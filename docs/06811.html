<html>
<head>
<title>Simple Strategy Pattern Using Attributes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用属性的简单策略模式</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/simple-strategy-pattern-using-attributes-880c55988215?source=collection_archive---------5-----------------------#2021-01-04">https://levelup.gitconnected.com/simple-strategy-pattern-using-attributes-880c55988215?source=collection_archive---------5-----------------------#2021-01-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="99d8" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">实用设计模式</h2><div class=""/><div class=""><h2 id="3990" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">如何改进传统的分支并理解策略模式如何降低圈复杂度。</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/ae1f327248e53f093f08365992fc5ef9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xuQwQiwtlVh8IdDfIiw0Zw.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">尼古拉斯·米勒德的插图</figcaption></figure><p id="fee4" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">您是否正在为策略模式而挣扎，或者想要额外的“建议”来应用它？</p><p id="d1e0" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">希望在本文结束时，您会对策略模式如何工作、为什么有用有一个清晰的理解，甚至可能认识到自定义C#属性如何为您的应用程序增加价值。</p><p id="283f" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">让我从一开始就说明这一点，即使您的主要语言是JavaScript、Python或像Swift这样的晦涩语言，我相信您会在这里找到一些有用的东西。阅读这篇文章并不需要成为C#开发人员。</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><p id="e690" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi mm translated"><span class="l mn mo mp bm mq mr ms mt mu di"> T </span>战略模式很可能是你尝试自己实现的第一个设计模式。您可能已经通过简单地使用传统的分支技术，如switch或if-else语句，实现了这个模式无数次。</p><p id="e48a" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">虽然这在很多情况下都很好，但是您可能需要在某个时候提高代码库的内部代码质量。您通常可以将分支语句转换成对象，从而将每个if或switch用例封装在一个非常简洁且易于理解的类中。本质上，这就是策略模式。就这么简单。</p><p id="4d70" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">在我看来，将分支分成不同的类提供了许多优势，比如高内聚，更少的类依赖，更低的<a class="ae mv" href="https://docs.codeclimate.com/docs/cognitive-complexity#:~:text=Cognitive%20Complexity%20is%20a%20measure,be%20to%20read%20and%20understand." rel="noopener ugc nofollow" target="_blank">认知和圈复杂度</a>，以及总体更短的类。批评家可能会指出更多的类是不可取的，因为每个额外的类和抽象都会增加一些开销，并增加整个项目的复杂性。</p><p id="2212" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">虽然将策略模式应用于较小的项目确实会有一些负面的结果，但是我认为长期的收益是值得的——但是这显然是您必须进行的逐案评估。</p><h2 id="fec8" class="mw mx it bd my mz na dn nb nc nd dp ne ls nf ng nh lw ni nj nk ma nl nm nn iz bi translated">在编写任何代码之前，创建一个测试项目。</h2><p id="2012" class="pw-post-body-paragraph lj lk it ll b lm no kd lo lp np kg lr ls nq lu lv lw nr ly lz ma ns mc md me im bi translated">在开始为策略模式创建类之前，先帮自己一个忙，创建一个测试项目。</p><p id="c313" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">每当我要实现一个设计或者重构我正在工作的应用程序的一部分时，我通常会从创建一个新的测试项目开始。你可能认为我这样做是因为我想严格坚持测试驱动开发，但事实并非如此。我发现这种方法在设计过程中提供了一种流畅的体验。代码覆盖率只是一个附加的好处。</p><h2 id="3d23" class="mw mx it bd my mz na dn nb nc nd dp ne ls nf ng nh lw ni nj nk ma nl nm nn iz bi translated">【属性】有什么好大惊小怪的？</h2><p id="9761" class="pw-post-body-paragraph lj lk it ll b lm no kd lo lp np kg lr ls nq lu lv lw nr ly lz ma ns mc md me im bi translated">如果你曾经使用过C#和。尤其是aspnet(core ),你非常习惯于将属性应用到你的类中，比如控制器、对象属性等等。但是，您真的知道这些特殊类的用途以及框架是如何使用它们的吗？</p><p id="8dec" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">属性基本上就像附加到现有类上的额外类型元数据。属性本身可能并不真的做什么——尽管它们可以——它们最常被其他类通过反射来搜索。</p><p id="ae8f" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">令人惊叹的是，您可以读取类型的元数据，包括提供给属性的数据，而不需要您感兴趣的元数据所在的类的实例。</p><p id="c041" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">如果没有这方面的实践经验，这听起来可能会不必要的复杂。当我们开始实现策略模式时，您将掌握它的窍门。</p><h1 id="e085" class="nt mx it bd my nu nv nw nb nx ny nz ne ki oa kj nh kl ob km nk ko oc kp nn od bi translated">传统分支技术的问题。</h1><p id="2b0b" class="pw-post-body-paragraph lj lk it ll b lm no kd lo lp np kg lr ls nq lu lv lw nr ly lz ma ns mc md me im bi translated"><a class="ae mv" href="https://github.com/NMillard/CSharpDesignPatterns/blob/main/src/Strategy/FileFormatting/Strategies.cs" rel="noopener ugc nofollow" target="_blank">📝如果你只是想看一些代码，可以看看GitHub repo。</a></p><p id="b2c0" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">想象一下，我们需要生成不同格式的事务报告，比如JSON和CSV——未来还会有更多的格式。</p><p id="c450" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">然而，如果您只需要生成JSON和CSV，您可以轻松地实现如下所示的伪策略。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oe"><img src="../Images/e1fbcf47b105d450d68d0e20ecf45fac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hubaZ7OJadyxTJYXe3RW9w.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">用if-else举例说明伪策略。图片由<a class="lh li ep" href="https://medium.com/u/7c7a43b3d9de?source=post_page-----880c55988215--------------------------------" rel="noopener" target="_blank">尼克拉斯·米勒德</a>提供</figcaption></figure><p id="dc64" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">这段代码肯定读起来不是很好，但是它非常简洁，并且完成了它的工作。本质上是策略模式减去策略对象。在我向您展示如何重构这段代码之前，让我们花几秒钟时间来理解为什么您可能不想要这样的代码。</p><p id="9eb6" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">我在上面的代码中只挑选了三个明显的问题。你可能会找到更多。</p><p id="7563" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">首先，这段看似简单的代码的圈复杂度为5——非常简单地说，圈复杂度代表源代码中决策的数量。这很麻烦，因为较高的圈数通常与可能的编码错误数量相关，并且与您需要多少测试用例相关。孤立地看，5并不是一个很高的数字，但是考虑到我们只有支持两种报告格式的代码，而且还计划支持更多格式，麻烦就要来了。</p><p id="1621" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">其次，修改任何代码都需要你在一个被无关代码包围的地方进行。例如，假设您需要更正CSV格式中的一个错误。这将要求您确保不要弄乱JSON格式的任何东西，即使它与手头的任务完全无关。</p><p id="3b01" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">最后，您可能会面临一些严重的构造函数膨胀。比方说，我们希望将JSON序列化程序设置作为构造函数参数。这种依赖性只与<em class="of">一个</em>分支相关。CSV格式分支根本不需要这种依赖。起初，这没什么大不了的。但是，一旦开始编写测试，即使测试的是CSV路径，也需要提供JSON序列化程序设置。<a class="ae mv" rel="noopener ugc nofollow" target="_blank" href="/dependency-injection-has-made-developers-lazy-255afc5bedf7">你的类依赖可能会增加，并且，在某些时候，它会导致依赖地狱。</a></p><h2 id="7f89" class="mw mx it bd my mz na dn nb nc nd dp ne ls nf ng nh lw ni nj nk ma nl nm nn iz bi translated">让我们实现策略模式。</h2><p id="c68d" class="pw-post-body-paragraph lj lk it ll b lm no kd lo lp np kg lr ls nq lu lv lw nr ly lz ma ns mc md me im bi translated">好了，以上是简单策略模式的大量背景知识，我们将把它应用到报告格式中。</p><p id="70e6" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">基本上，我们需要将每个分支语句的主体分成单独的类，并让这两个类实现一个共享接口。就这么简单。</p><p id="a237" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">首先，我们来定义一下接口。这没什么大不了的，因为我们只对一个返回字符串的方法感兴趣。然后，我们将每个分支逻辑封装在单独的类中。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi og"><img src="../Images/9fbe9ce29f9f0ffc4bb6851bf47d14c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MSpHZbG8EgdmWyp4GowVIQ.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">简单策略模式</figcaption></figure><p id="df86" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">至此，我们有了策略模式的工作实现。我们已经成功地将分支逻辑分成了类。您已经获得了改进的可维护性、更低的圈复杂度、关注点分离和可扩展性。</p><p id="4059" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">每个类也可以独立发展——添加或删除显式依赖项不会有弄乱分支的风险。</p><p id="0d7e" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">只有一个问题:要使用它，您可能仍然需要在代码中的某个地方使用一些if-else，在那里实例化正确的“formatter”类。</p><p id="8f4f" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">我们可以通过将元数据附加到我们的格式化程序类来修复这个if-else穷人的多态性。在C#中，我们创建“特殊”的属性类，可以应用于我们的类，扩展我们的类型数据。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oh"><img src="../Images/f561dd195941faa7e6aa9fed8fe7e083.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pw6fO5WuHH28fYgGWlOYSA.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">应用于类的C#属性。</figcaption></figure><p id="f03d" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">我们已经应用了属性，但是仍然没有任何代码读取属性值。我们需要一种方法，根据我们想要的报告文件格式来选择正确的格式化程序。</p><p id="aafd" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">您可以通过许多不同的方式来选择正确的格式化程序。根据用例，我会选择三种方法之一:创建扩展方法、<a class="ae mv" href="https://medium.com/swlh/factory-pattern-without-switch-this-is-how-it-should-be-done-cd895e356f44" rel="noopener">工厂</a>或<a class="ae mv" href="https://medium.com/swlh/the-most-overlooked-collection-feature-in-c-7ca2c67b408d" rel="noopener">定制集合类</a>。</p><p id="2f8c" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">我们将选择扩展方法。原因很简单，因为它易于实现，并且提供了很多价值。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oi"><img src="../Images/0fe20f701ec14222e37816fb015c3837.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NPFN_DaknpqRs2XpWxLmhA.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">C#扩展方法。</figcaption></figure><p id="94af" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">如果您不习惯扩展方法，这个语法可能看起来很奇怪。这个类所做的就是允许我们在格式化程序列表上使用自定义方法<code class="fe oj ok ol om b">PickFormatter(FileType)</code>。看一下第8行。这就是我们使用反射来读取自定义属性的地方。</p><p id="8cf1" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">下面的代码片段展示了如何使用我们的新类和扩展方法。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oh"><img src="../Images/8995878e688386de4d1df84024d3c421.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LqvnEcAMqKhn-ISSNU9-oA.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">格式化程序类和扩展方法的演示。</figcaption></figure><h2 id="fdb1" class="mw mx it bd my mz na dn nb nc nd dp ne ls nf ng nh lw ni nj nk ma nl nm nn iz bi translated">最终产品。</h2><p id="1b7b" class="pw-post-body-paragraph lj lk it ll b lm no kd lo lp np kg lr ls nq lu lv lw nr ly lz ma ns mc md me im bi translated">总而言之，我们有更多的代码。我们增加了项目的复杂性。但是，每一部分都更容易测试和理解。你所采取的每一种方法都会涉及到一些权衡。</p><p id="1f92" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">任何开发人员都需要建立一个工具和方法库。我希望这个例子能让你对如何实现策略模式有一个新的认识。</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><pre class="ks kt ku kv gt on om oo op aw oq bi"><span id="6082" class="mw mx it om b gy or os l ot ou"><strong class="om jd">Resources for the curious</strong><br/>--------------------------<br/><a class="ae mv" href="https://www.lexjansen.com/pharmasug/2004/FDACompliance/FC06.pdf" rel="noopener ugc nofollow" target="_blank">Using Cyclomatic Complexity to Determine Test Coverage for SAS programs</a> by Michael C. Harris</span></pre><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ov"><img src="../Images/745b6019f001879654cae7d29d306420.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*LZ0-rAawOB4iv6uI.png"/></div></div></figure><p id="cc49" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated"><strong class="ll jd"> Nicklas Millard </strong>是一名软件开发工程师，供职于一家发展最快的银行，负责构建任务关键型金融服务基础设施。</p><p id="7bfa" class="pw-post-body-paragraph lj lk it ll b lm ln kd lo lp lq kg lr ls lt lu lv lw lx ly lz ma mb mc md me im bi translated">此前，他是Big4的高级技术顾问，为商业客户和政府机构开发软件。</p><blockquote class="ow ox oy"><p id="71d7" class="lj lk of ll b lm ln kd lo lp lq kg lr oz lt lu lv pa lx ly lz pb mb mc md me im bi translated"><a class="ae mv" href="https://www.youtube.com/channel/UCaUy83EAkVdXsZjF3xGSvMw" rel="noopener ugc nofollow" target="_blank">新的YouTube频道(@Nicklas Millard) </a></p><p id="f1a4" class="lj lk of ll b lm ln kd lo lp lq kg lr oz lt lu lv pa lx ly lz pb mb mc md me im bi translated"><em class="it">连接上</em> <a class="ae mv" href="https://www.linkedin.com/in/nicklasmillard/" rel="noopener ugc nofollow" target="_blank"> <em class="it"> LinkedIn </em> </a></p></blockquote></div></div>    
</body>
</html>