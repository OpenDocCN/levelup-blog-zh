<html>
<head>
<title>An Approach to JavaScript Object Schema Migration</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一种JavaScript对象模式迁移的方法</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/an-approach-to-javascript-object-schema-migration-ae1bd9f0ce78?source=collection_archive---------6-----------------------#2019-12-30">https://levelup.gitconnected.com/an-approach-to-javascript-object-schema-migration-ae1bd9f0ce78?source=collection_archive---------6-----------------------#2019-12-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/ee62e03627dc09e7ada8fa9c0b2d6f9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eySS3SIKN6Z3rGpzu7GX4g.jpeg"/></div></div></figure><h1 id="6f72" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">介绍</h1><p id="c0a6" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">最近，我发现自己的应用程序严重依赖于状态对象。这对于单页应用程序(SPAs)来说是相当典型的，当您的状态对象的模式发生重大变化，并且您的用户将数据保存在旧模式下时，这可能会带来挑战。</p><p id="7b10" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">在这篇文章中，我将探索我为解决这个问题而提出的一个概念验证解决方案。虽然我确信已经存在模式迁移工具，但我认为这将是一个有趣且有教育意义的主题探索！</p><p id="96ae" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi">***</p><h2 id="5b33" class="mc kc it bd kd md me dn kh mf mg dp kl lk mh mi kp lo mj mk kt ls ml mm kx mn bi translated">通过注册我的免费时事通讯，在您的收件箱中获得快速JavaScript技巧！</h2><figure class="mo mp mq mr gt ju"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="8355" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi">***</p><h1 id="44b3" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">一个例题</h1><p id="8035" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">假设我已经创建了一个应用程序，其中有一个用户，用户可以输入他们的宠物类型和品种。在启动MVP时，我的状态对象看起来像这样:</p><pre class="mo mp mq mr gt mu mv mw mx aw my bi"><span id="9136" class="mc kc it mv b gy mz na l nb nc">const state = {<br/>  person: {<br/>    name: 'Edgar',<br/>    pets: {<br/>      type: 'dog',<br/>      name: 'Daffodil',<br/>    },<br/>  },<br/>};</span></pre><p id="1d53" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">这对MVP来说很好，但很快我意识到我不希望<code class="fe nd ne nf mv b">pets</code>地产生活在<code class="fe nd ne nf mv b">person</code>地产下，而是希望它在<code class="fe nd ne nf mv b">state</code>下成为自己的地产。换句话说，我的理想状态可能是这样的:</p><pre class="mo mp mq mr gt mu mv mw mx aw my bi"><span id="8675" class="mc kc it mv b gy mz na l nb nc">const state = {<br/>  person: {<br/>    name: 'Edgar',<br/>  },<br/>  pets: {<br/>    type: 'dog',<br/>    name: 'Daffodil',<br/>  },<br/>};</span></pre><p id="124a" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">虽然我希望能够在我的SPA中进行这种更改，但我担心现有的应用程序用户会将我的原始模式保存在某个地方(例如，本地存储、nosql、JSON字符串等)。).如果我加载了旧的数据，但是我的应用程序需要新的模式，我可能会尝试在错误的地方访问属性(例如，<code class="fe nd ne nf mv b">state.pets.type</code>对<code class="fe nd ne nf mv b">state.person.pets.type</code>)，从而导致问题。</p><h1 id="5fe3" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">模式迁移拯救世界！</h1><p id="e821" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">模式迁移不是一个新概念；它被用于在不同版本的应用程序之间迁移数据库表已经有一段时间了。在这篇文章中，我将使用模式迁移背后相同的基本概念来迁移JavaScript对象。</p><h1 id="9384" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">定义我们的迁移阵列</h1><p id="174d" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">让我们定义一组要运行的迁移。每个迁移将有一个<code class="fe nd ne nf mv b">from</code>、<code class="fe nd ne nf mv b">to</code>、<code class="fe nd ne nf mv b">up</code>和<code class="fe nd ne nf mv b">down</code>属性。<code class="fe nd ne nf mv b">from</code>和<code class="fe nd ne nf mv b">to</code>属性将分别代表较低和较高的版本，而<code class="fe nd ne nf mv b">up</code>和<code class="fe nd ne nf mv b">down</code>属性将是将模式从<code class="fe nd ne nf mv b">from</code>版本移动到<code class="fe nd ne nf mv b">to</code>版本的函数，反之亦然。这听起来可能有点混乱，但是我认为在我们的人/宠物的例子中会更有意义。</p><p id="80a6" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">让我们写第一个迁移。</p><pre class="mo mp mq mr gt mu mv mw mx aw my bi"><span id="1c3e" class="mc kc it mv b gy mz na l nb nc">const migrations = [<br/>  {<br/>    from: '1.0',<br/>    to: '1.1',<br/>    up: schema =&gt; {<br/>      const newSchema = {<br/>        version: '1.1',<br/>        person: {<br/>          name: schema.person.name,<br/>        },<br/>        pets: {<br/>          ...schema.person.pets,<br/>        },<br/>      };<br/>      return newSchema;<br/>    },<br/>    down: schema =&gt; {<br/>      const newSchema = {<br/>        version: '1.0',<br/>        person: {<br/>          ...schema.person,<br/>          pets: { ...schema.pets },<br/>        },<br/>      };<br/>      return newSchema;<br/>    },<br/>  },<br/>];</span></pre><p id="e39a" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">如果我们有一个“1.0”版本的模式，那么这个对象的<code class="fe nd ne nf mv b">up</code>方法会将这个模式转换成“1.1”。相反，如果我们有一个“1.1”版本的模式，<code class="fe nd ne nf mv b">down</code>方法会将该模式转换为“1.0”。</p><h1 id="e254" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">实现迁移</h1><p id="8d9c" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">这在概念上很酷，但是我们需要创建一个实际执行迁移的函数。为此，我们将创建一个<code class="fe nd ne nf mv b">migrate</code>函数，它将一个模式和该模式应该迁移到的版本号作为参数。</p><pre class="mo mp mq mr gt mu mv mw mx aw my bi"><span id="c535" class="mc kc it mv b gy mz na l nb nc">const migrate = (schema, toVersion) =&gt; {<br/>  const fromVersion = schema.version;<br/>  const direction = upOrDown(fromVersion, toVersion);<br/>  if (direction === 'same') {<br/>    return schema;<br/>  }<br/>  const currentMigration = migrations.find(<br/>    migration =&gt; migration[direction === 'up' ? 'from' : 'to'] === fromVersion<br/>  );<br/>  const newSchema = currentMigration[direction](schema);<br/>  return migrate(newSchema, toVersion);<br/>};</span></pre><p id="3ffa" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">您可能会注意到关于这个函数的一些事情:它是递归的(它不会停止，直到我们迁移到我们的目标版本)，并且它引用了一个助手函数，<code class="fe nd ne nf mv b">upOrDown</code>，我已经在下面定义了它。这个函数只是帮助确定迁移的方向(1.0到1.1向上，1.1到1.0向下)。</p><pre class="mo mp mq mr gt mu mv mw mx aw my bi"><span id="11fb" class="mc kc it mv b gy mz na l nb nc">const upOrDown = (fromVersion, toVersion) =&gt; {<br/>  const fromNumbers = fromVersion.split('.').map(el =&gt; Number(el));<br/>  const toNumbers = toVersion.split('.').map(el =&gt; Number(el));<br/>  for (let i = 0; i &lt; fromNumbers.length; i++) {<br/>    if (fromNumbers[i] &lt; toNumbers[i]) {<br/>      return 'up';<br/>    }<br/>    if (fromNumbers[i] &gt; toNumbers[i]) {<br/>      return 'down';<br/>    }<br/>  }<br/>  return 'same';<br/>};</span></pre><h1 id="913f" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">带它去试运行</h1><p id="0029" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">让我们创建两个对象，一个是“1.0”版本的模式，另一个是“1.1”版本的模式。目标是将“1.0”模式迁移到“1.1”，将“1.1”模式迁移到“1.0”。</p><pre class="mo mp mq mr gt mu mv mw mx aw my bi"><span id="12de" class="mc kc it mv b gy mz na l nb nc">const schemaA = {<br/>  version: '1.0',<br/>  person: {<br/>    name: 'Edgar',<br/>    pets: {<br/>      type: 'dog',<br/>      name: 'Daffodil',<br/>    },<br/>  },<br/>};</span><span id="2125" class="mc kc it mv b gy ng na l nb nc">const schemaB = {<br/>  version: '1.1',<br/>  person: {<br/>    name: 'Edgar',<br/>  },<br/>  pets: {<br/>    type: 'dog',<br/>    name: 'Daffodil',<br/>  },<br/>};</span></pre><p id="836f" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">现在，让我们运行我们的迁移。</p><pre class="mo mp mq mr gt mu mv mw mx aw my bi"><span id="d5e1" class="mc kc it mv b gy mz na l nb nc">// From 1.0 to 1.1<br/>console.log(migrate(schemaA, '1.1'));<br/>/*<br/>{ version: '1.1',<br/>  person: { name: 'Edgar' },<br/>  pets: { type: 'dog', name: 'Daffodil' } }<br/>*/</span><span id="e31e" class="mc kc it mv b gy ng na l nb nc">// From 1.1 to 1.0<br/>console.log(migrate(schemaB, '1.0'));<br/>/*<br/>{ version: '1.0',<br/>  person: { name: 'Edgar', pets: { type: 'dog', name: 'Daffodil' } } }<br/>*/</span></pre><p id="b952" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">完美！我们现在可以从一个模式版本“向上”迁移到下一个版本，或者“向下”迁移回来。</p><h1 id="4711" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">又一次架构更改！</h1><p id="f94e" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">我现在意识到一个人可以养多只宠物，为什么不呢？所以，我们的<code class="fe nd ne nf mv b">pets</code>键实际上应该是一个数组，而不是一个对象。此外，我意识到我们的<code class="fe nd ne nf mv b">person</code>键可能只是这个人的名字，而不是有一个<code class="fe nd ne nf mv b">name</code>键(我已经决定我们不会再有任何与这个人相关的道具)。这意味着一个新的模式，版本1.2，看起来像这样:</p><pre class="mo mp mq mr gt mu mv mw mx aw my bi"><span id="8bd6" class="mc kc it mv b gy mz na l nb nc">const state = {<br/>  person: 'Edgar',<br/>  pets: [<br/>    {<br/>      type: 'dog',<br/>      name: 'Daffodil',<br/>    },<br/>  ],<br/>};</span></pre><p id="9527" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">所以，让我们写一个从版本1.1到1.2的迁移。</p><pre class="mo mp mq mr gt mu mv mw mx aw my bi"><span id="d667" class="mc kc it mv b gy mz na l nb nc">const migrations = [<br/>  {<br/>    from: '1.0',<br/>    to: '1.1',<br/>    up: schema =&gt; {<br/>      const newSchema = {<br/>        version: '1.1',<br/>        person: {<br/>          name: schema.person.name,<br/>        },<br/>        pets: {<br/>          ...schema.person.pets,<br/>        },<br/>      };<br/>      return newSchema;<br/>    },<br/>    down: schema =&gt; {<br/>      const newSchema = {<br/>        version: '1.0',<br/>        person: {<br/>          ...schema.person,<br/>          pets: { ...schema.pets },<br/>        },<br/>      };<br/>      return newSchema;<br/>    },<br/>  },<br/>  {<br/>    from: '1.1',<br/>    to: '1.2',<br/>    up: schema =&gt; {<br/>      const newSchema = {<br/>        version: '1.2',<br/>        person: schema.person.name,<br/>        pets: [schema.pets],<br/>      };<br/>      return newSchema;<br/>    },<br/>    down: schema =&gt; {<br/>      const newSchema = {<br/>        version: '1.1',<br/>        person: {<br/>          name: schema.person,<br/>        },<br/>        pets: schema.pets[0],<br/>      };<br/>      return newSchema;<br/>    },<br/>  },<br/>];</span></pre><h1 id="2e88" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">多版本迁移</h1><p id="6cb2" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">还记得我们的<code class="fe nd ne nf mv b">migrate</code>函数是如何递归的吗？当我们需要迁移多个版本时，这变得非常有用。假设我们想从1.0模式迁移到1.2模式，反之亦然。我们能做到！</p><pre class="mo mp mq mr gt mu mv mw mx aw my bi"><span id="a65c" class="mc kc it mv b gy mz na l nb nc">// 1.0 to 1.2<br/>console.log(migrate(schemaA, '1.2'));<br/>/*<br/>{ version: '1.2',<br/>  person: 'Edgar',<br/>  pets: [ { type: 'dog', name: 'Daffodil' } ] }<br/>*/</span><span id="4cf1" class="mc kc it mv b gy ng na l nb nc">const schemaC = {<br/>  version: '1.2',<br/>  person: 'Edgar',<br/>  pets: [<br/>    {<br/>      type: 'dog',<br/>      name: 'Daffodil',<br/>    },<br/>  ],<br/>};<br/>// 1.2 to 1.0<br/>console.log(migrate(schemaC, '1.1'));<br/>/*<br/>{ version: '1.0',<br/>  person: { name: 'Edgar', pets: { type: 'dog', name: 'Daffodil' } } }<br/>*/</span></pre><p id="3a8d" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">嘿，成功了！</p><h1 id="b701" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">结论</h1><p id="4fa0" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">这是对模式迁移世界的有趣探索！在拼凑了一些模式迁移功能后，我现在相当有信心能够使用“自己动手”的方法或现有的包来实现它。</p></div></div>    
</body>
</html>