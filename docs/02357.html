<html>
<head>
<title>MongoDB: Maintain Data Integrity with Atomic Operations</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">MongoDB:用原子操作维护数据完整性</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/mongodb-maintain-data-integrity-with-atomic-operations-7c40d505b41e?source=collection_archive---------9-----------------------#2020-03-08">https://levelup.gitconnected.com/mongodb-maintain-data-integrity-with-atomic-operations-7c40d505b41e?source=collection_archive---------9-----------------------#2020-03-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a1a3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">仔细看看MongoDB的$set、$setOnInsert、$push、$pull和$inc更新操作符</h2></div><p id="253f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我和我在<a class="ae le" href="https://nightlife.com.au" rel="noopener ugc nofollow" target="_blank"> Nightlife Music </a>的团队已经使用<a class="ae le" href="https://www.mongodb.com/" rel="noopener ugc nofollow" target="_blank"> MongoDB </a>一年多了，用来存储我们音乐系统状态的对象表示，在这段时间里，我们学到了(并且仍在学习)很多关于如何正确使用和如何<em class="lf">而不是</em>使用数据库的知识。</p><p id="bc0b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，简单介绍一下我们如何使用它以及为什么使用它。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi lg"><img src="../Images/82d97f2c01dce006180ca37faea59b8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*xOVUR3DMDUfaguq5cIDAsw.jpeg"/></div></figure><p id="84ab" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们的公司为企业提供音乐解决方案，在一个场所播放的音乐存储在一台保持自身状态的计算机上，但当它的状态发生变化时，也会向我们的云基础设施发送通知。我们还可以从云中更改它的状态，当我们这样做时，我们会收到相同的通知。</p><h2 id="9e2c" class="lo lp it bd lq lr ls dn lt lu lv dp lw kr lx ly lz kv ma mb mc kz md me mf mg bi translated">我们如何处理从系统中收到的通知？</h2><p id="6162" class="pw-post-body-paragraph ki kj it kk b kl mh ju kn ko mi jx kq kr mj kt ku kv mk kx ky kz ml lb lc ld im bi translated">为了能够确定需要做出什么改变，我们需要两条信息:机器的<em class="lf">当前</em>状态，以及<em class="lf">预期</em>状态。预期状态通常由用户通过GUI填充，而机器的当前状态通过接收通知和更新该系统的MongoDB文档来存储。</p><p id="9954" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将这两个对象都作为BSON对象存储在MongoDB中(在这里阅读关于JSON和BSON的更多信息<a class="ae le" href="https://www.mongodb.com/json-and-bson" rel="noopener ugc nofollow" target="_blank"/>),当需要应用差异时，我们只需检索这两个对象，比较这两个对象，并计算出我们需要向系统发送什么API调用来改变其状态以匹配预期的状态。</p><p id="69fd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这个模型中，<strong class="kk iu">我们有一个准确的系统当前状态</strong>是至关重要的，否则预期值和当前值之间的差异将产生不正确的动作。这就是MongoDB及其在任何粒度级别更新属性的能力的用武之地。</p><h2 id="b564" class="lo lp it bd lq lr ls dn lt lu lv dp lw kr lx ly lz kv ma mb mc kz md me mf mg bi translated">我们最初是如何接近MongoDB的</h2><p id="e5cd" class="pw-post-body-paragraph ki kj it kk b kl mh ju kn ko mi jx kq kr mj kt ku kv mk kx ky kz ml lb lc ld im bi translated">当我们第一次使用MongoDB时，我们的过程看起来有点像这样:</p><pre class="lh li lj lk gt mm mn mo mp aw mq bi"><span id="81c4" class="lo lp it mn b gy mr ms l mt mu">// Receive state update notification from music system<br/>// Retrieve <strong class="mn iu">whole</strong> state from MongoDB by ID<br/>// Replace relevant section(s) of state with data from notification <br/>// Save <strong class="mn iu">entire</strong> state back to MongoDB  </span></pre><p id="4329" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您<strong class="kk iu">一次只处理一个通知</strong>并且只有一个应用程序实例在运行，这个过程虽然不是很高效，但会保持您的数据完好无损。我们的情况不是这样。</p><p id="6e63" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，我们通过<a class="ae le" href="https://www.rabbitmq.com/" rel="noopener ugc nofollow" target="_blank"> RabbitMQ </a>接收这些通知，我们的应用程序一次从队列中拉出多个通知。此外，当我们收到大量通知时，我们可能希望扩展我们的应用程序来运行多个重复实例，以跟上入口。</p><p id="cf01" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面的代码片段显示了在MongoDB中保存整个文档时，通知的并行处理可能会相互冲突和覆盖:</p><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="mv mw l"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">展示了MongoDB中的文档在检索整个文档、修改和保存它时如何变得不正确。</figcaption></figure><p id="6413" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的问题是，如果在两个通知中的任何一个有时间写入新状态之前检索当前状态，那么最后一个写入将覆盖第一个写入的更新值(在上面的情况下，<code class="fe nb nc nd mn b">b</code>的更新值将被来自<strong class="kk iu">原始</strong>当前状态的值覆盖，其中<code class="fe nb nc nd mn b">a</code>的变化的通知被检索。</p><p id="dc02" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面显示了当我们只是并行处理<strong class="kk iu">两个</strong>通知时，状态如何可能与系统发送给我们的不匹配。想象一下，如果我们处理<em class="lf">千个</em>会发生什么。相对于系统的<em class="lf">实际</em>状态，我们可能会偏离MongoDB中为我们的系统存储的内容。这就是“set”风格操作的用武之地，因为我们可以只对我们想要更新的属性执行原子操作。</p><h2 id="2486" class="lo lp it bd lq lr ls dn lt lu lv dp lw kr lx ly lz kv ma mb mc kz md me mf mg bi translated">我们如何确保不会覆盖准确的数据？</h2><p id="a5c9" class="pw-post-body-paragraph ki kj it kk b kl mh ju kn ko mi jx kq kr mj kt ku kv mk kx ky kz ml lb lc ld im bi translated">在我们进入MongoDB代码来解决这个问题之前，让我们看一下在同样的情况下我们会对SQL做什么。假设一行和列代表一个对象:</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/8dd22ea88722162e9029fb335a8081b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1324/format:webp/1*BaZ55km8Ka2VHfSThaGh4g.png"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">SQL表“system_states ”,显示我们的系统状态数据如何在SQL中表示</figcaption></figure><p id="7202" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了更新<code class="fe nb nc nd mn b">a</code>的值，我们不会检索整行，更改<code class="fe nb nc nd mn b">a</code>然后再次设置整行(尽管我很确定我们已经被发现这样做了一两次),原因与我们不想写回整个MongoDB文档的原因相同:我们可能会在应用程序中处理更新时清除另一个事务所做的任何更改。</p><p id="2781" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们会这样做:</p><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="mv mw l"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">在两个并行查询中更新一行中两个不同字段的简单SQL语句示例</figcaption></figure><p id="e97c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请注意，<code class="fe nb nc nd mn b">a</code>和<code class="fe nb nc nd mn b">b</code>的值不可能与我们收到的通知不匹配，因为我们是在单个表格单元格上执行原子操作。</p><h2 id="71e3" class="lo lp it bd lq lr ls dn lt lu lv dp lw kr lx ly lz kv ma mb mc kz md me mf mg bi translated">用MongoDB的方式处理它</h2><p id="bba7" class="pw-post-body-paragraph ki kj it kk b kl mh ju kn ko mi jx kq kr mj kt ku kv mk kx ky kz ml lb lc ld im bi translated">那么，为什么我们在处理MongoDB文档时不执行相同类型的操作呢？对一些人来说这似乎是显而易见的，也许我们应该在开始之前更仔细地阅读文档，但是学习下面的操作符完全改变了我们使用MongoDB的方式。那么，让我们只看几个。</p><p id="ccfc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们使用的一些是:</p><p id="7b04" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae le" href="https://docs.mongodb.com/manual/reference/operator/update/set/#up._S_set" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu"> $set </strong> </a> <strong class="kk iu"> </strong> —相当于与其同名的SQL，设置单个字段的值</p><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="mv mw l"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">使用$set运算符更新属性“a”和“b”</figcaption></figure><p id="6078" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae le" href="https://docs.mongodb.com/manual/reference/operator/update/setOnInsert/#up._S_setOnInsert" rel="noopener ugc nofollow" target="_blank"><strong class="kk iu">$seton insert</strong></a><strong class="kk iu"/>—类似$ set，但仅当文档是一个<em class="lf">新</em>文档时，才将字段的值设置为指定值。我们可以用它来设置文档的创建日期:</p><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="mv mw l"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">当找不到现有文档时，将属性“created_at”设置为当前日期和时间。请注意“upsert: true”选项，如果没有找到，它将创建文档</figcaption></figure><p id="fd65" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae le" href="https://docs.mongodb.com/manual/reference/operator/update/push/#up._S_push" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu"> $push </strong> </a> —将项目推入数组类型的属性中。我们还可以指定一个可选的索引来放置项目。可能被用来记录事件的历史，就像我们下面的<code class="fe nb nc nd mn b">save_history</code></p><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="mv mw l"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">将包含带有今天日期的“saved_at”和带有用户名的“saved_by”的对象推入save_history属性</figcaption></figure><p id="6ec6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae le" href="https://docs.mongodb.com/manual/reference/operator/update/pull/#up._S_pull" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu"> $pull </strong> </a> —从数组中拉出符合我们条件的项目。一个示例用例可能是取消用户接收有关对象变更的电子邮件更新:</p><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="mv mw l"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">从现有数组中提取一项</figcaption></figure><p id="ab36" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae le" href="https://docs.mongodb.com/manual/reference/operator/update/inc/#up._S_inc" rel="noopener ugc nofollow" target="_blank"><strong class="kk iu">【Inc】</strong></a><strong class="kk iu"/>-数值字段按指定数量的值。我们可以用它来跟踪文档的版本号。注意，如果属性不存在，第一个值将等于指定的值<code class="fe nb nc nd mn b">$inc:</code></p><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="mv mw l"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">对于每个update语句，将属性“$inc”增加1。如果该属性不存在，第一条语句会将其设置为1</figcaption></figure><h2 id="121a" class="lo lp it bd lq lr ls dn lt lu lv dp lw kr lx ly lz kv ma mb mc kz md me mf mg bi translated">主要是原子和安全的…</h2><p id="9a51" class="pw-post-body-paragraph ki kj it kk b kl mh ju kn ko mi jx kq kr mj kt ku kv mk kx ky kz ml lb lc ld im bi translated">除了<code class="fe nb nc nd mn b"><strong class="kk iu">$push</strong></code> <strong class="kk iu"> </strong>之外，上述所有操作符都是完全原子化的，无论我们以何种顺序处理通知，都将保护您的数据安全。<code class="fe nb nc nd mn b"><strong class="kk iu">$push</strong></code> <strong class="kk iu"> </strong>当我们不在乎对象在数组中出现的顺序时也是可以的，但对我们来说并不总是这样。当顺序很重要时，事情会变得有点棘手，如果不检索相关属性的当前状态，可能无法执行原子操作。</p><p id="fc56" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这些只是可以用MongoDB执行的一些原子写操作的几个例子。更多可以在这里找到<a class="ae le" href="https://docs.mongodb.com/manual/reference/operator/update/#id1" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="a3d8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您想了解更多关于当数据无序地从异步事件传入时如何处理对<strong class="kk iu"> same </strong>属性的并发更新，请看看这篇文章:<a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/mongodb-handling-parallel-writes-fa7744565313"> MongoDB:处理来自异步事件的并发更新</a>。</p><p id="53b6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢阅读和快乐蒙格。</p><h2 id="5e27" class="lo lp it bd lq lr ls dn lt lu lv dp lw kr lx ly lz kv ma mb mc kz md me mf mg bi translated">资源</h2><ol class=""><li id="f63d" class="nf ng it kk b kl mh ko mi kr nh kv ni kz nj ld nk nl nm nn bi translated"><a class="ae le" href="https://nightlife.com.au" rel="noopener ugc nofollow" target="_blank">夜生活音乐</a></li><li id="f18d" class="nf ng it kk b kl no ko np kr nq kv nr kz ns ld nk nl nm nn bi translated"><a class="ae le" href="https://www.mongodb.com/" rel="noopener ugc nofollow" target="_blank"> MongoDB </a></li><li id="3b20" class="nf ng it kk b kl no ko np kr nq kv nr kz ns ld nk nl nm nn bi translated"><a class="ae le" href="https://www.mongodb.com/json-and-bson" rel="noopener ugc nofollow" target="_blank"> JSON和BSON </a></li><li id="82b7" class="nf ng it kk b kl no ko np kr nq kv nr kz ns ld nk nl nm nn bi translated"><a class="ae le" href="https://www.rabbitmq.com/" rel="noopener ugc nofollow" target="_blank"> RabbitMQ </a></li><li id="ff91" class="nf ng it kk b kl no ko np kr nq kv nr kz ns ld nk nl nm nn bi translated">MongoDB <a class="ae le" href="https://docs.mongodb.com/manual/reference/operator/update/#id1" rel="noopener ugc nofollow" target="_blank">更新操作员</a></li></ol></div></div>    
</body>
</html>