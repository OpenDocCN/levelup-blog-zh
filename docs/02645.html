<html>
<head>
<title>Getting Dumped By Golang’s Garbage Collector</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">被Golang的垃圾收集者抛弃</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/getting-dumped-by-golangs-garbage-collector-639fe38408e7?source=collection_archive---------7-----------------------#2020-03-27">https://levelup.gitconnected.com/getting-dumped-by-golangs-garbage-collector-639fe38408e7?source=collection_archive---------7-----------------------#2020-03-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="012c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">众所周知，Go是一种垃圾收集语言，我们的应用程序运行时创建的任何堆栈|堆内存都将被Go自动垃圾收集。</p><p id="8986" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我也和其他人一样有着相似的假设，直到我遇到了由垃圾收集员造成的第一个障碍。</p></div><div class="ab cl kl km hu kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="ij ik il im in"><p id="61ca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从问题陈述开始，我们有一个每天运行两次的计划生成任务。就内存和CPU而言，这是一项非常资源密集型的任务，它对从多个来源收集的数据进行一些复杂的聚合，并将其转储到数据库中。</p><p id="634e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们用来保存所有聚合数据的内部数据结构是一个复杂的地图数据结构，其中键是一个字符串，值是一个字符串片段。</p><p id="81bc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">预期地图大小- &gt; 6个键，每个键的值为15-30个字符串的片数。</strong></p><p id="3eb8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我们使用pprof对内存和CPU进行基准测试时，一切似乎都很好，没有一个内存泄漏或比预期更高的CPU利用率。我们对性能分析的结果非常有信心，因此我们将该特性投入使用，它在我们的后台机器上运行任务，这是一台高端虚拟机。</p><p id="cbe5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当任务执行时，一切似乎都很好，我们从未回顾过资源消耗，直到对基础设施成本进行了审查。这是我们发现一些异常行为的时候。</p><p id="a6f4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们有一个40GB RAM的后台机器，每当执行计划的任务时，它都会消耗大约24GB的RAM，因为我们将数据存储在map中，这没什么问题，但是一旦生成结束，map消耗的内存就不会释放回操作系统，我们的后台机器不是以40GB的空闲空间运行，而是60%被填满，并以16GB运行，直到容器再次重新启动。</p><p id="8592" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我开始调试这种异常行为，研究为什么即使在执行了垃圾收集器之后，内存也没有被释放。</p><p id="0571" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第一个问题是-&gt;作为go例程或并发的一部分，是否有任何内存泄漏？(我调试了好几天，没发现任何漏洞)</p><p id="cb03" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">调试开始了，秒变分，分变小时，小时变天，却不知道为什么会这样。</p><p id="d474" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">经过数百次的试验和错误，以及数十次的测试发布，我终于明白了，当堆对象被创建时，即使手动运行<strong class="jp ir">运行时，GO运行时也无法释放为它分配的内存。GC()。</strong>作为证实我的怀疑的一部分，我用2.5 GB RAM运行了一个docker容器，并编写了一个测试API，它所做的只是创建一个1000万条记录的映射，然后返回一条成功消息。</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi ks"><img src="../Images/40635b4c54b9c27667027e5af3709cf0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r0ZEMRknI4ht0bNWexKZQQ.png"/></div></div></figure><p id="c1e0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">结果令人震惊。</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi le"><img src="../Images/a005ee8e808b0c7b80d2cc7111ee0720.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xgkh-utplstJ-hV8rt_Lbw.png"/></div></div></figure><p id="818f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您看一下上面的截图，在运行API之前，容器的内存是2.4GB，在填充map的过程中，内存逐渐减少。但是，根据我的假设，即使API创建了1000万条记录并将成功响应返回给客户端，GO runtime占用的内存也必须释放回OS，这是不可能的。此时，我开始意识到代码中没有内存泄漏。这都是因为分配的堆内存没有被释放。</p><p id="e052" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此时，我的脑袋一片空白，因为修复的范围超出了我的控制，我没有失去希望，开始尝试各种可能性。</p><ul class=""><li id="27ba" class="lf lg iq jp b jq jr ju jv jy lh kc li kg lj kk lk ll lm ln bi translated">步骤1:我试着在延迟时将贴图设置为零。不出所料，结果不太好。</li><li id="fe96" class="lf lg iq jp b jq lo ju lp jy lq kc lr kg ls kk lk ll lm ln bi translated">第2步:我尝试了defer上的<strong class="jp ir"> delete函数</strong>，在返回之前我删除了每一个键。但令人惊讶的是，这并没有成功，容器仍然拥有60%的内存</li><li id="0e29" class="lf lg iq jp b jq lo ju lp jy lq kc lr kg ls kk lk ll lm ln bi translated">步骤3:我尝试执行运行时。令我惊讶的是，这也不起作用。</li><li id="ee12" class="lf lg iq jp b jq lo ju lp jy lq kc lr kg ls kk lk ll lm ln bi translated">就在我失去希望的时候，<strong class="jp ir">调试的这个神奇的功能出现了。FreeOSMemory() </strong>与垃圾收集器的功能相同。让世界停下来，做标记，然后横扫一切，但这并不局限于更小的数据点。这个函数的作用是试图扫描所有没有被使用或空闲的内存，并将内存返回给操作系统。</li><li id="6d1c" class="lf lg iq jp b jq lo ju lp jy lq kc lr kg ls kk lk ll lm ln bi translated">FreeOSMemory是这样工作的。在任务被执行并且垃圾收集器被触发后，它会清除保存我的GO运行时的内存，并通知操作系统这些堆对象是空闲的，可以被操作系统回收。现在取决于操作系统是否回收内存。</li></ul><p id="0e94" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">使用FreeOSMemory释放内存后的结果</strong></p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi le"><img src="../Images/fc41c0bddf8654cd5755a0482754cd57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fYDjqKG6iQK-VNRwIWLRog.png"/></div></div></figure><p id="be5b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从所有这些分析中，我学到的是不要盲目地相信垃圾收集器会处理所有的事情。在大规模工作时，一定要跟踪系统资源是如何被利用的。</p><p id="d3d9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">哦，对了，我忘了通知一件更重要的事。FreeOSMemory只能在Go版本1.12以下运行。根据Go 1.12的官方发行说明，堆消耗的内存将被重用，直到满足某些条件才会返回给操作系统。</p><p id="4737" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了退回到以前的版本，使用<strong class="jp ir"> GODEBUG=madvdontneed=1 </strong>启用您的容器，这将最终从运行时释放内存并将其返回给操作系统。</p></div></div>    
</body>
</html>