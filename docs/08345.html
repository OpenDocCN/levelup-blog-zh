<html>
<head>
<title>A Heap of Go Generics</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一堆Go泛型</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/a-heap-of-go-generics-cd20f362a76?source=collection_archive---------3-----------------------#2021-04-23">https://levelup.gitconnected.com/a-heap-of-go-generics-cd20f362a76?source=collection_archive---------3-----------------------#2021-04-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/2c9469ae3bb7e6cdccb0e2497c01e2d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:790/format:webp/1*OIoubGYxH917VAyW9nGe8Q.jpeg"/></div></figure><p id="dde7" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我来自使用<a class="ae kv" href="https://en.wikipedia.org/wiki/Generic_programming" rel="noopener ugc nofollow" target="_blank">泛型</a>的语言，此外，我在Go中编写的样板代码的数量也有问题。所以，我一直带着希望期待着去仿制药。我已经记住了特定类型的泛型用例，当我发现我可以在<a class="ae kv" href="https://go2goplay.golang.org/" rel="noopener ugc nofollow" target="_blank">的Go2 Go游乐场</a>玩Go的泛型时。我决定试试看能不能解决一个。对于那些想要T4 TLDR的人来说，答案是:是的！</p><h2 id="be99" class="kw kx it bd ky kz la dn lb lc ld dp le ki lf lg lh km li lj lk kq ll lm ln lo bi translated">我的使用案例</h2><p id="4d7e" class="pw-post-body-paragraph jx jy it jz b ka lp kc kd ke lq kg kh ki lr kk kl km ls ko kp kq lt ks kt ku im bi translated">如果你用过Go的<a class="ae kv" href="https://golang.org/pkg/container/heap/" rel="noopener ugc nofollow" target="_blank">容器/堆</a>，你可能也会觉得它很笨拙。如果给定一个像切片这样的东西，只需要缺少一个类型化的比较函数就可以拥有一个堆，为什么还要有那么多样板代码呢？</p><p id="2454" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">例如，从头实现一个通用的Kotlin堆可能如下所示:</p><figure class="lu lv lw lx gt ju"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="5c32" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">泛型确保我们包含、比较、推送和弹出一个类型(T)。给定这些已知的约束，您可以轻松地实现一个泛型堆。你可以用你希望的任何类型来实例化它，提供一个适合类型的比较函数:</p><figure class="lu lv lw lx gt ju"><div class="bz fp l di"><div class="ly lz l"/></div></figure><h2 id="cecc" class="kw kx it bd ky kz la dn lb lc ld dp le ki lf lg lh km li lj lk kq ll lm ln lo bi translated">使用Go泛型</h2><p id="dd1d" class="pw-post-body-paragraph jx jy it jz b ka lp kc kd ke lq kg kh ki lr kk kl km ls ko kp kq lt ks kt ku im bi translated">用Go泛型我能实现什么？事实上我想要的一切。看看下面这个使用我的Go泛型堆的例子:</p><figure class="lu lv lw lx gt ju"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="9530" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">它正确地产生了:</p><pre class="lu lv lw lx gt ma mb mc md aw me bi"><span id="09f8" class="kw kx it mb b gy mf mg l mh mi">1<br/>1<br/>2<br/>{70}<br/>{42}<br/>{30}<br/>{23}</span></pre><p id="76f9" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">那就是一堆<strong class="jz iu">应该</strong>的样子。一些数据和一个比较器。谁在乎是什么类型。</p><h2 id="ff58" class="kw kx it bd ky kz la dn lb lc ld dp le ki lf lg lh km li lj lk kq ll lm ln lo bi translated">怎么做到的？</h2><p id="53d3" class="pw-post-body-paragraph jx jy it jz b ka lp kc kd ke lq kg kh ki lr kk kl km ls ko kp kq lt ks kt ku im bi translated">下面是整个Go泛型堆的实现。它干净、简单、实用:</p><figure class="lu lv lw lx gt ju"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="3631" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我现在真的很期待去仿制药。</p></div></div>    
</body>
</html>