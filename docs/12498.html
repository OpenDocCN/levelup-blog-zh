<html>
<head>
<title>Angular Dynamic Routing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">角度动态路由</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/angular-dynamic-routing-299c04ca75b1?source=collection_archive---------0-----------------------#2022-06-15">https://levelup.gitconnected.com/angular-dynamic-routing-299c04ca75b1?source=collection_archive---------0-----------------------#2022-06-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/490dc054b1dbc4ed40f19db4080ad29b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3Ujh9hg75fYDDomt"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">布鲁诺·凯尔泽在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="82ff" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此时，您可能已经听说过动态组件，它对于创建更加动态的应用程序非常有用。它们允许我们在运行时根据一些定制的逻辑动态地加载组件，而不必创建一个被ngIf的负载所膨胀的组件。</p><p id="950e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你还没有听说过动态元件，我建议你看看Angular Connect的Shmuela Jacobs的演讲:</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="f25f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我的日常工作中，我正在构建一个类似于CRM的系统，管理各种不同的产品，这些产品都有一个共同的核心部分，但也有一些特定于产品的东西。为了使组件更加可重用，我到处引入了动态组件，这些组件根据指定当前活动产品的InjectionToken加载正确的特定于产品的组件。一切都很好，直到我试图重构一个步骤流，它有一些通用步骤，但也有一些特定于产品的步骤。这是一个问题，因为分步流程不仅基于组件，还依赖于路线。这意味着产品的步骤流可以有一些与其他步骤不同的附加步骤，即路线。步骤的数量也可以变化。</p><p id="9aea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一种不太好的解决方法是创建固定数量的路由，命名为:step1、step2、step3，然后在每个步骤中动态加载组件，但是由于步骤的数量不同，这是不可能的。正确的解决方案是使用<strong class="kf ir">动态路由</strong>。</p><p id="48af" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通常，我们在路由模块中非常静态地定义模块的路由，如下所示:</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lh lg l"/></div></figure><p id="e6a8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦模块被加载，就没有任何逻辑可以干扰路由的静态分配，所以总是会有本地路由，除此之外什么也没有。</p><h1 id="5599" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">例子</h1><p id="d602" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">让我们来看一个非常简单的例子，这个例子可能没什么意义，但它的目的是演示动态路由的工作原理:</p><p id="bc6b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们希望创建一个具有以下路径的应用程序:</p><ul class=""><li id="cdad" class="ml mm iq kf b kg kh kk kl ko mn ks mo kw mp la mq mr ms mt bi translated"><strong class="kf ir">首页</strong> <em class="mu">(静态)</em></li><li id="475a" class="ml mm iq kf b kg mv kk mw ko mx ks my kw mz la mq mr ms mt bi translated"><strong class="kf ir"> 404未找到</strong> <em class="mu">(静态)</em></li><li id="7144" class="ml mm iq kf b kg mv kk mw ko mx ks my kw mz la mq mr ms mt bi translated"><strong class="kf ir">日</strong> <em class="mu">(动态；仅在早上6点到下午6点之间提供)</em></li><li id="5cf8" class="ml mm iq kf b kg mv kk mw ko mx ks my kw mz la mq mr ms mt bi translated"><strong class="kf ir">夜晚</strong> <em class="mu">(动态；仅在下午6点—早上6点之间提供)</em></li><li id="3b14" class="ml mm iq kf b kg mv kk mw ko mx ks my kw mz la mq mr ms mt bi translated"><strong class="kf ir">秘密</strong> <em class="mu">(动态；50/50的机会)</em></li></ul><p id="ac0a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">动态路由意味着模块的路由配置可以根据您为加载定义的逻辑在每次加载时发生变化。主要技巧是使用<strong class="kf ir"> ROUTES </strong> InjectionToken，这是一个用于路由器配置的低级API。我们没有在RouterModule的forRoot/forChild函数中直接传递路由，而是传递一个空数组，并在providers部分提供routes标记。在这种情况下，角度路由器将自动只使用来自所提供令牌的路由。</p><p id="dec6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们在providers部分定义了我们的路由，我们可以利用<strong class="kf ir"> useFactory </strong> provider定义对象。这样，我们可以通过一个包含决定路线外观的逻辑的工厂。</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lh lg l"/></div></figure><p id="6d10" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">简短提醒:</strong>如果您在早上5:59加载模块，并等到早上6:01，则当天的路线将不可用，因为之前已经完成了路线配置。这意味着定义路由的逻辑只在模块加载时出现一次。</p><h1 id="df7f" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">结论</h1><p id="a3be" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">我希望我能给你看一些新的有趣的东西。如果你对Angular感兴趣，可以看看我在Medium上的其他博文。</p><p id="2b09" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我的GitHub上有完整的示例:</p><div class="na nb gp gr nc nd"><a href="https://github.com/HaasStefan/dynamic-routing-angular" rel="noopener  ugc nofollow" target="_blank"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd ir gy z fp ni fr fs nj fu fw ip bi translated">GitHub-HaasStefan/dynamic-routing-Angular:Angular中的动态路由示例</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">此项目是使用Angular CLI版本13.2.2生成的。为开发服务器运行ng serve。导航到…</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">github.com</p></div></div><div class="nm l"><div class="nn l no np nq nm nr jw nd"/></div></div></a></div></div></div>    
</body>
</html>