<html>
<head>
<title>Dependency Injection using Self Types in Scala (Cake Pattern)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Scala中使用自身类型的依赖注入(蛋糕模式)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/dependency-injection-using-self-types-in-scala-cake-pattern-67c76e603e5b?source=collection_archive---------3-----------------------#2020-02-02">https://levelup.gitconnected.com/dependency-injection-using-self-types-in-scala-cake-pattern-67c76e603e5b?source=collection_archive---------3-----------------------#2020-02-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="8e42" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">本文旨在帮助开发者理解如何借助Scala中的<strong class="js iu"> <em class="ko">自类型</em> </strong>实现依赖注入。这种模式也被称为<strong class="js iu"> <em class="ko">蛋糕模式</em> </strong>，用于Scala编译器中。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/15c7115556616d7b0f01f6151a3218b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_Zbyhqw2SCjFEoZB"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated"><a class="ae lf" href="https://unsplash.com/@steven__chan?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">汀天</a>在<a class="ae lf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="29bd" class="lg lh it bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">什么是自我类型？</h1><blockquote class="me mf mg"><p id="f107" class="jq jr ko js b jt ju jv jw jx jy jz ka mh kc kd ke mi kg kh ki mj kk kl km kn im bi translated">自我类型是一种声明一种特性必须混合到另一种特性中的方式，即使它没有直接扩展它。</p></blockquote><p id="19b8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们看一个例子:</p><pre class="kq kr ks kt gt mk ml mm mn aw mo bi"><span id="52eb" class="mp lh it ml b gy mq mr l ms mt">trait A {<br/>  this: B<br/>}</span></pre><p id="56d8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这基本上意味着要实现<em class="ko"> A </em>你需要实现<em class="ko"> B </em>，也就是说<em class="ko"> A </em>依赖于<em class="ko">B</em></p><p id="7d86" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里，B被称为a的自我类型。自我类型是用关键字'<em class="ko"> this </em>'声明的。</p><p id="202b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你可以拥有多种特质作为特定类型的自我类型。例如，如果A依赖于B、C和D，那么上面的代码应该是这样的:</p><pre class="kq kr ks kt gt mk ml mm mn aw mo bi"><span id="14c5" class="mp lh it ml b gy mq mr l ms mt">trait A {<br/>  this: B with C with D<br/>}</span></pre><p id="ac8e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这种情况下，如果你实现了<em class="ko"> A </em>，你也需要实现<em class="ko"> B </em>和<em class="ko"> C </em>和<em class="ko"> D </em>。</p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="7956" class="lg lh it bd li lj nb ll lm ln nc lp lq lr nd lt lu lv ne lx ly lz nf mb mc md bi translated"><em class="ng">依赖注入使用自我类型</em></h1><p id="715d" class="pw-post-body-paragraph jq jr it js b jt nh jv jw jx ni jz ka kb nj kd ke kf nk kh ki kj nl kl km kn im bi translated">让我们通过一个例子来弄清楚如何使用self type注入依赖项。</p><p id="be47" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们这里的问题是创建一个登录服务，它使用某种认证机制来认证用户。我们将从基本代码开始，然后继续重构(这里的目标不是编写成熟的生产就绪代码)。</p><p id="a8d1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们考虑一个使用第三方认证服务(LDAP/OAuth服务器)的简单登录服务。为这个认证服务定义一个接口是明智的:</p><pre class="kq kr ks kt gt mk ml mm mn aw mo bi"><span id="d5f1" class="mp lh it ml b gy mq mr l ms mt">trait AuthenticationService {<br/>  def authenticate(userInfo: String) : Response<br/>}</span></pre><p id="7369" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了简洁起见，我们假设服务将接受包含用户名和密码的字符串，并返回一个响应对象。</p><p id="3c3c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">好的，让我们继续实现这个接口。我们的用户将通过OAuth服务器进行身份验证:</p><pre class="kq kr ks kt gt mk ml mm mn aw mo bi"><span id="4de8" class="mp lh it ml b gy mq mr l ms mt">class OAuthAuthenticationService extends AuthenticationService {<br/>  def authenticate(userInfo: String) : Response = ???<br/>}</span></pre><p id="b862" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个类<em class="ko">oauthenticationservice</em>将被我们的登录服务使用。使用构造函数，我们可以将这种依赖注入LoginService，如下所示:</p><pre class="kq kr ks kt gt mk ml mm mn aw mo bi"><span id="943d" class="mp lh it ml b gy mq mr l ms mt">class LoginService(authenticationService: AuthenticationService) {<br/>  def login(userInfo: String) : Response = authenticationService.authenticate(userInfo)<br/>}</span></pre><p id="407e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一切都很好，但我们想在这里使用自身类型，而不是使用构造函数。为了将<em class="ko">oauthenticationservice</em>作为<em class="ko"> LoginService </em>的自身类型，我们必须修改<em class="ko">oauthenticationservice</em>。所以，让我们继续把它包装在一个特征中。我稍后会解释为什么我们需要这样做。</p><pre class="kq kr ks kt gt mk ml mm mn aw mo bi"><span id="b8a1" class="mp lh it ml b gy mq mr l ms mt">trait OAuthAuthenticationServiceComponent {</span><span id="4152" class="mp lh it ml b gy nm mr l ms mt">  val authenticationService: AuthenticationService = new OAuthAuthenticationService</span><span id="ff94" class="mp lh it ml b gy nm mr l ms mt">  class OAuthAuthenticationService extends AuthenticationService {<br/>    def authenticate(userInfo: String) : Response = ???<br/>  }<br/>}</span></pre><p id="e21a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如您所见，我们已经将实际的实现包装在一个特征中。此外，实现对象的创建是在trait本身内部完成的。等等，我知道你很惊讶，但我保证我们会回到这个话题。</p><p id="23f2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了在<em class="ko">登录服务</em>中使用这个自类型，我们必须对<em class="ko">登录服务</em>做一点修改:</p><pre class="kq kr ks kt gt mk ml mm mn aw mo bi"><span id="bbd0" class="mp lh it ml b gy mq mr l ms mt">trait LoginServiceComponent {<br/>  <br/>  this: OAuthAuthenticationServiceComponent =&gt; </span><span id="1341" class="mp lh it ml b gy nm mr l ms mt">  val loginService = new LoginService</span><span id="503e" class="mp lh it ml b gy nm mr l ms mt">  class LoginService {<br/>    def login(userInfo: String) : Response =   authenticationService.authenticate(userInfo)<br/>  }<br/>}</span></pre><p id="e656" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将实现类包装在一个特征中，就像我们对<em class="ko">oauthenticationservice</em>所做的那样。让我解释一下这是怎么回事。</p><p id="da40" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko"> LoginServiceComponent </em>内的<em class="ko"> LoginService </em>使用<em class="ko"> authenticationService </em>，它是<em class="ko">oauthtauthenticationservice component的成员。</em>这是因为<em class="ko"> LoginServiceComponent </em>已经将<em class="ko">oauthenticationservicecomponent</em>定义为其自身类型。<em class="ko"> LoginServiceComponent </em>的成员可以访问<em class="ko">oauthenticationservicecomponent</em>的成员，但反之则不行。</p><p id="17dd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，这里唯一剩下的是将所有组件连接在一起的config对象。ComponentRegistry这里是我们的配置对象:</p><pre class="kq kr ks kt gt mk ml mm mn aw mo bi"><span id="7856" class="mp lh it ml b gy mq mr l ms mt">object ComponentRegistry extends LoginServiceComponent<br/>  with OAuthAuthenticationServiceComponent</span></pre><p id="4f5a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在可以像这样调用登录方法:</p><pre class="kq kr ks kt gt mk ml mm mn aw mo bi"><span id="54f3" class="mp lh it ml b gy mq mr l ms mt">ComponentRegistry.loginService.login(userInfo)</span></pre><p id="a151" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是可行的，但是实现对象的创建逻辑与实际的实现逻辑相耦合，这一点也不灵活。让我们继续改变这一点:</p><pre class="kq kr ks kt gt mk ml mm mn aw mo bi"><span id="852a" class="mp lh it ml b gy mq mr l ms mt">trait OAuthAuthenticationServiceComponent {</span><span id="25ef" class="mp lh it ml b gy nm mr l ms mt">val authenticationService: AuthenticationService</span><span id="b08a" class="mp lh it ml b gy nm mr l ms mt">class OAuthAuthenticationService extends AuthenticationService {<br/>    def authenticate(userInfo: String) : Response = ???<br/>  }<br/>}</span></pre><p id="6941" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">并且<em class="ko"> LoginServiceComponent </em>看起来会像:</p><pre class="kq kr ks kt gt mk ml mm mn aw mo bi"><span id="3e68" class="mp lh it ml b gy mq mr l ms mt">trait LoginServiceComponent {<br/>  <br/> this: OAuthAuthenticationServiceComponent =&gt;</span><span id="d56a" class="mp lh it ml b gy nm mr l ms mt"> val loginService: LoginService</span><span id="7558" class="mp lh it ml b gy nm mr l ms mt"> class LoginService {<br/>     def login(userInfo: String) : Response =   authenticationService.authenticate(userInfo)<br/>   }<br/>}</span></pre><p id="33cb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这给了我们在config对象中实例化我们选择的实现对象的灵活性。我们的配置对象现在看起来像这样:</p><pre class="kq kr ks kt gt mk ml mm mn aw mo bi"><span id="c6d5" class="mp lh it ml b gy mq mr l ms mt">object ComponentRegistry extends LoginService<br/>  with OAuthAuthenticationServiceComponent {<br/> <br/>  override val authenticationService: AuthenticationService = new OAuthAuthenticationService</span><span id="6f4d" class="mp lh it ml b gy nm mr l ms mt">  override val loginService: LoginService = new LoginService<br/>}</span></pre><p id="05fe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">LoginService现在将使用OAuthAuthenticationService对用户进行身份验证。你可能已经想通了，<strong class="js iu"> <em class="ko">这里的一切都是编译时注入</em> </strong>这种类型的依赖。只要您在配置对象中创建了正确类型的对象，就可以开始了。</p><p id="279b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在将以同样的方式调用login方法:</p><pre class="kq kr ks kt gt mk ml mm mn aw mo bi"><span id="d8f7" class="mp lh it ml b gy mq mr l ms mt">ComponentRegistry.loginService.login(userInfo)</span></pre></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="d4de" class="lg lh it bd li lj nb ll lm ln nc lp lq lr nd lt lu lv ne lx ly lz nf mb mc md bi translated"><strong class="ak">注入不同的依赖关系</strong></h1><p id="bc55" class="pw-post-body-paragraph jq jr it js b jt nh jv jw jx ni jz ka kb nj kd ke kf nk kh ki kj nl kl km kn im bi translated">要使用LDAP身份验证来代替OAuth，我们必须为它编写我们的实现，将其包装在trait中，并在config对象中创建一个该类型的对象:</p><pre class="kq kr ks kt gt mk ml mm mn aw mo bi"><span id="7778" class="mp lh it ml b gy mq mr l ms mt">override val authenticationService: AuthenticationService = new LdapAuthenticationService</span></pre><p id="6de0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这样，我们可以使用自身类型注入依赖项。虽然我只使用了一种自我类型，但是您也可以使用多种自我类型，将<em class="ko">与</em>关键字结合使用:</p><pre class="kq kr ks kt gt mk ml mm mn aw mo bi"><span id="dde5" class="mp lh it ml b gy mq mr l ms mt">this: OAuthAuthenticationServiceComponent with LoggerComponent with SomeOtherComponent =&gt;</span></pre></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><p id="b97f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在来谈谈为什么一切都围绕着特质？</p><p id="e389" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你会看到，在这种依赖注入中，我们通常会扩展多个组件，这只有在我们将实现包装在traits中时才有可能，因为Scala允许扩展多个traits，但不允许扩展多个类。</p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="68f7" class="lg lh it bd li lj nb ll lm ln nc lp lq lr nd lt lu lv ne lx ly lz nf mb mc md bi translated"><strong class="ak"> <em class="ng">这和平原老传承有什么不同？</em> </strong></h1><p id="d74e" class="pw-post-body-paragraph jq jr it js b jt nh jv jw jx ni jz ka kb nj kd ke kf nk kh ki kj nl kl km kn im bi translated">有了继承，你就被超类的实现卡住了。使用self类型，您可以在配置对象中混合不同的实现。</p><p id="289a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">继承还有另一个问题，超类把它的信息泄露给层次结构中的每一个类。这是违反封装的一个典型例子。</p><p id="506a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过使用自身类型的依赖注入，您可以在依赖层次结构中创建层。例如，考虑下面的例子:</p><pre class="kq kr ks kt gt mk ml mm mn aw mo bi"><span id="1d52" class="mp lh it ml b gy mq mr l ms mt">trait B {<br/>  this : A<br/>}</span><span id="aacc" class="mp lh it ml b gy nm mr l ms mt">trait C {<br/>  this : B<br/>}</span></pre><p id="7f42" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="ko">特征C的成员能够访问特征B的成员，但是不能访问特征A的成员</em> </strong>，从而在应用程序中创建层。<strong class="js iu"> </strong>因此这种图案也被称为<strong class="js iu">饼纹。</strong></p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><h1 id="1da0" class="lg lh it bd li lj nb ll lm ln nc lp lq lr nd lt lu lv ne lx ly lz nf mb mc md bi translated">结论</h1><p id="a3c7" class="pw-post-body-paragraph jq jr it js b jt nh jv jw jx ni jz ka kb nj kd ke kf nk kh ki kj nl kl km kn im bi translated">Cake模式为您提供了编译时安全性，因为您在config对象中混合了您的实现。如果config对象中缺少任何实现，编译器将不会编译您的代码。因此，这种模式可以用在编译类型配置可以接受的地方。</p><p id="949c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您必须表达相互依赖，这种模式也很有帮助。蛋糕模式允许循环依赖，这是其他类型的DI所不具备的。</p><p id="3940" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们在一个项目中使用蛋糕模式，我们已经意识到它带来的问题很容易超过它的优点。现在您可能已经意识到，许多样板代码都是以这种模式编写的，因为您必须将每个实现都包装在一个特征中。这种模式有更多的缺点，但这是改天的话题。</p><p id="0957" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我个人还没有找到使用这种模式的足够好的理由，但这只是我的看法。在Scala中注入依赖还有其他方法。其中一些是:</p><ol class=""><li id="322d" class="nn no it js b jt ju jx jy kb np kf nq kj nr kn ns nt nu nv bi translated">通过构造函数传递普通的旧参数(个人偏好)</li><li id="b4b0" class="nn no it js b jt nw jx nx kb ny kf nz kj oa kn ns nt nu nv bi translated">Guice(由Play框架使用)</li><li id="146c" class="nn no it js b jt nw jx nx kb ny kf nz kj oa kn ns nt nu nv bi translated">麦克威尔</li><li id="83b0" class="nn no it js b jt nw jx nx kb ny kf nz kj oa kn ns nt nu nv bi translated">Scala中的隐含</li><li id="a2aa" class="nn no it js b jt nw jx nx kb ny kf nz kj oa kn ns nt nu nv bi translated">春天(为什么不呢？)</li><li id="2f62" class="nn no it js b jt nw jx nx kb ny kf nz kj oa kn ns nt nu nv bi translated">Reader monad(使用语言构造的蛋糕模式的可能替代方案)</li></ol></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><p id="ad61" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我希望这篇文章有助于理解DI是如何在Scala中使用自类型的。感谢您的阅读。</p><p id="233a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">可运行代码可以在<a class="ae lf" href="https://github.com/shayan1337/scala-cake-pattern" rel="noopener ugc nofollow" target="_blank">https://github.com/shayan1337/scala-cake-pattern</a>找到</p></div></div>    
</body>
</html>