<html>
<head>
<title>How I Won My Battle of Using TensorFlow.js Without Leaking Memory</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我如何在不泄漏内存的情况下使用TensorFlow.js</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-use-tensorflow-js-without-memory-leaks-273ad16196be?source=collection_archive---------5-----------------------#2021-09-26">https://levelup.gitconnected.com/how-to-use-tensorflow-js-without-memory-leaks-273ad16196be?source=collection_archive---------5-----------------------#2021-09-26</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><h2 id="1373" class="is it iu bd b dl iv iw ix iy iz ja dk jb translated" aria-label="kicker paragraph"><a class="ae ep" href="https://rakiabensassi.medium.com/list/software-engineering-7a179a23ebfd" rel="noopener">网页性能</a></h2><div class=""/><div class=""><h2 id="9ca4" class="pw-subtitle-paragraph ka jd iu bd b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dk translated">使用TFJS模型而不影响web性能的技巧</h2></div><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj ks"><img src="../Images/2ad433a4403036c5595d6d2a98541f58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CxbPEy00b0523cIeawFE3A.jpeg"/></div></div><figcaption class="le lf gk gi gj lg lh bd b be z dk translated">图片来自<a class="ae li" href="https://pixabay.com/users/startupstockphotos-690514/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=593313" rel="noopener ugc nofollow" target="_blank"> StartupStockPhotos </a>来自<a class="ae li" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=593313" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></figcaption></figure><p id="33da" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">在<a class="ae li" href="https://betterprogramming.pub/web-performance-and-tensorflow-js-3db05b1de958" rel="noopener ugc nofollow" target="_blank">的上一篇文章</a>中，我在使用TensorFlow.js和机器学习通过手势而不是鼠标点击在订单创建步骤之间导航后，解决了我的一个web应用程序中遇到的性能问题。</p><p id="4acf" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">几周后，Google for TensorFlow.js和机器学习的高级开发人员Jason Mayes<a class="ae li" href="https://medium.com/@JasonMayes/thanks-for-making-the-informative-and-very-well-presented-video-and-blog-post-152493308039" rel="noopener">找到了</a>，问了我几个问题:</p><blockquote class="mf mg mh"><p id="d47c" class="lj lk mi ll b lm ln ke lo lp lq kh lr mj lt lu lv mk lx ly lz ml mb mc md me in bi translated">“这个GUI性能问题是在模型加载时出现的，还是在应用程序的整个使用过程中持续出现的(甚至在模型加载完成并且手动跟踪开始工作之后)？</p><p id="4004" class="lj lk mi ll b lm ln ke lo lp lq kh lr mj lt lu lv mk lx ly lz ml mb mc md me in bi translated">我自己刚刚尝试了默认的handpose演示，当模型首次加载时，我看到了延迟，因为数据必须传输到WebGL，Chrome也使用GPU来渲染DOM等——我们正在研究在这种情况下为浏览器保留一些GPU能力的方法，但一旦加载，我的性能又可以使用了——这对你来说是一样的吗？</p><p id="a694" class="lj lk mi ll b lm ln ke lo lp lq kh lr mj lt lu lv mk lx ly lz ml mb mc md me in bi translated">我们最近确实发现了一个与WebGL相关的内存泄漏错误，我相信它已经被修复了，你能确认一下你使用的内存是否仍然是100Mb吗？在我这边，我看到25Mb，它似乎没有比我刚才测试时的大。"</p></blockquote><p id="1885" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">因为我是TensorFlow.js的新手，而且我刚刚使用了Google Angular团队的软件工程师Minko Gechev的示例,做了一点小小的修改来实现这个功能，这条消息让我对TensorFlow.js的工作原理有了更多的了解。</p><div class="mm mn gq gs mo mp"><a href="https://betterprogramming.pub/javascript-memory-leaks-390957523a9e" rel="noopener  ugc nofollow" target="_blank"><div class="mq ab fp"><div class="mr ab ms cl cj mt"><h2 class="bd je gz z fq mu fs ft mv fv fx jd bi translated">如何识别、诊断和修复Web应用程序中的内存泄漏</h2><div class="mw l"><h3 class="bd b gz z fq mu fs ft mv fv fx dk translated">通过编写优化的代码和使用Chrome DevTools来提升你的web应用程序的性能</h3></div><div class="mx l"><p class="bd b dl z fq mu fs ft mv fv fx dk translated">better编程. pub</p></div></div><div class="my l"><div class="mz l na nb nc my nd lc mp"/></div></div></a></div><h1 id="86cc" class="ne nf iu bd ng nh ni nj nk nl nm nn no kj np kk nq km nr kn ns kp nt kq nu nv bi translated">确定内存泄漏的确切原因</h1><p id="a444" class="pw-post-body-paragraph lj lk iu ll b lm nw ke lo lp nx kh lr ls ny lu lv lw nz ly lz ma oa mc md me in bi translated">为了回答Jason的问题，我继续分析我的案例，发现在用户会话期间内存消耗持续增加，甚至在HandPose模型加载完成并且手势跟踪开始工作之后也是如此。</p><p id="a33a" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">我拍摄了许多堆快照，并注意到每当我转到编辑订单或产品的视图(其中有手势跟踪)并返回到产品列表视图(其中没有手势跟踪)时，快照的大小几乎增加了20 MB，如下所示:</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj ob"><img src="../Images/871e208a0fcebb09f8831129ed72aee6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CFJsPdmxEq29h16M89okYg.png"/></div></div><figcaption class="le lf gk gi gj lg lh bd b be z dk translated">大小不断增加的多个堆快照(图片由作者提供)</figcaption></figure><p id="f6c5" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">在给出这个结果后，Jason确认了每次用户访问details视图时都会重新加载模型，并且当用户离开页面时不会释放旧的内存，这使得堆大小的增加保持在20Mb以上。</p><p id="c6c4" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">当你在chrome浏览器的网络选项卡上看到多个<code class="fe oc od oe of b">model.json</code>时，你可以在下面的截图中找到这个:</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj og"><img src="../Images/b1c89ffb467d1796175187a2d8b80ad3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vKm_AItV8wnv24SCk1kczw.jpeg"/></div></div><figcaption class="le lf gk gi gj lg lh bd b be z dk translated">在chrome浏览器的网络选项卡上多次加载model.json(图片由作者提供)</figcaption></figure><h1 id="0818" class="ne nf iu bd ng nh ni nj nk nl nm nn no kj np kk nq km nr kn ns kp nt kq nu nv bi translated">我的项目与Minko的例子有何不同</h1><p id="be91" class="pw-post-body-paragraph lj lk iu ll b lm nw ke lo lp nx kh lr ls ny lu lv lw nz ly lz ma oa mc md me in bi translated">在我的项目中，我有一个作为<a class="ae li" href="https://betterprogramming.pub/angular-10-new-features-dbc779061dc8" rel="noopener ugc nofollow" target="_blank"> Angular </a>库实现的<a class="ae li" href="https://betterprogramming.pub/angular-library-dynamic-stepper-2ba05ab40228" rel="noopener ugc nofollow" target="_blank">动态步进器</a>,它具有步骤之间的导航，手跟踪是其中的一个特性。<code class="fe oc od oe of b">DynamicStepperModule</code>用于订单创建和产品详情视图，负责通过其<code class="fe oc od oe of b">HandGestureService</code>加载手部姿势模型。</p><p id="580a" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">这就是Minko Gechev演示中逻辑的不同之处，其中根组件<code class="fe oc od oe of b">AppComponent</code>负责呈现视频HTML元素:</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="oh oi l"/></div><figcaption class="le lf gk gi gj lg lh bd b be z dk translated">app.component.html</figcaption></figure><p id="da4d" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">以及处理媒体流的逻辑:</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="oh oi l"/></div><figcaption class="le lf gk gi gj lg lh bd b be z dk translated">应用程序组件</figcaption></figure><p id="a263" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated"><code class="fe oc od oe of b">AppComponent</code>是UI的主要包装器，所以用户永远不会离开并在会话期间回来，这意味着在这种情况下他们永远不会有机会看到模型被重新加载。</p><h1 id="697d" class="ne nf iu bd ng nh ni nj nk nl nm nn no kj np kk nq km nr kn ns kp nt kq nu nv bi translated">如何修复我的项目？</h1><p id="22b1" class="pw-post-body-paragraph lj lk iu ll b lm nw ke lo lp nx kh lr ls ny lu lv lw nz ly lz ma oa mc md me in bi translated">在我的案例中，我看到的解决方案是每当用户离开细节视图时就释放模型。就像<code class="fe oc od oe of b">load()</code>方法一样，TensorFlow.js库提供了一个<code class="fe oc od oe of b">dispose()</code>方法来释放模型保留的内存。</p><p id="6625" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">然而，Jason <a class="ae li" href="https://discuss.tensorflow.org/t/memory-leaks-with-tensorflow-js-hand-gestures/4384" rel="noopener ugc nofollow" target="_blank">建议</a>不要这样做，因为这样可以修复内存泄漏，但不能修复性能问题:</p><blockquote class="mf mg mh"><p id="de10" class="lj lk mi ll b lm ln ke lo lp lq kh lr mj lt lu lv mk lx ly lz ml mb mc md me in bi translated">“加载模型本身是一个非常密集的过程，在某些浏览器上，它甚至会阻止在加载时更新GUI。我们的团队实际上正在寻找降低负载强度的方法，但是仍然会使用大量的资源。</p><p id="8c43" class="lj lk mi ll b lm ln ke lo lp lq kh lr mj lt lu lv mk lx ly lz ml mb mc md me in bi translated">我建议加载一次TFJS模型，存储在一个在视图变化之间不会被破坏的常量中，然后在需要时调用预测函数。这将导致一个更高性能的web应用程序，并节省带宽，如果你没有在本地缓存，例如在本地存储等，每次视图改变时重新下载模型。</p><p id="21bb" class="lj lk mi ll b lm ln ke lo lp lq kh lr mj lt lu lv mk lx ly lz ml mb mc md me in bi translated">你建议的解决方案将解决内存泄漏，但不会解决性能问题，因为它必须每次都重新解析所有内容，并从CPU发送到GPU内存，这是非常密集的。"</p></blockquote><p id="8b3a" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">因此，有了这个提示，很明显，我没有其他解决方案例外调整我的应用程序的逻辑，只加载一次手部跟踪模型，然后将它保存在某个地方，并在需要时从那里读取它的值。</p></div><div class="ab cl oj ok hy ol" role="separator"><span class="om bw bk on oo op"/><span class="om bw bk on oo op"/><span class="om bw bk on oo"/></div><div class="in io ip iq ir"><h1 id="b12a" class="ne nf iu bd ng nh oq nj nk nl or nn no kj os kk nq km ot kn ns kp ou kq nu nv bi translated">解决方案1:将模型保存在本地存储中</h1><p id="85e3" class="pw-post-body-paragraph lj lk iu ll b lm nw ke lo lp nx kh lr ls ny lu lv lw nz ly lz ma oa mc md me in bi translated">虽然我以前已经使用过<code class="fe oc od oe of b">localStorage</code>很多次，但是序列化HandPose模型并不像我预期的那么容易。</p><h2 id="98df" class="ov nf iu bd ng ow ox dn nk oy oz dp no ls pa pb nq lw pc pd ns ma pe pf nu ja bi translated"><strong class="ak"> 1。类型错误:将循环结构转换为JSON </strong></h2><p id="5ff6" class="pw-post-body-paragraph lj lk iu ll b lm nw ke lo lp nx kh lr ls ny lu lv lw nz ly lz ma oa mc md me in bi translated">我面临的第一个挑战是我调用了<code class="fe oc od oe of b">JSON.stringify()</code>以便在保存之前将模型转换成字符串。我得到了错误:</p><p id="a2eb" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated"><code class="fe oc od oe of b">TypeError: Converting circular structure to JSON</code>:</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj pg"><img src="../Images/a200d287b0f1792358fc2b30a702bede.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FhN2Su6yj6uetwB-bKSH1g.png"/></div></div><figcaption class="le lf gk gi gj lg lh bd b be z dk translated">类型错误:将循环结构转换为JSON(图片由作者提供)</figcaption></figure><p id="07d2" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">这个问题我以前见过很多次，尤其是当我试图<code class="fe oc od oe of b">console.log</code>一个复杂的JSON对象时。</p><p id="c511" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">为了解决这个问题，我使用了下面的代码片段来查找和过滤循环引用:</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="oh oi l"/></div><figcaption class="le lf gk gi gj lg lh bd b be z dk translated"><a class="ae li" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Cyclic_object_value" rel="noopener ugc nofollow" target="_blank">来源:Mozilla </a></figcaption></figure><p id="c1ae" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">然后我调用了<code class="fe oc od oe of b">getCircularReplacer()</code>函数作为<code class="fe oc od oe of b">JSON.stringify()</code>的第二个参数。方法<code class="fe oc od oe of b">stringify()</code>有一个名为<code class="fe oc od oe of b">replacer</code>的可选参数:</p><pre class="kt ku kv kw gu ph of pi pj aw pk bi"><span id="7583" class="ov nf iu of b gz pl pm l pn po">stringify(value: any, <strong class="of je">replacer</strong>?: (this: any, key: string, value: any) =&gt; any, space?: string | number): string;</span></pre><p id="855f" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">这是我的手部姿势模型逻辑在改变后的样子:</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="oh oi l"/></div><figcaption class="le lf gk gi gj lg lh bd b be z dk translated">在本地存储中保存并加载TensorFlow.js手选模型</figcaption></figure><h2 id="7d03" class="ov nf iu bd ng ow ox dn nk oy oz dp no ls pa pb nq lw pc pd ns ma pe pf nu ja bi translated">2.TypeError: model.estimateHands不是函数</h2><p id="49c3" class="pw-post-body-paragraph lj lk iu ll b lm nw ke lo lp nx kh lr ls ny lu lv lw nz ly lz ma oa mc md me in bi translated">我面临的下一个挑战是第二次访问具有手部跟踪功能的视图。</p><p id="d963" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">当用户第一次打开这个视图时，它从<code class="fe oc od oe of b">handpose.load()</code>获取模型，第二次从<code class="fe oc od oe of b">localStorage</code>加载模型:</p><pre class="kt ku kv kw gu ph of pi pj aw pk bi"><span id="60a1" class="ov nf iu of b gz pl pm l pn po">const modelFromLocalStorage = localStorage.getItem('handPoseModel');<br/>return JSON.parse(modelFromLocalStorage);</span></pre><p id="6fc7" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">这是我得到的:<code class="fe oc od oe of b">TypeError: model.estimateHands is not a function</code>:</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj pp"><img src="../Images/f0b608be0a990ab1cc9c865e889040a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d3mzh_xVhsK-iNLylkOnrw.png"/></div></div><figcaption class="le lf gk gi gj lg lh bd b be z dk translated">TypeError: estimateHands不是函数(图片由作者提供)</figcaption></figure><p id="9218" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">原因是只有模型的属性保存在<code class="fe oc od oe of b">localStorage</code>中。<code class="fe oc od oe of b">getCircularReplacer()</code>在过滤循环引用的过程中导致了数据丢失。</p><p id="6c23" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">因此，我没有使用这种自我实现的解决方案，而是寻找一个支持序列化循环引用而不会丢失数据的库。我选择了<code class="fe oc od oe of b"><a class="ae li" href="https://www.npmjs.com/package/json-cyclic" rel="noopener ugc nofollow" target="_blank">json-cyclic</a></code>(或<a class="ae li" href="https://github.com/douglascrockford/JSON-js/blob/master/cycle.js" rel="noopener ugc nofollow" target="_blank"> cycle.js </a>)并将其添加到项目中:</p><pre class="kt ku kv kw gu ph of pi pj aw pk bi"><span id="0b29" class="ov nf iu of b gz pl pm l pn po">yarn add json-cyclic</span></pre><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="oh oi l"/></div></figure><h2 id="bb0f" class="ov nf iu bd ng ow ox dn nk oy oz dp no ls pa pb nq lw pc pd ns ma pe pf nu ja bi translated">3.范围错误:超出了最大调用堆栈大小</h2><p id="cab3" class="pw-post-body-paragraph lj lk iu ll b lm nw ke lo lp nx kh lr ls ny lu lv lw nz ly lz ma oa mc md me in bi translated">我几乎解决了这个问题，除了这个错误给了我一记耳光:</p><p id="62dc" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated"><code class="fe oc od oe of b">RangeError: Maximum call stack size exceeded</code></p><p id="8399" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">显然，这是因为来自<code class="fe oc od oe of b">json-cyclic</code>库的<code class="fe oc od oe of b">decycle()</code>和<code class="fe oc od oe of b">encycle()</code>方法中的递归函数调用:</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj pq"><img src="../Images/25e782e28703c260dedeab3e362f9295.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T06zzY_CYBW7BRQcNQ4qJg.png"/></div></div><figcaption class="le lf gk gi gj lg lh bd b be z dk translated">范围错误:超出了最大调用堆栈大小(图片由作者提供)</figcaption></figure></div><div class="ab cl oj ok hy ol" role="separator"><span class="om bw bk on oo op"/><span class="om bw bk on oo op"/><span class="om bw bk on oo"/></div><div class="in io ip iq ir"><h1 id="f259" class="ne nf iu bd ng nh oq nj nk nl or nn no kj os kk nq km ot kn ns kp ou kq nu nv bi translated">解决方案2:在服务中保存模型</h1><p id="b623" class="pw-post-body-paragraph lj lk iu ll b lm nw ke lo lp nx kh lr ls ny lu lv lw nz ly lz ma oa mc md me in bi translated">在最后一个错误之后，我改变了我的方法来修复内存泄漏:不是在<code class="fe oc od oe of b">localStorage</code>中保存模型，我想使用<code class="fe oc od oe of b">HandGesture</code>服务作为存储，并在那里保存TFJS模型，就像我在其他项目中使用<a class="ae li" href="https://betterprogramming.pub/frontend-architecture-376e6323ef9b" rel="noopener ugc nofollow" target="_blank">可观察数据服务(或基于行为主体的存储服务)</a>一样。</p><p id="d596" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated"><code class="fe oc od oe of b">HandGestureService</code>实际上是一个单例，这意味着应用程序只有一个实例，这允许我在其中定义一个新变量<code class="fe oc od oe of b">_handPoseModel</code>，它应该在第一次加载后保存模型:</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="oh oi l"/></div></figure><p id="78fe" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">实施这种方法后，我发现从<code class="fe oc od oe of b">_handPoseModel</code>获取模型的值太快了，导致了以下错误:</p><p id="f288" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated"><code class="fe oc od oe of b">The video element has not loaded data yet. Please wait for ‘loadeddata’ event on the &lt;video&gt; element</code>:</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj pr"><img src="../Images/9b3064b2c31971a0058c8bc17a924b1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*opq5efqb89intMVEutiGGg.png"/></div></div><figcaption class="le lf gk gi gj lg lh bd b be z dk translated">错误:视频元素尚未加载数据。请等待<video>元素上的“loadeddata”事件(图片由作者提供)</video></figcaption></figure><p id="db14" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">HTML视频元素很慢，需要几秒钟才能向用户显示<code class="fe oc od oe of b">MediaStream</code>内容:</p><pre class="kt ku kv kw gu ph of pi pj aw pk bi"><span id="ff3c" class="ov nf iu of b gz pl pm l pn po">&lt;video #video width="600" height="480" [srcObject]="stream" autoplay&gt;&lt;/video&gt;</span></pre><p id="9497" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">在多次尝试将<code class="fe oc od oe of b">video.addEventListener('loadeddata', (e) =&gt; {...})</code>添加到源代码的不同位置后，我终于找到了合适的位置，让应用程序运行时没有错误和内存泄漏。</p><p id="4946" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">我已经将它添加为<code class="fe oc od oe of b">model.estimateHands(video).then(...)</code>的包装器，如你在下面的代码中所见:</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="oh oi l"/></div><figcaption class="le lf gk gi gj lg lh bd b be z dk translated">在调用model.estimateHands(video)之前，请等待视频事件“loadeddata”</figcaption></figure><p id="a019" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">瞧啊！</p><p id="8bbd" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">漫长的时间和令人生畏的工作最终得到了回报:)更重要的是，我对TensorFlow.js以及如何使用它有了更多的了解。</p><p id="15e3" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">下面是修复后堆快照的样子:</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj ps"><img src="../Images/01f19d9b393cb49bc5de63fee95e7f8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Syu6nLc43EfNEEiSDjjsvA.png"/></div></div><figcaption class="le lf gk gi gj lg lh bd b be z dk translated">修复内存泄漏后的堆快照(图片由作者提供)</figcaption></figure><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj pt"><img src="../Images/b6ec06c7d0d5efd546c785ea8c4f94e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ee8CiAgneO9heGrSZOXL8w.png"/></div></div><figcaption class="le lf gk gi gj lg lh bd b be z dk translated">修复内存泄漏后的堆快照(图片由作者提供)</figcaption></figure><ul class=""><li id="b550" class="pu pv iu ll b lm ln lp lq ls pw lw px ma py me pz qa qb qc bi translated">第一个快照(13.6MB)是在启动应用程序后拍摄的。</li><li id="4230" class="pu pv iu ll b lm qd lp qe ls qf lw qg ma qh me pz qa qb qc bi translated">接下来的快照是在玩应用程序并多次访问和离开详细信息页面(显示手跟踪视频)后拍摄的。</li><li id="8789" class="pu pv iu ll b lm qd lp qe ls qf lw qg ma qh me pz qa qb qc bi translated">第二个快照(33.5MB)与第一个相比增加了大约20MB，因为它是在加载<code class="fe oc od oe of b">HandPose</code>模型之后拍摄的。它包括模型的大小和相关的逻辑。</li><li id="4339" class="pu pv iu ll b lm qd lp qe ls qf lw qg ma qh me pz qa qb qc bi translated">在此之后，没有新的模型加载，因此几乎没有连续增加内存。</li></ul><p id="504a" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">感谢阅读！我希望你在这篇文章中找到了一些见解和灵感，帮助你在自己的web应用程序中尝试TensorFlow.js。</p><p id="6c67" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">特别感谢<a class="qi qj ep" href="https://medium.com/u/c86fe9178d2?source=post_page-----273ad16196be--------------------------------" rel="noopener" target="_blank">杰森·梅斯</a>。</p></div><div class="ab cl oj ok hy ol" role="separator"><span class="om bw bk on oo op"/><span class="om bw bk on oo op"/><span class="om bw bk on oo"/></div><div class="in io ip iq ir"><p id="140f" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">🧠💡我为一群聪明、好奇的人写关于工程、技术和领导力的文章。<a class="ae li" href="https://rakiabensassi.substack.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="ll je">加入我的免费电子邮件简讯</strong> </a>获取独家访问权限，或者如果您还没有注册，请在此注册Medium <a class="ae li" href="https://rakiabensassi.medium.com/membership" rel="noopener">。</a></p><p id="3b55" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated"><em class="mi">你可以在Udemy上查看我的</em> <strong class="ll je"> <em class="mi">视频课程</em></strong><em class="mi">:</em><a class="ae li" href="https://www.udemy.com/course/identify-and-fix-javascript-memory-leaks/" rel="noopener ugc nofollow" target="_blank"><em class="mi">如何识别、诊断、修复Web Apps中的内存泄漏</em> </a> <em class="mi">。</em></p><div class="mm mn gq gs mo mp"><a href="https://betterprogramming.pub/web-vitals-guide-b56e28798e7f" rel="noopener  ugc nofollow" target="_blank"><div class="mq ab fp"><div class="mr ab ms cl cj mt"><h2 class="bd je gz z fq mu fs ft mv fv fx jd bi translated">网络生命:它们是什么，如何衡量它们</h2><div class="mw l"><h3 class="bd b gz z fq mu fs ft mv fv fx dk translated">谷歌用来影响你的网络应用排名的基本性能指标指南</h3></div><div class="mx l"><p class="bd b dl z fq mu fs ft mv fv fx dk translated">better编程. pub</p></div></div><div class="my l"><div class="qk l na nb nc my nd lc mp"/></div></div></a></div><div class="mm mn gq gs mo mp"><a rel="noopener  ugc nofollow" target="_blank" href="/7-nodejs-vulnerabilities-149094e441c2"><div class="mq ab fp"><div class="mr ab ms cl cj mt"><h2 class="bd je gz z fq mu fs ft mv fv fx jd bi translated">GitHub在NodeJS中发现了7个漏洞——这对你意味着什么？</h2><div class="mw l"><h3 class="bd b gz z fq mu fs ft mv fv fx dk translated">漏洞演练和给用户的建议</h3></div><div class="mx l"><p class="bd b dl z fq mu fs ft mv fv fx dk translated">levelup.gitconnected.com</p></div></div><div class="my l"><div class="ql l na nb nc my nd lc mp"/></div></div></a></div></div></div>    
</body>
</html>