<html>
<head>
<title>Learning C++: Sorted-Range Algorithms of the STL Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习c++:STL的排序范围算法第1部分</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/learning-c-sorted-range-algorithms-of-the-stl-part-1-f66edc967564?source=collection_archive---------13-----------------------#2020-04-29">https://levelup.gitconnected.com/learning-c-sorted-range-algorithms-of-the-stl-part-1-f66edc967564?source=collection_archive---------13-----------------------#2020-04-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/96ea41bf047979aebdb0a09265f1d134.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VcdV6PjBra-bvJ8d"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">Jonah Pettrich 在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="25aa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这篇文章中，我将讨论在元素已经排序的容器上使用的算法。这个类中的经典算法是<code class="fe le lf lg lh b">binary_search</code>，但是标准模板库(STL)中包含了其他几个算法。</p><h1 id="56f8" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">二分搜索法算法</h1><p id="07f9" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">计算机科学中的经典算法之一是二分搜索法算法。使用排序来提高搜索效率的历史可以追溯到古代。二分搜索法背后的概念是首先确保集装箱被分类。将变量L设置为0，将变量R设置为容器中的最后一个索引位置。找到容器的中点，并查看中点处的元素是否等于要搜索的值。如果是，返回中点并停止。如果元素小于要搜索的值，则将L调整到中点+ 1。如果元素大于要搜索的值，则将R设置为中点-1。继续这个过程，直到找到要搜索的值或者L &gt; R，在这种情况下，您已经到达容器的末尾。去<a class="ae kf" href="https://en.wikipedia.org/wiki/Binary_search_algorithm#History" rel="noopener ugc nofollow" target="_blank">这里</a>看更复杂的二分搜索法算法的讨论。</p><h1 id="a1dd" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">二进制搜索函数</h1><p id="805f" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">STL用<code class="fe le lf lg lh b">binary_search</code>函数实现了二分搜索法算法。该函数将起始范围、结束范围和要搜索的值作为参数。该函数返回一个布尔值，表明该值是否在范围内。重载版本也允许使用二元谓词函数作为排序标准，但是这个版本很少使用。</p><p id="6230" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是<code class="fe le lf lg lh b">binary_search</code>函数的语法模板:</p><p id="2005" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="ml"> bool binary_search(范围开始，范围结束，值)；</em></p><p id="197b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个正在使用的<code class="fe le lf lg lh b">binary_search</code>函数的例子:</p><pre class="mm mn mo mp gt mq lh mr ms aw mt bi"><span id="d583" class="mu lj it lh b gy mv mw l mx my">#include &lt;iostream&gt;<br/>#include &lt;vector&gt;<br/>#include &lt;algorithm&gt;<br/>#include &lt;cstdlib&gt;<br/>#include &lt;ctime&gt;<br/>using namespace std;</span><span id="236f" class="mu lj it lh b gy mz mw l mx my">void buildVec(vector&lt;int&gt; &amp;vec, int n) {<br/>  for (int i = 1; i &lt;= n; i++) {<br/>    vec.push_back(rand() % 100 + 1);<br/>  }<br/>}</span><span id="7fde" class="mu lj it lh b gy mz mw l mx my">void printVec(vector&lt;int&gt; &amp;vec) {<br/>  int i = 1;<br/>  for (const int n : vec) {<br/>    cout &lt;&lt; n &lt;&lt; " ";<br/>    if (i % 10 == 0) {<br/>      cout &lt;&lt; endl;<br/>    }<br/>    i++;<br/>  }<br/>}</span><span id="1487" class="mu lj it lh b gy mz mw l mx my">int main () {<br/>  vector&lt;int&gt; numbers;<br/>  buildVec(numbers, 100);<br/>  sort(numbers.begin(), numbers.end());<br/>  printVec(numbers);<br/>  cout &lt;&lt; endl &lt;&lt; endl;<br/>  int value;<br/>  for (int i = 1; i &lt;= 2; i++) {<br/>    cout &lt;&lt; "Enter value to search for: ";<br/>    cin &gt;&gt; value;<br/>    if (binary_search(numbers.begin(), numbers.end(), value)) {<br/>      cout &lt;&lt; "Found " &lt;&lt; value &lt;&lt; " in numbers." &lt;&lt; endl;<br/>    }<br/>    else {<br/>      cout &lt;&lt; "Did not find " &lt;&lt; value &lt;&lt; " in numbers."<br/>           &lt;&lt; endl;<br/>    }<br/>  }<br/>  return 0;<br/>}</span></pre><p id="7357" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是该程序的输出:</p><pre class="mm mn mo mp gt mq lh mr ms aw mt bi"><span id="e6ed" class="mu lj it lh b gy mv mw l mx my">1 2 3 4 5 6 6 7 7 9<br/>12 12 13 17 17 19 19 22 23 24<br/>24 24 25 27 27 28 28 30 30 30<br/>30 32 34 35 36 36 37 38 38 39<br/>39 40 41 41 42 42 42 42 43 43<br/>43 45 45 46 47 48 48 49 49 51<br/>54 54 55 57 58 59 60 62 63 63<br/>65 65 65 67 68 68 69 70 70 71<br/>72 74 77 79 79 82 83 83 85 89<br/>91 91 92 92 93 94 95 96 96 100</span><span id="2624" class="mu lj it lh b gy mz mw l mx my">Enter value to search for: 49<br/>Found 49 in numbers.<br/>Enter value to search for: 97<br/>Did not find 97 in numbers.</span></pre><p id="1f9c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可能想知道<code class="fe le lf lg lh b">binary_search</code>函数是否适用于未排序的容器。让我们试一试:</p><pre class="mm mn mo mp gt mq lh mr ms aw mt bi"><span id="5b53" class="mu lj it lh b gy mv mw l mx my">int main () {<br/>  vector&lt;int&gt; numbers;<br/>  buildVec(numbers, 100);<br/>  //sort(numbers.begin(), numbers.end());<br/>  printVec(numbers);<br/>  cout &lt;&lt; endl &lt;&lt; endl;<br/>  int value;<br/>  for (int i = 1; i &lt;= 2; i++) {<br/>    cout &lt;&lt; "Enter value to search for: ";<br/>    cin &gt;&gt; value;<br/>    if (binary_search(numbers.begin(), numbers.end(), value)) {<br/>      cout &lt;&lt; "Found " &lt;&lt; value &lt;&lt; " in numbers." &lt;&lt; endl;<br/>    }<br/>    else {<br/>      cout &lt;&lt; "Did not find " &lt;&lt; value &lt;&lt; " in numbers."<br/>           &lt;&lt; endl;<br/>    }<br/>  }<br/>  return 0;<br/>}</span></pre><p id="f0f2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我注释掉了前面程序中的排序函数。让我们看看一些输出:</p><pre class="mm mn mo mp gt mq lh mr ms aw mt bi"><span id="fd2b" class="mu lj it lh b gy mv mw l mx my">42 68 35 1 70 25 79 59 63 65<br/>6 46 82 28 62 92 96 43 28 37<br/>92 5 3 54 93 83 22 17 19 96<br/>48 27 72 39 70 13 68 100 36 95<br/>4 12 23 34 74 65 42 12 54 69<br/>48 45 63 58 38 60 24 42 30 79<br/>17 36 91 43 89 7 41 43 65 49<br/>47 6 91 30 71 51 7 2 94 49<br/>30 24 85 55 57 41 67 77 32 9<br/>45 40 27 24 38 39 19 83 30 42</span><span id="8e7d" class="mu lj it lh b gy mz mw l mx my">Enter value to search for: 7<br/>Did not find 7 in numbers.<br/>Enter value to search for: 42<br/>Did not find 42 in numbers.</span></pre><p id="3caf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">显然，我搜索的值在容器中，但是函数没有找到它们。让这成为一个警告。不要试图对未排序的数据使用binary_search。</p><h1 id="227f" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">搜索多个值</h1><p id="03cb" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">下一个函数搜索一个容器，看它是否在容器的任何地方包含一组值(不是一个精确的序列)。这个功能就是<code class="fe le lf lg lh b">includes</code>。以下是该函数的语法模板:</p><p id="a8d8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="ml"> bool包含(range-start，range-end，search-start，search-end)；</em></p><p id="897f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有一个版本允许二元谓词函数参数，但我在这里只讨论第一个版本。</p><p id="d091" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下一个程序演示了如何使用<code class="fe le lf lg lh b">includes</code>函数来检查是否在容器中找到了一组值。代码如下:</p><pre class="mm mn mo mp gt mq lh mr ms aw mt bi"><span id="d3f5" class="mu lj it lh b gy mv mw l mx my">int main () {<br/>  vector&lt;int&gt; numbers;<br/>  buildVec(numbers, 100);<br/>  sort(numbers.begin(), numbers.end());<br/>  printVec(numbers);<br/>  cout &lt;&lt; endl &lt;&lt; endl;<br/>  cout &lt;&lt; "Searching for 72, 82, and 92 in numbers."<br/>       &lt;&lt; endl &lt;&lt; endl;<br/>  vector&lt;int&gt; searched = {72, 82, 92};<br/>  if (includes(numbers.begin(), numbers.end(),<br/>               searched.begin(), searched.end())) {<br/>    cout &lt;&lt; "Found all elements of searched in numbers."<br/>         &lt;&lt; endl;<br/>  }<br/>  else {<br/>    cout &lt;&lt; "Did not find all elements of searched in numbers."<br/>         &lt;&lt; endl;<br/>  }<br/>  return 0;<br/>}</span></pre><p id="3a26" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个程序的输出是:</p><pre class="mm mn mo mp gt mq lh mr ms aw mt bi"><span id="420e" class="mu lj it lh b gy mv mw l mx my">1 2 3 4 5 6 6 7 7 9<br/>12 12 13 17 17 19 19 22 23 24<br/>24 24 25 27 27 28 28 30 30 30<br/>30 32 34 35 36 36 37 38 38 39<br/>39 40 41 41 42 42 42 42 43 43<br/>43 45 45 46 47 48 48 49 49 51<br/>54 54 55 57 58 59 60 62 63 63<br/>65 65 65 67 68 68 69 70 70 71<br/>72 74 77 79 79 82 83 83 85 89<br/>91 91 92 92 93 94 95 96 96 100</span><span id="e7a2" class="mu lj it lh b gy mz mw l mx my"><br/>Searching for 72, 82, and 92 in numbers.</span><span id="7d32" class="mu lj it lh b gy mz mw l mx my">Found all elements of searched in numbers.</span></pre><p id="bf9e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">关于<code class="fe le lf lg lh b">includes</code>函数的最后一件事——用户需要确保两个范围都按照相同的标准排序，以使函数正确工作。</p><h1 id="266a" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">寻找第一个和最后一个位置</h1><p id="2127" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">接下来的两个函数用于确定值在容器中的第一个位置和最后一个位置。这些功能是<code class="fe le lf lg lh b">lower_bound</code>和<code class="fe le lf lg lh b">upper_bound</code>。例如，如果容器中有一组相等的数字，而您想要将另一组相同值的数字插入到容器中，则可以使用这些函数来确定插入值的安全位置范围。</p><p id="50f5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是这些函数的两个最常见版本的语法模板:</p><p id="3eba" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="ml">forward _ iterator lower _ bound(范围开始，范围结束，值)；<br/>forward _ iterator upper _ bound(范围开始，范围结束，值)；</em></p><p id="e6c6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面的程序演示了如何使用<code class="fe le lf lg lh b">lower_bound</code>和<code class="fe le lf lg lh b">upper_bound</code>来确定在何处插入一个值，以保持当前的顺序。程序使用函数找到指定值的开始和结束位置，然后使用由<code class="fe le lf lg lh b">lower_bound</code>返回的迭代器插入该值。程序是这样的:</p><pre class="mm mn mo mp gt mq lh mr ms aw mt bi"><span id="1bb7" class="mu lj it lh b gy mv mw l mx my">int main () {<br/>  vector&lt;int&gt; numbers;<br/>  buildVec(numbers, 100);<br/>  sort(numbers.begin(), numbers.end());<br/>  printVec(numbers);<br/>  cout &lt;&lt; endl &lt;&lt; endl;<br/>  int value;<br/>  cout &lt;&lt; "What value do you want to insert? ";<br/>  cin &gt;&gt; value;<br/>  auto lower = lower_bound(numbers.begin(),<br/>                           numbers.end(), value);<br/>  auto upper = upper_bound(numbers.begin(),<br/>                           numbers.end(), value);<br/>  int firstPos = int(lower - numbers.begin());<br/>  int lastPos = int(upper - numbers.begin());<br/>  cout &lt;&lt; "You can insert " &lt;&lt; value &lt;&lt; " between positions "<br/>       &lt;&lt; firstPos &lt;&lt; " and " &lt;&lt; lastPos &lt;&lt; "." &lt;&lt; endl &lt;&lt; endl;<br/>  numbers.insert(lower, value);<br/>  printVec(numbers);<br/>  return 0;<br/>}</span></pre><p id="9264" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是这个程序运行一次的输出:</p><pre class="mm mn mo mp gt mq lh mr ms aw mt bi"><span id="d991" class="mu lj it lh b gy mv mw l mx my">1 2 3 4 5 6 6 7 7 9<br/>12 12 13 17 17 19 19 22 23 24<br/>24 24 25 27 27 28 28 30 30 30<br/>30 32 34 35 36 36 37 38 38 39<br/>39 40 41 41 42 42 42 42 43 43<br/>43 45 45 46 47 48 48 49 49 51<br/>54 54 55 57 58 59 60 62 63 63<br/>65 65 65 67 68 68 69 70 70 71<br/>72 74 77 79 79 82 83 83 85 89<br/>91 91 92 92 93 94 95 96 96 100</span><span id="1634" class="mu lj it lh b gy mz mw l mx my">What value do you want to insert? 17</span><span id="62d0" class="mu lj it lh b gy mz mw l mx my">You can insert 17 between positions 13 and 15.</span><span id="a11b" class="mu lj it lh b gy mz mw l mx my">1 2 3 4 5 6 6 7 7 9<br/>12 12 13 17 17 17 19 19 22 23<br/>24 24 24 25 27 27 28 28 30 30<br/>30 30 32 34 35 36 36 37 38 38<br/>39 39 40 41 41 42 42 42 42 43<br/>43 43 45 45 46 47 48 48 49 49<br/>51 54 54 55 57 58 59 60 62 63<br/>63 65 65 65 67 68 68 69 70 70<br/>71 72 74 77 79 79 82 83 83 85<br/>89 91 91 92 92 93 94 95 96 96<br/>100</span></pre><p id="7163" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">还有一个函数将返回被搜索值的第一个位置和最后一个位置。这个功能就是<code class="fe le lf lg lh b">equal_range</code>。此函数返回一个<code class="fe le lf lg lh b">pair</code>，其中<code class="fe le lf lg lh b">first</code>字段保存找到值的第一个位置，而<code class="fe le lf lg lh b">second </code>字段保存找到值的最后一个位置。</p><p id="694f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是<code class="fe le lf lg lh b">equal_range</code>函数的语法模板:</p><p id="57a4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="ml">对&lt;前向迭代器，前向迭代器&gt; equal_range(range-start，range-end，<br/>value)；</em></p><p id="9349" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面的程序提示用户输入他们想要插入的值，并告诉用户第一个位置和最后一个位置，这将使排序顺序得以保留。程序如下:</p><pre class="mm mn mo mp gt mq lh mr ms aw mt bi"><span id="be09" class="mu lj it lh b gy mv mw l mx my">int main () {<br/>  vector&lt;int&gt; numbers;<br/>  buildVec(numbers, 100);<br/>  sort(numbers.begin(), numbers.end());<br/>  printVec(numbers);<br/>  cout &lt;&lt; endl &lt;&lt; endl;<br/>  int value;<br/>  cout &lt;&lt; "What value do you want to insert? ";<br/>  cin &gt;&gt; value;<br/>  auto positions = equal_range(numbers.begin(), numbers.end(),<br/>                               value);<br/>  cout &lt;&lt; "The first position you can insert at is: "<br/>       &lt;&lt; *positions.first &lt;&lt; endl;<br/>  cout &lt;&lt; "The last position you can insert at is: "<br/>       &lt;&lt; *positions.second &lt;&lt; endl;<br/>  return 0;<br/>}</span></pre><p id="fed5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个程序的输出是:</p><pre class="mm mn mo mp gt mq lh mr ms aw mt bi"><span id="e592" class="mu lj it lh b gy mv mw l mx my">1 2 3 4 5 6 6 7 7 9<br/>12 12 13 17 17 19 19 22 23 24<br/>24 24 25 27 27 28 28 30 30 30<br/>30 32 34 35 36 36 37 38 38 39<br/>39 40 41 41 42 42 42 42 43 43<br/>43 45 45 46 47 48 48 49 49 51<br/>54 54 55 57 58 59 60 62 63 63<br/>65 65 65 67 68 68 69 70 70 71<br/>72 74 77 79 79 82 83 83 85 89<br/>91 91 92 92 93 94 95 96 96 100</span><span id="61f3" class="mu lj it lh b gy mz mw l mx my"><br/>What value do you want to insert? 17<br/>The first position you can insert at is: 17<br/>The last position you can insert at is: 19</span></pre><h1 id="e2e3" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">在第2部分中</h1><p id="3979" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">这就完成了第一组排序范围算法。在我的下一篇文章中，我将介绍一些用于合并两个容器的算法，找出两个有序集合的并集和交集，并找出两个有序集合的差异。</p><p id="a4d2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢您的阅读，请给我发电子邮件提出意见和建议。</p></div></div>    
</body>
</html>