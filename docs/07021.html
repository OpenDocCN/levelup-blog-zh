<html>
<head>
<title>One repository, many AWS Lambda functions: Conditional deployment with GitLab CI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一个存储库，多个AWS Lambda函数:使用GitLab CI的条件部署</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/aws-lambda-in-production-deploy-a-monorepo-with-gitlab-ci-4ecc84f89263?source=collection_archive---------12-----------------------#2021-01-19">https://levelup.gitconnected.com/aws-lambda-in-production-deploy-a-monorepo-with-gitlab-ci-4ecc84f89263?source=collection_archive---------12-----------------------#2021-01-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="b5e7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<a class="ae kl" href="https://www.textcloud.co" rel="noopener ugc nofollow" target="_blank"> textcloud </a>，我们在AWS Lambda上运行<a class="ae kl" href="https://www.textcloud.co" rel="noopener ugc nofollow" target="_blank">我们的工作流自动化平台</a>的核心。这使我们能够为客户提供快速可靠的体验。无论用户是每周运行一次简单的工作流，还是需要对数千个Airtable行进行情感分析，我们的基础设施都需要具有极高的可伸缩性。</p><p id="db85" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将所有Lambda函数的代码存储在一个存储库中。尽管monorepo非常适合所有函数共享大量代码的用例，但当涉及到我们的CI/CD管道时，它也有缺点:<strong class="jp ir">我们只想构建和部署在提交中发生变化的函数，而不是所有的函数<em class="km"/>。</strong>本文展示了我们是如何解决这个问题的。</p></div><div class="ab cl kn ko hu kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="ij ik il im in"><p id="337e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你对这个话题感兴趣，你可以在这里找到我的一些其他文章:</p><ul class=""><li id="2f7c" class="ku kv iq jp b jq jr ju jv jy kw kc kx kg ky kk kz la lb lc bi translated"><a class="ae kl" href="https://gntrm.medium.com/aws-lambda-in-production-deploy-python-functions-through-gitlab-ci-9c4aa1392600" rel="noopener">第1部分:通过GitLab CI部署AWS Lambda Python函数</a></li><li id="ad60" class="ku kv iq jp b jq ld ju le jy lf kc lg kg lh kk kz la lb lc bi translated"><a class="ae kl" href="https://gntrm.medium.com/schedule-your-lambda-functions-with-boto3-cron-e7ee4efc887" rel="noopener">用Python和boto3编程调度Lambda函数</a></li><li id="eee1" class="ku kv iq jp b jq ld ju le jy lf kc lg kg lh kk kz la lb lc bi translated"><a class="ae kl" href="https://gntrm.medium.com/goodbye-php-goodbye-mailchimp-how-to-build-a-simple-email-list-directly-from-your-landing-page-fcb776ce7085" rel="noopener">用idea+Airtable+AWS Lambda建立一个电子邮件列表</a></li></ul><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="gh gi li"><img src="../Images/e0f0d58c2d868ef0fa737b63702399c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1BMyU_viTdraT6sS"/></div></div><figcaption class="lu lv gj gh gi lw lx bd b be z dk translated"><a class="ae kl" href="https://unsplash.com/@mariogogh?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">马里奥·高</a>在<a class="ae kl" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="5508" class="ly lz iq bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">目标是:只部署已经改变的项目</h1><p id="cc30" class="pw-post-body-paragraph jn jo iq jp b jq mw js jt ju mx jw jx jy my ka kb kc mz ke kf kg na ki kj kk ij bi translated">这篇短文解释了如何为带有几个子项目的单个存储库配置GitLab CI。我们的目标是只为提交中已经更改的子项目运行构建/部署管道，而忽略其余的。</p><p id="b006" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另一个要求是每个子项目作为不同的作业运行。这为我们提供了更好的控制，并允许我们仅手动触发某些部署。它还加快了速度，因为所有部署都可以并行运行。</p><p id="0427" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如我前面提到的，本文<a class="ae kl" href="https://gntrm.medium.com/aws-lambda-in-production-deploy-python-functions-through-gitlab-ci-9c4aa1392600" rel="noopener">建立在我之前关于从GitLab CI </a>部署无服务器功能的教程之上，所以我不会详细讨论实际的部署代码。</p><h1 id="261d" class="ly lz iq bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">分步操作:编写GitLab CI配置</h1><h2 id="4073" class="nb lz iq bd ma nc nd dn me ne nf dp mi jy ng nh mm kc ni nj mq kg nk nl mu nm bi translated">有什么变化？</h2><p id="dcd3" class="pw-post-body-paragraph jn jo iq jp b jq mw js jt ju mx jw jx jy my ka kb kc mz ke kf kg na ki kj kk ij bi translated">首先，我们需要获得在当前提交中已经更改的所有文件的列表。我们可以使用以下命令来实现这一点:</p><p id="94d0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe nn no np nq b">git diff-tree --no-commit-id --compact-summary --name-only -r $CI_COMMIT_SHORT_SHA</code></p><p id="035d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">输出看起来有点像这样:</p><pre class="lj lk ll lm gt nr nq ns nt aw nu bi"><span id="4a13" class="nb lz iq nq b gy nv nw l nx ny">lang_detection/poetry.lock<br/>schedule/poetry.lock<br/>sentiment/package.json<br/>template/{{ cookiecutter.project_slug }}/serverless.yml<br/>translation/poetry.lock</span></pre><p id="d2c7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们实际上并不关心有什么样的变化(添加/删除/修改)，任何变化都应该触发新的部署。</p><p id="1c9a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下一步是提取每个项目的根文件夹。我们可以通过将输出管道化到grep: <code class="fe nn no np nq b">grep -oE "^\\w+"</code>来做到这一点。</p><p id="f04a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这为我们提供了所有已更改文件夹的列表。但是，我们仍然要清理一下，以消除重复:<code class="fe nn no np nq b">sort | uniq</code></p><p id="1ad7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">总结起来，以下命令为我们提供了包含变更的所有根文件夹的名称:</p><p id="fceb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe nn no np nq b">git diff-tree --no-commit-id --compact-summary --name-only -r $CI_COMMIT_SHORT_SHA | grep -oE "^\\w+" | sort | uniq</code></p><h2 id="3e8a" class="nb lz iq bd ma nc nd dn me ne nf dp mi jy ng nh mm kc ni nj mq kg nk nl mu nm bi translated">GitLab CI中的继承</h2><p id="eeba" class="pw-post-body-paragraph jn jo iq jp b jq mw js jt ju mx jw jx jy my ka kb kc mz ke kf kg na ki kj kk ij bi translated">现在让我们进入GitLab配置文件:我们的策略是为部署创建一个常规作业，另外为每个项目创建一个作业。每个项目作业都应该从部署作业继承脚本，同时指定其根目录的名称。</p><p id="d97d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的部署函数可以是这样的:</p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="e2c0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我解释一下步骤:</p><ol class=""><li id="ee0c" class="ku kv iq jp b jq jr ju jv jy kw kc kx kg ky kk ob la lb lc bi translated">首先，我们列出所有已更改的文件夹。</li><li id="236c" class="ku kv iq jp b jq ld ju le jy lf kc lg kg lh kk ob la lb lc bi translated">然后我们检查当前目录是否是这个列表的一部分。</li><li id="c2fd" class="ku kv iq jp b jq ld ju le jy lf kc lg kg lh kk ob la lb lc bi translated">我们将部署脚本封装到一个if语句中，并运行部署，在本例中:<code class="fe nn no np nq b">cd $CURRENT_PROJECT &amp;&amp; sls plugin install -n serverless-python-requirements &amp;&amp; sls deploy</code></li></ol><p id="cc1d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于每个文件夹，我们可以定义一个更小的作业:</p><pre class="lj lk ll lm gt nr nq ns nt aw nu bi"><span id="6566" class="nb lz iq nq b gy nv nw l nx ny">deploy_sentiment:<br/>  extends: .deploy<br/>  variables:<br/>    CURRENT_PROJECT: sentiment</span></pre><p id="c7f2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个例子中，项目文件夹被称为“情绪”,它包含我们用于情绪分析的Lambda函数。我们从<code class="fe nn no np nq b">.deploy</code>函数继承代码，并设置一个变量来指定我们想要检查的文件夹。</p><p id="2e57" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们现在向GitLab推送新的变更，它将运行<code class="fe nn no np nq b">deploy_sentiment</code>作业，检查变更列表，然后决定是否部署。</p><p id="dd96" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是这个作业定义看起来还是有点多余:我们已经在作业标题中有了文件夹的名称，为什么还需要再次将其设置为变量呢？幸运的是，部署脚本中有一个<code class="fe nn no np nq b">$CI_JOB_NAME</code>变量！</p><p id="3f29" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们简单地添加步骤<code class="fe nn no np nq b">export CURRENT_PROJECT=$(echo $CI_JOB_NAME | sed 's/deploy_//g')</code>来从作业名中去掉前缀<code class="fe nn no np nq b">deploy_</code>并获得目录名。</p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="gh gi oc"><img src="../Images/6146d186e965e2bf84f736bf1e955f69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*7LjLYkOdW1w9lZUwA2-wJA.gif"/></div></div></figure><h1 id="5a77" class="ly lz iq bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">最终GitLab配置项配置</h1><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="0034" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">编码快乐！或者，如果AWS已经让您落泪，<a class="ae kl" href="https://www.textcloud.co/" rel="noopener ugc nofollow" target="_blank">看看textcloud，看看工作流自动化+自然语言处理</a>如何通过自动化复杂的工作来帮助您的公司节省时间和资金:)</p><p id="28be" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您在让AWS Lambda与GitLab CI一起工作时遇到问题，请随时联系我！</p></div></div>    
</body>
</html>