<html>
<head>
<title>What I’ve Learned Using Cypress.io for the Past Three Weeks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在过去的三周里，我从Cypress.io中学到了什么</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/what-ive-learnt-using-cypress-io-for-the-past-three-weeks-c1597999cd2f?source=collection_archive---------0-----------------------#2019-01-18">https://levelup.gitconnected.com/what-ive-learnt-using-cypress-io-for-the-past-three-weeks-c1597999cd2f?source=collection_archive---------0-----------------------#2019-01-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/ac882f5ed94425424340a0f29eb9eb06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jkb_tsMBOvL6wQ8bzldu8Q.png"/></div></div></figure><p id="38e4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你正在阅读这篇博客，你可能听说过端到端测试、集成测试、单元测试和UI测试。然而，就在三周前，这些短语对我来说是完全陌生的。事实上，软件测试作为一个整体对我来说基本上是一个陌生的概念。</p><p id="a6c3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">仅仅三周前，我还在我的编码训练营中，完成了毕业所需的两个项目中的第一个。对于我的第二个项目，我有幸有机会在一家名为<strong class="ka ir"> HBSmith </strong>的软件测试初创公司开始实习。作为这次实习的一部分，我和我的一个合作伙伴一起承担了一个项目，使用Cypress.io为知名网站创建UI测试。这将作为官方公司<a class="ae kw" href="https://hbsmith.io/" rel="noopener ugc nofollow" target="_blank">网站</a>主页上的宣传材料。</p><p id="2cf0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，在过去的几周里，我一直致力于学习Cypress.io、<a class="ae kw" href="https://www.zuaneducation.com/software-testing-training-course" rel="noopener ugc nofollow" target="_blank">软件测试</a>及其应用的复杂性。在这个博客中，我希望整理我的想法，分享我新获得的知识。</p><h1 id="6e04" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">柏树是什么？</h1><p id="af8e" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">Cypress是一个Javascript <a class="ae kw" href="https://www.techopedia.com/definition/7035/end-to-end-test" rel="noopener ugc nofollow" target="_blank">端到端</a>测试框架，它允许你为前端代码和UI有效地、逻辑地编写测试。在过去，这是众所周知的困难。它允许在web应用程序中模拟普通用户交互的测试，同时还提供大量额外的信息和工具。</p><p id="e638" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Cypress是一个相对较新的测试框架，所以仍然存在一些bug和缺失的特性。但是，它普遍受到好评，并且正在积极开发中。在过去，<a class="ae kw" href="https://www.seleniumhq.org/" rel="noopener ugc nofollow" target="_blank"> Selenium </a>主要是构建端到端测试的唯一方法，但是最近几年，这些测试工具出现了热潮，Cypress是先驱之一。</p><h1 id="8c02" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">那么为什么是赛普拉斯呢？</h1><p id="8f4d" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">硒几乎是15年前的技术。在这段时间里，网络发生了巨大的变化，因此，测试也应该如此。Cypress是一个全新的测试框架，它是为当今web的高响应性、异步性而定制的。这允许快速和一致的测试结果。以下是其官方<a class="ae kw" href="https://docs.cypress.io/guides/overview/why-cypress.html" rel="noopener ugc nofollow" target="_blank">网站</a>上宣传的一些主要特性和优势。</p><h2 id="9e83" class="ma ky iq bd kz mb mc dn ld md me dp lh kj mf mg ll kn mh mi lp kr mj mk lt ml bi translated"><strong class="ak">可调试性</strong></h2><ul class=""><li id="f330" class="mm mn iq ka b kb lv kf lw kj mo kn mp kr mq kv mr ms mt mu bi translated">你可以使用熟悉的工具直接调试，比如Chrome开发工具。数百个定制的错误消息和堆栈跟踪也使得发现测试失败的地方变得容易。</li></ul><h2 id="4f9a" class="ma ky iq bd kz mb mc dn ld md me dp lh kj mf mg ll kn mh mi lp kr mj mk lt ml bi translated"><strong class="ak">自动等待</strong></h2><ul class=""><li id="b6c9" class="mm mn iq ka b kb lv kf lw kj mo kn mp kr mq kv mr ms mt mu bi translated">Cypress在继续前进之前会自动等待命令和断言。<em class="mv">不再有异步地狱</em>。Cypress将等待元素存在，等待元素停止动画，或者等待特定的网络请求完成。</li></ul><h2 id="b8b8" class="ma ky iq bd kz mb mc dn ld md me dp lh kj mf mg ll kn mh mi lp kr mj mk lt ml bi translated"><strong class="ak">实用建筑</strong></h2><ul class=""><li id="93d8" class="mm mn iq ka b kb lv kf lw kj mo kn mp kr mq kv mr ms mt mu bi translated">大多数测试工具(比如Selenium)都是在浏览器之外运行，并通过网络执行远程命令。相反，Cypress在与应用程序相同的循环中执行。这允许对每一个对象进行本地访问——<code class="fe mw mx my mz b">window</code>、<code class="fe mw mx my mz b">document</code>、一个DOM元素、应用程序实例等。</li></ul><h2 id="c3a8" class="ma ky iq bd kz mb mc dn ld md me dp lh kj mf mg ll kn mh mi lp kr mj mk lt ml bi translated"><strong class="ak">简易快捷方式</strong></h2><ul class=""><li id="939f" class="mm mn iq ka b kb lv kf lw kj mo kn mp kr mq kv mr ms mt mu bi translated">Cypress防止你被迫总是像用户一样为给定的情况产生状态。相反，你可以通过编程来交互和控制应用程序。(这将在后面显示)</li></ul><h1 id="4e61" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated"><strong class="ak">柏树在行动</strong></h1><p id="6953" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">在这一节中，我希望展示Cypress的一些关键特性和命令。我还将包括来自官方文档和我自己项目的示例代码。</p><h2 id="8b63" class="ma ky iq bd kz mb mc dn ld md me dp lh kj mf mg ll kn mh mi lp kr mj mk lt ml bi translated"><strong class="ak"> cy.visit </strong></h2><p id="00ec" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">这个命令将访问一个指定的URL，然后允许你与页面上的元素进行交互。</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="d424" class="ma ky iq mz b gy ni nj l nk nl">cy.visit(‘https://slack.com/signin')</span></pre><p id="c15a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个命令的<em class="mv">最佳实践</em>是在<code class="fe mw mx my mz b">cypress.json</code>文件中设置一个<strong class="ka ir"> baseUrl </strong>，这将允许您省略将它传递到这个命令中。通过设置一个<code class="fe mw mx my mz b">baseUrl</code>，您还可以避免在第一次运行测试时浪费宝贵的时间，因为Cypress会将主窗口直接加载到指定的<code class="fe mw mx my mz b">baseUrl</code>中。</p><p id="d9c4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<code class="fe mw mx my mz b">cypress.json</code></p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="1d8b" class="ma ky iq mz b gy ni nj l nk nl">{<br/>  "baseUrl": "https://slack.com"<br/>}</span></pre><p id="e752" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<code class="fe mw mx my mz b">exampletest.js</code></p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="1d07" class="ma ky iq mz b gy ni nj l nk nl">cy.visit(‘/signin’)</span></pre><h2 id="0ab6" class="ma ky iq bd kz mb mc dn ld md me dp lh kj mf mg ll kn mh mi lp kr mj mk lt ml bi translated"><strong class="ak"> cy.get / cy.contains </strong></h2><p id="494b" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">这两个命令是Cypress中任何UI测试的主干。它们有两个主要目的。</p><ol class=""><li id="21d9" class="mm mn iq ka b kb kc kf kg kj nm kn nn kr no kv np ms mt mu bi translated">检查某个元素或文本是否正确显示</li><li id="5dfa" class="mm mn iq ka b kb nq kf nr kj ns kn nt kr nu kv np ms mt mu bi translated">链接指定元素的动作或断言</li></ol><p id="92a8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">理想情况下，应该基于<code class="fe mw mx my mz b">data-*</code>属性选择元素，因为类和ID可以动态变化。然而，如果这是不可能的，只需确保您选择使用的选择器(类、id等。)不会轻易改变。</p><p id="9311" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="mv">例如</em>，对于看起来像这样的按钮:</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="bb5e" class="ma ky iq mz b gy ni nj l nk nl">&lt;button id="main" class="btn btn-large" data-cy="submit"&gt;<br/>    Submit<br/>&lt;/button&gt;</span></pre><p id="8e5f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="mv">最佳实践</em>是使用:</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="7df3" class="ma ky iq mz b gy ni nj l nk nl">cy.get(‘[data-cy=submit]’).click()</span><span id="643e" class="ma ky iq mz b gy nv nj l nk nl">// OR</span><span id="c288" class="ma ky iq mz b gy nv nj l nk nl">cy.contains(‘Submit’).click()</span></pre><p id="98b6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这些命令是相似的。<code class="fe mw mx my mz b">get</code>方法允许您根据元素(如<code class="fe mw mx my mz b">class</code>或<code class="fe mw mx my mz b">id</code>)来查找节点，而<code class="fe mw mx my mz b">contains</code>方法根据节点内部的测试来查找节点。</p><p id="bb61" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Cypress还在其测试浏览器中添加了一个名为“选择器游乐场”的功能，允许您快速找到屏幕上任何元素的选择器，如下所示。</p><figure class="na nb nc nd gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nw"><img src="../Images/af50ef94fb7c1a6ba188dfd84ddbc221.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*H3WFZWzni2q-FExa89kNOw.gif"/></div></div></figure><p id="60cd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="mv">总是确保仔细检查选择器，因为我发现它不是100%可靠。</em></p><h2 id="ec26" class="ma ky iq bd kz mb mc dn ld md me dp lh kj mf mg ll kn mh mi lp kr mj mk lt ml bi translated"><strong class="ak"> cy.request </strong></h2><p id="83fc" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">如前所述，Cypress允许通过某些命令实现简单的快捷方式，防止您总是像用户一样行事。<code class="fe mw mx my mz b">cy.request</code>是其中的一个命令，它允许你发出HTTP请求，看起来像是来自浏览器。该命令最明显的用途是生成登录用户的状态。它可以自动获取和设置cookies，让您完全绕过浪费时间总是使用用户界面登录。</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="1d9c" class="ma ky iq mz b gy ni nj l nk nl">cy.request({<br/>  method: 'POST',<br/>  url: '/login',<br/>  form: true,<br/>  body: {<br/>    username: 'hbsmith',<br/>    password: 'password123'<br/>  }<br/>})</span><span id="d3f7" class="ma ky iq mz b gy nv nj l nk nl">cy.getCookie('cypress-session-cookie').should('exist')</span></pre><p id="2f14" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上面的例子中，POST请求被发送到'/login '端点，通过这个，浏览器中的<code class="fe mw mx my mz b">cypress-session-cookie</code>将被自动设置，允许达到登录状态。</p><p id="93c3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一个好的做法是将这个<code class="fe mw mx my mz b">cy.request</code>包装在一个<a class="ae kw" href="https://docs.cypress.io/api/cypress-api/custom-commands.html" rel="noopener ugc nofollow" target="_blank">自定义Cypress命令</a>中，并将其放在<code class="fe mw mx my mz b">cypress/support/commands.js</code>文件中，这样它就可以在整个测试文件夹结构中重用。如下图所示:</p><p id="9d13" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">在</strong>在<code class="fe mw mx my mz b">commands.js</code></p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="6c16" class="ma ky iq mz b gy ni nj l nk nl">Cypress.Commands.add('login', function () {<br/>  cy.request({<br/>    method: 'POST',<br/>    url: '/login',<br/>    form: true,<br/>    body: {<br/>      username: 'hbsmith',<br/>      password: 'password123'<br/>    }<br/>  })<br/>})</span><span id="5b29" class="ma ky iq mz b gy nv nj l nk nl">// Thus, cy.login can be used in all other files</span></pre><h2 id="e59c" class="ma ky iq bd kz mb mc dn ld md me dp lh kj mf mg ll kn mh mi lp kr mj mk lt ml bi translated"><strong class="ak"> cy.wait </strong></h2><p id="4413" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">此命令允许您等待一段指定的时间，或者等待别名请求得到解决，然后再执行下一个命令。当涉及到Cypress不能完全识别的客户端渲染时，这个命令特别有用。</p><p id="5163" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">尽管您可以根据任意设置的时间等待资源加载，如下所示:</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="7bf1" class="ma ky iq mz b gy ni nj l nk nl">cy.wait(1000) // wait 1 second</span></pre><p id="f1ec" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不建议这样做，因为有更好的方法可以达到同样的效果。一种这样的方法是等待别名XHR响应。以下示例显示了如何等待请求。</p><p id="fee8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Trello:创建一个列表，将卡片拖放到新创建的列表中。</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="8569" class="ma ky iq mz b gy ni nj l nk nl">cy.server()<br/>cy.route(‘POST’, ‘/1/lists').as('postList')</span><span id="9005" class="ma ky iq mz b gy nv nj l nk nl">createCards()</span><span id="86fe" class="ma ky iq mz b gy nv nj l nk nl">createList() // sends POST request to ‘/1/lists'</span><span id="41f5" class="ma ky iq mz b gy nv nj l nk nl">cy.wait(‘@postList’)</span><span id="3132" class="ma ky iq mz b gy nv nj l nk nl">dragAndDropCardsToList()</span></pre><p id="29d5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上面的例子中，通过<code class="fe mw mx my mz b">cy.route</code>和<code class="fe mw mx my mz b">cy.server</code>为到“/1/lists”端点的POST请求设置了一个别名。然后，当一个列表被创建并且需要时间加载时，一个<code class="fe mw mx my mz b">cy.wait</code>命令被调用到别名“postList”路由。</p><p id="f93f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这实现了两个主要目标。</p><ol class=""><li id="83fb" class="mm mn iq ka b kb kc kf kg kj nm kn nn kr no kv np ms mt mu bi translated">Cypress知道在卡片被拖放之前，要等待新的列表被完全加载和创建。</li><li id="0069" class="mm mn iq ka b kb nq kf nr kj ns kn nt kr nu kv np ms mt mu bi translated">通过确保在创建新列表时发出正确的请求，并返回正确的响应，来减少测试的不完整性。</li></ol><h1 id="8f09" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated"><strong class="ak">克服赛普拉斯的局限性</strong></h1><p id="fbf3" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">到目前为止，Cypress不支持iframes和测试文件上传。然而，在本节中，我将介绍我发现的解决这两个问题的临时方法。</p><h2 id="f2c4" class="ma ky iq bd kz mb mc dn ld md me dp lh kj mf mg ll kn mh mi lp kr mj mk lt ml bi translated">内联框架</h2><p id="d5ae" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">由于驱动程序中的疏忽，Cypress不支持定位iframe中的任何元素或与之交互。在为协作工具<a class="ae kw" href="https://quip.com/" rel="noopener ugc nofollow" target="_blank"> Quip </a>实现测试时，我遇到了这个问题，但幸运的是我找到了一个足够简单的解决方案。</p><p id="bdc3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="mv">首先</em>，如果处理跨来源的iframes，<code class="fe mw mx my mz b">chromeWebSecurity</code>需要在<code class="fe mw mx my mz b">cypress.json</code>中设置为<code class="fe mw mx my mz b">false</code>。</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="3829" class="ma ky iq mz b gy ni nj l nk nl">{<br/>  "chromeWebSecurity": false<br/>}</span></pre><p id="6184" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后<em class="mv">，</em>为了在iframe中选择元素，您必须:</p><ol class=""><li id="a344" class="mm mn iq ka b kb kc kf kg kj nm kn nn kr no kv np ms mt mu bi translated"><code class="fe mw mx my mz b">cy.get</code>您想要定位的iframe</li><li id="7c29" class="mm mn iq ka b kb nq kf nr kj ns kn nt kr nu kv np ms mt mu bi translated"><code class="fe mw mx my mz b">cy.find</code>iframes内容中的元素</li><li id="9c5b" class="mm mn iq ka b kb nq kf nr kj ns kn nt kr nu kv np ms mt mu bi translated"><code class="fe mw mx my mz b">cy.wrap</code>该元素为了将适当的Cypress命令链离它</li></ol><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="254e" class="ma ky iq mz b gy ni nj l nk nl">cy.get('iframe').then($iframe =&gt; {<br/>  const $body = $iframe.contents().find('body')</span><span id="a594" class="ma ky iq mz b gy nv nj l nk nl">  cy.wrap($body)<br/>    .find('button')<br/>    .click()<br/>})</span></pre><p id="020c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我发现实现这一点的最有效的方法是将这一切放在一个定制的Cypress命令中。</p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="305f" class="ma ky iq mz b gy ni nj l nk nl">Cypress.Commands.add('iframe', (iframeSelector, elSelector) =&gt; {<br/>    return cy<br/>      .get(`iframe${iframeSelector || ''}`, { timeout: 10000 })<br/>      .should($iframe =&gt; {<br/>        expect($iframe.contents().find(elSelector||'body')).to.exist<br/>      })<br/>      .then($iframe =&gt; {<br/>        return cy.wrap($iframe.contents().find('body'))<br/>      })<br/>  })</span></pre><p id="2740" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，您可以为某些iframes起别名，并通过别名有效地链接Cypress命令。</p><p id="add7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> <em class="mv">妙语:创建日历事件</em> </strong></p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="856d" class="ma ky iq mz b gy ni nj l nk nl">cy.iframe('[title="Calendar"]').as('calenderIframe') // create alias</span><span id="7ba2" class="ma ky iq mz b gy nv nj l nk nl">cy.get('@calenderIframe') // use alias to efficiently chain commands<br/>      .find('.Calendar__day')<br/>      .eq(0)<br/>      .click()</span><span id="d810" class="ma ky iq mz b gy nv nj l nk nl">cy.get('@calenderIframe')<br/>      .find('.Calendar__day')<br/>      .eq(1)<br/>      .click()</span><span id="db9b" class="ma ky iq mz b gy nv nj l nk nl">cy.get('@calenderIframe')<br/>      .find('.Calendar__day')<br/>      .eq(2)<br/>      .click()</span></pre><h2 id="40bd" class="ma ky iq bd kz mb mc dn ld md me dp lh kj mf mg ll kn mh mi lp kr mj mk lt ml bi translated">文件上传</h2><p id="9704" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">我在测试Slack的文件上传功能时遇到了这个问题。到目前为止，Cypress还没有本地事件支持，所以还没有一个官方的方法来测试这个特定的函数。然而，作为一个临时的解决方法，你可以利用已经被烘焙成Cypress的<a class="ae kw" href="https://github.com/nolanlawson/blob-util" rel="noopener ugc nofollow" target="_blank"> Blob </a>库。根据为应用程序编写上传代码的方式，您将如何做略有不同，我发现上传图像文件的基本测试结构如下所示。</p><p id="01e8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">松弛:上传图像到输入元素</strong></p><pre class="na nb nc nd gt ne mz nf ng aw nh bi"><span id="cf29" class="ma ky iq mz b gy ni nj l nk nl">cy.fixture('images/image.png').as('image')<br/>      <br/>cy.get('input[type=file]').then($input =&gt; {<br/>        return Cypress.Blob.base64StringToBlob(this.image,<br/>        'image/png').then(<br/>          blob =&gt; {<br/>            const imageFile = new File([blob], 'image.png', { type:<br/>            'image/png' })<br/>            const dataTransfer = new DataTransfer()<br/>            dataTransfer.items.add(imageFile)<br/>            $input[0].files = dataTransfer.files<br/>          }<br/>        )<br/>      })</span></pre><p id="f367" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先将您想要上传的图像放入<code class="fe mw mx my mz b">fixture</code>文件夹，然后使用<code class="fe mw mx my mz b">cy.fixture</code>加载图像数据。然后<em class="mv">，</em>你将<code class="fe mw mx my mz b">cy.get</code>你想要上传到的<code class="fe mw mx my mz b">input</code>元素，并链接一个<code class="fe mw mx my mz b">then</code>命令。使用您为图像设置的别名<code class="fe mw mx my mz b">fixture</code>，然后将图像数据转换成Blob。在这个Blob表单中，您最终能够将它转移到<code class="fe mw mx my mz b">input</code>元素中。</p><h1 id="1901" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">结论</h1><p id="135c" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">尽管Cypress.io仍处于起步阶段，但其大量的特性和功能已经使其成为顶级框架。特别是在这个时代，测试和CI/CD是任何软件开发过程的关键部分，快速可靠的测试框架是必不可少的。到目前为止，Cypress可能还不能完全满足所有的需求，但是我毫不怀疑它会继续发展并最终克服它的局限性。</p></div><div class="ab cl nx ny hu nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="ij ik il im in"><figure class="na nb nc nd gt jr gh gi paragraph-image"><a href="https://levelup.gitconnected.com"><div class="gh gi oe"><img src="../Images/ff5028ba5a0041d2d76d2a155f00f05e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JaoZbi7tTKJ5vL7i2OAYMQ.png"/></div></a></figure><div class="of og gp gr oh oi"><a href="https://gitconnected.com/learn/javascript" rel="noopener  ugc nofollow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd ir gy z fp on fr fs oo fu fw ip bi translated">学习JavaScript -最佳JavaScript教程(2019) | gitconnected</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">前65名JavaScript教程-免费学习JavaScript。课程由开发人员提交并投票，从而实现…</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">gitconnected.com</p></div></div><div class="or l"><div class="os l ot ou ov or ow jw oi"/></div></div></a></div></div></div>    
</body>
</html>