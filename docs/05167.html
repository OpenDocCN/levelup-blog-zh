<html>
<head>
<title>JavaScript Problem Solvers: Rotate Image Matrix</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript问题解决程序:旋转图像矩阵</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-problem-solvers-rotate-image-matrix-c02323c1c2fb?source=collection_archive---------3-----------------------#2020-08-09">https://levelup.gitconnected.com/javascript-problem-solvers-rotate-image-matrix-c02323c1c2fb?source=collection_archive---------3-----------------------#2020-08-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5f21" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">案例010:及时排队</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4f5c8d227f89e54696287273a7c17055.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y2quu43zxJnd3Wh_GLeCUQ.png"/></div></div></figure><p id="c2ad" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我已经有一段时间没有写关于我解决的一个技术问题的博客了。事实是，我已经不像以前那样在HackerRank或LeetCode上磨蹭了，我所有的时间都花在了项目上。</p><p id="f0ff" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这种情况在本周发生了变化。今天的问题花了我很长时间来解决，比我愿意承认的时间要长，但提供了一个很好的机会来摆脱蜘蛛网，回到LeetCode的工作中。我想出的解决方案满足O(1)空间复杂度要求，运行时间复杂度为O(n * log n)(我认为)。</p><p id="7652" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我还想提一下，我最近发现了<a class="ae lq" href="https://codesignal.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="kw iu"> CodeSignal </strong> </a>，到目前为止我一直很喜欢它。我只是刚刚开始他们的面试实践轨道，但UI比LeetCode/HackerRank更上一层楼，他们的功能集和测试用例很扎实，每个问题的信息量都很好。如果你想换换环境，可以去看看。</p><p id="4778" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以，让我们开始解决。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h2 id="acb8" class="ly lz it bd ma mb mc dn md me mf dp mg ld mh mi mj lh mk ml mm ll mn mo mp mq bi translated">问题是</h2><p id="8f31" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated"><a class="ae lq" href="https://app.codesignal.com/interview-practice/task/5A8jwLGcEpTPyyjTB" rel="noopener ugc nofollow" target="_blank"> <strong class="kw iu">这里有一个链接，关于问题码信号</strong> </a></p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="23e4" class="ly lz it mx b gy nb nc l nd ne">You are given an n x n 2D matrix that represents an image. Rotate the image by 90 degrees (clockwise).</span><span id="4b3a" class="ly lz it mx b gy nf nc l nd ne"><em class="ng">Note: Try to solve this task in-place (with O(1) additional memory), since this is what you’ll be asked to do during an interview.</em></span><span id="62f1" class="ly lz it mx b gy nf nc l nd ne">Constraints:<br/>  1 ≤ a.length ≤ 100<br/>  a[i].length = a.length<br/>  1 ≤ a[i][j] ≤ 104</span><span id="916b" class="ly lz it mx b gy nf nc l nd ne">Input/Output:<br/>  [execution time limit] 4 seconds (js)<br/>  [input] array.array.integer a<br/>  [output] array.array.integer</span></pre></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h2 id="f04d" class="ly lz it bd ma mb mc dn md me mf dp mg ld mh mi mj lh mk ml mm ll mn mo mp mq bi translated">测试</h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h2 id="92fa" class="ly lz it bd ma mb mc dn md me mf dp mg ld mh mi mj lh mk ml mm ll mn mo mp mq bi translated">崩溃了</h2><p id="f6a3" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">从表面上看，这似乎很简单。但是有一个扳手在工作。所以，像我们一直做的那样，在做其他事情之前，让我们分解给我们的信息:</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="d1d9" class="ly lz it mx b gy nb nc l nd ne">You are given an n x n 2D matrix that represents an image.</span></pre><p id="69bb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们在第一句话中得到一条非常重要的信息:<code class="fe nj nk nl mx b">n x n 2D matrix</code>。<code class="fe nj nk nl mx b">n x n</code>表示给定矩阵中我们应该期望的行数/列数，由于矩阵是<code class="fe nj nk nl mx b">n x n</code>，行数将始终等于列数。这是巨大的，因为这意味着矩阵是线性相关的，如果我们愿意，我们可以在同一次迭代中对行和列执行操作。</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="9af1" class="ly lz it mx b gy nb nc l nd ne">Rotate the image by 90 degrees (clockwise)</span></pre><p id="7a98" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是我们的任务。在一个<code class="fe nj nk nl mx b">n x n 2D matrix</code>的上下文中，我们基本上需要将每一行翻转成一列。但是我们需要反过来这样做。</p><p id="328a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以，如果我们看看测试案例2:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="2ef9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这花了我一段时间来想象，或者至少是想象如何用代码做到这一点，所以我想在这里回顾一下。</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="09b0" class="ly lz it mx b gy nb nc l nd ne"><em class="ng">Note: Try to solve this task in-place (with O(1) additional memory), since this is what you’ll be asked to do during an interview.</em></span></pre><p id="d2ab" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是让事情变得有趣的转折。</p><p id="67ca" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我把这解释为:</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="29c9" class="ly lz it mx b gy nb nc l nd ne"><strong class="mx iu">This is a sorting algorithm</strong>: Swap numbers and set variables <strong class="mx iu"><em class="ng">only</em></strong></span><span id="78df" class="ly lz it mx b gy nf nc l nd ne"><strong class="mx iu">No extra data sets</strong>: No objects to store indices. No empty arrays to push into. Nothing. Everything must be done inline.</span><span id="fb39" class="ly lz it mx b gy nf nc l nd ne"><strong class="mx iu">No built in array methods</strong>: Since I am not 100% sure on the space complexity for each individual method in JavaScript (maybe I should be), that means no built in methods. No <em class="ng">reverse()</em>, <em class="ng">map()</em>, <em class="ng">sort()</em>, <em class="ng">filter(),</em> <em class="ng">indexOf()</em>, <em class="ng">shift()</em>, <em class="ng">push()</em>, etc.</span></pre><p id="0d42" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有空间复杂度为O(1)的方法吗？当然了。</p><p id="d299" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我想用它们吗？号码</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h2 id="994a" class="ly lz it bd ma mb mc dn md me mf dp mg ld mh mi mj lh mk ml mm ll mn mo mp mq bi translated">制约因素</h2><p id="972e" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">我不会担心我们可能遇到的大多数常见的边缘情况。我能想到的所有潜在的边缘情况都包含在约束条件中:</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="e7a5" class="ly lz it mx b gy nb nc l nd ne">1 ≤ a.length ≤ 100</span></pre><p id="a788" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nj nk nl mx b">a</code>代表整个矩阵，<code class="fe nj nk nl mx b">a.length</code>代表行数和列数。因为我们有一个下限<code class="fe nj nk nl mx b">1 ≤ a.length</code>，我们不必担心给定的矩阵是空的。不需要处理边缘情况的<code class="fe nj nk nl mx b">if</code>语句。<code class="fe nj nk nl mx b">a.length ≤ 100</code>的上限告诉我，我们必须小心解决方案的时间复杂度。100行和100列是一个很大的循环。</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="8a2a" class="ly lz it mx b gy nb nc l nd ne">a[i].length = a.length</span></pre><p id="14c5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是对我们之前被告知的内容的重申:<code class="fe nj nk nl mx b">n x n 2D matrix</code>。<code class="fe nj nk nl mx b">a[i].length = a.length</code>是<em class="ng">的另一种说法，“给定矩阵中的行数将总是等于列数。”</em></p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="e445" class="ly lz it mx b gy nb nc l nd ne">1 ≤ a[i][j] ≤ 104</span></pre><p id="d743" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nj nk nl mx b">a[i][j]</code>代表矩阵中的每个数字。虽然这不是我们得到的最基本的约束(我们所做的只是交换数字)，但对我们应该期望的元素有下限和上限总是好的。</p><p id="666b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">话虽如此，让我们着手解决这个问题。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h2 id="433d" class="ly lz it bd ma mb mc dn md me mf dp mg ld mh mi mj lh mk ml mm ll mn mo mp mq bi translated">嫌疑犯</h2><p id="052f" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">我为这个问题编写的伪代码比我解决过的任何其他问题都多，而且花在编写伪代码上的时间比编写/测试实际代码要多得多。所以我会用不同的方式来组织这个博客。</p><p id="e29e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先，我想更详细地介绍每一次迭代。我的解决方案遵循类似洋葱的交换模式，或者我称之为洋葱交换。</p><p id="0106" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了演示，让我们以文本案例3为例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="f9d3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">从<code class="fe nj nk nl mx b">row[0][0]</code>开始，我们希望所有的数字都以顺时针方向移动。在第一次迭代结束时，无论我们做什么，我们都希望<code class="fe nj nk nl mx b">row[0][0]</code>是正确的数字。因此，对于测试用例#3，我们希望6是5，它位于<code class="fe nj nk nl mx b">row[3][0]</code>。我们不希望在剩下的代码执行过程中不得不返回到<code class="fe nj nk nl mx b">row[0][0]</code>,所以为了工作，它必须以正确的数字结束。我们每次迭代都要访问一次，仅此而已。</p><p id="f2af" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">每个角落都是如此。在第一次迭代结束时，每个角必须处于正确的最终值。</p><p id="2b60" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以通过嵌套第二次迭代，并交换每个角的值，在第一次迭代中做到这一点:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="5b4f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">执行这3次交换后，矩阵角上的每个值都处于正确的最终位置，我们再也不用担心它们了。</p><p id="3513" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我们迭代的第二次循环中，我们可以对<code class="fe nj nk nl mx b">row[0][1]</code>处的数字重复相同的过程，并将其与层中的下一个数字交换:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="9516" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们现在在正确的位置上有了另一组数字。在嵌套循环的第三次迭代中，我们可以重复这种交换模式1次以上，并获得矩阵最外层中所有数字的正确和最终位置:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="a36f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们还希望我们的嵌套循环只运行3次，因为我们已经用<code class="fe nj nk nl mx b">row[0][0]</code>交换了<code class="fe nj nk nl mx b">row[0]</code>中的最后一个元素。我们可以通过将嵌套循环的上限设置为<code class="fe nj nk nl mx b">a.length - 1</code>来做到这一点。</p><p id="d28a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这种洋葱交换也适用于矩阵的任何内层。顺时针翻转数字的相同模式仍然成立。我们可以递增并使用<code class="fe nj nk nl mx b">i</code>和<code class="fe nj nk nl mx b">j</code>来访问每个后续层。</p><p id="a5b0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们设置<code class="fe nj nk nl mx b">j = i</code>，在<code class="fe nj nk nl mx b">i = 1</code>处的整个循环的第二次迭代中，我们可以访问测试用例#3的内层:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="faa7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">矩阵“内层”中的所有值现在也处于正确的最终位置。整个矩阵顺时针旋转了90度，仅用了4次迭代。我们可以从循环中退出<code class="fe nj nk nl mx b">return a</code>。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h2 id="8c65" class="ly lz it bd ma mb mc dn md me mf dp mg ld mh mi mj lh mk ml mm ll mn mo mp mq bi translated">变量</h2><p id="0f51" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">既然我们已经找到了一个可以将矩阵旋转90度的可重复模式，我们需要开始设置和分配变量，这样我们就可以让这个模式与给我们的任何<code class="fe nj nk nl mx b">n x n</code>矩阵一起工作。</p><p id="55c6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们看一下每次迭代的操作，就会发现一个模式:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="7215" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这告诉我，在嵌套迭代的每个循环中，我们需要额外的变量来递增和递减。我们可以使用<code class="fe nj nk nl mx b">j</code>作为我们需要增加的变量，因为<code class="fe nj nk nl mx b">j</code>在每次嵌套迭代中自然增加。</p><p id="09f1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是我们将需要添加另一个变量，我们可以减少…在某处。</p><p id="b5c9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们设置<code class="fe nj nk nl mx b">j = i</code>，我们可以用行<code class="fe nj nk nl mx b">[i][j]</code>替换<code class="fe nj nk nl mx b">row[0][0]</code>，因为<code class="fe nj nk nl mx b">j</code>将自然地在每个内层的每次重新迭代中从正确的位置开始。有了洋葱互换，<code class="fe nj nk nl mx b">j</code>开始向外，向内。</p><p id="a33c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是当我们查看整个迭代的第二个循环时，出现了一个问题:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="0ca9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">第一部分看起来不错。但是第二部分的模式与第一次迭代不同。测试用例#3的“内层”是<code class="fe nj nk nl mx b">2 x 2</code>，代表我们需要交换数字的最小子矩阵。</p><p id="ca72" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">没关系。这种模式对于矩阵中不是<code class="fe nj nk nl mx b">2 x 2</code>的每一层仍然成立。我们可以通过用<code class="fe nj nk nl mx b">(a.length - 1) - i</code>初始化我们在父<code class="fe nj nk nl mx b">for</code>循环中递减的变量来解决这个问题，并将其作用于嵌套迭代之外，以防止它在每次嵌套循环迭代时重置。</p><p id="c756" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们再来看看我们的迭代，但是添加我们想要减少的变量<code class="fe nj nk nl mx b">x</code>，并用<code class="fe nj nk nl mx b">x</code>、<code class="fe nj nk nl mx b">i</code>和<code class="fe nj nk nl mx b">j</code>替换适当的静态值:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="930d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这样我们就剩下1个静态值需要计算。</p><p id="c8ca" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">从表面上看，它也遵循一种模式。它在每个嵌套循环中保持不变，但在整个循环的每次迭代中需要减1。因此，我们可以使用它并添加另一个用<code class="fe nj nk nl mx b">a.length - 1</code>初始化的变量<code class="fe nj nk nl mx b">y</code>。这是为了确保它对给定矩阵的大小保持动态。我们还可以在两个循环之外确定它的范围，这样它就不会在我们解决方案的整个执行过程中重置，并在每次整个<code class="fe nj nk nl mx b">for</code>循环迭代时递减<code class="fe nj nk nl mx b">y</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="efc9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这满足了将洋葱交换付诸实践所需的所有可变要求。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h2 id="d0c8" class="ly lz it bd ma mb mc dn md me mf dp mg ld mh mi mj lh mk ml mm ll mn mo mp mq bi translated">设置</h2><p id="d348" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">所以，让我们把它写成代码。</p><p id="7839" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">两个<code class="fe nj nk nl mx b">for</code>循环的工作方式如下:</p><p id="9c2e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">父循环将遍历矩阵的每个“层”。矩阵的“层数”由它的一半长度或<code class="fe nj nk nl mx b">a.length / 2</code>决定。因此，如果我们将父循环的上限设置为<code class="fe nj nk nl mx b">i &lt; a.length / 2</code>，它应该正确地遍历矩阵的每个“层”，而不会浪费任何迭代。如果是这样的话，整个纸牌屋都会倒塌。</p><p id="37d7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">嵌套循环是在每一行和每一列的元素中循环。每行/列中的元素数量总是相等的，但是对于每个内部“层”，我们需要迭代的行/列/元素的数量越来越少，直到我们到达中心。</p><p id="03bd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于给定的矩阵，如果<code class="fe nj nk nl mx b">n x n</code>是偶数，那么矩阵的中心将是<code class="fe nj nk nl mx b">2 x 2</code>，我们将需要执行1次最后的洋葱交换。如果<code class="fe nj nk nl mx b">n x n</code>是奇数，矩阵的中心将是<code class="fe nj nk nl mx b">1 x 1</code>，我们不需要交换任何东西，我们可以退出迭代。</p><p id="6048" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们回头看看需要使用<code class="fe nj nk nl mx b">y</code>变量的模式，这是有意义的。它基本上是我们想要在每个内层迭代的元素位置的上限。所以我们可以在嵌套循环中使用<code class="fe nj nk nl mx b">y</code>作为上限，并设置<code class="fe nj nk nl mx b">j &lt; y</code>来防止循环通过不存在的层。</p><p id="d028" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">也就是说，我们可以设置我们的两个<code class="fe nj nk nl mx b">for</code>循环，我们的变量，以及我们希望如何减少<code class="fe nj nk nl mx b">x</code>和<code class="fe nj nk nl mx b">y</code>变量:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="27d0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在那个<code class="fe nj nk nl mx b">for</code>循环夹层中间，我们可以添加所有的洋葱交换逻辑。我们只需要去掉伪代码，用<code class="fe nj nk nl mx b">a</code>替换<code class="fe nj nk nl mx b">row</code>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h2 id="ac0c" class="ly lz it bd ma mb mc dn md me mf dp mg ld mh mi mj lh mk ml mm ll mn mo mp mq bi translated">最终解决方案</h2><p id="4555" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">我们所写代码的唯一问题(也是最后一个问题)是，从技术上讲，我们没有交换任何东西。我们只是替换了<code class="fe nj nk nl mx b">a[i][j]</code>当前的值。</p><p id="a314" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们还需要1个变量<code class="fe nj nk nl mx b">t</code>来存储我们当前交换的数字，这样我们就可以用我们要替换的数字来交换它:</p><p id="1053" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nj nk nl mx b">let t = a[i][j]</code></p><p id="076c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后我们需要用刚刚交换了<code class="fe nj nk nl mx b">a[i][j]</code>的位置的值来交换临时变量:</p><p id="cf80" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nj nk nl mx b">a[j][y] = t</code>或<code class="fe nj nk nl mx b">a[y][x] = t</code>或<code class="fe nj nk nl mx b">a[x][i] = t</code></p><p id="13cd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，我们需要用<code class="fe nj nk nl mx b">a[i][j]</code>的新值更新<code class="fe nj nk nl mx b">t</code>的值，这样我们就可以对迭代的第二次和第三次交换重复这个过程:</p><p id="12ef" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nj nk nl mx b">t = a[i][j]</code></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="7ab8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，如果我们对我们拥有的5个测试用例运行我们的解决方案，我们应该通过每个测试:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/734698b03c09ec0c5365c7e55a5d243e.png" data-original-src="https://miro.medium.com/v2/resize:fit:828/format:webp/1*JnyS8Q2aw6C2ivbTMrPRkA.png"/></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/3cc7af4a2de3d2afa878bebab96bcba0.png" data-original-src="https://miro.medium.com/v2/resize:fit:718/format:webp/1*XYkWOEt39NbUB8RevbLQsw.png"/></div></div></figure><p id="c616" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">很好。</p></div><div class="ab cl lr ls hx lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="im in io ip iq"><h2 id="d443" class="ly lz it bd ma mb mc dn md me mf dp mg ld mh mi mj lh mk ml mm ll mn mo mp mq bi translated">任务完成</h2><p id="b221" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">因此，这是一个吃饱了，但一个月不磨回来的好问题。我也很喜欢我想出的解决方案(通常我不太满意)，洋葱交换真的提高了我解决问题的能力。在某些时候，我真的很想让它工作，这可能是我花了这么多时间在它上面的原因。</p><p id="5217" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我是不是把事情搞得太复杂了？也许吧。但这是值得努力的，而且效率惊人。</p><p id="e1d3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">再说一次，我写的关于解决LeetCode/HackerRank/CodeSignal问题的博客并不是为了找到时间或空间复杂度最低的解决方案。他们关注的是解决问题的步骤。我当然明白我的解决方案不会是最好或最有效的，但这一次我对结果相当满意。</p><p id="7399" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">不管怎样，我希望你得到了一些有用的信息，希望你所有的函数都返回true，所有的请求都用200来响应。</p><p id="5982" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">保持安全…保持健康…继续为正义而战。</p></div></div>    
</body>
</html>