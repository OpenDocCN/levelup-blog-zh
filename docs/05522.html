<html>
<head>
<title>The Non-Value Trio of JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript的无价值三重奏</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/the-non-value-trio-of-javascript-db609004e3ec?source=collection_archive---------5-----------------------#2020-09-06">https://levelup.gitconnected.com/the-non-value-trio-of-javascript-db609004e3ec?source=collection_archive---------5-----------------------#2020-09-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="2854" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">揭开未定义、Null和NaN的神秘面纱</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/b0f3a8cd9811c0c570368de8c1cceaf0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*ZqhdzfepppJHeOHJIG1Iwg.jpeg"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">照片由<a class="ae ku" href="https://unsplash.com/@krisatomic" rel="noopener ugc nofollow" target="_blank">克里斯原子</a>在<a class="ae ku" href="https://unsplash.com/photos/m5RYZ2s2ZCA" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="22d7" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">Undefined、Null和NaN是三个关键字，称为非值或空值，对于许多初学JavaScript的工程师来说，它们常常是错误代码、压力和困惑的来源。依我拙见，部分原因是它们在大多数课程或书籍中很少得到应有的重视。在这里，我们将试图给这个三重奏以应有的重视，并揭开它的神秘面纱。</p><h2 id="199b" class="lr ls it bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated">不明确的</h2><p id="fc23" class="pw-post-body-paragraph kv kw it kx b ky mk ju la lb ml jx ld le mm lg lh li mn lk ll lm mo lo lp lq im bi translated">这个关键字在JavaScript中既是数据类型又是值。它是六种原始数据类型之一，其他的有:<code class="fe mp mq mr ms b">string</code>、<code class="fe mp mq mr ms b">number</code>、<code class="fe mp mq mr ms b">boolean</code>、<code class="fe mp mq mr ms b">null</code>和<code class="fe mp mq mr ms b">symbol</code> (ES5+)。默认情况下，<em class="mt">被分配给任何尚未定义值的变量</em>。在更深的层次上，这意味着变量存在，但其不存在的值已被自动赋值为<code class="fe mp mq mr ms b"><em class="mt">undefined</em></code>。JavaScript是一种动态类型语言，这意味着JS引擎根据分配给它的值的数据类型来确定变量的类型。在这个上下文中，<code class="fe mp mq mr ms b">undefined</code>实际上意味着<em class="mt"> JavaScript不知道所声明变量的数据类型，因为它还没有用值</em>初始化。</p><blockquote class="mu"><p id="b046" class="mv mw it bd mx my mz na nb nc nd lq dk translated">任何未赋值的变量都会被自动赋予undefined的值和类型</p></blockquote><p id="685f" class="pw-post-body-paragraph kv kw it kx b ky ne ju la lb nf jx ld le ng lg lh li nh lk ll lm ni lo lp lq im bi translated">我们可以用下面的代码来说明这一点。</p><pre class="kj kk kl km gt nj ms nk nl aw nm bi"><span id="98b6" class="lr ls it ms b gy nn no l np nq">let myVar;  //declared but left unassigned<br/>console.log(myVar)</span></pre><p id="a466" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">输出:<code class="fe mp mq mr ms b">undefined</code></p><p id="026d" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><code class="fe mp mq mr ms b">undefined</code>也是一种数据类型，因此有如下说法:</p><pre class="kj kk kl km gt nj ms nk nl aw nm bi"><span id="bcd2" class="lr ls it ms b gy nn no l np nq">console.log(typeof myVar)</span></pre><p id="0721" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">输出:<code class="fe mp mq mr ms b">"undefined"</code></p><p id="7834" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">注意到<code class="fe mp mq mr ms b">undefined</code>的值和类型之间有一点点不同；后者在引号中。你可能在面试问题中发现的一个问题是:</p><p id="2b50" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><strong class="kx iu"/><code class="fe mp mq mr ms b"><strong class="kx iu">typeof typeof undefined</strong></code><strong class="kx iu">的值是多少？</strong></p><p id="60bb" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">答案是:<code class="fe mp mq mr ms b">string</code></p><p id="3393" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这意味着我们可以键入以下内容:</p><p id="140a" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><code class="fe mp mq mr ms b">console.log(typeof myvar + “ variable”)</code></p><p id="aada" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">输出:<code class="fe mp mq mr ms b">undefined variable</code></p><p id="68d0" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们因此可以说，在JavaScript中，<em class="mt">的数据类型</em> <code class="fe mp mq mr ms b"><em class="mt">undefined</em></code> <em class="mt">的数据类型是</em> <code class="fe mp mq mr ms b"><em class="mt">string</em></code>！</p><p id="8675" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">对于函数，如果返回值未赋值，则返回<code class="fe mp mq mr ms b">undefined</code>。更重要的是，如果没有返回值，函数也会返回<code class="fe mp mq mr ms b">undefined</code>。</p><pre class="kj kk kl km gt nj ms nk nl aw nm bi"><span id="f35f" class="lr ls it ms b gy nn no l np nq">function f(){<br/>   return;<br/>}</span><span id="f698" class="lr ls it ms b gy nr no l np nq">console.log(f())</span></pre><p id="dc39" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">输出:<code class="fe mp mq mr ms b">undefined</code></p></div><div class="ab cl ns nt hx nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="im in io ip iq"><h2 id="5e0d" class="lr ls it bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated">空</h2><p id="f1e4" class="pw-post-body-paragraph kv kw it kx b ky mk ju la lb ml jx ld le mm lg lh li mn lk ll lm mo lo lp lq im bi translated"><code class="fe mp mq mr ms b">Null</code>也是JavaScript中的原始数据类型，也可以赋值。然而，与<code class="fe mp mq mr ms b">undefined</code>不同的是，它的数据类型是<code class="fe mp mq mr ms b">Object</code>。</p><pre class="kj kk kl km gt nj ms nk nl aw nm bi"><span id="dcae" class="lr ls it ms b gy nn no l np nq">let myVar = null;<br/>console.log(myVar)</span></pre><p id="43f3" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">输出:<code class="fe mp mq mr ms b">null</code></p><pre class="kj kk kl km gt nj ms nk nl aw nm bi"><span id="e42a" class="lr ls it ms b gy nn no l np nq">Console.log(typeof myVar);</span></pre><p id="d6c5" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">输出:<code class="fe mp mq mr ms b">Object</code></p><blockquote class="mu"><p id="58c6" class="mv mw it bd mx my mz na nb nc nd lq dk translated"><strong class="ak"> null </strong>是一个有意的值，表示缺少预期的对象值</p></blockquote><p id="4111" class="pw-post-body-paragraph kv kw it kx b ky ne ju la lb nf jx ld le ng lg lh li nh lk ll lm ni lo lp lq im bi translated"><code class="fe mp mq mr ms b">null</code>用来故意给某物一个空值。不满足条件时让函数返回null是常见的做法。例如，JavaScript的内置<code class="fe mp mq mr ms b">match()</code>函数返回匹配给定字符串模式的<code class="fe mp mq mr ms b">object</code>，否则返回<code class="fe mp mq mr ms b">null</code>。</p><pre class="kj kk kl km gt nj ms nk nl aw nm bi"><span id="3444" class="lr ls it ms b gy nn no l np nq">console.log( "Abe".match(/[aeiou]/gi). )</span></pre><p id="3ff2" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">输出:<code class="fe mp mq mr ms b">[ ‘A’, ‘e’ ]</code></p><pre class="kj kk kl km gt nj ms nk nl aw nm bi"><span id="d869" class="lr ls it ms b gy nn no l np nq">console.log( "PS4".match(/[aeiou]/gi). )</span></pre><p id="99af" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">输出:<code class="fe mp mq mr ms b">null</code></p><p id="0ec4" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">如果找到匹配，则<code class="fe mp mq mr ms b">match()</code>的返回值是一个数组(一个对象),否则<code class="fe mp mq mr ms b">null</code>返回。因此，<code class="fe mp mq mr ms b">null</code>是一个预期的<strong class="kx iu"> <em class="mt">对象</em> </strong>值的有意缺失。理解null与对象一起使用是很重要的。</p><p id="ade7" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><code class="fe mp mq mr ms b">undefined</code>与<code class="fe mp mq mr ms b">null</code>的主要区别在于:</p><ul class=""><li id="2cc3" class="nz oa it kx b ky kz lb lc le ob li oc lm od lq oe of og oh bi translated"><code class="fe mp mq mr ms b">undefined</code>表示变量已知，但其值未知，因此其数据类型未知</li><li id="57e3" class="nz oa it kx b ky oi lb oj le ok li ol lm om lq oe of og oh bi translated"><code class="fe mp mq mr ms b">null</code>表示变量的数据类型是已知的(<code class="fe mp mq mr ms b">Object</code>)，但是它的值<em class="mt">故意留为未知(空)，因为没有对象与给定的环境相关。</em></li><li id="a97d" class="nz oa it kx b ky oi lb oj le ok li ol lm om lq oe of og oh bi translated">当数值未知时，<code class="fe mp mq mr ms b">undefined</code>是否被自动分配给<em class="mt"/></li><li id="48c1" class="nz oa it kx b ky oi lb oj le ok li ol lm om lq oe of og oh bi translated"><code class="fe mp mq mr ms b">null</code>是<em class="mt">故意分配的</em>，当没有相关对象时</li></ul><p id="6f0d" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">Null代表<em class="mt">虚无</em>或<em class="mt">不存在</em>，可以认为等同于0。事实上，在一些语言如C++和Java中，是这样的。</p><p id="452b" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">我们来看几个与<code class="fe mp mq mr ms b">null</code>和<code class="fe mp mq mr ms b">undefined</code>相关的怪癖。</p><pre class="kj kk kl km gt nj ms nk nl aw nm bi"><span id="9b2e" class="lr ls it ms b gy nn no l np nq">null === undefined   // false<br/>null  == undefined   // true</span></pre><p id="ca6f" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">第一条语句检查左边的值是否与右边的值完全一样。这就是'<em class="mt"> three </em> quals' (===)运算符的作用。对于double-equals，因为JavaScript是动态类型的，所以当它看到两个值时，它会试图找出它们的数据类型。如果两个值不属于同一类型，它会将其中一个值转换或<em class="mt">强制</em>(或<em class="mt">强制</em>)为另一个值的数据类型，<em class="mt">才会进行比较。例如，如果比较一个<code class="fe mp mq mr ms b">string</code>和一个<code class="fe mp mq mr ms b">number</code>，JavaScript会将前者强制转换为后者。这就是为什么<code class="fe mp mq mr ms b">0 == ‘0’</code>和<code class="fe mp mq mr ms b">‘0’ == false</code>是真的。将<code class="fe mp mq mr ms b">0</code>转换为类型<code class="fe mp mq mr ms b">number</code>，然后进行比较，返回true。类似地，由于类型强制，<code class="fe mp mq mr ms b">null</code>双倍等于<code class="fe mp mq mr ms b">undefined</code>。请记住，这是JavaScript特有的怪癖；在大多数语言中，这样一个令人困惑的概念并不存在。</em></p></div><div class="ab cl ns nt hx nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="im in io ip iq"><h2 id="dcf4" class="lr ls it bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated">圆盘烤饼</h2><p id="1a41" class="pw-post-body-paragraph kv kw it kx b ky mk ju la lb ml jx ld le mm lg lh li mn lk ll lm mo lo lp lq im bi translated">它代表“不是一个数字”，代表<em class="mt">没有有效数字</em>。这是无效计算的结果，例如对<code class="fe mp mq mr ms b">string</code>而不是<code class="fe mp mq mr ms b">number</code>进行算术运算。我们来看几个例子。</p><pre class="kj kk kl km gt nj ms nk nl aw nm bi"><span id="d619" class="lr ls it ms b gy nn no l np nq">1 * 'five'<br/>'ten' / 2</span></pre><p id="cabb" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">输出:<code class="fe mp mq mr ms b">NaN</code></p><pre class="kj kk kl km gt nj ms nk nl aw nm bi"><span id="2f73" class="lr ls it ms b gy nn no l np nq">let myVar = 'four'<br/>console.log( Math.sqrt(myVar) )</span></pre><p id="5813" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">输出:<code class="fe mp mq mr ms b">NaN</code></p><p id="2f3d" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">注意，由于类型强制，像<code class="fe mp mq mr ms b">‘5’ * 5</code>或<code class="fe mp mq mr ms b">Math.sqrt(‘4’)</code>这样的操作在JavaScript中都是有效的。然而，在类型强制不适用的情况下，那些操作将总是产生<code class="fe mp mq mr ms b">NaN</code>。</p><blockquote class="mu"><p id="7096" class="mv mw it bd mx my mz na nb nc nd lq dk translated"><code class="fe mp mq mr ms b">NaN</code>是由无效数学运算引起的错误的关键字</p></blockquote><p id="f730" class="pw-post-body-paragraph kv kw it kx b ky ne ju la lb nf jx ld le ng lg lh li nh lk ll lm ni lo lp lq im bi translated">让我们来看看这个关键字的一些奇怪之处。</p><pre class="kj kk kl km gt nj ms nk nl aw nm bi"><span id="e2a7" class="lr ls it ms b gy nn no l np nq">NaN == NaN</span></pre><p id="52a9" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">输出:<code class="fe mp mq mr ms b">false</code></p><p id="35a0" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">有时候发现一个操作是否有效是很有用的。</p><pre class="kj kk kl km gt nj ms nk nl aw nm bi"><span id="bc64" class="lr ls it ms b gy nn no l np nq">function checkIfValidOperation(operation){<br/>     if (operation === NaN)<br/>         console.log("Invalid Operation!");<br/>     else<br/>         console.log("Valid Operation!");<br/>}</span><span id="6c69" class="lr ls it ms b gy nr no l np nq">let myOp = Math.sqrt('four');    //NaN</span><span id="4469" class="lr ls it ms b gy nr no l np nq">checkIfValidOperation(myOp)      //???</span></pre><p id="d606" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">输出:<code class="fe mp mq mr ms b">Valid Operation!</code></p><p id="1dbb" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">出乎意料！<code class="fe mp mq mr ms b">myOp</code>不等于<code class="fe mp mq mr ms b">NaN</code>吗！？是的，但是比较是<code class="fe mp mq mr ms b">false</code>。这是因为在JavaScript中:</p><p id="0a35" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><code class="fe mp mq mr ms b">NaN</code> === <code class="fe mp mq mr ms b">NaN</code></p><p id="a05b" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">输出:<code class="fe mp mq mr ms b">false</code></p><p id="b5ea" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">这是这种语言的一个怪癖。为了测试一个操作是否产生<code class="fe mp mq mr ms b">NaN</code>，我们需要使用内置函数<code class="fe mp mq mr ms b">isNaN()</code>。</p><pre class="kj kk kl km gt nj ms nk nl aw nm bi"><span id="5220" class="lr ls it ms b gy nn no l np nq">isNaN(myOp);</span></pre><p id="3633" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">输出:<code class="fe mp mq mr ms b">true</code></p></div><div class="ab cl ns nt hx nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="im in io ip iq"><h2 id="2571" class="lr ls it bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated">结合这一切</h2><p id="e80b" class="pw-post-body-paragraph kv kw it kx b ky mk ju la lb ml jx ld le mm lg lh li mn lk ll lm mo lo lp lq im bi translated">结合我们的非价值三要素，我们可以提取额外的怪癖，例如:</p><pre class="kj kk kl km gt nj ms nk nl aw nm bi"><span id="f650" class="lr ls it ms b gy nn no l np nq">1 + null + 1</span></pre><p id="8f82" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">输出:<code class="fe mp mq mr ms b">2</code></p><p id="7444" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><code class="fe mp mq mr ms b">null + null</code></p><p id="d2ec" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">输出:<code class="fe mp mq mr ms b">0</code></p><p id="4d0d" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">那是因为<code class="fe mp mq mr ms b">null</code>受到了和<code class="fe mp mq mr ms b">0</code>一样的待遇。</p><pre class="kj kk kl km gt nj ms nk nl aw nm bi"><span id="06da" class="lr ls it ms b gy nn no l np nq">undefined + 1<br/>null + undefined</span></pre><p id="b89b" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">输出:<code class="fe mp mq mr ms b">NaN</code></p><p id="5446" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">那是预期行为。</p></div><div class="ab cl ns nt hx nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="im in io ip iq"><h2 id="19ee" class="lr ls it bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated"><strong class="ak">外卖</strong></h2><p id="0d20" class="pw-post-body-paragraph kv kw it kx b ky mk ju la lb ml jx ld le mm lg lh li mn lk ll lm mo lo lp lq im bi translated">我们可以将上述总结如下:</p><ul class=""><li id="e956" class="nz oa it kx b ky kz lb lc le ob li oc lm od lq oe of og oh bi translated"><code class="fe mp mq mr ms b">undefined</code>表示变量存在(已声明)，但其数据类型还不存在，因为它未赋值</li><li id="885c" class="nz oa it kx b ky oi lb oj le ok li ol lm om lq oe of og oh bi translated"><code class="fe mp mq mr ms b">undefined</code>在JavaScript中既是值又是数据类型</li><li id="eda2" class="nz oa it kx b ky oi lb oj le ok li ol lm om lq oe of og oh bi translated"><code class="fe mp mq mr ms b">undefined</code>的数据类型是<code class="fe mp mq mr ms b">‘undefined’</code>，是一个<code class="fe mp mq mr ms b">string</code></li><li id="bfd7" class="nz oa it kx b ky oi lb oj le ok li ol lm om lq oe of og oh bi translated"><code class="fe mp mq mr ms b">null</code>表示变量的数据类型存在，但其值故意留空</li><li id="aa63" class="nz oa it kx b ky oi lb oj le ok li ol lm om lq oe of og oh bi translated">在JavaScript中，null既是值也是数据类型</li><li id="ad05" class="nz oa it kx b ky oi lb oj le ok li ol lm om lq oe of og oh bi translated"><code class="fe mp mq mr ms b">null</code>的数据类型为<code class="fe mp mq mr ms b">Object</code></li><li id="24d5" class="nz oa it kx b ky oi lb oj le ok li ol lm om lq oe of og oh bi translated"><code class="fe mp mq mr ms b">null</code>与物体结合使用</li><li id="29f7" class="nz oa it kx b ky oi lb oj le ok li ol lm om lq oe of og oh bi translated"><code class="fe mp mq mr ms b">null</code>象征<em class="mt">无</em>并被视为<code class="fe mp mq mr ms b">0</code></li><li id="c01d" class="nz oa it kx b ky oi lb oj le ok li ol lm om lq oe of og oh bi translated"><code class="fe mp mq mr ms b">undefined</code>是自动的，<code class="fe mp mq mr ms b">null</code>是故意的</li><li id="dc0a" class="nz oa it kx b ky oi lb oj le ok li ol lm om lq oe of og oh bi translated"><code class="fe mp mq mr ms b">NaN</code>意味着一个数学运算无效</li><li id="e387" class="nz oa it kx b ky oi lb oj le ok li ol lm om lq oe of og oh bi translated">在比较值时使用<em class="mt"> threequals </em>运算符(===)来避免类型强制被认为是一种好的做法</li></ul><p id="06f5" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">感谢您的阅读！编码快乐！:)</p></div></div>    
</body>
</html>