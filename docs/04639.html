<html>
<head>
<title>Laravel: Lightning Fast Testing for Subscription Payments With Stripe</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Laravel:用Stripe对订阅付费进行闪电般的快速测试</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/laravel-lightning-fast-testing-for-subscription-payments-with-stripe-167cfb43280a?source=collection_archive---------9-----------------------#2020-07-07">https://levelup.gitconnected.com/laravel-lightning-fast-testing-for-subscription-payments-with-stripe-167cfb43280a?source=collection_archive---------9-----------------------#2020-07-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="485a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">我应该有一个基本的测试套件，可以在没有互联网连接的情况下运行，而且应该非常快。他们两个，同时。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/67278a95e7a63fea5fd06de2b26b0da9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MI5AR2HlLRR7TZgNn72NlQ.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">在<a class="ae ky" href="/s/photos/speed?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae ky" href="https://unsplash.com/@veri_ivanova?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Veri Ivanova </a>拍摄的照片</figcaption></figure><p id="55be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于其易用性，Laravel一直是我所有辅助项目的首选框架，但最近在将<a class="ae ky" href="https://laravel.com/docs/7.x/billing" rel="noopener ugc nofollow" target="_blank">收银员</a>集成到<a class="ae ky" href="https://nana-landing.netlify.app/" rel="noopener ugc nofollow" target="_blank">娜娜</a>时，我发现在使用收银员时没有简单的方法来测试订阅创建流程。文档建议您对Stripe的测试API进行真正的调用:</p><blockquote class="lv lw lx"><p id="c690" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">当测试一个使用Cashier的应用程序时，您可以模拟对Stripe API的实际HTTP请求；但是，这需要您部分地重新实现出纳自己的行为。因此，我们建议允许您的测试触及实际的条带API。</p></blockquote><p id="aa66" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于某些情况来说，这可能是一个好建议，并且肯定会提供一个端到端测试流的好方法，并且它有一些优点:</p><ul class=""><li id="f518" class="mc md it lb b lc ld lf lg li me lm mf lq mg lu mh mi mj mk bi translated">可以端到端地测试流程，以及应用程序中的API契约和端点。</li><li id="04c4" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mh mi mj mk bi translated">由于能够在一个测试用例中测试多个单元，比如身份验证、数据库交互、收银员、支付流程等等，所以测试总体上更有信心。</li></ul><p id="d03a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但它也有自己的问题:</p><ul class=""><li id="7e5b" class="mc md it lb b lc ld lf lg li me lm mf lq mg lu mh mi mj mk bi translated">在条带测试仪表板中需要有测试数据设置，这使得在新项目中复制变得棘手。</li><li id="1f84" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mh mi mj mk bi translated">添加到条带的测试数据必须保持最新，并且必须根据需要随测试一起单独更新。</li><li id="623f" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mh mi mj mk bi translated">如果测试数据不一定要在Stripe仪表板上，测试将需要构建测试数据，并在每次测试后进行清理，这意味着即使对于简单的测试来说，也有相当多的样板代码。</li><li id="0ce1" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mh mi mj mk bi translated">根据Stripe文档，如果您有许多测试，在测试模式<a class="ae ky" href="https://stripe.com/docs/rate-limits" rel="noopener ugc nofollow" target="_blank">下每秒25个请求，您可以达到Stripe APIs速率限制。</a></li><li id="c9b1" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mh mi mj mk bi translated">测试将会变得更慢，使你的整体反馈循环更慢。</li></ul><p id="a4c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然这些缺点中的一些可以通过一些巧妙的技巧来解决，但它仍然不是最好的方法。对于我的用例来说，我更愿意采用这样的流程，即只需要设置一次条带测试数据，并使测试依赖于它们；然而，Nana应该是Laravel的一个非常简单的入门套件，因此让用户在Stripe dashboard上一个接一个地进行设置不是一个选项。另一个选择是包含一个一次性脚本来在Stripe上进行设置，但这也不是最理想的，因为该文件一旦执行就会变成死代码，我不想让用户感到困惑。我必须找到一个替代方案。</p><h1 id="15f0" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">输入预言</h1><p id="3ee5" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">对于那些不知道<a class="ae ky" href="https://github.com/phpspec/prophecy" rel="noopener ugc nofollow" target="_blank">预言</a>的人来说，这是一个非常简单的嘲笑PHP的库。预言允许您轻松地为模拟对象定义行为和返回值:</p><pre class="kj kk kl km gt nn no np nq aw nr bi"><span id="7256" class="ns mr it no b gy nt nu l nv nw">// Create your mock<br/>$mockUser = $this-&gt;prophesize(\App\User::class);</span><span id="c92d" class="ns mr it no b gy nx nu l nv nw">// Define the behavior and return value<br/>$mockUser-&gt;doSomething()<br/>    -&gt;shouldBeCalled()<br/>    -&gt;willReturn('something done');</span></pre><p id="288c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">预言与我将在本文后面展示的技巧并不十分相关，它只是为下面的例子奠定了基础。实际上，任何模拟库都应该可以工作。</p><h1 id="c4b9" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">处理订阅创建</h1><p id="3004" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">假设您有一个简单的定价结构，用户选择了其中一个选项并结帐。此时，您必须用给定的信息为用户创建一个订阅。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">一个假想的控制器来演示测试。</figcaption></figure><p id="8aaa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们只是从请求中接收了与支付相关的信息，附加了优惠券(如果存在的话)，并创建了订阅。为了简单起见，这里没有显示请求的验证，<strong class="lb iu">请不要在生产中使用这个控制器。</strong>我们不打算处理接口，因为这一点无关紧要。</p><h1 id="fabe" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">测试控制器</h1><p id="0e54" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">现在你已经准备好了你的控制器，我们要测试它。一种简单的方法是构建一个常规的功能测试，让用户调用端点，并观察在Stripe上创建的订阅，但正如我们之前提到的，我们不想进行互联网调用，因为我们希望我们的测试简单而快速，而不仅仅是简单或快速。</p><p id="ed8d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面是我们控制器的测试函数:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">假设终点的示例测试。</figcaption></figure><p id="6da5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如您所看到的，测试从定义公共请求变量开始，然后继续定义订阅模拟的行为。<code class="fe oa ob oc no b">SubscriptionBuilder</code>类是我们控制器类中<code class="fe oa ob oc no b">$user-&gt;subscription()</code>的返回值；所以，我们首先需要做好准备。</p><ul class=""><li id="d2a0" class="mc md it lb b lc ld lf lg li me lm mf lq mg lu mh mi mj mk bi translated">控制器应该附加优惠券，所以定义<code class="fe oa ob oc no b">withCoupon</code>方法行为。</li><li id="ca85" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mh mi mj mk bi translated">控制器应该尝试创建订阅，所以用参数<code class="fe oa ob oc no b">$paymentMethodId</code>定义<code class="fe oa ob oc no b">create</code>方法。</li></ul><p id="4a0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦我们准备好了subscription builder，我们需要将它附加到我们的用户对象:</p><ul class=""><li id="c3f5" class="mc md it lb b lc ld lf lg li me lm mf lq mg lu mh mi mj mk bi translated">当用这些字符串参数调用<code class="fe oa ob oc no b">$user</code>对象的<code class="fe oa ob oc no b">newSubscription()</code>方法时，mock将返回我们刚刚准备好的订阅构建器。</li></ul><p id="9e88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">至此，我们完成了模拟，可以执行实际的请求了。它只是对订阅创建端点的一个<code class="fe oa ob oc no b">POST</code>请求，它包括我们在函数开始时定义的请求参数。</p><p id="8dd6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里的技巧是在执行<code class="fe oa ob oc no b">POST</code>请求之前调用方法<code class="fe oa ob oc no b">actingAs</code>。该值将自动与控制器使用的<code class="fe oa ob oc no b">$request-&gt;user()</code>方法相关联，并允许我们完全按照自己的意愿定义用户的行为，而无需在数据库上设置任何东西，无需工厂，也绝对无需互联网调用。</p><p id="c16b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就是这样。现在，您可以使用这种方法来模拟您的收银员依赖性，而无需进行任何外部调用，并确保您的测试保持超快的速度。</p><h1 id="40f9" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">我为什么要用这种方法？</h1><p id="e4af" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">就像任何其他技术决策一样，这种方法也有其优点和缺点。</p><h2 id="5acc" class="ns mr it bd ms od oe dn mw of og dp na li oh oi nc lm oj ok ne lq ol om ng on bi translated">不足之处</h2><p id="97ed" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">这种方法的缺点是:</p><ul class=""><li id="8528" class="mc md it lb b lc ld lf lg li me lm mf lq mg lu mh mi mj mk bi translated">它需要模仿一些应用程序内部的行为，比如用户对象上的<code class="fe oa ob oc no b">subscription()</code>方法。如果您没有在用户模型上正确设置Cashier，这些测试仍然会通过。</li><li id="f8a4" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mh mi mj mk bi translated">它没有端到端地测试流，这意味着如果您的管道中有其他问题，比如发送无效的令牌或优惠券，这些测试仍然会通过。</li><li id="aad9" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mh mi mj mk bi translated">它要求您正确定义控制器中使用的方法的返回值。</li></ul><h2 id="9642" class="ns mr it bd ms od oe dn mw of og dp na li oh oi nc lm oj ok ne lq ol om ng on bi translated">优势</h2><p id="5331" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">尽管这种方法有一些缺点，但它仍然有很多价值:</p><ul class=""><li id="f611" class="mc md it lb b lc ld lf lg li me lm mf lq mg lu mh mi mj mk bi translated">没有必要测试出纳的内部，就像<a class="ae ky" href="https://laravel.com/docs/7.x/billing#testing" rel="noopener ugc nofollow" target="_blank">出纳文档</a>中建议的那样。</li></ul><blockquote class="lv lw lx"><p id="87ad" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">在测试时，请记住收银台本身已经有了一个很好的测试套件，所以您应该只关注于测试您自己的应用程序的订阅和支付流程，而不是每一个底层的收银台行为。</p></blockquote><ul class=""><li id="309c" class="mc md it lb b lc ld lf lg li me lm mf lq mg lu mh mi mj mk bi translated">测试仍然覆盖控制器的外围设备，比如路由和请求变量传递，这比仅仅构建一个控制器实例并直接调用其<code class="fe oa ob oc no b">save</code>方法要好。</li><li id="767e" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mh mi mj mk bi translated">它不需要任何互联网或数据库连接，而且<strong class="lb iu">超级快。</strong></li><li id="581d" class="mc md it lb b lc ml lf mm li mn lm mo lq mp lu mh mi mj mk bi translated">由于它不依赖于Stripe的API，因此不存在速率限制或网络调用失败的风险。</li></ul><h1 id="3a3b" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">结论</h1><p id="c4c0" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">总的来说，这种方法似乎满足了我的需求。它涵盖了足够多的应用程序，并为这样一项小小的工作提供了足够的价值。接下来，让测试也调用Stripe API将是有益的，这可能被分组并仅在主构建上或仅在需要时执行，这两种方法可以很容易地一起工作，并且还允许您在出现bug时隔离您的问题。对于Nana来说，这种方法肯定允许我用测试覆盖所有与支付/订阅相关的端点，这样用户就可以在这些特性的基础上进行构建，而无需关心在Stripe上设置任何东西。</p></div><div class="ab cl oo op hx oq" role="separator"><span class="or bw bk os ot ou"/><span class="or bw bk os ot ou"/><span class="or bw bk os ot"/></div><div class="im in io ip iq"><p id="ca0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然你已经设法读到这里，这里有一张可爱鹦鹉的照片作为感谢:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ov"><img src="../Images/b05e88d9af5de68a78e91f60c23be9af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e9kiKOT9pbhv2VNJK0MUyw.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">凯文·穆勒在<a class="ae ky" href="/s/photos/animal?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure></div></div>    
</body>
</html>