<html>
<head>
<title>Learning C++: Nonmutating Algorithms of the STL Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习c++:STL的不变算法第1部分</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/learning-c-nonmutating-algorithms-of-the-stl-part-1-7b306b4ac790?source=collection_archive---------18-----------------------#2020-04-21">https://levelup.gitconnected.com/learning-c-nonmutating-algorithms-of-the-stl-part-1-7b306b4ac790?source=collection_archive---------18-----------------------#2020-04-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/eb4eb70139b63fb6625857aa5fa76ae8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*iZrJXqWwA0z_2GnI"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">维多利亚诺·伊斯基耶多在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="974d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是关于标准模板库(STL)中的算法的系列文章的第一篇。这第一篇文章将研究非变动算法的一个子集——在不改变元素的情况下对容器元素执行任务的算法。第一组中的功能包括<code class="fe le lf lg lh b">for_each</code>、<code class="fe le lf lg lh b">count</code>、<code class="fe le lf lg lh b">count_if</code>、<code class="fe le lf lg lh b">min_element</code>、<code class="fe le lf lg lh b">max_element</code>和<code class="fe le lf lg lh b">minmax_element</code>。</p><h1 id="f9b4" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">for_each函数</h1><p id="4514" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated"><code class="fe le lf lg lh b">for_each</code>函数用于访问容器中的一系列元素，以便为每个元素执行一些任务。该函数的一个经典例子是打印容器中的每个元素。该函数的语法模板如下所示:</p><p id="5430" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="ml"> for_each(range-start，range-end，func)；</em></p><p id="3cb9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个使用<code class="fe le lf lg lh b">for_each</code>函数打印一个向量的每个元素的例子:</p><pre class="mm mn mo mp gt mq lh mr ms aw mt bi"><span id="285c" class="mu lj it lh b gy mv mw l mx my">#include &lt;iostream&gt;<br/>#include &lt;vector&gt;<br/>#include &lt;algorithm&gt;<br/>#include &lt;cstdlib&gt;<br/>#include &lt;ctime&gt;<br/>using namespace std;</span><span id="ad25" class="mu lj it lh b gy mz mw l mx my">void buildVec(vector&lt;int&gt; &amp;vec, int n) {<br/>  srand(time(0));  <br/>  for (int i = 1; i &lt;= n; i++) {<br/>    vec.push_back(rand() % 1000 + 1);<br/>  }<br/>}</span><span id="f330" class="mu lj it lh b gy mz mw l mx my">void printElement(int n) {<br/>  cout &lt;&lt; n &lt;&lt; " ";<br/>}</span><span id="b6b4" class="mu lj it lh b gy mz mw l mx my">int main()<br/>{<br/>  vector&lt;int&gt; numbers;<br/>  buildVec(numbers, 20);<br/>  for_each(numbers.begin(), numbers.end(), printElement);<br/>  return 0;<br/>}</span></pre><p id="cf64" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个程序运行一次的输出是:</p><pre class="mm mn mo mp gt mq lh mr ms aw mt bi"><span id="9d93" class="mu lj it lh b gy mv mw l mx my">928 722 270 403 832 495 100 728 993 75 442 376 482 169 368 563 978 610 432 374</span></pre><p id="d64b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为此目的使用<code class="fe le lf lg lh b">for_each</code>函数在某种程度上被range <code class="fe le lf lg lh b">for</code>循环劫持了，尤其是当您想要访问容器中的每个元素时:</p><pre class="mm mn mo mp gt mq lh mr ms aw mt bi"><span id="64eb" class="mu lj it lh b gy mv mw l mx my">int main()<br/>{<br/>  vector&lt;int&gt; numbers;<br/>  buildVec(numbers, 20);<br/>  for (const int number : numbers) {<br/>    cout &lt;&lt; number &lt;&lt; " ";<br/>  }<br/>  return 0;<br/>}</span></pre><p id="fbb6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">range <code class="fe le lf lg lh b">for</code>循环在场景下使用迭代器，就像<code class="fe le lf lg lh b">for_each</code>函数使用迭代器一样。</p><p id="6fcf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个显示来自<code class="fe le lf lg lh b">map</code>元素容器的键和值的<code class="fe le lf lg lh b">for_each</code>示例:</p><pre class="mm mn mo mp gt mq lh mr ms aw mt bi"><span id="d1a4" class="mu lj it lh b gy mv mw l mx my">void printNumber(pair&lt;string, string&gt; pr) {<br/>  cout &lt;&lt; "Name: " &lt;&lt; pr.first &lt;&lt; ", number: "<br/>       &lt;&lt; pr.second &lt;&lt; endl;<br/>}</span><span id="1c56" class="mu lj it lh b gy mz mw l mx my">int main()<br/>{<br/>  map&lt;string, string&gt; phoneList = {{"Jones", "2300"},<br/>                                   {"Smith", "2301"},<br/>                                   {"Brown", "2302"},<br/>                                   {"Green", "2303"}};<br/>  for_each(phoneList.begin(), phoneList.end(), printNumber);<br/>  return 0;<br/>}</span></pre><p id="479e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个程序的输出是:</p><pre class="mm mn mo mp gt mq lh mr ms aw mt bi"><span id="d1ee" class="mu lj it lh b gy mv mw l mx my">Name: Brown, number: 2302<br/>Name: Green, number: 2303<br/>Name: Jones, number: 2300<br/>Name: Smith, number: 2301</span></pre><p id="878c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为<code class="fe le lf lg lh b">for_each</code>函数的许多用法都被使用范围<code class="fe le lf lg lh b">for</code>循环所取代，所以当我在以后的文章中讨论变异算法时，我将演示<code class="fe le lf lg lh b">for_each</code>的一些变异用法。</p><h1 id="d705" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">count和count_if函数</h1><p id="9a68" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">这两个函数计算在容器中找到的指定值的数量。以下是count函数的语法模板:</p><p id="ddd5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="ml">计数(范围-开始，范围-结束，值)；</em></p><p id="5657" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该函数返回<em class="ml">值</em>在容器中出现的次数。下面是一个使用向量的示例:</p><pre class="mm mn mo mp gt mq lh mr ms aw mt bi"><span id="e728" class="mu lj it lh b gy mv mw l mx my">int main()<br/>{<br/>  vector&lt;int&gt; numbers;<br/>  buildVec(numbers, 100);<br/>  for (const int number : numbers) {<br/>    cout &lt;&lt; number &lt;&lt; " ";<br/>  }<br/>  const int VALUE = 100;<br/>  cout &lt;&lt; endl &lt;&lt; endl;<br/>  int hundreds = count(numbers.begin(), numbers.end(), VALUE);<br/>  cout &lt;&lt; "Number of 100 elements: " &lt;&lt; hundreds &lt;&lt; endl;<br/>  return 0;<br/>}</span></pre><p id="3c35" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个程序运行一次的输出是:</p><pre class="mm mn mo mp gt mq lh mr ms aw mt bi"><span id="f6e1" class="mu lj it lh b gy mv mw l mx my">4 93 27 2 72 87 84 9 33 68 9 67 89 10 47 5 4 75 68 11 47 1 44 64 59 44 55 87 59 99 97 76 62 42 6 63 33 38 15 29 48 77 20 4 66 100 48 66 82 67 14 61 87 80 25 69 71 90 62 1 84 18 36 11 15 51 40 87 94 31 3 34 11 62 25 74 65 38 42 48 23 91 26 13 6 44 33 51 48 34 82 100 30 93 5 39 78 68 13 9</span><span id="2851" class="mu lj it lh b gy mz mw l mx my">Number of 100 elements: 2</span></pre><p id="e707" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">函数对容器中符合给定标准的元素进行计数。这个标准可以是一个函数对象或一个lambda。下面是<code class="fe le lf lg lh b">count_if</code>的语法模板:</p><p id="6216" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="ml"> count_if(range-start，range-stop，func)；</em></p><p id="b077" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下示例计算值大于50的元素的数量并显示结果:</p><pre class="mm mn mo mp gt mq lh mr ms aw mt bi"><span id="0930" class="mu lj it lh b gy mv mw l mx my">bool aboveFifty(int element) {<br/>  return element &gt; 50;<br/>}</span><span id="0201" class="mu lj it lh b gy mz mw l mx my">int main()<br/>{<br/>  vector&lt;int&gt; numbers;<br/>  buildVec(numbers, 100);<br/>  for (const int number : numbers) {<br/>    cout &lt;&lt; number &lt;&lt; " ";<br/>  }<br/>  const int VALUE = 100;<br/>  cout &lt;&lt; endl &lt;&lt; endl;<br/>  int aboveFiftyN = count_if(numbers.begin(), numbers.end(),<br/>                             aboveFifty);<br/>  cout &lt;&lt; "Number of elements above fifty: " &lt;&lt; aboveFiftyN<br/>       &lt;&lt; endl;<br/>  return 0;<br/>}</span></pre><p id="036f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里是另一个使用lambda函数的<code class="fe le lf lg lh b">count_if</code>的例子:</p><pre class="mm mn mo mp gt mq lh mr ms aw mt bi"><span id="71ae" class="mu lj it lh b gy mv mw l mx my">int main()<br/>{<br/>  vector&lt;int&gt; numbers;<br/>  buildVec(numbers, 100);<br/>  int numOdds = count_if(numbers.begin(), numbers.end(),<br/>                  [](int number) { return number % 2 != 0;});<br/>  cout &lt;&lt; "Number of odd elements: " &lt;&lt; numOdds &lt;&lt; endl;<br/>  return 0;<br/>}</span></pre><h1 id="7a87" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">查找容器中的最小值和最大值</h1><p id="e1b8" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">接下来的两个函数用于查找容器中的最小和最大元素。第一个函数<code class="fe le lf lg lh b">min_element</code>查找容器的最小值。以下是该函数的语法模板:</p><p id="8497" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="ml"> min_element(范围-开始，范围-结束)；</em></p><p id="b6ec" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该函数返回迭代器，而不是值，如下例所示:</p><pre class="mm mn mo mp gt mq lh mr ms aw mt bi"><span id="24c9" class="mu lj it lh b gy mv mw l mx my">int main()<br/>{<br/>  vector&lt;int&gt; numbers;<br/>  buildVec(numbers, 100);<br/>  for (const int number : numbers) {<br/>    cout &lt;&lt; number &lt;&lt; " ";<br/>  }<br/>  cout &lt;&lt; endl &lt;&lt; endl;<br/>  auto minValue = min_element(numbers.begin(), numbers.end());<br/>  cout &lt;&lt; "The minimum value is: " &lt;&lt; *minValue &lt;&lt; endl;<br/>  return 0;<br/>}</span></pre><p id="50f2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">max_element</code>函数查找容器中的最大值。下面是语法模板:</p><p id="1c0b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="ml"> max_element(range-start，range-end)；</em></p><p id="4b63" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个函数也返回一个迭代器，如下所示:</p><pre class="mm mn mo mp gt mq lh mr ms aw mt bi"><span id="5c69" class="mu lj it lh b gy mv mw l mx my">int main()<br/>{<br/>  vector&lt;int&gt; numbers;<br/>  buildVec(numbers, 100);<br/>  for (const int number : numbers) {<br/>    cout &lt;&lt; number &lt;&lt; " ";<br/>  }<br/>  cout &lt;&lt; endl &lt;&lt; endl;<br/>  auto maxValue = max_element(numbers.begin(), numbers.end());<br/>  cout &lt;&lt; "The minimum value is: " &lt;&lt; *maxValue &lt;&lt; endl;<br/>  return 0;<br/>}</span></pre><p id="7807" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该组中的第三个功能是<code class="fe le lf lg lh b">minmax_element</code>功能。该函数返回一个由<code class="fe le lf lg lh b">first</code>字段容器中的最小值和<code class="fe le lf lg lh b">second</code>字段容器中的最大值组成的<code class="fe le lf lg lh b">pair</code>。</p><p id="9afb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">minmax_element</code>函数的语法模板是:</p><p id="0845" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="ml"> minmax_element(range-start，range-end)；</em></p><p id="40ed" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个使用<code class="fe le lf lg lh b">minmax_element</code>函数的例子:</p><pre class="mm mn mo mp gt mq lh mr ms aw mt bi"><span id="669d" class="mu lj it lh b gy mv mw l mx my">int main()<br/>{<br/>  vector&lt;int&gt; numbers;<br/>  buildVec(numbers, 100);<br/>  for (const int number : numbers) {<br/>    cout &lt;&lt; number &lt;&lt; " ";<br/>  }<br/>  cout &lt;&lt; endl &lt;&lt; endl;<br/>  auto minMax = minmax_element(numbers.begin(), numbers.end());<br/>  cout &lt;&lt; "The minimum element is: " &lt;&lt; *(minMax.first) &lt;&lt; endl;<br/>  cout &lt;&lt; "The maximum element is: " &lt;&lt; *(minMax.second)<br/>       &lt;&lt; endl;<br/>  return 0;<br/>}</span></pre><p id="d2b2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个程序运行一次的输出是:</p><pre class="mm mn mo mp gt mq lh mr ms aw mt bi"><span id="1a17" class="mu lj it lh b gy mv mw l mx my">870 960 895 146 899 868 269 174 439 403 886 287 131 652 526 39 830 798 88 770 303 435 814 297 689 108 69 589 678 758 816 503 143 259 755 392 811 467 91 756 94 709 653 341 811 289 893 797 542 32 168 140 259 190 683 971 459 982 181 319 424 302 610 58 758 197 562 151 909 323 449 357 980 992 936 126 457 783 37 8 382 252 86 59 622 948 404 964 192 652 517 369 538 741 170 278 891 742 746 928</span><span id="7322" class="mu lj it lh b gy mz mw l mx my">The minimum element is: 8<br/>The maximum element is: 992</span></pre><p id="f3aa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">特别注意检索<code class="fe le lf lg lh b">pair</code>字段的方式。因为该函数返回一个迭代器，所以必须通过将对字段的调用放在括号中，然后应用解引用操作符来检索字段。不将字段调用放在括号中会导致编译器只对<code class="fe le lf lg lh b">pair</code>名称应用解引用操作符，这是一个语法错误。</p><h1 id="046a" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">作为成员函数的算法</h1><p id="7643" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">大多数STL算法，无论是在本文中还是在我将在以后的文章中介绍的函数中，并不总是适用于每种容器类型。有时算法作为成员函数嵌入在容器中。</p><p id="dc10" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以<code class="fe le lf lg lh b">count</code>功能为例。如果您试图将这个函数应用于一个<code class="fe le lf lg lh b">multimap</code>，比如计算multimap中的键的数量，您将会得到一个语法错误。然而，在<code class="fe le lf lg lh b">multimap</code>类中有一个<code class="fe le lf lg lh b">count</code>成员函数允许这样做。这里有一个例子:</p><pre class="mm mn mo mp gt mq lh mr ms aw mt bi"><span id="1db9" class="mu lj it lh b gy mv mw l mx my">#include &lt;iostream&gt;<br/>#include &lt;map&gt;<br/>#include &lt;algorithm&gt;<br/>using namespace std;</span><span id="5bcd" class="mu lj it lh b gy mz mw l mx my">int main()<br/>{<br/>  multimap&lt;string, string&gt; words;<br/>  words.insert({"nail", "a finger or toe covering"});<br/>  words.insert({"nail", "a sharp metallic object"});<br/>  words.insert({"bark", "the noise made by a dog"});<br/>  words.insert({"bark", "the covering of a tree"});<br/>  int wordCount = words.count("bark");<br/>  cout &lt;&lt; "Number of bark keys: " &lt;&lt; wordCount &lt;&lt; endl;<br/>  return 0;<br/>}</span></pre><p id="e305" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个故事的寓意是，如果你试图将一个算法应用到一个容器中，但它不起作用，那么在你试图编写自己的算法之前，你应该检查一下是否在容器的成员函数中找到了一个算法。更好的是，首先检查成员函数，因为它们通常比一般算法更有效。</p><h1 id="8961" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">本文中的函数摘要</h1><p id="b2a7" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">我在本文中讨论的非变动算法要么用于访问容器的元素(<code class="fe le lf lg lh b">for_each</code>函数)，要么用于返回关于容器的一些信息(计数函数和最小值/最大值函数)。在我的下一篇文章中，我将介绍一些用于搜索容器或在容器中查找特定值的非可变算法。</p><p id="822e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢您阅读这篇文章，请给我发电子邮件，提出您的意见和建议。</p></div></div>    
</body>
</html>