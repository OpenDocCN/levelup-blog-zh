<html>
<head>
<title>Introduction to TypeScript Generics with Classes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带类的类型脚本泛型简介</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/introduction-to-typescript-generics-classes-54c30244ae99?source=collection_archive---------2-----------------------#2020-01-16">https://levelup.gitconnected.com/introduction-to-typescript-generics-classes-54c30244ae99?source=collection_archive---------2-----------------------#2020-01-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/fd840d4f57f459d5f24f526f7c9ace5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ADIJsNtY4OpcEg0A"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@joyceromero?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">乔伊斯·罗梅罗</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="2e6d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">创建可重用代码的一种方法是创建这样的代码，它允许我们根据自己的需要使用不同的数据类型。TypeScript提供了创建可重用组件的泛型构造，我们可以用一段代码处理各种类型。这允许开发者通过放入他们自己的类型来使用这些组件。在本文中，我们将研究定义泛型类的许多方法，并通过定义接口和<code class="fe le lf lg lh b">extends</code>关键字来验证属性，并通过使用<code class="fe le lf lg lh b">keyof</code>关键字来强制代码只接受对象中的属性名。</p><h1 id="2863" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">定义泛型类</h1><p id="49d2" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">为了在TypeScript中定义泛型类，我们将泛型类型标记放在类名后面的<code class="fe le lf lg lh b">&lt;&gt;</code>之间。我们可以用逗号分隔多个类型标记。此外，我们可以使用相同的类型标记来标记函数的类型，以便在我们的类中更改参数和返回方法的类型。例如，我们可以编写以下代码来定义具有单个泛型类型标记的泛型类:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="181f" class="mt lj it lh b gy mu mv l mw mx">class GenericPerson&lt;T&gt; {  <br/>  name: T;<br/>  getName: (name: T) =&gt; T;<br/>}</span><span id="0619" class="mt lj it lh b gy my mv l mw mx">let person = new GenericPerson&lt;string&gt;();<br/>person.name = 'Jane';<br/>person.getName = function(x) { return x; };</span></pre><p id="9012" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们在<code class="fe le lf lg lh b">&lt;&gt;</code>中传递了字符串类型。我们也可以改变成我们想要的任何其他类型，比如<code class="fe le lf lg lh b">number</code>、<code class="fe le lf lg lh b">boolean</code>，或者任何类似下面代码的接口:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="d9ec" class="mt lj it lh b gy mu mv l mw mx">class GenericPerson&lt;T&gt; {  <br/>  name: T;<br/>  getName: (name: T) =&gt; T;<br/>}</span><span id="825b" class="mt lj it lh b gy my mv l mw mx">let person = new GenericPerson&lt;number&gt;();<br/>person.name = 2;<br/>person.getName = function(x) { return x; };</span></pre><p id="b878" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还可以在同一个类中插入多种类型，如下面的代码所示:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="c7b4" class="mt lj it lh b gy mu mv l mw mx">class GenericPerson&lt;T, U&gt; {  <br/>  name: T;<br/>  getName: (name: U) =&gt; U;<br/>}</span><span id="2726" class="mt lj it lh b gy my mv l mw mx">let person = new GenericPerson&lt;string, number&gt;();<br/>person.name = 'Jane';<br/>person.getName = function (x) { return x; };<br/>person.getName(2);</span></pre><p id="8501" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，<code class="fe le lf lg lh b">T</code>和<code class="fe le lf lg lh b">U</code>可能是也可能不是不同的类型。只要我们将它们都放入，并且我们传入并分配具有我们在类定义中指定的类型的数据，那么TypeScript编译器将接受它。上面的例子只在有限的情况下有用，因为我们不能在类定义中引用任何属性，因为TypeScript编译器不知道<code class="fe le lf lg lh b">T</code>或<code class="fe le lf lg lh b">U</code>包含什么属性。</p><p id="ae49" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了让TypeScript编译器知道可能在我们的类定义中使用的属性，我们可以使用一个接口来列出所有可以与该类一起使用的属性，并在泛型类型标记之后使用<code class="fe le lf lg lh b">extends</code>关键字来表示该类型可能具有在接口中列出的属性列表。例如，如果我们希望在类方法中有不同的复杂类型，我们可以编写类似下面的代码:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="a807" class="mt lj it lh b gy mu mv l mw mx">interface PersonInterface {<br/>  name: string;<br/>  age: number;<br/>}</span><span id="99c2" class="mt lj it lh b gy my mv l mw mx">interface GreetingInterface {<br/>  toString(): string;<br/>}</span><span id="9ade" class="mt lj it lh b gy my mv l mw mx">class GenericPerson&lt;T extends PersonInterface, U extends GreetingInterface&gt; {  <br/>  person: T;<br/>  greet(greeting: U): string {<br/>    return `${greeting.toString()} ${this.person.name}. You're ${this.person.age} years old`;<br/>  }<br/>}</span><span id="c88e" class="mt lj it lh b gy my mv l mw mx">let jane = new GenericPerson();<br/>jane.person = {<br/>  name: 'Jane',<br/>  age: 20<br/>};<br/>console.log(jane.greet('Hi'));</span></pre><p id="520f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们定义了两个接口,<code class="fe le lf lg lh b">PersonInterface</code>和<code class="fe le lf lg lh b">GreetingInterface</code>,分别表示可以被<code class="fe le lf lg lh b">T</code>和<code class="fe le lf lg lh b">U</code>引用的属性。在<code class="fe le lf lg lh b">PersonInterface</code>中，我们列出了<code class="fe le lf lg lh b">name</code>和<code class="fe le lf lg lh b">age</code>属性，因此我们可以为类型为<code class="fe le lf lg lh b">T</code>的数据引用这些属性。对于类型为<code class="fe le lf lg lh b">U</code>的数据，我们可以对其调用<code class="fe le lf lg lh b">toString</code>方法。因此，在我们的<code class="fe le lf lg lh b">greet</code>方法中，我们可以在<code class="fe le lf lg lh b">greeting</code>上调用<code class="fe le lf lg lh b">toString</code>，因为它具有<code class="fe le lf lg lh b">U</code>类型，并且因为<code class="fe le lf lg lh b">this.person</code>具有<code class="fe le lf lg lh b">T</code>类型，我们可以从中获得<code class="fe le lf lg lh b">name</code>和<code class="fe le lf lg lh b">age</code>属性。</p><p id="5f91" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后在类定义之后，我们可以实例化该类，然后为我们创建的<code class="fe le lf lg lh b">jane</code>对象上的<code class="fe le lf lg lh b">name</code>和<code class="fe le lf lg lh b">age</code>属性设置值。然后，当我们在<code class="fe le lf lg lh b">jane.greet(‘Hi’)</code>上运行<code class="fe le lf lg lh b">console.log</code>时，我们应该会看到‘嗨，简。自从我们设定<code class="fe le lf lg lh b">jane.person</code>的值后，你已经20岁了。</p><p id="df5c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们也可以在实例化对象时显式地放入类型，以使类型更加清晰。我们可以稍微改变一下上面的内容，编写下面的代码:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="fe21" class="mt lj it lh b gy mu mv l mw mx">interface PersonInterface {<br/>  name: string;<br/>  age: number;<br/>}</span><span id="bfc5" class="mt lj it lh b gy my mv l mw mx">interface GreetingInterface {<br/>  toString(): string;<br/>}</span><span id="8229" class="mt lj it lh b gy my mv l mw mx">class GenericPerson&lt;T extends PersonInterface, U extends GreetingInterface&gt; {  <br/>  person: T;<br/>  greet(greeting: U): string {<br/>    return `${greeting.toString()} ${this.person.name}. You're ${this.person.age} years old`;<br/>  }<br/>}</span><span id="f490" class="mt lj it lh b gy my mv l mw mx">let jane = new GenericPerson&lt;PersonInterface, string&gt;();<br/>jane.person = {<br/>  name: 'Jane',<br/>  age: 20<br/>};<br/>console.log(jane.greet('Hi'));</span></pre><p id="c682" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">唯一的区别是我们在<code class="fe le lf lg lh b">new GenericPerson</code>后面加上了<code class="fe le lf lg lh b">&lt;PersonInterface, string&gt;</code>。注意，我们可以在括号之间添加接口或基本类型。TypeScript只关心类型是否具有我们定义的接口中列出的方法。既然这些类型受到这些泛型类型的约束，我们就不必担心引用任何意外的属性。例如，如果我们在下面的代码中引用了不存在的东西:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="8a6c" class="mt lj it lh b gy mu mv l mw mx">interface PersonInterface {<br/>  name: string;<br/>  age: number;<br/>}</span><span id="8f34" class="mt lj it lh b gy my mv l mw mx">interface GreetingInterface {<br/>  toString(): string;<br/>}</span><span id="46d6" class="mt lj it lh b gy my mv l mw mx">class GenericPerson&lt;T extends PersonInterface, U extends GreetingInterface&gt; {  <br/>  person: T;<br/>  greet(greeting: U): string {<br/>    return `${greeting.foo()} ${this.person.name}. You're ${this.person.age} years old`;<br/>  }<br/>}</span><span id="93de" class="mt lj it lh b gy my mv l mw mx">let jane = new GenericPerson&lt;PersonInterface, string&gt;();<br/>jane.person = {<br/>  name: 'Jane',<br/>  age: 20<br/>};<br/>console.log(jane.greet('Hi'));</span></pre><p id="6268" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们会得到“属性‘foo’在类型‘U’上不存在。(2339)“既然我们的<code class="fe le lf lg lh b">GreetingInterface</code>里没有列出<code class="fe le lf lg lh b">foo</code>。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/c6c1e69943830bc681a0840a4e854475.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lq8dhlprGOiXNDIb"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@sarandywestfall_photo?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> sarandy westfall </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="157f" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">约束对象属性的检索</h1><p id="9a0d" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">TypeScript还提供了一种方法，让我们可以用泛型安全地获取对象的属性。我们可以使用<code class="fe le lf lg lh b">keyof</code>关键字来约束一个对象可以接受的另一个对象的键名的值。例如，我们可以在下面的代码中使用<code class="fe le lf lg lh b">keyof</code>关键字:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="5382" class="mt lj it lh b gy mu mv l mw mx">function getProperty&lt;T, K extends keyof T&gt;(obj: T, key: K) {<br/>  return obj[key];<br/>}</span><span id="f2d6" class="mt lj it lh b gy my mv l mw mx">let x = { foo: 1, bar: 2, baz: 3 };</span><span id="5772" class="mt lj it lh b gy my mv l mw mx">console.log(getProperty(x, "foo"));</span></pre><p id="4f63" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们约束通用标记<code class="fe le lf lg lh b">K</code>只接受传递给<code class="fe le lf lg lh b">obj</code>的任何对象的键作为<code class="fe le lf lg lh b">key</code>的有效值，因为<code class="fe le lf lg lh b">K</code>在<code class="fe le lf lg lh b">K</code>之后有<code class="fe le lf lg lh b">extends keyof T</code>标记。这意味着无论<code class="fe le lf lg lh b">T</code>类型有什么键，这些键都是<code class="fe le lf lg lh b">K</code>的有效值。有了上面这样的代码，我们不必担心获取不存在的属性值。因此，如果我们传入一个在<code class="fe le lf lg lh b">obj</code>中不存在的键名，如下面的代码所示:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="22fd" class="mt lj it lh b gy mu mv l mw mx">getProperty(x, "a");</span></pre><p id="077d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">则TypeScript编译器将拒绝该代码，并给出错误消息“a类型的参数不可赋给foo类型的参数”| "bar" | "baz "”。(2345)".这意味着只有<code class="fe le lf lg lh b">'foo'</code>、<code class="fe le lf lg lh b">'bar'</code>和<code class="fe le lf lg lh b">'baz'</code>是<code class="fe le lf lg lh b">key</code>的有效值，因为它具有类型<code class="fe le lf lg lh b">K</code>，类型<code class="fe le lf lg lh b">K</code>后面有一个<code class="fe le lf lg lh b">extends keyof T</code>标记，用于将有效用法约束为<code class="fe le lf lg lh b">obj</code>的键名。</p><p id="067d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以用TypeScript轻松定义一个泛型类。为了在TypeScript中定义泛型类，我们将泛型类型标记放在类名后面的<code class="fe le lf lg lh b">&lt;&gt;</code>之间。我们可以用逗号分隔多个类型标记。此外，我们可以使用相同的类型标记来标记函数的类型，以便在我们的类中更改参数和返回方法的类型。此外，我们可以使用<code class="fe le lf lg lh b">extends</code>关键字来定义属性，这些属性可以被泛型类型标记的数据引用。我们可以使用<code class="fe le lf lg lh b">keyof</code>关键字来约束一个对象可以接受的另一个对象的键名的值。</p></div></div>    
</body>
</html>