<html>
<head>
<title>Python: Optimized sort over pre-sorted fake satellite telemetry data.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python:对预先分类的假卫星遥测数据进行优化分类。</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/python-optimized-sort-over-pre-sorted-fake-satellite-telemetry-data-9259b193d39e?source=collection_archive---------10-----------------------#2022-07-14">https://levelup.gitconnected.com/python-optimized-sort-over-pre-sorted-fake-satellite-telemetry-data-9259b193d39e?source=collection_archive---------10-----------------------#2022-07-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="77ff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们学习一点Python，并在高效解决现实世界问题的同时这样做。</p><p id="3733" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">作为一名数据专业人员，我们将了解一些算法解决问题的知识如何在工作中派上用场。害怕不是因为我要一步一步地走完这个过程。每一行代码都会有解释。</p><p id="4635" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以在这里看到带有示例数据的完整代码:<a class="ae kl" href="https://github.com/bfemiano/misc_scripts/tree/main/python/sorted_sat_data_reader" rel="noopener ugc nofollow" target="_blank">https://github . com/bfemiano/misc _ scripts/tree/main/python/sorted _ sat _ data _ reader</a></p><p id="ec52" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们从一个假设的真实场景的问题描述开始。</p><p id="4211" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设我们舰队中的几颗不同的卫星都已经将它们每天从机载仪器上获得的深空遥测读数传回了你的笔记本电脑。</p><p id="b8ac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当读数通过线路传来时，每个记录被及时写入卫星id (sid)的平面DAT文件。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/e8330de5b9ac73d33054c787d8322e00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*odON8PAwri4GsGOo3qBaMQ.png"/></div></div></figure><p id="a74d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从头到尾阅读每颗卫星的DAT文件将显示记录，因为它们是按时间排序顺序收集的。</p><p id="bbb1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">样本:<code class="fe ky kz la lb b">sid_1_2022_06_01.dat</code></p><pre class="kn ko kp kq gt lc lb ld le aw lf bi"><span id="0656" class="lg lh iq lb b gy li lj l lk ll">sid   |  galactic lat | galactic lon | reading | timestamp</span><span id="d848" class="lg lh iq lb b gy lm lj l lk ll">1     | 121.17424181 | -21.57288557  | &lt;bin&gt;   | 2022-06-01T12-00-00<br/>1     | 121.17424181 | -21.57287732  | &lt;bin&gt;   | 2022-06-01T13-12-01</span></pre><p id="0609" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们开始我们的挑战。</p><p id="9721" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设我们有几个不同的DAT文件传入每个卫星，为了我们的研究目的<strong class="jp ir">，我们希望有一个单一的每日文件，包含所有卫星按时间顺序的所有读数</strong>。</p><p id="81cf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，假设这些文件可能是大文件，那么我们希望避免将它们全部加载到内存中，以便调用python <code class="fe ky kz la lb b">sorted()</code>函数。</p><p id="0b21" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可能会想，我们一定有办法利用每个卫星的DAT文件已经按时间顺序排序的事实。你是对的！</p><p id="f3fe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先让我们定义我们的<code class="fe ky kz la lb b">main</code>函数</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi ln"><img src="../Images/a11c2a69efcbc1a5093a95d52bd8a416.png" data-original-src="https://miro.medium.com/v2/resize:fit:766/format:webp/1*eHlUZquM-YQuLnahXmi4Zw.png"/></div></figure><p id="e0dd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它所做的只是将工作委托给两个函数<code class="fe ky kz la lb b">create_file_reader_map()</code>，然后将得到的读者集合发送到<code class="fe ky kz la lb b">merge_single_file()</code></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi lo"><img src="../Images/6bb3812968db2b72193ef1aa7ad87389.png" data-original-src="https://miro.medium.com/v2/resize:fit:1186/format:webp/1*oq8sxH63euB8OFNz9Foz3g.png"/></div></figure><p id="5310" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe ky kz la lb b">create_file_reader_map</code>创建一个文件句柄生成器的索引字典，我们可以用它从不同的文件读入程序内存。</p><p id="5fd8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe ky kz la lb b">glob</code>模块提供了一种简便的方法来获取。匹配. dat扩展名的/datfiles子目录。然后对于每条发现的路径<code class="fe ky kz la lb b">f</code>，我们称之为<code class="fe ky kz la lb b">_read(f)</code>，它返回的是<code class="fe ky kz la lb b">f</code>的每个封闭值的唯一生成器。<code class="fe ky kz la lb b">yield</code>表示<code class="fe ky kz la lb b">_read()</code>将成为发电机功能。我们可以使用它在每次调用时返回一个值，并冻结文件的迭代，直到我们再次调用生成器。我们马上就会看到如何利用这一点。</p><p id="43d6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们生成的对象类型将是自定义类型，我们定义为<code class="fe ky kz la lb b">SatReading.</code></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi lp"><img src="../Images/6260ff78c08166c5e357cd8a4051cc42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1316/format:webp/1*2dCw2yElF3ED7iWRipQbQg.png"/></div></figure><p id="19bf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">构造函数将只接受一个字符串，它在构造函数参数列表中变成<code class="fe ky kz la lb b">record</code>。</p><p id="5e70" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe ky kz la lb b">: str</code>给编译器一个类型安全提示，在这个位置发送的参数必须是一个字符串。</p><p id="4812" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们做的第一件事是从<code class="fe ky kz la lb b">record</code>中移除换行符，并沿着管道<code class="fe ky kz la lb b">|</code>的边界分割它。Python将允许我们在一行中将数组解包为命名变量。</p><p id="25e3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，构造函数为拆分数组中的每个字段设置<code class="fe ky kz la lb b">self</code>属性。(我们以后可能会出于某种原因使用它们)。</p><p id="117c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还定义了<code class="fe ky kz la lb b">is_lte()</code>，它是<code class="fe ky kz la lb b">is_less_than_or_equal</code>的简写，用于比较其他<code class="fe ky kz la lb b">SatReading</code>实例。这个函数很简单。如果对方时间戳&gt;是自己的时间戳，则返回True。否则返回False。如果由于某种原因传入<code class="fe ky kz la lb b">is_lte</code>的对象不属于<code class="fe ky kz la lb b">SatRecording</code>类型，抛出一个参数错误。我们可以使用<code class="fe ky kz la lb b">-&gt; bool</code>给编译器一个类型提示，该函数将返回一个布尔值。</p><p id="75d9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我们这样做的时候，让我们也定义一下神奇的方法<code class="fe ky kz la lb b">__str__</code>，这样如果我们想把我们的<code class="fe ky kz la lb b">SatRecording</code>实例表示为字符串，我们可以发出信号，只打印最初作为参数传入的<code class="fe ky kz la lb b">self.record</code>字符串。</p><p id="e26b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe ky kz la lb b">self</code>参数告诉编译器这是每个<code class="fe ky kz la lb b">SatRecording</code>对象可用的实例方法。</p><p id="f6e9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">至此，我们已经编写了构建索引生成器字典的代码，每次调用它时，它都会从底层文件句柄中读取一条记录。现在，让我们使用它在所有排序的输入文件中按照时间顺序高效地构建一个输出文件。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi lq"><img src="../Images/76b6c3d0e1d71db25ef8feb645989daa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RsvRh2oNQe0pu2w5fNZo9w.png"/></div></div></figure><p id="e756" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe ky kz la lb b">merge_single_file()</code>为我们的文件读取生成器字典接受一个<code class="fe ky kz la lb b">dict</code>参数。</p><p id="6575" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它做的第一件事是创建另一个字典<code class="fe ky kz la lb b">top_item_per_reader</code>，他唯一的工作是保存一个从文件句柄读取的索引当前值的映射。最初对于每个读者来说，这只是第一个要素。我们可以使用列表理解来创建<code class="fe ky kz la lb b">i: get_next(readers[i])</code>，其中<code class="fe ky kz la lb b">get_next()</code>调用我们的生成器。</p><p id="ecfb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是<code class="fe ky kz la lb b">get_next()</code>的样子:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi lr"><img src="../Images/2619b7c8c6a20b4a07742076a674330b.png" data-original-src="https://miro.medium.com/v2/resize:fit:626/format:webp/1*fTSzG42m32lsWaDBs4kvGA.png"/></div></figure><p id="8ead" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">很简单。它通过生成器调用Python内置的<code class="fe ky kz la lb b">next()</code>并返回当前值。如果抛出<code class="fe ky kz la lb b">StopIteration</code>异常，返回<code class="fe ky kz la lb b">None</code>。捕捉这个异常是创建一个独立函数而不是直接调用<code class="fe ky kz la lb b">next()</code>的唯一原因。这使得合并中的代码更容易阅读。</p><p id="fb26" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还需要使用<code class="fe ky kz la lb b">with</code>操作符来打开一个输出文件的文件句柄，我们可以将结果流式传输到该文件中。我们将其命名为<code class="fe ky kz la lb b">merged_sat.out</code>。我们必须提供<code class="fe ky kz la lb b">'w’</code>来告诉open这是一个写操作。</p><p id="1bc2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了实现该算法，我们需要在遍历文件内容时跟踪最早的时间顺序条目。这就是<code class="fe ky kz la lb b">cur_min</code>和<code class="fe ky kz la lb b">cur_min_index</code>的用武之地。如果<code class="fe ky kz la lb b">cur_min</code>是<code class="fe ky kz la lb b">None</code>，那么我们知道我们刚刚开始对我们的五个句柄进行当前的<code class="fe ky kz la lb b">for</code>扫描，所以现在将最小值设置为第一个<code class="fe ky kz la lb b">sat_recording</code>。当我们看到其他代表各自文件头的<code class="fe ky kz la lb b">sat_reading</code>对象时，我们可以使用为<code class="fe ky kz la lb b">SatRecording</code>创建的实例方法<code class="fe ky kz la lb b">is_lte</code>来确定<code class="fe ky kz la lb b">sat_object</code>是否小于或等于<code class="fe ky kz la lb b">cur_min</code>。我们还必须检查<code class="fe ky kz la lb b">sat_recording = None</code>是否已经到达文件阅读器的末尾。</p><p id="4e22" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在每一轮<code class="fe ky kz la lb b">for</code>迭代结束时，让我们在所有仍有记录的文件中取最早观察到的<code class="fe ky kz la lb b">SatRecording</code>，并将其<code class="fe ky kz la lb b">record</code>属性写入我们的输出文件。</p><p id="617e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">还有更关键的一步。对于我们从中读取记录的文件，我们需要将文件句柄前进到下一条记录。这将更新<code class="fe ky kz la lb b">top_item_per_reader</code>,以具有该文件句柄的新的当前最早的时间顺序条目。这对我们的算法起作用是至关重要的。</p><pre class="kn ko kp kq gt lc lb ld le aw lf bi"><span id="dbe9" class="lg lh iq lb b gy li lj l lk ll">top_item_per_reader[cur_min_index] = get_next(readers[cur_min_index])</span></pre><p id="3338" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了清楚起见，这里用简单的数字代替日期时间字符串，直观地展示了这种算法的执行情况。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi ls"><img src="../Images/8ae3b8eb5e9f2b0eeaaebe69297e5d30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VSuNAKiwfxL99dzx-P4AYA.png"/></div></div></figure><p id="c1ca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每个阅读器的每个顶部项目值= <code class="fe ky kz la lb b">None</code>一次，然后我们将每个单独的dat文件中的每个记录写入我们的统一dat文件。我们现在可以退出程序了。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/608e7ff147c3de3a64c31c47b218dc3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1258/format:webp/1*ktI6sCfXFJyKTmWs5FsIOQ.png"/></div></figure><p id="4b23" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以下是<code class="fe ky kz la lb b">has_more_records</code>的工作方式。它查看顶部项目的地图，并检查是否所有项目都不存在。如果是，则返回True。</p><p id="8635" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另一种解释这个函数的方法是“非全无”。基于<code class="fe ky kz la lb b">return not all(i == None)</code></p><p id="d80b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">只要至少有一个值不是None，该函数将返回True。这意味着我们仍然有值要跨不同的文件生成器读取。</p><p id="497e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们做到了！</p><p id="d8b0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个解决方案有一些很好的特性。</p><ol class=""><li id="20f7" class="lu lv iq jp b jq jr ju jv jy lw kc lx kg ly kk lz ma mb mc bi translated">灵活适应任意数量的dat文件，并能容忍每个文件都有不同数量的记录。</li><li id="3f55" class="lu lv iq jp b jq md ju me jy mf kc mg kg mh kk lz ma mb mc bi translated">随着文件数量的增加，只需要很少的固定空间。对于每个文件句柄，我们每次在程序内存中只有一个记录。</li><li id="9593" class="lu lv iq jp b jq md ju me jy mf kc mg kg mh kk lz ma mb mc bi translated">当我们重复读取每个文件句柄时，总的O(n)线性最坏情况时间复杂度。这比内置<code class="fe ky kz la lb b">sorted()</code>的O(n log n)最坏情况性能要好得多</li><li id="21cc" class="lu lv iq jp b jq md ju me jy mf kc mg kg mh kk lz ma mb mc bi translated">我们可以迭代地将记录流式传输到输出文件中，而不必将所有内容都缓存在程序内存中。</li></ol><p id="76cc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于给定的输入dat文件:</p><p id="ca29" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">sat1.dat:</p><pre class="kn ko kp kq gt lc lb ld le aw lf bi"><span id="0a82" class="lg lh iq lb b gy li lj l lk ll">1|1.0|1.0|foo1|2022-02-06T12-01-00<br/>1|2.0|2.0|foo2|2022-02-06T12-03-00<br/>1|3.0|3.0|foo3|2022-02-06T12-05-00</span></pre><p id="004c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">sat2.dat:</p><pre class="kn ko kp kq gt lc lb ld le aw lf bi"><span id="ee2b" class="lg lh iq lb b gy li lj l lk ll">2|1.0|1.0|foo1|2022-02-06T12-02-00<br/>2|2.0|2.0|foo2|2022-02-06T12-04-00<br/>2|3.0|3.0|foo3|2022-02-06T12-06-00</span></pre><p id="b349" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们得到了一个统一的输出文件，它保持了全局时间排序的顺序:</p><pre class="kn ko kp kq gt lc lb ld le aw lf bi"><span id="45a4" class="lg lh iq lb b gy li lj l lk ll">1|1.0|1.0|foo1|2022-02-06T12-01-00<br/>2|1.0|1.0|foo1|2022-02-06T12-02-00<br/>1|2.0|2.0|foo2|2022-02-06T12-03-00<br/>2|2.0|2.0|foo2|2022-02-06T12-04-00<br/>1|3.0|3.0|foo3|2022-02-06T12-05-00<br/>2|3.0|3.0|foo3|2022-02-06T12-06-00</span></pre></div></div>    
</body>
</html>