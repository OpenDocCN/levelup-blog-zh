<html>
<head>
<title>Docker Containers for Deep Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">深度学习的Docker容器</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/docker-containers-for-deep-learning-77e8b7e10ef1?source=collection_archive---------7-----------------------#2020-03-16">https://levelup.gitconnected.com/docker-containers-for-deep-learning-77e8b7e10ef1?source=collection_archive---------7-----------------------#2020-03-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9102" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解什么是docker容器，我们为什么需要docker容器，以及如何创建深度学习的docker容器。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/fc12f335fc111c766392c1d7e49b4eaa.png" data-original-src="https://miro.medium.com/v2/resize:fit:678/format:webp/1*X_YknGp8WK5BDvRO_JbTAA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:<a class="ae ky" href="https://docs.docker.com/" rel="noopener ugc nofollow" target="_blank">https://docs.docker.com/</a>和<a class="ae ky" href="https://www.tensorflow.org/" rel="noopener ugc nofollow" target="_blank">https://www.tensorflow.org/</a></figcaption></figure><p id="ac99" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="lv">在这篇文章中，我们将了解Docker是什么以及它是如何帮助我们的。我们将了解虚拟机(VM)和Docker之间的区别。理解docker架构以及图像、容器、docker文件和卷等概念，并最终使用TensorFlow为深度学习算法创建Docker文件。</em> </strong></p><h1 id="7a69" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">Docker是什么，我们为什么需要它？</h1><p id="3779" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">您已经使用TensorFlow (TF)编写了用于分类的Python代码，并且获得了极好的精度和召回率。你现在想和你的朋友分享代码。代码在你的机器上运行良好，但在他们的计算机上出现错误。</p><p id="dd0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你发现问题出在不同版本的TF上。</p><p id="781f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你能把你的代码和所有相关的库打包，并把它发送给你的朋友会怎么样？</p><p id="9129" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是码头工人来救你的地方。</p><blockquote class="mt"><p id="e34a" class="mu mv it bd mw mx my mz na nb nc lu dk translated">Docker是一个构建、发布和部署应用程序的开放平台，它将应用程序与所有相关的库打包在一起，以确保代码可以在您的机器以及任何其他具有相同操作系统内核的机器上运行。</p><p id="7a43" class="mu mv it bd mw mx my mz na nb nc lu dk translated">Docker为所有使用容器的开发人员创建了一个标准化的环境，该环境封装了应用程序及其所有依赖库</p><p id="e434" class="mu mv it bd mw mx my mz na nb nc lu dk translated">Docker将应用程序从基础设施中分离出来，使它变得轻量级和快速</p><p id="a7ca" class="mu mv it bd mw mx my mz na nb nc lu dk translated">Docker很容易以近乎实时的方式扩展或删除应用程序和服务。</p></blockquote><p id="61d2" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated"><strong class="lb iu"> <em class="lv">虚拟机(VM)不也是为了同样的目的吗？</em>T11】</strong></p><p id="2719" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">VM和Docker是有区别的</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/44786847b3b30a7016b7a0efbefa9c7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IlmYy-VqlCwu9F_2Menm0Q.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">Docker和VM的区别</figcaption></figure><ul class=""><li id="6094" class="nj nk it lb b lc ld lf lg li nl lm nm lq nn lu no np nq nr bi translated">Docker运行多个容器；容器是封装应用程序和相关库的隔离环境</li><li id="8f12" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated">容器是开发、测试和部署应用程序的单元</li><li id="2fbe" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated"><strong class="lb iu">与VM相比，集装箱重量较轻。Docker映像没有虚拟机管理程序那样的额外负载。</strong> VM使用大量的磁盘空间，通常以GB为单位，而容器是轻量级的，通常以MB为单位。</li><li id="2fed" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated"><strong class="lb iu">容器直接在操作系统内核中运行</strong>。<strong class="lb iu">每个虚拟机内部都有一个操作系统，</strong>每个虚拟机在相同的硬件基础架构上可以有不同的操作系统</li><li id="dc9b" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated"><strong class="lb iu">与虚拟机相比，在相同的硬件上可以运行更多的容器，因为它们是轻量级容器，并且使用相同的操作系统内核。</strong></li></ul><p id="7ac7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个更好的架构是在一个VM上使用Docker和多个容器，如下所示</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/30261400f00d230253f4a2c3415d28e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:764/format:webp/1*HznUvpGQVS481OeUpZy5KA.png"/></div></figure><h1 id="b9b4" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">码头建筑</h1><p id="a6bf" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">Docker是一种客户端-服务器架构。docker客户端使用REST API与Docker守护进程通信。</p><p id="fc47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">Docker守护进程监听API请求，负责构建、运行和部署/分发Docker容器、卷等。</strong></p><p id="369a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> Docker注册表存储Docker图片。</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/43128d1b6fd95d7295a0c81b21ced628.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CNioUwfH0ctG_BiRl8GkEQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图片:<a class="ae ky" href="https://docs.docker.com/engine/docker-overview/" rel="noopener ugc nofollow" target="_blank">https://docs.docker.com/engine/docker-overview/</a></figcaption></figure><p id="3c7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">让我们了解一些与Docker相关的关键术语:图像和容器</em></p><h2 id="1bcf" class="nz lx it bd ly oa ob dn mc oc od dp mg li oe of mi lm og oh mk lq oi oj mm ok bi translated">图片:</h2><p id="2eab" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated"><strong class="lb iu">docker图像是由一系列层构建而成的只读模板。</strong>每一层都堆叠在下一层的顶部。使用包含源代码、相关库、工具或文件的docker文件中的指令来构建层，以使应用程序运行。</p><h2 id="e6a7" class="nz lx it bd ly oa ob dn mc oc od dp mg li oe of mi lm og oh mk lq oi oj mm ok bi translated">容器</h2><p id="d6ab" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated"><strong class="lb iu">容器是紧凑、隔离和便携的单元，用于一致地运行和部署应用</strong>，因此<strong class="lb iu">支持持续集成和持续交付</strong>。</p><p id="75b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">图像和容器的区别在于</p><ul class=""><li id="c401" class="nj nk it lb b lc ld lf lg li nl lm nm lq nn lu no np nq nr bi translated">图像是只读的，而容器的顶层是可写的。</li><li id="fea1" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated">如果图像被视为一个类，那么容器就是图像类的一个实例。</li><li id="0519" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated">多个容器共享对同一底层映像的访问，但可以有不同的数据。</li></ul><h2 id="e142" class="nz lx it bd ly oa ob dn mc oc od dp mg li oe of mi lm og oh mk lq oi oj mm ok bi translated">卷</h2><p id="3caf" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">当我们运行只读Docker映像来创建容器时，容器的顶层是可写的。默认情况下，数据<strong class="lb iu">不是</strong>持久存储在容器之外。如果我们修改在现有容器上运行的文件，该文件总是从只读层复制到可写层。对文件的任何更改在容器中都不可用，并且总是从只读映像中存在的文件的旧版本构建。为了解决数据持久化的问题，我们使用Docker Volume。</p><p id="38af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">卷有助于将数据保存在一个容器中，以及在几个Docker容器之间共享数据。卷是主机文件系统上的一个目录</strong></p><h2 id="162c" class="nz lx it bd ly oa ob dn mc oc od dp mg li oe of mi lm og oh mk lq oi oj mm ok bi translated">Dockerfile文件</h2><p id="3c65" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">Dockerfile是一个文本文件，我们在其中指定了Docker客户端调用来构建图像的命令列表</p><p id="f002" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Dockerfile包含四个命令，每个命令创建一个堆叠在另一个之上的层</p><ul class=""><li id="d5ea" class="nj nk it lb b lc ld lf lg li nl lm nm lq nn lu no np nq nr bi translated"><strong class="lb iu"> FROM </strong>:设置将在新图像创建过程中使用的容器图像</li><li id="3b10" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated"><strong class="lb iu">复制</strong>:将文件和目录复制到容器的文件系统中</li><li id="e81a" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated"><strong class="lb iu">运行</strong>:指定要运行的命令，并捕获到新的容器映像中</li><li id="d3d7" class="nj nk it lb b lc ns lf nt li nu lm nv lq nw lu no np nq nr bi translated"><strong class="lb iu"> CMD: </strong>设置部署容器映像实例时运行的默认命令</li></ul><p id="9bb7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">docker文件中的其他命令</p><p id="4cac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> WORKDIR </strong>:设置运行容器映像实例的工作目录</p><p id="1ce6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> EXPOSE </strong>:设置需要暴露的端口号。它通知Docker容器正在运行时监听指定的端口号</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/3e8e942b8b6927ff7a805220bb564d19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Az0BR0Sv3XLaWR-szcjh1A.png"/></div></div></figure><h1 id="e7aa" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">为深度学习分类模型创建docker文件</h1><p id="02fc" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我在一个文件<a class="ae ky" href="https://github.com/arshren/Classification-Fashion-MNIST/blob/master/Fashion_MNIST.py" rel="noopener ugc nofollow" target="_blank"> Fashion_MNIST.py </a>中使用Keras和TensorFlow为时尚MNIST编写了深度学习多类分类代码，该文件包含读取数据集、标准化数据、创建和训练模型并最终进行预测的代码。我想与您分享这段代码，以便它可以在您的机器上无缝运行。</p><p id="4076" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我有一个docker file<strong class="lb iu">fashion docker file</strong></p><pre class="kj kk kl km gt om on oo op aw oq bi"><span id="7185" class="nz lx it on b gy or os l ot ou"># use python 3.7 as base image<br/><strong class="on iu">FROM python:3.7</strong></span><span id="d5e7" class="nz lx it on b gy ov os l ot ou"># set the working directory to test_image<br/><strong class="on iu">WORKDIR /test_image</strong></span><span id="c4ff" class="nz lx it on b gy ov os l ot ou"># copy current directory files to test_image<br/><strong class="on iu">COPY / /test_image</strong></span><span id="199a" class="nz lx it on b gy ov os l ot ou"># install dependencies<br/><strong class="on iu">RUN pip install tensorflow==1.14.0<br/>RUN pip install -r requirements.txt</strong></span><span id="ae49" class="nz lx it on b gy ov os l ot ou">#Run Fashion_MNIST.py when container is launced<br/><strong class="on iu">CMD ["python", "Fashion_MNIST.py"]</strong></span></pre><p id="5033" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">requirements.txt包含以下依赖库</p><pre class="kj kk kl km gt om on oo op aw oq bi"><span id="914e" class="nz lx it on b gy or os l ot ou"><strong class="on iu">numpy==1.16.1<br/>matplotlib==3.0.2 <br/>keras==2.2.4</strong></span></pre><p id="afa0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在构建图像</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/c5dad3e09d7c87abc2202105dfc0c3ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:950/format:webp/1*--c6NTLcNz8ofwQrA8oDbQ.png"/></div></figure><p id="38b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦构建了映像，我们会看到以下消息</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/54d7f4643eada02505863b862bd1857b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1060/format:webp/1*Q4hMSvmjgdPAgbZ7oLys_Q.png"/></div></figure><p id="7445" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们最后运行图像来创建一个容器</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/089c7264292cc0e5cc1089c30a35ddac.png" data-original-src="https://miro.medium.com/v2/resize:fit:812/format:webp/1*jU9ZQof4upQlIMRmjMGttw.png"/></div></figure><p id="5bcb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你现在可以在你的机器上运行深度学习模型，没有任何问题</p><h2 id="390c" class="nz lx it bd ly oa ob dn mc oc od dp mg li oe of mi lm og oh mk lq oi oj mm ok bi translated">结论:</h2><p id="03f0" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">Docker运行多个容器，这些容器是独立的环境，封装了可以共享和部署的应用程序和相关库</p><h2 id="2bb4" class="nz lx it bd ly oa ob dn mc oc od dp mg li oe of mi lm og oh mk lq oi oj mm ok bi translated">参考资料:</h2><p id="5e1e" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated"><a class="ae ky" href="https://www.docker.com/resources/what-container" rel="noopener ugc nofollow" target="_blank">https://www.docker.com/resources/what-container</a></p></div></div>    
</body>
</html>