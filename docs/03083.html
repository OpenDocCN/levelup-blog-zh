<html>
<head>
<title>Learning C++: STL Algorithms Overview</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习C++: STL算法概述</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/learning-c-stl-algorithms-overview-9781e2f4249a?source=collection_archive---------9-----------------------#2020-04-18">https://levelup.gitconnected.com/learning-c-stl-algorithms-overview-9781e2f4249a?source=collection_archive---------9-----------------------#2020-04-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/4759e01e9a9a955e7b950f3412eaada3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*aRsgUnAAFEbF7EGZ"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">由<a class="ae kf" href="https://unsplash.com/@maxcodes?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">麦克斯韦·纳尔逊</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="bc96" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在以前的文章中，我已经写过关于C++标准模板库(STL)的容器。在这篇文章中，我将概述STL中的许多算法，在以后的文章中，我将提供这些算法的详细例子。</p><h1 id="55ec" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">STL算法概念</h1><p id="f348" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">C++ STL提供了执行多种任务的函数:排序、搜索、复制、修改、执行数值计算和重新排序等等。这些算法的一个有趣的方面是，它们不是附属于各种STL容器的成员函数。相反，这些函数是在特定容器内创建的迭代器上执行的全局函数。</p><p id="cd71" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这种实现的一个很大的优点是，您只需了解一种算法是如何工作的，然后就可以将它应用到您选择的容器中。许多算法将在多个容器上工作。一个更强大的特性是，您可以在自己的、用户定义的容器上使用这些算法。</p><p id="30fd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这种实现显然不属于面向对象的编程范式，而是一般函数式编程的一个例子。这意味着容器和算法是不同的，它们通过一个接口进行互操作。这种设计选择的结果是一些算法将不能与一些容器一起工作。更糟糕的是，一些算法，即使它们可以与容器一起工作，也可能效率低下。程序员有责任决定哪些算法适用于哪些容器。</p><h1 id="ee17" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">STL算法类别</h1><p id="af8e" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">STL中有几大类算法。以下部分将解释这些类别是什么，以及类别中算法的一些简要描述。</p><h1 id="83fb" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">非修改算法</h1><p id="1ddf" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">非修改算法不会改变容器中元素的顺序，也不会改变容器中的任何值。例如，<code class="fe mh mi mj mk b">for_each</code>函数对容器中的每个元素执行操作。由于范围<code class="fe mh mi mj mk b">for</code>循环现在可用，该功能不再像以前那样有用。计数元素的函数有:<code class="fe mh mi mj mk b">count</code>和<code class="fe mh mi mj mk b">count_if</code>；并且找到最小和最大元素，<code class="fe mh mi mj mk b">min_element</code>和<code class="fe mh mi mj mk b">max_element</code>。</p><p id="1a46" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">搜索数据有几个功能:<code class="fe mh mi mj mk b">find</code>、<code class="fe mh mi mj mk b">find_if</code>和<code class="fe mh mi mj mk b">find_if_not</code>。有两个搜索功能用于子范围中的第一次出现:<code class="fe mh mi mj mk b">search</code>和<code class="fe mh mi mj mk b">search_n</code>。还有一个查找最后一次出现的功能:<code class="fe mh mi mj mk b">find_end</code>。</p><p id="0f77" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于数据范围的处理，有两个函数:<code class="fe mh mi mj mk b">equal</code>，用于确定两个范围是否相等，以及<code class="fe mh mi mj mk b">is_permutation</code>，用于确定两个无序范围是否包含相同的元素。</p><p id="9692" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，尽管并不详尽，有三个函数可以确定容器的元素是否匹配某个标准:<code class="fe mh mi mj mk b">all_of</code>、<code class="fe mh mi mj mk b">any_of</code>和<code class="fe mh mi mj mk b">none_of</code>，它们的作用正如它们的名字所暗示的那样。</p><h1 id="a5e8" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">修改算法</h1><p id="c5f9" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">这类算法改变容器中元素的值。一些算法直接改变容器的值和/或在它们被复制到不同范围的元素时修改这些值。</p><p id="47ab" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">修改容器元素主要有两个功能:<code class="fe mh mi mj mk b">for_each</code>和<code class="fe mh mi mj mk b">transform</code>。<code class="fe mh mi mj mk b">for_each </code>函数对容器的每个元素执行修改操作。另一方面，<code class="fe mh mi mj mk b">transform</code>函数可用于修改容器的元素，并将它们复制到不同的目标范围。</p><p id="2390" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有两个复制容器元素的函数:<code class="fe mh mi mj mk b">copy</code>，它从一个开始元素复制，和<code class="fe mh mi mj mk b">copy_if</code>，它复制匹配一个标准的容器元素。</p><p id="f64f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以使用两个函数来移动容器中的元素:<code class="fe mh mi mj mk b">move</code>，从起始位置开始移动元素，以及<code class="fe mh mi mj mk b">move_backward</code>，从最后一个元素开始移动容器元素。</p><p id="0a15" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">替换容器元素有两个函数:<code class="fe mh mi mj mk b">replace</code>，用另一个值替换某个值的元素，和<code class="fe mh mi mj mk b">replace_if</code>，用另一个值替换匹配某个标准的元素。</p><p id="7cea" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这一类别中，我要提到的最后一个函数是merge，它接受两个范围并将它们合并在一起。</p><h1 id="94fd" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">移除算法</h1><p id="eac7" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">这个类别实际上是修改算法的一个子类别，包含删除容器元素的函数。第一个是<code class="fe mh mi mj mk b">remove</code>，它删除匹配给定值的容器元素。一个类似的函数<code class="fe mh mi mj mk b">remove_if</code>删除符合指定标准的元素。<code class="fe mh mi mj mk b">remove_copy</code>函数复制不匹配指定值的容器元素，而<code class="fe mh mi mj mk b">remove_copy_if</code>复制不匹配指定标准的容器元素。</p><p id="3c9f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">unique</code>函数将删除任何重复的相邻容器元素。还有<code class="fe mh mi mj mk b">unique_copy</code>函数，它复制容器元素，同时也删除相邻的重复元素。</p><h1 id="83af" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">变异算法</h1><p id="4599" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">下一组算法修改了元素的顺序，但没有改变它们。<code class="fe mh mi mj mk b">reverse</code>函数反转容器的顺序，而<code class="fe mh mi mj mk b">reverse_copy</code>在复制容器元素的同时复制它们。</p><p id="fbd5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">rotate</code>函数将使用迭代器位置来移动容器的元素。<code class="fe mh mi mj mk b">next_permutation</code>函数改变容器元素的顺序，这样如果元素的顺序是(1，2，3)，下一个改变可能是(1，3，2)。</p><p id="4244" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">shuffle</code>函数随机打乱容器的元素，<code class="fe mh mi mj mk b">partition</code>函数将那些符合标准的元素移动到容器的前面。</p><h1 id="4598" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">排序算法</h1><p id="768e" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">STL中有几种算法用于对容器的元素进行排序。主要功能是<code class="fe mh mi mj mk b">sort</code>。该函数将对基于迭代器的容器元素范围进行排序，通常使用<em class="ml">快速排序</em>算法来实现。sort函数使用的排序算法类型取决于实现。</p><p id="ed70" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你有一个包含重复元素的容器，并且你想保持这些重复元素的顺序，你可以使用<code class="fe mh mi mj mk b">stable_sort</code>函数。如果您只想对一定数量的元素进行排序，可以使用<code class="fe mh mi mj mk b">partial_sort</code>功能。</p><p id="3643" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我在上面提到的作为变异函数的<code class="fe mh mi mj mk b">partition</code>函数也可以用于对容器元素进行排序，因为排序顺序可以作为使用的标准。</p><p id="3ca2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您想查看容器是否已经分类，您可以使用<code class="fe mh mi mj mk b">is_sorted</code>功能。</p><h1 id="5159" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">排序范围算法</h1><p id="5ada" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">这些是您可以在元素已经排序的容器上调用的一组函数。<code class="fe mh mi mj mk b">binary_search</code>函数在容器范围内搜索一个元素。includes函数确定一个范围中的每个元素是否也是另一个范围中的元素。</p><p id="bf12" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">lower_bound</code>函数查找大于或等于给定值的第一个容器元素，这意味着这是一个较小的值可以插入到一个范围的地方，而<code class="fe mh mi mj mk b">upper_bound </code>函数查找给定值可以插入到一个排序范围的最后一个地方。</p><p id="abda" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">merge</code>功能将一个范围合并到另一个范围。容器范围有三个基于集合的函数:<code class="fe mh mi mj mk b">set_union</code>用于处理两个范围的排序联合，<code class="fe mh mi mj mk b">set_intersection</code>用于两个范围的排序交集，<code class="fe mh mi mj mk b">set_difference</code>用于查找一个范围中不属于另一个范围的所有元素。</p><h1 id="3cbb" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">数字算法</h1><p id="46df" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">有一些算法用于数字处理。其中最常用的是<code class="fe mh mi mj mk b">accumulate</code>函数，例如，它用于计算总和与乘积。该组中的其他函数<code class="fe mh mi mj mk b">inner_product</code>、<code class="fe mh mi mj mk b">adjacent_difference</code>和<code class="fe mh mi mj mk b">partial_sum</code>并不常用，将在以后的文章中讨论。</p><h1 id="354c" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">未来的深度报道</h1><p id="dd63" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">这篇文章仅仅是对STL中各种算法函数的概述。我将在以后的文章中更深入地讨论这些和其他STL算法，所以请寻找它们。</p><p id="a401" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢您阅读这篇文章，请给我发电子邮件，提出您的意见和建议。</p></div></div>    
</body>
</html>