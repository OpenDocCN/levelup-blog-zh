<html>
<head>
<title>Ensemble learning using the Voting Classifier</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用投票分类器的集成学习</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/ensemble-learning-using-the-voting-classifier-a28d450be64d?source=collection_archive---------8-----------------------#2020-02-09">https://levelup.gitconnected.com/ensemble-learning-using-the-voting-classifier-a28d450be64d?source=collection_archive---------8-----------------------#2020-02-09</a></blockquote><div><div class="fc ij ik il im in"/><div class="io ip iq ir is"><figure class="iu iv gp gr iw ix gh gi paragraph-image"><div role="button" tabindex="0" class="iy iz di ja bf jb"><div class="gh gi it"><img src="../Images/5e6090ef93b17ef349234e84cc4403f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jRPs81mYrrmMsgVP9suJrA.jpeg"/></div></div><figcaption class="je jf gj gh gi jg jh bd b be z dk translated">来源:<a class="ae ji" href="https://pixabay.com/photos/vote-word-letters-scrabble-1804596/" rel="noopener ugc nofollow" target="_blank"> pixabay </a></figcaption></figure><div class=""/><div class=""><h2 id="b08e" class="pw-subtitle-paragraph ki jk jl bd b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz dk translated">了解如何使用集成学习的变体来利用多个模型的优势</h2></div><p id="f22d" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">在本文中，我描述了一个简单的集成算法。总体而言，集合模型结合多个基本模型来提高预测性能。集成模型最著名的例子是随机森林，它极大地简化了算法的逻辑，结合了多个决策树，并在分类问题中使用多数投票或通过对回归任务取平均值来聚合它们的预测。</p><p id="4467" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">与随机森林类似，投票集合估计多个基本模型，并使用投票来组合各个预测以获得最终预测。然而，关键的区别在于基本估计量。投票集成(和堆叠集成)等模型不要求基础模型是同质的。换句话说，我们可以训练不同的基础学习器，例如，决策树和逻辑回归，然后使用投票集成来组合结果。</p><p id="af71" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">下图显示了投票组合的工作流程:</p><figure class="lx ly lz ma gt ix gh gi paragraph-image"><div role="button" tabindex="0" class="iy iz di ja bf jb"><div class="gh gi lw"><img src="../Images/4391be96513f22b80cd6506761bd6be2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EekXroXi99N05jcskdPsIg.png"/></div></div></figure><p id="9b4d" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">投票分类器支持两种类型的投票:</p><ul class=""><li id="0f23" class="mb mc jl lc b ld le lg lh lj md ln me lr mf lv mg mh mi mj bi translated"><strong class="lc jm">硬</strong>:最终的类别预测是通过多数投票做出的——评估者选择在基本模型中出现最频繁的类别预测。</li><li id="3885" class="mb mc jl lc b ld mk lg ml lj mm ln mn lr mo lv mg mh mi mj bi translated"><strong class="lc jm">软</strong>:基于使用所有基础模型预测计算的平均概率，进行最终类别预测。例如，如果模型1以70%的概率预测正类，模型2以90%的概率预测正类，则投票集合将计算出有80%的机会观察值属于正类，并选择正类作为预测。此外，我们可以使用自定义权重来计算加权平均值。这适用于我们更加信任一些模型，但仍然想考虑那些我们不太信任的模型的情况。</li></ul><p id="6970" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">需要记住的一点是，为了使用软投票，所有的基本模型都必须有<code class="fe mp mq mr ms b">predict_proba</code>方法。软投票可以比硬投票产生更好的性能(但不一定)，因为通过平均概率，它“给予”有信心的投票更多的权重。</p><p id="cd27" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">上述投票方案只对分类问题(二元和多类)有效。在<code class="fe mp mq mr ms b">scikit-learn</code>中，回归问题有一个单独的投票估计器(<code class="fe mp mq mr ms b">VotingRegressor</code>)，它使用基本估计器预测的平均值作为最终预测。关于实现的例子，请参见<a class="ae ji" href="https://github.com/erykml/medium_articles/blob/master/Machine%20Learning/voting_classifier_article.ipynb" rel="noopener ugc nofollow" target="_blank">GitHub上的笔记本</a>。</p><p id="43d5" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">投票集合是一种有用的技术，当单个模型显示出某种偏差时，这种技术尤其有用。也有可能投票集合产生比最好的基本估计量更好的总体分数，因为它聚集了多个模型的预测并试图覆盖单个模型的潜在弱点。提高集合性能的一种方法是使基本估计量尽可能多样化。</p><p id="3bec" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">在0.22版本中，<code class="fe mp mq mr ms b">scikit-learn</code>引入了<code class="fe mp mq mr ms b">StackingClassifier</code>，这是另一种使用异质模型作为基本估计器的集成技术。堆叠集成和投票集成的区别在于，前者在基本估计器预测的基础上训练另一个估计器(称为元学习器)。用于该任务的常见模型是逻辑回归。也可以将多层模型堆叠在彼此之上。</p><p id="d6ff" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">简单的理论介绍之后，让我们开始动手做编码吧。</p><h1 id="52c6" class="mt mu jl bd mv mw mx my mz na nb nc nd kr ne ks nf ku ng kv nh kx ni ky nj nk bi translated">设置</h1><p id="a01a" class="pw-post-body-paragraph la lb jl lc b ld nl km lf lg nm kp li lj nn ll lm ln no lp lq lr np lt lu lv io bi translated">我们需要导入以下库:</p><figure class="lx ly lz ma gt ix"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="87f8" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">这个列表相当长，因为我们需要导入不同的分类器，这些分类器将被用作基本估计器。</p><h1 id="ccc4" class="mt mu jl bd mv mw mx my mz na nb nc nd kr ne ks nf ku ng kv nh kx ni ky nj nk bi translated">为分类准备数据集</h1><p id="c263" class="pw-post-body-paragraph la lb jl lc b ld nl km lf lg nm kp li lj nn ll lm ln no lp lq lr np lt lu lv io bi translated">为了简单起见，我们使用<code class="fe mp mq mr ms b">scikit-learn</code>的<code class="fe mp mq mr ms b">make_classification</code>函数来准备分类数据集。我们创建了一个包含500个观察值和10个特征的数据集。使用默认设置，数据集中有2个信息要素和2个冗余要素。有关该功能的更多信息，请参考<a class="ae ji" href="https://scikit-learn.org/stable/modules/generated/sklearn.datasets.make_classification.html" rel="noopener ugc nofollow" target="_blank">文档</a>。我们额外设置了<code class="fe mp mq mr ms b">random_state</code>用于再现性。</p><figure class="lx ly lz ma gt ix"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="6f9f" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">我们创建的数据集是平衡的，标注类的比例为1:1。我们可以通过运行<code class="fe mp mq mr ms b">Counter(y)</code>来验证这一点。</p><p id="a370" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">创建数据集后，我们将数据分为训练集和测试集(使用80–20分割)，并使用StandardScaler缩放要素。请记住，在应用缩放等转换时，我们只在训练集上训练缩放器，并转换训练集和测试集。这样我们可以防止数据泄露。</p><p id="d7de" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">诸如决策树之类的算法不需要缩放特征，然而，依赖于某种距离度量(例如k-最近邻)的估计器需要缩放特征。我们对数据进行了缩放，因此它与所有考虑的估计值都兼容。</p><h1 id="d8df" class="mt mu jl bd mv mw mx my mz na nb nc nd kr ne ks nf ku ng kv nh kx ni ky nj nk bi translated">拟合模型</h1><p id="4e03" class="pw-post-body-paragraph la lb jl lc b ld nl km lf lg nm kp li lj nn ll lm ln no lp lq lr np lt lu lv io bi translated">作为第一步，我们定义一个元组列表，每个元组包含模型的名称和估计器本身。此时，我们对所有分类器的默认设置都很满意。我们以这种方式建立模型，因为该列表将在稍后用作<code class="fe mp mq mr ms b">VotingClassifier</code>的输入。</p><figure class="lx ly lz ma gt ix"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="aa45" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">下一步，我们迭代前面定义的列表。对于每个模型，我们将它拟合到训练数据，预测测试集的标签，并使用准确性评估性能(这是一个可接受的度量，因为类是平衡的)。出于可再现性的考虑，每当估计量有一个<code class="fe mp mq mr ms b">random_state</code>参数时，我们将其设置为42。</p><figure class="lx ly lz ma gt ix"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="cd5d" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">以下代码片段总结了模型的性能:</p><pre class="lx ly lz ma gt ns ms nt nu aw nv bi"><span id="8034" class="nw mu jl ms b gy nx ny l nz oa">decision tree's accuracy: 0.86 <br/>logistic regression's accuracy: 0.85 <br/>knn's accuracy: 0.86 <br/>naive bayes classifier's accuracy: 0.87 </span></pre><p id="508e" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">性能最好的模型是朴素贝叶斯分类器。</p><h1 id="5898" class="mt mu jl bd mv mw mx my mz na nb nc nd kr ne ks nf ku ng kv nh kx ni ky nj nk bi translated">使用投票分类器</h1><p id="602e" class="pw-post-body-paragraph la lb jl lc b ld nl km lf lg nm kp li lj nn ll lm ln no lp lq lr np lt lu lv io bi translated">是时候看看我们是否可以通过使用<code class="fe mp mq mr ms b">VotingClassifier</code>来提高性能了。我们从硬投票方案(多数票)开始。以下代码展示了如何设置它:</p><figure class="lx ly lz ma gt ix"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="fb30" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">运行代码打印出0.88的准确度分数，比最好的基本估计值稍好。看来这次我们可以从使用系综方法中获益。</p><p id="b203" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">我们也可以通过用<code class="fe mp mq mr ms b">'soft’</code>替换投票参数的值来尝试使用软投票。这样做实际上会将准确度分数降低到0.85。这可能是因为在某些情况下，模型对预测的类并不真正有信心。</p><h1 id="8b27" class="mt mu jl bd mv mw mx my mz na nb nc nd kr ne ks nf ku ng kv nh kx ni ky nj nk bi translated">结论</h1><p id="ab89" class="pw-post-body-paragraph la lb jl lc b ld nl km lf lg nm kp li lj nn ll lm ln no lp lq lr np lt lu lv io bi translated">在本文中，我展示了一个在<code class="fe mp mq mr ms b">scikit-learn</code>中可用的集成方法的基本用例。当在一个项目中工作时，我们最有可能用不同的评估方法进行实验，所以尝试将它们聚合起来，看看是否会得到更好的结果是有意义的。在实际项目中使用这种方法的一个潜在缺点是缺乏可解释性。</p><p id="2e20" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">此外，<code class="fe mp mq mr ms b">VotingClassifier</code>可与<code class="fe mp mq mr ms b">GridSearchCV</code>(或随机变量)一起使用，为基本估计量找到最佳超参数值。</p><p id="c2ac" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">您可以在我的<a class="ae ji" href="https://github.com/erykml/medium_articles/blob/master/Machine%20Learning/voting_classifier_article.ipynb" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到本文使用的代码。一如既往，我们欢迎任何建设性的反馈。你可以在<a class="ae ji" href="https://twitter.com/erykml1?source=post_page---------------------------" rel="noopener ugc nofollow" target="_blank">推特</a>或评论中联系我。</p></div><div class="ab cl ob oc hz od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="io ip iq ir is"><p id="9dc6" class="pw-post-body-paragraph la lb jl lc b ld le km lf lg lh kp li lj lk ll lm ln lo lp lq lr ls lt lu lv io bi translated">我最近出版了一本关于使用Python解决金融领域实际任务的书。如果你感兴趣，我在<a class="ae ji" href="https://towardsdatascience.com/introducing-my-book-python-for-finance-cookbook-de219ca0d612" rel="noopener" target="_blank">贴了一篇文章</a>介绍这本书的内容。你可以在亚马逊或者Packt的网站上买到这本书。</p></div></div>    
</body>
</html>