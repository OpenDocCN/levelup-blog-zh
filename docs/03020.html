<html>
<head>
<title>Remote development with multi-node MicroK8s cluster and Skaffold</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用多节点MicroK8s集群和Skaffold进行远程开发</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/remote-development-with-a-multi-node-kubernetes-cluster-f131aa48d82?source=collection_archive---------7-----------------------#2020-04-15">https://levelup.gitconnected.com/remote-development-with-a-multi-node-kubernetes-cluster-f131aa48d82?source=collection_archive---------7-----------------------#2020-04-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/49c24bb08a54b1c90907ba8c3ab88020.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PlaALm5CdtLMHc8_Ye0OWg.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><em class="kf">图片属于其各自的所有者</em></figcaption></figure><p id="07e4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">作为实现环境间对等的努力的一部分，我的团队最近在<a class="ae le" href="http://skaffold.dev" rel="noopener ugc nofollow" target="_blank">ska fold</a>的帮助下，转而使用<a class="ae le" href="https://kubernetes.io" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>进行开发和生产编排。</p><p id="52b7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">虽然这减少了维护开销，总体来说是个好主意，但这也意味着应用程序很快就超出了我的笔记本电脑。幸运的是，我们有一个企业虚拟机配置环境，我决定卸载我的开发环境。</p><p id="57b7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，建立一个具有足够大的虚拟机的单节点集群会更容易，但是这有多基础呢？所以，我选择了多节点集群。如果你也想这样做，请继续阅读！</p><h1 id="c629" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">先决条件</h1><ul class=""><li id="cb1c" class="md me it ki b kj mf kn mg kr mh kv mi kz mj ld mk ml mm mn bi translated">一套Ubuntu虚拟机。我使用了四台16 GB内存和4个CPU内核的机器。</li><li id="4652" class="md me it ki b kj mo kn mp kr mq kv mr kz ms ld mk ml mm mn bi translated">选择其中一个实例作为主节点，其余的将被视为辅助节点。让我们假设主节点有IP地址<code class="fe mt mu mv mw b">10.0.0.1</code>。</li><li id="8ca8" class="md me it ki b kj mo kn mp kr mq kv mr kz ms ld mk ml mm mn bi translated">节点之间的共享磁盘，以便永久卷可以在它们之间共享。接下来，我们将假设在所有节点上的<code class="fe mt mu mv mw b">/data</code>处安装了一个合理大小的磁盘。</li></ul><h1 id="4953" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">要公开的端口</h1><p id="406e" class="pw-post-body-paragraph kg kh it ki b kj mf kl km kn mg kp kq kr mx kt ku kv my kx ky kz mz lb lc ld im bi translated">主节点应该公开以下端口:</p><ul class=""><li id="e5d9" class="md me it ki b kj kk kn ko kr na kv nb kz nc ld mk ml mm mn bi translated"><code class="fe mt mu mv mw b">25000</code>(这样辅助节点可以加入集群)</li><li id="deaf" class="md me it ki b kj mo kn mp kr mq kv mr kz ms ld mk ml mm mn bi translated"><code class="fe mt mu mv mw b">32000</code>(这样容器注册表就可以被二级节点访问)</li><li id="28d9" class="md me it ki b kj mo kn mp kr mq kv mr kz ms ld mk ml mm mn bi translated"><code class="fe mt mu mv mw b">16443</code>(如果您想从远程机器使用<code class="fe mt mu mv mw b">kubectl</code>)</li><li id="0726" class="md me it ki b kj mo kn mp kr mq kv mr kz ms ld mk ml mm mn bi translated">其他需要的</li></ul><h1 id="b2bf" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">要安装的软件</h1><p id="be51" class="pw-post-body-paragraph kg kh it ki b kj mf kl km kn mg kp kq kr mx kt ku kv my kx ky kz mz lb lc ld im bi translated">按照标准步骤安装以下服务/应用程序:</p><ul class=""><li id="5943" class="md me it ki b kj kk kn ko kr na kv nb kz nc ld mk ml mm mn bi translated"><a class="ae le" href="http://www.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker </a> —在所有节点上</li><li id="0b44" class="md me it ki b kj mo kn mp kr mq kv mr kz ms ld mk ml mm mn bi translated"><a class="ae le" href="http://skaffold.dev/" rel="noopener ugc nofollow" target="_blank"> Skaffold </a> —仅在主节点上</li></ul><p id="8027" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我的虚拟机从Ubuntu Server 16.04开始，然后我升级到了18.04。这不是必须的，但是如果它改变了下面的一些步骤，这一点很重要。</p><h1 id="d89e" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">安装MicroK8s</h1><p id="a065" class="pw-post-body-paragraph kg kh it ki b kj mf kl km kn mg kp kq kr mx kt ku kv my kx ky kz mz lb lc ld im bi translated">让我们从在所有节点上安装MicroK8s 开始:</p><pre class="nd ne nf ng gt nh mw ni nj aw nk bi"><span id="5de6" class="nl lg it mw b gy nm nn l no np">sudo snap install microk8s --classic --channel=1.18/stable<br/># check status<br/>sudo microk8s status --wait-ready</span></pre><p id="c031" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在不需要启用任何插件，因为我们将在后面的步骤中这样做。</p><p id="5283" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">警告:</strong>你可能会与<a class="ae le" href="https://bugs.launchpad.net/ubuntu/+source/snapd/+bug/1662552" rel="noopener ugc nofollow" target="_blank"> NFS发生争执，并与</a>发生争执。我只能以root身份运行MicroK8s命令。</p><h2 id="e5ff" class="nl lg it bd lh nq nr dn ll ns nt dp lp kr nu nv lt kv nw nx lx kz ny nz mb oa bi translated">库贝特尔</h2><p id="9058" class="pw-post-body-paragraph kg kh it ki b kj mf kl km kn mg kp kq kr mx kt ku kv my kx ky kz mz lb lc ld im bi translated">MicroK8s自带命名空间<code class="fe mt mu mv mw b">kubectl</code>，可以用<code class="fe mt mu mv mw b">microk8s kubectl</code>调用。如果你习惯于直接和<code class="fe mt mu mv mw b">kubectl</code>一起工作，这可能会变得乏味。有几种方法可以解决这个问题:</p><ul class=""><li id="33bf" class="md me it ki b kj kk kn ko kr na kv nb kz nc ld mk ml mm mn bi translated">通过运行以下命令将现有的<code class="fe mt mu mv mw b">kubectl</code>连接到您的MicroK8s实例</li></ul><pre class="nd ne nf ng gt nh mw ni nj aw nk bi"><span id="9ebe" class="nl lg it mw b gy nm nn l no np">sudo microk8s kubectl config view --raw &gt; $HOME/.kube/config</span></pre><ul class=""><li id="2eda" class="md me it ki b kj kk kn ko kr na kv nb kz nc ld mk ml mm mn bi translated">只要可以访问适当的端口，就可以使用相同的文件从远程机器访问集群。更多信息参见<a class="ae le" href="https://kubernetes.io/docs/concepts/configuration/organize-cluster-access-kubeconfig" rel="noopener ugc nofollow" target="_blank">文档</a>。我应该指出，这是我已经测试过的选项，但是接下来的两个也可能有效。</li><li id="7b82" class="md me it ki b kj mo kn mp kr mq kv mr kz ms ld mk ml mm mn bi translated">使用一个古老的别名:<code class="fe mt mu mv mw b">alias kubectl='microk8s kubectl'</code></li><li id="0851" class="md me it ki b kj mo kn mp kr mq kv mr kz ms ld mk ml mm mn bi translated">使用快照别名:<code class="fe mt mu mv mw b">sudo snap alias microk8s.kubectl kubectl</code></li></ul><h1 id="10d9" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">安装和配置MicroK8s插件</h1><p id="a30e" class="pw-post-body-paragraph kg kh it ki b kj mf kl km kn mg kp kq kr mx kt ku kv my kx ky kz mz lb lc ld im bi translated">首先，启用一些我们将需要的基本的<a class="ae le" href="https://microk8s.io/docs/addons" rel="noopener ugc nofollow" target="_blank"> MicroK8s插件</a>:</p><pre class="nd ne nf ng gt nh mw ni nj aw nk bi"><span id="a1bd" class="nl lg it mw b gy nm nn l no np">sudo microk8s enable dns ingress storage</span></pre><p id="da0c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您需要<a class="ae le" href="http://helm.sh" rel="noopener ugc nofollow" target="_blank">舵</a>支持，请务必将<code class="fe mt mu mv mw b">helm</code>添加到上面的列表中。</p><h2 id="ce1a" class="nl lg it bd lh nq nr dn ll ns nt dp lp kr nu nv lt kv nw nx lx kz ny nz mb oa bi translated">配置存储位置</h2><p id="7128" class="pw-post-body-paragraph kg kh it ki b kj mf kl km kn mg kp kq kr mx kt ku kv my kx ky kz mz lb lc ld im bi translated">默认情况下，存储插件将所有卷保存在<code class="fe mt mu mv mw b">/var/snap/microk8s/common/default-storage</code>中。因为我们将在不同的节点上共享存储，所以我们需要更新它以写入我们的<code class="fe mt mu mv mw b">/data</code>挂载磁盘。您可以通过编辑<code class="fe mt mu mv mw b">hostpath-provisioner</code>部署来做到这一点:</p><pre class="nd ne nf ng gt nh mw ni nj aw nk bi"><span id="c9c1" class="nl lg it mw b gy nm nn l no np">sudo microk8s kubectl get -o yaml -n kube-system deploy hostpath-provisioner | \<br/>  sed 's~/var/snap/microk8s/common/default-storage~/data/snap/microk8s/common/default-storage~g' | \<br/>  sudo microk8s kubectl apply -f -</span><span id="0aa2" class="nl lg it mw b gy ob nn l no np"># restart microk8s for good measure<br/>sudo microk8s stop &amp;&amp; sudo microk8s start</span></pre><h2 id="57e6" class="nl lg it bd lh nq nr dn ll ns nt dp lp kr nu nv lt kv nw nx lx kz ny nz mb oa bi translated">启用内部注册表</h2><p id="f415" class="pw-post-body-paragraph kg kh it ki b kj mf kl km kn mg kp kq kr mx kt ku kv my kx ky kz mz lb lc ld im bi translated">当您拥有一个多节点集群时，共享开发映像的最简单的方法是将它们推送到一个私有注册中心。Skaffold知道如何在需要的时候从私有注册中心推送和获取，但是我们需要建立一个。幸运的是，MicroK8s让这变得相对容易:</p><pre class="nd ne nf ng gt nh mw ni nj aw nk bi"><span id="f47c" class="nl lg it mw b gy nm nn l no np">sudo microk8s enable registry</span></pre><p id="0466" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这将在端口<code class="fe mt mu mv mw b">32000</code>上启动一个注册表，集群中的其他节点可以通过<code class="fe mt mu mv mw b">10.0.0.1:32000</code>访问该注册表。</p><h2 id="136c" class="nl lg it bd lh nq nr dn ll ns nt dp lp kr nu nv lt kv nw nx lx kz ny nz mb oa bi translated">使用不安全的注册表</h2><p id="7215" class="pw-post-body-paragraph kg kh it ki b kj mf kl km kn mg kp kq kr mx kt ku kv my kx ky kz mz lb lc ld im bi translated">如果没有额外的配置，在上述步骤中启动的注册表是不安全的。如果你对此不满意，你可以考虑保护它。出于本教程的目的，我们将继续按原样使用它，这仍然需要一些—尽管不太复杂—的更改。</p><p id="e1db" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，我们需要确保Docker不会因为这个注册表不安全而有任何问题。这可以通过<a class="ae le" href="https://docs.docker.com/registry/insecure/" rel="noopener ugc nofollow" target="_blank">在<code class="fe mt mu mv mw b">/etc/docker/daemon.json</code>编辑Docker守护进程配置</a>来完成，以添加以下行:</p><pre class="nd ne nf ng gt nh mw ni nj aw nk bi"><span id="a836" class="nl lg it mw b gy nm nn l no np">{<br/>  "insecure-registries" : ["10.0.0.1:32000"]<br/>}</span></pre><p id="8b9a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请记住，如果这个文件不存在，可能需要创建它。完成后，重新启动守护程序以使更改生效:</p><pre class="nd ne nf ng gt nh mw ni nj aw nk bi"><span id="d938" class="nl lg it mw b gy nm nn l no np">sudo systemctl restart docker</span></pre><p id="ab0e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第二，需要说服MicroK8s在从这个不安全的注册表中拉取时不要抱怨。要先发制人地解决这个问题，找到文件<code class="fe mt mu mv mw b">/var/snap/microk8s/current/args/containerd-template.toml</code>并在<code class="fe mt mu mv mw b">[plugins] -&gt; [plugins.cri.registry] -&gt; [plugins.cri.registry.mirrors]</code>下添加:</p><pre class="nd ne nf ng gt nh mw ni nj aw nk bi"><span id="cfc9" class="nl lg it mw b gy nm nn l no np">        [plugins.cri.registry.mirrors."10.0.0.1:32000"]<br/>          endpoint = ["http://10.0.0.1:32000"]</span></pre><p id="a3ac" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">重启MicroK8s:</p><pre class="nd ne nf ng gt nh mw ni nj aw nk bi"><span id="1b3b" class="nl lg it mw b gy nm nn l no np">sudo microk8s stop &amp;&amp; sudo microk8s start</span></pre><p id="da18" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这需要在所有节点上完成。详见<a class="ae le" href="https://microk8s.io/docs/registry-private" rel="noopener ugc nofollow" target="_blank">官方说明</a>。</p><h1 id="0679" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">形成集群</h1><p id="217b" class="pw-post-body-paragraph kg kh it ki b kj mf kl km kn mg kp kq kr mx kt ku kv my kx ky kz mz lb lc ld im bi translated">最后，我们准备组建一个集群。在主节点上运行以下命令:</p><pre class="nd ne nf ng gt nh mw ni nj aw nk bi"><span id="1204" class="nl lg it mw b gy nm nn l no np">microk8s add-node</span></pre><p id="54bb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您将得到类似于以下内容的内容:</p><pre class="nd ne nf ng gt nh mw ni nj aw nk bi"><span id="a1c5" class="nl lg it mw b gy nm nn l no np">Join node with: microk8s join 10.0.0.1:25000/&lt;some-token&gt;<!-- --> </span></pre><p id="f516" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">复制<code class="fe mt mu mv mw b">microk8s join...</code>命令，并在一个辅助节点上运行它。需要为您希望添加到群集的每个辅助节点生成一个新令牌。</p><p id="c61c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，您可以在主服务器上运行<code class="fe mt mu mv mw b">kubectl get nodes</code>，看到所有节点都已加入。就这样，您现在拥有了自己的全功能Kubernetes集群！</p><h1 id="fadc" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">使用Skaffold进行构建和部署</h1><p id="4768" class="pw-post-body-paragraph kg kh it ki b kj mf kl km kn mg kp kq kr mx kt ku kv my kx ky kz mz lb lc ld im bi translated">教程的这一部分假设了一些关于<a class="ae le" href="http://skaffold.dev" rel="noopener ugc nofollow" target="_blank"> Skaffold </a>的知识。如果你不熟悉它，这是一个非常有用的工具，我强烈推荐你去看看。在我的例子中，我们使用Skaffold来简化构建Docker映像和在开发期间部署我们的<a class="ae le" href="http://helm.sh" rel="noopener ugc nofollow" target="_blank"> Helm </a>图表。</p><p id="4152" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的设置就绪后，我们需要对我们的<code class="fe mt mu mv mw b">skaffold.yaml</code>文件做一些小的调整，以使它们能够与多节点集群和私有注册中心一起工作。我还假设您的代码已经被克隆到主节点上的某个位置。</p><p id="feb6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，在<code class="fe mt mu mv mw b">build.insecureRegistries</code>下面列出你的私有注册表:</p><pre class="nd ne nf ng gt nh mw ni nj aw nk bi"><span id="641a" class="nl lg it mw b gy nm nn l no np">build:<br/>  insecureRegistries: ["10.0.0.1:32000"]</span></pre><p id="1ff5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第二，在<code class="fe mt mu mv mw b">build</code>下为您的所有工件的图像名加上您的注册地址前缀，如下所示:</p><pre class="nd ne nf ng gt nh mw ni nj aw nk bi"><span id="d585" class="nl lg it mw b gy nm nn l no np">build:<br/>  artifacts:<br/>  - image: 10.0.0.1:32000/my-image</span></pre><p id="c01b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这同样适用于你使用图像的地方。这可能因您自己的设置而异。例如，如果您使用Helm，您可能会得到类似于以下内容的结果:</p><pre class="nd ne nf ng gt nh mw ni nj aw nk bi"><span id="0141" class="nl lg it mw b gy nm nn l no np">deploy:<br/>  helm:<br/>    releases:<br/>    - values:<br/>        imageName: 10.0.0.1:32000/my-image</span></pre><p id="41c6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在您可以像往常一样使用<code class="fe mt mu mv mw b">skaffold dev</code>或<code class="fe mt mu mv mw b">skaffold run</code>进行构建和部署。发展再也不会一样了！</p><h1 id="d5fb" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">解决纷争</h1><p id="9a3a" class="pw-post-body-paragraph kg kh it ki b kj mf kl km kn mg kp kq kr mx kt ku kv my kx ky kz mz lb lc ld im bi translated">在这个过程中，我遇到了一些问题，这些问题可能是我的系统特有的，但是值得一提。</p><h2 id="1142" class="nl lg it bd lh nq nr dn ll ns nt dp lp kr nu nv lt kv nw nx lx kz ny nz mb oa bi translated">出现“禁止:被群集策略禁止”错误</h2><p id="9c04" class="pw-post-body-paragraph kg kh it ki b kj mf kl km kn mg kp kq kr mx kt ku kv my kx ky kz mz lb lc ld im bi translated">我在尝试安装Elasticsearch图表时遇到了<a class="ae le" href="https://github.com/ubuntu/microk8s/issues/749" rel="noopener ugc nofollow" target="_blank">这个问题</a>。解决方法是在主节点上执行以下操作:</p><pre class="nd ne nf ng gt nh mw ni nj aw nk bi"><span id="3c5e" class="nl lg it mw b gy nm nn l no np">echo "--allow-privileged" | sudo tee -a /var/snap/microk8s/current/args/kube-apiserver</span><span id="677b" class="nl lg it mw b gy ob nn l no np"># restart microk8s for changes to take effect<br/>sudo microk8s stop &amp;&amp; sudo microk8s start</span></pre><h2 id="d16f" class="nl lg it bd lh nq nr dn ll ns nt dp lp kr nu nv lt kv nw nx lx kz ny nz mb oa bi translated">无法从pod连接到互联网</h2><p id="ee8c" class="pw-post-body-paragraph kg kh it ki b kj mf kl km kn mg kp kq kr mx kt ku kv my kx ky kz mz lb lc ld im bi translated">默认情况下，内部DNS服务器指向Google的DNS服务器。如果，不管什么原因，这对你不起作用，你将需要<a class="ae le" href="https://microk8s.io/docs/addon-dns" rel="noopener ugc nofollow" target="_blank">更新CoreDNS配置</a>以允许你的pod访问互联网。</p><pre class="nd ne nf ng gt nh mw ni nj aw nk bi"><span id="76ae" class="nl lg it mw b gy nm nn l no np">kubectl edit -n kube-system configmaps coredns</span><span id="e1bb" class="nl lg it mw b gy ob nn l no np"># edit the configmap by replacing the line that starts with "forward" under data.Corefile with "forward . /etc/resolv.conf"<br/># if this doesn't work, you might try manually replacing Google's 8.8.8.8 and 8.8.4.4 servers with your own DNS servers<br/># save and close, the configuration should get reloaded</span></pre><h1 id="51ca" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">后续步骤</h1><p id="1bc4" class="pw-post-body-paragraph kg kh it ki b kj mf kl km kn mg kp kq kr mx kt ku kv my kx ky kz mz lb lc ld im bi translated">这里有一些我没有提到的对这个系统的改进:</p><ul class=""><li id="5890" class="md me it ki b kj kk kn ko kr na kv nb kz nc ld mk ml mm mn bi translated">如果<a class="ae le" href="https://code.visualstudio.com" rel="noopener ugc nofollow" target="_blank"> VS Code </a>是您的首选IDE，那么<a class="ae le" href="https://code.visualstudio.com/docs/remote/ssh" rel="noopener ugc nofollow" target="_blank">远程SSH开发</a>让与您的远程代码交互变得轻而易举！</li><li id="01d3" class="md me it ki b kj mo kn mp kr mq kv mr kz ms ld mk ml mm mn bi translated">在本地机器上配置Helm和kubectl客户机，通过导出前面<a class="ae le" href="https://dev.to/musabhusaini/remote-development-with-multi-node-microk8s-cluster-and-scaffold-4o1d#kubectl" rel="noopener ugc nofollow" target="_blank">描述的kubeconfig文件</a>连接到远程集群。这将允许您在不离开本地机器的情况下存储代码并与集群交互。</li><li id="2458" class="md me it ki b kj mo kn mp kr mq kv mr kz ms ld mk ml mm mn bi translated">您甚至可以尝试将您的构建卸载到远程Docker主机，而不是本地构建</li></ul><p id="cdc1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">希望你玩得开心！</p></div><div class="ab cl oc od hx oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="im in io ip iq"><p id="02fe" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="oj">原载于2020年4月15日</em><a class="ae le" href="https://dev.to/musabhusaini/remote-development-with-multi-node-microk8s-cluster-and-scaffold-4o1d" rel="noopener ugc nofollow" target="_blank"><em class="oj">https://dev . to</em></a><em class="oj">。</em></p></div></div>    
</body>
</html>