<html>
<head>
<title>How I handle time-based events in serverless architecture</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我如何在无服务器架构中处理基于时间的事件</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-i-handle-time-based-events-in-serverless-architecture-30a8155a712?source=collection_archive---------2-----------------------#2020-03-18">https://levelup.gitconnected.com/how-i-handle-time-based-events-in-serverless-architecture-30a8155a712?source=collection_archive---------2-----------------------#2020-03-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><h1 id="e72b" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">无服务器是一个事件驱动的世界</h1><p id="d088" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">不像几年前，当我们都将长期运行的守护程序作为服务器时，我们正在进入一个无服务器时代，一切都由事件触发。</p><p id="a8c8" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">这是显而易见的，如果你认为正常的网站流量。用户命中你网站的URL/API端点，API网关触发Lambda函数，Lambda再触发DynamoDB更新/检索数据，一切从用户开始。</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi lr"><img src="../Images/1183b2df3a270a14b8bba796dbfa2417.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uSzPRyRGamtWrkAzD7V1EQ.png"/></div></div><figcaption class="md me gj gh gi mf mg bd b be z dk translated">通用的无服务器架构。一切从用户动作开始</figcaption></figure><p id="f01a" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">然而，如果您的系统足够大，您将总是面临需要预定动作的情况。对于这些情况，我们如何采用无服务器架构？</p><h1 id="f1e6" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">我过去的项目:电动汽车充电器控制系统</h1><p id="e231" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我过去的一个项目是建立一个基于云的系统来远程控制电动汽车充电器。主要功能是定时每次充电会话的持续时间，并在持续时间到期时停止充电器(用户必须选择持续时间并在会话开始前支付)。</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi mh"><img src="../Images/341d8fe9837cb055822e71dde96263fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0oVl27nJ9s6U6fShoRwVSw.png"/></div></div></figure><p id="cd9e" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">我的设计很简单。用户通过API网关与系统进行交互。Lambda函数处理逻辑并通过SQS队列向现场Raspberry Pi发送命令，Raspberry Pi然后通过现场LAN控制充电器。</p><p id="0653" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">主要问题是，当会话过期时，我应该如何触发事件？如果我托管一个经典服务器，我可以每分钟运行一个CRON作业。或者极端地，我可以运行一个无限循环来检查每秒是否有任何过期的会话。</p><pre class="ls lt lu lv gt mi mj mk ml aw mm bi"><span id="0731" class="mn jr it mj b gy mo mp l mq mr">while True:<br/>    terminate_expired_sessions()<br/>    time.sleep(1)</span></pre><p id="3227" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">在无服务器架构中呢？我们做什么呢</p><h1 id="1ebe" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">选项1: CRON</h1><p id="58c6" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">回到过去，我们使用CRON来做基于时间的工作，为什么我们不用同样的方法呢？在AWS中，我们可以使用CloudWatch事件规则定期触发Lambda函数。在Azure中，我们可以设置一个带有定时器触发器的功能App。</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi ms"><img src="../Images/b24e7e66367a09d45cc9e1798dd6f5e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qqxfKU-YpwN9NxvJYZwZqw.png"/></div></div><figcaption class="md me gj gh gi mf mg bd b be z dk translated">我们可以使用CloudWatch事件规则定期触发Lambda</figcaption></figure><p id="9a92" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">权衡的结果是您希望计划功能运行的频率。如果时间间隔太长，您将无法精确安排事件。如果太短，您可能会过于频繁地调用该函数，但什么也不做。</p><p id="bef5" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">另一个问题是你不能设置短于1分钟的时间间隔。对我来说，这没什么大不了的，因为多给客户一分钟也不是什么大损失，这仍然是可行的。</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi mt"><img src="../Images/270d27cca2c750a2528d429758ebbf1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a6R1PmPVGUZgGMzuLtGLsg.png"/></div></div><figcaption class="md me gj gh gi mf mg bd b be z dk translated">像CRON一样，我们不能将间隔设置为小于一分钟</figcaption></figure><h1 id="90ee" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">选项2:等待</h1><p id="fe7e" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">如果CloudWatch事件规则无法实现小于一分钟的精度，那么在Lambda函数内部控制它怎么样？</p><p id="9dcb" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">你可能会认为让这个功能等待整整2个小时的充电时间只是为了终止它是疯狂的。</p><p id="11d7" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">如果我们使用选项1来调度一个1分钟的CRON作业，以检查在下一分钟内是否有任何即将过期的会话，并让函数等到确切的终止时间，这样会怎么样？</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi mu"><img src="../Images/1c856edc130ff2547601cd24552ebfbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nDbwWkglYRtJ2BJKi2_Lfg.png"/></div></div></figure><p id="bdfe" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">这是托管服务器中的一种常见方法。让进程等待比调度任务更容易。此外，让一个进程等待根本不会损害系统，因为我们已经提供了资源，等待进程不会消耗太多资源。</p><h2 id="6c8f" class="mn jr it bd js mv mw dn jw mx my dp ka kz mz na ke ld nb nc ki lh nd ne km nf bi translated">反模式</h2><p id="4df1" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">然而，在Lambda中这样做使我们陷入两种反模式:1)长时间运行的任务，和2)不使函数忙碌。</p><p id="42c1" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">假设AWS Lambda允许每个区域有多达1000个并发。如果我们用它来运行长时间运行的任务，我们会很快耗尽极限。想象一下，如果下一分钟有600个收费会话到期，我们调用600个函数来等待终止时间。目前，我们只剩下400个并发请求来满足其他请求。</p><p id="bcee" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">更糟糕的是，我们在利用执行时间什么都不做。Lambda函数每100ms充电一次，这使得该架构更具成本效益。然而，通过调用函数来等待，我们失去了这种好处。</p><h1 id="a3de" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">选项3:阶跃函数</h1><p id="b6c6" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">人们建议的另一个选择是使用<a class="ae ng" href="https://aws.amazon.com/step-functions/" rel="noopener ugc nofollow" target="_blank"> AWS阶跃函数</a>。如果你遇到一些需要协调的动作，这是一个很棒的工具。</p><p id="25ff" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">例如，如果您正在构建一个旅游预订系统，那么您已经构建了预订酒店房间和航班的功能。如果您分别调用这两个函数，您如何确保它们都成功？我相信您不希望您的客户乘飞机到达目的地后发现他们的酒店预订不成功。</p><p id="39b6" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">通过使用阶跃函数，我们可以很容易地实现一个saga模式(这是Chris Richardson的一个很棒的<a class="ae ng" href="https://youtu.be/txlSrGVCK18" rel="noopener ugc nofollow" target="_blank">演讲</a>)。您可以定义状态转换的逻辑。例如，如果航班预订成功，请继续预订酒店房间。如果失败了，就去取消航班。</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi nh"><img src="../Images/d58276d6a9adb39af002bc5716716e6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VaM6nJGfs3xAEpqo-9-J3w.png"/></div></div><figcaption class="md me gj gh gi mf mg bd b be z dk translated">用阶跃函数实现saga模式</figcaption></figure><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/fdffe2e1cf76ca8fbae4618d39e75469.png" data-original-src="https://miro.medium.com/v2/resize:fit:676/format:webp/1*W8T36ETBPJqmDy8sv8N1sA.png"/></div><figcaption class="md me gj gh gi mf mg bd b be z dk translated">我们可以在阶跃函数中加入等待时间</figcaption></figure><p id="6f58" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">当然，我们可以在阶跃函数中添加等待时间。例如，如果航空公司不允许你取消新预订的航班，你可以在取消之前增加一段等待时间。</p><h2 id="f870" class="mn jr it bd js mv mw dn jw mx my dp ka kz mz na ke ld nb nc ki lh nd ne km nf bi translated">这是有代价的</h2><p id="2043" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">阶跃函数是如此强大的工具，它的<a class="ae ng" href="https://aws.amazon.com/step-functions/pricing/" rel="noopener ugc nofollow" target="_blank">也不便宜</a>。每1000次状态转换花费0.025美元。</p><p id="bb46" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">在我的情况下，我只是希望充电器在某个时间停止，不需要复杂的协调，步进功能似乎是一个大材小用。</p><h1 id="de83" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">选项4: CRON + SQS</h1><p id="45c7" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">最后我想出了这个解决方案:用CloudWatch Event实现CRON和SQS秒精度触发事件。</p><p id="e3cd" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">它结合了前三个选项，使用CloudWatch事件来调度CRON作业，然后创建一个等待期来在准确的时间终止收费会话。我没有使用Lambda函数本身或阶跃函数，而是选择SQS来实现等待期。</p><p id="a4fb" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">首先，我创建了一个SQS队列来存储那些预定的操作。我没有使用现有的命令队列，因为我不想直接推出命令。我想执行一个函数来做最后的检查，看看在等待期间是否有任何变化。例如，用户可以将更多小时添加到充电会话中。在这种情况下，我不希望系统终止充电会话。</p><p id="58f9" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">AWS SQS允许消息在15分钟后发送<a class="ae ng" href="https://docs.aws.amazon.com/AWSSimpleQueueService/latest/APIReference/API_SendMessage.html#API_SendMessage_RequestParameters" rel="noopener ugc nofollow" target="_blank">，所以我将find _ expiring _ sessions函数安排为每15分钟一次。</a></p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi nj"><img src="../Images/0091a8eeb2fa682eee3555e0aa34bf21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*REC_XOuO7XnuBPFxYrO34w.png"/></div></div><figcaption class="md me gj gh gi mf mg bd b be z dk translated">使用CloudWatch事件每15分钟触发一次find _ expiring _ sessions</figcaption></figure><pre class="ls lt lu lv gt mi mj mk ml aw mm bi"><span id="5d90" class="mn jr it mj b gy mo mp l mq mr">def find_expiring_sessions():<br/>    fifteen_minute_later = <!-- -->datetime.now() \<br/>        +<!-- --> timedelta(minutes = 15)<br/>    expiring_sessions = Sessions.filter(<br/>        expire_time__lte = fifteen_minute_later,<br/>        expire_time__gt = <!-- -->datetime.now()<br/>    <!-- -->)</span><span id="0202" class="mn jr it mj b gy nk mp l mq mr">    for expiring_session in expiring_sessions:<br/>        sqs_client<strong class="mj iu">.</strong>send_message(<br/>            QueueUrl='xxxxxxxxxx',<br/>            DelaySeconds=expiring_session.expire_time-<!-- -->datetime.now(),<br/>            <!-- -->MessageBody=expiring_session.id<br/>        )</span></pre><p id="2d22" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">在该函数中，我找出了在未来15分钟内即将到期的所有充电会话。然后，对于每个会话，我将一条SQS消息按其自己的延迟时间推入队列。</p><p id="325f" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">因为SQS是基于拉的，所以由队列触发的函数需要权限来拉消息。所以我在handle _ expiring _ session函数中附加了一个策略</p><pre class="ls lt lu lv gt mi mj mk ml aw mm bi"><span id="7ab9" class="mn jr it mj b gy mo mp l mq mr">{<br/>    "Version": "2012-10-17",<br/>    "Statement": [<br/>        {<br/>            "Effect": "Allow",<br/>            "Action": [<br/>                "sqs:DeleteMessage",<br/>                "sqs:ReceiveMessage",<br/>                "sqs:GetQueueAttributes"<br/>            ],<br/>            "Resource": "arn:aws:sqs:us-east-1:111111111111:ExpireSessionWaitQueue"<br/>        }<br/>    ]<br/>}</span></pre><p id="f185" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">然后，我将一个触发器从队列配置到handle _ expiring _ session函数</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi nl"><img src="../Images/fa34c97c15f1b6835403ab515f0971d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zSznKRU4lhBIxkdxsbpSGQ.png"/></div></div><figcaption class="md me gj gh gi mf mg bd b be z dk translated">配置SQS以触发Lambda功能</figcaption></figure><p id="1286" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">现在，每当收费时间到期时，我的handle _ expiring _ session将被触发，它可以立即执行终止过程。</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/4345a167244b9c3eb7c700cd3356464a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1198/format:webp/1*KyekQZBZ9BCETe3V8dNK4w.png"/></div><figcaption class="md me gj gh gi mf mg bd b be z dk translated">克朗+ SQS建筑设计</figcaption></figure><h1 id="78d4" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">比较不同的选项</h1><p id="4bb2" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我将使用以下场景来比较这4个选项:</p><ol class=""><li id="6cb1" class="nn no it kq b kr lm kv ln kz np ld nq lh nr ll ns nt nu nv bi translated">每小时平均终止240个会话</li><li id="0037" class="nn no it kq b kr nw kv nx kz ny ld nz lh oa ll ns nt nu nv bi translated">所有会话在第30秒终止(例如14:02:30)</li><li id="0309" class="nn no it kq b kr nw kv nx kz ny ld nz lh oa ll ns nt nu nv bi translated">实际执行需要500毫秒和128兆内存</li><li id="e3b4" class="nn no it kq b kr nw kv nx kz ny ld nz lh oa ll ns nt nu nv bi translated">所有充电会话的持续时间是相等的</li></ol><p id="e4d8" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">对于选项1，每小时将有60次CRON调用。每次调用执行一次Lambda函数。因为端接是成批执行的，所以我们可以假设所需的时间仍然是500毫秒。</p><p id="23b3" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">选项1的成本将是:每小时0.00006美元(60次CloudWatch事件)+0.000012美元(60次Lambda执行)+0.00006249美元(30秒总执行时间)= $0.00013449美元。</p><p id="161e" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">对于选项2，每小时将有60次CRON调用。每次调用执行4个Lambda函数(每分钟4个终止)，这些函数将执行30秒。</p><p id="b26d" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">选项2的成本将是:每小时0.00006美元(60次CloudWatch事件)+ $0.000048美元(240次Lambda执行)+ $0.01524756美元(240 x 30.5s次Lambda执行时间)= $0.01535556美元。</p><p id="3632" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">对于备选方案3。假设Step Functions允许执行时间长达1年，我假设我们不必使用CRON，只需从整个会话的开始到结束安排终止操作。每小时有240个会话，因此每小时有240个状态转换。</p><p id="90bc" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">选项3的成本将是:0.006美元(240个状态转换)</p><p id="2d10" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">对于选项4，将有4次CRON调用(间隔15分钟)，每次调用生成240个SQS消息(每小时240个终止)，每个消息最终将调用终止函数。</p><p id="20df" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">选项4的成本将为:0.000004美元(4个CloudWatch事件)+0.000096美元(240条SQS消息)+0.000048美元(240次Lambda执行)+0.00024996美元(240 x 500ms毫秒执行时间)= $0.00039796美元</p><figure class="ls lt lu lv gt lw"><div class="bz fp l di"><div class="ob oc l"/></div><figcaption class="md me gj gh gi mf mg bd b be z dk translated">4个不同选项的比较</figcaption></figure><p id="e3a2" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">在这些选项中，使用Lambda等待是最糟糕的一个，它的成本很高，1000个并发配额也限制了它的可伸缩性。它唯一的优点是易于使用。你可以简单地在你的代码中以你想要的方式实现。</p><p id="5099" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">Simple CRON便宜且可扩展，缺点是它只能提供1分钟的精度。</p><p id="71e8" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">阶跃函数对于处理复杂的协调情况很好，但是对于解决简单的基于时间的事件来说就有点大材小用了。</p><p id="63c7" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">如果您希望以秒级精度安排基于时间的事件，CRON + SQS将是最合适的选择。</p></div></div>    
</body>
</html>