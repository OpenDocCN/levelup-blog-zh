<html>
<head>
<title>Node.js Packages I Use In Every Project</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我在每个项目中使用的Node.js包</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/node-js-packages-i-use-in-every-project-74bc2cbbc716?source=collection_archive---------4-----------------------#2022-03-24">https://levelup.gitconnected.com/node-js-packages-i-use-in-every-project-74bc2cbbc716?source=collection_archive---------4-----------------------#2022-03-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/8ebf06dea4261e8da9d86b4355c93d3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mg1c3jDfknA9Cc7A8KCK9g.jpeg"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">原图片由<a class="ae jg" href="https://unsplash.com/@jiaweizhao" rel="noopener ugc nofollow" target="_blank">赵家伟</a>在<a class="ae jg" href="https://unsplash.com/photos/W-ypTC6R7_k" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上</figcaption></figure><div class=""/><p id="5dd5" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以及为什么你也应该使用它们！</p><p id="d4ae" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我的职业生涯中，可能和你们中的许多人一样，我创建了几十个新的JavaScript项目，既有个人使用的，也有专业使用的。和所有事情一样，一旦你经常做某事，你就建立了共同的模式、惯例和最佳实践。在这篇文章中，我想谈谈我每次使用的最好的Node.js包，以及它们如何帮助您减少开发时间并立即扩展JavaScript应用程序的性能。</p><p id="df62" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个列表中的包适用于几乎所有的JavaScript项目，而不是特定于React、Angular、Express、NestJS等框架或库。我还排除了实用函数库，如<a class="ae jg" href="https://lodash.com/" rel="noopener ugc nofollow" target="_blank"> lodash </a>或<a class="ae jg" href="https://ramdajs.com/" rel="noopener ugc nofollow" target="_blank"> rambda </a>，或日期/时间转换库，如<a class="ae jg" href="https://momentjs.com/" rel="noopener ugc nofollow" target="_blank"> momentjs </a>或<a class="ae jg" href="https://date-fns.org/" rel="noopener ugc nofollow" target="_blank"> date-fns </a>。我已经排除了像<a class="ae jg" href="https://webpack.js.org/" rel="noopener ugc nofollow" target="_blank"> Webpack </a>、<a class="ae jg" href="https://esbuild.github.io/" rel="noopener ugc nofollow" target="_blank"> ESBuild </a>、<a class="ae jg" href="https://rollupjs.org/" rel="noopener ugc nofollow" target="_blank"> Rollup </a>或<a class="ae jg" href="https://parceljs.org/" rel="noopener ugc nofollow" target="_blank">package</a>这样的捆绑器，因为它们对于您正在处理的项目类型来说是非常特定的。相反，我试图特别关注我用于<strong class="ki jk">项目设置</strong>、<strong class="ki jk">开发</strong>、<strong class="ki jk">构建</strong>和<strong class="ki jk">维护</strong>的包，这些你以前可能会忽略。虽然这里列出的一些你肯定已经知道了，但是其他的对你来说也是新的。如果您不同意某个选择或有其他建议，请告诉我！</p><h1 id="4209" class="le lf jj bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">代码格式</h1><p id="18de" class="pw-post-body-paragraph kg kh jj ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">让我们从基础开始:<em class="mh">写好代码</em> ( <a class="ae jg" rel="noopener ugc nofollow" target="_blank" href="/7-simple-attributes-of-good-code-70c24cd75ad7">不管那是什么意思</a>)。当您在团队中工作时，有时很难保持代码库的格式和编码风格一致。毕竟有些人更喜欢制表符而不是空格(怪物！)，有些用单引号表示字符串，有些用双引号。有时在JavaScript语句的末尾有一个分号，等等。这就是代码格式化和验证库的用武之地！有些工具甚至能够超越简单的格式和样式，而是能够积极地帮助您编写更好、更快、更安全的代码。</p><p id="94a8" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是我在每个JavaScript项目中使用的几个例子:</p><h2 id="cd2c" class="mi lf jj bd lg mj mk dn lk ml mm dp lo kr mn mo ls kv mp mq lw kz mr ms ma mt bi translated">较美丽</h2><p id="de14" class="pw-post-body-paragraph kg kh jj ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><a class="ae jg" href="https://prettier.io/" rel="noopener ugc nofollow" target="_blank">漂亮的</a>是一个命令行工具，也作为Visual Studio代码和其他ide的<a class="ae jg" href="https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode" rel="noopener ugc nofollow" target="_blank">扩展而存在。它会自动格式化你的代码，并强制执行一个通用的编码风格(想想制表符和空格，引用风格等等)。).</a></p><p id="ad7a" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">漂亮是固执己见的，因此已经内置了许多格式规则，不一定需要配置。但是它和<a class="ae jg" href="https://editorconfig.org" rel="noopener ugc nofollow" target="_blank"> EditorConfig </a>一起工作也很好，这是一个优势，因为许多ide支持开箱即用的<a class="ae jg" href="https://editorconfig.org" rel="noopener ugc nofollow" target="_blank"> EditorConfig </a>格式选项，即使你没有安装更漂亮的扩展。以下是我目前正在做的项目中的一个，供参考:</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="b6ce" class="mi lf jj mz b gy nd ne l nf ng"># Editor configuration, see <a class="ae jg" href="https://editorconfig.org" rel="noopener ugc nofollow" target="_blank">https://editorconfig.org</a><br/>root = true</span><span id="a1bb" class="mi lf jj mz b gy nh ne l nf ng">[*]<br/>charset = utf-8<br/>indent_style = space<br/>indent_size = 2<br/>insert_final_newline = true<br/>trim_trailing_whitespace = true<br/>max_line_length = 120</span><span id="8a81" class="mi lf jj mz b gy nh ne l nf ng">[*.ts]<br/>quote_type = single</span><span id="471e" class="mi lf jj mz b gy nh ne l nf ng">[*.md]<br/>max_line_length = off<br/>trim_trailing_whitespace = false</span></pre><h2 id="b0de" class="mi lf jj bd lg mj mk dn lk ml mm dp lo kr mn mo ls kv mp mq lw kz mr ms ma mt bi translated">埃斯林特</h2><figure class="mu mv mw mx gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ni"><img src="../Images/03bafa61013c1e8c9a62011c485a5ce6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Y4Bn7WRxOP4ZCsuc.jpg"/></div></div></figure><p id="8187" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我这么说吧:如果你不把<a class="ae jg" href="https://eslint.org/" rel="noopener ugc nofollow" target="_blank"> ESLint </a>和JavaScript <a class="ae jg" href="https://www.youtube.com/watch?v=GaAUS0GsG_M" rel="noopener ugc nofollow" target="_blank">一起使用，那你就做错了</a>！如果你不熟悉linter的功能，可以从ESLint主页上下载:<strong class="ki jk">查找并修复你的JavaScript代码中的问题</strong>。</p><p id="eab4" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">ESLint是最受欢迎的JavaScript linter，它会自动发现并自动修复许多常见的代码错误。更好的是，ESLint可以通过插件扩展为<a class="ae jg" href="https://github.com/typescript-eslint/typescript-eslint" rel="noopener ugc nofollow" target="_blank">添加对TypeScript </a> ( <code class="fe nj nk nl mz b">@typescript-eslint/eslint-plugin</code>和<code class="fe nj nk nl mz b">@typescript-eslint/parser</code>)、<a class="ae jg" href="https://www.npmjs.com/package/eslint-plugin-json" rel="noopener ugc nofollow" target="_blank">格式JSON文件</a> ( <code class="fe nj nk nl mz b">eslint-plugin-json</code>)的支持，并且<a class="ae jg" href="https://github.com/prettier/eslint-plugin-prettier" rel="noopener ugc nofollow" target="_blank">还可以使用<code class="fe nj nk nl mz b">eslint-plugin-prettier</code>和<code class="fe nj nk nl mz b">eslint-config-prettier</code>插件与更漂亮的</a>很好地集成。</p><p id="472f" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">写关于ESLint的文章很容易就能写满一篇博文。要获得流行插件的完整列表，请查看<a class="ae jg" href="https://github.com/dustinspecker/awesome-eslint" rel="noopener ugc nofollow" target="_blank"> Awesome ESLint </a>列表。</p><h2 id="55df" class="mi lf jj bd lg mj mk dn lk ml mm dp lo kr mn mo ls kv mp mq lw kz mr ms ma mt bi translated">StandardJS和XO</h2><p id="79b8" class="pw-post-body-paragraph kg kh jj ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">这里对<a class="ae jg" href="https://standardjs.com/" rel="noopener ugc nofollow" target="_blank"> StandardJS </a>和<a class="ae jg" href="https://github.com/xojs/xo" rel="noopener ugc nofollow" target="_blank"> XO </a>的一个快速标注:你可以使用一个一体化的工具，比如<a class="ae jg" href="https://standardjs.com/" rel="noopener ugc nofollow" target="_blank"> StandardJS </a>或<a class="ae jg" href="https://github.com/xojs/xo" rel="noopener ugc nofollow" target="_blank"> XO </a>，而不是单独使用Prettier和ESLint。两者都建立在ESLint的基础上，可以非常快速和容易地将格式和一致的编码风格应用到新项目中，而无需手动添加大量插件和配置。归根结底，选择哪一个取决于你的项目需要多大的灵活性，你喜欢什么样的“默认”风格，以及<a class="ae jg" href="https://standardjs.com/awesome.html#editor-plugins" rel="noopener ugc nofollow" target="_blank">你的编辑器是否支持它</a>。</p><h2 id="f72a" class="mi lf jj bd lg mj mk dn lk ml mm dp lo kr mn mo ls kv mp mq lw kz mr ms ma mt bi translated">强壮的</h2><p id="0b62" class="pw-post-body-paragraph kg kh jj ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">如果没有人去执行，规则还有什么价值？这就是<a class="ae jg" href="https://typicode.github.io/husky/#/" rel="noopener ugc nofollow" target="_blank">哈士奇</a>的用武之地！Husky将<a class="ae jg" href="https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks" rel="noopener ugc nofollow" target="_blank"> git挂钩</a>添加到您的项目中，无论开发人员何时提交或推送代码，它都可以用来运行ESLint和Prettier above。通过这种方式，您可以确保提交到您的存储库中的任何代码都满足您之前定义的所有质量需求。</p><p id="aa75" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通常，我喜欢设置Husky在每个<code class="fe nj nk nl mz b">git commit</code>运行ESLint和Prettier，并在每个<code class="fe nj nk nl mz b">git push</code>之前执行单元测试。毕竟，我喜欢遵循尽早提交、经常提交的策略，并且不想在每次提交时都运行全面的单元测试，从而减慢我的团队。</p><h2 id="710f" class="mi lf jj bd lg mj mk dn lk ml mm dp lo kr mn mo ls kv mp mq lw kz mr ms ma mt bi translated">皮棉阶段</h2><p id="f34a" class="pw-post-body-paragraph kg kh jj ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">当ESLint和Husky一起使用时，每当您提交一个小的更改时，您很快就会对反复Lint整个项目所花费的时间感到恼火。<a class="ae jg" href="https://github.com/okonet/lint-staged" rel="noopener ugc nofollow" target="_blank"> Lint-Staged </a>来救援了！直接调用Lint-Staged而不是ESLint将确保只有您提交的代码<em class="mh">更改</em>被格式化和Lint化，而不是整个代码库。</p><p id="cbaa" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了更漂亮地和ESLint一起运行，在<code class="fe nj nk nl mz b">package.json</code>中将<code class="fe nj nk nl mz b">lint-staged</code>添加到您的开发依赖项中，并通过添加一个<code class="fe nj nk nl mz b">lint-staged</code>部分来配置它:</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="5d3a" class="mi lf jj mz b gy nd ne l nf ng">"lint-staged": {<br/> "src/*.{js,ts,md,yml,yaml,json,html,scss}": [<br/>   "prettier --write",<br/>   "eslint --cache --fix"<br/>  ]<br/>}</span></pre><h1 id="296b" class="le lf jj bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">脚本</h1><p id="1b1d" class="pw-post-body-paragraph kg kh jj ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">在许多情况下，您需要编写一些小的脚本片段来执行一些操作。以下是我更喜欢使用的工具:</p><h2 id="e07d" class="mi lf jj bd lg mj mk dn lk ml mm dp lo kr mn mo ls kv mp mq lw kz mr ms ma mt bi translated">里姆拉夫和Mkdirp</h2><figure class="mu mv mw mx gt iv gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/036f4f07807aa2c11b7bf872f91c9bfa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*UmBy4Iruh1wYf_lN.png"/></div></figure><p id="bd51" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当您的开发团队同时使用Windows和macOS或Linux时，有时很难确保脚本在两个系统上都工作。想想macOS/Linux上的<code class="fe nj nk nl mz b">rm -rf</code>和Windows上的<code class="fe nj nk nl mz b">rmdir /s</code>就知道了。这两个库通过统一如何创建(<a class="ae jg" href="https://github.com/substack/node-mkdirp" rel="noopener ugc nofollow" target="_blank"> Mkdirp </a>)和移除(<a class="ae jg" href="https://github.com/isaacs/rimraf" rel="noopener ugc nofollow" target="_blank"> RimRaf </a>)文件夹层次结构帮了大忙。例如，在我执行web应用程序的干净重建之前，我用它来清理和重新创建我的<code class="fe nj nk nl mz b">dist</code>或<code class="fe nj nk nl mz b">output</code>文件夹。与<code class="fe nj nk nl mz b">webpack</code>一起，你的<code class="fe nj nk nl mz b">package.json</code>可能看起来像这样:</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="1d02" class="mi lf jj mz b gy nd ne l nf ng">"scripts": {<br/>  "prebuild": "rimraf dist",<br/>  "build": "webpack --config build/webpack.config.js",<br/>}</span></pre><p id="2d90" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe nj nk nl mz b">npm</code>在<code class="fe nj nk nl mz b">build</code>脚本之前自动调用<code class="fe nj nk nl mz b">prebuild</code>脚本。在这个例子中，我们删除了Webpack的<code class="fe nj nk nl mz b">dist</code>输出文件夹的内容，以移除先前构建中遗留的文件。</p><h2 id="f807" class="mi lf jj bd lg mj mk dn lk ml mm dp lo kr mn mo ls kv mp mq lw kz mr ms ma mt bi translated">跨环境</h2><p id="2658" class="pw-post-body-paragraph kg kh jj ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">当您的开发团队同时使用不同的操作系统时，处理环境变量也同样麻烦。<a class="ae jg" href="https://github.com/kentcdodds/cross-env" rel="noopener ugc nofollow" target="_blank"> Cross-Env </a>通过提供统一的CLI来设置环境变量并与之交互，解决了这个问题。来自<code class="fe nj nk nl mz b">cross-env</code>网站的例子展示了这一点:</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="fa45" class="mi lf jj mz b gy nd ne l nf ng">"scripts": {<br/>  "build": "cross-env NODE_ENV=production webpack --config build/webpack.config.js"<br/>}</span></pre><p id="e7b9" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请注意，<code class="fe nj nk nl mz b">cross-env</code>包处于维护模式，在GitHub中被标记为“archived”。不过，<a class="ae jg" href="https://github.com/kentcdodds/cross-env/issues/257" rel="noopener ugc nofollow" target="_blank">这是好事</a>！这意味着该工具被认为是功能完整和稳定的(理解为:“生产就绪”)，不会对其代码库进行进一步的更改或添加。</p><h2 id="dbdc" class="mi lf jj bd lg mj mk dn lk ml mm dp lo kr mn mo ls kv mp mq lw kz mr ms ma mt bi translated">Is-CI和Is-Docker</h2><p id="1c5f" class="pw-post-body-paragraph kg kh jj ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">有些脚本应该只在本地运行，或者在持续集成环境中运行。为了帮助您轻松区分环境，请使用<a class="ae jg" href="https://github.com/watson/is-ci" rel="noopener ugc nofollow" target="_blank"> Is-CI </a>。如果CLI工具从GitHub操作或Azure管道等CI环境中运行，它会成功，否则会失败。因此，您可以使用它来保护您的脚本，如下所示:</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="7be3" class="mi lf jj mz b gy nd ne l nf ng">is-ci &amp;&amp; echo "This is a CI server" || echo "Not a CI server"</span></pre><p id="5d2e" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您使用上面的Husky，一个常见的模式是更新您在<code class="fe nj nk nl mz b">package.json</code>中的<code class="fe nj nk nl mz b">prepare</code>脚本，以便仅在您<em class="mh">而非</em>运行在CI服务器上时安装Husky:</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="e973" class="mi lf jj mz b gy nd ne l nf ng">"scripts": {<br/>  "prepare": "is-ci || husky install"<br/>}</span></pre><p id="dd60" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Is-Docker 以同样的方式工作，但是检查你是否在Docker容器中运行。</p><h2 id="e0e2" class="mi lf jj bd lg mj mk dn lk ml mm dp lo kr mn mo ls kv mp mq lw kz mr ms ma mt bi translated">兼侍候</h2><p id="a7e8" class="pw-post-body-paragraph kg kh jj ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我想在本节中介绍的最后两个库非常适合彼此协同工作:<a class="ae jg" href="https://www.npmjs.com/package/concurrently" rel="noopener ugc nofollow" target="_blank">并发</a>和<a class="ae jg" href="https://github.com/jeffbski/wait-on" rel="noopener ugc nofollow" target="_blank">等待</a>。<a class="ae jg" href="https://www.npmjs.com/package/concurrently" rel="noopener ugc nofollow" target="_blank">并发</a>允许你并行启动几个任务。例如，如果你同时使用Webpack和Nodemon，你可以使用<code class="fe nj nk nl mz b">concurrently</code>同时启动它们:</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="9dda" class="mi lf jj mz b gy nd ne l nf ng">"scripts": {<br/>  "watch": "nodemon index.js",<br/>  "dev-server": "webpack-dev-server",<br/>  "start": "concurrently -k \"npm:watch\" \"npm:dev-server\""<br/>}</span></pre><p id="61f2" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Wait-On解决了问题的另一面:<a class="ae jg" href="https://github.com/jeffbski/wait-on#why" rel="noopener ugc nofollow" target="_blank">在继续执行脚本之前，等待特定任务完成</a>。例如，如果您使用<code class="fe nj nk nl mz b">concurrently</code>来启动数据库实例和后端服务，那么您可以使用<code class="fe nj nk nl mz b">wait-on</code>来确保数据库在尝试连接之前启动并运行:</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="643e" class="mi lf jj mz b gy nd ne l nf ng">"scripts": {<br/>  "start-db": "myDbServerCmd",<br/>  "start-api": "wait-on tcp:27017 &amp;&amp; myApiServerCmd",<br/>  "start": "concurrently -k \"npm:start-db\" \"npm:start-api\""<br/>}</span></pre><h1 id="db40" class="le lf jj bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">类型安全</h1><figure class="mu mv mw mx gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ni"><img src="../Images/c2cb0588d78120d9986380a92ebb39d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5Yv_ACW2vZRL4tPA.jpg"/></div></div></figure><p id="be42" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你读过我过去写的任何东西，我是打字稿的忠实支持者应该不是秘密。Medium 上有很多关于TypeScript如何让你的生活变得更简单的帖子，所以我不会在这里重复这些观点。</p><h2 id="b115" class="mi lf jj bd lg mj mk dn lk ml mm dp lo kr mn mo ls kv mp mq lw kz mr ms ma mt bi translated">类型同步</h2><p id="743d" class="pw-post-body-paragraph kg kh jj ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">即使您使用TypeScript，您可能也不知道一个叫做<a class="ae jg" href="https://www.npmjs.com/package/typesync" rel="noopener ugc nofollow" target="_blank"> typesync </a>的很酷的小工具，它可以自动为您所有的本地包找到缺少的TypeScript类型定义。安装新的NPM包后，你只需运行<code class="fe nj nk nl mz b">typesync</code>来添加你可能需要的任何类型定义:</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="901b" class="mi lf jj mz b gy nd ne l nf ng">npx typesync</span></pre><p id="6284" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">并且，如果它发现一些缺失的依赖项，它会自动将它们作为开发依赖项添加到您的<code class="fe nj nk nl mz b">package.json</code>中。只需再次运行<code class="fe nj nk nl mz b">npm install</code>来安装它们。已经节省了我很多时间了！</p><h1 id="7da6" class="le lf jj bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="5b8e" class="pw-post-body-paragraph kg kh jj ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">通过上面的列表，我希望我让您对Node.js包和工具有了一个很好的了解，我每天都在使用这些包和工具，并且在我从事的每个项目中都是如此。虽然他们中的一些可能是固执己见的选择，但他们都被证明对我来说一次又一次地工作良好和健壮。</p><p id="02a5" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，也要提醒一句:人们每天都发布新的NPM软件包，并不是所有的都是我所说的“生产就绪”。在向您的应用程序依赖项添加新的包时要小心，不要让它们显示出一个经过验证的跟踪记录。为了安全起见，请检查每周的高下载量、GitHub明星的数量、多个不同的贡献者以及最近的提交历史。即使这样<a class="ae jg" href="https://cyware.com/news/analyzing-the-deadly-rise-in-npm-package-hijacking-78b24364" rel="noopener ugc nofollow" target="_blank">你也不能百分百确定</a>。</p></div></div>    
</body>
</html>