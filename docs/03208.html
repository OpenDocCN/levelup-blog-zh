<html>
<head>
<title>Java Spring Boot First App</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java Spring Boot第一应用程序</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/java-spring-boot-62691414119c?source=collection_archive---------7-----------------------#2020-04-25">https://levelup.gitconnected.com/java-spring-boot-62691414119c?source=collection_archive---------7-----------------------#2020-04-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/1f0c91801609de0cf1143813f6116790.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TqCUNqPbnTi2WmuNDiD8Uw.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/s/photos/green-leaf?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae kc" href="https://unsplash.com/@mockupgraphics?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">实体模型图形</a>拍摄</figcaption></figure><p id="75b7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> Java | Spring Boot |春季数据JPA | H2数据库|百里香叶</strong></p><p id="735e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">到目前为止，我在web开发旅程中关注的是JavaScript及其框架。我经常对非JavaScript框架感到疑惑，但是，由于我需要集中精力掌握我的JavaScript技能，所以我从来没有去尝试过。在我能够开始使用新的框架之前，学习一种新的编程语言的必要性阻碍了我。</p><p id="1cf6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我作为初级web开发人员的第一份工作中，我必须熟悉ColdFusion和面向对象编程范例。(我写了一篇关于这个话题的四部分文章，你可以在这里找到<a class="ae kc" href="https://medium.com/@mikedietz724/oop-in-coldfusion-part-1-24163913facc" rel="noopener"/>)。</p><p id="fde1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于Java是面向对象和基于类的，我觉得我已经准备好开始我的Java之旅了。这个长达一周的过程，我在文章<em class="lb">中记录了Java </em>的第一步。我认为在开始使用Java Spring之前，先学习Java编程语言的基础知识是明智的。</p><p id="af59" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对我来说，在这个阶段，框架<em class="lb"> Java Spring </em>比作一个商场，一个接一个的商店，每个商店都提供不同的产品。<em class="lb"> Java Spring </em>为不同类型的项目提供了一个模块化的框架集合，<em class="lb"> Spring Boot </em>、<em class="lb"> Spring框架</em>、<em class="lb"> Spring数据</em>、<em class="lb"> Spring安全</em>、<em class="lb"> Spring for Android </em>、<em class="lb"> Spring Mobile </em>、<em class="lb"> Spring Web Services </em>等等，都是可以根据您的应用目的轻松组合的项目。我明白了为什么Java Spring被认为是一个成熟的企业框架。</p><p id="9afc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">关于学习Java Spring的资源，在<a class="ae kc" href="https://spring.io/" rel="noopener ugc nofollow" target="_blank"> spring.io </a>上有很好的文档，并提供了大量的示例代码和教程。你也不会有困难在互联网上找到你的问题的答案，因为社区是相当大的。</p><p id="b6fc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这篇文章只涉及Java Spring的非常非常小的一部分。它记录了一个web应用程序的设置，该应用程序将数据存储在关系数据库<em class="lb"> H2 </em>中，并使用模板引擎<em class="lb">百里香叶</em>将其呈现在浏览器中。</p><h2 id="8c1e" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">要求</h2><p id="7e40" class="pw-post-body-paragraph kd ke iq kf b kg lv ki kj kk lw km kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">对于Windows 10计算机上的此项目:</p><p id="701a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb"> Java软件</em></p><ul class=""><li id="9f9a" class="ma mb iq kf b kg kh kk kl ko mc ks md kw me la mf mg mh mi bi translated">从java.com<a class="ae kc" href="https://www.java.com/" rel="noopener ugc nofollow" target="_blank">下载<em class="lb"> Java SE开发工具包14 </em> 64位</a></li><li id="8e9f" class="ma mb iq kf b kg mj kk mk ko ml ks mm kw mn la mf mg mh mi bi translated">将您的<em class="lb">环境变量</em>的系统路径设置为【您的本地路径】\Java\jdk-14。</li><li id="06d4" class="ma mb iq kf b kg mj kk mk ko ml ks mm kw mn la mf mg mh mi bi translated">打开命令行(cmd)并用命令<br/> <code class="fe mo mp mq mr b">&gt; java -version</code>检查安装是否成功</li></ul><p id="e00f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">兼容Java的IDE </em> <br/>我使用的是<em class="lb"> Visual Studio代码</em>但是也有明确的Java集成开发环境，例如免费开源的<em class="lb"> Apache NetBeans IDE </em>、行业标准的<em class="lb"> IntelliJ IDEA、</em>或<em class="lb"> Eclipse </em>。<br/>在Visual Studio代码中，安装以下扩展:</p><ul class=""><li id="2a1a" class="ma mb iq kf b kg kh kk kl ko mc ks md kw me la mf mg mh mi bi translated">Java扩展包</li><li id="0189" class="ma mb iq kf b kg mj kk mk ko ml ks mm kw mn la mf mg mh mi bi translated">Spring Boot扩展包</li><li id="7bbd" class="ma mb iq kf b kg mj kk mk ko ml ks mm kw mn la mf mg mh mi bi translated">Java代码生成器</li></ul><p id="fe57" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Java Spring项目需要一组支持所请求特性的库和包。为此，需要一个项目管理工具。如果你熟悉JavaScript，你可能会马上想到<em class="lb"> yarn </em>或者<em class="lb"> npm </em>。对于我们的项目，我们选择<em class="lb"> Maven </em>作为项目管理工具。Maven有助于构建和管理你的Java项目。它创建了一个所谓的<em class="lb">POM</em>(Project-Object-Model)，其中包含项目的所有信息和配置细节，并保存在一个pom.xml文件中。</p><p id="831e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Spring提供了一个生成spring boot项目的初始化工具，名为<em class="lb"> Initializr。它使得建立目录结构、创建构建文件、配置依赖项等任务变得困难。非常容易。<em class="lb"> Initializr </em>可以在<a class="ae kc" href="http://start.spring.io" rel="noopener ugc nofollow" target="_blank"><em class="lb">start . spring . io</em></a><em class="lb">，</em>中访问，您可以在那里配置您的项目并生成一个需要提取并导入到spring项目中的zip文件，或者您可以直接在您的IDE中访问它，我正在这个项目中这样做。</em></p><p id="50d7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用组合键<em class="lb"> Ctrl + Shift + P，e</em>enter<code class="fe mo mp mq mr b">&gt;<em class="lb">Spring</em></code>打开<strong class="kf ir"> Visual Studio代码</strong>中的命令面板，进行如下选择:</p><ul class=""><li id="d02e" class="ma mb iq kf b kg kh kk kl ko mc ks md kw me la mf mg mh mi bi translated">选择<em class="lb"> Initialzr:创建一个Maven项目</em></li><li id="c65e" class="ma mb iq kf b kg mj kk mk ko ml ks mm kw mn la mf mg mh mi bi translated">指定项目语言:Java</li><li id="2ca5" class="ma mb iq kf b kg mj kk mk ko ml ks mm kw mn la mf mg mh mi bi translated">项目的输入组Id:com . project</li><li id="6da9" class="ma mb iq kf b kg mj kk mk ko ml ks mm kw mn la mf mg mh mi bi translated">项目的输入工件Id:first app</li><li id="4bbf" class="ma mb iq kf b kg mj kk mk ko ml ks mm kw mn la mf mg mh mi bi translated">指定Spring Boot版本:2.2.6(不要选择快照)<br/>选择依赖项:<br/> <em class="lb"> Spring Web </em>，<br/> <em class="lb"> Spring Data JPA，</em> <br/> <em class="lb"> H2数据库<br/> </em>回车</li><li id="16ef" class="ma mb iq kf b kg mj kk mk ko ml ks mm kw mn la mf mg mh mi bi translated">选择文件夹:webDev/Java/Spring(您的文件位置)</li><li id="c551" class="ma mb iq kf b kg mj kk mk ko ml ks mm kw mn la mf mg mh mi bi translated">生成到此文件夹</li></ul><p id="2d3c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过这几个步骤，我们的项目就建立起来了。</p><p id="869e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们开始之前，我想提一些一般性的注意事项。在这个项目的过程中，我们会遇到Java和Spring特有的概念，以及一般的计算机编程相关术语。深入研究每一个都需要太多的时间。对于从未听说过它们的人来说，我非常简短的解释是不够的，但我希望它们能在上下文中发挥作用，并鼓励你寻找更详细的解释。</p><p id="97b7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi ms translated"><span class="l mt mu mv bm mw mx my mz na di"> P </span> <strong class="kf ir">持久化</strong><br/>T5】瞬态数据在应用程序会话中创建，一旦应用程序关闭就不再可用。存储在永久存储器中的数据在应用程序或系统重启后可用，它已达到<em class="lb">持久性</em>状态。大部分数据通过<em class="lb"> JDBC </em> (Java数据库连接性)<em class="lb">序列化</em>、<em class="lb"> JCA </em> (Java EE连接器架构)、JPA等<em class="lb">持久化</em>在数据库中。</p><p id="8689" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi ms translated"><span class="l mt mu mv bm mw mx my mz na di"> J </span></p><p id="f14d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi ms translated">ibernate <br/> 是一个对象关系映射解决方案(ORM)。它会自动创建表和查询。不需要编写任何SQL来创建和查询表。</p><p id="969a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi ms translated"><span class="l mt mu mv bm mw mx my mz na di"> P </span><em class="lb">JavaBean就是POJO的一个例子。</em></p><p id="3172" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi ms translated"><span class="l mt mu mv bm mw mx my mz na di">一个</span> <strong class="kf ir">注释<br/> </strong>元数据，用<em class="lb"> @ </em>符号添加到类、方法、变量、参数和包中。例如，<em class="lb"> @Override </em>指示编译器检查匹配的方法。如果它不存在，将会抛出一个错误。如果父类中不存在<em class="lb"> @Override </em>注释，它将被自动创建。</p><p id="4acd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi ms translated"><span class="l mt mu mv bm mw mx my mz na di">P</span>T57】ackageT59】一组相似类型的类。有<em class="lb">内置的</em>包，例如java.lang、java.sql等。并且还有<em class="lb">用户自定义</em>包。如果您创建一个保存类的新文件夹，这将被视为一个新包。</p><p id="d2c2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi ms translated"><span class="l mt mu mv bm mw mx my mz na di"> O </span> <strong class="kf ir">重载</strong> <br/>在一个类中，你可以创建多个方法，都用相同的名字。他们只需要改变参数列表。这将创建同一方法的多个版本。根据所提供的参数列表，会自动选择相应的方法。<br/>重载也适用于构造函数。例如，Hibernate需要一个空的无参数构造函数，而我们需要实例化对象的参数列表。因此，我们有两个构造函数。</p><p id="b214" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意:所有注释、接口、包等。需要导入在类中使用的。Visual Studio Code IntelliSense将通过在关键字下加红色下划线来提醒您这一点，并给出适当的代码行作为建议，供您选择。</p><p id="4827" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个项目中，您将会遇到以下注释。注释提供了一些定义类、方法、变量、参数等的元数据。会被注释掉。它对其进行配置并提供一些特定的功能。</p><ul class=""><li id="4628" class="ma mb iq kf b kg kh kk kl ko mc ks md kw me la mf mg mh mi bi translated"><strong class="kf ir">@实体</strong>(多为表格，实体实例对应一个表格行)</li><li id="257d" class="ma mb iq kf b kg mj kk mk ko ml ks mm kw mn la mf mg mh mi bi translated"><strong class="kf ir"> @Id </strong>(指定实体的主键)</li><li id="f6a0" class="ma mb iq kf b kg mj kk mk ko ml ks mm kw mn la mf mg mh mi bi translated"><strong class="kf ir"> @GeneratedValue </strong>(指定值自动生成)</li><li id="1b12" class="ma mb iq kf b kg mj kk mk ko ml ks mm kw mn la mf mg mh mi bi translated"><strong class="kf ir"> @ManyToMany </strong>(通知Hibernate多对多关系)</li><li id="8d19" class="ma mb iq kf b kg mj kk mk ko ml ks mm kw mn la mf mg mh mi bi translated"><strong class="kf ir"> @JoinTable </strong>(通知Hibernate用属性创建一个连接表)</li><li id="1d41" class="ma mb iq kf b kg mj kk mk ko ml ks mm kw mn la mf mg mh mi bi translated"><strong class="kf ir"> @JoinColumn </strong>(将列标记为联接列)</li><li id="3ca0" class="ma mb iq kf b kg mj kk mk ko ml ks mm kw mn la mf mg mh mi bi translated"><strong class="kf ir"> @Controller </strong>(将类定义为控制器，调度程序将扫描映射的方法和@RequestMapping注释)</li><li id="40c3" class="ma mb iq kf b kg mj kk mk ko ml ks mm kw mn la mf mg mh mi bi translated"><strong class="kf ir">@组件</strong>(仅创建一个实例，在应用程序启动时自动创建)</li><li id="c13f" class="ma mb iq kf b kg mj kk mk ko ml ks mm kw mn la mf mg mh mi bi translated"><strong class="kf ir"> @Override </strong>(允许子类覆盖继承的方法)</li><li id="d82b" class="ma mb iq kf b kg mj kk mk ko ml ks mm kw mn la mf mg mh mi bi translated"><strong class="kf ir"> @RequestMapping </strong>(将web请求映射到处理程序控制器或方法)</li></ul><p id="d251" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们开始构建应用程序。出于演示目的，我们使用学生及其班级的基本示例。我们将创建一个数据库，并在浏览器中显示该数据。</p><p id="0bb1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我们创建两个beans来保存学生和班级的数据。</p><h1 id="551d" class="nb ld iq bd le nc nd ne lh nf ng nh lk ni nj nk ln nl nm nn lq no np nq lt nr bi translated">创建POJOs</h1><p id="2158" class="pw-post-body-paragraph kd ke iq kf b kg lv ki kj kk lw km kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">在<em class="lb">src/main/Java . com . project . first app</em>中创建目录<strong class="kf ir"> domain </strong>。<br/>在文件夹<em class="lb">域中，</em>创建两个<em class="lb">POJO</em>bean，包含构造器、设置器和获取器:</p><h2 id="9913" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">Student.java</h2><ul class=""><li id="a8f2" class="ma mb iq kf b kg lv kk lw ko ns ks nt kw nu la mf mg mh mi bi translated">为<em class="lb"> id </em>、<em class="lb">名字、</em>和<em class="lb">姓氏</em>创建私有字段，并使用其数据类型。<br/> <code class="fe mo mp mq mr b">private Long id;<br/>private String firstName;<br/>private String lastName;</code></li><li id="ef45" class="ma mb iq kf b kg mj kk mk ko ml ks mm kw mn la mf mg mh mi bi translated">为学生将要学习的课程集合创建私有字段。使用<em class="lb">类型路线</em>的<em class="lb">接口</em> <em class="lb">设置</em>。<br/>集合是元素的集合，它不能包含重复的元素，因为学生每学期只会注册一次特定的课程。<br/> <code class="fe mo mp mq mr b">private Set&lt;Course&gt; courses</code></li><li id="f496" class="ma mb iq kf b kg mj kk mk ko ml ks mm kw mn la mf mg mh mi bi translated">我们将这个私有字段课程<em class="lb"> s </em>声明为<em class="lb"> HashSet。</em>HashSet类实现<em class="lb">接口</em> <em class="lb">集合</em>并创建<em class="lb">集合</em>存储在<em class="lb">哈希表</em>中。一个<em class="lb"> HashSet </em>只允许唯一的元素，并且顺序没有保证，这将<em class="lb"> Set </em>与<em class="lb"> List </em>区分开来。<br/>HashSet类有类似<em class="lb"> add() </em>、<em class="lb"> remove() </em>、<em class="lb"> clear() </em>、<em class="lb"> contains() </em>等成员方法。可用。<br/> <code class="fe mo mp mq mr b">private Set&lt;Course&gt; courses = new HashSet&lt;&gt;();</code></li><li id="a010" class="ma mb iq kf b kg mj kk mk ko ml ks mm kw mn la mf mg mh mi bi translated">创建一个空的构造函数(Hibernate，它处理JPA需要一个空的构造函数)。<br/> <code class="fe mo mp mq mr b">public Student() {}</code></li><li id="0071" class="ma mb iq kf b kg mj kk mk ko ml ks mm kw mn la mf mg mh mi bi translated">使用参数<em class="lb"> firstName </em>和<em class="lb"> lastName创建一个构造函数。<br/></em>T3】</li></ul><h2 id="557c" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">Classes.java</h2><p id="c310" class="pw-post-body-paragraph kd ke iq kf b kg lv ki kj kk lw km kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">使用与<em class="lb">Student.java</em>中相同的结构。<br/>我们需要字段<em class="lb"> id </em>(数据类型为Long)，以及course、courseTitle和courseDescription(数据类型均为<em class="lb">字符串</em>)。由于一个班级有很多学生，我们为私有字段<em class="lb">学生</em>创建一个<em class="lb">哈希表</em>，就像在<em class="lb">Students.java做的那样。</em></p><p id="8387" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这两个beans携带我们想要存储到数据库中的数据。</p><h1 id="ec6f" class="nb ld iq bd le nc nd ne lh nf ng nh lk ni nj nk ln nl nm nn lq no np nq lt nr bi translated">JPA实体</h1><p id="2a65" class="pw-post-body-paragraph kd ke iq kf b kg lv ki kj kk lw km kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">我们将这些POJOs做成JPA实体,可以通过Hibernate保存到数据库中。<em class="lb">实体</em>代表一个表格，一个实体实例对应一个表格行。</p><p id="c0e8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以下适用于<em class="lb">Student.java</em>和<em class="lb">Course.java</em></p><ul class=""><li id="908e" class="ma mb iq kf b kg kh kk kl ko mc ks md kw me la mf mg mh mi bi translated">在类声明前添加<strong class="kf ir"> @Entity </strong>注释。Hibernate现在将这个类识别为一个实体。<br/> <code class="fe mo mp mq mr b">@Entity</code> <br/> <code class="fe mo mp mq mr b">public class Student {...</code></li><li id="0f7d" class="ma mb iq kf b kg mj kk mk ko ml ks mm kw mn la mf mg mh mi bi translated">用<strong class="kf ir"> @id <br/> </strong>对持久字段<em class="lb"> id </em>进行注释,@Id注释使其成为实体的主Id。</li><li id="68ab" class="ma mb iq kf b kg mj kk mk ko ml ks mm kw mn la mf mg mh mi bi translated">用<strong class="kf ir">@ generated value(strategy = generation type)注释id。AUTO) <br/> </strong>这告诉Hibernate如何生成id。配置<em class="lb"> id </em>值<strong class="kf ir"><br/>@ generated value(strategy = generation type)的自动递增。汽车)<br/> </strong> <code class="fe mo mp mq mr b">@Id<br/>@GeneratedValue(strategy = GenerationType.AUTO)<br/>private Long id;</code></li></ul><h1 id="9589" class="nb ld iq bd le nc nd ne lh nf ng nh lk ni nj nk ln nl nm nn lq no np nq lt nr bi translated">绘图</h1><p id="4b50" class="pw-post-body-paragraph kd ke iq kf b kg lv ki kj kk lw km kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">接下来，我们需要<em class="lb">分配关系</em>并进行映射。在我们的关系数据库设置中，在实体<em class="lb">学生</em>和<em class="lb">课程</em>之间有一个<em class="lb">多对多</em>关系。很多学生报一门课，一个学生可以报多门课。</p><p id="668a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<em class="lb">Student.java</em>标注私人球场并绘制地图。<br/> <code class="fe mo mp mq mr b">@ManyToMany(mappedBy = “students”)</code></p><p id="8ee6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在Course.java，不需要映射，我们只标注关系。<code class="fe mo mp mq mr b"><br/></code>在它的正下方，我们设置了一个连接表，给它命名，并设置了两个表的外键。我们在Course.java的文件中这样做。<br/>T3】</p><p id="e980" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下一部分需要对代码的推导进行大量解释。我不会在这篇文章中涉及这一部分。相反，我只会提供代码，并要求你只是实现它。有很多资源可以详细解释，只需搜索<em class="lb">‘Java equals and hashCode’</em>。</p><p id="4218" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将通过对每个方法应用注释<em class="lb"> @Override </em>来覆盖方法<em class="lb"> equals() </em>、<em class="lb"> hashCode()、</em>和<em class="lb"> toString() </em>。这些方法在object类中，每个实例都将继承它们。<br/>方法<strong class="kf ir"> equals() </strong>检查两个对象是否相等，<em class="lb"> x.equals(y) </em>将返回<em class="lb"> false </em>。<br/>hashCode<em class="lb">是Java为每个对象生成的唯一编号。如果两个hashCodes相同，那么这些对象将为方法<em class="lb"> equals() </em>返回<em class="lb"> true </em>。由于这些方法的默认实现导致了一些冲突，我们需要覆盖它们。一些ide，例如<em class="lb"> IntelliJ </em>会根据请求自动生成这些方法。</em></p><h2 id="b842" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">Equal()和HashCode()</h2><p id="4eef" class="pw-post-body-paragraph kd ke iq kf b kg lv ki kj kk lw km kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">安装Hibernate时需要。我们希望基于id的对象的相等性。</p><p id="25d4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">在Author.java: <br/> </em> <code class="fe mo mp mq mr b">@Override<br/>public int hashCode() {<br/>return id != null ? id.hashCode() : 0;<br/>}</code></p><p id="ab21" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mo mp mq mr b">@Override</code><br/><code class="fe mo mp mq mr b">public boolean equals(Object o) {</code><br/>T2】</p><p id="bf7f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<em class="lb">Book.java</em>中使用相同的，除了<code class="fe mo mp mq mr b">Course course = (Course) o;</code></p><h2 id="28ad" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">toString()</h2><p id="e9d2" class="pw-post-body-paragraph kd ke iq kf b kg lv ki kj kk lw km kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">我们重写此方法，以便能够在调试模式下呈现输出。<br/>在<em class="lb">Author.java</em>和<em class="lb">Book.java</em>中实现toString方法(只需分别调整属性)。这将在调试模式下格式化输出。</p><p id="7177" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mo mp mq mr b">@Override<br/>public String toString() {<br/> return “Student{“ +<br/> “id=” + id +<br/> “, firstName=’ “ + firstName + ‘\’ ‘ +<br/> “, lastName=’ “ + lastName + ‘\’ ‘ +|<br/> “, courses=” + courses +<br/> ‘}’;<br/>}</code></p><h1 id="c4a8" class="nb ld iq bd le nc nd ne lh nf ng nh lk ni nj nk ln nl nm nn lq no np nq lt nr bi translated">Spring数据JPA存储库</h1><p id="5127" class="pw-post-body-paragraph kd ke iq kf b kg lv ki kj kk lw km kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">一般来说，存储库是一个容器。JPA存储库可以比作DAO。通过Hibernate建立数据库连接，并管理所有CRUD函数。虽然在DAO中，我们需要自己编写查询，但是JPA存储库已经实现了所有的功能。</p><ul class=""><li id="8a8f" class="ma mb iq kf b kg kh kk kl ko mc ks md kw me la mf mg mh mi bi translated">创建一个名为<em class="lb">仓库</em>的新包(目录)。</li><li id="482c" class="ma mb iq kf b kg mj kk mk ko ml ks mm kw mn la mf mg mh mi bi translated">在新文件夹中创建一个类型为<em class="lb">接口</em>的新类，名为<em class="lb"> StudentRepository </em>。</li><li id="d9cb" class="ma mb iq kf b kg mj kk mk ko ml ks mm kw mn la mf mg mh mi bi translated">在新文件夹中创建一个类型为<em class="lb">接口</em>的新类，名为<em class="lb"> CourseRepository </em>。</li><li id="8bc6" class="ma mb iq kf b kg mj kk mk ko ml ks mm kw mn la mf mg mh mi bi translated">这两个类都扩展了CrudRepository，它是对存储库进行通用CRUD操作的接口。需要提供两个必需的属性:类型和id数据类型。<br/> <code class="fe mo mp mq mr b">public interface StudentRepository extends CrudRepository&lt;Student, Long&gt;{ }<br/>public interface CourseRepository extends CrudRepository&lt;Course, Long&gt; {}</code></li></ul><p id="6473" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意，CrudRepository包含所有CRUD方法，Spring已经实现了这些方法。如果查看文件CrudRepository.class，会发现函数<em class="lb"> save() </em>，<em class="lb"> findById() </em>，<em class="lb"> existsById() </em>，<em class="lb"> findAll() </em>，<em class="lb"> delete() </em>等。</p><p id="ec42" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们将创建一些数据。由于我们还没有数据库，这些数据只能在本地内存中获得。</p><h2 id="20c5" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">初始化数据</h2><ul class=""><li id="1b49" class="ma mb iq kf b kg lv kk lw ko ns ks nt kw nu la mf mg mh mi bi translated">添加一个名为<em class="lb"> bootstrap的新包。</em></li><li id="29ef" class="ma mb iq kf b kg mj kk mk ko ml ks mm kw mn la mf mg mh mi bi translated">添加一个新类<em class="lb"> BootStrapData。</em></li><li id="86c8" class="ma mb iq kf b kg mj kk mk ko ml ks mm kw mn la mf mg mh mi bi translated">用@Component将类注释为组件。</li><li id="f073" class="ma mb iq kf b kg mj kk mk ko ml ks mm kw mn la mf mg mh mi bi translated">我们想要实现接口<em class="lb"> CommandLineRunner </em>，它搜索特定类型的实例(在我们的例子中是StudentRepository和CourseRepository)并运行它们。<br/> <code class="fe mo mp mq mr b">@Component<br/>public class BootStrapData implements CommandLineRunner {</code></li><li id="8c11" class="ma mb iq kf b kg mj kk mk ko ml ks mm kw mn la mf mg mh mi bi translated">设置仓库的私有字段<br/> <code class="fe mo mp mq mr b">private final StudentRepository studentRepository;<br/>private final CourseRepository courseRepository;</code></li><li id="6eb4" class="ma mb iq kf b kg mj kk mk ko ml ks mm kw mn la mf mg mh mi bi translated">创建构造函数<br/> <code class="fe mo mp mq mr b">public BootStrapData(StudentRepository studentRepository, CourseRepository courseRepository) {<br/>this.studentRepository = studentRepository;<br/>this.courseRepository = courseRepository;<br/>}</code></li><li id="bc07" class="ma mb iq kf b kg mj kk mk ko ml ks mm kw mn la mf mg mh mi bi translated"><br/>添加数据:<code class="fe mo mp mq mr b">@Override<br/>public void run(String… args) throws Exception {<br/>Student bob = new Student(“Bob”, “Wild”);<br/>Student gil = new Student(“Gil”, “Mess”);<br/>Course oop = new Course( “CS202”, “OOP”, “Object-Oriented Programming”);<br/>Course intro = new Course(“SC101”, “Intro”, “Introduction to Computer Science”);<br/>bob.getCourses().add(intro);<br/>bob.getCourses().add(oop);<br/>gil.getCourses().add(intro);<br/>gil.getCourses().add(oop);<br/>oop.getStudents().add(bob);<br/>oop.getStudents().add(gil);<br/>intro.getStudents().add(bob);<br/>intro.getStudents().add(fran);<br/>studentRepository.save(bob);<br/>studentRepository.save(gil);<br/>courseRepository.save(oop);<br/>courseRepository.save(intro);</code></li><li id="755f" class="ma mb iq kf b kg mj kk mk ko ml ks mm kw mn la mf mg mh mi bi translated">打印信息到屏幕上大约有多少本书<br/> <code class="fe mo mp mq mr b">System.out.println(“Number of Courses: “ + courseRepository.count());<br/>System.out.println(“Number of Students: “ + studentRepository.count());</code></li></ul><h1 id="2811" class="nb ld iq bd le nc nd ne lh nf ng nh lk ni nj nk ln nl nm nn lq no np nq lt nr bi translated">H2数据库</h1><p id="cf43" class="pw-post-body-paragraph kd ke iq kf b kg lv ki kj kk lw km kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">我们需要启用H2数据库控制台。在application.properties设置中<code class="fe mo mp mq mr b">spring.h2.console.enabled = true</code></p><ul class=""><li id="81c8" class="ma mb iq kf b kg kh kk kl ko mc ks md kw me la mf mg mh mi bi translated">运行文件DemoApplication.java(右击文件名并选择<em class="lb">运行</em>)并检查在“/h2-console”中是否有<strong class="kf ir"> <em class="lb"> H2控制台。数据库位于“JDBC:H2:mem:testdb”</em></strong></li><li id="7c47" class="ma mb iq kf b kg mj kk mk ko ml ks mm kw mn la mf mg mh mi bi translated">接下来，在浏览器中输入<code class="fe mo mp mq mr b"><em class="lb">localhost:8080/h2-console</em></code> <em class="lb">。</em></li><li id="da13" class="ma mb iq kf b kg mj kk mk ko ml ks mm kw mn la mf mg mh mi bi translated">控制台将会打开。检查上面的<em class="lb"> JDBC URL </em>是否与<em class="lb"> H2引导信息</em>匹配。</li><li id="6bd2" class="ma mb iq kf b kg mj kk mk ko ml ks mm kw mn la mf mg mh mi bi translated">连接</li></ul><h1 id="211e" class="nb ld iq bd le nc nd ne lh nf ng nh lk ni nj nk ln nl nm nn lq no np nq lt nr bi translated">配置控制器</h1><p id="d6e9" class="pw-post-body-paragraph kd ke iq kf b kg lv ki kj kk lw km kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">在MVC(模型-视图-控制器)设计模式中，控制器链接用户前端和应用程序的业务逻辑。它通过调用与管理和服务数据的<em class="lb">模型</em>通信的相应方法来处理来自<em class="lb">视图</em>的请求，将数据返回给<em class="lb">视图，</em>视图将数据呈现在浏览器中。通过用@Controller注释一个类，你可以把它和它的所有成员方法变成控制器。</p><ul class=""><li id="2a89" class="ma mb iq kf b kg kh kk kl ko mc ks md kw me la mf mg mh mi bi translated">创建一个新的包，在这个上下文中有一个新的文件夹，叫做<em class="lb">控制器。</em></li><li id="a85d" class="ma mb iq kf b kg mj kk mk ko ml ks mm kw mn la mf mg mh mi bi translated">在新包<em class="lb">控制器</em>中创建一个新文件<em class="lb">StudentController.java</em>。</li><li id="5ba0" class="ma mb iq kf b kg mj kk mk ko ml ks mm kw mn la mf mg mh mi bi translated">用<em class="lb">@控制器</em>对类进行注释。<em class="lb">T39</em>T6】</li><li id="dc62" class="ma mb iq kf b kg mj kk mk ko ml ks mm kw mn la mf mg mh mi bi translated">创建私有常量<em class="lb"> StudentRepository </em>。<br/> <code class="fe mo mp mq mr b">private final StudentRepository studentRepository;</code></li><li id="8b09" class="ma mb iq kf b kg mj kk mk ko ml ks mm kw mn la mf mg mh mi bi translated">通过构造函数将<em class="lb">学生资源库</em>注入控制器。<br/> <code class="fe mo mp mq mr b">public StudentController(StudentRepository studentRepository) {<br/>this.studentRepository = studentRepository;<br/>}</code></li><li id="1712" class="ma mb iq kf b kg mj kk mk ko ml ks mm kw mn la mf mg mh mi bi translated">创建一个返回所有学生数据记录的控制器方法。为此，您需要提供接口<em class="lb">模型</em>作为参数。模型接口充当数据容器，它提供不同的方法。我们使用addAttribute()，它有两个参数。第一个(<code class="fe mo mp mq mr b">“students”</code>)定义保存返回数据的变量，第二个(<code class="fe mo mp mq mr b">studentRepository.findAll()</code>)将CrudRepository-request方法(在本例中为<code class="fe mo mp mq mr b">find.All()</code>)应用于指定的存储库。<br/> <code class="fe mo mp mq mr b">public String getStudents(Model model) {<br/>model.addAttribute(“students”, studentRepository.findAll());<br/>return “students”;<br/>}</code></li><li id="7186" class="ma mb iq kf b kg mj kk mk ko ml ks mm kw mn la mf mg mh mi bi translated">通过用<em class="lb"> @RequestMapping </em>对其进行注释并提供路径来映射该方法。<br/> <code class="fe mo mp mq mr b">@RequestMapping(“/students”)</code></li></ul><p id="e270" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对文件<em class="lb">CourseController.java</em>采用相同的步骤。使用路径<em class="lb"> "/courses" </em>进行映射。</p><p id="2dc7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们已经完成了这个非常简单的例子的业务逻辑部分，现在将注意力转向前端。我们需要创建一些显示数据的视图。为此，我们使用百里香叶，它完全集成在</p><h1 id="651e" class="nb ld iq bd le nc nd ne lh nf ng nh lk ni nj nk ln nl nm nn lq no np nq lt nr bi translated">百里香叶</h1><p id="b287" class="pw-post-body-paragraph kd ke iq kf b kg lv ki kj kk lw km kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">是来自Apache的开源Java库，完全集成到Java Spring中。它是一个用于web和非web环境的服务器端Java模板引擎，可以与HTML5一起使用。百里香使用附加的HTML标签属性，这些属性应用了Spring标准方言的规则。要了解更多信息，请前往thymeleaf.org。</p><h2 id="9656" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">设置</h2><p id="c646" class="pw-post-body-paragraph kd ke iq kf b kg lv ki kj kk lw km kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">检查pom.xml文件中的<em class="lb">百里香叶</em>的依赖项，如果没有列出，则添加它。<br/> <code class="fe mo mp mq mr b">&lt;dependency&gt;<br/>&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br/>&lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;<br/>&lt;/dependency&gt;</code></p><p id="057d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Spring会自动在/ <em class="lb">资源中生成文件夹<em class="lb">模板</em>。</em></p><p id="e8a7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<em class="lb">模板</em>中，我们创建了文件<em class="lb">studentlist.html。<br/> </em>添加通用的HTML结构。安装了扩展Emmet后，我只需要输入一个引号'！'并按回车键确认。</p><p id="8518" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，在添加百里香功能之前，我们将为页面结构和一些模拟数据创建一个普通的HTML表。</p><h2 id="b4dc" class="lc ld iq bd le lf lg dn lh li lj dp lk ko ll lm ln ks lo lp lq kw lr ls lt lu bi translated">超文本标记语言</h2><p id="18b3" class="pw-post-body-paragraph kd ke iq kf b kg lv ki kj kk lw km kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated"><code class="fe mo mp mq mr b">&lt;table&gt;<br/> &lt;tr&gt;<br/> &lt;th&gt;id&lt;/th&gt;<br/> &lt;th&gt;firstName&lt;/th&gt;<br/> &lt;th&gt;lastName&lt;/th&gt;<br/>&lt;/tr&gt;<br/> &lt;tr&gt;<br/> &lt;td&gt;007&lt;/td&gt;<br/> &lt;td&gt;Jay&lt;/td&gt;<br/> &lt;td&gt;Dee&lt;/td&gt;<br/> &lt;/tr&gt;<br/>&lt;/table&gt;</code></p><p id="2b57" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">转到localhost:8080/students并检查结果。</p><h1 id="ff2f" class="nb ld iq bd le nc nd ne lh nf ng nh lk ni nj nk ln nl nm nn lq no np nq lt nr bi translated">百里香叶</h1><p id="9d7b" class="pw-post-body-paragraph kd ke iq kf b kg lv ki kj kk lw km kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">将HTML文件转换成百里香文档。在标签中添加一个百里香的链接。<br/> <code class="fe mo mp mq mr b">&lt;html lang=”en” xmlns:th=”http:www.thymeleaf.org"&gt;</code></p><p id="5ea6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们准备在餐桌上添加百里香叶功能。Thymeleaf提供了一种SpringStandard方言，它提供了使用Spring所需的所有实现。我们只利用了百里香的一小部分能力。</p><p id="9009" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将一个百里香叶迭代器添加到我们当前拥有模拟数据的表行中。我们迭代从控制器方法<code class="fe mo mp mq mr b">getStudents()</code>返回的<code class="fe mo mp mq mr b">“students”</code>数据。<br/> <code class="fe mo mp mq mr b">&lt;tr th:each=”student : ${students}”&gt;</code></p><p id="452b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们可以访问每个数据列的对象属性。添加标签属性如图所示:<br/> <code class="fe mo mp mq mr b">&lt;td th:text=”${student.id}”&gt;007&lt;/td&gt;</code> <br/> <code class="fe mo mp mq mr b">&lt;td th:text=”${student.firstName}”&gt;Jay&lt;/td&gt;<br/>&lt;td th:text=”${student.lastName}”&gt;Dee&lt;/td&gt;</code></p><p id="f802" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">再次进入<em class="lb">localhost:8080/students</em>查看结果。</p><p id="4430" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了稍微改进一下表格的样式，我们通过在HTML标题中添加以下链接，快速添加了bootstrap，这是一个广泛使用的CSS框架。<br/> <code class="fe mo mp mq mr b">&lt;link rel=”stylesheet” href=”https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css"&gt;</code></p><p id="12db" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">学生表的完整HTML代码:</p><p id="e6f8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mo mp mq mr b">&lt;div class=”card w-75"&gt;<br/>&lt;div class=”card text-center”&gt;<br/>&lt;div class=”card-header”&gt;Students&lt;/div&gt;<br/>&lt;div class=”card-body”&gt;<br/>&lt;table class=”table table-hover”&gt;<br/>&lt;tr scope=”row”&gt;<br/>&lt;th scope=”col”&gt;id&lt;/th&gt;<br/>&lt;th scope=”col”&gt;firstName&lt;/th&gt;<br/>&lt;th scope=”col”&gt;lastName&lt;/th&gt;<br/>&lt;/tr&gt;<br/>&lt;tr scope=”row” th:each=”student : ${students}”&gt;<br/>&lt;td scope=”col” th:text=”${student.id}”&gt;007&lt;/td&gt;<br/>&lt;td scope=”col” th:text=”${student.firstName}”&gt;mo&lt;/td&gt;<br/>&lt;td scope=”col”th:text=”${student.lastName}”&gt;dee&lt;/td&gt;<br/>&lt;/tr&gt;<br/>&lt;/table&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</code></p><p id="6e7f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了完成这个小教程，创建一个具有相同结构的<em class="lb">course.html</em>文件。现在，我们可以在浏览器中呈现保存在H2数据库中的数据。<br/>这当然不是一个完整的web应用程序，但它向我们介绍了用Java Spring构建web应用程序的开端。我希望你喜欢这次谈话。我很高兴从你那里得到任何建设性的反馈。</p><p id="8509" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">除了我为这篇文章查阅了许多不同的在线资源之外，我还要感谢Spring框架大师约翰·汤姆逊。他提供了大量的在线Java Spring课程，带有清晰的解释和逐步说明。</p><p id="a9f3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这篇文章的所有代码都可以在我的GitHub资源库<a class="ae kc" href="https://github.com/maraxai/JavaSpring_firstApp" rel="noopener ugc nofollow" target="_blank"> JavaSpring_firstApp </a>中找到，按照本文中的顺序分成不同的分支。</p></div></div>    
</body>
</html>