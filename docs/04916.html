<html>
<head>
<title>Writing A Simple Factory Method In Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python编写简单的工厂方法</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/writing-a-simple-factory-method-in-python-6e48145d03a?source=collection_archive---------2-----------------------#2020-07-23">https://levelup.gitconnected.com/writing-a-simple-factory-method-in-python-6e48145d03a?source=collection_archive---------2-----------------------#2020-07-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/2cdecb303a227acd6eb1d98cd4a848b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rvjl8MSimui_AdkRw2N4TA.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@jantined?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Jantine Doornbos </a>在<a class="ae kf" href="https://unsplash.com/s/photos/code?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure></div><div class="ab cl kg kh hx ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="im in io ip iq"><p id="d089" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">如果你以前读过<a class="ae kf" href="https://en.wikipedia.org/wiki/Design_Patterns" rel="noopener ugc nofollow" target="_blank"> <em class="ll">设计模式</em> </a>的话，你可能已经了解了一种叫做“工厂方法”的经典模式。该模式允许基类的子类指定要创建的对象，从而使基类更加灵活。与其将对象名硬编码到父类中，不如将它们委托给子类。这种模式使得扩展类变得更容易，并确保了更松散耦合的对象。</p><p id="40c7" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">例如，假设您有一个父类<code class="fe lm ln lo lp b">Bicycle</code>。你希望每辆<code class="fe lm ln lo lp b">Bicycle</code>都有一套轮胎(我希望如此)。所以，每次一个新的<code class="fe lm ln lo lp b">Bicycle</code>被初始化时，你就自动把<code class="fe lm ln lo lp b">tires</code>分配给<code class="fe lm ln lo lp b">GenericTires</code>。看起来不错，对吧？但是如果你想要一个不同类型的<code class="fe lm ln lo lp b">Bicycle</code>和一个不同类型的<code class="fe lm ln lo lp b">tires</code>呢？如果<code class="fe lm ln lo lp b">GenericTires</code>接口变了或者你想完全换出来怎么办？您必须更新父<code class="fe lm ln lo lp b">Bicycle</code>类。像这样梳理代码并更新硬编码的元素是乏味的、不灵活的并且容易出错。</p><p id="39f0" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">使用工厂方法的目标是使对象更具可扩展性和抽象性，从而更易于使用。经验法则是:</p><blockquote class="lq lr ls"><p id="408c" class="kn ko ll kp b kq kr ks kt ku kv kw kx lt kz la lb lu ld le lf lv lh li lj lk im bi translated">"在单独的操作中创建对象，这样子类可以覆盖它们的创建方式."<em class="it"> — </em> <a class="ae kf" href="https://en.wikipedia.org/wiki/Design_Patterns" rel="noopener ugc nofollow" target="_blank">设计模式(1994) </a></p></blockquote><p id="76dc" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">这正是我们将在Python中探索如何做的。</p><h2 id="846e" class="lw lx it bd ly lz ma dn mb mc md dp me ky mf mg mh lc mi mj mk lg ml mm mn mo bi translated">最初的设计</h2><p id="64fa" class="pw-post-body-paragraph kn ko it kp b kq mp ks kt ku mq kw kx ky mr la lb lc ms le lf lg mt li lj lk im bi translated">在第一个例子中，我们将回顾一段可以应用工厂方法的代码通常是什么样子。我们将使用我们便利的<code class="fe lm ln lo lp b">Bicycle</code>例子，因为谁不喜欢骑自行车兜风呢？我还发现，当类模拟我们熟悉的物理事物时，更容易理解这样的概念。Sandi Metz 也经常在示例代码中使用构建自行车，我非常喜欢这种类比。让我们开始吧。</p><pre class="mu mv mw mx gt my lp mz na aw nb bi"><span id="dcd0" class="lw lx it lp b gy nc nd l ne nf">class Bicycle:<br/>    def __init__(self):<br/>        self.tires = GenericTires()</span><span id="ed9f" class="lw lx it lp b gy ng nd l ne nf">    def get_tire_type(self):<br/>        return self.tires.tire_type()</span><span id="c085" class="lw lx it lp b gy ng nd l ne nf">class GenericTires:<br/>    def tire_type(self):<br/>        return 'generic'</span><span id="79f0" class="lw lx it lp b gy ng nd l ne nf">bike = Bicycle()<br/>print(bike.get_tire_type())</span></pre><p id="e61c" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">在这个例子中，父类<code class="fe lm ln lo lp b">Bicycle</code>通过直接引用类用一组<code class="fe lm ln lo lp b">GenericTires</code>初始化。这使得<code class="fe lm ln lo lp b">Bicycle</code>和<code class="fe lm ln lo lp b">GenericTires</code>之间的耦合更加紧密和刚性。创建不同类型的自行车是可能的，但是在这个例子中改变它们的轮胎是不直观的。</p><p id="90d3" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">假设我们想制造一种新型自行车。一辆山地自行车。它可能应该有一些特殊的轮胎来应对崎岖的地形，对不对？我们如何调整基本的<code class="fe lm ln lo lp b">Bicycle</code>等级来适应不同种类的轮胎？</p><p id="2769" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">这里有一个稍微灵活的设计:</p><pre class="mu mv mw mx gt my lp mz na aw nb bi"><span id="d0a9" class="lw lx it lp b gy nc nd l ne nf">class Bicycle:<br/>    def __init__(self):<br/>        self.tires = self.add_tires()</span><span id="359e" class="lw lx it lp b gy ng nd l ne nf">    def add_tires(self):<br/>        return GenericTires()</span><span id="5a18" class="lw lx it lp b gy ng nd l ne nf">    def get_tire_type(self):<br/>        return self.tires.tire_type()</span><span id="604a" class="lw lx it lp b gy ng nd l ne nf">class MountainBike(Bicycle):<br/>    def add_tires(self):<br/>        return MountainTires()</span><span id="a218" class="lw lx it lp b gy ng nd l ne nf">class GenericTires:<br/>    def tire_type(self):<br/>        return 'generic'</span><span id="cf13" class="lw lx it lp b gy ng nd l ne nf">class MountainTires:<br/>    def tire_type(self):<br/>        return 'mountain'</span><span id="c192" class="lw lx it lp b gy ng nd l ne nf">mountain_bike = MountainBike()<br/>print(mountain_bike.get_tire_type())</span></pre><p id="454c" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">在这个例子中，我们添加了一个新的<code class="fe lm ln lo lp b">add_tires()</code>方法来返回正确的轮胎类别。这让我们可以在<code class="fe lm ln lo lp b">Bicycle</code>的任何子类中覆盖该方法，并提供不同类别的轮胎。为了添加新的自行车和轮胎，您只需要添加新的类并覆盖方法。您不必对基类进行调整。接下来，让我们来看看当你有更复杂的自行车零件时，进一步扩展这一点。</p><h2 id="62c0" class="lw lx it bd ly lz ma dn mb mc md dp me ky mf mg mh lc mi mj mk lg ml mm mn mo bi translated">更灵活的设计</h2><p id="4703" class="pw-post-body-paragraph kn ko it kp b kq mp ks kt ku mq kw kx ky mr la lb lc ms le lf lg mt li lj lk im bi translated">这里我们展示了一个更灵活和“客户端友好”的设计，类似于抽象工厂模式。该示例向父类添加了一个<code class="fe lm ln lo lp b">factory</code>参数，该参数将接受一种“零件工厂”,用于指定要创建的轮胎或其他零件的类型。</p><pre class="mu mv mw mx gt my lp mz na aw nb bi"><span id="24e9" class="lw lx it lp b gy nc nd l ne nf">class Bicycle:<br/>    def __init__(self, factory):<br/>        self.tires = factory().add_tires()<br/>        self.frame = factory().add_frame()</span><span id="9719" class="lw lx it lp b gy ng nd l ne nf">class GenericFactory:<br/>    def add_tires(self):<br/>        return GenericTires()</span><span id="0b72" class="lw lx it lp b gy ng nd l ne nf">    def add_frame(self):<br/>        return GenericFrame()</span><span id="6b0a" class="lw lx it lp b gy ng nd l ne nf">class MountainFactory:<br/>    def add_tires(self):<br/>        return RuggedTires()</span><span id="a0ad" class="lw lx it lp b gy ng nd l ne nf">    def add_frame(self):<br/>        return SturdyFrame()</span><span id="5b98" class="lw lx it lp b gy ng nd l ne nf">class RoadFactory:<br/>    def add_tires(self):<br/>        return RoadTires()</span><span id="5146" class="lw lx it lp b gy ng nd l ne nf">    def add_frame(self):<br/>        return LightFrame()</span><span id="4f25" class="lw lx it lp b gy ng nd l ne nf">class GenericTires:<br/>    def part_type(self):<br/>        return 'generic_tires'</span><span id="d3a1" class="lw lx it lp b gy ng nd l ne nf">class RuggedTires:<br/>    def part_type(self):<br/>        return 'rugged_tires'</span><span id="d00d" class="lw lx it lp b gy ng nd l ne nf">class RoadTires:<br/>    def part_type(self):<br/>        return 'road_tires'</span><span id="6a7f" class="lw lx it lp b gy ng nd l ne nf">class GenericFrame:<br/>    def part_type(self):<br/>        return 'generic_frame'</span><span id="66dc" class="lw lx it lp b gy ng nd l ne nf">class SturdyFrame:<br/>    def part_type(self):<br/>        return 'sturdy_frame'</span><span id="c9e7" class="lw lx it lp b gy ng nd l ne nf">class LightFrame:<br/>    def part_type(self):<br/>        return 'light_frame'</span><span id="a14c" class="lw lx it lp b gy ng nd l ne nf">bike = Bicycle(GenericFactory)<br/>print(bike.tires.part_type())<br/>print(bike.frame.part_type())</span><span id="d9c9" class="lw lx it lp b gy ng nd l ne nf">mountain_bike = Bicycle(MountainFactory)<br/>print(mountain_bike.tires.part_type())<br/>print(mountain_bike.frame.part_type())</span><span id="bd65" class="lw lx it lp b gy ng nd l ne nf">road_bike = Bicycle(RoadFactory)<br/>print(road_bike.tires.part_type())<br/>print(road_bike.frame.part_type())</span></pre><p id="b5cc" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">我们不再指定要安装在父类中的部件类型。添加零件由零件工厂内各自的<code class="fe lm ln lo lp b">add_tires()</code>和<code class="fe lm ln lo lp b">add_frame()</code>方法处理。部件工厂只是一个单独的类，处理每个具体部件的添加。父类<code class="fe lm ln lo lp b">Bicycle</code>调用方法在部件工厂类中添加部件。每个实例仍然是一个<code class="fe lm ln lo lp b">Bicycle</code>，但是由不同的部分组成。</p><p id="8937" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">您还可以采取一些额外的步骤来进一步抽象前面的一组类:</p><ul class=""><li id="2b55" class="nh ni it kp b kq kr ku kv ky nj lc nk lg nl lk nm nn no np bi translated">将<code class="fe lm ln lo lp b">add_tires()</code>和<code class="fe lm ln lo lp b">add_frame()</code>推广到<code class="fe lm ln lo lp b">add_part('type')</code></li><li id="a625" class="nh ni it kp b kq nq ku nr ky ns lc nt lg nu lk nm nn no np bi translated">在父类<code class="fe lm ln lo lp b">Bicycle</code>中创建一个方法，用于显示与自行车相关的所有部件。你可以通过简单地获取每一个<code class="fe lm ln lo lp b">part_type()</code>或者将<code class="fe lm ln lo lp b">self.tires</code>和<code class="fe lm ln lo lp b">self.frame</code>移动到一个列表或者零件图中进行迭代来实现。</li><li id="b01c" class="nh ni it kp b kq nq ku nr ky ns lc nt lg nu lk nm nn no np bi translated">现在<code class="fe lm ln lo lp b">Bicycle</code>期待一个零件工厂被传入。您可以将<code class="fe lm ln lo lp b">GenericFactory</code>作为默认赋值包含在类中，它可以被新工厂覆盖。</li></ul><p id="9471" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated">这些例子只是用Python编写和扩展工厂模式的一些方法。还有许多其他的变化。你选择哪一个完全取决于项目的大小和课程的复杂程度。在某些情况下，也许您只需要覆盖父类中的一个方法，在其他情况下，您需要一个专用的工厂类来实例化多个对象。最终，无论您选择哪个选项，都应该感觉自然，并为客户提供简单、可扩展的界面。</p></div><div class="ab cl kg kh hx ki" role="separator"><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl km"/><span class="kj bw bk kk kl"/></div><div class="im in io ip iq"><p id="acd7" class="pw-post-body-paragraph kn ko it kp b kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk im bi translated"><em class="ll">感谢阅读！希望您喜欢学习Python中工厂方法设计模式的工作方式。如果您不想要更多有趣的Python指南，请查看一下</em> <a class="ae kf" rel="noopener ugc nofollow" target="_blank" href="/5-python-string-methods-for-better-formatting-a2c3b92a2d33"> <em class="ll"> 5种Python字符串方法，以便更好地格式化</em> </a> <em class="ll">。</em></p></div></div>    
</body>
</html>