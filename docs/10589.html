<html>
<head>
<title>Optimizing React.js Performance with PureComponents and Shallow Comparison</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用PureComponents和浅层比较优化React.js性能</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/optimizing-ui-performance-with-react-purecomponent-and-shallow-comparison-a10cc3073e78?source=collection_archive---------8-----------------------#2021-12-23">https://levelup.gitconnected.com/optimizing-ui-performance-with-react-purecomponent-and-shallow-comparison-a10cc3073e78?source=collection_archive---------8-----------------------#2021-12-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/5c63acf00277c662fb96b2ff7fafea0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1X0-98EiQNkwBJj2vnTTqQ.jpeg"/></div></div></figure><p id="3ee1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">今天，我们将讨论如何使用React。PureComponent来加速我们前端应用程序的性能！在我们开始这篇博客的演示之前，让我们讨论一下是什么使得PureComponent不同于常规的React组件。</p><p id="acf5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> PureComponents和shouldComponentUpdate() </strong></p><p id="d24c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">PureComponents隐式地引入了一个<code class="fe kz la lb lc b">shouldComponentUpdate()</code>生命周期方法来提高性能并防止不必要的重新渲染。如果你不熟悉这个生命周期钩子，它决定了一个组件是否应该更新，假设我们满足某些条件。关于<code class="fe kz la lb lc b">shouldComponentUpdate()</code>的更多信息，你可以看这里:</p><div class="ld le gp gr lf lg"><a href="https://reactjs.org/docs/react-component.html#shouldcomponentupdate" rel="noopener  ugc nofollow" target="_blank"><div class="lh ab fo"><div class="li ab lj cl cj lk"><h2 class="bd iu gy z fp ll fr fs lm fu fw is bi translated">做出反应。成分-反应</h2><div class="ln l"><h3 class="bd b gy z fp ll fr fs lm fu fw dk translated">该页面包含React组件类定义的详细API参考。它假设您熟悉…</h3></div><div class="lo l"><p class="bd b dl z fp ll fr fs lm fu fw dk translated">reactjs.org</p></div></div><div class="lp l"><div class="lq l lr ls lt lp lu jz lg"/></div></div></a></div><p id="dcb5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在纯组件的情况下，<code class="fe kz la lb lc b">shouldComponentUpdate</code>方法对组件的状态和属性进行简单的比较，以确定是否需要重新呈现。</p><p id="84d6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">浅薄的比较</strong></p><p id="72a0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在PureComponents的情况下，React在一个深度级别上观察状态和道具，以确定是否需要进行任何重新呈现。</p><p id="6024" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">根据React文档对浅层比较的描述，“它通过对被比较对象的键进行迭代，并在每个对象中的键值不严格相等时返回true。”</p><p id="8cb3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">假设我们有某种状态:</p><pre class="lv lw lx ly gt lz lc ma mb aw mc bi"><span id="b05c" class="md me it lc b gy mf mg l mh mi">state = {<br/> name: 'Jay',<br/> address: {<br/>  street: 'Apple Way',<br/>  houseNumber: 123,<br/>  town: 'Townsville'<br/> }<br/>}</span></pre><p id="22bf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们的浅层比较将检查<code class="fe kz la lb lc b">name.</code>的值的状态变化之间的相等性。如果名称更改为‘John’，那么我们的浅层比较将提取该值并触发重新呈现。</p><p id="e8fd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们的浅层比较将根据我们的状态对象中的地址条目来比较对象在内存中的引用位置。如果内存中的位置发生变化(如果创建了一个新对象并将其设置为state)，浅层比较将触发重新呈现。</p><p id="a1dc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">道具对比一般也是如此。</p><p id="913a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">演示:</strong></p><p id="7474" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面是我创建的一个示例应用程序，演示了我们如何使用PureComponents来优化我们的性能。</p><figure class="lv lw lx ly gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mj"><img src="../Images/946afa966356baa857303c4c34cd7ece.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*thbtaIPI_nAdSuJj4bwUog.gif"/></div></div></figure><p id="d3c2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">可以在此处找到该库的链接:</p><div class="ld le gp gr lf lg"><a href="https://github.com/jonathanbrierre/pure-component-demo" rel="noopener  ugc nofollow" target="_blank"><div class="lh ab fo"><div class="li ab lj cl cj lk"><h2 class="bd iu gy z fp ll fr fs lm fu fw is bi translated">GitHub-jonathanbrierre/纯组件-演示</h2><div class="ln l"><h3 class="bd b gy z fp ll fr fs lm fu fw dk translated">这个项目是用Create React App引导的。在项目目录中，您可以运行:在…中运行应用程序</h3></div><div class="lo l"><p class="bd b dl z fp ll fr fs lm fu fw dk translated">github.com</p></div></div><div class="lp l"><div class="mk l lr ls lt lp lu jz lg"/></div></div></a></div><p id="8b58" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个应用程序有两个组件:作为父组件的App.jsx和名为Child.jsx的子组件。</p><p id="2e97" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">App.jsx看起来像这样:</p><figure class="lv lw lx ly gt ju"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="b5b2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Child.jsx:</p><figure class="lv lw lx ly gt ju"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="6e11" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我们的父组件中，我们使用useState钩子设置了两个状态变量:一个跟踪我们点击第一个按钮的次数，第二个改变子组件的颜色。颜色的状态作为道具传递给子组件。</p><p id="7bed" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你不熟悉React中的useState钩子是如何工作的，我建议你在这里看看我的博文！</p><div class="ld le gp gr lf lg"><a href="https://betterprogramming.pub/get-to-know-the-usestate-hook-in-react-js-d87797cb5a7" rel="noopener  ugc nofollow" target="_blank"><div class="lh ab fo"><div class="li ab lj cl cj lk"><h2 class="bd iu gy z fp ll fr fs lm fu fw is bi translated">了解React.js中的UseState钩子</h2><div class="ln l"><h3 class="bd b gy z fp ll fr fs lm fu fw dk translated">因为功能组件很牛逼</h3></div><div class="lo l"><p class="bd b dl z fp ll fr fs lm fu fw dk translated">better编程. pub</p></div></div><div class="lp l"><div class="mn l lr ls lt lp lu jz lg"/></div></div></a></div><p id="a86f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在子组件中，我们有一个扩展常规React.Component的类组件。我们有一个设置为“Hello World”的状态变量<code class="fe kz la lb lc b">text</code>和一个调用<code class="fe kz la lb lc b">setInterval</code>函数的<code class="fe kz la lb lc b">componentDidMount</code>生命周期方法，该函数每秒将我们的文本状态设置为“Hello World”。这样做是为了帮助模拟我将很快演示的性能问题。</p><p id="0524" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后，在我们的render方法中有一个<code class="fe kz la lb lc b">console.log</code>语句来显示我们的子组件被重新呈现的频率。</p><p id="0e7e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">事不宜迟，下面我们就来观察<strong class="kd iu">这里的问题</strong>！</p><figure class="lv lw lx ly gt ju gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/3ef1a75a4a15b6dc7e5e5ef7c229e7c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*Y_FonZ9QTqP7oQkRajE9VA.gif"/></div></figure><p id="0d45" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如我们所见，我们有一个不擅长表演的孩子！每当父组件重新呈现时，无论其更改是否会影响子组件，子组件也会重新呈现。此外，不管我们孩子的状态是否用相同的值更新，它将继续每秒重新呈现一次。这是<em class="mo">低效的</em>，因为当我们改变传递给它的颜色属性时，或者当子组件的状态值改变时，我们会想要重新渲染子组件。为此，我们从React扩展了子组件。PureComponent！</p><p id="f82f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">优化</strong></p><p id="2a86" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，您可以像这样从React导入“PureComponent ”:</p><pre class="lv lw lx ly gt lz lc ma mb aw mc bi"><span id="0100" class="md me it lc b gy mf mg l mh mi">import { PureComponent } from ‘react’</span></pre><p id="0405" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后我们延伸:</p><pre class="lv lw lx ly gt lz lc ma mb aw mc bi"><span id="fe2e" class="md me it lc b gy mf mg l mh mi">class Child extends PureComponent</span></pre><p id="55a9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当我们查看应用程序的性能时，我们可以看到我们已经完成了我们想要的！</p><figure class="lv lw lx ly gt ju gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/fa3d8f625524ad2ae1aa593b61b84608.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*N4wYSl2isAZeK1Txdo5S1w.gif"/></div></figure><p id="2ce7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">更新<code class="fe kz la lb lc b">count</code>状态只影响父级；只有父级会重新呈现，而子级不会，因为计数不会作为道具传递。</p><p id="2dd5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">此外，我们在子组件中调用的<code class="fe kz la lb lc b">setInterval</code>函数不再每秒触发一次重新渲染，因为它不会改变我们的状态值。</p><p id="97f3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">但是</strong>假设我们确实想每秒在子组件中的文本末尾添加一个感叹号。我们需要更新setInterval函数，如下所示:</p><pre class="lv lw lx ly gt lz lc ma mb aw mc bi"><span id="126b" class="md me it lc b gy mf mg l mh mi"> setInterval(() =&gt; {<br/>    this.setState(prevState =&gt; ({ text: prevState.text + ‘!’ }))<br/> }, 1000)`</span></pre><figure class="lv lw lx ly gt ju gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/ece4700af73c184bff12bc0728f20b87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*XMx1aTO3DmJ5VideDZC-yA.gif"/></div></figure><p id="0427" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">由于我们现在每秒都在有效地改变我们孩子的状态，我们的PureComponent的浅层比较检测到这种变化，并允许重新呈现。这些更改会根据需要反映在用户界面上。</p><p id="33af" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">注意事项:</strong></p><p id="cf5e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">作为反应。PureComponent使用浅层比较来决定何时重新渲染，我们必须在创建和更新组件状态时遵守规则。通常建议不要在PureComponents中使用深度嵌套的状态。这是为了在操作状态数据时避免任何不必要的直接状态突变。更新状态时，总是创建新的或重复的状态对象和数组。</p><p id="d839" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有关如何不改变状态的指南，请查看这篇博文:</p><div class="ld le gp gr lf lg"><a href="https://medium.com/@kkranthi438/dont-mutate-state-in-react-6b25d5e06f42" rel="noopener follow" target="_blank"><div class="lh ab fo"><div class="li ab lj cl cj lk"><h2 class="bd iu gy z fp ll fr fs lm fu fw is bi translated">不要在反应中改变状态</h2><div class="ln l"><h3 class="bd b gy z fp ll fr fs lm fu fw dk translated">这篇文章描述了在react中不改变状态的重要性。</h3></div><div class="lo l"><p class="bd b dl z fp ll fr fs lm fu fw dk translated">medium.com</p></div></div></div></a></div><p id="ecb6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">此外，根据React文档，“如果[状态或属性]包含复杂的数据结构，它可能会对更深层次的差异产生假阴性。”</p><p id="9db2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您可以在React上找到更多信息。此处为纯组件</p><div class="ld le gp gr lf lg"><a href="https://reactjs.org/docs/react-api.html#reactpurecomponent" rel="noopener  ugc nofollow" target="_blank"><div class="lh ab fo"><div class="li ab lj cl cj lk"><h2 class="bd iu gy z fp ll fr fs lm fu fw is bi translated">反应顶级API -反应</h2><div class="ln l"><h3 class="bd b gy z fp ll fr fs lm fu fw dk translated">React是React库的入口点。如果从一个标签加载React，这些顶级API可以在…</h3></div><div class="lo l"><p class="bd b dl z fp ll fr fs lm fu fw dk translated">reactjs.org</p></div></div><div class="lp l"><div class="mp l lr ls lt lp lu jz lg"/></div></div></a></div><p id="db12" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">此外，PureComponent将用于类组件。如果您想为您的功能组件添加类似的性能优化，请查看我在React.memo上的博客！</p><div class="ld le gp gr lf lg"><a rel="noopener  ugc nofollow" target="_blank" href="/optimizing-performance-using-react-memo-cc7d954de309"><div class="lh ab fo"><div class="li ab lj cl cj lk"><h2 class="bd iu gy z fp ll fr fs lm fu fw is bi translated">使用React.memo优化性能</h2><div class="lo l"><p class="bd b dl z fp ll fr fs lm fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="lp l"><div class="mq l lr ls lt lp lu jz lg"/></div></div></a></div><p id="b507" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">编码快乐！</p></div></div>    
</body>
</html>