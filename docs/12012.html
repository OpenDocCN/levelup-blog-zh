<html>
<head>
<title>Using monads with go 1.18 generics (Part 1 — Maybe)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在go 1.18泛型中使用单子(第1部分—也许)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/using-monads-with-go-1-18-generics-part-1-maybe-bb42d3e09968?source=collection_archive---------0-----------------------#2022-05-08">https://levelup.gitconnected.com/using-monads-with-go-1-18-generics-part-1-maybe-bb42d3e09968?source=collection_archive---------0-----------------------#2022-05-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/33b53d345a2b1b392146d75034bfcdc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:678/format:webp/1*hcH45UTXMb0UmUiQ4EqoTA.png"/></div></figure><p id="e17c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Go 1.18为Go编程语言引入了期待已久的泛型。这次更新为类型安全编程增加了许多新的可能性。</p><p id="7bf2" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">其中一种可能性是使用一种众所周知的模式，这种模式来自函数式编程，称为monads。单子是一种将你的计算包装在容器中的方法，容器将你的计算粘合在一起，在这个过程中产生一些效果。例如，在Haskell中你不能直接执行任何副作用——你需要将它们包装在IO monad中，这一点我们将在后面讨论。</p><p id="aade" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们从最简单的单子开始——也许吧。也许是一个容器，要么有值，要么什么都没有。它有一些方法，允许我们将它们组合在一起，过滤，并从中获取值。</p><figure class="ks kt ku kv gt jr"><div class="bz fp l di"><div class="kw kx l"/></div></figure><figure class="ks kt ku kv gt jr"><div class="bz fp l di"><div class="kw kx l"/></div></figure><p id="a362" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这个接口有两个实现——一个用于我们有价值的情况，另一个用于我们一无所有的情况。</p><p id="ce2e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">链接计算的最简单方法是使用Map和FlatMap:</p><figure class="ks kt ku kv gt jr"><div class="bz fp l di"><div class="kw kx l"/></div></figure><p id="5444" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Map采用任何取值并返回值的函数并将此函数应用于我们的Maybe值m，如果m有值，它就对其运行函数，如果没有值，它什么也不做。这样，如果我们有一个很长的计算序列，其中第一个可能失败并且不返回任何东西，我们就不必在过程中的每一站都编写if检查。</p><p id="6267" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">FlatMap以同样的方式工作，但是对于一个也返回Maybe的函数。</p><p id="1171" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">还有一些实用方法，如IsPresent，它对Just返回true，对Nothing返回false。</p><p id="124a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在让我们看一些实际例子，看看如何使用monad来减少代码混乱。</p><p id="90aa" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">假设我们有以下的划分顺序:</p><p id="b319" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">x := a / b</p><p id="00e9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">y := c/x</p><p id="2c73" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">z := d/ y</p><p id="877d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">b和d可以是零，x和y也可以是零。</p><p id="ad0c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">下面是我们如何使用if语句来实现它:</p><figure class="ks kt ku kv gt jr"><div class="bz fp l di"><div class="kw kx l"/></div></figure><p id="0973" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">可能用单子:</p><figure class="ks kt ku kv gt jr"><div class="bz fp l di"><div class="kw kx l"/></div></figure><p id="d85f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">可能是单子的完整代码:</p><figure class="ks kt ku kv gt jr"><div class="bz fp l di"><div class="kw kx l"/></div></figure><p id="2d73" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">您可以在<a class="ae ky" href="https://github.com/OlegStotsky/go-monads" rel="noopener ugc nofollow" target="_blank"> go-monads github repo </a>中找到这些代码以及其他monads的代码。在本系列的下一篇文章中，我们将关注木卫一。敬请期待！</p></div></div>    
</body>
</html>