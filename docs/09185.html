<html>
<head>
<title>Shared Element using MaterialContainerTransform in Android</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android中使用MaterialContainerTransform的共享元素</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/shared-element-using-materialcontainertransform-in-android-6d420e74b122?source=collection_archive---------12-----------------------#2021-07-14">https://levelup.gitconnected.com/shared-element-using-materialcontainertransform-in-android-6d420e74b122?source=collection_archive---------12-----------------------#2021-07-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c52d" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何建立MaterialContainerTransform转换并解决随之而来的问题</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/a8a9f6d4a98d0c56be63efc1969d7087.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/1*TE6f3Zy7_2VFEiKiTCqyHw.gif"/></div></figure><h1 id="1354" class="kq kr it bd ks kt ku kv kw kx ky kz la jz lb ka lc kc ld kd le kf lf kg lg lh bi translated">介绍</h1><p id="82e6" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">材料设计就是创造一种无处不在的直观的用户体验<em class="me">。【Android的Material motion系统是一套过渡模式，可以帮助用户理解和导航应用程序。</em></p><p id="f86f" class="pw-post-body-paragraph li lj it lk b ll mf ju ln lo mg jx lq lr mh lt lu lv mi lx ly lz mj mb mc md im bi translated">四种主要的材料转换模式如下:</p><ul class=""><li id="721b" class="mk ml it lk b ll mf lo mg lr mm lv mn lz mo md mp mq mr ms bi translated">容器转换。</li><li id="f97f" class="mk ml it lk b ll mt lo mu lr mv lv mw lz mx md mp mq mr ms bi translated">共享轴。</li><li id="59bc" class="mk ml it lk b ll mt lo mu lr mv lv mw lz mx md mp mq mr ms bi translated">逐渐消失。</li><li id="e556" class="mk ml it lk b ll mt lo mu lr mv lv mw lz mx md mp mq mr ms bi translated">褪色。</li></ul><p id="8fe0" class="pw-post-body-paragraph li lj it lk b ll mf ju ln lo mg jx lq lr mh lt lu lv mi lx ly lz mj mb mc md im bi translated">请看看https://material.io/develop/android/theming/motion<a class="ae my" href="https://material.io/develop/android/theming/motion" rel="noopener ugc nofollow" target="_blank"><em class="me"/></a><em class="me"><em class="me">的详细方针和原则。</em></em></p><p id="f002" class="pw-post-body-paragraph li lj it lk b ll mf ju ln lo mg jx lq lr mh lt lu lv mi lx ly lz mj mb mc md im bi translated"><strong class="lk iu">什么是MaterialContainerTransform？</strong></p><p id="ee9a" class="pw-post-body-paragraph li lj it lk b ll mf ju ln lo mg jx lq lr mh lt lu lv mi lx ly lz mj mb mc md im bi translated">容器转换类似于将一个容器转换成另一个容器的共享元素，例如将CardView转换成一个细节容器。这种转换的强大之处在于，它可以在从一种布局转换到另一种布局的过程中吸引用户的注意力。</p><p id="dd3e" class="pw-post-body-paragraph li lj it lk b ll mf ju ln lo mg jx lq lr mh lt lu lv mi lx ly lz mj mb mc md im bi translated"><strong class="lk iu">什么问题？</strong></p><blockquote class="mz"><p id="c4a1" class="na nb it bd nc nd ne nf ng nh ni md dk translated">“如果我有一个小时来解决一个问题，我会花55分钟思考问题，花5分钟思考解决方案。”——阿尔伯特·爱因斯坦</p></blockquote><p id="df80" class="pw-post-body-paragraph li lj it lk b ll nj ju ln lo nk jx lq lr nl lt lu lv nm lx ly lz nn mb mc md im bi translated"><a class="ae my" href="https://developer.android.com/reference/com/google/android/material/transition/MaterialContainerTransform" rel="noopener ugc nofollow" target="_blank">根据Android文档</a>:</p><blockquote class="no np nq"><p id="9f9f" class="li lj me lk b ll mf ju ln lo mg jx lq nr mh lt lu ns mi lx ly nt mj mb mc md im bi translated"><em class="it">该转换捕获开始和结束视图，用于创建一个</em> <a class="ae my" href="https://developer.android.com/reference/android/graphics/drawable/Drawable" rel="noopener ugc nofollow" target="_blank"> <em class="it">可绘制的</em> </a> <em class="it">，该视图将被添加到视图层次结构中。drawable将作为覆盖图添加到视图层次结构中，并处理在起始视图的形状和结束视图的形状之间变形的遮罩的绘制。</em></p></blockquote><p id="8b0f" class="pw-post-body-paragraph li lj it lk b ll mf ju ln lo mg jx lq lr mh lt lu lv mi lx ly lz mj mb mc md im bi translated">那么过渡结束后会发生什么呢？好吧，让我们来看看<code class="fe nu nv nw nx b">MaterialContainerTransform</code>的源代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="d725" class="pw-post-body-paragraph li lj it lk b ll mf ju ln lo mg jx lq lr mh lt lu lv mi lx ly lz mj mb mc md im bi translated">用于从一个容器变形到另一个容器的<code class="fe nu nv nw nx b">drawingView</code>将被移除。此时，将显示目的地集装箱。转换大约需要300毫秒，所以理想情况下，目标容器应该在覆盖图被移除之前完成视图的加载。如果没有及时加载，将会出现如下情况:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/d3e69d9ccfbf0ff30f69282c9353dc33.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/1*nEs3bE4CTmEsaXXl5P0RXQ.gif"/></div></figure><h1 id="cc9c" class="kq kr it bd ks kt ku kv kw kx ky kz la jz lb ka lc kc ld kd le kf lf kg lg lh bi translated">编码部分</h1><p id="06e6" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我将编码部分分为4个步骤，如下所示:</p><ul class=""><li id="daf2" class="mk ml it lk b ll mf lo mg lr mm lv mn lz mo md mp mq mr ms bi translated"><a class="ae my" href="#7442" rel="noopener ugc nofollow">项目设置。</a></li><li id="1ee5" class="mk ml it lk b ll mt lo mu lr mv lv mw lz mx md mp mq mr ms bi translated"><a class="ae my" href="#7afb" rel="noopener ugc nofollow">开始片段。</a></li><li id="9f77" class="mk ml it lk b ll mt lo mu lr mv lv mw lz mx md mp mq mr ms bi translated"><a class="ae my" href="#8215" rel="noopener ugc nofollow">目的地片段。</a></li><li id="a7a5" class="mk ml it lk b ll mt lo mu lr mv lv mw lz mx md mp mq mr ms bi translated"><a class="ae my" href="#f2bb" rel="noopener ugc nofollow">滑行——调试。</a></li></ul><h1 id="7442" class="kq kr it bd ks kt ku kv kw kx ky kz la jz lb ka lc kc ld kd le kf lf kg lg lh bi translated">步骤1:项目设置</h1><p id="9129" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">首先请查看<a class="ae my" href="https://github.com/material-components/material-components-android" rel="noopener ugc nofollow" target="_blank"> Material components android网站</a>获取最新版本的MaterialContainerTransform。然后将以下内容添加到您的应用程序的<code class="fe nu nv nw nx b">build.gradle.kts</code>:</p><pre class="kj kk kl km gt oa nx ob oc aw od bi"><span id="bc2a" class="oe kr it nx b gy of og l oh oi">dependencies {<br/>    implementation('com.google.android.material:material:1.4.0')<br/>}</span></pre><p id="bbb6" class="pw-post-body-paragraph li lj it lk b ll mf ju ln lo mg jx lq lr mh lt lu lv mi lx ly lz mj mb mc md im bi translated">容器转换可以被配置为在许多Android结构之间转换，包括片段、活动和视图。在这个例子中，我们使用艺术家列表片段和艺术家细节片段之间的过渡。</p><h1 id="7afb" class="kq kr it bd ks kt ku kv kw kx ky kz la jz lb ka lc kc ld kd le kf lf kg lg lh bi translated">第二步:开始片段</h1><h2 id="71a3" class="oe kr it bd ks oj ok dn kw ol om dp la lr on oo lc lv op oq le lz or os lg ot bi translated">a.设置转换名称</h2><p id="5bda" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe nu nv nw nx b">MaterialContainerTransform</code>作为共享元素转换操作，当标记有<strong class="lk iu">转换名称</strong>时，它拾取不同布局中的两个视图。首先添加一个transitionName，它在我们的开始视图中是唯一的。我使用BE返回的id作为一个transitionName并将其添加到<code class="fe nu nv nw nx b">onBindViewHolder()</code>中:</p><pre class="kj kk kl km gt oa nx ob oc aw od bi"><span id="7746" class="oe kr it nx b gy of og l oh oi">override fun onBindViewHolder(holder: ArtistViewHolder, position: Int) {<br/>    ...<br/>    holder.binding.imgv.<em class="me">transitionName </em>= getItem(position).id<br/>}</span></pre><h2 id="25f5" class="oe kr it bd ks oj ok dn kw ol om dp la lr on oo lc lv op oq le lz or os lg ot bi translated">b.定义一个形状</h2><p id="7dc7" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">下一步，我们必须为开始视图定义一个形状。要实现一个圆形，让我们首先尝试使用Glide中的<code class="fe nu nv nw nx b">CircleCrop()</code>来加载一个圆形图像:</p><pre class="kj kk kl km gt oa nx ob oc aw od bi"><span id="ff8f" class="oe kr it nx b gy of og l oh oi">requestManager<br/>    .load(url)<br/>    .placeholder(R.drawable.<em class="me">image_placeholder</em>)<br/>    .transform(CircleCrop())<br/>    .into(this)</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/5f821d15011b73342cea40f3a472d428.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/1*dlp9M7eRqkq0XOoLihMQxg.gif"/></div></figure><p id="51cb" class="pw-post-body-paragraph li lj it lk b ll mf ju ln lo mg jx lq lr mh lt lu lv mi lx ly lz mj mb mc md im bi translated">正如我们所看到的，<code class="fe nu nv nw nx b">CircleCrop()</code>只是圆形裁剪了一个图像，包含它的视图仍然具有方形形状。</p><p id="ca9a" class="pw-post-body-paragraph li lj it lk b ll mf ju ln lo mg jx lq lr mh lt lu lv mi lx ly lz mj mb mc md im bi translated">有两种解决方法:</p><ul class=""><li id="4510" class="mk ml it lk b ll mf lo mg lr mm lv mn lz mo md mp mq mr ms bi translated">在XML文件中使用<code class="fe nu nv nw nx b">app:shapeAppearance</code>。</li></ul><pre class="kj kk kl km gt oa nx ob oc aw od bi"><span id="0bbf" class="oe kr it nx b gy of og l oh oi">&lt;com.google.android.material.imageview.ShapeableImageView<br/>    ...<br/>    app:shapeAppearance="?attr/shapeAppearanceCircleComponent"/&gt;</span></pre><p id="f54f" class="pw-post-body-paragraph li lj it lk b ll mf ju ln lo mg jx lq lr mh lt lu lv mi lx ly lz mj mb mc md im bi translated">通过使用这种方式，我们在加载图像时不必使用<code class="fe nu nv nw nx b">CenterCrop()</code>。</p><ul class=""><li id="09e4" class="mk ml it lk b ll mf lo mg lr mm lv mn lz mo md mp mq mr ms bi translated">如果我们需要使用<code class="fe nu nv nw nx b">CenterCrop()</code>，我们必须通过使用<code class="fe nu nv nw nx b">MaterialContainerTransform</code>类中提供的<code class="fe nu nv nw nx b"><a class="ae my" href="https://developer.android.com/reference/com/google/android/material/transition/MaterialContainerTransform#setStartShapeAppearanceModel(com.google.android.material.shape.ShapeAppearanceModel)" rel="noopener ugc nofollow" target="_blank">setStartShapeAppearanceModel</a>()</code>来手动设置形状外观。</li></ul><p id="943e" class="pw-post-body-paragraph li lj it lk b ll mf ju ln lo mg jx lq lr mh lt lu lv mi lx ly lz mj mb mc md im bi translated">尝试重新运行该应用程序。变形形状变得更好。不错！让我们不断改进动画。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/9d80c981414654a92cde66ebc5c3c84d.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/1*Vf4NI8WWlaJJ-7Y4Fx6zNg.gif"/></div><figcaption class="ou ov gj gh gi ow ox bd b be z dk translated">在XML文件中使用<code class="fe nu nv nw nx b">app:shapeAppearance</code></figcaption></figure><h2 id="52d5" class="oe kr it bd ks oj ok dn kw ol om dp la lr on oo lc lv op oq le lz or os lg ot bi translated">c.配置转换</h2><pre class="kj kk kl km gt oa nx ob oc aw od bi"><span id="4001" class="oe kr it nx b gy of og l oh oi">val targetFrag = ArtistDetailFragment.newInstance(it.artist, it.view.transitionName, it.view.width, it.view.height, it.imageUrl).<em class="me">apply </em><strong class="nx iu">{<br/>    </strong><em class="me">sharedElementEnterTransition </em>= MaterialContainerTransform()<br/><strong class="nx iu">}<br/></strong>supportFragmentManager.commit(true) <strong class="nx iu">{<br/>    </strong>addSharedElement(it.view, it.view.transitionName)<br/>    replace(R.id.<em class="me">content</em>, targetFrag)<br/>    addToBackStack(null)<br/><strong class="nx iu">}</strong></span></pre><p id="ea98" class="pw-post-body-paragraph li lj it lk b ll mf ju ln lo mg jx lq lr mh lt lu lv mi lx ly lz mj mb mc md im bi translated">请注意以下事项:</p><ul class=""><li id="4580" class="mk ml it lk b ll mf lo mg lr mm lv mn lz mo md mp mq mr ms bi translated"><code class="fe nu nv nw nx b">targetFrag</code>:是目的片段。</li><li id="5d91" class="mk ml it lk b ll mt lo mu lr mv lv mw lz mx md mp mq mr ms bi translated"><code class="fe nu nv nw nx b">transitionName</code>、<code class="fe nu nv nw nx b">width</code>、<code class="fe nu nv nw nx b">height</code>、<code class="fe nu nv nw nx b">imageUrl</code>:与滑动缓存键相关。</li><li id="9eb4" class="mk ml it lk b ll mt lo mu lr mv lv mw lz mx md mp mq mr ms bi translated"><code class="fe nu nv nw nx b">addSharedElement()</code>:我们提供一个来自起始片段的<code class="fe nu nv nw nx b">view</code>，用于映射到来自目的片段的视图，以及一个<code class="fe nu nv nw nx b">transitionName</code>。</li></ul><h2 id="b4ab" class="oe kr it bd ks oj ok dn kw ol om dp la lr on oo lc lv op oq le lz or os lg ot bi translated">d.滑动缓存键</h2><p id="94ca" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><a class="ae my" href="https://bumptech.github.io/glide/doc/caching.html" rel="noopener ugc nofollow" target="_blank">根据文档</a>，缓存键由多个元素组成。在本例中，我们使用了3个元素:</p><ul class=""><li id="f227" class="mk ml it lk b ll mf lo mg lr mm lv mn lz mo md mp mq mr ms bi translated">全球资源定位器(Uniform Resource Locator)</li><li id="4974" class="mk ml it lk b ll mt lo mu lr mv lv mw lz mx md mp mq mr ms bi translated">宽度</li><li id="71fc" class="mk ml it lk b ll mt lo mu lr mv lv mw lz mx md mp mq mr ms bi translated">高度</li></ul><p id="e766" class="pw-post-body-paragraph li lj it lk b ll mf ju ln lo mg jx lq lr mh lt lu lv mi lx ly lz mj mb mc md im bi translated">这就是为什么我将包含url、宽度和高度的artist对象传递给目的片段。通过这样做，我们可以生成相同的缓存键，目的片段可以从内存缓存中获取位图，以便快速加载。</p><h2 id="6b0f" class="oe kr it bd ks oj ok dn kw ol om dp la lr on oo lc lv op oq le lz or os lg ot bi translated">e.回归转型</h2><p id="f20c" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">默认情况下，如果没有设置返回过渡，过渡系统将在向后导航时自动反转enter过渡。但是，请注意，按back不会将艺术家的详细信息折叠回艺术家列表中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/b1314ccd0233b635a44c6322eb77712b.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/1*YSalEZPKeTJu2Ng8jgRerw.gif"/></div></figure><p id="52ab" class="pw-post-body-paragraph li lj it lk b ll mf ju ln lo mg jx lq lr mh lt lu lv mi lx ly lz mj mb mc md im bi translated">因为当我们返回时，开始片段还没有膨胀，所以没有共享元素的映射视图来创建返回转换。我们必须等到开始片段展开。</p><p id="d369" class="pw-post-body-paragraph li lj it lk b ll mf ju ln lo mg jx lq lr mh lt lu lv mi lx ly lz mj mb mc md im bi translated">在这种情况下，过渡系统提供了两种方法来帮助我们:</p><ul class=""><li id="3ed4" class="mk ml it lk b ll mf lo mg lr mm lv mn lz mo md mp mq mr ms bi translated"><code class="fe nu nv nw nx b"><a class="ae my" href="https://developer.android.com/reference/android/app/Activity#postponeEnterTransition()" rel="noopener ugc nofollow" target="_blank">postponeEnterTransition</a></code> <strong class="lk iu"> : </strong>推迟进入的片段过渡，直到调用了startPostponedEnterTransition()为止。</li><li id="6100" class="mk ml it lk b ll mt lo mu lr mv lv mw lz mx md mp mq mr ms bi translated"><code class="fe nu nv nw nx b"><a class="ae my" href="https://developer.android.com/reference/android/app/Activity#startPostponedEnterTransition()" rel="noopener ugc nofollow" target="_blank">startPostponedEnterTransition</a></code> <strong class="lk iu"> : </strong>开始延期过渡。</li></ul><p id="2639" class="pw-post-body-paragraph li lj it lk b ll mf ju ln lo mg jx lq lr mh lt lu lv mi lx ly lz mj mb mc md im bi translated">将下面两行添加到<code class="fe nu nv nw nx b">onViewCreated</code>方法中，并尝试重新运行应用程序:</p><pre class="kj kk kl km gt oa nx ob oc aw od bi"><span id="a719" class="oe kr it nx b gy of og l oh oi">postponeEnterTransition()<br/>view.doOnPreDraw { startPostponedEnterTransition() }</span></pre><p id="17e9" class="pw-post-body-paragraph li lj it lk b ll mf ju ln lo mg jx lq lr mh lt lu lv mi lx ly lz mj mb mc md im bi translated">当视图树将要被绘制时，我们开始转换，这意味着视图已经布局好了。不错！🥰</p><h1 id="8215" class="kq kr it bd ks kt ku kv kw kx ky kz la jz lb ka lc kc ld kd le kf lf kg lg lh bi translated">步骤3:目的片段</h1><p id="8f0a" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们希望将起始片段中的视图转换为目的片段中的完整视图，因此在<code class="fe nu nv nw nx b">onCreateView()</code>方法中将<code class="fe nu nv nw nx b">transitionName</code>从参数设置为视图根:</p><pre class="kj kk kl km gt oa nx ob oc aw od bi"><span id="d425" class="oe kr it nx b gy of og l oh oi">override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? {<br/>    viewBinding = FragmentArtistDetailBinding.inflate(inflater, container, false)<br/>    return viewBinding.root.apply {<br/>        transitionName = this@ArtistDetailFragment.transitionName<br/>    }<br/>}</span></pre><p id="29c2" class="pw-post-body-paragraph li lj it lk b ll mf ju ln lo mg jx lq lr mh lt lu lv mi lx ly lz mj mb mc md im bi translated">从参数中获取密钥并加载到<code class="fe nu nv nw nx b">thumbnail()</code>方法中。此方法最适合用于加载较小的缩略图资源，加载速度比全尺寸资源快。我们应该将该负载的优先级设置为<code class="fe nu nv nw nx b">IMMEDIATE</code>，当一次有多个负载排队时，将首先启动优先级较高的负载:</p><pre class="kj kk kl km gt oa nx ob oc aw od bi"><span id="aa0b" class="oe kr it nx b gy of og l oh oi">Glide.with(this@ArtistDetailFragment)<br/>    .asBitmap() .thumbnail(Glide.with(this).asBitmap().load(imageUrl).priority(Priority.<em class="me">IMMEDIATE</em>).override(widthImage, heightImage))<br/>    .load(artist.model.pictureBig)<br/>    .placeholder(R.drawable.<em class="me">image_placeholder</em>)<br/>    .into(viewBinding.artistImageView)</span></pre><h1 id="f2bb" class="kq kr it bd ks kt ku kv kw kx ky kz la jz lb ka lc kc ld kd le kf lf kg lg lh bi translated">第四步:滑动——调试</h1><p id="7855" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">到目前为止，一切都好！但是我们需要确定是否有<strong class="lk iu">意外的缓存未命中，</strong>为什么你在一个地方的内存中的图像没有在另一个地方被使用…</p><p id="2c23" class="pw-post-body-paragraph li lj it lk b ll mf ju ln lo mg jx lq lr mh lt lu lv mi lx ly lz mj mb mc md im bi translated">首先，在您的终端中使用adb启用引擎标签记录:</p><pre class="kj kk kl km gt oa nx ob oc aw od bi"><span id="4a9b" class="oe kr it nx b gy of og l oh oi"><em class="me">adb shell setprop log.tag.Engine VERBOSE</em></span></pre><p id="cd41" class="pw-post-body-paragraph li lj it lk b ll mf ju ln lo mg jx lq lr mh lt lu lv mi lx ly lz mj mb mc md im bi translated">它用于查看logcat中的缓存键，如下所示:</p><pre class="kj kk kl km gt oa nx ob oc aw od bi"><span id="dbdb" class="oe kr it nx b gy of og l oh oi">V/Engine: Loaded resource from active resources in 0.009458ms, key: EngineKey{model=https://cdns-images.dzcdn.net/images/artist/7e2efcc3fdbfaaed13b07d8c87929615/250x250-000000-80-0-0.jpg, width=477, height=477, resourceClass=class java.lang.Object, transcodeClass=class android.graphics.drawable.Drawable, signature=EmptySignature, hashCode=-807288796, transformations={}, options=Options{values={}}}</span></pre><p id="7c07" class="pw-post-body-paragraph li lj it lk b ll mf ju ln lo mg jx lq lr mh lt lu lv mi lx ly lz mj mb mc md im bi translated">其次，通过添加下面的类来启用滑动标记:</p><pre class="kj kk kl km gt oa nx ob oc aw od bi"><span id="1a4a" class="oe kr it nx b gy of og l oh oi">@GlideModule<br/>class MyGlideModule : AppGlideModule() {<br/>    override fun applyOptions(context: Context, builder: GlideBuilder) {<br/>        builder.setLogLevel(Log.<em class="me">VERBOSE</em>)<br/>    }<br/>}</span></pre><p id="f969" class="pw-post-body-paragraph li lj it lk b ll mf ju ln lo mg jx lq lr mh lt lu lv mi lx ly lz mj mb mc md im bi translated">它用于检查来自远程、磁盘还是内存的图像:</p><pre class="kj kk kl km gt oa nx ob oc aw od bi"><span id="fbf9" class="oe kr it nx b gy of og l oh oi">D/Glide: Finished loading BitmapDrawable from MEMORY_CACHE for <a class="ae my" href="https://cdns-images.dzcdn.net/images/artist/7e2efcc3fdbfaaed13b07d8c87929615/250x250-000000-80-0-0.jpg" rel="noopener ugc nofollow" target="_blank">https://cdns-images.dzcdn.net/images/artist/7e2efcc3fdbfaaed13b07d8c87929615/250x250-000000-80-0-0.jpg</a> with size [477x477] in 0.051165999999999996 ms</span></pre><p id="d941" class="pw-post-body-paragraph li lj it lk b ll mf ju ln lo mg jx lq lr mh lt lu lv mi lx ly lz mj mb mc md im bi translated">注意Glide标签通知我们它<em class="me">完成了从MEMORY_CACHE为</em>加载BitmapDrawable这是我们想要的东西。如果没有，尝试再次检查引擎日志标记中的缓存键，并找出它们之间的不同之处。</p><p id="7005" class="pw-post-body-paragraph li lj it lk b ll mf ju ln lo mg jx lq lr mh lt lu lv mi lx ly lz mj mb mc md im bi translated">对于在开始和结束片段中生成相同的缓存键，我的建议是ImageView的<code class="fe nu nv nw nx b">scaleType</code>应该是<code class="fe nu nv nw nx b">center</code>。让我们看看Glide中<code class="fe nu nv nw nx b">RequestBuilder()</code>的源代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="6bb0" class="pw-post-body-paragraph li lj it lk b ll mf ju ln lo mg jx lq lr mh lt lu lv mi lx ly lz mj mb mc md im bi translated">当我们使用<code class="fe nu nv nw nx b">scaleType</code>而不是<code class="fe nu nv nw nx b">center</code>或<code class="fe nu nv nw nx b">matrix</code>时，Glide会自动生成一个变换。转换涉及到缓存键的生成，如果我们消除它，缓存键将变得更容易控制。</p><p id="a1f9" class="pw-post-body-paragraph li lj it lk b ll mf ju ln lo mg jx lq lr mh lt lu lv mi lx ly lz mj mb mc md im bi translated">但是如果<code class="fe nu nv nw nx b">scaleType</code>是居中，它只是将图像在视图中居中，但是不执行缩放。我们必须向<code class="fe nu nv nw nx b">override</code>方法()提供宽度和高度，使其满足视图:</p><pre class="kj kk kl km gt oa nx ob oc aw od bi"><span id="661b" class="oe kr it nx b gy of og l oh oi"><em class="me">doOnLayout </em>{<br/>    requestManager<br/>        .load(url)<br/>        .placeholder(R.drawable.<em class="me">image_placeholder</em>)<br/>        .override(it.<em class="me">width</em>, it.<em class="me">height</em>)<br/>        .into(this)<br/>}</span></pre><p id="a34f" class="pw-post-body-paragraph li lj it lk b ll mf ju ln lo mg jx lq lr mh lt lu lv mi lx ly lz mj mb mc md im bi translated">仅此而已！如果您在执行代码片段时发现问题，请查看GitHub repo获取帮助:</p><div class="oy oz gp gr pa pb"><a href="https://github.com/PhongHuynh93/DeezerKMP" rel="noopener  ugc nofollow" target="_blank"><div class="pc ab fo"><div class="pd ab pe cl cj pf"><h2 class="bd iu gy z fp pg fr fs ph fu fw is bi translated">PhongHuynh93/DeezerKMP</h2><div class="pi l"><h3 class="bd b gy z fp pg fr fs ph fu fw dk translated">在GitHub上创建一个帐户，为PhongHuynh93/DeezerKMP的开发做出贡献。</h3></div><div class="pj l"><p class="bd b dl z fp pg fr fs ph fu fw dk translated">github.com</p></div></div><div class="pk l"><div class="pl l pm pn po pk pp ko pb"/></div></div></a></div></div><div class="ab cl pq pr hx ps" role="separator"><span class="pt bw bk pu pv pw"/><span class="pt bw bk pu pv pw"/><span class="pt bw bk pu pv"/></div><div class="im in io ip iq"><p id="4d7a" class="pw-post-body-paragraph li lj it lk b ll mf ju ln lo mg jx lq lr mh lt lu lv mi lx ly lz mj mb mc md im bi translated">非常感谢你阅读我的文章。<em class="me">如果你喜欢这个故事，请</em> <strong class="lk iu"> <em class="me">点击</em> </strong>👏<strong class="lk iu"> <em class="me">按钮，分享</em> </strong> <em class="me">它来帮助别人！</em>关注我<a class="ae my" href="https://mr-umbrella.medium.com/" rel="noopener">中</a>T24】获取更多牛逼安卓小技巧。你也可以在<a class="ae my" href="https://www.linkedin.com/in/huynh-phong-3649a7131/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上找到我。祝您愉快！😄</p><h1 id="0b81" class="kq kr it bd ks kt ku kv kw kx ky kz la jz lb ka lc kc ld kd le kf lf kg lg lh bi translated">继续读Android的东西</h1><p id="4198" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><a class="ae my" rel="noopener ugc nofollow" target="_blank" href="/how-to-create-like-button-animation-in-android-part-1-f99e2792143d">如何在Android中创建like按钮动画</a></p><p id="4a6c" class="pw-post-body-paragraph li lj it lk b ll mf ju ln lo mg jx lq lr mh lt lu lv mi lx ly lz mj mb mc md im bi translated"><a class="ae my" rel="noopener ugc nofollow" target="_blank" href="/android-button-morphing-animation-bc3bed740501">安卓按钮变形动画</a></p><p id="69e3" class="pw-post-body-paragraph li lj it lk b ll mf ju ln lo mg jx lq lr mh lt lu lv mi lx ly lz mj mb mc md im bi translated"><a class="ae my" rel="noopener ugc nofollow" target="_blank" href="/motionlayout-collapsing-toolbar-d0ce8dd874b6">运动布局——折叠工具栏</a></p><h1 id="657a" class="kq kr it bd ks kt ku kv kw kx ky kz la jz lb ka lc kc ld kd le kf lf kg lg lh bi translated">Jetpack撰写</h1><p id="b126" class="pw-post-body-paragraph li lj it lk b ll lm ju ln lo lp jx lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><a class="ae my" rel="noopener ugc nofollow" target="_blank" href="/implement-android-snackbar-in-jetpack-compose-d83df5ff5b47">在Jetpack Compose中实现snack bar</a></p><p id="3626" class="pw-post-body-paragraph li lj it lk b ll mf ju ln lo mg jx lq lr mh lt lu lv mi lx ly lz mj mb mc md im bi translated"><a class="ae my" rel="noopener ugc nofollow" target="_blank" href="/implement-android-tablayout-in-jetpack-compose-e61c113add79">在Jetpack Compose中实现tab layout</a></p><p id="8489" class="pw-post-body-paragraph li lj it lk b ll mf ju ln lo mg jx lq lr mh lt lu lv mi lx ly lz mj mb mc md im bi translated"><a class="ae my" rel="noopener ugc nofollow" target="_blank" href="/implement-tablayout-with-viewpager-in-android-jetpack-compose-d509fc6e2d8e">在Jetpack Compose中用ViewPager实现TabLayout】</a></p><p id="f248" class="pw-post-body-paragraph li lj it lk b ll mf ju ln lo mg jx lq lr mh lt lu lv mi lx ly lz mj mb mc md im bi translated"><a class="ae my" rel="noopener ugc nofollow" target="_blank" href="/create-an-auto-scroll-viewpager-with-transformation-and-ken-burns-effect-in-android-jetpack-compose-efdf46f2e8ed">在Jetpack Compose中创建一个带有变形和ken burns效果的自动滚动viewparager</a></p></div></div>    
</body>
</html>