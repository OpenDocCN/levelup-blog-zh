<html>
<head>
<title>Websockets streaming magic — Loading thousands of images in Vue.js.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Websockets streaming magic —在Vue.js中加载成千上万的图像。</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/websockets-streaming-magic-loading-thousands-of-images-in-vue-js-26f29eac5fe6?source=collection_archive---------3-----------------------#2020-12-14">https://levelup.gitconnected.com/websockets-streaming-magic-loading-thousands-of-images-in-vue-js-26f29eac5fe6?source=collection_archive---------3-----------------------#2020-12-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/8dc14a7c9282db2674989a52cd7b6c20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lry5TXj4qyqJGH4HIQmDPg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Eikona照片托管服务(原型)</figcaption></figure><p id="479a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在我的上一篇文章中，我简要地谈到了廉价的、可伸缩的、最重要的是性能良好的基于云的对象存储的重要性。然后，我花时间向您介绍了如何设置和导入您的数据到B2，我目前正在使用。在这篇文章中，我将向你展示我是如何在没有任何加载指示器、屏幕或用户体验中断的情况下，优化加载数千幅图像的(UX)。如果你想继续下去，赶上我们现在的位置，请随时查看我上一篇关于B2的文章。</p><div class="la lb gp gr lc ld"><a href="https://thomasunderwoodii.medium.com/cheap-and-performant-object-storage-for-prototyping-and-production-8664d317dc8e" rel="noopener follow" target="_blank"><div class="le ab fo"><div class="lf ab lg cl cj lh"><h2 class="bd ir gy z fp li fr fs lj fu fw ip bi translated">用于原型制作和生产的廉价且高性能的对象存储。</h2><div class="lk l"><h3 class="bd b gy z fp li fr fs lj fu fw dk translated">如果你一直在关注我过去的一两篇文章，那么你就会知道我正在寻求创造一个高性能的…</h3></div><div class="ll l"><p class="bd b dl z fp li fr fs lj fu fw dk translated">thomasunderwoodii.medium.com</p></div></div><div class="lm l"><div class="ln l lo lp lq lm lr jw ld"/></div></div></a></div><p id="c226" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">任务是:从用户的照片库中加载成千上万的图片。问题是:速度、不同的硬件和网络配置以及成本。让我简单介绍一下我们是如何解决这些不同问题的。</p><p id="6a2a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">性能</strong></p><p id="b8d9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">为了提高性能，我们做了几件事。首先，我们在上传用户图像时对其进行预处理。这意味着，当用户上传他们的图像到Eikona时，我们会创建一个缩略图，它是全分辨率图像的缩小版本。我们将原始图像存储在B2，并将大幅缩小的缩略图(原始照片的1/10或更小)保存在服务器的本地磁盘上。当我们的应用程序加载时，我们提供缩略图。这使得我们可以快速加载数千张图片，而不会降低用户体验。</p><p id="053a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我目前实现了最后一项性能改进。我们在前端和后端服务之间保持一个持久的WebSocket连接，而不是直接将图像与Webpack捆绑在一起，或者同时处理数千个HTTP请求并使浏览器过载。这允许我们在短时间内传输大量数据，并使UX和数据读取看起来无缝。</p><figure class="lt lu lv lw gt jr gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/355fbc425f110424afaada577bc2a3e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*5G6Q9LlnlPRdO4S8rNqHzw.gif"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">一次加载2584张图像(约4秒)</figcaption></figure><p id="ca26" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">成本</strong></p><p id="59a9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">通过使用廉价的基于云的对象存储解决方案，如B2的全分辨率图像，我们能够存储100 GB的照片，每月只需几美元。使用像B2这样的解决方案的另一个成本效益是，我们只需要在运行后端的服务器上保存缩略图，而不是全分辨率图像。这大大降低了运营成本，因为对于照片或视频等大量数据，基于服务器的块存储与基于云的对象存储相比极其昂贵。</p><p id="31be" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">*根据我们的互联网连接速度和用户照片库的大小，我们甚至可以在每次会话前后下载和删除缩略图。</p><p id="ccd3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">变化的硬件和网络</strong></p><p id="f469" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这是一个有趣的问题，我才刚刚开始解决它。大多数性能改进应该也有助于解决这个问题。我提到的性能改进之一是，由于我们使用了WebSockets，现在我们能够将数据流式传输到前端。这对于互联网连接速度较慢或硬件功能较弱的设备来说非常强大。流式数据允许我们将数据分成更小的一口大小的块，并且只发送在特定时间点请求或需要的内容。WebSockets对性能影响最大的是初始连接，之后的一切都非常快。然而，重要的是要跟踪哪些数据已经发送到UI，哪些数据仍然需要流式传输，这与HTTP请求不同，在HTTP请求中，您通常一次获取所有数据，或者尝试根据REST约定将数据拆分。现在，您必须在后端服务级别实现类似于分页的东西。涵盖不同的边缘情况也很重要，例如由于互联网连接不良或浏览器标签被关闭导致的连接断开、浏览器刷新、注销等。</p><figure class="lt lu lv lw gt jr gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/05df8725bf96de96f3309269b8fd3cdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*FRT_lhbAj5jrFnVHV4sU9A.gif"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">每个请求流式传输175张图片(&lt;1s)</figcaption></figure><h1 id="e219" class="lx ly iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">Websocket Implementation Walk-Through</h1><p id="04bc" class="pw-post-body-paragraph kc kd iq ke b kf mv kh ki kj mw kl km kn mx kp kq kr my kt ku kv mz kx ky kz ij bi translated"><strong class="ke ir">*请注意，这是原型代码，没有验证或最终产品代码所需的其他考虑因素。</strong></p><h2 id="986a" class="na ly iq bd lz nb nc dn md nd ne dp mh kn nf ng ml kr nh ni mp kv nj nk mt nl bi translated"><strong class="ak">前端视角</strong></h2><p id="2bf2" class="pw-post-body-paragraph kc kd iq ke b kf mv kh ki kj mw kl km kn mx kp kq kr my kt ku kv mz kx ky kz ij bi translated">让我们一步一步地分解它。</p><h2 id="128d" class="na ly iq bd lz nb nc dn md nd ne dp mh kn nf ng ml kr nh ni mp kv nj nk mt nl bi translated">已创建()</h2><p id="9481" class="pw-post-body-paragraph kc kd iq ke b kf mv kh ki kj mw kl km kn mx kp kq kr my kt ku kv mz kx ky kz ij bi translated">在将任何组件安装到文档对象模型(DOM)并向用户显示之前，在<em class="nm">创建的</em>生命周期挂钩中，WebSocket连接从第一次使用<em class="nm"> this.socket </em>对象实例开始，其中socket.io正在等待从后端发出的<em class="nm"> connect </em>事件。然后是从客户端(前端)Websocket向<em class="nm"> /requestThumbnails </em>发出的第一个事件，以在页面加载之前加载前175个缩略图。这让用户觉得几乎没有加载时间。最后，在unload之前，您会注意到<em class="nm">的事件监听器。</em>该事件监听器是在浏览器刷新时重置当前加载的缩略图所必需的。</p><h2 id="ffaa" class="na ly iq bd lz nb nc dn md nd ne dp mh kn nf ng ml kr nh ni mp kv nj nk mt nl bi translated">已安装()</h2><p id="ff6b" class="pw-post-body-paragraph kc kd iq ke b kf mv kh ki kj mw kl km kn mx kp kq kr my kt ku kv mz kx ky kz ij bi translated">一旦UI通过Vue.js挂载到DOM，就会调用<em class="nm">挂载的</em>生命周期钩子并执行下面的代码。首先，套接字等待来自<em class="nm"> /respondThumbnails的响应。</em>第一次触发<em class="nm">/响应缩略图</em>将响应在<em class="nm">创建的</em>生命周期挂钩中发出的第一个<em class="nm">/请求缩略图</em>事件。值得注意的是，所有的<strong class="ke ir">this . socket . on事件在<em class="nm"> mounted </em>生命周期钩子中总是活动的，因为这是Vue.js生命周期的当前阶段，当用户查看页面时是活动的。一旦<em class="nm"> /respondThumbails </em>接收到一个事件，来自后端的新缩略图数据被添加到当前图像中，并且<em class="nm">进入的</em>状态被设置为假。<em class="nm">进入的</em>状态与图像加载进度条一起使用，我将在下面解释。下面是一个W3schools的链接，我在那里得到了进度条的代码。</strong></p><figure class="lt lu lv lw gt jr"><div class="bz fp l di"><div class="nn no l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">前端Websocket代码</figcaption></figure><div class="la lb gp gr lc ld"><a href="https://www.w3schools.com/howto/howto_js_scroll_indicator.asp" rel="noopener  ugc nofollow" target="_blank"><div class="le ab fo"><div class="lf ab lg cl cj lh"><h2 class="bd ir gy z fp li fr fs lj fu fw ip bi translated">如何创建滚动指示器</h2><div class="lk l"><h3 class="bd b gy z fp li fr fs lj fu fw dk translated">页眉样式:固定位置(始终位于顶部)*/。表头{位置:固定；top:0；z指数:1；宽度:100%…</h3></div><div class="ll l"><p class="bd b dl z fp li fr fs lj fu fw dk translated">www.w3schools.com</p></div></div><div class="lm l"><div class="np l lo lp lq lm lr jw ld"/></div></div></a></div><h2 id="303b" class="na ly iq bd lz nb nc dn md nd ne dp mh kn nf ng ml kr nh ni mp kv nj nk mt nl bi translated">滚动进度条— Websocket流魔术</h2><p id="6985" class="pw-post-body-paragraph kc kd iq ke b kf mv kh ki kj mw kl km kn mx kp kq kr my kt ku kv mz kx ky kz ij bi translated">我无意中发现了使用这个滚动进度条的想法，以便直观地向用户显示他们在查看照片的过程中所处的位置，以及他们已经加载了多少照片。许多人使用观察器(一个不可见的DOM元素),在请求和/或在UI上加载更多数据之前，等待用户在观察器的范围内滚动。我发现这种方法导致了比我希望的更差的用户体验(UX)。我将很快就我的发现写一篇文章。与此同时，我发现使用进度条滚动计算有助于确定用户在页面上的位置，以及他们还能滚动多远。<strong class="ke ir"> </strong>这比观察者惰性加载模式<strong class="ke ir">更有帮助，能创建更好的UX。让我们回到滚动进度条是如何给我灵感来创建一个比使用观察者惰性加载模式更平滑的UX的。当用户滚动时，<em class="nm"> window.onscroll </em>事件触发，下面代码中相应的函数运行。一旦用户滚动超过页面高度的75%，就会向后端发出<em class="nm"> /requestThumbnails </em>事件。这个想法是，相应的响应<em class="nm"> /respondThumbnails </em>在用户达到页面高度的100%之前返回，除非所有的图像都已加载。<em class="nm">输入的</em>变量控制是否可以调用/requestThumbnails。这确保了不会发生对<em class="nm"> /requestThumbnails </em>的多次调用。</strong></p><h2 id="90c0" class="na ly iq bd lz nb nc dn md nd ne dp mh kn nf ng ml kr nh ni mp kv nj nk mt nl bi translated"><strong class="ak">后端透视</strong></h2><p id="40e6" class="pw-post-body-paragraph kc kd iq ke b kf mv kh ki kj mw kl km kn mx kp kq kr my kt ku kv mz kx ky kz ij bi translated">我使用了<em class="nm"> makeMetaData </em>来创建一个指定大小的数组——目前是175。这意味着随着每个<em class="nm"> /requestThumbnails </em>事件返回到UI的图像数量将是175。<em class="nm"> loadThumbNails </em>获取分块的缩略图元数据(175张图像)并将缩略图从服务器硬盘加载到内存中。<em class="nm"> /requestThumbnails </em>遍历所有的元数据数组(每个数组有175个图像块)，根据元数据加载相应的缩略图，并用缩略图响应UI。然后代码推进索引。由于图像数据的流式传输只需要向前进行，并且我们知道初始索引，所以不需要我们使用循环。最后，我们在<em class="nm"> disconnect </em> socket事件中将所有东西的状态重置回初始状态。</p><figure class="lt lu lv lw gt jr"><div class="bz fp l di"><div class="nn no l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">后端Websocket代码</figcaption></figure><p id="6b70" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我希望您喜欢这篇关于Websockets和为web应用程序获得良好的性能、成本和UX的文章。在我的下一篇文章中，我将讨论基于观察器的延迟加载模式与我使用的滚动高度计算方法的优缺点。</p></div></div>    
</body>
</html>