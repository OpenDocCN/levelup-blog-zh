<html>
<head>
<title>When should you use Node.js?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么时候应该使用Node.js？</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/when-should-you-use-node-js-727c7d97fd09?source=collection_archive---------9-----------------------#2021-08-26">https://levelup.gitconnected.com/when-should-you-use-node-js-727c7d97fd09?source=collection_archive---------9-----------------------#2021-08-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b1bd" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">有时候用它是个坏主意</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/48c1346c29fa6ddb7a369958a25c94f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*iohtMNSNC0XQCjlQ.png"/></div></div></figure><p id="ae6f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有许多用于构建应用服务器的编程语言、开发平台、框架和工具。作为一名软件工程师，我们总是必须了解优点和缺点，并根据我们的需要决定何时使用哪种编程语言或工具。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ln"><img src="../Images/e5e1e03372f746e4fbeb2e3bddac940e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gkc6fi9SEnu6d_SP_Pz1-g.png"/></div></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk translated">传统web服务器模型</figcaption></figure><p id="6571" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Node.js兴起之前，大部分服务器都是遵循<strong class="kt ir">传统web服务器模式</strong>。在传统的web服务器模型中，有一个线程池维护多个线程来处理传入的请求。每个请求将由线程池中的特定线程处理。一旦一个线程被分配来处理一个传入的请求，它将返回线程池，直到它完成执行并返回一个响应。如果没有线程来完成请求，那么请求需要等待下一个可用的线程。</p><p id="2450" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">近几十年来，Node.js不仅在初创企业，也在企业公司中迅速发展。亚马逊、网飞、易贝、LinkedIn、Paypal等科技巨头都依赖Node.js作为他们的应用开发环境。</p><p id="e770" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">虽然选择Node.js进行服务器端开发似乎是一种趋势，但是在您的下一个项目中使用它之前，我们需要了解它到底是什么以及它的优缺点。</p><h1 id="1153" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">Node.js是什么？</h1><p id="b9ea" class="pw-post-body-paragraph kr ks iq kt b ku mk jr kw kx ml ju kz la mm lc ld le mn lg lh li mo lk ll lm ij bi translated">Node.js于2009年首次发布，我相信大多数开发人员都听说过它，并且可能正在将其用作web服务解决方案。但并不是每个人都真正了解它的特性。</p><h2 id="9551" class="mp lt iq bd lu mq mr dn ly ms mt dp mc la mu mv me le mw mx mg li my mz mi na bi translated">运行时环境</h2><p id="05a2" class="pw-post-body-paragraph kr ks iq kt b ku mk jr kw kx ml ju kz la mm lc ld le mn lg lh li mo lk ll lm ij bi translated">首先，Node.js不是编程语言或框架，而是一个<strong class="kt ir"> JavaScript运行时环境</strong>。使用Node.js，Javascript代码可以在没有浏览器的情况下执行，这鼓励开发人员仅使用JavaScript构建全栈应用程序。</p><h2 id="e0a3" class="mp lt iq bd lu mq mr dn ly ms mt dp mc la mu mv me le mw mx mg li my mz mi na bi translated"><strong class="ak">非阻塞I/O事件循环</strong></h2><p id="e378" class="pw-post-body-paragraph kr ks iq kt b ku mk jr kw kx ml ju kz la mm lc ld le mn lg lh li mo lk ll lm ij bi translated">Node.js与传统web服务器的另一个主要区别是<strong class="kt ir"> Node.js运行在一个带有事件循环</strong>的单线程上，以执行非阻塞I/O操作。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nb"><img src="../Images/6d6c379395e25671810482ec82240596.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8gXf2PhsqqoPvMlnkx2Ybw.png"/></div></div></figure><p id="d39c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Node.js事件循环在其单线程上执行Javascript代码，并异步处理请求。如果请求由阻塞I/O任务组成，事件循环会将任务传递给内部线程池来处理任何密集型操作。一旦操作完成，负责的线程将通知事件循环。</p><p id="d7f3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是Node.js的特性，它允许您分配更多的系统时间和内存来处理请求，而不是将空间和时间开销浪费在线程上(即上下文切换)。</p><p id="1962" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">总而言之:</p><ul class=""><li id="2997" class="nc nd iq kt b ku kv kx ky la ne le nf li ng lm nh ni nj nk bi translated">Node.js是一个<strong class="kt ir"> Javascript运行时环境</strong></li><li id="fada" class="nc nd iq kt b ku nl kx nm la nn le no li np lm nh ni nj nk bi translated">Node.js有一个<strong class="kt ir">事件循环</strong>来处理非阻塞和事件驱动的I/O操作</li></ul><h1 id="f35a" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">什么时候用Node.js？</h1><p id="6188" class="pw-post-body-paragraph kr ks iq kt b ku mk jr kw kx ml ju kz la mm lc ld le mn lg lh li mo lk ll lm ij bi translated">现在我们对Node.js有了一个简单的了解。让我们看看如何利用它的优势来最大化我们的应用程序性能。</p><h2 id="1c48" class="mp lt iq bd lu mq mr dn ly ms mt dp mc la mu mv me le mw mx mg li my mz mi na bi translated">API应用程序</h2><p id="0d90" class="pw-post-body-paragraph kr ks iq kt b ku mk jr kw kx ml ju kz la mm lc ld le mn lg lh li mo lk ll lm ij bi translated">对于用关系和非关系数据库构建API应用程序，Node.js也是一个很好的选择。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/707a1a3267439894d378f33c6cecde87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xC6p1j1qntmoOfwT_QDB5g.png"/></div></div></figure><p id="62a4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Node.js为什么适合？都是因为有事件循环的<strong class="kt ir">单线程。这使得:</strong></p><ul class=""><li id="cf44" class="nc nd iq kt b ku kv kx ky la ne le nf li ng lm nh ni nj nk bi translated">Node.js在单线程上运行，这使得处理多达10，000个并发请求变得更加容易</li><li id="40cd" class="nc nd iq kt b ku nl kx nm la nn le no li np lm nh ni nj nk bi translated">所有阻塞的I/O任务(即数据库访问)总是由内部线程异步处理，而不会中断主线程</li></ul><p id="eff1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这使得Node.js可以很好地处理请求、进行数据库操作以及为客户端公开JSON对象。过去，有人说Node.js只适合非关系数据库，因为缺少关系数据库的ORM。但是现在有很多成熟的ORM解决方案，如<a class="ae nr" href="https://sequelize.org/master/" rel="noopener ugc nofollow" target="_blank">序列</a>来查询和操作关系数据库中的数据。</p><h2 id="5b94" class="mp lt iq bd lu mq mr dn ly ms mt dp mc la mu mv me le mw mx mg li my mz mi na bi translated">实时应用</h2><p id="c7db" class="pw-post-body-paragraph kr ks iq kt b ku mk jr kw kx ml ju kz la mm lc ld le mn lg lh li mo lk ll lm ij bi translated">由于事件驱动和异步的特性，Node.js擅长构建实时应用程序，如消息传递、通知交付、直播和协作工具。</p><p id="4bd1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们以消息应用程序为例。消息应用程序是:</p><ul class=""><li id="585a" class="nc nd iq kt b ku kv kx ky la ne le nf li ng lm nh ni nj nk bi translated">轻量级选手</li><li id="8ccb" class="nc nd iq kt b ku nl kx nm la nn le no li np lm nh ni nj nk bi translated">高流量</li><li id="3acb" class="nc nd iq kt b ku nl kx nm la nn le no li np lm nh ni nj nk bi translated">数据密集型，但需要少量计算能力</li></ul><p id="299d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Node.js非常适合实现消息传递应用程序。</p><p id="209d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae nr" href="https://socket.io/" rel="noopener ugc nofollow" target="_blank"> Socket.io </a>，一个用于实时和双向通信的JavaScript库，可用于更容易和更快地构建消息应用程序。它使用带有HTTP长轮询的<a class="ae nr" href="https://en.wikipedia.org/wiki/WebSocket" rel="noopener ugc nofollow" target="_blank"> WebSocket </a>协议作为后备选项，不仅提供消息传递功能，还提供二进制流、文档协作和实时分析功能。</p><h2 id="35e5" class="mp lt iq bd lu mq mr dn ly ms mt dp mc la mu mv me le mw mx mg li my mz mi na bi translated">微服务</h2><p id="3682" class="pw-post-body-paragraph kr ks iq kt b ku mk jr kw kx ml ju kz la mm lc ld le mn lg lh li mo lk ll lm ij bi translated">除此之外，Node还可以用于构建微服务——一种基于将应用程序构建为小型服务集合的架构方法。每个微服务都有自己的数据模型，管理自己的数据。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/ea6e934f25f287fb010f04d7944f09c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CPtvhQIc7OdW7WaBGnC6xA.png"/></div></div></figure><p id="e70d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">构建微服务的编程语言有很多。其中一个就是NodeJS。那么，Node.js的特性如何让它成为微服务的最佳选择之一呢？</p><ul class=""><li id="852d" class="nc nd iq kt b ku kv kx ky la ne le nf li ng lm nh ni nj nk bi translated">Node.js将I/O任务分配给内部IO线程，而不会阻塞主线程</li><li id="7f2f" class="nc nd iq kt b ku nl kx nm la nn le no li np lm nh ni nj nk bi translated">Node.js使用可以高度解耦的事件驱动架构</li></ul><p id="3a86" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有了微服务，大规模的系统可以分解成小块的微服务，并独立部署。每个微服务可以有更高的自主性，可以自由伸缩。</p><h1 id="658b" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">什么时候不用Node.js？</h1><p id="1239" class="pw-post-body-paragraph kr ks iq kt b ku mk jr kw kx ml ju kz la mm lc ld le mn lg lh li mo lk ll lm ij bi translated">然而，每种编程语言都有其缺点。</p><h2 id="024b" class="mp lt iq bd lu mq mr dn ly ms mt dp mc la mu mv me le mw mx mg li my mz mi na bi translated">CPU密集型任务</h2><p id="d660" class="pw-post-body-paragraph kr ks iq kt b ku mk jr kw kx ml ju kz la mm lc ld le mn lg lh li mo lk ll lm ij bi translated">当涉及到繁重的计算时，Node.js并不是最好的解决方案。运行在单线程上的事件循环在处理CPU密集型任务方面很弱。</p><p id="e7f0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">事件循环负责来自客户端的每个传入请求，并将I/O任务传递给内部线程。但是，这个事件循环运行在一个线程上。当线程被所有其他任务阻塞时，传入的请求必须等待线程被解除阻塞才能被处理。</p><h1 id="da4f" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结论</h1><p id="a833" class="pw-post-body-paragraph kr ks iq kt b ku mk jr kw kx ml ju kz la mm lc ld le mn lg lh li mo lk ll lm ij bi translated">毫无疑问，Node.js与传统的web服务器模型非常不同。它的事件循环尽可能将I/O操作卸载到系统内核。然而，我们必须意识到其事件循环的弱点。<strong class="kt ir">千万不要用Nodejs来解决计算伸缩问题</strong>。</p></div><div class="ab cl nt nu hu nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="ij ik il im in"><p id="4612" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">希望你对Node.js的特点有更好的了解，以及什么时候应该使用。</p><p id="b22d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">要了解更多关于我的后端学习路径，请点击这里查看我的旅程:</p><div class="oa ob gp gr oc od"><a href="https://mattchw.medium.com/my-backend-developer-learning-journey-%E6%88%91%E7%9A%84%E5%BE%8C%E7%AB%AF%E5%AD%B8%E7%BF%92%E4%B9%8B%E6%97%85-5315fe2fefc2" rel="noopener follow" target="_blank"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd ir gy z fp oi fr fs oj fu fw ip bi">My Backend Developer Learning Journey 我的後端學習之旅</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">毕业一年多了。拥有2年以上的前端和后端工作经验…</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">mattchw.medium.com</p></div></div><div class="om l"><div class="on l oo op oq om or kp od"/></div></div></a></div></div></div>    
</body>
</html>