<html>
<head>
<title>How to write performant React code: rules, patterns, do’s and don’ts</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何编写performant React代码:规则、模式、该做什么和不该做什么</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-write-performant-react-code-rules-patterns-dos-and-don-ts-89056af11ede?source=collection_archive---------4-----------------------#2022-01-12">https://levelup.gitconnected.com/how-to-write-performant-react-code-rules-patterns-dos-and-don-ts-89056af11ede?source=collection_archive---------4-----------------------#2022-01-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/e8f7f81636b4a61fe84162ceb4025271.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UK6zVXpR46PEb0G_AqsgSg.jpeg"/></div></div></figure><p id="6d3d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">性能和反应！如此有趣的话题，却有如此多有争议的观点和如此多的最佳实践，却在短短6个月内变成了反面。有没有可能在这里说些明确的话，或者提些笼统的建议？</p><p id="4e01" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通常，性能专家是“过早优化是万恶之源”和“度量优先”规则的支持者。大致翻译过来就是“不要修理没有坏的东西”，这一点很难反驳。但是我还是要去😉</p><p id="b232" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我喜欢React的一点是，它让实现复杂的UI交互变得异常简单。我不喜欢React的一点是，它也让我们非常容易犯错误，而这些错误会带来无法立即看到的巨大后果。好消息是，防止这些错误并立即编写大多数情况下都是高性能的代码也非常容易，从而大大减少了调查性能问题所需的时间和精力，因为这样的问题会少得多。基本上，当涉及到反应和性能时，“过早优化”实际上是一件好事，是每个人都应该做的事情😉。你只需要知道一些要注意的模式，就能有意义地做到这一点。</p><p id="cc76" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以这正是我想在这篇文章中证明的😊。我将通过一步一步地实现一个“现实生活”的应用程序来做到这一点，首先以一种“正常”的方式，使用你几乎在任何地方都能看到的模式，并且你自己肯定会多次使用这些模式。然后在考虑性能的情况下重构每一步，从每一步中提炼出一个可以在大多数时候适用于大多数app的通用规则。然后最后比较结果。</p><p id="2d67" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们开始吧！</p><p id="0fd3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将为一个在线商店编写一个“设置”页面(我们在以前的“React开发人员的高级类型脚本”文章中介绍过)。在该页面上，用户可以从列表中选择一个国家，查看该国家的所有可用信息(如货币、交付方式等)，然后将该国家保存为他们选择的国家。该页面看起来会像这样:</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi kw"><img src="../Images/0c83d6f710bb5de584d9a1a21ceaad92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*v4Febg4DzA3jKnSp.png"/></div></div></figure><p id="bf70" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在左侧，我们将有一个国家的列表，有“保存”和“选择”状态，当列表中的一个项目被单击时，在右侧的列中显示详细信息。当按下“保存”按钮时,“选定”的国家/地区变为“已保存”,带有不同的项目颜色。</p><p id="9dd8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">哦，我们当然希望那里是黑暗模式，毕竟现在是2022年！</p><p id="c457" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此外，考虑到React中90%的性能问题可以总结为“太多的重新渲染”，我们将主要关注减少文章中的这些问题。(另外10%是:“渲染太重”和“需要进一步调查的非常奇怪的东西”。)</p><h1 id="bfe0" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">让我们首先构建我们的应用程序</h1><p id="1a64" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">首先，让我们看看设计，画出想象中的边界，并起草我们未来应用程序的结构，以及我们需要在那里实现哪些组件:</p><ul class=""><li id="7e67" class="me mf iq ka b kb kc kf kg kj mg kn mh kr mi kv mj mk ml mm bi translated">一个根“页面”组件，我们在其中处理“提交”逻辑和国家选择逻辑</li><li id="c21d" class="me mf iq ka b kb mn kf mo kj mp kn mq kr mr kv mj mk ml mm bi translated">一个“国家列表”组件，将所有国家呈现在一个列表中，并在未来处理像过滤和排序的事情</li><li id="b142" class="me mf iq ka b kb mn kf mo kj mp kn mq kr mr kv mj mk ml mm bi translated">“Item”组件，它将国家呈现在“国家列表”中</li><li id="708c" class="me mf iq ka b kb mn kf mo kj mp kn mq kr mr kv mj mk ml mm bi translated">一个“选择的国家”组件，提供关于选择的国家的详细信息，并有“保存”按钮</li></ul><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi kw"><img src="../Images/77a4027cfab5bd32955b487860f06a55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*63RUYTexQf21qHqN.png"/></div></div></figure><p id="6f2e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当然，这不是实现这个页面的唯一可能的方式，这就是React的优点和缺点:任何事情都可以用一百万种方式实现，任何事情都没有正确或错误的答案。但从长远来看，在快速增长或已经很大的应用程序中，有一些模式绝对可以被称为<strong class="ka ir">“永远不要这样做”</strong>或<strong class="ka ir">“这是必须的”</strong>。</p><p id="c3fa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们看看我们是否能一起解决它们🙂</p><h1 id="e757" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">实现页面组件</h1><p id="e1f5" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">现在，终于到了动手做一些编码的时候了。让我们从“根”开始，实现页面组件。</p><p id="182d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先:我们需要一个具有一些风格的包装器，呈现页面标题，“国家列表”和“选定的国家”组件。</p><p id="a18b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第二:我们的页面应该从某个地方接收国家列表，然后将它传递给<code class="fe ms mt mu mv b">CountriesList</code>组件，以便它可以呈现这些列表。</p><p id="3c98" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第三:我们的页面应该有一个“选定”国家的概念，它将从<code class="fe ms mt mu mv b">CountriesList</code>组件接收并传递给<code class="fe ms mt mu mv b">SelectedCountry</code>组件。</p><p id="3a4d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后:我们的页面应该有一个“保存”国家的概念，它将从<code class="fe ms mt mu mv b">SelectedCountry</code>组件接收并传递给<code class="fe ms mt mu mv b">CountriesList</code>组件(并在将来发送到后端)。</p><pre class="kx ky kz la gt mw mv mx my aw mz bi"><span id="056a" class="na lc iq mv b gy nb nc l nd ne"><em class="nf">export const Page = ({ countries }: { countries: Country[] }) =&gt; {<br/>  const [selectedCountry, setSelectedCountry] = useState&lt;Country&gt;(countries[0]);<br/>  const [savedCountry, setSavedCountry] = useState&lt;Country&gt;(countries[0]);<br/><br/>  return (<br/>    &lt;&gt;<br/>      &lt;h1&gt;Country settings&lt;/h1&gt;<br/>      &lt;div css={contentCss}&gt;<br/>        &lt;CountriesList<br/>          countries={countries}<br/>          onCountryChanged={(c) =&gt; setSelectedCountry(c)}<br/>          savedCountry={savedCountry}<br/>        /&gt;<br/>        &lt;SelectedCountry<br/>          country={selectedCountry}<br/>          onCountrySaved={() =&gt; setSavedCountry(selectedCountry)}<br/>        /&gt;<br/>      &lt;/div&gt;<br/>    &lt;/&gt;<br/>  );<br/>};</em></span></pre><p id="b311" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是“页面”组件的完整实现，它是随处可见的最基本的反应，在这个实现中绝对没有任何犯罪行为。除了一件事。好奇，能看到吗？</p><h1 id="bea3" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">重构页面组件—考虑性能</h1><p id="2bcc" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">我想现在大家都知道，当状态或道具改变时，react会重新渲染组件。在我们的页面组件中，当调用<code class="fe ms mt mu mv b">setSelectedCountry</code>或<code class="fe ms mt mu mv b">setSavedCountry</code>时，它会重新呈现。如果我们的页面组件中的国家数组(props)发生变化，它将重新呈现。同样的道理也适用于<code class="fe ms mt mu mv b">CountriesList</code>和<code class="fe ms mt mu mv b">SelectedCountry</code>组件——当它们的任何道具改变时，它们会重新渲染。</p><p id="adda" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此外，任何使用过React的人都知道javascript <a class="ae ng" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness" rel="noopener ugc nofollow" target="_blank">相等比较</a>，React对props进行严格的相等比较，内联函数每次都创造新的值。这导致了一个非常普遍的(而且绝对错误的)想法，为了减少<code class="fe ms mt mu mv b">CountriesList</code>和<code class="fe ms mt mu mv b">SelectedCountry</code>组件的重新渲染，我们需要通过在<code class="fe ms mt mu mv b">useCallback</code>中包装内联函数来避免在每次渲染时重新创建内联函数。甚至<a class="ae ng" href="https://reactjs.org/docs/hooks-reference.html#usecallback" rel="noopener ugc nofollow" target="_blank"> React docs </a>在同一句话中提到<code class="fe ms mt mu mv b">useCallback</code>与“防止不必要的渲染”！看看这个模式是否眼熟:</p><pre class="kx ky kz la gt mw mv mx my aw mz bi"><span id="ab0d" class="na lc iq mv b gy nb nc l nd ne"><em class="nf">export const Page = ({ countries }: { countries: Country[] }) =&gt; {<br/>  // ... same as before<br/><br/>  const onCountryChanged = useCallback((c) =&gt; setSelectedCountry(c), []);<br/>  const onCountrySaved = useCallback(() =&gt; setSavedCountry(selectedCountry), []);<br/><br/>  return (<br/>    &lt;&gt;<br/>      ...<br/>        &lt;CountriesList<br/>          onCountryChanged={onCountryChange}<br/>        /&gt;<br/>        &lt;SelectedCountry<br/>          onCountrySaved={onCountrySaved}<br/>        /&gt;<br/>      ...<br/>    &lt;/&gt;<br/>  );<br/>};</em></span></pre><p id="103a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你知道最有趣的是什么吗？它实际上<strong class="ka ir">不起作用</strong>。因为它没有考虑React组件被重渲染的第三个原因:<strong class="ka ir">父组件被重渲染的时候</strong>。不管是什么道具，<code class="fe ms mt mu mv b">CountriesList</code>都会在页面重新渲染的时候重新渲染，即使它根本没有任何道具。</p><p id="5c1c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以将页面示例简化为:</p><pre class="kx ky kz la gt mw mv mx my aw mz bi"><span id="a2fb" class="na lc iq mv b gy nb nc l nd ne"><em class="nf">const CountriesList = () =&gt; {<br/>  console.log("Re-render!!!!!");<br/>  return &lt;div&gt;countries list, always re-renders&lt;/div&gt;;<br/>};<br/><br/>export const Page = ({ countries }: { countries: Country[] }) =&gt; {<br/>  const [counter, setCounter] = useState&lt;number&gt;(1);<br/><br/>  return (<br/>    &lt;&gt;<br/>      &lt;h1&gt;Country settings&lt;/h1&gt;<br/>      &lt;button onClick={() =&gt; setCounter(counter + 1)}&gt;<br/>        Click here to re-render Countries list (open the console) {counter}<br/>      &lt;/button&gt;<br/>      &lt;CountriesList /&gt;<br/>    &lt;/&gt;<br/>  );<br/>};</em></span></pre><p id="3a74" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">而我们每次点击按钮，都会看到<code class="fe ms mt mu mv b">CountriesList</code>被重新渲染，<strong class="ka ir">即使它根本没有任何道具</strong>。<a class="ae ng" href="https://codesandbox.io/s/re-renders-simplified-bad-1giei?file=/src/country-settings/page.tsx" rel="noopener ugc nofollow" target="_blank"> Codesandbox代码在这里</a>。</p><p id="d821" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，这让我们巩固了本文的第一条规则:</p><blockquote class="nh ni nj"><p id="62d2" class="jy jz nf ka b kb kc kd ke kf kg kh ki nk kk kl km nl ko kp kq nm ks kt ku kv ij bi translated"><strong class="ka ir">规则1。如果你想将props中的内联函数提取到useCallback中的唯一原因是为了避免子组件的重新呈现:不要。它不起作用。</strong></p></blockquote><p id="6d37" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，有几种方法来处理上述情况，我将在这个特殊的场合使用最简单的方法。它所做的是本质上“缓存”你传递给它的任何函数的结果，并且只在<code class="fe ms mt mu mv b">useMemo</code>的<em class="nf">依赖</em>改变时刷新它们。如果我只是将渲染后的<code class="fe ms mt mu mv b">CountriesList</code>提取到一个变量<code class="fe ms mt mu mv b">const list = &lt;ComponentList /&gt;;</code>中，然后对其应用<code class="fe ms mt mu mv b">useMemo</code>，那么只有当useMemo依赖关系改变时，<code class="fe ms mt mu mv b">ComponentList</code>组件才会被重新渲染<strong class="ka ir">。</strong></p><pre class="kx ky kz la gt mw mv mx my aw mz bi"><span id="b56a" class="na lc iq mv b gy nb nc l nd ne"><em class="nf">export const Page = ({ countries }: { countries: Country[] }) =&gt; {<br/>  const [counter, setCounter] = useState&lt;number&gt;(1);<br/><br/>  const list = useMemo(() =&gt; {<br/>    return &lt;CountriesList /&gt;;<br/>  }, []);<br/><br/>  return (<br/>    &lt;&gt;<br/>      &lt;h1&gt;Country settings&lt;/h1&gt;<br/>      &lt;button onClick={() =&gt; setCounter(counter + 1)}&gt;<br/>        Click here to re-render Countries list (open the console) {counter}<br/>      &lt;/button&gt;<br/>      {list}<br/>    &lt;/&gt;<br/>  );<br/>};</em></span></pre><p id="871e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本例中是never，因为它没有任何依赖关系。这种模式基本上允许我打破这种“父元素重新渲染—重新渲染所有子元素”的循环，并控制它。查看codesandbox 中的<a class="ae ng" href="https://codesandbox.io/s/re-renders-simplified-memo-xcv5f?file=/src/country-settings/page.tsx" rel="noopener ugc nofollow" target="_blank">完整示例。</a></p><p id="86f0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">需要注意的最重要的事情是<code class="fe ms mt mu mv b">useMemo</code>的依赖列表。如果它依赖于导致父组件重新渲染的完全相同的东西，那么它将在每次重新渲染时刷新其缓存，并且基本上变得无用。例如，在这个简化的例子中，如果我将<code class="fe ms mt mu mv b">counter</code>值作为依赖项传递给<code class="fe ms mt mu mv b">list</code>变量(注意:甚至不是memoised组件的属性！)，这将导致<code class="fe ms mt mu mv b">useMemo</code>在每次状态改变时刷新自己，并将使<code class="fe ms mt mu mv b">CountriesList</code>再次重新渲染。</p><pre class="kx ky kz la gt mw mv mx my aw mz bi"><span id="d3a1" class="na lc iq mv b gy nb nc l nd ne"><em class="nf">const list = useMemo(() =&gt; {<br/>  return (<br/>    &lt;&gt;<br/>      {counter}<br/>      &lt;CountriesList /&gt;<br/>    &lt;/&gt;<br/>  );<br/>}, [counter]);</em></span></pre><p id="5726" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae ng" href="https://codesandbox.io/s/re-renders-simplified-memo-with-dep-9h433?file=/src/country-settings/page.tsx:363-491" rel="noopener ugc nofollow" target="_blank">参见codesandbox示例。</a></p><p id="5208" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好的，所有这些都很棒，但是如何才能将它应用到我们的非简化页面组件中呢？如果我们再次仔细观察它的实现</p><pre class="kx ky kz la gt mw mv mx my aw mz bi"><span id="1cd8" class="na lc iq mv b gy nb nc l nd ne"><em class="nf">export const Page = ({ countries }: { countries: Country[] }) =&gt; {<br/>  const [selectedCountry, setSelectedCountry] = useState&lt;Country&gt;(countries[0]);<br/>  const [savedCountry, setSavedCountry] = useState&lt;Country&gt;(countries[0]);<br/><br/>  return (<br/>    &lt;&gt;<br/>      &lt;h1&gt;Country settings&lt;/h1&gt;<br/>      &lt;div css={contentCss}&gt;<br/>        &lt;CountriesList<br/>          countries={countries}<br/>          onCountryChanged={(c) =&gt; setSelectedCountry(c)}<br/>          savedCountry={savedCountry}<br/>        /&gt;<br/>        &lt;SelectedCountry<br/>          country={selectedCountry}<br/>          onCountrySaved={() =&gt; setSavedCountry(selectedCountry)}<br/>        /&gt;<br/>      &lt;/div&gt;<br/>    &lt;/&gt;<br/>  );<br/>};</em></span></pre><p id="82ae" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们会看到:</p><ul class=""><li id="fe90" class="me mf iq ka b kb kc kf kg kj mg kn mh kr mi kv mj mk ml mm bi translated"><code class="fe ms mt mu mv b">selectedCountry</code>状态从不用于<code class="fe ms mt mu mv b">CountriesList</code>组件</li><li id="7511" class="me mf iq ka b kb mn kf mo kj mp kn mq kr mr kv mj mk ml mm bi translated"><code class="fe ms mt mu mv b">savedCountry</code>状态从不用于<code class="fe ms mt mu mv b">SelectedCountry</code>组件</li></ul><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nn"><img src="../Images/6f8ea303478b9a21e11b166fdeb6e2c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*tI_0Hid1PabstzLw.png"/></div></div></figure><p id="3941" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">也就是说当<code class="fe ms mt mu mv b">selectedCountry</code>状态改变时，<code class="fe ms mt mu mv b">CountriesList</code>组件根本不需要重新渲染！而同样的故事还有着<code class="fe ms mt mu mv b">savedCountry</code>的状态和<code class="fe ms mt mu mv b">SelectedCountry</code>的成分。我可以将它们都提取到变量中，并对它们进行优化，以防止不必要的重新渲染:</p><pre class="kx ky kz la gt mw mv mx my aw mz bi"><span id="a23d" class="na lc iq mv b gy nb nc l nd ne"><em class="nf">export const Page = ({ countries }: { countries: Country[] }) =&gt; {<br/>  const [selectedCountry, setSelectedCountry] = useState&lt;Country&gt;(countries[0]);<br/>  const [savedCountry, setSavedCountry] = useState&lt;Country&gt;(countries[0]);<br/><br/>  const list = useMemo(() =&gt; {<br/>    return (<br/>      &lt;CountriesList<br/>        countries={countries}<br/>        onCountryChanged={(c) =&gt; setSelectedCountry(c)}<br/>        savedCountry={savedCountry}<br/>      /&gt;<br/>    );<br/>  }, [savedCountry, countries]);<br/><br/>  const selected = useMemo(() =&gt; {<br/>    return (<br/>      &lt;SelectedCountry<br/>        country={selectedCountry}<br/>        onCountrySaved={() =&gt; setSavedCountry(selectedCountry)}<br/>      /&gt;<br/>    );<br/>  }, [selectedCountry]);<br/><br/>  return (<br/>    &lt;&gt;<br/>      &lt;h1&gt;Country settings&lt;/h1&gt;<br/>      &lt;div css={contentCss}&gt;<br/>        {list}<br/>        {selected}<br/>      &lt;/div&gt;<br/>    &lt;/&gt;<br/>  );<br/>};</em></span></pre><p id="eaed" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，让我们正式确定本文的第二条规则:</p><blockquote class="nh ni nj"><p id="5dc1" class="jy jz nf ka b kb kc kd ke kf kg kh ki nk kk kl km nl ko kp kq nm ks kt ku kv ij bi translated"><strong class="ka ir">规则#2 </strong>。如果您的组件管理状态，请找到渲染树中不依赖于已更改状态的部分，并对它们进行优化，以最小化它们的重新渲染。</p></blockquote><h1 id="71cf" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">实施国家清单</h1><p id="fd43" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">现在，我们的页面组件已经准备就绪，是时候充实它的子组件了。首先，让我们实现复杂的组件:<code class="fe ms mt mu mv b">CountriesList</code>。我们已经知道，这个组件应该接受国家列表，当在列表中选择一个国家时应该触发<code class="fe ms mt mu mv b">onCountryChanged</code>回调，并且应该根据设计将<code class="fe ms mt mu mv b">savedCountry</code>突出显示为不同的颜色。所以让我们从最简单的方法开始:</p><pre class="kx ky kz la gt mw mv mx my aw mz bi"><span id="3785" class="na lc iq mv b gy nb nc l nd ne"><em class="nf">type CountriesListProps = {<br/>  countries: Country[];<br/>  onCountryChanged: (country: Country) =&gt; void;<br/>  savedCountry: Country;<br/>};<br/><br/>export const CountriesList = ({<br/>  countries,<br/>  onCountryChanged,<br/>  savedCountry<br/>}: CountriesListProps) =&gt; {<br/>  const Item = ({ country }: { country: Country }) =&gt; {<br/>    // different className based on whether this item is "saved" or not<br/>    const className = savedCountry.id === country.id ? "country-item saved" : "country-item";<br/><br/>    // when the item is clicked - trigger the callback from props with the correct country in the arguments<br/>    const onItemClick = () =&gt; onCountryChanged(country);<br/>    return (<br/>      &lt;button className={className} onClick={onItemClick}&gt;<br/>        &lt;img src={country.flagUrl} /&gt;<br/>        &lt;span&gt;{country.name}&lt;/span&gt;<br/>      &lt;/button&gt;<br/>    );<br/>  };<br/><br/>  return (<br/>    &lt;div&gt;<br/>      {countries.map((country) =&gt; (<br/>        &lt;Item country={country} key={country.id} /&gt;<br/>      ))}<br/>    &lt;/div&gt;<br/>  );<br/>};</em></span></pre><p id="17d5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">再说一遍，最简单的组件，实际上只发生了两件事:</p><ul class=""><li id="9d78" class="me mf iq ka b kb kc kf kg kj mg kn mh kr mi kv mj mk ml mm bi translated">我们根据收到的道具生成<code class="fe ms mt mu mv b">Item</code>(这取决于<code class="fe ms mt mu mv b">onCountryChanged</code>和<code class="fe ms mt mu mv b">savedCountry</code>)</li><li id="6648" class="me mf iq ka b kb mn kf mo kj mp kn mq kr mr kv mj mk ml mm bi translated">我们在一个循环中为所有国家渲染这个<code class="fe ms mt mu mv b">Item</code></li></ul><p id="b055" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">再说一次，这种<em class="nf">本身并没有什么犯罪的成分，我已经看到这种模式在很多地方被使用。</em></p><h1 id="877f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">重构国家列表组件—考虑性能</h1><p id="ff6d" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">又到了更新React如何渲染事物的知识的时候了，这次——如果一个组件，比如上面的<code class="fe ms mt mu mv b">Item</code>组件，在另一个组件渲染期间被创建<em class="nf">，会发生什么？简而言之，没什么好的，真的。从React的角度来看，这个<code class="fe ms mt mu mv b">Item</code>只是一个在每次渲染时都是新的函数，它在每次渲染时都返回一个新的结果。因此，它将在<strong class="ka ir">每次渲染</strong>时从头开始重新创建该函数的结果，也就是说，它只会将之前的组件状态与当前状态进行比较，就像正常重新渲染时发生的一样。它将删除以前生成的组件，包括它的DOM树，将它从页面中删除，并生成和安装一个全新的组件，每次重新呈现父组件时都有一个全新的DOM树。</em></p><p id="fd93" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们简化国家的例子来说明这种影响，结果将是这样的:</p><pre class="kx ky kz la gt mw mv mx my aw mz bi"><span id="823b" class="na lc iq mv b gy nb nc l nd ne"><em class="nf">const CountriesList = ({ countries }: { countries: Country[] }) =&gt; {<br/>  const Item = ({ country }: { country: Country }) =&gt; {<br/>    useEffect(() =&gt; {<br/>      console.log("Mounted!");<br/>    }, []);<br/>    console.log("Render");<br/>    return &lt;div&gt;{country.name}&lt;/div&gt;;<br/>  };<br/><br/>  return (<br/>    &lt;&gt;<br/>      {countries.map((country) =&gt; (<br/>        &lt;Item country={country} /&gt;<br/>      ))}<br/>    &lt;/&gt;<br/>  );<br/>};</em></span></pre><p id="7b0f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是他们所有反应中最重的一次行动。从性能角度来看，10次“正常”重新渲染与完全重新安装一个新创建的组件相比根本不算什么。在正常情况下，一个空的依赖数组只会被触发一次——在组件完成安装和第一次渲染之后。之后，React中的轻量级重新渲染过程开始，组件不是从头开始创建的，而是只在需要时更新(这就是React如此快速的原因)。但在这种情况下不会——看看<a class="ae ng" href="https://codesandbox.io/s/creating-components-in-render-bad-8otem?file=/src/country-settings/page.tsx" rel="noopener ugc nofollow" target="_blank">这个代码沙箱</a>,在打开的控制台上点击“重新渲染”按钮，享受每次点击都会发生的250次渲染和安装。</p><p id="a611" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">解决这个问题的方法显而易见:我们只需要将<code class="fe ms mt mu mv b">Item</code>组件移出渲染函数。</p><pre class="kx ky kz la gt mw mv mx my aw mz bi"><span id="4e5b" class="na lc iq mv b gy nb nc l nd ne"><em class="nf">const Item = ({ country }: { country: Country }) =&gt; {<br/>  useEffect(() =&gt; {<br/>    console.log("Mounted!");<br/>  }, []);<br/>  console.log("Render");<br/>  return &lt;div&gt;{country.name}&lt;/div&gt;;<br/>};<br/><br/>const CountriesList = ({ countries }: { countries: Country[] }) =&gt; {<br/>  return (<br/>    &lt;&gt;<br/>      {countries.map((country) =&gt; (<br/>        &lt;Item country={country} /&gt;<br/>      ))}<br/>    &lt;/&gt;<br/>  );<br/>};</em></span></pre><p id="3c23" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，在我们的<a class="ae ng" href="https://codesandbox.io/s/creating-components-in-render-fixed-cs7pe?file=/src/country-settings/page.tsx" rel="noopener ugc nofollow" target="_blank">简化的codesandbox </a>中，不会在每次重新渲染父组件时进行挂载。</p><p id="5444" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另外，像这样的重构有助于保持不同组件之间的健康界限，并保持代码更干净、更简洁。当我们将这种改进应用到我们的“真正的”应用程序时，这将变得尤其明显。之前:</p><pre class="kx ky kz la gt mw mv mx my aw mz bi"><span id="b6fd" class="na lc iq mv b gy nb nc l nd ne"><em class="nf">export const CountriesList = ({<br/>  countries,<br/>  onCountryChanged,<br/>  savedCountry<br/>}: CountriesListProps) =&gt; {<br/><br/>  // only "country" in props<br/>  const Item = ({ country }: { country: Country }) =&gt; {<br/>    // ... same code<br/>  };<br/><br/>  return (<br/>    &lt;div&gt;<br/>      {countries.map((country) =&gt; (<br/>        &lt;Item country={country} key={country.id} /&gt;<br/>      ))}<br/>    &lt;/div&gt;<br/>  );<br/>};</em></span></pre><p id="d745" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">之后:</p><pre class="kx ky kz la gt mw mv mx my aw mz bi"><span id="4148" class="na lc iq mv b gy nb nc l nd ne"><em class="nf">type ItemProps = {<br/>  country: Country;<br/>  savedCountry: Country;<br/>  onItemClick: () =&gt; void;<br/>};<br/><br/>// turned out savedCountry and onItemClick were also used<br/>// but it was not obvious at all in the previous implementation<br/>const Item = ({ country, savedCountry, onItemClick }: ItemProps) =&gt; {<br/>  // ... same code<br/>};<br/><br/>export const CountriesList = ({<br/>  countries,<br/>  onCountryChanged,<br/>  savedCountry<br/>}: CountriesListProps) =&gt; {<br/>  return (<br/>    &lt;div&gt;<br/>      {countries.map((country) =&gt; (<br/>        &lt;Item<br/>          country={country}<br/>          key={country.id}<br/>          savedCountry={savedCountry}<br/>          onItemClick={() =&gt; onCountryChanged(country)}<br/>        /&gt;<br/>      ))}<br/>    &lt;/div&gt;<br/>  );<br/>};</em></span></pre><p id="21d4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们摆脱了每次重新呈现父组件时重新装载<code class="fe ms mt mu mv b">Item</code>组件的问题，我们可以提取文章的第三条规则:</p><blockquote class="nh ni nj"><p id="c75e" class="jy jz nf ka b kb kc kd ke kf kg kh ki nk kk kl km nl ko kp kq nm ks kt ku kv ij bi translated"><strong class="ka ir">规则三</strong>。不要在另一个组件的渲染函数中创建新的组件。</p></blockquote><h1 id="61e4" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">实施选定的国家</h1><p id="b953" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">下一步:组件“选定的国家”,这将是文章中最短也是最无聊的部分，因为这里没有什么可展示的:它只是一个接受属性和回调并呈现几个字符串的组件:</p><pre class="kx ky kz la gt mw mv mx my aw mz bi"><span id="6fb4" class="na lc iq mv b gy nb nc l nd ne"><em class="nf">const SelectedCountry = ({ country, onSaveCountry }: { country: Country; onSaveCountry: () =&gt; void }) =&gt; {<br/>  return (<br/>    &lt;&gt;<br/>      &lt;ul&gt;<br/>        &lt;li&gt;Country: {country.name}&lt;/li&gt;<br/>        ... // whatever country's information we're going to render<br/>      &lt;/ul&gt;<br/>      &lt;button onClick={onSaveCountry} type="button"&gt;Save&lt;/button&gt;<br/>    &lt;/&gt;<br/>  );<br/>};</em></span></pre><p id="c336" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">🤷🏽‍♀️就是这样！这只是为了让演示代码更加有趣🙂</p><h1 id="0862" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">最后润色:主题化</h1><p id="c4b2" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">现在是最后一步:黑暗模式！谁不喜欢这些呢？考虑到当前主题应该在大多数组件中可用，在任何地方通过道具传递它将是一场噩梦，因此React Context是这里的自然解决方案。</p><p id="67f3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先创建主题上下文:</p><pre class="kx ky kz la gt mw mv mx my aw mz bi"><span id="bfa3" class="na lc iq mv b gy nb nc l nd ne"><em class="nf">type Mode = 'light' | 'dark';<br/>type Theme = { mode: Mode };<br/>const ThemeContext = React.createContext&lt;Theme&gt;({ mode: 'light' });<br/><br/>const useTheme = () =&gt; {<br/>  return useContext(ThemeContext);<br/>};</em></span></pre><p id="0beb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">添加上下文提供程序和按钮以将其切换到页面组件:</p><pre class="kx ky kz la gt mw mv mx my aw mz bi"><span id="5afc" class="na lc iq mv b gy nb nc l nd ne"><em class="nf">export const Page = ({ countries }: { countries: Country[] }) =&gt; {<br/>  // same as before<br/>  const [mode, setMode] = useState&lt;Mode&gt;("light");<br/><br/>  return (<br/>    &lt;ThemeContext.Provider value={{ mode }}&gt;<br/>      &lt;button onClick={() =&gt; setMode(mode === 'light' ? 'dark' : 'light')}&gt;Toggle theme&lt;/button&gt;<br/>      // the rest is the same as before<br/>    &lt;/ThemeContext.Provider&gt;<br/>  )<br/>}</em></span></pre><p id="384f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后使用上下文挂钩将我们的按钮涂成适当的主题:</p><pre class="kx ky kz la gt mw mv mx my aw mz bi"><span id="eac9" class="na lc iq mv b gy nb nc l nd ne"><em class="nf">const Item = ({ country }: { country: Country }) =&gt; {<br/>    const { mode } = useTheme();<br/>    const className = `country-item ${mode === "dark" ? "dark" : ""}`;<br/>    // the rest is the same<br/>}</em></span></pre><p id="0346" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">同样，在这个实现中没有犯罪，一个非常常见的模式，特别是主题化。</p><h1 id="1599" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">重构主题——考虑性能。</h1><p id="d0cd" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">在我们能够发现上面的实现有什么问题之前，是时候看看React组件可以被重新呈现的第四个原因了，这一点经常被遗忘:<strong class="ka ir">如果一个组件使用上下文消费者，那么每当上下文提供者的值改变时，它都会被重新呈现。</strong></p><p id="c1fe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">还记得我们简化的例子吗？在这个例子中，我们对渲染结果进行了记忆，以避免它们被重新渲染。</p><pre class="kx ky kz la gt mw mv mx my aw mz bi"><span id="d7f0" class="na lc iq mv b gy nb nc l nd ne"><em class="nf">const Item = ({ country }: { country: Country }) =&gt; {<br/>  console.log("render");<br/>  return &lt;div&gt;{country.name}&lt;/div&gt;;<br/>};<br/><br/>const CountriesList = ({ countries }: { countries: Country[] }) =&gt; {<br/>  return (<br/>    &lt;&gt;<br/>      {countries.map((country) =&gt; (<br/>        &lt;Item country={country} /&gt;<br/>      ))}<br/>    &lt;/&gt;<br/>  );<br/>};<br/><br/>export const Page = ({ countries }: { countries: Country[] }) =&gt; {<br/>  const [counter, setCounter] = useState&lt;number&gt;(1);<br/><br/>  const list = useMemo(() =&gt; &lt;CountriesList countries={countries} /&gt;, [<br/>    countries<br/>  ]);<br/><br/>  return (<br/>    &lt;&gt;<br/>      &lt;h1&gt;Country settings&lt;/h1&gt;<br/>      &lt;button onClick={() =&gt; setCounter(counter + 1)}&gt;<br/>        Click here to re-render Countries list (open the console) {counter}<br/>      &lt;/button&gt;<br/>      {list}<br/>    &lt;/&gt;<br/>  );<br/>};</em></span></pre><p id="0730" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">组件会在我们每次点击按钮时重新渲染，因为它会在每次点击时更新状态。但是<code class="fe ms mt mu mv b">CountriesList</code>是内存化的，并且独立于那个状态，所以它不会被重新渲染，因此<code class="fe ms mt mu mv b">Item</code>组件也不会被重新渲染。参见<a class="ae ng" href="https://codesandbox.io/s/context-before-good-duhgf?file=/src/country-settings/page.tsx" rel="noopener ugc nofollow" target="_blank"> codesandbox这里</a>。</p><p id="4ebb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，如果我在这里添加主题上下文会发生什么？<code class="fe ms mt mu mv b">Page</code>组件中的提供者:</p><pre class="kx ky kz la gt mw mv mx my aw mz bi"><span id="1607" class="na lc iq mv b gy nb nc l nd ne"><em class="nf">export const Page = ({ countries }: { countries: Country[] }) =&gt; {<br/>  // everything else stays the same<br/><br/>  // memoised list is still memoised<br/>  const list = useMemo(() =&gt; &lt;CountriesList countries={countries} /&gt;, [<br/>    countries<br/>  ]);<br/><br/>  return (<br/>    &lt;ThemeContext.Provider value={{ mode }}&gt;<br/>      // same<br/>    &lt;/ThemeContext.Provider&gt;<br/>  );<br/>};</em></span></pre><p id="851d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">和项目组件中的上下文:</p><pre class="kx ky kz la gt mw mv mx my aw mz bi"><span id="593d" class="na lc iq mv b gy nb nc l nd ne"><em class="nf">const Item = ({ country }: { country: Country }) =&gt; {<br/>  const theme = useTheme();<br/>  console.log("render");<br/>  return &lt;div&gt;{country.name}&lt;/div&gt;;<br/>};</em></span></pre><p id="e007" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果它们只是普通的组件和钩子，什么都不会发生——<code class="fe ms mt mu mv b">Item</code>不是<code class="fe ms mt mu mv b">Page</code>组件的子组件，<code class="fe ms mt mu mv b">CountriesList</code>不会因为内存化而重新渲染，所以<code class="fe ms mt mu mv b">Item</code>也不会。不同的是，在这种情况下，它是一个提供者-消费者的组合，所以每次提供者的值改变时，<strong class="ka ir">所有的</strong>消费者都会重新呈现。由于我们一直在传递新的对象给值，<code class="fe ms mt mu mv b"><em class="nf">Items</em></code> <em class="nf">将会不必要的在每个计数器</em>上重新呈现。上下文基本上绕过了我们所做的记忆，使它变得几乎毫无用处。<a class="ae ng" href="https://codesandbox.io/s/context-bad-4zou7?file=/src/country-settings/page.tsx" rel="noopener ugc nofollow" target="_blank">参见codesandbox。</a></p><p id="8adb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如您可能已经猜到的那样，对它的修复只是为了确保提供程序中的<code class="fe ms mt mu mv b">value</code>不会做不必要的更改。在我们的例子中，我们只需要记住它:</p><pre class="kx ky kz la gt mw mv mx my aw mz bi"><span id="1266" class="na lc iq mv b gy nb nc l nd ne"><em class="nf">export const Page = ({ countries }: { countries: Country[] }) =&gt; {<br/>  // everything else stays the same<br/><br/>  // memoising the object!<br/>  const theme = useMemo(() =&gt; ({ mode }), [mode]);<br/><br/>  return (<br/>    &lt;ThemeContext.Provider value={theme}&gt;<br/>      // same<br/>    &lt;/ThemeContext.Provider&gt;<br/>  );<br/>};</em></span></pre><p id="0953" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在计数器将工作，而不会导致所有的项目重新渲染！</p><p id="8b14" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以将完全相同的解决方案应用到非简化的<code class="fe ms mt mu mv b">Page</code>组件上，以防止不必要的重新渲染:</p><pre class="kx ky kz la gt mw mv mx my aw mz bi"><span id="df89" class="na lc iq mv b gy nb nc l nd ne"><em class="nf">export const Page = ({ countries }: { countries: Country[] }) =&gt; {<br/>  // same as before<br/>  const [mode, setMode] = useState&lt;Mode&gt;("light");<br/><br/>  // memoising the object!<br/>  const theme = useMemo(() =&gt; ({ mode }), [mode]);<br/><br/>  return (<br/>    &lt;ThemeContext.Provider value={theme}&gt;<br/>      &lt;button onClick={() =&gt; setMode(mode === 'light' ? 'dark' : 'light')}&gt;Toggle theme&lt;/button&gt;<br/>      // the rest is the same as before<br/>    &lt;/ThemeContext.Provider&gt;<br/>  )<br/>}</em></span></pre><p id="cdac" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">并将新知识提炼到本文的最后一条规则中:</p><blockquote class="nh ni nj"><p id="a3cc" class="jy jz nf ka b kb kc kd ke kf kg kh ki nk kk kl km nl ko kp kq nm ks kt ku kv ij bi translated"><strong class="ka ir">规则#4 </strong>:当使用上下文时，如果value属性不是数字、字符串或布尔值，要确保它总是被记忆。</p></blockquote><h1 id="70d8" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">将这一切结合在一起</h1><p id="f99f" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">最后，我们的应用程序完成了！整个实现在这个代码沙箱中<a class="ae ng" href="https://codesandbox.io/s/re-renders-final-good-luz8s?file=/src/country-settings/page.tsx" rel="noopener ugc nofollow" target="_blank">可用。如果你用的是最新的MacBook，那就降低你的CPU，像普通用户一样体验世界，并尝试在列表中的不同国家之间进行选择。即使减少了6倍的CPU，它仍然非常快！🎉</a></p><p id="034d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我想很多人都想问一个大问题:“但是Nadia，无论如何，React本身是非常快的。你所做的那些“优化”肯定不会对一个只有250个条目的简单列表产生太大的影响吧？你不是夸大了这里的重要性吗？”。</p><p id="dece" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">是啊，刚开始写这篇文章的时候，我也是这么想的。但后来我用“非性能”的方式实现了那个应用。<a class="ae ng" href="https://codesandbox.io/s/re-renders-final-bad-4znwe?file=/src/country-settings/page.tsx" rel="noopener ugc nofollow" target="_blank">在codesandbox </a>中查看。我甚至不需要降低CPU来查看选择项目之间的延迟😱。缩小6倍，它可能是这个星球上最慢的简单列表，甚至无法正常工作(它有一个“performant”应用程序没有的焦点bug)。我甚至没有做任何令人发指和明显的邪恶！😅</p><p id="8765" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以让我们在React组件重新渲染时刷新<strong class="ka ir">:</strong></p><ul class=""><li id="1e98" class="me mf iq ka b kb kc kf kg kj mg kn mh kr mi kv mj mk ml mm bi translated">当道具或状态改变时</li><li id="0683" class="me mf iq ka b kb mn kf mo kj mp kn mq kr mr kv mj mk ml mm bi translated">当父组件重新呈现时</li><li id="2845" class="me mf iq ka b kb mn kf mo kj mp kn mq kr mr kv mj mk ml mm bi translated">当组件使用上下文并且其提供者的值改变时</li></ul><p id="dfd4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们提取的规则是:</p><p id="128d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你想将props中的内联函数提取到<code class="fe ms mt mu mv b">useCallback</code>中的唯一原因是为了避免子组件的重新渲染:不要。它不起作用。</p><p id="56ae" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">规则#2 </strong>:如果你的组件管理状态，找到渲染树中不依赖于改变后的状态的部分，并对它们进行优化以最小化它们的重新渲染。</p><p id="bb72" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">规则#3 </strong>。<em class="nf">永远不要在另一个组件的渲染函数内创建新的组件。</em></p><p id="7e93" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">规则#4 </strong>。当使用上下文时，确保<code class="fe ms mt mu mv b">value</code>属性是<em class="nf">总是</em> memoised，如果它不是数字、字符串或布尔值。</p><p id="508f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">就是这样！我希望这些规则将有助于从一开始就编写更高性能的应用程序，并让那些再也不用体验缓慢产品的用户更加满意。</p><h1 id="de65" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">额外收获:T2难题</h1><p id="2979" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">我觉得在结束这篇文章之前，我需要解决一个谜:为什么<code class="fe ms mt mu mv b">useCallback</code>对减少重新呈现毫无用处，为什么React文档字面上说“[useCallback]在传递回调到依赖引用相等来防止不必要呈现的优化子组件时是有用的”？🤯</p><p id="58bf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">答案就在这句话里:<em class="nf">“依赖引用相等的优化子组件”</em>。</p><p id="a041" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里有两种情况。</p><p id="2021" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">第一个</strong>:接收回调的组件被包装在<code class="fe ms mt mu mv b">React.memo</code>中，并把回调作为依赖项。基本上是这样:</p><pre class="kx ky kz la gt mw mv mx my aw mz bi"><span id="bcff" class="na lc iq mv b gy nb nc l nd ne"><em class="nf">const MemoisedItem = React.memo(Item);<br/><br/>const List = () =&gt; {<br/>  // this HAS TO be memoised, otherwise `React.memo` for the Item is useless<br/>  const onClick = () =&gt; {console.log('click!')};<br/><br/>  return &lt;MemoisedItem onClick={onClick} country="Austria" /&gt;<br/>}</em></span></pre><p id="fdc8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">或者这个:</p><pre class="kx ky kz la gt mw mv mx my aw mz bi"><span id="68ef" class="na lc iq mv b gy nb nc l nd ne"><em class="nf">const MemoisedItem = React.memo(Item, (prev, next) =&gt; prev.onClick !== next.onClick);<br/><br/>const List = () =&gt; {<br/>  // this HAS TO be memoised, otherwise `React.memo` for the Item is useless<br/>  const onClick = () =&gt; {console.log('click!')};<br/><br/>  return &lt;MemoisedItem onClick={onClick} country="Austria" /&gt;<br/>}</em></span></pre><p id="c8f3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">第二个</strong>:如果收到回调的组件在<code class="fe ms mt mu mv b">useMemo</code>、<code class="fe ms mt mu mv b">useCallback</code>或<code class="fe ms mt mu mv b">useEffect</code>等钩子中将该回调作为依赖。</p><pre class="kx ky kz la gt mw mv mx my aw mz bi"><span id="54f8" class="na lc iq mv b gy nb nc l nd ne"><em class="nf">const Item = ({ onClick }) =&gt; {<br/>  useEffect(() =&gt; {<br/>    // some heavy calculation here<br/>    const data = ...<br/>    onClick(data);<br/><br/>  // if onClick is not memoised, this will be triggered on every single render<br/>  }, [onClick])<br/>  return &lt;div&gt;something&lt;/div&gt;<br/>}<br/>const List = () =&gt; {<br/>  // this HAS TO be memoised, otherwise `useEffect` in Item above<br/>  // will be triggered on every single re-render<br/>  const onClick = () =&gt; {console.log('click!')};<br/><br/>  return &lt;Item onClick={onClick} country="Austria" /&gt;<br/>}</em></span></pre><p id="4f13" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所有这些都不能概括为简单的“做”或“不做”，它只能用于解决确切组件的确切性能问题，而不是以前。</p><p id="20bd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在文章终于完成了，谢谢你阅读到目前为止，希望你觉得有用！再见，下次见，✌🏼</p></div><div class="ab cl no np hu nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="ij ik il im in"><p id="ac85" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="nf">原载于</em><a class="ae ng" href="https://www.developerway.com/posts/how-to-write-performant-react-code" rel="noopener ugc nofollow" target="_blank"><em class="nf">https://www.developerway.com</em></a><em class="nf">。网站上有更多这样的文章</em>😉</p><p id="27d0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae ng" href="https://www.developerway.com/" rel="noopener ugc nofollow" target="_blank"> <em class="nf">订阅快讯</em> </a>、<em class="nf"> </em> <a class="ae ng" href="https://www.linkedin.com/in/adevnadia/" rel="noopener ugc nofollow" target="_blank"> <em class="nf">在LinkedIn上连接</em> </a> <em class="nf">或</em> <a class="ae ng" href="https://twitter.com/adevnadia" rel="noopener ugc nofollow" target="_blank"> <em class="nf">在Twitter上关注</em> </a> <em class="nf">以便在下一篇文章出来时立即获得通知。</em></p></div></div>    
</body>
</html>