<html>
<head>
<title>15+ things you need to know when you want to use Spring @Transactional really well</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">当你想很好地使用Spring @Transactional时，你需要知道的15件事情</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/15-things-you-need-to-know-when-you-want-to-use-spring-transactional-really-well-fc6f5ec207ac?source=collection_archive---------2-----------------------#2022-12-19">https://levelup.gitconnected.com/15-things-you-need-to-know-when-you-want-to-use-spring-transactional-really-well-fc6f5ec207ac?source=collection_archive---------2-----------------------#2022-12-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="a770" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">作为一名优秀的Java开发人员或架构师。你真的掌握了如何用好@Transactional吗？</p><p id="546a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该事务是理解和使用well概念所必需的，这将确保我们业务数据的完整性，并避免许多不必要的错误。</p><p id="5765" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这篇文章中。我就说说如何在数据操作上很好的使用spring annotation @Transactional。而且<strong class="js iu"> <em class="ko">读完之后你会发现很多好的例子带走。</em>T3】</strong></p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi kp"><img src="../Images/ab49d14728fa937c5ec611f563300f4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1034/format:webp/0*RZx7fqgKQrF5f_AH.jpeg"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">外卖</figcaption></figure><h2 id="b498" class="lb lc it bd ld le lf dn lg lh li dp lj kb lk ll lm kf ln lo lp kj lq lr ls lt bi translated">1.在我们开始钻研@Transactional注释之前，我们首先需要理解什么是事务。</h2><p id="df89" class="pw-post-body-paragraph jq jr it js b jt lu jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn im bi translated">什么是交易？</p><ul class=""><li id="1bb1" class="lz ma it js b jt ju jx jy kb mb kf mc kj md kn me mf mg mh bi translated">事务通常被定义为不可分割的工作单元。<a class="ae mi" href="https://docs.oracle.com/javaee/5/tutorial/doc/bncii.html" rel="noopener ugc nofollow" target="_blank">什么是交易？Java EE 5教程</a></li><li id="775f" class="lz ma it js b jt mj jx mk kb ml kf mm kj mn kn me mf mg mh bi translated">在java中，它是一系列必须成功完成的动作。如果一个或多个动作失败，所有其他动作必须退出，应用程序的状态保持不变。<a class="ae mi" href="https://www.baeldung.com/java-transactions" rel="noopener ugc nofollow" target="_blank">https://www.baeldung.com/java-transactions</a></li></ul><p id="7f4e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们用图表上的一个简单例子来解释:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi mo"><img src="../Images/fa21164c3015e54e9e512d075dbe09db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j9Rqi7EbsmqFOLiMNVZy8w.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">简单交易示例</figcaption></figure><p id="1dc4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以这关系到数据的完整性。我们只能看到所有步骤的成功。事务可以提交。否则将失败或回滚以保持数据完整性。</p><p id="ccfd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">事实上，在计算机领域，有多种事务类型如数据库事务、消息中间件的消息事务(Kafka、Rockmq)等。而<strong class="js iu">这篇文章将关注数据库事务。</strong></p><h2 id="bc40" class="lb lc it bd ld le lf dn lg lh li dp lj kb lk ll lm kf ln lo lp kj lq lr ls lt bi translated">1.1交易的使用场景</h2><p id="71ac" class="pw-post-body-paragraph jq jr it js b jt lu jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn im bi translated">什么时候用？</p><p id="6b12" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">总之。当您试图在工作单元的一个或多个步骤中创建/更新/删除表中的数据时。那么你最好使用事务来保持数据的完整性。</p><h2 id="6a35" class="lb lc it bd ld le lf dn lg lh li dp lj kb lk ll lm kf ln lo lp kj lq lr ls lt bi translated">1.2 Spring提供的事务机制。</h2><p id="693e" class="pw-post-body-paragraph jq jr it js b jt lu jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn im bi translated">所有的数据访问技术都有自己的事务处理机制，这些技术提供了用于打开事务、提交事务以完成数据操作或在发生错误时回滚数据的API。</p><p id="5d05" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Spring的事务机制是为不同的数据访问技术处理事务的统一机制，Spring的事务机制提供了一个<strong class="js iu">PlatformTransactionManager</strong>接口，不同的数据访问技术从这个接口实现它们不同的方式。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi mt"><img src="../Images/e124ca593ed745f9ac00a2f3e9edac18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qftVQkc9F-zAxHBL2xdmHQ.png"/></div></div></figure><h2 id="8a69" class="lb lc it bd ld le lf dn lg lh li dp lj kb lk ll lm kf ln lo lp kj lq lr ls lt bi translated">1.2.1 Spring声明式事务</h2><p id="436e" class="pw-post-body-paragraph jq jr it js b jt lu jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn im bi translated">Spring提供了一个<em class="ko">@ EnableTransactionManagement</em>注释来启用对配置类的声明式事务支持。在使用了<em class="ko">@ EnableTransactionManagement</em>之后，Spring容器会自动扫描标注了<em class="ko"> @Transactional </em>的方法和类。<em class="ko">@ EnableTransactionManagement</em>使用方法如下。</p><pre class="kq kr ks kt gt mu mv mw bn mx my bi"><span id="3f52" class="mz lc it mv b be na nb l nc nd">@Configuration<br/>@EnableTransactionManagement<br/>public class ApplicationConfig {<br/>    ...<br/>}</span></pre><p id="b0a5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在方法上使用<em class="ko"> @Transactional </em>注释来表示该方法需要事务支持</p><pre class="kq kr ks kt gt mu mv mw bn mx my bi"><span id="e919" class="mz lc it mv b be na nb l nc nd">@Transactional<br/>public void dbOperate(Object xxxx) {<br/>    //save or update or delete<br/>}</span></pre><p id="af0e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko"> @Transactional </em>不仅可以在方法上注释，也可以在类上注释。当对一个类进行注释时，该类的所有公共方法都是支持事务的。如果同时使用了类级别和方法级别的<em class="ko"> @Transactional </em>注释，则在方法级别使用的注释会覆盖类级别的注释。</p><p id="34b3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Spring团队<strong class="js iu">建议在特定的类(或类的方法)上使用<em class="ko"> @Transactional </em>，而不是在该类打算实现的任何接口上。</strong></p><p id="50f9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果它必须在一个接口上使用，<strong class="js iu">它只有在你建立一个基于接口的代理</strong>时才能工作。这是因为注释是不可继承的，这意味着一旦您在使用基于类的代理时设置了基于接口的代理，基于类的代理将不会识别事务设置，并且事务代理也不会包装对象。</p><h2 id="ce23" class="lb lc it bd ld le lf dn lg lh li dp lj kb lk ll lm kf ln lo lp kj lq lr ls lt bi translated">1.3 SpringBoot的交易支持</h2><p id="fd24" class="pw-post-body-paragraph jq jr it js b jt lu jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn im bi translated">Spring Boot的事务配置类是<em class="ko">org . spring framework . boot . auto configure . transaction . transactionautoconfiguration</em>。</p><pre class="kq kr ks kt gt mu mv mw bn mx my bi"><span id="a574" class="mz lc it mv b be na nb l nc nd">@AutoConfiguration(after = { JtaAutoConfiguration.class, HibernateJpaAutoConfiguration.class,<br/>        DataSourceTransactionManagerAutoConfiguration.class, Neo4jDataAutoConfiguration.class })<br/>@ConditionalOnClass(PlatformTransactionManager.class)<br/>@EnableConfigurationProperties(TransactionProperties.class)<br/>public class TransactionAutoConfiguration {<br/>    ...<br/>}</span></pre><p id="0019" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">只有当类<code class="fe ne nf ng mv b">PlatformTransactionManager</code>存在于<code class="fe ne nf ng mv b">classpath</code>上时，它才起作用。并且仅在应用了以下自动配置类之后:</p><ul class=""><li id="4a38" class="lz ma it js b jt ju jx jy kb mb kf mc kj md kn me mf mg mh bi translated"><code class="fe ne nf ng mv b">JtaAutoConfiguration</code></li><li id="88a4" class="lz ma it js b jt mj jx mk kb ml kf mm kj mn kn me mf mg mh bi translated"><code class="fe ne nf ng mv b">HibernateJpaAutoConfiguration</code></li><li id="12ba" class="lz ma it js b jt mj jx mk kb ml kf mm kj mn kn me mf mg mh bi translated"><code class="fe ne nf ng mv b">DataSourceTransactionManagerAutoConfiguration</code></li><li id="ddef" class="lz ma it js b jt mj jx mk kb ml kf mm kj mn kn me mf mg mh bi translated"><code class="fe ne nf ng mv b">Neo4jDataAutoConfiguration</code></li></ul><p id="be89" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">那么SpringBoot如何选择使用哪种数据访问技术和对应的事务管理器呢？它实际上是根据你所介绍的依赖关系来选择的。</p><pre class="kq kr ks kt gt mu mv mw bn mx my bi"><span id="024d" class="mz lc it mv b be na nb l nc nd">&lt;dependency&gt;<br/>    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br/>    &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;<br/>&lt;/dependency&gt;</span></pre><p id="7b8a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当引入spring-boot-starter-data-jpa时，SpringBoot将默认使用JpaTransactionManager作为事务管理器。</p><pre class="kq kr ks kt gt mu mv mw bn mx my bi"><span id="e3bd" class="mz lc it mv b be na nb l nc nd">&lt;dependency&gt;<br/>    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br/>    &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;<br/>&lt;/dependency&gt;</span></pre><p id="8553" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当您引入spring-boot-starter-jdbc时，SpringBoot将默认使用DataSourceTransactionManager作为事务管理器。</p><h2 id="3406" class="lb lc it bd ld le lf dn lg lh li dp lj kb lk ll lm kf ln lo lp kj lq lr ls lt bi translated">1.4 Spring Data JPA的事务支持</h2><p id="ad95" class="pw-post-body-paragraph jq jr it js b jt lu jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn im bi translated">Spring Data JPA对所有默认方法都启用了事务支持，查询事务默认启用了<strong class="js iu"><em class="ko">readOnly = true</em></strong>属性。</p><p id="9ad9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这可以从<strong class="js iu"> SimpleJpaRepository </strong>源代码中看出，定义在类级<em class="ko">@ Transactional(readOnly = true)</em>，但是save()和delete()相关操作覆盖了<em class="ko"> @Transactional </em>属性，此时<em class="ko"> readOnly </em>属性为false，其余的查询操作<em class="ko"> readOnly </em>仍然为true。</p><pre class="kq kr ks kt gt mu mv mw bn mx my bi"><span id="dddc" class="mz lc it mv b be na nb l nc nd">@Repository<br/>@Transactional(readOnly = true)<br/>public class SimpleJpaRepository&lt;T, ID&gt; implements JpaRepositoryImplementation&lt;T, ID&gt; {<br/>    <br/>    ...<br/><br/>    @Transactional<br/>    @Override<br/>    public &lt;S extends T&gt; S save(S entity) {<br/>        ...<br/>    }<br/><br/>    ...<br/><br/>    @Override<br/>    @Transactional<br/>    @SuppressWarnings("unchecked")<br/>    public void delete(T entity) {<br/>        ...<br/>    }<br/>}</span></pre></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><h2 id="f4ae" class="lb lc it bd ld le lf dn lg lh li dp lj kb lk ll lm kf ln lo lp kj lq lr ls lt bi translated">2.如何用好这个注释，我们需要完全理解一些基本的规则。</h2><p id="bdaa" class="pw-post-body-paragraph jq jr it js b jt lu jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn im bi translated">注意，默认情况下，<strong class="js iu">回滚在运行时发生，未检查的异常仅在</strong>(图中黄绿色部分)发生。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi no"><img src="../Images/6885f4397875b125b3230c19f251bdda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*99m7St_7_aZCrGkexie_5Q.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">例外</figcaption></figure><p id="a820" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为什么这样设计？Spring认为，checked exception属于业务范围，程序员需要给出解决方案而不是直接交给框架或JVM去处理。</p><p id="7e0d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">被检查的异常不触发事务的回滚</strong>。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi np"><img src="../Images/88cd340eb2894638c9a23a44e2362df8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_fUjOkAmm8X2TeCy9iTZ0A.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">源代码</figcaption></figure><p id="900e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当然，我们可以用<em class="ko"> rollbackFor </em>和<em class="ko"> noRollbackFor </em>注释参数来配置这种行为。</p><p id="82d0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko"> @Transactional </em>注释使用属性<em class="ko"> rollbackFor </em>或<em class="ko"> rollbackForClassName </em>来回滚事务，并使用属性<em class="ko"> noRollbackFor </em>或<em class="ko"> noRollbackForClassName </em>来避免回滚列出的异常。</p><h1 id="9ced" class="nq lc it bd ld nr ns nt lg nu nv nw lj nx ny nz lm oa ob oc lp od oe of ls og bi translated">回滚到</h1><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/8a5e4b78e085cf6d7711a6d8a0ae8f9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1398/format:webp/1*o1JVkg5ioc4pfdcLmx4K8g.png"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">源代码</figcaption></figure><p id="bb71" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">选中时，异常抛出将执行回滚。</p><pre class="kq kr ks kt gt mu mv mw bn mx my bi"><span id="1e36" class="mz lc it mv b be na nb l nc nd">    //without 'rollbackFor'<br/>    @Transactional<br/>    public void dbOperate() throws ClassNotFoundException {<br/>        svcA.save();    // svcA.save() will execute normally.<br/>        Class.forName("The Class do not Exist");  //throws<br/>        testBMapper.descNumB();<br/>    }<br/><br/>    //with 'rollbackFor'<br/>    @Transactional(rollbackFor = {ClassNotFoundException.class})<br/>    public void dbOperate() throws ClassNotFoundException {<br/>        svcA.save();    // svcA.save() will rollback<br/>        Class.forName("The Class do not Exist"); //throws<br/>        svcB.update();<br/>    }<br/></span></pre><p id="5147" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当非RuntimeExceptions被try-catch时，<em class="ko"> rollbackFor </em>不起作用，事务正常进行</p><pre class="kq kr ks kt gt mu mv mw bn mx my bi"><span id="6814" class="mz lc it mv b be na nb l nc nd">@Transactional(rollbackFor = {ClassNotFoundException.class})<br/>public void changeNum()  {<br/>  svcA.save();    // svcA.save() will execute normally.<br/>  try {<br/>    Class.forName("The Class do not Exist"); //throws<br/>  } catch (ClassNotFoundException e) {<br/>    e.printStackTrace();<br/>  }<br/>  svcB.update();  // svcB.update() will execute normally.<br/>}</span></pre><h1 id="2b90" class="nq lc it bd ld nr ns nt lg nu nv nw lj nx ny nz lm oa ob oc lp od oe of ls og bi translated">noRollbackFor</h1><p id="d1bb" class="pw-post-body-paragraph jq jr it js b jt lu jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn im bi translated">抛出RuntimeException时不会执行回滚</p><pre class="kq kr ks kt gt mu mv mw bn mx my bi"><span id="4b08" class="mz lc it mv b be na nb l nc nd">@Transactional(noRollbackFor = {ArithmeticException.class})<br/>public void doMath(){<br/>  svcA.save();<br/>  int a = 1/0;  //this will throw AruthmeticException. but svcA.save() will no rollback.<br/>  svcB.update();<br/>}</span></pre><p id="cb89" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当RuntimeException被try-catched时，<em class="ko"> noRollbackFor </em>不起作用，交易正常进行</p><pre class="kq kr ks kt gt mu mv mw bn mx my bi"><span id="9e78" class="mz lc it mv b be na nb l nc nd">@Transactional(noRollbackFor = {ArithmeticException.class})<br/>public void changeNum(){<br/>  svcA.save();    // svcA.save() will execute normally.<br/>  try {<br/>    int a = 1/0;<br/>  }<br/>  catch (Exception e){}<br/>  svcB.update();  // svcB.update() will execute normally.<br/>}</span></pre><h1 id="8b9c" class="nq lc it bd ld nr ns nt lg nu nv nw lj nx ny nz lm oa ob oc lp od oe of ls og bi translated">3.什么会导致交易失败</h1><p id="e1ef" class="pw-post-body-paragraph jq jr it js b jt lu jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn im bi translated"><strong class="js iu"> 3.1访问修饰符必须是公共的</strong>。所以final/private/static/private/protected都不行。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi mt"><img src="../Images/6fdca73e6efb60e433060bc20e55e6d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P2lOLOmVYTCR6nYZ31jNBQ.png"/></div></div></figure><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi oi"><img src="../Images/388db3a2dbf9ef82cecc4a8962bc901b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6t8C1sI5SK1E-_yzkGip8A.png"/></div></div></figure><p id="fc57" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> 3.2标记方法不能与@Transactional方法在同一个类中。</strong></p><p id="1bea" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我在上一篇文章(3.4点)中解释了这一点<a class="ae mi" href="https://medium.com/gitconnected/8-things-you-need-to-know-when-you-want-to-use-spring-async-really-well-e5af4af259c5" rel="noopener">https://medium . com/git connected/8-things-you-need-to-know-when-you-want-use-spring-async-really-well-e 5a F4 af 259 C5</a></p><p id="659f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是这次试着用一张图来解释得更清楚些。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi oj"><img src="../Images/be57f216ed859ba164e972cb21882745.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ad6NCPfpztYVkH1KejMnLA.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">AOP代理如何工作</figcaption></figure><p id="00a9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> 3.3 Bean不由spring管理</strong></p><p id="5daa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如:@ Services @ Component @ Controller @ Reposity未放在Bean类上</p><p id="1454" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> 3.4多线程调用</strong></p><pre class="kq kr ks kt gt mu mv mw bn mx my bi"><span id="0bfc" class="mz lc it mv b be na nb l nc nd">@Service    <br/>public class OutsideService {<br/>    ...<br/><br/>    @Transactional<br/>    public void multipleThreadTest(Team team){<br/>        teamRepository.save(team);<br/>        new Thread(() -&gt; insideService.doSth()).start(); //this would been called by new thread.<br/>    }<br/>}    <br/><br/>@Service    <br/>public class InsideService {<br/><br/>    @Transactional<br/>    public void doSth(){<br/>        log.info("do sth");<br/>    }<br/>}</span></pre><p id="55cd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以看到<em class="ko"> insideService.doSth() </em>会在另一个新的线程中被调用，这会在不同的线程中coz两个方法，从而得到不同的数据库连接，因为事务是在同一个数据库连接中打开和提交/回滚的，那么2个不同的数据库连接自然会在两个不同的事务中处理。这导致交易失败。</p><p id="867b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从源代码中我们还可以看到，spring的事务都是通过数据库连接实现的，<strong class="js iu">当前线程会保存一个map，key是数据源，value是数据库连接</strong>。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi ok"><img src="../Images/a1fdce8c8f3fabefa91c8651b07812b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dR1MWLzh3wPuvB3iKwZiRg.png"/></div></div></figure><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi ol"><img src="../Images/bd98f2ffdaba4eb3b70a09198fc45d4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SzeAx4ceXHghUGBQrs3rxg.png"/></div></div></figure><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi om"><img src="../Images/462d0efa9b65feb5e4837f0a9d2cb6ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_btzn2d8fY8e78Sp8hSjcQ.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">JPATransactionManager如何调用此绑定资源(数据源，连接)</figcaption></figure><p id="c2c6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们来看一些代码示例:</p><p id="9df3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">3.4.1父线程抛出异常。发生回滚。parentThread team将不保存。但是由于子线程不在这个事务中，所以子线程操作不会回滚。那么childThread团队将拯救成功。</p><pre class="kq kr ks kt gt mu mv mw bn mx my bi"><span id="dfbd" class="mz lc it mv b be na nb l nc nd">    @Service<br/>    @Slf4j<br/>    public class OutsideService {<br/>        @Transactional<br/>        public void parentThreadThrowException(Team team){<br/>            teamRepository.save(team);<br/>            new Thread(() -&gt; insideService.doSth(new Team("childThread"))).start();<br/>            throw new RuntimeException("Parent Thread throw Exception");<br/>        }<br/>    }<br/>    <br/>    @Service<br/>    @Slf4j<br/>    public class InsideService {<br/>        @Transactional<br/>        public void doSth(Team team){<br/>            teamRepository.save(team);<br/>            log.info("do sth");<br/>        }<br/>    }<br/>    <br/>    @Test<br/>    void parentThread_throw_RuntimeException_rollback_but_childThread_save_success() {<br/>        Team team = new Team("parentThread");<br/>        assertThrows(RuntimeException.class, () -&gt; outsideService.parentThreadThrowException(team));<br/>        Optional&lt;Team&gt; parentThreadTeam = teamRepository.findByName("parentThread");<br/>        assertFalse(parentThreadTeam.isPresent());<br/>        Optional&lt;Team&gt; childThreadTeam = teamRepository.findByName("childThread");<br/>        assertTrue(childThreadTeam.isPresent());<br/>    }</span></pre><p id="f6b6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">3.4.2子线程抛出异常。发生回滚。childThread团队将不保存。但是由于子线程不在父事务中，所以父线程的操作不会回滚。那么parentThread团队就会拯救成功。</p><pre class="kq kr ks kt gt mu mv mw bn mx my bi"><span id="bc7a" class="mz lc it mv b be na nb l nc nd">@Service<br/>@Slf4j<br/>public class OutsideService {<br/>    @Transactional<br/>    public void childThreadThrowException(Team team){<br/>        teamRepository.save(team);<br/>        new Thread(() -&gt; insideService.save_ThrowException(new Team("childThread"))).start();<br/>    }<br/>}<br/><br/>@Service<br/>@Slf4j<br/>public class InsideService {<br/>    @Transactional<br/>    public void save_ThrowException(Team team){<br/>        teamRepository.save(team);<br/>        throw new RuntimeException("Child Thread throw Exception");<br/>    }<br/>}<br/><br/><br/>@Test<br/>void inside_method_throw_RuntimeException_with_REQUIRED_NEW_transaction() {<br/>    Team team = new Team("parentThread");<br/>    assertDoesNotThrow(() -&gt; outsideService.childThreadThrowException(team));<br/>    Optional&lt;Team&gt; newTeam = teamRepository.findByName("parentThread");<br/>    assertTrue(newTeam.isPresent());<br/>    Optional&lt;Team&gt; childThreadTeam = teamRepository.findByName("childThread");<br/>    assertFalse(childThreadTeam.isPresent());<br/>}</span></pre><p id="01fc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> 3.5数据库引擎不支持事务</strong></p><p id="7cda" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如:MySQL-MyISAM不支持该事务。</p><p id="ed5c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> 3.6使用错误的传播方式</strong></p><p id="9132" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">用例:我们只是想捕捉内部事务中发生的一些RuntimeException，而不是触发外部事务回滚。</p><p id="43f6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">错误示例:</p><p id="0aa0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这将触发外部事务回滚。</p><p id="fa80" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">默认的@事务传播是<strong class="js iu"> <em class="ko">必需的</em> </strong>。如果<em class="ko"> RuntimeException </em>抛出事务代理，Spring将当前事务标记为仅回滚。下面的<em class="ko"> insideService.method() </em>会抛出<em class="ko">NullPointerException</em>[<em class="ko">runtime exception】</em>。Spring会将当前事务标记为仅回滚，并抛出'<em class="ko">UnexpectedRollbackException【T21 ' '</em></p><pre class="kq kr ks kt gt mu mv mw bn mx my bi"><span id="3f56" class="mz lc it mv b be na nb l nc nd">@Service<br/>@Slf4j<br/>public class OutsideService {<br/>    @Transactional<br/>    public Team dbOperateAndCallTransactionalMethod(Team team){<br/>        teamRepository.save(team);<br/>        try{<br/>            insideService.REQUIRED_TransactionalMethodAndThrowNullPointerException();<br/>        } catch (NullPointerException e){<br/>            log.error("Exception Been catch without throws in current method transaction flow: {}", e.getMessage());<br/>        }<br/>        log.info("New Saved Team Id: {}", team.getId());<br/>        return team;<br/>    }<br/>}<br/><br/>    <br/>@Service<br/>public class InsideService {<br/>    @Transactional<br/>    public void REQUIRED_TransactionalMethodAndThrowNullPointerException(){<br/>        throw new NullPointerException("sth is null");<br/>    }<br/>}<br/><br/>public class PropagationUT {<br/>    @Test<br/>    void inside_method_throw_RuntimeException_with_default_REQUIRED_transaction() {<br/>        Team team = new Team("NGU");<br/>        assertThrows(UnexpectedRollbackException.class, () -&gt; outsideService.dbOperateAndCallTransactionalMethod(team),<br/>                "Transaction silently rolled back because it has been marked as rollback-only");<br/>        Optional&lt;Team&gt; newTeam = teamRepository.findByName("NGU");<br/>        assertFalse(newTeam.isPresent());<br/>    }<br/>}</span></pre><p id="6920" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">来完成用例。我们可以通过使用<em class="ko">@ Transactional(Propagation = Propagation)来实现。</em>对内部交易的要求_新)</p><pre class="kq kr ks kt gt mu mv mw bn mx my bi"><span id="a0ed" class="mz lc it mv b be na nb l nc nd">@Service<br/>@Slf4j<br/>public class OutsideService {<br/>    ...<br/><br/>    @Transactional<br/>    public Team dbOperateAndCallTransactionalMethod_REQUIRES_NEW(Team team){<br/>        teamRepository.save(team);<br/>        try{<br/>            insideService.REQUIRES_NEW_TransactionalMethodAndThrowRuntimeException();<br/>        } catch (NullPointerException e){<br/>            log.error("Exception Been catch without throws in current method transaction flow: {}", e.getMessage());<br/>        }<br/>        log.info("New Saved Team Id: {}", team.getId());<br/>        return team;<br/>    }<br/>}<br/><br/>@Service<br/>@Slf4j<br/>public class InsideService {<br/>    ...<br/><br/>    @Transactional(propagation = Propagation.REQUIRES_NEW)<br/>    public void REQUIRES_NEW_TransactionalMethodAndThrowRuntimeException(){<br/>        throw new NullPointerException("sth is null");<br/>    }<br/>}<br/><br/>public class PropagationUT {<br/>    ...<br/><br/>    @Test<br/>    void inside_method_throw_RuntimeException_with_REQUIRED_NEW_transaction() {<br/>        Team team = new Team("NGU");<br/>        assertDoesNotThrow(() -&gt; outsideService.dbOperateAndCallTransactionalMethod_REQUIRES_NEW(team));<br/>        Optional&lt;Team&gt; newTeam = teamRepository.findByName("NGU");<br/>        assertTrue(newTeam.isPresent());<br/>    }<br/>}</span></pre><p id="d83a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> 3.7.1异常已被方法self尝试。</strong></p><pre class="kq kr ks kt gt mu mv mw bn mx my bi"><span id="7e8d" class="mz lc it mv b be na nb l nc nd">@Transactional<br/>    public void tryCatch(Team team){<br/>        try {<br/>            teamRepository.save(team);<br/>            int a = 1/0;<br/>        } catch (Exception e) {<br/>            log.error(e.getMessage());<br/>        }<br/>    }<br/>    <br/>    @Test<br/>    void tryCatch_no_rollback() {<br/>        Team team = new Team("NGU");<br/>        assertDoesNotThrow(() -&gt; outsideService.tryCatch(team));<br/>        Optional&lt;Team&gt; newTeam = teamRepository.findByName("NGU");<br/>        assertTrue(newTeam.isPresent());<br/>    }</span></pre><p id="e94d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> 3.7.2尝试了异常，并在catch中抛出相同的异常</strong></p><pre class="kq kr ks kt gt mu mv mw bn mx my bi"><span id="815a" class="mz lc it mv b be na nb l nc nd">@Transactional<br/>  public void tryCatchAndThrow(Team team) throws Exception{<br/>      try {<br/>          teamRepository.save(team);<br/>          int a = 1/0;<br/>      } catch (Exception e) {<br/>          log.error(e.getMessage());<br/>          throw new Exception();<br/>      }<br/>  }<br/>  <br/>  @Test<br/>  void tryCatchAndThrow_no_rollback() {<br/>      Team team = new Team("NGU");<br/>      assertThrows(Exception.class, () -&gt; outsideService.tryCatchAndThrow(team));<br/>      Optional&lt;Team&gt; newTeam = teamRepository.findByName("NGU");<br/>      assertTrue(newTeam.isPresent());<br/>  }</span></pre><p id="8aad" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> 3.8手动抛出已检查的异常</strong></p><pre class="kq kr ks kt gt mu mv mw bn mx my bi"><span id="8f98" class="mz lc it mv b be na nb l nc nd">@Transactional<br/>    public void tryCatchAndThrowOtherCheckedException(Team team) throws TimeoutException {<br/>        try {<br/>            teamRepository.save(team);<br/>            int a = 1/0;<br/>        } catch (ArithmeticException e) {<br/>            log.error(e.getMessage());<br/>            throw new TimeoutException();<br/>        }<br/>    }<br/>    <br/>    @Test<br/>    void tryCatchAndThrowOtherCheckedException_no_rollback() {<br/>        Team team = new Team("NGU");<br/>        assertThrows(Exception.class, () -&gt; outsideService.tryCatchAndThrowOtherCheckedException(team));<br/>        Optional&lt;Team&gt; newTeam = teamRepository.findByName("NGU");<br/>        assertTrue(newTeam.isPresent());<br/>    }</span></pre><p id="425f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> 3.9手动抛出自定义检查异常。</strong></p><pre class="kq kr ks kt gt mu mv mw bn mx my bi"><span id="d0c2" class="mz lc it mv b be na nb l nc nd">public class MyCheckedException extends Exception {<br/><br/>    private static final long serialVersionUID = 1L;<br/>    private String message;<br/><br/>    @Override<br/>    public String getMessage() {<br/>        return message;<br/>    }<br/><br/>    public void setMessage(String message) {<br/>        this.message = message;<br/>    }<br/><br/>    public MyCheckedException(String message) {<br/>        this.message = message;<br/>    }<br/>}<br/><br/>@Transactional<br/>public void tryCatchAndThrowCustomizeCheckedException(Team team) throws MyCheckedException {<br/>  try {<br/>    teamRepository.save(team);<br/>    throw new MyCheckedException("my custom exception");<br/>  } catch (MyCheckedException e) {<br/>    log.error(e.getMessage());<br/>    throw new MyCheckedException("MyException");<br/>  }<br/>}<br/><br/><br/>@Test<br/>void tryCatchAndThrowCustomizeCheckedException_no_rollback() {<br/>  Team team = new Team("NGU");<br/>  assertThrows(Exception.class, () -&gt; outsideService.tryCatchAndThrowCustomizeCheckedException(team));<br/>  Optional&lt;Team&gt; newTeam = teamRepository.findByName("NGU");<br/>  assertTrue(newTeam.isPresent());<br/>}</span></pre><p id="81e3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是如果我们希望它在抛出定制异常时回滚呢？有两种方法。</p><p id="5a62" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">1.自定义异常从RuntimeException扩展而来。(代码省略)</p><p id="7e96" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">2.setRollbackOnly。</p><pre class="kq kr ks kt gt mu mv mw bn mx my bi"><span id="3350" class="mz lc it mv b be na nb l nc nd">@Transactional<br/>    public void tryCatchAndThrowCustomizeCheckedExceptionSetRollbackOnly(Team team) throws MyCheckedException {<br/>        try {<br/>            teamRepository.save(team);<br/>             throw new MyCheckedException("my custom exception");<br/>        } catch (MyCheckedException e) {<br/>            log.error(e.getMessage());<br/>            TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();<br/>            throw new MyCheckedException("MyException");<br/>        }<br/>    }<br/>    <br/>    @Test<br/>    void tryCatchAndThrowCustomizeCheckedException_setRollbackOnly_will_rollback() {<br/>        Team team = new Team("NGU");<br/>        assertThrows(Exception.class, () -&gt; outsideService.tryCatchAndThrowCustomizeCheckedExceptionSetRollbackOnly(team));<br/>        Optional&lt;Team&gt; newTeam = teamRepository.findByName("NGU");<br/>        assertFalse(newTeam.isPresent());<br/>    }</span></pre><p id="88f9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> 3.10捕捉自定义异常但不抛出。插入不会被回滚。</strong></p><pre class="kq kr ks kt gt mu mv mw bn mx my bi"><span id="ee66" class="mz lc it mv b be na nb l nc nd">@Transactional<br/>    public void tryCatchCustomizeException(Team team){<br/>        try {<br/>            teamRepository.save(team);<br/>            throw new MyCheckedException("my custom exception");<br/>        } catch (MyCheckedException e) {<br/>            log.error(e.getMessage());<br/>        }<br/>    }<br/><br/>    @Test<br/>    void tryCatch_CustomizeException_without_throw_no_rollback() {<br/>        Team team = new Team("NGU");<br/>        assertDoesNotThrow(() -&gt; outsideService.tryCatchCustomizeException(team));<br/>        Optional&lt;Team&gt; newTeam = teamRepository.findByName("NGU");<br/>        assertTrue(newTeam.isPresent());<br/>    }</span></pre><h1 id="380c" class="nq lc it bd ld nr ns nt lg nu nv nw lj nx ny nz lm oa ob oc lp od oe of ls og bi translated">4.最佳实践</h1><p id="0310" class="pw-post-body-paragraph jq jr it js b jt lu jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn im bi translated">4.1尽可能避免多头/大额交易。</p><p id="d9db" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为长期/大额交易会产生很多问题。</p><ul class=""><li id="6771" class="lz ma it js b jt ju jx jy kb mb kf mc kj md kn me mf mg mh bi translated">回滚发生的时间会很长。</li><li id="78e4" class="lz ma it js b jt mj jx mk kb ml kf mm kj mn kn me mf mg mh bi translated">当并发操作可能接管所有活动的数据库连接时</li><li id="8448" class="lz ma it js b jt mj jx mk kb ml kf mm kj mn kn me mf mg mh bi translated">如果端点有一个长事务，可能会导致响应超时。</li><li id="44a4" class="lz ma it js b jt mj jx mk kb ml kf mm kj mn kn me mf mg mh bi translated">僵局</li><li id="60a5" class="lz ma it js b jt mj jx mk kb ml kf mm kj mn kn me mf mg mh bi translated">锁定等待</li></ul><p id="ac18" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">4.2将select/query DB操作方法放到事务之外。</p><p id="25eb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">4.3避免一个事务处理太多数据。</p><p id="e89c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">4.4避免将远程调用放入事务中。(远程呼叫可能需要一段时间)</p><p id="f210" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">4.5一些需要的功能可能我们不需要使用事务。或者我们可以使用@Async来处理它。</p><p id="d2aa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi">— — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — — —</p><p id="50c4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">就是这样。我尽量不把文章写得太长，我会根据你的反馈考虑写第二部分。</p><p id="7821" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第二部分。也许关注 <strong class="js iu"> <em class="ko">潜入事务的传播行为和事务的隔离级别。</em> </strong>如果你想看，请在评论中留言。</p><p id="dc5e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">感谢阅读！如果你喜欢它或觉得它有帮助，请点击鼓掌:)</p><p id="2747" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">快乐编码。下次见:)</p></div></div>    
</body>
</html>