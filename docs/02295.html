<html>
<head>
<title>Two Sum Interview Problem in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中两个Sum面试问题</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/two-sum-interview-problem-in-python-c1d84b029d35?source=collection_archive---------0-----------------------#2020-03-04">https://levelup.gitconnected.com/two-sum-interview-problem-in-python-c1d84b029d35?source=collection_archive---------0-----------------------#2020-03-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/18a239598a1b6f4e6988c0f86d958596.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ETTIDamOmYZ7u7YjJvGuFA.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">由<a class="ae kf" href="https://unsplash.com/@thisisengineering?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> ThisisEngineering RAEng </a>在<a class="ae kf" href="https://unsplash.com/s/photos/whiteboard?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><h1 id="c083" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">问题是:</h1><p id="2aad" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">给定一个整数数组，返回两个数的索引<strong class="lg iu">和</strong>，这样它们加起来就是一个特定的<code class="fe mc md me mf b">target</code>。</p><p id="4d33" class="pw-post-body-paragraph le lf it lg b lh mg lj lk ll mh ln lo lp mi lr ls lt mj lv lw lx mk lz ma mb im bi translated">你可以假设每个输入都有<strong class="lg iu"> <em class="ml">恰好</em> </strong>一个解，并且你不能两次使用<em class="ml">相同的</em>元素。</p><p id="0ce8" class="pw-post-body-paragraph le lf it lg b lh mg lj lk ll mh ln lo lp mi lr ls lt mj lv lw lx mk lz ma mb im bi translated"><strong class="lg iu">示例:</strong></p><pre class="mm mn mo mp gt mq mf mr ms aw mt bi"><span id="c974" class="mu kh it mf b gy mv mw l mx my">Given nums = [2, 7, 11, 15], target = 9,</span><span id="75ba" class="mu kh it mf b gy mz mw l mx my">Because nums[<strong class="mf iu">0</strong>] + nums[<strong class="mf iu">1</strong>] = 2 + 7 = 9,<br/>return [<strong class="mf iu">0</strong>, <strong class="mf iu">1</strong>].</span></pre><h1 id="0206" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated"><strong class="ak">解决方案:</strong></h1><p id="f4a9" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">关于这个问题，我真正欣赏的一点是，解决这个问题有多种方式，每种解决方案都需要不同的思维方式，然后你才能得出解决方案的想法。</p><h2 id="362f" class="mu kh it bd ki na nb dn km nc nd dp kq lp ne nf ku lt ng nh ky lx ni nj lc nk bi translated">强力解决方案:</h2><p id="f5d2" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">解决这个挑战的第一个方法可能是大多数人第一次看到这个问题时想到的方法。该解决方案的伪代码如下所示:</p><pre class="mm mn mo mp gt mq mf mr ms aw mt bi"><span id="d945" class="mu kh it mf b gy mv mw l mx my">for each number X in list of numbers:<br/>    for each number Y in list of numbers starting from X:<br/>        if X+Y equal target number, return indices</span></pre><p id="12fa" class="pw-post-body-paragraph le lf it lg b lh mg lj lk ll mh ln lo lp mi lr ls lt mj lv lw lx mk lz ma mb im bi translated">问题是最坏情况下的运行时间是O(n)。如果您要搜索的两个数字在列表的末尾，您将需要多次遍历所有的数字，一次在“X”循环中，一次在“Y”循环中。</p><p id="5705" class="pw-post-body-paragraph le lf it lg b lh mg lj lk ll mh ln lo lp mi lr ls lt mj lv lw lx mk lz ma mb im bi translated">这将会给你正确的答案，但是运行时间很慢，并且在大量数字的情况下，这可能会很成问题。</p><pre class="mm mn mo mp gt mq mf mr ms aw mt bi"><span id="0e0a" class="mu kh it mf b gy mv mw l mx my">def twoSum(self, nums: List[int], target: int) -&gt; List[int]:<br/>        for i in range(len(nums)):<br/>            for j in range(i+1, len(nums)):<br/>                if nums[i] + nums[j] == target:<br/>                    return [i, j]</span></pre><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nl"><img src="../Images/a4744ea70656dc18e9d7269e0ffbc36f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yAjKjrwEN5TvciGpBINZSA.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">这个解决方案非常慢，即使内存使用不是太糟糕</figcaption></figure><p id="e0da" class="pw-post-body-paragraph le lf it lg b lh mg lj lk ll mh ln lo lp mi lr ls lt mj lv lw lx mk lz ma mb im bi translated">如果你在一家大公司的面试中，这是你的最终解决方案，在那里他们可能会非常强调效率，你可能会有麻烦。</p><h2 id="483f" class="mu kh it bd ki na nb dn km nc nd dp kq lp ne nf ku lt ng nh ky lx ni nj lc nk bi translated">字典解决方案:</h2><p id="6306" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">在花了一些时间思考这个问题后，我得出了一个不同的解决方案，正如我上面提到的，这需要一个不同的思考角度。</p><p id="9bff" class="pw-post-body-paragraph le lf it lg b lh mg lj lk ll mh ln lo lp mi lr ls lt mj lv lw lx mk lz ma mb im bi translated">这个解决方案利用了一个字典(或关键值图)，正如我在之前的一篇文章中提到的，由于它的超级快速的价值查找，在面试挑战中非常有用。</p><p id="9a7e" class="pw-post-body-paragraph le lf it lg b lh mg lj lk ll mh ln lo lp mi lr ls lt mj lv lw lx mk lz ma mb im bi translated">我们的想法是，不要寻找两个数字相加得到目标数字，而是执行以下操作:</p><pre class="mm mn mo mp gt mq mf mr ms aw mt bi"><span id="43de" class="mu kh it mf b gy mv mw l mx my">instantiate an empty dictionary</span><span id="6c60" class="mu kh it mf b gy mz mw l mx my">for each number in list of numbers:<br/>    result = subtract number from target number<br/>    look for result in the dictionary (instant lookup)<br/>    if found:<br/>        return index of number and index of dictionary lookup result<br/>    else:<br/>        add number to dictionary as key with value being the index</span></pre><p id="9a34" class="pw-post-body-paragraph le lf it lg b lh mg lj lk ll mh ln lo lp mi lr ls lt mj lv lw lx mk lz ma mb im bi translated">将思维方式从“number1 + number2 = target”转换到“target - number1 = number2”起初并不太容易，但是这样做不仅允许使用键值映射，而且只需要数字列表的一次迭代，这意味着最坏情况下的运行时间为O(n ),这明显优于蛮力方法的O(n)。</p><pre class="mm mn mo mp gt mq mf mr ms aw mt bi"><span id="4712" class="mu kh it mf b gy mv mw l mx my">def twoSum(self, nums: List[int], target: int) -&gt; List[int]:<br/>        dictionary = {}<br/>        answer = []<br/>        <br/>        for i in range(len(nums)):<br/>            secondNumber = target-nums[i]<br/>            if(secondNumber in dictionary.keys()):<br/>                secondIndex = nums.index(secondNumber)<br/>                if(i != secondIndex):<br/>                    return sorted([i, secondIndex])<br/>                <br/>            dictionary.update({nums[i]: i})</span></pre><figure class="mm mn mo mp gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nm"><img src="../Images/7a56bebb1eba03724a4087eb488ccbb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2IRll46NMBaFpgam1Ygb4A.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">48毫秒和平均内存使用量，我对这个解决方案相当满意。</figcaption></figure></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><p id="11ae" class="pw-post-body-paragraph le lf it lg b lh mg lj lk ll mh ln lo lp mi lr ls lt mj lv lw lx mk lz ma mb im bi translated">你想看到我崩溃吗？下面评论一下！</p><p id="9ac0" class="pw-post-body-paragraph le lf it lg b lh mg lj lk ll mh ln lo lp mi lr ls lt mj lv lw lx mk lz ma mb im bi translated">感谢阅读！关于软件开发实践的一些技巧，请查看我的系列文章</p></div></div>    
</body>
</html>