<html>
<head>
<title>Deploy and Secure MongoDB on Atlas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Atlas上部署和保护MongoDB</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/part-2-deploy-and-secure-mongodb-on-atlas-4820d539a1dc?source=collection_archive---------1-----------------------#2019-02-01">https://levelup.gitconnected.com/part-2-deploy-and-secure-mongodb-on-atlas-4820d539a1dc?source=collection_archive---------1-----------------------#2019-02-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/0f35ca82058d1eaf44d1b3eb55152cc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dd1_V4HSmaSnPoTNH10bpg.jpeg"/></div></div></figure><h2 id="c811" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">目录</h2><ul class=""><li id="71c2" class="ku kv iq kw b kx ky kz la kh lb kl lc kp ld le lf lg lh li bi translated"><a class="ae lj" href="https://medium.com/p/4820d539a1dc#1b03" rel="noopener">简介</a></li><li id="4693" class="ku kv iq kw b kx lk kz ll kh lm kl ln kp lo le lf lg lh li bi translated"><a class="ae lj" href="https://medium.com/p/4820d539a1dc#8d55" rel="noopener">在Mongo Atlas上部署MongoDB</a></li><li id="187b" class="ku kv iq kw b kx lk kz ll kh lm kl ln kp lo le lf lg lh li bi translated"><a class="ae lj" href="https://medium.com/p/4820d539a1dc#bbc9" rel="noopener">用MongoDB配置node . js app</a></li><li id="8721" class="ku kv iq kw b kx lk kz ll kh lm kl ln kp lo le lf lg lh li bi translated"><a class="ae lj" href="https://medium.com/p/4820d539a1dc#a88f" rel="noopener">测试MongoDB连接</a></li><li id="0f7e" class="ku kv iq kw b kx lk kz ll kh lm kl ln kp lo le lf lg lh li bi translated"><a class="ae lj" href="https://medium.com/p/4820d539a1dc#42ba" rel="noopener">配置NAT网关</a></li><li id="fa01" class="ku kv iq kw b kx lk kz ll kh lm kl ln kp lo le lf lg lh li bi translated"><a class="ae lj" href="https://medium.com/p/4820d539a1dc#2408" rel="noopener">安全MongoDB集群</a></li><li id="e76a" class="ku kv iq kw b kx lk kz ll kh lm kl ln kp lo le lf lg lh li bi translated"><a class="ae lj" href="https://medium.com/p/4820d539a1dc#ee7e" rel="noopener">检查一切正常</a></li></ul><h1 id="1b03" class="lp jz iq bd ka lq lr ls kd lt lu lv kg lw lx ly kk lz ma mb ko mc md me ks mf bi translated">介绍</h1><p id="ca40" class="pw-post-body-paragraph mg mh iq kw b kx ky mi mj kz la mk ml kh mm mn mo kl mp mq mr kp ms mt mu le ij bi translated">这篇文章是我上一篇文章<a class="ae lj" href="https://medium.com/@francescovirga_50717/dockerizing-and-autoscaling-node-js-on-google-cloud-ef8db3b99486" rel="noopener">在Google Cloud上Dockerizing和auto scaling Node.js</a>的延续，这篇文章概述了如何在Google Cloud上部署和扩展node . js。第一篇文章中的各种组件和配置会在这里被引用，所以我建议你如果还没有的话，可以去看看。</p><p id="e496" class="pw-post-body-paragraph mg mh iq kw b kx mv mi mj kz mw mk ml kh mx mn mo kl my mq mr kp mz mt mu le ij bi translated">对于本教程，我们将从通过Mongo Atlas部署一个MongoDB实例开始。然后，我们将Node.js应用程序连接到数据库，最后配置一个NAT(网络地址转换)网关，通过同一个IP地址路由所有的输出流量。这将允许我们将该IP列入MongoDB部署的白名单，确保只有我们自己的虚拟机可以访问数据库。NAT网关是必需的，因为我们的托管实例组会在虚拟机自动添加或删除时为其重新分配新的IP地址(因为我们的托管实例组配置为自动扩展)。</p><p id="c12b" class="pw-post-body-paragraph mg mh iq kw b kx mv mi mj kz mw mk ml kh mx mn mo kl my mq mr kp mz mt mu le ij bi translated">我把我自己的代码上传到GitHub <a class="ae lj" href="https://github.com/francescov1/gcloud-docker-node-tutorial" rel="noopener ugc nofollow" target="_blank">这里</a>以防你在这个过程中遇到任何问题，所以确保把它放在手边以防万一！</p><h1 id="8d55" class="lp jz iq bd ka lq lr ls kd lt lu lv kg lw lx ly kk lz ma mb ko mc md me ks mf bi translated">在Mongo Atlas上部署MongoDB</h1><p id="8515" class="pw-post-body-paragraph mg mh iq kw b kx ky mi mj kz la mk ml kh mm mn mo kl mp mq mr kp ms mt mu le ij bi translated">Mongo Atlas在部署和管理MongoDB部署方面绝对令人惊叹。它允许我们在各种云提供商(Google Cloud、AWS和Azure)上部署我们的数据库，选择要部署的区域和正在使用的虚拟机的确切规格。最好的部分是，一旦我们部署，我们可以很容易地改变任何这些配置和Mongo Atlas将自动迁移我们所有的数据到一个新的虚拟机与新的设置。它还允许我们将MongoDB放在与托管实例组VM相同的地理位置，确保服务器之间的通信经历尽可能低的延迟。</p><figure class="nb nc nd ne gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi na"><img src="../Images/3b53fd806e68bf30f641b472c775fee8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9dV_zys4ZIJQp3pEgbSvSw.jpeg"/></div></div></figure><p id="662e" class="pw-post-body-paragraph mg mh iq kw b kx mv mi mj kz mw mk ml kh mx mn mo kl my mq mr kp mz mt mu le ij bi translated">前往<a class="ae lj" href="https://www.mongodb.com/cloud/atlas" rel="noopener ugc nofollow" target="_blank">https://www.mongodb.com/cloud/atlas</a>，点击<em class="nf">免费试用。</em>注册后，您应该会立即进入一个页面，在这里您可以配置和部署您的第一个MongoDB集群。集群就是一组共享相同数据的MongoDB实例。</p><p id="8755" class="pw-post-body-paragraph mg mh iq kw b kx mv mi mj kz mw mk ml kh mx mn mo kl my mq mr kp mz mt mu le ij bi translated">对于云提供商，选择<em class="nf"> Google Cloud </em>，以及<em class="nf"> lowa(美国中部-1) </em>作为地区。<strong class="kw ir">通常，我们会希望确保我们的MongoDB部署与我们在Google Cloud中的托管实例组位于同一区域(在我们的示例中，这是<em class="nf"> South Carolina (us-east1) </em>)，但出于本教程的目的，我们将坚持使用us-central1，以允许我们使用自由层。</strong>将<em class="nf">集群层</em>设置为<em class="nf"> M0 </em>，因为这将确保我们不会产生任何费用，并将<em class="nf">附加设置</em>保持不变。最后，为您的集群名称输入<strong class="kw ir"> gcloud-docker-node-db </strong>，以保持与我们在<a class="ae lj" href="https://medium.com/@francescovirga_50717/dockerizing-and-autoscaling-node-js-on-google-cloud-ef8db3b99486" rel="noopener">上一篇文章</a>中的命名约定一致。点击<em class="nf">创建集群</em>。</p><p id="6f3e" class="pw-post-body-paragraph mg mh iq kw b kx mv mi mj kz mw mk ml kh mx mn mo kl my mq mr kp mz mt mu le ij bi translated"><em class="nf">注意:在为生产部署数据库时，确保将您的层至少升级到</em><strong class="kw ir"><em class="nf"/></strong><em class="nf">M10。</em></p></div><div class="ab cl ng nh hu ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ij ik il im in"><p id="1489" class="pw-post-body-paragraph mg mh iq kw b kx mv mi mj kz mw mk ml kh mx mn mo kl my mq mr kp mz mt mu le ij bi translated">当集群初始化时，在你的Mongo Atlas控制台中进入<em class="nf">安全</em>选项卡，在<em class="nf"> MongoDB用户</em>下点击<em class="nf">添加新用户</em>。输入<strong class="kw ir">默认</strong>作为用户名，点击<em class="nf">自动生成安全密码</em>填写密码栏，点击<em class="nf">显示</em>并确保复制生成的密码(如果丢失不用担心，您可以简单地生成一个新的)。将<em class="nf">用户权限</em>设置为<strong class="kw ir"> <em class="nf">读写任意数据库</em> </strong>，点击<em class="nf">添加用户。</em></p><p id="6d34" class="pw-post-body-paragraph mg mh iq kw b kx mv mi mj kz mw mk ml kh mx mn mo kl my mq mr kp mz mt mu le ij bi translated">接下来点击<em class="nf"> IP白名单</em>并点击<em class="nf">添加IP地址</em>。点击<em class="nf">允许从任何地方访问</em>并点击<em class="nf">确认</em>。这打开了我们的MongoDB，可以从任何IP地址访问它(仍然需要MongoDB用户名和密码来连接，所以我们还没有完全向所有人开放我们的数据库)。不要担心，一旦我们配置了NAT网关，我们会阻止它只对我们的谷歌虚拟机开放。</p><p id="3147" class="pw-post-body-paragraph mg mh iq kw b kx mv mi mj kz mw mk ml kh mx mn mo kl my mq mr kp mz mt mu le ij bi translated">现在回到<em class="nf">概述</em>选项卡，一旦集群完成初始化，点击<em class="nf">连接</em>，然后点击<em class="nf">连接您的应用</em>。选择<em class="nf">短SRV连接串</em>并记下如下所示的连接串。</p><h1 id="bbc9" class="lp jz iq bd ka lq lr ls kd lt lu lv kg lw lx ly kk lz ma mb ko mc md me ks mf bi translated">用MongoDB配置Node.js应用程序</h1><p id="43c4" class="pw-post-body-paragraph mg mh iq kw b kx ky mi mj kz la mk ml kh mm mn mo kl mp mq mr kp ms mt mu le ij bi translated">在上一个教程中，我们简单地使用了一个<a class="ae lj" href="https://github.com/francescov1/node-boilerplate-script" rel="noopener ugc nofollow" target="_blank">样板文件生成器脚本</a>来生成我们的Node.js/Express应用程序。现在，我们将配置到MongoDB集群的连接，并添加一些基本路由，这将允许我们测试一切是否正常工作。</p><p id="d2ad" class="pw-post-body-paragraph mg mh iq kw b kx mv mi mj kz mw mk ml kh mx mn mo kl my mq mr kp mz mt mu le ij bi translated">我们要做的第一件事是将MongoDB连接字符串保存在我们的<em class="nf">中。env </em>文件。添加以下一行:</p><pre class="nb nc nd ne gt nn no np nq aw nr bi"><span id="2ecc" class="jy jz iq no b gy ns nt l nu nv">MONGODB_URI=&lt;connection-string&gt;</span></pre><p id="503e" class="pw-post-body-paragraph mg mh iq kw b kx mv mi mj kz mw mk ml kh mx mn mo kl my mq mr kp mz mt mu le ij bi translated">在连接字符串中，将单词<em class="nf"> test </em>替换为<em class="nf"> default </em>，它定义了数据库名称，位于<code class="fe nw nx ny no b">?retryWrites=true</code>之前。确保用您之前保存的数据库用户密码替换<code class="fe nw nx ny no b">&lt;PASSWORD&gt;</code>。</p><p id="725e" class="pw-post-body-paragraph mg mh iq kw b kx mv mi mj kz mw mk ml kh mx mn mo kl my mq mr kp mz mt mu le ij bi translated">我们还必须更改我们的<em class="nf"> config/index.js </em>文件来导出连接字符串。你的<em class="nf"> config/index.js </em>文件应该是这样的:</p><pre class="nb nc nd ne gt nn no np nq aw nr bi"><span id="cc1c" class="jy jz iq no b gy ns nt l nu nv">'use strict';<br/>require('dotenv').config();</span><span id="8a7a" class="jy jz iq no b gy nz nt l nu nv">module.exports = {<br/>  port: process.env.PORT || 3000,<br/>  node_env: process.env.NODE_ENV || 'development',<br/>  mongodb_uri: process.env.MONGODB_URI<br/>};</span></pre><p id="f232" class="pw-post-body-paragraph mg mh iq kw b kx mv mi mj kz mw mk ml kh mx mn mo kl my mq mr kp mz mt mu le ij bi translated">接下来用<code class="fe nw nx ny no b">touch config/mongoose.js</code>创建一个mongoose配置文件，我们将在其中连接和配置我们的数据库。添加以下代码:</p><pre class="nb nc nd ne gt nn no np nq aw nr bi"><span id="a488" class="jy jz iq no b gy ns nt l nu nv">'use strict';<br/>const config = require('./');</span><span id="a41c" class="jy jz iq no b gy nz nt l nu nv">module.exports = function() {</span><span id="3a51" class="jy jz iq no b gy nz nt l nu nv">  const mongoose = require('mongoose');<br/>  mongoose.Promise = require('bluebird');</span><span id="f8af" class="jy jz iq no b gy nz nt l nu nv">  // set up database<br/>  mongoose.connect(config.mongodb_uri, { useNewUrlParser: true });</span><span id="7127" class="jy jz iq no b gy nz nt l nu nv">  mongoose.connection.on('connected', () =&gt; console.log('mongodb connected'));</span><span id="573a" class="jy jz iq no b gy nz nt l nu nv">  mongoose.connection.on('open', () =&gt; console.log('mongodb connection opened'));</span><span id="d420" class="jy jz iq no b gy nz nt l nu nv">  mongoose.connection.on('error', err =&gt; console.log('mongodb error: ' + err));</span><span id="8ccc" class="jy jz iq no b gy nz nt l nu nv">  mongoose.connection.on('disconnected', () =&gt; console.log('mongodb disconnected'));</span><span id="0ca8" class="jy jz iq no b gy nz nt l nu nv">  process.on('SIGINT', () =&gt; mongoose.connection.close(() =&gt; process.exit(0)));</span><span id="7678" class="jy jz iq no b gy nz nt l nu nv">};</span></pre><p id="7333" class="pw-post-body-paragraph mg mh iq kw b kx mv mi mj kz mw mk ml kh mx mn mo kl my mq mr kp mz mt mu le ij bi translated">这将使用连接字符串连接到我们的MongoDB集群，并设置一些日志让我们知道数据库连接的状态。</p><p id="bf63" class="pw-post-body-paragraph mg mh iq kw b kx mv mi mj kz mw mk ml kh mx mn mo kl my mq mr kp mz mt mu le ij bi translated">接下来我们将为<code class="fe nw nx ny no b">routes/examples.js</code>添加两个routes函数，一个用于添加新用户，另一个用于获取用户。打开文件，将代码替换为以下内容:</p><pre class="nb nc nd ne gt nn no np nq aw nr bi"><span id="5e33" class="jy jz iq no b gy ns nt l nu nv">'use strict';<br/>const User = require('../models/user');<br/>const express = require('express');<br/>const router = express.Router();</span><span id="8bfe" class="jy jz iq no b gy nz nt l nu nv">router.post('/', (req, res, next) =&gt; {<br/>  const { email, name } = req.body;<br/>  const user = new User({ name, email });<br/>  return user.save()<br/>    .then(user =&gt; res.status(201).send(user))<br/>    .catch(err =&gt; next(err));<br/>});</span><span id="db0c" class="jy jz iq no b gy nz nt l nu nv">router.get('/:id', (req, res, next) =&gt; {<br/>  return User.findById(req.params.id)<br/>    .then(user =&gt; res.status(200).send(user))<br/>    .catch(err =&gt; next(err));<br/>});</span><span id="3c8e" class="jy jz iq no b gy nz nt l nu nv">module.exports = router;</span></pre><p id="6f17" class="pw-post-body-paragraph mg mh iq kw b kx mv mi mj kz mw mk ml kh mx mn mo kl my mq mr kp mz mt mu le ij bi translated">我们需要做的最后一件事是调用在<code class="fe nw nx ny no b">config/mongoose.js</code>中导出的函数来连接数据库。您的<code class="fe nw nx ny no b">index.js</code>文件应该如下所示:</p><pre class="nb nc nd ne gt nn no np nq aw nr bi"><span id="e2e7" class="jy jz iq no b gy ns nt l nu nv">'use strict';<br/>Promise = require('bluebird');<br/>const config = require('./config');<br/>const express = require('express');<br/>const helmet = require('helmet');<br/>const bodyParser = require('body-parser');<br/>const logger = require("morgan");</span><span id="ddcf" class="jy jz iq no b gy nz nt l nu nv">const routes = require('./routes');<br/>const errors = require('./errors/middleware');</span><span id="d4eb" class="jy jz iq no b gy nz nt l nu nv">require('./config/mongoose')();</span><span id="ef6b" class="jy jz iq no b gy nz nt l nu nv">const app = express();</span><span id="ad8d" class="jy jz iq no b gy nz nt l nu nv">// basic middleware<br/>app.use(helmet());<br/>app.use(logger(config.node_env === "production" ? "combined" : "dev"));<br/>app.use(bodyParser.json());</span><span id="f420" class="jy jz iq no b gy nz nt l nu nv">// api routes<br/>app.use('/api', routes)</span><span id="c8ac" class="jy jz iq no b gy nz nt l nu nv">// error middleware<br/>app.use(errors)</span><span id="d5b6" class="jy jz iq no b gy nz nt l nu nv">app.all("*", (req, res) =&gt; res.status(200).send("My Node.js API"));</span><span id="cfcd" class="jy jz iq no b gy nz nt l nu nv">app.listen(config.port, () =&gt; {<br/>  console.log(`Server listening on port ${config.port}...`)<br/>});</span></pre><p id="fa4e" class="pw-post-body-paragraph mg mh iq kw b kx mv mi mj kz mw mk ml kh mx mn mo kl my mq mr kp mz mt mu le ij bi translated">注意<code class="fe nw nx ny no b">require('./config/mongoose')();</code>线。现在，您应该能够在您的控制台中运行<code class="fe nw nx ny no b">npm start</code>，并看到以下内容:</p><pre class="nb nc nd ne gt nn no np nq aw nr bi"><span id="d579" class="jy jz iq no b gy ns nt l nu nv">server listening on port 3000...<br/>mongodb connected<br/>mongodb connection opened</span></pre><p id="8bc8" class="pw-post-body-paragraph mg mh iq kw b kx mv mi mj kz mw mk ml kh mx mn mo kl my mq mr kp mz mt mu le ij bi translated">恭喜你。我们现在已经部署了一个MongoDB集群，并成功地在本地连接到它。</p><p id="1345" class="pw-post-body-paragraph mg mh iq kw b kx mv mi mj kz mw mk ml kh mx mn mo kl my mq mr kp mz mt mu le ij bi translated">现在还记得我们在上一个教程中写的那个<code class="fe nw nx ny no b">deploy.sh</code>文件吗？保存上面的更改后，只需在控制台中运行<code class="fe nw nx ny no b">./deploy.sh</code>即可部署新的Docker映像并重启虚拟机。</p><h1 id="a88f" class="lp jz iq bd ka lq lr ls kd lt lu lv kg lw lx ly kk lz ma mb ko mc md me ks mf bi translated">测试MongoDB连接</h1><p id="d23b" class="pw-post-body-paragraph mg mh iq kw b kx ky mi mj kz la mk ml kh mm mn mo kl mp mq mr kp ms mt mu le ij bi translated">现在让我们尝试一下我们创建的新路由，以确保它们能够与我们的MongoDB集群正常通信。请记住，重新启动我们的托管实例组可能需要几分钟时间，因此在继续之前，让我们确保我们的虚拟机已经重新启动。运行:</p><pre class="nb nc nd ne gt nn no np nq aw nr bi"><span id="7ce7" class="jy jz iq no b gy ns nt l nu nv">gcloud beta compute instance-groups managed list-instances gcloud-docker-node-group --zone us-east1-b</span></pre><p id="e024" class="pw-post-body-paragraph mg mh iq kw b kx mv mi mj kz mw mk ml kh mx mn mo kl my mq mr kp mz mt mu le ij bi translated">您对此命令感兴趣的输出是<em class="nf">状态</em>和<em class="nf">动作</em>。初始<em class="nf">状态</em> = <em class="nf">运行</em>和<em class="nf">动作</em> = <em class="nf">重启</em>。继续每隔一分钟左右运行一次命令<em class="nf"> ACTION </em> = <em class="nf"> NONE </em>我们知道至少有一个虚拟机已经完全重启，并且正在运行新的Docker映像。</p><p id="0ce7" class="pw-post-body-paragraph mg mh iq kw b kx mv mi mj kz mw mk ml kh mx mn mo kl my mq mr kp mz mt mu le ij bi translated">一旦完成，在<a class="ae lj" href="https://console.cloud.google.com/networking/addresses/list" rel="noopener ugc nofollow" target="_blank">https://console.cloud.google.com/networking/addresses/list</a>(我们在<a class="ae lj" href="https://medium.com/@francescovirga_50717/dockerizing-and-autoscaling-node-js-on-google-cloud-ef8db3b99486" rel="noopener">第1部分</a>中分配的)获取您的负载平衡器的外部IP，我们将发出创建新用户的POST请求。在命令行中输入以下命令:</p><pre class="nb nc nd ne gt nn no np nq aw nr bi"><span id="784b" class="jy jz iq no b gy ns nt l nu nv">curl --header "Content-Type: application/json" \<br/>     --data '{"name":"Joe Smith","email":"<a class="ae lj" href="mailto:joe@smith.com" rel="noopener ugc nofollow" target="_blank">joe@smith.com</a>"}' \<br/>     <a class="ae lj" href="http://localhost:3000/api/examples" rel="noopener ugc nofollow" target="_blank">&lt;ip-address&gt;/api/examples</a></span></pre><p id="2668" class="pw-post-body-paragraph mg mh iq kw b kx mv mi mj kz mw mk ml kh mx mn mo kl my mq mr kp mz mt mu le ij bi translated">应该返回一个包含用户数据库条目的JSON对象。我们可以从返回的对象中获取<em class="nf"> _id </em>属性，并使用<em class="nf">获取用户</em>路径来查找我们刚刚创建的用户:</p><pre class="nb nc nd ne gt nn no np nq aw nr bi"><span id="82ec" class="jy jz iq no b gy ns nt l nu nv">curl <a class="ae lj" href="http://localhost:3000/api/examples" rel="noopener ugc nofollow" target="_blank">&lt;ip-address&gt;/api/examples</a>/&lt;_id&gt;</span></pre><p id="f3aa" class="pw-post-body-paragraph mg mh iq kw b kx mv mi mj kz mw mk ml kh mx mn mo kl my mq mr kp mz mt mu le ij bi translated">这将再次返回新用户。</p><h1 id="42ba" class="lp jz iq bd ka lq lr ls kd lt lu lv kg lw lx ly kk lz ma mb ko mc md me ks mf bi translated">配置NAT网关</h1><p id="27f3" class="pw-post-body-paragraph mg mh iq kw b kx ky mi mj kz la mk ml kh mm mn mo kl mp mq mr kp ms mt mu le ij bi translated">现在一切都按预期运行了，让我们配置一个出站IP地址，允许我们将所有MongoDB通信限制到一个IP地址。</p><p id="0d93" class="pw-post-body-paragraph mg mh iq kw b kx mv mi mj kz mw mk ml kh mx mn mo kl my mq mr kp mz mt mu le ij bi translated">简单来说，Google的网络地址转换服务Cloud NAT允许我们为我们的虚拟机提供一个网关来访问互联网，即使它们没有自己的外部IP地址。当我们希望在关闭传入流量的同时仍然允许传出流量时，通常会使用这种方法。在我们的例子中，所有传入流量都是从我们的负载平衡器接收的，然后使用它们的内部IP地址重定向到我们的虚拟机，因此，我们可以将所有流量路由到同一个NAT网关，而不是为每个虚拟机的出站请求提供自己的外部IP地址。</p><p id="3fcb" class="pw-post-body-paragraph mg mh iq kw b kx mv mi mj kz mw mk ml kh mx mn mo kl my mq mr kp mz mt mu le ij bi translated">前往<a class="ae lj" href="https://console.cloud.google.com/net-services/nat/" rel="noopener ugc nofollow" target="_blank">https://console.cloud.google.com/net-services/nat</a>，点击<em class="nf">开始</em>。将其命名为<strong class="kw ir"> gcloud-docker-node-nat </strong>，选择<strong class="kw ir"> us-east1 </strong>作为区域，点击<em class="nf">云路由器</em>下拉菜单，点击<em class="nf">创建新路由器</em>。将其命名为<strong class="kw ir">g cloud-docker-node-router</strong>并点击<em class="nf"> Create </em>。点击<em class="nf"> Nat IP地址</em>下拉菜单，选择<strong class="kw ir">手动</strong> <em class="nf">。</em>这将允许我们手动选择所使用的出站IP地址。点击<em class="nf"> IP地址</em>下拉菜单，选择<strong class="kw ir">创建IP地址</strong>，输入<strong class="kw ir"> nat-ip </strong>作为名称，点击<em class="nf"> Reserve </em>。最后，点击<em class="nf">创建</em>。记下刚刚分配给NAT网关的新IP地址。</p><p id="6aa8" class="pw-post-body-paragraph mg mh iq kw b kx mv mi mj kz mw mk ml kh mx mn mo kl my mq mr kp mz mt mu le ij bi translated">我们现在必须从托管实例组中删除外部IP，以强制流量通过NAT网关。为此，我们需要更改实例模板，以指定我们不希望将外部IP自动分配给我们的托管实例组虚拟机。不幸的是，谷歌云不允许我们编辑实例模板，所以我们需要创建一个新的。前往<a class="ae lj" href="https://console.cloud.google.com/compute/instanceTemplates" rel="noopener ugc nofollow" target="_blank">https://console.cloud.google.com/compute/instanceTemplates</a>并点击<em class="nf">创建实例模板</em>。我们将创建一个与上一篇文章几乎相同的模板，所以返回<a class="ae lj" href="https://medium.com/@francescovirga_50717/dockerizing-and-autoscaling-node-js-on-google-cloud-ef8db3b99486/#6387" rel="noopener">这里</a>并复制实例模板。唯一需要的更改是更改名称和删除外部IP。名称输入<strong class="kw ir">g cloud-docker-node-template-2</strong>(创意对吧？)并在<em class="nf">外部IP </em>下拉菜单下选择<strong class="kw ir">无</strong>。点击<em class="nf">创建</em>。</p><p id="09d5" class="pw-post-body-paragraph mg mh iq kw b kx mv mi mj kz mw mk ml kh mx mn mo kl my mq mr kp mz mt mu le ij bi translated">通过单击侧栏中的<em class="nf">实例组</em>导航到您的托管实例组，选择实例组并单击页面顶部的编辑图标。打开<em class="nf">实例模板</em>下拉菜单，选择我们的新模板并点击<em class="nf">保存</em>。</p><h1 id="2408" class="lp jz iq bd ka lq lr ls kd lt lu lv kg lw lx ly kk lz ma mb ko mc md me ks mf bi translated">安全MongoDB集群</h1><p id="26dd" class="pw-post-body-paragraph mg mh iq kw b kx ky mi mj kz la mk ml kh mm mn mo kl mp mq mr kp ms mt mu le ij bi translated">导航回Mongo Atlas并点击<em class="nf">安全</em>选项卡。点击<em class="nf"> IP白名单</em>，点击<em class="nf">编辑</em>。用您之前保存的nat-ip地址替换0.0.0.0/0，并点击<em class="nf">确认</em>。</p><h1 id="ee7e" class="lp jz iq bd ka lq lr ls kd lt lu lv kg lw lx ly kk lz ma mb ko mc md me ks mf bi translated">检查一切是否正常</h1><p id="ec23" class="pw-post-body-paragraph mg mh iq kw b kx ky mi mj kz la mk ml kh mm mn mo kl mp mq mr kp ms mt mu le ij bi translated">现在一切都设置好了，让我们做一些检查，以确保一切正常工作。我们将从重启托管实例组开始，用新的实例模板加载我们的虚拟机。在命令行中输入我们的<em class="nf"> deploy.sh </em>脚本的第二行:</p><pre class="nb nc nd ne gt nn no np nq aw nr bi"><span id="a557" class="jy jz iq no b gy ns nt l nu nv">gcloud beta compute instance-groups managed rolling-action restart gcloud-docker-node-group --zone us-east1-b --project &lt;project-id&gt;</span></pre><p id="b770" class="pw-post-body-paragraph mg mh iq kw b kx mv mi mj kz mw mk ml kh mx mn mo kl my mq mr kp mz mt mu le ij bi translated">既然我们已经删除了虚拟机的外部IP，如果我们需要诊断任何错误，我们就无法通过SSH连接到虚拟机。为了解决这个问题，我们可以创建一个所谓的堡垒主机，它实际上是一个虚拟虚拟机，我们使用内部连接来连接到其他虚拟机。点击<a class="ae lj" href="https://cloud.google.com/solutions/connecting-securely#bastion" rel="noopener ugc nofollow" target="_blank">了解更多信息。</a></p><p id="10e4" class="pw-post-body-paragraph mg mh iq kw b kx mv mi mj kz mw mk ml kh mx mn mo kl my mq mr kp mz mt mu le ij bi translated">我们所要做的就是创建一个简单的VM，它有一个外部IP，并且与我们的托管实例组在同一个内部网络中。导航到您的<a class="ae lj" href="https://console.cloud.google.com/compute/instances" rel="noopener ugc nofollow" target="_blank">虚拟机实例</a>并点击<em class="nf">创建实例</em>。将其命名为<strong class="kw ir"> bastion </strong>并选择<strong class="kw ir"> micro </strong>作为<em class="nf">机器类型</em>(因为我们不需要强大的机器)。确保该区域设置为与我们的托管实例组相同的区域，然后单击<em class="nf"> Create </em>。</p><p id="bc64" class="pw-post-body-paragraph mg mh iq kw b kx mv mi mj kz mw mk ml kh mx mn mo kl my mq mr kp mz mt mu le ij bi translated">在继续之前，确保您的托管实例组已经完成了重启(还记得在<em class="nf"> Test MongoDB connection </em>小节开头的list-instances命令)。</p><p id="7b51" class="pw-post-body-paragraph mg mh iq kw b kx mv mi mj kz mw mk ml kh mx mn mo kl my mq mr kp mz mt mu le ij bi translated">现在让我们SSH到<em class="nf"> bastion </em>虚拟机，然后从那里SSH到我们的一个托管实例组虚拟机(您的组可能只运行一个虚拟机，因为它没有足够的流量来扩展)。为了访问我们的托管实例组虚拟机，我们需要通过Google Cloud控制台SSH到<em class="nf"> bastion </em>，而不是通过我们自己的命令行。点击<em class="nf">堡垒</em>虚拟机的<em class="nf"> SSH </em>按钮旁边的下拉菜单，并点击<em class="nf">在浏览器窗口</em>中打开。进入后，请输入:</p><pre class="nb nc nd ne gt nn no np nq aw nr bi"><span id="e2ed" class="jy jz iq no b gy ns nt l nu nv">ssh gcloud-docker-node-group-XXXX -A</span></pre><p id="d5e7" class="pw-post-body-paragraph mg mh iq kw b kx mv mi mj kz mw mk ml kh mx mn mo kl my mq mr kp mz mt mu le ij bi translated">确保用虚拟机名称中的随机字符替换XXXX。</p><p id="6431" class="pw-post-body-paragraph mg mh iq kw b kx mv mi mj kz mw mk ml kh mx mn mo kl my mq mr kp mz mt mu le ij bi translated">现在输入<code class="fe nw nx ny no b">docker ps</code>，并使用列出的第一个容器ID的前几个字符，输入<code class="fe nw nx ny no b">docker logs &lt;container-id&gt;</code>。您应该会看到以下输出:</p><pre class="nb nc nd ne gt nn no np nq aw nr bi"><span id="64b2" class="jy jz iq no b gy ns nt l nu nv">server listening on port 3000...<br/>mongodb connected<br/>mongodb connection opened</span></pre><p id="9cda" class="pw-post-body-paragraph mg mh iq kw b kx mv mi mj kz mw mk ml kh mx mn mo kl my mq mr kp mz mt mu le ij bi translated">这告诉我们，我们的虚拟机能够通过我们配置的NAT网关与我们的MongoDB集群通信。作为最后一个测试，让我们尝试之前从我们自己的命令行发出的GET请求。输入:</p><pre class="nb nc nd ne gt nn no np nq aw nr bi"><span id="940f" class="jy jz iq no b gy ns nt l nu nv">curl <a class="ae lj" href="http://localhost:3000/api/examples" rel="noopener ugc nofollow" target="_blank">&lt;ip-address&gt;/api/examples</a>/&lt;_id&gt;</span></pre><p id="11ec" class="pw-post-body-paragraph mg mh iq kw b kx mv mi mj kz mw mk ml kh mx mn mo kl my mq mr kp mz mt mu le ij bi translated">其中<_id>是我们之前创建的用户条目的ID。您应该看到:</_id></p><pre class="nb nc nd ne gt nn no np nq aw nr bi"><span id="0e73" class="jy jz iq no b gy ns nt l nu nv">{"_id":"&lt;_id&gt;","name":"Joe Smith","email":"<a class="ae lj" href="mailto:joe@smth.com" rel="noopener ugc nofollow" target="_blank">joe@smth.com</a>","__v":0}</span></pre><p id="312f" class="pw-post-body-paragraph mg mh iq kw b kx mv mi mj kz mw mk ml kh mx mn mo kl my mq mr kp mz mt mu le ij bi translated">我们完事了。🎉希望你喜欢这个教程，任何反馈都是非常感谢的！如果你在代码上遇到任何问题，不要忘记查看一下GitHub ,或者在下面提问。</p></div></div>    
</body>
</html>