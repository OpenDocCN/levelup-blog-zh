<html>
<head>
<title>Fullstack Go: Adding API Security</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Fullstack Go:添加API安全性</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/fullstack-go-adding-api-security-1b603ac2fa1d?source=collection_archive---------12-----------------------#2020-07-22">https://levelup.gitconnected.com/fullstack-go-adding-api-security-1b603ac2fa1d?source=collection_archive---------12-----------------------#2020-07-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/42b9b04420725c7c47d5a03bffb18e37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2OVPhxJHm1C-8cR6"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">由<a class="ae kc" href="https://unsplash.com/@srhhrbch?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Siarhei Horbach </a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="2eb9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<a class="ae kc" href="https://medium.com/@sean_24982/go-frontend-backend-revisited-leveraging-swagger-on-the-frontend-caa60087d65b" rel="noopener">之前的一篇文章</a>中，我描述了如何将<a class="ae kc" href="https://swagger.io/" rel="noopener ugc nofollow" target="_blank"> Swagger </a>支持添加到我的示例Go fullstack应用程序中。在这里，我描述了如何增强该解决方案以提供API安全性。</p><p id="9466" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">添加API安全性涉及完整的前端重写和对基于<a class="ae kc" href="https://aws.amazon.com/api-gateway/" rel="noopener ugc nofollow" target="_blank"> AWS API Gateway </a>的后端的一些合理且有据可查的更改:<a class="ae kc" href="https://aws.amazon.com/cognito/" rel="noopener ugc nofollow" target="_blank"> AWS Cognito </a>被选为安全解决方案的基础，因为我已经在<a class="ae kc" href="https://aws.amazon.com/" rel="noopener ugc nofollow" target="_blank"> AWS </a>生态系统中工作。</p><p id="d01b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">支持OAuth流时vecty的限制</strong></p><p id="a60e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">之前的前端是用<code class="fe lb lc ld le b"><a class="ae kc" href="https://github.com/gopherjs/vecty" rel="noopener ugc nofollow" target="_blank">vecty</a></code> Go前端框架写的；这当然是一个很好的框架，证明了(对我来说)是一个很好的前端开发的切入点。<code class="fe lb lc ld le b">vecty</code>有许多积极的方面DOM元素的管理是高效的，组件模型是经过深思熟虑的，最终结果肯定是一种反应式的前端体验；然而，由于它的作者仍然认为它是试验性的，因此在某个时候限制必然会出现——我在试图增加安全性时遇到了一个重大的限制。</p><p id="f87c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我想要使用的安全模型是一个标准的<a class="ae kc" href="https://oauth.net/2/" rel="noopener ugc nofollow" target="_blank"> OAuth </a>授权授予模型，利用<a class="ae kc" href="https://oauth.net/2/pkce/" rel="noopener ugc nofollow" target="_blank">代码交换的证明密钥(PKCE) </a>。PKCE是为没有应用程序后端服务构成OAuth流程的情况而设计的；移动和网络应用是主要的用例。PKCE流的基本特征是没有客户端秘密，因为客户端是不受信任的终端设备。PKCE与众所周知的OAuth grant流程并无本质区别；相反，它是一种适应——它仍然需要登录到一个身份验证提供者，使用一个代码重定向到一个已知的回调URI，然后该代码可用于获得一个可用于访问安全资源的访问令牌。</p><p id="903e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如上所述，PKCE要求使用回调；在PKCE的情况下，假设这个回调是在客户端处理的——例如，对于移动应用，可以使用由设备操作系统处理的自定义URI方案(例如<code class="fe lb lc ld le b">myapp://</code>)。对于没有后端支持的web应用程序，这必须由前端路由器来处理。</p><p id="5cff" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">目前，<code class="fe lb lc ld le b">vecty</code>还没有内置对前端路由的支持；<code class="fe lb lc ld le b"><a class="ae kc" href="https://github.com/marwan-at-work/vecty-router" rel="noopener ugc nofollow" target="_blank">vecty-router</a></code>项目部分解决了这个问题，但是我遇到了当回调被触发时如何使用它来导航到另一个URI的问题——以前没有被渲染的组件将不能被正确渲染。为此，我开始寻找替代解决方案。</p><p id="aae3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">输入vugu… </strong></p><p id="3282" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b"><a class="ae kc" href="https://www.vugu.org/" rel="noopener ugc nofollow" target="_blank">vugu</a> </code>是另一个前端Go框架，它受到了<a class="ae kc" href="https://vuejs.org/" rel="noopener ugc nofollow" target="_blank"> Vue.js </a>的强烈启发，但是<a class="ae kc" href="https://blog.gopheracademy.com/advent-2019/writing-go-user-interfaces-with-vugu/" rel="noopener ugc nofollow" target="_blank">主要由于Go </a>的设计而有所不同。不像<code class="fe lb lc ld le b">vecty</code> , <code class="fe lb lc ld le b">vugu</code>文件包含HTML、CSS和Go的混合——这可能会让你的编辑器更加混乱，但确实会使应用程序逻辑的表示更加简洁。<code class="fe lb lc ld le b">vugu</code>获取应用程序的描述，并将其解析成一组本地Go文件，然后这些文件可以被编译成<a class="ae kc" href="https://webassembly.org/" rel="noopener ugc nofollow" target="_blank"> WebAssembly </a>并在浏览器中运行。</p><p id="229d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">vugu</code>确实对路由提供了一些支持，尽管它还是相当新的:它包括一个层次模型，其中嵌套的组件可以根据浏览器中URI的变化进行更新:路由器还使浏览器URI能够被应用程序更新，这可以导致页面内容的重新呈现。</p><p id="e2d8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于<code class="fe lb lc ld le b">vugu</code>具有很强的前端偏向性，它带有一个开发服务器，该服务器不执行任何显式的路由处理，而只是简单地提供相同的内容，而不管哪个端点被调用:因此开发服务器的所有路由处理都在前端执行。</p><p id="f1c3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">在vugu中实现Todo应用程序</strong></p><p id="9bc9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第一步是使用<code class="fe lb lc ld le b">vugu</code>重新实现基于 <code class="fe lb lc ld le b"><a class="ae kc" href="https://github.com/seanrmurphy/go-vecty-swagger" rel="noopener ugc nofollow" target="_blank">vecty</a></code> <a class="ae kc" href="https://github.com/seanrmurphy/go-vecty-swagger" rel="noopener ugc nofollow" target="_blank">的</a><a class="ae kc" href="https://github.com/seanrmurphy/go-vecty-swagger" rel="noopener ugc nofollow" target="_blank">待办事项应用</a>。总的来说，这非常简单；在<code class="fe lb lc ld le b">vugu</code>模型中，页面元素上的<a class="ae kc" href="https://www.vugu.org/doc/dom-events" rel="noopener ugc nofollow" target="_blank">动作可以直接链接到Go函数</a>，这使得实现比<code class="fe lb lc ld le b">vecty</code>中使用的方法更简单，后者使用动作、监听器和调度程序。</p><p id="175d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">vugu</code>有一些<a class="ae kc" href="https://www.vugu.org/doc/files/markup" rel="noopener ugc nofollow" target="_blank">好的原语</a>，使得有条件地显示一些HTML内容变得容易；还有一些很好的循环结构，可以很容易地显示项目列表——在这种情况下，这对于显示待办事项很有用。<code class="fe lb lc ld le b">vugu</code>的一个很好的设计特性是支持在渲染之前调用一个特定的函数(用<code class="fe lb lc ld le b">BeforeBuild()</code>)，这样在进入时间关键的渲染循环之前，数据可以被处理或者从服务器中检索。</p><p id="e531" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用<code class="fe lb lc ld le b">vugu</code> devserver也是一种很好的体验，它增加了工作流的节奏——与其他前端框架一样，应用程序的更改会被devserver自动拾取，并在浏览器中重新加载以进行测试和验证。</p><p id="b546" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">增加安全性—集成OAuth流程</strong></p><p id="d564" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要使用OAuth PKCE流，必须向前端添加逻辑，以使用适当的查询参数导航到身份验证服务，并处理回调URI。</p><p id="fd58" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">PKCE的工作原理是在前端创建一个所谓的<em class="lf">代码验证器</em>和相关的挑战，并将后者传递给认证服务器。认证后，认证服务器用一个代码重定向到回调。在我最初的尝试中，我试图使用<code class="fe lb lc ld le b">http://localhost:8844/callback</code>作为回调URI，并将其重定向回主登录页面——然而<code class="fe lb lc ld le b">vugu</code>路由器仍在发展中，当呈现不同URI的内容时，我遇到了更改为新URI的问题。出于这个原因，我只是使用主登录页面作为回调URI，并添加逻辑来解析返回的<code class="fe lb lc ld le b">code </code>。然后，前端使用代码和代码验证器从认证服务获得访问令牌；然后在调用API时可以使用这个访问令牌。</p><pre class="lg lh li lj gt lk le ll lm aw ln bi"><span id="1f6f" class="lo lp iq le b gy lq lr l ls lt">func (c *Root) createCognitoURI(clientName string, p CognitoParameters) (u url.URL) {<br/>  u = url.URL{<br/>    Scheme: "https",<br/>    Host:   clientName + ".auth.&lt;AWS-REGION&gt;.amazoncognito.com",<br/>    Path:   "oauth2/authorize",<br/>    Opaque: "//" + clientName + ".auth.&lt;AWS-REGION&gt;.amazoncognito.com/oauth2/authorize",<br/>  }<br/>  v, _ := query.Values(p)<br/>  u.RawQuery = v.Encode()<br/>  return<br/>}</span><span id="146d" class="lo lp iq le b gy lu lr l ls lt">func (c *Root) Login() {<br/>  challenge := LoginData.CodeVerifier.CodeChallengeS256()<br/>  challengeMethod := "S256"</span><span id="c989" class="lo lp iq le b gy lu lr l ls lt">  clientName := "&lt;CLIENT-NAME&gt;"<br/>  clientID := "&lt;CLIENT-ID&gt;"</span><span id="13dd" class="lo lp iq le b gy lu lr l ls lt">  p := CognitoParameters{<br/>    ResponseType:        "code",<br/>    ClientID:            clientID,<br/>    RedirectURI:         "<a class="ae kc" href="http://localhost:8844/callback" rel="noopener ugc nofollow" target="_blank">http://localhost:8844</a>",<br/>    State:               "initial-state",<br/>    IdentityProvider:    "COGNITO",<br/>    IDPProvider:         "",<br/>    Scope:               "profile",<br/>    CodeChallengeMethod: challengeMethod,<br/>    CodeChallenge:       challenge,<br/>  }</span><span id="c278" class="lo lp iq le b gy lu lr l ls lt">  q := c.createCognitoURI(clientName, p)</span><span id="2fbc" class="lo lp iq le b gy lu lr l ls lt">  window := js.Global().Get("window")<br/>  window.Call("open", q.String(), "_self")<br/>}</span></pre><p id="a818" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当前的解决方案是在登录页面上呈现一个登录按钮——单击该按钮会导致为认证服务器创建一个适当的URI，其中包括查询参数，包括上面提到的质询、客户端ID、回调URI和状态参数(参见代码片段)。登录后，浏览器以<code class="fe lb lc ld le b">code</code>为查询参数重定向回登陆页面；然后使用存储在前端应用程序中的代码获得访问令牌，并用于从安全REST API获得待办事项列表。</p><p id="e9db" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一个不明显的地方是，代码验证器必须在OAuth流中保持不变——它不能简单地存储在前端应用程序中，因为当控制权传递给身份验证服务器时，它会丢失。在这个实现中，这一点通过在导航到身份验证服务之前使用LocalStorage来存储代码验证器，然后在返回时再次访问它来解决。</p><p id="83a7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">保护后端</strong></p><p id="daa5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">之前的不安全后端是使用触发Lambda函数的<a class="ae kc" href="https://aws.amazon.com/api-gateway/" rel="noopener ugc nofollow" target="_blank"> AWS API网关</a>实现的——API是在一个Swagger文件中定义的。AWS提供了关于如何使用不同方法保护Swagger定义的API的<a class="ae kc" href="https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-integrate-with-cognito.html" rel="noopener ugc nofollow" target="_blank">文档，其中一种方法是使用他们的Cognito服务。</a></p><p id="2d71" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该方法包括以下基本步骤:</p><ul class=""><li id="9008" class="lv lw iq kf b kg kh kk kl ko lx ks ly kw lz la ma mb mc md bi translated">在Cognito中创建新的<a class="ae kc" href="https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-identity-pools.html" rel="noopener ugc nofollow" target="_blank">用户池</a></li><li id="b1cf" class="lv lw iq kf b kg me kk mf ko mg ks mh kw mi la ma mb mc md bi translated">添加一个特定于此前端的新客户端—请注意，客户端不能有密码，否则此客户端不支持PKCE。</li><li id="b86f" class="lv lw iq kf b kg me kk mf ko mg ks mh kw mi la ma mb mc md bi translated">为此用户池添加执行身份验证所需的域。(显然，为此提供您自己的域名是可能的，但是这里我们假设使用一个带有URI的域名就足够了)。</li><li id="f9a3" class="lv lw iq kf b kg me kk mf ko mg ks mh kw mi la ma mb mc md bi translated">将用户添加到用户池—这可以通过命令行或web界面来完成；请注意，可以在创建时配置用户，以便用户已经过验证</li><li id="30e5" class="lv lw iq kf b kg me kk mf ko mg ks mh kw mi la ma mb mc md bi translated">修改Swagger文件以包含安全定义，并将其应用于不同的端点，如这里的<a class="ae kc" href="https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-enable-cognito-user-pool.html" rel="noopener ugc nofollow" target="_blank">所述</a>。(注意，我使用了OpenAPI 2.0的变化，因为go-swagger工具链关注于此)。</li><li id="64cc" class="lv lw iq kf b kg me kk mf ko mg ks mh kw mi la ma mb mc md bi translated">基于这个Swagger文件创建一个新的REST API它使用与不安全API定义相同的AWS命令，但是Swagger文件的内容指示API网关在创建API时添加授权码。</li></ul><p id="2202" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面链接的repo中为此提供了一组shell脚本和一个Swagger文件模板。</p><p id="1a6d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后可以很容易地测试API:在没有访问令牌的情况下在API上使用<code class="fe lb lc ld le b">curl</code>会导致带有未授权响应的HTTP 403。在形式为<code class="fe lb lc ld le b">"Authorization: $ACCESSTOKEN"</code>的头中添加一个由前端生成的访问令牌应该会导致对API的成功调用。</p><p id="b4d4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">从前端安全调用API</strong></p><p id="2f72" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从前端调用安全API非常简单。如前一篇文章所述，从Swagger定义中生成客户端库并在前端使用它们没有出现任何问题。在这种情况下，客户端库与以前略有不同，唯一的区别是包含身份验证令牌的方式。使用客户端库只需要在调用后端时添加访问令牌——下面的代码展示了这是如何完成的。</p><pre class="lg lh li lj gt lk le ll lm aw ln bi"><span id="5c54" class="lo lp iq le b gy lq lr l ls lt">// BearerToken creates the authentication header using a given<br/>// token<br/>func BearerToken(token string) runtime.ClientAuthInfoWriter {<br/> return runtime.ClientAuthInfoWriterFunc(func(r   runtime.ClientRequest, _ strfmt.Registry) error {<br/>  return r.SetHeaderParam("Authorization", token)<br/> })<br/>}</span><span id="11f3" class="lo lp iq le b gy lu lr l ls lt">// createClient creates a client to commmunicate with the REST<br/>// API as necessary<br/>func createClient() *client.SimpleTodoAPISecure {<br/>  url, _ := url.Parse(AuthenticationData.RestEndpoint)<br/>  authenticator := BearerToken(AuthenticationData.LoginData.ResponseParams.AccessToken)</span><span id="fcd4" class="lo lp iq le b gy lu lr l ls lt">  conf := client.Config{<br/>    URL:      url,<br/>    AuthInfo: authenticator,<br/>  }<br/>  return client.New(conf)<br/>}</span><span id="7a60" class="lo lp iq le b gy lu lr l ls lt">// postItemToBackend posts a new Todo to the backend - note<br/>// that the token is only used when creating the client above<br/>func (c *ToDoList) postItemToBackend(t models.Todo) {<br/>  backend := createClient()</span><span id="7da5" class="lo lp iq le b gy lu lr l ls lt">  params := developers.NewAddTodoParams()<br/>    params.Todo = &amp;t<br/>    ctx := context.TODO()</span><span id="0fab" class="lo lp iq le b gy lu lr l ls lt">  if _, err := backend.Developers.AddTodo(ctx, params); err != nil {<br/>    log.Printf("Error pusting new item on backend - error %v\n", err)<br/>    return<br/>  }<br/>}</span></pre><p id="6483" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">结束语</strong></p><p id="e2da" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这项工作涉及到相当多的移动部件和从一个Go前端技术到另一个的移动；因此，我似乎遇到了现有前端Go框架的一些限制。也就是说，迁移到<code class="fe lb lc ld le b">vugu</code>极大地简化了前端实现。一般来说，PKCE流的设置有点棘手，如果Cognito客户端包含客户端机密(这是默认设置),它就不能与PKCE一起使用，这一点并不明显，需要一些时间来解决。保护后端是有据可查的，而且相当简单，因为利用自动生成的Swagger代码来触发对后端的安全调用。</p><p id="46a3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">结果是一个用Go编写的简单应用程序，前端和后端都有身份验证和安全API。当然，这只是一个玩具应用程序，但它确实展示了使某些东西更具实质性所必需的基本构件。</p><p id="0d4a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Github repo包含的内容:</p><ul class=""><li id="a919" class="lv lw iq kf b kg kh kk kl ko lx ks ly kw lz la ma mb mc md bi translated"><a class="ae kc" href="https://github.com/seanrmurphy/vugu-tdl-swagger" rel="noopener ugc nofollow" target="_blank">https://github.com/seanrmurphy/vugu-tdl-swagger</a></li></ul></div></div>    
</body>
</html>