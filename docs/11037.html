<html>
<head>
<title>Rewriting nested callbacks with Promises and async/await syntax</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用承诺和异步/等待语法重写嵌套回调</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/rewriting-nested-callbacks-with-promises-and-async-await-syntax-ade1a0fe2d3d?source=collection_archive---------3-----------------------#2022-02-09">https://levelup.gitconnected.com/rewriting-nested-callbacks-with-promises-and-async-await-syntax-ade1a0fe2d3d?source=collection_archive---------3-----------------------#2022-02-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/337bbcf203472964b9987f7c85cfd8dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ous_u1STyar1WAFt3Zk6Pw.png"/></div></div></figure><p id="bd9f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们考虑下面一个简单的NodeJS脚本，它从命令行运行一个调查问卷:</p><figure class="kw kx ky kz gt jr"><div class="bz fp l di"><div class="la lb l"/></div></figure><p id="b571" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是一段老式的JS代码，说明了在<em class="lc"> rl.question </em>方法调用中嵌套回调的常见问题。</p><p id="617d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了用现代语法重写它，首先应该定义承诺。</p><figure class="kw kx ky kz gt jr"><div class="bz fp l di"><div class="la lb l"/></div></figure><p id="c462" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里使用了<a class="ae ld" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions" rel="noopener ugc nofollow" target="_blank">箭头</a>函数来创建一个新的承诺，该承诺接受两个特定的回调函数<em class="lc"> resolve </em>和<em class="lc"> reject </em>。在promise主体中调用这些函数，以便在成功和失败的情况下返回值。成功时叫做决心，失败时叫做拒绝，而成功时叫做决心。</p><p id="941e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">承诺是异步执行的。这意味着执行流程在下一条语句之后继续，而不等待promise表达式返回值。</p><p id="872f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，操作符<em class="lc"> await </em>允许暂停一个执行流，以便等待承诺解析(或拒绝)并返回一个值。Await只能在用<em class="lc"> async </em>关键字注释的函数中调用。</p><p id="6b9d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">应用了<em class="lc">异步</em>和<em class="lc">等待</em>的结果脚本如下:</p><figure class="kw kx ky kz gt jr"><div class="bz fp l di"><div class="la lb l"/></div></figure><p id="a652" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这种方法允许以更可读的方式重写嵌套的回调。</p><p id="b63a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="lc">参考文献</em>:</p><ol class=""><li id="34d6" class="le lf iq ka b kb kc kf kg kj lg kn lh kr li kv lj lk ll lm bi translated"><a class="ae ld" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions" rel="noopener ugc nofollow" target="_blank">箭头功能。MDN </a></li><li id="8590" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated">等待。MDN </li><li id="fe62" class="le lf iq ka b kb ln kf lo kj lp kn lq kr lr kv lj lk ll lm bi translated"><a class="ae ld" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="noopener ugc nofollow" target="_blank">答应。MDN </a></li></ol></div></div>    
</body>
</html>