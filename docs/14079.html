<html>
<head>
<title>How to Fix Your React App after Upgrading to Version 18</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在升级到18版后修复React应用</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-fix-your-react-app-after-upgrading-to-version-18-a309d9db5707?source=collection_archive---------2-----------------------#2022-10-31">https://levelup.gitconnected.com/how-to-fix-your-react-app-after-upgrading-to-version-18-a309d9db5707?source=collection_archive---------2-----------------------#2022-10-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9e1a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">为什么React团队决定改变输入方式，在这个过程中破坏了数千个应用程序？</h2></div><p id="17f0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">React v18版本包含许多重大变化(如<a class="ae lb" href="https://reactjs.org/blog/2022/03/29/react-v18.html#what-is-concurrent-react" rel="noopener ugc nofollow" target="_blank">并发</a>)，但有时正是这些小变化困扰着我们。说到<a class="ae lb" href="https://www.typescriptlang.org/docs/handbook/react.html" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir"> typescript </strong> </a>，React为我们提供了<code class="fe lc ld le lf b">FC</code>接口，用于创建一个功能组件。在版本18之前，我们不必定义在功能组件上使用的<code class="fe lc ld le lf b">children</code>属性:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ll lm l"/></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk translated">FC接口隐式定义的子属性</figcaption></figure><p id="ab14" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是从v18开始，上面的代码会导致下面的错误:</p><pre class="lg lh li lj gt lr lf ls lt aw lu bi"><span id="0746" class="lv lw iq lf b gy lx ly l lz ma">Property 'children' does not exist on type 'Props'</span></pre><p id="c0a9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于这个接口是常用的，升级到v18很可能会坏了你的app，的确<a class="ae lb" href="https://stackoverflow.com/questions/71788254/react-18-typescript-children-fc/" rel="noopener ugc nofollow" target="_blank">很多app升级</a>后就坏了。</p><h1 id="4027" class="mb lw iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">反应和失踪的孩子</h1><p id="4ba5" class="pw-post-body-paragraph kf kg iq kh b ki ms jr kk kl mt ju kn ko mu kq kr ks mv ku kv kw mw ky kz la ij bi translated">突破性的变化是在<code class="fe lc ld le lf b">FC</code>界面中删除了<code class="fe lc ld le lf b">children</code>道具的默认定义。</p><h2 id="b803" class="lv lw iq bd mc mx my dn mg mz na dp mk ko nb nc mm ks nd ne mo kw nf ng mq nh bi translated">怎么修</h2><p id="2416" class="pw-post-body-paragraph kf kg iq kh b ki ms jr kk kl mt ju kn ko mu kq kr ks mv ku kv kw mw ky kz la ij bi translated">有很多<a class="ae lb" href="https://bobbyhadz.com/blog/react-property-children-does-not-exist-on-type" rel="noopener ugc nofollow" target="_blank">帖子</a>是关于如何解决这个typescript错误的，所有的解决方案都是<a class="ae lb" href="https://stackoverflow.com/questions/71788254/react-18-typescript-children-fc/71800185#71800185" rel="noopener ugc nofollow" target="_blank">不同的方式显式添加“children”道具</a>。最常见的一种方法是将其添加到您的props界面中:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ll lm l"/></div></figure><p id="54da" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而大多数关于解决这个问题的文章都忽略了一个重要的问题——为什么React一开始就从<code class="fe lc ld le lf b">FC</code>界面中移除了隐式的“孩子”?</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="nj nk di nl bf nm"><div class="gh gi ni"><img src="../Images/22c8af83bbb49083f27cad13b3547845.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*onW5if-DCXCXtCjd"/></div></div></figure></div><div class="ab cl np nq hu nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="ij ik il im in"><h1 id="967a" class="mb lw iq bd mc md nw mf mg mh nx mj mk jw ny jx mm jz nz ka mo kc oa kd mq mr bi translated">生孩子应该是一个有意识的决定</h1><p id="fdee" class="pw-post-body-paragraph kf kg iq kh b ki ms jr kk kl mt ju kn ko mu kq kr ks mv ku kv kw mw ky kz la ij bi translated">做出此类<a class="ae lb" href="https://en.wiktionary.org/wiki/breaking_change#:~:text=breaking%20change%20(plural%20breaking%20changes,to%20new%20in%20import%20lib." rel="noopener ugc nofollow" target="_blank">重大变更</a>的原因是，之前的假设——所有组件都可能有<code class="fe lc ld le lf b">ReactNode</code>类型的“子”道具——并不成立，因为:</p><ul class=""><li id="d3cf" class="ob oc iq kh b ki kj kl km ko od ks oe kw of la og oh oi oj bi translated">有些孩子应该有不同于<code class="fe lc ld le lf b">ReactNode</code>的类型</li><li id="f51d" class="ob oc iq kh b ki ok kl ol ko om ks on kw oo la og oh oi oj bi translated">有些组件根本不需要子组件</li></ul><h2 id="6325" class="lv lw iq bd mc mx my dn mg mz na dp mk ko nb nc mm ks nd ne mo kw nf ng mq nh bi translated">其他类型的孩子</h2><p id="e86e" class="pw-post-body-paragraph kf kg iq kh b ki ms jr kk kl mt ju kn ko mu kq kr ks mv ku kv kw mw ky kz la ij bi translated">考虑以下(简化的)按钮组件。</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ll lm l"/></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk translated">对于某些组件，我们可能更喜欢带有字符串类型的子组件</figcaption></figure><p id="c19d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意<strong class="kh ir">子</strong>的类型是<code class="fe lc ld le lf b">string</code>。当我们希望对组件的内容有更多的控制时，这是很有用的。我以前写过<a class="ae lb" href="https://medium.com/@yuval.bar.levi/react-spread-attributes-dont-overuse-them-3f322a0ace22" rel="noopener">降低组件灵活性如何帮助保持应用程序的一致性</a>，这里也是一样:当我们为<code class="fe lc ld le lf b">children</code>设置字符串类型时，我们可以防止滥用它的<code class="fe lc ld le lf b">children</code>属性。</p><p id="00e4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">怎么虐？像这样:</p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ll lm l"/></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk translated">当使用ReactNode类型的子节点时，它允许向内容中注入样式</figcaption></figure><p id="e159" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的代码是一个常见的场景，错误的样式可以被注入到按钮的内容中，并在无意中修改它。在React v17中，我们不必定义<strong class="kh ir">子</strong>的类型——默认情况下，它曾经是<code class="fe lc ld le lf b">ReactNode</code>类型。因此，除非我们定义不同的子类型，否则这段代码不会触发任何错误。这让我们的组件有太多的开箱即用的灵活性。在v18中，我们必须有意识地决定孩子的类型。</p><h2 id="6376" class="lv lw iq bd mc mx my dn mg mz na dp mk ko nb nc mm ks nd ne mo kw nf ng mq nh bi translated">没有子组件的组件</h2><p id="2ab0" class="pw-post-body-paragraph kf kg iq kh b ki ms jr kk kl mt ju kn ko mu kq kr ks mv ku kv kw mw ky kz la ij bi translated">在很多情况下，一个组件从一个源而不是一个道具获得它的内容，例如，一个连接到一个存储库的<a class="ae lb" href="https://medium.com/@suraj.kc/mobx-strategies-with-react-hooks-3de23932cb8c" rel="noopener">内部钩子。</a></p><figure class="lg lh li lj gt lk"><div class="bz fp l di"><div class="ll lm l"/></div></figure><p id="33f2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为我们的<code class="fe lc ld le lf b">ErrorMessage</code>组件从商店而不是道具中获取内容——它对<strong class="kh ir">子</strong>道具没有用处。在这种情况下，我们希望typescript编译器阻止向<code class="fe lc ld le lf b">ErrorMessage</code>添加子元素。这是v18的默认行为——当我们使用<code class="fe lc ld le lf b">FC</code>接口时，除非我们明确设置<strong class="kh ir">孩子</strong>的道具类型。</p><h2 id="fa72" class="lv lw iq bd mc mx my dn mg mz na dp mk ko nb nc mm ks nd ne mo kw nf ng mq nh bi translated">摘要</h2><p id="964e" class="pw-post-body-paragraph kf kg iq kh b ki ms jr kk kl mt ju kn ko mu kq kr ks mv ku kv kw mw ky kz la ij bi translated">有些事情不应该被隐含地定义，因为它可能会鼓励错误的假设，从而导致错误。React的隐式<strong class="kh ir"> children </strong>的定义就是这样一个例子。正如React团队所说:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi op"><img src="../Images/3eff717842e9c4009fd21cec286a5ff3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/1*ayKuSG8zZJvcAYhVG2zlTA.png"/></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk translated"><a class="ae lb" href="https://twitter.com/reactjs/status/1512453969490108418" rel="noopener ugc nofollow" target="_blank">见推特上的帖子</a></figcaption></figure><p id="0ef5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">关于确定类型回购的相关<a class="ae lb" href="https://github.com/DefinitelyTyped/DefinitelyTyped/issues/46691" rel="noopener ugc nofollow" target="_blank">问题对此做了进一步解释:</a></p><blockquote class="oq or os"><p id="6df9" class="kf kg ot kh b ki kj jr kk kl km ju kn ou kp kq kr ov kt ku kv ow kx ky kz la ij bi translated">从<code class="fe lc ld le lf b">React.FC</code>(以及<code class="fe lc ld le lf b">React.memo</code> ) <br/> <strong class="kh ir">中移除隐式类型<code class="fe lc ld le lf b">children</code>在TypeScript中，添加类型通常比移除类型更容易。</strong></p></blockquote><p id="41a4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，正如我们在上面的第一个例子中看到的，太多的灵活性并不总是一件好事。你可以在这里观看我关于过度弹性的演讲<a class="ae lb" href="https://www.youtube.com/watch?v=gvneSW-ICqc&amp;t=670s" rel="noopener ugc nofollow" target="_blank">。</a></p><h2 id="4f29" class="lv lw iq bd mc mx my dn mg mz na dp mk ko nb nc mm ks nd ne mo kw nf ng mq nh bi translated">资源</h2><ul class=""><li id="3bd1" class="ob oc iq kh b ki ms kl mt ko ox ks oy kw oz la og oh oi oj bi translated"><a class="ae lb" href="https://solverfox.dev/writing/no-implicit-children/" rel="noopener ugc nofollow" target="_blank">去除隐性子女</a></li><li id="e601" class="ob oc iq kh b ki ok kl ol ko om ks on kw oo la og oh oi oj bi translated"><a class="ae lb" href="https://github.com/DefinitelyTyped/DefinitelyTyped/pull/56210" rel="noopener ugc nofollow" target="_blank">反应18种类型(拉式请求)</a></li><li id="2489" class="ob oc iq kh b ki ok kl ol ko om ks on kw oo la og oh oi oj bi translated"><a class="ae lb" href="https://github.com/DefinitelyTyped/DefinitelyTyped/issues/46691" rel="noopener ugc nofollow" target="_blank">反应18和仅类型的突变</a></li><li id="c6a3" class="ob oc iq kh b ki ok kl ol ko om ks on kw oo la og oh oi oj bi translated"><a class="ae lb" href="https://twitter.com/reactjs/status/1512453230504124420" rel="noopener ugc nofollow" target="_blank">React 18打字稿打字出来了！(推特)</a></li></ul></div></div>    
</body>
</html>