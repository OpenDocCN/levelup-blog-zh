<html>
<head>
<title>Solving multiple executions of @Scheduled tasks across multiple nodes even with ShedLock — Spring Boot</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">即使使用谢德洛克-Spring Boot，也能在多个节点上解决@Scheduled任务的多次执行</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/solving-multiple-executions-of-scheduled-tasks-across-multiple-nodes-even-with-shedlock-spring-2b1d26db9356?source=collection_archive---------0-----------------------#2022-09-12">https://levelup.gitconnected.com/solving-multiple-executions-of-scheduled-tasks-across-multiple-nodes-even-with-shedlock-spring-2b1d26db9356?source=collection_archive---------0-----------------------#2022-09-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="343e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设您在运行于多个节点上的spring boot应用程序中配置了许多@Scheduled任务，并且您添加了<a class="ae kl" href="https://github.com/lukas-krecan/ShedLock" rel="noopener ugc nofollow" target="_blank"> ShedLock </a>来确保一个任务在多个节点上一次只执行一次。</p><p id="4f6f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是令人惊讶的是，您注意到任务仍然在多个pod上运行，不是在预定的时间，而是有随机延迟。同样在几天后，您注意到大多数计划的任务突然停止运行，并且这种情况持续到您重新部署pod。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/112cc48819808902e2901e6419e562d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2yMBDK5zdyIQrswybLvYiA.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">计划任务停止运行，直到重新部署</figcaption></figure></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><p id="7a90" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了理解发生了什么，我们需要理解spring调度和ShedLock是如何工作的。</p><p id="570c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">spring boot中的日程安排是如何工作的？</strong></p><p id="e1c0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过使用@Scheduled注释，我们可以很容易地在spring boot中调度任务。然后我们需要通过向spring配置类添加@EnableScheduling注释来启用调度。Spring使用<a class="ae kl" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/scheduling/concurrent/ThreadPoolTaskScheduler.html" rel="noopener ugc nofollow" target="_blank"> ThreadPoolTaskScheduler </a>来调度任务，它在内部委托给一个ScheduledExecutorService。默认情况下，ThreadPoolTaskScheduler的线程池大小为1，这意味着应用程序的所有调度任务都由一个线程执行(线程名— scheduling-1)。</p><p id="f33c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">shed lock是如何工作的？</strong></p><p id="7040" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">ShedLock使用连接到所有实例的持久存储来存储关于计划任务的信息。实现这个<strong class="jp ir"> <em class="lj"> LockProvider </em> </strong>有多种方式，因为ShedLock支持众多数据库，如<em class="lj"> MongoDB </em>、<em class="lj"> PostgreSQL </em>、<em class="lj"> MySQL </em>等。我们对LockProvider使用PostgreSQL数据库。ShedLock在数据库中用来管理锁的表非常简单。它只有四列:</p><ul class=""><li id="c344" class="lk ll iq jp b jq jr ju jv jy lm kc ln kg lo kk lp lq lr ls bi translated"><strong class="jp ir"> <em class="lj">名称</em> </strong>:用户为计划作业提供的唯一名称</li><li id="de5c" class="lk ll iq jp b jq lt ju lu jy lv kc lw kg lx kk lp lq lr ls bi translated"><strong class="jp ir"><em class="lj">lock _ until</em></strong><em class="lj"/>:锁定当前正在执行的作业的时间</li><li id="1c04" class="lk ll iq jp b jq lt ju lu jy lv kc lw kg lx kk lp lq lr ls bi translated"><strong class="jp ir"><em class="lj">locked _ at</em></strong><em class="lj"/>:实例获得锁时的时间戳</li><li id="d543" class="lk ll iq jp b jq lt ju lu jy lv kc lw kg lx kk lp lq lr ls bi translated"><strong class="jp ir"><em class="lj">locked _ by</em></strong><em class="lj"/>:获取锁的标识符(pod名称)</li></ul><p id="d155" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这样，ShedLock仅在作业第一次运行时为每个计划任务创建一个条目。之后，当任务再次执行时，相同的数据库行被更新，而不删除或重新创建条目。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi ly"><img src="../Images/4a364c1d9be302a3ac5a7bf68bc6cd2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RTHBYZtjYwSXyKuVRsUAPQ.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">用于计划任务的@SchedulerLock批注</figcaption></figure><p id="c6ca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我们将<strong class="jp ir"><em class="lj">【lock _ until】</em></strong>列设置为未来日期时，锁定一个预定任务就会发生。当我们的调度任务执行时，所有正在运行的节点都尝试更新该任务的数据库行。但是只有一个人成功做到了，当<strong class="jp ir">(<em class="lj">lock _ until&lt;= now()</em>)</strong>。更新<strong class="jp ir"> <em class="lj"> lock_until、</em> <em class="lj"> locked_at、locked_by </em> </strong>的列的实例拥有该执行周期的锁，并将<em class="lj"> lock_until </em>设置为<strong class="jp ir"><em class="lj">now()+lock atmostf for</em></strong><em class="lj">。</em>任务执行后ShedLock更新<em class="lj"> lock_until </em>列与<strong class="jp ir"><em class="lj">now()</em></strong><em class="lj"/>仅当任务完成时间为&gt;<strong class="jp ir"><em class="lj">lockAtLeastFor</em></strong>时。如果是一个短时间运行的任务，任务完成时间为&lt;<strong class="jp ir"><em class="lj">lockatleast for</em></strong><em class="lj"/>那么ShedLock设置<em class="lj"/><strong class="jp ir"><em class="lj">lock _ until</em></strong><em class="lj"/>to<em class="lj"/><strong class="jp ir"><em class="lj">locked _ at+lockatleast for</em></strong><em class="lj">。</em>默认情况下，我们使用的ShedLock工作在AOP代理集成模式，它试图在TaskScheduler即将执行任务之前获取任务的锁。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi lz"><img src="../Images/8c7092f1b4c5b9a5f95e78ff75903c40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Eq746kDfdas9bmeK"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">ShedLock AOP PROXY_METHOD模式集成</figcaption></figure><p id="81ac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">发生了什么事？</p><p id="73e6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以每个节点中只有一个调度器线程在工作。我们的应用程序中有80多个计划任务，其中一些是长期运行的(运行2-4小时),每隔2-4小时运行一次。因此，当一个长时间运行的任务正在执行时，在此期间调度的所有其他任务都会排队，最终被延迟执行。</p><p id="c372" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设我们有2个节点(A &amp; B)正在运行，我们有一个包含以下配置的计划任务，需要大约6–7分钟:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi ma"><img src="../Images/df39ae8c2e363187bc21404f64a7ca81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6UvlWLw7Xy0i_q2wzXQXSg.png"/></div></div></figure><p id="5fc2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，这个<em class="lj">测试作业</em>将被安排在上午10点在两个节点上执行，但是假设节点A的scheduling-1线程已经在执行另一个长时间运行的任务，该任务在上午8点开始，需要3个小时才能完成，并且节点B的<em class="lj"> scheduling-1 </em>线程空闲。</p><p id="d59d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个场景中，节点B将能够在上午10点获取testJob的锁，并更新db中的行，如下所示。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mb"><img src="../Images/2a8378bfb398ac061e084be63b373667.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bunPPz8wBjCri0SJlOVNFw.png"/></div></div></figure><p id="e2ac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是节点A中的<em class="lj"> testJob </em>任务将等待上午11点完成的前一个任务。因此在上午11点<em class="lj">节点A的调度-1 </em>线程将尝试获取锁，并将成功地将锁作为<em class="lj"> lock_until &lt; now() </em>，并将再次执行任务<em class="lj">。</em></p><p id="19dd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">同样的事情也发生在我们的多节点系统中，任务在多个节点中的执行频率超过了配置的频率。由于我们有许多长时间运行的任务，而且这些任务的执行频率也超过了要求，这最终会导致任务在队列中堆积。因此，大多数计划任务似乎在几天后停止运行。</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h2 id="6f6b" class="mc md iq bd me mf mg dn mh mi mj dp mk jy ml mm mn kc mo mp mq kg mr ms mt mu bi translated"><strong class="ak">解！</strong></h2><p id="631d" class="pw-post-body-paragraph jn jo iq jp b jq mv js jt ju mw jw jx jy mx ka kb kc my ke kf kg mz ki kj kk ij bi translated">现在是时候增加调度程序线程的数量了。因为单个线程不足以处理我们在应用程序中配置的大量调度任务。为此，我们将调度器配置为并行运行任务，这样任务在队列中的等待时间将会最短。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi na"><img src="../Images/8ffd79c98b27f36803653b2f2ca6ab4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*96tEiaPwzAz9OZz1swmQvw.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">调度程序配置</figcaption></figure><p id="ef99" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">我们学到了什么？</strong></p><p id="6288" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们应该始终根据需求配置/调整调度程序的线程池大小，否则我们会注意到意外的行为。分析线程转储有助于调整线程池的大小。</p><p id="91b1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另一个导致我们问题的因素是<em class="lj"> @SchedulerLock </em>的<em class="lj"> lockAtLeastFor </em>和<em class="lj">lock Atmos for</em>配置不当。所以我们应该始终考虑以下几点:</p><ul class=""><li id="e815" class="lk ll iq jp b jq jr ju jv jy lm kc ln kg lo kk lp lq lr ls bi translated"><em class="lj">lock Atmos for</em>应始终大于任务的执行时间，否则任务可能会执行多次。</li><li id="fc68" class="lk ll iq jp b jq lt ju lu jy lv kc lw kg lx kk lp lq lr ls bi translated"><em class="lj">对于短期运行的作业，应始终添加</em>的锁定。如果节点之间的时钟差大于<em class="lj"> lockAtLeastFor </em>，则任务可以以高于配置的频率执行。</li></ul><p id="8fa4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">有益文章</strong></p><ul class=""><li id="1a0d" class="lk ll iq jp b jq jr ju jv jy lm kc ln kg lo kk lp lq lr ls bi translated"><a class="ae kl" href="https://docs.spring.io/spring-framework/docs/current/reference/html/integration.html#scheduling-task-namespace-scheduler" rel="noopener ugc nofollow" target="_blank">https://docs . spring . io/spring-framework/docs/current/reference/html/integration . html # scheduling-task-namespace-scheduler</a></li><li id="6553" class="lk ll iq jp b jq lt ju lu jy lv kc lw kg lx kk lp lq lr ls bi translated"><a class="ae kl" href="https://javarepos.com/lib/lukas-krecan-ShedLock-java-job-scheduling" rel="noopener ugc nofollow" target="_blank">https://Java repos . com/lib/lukas-kre can-shed lock-Java-job-scheduling</a></li><li id="1f88" class="lk ll iq jp b jq lt ju lu jy lv kc lw kg lx kk lp lq lr ls bi translated"><a class="ae kl" href="https://crmepham.github.io/spring-boot-multi-thread-scheduling/" rel="noopener ugc nofollow" target="_blank">https://crmepham . github . io/spring-boot-multi-thread-scheduling/</a></li></ul></div></div>    
</body>
</html>