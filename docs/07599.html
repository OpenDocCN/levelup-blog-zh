<html>
<head>
<title>Improve Both App Performance and Code Quality: Combining HTTP Requests by Proxy Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">提高应用程序性能和代码质量:通过代理模式组合HTTP请求</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/improve-both-app-performance-and-code-quality-combining-http-requests-by-proxy-pattern-2cce132d60e?source=collection_archive---------7-----------------------#2021-02-26">https://levelup.gitconnected.com/improve-both-app-performance-and-code-quality-combining-http-requests-by-proxy-pattern-2cce132d60e?source=collection_archive---------7-----------------------#2021-02-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6ca2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一步一步优化一个真实的项目。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0ac6f54d6b993a1d0b22162a54e7100e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*289NRk8nd-XXOWrB5Fy82A.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">由bitfish创建</figcaption></figure><p id="eed5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在一个前端项目中，我们的网页经常需要向服务器发送多个HTTP请求。</p><p id="fef5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">假设我们的产品有一个特性，每次用户点击<code class="fe lu lv lw lx b">li</code>标签，客户端都会向服务器发送一个HTTP请求。</p><p id="715c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里有一个简单的演示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="c034" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在上面的代码中，我们直接使用一个简单的<code class="fe lu lv lw lx b">sendHTTPRequest</code>函数来<strong class="la iu">模拟</strong>发送一个HTTP请求。这样做是为了更好地关注核心目标，所以我简化了一些代码。</p><p id="76bb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后我们将一个点击事件绑定到<code class="fe lu lv lw lx b">ul</code>元素。每当用户点击一个标签，比如<code class="fe lu lv lw lx b">&lt;li&gt;5&lt;/li&gt;</code>，客户端就会执行<code class="fe lu lv lw lx b">sendHTTPRequest</code>函数向服务器发出一个HTTP请求。</p><p id="5b2f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上面的程序是这样工作的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ma"><img src="../Images/6a011f26340fd42e46e0b33086583114.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*IQCxX1xEmBpaAGUhc_uUOw.gif"/></div></div></figure><p id="d9d4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了让你们更容易尝试，我做了一个Codepen演示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mb lz l"/></div></figure><p id="5f89" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="mc">(你需要</em> <strong class="la iu"> <em class="mc">打开你浏览器的控制台</em> </strong> <em class="mc">才能看到程序的输出。)</em></p><p id="28b1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当然，在一个真实的项目中，我们可能会向服务器发送一个文件，推送通知，或者发送一些日志。但是我们将跳过演示会议的细节。</p><p id="ddaa" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">好了，这是一个非常简单的演示，那么上面的代码有什么缺点吗？</p></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><p id="6c72" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您的项目非常简单，那么编写这样的代码应该没有问题。但是，如果您的项目很复杂，并且您的客户端需要频繁地向服务器发送HTTP请求，那么这些代码将是低效的。</p><p id="c7b8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在上面的例子中，如果用户反复快速点击<code class="fe lu lv lw lx b">li</code>元素会发生什么？这个时候我们的客户端需要频繁的向服务器发出HTTP请求，每个请求都会消耗大量的时间和服务器资源。</p><p id="22ca" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">每次客户端与服务器建立新的HTTP连接时，都会消耗一些时间和服务器资源。因此，在HTTP传输机制中，一次传输所有文件比多次传输少量文件更高效。</p><p id="d609" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，您可能需要发送五个HTTP请求，每个请求的HTTP数据包大小为1MB。现在您一次发送一个HTTP请求，数据包大小为5MB。后者通常会比前一个表现得更好。</p><p id="3ae4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">网页的大量HTTP请求会降低页面的加载速度，最终损害用户体验。如果页面加载速度不够快，这会导致访问者更快地离开页面。</p><p id="ecfd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以在这种情况下，我们可以考虑合并HTTP请求。</p><p id="7f7f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我们目前的项目中，我的想法是这样的:我们可以在本地设置一个缓存，然后收集一段时间内需要发送到服务器的所有消息，并将它们一起发送。</p><p id="a9a3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你可以暂停一会儿，试着自己想清楚。</p><p id="260a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">提示:您需要创建一个本地缓存对象来收集需要发送的消息。然后，您需要使用计时器定期发送收集到的消息。</p><p id="3fbd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是一个实现。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mk"><img src="../Images/30dc5dd1fc37f4188c04c2dd919db668.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oHvRO90HOP4XlqNc7rw2rg.png"/></div></div></figure><pre class="kj kk kl km gt ml lx mm mn aw mo bi"><span id="22e5" class="mp mq it lx b gy mr ms l mt mu">var messages = [];<br/>var timer;</span><span id="2937" class="mp mq it lx b gy mv ms l mt mu">var sendHTTPRequest = function (message) {<br/>  messages.push(message);<br/>  if (timer) {<br/>    return;<br/>  }<br/>  timer = setTimeout(function () {<br/>    console.log("Start sending messages: ", messages.join(","));<br/>    console.log("1000ms passed");<br/>    console.log("HTTP Request is completed.");</span><span id="74e6" class="mp mq it lx b gy mv ms l mt mu">clearTimeout(timer);<br/>    timer = null;<br/>    messages = [];<br/>  }, 2000);<br/>};</span></pre><p id="2275" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">每当客户端需要发送消息时，即触发<code class="fe lu lv lw lx b">onclick</code>事件时，<code class="fe lu lv lw lx b">sendHTTPRequest</code>不会立即将消息发送给服务器，而是先将消息缓存在<code class="fe lu lv lw lx b">messages</code>中。然后我们有一个2秒后执行的计时器，2秒后计时器会将之前缓存的所有消息发送到服务器。这种改变达到了组合HTTP请求的目的。</p><p id="5479" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">测试结果如下:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mw"><img src="../Images/7139908666ac1d077db2a72da16fbdc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*7WdAkakkrRf3zxgkSd-5AA.gif"/></div></div></figure><p id="fe51" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如您所见，尽管我们多次触发了click事件，但在两秒钟内，我们只发送了一个HTTP请求。</p><p id="fdfd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当然，为了演示方便，我把等待时间设置为2秒。如果你觉得这个等待时间太长，可以缩短这个等待时间。</p><p id="49c9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于不需要太多实时交互的项目，2秒钟的延迟并不是一个巨大的副作用，但它可以减轻服务器的压力。在合适的背景下，这是非常值得的。</p></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><p id="773d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上面的代码确实为项目提供了一些性能改进。但是在代码设计方面，上面的代码并不好。</p><p id="9e18" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，它违反了单一责任原则。<code class="fe lu lv lw lx b">sendHTTPRequest</code>函数不仅向服务器发送HTTP请求，还组合HTTP请求。这个函数做得太多，使得代码看起来非常复杂。</p><p id="8d3d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果一个功能(或对象)承担了太多的责任，那么当我们的需求发生变化时，这个功能通常会发生巨大的变化。这样的设计不能有效地处理可能的变化，这是一个糟糕的设计。</p><p id="5aa5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们理想的代码应该是这样的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mx"><img src="../Images/afaa292a0bd39737d46aa981d02bbecc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Gb_Q259TU6A-FWvmZolyVQ.png"/></div></div></figure><p id="673f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们没有对<code class="fe lu lv lw lx b">sendHTTPRequest</code>做任何修改，而是选择为它提供一个代理。这个代理函数执行合并HTTP请求的任务，并将合并后的消息传递给<code class="fe lu lv lw lx b">sendHTTPRequest</code>进行发送。然后我们可以在将来使用<code class="fe lu lv lw lx b">proxySendHTTPRequest</code>方法。</p><p id="b5f3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你可以暂停一会儿，试着自己想清楚。</p><p id="25c7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是一个实现:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi my"><img src="../Images/41174068ee77e430066d94b27269bc01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qoqYkUpCdtkW5Tiqiv5C8Q.png"/></div></div></figure><pre class="kj kk kl km gt ml lx mm mn aw mo bi"><span id="848b" class="mp mq it lx b gy mr ms l mt mu">var proxySendHTTPRequest = (function() {<br/>    var messages = [],<br/>        timer;<br/>    return function(message) {<br/>        messages.push(message);<br/>        if (timer) {<br/>            return;<br/>        }<br/>        timer = setTimeout(function() {<br/>            sendHTTPRequest(messages.join(","));<br/>            clearTimeout(timer);<br/>            timer = null;<br/>            messages = [];<br/>        }, 2000);<br/>    };<br/>})();</span></pre><p id="b7f1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">大致思路和前面的代码类似，用一个<code class="fe lu lv lw lx b">messages</code>变量缓存一个时间范围内的所有消息，然后通过一个定时器统一发送。此外，这段代码使用闭包技巧将<code class="fe lu lv lw lx b">messages</code>和<code class="fe lu lv lw lx b">timer</code>变量放在局部范围内，以避免污染全局名称空间。</p><p id="5904" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这段代码和之前的代码最大的区别就是没有改变<code class="fe lu lv lw lx b">sendHTTPRequest</code>函数，而是把它隐藏在了<code class="fe lu lv lw lx b">proxySendHTTPRequest</code>后面。我们不再需要直接访问<code class="fe lu lv lw lx b">sendHTTPRequest</code>，而是使用代理<code class="fe lu lv lw lx b">proxySendHTTPRequest</code>来访问它。<code class="fe lu lv lw lx b">proxySendHTTPRequest</code>和<code class="fe lu lv lw lx b">sendHTTPRequest</code>有相同的参数列表，相同的返回值。</p><p id="54d8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这样的设计有什么好处？</p><ul class=""><li id="4c47" class="mz na it la b lb lc le lf lh nb ll nc lp nd lt ne nf ng nh bi translated">发送HTTP请求的任务和合并HTTP请求的任务被交给两个不同的函数，每个函数专注于一个职责。它符合单一责任原则，并使代码更容易理解。</li><li id="cc7b" class="mz na it la b lb ni le nj lh nk ll nl lp nm lt ne nf ng nh bi translated">由于两个函数的参数是相同的，我们可以简单地用<code class="fe lu lv lw lx b">proxySendHTTPRequest</code>替换<code class="fe lu lv lw lx b">sendHTTPRequest</code>的位置，而不需要做任何剧烈的改变。</li></ul><p id="40a1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">想象一下，如果在将来，网络性能提高了，或者由于其他原因，我们不再需要组合HTTP请求。此时，如果我们使用以前的设计，我们将不得不再次大规模地更改代码。用现在的代码设计，我们可以简单的替换函数名。</p><p id="8401" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">事实上，这个编码技巧在设计模式中经常被称为<strong class="la iu">代理模式</strong>。</p><p id="7956" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所谓的代理模式实际上在现实生活中很好理解。</p><ul class=""><li id="d502" class="mz na it la b lb lc le lf lh nb ll nc lp nd lt ne nf ng nh bi translated">假设你想访问一个网站，但你不想给出你的IP地址。然后你可以使用VPN，先访问你的代理服务器，然后通过代理服务器访问目标网站。所以目标站点无法知道你的IP地址。</li><li id="9efd" class="mz na it la b lb ni le nj lh nk ll nl lp nm lt ne nf ng nh bi translated">有时候，你会把你的真实服务器藏在Nginx服务器后面，让Nginx服务器为你的真实服务器处理一些琐碎的操作。</li></ul><p id="9046" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这些是代理模式的真实例子。</p><p id="4295" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们不需要纠结于代理模式(或任何其他设计模式)的官方定义，我们只需要知道，当客户端不方便(或不能)直接访问目标函数(或对象)时，我们可以提供一个代理函数(或对象)来控制对目标函数(或对象)的访问。客户机实际上访问代理函数(或对象)，代理函数对请求进行一些处理，然后将请求传递给目标。</p></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><p id="2ece" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您有任何问题或认为本文需要改进，欢迎您发表评论。你的建议和批评对我很有用。谢谢你。</p></div></div>    
</body>
</html>