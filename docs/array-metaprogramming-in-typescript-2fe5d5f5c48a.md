# TypeScript 中的数组元编程

> 原文：<https://levelup.gitconnected.com/array-metaprogramming-in-typescript-2fe5d5f5c48a>

大多数 TypeScript 开发人员很容易注意到他们可以使用泛型类型对数组进行类型化。有没有想过能不能推断出*一个阵*的*阵型*？或者说，如何根据类型得到*所有数组元素*？

如果你不知道如何做，请继续阅读！

如果您是更高级的 TypeScript 开发人员，我也为您准备了一些值得花时间的东西！

![](img/7c7ba0b6bd04ad6c0a1501018569baf8.png)

照片由[诺亚根岸](https://unsplash.com/@noah_negishi?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄

# 数组中的数组类型

推断特定数组的数组类型是更高级元编程的基础。如果你是初学者(这没什么不好，大家都是从头开始！)，你可能会尝试以下列方式:

这是可行的，因为`array1`的类型是`string[]`。由于在获得元素的类型后，仍然将元素推送到`array1`，因此 TypeScript 必须推断它是一个可变数组。从它的初始元素来看，这是一个可变的字符串数组。

如果我们想要一个更精确的类型呢？我们需要在不使用`ReadonlyArray<T>`类型的情况下使所讨论的数组不可变——否则，我们需要指定数组类型，这没有任何意义。我们应该使用`as const`的表达方式:

`array2`的类型是`readonly ['a' | 'b' | 'c']`。我们得到了我们想要的，然而，TypeScript 也允许我们提取数组元素类型！这需要以下列方式使用`infer`关键字:

`InferRAET`(“推断只读数组元素类型”)是一个条件泛型类型。它接受类型`A`只是为了检查它是否是`ReadonlyArray`类型。

我们使用`infer I`来标记元素类型以便推断。如果`A`是一个`ReadonlyArray`类型，则返回推断的元素类型。否则，我们返回`never`类型。

使用`InferREAT`后，`ET`(元素类型)等于`'a' | 'b' | 'c'`，为联合类型。

如果你认为使用`InferRAET`太复杂，我有个好消息。有一个更简洁的解决方案，它使用索引访问类型:

`ET`等于`ET2`，因为数组使用数字进行索引。

# 条件类型的分配性

如果我们想把只读数组类型改成可写数组类型呢？这种转换似乎可以通过一行代码实现，如下所示:

`TransformRA2WA`类型将只读数组转换为可写数组。如您所见，类型`RA1`和`RA2`是不同的，它们的转换类型`WA1`和`WA2`也是不同的。

为了检查类型的相等性，我使用了来自`ts-essentials`库中的`Exact`类型。`E1`和`E2`都等于`never`，表示测试的类型不准确。

当处理条件类型时，TypeScript 对泛型联合类型应用分布。这就是前面代码片段中缺少类型相等的原因。这个语言特性在这里有很好的描述[。](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#distributive-conditional-types)

如果我们想在示例中禁用分发，我们需要执行以下操作:

如您所见，`TransformRA2WAND`(“将只读数组转换为可写数组，无分布”的简化名称)与`TransformRA2WA`的不同之处仅在于 extends 表达式的左右两边都有`[]`(方括号)。如前所述，`WA3`在类型方面等于`WA4`。

# 数组类型中的所有数组元素

如果你曾经尝试过这种转换，你就会知道这不是一件容易的事情。这可以归结为将联合类型转换为元组类型——不幸的是，不存在支持这种转换的 TypeScript 操作符。如果你想深入了解这个话题，你可以访问这个 [GitHub 问题](https://github.com/microsoft/TypeScript/issues/13298)。

同时，我将描述以下三种解决这个问题的方法。

## 解决方案 1

由于联合类型到元组类型的转换仍然很复杂，我们可以将联合作为对象的属性来析构。这是 joaopaulobdac 在他们的评论中发现的，虽然我不知道他们是否是第一个发现这种方法的人。我们可以很容易地在 TypeScript 中键入这样一个对象，如下面的代码片段所示:

你可能会问为什么`ET3KeyToOneDictionary`中的值总是设置为`1`。它可以被设置为几乎任何值，但是我希望有一个单一的字符值，以节省打字。正如您可能看到的，所提出的方法有两个问题:

*   建造`et3KeyToOneDictionary`可能会令人厌倦，
*   `allElements`是`string[]`型，不是`ET3[]`型。

## 解决方案 2

由于第一个解决方案不够简洁，我们需要另一个解决方案。自从 **vojtechhabarta** 发现我们可以在这里利用枚举[，我相应地修改了第一个解决方案。以下代码片段提供了结果:](https://github.com/Microsoft/TypeScript/issues/13298#issuecomment-823206565)

该代码绝对值得解释。名为`ET4KeyToNumberDictionary`的字典类型将联合类型的键映射成数字。我这样做是为了确保`ET4KeyToNumberDictionary`匹配下面的`Enum4`类型。提取所有枚举键并不容易(您可能想自己检查一下为什么我必须过滤这些键)。

由于 TypeScript 中的枚举不能显式扩展类型，我需要自己确保类型安全。为此，我编写了一个只有两种状态的类型守卫— `0`或`1`。后者仅在`Enum4`在类型级别上扩展`ET4KeyToNumberDictionary`时发生。之后，我设置`typeGuard`来保存`1`作为一个值。

只要类型正确，代码就会编译。你可能想知道我为什么在它的定义后调用`typeGuard`。我这样做是为了确保编译器对未使用常量的遵从。

## 解决方案 3

**karol-majewski** 在这里提出了我目前为止看到的最好的解决方案[。尽管这是一个非常高级的片段，我还是会一步一步地向您介绍。](https://github.com/Microsoft/TypeScript/issues/13298#issuecomment-654906323)

**类型的值**

首先，我们需要讨论一下`ValueOf`泛型类型。由于许多 TypeScript 开发人员使用它，一些库已经包含了它，`ts-essentials`是最显著的例子。正式定义如下:

如果我们在一个数组类型上使用`ValueOf`会发生什么？

因为数组是对象，所以我们得到该对象中所有值的联合类型，尤其是数组方法和所有数组元素类型。

**value of Type 和 Extends 关键字**

其次，我必须解释在`MustInclude`型的引擎盖下发生了什么，在我们正在讨论的例子中有详细说明。我将使用下面的片段来解构那里发生的事情:

`T1`是一个比 tuple 类型更多类型的 union 类型，称为`U1`。因此，`U1`扩展`T1[]`，同样的方式`'a'`扩展`string`。起初听起来可能有些违反直觉，但是只有当`a`可以被赋值给`string`时，`extends`关键字才会让编译器进行检查。你可以在这里阅读更多关于它的[。](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)

上一段解释了为什么`C1`等于`1`。那`C2`呢？`C2`也等于`1`吗？

它没有！

如果`U1`是一组字符串，那么`ValueOf<U1>`是什么？对于这个表达式，我们可以将`U1`视为字符串文字的数组类型。这样的数组在 JavaScript 中始终是一个对象。

如前所述，应用于对象类型的`ValueOf`类型导致所有属性值类型的联合。对于数组类型，这归结为以下内容的联合:

*   过多的函数类型，
*   数组元素类型。

`U1`的数组元素类型有哪些？必须是`'a'`、`'b'`和`'c'`。我们能至少将`T1`赋值给这些元素类型的并集吗？显然不是，因为它们不包含`'d'`字符串文字类型。

这证明了为什么`T1`没有扩展`ValueOf<U1>`，因此`C2`等于`0`。

作为练习，您可以从`T1`中删除`'c' | 'd'`，并重新思考之前概述的推理。

**必须包括类型和分布**

第三，一个热心的读者一定已经意识到我已经解释了几乎所有关于由 **karol-majewski** 提供的解决方案的事情。几乎所有的事情，因为`MustInclude`类型使用非分配条件类型，由包围在`extends`表达式两边的方括号表示。

正如您可能意识到的，这不是错误，分发必须被禁用。

`MustInclude`有两个泛型类型，但只有第一个(`T`)是联合类型。这意味着使用 distribution，将为每个 union 元素调用`T extends ValueOf<U>`表达式，end 类型将是所有这些表达式结果的并集。

我们可以应用这种思想来编写一个模仿这种行为的代码片段:

尽管根据我们从前面的代码片段中了解到的情况，`T1`没有扩展`ValueOf<U1>`，但是所有`extends`表达式的并集(`C`)等于`U1`。这种情况只发生在应用于任何联合类型的`never`类型不会改变它的时候。

# 数组类型和数组元素的所有元组元素

由于在某些情况下元组可以用数组来近似，所以我们可以很容易地从元组类型中获取所有元素，并将它们转换为数组类型。请看看下面的片段:

我们可以通过复制元组定义并将其设置为一个值来提取所有元组元素。为了推断 tuple 中元素的联合类型，我们需要使用之前定义的泛型类型`InferREAT`。这是 TypeScript 将元组转换为(只读)数组以进行推断的时刻。在我们提取了元素类型`ETT1[]`之后，我们可以定义数组类型。

# 使用 io-ts 进行元编程

`io-ts`库允许软件开发人员为 JSON 对象的反序列化创建编解码器，还有许多其他用途。它支持许多元编程模式，尤其是在处理数组类型时。我编写了下面的代码片段来展示它的功能示例:

`codec`结构在自身内部编码(无意双关)类型数据，我们可以使用`TypeOf`类型提取它们——我建议更高级的 TypeScript 开发人员阅读控制这种类型提取的代码。完全掌握它并可能在自己的项目中使用相同的模式绝对值得您花费时间。

我们还可以使用提供的编解码器接口获得所有数组元素(`allElementsFromCodec`)。通过定义一个编解码器，我们可以自动获得数组类型及其所有元素。

# 摘要

数组元编程仍然是 TypeScript 中的一个广泛话题。到目前为止，我们可以很容易地将数组类型与数组元素联系起来，并执行相互推断的操作，反之亦然。我们还观察到，在特定的场景中，数组可以与元组互换使用。