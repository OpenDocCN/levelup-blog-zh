<html>
<head>
<title>Java Functional Interface and Lamda Implementation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java函数接口和Lamda实现</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/java-functional-interface-and-lamda-implementation-7121eb7c8564?source=collection_archive---------4-----------------------#2021-05-20">https://levelup.gitconnected.com/java-functional-interface-and-lamda-implementation-7121eb7c8564?source=collection_archive---------4-----------------------#2021-05-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="132c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">术语<em class="ki"> Java函数接口</em>是在Java 8中引入的</h2></div><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/958a7173420ec6af94b69e175a8e1956.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9VWXwMiztoTy76ra"/></div></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk translated"><a class="ae kz" href="https://unsplash.com/@tracycodes?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Tracy Adams </a>在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="3d55" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">Java中的函数接口是只包含一个抽象(未实现)方法的接口。</p><p id="b6a3" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">除了单个未实现的方法之外，函数接口可能已经默认，静态方法可能已经实现。</p><p id="98f4" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">添加了注释，这样我们可以将一个接口标记为功能接口。即使没有它，只要你的接口只有一个抽象方法，它也会被视为功能性的。<strong class="lc iu">这确保了接口不能有一个以上的抽象方法。</strong></p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="828b" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这里，它只有一个抽象方法，所以我们可以省略注释<code class="fe lw lx ly lz b">@FunctionalInterface.</code></p><h2 id="b269" class="mc md it bd me mf mg dn mh mi mj dp mk lj ml mm mn ln mo mp mq lr mr ms mt mu bi translated"><strong class="ak">功能接口要点/观察:</strong></h2><ol class=""><li id="5058" class="mv mw it lc b ld mx lg my lj mz ln na lr nb lv nc nd ne nf bi translated">一个函数接口只有一个抽象方法，但是它可以有多个默认方法。</li><li id="d63c" class="mv mw it lc b ld ng lg nh lj ni ln nj lr nk lv nc nd ne nf bi translated"><code class="fe lw lx ly lz b">@FunctionalInterface</code>注释用于确保一个接口不能有多个抽象方法。该注释的使用是可选的。</li><li id="3153" class="mv mw it lc b ld ng lg nh lj ni ln nj lr nk lv nc nd ne nf bi translated">java.util.function包包含了Java 8中很多内置的函数接口。</li></ol><h2 id="4737" class="mc md it bd me mf mg dn mh mi mj dp mk lj ml mm mn ln mo mp mq lr mr ms mt mu bi translated">功能界面的使用</h2><ul class=""><li id="8f7b" class="mv mw it lc b ld mx lg my lj mz ln na lr nb lv nl nd ne nf bi translated">java 8中引入了函数接口，以支持Java 8中的lambda表达式。另一方面，可以说lambda表达式是函数接口的实例。</li><li id="aad3" class="mv mw it lc b ld ng lg nh lj ni ln nj lr nk lv nl nd ne nf bi translated">Java 8 Collections API已经被重写，并且引入了一个新的流API，它使用了很多函数接口。</li><li id="8620" class="mv mw it lc b ld ng lg nh lj ni ln nj lr nk lv nl nd ne nf bi translated">Java 8在这个包里定义了很多功能接口<code class="fe lw lx ly lz b">java.util.function</code>。一些有用的java 8函数接口有<code class="fe lw lx ly lz b">Consumer</code>、<code class="fe lw lx ly lz b">Supplier</code>、<code class="fe lw lx ly lz b">Function</code>和<code class="fe lw lx ly lz b">Predicate</code>。</li></ul><h2 id="f982" class="mc md it bd me mf mg dn mh mi mj dp mk lj ml mm mn ln mo mp mq lr mr ms mt mu bi translated">如何定义功能接口</h2><p id="4bbe" class="pw-post-body-paragraph la lb it lc b ld mx ju lf lg my jx li lj nm ll lm ln nn lp lq lr no lt lu lv im bi translated">首先，我们可以检查一个内置的功能接口。其给出如下:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="df1a" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这里，<code class="fe lw lx ly lz b">Function</code>接口表示一个函数(方法),它接受一个参数(T)并返回一个值(R)。</p><p id="7307" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">除了上面列出的方法之外，<code class="fe lw lx ly lz b">Function</code>接口实际上包含了一些额外的方法。尽管如此，因为它们都有一个默认的实现，所以您不必实现这些额外的方法。</p><p id="1e00" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">您必须实现的实现<code class="fe lw lx ly lz b">Function</code>接口的唯一方法是<code class="fe lw lx ly lz b">apply()</code>方法。下面是一个<code class="fe lw lx ly lz b">Function</code>实现的例子:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="1d6b" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">现在调用方法如下:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="02d4" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这里，</p><ul class=""><li id="a838" class="mv mw it lc b ld le lg lh lj np ln nq lr nr lv nl nd ne nf bi translated">第一个例子创建了一个新的<code class="fe lw lx ly lz b">AddSeedValueImplementation</code>实例，并将其赋给一个<code class="fe lw lx ly lz b">Function</code>变量。</li><li id="90ed" class="mv mw it lc b ld ng lg nh lj ni ln nj lr nk lv nl nd ne nf bi translated">其次，该示例在<code class="fe lw lx ly lz b">AddSeedValueImplementation</code>实例上调用<code class="fe lw lx ly lz b">apply()</code>方法。</li><li id="e9cf" class="mv mw it lc b ld ng lg nh lj ni ln nj lr nk lv nl nd ne nf bi translated">第三，该示例打印出结果(即9)。</li></ul><p id="e44b" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">现在我描述它的lambda实现:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="2d9f" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这里，</p><ul class=""><li id="5958" class="mv mw it lc b ld le lg lh lj np ln nq lr nr lv nl nd ne nf bi translated">首先，我们定义计算功能接口应用方法。这里，n是提供的输入，而(5L+n)是提供的输入和硬编码值5之和</li><li id="5dec" class="mv mw it lc b ld ng lg nh lj ni ln nj lr nk lv nl nd ne nf bi translated">其次，我们正在使用新配置的接口<strong class="lc iu">功能</strong>。在apply方法中，我们传递计算。</li></ul><h2 id="af5e" class="mc md it bd me mf mg dn mh mi mj dp mk lj ml mm mn ln mo mp mq lr mr ms mt mu bi translated">默认方法的功能接口</h2><p id="305e" class="pw-post-body-paragraph la lb it lc b ld mx ju lf lg my jx li lj nm ll lm ln nn lp lq lr no lt lu lv im bi translated">我们只是在修改之前的界面。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="2435" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这里，我们只是添加了一个名为defaultMethodAdd的默认方法。下面给出了调用机制。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ma mb l"/></div></figure><h2 id="a9ea" class="mc md it bd me mf mg dn mh mi mj dp mk lj ml mm mn ln mo mp mq lr mr ms mt mu bi translated">具有两个输入和一个结果的功能接口</h2><p id="9e0e" class="pw-post-body-paragraph la lb it lc b ld mx ju lf lg my jx li lj nm ll lm ln nn lp lq lr no lt lu lv im bi translated">检查下面的代码</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="3517" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这里，</p><ul class=""><li id="3826" class="mv mw it lc b ld le lg lh lj np ln nq lr nr lv nl nd ne nf bi translated">输入是X和Y，输出是R</li></ul><p id="726c" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">现在调用机制是</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="4fcb" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这里，</p><ul class=""><li id="9639" class="mv mw it lc b ld le lg lh lj np ln nq lr nr lv nl nd ne nf bi translated">我们正在定义函数的行为方式。它将两个参数作为输入，相乘并返回结果值。</li></ul><h2 id="0329" class="mc md it bd me mf mg dn mh mi mj dp mk lj ml mm mn ln mo mp mq lr mr ms mt mu bi translated">具有字符串匹配的功能接口</h2><p id="1241" class="pw-post-body-paragraph la lb it lc b ld mx ju lf lg my jx li lj nm ll lm ln nn lp lq lr no lt lu lv im bi translated">让我们检查下面的功能接口谓词。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="0c1d" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这里，</p><ul class=""><li id="936e" class="mv mw it lc b ld le lg lh lj np ln nq lr nr lv nl nd ne nf bi translated">输入是T，会是字符串，输出是R</li></ul><p id="1f4a" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">现在调用机制如下</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="e8ae" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这里，</p><ul class=""><li id="d66d" class="mv mw it lc b ld le lg lh lj np ln nq lr nr lv nl nd ne nf bi translated">创建字符串列表。</li><li id="16ba" class="mv mw it lc b ld ng lg nh lj ni ln nj lr nk lv nl nd ne nf bi translated">用从G开始的逻辑字符串构建谓词</li><li id="82f7" class="mv mw it lc b ld ng lg nh lj ni ln nj lr nk lv nl nd ne nf bi translated">现在从另一个列表中提取从G开始的字符串</li></ul></div><div class="ab cl ns nt hx nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="im in io ip iq"><h2 id="cd32" class="mc md it bd me mf mg dn mh mi mj dp mk lj ml mm mn ln mo mp mq lr mr ms mt mu bi translated">结论</h2><p id="855d" class="pw-post-body-paragraph la lb it lc b ld mx ju lf lg my jx li lj nm ll lm ln nn lp lq lr no lt lu lv im bi translated">我希望你喜欢这篇文章。快乐阅读:)</p><p id="bb9a" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><strong class="lc iu">参考文献:<br/> 1。</strong><a class="ae kz" href="https://www.geeksforgeeks.org/functional-interfaces-java/" rel="noopener ugc nofollow" target="_blank">https://www.geeksforgeeks.org/functional-interfaces-java/</a><br/>2。<a class="ae kz" href="http://tutorials.jenkov.com/java-functional-programming/functional-interfaces.html" rel="noopener ugc nofollow" target="_blank">http://tutorials . jen kov . com/Java-functional-programming/functional-interfaces . html</a><br/>3 .<a class="ae kz" href="https://dzone.com/articles/functional-interface-and-lambda-expression-in-java" rel="noopener ugc nofollow" target="_blank">https://dzone . com/articles/functional-interface-and-lambda-expression-in-Java</a></p></div></div>    
</body>
</html>