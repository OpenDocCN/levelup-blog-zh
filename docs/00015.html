<html>
<head>
<title>JavaScript Promises - Understand JavaScript Promises by Building a Simple Promise Example</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript承诺——通过构建一个简单的承诺示例来理解JavaScript承诺</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/understand-javascript-promises-by-building-a-promise-from-scratch-84c0fd855720?source=collection_archive---------0-----------------------#2017-09-26">https://levelup.gitconnected.com/understand-javascript-promises-by-building-a-promise-from-scratch-84c0fd855720?source=collection_archive---------0-----------------------#2017-09-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e9d1" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">这是一个循序渐进的教程，通过从头开始构建承诺，确保您完全理解JavaScript承诺是如何工作的</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/7d9e1c5a44910914c1e6e9cc150a7426.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Z-8zwP0QEAewJg7hRM22cw.gif"/></div></div></figure><p id="e8ab" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在本教程中，您将通过从头开始构建JavaScript promise来学习JavaScript promise。这一课对于仍在学习异步JavaScript基础知识的初学者和中级开发人员来说非常有用。您将构建的JavaScript promise示例旨在帮助您理解承诺和异步思维的基础——它并不打算展示承诺的最佳版本。</p><div class="ln lo gp gr lp lq"><a href="https://skilled.dev" rel="noopener  ugc nofollow" target="_blank"><div class="lr ab fo"><div class="ls ab lt cl cj lu"><h2 class="bd ir gy z fp lv fr fs lw fu fw ip bi translated">编写面试问题</h2><div class="lx l"><h3 class="bd b gy z fp lv fr fs lw fu fw dk translated">一个完整的平台，在这里我会教你找到下一份工作所需的一切，以及…</h3></div><div class="ly l"><p class="bd b dl z fp lv fr fs lw fu fw dk translated">技术开发</p></div></div><div class="lz l"><div class="ma l mb mc md lz me kp lq"/></div></div></a></div><p id="47a4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你可能以前见过类似的东西:</p><pre class="kg kh ki kj gt mf mg mh mi aw mj bi"><span id="304d" class="mk ml iq mg b gy mm mn l mo mp">fetch('/user/1')<br/>  .then((user) =&gt; { <br/>    /* Do something with user after the API returns */ <br/>  })</span></pre><p id="7d78" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在执行任何操作之前，<code class="fe mq mr ms mg b">.then()</code>中的代码块会一直等待，直到收到来自服务器的响应。这叫做<code class="fe mq mr ms mg b">Promise</code>。但是不要让花哨的名字或者异步代码<a class="ae mt" href="https://stackoverflow.com/questions/4559032/easy-to-understand-definition-of-asynchronous-event" rel="noopener ugc nofollow" target="_blank">的事实吓倒你——<code class="fe mq mr ms mg b">Promise</code>只是一个普通的老式JavaScript对象，它有特殊的方法允许你同步执行代码(即使有延迟，它也会按顺序执行)。</a></p><p id="69bd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe mq mr ms mg b">typeof new Promise((resolve, reject) =&gt; {}) === 'object' // true</code></p><p id="81cd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我重申一下(因为这是我第一次学习承诺时很难理解的)，一个<code class="fe mq mr ms mg b">Promise</code>只是一个对象。为了能够在响应后等待服务器并执行<code class="fe mq mr ms mg b">.then()</code>链中的代码，必须返回一个<code class="fe mq mr ms mg b">Promise</code>对象。这不是函数开箱即用的东西。在幕后，fetch函数正在做这样的事情。</p><pre class="kg kh ki kj gt mf mg mh mi aw mj bi"><span id="2cfa" class="mk ml iq mg b gy mm mn l mo mp">const fetch = function(url) {<br/>  return new Promise((resolve, reject) =&gt; {<br/>    request((error, apiResponse) =&gt; {<br/>      if (error) {<br/>        reject(error)<br/>      }<br/>      <br/>      resolve(apiResponse)<br/>    })<br/>  })<br/>}</span></pre><p id="3729" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe mq mr ms mg b">fetch()</code>函数向服务器发出http请求，但是客户端不知道服务器什么时候会发回结果。因此JavaScript开始执行其他不相关的代码，同时等待服务器返回响应。一旦客户端收到响应，它就会通过调用<code class="fe mq mr ms mg b">resolve(apiResponse)</code>来启动<code class="fe mq mr ms mg b">.then()</code>语句中代码的执行。</p><p id="528e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在让我们仔细看看<code class="fe mq mr ms mg b">Promise</code>实际上是如何让你做到这一点的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div><figcaption class="mw mx gj gh gi my mz bd b be z dk translated">一个承诺的教育范例—<a class="ae mt" href="https://gist.github.com/treyhuffine/d2e63bdee6645a7a0619989ee5a4538b" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/trey huffine/D2 e 63 bdee 6645 a7a 0619989 ee5a 4538 b</a></figcaption></figure><blockquote class="na nb nc"><p id="a880" class="kr ks nd kt b ku kv jr kw kx ky ju kz ne lb lc ld nf lf lg lh ng lj lk ll lm ij bi translated">注意:这个版本的承诺仅用于教育目的。我省略了一些更高级的特性，将其提炼为核心功能。</p></blockquote><p id="bc3f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我把它命名为<code class="fe mq mr ms mg b">PromiseSimple</code>，这样它就不会和原生的<code class="fe mq mr ms mg b">Promise</code>冲突，以防你想把它复制粘贴到你的Chrome主机上。我们的承诺实现有一个<code class="fe mq mr ms mg b">constructor</code>，两个你可能熟悉的公共方法<code class="fe mq mr ms mg b">then()</code>和<code class="fe mq mr ms mg b">catch()</code>，两个内部方法<code class="fe mq mr ms mg b">onResolve()</code>和<code class="fe mq mr ms mg b">onReject()</code>。</p><p id="52ef" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当你创造一个承诺时，你这样做<code class="fe mq mr ms mg b">new Promise((resolve, reject) =&gt; {/* ... */})</code>。你传递给它一个回调函数，我在构造函数中命名为<code class="fe mq mr ms mg b">executionFunction</code>。执行函数采用映射到内部函数<code class="fe mq mr ms mg b">onResolve()</code>和<code class="fe mq mr ms mg b">onReject()</code>的<code class="fe mq mr ms mg b">resolve</code>和<code class="fe mq mr ms mg b">reject</code>。当fetch调用resolve或reject时，将调用这些函数。</p><p id="e1bf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">构造函数还创建了一个<code class="fe mq mr ms mg b">promiseChain</code>数组和<code class="fe mq mr ms mg b">handleError</code>函数。当添加一系列<code class="fe mq mr ms mg b">.then(() =&gt; {})</code>时，它会将每个功能推送到<code class="fe mq mr ms mg b">promiseChain</code>上。当用户调用<code class="fe mq mr ms mg b">catch(() =&gt; {})</code>时，它将函数分配给内部<code class="fe mq mr ms mg b">handleError</code>。注意<code class="fe mq mr ms mg b">then()</code>和<code class="fe mq mr ms mg b">catch()</code>功能<code class="fe mq mr ms mg b">return this;</code>。这允许你链接多个<code class="fe mq mr ms mg b">then()</code>，因为你正在返回对象本身。</p><blockquote class="na nb nc"><p id="5a32" class="kr ks nd kt b ku kv jr kw kx ky ju kz ne lb lc ld nf lf lg lh ng lj lk ll lm ij bi translated">注意:在原生的<code class="fe mq mr ms mg b">Promise</code>中，这些<code class="fe mq mr ms mg b">then()</code>和<code class="fe mq mr ms mg b">catch()</code>函数实际上返回了一个<code class="fe mq mr ms mg b">new Promise</code>，但是对于这个简单的场景，我只返回了<code class="fe mq mr ms mg b">this</code>。此外，可以有多个<code class="fe mq mr ms mg b">.catch()</code>模块，它们也可以被链接，并且不需要出现在<code class="fe mq mr ms mg b">.then()</code>链的末端。</p></blockquote><p id="5716" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当异步函数调用<code class="fe mq mr ms mg b">resolve(apiResponse)</code>时，promise对象开始执行<code class="fe mq mr ms mg b">onResolve(apiResponse)</code>。它通过删除前面的函数来遍历整个<code class="fe mq mr ms mg b">promiseChain</code>，并使用保存在<code class="fe mq mr ms mg b">storedValue</code>中的最新值来执行它。然后它将<code class="fe mq mr ms mg b">storedValue</code>更新为最近一次执行的结果。它将按顺序执行这些功能。这就创建了同步承诺链。</p><p id="7906" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">该循环被包裹在<code class="fe mq mr ms mg b">try/catch</code>块中。这是查找错误的特殊JavaScript语法。如果你的异步函数调用了<code class="fe mq mr ms mg b">reject(error)</code>或者你的<code class="fe mq mr ms mg b">try/catch</code>发现了一个错误，那么它将被传递给<code class="fe mq mr ms mg b">onReject()</code>方法，该方法调用你传递给<code class="fe mq mr ms mg b">.catch()</code>的函数。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nh"><img src="../Images/aced8a676f6e35c5f7a618a71ff5fd7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TLAWV1AQAnbMj9Ravbgq7A.png"/></div></div></figure><div class="ln lo gp gr lp lq"><a href="https://gitconnected.com/portfolio-api" rel="noopener  ugc nofollow" target="_blank"><div class="lr ab fo"><div class="ls ab lt cl cj lu"><h2 class="bd ir gy z fp lv fr fs lw fu fw ip bi translated">组合API —轻松发展您的编码事业| gitconnected</h2><div class="lx l"><h3 class="bd b gy z fp lv fr fs lw fu fw dk translated">消除在每个单独位置手动更新您的详细信息的痛苦。只需在您的中更改一次数据…</h3></div><div class="ly l"><p class="bd b dl z fp lv fr fs lw fu fw dk translated">gitconnected.com</p></div></div><div class="lz l"><div class="ni l mb mc md lz me kp lq"/></div></div></a></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nh"><img src="../Images/aced8a676f6e35c5f7a618a71ff5fd7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TLAWV1AQAnbMj9Ravbgq7A.png"/></div></div></figure><p id="6da3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">结合一个更实际的例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mu mv l"/></div><figcaption class="mw mx gj gh gi my mz bd b be z dk translated"><a class="ae mt" href="https://gist.github.com/treyhuffine/f21525172fece828d385f9c5db8f87a0" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/trey huffine/f 21525172 fece 828d 385 f 9 C5 db 8 f 87 a 0</a></figcaption></figure></div><div class="ab cl nj nk hu nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ij ik il im in"><p id="eaf6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="nd">如果您觉得本文有帮助，请点击</em>👏<em class="nd">。</em> <a class="ae mt" href="https://medium.com/@treyhuffine" rel="noopener"> <em class="nd">关注我</em> </a> <em class="nd">了解更多关于React、Node.js、JavaScript和开源软件的文章！你也可以在</em><a class="ae mt" href="https://twitter.com/treyhuffine" rel="noopener ugc nofollow" target="_blank"><em class="nd">Twitter</em></a><em class="nd">或者</em><a class="ae mt" href="https://gitconnected.com/treyhuffine" rel="noopener ugc nofollow" target="_blank"><em class="nd">git connected</em></a><em class="nd">上找到我。</em></p></div></div>    
</body>
</html>