# 魔术师算法指南，第 1 部分:冒泡排序

> 原文：<https://levelup.gitconnected.com/the-magicians-guide-to-algorithms-part-1-the-bubble-sort-271a9aa6d18>

我现在必须警告你。我是幻想小说的超级粉丝。如果这不是你的事情，你可能想在其他地方寻找你的算法需求，因为它将在这里变得不可思议。不用说，我需要一种有趣的方式来回顾我的算法，所以这里推出了一系列以魔法为主题的帖子，希望这是一种学习或重新学习算法的有趣方式。这第一周，我将涵盖泡沫排序。

**冒泡排序**

首先，让我们想象一下，在魔药学课上被留校后，你正为斯内普教授整理坩埚，或者你只是想帮助威妮弗蕾德·桑德森整理她的坩埚收藏。

![](img/d08667265b2f3d33156c6823e88b388b.png)

有很多方法可以做到这一点，但因为你是第一年，你只知道冒泡排序。冒泡排序的概念非常简单。

假设斯内普想让你按大小给坩埚分类。一个简单的冒泡排序将第一个大锅和第二个进行比较，如果第一个大锅比第二个大，我们就交换它们。然后我们对第二个大锅和第三个大锅做同样的事情，如果有必要的话，一直对它们施魔法直到最后一个，这时我们告诉斯内普我们完了，他给了我们一些其他的粗活要做，直到宵禁后我们终于可以艰难地回到公共休息室。

这是你的基本咒语，以泡沫排序釜:

我们通过声明变量`swapped`开始这个咒语。这个变量必须在顶部声明，因为我们使用的是 do/while 循环。我觉得通过区分外循环(do/while)和内循环(for ),更容易理解这个算法的内部工作原理。

一旦`swapped`被声明，我们就进入 for 循环。首先，我们让`current`变量等于`i`索引处的`list`元素，以存储字母。然后我们声明`next`变量等于一个三元语句。原因如下:

如果我们简单地让`next`等于`list[i + 1]`，那么当我们到达数组的末尾时就会出现问题。`list[i + 1]`将等于`undefined`，这对谁都没有好处。这就是为什么我们让`next`等于`list[i + 1]`或`Number.POSITIVE_INFINITY`。正无穷大总是大于数组中的任何元素，这使得当我们到达数组末尾时循环结束，因为到那时`next < current`总是为假。

我们比较`next`和`current`，看看我们是否需要交换。如果我们这样做，`next`成为`list[i]`的值，`current`成为`list[i + 1]`的值。变量`swapped`也被设置为`true`，这允许我们的外部循环继续。

一旦没有变量可交换，`swapped`将等于`false`，我们退出内部循环和外部循环，并返回一个排序良好的大锅列表(我的意思是数字)。

**结论**

这就是了。我们已经成功地铸造了 *bubbilicus sorticus* (气泡分类)，现在你有了一架子的分类坩埚，即使斯内普也会引以为豪，至少在下一节魔药课之前是这样。

下周我们将处理[合并排序](https://medium.com/gitconnected/the-magicians-guide-to-algorithms-part-2-the-merge-sort-84e3cbdd1cd2)。