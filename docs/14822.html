<html>
<head>
<title>Clone saga in JavaScript part 2: Shallow copying in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的克隆传奇第2部分:JavaScript中的浅层复制</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/clone-saga-in-javascript-part-2-shallow-copying-in-javascript-9dc340b92634?source=collection_archive---------23-----------------------#2022-12-26">https://levelup.gitconnected.com/clone-saga-in-javascript-part-2-shallow-copying-in-javascript-9dc340b92634?source=collection_archive---------23-----------------------#2022-12-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="549d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi ko translated"><span class="l kp ky bm di kz"> <img alt="T" class="la lb lc ld le lf fc n ih dh bf" src="../Images/97e826c971e9cf5664ff0bfa07877590.png" width="61" height="79" loading="lazy" data-original-src="https://miro.medium.com/v2/resize:fit:122/1*azj21xtGu5mYYcwndMfUWg.png"/> <span class="l kp kq kr bm ks kt ku kv kw di kx"> T </span> </span>他的是JavaScript克隆传奇的第二部分。在<a class="ae lg" href="https://pandaquests.medium.com/clone-saga-in-javascript-part-1-different-ways-of-how-to-copy-objects-11f625fa156a" rel="noopener">上一篇文章中，我们探讨了JavaScript中存在什么样的复制</a>。在这篇文章中，我们将深入浅出的复制。在本系列的下一篇文章中，我们将深入研究深度复制。</p><p id="8ab7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这只是我们写的许多关于JavaScript或软件开发的文章中的一篇。我们试图每天发表一篇文章——即使是在节假日。关注或订阅我们，这样你就不会错过任何一个。</p><figure class="li lj lk ll gt lm gh gi paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="gh gi lh"><img src="../Images/a3be51a5b572f5542d63d206616597c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wKIW3rvq36UYz2XP"/></div></div><figcaption class="ls lt gj gh gi lu lv bd b be z dk translated">克劳福德·乔利在<a class="ae lg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="5f58" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在JavaScript中，浅表副本是一个对象的副本，它创建一个与原始对象具有相同属性的新对象，但不复制原始对象引用的对象。查看上一篇文章，了解什么是JavaScript中的浅层复制。</p><p id="d430" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以下是在JavaScript中创建对象的浅层副本的几种方法:</p><ul class=""><li id="b89f" class="lw lx it js b jt ju jx jy kb ly kf lz kj ma kn mb mc md me bi translated">使用Object.assign()方法:</li></ul><pre class="li lj lk ll gt mf mg mh bn mi mj bi"><span id="0b41" class="mk ml it mg b be mm mn l mo mp">const original = { a: 1, b: { c: 3 } };<br/>const copy = Object.assign({}, original);</span></pre><p id="00b7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这将创建一个新对象，并将原始对象的属性复制到其中。</p><ul class=""><li id="8788" class="lw lx it js b jt ju jx jy kb ly kf lz kj ma kn mb mc md me bi translated">使用扩展运算符(…)</li></ul><pre class="li lj lk ll gt mf mg mh bn mi mj bi"><span id="97b7" class="mk ml it mg b be mm mn l mo mp">const original = { a: 1, b: { c: 3 } };<br/>const copy = { …original };</span></pre><p id="cf35" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这将创建一个新对象，并将原始对象的属性复制到其中，就像Object.assign()一样。</p><ul class=""><li id="cfbc" class="lw lx it js b jt ju jx jy kb ly kf lz kj ma kn mb mc md me bi translated">使用Object.create()方法:</li></ul><pre class="li lj lk ll gt mf mg mh bn mi mj bi"><span id="f3db" class="mk ml it mg b be mm mn l mo mp">const original = { a: 1, b: { c: 3 } };<br/>const copy = Object.create(Object.getPrototypeOf(original), Object.getOwnPropertyDescriptors(original));</span></pre><p id="3eae" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这将创建一个与原始对象具有相同原型的新对象，并将自己的属性及其描述符从原始对象复制到新对象中。</p><ul class=""><li id="85d6" class="lw lx it js b jt ju jx jy kb ly kf lz kj ma kn mb mc md me bi translated">使用循环:</li></ul><pre class="li lj lk ll gt mf mg mh bn mi mj bi"><span id="70c8" class="mk ml it mg b be mm mn l mo mp">function shallowCopy(obj) {<br/>  const copy = {};<br/>  for (let key in obj) {<br/>    if (obj.hasOwnProperty(key)) {<br/>      copy[key] = obj[key];<br/>    }<br/> }<br/> return copy;<br/>}<br/>const original = { a: 1, b: { c: 3 } };<br/>const copy = shallowCopy(original);</span></pre><p id="a36f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这将创建一个新对象，并使用一个循环将原始对象的自身属性复制到其中。</p><ul class=""><li id="3f6a" class="lw lx it js b jt ju jx jy kb ly kf lz kj ma kn mb mc md me bi translated">使用Object.keys()和Array.prototype.reduce()方法:</li></ul><pre class="li lj lk ll gt mf mg mh bn mi mj bi"><span id="9027" class="mk ml it mg b be mm mn l mo mp">function shallowCopy(obj) {<br/>  return Object.keys(obj).reduce((acc, key) =&gt; {<br/>    acc[key] = obj[key];<br/>    return acc;<br/>  }, {});<br/>}<br/>const original = { a: 1, b: { c: 3 } };<br/>const copy = shallowCopy(original);</span></pre><p id="4df9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这将创建一个新的对象，并使用Object.keys()方法获取对象自己的属性名数组，使用Array.prototype.reduce()方法迭代数组并将属性复制到新对象中，从而将原始对象自己的属性复制到该对象中。</p><ul class=""><li id="56ea" class="lw lx it js b jt ju jx jy kb ly kf lz kj ma kn mb mc md me bi translated">使用for…in循环:</li></ul><pre class="li lj lk ll gt mf mg mh bn mi mj bi"><span id="e5ca" class="mk ml it mg b be mm mn l mo mp">function shallowCopy(obj) {<br/>  const copy = {};<br/>  for (const key in obj) {<br/>    copy[key] = obj[key];<br/>  }<br/>  return copy;<br/>}<br/>const original = { a: 1, b: { c: 3 } };<br/>const copy = shallowCopy(original);</span></pre><p id="ef7e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这将创建一个新对象，并使用for…in循环将原始对象的自身属性复制到其中。请注意，for…in循环还将迭代继承的属性，因此您可能希望添加一个检查，以便只复制自己的属性，如下所示:</p><pre class="li lj lk ll gt mf mg mh bn mi mj bi"><span id="0259" class="mk ml it mg b be mm mn l mo mp">function shallowCopy(obj) {<br/>  const copy = {};<br/>  for (const key in obj) {<br/>    if (obj.hasOwnProperty(key)) {<br/>      copy[key] = obj[key];<br/>    }<br/>  }<br/>  return copy;<br/>}</span></pre><ul class=""><li id="fcdb" class="lw lx it js b jt ju jx jy kb ly kf lz kj ma kn mb mc md me bi translated">使用Object.entries()和Object.fromEntries()方法:</li></ul><pre class="li lj lk ll gt mf mg mh bn mi mj bi"><span id="ad7e" class="mk ml it mg b be mm mn l mo mp">function shallowCopy(obj) {<br/>  return Object.fromEntries(Object.entries(obj));<br/>}<br/>const original = { a: 1, b: { c: 3 } };<br/>const copy = shallowCopy(original);</span></pre><p id="6bbb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过使用Object.entries()获取对象自身的可枚举属性[key，value]对的数组，然后使用Object.fromEntries()从该数组创建一个对象，从而创建一个新的对象。</p><ul class=""><li id="4e14" class="lw lx it js b jt ju jx jy kb ly kf lz kj ma kn mb mc md me bi translated">使用Object.getOwnPropertyNames()和Object.defineProperties()方法:</li></ul><pre class="li lj lk ll gt mf mg mh bn mi mj bi"><span id="48af" class="mk ml it mg b be mm mn l mo mp">function shallowCopy(obj) {<br/>  const copy = {};<br/>  const propNames = Object.getOwnPropertyNames(obj);<br/>  Object.defineProperties(copy, propNames.map(name =&gt; ({<br/>    [name]: Object.getOwnPropertyDescriptor(obj, name)<br/>  })));<br/>  return copy;<br/>}<br/>const original = { a: 1, b: { c: 3 } };<br/>const copy = shallowCopy(original);</span></pre><p id="b25c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这将创建一个新的对象，并使用Object.getOwnPropertyNames()方法获取对象自己的属性名数组，使用Object.defineProperties()方法定义新对象的属性，将原始对象自己的属性复制到该对象中。</p><ul class=""><li id="4869" class="lw lx it js b jt ju jx jy kb ly kf lz kj ma kn mb mc md me bi translated">使用Object.getOwnPropertyNames()和循环:</li></ul><pre class="li lj lk ll gt mf mg mh bn mi mj bi"><span id="be62" class="mk ml it mg b be mm mn l mo mp">function shallowCopy(obj) {<br/>  const copy = {};<br/>  const propNames = Object.getOwnPropertyNames(obj);<br/>  for (const propName of propNames) {<br/>    copy[propName] = obj[propName];<br/>  }<br/>  return copy;<br/>}<br/>const original = { a: 1, b: { c: 3 } };<br/>const copy = shallowCopy(original);</span></pre><p id="3cdd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这将创建一个新的对象，并使用Object.getOwnPropertyNames()方法将原始对象的自身属性复制到该对象中，以获取该对象自身属性名称的数组和一个循环来迭代该数组并将属性复制到新对象中。</p><ul class=""><li id="aff3" class="lw lx it js b jt ju jx jy kb ly kf lz kj ma kn mb mc md me bi translated">使用Object.getOwnPropertySymbols()和object . getownpropertydescriptors()方法:</li></ul><pre class="li lj lk ll gt mf mg mh bn mi mj bi"><span id="fdad" class="mk ml it mg b be mm mn l mo mp">function shallowCopy(obj) {<br/>  const copy = {};<br/>  const propSymbols = Object.getOwnPropertySymbols(obj);<br/>  const propDescriptors = Object.getOwnPropertyDescriptors(obj);<br/>  for (const propSymbol of propSymbols) {<br/>    copy[propSymbol] = obj[propSymbol];<br/>  }<br/>  return Object.defineProperties(copy, propDescriptors);<br/>}<br/>const original = { a: 1, b: { c: 3 } };<br/>const copy = shallowCopy(original);</span></pre><p id="78e9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这将创建一个新的对象，并使用Object.getOwnPropertySymbols()方法将原始对象自己的符号属性复制到该对象中，以获取该对象自己的符号属性的数组和一个循环，以迭代该数组并将属性复制到新对象中。它还使用object . getownpropertydescriptors()方法和Object.defineProperties()方法将原始对象自己的数据属性复制到新对象中。</p><ul class=""><li id="e70c" class="lw lx it js b jt ju jx jy kb ly kf lz kj ma kn mb mc md me bi translated">使用Reflect.ownKeys()和reflect . getownpropertydescriptor()方法:</li></ul><pre class="li lj lk ll gt mf mg mh bn mi mj bi"><span id="c915" class="mk ml it mg b be mm mn l mo mp">function shallowCopy(obj) {<br/>  const copy = {};<br/>  const propKeys = Reflect.ownKeys(obj);<br/>  for (const propKey of propKeys) {<br/>    copy[propKey] = obj[propKey];<br/>  }<br/>  return Reflect.ownKeys(obj).reduce((acc, key) =&gt; {<br/>    return Reflect.defineProperty(acc, key, Reflect.getOwnPropertyDescriptor(obj, key));<br/>  }, copy);<br/>}<br/>const original = { a: 1, b: { c: 3 } };<br/>const copy = shallowCopy(original);</span></pre><p id="5277" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这将创建一个新的对象，并使用Reflect.ownKeys()方法将原始对象的属性复制到该对象中，以获得该对象自己的属性键数组和一个循环来迭代该数组并将属性复制到新对象中。它还使用reflect . getownpropertydescriptor()和Reflect.defineProperty()方法将原始对象自身属性的属性描述符复制到新对象中。</p><ul class=""><li id="72c1" class="lw lx it js b jt ju jx jy kb ly kf lz kj ma kn mb mc md me bi translated">使用Object.entries()和Object.defineProperties()方法:</li></ul><pre class="li lj lk ll gt mf mg mh bn mi mj bi"><span id="a8bf" class="mk ml it mg b be mm mn l mo mp">function shallowCopy(obj) {<br/>  const copy = {};<br/>  Object.defineProperties(copy, Object.entries(obj).map(([key, value]) =&gt; ({<br/>    [key]: {<br/>      value,<br/>      writable: true,<br/>      enumerable: true,<br/>      configurable: true<br/>    }<br/>   })));<br/>   return copy;<br/>}<br/>const original = { a: 1, b: { c: 3 } };<br/>const copy = shallowCopy(original);</span></pre><p id="ee69" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这将创建一个新对象，并使用Object.entries()方法将原始对象自己的属性复制到该对象中，以获得对象自己的可枚举属性[key，value]对的数组，并使用Object.defineProperties()方法定义新对象的属性。它将属性描述符设置为默认值writable: true、enumerate:true和configurable: true。</p><ul class=""><li id="821e" class="lw lx it js b jt ju jx jy kb ly kf lz kj ma kn mb mc md me bi translated">使用Object.keys()和Object.defineProperties()方法:</li></ul><pre class="li lj lk ll gt mf mg mh bn mi mj bi"><span id="5a68" class="mk ml it mg b be mm mn l mo mp">function shallowCopy(obj) {<br/>  const copy = {};<br/>  Object.defineProperties(copy, Object.keys(obj).map(key =&gt; ({<br/>    [key]: {<br/>      value: obj[key],<br/>      writable: true,<br/>      enumerable: true,<br/>      configurable: true<br/>    }<br/>  })));<br/>  return copy;<br/>}<br/>const original = { a: 1, b: { c: 3 } };<br/>const copy = shallowCopy(original);</span></pre><p id="9b6b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这将创建一个新的对象，并使用Object.keys()方法获取该对象自己的可枚举属性名称数组，使用Object.defineProperties()方法定义新对象的属性，将原始对象自己的属性复制到该对象中。它将属性描述符设置为默认值writable: true、enumerate:true和configurable: true。</p><figure class="li lj lk ll gt lm gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/750133d9577bd1e07bcae69c6dc25e89.png" data-original-src="https://miro.medium.com/v2/resize:fit:354/format:webp/1*5PyVJgcMdPBQy94JSZNyIw.png"/></div></figure><p id="c254" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所有这些方法都创建对象的浅表副本，这意味着如果原始对象包含对其他对象的引用，副本仍将包含对与原始对象相同的对象的引用。如果您想创建一个对象的深层副本，这将创建原始对象引用的所有对象的新副本，请查看我们的下一篇文章。敬请关注。</p><p id="ecd7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你喜欢这个系列，请关注或订阅我们，这样你就不会错过JavaScript克隆传奇的下一部分。愿原力与你同在。</p></div></div>    
</body>
</html>