<html>
<head>
<title>Let’s Utilize the Flutter App Lifecycle</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们利用Flutter应用程序的生命周期</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/lets-utilize-the-flutter-app-lifecycle-388121533fd9?source=collection_archive---------3-----------------------#2021-06-07">https://levelup.gitconnected.com/lets-utilize-the-flutter-app-lifecycle-388121533fd9?source=collection_archive---------3-----------------------#2021-06-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="94b3" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated"><em class="kf">检测移动应用生命周期变化的清晰指南</em></h2></div><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi kg"><img src="../Images/f21a93f8c00a5d200ff1d39bdf4ae9d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*88m7FcgfCHjKVCENPdSJPg.gif"/></div></div></figure><blockquote class="ks kt ku"><p id="0154" class="kv kw kx ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> Flutter </strong>是一个开源的移动框架，用于为Android和iOS创建原生应用。当您处理移动应用程序时，在实现某些功能时了解应用程序的生命周期是很重要的。因此，本文将详细描述Flutter应用程序生命周期方法。</p></blockquote></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h2 id="1b1f" class="lz ma iq bd mb mc md dn me mf mg dp mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">为什么我们需要关注应用程序的生命周期？</h2><p id="e91b" class="pw-post-body-paragraph kv kw iq ky b kz mv jr lb lc mw ju le mi mx lh li mm my ll lm mq mz lp lq lr ij bi translated">实际上，在处理移动应用程序时，有一些主要的问题，比如某个特定的应用程序是在后台还是前台运行。因此，这可以很容易地处理颤振<a class="ae na" href="https://api.flutter.dev/flutter/dart-ui/AppLifecycleState-class.html" rel="noopener ugc nofollow" target="_blank"> <em class="kx">应用周期状态</em> </a>和4个主要的生命周期状态:</p><p id="4980" class="pw-post-body-paragraph kv kw iq ky b kz la jr lb lc ld ju le mi lg lh li mm lk ll lm mq lo lp lq lr ij bi translated"><strong class="ky ir">分离的</strong> →固定的<a class="ae na" href="https://api.flutter.dev/flutter/dart-ui/AppLifecycleState-class.html" rel="noopener ugc nofollow" target="_blank">应用循环地产</a>:</p><p id="ab14" class="pw-post-body-paragraph kv kw iq ky b kz la jr lb lc ld ju le mi lg lh li mm lk ll lm mq lo lp lq lr ij bi translated">如果一个应用程序处于这种状态，颤振引擎正在运行，但我们看不到视图。简单假设手机里有任何app但是你没有打开。因此，如果应用程序托管在flutter引擎中，它将从任何主机视图中分离出来。</p><p id="0b50" class="pw-post-body-paragraph kv kw iq ky b kz la jr lb lc ld ju le mi lg lh li mm lk ll lm mq lo lp lq lr ij bi translated"><strong class="ky ir">无效</strong> →常量<a class="ae na" href="https://api.flutter.dev/flutter/dart-ui/AppLifecycleState-class.html" rel="noopener ugc nofollow" target="_blank">应用循环属性</a>:</p><p id="ca83" class="pw-post-body-paragraph kv kw iq ky b kz la jr lb lc ld ju le mi lg lh li mm lk ll lm mq lo lp lq lr ij bi translated">如果应用程序处于这种状态，它不会接收用户输入。简单来说，我们可以说这个应用程序在前台，而不是在你的手机后台运行。例如，如果我们按下后退按钮并移动到一个新的应用程序，那么之前工作的应用程序将进入前台非活动状态，并且不会接收用户输入。因此，状态中的应用程序应该假设它们可以随时暂停。</p><p id="4b26" class="pw-post-body-paragraph kv kw iq ky b kz la jr lb lc ld ju le mi lg lh li mm lk ll lm mq lo lp lq lr ij bi translated"><strong class="ky ir">暂停</strong> →常量<a class="ae na" href="https://api.flutter.dev/flutter/dart-ui/AppLifecycleState-class.html" rel="noopener ugc nofollow" target="_blank">应用循环属性</a>:</p><p id="4247" class="pw-post-body-paragraph kv kw iq ky b kz la jr lb lc ld ju le mi lg lh li mm lk ll lm mq lo lp lq lr ij bi translated">如果应用程序处于这种状态，它对用户是不可见的，并且不响应用户输入。但是需要注意的是，它是在后台运行的。举个例子，假设你在脸书，你从WhatsApp收到一个通知，然后你点击那个聊天通知，进入WhatsApp。在这种情况下，脸书处于暂停状态，它在后台运行，但对用户不可见。</p><p id="c02a" class="pw-post-body-paragraph kv kw iq ky b kz la jr lb lc ld ju le mi lg lh li mm lk ll lm mq lo lp lq lr ij bi translated"><strong class="ky ir">恢复</strong> → const <a class="ae na" href="https://api.flutter.dev/flutter/dart-ui/AppLifecycleState-class.html" rel="noopener ugc nofollow" target="_blank">应用循环地产</a>:</p><p id="cc8f" class="pw-post-body-paragraph kv kw iq ky b kz la jr lb lc ld ju le mi lg lh li mm lk ll lm mq lo lp lq lr ij bi translated">如果应用程序处于这种状态，它会响应用户的输入，并在后台显示应用程序。假设您正在使用WhatsApp即时消息。</p><p id="e2af" class="pw-post-body-paragraph kv kw iq ky b kz la jr lb lc ld ju le mi lg lh li mm lk ll lm mq lo lp lq lr ij bi translated">现在，我想你可以对应用程序的生命周期有一个清晰的概念，然后让我们来看代码实现。</p><p id="969d" class="pw-post-body-paragraph kv kw iq ky b kz la jr lb lc ld ju le mi lg lh li mm lk ll lm mq lo lp lq lr ij bi translated">1.创建一个演示应用程序。</p><p id="7c87" class="pw-post-body-paragraph kv kw iq ky b kz la jr lb lc ld ju le mi lg lh li mm lk ll lm mq lo lp lq lr ij bi translated">2.创建StatefulWidget和WidgetsBinindingObserver</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi nb"><img src="../Images/7411991e3e147bd25c2c19768920d810.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*viBTDnvFPxPmDgE6MrzZVw.jpeg"/></div></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated">StatefulWidget和WidgetsBinindingObserver</figcaption></figure><p id="0a6d" class="pw-post-body-paragraph kv kw iq ky b kz la jr lb lc ld ju le mi lg lh li mm lk ll lm mq lo lp lq lr ij bi translated">3.然后，您需要分别使用addObserver方法和removeObserver方法添加和删除观察器来管理观察器:</p><p id="fcf9" class="pw-post-body-paragraph kv kw iq ky b kz la jr lb lc ld ju le mi lg lh li mm lk ll lm mq lo lp lq lr ij bi translated">initState(): 这是创建小部件时调用的第一个方法(当然是在类构造函数之后。)initState被调用一次，且只能调用一次。它必须调用super.initState()。</p><p id="9074" class="pw-post-body-paragraph kv kw iq ky b kz la jr lb lc ld ju le mi lg lh li mm lk ll lm mq lo lp lq lr ij bi translated"><strong class="ky ir"> dispose(): </strong> dispose()在状态对象被移除时被调用，是永久的。这种方法是你应该退订和取消所有动画，流等。</p><p id="d850" class="pw-post-body-paragraph kv kw iq ky b kz la jr lb lc ld ju le mi lg lh li mm lk ll lm mq lo lp lq lr ij bi translated"><strong class="ky ir"> deactivate() </strong>:从树中移除状态时调用。这种方法的存在基本上是因为状态对象可以从树中的一点移动到另一点。</p><p id="0b60" class="pw-post-body-paragraph kv kw iq ky b kz la jr lb lc ld ju le mi lg lh li mm lk ll lm mq lo lp lq lr ij bi translated">setState() :经常从Flutter框架本身和开发者那里调用。它用于通知框架“数据已经更改”，并且应该重新构建该构建上下文中的小部件。</p><p id="b01f" class="pw-post-body-paragraph kv kw iq ky b kz la jr lb lc ld ju le mi lg lh li mm lk ll lm mq lo lp lq lr ij bi translated"><a class="ae na" href="https://www.bookstack.cn/read/flutterbyexample/aebe8dda4df3319f.md" rel="noopener ugc nofollow" target="_blank"> <em class="kx">参见更多</em> </a> <em class="kx"> …..</em></p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi ng"><img src="../Images/3af102cb86b8a9a452097ba4f723477d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6ARyd6ayy0yQsnbBrajPNw.png"/></div></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated">作者图片</figcaption></figure><p id="f671" class="pw-post-body-paragraph kv kw iq ky b kz la jr lb lc ld ju le mi lg lh li mm lk ll lm mq lo lp lq lr ij bi translated">4.创建didChangeAppLifecycleState，它将AppLifecycleState作为对象参数，用于检查应用程序生命周期中的各种状态。当[State]对象的依赖关系改变时，调用didChangeAppLifecycleState。</p><p id="2dca" class="pw-post-body-paragraph kv kw iq ky b kz la jr lb lc ld ju le mi lg lh li mm lk ll lm mq lo lp lq lr ij bi translated">此外，第一次构建小部件时，会在initState之后立即调用didChangeAppLifecycleState。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi nh"><img src="../Images/bacb3c08727fb4ea36f41ad4a1db5034.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BoSgrbkufVjkDrqqcX8MBA.png"/></div></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated">didChangeAppLifecycleState方法</figcaption></figure><p id="ce3e" class="pw-post-body-paragraph kv kw iq ky b kz la jr lb lc ld ju le mi lg lh li mm lk ll lm mq lo lp lq lr ij bi translated">5.您用于检测应用生命周期变化的应用现已准备就绪。完整的代码实现如下。</p><pre class="kh ki kj kk gt ni nj nk nl aw nm bi"><span id="3353" class="lz ma iq nj b gy nn no l np nq">import 'package:flutter/material.dart';</span><span id="a498" class="lz ma iq nj b gy nr no l np nq">void main() {<br/>  runApp(MyApp());<br/>}</span><span id="1166" class="lz ma iq nj b gy nr no l np nq">class MyApp extends StatelessWidget {<br/>  <a class="ae na" href="http://twitter.com/override" rel="noopener ugc nofollow" target="_blank">@override</a><br/>  Widget build(BuildContext context) {<br/>    return MaterialApp(<br/>      title: 'Flutter Demo',<br/>      theme: ThemeData(<br/>        primarySwatch: Colors.blue,<br/>      ),<br/>      home: MyHomePage(title: 'Flutter Demo Home Page'),<br/>    );<br/>  }<br/>}</span><span id="b5d5" class="lz ma iq nj b gy nr no l np nq">class MyHomePage extends StatefulWidget {<br/>  MyHomePage({Key key, this.title}) : super(key: key);</span><span id="c861" class="lz ma iq nj b gy nr no l np nq">final String title;</span><span id="6894" class="lz ma iq nj b gy nr no l np nq"><a class="ae na" href="http://twitter.com/override" rel="noopener ugc nofollow" target="_blank">@override</a><br/>  _MyHomePageState createState() =&gt; _MyHomePageState();<br/>}</span><span id="5203" class="lz ma iq nj b gy nr no l np nq">class _MyHomePageState extends State&lt;MyHomePage&gt; with WidgetsBindingObserver {<br/>  int _counter = 0;</span><span id="8607" class="lz ma iq nj b gy nr no l np nq">void _incrementCounter() {<br/>    setState(() {<br/>      _counter++;<br/>    });<br/>  }</span><span id="eebd" class="lz ma iq nj b gy nr no l np nq"><a class="ae na" href="http://twitter.com/override" rel="noopener ugc nofollow" target="_blank">@override</a><br/>  void initState() {<br/>    super.initState();<br/>    WidgetsBinding.instance.addObserver(this);<br/>    print("InitState");<br/>  }</span><span id="6a1f" class="lz ma iq nj b gy nr no l np nq"><a class="ae na" href="http://twitter.com/override" rel="noopener ugc nofollow" target="_blank">@override</a><br/>  void didChangeDependencies() {<br/>    super.didChangeDependencies();<br/>    print("DidChangeDependencies");<br/>  }</span><span id="31ac" class="lz ma iq nj b gy nr no l np nq"><a class="ae na" href="http://twitter.com/override" rel="noopener ugc nofollow" target="_blank">@override</a><br/>  void setState(fn) {<br/>    print("SetState");<br/>    super.setState(fn);<br/>  }</span><span id="427f" class="lz ma iq nj b gy nr no l np nq"><a class="ae na" href="http://twitter.com/override" rel="noopener ugc nofollow" target="_blank">@override</a><br/>  void deactivate() {<br/>    print("Deactivate");<br/>    super.deactivate();<br/>  }</span><span id="4495" class="lz ma iq nj b gy nr no l np nq"><a class="ae na" href="http://twitter.com/override" rel="noopener ugc nofollow" target="_blank">@override</a><br/>  void dispose() {<br/>    print("Dispose");<br/>    super.dispose();<br/>    WidgetsBinding.instance.removeObserver(this);<br/>  }</span><span id="1d70" class="lz ma iq nj b gy nr no l np nq"><a class="ae na" href="http://twitter.com/override" rel="noopener ugc nofollow" target="_blank">@override</a><br/>  void didChangeAppLifecycleState(AppLifecycleState state) {<br/>    super.didChangeAppLifecycleState(state);<br/>    switch (state) {<br/>      case AppLifecycleState.inactive:<br/>        print('appLifeCycleState inactive');<br/>        break;<br/>      case AppLifecycleState.resumed:<br/>        print('appLifeCycleState resumed');<br/>        break;<br/>      case AppLifecycleState.paused:<br/>        print('appLifeCycleState paused');<br/>        break;<br/>      case AppLifecycleState.detached:<br/>        print('appLifeCycleState detached');<br/>        break;<br/>    }<br/>  }</span><span id="010e" class="lz ma iq nj b gy nr no l np nq"><a class="ae na" href="http://twitter.com/override" rel="noopener ugc nofollow" target="_blank">@override</a><br/>  Widget build(BuildContext context) {<br/>    return Scaffold(<br/>      appBar: AppBar(<br/>        title: Text(widget.title),<br/>      ),<br/>      body: Center(<br/>        child: Column(<br/>          mainAxisAlignment: MainAxisAlignment.center,<br/>          children: &lt;Widget&gt;[<br/>            Text(<br/>              'You have pushed the button this many times:',<br/>            ),<br/>            Text(<br/>              '$_counter',<br/>              style: Theme.of(context).textTheme.headline4,<br/>            ),<br/>          ],<br/>        ),<br/>      ),<br/>      floatingActionButton: FloatingActionButton(<br/>        onPressed: _incrementCounter,<br/>        tooltip: 'Increment',<br/>        child: Icon(Icons.add),<br/>      ),<br/>    );<br/>  }<br/>}</span></pre><p id="6459" class="pw-post-body-paragraph kv kw iq ky b kz la jr lb lc ld ju le mi lg lh li mm lk ll lm mq lo lp lq lr ij bi translated">6.您可以运行您的应用程序，并观察应用程序生命周期的变化。生命周期变更的示例片段如下:</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi ns"><img src="../Images/f054e930851f16c6c64d7e95cd92c6af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*We8wfaHUwRzGCFjBaHMXxQ.png"/></div></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk translated">作者图片</figcaption></figure><p id="90cf" class="pw-post-body-paragraph kv kw iq ky b kz la jr lb lc ld ju le mi lg lh li mm lk ll lm mq lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="kx">结论</em> </strong></p><blockquote class="ks kt ku"><p id="fe46" class="kv kw kx ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">检测应用程序生命周期是一种简单的方法，但当您处理移动应用程序以及需要实现一些特殊的本机应用程序相关开发时，这种方法非常有用。</p></blockquote><h2 id="9da0" class="lz ma iq bd mb mc md dn me mf mg dp mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">感谢你阅读这篇文章，如果你喜欢这篇文章或者学到了新的东西，尽可能多的鼓掌来表示你的支持。🙌😎</h2></div></div>    
</body>
</html>