<html>
<head>
<title>A Practical Guide to JWT Authentication with NodeJS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">NodeJS JWT认证实用指南</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/a-practical-guide-to-jwt-authentication-with-nodejs-e0e425376733?source=collection_archive---------8-----------------------#2020-08-12">https://levelup.gitconnected.com/a-practical-guide-to-jwt-authentication-with-nodejs-e0e425376733?source=collection_archive---------8-----------------------#2020-08-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="9bb4" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">更好的编程</h2><div class=""/><div class=""><h2 id="074d" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">为下一个NodeJS应用程序构建一个身份验证模块</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/dc9fedc61f6addb8a38d5ad4d8659da0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q5w0UP51Y3aldUmB7mx2Fw.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">由<a class="ae lh" href="https://unsplash.com/@wesleyphotography?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">韦斯利·廷吉</a>在<a class="ae lh" href="https://unsplash.com/s/photos/private-property?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="819a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">您是否尝试过将JWT身份验证集成到Node.js应用程序中，但始终没有找到正确的解决方案？那你来对地方了。在这篇文章中，我们将带您了解Node.js中使用npm包<code class="fe me mf mg mh b">jsonwebtoken</code>的JWT认证的更详细的细节。</p><div class="mi mj gp gr mk ml"><a rel="noopener  ugc nofollow" target="_blank" href="/a-brief-introduction-to-securing-applications-with-jwt-2004e9f6c829"><div class="mm ab fo"><div class="mn ab mo cl cj mp"><h2 class="bd jd gy z fp mq fr fs mr fu fw jc bi translated">用JWT保护应用程序的简介</h2><div class="ms l"><h3 class="bd b gy z fp mq fr fs mr fu fw dk translated">了解什么是JWT，它是如何工作的，以及它如何保护我们的应用程序的安全。</h3></div><div class="mt l"><p class="bd b dl z fp mq fr fs mr fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="mu l"><div class="mv l mw mx my mu mz lb ml"/></div></div></a></div><p id="5132" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果您仍然不确定JWT到底是什么以及它是如何工作的，您可以在继续实现之前关注我们之前的帖子。正如我们在上一篇文章中所讨论的，在这个实现中，我们将遵循JWT身份验证的最佳实践。如果您想先回忆一下JWTs，让我们来看看在本教程中我们将遵循哪些最佳实践。</p><ul class=""><li id="758e" class="na nb it lk b ll lm lo lp lr nc lv nd lz ne md nf ng nh ni bi translated">发送cookie中的JWT令牌，而不是HTTP头</li><li id="86ac" class="na nb it lk b ll nj lo nk lr nl lv nm lz nn md nf ng nh ni bi translated">为令牌设置较短的过期时间</li><li id="5a73" class="na nb it lk b ll nj lo nk lr nl lv nm lz nn md nf ng nh ni bi translated">使用刷新令牌来重新颁发即将到期的访问令牌</li></ul><p id="71fb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在进入细节之前，我想强调两点:</p><ul class=""><li id="a962" class="na nb it lk b ll lm lo lp lr nc lv nd lz ne md nf ng nh ni bi translated">为身份验证编写自己的实现并不总是最好的解决方案。有几个第三方产品可以以非常安全的方式为您处理所有这一切。</li><li id="514c" class="na nb it lk b ll nj lo nk lr nl lv nm lz nn md nf ng nh ni bi translated">本教程中介绍的代码是一个monolith应用程序的实现。如果您想将此代码用于微服务，您必须使用公钥/私钥组合来签名和验证令牌。</li></ul><p id="c40d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">既然我们已经设定了目标，让我们开始实施吧。</p></div><div class="ab cl no np hx nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="im in io ip iq"><h1 id="4c28" class="nv nw it bd nx ny nz oa ob oc od oe of ki og kj oh kl oi km oj ko ok kp ol om bi translated">初始准备工作…</h1><p id="86f3" class="pw-post-body-paragraph li lj it lk b ll on kd ln lo oo kg lq lr op lt lu lv oq lx ly lz or mb mc md im bi translated">如果您还没有为这个项目设置节点环境。然后，安装我们将在本教程中使用的以下软件包。</p><ul class=""><li id="46c8" class="na nb it lk b ll lm lo lp lr nc lv nd lz ne md nf ng nh ni bi translated">Express:我们将使用的Node.js框架</li><li id="7aa5" class="na nb it lk b ll nj lo nk lr nl lv nm lz nn md nf ng nh ni bi translated">Cookie-Parser:因为我们将在Cookie中发送JWT令牌，所以使用这个包来解析随请求一起发送的cookie</li><li id="e99c" class="na nb it lk b ll nj lo nk lr nl lv nm lz nn md nf ng nh ni bi translated">Body-Parser:这个包解析传入请求的主体，以提取POST参数</li><li id="d21d" class="na nb it lk b ll nj lo nk lr nl lv nm lz nn md nf ng nh ni bi translated">Dotenv:这个包从。应用程序环境的env文件</li><li id="9142" class="na nb it lk b ll nj lo nk lr nl lv nm lz nn md nf ng nh ni bi translated">Json-Web-Token:这是帮助我们实现JWT的包</li></ul><p id="cb9f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">您可以使用以下命令安装这些软件包。</p><pre class="ks kt ku kv gt os mh ot ou aw ov bi"><span id="086b" class="ow nw it mh b gy ox oy l oz pa">npm install express cookie-parser bory-parser dotenv json-web-token --save</span></pre><p id="c854" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在我们将在项目的主文件<code class="fe me mf mg mh b">app.js</code>中设置应用程序的后端。</p><pre class="ks kt ku kv gt os mh ot ou aw ov bi"><span id="77e1" class="ow nw it mh b gy ox oy l oz pa">require('dotenv').config()<br/>const express = require('express')<br/>const bodyParser = require('body-parser')<br/>const cookieParser = require('cookie-parser')<br/>const app = express()</span><span id="97f9" class="ow nw it mh b gy pb oy l oz pa">const {login, refresh} = require('./authentication')<br/>app.use(bodyParser.json())<br/>app.use(cookieParser())</span><span id="4d8a" class="ow nw it mh b gy pb oy l oz pa">app.post('/login', login)<br/>app.post('/refrsh', refresh)</span></pre><p id="c110" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在接下来的步骤中，我们将在controller.js中实现我们在上面的代码中使用过的函数。我们使用login函数来处理发送到/login路由和登录用户的post请求。我们使用刷新函数来处理发送到/refresh路由的post请求，并使用刷新令牌发布新的访问令牌。</p></div><div class="ab cl no np hx nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="im in io ip iq"><h1 id="d6a1" class="nv nw it bd nx ny nz oa ob oc od oe of ki og kj oh kl oi km oj ko ok kp ol om bi translated">设置环境变量</h1><p id="a452" class="pw-post-body-paragraph li lj it lk b ll on kd ln lo oo kg lq lr op lt lu lv oq lx ly lz or mb mc md im bi translated">在实现让用户登录的逻辑之前，我们需要设置配置jwt所需的环境变量。创建一个. env文件，并添加我们将在应用程序中使用的这两个变量。</p><pre class="ks kt ku kv gt os mh ot ou aw ov bi"><span id="e0b7" class="ow nw it mh b gy ox oy l oz pa">ACCESS_TOKEN_SECRET=swsh23hjddnns<br/>ACCESS_TOKEN_LIFE=120<br/>REFRESH_TOKEN_SECRET=dhw782wujnd99ahmmakhanjkajikhiwn2n<br/>REFRESH_TOKEN_LIFE=86400</span></pre><p id="2de0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">您可以添加任何字符串作为密码。建议使用带有随机字符的较长密码作为安全措施。我们创建的访问令牌的到期时间将是120秒。我们还设置了签名刷新令牌的秘密及其到期时间。请注意，与访问令牌相比，刷新令牌的生存期更长。</p></div><div class="ab cl no np hx nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="im in io ip iq"><h1 id="3784" class="nv nw it bd nx ny nz oa ob oc od oe of ki og kj oh kl oi km oj ko ok kp ol om bi translated">处理用户登录和JWT令牌创建</h1><p id="3098" class="pw-post-body-paragraph li lj it lk b ll on kd ln lo oo kg lq lr op lt lu lv oq lx ly lz or mb mc md im bi translated">现在我们可以进入实现登录函数的步骤，我们将该函数导入到<code class="fe me mf mg mh b">app.js</code>文件来处理<code class="fe me mf mg mh b">/login</code>路由。</p><p id="5e83" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了实现这个目的，我们将在应用程序中存储一个用户对象数组。在真实的场景中，您将从数据库或任何其他位置检索这些用户信息。另外，这只是为了演示，<strong class="lk jd">从来没有</strong>存储实际的密码。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi pc"><img src="../Images/344ae7b1b4d963ca601696ab06f91349.png" data-original-src="https://miro.medium.com/v2/resize:fit:1006/format:webp/1*NGGHVJau2Q9v3LhY-02NVw.jpeg"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">不要以纯文本格式保存密码</figcaption></figure><pre class="ks kt ku kv gt os mh ot ou aw ov bi"><span id="ee48" class="ow nw it mh b gy ox oy l oz pa">let users = {<br/>    john: {password: "passwordjohn"},<br/>    mary: {password:"passwordmary"}<br/>}</span></pre><p id="6c36" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当实现登录功能时，首先我们需要检索与登录POST请求一起发送的用户名和密码。</p><pre class="ks kt ku kv gt os mh ot ou aw ov bi"><span id="6412" class="ow nw it mh b gy ox oy l oz pa">const jwt = require('json-web-token')</span><span id="6664" class="ow nw it mh b gy pb oy l oz pa">// Never do this!<br/>let users = {<br/>    john: {password: "passwordjohn"},<br/>    mary: {password:"passwordmary"}<br/>}</span><span id="6975" class="ow nw it mh b gy pb oy l oz pa">exports.login = function(req, res){</span><span id="b503" class="ow nw it mh b gy pb oy l oz pa">    let username = req.body.username<br/>    let password = req.body.password<br/>    <br/>    // Neither do this!<br/>    if (!username || !password || users[username] !== password){<br/>        return res.status(401).send()<br/>    }    <br/>}</span></pre><p id="8dc4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果请求不包含用户名或密码，服务器将以401未授权状态响应。如果与请求一起发送的密码与存储在数据库中的该特定用户名的密码不匹配，则应用相同的响应。</p><p id="7346" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果客户端已经向服务器发送了正确的凭据，那么我们将通过颁发新的JWT令牌让用户登录系统。在这种情况下，新登录用户会收到两个令牌:访问令牌和刷新令牌。然后，访问令牌与cookie中的响应一起发送回客户端。刷新令牌存储在数据库中，用于将来发布访问令牌。在我们的例子中，我们将把刷新令牌存储在之前创建的用户数组中。</p><pre class="ks kt ku kv gt os mh ot ou aw ov bi"><span id="5a81" class="ow nw it mh b gy ox oy l oz pa">const jwt = require('json-web-token')</span><span id="8ef4" class="ow nw it mh b gy pb oy l oz pa">// Never do this!<br/>let users = {<br/>    john: {password: "passwordjohn"},<br/>    mary: {password:"passwordmary"}<br/>}</span><span id="9693" class="ow nw it mh b gy pb oy l oz pa">exports.login = function(req, res){</span><span id="f5fd" class="ow nw it mh b gy pb oy l oz pa">    let username = req.body.username<br/>    let password = req.body.password<br/>    <br/>    // Neither do this!<br/>    if (!username || !password || users[username].password !== password){<br/>        return res.status(401).send()<br/>    }</span><span id="6eb7" class="ow nw it mh b gy pb oy l oz pa">    //use the payload to store information about the user such as username, user role, etc.<br/>    let payload = {username: username}</span><span id="ec06" class="ow nw it mh b gy pb oy l oz pa">    //create the access token with the shorter lifespan<br/>    let accessToken = jwt.sign(payload, process.env.ACCESS_TOKEN_SECRET, {<br/>        algorithm: "HS256",<br/>        expiresIn: process.env.ACCESS_TOKEN_LIFE<br/>    })</span><span id="e0fd" class="ow nw it mh b gy pb oy l oz pa">    //create the refresh token with the longer lifespan<br/>    let refreshToken = jwt.sign(payload, process.env.REFRESH_TOKEN_LIFE, {<br/>        algorithm: "HS256",<br/>        expiresIn: process.env.REFRESH_TOKEN_LIFE<br/>    })</span><span id="dea9" class="ow nw it mh b gy pb oy l oz pa">    //store the refresh token in the user array<br/>    users[username].refreshToken = refreshToken</span><span id="4ef9" class="ow nw it mh b gy pb oy l oz pa">    //send the access token to the client inside a cookie<br/>    res.cookie("jwt", accessToken, {secure: true, httpOnly: true})<br/>    res.send()<br/>}</span></pre><p id="81cc" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当在cookie中发送访问令牌时，记得设置httpOnly标志以防止攻击者从客户端访问cookie。我们还在上面的例子中设置了安全标志。但是，如果您只是通过HTTP连接而不是HTTPS连接来测试这段代码，那么请移除安全标志，将其与响应一起发送。</p></div><div class="ab cl no np hx nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="im in io ip iq"><h1 id="70bb" class="nv nw it bd nx ny nz oa ob oc od oe of ki og kj oh kl oi km oj ko ok kp ol om bi translated">添加中间件来验证用户请求</h1><p id="9646" class="pw-post-body-paragraph li lj it lk b ll on kd ln lo oo kg lq lr op lt lu lv oq lx ly lz or mb mc md im bi translated">服务器需要检查用户是否已经登录，然后才允许访问某些路由。我们可以使用每个请求在cookie中发送的访问令牌来验证用户实际上已经过身份验证。这个过程是在中间件中执行的。</p><p id="78ae" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们创建一个名为<code class="fe me mf mg mh b">middleware.js</code>的新文件，并实现verify方法来检查用户是否经过身份验证。</p><p id="b037" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">首先，我们应该从随请求发送的cookie中检索访问令牌。如果请求不包含访问令牌，它将不会前进到预定的路由，而是返回403禁止错误。</p><pre class="ks kt ku kv gt os mh ot ou aw ov bi"><span id="80fa" class="ow nw it mh b gy ox oy l oz pa">const jwt = require('json-web-token')</span><span id="2fa3" class="ow nw it mh b gy pb oy l oz pa">exports.verify = function(req, res, next){<br/>    let accessToken = req.cookies.jwt</span><span id="d409" class="ow nw it mh b gy pb oy l oz pa">    //if there is no token stored in cookies, the request is unauthorized<br/>    if (!accessToken){<br/>        return res.status(403).send()<br/>    }<br/>}</span></pre><p id="41cb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果请求包含访问令牌，那么服务器将使用存储的秘密来验证它是否是由服务器本身发出的。如果令牌过期或被识别为未经服务器签名的令牌，jsonwebtoken的verify方法将抛出一个错误。我们可以处理这个错误，向客户端返回一个401错误。</p><pre class="ks kt ku kv gt os mh ot ou aw ov bi"><span id="a773" class="ow nw it mh b gy ox oy l oz pa">const jwt = require('json-web-token')</span><span id="2679" class="ow nw it mh b gy pb oy l oz pa">exports.verify = function(req, res, next){<br/>    let accessToken = req.cookies.jwt</span><span id="317a" class="ow nw it mh b gy pb oy l oz pa">    //if there is no token stored in cookies, the request is unauthorized<br/>    if (!accessToken){<br/>        return res.status(403).send()<br/>    }</span><span id="3490" class="ow nw it mh b gy pb oy l oz pa">    let payload<br/>    try{<br/>        //use the jwt.verify method to verify the access token<br/>        //throws an error if the token has expired or has a invalid signature<br/>        payload = jwt.verify(accessToken, process.env.ACCESS_TOKEN_SECRET)<br/>        next()<br/>    }<br/>    catch(e){<br/>        //if an error occured return request unauthorized error<br/>        return res.status(401).send()<br/>    }<br/>}</span></pre><p id="dc09" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，我们可以使用这个中间件来保护任何需要用户在访问之前登录的路由。将中间件导入到您正在处理路由的地方，在我们的例子中是<code class="fe me mf mg mh b">app.js</code>。如果我们试图保护一个名为/comments的路由，可以通过在路由处理器之前添加中间件来轻松实现。</p><pre class="ks kt ku kv gt os mh ot ou aw ov bi"><span id="2fff" class="ow nw it mh b gy ox oy l oz pa">const {verify} = require('./middleware')</span><span id="5c6b" class="ow nw it mh b gy pb oy l oz pa">app.get('/comments', verify, routeHandler)</span></pre><p id="9e71" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">只有当用户通过身份验证时，请求才会被传递到路由处理程序。</p></div><div class="ab cl no np hx nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="im in io ip iq"><h1 id="da01" class="nv nw it bd nx ny nz oa ob oc od oe of ki og kj oh kl oi km oj ko ok kp ol om bi translated">使用刷新令牌发布新的访问令牌</h1><p id="f773" class="pw-post-body-paragraph li lj it lk b ll on kd ln lo oo kg lq lr op lt lu lv oq lx ly lz or mb mc md im bi translated">还记得我们在<code class="fe me mf mg mh b">app.js</code>文件的初始代码中使用的/refresh route和refresh函数吗？现在，我们可以实现这个刷新功能，使用存储的刷新令牌发布新的访问令牌。</p><p id="a08a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这里使用的函数refresh也在我们之前用于登录函数实现的<code class="fe me mf mg mh b">controller.js</code>文件中。</p><p id="35e2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这个函数的第一部分非常类似于我们验证访问令牌的工作:检查访问令牌是否被发送并验证令牌。</p><pre class="ks kt ku kv gt os mh ot ou aw ov bi"><span id="3c20" class="ow nw it mh b gy ox oy l oz pa">exports.refresh = function (req, res){</span><span id="c699" class="ow nw it mh b gy pb oy l oz pa">    let accessToken = req.cookies.jwt</span><span id="60f5" class="ow nw it mh b gy pb oy l oz pa">    if (!accessToken){<br/>        return res.status(403).send()<br/>    }</span><span id="0c70" class="ow nw it mh b gy pb oy l oz pa">    let payload<br/>    try{<br/>        payload = jwt.verify(accessToken, process.env.ACCESS_TOKEN_SECRET)<br/>    }<br/>    catch(e){<br/>        return res.status(401).send()<br/>    }<br/>}</span></pre><p id="e10c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">然后，我们将使用存储在访问令牌有效负载中的用户名来检索这个特定用户的刷新令牌。一旦刷新令牌被验证，服务器将发布新的访问令牌，如登录功能中所实现的。</p><p id="01bd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果刷新令牌过期或验证失败，服务器将返回未经授权的错误。否则，将在cookie中发送新的访问令牌。</p><pre class="ks kt ku kv gt os mh ot ou aw ov bi"><span id="2653" class="ow nw it mh b gy ox oy l oz pa">exports.refresh = function (req, res){</span><span id="587c" class="ow nw it mh b gy pb oy l oz pa">    let accessToken = req.cookies.jwt</span><span id="5a57" class="ow nw it mh b gy pb oy l oz pa">    if (!accessToken){<br/>        return res.status(403).send()<br/>    }</span><span id="e0a6" class="ow nw it mh b gy pb oy l oz pa">    let payload<br/>    try{<br/>        payload = jwt.verify(accessToken, process.env.ACCESS_TOKEN_SECRET)<br/>     }<br/>    catch(e){<br/>        return res.status(401).send()<br/>    }</span><span id="28f1" class="ow nw it mh b gy pb oy l oz pa">    //retrieve the refresh token from the users array<br/>    let refreshToken = users[payload.username].refreshToken</span><span id="b3f9" class="ow nw it mh b gy pb oy l oz pa">    //verify the refresh token<br/>    try{<br/>        jwt.verify(refreshToken, process.env.REFRESH_TOKEN_SECRET)<br/>    }<br/>    catch(e){<br/>        return res.status(401).send()<br/>    }</span><span id="7b77" class="ow nw it mh b gy pb oy l oz pa">    let newToken = jwt.sign(payload, process.env.ACCESS_TOKEN_SECRET, <br/>    {<br/>        algorithm: "HS256",<br/>        expiresIn: process.env.ACCESS_TOKEN_LIFE<br/>    })</span><span id="51ef" class="ow nw it mh b gy pb oy l oz pa">    res.cookie("jwt", newToken, {secure: true, httpOnly: true})<br/>    res.send()<br/>}</span></pre><p id="6848" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这一步完成了我们使用Node.js的JWT认证的实现</p></div><div class="ab cl no np hx nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="im in io ip iq"><h1 id="1a1c" class="nv nw it bd nx ny nz oa ob oc od oe of ki og kj oh kl oi km oj ko ok kp ol om bi translated">摘要</h1><p id="472e" class="pw-post-body-paragraph li lj it lk b ll on kd ln lo oo kg lq lr op lt lu lv oq lx ly lz or mb mc md im bi translated">在本教程中，我们介绍了在Node.js中使用JWT实现身份验证的步骤。作为上一篇文章的延续，我们讨论了JWT身份验证背后的理论，我们的实现侧重于遵循我们之前讨论的最佳实践。因此，我们的JWT实现利用cookies来发送jwt并刷新令牌以生成新的访问令牌。如果您愿意在这一实现之前先行一步，您可以提出一个解决方案，在短时间内重新发布刷新令牌，以避免安全漏洞。</p><p id="1e01" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">感谢阅读！</p></div></div>    
</body>
</html>