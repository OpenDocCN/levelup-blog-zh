<html>
<head>
<title>Stop Filling Your Tests With Test Data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">停止用测试数据填充你的测试</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/stop-filling-your-tests-with-test-data-4eaa151bfe31?source=collection_archive---------2-----------------------#2019-09-20">https://levelup.gitconnected.com/stop-filling-your-tests-with-test-data-4eaa151bfe31?source=collection_archive---------2-----------------------#2019-09-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a7aa" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">用更少的代码使你的测试更具描述性</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/bc7a29da5d91c98a3fb250f127083d35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*w1jqEyhBPY3Krw38"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@markusspiske?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">马库斯·斯皮斯克</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="4f6e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我交谈过的大多数开发人员都同意测试是有价值的，他们应该编写更多的测试。即使没有编写测试的开发人员也很少质疑这样做的价值。但是偶尔我会和不喜欢考试的人聊天。我经常听到这样的抱怨:</p><blockquote class="lv lw lx"><p id="13b3" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">"但是对于我写的每10行代码，我需要20行测试！"</p></blockquote><p id="6020" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">习惯它吧，因为如果你在特性中写的代码比在测试中写的多，你可能就没有写足够多的测试。</p><p id="ccec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我也不是指测试数据——我是指设置和断言。你的测试数据应该简短明了。不幸的是，这种情况很少发生，我经常在一个规范文件的顶部看到人工管理的测试数据。这里有一个相当人为的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mc md l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">客户服务规范</figcaption></figure><p id="8330" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个非常简短的规范文件的54行中，有38行是测试数据。现在，有人可能会说，单个测试的问题要严重得多，这是真的——如果我编写更多的测试，我可能会重用这些数据。</p><p id="e569" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是我经常发现自己编写使用相同数据结构的多个组件，这意味着我仍然必须为每个规范文件编写一次。如果我将测试数据移动到它自己的文件中，我现在必须开始管理一组跨多个组件工作的测试数据，这可能很耗时，并且会创建脆弱的测试。</p><p id="dab0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，眼下还有一个更大的问题。有这么多行测试数据，对于每个测试来说哪个部分是重要的并不明显。在大量不重要的数据中隐藏重要的部分不会帮助你的测试向下一批阅读它们的人描述它们自己。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="a37b" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">TestDataFactory</h1><p id="ec9f" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">比起手动管理长长的对象数组，我更喜欢创建测试数据工厂:其工作是按需生成<em class="ly"> n </em>个测试数据记录的类。因为这是我必须经常对多种类型的数据做的事情，所以下面是我为此使用的一些方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mc md l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">测试数据.工厂.规格</figcaption></figure><p id="00c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个泛型类期望在构造函数中提供一个函数，该函数生成数据类型为<em class="ly"> T </em>的单个记录。</p><p id="df3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如何生成这些数据取决于你，但是随机化是相当标准的，因为否则的话，每条记录都是一样的。</p><p id="7ea1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，它为您提供了两种方法— <code class="fe ni nj nk nl b">getSingleRecord</code>和<code class="fe ni nj nk nl b">getArray</code>。在任一情况下，您都可以在函数调用中覆盖单个记录。让我们看一下上述类的实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mc md l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">客户.工厂.规格</figcaption></figure><p id="6eaa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我倾向于生成一个随机的令牌或ID，然后在每个后续字段中重用它。一些数据结构将会比这更复杂，你可以在测试数据工厂中有测试数据工厂，就像“Inception”风格。</p><p id="be59" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是请记住，当您的测试失败时，您希望输出易于阅读，所以不要完全随机化您的测试数据。<code class="fe ni nj nk nl b">"FIRSTNAME_325"</code>比<code class="fe ni nj nk nl b">"FxSQt4"</code>更容易阅读。</p><p id="deab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们看看上面的代码示例，但是使用了我们的<code class="fe ni nj nk nl b">CUSTOMER_FACTORY</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mc md l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">客户服务规范</figcaption></figure><p id="45c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过使用工厂，我们已经将规范中测试数据的大小减少到只有四行，使得生成大量数据变得更加容易，并且清楚地表明这些记录之间唯一显著的区别是<code class="fe ni nj nk nl b">memberLevel</code>字段。</p><p id="4b7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还通过随机化测试数据来保护自己免受硬编码值的影响。您可能会想，“什么样的白痴会硬编码数据？”但是我已经看到它发生了；不是因为愚蠢，而是因为开发人员在错误的时间分心，忘记完成他们开始的工作。</p><p id="7f5c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以在自己的测试中随意重用上面的TypeScript片段，并进行您认为合适的任何改进，或者根据您选择的语言对它们进行调整。我做的一件事是生成随机数、字符串、布尔值等函数。，以及每个的数组。如果你想使用类似的东西，这里有一个选择，你可以根据自己的喜好定制:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mc md l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">随机数据规格</figcaption></figure><h1 id="473a" class="ml mm it bd mn mo nm mq mr ms nn mu mv jz no ka mx kc np kd mz kf nq kg nb nc bi translated">为什么要随机测试数据？</h1><p id="6159" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">我们用一个例子来说明。参加以下测试:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="5284" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不使用配置就可以很容易地通过上面的测试。我可以只在按钮文本中写“OK”。但是它不能确保配置真正被使用。我可以在测试中写“OK TEST ”,这样稍微好一点，因为它不太可能被硬编码到组件中。</p><p id="b1a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，我应该如何确保组件中实际使用了配置呢？也许我应该用不同的配置写第二个测试？感觉很笨重。相反，我更喜欢写随机的测试数据。如果我将配置随机化，我就不能将值硬编码到我的组件中，我也不必编写多个测试。正常情况下，随机生成测试数据可能很麻烦，但是使用上面概述的方法，这应该是一个简单的任务。</p><h1 id="af56" class="ml mm it bd mn mo nm mq mr ms nn mu mv jz no ka mx kc np kd mz kf nq kg nb nc bi translated">结论</h1><p id="de83" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">你的测试应该清楚你在测试什么。除了难以维护之外，如果您有一长串手动管理的测试数据，它会模糊您应该关心的部分。</p><p id="3850" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用这些工厂有望帮助你的测试摆脱混乱，变得清晰。</p></div><div class="ab cl me mf hx mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="im in io ip iq"><h1 id="f9cc" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">更新</h1><p id="c4fc" class="pw-post-body-paragraph kz la it lb b lc nd ju le lf ne jx lh li nf lk ll lm ng lo lp lq nh ls lt lu im bi translated">为了使您免于复制和粘贴上面的代码，我决定将其作为名为“Testility”的库的一部分发布。您可以像这样安装它:</p><pre class="kj kk kl km gt nr nl ns nt aw nu bi"><span id="6b14" class="nv mm it nl b gy nw nx l ny nz">npm install --save-dev @maloric/testility</span></pre><p id="bcd0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不客气</p></div></div>    
</body>
</html>