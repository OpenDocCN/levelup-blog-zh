<html>
<head>
<title>Building a Simple GraphQL Server</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建一个简单的GraphQL服务器</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/building-a-simple-graphql-server-6c26f6b916f9?source=collection_archive---------19-----------------------#2020-03-10">https://levelup.gitconnected.com/building-a-simple-graphql-server-6c26f6b916f9?source=collection_archive---------19-----------------------#2020-03-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/6ca1bf89404f205d4d8f4ef239b2c162.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fIt--isTWmABtU-gSHwKUw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">GraphQL</figcaption></figure><p id="26b8" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">随着编程的时代精神不断变化，很难确定什么是时尚，什么会持续下去。幸存下来的工具之一是GraphQL，它是标准RESTful route查询和操作数据方法的替代方案。上周我决定着手解决开源项目的基础问题，我明白了它为什么如此受欢迎。</p><ul class=""><li id="ac68" class="la lb iq ke b kf kg kj kk kn lc kr ld kv le kz lf lg lh li bi translated">GraphQL 是一种用于API的开源数据查询和操作语言，是一个用现有数据完成查询的运行时。</li><li id="ec08" class="la lb iq ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated">GraphQL是脸书在2012年内部开发的，2015年公开发布。</li><li id="662f" class="la lb iq ke b kf lj kj lk kn ll kr lm kv ln kz lf lg lh li bi translated">GraphQL支持读取、写入(变异)和订阅对数据的更改(实时更新——最常用WebHooks实现)。</li></ul><p id="77a7" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">GraphQL提供了一种开发web APIs的方法，并与REST架构风格进行了对比。它允许客户端定义所需的数据结构，并且从服务器返回相同的数据结构，从而防止返回过多的数据。</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><p id="34da" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">对于这个例子，我们将结合Express和MongoDB构建一个GraphQL服务器。如果您需要在开始学习本教程之前快速浏览一下，请查看以下内容:</p><div class="lv lw gp gr lx ly"><a rel="noopener  ugc nofollow" target="_blank" href="/introduction-to-express-js-a-node-js-framework-fa3dcbba3a98"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd ir gy z fp md fr fs me fu fw ip bi translated">Express.js简介:Node.js框架</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">狂热者终于找到了我。我已经决定深入研究Express.js框架，以及它是如何补充</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="mh l"><div class="mi l mj mk ml mh mm jw ly"/></div></div></a></div><div class="lv lw gp gr lx ly"><a rel="noopener  ugc nofollow" target="_blank" href="/mernn-to-do-app-dab1e3173493"><div class="lz ab fo"><div class="ma ab mb cl cj mc"><h2 class="bd ir gy z fp md fr fs me fu fw ip bi translated">MERNN:待办事项应用</h2><div class="mf l"><h3 class="bd b gy z fp md fr fs me fu fw dk translated">用Mongo、Express、React Native、Node搭建一个app</h3></div><div class="mg l"><p class="bd b dl z fp md fr fs me fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="mh l"><div class="mn l mj mk ml mh mm jw ly"/></div></div></a></div><p id="f932" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">前往您的终端，导航到您的项目目录并输入以下命令:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="41ab" class="mx my iq mt b gy mz na l nb nc">mkdir graphql-example<br/>cd graphql-example<br/>touch server.js<br/>touch .env<br/>touch .gitignore<br/>npm init -y<br/>yarn add cors dotenv express express-graphql graphql lodash mongoose nodemon</span></pre><h2 id="9bdc" class="mx my iq bd nd ne nf dn ng nh ni dp nj kn nk nl nm kr nn no np kv nq nr ns nt bi translated">家属:</h2><p id="d2e2" class="pw-post-body-paragraph kc kd iq ke b kf nu kh ki kj nv kl km kn nw kp kq kr nx kt ku kv ny kx ky kz ij bi translated"><code class="fe nz oa ob mt b">cors</code> : CORS是一个node.js包，用于提供一个<a class="ae oc" href="http://www.senchalabs.org/connect/" rel="noopener ugc nofollow" target="_blank"> Connect </a> / <a class="ae oc" href="http://expressjs.com/" rel="noopener ugc nofollow" target="_blank"> Express </a>中间件，可以用来启用<a class="ae oc" href="http://en.wikipedia.org/wiki/Cross-origin_resource_sharing" rel="noopener ugc nofollow" target="_blank"> CORS </a>的各种选项。</p><p id="d212" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe nz oa ob mt b">dotenv</code> : Dotenv是一个零依赖模块，将环境变量从<code class="fe nz oa ob mt b">.env</code>文件加载到<code class="fe nz oa ob mt b"><a class="ae oc" href="https://nodejs.org/docs/latest/api/process.html#process_process_env" rel="noopener ugc nofollow" target="_blank">process.env</a></code></p><p id="f0ed" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe nz oa ob mt b">express</code>:用于<a class="ae oc" href="http://nodejs.org/" rel="noopener ugc nofollow" target="_blank">节点</a>的快速、非个性化、极简的web框架。</p><p id="68bd" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe nz oa ob mt b">express-graphql</code>:用任何支持connect风格中间件的HTTP web框架创建一个GraphQL HTTP server，包括<a class="ae oc" href="https://github.com/senchalabs/connect" rel="noopener ugc nofollow" target="_blank"> Connect </a>本身、<a class="ae oc" href="https://expressjs.com/" rel="noopener ugc nofollow" target="_blank"> Express </a>和<a class="ae oc" href="http://restify.com/" rel="noopener ugc nofollow" target="_blank"> Restify </a>。</p><p id="7fc0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe nz oa ob mt b">graphql</code>:可以针对任何服务的查询语言和运行时。</p><p id="bdbc" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe nz oa ob mt b">lodash</code> : Lodash模块化公用事业。</p><p id="cd60" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe nz oa ob mt b">mongoose</code>:mongose是一个<a class="ae oc" href="https://www.mongodb.org/" rel="noopener ugc nofollow" target="_blank"> MongoDB </a>对象建模工具，设计用于在异步环境中工作。猫鼬支持承诺和回调。</p><p id="5c5e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe nz oa ob mt b">nodemon</code> : nodemon是一个帮助开发基于node.js的应用程序的工具，当检测到目录中的文件改变时，它会自动重启node应用程序。</p><p id="4ede" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">太好了。现在让我们开始设置我们的<code class="fe nz oa ob mt b">server.js</code>文件的框架。</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="6e96" class="mx my iq mt b gy mz na l nb nc">const express = require("express");<br/>const app = express();<br/>require("dotenv").config()<br/>const PORT = 4000 || process.env.PORT</span><span id="7927" class="mx my iq mt b gy od na l nb nc">app.listen(PORT, () =&gt; {<br/>    console.log(`Listening on port: ${PORT}`)<br/>});</span></pre><p id="abf7" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果您打开终端并运行以下命令，您的终端应该输出“监听端口:4000”:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="7fd0" class="mx my iq mt b gy mz na l nb nc">nodemon server</span></pre><p id="9565" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在我们深入研究代码之前，<a class="ae oc" href="https://docs.atlas.mongodb.com/tutorial/deploy-free-tier-cluster/" rel="noopener ugc nofollow" target="_blank">前往MongoDB，创建一个帐户，然后创建一个免费的分层集群用于我们的应用程序。</a>部署集群后，<a class="ae oc" href="https://docs.atlas.mongodb.com/connect-to-cluster/" rel="noopener ugc nofollow" target="_blank">您需要使用URI，通过“连接您的应用程序”选项将集群连接到应用程序</a>。这将生成一个字符串，您可以通过它将应用程序连接到数据库。一旦有了字符串，打开<code class="fe nz oa ob mt b">.env</code>文件，用集群提供的URI添加以下内容:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="55e3" class="mx my iq mt b gy mz na l nb nc">PORT=4000<br/>MONGODB_URI=mongodb+srv://&lt;name&gt;:&lt;password&gt;@cluster.mongodb.net/test?retryWrites=true&amp;w=majority</span></pre><p id="52d8" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">完美。现在我们可以开始设置我们的数据模型和模式了。打开终端，输入以下命令:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="6a6b" class="mx my iq mt b gy mz na l nb nc">mkdir models<br/>cd models<br/>touch author.model.js<br/>touch book.model.js<br/>cd ..</span></pre><p id="85d2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在打开<code class="fe nz oa ob mt b">author.model.js</code>，让我们开始构建我们的数据模型。我们的作者模型将由姓名、年龄、简历和图片组成。我们将首先为Mongo建立模型，然后为graphql建立模式。</p><p id="788e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="oe">/模型/作者.模型. js </em></p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="7bc6" class="mx my iq mt b gy mz na l nb nc">const mongoose = require("mongoose")<br/>const Schema = mongoose.Schema</span><span id="1e9f" class="mx my iq mt b gy od na l nb nc">const AuthorSchema = new Schema({<br/>   name: { type: String, required: true },<br/>   age: { type: Number, required: true },<br/>   bio: { type: String, required: true },<br/>   picture: { type: String, required: true }<br/>})</span><span id="7027" class="mx my iq mt b gy od na l nb nc">module.exports = mongoose.model("Author", AuthorSchema)</span></pre><p id="6ac5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在，我们需要为图书建立一个模式，该模式将由标题、流派、图书封面、摘要和作者ID组成。</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="ece4" class="mx my iq mt b gy mz na l nb nc">const mongoose = require("mongoose")<br/>const Schema = mongoose.Schema</span><span id="5a6b" class="mx my iq mt b gy od na l nb nc">const BookSchema = new Schema({<br/>   title: { type: String, required: true },<br/>   genre: { type: String, required: true },<br/>   summary: { type: String, required: true },<br/>   bookCover: { type: String, required: true },<br/>   authorID: { type: String, required: true }<br/>})</span><span id="1b76" class="mx my iq mt b gy od na l nb nc">module.exports = mongoose.model("Book", BookSchema)</span></pre><p id="6594" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在让我们回到我们的<code class="fe nz oa ob mt b">server.js</code>文件，在我们的应用程序和数据库之间建立连接。</p><p id="9a2a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="oe"> server.js </em></p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="6d56" class="mx my iq mt b gy mz na l nb nc">const express = require("express");<br/>const app = express();<br/>require("dotenv").config()<br/>const PORT = 4000 || process.env.PORT<br/><strong class="mt ir">const mongoose = require("mongoose")<br/>const uri = process.env.MONGODB_URI</strong></span><span id="7523" class="mx my iq mt b gy od na l nb nc"><strong class="mt ir">mongoose.connect(uri, {<br/>   useNewUrlParser: true,<br/>   useCreateIndex: true,<br/>   useUnifiedTopology: true<br/>});</strong></span><span id="9b16" class="mx my iq mt b gy od na l nb nc"><strong class="mt ir">const connection = mongoose.connection;</strong></span><span id="904f" class="mx my iq mt b gy od na l nb nc"><strong class="mt ir">connection.once("open", () =&gt; {<br/>  console.log("Cluster has been connected.");<br/>});</strong></span><span id="64c1" class="mx my iq mt b gy od na l nb nc">app.listen(PORT, () =&gt; {<br/>    console.log(`Listening on port: ${PORT}`)<br/>});</span></pre><p id="64db" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果您在运行<code class="fe nz oa ob mt b">nodemon server</code>时遵循了创建和连接集群的指导，您的终端应该输出以下内容:</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi of"><img src="../Images/5fd5e2d54c07ea75350e71a9cbd8e51c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SiKqzYOdIqFus3MykxLO1Q.png"/></div></div></figure><p id="b700" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果您在这方面有困难，请打开您的MongoDB仪表板并确保:</p><ol class=""><li id="e4a2" class="la lb iq ke b kf kg kj kk kn lc kr ld kv le kz og lg lh li bi translated">您的集群已经部署</li><li id="76ea" class="la lb iq ke b kf lj kj lk kn ll kr lm kv ln kz og lg lh li bi translated">您已将您的IP地址列入“网络访问”白名单</li></ol><p id="003e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在我们可以构建我们的GraphQL模式、查询和变异。回到您的终端，创建目录和文件:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="d9a9" class="mx my iq mt b gy mz na l nb nc">mkdir schema<br/>cd schema <br/>touch schema.js<br/>cd ..</span></pre><p id="a5d9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">首先，让我们为书籍构建GraphQL模式:</p><p id="c539" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="oe"> /schema/schema.js </em></p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="a194" class="mx my iq mt b gy mz na l nb nc">const graphql = require("graphql")<br/>const { GraphQLObjectType,<br/>        GraphQLString, <br/>        GraphQLID,<br/>        GraphQLSchema,<br/>        GraphQLList,<br/>        GraphQLNonNull,<br/>        GraphQLInt<br/>      } = graphql<br/>const Book = require("../models/book.model")<br/>const Author = require("../models/author.model")</span><span id="a513" class="mx my iq mt b gy od na l nb nc">const BookType = new GraphQLObjectType({<br/>   name: "Book",<br/>   fields: () =&gt; ({<br/>     id: { type: GraphQLID },<br/>     title: { type: GraphQLString },<br/>     genre: { type: GraphQLString },<br/>     bookCover: { type: GraphQLString },<br/>     summary: { type: GraphQLString },</span><span id="b839" class="mx my iq mt b gy od na l nb nc">     author: {<br/>        type: AuthorType,<br/>        resolve(parent, args) {<br/>         return Author.findById(parent.authorID)<br/>        }<br/>      }<br/>    })<br/> });</span><span id="7ef2" class="mx my iq mt b gy od na l nb nc">const AuthorType = new GraphQLObjectType({<br/>   name: "Author",<br/>   fields: () =&gt; ({<br/>     id: { type: GraphQLID },<br/>     name: { type: GraphQLString },<br/>     age: { type: GraphQLInt },<br/>     bio: { type: GraphQLString },<br/>     picture: { type: GraphQLString },</span><span id="d443" class="mx my iq mt b gy od na l nb nc">     books: {<br/>        type: BookType,<br/>        resolve(parent, args) {<br/>         return Book.find({ authorID: parent.id })<br/>        }<br/>      }<br/>    })<br/> });</span></pre><p id="ee73" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">既然我们已经使用MongoDB模型定义了GraphQL模式，我们就可以设置我们的根查询了。在我们刚刚编写的代码下面，让我们创建我们的根查询。</p><p id="9dc1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">/架构/schema.js</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="3587" class="mx my iq mt b gy mz na l nb nc">const RootQuery = new GraphQlObjectType({<br/>   name: "RootQueryType",<br/>   fields: {<br/>    books: {<br/>      type: new GraphQLList(BookType),<br/>      resolve(parent, args) {<br/>        return Book.find({});<br/>      }<br/>    },<br/>    authors: {<br/>      type: new GraphQLList(AuthorType),<br/>      resolve(parent, args) {<br/>         return Author.find({})<br/>       }<br/>    },<br/>    book: {<br/>     type: BookType, <br/>     args: { id: { type: GraphQLID } },     <br/>     resolve(parent, args) {<br/>         return Book.findById(args.id);<br/>       }<br/>    },<br/>    author: {<br/>     type: AuthorType, <br/>     args: { id: { type: GraphQLID } },     <br/>     resolve(parent, args) {<br/>         return Author.findById(args.id);<br/>       }<br/>    }<br/>  }<br/>});</span></pre><p id="dc68" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们的查询现在已经设置好了，但是现在没有用，因为我们的数据库中没有数据。让我们设置一些突变，以便我们可以添加一些数据。在我们刚刚编写的代码下面，添加以下内容:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="0ee4" class="mx my iq mt b gy mz na l nb nc"><strong class="mt ir">const Mutation = new GraphQLObjectType({<br/>   name: "Mutation",<br/>   fields: {<br/>     addAuthor: {<br/>        type: AuthorType,<br/>        args: {<br/>          name: { type: new GraphQLNonNull(GraphQLString) },<br/>          age: { type: new GraphQLNonNull(GraphQLInt) },<br/>          bio: { type: new GraphQLNonNull(GraphQLString) },<br/>          picture: { type: new GraphQLNonNull(GraphQLString) }<br/>         },<br/>         resolve(parent, args) {<br/>            let author = new Author({<br/>              name: args.name,<br/>              age: args.age,<br/>              bio: args.bio,<br/>              picture: args.picture<br/>            });<br/>       <br/>         return author.save();<br/>        }<br/>      },<br/>    addBook: {<br/>      type: BookType,<br/>      args: {<br/>        title: { type: new GraphQLNonNull(GraphQLString) },<br/>        genre: { type: new GraphQLNonNull(GraphQLString) },<br/>        bookCover: { type: new GraphQLNonNull(GraphQLString) },<br/>        summary: { type: new GraphQLNonNull(GraphQLString) },<br/>        authorID: { type: new GraphQLNonNull(GraphQLID) }<br/>       },<br/>      resolve(parent, args) {<br/>        let book = new Book({<br/>          title: args.title,<br/>          genre: args.genre,<br/>          bookCover: args.bookCover,<br/>          authorID: args.authorID<br/>        });</strong></span><span id="ddfa" class="mx my iq mt b gy od na l nb nc"><strong class="mt ir">      return book.save();<br/>      }<br/>    }<br/>  }<br/>});</strong></span><span id="e575" class="mx my iq mt b gy od na l nb nc"><strong class="mt ir">module.exports = new GraphQLSchema({<br/>    query: RootQuery,<br/>    mutation: Mutation<br/>});</strong></span></pre><p id="7a03" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然后转到您的<code class="fe nz oa ob mt b">server.js</code>文件，建立我们的路线图QL。</p><p id="dd59" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="oe"> /server.js </em></p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="5f07" class="mx my iq mt b gy mz na l nb nc">...<br/><strong class="mt ir">const schema = require("./schema/schema")<br/>const graphqlHTTP = require("express-graphql")</strong><br/>...</span><span id="61c6" class="mx my iq mt b gy od na l nb nc"><strong class="mt ir">app.use("/graphql", graphqlHTTP({<br/>      schema,<br/>      graphiql: true<br/>   })<br/>);</strong></span><span id="245c" class="mx my iq mt b gy od na l nb nc">app.listen(PORT, () =&gt; {<br/>   console.log(`Listening on port: ${PORT}`);<br/>});</span></pre><p id="ef6e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">用<code class="fe nz oa ob mt b">nodemon server</code>命令启动服务器，然后打开浏览器到<a class="ae oc" href="http://localhost:4000/graphql" rel="noopener ugc nofollow" target="_blank">http://localhost:4000/graph</a>l您应该会看到GraphQL的内置graph QL，您可以在其中进行查询和修改。</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oh"><img src="../Images/76f6d4bb9856eb4ca7508ef788411ff2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UKgR7OPOoS48dom1oKAgXg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">图形QL</figcaption></figure><p id="bce0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">GraphiQL有一些非常酷的特性。如果查询和突变设置正确，您应该能够点击右上角的“Docs ”,并查看您可以查询的可能字段。</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oi"><img src="../Images/5b3ad651fcfc8d24419b49c34c07d864.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iGVDnO_v65DNa5314cpRAw.png"/></div></div></figure><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oi"><img src="../Images/bf25c0e7eb8325c70f00fe8796946d36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QOHu4cBaN2b6Ep07Ci9mwg.png"/></div></div></figure><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oj"><img src="../Images/c3d277669d6f2886d0a081d8303707ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_3vwRWh4JVp9AMM31bNORQ.png"/></div></div></figure><p id="b235" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">让我们添加一些种子数据。为此，首先使用以下格式创建一个作者:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="c81d" class="mx my iq mt b gy mz na l nb nc">mutation {<br/>  addAuthor(name: "Eiji Yoshikawa", age: 70, bio: "was a Japanese historical novelist. Among his best-known novels are revisions of older classics.", picture: "<a class="ae oc" href="https://upload.wikimedia.org/wikipedia/commons/d/d9/Eiji_Yoshikawa.jpg" rel="noopener ugc nofollow" target="_blank">https://upload.wikimedia.org/wikipedia/commons/d/d9/Eiji_Yoshikawa.jpg</a>" ) {<br/>    name<br/>    bio<br/>  }<br/>}</span></pre><p id="ac6c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然后添加一本书:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="1f3e" class="mx my iq mt b gy mz na l nb nc">mutation {<br/>  addBook(title: "Musashi", summary: "The long epic comprises seven \"books\" detailing the exploits of Miyamoto Musashi", genre: "Historical Fiction", bookCover: "<a class="ae oc" href="https://external-content.duckduckgo.com/iu/?u=https%3A%2F%2Fupload.wikimedia.org%2Fwikipedia%2Fen%2F3%2F34%2FMusashiNovel.jpg&amp;f=1&amp;nofb=1" rel="noopener ugc nofollow" target="_blank">https://external-content.duckduckgo.com/iu/?u=https%3A%2F%2Fupload.wikimedia.org%2Fwikipedia%2Fen%2F3%2F34%2FMusashiNovel.jpg&amp;f=1&amp;nofb=1</a>", authorID: "5e62c5ea811aaf5e98e00073") {<br/>    title <br/>    author {<br/>      name<br/>    }<br/>  }<br/>}</span></pre><p id="f075" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在，您可以进行一些查询:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="5f22" class="mx my iq mt b gy mz na l nb nc">{<br/>  authors {<br/>   name<br/>   books {<br/>     title<br/>    }<br/>  }<br/>}</span></pre><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ok"><img src="../Images/f049deaf72fd72978d38b8c8c8b33965.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c-npTVLO5nMZUhoz5K7Mug.png"/></div></div></figure><p id="e396" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">就这么简单。</p></div></div>    
</body>
</html>