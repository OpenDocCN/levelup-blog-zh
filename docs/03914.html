<html>
<head>
<title>JavaScript Best Practices— JSONP and Deployment</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript最佳实践— JSONP和部署</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-best-practices-jsonp-and-deployment-4857b3c9b1b2?source=collection_archive---------27-----------------------#2020-06-01">https://levelup.gitconnected.com/javascript-best-practices-jsonp-and-deployment-4857b3c9b1b2?source=collection_archive---------27-----------------------#2020-06-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/d33bd098f595e56089b6235a488ded06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Skq-Ag4igAQznfy8"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@pawankawan?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">帕万·卡万</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="8b38" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">JavaScript让我们可以做很多事情。它的语法有时过于宽容。</p><p id="8a3a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了组织我们的代码，我们应该使用一些基本的设计模式。在本文中，我们将研究如何使用JSONP和部署策略。</p><h1 id="2963" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">JSONP</h1><p id="7af5" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">JSONP是带填充的JSON。我们可以用这个代替JSON来绕过同域浏览器策略。</p><p id="34d1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们应该小心使用，因为我们正在从第三方网站加载数据。</p><p id="b523" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用JSONP，我们将JSON封装在一个函数调用中。</p><p id="26ae" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">JSONP请求提供了函数名。</p><p id="2335" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，JSONP请求URL可能看起来像:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="36c4" class="mq lf it mm b gy mr ms l mt mu">http://example.org/getdata?callback=myHandler</span></pre><p id="e991" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">其中,<code class="fe mv mw mx mm b">myHandler</code>是我们的应用程序中的函数名，一旦发出请求，这个函数就会被调用。</p><p id="e777" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">URL被加载到script元素中，一旦加载完成，它将调用<code class="fe mv mw mx mm b">myHandler</code>。</p><h1 id="4f2c" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">部署JavaScript</h1><p id="b3b2" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">当我们部署JavaScript代码时，我们需要考虑一些事情。</p><p id="593a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们必须确保组合脚本，使它们紧凑。</p><p id="f782" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">空格、长名字等。都被删除并替换为更短的空格和名称。</p><p id="2b84" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">组合脚本是我们部署之前的又一个步骤。</p><p id="0e54" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可能会失去一些缓存优势。因为包中的一个小变化而使缓存无效是不好的。</p><p id="22e7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，我们必须为这个包提供一些版本控制模式，这样我们才不会忘记它们。</p><h1 id="e606" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">缩小和压缩</h1><p id="9a6c" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">缩小和压缩代码很重要。包越小，用户需要下载的代码就越少。</p><p id="71fe" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这意味着用户可以更快地使用我们的应用程序。</p><p id="7323" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那对用户来说肯定是好的。</p><p id="8732" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">与原始代码相比，缩小和压缩可以减少多达50%的大小。</p><p id="c9ab" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以用gzip压缩来压缩我们的包。我们的web服务器可以配置为提供gzipped包，而不是纯文本。</p><p id="a596" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这也将使我们的尺寸减小。</p><p id="7d10" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">压缩平均会使我们的文件变小70%。</p><p id="179d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过缩小和压缩，用户只需下载原始代码大小15%的文件。</p><h1 id="2004" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">过期标题</h1><p id="6125" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们的缓存应该在一段时间后过期。这样用户就不用手动刷新才能看到最新的变化。</p><p id="7f60" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以将到期头更改为我们满意的值。</p><p id="1cb6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们将缓存设置为long，那么我们必须在每次部署时重命名文件，这样缓存就会自动失效。</p><h1 id="c075" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">使用CDN</h1><p id="0b1d" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">CDN代表内容交付网络。这些是付费服务，让我们在世界各地的不同数据中心分发文件副本。</p><p id="1363" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这样，由于位置接近，文件将更快地提供给用户。</p><p id="4066" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以链接到cdn上的库文件并使用它们。</p><h1 id="af9b" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">装载策略</h1><p id="bd07" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">如果我们在应用程序中加载文件，那么我们可以用几种方式加载它们。</p><p id="9a05" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于简单的脚本，我们可以使用内联脚本:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="8f0b" class="mq lf it mm b gy mr ms l mt mu">&lt;script&gt;<br/>  console.log("hello");<br/>&lt;/script&gt;</span></pre><p id="cce1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">或者我们可以从外部资源加载它们:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="f52b" class="mq lf it mm b gy mr ms l mt mu">&lt;script src="external.js"&gt;&lt;/script&gt;</span></pre><p id="3504" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以使用一些属性以不同的方式加载脚本。</p><p id="4071" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以使用<code class="fe mv mw mx mm b">defer</code>指令让我们的脚本以一种不会阻止我们的浏览器运行其他代码的方式下载。</p><h1 id="ecf5" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">脚本元素的位置</h1><p id="fe3b" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">脚本元素应该作为一个包来加载，这样我们就不需要按顺序加载很多文件。</p><p id="4abc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们拥有的脚本标签越多，我们就越有可能打乱顺序。</p><p id="a039" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我们应该确保通过捆绑来减少脚本标签的数量。</p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi my"><img src="../Images/c0f58113e12e84d3af1813d834747955.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*O4it_PjZnr11h2SW"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@pooya_ramezani?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> pooya ramezani </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="395b" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">HTTP分块</h1><p id="4c90" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们也可以把我们的页面分块，这样它们就可以分块加载了。</p><p id="beff" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以将所有的JavaScript移到head标签中，而加载主体的其余部分可以在以后加载。</p><h1 id="ae57" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">动态脚本元素</h1><p id="629b" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以在脚本标签中使用<code class="fe mv mw mx mm b">defer</code>或<code class="fe mv mw mx mm b">async</code>属性。</p><p id="6a8c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mv mw mx mm b">defer</code>异步但按顺序加载它们。</p><p id="f814" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mv mw mx mm b">async</code>异步加载它们，但可能不按顺序。</p><p id="6558" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还可以通过编写以下代码来动态创建脚本标记:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="655d" class="mq lf it mm b gy mr ms l mt mu">const script = document.createElement("script");<br/>script.src = "foo.js"; document.documentElement.firstChild.appendChild(script);</span></pre><p id="8719" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这将创建一个脚本标签，我们可以将它附加到head标签或其他任何地方。</p><h1 id="efec" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="943a" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以通过缩小和压缩来减小脚本包的大小。</p><p id="9e3a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这样，我们的代码可以少于原始代码的一半。</p><p id="426e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还可以使用<code class="fe mv mw mx mm b">defer</code>和<code class="fe mv mw mx mm b">async</code>指令来加载脚本文件。</p><p id="6564" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以即时创建脚本来延迟加载。</p><p id="62fe" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">JSONP允许我们加载JSON，而没有相同的域限制。</p></div></div>    
</body>
</html>