<html>
<head>
<title>JavaScript Events Handlers — Metadata and Ajax Events</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript事件处理程序—元数据和Ajax事件</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-events-handlers-metadata-and-ajax-events-de440bafb851?source=collection_archive---------5-----------------------#2020-01-25">https://levelup.gitconnected.com/javascript-events-handlers-metadata-and-ajax-events-de440bafb851?source=collection_archive---------5-----------------------#2020-01-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/a52ccd1fbabb226f92cefd99f39bd9ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Ziz2v78icltStMTK"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@aboeka?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">格温·威斯丁克</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="d442" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在JavaScript中，事件是应用程序中发生的动作。它们是由各种事件触发的，比如输入、提交表单、调整大小等元素变化，或者应用程序运行时发生的错误等。我们可以分配一个事件处理程序来处理这些事件。</p><p id="bb00" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">发生在DOM元素上的事件可以通过为相应事件的DOM对象的属性分配一个事件处理程序来处理。在本文中，我们将研究媒体DOM元素的<code class="fe le lf lg lh b">onloadedmetadata</code>属性和XmlHttpRequest对象的<code class="fe le lf lg lh b">onloadend</code>属性。</p><h1 id="9667" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">onloadedmetadata</h1><p id="6ec2" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">媒体DOM元素的<code class="fe le lf lg lh b">onloadedmetadata</code>属性让我们设置一个事件处理函数，当<code class="fe le lf lg lh b">loademetadata</code>事件被触发时运行这个函数。每当加载媒体元数据时，都会触发此事件。</p><p id="d924" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以先在HTML代码中添加一个视频标签来使用它:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="6ed8" class="mt lj it lh b gy mu mv l mw mx">&lt;video src='<a class="ae kf" href="https://sample-videos.com/video123/mp4/240/big_buck_bunny_240p_30mb.mp4'" rel="noopener ugc nofollow" target="_blank">https://sample-videos.com/video123/mp4/240/big_buck_bunny_240p_30mb.mp4'</a>&gt;&lt;/video&gt;</span></pre><p id="7005" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后在相应的JavaScript代码中，我们可以为<code class="fe le lf lg lh b">onloadedmetadata</code>属性设置一个事件处理函数，如下面的代码所示:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="55a7" class="mt lj it lh b gy mu mv l mw mx">const video = document.querySelector('video');</span><span id="77de" class="mt lj it lh b gy my mv l mw mx">video.onloadedmetadata = (e) =&gt; {<br/>  console.log(e); <br/>}</span></pre><p id="8b49" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们在<code class="fe le lf lg lh b">e</code>参数的<code class="fe le lf lg lh b">srcElement</code>属性中获取视频的元数据，这是一个<code class="fe le lf lg lh b">Event</code>对象。我们会得到这样的结果:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="c477" class="mt lj it lh b gy mu mv l mw mx">clientHeight: 240<br/>clientLeft: 0<br/>clientTop: 0<br/>clientWidth: 320<br/>contentEditable: "inherit"<br/>controls: false<br/>controlsList: DOMTokenList [value: ""]<br/>crossOrigin: null<br/>currentSrc: "<a class="ae kf" href="https://sample-videos.com/video123/mp4/240/big_buck_bunny_240p_30mb.mp4" rel="noopener ugc nofollow" target="_blank">https://sample-videos.com/video123/mp4/240/big_buck_bunny_240p_30mb.mp4</a>"<br/>currentTime: 0<br/>dataset: DOMStringMap {}<br/>defaultMuted: false<br/>defaultPlaybackRate: 1<br/>dir: ""<br/>disablePictureInPicture: false<br/>disableRemotePlayback: false<br/>draggable: false<br/>duration: 368.2<br/>elementTiming: ""<br/>ended: false<br/>enterKeyHint: ""<br/>error: null<br/>firstChild: null<br/>firstElementChild: null<br/>height: 0<br/>hidden: false<br/>id: ""<br/>innerHTML: ""<br/>innerText: ""<br/>inputMode: ""<br/>isConnected: true<br/>isContentEditable: false<br/>lang: ""<br/>lastChild: null<br/>lastElementChild: null<br/>localName: "video"<br/>loop: false<br/>mediaKeys: null<br/>muted: false<br/>namespaceURI: "<a class="ae kf" href="http://www.w3.org/1999/xhtml" rel="noopener ugc nofollow" target="_blank">http://www.w3.org/1999/xhtml</a>"<br/>networkState: 1<br/>nextElementSibling: script<br/>nextSibling: text<br/>nodeName: "VIDEO"<br/>nodeType: 1<br/>nodeValue: null<br/>nonce: ""<br/>offsetHeight: 240<br/>offsetLeft: 8<br/>offsetParent: body<br/>offsetTop: 8<br/>offsetWidth: 320<br/>...<br/>outerHTML: "&lt;video src="<a class="ae kf" href="https://sample-videos.com/video123/mp4/240/big_buck_bunny_240p_30mb.mp4" rel="noopener ugc nofollow" target="_blank">https://sample-videos.com/video123/mp4/240/big_buck_bunny_240p_30mb.mp4</a>"&gt;&lt;/video&gt;"<br/>outerText: ""<br/>ownerDocument: document<br/>parentElement: body<br/>parentNode: body<br/>part: DOMTokenList [value: ""]<br/>paused: true<br/>playbackRate: 1<br/>played: TimeRanges {length: 0}<br/>playsInline: false<br/>poster: ""<br/>prefix: null<br/>preload: "metadata"<br/>previousElementSibling: null<br/>previousSibling: text<br/>readyState: 4<br/>remote: RemotePlayback {state: "disconnected", onconnecting: null, onconnect: null, ondisconnect: null}<br/>scrollHeight: 240<br/>scrollLeft: 0<br/>scrollTop: 0<br/>scrollWidth: 320<br/>seekable: TimeRanges {length: 1}<br/>seeking: false<br/>shadowRoot: null<br/>sinkId: ""<br/>slot: ""<br/>spellcheck: true<br/>src: "<a class="ae kf" href="https://sample-videos.com/video123/mp4/240/big_buck_bunny_240p_30mb.mp4" rel="noopener ugc nofollow" target="_blank">https://sample-videos.com/video123/mp4/240/big_buck_bunny_240p_30mb.mp4</a>"<br/>srcObject: null<br/>style: CSSStyleDeclaration {alignContent: "", alignItems: "", alignSelf: "", alignmentBaseline: "", all: "", …}<br/>tabIndex: -1<br/>tagName: "VIDEO"<br/>textContent: ""<br/>textTracks: TextTrackList {length: 0, onchange: null, onaddtrack: null, onremovetrack: null}<br/>title: ""<br/>translate: true<br/>videoHeight: 240<br/>videoWidth: 320<br/>volume: 1<br/>webkitAudioDecodedByteCount: 10995<br/>webkitDecodedFrameCount: 4<br/>webkitDisplayingFullscreen: false<br/>webkitDroppedFrameCount: 0<br/>webkitSupportsFullscreen: true<br/>webkitVideoDecodedByteCount: 37638</span></pre><p id="7541" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一些有用的元数据包括<code class="fe le lf lg lh b">videoHeight</code>，它以像素为单位告诉我们视频的高度，<code class="fe le lf lg lh b">videoWidth</code>，它以像素为单位告诉我们视频的宽度，以及<code class="fe le lf lg lh b">duration</code>，它以秒为单位告诉我们视频的长度。<code class="fe le lf lg lh b">duration</code>也可用音频元素。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/b29cfd20eb2ed893c5cb9983913fc7ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MK5MGhs1qJIFYTn2"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@baptiststandaert?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">浸礼会标准员</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><h1 id="106a" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">onloadend</h1><p id="b769" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">XMLHttpRequest对象的<code class="fe le lf lg lh b">onloadend</code>属性允许我们为它分配一个事件处理程序，每当触发<code class="fe le lf lg lh b">loadend</code>事件时，该处理程序就会运行。无论请求是否成功完成，只要请求完成，就会触发<code class="fe le lf lg lh b">loadend</code>事件。如果成功，那么这个事件将在<code class="fe le lf lg lh b">load</code>事件之后被触发。否则，它将在<code class="fe le lf lg lh b">abort</code>或<code class="fe le lf lg lh b">error</code>事件后触发。</p><p id="ac11" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以为<code class="fe le lf lg lh b">onloadend</code>事件分配一个事件处理程序，就像我们在下面的代码中所做的那样:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="6679" class="mt lj it lh b gy mu mv l mw mx">const loadButtonSuccess = document.querySelector('.load.success');<br/>const loadButtonError = document.querySelector('.load.error');<br/>const loadButtonAbort = document.querySelector('.load.abort');<br/>const log = document.querySelector('.event-log');</span><span id="446e" class="mt lj it lh b gy my mv l mw mx">function handleLoadEnd(e) {<br/>    log.textContent = log.textContent + `${e.type}: ${e.loaded} bytes transferred\n`;<br/>}</span><span id="835a" class="mt lj it lh b gy my mv l mw mx">function addListeners(xhr) {<br/>  xhr.onloadend = handleLoadEnd;<br/>}</span><span id="f476" class="mt lj it lh b gy my mv l mw mx">function get(url) {<br/>  log.textContent = '';</span><span id="2dda" class="mt lj it lh b gy my mv l mw mx">  const xhr = new XMLHttpRequest();<br/>  addListeners(xhr);<br/>  xhr.open("GET", url);<br/>  xhr.send();<br/>  return xhr;  <br/>}</span><span id="b69a" class="mt lj it lh b gy my mv l mw mx">loadButtonSuccess.addEventListener('click', () =&gt; {<br/>    get('<a class="ae kf" href="https://jsonplaceholder.typicode.com/todos/1'" rel="noopener ugc nofollow" target="_blank">https://jsonplaceholder.typicode.com/todos/1'</a>);<br/>});</span><span id="5a24" class="mt lj it lh b gy my mv l mw mx">loadButtonError.addEventListener('click', () =&gt; {<br/>    get('<a class="ae kf" href="https://somewhere.org/i-dont-exist'" rel="noopener ugc nofollow" target="_blank">https://somewhere.org/i-dont-exist'</a>);<br/>});</span><span id="a7c1" class="mt lj it lh b gy my mv l mw mx">loadButtonAbort.addEventListener('click', () =&gt; {<br/>    get('<a class="ae kf" href="https://jsonplaceholder.typicode.com/todos/1').abort();" rel="noopener ugc nofollow" target="_blank">https://jsonplaceholder.typicode.com/todos/1').abort();</a><br/>});</span></pre><p id="346d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们有3个按钮，每当每个按钮被点击时都会运行<code class="fe le lf lg lh b">click</code>事件处理程序。点击“加载(成功)”按钮将运行<code class="fe le lf lg lh b">get </code>功能。我们将在对<code class="fe le lf lg lh b">get</code>函数的调用中传递一个有效的URL。“加载(成功)”按钮的点击处理由以下模块完成:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="b712" class="mt lj it lh b gy mu mv l mw mx">loadButtonSuccess.addEventListener('click', () =&gt; {<br/>    get('<a class="ae kf" href="https://jsonplaceholder.typicode.com/todos/1'" rel="noopener ugc nofollow" target="_blank">https://jsonplaceholder.typicode.com/todos/1'</a>);<br/>});</span></pre><p id="091c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">JSONPlaceholder有一个可以为任何URL服务的测试API，因为它托管了一个假API，所以我们可以加载它而不会得到任何错误。同样，我们有按钮加载一个会给出错误的URL，还有另一个按钮加载一个有效的URL，但是我们中止请求。一旦XmlHttpRequest完成，我们分配给<code class="fe le lf lg lh b">onloadend</code>事件处理程序的函数，也就是<code class="fe le lf lg lh b">handleLoadEnd</code>函数，将会运行。</p><p id="8f86" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">handleLoadEnd</code>函数有一个参数，它是一个<code class="fe le lf lg lh b">Event</code>对象，包含一些关于已完成请求的数据。在该函数中，我们获得了<code class="fe le lf lg lh b">type</code>属性的值，该属性具有被触发的事件类型，应该是<code class="fe le lf lg lh b">loadend</code>。此外，我们还获得了属性<code class="fe le lf lg lh b">loaded</code>的值，它包含了已经加载的数据的字节数。</p><p id="7867" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后在HTML代码中，我们添加上面的<code class="fe le lf lg lh b">querySelector</code>调用中列出的元素:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="ef92" class="mt lj it lh b gy mu mv l mw mx">&lt;div class="controls"&gt;<br/>    &lt;input class="load success" type="button" name="xhr" value="Load (success)" /&gt;<br/>    &lt;br&gt;<br/>    &lt;input class="load error" type="button" name="xhr" value="Load (error)" /&gt;<br/>    &lt;br&gt;<br/>    &lt;input class="load abort" type="button" name="xhr" value="Load (abort)" /&gt;<br/>&lt;/div&gt;</span><span id="4c3f" class="mt lj it lh b gy my mv l mw mx">&lt;textarea readonly class="event-log"&gt;&lt;/textarea&gt;</span></pre><p id="7b3e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们有3个按钮可以点击来加载成功的HTTP请求，一个带有不存在的URL的HTTP请求，和一个中止的HTTP请求。然后我们显示触发的事件和加载的字节数。</p><p id="7795" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">media DOM元素的<code class="fe le lf lg lh b">onloadedmetadata</code>属性让我们设置一个事件处理函数，当<code class="fe le lf lg lh b">loademetadata</code>事件被触发时运行这个函数。每当加载媒体元数据时，都会触发此事件。我们可以从事件处理函数的<code class="fe le lf lg lh b">event</code>参数的<code class="fe le lf lg lh b">srcElement</code>属性中获取元数据。</p><p id="f921" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">XMLHttpRequest对象的<code class="fe le lf lg lh b">onloadend</code>属性让我们为它分配一个事件处理程序，每当<code class="fe le lf lg lh b">loadend</code>事件被触发时，它就会运行。无论请求是否成功完成，只要请求完成，就会触发<code class="fe le lf lg lh b">loadend</code>事件。如果成功，那么这个事件将在<code class="fe le lf lg lh b">load</code>事件之后被触发。否则，它将在<code class="fe le lf lg lh b">abort</code>或<code class="fe le lf lg lh b">error</code>事件之后触发。我们可以通过设置XMLHttpRequest对象的<code class="fe le lf lg lh b">onloadend</code>属性来处理这个事件。事件处理函数应该有一个<code class="fe le lf lg lh b">event</code>参数，该参数是一个具有<code class="fe le lf lg lh b">type</code>属性的<code class="fe le lf lg lh b">event</code>对象，该对象具有被触发的事件类型，应该是<code class="fe le lf lg lh b">loadend</code>。此外，我们还获得了<code class="fe le lf lg lh b">loaded</code>属性的值，它包含了已经加载的数据的字节数。</p></div></div>    
</body>
</html>