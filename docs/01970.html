<html>
<head>
<title>TypeScript for People in a Hurry</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为赶时间的人打字</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/typescript-for-people-in-a-hurry-dfbf8956d767?source=collection_archive---------12-----------------------#2020-02-09">https://levelup.gitconnected.com/typescript-for-people-in-a-hurry-dfbf8956d767?source=collection_archive---------12-----------------------#2020-02-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/5bcb1b2215239c1b2caefbfe0edc5c54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B8yDF-V3roTG4tX9mHSmUg.jpeg"/></div></div></figure><h2 id="9555" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">什么是TypeScript？</h2><p id="6459" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">TypeScript是JavaScript的超集。它能做JS能做的一切，甚至更多。它由微软更新和维护，可以向下编译成常规的JS。</p><p id="1caa" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">一些开发人员会争辩说，TypeScript对人类的可读性也更好，这可能是它在开发社区中越来越受欢迎的原因。</p></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h2 id="3008" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">许多不同类型(1/3)</h2><p id="dbf9" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">只要有可能，我们应该将静态类型应用到变量中。然而，默认情况下，如果类型像在type1中那样未定义，它将携带一个类型<strong class="kw ir"> any </strong>。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="64af" class="jy jz iq mg b gy mk ml l mm mn">let type1;<br/>// I am an any type</span><span id="4ac2" class="jy jz iq mg b gy mo ml l mm mn">let type2: boolean = false;<br/>// I am a boolean type</span><span id="f217" class="jy jz iq mg b gy mo ml l mm mn">let type3: string = 'Hello Developers';<br/>// I am a string type</span><span id="8945" class="jy jz iq mg b gy mo ml l mm mn">let type4: number = 42;<br/>// I am a number type</span></pre><p id="0739" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">还有<strong class="kw ir">多种类型</strong>。注意在<em class="ms">数字</em>和<em class="ms">布尔之间的“管道操作符”<code class="fe mp mq mr mg b">|</code>。</em>这表示type4可以是数字类型或布尔类型。</p><p id="01a3" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">在TypeScript中，我们希望尽可能地使用单一类型<strong class="kw ir">。然而，如果不是，我们可以选择使用<strong class="kw ir">多类型</strong>来代替默认的<strong class="kw ir">任意类型</strong>。</strong></p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="541f" class="jy jz iq mg b gy mk ml l mm mn">let type4: number | boolean = 42;<br/>// I am type4. I am a number type or a boolean type</span></pre><p id="b6c8" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">到目前为止，所有的类型都是显式类型。一种我们明确硬编码的类型。但是也有像我们的type4这样的<strong class="kw ir">隐式类型</strong>。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="0930" class="jy jz iq mg b gy mk ml l mm mn">let type4: number;<br/>type4 = 42<br/>// I'm an explicit type</span><span id="aa2a" class="jy jz iq mg b gy mo ml l mm mn">let type4 = 'Hey good looking. I'm an implicit type'<br/>// Notice that we did not hard code the type 'string' here. type4 implicitly knows it is a string</span></pre><p id="5828" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">我们也可以用函数做到这一点。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="4b91" class="jy jz iq mg b gy mk ml l mm mn">const arrayImplicit = [10, 30, 40, 50];<br/>let arrayImplicit = arrayImplicit.reduce((num1, num2) =&gt; num1 + num2);</span><span id="4c95" class="jy jz iq mg b gy mo ml l mm mn">//I am an implicit type function</span><span id="59ee" class="jy jz iq mg b gy mo ml l mm mn">const arrayExplicit: number[] = [10, 30, 40, 50];<br/>let arrayExplicit = arrayExplicit.reduce((num1, num2) =&gt; num1 + num2);</span><span id="9402" class="jy jz iq mg b gy mo ml l mm mn">//I am an explicit type function</span></pre></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h2 id="469e" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">检查类型</h2><p id="e8f7" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">为了检查我们是否得到了正确的类型，我们使用了操作符的<em class="ms">实例。这将测试构造函数的原型属性是否出现在对象的原型链中。</em></p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="c53a" class="jy jz iq mg b gy mk ml l mm mn">class Puppies {<br/> puppies: number;<br/>  constructor(data: number) {<br/>  this.puppies = data;<br/>  }<br/>}</span><span id="2a0b" class="jy jz iq mg b gy mo ml l mm mn">const puppy = new Puppies(4);</span><span id="883d" class="jy jz iq mg b gy mo ml l mm mn">if (puppy instanceof Puppies) {<br/>  console.log("Adopt don't shop!");<br/>}</span></pre><p id="e0ce" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">如果从多个类继承，它也会通过，所以一个好的经验法则是将它缩小到被检查的最低模型。</p></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h2 id="e76a" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">TypeScript中的数组</h2><p id="4217" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">TypeScript数组的示例。特别注意coolType8和coolType9。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="48da" class="jy jz iq mg b gy mk ml l mm mn">const type5: string[] = ['Hello World'];</span><span id="bb17" class="jy jz iq mg b gy mo ml l mm mn">const type6: number[] = [1, 2];</span><span id="bfd5" class="jy jz iq mg b gy mo ml l mm mn">const type7: boolean[] = [true, false];</span><span id="d9ec" class="jy jz iq mg b gy mo ml l mm mn">const coolType8: (number | boolean)[] = [1, 2, true];<br/>//Notice that my types are wrapped with (). This reads that I can accept number or boolean values in my array</span><span id="bd2e" class="jy jz iq mg b gy mo ml l mm mn">const coolType9: boolean[][] = [ [true, false] ];<br/>// I have a nested array value</span></pre><p id="41d5" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">现在让我们来看看叫做元组的东西。元组是具有固定数量元素的数组。元组允许我们使用具有固定数量元素的数组，这些元素的类型是已知的，但不需要相同。以下示例说明了字符串和数字的值和类型表示。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="562d" class="jy jz iq mg b gy mk ml l mm mn"><strong class="mg ir">let</strong> tupleExample: [string, number];<br/>//Tuple declaration </span><span id="7d5b" class="jy jz iq mg b gy mo ml l mm mn">tupleExample = ["hello", 10]; // CORRECT</span><span id="9a7c" class="jy jz iq mg b gy mo ml l mm mn">tupleExample = [10, "hello"]; // INCORRECT</span></pre><p id="5ea3" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">另一个例子:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="7bf2" class="jy jz iq mg b gy mk ml l mm mn">const tupleMe: [string, number] = ['I am Tuple', 25];</span></pre></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h2 id="b9af" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">枚举</h2><p id="2bff" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">对JS来说有点新的是枚举或枚举值。枚举是为数值集提供更友好名称的一种方式。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="aa07" class="jy jz iq mg b gy mk ml l mm mn"><strong class="mg ir">enum</strong> Simpsons{Bart, Lisa, Maggie} <br/>let s: Simpsons = Simpsons.Lisa;</span></pre><p id="10e8" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">默认情况下，像数组索引一样，枚举从0开始对其成员进行编号。要改变这一点，我们可以手动设置它的一个成员的值。例如，我们可以从1而不是0开始我们的Simpsons例子。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="0c36" class="jy jz iq mg b gy mk ml l mm mn"><strong class="mg ir">enum</strong> Simpsons{Bart = 1, Lisa, Maggie} <br/>let s: Simpsons = Simpsons.Lisa;</span></pre><p id="9951" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">我们也可以手动设置所有枚举。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="74c7" class="jy jz iq mg b gy mk ml l mm mn"><strong class="mg ir">enum</strong> Simpsons{Bart = 1, Lisa = 2, Maggie = 5} <br/>let s: Simpsons = Simpsons.Lisa;</span></pre><p id="891f" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">我们也可以从一个数值到枚举中该值的名称。例如，如果我们有值2，但不确定它在Simpsons枚举中映射到什么，我们可以搜索相应的名称。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="35ba" class="jy jz iq mg b gy mk ml l mm mn"><strong class="mg ir">enum</strong> Simpsons{Bart = 1, Lisa, Maggie} <br/><strong class="mg ir">let</strong> simpsonName: string = Simpsons[2];  </span><span id="131a" class="jy jz iq mg b gy mo ml l mm mn">console.log(simpsonName); <br/>// will display 'Lisa' as Lisa's value is 2 above<br/></span></pre></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mt"><img src="../Images/06f8a16aa1e8a7c68612343e4e08e97c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R9QegkTg-9j8NXytNuYzuA.jpeg"/></div></div></figure><p id="28fd" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated"><em class="ms">半途而废</em></p></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h2 id="17ca" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">功能</h2><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="7330" class="jy jz iq mg b gy mk ml l mm mn">function add(num1: number, num2: number) {<br/> return num1 + num2;<br/>}</span><span id="6b55" class="jy jz iq mg b gy mo ml l mm mn">add(10, 5);<br/>// will return 15</span></pre><p id="f9bc" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">上面示例中的参数表示num1的类型为number，num2的类型为number。注意，由于这个原因，我们只能在add()中输入数字。任何其他类型的值都会给我们一个错误。</p><p id="f39c" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">上面的例子有一个<strong class="kw ir">隐式返回类型。</strong>让我们将返回类型显式化。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="bb06" class="jy jz iq mg b gy mk ml l mm mn">function add(num1: number, num2: number)<strong class="mg ir">: number</strong> {<br/> return num1 + num2;<br/>}</span><span id="b1f7" class="jy jz iq mg b gy mo ml l mm mn">add(10, 5);<br/>// will return 15</span></pre><p id="e64e" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">请注意，如果我们显式地将它作为字符串返回，我们的代码将会中断。要显式返回一个字符串，我们必须返回一个字符串。</p></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h2 id="ceea" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">接口</h2><p id="5779" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">我们可以不使用类，而是使用接口。一个接口用关键字<em class="ms">接口</em>定义，可以包含属性和使用函数或箭头函数的方法声明。对于下面的例子，我们将关注属性，我们的三个属性是firstName、middleName和lastName。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="3a9d" class="jy jz iq mg b gy mk ml l mm mn">interface IStudent {<br/> firstName: string;<br/> middleName: string;<br/> lastName: string; <br/>}</span><span id="f559" class="jy jz iq mg b gy mo ml l mm mn">const myFace: IStudent = {firstName: 'Kelly', middleName: 'Belly', lastName: 'Jelly'};</span><span id="e839" class="jy jz iq mg b gy mo ml l mm mn">myFace.firstName = 'Miss';<br/>myFace.middleName = 'Kelly';<br/>myFace.lastName = 'More';</span></pre><p id="7e28" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">命名接口时使用大写<code class="fe mp mq mr mg b">I</code>是一种惯例。通知<code class="fe mp mq mr mg b">IStudent</code>。</p></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h2 id="968c" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">许多不同的类型继续—交叉类型(2/3)</h2><p id="ee89" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">交集类型将多种类型合并为一种。它们允许我们将现有的类型添加到一起，以获得具有您需要的所有特性的单一类型。换句话说，它是向单个实体添加多种类型以及基于此创建新类型的能力。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="3610" class="jy jz iq mg b gy mk ml l mm mn">interface IRobot {<br/> iq: number;<br/>}</span><span id="7d04" class="jy jz iq mg b gy mo ml l mm mn">interface IHuman {<br/> firstName: string;<br/>}</span><span id="425f" class="jy jz iq mg b gy mo ml l mm mn">interface IPrimate {<br/> lucy: boolean;<br/>}</span><span id="c845" class="jy jz iq mg b gy mo ml l mm mn">let cyborg: IRobot | IHuman; // I can identify as a robot or a human<br/>let animal: IPrimate;<br/>let martians: IHuman;</span><span id="7c06" class="jy jz iq mg b gy mo ml l mm mn">type OurHistory = IPrimate &amp; IHuman &amp; IRobot<br/>// I have combined all 3 interface features into OurHistory. I also have the properties of these interfaces</span><span id="2e6e" class="jy jz iq mg b gy mo ml l mm mn">let story: OurHistory;</span><span id="3cd9" class="jy jz iq mg b gy mo ml l mm mn">story.firstName = 'Scarlett';<br/>story.iq = 263;<br/>story.lucy = true;</span></pre><h2 id="effb" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">许多不同类型继续存在——属型(3/3)</h2><p id="e5c9" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">泛型确定了一种约束类型，对于可重用代码非常有用。当我们没有预定义的数据类型时，它们为我们提供了一种操作方法。当我们想要传递一个类型但不知道它是什么，或者在传递一个类型后操作一个类型时，我们使用泛型。</p><p id="b1d1" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">下面是一个非常基本的泛型类型函数的例子。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="e0d9" class="jy jz iq mg b gy mk ml l mm mn">function genericEg&lt;T&gt;(arg: T): T {<br/> return arg;<br/>}</span></pre><p id="2800" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">赋值<t>让函数知道它将是泛型的。跟在:后面的T是返回类型，我们的参数也是这种类型，(arg: T)。</t></p><p id="b00b" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">稍后我们将能够选择我们要传递的类型。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="6670" class="jy jz iq mg b gy mk ml l mm mn">function genericEg&lt;T&gt;(arg: T): T {<br/> return arg;<br/>}</span><span id="68b4" class="jy jz iq mg b gy mo ml l mm mn">genericEg(8);<br/>// This is now a number that is being passed in</span></pre></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h2 id="525b" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">资源</h2><p id="161b" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">打字稿:<a class="ae mu" href="https://www.typescriptlang.org/index.html" rel="noopener ugc nofollow" target="_blank">https://www.typescriptlang.org/index.html</a><br/>斯克林巴:<a class="ae mu" href="https://scrimba.com/g/gintrototypescript" rel="noopener ugc nofollow" target="_blank">https://scrimba.com/g/gintrototypescript</a></p></div></div>    
</body>
</html>