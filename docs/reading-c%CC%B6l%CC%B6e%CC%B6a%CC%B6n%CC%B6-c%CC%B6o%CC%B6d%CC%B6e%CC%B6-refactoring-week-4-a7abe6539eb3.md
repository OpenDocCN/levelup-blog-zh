# 阅读 C̶l̶e̶a̶n̶ C̶o̶d̶e̶重构第四周

> 原文：<https://levelup.gitconnected.com/reading-c%CC%B6l%CC%B6e%CC%B6a%CC%B6n%CC%B6-c%CC%B6o%CC%B6d%CC%B6e%CC%B6-refactoring-week-4-a7abe6539eb3>

我一直喜欢通读 [*干净的代码*](https://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/B08X8ZXT15/ref=sr_1_1?dchild=1&keywords=clean+code&qid=1626195338&sr=8-1) ，但本周我会稍微休息一下，讨论一下[马丁·福勒](https://martinfowler.com/)的*重构的第一章。*像*干净的代码*，*重构*在职业程序员中相当有名，因为它对如何编写干净、可读、高效的代码给出了清晰简明的建议。现在在它的第二版[中，包含了福勒令人难以置信的见解，*重构*经常被列入](https://www.amazon.com/Refactoring-Improving-Existing-Addison-Wesley-Signature/dp/0134757599/ref=sr_1_1?dchild=1&keywords=refactoring&qid=1626195319&sr=8-1)[最佳](https://www.geeksforgeeks.org/top-10-books-that-every-programmer-must-read-once/) [编程](https://hackr.io/blog/best-programming-books) [书籍](https://learntocodewith.me/posts/programming-books/) [可用](https://simpleprogrammer.com/best-programming-books-2019/)(说真的，我刚刚谷歌了一下“最佳编程书籍”，它被列在了前四名的结果中)。至此，让我们直接进入福勒在第一章提出的一些教训。

![](img/3ec4f78fd407afa0d36b3985ffaae0b4.png)

《重构》的第一行强调学习代码需要例子，以免你在试图理解抽象的计算机科学主题时打瞌睡。同样，我将使用*重构*来编辑我之前为[腐烂的土豆](https://putridpotatoes.netlify.app/)编写的代码，这是一个社交媒体应用程序，允许你回顾你观看的电影，并与网站上的其他用户互动。虽然我总是致力于编写清晰、专业的代码，但在为熨斗学校制作这个压顶项目时，我承认我写的一些代码可以改进。

![](img/6fac27bb02a6af0c83dd6fa5b7fe8150.png)

腐败土豆主页

更具体地说，我将重构这个应用程序中的一个 React 组件，即`UserProfile`组件。这个组件相当简单，充当用户的个人资料页面，包含他们的追随者列表以及他们的个人电影评论。这个组件的代码可以在[这里](https://github.com/jmarthaller/movie-chat-app-frontend/blob/main/src/components/UserProfile.js)找到，这里是它在浏览器中的样子的一个例子:

![](img/750a689921005cf29546a14f6deb5540.png)

腐败土豆的个人资料页面

虽然这个组件的代码运行得非常好，但是对于其他开发人员来说可读性不是很好。正如我在以前的博客文章中提到的，你的编译器并不关心你的代码是否对其他人可读；如果你真的想用尽可能少的代码行编写你的程序，你的 IDE 可能会满足你。但是代码可读性对于团队中的其他开发人员来说非常重要。对于 Fowler 来说，可读性首先成为考虑结构的关键。或者，正如福勒更雄辩地说:

*“当你必须给一个程序添加一个特性，但是代码不是以一种方便的方式构造的时候，首先重构程序，使之易于添加特性，然后再添加特性。”*

虽然看起来很明显，但我认为福勒在这里所说的是“测量两次，减少一次”哲学的一个版本，这或多或少是良好工程实践的一个主要部分。当有经验的软件工程师为他们的程序打下一个良好的基础时，他们会成功，这个基础将能够支持今天以及六个月或一年内构建的功能，而不是在一个构建新的和令人兴奋的功能的程序中进行黑客攻击。如果你想独自构建应用程序，你应该可以为你的程序维护任何你想要的结构。然而，一旦你和另外一个人一起构建东西，你就需要编写可读的代码。举个简单的例子，让我们只看一下`UserProfile`组件的一些代码:

![](img/3d43ae44d23f49a90f1926f40364616f.png)

同样，这段代码运行得非常好，但是在格式方面有一些非常明显的问题。首先，这些状态管理函数被笨拙地隔开，我可以看到在我的`UserProfile`的道具列表中有一个未使用的变量`setReviews`。最糟糕的是，`allUserFriends`中的道具正在我的文本编辑器页面上运行！令人欣慰的是，像[prettle](https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode)这样的工具使得重构变得非常容易:

![](img/3c2df719ddd7f9770122d8a31b081586.png)

我想你会同意这段代码比前一个例子更容易理解(或者至少看起来更舒服)，虽然它只是整个应用程序中相对较小的一部分中的一小段代码，但是当 Fowler 想要重构以前编写的代码时，首先要做的就是给出程序的结构。尽管这段经过编辑的代码比之前的代码片段占用了*更多的*行，但随着时间的推移，它仍然更容易理解和构建。

接下来我们将看一下`handleUpdateReview()`函数，该函数(可能很明显)允许用户更新之前提交的评论的内容或星级。下面是我的代码库中该函数的样子:

![](img/00a1bd7cf35f581c1ec2ce30634a2f7e.png)

虽然这个函数运行得很好，但是我承诺的`.then`语法有点过时，我已经从我的软件工程师同事那里得到反馈，使用更现代的`async-await`语法会更好。现在不讨论这个决定的细节，需要做这个改变是为什么好的重构如此重要的一个很好的例子。正如 Fowler 所写的，“对好代码的真正测试是改变它有多容易。”我们使用的技术总是需要更新，代码库总是需要质量重构。因此，使我们的代码模块化和灵活是保持软件高效的关键。在用 pretty 重新格式化`handleUpdateReview()`之后，我有了一个相当不错的小逻辑:

![](img/d70fa809f29de59fdfd0f9f4f0d129b3.png)

当然，这是对我的程序的一个小改动，只包含了几次击键。虽然这看起来是一个无关紧要的改变，但对我来说这是一个保存我的程序的好机会，测试改变的特性以确保它仍然可以在浏览器中工作，然后用版本控制系统提交这些改变。这说到我最喜欢的《重构》第一章的部分。

在整个第一章，福勒提醒他的读者，他不断地，煞费苦心地检查他的编辑，以确保他没有破坏他的整体计划。事实上，福勒的短语“编译-测试-提交”几乎出现在第一章的每一页，作为他在每次更改后执行的编码咒语，以确保他没有犯错误。在第一章的几个段落中，福勒甚至提醒读者，尽管他没有在*重构*中明确地写“编译-测试-提交”，但这是他编码实践的一个常规部分。

通过在本地运行腐烂的土豆，我能够做类似的事情，在提交这些更改之前测试浏览器中的更改，并最终将它们推送到我在 [Netlify](https://www.netlify.com/) 的托管服务。如果你只是盲目地编辑你的程序并将你的修改保存到 GitHub，得到这种紧密的反馈循环将会节省你浪费的时间。在我看来，这种实践给了程序员一种重构节奏的感觉，如何编辑你的程序应该总是伴随着细心和定期测试。它提醒你，在你测量了两次并裁剪了一次之后，你仍然应该再次检查其他的东西是否仍然吻合。使用像 git 这样的现代工具，压缩您的提交很容易做到，所以在这个广泛的重构阶段进行大量的提交不会在您最终推进您的更改时建立大量的 cruft。

![](img/f4c5d852c9f40fb63479c14cb784aedf.png)

马丁·福勒演讲

在我开始阅读《T2》《重构》《T3》和《T4》《干净的代码》《T5》之前，我对阅读这类书籍持保留态度。虽然学习更多关于编写高质量代码的过程似乎是一个好主意，但是实际编写代码难道不是一个更好的主意吗？老实说，我仍然认为感兴趣的读者需要在学习编码最佳实践和编写代码之间取得平衡。尽管如此，重要的是要注意，当你在阅读像 *Refactoring* 这样的书籍时，你可能会在编程时发现自己在思考它的教训。以我的经验来看，如果你花时间坐下来阅读这些书，并将它们的经验内化，它们会深深地渗透到你的开发人员的大脑中，确保你写出更具可读性和可维护性的代码。下周我将再次回到*清理代码*。我希望你能回来看看我的进步。