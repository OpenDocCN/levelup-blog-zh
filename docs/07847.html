<html>
<head>
<title>How To Use Doubles In Unit Tests</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在单元测试中使用Doubles</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-use-doubles-in-unit-tests-fe1b13e42c27?source=collection_archive---------19-----------------------#2021-03-15">https://levelup.gitconnected.com/how-to-use-doubles-in-unit-tests-fe1b13e42c27?source=collection_archive---------19-----------------------#2021-03-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f578" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">有时候替身是模仿的更好替代。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5b195525889015f69a661669e6e9f1a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iRzgT_10IiUuMUSfdnAXCg.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图片由<a class="ae ky" href="https://pixabay.com/users/analogicus-8164369/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=4243189" rel="noopener ugc nofollow" target="_blank">类比</a>来自<a class="ae ky" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=4243189" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></figcaption></figure><p id="b995" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您为某段代码编写单元测试时，您应该只测试一段代码，而不是它调用的代码。否则，您可能会重复您的测试工作。隔离代码的一种方法是模仿被调用的对象或方法。但是，如果您正在模仿一个对象，尤其是一个包含状态的对象，那么协调模仿代码可能会很困难。如果对象是一个接口的实现，你可以使用doubles。</p><p id="412c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">double是一个行为类似于它的孪生兄弟的对象，只是它被简化了。数据库就是一个很好的例子。如果我们测试的代码需要进行添加、按id检索和按id删除的数据库调用，底层数据结构只需要是一个映射。即使您需要加倍的接口是广泛的，您只需要填写被测试代码使用的方法。</p><p id="4b4a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用可以携带状态的doubles的好处之一是，我们可以通过以某种预期的顺序调用方法来测试一个类。这提供了我们不常想到的单元测试的好处之一，即作为如何使用一个类的例子。如果编程语言是基于类的，那么让单元测试也基于类是很有用的，即使是在混合的经典/函数环境中。基于类的单元测试应该能够以预期的方式使用被测试类的方法，提供一个使用模板。</p><p id="9c65" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最近，我必须完成一个代表银行的小型示例REST服务，包括用户、账户和余额。它是一个整体，所有的活动都由一个服务处理，逻辑大部分包含在一个类中。其余的类是配置类、数据类或简单的外观类，不需要测试。所以所有的测试都是在单个服务类上完成的。因为服务类依赖于数据库来保存方法调用之间的状态，所以我们想要模拟它，这样我们就可以以自然的方式进行测试，只调用服务的成员。</p><p id="726d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，我们有一个方法<code class="fe lv lw lx ly b">getAccount</code>可以返回特定用户的账户信息。为了设置要获取的帐户，我们将使用方法<code class="fe lv lw lx ly b">createAccount</code>(假设用户已设置好)下面是我为测试准备的内容:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="78b9" class="md me it ly b gy mf mg l mh mi"><a class="ae ky" href="http://twitter.com/Test" rel="noopener ugc nofollow" target="_blank">@Test</a><br/>  public void testGetAccount() {<br/>    System.out.println("getAccount");<br/>    AccountPayload account = AccountPayload.builder()<br/>      .currAmount(BigDecimal.valueOf(100, 2))<br/>      .type("checking")<br/>      .build();<br/>    String userId = customers.get(0).getId();<br/>    account = sut.createAccount(account, userId)<br/>      .blockOptional(Duration.ofSeconds(1))<br/>      .orElseThrow(() -&gt; <br/>             new RuntimeException("result of save not found"));<br/>    AccountPayload result = sut.getAccount(account.getId(), userId)<br/>                .blockOptional(Duration.ofSeconds(1))<br/>                .orElseThrow(() -&gt; <br/>             new RuntimeException("result of get not found"));<br/>          <br/>    assertEquals(account.getCurrAmount(),result.getCurrAmount());<br/>    assertEquals(account.getType(),result.getType());<br/>    assertNotNull(result.getId());<br/>    try { // user can only get their own accounts<br/>      sut.getAccount(account.getId(), customers.get(1).getId())<br/>                .blockOptional(Duration.ofSeconds(1))<br/>                .orElseThrow(() -&gt; <br/>             new RuntimeException("result of get not found"));<br/>      fail("expected exception not thrown");<br/>    } catch (AccountNotFoundException ex) {<br/>      assertEquals("Account " <br/>         + account.getId() <br/>         + " not found for user " <br/>         + customers.get(1).getId(), ex.getMessage());<br/>    }<br/>    try { // unknown account returns reasonable error<br/>      sut.getAccount("0", customers.get(1).getId())<br/>        .blockOptional(Duration.ofSeconds(1))<br/>        .orElseThrow(() -&gt; <br/>             new RuntimeException("result of get not found"));<br/>      fail("expected exception not thrown");<br/>    } catch (AccountNotFoundException ex) {<br/>      assertEquals("Account 0 not found for user " <br/>          + customers.get(1).getId(), ex.getMessage());<br/>    }<br/>    try { // unknown user<br/>      sut.getAccount("", "0")<br/>        .blockOptional(Duration.ofSeconds(1))<br/>        .orElseThrow(() -&gt; <br/>           new RuntimeException("result of get not found"));<br/>      fail("expected exception not thrown");<br/>    } catch (UserNotFoundException ex) {<br/>    assertEquals("User 0 not found", ex.getMessage());<br/>  }<br/>}</span></pre><p id="9f44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">值<code class="fe lv lw lx ly b">sut</code>是“受测对象”,在每次测试前设置。给它贴上这样的标签有助于记住我们到底在测试什么，以及什么只是测试本身的一个工件。值customer也是在测试类之前设置的，并且是不可变的。因为这个服务假设用户是预先设置好的<em class="mj"/>，也许结合认证，我们可以从一个文件中加载样本用户。</p><p id="f449" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该测试调用其中一个客户的<code class="fe lv lw lx ly b">createAccount</code>，然后以四种不同的方式调用<code class="fe lv lw lx ly b">getAccount</code>。第一个调用检查获取我们刚刚创建的帐户的正常条件。第二个呼叫是代表另一个客户完成的，并抛出<code class="fe lv lw lx ly b">AccountNotFoundException</code>。第三个电话寻找一个假账户，再次抛出<code class="fe lv lw lx ly b">AccountNotFoundException</code>。最后一个呼叫是代表一个假客户完成的，并抛出<code class="fe lv lw lx ly b">UserNotFoundException</code>。最后一种情况可能永远不会发生，因为应该通过身份验证来检查客户，这应该会返回400错误。</p><p id="2eb3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当创建值<code class="fe lv lw lx ly b">sut</code>时，我们也创建了它将使用的doubles，而不是一个真正的数据库。它是这样设置的:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="b77b" class="md me it ly b gy mf mg l mh mi">public class FinTechServiceTest {<br/>    FinTechService sut;<br/>    UserReactiveRepository userRepository = <br/>         new UserRepositoryDouble();<br/>    TransferAuditReactiveRepository transferAuditRepository = <br/>         new TransferAuditRepositoryDouble();<br/>    List&lt;Customer&gt; customers;<br/>    <br/>    <br/>    public FinTechServiceTest() {<br/>    }<br/>    <br/>    <a class="ae ky" href="http://twitter.com/BeforeEach" rel="noopener ugc nofollow" target="_blank">@BeforeEach</a><br/>    public void setUp() throws IOException {<br/>        userRepository.deleteAll();<br/>        transferAuditRepository.deleteAll();<br/>        sut = new FinTechService(userRepository,<br/>                            transferAuditRepository);<br/>        sut.initializeUsers();<br/>        customers = userRepository.findAll()<br/>                .collectList()<br/>                .block();<br/>    }</span><span id="98fc" class="md me it ly b gy mk mg l mh mi">...</span></pre><p id="b04e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我们创建两个double，它们代表两个数据库客户机(在上面的测试中，我们没有使用transfer audit客户机)，然后在每个测试之前，清除存储库，创建一个用这两个double构造的新服务对象，然后初始化并收集客户。因为我们使用的是Spring的构造函数初始化，而不是AutoWire注释，所以我们可以很容易地用doubles替换普通的数据库客户机。</p><p id="4637" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，这是我们用于用户存储库的替身:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="763e" class="md me it ly b gy mf mg l mh mi">public class UserRepositoryDouble implements UserReactiveRepository {<br/>  private final Map&lt;String, Customer&gt; data = new HashMap&lt;&gt;();</span><span id="c844" class="md me it ly b gy mk mg l mh mi">  public Mono&lt;Customer&gt; save(Customer s) {<br/>    Customer s1 = copy(s);<br/>    data.put(s1.getId(),s1);<br/>    return Mono.just(s1);<br/>  }</span><span id="540d" class="md me it ly b gy mk mg l mh mi">  public Mono&lt;Customer&gt; findById(String id) {<br/>    return Mono.justOrEmpty(data.get(id));<br/>  }</span><span id="72e9" class="md me it ly b gy mk mg l mh mi">  public Flux&lt;Customer&gt; findAll() {<br/>    return Flux.fromStream(data.values().stream());<br/>  }</span><span id="a2ce" class="md me it ly b gy mk mg l mh mi">  public Mono&lt;Long&gt; count() {<br/>    return Mono.just(Long.valueOf(data.size()));<br/>  }</span><span id="b950" class="md me it ly b gy mk mg l mh mi">  public Mono&lt;Void&gt; deleteAll() {<br/>    data.clear();<br/>    return Mono.empty();<br/>  }</span><span id="18ea" class="md me it ly b gy mk mg l mh mi">  public &lt;S extends Customer&gt; Flux&lt;S&gt; saveAll(Publisher&lt;S&gt; pblshr) {<br/>    return Flux.from(pblshr)<br/>                .map(c -&gt; {<br/>                    Customer s1 = copy(c);<br/>                    data.put(s1.getId(),s1);<br/>                    return (S)s1;<br/>                });<br/>  }</span><span id="f480" class="md me it ly b gy mk mg l mh mi">  private static Customer copy(Customer customer) {<br/>    return Customer.builder()<br/>                .accounts(new ArrayList(customer.getAccounts()))<br/>                .id(customer.getId())<br/>                .name(customer.getName())<br/>                .build();<br/>  }<br/>    <br/>}</span></pre><p id="c4ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为该类实现了一个接口，所以我的IDE能够用抛出异常的默认实现来填充所有必要的方法。我所要做的就是为测试中使用的方法填充一点逻辑。为了简洁起见，我省略了上面代码中所有未实现的方法。</p><p id="de99" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我之所以能够使用double，是因为在这种情况下，接口的使用部分很小，并且它的实现很简单。如果界面有更复杂的方面，使用double会变得更加困难，嘲讽可能更合适。</p><p id="8cf6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我还认为，在微服务的世界里，单元测试的重要性已经降低了。测试微服务的最佳方式是作为一个运行单元，因为它们应该相对简单，并且容易部署到测试环境中。真正的困难在于微服务之间的协调，这也是我们应该集中测试精力的地方。但是，我仍然喜欢看到我的代码工作，单元测试是实现这一点的一种方式。</p><p id="74e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是GitHub的存储库，包含所有代码:</p><div class="ml mm gp gr mn mo"><a href="https://github.com/rkamradt/fintechapi/tree/v0.1" rel="noopener  ugc nofollow" target="_blank"><div class="mp ab fo"><div class="mq ab mr cl cj ms"><h2 class="bd iu gy z fp mt fr fs mu fu fw is bi translated">rkamradt/fintechapi</h2><div class="mv l"><h3 class="bd b gy z fp mt fr fs mu fu fw dk translated">一个带有Spring Boot的Java API示例。通过在…上创建帐户，为rkamradt/fintechapi开发做出贡献</h3></div><div class="mw l"><p class="bd b dl z fp mt fr fs mu fu fw dk translated">github.com</p></div></div><div class="mx l"><div class="my l mz na nb mx nc ks mo"/></div></div></a></div></div></div>    
</body>
</html>