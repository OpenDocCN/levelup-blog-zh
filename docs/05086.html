<html>
<head>
<title>Android: Dalvik vs ART</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">安卓:达尔维克vs阿特</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/android-dvm-vs-art-5687c7903e65?source=collection_archive---------7-----------------------#2020-08-03">https://levelup.gitconnected.com/android-dvm-vs-art-5687c7903e65?source=collection_archive---------7-----------------------#2020-08-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="069e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本文中，我们将讨论Android运行时环境。值得注意的是，我们承诺会简短地解释Android中ART和Dalvik (DVM)的差异。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/e028ed397d6bc62842e674a0d9ba2847.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*PSPtjqr2rXC0SzrA.png"/></div></div></figure><h1 id="5be3" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">虚拟计算机</h1><p id="78d4" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">让我们先弄清楚JVM和DVM的区别。</p><p id="0529" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> Java虚拟机</strong>是能够执行Java字节码的虚拟机，不考虑基础平台。它基于“一次编写，随处运行”的原则Java字节码可以在任何支持JVM的机器上运行。</p><p id="243a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Java编译器会转换。java文件进入<em class="md">。类</em>文件(字节码)。字节码被传递给JVM，JVM将其编译成机器代码，以便直接在CPU上执行。</p><p id="8873" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">JVM特性:</p><ul class=""><li id="55b4" class="me mf it js b jt ju jx jy kb mg kf mh kj mi kn mj mk ml mm bi translated">堆栈架构。堆栈用作放置和存储方法的数据结构。它的工作原理是后进先出法。</li><li id="ecfc" class="me mf it js b jt mn jx mo kb mp kf mq kj mr kn mj mk ml mm bi translated">跑<em class="md">。仅类</em>文件。</li><li id="817c" class="me mf it js b jt mn jx mo kb mp kf mq kj mr kn mj mk ml mm bi translated">使用JIT编译器。</li></ul><p id="e93a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Dalvik虚拟机 (DVM)是由丹·博恩施泰因等人开发和编写的Java虚拟机，是Android移动平台的一部分。</p><p id="b12e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以说Dalvik是Android操作系统组件和用户应用程序的运行时。每个进程都在其隔离的域中执行。当用户启动一个应用程序(或者操作系统启动它的一个组件)时，Dalvik虚拟机内核(Zygote Dalvik VM)在共享内存中创建一个单独的安全进程，其中VM直接部署为运行应用程序的环境。简而言之，Android within看起来像一组Dalvik虚拟机，每个虚拟机都执行一个应用程序。</p><p id="bb83" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">DVM功能:</p><ul class=""><li id="20ff" class="me mf it js b jt ju jx jy kb mg kf mh kj mi kn mj mk ml mm bi translated">基于寄存器的架构。方法所在的数据结构基于处理器寄存器。由于没有弹出和推送，寄存器VM中的指令比堆栈VM中的类似指令执行得更快。</li><li id="b139" class="me mf it js b jt mn jx mo kb mp kf mq kj mr kn mj mk ml mm bi translated">执行其格式的字节码。Android dexer(后面再说)转换<em class="md">。将</em>类文件放入<em class="md">中。dex </em>格式针对DVM执行进行了优化。不像一个<em class="md">。类</em>文件，一个<em class="md">文件。dex </em>文件一次包含几个类。</li></ul><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/7c6b3db28afabe262bc320d41e3d4394.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*S08XLnRLUVWjfaNq.png"/></div></div></figure><p id="46a9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你有兴趣，可以在这里阅读更多关于DVM架构<a class="ae ms" href="http://www.davidehringer.com/software/android/The_Dalvik_Virtual_Machine.pdf" rel="noopener ugc nofollow" target="_blank">的内容。</a></p><h1 id="dc80" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">Android Dexer</h1><p id="d988" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">创建APK的关键步骤是将Java字节码转换成<em class="md">。dex </em>字节码供Android运行时和Android开发者了解。dex编译器主要在日常应用程序开发中“卧底”工作，但它直接影响应用程序的构建时间。dex 文件大小和运行时性能。</p><p id="119e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如前所述。<em class="md"> dex </em>文件本身同时包含几个类。重复字符串和其他常量，在多个<em class="md">中使用。包含类</em>文件只是为了节省空间。Java字节码也被转换成DVM使用的可选命令集。一个未压缩的<em class="md">。dex </em>文件通常比来自同一个<em class="md">的压缩Java归档文件(JAR)小几个百分点。类</em>文件。</p><p id="9a4b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最初，<em class="md">。类别</em>文件被转换为<em class="md">。使用内置DX编译器的dex </em>。但是从<a class="ae ms" href="https://android-developers.googleblog.com/2017/08/next-generation-dex-compiler-now-in.html" rel="noopener ugc nofollow" target="_blank"> Android Studio 3.1 </a>开始，默认编译器是<a class="ae ms" href="https://developer.android.com/studio/command-line/d8" rel="noopener ugc nofollow" target="_blank"> D8 </a>。与DX编译器相比，D8编译更快，输出更小。dex文件，在运行时提供高应用程序性能。使用开源实用程序<a class="ae ms" href="https://www.guardsquare.com/en/products/proguard" rel="noopener ugc nofollow" target="_blank"> ProGuard </a>将产生的字节码缩小。结果，我们得到相同的<em class="md">。dex </em>文件，但是更小。然后这个文件被用于APK构建，最后被部署到Android设备上。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/43354b6b301398ce61c703386161658d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*4nbRcXA2xUDzz3iy.png"/></div></div></figure><p id="4c0e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">继<a class="ae ms" href="https://android-developers.googleblog.com/2018/11/r8-new-code-shrinker-from-google-is.html" rel="noopener ugc nofollow" target="_blank"> 2018 </a>中的D8之后，又来了<a class="ae ms" href="https://developer.android.com/studio/build/shrink-code" rel="noopener ugc nofollow" target="_blank"> R8 </a>，本质上是同一个D8，只是更新了。</p><p id="da9e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在使用Android Studio 3.4和<a class="ae ms" href="https://developer.android.com/studio/releases/gradle-plugin#3-4-0" rel="noopener ugc nofollow" target="_blank"> Android Gradle 3.4.0 </a>插件或更高版本时，编译期间不再使用Proguard进行代码优化。该插件默认情况下与R8一起工作，后者自己执行代码收缩、优化和模糊处理。尽管R8只提供了Proguard提供的一部分功能，但它允许将Java字节码转换成dex字节码只需执行一次，从而进一步减少了构建时间。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/7e3cf28a63d26c5586ffe321186e1902.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*gBzWCfvFOJfisar1.png"/></div></div></figure><h1 id="3f51" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">R8和代码收缩</h1><p id="2134" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">我们都知道大部分应用使用的是第三方库比如Guava，Jetpack，Gson，Google Play服务。当我们使用这些库中的一个时，通常每个库中只有一小部分在应用程序中使用。如果没有代码收缩，库的全部代码都存储在您的应用程序中。</p><p id="1c49" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当开发人员使用冗长的代码来提高可读性和可维护性时，就会发生这种情况。例如，有意义的变量名和构建器模式可以用来使其他人更容易理解您的代码。但是这种模式通常会导致比所需更多的代码。</p><p id="4abb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这种情况下，R8来救援。它允许您通过优化应用程序实际使用的代码量来显著减小应用程序的大小。</p><p id="7406" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">作为一个例子，我将引用在2019年<a class="ae ms" href="https://www.youtube.com/watch?time_continue=3&amp;v=uQ_yK8kRCaA&amp;feature=emb_title" rel="noopener ugc nofollow" target="_blank"> Android开发峰会</a>上提交的<a class="ae ms" href="https://www.youtube.com/watch?time_continue=3&amp;v=uQ_yK8kRCaA&amp;feature=emb_title" rel="noopener ugc nofollow" target="_blank">R8</a>报告中的数字:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/daa51f40bc297b12397c4c1665eded9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*yKZnJN2CfYduLCTf.png"/></div></div></figure><p id="2232" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面你可以看到测试版发布时的R8效率(摘自<a class="ae ms" href="https://android-developers.googleblog.com/" rel="noopener ugc nofollow" target="_blank"> Android开发者博客</a>来源):</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mt"><img src="../Images/bff90c478dfa345d78c354b41aa37d90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*bnHhj-xFa5UkzmCj.png"/></div></div></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mt"><img src="../Images/3e9468518827b2b060729f4d490fad5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*xQ1QcRovjczR5v93.png"/></div></div></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mt"><img src="../Images/88d1f1756ce9ae5dd6e16ceb8542c29f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*lknCzHephrnBaBl9.png"/></div></div></figure><p id="3de2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有关详细信息，请查看<a class="ae ms" href="https://developer.android.com/studio/build/shrink-code" rel="noopener ugc nofollow" target="_blank">官方文档</a>和上述报告。</p><h1 id="2c2a" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">Android中的ART vs DVM</h1><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/1c250b4a5dd0d3e065a23b20d23c40f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*LMPhjF2BanM_9h8o.png"/></div></div></figure><p id="6ae6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">DVM是专为移动设备设计的，在android 4.4 Kitkat之前，它被用作虚拟机来运行Android应用程序。</p><p id="1758" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从这个版本开始，<a class="ae ms" href="https://source.android.com/devices/tech/dalvik" rel="noopener ugc nofollow" target="_blank"> ART </a>作为运行时环境被引入，在Android 5.0 (Lollipop)中，ART完全取代了Dalvik。</p><p id="7996" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">ART和DVM之间最明显的区别是ART使用AOT编译，而DVM使用JIT编译。不久前，ART开始使用AOT和JIT的混合。我们将对此进行更深入的探讨。</p><p id="121e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> DVM </strong></p><ul class=""><li id="dec7" class="me mf it js b jt ju jx jy kb mg kf mh kj mi kn mj mk ml mm bi translated">使用JIT编译:无论何时启动应用程序，执行应用程序所需的代码部分都会编译。其余代码动态编译。这减慢了应用程序的启动和运行，但减少了安装时间。</li><li id="650c" class="me mf it js b jt mn jx mo kb mp kf mq kj mr kn mj mk ml mm bi translated">加速设备的启动，因为应用程序缓存是在运行时创建的。</li><li id="c7bf" class="me mf it js b jt mn jx mo kb mp kf mq kj mr kn mj mk ml mm bi translated">DVM应用比运行在ART上的应用需要更少的内存。</li><li id="e891" class="me mf it js b jt mn jx mo kb mp kf mq kj mr kn mj mk ml mm bi translated">通过增加CPU负载来降低电池性能。</li><li id="7919" class="me mf it js b jt mn jx mo kb mp kf mq kj mr kn mj mk ml mm bi translated">Dalvik已经“过时”，在4.4以上的Android版本上不再使用。</li></ul><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/80ecd87b2c2dc34c8d3bd5f1631366da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*AHlBCn_G4WB5R4RV.png"/></div></div></figure><p id="ddf8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">艺术</strong></p><ul class=""><li id="f1da" class="me mf it js b jt ju jx jy kb mg kf mh kj mi kn mj mk ml mm bi translated">使用AOT编译，即在应用程序安装期间编译所有代码。这加快了应用程序的运行和操作，但需要更多的安装时间。</li><li id="cd45" class="me mf it js b jt mn jx mo kb mp kf mq kj mr kn mj mk ml mm bi translated">减慢设备的启动速度，因为缓存是在第一次启动时创建的。</li><li id="309a" class="me mf it js b jt mn jx mo kb mp kf mq kj mr kn mj mk ml mm bi translated">由于AOT编译方法，与DVM应用程序相比，需要更多的内存。</li><li id="f394" class="me mf it js b jt mn jx mo kb mp kf mq kj mr kn mj mk ml mm bi translated">通过减少运行应用程序时由于编译缺失而导致的CPU操作来提高电池性能。</li><li id="983e" class="me mf it js b jt mn jx mo kb mp kf mq kj mr kn mj mk ml mm bi translated">改进的垃圾收集。使用Dalvik时，垃圾收集器必须执行两次堆传递，这导致了糟糕的UX。在ART的例子中，情况并非如此:它为内存整合清理一次堆。</li></ul><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/8802ae762ad92148ce2c7f7a4604564f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*tz0DhazhoXYZvn1H.png"/></div></div></figure><h1 id="468f" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">艺术中的JIT + AOT</h1><p id="7000" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">从Android 7开始，Android运行时环境包含了一个带有代码分析的JIT编译器。JIT编译器补充了AOT编译器，提高了运行时性能，节省了磁盘空间，并加快了应用程序和系统的更新。</p><p id="8e5d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它是根据以下方案进行的:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/a0fb17e6880debd9e0bd797790e4aa51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ZFpIMgR0kKniiery.png"/></div></div></figure><p id="b824" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它不是在安装期间运行每个应用程序的AOT编译，而是在使用JIT编译器的虚拟机下运行应用程序(几乎与Android中的&lt; 5.0) but keeping track of pieces of app code executing most often. This information is after used for the AOT compilation of these code fragments. The last operation is performed only during the smartphone is inactive, which is on a charge.</p><p id="27c0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Merely speaking, now two different approaches work together, which brings its benefits:</p><ul class=""><li id="d47d" class="me mf it js b jt ju jx jy kb mg kf mh kj mi kn mj mk ml mm bi translated">More efficient compilation — when you start an app, the compiler can learn much more about its operation than when performing static analysis, and, as a result, more suitable optimization methods are applied for each situation.</li><li id="bcf9" class="me mf it js b jt mn jx mo kb mp kf mq kj mr kn mj mk ml mm bi translated">Preserving RAM and permanent memory — bytecode is more compact than machine code. When we perform AOT compilation only of separate application parts and do not compile applications the user doesn’t use, we can significantly save. NAND-memory space;</li><li id="6664" class="me mf it js b jt mn jx mo kb mp kf mq kj mr kn mj mk ml mm bi translated">A sharp increase in installation speed and first boot after system update — no AOT compilation, no delay.</li></ul><p id="9416" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">More information about JIT compiler implementation in ART you can find <a class="ae ms" href="https://source.android.com/devices/tech/dalvik/jit-compiler" rel="noopener ugc nofollow" target="_blank">相同，这里是</a>)。</p><h1 id="9eb5" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">总结</h1><p id="796e" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">在本文中，我们已经分析了DVM和ART之间的主要差异，并大致了解了Android如何随着时间的推移改进其开发工具。</p><p id="1e3f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">ART仍在开发中:正在添加新功能来改善用户和开发人员的体验。</p><p id="b4ae" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们希望这篇文章对那些刚刚开始使用Android的人有所帮助。</p></div><div class="ab cl mu mv hx mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="im in io ip iq"><p id="4f5e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="md">原载于2020年8月3日</em><a class="ae ms" href="https://intexsoft.com/blog/android-runtime-environment-dvm-vs-art/" rel="noopener ugc nofollow" target="_blank"><em class="md">【https://intexsoft.com】</em></a><em class="md">。</em></p></div></div>    
</body>
</html>