<html>
<head>
<title>TypeScript Best Practices —void, Default Type Parameters, Spread, and Numbers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript最佳实践—void、默认类型参数、跨页和数字</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/typescript-best-practices-void-default-type-parameters-spread-and-numbers-1f071cb845b2?source=collection_archive---------7-----------------------#2020-07-23">https://levelup.gitconnected.com/typescript-best-practices-void-default-type-parameters-spread-and-numbers-1f071cb845b2?source=collection_archive---------7-----------------------#2020-07-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/339a9734ba1a47d7ca4ce420ff7ce3c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cjFq-W92Ajavtj_Q"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">Vincent van Zalinge 在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="67b0" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">没有空表达式</h1><p id="0d9d" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">我们不应该在返回类型为<code class="fe mc md me mf b">void</code>的函数中返回表达式。</p><p id="2fca" class="pw-post-body-paragraph le lf it lg b lh mg lj lk ll mh ln lo lp mi lr ls lt mj lv lw lx mk lz ma mb im bi translated">例如，如果我们有<code class="fe mc md me mf b">doWork</code>函数:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="dace" class="mt kh it mf b gy mu mv l mw mx">const doWork = (): void =&gt; {<br/>  doFirst();<br/>  doSecond();<br/>};</span></pre><p id="baa0" class="pw-post-body-paragraph le lf it lg b lh mg lj lk ll mh ln lo lp mi lr ls lt mj lv lw lx mk lz ma mb im bi translated">我们应该调用<code class="fe mc md me mf b">doWork</code>而不使用它的返回值。</p><p id="0016" class="pw-post-body-paragraph le lf it lg b lh mg lj lk ll mh ln lo lp mi lr ls lt mj lv lw lx mk lz ma mb im bi translated">所以与其写:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="a492" class="mt kh it mf b gy mu mv l mw mx">console.log(doWork());</span></pre><p id="5ee7" class="pw-post-body-paragraph le lf it lg b lh mg lj lk ll mh ln lo lp mi lr ls lt mj lv lw lx mk lz ma mb im bi translated">我们写道:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="9a39" class="mt kh it mf b gy mu mv l mw mx">doWork()</span></pre><h1 id="b0dd" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">没有条件表达式</h1><p id="63b9" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">我们应该使用条件表达式，而不是给语句的每个分支分配相同的内容。</p><p id="7d03" class="pw-post-body-paragraph le lf it lg b lh mg lj lk ll mh ln lo lp mi lr ls lt mj lv lw lx mk lz ma mb im bi translated">例如，不写:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="61d1" class="mt kh it mf b gy mu mv l mw mx">let foo;<br/>if (cond) [<br/>  foo = 1;<br/>}<br/>else {<br/>  foo = 2;<br/>}</span></pre><p id="1e16" class="pw-post-body-paragraph le lf it lg b lh mg lj lk ll mh ln lo lp mi lr ls lt mj lv lw lx mk lz ma mb im bi translated">我们写道:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="5654" class="mt kh it mf b gy mu mv l mw mx">let foo = cond ? 1: 2;</span></pre><p id="5137" class="pw-post-body-paragraph le lf it lg b lh mg lj lk ll mh ln lo lp mi lr ls lt mj lv lw lx mk lz ma mb im bi translated">它要短得多，也容易阅读。</p><h1 id="8f0b" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">使用对象扩散</h1><p id="3d72" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">对象扩散从ES2018开始就是一个特性，所以我们应该用它来代替<code class="fe mc md me mf b">Object.assign</code>。</p><p id="6c2c" class="pw-post-body-paragraph le lf it lg b lh mg lj lk ll mh ln lo lp mi lr ls lt mj lv lw lx mk lz ma mb im bi translated">例如，不写:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="0396" class="mt kh it mf b gy mu mv l mw mx">const baz = Object.assign({}, foo, bar);</span></pre><p id="3f24" class="pw-post-body-paragraph le lf it lg b lh mg lj lk ll mh ln lo lp mi lr ls lt mj lv lw lx mk lz ma mb im bi translated">我们写道:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="16e9" class="mt kh it mf b gy mu mv l mw mx">const baz = {...foo, ...bar};</span></pre><h1 id="49cc" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">包括parseInt中的Radix参数</h1><p id="160f" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">我们应该在调用<code class="fe mc md me mf b">parseInt</code>时包含基数参数，这样它就可以把值解析成我们想要的基数。</p><p id="9b41" class="pw-post-body-paragraph le lf it lg b lh mg lj lk ll mh ln lo lp mi lr ls lt mj lv lw lx mk lz ma mb im bi translated">它也不会假定我们基于值解析的数字的基数。</p><p id="f817" class="pw-post-body-paragraph le lf it lg b lh mg lj lk ll mh ln lo lp mi lr ls lt mj lv lw lx mk lz ma mb im bi translated">例如，不写:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="3685" class="mt kh it mf b gy mu mv l mw mx">const x: string = '12';<br/>const dec: number = parseInt(x);</span></pre><p id="e7f8" class="pw-post-body-paragraph le lf it lg b lh mg lj lk ll mh ln lo lp mi lr ls lt mj lv lw lx mk lz ma mb im bi translated">我们写道:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="3bfa" class="mt kh it mf b gy mu mv l mw mx">const x: string = '12';<br/>const dec: number = parseInt(x, 10);</span></pre><h1 id="f987" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">使用加号运算符时，操作数应为字符串或数字类型</h1><p id="b2ac" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">当我们使用<code class="fe mc md me mf b">+</code>操作符时，我们应该确保它们都是字符串的数字。</p><p id="ea27" class="pw-post-body-paragraph le lf it lg b lh mg lj lk ll mh ln lo lp mi lr ls lt mj lv lw lx mk lz ma mb im bi translated">这样，我们知道我们肯定是在添加或连接。</p><p id="4d47" class="pw-post-body-paragraph le lf it lg b lh mg lj lk ll mh ln lo lp mi lr ls lt mj lv lw lx mk lz ma mb im bi translated">例如，不写:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="5c9a" class="mt kh it mf b gy mu mv l mw mx">const foo = 'foo' + 1;</span></pre><p id="44cd" class="pw-post-body-paragraph le lf it lg b lh mg lj lk ll mh ln lo lp mi lr ls lt mj lv lw lx mk lz ma mb im bi translated">我们写道:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="158e" class="mt kh it mf b gy mu mv l mw mx">const foo = 'foo' + 'bar';</span></pre><p id="2646" class="pw-post-body-paragraph le lf it lg b lh mg lj lk ll mh ln lo lp mi lr ls lt mj lv lw lx mk lz ma mb im bi translated">或者:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="be95" class="mt kh it mf b gy mu mv l mw mx">const sum = 1 + 2;</span></pre><h1 id="6408" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">在静态方法中不使用它</h1><p id="127d" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">我们不应该在静态方法中使用<code class="fe mc md me mf b">this</code>。</p><p id="dfe2" class="pw-post-body-paragraph le lf it lg b lh mg lj lk ll mh ln lo lp mi lr ls lt mj lv lw lx mk lz ma mb im bi translated">它们不应该引用<code class="fe mc md me mf b">this</code>，因为它们不会引用我们期望的值，也就是类实例。</p><p id="8017" class="pw-post-body-paragraph le lf it lg b lh mg lj lk ll mh ln lo lp mi lr ls lt mj lv lw lx mk lz ma mb im bi translated">例如，代替书写；</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="c55c" class="mt kh it mf b gy mu mv l mw mx">class Foo {<br/>  static foo() {<br/>    return 'foo';<br/>  }</span><span id="2398" class="mt kh it mf b gy my mv l mw mx">  static bar() {<br/>    return `bar${this.foo()}`;<br/>  }<br/>}</span></pre><p id="8085" class="pw-post-body-paragraph le lf it lg b lh mg lj lk ll mh ln lo lp mi lr ls lt mj lv lw lx mk lz ma mb im bi translated">我们写道:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="b6dd" class="mt kh it mf b gy mu mv l mw mx">class Foo {<br/>  foo() {<br/>    return 'foo';<br/>  }</span><span id="8ec0" class="mt kh it mf b gy my mv l mw mx">  bar() {<br/>    return `bar${this.foo()}`;<br/>  }<br/>}</span></pre><h1 id="73ae" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">严格比较</h1><p id="d7c1" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">我们应该确保使用<code class="fe mc md me mf b">===</code>和<code class="fe mc md me mf b">!==</code>进行等式比较。</p><p id="2afb" class="pw-post-body-paragraph le lf it lg b lh mg lj lk ll mh ln lo lp mi lr ls lt mj lv lw lx mk lz ma mb im bi translated">他们检查数据的类型和值。</p><p id="d999" class="pw-post-body-paragraph le lf it lg b lh mg lj lk ll mh ln lo lp mi lr ls lt mj lv lw lx mk lz ma mb im bi translated">所以与其写:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="513b" class="mt kh it mf b gy mu mv l mw mx">x == 1;</span></pre><p id="2599" class="pw-post-body-paragraph le lf it lg b lh mg lj lk ll mh ln lo lp mi lr ls lt mj lv lw lx mk lz ma mb im bi translated">我们写道:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="aeb1" class="mt kh it mf b gy mu mv l mw mx">x === 1;</span></pre><p id="0bbb" class="pw-post-body-paragraph le lf it lg b lh mg lj lk ll mh ln lo lp mi lr ls lt mj lv lw lx mk lz ma mb im bi translated">在比较之前避免任何数据类型强制。</p><h1 id="7cf5" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">严格字符串表达式</h1><p id="ffa6" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">我们应该使用模板文字插值，而不是使用字符串连接。</p><p id="d3f4" class="pw-post-body-paragraph le lf it lg b lh mg lj lk ll mh ln lo lp mi lr ls lt mj lv lw lx mk lz ma mb im bi translated">例如，不写:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="697d" class="mt kh it mf b gy mu mv l mw mx">'foo' + bar</span></pre><p id="46e2" class="pw-post-body-paragraph le lf it lg b lh mg lj lk ll mh ln lo lp mi lr ls lt mj lv lw lx mk lz ma mb im bi translated">我们写道:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="cf3b" class="mt kh it mf b gy mu mv l mw mx">`foo ${bar}`</span></pre><h1 id="45f2" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">添加带有Switch语句的Default子句</h1><p id="39f8" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">我们应该添加一个带有<code class="fe mc md me mf b">switch</code>语句的<code class="fe mc md me mf b">default</code>子句，这样当没有一个<code class="fe mc md me mf b">case</code>与值匹配时，我们可以做些什么。</p><p id="2333" class="pw-post-body-paragraph le lf it lg b lh mg lj lk ll mh ln lo lp mi lr ls lt mj lv lw lx mk lz ma mb im bi translated">例如，代替书写:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="89ef" class="mt kh it mf b gy mu mv l mw mx">let foo: number = 1;<br/>switch (foo) {<br/>  case 1:<br/>    doSomething();<br/>    break;<br/>  case 2:<br/>    doMore();<br/>}</span></pre><p id="0429" class="pw-post-body-paragraph le lf it lg b lh mg lj lk ll mh ln lo lp mi lr ls lt mj lv lw lx mk lz ma mb im bi translated">我们写道:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="12bc" class="mt kh it mf b gy mu mv l mw mx">let foo: number = 1;<br/>switch (foo) {<br/>  case 1:<br/>    doSomething();<br/>    break;<br/>  case 2:<br/>    doMore();<br/>    break;<br/>  default:<br/>    console.log('default');<br/>}</span></pre><h1 id="2105" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">将typeof与正确的字符串值进行比较</h1><p id="96d2" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">我们应该将<code class="fe mc md me mf b">typeof</code>与正确的字符串值进行比较。</p><p id="70b4" class="pw-post-body-paragraph le lf it lg b lh mg lj lk ll mh ln lo lp mi lr ls lt mj lv lw lx mk lz ma mb im bi translated"><code class="fe mc md me mf b">typeof</code>只能为类型返回几个字符串值。</p><p id="834c" class="pw-post-body-paragraph le lf it lg b lh mg lj lk ll mh ln lo lp mi lr ls lt mj lv lw lx mk lz ma mb im bi translated">所以我们应该与他们进行比较，确保我们没有任何错别字。</p><p id="15ef" class="pw-post-body-paragraph le lf it lg b lh mg lj lk ll mh ln lo lp mi lr ls lt mj lv lw lx mk lz ma mb im bi translated">例如，不写:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="7307" class="mt kh it mf b gy mu mv l mw mx">typeof foo === 'undefimed';</span></pre><p id="aa15" class="pw-post-body-paragraph le lf it lg b lh mg lj lk ll mh ln lo lp mi lr ls lt mj lv lw lx mk lz ma mb im bi translated">我们写道:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="774e" class="mt kh it mf b gy mu mv l mw mx">typeof foo === 'undefined';</span></pre><h1 id="4f31" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">没有不必要的构造函数</h1><p id="d478" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">我们不应该有多余的构造函数。</p><p id="5068" class="pw-post-body-paragraph le lf it lg b lh mg lj lk ll mh ln lo lp mi lr ls lt mj lv lw lx mk lz ma mb im bi translated">JavaScript会在没有它的情况下为我们添加它们。</p><p id="25be" class="pw-post-body-paragraph le lf it lg b lh mg lj lk ll mh ln lo lp mi lr ls lt mj lv lw lx mk lz ma mb im bi translated">例如，不写:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="9a0d" class="mt kh it mf b gy mu mv l mw mx">class A {<br/>  constructor(){}<br/>}</span></pre><p id="65f6" class="pw-post-body-paragraph le lf it lg b lh mg lj lk ll mh ln lo lp mi lr ls lt mj lv lw lx mk lz ma mb im bi translated">或者</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="f379" class="mt kh it mf b gy mu mv l mw mx">class A extends B {<br/>  constructor(){<br/>    super();<br/>  }<br/>}</span></pre><p id="3133" class="pw-post-body-paragraph le lf it lg b lh mg lj lk ll mh ln lo lp mi lr ls lt mj lv lw lx mk lz ma mb im bi translated">我们写道:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="44fd" class="mt kh it mf b gy mu mv l mw mx">class A {<br/>  constructor(name){<br/>    this.name = name;<br/>  }<br/>}</span></pre><p id="c594" class="pw-post-body-paragraph le lf it lg b lh mg lj lk ll mh ln lo lp mi lr ls lt mj lv lw lx mk lz ma mb im bi translated">或者</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="888e" class="mt kh it mf b gy mu mv l mw mx">class A extends B {<br/>  constructor(bar){<br/>    super(bar);<br/>  }<br/>}</span></pre><h1 id="2e16" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">默认类型参数</h1><p id="88b6" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">我们可以给泛型类型参数添加一个默认的类型值。</p><p id="3d92" class="pw-post-body-paragraph le lf it lg b lh mg lj lk ll mh ln lo lp mi lr ls lt mj lv lw lx mk lz ma mb im bi translated">例如，不写:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="f8e8" class="mt kh it mf b gy mu mv l mw mx">function foo&lt;N, S&gt;() {}</span></pre><p id="a389" class="pw-post-body-paragraph le lf it lg b lh mg lj lk ll mh ln lo lp mi lr ls lt mj lv lw lx mk lz ma mb im bi translated">我们可以写:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="f813" class="mt kh it mf b gy mu mv l mw mx">function foo&lt;N = number, S = string&gt;() {}</span></pre><p id="a91a" class="pw-post-body-paragraph le lf it lg b lh mg lj lk ll mh ln lo lp mi lr ls lt mj lv lw lx mk lz ma mb im bi translated">这样，泛型类型参数将总是用实参来设置。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/dac03bfa8767129cff196293e7723c69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CmsYGqpDGRulIBvt"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">图为<a class="ae kf" href="https://unsplash.com/@clo_shooting?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">克洛维斯伍德</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></figcaption></figure><h1 id="1471" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">结论</h1><p id="8124" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">我们可以向泛型类型参数添加默认类型。</p><p id="da23" class="pw-post-body-paragraph le lf it lg b lh mg lj lk ll mh ln lo lp mi lr ls lt mj lv lw lx mk lz ma mb im bi translated"><code class="fe mc md me mf b">void</code>表达式不应该作为值使用。</p><p id="ca46" class="pw-post-body-paragraph le lf it lg b lh mg lj lk ll mh ln lo lp mi lr ls lt mj lv lw lx mk lz ma mb im bi translated">条件表达式、对象扩展、<code class="fe mc md me mf b">parseInt</code>和基数都是我们在代码中应该有的东西。</p></div></div>    
</body>
</html>