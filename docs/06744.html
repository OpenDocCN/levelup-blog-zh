<html>
<head>
<title>Game of Life in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的生命游戏</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/game-of-life-on-python-6aaf5fd58ee3?source=collection_archive---------0-----------------------#2020-12-26">https://levelup.gitconnected.com/game-of-life-on-python-6aaf5fd58ee3?source=collection_archive---------0-----------------------#2020-12-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/848d21f706689126da95c7fa5dcf4ca8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TxQU6pBy-kwsAFWPfBSBtg.png"/></div></div></figure><p id="5a93" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不知道的话，人生的游戏是对人口的模拟。</p><div class="kw kx gp gr ky kz"><a href="https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life" rel="noopener  ugc nofollow" target="_blank"><div class="la ab fo"><div class="lb ab lc cl cj ld"><h2 class="bd ir gy z fp le fr fs lf fu fw ip bi translated">康威的生活游戏</h2><div class="lg l"><h3 class="bd b gy z fp le fr fs lf fu fw dk translated">生命的游戏，也简称为生命，是由英国数学家约翰·霍顿设计的细胞自动机…</h3></div><div class="lh l"><p class="bd b dl z fp le fr fs lf fu fw dk translated">en.wikipedia.org</p></div></div><div class="li l"><div class="lj l lk ll lm li ln jw kz"/></div></div></a></div><p id="ca72" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">维基百科页面解释了生命游戏的基本规则，以及如何决定一个方块的状态。</p><figure class="lo lp lq lr gt jr"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="986d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你是一个视觉学习者，这个视频也给了你一个直观的解释。</p><h1 id="bf01" class="lu lv iq bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">规则:</h1><p id="ef27" class="pw-post-body-paragraph jy jz iq ka b kb ms kd ke kf mt kh ki kj mu kl km kn mv kp kq kr mw kt ku kv ij bi translated">活着的状态是黑色的，死去的状态是白色的。我们</p><ol class=""><li id="b47c" class="mx my iq ka b kb kc kf kg kj mz kn na kr nb kv nc nd ne nf bi translated">任何少于两个活邻居的活细胞都会死亡，就好像是由于人口减少。</li><li id="dc9a" class="mx my iq ka b kb ng kf nh kj ni kn nj kr nk kv nc nd ne nf bi translated">任何有两个或三个活邻居的活细胞都会延续到下一代。</li><li id="0283" class="mx my iq ka b kb ng kf nh kj ni kn nj kr nk kv nc nd ne nf bi translated">任何有三个以上活邻居的活细胞都会死亡，好像是由于人口过多。</li><li id="4c3e" class="mx my iq ka b kb ng kf nh kj ni kn nj kr nk kv nc nd ne nf bi translated">任何一个死细胞，只要有三个活的邻居，就会变成活细胞，就像通过繁殖一样。</li></ol><p id="dd5d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你看一下代码，你可能会意识到它使用了与国际象棋网格非常相似的代码，这是因为这个程序的大部分是带有新逻辑的国际象棋的副本。所以我复制了大部分的网格设置(我可能也不小心留下了象棋代码的新注释)。</p><h1 id="d760" class="lu lv iq bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">完整代码</h1><p id="1658" class="pw-post-body-paragraph jy jz iq ka b kb ms kd ke kf mt kh ki kj mu kl km kn mv kp kq kr mw kt ku kv ij bi translated">首先我会分享完整的代码，然后解释如下。</p><pre class="lo lp lq lr gt nl nm nn no aw np bi"><span id="3e73" class="nq lv iq nm b gy nr ns l nt nu">import pygame<br/>import sys</span><span id="8636" class="nq lv iq nm b gy nv ns l nt nu">WIDTH = 800<br/>ROWS = 20<br/>WIN = pygame.display.set_mode((WIDTH, WIDTH))</span><span id="0a77" class="nq lv iq nm b gy nv ns l nt nu">pygame.display.set_caption("Game of Life")</span><span id="e52a" class="nq lv iq nm b gy nv ns l nt nu">WHITE = (255, 255, 255)<br/>BLACK = (0, 0, 0)</span><span id="3839" class="nq lv iq nm b gy nv ns l nt nu">class Node:<br/>    def __init__(self, row, col, width):<br/>        self.row = row</span><span id="e102" class="nq lv iq nm b gy nv ns l nt nu">self.col = col</span><span id="7642" class="nq lv iq nm b gy nv ns l nt nu">self.x = int(row * width)</span><span id="fc37" class="nq lv iq nm b gy nv ns l nt nu">self.y = int(col * width)</span><span id="8b79" class="nq lv iq nm b gy nv ns l nt nu">self.colour = WHITE</span><span id="83aa" class="nq lv iq nm b gy nv ns l nt nu">self.occupied = None</span><span id="fd1a" class="nq lv iq nm b gy nv ns l nt nu">def draw(self, WIN):<br/>        pygame.draw.rect(WIN, self.colour, (self.x, self.y, WIDTH / 8, WIDTH / 8))</span><span id="4f70" class="nq lv iq nm b gy nv ns l nt nu">def make_grid(rows, width):<br/>    grid = []</span><span id="0dba" class="nq lv iq nm b gy nv ns l nt nu">gap = WIDTH // rows</span><span id="acfb" class="nq lv iq nm b gy nv ns l nt nu">print(gap)</span><span id="2620" class="nq lv iq nm b gy nv ns l nt nu">for i in range(rows):</span><span id="d6a0" class="nq lv iq nm b gy nv ns l nt nu">grid.append([])</span><span id="2d63" class="nq lv iq nm b gy nv ns l nt nu">for j in range(rows):<br/>            node = Node(j, i, gap)</span><span id="d09c" class="nq lv iq nm b gy nv ns l nt nu">grid[i].append(node)</span><span id="8b10" class="nq lv iq nm b gy nv ns l nt nu">return grid</span><span id="0c0e" class="nq lv iq nm b gy nv ns l nt nu">def draw_grid(win, rows, width):<br/>    gap = width // ROWS</span><span id="b8e1" class="nq lv iq nm b gy nv ns l nt nu">for i in range(rows):</span><span id="4312" class="nq lv iq nm b gy nv ns l nt nu">pygame.draw.line(win, BLACK, (0, i * gap), (width, i * gap))</span><span id="39de" class="nq lv iq nm b gy nv ns l nt nu">for j in range(rows):<br/>            pygame.draw.line(win, BLACK, (j * gap, 0), (j * gap, width))</span><span id="9cd2" class="nq lv iq nm b gy nv ns l nt nu">"""</span><span id="3666" class="nq lv iq nm b gy nv ns l nt nu">The nodes are all white so this we need to draw the grey lines that separate all the chess tiles</span><span id="d212" class="nq lv iq nm b gy nv ns l nt nu">from each other and that is what this function does"""</span><span id="95d7" class="nq lv iq nm b gy nv ns l nt nu">def update_display(win, grid, rows, width):<br/>    for row in grid:</span><span id="b857" class="nq lv iq nm b gy nv ns l nt nu">for spot in row:<br/>            spot.draw(win)</span><span id="44ef" class="nq lv iq nm b gy nv ns l nt nu">draw_grid(win, rows, width)</span><span id="64d3" class="nq lv iq nm b gy nv ns l nt nu">pygame.display.update()</span><span id="5463" class="nq lv iq nm b gy nv ns l nt nu">def Find_Node(pos, WIDTH):<br/>    interval = WIDTH / ROWS</span><span id="7b07" class="nq lv iq nm b gy nv ns l nt nu">y, x = pos</span><span id="700b" class="nq lv iq nm b gy nv ns l nt nu">rows = y // interval</span><span id="3d6a" class="nq lv iq nm b gy nv ns l nt nu">columns = x // interval</span><span id="8249" class="nq lv iq nm b gy nv ns l nt nu">return int(rows), int(columns)</span><span id="edd9" class="nq lv iq nm b gy nv ns l nt nu">def neighbour(tile):<br/>    col, row = tile.row, tile.col</span><span id="62ef" class="nq lv iq nm b gy nv ns l nt nu"># print(row, col)</span><span id="b4e7" class="nq lv iq nm b gy nv ns l nt nu">neighbours = [[row - 1, col - 1], [row - 1, col], [row - 1, col + 1],<br/>                  [row, col - 1], [row, col + 1],<br/>                  [row + 1, col - 1], [row + 1, col], [row + 1, col + 1], ]</span><span id="6de9" class="nq lv iq nm b gy nv ns l nt nu">actual = []</span><span id="0d59" class="nq lv iq nm b gy nv ns l nt nu">for i in neighbours:<br/>        row, col = i</span><span id="3dba" class="nq lv iq nm b gy nv ns l nt nu">if 0 &lt;= row &lt;= (ROWS - 1) and 0 &lt;= col &lt;= (ROWS - 1):<br/>            actual.append(i)<br/>    # print(row, col, actual)<br/>    return actual</span><span id="8cbd" class="nq lv iq nm b gy nv ns l nt nu">def update_grid(grid):<br/>    newgrid = []<br/>    for row in grid:<br/>        for tile in row:<br/>            neighbours = neighbour(tile)<br/>            count = 0<br/>            for i in neighbours:<br/>                row, col = i<br/>                if grid[row][col].colour == BLACK:<br/>                    count += 1</span><span id="d891" class="nq lv iq nm b gy nv ns l nt nu">if tile.colour == BLACK:<br/>                if count == 2 or count == 3:<br/>                    newgrid.append(BLACK)<br/>                else:<br/>                    newgrid.append(WHITE)</span><span id="08fa" class="nq lv iq nm b gy nv ns l nt nu">else:<br/>                if count == 3:<br/>                    newgrid.append(BLACK)<br/>                else:<br/>                    newgrid.append(WHITE)</span><span id="6e89" class="nq lv iq nm b gy nv ns l nt nu">return newgrid</span><span id="f655" class="nq lv iq nm b gy nv ns l nt nu">def main(WIN, WIDTH):<br/>    run = None<br/>    grid = make_grid(ROWS, WIDTH)</span><span id="d894" class="nq lv iq nm b gy nv ns l nt nu">while True:<br/>        pygame.time.delay(50)  ##stops cpu dying<br/>        for event in pygame.event.get():<br/>            if event.type == pygame.QUIT:<br/>                pygame.quit()<br/>                sys.exit()</span><span id="c79c" class="nq lv iq nm b gy nv ns l nt nu">if event.type == pygame.KEYDOWN:<br/>                if event.key == pygame.K_SPACE:<br/>                    run = True</span><span id="51f7" class="nq lv iq nm b gy nv ns l nt nu">if event.type == pygame.MOUSEBUTTONDOWN:<br/>                pos = pygame.mouse.get_pos()<br/>                row, col = Find_Node(pos, WIDTH)<br/>                if grid[col][row].colour == WHITE:<br/>                    grid[col][row].colour = BLACK</span><span id="321a" class="nq lv iq nm b gy nv ns l nt nu">elif grid[col][row].colour == BLACK:<br/>                    grid[col][row].colour = WHITE</span><span id="3252" class="nq lv iq nm b gy nv ns l nt nu">while run:<br/>                for event in pygame.event.get():<br/>                    if event.type == pygame.MOUSEBUTTONDOWN:<br/>                        run = False</span><span id="3ca9" class="nq lv iq nm b gy nv ns l nt nu">#pygame.time.delay(50)<br/>                newcolours = update_grid(grid)<br/>                count=0<br/>                for i in range(0,len(grid[0])):<br/>                    for j in range(0, len(grid[0])):<br/>                        grid[i][j].colour=newcolours[count]<br/>                        count+=1<br/>                update_display(WIN, grid, ROWS, WIDTH)<br/>                #run= False</span><span id="3487" class="nq lv iq nm b gy nv ns l nt nu">update_display(WIN, grid, ROWS, WIDTH)</span><span id="3a3d" class="nq lv iq nm b gy nv ns l nt nu">main(WIN, WIDTH)</span></pre><h1 id="1e36" class="lu lv iq bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">代码解释:</h1><pre class="lo lp lq lr gt nl nm nn no aw np bi"><span id="d39e" class="nq lv iq nm b gy nr ns l nt nu">import pygame<br/>import sys<br/><br/>WIDTH = 800<br/>ROWS = 20<br/>WIN = pygame.display.set_mode((WIDTH, WIDTH))<br/><br/>pygame.display.set_caption("Game of Life")<br/><br/>WHITE = (255, 255, 255)<br/>BLACK = (0, 0, 0)<br/><br/><br/>class Node:<br/>    def __init__(self, row, col, width):<br/>        self.row = row<br/><br/>        self.col = col<br/><br/>        self.x = int(row * width)<br/><br/>        self.y = int(col * width)<br/><br/>        self.colour = WHITE<br/><br/>        self.occupied = None<br/><br/>    def draw(self, WIN):<br/>        pygame.draw.rect(WIN, self.colour, (self.x, self.y, WIDTH / 8, WIDTH / 8))<br/><br/><br/>def make_grid(rows, width):<br/>    grid = []<br/><br/>    gap = WIDTH // rows<br/><br/>    print(gap)<br/><br/>    for i in range(rows):<br/><br/>        grid.append([])<br/><br/>        for j in range(rows):<br/>            node = Node(j, i, gap)<br/><br/>            grid[i].append(node)<br/><br/>    return grid<br/><br/><br/>def draw_grid(win, rows, width):<br/>    gap = width // ROWS<br/><br/>    for i in range(rows):<br/><br/>        pygame.draw.line(win, BLACK, (0, i * gap), (width, i * gap))<br/><br/>        for j in range(rows):<br/>            pygame.draw.line(win, BLACK, (j * gap, 0), (j * gap, width))<br/><br/>    """<br/><br/>    The nodes are all white so this we need to draw the grey lines that separate all the chess tiles<br/><br/>    from each other and that is what this function does"""<br/><br/><br/>def update_display(win, grid, rows, width):<br/>    for row in grid:<br/><br/>        for spot in row:<br/>            spot.draw(win)<br/><br/>    draw_grid(win, rows, width)<br/><br/>    pygame.display.update()<br/><br/><br/>def Find_Node(pos, WIDTH):<br/>    interval = WIDTH / ROWS<br/><br/>    y, x = pos<br/><br/>    rows = y // interval<br/><br/>    columns = x // interval<br/><br/>    return int(rows), int(columns)</span></pre><p id="c0f2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所有这些代码都是我做的象棋程序的副本，我基本上只是用一个我称之为节点的类来创建网格的瓦片。如果你想要一个网格的解释，我推荐你去看看我的象棋代码。</p><ul class=""><li id="6168" class="mx my iq ka b kb kc kf kg kj mz kn na kr nb kv nw nd ne nf bi translated">draw——我用来在窗口上绘制节点的方法，注意——这些节点周围没有黑色边框，所以我们需要单独添加这些节点。</li><li id="99fb" class="mx my iq ka b kb ng kf nh kj ni kn nj kr nk kv nw nd ne nf bi translated">make_grid在程序开始时被调用，它将创建一个充满节点元素的初始2d数组，用来表示网格。嵌套循环将会定期自动设置节点在屏幕上的位置</li><li id="6859" class="mx my iq ka b kb ng kf nh kj ni kn nj kr nk kv nw nd ne nf bi translated">正如我前面所说的，当我们在屏幕上画正方形时，当它们是白色时，它们不会立即有边界，例如，如果我们在屏幕上画一个白色的正方形，它的边界也将是白色的，因为我们窗口的背景颜色自动是白色的，这意味着它将融入背景，也融入相同颜色的其他节点。因此，该函数将绘制黑线来分隔所有节点。</li><li id="bc2a" class="mx my iq ka b kb ng kf nh kj ni kn nj kr nk kv nw nd ne nf bi translated">update _ display——对于每个tick，我们需要用已经做出的任何更改来更新屏幕，所以我们在while True循环的末尾使用这个函数来更新屏幕。我们通过再次调用draw方法来做到这一点，如果发生了任何变化(当发生变化时，我们改变节点颜色)，这将出现在屏幕上。</li><li id="a398" class="mx my iq ka b kb ng kf nh kj ni kn nj kr nk kv nw nd ne nf bi translated">使用Find_Node是因为如果我们单击屏幕，房子的坐标将在800 x 800的范围内(因为它是窗口上的坐标),而我们想要一个较小范围内的数组网格的索引。这是我们使用mod(%)转换成网格索引的地方，该索引对应于我们单击屏幕时鼠标所在的节点。</li></ul><pre class="lo lp lq lr gt nl nm nn no aw np bi"><span id="f184" class="nq lv iq nm b gy nr ns l nt nu">def neighbour(tile):<br/>    col, row = tile.row, tile.col<br/><br/>    # print(row, col)<br/><br/>    neighbours = [[row - 1, col - 1], [row - 1, col], [row - 1, col + 1],<br/>                  [row, col - 1], [row, col + 1],<br/>                  [row + 1, col - 1], [row + 1, col], [row + 1, col + 1], ]<br/><br/>    actual = []<br/><br/>    for i in neighbours:<br/>        row, col = i<br/><br/>        if 0 &lt;= row &lt;= (ROWS - 1) and 0 &lt;= col &lt;= (ROWS - 1):<br/>            actual.append(i)<br/>    # print(row, col, actual)<br/>    return actual<br/><br/><br/>def update_grid(grid):<br/>    newgrid = []<br/>    for row in grid:<br/>        for tile in row:<br/>            neighbours = neighbour(tile)<br/>            count = 0<br/>            for i in neighbours:<br/>                row, col = i<br/>                if grid[row][col].colour == BLACK:<br/>                    count += 1<br/><br/>            if tile.colour == BLACK:<br/>                if count == 2 or count == 3:<br/>                    newgrid.append(BLACK)<br/>                else:<br/>                    newgrid.append(WHITE)<br/><br/>            else:<br/>                if count == 3:<br/>                    newgrid.append(BLACK)<br/>                else:<br/>                    newgrid.append(WHITE)<br/><br/>    return newgrid<br/><br/><br/>def main(WIN, WIDTH):<br/>    run = None<br/>    grid = make_grid(ROWS, WIDTH)<br/><br/>    while True:<br/>        pygame.time.delay(50)  ##stops cpu dying<br/>        for event in pygame.event.get():<br/>            if event.type == pygame.QUIT:<br/>                pygame.quit()<br/>                sys.exit()<br/><br/>            if event.type == pygame.KEYDOWN:<br/>                if event.key == pygame.K_SPACE:<br/>                    run = True<br/><br/>            if event.type == pygame.MOUSEBUTTONDOWN:<br/>                pos = pygame.mouse.get_pos()<br/>                row, col = Find_Node(pos, WIDTH)<br/>                if grid[col][row].colour == WHITE:<br/>                    grid[col][row].colour = BLACK<br/><br/>                elif grid[col][row].colour == BLACK:<br/>                    grid[col][row].colour = WHITE<br/><br/>            while run:<br/>                for event in pygame.event.get():<br/>                    if event.type == pygame.MOUSEBUTTONDOWN:<br/>                        run = False<br/><br/>                #pygame.time.delay(50)<br/>                newcolours = update_grid(grid)<br/>                count=0<br/>                for i in range(0,len(grid[0])):<br/>                    for j in range(0, len(grid[0])):<br/>                        grid[i][j].colour=newcolours[count]<br/>                        count+=1<br/>                update_display(WIN, grid, ROWS, WIDTH)<br/>                #run= False<br/><br/>            update_display(WIN, grid, ROWS, WIDTH)<br/><br/><br/>main(WIN, WIDTH)</span></pre><p id="fc0e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面的代码是我为了让它工作而编写的新代码。此外，我想再次感谢埃德温，因为我在使用[列][行]索引2D数组的代码中犯了一些非常愚蠢的逻辑错误，我无法调试逻辑错误所在，埃德温是为我找到逻辑错误并修复代码的人。</p><h1 id="fc0b" class="lu lv iq bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">邻居:</h1><p id="7326" class="pw-post-body-paragraph jy jz iq ka b kb ms kd ke kf mt kh ki kj mu kl km kn mv kp kq kr mw kt ku kv ij bi translated">这个函数非常类似于我们在国际象棋程序中放入棋子的逻辑，但现在我们只是取我们所在的节点的位置，然后检查它的每个邻居，如果它们在网格的范围内，那么它们被放入我们返回的2D数组中</p><p id="6986" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">注意:这是一种非常低效的方式来确定我们想要切换到活动/死亡的节点，一种更高效的方式是在屏幕上添加活动节点，并在它周围的所有节点上增加一个计数器，然后计算出该节点应该是活动的还是死亡的。这种方式仍然有效，但是你的CPU不会很享受。</strong></p><h1 id="4277" class="lu lv iq bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">更新网格:</h1><p id="02c5" class="pw-post-body-paragraph jy jz iq ka b kb ms kd ke kf mt kh ki kj mu kl km kn mv kp kq kr mw kt ku kv ij bi translated">这个函数将会计算出在下一次窗口更新中哪些图块将变得活跃和不活跃。你可能想知道为什么我没有立即直接在图块上实现颜色更改，而是将它放入一个数组中，我这样做是因为如果你立即更新这些值，这个新值将影响下一次对它旁边的图块进行检查的结果，所以我们需要在实现更改之前计算所有的节点。如果你了解线性回归，尤其是其中的梯度下降，这就是为什么我们在完成所有涉及梯度下降方程的计算后更新所有参数。if语句也是我们实现前面展示的规则的地方，这是我们决定图块在程序的下一次迭代中是死是活的地方。</p><h1 id="6f2b" class="lu lv iq bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">主要:</h1><p id="30f9" class="pw-post-body-paragraph jy jz iq ka b kb ms kd ke kf mt kh ki kj mu kl km kn mv kp kq kr mw kt ku kv ij bi translated">程序启动时运行的是主循环。我们通过让用户点击空格按钮来开始游戏，当他们点击时，它将运行状态切换到True，这将启动一个无限循环，在这里运行我们所做的计算函数。在此之前，我们让用户能够点击任何瓷砖，然后我们将它涂成黑色(活着)，如果他们点击一个活瓷砖，它会把它变回死。这允许用户定制他们想要的任何开始安排，也帮助我和Edwin验证了程序中的逻辑实际上工作正常。</p><p id="4568" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是人生完整的游戏！我记得大概就在一个月前看这个程序，认为这是一个非常难的程序，完全超出了我的能力范围，但所有的代码都在2小时内完成，这让我感到震惊(尽管这确实涉及到我从未发现的逻辑错误(edwin发现))。</p></div></div>    
</body>
</html>