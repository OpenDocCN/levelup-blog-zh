<html>
<head>
<title>A Hash Table Walks Into a Bar…</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">哈希表走进酒吧…</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/the-hash-table-4e02f7052440?source=collection_archive---------1-----------------------#2017-11-10">https://levelup.gitconnected.com/the-hash-table-4e02f7052440?source=collection_archive---------1-----------------------#2017-11-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="io ip gp gr iq ir"><div class="bz fp l di"><div class="is it l"/></div></figure><div class=""/><p id="2bd5" class="pw-post-body-paragraph jt ju iw jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ij bi translated">在我们之前的文章中，我们已经讨论了二叉查找树(BST)及其属性。我们回顾了它的O(log n)的Big-O符号，并讨论了它的当代替代品:哈希表。在这篇文章中，我们将剥离散列表(HT)的一些层，它的用途和它如何比较。</p><h2 id="fbbb" class="kr ks iw bd kt ku kv dn kw kx ky dp kz ke la lb lc ki ld le lf km lg lh li lj bi translated"><strong class="ak">数据结构</strong></h2><p id="0e2a" class="pw-post-body-paragraph jt ju iw jv b jw lk jy jz ka ll kc kd ke lm kg kh ki ln kk kl km lo ko kp kq ij bi translated">就像BST一样，HT是另一种数据结构——然而，与树不同，HT使用关联数组(一个数组和一个散列函数的组合)将其元素存储在可以快速轻松访问的键值对中。每个键被分解成数组中的“桶”,每个桶包含一个或多个值——为了防止对象具有相同键时的冲突，每个桶都可以成为链表(我们将在后面讨论)。</p><p id="ef4b" class="pw-post-body-paragraph jt ju iw jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ij bi translated">因此，如果我们想要将个人的电话号码存储在一个集合中并快速检索它们，实现一个散列表看起来有点像这样:</p><figure class="lq lr ls lt gt ir gh gi paragraph-image"><div class="gh gi lp"><img src="../Images/dae145e11ca730c75a909039fb243ce8.png" data-original-src="https://miro.medium.com/v2/resize:fit:630/format:webp/1*nzISDLbkF67C-BTQtFc_DQ.png"/></div></figure><h2 id="e45c" class="kr ks iw bd kt ku kv dn kw kx ky dp kz ke la lb lc ki ld le lf km lg lh li lj bi translated">哈希函数</h2><p id="45e1" class="pw-post-body-paragraph jt ju iw jv b jw lk jy jz ka ll kc kd ke lm kg kh ki ln kk kl km lo ko kp kq ij bi translated">HT的关键元素是散列函数。根据维基百科的定义:</p><blockquote class="lw lx ly"><p id="44bd" class="jt ju lz jv b jw jx jy jz ka kb kc kd ma kf kg kh mb kj kk kl mc kn ko kp kq ij bi translated">一个<strong class="jv ix">散列函数</strong>是任何一个<strong class="jv ix">函数</strong>，可以用来将任意大小的数据映射到固定大小的数据。由<strong class="jv ix">散列函数</strong>返回的值被称为<strong class="jv ix">散列</strong>值、<strong class="jv ix">散列</strong>代码、摘要，或者简称为<strong class="jv ix">散列</strong>。— <a class="ae md" href="https://en.wikipedia.org/wiki/Hash_function" rel="noopener ugc nofollow" target="_blank"> <em class="iw">哈希函数</em> </a></p></blockquote><p id="7752" class="pw-post-body-paragraph jt ju iw jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ij bi translated">由期望的散列函数返回的散列值可以是任何值——尽管它们通常是整数——并且表示每个数据集的键。哈希函数必须是一个纯函数，所以当我们给定相同的输入时，它应该总是给出相同的输出。没有这种一致性，我们将无法查找我们的索引并找到我们刚刚映射到表中的数据。</p><p id="6fd1" class="pw-post-body-paragraph jt ju iw jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ij bi translated">设置索引通常在以下任一步骤中完成:</p><pre class="lq lr ls lt gt me mf mg mh aw mi bi"><span id="1777" class="kr ks iw mf b gy mj mk l ml mm">index = f(key, array_size)</span></pre><p id="8b9f" class="pw-post-body-paragraph jt ju iw jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ij bi translated">或者两步走:</p><pre class="lq lr ls lt gt me mf mg mh aw mi bi"><span id="13e8" class="kr ks iw mf b gy mj mk l ml mm">hash = hashfunc(key)<br/>index = hash % array_size</span></pre><p id="a3c8" class="pw-post-body-paragraph jt ju iw jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ij bi translated">在散列函数中运行了键之后，我们现在就有了表中任何对象/数据的简明引用点。我们所要做的就是获取我们想要查找的关键字，并将其传递给哈希函数，以再次返回相同的索引，并使用该索引来标识在关联数组中的何处查找。与分别具有O(log n)和O(n)的Big-O符号的BST和链表(LL)相比，尽管它依赖于哈希函数的时间和复杂性，但理想情况下，这给了我们的HT一个恒定的查找和插入时间O(1) —太棒了！</p><h2 id="f56c" class="kr ks iw bd kt ku kv dn kw kx ky dp kz ke la lb lc ki ld le lf km lg lh li lj bi translated">碰撞</h2><p id="f492" class="pw-post-body-paragraph jt ju iw jv b jw lk jy jz ka ll kc kd ke lm kg kh ki ln kk kl km lo ko kp kq ij bi translated">如果两个键被散列到同一个索引，我们会以冲突结束。如果我们处理一个固定大小的表，随着数据集的增长，冲突越来越不可避免。没有固定大小的表可能更容易避免这种情况，但是这种类型的表需要大量未使用的空间或浪费的内存。</p><p id="ed2d" class="pw-post-body-paragraph jt ju iw jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ij bi translated">未处理的冲突当然是有问题的，因为我们期望在每个索引中只能找到一个值。为了说明这一点，有几种碰撞方法；最常见的是通过链表进行单独链接。这意味着每个桶包含一个链表，并将我们的常数时间O(1)减少到O(n ),因为一旦我们查找索引，我们将需要遍历列表中条目的数量<em class="lz"> n </em>。我们的电话簿示例的最终结果如下所示:</p><figure class="lq lr ls lt gt ir gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi mn"><img src="../Images/ec99fa9c6a0ede3c3e75b999176e7201.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-BjbJwNd34nP6OYk2TbCdw.png"/></div></div></figure><p id="dcd8" class="pw-post-body-paragraph jt ju iw jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ij bi translated">对于Javascript中的代码示例，我们可以参考以下由Beau Carnes提供的CodePen链接:</p><p id="ca8b" class="pw-post-body-paragraph jt ju iw jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ij bi translated">【https://codepen.io/beaucarnes/pen/VbYGMb?editors=0012 T2】号</p><p id="3f53" class="pw-post-body-paragraph jt ju iw jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ij bi translated">感谢阅读！</p></div></div>    
</body>
</html>