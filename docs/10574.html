<html>
<head>
<title>Find the non-duplicate number in an array.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在数组中寻找不重复的数字。</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/find-the-non-duplicate-number-in-an-array-e7d56544b5d6?source=collection_archive---------7-----------------------#2021-12-22">https://levelup.gitconnected.com/find-the-non-duplicate-number-in-an-array-e7d56544b5d6?source=collection_archive---------7-----------------------#2021-12-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="95b6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">给定一个<strong class="ak">非空的</strong>整数数组，每个元素出现<em class="ki">两次</em>，只有一个除外。找到那个单身的。</h2></div><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/8f01156debe1ad3c1d19d0082ac65a39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SEPTzVF27zBGJMDGFLobJw.png"/></div></div></figure><p id="dd68" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">例如，这个数组[4，3，2，4，1，3，2]的特点是其中包含的所有数字都是重复的，只有一个除外。在这种特殊情况下，不重复的号码是<code class="fe lr ls lt lu b">1</code></p><h1 id="b015" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">第一种解决方案</h1><p id="915e" class="pw-post-body-paragraph kv kw it kx b ky mn ju la lb mo jx ld le mp lg lh li mq lk ll lm mr lo lp lq im bi translated">一个可能的解决方案是使用一个<code class="fe lr ls lt lu b">hashmap</code>并保存数组中每个数字的出现次数。</p><p id="fb91" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">末了<code class="fe lr ls lt lu b">hashmap</code>包含:</p><p id="a1fb" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><code class="fe lr ls lt lu b">4 =&gt; 2</code></p><p id="c9fd" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><code class="fe lr ls lt lu b">3 =&gt; 2</code></p><p id="90bc" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><code class="fe lr ls lt lu b">2 =&gt; 2</code></p><p id="c1ec" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><code class="fe lr ls lt lu b">1 =&gt; 1</code></p><p id="ec45" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><code class="fe lr ls lt lu b">key</code>表示我的数组中的数字，而<code class="fe lr ls lt lu b">value</code>表示出现次数。只需滚动我们的散列表，返回一次出现的值。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ms mt l"/></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk translated">第一种解决方案</figcaption></figure><h2 id="c89d" class="my lw it bd lx mz na dn mb nb nc dp mf le nd ne mh li nf ng mj lm nh ni ml nj bi translated">时间和空间复杂性</h2><p id="11b5" class="pw-post-body-paragraph kv kw it kx b ky mn ju la lb mo jx ld le mp lg lh li mq lk ll lm mr lo lp lq im bi translated">第一个周期的<strong class="kx iu">时间</strong>复杂度为<code class="fe lr ls lt lu b">O(n)</code>，第二个周期的<code class="fe lr ls lt lu b">O(n)</code>。<br/><strong class="kx iu">空间</strong>复杂度等于<code class="fe lr ls lt lu b">O(n)</code>内存中数组大小对应的复杂度。</p></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><h1 id="9f0e" class="lv lw it bd lx ly nr ma mb mc ns me mf jz nt ka mh kc nu kd mj kf nv kg ml mm bi translated">第二种解决方案</h1><p id="1b54" class="pw-post-body-paragraph kv kw it kx b ky mn ju la lb mo jx ld le mp lg lh li mq lk ll lm mr lo lp lq im bi translated">第二个更好的解决方案是使用<code class="fe lr ls lt lu b">XOR</code>操作符。</p><p id="3fa4" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><code class="fe lr ls lt lu b">XOR</code>操作员的简要概述:</p><p id="a5ad" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><code class="fe lr ls lt lu b">1 xor 1 = 0</code></p><p id="b2ad" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><code class="fe lr ls lt lu b">0 xor 0 = 0</code></p><p id="50b5" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><code class="fe lr ls lt lu b">1 xor 0 = 1</code></p><p id="0a7d" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><code class="fe lr ls lt lu b">0 xor 1 = 1</code></p><p id="2d86" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">让我们考虑下面的数组[5，4，5]并执行<code class="fe lr ls lt lu b">xor</code>操作符:</p><p id="c464" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><code class="fe lr ls lt lu b">101 xor 100 =&gt; 001 xor 101 =&gt; 100</code></p><p id="1e6a" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">最后的结果是<code class="fe lr ls lt lu b">100</code>,它对应的<code class="fe lr ls lt lu b">4</code>实际上在我们的数组中只出现过一次。</p><p id="9bbc" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">现在让我们考虑这个数组[5，4，4，5]并执行<code class="fe lr ls lt lu b">xor</code>操作符:</p><p id="9b43" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated"><code class="fe lr ls lt lu b">101 xor 100 =&gt; 001 xor 100 =&gt; 101 xor 101 =&gt; 000</code></p><p id="633b" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">最终结果是<code class="fe lr ls lt lu b">000</code>，在第二个数组中，所有元素都被复制。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ms mt l"/></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk translated">第二种解决方案</figcaption></figure><h2 id="f872" class="my lw it bd lx mz na dn mb nb nc dp mf le nd ne mh li nf ng mj lm nh ni ml nj bi translated">时间和空间复杂性</h2><p id="d932" class="pw-post-body-paragraph kv kw it kx b ky mn ju la lb mo jx ld le mp lg lh li mq lk ll lm mr lo lp lq im bi translated">第二个解决方案的<strong class="kx iu">时间</strong>复杂度是<code class="fe lr ls lt lu b">for</code>循环的<code class="fe lr ls lt lu b">O(n)</code>。<br/><strong class="kx iu">空间</strong>复杂度等于<code class="fe lr ls lt lu b">O(1)</code>，因为在每次迭代中，我们在内存中只有一个数字。</p></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><p id="c57b" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">在结束之前，我建议你喜欢并分享这篇文章，并留下评论。它不会让你付出任何代价，同时鼓励我继续创作其他类似的内容。谢谢你的支持。</p><p id="1b17" class="pw-post-body-paragraph kv kw it kx b ky kz ju la lb lc jx ld le lf lg lh li lj lk ll lm ln lo lp lq im bi translated">下节课再见。😉</p></div></div>    
</body>
</html>