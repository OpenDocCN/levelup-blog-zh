<html>
<head>
<title>Role-based Authentication with React Router and TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React路由器和类型脚本进行基于角色的身份验证</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/role-based-authentication-with-react-router-and-typescript-b707af568ccf?source=collection_archive---------0-----------------------#2019-12-16">https://levelup.gitconnected.com/role-based-authentication-with-react-router-and-typescript-b707af568ccf?source=collection_archive---------0-----------------------#2019-12-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a595" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过处理身份验证和授权，定义一个强类型组件来处理基于角色的导航</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6e104b7e1f0373448e9bc3e87104ee22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mMfu7RksYomCXubps5Rsdw.png"/></div></div></figure><p id="9b76" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">身份验证和授权是现代应用程序不可或缺的一部分，但一直是我作为React开发人员的一个棘手问题，我认为可以肯定地说，我不是唯一一个处于这种困境的人。</p><p id="4444" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我将展示我最近使用React Router和TypeScript进行基于角色的身份验证的设置。也就是说，这不是对这两种技术的介绍。换句话说，我将提供的示例将假设对它们的工作原理有一个基本的了解，并专注于解决基于角色的认证问题。</p><p id="c4d1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我们进入代码之前，先简单提一下。这个系统绝对不是有效验证生产级应用程序所需的全部。这不会包含Redux或任何其他状态管理解决方案，也不会解决所有难题。我的目标是让它成为其他人的基础。</p><p id="e045" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意:为了简单起见，示例代码将使用本地存储进行令牌管理。对于生产应用程序，我不推荐这种方法。</p></div><div class="ab cl lq lr hx ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="im in io ip iq"><p id="12bb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">假设我们有一个库存管理工具，需要对用户进行身份验证，有<code class="fe lx ly lz ma b">super-admin</code>、<code class="fe lx ly lz ma b">admin</code>和<code class="fe lx ly lz ma b">non-admin</code>用户，他们每个人对应用程序的各个部分都有不同的写/读权限。</p><h1 id="146c" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">类型化角色</h1><p id="06e7" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">让我们设置一个角色枚举，然后在一个<code class="fe lx ly lz ma b">userRoles</code>数组中使用它:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi my"><img src="../Images/78f5fc2fdf1becff91133e299667f856.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Iyuv-WNeCvvZ0wGT6a7-Cg.png"/></div></div></figure><p id="725a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您可能想知道为什么我在<code class="fe lx ly lz ma b">userRoles</code>对象中将枚举值转换成字符串。这是因为我希望能够检查给定的用户角色是否在所需角色的数组中。使用类型安全字符串数组使这变得更容易。我并不是说这是最佳实践，但它对我很有效。</p><h1 id="9e87" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">路由器设置</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/5b5f7b7f33284e00d00b3036d6fbfbfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yze7P6T6bZ39bCwGI8nJ6Q.png"/></div></div></figure><p id="a556" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于React路由器来说，这应该非常简单。这是一个标准的导航设置。然而，目前我们的导航中没有整合认证逻辑，路由器也不关心(或知道)用户在导航应用程序时的授权角色。</p><p id="0279" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们假设我们的服务器已经在工作了。因此，我们打个响指，在后端设置认证令牌。现在，我们希望确保用户在查看任何应用程序内容之前已经登录。</p><p id="413b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们做几件事来实现这一点:</p><p id="f5e4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">1)为我们的授权和非授权路由定义枚举(这不是必需的，但我更喜欢它而不是传递字符串)。</p><p id="2fca" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">2)为访问授权路由的非授权用户定义一个单独的组件来处理重定向逻辑。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi my"><img src="../Images/acd30ce9fbaf6d4246cab56dab2c41e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bqe9mnGkMCDui9Ex4mkzMg.png"/></div></div></figure><h1 id="82f0" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">AuthRoute.tsx</h1><p id="6ba3" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">现在让我们创建一个<code class="fe lx ly lz ma b">AuthRoute</code>组件。我们稍后还将添加一个<code class="fe lx ly lz ma b">Unauthorized</code>视图，如果用户试图访问他们不应该访问的内容，我们将向用户显示该视图(理想情况下，路由逻辑会阻止用户看到它，但以防万一，这是一个‘很好的’视图)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/17f915f52526742ba06e0d62472c80f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pZ4fflGBHCSwBQm5q4vz0w.png"/></div></div></figure><p id="3a2f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们稍微分解一下这个组件。如果你不熟悉的话，来自<code class="fe lx ly lz ma b">react-router-dom</code>的<code class="fe lx ly lz ma b">Route</code>组件有一个<a class="ae nb" href="https://github.com/ReactTraining/react-router/blob/master/packages/react-router/docs/api/Route.md#render-func" rel="noopener ugc nofollow" target="_blank">渲染</a>道具，它允许我们传入一个函数，当位置与路线<code class="fe lx ly lz ma b">path</code>匹配时，该函数将最终返回一个React组件。这是检查用户是否有权查看我们应用程序中给定页面的理想位置。如果组件通过标准的<code class="fe lx ly lz ma b">component</code>属性呈现，这个函数也可以访问所有的路径属性。在我们验证了用户的身份之后，我们希望将这些属性传递给呈现的组件。</p><p id="fba4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe lx ly lz ma b">Redirect</code>组件有一个to <a class="ae nb" href="https://github.com/ReactTraining/react-router/blob/master/packages/react-router/docs/api/Redirect.md#to-string" rel="noopener ugc nofollow" target="_blank">属性</a>,它不仅可以传递字符串，还可以传递带有属性的对象，我在<code class="fe lx ly lz ma b">AuthRoute</code>组件中使用了其中的两个属性。<code class="fe lx ly lz ma b">pathname</code>非常简单，但是我们也可以将状态片段传递给目的组件。如果您希望允许用户返回到他们在令牌过期之前尝试访问的视图，并且他们在不知情的情况下被注销，这将非常方便。</p><p id="49b2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在成功登录后将用户导航到给定视图的登录逻辑中可以看到这样的例子:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nc"><img src="../Images/218b0b55342502f810aeb057492b2c00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wuZhkQqOoMAv3sWBmbnPMg.png"/></div></div></figure><h1 id="9f4f" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">将AuthRoute合并到路由器中</h1><p id="fb39" class="pw-post-body-paragraph ku kv it kw b kx mt ju kz la mu jx lc ld mv lf lg lh mw lj lk ll mx ln lo lp im bi translated">现在我们已经设置好了<code class="fe lx ly lz ma b">AuthRoute</code>组件，让我们在路由器中使用它:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/5b4588dbb505941290ca11d452b44280.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KdPKwHTwOVrTrtG4osYcZQ.png"/></div></div></figure><p id="f2c1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">太棒了。现在，如果一个用户试图在未经认证的情况下访问这些视图，我们的路由器将引导他们返回登录页面。或者，如果用户偶然发现了不允许他们查看的内容，他们会看到一个<code class="fe lx ly lz ma b">Unauthorized</code>视图，但是用户角色呢？让我们假设我们的应用程序在<code class="fe lx ly lz ma b">Context</code>中存储了一个<code class="fe lx ly lz ma b">userRole</code>字符串。让我们将逻辑合并到我们的<code class="fe lx ly lz ma b">AuthRoute</code>组件中，以便在将用户路由到给定视图之前处理角色检查:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi my"><img src="../Images/bd73bcfe2b23154eebd32babc788e249.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1DlhmNip_fDd5d5t-LmwZg.png"/></div></div></figure><p id="66ff" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以现在，组件接受一个<code class="fe lx ly lz ma b">requiredRoles</code>数组，该数组将包含用户为了查看给定页面而必须拥有的角色。现在我们可以为每个组件传递所需的角色:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi na"><img src="../Images/42feffe562f57de6b87f140cd97333a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mO_Qpc2VfIQlR8CPJSoI6A.png"/></div></div></figure><p id="2a14" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们不仅要确保我们的用户通过了身份验证，还要确保他们被授权有权查看页面。注意，我们的<code class="fe lx ly lz ma b">Redirect</code>组件的目的地也是由用户是否拥有所需的角色决定的。</p><p id="3fd2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">差不多就是这样。我真的很喜欢我正在做的项目中的这个设置，并希望与他人分享，看看他们是否可以利用它(或评论它)👀).</p><p id="5091" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">感谢您的倾听👋🏻</p></div></div>    
</body>
</html>