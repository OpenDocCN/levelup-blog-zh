<html>
<head>
<title>Elegant Typescript Data Validation With Decorators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Decorators进行优雅的类型脚本数据验证</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/elegant-typescript-data-validation-with-decorators-68ec7506fd87?source=collection_archive---------2-----------------------#2020-02-06">https://levelup.gitconnected.com/elegant-typescript-data-validation-with-decorators-68ec7506fd87?source=collection_archive---------2-----------------------#2020-02-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/125e18f9da2345bcc3bd5b2793fcebc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FqVzyWSkxPgIZ9t863otpg.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">在<a class="ae kc" href="https://unsplash.com/s/photos/elegant?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae kc" href="https://unsplash.com/@adeolueletu?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Adeolu Eletu </a>拍摄的照片</figcaption></figure><h1 id="0033" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">我的目标</h1><p id="62aa" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">我想尽可能以最符合人类工程学的优雅方式为我在typescript应用程序中使用的对象指定验证规则。</p><p id="14b2" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated"><em class="me">github:</em><a class="ae kc" href="https://github.com/kanian/ts-decorator-validation" rel="noopener ugc nofollow" target="_blank"><em class="me">https://github.com/kanian/ts-decorator-validation</em></a><em class="me">，</em></p><p id="1883" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated"><em class="me">NPM:</em><a class="ae kc" href="https://www.npmjs.com/package/ts-decorator-validation" rel="noopener ugc nofollow" target="_blank">T15】https://www.npmjs.com/package/ts-decorator-validation</a></p><h1 id="2110" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">工具</h1><p id="a72f" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">我将使用<a class="ae kc" href="https://hapi.dev/family/joi/" rel="noopener ugc nofollow" target="_blank"> Joi </a>和JavaScript <a class="ae kc" href="https://github.com/tc39/proposal-decorators" rel="noopener ugc nofollow" target="_blank">装饰者</a>。这里有一个简单的UML图来总结这种方法:</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/8c34411d55b59afe4b208107bf85971f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1346/format:webp/1*HAla3-wpEk_ytVuE5i72eg.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">一个类，它的构造函数，构造函数参数，类属性和它们的模式</figcaption></figure><h1 id="b995" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">关于Joi</h1><p id="715c" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">Joi是JavaScript的模式描述语言和数据验证器。假设您想要验证一个person对象，这样每个person对象都有一个name和age属性。名称必须是至少3个字符的非空字符串，而年龄是不能小于1的数字。你可以这么做:</p><figure class="mg mh mi mj gt jr"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="08c5" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">然后你会这样验证:</p><figure class="mg mh mi mj gt jr"><div class="bz fp l di"><div class="mk ml l"/></div></figure><h1 id="5be6" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">打字稿装饰者</h1><p id="624c" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">decorators是Typescript的一个实验性特性，它提供了一种注释类和类成员声明的方法。它们还为上述类及其成员提供了元编程语法。作为实验，您必须在tsconfig.json中启用decorators和元数据发射:</p><pre class="mg mh mi mj gt mm mn mo mp aw mq bi"><span id="940d" class="mr ke iq mn b gy ms mt l mu mv">{<br/>    "compilerOptions": {<br/>        "target": "ES5",<br/>        "experimentalDecorators": true,<br/>        "emitDecoratorMetadata": true</span><span id="6d1c" class="mr ke iq mn b gy mw mt l mu mv">    }<br/>}</span></pre><p id="7c8d" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">此外，您必须安装元数据功能，一个用于ECMAScript <a class="ae kc" href="https://rbuckton.github.io/reflect-metadata/" rel="noopener ugc nofollow" target="_blank">提议</a>的<a class="ae kc" href="https://www.npmjs.com/package/reflect-metadata" rel="noopener ugc nofollow" target="_blank"> polyfill </a>:</p><pre class="mg mh mi mj gt mm mn mo mp aw mq bi"><span id="bbe1" class="mr ke iq mn b gy ms mt l mu mv">npm i reflect-metadata</span></pre><p id="4d65" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">通常</p><blockquote class="mx my mz"><p id="44ed" class="lb lc me ld b le lz lg lh li ma lk ll na mb lo lp nb mc ls lt nc md lw lx ly ij bi translated"><em class="iq">装饰器</em>是一种特殊的声明，可以附加到<a class="ae kc" href="https://www.typescriptlang.org/docs/handbook/decorators.html#class-decorators" rel="noopener ugc nofollow" target="_blank">类声明</a>、<a class="ae kc" href="https://www.typescriptlang.org/docs/handbook/decorators.html#method-decorators" rel="noopener ugc nofollow" target="_blank">方法</a>、<a class="ae kc" href="https://www.typescriptlang.org/docs/handbook/decorators.html#accessor-decorators" rel="noopener ugc nofollow" target="_blank">访问器</a>、<a class="ae kc" href="https://www.typescriptlang.org/docs/handbook/decorators.html#property-decorators" rel="noopener ugc nofollow" target="_blank">属性</a>或<a class="ae kc" href="https://www.typescriptlang.org/docs/handbook/decorators.html#parameter-decorators" rel="noopener ugc nofollow" target="_blank">参数</a>。装饰者使用形式<code class="fe nd ne nf mn b">@expression</code>，其中<code class="fe nd ne nf mn b">expression</code>必须计算出一个函数，该函数将在运行时使用关于被装饰声明的信息来调用。</p></blockquote><p id="e05b" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">我对类、参数和属性装饰器特别感兴趣。</p><p id="d7bd" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">类装饰器应用于类构造函数，并允许您修改类声明，以便您可以观察它或应用任何类型的自定义行为。在我的例子中，我想确保一个类实例符合给定的Joi模式。因此，我将使用一个decorator factory，它接受一个给定的模式，并在decorator的表达式定义中使用它来验证所创建的感兴趣的类的实例:</p><figure class="mg mh mi mj gt jr"><div class="bz fp l di"><div class="mk ml l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">类模式装饰器</figcaption></figure><p id="6808" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">对于本文的其余部分，我们将假设:</p><figure class="mg mh mi mj gt jr"><div class="bz fp l di"><div class="mk ml l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">与人相关的图式</figcaption></figure><p id="5a13" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">现在，我们可以在创建时验证实例，如下所示:</p><figure class="mg mh mi mj gt jr"><div class="bz fp l di"><div class="mk ml l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">使用schema decorator来验证Person对象</figcaption></figure><p id="4d77" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">如您所见，除了创建模式之外，我们只需向我们的类添加一行代码，即decorator，以便实施验证。这是符合人体工程学的，简洁地显示了意图，是优雅的。</p><p id="23fd" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">然而，我们必须在退出之前创建一个完整的实例，即使我们可以从参数列表中获得参数无效的信息。一个更好的方法是单独验证参数，然后创建一个实例并在类级别验证它。无论如何，如果参数无效，就不会创建实例。为此，我将使用<a class="ae kc" href="https://www.typescriptlang.org/docs/handbook/decorators.html#parameter-decorators" rel="noopener ugc nofollow" target="_blank">参数装饰器</a>和<a class="ae kc" href="https://www.typescriptlang.org/docs/handbook/decorators.html#metadata" rel="noopener ugc nofollow" target="_blank">反射元数据</a>。一个<strong class="ld ir">参数装饰器</strong></p><blockquote class="mx my mz"><p id="cb43" class="lb lc me ld b le lz lg lh li ma lk ll na mb lo lp nb mc ls lt nc md lw lx ly ij bi translated">[…]将在运行时作为函数调用，有以下三个参数:1。静态成员的类的构造函数，或者实例成员的类的原型。2.成员的名称。3.函数的参数列表中参数的序号索引。(<a class="ae kc" href="https://www.typescriptlang.org/docs/handbook/decorators.html#parameter-decorators" rel="noopener ugc nofollow" target="_blank">https://www . typescriptlang . org/docs/handbook/decorators . html # parameter-decorators</a>)</p></blockquote><p id="4022" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">这是参数装饰器的代码:</p><figure class="mg mh mi mj gt jr"><div class="bz fp l di"><div class="mk ml l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">参数装饰器</figcaption></figure><p id="c18e" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">此外，我将修改前面的类schema decorator来检查参数decorator，从而验证构造函数参数:</p><figure class="mg mh mi mj gt jr"><div class="bz fp l di"><div class="mk ml l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">具有构造函数模式验证的类模式装饰器</figcaption></figure><p id="7a0c" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated"><code class="fe nd ne nf mn b">validateConstructorParams</code>函数检索现有的构造函数参数元数据，并根据各自的参数模式验证给定的参数:</p><figure class="mg mh mi mj gt jr"><div class="bz fp l di"><div class="mk ml l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">ValidateConstructorParams:根据各自的参数模式验证给定的参数</figcaption></figure><p id="296d" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">现在，只要参数无效，我们就可以退出:</p><figure class="mg mh mi mj gt jr"><div class="bz fp l di"><div class="mk ml l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">paramSchema装饰器验证示例</figcaption></figure><p id="b424" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">这个还是挺简洁优雅的。我们可以通过在导入过程中给装饰者提供更短的别名来使代码更加简洁。</p><p id="8cd6" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">现在，我确信如果给定的数据无效，对象创建将不会完成。</p><p id="f208" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">我现在要确保<strong class="ld ir">对对象状态的任何修改都不会使其处于无效状态</strong>。为了实现这一点，我将使用<strong class="ld ir">属性装饰器；</strong>它们叫做</p><blockquote class="mx my mz"><p id="d711" class="lb lc me ld b le lz lg lh li ma lk ll na mb lo lp nb mc ls lt nc md lw lx ly ij bi translated">[…]在运行时，使用以下两个参数:1。静态成员的类的构造函数，或者实例成员的类的原型。2.成员的名称。(<a class="ae kc" href="https://www.typescriptlang.org/docs/handbook/decorators.html#property-decorators" rel="noopener ugc nofollow" target="_blank">https://www . typescriptlang . org/docs/handbook/decorators . html # property-decorators</a>)</p></blockquote><p id="0272" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">属性装饰器将<strong class="ld ir">为它注释的属性构建一个getter和一个setter </strong>。setter将根据属性装饰器的模式验证它的参数:</p><figure class="mg mh mi mj gt jr"><div class="bz fp l di"><div class="mk ml l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">propertySchema装饰</figcaption></figure><figure class="mg mh mi mj gt jr"><div class="bz fp l di"><div class="mk ml l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">propertySchema装饰器验证示例</figcaption></figure><p id="e6c7" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">将所有东西放在一起会给我们带来:</p><figure class="mg mh mi mj gt jr"><div class="bz fp l di"><div class="mk ml l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">所有使用的装饰者</figcaption></figure><h1 id="389a" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">结论</h1><p id="4676" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">Typescript类、参数和属性装饰器以及reflect-metadata都是完美的工具，有助于以最符合人类工程学的方式验证TypeScript对象，因此也是最优雅的方式。这种声明式方法简洁明了，并且以非常清晰的方式传达意图。</p><p id="89db" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated"><em class="me">这篇文章的代码在https://github.com/kanian/ts-decorator-validation</em><a class="ae kc" href="https://github.com/kanian/ts-decorator-validation" rel="noopener ugc nofollow" target="_blank"><em class="me"/></a><em class="me">找到，而npm包是</em><a class="ae kc" href="https://www.npmjs.com/package/ts-decorator-validation" rel="noopener ugc nofollow" target="_blank"><em class="me"/></a><em class="me">。</em></p></div></div>    
</body>
</html>