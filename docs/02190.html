<html>
<head>
<title>4 tips for logging on GCP using Golang and Logrus</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Golang和Logrus登录GCP的4个技巧</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/4-tips-for-logging-on-gcp-using-golang-and-logrus-239baf3b1ac2?source=collection_archive---------11-----------------------#2020-02-25">https://levelup.gitconnected.com/4-tips-for-logging-on-gcp-using-golang-and-logrus-239baf3b1ac2?source=collection_archive---------11-----------------------#2020-02-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/c64cbf9a3ad6dd6c766c4c49e44c6e62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BHQM_wsNhDlUEPW8Vj5gVQ.jpeg"/></div></div></figure><p id="d9df" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">日志记录是一个重要的部分，并且有着为不同类型的应用程序开发的悠久历史。软件开发从各个方面都变化很快。日志记录也不例外。过去，企业应用程序开发人员通常主要关注输出位置、旋转和翻转。如今，随着我们向云部署的转移，日志也有了新的标准。</p><p id="058b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">根据十二要素应用的<a class="ae kz" href="https://12factor.net/" rel="noopener ugc nofollow" target="_blank">，云原生应用应该以事件流的形式记录，并且从不关心路由或存储。该日志仍将由云提供商或另一个进程在其他地方处理。因此，登录云原生应用更关注遵循行业标准分发事件。</a></p><p id="915d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">以下是我使用Golang和<a class="ae kz" href="https://github.com/sirupsen/logrus" rel="noopener ugc nofollow" target="_blank"> Logrus </a>库登录GCP Kubernetes的技巧。</p><h1 id="5a3c" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">为您的消息添加上下文</h1><p id="b393" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">如果我们正在对一个问题进行故障诊断，但是在目标部分没有找到日志，这将是非常令人沮丧的。你知道更令人沮丧的是什么吗？这是当我们有一个日志，但日志实际上并没有给你任何有价值的信息。没有比这种消息更糟糕的了:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="32e1" class="mm lb it mi b gy mn mo l mp mq">Transaction failed</span></pre><p id="14ff" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">或者</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="b733" class="mm lb it mi b gy mn mo l mp mq">Data validation error</span></pre><p id="d402" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">没有适当的上下文，这些消息没有多少价值。就故障排除而言，以下消息更有意义:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="6829" class="mm lb it mi b gy mn mo l mp mq">Transaction failed: insufficient funds</span></pre><p id="420f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">或者</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="a311" class="mm lb it mi b gy mn mo l mp mq">Data validation error: invalid email address</span></pre><p id="054f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">或者</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="8131" class="mm lb it mi b gy mn mo l mp mq">Transaction 123456 was successfully, amount transferred: $42,394</span></pre><p id="08b3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以稍微改进一下这些信息。日志不仅是人类的，也是机器的。在数据世界中，日志可以是自动处理的输入源(例如监控和警报)。您的日志不仅应该可读，而且应该易于解析。如果你正在实现一个解析服务，下面的日志格式会节省你很多时间:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="fd58" class="mm lb it mi b gy mn mo l mp mq">2020-01-31 13:42:12,471 INFO Processing payment user_id=37162 transaction_id=38271 amount=32371 currency=USD</span></pre><p id="2679" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">或者，您甚至可以用JSON格式登录:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="232f" class="mm lb it mi b gy mn mo l mp mq">{"time": "2020-01-31 13:42:12,471", "level": info, "msg": "Processing payment", "user_id": 37416, "transaction_id": 957126, "amount":3000, "currency": "USD"}</span></pre><p id="78c7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">要对此进行存档，您应该将上下文数据与日志消息分开附加，而不是自己格式化日志。日志格式化程序将处理剩下的工作。以下是关于如何使用<code class="fe mr ms mt mi b">logrus</code>实现这一点的示例:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="dba9" class="mm lb it mi b gy mn mo l mp mq">package main</span><span id="60ff" class="mm lb it mi b gy mu mo l mp mq">import (<br/> log "github.com/sirupsen/logrus"<br/>)</span><span id="7a1e" class="mm lb it mi b gy mu mo l mp mq">func main() {<br/> ... <br/>    <br/> log.WithError(err).Error("Transaction failed")<br/> log.WithField("transaction", transaction).Debug("Transaction processed successfully")<br/> log.WithFields(log.Fields{<br/>  "user_id": 2384172,<br/>  "transaction_id": 9823183,<br/>  "amount": 5000,<br/>  "currency": "USD",<br/> }).Info("Transaction processed successfully")<br/> ...<br/>}</span></pre><p id="41b2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">上面的代码乍一看似乎非常长。但是一旦你熟悉了，附加上下文数据是非常有帮助的，而且更加灵活。您还可以用初始上下文数据创建一个logger对象。来自该记录器的所有日志将包含以下信息:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="dcae" class="mm lb it mi b gy mn mo l mp mq">logger := log.WithFields(log.Fields{<br/> "user_id": 2384172,<br/> "transaction_id": 9823183,<br/> "amount": 5000,<br/> "currency": "USD",<br/>})<br/>    <br/>...</span><span id="d84c" class="mm lb it mi b gy mu mo l mp mq">logger.Info("Start transaction")<br/>logger.WithError(err).Error("Transaction failed")</span></pre><h1 id="9e19" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">记录到标准输出和标准错误</h1><p id="20aa" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">许多云提供商让他们的容器引擎捕获所包含的应用程序的日志输出管道(<code class="fe mr ms mt mi b">stdout</code>、<code class="fe mr ms mt mi b">stderr</code>)。容器将您的消息包装到一个新的日志条目中。新日志条目的级别取决于原始日志来自的管道。如果是从<code class="fe mr ms mt mi b">stdout</code>收到的，新日志将是<code class="fe mr ms mt mi b">INFO</code>。否则，新的日志将会是<code class="fe mr ms mt mi b">ERROR</code>。容器日志对于故障排除非常有帮助，尤其是当您想要查看组合日志时，包括来自云提供商或其他服务的外部日志。</p><p id="7d27" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">默认情况下，<code class="fe mr ms mt mi b">logrus</code>将所有日志写入<code class="fe mr ms mt mi b">stderr</code>。这意味着你所有的日志都将出现在<code class="fe mr ms mt mi b">ERROR</code>级别的容器日志中。在GCP·库伯内特网上，所有的日志都会用红色突出显示。它不仅令人困惑，而且还会禁用颜色过滤器，这有助于我们快速扫描真正的错误。迟早，我们需要将日志流式传输到正确的管道。比方说，所有等于或高于<code class="fe mr ms mt mi b">WARN</code>级别的日志都将被传输到<code class="fe mr ms mt mi b">stderr</code>。其他日志将转到<code class="fe mr ms mt mi b">stdout</code>。一种解决方案是为<code class="fe mr ms mt mi b">logrus</code>设置自定义输出:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="0935" class="mm lb it mi b gy mn mo l mp mq">import (<br/> "os"<br/> "regexp"</span><span id="fc7f" class="mm lb it mi b gy mu mo l mp mq">log "github.com/sirupsen/logrus"<br/>)</span><span id="fadd" class="mm lb it mi b gy mu mo l mp mq">type LogWriter struct{}</span><span id="5a5d" class="mm lb it mi b gy mu mo l mp mq">var levelRegex *regexp.Regexp</span><span id="b475" class="mm lb it mi b gy mu mo l mp mq">const (<br/> LevelError   = "error"<br/> LevelWarning = "warning"<br/> LevelFatal   = "fatal"<br/> LevelPanic   = "panic"<br/>)</span><span id="6f72" class="mm lb it mi b gy mu mo l mp mq">func init() {<br/> var err error<br/> levelRegex, err = regexp.Compile("level=([a-z]+)")<br/> if err != nil {<br/>  log.WithError(err).Fatal("Cannot setup log level")<br/> }<br/>}</span><span id="156b" class="mm lb it mi b gy mu mo l mp mq">func (w *LogWriter) detectLogLevel(p []byte) (level string) {<br/> matches := levelRegex.FindStringSubmatch(string(p))<br/> if len(matches) &gt; 1 {<br/>  level = matches[1]<br/> }<br/> return<br/>}</span><span id="31b0" class="mm lb it mi b gy mu mo l mp mq">func (w *LogWriter) Write(p []byte) (n int, err error) {<br/> level := w.detectLogLevel(p)</span><span id="c251" class="mm lb it mi b gy mu mo l mp mq">if level == LevelError || level == LevelWarning || level == LevelFatal || level == LevelPanic {<br/>  return os.Stderr.Write(p)<br/> }<br/> return os.Stdout.Write(p)<br/>}</span><span id="fbcb" class="mm lb it mi b gy mu mo l mp mq">...</span><span id="9c8e" class="mm lb it mi b gy mu mo l mp mq">func main() {<br/> log.SetOutput(&amp;LogWriter{})<br/>}</span></pre><h1 id="4fd2" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">记录全局默认字段</h1><p id="3ea9" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">如果您将日志从几个服务或实例流式传输到一个目的地(例如堆栈驱动程序)，您将很快需要添加一些额外的字段用于过滤目的。对于我的项目，我需要向所有条目添加服务名称、流程ID和环境(登台、生产)。为了在<code class="fe mr ms mt mi b">logrus</code>中存档这个，我添加了一个自定义钩子。钩子是<code class="fe mr ms mt mi b">logrus</code>的一个特性，当用户写日志时触发一些动作。这个特性非常强大，尤其是在云世界中，我们有许多可能的日志用例(添加数据、流向云、报告错误、警报等。).</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="0aa7" class="mm lb it mi b gy mn mo l mp mq">import (<br/> "os"</span><span id="4065" class="mm lb it mi b gy mu mo l mp mq">"github.com/sirupsen/logrus"<br/>)</span><span id="4f8e" class="mm lb it mi b gy mu mo l mp mq">type ExtraFieldHook struct {<br/> service string<br/> env     string<br/> pid     int<br/>}</span><span id="ca73" class="mm lb it mi b gy mu mo l mp mq">func NewExtraFieldHook(service string, env string) *ExtraFieldHook {<br/> return &amp;ExtraFieldHook{<br/>  service: service,<br/>  env:     env,<br/>  pid:     os.Getpid(),<br/> }<br/>}</span><span id="d7a1" class="mm lb it mi b gy mu mo l mp mq">func (h *ExtraFieldHook) Levels() []logrus.Level {<br/> return logrus.AllLevels<br/>}</span><span id="97c7" class="mm lb it mi b gy mu mo l mp mq">func (h *ExtraFieldHook) Fire(entry *logrus.Entry) error {<br/> entry.Data["service"] = h.service<br/> entry.Data["env"] = h.env<br/> entry.Data["pid"] = h.pid<br/> return nil<br/>}</span><span id="9ca7" class="mm lb it mi b gy mu mo l mp mq">...</span><span id="3de3" class="mm lb it mi b gy mu mo l mp mq">func main() {<br/> log.AddHook(NewExtraFieldHook(service, config.Env))<br/> ...<br/>}</span></pre><h1 id="65b2" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">记录到堆栈驱动程序并报告错误</h1><p id="6ff3" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">将所有服务的所有日志流式传输到一个位置将有助于您集中数据，以便于监控和审计，尤其是当您的服务部署在不同的位置时。</p><p id="1159" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe mr ms mt mi b">logrus</code>有<a class="ae kz" href="https://github.com/sirupsen/logrus/wiki/Hooks" rel="noopener ugc nofollow" target="_blank">几个挂钩</a>用于不同的第三方。不幸的是，用于堆栈驱动程序的那个似乎不起作用。通过深入研究它的代码，我发现钩子没有使用官方文档中的栈驱动库。它看起来像一个堆栈驱动API的遗留版本。因此，我想出了自己的版本:</p><ul class=""><li id="9fdf" class="mv mw it kd b ke kf ki kj km mx kq my ku mz ky na nb nc nd bi translated">所有日志都将传输到堆栈驱动程序</li><li id="4cae" class="mv mw it kd b ke ne ki nf km ng kq nh ku ni ky na nb nc nd bi translated">所有具有<code class="fe mr ms mt mi b">error</code>或更高级别的日志将被报告给堆栈驱动程序的错误报告</li><li id="ae52" class="mv mw it kd b ke ne ki nf km ng kq nh ku ni ky na nb nc nd bi translated">从错误的堆栈跟踪中删除<code class="fe mr ms mt mi b">logrus</code>的堆栈。这是为了防止错误报告从<a class="ae kz" href="https://cloud.google.com/error-reporting/docs/grouping-errors" rel="noopener ugc nofollow" target="_blank">将你的错误组合成一个</a></li></ul><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="01a0" class="mm lb it mi b gy mn mo l mp mq">import (<br/> "context"<br/> "encoding/json"<br/> "fmt"<br/> "log"<br/> "regexp"<br/> "runtime"</span><span id="2222" class="mm lb it mi b gy mu mo l mp mq">"cloud.google.com/go/errorreporting"<br/> "cloud.google.com/go/logging"<br/> "github.com/sirupsen/logrus"<br/>)</span><span id="9277" class="mm lb it mi b gy mu mo l mp mq">type StackDriverHook struct {<br/> client      *logging.Client<br/> errorClient *errorreporting.Client<br/> logger      *logging.Logger<br/>}</span><span id="0ef9" class="mm lb it mi b gy mu mo l mp mq">var logLevelMappings = map[logrus.Level]logging.Severity{<br/> logrus.TraceLevel: logging.Default,<br/> logrus.DebugLevel: logging.Debug,<br/> logrus.InfoLevel:  logging.Info,<br/> logrus.WarnLevel:  logging.Warning,<br/> logrus.ErrorLevel: logging.Error,<br/> logrus.FatalLevel: logging.Critical,<br/> logrus.PanicLevel: logging.Critical,<br/>}</span><span id="6438" class="mm lb it mi b gy mu mo l mp mq">func NewStackDriverHook(logName string) (*StackDriverHook, error) {<br/> ctx := context.Background()</span><span id="b2a1" class="mm lb it mi b gy mu mo l mp mq">client, err := logging.NewClient(ctx, config.GCPProjectID)<br/> if err != nil {<br/>  return nil, err<br/> }</span><span id="4493" class="mm lb it mi b gy mu mo l mp mq">errorClient, err := errorreporting.NewClient(ctx, config.GCPProjectID, errorreporting.Config{<br/>  ServiceName: config.GCPProjectID,<br/>  OnError: func(err error) {<br/>   log.Printf("Could not log error: %v", err)<br/>  },<br/> })<br/> if err != nil {<br/>  return nil, err<br/> }</span><span id="35df" class="mm lb it mi b gy mu mo l mp mq">return &amp;StackDriverHook{<br/>  client:      client,<br/>  errorClient: errorClient,<br/>  logger:      client.Logger(logName),<br/> }, nil<br/>}</span><span id="7ece" class="mm lb it mi b gy mu mo l mp mq">func (sh *StackDriverHook) Close() {<br/> sh.client.Close()<br/> sh.errorClient.Close()<br/>}</span><span id="72f0" class="mm lb it mi b gy mu mo l mp mq">func (sh *StackDriverHook) Levels() []logrus.Level {<br/> return logrus.AllLevels<br/>}</span><span id="9fc8" class="mm lb it mi b gy mu mo l mp mq">func (sh *StackDriverHook) Fire(entry *logrus.Entry) error {<br/> payload := map[string]interface{}{<br/>  "Message": entry.Message,<br/>  "Data":    entry.Data,<br/> }<br/> level := logLevelMappings[entry.Level]<br/> sh.logger.Log(logging.Entry{Payload: payload, Severity: level})<br/> if int(level) &gt;= int(logging.Error) {<br/>  err := getError(entry)<br/>  if err == nil {<br/>   errData, e := json.Marshal(payload)<br/>   if e != nil {<br/>    fmt.Printf("Error %v", e)<br/>   }<br/>   fmt.Print(string(errData))<br/>   err = fmt.Errorf(string(errData))<br/>  }<br/>  fmt.Println(err.Error())</span><span id="5b72" class="mm lb it mi b gy mu mo l mp mq">sh.errorClient.Report(errorreporting.Entry{<br/>   Error: err,<br/>   Stack: sh.getStackTrace(),<br/>  })<br/> }<br/> return nil<br/>}</span><span id="c75d" class="mm lb it mi b gy mu mo l mp mq">func (sh *StackDriverHook) getStackTrace() []byte {<br/> stackSlice := make([]byte, 2048)<br/> length := runtime.Stack(stackSlice, false)<br/> stack := string(stackSlice[0:length])<br/> re := regexp.MustCompile("[\r\n].*logrus.*")<br/> res := re.ReplaceAllString(stack, "")<br/> return []byte(res)<br/>}</span><span id="9b2c" class="mm lb it mi b gy mu mo l mp mq">type stackDriverError struct {<br/> Err         interface{}<br/> Code        interface{}<br/> Description interface{}<br/> Message     interface{}<br/> Env         interface{}<br/>}</span><span id="0db8" class="mm lb it mi b gy mu mo l mp mq">func (e stackDriverError) Error() string {<br/> return fmt.Sprintf("%v - %v - %v - %v - %v", e.Code, e.Description, e.Message, e.Err, e.Env)<br/>}</span><span id="96bf" class="mm lb it mi b gy mu mo l mp mq">func getError(entry *logrus.Entry) error {<br/> errData := entry.Data["error"]<br/> env := entry.Data["env"]<br/> code := entry.Data["ErrCode"]<br/> desc := entry.Data["ErrDescription"]<br/> msg := entry.Message</span><span id="ba35" class="mm lb it mi b gy mu mo l mp mq">err := stackDriverError{<br/>  Err:         errData,<br/>  Code:        code,<br/>  Message:     msg,<br/>  Description: desc,<br/>  Env:         env,<br/> }</span><span id="3a46" class="mm lb it mi b gy mu mo l mp mq">return err<br/>}</span><span id="25d0" class="mm lb it mi b gy mu mo l mp mq">func (sh *StackDriverHook) Wait() {}</span></pre><h1 id="3054" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">结论</h1><p id="db3d" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">以上是我在与戈朗、<code class="fe mr ms mt mi b">logrus</code>和GCP合作过程中发现的一些记录技巧。其他库或编程语言的详细实现可能会有所不同，但我希望主要思想对您仍然有价值，尤其是当您将应用程序部署到GCP时:</p><ul class=""><li id="96ba" class="mv mw it kd b ke kf ki kj km mx kq my ku mz ky na nb nc nd bi translated">日志消息应该包含上下文数据，并且应该对人和机器都友好</li><li id="2e5e" class="mv mw it kd b ke ne ki nf km ng kq nh ku ni ky na nb nc nd bi translated">注意您的日志输出流，它可能会影响您的容器日志</li><li id="7955" class="mv mw it kd b ke ne ki nf km ng kq nh ku ni ky na nb nc nd bi translated">使用钩子为每个日志条目增加额外的步骤。它的使用案例非常广泛。</li></ul></div><div class="ab cl nj nk hx nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="im in io ip iq"><p id="e940" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="nq">原发布于</em><a class="ae kz" href="https://huynvk.dev/blog/4-tips-for-logging-on-gcp-using-golang-and-logrus" rel="noopener ugc nofollow" target="_blank"><em class="nq">https://huynvk . dev</em></a><em class="nq">。</em></p></div></div>    
</body>
</html>