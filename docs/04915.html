<html>
<head>
<title>Creating an AWS SAM CLI project with Typescript and Both Types of Layers (Dependencies and Function)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Typescript和两种类型的层(依赖项和功能)创建AWS SAM CLI项目</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/creating-an-aws-sam-cli-project-with-typescript-and-both-types-of-layers-dependencies-and-34da5efdaec8?source=collection_archive---------1-----------------------#2020-07-23">https://levelup.gitconnected.com/creating-an-aws-sam-cli-project-with-typescript-and-both-types-of-layers-dependencies-and-34da5efdaec8?source=collection_archive---------1-----------------------#2020-07-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/a468842f6bdb12bc68e38409adced642.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SQWLfsO-_5txiv2m"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">由<a class="ae kf" href="https://unsplash.com/@goshua13?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">约书亚·阿拉贡</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="ba21" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你想跳过教程，直接获取代码，这里有GitHub repo:</p><div class="le lf gp gr lg lh"><a href="https://github.com/Borduhh/serverless-SAM-typescript-boilerplate" rel="noopener  ugc nofollow" target="_blank"><div class="li ab fo"><div class="lj ab lk cl cj ll"><h2 class="bd iu gy z fp lm fr fs ln fu fw is bi translated">borduhh/server less-SAM-typescript-boilerplate</h2><div class="lo l"><h3 class="bd b gy z fp lm fr fs ln fu fw dk translated">使用Typescript和Webpack的带有功能和依赖层的AWS SAM CLI样板文件。GitHub是超过50个…</h3></div><div class="lp l"><p class="bd b dl z fp lm fr fs ln fu fw dk translated">github.com</p></div></div><div class="lq l"><div class="lr l ls lt lu lq lv jz lh"/></div></div></a></div><p id="3810" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最近，有人向我介绍了如何使用SAM CLI创建AWS Lambda部署。和往常一样，我喜欢尝试新工具，所以我一头扎了进去。大约30分钟后，我的头感觉像…</p><figure class="lw lx ly lz gt ju"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">试图弄清楚SAM CLI如何使用Typescript</figcaption></figure><p id="06e8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我很快意识到建立一个生产级的应用程序需要大量的工作。更有甚者，使用我最喜欢的工具(ESLint、Typescript和更漂亮的)变得更加令人头疼。更糟糕的是，没有任何关于使用Typescript和函数层构建样板文件的好文章。然而，在阅读了大量文档和StackOverflow搜索之后，我能够拼凑出一个模板结构，它允许我使用我最喜欢的工具快速创建和部署功能和层。</p><h1 id="4f55" class="mc md it bd me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz bi translated">项目结构</h1><p id="a385" class="pw-post-body-paragraph kg kh it ki b kj na kl km kn nb kp kq kr nc kt ku kv nd kx ky kz ne lb lc ld im bi translated">为了使这个项目易于扩展到较小的团队和项目，我选择坚持使用monorepo结构，而不是将每个API都编码在自己的repo中。这使得代码在部署到AWS CloudFormation之前更容易处理和测试。</p><p id="4c9e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文结束时，项目结构将如下所示:</p><pre class="lw lx ly lz gt nf ng nh ni aw nj bi"><span id="2baa" class="nk md it ng b gy nl nm l nn no">Helloworld-Application<br/>  apis/<br/>    helloworld/<br/>      functions/<br/>        greeting/<br/>          dist/<br/>          src/<br/>              __tests__/<br/>          tsconfig.json<br/>          package.json<br/>      layers/<br/>        api-responses<br/>          dist/<br/>          src/<br/>              __tests__/<br/>          tsconfig.json<br/>          package.json<br/>        <!-- -->global-dependencies<!-- -->/<br/>          package.json<br/>    template.yaml<br/>  package.json<br/>  .gitignore</span></pre><p id="7de3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您想添加另一个API，只需复制<code class="fe np nq nr ng b">helloword</code>目录。如果想做一个新函数，复制<code class="fe np nq nr ng b">greeting</code>函数即可。就这么简单，但我将在最后介绍所需的具体更改。让我们开始建造吧。</p><h1 id="a19a" class="mc md it bd me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz bi translated">入门—安装SAM CLI和AWS工具包</h1><p id="8e0f" class="pw-post-body-paragraph kg kh it ki b kj na kl km kn nb kp kq kr nc kt ku kv nd kx ky kz ne lb lc ld im bi translated">这个项目需要SAM CLI。我还推荐使用AWS工具包，因为它能让您深入了解IDE中的部署。为了简洁起见，我不打算重复这些步骤，但是这里有一些很好的资源可以帮助您设置环境:</p><ul class=""><li id="baef" class="ns nt it ki b kj kk kn ko kr nu kv nv kz nw ld nx ny nz oa bi translated">安装SAM CLI—<a class="ae kf" href="https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-sam-cli-install.html" rel="noopener ugc nofollow" target="_blank">https://docs . AWS . Amazon . com/server less-application-model/latest/developer guide/server less-SAM-CLI-install . html</a></li><li id="d0f7" class="ns nt it ki b kj ob kn oc kr od kv oe kz of ld nx ny nz oa bi translated">安装用于VSCode的AWS工具包—<a class="ae kf" href="https://docs.aws.amazon.com/toolkit-for-vscode/latest/userguide/setup-toolkit.html" rel="noopener ugc nofollow" target="_blank">https://docs . AWS . Amazon . com/Toolkit-for-vs code/latest/user guide/setup-Toolkit . html</a></li></ul><h1 id="0100" class="mc md it bd me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz bi translated">入门—设置项目目录结构</h1><p id="c0f7" class="pw-post-body-paragraph kg kh it ki b kj na kl km kn nb kp kq kr nc kt ku kv nd kx ky kz ne lb lc ld im bi translated">首先，让我们建立项目的基本结构，这样我们就可以很容易地将所有东西放在需要的地方。在IDE中创建以下文件夹:</p><pre class="lw lx ly lz gt nf ng nh ni aw nj bi"><span id="6527" class="nk md it ng b gy nl nm l nn no">Helloworld-Application<br/>  apis/<br/>    helloworld/<br/>      functions/<br/>        greeting/<br/>      layers/<br/>        api-responses/<br/>        <!-- -->global-dependencies<!-- -->/</span></pre><p id="f7db" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在导航到终端中的<code class="fe np nq nr ng b">Helloworld-Application</code>文件夹，用<code class="fe np nq nr ng b">npm init</code>命令初始化一个NPM项目。</p><p id="0af7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦你完成了提示，请随意进入并移除你的<code class="fe np nq nr ng b">package.json</code>中的<code class="fe np nq nr ng b">main</code>线并保存它。</p><p id="8a2a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，让我们为一个SAM项目添加默认的<code class="fe np nq nr ng b">.gitignore</code>文件，这样这些东西就不会出现在我们的回购中了。代码如下:</p><figure class="lw lx ly lz gt ju"><div class="bz fp l di"><div class="og mb l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">默认。SAM无服务器项目的gitignore</figcaption></figure><h1 id="0680" class="mc md it bd me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz bi translated">设置依赖层</h1><p id="6e51" class="pw-post-body-paragraph kg kh it ki b kj na kl km kn nb kp kq kr nc kt ku kv nd kx ky kz ne lb lc ld im bi translated">首先是依赖层。这包含了在您的函数之间共享的所有npm包。这一层将非常容易设置，因为我们在这个项目中不会用到它。但是因为我们正在构建一个样板模板，所以包含它是很重要的，因为您的大多数生产项目功能将共享共同的依赖关系。所以我们来设置一下。</p><p id="f3d0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在IDE中导航到<code class="fe np nq nr ng b">/apis/helloworld/layers/global-dependencies</code>，让我们创建一个简单的<code class="fe np nq nr ng b">package.json</code>文件。代码如下:</p><figure class="lw lx ly lz gt ju"><div class="bz fp l di"><div class="og mb l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">Global Dependencies package.json文件</figcaption></figure><p id="34c7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">很简单，对吧？请记住，在生产应用程序中，您可以在这里添加任何共享的依赖项。</p><p id="44b8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这就是依赖层的全部内容。让我们确保SAM CLI可以在构建阶段找到我们的全局依赖项。在IDE中导航到<code class="fe np nq nr ng b">/apis/helloworld/</code>，让我们创建一个<code class="fe np nq nr ng b">template.yaml</code>。该文件用于告诉SAM CLI如何构建我们的项目。以下是目前为止的代码:</p><figure class="lw lx ly lz gt ju"><div class="bz fp l di"><div class="og mb l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">HelloWorld API template.yaml文件</figcaption></figure><p id="c017" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为此，我们告诉SAM CLI，我们有一个名为<code class="fe np nq nr ng b">GlobalDependenciesLayer</code>的层，它位于<code class="fe np nq nr ng b">/layers/global-dependencies</code>。默认情况下，SAM CLI将查找<code class="fe np nq nr ng b">package.json</code>文件，并将其中的所有依赖项安装到引用该层的每个函数中。</p><p id="2f29" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu"> <em class="oh">注意:</em> </strong> <em class="oh">您在</em> <code class="fe np nq nr ng b"><em class="oh">ContentUri</em></code> <em class="oh">中指定的文件夹内必须有一个package.json文件，并带有名称和版本，否则当您运行</em> <code class="fe np nq nr ng b"><em class="oh">build</em></code> <em class="oh">命令时SAM CLI将出错。</em></p><p id="2baf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，如果我们在终端中导航回<code class="fe np nq nr ng b">/apis/helloworld/</code>，并键入<code class="fe np nq nr ng b">sam build</code>，您应该会得到以下结果:</p><pre class="lw lx ly lz gt nf ng nh ni aw nj bi"><span id="7f95" class="nk md it ng b gy nl nm l nn no">Building layer 'GlobalDependenciesLayer'<br/>Running NodejsNpmBuilder:NpmPack<br/>Running NodejsNpmBuilder:CopyNpmrc<br/>Running NodejsNpmBuilder:CopySource<br/>Running NodejsNpmBuilder:NpmInstall<br/>Running NodejsNpmBuilder:CleanUpNpmrc</span><span id="89f3" class="nk md it ng b gy oi nm l nn no">Build Succeeded</span><span id="465c" class="nk md it ng b gy oi nm l nn no">Built Artifacts  : .aws-sam/build<br/>Built Template   : .aws-sam/build/template.yaml</span><span id="4043" class="nk md it ng b gy oi nm l nn no">Commands you can use next<br/>=========================<br/>[*] Invoke Function: sam local invoke<br/>[*] Deploy: sam deploy --guided</span></pre><p id="27f0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">恭喜你，你已经创建了一个依赖层！</p><h1 id="2f45" class="mc md it bd me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz bi translated">设置功能层</h1><p id="b7fc" class="pw-post-body-paragraph kg kh it ki b kj na kl km kn nb kp kq kr nc kt ku kv nd kx ky kz ne lb lc ld im bi translated">拥有一个依赖层是很酷的，但是如果我们有一个定制的代码库，而不是我们想要用于多种功能的NPM包，那该怎么办呢？这就是功能层的用武之地。在这一层，我们将构建一个简单的API响应库，这样我们就不必在以后手工将它们编码到每个函数中。</p><p id="20c6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们在IDE中导航到<code class="fe np nq nr ng b">/apis/helloworld/layers/api-responses/</code>,并在这里添加另一个package.json，与前面类似。这个package.json还将包含我们的开发环境依赖项和一些脚本，以便在我们稍后打包代码时帮助我们。</p><figure class="lw lx ly lz gt ju"><div class="bz fp l di"><div class="og mb l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">API响应层package.json文件</figcaption></figure><p id="e105" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，通过在您的终端中导航到<code class="fe np nq nr ng b">/apis/helloworld/layers/api-responses/</code>并键入<code class="fe np nq nr ng b">npm install</code>来安装所有的<code class="fe np nq nr ng b">devDependencies</code>来安装所有的东西。</p><p id="b66b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们可以开始设置我们的开发环境了。先说大家最喜欢的工具，ESLint，还有更漂亮的。以下是我为他们两个设置的配置:</p><figure class="lw lx ly lz gt ju"><div class="bz fp l di"><div class="og mb l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">API响应层。eslintrc和。漂亮的文件</figcaption></figure><p id="5dbe" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请记住，这些都是我个人对ESLint和pretty的喜好。您可以轻松地更改或删除它们，这不会影响项目。</p><p id="e396" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们也配置Typescript来处理我们的项目，因为它是大多数生产应用程序中的必备组件。继续使用以下代码在<code class="fe np nq nr ng b">/apis/helloworld/layers/api-responses/</code>中创建一个<code class="fe np nq nr ng b">tsconfig.json</code>文件:</p><figure class="lw lx ly lz gt ju"><div class="bz fp l di"><div class="og mb l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">API响应层tsconfig.json文件</figcaption></figure><p id="1a25" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu"> <em class="oh">注意:</em> </strong> <em class="oh">您可能会从Typescript开始得到一个</em> <code class="fe np nq nr ng b"><em class="oh">No inputs were found in config file</em></code> <em class="oh">错误。不要担心，当我们构建代码时，它会消失。</em></p><p id="8480" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，为了确保我们的代码被正确打包，让我们设置我们的Webpack配置。使用以下代码在与您的<code class="fe np nq nr ng b">tsconfig.json</code>相同的目录中创建一个<code class="fe np nq nr ng b">webpack.config.ts</code>文件:</p><figure class="lw lx ly lz gt ju"><div class="bz fp l di"><div class="og mb l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">API响应层webpack.config.js文件</figcaption></figure><p id="60d7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后但同样重要的是，让我们确保我们可以使用Jest通过单元测试遵循测试驱动开发(TDD)过程。在同一个目录下创建一个<code class="fe np nq nr ng b">jest.config.js</code>文件。</p><figure class="lw lx ly lz gt ju"><div class="bz fp l di"><div class="og mb l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">API响应层jest.config.js文件</figcaption></figure><p id="f46a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我告诉过你这需要很多准备时间。现在我们完成了配置，终于可以开始实际的逻辑工作了(唷！).</p><h1 id="ee4f" class="mc md it bd me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz bi translated">构建我们的功能层</h1><p id="e8e5" class="pw-post-body-paragraph kg kh it ki b kj na kl km kn nb kp kq kr nc kt ku kv nd kx ky kz ne lb lc ld im bi translated">所有的设置都准备好了，是时候构建一些默认响应了，我们将在以后的函数中使用它们。使用TDD(测试驱动开发)方法，让我们首先为我们的默认API响应构建测试。在<code class="fe np nq nr ng b">/api-responses/src/__tests__</code>中创建<code class="fe np nq nr ng b">defaultResponses.ts</code>文件。下面是测试代码:</p><figure class="lw lx ly lz gt ju"><div class="bz fp l di"><div class="og mb l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">API响应层默认值Responses.test.ts</figcaption></figure><p id="2de4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们知道了我们要测试什么，我们可以只写我们需要的代码来满足我们的测试用例。让我们在<code class="fe np nq nr ng b">/api-responses/src</code>中创建<code class="fe np nq nr ng b">defaultResponses.ts</code>文件。代码如下:</p><figure class="lw lx ly lz gt ju"><div class="bz fp l di"><div class="og mb l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">API响应层默认响应. ts文件</figcaption></figure><p id="3827" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu"> <em class="oh">注意:</em> </strong> <em class="oh">我们在这里使用的是</em> <code class="fe np nq nr ng b"><em class="oh">any</em></code> <em class="oh">类型，因为您可以传入自定义标题和数据类型的无限组合。</em></p><p id="9315" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是对<code class="fe np nq nr ng b">defaultResponses.ts</code>中发生的事情的分析。在我们的函数中，我们需要用一个<code class="fe np nq nr ng b">body</code>、<code class="fe np nq nr ng b">headers</code>和<code class="fe np nq nr ng b">statusCode</code>以AWS Lambda理解的方式格式化我们的响应。我们可以简单地在每个函数中分别构建对象，但是这违背了软件开发的基本规则，即枯燥(不要重复)的编码。相反，我们可以在这里对对象进行一次编码，然后在任何需要的时候调用这个函数。</p><p id="c01a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在让我们确保我们的代码通过了测试。在您的终端中导航到<code class="fe np nq nr ng b">/apis/helloworld/api-responses</code>并运行<code class="fe np nq nr ng b">npm test</code>命令。您应该得到显示所有通过测试的输出，如下所示:</p><pre class="lw lx ly lz gt nf ng nh ni aw nj bi"><span id="3d3d" class="nk md it ng b gy nl nm l nn no">&gt; api-responses-layer@1.0.0 test<br/>/serverless-SAM-typscript-boilerplate/apis/helloworld/layers/api-responses</span><span id="ae80" class="nk md it ng b gy oi nm l nn no">&gt; jest</span><span id="10f2" class="nk md it ng b gy oi nm l nn no"><strong class="ng iu">PASS </strong> src/__tests__/<strong class="ng iu">defaultResponses.test.ts<br/></strong>API Response Success Tests<br/>✓ Should return a default response (3 ms)<br/>✓ Should return custom headers (1 ms)<br/>✓ Should return 204 with no body<br/>✓ Should return 200 with body data<br/>API Response Error Tests<br/>✓ Should return a default error (1 ms)<br/>✓ Should return custom headers (1 ms)<br/>✓ Should return 500 error wtih general (1 ms)<br/>✓ Should return 400 error with message</span><span id="cc96" class="nk md it ng b gy oi nm l nn no"><strong class="ng iu">Test Suites: 1 passed</strong>, 1 total<br/><strong class="ng iu">Tests:       8 passed</strong>, 8 total<br/><strong class="ng iu">Snapshots:   </strong>0 total<br/><strong class="ng iu">Time:</strong>        2.396 s</span><span id="fd29" class="nk md it ng b gy oi nm l nn no">Ran all test suites.</span></pre><p id="73be" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">好消息！一切都在按预期运行。现在让我们通过在终端中运行<code class="fe np nq nr ng b">npm run build:prod</code>命令来构建生产代码。这将把<code class="fe np nq nr ng b">package.json</code>文件复制到<code class="fe np nq nr ng b">/dist</code>文件夹中，然后打包我们所有的源代码。完成后，您应该会得到以下输出:</p><pre class="lw lx ly lz gt nf ng nh ni aw nj bi"><span id="9fbd" class="nk md it ng b gy nl nm l nn no">&gt; api-responses-layer@1.0.0 build:prod <br/>/serverless-SAM-typscript-boilerplate/apis/helloworld/layers/api-responses</span><span id="29e1" class="nk md it ng b gy oi nm l nn no">&gt; npm run clean &amp;&amp; mkdir ./dist &amp;&amp; cp package.json ./dist/package.json &amp;&amp; NODE_ENV=${NODE_ENV:-production} webpack</span><span id="9bb4" class="nk md it ng b gy oi nm l nn no">&gt; api-responses-layer@1.0.0 clean<br/>/serverless-SAM-typscript-boilerplate/apis/helloworld/layers/api-responses</span><span id="5646" class="nk md it ng b gy oi nm l nn no">&gt; rm -rf dist/</span><span id="39d4" class="nk md it ng b gy oi nm l nn no">Hash: <strong class="ng iu">53f69af59a60000f45fc<br/></strong>Version: webpack <strong class="ng iu">4.43.0<br/></strong>Time: <strong class="ng iu">1990</strong>ms<br/>Built at: 07/22/2020 <strong class="ng iu">10:32:54 AM</strong></span><span id="ee65" class="nk md it ng b gy oi nm l nn no"><strong class="ng iu">Asset</strong>      <strong class="ng iu">Size</strong>  <strong class="ng iu">Chunks</strong>                   <strong class="ng iu">Chunk Names</strong></span><span id="5696" class="nk md it ng b gy oi nm l nn no"><strong class="ng iu">defaultApiResponses.js</strong>  1.65 KiB       <strong class="ng iu">0</strong>  <strong class="ng iu">[emitted]</strong>        defaultApiResponses</span><span id="1d41" class="nk md it ng b gy oi nm l nn no"><strong class="ng iu">defaultApiResponses.js.map</strong>  7.09 KiB       <strong class="ng iu">0</strong>  <strong class="ng iu">[emitted] [dev]</strong>  defaultApiResponses</span><span id="fb5f" class="nk md it ng b gy oi nm l nn no">Entrypoint <strong class="ng iu">defaultApiResponses</strong> = <strong class="ng iu">defaultApiResponses.js</strong> <strong class="ng iu">defaultApiResponses.js.map</strong></span><span id="4ade" class="nk md it ng b gy oi nm l nn no">[0] <strong class="ng iu">./src/defaultResponses.ts</strong> 1.86 KiB {<strong class="ng iu">0</strong>}<strong class="ng iu"> [built]</strong></span></pre><p id="3930" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在让我们在<code class="fe np nq nr ng b">/apis/helloworld/template.yaml</code>文件中注册我们的新层。新文件应该如下所示:</p><figure class="lw lx ly lz gt ju"><div class="bz fp l di"><div class="og mb l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">带有API响应层更新的template.yaml</figcaption></figure><p id="de0b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们在终端中导航回<code class="fe np nq nr ng b">/apis/helloworld/</code>并运行<code class="fe np nq nr ng b">sam build</code>命令，我们将看到我们的第二层已经成功构建。输出应该如下所示:</p><pre class="lw lx ly lz gt nf ng nh ni aw nj bi"><span id="9fce" class="nk md it ng b gy nl nm l nn no">Building layer 'GlobalDependenciesLayer'<br/>Running NodejsNpmBuilder:NpmPack<br/>Running NodejsNpmBuilder:CopyNpmrc<br/>Running NodejsNpmBuilder:CopySource<br/>Running NodejsNpmBuilder:NpmInstall<br/>Running NodejsNpmBuilder:CleanUpNpmrc<br/>Building layer 'GlobalApiResponsesLayer'<br/>Running NodejsNpmBuilder:NpmPack<br/>Running NodejsNpmBuilder:CopyNpmrc<br/>Running NodejsNpmBuilder:CopySource<br/>Running NodejsNpmBuilder:NpmInstall<br/>Running NodejsNpmBuilder:CleanUpNpmrc</span><span id="5215" class="nk md it ng b gy oi nm l nn no">Build Succeeded</span><span id="0519" class="nk md it ng b gy oi nm l nn no">Built Artifacts  : .aws-sam/build<br/>Built Template   : .aws-sam/build/template.yaml</span><span id="4afd" class="nk md it ng b gy oi nm l nn no">Commands you can use next<br/>=========================<br/>[*] Invoke Function: sam local invoke<br/>[*] Deploy: sam deploy --guided</span></pre><h1 id="4f34" class="mc md it bd me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz bi translated">构建我们的问候功能</h1><p id="7424" class="pw-post-body-paragraph kg kh it ki b kj na kl km kn nb kp kq kr nc kt ku kv nd kx ky kz ne lb lc ld im bi translated">到目前为止，我们已经有了两层，其中包含了一些可重用的依赖项和代码。让我们构建我们的第一个函数，这样我们就可以看到它们是如何联系在一起的。在IDE中导航到<code class="fe np nq nr ng b">/apis/helloworld/functions/greeting</code>，让我们创建另一个<code class="fe np nq nr ng b">package.json</code>文件。这段代码看起来应该很熟悉:</p><figure class="lw lx ly lz gt ju"><div class="bz fp l di"><div class="og mb l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">问候功能包. json文件</figcaption></figure><p id="28b4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在通过在你的终端中导航到<code class="fe np nq nr ng b">/apis/helloworld/functions/greeting</code>并使用<code class="fe np nq nr ng b">npm install</code>命令来安装所有的东西。</p><p id="a7dd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另外，确保将以下文件从<code class="fe np nq nr ng b">/apis/helloworld/layers/api-responses</code>复制到<code class="fe np nq nr ng b">/apis/helloworld/functions/greeting</code>:</p><pre class="lw lx ly lz gt nf ng nh ni aw nj bi"><span id="9408" class="nk md it ng b gy nl nm l nn no">.eslintrc<br/>.prettierrc<br/>jest.config.js<br/>tsconfig.json<br/>webpack.config.js</span></pre><p id="4a61" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为函数都是自包含的程序，我们需要确保我们所有的环境配置都被继承。一旦完成，创建<code class="fe np nq nr ng b">/greeting/src/__tests__/handler.test.ts</code>文件，让我们像往常一样首先编写单元测试。代码如下:</p><figure class="lw lx ly lz gt ju"><div class="bz fp l di"><div class="og mb l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">问候函数handler.test.ts</figcaption></figure><p id="3916" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们进去在<code class="fe np nq nr ng b">/greeting/src/handler.ts</code>里面写实际的函数。代码如下:</p><figure class="lw lx ly lz gt ju"><div class="bz fp l di"><div class="og mb l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">问候功能处理程序. ts</figcaption></figure><p id="880b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，如果你粘贴代码，你可能会看到一个<code class="fe np nq nr ng b">Cannot find module ‘/opt/nodejs/defaultResponses’ or its corresponding type declarations. </code>类型脚本错误。</p><p id="c6ac" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们回顾一下为什么会抛出这个错误。抛出错误的行是导入我们的API响应层的行，这里是:</p><pre class="lw lx ly lz gt nf ng nh ni aw nj bi"><span id="c3c7" class="nk md it ng b gy nl nm l nn no">import response from '/opt/nodejs/defaultResponses';</span></pre><p id="0667" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们从<code class="fe np nq nr ng b">template.yaml</code>文件中知道，我们告诉SAM CLI从<code class="fe np nq nr ng b">layers/api-responses/dist</code>获取API响应层，那么为什么我们在<code class="fe np nq nr ng b">/opt/nodejs</code>引用它呢？这是因为SAM CLI将所有功能层打包到<code class="fe np nq nr ng b">/opt/nodejs/</code>。</p><p id="d3ab" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu"> <em class="oh">注意:</em> </strong> <em class="oh">如果有多个层的文件名相同，那么最后引用的层将是打包成</em> <code class="fe np nq nr ng b"><em class="oh">/opt/nodejs</em></code> <em class="oh">的代码。</em></p><p id="7626" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在有趣的部分来了。Typescript不知道我们正在开发一个SAM CLI应用程序，所以它不知道在哪里寻找我们的文件。为了解决这个问题，让我们通过在我们的<code class="fe np nq nr ng b">tsconfig.json</code>文件中添加<code class="fe np nq nr ng b">baseUrl</code>和<code class="fe np nq nr ng b">paths</code>变量来声明一个别名。现在应该是这样的:</p><figure class="lw lx ly lz gt ju"><div class="bz fp l di"><div class="og mb l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">问候功能tsconfig.json文件</figcaption></figure><p id="7e8d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">嘣，错误消失了！好吧，让我们确保所有的测试都正常。在终端导航到<code class="fe np nq nr ng b">/apis/helloworld/functions/greeting</code>并运行<code class="fe np nq nr ng b">npm test</code>命令。它应该是这样的:</p><figure class="lw lx ly lz gt ju"><div class="bz fp l di"><div class="og mb l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">问候功能Jest配置错误</figcaption></figure><p id="3903" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">WTF？！？！？又一个错误！我以为我们已经修好了？</p><p id="1c63" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">好吧，看来带有<code class="fe np nq nr ng b">ts-jest</code>的Jest无法读取我们的<code class="fe np nq nr ng b">tsconfig.json</code>。不过我们很幸运，<code class="fe np nq nr ng b">ts-jest</code>创建了<code class="fe np nq nr ng b">pathsToModuleNameMapper</code>实用程序来帮助解决这个问题。让我们打开我们的<code class="fe np nq nr ng b">/apis/helloworld/functions/greeting/jest.config.js</code>文件并添加它。下面是新代码:</p><figure class="lw lx ly lz gt ju"><div class="bz fp l di"><div class="og mb l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">问候功能jest.config.js文件</figcaption></figure><p id="fa17" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们现在再做一次测试。你应该知道这个:</p><figure class="lw lx ly lz gt ju"><div class="bz fp l di"><div class="og mb l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">问候功能玩笑测试通过</figcaption></figure><p id="6393" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们现在处于最后阶段。我们所要做的就是用SAM CLI模板注册函数并构建代码。首先让我们在<code class="fe np nq nr ng b">/apis/helloworld/template.yaml</code>文件中注册这个函数。现在应该是这样的:</p><figure class="lw lx ly lz gt ju"><div class="bz fp l di"><div class="og mb l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">包含问候功能的template.yaml文件</figcaption></figure><p id="be13" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，在我们得到类似Typescript和Jest的另一个模块未找到错误之前，让我们更新我们的<code class="fe np nq nr ng b">webpack.config.ts</code>文件，将<code class="fe np nq nr ng b">alias</code>添加到Webpack的解析器中。以下是新文件:</p><figure class="lw lx ly lz gt ju"><div class="bz fp l di"><div class="og mb l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">问候功能webpack.config.ts文件</figcaption></figure><p id="a0e6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">好了，现在让我们在终端中导航到<code class="fe np nq nr ng b">/apis/helloworld/functions/greeting</code>并运行<code class="fe np nq nr ng b">npm run build:prod</code>命令来打包我们的新函数。您应该得到以下输出:</p><figure class="lw lx ly lz gt ju"><div class="bz fp l di"><div class="og mb l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">问候功能Webpack成功输出</figcaption></figure><p id="b8fc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">很好，现在让我们用SAM CLI构建应用程序。在终端导航到<code class="fe np nq nr ng b">/apis/helloworld</code>并运行<code class="fe np nq nr ng b">sam build</code>命令。一切都应该构建成功，您应该得到这个输出。</p><figure class="lw lx ly lz gt ju"><div class="bz fp l di"><div class="og mb l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">sam build命令的输出</figcaption></figure><p id="dae1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">恭喜你！您已经成功地用Typescript和layers构建了一个无服务器样板文件。如果您运行<code class="fe np nq nr ng b">sam local start-api</code>命令，您将看到可以调用您的函数的URL。它看起来会像这样:</p><pre class="lw lx ly lz gt nf ng nh ni aw nj bi"><span id="4051" class="nk md it ng b gy nl nm l nn no">Mounting GreetingFunction at http://127.0.0.1:3000/hello [GET]</span></pre><p id="2011" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您在浏览器中访问该URL，您应该会看到如下输出:</p><pre class="lw lx ly lz gt nf ng nh ni aw nj bi"><span id="9028" class="nk md it ng b gy nl nm l nn no">{"error":{},"data":{"message":"Hello World!"}}</span></pre><p id="c596" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">嘣！现在，这个无服务器的世界是你的了。走出去，建立下一个网飞或什么的。干杯！像往常一样，如果你发现一个错误，让我知道。</p><figure class="lw lx ly lz gt ju"><div class="bz fp l di"><div class="oj mb l"/></div></figure></div></div>    
</body>
</html>