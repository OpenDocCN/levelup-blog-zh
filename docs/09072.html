<html>
<head>
<title>Composite Data Types in Golang</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Golang中的复合数据类型</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/composite-data-types-in-golang-a829288b5553?source=collection_archive---------1-----------------------#2021-07-03">https://levelup.gitconnected.com/composite-data-types-in-golang-a829288b5553?source=collection_archive---------1-----------------------#2021-07-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="99af" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Go支持复合类型，如数组、切片、映射和结构。我们将逐一讨论这四种复合类型</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/f3ce4c69e5f63633aec36c8214fdc046.png" data-original-src="https://miro.medium.com/v2/resize:fit:1344/format:webp/1*woZaBaFrmDR6N-RLNEjnvg.png"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">Golang数据类型</figcaption></figure><p id="548b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在Go中，数据类型分为以下四类:</p><ol class=""><li id="58c7" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp lv lw lx ly bi translated">基本类型:数字、字符串和布尔值都属于这一类。</li><li id="9636" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated"><strong class="kw iu">聚集类型:</strong>数组和结构属于这一类别。它们的值是内存中其他值的串联。</li><li id="105f" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated"><strong class="kw iu">引用类型:</strong>指针、切片、地图、函数、通道都属于此类。</li><li id="7850" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp lv lw lx ly bi translated"><strong class="kw iu">接口类型</strong></li></ol><p id="b64f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这篇文章中，我们将讨论四种复合类型:<em class="me">数组、切片、映射、结构。</em></p><h1 id="8896" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">目录</h1><ul class=""><li id="adf3" class="lq lr it kw b kx mx la my ld mz lh na ll nb lp nc lw lx ly bi translated"><a class="ae nd" href="#866f" rel="noopener ugc nofollow">数组</a></li><li id="abb7" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp nc lw lx ly bi translated"><a class="ae nd" href="#d610" rel="noopener ugc nofollow">切片</a></li><li id="589b" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp nc lw lx ly bi translated"><a class="ae nd" href="#640d" rel="noopener ugc nofollow">地图</a></li><li id="9841" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp nc lw lx ly bi translated"><a class="ae nd" href="#e9ca" rel="noopener ugc nofollow">结构</a></li></ul></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h1 id="866f" class="mf mg it bd mh mi nl mk ml mm nm mo mp jz nn ka mr kc no kd mt kf np kg mv mw bi translated"><strong class="ak">阵列</strong></h1><ul class=""><li id="d4af" class="lq lr it kw b kx mx la my ld mz lh na ll nb lp nc lw lx ly bi translated">数组存储与<strong class="kw iu">同类型</strong> ( <em class="me">同质</em>)的项目集合</li><li id="f210" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp nc lw lx ly bi translated">数组中的元素存储在<strong class="kw iu">连续内存位置</strong></li><li id="b88c" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp nc lw lx ly bi translated">数组具有固定的大小</li><li id="2112" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp nc lw lx ly bi translated">申报样式</li></ul><pre class="kj kk kl km gt nq nr ns nt aw nu bi"><span id="f7d9" class="nv mg it nr b gy nw nx l ny nz">// Given fixed size<br/>a := [3]int{1,2,3}</span><span id="6f95" class="nv mg it nr b gy oa nx l ny nz">//  Array literal with length inferred<br/>a := [...]int{1,2,3}</span><span id="abdb" class="nv mg it nr b gy oa nx l ny nz">var a [3]int<br/>a[0] = 1<br/>a[1] = 2<br/>a[2] = 3</span></pre><p id="fc52" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在数组文本中，<code class="fe ob oc od nr b">...</code>符号指定的长度等于文本中元素的数量。</p><ul class=""><li id="05f1" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp nc lw lx ly bi translated">数组副本引用<strong class="kw iu">不同的</strong>底层数据。</li></ul><p id="8405" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当数组用作函数参数时，内部的函数接收数组的副本，而不是原始数组。这种行为不同于其他通过引用隐式传递数组的语言。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/5eed6a24c865ad0e2b4f21f8ff25dd0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1382/format:webp/1*xk5eaCSl3bKUu3IuNQdi9w.png"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">go的数组副本</figcaption></figure><h1 id="d610" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">薄片</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="og oh di oi bf oj"><div class="gh gi of"><img src="../Images/0b422684e6e4e73b9360b44cfa887130.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*XIbYLIcsATb0Tyfd.png"/></div></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk translated">切片示例</figcaption></figure><ul class=""><li id="fa49" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp nc lw lx ly bi translated">切片不存储任何数据，它只是描述底层阵列的一部分，并由该阵列提供支持</li><li id="6b5f" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp nc lw lx ly bi translated">内置函数<code class="fe ob oc od nr b">len</code>返回切片中元素的数量</li><li id="52e0" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp nc lw lx ly bi translated">内置函数<code class="fe ob oc od nr b">cap</code>返回底层数组的长度</li><li id="4cbd" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp nc lw lx ly bi translated">申报样式</li></ul><pre class="kj kk kl km gt nq nr ns nt aw nu bi"><span id="4a8e" class="nv mg it nr b gy nw nx l ny nz">// slice existing array <br/>a := [...]int{1,2,3,4,5,6}<br/>b := a[:3]</span><span id="5f5e" class="nv mg it nr b gy oa nx l ny nz">// literal style<br/>c := []int{1,2,3,4,5,6}</span><span id="4fb1" class="nv mg it nr b gy oa nx l ny nz">// Via make function<br/>d := make([]int, 10, 100)   // slice with length==10 capacity==100<br/>e := make([]int, 10)   // slice with length==10 capacity==10</span></pre><ul class=""><li id="c290" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp nc lw lx ly bi translated">片拷贝引用<strong class="kw iu">相同的</strong>底层数据，与数组不同</li></ul><h1 id="640d" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">地图</h1><p id="c51d" class="pw-post-body-paragraph ku kv it kw b kx mx ju kz la my jx lc ld ok lf lg lh ol lj lk ll om ln lo lp im bi translated">在Go中，映射是对哈希表的引用。它是按键值对分组的元素的集合</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="og oh di oi bf oj"><div class="gh gi on"><img src="../Images/baaa32ee5d52d570c44182aa4400ba3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MF82DTElbNKV29T22_V8Ug.png"/></div></div></figure><ul class=""><li id="e0ed" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp nc lw lx ly bi translated">申报样式</li></ul><pre class="kj kk kl km gt nq nr ns nt aw nu bi"><span id="169d" class="nv mg it nr b gy nw nx l ny nz">// literal style<br/>p := map[string]int{<br/>    "Key1": 1,<br/>    "Key2": 2,<br/>  }</span><span id="2a46" class="nv mg it nr b gy oa nx l ny nz">// Via make function<br/>q := make(map[string]int)<br/>q["key3"] = 4</span></pre><ul class=""><li id="ae2e" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp nc lw lx ly bi translated">要知道该元素是否存在，请使用如下测试:</li></ul><p id="0c58" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe ob oc od nr b">value, ok := p["Key2"]</code></p><ul class=""><li id="8a2f" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp nc lw lx ly bi translated">多个赋值引用<strong class="kw iu">相同的</strong>底层数据</li></ul><h1 id="e9ca" class="mf mg it bd mh mi mj mk ml mm mn mo mp jz mq ka mr kc ms kd mt kf mu kg mv mw bi translated">结构体</h1><blockquote class="oo op oq"><p id="590c" class="ku kv me kw b kx ky ju kz la lb jx lc or le lf lg os li lj lk ot lm ln lo lp im bi translated">Golang中的结构是最常用的结构之一，也是创建用户定义类型的一种方式。</p></blockquote><p id="0bb8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一个<code class="fe ob oc od nr b">struct</code>是描述一个单一概念的<strong class="kw iu">不同数据类型</strong> ( <em class="me">异构</em> ) <strong class="kw iu"> </strong>的集合。</p><ul class=""><li id="e83f" class="lq lr it kw b kx ky la lb ld ls lh lt ll lu lp nc lw lx ly bi translated">结构中的字段或属性存储在<strong class="kw iu">连续内存位置</strong></li><li id="9c34" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp nc lw lx ly bi translated">就像数组一样，它有固定的大小</li><li id="5608" class="lq lr it kw b kx lz la ma ld mb lh mc ll md lp nc lw lx ly bi translated">结构副本引用<strong class="kw iu">不同的</strong>底层数据</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/f4043684d2f6b4d1d7207bfd2757e584.png" data-original-src="https://miro.medium.com/v2/resize:fit:1382/format:webp/1*UUEqU_mwwkqSw1dIKgYOWg.png"/></div></figure></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><p id="3016" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">很好，我相信您现在对四种复合类型已经很有信心了:数组、切片、映射和结构。</p></div></div>    
</body>
</html>