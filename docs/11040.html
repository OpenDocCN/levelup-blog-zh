<html>
<head>
<title>How to Write Performant React Apps with Context</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用上下文编写高性能的反应应用程序</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-write-performant-react-apps-with-context-83b27756c6a0?source=collection_archive---------2-----------------------#2022-02-10">https://levelup.gitconnected.com/how-to-write-performant-react-apps-with-context-83b27756c6a0?source=collection_archive---------2-----------------------#2022-02-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/5ebed750133f1f2229806b44c0bd1891.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kFZjeqq9u_1nvVcvF_d5Yg.png"/></div></div></figure><p id="d273" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">没有一两篇关于上下文的文章，就不可能有关于<a class="ae kw" href="https://www.developerway.com/posts/how-to-write-performant-react-code" rel="noopener ugc nofollow" target="_blank">如何编写performant React代码</a>的对话。而且是这么有争议的话题！有很多偏见和谣言围绕着它。上下文是邪恶的！使用上下文时，React会毫无理由地重新渲染所有内容！有时候我觉得开发者把上下文当成了一个神奇的小精灵，随机地、自发地重新渲染整个应用程序来娱乐自己。</p><p id="71b5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这篇文章中，我不打算说服任何人我们应该抛弃我们钟爱的国家管理库而支持上下文。他们的存在是有原因的。这里的主要目标是消除上下文的神秘感，并提供一些有趣的编码模式，这可以帮助最小化与上下文相关的重新渲染，并提高React应用程序的性能。还有一个好处是，代码看起来更干净，更容易理解。</p><p id="b1c1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们通过实现一些现实生活中的应用程序来开始调查，看看这会把我们带到哪里。</p><h1 id="604f" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">让我们在React中实现一个表单</h1><p id="cdfa" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">我们的形式将会非常复杂，首先，它将包括:</p><ul class=""><li id="a3d1" class="ma mb iq ka b kb kc kf kg kj mc kn md kr me kv mf mg mh mi bi translated">“个人信息”部分，人们可以设置一些个人信息，如姓名，电子邮件等</li><li id="0b2e" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">一个“价值计算”部分，人们可以设置他们的货币偏好，他们喜欢的折扣，添加一些优惠券等</li><li id="bc9d" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">选择的折扣应该以表情符号的形式在个人部分突出显示(不要问，设计师有一种奇怪的幽默感)</li><li id="ed29" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">带有操作按钮的“操作”部分(即“保存”、“重置”等)</li></ul><p id="a9da" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">“设计”看起来是这样的:</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mo"><img src="../Images/52add024ccda6abbc00c8910f8ca8c34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*pgWgliNW3rcaD4Nt.png"/></div></div></figure><p id="68f7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了让事情变得更有趣，我们还将假装“选择国家”和“拖动栏”组件是我们作为一个包安装的“外部”库。所以我们只能通过API来使用它们，而对里面的东西没有任何影响。我们将使用“慢速”版本的国家选择，这是我们在<a class="ae kw" href="https://www.developerway.com/posts/how-to-write-performant-react-code" rel="noopener ugc nofollow" target="_blank">之前的绩效调查</a>中实施的。</p><p id="0437" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在是时候写一些代码了。先说app的组件结构。我知道这个表单很快会变得非常复杂，所以我想马上把它分成更小、更包容的组件。</p><p id="2fe2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在根处，我将拥有我的主<code class="fe mt mu mv mw b">Form</code>组件，它将呈现三个必需的部分:</p><pre class="mp mq mr ms gt mx mw my mz aw na bi"><span id="7f10" class="nb ky iq mw b gy nc nd l ne nf"><em class="ng">const Form = () =&gt; {<br/>  return (<br/>    &lt;&gt;<br/>      &lt;PersonalInfoSection /&gt;<br/>      &lt;ValueCalculationsSection /&gt;<br/>      &lt;ActionsSection /&gt;<br/>    &lt;/&gt;<br/>  );<br/>};</em></span></pre><p id="f0c1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">“个人信息”部分将呈现三个组件:折扣表情符号、姓名输入和国家选择</p><pre class="mp mq mr ms gt mx mw my mz aw na bi"><span id="a7fd" class="nb ky iq mw b gy nc nd l ne nf"><em class="ng">const PersonalInfoSection = () =&gt; {<br/>  return (<br/>    &lt;Section title="Personal information"&gt;<br/>      &lt;DiscountSituation /&gt;<br/>      &lt;NameFormComponent /&gt;<br/>      &lt;SelectCountryFormComponent /&gt;<br/>    &lt;/Section&gt;<br/>  );<br/>};</em></span></pre><p id="9a31" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它们三个都将包含那些组件的实际逻辑(它们的代码将在下面)，而<code class="fe mt mu mv mw b">Section</code>只是封装了一些样式。</p><p id="01f1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">“价值计算”部分只有一个组件(目前)，折扣栏:</p><pre class="mp mq mr ms gt mx mw my mz aw na bi"><span id="f3d6" class="nb ky iq mw b gy nc nd l ne nf"><em class="ng">const ValueCalculationSection = () =&gt; {<br/>  return (<br/>    &lt;Section title="Value calculation"&gt;<br/>      &lt;DiscountFormComponent /&gt;<br/>    &lt;/Section&gt;<br/>  );<br/>};</em></span></pre><p id="a29d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">“Actions”部分现在也只有一个按钮:带有onSave回调的save按钮。</p><pre class="mp mq mr ms gt mx mw my mz aw na bi"><span id="c490" class="nb ky iq mw b gy nc nd l ne nf"><em class="ng">const ActionsSection = ({ onSave }: { onSave: () =&gt; void }) =&gt; {<br/>  return (<br/>    &lt;Section title="Actions"&gt;<br/>      &lt;button onClick={onClick}&gt;Save form&lt;/button&gt;<br/>    &lt;/Section&gt;<br/>  );<br/>};</em></span></pre><p id="d1b1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在有趣的部分是:我们需要使这个表单具有交互性。考虑到整个表单只有一个“保存”按钮，而且不同的部分需要来自其他部分的数据，状态管理的自然位置是在根，在<code class="fe mt mu mv mw b">Form</code>组件中。我们将有3个数据:姓名、国家和折扣，一个设置这三个数据的方法，以及一个“保存”它的方法:</p><pre class="mp mq mr ms gt mx mw my mz aw na bi"><span id="b6b9" class="nb ky iq mw b gy nc nd l ne nf"><em class="ng">type State = {<br/>  name: string;<br/>  country: Country;<br/>  discount: number;<br/>};<br/><br/>const Form = () =&gt; {<br/>  const [state, setState] = useState&lt;State&gt;(defaultState as State);<br/><br/>  const onSave = () =&gt; {<br/>    // send the request to the backend here<br/>  };<br/><br/>  const onDiscountChange = (discount: number) =&gt; {<br/>    setState({ ...state, discount });<br/>  };<br/><br/>  const onNameChange = (name: string) =&gt; {<br/>    setState({ ...state, name });<br/>  };<br/><br/>  const onCountryChange = (country: Country) =&gt; {<br/>    setState({ ...state, country });<br/>  };<br/><br/>  // the rest as before<br/>};</em></span></pre><p id="0532" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们需要将相关数据和回调传递给需要它的组件。在我们的<code class="fe mt mu mv mw b">PersonalInfoSection</code>:</p><ul class=""><li id="5eb3" class="ma mb iq ka b kb kc kf kg kj mc kn md kr me kv mf mg mh mi bi translated"><code class="fe mt mu mv mw b">DiscountSituation</code>组件应该能够显示基于<code class="fe mt mu mv mw b">discount</code>值的表情符号。</li><li id="6a9c" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated"><code class="fe mt mu mv mw b">NameFormComponent</code>应该可以控制<code class="fe mt mu mv mw b">name</code>的值</li><li id="7111" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated"><code class="fe mt mu mv mw b">SelectCountryFormComponent</code>应能设置所选的<code class="fe mt mu mv mw b">country</code></li></ul><p id="23f7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">考虑到这些组件没有直接在<code class="fe mt mu mv mw b">Form</code>中呈现，而是<code class="fe mt mu mv mw b">PersonalInfoSection</code>的子组件，是时候做一些道具练习了😊</p><p id="2520" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mt mu mv mw b">DiscountSituation</code>会接受<code class="fe mt mu mv mw b">discount</code>作为道具:</p><pre class="mp mq mr ms gt mx mw my mz aw na bi"><span id="57f8" class="nb ky iq mw b gy nc nd l ne nf"><em class="ng">export const DiscountSituation = ({ discount }: { discount: number }) =&gt; {<br/>  // some code to calculate the situation based on discount<br/>  const discountSituation = ...;<br/>  return &lt;div&gt;Your discount situation: {discountSituation}&lt;/div&gt;;<br/>};</em></span></pre><p id="9a8a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mt mu mv mw b">NameFormComponent</code>将接受<code class="fe mt mu mv mw b">name</code>和<code class="fe mt mu mv mw b">onChange</code>的回调:</p><pre class="mp mq mr ms gt mx mw my mz aw na bi"><span id="d349" class="nb ky iq mw b gy nc nd l ne nf"><em class="ng">export const NameFormComponent = ({ onChange, name }: { onChange: (val: string) =&gt; void; name: string }) =&gt; {<br/>  return (<br/>    &lt;div&gt;<br/>      Type your name here: &lt;br /&gt;<br/>      &lt;input onChange={() =&gt; onChange(e.target.value)} value={name} /&gt;<br/>    &lt;/div&gt;<br/>  );<br/>};</em></span></pre><p id="b275" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mt mu mv mw b">SelectCountryFormComponent</code>将接受<code class="fe mt mu mv mw b">onChange</code>的回调:</p><pre class="mp mq mr ms gt mx mw my mz aw na bi"><span id="396e" class="nb ky iq mw b gy nc nd l ne nf"><em class="ng">export const SelectCountryFormComponent = ({ onChange }: { onChange: (country: Country) =&gt; void }) =&gt; {<br/>  return &lt;SelectCountry onChange={onChange} /&gt;;<br/>};</em></span></pre><p id="0e82" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的<code class="fe mt mu mv mw b">PersonalInfoSection</code>必须将它们从其父<code class="fe mt mu mv mw b">Form</code>组件传递给其子组件:</p><pre class="mp mq mr ms gt mx mw my mz aw na bi"><span id="7f1b" class="nb ky iq mw b gy nc nd l ne nf"><em class="ng">export const PersonalInfoSection = ({<br/>  onNameChange,<br/>  onCountryChange,<br/>  discount,<br/>  name,<br/>}: {<br/>  onNameChange: (name: string) =&gt; void;<br/>  onCountryChange: (name: Country) =&gt; void;<br/>  discount: number;<br/>  name: string;<br/>}) =&gt; {<br/>  return (<br/>    &lt;Section title="Personal information"&gt;<br/>      &lt;DiscountSituation discount={discount} /&gt;<br/>      &lt;NameFormComponent onChange={onNameChange} name={name} /&gt;<br/>      &lt;SelectCountryFormComponent onChange={onCountryChange} /&gt;<br/>    &lt;/Section&gt;<br/>  );<br/>};</em></span></pre><p id="fcf5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">与<code class="fe mt mu mv mw b">ValueCalculationSection</code>的情况相同；它需要将<code class="fe mt mu mv mw b">onDiscountChange</code>和<code class="fe mt mu mv mw b">discount</code>的值从<code class="fe mt mu mv mw b">Form</code>组件传递给其子组件；</p><pre class="mp mq mr ms gt mx mw my mz aw na bi"><span id="28c2" class="nb ky iq mw b gy nc nd l ne nf"><em class="ng">export const ValueCalculationsSection = ({ onDiscountChange }: { onDiscountChange: (val: number) =&gt; void }) =&gt; {<br/>  console.info('ValueCalculationsSection render');<br/>  return (<br/>    &lt;Section title="Value calculation"&gt;<br/>      &lt;DiscountFormComponent onDiscountChange={onDiscountChange} /&gt;<br/>    &lt;/Section&gt;<br/>  );<br/>};</em></span></pre><p id="683b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">而<code class="fe mt mu mv mw b">DiscountFormComponent</code>只是使用“外部”库<code class="fe mt mu mv mw b">DraggingBar</code>来呈现工具条，并通过它给出的回调来捕捉变化:</p><pre class="mp mq mr ms gt mx mw my mz aw na bi"><span id="c806" class="nb ky iq mw b gy nc nd l ne nf"><em class="ng">export const DiscountFormComponent = ({ onDiscountChange }: { onDiscountChange: (value: number) =&gt; void }) =&gt; {<br/>  console.info('DiscountFormComponent render');<br/>  return (<br/>    &lt;div&gt;<br/>      Please select your discount here: &lt;br /&gt;<br/>      &lt;DraggingBar onChange={(value: number) =&gt; onDiscountChange(value)} /&gt;<br/>    &lt;/div&gt;<br/>  );<br/>};</em></span></pre><p id="9b3e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">并且，我们的<code class="fe mt mu mv mw b">Form</code>组件的渲染看起来像这样:</p><pre class="mp mq mr ms gt mx mw my mz aw na bi"><span id="c1e7" class="nb ky iq mw b gy nc nd l ne nf"><em class="ng">const Form = () =&gt; {<br/>  return (<br/>    &lt;div&gt;<br/>      &lt;PersonalInfoSection onNameChange={onNameChange} onCountryChange={onCountryChange} discount={state.discount} name={state.name} /&gt;<br/>      &lt;ValueCalculationsSection onDiscountChange={onDiscountChange} /&gt;<br/>      &lt;ActionsSection onSave={onSave} /&gt;<br/>    &lt;/div&gt;<br/>  );<br/>};</em></span></pre><p id="4101" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">相当多的代码，但最终完成了😅想看看结果吗？<a class="ae kw" href="https://codesandbox.io/s/form-initial-implementation-uxw8v?file=/src/App.tsx" rel="noopener ugc nofollow" target="_blank">参见codesandbox。</a></p><p id="239b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不幸的是，由几个组件和一个简单的状态组成的结果比您预期的要糟糕得多😕试着在输入中输入你的名字，或者拖动蓝色条——这两种方式即使在快速的笔记本电脑上也会滞后。由于CPU节流，它们基本上是不可用的。发生了什么事？</p><h1 id="4f75" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">前绩效调查</h1><p id="9d26" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">首先，我们来看看那里的控制台输出。如果我在<code class="fe mt mu mv mw b">Name</code>输入中键入一个键，我会看到:</p><pre class="mp mq mr ms gt mx mw my mz aw na bi"><span id="05cf" class="nb ky iq mw b gy nc nd l ne nf"><em class="ng">Form render<br/>PersonalInfoSection render<br/>Section render<br/>Discount situation render<br/>NameFormComponent render<br/>SelectCountryFormComponent render<br/>ValueCalculationsSection render<br/>Section render<br/>DiscountFormComponent render<br/>ActionsSection render<br/>Section render</em></span></pre><p id="9359" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们表单中的每一个组件都会在每次击键时重新呈现！拖动也是同样的情况——每移动一次鼠标，整个表单及其所有组件都会重新呈现。我们已经知道，我们的<code class="fe mt mu mv mw b">SelectCountryFormComponent</code>非常慢，我们对它的性能无能为力。所以我们唯一能做的就是确保它不会在每次按键或鼠标移动时重新呈现。</p><p id="18ed" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们知道，组件会在以下情况下重新呈现:</p><ul class=""><li id="acbf" class="ma mb iq ka b kb kc kf kg kj mc kn md kr me kv mf mg mh mi bi translated">组件的状态已更改</li><li id="b271" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">父组件重新渲染</li></ul><p id="aba8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这正是这里发生的事情:当输入中的值改变时，我们通过回调链将该值向上传播到根<code class="fe mt mu mv mw b">Form</code>组件，在那里我们改变根状态，这触发了<code class="fe mt mu mv mw b">Form</code>组件的重新呈现，然后向下级联到该组件的每个子组件和子组件的子组件(即所有子组件)。</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nh"><img src="../Images/5891d5babe86e1bf2e0cce51310d0adf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*kk9WPt-OV4tzU05s.png"/></div></div></figure><p id="cab3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了解决这个问题，我们当然可以在战略位置撒一些<code class="fe mt mu mv mw b">useMemo</code>和<code class="fe mt mu mv mw b">useCallback</code>，然后就到此为止。但这只是掩盖了问题，并没有真正解决问题。当将来我们引入另一个慢组件时，这个故事将会重演。更不用说这会使代码变得更加复杂和难以维护。在理想情况下，当我在<code class="fe mt mu mv mw b">Name</code>组件中键入一些内容时，我只希望<code class="fe mt mu mv mw b">NameFormComponent</code>和实际使用<code class="fe mt mu mv mw b">name</code>值的组件重新呈现，其余的应该只是闲置在那里，等待轮到它们进行交互。</p><p id="6f4e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">React实际上给了我们一个完美的工具来做到这一点——<code class="fe mt mu mv mw b">Context</code>！</p><h1 id="5614" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">向表单添加上下文</h1><p id="af96" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">根据<a class="ae kw" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank"> React docs </a>，上下文提供了一种通过组件树传递数据的方式，而不必在每一层手动向下传递属性。举例来说，如果我们将表单状态提取到上下文中，我们可以去掉所有我们通过中间部分(如<code class="fe mt mu mv mw b">PersonalInfoSection</code>)传递的道具，直接在<code class="fe mt mu mv mw b">NameFormComponent</code>和<code class="fe mt mu mv mw b">DiscountFormComponent</code>中使用状态。数据流看起来会像这样:</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ni"><img src="../Images/5d017d0340cfa1430cd0d509e4969800.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*x6sRkE_5g-9hV30h.png"/></div></div></figure><p id="4c28" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了实现这一点，首先，我们正在创建<code class="fe mt mu mv mw b">Context</code>本身，它将拥有我们的状态和管理该状态的API(即我们的回调):</p><pre class="mp mq mr ms gt mx mw my mz aw na bi"><span id="7a30" class="nb ky iq mw b gy nc nd l ne nf"><em class="ng">type State = {<br/>  name: string;<br/>  country: Country;<br/>  discount: number;<br/>};<br/><br/>type Context = {<br/>  state: State;<br/>  onNameChange: (name: string) =&gt; void;<br/>  onCountryChange: (name: Country) =&gt; void;<br/>  onDiscountChange: (price: number) =&gt; void;<br/>  onSave: () =&gt; void;<br/>};<br/><br/>const FormContext = createContext&lt;Context&gt;({} as Context);</em></span></pre><p id="3657" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后我们应该移动所有的状态逻辑，在<code class="fe mt mu mv mw b">Form</code>中，在<code class="fe mt mu mv mw b">FormDataProvider</code>组件中，并将状态和回调附加到新创建的<code class="fe mt mu mv mw b">Context</code>:</p><pre class="mp mq mr ms gt mx mw my mz aw na bi"><span id="b557" class="nb ky iq mw b gy nc nd l ne nf"><em class="ng">export const FormDataProvider = ({ children }: { children: ReactNode }) =&gt; {<br/>  const [state, setState] = useState&lt;State&gt;({} as State);<br/><br/>  const value = useMemo(() =&gt; {<br/>    const onSave = () =&gt; {<br/>      // send the request to the backend here<br/>    };<br/><br/>    const onDiscountChange = (discount: number) =&gt; {<br/>      setState({ ...state, discount });<br/>    };<br/><br/>    const onNameChange = (name: string) =&gt; {<br/>      setState({ ...state, name });<br/>    };<br/><br/>    const onCountryChange = (country: Country) =&gt; {<br/>      setState({ ...state, country });<br/>    };<br/><br/>    return {<br/>      state,<br/>      onSave,<br/>      onDiscountChange,<br/>      onNameChange,<br/>      onCountryChange,<br/>    };<br/>  }, [state]);<br/><br/>  return &lt;FormContext.Provider value={value}&gt;{children}&lt;/FormContext.Provider&gt;;<br/>};</em></span></pre><p id="45e0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后公开挂钩，让其他组件使用该上下文，而无需直接访问它:</p><pre class="mp mq mr ms gt mx mw my mz aw na bi"><span id="a43e" class="nb ky iq mw b gy nc nd l ne nf"><em class="ng">export const useFormState = () =&gt; useContext(FormContext);</em></span></pre><p id="08a5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">并将我们的<code class="fe mt mu mv mw b">Form</code>组件包装到<code class="fe mt mu mv mw b">FormDataProvider</code>中:</p><pre class="mp mq mr ms gt mx mw my mz aw na bi"><span id="201e" class="nb ky iq mw b gy nc nd l ne nf"><em class="ng">export default function App() {<br/>  return (<br/>    &lt;FormDataProvider&gt;<br/>      &lt;Form /&gt;<br/>    &lt;/FormDataProvider&gt;<br/>  );<br/>}</em></span></pre><p id="3093" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">之后，我们可以在整个app中去掉<strong class="ka ir">所有的道具</strong>，通过<code class="fe mt mu mv mw b">useFormState</code> hook直接在组件中需要的地方使用所需的数据和回调。</p><p id="b3ee" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，我们的根<code class="fe mt mu mv mw b">Form</code>组件将变成这样:</p><pre class="mp mq mr ms gt mx mw my mz aw na bi"><span id="d185" class="nb ky iq mw b gy nc nd l ne nf"><em class="ng">const Form = () =&gt; {<br/>  // no more props anywhere!<br/>  return (<br/>    &lt;div className="App"&gt;<br/>      &lt;PersonalInfoSection /&gt;<br/>      &lt;ValueCalculationsSection /&gt;<br/>      &lt;ActionsSection /&gt;<br/>    &lt;/div&gt;<br/>  );<br/>};</em></span></pre><p id="f115" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">并且<code class="fe mt mu mv mw b">NameFormComponent</code>将能够像这样访问所有数据:</p><pre class="mp mq mr ms gt mx mw my mz aw na bi"><span id="a3b2" class="nb ky iq mw b gy nc nd l ne nf"><em class="ng">export const NameFormComponent = () =&gt; {<br/>  // accessing the data directly right where it's needed!<br/>  const { onNameChange, state } = useFormState();<br/><br/>  const onValueChange = (e: ChangeEvent&lt;HTMLInputElement&gt;) =&gt; {<br/>    onNameChange(e.target.value);<br/>  };<br/><br/>  return (<br/>    &lt;div&gt;<br/>      Type your name here: &lt;br /&gt;<br/>      &lt;input onChange={onValueChange} value={state.name} /&gt;<br/>    &lt;/div&gt;<br/>  );<br/>};</em></span></pre><p id="e3af" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">看看<a class="ae kw" href="https://codesandbox.io/s/form-implementation-with-context-2-3wd2i?file=/src/App.tsx" rel="noopener ugc nofollow" target="_blank">这个代码沙箱</a>里的完整代码。不要忘了欣赏现在没有到处乱七八糟的道具时看起来有多干净！</p><h1 id="db43" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">新形式的表现如何？</h1><p id="2191" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">从性能的角度来看，我们还没有做到这一点:键入名称和拖动滚动条仍然滞后。但是如果我开始输入<code class="fe mt mu mv mw b">NameFormComponent</code>，在控制台中我会看到:</p><pre class="mp mq mr ms gt mx mw my mz aw na bi"><span id="532d" class="nb ky iq mw b gy nc nd l ne nf"><em class="ng">Discount situation render<br/>NameFormComponent render<br/>SelectCountryFormComponent render<br/>DiscountFormComponent render<br/>ActionsSection render<br/>Section render</em></span></pre><p id="c6c1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一半的组件现在不重新渲染，包括我们的父组件<code class="fe mt mu mv mw b">Form</code>。发生这种情况是因为上下文是如何工作的:当一个上下文值改变时，<strong class="ka ir">这个上下文的每个消费者将重新呈现</strong>，不管他们是否使用改变的值。而且，那些被上下文绕过的组件根本不会被重新呈现。我们的重新渲染流现在看起来像这样:</p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nj"><img src="../Images/0bcecbcdd1cd87abf68d6f64250c81e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*E60uWExXdrb0a5jl.png"/></div></div></figure><p id="ce70" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，如果我们仔细观察我们的组件实现，特别是<code class="fe mt mu mv mw b">SelectCountryComponent</code>，它是慢速“外部”组件的包装器，我们会发现它实际上并没有使用<code class="fe mt mu mv mw b">state</code>本身。它所需要的只是<code class="fe mt mu mv mw b">onCountryChange</code>的回调:</p><pre class="mp mq mr ms gt mx mw my mz aw na bi"><span id="dbfb" class="nb ky iq mw b gy nc nd l ne nf"><em class="ng">export const SelectCountryFormComponent = () =&gt; {<br/>  const { onCountryChange } = useFormState();<br/>  console.info('SelectCountryFormComponent render');<br/><br/>  return &lt;SelectCountry onChange={onCountryChange} /&gt;;<br/>};</em></span></pre><p id="5a66" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这给了我们一个机会来尝试一个非常酷的技巧:我们可以将<code class="fe mt mu mv mw b">state</code>部分和<code class="fe mt mu mv mw b">API</code>部分拆分到<code class="fe mt mu mv mw b">FormDataProvider</code>部分。</p><h1 id="7974" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">拆分状态和API</h1><p id="4b45" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">基本上，我们想要做的是将我们的“整体”状态分解成两个“微观”状态😅。</p><p id="f224" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们需要两个上下文，一个用于数据，一个用于API，而不是一个包含所有内容的上下文:</p><pre class="mp mq mr ms gt mx mw my mz aw na bi"><span id="30c3" class="nb ky iq mw b gy nc nd l ne nf"><em class="ng">type State = {<br/>  name: string;<br/>  country: Country;<br/>  discount: number;<br/>};<br/><br/>type API = {<br/>  onNameChange: (name: string) =&gt; void;<br/>  onCountryChange: (name: Country) =&gt; void;<br/>  onDiscountChange: (price: number) =&gt; void;<br/>  onSave: () =&gt; void;<br/>};<br/><br/>const FormDataContext = createContext&lt;State&gt;({} as State);<br/>const FormAPIContext = createContext&lt;API&gt;({} as API);</em></span></pre><p id="e4c4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们的<code class="fe mt mu mv mw b">FormDataProvider</code>组件中没有一个上下文提供者，而是有两个，在这里我们将状态直接传递给<code class="fe mt mu mv mw b">FormDataContext.Provider</code>:</p><pre class="mp mq mr ms gt mx mw my mz aw na bi"><span id="393e" class="nb ky iq mw b gy nc nd l ne nf"><em class="ng">const FormDataProvider = () =&gt; {<br/>  // state logic<br/><br/>  return (<br/>    &lt;FormAPIContext.Provider value={api}&gt;<br/>      &lt;FormDataContext.Provider value={state}&gt;{children}&lt;/FormDataContext.Provider&gt;<br/>    &lt;/FormAPIContext.Provider&gt;<br/>  );<br/>};</em></span></pre><p id="0e34" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在最有趣的部分是<code class="fe mt mu mv mw b">api</code>值。</p><p id="0619" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们只是让它像以前一样，整个“分解”的想法是行不通的，因为我们仍然必须依赖<code class="fe mt mu mv mw b">state</code>作为<code class="fe mt mu mv mw b">useMemo</code>钩子中的一个依赖项:</p><pre class="mp mq mr ms gt mx mw my mz aw na bi"><span id="a0fa" class="nb ky iq mw b gy nc nd l ne nf"><em class="ng">const api = useMemo(() =&gt; {<br/>  const onDiscountChange = (discount: number) =&gt; {<br/>    // this is why we still need state here - in order to update it<br/>    setState({ ...state, discount });<br/>  };<br/><br/>  // all other callbacks<br/><br/>  return { onSave, onDiscountChange, onNameChange, onCountryChange };<br/>  // still have state as a dependency<br/>}, [state]);</em></span></pre><p id="b390" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这将导致<code class="fe mt mu mv mw b">api</code>值随着每次状态更新而改变，这将导致<code class="fe mt mu mv mw b">FormAPIContext</code>在每次状态更新时触发重新渲染，这将使我们的分割无效。我们希望我们的<code class="fe mt mu mv mw b">api</code>保持不变，不管<code class="fe mt mu mv mw b">state</code>如何，这样这个提供者的消费者就不会重新呈现。</p><p id="2472" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">幸运的是，这里我们可以应用另一个巧妙的技巧:我们可以将我们的状态提取到一个reducer中，而不是在回调中调用<code class="fe mt mu mv mw b">setState</code>,我们只是触发一个reducer动作。</p><p id="f953" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，创建动作和减速器本身:</p><pre class="mp mq mr ms gt mx mw my mz aw na bi"><span id="4a58" class="nb ky iq mw b gy nc nd l ne nf"><em class="ng">type Actions =<br/>  | { type: 'updateName'; name: string }<br/>  | { type: 'updateCountry'; country: Country }<br/>  | { type: 'updateDiscount'; discount: number };<br/><br/>const reducer = (state: State, action: Actions): State =&gt; {<br/>  switch (action.type) {<br/>    case 'updateName':<br/>      return { ...state, name: action.name };<br/>    case 'updateDiscount':<br/>      return { ...state, discount: action.discount };<br/>    case 'updateCountry':<br/>      return { ...state, country: action.country };<br/>  }<br/>};</em></span></pre><p id="31c3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">用减速器代替<code class="fe mt mu mv mw b">useState</code>:</p><pre class="mp mq mr ms gt mx mw my mz aw na bi"><span id="9fe7" class="nb ky iq mw b gy nc nd l ne nf"><em class="ng">export const FormProvider = ({ children }: { children: ReactNode }) =&gt; {<br/>  const [state, dispatch] = useReducer(reducer, {} as State);<br/>  // ...<br/>};</em></span></pre><p id="dfc9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">并将我们的<code class="fe mt mu mv mw b">api</code>从<code class="fe mt mu mv mw b">setState</code>迁移到<code class="fe mt mu mv mw b">dispatch</code>:</p><pre class="mp mq mr ms gt mx mw my mz aw na bi"><span id="3de1" class="nb ky iq mw b gy nc nd l ne nf"><em class="ng">const api = useMemo(() =&gt; {<br/>  const onSave = () =&gt; {<br/>    // send the request to the backend here<br/>  };<br/><br/>  const onDiscountChange = (discount: number) =&gt; {<br/>    dispatch({ type: 'updateDiscount', discount });<br/>  };<br/><br/>  const onNameChange = (name: string) =&gt; {<br/>    dispatch({ type: 'updateName', name });<br/>  };<br/><br/>  const onCountryChange = (country: Country) =&gt; {<br/>    dispatch({ type: 'updateCountry', country });<br/>  };<br/><br/>  return { onSave, onDiscountChange, onNameChange, onCountryChange };<br/>  // no more dependency on state! The api value will stay the same<br/>}, []);</em></span></pre><p id="58d3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后一步:不要忘记将所有使用过<code class="fe mt mu mv mw b">useFormState</code>的组件迁移到<code class="fe mt mu mv mw b">useFormData</code>和<code class="fe mt mu mv mw b">useFormAPI</code>。比如我们的<code class="fe mt mu mv mw b">SelectCountryFormComponent</code>会从<code class="fe mt mu mv mw b">useFormAPI</code>钩子使用<code class="fe mt mu mv mw b">onCountryChange</code>，永远不会在状态改变时重新渲染。</p><pre class="mp mq mr ms gt mx mw my mz aw na bi"><span id="eb48" class="nb ky iq mw b gy nc nd l ne nf"><em class="ng">export const SelectCountryFormComponent = () =&gt; {<br/>  const { onCountryChange } = useFormAPI();<br/><br/>  return &lt;SelectCountry onChange={onCountryChange} /&gt;;<br/>};</em></span></pre><p id="6332" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">看看这个代码沙箱中的完整实现。现在，键入和拖动栏的速度非常快，当我们键入内容时，我们看到的唯一控制台输出是这样的:</p><pre class="mp mq mr ms gt mx mw my mz aw na bi"><span id="e99f" class="nb ky iq mw b gy nc nd l ne nf"><em class="ng">Discount situation render<br/>NameFormComponent render</em></span></pre><p id="8bbe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">只有两个组件，因为只有这两个组件使用实际的状态数据。🎉</p><h1 id="8fbf" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">进一步分裂状态</h1><p id="7f14" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">现在，有好的设计眼光的人或者只是细心的读者可能会注意到我有一点作弊。我们没有将选择的国家传递给我们的" external" <code class="fe mt mu mv mw b">SelectCountry</code>组件，它停留在列表的第一项上。实际上，选中的“淡紫色”应该移动到你点击的国家。组件实际上允许我们通过<code class="fe mt mu mv mw b">activeCountry</code>传递它。从技术上讲，我可以做得很简单:</p><pre class="mp mq mr ms gt mx mw my mz aw na bi"><span id="64e8" class="nb ky iq mw b gy nc nd l ne nf"><em class="ng">export const SelectCountryFormComponent = () =&gt; {<br/>  const { onCountryChange } = useFormAPI();<br/>  const { country } = useFormData();<br/><br/>  return &lt;SelectCountry onChange={onCountryChange} activeCountry={country} /&gt;;<br/>};</em></span></pre><p id="ff48" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是它有一个问题——只要我在一个组件中使用<code class="fe mt mu mv mw b">useFormData</code>钩子，它就会随着状态的改变开始重新渲染，就像<code class="fe mt mu mv mw b">NameFormComponent</code>一样。对我们来说，这意味着我们将回到打字和拖动的落后体验。</p><p id="5536" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是现在，既然我们已经知道了如何在不同的提供者之间分割数据，那么没有什么可以阻止我们将这一点提升到下一个层次，并且同样分割状态的其余部分。摩尔供应商！😅</p><p id="ac0a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于<code class="fe mt mu mv mw b">State</code>，我们现在有三个统一的上下文:</p><pre class="mp mq mr ms gt mx mw my mz aw na bi"><span id="9e95" class="nb ky iq mw b gy nc nd l ne nf"><em class="ng">const FormNameContext = createContext&lt;State['name']&gt;({} as State['name']);<br/>const FormCountryContext = createContext&lt;State['country']&gt;({} as State['country']);<br/>const FormDiscountContext = createContext&lt;State['discount']&gt;({} as State['discount']);</em></span></pre><p id="e000" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">三个国家供应商:</p><pre class="mp mq mr ms gt mx mw my mz aw na bi"><span id="c892" class="nb ky iq mw b gy nc nd l ne nf"><em class="ng">&lt;FormAPIContext.Provider value={api}&gt;<br/>  &lt;FormNameContext.Provider value={state.name}&gt;<br/>    &lt;FormCountryContext.Provider value={state.country}&gt;<br/>      &lt;FormDiscountContext.Provider value={state.discount}&gt;{children}&lt;/FormDiscountContext.Provider&gt;<br/>    &lt;/FormCountryContext.Provider&gt;<br/>  &lt;/FormNameContext.Provider&gt;<br/>&lt;/FormAPIContext.Provider&gt;</em></span></pre><p id="bf46" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">和三个钩子来使用状态:</p><pre class="mp mq mr ms gt mx mw my mz aw na bi"><span id="2067" class="nb ky iq mw b gy nc nd l ne nf"><em class="ng">export const useFormName = () =&gt; useContext(FormNameContext);<br/>export const useFormCountry = () =&gt; useContext(FormCountryContext);<br/>export const useFormDiscount = () =&gt; useContext(FormDiscountContext);</em></span></pre><p id="0947" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在在我们的<code class="fe mt mu mv mw b">SelectCountryFormComponent</code>中，我们可以使用<code class="fe mt mu mv mw b">useFormCountry</code>钩子，除了国家本身之外，它不会在任何变化上重新呈现:</p><pre class="mp mq mr ms gt mx mw my mz aw na bi"><span id="38ba" class="nb ky iq mw b gy nc nd l ne nf"><em class="ng">export const SelectCountryFormComponent = () =&gt; {<br/>  const { onCountryChange } = useFormAPI();<br/>  const country = useFormCountry();<br/><br/>  return &lt;SelectCountry onChange={onCountryChange} activeCountry={country} /&gt;;<br/>};</em></span></pre><p id="2b93" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在codesandbox 中检查这个<a class="ae kw" href="https://codesandbox.io/s/form-implementation-split-api-and-state-0tvq0?file=/src/App.tsx" rel="noopener ugc nofollow" target="_blank">:它仍然很快，并且可以选择国家。当我们在名称输入中键入一些内容时，我们在控制台输出中看到的唯一内容是:</a></p><pre class="mp mq mr ms gt mx mw my mz aw na bi"><span id="468a" class="nb ky iq mw b gy nc nd l ne nf"><em class="ng">NameFormComponent render</em></span></pre><h1 id="0b36" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">奖励:外部状态管理</h1><p id="7b21" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">现在，这个表单的状态是否应该马上用一些状态管理库来实现的问题可能会出现在你的脑海中。也许你是对的。毕竟，如果我们仔细观察代码，我们只是重新发明了轮子并实现了一个基本的状态管理库，具有类似选择器的状态功能和改变状态的独立操作。</p><p id="39a9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是现在你有了一个选择。上下文不再是一个谜，有了这些技术，如果有需要，你可以很容易地编写纯上下文的高性能应用程序，如果你想过渡到任何其他框架，你可以通过对代码进行最小的更改来完成。当你设计你的应用时，状态管理框架<strong class="ka ir">并不重要</strong>。</p><p id="db95" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们还不如现在就把它移到旧的好的Redux上。我们需要做的唯一事情是:去掉上下文和提供者，将React reducer转换为Redux store，并将我们的钩子转换为使用Redux选择器和dispatch。</p><pre class="mp mq mr ms gt mx mw my mz aw na bi"><span id="31fb" class="nb ky iq mw b gy nc nd l ne nf"><em class="ng">const store = createStore((state = {}, action) =&gt; {<br/>  switch (action.type) {<br/>    case 'updateName':<br/>      return { ...state, name: action.payload };<br/>    case 'updateCountry':<br/>      return { ...state, country: action.payload };<br/>    case 'updateDiscount':<br/>      return { ...state, discount: action.payload };<br/>    default:<br/>      return state;<br/>  }<br/>});<br/><br/>export const FormDataProvider = ({ children }: { children: ReactNode }) =&gt; {<br/>  return &lt;Provider store={store}&gt;{children}&lt;/Provider&gt;;<br/>};<br/><br/>export const useFormDiscount = () =&gt; useSelector((state) =&gt; state.discount);<br/>export const useFormCountry = () =&gt; useSelector((state) =&gt; state.country);<br/>export const useFormName = () =&gt; useSelector((state) =&gt; state.name);<br/><br/>export const useFormAPI = () =&gt; {<br/>  const dispatch = useDispatch();<br/><br/>  return {<br/>    onCountryChange: (value) =&gt; {<br/>      dispatch({ type: 'updateCountry', payload: value });<br/>    },<br/>    onDiscountChange: (value) =&gt; dispatch({ type: 'updateDiscount', payload: value }),<br/>    onNameChange: (value) =&gt; dispatch({ type: 'updateName', payload: value }),<br/>    onSave: () =&gt; {},<br/>  };<br/>};</em></span></pre><p id="29e8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">其他一切保持不变，完全按照我们的设计工作。<a class="ae kw" href="https://codesandbox.io/s/form-implementation-redux-2-t5w30?file=/src/form-api.tsx" rel="noopener ugc nofollow" target="_blank">参见CodeSandbox。</a></p><p id="b80a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">今天到此为止，希望now <code class="fe mt mu mv mw b">Context</code>不是你的应用程序中神秘的自发再现的来源，而是你编写高性能React代码✌的坚实工具🏼</p></div><div class="ab cl nk nl hu nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ij ik il im in"><p id="84bb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="ng">最初发表于</em><a class="ae kw" href="https://www.developerway.com/posts/how-to-write-performant-react-apps-with-context" rel="noopener ugc nofollow" target="_blank"><em class="ng"/></a><em class="ng">。网站上有更多这样的文章</em>😉</p><p id="27d0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" href="https://www.developerway.com/" rel="noopener ugc nofollow" target="_blank"> <em class="ng">订阅简讯</em> </a>，<em class="ng"> </em> <a class="ae kw" href="https://www.linkedin.com/in/adevnadia/" rel="noopener ugc nofollow" target="_blank"> <em class="ng">在LinkedIn </em> </a> <em class="ng">或</em> <a class="ae kw" href="https://twitter.com/adevnadia" rel="noopener ugc nofollow" target="_blank"> <em class="ng">上关注Twitter </em> </a> <em class="ng">以便在下一篇文章出来时立即获得通知。</em></p></div></div>    
</body>
</html>