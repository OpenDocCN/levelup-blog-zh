<html>
<head>
<title>Build your own Future in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在围棋中打造自己的未来</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/build-your-own-future-in-go-f66c568e9a7a?source=collection_archive---------4-----------------------#2020-08-17">https://levelup.gitconnected.com/build-your-own-future-in-go-f66c568e9a7a?source=collection_archive---------4-----------------------#2020-08-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/0da3a697e4995dd334060be5c842e2ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ArcjR8AsMr-LkjF6"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@gdtography?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">g摄影</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="b40b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Go编程语言的一个主要特点就是它的同名<code class="fe lb lc ld le b">go</code>语句。不过，在我看来，<code class="fe lb lc ld le b">go</code>语句也是它的主要缺点之一。不仅仅是我。</p><p id="ea87" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">与表达式不同，语句不产生任何结果。在围棋中，开始一个新的goroutine超级容易。但是你如何得到它的结果呢？你怎么知道它是否出错了呢？你如何等待它完成？如果你不再需要它的结果，你如何取消它？</p><p id="01be" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">熟悉围棋的人会说:嗯，很明显，用渠道。但是围棋中的通道仍然是一个低层次的构造。首先，要有一个产生结果或错误的goroutine，并且也是可取消的，你需要三个。你可能认为<code class="fe lb lc ld le b">Context</code>有助于满足第三个要求。但是<code class="fe lb lc ld le b">Context</code>还是暴露了渠道:<code class="fe lb lc ld le b">Done()</code>只是<code class="fe lb lc ld le b">&lt;-chan struct{}</code></p><p id="d66e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那有什么问题？频道越多，问题就越多。通道可能会死锁。渠道会恐慌。甚至在开始编写业务逻辑之前，您就已经有了所有需要处理的底层问题。</p><p id="817e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而且只写一次是不够的。你必须一遍又一遍地重复它。因为最有可能的是，两个不同的goroutines会返回两种不同类型的结果。也就是说，两种不同的频道类型。这意味着，如果没有泛型，你要么多次复制你的代码，要么求助于使用<code class="fe lb lc ld le b">interface{}</code>和运行时强制转换，这完全打破了类型安全的概念。您必须在两个糟糕的解决方案之间做出选择，因为<code class="fe lb lc ld le b">go</code>是一个语句，而不是一个表达式。</p></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><p id="5d06" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在Go语言引入泛型作为实验性特性之前，情况确实如此。我已经简要地写过一次了，这一次，我想展示一下泛型是如何帮助我们解决围棋设计中的一个最大的缺陷。</p><p id="45d4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将实现一个延迟值设计模式，在不同的语言和框架中，它被称为Future、Promise和一堆其他的名字。我会把它叫做未来，就像Java那样。</p><p id="2017" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">延期值不是急，就是懒。这意味着它们要么一创建就开始执行，要么只有在某些事情触发它们时才执行。既然陈述的本质是急切的，我会赞成急切的执行。</p><p id="192c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的未来将有以下方法:</p><ul class=""><li id="6375" class="lm ln iq kf b kg kh kk kl ko lo ks lp kw lq la lr ls lt lu bi translated"><code class="fe lb lc ld le b">Get()</code>阻塞当前的goroutine，直到获得未来的结果</li><li id="cc75" class="lm ln iq kf b kg lv kk lw ko lx ks ly kw lz la lr ls lt lu bi translated"><code class="fe lb lc ld le b">Cancel()</code>那停止了我们未来的执行</li></ul><p id="dc7a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">用Go术语来说，它将是一个具有两种方法的接口:</p><pre class="ma mb mc md gt me le mf mg aw mh bi"><span id="ebfb" class="mi mj iq le b gy mk ml l mm mn">type Future[type T] interface {<br/>   Get() Result[T]<br/>   Cancel()<br/>}</span></pre><p id="ad37" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mo">注意，我将使用方括号来表示泛型类型。他们没有在提案中记载，但是</em><a class="ae kc" href="https://go2goplay.golang.org" rel="noopener ugc nofollow" target="_blank"><em class="mo">go2 playground</em></a><em class="mo">支持他们，事实我是从</em> <a class="ae kc" href="https://medium.com/capital-one-tech/generics-are-the-generics-of-go-3e0ef0cb9e04" rel="noopener"> <em class="mo">这篇文章</em> </a> <em class="mo">中得知的。我发现这种类似Scala的语法比圆括号更容易混淆。</em></p><p id="be42" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">Result</code>是另一个接口，它包装了<code class="fe lb lc ld le b">S</code>类型的<code class="fe lb lc ld le b">Success</code>，或者是<code class="fe lb lc ld le b">Failure</code>:</p><pre class="ma mb mc md gt me le mf mg aw mh bi"><span id="fdc7" class="mi mj iq le b gy mk ml l mm mn">type Result[type S] interface {<br/>   Success() S<br/>   Failure() error<br/>}</span></pre><p id="c7af" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了支持结果，我们需要一个结构来保存它的数据:</p><pre class="ma mb mc md gt me le mf mg aw mh bi"><span id="4a3a" class="mi mj iq le b gy mk ml l mm mn">type result[type S] struct {<br/>   success S<br/>   failure error<br/>}</span></pre><p id="fc10" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">看看这个结构，实现这两个结果接口方法应该很简单:</p><pre class="ma mb mc md gt me le mf mg aw mh bi"><span id="f013" class="mi mj iq le b gy mk ml l mm mn">func (this *result(S)) Success() S {<br/>   return this.success<br/>}<br/><br/>func (this *result(S)) Failure() error {<br/>   return this.failure<br/>}</span></pre><p id="94f0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以简单地将结构本身公开，避免使用接口，节省几行代码，但是接口提供了更干净的API。</p><p id="a09a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将来，打印结果的内容也很方便，因此我们将为此实现Stringer接口:</p><pre class="ma mb mc md gt me le mf mg aw mh bi"><span id="3f13" class="mi mj iq le b gy mk ml l mm mn">func (this *result(S)) String() string {<br/>   if this.failure != nil {<br/>      return fmt.Sprintf("%v", this.failure)<br/>   } else {<br/>      return fmt.Sprintf("%v", this.success)<br/>   }<br/>}</span></pre><p id="19a6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">到目前为止，应该很简单。现在让我们讨论一下支持<code class="fe lb lc ld le b">Future</code>的结构需要什么数据。</p></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><p id="b5de" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">具有以下结构:</p><pre class="ma mb mc md gt me le mf mg aw mh bi"><span id="8081" class="mi mj iq le b gy mk ml l mm mn">type future[type T] struct {<br/>    ...<br/>}</span></pre><p id="5852" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">关于<code class="fe lb lc ld le b">Future</code>的状态我们需要知道什么？</p><p id="3dd9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我们想把结果保存在某个地方:</p><pre class="ma mb mc md gt me le mf mg aw mh bi"><span id="375b" class="mi mj iq le b gy mk ml l mm mn">type future[type T] struct {<br/>   result   *result[T]<br/>   ...<br/>}</span></pre><p id="5313" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">知道未来是否已经完成也是有用的:</p><pre class="ma mb mc md gt me le mf mg aw mh bi"><span id="c823" class="mi mj iq le b gy mk ml l mm mn">type future[type T] struct {<br/>   ...<br/>   completed bool<br/>   ...<br/>}</span></pre><p id="be30" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果它还没有完成，我们需要一个等待它的方法。在Go中，一种常见方法是使用通道:</p><pre class="ma mb mc md gt me le mf mg aw mh bi"><span id="fa48" class="mi mj iq le b gy mk ml l mm mn">type future[type T] struct {<br/>   ...<br/>   wait     chan bool<br/>   ...<br/>}</span></pre><p id="53ae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们最后的要求是能够取消<code class="fe lb lc ld le b">Future</code>。为此，我们将使用<code class="fe lb lc ld le b">Context</code>，它返回一个函数，我们需要调用它来取消它:</p><pre class="ma mb mc md gt me le mf mg aw mh bi"><span id="9432" class="mi mj iq le b gy mk ml l mm mn">type future[type T] struct {<br/>   ...<br/>   cancel   func()<br/>}</span></pre><p id="27d5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是引用<code class="fe lb lc ld le b">Context</code>本身也是有用的:</p><pre class="ma mb mc md gt me le mf mg aw mh bi"><span id="adfa" class="mi mj iq le b gy mk ml l mm mn">type future[type T] struct {<br/>   ...<br/>   ctx      context.Context<br/>   cancel   func()<br/>}</span></pre><p id="7ecf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就这样，这就是我们的<code class="fe lb lc ld le b">Future</code>现在需要的所有数据。</p><pre class="ma mb mc md gt me le mf mg aw mh bi"><span id="41c1" class="mi mj iq le b gy mk ml l mm mn">type future[type T] struct {<br/>   result   *result[T]<br/>   complete bool<br/>   wait     chan bool<br/>   ctx      context.Context<br/>   cancel   func()<br/>}</span></pre><p id="4813" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们实现这两个<code class="fe lb lc ld le b">Future</code>方法。</p></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><p id="fd47" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于我们正在使用<code class="fe lb lc ld le b">Context</code>，取消<code class="fe lb lc ld le b">Future</code>变得微不足道:</p><pre class="ma mb mc md gt me le mf mg aw mh bi"><span id="dbc8" class="mi mj iq le b gy mk ml l mm mn">func (this *future[T]) Cancel() {<br/>   this.cancel()<br/>}</span></pre><p id="36c3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们讨论一下我们的<code class="fe lb lc ld le b">Get()</code>应该处理什么情况。</p><ol class=""><li id="ef77" class="lm ln iq kf b kg kh kk kl ko lo ks lp kw lq la mp ls lt lu bi translated"><code class="fe lb lc ld le b">Future</code>已经完成了它的工作。那么我们应该简单地返回结果，不管是成功还是失败</li><li id="ec8a" class="lm ln iq kf b kg lv kk lw ko lx ks ly kw lz la mp ls lt lu bi translated"><code class="fe lb lc ld le b">Future</code>还没有完成它的工作。然后我们应该等待，阻塞调用的goroutine，当结果准备好了，我们应该返回它</li><li id="32c4" class="lm ln iq kf b kg lv kk lw ko lx ks ly kw lz la mp ls lt lu bi translated">在此期间<code class="fe lb lc ld le b">Future</code>被取消了。我们应该返回一个错误，指出</li></ol><p id="274a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">映射这三种情况后，我们得出以下方法:</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="0d13" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">已经完成的未来的例子很简单。我们只是返回缓存的结果。</p><p id="e2c1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果它还没有完成，我们使用<code class="fe lb lc ld le b">wait</code>通道来等待它。</p><p id="ed46" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">也可能有这样一种情况，我们的未来被取消了上下文。检查<code class="fe lb lc ld le b">ctx.Done()</code>频道就知道了。</p><p id="8a4b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就是实现处理结果的不同用例。</p><p id="f41c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，让我们看看我们如何构建我们的未来。</p></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><p id="fa4c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的未来需要执行任意一段代码。代码本身可能返回泛型类型的结果或错误。我们的构造函数将简单地返回相同泛型类型的Future。</p><pre class="ma mb mc md gt me le mf mg aw mh bi"><span id="a0f1" class="mi mj iq le b gy mk ml l mm mn">func NewFuture[type <strong class="le ir">T</strong>](f func() (<strong class="le ir">T</strong>, error)) Future[<strong class="le ir">T</strong>] {<br/>    ...<br/>}</span></pre><p id="160a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意泛型是如何允许我们定义输入和输出类型之间的强大关系的。我们的<code class="fe lb lc ld le b">Future</code>保证返回与我们提供给构造函数的任意函数相同的类型。不再需要使用<code class="fe lb lc ld le b">interface{}</code>和不安全施法。</p><p id="57a5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们要初始化我们的<code class="fe lb lc ld le b">Future</code>:</p><pre class="ma mb mc md gt me le mf mg aw mh bi"><span id="efde" class="mi mj iq le b gy mk ml l mm mn">fut := &amp;future[T]{<br/>   wait: make(chan bool),<br/>}<br/>fut.ctx, fut.cancel = context.WithCancel(context.Background())<br/>...<br/><br/>return fut</span></pre><p id="d4e8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了使我们的<code class="fe lb lc ld le b">Future</code>可取消，我们创建了一个<code class="fe lb lc ld le b">Context</code>和一个通道，这样我们可以等待它以并发方式完成。</p><p id="0194" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mo">你可能要考虑把</em> <code class="fe lb lc ld le b"><em class="mo">Context</em></code> <em class="mo">传递给</em> <code class="fe lb lc ld le b"><em class="mo">Future</em></code> <em class="mo">的构造函数，而不是自己创建。为了示例的简洁，我省略了这一点。</em></p><p id="b203" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们需要对我们推迟的任意一段代码做一些事情:</p><pre class="ma mb mc md gt me le mf mg aw mh bi"><span id="24b3" class="mi mj iq le b gy mk ml l mm mn">go func() {<br/>   success, failure := f()<br/><br/>   fut.result = &amp;result[T]{success, failure}<br/>   fut.completed = true<br/>   fut.wait &lt;- true<br/>   close(fut.wait)<br/>}()</span></pre><p id="593b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里我们在一个新的goroutine中执行函数，获取它的结果，并将我们的<code class="fe lb lc ld le b">Future</code>标记为完成。</p><p id="a775" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通道应该只使用一次，所以关闭它是个好主意。</p><p id="51ad" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mo">根据您的用例，您可能想要考虑使用一个工人池，而不是为每一个未来生成goroutine。</em></p></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><p id="b382" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们看看它是如何工作的。</p><p id="8650" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我们希望看到我们的未来能够回报一个结果:</p><pre class="ma mb mc md gt me le mf mg aw mh bi"><span id="a59f" class="mi mj iq le b gy mk ml l mm mn">f1 := NewFuture(func() (string, error) {<br/>   time.Sleep(1000)<br/>   return "F1", nil<br/>})<br/><br/>fmt.Printf("ready with %v \n", f1.Get()) <br/>// Need to wait...<br/>// ready with F1</span></pre><p id="57f8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">到目前为止，看起来不错。</p><p id="91b6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，如果我们再次尝试得到结果呢？</p><pre class="ma mb mc md gt me le mf mg aw mh bi"><span id="fa3e" class="mi mj iq le b gy mk ml l mm mn">fmt.Printf("trying again with %v \n", f1.Get()) <br/>// trying again with F1</span></pre><p id="61da" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意，它现在不打印“需要等待”，因为结果已经被记忆。</p><p id="2978" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果函数返回一个错误，我们的未来会怎样？</p><pre class="ma mb mc md gt me le mf mg aw mh bi"><span id="afa6" class="mi mj iq le b gy mk ml l mm mn">f2 := NewFuture(func() (string, error) {<br/>   time.Sleep(1000)<br/>   return "F2", fmt.Errorf("something went wrong")<br/>})<br/><br/>fmt.Printf("ready with %v \n", f2.Get())<br/>// Need to wait...<br/>// ready with something went wrong</span></pre><p id="6edf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">很好，看起来错误也能被正确处理。</p><p id="a03a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，取消怎么办？</p><pre class="ma mb mc md gt me le mf mg aw mh bi"><span id="fb3d" class="mi mj iq le b gy mk ml l mm mn">f3 := NewFuture(func() (string, error) {<br/>   time.Sleep(100)<br/>   fmt.Println("I'm done!")<br/>   return "F3", nil<br/>})<br/>f3.Cancel()<br/><br/>fmt.Printf("ready with %v \n", f3.Get())<br/>// Need to wait...<br/>// ready with context canceled</span></pre><p id="d0ec" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意“我完成了！”是永远不会被打印出来的，因为我们丢弃了这个未来的结果。</p><h1 id="1a9b" class="ms mj iq bd mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk nl nm nn no bi translated">结论</h1><p id="9a8a" class="pw-post-body-paragraph kd ke iq kf b kg np ki kj kk nq km kn ko nr kq kr ks ns ku kv kw nt ky kz la ij bi translated">即将到来的泛型可能有助于解决<code class="fe lb lc ld le b">go</code>作为一个声明，而不是一个表达式所引起的许多问题。</p><p id="a193" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">多亏了它们，我们可以像许多其他语言一样，使用延迟值作为并发原语。这意味着我们现在可以:</p><ul class=""><li id="2e70" class="lm ln iq kf b kg kh kk kl ko lo ks lp kw lq la lr ls lt lu bi translated">轻松访问goroutine结果和错误</li><li id="8efe" class="lm ln iq kf b kg lv kk lw ko lx ks ly kw lz la lr ls lt lu bi translated">编写类型安全的代码，仍然是可重用的和通用的</li><li id="b522" class="lm ln iq kf b kg lv kk lw ko lx ks ly kw lz la lr ls lt lu bi translated">停止搞乱低级并发原语，如通道</li><li id="3f3e" class="lm ln iq kf b kg lv kk lw ko lx ks ly kw lz la lr ls lt lu bi translated">可以完全停止使用<code class="fe lb lc ld le b">go</code>语句</li></ul><h2 id="3f5e" class="mi mj iq bd mt nu nv dn mx nw nx dp nb ko ny nz nf ks oa ob nj kw oc od nn oe bi translated">脚注</h2><p id="048d" class="pw-post-body-paragraph kd ke iq kf b kg np ki kj kk nq km kn ko nr kq kr ks ns ku kv kw nt ky kz la ij bi translated">完整的代码示例可以在这里找到:【https://github.com/AlexeySoshin/go2future T2】</p></div></div>    
</body>
</html>