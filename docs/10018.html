<html>
<head>
<title>What is this “Polymorphism”? — The A-Z easy explanation you might be looking for</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">这种“多态性”是什么？—你可能正在寻找的最简单的解释</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/what-is-this-polymorphism-the-a-z-easy-explanation-you-might-be-looking-for-54d64041c013?source=collection_archive---------0-----------------------#2021-10-16">https://levelup.gitconnected.com/what-is-this-polymorphism-the-a-z-easy-explanation-you-might-be-looking-for-54d64041c013?source=collection_archive---------0-----------------------#2021-10-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="a14b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们都学过“<em class="kl">多态性</em>”这个词，可能在学术生活中，也可能在职业生活中。虽然这个词似乎很难拼写，但这个概念很容易理解。书中的理论甚至是网上的这个概念都是用一种非常复杂的方式来解释的，以至于我们弄糊涂了，而不是学会了！甚至我们在编码中使用它，但没有意识到它。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/ce3b283213b2258a74121e3ad225fdf7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6tLhFiEFZ_Yt_HRgoST2PA.jpeg"/></div></div></figure><p id="77e8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">与<em class="kl">继承</em>、<em class="kl">多态</em>一样，也是面向对象编程的一个原则。它依赖于<em class="kl">类</em>类&amp;类<em class="kl">继承</em>的概念，所以你可能需要一些它们的先验知识来理解，但是没问题，<em class="kl">类</em> &amp; <em class="kl">继承</em>也在这里讨论！我们在这里使用Java作为编码示例。如果你对Java不太熟悉，你可以仔细阅读一下解释，然后用你想要的OOP语言检查一下，这应该没什么不同。<br/>让我们一步步来学习吧:</p></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><h1 id="b665" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">1.我们开始吧</h1><p id="d09b" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">如果我们考虑运算符:"<strong class="jp ir"> + </strong>"和"<strong class="jp ir"> - </strong>"，我们可以看到，它们有一个相似的性质，它们需要两个数来运算。<br/>例如。6+5 = 11，6–5 = 1<br/>如果一个运算符需要两个数进行运算，则与上述运算符一样称为<strong class="jp ir">二元运算符</strong>。</p><h1 id="6db4" class="lf lg iq bd lh li mi lk ll lm mj lo lp lq mk ls lt lu ml lw lx ly mm ma mb mc bi translated">2.班级</h1><p id="9aaa" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">让我们想象一下，我们有一个类名“<strong class="jp ir"> BinaryOperator </strong>”，它存储两个整数(=操作数)，还有一个名为operate的帮助方法。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="51a8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以看到，这个简单的类包含:<br/>——两个名为<em class="kl"> operand1 </em>、<em class="kl"> operand2 </em>的整数。<strong class="jp ir"> <br/> </strong> -初始化整数的<strong class="jp ir"> </strong>构造函数。<br/> -一个方法<em class="kl"> operate() </em>，刚好返回0。<br/>这个类作为二元操作符是没有用的，因为它没有对<em class="kl"> operate() </em>方法中的操作数执行任何有用的操作，而是返回0！</p><h1 id="6532" class="lf lg iq bd lh li mi lk ll lm mj lo lp lq mk ls lt lu ml lw lx ly mm ma mb mc bi translated">3.遗产</h1><p id="2ccf" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">如果一个操作符想要成为二元操作符，它可以继承<strong class="jp ir">二元操作符</strong>类，该类提供了一些有用的属性，比如存储两个操作数，一个操作方法。加法&amp;减法运算符可以继承<strong class="jp ir">二元运算符</strong>的属性，并操作操作数。让我们看看下面的代码:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mn mo l"/></div></figure><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="5036" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以看到，这两个类都继承了类<strong class="jp ir"> BinaryOperator </strong>。因此，他们都可以访问整数<em class="kl"> operand1 </em>、<em class="kl"> operand2 </em>，以及方法<em class="kl"> operate() </em>。看吧！我们不需要声明任何操作数或任何像operate这样的方法，只需要继承它们就可以了！</p><p id="f59d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们需要按照操作者的要求<em class="kl">覆盖</em>父类方法<em class="kl"> operate() </em>。<strong class="jp ir">加法运算符</strong>查找和，<strong class="jp ir">减法运算符</strong>查找<em class="kl"> operate() </em>方法中两个操作数的减法。</p><p id="f7d4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在OOP语言中，<strong class="jp ir"> BinaryOperator </strong>现在是<strong class="jp ir">addition operator</strong>&amp;<strong class="jp ir">subtraction operator</strong>的父类(基类/超类)。相反，<strong class="jp ir">加法运算符</strong> &amp; <strong class="jp ir">减法运算符</strong>是<strong class="jp ir">二元运算符</strong>的子类(子类)。</p><p id="7b60" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，我们还添加了一些额外的方法:<br/> - <em class="kl"> getGreater() </em>在<em class="kl"/><strong class="jp ir">addition operator</strong>中，它只是返回较大的操作数。(从6，5它将返回6)<br/>-<em class="kl">isBothOperandEqual()</em>in<em class="kl"/><strong class="jp ir">减法运算符</strong>检查两个操作数是否相同。(对于6，5它将返回<em class="kl">假</em>)</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mp"><img src="../Images/012e1da6d42aa0df3406912c466d8ece.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CZggTxxg3jbRyY8MVnpijA.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">类图</figcaption></figure><h1 id="c426" class="lf lg iq bd lh li mi lk ll lm mj lo lp lq mk ls lt lu ml lw lx ly mm ma mb mc bi translated">4.检查上面的类</h1><p id="c80b" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">让我们在main函数中检查上面的类，并打印方法<em class="kl"> operate() </em>的结果:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="4af7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如您所料，如果我们运行代码，上述代码的输出将是:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/3bdc8c2603961d427df09b1d2e020bf2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1076/format:webp/1*4oN7Xyz4uRmDpPIqDG_qjg.png"/></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">上述代码的输出</figcaption></figure><ul class=""><li id="661b" class="mv mw iq jp b jq jr ju jv jy mx kc my kg mz kk na nb nc nd bi translated">对象<em class="kl"> binaryOperator </em>的<em class="kl"> operate() </em>方法返回<strong class="jp ir"> 0 </strong>，那是因为在<strong class="jp ir"> BinaryOperator </strong>类中我们刚刚返回了0。</li><li id="bccc" class="mv mw iq jp b jq ne ju nf jy ng kc nh kg ni kk na nb nc nd bi translated">对象<em class="kl">加法运算符</em>的<em class="kl"> operate() </em>方法返回<strong class="jp ir"> 11 </strong>，这是因为在<strong class="jp ir">加法运算符</strong>类中我们返回了sum (6+5)。</li><li id="b9e2" class="mv mw iq jp b jq ne ju nf jy ng kc nh kg ni kk na nb nc nd bi translated">对象<em class="kl">减法运算符</em>的<em class="kl"> operate() </em>方法返回<strong class="jp ir"> 1 </strong>，这是因为在<strong class="jp ir">减法运算符</strong>类中我们返回了减法(6–5)。</li></ul><h1 id="f019" class="lf lg iq bd lh li mi lk ll lm mj lo lp lq mk ls lt lu ml lw lx ly mm ma mb mc bi translated"><strong class="ak"> 5。多态性—例如</strong></h1><p id="eeb1" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">到目前为止，我们讨论的非常简单，也没有使用多态性。但是，我们现在准备使用它！<br/>在<strong class="jp ir">步骤4 </strong>中，我们声明了如下<strong class="jp ir"> </strong>对象(第3–5行):</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mn mo l"/></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">没有多态性</figcaption></figure><blockquote class="nj nk nl"><p id="8493" class="jn jo kl jp b jq jr js jt ju jv jw jx nm jz ka kb nn kd ke kf no kh ki kj kk ij bi translated">在多态中，我们可以将子对象赋给或初始化给它的父对象</p></blockquote><p id="784f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以，我们可以将<strong class="jp ir">加法运算符</strong> &amp; <strong class="jp ir">减法运算符</strong>的子类对象赋给父类对象<strong class="jp ir">二元运算符</strong>！？😮</p><p id="5e90" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们再次回到<strong class="jp ir">步骤4 </strong>，将子对象声明为父对象，如下所示:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mn mo l"/></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">具有多态性</figcaption></figure><p id="49d8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上面的代码中，一切都是一样的，除了第3和第5行，我们将<strong class="jp ir">加法运算符</strong> &amp; <strong class="jp ir">减法运算符</strong>对象初始化为<strong class="jp ir">二元运算符</strong>。</p><p id="4003" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可能会想，当我们运行代码时，会导致如下编译错误:</p><pre class="kn ko kp kq gt np nq nr ns aw nt bi"><span id="4fc2" class="nu lg iq nq b gy nv nw l nx ny">“<em class="kl">Type mismatch: cannot convert from AdditionOperator to BinaryOperator…</em>”.</span></pre><p id="01cb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">神奇的是，它不会，而是会给出如下输出:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/3bdc8c2603961d427df09b1d2e020bf2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1076/format:webp/1*4oN7Xyz4uRmDpPIqDG_qjg.png"/></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">使用多态性输出</figcaption></figure><p id="1793" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该输出与<strong class="jp ir">步骤4 </strong>中的先前输出相同！！</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nz mo l"/></div></figure><p id="c617" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">等等！！如果我们尝试将它们分配给字符串<strong class="jp ir">会怎么样，如下所示:</strong></p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mn mo l"/></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">分配为字符串类对象</figcaption></figure><p id="cb36" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">会导致编译错误！😒</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi oa"><img src="../Images/b786bfcc8b3cf105037adbb8632783c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VKy1c1z35RR7RYsTAdiGhQ.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">上述代码的输出</figcaption></figure><p id="522e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们来探索这里发生了什么！我们被允许将一个子对象赋给父对象(=多态)。因此，我们可以将<strong class="jp ir">加法运算符</strong>(子)<strong class="jp ir"> </strong>分配给<strong class="jp ir">二元运算符</strong>(父)，但不能将<strong class="jp ir">加法运算符</strong>分配给<strong class="jp ir">字符串</strong> ( <strong class="jp ir">字符串</strong>不是父)。</p><blockquote class="ob"><p id="b953" class="oc od iq bd oe of og oh oi oj ok kk dk translated">根据以上测试，我们成功验证了多态性！</p></blockquote><h1 id="2bd9" class="lf lg iq bd lh li mi lk ll lm mj lo lp lq ol ls lt lu om lw lx ly on ma mb mc bi translated">6.多态性——用例</h1><p id="3789" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">多态性的主要用例是我们可以忘记单个子类，而是可以一般性地使用它们。让我们看看例子:</p><p id="2b87" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">用例1: </strong>我们可以想到一个通用列表，它应该允许任何<strong class="jp ir"> BinaryOperator </strong>对象。在这个列表中，我们可以添加<strong class="jp ir"> BinaryOperator </strong>对象以及任何子对象(<strong class="jp ir">加法运算符</strong> &amp; <strong class="jp ir">减法运算符</strong>的对象),如下所示:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mn mo l"/></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">列表中的多态性</figcaption></figure><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/cfbd9e18007197b64e763b5584a7af1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:892/format:webp/1*2HgbrkdGcSKxKptgiTYSQQ.png"/></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">上述代码的输出</figcaption></figure><p id="e079" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果没有多态性，我们将无法在一个列表中添加它们，而是必须为<strong class="jp ir">加法运算符</strong>和<strong class="jp ir">减法运算符</strong>使用单独的列表！！😿这减少了我们的重复工作，特别是在职业生活中，应该有无数的子类。</p><p id="2f97" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">用例2: </strong>我们可以认为，我们需要一个方法来接受两个二元操作符，这两个操作符评估操作符并检查两者的结果是否相同。有了多态性，我们可以像下面这样做:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mn mo l"/></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">方法参数中的多态性</figcaption></figure><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi op"><img src="../Images/92dcbd0b896786113bc696d78bb15f3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:890/format:webp/1*kM4rIJQS6dQW1xp2sRPxsw.png"/></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">上述代码的输出</figcaption></figure><p id="6b3c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于多态，我们可以将<strong class="jp ir">加法运算符</strong> &amp; <strong class="jp ir">减法运算符</strong>对象传递给<em class="kl"> isSameResult() </em>方法中的<strong class="jp ir">二元运算符</strong>参数。</p><p id="24ca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第14行的输出为<strong class="jp ir">假</strong> : 6 + 5！= 6 - 5 <br/>第16行的输出为<strong class="jp ir">真</strong> : 6 + 5 == 12 - 1</p><p id="3ccd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">没有多态性，我们不得不重载所有可能的方法参数组合，如下所示，这是非常繁琐的工作！如果父类的孩子很多，那么每个组合都是不可能写出来的！</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mn mo l"/></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">没有多态性</figcaption></figure><p id="abc6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可能会面临更多的用例，这些用例可以使用多态性来解决。它可以让你的代码更易读，更简短，更不容易被接受。奖金部分也给出了更多的例子。</p><h1 id="dace" class="lf lg iq bd lh li mi lk ll lm mj lo lp lq mk ls lt lu ml lw lx ly mm ma mb mc bi translated">6.多态性—一些问题</h1><p id="1d46" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">如果将子对象赋给父对象(使用多态性)，我们将丢失在子类中声明的附加属性或方法！😤这是因为，父类不知道子类的实现(显然，子类知道父类的实现)。</p><p id="f90d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<strong class="jp ir">第三步:<br/> - AdditionOperator </strong>有一个子特定的加法方法<em class="kl"> getGreater() </em>，返回较大的操作数。<br/> - <strong class="jp ir">减法运算符</strong>有一个子特定的附加方法<em class="kl"> isBothOperandEqual() </em>，如果两个操作数相等或不相等，则返回。</p><p id="a954" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看看下面的例子，我们将在使用多态后通过调用<em class="kl">get greater()</em>&amp;<em class="kl">isBothOperandEqual()</em>方法来实现这个场景:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mn mo l"/></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">从父类调用特定于子类的方法</figcaption></figure><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi oq"><img src="../Images/9fa3e42e09229328db81f19a7d11bfcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YWlFQUdRASdXZgmWf7etEA.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">上述代码的输出</figcaption></figure><p id="1704" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这导致第5 &amp; 6行出现编译错误。使用多态性<em class="kl">addition op</em>&amp;<em class="kl">subtraction op</em>对象后，成为<strong class="jp ir"> BinaryOperator </strong>的对象，它不知道子方法<em class="kl">get greater()</em>&amp;<em class="kl">isBothOperandEqual()</em>。因此，我们看到了编译错误。</p><h2 id="b734" class="nu lg iq bd lh or os dn ll ot ou dp lp jy ov ow lt kc ox oy lx kg oz pa mb pb bi translated">找回孩子:</h2><p id="b749" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">那么，如果我们需要特定于子级的方法/属性，该怎么办呢？😟</p><p id="9ebd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你一定听说过选角。是啊！我们说的是我们经常使用的将整数转换为双精度数的转换。类似地，我们可以将父对象转换为子对象，然后毫无麻烦地取回完整的子对象:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mn mo l"/></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">回到孩子身上</figcaption></figure><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi pc"><img src="../Images/3af65dc25c71c3cc9d8f3d17d3835855.png" data-original-src="https://miro.medium.com/v2/resize:fit:946/format:webp/1*Kyh-e7qWkXyJTPk62Kxzdw.png"/></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">上述代码的输出</figcaption></figure><p id="a650" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你看！？转换后，我们现在可以在第8行&amp; 9中调用<strong class="jp ir">加法运算符</strong>的子方法<em class="kl"> getGreater() </em>和<strong class="jp ir">减法运算符</strong>的子方法<em class="kl"> isBothOperandEqual() </em>而没有任何编译错误。</p><h2 id="b13a" class="nu lg iq bd lh or os dn ll ot ou dp lp jy ov ow lt kc ox oy lx kg oz pa mb pb bi translated">铸造注意事项:</h2><p id="2174" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">如果我们错误地从父对象转换到错误的子对象，将导致运行时错误！怎么会？让我们探索一下…</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nz mo l"/></div></figure><p id="2934" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">举个例子，我们可以用多态把一个<strong class="jp ir">加法运算符</strong>的对象保存为<strong class="jp ir">二元运算符</strong>，然后，如果我们想把它强制转换为<strong class="jp ir">减法运算符</strong>(但实际上是<strong class="jp ir">加法运算符</strong> ) <strong class="jp ir"> <em class="kl"> </em> </strong>，它会立即崩溃:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mn mo l"/></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">错误的铸造示例</figcaption></figure><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi pd"><img src="../Images/8d4b650cb897aaf4136a4440228b2233.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JnINUTblOBxOr3sFn6Zzvg.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">上述代码的输出</figcaption></figure><p id="591e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们使用多态性，子对象就不会丢失，它们只是成为父类的一个影子，如果我们想从影子中找回子类，我们必须得将它投射回真正的子类。如果我们将类型转换为错误的子类型，就会产生一个类似上面的运行时错误。</p><h2 id="bfa8" class="nu lg iq bd lh or os dn ll ot ou dp lp jy ov ow lt kc ox oy lx kg oz pa mb pb bi translated">检查类别类型:</h2><p id="a488" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">我们可以检查一个对象是否是从一个特定的类创建的。Java/JS有关键字<strong class="jp ir"> instanceof </strong>，C++有<strong class="jp ir"> dynamic_cast </strong>，Python有<strong class="jp ir"> isinstance() </strong>等等，每一种OOP语言都有这种类型的对象检查。它们都返回true/false，表明对象是否属于该类型。对于Java，我们可以这样做:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mn mo l"/></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">类型检查</figcaption></figure><p id="db7b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你能猜出产量吗？？</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi pe"><img src="../Images/86a8e9450b50b91e2a4b6b850133290c.png" data-original-src="https://miro.medium.com/v2/resize:fit:896/format:webp/1*zOuyUXTj_1Bkqzhunmzg7w.png"/></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">上述代码的输出</figcaption></figure><p id="cfc3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第5 &amp; 11行被执行并打印在控制台中。但是，第8行被跳过。那是因为，<em class="kl"> binOp </em>对象既是<strong class="jp ir"> BinaryOperator </strong>(父)<strong class="jp ir"><em class="kl"/></strong>&amp;<strong class="jp ir">addition operator</strong>(子阴影)<strong class="jp ir"> <em class="kl"> </em> </strong>的类型，又返回true，但不是<strong class="jp ir"> SubtractionOperator </strong>的类型，所以第7行返回false。</p><h2 id="8cf5" class="nu lg iq bd lh or os dn ll ot ou dp lp jy ov ow lt kc ox oy lx kg oz pa mb pb bi translated">安全铸件类型:</h2><p id="94d5" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">使用类型检查，我们可以确保安全转换(即没有运行时错误)。这种现象称为类型安全转换。让我们看看下面的代码片段:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mn mo l"/></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">铸造前的类型检查</figcaption></figure><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi pf"><img src="../Images/89a78f8ad7b57f2e92082688250ee121.png" data-original-src="https://miro.medium.com/v2/resize:fit:902/format:webp/1*2hCzw_0yWLynRzQnyB_w6w.png"/></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">上述代码的输出</figcaption></figure><p id="1024" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以看到，<em class="kl"> binOp </em>是<strong class="jp ir">加法运算符</strong>的类型，因此与<strong class="jp ir">加法运算符</strong>的<em class="kl">instance返回true，第7–8行被执行并在控制台打印输出<strong class="jp ir"> 6 </strong>(较大的操作数)<strong class="jp ir"> </strong>。但是，<em class="kl"> binOp </em>不是<strong class="jp ir">减法运算符</strong>的类型，并且</em>的<em class="kl">instance返回false。因此，如果</em>程序块，将跳过整个<em class="kl">程序块中可能导致运行时错误的造型(第13行)。</em></p><h1 id="e11a" class="lf lg iq bd lh li mi lk ll lm mj lo lp lq mk ls lt lu ml lw lx ly mm ma mb mc bi translated">7.多态性——加分</h1><p id="4635" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">综上所述，我们来查一些可能的案例和解释:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="9f65" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">关于多态性的一些常见问题:</p><ul class=""><li id="2c92" class="mv mw iq jp b jq jr ju jv jy mx kc my kg mz kk na nb nc nd bi translated">你知道吗，在Java中，每个对象都可以被分配给<strong class="jp ir">对象</strong>类？<br/> <strong class="jp ir">答:</strong>Java中的每个类都是<strong class="jp ir">对象</strong>类的子类，因此，你可以使用多态。</li><li id="bd96" class="mv mw iq jp b jq ne ju nf jy ng kc nh kg ni kk na nb nc nd bi translated">如果发生多级遗传，我们可以对祖父母或更多的顶级亲属以及父母使用多态性吗？<br/> <strong class="jp ir"> Ans: </strong>我们来想一个例子，类<strong class="jp ir"> A </strong>被继承到<strong class="jp ir"> <em class="kl"> </em> B </strong>，<strong class="jp ir"> B </strong>被继承到<strong class="jp ir"> C </strong>。能否将<strong class="jp ir"> C </strong>的对象赋给<strong class="jp ir"> A </strong>(多态)？是的，我们可以！我们可以分配给任何顶级父母！</li><li id="552e" class="mv mw iq jp b jq ne ju nf jy ng kc nh kg ni kk na nb nc nd bi translated">可以给我一些多态的真实编码例子吗？<br/> <strong class="jp ir">答:</strong>我们在不知不觉中使用了多态性。在开发中，我们可能会过多地使用这个概念，以至于我们可能已经隐含地了解了它。你可以看到下面的代码:</li></ul><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mn mo l"/></div></figure></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><p id="251d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">唷！那可是多形态啊！它不应该像书本理论或其他互联网解释那样过于强硬！！</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nz mo l"/></div></figure><p id="f847" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以浏览用Java写的代码，自己测试。整个项目可以在这里找到解释:</p><div class="pg ph gp gr pi pj"><a href="https://github.com/tareqjoy/OperatorProject/" rel="noopener  ugc nofollow" target="_blank"><div class="pk ab fo"><div class="pl ab pm cl cj pn"><h2 class="bd ir gy z fp po fr fs pp fu fw ip bi translated">GitHub-tareqjoy/operator项目</h2><div class="pq l"><h3 class="bd b gy z fp po fr fs pp fu fw dk translated">在GitHub上创建一个帐户，为tareqjoy/OperatorProject的开发做出贡献。</h3></div><div class="pr l"><p class="bd b dl z fp po fr fs pp fu fw dk translated">github.com</p></div></div><div class="ps l"><div class="pt l pu pv pw ps px kw pj"/></div></div></a></div><p id="e093" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不要忘记👏 😉！</p><p id="f041" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在LinkedIn上与我联系:</p><div class="pg ph gp gr pi pj"><a href="https://www.linkedin.com/in/tareqjoy/" rel="noopener  ugc nofollow" target="_blank"><div class="pk ab fo"><div class="pl ab pm cl cj pn"><h2 class="bd ir gy z fp po fr fs pp fu fw ip bi translated">Tareq Rahman Joy -软件工程师- TigerIT孟加拉有限公司| LinkedIn</h2><div class="pq l"><h3 class="bd b gy z fp po fr fs pp fu fw dk translated">经验丰富的软件工程师，对面向对象编程&amp;数据结构和算法有广泛的了解…</h3></div><div class="pr l"><p class="bd b dl z fp po fr fs pp fu fw dk translated">www.linkedin.com</p></div></div><div class="ps l"><div class="py l pu pv pw ps px kw pj"/></div></div></a></div></div></div>    
</body>
</html>