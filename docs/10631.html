<html>
<head>
<title>Introduction to RabbitMQ with Nodejs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带Nodejs的RabbitMQ简介</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/introduction-to-rabbitmq-with-nodejs-61e2aec0c52c?source=collection_archive---------1-----------------------#2021-12-28">https://levelup.gitconnected.com/introduction-to-rabbitmq-with-nodejs-61e2aec0c52c?source=collection_archive---------1-----------------------#2021-12-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="92ed" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">事件驱动服务的异步通信</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8e311d727ac05c218685cfb4e90e6231.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g5aYzy1gIw0wgMyyUfKucA.png"/></div></div></figure><h1 id="953b" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">同步和异步通信</h1><p id="5065" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">在涉及多种服务的复杂生态系统中，服务之间需要进行通信。然而，有两种不同的通信模式，即同步和异步通信。</p><p id="a188" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">同步 <strong class="lo iu">通信</strong>仅仅意味着服务A将调用服务B来执行一些任务或获取一些数据。这里需要注意的一点是，现在服务A <strong class="lo iu">被</strong> <strong class="lo iu">阻塞</strong> <strong class="lo iu">和</strong> <strong class="lo iu">等待服务B上的</strong>完成任务。这将导致服务A现在依赖于服务b之间的<strong class="lo iu">紧密</strong> <strong class="lo iu">耦合</strong>，同步通信的一个例子是REST API中的GET、POST操作，它必须等待结果，并且可能使用结果。</p><p id="3ce9" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated"><strong class="lo iu">异步</strong> <strong class="lo iu">通信</strong>是服务A <strong class="lo iu">没有</strong> <strong class="lo iu">被</strong>服务B<strong class="lo iu">阻塞</strong> <strong class="lo iu">，但是服务A <strong class="lo iu">要求</strong> <strong class="lo iu">到</strong> <strong class="lo iu">在后台执行</strong><strong class="lo iu"/><strong class="lo iu">任务</strong>于服务B，所以系统会导致<strong class="lo iu">最终</strong> <strong class="lo iu">一致性<strong class="lo iu"><strong class="lo iu">松散</strong> <strong class="lo iu">耦合</strong> &amp; <strong class="lo iu">可扩展性</strong>是异步通信的主要原因。</strong></strong></strong></p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="b0c2" class="ku kv it bd kw kx mu kz la lb mv ld le jz mw ka lg kc mx kd li kf my kg lk ll bi translated">兔子q</h1><p id="0562" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">异步通信是由处理服务间消息的消息代理实现的。RabbitMQ是一个消息代理，它将在<strong class="lo iu">消费者</strong>和<strong class="lo iu">发布者</strong>之间<strong class="lo iu">接收</strong>、<strong class="lo iu">存储</strong> <strong class="lo iu"> &amp; </strong> <strong class="lo iu">和</strong> <strong class="lo iu">消息</strong>。RabbitMQ使用<strong class="lo iu"> AMQP </strong>(高级消息队列协议)通过定义生产者、代理和消费者来标准化 <strong class="lo iu">消息传递</strong>。然而RabbitMQ支持其他协议，如MQTT、HTTP，但是对于本教程，它将使用Nodejs来转换AMQP。</p><div class="mz na gp gr nb nc"><a href="https://www.rabbitmq.com/" rel="noopener  ugc nofollow" target="_blank"><div class="nd ab fo"><div class="ne ab nf cl cj ng"><h2 class="bd iu gy z fp nh fr fs ni fu fw is bi translated">有效的消息传递- RabbitMQ</h2><div class="nj l"><h3 class="bd b gy z fp nh fr fs ni fu fw dk translated">RabbitMQ拥有成千上万的用户，是最受欢迎的开源消息代理之一。从T-Mobile到…</h3></div><div class="nk l"><p class="bd b dl z fp nh fr fs ni fu fw dk translated">www.rabbitmq.com</p></div></div></div></a></div></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="6bc4" class="ku kv it bd kw kx mu kz la lb mv ld le jz mw ka lg kc mx kd li kf my kg lk ll bi translated">RabbitMQ架构</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/9d79698ce7b1021ffc931907d5de2141.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bBjdpAOpDDyssvFHDHF_wg.png"/></div></div></figure><ul class=""><li id="6412" class="nm nn it lo b lp mi ls mj lv no lz np md nq mh nr ns nt nu bi translated"><strong class="lo iu">连接</strong> →双向<strong class="lo iu">有状态</strong> <strong class="lo iu"> TCP </strong> <strong class="lo iu">连接</strong>的创建是为了用RabbitMQ服务连接发布者和消费者。</li><li id="d54f" class="nm nn it lo b lp nv ls nw lv nx lz ny md nz mh nr ns nt nu bi translated"><strong class="lo iu">通道</strong>→TCP连接内的一个<strong class="lo iu">逻辑</strong> <strong class="lo iu">连接</strong>，用于分离共享同一TCP连接的同一物理消费者内的多个消费者，提供<strong class="lo iu">复用</strong>。</li><li id="bd6e" class="nm nn it lo b lp nv ls nw lv nx lz ny md nz mh nr ns nt nu bi translated"><strong class="lo iu">交换</strong> →负责<strong class="lo iu">发送</strong> <strong class="lo iu">消息</strong> <strong class="lo iu">到</strong> <strong class="lo iu">所需</strong> <strong class="lo iu">队列</strong>依靠<strong class="lo iu">绑定</strong> <strong class="lo iu">键</strong>在交换和队列之间进行。下面讨论不同类型的交换。</li><li id="c4bf" class="nm nn it lo b lp nv ls nw lv nx lz ny md nz mh nr ns nt nu bi translated"><strong class="lo iu">队列</strong> →负责<strong class="lo iu">存储要消费的</strong> <strong class="lo iu">消息</strong>，队列通过绑定键连接到交换机。因此，根据交换机的类型和消息的路由关键字，它将被交换机路由到首选队列。</li></ul><h2 id="e0a6" class="oa kv it bd kw ob oc dn la od oe dp le lv of og lg lz oh oi li md oj ok lk ol bi translated">交易所的类型</h2><ul class=""><li id="9db4" class="nm nn it lo b lp lq ls lt lv om lz on md oo mh nr ns nt nu bi translated"><strong class="lo iu">直接</strong> <strong class="lo iu">交换</strong> →如果队列的绑定关键字与消息的路由关键字相同，则转发消息。</li><li id="5d56" class="nm nn it lo b lp nv ls nw lv nx lz ny md nz mh nr ns nt nu bi translated"><strong class="lo iu">扇出</strong></li><li id="9c55" class="nm nn it lo b lp nv ls nw lv nx lz ny md nz mh nr ns nt nu bi translated"><strong class="lo iu">主题</strong> <strong class="lo iu">交换</strong> →查找消息路由关键字和交换路由模式之间的通配符匹配</li><li id="a73c" class="nm nn it lo b lp nv ls nw lv nx lz ny md nz mh nr ns nt nu bi translated"><strong class="lo iu">报头</strong> <strong class="lo iu">交换</strong> →使用消息报头进行路由</li></ul><p id="788e" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">对于本教程，它将使用<strong class="lo iu">默认</strong> <strong class="lo iu">交换</strong>，这是直接交换类型的预定义交换。这里消息的<strong class="lo iu">路由关键字与队列名</strong>匹配。</p><h2 id="a5b4" class="oa kv it bd kw ob oc dn la od oe dp le lv of og lg lz oh oi li md oj ok lk ol bi translated">RabbitMQ中的消息流</h2><p id="2f94" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">总之，<strong class="lo iu">生产者将向交易所</strong>发出信息。使用绑定密钥将交换机连接到队列<strong class="lo iu">。从而<strong class="lo iu">根据绑定密钥、路由密钥和交换类型交换转发接收到的消息到相关队列</strong>。最后<strong class="lo iu">消费者从队列</strong>接收消息。</strong></p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="c1f8" class="ku kv it bd kw kx mu kz la lb mv ld le jz mw ka lg kc mx kd li kf my kg lk ll bi translated">用Docker创建RabbitMQ服务器</h1><p id="6f6f" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">这里使用的是<code class="fe op oq or os b"><strong class="lo iu">rabbitmq</strong></code> <strong class="lo iu">官方</strong> <strong class="lo iu"> Docker </strong> <strong class="lo iu">图片</strong>启用<strong class="lo iu">管理插件</strong>，会被<strong class="lo iu"> </strong> <code class="fe op oq or os b"><strong class="lo iu">rabbitmq:management</strong></code> <strong class="lo iu">标记。然而默认的<code class="fe op oq or os b">rabbitmq</code>图像也可以通过手动启用插件来使用。</strong></p><div class="mz na gp gr nb nc"><a href="https://hub.docker.com/_/rabbitmq" rel="noopener  ugc nofollow" target="_blank"><div class="nd ab fo"><div class="ne ab nf cl cj ng"><h2 class="bd iu gy z fp nh fr fs ni fu fw is bi translated">Rabbitmq -官方图片| Docker Hub</h2><div class="nj l"><h3 class="bd b gy z fp nh fr fs ni fu fw dk translated">RabbitMQ是一个开源的多协议消息传递代理。</h3></div><div class="nk l"><p class="bd b dl z fp nh fr fs ni fu fw dk translated">hub.docker.com</p></div></div></div></a></div><p id="2570" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">这里端口<code class="fe op oq or os b"><strong class="lo iu">5672</strong></code>在<strong class="lo iu"> amqp </strong>协议中启用用于消息传递，而端口<code class="fe op oq or os b"><strong class="lo iu">15672</strong></code>在<strong class="lo iu"> http </strong>协议中启用用于管理门户。</p><ul class=""><li id="6a00" class="nm nn it lo b lp mi ls mj lv no lz np md nq mh nr ns nt nu bi translated">运行RabbitMQ的Docker映像</li></ul><pre class="kj kk kl km gt ot os ou ov aw ow bi"><span id="2490" class="oa kv it os b gy ox oy l oz pa">docker run -d -p <strong class="os iu">5672</strong>:<strong class="os iu">5672</strong> -p <strong class="os iu">15672</strong>:<strong class="os iu">15672</strong> \<br/>   --name rabbitmq-server <strong class="os iu">rabbitmq:management</strong></span></pre><ul class=""><li id="3a57" class="nm nn it lo b lp mi ls mj lv no lz np md nq mh nr ns nt nu bi translated">通过Docker日志验证RabbitMQ服务状态</li></ul><pre class="kj kk kl km gt ot os ou ov aw ow bi"><span id="c7b5" class="oa kv it os b gy ox oy l oz pa">$ docker logs rabbitmq-server</span><span id="bcaa" class="oa kv it os b gy pb oy l oz pa">&gt; Ready to start client connection listeners<br/>&gt; <strong class="os iu">started TCP listener</strong> on [::]:<strong class="os iu">5672</strong><br/>&gt; <strong class="os iu">Server</strong> <strong class="os iu">startup complete</strong>; 4 plugins started.</span></pre><ul class=""><li id="3eca" class="nm nn it lo b lp mi ls mj lv no lz np md nq mh nr ns nt nu bi translated">验证RabbitMQ Cli和服务管理插件</li></ul><pre class="kj kk kl km gt ot os ou ov aw ow bi"><span id="4770" class="oa kv it os b gy ox oy l oz pa">$ docker exec -it rabbitmq-server bash</span><span id="7b8f" class="oa kv it os b gy pb oy l oz pa">&gt; rabbitmqctl version<br/>3.9.11</span><span id="791e" class="oa kv it os b gy pb oy l oz pa">&gt; rabbitmq-plugins list<br/>[E*] rabbitmq_management               3.9.11</span></pre><ul class=""><li id="260b" class="nm nn it lo b lp mi ls mj lv no lz np md nq mh nr ns nt nu bi translated">位于<a class="ae pc" href="http://localhost:15672/" rel="noopener ugc nofollow" target="_blank">的管理门户http://localhost:15672/ </a>(凭证:<code class="fe op oq or os b">guest/guest</code>)</li></ul><div class="kj kk kl km gt ab cb"><figure class="pd kn pe pf pg ph pi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/85ce8bc830b6e8c889bafda64d25bf3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1172/format:webp/1*X7szlbpIaZwtZ7RPRcq5iA.png"/></div></figure><figure class="pd kn pj pf pg ph pi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/793f32d64833dc9ca9b429b985d512f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:830/format:webp/1*bkEspvtjfPe8lBdgJaAy3w.png"/></div><figcaption class="pk pl gj gh gi pm pn bd b be z dk po di pp pq translated">通过<strong class="bd kw"> guest/guest </strong>的默认凭证登录。可以看到节点和端口。</figcaption></figure></div></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="ed58" class="ku kv it bd kw kx mu kz la lb mv ld le jz mw ka lg kc mx kd li kf my kg lk ll bi translated">为发布者和消费者创建项目</h1><p id="a54b" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">如上所述，RabbitMQ通信通过<strong class="lo iu">AMQP</strong>T37】协议进行，对于Nodejs，有<code class="fe op oq or os b"><strong class="lo iu">amqplib</strong></code> npm包与RabbitMQ进行交互。</p><p id="026e" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">出于演示目的，本教程将使用一个包含发布者和消费者的Nodejs项目。让我们启动示例Nodejs项目并安装所需的npm包。</p><pre class="kj kk kl km gt ot os ou ov aw ow bi"><span id="fb00" class="oa kv it os b gy ox oy l oz pa">$ npm init<br/>$ npm install --save <strong class="os iu">amqplib</strong></span><span id="1848" class="oa kv it os b gy pb oy l oz pa">// Creating two empty files<br/>$ touch publisher.js<br/>$ touch consumer.js</span></pre></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="38d9" class="ku kv it bd kw kx mu kz la lb mv ld le jz mw ka lg kc mx kd li kf my kg lk ll bi translated">使用Nodejs创建发布者</h1><p id="50fa" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">这里，publisher试图通过用于消息传递的AMQP协议将<code class="fe op oq or os b">{number: 10}</code>消息发送到<code class="fe op oq or os b">"number"</code>队列。</p><pre class="kj kk kl km gt ot os ou ov aw ow bi"><span id="923e" class="oa kv it os b gy ox oy l oz pa">const amqp = require("<strong class="os iu">amqplib</strong>");</span><span id="4f51" class="oa kv it os b gy pb oy l oz pa">async function connect() {<br/> const msgBuffer = Buffer.from(JSON.stringify({ number: 10 }));<br/> try {<br/>   const connection = await <strong class="os iu">amqp.connect</strong>("amqp://localhost:5672");<br/>   const channel = await <strong class="os iu">connection.createChannel</strong>();<br/>   await <strong class="os iu">channel</strong>.<strong class="os iu">assertQueue</strong>("number");<br/>   await <strong class="os iu">channel</strong>.<strong class="os iu">sendToQueue</strong>("number", msgBuffer);<br/>   console.log("Sending message to number queue");<br/>   await <strong class="os iu">channel</strong>.<strong class="os iu">close</strong>();<br/>   await <strong class="os iu">connection</strong>.<strong class="os iu">close</strong>();<br/> } catch (ex) {<br/>   console.error(ex);<br/> }<br/>}</span><span id="dc6e" class="oa kv it os b gy pb oy l oz pa">connect();</span></pre><ul class=""><li id="f8d6" class="nm nn it lo b lp mi ls mj lv no lz np md nq mh nr ns nt nu bi translated"><code class="fe op oq or os b">amqp.connect</code> →创建与RabbitMQ服务的<strong class="lo iu"> TCP </strong>连接</li><li id="e3ff" class="nm nn it lo b lp nv ls nw lv nx lz ny md nz mh nr ns nt nu bi translated"><code class="fe op oq or os b">connection.createChannel</code> →在创建的连接中创建<strong class="lo iu">虚拟</strong>链接</li><li id="aff0" class="nm nn it lo b lp nv ls nw lv nx lz ny md nz mh nr ns nt nu bi translated"><code class="fe op oq or os b">channel.assertQueue</code> → <strong class="lo iu">连接</strong> <strong class="lo iu">或</strong> <strong class="lo iu">创建</strong>队列(如果不存在)</li><li id="20c5" class="nm nn it lo b lp nv ls nw lv nx lz ny md nz mh nr ns nt nu bi translated"><code class="fe op oq or os b">channel.sendToQueue</code> → <strong class="lo iu">向指定队列发送</strong>消息</li><li id="6085" class="nm nn it lo b lp nv ls nw lv nx lz ny md nz mh nr ns nt nu bi translated"><code class="fe op oq or os b">channel.close</code> →关闭已创建连接内的<strong class="lo iu">虚拟</strong>链接</li><li id="e2a4" class="nm nn it lo b lp nv ls nw lv nx lz ny md nz mh nr ns nt nu bi translated"><code class="fe op oq or os b">connection.close</code> →关闭<strong class="lo iu"> TCP </strong>与RabbitMQ服务的连接</li></ul><p id="9d0a" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">这里让我们将上述内容添加到<code class="fe op oq or os b">publisher.js</code>中，并通过执行<code class="fe op oq or os b">node publisher.js</code>向RabbitMQ发送消息。它会将1条消息推送到<strong class="lo iu">默认</strong>交换<strong class="lo iu">到<code class="fe op oq or os b"><strong class="lo iu">"number"</strong></code>队列<strong class="lo iu">中</strong>。因为没有消费者，所以从管理门户可以看到1条消息被保留，并且一直在队列中，直到被消费。还要注意，Nodejs publisher脚本在发送消息后终止，因此<strong class="lo iu">连接</strong> <strong class="lo iu">保持为0 </strong>。</strong></p><div class="kj kk kl km gt ab cb"><figure class="pd kn pr pf pg ph pi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/ffe71bdb9e46e482765100990a1c6390.png" data-original-src="https://miro.medium.com/v2/resize:fit:954/format:webp/1*8tS-FbB0uMEB2iCyzTbxaA.png"/></div></figure><figure class="pd kn ps pf pg ph pi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/c233a27b7daa1333c93fc934e91ee858.png" data-original-src="https://miro.medium.com/v2/resize:fit:1048/format:webp/1*9wq1zJ4R3OLz_EwB06gjew.png"/></div></figure></div></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="2424" class="ku kv it bd kw kx mu kz la lb mv ld le jz mw ka lg kc mx kd li kf my kg lk ll bi translated">使用Nodejs创建消费者</h1><p id="afeb" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">在这里，消费者将尝试接收已经由出版商发送消息，并继续通过AMQP收听来自RabbitMQ的任何新消息。</p><pre class="kj kk kl km gt ot os ou ov aw ow bi"><span id="51b4" class="oa kv it os b gy ox oy l oz pa">const amqp = require("amqplib");</span><span id="899d" class="oa kv it os b gy pb oy l oz pa">async function connect() {<br/> try {<br/>   const connection = await <strong class="os iu">amqp</strong>.<strong class="os iu">connect</strong>("amqp://localhost:5672");<br/>   const channel = await <strong class="os iu">connection</strong>.<strong class="os iu">createChannel</strong>();<br/>   await <strong class="os iu">channel</strong>.<strong class="os iu">assertQueue</strong>("number");<br/>   <strong class="os iu">channel</strong>.<strong class="os iu">consume</strong>("number", message =&gt; {<br/>     const input = JSON.parse(message.content.toString());<br/>     console.log(`Received number: ${input.number}`);<br/>     <strong class="os iu">channel</strong>.<strong class="os iu">ack</strong>(message);<br/>   });<br/>   console.log(`Waiting for messages...`);<br/> } catch (ex) {<br/>   console.error(ex);<br/> }<br/>}</span><span id="b79e" class="oa kv it os b gy pb oy l oz pa">connect();</span></pre><ul class=""><li id="9bdb" class="nm nn it lo b lp mi ls mj lv no lz np md nq mh nr ns nt nu bi translated"><code class="fe op oq or os b">amqp.connect</code> →创建与RabbitMQ服务的<strong class="lo iu"> TCP </strong>连接</li><li id="5b71" class="nm nn it lo b lp nv ls nw lv nx lz ny md nz mh nr ns nt nu bi translated"><code class="fe op oq or os b">connection.createChannel</code> →在创建的连接中创建<strong class="lo iu">虚拟</strong>链接</li><li id="ce9e" class="nm nn it lo b lp nv ls nw lv nx lz ny md nz mh nr ns nt nu bi translated"><code class="fe op oq or os b">channel.assertQueue</code> → <strong class="lo iu">连接</strong> <strong class="lo iu">或</strong> <strong class="lo iu">创建</strong>队列(如果不存在)</li><li id="59c9" class="nm nn it lo b lp nv ls nw lv nx lz ny md nz mh nr ns nt nu bi translated"><code class="fe op oq or os b">channel.consume</code> → <strong class="lo iu">等待接收来自指定队列的</strong>消息，当消息发出时执行回调函数</li><li id="e6a4" class="nm nn it lo b lp nv ls nw lv nx lz ny md nz mh nr ns nt nu bi translated"><code class="fe op oq or os b">channel.ack</code> → <strong class="lo iu">向RabbitMQ服务确认</strong>收到了特定的消息，因此它不会再次重试</li></ul><p id="efa2" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">在这里，让我们将上述内容添加到<code class="fe op oq or os b">consumer.js</code> &amp;中，通过执行<code class="fe op oq or os b">node consumer.js</code>将消息接收到RabbitMQ。它将从<strong class="lo iu">默认</strong> <strong class="lo iu">交换</strong>的<code class="fe op oq or os b"><strong class="lo iu">"number"</strong></code> <strong class="lo iu">队列</strong>中读取现有的1条报文。还要注意，Nodejs消费者脚本在收到消息后不会终止，它将继续监听任何即将到来的消息。这是通过管理门户中的“连接”选项卡确定的，其中连接了一个连接。此外，可以看出，现有的1条消息被消耗，并从RabbitMQ中移除。这是因为消费者已经确认收到并使用了消息，RabbitMQ可以删除已使用的消息。</p><div class="kj kk kl km gt ab cb"><figure class="pd kn pt pf pg ph pi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/340d3e7a63cf0dafc60154eea78a60b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:980/format:webp/1*tQGgzDus4p_ooc9ob2Fzvg.png"/></div></figure><figure class="pd kn pu pf pg ph pi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/8de8a1e9f765e3467bfb81ef85a0d0e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1022/format:webp/1*IUDv733Mi_o5UACtQdtg_Q.png"/></div></figure></div></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="ed45" class="ku kv it bd kw kx mu kz la lb mv ld le jz mw ka lg kc mx kd li kf my kg lk ll bi translated">创建具有多个消费者的应用程序</h1><p id="ce69" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">在本例中，publisher将把数字列表作为输入，并根据数字发送到<code class="fe op oq or os b">odd</code>或<code class="fe op oq or os b">even</code>队列。然后将有多个消费者监听每个队列来检查行为。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pv"><img src="../Images/70d6b304225177bc2862fcad51ae42b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YrowJlitUf3FyPpdZ8YUQw.png"/></div></div></figure><p id="3792" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">要检查实时行为，需要在发布者发送消息之前连接消费者。因此，按照消费者代码，在三个不同的终端中运行三个消费者:将有两个消费者监听<code class="fe op oq or os b">odd</code>队列，一个消费者监听<code class="fe op oq or os b">even</code>队列。</p><pre class="kj kk kl km gt ot os ou ov aw ow bi"><span id="4023" class="oa kv it os b gy ox oy l oz pa">$ node ./consumer.js odd<br/>$ node ./consumer.js odd<br/>$ node ./consumer.js even</span></pre><p id="6564" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">现在从下面的publisher代码，它可以发送数字列表到两个队列。这里它将添加5个数字作为检查行为的输入。</p><pre class="kj kk kl km gt ot os ou ov aw ow bi"><span id="c9b4" class="oa kv it os b gy ox oy l oz pa">$ node ./publisher.js 1,2,3,4,5</span></pre><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pw px l"/></div></figure><p id="7b10" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">用一个发布者和三个消费者执行的输出将是:</p><pre class="kj kk kl km gt ot os ou ov aw ow bi"><span id="2d75" class="oa kv it os b gy ox oy l oz pa">$ <strong class="os iu">node publisher.js 1,2,3,4,5</strong><br/>Start publishing<br/>Publishing number: 1 to queueName: odd<br/>Publishing number: 2 to queueName: even<br/>Publishing number: 3 to queueName: odd<br/>Publishing number: 4 to queueName: even<br/>Publishing number: 5 to queueName: odd<br/>End publishing</span><span id="5c72" class="oa kv it os b gy pb oy l oz pa">$ <strong class="os iu">node consumer.js odd</strong><br/>Waiting for messages from queueName: odd<br/>Received number: 1 from queueName: odd<br/>Received number: 5 from queueName: odd</span><span id="9ea6" class="oa kv it os b gy pb oy l oz pa">$ <strong class="os iu">node consumer.js odd</strong><br/>Waiting for messages from queueName: odd<br/>Received number: 3 from queueName: odd</span><span id="41fb" class="oa kv it os b gy pb oy l oz pa">$ <strong class="os iu">node consumer.js even<br/></strong>Waiting for messages from queueName: even<br/>Received number: 2 from queueName: even<br/>Received number: 4 from queueName: even</span></pre><p id="3179" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">这里的一个重要观察是<code class="fe op oq or os b">odd</code>队列有两个消费者，但是每个消费者消费的东西并不重复。这意味着<strong class="lo iu"> RabbitMQ将允许一条消息只被一个消费者</strong>消费。当同一个队列有多个消费者时，<strong class="lo iu"> RabbitMQ将按照循环轮换法在消费者之间做出决定</strong>。这就是为什么对一个消费者来说是T3和T4，对另一个消费者来说是中间T5。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="31d5" class="ku kv it bd kw kx mu kz la lb mv ld le jz mw ka lg kc mx kd li kf my kg lk ll bi translated">用RabbitMQ监控</h1><p id="0739" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">如上所述，RabbitMQ管理门户有助于监控RabbitMQ服务的状态，并配置服务。然而RabbitMQ支持与更先进和更流行的<strong class="lo iu"> Prometheus </strong>和<strong class="lo iu"> Grafana </strong>的集成。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="c915" class="ku kv it bd kw kx mu kz la lb mv ld le jz mw ka lg kc mx kd li kf my kg lk ll bi translated">使用RabbitMQ进行聚类</h1><p id="ad78" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">对于事件驱动系统，RabbitMQ将在通信中发挥重要作用，因此需要避免复杂生态系统中的单点故障。因此RabbitMQ提供了集群能力，其中多个RabbitMQ实例可以协同工作，提供高可用性。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="a074" class="ku kv it bd kw kx mu kz la lb mv ld le jz mw ka lg kc mx kd li kf my kg lk ll bi translated">Kubernetes with RabbitMQ</h1><p id="02dd" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">RabbitMQ集群可以轻松设置，也可以<strong class="lo iu">集成</strong> <strong class="lo iu">到</strong> <strong class="lo iu"> Kubernetes </strong>，因此，如果生态系统在Kubernetes中运行，集成RabbitMQ集群以实现高可用性消息服务是可行的。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><p id="cda1" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">总之，<strong class="lo iu"> RabbitMQ </strong>是微服务架构中提供异步通信的常用可靠方法。它易于使用，并消除了应用程序中消息传递的复杂性，从而允许开发人员更多地关注应用程序。</p></div></div>    
</body>
</html>