<html>
<head>
<title>Dynamic Programming and Boolean Formulae</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">动态规划和布尔公式</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/dynamic-programming-and-boolean-formulae-2e1d09fcb6fb?source=collection_archive---------25-----------------------#2021-01-19">https://levelup.gitconnected.com/dynamic-programming-and-boolean-formulae-2e1d09fcb6fb?source=collection_archive---------25-----------------------#2021-01-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/ad571acb5c8cc70d90af89e454cb2749.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*h9g-Yk6ABOljEpzK"/></div></div></figure><div class=""/></div><div class="ab cl kb kc hx kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="im in io ip iq"><p id="36cb" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated"><em class="lg">在编程面试中，动态编程是许多面试官的最爱——它测试你的问题公式化策略、对递归算法和数据结构(大多是多维数组或哈希表)的良好使用，还测试你对具有记忆化的递归算法的计算复杂性的推理能力。</em></p><p id="60cf" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">让我们在一个意想不到的地方解决一个动态编程问题。这个问题是QuantCast问的。随意翻阅 <a class="ae lh" href="https://cppcodingzen.com/?p=319" rel="noopener ugc nofollow" target="_blank"> <em class="lg">其他</em> </a> <em class="lg"> </em> <a class="ae lh" href="https://cppcodingzen.com/?p=218" rel="noopener ugc nofollow" target="_blank"> <em class="lg">帖子</em> </a> <em class="lg">获取大部分动态编程实例。</em></p></div><div class="ab cl kb kc hx kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="im in io ip iq"><h1 id="b79d" class="li lj je bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">问题</h1><p id="409b" class="pw-post-body-paragraph ki kj je kk b kl mg kn ko kp mh kr ks kt mi kv kw kx mj kz la lb mk ld le lf im bi translated">您将看到一个表示布尔表达式的数组。这些元素有两种:</p><p id="0ea8" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">确定使用括号对数组元素进行分组的方式的数量，以便整个表达式的计算结果为<code class="fe ml mm mn mo b">True</code>。</p><p id="ad4a" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">例如，假设输入是<code class="fe ml mm mn mo b">['F', '|', 'T', '&amp;', 'T']</code>。在这种情况下，有两个可接受的分组:<code class="fe ml mm mn mo b">(F | T) &amp; T</code>和<code class="fe ml mm mn mo b">F | (T &amp; T)</code>。</p><h1 id="da8c" class="li lj je bd lk ll mp ln lo lp mq lr ls lt mr lv lw lx ms lz ma mb mt md me mf bi translated">解决办法</h1><p id="98f8" class="pw-post-body-paragraph ki kj je kk b kl mg kn ko kp mh kr ks kt mi kv kw kx mj kz la lb mk ld le lf im bi translated">像许多问题一样，解决方案的潜在提示来自这个例子。在给定的例子中，我们在不同的位置(在这种情况下，在布尔运算符<code class="fe ml mm mn mo b">|</code>和<code class="fe ml mm mn mo b">&amp;</code>)对输入数组进行<em class="lg">分割</em>，并组合得到的解。这暗示了一个<em class="lg">分治</em>递归解决方案:</p><ul class=""><li id="2362" class="mu mv je kk b kl km kp kq kt mw kx mx lb my lf mz na nb nc bi translated">迭代整个符号数组。</li><li id="753e" class="mu mv je kk b kl nd kp ne kt nf kx ng lb nh lf mz na nb nc bi translated">每当我们遇到一个布尔运算符(<code class="fe ml mm mn mo b">|</code>、<code class="fe ml mm mn mo b">&amp;</code>、<code class="fe ml mm mn mo b">^</code>)，就把数组分成两部分，递归地找到这两部分的括号。</li><li id="341e" class="mu mv je kk b kl nd kp ne kt nf kx ng lb nh lf mz na nb nc bi translated">使用布尔运算符将两个解决方案组合起来，组成完整的解决方案。</li></ul><p id="a026" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">假设我们原来的数组叫做<code class="fe ml mm mn mo b">symbols</code>，假设<code class="fe ml mm mn mo b">symbols[i]</code>是布尔运算符。我们将把数组分成两个子数组- <code class="fe ml mm mn mo b">symbols[0...i-1]</code>(称为<code class="fe ml mm mn mo b">left</code>)和<code class="fe ml mm mn mo b">symbols[i+1...n]</code>(称为<code class="fe ml mm mn mo b">right)</code>)。让我们定义四个数字:</p><ol class=""><li id="8c03" class="mu mv je kk b kl km kp kq kt mw kx mx lb my lf ni na nb nc bi translated"><code class="fe ml mm mn mo b">false_left</code> =评估为假的<code class="fe ml mm mn mo b">left</code>的括号数。</li><li id="5807" class="mu mv je kk b kl nd kp ne kt nf kx ng lb nh lf ni na nb nc bi translated"><code class="fe ml mm mn mo b">true_left</code> =评估为真的<code class="fe ml mm mn mo b">left</code>的括号数。</li><li id="ca72" class="mu mv je kk b kl nd kp ne kt nf kx ng lb nh lf ni na nb nc bi translated"><code class="fe ml mm mn mo b">false_right</code> =评估为假的<code class="fe ml mm mn mo b">right</code>的括号数。</li><li id="15a5" class="mu mv je kk b kl nd kp ne kt nf kx ng lb nh lf ni na nb nc bi translated"><code class="fe ml mm mn mo b">true_right</code> =评估为真的<code class="fe ml mm mn mo b">right</code>的括号数。</li></ol><p id="d484" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">使用运算符<code class="fe ml mm mn mo b">symbols[i]</code>正确组合这四个数字非常重要，这样整个数组的计算结果为真。我们可以使用下表来组合它们:</p><figure class="nk nl nm nn gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nj"><img src="../Images/2ce20551b13d3ccf20502fe128488af5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ymWa28S6wXLMT3vWZmL_VQ.png"/></div></div></figure><p id="905c" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">我们将有一个类似的表，用于计算组合子数组的结果以使整个数组计算为假的方法的数量。</p><p id="71d2" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">有了这个递归公式，就很容易为这个问题编写一个递归的解决方案。大多数候选人应该能够轻松地编写代码。然而，提出递归公式只是战斗的一部分！如果你利用这个事实，即许多对算法的递归调用共享这个解决方案，你的解决方案将会脱颖而出。对于任何给定的I，符号[0..i-1]可以作为参数多次传递给递归方法。这种观察是<strong class="kk jf"> <em class="lg">动态编程的标志。</em> </strong></p><blockquote class="no np nq"><p id="582d" class="ki kj lg kk b kl km kn ko kp kq kr ks nr ku kv kw ns ky kz la nt lc ld le lf im bi translated">当一个问题的解可以从子问题的解中构造出来时，这个问题就被称为展示了一个最优子结构。此外，如果多个子问题共享一个解决方案，则可以使用<strong class="kk jf">动态编程来解决该问题。</strong></p></blockquote><p id="675e" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">动态编程通过在第一次调用子问题时将子问题的结果缓存在哈希表(通常称为<em class="lg">存储表</em>)中来实现高效的解决方案。对子问题的每个后续调用都简单地使用更快的缓存查找(而不是再次执行计算)来返回解决方案。</p><p id="dd5a" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">下面是我们例子中记忆化的工作方式——我们的原始数组是<code class="fe ml mm mn mo b">symbols = ['F', '|', 'T', '&amp;', 'T']</code>。假设我们试图解决子数组<code class="fe ml mm mn mo b">symbols[2...4] = ['T', '&amp;', 'T']</code>。</p><ul class=""><li id="a5ad" class="mu mv je kk b kl km kp kq kt mw kx mx lb my lf mz na nb nc bi translated">将评估为<code class="fe ml mm mn mo b">true</code>的子数组括起来的方式有一种:<code class="fe ml mm mn mo b">(T &amp; T)</code></li><li id="f6d8" class="mu mv je kk b kl nd kp ne kt nf kx ng lb nh lf mz na nb nc bi translated">没有任何方法可以将子数组括起来，以对其求值<code class="fe ml mm mn mo b">false</code>。</li></ul><p id="8b5e" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">计算完这些信息后，我们将其保存到两个表中:</p><ul class=""><li id="82e7" class="mu mv je kk b kl km kp kq kt mw kx mx lb my lf mz na nb nc bi translated"><code class="fe ml mm mn mo b">true_table[['T', '&amp;', 'T']] = 1</code></li><li id="165a" class="mu mv je kk b kl nd kp ne kt nf kx ng lb nh lf mz na nb nc bi translated"><code class="fe ml mm mn mo b">false_table[['T', '&amp;', 'T']] = 0</code></li></ul><p id="b0a1" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">对<strong class="kk jf"> <em class="lg">相同子数组</em> </strong> <em class="lg">的任何后续调用在true_table和false_table中查找并返回结果(1或0)，而不是重新计算括号。</em></p><p id="21ea" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">上面的动态编程公式启发了下面的C++递归函数:</p><figure class="nk nl nm nn gt iv"><div class="bz fp l di"><div class="nu nv l"/></div><figcaption class="nw nx gj gh gi ny nz bd b be z dk translated">圆括号的递归动态规划算法</figcaption></figure><h1 id="c3a4" class="li lj je bd lk ll mp ln lo lp mq lr ls lt mr lv lw lx ms lz ma mb mt md me mf bi translated">复杂性</h1><p id="34d2" class="pw-post-body-paragraph ki kj je kk b kl mg kn ko kp mh kr ks kt mi kv kw kx mj kz la lb mk ld le lf im bi translated">显然，算法的复杂性是由递归<code class="fe ml mm mn mo b">find_parenthesization</code>方法的复杂性决定的。看看这个方法——它被调用了多少次？该方法在数组中取两个索引，<code class="fe ml mm mn mo b">start</code>和<code class="fe ml mm mn mo b">end</code>。这两者都可以取1到n之间的任何值，其中n是数组的大小。而且，<em class="lg">因为记忆化，每一对(start，end)最多传递给递归函数一次！</em>由于有O(n)对索引，递归方法最多调用O(n)次。在每个调用中，我们可能会迭代整个子数组<code class="fe ml mm mn mo b">symbols[start...end]</code>，做O(n)量的工作。因此，算法的总时间复杂度为O(n ) * O(n) = O(n)。由于我们维护的地图最多有O(n)对形式的<code class="fe ml mm mn mo b">(start, end)</code>，算法的总空间复杂度是O(n)。</p><h1 id="9b13" class="li lj je bd lk ll mp ln lo lp mq lr ls lt mr lv lw lx ms lz ma mb mt md me mf bi translated">单元测试</h1><p id="d743" class="pw-post-body-paragraph ki kj je kk b kl mg kn ko kp mh kr ks kt mi kv kw kx mj kz la lb mk ld le lf im bi translated">让我们写几个好的单元测试，让我们的面试真正脱颖而出！我们将涵盖一些简单的情况(空数组，空真假数组等)。我们还将为一些复杂的情况编写测试，包括问题陈述中的情况。</p><figure class="nk nl nm nn gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oa"><img src="../Images/f0623b7a8ec66e3d4b1f7508017b899b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZBJZ3asX6OBzBBP5n7syMA.png"/></div></div><figcaption class="nw nx gj gh gi ny nz bd b be z dk translated">圆括号的单元测试</figcaption></figure></div><div class="ab cl kb kc hx kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="im in io ip iq"><p id="d39a" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated"><em class="lg">原载于2021年1月19日https://cppcodingzen.com</em><a class="ae lh" href="https://cppcodingzen.com/?p=2172" rel="noopener ugc nofollow" target="_blank"><em class="lg"/></a><em class="lg">。</em></p></div></div>    
</body>
</html>