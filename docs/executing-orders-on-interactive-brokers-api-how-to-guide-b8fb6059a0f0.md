# 在交互式经纪人 API 上执行订单(操作指南)

> 原文：<https://levelup.gitconnected.com/executing-orders-on-interactive-brokers-api-how-to-guide-b8fb6059a0f0>

![](img/1b8d2a2eac93367a3731c4418d1e13e7.png)

穆罕默德·何西尼·拉德在 [Unsplash](https://unsplash.com/s/photos/code?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上拍摄的照片

# 简介:

本文是交互式代理 API 教程系列(第 2 部分)的继续。第一篇文章展示了建立一个程序和开始使用你自己的系统交易程序的最初步骤。

## 文章来源:

文章根据[**互动券商指南**](http://thequantacademy.com?utm_source=Medium&utm_medium=writing&utm_campaign=executing_orders) **。**

## 相关资源:

*   [全指南](http://thequantacademy.com?utm_source=Medium&utm_medium=writing&utm_campaign=executing_orders)
*   [Github 代码](https://github.com/corbinbalzan/IBAPICode)
*   [上一篇文章](https://medium.com/swlh/structure-and-communicating-with-interactive-brokers-api-python-78ed9dcaccd7)

**这一部分展示了如何完成任何系统交易程序中最关键的一个环节:买单**。代码是用 Python 编写的，根据您选择的语言，技术可能会略有不同。官方的交互式经纪人文档可以澄清这些区别。

# 概观

## 订单策略

在这一部分中，我们将开发一个名为 Order Execution 的方法来构建一个契约和订单对象，将对象发送到 TWS，然后履行订单。

互动经纪商(IB)的突出之处在于其执行订单的速度比竞争对手更快。此外，由于有超过 35 个选项，IB 可以执行的订单方法范围之广令人难以置信。

在本教程中，从最简单的公开市场操作开始是有意义的。我们将实现一个方法，可以购买和卖空股票作为市场订单。但是，随着您对 API 越来越熟悉，我鼓励您更深入地阅读文档，尝试并找到更适合您的算法策略的订单类型。

## 订单执行是如何工作的？

从逻辑上讲，订单通过 TestClient 类发送，并在 TWS 中接收。这些订单被创建为 API 代码中指定的对象，用来自我们的应用程序的数据填充，然后通过客户端方法 placeOrder()发送。然后，我们收到来自包装类的确认。

在此部分中，在定时事件后，市场订单与固定信息一起发送。随着算法的进一步开发，您可以收集必要的信息，根据特定于您的应用程序的特定触发器来创建更动态的算法。

# 构建合同对象

契约对象是建立市场交易所需的第一个元素。这个对象位于 IB API 文件夹(从 Interactive Brokers 下载)中，文件名为 contract.py。

如果您想了解每种契约类型可用的高级参数，请随意阅读 contract.py。然而，出于我们的目的，我们在*IBJts/samples/Python/Testbed*中引用 ContractSamples.py。测试床文件包含可以在您的程序中测试和实现的有用方法。Interactive Brokers 提供了此文件，其中包含所有可能的合同类型，以供参考。**为了我们的目的，我们将使用 USStock** **(代码 4.1)** 。

代码 4.1

这个方法是在我们的主程序 ibProgram1.py 中使用和定制的。目前，合同字段将根据以下字段填充静态数据:

*   **Symbol:** 该证券的目标股票代码，现在填充为 Apple
*   **证券类型:**证券类型，现在填入“STK”(股票)。
*   **货币:**您将使用的货币。由于我们正在创建一个 USStock 合同类型，我们使用美元。
*   **交易所:**交易该合约的交易所。在我们的对象中，我们使用“智能”交换。Smart 是由交互式经纪人提供的路由服务，它不断扫描市场并将您的订单路由到价格和可用性最佳的交易所。
*   **PrimaryExch:** 默认推荐智能路由；但是，如果智能系统有问题，或者您希望您的程序有一个交换，那么您可以用一个主交换来覆盖(在示例中被注释掉)。

代码 4.2

创建合同并填充字段后，我们就可以开始构建订单对象了。

# 构建订单对象

订单对象是构建市场采购所需的下一步。这个对象位于 IB API 文件夹中，文件名为 object.py。在上一节中，我们在第 6 行从这个文件中导入了这个类，所以像 contract 对象一样，它已经可以使用了。

模板订单对象可以在*IBJts/samples/Python/Testbed*(代码 4.3)中的 OrderSamples.py 内找到。

代码 4.3

与契约对象类似，我们在主程序中构建订单对象，位于 contractCreate()方法(代码 4.4)之下。

代码 4.4

*   **动作:**指定市场动作。在我们的情况下，我们将购买股票；但是，同一个对象将用于通过“sell”操作出售现有股份。类似地，可以在买入动作之前发送卖出动作，以便卖空股票(可以在相同数量上使用买入来弥补被卖空的股票)。
*   **OrderType:** 为我们的演示设置市场订单，这是最简单的执行类型之一。这可以设置成许多其他类型，如 OrderSamples.py 中所示。
*   **传送:**该字段确保 IB 服务器接收指令并通过交易者工作站。
*   **TotalQuantity:** 我们通过该订单购买的股票数量

现在我们有了合同和订单对象，我们准备将这两者组合在一起，并将订单发送到 Trader 工作站。

# 发送订单

因为我们已经创建了构建契约和订单对象的方法，所以我们准备在变量中实例化这些方法，并将它们传递给 placeOrder()。**订单将通过名为 OrderExecution** 的方法提交。您可以在代码 4.5 中看到所有三个方法之间的交互。

代码 4.5

执行的关键是一个叫做 placeOrder 的方法。PlaceOrder 接受契约和订单对象作为第二个和第三个参数。第一个参数是 orderid。

OrderId 是序列中的一个标识符，用于跟踪单个订单。每个订单的 orderId 标识符必须是唯一的(除非在 TWS 的设置中重置)。这意味着不能存在两个具有相同 id 1 的订单。需要有一个 id 为 1 的订单，下一个 id 为 2 的订单，依此类推。如果您试图提交具有重复 id 的订单，那么执行将不会完成，并且在终端中将不会返回错误。每个 orderId 都需要高于所有以前的 orderId。

**例如:**

*   1，2，3 —有效序列
*   2，1，3 —无效，在 1 时失败
*   1，20，39 —有效，所有值递增

对于我们的第一个订单，我们用 id 100 进行测试。该值可以使用一次，然后在后续测试中增加到 101 或更大。稍后，您可以创建自动递增 orderid 的函数(将在下一篇文章中介绍)。在下订单之后，我们可以用一个打印语句来显示程序已经执行到那个点。

要触发这个函数，需要在 orderExecution 程序的末尾添加一个方法调用。在订单执行之前将增加 3 秒钟的短暂等待，以便 TWS 有时间处理初始退货(代码 4.6)。这个值可以加长或缩短，以适应客户机的互联网速度(或者以后用侦听器代替)。如果在 TWS 连接建立之前发出请求，则在没有短暂超时的情况下可能会发生错误。

代码 4.6

**恭喜你！**您刚刚创建并执行了您的第一个订单。在这个程序可以被信任自己执行命令之前，还有许多改进要做。然而，从您的代码中看到订单的执行是一个很大的进步。全部

如果你准备了解更多，请查看 [**全指南**](http://thequantacademy.com?utm_source=Medium&utm_medium=writing&utm_campaign=executing_orders) ！