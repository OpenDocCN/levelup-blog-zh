<html>
<head>
<title>Javascript and Asynchronous Magic — Explaining the JS Engine and Event Loop</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Javascript和异步魔术——解释JS引擎和事件循环</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-and-asynchronous-magic-bee537edc2da?source=collection_archive---------0-----------------------#2019-02-26">https://levelup.gitconnected.com/javascript-and-asynchronous-magic-bee537edc2da?source=collection_archive---------0-----------------------#2019-02-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/b62075e2024de187cc773557356aff4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VNJxBO3aLOJ4zI6BVOhH2A.jpeg"/></div></div></figure><p id="2d58" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我们说JavaScript是单线程或同步的时候，我们指的是什么？在JS-speak中，这些术语是这样一个事实的同义词，即Javascript引擎，无论是像Google Chrome的V8这样的浏览器引擎，还是在本地机器上用NodeJS解释的代码，都只有一个调用栈。</p><p id="7d5f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">就如何编写高效的Javascript代码而言，仅仅这个事实就有非常重要的意义。这篇文章将探讨我目前对其中一些含义的了解，以及使用Javascript ES6的异步功能解决这些问题的方法。</p><h2 id="687b" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">Javascript引擎</h2><p id="ed37" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">首先，我们需要了解JavaScript引擎是如何工作的，以及这个架构实际上是什么样子。下图中可以看到Javascript引擎:</p><figure class="lv lw lx ly gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lu"><img src="../Images/6fcacfd2fe0739a62b6cb6c2ced7a1d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m5M4NV495oH4ADvpnItnVQ.png"/></div></div></figure><p id="9228" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">发动机有几个部分。</p><ol class=""><li id="d8dc" class="lz ma iq ka b kb kc kf kg kj mb kn mc kr md kv me mf mg mh bi translated"><strong class="ka ir"> <em class="mi">堆</em> </strong>:这是用来存储变量、函数、对象的物理内存空间。因为Javascript中的一切都是对象，所以使用<code class="fe mj mk ml mm b">new</code>关键字在内存中分配的任何东西都存储在堆中。Javascript还有一个垃圾收集器，可以释放分配的内存，这样就不必像在C/C++中那样手动释放。</li><li id="ea5b" class="lz ma iq ka b kb mn kf mo kj mp kn mq kr mr kv me mf mg mh bi translated"><strong class="ka ir"> <em class="mi">栈</em> </strong>:这里是存储函数和API调用(浏览器中的Web API和本地机器上的C/C++ API通过NodeJs)的地方。这部分的行为就像一个典型的具有后进先出结构(LIFO)的堆栈数据结构。函数调用被添加到堆栈的顶部，并在执行完成后从顶部弹出。</li><li id="4645" class="lz ma iq ka b kb mn kf mo kj mp kn mq kr mr kv me mf mg mh bi translated"><strong class="ka ir"><em class="mi">API(Web或C/C++) </em> </strong>:这是<code class="fe mj mk ml mm b">setTimeout()</code>和<code class="fe mj mk ml mm b">fetch()</code>等内置函数的实际功能所在的位置。在某种程度上，像<code class="fe mj mk ml mm b">setTimeout()</code>这样的函数可以被认为是激活了API函数，然后在API函数继续在后台运行的同时被立即弹出调用堆栈(在这种情况下，一个定时器在后台运行)。</li><li id="04a4" class="lz ma iq ka b kb mn kf mo kj mp kn mq kr mr kv me mf mg mh bi translated"><strong class="ka ir"> <em class="mi">回调队列</em> </strong>:一些像<code class="fe mj mk ml mm b">setTimeout()</code>这样联系API的函数需要提供一个回调函数给它，这样它就知道API函数运行后该做什么。在这种情况下，回调函数被放在回调队列中。队列本身就像队列数据结构一样，是一种先进先出结构(FIFO)。</li><li id="103f" class="lz ma iq ka b kb mn kf mo kj mp kn mq kr mr kv me mf mg mh bi translated"><strong class="ka ir"> <em class="mi">事件循环</em> </strong>:事件循环是一种不断检查调用栈，看是否有需要运行的函数调用的算法。当调用堆栈为空时，回调队列中的第一项被推送到调用堆栈上以完成执行。这种情况会一直发生，直到队列为空。</li></ol><h2 id="b17d" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">单线程与多线程</h2><p id="6889" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">我们已经知道Javascript是一种单线程语言，它只有一个调用栈，但是这实际上意味着什么呢？在计算机科学中，线程就像一个能够独立运行代码行的实体。因此，单线程就像是说只有一个实体在运行代码行。多线程就像是说有多个实体能够同时运行多行代码。</p><p id="d000" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">单线程应用的含义是，瓶颈是不可避免的，一系列代码行的运行时间受到运行时间最长的代码行的速度限制。例如，如果您要运行以下内容:</p><pre class="lv lw lx ly gt ms mm mt mu aw mv bi"><span id="6c67" class="kw kx iq mm b gy mw mx l my mz">console.log("Hello");<br/>const takesALongTime = () =&gt; {<br/>  // Function that takes 1 hour to run</span><span id="0d05" class="kw kx iq mm b gy na mx l my mz">takesALongTime();<br/>console.log("Bye");</span></pre><p id="11df" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Javascript的单线程特性意味着这一系列代码将把<code class="fe mj mk ml mm b">Hello</code>打印到控制台，然后花整整一个小时才把<code class="fe mj mk ml mm b">Bye</code>打印到控制台。没有办法绕过中间函数，因此第二个控制台日志可以在中间函数完成之前运行。在这种情况下，第一个<code class="fe mj mk ml mm b">console.log</code>被推到调用堆栈上，执行，然后弹出。中间的函数被推送到调用堆栈中，而在它内部运行的任何其他函数都被推送到调用堆栈中。最后，中间的函数在一个小时后被弹出，最后一个<code class="fe mj mk ml mm b">console.log</code>被推入、运行并从调用堆栈中弹出。效率很低，是吧？</p><h2 id="be93" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">一个可行的解决方案:异步回调</h2><p id="c2ee" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">Javascript可以做的一件很酷的事情是将函数作为参数传递给其他函数。当一个函数被传递给另一个函数而没有<code class="fe mj mk ml mm b">()</code>时，它被称为回调函数。例如，如果您有以下代码:</p><pre class="lv lw lx ly gt ms mm mt mu aw mv bi"><span id="a893" class="kw kx iq mm b gy mw mx l my mz">function functionOne(num) {<br/>  console.log(num);<br/>}</span><span id="84c8" class="kw kx iq mm b gy na mx l my mz">function functionTwo(num, callback) {<br/>  callbackNum = 10;<br/>  callback(callbackNum);<br/>  console.log(num);<br/>}</span><span id="6d31" class="kw kx iq mm b gy na mx l my mz">functionTwo(5, functionOne); //outputs 10, then 5 on a new line</span></pre><p id="62d3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这创建了一个闭包，其中函数<code class="fe mj mk ml mm b">functionOne</code>可以访问<code class="fe mj mk ml mm b">functionTwo</code>的范围。函数<code class="fe mj mk ml mm b">functionOne</code>作为回调传递给<code class="fe mj mk ml mm b">functionTwo</code>，因此，回调函数本身被放入Javascript引擎的回调队列中，然后当回调函数为空时，将回调函数推送到调用堆栈中。</p><p id="fb00" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当然，我们知道<code class="fe mj mk ml mm b">console.log</code>立即运行，所以我们把<code class="fe mj mk ml mm b">functionOne</code>放在回调队列中，但是由于调用栈是空的，所以它立即被放在调用栈上运行，这样就打印出了为10的<code class="fe mj mk ml mm b">callbackNum</code>，然后从栈中弹出。然后将<code class="fe mj mk ml mm b">console.log(num)</code>放在调用堆栈上，打印5。</p><p id="03cb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这不是一个非常有用的例子，所以让我们用这个函数花了一个小时执行的代码作为例子。以下是评论:</p><pre class="lv lw lx ly gt ms mm mt mu aw mv bi"><span id="6c4f" class="kw kx iq mm b gy mw mx l my mz">console.log("Hello");<br/>const takesALongTime = () =&gt; {<br/>  // Function that takes 1 hour to run</span><span id="f689" class="kw kx iq mm b gy na mx l my mz">takesALongTime();<br/>console.log("Bye");</span></pre><p id="b9c6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您不能自己编写一个异步Javascript函数。你可以做的是使用一个异步原语，比如<code class="fe mj mk ml mm b">setTimeout()</code>，它将与回调队列交互。那么，我们如何使用<code class="fe mj mk ml mm b">setTimeout()</code>来允许在<code class="fe mj mk ml mm b">takesALongTime()</code>完成之前打印<code class="fe mj mk ml mm b">Bye</code>？我们可以这样做:</p><pre class="lv lw lx ly gt ms mm mt mu aw mv bi"><span id="7ea5" class="kw kx iq mm b gy mw mx l my mz">console.log("Hello");<br/>const takesALongTime = () =&gt; {<br/>  // Function that takes 1 hour to run<br/>setTimeout(takesALongTime, 2000);<br/>console.log("Bye");</span></pre><p id="7a37" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这将打印出<code class="fe mj mk ml mm b">Hello</code>，然后是<code class="fe mj mk ml mm b">Bye</code>，然后等待一个小时，等待<code class="fe mj mk ml mm b">takesALongTime()</code>函数完成执行，然后退出程序。那么这里到底发生了什么呢？</p><ol class=""><li id="3a5d" class="lz ma iq ka b kb kc kf kg kj mb kn mc kr md kv me mf mg mh bi translated">将<code class="fe mj mk ml mm b">console.log("Hello")</code>推入调用堆栈并执行。然后它被弹出。</li><li id="be43" class="lz ma iq ka b kb mn kf mo kj mp kn mq kr mr kv me mf mg mh bi translated"><code class="fe mj mk ml mm b">setTimeout(takesALongTime, 1000)</code>被推到调用堆栈上。<code class="fe mj mk ml mm b">setTimeout</code>函数与Web API或C/C++ API交互，启动一个2秒计时器。</li><li id="5562" class="lz ma iq ka b kb mn kf mo kj mp kn mq kr mr kv me mf mg mh bi translated"><code class="fe mj mk ml mm b">setTimeout</code>函数的工作已经完成，所以它被弹出调用堆栈。</li><li id="6c20" class="lz ma iq ka b kb mn kf mo kj mp kn mq kr mr kv me mf mg mh bi translated">将<code class="fe mj mk ml mm b">console.log("Bye")</code>推入调用堆栈并执行。然后它被弹出。</li><li id="09b1" class="lz ma iq ka b kb mn kf mo kj mp kn mq kr mr kv me mf mg mh bi translated">两秒钟后，计时器结束，并且<code class="fe mj mk ml mm b">takesALongTime</code>回调被加入回调队列。</li><li id="9215" class="lz ma iq ka b kb mn kf mo kj mp kn mq kr mr kv me mf mg mh bi translated">事件循环查看调用堆栈，发现它是空的，于是它将<code class="fe mj mk ml mm b">takesALongTime</code>回调函数推到调用堆栈上执行。</li><li id="4bda" class="lz ma iq ka b kb mn kf mo kj mp kn mq kr mr kv me mf mg mh bi translated">一小时后，<code class="fe mj mk ml mm b">takesALongTime</code>完成，并从调用堆栈中弹出。</li></ol><h2 id="c4c0" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">更好的解决方案:Javascript Promise对象</h2><figure class="lv lw lx ly gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nb"><img src="../Images/f0d273c36fa9c12de0edbd2455cee9af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dpnAH5O-2ik_zmfa02CM2w.jpeg"/></div></div></figure><p id="4a85" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以当我说你不能写异步函数的时候，我有点撒谎了。Javascript ES6引入了一个名为promises的特性，使得编写异步Javascript更加容易。承诺基本上是将来可能解析(本质上是返回)一个值的对象，但它将通过回调通知调用函数它是否成功。</p><p id="bb6b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">承诺有三种状态:履行、拒绝或待定，这三种状态的定义都很简单。完整的承诺流程由以下序列组成:</p><pre class="lv lw lx ly gt ms mm mt mu aw mv bi"><span id="6926" class="kw kx iq mm b gy mw mx l my mz">1. Executor code (may take time to complete)<br/>2. One or more consumer code (uses result of previous executor or consumer code)<br/>3. (optional) error catch code</span></pre><p id="1148" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">承诺可以通过以下方式宣布:</p><pre class="lv lw lx ly gt ms mm mt mu aw mv bi"><span id="5ed1" class="kw kx iq mm b gy mw mx l my mz">let promise = new Promise((resolve, reject) =&gt; {<br/>  // executor code<br/>});</span></pre><p id="cb6b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">promise对象具有内部属性:</p><ol class=""><li id="cf04" class="lz ma iq ka b kb kc kf kg kj mb kn mc kr md kv me mf mg mh bi translated"><code class="fe mj mk ml mm b">state</code> —承诺的当前状态，可以是“已履行”、“已拒绝”或“待定”。当executor代码运行时，状态是“待定”,当承诺完成时，状态可以是“履行”或“拒绝”。</li><li id="fd2e" class="lz ma iq ka b kb mn kf mo kj mp kn mq kr mr kv me mf mg mh bi translated"><code class="fe mj mk ml mm b">result</code> —某个任意值。</li></ol><p id="1364" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">传入的参数<code class="fe mj mk ml mm b">resolve</code>和<code class="fe mj mk ml mm b">reject</code>是Javascript引擎的两个内部函数，根据承诺的最终状态运行。</p><ol class=""><li id="20bd" class="lz ma iq ka b kb kc kf kg kj mb kn mc kr md kv me mf mg mh bi translated"><code class="fe mj mk ml mm b">resolve</code>在履行承诺时运行，它将承诺的状态设置为“已履行”，并将结果设置为某个指定的值。</li><li id="3828" class="lz ma iq ka b kb mn kf mo kj mp kn mq kr mr kv me mf mg mh bi translated"><code class="fe mj mk ml mm b">reject</code>在承诺被拒绝时运行，它将承诺的状态设置为“已拒绝”,并将结果设置为错误。</li></ol><p id="73e7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，下面的代码运行executor函数，成功后，将内部变量<code class="fe mj mk ml mm b">state</code>设置为<code class="fe mj mk ml mm b">"fulfilled"</code>并将<code class="fe mj mk ml mm b">result</code>设置为<code class="fe mj mk ml mm b">"Success"</code>:</p><pre class="lv lw lx ly gt ms mm mt mu aw mv bi"><span id="b4ed" class="kw kx iq mm b gy mw mx l my mz">let promise = new Promise((resolve, reject) =&gt; {<br/>  console.log("Hello");<br/>  resolve("Success");<br/>});</span></pre><p id="93c7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是一个使用<code class="fe mj mk ml mm b">reject</code>功能失败的例子:</p><pre class="lv lw lx ly gt ms mm mt mu aw mv bi"><span id="c421" class="kw kx iq mm b gy mw mx l my mz">let promise = new Promise((resolve, reject) =&gt; {<br/>  console.log("No hello");<br/>  reject("Failure");<br/>});</span></pre><p id="ca25" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不过有一个陷阱！不能直接访问<code class="fe mj mk ml mm b">state</code>和<code class="fe mj mk ml mm b">result</code>变量。它们必须通过“消费者”来访问。主要消费关键词是<code class="fe mj mk ml mm b">then</code>。还有一个<code class="fe mj mk ml mm b">catch</code>消费者调用，专门用于执行器代码遇到错误而无法完成时。</p><p id="df3c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mj mk ml mm b">then</code>调用的语法如下:</p><pre class="lv lw lx ly gt ms mm mt mu aw mv bi"><span id="e1c9" class="kw kx iq mm b gy mw mx l my mz">promise.then(result =&gt; successFunction, error =&gt; failureFunction);</span></pre><p id="9a04" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就是承诺的异步性的来源。<code class="fe mj mk ml mm b">.then</code>在承诺解决后运行(即从“待定”变为“已履行”/“已拒绝”)。第一个参数在承诺成功时运行，而第二个参数在承诺失败时运行，但是两者都将接收到<code class="fe mj mk ml mm b">result</code>是成功并提供值还是失败并提供错误。</p><p id="7795" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是回调队列真正出彩的地方。所有的<code class="fe mj mk ml mm b">.then</code>处理程序都被放入回调队列，这实质上允许所有的承诺代码被直接读取，但不一定被执行。正如我们所了解的，Javascript引擎只在调用栈为空时查看回调队列。因此，这允许在承诺的<code class="fe mj mk ml mm b">.then</code>处理程序之后编写的代码首先执行，即使承诺立即得到解决。一旦所有主函数调用完成，就会执行<code class="fe mj mk ml mm b">.then</code>处理程序。举个例子:</p><pre class="lv lw lx ly gt ms mm mt mu aw mv bi"><span id="14ce" class="kw kx iq mm b gy mw mx l my mz">let promise = new Promise((resolve, reject) =&gt; {<br/>  console.log("Hello");<br/>  resolve("Promise complete");<br/>});<br/>promise.then(result =&gt; console.log(result));<br/>console.log("Bye");</span><span id="1faf" class="kw kx iq mm b gy na mx l my mz">// Output<br/>Hello<br/>Bye<br/>Promise complete</span></pre><p id="821e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Javascript引擎从头到尾阅读承诺，然后是剩余的代码。在这个执行<code class="fe mj mk ml mm b">promise.then(result =&gt; console.log(result))</code>的过程中，它执行promise对象，并将<code class="fe mj mk ml mm b">console.log("Hello")</code>推送到调用栈上，调用栈运行并弹出。然后，它用等于<code class="fe mj mk ml mm b">"Promise complete"</code>的<code class="fe mj mk ml mm b">result</code>来解析承诺。然而，它读取到一个<code class="fe mj mk ml mm b">.then</code>遵循承诺解析，并将其放在回调队列中。然后，它将<code class="fe mj mk ml mm b">console.log("Bye")</code>命令推到调用堆栈上，在那里执行然后弹出。最后，由于调用栈现在是空的，它将<code class="fe mj mk ml mm b">console.log(result)</code>推到调用栈上，并打印<code class="fe mj mk ml mm b">"Promise complete"</code>，后者使用来自执行器代码的结果。</p><p id="e183" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">综上所述，在我们最初的例子中，我们现在可以将<code class="fe mj mk ml mm b">takesALongTime</code>变成一个承诺，这样它就可以异步执行了！</p><pre class="lv lw lx ly gt ms mm mt mu aw mv bi"><span id="e9a4" class="kw kx iq mm b gy mw mx l my mz">const takesALongTime = new Promise((resolve, reject) =&gt; {<br/>  // Code that takes 1 hour to run<br/>  resolve("That took an hour...");<br/>});</span><span id="e282" class="kw kx iq mm b gy na mx l my mz">console.log("Hello");<br/>takesALongTime.then(result =&gt; console.log(result));<br/>console.log("Bye");</span><span id="ad30" class="kw kx iq mm b gy na mx l my mz">//Output<br/>Hello<br/>Bye<br/>That took an hour...</span></pre><h2 id="ab00" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">结论</h2><p id="e065" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">老实说，这只是触及了异步Javascript的皮毛。你能做的事情太多了，也太复杂了。我也还在学习，有些东西让我很难理解！我们甚至还没有涵盖来自ES8的<code class="fe mj mk ml mm b">async/await</code>组合！希望这能给Javascript引擎的工作方式提供一点背景知识，以及如何解决这种令人敬畏的语言的单线程特性。请让我知道是否有任何可以改进的地方。谢谢！</p><p id="9e46" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请随时与我联系！我也在找工作，所以如果你知道任何纽约市地区的招聘人员或公司在寻找全栈软件工程师，请告诉我！:)我喜欢写这样的帖子，并将继续这样做，因为我在我们生活的这个不断变化的技术世界中学到了更多有趣的东西！</p><p id="941c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae nc" href="http://derekhkwok.com" rel="noopener ugc nofollow" target="_blank">投资组合</a></p><p id="a7b5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae nc" href="https://linkedin.com/in/derekkwok94" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a></p><p id="3515" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae nc" href="https://github.com/dkwok94" rel="noopener ugc nofollow" target="_blank"> Github </a></p></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><figure class="lv lw lx ly gt jr gh gi paragraph-image"><a href="https://levelup.gitconnected.com"><div class="gh gi nk"><img src="../Images/9914c5dd23ac08b70eea6f4f9ba6fed2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E6CoI_MRyZ1JInNPsBSHtA.png"/></div></a></figure><div class="nl nm gp gr nn no"><a href="https://gitconnected.com/learn/javascript" rel="noopener  ugc nofollow" target="_blank"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd ir gy z fp nt fr fs nu fu fw ip bi translated">学习JavaScript -最佳JavaScript教程(2019) | gitconnected</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">50大JavaScript教程-免费学习JavaScript。课程由开发人员提交并投票，从而实现…</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">gitconnected.com</p></div></div><div class="nx l"><div class="ny l nz oa ob nx oc jw no"/></div></div></a></div></div></div>    
</body>
</html>