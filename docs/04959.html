<html>
<head>
<title>React Tips — Styles, Clone Element, and Nav Bar</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应提示—样式、克隆元素和导航栏</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/react-tips-styles-clone-element-and-nav-bar-9008be95e37d?source=collection_archive---------12-----------------------#2020-07-26">https://levelup.gitconnected.com/react-tips-styles-clone-element-and-nav-bar-9008be95e37d?source=collection_archive---------12-----------------------#2020-07-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/203ff4a85bd1639c6fc5f724d0eaca83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FoRj2ZMGEE7tUxHg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">克里斯蒂安·马丁在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="2c24" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">React是一个用于创建web应用程序和移动应用程序的流行库。</p><p id="f2a2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将了解一些编写更好的React应用程序的技巧。</p><h1 id="c7f2" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">“Fix”样式属性要求从样式属性到值的映射，而不是字符串错误</h1><p id="df80" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们必须向<code class="fe mh mi mj mk b">style</code>道具传递一个对象。</p><p id="0ebc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="c634" class="mt lf it mk b gy mu mv l mw mx">&lt;span style={{ float: 'left', paddingRight: '5px' }} &gt;foo&lt;/span&gt;</span></pre><p id="e2f1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们传入一个具有骆驼外壳属性的对象，而不是烤肉串外壳。</p><p id="390c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，我们可以用<code class="fe mh mi mj mk b">import</code>关键字从文件中导入样式。</p><p id="718f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><p id="a0eb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">styles.css</code></p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="a2e3" class="mt lf it mk b gy mu mv l mw mx">.color{<br/>  color: "red";<br/>  background: "#0f0";<br/>}</span></pre><p id="1fab" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们写道:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="0fb2" class="mt lf it mk b gy mu mv l mw mx">import './styles.css';</span><span id="ffe5" class="mt lf it mk b gy my mv l mw mx">const Button = (props) =&gt; {<br/>  return (<br/>    &lt;div&gt;<br/>      &lt;span className="color"&gt;{props.age}&lt;/span&gt;<br/>    &lt;/div&gt;<br/>  );<br/>};</span><span id="c31a" class="mt lf it mk b gy my mv l mw mx">const infos = {<br/>  age: 20<br/>};</span><span id="1597" class="mt lf it mk b gy my mv l mw mx">ReactDOM.render(&lt;Button {...infos} /&gt;, mountNode);</span></pre><p id="6a40" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们导入<code class="fe mh mi mj mk b">styles.css</code>，然后样式将被应用。</p><h1 id="965b" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">React useReducer异步数据提取</h1><p id="5e21" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">如果我们要改变一个经过大量计算后设定的状态，可以用<code class="fe mh mi mj mk b">useReducer</code>代替<code class="fe mh mi mj mk b">useState</code>。</p><p id="cece" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们有复杂的状态逻辑，状态中有多个子值，或者下一个状态依赖于前一个状态，那么我们可以使用这个钩子。</p><p id="116a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="1966" class="mt lf it mk b gy mu mv l mw mx">const initialState = {};</span><span id="cd76" class="mt lf it mk b gy my mv l mw mx">function reducer(state, action) {<br/>  switch (action.type) {<br/>    case 'profileReady':<br/>      return action.payload;<br/>    default:<br/>      throw new Error();<br/>  }<br/>}</span><span id="f37e" class="mt lf it mk b gy my mv l mw mx">function App(props) {<br/>  const [profile, setProfile] = React.useReducer(reducer, initialState);</span><span id="e47d" class="mt lf it mk b gy my mv l mw mx">  useEffect(() =&gt; {<br/>    reloadProfile()<br/>      .then((profileData) =&gt; {<br/>        setProfile({<br/>          type: "profileReady",<br/>          payload: profileData<br/>        });<br/>    });<br/>  }, []); </span><span id="f009" class="mt lf it mk b gy my mv l mw mx">  return (<br/>    &lt;div&gt;{profile.name}&lt;/div&gt;<br/>  );<br/>}</span></pre><p id="2329" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们有一个设定状态的减速器。</p><p id="2c3e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们有一个可以传入的初始状态。</p><p id="5bc7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以将它们都传递到<code class="fe mh mi mj mk b">useReducer</code>钩子中。</p><p id="1d54" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它按照这个顺序返回状态和状态设置函数。</p><p id="5e6a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们可以用这个和<code class="fe mh mi mj mk b">useEffect</code>来获取数据并设置它。</p><p id="6e82" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第二个参数中的空数组确保回调仅在组件加载时运行。</p><h1 id="e180" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">如何使用React路由器链接刷新页面</h1><p id="b435" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以在不使用React路由器的情况下重新加载页面。</p><p id="300f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="5cb1" class="mt lf it mk b gy mu mv l mw mx">window.location.reload();</span></pre><p id="ae61" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">重新加载页面。</p><h1 id="9f6b" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">用React路由器创建一个导航条</h1><p id="5175" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">为了使用React Router创建navbar，我们使用React Router附带的组件来创建路由。</p><p id="220c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="5f2b" class="mt lf it mk b gy mu mv l mw mx">import React from "react";<br/>import {<br/>  BrowserRouter as Router,<br/>  Switch,<br/>  Route,<br/>  Link<br/>} from "react-router-dom";</span><span id="dec2" class="mt lf it mk b gy my mv l mw mx">export default function App() {<br/>  return (<br/>    &lt;Router&gt;<br/>      &lt;div&gt;<br/>        &lt;nav&gt;<br/>          &lt;ul&gt;<br/>            &lt;li&gt;<br/>              &lt;Link to="/"&gt;Home&lt;/Link&gt;<br/>            &lt;/li&gt;<br/>            &lt;li&gt;<br/>              &lt;Link to="/about"&gt;About&lt;/Link&gt;<br/>            &lt;/li&gt;<br/>            &lt;li&gt;<br/>              &lt;Link to="/dashboard"&gt;Dashboard&lt;/Link&gt;<br/>            &lt;/li&gt;<br/>          &lt;/ul&gt;<br/>        &lt;/nav&gt;</span><span id="9de8" class="mt lf it mk b gy my mv l mw mx">        &lt;Switch&gt;<br/>          &lt;Route path="/about"&gt;<br/>            &lt;About /&gt;<br/>          &lt;/Route&gt;<br/>          &lt;Route path="/dashboard"&gt;<br/>            &lt;Dashboard /&gt;<br/>          &lt;/Route&gt;<br/>          &lt;Route path="/"&gt;<br/>            &lt;Home /&gt;<br/>          &lt;/Route&gt;<br/>        &lt;/Switch&gt;<br/>      &lt;/div&gt;<br/>    &lt;/Router&gt;<br/>  );<br/>}</span><span id="0f50" class="mt lf it mk b gy my mv l mw mx">function Home() {<br/>  return &lt;h2&gt;Home&lt;/h2&gt;;<br/>}</span><span id="4623" class="mt lf it mk b gy my mv l mw mx">function About() {<br/>  return &lt;h2&gt;About&lt;/h2&gt;;<br/>}</span><span id="7fff" class="mt lf it mk b gy my mv l mw mx">function Dashboard() {<br/>  return &lt;h2&gt;Dashboard&lt;/h2&gt;;<br/>}</span></pre><p id="ec0d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们创建了一些用作路线的组件。</p><p id="8c34" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们使用<code class="fe mh mi mj mk b">Switch</code>组件中的来创建我们的路线。</p><p id="61d7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将<code class="fe mh mi mj mk b">Route</code>组件放入其中，并将想要显示的组件嵌套在其中。</p><p id="546b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">导航栏是用<code class="fe mh mi mj mk b">nav</code>组件创建的。</p><p id="abde" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在它里面，我们有<code class="fe mh mi mj mk b">Link</code>组件来创建链接以显示路由组件。</p><p id="4bc2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">to</code>是我们想要显示的组件的路径。</p><p id="0757" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">并且它应该与<code class="fe mh mi mj mk b">Switch</code>中的<code class="fe mh mi mj mk b">path</code>值之一相匹配。</p><p id="47b6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">做导航，可以调用<code class="fe mh mi mj mk b">history.push</code>导航。</p><p id="c49a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="af5b" class="mt lf it mk b gy mu mv l mw mx">&lt;a onClick={() =&gt; history.push('dashboard') }&gt;Dashboard&lt;/a&gt;</span></pre><p id="b9f0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以编程方式导航。</p><h1 id="f12c" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">在为子级提供属性时，将正确的类型分配给React.cloneElement</h1><p id="fac9" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以将子组件的类型设置为<code class="fe mh mi mj mk b">React.ReactElement</code>类型。</p><p id="258b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="e83c" class="mt lf it mk b gy mu mv l mw mx">return React.cloneElement(child as React.ReactElement&lt;any&gt;, {<br/>  name: this.props.name,<br/>  age: this.props.age<br/>});</span></pre><p id="3664" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果<code class="fe mh mi mj mk b">child</code>是一个元素。</p><p id="de51" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们也可以使用<code class="fe mh mi mj mk b">isValidElement</code>型防护罩。</p><p id="8689" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="b508" class="mt lf it mk b gy mu mv l mw mx">if (React.isValidElement(child)) {<br/>  return React.cloneElement(child, {<br/>    name: this.props.name,<br/>    age: this.props.age<br/>  });<br/>}</span></pre><p id="d143" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这将让TypeScript编译器自动确定类型，而无需添加任何数据类型断言。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/74a9ca2329c68d5d55a2bc8703f6358a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jEYy4CQMsKNsDBhB"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@vaun0815?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> vaun0815 </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="2f78" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="42ff" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mh mi mj mk b">cloneElement</code>可以通过设置正确的类型或使用类型保护在React中与子元素一起使用。</p><p id="ab2a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">造型可以用各种物品来完成。</p><p id="c039" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以使用React路由器轻松创建导航栏。</p></div></div>    
</body>
</html>