<html>
<head>
<title>Working with GraphQL in Rust</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Rust中使用GraphQL</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/working-with-graphql-in-rust-dcbff7e768f1?source=collection_archive---------3-----------------------#2020-10-01">https://levelup.gitconnected.com/working-with-graphql-in-rust-dcbff7e768f1?source=collection_archive---------3-----------------------#2020-10-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/88a99af1cd375ad724c7a71c2adfbd53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DjWm8Ddh48McbtTcJVZ08w.png"/></div></div></figure><p id="6cbe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">GraphQL是开发面向客户端的API的一个非常流行的框架。本文涵盖了GraphQL与Rust集成的基础知识，包括设计一个代码优先的模式，设置一个GraphQL服务器，以及实现定制的解析器和变异。</p><h1 id="978b" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">为什么选择GraphQL和Rust</h1><p id="e766" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">这篇文章的想法源于我最近在工作中所做的事情。我通常花时间编写Rust代码，但最近我一直在一个TypeScript环境中使用GraphQL。GraphQL使用的类型系统让我想起了Rust中的结构，这让我对一起使用GraphQL和Rust感到好奇，所以我决定看看Rust对GraphQL的支持。</p><p id="5be6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">经过一番研究，我能够找到两个库:<a class="ae lz" href="https://crates.io/crates/async-graphql" rel="noopener ugc nofollow" target="_blank"> <em class="ma"> async-graphql </em> </a>和<a class="ae lz" href="https://crates.io/crates/juniper" rel="noopener ugc nofollow" target="_blank"> <em class="ma"> Juniper </em> </a>。根据<em class="ma"> crates.io </em>统计，Juniper 库似乎是首选库。这是一个相当稳定的机箱，支持大多数GraphQL规范。然而，它不支持<em class="ma">订阅</em>或<em class="ma">异步/等待</em>，尽管这两个特性在主分支中都可用。<em class="ma"> async-graphql </em>库是更新的，并且越来越受欢迎。它还支持GraphQL <em class="ma">订阅</em>和<em class="ma">异步/等待</em>语法。一个缺点是,<em class="ma"> async-graphql </em>正在经历API的快速变化，有时一天内会发布多个版本。因为这篇文章不是要比较这两种板条箱，我决定先使用Juniper，因为它现在要稳定得多。</p><h1 id="a781" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">什么是GraphQL</h1><p id="341c" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">以防你不熟悉GraphQL，在进入本教程的其余部分之前，我将给出一个简要的概述。GraphQL是一种API查询语言和一个运行时，用于用请求的数据解析这些查询。从客户端的角度来看，GraphQL允许在客户端和服务器端资源之间进行更好的分离。这意味着客户端不需要知道任何资源的端点，甚至不需要知道两个或更多资源是否相关。客户可以简单地要求它所需要的数据，它将得到确切的数据。在服务器端，根据类型和字段实现了一个GraphQL API。根类型包含资源的名称以及这些资源返回的内容。其他类型定义可以从根类型中的资源返回的数据。为了更深入地了解GraphQL，我建议从这里的开始。</p><h1 id="f330" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">设置一个简单的GraphQL服务器</h1><p id="0896" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">既然我已经选择了一个GraphQL库，我还需要一个web框架来处理传入的GraphQL查询。由于<em class="ma"> Juniper </em>不支持<em class="ma"> async/await </em>语法，我决定在类似的情况下使用web框架<em class="ma"> Rocket </em>。和<em class="ma"> Juniper </em>一样，<em class="ma"> Rocket </em>也不支持<em class="ma"> async/await </em>，但这将在下一个版本中有所改变。</p><blockquote class="mb mc md"><p id="4d18" class="jy jz ma ka b kb kc kd ke kf kg kh ki me kk kl km mf ko kp kq mg ks kt ku kv ij bi translated"><em class="iq"> Rocket要求使用Rust的夜间版本。您可以通过运行命令</em> <code class="fe mh mi mj mk b"><em class="iq">rustup default nightly</em></code> <em class="iq">切换到夜间版本。如果想切换回稳定，只需运行</em> <code class="fe mh mi mj mk b"><em class="iq">rustup default stable</em></code> <em class="iq">命令即可。</em></p></blockquote><p id="6b17" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有了基本的方法，我将开始使用<code class="fe mh mi mj mk b">cargo new rust_graphql_example</code>建立一个新的项目。然后在<em class="ma"> Cargo.toml </em>文件中，我将添加以下依赖项:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="f405" class="mt kx iq mk b gy mu mv l mw mx">juniper = "0.14.2" juniper_rocket = "0.5.2" rocket = "0.4.5"</span></pre><p id="b788" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">需要注意的一点是<em class="ma"> Juniper </em>提供了一些预构建的库，用于与一些web框架集成。对于这个例子，我将使用<a class="ae lz" href="https://crates.io/crates/juniper_rocket" rel="noopener ugc nofollow" target="_blank"><em class="ma">juniper _ rocket</em></a></p><blockquote class="mb mc md"><p id="6bad" class="jy jz ma ka b kb kc kd ke kf kg kh ki me kk kl km mf ko kp kq mg ks kt ku kv ij bi translated"><em class="iq">有关支持的集成的完整列表，请查看</em> <a class="ae lz" href="https://docs.rs/juniper/0.14.2/juniper/index.html" rel="noopener ugc nofollow" target="_blank"> <em class="iq">文档</em> </a> <em class="iq">中的</em>集成<em class="iq">部分。</em></p></blockquote><h2 id="f0c4" class="mt kx iq bd ky my mz dn lc na nb dp lg kj nc nd lk kn ne nf lo kr ng nh ls ni bi translated">简单的模式</h2><p id="3aa4" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">首先要做的是定义一个简单的GraphQL模式。所以我在<em class="ma"> /src </em>目录中创建了一个名为<em class="ma"> schema.rs </em>的新文件，并添加了以下内容:</p><figure class="ml mm mn mo gt jr gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/fa408363b8c67d536a7490bd08cc7a3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/0*FQDpQYhaTSoyO00b.png"/></div></figure><p id="5786" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">GraphQL模式有三个主要部分:查询、变异和根节点。<code class="fe mh mi mj mk b">Query</code> struct用于定义GraphQL可用的资源，并定义如何解析查询。<code class="fe mh mi mj mk b">Query</code>实现块上方的<code class="fe mh mi mj mk b">juniper::object</code>程序宏是在<em class="ma"> Juniper </em>中定义GraphQL解析器的主要方式。<code class="fe mh mi mj mk b">Mutation</code>类型现在只是一个占位符，但是它将在以后定义允许客户端改变数据的资源。你会注意到<code class="fe mh mi mj mk b">EmptyMutation</code>是一个泛型结构。稍后，单元类型<code class="fe mh mi mj mk b">()</code>将被数据库上下文替换。最后，<code class="fe mh mi mj mk b">Schema</code>基本上合并了其他两个结构，成为GraphQL模式的根。</p><h2 id="4187" class="mt kx iq bd ky my mz dn lc na nb dp lg kj nc nd lk kn ne nf lo kr ng nh ls ni bi translated">一个简单的网络服务器</h2><p id="d977" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">既然已经定义了一个简单的模式，我需要设置web服务器。juniper _ rocket库使这变得更容易，因为它提供了一些预构建的集成。在<em class="ma"> main.rs </em>文件中，我添加了以下内容:</p><figure class="ml mm mn mo gt jr gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/35cac468c5128556e46ab3fd45c0d436.png" data-original-src="https://miro.medium.com/v2/resize:fit:1328/format:webp/0*_QAM1chiFkgBzmeG.png"/></div></figure><p id="5515" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个例子中，我设置了两个端点:一个用于GraphiQL接口，另一个用于处理来自实际客户端的post请求。juniper_rocket的集成在这里非常有用，因为它提供了简单的请求和响应包装器以及执行GraphQL查询的简单方法。<code class="fe mh mi mj mk b">juniper_rocket::graphiql_source</code>函数也很好，因为它允许您轻松地在应用程序中设置GraphiQL页面。<code class="fe mh mi mj mk b">main</code>功能只是注册<code class="fe mh mi mj mk b">Schema</code>，安装路由，然后启动web服务器。</p><p id="dd0a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">顺便提一下，我对<em class="ma"> Juniper </em>的一个疑问是<em class="ma"> EmptyMutation </em>是一个通用结构。这意味着如果我不提供一个实际的数据库上下文，就像在这个例子中，我必须将模板类型设置为单元类型。在<em class="ma"> Rocket </em>中，这意味着我必须在<code class="fe mh mi mj mk b">Rocket::State</code>和<code class="fe mh mi mj mk b">manage</code>函数中传递单元类型。这在我看来是不必要的。</p><h2 id="9877" class="mt kx iq bd ky my mz dn lc na nb dp lg kj nc nd lk kn ne nf lo kr ng nh ls ni bi translated">启动服务器</h2><p id="2fee" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">现在我有了一个简单的模式和一个web服务器来处理请求。要测试它，只需运行命令<code class="fe mh mi mj mk b">cargo run</code>，它将编译并启动服务器。一旦项目完成编译，打开web浏览器并导航到<code class="fe mh mi mj mk b">localhost:8000</code>。</p><p id="7f67" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">欢迎来到GraphiQL！该工具支持编写和执行查询以及模式自省。由<code class="fe mh mi mj mk b">Docs</code>按钮指定的<em class="ma">文档浏览器</em>允许模式自省。这意味着我可以深入模式，查看GraphQL可用的资源、字段和类型。这包括任何参数和文档。查询窗口允许我构造一个查询，并通过按播放图标来执行它。例如，如果我键入以下查询:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="ffd8" class="mt kx iq mk b gy mu mv l mw mx">{<br/>  helloWorld<br/>}</span></pre><p id="7d57" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">来自我们的GraphQL服务器的响应是:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="1dcc" class="mt kx iq mk b gy mu mv l mw mx">{<br/>  "data": {<br/>    "helloWorld": "Hello, world!"<br/>  }<br/>}</span></pre><h1 id="12ed" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">自定义GraphQL类型</h1><p id="c0e1" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">现在我已经建立了一个简单的GraphQL模式和服务器。也正好完全没用。对于一个更现实的例子，我将建立一个GraphQL API，它提供关于一个顾问的客户列表及其发票的数据。本例的数据包含在存储库的<code class="fe mh mi mj mk b">/data</code>目录中。我有三个数据源:<em class="ma"> Clients.csv </em>、<em class="ma"> Invoices.csv、</em>和<em class="ma"> InvoiceItems.csv </em>。发票通过<code class="fe mh mi mj mk b">ClientId</code>与客户关联，发票项目通过<code class="fe mh mi mj mk b">InvoiceId</code>与发票关联。</p><blockquote class="mb mc md"><p id="e9e5" class="jy jz ma ka b kb kc kd ke kf kg kh ki me kk kl km mf ko kp kq mg ks kt ku kv ij bi translated"><em class="iq">所有数据都是使用</em><a class="ae lz" href="https://mockaroo.com/" rel="noopener ugc nofollow" target="_blank"><em class="iq">Mockaroo</em></a><em class="iq">随机生成的。</em></p></blockquote><h2 id="54cf" class="mt kx iq bd ky my mz dn lc na nb dp lg kj nc nd lk kn ne nf lo kr ng nh ls ni bi translated">添加数据模型</h2><p id="31fa" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">我想做的第一件事是向项目中添加另外三个依赖项。因为我正在处理CSV数据，所以我想拉进<em class="ma"> csv </em>机箱。另外，<code class="fe mh mi mj mk b">Invoices.csv</code>文件包含日期，所以我将把<em class="ma"> chrono </em>箱拉进来。最后，我需要能够将CSV数据反序列化为定制的Rust类型，所以我想拉进<em class="ma"> serde </em>机箱。将以下内容添加到<em class="ma"> Cargo.toml </em>文件中:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="5619" class="mt kx iq mk b gy mu mv l mw mx">chrono = { version = "0.4.15", features=["serde"] } csv = "1.1" serde = { version = "1.0", features = ["derive"] }</span></pre><p id="42a2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，我创建一个名为<em class="ma"> models.rs </em>的新文件，并用一个模块声明更新<em class="ma"> main.rs </em>:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="4b59" class="mt kx iq mk b gy mu mv l mw mx">mod models;</span></pre><p id="14ff" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后我用下面的结构定义更新<em class="ma"> models.rs </em>:</p><figure class="ml mm mn mo gt jr gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/933d6643bfd7af80aa1ad5959b06a3ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:876/format:webp/0*PpbR39rxxERRqunU.png"/></div></figure><h2 id="033f" class="mt kx iq bd ky my mz dn lc na nb dp lg kj nc nd lk kn ne nf lo kr ng nh ls ni bi translated">添加数据上下文</h2><p id="3f82" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">下一个任务是添加逻辑来读取CSV数据，并使其可供应用程序访问。为此，我创建了一个名为<em class="ma"> db.rs </em>的文件，并用一个模块声明来更新<em class="ma"> main.rs </em>:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="b141" class="mt kx iq mk b gy mu mv l mw mx">mod db;</span></pre><p id="da78" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，我用以下内容更新<em class="ma"> db.rs </em>:</p><figure class="ml mm mn mo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nm"><img src="../Images/6df41fe4d6caa6192e3886e2f882bb2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*WHUgjof1JyU7yyNM.png"/></div></div></figure><p id="e341" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这提供了一种将CSV文件中的数据提供给应用程序其余部分的方法，但是GraphQL不知道这个<em class="ma"> DataContext </em>结构或任何数据模型。</p><h2 id="29cc" class="mt kx iq bd ky my mz dn lc na nb dp lg kj nc nd lk kn ne nf lo kr ng nh ls ni bi translated">连接到Juniper</h2><p id="30e7" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">这里要做的第一件事是让<em class="ma"> Juniper </em>意识到一个结构是GraphQL类型。一个简单的方法是使用提供的宏<code class="fe mh mi mj mk b">juniper::GraphQLObject</code>。举个例子，我将更新<em class="ma">客户端</em>模型，如下所示:</p><figure class="ml mm mn mo gt jr gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/6d356cc23658c09ef4351b7f0d81b575.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/0*lh9hTmYwkjtvENUr.png"/></div></figure><p id="0d49" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在<em class="ma"> Juniper </em>知道了<em class="ma">客户端</em>模型，但是它不知道如何与<em class="ma"> DataContext </em>接口或者查询客户端数据。为此，我需要将<em class="ma"> schema.rs </em>更新如下:</p><figure class="ml mm mn mo gt jr gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/e3a806288f886d80bbea7aa0910424ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/0*advjY2ntfzCM0Gmh.png"/></div></figure><p id="8b7c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面的代码做了两件事:</p><ul class=""><li id="d6df" class="no np iq ka b kb kc kf kg kj nq kn nr kr ns kv nt nu nv nw bi translated">通过实现<code class="fe mh mi mj mk b">juniper::Context</code>使<em class="ma"> Juniper </em>意识到<em class="ma"> DataContext </em></li><li id="83c7" class="no np iq ka b kb nx kf ny kj nz kn oa kr ob kv nt nu nv nw bi translated">并创建一个名为<code class="fe mh mi mj mk b">clients</code>的GraphQL查询，该查询使用对<em class="ma"> DataContext </em>的引用来查询客户端数据</li></ul><p id="e75a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我还需要通过更新请求处理程序中的<code class="fe mh mi mj mk b">context</code>变量，让<em class="ma"> Rocket </em>知道<em class="ma"> DataContext </em>，并添加一个由<em class="ma"> Rocket </em>管理的<em class="ma"> DataContext </em>的实例。用以下内容更新<em class="ma"> main.rs </em>:</p><figure class="ml mm mn mo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oc"><img src="../Images/8c6d5db3d4550af31c56a37a2ff2702d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*JGQrjDaEIHf0o7ed.png"/></div></div></figure><p id="221d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我应该能够编译和运行这个例子了。当我导航到<code class="fe mh mi mj mk b">http://localhost:8000/</code>时，我可以打开<em class="ma">文档浏览器</em>并点击<em class="ma">查询</em>，我会看到如下内容:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="018b" class="mt kx iq mk b gy mu mv l mw mx">helloWorld: String! <br/>Simple "Hello, world!" query </span><span id="1717" class="mt kx iq mk b gy od mv l mw mx">clients: [Client!]! <br/>Client resource to query clients</span></pre><p id="08b3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这意味着我可以执行如下查询:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="ddaf" class="mt kx iq mk b gy mu mv l mw mx">{<br/>  clients {<br/>    clientId<br/>    companyName<br/>    contactName<br/>    email<br/>  }<br/>}</span></pre><p id="251f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">并得到类似这样的响应:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="041b" class="mt kx iq mk b gy mu mv l mw mx">{<br/>"data": {<br/>  "clients": [<br/>    {<br/>      "clientId": "07-3782546",<br/>      "companyName": "Ward, McLaughlin and Hilpert",<br/>      "contactName": "Helga Jarritt",<br/>      "email": "hjarritt0@icio.us"<br/>    },<br/>    {<br/>      "clientId": "91-7491370",<br/>      "companyName": "Hermiston, Kilback and Runolfsson",<br/>      "contactName": "Leonie Willshear",<br/>      "email": "lwillshear1@amazon.co.uk"<br/>    },<br/>    {<br/>      "clientId": "36-6951968",<br/>      "companyName": "Feil-Lang",<br/>      "contactName": "Franzen Zelake",<br/>      "email": "fzelake2@go.com"<br/>    }<br/>}</span></pre><p id="1446" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个例子允许我查询所有的客户端数据，但是不允许我查看任何其他与客户端相关的数据。我需要的是告诉GraphQL我所有的数据模型都以某种方式相关联。</p><h1 id="ffd2" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">自定义GraphQL解析器</h1><p id="770f" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">这就引出了GraphQL解析器的概念。解析器告诉GraphQL如何检索GraphQL类型的某个字段的数据。因此，对于这个示例，我将把另外两个模型— <em class="ma"> Invoice </em>和<em class="ma"> InvoiceItem </em> —添加到<em class="ma"> Juniper </em>中，以便我可以查询所有相关数据。为此，我需要为<em class="ma">客户端</em>和<em class="ma">发票</em>模型定制一个解析器。</p><p id="0f8f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，我需要更新<em class="ma">型号:</em></p><figure class="ml mm mn mo gt jr gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/aa97e1ec8ae3ebef5190802b7831d629.png" data-original-src="https://miro.medium.com/v2/resize:fit:1328/format:webp/0*a56RC0K2IVnwliXL.png"/></div></figure><p id="314b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">基本上，这只是将宏<code class="fe mh mi mj mk b">juniper::GraphQLObject</code>从<em class="ma">客户端</em>模型移动到<em class="ma"> InvoiceItem </em>模型。</p><p id="a504" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我用<em class="ma">客户端</em>和<em class="ma">发票</em>模型的定制解析器更新<em class="ma"> schema.rs </em>:</p><figure class="ml mm mn mo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oe"><img src="../Images/ff5563f4f7642d94961b316e6716a268.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*sd44QJ62BBdO4LdJ.png"/></div></div></figure><p id="2718" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">自定义解析器由<em class="ma">客户端</em>和<em class="ma">发票</em>的<code class="fe mh mi mj mk b">impl</code>模块定义。除了一个字段之外，它们与相应的数据模型几乎相同。<em class="ma">客户端</em>有一个名为<code class="fe mh mi mj mk b">invoices</code>的函数，它返回与该客户端相关的任何发票。<em class="ma">发票</em>有一个名为<code class="fe mh mi mj mk b">invoice_items</code>的函数，它返回与该发票相关的任何发票项目。</p><p id="2317" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，当我编译并运行这个例子时，我可以查看<em class="ma">文档浏览器</em>并看到<em class="ma">客户端</em>被定义为:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="4d3c" class="mt kx iq mk b gy mu mv l mw mx">Information about a client </span><span id="19b2" class="mt kx iq mk b gy od mv l mw mx">clientId: String! <br/>companyName: String! <br/>contactName: String! <br/>contactTitle: String! <br/>phone: String! <br/>email: String! <br/>invoices: [Invoice!]!</span></pre><p id="12d8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">而<em class="ma">发票</em>的定义是:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="679a" class="mt kx iq mk b gy mu mv l mw mx">Information about an invoice for a specific client </span><span id="dbdb" class="mt kx iq mk b gy od mv l mw mx">invoiceId: Int! <br/>invoiceNumber: String! <br/>clientId: String! <br/>invoiceDate: NaiveDate! <br/>dueDate: NaiveDate! <br/>invoiceItems: [InvoiceItems!]!</span></pre><p id="2d34" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这意味着我可以执行如下查询:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="95c6" class="mt kx iq mk b gy mu mv l mw mx">{ <br/>  clients { <br/>    clientId <br/>    companyName <br/>    contactName<br/>    email <br/>    invoices { <br/>      invoiceNumber <br/>      invoiceDate <br/>      dueDate <br/>      invoiceItems { <br/>        productId <br/>        description <br/>        price <br/>      } <br/>    } <br/>  } <br/>}</span></pre><p id="7bf5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">并得到如下所示的结果:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="cb75" class="mt kx iq mk b gy mu mv l mw mx">{<br/>  "data": {<br/>    "clients": [<br/>      {<br/>        "clientId": "07-3782546",<br/>        "companyName": "Ward, McLaughlin and Hilpert",<br/>        "contactName": "Helga Jarritt",<br/>        "email": "hjarritt0@icio.us",<br/>        "invoices": [<br/>          {<br/>            "invoiceNumber": "INV100001",<br/>            "invoiceDate": "2020-01-31",<br/>            "dueDate": "2020-02-29",<br/>            "invoiceItems": [<br/>              {<br/>                "productId": 7929,<br/>                "description": "leverage back-end e-business",<br/>                "price": 3315.33<br/>              }<br/>            ]<br/>          }<br/>        ]<br/>      }<br/>    ]<br/>  }<br/>}</span></pre><h1 id="5a3f" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">高效的GraphQL查询</h1><p id="0b6a" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">然而，这种设计有一个大问题。假设可能会请求发票数据，那么这种设计是非常低效的。对于每个客户记录，都要进行一次查询，以获取该客户的所有发票。对于每条发票记录，都会进行查询以获取该发票的发票详细信息。这就是众所周知的<code class="fe mh mi mj mk b">N + 1</code>查询问题，并导致寻找执行查询的有效方式。</p><p id="fb22" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">解决这个问题的一个方法是将数据模型与GraphQL类型分离。有几个库可以帮助解决这个问题，例如:</p><ul class=""><li id="bc1d" class="no np iq ka b kb kc kf kg kj nq kn nr kr ns kv nt nu nv nw bi translated"><a class="ae lz" href="https://crates.io/crates/dataloader" rel="noopener ugc nofollow" target="_blank">数据加载器</a></li><li id="9eb1" class="no np iq ka b kb nx kf ny kj nz kn oa kr ob kv nt nu nv nw bi translated"><a class="ae lz" href="https://crates.io/crates/juniper-eager-loading" rel="noopener ugc nofollow" target="_blank">杜松渴望装载</a></li></ul><p id="2bb2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，我想只关注Juniper的集成，所以我决定为这个例子实现一个简单的解决方案。</p><p id="4701" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我需要做两件事来完成这项工作。第一项任务是在中定义GraphQL类型，它独立于数据模型，但允许关系数据。第二个任务是更新<code class="fe mh mi mj mk b">clients</code>查询以提取所有数据，并根据来自数据模型的关系id正确映射数据。我将<em class="ma"> schema.rs </em>更新为以下内容:</p><figure class="ml mm mn mo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi of"><img src="../Images/3fca9990470deae96b8212650a80bd8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*b3sZQ_E1dafRK8MO.png"/></div></div></figure><p id="f859" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">GraphQL类型非常简单，但是我想浏览一下<code class="fe mh mi mj mk b">clients</code>查询。目标是提前获取所有数据，这样就不需要后续的查询。我这样做的方法是使用两个哈希映射——一个用于客户，一个用于发票。我首先创建客户机散列映射，并将<code class="fe mh mi mj mk b">invoices</code>字段初始化为一个空向量。然后我创建发票映射，我只在客户端映射中添加带有<code class="fe mh mi mj mk b">client_id</code>的发票，并将<code class="fe mh mi mj mk b">invoice_items</code>字段设置为空向量。然后，我可以将发票项目数据映射到发票映射中的适当发票，并将发票映射到适当的客户端。在所有数据被正确查询和映射后，我返回客户机列表。</p><h2 id="2f4b" class="mt kx iq bd ky my mz dn lc na nb dp lg kj nc nd lk kn ne nf lo kr ng nh ls ni bi translated">添加查询参数</h2><p id="5310" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">上面的示例返回所有客户端数据的列表。根据数据量，这可能是一个非常糟糕的主意。GraphQL提供了向查询传递参数的能力。例如，我可以使用参数来实现分页，或者添加另一个查询来按id查找客户机。</p><figure class="ml mm mn mo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi og"><img src="../Images/971abf211f375a9b14db0a07f2511d03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_aSGVcY9wN2OKlnN.png"/></div></div></figure><p id="18a9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个例子通过添加<code class="fe mh mi mj mk b">first</code>和<code class="fe mh mi mj mk b">offset</code>作为参数，为<code class="fe mh mi mj mk b">clients</code>查询添加了简单的分页逻辑。这些参数随后被用于skip和take函数。GraphQL在这里提供了更深入的分页指南<a class="ae lz" href="https://graphql.org/learn/pagination/" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="15e7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">添加了<code class="fe mh mi mj mk b">get_client</code>查询，其逻辑与<code class="fe mh mi mj mk b">clients</code>相似，只是它最多只返回一个客户端。另外，<code class="fe mh mi mj mk b">get_client</code>的返回类型是一个<code class="fe mh mi mj mk b">Option</code>。这意味着如果<code class="fe mh mi mj mk b">id</code>参数与现有的客户端不匹配，响应将如下所示:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="f3ad" class="mt kx iq mk b gy mu mv l mw mx">{<br/>  "data": {<br/>    "getClient": null<br/>  }<br/>}</span></pre><h1 id="0895" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">GraphQL突变</h1><p id="2b27" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">现在，我可以对数据集执行两个独立的查询。但是，我没有办法改变数据的状态。GraphQL提供了一种使用<a class="ae lz" href="https://graphql.org/learn/queries/#mutations" rel="noopener ugc nofollow" target="_blank">突变</a>来修改服务器端数据的方法。</p><h2 id="43a9" class="mt kx iq bd ky my mz dn lc na nb dp lg kj nc nd lk kn ne nf lo kr ng nh ls ni bi translated">在Juniper中添加突变</h2><p id="c130" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">在<em class="ma"> Juniper </em>的上下文中，变异的实现类似于查询的实现。为了添加<code class="fe mh mi mj mk b">Mutation</code>的实现，我替换了这一行:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="8381" class="mt kx iq mk b gy mu mv l mw mx">pub type Mutation = EmptyMutation&lt;DataContext&gt;;</span></pre><p id="3032" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">包含以下内容:</p><figure class="ml mm mn mo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oh"><img src="../Images/b38397fea48a8fa2549eff4cc2396572.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*id-3EP1GWDdD0RjZ.png"/></div></div></figure><p id="f1c1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个例子定义了一个名为<code class="fe mh mi mj mk b">Mutation</code>的空结构，并添加了一个带有<code class="fe mh mi mj mk b">juniper::object</code>属性的实现块。它还向GraphQL声明了名为<code class="fe mh mi mj mk b">NewClient</code>和<code class="fe mh mi mj mk b">NewInvoiceItem</code>的输入类型。在实现模块中，有三个功能目前被剔除，但将在以后实现。</p><p id="74b9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于<code class="fe mh mi mj mk b">Mutation</code>从一种类型变为一种结构，需要做两个小的改变。首先，我需要更新<code class="fe mh mi mj mk b">Schema</code>类型:</p><p id="3b2d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我还需要更新<code class="fe mh mi mj mk b">Schema</code>是如何在<code class="fe mh mi mj mk b">main</code>函数中被实例化的，如下所示:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="b154" class="mt kx iq mk b gy mu mv l mw mx">fn main() {<br/>  rocket::ignite()<br/>    .manage(DataContext::init().unwrap())<br/>    .manage(Schema::new(Query, Mutation))<br/>    .mount(<br/>      "/",<br/>      rocket::routes![graphiql, get_graphql_handler, post_graphql_handler],<br/>    )<br/>    .launch();<br/>}</span></pre><p id="43bd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在新的<code class="fe mh mi mj mk b">Mutation</code>会用<em class="ma"> Juniper </em>注册，但是它还什么都不做。然而，在我实现<code class="fe mh mi mj mk b">Mutation</code>中的函数之前，我必须做一些修改，以允许<code class="fe mh mi mj mk b">DataContext</code>在函数调用中是可变的。</p><h2 id="19a7" class="mt kx iq bd ky my mz dn lc na nb dp lg kj nc nd lk kn ne nf lo kr ng nh ls ni bi translated">可变上下文</h2><p id="d258" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">我在<code class="fe mh mi mj mk b">juniper::object</code>宏中实例化的<code class="fe mh mi mj mk b">Context</code>对象是不可变的。这是一个问题，因为这意味着上下文对象中的数据也是不可变的。我真正想做的是改变内部数据的状态，这意味着我需要线程安全的内部可变性。</p><p id="6f4f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了让上下文对象支持内部可变性，我需要将<code class="fe mh mi mj mk b">DataContext</code>的属性包装在<code class="fe mh mi mj mk b">Arc</code>和<code class="fe mh mi mj mk b">Mutex</code>中。在<em class="ma"> db.rs </em>中，我将<code class="fe mh mi mj mk b">DataContext</code>更新为:</p><figure class="ml mm mn mo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nm"><img src="../Images/8cec52c725f4ae3e2f73df75db8abe80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*BJJub9_azf5e-V7Q.png"/></div></div></figure><p id="6d7e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过添加那个<code class="fe mh mi mj mk b">Arc</code>和<code class="fe mh mi mj mk b">Mutex</code>包装器，我可以安全地在<code class="fe mh mi mj mk b">DataContext</code>中改变数据。然而，这确实破坏了<code class="fe mh mi mj mk b">Query</code>中的所有功能。为了解决这个问题，我需要更新<code class="fe mh mi mj mk b">clients</code>和<code class="fe mh mi mj mk b">get_client</code>查询来使用新版本的上下文对象。</p><p id="b284" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我将<code class="fe mh mi mj mk b">clients</code>更新为:</p><figure class="ml mm mn mo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oi"><img src="../Images/96b35b7e21669f0e1f285a21e1f9211d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*7NJo9ptB-Np9VIwN.png"/></div></div></figure><p id="0b0e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">和<code class="fe mh mi mj mk b">get_clients</code>到以下:</p><figure class="ml mm mn mo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi og"><img src="../Images/af8e442706bde5f71a229db3c75c84b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*UEqH7LCE07q6fuZY.png"/></div></div></figure><p id="640f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这将修复因更改<code class="fe mh mi mj mk b">DataContext</code>实现而导致的问题。</p><h2 id="fc44" class="mt kx iq bd ky my mz dn lc na nb dp lg kj nc nd lk kn ne nf lo kr ng nh ls ni bi translated">添加变异函数定义</h2><p id="b848" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">现在我可以实现<code class="fe mh mi mj mk b">Mutation</code>中的功能了。这是一个有点做作的例子，所以我不打算将更新写回文件，但是只要服务器是活动的，任何更改都将存在。此外，如果添加成功，每个变异将只返回对象的实例。</p><p id="1138" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于<code class="fe mh mi mj mk b">add_client</code>，我补充如下:</p><figure class="ml mm mn mo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nm"><img src="../Images/a09f2448f03a44737d10e3833e5b126d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*7c-qJhEAk56UHxwJ.png"/></div></div></figure><p id="9a5a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个没什么特别的。它创建一个GraphQL <code class="fe mh mi mj mk b">Client</code>类型的实例返回给调用者。它还创建了一个<code class="fe mh mi mj mk b">ClientModel</code>实例，并将其添加到<code class="fe mh mi mj mk b">DataContext</code>的<code class="fe mh mi mj mk b">clients</code>属性中。</p><p id="7c1f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于<code class="fe mh mi mj mk b">add_invoice</code>，还有更多的事情要做:</p><figure class="ml mm mn mo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oj"><img src="../Images/11a93393a9fc2a93da6b02764a6b4c0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*25qKUQAKGTOhoUK9.png"/></div></div></figure><p id="1d23" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个函数找到具有最大发票id的发票，并将其递增1以生成新的发票id和发票号。然后它使用<code class="fe mh mi mj mk b">chrono::Local::today</code>获取当前月份和年份来计算发票日期(当前月份的最后一天)和到期日(下个月的最后一天)。从那里看，和<code class="fe mh mi mj mk b">add_client</code>差不多。GraphQL <code class="fe mh mi mj mk b">Invoice</code>的实例被创建，并且<code class="fe mh mi mj mk b">InvoiceModel</code>的实例被添加到<code class="fe mh mi mj mk b">DataContext</code>的<code class="fe mh mi mj mk b">invoices</code>属性中。</p><p id="4104" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，<code class="fe mh mi mj mk b">add_invoice_item</code>:</p><figure class="ml mm mn mo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ok"><img src="../Images/15ccc34e3c1dd58487dd9023ccb02aaa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*drhu68I0EqCepXd7.png"/></div></div></figure><p id="f5d6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">像<code class="fe mh mi mj mk b">add_invoice</code>一样，<code class="fe mh mi mj mk b">add_invoice_item</code>找到最大的项目id，并递增它以获得新的项目id。然后创建GraphQL类型<code class="fe mh mi mj mk b">InvoiceItem</code>的一个实例，并将<code class="fe mh mi mj mk b">InvoiceItemModel</code>的一个实例添加到<code class="fe mh mi mj mk b">DataContext</code>的<code class="fe mh mi mj mk b">invoice_items</code>属性中。</p><h2 id="c0ee" class="mt kx iq bd ky my mz dn lc na nb dp lg kj nc nd lk kn ne nf lo kr ng nh ls ni bi translated">运行突变</h2><p id="10b8" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">定义了所有的突变方法后，我现在可以测试它们了。首先通过运行命令<code class="fe mh mi mj mk b">cargo run</code>启动服务器。然后，如果我想添加一个新的客户端，我将执行的变异可能如下所示:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="a87c" class="mt kx iq mk b gy mu mv l mw mx">mutation {<br/>  addClient(<br/>    newClient: {<br/>      clientId: "99-5344573"<br/>      companyName: "Herman-Treutel"<br/>      contactName: "Ario Drayson"<br/>      contactTitle: "Business Systems Development Analyst"<br/>      phone: "499-304-2835"<br/>     email: "wclaricoats0@ftc.gov"<br/> }) {<br/>    clientId<br/>    companyName<br/>    contactName<br/>    contactTitle<br/>    phone<br/>    email<br/>  }<br/>}</span></pre><p id="81da" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我会得到这样的回应:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="38c0" class="mt kx iq mk b gy mu mv l mw mx">{<br/>  "data": {<br/>    "addClient": {<br/>      "clientId": "99-5344573",<br/>      "companyName": "Herman-Treutel",<br/>      "contactName": "Ario Drayson",<br/>      "contactTitle": "Business Systems Development Analyst",<br/>      "phone": "499-304-2835",<br/>      "email": "wclaricoats0@ftc.gov"<br/>    }<br/>  }<br/>}</span></pre><p id="06e6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，我可以通过执行这种变异向新客户端添加发票:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="7d11" class="mt kx iq mk b gy mu mv l mw mx">mutation {<br/>  addInvoice(clientId: "99-5344573") {<br/>    invoiceId<br/>    invoiceNumber<br/>    invoiceDate<br/>    dueDate<br/>  }<br/>}</span></pre><p id="8ec5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这将返回以下内容:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="208a" class="mt kx iq mk b gy mu mv l mw mx">{<br/>  "data": {<br/>    "addInvoice": {<br/>      "invoiceId": 101001,<br/>      "invoiceNumber": "INV101001",<br/>      "invoiceDate": "2020-09-30",<br/>      "dueDate": "2020-10-31"<br/>    }<br/>  }<br/>}</span></pre><p id="1dab" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后添加一个发票项目，我可以运行<code class="fe mh mi mj mk b">add_invoice_item</code>突变:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="34c3" class="mt kx iq mk b gy mu mv l mw mx">mutation {<br/>  addInvoiceItem(<br/>    invoiceId: 101001<br/>    newInvoiceItem: {<br/>      productId: 2899<br/>      description: "exploit e-business supply-chains"<br/>      price: 4969.04<br/>    }<br/>  ) {<br/>    itemId<br/>    invoiceId<br/>    productId<br/>    description<br/>    price<br/>  }<br/>}</span></pre><p id="f67a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">答案会是:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="8cba" class="mt kx iq mk b gy mu mv l mw mx">{<br/>  "data": {<br/>    "addInvoiceItem": {<br/>      "itemId": 6001,<br/>      "invoiceId": 101001,<br/>      "productId": 2899,<br/>      "description": "exploit e-business supply-chains",<br/>      "price": 4969.04<br/>    }<br/>  }<br/>}</span></pre><h1 id="649b" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">回顾</h1><p id="faff" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">总的来说，<em class="ma"> Juniper </em>是一个设计良好的库，在Rust中提供GraphQL支持，我很喜欢使用它。集成是非常有益的，大多数类型都是结构良好的。我最喜欢的两个特性是<code class="fe mh mi mj mk b">juniper::object</code>属性和GraphQL类型宏。</p><p id="33fc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有一件事我很想看到这个库——一个新的版本。自2019年12月以来，一直没有版本发布。从那以后，repo有了一些变化，比如对async/await语法和GraphQL订阅的支持。希望很快会有新的版本发布。</p><p id="1725" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所有代码都可以在<a class="ae lz" href="https://github.com/andrewleverette/rust_graphql_example" rel="noopener ugc nofollow" target="_blank">这里</a>获得。</p><h1 id="6d0c" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">谢谢</h1><p id="b998" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">感谢阅读！如果你想联系或想提供反馈，请随时通过LinkedIn 联系我。</p></div><div class="ab cl ol om hu on" role="separator"><span class="oo bw bk op oq or"/><span class="oo bw bk op oq or"/><span class="oo bw bk op oq"/></div><div class="ij ik il im in"><figure class="ml mm mn mo gt jr gh gi paragraph-image"><div class="gh gi os"><img src="../Images/2683b9f8b8766fdf390a456bcd63ab22.png" data-original-src="https://miro.medium.com/v2/resize:fit:970/format:webp/1*3N6R_9KQPVOHCiYG66Iytg.png"/></div></figure><p id="9c77" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="ma">原载于2020年10月1日</em><a class="ae lz" href="https://andrewleverette.github.io/graphql-and-rust/" rel="noopener ugc nofollow" target="_blank"><em class="ma">https://andrewleverette . github . io</em></a><em class="ma">。</em></p></div></div>    
</body>
</html>