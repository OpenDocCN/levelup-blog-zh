<html>
<head>
<title>The Hidden Unsafe Features of C#</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C#隐藏的不安全特性</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/the-hidden-unsafe-features-of-c-63895400800a?source=collection_archive---------1-----------------------#2020-03-10">https://levelup.gitconnected.com/the-hidden-unsafe-features-of-c-63895400800a?source=collection_archive---------1-----------------------#2020-03-10</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="384e" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">使用指针、破坏类型安全以及非托管世界中的各种乐趣</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/d651519bc4a4ff9ffbffcc9100db5945.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hMzXVnPwPLaDwcVT"/></div></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated">迪安·普在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="1c1b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在过去的几年里，C#已经成为现代软件开发的主流语言之一。在<a class="ae kz" href="https://insights.stackoverflow.com/survey/2019#technology" rel="noopener ugc nofollow" target="_blank"> Stack Overflow的2019年开发者调查</a>中，它在业余爱好者和专业程序员中排名第七。</p><p id="7e30" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">随着ASP.NET核心和实体框架等突出技术在。NET生态系统中，这种语言已经稍微转向了web和云本地开发。结合持续不断的对运行时的改进，C#已经牢固地确立了自己作为一种可靠的主流语言的地位，几乎可以用来编写任何应用程序。</p><p id="01fe" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">你几乎会忘记，就在几年前，C#主要用于编写桌面或工作站应用程序，它与Windows平台紧密耦合，并且必须与其许多遗留的Win32组件互操作。</p><p id="5098" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">正因为如此，C#语言包含了一些大多数开发人员不再日常使用的构造，但是仍然非常强大。例如，你知道C#支持<em class="lw">指针</em>吗？你知道你可以破坏类型安全吗？</p><p id="efd9" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在本文中，我们将深入探讨C#和。NET运行时。我们将做一些有趣的、不稳定的事情，比如破坏类型安全、处理指针、使用封送拆收器和不安全的强制转换将对象直接转换成字节数组。</p><p id="4a6f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">值得注意的是，本文中解释的一些概念需要一些C#知识，一些概念的背景知识(如垃圾收集、托管运行时)可能会有用。</p><h1 id="f6e2" class="lx ly iu bd lz ma mb mc md me mf mg mh ka mi kb mj kd mk ke ml kg mm kh mn mo bi translated">托管和非托管</h1><p id="bfd8" class="pw-post-body-paragraph la lb iu lc b ld mp jv lf lg mq jy li lj mr ll lm ln ms lp lq lr mt lt lu lv in bi translated">在我们深入研究这些特性之前，理解<em class="lw">托管</em>和<em class="lw">非托管</em>代码的概念是很重要的。根据定义，托管代码是作为公共语言运行时(CLR)的一部分运行的代码。CLR为我们管理很多事情，比如垃圾收集、异常处理、内存管理等等。</p><p id="9312" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">托管代码是在CLR的“虚拟机”边界内运行的任何代码。这是一个有围墙的花园，里面一切都很整洁。东西一般不会坏，但一旦坏了，就优雅地坏了。这与可怕的、<em class="lw">非托管的</em>世界形成了鲜明的对比，在这个世界中，指针可能摇摆不定，异常可能无法处理，内存可能开始泄漏。</p><p id="a8dc" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">每当我们写C#代码时，我们通常都呆在这个有围墙的花园里。我们不必为任何细节而烦恼，比如内存管理和清理我们身后的资源。我们已经处理好了。</p><p id="9e7c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">然而，如前所述，因为C#传统上必须与操作系统内的遗留的、非托管的组件进行交互，所以它确实提供了离开这个围墙花园的选项，并与外部世界进行交互。支持这一点的编译器标志被恰当地命名为<code class="fe mu mv mw mx b">/unsafe</code>。</p><p id="265b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">本文中几乎所有的代码都只能使用<code class="fe mu mv mw mx b">/unsafe</code>编译器标志进行编译。今天我们将走出CLR的界限。</p><h1 id="c723" class="lx ly iu bd lz ma mb mc md me mf mg mh ka mi kb mj kd mk ke ml kg mm kh mn mo bi translated">有指针</h1><p id="7b70" class="pw-post-body-paragraph la lb iu lc b ld mp jv lf lg mq jy li lj mr ll lm ln ms lp lq lr mt lt lu lv in bi translated">正如简介中提到的，<a class="ae kz" href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/unsafe-code-pointers/pointer-types" rel="noopener ugc nofollow" target="_blank"> C#完全支持指针</a>。您可以获取指向任何非托管类型(如基元类型)以及大多数不包含引用类型的结构的指针。</p><p id="54ac" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这意味着下面这段代码完全有效:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="my mz l"/></div></figure><p id="271d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">让我们一步一步来。我们首先像平常一样创建一个新的<code class="fe mu mv mw mx b">Vector3</code>，通过引用将其传递给<code class="fe mu mv mw mx b">Foo</code>，然后它对其成员进行一些添加，并写入控制台。</p><p id="d22c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">为了让C#能够获得指向一个对象的指针，它需要通过引用来传递。在上面的例子中，这是通过<code class="fe mu mv mw mx b">ref Vector3 vec</code>声明完成的。如果那个<code class="fe mu mv mw mx b">ref</code>不在那里，它将简单地通过值传递。</p><p id="cd8a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe mu mv mw mx b">fixed</code>语句是C#中很少使用的语句，它防止垃圾收集器重新定位变量，例如在垃圾收集器的压缩阶段。当我们获得一个指向向量的指针时，我们希望确保垃圾收集器在我们使用向量时不会改变它的位置——否则我们可能会冒着读取垃圾的风险。</p><p id="b7f3" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">当操作指针类型时，C#支持C风格的箭头符号<code class="fe mu mv mw mx b">-&gt;</code>去引用和访问指针的成员。然后，您可以像平常一样使用或修改对象的成员。</p><h2 id="0500" class="na ly iu bd lz nb nc dn md nd ne dp mh lj nf ng mj ln nh ni ml lr nj nk mn nl bi translated">这个什么时候有用？</h2><p id="87e2" class="pw-post-body-paragraph la lb iu lc b ld mp jv lf lg mq jy li lj mr ll lm ln ms lp lq lr mt lt lu lv in bi translated">在C#中，指针有很多用处，尽管由于固定对象和缓冲区的内在要求，它并不总是像C/C++中的指针那样高效。</p><p id="3a0a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">使用指针实际上有用的一个例子是与<code class="fe mu mv mw mx b">Marshal</code>结合使用。封送处理充当托管和非托管领域之间的看门人，有一系列非常有用的方法用于将托管类型转换为非托管类型、分配内存等。</p><p id="bc10" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">假设我们想在一个非托管应用程序中使用我们之前创建的<code class="fe mu mv mw mx b">Vector3</code>实例。我们需要某种方法将托管向量转换成非托管表示。JSON等流行的序列化技术是一种选择，但是我们也可以简单地使用<code class="fe mu mv mw mx b">Marshal</code>来创建一个表示我们的向量的字节数组:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="my mz l"/></div></figure><p id="b74d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">封送器本质上做的是获取我们的托管vector实例，并将其序列化为非托管的<code class="fe mu mv mw mx b">byte[]</code>。这相对较快，并且允许通过例如网络连接发送原始形式的矢量。</p><p id="90d2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">虽然这是一种将托管类型转换为非托管字节数组的非常有效且相对快速的方法，但也有一些限制。首先，封送处理要求它处理的每个类型都是<a class="ae kz" href="https://en.wikipedia.org/wiki/Blittable_types" rel="noopener ugc nofollow" target="_blank">可直接复制到本机结构中的</a>。这意味着该类型在托管和非托管环境中具有相同的字节表示形式。大多数原始类型都是可直接复制到本机结构中的，但是字符串和几乎所有复杂类型都不是。</p><p id="dcb6" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这严重限制了封送处理的用途，并使JSON等常见的序列化技术在大多数用例中更加可行。但是对于那些只传输原语的情况，它可以非常快。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj nm"><img src="../Images/040626cba678e3b145891ea8bbbef2f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NNPQPot33xgrSK0g"/></div></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated">照片由<a class="ae kz" href="https://unsplash.com/@arielbeagar?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Ariel Besagar </a>在<a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="ef00" class="lx ly iu bd lz ma mb mc md me mf mg mh ka mi kb mj kd mk ke ml kg mm kh mn mo bi translated">堆栈分配</h1><p id="598b" class="pw-post-body-paragraph la lb iu lc b ld mp jv lf lg mq jy li lj mr ll lm ln ms lp lq lr mt lt lu lv in bi translated">另一个很少使用的特性是<code class="fe mu mv mw mx b">stackalloc</code>操作符。顾名思义，<code class="fe mu mv mw mx b">stackalloc</code>在堆栈上分配一块内存。当方法返回时，该块被自动丢弃，并且不能被显式释放。</p><p id="c55b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">与常规的内存分配不同，堆栈分配的内存块不受垃圾收集的影响，出于同样的原因，它们不需要使用我们在上一节中讨论的<code class="fe mu mv mw mx b">fixed</code>关键字来固定。</p><p id="4e32" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果我们看一下上一节中的例子，在这个例子中，我们将<code class="fe mu mv mw mx b">Vector3</code>转换成一个字节数组，我们用<code class="fe mu mv mw mx b">new byte[]</code>初始化这个字节数组——它在堆上分配这个字节数组。</p><p id="2e10" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">因为我们提前知道我们的向量不会特别大，我们可以通过使用<code class="fe mu mv mw mx b">stackalloc</code>在堆栈上分配我们的缓冲区来放弃这种分配:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="my mz l"/></div></figure><p id="dcfe" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">通过在堆栈上直接分配向量所需的12个字节，这为我们节省了堆分配。与堆分配相比，堆栈分配在性能方面要便宜得多。</p><p id="0bbb" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">对于眼尖的人来说，由于对<code class="fe mu mv mw mx b">buffer.ToArray();</code>的调用，堆栈分配的缓冲区仍然被分配在堆上，这使得一开始就在堆栈上分配缓冲区变得毫无意义。理想情况下，您不会将缓冲区返回给调用者。相反，它将在方法本身中被消耗。</p><h2 id="7700" class="na ly iu bd lz nb nc dn md nd ne dp mh lj nf ng mj ln nh ni ml lr nj nk mn nl bi translated">这个什么时候有用？</h2><p id="117d" class="pw-post-body-paragraph la lb iu lc b ld mp jv lf lg mq jy li lj mr ll lm ln ms lp lq lr mt lt lu lv in bi translated">虽然堆栈分配比堆分配便宜得多，但在大多数应用程序中，它们通常不是您应该关心的事情。许多应用程序在运行时执行大量的堆分配，在大多数情况下，垃圾收集器可以很好地处理它。</p><p id="1366" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">当你分配大量相对较小的缓冲区时，使用<code class="fe mu mv mw mx b">stackalloc</code>会大放异彩——例如当你处理底层网络代码时。在这种情况下，使用堆栈分配的缓冲区可以大大减少垃圾收集器的压力，因为它可以避免无数次生命周期非常短的小分配。</p><p id="2e34" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">值得注意的是，从C# 7.2开始，<code class="fe mu mv mw mx b">Span&lt;T&gt;</code> <code class="fe mu mv mw mx b">Memory&lt;T&gt;</code>和<code class="fe mu mv mw mx b">ReadOnlySpan&lt;T&gt;</code>类型使得访问连续内存块变得更加容易，并且它们是访问内存块的首选方法。</p><p id="c109" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">更多信息参见<a class="ae kz" href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/stackalloc" rel="noopener ugc nofollow" target="_blank"/><code class="fe mu mv mw mx b"><a class="ae kz" href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/stackalloc" rel="noopener ugc nofollow" target="_blank">stackalloc</a></code><a class="ae kz" href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/stackalloc" rel="noopener ugc nofollow" target="_blank">操作员文档</a>。</p><h1 id="5a85" class="lx ly iu bd lz ma mb mc md me mf mg mh ka mi kb mj kd mk ke ml kg mm kh mn mo bi translated">不安全的类型</h1><p id="65cb" class="pw-post-body-paragraph la lb iu lc b ld mp jv lf lg mq jy li lj mr ll lm ln ms lp lq lr mt lt lu lv in bi translated">当操作指针时，我们可以更进一步。像C++这样的语言允许我们使用<code class="fe mu mv mw mx b">reinterpret_cast&lt;T&gt;</code>将指针转换成任何类型，但在C#中，我们受到语言类型安全的限制。</p><p id="ee97" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">然而，这种限制在C#编译成的中间语言(简称IL)中并不存在。例如，在IL中，将指针转换为类型可以表示为:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="my mz l"/></div></figure><p id="1e7d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这实际上是将<code class="fe mu mv mw mx b">source</code>指针表示为<code class="fe mu mv mw mx b">!!T</code>——本质上相当于C++中的<code class="fe mu mv mw mx b">reinterpret_cast&lt;T&gt;</code>。这开启了一个全新的可能性领域。</p><p id="c632" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">本节中的代码使用了<code class="fe mu mv mw mx b">CompilerServices.Unsafe</code>包，它可以从NuGet获得，并且主要在IL中实现。使用<code class="fe mu mv mw mx b">Unsafe</code>类型，我们可以用少得多的代码将向量与缓冲区相互转换:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="my mz l"/></div></figure><p id="a9f6" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">但是这样做的话，我们无法保证我们所做的造型是有效的。然而，与我们之前讨论的<code class="fe mu mv mw mx b">Marshal</code>相比，这种方法要快得多，因为它放弃了通常需要的所有类型检查。</p><p id="1d4c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">为了进行演示，请考虑如果我们执行以下代码会发生什么:</p><pre class="kk kl km kn gu nn mx no np aw nq bi"><span id="a5ad" class="na ly iu mx b gz nr ns l nt nu">int a = 1;</span><span id="cdb0" class="na ly iu mx b gz nv ns l nt nu">bool b = (bool) a;</span></pre><p id="0efb" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">那不会编译，对吧？尽管在内存中，<code class="fe mu mv mw mx b">bool</code>被表示为1或0，但在C#中，我们不能在没有编译器错误的情况下将<code class="fe mu mv mw mx b">int</code>转换为<code class="fe mu mv mw mx b">bool</code>，因为这会破坏类型安全。</p><p id="ad0c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">然而，我们可以用<code class="fe mu mv mw mx b">Unsafe</code>:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="my mz l"/></div></figure><p id="ee2b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">执行时，上面的代码会编译，它会输出<code class="fe mu mv mw mx b">False</code>。</p><h2 id="b1f3" class="na ly iu bd lz nb nc dn md nd ne dp mh lj nf ng mj ln nh ni ml lr nj nk mn nl bi translated">这个什么时候有用？</h2><p id="3133" class="pw-post-body-paragraph la lb iu lc b ld mp jv lf lg mq jy li lj mr ll lm ln ms lp lq lr mt lt lu lv in bi translated">当您需要读写非托管缓冲区时，性能是您关心的唯一最重要的指标。您必须自己考虑运行时通常为您提供的所有类型安全，但是如果操作正确，这可能会产生一些非常好的优化代码。</p><p id="6181" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">它也比通过前面几节中概述的封送处理运行基元类型快得多。</p><h1 id="6f11" class="lx ly iu bd lz ma mb mc md me mf mg mh ka mi kb mj kd mk ke ml kg mm kh mn mo bi translated">结论</h1><p id="0dae" class="pw-post-body-paragraph la lb iu lc b ld mp jv lf lg mq jy li lj mr ll lm ln ms lp lq lr mt lt lu lv in bi translated">当您指定了<code class="fe mu mv mw mx b">/unsafe</code>编译器标志时，您获得了很大的权力。直接使用指针、堆栈分配和固定对象的能力为优化开辟了一个全新的领域。</p><p id="61f8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">然而，这就是C#世界中众所周知的龙<em class="lw">所在的地方。诚然，它们是相对温顺的龙，但你仍然可以用你通常不会用的方式搬起石头砸自己的脚。</em></p><p id="40e0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">就我个人而言，我曾广泛使用C#中的非托管资源，我看到代码的执行方式没有一点点<code class="fe mu mv mw mx b">unsafe</code>魔力是不可能的。虽然类型系统通常是一个很好的安全网，但是在非常特殊的情况下能够避开它是一个非常强大的选择。在我看来，这是每个C#程序员都应该知道的一个选项。</p><p id="988c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我希望这篇文章对你有帮助，如果你有任何问题或者喜欢这类内容，请告诉我。这篇文章只是我们的尝试，如果有足够的兴趣，还有很多很多东西可以写。</p><p id="b272" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">感谢您的阅读！</p></div></div>    
</body>
</html>