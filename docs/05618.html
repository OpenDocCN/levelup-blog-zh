<html>
<head>
<title>Your own Component-based Library</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">您自己的基于组件的库</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/your-own-component-based-jlibrary-fe67cb5cf771?source=collection_archive---------19-----------------------#2020-09-14">https://levelup.gitconnected.com/your-own-component-based-jlibrary-fe67cb5cf771?source=collection_archive---------19-----------------------#2020-09-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="783a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">从头开始构建一个基本的JavaScript库</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c44defda14196183e0eb26a4c616b2cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bwq2DZgDEedqDGAxZM8I1Q.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">苏珊·尹在<a class="ae ky" href="https://unsplash.com/s/photos/library?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="1040" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">React和Angular除了是两个最大的前端web开发框架/库之外，还有什么共同之处？</p><p id="8f41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">它们都是基于组件的！</em></p><p id="1382" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将创建一个简单的前端库，它使用了一些组件和优秀的普通JavaScript。这可以帮助我们更好地理解组件，也提高了我们使用普通JavaScript的技能。</p><h2 id="cb8a" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated"><strong class="ak">先决条件</strong></h2><p id="30e6" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">在深入本文的JavaScript部分之前，我们需要设置我们的项目结构。为此，我们创建了一个名为<em class="lv">组件库</em>的新文件夹以及一些子文件夹和文件:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="1803" class="lw lx it mv b gy mz na l nb nc">$ mkdir component-library<br/>$ cd ./component-library<br/>$ mkdir lib style components<br/>$ touch index.html index.js ./style/styles.css</span></pre><p id="f329" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们需要像这样填写我们的HTML和CSS文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">index.html</figcaption></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">样式. css</figcaption></figure><p id="0f0e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们已经设置好了，准备写一些JavaScript。</p><h2 id="e19c" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">名为埃斯泽特的图书馆</h2><p id="ff14" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">我喜欢从假装图书馆已经存在开始。因此，我们首先需要关注的是<em class="lv"> index.js. </em></p><p id="7e48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在文件的最顶端，我们需要导入我们的库，然后实例化一个新的应用程序:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="0fa6" class="lw lx it mv b gy mz na l nb nc">// All our imports are here<br/>import ß from ‘./lib/Eszett.js’;</span><span id="54c9" class="lw lx it mv b gy nf na l nb nc">// Initialize app<br/>const app = new ß('app');</span></pre><p id="895c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这段代码将抛出一个错误，因为我们没有从我们的<em class="lv"> Eszett.js </em>中导出任何东西。在这个文件中，我们需要一个名为<strong class="lb iu">的类和一个构造函数，该构造函数将一个<strong class="lb iu">选择器</strong>作为字符串接收并导出它。所以首先我们需要创建一个这样的文件:</strong></p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="7ea6" class="lw lx it mv b gy mz na l nb nc">$ touch ./lib/Eszett.js</span></pre><p id="5f80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该文件的内容应该如下所示:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="739f" class="lw lx it mv b gy mz na l nb nc">class ß {<br/>  constructor(selector) {<br/>    this.eszettElement = document.querySelector(`#${selector}`);<br/>    console.log(‘Eszett initialized!’);<br/>  }<br/>}<br/>export default ß;</span></pre><p id="b5b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您现在运行您的应用程序，我们将不会再收到错误，文本“Eszett initialized”将出现在您的浏览器控制台中。但到目前为止，我们并没有在代码中做那么多。让我们通过实现在应用程序中注册组件的可能性来改变这一点。</p><h2 id="d2d5" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">成分</h2><p id="6c67" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">为此，我们需要实现两件事:</p><ul class=""><li id="89b9" class="ng nh it lb b lc ld lf lg li ni lm nj lq nk lu nl nm nn no bi translated">存储所有注册组件的字段</li><li id="cde6" class="ng nh it lb b lc np lf nq li nr lm ns lq nt lu nl nm nn no bi translated">一个<em class="lv">注册组件</em>方法</li></ul><p id="7ee3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们在构造函数中的<em class="lv"> console.log </em>的正上方添加下面一行代码:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="b090" class="lw lx it mv b gy mz na l nb nc">this.components = {};</span></pre><p id="cb11" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">计划是将该字段中的所有组件注册为键值对。为此，我们需要在构造函数下添加以下方法:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="711f" class="lw lx it mv b gy mz na l nb nc">registerComponent(component {<br/>  this.components[component.name] = component;<br/>}</span></pre><p id="413a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们可以在应用程序中注册组件了。注册将在我们应用程序初始化下面的<em class="lv"> index.js </em>中进行。我们的第一个组件将是一个<strong class="lb iu">菜单组件</strong>。这将是一个两步的过程，首先，我们导入组件，然后我们在应用程序初始化后注册它。</p><p id="cc71" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样做之后，我们的index.js应该是这样的:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="f3a7" class="lw lx it mv b gy mz na l nb nc">// All our imports are here<br/>import ß from ‘./lib/Eszett.js’;<br/>import MenuComponent from ‘./components/MenuComponent.js’;</span><span id="3af9" class="lw lx it mv b gy nf na l nb nc">// Initialize app<br/>const app = new ß(‘app’);</span><span id="c21f" class="lw lx it mv b gy nf na l nb nc">// Adding our Components to the App<br/>app.registerComponent(MenuComponent)</span></pre><p id="3281" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此时，我们的应用程序将抛出一个错误，因为我们还没有<strong class="lb iu"> MenuComponent </strong>，现在我们继续通过添加一个新文件来创建它，如下所示:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="f493" class="lw lx it mv b gy mz na l nb nc">$ touch ./components/MenuComponent.js</span></pre><p id="cb51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个文件中，我们将导入尚不存在的<em class="lv"> Component.js </em>，这样我们就可以创建一个新组件。之后，我们需要一个<em class="lv"> HTML模板</em>，最后但并非最不重要的是组件本身。它应该是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">菜单组件. js</figcaption></figure><p id="648c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们先仔细看看<em class="lv"> HTML模板</em>。它是一个函数，返回一个<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals" rel="noopener ugc nofollow" target="_blank">模板文字</a>(模板字符串)，并获取作为参数传入的组件状态。在第8行中，我们看到这个状态被用来动态呈现博客的名称。</p><p id="60fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看一下组件本身，我们看到它有三个参数。第一个参数是组件本身的名称，第二个参数是一个只有一个名为name的属性的对象。这是我们传递给<em class="lv"> menuTemplate </em>的状态对象，也是我们的最后一个参数。</p><p id="570c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了让所有这些工作，我们需要实现我们的<em class="lv"> component.js </em>。首先，我们需要创建一个这样的文件:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="a607" class="lw lx it mv b gy mz na l nb nc">$ touch ./lib/Component.js</span></pre><p id="8ec9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们组件的实现非常简单。我们需要一个接受三个参数的构造函数，我们需要一个调用我们的<em class="lv"> HTML-Template-Function </em>并返回结果的函数。最后应该是这样的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">组件. js</figcaption></figure><p id="2123" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们的页面不会显示任何错误，但也不会显示我们的<strong class="lb iu"> MenuComponent </strong>。</p><h2 id="b18a" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">翻译</h2><p id="1f95" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">我们可以创建一个组件，并在我们的应用程序中注册它，但我们不能显示组件的HTML。在我们处理这个问题之前，我想给我们的应用程序添加一个<strong class="lb iu"> PostsComponent </strong>，这样我们就可以同时呈现两个组件。</p><p id="fda8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，我们需要这样注册它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">索引. js</figcaption></figure><p id="c494" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建它:</p><pre class="kj kk kl km gt mu mv mw mx aw my bi"><span id="6c36" class="lw lx it mv b gy mz na l nb nc">$ touch ./components/PostsComponent.js</span></pre><p id="57b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并像这样实现它:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">PostsComponent.js</figcaption></figure><p id="3dd6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了进行渲染，我们需要通过调用组件的<em class="lv">视图</em>方法<em class="lv"> </em>来更新<a class="ae ky" href="https://en.wikipedia.org/wiki/Document_Object_Model" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> DOM </strong> </a>，并将返回的HTML插入到已经定义的<em class="lv"> eszettElement </em>中。所描述的行为应该是我们的<em class="lv">类</em>类<em class="lv">类</em>的一个方法，并在我们的<em class="lv"> registerComponent </em>方法内部被调用。这是我们类的最终实现:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nd ne l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">Eszett.js</figcaption></figure><p id="ee82" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv"> updateView </em>方法首先检查是否有任何组件被注册。如果是这种情况，它将遍历所有组件，并调用每个组件的<em class="lv">视图</em>方法。返回的HTML将被合并并设置为<em class="lv"> eszettElement </em>的<em class="lv"> innerHTML </em>。如果一切顺利，你的最终页面应该是这样的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/410aa3c8143143345d9ac144a25d6cd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1398/format:webp/1*U6qBPrsG4zNIKBEFSd95Qg.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">最终博客页面</figcaption></figure><h2 id="24ae" class="lw lx it bd ly lz ma dn mb mc md dp me li mf mg mh lm mi mj mk lq ml mm mn mo bi translated">下一步会是什么？</h2><p id="04a8" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">我们刚刚创建了名为<strong class="lb iu"> Eszett </strong>的小型库。我们可以创建包含独立状态和自己的HTML模板的组件。这些组件可以在应用程序级别注册和呈现。</p><p id="6b09" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还可以添加一些功能。例如，路由器显示某些路由上的某些组件，或者将一个组件嵌套在另一个组件中并传递状态的可能性。</p><p id="a5bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">只需尝试添加新特性来提高您的JavaScript技能，并从中获得乐趣！</p><p id="eb45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像往常一样，你可以在我的GitHub上找到这个项目的代码。</p></div><div class="ab cl nv nw hx nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="im in io ip iq"><h1 id="542f" class="oc lx it bd ly od oe of mb og oh oi me jz oj ka mh kc ok kd mk kf ol kg mn om bi translated">分级编码</h1><p id="659c" class="pw-post-body-paragraph kz la it lb b lc mp ju le lf mq jx lh li mr lk ll lm ms lo lp lq mt ls lt lu im bi translated">感谢您成为我们社区的一员！<a class="ae ky" href="https://www.youtube.com/channel/UC3v9kBR_ab4UHXXdknz8Fbg?sub_confirmation=1" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">订阅我们的YouTube频道</strong> </a>或者加入<a class="ae ky" href="https://skilled.dev/" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> Skilled.dev编码面试课程</strong> </a>。</p><div class="on oo gp gr op oq"><a href="https://skilled.dev" rel="noopener  ugc nofollow" target="_blank"><div class="or ab fo"><div class="os ab ot cl cj ou"><h2 class="bd iu gy z fp ov fr fs ow fu fw is bi translated">编写面试问题</h2><div class="ox l"><h3 class="bd b gy z fp ov fr fs ow fu fw dk translated">掌握编码面试的过程</h3></div><div class="oy l"><p class="bd b dl z fp ov fr fs ow fu fw dk translated">技术开发</p></div></div><div class="oz l"><div class="pa l pb pc pd oz pe ks oq"/></div></div></a></div></div></div>    
</body>
</html>