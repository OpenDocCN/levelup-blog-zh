<html>
<head>
<title>Ways to Write Better JavaScript — Use TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编写更好的JavaScript的方法—使用TypeScript</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/ways-to-write-better-javascript-use-typescript-40f89193771a?source=collection_archive---------16-----------------------#2020-05-19">https://levelup.gitconnected.com/ways-to-write-better-javascript-use-typescript-40f89193771a?source=collection_archive---------16-----------------------#2020-05-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/014718655f560bd6ade35f2f2e1c712e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VquUspccl-f0L11o"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">Erik Lucatero 在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="0d17" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们编写JavaScript的方式总是可以改进的。随着语言的发展和更方便的特性的增加，我们也可以通过使用有用的新特性来改进。</p><p id="0a4f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将研究一些使用TypeScript编写更好的JavaScript的方法。</p><h1 id="82ea" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">使用类型脚本</h1><p id="d622" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">TypeScript是JavaScript的自然扩展。它让我们编写类型安全的JavaScript代码。因此，我们可以使用它来防止大量的数据类型错误，如果我们不使用TypeScript，这些错误就会发生。</p><p id="6aa3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，它还提供了自动完成功能，否则就不像许多库那样具有自动完成功能。他们使用TypeScript类型定义为文本编辑器和ide提供自动完成功能，使我们的生活变得更加轻松。</p><p id="bd82" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">TypeScript并没有把JavaScript变成一种不同的语言。它所做的就是通过各种类型检查特性给JavaScript添加类型检查。</p><p id="33bc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，所有用于JavaScript的知识都适用于TypeScript。</p><p id="541d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以创建一个带有类型注释的函数，如下所示:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="007a" class="mq lf it mm b gy mr ms l mt mu">const foo = (num: number): number =&gt; {<br/>  return num + 1;<br/>}</span></pre><p id="0ff3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们有一个带有被设置为类型<code class="fe mv mw mx mm b">number</code>的<code class="fe mv mw mx mm b">num</code>参数的<code class="fe mv mw mx mm b">foo</code>函数。我们还通过在<code class="fe mv mw mx mm b">:</code>后指定类型，将返回类型设置为<code class="fe mv mw mx mm b">number</code>。</p><p id="adcc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后如果我们用数字调用函数，TypeScript编译器会接受代码。</p><p id="3010" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">否则，它会拒绝代码，不会构建代码。这很好，因为JavaScript不会阻止这种情况发生。</p><h1 id="5cda" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">接口</h1><p id="0533" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">TypeScript为我们提供了接口，这样我们就可以知道对象的结构，而无需记录对象或检查值。</p><p id="92e8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以创建一个，如下所示:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="84d1" class="mq lf it mm b gy mr ms l mt mu">interface Person {<br/>    name: string;<br/>    age: number;<br/>}</span></pre><p id="fd83" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么我们可以如下使用它:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="7929" class="mq lf it mm b gy mr ms l mt mu">const person: Person = { name: 'jane', age: 10 }</span></pre><p id="c5b8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们错过了这些属性中的任何一个，那么当TypeScript编译器正在寻找它们时，我们将得到一个错误。</p><p id="36f2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还可以使用它来强制实现一个类，如下所示:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="6d11" class="mq lf it mm b gy mr ms l mt mu">interface PersonInterface {<br/>    name: string;<br/>    age: number;<br/>}</span><span id="c79f" class="mq lf it mm b gy my ms l mt mu">class Person implements PersonInterface {<br/>    name: string;<br/>    age: number;<br/>    constructor(name: string, age: number) {<br/>        this.name = name;<br/>        this.age = age;<br/>    }<br/>}</span></pre><p id="17b0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们有<code class="fe mv mw mx mm b">name</code>和<code class="fe mv mw mx mm b">age</code>字段。如果我们跳过其中的任何一个，那么我们将从TypeScript编译器得到一个错误。</p><p id="606c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们想接受JavaScript的动态类型特性，我们可以在JavaScript中添加动态索引签名。此外，还有联合和交集类型，可以将不同的类型组合成一个类型。</p><p id="b288" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以如下使用它:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="65f3" class="mq lf it mm b gy mr ms l mt mu">interface PersonInterface {<br/>    name: string;<br/>    age: number;<br/>    [key: string]: any;<br/>}</span></pre><p id="bed1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们有:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="4480" class="mq lf it mm b gy mr ms l mt mu">[key: string]: any;</span></pre><p id="c70c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">允许在任何实现有值的<code class="fe mv mw mx mm b">PersonInterface</code>的东西中使用动态键。</p><p id="6109" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们可以在任何实现了<code class="fe mv mw mx mm b">PersonInterface</code>的类中拥有除了<code class="fe mv mw mx mm b">name</code>和<code class="fe mv mw mx mm b">age</code>之外的任何属性，或者拥有一个被转换为<code class="fe mv mw mx mm b">PersonInterface</code>类型的对象。</p><p id="e553" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">联合类型让我们将不同的类型连接在一起。例如，我们可以如下使用它:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="4418" class="mq lf it mm b gy mr ms l mt mu">interface Person {<br/>    name: string;<br/>    age: number;    <br/>}</span><span id="8230" class="mq lf it mm b gy my ms l mt mu">interface Employee {<br/>    employeeId: string;<br/>}</span><span id="b002" class="mq lf it mm b gy my ms l mt mu">const staff: Person | Employee = {<br/>    name: 'jane',<br/>    age: 10,<br/>    employeeId: 'abc'<br/>}</span></pre><p id="abc6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，<code class="fe mv mw mx mm b">|</code>是联合类型的操作符。它允许我们将两个接口中的两个键合并成一个，而无需创建新的类型。</p><p id="64f4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">TypeScript的另一个优点是可空属性。我们可以用<code class="fe mv mw mx mm b">?</code>操作符使属性可选。</p><p id="694f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以使用下面的代码:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="a3e4" class="mq lf it mm b gy mr ms l mt mu">interface Person {<br/>    name: string;<br/>    age?: number;    <br/>}</span></pre><p id="7606" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用<code class="fe mv mw mx mm b">?</code>操作符，我们将<code class="fe mv mw mx mm b">age</code>设置为可选属性。</p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/f865cfb11142e1c557e6b8fd1f61425a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*88ibC0NlhX7guXMf"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@sebastian123?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Pereanu Sebastian </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="716c" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">运算符的类型</h1><p id="9a1c" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">TypeScript的另一个很棒的特性是<code class="fe mv mw mx mm b">typeof</code>操作符，它让我们可以指定某个东西与另一个东西具有相同的类型。</p><p id="4955" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以如下使用它:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="516b" class="mq lf it mm b gy mr ms l mt mu">const person = {<br/>    name: 'jane',<br/>    age: 10,<br/>}</span><span id="9308" class="mq lf it mm b gy my ms l mt mu">const person2: typeof person = {<br/>    name: 'john',<br/>    age: 11,<br/>}</span></pre><p id="3fa8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们有<code class="fe mv mw mx mm b">person2</code>对象，它与<code class="fe mv mw mx mm b">person</code>具有相同的类型，因为我们用<code class="fe mv mw mx mm b">typeof person</code>指定了它。那么<code class="fe mv mw mx mm b">person2</code>必须有<code class="fe mv mw mx mm b">name </code>和<code class="fe mv mw mx mm b">age </code>属性，否则我们会得到一个错误。</p><p id="043b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我们所看到的，我们不需要明确地指定任何接口或类来指定类型。这对于获取没有类型定义的导入库的类型很方便。</p><h1 id="35a1" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="0300" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">有了TypeScript，我们使重构变得容易，因为用它提供的类型和结构检查来破坏现有代码变得更加困难。</p><p id="3dcc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这也使得交流更加容易，因为我们知道我们的对象、类和函数返回值的类型和结构。</p></div></div>    
</body>
</html>