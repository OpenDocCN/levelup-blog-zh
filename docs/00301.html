<html>
<head>
<title>What Are The Differences Between Promises, Observables, and Streams?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">承诺、可观察和流之间有什么区别？</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/promise-vs-observable-vs-stream-165a310e886f?source=collection_archive---------2-----------------------#2018-12-26">https://levelup.gitconnected.com/promise-vs-observable-vs-stream-165a310e886f?source=collection_archive---------2-----------------------#2018-12-26</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><h2 id="4f16" class="is it iu bd b dl iv iw ix iy iz ja dk jb translated" aria-label="kicker paragraph"><a class="ae ep" href="https://rakiabensassi.medium.com/list/software-engineering-7a179a23ebfd" rel="noopener">网页开发</a></h2><div class=""/><div class=""><h2 id="0245" class="pw-subtitle-paragraph ka jd iu bd b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dk translated">现代编程中的三种风格</h2></div><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj ks"><img src="../Images/0f5e98aec619b757558e1afd19c301f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eP6CDsjYVdV2AmgiGmVszg.jpeg"/></div></div><figcaption class="le lf gk gi gj lg lh bd b be z dk translated">由<a class="ae li" href="https://unsplash.com/@nate_dumlao?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">内森·杜姆劳</a>在<a class="ae li" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="16d8" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">我的一个同事想知道可观察到的东西和承诺是否是一样的东西，在一次讨论的启发下，我决定写这篇文章来解释它们之间的区别。</p></div><div class="ab cl mf mg hy mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="in io ip iq ir"><p id="4447" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated"><em class="mm">可以在Udemy上查看我的</em> <strong class="ll je"> <em class="mm">视频课程</em></strong><em class="mm">:</em><a class="ae li" href="https://www.udemy.com/course/identify-and-fix-javascript-memory-leaks/" rel="noopener ugc nofollow" target="_blank"><em class="mm">如何识别、诊断、修复Web Apps中的内存泄漏</em> </a> <em class="mm">。</em></p><h1 id="7594" class="mn mo iu bd mp mq mr ms mt mu mv mw mx kj my kk mz km na kn nb kp nc kq nd ne bi translated">承诺与可观察</h1><p id="d9b5" class="pw-post-body-paragraph lj lk iu ll b lm nf ke lo lp ng kh lr ls nh lu lv lw ni ly lz ma nj mc md me in bi translated">承诺和观察都有助于我们使用JavaScript中的<strong class="ll je"> <em class="mm">异步功能</em> </strong>。承诺是以异步方式解析的值，如HTTP调用。当异步操作完成或失败时，它们处理一个<strong class="ll je"> <em class="mm">单事件</em> </strong>。</p><p id="a994" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">可观察的东西就像承诺，除了它们与多个值一起工作，它们自己清理，它们可以被取消。如果不再需要HTTP请求或一些异步操作的结果，可观察对象的订阅允许取消订阅，而承诺最终会调用成功或失败的回调，即使您不再需要通知或它提供的结果。</p><p id="917a" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">Observable就像一个流(在许多语言中),允许传递0个、1个或更多事件，每个事件都调用回调函数。它们处理一个<strong class="ll je"> <em class="mm">序列的异步事件</em> </strong>。</p><p id="a5ff" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">可观察性提供了承诺和更多的特征:</p><ul class=""><li id="1550" class="nk nl iu ll b lm ln lp lq ls nm lw nn ma no me np nq nr ns bi translated">随着时间的推移，它们可以有<a class="ae li" href="https://medium.com/@luukgruijs/understanding-creating-and-subscribing-to-observables-in-angular-426dbf0b04a3" rel="noopener">多个值</a>:如果我们继续订阅时事通讯，我们将获得下一个生成的值。发件人决定我们什么时候收到，但我们必须等到它来。</li><li id="ae7f" class="nk nl iu ll b lm nt lp nu ls nv lw nw ma nx me np nq nr ns bi translated">他们有多条管道</li><li id="bee4" class="nk nl iu ll b lm nt lp nu ls nv lw nw ma nx me np nq nr ns bi translated">它们支持聚合操作，如映射、过滤、forEach、归约等</li><li id="4f4b" class="nk nl iu ll b lm nt lp nu ls nv lw nw ma nx me np nq nr ns bi translated">我们可以做一些强大的功能，比如用<code class="fe ny nz oa ob b">zip</code>、<code class="fe ny nz oa ob b">merge</code>或<code class="fe ny nz oa ob b">concat</code>将不同的<code class="fe ny nz oa ob b">Observable</code>组合成一个新的。</li></ul><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div class="gi gj oc"><img src="../Images/5482650c701ed12a8ce3e9de0944111a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1232/format:webp/1*nh9Li00xPGWVtmvWQ44jFw.png"/></div><figcaption class="le lf gk gi gj lg lh bd b be z dk translated">使用Angular app 中可观察到的<a class="ae li" href="https://medium.com/javascript-in-plain-english/angular-material-table-with-edit-function-like-excel-7c2c53332553" rel="noopener">来处理</a><a class="ae li" href="https://medium.com/swlh/sso-with-spnego-and-kerberos-8794f8ad5162" rel="noopener">用户的认证</a></figcaption></figure><p id="005b" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">由于在处理“异步事件序列”的<a class="ae li" href="https://medium.com/javascript-in-plain-english/angular-material-table-with-edit-function-like-excel-7c2c53332553" rel="noopener">反应式编程</a>中使用了可观察值，让我们看看这个来自<a class="ae li" href="https://www.scnsoft.com/blog/java-reactive-programming" rel="noopener ugc nofollow" target="_blank"> Uladzimir Sinkevich </a>的真实例子，这意味着什么:</p><p id="bd82" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">比如说，今天是星期五，约翰想和他的朋友鲍勃一起吃披萨，看一集《星球大战》。让我们概述一下他的选择。</p><ol class=""><li id="f5d8" class="nk nl iu ll b lm ln lp lq ls nm lw nn ma no me od nq nr ns bi translated">约翰完成了他的工作。然后去点披萨，一直等到做好。然后抱起他的朋友。最后(带着鲍勃和披萨)回到家，开始看电影。这将是<strong class="ll je">同步</strong>的方法，时间太长了，到那时约翰可能已经想取消了。</li><li id="b726" class="nk nl iu ll b lm nt lp nu ls nv lw nw ma nx me od nq nr ns bi translated">约翰在网上订了比萨饼，打电话给鲍勃，邀请他来。他回到家，叫了外卖，开始看电影(吃披萨),没有等鲍勃出现。这就是<strong class="ll je">异步</strong>方法可能发生的情况。</li><li id="6a71" class="nk nl iu ll b lm nt lp nu ls nv lw nw ma nx me od nq nr ns bi translated">约翰订了比萨饼，打电话给鲍勃，邀请他来，回家，并得到他的比萨饼。但是这一次，他等到鲍勃来了，只有在那之后，他才打开电影。这就是<strong class="ll je">反应式方法</strong>的目的。您等待所有异步操作(更改)完成，然后继续进一步的操作。</li></ol><blockquote class="oe"><p id="9073" class="of og iu bd oh oi oj ok ol om on me dk translated">"反应式编程是用异步数据流编程."安德烈·斯塔尔茨</p></blockquote><h1 id="b917" class="mn mo iu bd mp mq mr ms mt mu mv mw mx kj oo kk mz km op kn nb kp oq kq nd ne bi translated">可观察与流</h1><p id="9388" class="pw-post-body-paragraph lj lk iu ll b lm nf ke lo lp ng kh lr ls nh lu lv lw ni ly lz ma nj mc md me in bi translated">在这个阶段，在看到我们可以用一个可观察对象做什么之后，我的同事提出了下一个好问题:<br/>“既然它们有相似的操作符，我们可以像在Java中处理流一样处理一个可观察对象(在前端)吗？”</p><p id="a483" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">可观测的和流看起来非常相似。它们有看起来相似的运算符(过滤器、映射等)，但可观察值与流有显著不同:</p><ul class=""><li id="4b2c" class="nk nl iu ll b lm ln lp lq ls nm lw nn ma no me np nq nr ns bi translated">流只是随时间到达的集合。</li><li id="b949" class="nk nl iu ll b lm nt lp nu ls nv lw nw ma nx me np nq nr ns bi translated">可观测量就像集合…除了它们随着时间<strong class="ll je"> <em class="mm">异步</em> </strong>到达。</li><li id="afb4" class="nk nl iu ll b lm nt lp nu ls nv lw nw ma nx me np nq nr ns bi translated">Stream只能使用一次，Observable可以订阅多次。</li><li id="fe3d" class="nk nl iu ll b lm nt lp nu ls nv lw nw ma nx me np nq nr ns bi translated">流是<strong class="ll je"> <em class="mm">基于拉的</em> </strong>:数据消费者决定何时从数据生产者那里获取数据。生产者不知道数据何时将被交付给消费者。这只适用于与<strong class="ll je"> <em class="mm">同步的</em> </strong>事物。要从集合中提取一个值，它现在必须可用<strong class="ll je"> <em class="mm">！</em> </strong>如果我们将同步理解为“拉”…我们可以将异步理解为“推”…</li><li id="8196" class="nk nl iu ll b lm nt lp nu ls nv lw nw ma nx me np nq nr ns bi translated">可观察的是<strong class="ll je"> <em class="mm">基于推送的</em> </strong>:数据生产者(简讯的创建者)决定消费者(简讯的订阅者)何时获取数据。承诺是Javascript中最常见的<strong class="ll je"> <em class="mm">推</em> </strong>的方式。承诺(生产者)向注册的回调(消费者)传递<strong class="ll je"> <em class="mm">一个解析值</em> </strong>，但与函数不同的是，承诺负责精确地确定该值何时被<strong class="ll je"> <em class="mm">推送到</em> </strong>回调。</li></ul><p id="34d7" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">每个Javascript函数都使用pull该函数是数据的生产者，调用该函数的代码通过从其调用中取出一个<em class="mm">单个</em>返回值来消费数据。</p><p id="267f" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">一个可观察的生产者是<strong class="ll je"> <em class="mm">多个值</em> </strong>，<em class="mm">将它们推送给</em>订阅者。我们订阅一个可观察的，当下一个项目到达<code class="fe ny nz oa ob b">onNext</code>，或者当流完成<code class="fe ny nz oa ob b">onCompleted</code>，或者当错误发生<code class="fe ny nz oa ob b">onError</code>时，我们将<strong class="ll je"> <em class="mm">得到</em> </strong> <strong class="ll je"> <em class="mm">通知</em> </strong>。因为有了<code class="fe ny nz oa ob b">Observable</code>，我们就接收到了<code class="fe ny nz oa ob b">onNext</code>、<code class="fe ny nz oa ob b">onCompleted</code>、<code class="fe ny nz oa ob b">onError</code>事件。我们可以做的其他事情是缓存，节流，...</p><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj or"><img src="../Images/cde2fb7727a1be2e8f84b79c77d750c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*13TP08Xwr91St1oERq4-fg.png"/></div></div><figcaption class="le lf gk gi gj lg lh bd b be z dk translated"><a class="ae li" href="http://slides.com/robwormald/everything-is-a-stream#/65" rel="noopener ugc nofollow" target="_blank">用迭代器拉vs用可观察值推</a></figcaption></figure><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div class="gi gj os"><img src="../Images/dbc5af420d7a2635c7a2095e8ef3899f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1228/format:webp/1*NHi6FrNkYMYEi_qtQki5uA.png"/></div><figcaption class="le lf gk gi gj lg lh bd b be z dk translated">Java中的迭代器与可观察对象</figcaption></figure><h2 id="d23e" class="ot mo iu bd mp ou ov dn mt ow ox dp mx ls oy oz mz lw pa pb nb ma pc pd nd ja bi translated">Java 8流API与RxJava</h2><p id="6acf" class="pw-post-body-paragraph lj lk iu ll b lm nf ke lo lp ng kh lr ls nh lu lv lw ni ly lz ma nj mc md me in bi translated">让我们以Java 8 Streams API(Java . util . stream)中的流和RxJava中的Observables(Java的ReactiveX API，用于可观察流的异步编程)为例。这两个API不是为相同的用途而构建的。</p><ul class=""><li id="3016" class="nk nl iu ll b lm ln lp lq ls nm lw nn ma no me np nq nr ns bi translated">我们可以使用rx Java<strong class="ll je"><em class="mm">执行异步任务</em> </strong>。</li><li id="9d20" class="nk nl iu ll b lm nt lp nu ls nv lw nw ma nx me np nq nr ns bi translated">使用Java 8 stream，我们将<strong class="ll je"> <em class="mm">遍历您的集合</em> </strong>中的条目。</li><li id="0e61" class="nk nl iu ll b lm nt lp nu ls nv lw nw ma nx me np nq nr ns bi translated">我们可以在RxJava中做几乎相同的事情(遍历集合中的项目)，但是，由于RxJava专注于并发任务，…，它使用同步、锁存…因此，使用RxJava的相同任务可能比使用Java 8 stream慢。</li><li id="5a64" class="nk nl iu ll b lm nt lp nu ls nv lw nw ma nx me np nq nr ns bi translated">RxJava可以与<code class="fe ny nz oa ob b">CompletableFuture</code>相比，但是它可以计算不止一个值。</li><li id="e1a6" class="nk nl iu ll b lm nt lp nu ls nv lw nw ma nx me np nq nr ns bi translated">默认情况下RxJava是<strong class="ll je"> <em class="mm">单线程的。</em> </strong>除非我们开始使用调度程序，否则一切都将发生在同一个线程上。</li></ul><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj pe"><img src="../Images/06b129c14518ff478aa1b73ced7d330f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A8B_3LkPIAiNv_KJOFEX6A.png"/></div></div><figcaption class="le lf gk gi gj lg lh bd b be z dk translated"><a class="ae li" href="https://www.slideshare.net/triondevelopment/reactive-everywhere" rel="noopener ugc nofollow" target="_blank">后端实现:REST方法返回一个可观察对象</a></figcaption></figure><h2 id="b49c" class="ot mo iu bd mp ou ov dn mt ow ox dp mx ls oy oz mz lw pa pb nb ma pc pd nd ja bi translated"><strong class="ak">最后一件事:流与集合</strong></h2><p id="8b39" class="pw-post-body-paragraph lj lk iu ll b lm nf ke lo lp ng kh lr ls nh lu lv lw ni ly lz ma nj mc md me in bi translated">正如你已经注意到的，我们的故事中还有第四个玩家:它是<strong class="ll je"> <em class="mm">集合</em> </strong>。Java 8 Streams API提供了一种处理Java集合的机制。它是关于将集合转换为流，并行处理元素<strong class="ll je"> <em class="mm">，</em> </strong>，然后将结果元素收集到一个集合中。</p><ul class=""><li id="950e" class="nk nl iu ll b lm ln lp lq ls nm lw nn ma no me np nq nr ns bi translated">集合是一个<strong class="ll je"> <em class="mm">内存中的</em> </strong>数据结构，其中包含元素。集合中的每个元素在实际成为集合的一部分之前都经过计算。所以，这是一组<strong class="ll je"> <em class="mm">急切地</em> </strong>计算出来的数值。</li><li id="88ea" class="nk nl iu ll b lm nt lp nu ls nv lw nw ma nx me np nq nr ns bi translated">流是固定的数据结构，它按需计算元素。Java 8流可以看作是<strong class="ll je"><em class="mm"/></strong>构造的集合，当用户需要时，这些值被计算出来。</li><li id="161c" class="nk nl iu ll b lm nt lp nu ls nv lw nw ma nx me np nq nr ns bi translated">像函数式编程语言一样，流支持可以串行或并行执行的聚合操作:过滤、映射、归约、查找、匹配、排序、限制、收集…</li><li id="67d4" class="nk nl iu ll b lm nt lp nu ls nv lw nw ma nx me np nq nr ns bi translated">流还支持管道和内部迭代:大多数java 8流操作只返回流。这有助于我们创建各种流操作的链→这称为流水线操作。流水线操作看起来类似于SQL查询。</li></ul><h2 id="bd8a" class="ot mo iu bd mp ou ov dn mt ow ox dp mx ls oy oz mz lw pa pb nb ma pc pd nd ja bi translated">今天到此为止</h2><p id="0511" class="pw-post-body-paragraph lj lk iu ll b lm nf ke lo lp ng kh lr ls nh lu lv lw ni ly lz ma nj mc md me in bi translated">让我知道你对此的想法。我希望这有助于增强你对承诺、可观察和心流的理解，下次你遇到这些术语时，它们不会让你困惑。</p></div><div class="ab cl mf mg hy mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="in io ip iq ir"><h1 id="e973" class="mn mo iu bd mp mq pf ms mt mu pg mw mx kj ph kk mz km pi kn nb kp pj kq nd ne bi translated">想要更多吗？</h1><p id="ae76" class="pw-post-body-paragraph lj lk iu ll b lm nf ke lo lp ng kh lr ls nh lu lv lw ni ly lz ma nj mc md me in bi translated">我为一群聪明、好奇的🧠人写关于工程、技术和领导力的文章💡。<a class="ae li" href="https://rakiabensassi.substack.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="ll je">加入我的免费电子邮件简讯独家访问</strong> </a> <strong class="ll je"> </strong>或在此报名Medium<a class="ae li" href="https://rakiabensassi.medium.com/membership" rel="noopener"/>。</p><p id="70ac" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated"><em class="mm">可以在Udemy上查看我的</em> <strong class="ll je"> <em class="mm">视频课程</em></strong><em class="mm">:</em><a class="ae li" href="https://www.udemy.com/course/identify-and-fix-javascript-memory-leaks/" rel="noopener ugc nofollow" target="_blank"><em class="mm">如何识别、诊断、修复Web Apps中的内存泄漏</em> </a> <em class="mm">。</em></p><div class="pk pl gq gs pm pn"><a href="https://medium.com/better-programming/compiler-vs-interpreter-d0a12ca1c1b6" rel="noopener follow" target="_blank"><div class="po ab fp"><div class="pp ab pq cl cj pr"><h2 class="bd je gz z fq ps fs ft pt fv fx jd bi translated">编译器与解释器:了解它们的区别以及何时使用它们</h2><div class="pu l"><h3 class="bd b gz z fq ps fs ft pt fv fx dk translated">编译器和解释器的类型和用例</h3></div><div class="pv l"><p class="bd b dl z fq ps fs ft pt fv fx dk translated">medium.com</p></div></div><div class="pw l"><div class="px l py pz qa pw qb lc pn"/></div></div></a></div><div class="pk pl gq gs pm pn"><a rel="noopener  ugc nofollow" target="_blank" href="/learning-velocity-and-coding-standards-10952f6c9640"><div class="po ab fp"><div class="pp ab pq cl cj pr"><h2 class="bd je gz z fq ps fs ft pt fv fx jd bi translated">为什么编码标准很重要，以及如何衡量开发速度</h2><div class="pu l"><h3 class="bd b gz z fq ps fs ft pt fv fx dk translated">熟悉一个新项目需要多长时间</h3></div><div class="pv l"><p class="bd b dl z fq ps fs ft pt fv fx dk translated">levelup.gitconnected.com</p></div></div><div class="pw l"><div class="qc l py pz qa pw qb lc pn"/></div></div></a></div></div></div>    
</body>
</html>