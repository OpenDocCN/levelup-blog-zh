<html>
<head>
<title>Reverse Engineer React Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">逆向工程反应钩</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/reverse-engineer-react-hooks-4abfb4163e37?source=collection_archive---------16-----------------------#2020-10-13">https://levelup.gitconnected.com/reverse-engineer-react-hooks-4abfb4163e37?source=collection_archive---------16-----------------------#2020-10-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/7a5f33e9cdbd95899727bc769cf67ff1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UMkNVuenBfTN7KO6fzMpgA.jpeg"/></div></div></figure><p id="c9f2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我开始用功能组件已经一年多了。对于功能组件，我们可以使用很酷的React钩子，比如useState，useEffect…等等。钩子成为我们应用程序的主要构件之一，理解它们如何工作是成为一名更好的React开发人员的关键。我个人认为，弄清楚事物如何工作的最好方法之一是尝试对其进行逆向工程。</p><h1 id="5fee" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">怎么才能做到呢？</h1><p id="d017" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">React钩子最酷的一点是我们可以在其他钩子的帮助下实现它们。所以我们可以在使用钩子的同时对它们进行逆向工程，这将有助于我们更好地理解钩子的逻辑，并开发一个合适的心智模型，事不宜迟，让我们实现一些内置的钩子。</p><p id="4f79" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">注1:真正的实现使用完全不同的方法。</strong></p><p id="35a9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">注2:我不能保证我们的定制钩子在新的并发模式下会像预期的那样工作。</strong></p></div><div class="ab cl lz ma hu mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ij ik il im in"><h1 id="f316" class="kw kx iq bd ky kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt bi translated">useRef</h1><p id="103c" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">让我们从useRef开始，因为我们将使用这个钩子作为其他实现的主要构件。</p><p id="c805" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">根据React <a class="ae ml" href="https://reactjs.org/docs/hooks-reference.html" rel="noopener ugc nofollow" target="_blank">文件</a>:</p><blockquote class="mm mn mo"><p id="2956" class="jy jz mp ka b kb kc kd ke kf kg kh ki mq kk kl km mr ko kp kq ms ks kt ku kv ij bi translated"><code class="fe mt mu mv mw b">useRef</code>返回一个可变的ref对象，其<code class="fe mt mu mv mw b">.current</code>属性被初始化为传递的参数(<code class="fe mt mu mv mw b">initialValue</code>)。返回的对象将在组件的整个生存期内保持不变。</p></blockquote><p id="f63e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以我们需要某种“盒子”来存储我们的价值，那么我们的custom <strong class="ka ir"> useRef </strong>应该遵循哪些基本原则？</p><ul class=""><li id="ee09" class="mx my iq ka b kb kc kf kg kj mz kn na kr nb kv nc nd ne nf bi translated">该框应该包含一个带有一个key = "current "的对象</li><li id="2027" class="mx my iq ka b kb ng kf nh kj ni kn nj kr nk kv nc nd ne nf bi translated">盒子的<code class="fe mt mu mv mw b">current</code>应该是可变的</li><li id="bcff" class="mx my iq ka b kb ng kf nh kj ni kn nj kr nk kv nc nd ne nf bi translated">更改框的<code class="fe mt mu mv mw b">current</code>值不应触发重新渲染</li></ul><p id="b758" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">每当我必须存储某种对象/数据/值时，我首先想到的当然是状态，我们可以用状态实现useRef吗？让我们看看</p><figure class="nl nm nn no gt jr"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="2811" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">是的，我知道我们不应该在普通函数中使用<code class="fe mt mu mv mw b">useState</code>而直接修改它，(顺便你可以查看一下<a class="ae ml" href="https://medium.com/@ryardley/react-hooks-not-magic-just-arrays-cd4f1857236e" rel="noopener"> <strong class="ka ir">这篇文章</strong> </a>以便更好地理解那个hook的规则背后的原因)，但是我们就破例这一次吧。您可以查看<a class="ae ml" href="https://codesandbox.io/s/my-custom-ref-vsg9z?file=/src/my-own-ref.ts" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">现场演示</strong> </a>，因为我们可以看到我们的自定义钩子的行为与React的内置<strong class="ka ir"> useRef </strong>完全一样。如果你不明白为什么这样做，去玩一下给定的演示，在<strong class="ka ir"> useRenderCount </strong>钩子中添加一些<code class="fe mt mu mv mw b">console.log</code> -s，仔细看看存储在我们的“盒子”中的对象。</p></div><div class="ab cl lz ma hu mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ij ik il im in"><h1 id="b347" class="kw kx iq bd ky kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt bi translated">使用状态</h1><p id="1b5a" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">我们用<strong class="ka ir">使用状态</strong>做什么？如果你正在读这篇文章，你已经知道什么是状态，那么让我们写下一些我们习惯使用状态应该遵循的基本原则</p><ul class=""><li id="67ba" class="mx my iq ka b kb kc kf kg kj mz kn na kr nb kv nc nd ne nf bi translated">应该返回一个有状态的值和一个函数来更新它。</li><li id="9ae8" class="mx my iq ka b kb ng kf nh kj ni kn nj kr nk kv nc nd ne nf bi translated">在初始渲染期间，返回<code class="fe mt mu mv mw b">state</code>应该与<code class="fe mt mu mv mw b">initialState</code>相同</li><li id="d7b7" class="mx my iq ka b kb ng kf nh kj ni kn nj kr nk kv nc nd ne nf bi translated">在随后的重新渲染过程中，返回的状态应该总是最新的状态。</li><li id="73da" class="mx my iq ka b kb ng kf nh kj ni kn nj kr nk kv nc nd ne nf bi translated"><code class="fe mt mu mv mw b">initialState</code>参数也可以是一个函数，只在初始渲染时执行。</li><li id="f7b3" class="mx my iq ka b kb ng kf nh kj ni kn nj kr nk kv nc nd ne nf bi translated"><code class="fe mt mu mv mw b">setState</code>应该支持传递一个函数作为参数，它将接收以前的值，并返回一个更新的值。</li><li id="c551" class="mx my iq ka b kb ng kf nh kj ni kn nj kr nk kv nc nd ne nf bi translated"><code class="fe mt mu mv mw b">setState</code>重新渲染时不应改变。</li><li id="0469" class="mx my iq ka b kb ng kf nh kj ni kn nj kr nk kv nc nd ne nf bi translated">如果<code class="fe mt mu mv mw b">newValue</code>，改变状态应触发rerender！== <code class="fe mt mu mv mw b">prevValue</code></li></ul><p id="2d10" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">关于我们列表中的最后一项，在没有React的原始useState挂钩的情况下触发rerender是一件非常具有挑战性的事情(老实说，我认为不使用useReducer是不可能的)，所以我们将使用一个自定义的小hack挂钩，它将手动触发rerender。</p><figure class="nl nm nn no gt jr"><div class="bz fp l di"><div class="np nq l"/></div></figure><figure class="nl nm nn no gt jr"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="e0fd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这一次我们没有违反任何React钩子规则，我们的钩子完全像内置的<strong class="ka ir">use state</strong>一样工作。<a class="ae ml" href="https://codesandbox.io/s/my-custom-state-kfvyr" rel="noopener ugc nofollow" target="_blank">现场演示</a>。</p><p id="f8e6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一些值得注意的时刻:</p><ul class=""><li id="c027" class="mx my iq ka b kb kc kf kg kj mz kn na kr nb kv nc nd ne nf bi translated">我们必须存储关于是否是<strong class="ka ir">第一次渲染</strong>的信息</li><li id="730a" class="mx my iq ka b kb ng kf nh kj ni kn nj kr nk kv nc nd ne nf bi translated">如果它是第一次呈现，我们应该首先初始化我们的状态。<strong class="ka ir">如果</strong>传递的参数是function - &gt;调用该函数- &gt;将返回值设置为当前状态。我们只是将我们的状态设置为给定的默认值。</li><li id="800c" class="mx my iq ka b kb ng kf nh kj ni kn nj kr nk kv nc nd ne nf bi translated">React不喜欢不必要的重新渲染，所以为了避免这种情况，我们应该首先拍摄当前状态的快照，然后从给定的参数中获取一个新的状态，并且只有在<code class="fe mt mu mv mw b">prevState</code>！== <code class="fe mt mu mv mw b">curState</code></li><li id="5672" class="mx my iq ka b kb ng kf nh kj ni kn nj kr nk kv nc nd ne nf bi translated">恭喜我们现在有了自己的<strong class="ka ir"> useMyState！</strong></li></ul><p id="d3ee" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">注意:如果你认为有时你的React应用程序会毫无理由地重新渲染，你可能会发现</strong> <a class="ae ml" href="https://reactjs.org/docs/strict-mode.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> React严格模式</strong> </a> <strong class="ka ir">很有趣，这是一件非常有用的事情。</strong></p><figure class="nl nm nn no gt jr gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/308348cb4d2eeb6e012c5675a204d3c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:772/format:webp/1*u2aSCN3uCrX294jNPVadJw.png"/></div></figure><p id="050b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们实现了两个钩子<strong class="ka ir"> useMyRef </strong>和<strong class="ka ir"> useMyState </strong>，如果你问我，我们的useRef实现依赖于useState和useState实现——useRef，这很酷。</p><p id="671f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是我们每天都在使用许多其他的钩子，目前，记忆和优化是React社区中的一个非常热门的话题，所以我们可以构建<strong class="ka ir"> useCallback </strong>和<strong class="ka ir"> useMemo </strong>钩子吗？我们能在它们之间找到某种可互换的联系吗，就像我们在ref和sate中所做的那样？让我们看看</p></div><div class="ab cl lz ma hu mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ij ik il im in"><h1 id="fa9e" class="kw kx iq bd ky kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt bi translated">使用回调</h1><p id="5e01" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">我们用useCallback做什么？</p><p id="3369" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这非常简单，useCallback返回Callback的记忆化版本，只有当其中一个依赖关系发生变化时，它才会发生变化。嗯，在反应中记忆一些东西，这是最擅长的事情。</p><figure class="nl nm nn no gt jr"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="b8dc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">耶，作品如魅，结账<a class="ae ml" href="https://codesandbox.io/s/use-my-callback-h2ins?file=/src/App.tsx" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">现场试玩</strong> </a> <strong class="ka ir">。但是在React文档中有一个我们应该考虑的小警告</strong></p><blockquote class="mm mn mo"><p id="4537" class="jy jz mp ka b kb kc kd ke kf kg kh ki mq kk kl km mr ko kp kq ms ks kt ku kv ij bi translated"><strong class="ka ir">你可以依赖</strong> <code class="fe mt mu mv mw b"><strong class="ka ir">useMemo</strong></code> <strong class="ka ir">作为性能优化，而不是作为语义保证。</strong>将来，React可能会选择“忘记”一些先前记忆的值，并在下次渲染时重新计算它们，例如为屏幕外组件释放内存。编写您的代码，使其在没有<code class="fe mt mu mv mw b">useMemo</code>的情况下仍然可以工作，然后添加它以优化性能。</p></blockquote><p id="8786" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以我们需要新的<strong class="ka ir"> useMyCallback </strong>，它不依赖于<strong class="ka ir"> useMemo </strong>和<strong class="ka ir"> </strong>如果依赖数组没有改变，那么每次渲染都是相同的<strong class="ka ir"> </strong>。<strong class="ka ir">额外特性:</strong>也许我们懒得传递deps数组，让我们做一个没有依赖列表的钩子，和原来的钩子一样高效。将可变值存储在React中，并在满足某些条件时更新它，我们之前已经遇到过这个问题，答案是相同的- <strong class="ka ir"> useRef </strong>。</p><figure class="nl nm nn no gt jr"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="772c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">查看<a class="ae ml" href="https://codesandbox.io/s/use-my-custom-callback-02t8z?file=/src/useMyBetterCallback.ts" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">现场演示</strong> </a>，如果你不明白为什么我们的钩子是这样工作的，最好的方法就是回去查看我们早期的实现，然后再玩这个演示。继续把钩子的返回值直接改成<code class="fe mt mu mv mw b">fn</code>，你会注意到渲染次数会增加。还有，你可以这样修改我们的钩子- <code class="fe mt mu mv mw b">export const useMyBetterCallback = useCallback;</code>。你会注意到它的行为就像我们的定制钩子一样。</p></div><div class="ab cl lz ma hu mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ij ik il im in"><h1 id="03da" class="kw kx iq bd ky kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt bi translated"><strong class="ak">使用备忘录</strong></h1><p id="a3c7" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">如果useCallback存储记忆化的函数，useMemo存储记忆化的值，该值是用我们作为参数传递的函数计算的。依赖性数组逻辑在这里是相同的，当前数组和旧数组的不同意味着我们应该重新计算值。</p><blockquote class="mm mn mo"><p id="451b" class="jy jz mp ka b kb kc kd ke kf kg kh ki mq kk kl km mr ko kp kq ms ks kt ku kv ij bi translated">记住传递给<code class="fe mt mu mv mw b">useMemo</code>的函数在渲染时运行。不要做任何渲染时通常不会做的事情。例如，副作用属于<code class="fe mt mu mv mw b">useEffect</code>，而不是<code class="fe mt mu mv mw b">useMemo</code>。</p></blockquote><p id="62c4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">同样，我们应该存储某种值，该值在每次渲染时都必须相同，直到依赖关系数组发生变化，这意味着我们必须再次寻址我们的老useRef。</p><p id="a98b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">注意:</strong>对于useMemo钩子的实现，我们需要某种等式函数来确定先前和新的依赖列表是否相同。</p><figure class="nl nm nn no gt jr"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="7789" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">结帐<strong class="ka ir">使用我的备忘录</strong>进行现场演示。对于我们来说,<code class="fe mt mu mv mw b">areDeepEqual</code>函数是如何实现的并不重要，我们只知道它是纯的，并且按预期工作。</p><p id="3439" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们只需要用useRef存储以前的依赖列表，然后我们将它与新列表进行比较，只有在列表之间有一些差异时，才执行给定的函数。现在，我们的用户将总是使用最新的函数来计算值。</p></div><div class="ab cl lz ma hu mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ij ik il im in"><h1 id="b2db" class="kw kx iq bd ky kz mg lb lc ld mh lf lg lh mi lj lk ll mj ln lo lp mk lr ls lt bi translated">摘要</h1><p id="ef43" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">功能组件是非常有效的，但是我们在使用它们的时候需要一个不同的心智模型，有时这可能会有点棘手，在调试代码的时候，扎实的钩子知识可以节省我们大量的时间。正如我上面提到的，在学习新东西的时候，尝试逆向工程是很有帮助的，当我开始使用React hooks并遇到一些花了几个小时才找到的bug时，这给了我很大的帮助。</p><h2 id="36ab" class="ns kx iq bd ky nt nu dn lc nv nw dp lg kj nx ny lk kn nz oa lo kr ob oc ls od bi translated">我希望这很有趣。</h2></div></div>    
</body>
</html>