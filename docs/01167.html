<html>
<head>
<title>Using React Context to inject dependencies to your component library</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React上下文向组件库注入依赖关系</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/using-react-context-to-inject-dependencies-to-your-component-library-9e0c4c1342da?source=collection_archive---------1-----------------------#2019-11-21">https://levelup.gitconnected.com/using-react-context-to-inject-dependencies-to-your-component-library-9e0c4c1342da?source=collection_archive---------1-----------------------#2019-11-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f003" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">向React库添加配置的简单技术。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/c55c60597374c96018d1753219a69907.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cpYmsUDWGMx0bGFy"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated"><a class="ae kv" href="https://unsplash.com/@setbydaniel?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">丹尼尔</a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="57cc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi ls translated">我认为你正在编写一个库，它导出了一组可重用的组件。其中一个组件是一个按钮，需要链接到应用程序的另一部分。您正在使用<code class="fe mb mc md me b">react-router</code>的<code class="fe mb mc md me b">Link</code>组件或类似的东西来创建这些链接。但是你不希望你的可重用组件库依赖于<code class="fe mb mc md me b">react-router</code>——事实上，UI库不应该关心路由，对吗？</p><p id="7b8a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以你需要一种方式对你的<code class="fe mb mc md me b">Button</code>组件说，“嘿，我需要你使用这个基础组件来渲染，这样你就可以和我的应用程序的其余部分相处了。”</p><p id="7dab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一种选择是向该组件传递一个属性来告诉按钮应该如何呈现，例如:</p><pre class="kg kh ki kj gt mf me mg mh aw mi bi"><span id="308e" class="mj mk iq me b gy ml mm l mn mo">&lt;Button {...props} renderComponent={Link} /&gt;</span></pre><p id="9e20" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后<code class="fe mb mc md me b">Button</code>组件代码会是这样的:</p><pre class="kg kh ki kj gt mf me mg mh aw mi bi"><span id="4899" class="mj mk iq me b gy ml mm l mn mo">// Button.js<br/>const Button = ({ renderComponent, ...otherProps }) =&gt; {<br/>  const LinkComponent = renderComponent;<br/>  return &lt;LinkComponent {...otherProps} /&gt;;<br/>};</span></pre><p id="8afd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不过，这种方法有一些缺点。</p><p id="28cd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最明显的一点是，您需要为应用程序需要使用的每个<code class="fe mb mc md me b">Button</code>实例指定渲染组件。这很麻烦，但也没那么可怕。</p><p id="796a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，如果您的组件库也包含一个名为<code class="fe mb mc md me b">NavMenu</code>的组件，该组件由多个<code class="fe mb mc md me b">Button</code>组成，每个组件都有一个到应用程序不同部分的链接，该怎么办呢？您还需要在您的<code class="fe mb mc md me b">NavMenu</code>组件中实现<code class="fe mb mc md me b">renderComponent</code> prop，这样它就可以将它传递给底层的<code class="fe mb mc md me b">Button</code>组件。</p><pre class="kg kh ki kj gt mf me mg mh aw mi bi"><span id="db86" class="mj mk iq me b gy ml mm l mn mo">// NavMenu.js<br/>const NavMenu = ({ buttonRenderComponent, urlA, urlB }) =&gt; (&lt;&gt;<br/>  &lt;Button renderComponent={buttonRenderComponent} href={urlA} /&gt;<br/>  &lt;Button renderComponent={buttonRenderComponent} href={urlB} /&gt;<br/>&lt;/&gt;);</span></pre><p id="dd2c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这很糟糕，也显示了我们设计中的一个弱点，<code class="fe mb mc md me b">Button</code>实现通过<code class="fe mb mc md me b">NavMenu</code>泄漏。</p><h1 id="f750" class="mp mk iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">上下文API来拯救</h1><p id="469d" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">React Context API 是一个很好的工具，可以最大限度地减少组件树中的道具传递。当然，这种权力不应该被滥用，但是，对于我们目前的情况来说，它确实很方便。</p><p id="aef0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">实施此解决方案的步骤非常简单:</p><ol class=""><li id="a35b" class="nm nn iq ky b kz la lc ld lf no lj np ln nq lr nr ns nt nu bi translated">你的库需要公开一个<code class="fe mb mc md me b">Context</code>，定义初始值，</li><li id="66c8" class="nm nn iq ky b kz nv lc nw lf nx lj ny ln nz lr nr ns nt nu bi translated">您的<code class="fe mb mc md me b">Button</code>组件将需要使用该上下文，并从那里获取指定的组件来呈现</li><li id="3545" class="nm nn iq ky b kz nv lc nw lf nx lj ny ln nz lr nr ns nt nu bi translated">库用户需要导入库上下文，并在应用程序的根目录中提供值。</li></ol><p id="ca62" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在JavaScript中:</p><pre class="kg kh ki kj gt mf me mg mh aw mi bi"><span id="a9ea" class="mj mk iq me b gy ml mm l mn mo"><strong class="me ir">// library/context.js</strong><br/>import { createContext } from 'react';</span><span id="72ee" class="mj mk iq me b gy oa mm l mn mo">const LibraryContext = createContext({<br/>  LinkComponent: undefined<br/>});</span><span id="c867" class="mj mk iq me b gy oa mm l mn mo">export default LibraryContext;</span><span id="d1f2" class="mj mk iq me b gy oa mm l mn mo"><strong class="me ir">// library/button.js</strong><br/>import React, { useContext } from 'react';<br/>import LibraryContext from './context';</span><span id="9d2a" class="mj mk iq me b gy oa mm l mn mo">const DefaultLinkComponent = ({ to, ...props }) =&gt; (<br/>  &lt;a href={to} {...props} /&gt;<br/>);</span><span id="ea6a" class="mj mk iq me b gy oa mm l mn mo">const Button = (props) =&gt; {<br/>  const {<br/>    LinkComponent = DefaultLinkComponent<br/>  } = useContext(LibraryContext);</span><span id="6ea3" class="mj mk iq me b gy oa mm l mn mo">  return &lt;LinkComponent {...props} /&gt;;<br/>};</span><span id="fef5" class="mj mk iq me b gy oa mm l mn mo"><strong class="me ir">// app.js</strong><br/>import { BrowserRouter, Link } from 'react-router-dom';<br/>import { Context, Button } from 'my-library';</span><span id="d2fb" class="mj mk iq me b gy oa mm l mn mo">render(<br/>  &lt;Context.Provider value={{ LinkComponent: Link }}&gt;<br/>    &lt;BrowserRouter&gt;<br/>      &lt;Button to="/path" /&gt;<br/>    &lt;/BrowserRouter&gt;<br/>  &lt;/Context.Provider&gt;<br/>);</span></pre><p id="2168" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">很简单，对吧？现在，您有了配置组件库的方法，更重要的是，您已经成功地扩展了组件，而没有向工具箱添加外部依赖项。</p><h1 id="dcb3" class="mp mk iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">附加用例:跨平台渲染</h1><p id="9898" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">也许这种方法还可以帮助创建一个跨平台的组件库，它可以根据上下文值使用一组不同的“原语”进行渲染。</p><p id="c789" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我还没有研究过，但是我觉得可能可以写一个只依赖于<code class="fe mb mc md me b">react</code>的库，然后它使用<code class="fe mb mc md me b">react-dom</code>、<code class="fe mb mc md me b">react-native</code>甚至一个<a class="ae kv" href="https://reactpixi.org/" rel="noopener ugc nofollow" target="_blank"> Canvas/WebGL渲染后端</a>，通过上下文注入。</p><p id="1ce7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果有任何人已经这样做了，请给我指出这个项目！</p></div></div>    
</body>
</html>