<html>
<head>
<title>Making a Flutter Todo App from Scratch Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从零开始制作一个抖动的Todo应用程序第2部分</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/making-a-flutter-todo-app-from-scratch-part-2-47dadd3a0b96?source=collection_archive---------7-----------------------#2020-01-06">https://levelup.gitconnected.com/making-a-flutter-todo-app-from-scratch-part-2-47dadd3a0b96?source=collection_archive---------7-----------------------#2020-01-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7fbf" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">理解颤振状态</h2></div><h1 id="d601" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">州</h1><p id="653c" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">从我们上次制作的<a class="ae lt" href="https://medium.com/@hydroweaver/making-a-flutter-todo-app-from-scratch-part-1-bd66608b1818?" rel="noopener"> <strong class="kz ir">哑app </strong> </a>向前看，让我们了解一下旋舞中的状态。当你的应用程序在用户界面上做了一些需要改变的事情时，状态就会改变。这里的国家文件是<a class="ae lt" href="https://flutter.dev/docs/development/data-and-backend/state-mgmt/intro" rel="noopener ugc nofollow" target="_blank"/>。让我们看看下面一些触发状态变化的例子:</p><ol class=""><li id="bf4d" class="lu lv iq kz b la lw ld lx lg ly lk lz lo ma ls mb mc md me bi translated">将待办事项切换为完成/未完成，可以更改应用程序的状态。</li><li id="1b7c" class="lu lv iq kz b la mf ld mg lg mh lk mi lo mj ls mb mc md me bi translated">从文本栏添加新的待办事项</li><li id="fe8c" class="lu lv iq kz b la mf ld mg lg mh lk mi lo mj ls mb mc md me bi translated">删除待办事项</li><li id="6f14" class="lu lv iq kz b la mf ld mg lg mh lk mi lo mj ls mb mc md me bi translated">编辑待办事项</li><li id="de38" class="lu lv iq kz b la mf ld mg lg mh lk mi lo mj ls mb mc md me bi translated">...任何需要改变视觉外观的变化。</li></ol><p id="96cd" class="pw-post-body-paragraph kx ky iq kz b la lw jr lc ld lx ju lf lg mk li lj lk ml lm ln lo mm lq lr ls ij bi translated">让我们把这个放到应用程序中，我们的目标是<strong class="kz ir"> <em class="mn">实际上让可订购列表项保持在它们的新位置。</em> </strong>可以想象，一个简单的变化，从一个位置到另一个位置，真的是状态变化。</p><p id="3f42" class="pw-post-body-paragraph kx ky iq kz b la lw jr lc ld lx ju lf lg mk li lj lk ml lm ln lo mm lq lr ls ij bi translated">为了在我们的应用程序中嵌入状态，我们需要稍微修改一下代码。</p><ul class=""><li id="7f16" class="lu lv iq kz b la lw ld lx lg ly lk lz lo ma ls mo mc md me bi translated">第一件事是将我们的应用程序更改为<strong class="kz ir"> StatefulWidget </strong>类，这意味着它将是一个状态可以改变的小部件，而不像<strong class="kz ir"> StatelessWidget </strong>那样本质上是静态的。</li><li id="93a4" class="lu lv iq kz b la mf ld mg lg mh lk mi lo mj ls mo mc md me bi translated">创建另一个类，它包含第1点中定义的<strong class="kz ir"> StatefulWidget </strong>类的实现。</li></ul><p id="ab68" class="pw-post-body-paragraph kx ky iq kz b la lw jr lc ld lx ju lf lg mk li lj lk ml lm ln lo mm lq lr ls ij bi translated">现在看起来确实很混乱，但很快就会有意义。这是我们的新班级。</p><figure class="mp mq mr ms gt mt"><div class="bz fp l di"><div class="mu mv l"/></div><figcaption class="mw mx gj gh gi my mz bd b be z dk translated">应用程序已从StatlessWidget更改为StatefulWidget</figcaption></figure><p id="f36e" class="pw-post-body-paragraph kx ky iq kz b la lw jr lc ld lx ju lf lg mk li lj lk ml lm ln lo mm lq lr ls ij bi translated">这是一个新的类，它现在保存了我们上次添加的实现，请注意，代码中只有<strong class="kz ir">一处</strong>更改，但应用程序以相同的方式工作，即<strong class="kz ir">哑方式！</strong>😉</p><figure class="mp mq mr ms gt mt"><div class="bz fp l di"><div class="mu mv l"/></div></figure><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div class="gh gi na"><img src="../Images/309ea7cf3d2dba47d461dba335f3d523.png" data-original-src="https://miro.medium.com/v2/resize:fit:576/1*GdCVxeBKCcP_TiHQN6YUlw.gif"/></div><figcaption class="mw mx gj gh gi my mz bd b be z dk translated">未实施重新订购，仍然无效</figcaption></figure><p id="c2b6" class="pw-post-body-paragraph kx ky iq kz b la lw jr lc ld lx ju lf lg mk li lj lk ml lm ln lo mm lq lr ls ij bi translated">注意到上面要点的第一行了吗？</p><figure class="mp mq mr ms gt mt"><div class="bz fp l di"><div class="mu mv l"/></div><figcaption class="mw mx gj gh gi my mz bd b be z dk translated">新类AppState保存了APP 类的<strong class="ak">状态</strong></figcaption></figure><p id="1b52" class="pw-post-body-paragraph kx ky iq kz b la lw jr lc ld lx ju lf lg mk li lj lk ml lm ln lo mm lq lr ls ij bi translated">这个新类包含了我们上一次处理的类的状态<strong class="kz ir"> <em class="mn">【实现】</em> </strong>的内部结构，但是其他什么都没有改变。我引用了“实现”这个词，因为如你所见，没有其他区别。真正的区别来自于实现中的<strong class="kz ir">on order</strong>函数。让我们添加一些代码。</p><h1 id="a40b" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated"><strong class="ak">on命令</strong></h1><p id="6df3" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">可重新排序列表的想法是能够在这里和那里移动子部件，也就是说，在我们的应用程序行话中，在这里和那里移动待办事项。所以运动背后的想法很简单:</p><ol class=""><li id="16e3" class="lu lv iq kz b la lw ld lx lg ly lk lz lo ma ls mb mc md me bi translated">当用户长按todo时，应用程序应该<strong class="kz ir">从其现有索引中移除</strong>todo，并将其保存在临时位置(或内存)中。</li><li id="2ca3" class="lu lv iq kz b la mf ld mg lg mh lk mi lo mj ls mb mc md me bi translated">当用户按住并在新的索引中插入悬停的待办事项时，应用程序应该<strong class="kz ir">在新的位置(或内存)插入</strong>待办事项。</li><li id="ba37" class="lu lv iq kz b la mf ld mg lg mh lk mi lo mj ls mb mc md me bi translated">当切换发生时，UI应该更新，用户应该能够看到变化。</li></ol><h1 id="cf87" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated"><strong class="ak"> setState() </strong></h1><p id="f79d" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这就是本文中一个新成员出现的地方，<strong class="kz ir"> setState() </strong>函数。这个函数告诉框架重新绘制屏幕来显示新的状态。</p><p id="acee" class="pw-post-body-paragraph kx ky iq kz b la lw jr lc ld lx ju lf lg mk li lj lk ml lm ln lo mm lq lr ls ij bi translated">这个函数只出现在state实现中，或者我们定义的新类中，通常和其他函数一样，除了它会触发一个重建以及你放入的任何定义。</p><p id="1718" class="pw-post-body-paragraph kx ky iq kz b la lw jr lc ld lx ju lf lg mk li lj lk ml lm ln lo mm lq lr ls ij bi translated">在我们的例子中，<strong class="kz ir">on order</strong>函数应该调用setState()函数来移动todos。请记住，<strong class="kz ir">on order</strong>是<strong class="kz ir">可重新排序列表的必需参数。</strong>下面是新的<strong class="kz ir">on order</strong>调用:</p><figure class="mp mq mr ms gt mt"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="d762" class="pw-post-body-paragraph kx ky iq kz b la lw jr lc ld lx ju lf lg mk li lj lk ml lm ln lo mm lq lr ls ij bi translated">现在，将所有这些放在一起，我们得到以下结果:</p><figure class="mp mq mr ms gt mt"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="8024" class="pw-post-body-paragraph kx ky iq kz b la lw jr lc ld lx ju lf lg mk li lj lk ml lm ln lo mm lq lr ls ij bi translated">这里是我们的<strong class="kz ir"> <em class="mn">非哑re可订购列表:</em> </strong></p><figure class="mp mq mr ms gt mt gh gi paragraph-image"><div class="gh gi na"><img src="../Images/b15657f7f034203ff789e6640c9f9548.png" data-original-src="https://miro.medium.com/v2/resize:fit:576/1*5Nkw5eoZaKkQAY1-tRXxlg.gif"/></div><figcaption class="mw mx gj gh gi my mz bd b be z dk translated">开始了。</figcaption></figure><p id="8037" class="pw-post-body-paragraph kx ky iq kz b la lw jr lc ld lx ju lf lg mk li lj lk ml lm ln lo mm lq lr ls ij bi translated">下面是最新<a class="ae lt" href="https://github.com/hydroweaver/flutter_simple_todo" rel="noopener ugc nofollow" target="_blank"> <strong class="kz ir">回购</strong> </a>的代码。</p><p id="3ea0" class="pw-post-body-paragraph kx ky iq kz b la lw jr lc ld lx ju lf lg mk li lj lk ml lm ln lo mm lq lr ls ij bi translated">查看下一个帖子<a class="ae lt" href="https://medium.com/@hydroweaver/making-a-flutter-todo-app-from-scratch-part-3-9bb7f1cf00af" rel="noopener"> <strong class="kz ir">这里</strong> </a>。</p></div></div>    
</body>
</html>