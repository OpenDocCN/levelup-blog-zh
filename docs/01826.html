<html>
<head>
<title>Singleton Design Pattern and hidden things</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">单体设计模式和隐藏的东西</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/singleton-design-pattern-and-hidden-things-95ab2ba4cfa1?source=collection_archive---------7-----------------------#2020-01-31">https://levelup.gitconnected.com/singleton-design-pattern-and-hidden-things-95ab2ba4cfa1?source=collection_archive---------7-----------------------#2020-01-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/05f17577a7a7418853e780d63f2bdaa4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*apLPqKGzxkcTOM5g"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">Stanislav Ivanitskiy 在<a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><div class=""/><p id="4144" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">本文将带你走过实现最常见的设计模式时的陷阱:Singleton </em></p><h1 id="8179" class="lf lg jj bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">履行</h1><h2 id="3e97" class="md lg jj bd lh me mf dn ll mg mh dp lp kr mi mj lt kv mk ml lx kz mm mn mb mo bi translated">1.急切初始化</h2><p id="c422" class="pw-post-body-paragraph kg kh jj ki b kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">如果程序总是需要一个实例，或者如果创建实例的时间/资源成本不是太大，程序员可以切换到急切初始化，当类被加载到JVM中时<strong class="ki jk">总是创建一个实例。</strong></p><figure class="mu mv mw mx gt iv"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="eace" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki jk">静态块初始化</strong></p><p id="e9b7" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这里使用静态块的主要优点是它支持单例类实例化的异常处理选项。</p><figure class="mu mv mw mx gt iv"><div class="bz fp l di"><div class="my mz l"/></div></figure><h2 id="5ace" class="md lg jj bd lh me mf dn ll mg mh dp lp kr mi mj lt kv mk ml lx kz mm mn mb mo bi translated"><strong class="ak"> 2。惰性初始化</strong></h2><figure class="mu mv mw mx gt iv"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="b3c9" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">当您的应用程序运行多线程时，您的代码可以随时在任何一行暂停。所以两个线程可能会运行在两个初始化块中。</em></p><p id="323f" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在多线程环境中，为了防止每个线程创建单例对象的另一个实例，从而产生并发问题，我们需要使用锁定机制。这可以通过<code class="fe na nb nc nd b">synchronized</code>关键字来实现。</p><figure class="mu mv mw mx gt iv"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="5613" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">每次调用<code class="fe na nb nc nd b">getInstance()</code>都会给我们带来额外的开销。<strong class="ki jk">我们如何避免这种情况？</strong></p><h2 id="4c66" class="md lg jj bd lh me mf dn ll mg mh dp lp kr mi mj lt kv mk ml lx kz mm mn mb mo bi translated"><strong class="ak">双重检查锁定设计模式</strong></h2><figure class="mu mv mw mx gt iv"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="d7fb" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你知道上面的代码对Java不起作用。我不是在开玩笑，你们中的许多人(包括我)已经一遍又一遍地这样实现了。</p><p id="9b4b" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">原因如下，请仔细阅读下面的链接:</p><div class="is it gp gr iu ne"><a href="http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html" rel="noopener  ugc nofollow" target="_blank"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd jk gy z fp nj fr fs nk fu fw ji bi translated">“双重检查锁定被破坏”声明</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">署名:David Bacon(IBM Research)Joshua Bloch(Javasoft)，Jeff Bogda，Cliff Click (Hotspot JVM项目)，Paul…</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">www.cs.umd.edu</p></div></div></div></a></div><div class="is it gp gr iu ne"><a href="https://en.wikipedia.org/wiki/Double-checked_locking" rel="noopener  ugc nofollow" target="_blank"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd jk gy z fp nj fr fs nk fu fw ji bi translated">双重检查锁定</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">在软件工程中，双重检查锁定(也称为“双重检查锁定优化”)是一种软件…</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">en.wikipedia.org</p></div></div></div></a></div><p id="9e36" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如何解决这个问题:简单地使用<code class="fe na nb nc nd b"><strong class="ki jk">volatile</strong></code>关键字。下面是双重检查锁定模式的真实版本:</p><figure class="mu mv mw mx gt iv"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="9564" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意局部变量<code class="fe na nb nc nd b">result</code>似乎是不必要的。这样做的效果是，在<code class="fe na nb nc nd b">sInstance</code>已经被初始化的情况下(即大多数时候)，volatile字段只被访问一次(由于<code class="fe na nb nc nd b">return result;</code>而不是<code class="fe na nb nc nd b">return sInstance;</code>)，这可以将方法的整体性能提高25%。</p><h2 id="99d1" class="md lg jj bd lh me mf dn ll mg mh dp lp kr mi mj lt kv mk ml lx kz mm mn mb mo bi translated"><strong class="ak">按需初始化持有者习语</strong></h2><figure class="mu mv mw mx gt iv"><div class="bz fp l di"><div class="my mz l"/></div></figure><p id="b5ed" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Java确保静态类加载器的线程安全属性。因此，当一个线程使用类<code class="fe na nb nc nd b">Helper</code>初始化一个对象时，没有其他线程可以来创建另一个对象。</p><p id="bf09" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上述方法也确保了惰性初始化属性。静态实例字段的初始化不会早于<code class="fe na nb nc nd b">SingletonHolder</code>类的加载和初始化。<code class="fe na nb nc nd b">SingletonHolder</code>类的加载和初始化不会早于它第一次被引用。最后，在调用<code class="fe na nb nc nd b">getSingletonInstance()</code>方法之前，<code class="fe na nb nc nd b">SingletonHolder</code>类首先被引用。这正是我们所需要的。</p><p id="0544" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki jk">枚举</strong></p><figure class="mu mv mw mx gt iv"><div class="bz fp l di"><div class="my mz l"/></div></figure><blockquote class="nn no np"><p id="edc9" class="kg kh le ki b kj kk kl km kn ko kp kq nq ks kt ku nr kw kx ky ns la lb lc ld im bi translated">这种方法在功能上等同于公共字段方法，只是它更简洁，免费提供序列化机制，并提供防止多重实例化的可靠保证，即使面对复杂的序列化或反射攻击。虽然这种方法尚未被广泛采用，但是单元素枚举类型是实现singleton的最佳方式。</p></blockquote><h1 id="2737" class="lf lg jj bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">序列化问题</h1><p id="5792" class="pw-post-body-paragraph kg kh jj ki b kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">序列化允许将对象存储在某个数据存储中，并在以后重新创建它。然而，当我们序列化一个单例类并多次调用反序列化时，我们最终会得到单例类的多个对象。</p><p id="9883" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了让序列化和singleton正常工作，我们必须在singleton类中引入<code class="fe na nb nc nd b">readResolve()</code>方法。方法让开发人员控制在反序列化时应该返回什么对象。</p><figure class="mu mv mw mx gt iv"><div class="bz fp l di"><div class="my mz l"/></div></figure><h1 id="d903" class="lf lg jj bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">克隆问题</h1><p id="e88a" class="pw-post-body-paragraph kg kh jj ki b kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz mt lb lc ld im bi translated">尽管我们已经采取了足够的预防措施来使单例对象作为单例对象工作，但是克隆对象仍然会复制它并导致一个重复的对象。可以使用对象的<code class="fe na nb nc nd b">clone()</code>方法构建单例对象的克隆。因此，建议重载Object类的<code class="fe na nb nc nd b">clone()</code>方法并抛出<code class="fe na nb nc nd b">CloneNotSupportedException</code>异常。</p><figure class="mu mv mw mx gt iv"><div class="bz fp l di"><div class="my mz l"/></div></figure></div><div class="ab cl nt nu hx nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="im in io ip iq"><h1 id="374f" class="lf lg jj bd lh li oa lk ll lm ob lo lp lq oc ls lt lu od lw lx ly oe ma mb mc bi translated">灵感</h1><ul class=""><li id="21a7" class="of og jj ki b kj mp kn mq kr oh kv oi kz oj ld ok ol om on bi translated">受quang光·thảo和他关于媒体上的单例设计模式的文章的启发。你可以在这里查看<a class="ae jg" href="https://blog.androidcafe.in/singleton-design-pattern-2c63dfcfccf2" rel="noopener ugc nofollow" target="_blank">。</a></li><li id="e29f" class="of og jj ki b kj oo kn op kr oq kv or kz os ld ok ol om on bi translated">也参考<a class="ae jg" href="https://javarevealed.wordpress.com/tag/singleton-and-serialization/" rel="noopener ugc nofollow" target="_blank">单例设计模式</a>。</li></ul><p id="c492" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">开心编码~</p></div></div>    
</body>
</html>