<html>
<head>
<title>DNS response in Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java中的DNS响应</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/dns-response-in-java-a6298e3cc7d9?source=collection_archive---------1-----------------------#2022-04-13">https://levelup.gitconnected.com/dns-response-in-java-a6298e3cc7d9?source=collection_archive---------1-----------------------#2022-04-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="39ff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Java文章中的<a class="ae kl" href="https://medium.com/@junkypic/dns-request-and-response-in-java-acbd51ad3467" rel="noopener"> DNS请求集中在请求部分。既然已经完成了，接下来的事情就是接收响应并实际解析它。</a></p><p id="4fe5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您对没有全部解释的代码更感兴趣，请跳到文章末尾。</p></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><p id="0d0d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我将坚持使用我在第一篇文章中已经使用过的工具。</p><p id="e149" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">快速提醒一下，DNS协议在邮件中“说话”。消息的格式，按照<a class="ae kl" href="https://datatracker.ietf.org/doc/html/rfc1035#section-4.1.1" rel="noopener ugc nofollow" target="_blank"> RFC1035第4.1.1节。</a>看起来是这样的</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="5b81" class="lc ld iq ky b gy le lf l lg lh">    +---------------------+<br/>    |        Header       |<br/>    +---------------------+<br/>    |       Question      | the question for the name server<br/>    +---------------------+<br/>    |        Answer       | RRs answering the question<br/>    +---------------------+<br/>    |      Authority      | RRs pointing toward an authority<br/>    +---------------------+<br/>    |      Additional     | RRs holding additional information<br/>    +---------------------+</span></pre><p id="9759" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将从响应的头部分开始。</p></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><p id="06f2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们能够解析任何东西之前，我们必须接收来自服务器的响应。</p><p id="0dc8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如前一篇文章所述，Java使用DatagramSockets和DatagramPackets通过UDP进行通信。</p><p id="5498" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们试着接收响应</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="ee18" class="lc ld iq ky b gy le lf l lg lh">byte[] response = new byte[1024];<br/>DatagramPacket packet = new DatagramPacket(response, response.length);<br/>socket.receive(packet);</span></pre><p id="90c5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">打印出一些信息</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="6d7c" class="lc ld iq ky b gy le lf l lg lh">System.<em class="li">out</em>.println("\n\nReceived: " + packet.getLength() + " bytes");<br/>for (int i = 0; i &lt; packet.getLength(); i++) {<br/>    System.<em class="li">out</em>.print(String.<em class="li">format</em>("%s", response[i]) + " ");<br/>}<br/>System.<em class="li">out</em>.println("\n");</span></pre><p id="1c6b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于medium.com域，我收到这个数据包</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="e836" class="lc ld iq ky b gy le lf l lg lh">Received: 60 bytes<br/>-5 46 -127 -128 0 1 0 2 0 0 0 0 6 109 101 100 105 117 109 3 99 111 109 0 0 1 0 1 -64 12 0 1 0 1 0 0 0 1 0 4 -94 -97 -104 4 -64 12 0 1 0 1 0 0 0 1 0 4 -94 -97 -103 4</span></pre><p id="938b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您请求该域的记录，您很可能会收到相同的数据包。</p><p id="ae45" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">解析响应</p></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><p id="ea2b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">按照请求，报头响应完全相同，只是各个部分包含不同的信息。</p><p id="8449" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">标题部分的格式如下</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="be01" class="lc ld iq ky b gy le lf l lg lh">     0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5<br/>    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+<br/>    |                      ID                       |<br/>    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+<br/>    |QR|   Opcode  |AA|TC|RD|RA|   Z    |   RCODE   |<br/>    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+<br/>    |                    QDCOUNT                    |<br/>    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+<br/>    |                    ANCOUNT                    |<br/>    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+<br/>    |                    NSCOUNT                    |<br/>    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+<br/>    |                    ARCOUNT                    |<br/>    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span></pre><p id="0f1a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了阅读标题部分中的信息，我们必须以适当的方式解析它。</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="b086" class="lc ld iq ky b gy le lf l lg lh">DataInputStream dataInputStream = new DataInputStream(new ByteArrayInputStream(response));</span></pre><p id="0c4c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将响应读入dataInputStream允许以更可控的方式进行解析。</p><p id="cd03" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">获取ID就像读取输入中的第一个缩写一样简单</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="6fe6" class="lc ld iq ky b gy le lf l lg lh">short ID = dataInputStream.readShort();</span></pre><p id="cdb2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当然，ID是随机生成的，所以不同的请求不可能得到相同的ID。</p><p id="fc52" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是，ID必须与请求中发送的ID相同。服务器只是用它来匹配不同的请求和正确的响应。</p><p id="2873" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">注意，readByte(或readInteger或任何其他read*)在DataInputStream的内部表示中移动光标，移动量等于读取的位数。在这种情况下，它将移动16位。因此，下一个readByte将读取标志的第一个字节(或8位)。当然，如果我们再做一次readShort，我们会阅读整个Flags部分。</strong></p><p id="13c9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">按照同样的逻辑，我们可以继续下一部分，标志部分。</p><p id="f7e6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个解析起来有点复杂，readByte会一次读取几个标志。必须做一点位移。</p><p id="11f9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们读QR</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="4f01" class="lc ld iq ky b gy le lf l lg lh">short flags = dataInputStream.readByte();<br/>int QR = (flags &amp; 0b10000000) &gt;&gt;&gt; 7;</span></pre><p id="77fa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">即使对于熟悉Java的人来说，位移也不是每天都会发生的事情，因为大部分繁重的工作都隐藏在抽象中。</p><p id="a502" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我使用了二进制来尽可能清楚地说明正在发生的事情。在一个数前面加上0b可以让你写出它的二进制表示。</p><p id="08db" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这种情况下，10000000是128，因此<strong class="jp ir">标志&amp; 128 </strong>的工作方式完全相同，但不太明显。</p><p id="6d00" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们再细分一下:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="8ef3" class="lc ld iq ky b gy le lf l lg lh">dataInputStream.readByte()</span></pre><p id="37d5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将读取响应中的第一个字节，紧跟在ID之后。</p><p id="adf1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设Flags部分的第一个字节用二进制表示，如下所示</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="c170" class="lc ld iq ky b gy le lf l lg lh">10000001</span></pre><p id="162a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以把上面的代码归结为</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="05b4" class="lc ld iq ky b gy le lf l lg lh">(10000001 &amp; 10000000) &gt;&gt;&gt; 7</span></pre><p id="ccd3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对上面的数字进行二进制AND (&amp;)运算会得到10000000，因为它从左到右依次取第一个数字的每一位，并以相同的顺序对第二个数字进行AND(&amp;)运算。</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="7fb9" class="lc ld iq ky b gy le lf l lg lh">10000001<br/>&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;<br/>10000000</span></pre><p id="0093" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，1&amp;1 == 1。既然真且真==真。下一位是0，因为false和false == false。最后一位，1&amp;0 == 0，因为true和false == false。</p><p id="936d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们把&amp;和一个非常具体的数字结合起来使用，这样我们在我们想要的比特上保持真实，但在我们不关心的比特上去掉真实。</p><p id="8cac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对这些数字(10000001 &amp; 10000000)进行“与”运算后，我们得到10000000。</p><p id="8818" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦我们得到了想要的结果，我们只需将第7位<strong class="jp ir">从第0位</strong>开始，向右侧 ( &gt; &gt; &gt;)移动(或移动)7个空格。</p><p id="1bfa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，我使用了<strong class="jp ir"> &gt; &gt; &gt; </strong>，不，这不是一个错误，是的，这是一个真实的事情，它被称为逻辑右移(相对于<code class="fe lj lk ll ky b">&gt;&gt;</code>算术右移)。对于那些来自其他语言的人来说，这可能没有意义。</p><p id="7d3e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Java没有显式的有符号数字。默认情况下，java中的每个数字都是带符号的。</p><p id="03ae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在算术移位中，符号位被扩展以保持数字的有符号性。</p><p id="878c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们真的不希望这样(虽然在这种情况下不应该有负数)，所以我们想删除符号，使其默认为无符号。</p><p id="4aea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于那些好奇的人来说，这个stackoverflow问题比我更好地解释了这个问题。</p><p id="9fcc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看看这种方法是如何迭代工作的</p><p id="81a5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第一次轮班将导致</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="94ff" class="lc ld iq ky b gy le lf l lg lh">01000000</span></pre><p id="5399" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第二次轮班将导致</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="c3b2" class="lc ld iq ky b gy le lf l lg lh">00100000</span></pre><p id="a781" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">依此类推，直到我们总共移位7次，结果是</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="b253" class="lc ld iq ky b gy le lf l lg lh">00000001</span></pre><p id="b1de" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是我们的第一个标志，根据上图，它是QR，指定消息是查询(0)还是响应(1)</p><p id="3cf5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">二进制数00000001实际上是十进制数中的1。这里的QR是一个响应。</p><p id="2801" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">既然我们知道了如何读取标志，我们必须简单地对所有其他标志遵循相同的逻辑</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="0381" class="lc ld iq ky b gy le lf l lg lh">short flags = dataInputStream.readByte();<br/>int QR = (flags &amp; 0b10000000) &gt;&gt;&gt; 7;<br/>int opCode = ( flags &amp; 0b01111000) &gt;&gt;&gt; 3;<br/>int AA = ( flags &amp; 0b00000100) &gt;&gt;&gt; 2;<br/>int TC = ( flags &amp; 0b00000010) &gt;&gt;&gt; 1;<br/>int RD = flags &amp; 0b00000001;<br/>System.<em class="li">out</em>.println("QR "+QR);<br/>System.<em class="li">out</em>.println("Opcode "+opCode);<br/>System.<em class="li">out</em>.println("AA "+AA);<br/>System.<em class="li">out</em>.println("TC "+TC);<br/>System.<em class="li">out</em>.println("RD "+RD);</span><span id="ea53" class="lc ld iq ky b gy lm lf l lg lh">flags = dataInputStream.readByte();<br/>int RA = (flags &amp; 0b10000000) &gt;&gt;&gt; 7;<br/>int Z = ( flags &amp; 0b01110000) &gt;&gt;&gt; 4;<br/>int RCODE = flags &amp; 0b00001111;<br/>System.<em class="li">out</em>.println("RA "+RA);<br/>System.<em class="li">out</em>.println("Z "+ Z);<br/>System.<em class="li">out</em>.println("RCODE " +RCODE);</span></pre><p id="878a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，在我自己的回答中，我得到:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="1e4c" class="lc ld iq ky b gy le lf l lg lh">QR 1<br/>Opcode 0<br/>AA 0<br/>TC 0<br/>RD 1<br/>RA 1<br/>Z 0<br/>RCODE 0</span></pre><p id="013c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用Wireshark，我可以拦截响应，并检查我的代码是否与Wireshark的代码一致。</p><figure class="kt ku kv kw gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi ln"><img src="../Images/84af9a4ec496d996634d347cb9612162.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R9YzW2gsg4vySsY4Xwajxg.png"/></div></div></figure><p id="bc59" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">事实上似乎是这样。</p><p id="b84e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们可以读取头部分的其余部分:QDCOUNT、ANCOUNT、NSCOUNT和ARCOUNT。</p><p id="6fbe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是读取下一个short的简单问题，因为每个条目正好是16位长。</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="a9f7" class="lc ld iq ky b gy le lf l lg lh">QDCOUNT = dataInputStream.readShort();<br/>ANCOUNT = dataInputStream.readShort();<br/>NSCOUNT = dataInputStream.readShort();<br/>ARCOUNT = dataInputStream.readShort();<br/><br/>System.<em class="li">out</em>.println("Questions: " + String.<em class="li">format</em>("%s",QDCOUNT ));<br/>System.<em class="li">out</em>.println("Answers RRs: " + String.<em class="li">format</em>("%s", ANCOUNT));<br/>System.<em class="li">out</em>.println("Authority RRs: " + String.<em class="li">format</em>("%s", NSCOUNT));<br/>System.<em class="li">out</em>.println("Additional RRs: " + String.<em class="li">format</em>("%s", ARCOUNT));</span></pre><p id="3371" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我的回答中</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="fb21" class="lc ld iq ky b gy le lf l lg lh">Questions: 1<br/>Answers RRs: 2<br/>Authority RRs: 0<br/>Additional RRs: 0</span></pre><figure class="kt ku kv kw gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi lv"><img src="../Images/1fcba1b3dd58eed66adfccb61e546c55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zNjBBy8NxzjyK_MeMvhe0A.png"/></div></div></figure><p id="c366" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">同样，我使用Wireshark验证结果。</p><p id="a340" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在来解析回答中的问题部分。</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="f784" class="lc ld iq ky b gy le lf l lg lh">     0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5<br/>    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+<br/>    |                                               |<br/>    /                     QNAME                     /<br/>    /                                               /<br/>    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+<br/>    |                     QTYPE                     |<br/>    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+<br/>    |                     QCLASS                    |<br/>    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span></pre><p id="62ce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这可以通过遵循RFC中的说明很容易地理解</p><p id="f675" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">QNAME — <em class="li">用一系列标签表示的域名，其中<br/>每个标签由一个长度八位字节和其后的<br/>个八位字节组成。域名以根的空标签的零长度八位字节<br/>终止。注意<br/>这个字段可能是奇数个八位字节；不使用<br/>填充。</em></p><p id="9a88" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以我们可以预期:一个特定的长度— label — 00 len octet来完成阅读。</p><p id="8687" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">简单地说，medium.com将会是</p><p id="7647" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">6介质3com0</p><p id="1ec7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">6 —下一个单词的总长度</p><p id="995a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">媒介——文字本身</p><p id="b498" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi">…</p><p id="180f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">0 —结束序列</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="eb63" class="lc ld iq ky b gy le lf l lg lh">String QNAME = "";<br/>int recLen;<br/>while ((recLen = dataInputStream.readByte()) &gt; 0) {<br/>    byte[] record = new byte[recLen];<br/>    for (int i = 0; i &lt; recLen; i++) {<br/>        record[i] = dataInputStream.readByte();<br/>    }<br/>    QNAME = new String(record, StandardCharsets.<em class="li">UTF_8</em>);<br/>}<br/>short QTYPE = dataInputStream.readShort();<br/>short QCLASS = dataInputStream.readShort();<br/>System.<em class="li">out</em>.println("Record: " + QNAME);<br/>System.<em class="li">out</em>.println("Record Type: " + String.<em class="li">format</em>("%s", QTYPE));<br/>System.<em class="li">out</em>.println("Class: " + String.<em class="li">format</em>("%s", QCLASS));</span></pre></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><p id="98b1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在有趣的部分来了。阅读回复的答案部分。</p><p id="c743" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第4.1.3节。RFC告诉我们</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="a8ae" class="lc ld iq ky b gy le lf l lg lh">The answer, authority, and additional sections all share the same<br/>format: a variable number of resource records, where the number of<br/>records is specified in the corresponding count field in the header.</span></pre><p id="71e7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以我们通过ANCOUNT、NSCOUNT和ARCOUNT知道每个部分有多少个条目。我们也知道它们是相同的格式。</p><p id="74ef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">说到格式，在这里(针对所有版块)。请注意，RDATA的格式取决于类型，因此在A记录和CNAME记录之间会有所不同。</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="2551" class="lc ld iq ky b gy le lf l lg lh">     0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5<br/>    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+<br/>    |                                               |<br/>    /                                               /<br/>    /                      NAME                     /<br/>    |                                               |<br/>    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+<br/>    |                      TYPE                     |<br/>    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+<br/>    |                     CLASS                     |<br/>    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+<br/>    |                      TTL                      |<br/>    |                                               |<br/>    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+<br/>    |                   RDLENGTH                    |<br/>    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--|<br/>    /                     RDATA                     /<br/>    /                                               /<br/>    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+</span></pre><p id="55b2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://datatracker.ietf.org/doc/html/rfc1035#section-4.1.4" rel="noopener ugc nofollow" target="_blank">第4.1.4节。</a>告诉我们如何阅读姓名条目。但长话短说:</p><ul class=""><li id="e20f" class="lw lx iq jp b jq jr ju jv jy ly kc lz kg ma kk mb mc md me bi translated">11的2位表示偏移的开始</li><li id="9baa" class="lw lx iq jp b jq mf ju mg jy mh kc mi kg mj kk mb mc md me bi translated">2位00代表实际标签</li><li id="b9c0" class="lw lx iq jp b jq mf ju mg jy mh kc mi kg mj kk mb mc md me bi translated">一直读到以00结尾</li></ul><p id="3505" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，我们必须阅读前两位，看看我们的立场。</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="defd" class="lc ld iq ky b gy le lf l lg lh">byte firstBytes = dataInputStream.readByte();<br/>int firstTwoBits = (firstBytes &amp; 0b11000000) &gt;&gt;&gt; 6;</span></pre><p id="c14d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">显然，这里我们假设我们从服务器得到了一个答案。更好的方法是检查ANCOUNT、NSCOUNT和ARCOUNT是否大于0。</p><p id="c265" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是为了这个练习的目的，我们知道ANCOUNT是2。</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="f4b0" class="lc ld iq ky b gy le lf l lg lh">for(int i = 0; i &lt; ANCOUNT; i++) {<br/>  if(firstTwoBits == 3) { // 00000011 first 2 bits<br/>      // more code here</span><span id="c771" class="lc ld iq ky b gy lm lf l lg lh">  }else if(firstTwoBits == 0){<br/>      System.<em class="li">out</em>.println("It's a label");<br/>  }<br/><br/>  firstBytes = dataInputStream.readByte();<br/>  firstTwoBits = (firstBytes &amp; 0b11000000) &gt;&gt;&gt; 6;</span><span id="d81d" class="lc ld iq ky b gy lm lf l lg lh">}</span></pre><p id="e8e5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">读取前2位，如果是11，则是偏移。</p><p id="87c2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，从0到100真的很快</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="c994" class="lc ld iq ky b gy le lf l lg lh">byte firstBytes = dataInputStream.readByte();<br/>int firstTwoBits = (firstBytes &amp; 0b11000000) &gt;&gt;&gt; 6;<br/><br/>ByteArrayOutputStream label = new ByteArrayOutputStream();<br/>Map&lt;String, String&gt; domainToIp = new HashMap&lt;&gt;();<br/><br/>for(int i = 0; i &lt; ANCOUNT; i++) {<br/>    if(firstTwoBits == 3) {<br/>        byte currentByte = dataInputStream.readByte();<br/>        boolean stop = false;<br/>        byte[] newArray = Arrays.<em class="li">copyOfRange</em>(response, currentByte, response.length);<br/>        DataInputStream sectionDataInputStream = new DataInputStream(new ByteArrayInputStream(newArray));<br/>        ArrayList&lt;Integer&gt; RDATA = new ArrayList&lt;&gt;();<br/>        ArrayList&lt;String&gt; DOMAINS = new ArrayList&lt;&gt;();<br/>        while(!stop) {<br/>            byte nextByte = sectionDataInputStream.readByte();<br/>            if(nextByte != 0) {<br/>                byte[] currentLabel = new byte[nextByte];<br/>                for(int j = 0; j &lt; nextByte; j++) {<br/>                    currentLabel[j] = sectionDataInputStream.readByte();<br/>                }<br/>                label.write(currentLabel);<br/>            } else {<br/>                stop = true;<br/>                short TYPE = dataInputStream.readShort();<br/>                short CLASS = dataInputStream.readShort();<br/>                int TTL = dataInputStream.readInt();<br/>                int RDLENGTH = dataInputStream.readShort();<br/>                for(int s = 0; s &lt; RDLENGTH; s++) {<br/>                    int nx = dataInputStream.readByte() &amp; 255;<br/>                    RDATA.add(nx);<br/>                }<br/><br/>                System.<em class="li">out</em>.println("Type: " + TYPE);<br/>                System.<em class="li">out</em>.println("Class: " + CLASS);<br/>                System.<em class="li">out</em>.println("Time to live: " + TTL);<br/>                System.<em class="li">out</em>.println("Rd Length: " + RDLENGTH);<br/>            }<br/><br/>            DOMAINS.add(label.toString(StandardCharsets.<em class="li">UTF_8</em>));<br/>            label.reset();<br/>        }<br/><br/>        StringBuilder ip = new StringBuilder();<br/>        StringBuilder domainSb = new StringBuilder();<br/>        for(Integer ipPart:RDATA) {<br/>            ip.append(ipPart).append(".");<br/>        }<br/><br/>        for(String domainPart:DOMAINS) {<br/>            if(!domainPart.equals("")) {<br/>                domainSb.append(domainPart).append(".");<br/>            }<br/>        }<br/>        String domainFinal = domainSb.toString();<br/>        String ipFinal = ip.toString();<br/>        domainToIp.put(ipFinal.substring(0, ipFinal.length()-1), domainFinal.substring(0, domainFinal.length()-1));<br/><br/>    }else if(firstTwoBits == 0){<br/>        System.<em class="li">out</em>.println("It's a label");<br/>    }<br/><br/>    firstBytes = dataInputStream.readByte();<br/>    firstTwoBits = (firstBytes &amp; 0b11000000) &gt;&gt;&gt; 6;<br/>}<br/><br/>domainToIp.forEach((key, value) -&gt; System.<em class="li">out</em>.println(key + " : " + value));</span></pre><p id="1107" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这导致了</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="23a7" class="lc ld iq ky b gy le lf l lg lh">Type: 1<br/>Class: 1<br/>Time to live: 291<br/>Rd Length: 4<br/>Type: 1<br/>Class: 1<br/>Time to live: 291<br/>Rd Length: 4<br/>162.159.153.4 : medium.com<br/>162.159.152.4 : medium.com</span></pre><figure class="kt ku kv kw gt lo gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/3fbe581b4c0dfc5338f21b9e0868d021.png" data-original-src="https://miro.medium.com/v2/resize:fit:862/format:webp/1*0KUfsh1yVoQspJIIxQcW9Q.png"/></div></figure><p id="5dc5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Wireshark再次同意我的结果。</p><p id="708b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是让我们仔细看看这里发生了什么，因为它很重要。</p><p id="ec89" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最重要的部分是域名的压缩。</p><p id="41dd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">感觉<a class="ae kl" href="https://datatracker.ietf.org/doc/html/rfc1035#section-4.1.4" rel="noopener ugc nofollow" target="_blank">第4.1.4节。</a>在解释这一点上做得比我好得多，但从上述章节中最重要的收获是这张图表</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="a400" class="lc ld iq ky b gy le lf l lg lh">For example, a datagram might need to use the domain names F.ISI.ARPA,<br/>FOO.F.ISI.ARPA, ARPA, and the root.  Ignoring the other fields of the<br/>message, these domain names might be represented as:</span><span id="cc7d" class="lc ld iq ky b gy lm lf l lg lh">       +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+<br/>    20 |           1           |           F           |<br/>       +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+<br/>    22 |           3           |           I           |<br/>       +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+<br/>    24 |           S           |           I           |<br/>       +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+<br/>    26 |           4           |           A           |<br/>       +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+<br/>    28 |           R           |           P           |<br/>       +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+<br/>    30 |           A           |           0           |<br/>       +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+<br/><br/>       +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+<br/>    40 |           3           |           F           |<br/>       +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+<br/>    42 |           O           |           O           |<br/>       +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+<br/>    44 | 1  1|                20                       |<br/>       +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+<br/><br/>       +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+<br/>    64 | 1  1|                26                       |<br/>       +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+<br/><br/>       +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+<br/>    92 |           0           |                       |<br/>       +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+<br/>The domain name for F.ISI.ARPA is shown at offset 20.  The domain name<br/>FOO.F.ISI.ARPA is shown at offset 40; this definition uses a pointer to<br/>concatenate a label for FOO to the previously defined F.ISI.ARPA.  The<br/>domain name ARPA is defined at offset 64 using a pointer to the ARPA<br/>component of the name F.ISI.ARPA at 20; note that this pointer relies on<br/>ARPA being the last label in the string at 20.</span></pre><p id="0951" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们的例子中，名称实际上是指向问题部分的QNAME的指针。为什么？因为完全是同一个领域，所以没有必要再写了(呵呵)。节省了响应中非常需要的空间。</p><p id="9fc2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我就不一一赘述了，因为它相当容易理解，只是乍一看有点吓人。然而，你们中的一些人可能已经注意到了这一小部分</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="22e2" class="lc ld iq ky b gy le lf l lg lh">for(int s = 0; s &lt; RDLENGTH; s++) {<br/>    int nx = dataInputStream.readByte() &amp; 255;<br/>    RDATA.add(nx);<br/>}</span></pre><p id="fb27" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">更具体地说</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="58f9" class="lc ld iq ky b gy le lf l lg lh">dataInputStream.readByte() &amp; 255;</span></pre><p id="7518" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是我们正在阅读的RDATA部分，专门针对A记录。</p><p id="05c0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每种记录类型都有自己特定的RDATA格式，所以以正确的方式读取它很重要。</p><p id="3444" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://datatracker.ietf.org/doc/html/rfc1035#section-3.4.1" rel="noopener ugc nofollow" target="_blank">第3.4.1节。</a>告诉我们，对于A记录，RDATA部分如下所示</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="3086" class="lc ld iq ky b gy le lf l lg lh">    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+<br/>    |                    ADDRESS                    |<br/>    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+<br/><br/>where:<br/><br/>ADDRESS         A 32 bit Internet address.</span></pre><p id="d830" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这很简单。</p><p id="febc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，IP地址(即IPv4)实际上是由一个点分隔的一系列4个字节。不幸的是，java没有带符号的数字(嗯…所有的整数类型都是带符号的(除了char)，它没有显式声明带符号的整数)，所以例如255.255.255.255 ip地址将溢出为负数(这可不好玩)，因为java字节保存的数字的最小值为-128，最大值为127(包括127)。</p><p id="9120" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，我们必须将其“下溢”回正确的数字。对11111111使用按位运算(&amp;)将得到正确的值。如果它已经是一个正确的值，它将保持原样。</p><p id="3077" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">其他部分NSCOUNT和ARCOUNT的读取方式与ANCOUNT完全相同，因为它们的格式完全相同。</p><p id="9ee8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当然，您必须记住，RDATA是特定于类型的。</p></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><p id="06bd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以及完整的代码，包括请求和响应</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="ad37" class="lc ld iq ky b gy le lf l lg lh">import java.io.*;<br/>import java.net.DatagramPacket;<br/>import java.net.DatagramSocket;<br/>import java.net.InetAddress;<br/>import java.nio.ByteBuffer;<br/>import java.nio.charset.StandardCharsets;<br/>import java.util.*;<br/><br/>public class Main {<br/>    private static final int <em class="li">DNS_SERVER_PORT </em>= 53;<br/><br/>    public static void main(String[] args) throws IOException {<br/><br/>        InetAddress ipAddress = InetAddress.<em class="li">getByName</em>("1.1.1.1");<br/><br/>        Random random = new Random();<br/>        short ID = (short)random.nextInt(32767);<br/>        System.<em class="li">out</em>.println(ID);<br/>        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();<br/>        DataOutputStream dataOutputStream = new DataOutputStream(byteArrayOutputStream);<br/><br/>        short requestFlags = Short.<em class="li">parseShort</em>("0000000100000000", 2);<br/>        ByteBuffer byteBuffer = ByteBuffer.<em class="li">allocate</em>(2).putShort(requestFlags);<br/>        byte[] flagsByteArray = byteBuffer.array();<br/><br/>        short QDCOUNT = 1;<br/>        short ANCOUNT = 0;<br/>        short NSCOUNT = 0;<br/>        short ARCOUNT = 0;<br/><br/>        dataOutputStream.writeShort(ID);<br/>        dataOutputStream.write(flagsByteArray);<br/>        dataOutputStream.writeShort(QDCOUNT);<br/>        dataOutputStream.writeShort(ANCOUNT);<br/>        dataOutputStream.writeShort(NSCOUNT);<br/>        dataOutputStream.writeShort(ARCOUNT);<br/>        String domain = "medium.com";<br/>        String[] domainParts = domain.split("\\.");<br/><br/>        for (int i = 0; i &lt; domainParts.length; i++) {<br/>            byte[] domainBytes = domainParts[i].getBytes(StandardCharsets.<em class="li">UTF_8</em>);<br/>            dataOutputStream.writeByte(domainBytes.length);<br/>            dataOutputStream.write(domainBytes);<br/>        }<br/>        // No more parts<br/>        dataOutputStream.writeByte(0);<br/>        // Type 0x01 = A (Host Request)<br/>        dataOutputStream.writeShort(1);<br/>        // Class 0x01 = IN<br/>        dataOutputStream.writeShort(1);<br/><br/>        byte[] dnsFrame = byteArrayOutputStream.toByteArray();<br/><br/>        System.<em class="li">out</em>.println("SendataInputStreamg: " + dnsFrame.length + " bytes");<br/>        for (int i = 0; i &lt; dnsFrame.length; i++) {<br/>            System.<em class="li">out</em>.print(String.<em class="li">format</em>("%s", dnsFrame[i]) + " ");<br/>        }<br/><br/>        DatagramSocket socket = new DatagramSocket();<br/>        DatagramPacket dnsReqPacket = new DatagramPacket(dnsFrame, dnsFrame.length, ipAddress, <em class="li">DNS_SERVER_PORT</em>);<br/>        socket.send(dnsReqPacket);<br/><br/><br/>        byte[] response = new byte[1024];<br/>        DatagramPacket packet = new DatagramPacket(response, response.length);<br/>        socket.receive(packet);<br/><br/>        System.<em class="li">out</em>.println("\n\nReceived: " + packet.getLength() + " bytes");<br/>        for (int i = 0; i &lt; packet.getLength(); i++) {<br/>            System.<em class="li">out</em>.print(String.<em class="li">format</em>("%s", response[i]) + " ");<br/>        }<br/>        System.<em class="li">out</em>.println("\n");<br/><br/>        DataInputStream dataInputStream = new DataInputStream(new ByteArrayInputStream(response));<br/>        System.<em class="li">out</em>.println("\n\nStart response decode");<br/>        System.<em class="li">out</em>.println("Transaction ID: " + dataInputStream.readShort()); // ID<br/>        short flags = dataInputStream.readByte();<br/>        int QR = (flags &amp; 0b10000000) &gt;&gt;&gt; 7;<br/>        int opCode = ( flags &amp; 0b01111000) &gt;&gt;&gt; 3;<br/>        int AA = ( flags &amp; 0b00000100) &gt;&gt;&gt; 2;<br/>        int TC = ( flags &amp; 0b00000010) &gt;&gt;&gt; 1;<br/>        int RD = flags &amp; 0b00000001;<br/>        System.<em class="li">out</em>.println("QR "+QR);<br/>        System.<em class="li">out</em>.println("Opcode "+opCode);<br/>        System.<em class="li">out</em>.println("AA "+AA);<br/>        System.<em class="li">out</em>.println("TC "+TC);<br/>        System.<em class="li">out</em>.println("RD "+RD);<br/>        flags = dataInputStream.readByte();<br/>        int RA = (flags &amp; 0b10000000) &gt;&gt;&gt; 7;<br/>        int Z = ( flags &amp; 0b01110000) &gt;&gt;&gt; 4;<br/>        int RCODE = flags &amp; 0b00001111;<br/>        System.<em class="li">out</em>.println("RA "+RA);<br/>        System.<em class="li">out</em>.println("Z "+ Z);<br/>        System.<em class="li">out</em>.println("RCODE " +RCODE);<br/><br/>        QDCOUNT = dataInputStream.readShort();<br/>        ANCOUNT = dataInputStream.readShort();<br/>        NSCOUNT = dataInputStream.readShort();<br/>        ARCOUNT = dataInputStream.readShort();<br/><br/>        System.<em class="li">out</em>.println("Questions: " + String.<em class="li">format</em>("%s",QDCOUNT ));<br/>        System.<em class="li">out</em>.println("Answers RRs: " + String.<em class="li">format</em>("%s", ANCOUNT));<br/>        System.<em class="li">out</em>.println("Authority RRs: " + String.<em class="li">format</em>("%s", NSCOUNT));<br/>        System.<em class="li">out</em>.println("Additional RRs: " + String.<em class="li">format</em>("%s", ARCOUNT));<br/><br/>        String QNAME = "";<br/>        int recLen;<br/>        while ((recLen = dataInputStream.readByte()) &gt; 0) {<br/>            byte[] record = new byte[recLen];<br/>            for (int i = 0; i &lt; recLen; i++) {<br/>                record[i] = dataInputStream.readByte();<br/>            }<br/>            QNAME = new String(record, StandardCharsets.<em class="li">UTF_8</em>);<br/>        }<br/>        short QTYPE = dataInputStream.readShort();<br/>        short QCLASS = dataInputStream.readShort();<br/>        System.<em class="li">out</em>.println("Record: " + QNAME);<br/>        System.<em class="li">out</em>.println("Record Type: " + String.<em class="li">format</em>("%s", QTYPE));<br/>        System.<em class="li">out</em>.println("Class: " + String.<em class="li">format</em>("%s", QCLASS));<br/><br/>        System.<em class="li">out</em>.println("\n\nstart answer, authority, and additional sections\n");<br/><br/>        byte firstBytes = dataInputStream.readByte();<br/>        int firstTwoBits = (firstBytes &amp; 0b11000000) &gt;&gt;&gt; 6;<br/><br/>        ByteArrayOutputStream label = new ByteArrayOutputStream();<br/>        Map&lt;String, String&gt; domainToIp = new HashMap&lt;&gt;();<br/><br/>        for(int i = 0; i &lt; ANCOUNT; i++) {<br/>            if(firstTwoBits == 3) {<br/>                byte currentByte = dataInputStream.readByte();<br/>                boolean stop = false;<br/>                byte[] newArray = Arrays.<em class="li">copyOfRange</em>(response, currentByte, response.length);<br/>                DataInputStream sectionDataInputStream = new DataInputStream(new ByteArrayInputStream(newArray));<br/>                ArrayList&lt;Integer&gt; RDATA = new ArrayList&lt;&gt;();<br/>                ArrayList&lt;String&gt; DOMAINS = new ArrayList&lt;&gt;();<br/>                while(!stop) {<br/>                    byte nextByte = sectionDataInputStream.readByte();<br/>                    if(nextByte != 0) {<br/>                        byte[] currentLabel = new byte[nextByte];<br/>                        for(int j = 0; j &lt; nextByte; j++) {<br/>                            currentLabel[j] = sectionDataInputStream.readByte();<br/>                        }<br/>                        label.write(currentLabel);<br/>                    } else {<br/>                        stop = true;<br/>                        short TYPE = dataInputStream.readShort();<br/>                        short CLASS = dataInputStream.readShort();<br/>                        int TTL = dataInputStream.readInt();<br/>                        int RDLENGTH = dataInputStream.readShort();<br/>                        for(int s = 0; s &lt; RDLENGTH; s++) {<br/>                            int nx = dataInputStream.readByte() &amp; 255;// and with 255 to<br/>                            RDATA.add(nx);<br/>                        }<br/><br/>                        System.<em class="li">out</em>.println("Type: " + TYPE);<br/>                        System.<em class="li">out</em>.println("Class: " + CLASS);<br/>                        System.<em class="li">out</em>.println("Time to live: " + TTL);<br/>                        System.<em class="li">out</em>.println("Rd Length: " + RDLENGTH);<br/>                    }<br/><br/>                    DOMAINS.add(label.toString(StandardCharsets.<em class="li">UTF_8</em>));<br/>                    label.reset();<br/>                }<br/><br/>                StringBuilder ip = new StringBuilder();<br/>                StringBuilder domainSb = new StringBuilder();<br/>                for(Integer ipPart:RDATA) {<br/>                    ip.append(ipPart).append(".");<br/>                }<br/><br/>                for(String domainPart:DOMAINS) {<br/>                    if(!domainPart.equals("")) {<br/>                        domainSb.append(domainPart).append(".");<br/>                    }<br/>                }<br/>                String domainFinal = domainSb.toString();<br/>                String ipFinal = ip.toString();<br/>                domainToIp.put(ipFinal.substring(0, ipFinal.length()-1), domainFinal.substring(0, domainFinal.length()-1));<br/><br/>            }else if(firstTwoBits == 0){<br/>                System.<em class="li">out</em>.println("It's a label");<br/>            }<br/><br/>            firstBytes = dataInputStream.readByte();<br/>            firstTwoBits = (firstBytes &amp; 0b11000000) &gt;&gt;&gt; 6;<br/>        }<br/><br/>        domainToIp.forEach((key, value) -&gt; System.<em class="li">out</em>.println(key + " : " + value));<br/>    }<br/>}</span></pre><p id="117a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你认为这看起来非常丑陋，我同意你的观点。</p><p id="f47f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">事实上，我计划上传一个更干净的版本到我的GitHub上。与此同时，如果出于某种原因你想要一个java dns，你可以使用<a class="ae kl" href="https://github.com/dnsjava/dnsjava" rel="noopener ugc nofollow" target="_blank"> dnsjava </a>。</p></div></div>    
</body>
</html>