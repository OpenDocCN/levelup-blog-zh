<html>
<head>
<title>Project structure and Building routes of RESTFUL API with Node.js, Express, MongoDB using TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用TypeScript的Node.js、Express、MongoDB的RESTFUL API的项目结构和构建路线</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/project-structure-and-building-routes-of-restful-api-with-node-js-f3a8b53d94e7?source=collection_archive---------0-----------------------#2020-04-12">https://levelup.gitconnected.com/project-structure-and-building-routes-of-restful-api-with-node-js-f3a8b53d94e7?source=collection_archive---------0-----------------------#2020-04-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/375add0fa33c1c03f0e375e244c8701d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*p-zoott5uZ8YR3ntSfz5vA.png"/></div></figure><p id="733a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">第1部分:<a class="ae ks" href="https://medium.com/@jpbinith/setup-restful-api-with-node-js-express-mongodb-using-typescript-261959ef0998" rel="noopener">设置REST API </a></p><p id="0391" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">第二部分:<a class="ae ks" href="https://medium.com/@jpbinith/project-structure-and-building-routes-of-restful-api-with-node-js-f3a8b53d94e7" rel="noopener">REST API中的项目结构和建设路线</a></p><p id="b36c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">第3部分:<a class="ae ks" href="https://medium.com/@jpbinith/connect-express-rest-api-with-mongodb-and-crud-operations-using-typescript-58d9afcc06d" rel="noopener">连接到MongoDB和CRUD操作</a></p></div><div class="ab cl kt ku hu kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ij ik il im in"><p id="8487" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在本文中，我将讨论如何为最佳实践维护项目结构，以及如何为您的第一个API实现路由。希望你会喜欢它。😃</p><p id="6da7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在阅读本文之前，请务必阅读我关于如何设置第一个REST API的文章。</p><p id="07b6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Express是制作Node.js REST APIs的一个很好的框架，但是它没有给你任何关于如何组织你的项目的线索。</p><p id="7f21" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">你可以随意使用任何你想要的结构。但是当你的代码库增长时，你最终会有长的处理程序。这使得你的代码难以理解，并且包含潜在的错误。</p><p id="b773" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">项目结构的正确组织将提高稳定性和效率，避免代码的重复，如果做得正确，还可以帮助您扩展服务。</p><p id="eec6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这就是我所说的项目结构。我在我构建的每个REST API服务中都使用它，让我们来详细看看每个组件是做什么的。</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="5893" class="lj lk iq lf b gy ll lm l ln lo">backend<br/>│<br/>└─── dist                   #all the javascript files are here<br/>└─── lib                    #all the typescript files are here<br/>      └─── config           #app configurations files<br/>            └─── app.ts     #app starting point<!-- -->            <br/>      └─── controllers      <!-- -->#request managers<br/>      └─── modules          #schemas, interfaces, services<br/>      └─── routes           #define the endpoints<br/>      └─── environment.ts   #store all environment variables<br/>      └─── server.js        #<!-- -->HTTP server that listens to server port<br/>└─── .gitignore             #git ignore file<br/>└─── package-lock.json      #npm automatically generated document<br/>└─── package.json           #holds metadata and npm packagage list<br/>└─── tsconfig.json          #<!-- -->specify the root level files and the                                              .                            compiler options</span></pre><p id="5c5b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这里，我在app.ts文件中执行MongoDB配置。如果你愿意，你也可以在一个单独的文件中完成。如果你能找到最适合你的项目结构，并在你的每个项目中保持最佳实践，那就更好了。</p></div><div class="ab cl kt ku hu kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ij ik il im in"><p id="9138" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们进入下一部分，为您的第一个RESTFUL API构建路径。</p><p id="c96e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">正如我在<a class="ae ks" href="https://medium.com/@jpbinith/setup-restful-api-with-node-js-express-mongodb-using-typescript-261959ef0998" rel="noopener">上一篇文章</a>中所说的，因为我们是用typescript开发的，所以我们在“<strong class="jw ir"> lib </strong>文件夹中实现所有的实现。所以首先你必须在'<strong class="jw ir"> lib </strong>文件夹中创建一个名为'<strong class="jw ir"> routes </strong>的文件夹。然后在'<strong class="jw ir"> routes </strong>'文件夹下创建一个文件，命名为'<strong class="jw ir"> test_routes.ts </strong>'。在该文件中复制并粘贴以下内容。</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="e71a" class="lj lk iq lf b gy ll lm l ln lo">//lib/routes/test_routes.ts<br/>import {Application, Request, Response } from 'express';</span><span id="2693" class="lj lk iq lf b gy lp lm l ln lo">export class TestRoutes {</span><span id="c377" class="lj lk iq lf b gy lp lm l ln lo">   public route(app: Application) {</span><span id="2481" class="lj lk iq lf b gy lp lm l ln lo">      app.get('/api/test', (req: Request, res: Response) =&gt; {<br/>         res.status(200).json({message: "Get request successfull"});<br/>      });</span><span id="a6e9" class="lj lk iq lf b gy lp lm l ln lo">      app.post('/api/test', (req: Request, res: Response) =&gt; {<br/>         res.status(200).json({message:"Post request successfull"});<br/>      });</span><span id="457c" class="lj lk iq lf b gy lp lm l ln lo">   }</span><span id="2c19" class="lj lk iq lf b gy lp lm l ln lo">}</span></pre><p id="13f3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在我们已经完成了第一条有两个端点的路由的构建。但是，它仍然不能正常工作。为什么？只是因为我们还没有把它连接到app模块上。这仍然是一个外部模块，应用程序不知道这个模块的存在。所以我们必须告诉应用程序包含这个模块。我们来看看怎么做。在我们完成集成并调用相关的端点之后，它会用状态代码200进行响应。</p><p id="4426" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们转到'<strong class="jw ir">配置</strong>文件夹中的'<strong class="jw ir"> app.ts </strong>文件。然后包括以下突出显示的行。</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="a0a7" class="lj lk iq lf b gy ll lm l ln lo">//lib/config/app.ts<br/>import * as express from "express";<br/>import * as bodyParser from "body-parser";<br/><strong class="lf ir">import { TestRoutes } from "../routes/test_routes";</strong></span><span id="3b44" class="lj lk iq lf b gy lp lm l ln lo">class App {</span><span id="3be1" class="lj lk iq lf b gy lp lm l ln lo">   public app: express.Application;<br/>   <strong class="lf ir">private test_routes: TestRoutes = new TestRoutes();</strong></span><span id="9b49" class="lj lk iq lf b gy lp lm l ln lo">   constructor() {<br/>      this.app = express();<br/>      this.config();<br/>      <strong class="lf ir">this.test_routes.route(this.app);</strong><br/>   }</span><span id="aba1" class="lj lk iq lf b gy lp lm l ln lo">   private config(): void {<br/>      // support application/json type post data<br/>      this.app.use(bodyParser.json());<br/>      //support application/x-www-form-urlencoded post data<br/>      this.app.use(bodyParser.urlencoded({ extended: false }));<br/>   }<br/>}<br/>export default new App().app;</span></pre><p id="9466" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在这里，我们创建了一个“<strong class="jw ir"> TestRoutes </strong>的实例，并将其导入到app模块的构造函数中。现在，当应用程序运行时，它知道路线的存在。让我们通过在终端上运行'<strong class="jw ir"> npm run dev </strong>'来启动我们的API。如果您已经使用'<strong class="jw ir"> npm run prod </strong>'启动了API，您可以通过在另一个终端上运行'<strong class="jw ir"> tsc </strong>'来重新启动它。</p><figure class="la lb lc ld gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi lq"><img src="../Images/3aa71e0f232f390cbda46653889c4f16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CMGLK79-z05AxViU7HicUQ.png"/></div></div></figure><p id="d5f1" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们使用<a class="ae ks" href="https://www.getpostman.com/apps" rel="noopener ugc nofollow" target="_blank"> Postman </a>向API发送一个GET和POST请求，并查看结果。(http://localhost:3000/api/test)</p><figure class="la lb lc ld gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi lv"><img src="../Images/897525cb54380e6799bb8d2a620cc023.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rANHj-_aKB66k5HNrvKvoQ.png"/></div></div></figure><figure class="la lb lc ld gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi lv"><img src="../Images/897525cb54380e6799bb8d2a620cc023.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rANHj-_aKB66k5HNrvKvoQ.png"/></div></div></figure><p id="43a7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">因此我们可以看到我们的端点(http://localhost:3000/api/test)正在完美地工作。让我们看看，如果我们向除此端点之外任何其他端点发送请求，会发生什么。</p><figure class="la lb lc ld gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi lv"><img src="../Images/546ea71c77d87449dcdb46a4f68712b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pMuCbCzZR2NMNVdUXKkiSQ.png"/></div></div></figure><p id="7874" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">因此它将返回状态为404的错误消息。我们来看看怎么处理。</p><p id="aa45" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在'<strong class="jw ir"> routes </strong>'文件夹中创建另一个名为'<strong class="jw ir"> common_routes.ts </strong>的文件，复制并粘贴以下内容。</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="1b22" class="lj lk iq lf b gy ll lm l ln lo">//lib/routes/common_routes.ts<br/>import { Application, Request, Response } from 'express';</span><span id="e6ab" class="lj lk iq lf b gy lp lm l ln lo">export class CommonRoutes {</span><span id="98b5" class="lj lk iq lf b gy lp lm l ln lo">   public route(app: Application) {</span><span id="a804" class="lj lk iq lf b gy lp lm l ln lo">      // Mismatch URL<br/>      app.all('*', function (req: Request, res: Response) {<br/>         res.status(404).send({ error: true, message: 'Check your URL please' });</span><span id="9fe0" class="lj lk iq lf b gy lp lm l ln lo">      });<br/>   }<br/>}</span></pre><p id="1b34" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在如上所述将其添加到'<strong class="jw ir"> app.ts </strong>'文件中。但是要确保它总是作为构造函数中的最后一条路径。现在运行它，看看结果。</p><blockquote class="lw lx ly"><p id="074b" class="ju jv lz jw b jx jy jz ka kb kc kd ke ma kg kh ki mb kk kl km mc ko kp kq kr ij bi translated"><strong class="jw ir">使用CRUD？</strong></p></blockquote><p id="545e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">CRUD代表创建、读取、更新和删除。关于它在REST API中的使用，CRUD是HTTP请求的标准化使用。</p><ul class=""><li id="d4a7" class="md me iq jw b jx jy kb kc kf mf kj mg kn mh kr mi mj mk ml bi translated">获取:用于检索数据</li><li id="d81e" class="md me iq jw b jx mm kb mn kf mo kj mp kn mq kr mi mj mk ml bi translated">发布:用于创建新数据</li><li id="f2bd" class="md me iq jw b jx mm kb mn kf mo kj mp kn mq kr mi mj mk ml bi translated">上传/修补:用于更新数据</li><li id="5b35" class="md me iq jw b jx mm kb mn kf mo kj mp kn mq kr mi mj mk ml bi translated">删除:用于删除数据</li></ul><blockquote class="lw lx ly"><p id="b83b" class="ju jv lz jw b jx jy jz ka kb kc kd ke ma kg kh ki mb kk kl km mc ko kp kq kr ij bi translated"><strong class="jw ir">状态码的使用？</strong></p></blockquote><p id="d8da" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在监控时，通过应用程序的状态代码可以更容易地了解应用程序的健康状况。然而，对于一些REST服务，HTTP状态代码没有很好地定义。</p><p id="a87a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">任何HTTP请求最常用的代码是:<br/> 200 — OK <br/> 404 —找不到<br/> 500 —内部服务器错误</p><p id="5332" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果需要，可以扩展到一组更详细的状态，例如:<br/>201-已创建<br/>204-无内容<br/>304-已修改<br/>400-错误请求<br/>401-未授权<br/>403-禁止<br/>501-未实现</p><p id="1ab6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">甚至你可以使用任何状态的任何代码。但是，如果您遵循最佳实践的标准，效果会更好。</p></div><div class="ab cl kt ku hu kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ij ik il im in"><p id="6516" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这是这篇文章的结尾，希望你能理解一切。在下一篇关于实现MongoDB的文章中，我们将会看到关于控制器使用的内容。</p><p id="6304" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">完整代码请访问我的<a class="ae ks" href="https://github.com/jpbinith/test-project" rel="noopener ugc nofollow" target="_blank"> Github库</a>。如果你感兴趣，你可以从下面的文章中学习关于Node Express REST APIs的移动。</p><ol class=""><li id="48ad" class="md me iq jw b jx jy kb kc kf mf kj mg kn mh kr mr mj mk ml bi translated"><a class="ae ks" href="https://medium.com/@jpbinith/setup-restful-api-with-node-js-express-mongodb-using-typescript-261959ef0998" rel="noopener">设置REST API </a></li><li id="96e3" class="md me iq jw b jx mm kb mn kf mo kj mp kn mq kr mr mj mk ml bi translated"><a class="ae ks" href="https://medium.com/@jpbinith/project-structure-and-building-routes-of-restful-api-with-node-js-f3a8b53d94e7" rel="noopener">REST API</a>项目结构和建设路线</li><li id="3bde" class="md me iq jw b jx mm kb mn kf mo kj mp kn mq kr mr mj mk ml bi translated"><a class="ae ks" href="https://medium.com/@jpbinith/connect-express-rest-api-with-mongodb-and-crud-operations-using-typescript-58d9afcc06d" rel="noopener">连接到MongoDB和CRUD操作</a></li></ol></div></div>    
</body>
</html>