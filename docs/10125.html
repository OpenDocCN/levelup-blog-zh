<html>
<head>
<title>Keep Your Assertions Focused</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">保持你的主张的重点</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/keep-your-assertions-focused-9d3f0dc74c38?source=collection_archive---------5-----------------------#2021-10-28">https://levelup.gitconnected.com/keep-your-assertions-focused-9d3f0dc74c38?source=collection_archive---------5-----------------------#2021-10-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="50f0" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><a class="ae ep" href="https://gentille.us/b3601fb73472?sk=0dc73c81df810c0f181c432c9db3e085" rel="noopener ugc nofollow" target="_blank"> JavaScript和类型脚本测试</a></h2><div class=""/><div class=""><h2 id="db2f" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">处理复杂对象的单元测试应该只断言由测试操作的对象部分。</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ko"><img src="../Images/5710ac3b1c87324bc1307aac39bb7af4.png" data-original-src="https://miro.medium.com/v2/resize:fit:840/format:webp/1*27TPyjAoEFhFKXeYsTvQHg.jpeg"/></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">寻找物体的正确部分</figcaption></figure><h1 id="c42a" class="la lb iq bd lc ld le lf lg lh li lj lk kf ll kg lm ki ln kj lo kl lp km lq lr bi translated">目标受众</h1><p id="1c96" class="pw-post-body-paragraph ls lt iq lu b lv lw ka lx ly lz kd ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">虽然任何编写单元测试的开发人员都可以从本文中受益，但本文的目标读者是熟悉使用mocha/chai/sinon测试工具套件进行单元测试的JavaScript/TypeScript开发人员。</p><h1 id="2c8e" class="la lb iq bd lc ld le lf lg lh li lj lk kf ll kg lm ki ln kj lo kl lp km lq lr bi translated">问题是</h1><p id="864c" class="pw-post-body-paragraph ls lt iq lu b lv lw ka lx ly lz kd ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">我测试了一些不返回任何东西的代码，但是构造了一个复杂的对象并把它传递给了一个API。这意味着单元测试需要测试存根是用预期的对象调用的。虽然我可以编写所有的测试来每次比较整个对象，但这会使测试更难阅读和维护。我想只测试对象中发生变化的部分。在我将在这里强调的特殊情况下，我想深入研究包含一组对象的单个属性。此外，我只想查看数组中一个元素的一个属性。</p><h1 id="c918" class="la lb iq bd lc ld le lf lg lh li lj lk kf ll kg lm ki ln kj lo kl lp km lq lr bi translated">被测单元</h1><p id="3bd1" class="pw-post-body-paragraph ls lt iq lu b lv lw ka lx ly lz kd ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">为了保持对解决方案的关注，我展示的代码是人为的。这是测试中的单元:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/2655b315a15b9198ceabfb6707d5bc7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1070/format:webp/1*m-4fr970UlBdMW_LQ4DDgg.png"/></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">doLogging()测试中的单元</figcaption></figure><p id="5fc8" class="pw-post-body-paragraph ls lt iq lu b lv mp ka lx ly mq kd ma mb mr md me mf ms mh mi mj mt ml mm mn ij bi translated">我们想要测试<code class="fe mu mv mw mx b">doLogging()</code>，但是我们需要剔除导入的<code class="fe mu mv mw mx b">logAnObject()</code>函数。这里<code class="fe mu mv mw mx b">logAnObject()</code>只是将对象登录到终端，但是我们可以想象在一个真实的应用程序中，我们可能会调用API或者写入数据库。</p><h1 id="15ce" class="la lb iq bd lc ld le lf lg lh li lj lk kf ll kg lm ki ln kj lo kl lp km lq lr bi translated">样本对象</h1><p id="017c" class="pw-post-body-paragraph ls lt iq lu b lv lw ka lx ly lz kd ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">查看示例对象将有助于全面理解解决方案。同样，这是非常人为的，真实世界的例子往往要复杂得多。此外，导出的接口通常不会包含在测试数据中，但在此将其包含在内是为了帮助理解。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi my"><img src="../Images/6344d729b30f5c545e92ef82129ba92b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1188/format:webp/1*7dEbjuPXw767sW2NheaO9w.png"/></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">样本测试对象</figcaption></figure><p id="3dca" class="pw-post-body-paragraph ls lt iq lu b lv mp ka lx ly mq kd ma mb mr md me mf ms mh mi mj mt ml mm mn ij bi translated">有两个测试目标:</p><ol class=""><li id="56bb" class="mz na iq lu b lv mp ly mq mb nb mf nc mj nd mn ne nf ng nh bi translated">测试<code class="fe mu mv mw mx b">topLevelProperty</code>是否具有预期值。</li><li id="908f" class="mz na iq lu b lv ni ly nj mb nk mf nl mj nm mn ne nf ng nh bi translated">测试<code class="fe mu mv mw mx b">topLevelArray[0].prop2 </code>是否有预期值</li></ol><p id="a837" class="pw-post-body-paragraph ls lt iq lu b lv mp ka lx ly mq kd ma mb mr md me mf ms mh mi mj mt ml mm mn ij bi translated">在生产代码中，设置这些属性会涉及到某种类型的逻辑，我们将验证这种逻辑。</p><h1 id="0327" class="la lb iq bd lc ld le lf lg lh li lj lk kf ll kg lm ki ln kj lo kl lp km lq lr bi translated">解决方案</h1><p id="0cfe" class="pw-post-body-paragraph ls lt iq lu b lv lw ka lx ly lz kd ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">这里有很多设置，但回报只是几行代码。</p><p id="6086" class="pw-post-body-paragraph ls lt iq lu b lv mp ka lx ly mq kd ma mb mr md me mf ms mh mi mj mt ml mm mn ij bi translated">目标1:解决方案是第23行。我们可以使用<code class="fe mu mv mw mx b">calledWithMatch</code>断言来指定我们只关心传入的对象有一个名为<code class="fe mu mv mw mx b">topLevelProperty</code>的属性，并且该属性应该有一个值<code class="fe mu mv mw mx b">another top level property.</code>。传入的对象可以有其他属性，但是我们只关心这一个属性。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="no np di nq bf nr"><div class="gh gi nn"><img src="../Images/f02961a943e2b7d266fb49cee919bf51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jRmCM-K8Qbwcg9VFivLaLg.png"/></div></div></figure><p id="7be4" class="pw-post-body-paragraph ls lt iq lu b lv mp ka lx ly mq kd ma mb mr md me mf ms mh mi mj mt ml mm mn ij bi translated">第26行和第27行实现了目标2。我们再次使用<code class="fe mu mv mw mx b">calledWithMatch()</code>来允许对象上存在其他属性。在这种情况下，我们指定保存数组的属性名。然后在数组内部，我们使用<code class="fe mu mv mw mx b">sinon.match()</code>函数来指定一个匹配的属性。这个数组中可能有其他元素，每个元素中可能有其他属性。</p></div><div class="ab cl ns nt hu nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ij ik il im in"><p id="7f87" class="pw-post-body-paragraph ls lt iq lu b lv mp ka lx ly mq kd ma mb mr md me mf ms mh mi mj mt ml mm mn ij bi translated">如果你发现自己喜欢这种技术，并且希望在sinon不参与的情况下也能做类似的事情，不要错过<a class="ae nz" rel="noopener ugc nofollow" target="_blank" href="/keep-your-assertions-focused-part-ii-3cddadcb36fe"> <em class="oa">保持你的断言重点:第二部分</em> </a> <em class="oa">。</em></p><p id="ebe0" class="pw-post-body-paragraph ls lt iq lu b lv mp ka lx ly mq kd ma mb mr md me mf ms mh mi mj mt ml mm mn ij bi translated">还有更多<a class="ae nz" href="https://gentille.us/b3601fb73472?sk=0dc73c81df810c0f181c432c9db3e085" rel="noopener ugc nofollow" target="_blank"> JavaScript/TypeScript测试</a>技巧文章。</p><p id="ca32" class="pw-post-body-paragraph ls lt iq lu b lv mp ka lx ly mq kd ma mb mr md me mf ms mh mi mj mt ml mm mn ij bi translated">平静地编码。</p></div></div>    
</body>
</html>