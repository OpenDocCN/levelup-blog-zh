<html>
<head>
<title>Mastering Computed Properties in VueJS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">掌握VueJS中的计算属性</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/mastering-computed-properties-in-vuejs-82a60dfcbaef?source=collection_archive---------0-----------------------#2019-01-27">https://levelup.gitconnected.com/mastering-computed-properties-in-vuejs-82a60dfcbaef?source=collection_archive---------0-----------------------#2019-01-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/0868bafa1339419348022a5fcad88fa2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1kEqnHmBfiqp91XLCyoiVA.jpeg"/></div></div></figure><div class=""/><p id="7be6" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于一个程序员来说，没有什么比盯着一段代码，花上几年的时间去破译到底发生了什么更令人沮丧的了。在VueJS中工作时，最常见的使代码混乱的方法之一是在模板中添加很长的表达式。例如，假设我们想要呈现一个反转的字符串，没有空格，全部大写。如果我们使用一个模板内表达式来做这件事，它看起来会像这样。</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="b56b" class="lf lg jb lb b gy lh li l lj lk">&lt;span&gt;</span><span id="f972" class="lf lg jb lb b gy ll li l lj lk">   {{text.replace(‘ ‘, ‘’).reverse().toUpperCase()}}</span><span id="895a" class="lf lg jb lb b gy ll li l lj lk">&lt;/span&gt;</span></pre><p id="e277" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在你可能比我更像一个CS专业人员，但是这对于我来说太杂乱了，以至于我看一眼就知道它在做什么。现在想象一下，必须在一个模板的多个地方使用这个值，并且在代码中使用这个长表达式。这就是使用VueJS的计算属性的时候了。</p><h1 id="a30d" class="lm lg jb bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">好的，但是它们是如何工作的呢？</h1><p id="2c42" class="pw-post-body-paragraph jy jz jb ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">现在我们知道了为什么计算属性是有用的，让我们回顾一下如何使用它们。用最基本的术语来说，我们只是在Javascript导出中添加一个字段，并在那里定义我们的计算属性。对于上面的例子，它看起来像这样。</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="db5c" class="lf lg jb lb b gy lh li l lj lk">export default {</span><span id="1b7b" class="lf lg jb lb b gy ll li l lj lk">   data () {</span><span id="ea8a" class="lf lg jb lb b gy ll li l lj lk">      text: ‘hello world’</span><span id="1dbb" class="lf lg jb lb b gy ll li l lj lk">   },</span><span id="7a78" class="lf lg jb lb b gy ll li l lj lk">   computed {</span><span id="afc1" class="lf lg jb lb b gy ll li l lj lk">      formattedText: function () {</span><span id="a4c4" class="lf lg jb lb b gy ll li l lj lk">         return this.text.replace(‘ ‘, ‘’).reverse().toUpperCase()</span><span id="0ef6" class="lf lg jb lb b gy ll li l lj lk">      }</span><span id="a112" class="lf lg jb lb b gy ll li l lj lk">   }</span><span id="5770" class="lf lg jb lb b gy ll li l lj lk">}</span></pre><p id="0c6d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">既然我们已经定义了计算属性，那么在模板中呈现它就变得非常容易了。这就是我们要做的一切。</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="c4d6" class="lf lg jb lb b gy lh li l lj lk">&lt;span&gt;</span><span id="cb06" class="lf lg jb lb b gy ll li l lj lk">   {{ formattedText }}</span><span id="974e" class="lf lg jb lb b gy ll li l lj lk">&lt;/span&gt;</span></pre><p id="7ea7" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">就是这样。现在，在我们的网页上，我们应该以一种更加清晰易读的方式来呈现DLROWOLLEH。使用计算属性总是使您的项目更具可伸缩性，因为如果我们想要更改呈现的值，我们只需更改计算属性，而不必遍历并更改整个模板中的每个表达式。</p><h1 id="795b" class="lm lg jb bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">那么，计算出的属性到底什么时候改变呢？</h1><p id="cc95" class="pw-post-body-paragraph jy jz jb ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">对于我们的例子，formattedText总是依赖于Text的值。因此，如果我们要将文本更改为“ABCDEF”，那么formattedText将返回“FEDCBA”。然而，为了更有效地运行，VueJS缓存计算的属性值。VueJS只会在依赖关系改变时重新计算属性。在我们的例子中，它只会在文本改变时重新计算。否则，它将返回上次更改的缓存值。</p><p id="cdd9" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了完全理解计算属性何时会改变，我们必须理解它们的依赖关系。简单地说，计算属性的依赖项是帮助属性确定返回值的值。如果这些都没有改变，那么将再次返回缓存的值。</p><blockquote class="mo mp mq"><p id="387c" class="jy jz mr ka b kb kc kd ke kf kg kh ki ms kk kl km mt ko kp kq mu ks kt ku kv ij bi translated"><strong class="ka jc">如果没有改变依赖关系，则不会重新计算计算属性。</strong></p></blockquote><p id="ee77" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">VueJS文档中的以下示例显示了一个永远不会重新计算的计算属性。</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="3267" class="lf lg jb lb b gy lh li l lj lk">computed: {</span><span id="8640" class="lf lg jb lb b gy ll li l lj lk">   now: function () {</span><span id="37de" class="lf lg jb lb b gy ll li l lj lk">      return new Date()</span><span id="5cf3" class="lf lg jb lb b gy ll li l lj lk">   }</span><span id="73c7" class="lf lg jb lb b gy ll li l lj lk">}</span></pre><p id="ab4e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">尽管computed属性现在返回一个一直在变化的值，但是VueJS并不关注依赖项。因此，它永远不会重新计算。</p><p id="9305" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你不喜欢这样，你可以使用常规的VueJS方法，默认情况下，每次渲染时都会重新计算。</p><h1 id="97d6" class="lm lg jb bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">您还可以为计算属性定义一个setter</h1><p id="7284" class="pw-post-body-paragraph jy jz jb ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">默认情况下，计算属性是只读的，不能设置。但是，如果您想为计算属性添加一个钩子，以允许设置它的依赖项。你要做的就是下面这些。</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="e8dc" class="lf lg jb lb b gy lh li l lj lk">computed: {</span><span id="1e5b" class="lf lg jb lb b gy ll li l lj lk">   formattedText: function () {</span><span id="568f" class="lf lg jb lb b gy ll li l lj lk">      get: function () {</span><span id="c653" class="lf lg jb lb b gy ll li l lj lk">         return this.text.replace(‘ ‘, ‘’).reverse().toUpperCase()</span><span id="25c3" class="lf lg jb lb b gy ll li l lj lk">      },</span><span id="3146" class="lf lg jb lb b gy ll li l lj lk">      set: function (value) {</span><span id="8fc4" class="lf lg jb lb b gy ll li l lj lk">         this.text = value;</span><span id="5348" class="lf lg jb lb b gy ll li l lj lk">      }</span><span id="95a2" class="lf lg jb lb b gy ll li l lj lk">   }</span><span id="9b97" class="lf lg jb lb b gy ll li l lj lk">}</span></pre><h1 id="8b48" class="lm lg jb bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">计算属性与观察器有何不同？</h1><p id="b538" class="pw-post-body-paragraph jy jz jb ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">计算属性和观察器都能够基于数据更新值。虽然所有计算属性都可以使用观察器编写，但使用计算属性通常更具可读性和效率。以下面的例子为例，首先编写为观察器，然后编写为计算属性。</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="c6f4" class="lf lg jb lb b gy lh li l lj lk">export {</span><span id="25ec" class="lf lg jb lb b gy ll li l lj lk">   data () {</span><span id="f5e7" class="lf lg jb lb b gy ll li l lj lk">      return {</span><span id="b90b" class="lf lg jb lb b gy ll li l lj lk">         name: ‘Matt’,</span><span id="e9bc" class="lf lg jb lb b gy ll li l lj lk">         age: 19,</span><span id="cc84" class="lf lg jb lb b gy ll li l lj lk">         output: ‘’</span><span id="fed8" class="lf lg jb lb b gy ll li l lj lk">      }</span><span id="81af" class="lf lg jb lb b gy ll li l lj lk">   },</span><span id="15be" class="lf lg jb lb b gy ll li l lj lk">   watch: {</span><span id="ffa8" class="lf lg jb lb b gy ll li l lj lk">      name: function (val) {</span><span id="bdd0" class="lf lg jb lb b gy ll li l lj lk">         this.output = this.name + ‘ is ‘ + this.age + ‘ years old.’</span><span id="91b8" class="lf lg jb lb b gy ll li l lj lk">      },</span><span id="b87e" class="lf lg jb lb b gy ll li l lj lk">      age: function (val) {</span><span id="3665" class="lf lg jb lb b gy ll li l lj lk">         this.output = this.name + ‘ is ‘ + this.age + ‘ years old.’</span><span id="d2cf" class="lf lg jb lb b gy ll li l lj lk">      }</span><span id="2cd2" class="lf lg jb lb b gy ll li l lj lk">   }</span><span id="b084" class="lf lg jb lb b gy ll li l lj lk">}</span><span id="d9c4" class="lf lg jb lb b gy ll li l lj lk">// Now as a computed property</span><span id="cf95" class="lf lg jb lb b gy ll li l lj lk">export {</span><span id="64a0" class="lf lg jb lb b gy ll li l lj lk">   data () {</span><span id="d47d" class="lf lg jb lb b gy ll li l lj lk">      return {</span><span id="800c" class="lf lg jb lb b gy ll li l lj lk">         name: ‘Matt’,</span><span id="3c24" class="lf lg jb lb b gy ll li l lj lk">         age: 19</span><span id="c97e" class="lf lg jb lb b gy ll li l lj lk">      }</span><span id="3092" class="lf lg jb lb b gy ll li l lj lk">   },</span><span id="1086" class="lf lg jb lb b gy ll li l lj lk">   computed: {</span><span id="69e0" class="lf lg jb lb b gy ll li l lj lk">      nameAndAge: function () {</span><span id="01ea" class="lf lg jb lb b gy ll li l lj lk">         return this.name + ‘ is ‘ + this.age + ‘ years old.’</span><span id="5db9" class="lf lg jb lb b gy ll li l lj lk">      }</span><span id="9ce8" class="lf lg jb lb b gy ll li l lj lk">   }</span><span id="898a" class="lf lg jb lb b gy ll li l lj lk">}</span></pre><p id="1c2a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如您所见，computed属性要简单得多，冗余性也小得多，同时在数据发生变化时仍能提供相同的响应能力。</p><h1 id="c61d" class="lm lg jb bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">给你。</h1><p id="2d7e" class="pw-post-body-paragraph jy jz jb ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">您应该具备使用计算属性的所有基础知识。希望这有助于您精简代码，使其更具可读性和易于理解。让我知道你有什么建议！</p></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><figure class="kw kx ky kz gt is gh gi paragraph-image"><a href="https://levelup.gitconnected.com"><div class="gh gi nc"><img src="../Images/9914c5dd23ac08b70eea6f4f9ba6fed2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E6CoI_MRyZ1JInNPsBSHtA.png"/></div></a></figure><div class="ip iq gp gr ir nd"><a href="https://gitconnected.com/learn/vue-js" rel="noopener  ugc nofollow" target="_blank"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd jc gy z fp ni fr fs nj fu fw ja bi translated">学习Vue.js -最佳Vue.js教程(2019) | gitconnected</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">27大Vue.js教程-免费学习Vue.js。课程由开发人员提交并投票，使您能够…</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">gitconnected.com</p></div></div><div class="nm l"><div class="nn l no np nq nm nr ix nd"/></div></div></a></div><p id="a414" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你有兴趣了解更多关于Vue 3的知识，请下载我的免费Vue 3备忘单，里面有一些基本知识，比如合成API、Vue 3模板语法和事件处理。</p></div></div>    
</body>
</html>