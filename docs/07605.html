<html>
<head>
<title>Azure Functions Best Practice — Reuse Client Instances, In Two Different Ways</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Azure Functions最佳实践——以两种不同的方式重用客户端实例</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/azure-functions-best-practice-reuse-client-instances-in-two-different-ways-9482841d3131?source=collection_archive---------1-----------------------#2021-02-28">https://levelup.gitconnected.com/azure-functions-best-practice-reuse-client-instances-in-two-different-ways-9482841d3131?source=collection_archive---------1-----------------------#2021-02-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/171e59b20d4dd99a450462286aef7f7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yAxNld1DYYm1GmwwPWsCZA.png"/></div></div></figure><p id="7f29" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi kz translated"><span class="l la lb lc bm ld le lf lg lh di">一个</span> zure Functions是微软Azure Cloud上提供的一个事件驱动的无服务器计算服务。您可以在您的IDE中非常轻松地创建一个新的Azure Functions应用程序，如Visual Studio 2019、Visual Studio Code、Rider等。因为我在Mac上使用Rider，所以我创建了一个新的Azure Functions解决方案，并在Rider的解决方案中添加了一个新功能。</p><figure class="lj lk ll lm gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi li"><img src="../Images/51cebf6ffd95688e307b5adb292cd74a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8tXZAu67QojvaSSJBW35bw.png"/></div></div></figure><figure class="lj lk ll lm gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ln"><img src="../Images/01731961cc99964dc7af73f39e9a2aae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R_Ig2P9mP4EbXF1p6gbuMw.png"/></div></div></figure><p id="f2c9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我们的函数中有一个名为AzureTipsFunction的静态类和一个名为RunAsync的静态方法。(其实对<strong class="kd iu">依赖注入</strong>的支持是从<strong class="kd iu"> Azure Functions 2.x </strong>开始的。所以那些IDE应该使用另一个模板来生成代码)。</p><p id="d98c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您可以轻松地在本地运行它，或者将其发布到Azure cloud，让更多人可以访问它。</p><p id="1340" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">虽然开发一个Azure Functions app很容易，但是如果不小心，也会遇到很严重的问题。例如，你应该记住Azure函数应用程序中的函数共享连接，如HTTP连接、数据库连接等。许多库提供了外部资源的抽象，这些库管理自己与资源的连接，如HttpClient、QueueClient等。</p><p id="bee2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此，如果您的函数代码看起来像这样，它将在每次调用函数时创建一个新的HTTP客户端实例。</p><pre class="lj lk ll lm gt lo lp lq lr aw ls bi"><span id="46fd" class="lt lu it lp b gy lv lw l lx ly">public static class AzureTipsFunction<br/>{<br/>    [FunctionName("AzureTipsFunction")]<br/>    public static async Task&lt;IActionResult&gt; RunAsync(<br/>        [HttpTrigger(AuthorizationLevel.Function, "get", "post", Route = null)]<br/>        HttpRequest req, ILogger log)<br/>    {<br/>        log.LogInformation("C# HTTP trigger function processed a request.");<br/>        <br/>        <strong class="lp iu">using (var client = new HttpClient())</strong><br/>        {<br/>            var client = new HttpClient();<br/>            var response = await client.GetAsync("<a class="ae lz" href="http://jiadongchen.com" rel="noopener ugc nofollow" target="_blank">http://jiadongchen.com</a>");<br/>            ...<br/>            ...<br/>        }<br/>    }<br/>}</span></pre><p id="a54f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在运行您的功能应用程序时，您可能会遇到<code class="fe ma mb mc lp b"><strong class="kd iu">Host thresholds exceeded: Connections</strong></code>异常或其他一些性能问题。</p><p id="9548" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">那么如何解决这个问题呢？这是我们将在这篇文章中讨论的主题，即“在你的Azure Functions应用程序中重用客户端实例”。我将介绍在Azure Functions应用程序中实现实例重用的两种方法。</p><h1 id="2faa" class="md lu it bd me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz bi translated"># 1静态客户端</h1><p id="b5ff" class="pw-post-body-paragraph kb kc it kd b ke na kg kh ki nb kk kl km nc ko kp kq nd ks kt ku ne kw kx ky im bi translated">不要在每次调用一个函数时都创建一个新的HttpClient实例(和其他客户机),而应该为所有调用使用一个HttpClient实例。</p><p id="23ea" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在Azure函数中实现它的最简单的方法是在函数的运行代码之外将HttpClient声明为静态的。</p><pre class="lj lk ll lm gt lo lp lq lr aw ls bi"><span id="822a" class="lt lu it lp b gy lv lw l lx ly">// Create a single, static HttpClient<br/><strong class="lp iu">private static HttpClient httpClient = new HttpClient();</strong></span><span id="c260" class="lt lu it lp b gy nf lw l lx ly">public static async Task Run(string input)<br/>{<br/>    var response = await httpClient.GetAsync("<a class="ae lz" href="http://jiadongchen.com/" rel="noopener ugc nofollow" target="_blank">http://jiadongchen.com/</a>");<br/>    // Rest of function<br/>}</span></pre><p id="46a4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这样，每个函数调用都将重用HttpClient的同一个实例，这非常容易实现。</p><p id="f239" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但是，随着代码量的增加，这种方法不容易维护。当然，您可以将HttpClient的声明放在一个助手类中，但这仍然很难维护。想象一下另一个程序员不知道这个helper类的存在…</p><h1 id="e05b" class="md lu it bd me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz bi translated"># 2使用依赖注入。NET Azure函数</h1><p id="f1e3" class="pw-post-body-paragraph kb kc it kd b ke na kg kh ki nb kk kl km nc ko kp kq nd ks kt ku ne kw kx ky im bi translated">所以，我更倾向于第二种方式。</p><p id="594a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">正如我在本文开头提到的，对依赖注入的支持始于<strong class="kd iu"> Azure Functions 2.x </strong>。所以我们可以不使用静态函数类/方法，而是像其他ASP一样，添加一个带有<code class="fe ma mb mc lp b">FunctionsStartup</code> assembly属性的<code class="fe ma mb mc lp b">Startup</code>类来注册我们需要的服务。NET项目。然后，为了使我们的依赖关系在函数中可用，我们应该使用构造函数注入。</p><p id="db35" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">那么代码将变成如下所示。</p><pre class="lj lk ll lm gt lo lp lq lr aw ls bi"><span id="5c4e" class="lt lu it lp b gy lv lw l lx ly">[<strong class="lp iu">assembly: FunctionsStartup</strong>(typeof(MyNamespace.Startup))]</span><span id="692b" class="lt lu it lp b gy nf lw l lx ly">namespace MyNamespace<br/>{<br/>    public class <strong class="lp iu">Startup</strong> : FunctionsStartup<br/>    {<br/>        public override void Configure(IFunctionsHostBuilder builder)<br/>        {<br/>            <strong class="lp iu">builder.Services.AddHttpClient();</strong></span><span id="3c09" class="lt lu it lp b gy nf lw l lx ly">            //builder.Services.AddSingleton&lt;IMyService&gt;((s) =&gt; {<br/>            //    return new MyService();<br/>            //});</span><span id="f044" class="lt lu it lp b gy nf lw l lx ly">            builder.Services.AddSingleton&lt;ILoggerProvider, MyLoggerProvider&gt;();<br/>        }<br/>    }<br/>}</span></pre><p id="3aaf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们在启动类中注册HttpClient。</p><pre class="lj lk ll lm gt lo lp lq lr aw ls bi"><span id="9105" class="lt lu it lp b gy lv lw l lx ly">public class AzureTipsFunction<br/>{<br/>    <strong class="lp iu">private readonly HttpClient _http;</strong></span><span id="b963" class="lt lu it lp b gy nf lw l lx ly">    <strong class="lp iu">public AzureTipsFunction(HttpClient httpClient)</strong><br/>    {<br/><strong class="lp iu">        <em class="ng">_http = httpClient;</em><br/></strong>    }</span><span id="194d" class="lt lu it lp b gy nf lw l lx ly">    [FunctionName("AzureTipsFunction")]<br/>    public async Task&lt;IActionResult&gt; RunAsync(<br/>        [HttpTrigger(AuthorizationLevel.Function, "get", "post", Route = null)]<br/>        HttpRequest req, ILogger log)<br/>    {<br/>        ...<br/>    }<br/>}</span></pre><p id="954f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们移除了AzureTipsFunction类的静态修饰符，并向该类添加了一个构造函数，以将HttpClient依赖注入到这个HTTP触发的函数中。</p><p id="a809" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我个人认为这是在Azure Functions应用中实现客户端实例重用的一种更优雅的方式！</p><p id="6bfc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">好了，以上就是我想在本帖中与大家分享的“在你的Azure Functions app中重用客户端实例”的两种实现方式，你可以在下面找到更多有用的链接！</p></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><h1 id="b912" class="md lu it bd me mf no mh mi mj np ml mm mn nq mp mq mr nr mt mu mv ns mx my mz bi translated">有用的链接</h1><div class="nt nu gp gr nv nw"><a href="https://docs.microsoft.com/en-us/azure/azure-functions/manage-connections?WT.mc_id=DT-MVP-5001664" rel="noopener  ugc nofollow" target="_blank"><div class="nx ab fo"><div class="ny ab nz cl cj oa"><h2 class="bd iu gy z fp ob fr fs oc fu fw is bi translated">管理Azure函数中的连接</h2><div class="od l"><h3 class="bd b gy z fp ob fr fs oc fu fw dk translated">功能应用中的功能共享资源。这些共享资源包括连接:HTTP连接、数据库…</h3></div><div class="oe l"><p class="bd b dl z fp ob fr fs oc fu fw dk translated">docs.microsoft.com</p></div></div><div class="of l"><div class="og l oh oi oj of ok jz nw"/></div></div></a></div><div class="nt nu gp gr nv nw"><a href="https://docs.microsoft.com/en-us/azure/architecture/antipatterns/improper-instantiation?WT.mc_id=DT-MVP-5001664" rel="noopener  ugc nofollow" target="_blank"><div class="nx ab fo"><div class="ny ab nz cl cj oa"><h2 class="bd iu gy z fp ob fr fs oc fu fw is bi translated">不正确的实例化反模式-云应用的性能反模式</h2><div class="od l"><h3 class="bd b gy z fp ob fr fs oc fu fw dk translated">不断地创建一个对象的新实例会影响性能，而这个对象本来是要创建一次的，然后…</h3></div><div class="oe l"><p class="bd b dl z fp ob fr fs oc fu fw dk translated">docs.microsoft.com</p></div></div><div class="of l"><div class="ol l oh oi oj of ok jz nw"/></div></div></a></div><div class="nt nu gp gr nv nw"><a href="https://docs.microsoft.com/en-us/azure/azure-functions/functions-dotnet-dependency-injection?WT.mc_id=DT-MVP-5001664" rel="noopener  ugc nofollow" target="_blank"><div class="nx ab fo"><div class="ny ab nz cl cj oa"><h2 class="bd iu gy z fp ob fr fs oc fu fw is bi translated">在中使用依赖注入。NET Azure函数</h2><div class="od l"><h3 class="bd b gy z fp ob fr fs oc fu fw dk translated">Azure Functions支持依赖注入(DI)软件设计模式，这是一种实现</h3></div><div class="oe l"><p class="bd b dl z fp ob fr fs oc fu fw dk translated">docs.microsoft.com</p></div></div><div class="of l"><div class="om l oh oi oj of ok jz nw"/></div></div></a></div></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><p id="8d75" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">感谢您的阅读，希望对您有所帮助。</p><p id="ada2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在聊天</p><div class="nt nu gp gr nv nw"><a href="https://www.linkedin.com/in/chenjd/" rel="noopener  ugc nofollow" target="_blank"><div class="nx ab fo"><div class="ny ab nz cl cj oa"><h2 class="bd iu gy z fp ob fr fs oc fu fw is bi translated">陈家东-高级软件开发人员-X公司| LinkedIn</h2><div class="od l"><h3 class="bd b gy z fp ob fr fs oc fu fw dk translated">大家好，我是陈家东陈(@chen_jd)。我是个有经验的人。NET开发者，2015年10月起成为微软MVP。我最后一次…</h3></div><div class="oe l"><p class="bd b dl z fp ob fr fs oc fu fw dk translated">www.linkedin.com</p></div></div><div class="of l"><div class="on l oh oi oj of ok jz nw"/></div></div></a></div></div></div>    
</body>
</html>