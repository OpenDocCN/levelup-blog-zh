<html>
<head>
<title>Sandboxing in Linux with Zero Lines of Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Linux中的沙盒，零行代码</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/sandboxing-in-linux-with-zero-lines-of-code-f0412c74c5ae?source=collection_archive---------8-----------------------#2020-07-15">https://levelup.gitconnected.com/sandboxing-in-linux-with-zero-lines-of-code-f0412c74c5ae?source=collection_archive---------8-----------------------#2020-07-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="3ad4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">原载于2020年7月8日</em><a class="ae km" href="https://blog.cloudflare.com/sandboxing-in-linux-with-zero-lines-of-code/" rel="noopener ugc nofollow" target="_blank"><em class="kl">【https://blog.cloudflare.com】</em></a><em class="kl">。</em></p><p id="8d3e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现代Linux操作系统提供了许多工具来更安全地运行代码。有<a class="ae km" href="https://www.man7.org/linux/man-pages/man7/namespaces.7.html" rel="noopener ugc nofollow" target="_blank">名称空间</a>(容器的基本构建块)<a class="ae km" href="https://www.kernel.org/doc/html/latest/admin-guide/LSM/index.html" rel="noopener ugc nofollow" target="_blank"> Linux安全模块</a>、<a class="ae km" href="https://wiki.gentoo.org/wiki/Integrity_Measurement_Architecture" rel="noopener ugc nofollow" target="_blank">完整性度量架构</a>等。</p><p id="a3fa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这篇文章中，我们将回顾Linux seccomp，并学习如何不用写一行代码就可以运行任何(甚至是专有的)应用程序。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi kn"><img src="../Images/6764831a32a0a7c128db44a2c59b24d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*MLQYZFcVPBXUo84W.jpg"/></div></div></figure><p id="f529" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae km" href="https://www.deviantart.com/qubodup/art/Tux-Flat-SVG-607655623" rel="noopener ugc nofollow" target="_blank">伊旺·加博维奇的Tux，GPL </a> <a class="ae km" href="https://pixabay.com/vectors/sandpit-sandbox-container-sand-35536/" rel="noopener ugc nofollow" target="_blank">沙盒，简化的Pixabay许可证</a></p><h2 id="f873" class="kz la iq bd lb lc ld dn le lf lg dp lh jy li lj lk kc ll lm ln kg lo lp lq lr bi translated">Linux系统调用</h2><p id="e3ff" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">系统调用(syscalls)是<a class="ae km" href="https://en.wikipedia.org/wiki/User_space" rel="noopener ugc nofollow" target="_blank">用户空间应用</a>和<a class="ae km" href="https://en.wikipedia.org/wiki/Kernel_(operating_system)" rel="noopener ugc nofollow" target="_blank">操作系统(OS)内核</a>之间定义良好的接口。在现代操作系统上，大多数应用程序只提供特定于应用程序的逻辑作为代码。当应用程序需要存储数据或通过网络发送数据时，它们不直接访问底层硬件或网络，大多数时候也不能这样做。相反，它们使用系统调用来要求操作系统内核代表它们执行特定的硬件和网络任务:</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi lx"><img src="../Images/bd5daea8060a553b4cbcdbb1fa9935f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*HVgZRygUwAnL3crT.png"/></div></div></figure><p id="4845" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">除了为应用程序提供与低级硬件交互的通用高级方式之外，系统调用体系结构还允许操作系统内核管理应用程序之间的可用资源，并实施策略，如应用程序权限、网络访问控制列表等。</p><h2 id="0c80" class="kz la iq bd lb lc ld dn le lf lg dp lh jy li lj lk kc ll lm ln kg lo lp lq lr bi translated">Linux seccomp</h2><p id="fdbc" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">Linux seccomp<a class="ae km" href="https://www.man7.org/linux/man-pages/man2/seccomp.2.html" rel="noopener ugc nofollow" target="_blank">是Linux上的另一个系统调用</a>，但是它有点特殊，因为当应用程序使用其他系统调用时，它会影响操作系统内核的行为。默认情况下，操作系统内核几乎不了解用户空间的应用程序逻辑，因此它提供了所有可能的服务。但不是所有的应用程序都需要所有的服务。考虑一个转换图像格式的应用程序:它需要从磁盘读取和写入数据的能力，但最简单的形式可能不需要任何网络访问。使用seccomp，应用程序可以提前向Linux内核声明它的意图。对于这种特殊情况，它可以通知内核它将使用<a class="ae km" href="https://www.man7.org/linux/man-pages/man2/read.2.html" rel="noopener ugc nofollow" target="_blank"> read </a>和<a class="ae km" href="https://www.man7.org/linux/man-pages/man2/write.2.html" rel="noopener ugc nofollow" target="_blank"> write </a>系统调用，但从不使用<a class="ae km" href="https://www.man7.org/linux/man-pages/man2/send.2.html" rel="noopener ugc nofollow" target="_blank"> send </a>和<a class="ae km" href="https://www.man7.org/linux/man-pages/man2/recv.2.html" rel="noopener ugc nofollow" target="_blank"> recv </a>系统调用(因为它的目的是处理本地文件，而不是网络)。这就像在应用程序和操作系统内核之间建立一个契约:</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi ly"><img src="../Images/2f2aac3a34d104e5351adcb9be9f6ced.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*r_FzORXXdeBtca0s.png"/></div></div></figure><p id="b5e6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是，如果应用程序后来违反约定，试图使用它承诺不使用的系统调用之一，会发生什么呢？内核会“惩罚”应用程序，通常是立即终止它。Linux seccomp还允许内核采取较少限制的动作:</p><ul class=""><li id="b7a2" class="lz ma iq jp b jq jr ju jv jy mb kc mc kg md kk me mf mg mh bi translated">可以请求内核只终止发出禁止的系统调用的线程，而不是终止整个应用程序</li><li id="15ed" class="lz ma iq jp b jq mi ju mj jy mk kc ml kg mm kk me mf mg mh bi translated">内核可以只向调用线程发送一个<code class="fe mn mo mp mq b">SIGSYS</code> <a class="ae km" href="https://man7.org/linux/man-pages/man7/signal.7.html" rel="noopener ugc nofollow" target="_blank">信号</a></li><li id="07c7" class="lz ma iq jp b jq mi ju mj jy mk kc ml kg mm kk me mf mg mh bi translated">seccomp策略可以指定一个错误代码，然后内核会将它返回给调用应用程序，而不是执行被禁止的系统调用</li><li id="05f2" class="lz ma iq jp b jq mi ju mj jy mk kc ml kg mm kk me mf mg mh bi translated">如果违规进程在<a class="ae km" href="https://man7.org/linux/man-pages/man2/ptrace.2.html" rel="noopener ugc nofollow" target="_blank"> ptrace </a>下(例如在调试器下执行)，内核可以通知跟踪器(调试器)一个被禁止的系统调用即将发生，并让调试器决定做什么</li><li id="7638" class="lz ma iq jp b jq mi ju mj jy mk kc ml kg mm kk me mf mg mh bi translated">可以指示内核允许并执行系统调用，但是记录这个尝试:当我们想要验证我们的seccomp策略是否太紧而没有终止应用程序和潜在造成中断的风险时，这是很有用的</li></ul><p id="0a42" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">尽管在定义应用程序的潜在惩罚方面有很大的灵活性，但从安全角度来看，通常最好坚持在违反seccomp政策时完全终止应用程序。原因将在后面的例子中描述。</p><p id="edff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么，如果应用程序可以“沉默”并且操作系统内核默认允许它使用任何系统调用，那么为什么要冒突然终止的风险并事先声明它的意图呢？当然，对于一个正常运行的应用程序来说，这是没有意义的，但是事实证明这个特性对于防止恶意应用程序和任意代码执行攻击是非常有效的。</p><p id="a60e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">想象一下，我们的图像格式转换器是用一些不安全的语言编写的，而<a class="ae km" href="https://imagetragick.com/" rel="noopener ugc nofollow" target="_blank">攻击者能够通过让它处理一些畸形的图像来控制应用程序</a>。攻击者可能会从运行我们转换器的机器上窃取一些敏感信息，并通过网络发送给他们自己。默认情况下，操作系统内核很可能会允许它，这样就会发生数据泄漏。但是，如果我们的图像转换器事先“限制”(或沙箱)自己只读取和写入本地数据，当后者试图通过网络泄漏数据时，内核将终止应用程序，从而防止泄漏并将攻击者锁定在我们的系统之外！</p><h2 id="2943" class="kz la iq bd lb lc ld dn le lf lg dp lh jy li lj lk kc ll lm ln kg lo lp lq lr bi translated">将seccomp集成到应用程序中</h2><p id="67e1" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">为了了解如何在实践中使用seccomp，让我们考虑一个玩具示例程序</p><p id="2632" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl"> myos.c: </em></p><pre class="ko kp kq kr gt mr mq ms mt aw mu bi"><span id="d1d4" class="kz la iq mq b gy mv mw l mx my"><strong class="mq ir">#include &lt;stdio.h&gt;<br/>#include &lt;sys/utsname.h&gt;<br/></strong><br/><strong class="mq ir">int</strong> <strong class="mq ir">main</strong>(<strong class="mq ir">void</strong>)<br/>{<br/>    <strong class="mq ir">struct</strong> <strong class="mq ir">utsname</strong> name;<br/><br/>    <strong class="mq ir">if</strong> (uname(<strong class="mq ir">&amp;</strong>name)) {<br/>        perror("uname failed: ");<br/>        <strong class="mq ir">return</strong> 1;<br/>    }<br/><br/>    printf("My OS is %s!\n", name.sysname);<br/>    <strong class="mq ir">return</strong> 0;<br/>}</span></pre><p id="00fd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是一个简化版的<a class="ae km" href="https://www.man7.org/linux/man-pages/man1/uname.1.html" rel="noopener ugc nofollow" target="_blank"> uname命令行工具</a>，它只打印你的操作系统名称。像它的全功能对应物一样，它使用<a class="ae km" href="https://www.man7.org/linux/man-pages/man2/uname.2.html" rel="noopener ugc nofollow" target="_blank"> uname系统调用</a>从内核中获取当前操作系统的名称。让我们来看看行动:</p><pre class="ko kp kq kr gt mr mq ms mt aw mu bi"><span id="7695" class="kz la iq mq b gy mv mw l mx my">$ gcc -o myos myos.c<br/>$ ./myos<br/>My OS is Linux!</span></pre><p id="f699" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">太好了！我们在Linux上，所以可以进一步试验<a class="ae km" href="https://www.man7.org/linux/man-pages/man2/seccomp.2.html" rel="noopener ugc nofollow" target="_blank"> seccomp </a>(这是Linux独有的特性)。注意，在调用<a class="ae km" href="https://www.man7.org/linux/man-pages/man2/uname.2.html" rel="noopener ugc nofollow" target="_blank"> uname系统调用</a>之后，我们正在正确处理错误代码。然而，根据<a class="ae km" href="https://www.man7.org/linux/man-pages/man2/uname.2.html" rel="noopener ugc nofollow" target="_blank">手册页</a>，只有当传入的缓冲区指针无效时，它才会失败。在这种情况下，设置的错误号将是“EINVAL”，这意味着无效参数。在我们的例子中,“struct utsname”结构是在堆栈上分配的，所以我们的指针总是有效的。换句话说，在正常情况下，<a class="ae km" href="https://www.man7.org/linux/man-pages/man2/uname.2.html" rel="noopener ugc nofollow" target="_blank"> uname系统调用</a>应该永远不会在这个特定的程序中失败。</p><p id="d86f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了说明seccomp的功能，我们将在程序的主逻辑之前添加一个“沙箱”功能</p><p id="f80a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl"> myos_raw_seccomp.c: </em></p><pre class="ko kp kq kr gt mr mq ms mt aw mu bi"><span id="8a16" class="kz la iq mq b gy mv mw l mx my"><strong class="mq ir">#include &lt;linux/seccomp.h&gt;<br/>#include &lt;linux/filter.h&gt;<br/>#include &lt;linux/audit.h&gt;<br/>#include &lt;sys/ptrace.h&gt;<br/>#include &lt;sys/prctl.h&gt;<br/></strong><br/><strong class="mq ir">#include &lt;stdlib.h&gt;<br/>#include &lt;stdio.h&gt;<br/>#include &lt;stddef.h&gt;<br/>#include &lt;sys/utsname.h&gt;<br/>#include &lt;errno.h&gt;<br/>#include &lt;unistd.h&gt;<br/>#include &lt;sys/syscall.h&gt;<br/></strong><br/><strong class="mq ir">static</strong> <strong class="mq ir">void</strong> <strong class="mq ir">sandbox</strong>(<strong class="mq ir">void</strong>)<br/>{<br/>    <strong class="mq ir">struct</strong> <strong class="mq ir">sock_filter</strong> filter[] <strong class="mq ir">=</strong> {<br/>        <em class="kl">/* seccomp(2) says we should always check the arch */</em><br/>        <em class="kl">/* as syscalls may have different numbers on different architectures */</em><br/>        <em class="kl">/* see https://fedora.juszkiewicz.com.pl/syscalls.html */</em><br/>        <em class="kl">/* for simplicity we only allow x86_64 */</em><br/>        BPF_STMT(BPF_LD <strong class="mq ir">|</strong> BPF_W <strong class="mq ir">|</strong> BPF_ABS, (offsetof(<strong class="mq ir">struct</strong> <strong class="mq ir">seccomp_data</strong>, arch))),<br/>        <em class="kl">/* if not x86_64, tell the kernel to kill the process */</em><br/>        BPF_JUMP(BPF_JMP <strong class="mq ir">|</strong> BPF_JEQ <strong class="mq ir">|</strong> BPF_K, AUDIT_ARCH_X86_64, 0, 4),<br/>        <em class="kl">/* get the actual syscall number */</em><br/>        BPF_STMT(BPF_LD <strong class="mq ir">|</strong> BPF_W <strong class="mq ir">|</strong> BPF_ABS, (offsetof(<strong class="mq ir">struct</strong> <strong class="mq ir">seccomp_data</strong>, nr))),<br/>        <em class="kl">/* if "uname", tell the kernel to return EPERM, otherwise just allow */</em><br/>        BPF_JUMP(BPF_JMP <strong class="mq ir">|</strong> BPF_JEQ <strong class="mq ir">|</strong> BPF_K, SYS_uname, 0, 1),<br/>        BPF_STMT(BPF_RET <strong class="mq ir">|</strong> BPF_K, SECCOMP_RET_ERRNO <strong class="mq ir">|</strong> (EPERM <strong class="mq ir">&amp;</strong> SECCOMP_RET_DATA)),<br/>        BPF_STMT(BPF_RET <strong class="mq ir">|</strong> BPF_K, SECCOMP_RET_ALLOW),<br/>        BPF_STMT(BPF_RET <strong class="mq ir">|</strong> BPF_K, SECCOMP_RET_KILL),<br/>    };<br/><br/>    <strong class="mq ir">struct</strong> <strong class="mq ir">sock_fprog</strong> prog <strong class="mq ir">=</strong> {<br/>        .len <strong class="mq ir">=</strong> (<strong class="mq ir">unsigned</strong> <strong class="mq ir">short</strong>) (<strong class="mq ir">sizeof</strong>(filter) <strong class="mq ir">/</strong> <strong class="mq ir">sizeof</strong>(filter[0])),<br/>        .filter <strong class="mq ir">=</strong> filter,<br/>    };<br/><br/>    <em class="kl">/* see seccomp(2) on why this is needed */</em><br/>    <strong class="mq ir">if</strong> (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)) {<br/>        perror("PR_SET_NO_NEW_PRIVS failed");<br/>        exit(1);<br/>    };<br/><br/>    <em class="kl">/* glibc does not have a wrapper for seccomp(2) */</em><br/>    <em class="kl">/* invoke it via the generic syscall wrapper */</em><br/>    <strong class="mq ir">if</strong> (syscall(SYS_seccomp, SECCOMP_SET_MODE_FILTER, 0, <strong class="mq ir">&amp;</strong>prog)) {<br/>        perror("seccomp failed");<br/>        exit(1);<br/>    };<br/>}<br/><br/><strong class="mq ir">int</strong> <strong class="mq ir">main</strong>(<strong class="mq ir">void</strong>)<br/>{<br/>    <strong class="mq ir">struct</strong> <strong class="mq ir">utsname</strong> name;<br/><br/>    sandbox();<br/><br/>    <strong class="mq ir">if</strong> (uname(<strong class="mq ir">&amp;</strong>name)) {<br/>        perror("uname failed");<br/>        <strong class="mq ir">return</strong> 1;<br/>    }<br/><br/>    printf("My OS is %s!\n", name.sysname);<br/>    <strong class="mq ir">return</strong> 0;<br/>}</span></pre><p id="872e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了用沙箱保护自己，应用程序定义了一个<a class="ae km" href="https://www.kernel.org/doc/Documentation/networking/filter.txt" rel="noopener ugc nofollow" target="_blank"> BPF程序</a>，它实现所需的沙箱保护策略。然后应用程序通过<a class="ae km" href="https://www.man7.org/linux/man-pages/man2/seccomp.2.html" rel="noopener ugc nofollow" target="_blank"> seccomp </a>系统调用将这个程序传递给内核。内核做一些验证检查，以确保BPF程序是正确的，然后在应用程序进行的每个系统调用中运行这个程序。内核使用程序的执行结果来确定当前调用是否符合期望的策略。换句话说，BPF程序是应用程序和内核之间的“契约”。</p><p id="2f7c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们上面的玩具例子中，BPF程序只是检查哪个系统调用将被调用。如果应用程序试图使用<a class="ae km" href="https://www.man7.org/linux/man-pages/man2/uname.2.html" rel="noopener ugc nofollow" target="_blank"> uname系统调用</a>，我们告诉内核只返回一个EPERM(代表“不允许操作”)错误代码。我们还告诉内核允许任何其他系统调用。让我们看看它现在是否有效:</p><pre class="ko kp kq kr gt mr mq ms mt aw mu bi"><span id="39ac" class="kz la iq mq b gy mv mw l mx my">$ gcc -o myos myos_raw_seccomp.c<br/>$ ./myos<br/>uname failed: Operation not permitted</span></pre><p id="f17b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mn mo mp mq b">uname</code>现在失败，出现EPERM错误代码，并且在<a class="ae km" href="https://www.man7.org/linux/man-pages/man2/uname.2.html" rel="noopener ugc nofollow" target="_blank"> uname联机帮助页</a>中EPERM甚至没有被描述为潜在的失败代码！所以我们现在知道发生这种情况是因为我们“告诉”内核禁止我们使用uname syscall，而是返回EPERM。我们可以通过用其他一些错误代码替换EPERM来仔细检查这一点，这些代码完全不适合这个上下文，例如enet down(“network down”)。为什么我们需要网络来获取当前正在执行的操作系统？然而，重新编译和运行程序，我们得到:</p><pre class="ko kp kq kr gt mr mq ms mt aw mu bi"><span id="3854" class="kz la iq mq b gy mv mw l mx my">$ gcc -o myos myos_raw_seccomp.c<br/>$ ./myos<br/>uname failed: Network is down</span></pre><p id="b0d2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还可以验证我们“合同”的另一部分是否如预期的那样工作。我们告诉内核允许任何其他系统调用，还记得吗？在我们的程序中，当uname失败时，我们用<a class="ae km" href="https://www.man7.org/linux/man-pages/man3/perror.3.html" rel="noopener ugc nofollow" target="_blank"> perror </a>函数将错误代码转换成人类可读的消息并打印在屏幕上。为了在屏幕上打印<a class="ae km" href="https://www.man7.org/linux/man-pages/man3/perror.3.html" rel="noopener ugc nofollow" target="_blank"> perror </a>使用了<a class="ae km" href="https://www.man7.org/linux/man-pages/man2/write.2.html" rel="noopener ugc nofollow" target="_blank">写系统调用</a>,因为我们实际上可以看到打印的错误消息，我们知道内核首先允许我们的程序进行<a class="ae km" href="https://www.man7.org/linux/man-pages/man2/write.2.html" rel="noopener ugc nofollow" target="_blank">写系统调用</a>。</p><h2 id="e64b" class="kz la iq bd lb lc ld dn le lf lg dp lh jy li lj lk kc ll lm ln kg lo lp lq lr bi translated">带libseccomp的seccomp</h2><p id="48ee" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">虽然可以像上面的例子那样直接使用seccomp，但是BPF程序手写起来很麻烦，而且很难调试、检查和更新。这就是为什么使用更高级的库通常是个好主意，它抽象掉了大多数低级的细节。幸运的是<a class="ae km" href="https://github.com/seccomp/libseccomp" rel="noopener ugc nofollow" target="_blank">有这样一个库</a>:它叫做libseccomp，甚至被<a class="ae km" href="https://www.man7.org/linux/man-pages/man2/seccomp.2.html" rel="noopener ugc nofollow" target="_blank"> seccomp手册页</a>推荐。</p><p id="c836" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们重写程序的<code class="fe mn mo mp mq b">sandbox()</code>函数来使用这个库:</p><p id="7153" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl"> myos_libseccomp.c: </em></p><pre class="ko kp kq kr gt mr mq ms mt aw mu bi"><span id="97ca" class="kz la iq mq b gy mv mw l mx my"><strong class="mq ir">#define _GNU_SOURCE<br/>#include &lt;stdio.h&gt;<br/>#include &lt;stdlib.h&gt;<br/>#include &lt;sys/utsname.h&gt;<br/>#include &lt;seccomp.h&gt;<br/>#include &lt;err.h&gt;<br/></strong><br/><strong class="mq ir">static</strong> <strong class="mq ir">void</strong> <strong class="mq ir">sandbox</strong>(<strong class="mq ir">void</strong>)<br/>{<br/>    <em class="kl">/* allow all syscalls by default */</em><br/>    scmp_filter_ctx seccomp_ctx <strong class="mq ir">=</strong> seccomp_init(SCMP_ACT_ALLOW);<br/>    <strong class="mq ir">if</strong> (<strong class="mq ir">!</strong>seccomp_ctx)<br/>        err(1, "seccomp_init failed");<br/><br/>    <em class="kl">/* kill the process, if it tries to use "uname" syscall */</em><br/>    <strong class="mq ir">if</strong> (seccomp_rule_add_exact(seccomp_ctx, SCMP_ACT_KILL, seccomp_syscall_resolve_name("uname"), 0)) {<br/>        perror("seccomp_rule_add_exact failed");<br/>        exit(1);<br/>    }<br/><br/>    <em class="kl">/* apply the composed filter */</em><br/>    <strong class="mq ir">if</strong> (seccomp_load(seccomp_ctx)) {<br/>        perror("seccomp_load failed");<br/>        exit(1);<br/>    }<br/><br/>    <em class="kl">/* release allocated context */</em><br/>    seccomp_release(seccomp_ctx);<br/>}<br/><br/><strong class="mq ir">int</strong> <strong class="mq ir">main</strong>(<strong class="mq ir">void</strong>)<br/>{<br/>    <strong class="mq ir">struct</strong> <strong class="mq ir">utsname</strong> name;<br/><br/>    sandbox();<br/><br/>    <strong class="mq ir">if</strong> (uname(<strong class="mq ir">&amp;</strong>name)) {<br/>        perror("uname failed: ");<br/>        <strong class="mq ir">return</strong> 1;<br/>    }<br/><br/>    printf("My OS is %s!\n", name.sysname);<br/>    <strong class="mq ir">return</strong> 0;<br/>}</span></pre><p id="4183" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的<code class="fe mn mo mp mq b">sandbox()</code>函数不仅变得更短、可读性更强，而且还提供了通过名称而不是内部编号来引用规则中的系统调用的能力，并且不必处理其他问题，比如设置<code class="fe mn mo mp mq b">PR_SET_NO_NEW_PRIVS</code>位和处理系统架构。</p><p id="2a95" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">值得注意的是，我们已经修改了我们的seccomp政策。在上面的原始seccomp示例中，我们指示内核在应用程序试图执行被禁止的系统调用时返回一个错误代码。这有利于演示，但在大多数情况下需要更严格的操作。仅仅返回一个错误代码并允许应用程序继续运行，就给了潜在的恶意代码绕过策略的机会。Linux中有许多系统调用，其中一些做相同或相似的事情。例如，我们可能希望禁止应用程序从磁盘读取数据，因此我们在策略中拒绝了<a class="ae km" href="https://www.man7.org/linux/man-pages/man2/read.2.html" rel="noopener ugc nofollow" target="_blank"> read </a> syscall，并告诉内核返回一个错误代码。但是，如果应用程序被利用，利用代码/逻辑可能如下所示:</p><pre class="ko kp kq kr gt mr mq ms mt aw mu bi"><span id="b2fb" class="kz la iq mq b gy mv mw l mx my">…<br/><strong class="mq ir">if</strong> (<strong class="mq ir">-</strong>1 <strong class="mq ir">==</strong> read(fd, buf, count)) {<br/>    <em class="kl">/* hm… read failed, but what about pread? */</em><br/>    <strong class="mq ir">if</strong> (<strong class="mq ir">-</strong>1 <strong class="mq ir">==</strong> pread(fd, buf, count, offset) {<br/>        <em class="kl">/* what about readv? */</em> ...<br/>    }<br/>    <em class="kl">/* bypassed the prohibited read(2) syscall */</em><br/>}<br/>…</span></pre><p id="d30d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">等等什么？！有多个读取系统调用？是的，有<a class="ae km" href="https://www.man7.org/linux/man-pages/man2/read.2.html" rel="noopener ugc nofollow" target="_blank"> read </a>，<a class="ae km" href="https://man7.org/linux/man-pages/man2/pread.2.html" rel="noopener ugc nofollow" target="_blank"> pread </a>，<a class="ae km" href="https://man7.org/linux/man-pages/man2/readv.2.html" rel="noopener ugc nofollow" target="_blank"> readv </a>还有更隐晦的，像<a class="ae km" href="https://blog.cloudflare.com/io_submit-the-epoll-alternative-youve-never-heard-about/" rel="noopener ugc nofollow" target="_blank"> io_submit </a>和<code class="fe mn mo mp mq b">io_uring_enter</code>。当然，提供不完整的seccomp策略是我们的错，它没有阻止所有可能的读取系统调用。但是，如果我们至少已经指示内核在违反第一个普通<code class="fe mn mo mp mq b">read</code>时立即终止进程，那么上面的恶意代码就没有机会变得聪明并尝试其他选项。</p><p id="3e5f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上面的libseccomp示例中，我们现在有了一个更严格的策略，它告诉内核在违反策略时终止进程。让我们看看它是否有效:</p><pre class="ko kp kq kr gt mr mq ms mt aw mu bi"><span id="4f02" class="kz la iq mq b gy mv mw l mx my">$ gcc -o myos myos_libseccomp.c -lseccomp<br/>$ ./myos<br/>Bad system call</span></pre><p id="d9e6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，在编译应用程序时，我们需要针对<a class="ae km" href="https://github.com/seccomp/libseccomp" rel="noopener ugc nofollow" target="_blank"> libseccomp </a>进行链接。此外，当我们运行应用程序时，我们再也看不到<code class="fe mn mo mp mq b">uname failed: Operation not permitted</code>错误输出，因为我们甚至没有给应用程序打印失败消息的能力。相反，我们看到一条来自shell的<code class="fe mn mo mp mq b">Bad system call</code>消息，告诉我们应用程序被一个<code class="fe mn mo mp mq b">SIGSYS</code> <a class="ae km" href="https://man7.org/linux/man-pages/man7/signal.7.html" rel="noopener ugc nofollow" target="_blank">信号</a>终止。太好了！</p><h2 id="470a" class="kz la iq bd lb lc ld dn le lf lg dp lh jy li lj lk kc ll lm ln kg lo lp lq lr bi translated">零代码秒补偿</h2><p id="2558" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">前面的例子工作得很好，但是它们都有一个缺点:我们实际上需要修改源代码来将我们想要的seccomp策略嵌入到应用程序中。这是因为<a class="ae km" href="https://www.man7.org/linux/man-pages/man2/seccomp.2.html" rel="noopener ugc nofollow" target="_blank"> seccomp syscall </a>影响调用进程及其子进程，但是没有接口从“外部”注入策略。人们期望开发人员将自己的代码作为应用程序逻辑的一部分用沙箱保护起来，但实际上这很少发生。当开发人员开始一个新项目时，大多数时候关注的是主要功能，而安全特性通常要么被推迟，要么被完全忽略。此外，大多数真实世界的软件通常是使用某种高级编程语言和/或框架编写的，其中开发人员不直接处理系统调用，甚至可能不知道他们的代码正在使用哪些系统调用。</p><p id="e9ba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另一方面，我们有系统操作员、系统管理员、SRE和其他人，他们在生产中运行上述代码。他们更愿意保持生产系统的安全，因此可能希望尽可能地用沙箱保护服务。但是大部分时间他们都接触不到源代码。因此，存在不匹配的期望:开发人员有能力用沙箱保护他们的代码，但通常没有动力这样做，而操作人员有动力用沙箱保护代码，但没有这个能力。</p><p id="9778" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是“零代码seccomp”可能有所帮助的地方，外部操作者可以将所需的沙盒策略注入到任何进程中，而无需修改任何源代码。Systemd 是“零代码seccomp”方法的流行实现之一。Systemd管理的服务可以在它们的<a class="ae km" href="https://www.freedesktop.org/software/systemd/man/systemd.service.html" rel="noopener ugc nofollow" target="_blank">单元文件</a>中定义一个<code class="fe mn mo mp mq b"><a class="ae km" href="https://www.freedesktop.org/software/systemd/man/systemd.exec.html#SystemCallFilter=" rel="noopener ugc nofollow" target="_blank">SystemCallFilter=</a></code>指令，列出被管理的服务允许进行的所有系统调用。例如，让我们回到没有嵌入任何沙盒代码的玩具应用程序:</p><pre class="ko kp kq kr gt mr mq ms mt aw mu bi"><span id="6153" class="kz la iq mq b gy mv mw l mx my">$ gcc -o myos myos.c<br/>$ ./myos<br/>My OS is Linux!</span></pre><p id="60fc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们可以用systemd运行相同的代码，但是禁止应用程序使用<a class="ae km" href="https://www.man7.org/linux/man-pages/man2/uname.2.html" rel="noopener ugc nofollow" target="_blank"> uname </a>而不更改或重新编译任何代码(我们使用<a class="ae km" href="https://www.freedesktop.org/software/systemd/man/systemd-run.html" rel="noopener ugc nofollow" target="_blank"> systemd-run </a>为我们创建一个短暂的systemd服务单元):</p><pre class="ko kp kq kr gt mr mq ms mt aw mu bi"><span id="0988" class="kz la iq mq b gy mv mw l mx my">$ systemd-run --user --pty --same-dir --wait --collect --service-type=exec --property="SystemCallFilter=~uname" ./myos<br/>Running as unit: run-u0.service<br/>Press ^] three times within 1s to disconnect TTY.<br/>Finished with result: signal<br/>Main processes terminated with: code=killed/status=SYS<br/>Service runtime: 6ms</span></pre><p id="8e6c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们再也看不到正常的<code class="fe mn mo mp mq b">My OS is Linux!</code>输出，systemd很方便地告诉我们托管进程被一个<code class="fe mn mo mp mq b">SIGSYS</code>信号终止了。我们甚至可以更进一步，使用另一个指令<code class="fe mn mo mp mq b"><a class="ae km" href="https://www.freedesktop.org/software/systemd/man/systemd.exec.html#SystemCallErrorNumber=" rel="noopener ugc nofollow" target="_blank">SystemCallErrorNumber=</a></code>来配置我们的seccomp策略，不终止应用程序，而是返回一个错误代码，如我们的第一个seccomp raw示例所示:</p><pre class="ko kp kq kr gt mr mq ms mt aw mu bi"><span id="46c2" class="kz la iq mq b gy mv mw l mx my">$ systemd-run --user --pty --same-dir --wait --collect --service-type=exec --property="SystemCallFilter=~uname" --property="SystemCallErrorNumber=ENETDOWN" ./myos<br/>Running as unit: run-u2.service<br/>Press ^] three times within 1s to disconnect TTY.<br/>uname failed: Network is down<br/>Finished with result: exit-code<br/>Main processes terminated with: code=exited/status=1<br/>Service runtime: 6ms</span></pre><h2 id="8e2a" class="kz la iq bd lb lc ld dn le lf lg dp lh jy li lj lk kc ll lm ln kg lo lp lq lr bi translated">systemd小型印刷字体</h2><p id="da30" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">太好了！我们现在可以将几乎任何seccomp策略注入到任何进程中，而无需编写任何代码或重新编译应用程序。不过在<a class="ae km" href="https://www.freedesktop.org/software/systemd/man/systemd.exec.html#SystemCallFilter=" rel="noopener ugc nofollow" target="_blank"> systemd文档</a>中有一句很有意思的话:</p><blockquote class="mz na nb"><p id="3d2d" class="jn jo kl jp b jq jr js jt ju jv jw jx nc jz ka kb nd kd ke kf ne kh ki kj kk ij bi translated">…请注意，<code class="fe mn mo mp mq b">execve, exit, exit_group, getrlimit, rt_sigreturn, sigreturn</code>系统调用以及查询时间和睡眠的系统调用被隐式列入白名单，不需要显式列出...</p></blockquote><p id="7164" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有些系统调用是隐式允许的，我们不必列出它们。这主要与systemd管理进程和注入seccomp策略的方式有关。我们之前已经确定seccomp策略适用于当前进程及其子进程。因此，为了注入策略，systemd <a class="ae km" href="https://www.man7.org/linux/man-pages/man2/fork.2.html" rel="noopener ugc nofollow" target="_blank">分叉</a>本身，在分叉的进程中调用<a class="ae km" href="https://www.man7.org/linux/man-pages/man2/seccomp.2.html" rel="noopener ugc nofollow" target="_blank"> seccomp </a>，然后<a class="ae km" href="https://www.man7.org/linux/man-pages/man2/execve.2.html" rel="noopener ugc nofollow" target="_blank">将分叉的进程</a>执行到目标应用程序中。这就是为什么首先总是允许<a class="ae km" href="https://www.man7.org/linux/man-pages/man2/execve.2.html" rel="noopener ugc nofollow" target="_blank"> execve </a>系统调用是必要的，因为否则systemd不能完成它作为服务管理器的工作。</p><p id="15ad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是如果我们想明确禁止这些系统调用呢？如果我们继续以<a class="ae km" href="https://www.man7.org/linux/man-pages/man2/execve.2.html" rel="noopener ugc nofollow" target="_blank"> execve </a>为例，那实际上可能是大多数应用程序想要禁止的一个危险的系统调用。Seccomp是保护代码免受任意代码执行攻击的有效工具，还记得吗？如果一个恶意的参与者接管了我们的代码，他们最有可能做的第一件事就是获得一个shell(或者用任何其他更容易控制的应用程序替换我们的代码),方法是指导我们的代码用想要的二进制文件调用<a class="ae km" href="https://www.man7.org/linux/man-pages/man2/execve.2.html" rel="noopener ugc nofollow" target="_blank"> execve </a>。因此，如果我们的代码不需要<a class="ae km" href="https://www.man7.org/linux/man-pages/man2/execve.2.html" rel="noopener ugc nofollow" target="_blank"> execve </a>来实现它的主要功能，那么禁止它将是一个好主意。不幸的是，使用systemd <code class="fe mn mo mp mq b"><a class="ae km" href="https://www.freedesktop.org/software/systemd/man/systemd.exec.html#SystemCallFilter=" rel="noopener ugc nofollow" target="_blank">SystemCallFilter=</a></code>方法是不可能的...</p><h2 id="b037" class="kz la iq bd lb lc ld dn le lf lg dp lh jy li lj lk kc ll lm ln kg lo lp lq lr bi translated">Cloudflare沙盒简介</h2><p id="f3fd" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">我们非常喜欢systemd <code class="fe mn mo mp mq b"><a class="ae km" href="https://www.freedesktop.org/software/systemd/man/systemd.exec.html#SystemCallFilter=" rel="noopener ugc nofollow" target="_blank">SystemCallFilter=</a></code>指令的“零代码seccomp”方法，但是对它的局限性不满意。我们决定更进一步，在不触及源代码的情况下，从外部禁止任何进程中的任何系统调用，因此推出了<a class="ae km" href="https://github.com/cloudflare/sandbox" rel="noopener ugc nofollow" target="_blank"> Cloudflare沙箱</a>。这是一个简单的独立工具包，由一个共享库和一个可执行文件组成。共享库应该用于动态链接的应用程序，而可执行文件则用于静态链接的应用程序。</p><h2 id="c739" class="kz la iq bd lb lc ld dn le lf lg dp lh jy li lj lk kc ll lm ln kg lo lp lq lr bi translated">沙箱动态链接的可执行文件</h2><p id="218c" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">对于动态链接的可执行文件，可以利用<code class="fe mn mo mp mq b"><a class="ae km" href="https://www.man7.org/linux/man-pages/man8/ld.so.8.html" rel="noopener ugc nofollow" target="_blank">LD_PRELOAD</a></code>环境变量将定制代码注入到进程中。我们工具包中的<code class="fe mn mo mp mq b">libsandbox.so</code>共享库还包含一个所谓的<a class="ae km" href="https://gcc.gnu.org/onlinedocs/gccint/Initialization.html" rel="noopener ugc nofollow" target="_blank">初始化例程</a>，它应该在主逻辑之前执行。这就是我们如何制作目标应用程序沙箱本身:</p><ul class=""><li id="5a02" class="lz ma iq jp b jq jr ju jv jy mb kc mc kg md kk me mf mg mh bi translated"><code class="fe mn mo mp mq b"><a class="ae km" href="https://www.man7.org/linux/man-pages/man8/ld.so.8.html" rel="noopener ugc nofollow" target="_blank">LD_PRELOAD</a></code>告诉动态加载器在应用程序启动时加载我们的<code class="fe mn mo mp mq b">libsandbox.so</code>作为应用程序的一部分</li><li id="eb16" class="lz ma iq jp b jq mi ju mj jy mk kc ml kg mm kk me mf mg mh bi translated">运行时在大多数主逻辑之前执行来自<code class="fe mn mo mp mq b">libsandbox.so</code>的<a class="ae km" href="https://gcc.gnu.org/onlinedocs/gccint/Initialization.html" rel="noopener ugc nofollow" target="_blank">初始化例程</a></li><li id="0213" class="lz ma iq jp b jq mi ju mj jy mk kc ml kg mm kk me mf mg mh bi translated">我们的初始化例程配置在特殊环境变量中描述的沙盒策略</li><li id="3a9e" class="lz ma iq jp b jq mi ju mj jy mk kc ml kg mm kk me mf mg mh bi translated">当主应用程序逻辑开始执行时，目标进程已经实施了配置的seccomp策略</li></ul><p id="6f7c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看看它是如何与我们的<code class="fe mn mo mp mq b">myos</code>玩具工具一起工作的。首先，我们需要确保它实际上是一个动态链接的应用程序:</p><pre class="ko kp kq kr gt mr mq ms mt aw mu bi"><span id="70d5" class="kz la iq mq b gy mv mw l mx my">$ ldd ./myos<br/>	linux-vdso.so.1 (0x00007ffd8e1e3000)<br/>	libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f339ddfb000)<br/>	/lib64/ld-linux-x86-64.so.2 (0x00007f339dfcf000)</span></pre><p id="8b67" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">是的，它是。现在，让我们用我们的工具包禁止它使用<a class="ae km" href="https://www.man7.org/linux/man-pages/man2/uname.2.html" rel="noopener ugc nofollow" target="_blank"> uname </a>系统调用:</p><pre class="ko kp kq kr gt mr mq ms mt aw mu bi"><span id="b54f" class="kz la iq mq b gy mv mw l mx my">$ LD_PRELOAD=/usr/lib/x86_64-linux-gnu/libsandbox.so SECCOMP_SYSCALL_DENY=uname ./myos<br/>adding uname to the process seccomp filter<br/>Bad system call</span></pre><p id="a523" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们再次成功地将我们想要的seccomp策略注入到<code class="fe mn mo mp mq b">myos</code>应用程序中，而没有修改或重新编译它。这种方法的优点是它没有systemd的<code class="fe mn mo mp mq b"><a class="ae km" href="https://www.freedesktop.org/software/systemd/man/systemd.exec.html#SystemCallFilter=" rel="noopener ugc nofollow" target="_blank">SystemCallFilter=</a></code>的缺点，我们可以阻塞任何系统调用(幸运的是<a class="ae km" href="https://www.gnu.org/software/bash/" rel="noopener ugc nofollow" target="_blank"> Bash </a>也是一个动态链接的应用程序):</p><pre class="ko kp kq kr gt mr mq ms mt aw mu bi"><span id="109a" class="kz la iq mq b gy mv mw l mx my">$ /bin/bash -c 'echo I will try to execve something...; exec /usr/bin/echo Doing arbitrary code execution!!!'<br/>I will try to execve something...<br/>Doing arbitrary code execution!!!<br/>$ LD_PRELOAD=/usr/lib/x86_64-linux-gnu/libsandbox.so SECCOMP_SYSCALL_DENY=execve /bin/bash -c 'echo I will try to execve something...; exec /usr/bin/echo Doing arbitrary code execution!!!'<br/>adding execve to the process seccomp filter<br/>I will try to execve something...<br/>Bad system call</span></pre><p id="3afa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里唯一的问题是，我们可能会不小心忘记<code class="fe mn mo mp mq b">LD_PRELOAD</code>我们的<code class="fe mn mo mp mq b">libsandbox.so</code>库，并可能不受保护地运行。此外，如<a class="ae km" href="https://www.man7.org/linux/man-pages/man8/ld.so.8.html" rel="noopener ugc nofollow" target="_blank">手册页</a>中所述，<code class="fe mn mo mp mq b">LD_PRELOAD</code>也有一些限制。我们可以通过使<code class="fe mn mo mp mq b">libsandbox.so</code>成为我们目标应用程序的永久部分来克服所有这些问题:</p><pre class="ko kp kq kr gt mr mq ms mt aw mu bi"><span id="7bde" class="kz la iq mq b gy mv mw l mx my">$ patchelf --add-needed /usr/lib/x86_64-linux-gnu/libsandbox.so ./myos<br/>$ ldd ./myos<br/>	linux-vdso.so.1 (0x00007fff835ae000)<br/>	/usr/lib/x86_64-linux-gnu/libsandbox.so (0x00007fc4f55f2000)<br/>	libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007fc4f5425000)<br/>	/lib64/ld-linux-x86-64.so.2 (0x00007fc4f5647000)</span></pre><p id="099e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">同样，我们在这里不需要访问源代码，而是修补编译后的二进制文件。现在我们可以像以前一样配置我们的seccomp策略，而不需要<code class="fe mn mo mp mq b">LD_PRELOAD</code>:</p><pre class="ko kp kq kr gt mr mq ms mt aw mu bi"><span id="fd01" class="kz la iq mq b gy mv mw l mx my">$ ./myos<br/>My OS is Linux!<br/>$ SECCOMP_SYSCALL_DENY=uname ./myos<br/>adding uname to the process seccomp filter<br/>Bad system call</span></pre><h2 id="ddac" class="kz la iq bd lb lc ld dn le lf lg dp lh jy li lj lk kc ll lm ln kg lo lp lq lr bi translated">沙箱静态链接的可执行文件</h2><p id="3b0f" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">上面的方法非常方便简单，但是它不适用于静态链接的可执行文件:</p><pre class="ko kp kq kr gt mr mq ms mt aw mu bi"><span id="987c" class="kz la iq mq b gy mv mw l mx my">$ gcc -static -o myos myos.c<br/>$ ldd ./myos<br/>	not a dynamic executable<br/>$ LD_PRELOAD=/usr/lib/x86_64-linux-gnu/libsandbox.so SECCOMP_SYSCALL_DENY=uname ./myos<br/>My OS is Linux!</span></pre><p id="81d2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是因为没有<a class="ae km" href="https://www.man7.org/linux/man-pages/man8/ld.so.8.html" rel="noopener ugc nofollow" target="_blank">动态加载器</a>参与启动一个静态链接的可执行文件，所以<code class="fe mn mo mp mq b">LD_PRELOAD</code>没有影响。对于这种情况，我们的工具包包含一个特殊的应用程序启动器，它将以类似于systemd的方式注入seccomp规则:</p><pre class="ko kp kq kr gt mr mq ms mt aw mu bi"><span id="8c71" class="kz la iq mq b gy mv mw l mx my">$ sandboxify ./myos<br/>My OS is Linux!<br/>$ SECCOMP_SYSCALL_DENY=uname sandboxify ./myos<br/>adding uname to the process seccomp filter</span></pre><p id="e2f3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意，我们再也看不到<code class="fe mn mo mp mq b">Bad system call</code> shell消息了，因为我们的目标可执行文件是由启动器启动的，而不是由shell直接启动的。然而，与systemd不同，我们可以使用这个启动器来阻止危险的系统调用，比如<a class="ae km" href="https://www.man7.org/linux/man-pages/man2/execve.2.html" rel="noopener ugc nofollow" target="_blank"> execve </a>:</p><pre class="ko kp kq kr gt mr mq ms mt aw mu bi"><span id="8f93" class="kz la iq mq b gy mv mw l mx my">$ sandboxify /bin/bash -c 'echo I will try to execve something...; exec /usr/bin/echo Doing arbitrary code execution!!!'<br/>I will try to execve something...<br/>Doing arbitrary code execution!!!<br/>SECCOMP_SYSCALL_DENY=execve sandboxify /bin/bash -c 'echo I will try to execve something...; exec /usr/bin/echo Doing arbitrary code execution!!!'<br/>adding execve to the process seccomp filter<br/>I will try to execve something...</span></pre><h2 id="078a" class="kz la iq bd lb lc ld dn le lf lg dp lh jy li lj lk kc ll lm ln kg lo lp lq lr bi translated">sandboxify vs libsandbox.so</h2><p id="fac0" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">从上面的例子中，你可能会注意到对动态链接的可执行文件使用<code class="fe mn mo mp mq b">sandboxify</code>也是可能的，那么为什么还要用<code class="fe mn mo mp mq b">libsandbox.so</code>呢？当我们开始使用“denylist”策略，而不是本文中大多数例子中的“denylist”策略，而是首选的“allowlist”策略时，差异就变得明显了，在allow list策略中，我们只显式地允许我们需要的系统调用，而禁止其他所有的调用。</p><p id="59ee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们将我们的玩具应用程序转换回动态链接应用程序，并尝试列出它正常运行所需的最少允许系统调用列表:</p><pre class="ko kp kq kr gt mr mq ms mt aw mu bi"><span id="f61b" class="kz la iq mq b gy mv mw l mx my">$ gcc -o myos myos.c<br/>$ ldd ./myos<br/>	linux-vdso.so.1 (0x00007ffe027f6000)<br/>	libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f4f1410a000)<br/>	/lib64/ld-linux-x86-64.so.2 (0x00007f4f142de000)<br/>$ LD_PRELOAD=/usr/lib/x86_64-linux-gnu/libsandbox.so SECCOMP_SYSCALL_ALLOW=exit_group:fstat:uname:write ./myos<br/>adding exit_group to the process seccomp filter<br/>adding fstat to the process seccomp filter<br/>adding uname to the process seccomp filter<br/>adding write to the process seccomp filter<br/>My OS is Linux</span></pre><p id="95f5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以我们需要允许4个系统调用:<code class="fe mn mo mp mq b">exit_group:fstat:uname:write</code>。这是最严密的“沙箱”，仍然没有打破应用。如果我们从这个列表中删除任何系统调用，应用程序将终止并显示<code class="fe mn mo mp mq b">Bad system call</code>消息(自己试试吧！).</p><p id="8317" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们使用相同的allowlist，但是使用<code class="fe mn mo mp mq b">sandboxify</code>启动器，事情就不再工作了:</p><pre class="ko kp kq kr gt mr mq ms mt aw mu bi"><span id="1c77" class="kz la iq mq b gy mv mw l mx my">$ SECCOMP_SYSCALL_ALLOW=exit_group:fstat:uname:write sandboxify ./myos<br/>adding exit_group to the process seccomp filter<br/>adding fstat to the process seccomp filter<br/>adding uname to the process seccomp filter<br/>adding write to the process seccomp filter</span></pre><p id="cd47" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">原因是<code class="fe mn mo mp mq b">sandboxify</code>和<code class="fe mn mo mp mq b">libsandbox.so</code>在流程生命周期的不同阶段注入seccomp规则。考虑以下流程启动的高级图表:</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi nf"><img src="../Images/0adce98cbcc48451801fd6e1cf831c24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*rq1WjwiNSPvqQn17.png"/></div></div></figure><p id="5d57" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">简而言之，每个进程都有两个运行时阶段:“运行时初始化”和“主逻辑”。主要逻辑基本上是代码，它位于程序<code class="fe mn mo mp mq b">main()</code>函数和应用程序开发人员放在那里的其他代码中。但是在来自<code class="fe mn mo mp mq b">main()</code>函数的代码能够执行之前，进程通常需要做一些工作——在上图中，我们将这些工作称为“运行时初始化”。开发人员并不直接编写这些代码，但是大多数时候这些代码是由编译器工具链自动生成的，编译器工具链用于编译源代码。</p><p id="be84" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了完成它的工作,“运行时初始化”阶段使用了许多不同的系统调用，但是在“主逻辑”阶段，大部分都是不需要的。如果我们在沙箱中使用“allowlist”方法，那么如果这些系统调用只在程序初始化中使用一次，那么在程序的整个运行过程中允许它们是没有意义的。这就是<code class="fe mn mo mp mq b">libsandbox.so</code>和<code class="fe mn mo mp mq b">sandboxify</code>的区别所在:<code class="fe mn mo mp mq b">libsandbox.so</code>通常在“运行时初始化”阶段已经执行之后执行seccomp规则，所以我们不必允许来自那个阶段的大多数系统调用。<code class="fe mn mo mp mq b">sandboxify</code>另一方面，在“运行时初始化”阶段之前实施策略，因此我们必须允许来自两个阶段的所有系统调用，这通常会导致更大的allowlist，从而扩大攻击面。</p><p id="c4eb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">回到我们的玩具<code class="fe mn mo mp mq b">myos</code>的例子，这里是所有系统调用的最小列表，我们需要允许应用程序在我们的沙箱下工作:</p><pre class="ko kp kq kr gt mr mq ms mt aw mu bi"><span id="90ef" class="kz la iq mq b gy mv mw l mx my">$ SECCOMP_SYSCALL_ALLOW=access:arch_prctl:brk:close:exit_group:fstat:mmap:mprotect:munmap:openat:read:uname:write sandboxify ./myos<br/>adding access to the process seccomp filter<br/>adding arch_prctl to the process seccomp filter<br/>adding brk to the process seccomp filter<br/>adding close to the process seccomp filter<br/>adding exit_group to the process seccomp filter<br/>adding fstat to the process seccomp filter<br/>adding mmap to the process seccomp filter<br/>adding mprotect to the process seccomp filter<br/>adding munmap to the process seccomp filter<br/>adding openat to the process seccomp filter<br/>adding read to the process seccomp filter<br/>adding uname to the process seccomp filter<br/>adding write to the process seccomp filter<br/>My OS is Linux!</span></pre><p id="afe3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们使用<code class="fe mn mo mp mq b">libsandbox.so</code>方法，这是13个系统调用对4个系统调用！</p><h2 id="45bd" class="kz la iq bd lb lc ld dn le lf lg dp lh jy li lj lk kc ll lm ln kg lo lp lq lr bi translated">结论</h2><p id="35f4" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">在这篇文章中，我们讨论了如何轻松地在Linux上用沙箱保护应用程序，而不需要编写任何额外的代码。我们介绍了<a class="ae km" href="https://github.com/cloudflare/sandbox" rel="noopener ugc nofollow" target="_blank"> Cloudflare沙盒工具包</a>，并讨论了我们在沙盒化动态链接应用程序和静态链接应用程序时采用的不同方法。</p><p id="dd83" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">拥有更安全的在线代码有助于建立一个更好的互联网，如果你觉得我们的<a class="ae km" href="https://github.com/cloudflare/sandbox" rel="noopener ugc nofollow" target="_blank">沙盒工具包</a>有用，我们会很高兴。期待反馈、改进和其他贡献！</p></div></div>    
</body>
</html>