<html>
<head>
<title>How Computers Generate Random Numbers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">计算机如何产生随机数</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-do-computers-generate-random-numbers-a72be65877f6?source=collection_archive---------0-----------------------#2021-01-07">https://levelup.gitconnected.com/how-do-computers-generate-random-numbers-a72be65877f6?source=collection_archive---------0-----------------------#2021-01-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="8984" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">信不信由你，遵循规则的机器实际上是相当自发的。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/11fbedef953c2d5aad1e8583700a0ae9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*mQDq7K37Lnh-066J.jpg"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">图片由<a class="ae lb" href="https://pixabay.com/photos/games-dice-of-cube-statistics-4725932/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>上的<a class="ae lb" href="https://pixabay.com/users/jaclou-dl-5602247/" rel="noopener ugc nofollow" target="_blank"> JACLOU-DL </a>拍摄</figcaption></figure><h2 id="d532" class="lc ld iq bd le lf lg dn lh li lj dp lk jy ll lm ln kc lo lp lq kg lr ls lt lu bi translated">索引</h2><ul class=""><li id="8dd6" class="lv lw iq jp b jq lx ju ly jy lz kc ma kg mb kk mc md me mf bi translated"><a class="ae lb" href="#5e79" rel="noopener ugc nofollow">真随机数发生器(附例子)</a></li><li id="94c5" class="lv lw iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated"><a class="ae lb" href="#e15c" rel="noopener ugc nofollow">伪随机数发生器(附示例)</a></li><li id="2a7e" class="lv lw iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated"><a class="ae lb" href="#fc8f" rel="noopener ugc nofollow">比较两者:trng vs prng</a></li><li id="33db" class="lv lw iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated"><a class="ae lb" href="#71d9" rel="noopener ugc nofollow">汇总表</a></li></ul><p id="e83f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我想我们都遇到过这样的群体情况:有一项可怕的任务必须完成，但没有人愿意去做。无论是坏消息还是项目结束后的清理工作，总有人要为团队做点什么。</p><p id="b67a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那你怎么解决呢？你不能让某人随便选一个号码，因为他们总是可以改变他们的号码来刁难他们最不喜欢的成员。你能做的就是<a class="ae lb" href="https://www.google.com/search?q=flip+a+coin&amp;oq=flip+a+coin&amp;aqs=chrome.0.69i59j0l4j69i60l3.1511j0j7&amp;sourceid=chrome&amp;ie=UTF-8" rel="noopener ugc nofollow" target="_blank">让电脑帮你做</a>。但是产生的数字真的是随机的吗？<strong class="jp ir">计算机，一台被定义为遵守指令和公式的机器，是如何产生随机结果的？</strong></p><p id="18ed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们开始之前，有一点很重要，那就是随机生成比解决群体纠纷更有用。随机性是赌博、视频游戏、统计抽样以及最著名的密码学的前沿。如果它们不是不可预测的，我们的设备将缺乏基本的安全功能，更容易受到网络攻击。</p><p id="5e79" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">计算机产生随机数的方法主要有两种:<strong class="jp ir">真随机数发生器(trng)</strong>和<strong class="jp ir">伪随机数发生器(prng)</strong>。前者使用计算机之外的一些现象来生成数字，而后者依靠预设的算法来模拟随机性。</p><p id="bc89" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果这还没有任何意义，不要担心<strong class="jp ir"/>——接下来还有更多。</p><h1 id="9579" class="ml ld iq bd le mm mn mo lh mp mq mr lk ms mt mu ln mv mw mx lq my mz na lt nb bi translated"><strong class="ak">真随机数发生器(trng)</strong></h1><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nc"><img src="../Images/61656cec065aab288a8e9f28f7574558.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d7LYBntrJX2PXBW6DhsMwg.jpeg"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated"><a class="ae lb" href="https://hackaday.io/project/4628-nuclear-random-number-generator" rel="noopener ugc nofollow" target="_blank">核随机数发生器</a>由<a class="ae lb" href="https://hackaday.io/mano" rel="noopener ugc nofollow" target="_blank"> M.daSilva </a></figcaption></figure><p id="50f3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">真正的随机数发生器(也称为硬件随机数发生器)通过<strong class="jp ir">收集熵</strong>来产生数字，这意味着它们从不可预测的环境条件中收集信息。</p><p id="d878" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了将一些物理现象转换成数字，TRNG必须有几个硬件组件:</p><ul class=""><li id="c328" class="lv lw iq jp b jq jr ju jv jy nd kc ne kg nf kk mc md me mf bi translated"><strong class="jp ir">传感器:</strong>将被测现象转换成电信号</li><li id="3cf9" class="lv lw iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated"><strong class="jp ir">一个放大器:</strong>这增加了信号中随机变化的幅度，因此它们可以被设备识别</li><li id="ecc5" class="lv lw iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated"><strong class="jp ir">模数转换器:</strong>将信号转换成数字</li></ul><p id="1e75" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">TRNG源的一些例子包括大气噪声、时间和放射性衰变。</p><h2 id="1f7c" class="lc ld iq bd le lf lg dn lh li lj dp lk jy ll lm ln kc lo lp lq kg lr ls lt lu bi translated">大气噪声</h2><p id="e374" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy ng ka kb kc nh ke kf kg ni ki kj kk ij bi translated">这利用了大气中发生的RNG过程。最常见的是，它能捕捉到闪电产生的静电，这种现象在second⁴.大约发生40次这种方法就像它们一样不可预测。</p><blockquote class="nj nk nl"><p id="7daf" class="jn jo nm jp b jq jr js jt ju jv jw jx nn jz ka kb no kd ke kf np kh ki kj kk ij bi translated"><a class="ae lb" href="https://www.random.org/" rel="noopener ugc nofollow" target="_blank">众所周知，Random.org</a>使用大气噪音为各种不同的场景生成随机结果。强烈推荐去看看！</p></blockquote><h2 id="1e3b" class="lc ld iq bd le lf lg dn lh li lj dp lk jy ll lm ln kc lo lp lq kg lr ls lt lu bi translated">时间</h2><p id="8502" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy ng ka kb kc nh ke kf kg ni ki kj kk ij bi translated">一些TRNGs将使用您按键或单击鼠标的精确纳秒来生成一个随机数。例如:如果你想生成一个介于1和10之间的整数值，你在下午4:50:52.287503482点整按下回车键(是的，我刚刚敲了键盘)，那么计算机可能会取最后一个数字，并使用“2”作为输出。</p><h2 id="ef8d" class="lc ld iq bd le lf lg dn lh li lj dp lk jy ll lm ln kc lo lp lq kg lr ls lt lu bi translated"><strong class="ak">放射性衰变</strong></h2><p id="3e6c" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy ng ka kb kc nh ke kf kg ni ki kj kk ij bi translated">当原子核不稳定时，没有办法预测它何时衰变。这使得它成为产生真随机数的理想的熵源。</p><blockquote class="nj nk nl"><p id="e15c" class="jn jo nm jp b jq jr js jt ju jv jw jx nn jz ka kb no kd ke kf np kh ki kj kk ij bi translated">如果你有兴趣了解更多关于放射性衰变和RNG的知识，你可能想看看FormiLab的热门话题。</p></blockquote><h1 id="f49b" class="ml ld iq bd le mm mn mo lh mp mq mr lk ms mt mu ln mv mw mx lq my mz na lt nb bi translated"><strong class="ak">伪随机数发生器</strong></h1><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/697f38bb8e0fb0165798094f2f65b04c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/0*1jKiWESfWpZM2RQ8"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">图片来自<a class="ae lb" href="https://www.pexels.com/photo/code-coding-computer-cyberspace-270373/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a></figcaption></figure><p id="6cb5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">PRNGs依靠算法生成看似随机的数字序列。正如前缀“pseudo”所暗示的，这个序列实际上并不是随机的，只是看起来像而已。PRNG的两个主要组成部分是初始值或<strong class="jp ir">种子、</strong>和预设的<strong class="jp ir">算法</strong>。</p><p id="46c8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它是这样工作的。发电机必须:</p><ol class=""><li id="7b05" class="lv lw iq jp b jq jr ju jv jy nd kc ne kg nf kk nr md me mf bi translated"><strong class="jp ir">接收</strong>初始值或<strong class="jp ir">种子</strong>作为输入</li><li id="b500" class="lv lw iq jp b jq mg ju mh jy mi kc mj kg mk kk nr md me mf bi translated">通过对种子应用一系列数学变换来生成一个新数字</li><li id="87dd" class="lv lw iq jp b jq mg ju mh jy mi kc mj kg mk kk nr md me mf bi translated"><strong class="jp ir">使用</strong>获得的值作为下一次迭代的种子</li><li id="85fb" class="lv lw iq jp b jq mg ju mh jy mi kc mj kg mk kk nr md me mf bi translated"><strong class="jp ir">重复</strong>过程，直到达到所需长度</li></ol><p id="03b9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">PRNGs是<strong class="jp ir">确定性</strong>和<strong class="jp ir">周期性</strong>。它们是确定性的，因为一旦定义了算法和种子，就没有什么可以改变输出的数字。序列中的每个连续数字都与前面的数字相关；这就是所谓的递归关系。PRNGs是周期性的，这意味着它们在一定次数的迭代后会重复自身。一个好的PRNG算法应该有很长的周期。</p><p id="f1c2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们来看一些例子:线性同余发生器<strong class="jp ir">和中间平方发生器</strong>。</p><blockquote class="nj nk nl"><p id="95dd" class="jn jo nm jp b jq jr js jt ju jv jw jx nn jz ka kb no kd ke kf np kh ki kj kk ij bi translated">注意:PRNGs还有无数其他类型和变体，其中一些听起来很酷，比如<a class="ae lb" href="https://numpy.org/doc/stable/reference/random/bit_generators/philox.html" rel="noopener ugc nofollow" target="_blank"> Philox </a>和<a class="ae lb" href="https://www.sciencedirect.com/topics/computer-science/mersenne-twister" rel="noopener ugc nofollow" target="_blank"> Mersenne Twister </a>。</p></blockquote><h2 id="509c" class="lc ld iq bd le lf lg dn lh li lj dp lk jy ll lm ln kc lo lp lq kg lr ls lt lu bi translated"><strong class="ak">线性同余发生器</strong></h2><p id="d650" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy ng ka kb kc nh ke kf kg ni ki kj kk ij bi translated">线性同余发生器(LCG) <strong class="jp ir"> </strong>于1958年首次亮相，是至今最流行的algorithms⁵.之一</p><p id="c33d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它遵循以下格式的递归关系:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/9d8c7d4e7715154c8f023f8da8681e7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:784/format:webp/1*9oLQU-xkgRNA8-o0yXhD8w.png"/></div></figure><p id="2398" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在哪里</p><ul class=""><li id="5c2e" class="lv lw iq jp b jq jr ju jv jy nd kc ne kg nf kk mc md me mf bi translated">X₀是<strong class="jp ir">种子</strong>或<strong class="jp ir">起始值(0 ≤ X₀ &lt; m) </strong></li><li id="ef5d" class="lv lw iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated">a为<strong class="jp ir">乘数(0 ≤ a &lt; m) </strong>，</li><li id="e91b" class="lv lw iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated">c为<strong class="jp ir">增量(0 ≤ c &lt; m) </strong>，且</li><li id="676f" class="lv lw iq jp b jq mg ju mh jy mi kc mj kg mk kk mc md me mf bi translated">m是<strong class="jp ir">模数(m &gt; 0) </strong></li></ul><p id="bc62" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们使用上面概述的过程来尝试一个例子。设X₀ = 235，a = 2,398，c = 8,738，m = 100万。</p><p id="291e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">步骤1:接收一个初始值或种子作为输入。</p><p id="0b6d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">太好了！我们已经做到了:<strong class="jp ir"> X₀ = 235。</strong></p><p id="94e9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">第二步:通过对种子应用一系列数学变换来生成一个新数字。</strong></p><p id="3e49" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用a、c和m的值，我们可以完成计算:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/b599410d75a65776ad19508d9a3b3487.png" data-original-src="https://miro.medium.com/v2/resize:fit:1016/format:webp/1*a7uAxTOVpOp3nSb4dRTn1A.png"/></div></figure><ul class=""><li id="a55a" class="lv lw iq jp b jq jr ju jv jy nd kc ne kg nf kk mc md me mf bi translated">100万适合572268<strong class="jp ir">乘以</strong>0，剩下<strong class="jp ir">572268</strong>的余数。</li></ul><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/d8955966f235f86989e872d03dd35f1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:348/format:webp/1*QWHAsbUuu5QjHlHo6WBjxQ.png"/></div></figure><p id="af34" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">第三步:使用获得的值作为下一次迭代的种子。</strong></p><p id="1275" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的X₁是572，268，所以要得到我们的X₂，我们只需再次使用我们的公式:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/edf94c70f243413bab2db53bd638e35a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/format:webp/1*AjSHIKTisQz9ssyrMQ8m9Q.png"/></div></figure><ul class=""><li id="633a" class="lv lw iq jp b jq jr ju jv jy nd kc ne kg nf kk mc md me mf bi translated">1，000，000 <strong class="jp ir"> </strong>适合1，372，307，402 <strong class="jp ir">的1372倍，</strong>剩下剩余的<strong class="jp ir"> 307，402 </strong>。</li></ul><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/8aa32038707bb9aa2f0a4d0ae1e95a2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:344/format:webp/1*WStkO9oBOiHqAbcuVa5oIg.png"/></div></figure><p id="62f2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第四步:重复这个过程，直到达到想要的长度。</p><p id="6a99" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过重复步骤1到3，我们发现这个序列的前10个数字是572268、307402、158734、652870和590998。看起来很随意，不是吗？</p><p id="a948" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您不喜欢手动进行所有这些计算，我创建了一个方法，它返回由线性同余算法生成的一系列值。下面是用Java语言呈现的:</p><pre class="km kn ko kp gt nx ny nz oa aw ob bi"><span id="01f2" class="lc ld iq ny b gy oc od l oe of">public static String generateRandomNumbers(int length, long x0, long a, long c, long m)<br/> {<br/>  StringBuilder sb = new StringBuilder();<br/>  <br/>  long x[] = new long [length];<br/>  x[0] = x0;<br/>  <br/><strong class="ny ir">// applies a series of mathematical operations to a term (x[i]) in order to find the next term in the sequence (x[i+1]); this repeats until the desired length is achieved</strong></span><span id="755f" class="lc ld iq ny b gy og od l oe of">  for(int i = 0; i&lt; length-1; i++)<br/>  {<br/>   x[i+1] = (long) ((a*x[i] + c) % m);<br/>   sb.append(x[i+1]+" ");<br/>  }<br/>  <br/>  String results = sb.toString();<br/>  <br/>  return results;<br/> }</span></pre><h2 id="f34c" class="lc ld iq bd le lf lg dn lh li lj dp lk jy ll lm ln kc lo lp lq kg lr ls lt lu bi translated">中间平方生成器</h2><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi oh"><img src="../Images/3904c4a9c38fa03b3ea223c4c49b702c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bZFXWE0yLopw5jwtESLtsw.png"/></div></div></figure><p id="d925" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">中间平方方法是乔恩·冯·诺依曼在1949年发明的，其工作原理是用<strong class="jp ir">对种子值</strong>求平方，<strong class="jp ir">提取其中的中间数字</strong>作为下一个种子。⁶</p><blockquote class="nj nk nl"><p id="7cd4" class="jn jo nm jp b jq jr js jt ju jv jw jx nn jz ka kb no kd ke kf np kh ki kj kk ij bi translated">注意:这种方法被认为是不太实用的算法之一，因为它的周期较短。大量的种子值很快会导致零或其他数字的重复。</p></blockquote><p id="35aa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">要让这个方法生效，需要满足几个条件:</strong></p><ul class=""><li id="55c8" class="lv lw iq jp b jq jr ju jv jy nd kc ne kg nf kk mc md me mf bi translated"><strong class="jp ir">平方种子的位数必须至少是种子的两倍。</strong>如果不是这种情况，则添加前导零进行补偿。</li></ul><p id="53a5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="nm">例如，如果我们的种子是20，那么种子就是400。400有3位数，20有2位数。由于3 &lt; 2*10，我们加一个前导零使平方值为0400，我们的输出是40。</em></p><ul class=""><li id="5aa9" class="lv lw iq jp b jq jr ju jv jy nd kc ne kg nf kk mc md me mf bi translated"><strong class="jp ir">种子必须有偶数位数。</strong>这是因为对奇数求平方并不保证会有中间数字要提取。</li></ul><p id="407b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="nm">如果我们的种子是617，那么种子就是380689。这里，种子中的位数是种子位数的2倍，因此满足该条件。然而，没有3个中间数字是有效的。这可以通过在种子中添加前导零来纠正:0617→00</em><strong class="jp ir"><em class="nm">3806</em></strong><em class="nm">89→3806。</em></p><p id="f353" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">同样，我们可以创建一个Java程序，它将一个种子作为输入，并生成一个数字序列。</p><p id="63c4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们必须创建一个方法来获取种子，对其求平方，然后提取中间的数字:</p><pre class="km kn ko kp gt nx ny nz oa aw ob bi"><span id="34c0" class="lc ld iq ny b gy oc od l oe of"><strong class="ny ir">// String x = seed // int digitsX = number of digits in the seed</strong></span><span id="0f4c" class="lc ld iq ny b gy og od l oe of">public static String getMiddleDigits(String x, int digitsX)<br/> {<br/>  String leadingZeros="";<br/>  <br/><strong class="ny ir">// adds leading zeros</strong></span><span id="a9e1" class="lc ld iq ny b gy og od l oe of">  for(int k = 0; k &lt; x.length(); k++)<br/>  {<br/>  if(x.charAt(k)!='0') {<br/>   break;<br/>  } else {<br/>   leadingZeros+="00";<br/>  }<br/>  }</span><span id="efa7" class="lc ld iq ny b gy og od l oe of"><strong class="ny ir">// squares the seed, converts it to a string array, and obtains the number of digits<br/></strong>  <br/>  String squared = leadingZeros + String.valueOf((long) Math.pow(Integer.parseInt(x), 2));<br/>  String[] stringSquared = squared.split("");<br/>  int digitsSquared = stringSquared.length;<br/>  <br/>  <strong class="ny ir">// finds the digit in the squared seed where the next term will start</strong></span><span id="dc82" class="lc ld iq ny b gy og od l oe of">  int start = (int) (digitsSquared - digitsX) / 2;<br/>  String [] newTerm = new String [digitsX];</span><span id="2cf8" class="lc ld iq ny b gy og od l oe of">StringBuilder sb = new StringBuilder();<br/>  <br/><strong class="ny ir">// creates the new term by adding digits from the middle of the squared seed to an array</strong></span><span id="2653" class="lc ld iq ny b gy og od l oe of">  for(int j = 0; j &lt; digitsX; j++)<br/>  {<br/>   newTerm[j] = stringSquared[start+j];<br/>   sb.append(newTerm[j]);<br/>  }</span><span id="c907" class="lc ld iq ny b gy og od l oe of">  String middleDigits = sb.toString();<br/>  <br/>  return middleDigits;<br/> }</span></pre><p id="a0dc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，我们让它重复这个过程来生成序列中的前200个数字:</p><pre class="km kn ko kp gt nx ny nz oa aw ob bi"><span id="98de" class="lc ld iq ny b gy oc od l oe of">public static String generateRandomNumbers(String x0)<br/> {<br/>  String x[] = new String [200];<br/>  x[0] = x0;</span><span id="ab7f" class="lc ld iq ny b gy og od l oe of"><strong class="ny ir">// finds the number of digits in the seed<br/></strong> <br/>  int digitsX = (x[0]).split("").length;<br/>  <br/>  StringBuilder sb = new StringBuilder();<br/>  <br/><strong class="ny ir">// applies the getMiddleDigits method to create a sequence of seemingly random numbers</strong></span><span id="aaee" class="lc ld iq ny b gy og od l oe of">  for(int i=0; i&lt;199; i++)<br/>  {<br/>   x[i + 1] = getMiddleDigits(x[i], digitsX);<br/>   sb.append(x[i + 1] + " ");<br/>  }<br/>  <br/>  String results = sb.toString();<br/><br/>  return results;<br/> }</span></pre><p id="fc8f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在你知道了！中间平方生成器。</p><h1 id="24b9" class="ml ld iq bd le mm mn mo lh mp mq mr lk ms mt mu ln mv mw mx lq my mz na lt nb bi translated">TRNGs和PRNGs哪个生成器更好？</h1><p id="d296" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy ng ka kb kc nh ke kf kg ni ki kj kk ij bi translated">要看什么叫“更好”。</p><p id="4362" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们谈论的是便利性，PRNG拿走了蛋糕。因为它们依赖于外部条件，所以大多数TRNGs需要昂贵的仪器和资源，并且必须持续监测其损害。说说高维护。</p><p id="ecd6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">谈到网络安全，TRNG是你的赢家。对于序列真随机数，除了它们来自同一个熵源之外，后续值之间没有关系。通过这种方式，TRNGs几乎不可能预测，因此对网络攻击的防御要安全得多。PRNGs是确定性的；因为序列中的每个数字都依赖于前面的数字，所以它们更容易被解密。</p><p id="71d9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">伪随机数也是周期性的；他们最终会重复自己。这在某些情况下可能会有问题，但实际上，在周期足够长的情况下，通常很容易找到输入组合。</p><h1 id="95ad" class="ml ld iq bd le mm mn mo lh mp mq mr lk ms mt mu ln mv mw mx lq my mz na lt nb bi translated">一览表</h1><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi oi"><img src="../Images/8c407ab8fc0db2644fbc6d0816583bb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nOT2VK7dQnY3MihmKTGX5Q.png"/></div></div></figure></div><div class="ab cl oj ok hu ol" role="separator"><span class="om bw bk on oo op"/><span class="om bw bk on oo op"/><span class="om bw bk on oo"/></div><div class="ij ik il im in"><h1 id="0dce" class="ml ld iq bd le mm oq mo lh mp or mr lk ms os mu ln mv ot mx lq my ou na lt nb bi translated">参考</h1><p id="27fa" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy ng ka kb kc nh ke kf kg ni ki kj kk ij bi translated">[1] C. Hoffman，<a class="ae lb" href="http://www.howtogeek.com/183051/htg-explains-how-computers-generate-random-numbers/." rel="noopener ugc nofollow" target="_blank">计算机如何产生随机数。</a> (2019)，极客入门</p><p id="841a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">[2] M. Haahr，<a class="ae lb" href="http://www.random.org/randomness/." rel="noopener ugc nofollow" target="_blank">真随机数服务。</a> (1998)，随机。（同organic）有机</p><p id="e718" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">[3] A. Arobelidze，<a class="ae lb" href="http://www.freecodecamp.org/news/random-number-generator/." rel="noopener ugc nofollow" target="_blank">随机数生成器:计算机如何生成随机数？</a> (2020年)，FreeCodeCamp.org</p><p id="c65a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">[4] P .林奇，<a class="ae lb" href="https://www.irishtimes.com/news/science/random-numbers-plucked-from-the-atmosphere-1.3714968" rel="noopener ugc nofollow" target="_blank">从大气中随机抽取的数字。</a> (2018)，《爱尔兰时报》</p><p id="4737" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">[5] V .拉文德兰，<a class="ae lb" href="http://theurbanengine.com/blog//linear-congruential-generator" rel="noopener ugc nofollow" target="_blank">线性同余生成器</a> (2019)，唯帅·拉文德兰博客</p><p id="d033" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">[6] S. Pigeon，<a class="ae lb" href="http://hbfs.wordpress.com/2017/11/21/the-middle-square-method-generating-random-sequences-viii/" rel="noopener ugc nofollow" target="_blank">中平方方法(生成随机序列八)</a> (2017)，更难，更好，更快，更强</p></div></div>    
</body>
</html>