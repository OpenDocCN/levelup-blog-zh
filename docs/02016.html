<html>
<head>
<title>Probability Distributions Using SciPy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用SciPy的概率分布</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/probability-distributions-using-scipy-58fdab53d7ac?source=collection_archive---------7-----------------------#2020-02-12">https://levelup.gitconnected.com/probability-distributions-using-scipy-58fdab53d7ac?source=collection_archive---------7-----------------------#2020-02-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="0ca2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这篇文章中，我将向你展示如何使用<code class="fe kl km kn ko b">SciPy</code>来处理概率分布。我们将从导入相关的包开始。</p><pre class="kp kq kr ks gt kt ko ku kv aw kw bi"><span id="e61a" class="kx ky iq ko b gy kz la l lb lc">import scipy.stats as stats<br/>import numpy as np<br/>%matplotlib inline<br/>import matplotlib.pyplot as plt</span></pre><p id="de8e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe kl km kn ko b">sciPy</code>的<code class="fe kl km kn ko b">stats</code>模块提供了许多发行版，所以你一定会找到你想要的。它们分为三类:连续、离散和多元。这里是<a class="ae ld" href="https://docs.scipy.org/doc/scipy/reference/stats.html" rel="noopener ugc nofollow" target="_blank">完整列表</a>。在这篇博文中，我们将关注(两个)连续分布和(两个)离散分布。</p><h2 id="3bce" class="kx ky iq bd le lf lg dn lh li lj dp lk jy ll lm ln kc lo lp lq kg lr ls lt lu bi translated">连续分布</h2><p id="fb85" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">我们将从可能是最著名的分布开始:正态(高斯)分布。</p><p id="a5da" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们从创建一个<code class="fe kl km kn ko b">stats.norm</code>类的实例开始，将这个对象初始化为平均值100和标准偏差15:</p><p id="b3d0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe kl km kn ko b">normal=stats.norm(loc=100, scale=15)</code></p><p id="85c1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们可以通过在这个对象上调用方法<code class="fe kl km kn ko b">.rvs(size=10)</code>来生成10个随机数，从而生成一个随机样本。</p><pre class="kp kq kr ks gt kt ko ku kv aw kw bi"><span id="af56" class="kx ky iq ko b gy kz la l lb lc">normal.rvs(size=10,random_state=143)<br/>&gt;&gt; <!-- -->array([ 87.50268488, 118.56536514,  62.86403442,  84.42053641,<br/>       114.91967271, 102.67337385,  92.6638058 ,  93.36867073,<br/>        96.22587266,  92.97029531])</span></pre><p id="0011" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe kl km kn ko b">random_state=143</code>只是为了使结果具有可重复性。如果包括这个，这个结果永远是一样的。如果您想重复并得到不同的结果，只需省略它，这样您的代码就会显示为<code class="fe kl km kn ko b">normal.rvs(size=10)</code>。</p><p id="62a8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那很容易！现在从这个分布中产生1000个随机数，并制作一个直方图。</p><pre class="kp kq kr ks gt kt ko ku kv aw kw bi"><span id="fc24" class="kx ky iq ko b gy kz la l lb lc">normal_sample = normal.rvs(size=1000,random_state=123)<br/>plt.hist(normal_sample,density=True,label="Sample")<br/>plt.title("Normal Distribution")<br/>plt.ylabel("Density")<br/>plt.legend()<br/>plt.show()</span></pre><p id="f24f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是结果。</p><figure class="kp kq kr ks gt mb gh gi paragraph-image"><div class="gh gi ma"><img src="../Images/5fdcae94c3b0af9e0827f395946d4a73.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*A6SPXvyfXElqvHU81uYz6Q.png"/></div><figcaption class="me mf gj gh gi mg mh bd b be z dk translated">从正态分布生成1000个随机数的直方图。</figcaption></figure><p id="5a36" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们把注意力放在概率密度函数上。使用我们创建的同一个(分布)对象，我们可以通过方法<code class="fe kl km kn ko b">.pdf</code>访问PDF。第一个参数可以是值数组的标量。</p><pre class="kp kq kr ks gt kt ko ku kv aw kw bi"><span id="b257" class="kx ky iq ko b gy kz la l lb lc">print(normal.pdf(120))<br/>print(normal.pdf([120,130,140]))<br/>&gt;&gt; 0.010934004978399577<br/>&gt;&gt; [0.010934   0.0035994  0.00075973]</span></pre><p id="a8ac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，让我们看看如何绘制PDF。首先为水平轴创建一些值。我们将使用<code class="fe kl km kn ko b">np.linspace(start,stop,num)</code>在<code class="fe kl km kn ko b">start</code>和<code class="fe kl km kn ko b">end</code>之间生成等间距的<code class="fe kl km kn ko b">num </code>数字。我们案例的相关值似乎在50到150之间:<code class="fe kl km kn ko b">t.np.linspace(50,150,100)</code>。这些将作为绘图的水平(x)值。</p><p id="7a02" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了获得垂直(y)值，我们可以计算这些值的PDF:<code class="fe kl km kn ko b">normal.pdf(t)</code>。下面我们有代码把所有这些放在一起，给我们一个正常的PDF绘图。</p><pre class="kp kq kr ks gt kt ko ku kv aw kw bi"><span id="85d3" class="kx ky iq ko b gy kz la l lb lc">t = np.linspace(50,150,100)<br/>plt.plot(t,normal.pdf(t),label="PDF")<br/>plt.legend()<br/>plt.show()</span></pre><figure class="kp kq kr ks gt mb gh gi paragraph-image"><div class="gh gi ma"><img src="../Images/216804812e244e366a181412cfe2c20e.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*TlmOzs9lOmZbTfJ93fvwvA.png"/></div><figcaption class="me mf gj gh gi mg mh bd b be z dk translated">正常PDF的绘图</figcaption></figure><p id="d4c3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我们可以将它覆盖在直方图的顶部，看看随机数生成器做得有多好！</p><figure class="kp kq kr ks gt mb gh gi paragraph-image"><div class="gh gi ma"><img src="../Images/49877d95570d96189a0961f5fc72d5f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*YnH42aVnUIYOPgjhqYOJWg.png"/></div><figcaption class="me mf gj gh gi mg mh bd b be z dk translated">正态分布样本的直方图和相应的PDF图</figcaption></figure><p id="069b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">看起来不错！</p><p id="5d04" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另一个流行的发行版是Beta发行版。这也是一个连续分布，用于模拟0到1之间的随机变量。例如，如果随机变量是成功的概率，那么这可能是一个很好的分布。beta分布有两个参数，a和b。因此，为了在<code class="fe kl km kn ko b">scipy</code>中创建一个Beta分布对象，我们把<code class="fe kl km kn ko b">beta=stats.beta(a=2,b=5)</code>。下面的代码从这个分布中生成一个随机样本。</p><pre class="kp kq kr ks gt kt ko ku kv aw kw bi"><span id="af34" class="kx ky iq ko b gy kz la l lb lc">beta=stats.beta(a=2,b=5)<br/>beta.rvs(size=5,random_state=133)<br/>&gt;&gt;array([0.13580999, 0.55628319, 0.39061464, 0.51549706, 0.3439727 ])</span></pre><p id="9639" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">像以前一样，让我们从这个分布中得到1000个数字，制作一个直方图并覆盖它的PDF。</p><pre class="kp kq kr ks gt kt ko ku kv aw kw bi"><span id="ebdc" class="kx ky iq ko b gy kz la l lb lc">beta_sample=beta.rvs(size=1000,random_state=133)<br/>t=np.linspace(0,1,100)<br/>plt.hist(beta_sample,density=True,label="Sample")<br/>plt.plot(t,beta.pdf(t),label="PDF")<br/>plt.legend()<br/>plt.ylabel("Density")<br/>plt.title("Beta Distribution")<br/>plt.savefig("beta_hist_pdf.png")<br/>plt.show()</span></pre><figure class="kp kq kr ks gt mb gh gi paragraph-image"><div class="gh gi ma"><img src="../Images/cc98aadf2ffb05f4fcb825dec622f9ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*Mv_7K7ZuHAEfEDqfOfjikw.png"/></div><figcaption class="me mf gj gh gi mg mh bd b be z dk translated">贝塔分布的样本直方图和相应的PDF图</figcaption></figure><h2 id="f82c" class="kx ky iq bd le lf lg dn lh li lj dp lk jy ll lm ln kc lo lp lq kg lr ls lt lu bi translated">离散分布</h2><p id="20f6" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">有时，我们需要处理离散分布。我们将演示两个:二项式和泊松。二项式分布用于模拟重复试验的成功次数，其中每次试验可能导致“成功”或“失败”，每次试验的成功概率保持不变，试验相互独立，最终试验次数预先固定。一个典型的例子是投掷固定次数的硬币。下面是我们如何在<code class="fe kl km kn ko b">scipy</code>中得到二项式分布对象并生成一些随机数:</p><pre class="kp kq kr ks gt kt ko ku kv aw kw bi"><span id="67b6" class="kx ky iq ko b gy kz la l lb lc">binomial=stats.binom(n=10,p=0.4)<br/>binomial.rvs(size=10,random_state=143)<br/>&gt;&gt; array([5, 3, 4, 4, 4, 6, 1, 1, 3, 2])</span></pre><p id="ece0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请记住，离散分布没有PDF。相应的函数是概率质量函数或PMF。在<code class="fe kl km kn ko b">scipy</code>中，我们可以如下访问分配对象的该功能:<code class="fe kl km kn ko b">binomial.pmf</code>。就像PDF一样，我们可以计算单个数字或一系列数字的PMF。</p><pre class="kp kq kr ks gt kt ko ku kv aw kw bi"><span id="aa2f" class="kx ky iq ko b gy kz la l lb lc">binomial.pmf(2)<br/>binomial.pmf([2,3,4])<br/>&gt;&gt;&gt; 0.12093235199999994<br/>&gt;&gt;&gt; [0.12093235 0.21499085 0.25082266]</span></pre><p id="4a82" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，让我们绘制PMF。既然是离散的，我们就用<code class="fe kl km kn ko b">plt.scatter</code>代替<code class="fe kl km kn ko b">plt.plot</code>。此外，PMF是零，除非这个分布恰好是0，1，2，…，10。我们将使用<code class="fe kl km kn ko b">np.arange(start,stop,step=1)</code>生成离散集合的值，而不是使用<code class="fe kl km kn ko b">np.linspace</code>从连续范围生成数字。对我们来说，这将是</p><pre class="kp kq kr ks gt kt ko ku kv aw kw bi"><span id="5e89" class="kx ky iq ko b gy kz la l lb lc">t=np.arange(0,11)<br/>t<br/>&gt;&gt; array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10])</span></pre><p id="4a45" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意，我们必须用<code class="fe kl km kn ko b">np.arange(0,11)</code>代替<code class="fe kl km kn ko b">np.arange(0,10)</code>，因为它不返回最后一个数字。现在，利用这些值，我们可以画出二项式分布的PMF。</p><pre class="kp kq kr ks gt kt ko ku kv aw kw bi"><span id="284a" class="kx ky iq ko b gy kz la l lb lc">plt.scatter(t,binomial.pmf(t),label="PMF",color="Orange")<br/>plt.title("Binomial Distribution")<br/>plt.ylabel("Density")<br/>plt.legend()<br/>plt.xticks(t)<br/>plt.show()</span></pre><figure class="kp kq kr ks gt mb gh gi paragraph-image"><div class="gh gi ma"><img src="../Images/12ba86479d46d8ad7aadc469fe8c237f.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*AJDYPUFLPhdnpwYvxXsXqw.png"/></div><figcaption class="me mf gj gh gi mg mh bd b be z dk translated">二项分布的PMF图。</figcaption></figure><p id="aceb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们将从这个分布<code class="fe kl km kn ko b">binomial_sample=binomial.rvs(size=1000,random_state=143)</code>中生成1000个随机数，并创建一个直方图。由于我们处理的是离散数字，我们必须添加一些选项来控制直方图的计算方式:</p><ul class=""><li id="d797" class="mi mj iq jp b jq jr ju jv jy mk kc ml kg mm kk mn mo mp mq bi translated"><code class="fe kl km kn ko b">bins=11</code>确保我们有11个箱子，每个箱子对应一个数字0，1，…，10</li><li id="1644" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated"><code class="fe kl km kn ko b">range=(0,11)</code>确保各个类别为[0，1]，[1，2)，…，[10，11)</li><li id="71c2" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated"><code class="fe kl km kn ko b">align='left'</code>确保该条与PMF对齐(稍后当我们覆盖所有内容时，您会看到原因。</li><li id="8d55" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated"><code class="fe kl km kn ko b">rwidth=0.75</code>所以直方图的条是类宽度的75%。这将确保条形图不会相互接触，以表明我们正在处理离散数据。</li><li id="1252" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated"><code class="fe kl km kn ko b">alpha=0.75</code>这样条形是半透明的，使覆盖看起来很漂亮。</li></ul><p id="847f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是完整的代码。</p><pre class="kp kq kr ks gt kt ko ku kv aw kw bi"><span id="3454" class="kx ky iq ko b gy kz la l lb lc">binomial_sample=binomial.rvs(size=1000,random_state=143)<br/>plt.hist(binomial_sample,bins=11,range=(0,11),density=True,align='left',rwidth=0.75,label="Sample",alpha=0.75)<br/>plt.title("Binomial Distribution")<br/>plt.ylabel("Density")<br/>plt.legend()<br/>plt.xticks(t)<br/>plt.show()</span></pre><figure class="kp kq kr ks gt mb gh gi paragraph-image"><div class="gh gi ma"><img src="../Images/7c8b5bb57db96e4106631fdc3982050c.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*puZiRgZgoqqbc2Rc6QVuZw.png"/></div><figcaption class="me mf gj gh gi mg mh bd b be z dk translated">来自二项式分布的1000个随机数的直方图</figcaption></figure><p id="6b8a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，下面是将PMF和直方图放在一起的代码。</p><pre class="kp kq kr ks gt kt ko ku kv aw kw bi"><span id="aba9" class="kx ky iq ko b gy kz la l lb lc">binomial_sample=binomial.rvs(size=1000,random_state=143)<br/>t = np.arange(0,11)<br/>plt.hist(binomial_sample,bins=11,range=(0,11),density=True,align='left',rwidth=0.75,label="Sample",alpha=0.75)<br/>plt.scatter(t,binomial.pmf(t),label="PMF",color="Orange")<br/>plt.title("Binomial Distribution")<br/>plt.ylabel("Density")<br/>plt.legend()<br/>plt.xticks(t)<br/>plt.show()</span></pre><figure class="kp kq kr ks gt mb gh gi paragraph-image"><div class="gh gi ma"><img src="../Images/6fefa4d2e7d2cd794e52d8990732abe9.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*UQnU7hMztqQNADBOwE14pA.png"/></div><figcaption class="me mf gj gh gi mg mh bd b be z dk translated">来自二项式分布的随机样本的直方图和相关的PMF图</figcaption></figure><p id="5f40" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">泊松分布在实践中也非常常用。它用于模拟在固定持续时间(或空间)内发生的事件(如车祸)数量。这个随机变量可以取的值是0，1，2，…(它永远持续下去)。在<code class="fe kl km kn ko b">scipy</code>中，我们可以通过<code class="fe kl km kn ko b">stats.poisson(mu=2)</code>设置一个泊松分布对象。生成随机数就像其他分布一样:</p><pre class="kp kq kr ks gt kt ko ku kv aw kw bi"><span id="08cd" class="kx ky iq ko b gy kz la l lb lc">poisson.rvs(size=10,random_state=143)<br/>&gt;&gt; array([2, 3, 0, 1, 1, 0, 2, 2, 0, 1])</span></pre><p id="6e8b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">基于我们上面所做的一切，我们可以从这个分布中生成1000个随机数，绘制直方图，并将PMF一起绘制在同一个图上。在查看下面的代码之前，尝试自己完成这项工作。为了鼓励你，我先展示最终结果，然后是代码。</p><figure class="kp kq kr ks gt mb gh gi paragraph-image"><div class="gh gi ma"><img src="../Images/f31840cb95549a9edec70e0567a3640f.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*EzZVYV43iARfACHNdIPhRQ.png"/></div><figcaption class="me mf gj gh gi mg mh bd b be z dk translated">泊松分布中随机样本的直方图和相关的PMF图</figcaption></figure><pre class="kp kq kr ks gt kt ko ku kv aw kw bi"><span id="b311" class="kx ky iq ko b gy kz la l lb lc">poisson_sample = poisson.rvs(size=1000,random_state=143)<br/>end = np.max(poisson_sample)+1<br/>t=np.arange(0,end)<br/>plt.hist(poisson_sample, bins=end,range=(0,end), density=True,align='left', rwidth=0.75,label="Sample", alpha=0.75)<br/>plt.scatter(t,poisson.pmf(t),label="PMF",color="Orange")<br/>plt.title("Poisson Distribution")<br/>plt.ylabel("Density")<br/>plt.legend()<br/>plt.show()</span></pre><p id="a2d4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里一个棘手的部分是，由于泊松随机变量的支持是没有尽头的，我们必须决定在哪里停止计算。对我们来说，这将是我们样本数据的最大价值；因此，我们<code class="fe kl km kn ko b">end=np.max(poisson_sample)+1</code>。</p><p id="03d0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里有一个链接指向包含这篇文章所有代码的要点。</p><p id="b1b1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我希望你喜欢这篇文章！</p></div></div>    
</body>
</html>