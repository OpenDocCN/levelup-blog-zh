<html>
<head>
<title>Golang 1.18 — Generics explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Golang 1.18 —泛型解释</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/golang-1-18-generics-explained-bc0feaeb5f0e?source=collection_archive---------7-----------------------#2022-03-18">https://levelup.gitconnected.com/golang-1-18-generics-explained-bc0feaeb5f0e?source=collection_archive---------7-----------------------#2022-03-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/22ae99d4c4bb86b65b9926071565bc1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gzxpAUe7HcI1cnbA"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@timmossholder?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Tim Mossholder </a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="b7b1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">多年来，golang社区一直在等待仿制药。</p><p id="aada" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好消息。随着新的1.18更新，我们现在可以访问泛型了。所以让我们深入了解一下泛型到底是什么。</p><p id="981c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个例子的<strong class="kf ir">源代码</strong>可以在这篇博文的末尾找到。</p><h1 id="b72c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">什么是泛型？</h1><p id="700e" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><strong class="kf ir">泛型</strong>表示<strong class="kf ir">参数化类型。这个想法是允许整型、字符串等类型。成为方法的参数。它们确实有广泛的应用，但是它对于框架开发尤其重要，因为它利用了开发人员的工作。</strong></p><h1 id="3706" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">例子</h1><p id="a53c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">让我们想一个非常简单的特征。我们希望找到一组数字中的最大值。</p><p id="971f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果没有泛型，我们会这样做:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="7e3e" class="mn lc iq mj b gy mo mp l mq mr">func Max(array []int) int { }<br/>func Max(array []float64) float64 { }</span></pre><p id="5569" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们必须为每种类型声明一个函数。这是不好的，因为这会导致重复的代码，并且耗费时间。</p><p id="e87a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们有了期待已久的新泛型特性，我们可以这样做:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="3fb6" class="mn lc iq mj b gy mo mp l mq mr">type Number interface {<br/>	int | float64<br/>}</span><span id="03c0" class="mn lc iq mj b gy ms mp l mq mr">func Max[T Number](array []T) T { }</span></pre><p id="19c6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们需要定义一个名为<code class="fe mt mu mv mj b">Number</code>的新类型，以声明泛型可以拥有的所有可用类型。在我们的例子中，我们声明我们的泛型是一个<code class="fe mt mu mv mj b">int</code>或者一个<code class="fe mt mu mv mj b">float</code>类型。</p><p id="a3af" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们可以使用我们的<code class="fe mt mu mv mj b">Number</code>类型定义一个新的函数，就像这个<code class="fe mt mu mv mj b">func Max [T Number](..)</code>。我们告诉编译器，我们希望我们的泛型类型<code class="fe mt mu mv mj b">T</code>成为<code class="fe mt mu mv mj b">Number</code>的类型。</p><p id="ab1c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦我们完成了这些，我们就可以在函数中重用通用参数<code class="fe mt mu mv mj b">T</code>来定义输入和输出，就像这个<code class="fe mt mu mv mj b">func ..(array []T) T</code>。</p><p id="02b9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们现在已经完成了函数签名的定义。现在让我们添加我们的业务逻辑。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="8385" class="mn lc iq mj b gy mo mp l mq mr">func Max[T Number](array []T) T {<br/>	var result T = 0<br/>	for key, _ := range array {<br/>		if array[key] &gt; result {<br/>			result = array[key]<br/>		}<br/>	}<br/>	return result<br/>}</span></pre><p id="a11a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如您所见，我们还可以在函数中重用泛型类型<code class="fe mt mu mv mj b">T</code>，以存储结果值<code class="fe mt mu mv mj b">var result T</code>。</p><p id="7bfa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">代码本身在泛型数组中循环，如果结果变量中的数字高于当前存储的值，就将它存储在结果变量中。一旦我们循环了所有的值，我们只是返回最高的存储值。</p><p id="ea69" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后但同样重要的是，我们只需要调用我们的函数</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="2278" class="mn lc iq mj b gy mo mp l mq mr">func main() {<br/>	intValues := []int{2, 3, 15, 27, 11, 13}<br/>	fmt.Println("Int values max: ", Max(intValues))</span><span id="6d35" class="mn lc iq mj b gy ms mp l mq mr">	floatValues := []float64{2.1, 3.2, 15.4, 27.9, 11.1, 13.2}<br/>	fmt.Println("Float values max: ", Max(floatValues))<br/>}</span></pre><p id="6d29" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当你查看main时，你可以看到我们现在有能力调用不同类型的<code class="fe mt mu mv mj b">Max</code>函数。在我们的例子中是一个由<code class="fe mt mu mv mj b">int</code>和<code class="fe mt mu mv mj b">float64</code>组成的数组。</p><p id="94f8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们看看运行应用程序后的输出:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="21e8" class="mn lc iq mj b gy mo mp l mq mr">➜  generics go run .</span><span id="72d5" class="mn lc iq mj b gy ms mp l mq mr">Int values max:  27<br/>Float values max:  27.9</span></pre><h1 id="3005" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">概述</h1><p id="9bbe" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">golang社区已经等待这个通用特性很久了。随着1.18的更新，我们终于可以使用泛型了。这对于框架开发尤其有用。</p><p id="7cd8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写了一个简单的函数，它返回一个普通数组中的最大值。</p><p id="ddcc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">源代码</strong>可以在<a class="ae kc" href="https://github.com/jakob-fiegerl/golang-generics" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="8358" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">详细的博文也可以在golang官方页面找到:<a class="ae kc" href="https://go.dev/doc/tutorial/generics" rel="noopener ugc nofollow" target="_blank">https://go.dev/doc/tutorial/generics</a></p></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><h1 id="668e" class="lb lc iq bd ld le nd lg lh li ne lk ll lm nf lo lp lq ng ls lt lu nh lw lx ly bi translated">喜欢这篇文章？</h1><p id="0f2d" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">请务必在<strong class="kf ir"> <em class="ni">媒体</em> </strong>和我的社交媒体上关注我。</p><p id="7fea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">➕ <strong class="kf ir">推特</strong> : <a class="ae kc" href="https://twitter.com/thejakeio" rel="noopener ugc nofollow" target="_blank"> thejakeio </a></p></div></div>    
</body>
</html>