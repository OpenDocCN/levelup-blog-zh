<html>
<head>
<title>Writing Space Invaders with Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Go编写太空入侵者</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/writing-space-invaders-with-go-db22111cce48?source=collection_archive---------0-----------------------#2018-01-31">https://levelup.gitconnected.com/writing-space-invaders-with-go-db22111cce48?source=collection_archive---------0-----------------------#2018-01-31</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="32ae" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">如何在Go中写一个基于终端的太空入侵者游戏</h2></div><p id="57d1" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">我对街机电子游戏最早的记忆是看我的哥哥和堂兄弟在云顶高地玩电子游戏机。当我们的父母在玩云顶高地更广为人知的其他游戏时，我们通常可以尽情地玩街机游戏。</p><figure class="lg lh li lj gu lk gi gj paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gi gj lf"><img src="../Images/bbca752e801ff5734288321b4a73910b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CmUjek1DPmIhRQVFYpr53A.jpeg"/></div></div><figcaption class="lr ls gk gi gj lt lu bd b be z dk translated">云顶高地酒店(照片由维基共享资源上的<a class="ae lv" href="https://commons.wikimedia.org/wiki/File:Genting_Grand_Hotel.jpg" rel="noopener ugc nofollow" target="_blank"> Chongkian </a>拍摄)</figcaption></figure><p id="08d4" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">那是吃豆人、太空入侵者、加拉西安、大金刚、青蛙过河、蜈蚣等等的神奇时代。几天来闪烁的灯光，激烈的音乐，疯狂地拽着操纵杆，疯狂地敲击按钮，然后是最后一条生命逝去时沮丧的呻吟。</p><p id="9d27" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">正如许多有抱负的程序员一样，我的一个秘密梦想就是重现那种魔力，编写下一个大游戏。和许多优秀的程序员一样，我悲惨地失败了许多次。尽管最终我成功地编写了一些简单的游戏，但我开始意识到即使看似简单的游戏实际上也不容易编写。</p><p id="4fcb" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">当然，这并没有阻止我再次尝试。这一次，我尝试了街机电子游戏中的老女人——太空入侵者<em class="lw"/>。</p><h1 id="1bf8" class="lx ly iu bd lz ma mb mc md me mf mg mh ka mi kb mj kd mk ke ml kg mm kh mn mo bi translated">太空入侵者</h1><p id="3e5c" class="pw-post-body-paragraph kj kk iu kl b km mp jv ko kp mq jy kr ks mr ku kv kw ms ky kz la mt lc ld le in bi translated"><a class="ae lv" href="https://en.wikipedia.org/wiki/Space_Invaders" rel="noopener ugc nofollow" target="_blank">太空入侵者</a>是街机游戏黄金时代<a class="ae lv" href="https://en.wikipedia.org/wiki/Golden_age_of_arcade_video_games" rel="noopener ugc nofollow" target="_blank">最成功的街机游戏之一。它于1978年首次发行，被普遍认为是黄金时代的开始，从70年代末持续到90年代初。甚至在街机电子游戏衰落之后，它也干脆超越了媒介，转移到了电子游戏机上。</a></p><figure class="lg lh li lj gu lk gi gj paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gi gj mu"><img src="../Images/272301e4d4955ec0b20f2cd31e04e57b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KuSVbi__D6WkZAymr3O4sw.jpeg"/></div></div><figcaption class="lr ls gk gi gj lt lu bd b be z dk translated">《太空入侵者》街机柜(照片由维基共享资源上的科恩特拍摄)</figcaption></figure><p id="0365" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">如果你还不熟悉的话，这个游戏的前提非常简单。作为玩家，你控制激光炮与一排排外星入侵者战斗。激光炮只能在屏幕底部水平移动，因为外星人来回移动，并慢慢向你下降。外星人试图通过向你投掷鱼雷来摧毁你，而你被一些固定的防御掩体部分保护。如果外星人到达加农炮或者你所有的加农炮都被摧毁，游戏结束。</p><p id="bd22" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">就像我说的，简单。</p><h1 id="1f69" class="lx ly iu bd lz ma mb mc md me mf mg mh ka mi kb mj kd mk ke ml kg mm kh mn mo bi translated">无发动机的</h1><p id="cc18" class="pw-post-body-paragraph kj kk iu kl b km mp jv ko kp mq jy kr ks mr ku kv kw ms ky kz la mt lc ld le in bi translated">大多数游戏开发使用某种游戏引擎或者至少是图形引擎，但是我写的游戏两者都没有使用。相反，我试图做的是通过创建单独的帧并快速地一个接一个地显示它们来构建一个游戏。本质上，这是我之前写的<a class="ae lv" href="https://sausheong.github.io/posts/flocking-with-go/" rel="noopener ugc nofollow" target="_blank">群集模拟</a>的变体。</p><p id="b847" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">这个想法非常简单——不久前，我偶然发现iTerm2中的一个<a class="ae lv" href="https://www.iterm2.com/documentation-images.html" rel="noopener ugc nofollow" target="_blank">黑客</a>,它允许我在屏幕上显示图像，并引导我一个接一个地显示大量图像，从而产生一个动画。</p><p id="09f7" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">如果你仔细想想，这就是像《太空入侵者》这样的简单游戏的全部——一个可以由用户控制的动画。</p><p id="7a09" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">让我们看看代码。</p><h1 id="4190" class="lx ly iu bd lz ma mb mc md me mf mg mh ka mi kb mj kd mk ke ml kg mm kh mn mo bi translated">精灵</h1><p id="098c" class="pw-post-body-paragraph kj kk iu kl b km mp jv ko kp mq jy kr ks mr ku kv kw ms ky kz la mt lc ld le in bi translated">在计算机图形学中，精灵是添加到背景上的独立对象。不出所料，精灵首先被用于街机视频游戏，通常由硬件生成。在我们的例子中，我们使用了一个简单但流行的技术，使用一个单独的sprite sheet，并将sprite sheet的各个部分作为一个单独的sprite。</p><figure class="lg lh li lj gu lk gi gj paragraph-image"><div class="gi gj mv"><img src="../Images/785dbd9b715e9951d4c32530b614db81.png" data-original-src="https://miro.medium.com/v2/resize:fit:500/format:webp/0*_dKZ-9MftFGI55xD.png"/></div><figcaption class="lr ls gk gi gj lt lu bd b be z dk translated">游戏精灵</figcaption></figure><p id="7bcc" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">上图是<code class="fe mw mx my mz b">sprites.png</code>精灵表文件的放大版本。</p><pre class="lg lh li lj gu na mz nb nc aw nd bi"><span id="aeaf" class="ne ly iu mz b gz nf ng l nh ni">// sprites<br/>var src = getImage("imgs/sprites.png")<br/>var background = getImage("imgs/bg.png")<br/>var cannonSprite = image.Rect(20, 47, 38, 59)<br/>var cannonExplode = image.Rect(0, 47, 16, 57)<br/>var alien1Sprite = image.Rect(0, 0, 20, 14)<br/>var alien1aSprite = image.Rect(20, 0, 40, 14)<br/>var alien2Sprite = image.Rect(0, 14, 20, 26)<br/>var alien2aSprite = image.Rect(20, 14, 40, 26)<br/>var alien3Sprite = image.Rect(0, 27, 20, 40)<br/>var alien3aSprite = image.Rect(20, 27, 40, 40)<br/>var alienExplode = image.Rect(0, 60, 16, 68)<br/>var beamSprite = image.Rect(20, 60, 22, 65)<br/>var bombSprite = image.Rect(0, 70, 10, 79)</span></pre><p id="9544" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">每个精灵由<code class="fe mw mx my mz b">sprites.png</code>文件中相应精灵图像的<code class="fe mw mx my mz b">image.Rectangle</code>位置表示。例如，<code class="fe mw mx my mz b">alien1Sprite</code>显示一个矩形，其左上角位置为<code class="fe mw mx my mz b">(0,0)</code>，右下角位置为<code class="fe mw mx my mz b">(20,14)</code>。</p><figure class="lg lh li lj gu lk gi gj paragraph-image"><div class="gi gj mv"><img src="../Images/190d1cfdb5e146b2a4caad5ee110ffaa.png" data-original-src="https://miro.medium.com/v2/resize:fit:500/format:webp/0*E3U2cMX5SpZjOmnl.png"/></div></figure><p id="b5f0" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">一会儿我们会看到它是如何被使用的。</p><p id="ab46" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">我们还看到加载了两个图像文件<code class="fe mw mx my mz b">sprites.png</code>和<code class="fe mw mx my mz b">bg.png</code>。这个函数只是从一个图像文件中获取一个<code class="fe mw mx my mz b">image.Image</code>。</p><pre class="lg lh li lj gu na mz nb nc aw nd bi"><span id="1455" class="ne ly iu mz b gz nf ng l nh ni">func getImage(filePath string) image.Image {<br/>	imgFile, err := os.Open(filePath)<br/>	defer imgFile.Close()<br/>	if err != nil {<br/>		fmt.Println("Cannot read file:", err)<br/>	}<br/>	img, _, err := image.Decode(imgFile)<br/>	if err != nil {<br/>		fmt.Println("Cannot decode file:", err)<br/>	}<br/>	return img<br/>}</span></pre><p id="bfee" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">现在我们有了精灵的位置，让我们看看<code class="fe mw mx my mz b">Sprite</code>结构本身。</p><pre class="lg lh li lj gu na mz nb nc aw nd bi"><span id="c701" class="ne ly iu mz b gz nf ng l nh ni">// Sprite represents a sprite in the game<br/>type Sprite struct {<br/>	size     image.Rectangle // the sprite size<br/>	Filter   *gift.GIFT      // normal filter used to draw the sprite<br/>	FilterA  *gift.GIFT      // alternate filter used to draw the sprite<br/>	FilterE  *gift.GIFT      // exploded filter used to draw the sprite<br/>	Position image.Point     // top left position of the sprite<br/>	Status   bool            // alive or dead<br/>	Points   int             // number of points if destroyed<br/>}</span></pre><p id="9467" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">精灵由以下各项表示:</p><ol class=""><li id="05e5" class="nj nk iu kl b km kn kp kq ks nl kw nm la nn le no np nq nr bi translated">精灵的大小，也就是我们之前定义的矩形</li><li id="0d20" class="nj nk iu kl b km ns kp nt ks nu kw nv la nw le no np nq nr bi translated">3个图像过滤器，我们稍后将使用它们来绘制精灵</li><li id="8407" class="nj nk iu kl b km ns kp nt ks nu kw nv la nw le no np nq nr bi translated">要在背景上绘制的精灵的位置</li><li id="8e1c" class="nj nk iu kl b km ns kp nt ks nu kw nv la nw le no np nq nr bi translated">子画面状态的表示，以及</li><li id="8f07" class="nj nk iu kl b km ns kp nt ks nu kw nv la nw le no np nq nr bi translated">精灵被摧毁的点数(这只适用于外星人)。</li></ol><p id="cf35" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">我们使用的图像过滤器来自优秀的<a class="ae lv" href="https://github.com/disintegration/gift" rel="noopener ugc nofollow" target="_blank"> Go图像过滤工具包(GIFT) </a>。我们没有充分利用这个库，因为我们只用它来绘制背景上的精灵。每个精灵有3个过滤器，一个用于绘制正常精灵的正常过滤器，一个用于绘制精灵的替代形式的替代过滤器(目前为止只适用于外星人)和一个爆炸过滤器，当精灵爆炸(或死亡)时绘制精灵。我们使用精灵的另一种形式来制作精灵动画。</p><p id="8d74" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">我们来看看游戏中不同精灵的定义。</p><pre class="lg lh li lj gu na mz nb nc aw nd bi"><span id="7d95" class="ne ly iu mz b gz nf ng l nh ni">var aliens = []Sprite{}</span><span id="4426" class="ne ly iu mz b gz nx ng l nh ni">// sprite for laser cannon<br/>var laserCannon = Sprite{<br/>	size:     cannonSprite,<br/>	Filter:   gift.New(gift.Crop(cannonSprite)),<br/>	Position: image.Pt(50, 250),<br/>	Status:   true,<br/>}</span><span id="baef" class="ne ly iu mz b gz nx ng l nh ni">// sprite for the laser beam<br/>var beam = Sprite{<br/>	size:     beamSprite,<br/>	Filter:   gift.New(gift.Crop(beamSprite)),<br/>	Position: image.Pt(laserCannon.Position.X+7, 250),<br/>	Status:   false,<br/>}</span></pre><p id="e987" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">这是《太空入侵者》的简化版，所以我们只有4种精灵——外星人、外星人投掷的炸弹、激光炮和从大炮中射出的激光束。变量<code class="fe mw mx my mz b">aliens</code>是外星人精灵的数组，<code class="fe mw mx my mz b">bombs</code>是投掷的炸弹数组，<code class="fe mw mx my mz b">laserCannon</code>是激光炮精灵，<code class="fe mw mx my mz b">beam</code>是激光束精灵。从代码中可以看出，过滤器根据前面定义的矩形裁剪sprite工作表的一部分。</p><p id="fa17" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">我们还没有在这里创建外星人，但是过一会儿我们会用到一个函数:</p><pre class="lg lh li lj gu na mz nb nc aw nd bi"><span id="4a43" class="ne ly iu mz b gz nf ng l nh ni">// used for creating alien sprites<br/>func createAlien(x, y int, sprite, alt image.Rectangle, points int) (s Sprite) {<br/>	s = Sprite{<br/>		size:     sprite,<br/>		Filter:   gift.New(gift.Crop(sprite)),<br/>		FilterA:  gift.New(gift.Crop(alt)),<br/>		FilterE:  gift.New(gift.Crop(alienExplode)),<br/>		Position: image.Pt(x, y),<br/>		Status:   true,<br/>		Points:   points,<br/>	}<br/>	return<br/>}</span></pre><p id="e175" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">我们将把矩形传递给函数来创建正确的外星人精灵和它的替代形式(用于动画精灵)，但是所有的外星人都以同样的方式爆炸。炸弹是在游戏循环中产生的，我们稍后会看到。</p><p id="d8df" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">精灵们说了这么多，让我们看看游戏的<code class="fe mw mx my mz b">main</code>功能。</p><h1 id="22b7" class="lx ly iu bd lz ma mb mc md me mf mg mh ka mi kb mj kd mk ke ml kg mm kh mn mo bi translated">行动开始了</h1><p id="4927" class="pw-post-body-paragraph kj kk iu kl b km mp jv ko kp mq jy kr ks mr ku kv kw ms ky kz la mt lc ld le in bi translated">这是一个从终端开始的游戏，整个游戏在终端上是动画的。所以，控制终端很重要。我使用流行的<a class="ae lv" href="https://github.com/nsf/termbox-go" rel="noopener ugc nofollow" target="_blank"> termbox-go </a>库来给我这种控制。Termbox和GIFT library一样，可能有点矫枉过正，因为它是一个比这里所需要的更强大的库。</p><pre class="lg lh li lj gu na mz nb nc aw nd bi"><span id="a922" class="ne ly iu mz b gz nf ng l nh ni">err := termbox.Init()<br/>if err != nil {<br/>	panic(err)<br/>}</span></pre><p id="3047" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">我通过初始化termbox-go来启动主函数。这个游戏实际上有两个独立的循环:</p><ul class=""><li id="04b8" class="nj nk iu kl b km kn kp kq ks nl kw nm la nn le ny np nq nr bi translated">第一个是用户对激光炮的控制，这是通过键盘上的输入(左右箭头)</li><li id="8c0f" class="nj nk iu kl b km ns kp nt ks nu kw nv la nw le ny np nq nr bi translated">第二个是游戏的其余部分，在所谓的游戏循环中，稍后解释。无论用户做什么，它都会运行。它包括外星人的持续运动，因为他们下降，同时投掷炸弹摧毁地球上的所有生命，以及激光束的向上运动，因为它冲向外星人，把他们炸得粉碎。</li></ul><p id="be73" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">这意味着有两个并发运行的线程，在本例中是goroutines。</p><pre class="lg lh li lj gu na mz nb nc aw nd bi"><span id="2347" class="ne ly iu mz b gz nf ng l nh ni">// poll for keyboard events in another goroutine<br/>events := make(chan termbox.Event, 1000)<br/>go func() {<br/>	for {<br/>		events &lt;- termbox.PollEvent()<br/>	}<br/>}()</span></pre><p id="d0ff" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">我们启动一个单独的goroutine来轮询事件，并将它们填充到一个缓冲通道中。我们在这里使用了一个非常大的缓冲区，它真的可以更小，但是缓冲区越大，事件捕获就越平滑，所以我并没有试图找出最佳的大小。</p><p id="a2e5" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">大多数游戏都有一个开始屏幕，在那里你被要求投入硬币，然后按下按钮开始游戏。我们也有一个。</p><pre class="lg lh li lj gu na mz nb nc aw nd bi"><span id="e274" class="ne ly iu mz b gz nf ng l nh ni">// show the start screen<br/>	startScreen := getImage("imgs/start.png")<br/>	printImage(startScreen)<br/>start:<br/>	for {<br/>		switch ev := termbox.PollEvent(); ev.Type {<br/>		case termbox.EventKey:<br/>			if ev.Ch == 's' || ev.Ch == 'S' {<br/>				break start<br/>			}<br/>			if ev.Ch == 'q' {<br/>				gameOver = true<br/>				break start<br/>			}<br/>		}<br/>	}</span></pre><p id="877a" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">我们再次轮询键盘，我们等待有人按下<code class="fe mw mx my mz b">s</code>或<code class="fe mw mx my mz b">S</code>开始游戏，或<code class="fe mw mx my mz b">q</code>退出游戏。</p><p id="6641" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">接下来，我们填充<code class="fe mw mx my mz b">aliens</code>数组。这很简单，我们只需要三排不同的外星人。</p><pre class="lg lh li lj gu na mz nb nc aw nd bi"><span id="fe3b" class="ne ly iu mz b gz nf ng l nh ni">// populate the aliens<br/>for i := aliensStartCol; i &lt; aliensStartCol+(alienSize*aliensPerRow); i += alienSize {<br/>	aliens = append(aliens, createAlien(i, 30, alien1Sprite, alien1aSprite, 30))<br/>}<br/>for i := aliensStartCol; i &lt; aliensStartCol+(30*aliensPerRow); i += alienSize {<br/>	aliens = append(aliens, createAlien(i, 55, alien2Sprite, alien2aSprite, 20))<br/>}<br/>for i := aliensStartCol; i &lt; aliensStartCol+(30*aliensPerRow); i += alienSize {<br/>	aliens = append(aliens, createAlien(i, 80, alien3Sprite, alien3aSprite, 10))<br/>}</span></pre><h1 id="3095" class="lx ly iu bd lz ma mb mc md me mf mg mh ka mi kb mj kd mk ke ml kg mm kh mn mo bi translated">游戏循环</h1><p id="ec38" class="pw-post-body-paragraph kj kk iu kl b km mp jv ko kp mq jy kr ks mr ku kv kw ms ky kz la mt lc ld le in bi translated">现在我们已经奠定了基础，让我们进入主要的游戏循环。大多数游戏运行在一个通常被称为<a class="ae lv" href="http://gameprogrammingpatterns.com/game-loop.html" rel="noopener ugc nofollow" target="_blank">的游戏循环</a>中。游戏循环是一种游戏软件开发模式，通常是游戏的核心。这是一个无限循环，通过更新和重绘来使游戏充满活力。在我们的太空入侵者游戏循环中，我们使用一个名为<code class="fe mw mx my mz b">gameOver</code>的变量来表示循环应该持续到游戏结束(要么由玩家触发，要么当外星人获胜)。</p><p id="3e4e" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">游戏循环相当长，所以我们将把它分成几个部分。让我们看第一部分，它用于从播放器中捕获键盘事件。</p><pre class="lg lh li lj gu na mz nb nc aw nd bi"><span id="600f" class="ne ly iu mz b gz nf ng l nh ni">// if any of the keyboard events are captured<br/>select {<br/>case ev := &lt;-events:<br/>	if ev.Type == termbox.EventKey {<br/>		if ev.Key == termbox.KeyCtrlQ {<br/>			gameOver = true<br/>		}<br/>		if ev.Key == termbox.KeySpace {<br/>			if beam.Status == false {<br/>				beamShot = true<br/>			}<br/>		}<br/>		if ev.Key == termbox.KeyArrowRight {<br/>			laserCannon.Position.X += 10<br/>		}<br/>		if ev.Key == termbox.KeyArrowLeft {<br/>			laserCannon.Position.X -= 10<br/>		}<br/>	}</span><span id="4b49" class="ne ly iu mz b gz nx ng l nh ni">default:</span><span id="5e1a" class="ne ly iu mz b gz nx ng l nh ni">}</span></pre><p id="f05e" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">每当<code class="fe mw mx my mz b">events</code>缓冲通道有东西时，它将被接收到<code class="fe mw mx my mz b">ev</code>变量中，我们试图确定它是哪种类型的事件。按下<code class="fe mw mx my mz b">Ctrl-Q</code>结束游戏，同时按下空格键发射激光束。按下向左或向右箭头按钮，相应地向左或向右移动激光炮。</p><p id="3aec" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">您可能会注意到，我们必须在select中有一个默认值。这是因为如果我们没有默认值，select将会阻塞，只有当用户按下一个键时循环才能继续！</p><p id="df05" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">接下来，我们将绘制激光炮和外星精灵。我们从一个空的图像开始，并在上面绘制背景。</p><pre class="lg lh li lj gu na mz nb nc aw nd bi"><span id="2380" class="ne ly iu mz b gz nf ng l nh ni">// create background<br/>dst := image.NewRGBA(image.Rect(0, 0, windowWidth, windowHeight))<br/>gift.New().Draw(dst, background)</span></pre><h1 id="fcdd" class="lx ly iu bd lz ma mb mc md me mf mg mh ka mi kb mj kd mk ke ml kg mm kh mn mo bi translated">外星人来了！</h1><p id="496b" class="pw-post-body-paragraph kj kk iu kl b km mp jv ko kp mq jy kr ks mr ku kv kw ms ky kz la mt lc ld le in bi translated">我们先从外星人开始。</p><pre class="lg lh li lj gu na mz nb nc aw nd bi"><span id="2adc" class="ne ly iu mz b gz nf ng l nh ni">// process aliens<br/>for i := 0; i &lt; len(aliens); i++ {<br/>	aliens[i].Position.X = aliens[i].Position.X + 5*alienDirection<br/>	if aliens[i].Status {<br/>		// if alien is hit by a laser beam<br/>		if collide(aliens[i], beam) {<br/>			// draw the explosion<br/>			aliens[i].FilterE.DrawAt(dst, src, image.Pt(aliens[i].Position.X, aliens[i].Position.Y), gift.OverOperator)<br/>			// alien dies, player scores points<br/>			aliens[i].Status = false<br/>			score += aliens[i].Points<br/>			// reset the laser beam<br/>			resetBeam()<br/>		} else {<br/>			// show alternating alients<br/>			if loop%2 == 0 {<br/>				aliens[i].Filter.DrawAt(dst, src, image.Pt(aliens[i].Position.X, aliens[i].Position.Y), gift.OverOperator)<br/>			} else {<br/>				aliens[i].FilterA.DrawAt(dst, src, image.Pt(aliens[i].Position.X, aliens[i].Position.Y), gift.OverOperator)<br/>			}<br/>			// drop torpedoes<br/>			if rand.Float64() &lt; bombProbability {<br/>				dropBomb(aliens[i])<br/>			}			<br/>		}<br/>	}<br/>}</span></pre><p id="5e71" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">为了确定外星人应该去哪里，我们用变量<code class="fe mw mx my mz b">alienDirection</code>乘以外星人的水平(X)位置。</p><p id="b4f2" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">我们还使用外星人的<code class="fe mw mx my mz b">Status</code>来确定它是活着还是死了。如果它是活的，我们检查它是否与激光束碰撞过。如果是，那就是死了。我们绘制爆炸精灵，设置<code class="fe mw mx my mz b">Status</code>为假，累积玩家点数并重置激光束。重置激光束只是意味着我们将光束的<code class="fe mw mx my mz b">Status</code>设置回<code class="fe mw mx my mz b">false</code>，并将其放置在与加农炮相同的垂直(Y)水平。</p><pre class="lg lh li lj gu na mz nb nc aw nd bi"><span id="10c2" class="ne ly iu mz b gz nf ng l nh ni">func resetBeam() {<br/>	beam.Status = false<br/>	beam.Position.Y = 250<br/>}</span></pre><h1 id="5c50" class="lx ly iu bd lz ma mb mc md me mf mg mh ka mi kb mj kd mk ke ml kg mm kh mn mo bi translated">碰撞物理学</h1><p id="713e" class="pw-post-body-paragraph kj kk iu kl b km mp jv ko kp mq jy kr ks mr ku kv kw ms ky kz la mt lc ld le in bi translated">如果外星人没有与激光束碰撞，我们要么显示正常的精灵，要么显示替代精灵。这给了我们一个移动的外星人的动画。</p><p id="2acc" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">让我们快速看一下碰撞物理学，它集中在<code class="fe mw mx my mz b">collide()</code>函数中。</p><pre class="lg lh li lj gu na mz nb nc aw nd bi"><span id="5c56" class="ne ly iu mz b gz nf ng l nh ni">func collide(s1, s2 Sprite) bool {<br/>	spriteA := image.Rect(s1.Position.X, s1.Position.Y, s1.Position.X+s1.size.Dx(), s1.Position.Y+s1.size.Dy())<br/>	spriteB := image.Rect(s2.Position.X, s2.Position.Y, s2.Position.X+s1.size.Dx(), s2.Position.Y+s1.size.Dy())<br/>	if spriteA.Min.X &lt; spriteB.Max.X &amp;&amp; spriteA.Max.X &gt; spriteB.Min.X &amp;&amp;<br/>		spriteA.Min.Y &lt; spriteB.Max.Y &amp;&amp; spriteA.Max.Y &gt; spriteB.Min.Y {<br/>		return true<br/>	}<br/>	return false<br/>}</span></pre><p id="5a23" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">假设两个子画面被框在两个矩形内，如果满足所有这些条件，则认为子画面发生了碰撞:</p><ul class=""><li id="a4e5" class="nj nk iu kl b km kn kp kq ks nl kw nm la nn le ny np nq nr bi translated">spriteA。最小X &lt; spriteB.Max.X</li><li id="82ce" class="nj nk iu kl b km ns kp nt ks nu kw nv la nw le ny np nq nr bi translated">spriteA.Max.X &gt; spriteB。最小X</li><li id="dbc8" class="nj nk iu kl b km ns kp nt ks nu kw nv la nw le ny np nq nr bi translated">spriteA。最小Y &lt; spriteB.Max.Y</li><li id="542f" class="nj nk iu kl b km ns kp nt ks nu kw nv la nw le ny np nq nr bi translated">spriteA.Max.Y &gt; spriteB。最小Y</li></ul><figure class="lg lh li lj gu lk gi gj paragraph-image"><div class="gi gj nz"><img src="../Images/e9d1c41d200588db00148c6f40de6350.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*G7l27mShs5CBU78i.png"/></div></figure><h1 id="e187" class="lx ly iu bd lz ma mb mc md me mf mg mh ka mi kb mj kd mk ke ml kg mm kh mn mo bi translated">扔炸弹</h1><p id="d362" class="pw-post-body-paragraph kj kk iu kl b km mp jv ko kp mq jy kr ks mr ku kv kw ms ky kz la mt lc ld le in bi translated">当外星人降落在激光炮上时，他们投下炸弹。显然我们不希望它不断地投下炸弹，所以我们用一个概率来决定是否应该投下炸弹。</p><pre class="lg lh li lj gu na mz nb nc aw nd bi"><span id="339c" class="ne ly iu mz b gz nf ng l nh ni">// drop torpedoes<br/>if rand.Float64() &lt; bombProbability {<br/>	dropBomb(aliens[i])<br/>}</span></pre><p id="9f4a" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">在这里投放炸弹意味着我们创建一个新的<code class="fe mw mx my mz b">Bomb</code>精灵，并将其设置为从外星人所在的地方开始，然后将其添加到炸弹阵列中。</p><pre class="lg lh li lj gu na mz nb nc aw nd bi"><span id="bb07" class="ne ly iu mz b gz nf ng l nh ni">func dropBomb(alien Sprite) {<br/>	torpedo := Sprite{<br/>		size:     bombSprite,<br/>		Filter:   gift.New(gift.Crop(bombSprite)),<br/>		Position: image.Pt(alien.Position.X+7, alien.Position.Y),<br/>		Status:   true,<br/>	}</span><span id="0569" class="ne ly iu mz b gz nx ng l nh ni">	bombs = append(bombs, torpedo)<br/>}</span></pre><p id="d299" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">现在我们已经画出了外星人(或者它的爆炸死亡)，我们检查它是否已经移到了窗外。如果是的话，我们逆转方向，把外星人带下来。</p><pre class="lg lh li lj gu na mz nb nc aw nd bi"><span id="4238" class="ne ly iu mz b gz nf ng l nh ni">// move the aliens back and forth<br/>if aliens[0].Position.X &lt; alienSize || aliens[aliensPerRow-1].Position.X &gt; windowWidth-(2*alienSize) {<br/>	alienDirection = alienDirection * -1<br/>	for i := 0; i &lt; len(aliens); i++ {<br/>		aliens[i].Position.Y = aliens[i].Position.Y + 10<br/>	}<br/>}</span></pre><p id="8ff5" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">根据<code class="fe mw mx my mz b">bombSpeed</code>，我们还需要在致命下降时向下移动炸弹。</p><pre class="lg lh li lj gu na mz nb nc aw nd bi"><span id="5aca" class="ne ly iu mz b gz nf ng l nh ni">// draw bombs, if laser cannon is hit, game over<br/>for i := 0; i &lt; len(bombs); i++ {<br/>	bombs[i].Position.Y = bombs[i].Position.Y + bombSpeed<br/>	bombs[i].Filter.DrawAt(dst, src, image.Pt(bombs[i].Position.X, bombs[i].Position.Y), gift.OverOperator)<br/>	if collide(bombs[i], laserCannon) {<br/>		gameOver = true<br/>		laserCannon.FilterE.DrawAt(dst, src, image.Pt(laserCannon.Position.X, laserCannon.Position.Y), gift.OverOperator)<br/>	}<br/>}</span></pre><p id="3d27" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">当炸弹落下时，我们需要检查它是否与激光炮相撞。如果是的话，游戏就结束了，我们画爆炸的大炮精灵。</p><p id="5135" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">这就是游戏循环中外星人和他们的炸弹。接下来让我们看看激光炮和它的激光束。</p><h1 id="c61a" class="lx ly iu bd lz ma mb mc md me mf mg mh ka mi kb mj kd mk ke ml kg mm kh mn mo bi translated">激光炮和激光束</h1><p id="502c" class="pw-post-body-paragraph kj kk iu kl b km mp jv ko kp mq jy kr ks mr ku kv kw ms ky kz la mt lc ld le in bi translated">激光炮比较简单。只要加农炮没有被摧毁，我们就继续牵引它。</p><pre class="lg lh li lj gu na mz nb nc aw nd bi"><span id="3b31" class="ne ly iu mz b gz nf ng l nh ni">// draw the laser cannon unless it's been destroyed<br/>if !gameOver {<br/>	laserCannon.Filter.DrawAt(dst, src, image.Pt(laserCannon.Position.X, laserCannon.Position.Y), gift.OverOperator)<br/>}</span></pre><p id="e011" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">至于激光束，因为只有一个变量来表示它，你可能会意识到大炮一次只能发射一束激光束。这主要是为了简单起见。</p><p id="c876" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">我们使用<code class="fe mw mx my mz b">beamShot</code>变量来确定玩家是否按下了空格键，并因此发射了激光炮。</p><pre class="lg lh li lj gu na mz nb nc aw nd bi"><span id="548e" class="ne ly iu mz b gz nf ng l nh ni">// if the beam is shot, place the beam at start of the cannon<br/>if beamShot {<br/>	beam.Position.X = laserCannon.Position.X + 7<br/>	beam.Status = true<br/>	beamShot = false<br/>}</span></pre><p id="f27a" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">如果是，我们将光束放在激光炮的尖端，将光束的<code class="fe mw mx my mz b">Status</code>设置为<code class="fe mw mx my mz b">true</code>以指示光束正在运行，我们应该显示它，然后将<code class="fe mw mx my mz b">beamShot</code>设置回false。</p><p id="53bf" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">我们需要检查光束的<code class="fe mw mx my mz b">Status</code>,如果它在运动，我们就画出来，然后向上移动。如果光束的位置在窗口之外，我们再次重置光束。</p><pre class="lg lh li lj gu na mz nb nc aw nd bi"><span id="e3fd" class="ne ly iu mz b gz nf ng l nh ni">// keep drawing the beam as it moves every loop<br/>if beam.Status {<br/>	beam.Filter.DrawAt(dst, src, image.Pt(beam.Position.X, beam.Position.Y), gift.OverOperator)<br/>	beam.Position.Y -= 10<br/>}</span><span id="83c0" class="ne ly iu mz b gz nx ng l nh ni">// if the beam leaves the window reset it<br/>if beam.Position.Y &lt; 0 {<br/>	resetBeam()<br/>}</span></pre><h1 id="5795" class="lx ly iu bd lz ma mb mc md me mf mg mh ka mi kb mj kd mk ke ml kg mm kh mn mo bi translated">包装并打印图像</h1><p id="f6ec" class="pw-post-body-paragraph kj kk iu kl b km mp jv ko kp mq jy kr ks mr ku kv kw ms ky kz la mt lc ld le in bi translated">就在我们结束游戏循环之前，我们将图像打印到屏幕上，打印分数并递增循环。</p><pre class="lg lh li lj gu na mz nb nc aw nd bi"><span id="8f63" class="ne ly iu mz b gz nf ng l nh ni">printImage(dst)<br/>fmt.Println("\n\nSCORE:", score)<br/>loop++</span></pre><p id="72cf" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">那么我们到底如何在屏幕上打印图像呢<em class="lw"/>？这是通过ITerm2上的一个简单的黑客攻击完成的(所以这只在iTerm2上有效，抱歉！)</p><pre class="lg lh li lj gu na mz nb nc aw nd bi"><span id="b1f1" class="ne ly iu mz b gz nf ng l nh ni">// this only works for iTerm2!<br/>func printImage(img image.Image) {<br/>	var buf bytes.Buffer<br/>	png.Encode(&amp;buf, img)<br/>	imgBase64Str := base64.StdEncoding.EncodeToString(buf.Bytes())<br/>	fmt.Printf("\x1b[2;0H\x1b]1337;File=inline=1:%s\a", imgBase64Str)<br/>}</span></pre><p id="9986" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">就是这样！总而言之，包括注释在内，代码不到300行。如果它看起来很短，你应该记得最初的整个游戏编译二进制ROM的大小不到110kb，包括图像和音乐！我的是一个更简单的克隆版本，没有完整的游戏功能(多重生命，防御掩体，不明飞行物等)，还包括两个外部库。</p><p id="316c" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">这是它在我电脑上的样子。你戴起来怎么样？</p><figure class="lg lh li lj gu lk gi gj paragraph-image"><div class="gi gj oa"><img src="../Images/021389874732fbe965943925f13c908f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1108/1*zpFsnp371JqmFkQ90sdOYA.gif"/></div><figcaption class="lr ls gk gi gj lt lu bd b be z dk translated">iTerm2上的太空入侵者</figcaption></figure><p id="9cc1" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">这是在一个终端上心血来潮做的，后来我实际上把它变成了一个网络应用，<a class="ae lv" href="https://medium.com/sausheong/create-a-simple-cross-platform-desktop-game-with-go-8e5432128c9b" rel="noopener">点击这里</a>！</p><h1 id="be81" class="lx ly iu bd lz ma mb mc md me mf mg mh ka mi kb mj kd mk ke ml kg mm kh mn mo bi translated">密码</h1><p id="9b12" class="pw-post-body-paragraph kj kk iu kl b km mp jv ko kp mq jy kr ks mr ku kv kw ms ky kz la mt lc ld le in bi translated">这方面的代码都在这个GitHub存储库中。</p><p id="3924" class="pw-post-body-paragraph kj kk iu kl b km kn jv ko kp kq jy kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated"><a class="ae lv" href="https://github.com/sausheong/invaders" rel="noopener ugc nofollow" target="_blank">https://github.com/sausheong/invaders</a></p></div></div>    
</body>
</html>