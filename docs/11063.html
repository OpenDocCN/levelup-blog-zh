<html>
<head>
<title>A developer’s oath: keep my promises … with React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一个开发者的誓言:遵守我的承诺…用React</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/a-developers-oath-keep-my-promises-with-react-6926b60435c?source=collection_archive---------5-----------------------#2022-02-11">https://levelup.gitconnected.com/a-developers-oath-keep-my-promises-with-react-6926b60435c?source=collection_archive---------5-----------------------#2022-02-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4292" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">React开发人员的承诺处理建议</h2></div><p id="87c5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">注意:</strong>这个提议可以被移植到其他工具上，不久前我已经为lit-html移植过了。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi lc"><img src="../Images/5598d1514b54020c8602f7c9fc87ac51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/0*DnxiESKhvT43pU-5.gif"/></div></figure></div><div class="ab cl lk ll hu lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ij ik il im in"><h1 id="be0a" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">1/3引言</h1><p id="f121" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">有些承诺你信守，有些则不然；挺好的。只要这两种情况都处理了😌。剧透提示:结尾有一个代码沙箱。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/f13bd4a8666d8800e641b659823e8bf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:798/0*zMQWomNUtsZzq1F7"/></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">那天我希望我的应用程序可以是一个誓言…一个牢不可破的誓言🧙‍♀️</figcaption></figure><p id="6241" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在React项目(和其他项目)中，我有这样一种感觉，我们通过将结果保存在一个状态中来保持尽可能快地去结构化承诺——通常在组件安装时。像这样:</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="2c84" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在在想:<br/> 1。为什么总是重写这些<code class="fe mv mw mx my b">useEffect</code>或<code class="fe mv mw mx my b">componentDidMount</code>(尽管有些部分可以分解)？<br/> 2。解开承诺价值的冲动是什么？<br/>如果我们直接使用模板中的承诺会怎么样🤔？(这本身就是一个因式分解🤫。并且实际上会更加函数式编程友好，尽管这是有争议的。)</p><h1 id="6e99" class="lr ls iq bd lt lu mz lw lx ly na ma mb jw nb jx md jz nc ka mf kc nd kd mh mi bi translated">2/3承诺折叠和映射</h1><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/84e71269a5b500990981480dc1bf04f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/0*ZUPcVMziQdl1JGM2"/></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">疯狂的折叠技巧😎</figcaption></figure><p id="456f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有<strong class="kh ir">两个用例来<em class="nf">创建</em>承诺</strong> : <br/> <strong class="kh ir"> 1。</strong>当异步动作被触发时<em class="nf">立即</em>，如数据获取。<br/> <strong class="kh ir"> 2。</strong>按需触发<em class="nf">异步动作时，如表单提交。</em></p><p id="2e6c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有<strong class="kh ir">两个用例来<em class="nf">使用</em>一个承诺值</strong> : <br/> <strong class="kh ir"> 1。详尽地</strong>:在一个地方处理所有状态(未询问、未决、失败&amp;成功)；特别是确保错误得到处理😒。<br/>2<strong class="kh ir">。不完全</strong>:例如，当你需要一个按钮只有在提交被挂起时才被禁用。为了符合人体工程学，我们的组件API应该处理那些2 × 2用例。</p><blockquote class="ng nh ni"><p id="f3f5" class="kf kg nf kh b ki kj jr kk kl km ju kn nj kp kq kr nk kt ku kv nl kx ky kz la ij bi translated">旁注:我得出一个结论，特朗普和墨西哥人之间的边界(以及其他边界)是错误处理🤐</p></blockquote><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/31a12e8f4d48c90f533d87f2c5410619.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/0*U6ON8EqjD7BgwwXx"/></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">一个初级开发人员在路上的罕见镜头</figcaption></figure><h2 id="fd9b" class="nn ls iq bd lt no np dn lx nq nr dp mb ko ns nt md ks nu nv mf kw nw nx mh ny bi translated">1.异步动作立即触发——数据提取</h2><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="98f4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">出于测试目的，我们可以通过注入来测试所有的承诺状态:<br/> -未决:<code class="fe mv mw mx my b">getUser: (id) =&gt; <strong class="kh ir">new</strong> Promise()</code><br/>-从不解析承诺:<code class="fe mv mw mx my b">getUser: (id) =&gt; Promise.resolve(…)</code> <br/> -失败:<code class="fe mv mw mx my b">getUser: (id) =&gt; Promise.reject(<strong class="kh ir">new</strong> Error('Oops'))</code></p><h2 id="eb85" class="nn ls iq bd lt no np dn lx nq nr dp mb ko ns nt md ks nu nv mf kw nw nx mh ny bi translated">2.按需触发的异步动作<em class="nz"/>—表单提交</h2><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="8130" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好的，那很好。但是如果我有更复杂的需求呢，比如组合承诺？</p><h2 id="c0c2" class="nn ls iq bd lt no np dn lx nq nr dp mb ko ns nt md ks nu nv mf kw nw nx mh ny bi translated">承诺作文</h2><p id="476e" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">幸运的是，<code class="fe mv mw mx my b">Promise</code>是一个很棒的数据类型，它允许您转换成功数据<strong class="kh ir">和错误数据</strong>。这意味着我们可以自由地无限期地从其他承诺中创造承诺<strong class="kh ir">，而不会触发更多的请求</strong>。为了说明这一点:</p><pre class="ld le lf lg gt oa my ob oc aw od bi"><span id="ee32" class="nn ls iq my b gy oe of l og oh"><strong class="my ir">const</strong> user = fetch(…)<br/><strong class="my ir">const </strong>userName = user.then((user) =&gt; user.name)<br/><strong class="my ir">const</strong> userNameWithBetterError = userName.catch((error) =&gt; {<br/>  <strong class="my ir">if</strong> (error.message.length &gt; 10) throw error<br/>  <strong class="my ir">throw new</strong> Error('some clearer error')<br/>})</span></pre><p id="089c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后(🤭)在某种程度上，我们可以准确地分解它们的值<strong class="kh ir">，并且只在我们需要的地方进行分解</strong>。</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="2c76" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里，如果<code class="fe mv mw mx my b">user</code>承诺改变，<code class="fe mv mw mx my b">posts</code>承诺立即变为<em class="nf">待定</em>。</p><p id="b046" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在性能方面，可能会有惊人的影响:<br/> <em class="nf">在</em>之前:整个组件每承诺重渲染2+次。<br/><em class="nf"/>之后:组件为每个承诺重新呈现一次，当承诺解决或拒绝时，只有模板的子部分被重新呈现。<br/>多牛逼啊？</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/6390bb4a00349aa28277b0cf0990fcd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/0*v3qOc62cVH5SY5eG"/></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">我，唱着我的小夜曲</figcaption></figure><p id="a03a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在可能有一些我目前不知道的警告。想一想，我想知道这种方法是否有一个共同的警告:道具训练。<br/>如果你在组件树深处传递承诺，并在向下的过程中从props中创建新的承诺，我不知道错误有多明显，找到最初的错误承诺有多容易。这个<em class="nf">可能</em>不能帮助跟踪bug和追踪问题。<br/>另一方面，承诺堆叠痕迹挺好的，不把承诺当道具传就没事，所以……我不知道。也许一个不允许通过承诺作为道具的ESLint规则可以达到这个目的？<br/>思想？</p></div><div class="ab cl lk ll hu lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ij ik il im in"><h1 id="984f" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">3/3反馈时间！</h1><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/d9121493ac82c638c2652f94850cbca3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/0*XBGMqcII2vOih4E0"/></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">拜托了。</figcaption></figure><ul class=""><li id="b28c" class="oj ok iq kh b ki kj kl km ko ol ks om kw on la oo op oq or bi translated">你觉得这个图案怎么样？</li><li id="54e9" class="oj ok iq kh b ki os kl ot ko ou ks ov kw ow la oo op oq or bi translated">这是一个<strong class="kh ir">真</strong>好主意还是一个<strong class="kh ir">假</strong>好主意？</li><li id="fb41" class="oj ok iq kh b ki os kl ot ko ou ks ov kw ow la oo op oq or bi translated">你会在你的公司或项目中使用这种模式吗？</li><li id="2ccf" class="oj ok iq kh b ki os kl ot ko ou ks ov kw ow la oo op oq or bi translated">我是不是错过了一些应该阻止这个想法的东西？</li><li id="f49e" class="oj ok iq kh b ki os kl ot ko ou ks ov kw ow la oo op oq or bi translated">最后但同样重要的是:我应该对此做一个小小的改动吗？(如果是这样，我也会添加一个独立的挂钩😏)</li></ul><blockquote class="ng nh ni"><p id="18f3" class="kf kg nf kh b ki kj jr kk kl km ju kn nj kp kq kr nk kt ku kv nl kx ky kz la ij bi translated">如果您对承诺是如何在幕后表现的感兴趣，我使用了一个我在Elm包<a class="ae lb" href="https://package.elm-lang.org/packages/ohanhi/remotedata-http/latest/" rel="noopener ugc nofollow" target="_blank"> remotedata-http，</a>中遇到的通用数据类型<code class="fe mv mw mx my b"><em class="iq">RemoteData</em></code>，并将其转换为JavaScript/TypeScript:</p></blockquote><pre class="ld le lf lg gt oa my ob oc aw od bi"><span id="3559" class="nn ls iq my b gy oe of l og oh"><strong class="my ir">type</strong> RemoteData&lt;Error, Value&gt; =<br/>  | { kind: 'NotAsked' }<br/>  | { kind: 'Pending', stale: Value | undefined }<br/>  | { kind: 'Failure', error: Error }<br/>  | { kind: 'Success', value: Value }</span></pre><blockquote class="ng nh ni"><p id="86a6" class="kf kg nf kh b ki kj jr kk kl km ju kn nj kp kq kr nk kt ku kv nl kx ky kz la ij bi translated">我最近还在<a class="ae lb" href="https://gcanti.github.io/fp-ts/modules/TaskEither.ts.html" rel="noopener ugc nofollow" target="_blank"> fp-ts </a>库中发现了一个等价类型:<code class="fe mv mw mx my b"><em class="iq">TaskEither</em></code>。</p></blockquote></div><div class="ab cl lk ll hu lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ij ik il im in"><h2 id="fc4c" class="nn ls iq bd lt no np dn lx nq nr dp mb ko ns nt md ks nu nv mf kw nw nx mh ny bi translated">结论</h2><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/66cea42e63aa66bd31460fc35b35e747.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/0*80Sr5XYu0XM5f394"/></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">唷，那是一个很长的帖子，我想我现在需要打个盹</figcaption></figure><p id="cfa6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">无论如何，如果你已经走了这么远，非常感谢<em class="nf"/>的阅读，我希望它至少能引出一些问题。我在最后添加了一些关于现有技术的注释。</p><p id="6f2e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">保持安全😷，希望疫情将很快成为一个(非常)糟糕的记忆。<br/>干杯🤗，又这么久👋！</p><p id="a4ea" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">顺便说一句，我从来没有提到过:<br/>我目前住在巴黎东部(作为自由职业者)，如果你想边喝边讨论东西或项目，你可以给我留言😊。</p><p id="a892" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为我信守承诺🙃，承诺的沙盒:</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="ox mu l"/></div><figcaption class="mp mq gj gh gi mr ms bd b be z dk translated">沙盒</figcaption></figure></div><div class="ab cl lk ll hu lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ij ik il im in"><h1 id="2cb2" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">先前技术</h1><p id="1a80" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">我在NPM上发现的最接近的react现有技术是<a class="ae lb" href="https://oyvindberg.github.io/use-remote-data/intro" rel="noopener ugc nofollow" target="_blank"> use-remote-data </a>(它做了太多的事情)和<a class="ae lb" href="https://www.npmjs.com/package/react-use-promise-matcher" rel="noopener ugc nofollow" target="_blank">react-use-promise-matcher</a>，在这两种情况下，我都不喜欢需要一个钩子<strong class="kh ir">和一个组件</strong>的想法。IMHO它应该是一个钩子<strong class="kh ir">或</strong>一个组件。库应该尽可能保持简单，以便有效地集成在一起。<br/>例如，这里我只处理简单的承诺，你可以使用其他工具来处理承诺，比如<a class="ae lb" href="https://www.npmjs.com/package/ts-retry" rel="noopener ugc nofollow" target="_blank"> ts-retry </a>来处理重试策略。我不知道你如何履行你的诺言！</p><p id="d310" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其他现有技术——它们是很好的库，但不适合我现在使用库的方式:</p><ul class=""><li id="8d65" class="oj ok iq kh b ki kj kl km ko ol ks om kw on la oo op oq or bi translated"><a class="ae lb" href="https://www.npmjs.com/package/react-async-hook" rel="noopener ugc nofollow" target="_blank"> react-async-hook </a>:错误的数据结构允许不正确的状态。例如，<code class="fe mv mw mx my b">{ loading: true, error: new Error(…), result: '…' }</code>是一种可能的状态，它在现实世界中没有位置🤷。</li><li id="ea13" class="oj ok iq kh b ki os kl ot ko ou ks ov kw ow la oo op oq or bi translated"><a class="ae lb" href="https://react-query.tanstack.com/overview" rel="noopener ugc nofollow" target="_blank"> react-query </a>:同样的问题，而且它做了太多的事情，同时紧密地将它们绑定到react。在我看来，像缓存<strong class="kh ir">这样的特性实现不需要React </strong>，一般来说，这些特性应该与其他工具/库分离。</li><li id="b703" class="oj ok iq kh b ki os kl ot ko ou ks ov kw ow la oo op oq or bi translated"><a class="ae lb" href="https://oyvindberg.github.io/use-remote-data/intro/" rel="noopener ugc nofollow" target="_blank"> use-remote-data </a>:状态映射没有穷尽性(没有错误处理)，需要处理的东西太多，反应也紧密耦合。</li><li id="0016" class="oj ok iq kh b ki os kl ot ko ou ks ov kw ow la oo op oq or bi translated"><a class="ae lb" href="https://github.com/vercel/swr" rel="noopener ugc nofollow" target="_blank"> swr </a>:相同。但是不一样。但还是一样。🕵️‍</li></ul></div></div>    
</body>
</html>