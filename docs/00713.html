<html>
<head>
<title>Scala journals— error handling</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Scala日志—错误处理</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/scala-journals-part-6-error-handling-fe6c8a424cab?source=collection_archive---------1-----------------------#2019-07-05">https://levelup.gitconnected.com/scala-journals-part-6-error-handling-fe6c8a424cab?source=collection_archive---------1-----------------------#2019-07-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/02fce2a6f75f6a95774b7855d3e8cebb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TpVyaGwVgvb7T9IvMKG3eQ.jpeg"/></div></div></figure><p id="6027" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们来谈谈错误处理。在函数式编程中，我们不喜欢副作用。错误就是那些能够(并且将会)发生的事情！)走错了。如何用函数的方式处理Scala中的错误？</p><p id="96bd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我在第一篇文章中提到，当我想到Scala /函数式编程时，我会想到代数。对于你这样解方程，你的数学老师会怎么说:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="4098" class="lj lk it lf b gy ll lm l ln lo">x = 3 <br/>y = 0 <br/>x / y = error</span></pre><p id="0c6d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">…或者…</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="be57" class="lj lk it lf b gy ll lm l ln lo">x = 3 <br/>x / y = null</span></pre><p id="6668" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果函数方式像代数一样，那么我们不能允许<strong class="kd iu">空值</strong>或<strong class="kd iu">异常</strong>。空值破坏了参照透明性规则，换句话说，它们破坏了函数的纯洁性。例外也是如此(在某种程度上)。让我们澄清一下。</p><h1 id="3f86" class="lp lk it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">什么是参照透明和纯函数？</h1><p id="4540" class="pw-post-body-paragraph kb kc it kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">我之前提到过，但是<strong class="kd iu">纯函数</strong>是这样一个函数:</p><ul class=""><li id="c913" class="mr ms it kd b ke kf ki kj km mt kq mu ku mv ky mw mx my mz bi translated">它的返回值不是<code class="fe na nb nc lf b">Unit</code> -想想看:<code class="fe na nb nc lf b">Unit</code>强烈暗示我们正在做一些不纯的事情(比如<code class="fe na nb nc lf b">println</code>)也许？)</li><li id="24cf" class="mr ms it kd b ke nd ki ne km nf kq ng ku nh ky mw mx my mz bi translated">它的返回值只依赖于它的参数:<br/> <code class="fe na nb nc lf b">def add(x: Int, y: Int) = x + y</code></li><li id="25fe" class="mr ms it kd b ke nd ki ne km nf kq ng ku nh ky mw mx my mz bi translated">该函数的返回值在任何时候都是相同的，没有例外:</li></ul><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="973e" class="lj lk it lf b gy ll lm l ln lo">def add(x: Int, y: Int) = x + y <br/>add(1, 4) // 5 <br/>add(1, 4) // 5 again, this could never evaluate to anything else</span></pre><ul class=""><li id="9ca0" class="mr ms it kd b ke kf ki kj km mt kq mu ku mv ky mw mx my mz bi translated">这个函数的返回值可以和这个函数调用互换使用</li></ul><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="ff29" class="lj lk it lf b gy ll lm l ln lo">def add(x: Int, y: Int) = x + y <br/>add(1, 5) == 6 // true at all times as add(1, 5) is the same as 6 at all times</span></pre><p id="b401" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">引用透明</strong>指的是最后一点——在简化中，它意味着你总是可以用它的返回值替换一个函数调用。</p><h1 id="7413" class="lp lk it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">没有空听起来很粗略</h1><p id="906f" class="pw-post-body-paragraph kb kc it kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">如果你曾经调试过<code class="fe na nb nc lf b">NullPointerException</code>,你将会体会到无空规则。如果不是，就认为null不是一个值——它表示没有值。而这种东西在代数中是不存在的。自从我开始函数式编程之旅以来，我只在使用一些Java库的环境中遇到过使用null，这些库的<em class="kz">可能会返回null。尽管如此，我的Scala代码不会使用null。</em></p><p id="227f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Scala不像Java那样有检查异常的概念，在Java中编译器会提醒你(在一定程度上)你的错误处理——所以在Scala中，无论你告诉你的函数将返回什么，编译器都会假设你没有说谎。</p><h1 id="4191" class="lp lk it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">为什么异常“在某种程度上”破坏了参照透明性？</h1><p id="cb2c" class="pw-post-body-paragraph kb kc it kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">例外应该根据它们的名字来使用——例外。当一个情况是一个真正的例外。被零除真的是例外吗？不会，如果你的递归函数意外炸栈，是真的异常吗？大概是的。(尽管这也意味着你的测试很丢人！)</p><p id="f71a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这导致了(也许是有争议的)一种说法，即只有当异常被显式地观察和执行时，它们才会破坏参照透明性。这意味着—如果您编写显式抛出或捕获异常的代码，您就破坏了引用透明性。如果代码“自己”做到了——我个人认为没问题。异常将在真正异常的情况下抛出。这显然并不意味着我们完全忽略错误处理！让我们看看Scala提供了什么。</p><h1 id="cf5d" class="lp lk it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">期权及其在现实世界中的应用</h1><p id="fd8b" class="pw-post-body-paragraph kb kc it kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">建议一个可选值——一个可能存在也可能不存在的值。如果它存在，它被包裹在<code class="fe na nb nc lf b">Some</code>中，如果它不存在，它就变成了<code class="fe na nb nc lf b">None</code>。这非常适合模式匹配。</p><p id="9299" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们看看下面的基本用法——想象一下注册中的可选字段，比如“生日”。<code class="fe na nb nc lf b">calculateAge</code>函数获取出生日期并计算年龄。</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="b63d" class="lj lk it lf b gy ll lm l ln lo">def calculateAge(birthday: Option[Date]): Option[Int] =        <br/>       birthday match {         <br/>            case Some(bday) =&gt; Some(calculateAge(bday))         <br/>            case None =&gt; None     <br/>} </span><span id="2916" class="lj lk it lf b gy ni lm l ln lo">private def calculateAge(bday: Date): Int = 21 <br/>// everyone is 21 obviously ;)  </span></pre><p id="9858" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们的客户添加了他们的出生日期，他们的年龄将被计算出来，并以<code class="fe na nb nc lf b">Some</code>的形式返回。如果客户错过了他们的出生日期，甚至不会调用<code class="fe na nb nc lf b">calculateAge</code>，他们的年龄将作为<code class="fe na nb nc lf b">None</code>返回。现在就看打电话的人处理了。</p><p id="f8dc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">选项<strong class="kd iu">被大量使用</strong>。一些实际例子:</p><ul class=""><li id="be78" class="mr ms it kd b ke kf ki kj km mt kq mu ku mv ky mw mx my mz bi translated">函数中的可选参数:</li></ul><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="57f4" class="lj lk it lf b gy ll lm l ln lo">def optionalStrings(str: Option[String]) = ...</span></pre><ul class=""><li id="1233" class="mr ms it kd b ke kf ki kj km mt kq mu ku mv ky mw mx my mz bi translated">初始化时不存在的参数</li></ul><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="8d69" class="lj lk it lf b gy ll lm l ln lo">case class Customer(name: String, age: Option[Int])  <br/>// age can be updated/added later</span></pre><ul class=""><li id="9356" class="mr ms it kd b ke kf ki kj km mt kq mu ku mv ky mw mx my mz bi translated">当您不关心错误消息时</li></ul><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="3ede" class="lj lk it lf b gy ll lm l ln lo">def divide(one: Int, two: Int): Option[Int] =    <br/>      two match {     <br/>          case t if t == 0 =&gt; None     <br/>          case t =&gt; Some(one/two)    <br/>       }</span></pre><h2 id="0877" class="lj lk it bd lq nj nk dn lu nl nm dp ly km nn no mc kq np nq mg ku nr ns mk nt bi translated">摘要</h2><p id="c842" class="pw-post-body-paragraph kb kc it kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated"><code class="fe na nb nc lf b">Option</code> ==可能缺少数据或者我们不关心错误消息</p><h1 id="f560" class="lp lk it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">以及它在现实世界中的用法</h1><p id="ef46" class="pw-post-body-paragraph kb kc it kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated"><code class="fe na nb nc lf b">Either</code>与选项非常相似，不同之处在于它允许检索错误消息。可能是<code class="fe na nb nc lf b">Left</code>也可能是<code class="fe na nb nc lf b">Right</code> - <code class="fe na nb nc lf b">Left</code>表示有问题(类似于<code class="fe na nb nc lf b">Option</code>中的<code class="fe na nb nc lf b">None</code>),<code class="fe na nb nc lf b">Right</code>表示一切正常(类似于<code class="fe na nb nc lf b">Some</code>表示<code class="fe na nb nc lf b">Option</code>)。</p><p id="d588" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们看看上面使用<code class="fe na nb nc lf b">Either</code>实现的生日示例。</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="7af7" class="lj lk it lf b gy ll lm l ln lo">// type Age is only a type alias to make below Either more explicit and easier to understand <br/>type Age = Int  </span><span id="bb47" class="lj lk it lf b gy ni lm l ln lo">// this will hold our error detail case class CalculationProblem(problem: String)   </span><span id="fd12" class="lj lk it lf b gy ni lm l ln lo">def calculateAge(birthday: Option[Date]): Either[CalculationProblem, Age] =    <br/>birthday match {         <br/>    case Some(bday) =&gt; Right(calculateAge(bday))         <br/>    case None =&gt; Left(CalculationProblem("Birthday date missing")    } </span><span id="7686" class="lj lk it lf b gy ni lm l ln lo">private def calculateAge(bday: Date): Int = 21</span></pre><p id="c7a8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe na nb nc lf b">Either</code>用的很多，我会说和<code class="fe na nb nc lf b">Option</code>差不多。当然有很多更好的方法来实现<code class="fe na nb nc lf b">calculateAge</code>——这是毫无疑问的，但是让我们用它来想出一些在现实生活中如何以及何时使用<code class="fe na nb nc lf b">Either</code>的好主意。</p><ul class=""><li id="2df4" class="mr ms it kd b ke kf ki kj km mt kq mu ku mv ky mw mx my mz bi translated">当您想要获取错误消息并对其采取行动时，您可以将其打包在<code class="fe na nb nc lf b">Left</code>中。<code class="fe na nb nc lf b">Right</code>将代表幸福之路。</li><li id="f8dd" class="mr ms it kd b ke nd ki ne km nf kq ng ku nh ky mw mx my mz bi translated">使用<code class="fe na nb nc lf b">Either</code>而不是抛出异常——你可以创建一个case类(或者整个层次结构，有点像异常)来保存你的错误信息，就像我上面做的那样(这也是一个非常常见的做法)</li><li id="34c7" class="mr ms it kd b ke nd ki ne km nf kq ng ku nh ky mw mx my mz bi translated">确保你的<code class="fe na nb nc lf b">Either</code>是可以理解的，并且在它出现的上下文中容易推理。这意味着有时创建类型或别名并使用<code class="fe na nb nc lf b">Either[DatabaseConnectionProblem, WriteSuccess]</code>而不是<code class="fe na nb nc lf b">Either[Problem, Unit]</code>更好——想想在你的代码所做的上下文中放置第一个<code class="fe na nb nc lf b">Either</code>和第二个<code class="fe na nb nc lf b">Either</code>有多容易或多难。</li></ul><h2 id="cf0a" class="lj lk it bd lq nj nk dn lu nl nm dp ly km nn no mc kq np nq mg ku nr ns mk nt bi translated">摘要</h2><p id="6975" class="pw-post-body-paragraph kb kc it kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated"><code class="fe na nb nc lf b">Either</code> ==操作可能失败，我们关心错误信息</p><h1 id="887a" class="lp lk it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">Try及其在现实世界中的用法</h1><p id="1425" class="pw-post-body-paragraph kb kc it kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">最后但并非最不重要的(虽然在我今天提到的所有三种类型中使用最少的)是<code class="fe na nb nc lf b">Try</code>。你可以认为<code class="fe na nb nc lf b">Try</code>是<code class="fe na nb nc lf b">Either</code>的一种特殊类型，其中<code class="fe na nb nc lf b">Left</code>不是<code class="fe na nb nc lf b">Left</code>而是<code class="fe na nb nc lf b">Throwable</code>。这意味着<code class="fe na nb nc lf b">Try</code>是处理抛出异常的代码的一个很好的选择(想想Java库)。构造函数自动“捕捉”应该抛出的异常，并将它们放在<code class="fe na nb nc lf b">Try</code>的<code class="fe na nb nc lf b">Left</code> - <code class="fe na nb nc lf b">Failure</code>的等效位置。快乐路径结果进入<code class="fe na nb nc lf b">Success</code>。</p><p id="7c76" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">将<code class="fe na nb nc lf b">Try</code>和<code class="fe na nb nc lf b">calculateAge</code>一起使用有点大材小用，所以让我们再来看看分工:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="5eb8" class="lj lk it lf b gy ll lm l ln lo">def divide(one: Int, two: Int): Try[Int] = Try(one/two) <br/>divide(1, 0) // Failure(java.lang.ArithmeticException: / by zero) divide(1, 1) // Success(1)</span></pre><p id="7a09" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">…想想模式匹配处理这种情况会有多容易，这种方法可以避免出现异常:</p><p id="f662" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">没有灵丹妙药，但是一般来说<code class="fe na nb nc lf b">Try</code>比<code class="fe na nb nc lf b">Either</code>和<code class="fe na nb nc lf b">Option</code>用得少一点，原因很简单，我们一般不希望在Scala代码中看到异常。<code class="fe na nb nc lf b">Try</code>非常适合:</p><ul class=""><li id="5490" class="mr ms it kd b ke kf ki kj km mt kq mu ku mv ky mw mx my mz bi translated">抛出异常的代码(例如Java库)</li></ul><h2 id="6822" class="lj lk it bd lq nj nk dn lu nl nm dp ly km nn no mc kq np nq mg ku nr ns mk nt bi translated">摘要</h2><p id="fadb" class="pw-post-body-paragraph kb kc it kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated"><code class="fe na nb nc lf b">Try</code> ==包装在<code class="fe na nb nc lf b">Try</code>中的代码可能会抛出异常</p><h1 id="419f" class="lp lk it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">那么我应该抛出异常吗？</h1><p id="7aa5" class="pw-post-body-paragraph kb kc it kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">如上所述——只有在<strong class="kd iu">真正</strong>的例外情况下。在定义异常时，我是一个纯粹主义者(在可抛出的意义上)——如果你知道它会在你的代码中发生，它就不是异常，它只是一条不愉快的路径。由于在Scala代码中抛出异常对我来说是一件大事，我记得非常清楚，在我的职业生涯中，只有一次在我工作的Scala代码库中允许出现显式异常。</p><h1 id="7411" class="lp lk it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">错误处理摘要</h1><p id="16e0" class="pw-post-body-paragraph kb kc it kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">仔细想想，盲目地遵循参照透明性最终会让我们认为我们不能有任何IO操作/数据存储，甚至不能有随机数或时间/日期操作。那编程有什么用？</p><p id="2fa7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">正如我在其他帖子中多次提到的，这完全取决于你想成为一个多么纯粹的人。在我的代码中，我遵循这些规则:</p><ul class=""><li id="7ba1" class="mr ms it kd b ke kf ki kj km mt kq mu ku mv ky mw mx my mz bi translated">我不使用空值。永远不会。如果我不关心为什么某件事可能是<code class="fe na nb nc lf b">None</code>，我使用<code class="fe na nb nc lf b">Option</code>，如果我想知道失败的原因，我使用<code class="fe na nb nc lf b">Either</code></li><li id="439f" class="mr ms it kd b ke nd ki ne km nf kq ng ku nh ky mw mx my mz bi translated">我不抛出异常。我用<code class="fe na nb nc lf b">Either</code>代替。</li><li id="e19e" class="mr ms it kd b ke nd ki ne km nf kq ng ku nh ky mw mx my mz bi translated">我不尝试/捕捉可能抛出异常的代码(例如Java库)，而是将有问题的代码封装在<code class="fe na nb nc lf b">Try</code>中，并在<code class="fe na nb nc lf b">Success</code>或<code class="fe na nb nc lf b">Failure</code>上进行模式匹配——这是异常停止冒泡的地方</li><li id="c771" class="mr ms it kd b ke nd ki ne km nf kq ng ku nh ky mw mx my mz bi translated">我认为异常和空值是邪恶的——我尽一切可能不使用它们，即使这意味着从我的高级同事那里寻求我可能不会使用的替代方法的帮助(还没有！)要意识到。</li></ul><h1 id="a680" class="lp lk it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">(不那么)可怕的东西结束</h1><p id="fed9" class="pw-post-body-paragraph kb kc it kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">还记得我在关于理解的文章中说过单子是可以平面映射的东西吗？我说:</p><blockquote class="nu nv nw"><p id="07da" class="kb kc kz kd b ke kf kg kh ki kj kk kl nx kn ko kp ny kr ks kt nz kv kw kx ky im bi translated">因为理解对于处理和编写单子来说是很棒的。</p></blockquote><p id="1c89" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">猜猜是什么— <code class="fe na nb nc lf b">Try</code>、<code class="fe na nb nc lf b">Option</code>和<code class="fe na nb nc lf b">Either</code>(虽然要么只来自Scala 2.12！)也是单子。这意味着你可以用它们来理解。</p><p id="d453" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">参考资料:<br/> <em class="kz"> Scala食谱</em>作者a .亚历山大<br/><em class="kz">Scala中的编程:简体</em>作者a .亚历山大<br/><a class="ae oa" href="https://www.garysieling.com/scaladoc/" rel="noopener ugc nofollow" target="_blank">https://www.garysieling.com/scaladoc/</a></p></div></div>    
</body>
</html>