<html>
<head>
<title>3 Principles You Can Use Now to Make Stable Software</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">现在你可以用3个原则来制作稳定的软件</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/3-principles-you-can-use-now-to-make-stable-software-3b84bad7a4e?source=collection_archive---------8-----------------------#2021-03-18">https://levelup.gitconnected.com/3-principles-you-can-use-now-to-make-stable-software-3b84bad7a4e?source=collection_archive---------8-----------------------#2021-03-18</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="29ae" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">我对稳定软件生产的探索。以下是我学到的。</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/fe1a3f5d0ba93b812c651fdeed51ebce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Igatbzgee8kwcJxm"/></div></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated">照片由<a class="ae kz" href="https://www.pexels.com/@mastercowley?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">内森·考利</a>从<a class="ae kz" href="https://www.pexels.com/photo/photo-of-stacked-rocks-near-shore-1192672/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">派克斯</a>拍摄</figcaption></figure><p id="af9c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我写了一篇关于弹性软件的<a class="ae kz" rel="noopener ugc nofollow" target="_blank" href="/3-object-oriented-tips-sandi-metz-uses-for-better-software-design-1c5393c7698d">文章</a>。稳定的软件对每个开发者来说都是至关重要的。这就是为什么稳定的软件需要更多的关注。</p><p id="fc86" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">您收到了来自企业的新请求。您几乎没有将它放入现有的代码库。过了一会儿，稍有不同的情况出现了。</p><p id="e129" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">它会一次又一次地发生。添加新功能变得日益困难。</p><blockquote class="lw lx ly"><p id="1d9f" class="la lb lz lc b ld le jv lf lg lh jy li ma lk ll lm mb lo lp lq mc ls lt lu lv in bi translated">每个人都面临这个问题。</p></blockquote><p id="e153" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">让我们来研究一下可能的解决方案。创建稳定灵活的软件。经得起所有可能变化的软件。</p></div><div class="ab cl md me hy mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="in io ip iq ir"><h1 id="7e2d" class="mk ml iu bd mm mn mo mp mq mr ms mt mu ka mv kb mw kd mx ke my kg mz kh na nb bi translated">创建序列图</h1><p id="863b" class="pw-post-body-paragraph la lb iu lc b ld nc jv lf lg nd jy li lj ne ll lm ln nf lp lq lr ng lt lu lv in bi translated">对象协作。对象应该被隔离。从某种意义上说是孤立的，一个不依赖于另一个。如果一个对象改变了，从属对象不应该改变。</p><p id="bc16" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">使用<a class="ae kz" href="https://www.websequencediagrams.com/" rel="noopener ugc nofollow" target="_blank">序列图</a>捕捉对象的交互。现在您将看到对象是如何协作的。发送什么消息，以及每个对象知道什么。</p><p id="2c4c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">查找没有从属或依赖关系的对象。行尾代码，有很多程序逻辑。桑迪·梅兹称这些为“欧米伽混乱”的物体。</p><p id="9188" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">你应该把“欧米茄乱七八糟”分成方法。尽可能地理清逻辑。您可能会回到代码，并添加更多的特性。</p><p id="14a2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在我看来，这些物体带来了很多麻烦。你触摸它们，你就破坏了特征。有一个合适的测试套件。那你就变了。</p><p id="8181" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">即使你完成了提取和解耦，你也不会满意。你需要构图。将尽可能多的逻辑提取到新对象中。</p><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj nh"><img src="../Images/db37f3a274d7df9cb8bfc10dab509752.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/format:webp/0*ou_Q-Tu6vO7MWWVO.png"/></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated">程序表</figcaption></figure></div><div class="ab cl md me hy mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="in io ip iq ir"><h1 id="3738" class="mk ml iu bd mm mn mo mp mq mr ms mt mu ka mv kb mw kd mx ke my kg mz kh na nb bi translated">使用对象知识</h1><figure class="kk kl km kn gu ko gi gj paragraph-image"><div class="gi gj ni"><img src="../Images/090ea8036c135cd18ffd6f59c16f976a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/0*bDcEaZ80AI-90CTO"/></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated">摘自桑迪·梅茨的演讲《来吧，制造混乱》</figcaption></figure><p id="0bab" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">知识图谱显示对象的智能。情节由<em class="lz">【公共API】</em><em class="lz">【私有API】</em><em class="lz">【依赖】</em>组成。一个人应该<em class="lz">公开</em> API，<em class="lz">隐藏</em>私有行为。稳定的依赖关系应该<em class="lz">最小化</em>，不稳定的依赖关系应该<em class="lz">移动</em>。</p><p id="b4f1" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">首先检查运动部件。不适合的逻辑在这里，计算产品中的价格不适合。将逻辑移到一个单独的对象中，并在需要的地方注入。</p><p id="2f54" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">即使你把物体放在这个情节里，你也只是想想而已。如果代码更改没有明显的好处，就不要这样做。等等。等待新的要求。</p><p id="7ccd" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">你现在能做什么？你可以改善现有的混乱，尽量减少它。如果稳定的话。</p><p id="9ed6" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">检查测试，如果需要，添加更多测试。检查圈复杂度，寻找遗漏的执行路径。为缺失的执行路径添加测试。</p><blockquote class="lw lx ly"><p id="bed7" class="la lb lz lc b ld le jv lf lg lh jy li ma lk ll lm mb lo lp lq mc ls lt lu lv in bi translated">组件依赖应该朝着稳定的方向发展</p></blockquote><p id="4a6e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">检查稳定的组件。看看哪些组件是新的和易变的。x轴代表组件的稳定性。</p><p id="0dbf" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">稳定的组件正在工作，经受住了时间的考验，并包含核心逻辑。易变组件是新的，易于变化，并且位于x轴的不稳定部分。</p><p id="af57" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">稳定应该最小化或暴露。应该移动或隐藏Volatile。不要让稳定依赖于不稳定。应该是反过来。变化的组件应该依赖于稳定的组件。</p></div><div class="ab cl md me hy mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="in io ip iq ir"><h1 id="39bd" class="mk ml iu bd mm mn mo mp mq mr ms mt mu ka mv kb mw kd mx ke my kg mz kh na nb bi translated">使用组合</h1><p id="44a4" class="pw-post-body-paragraph la lb iu lc b ld nc jv lf lg nd jy li lj ne ll lm ln nf lp lq lr ng lt lu lv in bi translated">遗产上的复合。将逻辑移入对象并注入。错误的抽象会成为负担。大多数开发人员扩展了一个超类，而没有仔细观察。</p><p id="0a1b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">隔离对象中的逻辑。稳定的对象是指没有依赖和依赖的对象。向那个对象移动，尽可能地去耦合。</p><p id="cbba" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">当你完成隔离后，问问题。这属于这里吗？这个逻辑在做什么？放在知识情节上。</p><p id="88af" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">将责任转移到角色。创建新角色，并依赖它们的接口。使用接口隐藏内部行为。</p><p id="2a13" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">基于对象的抽象进行协作，而不是基于内部行为。遵循依赖倒置原则。</p><blockquote class="lw lx ly"><p id="053c" class="la lb lz lc b ld le jv lf lg lh jy li ma lk ll lm mb lo lp lq mc ls lt lu lv in bi translated">依靠抽象，而不是具体</p></blockquote></div><div class="ab cl md me hy mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="in io ip iq ir"><h1 id="d21f" class="mk ml iu bd mm mn mo mp mq mr ms mt mu ka mv kb mw kd mx ke my kg mz kh na nb bi translated">结论</h1><p id="0791" class="pw-post-body-paragraph la lb iu lc b ld nc jv lf lg nd jy li lj ne ll lm ln nf lp lq lr ng lt lu lv in bi translated">布局对象消息。这将有助于您了解对象之间发送的消息。之后，你会看到你的软件的角色。提取到方法中并继续前进。</p><p id="9138" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">把你的对象放在知识图上。然后你就可以看到需要做什么了。你也会看到什么是稳定的，什么是不稳定的。依赖稳定成分，远离不稳定成分。</p><p id="f0e7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">隔离逻辑。移动对象中的逻辑。注入并与他们互动。避免继承，偏爱构图。</p></div><div class="ab cl md me hy mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="in io ip iq ir"><h1 id="6f69" class="mk ml iu bd mm mn mo mp mq mr ms mt mu ka mv kb mw kd mx ke my kg mz kh na nb bi translated">资源</h1><div class="nj nk gq gs nl nm"><a href="https://khalilstemmler.com/wiki/stable-dependency-principle/" rel="noopener  ugc nofollow" target="_blank"><div class="nn ab fp"><div class="no ab np cl cj nq"><h2 class="bd iv gz z fq nr fs ft ns fv fx it bi translated">稳定依赖原则(SDP)| Khalil stem ler</h2><div class="nt l"><h3 class="bd b gz z fq nr fs ft ns fv fx dk translated">每个系统都有稳定的部分和不稳定的部分。稳定的组件是不被期望…</h3></div><div class="nu l"><p class="bd b dl z fq nr fs ft ns fv fx dk translated">khalilstemmler.com</p></div></div><div class="nv l"><div class="nw l nx ny nz nv oa kt nm"/></div></div></a></div><div class="nj nk gq gs nl nm"><a href="https://softwareengineering.stackexchange.com/questions/290594/depend-in-the-direction-of-stability-how-do-i-know-what-is-more-stable" rel="noopener  ugc nofollow" target="_blank"><div class="nn ab fp"><div class="no ab np cl cj nq"><h2 class="bd iv gz z fq nr fs ft ns fv fx it bi translated">依赖于稳定的方向:我如何知道什么更稳定？</h2><div class="nt l"><h3 class="bd b gz z fq nr fs ft ns fv fx dk translated">根据稳定依赖原则，依赖应该在稳定的方向，但是:如果你…</h3></div><div class="nu l"><p class="bd b dl z fq nr fs ft ns fv fx dk translated">softwareengineering.stackexchange.com</p></div></div><div class="nv l"><div class="ob l nx ny nz nv oa kt nm"/></div></div></a></div><div class="nj nk gq gs nl nm"><a href="https://devlead.io/DevTips/StableDependenciesPrinciple" rel="noopener  ugc nofollow" target="_blank"><div class="nn ab fp"><div class="no ab np cl cj nq"><h2 class="bd iv gz z fq nr fs ft ns fv fx it bi translated">稳定依赖原则| DevLead.io</h2><div class="nt l"><h3 class="bd b gz z fq nr fs ft ns fv fx dk translated">以这样一种方式设计你的软件，任何给定的组件都依赖于其他组件…</h3></div><div class="nu l"><p class="bd b dl z fq nr fs ft ns fv fx dk translated">devlead.io</p></div></div><div class="nv l"><div class="oc l nx ny nz nv oa kt nm"/></div></div></a></div><p id="bcb8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><a class="ae kz" href="https://www.youtube.com/watch?v=xi3DClfGuqQ" rel="noopener ugc nofollow" target="_blank">桑迪·梅斯谈欧米茄的混乱</a></p></div><div class="ab cl md me hy mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="in io ip iq ir"><h1 id="cc84" class="mk ml iu bd mm mn mo mp mq mr ms mt mu ka mv kb mw kd mx ke my kg mz kh na nb bi translated">继续阅读相关文章</h1><div class="nj nk gq gs nl nm"><a rel="noopener  ugc nofollow" target="_blank" href="/3-object-oriented-tips-sandi-metz-uses-for-better-software-design-1c5393c7698d"><div class="nn ab fp"><div class="no ab np cl cj nq"><h2 class="bd iv gz z fq nr fs ft ns fv fx it bi translated">高级开发人员使用弹性软件的3个原则</h2><div class="nt l"><h3 class="bd b gz z fq nr fs ft ns fv fx dk translated">Sandi Metz关于面向对象设计的三大开发经验</h3></div><div class="nu l"><p class="bd b dl z fq nr fs ft ns fv fx dk translated">levelup.gitconnected.com</p></div></div><div class="nv l"><div class="od l nx ny nz nv oa kt nm"/></div></div></a></div></div></div>    
</body>
</html>