<html>
<head>
<title>If You are Web Scraping Don’t Do These Things</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如果你是网络抓取者，不要做这些事情</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/if-you-are-web-scraping-dont-do-these-things-2cba2ebe5b29?source=collection_archive---------0-----------------------#2020-07-12">https://levelup.gitconnected.com/if-you-are-web-scraping-dont-do-these-things-2cba2ebe5b29?source=collection_archive---------0-----------------------#2020-07-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/8b78a4a7c44734a935b652ddc54c2467.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xxXy9afXKQe6vwN5q22nYw.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">来源:<a class="ae kf" href="https://imgur.com/gallery/bjD7f3p" rel="noopener ugc nofollow" target="_blank"> Imgur </a></figcaption></figure><p id="ac25" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Web抓取是许多程序员最喜欢的消遣。我觉得我参与的3个项目中有2个最终需要我做网络搜集。也就是说，我见过很多糟糕的网络抓取脚本。更糟糕的是，有人真的对有这些问题的代码收费。</p><h1 id="9037" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">1.不要硬编码会话Cookies</h1><figure class="md me mf mg gt ju gh gi paragraph-image"><div class="gh gi mc"><img src="../Images/d26488eb6baa75c8f7fbbdb62cec1789.png" data-original-src="https://miro.medium.com/v2/resize:fit:906/format:webp/0*SloLQtb-fo9g8i4t.jpg"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">我保证我剩下的照片会更好…来源:【teamscs.com<a class="ae kf" href="https://www.teamscs.com/2015/04/hard-coding-used/" rel="noopener ugc nofollow" target="_blank"/></figcaption></figure><p id="5eda" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">停下来。只是。停下来。你硬编码的任何东西都有可能悲惨地失败。这里有一个例子，说明这可能是什么样子，而不是你应该做什么。</p><p id="2cb4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你的客户有一个网站，他们想刮需要登录。没问题，只要从浏览器登录到那个站点，获取会话cookie并在每次代码调用服务器时发送它。Ez pz。您不知道的是该会话的TTL(生存时间)。如果该会话在一个月后过期怎么办？这意味着一旦你把他们的脚本交给你的客户，在他们的代码消失之前，你最多还有一个月的时间。</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="5b9a" class="mm lf it mi b gy mn mo l mp mq"># This is bad. Don't do this<br/>headers = {<br/>    'Cookie': '_session=23ln4teknl4iowgel'<br/>}</span><span id="eda4" class="mm lf it mi b gy mr mo l mp mq">for url in url_list:<br/>    response = requests.get(url, headers=headers)</span></pre><p id="97d6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么你应该怎么做呢？编写您的程序登录并使用会话来确保您的cookies随每个请求一起发送！</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="7dcf" class="mm lf it mi b gy mn mo l mp mq">s = <!-- -->requests.Session()<br/>s.post("https://fakewebsite.com/login", login_data)</span><span id="a803" class="mm lf it mi b gy mr mo l mp mq">for url in url_list:<br/>    response = s.get(url)</span></pre><p id="73d5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这只需要一点额外的工作，但它将节省您的时间，从不断更新代码。</p><h1 id="c1c1" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">2.不要做网站</h1><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ms"><img src="../Images/84b1158b63a1695e54a3fa5def1c589d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*veNwOxoa9URJPk8UIbpZLw.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">来源:<a class="ae kf" href="https://www.microsoft.com/en-us/p/dos-pro/9p5cr9x5fkvq?activetab=pivot:overviewtab" rel="noopener ugc nofollow" target="_blank">微软</a></figcaption></figure><p id="d179" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不是那种类型的DOS。我是说拒绝服务。如果你不认为你正在这样做，你应该看看这一部分，因为我要让你大吃一惊。写一个for循环来访问一个网站是一个DOS。以这段代码为例:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="0d25" class="mm lf it mi b gy mn mo l mp mq">for page in range(1000):<br/>    response = requests.get("https://search.com?page=" + page)</span></pre><p id="d4fa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这种类型的东西会让你的IP被禁止，然后你要么不得不切换到一个旋转代理(潜在的昂贵和耗时)，要么每次你被禁止时获得一个新的公共IP。根据您的ISP，这可能是一个问题。</p><p id="d64c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">相反，只是添加一些友好的延迟！哇这么简单！(我从<a class="ae kf" href="https://stackoverflow.com/questions/4054254/how-to-add-random-delays-between-the-queries-sent-to-google-to-avoid-getting-blo" rel="noopener ugc nofollow" target="_blank">堆栈溢出</a>中复制并粘贴了我的解决方案，这没问题)。</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="68b5" class="mm lf it mi b gy mn mo l mp mq">from random import randint<br/>from time import sleep</span><span id="4f57" class="mm lf it mi b gy mr mo l mp mq">for page in range(1000):<br/>    response = requests.get("https://search.com?page=" + page)<br/>    sleep(randint(2,5))</span></pre><p id="e3d6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这样你可以避免因为太快提出太多要求而被禁止。</p><h1 id="b17f" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">3.不要复制和粘贴可重用的代码</h1><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mt"><img src="../Images/c8a86c76c41d21534aa79d76146ead2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n4JbrLRwjeCPC-_by_v7Ow.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">来源:<a class="ae kf" href="https://medium.com/digital-identity/copy-paste-inc-d9a99f4a4b6a" rel="noopener">媒体</a></figcaption></figure><p id="44b6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我一直看到人们到处复制和粘贴他们的http验证代码逻辑。写一次就算了！这里有一个示例要点，您可以将其作为起点。边注要了解更多关于日志的信息，请查看我的文章。</p><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="mu mv l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">感谢<a class="mw mx ep" href="https://medium.com/u/17e1717e0029?source=post_page-----2cba2ebe5b29--------------------------------" rel="noopener" target="_blank">蒂姆·赖特</a>更好地执行了成功的请求！</figcaption></figure><p id="f88c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，您可以传入响应和boom！你要去比赛了。注意，为了我的缘故，我只在请求有问题时才返回False。这将使脚本越过该端点。这是因为当你刮擦时会发生很多事情，除非你更好地跟踪你的状态，只是继续前进，稍后再回来纠正。</p><p id="f9b6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是你如何利用这样的东西:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="0129" class="mm lf it mi b gy mn mo l mp mq">for url in url_list:    <br/>    response = requests.get(url)</span><span id="e82c" class="mm lf it mi b gy mr mo l mp mq">    if (successful_request(response)):<br/>        process_data(response)</span></pre><h1 id="4560" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">4.不要写单线程刮刀</h1><figure class="md me mf mg gt ju gh gi paragraph-image"><div class="gh gi my"><img src="../Images/21d65b76f50c547ad5504c734fd2ba96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*2hfLFTgpnwFxIseSD66SSA.jpeg"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">来源:<a class="ae kf" href="https://memegenerator.net/instance/73002845/captain-kirk-concentrating-scotty-i-need-more-threads" rel="noopener ugc nofollow" target="_blank">迷因生成器</a></figcaption></figure><p id="b1df" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">很快就从0到100了。我知道这听起来很有挑战性，但请听我说完。在第二步中，我们谈到了不要做网站。通过将您的工作分散到几个线程上，您因请求之间的随机超时而损失的时间可以弥补回来。我建议将每个域名放在一个线程上，以防止我们在步骤2中的工作被撤销。</p><p id="e1a4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在下面的例子中，我们抓取了4个网站。其中每一个都包含了我们想要抓取的10个URL的列表。这可能是这样的。</p><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="432f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面我们给了每个网站自己的线索。请注意，更多线程并不总是意味着更好的性能。这是因为所有这些线程都位于同一个内核上。我知道这令人困惑，但这是你在测试中可能会遇到的事情。</p><h1 id="e5ed" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">5.不要用同样的模式刮</h1><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/a1c38c93892b56251e1cd095d627e700.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NzxNbLSXmiDvth3zo4KJZQ.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">来源:<a class="ae kf" href="https://blog.carbonfive.com/pattern-matching-in-elixir-five-things-to-remember/" rel="noopener ugc nofollow" target="_blank">CarbonFive.com</a></figcaption></figure><p id="79a2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你反复做同样的事情，许多网站会禁止你。你可以使用一些策略来避免这种情况。</p><p id="443a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，打乱你访问网页的顺序。这里有一个用列表来做这件事的简单方法。一如既往地信任<a class="ae kf" href="https://stackoverflow.com/questions/9770668/scramble-python-list" rel="noopener ugc nofollow" target="_blank">加扰函数</a>的堆栈溢出。</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="23d8" class="mm lf it mi b gy mn mo l mp mq">import random<br/>url_list = ['fakesite.com/1', <br/>            'fakesite.com/2', <br/>            'fakesite.com/3']</span><span id="d097" class="mm lf it mi b gy mr mo l mp mq">def scrambled(orig):<br/>    dest = orig[:]<br/>    random.shuffle(dest)<br/>    return dest</span><span id="61ed" class="mm lf it mi b gy mr mo l mp mq">for url in scrambled(url_list):<br/>    # do something</span></pre><p id="f0e7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这样，我们就不会以相同的顺序访问资源。这样，我们就无法通过访问网站的方式被跟踪。如果你一次浏览几个网站，效果会更好。</p><p id="eff1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">逃避模式匹配的第二种方法是随机化您的用户代理。用户代理是您的系统向web服务器报告的内容。例如，chrome会将以下内容作为其用户代理发送回来:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="6bce" class="mm lf it mi b gy mn mo l mp mq"><a class="ae kf" href="https://developers.whatismybrowser.com/useragents/parse/1252728-chrome-windows-blink" rel="noopener ugc nofollow" target="_blank">Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.121 Safari/537.36</a></span></pre><p id="0e3d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里面有几条信息，比如浏览器版本等等。你可以在<a class="ae kf" href="https://developers.whatismybrowser.com/useragents/explore/" rel="noopener ugc nofollow" target="_blank">developers.whatismybrowser.com</a>上找到用户代理列表。随机化用户代理的例子可以在我的GitHub下的<a class="ae kf" href="https://github.com/dtaivpp/NewsTicker/blob/master/src/util/request_tools.py" rel="noopener ugc nofollow" target="_blank"> NewsTicker </a>项目中找到。参见get_random_ua函数。</p><p id="8958" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">避免模式检测的第三种方法是以随机的时间间隔运行您的脚本，使用您想要抓取的URL的随机子集。</p><h1 id="e92b" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="8748" class="pw-post-body-paragraph kg kh it ki b kj na kl km kn nb kp kq kr nc kt ku kv nd kx ky kz ne lb lc ld im bi translated">网页抓取不一定很难。你能为自己做的最好的事情是建立好的工具，你可以重复使用，你的网络抓取生活将会更加容易。如果你需要一个网页抓取项目的帮助，请随时在twitter上联系我，因为我正在做咨询。</p></div></div>    
</body>
</html>