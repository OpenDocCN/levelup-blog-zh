<html>
<head>
<title>Coding Problem: Validate Subsequence in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编码问题:在Go中验证子序列</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/coding-problem-validate-subsequence-in-go-e8e6af5a8054?source=collection_archive---------11-----------------------#2021-06-16">https://levelup.gitconnected.com/coding-problem-validate-subsequence-in-go-e8e6af5a8054?source=collection_archive---------11-----------------------#2021-06-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="89b7" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">让你的计算机科学基础在这个番茄大战中保持敏锐。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f8d3a9bc81e48fee0420c3e8847b0f1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*K2hr-2WZEbQE-qrr"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">来自<a class="ae ky" href="https://images.unsplash.com/photo-1520085601670-ee14aa5fa3e8?ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;ixlib=rb-1.2.1&amp;auto=format&amp;fit=crop&amp;w=1650&amp;q=80" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></figcaption></figure><p id="dcf4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">验证子序列问题是一个简单的问题，但是它引入了顺序的重要概念。这可以比作寻找一个数组的子集，其中顺序是不相关的。在这篇文章中，我们将理解后续问题本身，编写测试，并最终开发一个解决方案以及它的巨大的时间和空间复杂性。</p><p id="e19d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编码<a class="ae ky" href="https://todoist.com/productivity-methods/pomodoro-technique" rel="noopener ugc nofollow" target="_blank">番茄</a>现在开始！</p><p id="049d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> <em class="lv">注意:</em> </strong> <em class="lv">本文假设您知道如何设置Go工作区和安装程序依赖项。</em></p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="0af7" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">理解问题</h1><p id="e917" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">验证一个子序列需要输入两个独立的数组。其中一个数组是一个序列，而另一个数组是一组值，可能包含也可能不包含该序列。对于编码问题，写一些例子总是一个好的开始:</p><pre class="kj kk kl km gt na nb nc nd aw ne bi"><span id="973e" class="nf me it nb b gy ng nh l ni nj">Example #1<br/>array = [1,0,1]<br/>sequence = [1]<br/>result: true</span><span id="4b65" class="nf me it nb b gy nk nh l ni nj">Example #2<br/>array = [1,5,9]<br/>sequence = [9,5]<br/>result: false</span><span id="2bb5" class="nf me it nb b gy nk nh l ni nj">Example #3<br/>array = [1,4,-1,6,4,9,10]<br/>sequence = [1,-1,10]<br/>result: true</span></pre><p id="89c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你还能想到哪些基本案例？</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="ecb9" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">在Go中编写表格驱动的测试</h1><p id="cd9c" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">测试驱动开发(TDD)越来越受欢迎，因为它迫使你编写高度测试的最少代码。我发现提高你的TDD技能的最好方法之一是在你进入更标准的软件开发环境之前，先从这些编码问题开始。谢天谢地，Go拥有出色的内置测试支持。</p><p id="7497" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们导入了<code class="fe nl nm nn nb b">assert</code>和<code class="fe nl nm nn nb b">testing</code>包之后，我们创建了函数<code class="fe nl nm nn nb b">TestValidateSubsequence()</code>，它带有一个指向<code class="fe nl nm nn nb b">testing.T</code>对象的指针。从那里，我们可以启动一个结构体数组作为我们的测试用例，用四个字段来描述每个测试。我们总共定义了六个结构来涵盖验证子序列的主要情况，你还能想到别的吗？</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="936a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们定义了充当测试用例的结构数组之后，我们声明了一个<code class="fe nl nm nn nb b">for</code>循环来覆盖它们。我们获得一个单独的测试用例，然后我们调用<code class="fe nl nm nn nb b">t.Run()</code>来调用Go的测试包。我们也可以从内部调用<code class="fe nl nm nn nb b">t.Parallel()</code>来提升性能(只是培养好习惯)。接下来，我们通过向函数<code class="fe nl nm nn nb b">ValidateSubsequence()</code>提供当前测试用例的<code class="fe nl nm nn nb b">inputArray</code>和<code class="fe nl nm nn nb b">inputSequence</code>来获得函数<code class="fe nl nm nn nb b">ValidateSubsequence()</code>的结果。最后，我们断言我们的函数的结果是否和我们从测试用例中所期望的一样。</p><p id="c647" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Go拥有所有语言中最优雅和简单的测试方法，改变我的想法。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><h1 id="6351" class="md me it bd mf mg mh mi mj mk ml mm mn jz mo ka mp kc mq kd mr kf ms kg mt mu bi translated">解——O(N)时间和O(1)空间</h1><p id="1578" class="pw-post-body-paragraph kz la it lb b lc mv ju le lf mw jx lh li mx lk ll lm my lo lp lq mz ls lt lu im bi translated">我只提出一个单一的解决方案，因为没有太多的方法可以解决这个问题而不使其过于复杂。您不能使用double for循环来运行子序列的强力检查——这将是查找有效子集的有效解决方案，并且时间为O(N)。</p><p id="ef10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不管怎样，这个问题的解决方案很简短，但是当您需要查找或验证一个子序列时，它可以用于更复杂的问题。基本上，我们希望在移动到下一个元素之前，跟踪我们是否已经看到了序列中的每个元素。如果我们在数组中找到一个序列元素，那么我们可以增加到下一个序列元素，同时跟踪我们在数组中的位置。</p><p id="96bc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，首先我们为数组和序列初始化一个索引。然后，我们开始一个循环，如果任何一个索引超出了各自数组的范围，这个循环就会终止。我们首先检查当前数组元素是否等于当前序列元素。如果是，那么我们找到了一个序列元素匹配，并可以增加我们的序列索引。无论我们是否找到匹配，我们都必须增加数组索引来继续向前搜索。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="9953" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦循环终止，我们返回序列索引是否与原始序列的长度相同的布尔值。我们这样做是因为这可能是真的唯一方式是我们为每个序列元素找到一个有序匹配，因此我们将序列索引增加到序列本身的长度。</p><p id="992a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该算法的运行时间受限于<code class="fe nl nm nn nb b">array</code>的长度。这是因为序列只有在匹配的情况下才会递增，而我们总是递增<code class="fe nl nm nn nb b">array</code>索引。即使序列比数组长，一旦数组索引太大，我们也会终止。因此，我们的时间复杂度是O(N)，其中N是<code class="fe nl nm nn nb b">array</code>的长度。空间复杂度是常数O(1 ),因为我们不存储任何额外的数据结构。</p></div><div class="ab cl lw lx hx ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="im in io ip iq"><p id="4886" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望你喜欢阅读这篇文章，并能够学到一些新的东西。如果您发现任何部分特别有用，或者想要任何其他编码问题的教程，我鼓励您在下面留下评论！感谢阅读。</p></div></div>    
</body>
</html>