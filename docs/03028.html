<html>
<head>
<title>Building an Express API with Sequelize CLI and Unit Testing!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用序列CLI和单元测试构建Express API！</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/building-an-express-api-with-sequelize-cli-and-unit-testing-882c6875ed59?source=collection_archive---------2-----------------------#2020-04-16">https://levelup.gitconnected.com/building-an-express-api-with-sequelize-cli-and-unit-testing-882c6875ed59?source=collection_archive---------2-----------------------#2020-04-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/021463944331716371fec71e4ce6afef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fygqfizATFjt6ALek2W1jg.png"/></div></div></figure><p id="a535" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">单元测试对于软件开发人员来说是一个有用的习惯。对于任何代码可能变得更加复杂的项目，单元测试有助于确保应用程序的核心功能得到维护，即使发生了更改。</p><p id="cf2c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">即使对于相对小规模的Node.js应用程序，也可以通过使用像Jest和SuperTest这样的npm包来包含单元测试。在本演练中，我们将使用Sequelize和Express构建一个基本的API，然后添加单元测试以确保我们的CRUD端点保持不变。</p><h1 id="05bb" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">创建顺序化应用程序</h1><p id="9093" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">我们将尽快完成初始设置，以便进行单元测试——但是我们会在过程中为那些想了解更多有关使用Sequelize CLI with Express的人提供注释。</p><p id="71c2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们从安装Postgres、Sequelize和<a class="ae lz" href="https://github.com/sequelize/cli" rel="noopener ugc nofollow" target="_blank"> Sequelize CLI </a>开始，在一个新的项目文件夹中，我们称之为<code class="fe ma mb mc md b">express-api-unit-testing</code>:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="1d52" class="mm kx iq md b gy mn mo l mp mq">mkdir express-api-unit-testing<br/>cd express-api-unit-testing<br/>git init<br/>npm init -y &amp;&amp; npm i sequelize pg &amp;&amp; npm i --save-dev sequelize-cli</span></pre><p id="9bbe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们添加一个<code class="fe ma mb mc md b">.gitignore</code>文件，以便于以后的部署:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="fbf1" class="mm kx iq md b gy mn mo l mp mq">echo "<br/>/node_modules<br/>.DS_Store<br/>.env" &gt;&gt; .gitignore</span></pre><p id="76a1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们将初始化一个Sequelize项目，然后在代码编辑器中打开目录:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="97ec" class="mm kx iq md b gy mn mo l mp mq">npx sequelize-cli init<br/>code .</span></pre><blockquote class="mr ms mt"><p id="d51b" class="jy jz mu ka b kb kc kd ke kf kg kh ki mv kk kl km mw ko kp kq mx ks kt ku kv ij bi translated">要了解有关以下序列化CLI命令的更多信息，请参见:<br/> <a class="ae lz" href="https://medium.com/@brunopgalvao/getting-started-with-sequelize-cli-c33c797f05c6" rel="noopener"> <strong class="ka ir">序列化CLI入门</strong> </a></p></blockquote><p id="9ee1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们配置我们的Sequelize项目来使用Postgres数据库。在<code class="fe ma mb mc md b">/config</code>目录中找到<code class="fe ma mb mc md b">config.json</code>，并修改代码，如下所示:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="47f9" class="mm kx iq md b gy mn mo l mp mq">{<br/>  "development": {<br/>    "database": "wishlist_api_development",<br/>    "dialect": "postgres"<br/>  },<br/>  "test": {<br/>    "database": "wishlist_api_test",<br/>    "dialect": "postgres"<br/>  },<br/>  "production": {<br/>    "use_env_variable": "DATABASE_URL",<br/>    "dialect": "postgres",<br/>    "dialectOptions": {<br/>      "ssl": {<br/>        "rejectUnauthorized": false<br/>      }<br/>    }<br/>  }<br/>}</span></pre><blockquote class="mr ms mt"><p id="1732" class="jy jz mu ka b kb kc kd ke kf kg kh ki mv kk kl km mw ko kp kq mx ks kt ku kv ij bi translated">注:对于<code class="fe ma mb mc md b"><em class="iq">production</em></code>，我们使用<code class="fe ma mb mc md b"><em class="iq">use_env_variable</em></code>和<code class="fe ma mb mc md b"><em class="iq">DATABASE_URL</em></code>。我们将把这个应用程序部署到Heroku。Heroku很聪明，他用生产数据库取代了T7，我们将在稍后的<em class="iq"> r. </em>看到它的实际应用</p></blockquote><p id="2c0d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们可以告诉Sequelize CLI创建Postgres数据库:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="5e5c" class="mm kx iq md b gy mn mo l mp mq">npx sequelize-cli db:create</span></pre><h1 id="c8ae" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">定义模型和添加种子数据</h1><p id="4b79" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">我们的演示应用程序将用户与愿望清单上的项目相关联。让我们从使用Sequelize CLI创建一个<code class="fe ma mb mc md b">User</code>模型开始:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="2fca" class="mm kx iq md b gy mn mo l mp mq">npx sequelize-cli model:generate --name User --attributes firstName:string,lastName:string,email:string,password:string</span></pre><p id="3f2a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">运行<code class="fe ma mb mc md b">model:generate</code>会自动创建一个模型文件和一个带有我们指定属性的迁移。现在我们可以执行迁移，在数据库中创建<code class="fe ma mb mc md b">Users</code>表:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="f782" class="mm kx iq md b gy mn mo l mp mq">npx sequelize-cli db:migrate</span></pre><p id="862b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们创建一个种子文件:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="fac0" class="mm kx iq md b gy mn mo l mp mq">npx sequelize-cli seed:generate --name users</span></pre><p id="10fd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您将在<code class="fe ma mb mc md b">/seeders</code>目录中看到一个新文件。在该文件中，粘贴以下代码，这将在您的数据库中为三个用户创建条目:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="51af" class="mm kx iq md b gy mn mo l mp mq">module.exports = {<br/>  up: (queryInterface, Sequelize) =&gt; {<br/>    return queryInterface.bulkInsert('Users', [{<br/>      firstName: 'Bruno',<br/>      lastName: 'Doe',<br/>      email: 'bruno@doe.com',<br/>      password: '123456789',<br/>      createdAt: new Date(),<br/>      updatedAt: new Date()<br/>    },<br/>    {<br/>      firstName: 'Emre',<br/>      lastName: 'Smith',<br/>      email: 'emre@smith.com',<br/>      password: '123456789',<br/>      createdAt: new Date(),<br/>      updatedAt: new Date()<br/>    },<br/>    {<br/>      firstName: 'John',<br/>      lastName: 'Stone',<br/>      email: 'john@stone.com',<br/>      password: '123456789',<br/>      createdAt: new Date(),<br/>      updatedAt: new Date()<br/>    }], {});<br/>  },</span><span id="cd64" class="mm kx iq md b gy my mo l mp mq">  down: (queryInterface, Sequelize) =&gt; {<br/>    return queryInterface.bulkDelete('Users', null, {});<br/>  }<br/>};</span></pre><p id="9eb7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们的API中，这些用户中的每一个都可以有许多愿望清单项目。让我们创建一个<code class="fe ma mb mc md b">Item</code>模型，让这些用户有所期待:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="237b" class="mm kx iq md b gy mn mo l mp mq">npx sequelize-cli model:generate --name Item --attributes title:string,link:string,userId:integer</span></pre><p id="17e9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们将创建两个模型之间的关联。</p><blockquote class="mr ms mt"><p id="a011" class="jy jz mu ka b kb kc kd ke kf kg kh ki mv kk kl km mw ko kp kq mx ks kt ku kv ij bi translated">要了解有关创建序列关联的更多信息，请参阅:<br/> <a class="ae lz" href="https://medium.com/@brunopgalvao/creating-sequelize-associations-with-the-sequelize-cli-tool-d83caa902233" rel="noopener"> <strong class="ka ir">使用序列CLI创建序列关联</strong> </a></p></blockquote><p id="cad5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，在<code class="fe ma mb mc md b">/models</code>子目录中找到<code class="fe ma mb mc md b">item.js</code>，将代码替换为:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="1101" class="mm kx iq md b gy mn mo l mp mq">module.exports = (sequelize, DataTypes) =&gt; {<br/>  const Item = sequelize.define('Item', {<br/>    title: DataTypes.STRING,<br/>    link: DataTypes.STRING,<br/>    userId: {<br/>      type: DataTypes.INTEGER,<br/>      references: {<br/>        model: 'User',<br/>        key: 'id',<br/>        as: 'userId',<br/>      }<br/>    }<br/>  }, {});<br/>  Item.associate = function (models) {<br/>    // associations can be defined here<br/>    Item.belongsTo(models.User, {<br/>      foreignKey: 'userId',<br/>      onDelete: 'CASCADE'<br/>    })<br/>  };<br/>  return Item;<br/>};</span></pre><p id="8cd7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在在同一个目录中找到<code class="fe ma mb mc md b">user.js</code>,将代码替换为:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="5376" class="mm kx iq md b gy mn mo l mp mq">module.exports = (sequelize, DataTypes) =&gt; {<br/>  const User = sequelize.define('User', {<br/>    firstName: DataTypes.STRING,<br/>    lastName: DataTypes.STRING,<br/>    email: DataTypes.STRING,<br/>    password: DataTypes.STRING<br/>  }, {});<br/>  User.associate = function(models) {<br/>    // associations can be defined here<br/>    User.hasMany(models.Item, {<br/>      foreignKey: 'userId'<br/>    })<br/>  };<br/>  return User;<br/>};</span></pre><p id="9713" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">执行迁移以在Postgres数据库中创建<code class="fe ma mb mc md b">Items</code>表:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="e600" class="mm kx iq md b gy mn mo l mp mq">npx sequelize-cli db:migrate</span></pre><p id="1806" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们为我们的用户创建一些想要的项目:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="a15e" class="mm kx iq md b gy mn mo l mp mq">npx sequelize-cli seed:generate --name items</span></pre><p id="ddde" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您将在您的<code class="fe ma mb mc md b">/seeders</code>子目录中看到一个以<code class="fe ma mb mc md b">items.js</code>结尾的新文件。将该文件中的代码更改为以下内容:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="53d2" class="mm kx iq md b gy mn mo l mp mq">module.exports = {<br/>  up: (queryInterface, Sequelize) =&gt; {<br/>    return queryInterface.bulkInsert('Items', [{<br/>      title: 'Moped',<br/>      link: 'https://detroitmopedworks.com',<br/>      userId: 1,<br/>      createdAt: new Date(),<br/>      updatedAt: new Date()<br/>    },<br/>    {<br/>      title: 'iPad Mini',<br/>      link: 'https://www.apple.com/ipad-mini',<br/>      userId: 3,<br/>      createdAt: new Date(),<br/>      updatedAt: new Date()<br/>    },<br/>    {<br/>      title: 'Electric Scooter',<br/>      link: 'https://swagtron.com/electric-scooter',<br/>      userId: 1,<br/>      createdAt: new Date(),<br/>      updatedAt: new Date()<br/>    },<br/>    {<br/>      title: 'Monitor',<br/>      link: 'https://www.asus.com/us/Monitors/MB168B',<br/>      userId: 2,<br/>      createdAt: new Date(),<br/>      updatedAt: new Date()<br/>    }], {});<br/>  },</span><span id="df77" class="mm kx iq md b gy my mo l mp mq">  down: (queryInterface, Sequelize) =&gt; {<br/>    return queryInterface.bulkDelete('Items', null, {});<br/>  }<br/>};</span></pre><p id="9d39" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们将运行两个种子文件，将我们的用户和我们的意愿列表项目添加到数据库中:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="2816" class="mm kx iq md b gy mn mo l mp mq">npx sequelize-cli db:seed:all</span></pre><p id="922e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">确保数据存在于数据库中:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="1a51" class="mm kx iq md b gy mn mo l mp mq">psql wishlist_api_development<br/>SELECT * FROM "Users" JOIN "Items" ON "Users".id = "Items"."userId";</span></pre><h1 id="3405" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">设置Express</h1><p id="6033" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">太好了，我们的项目已经准备好了。现在，我们可以合并Express并设置路由来服务我们的数据。首先，让我们安装Express，连同<a class="ae lz" href="https://nodemon.io/" rel="noopener ugc nofollow" target="_blank"> nodemon </a>来监控我们文件中的变化，以及<a class="ae lz" href="https://www.npmjs.com/package/body-parser" rel="noopener ugc nofollow" target="_blank"> body-parser </a>来处理来自用户请求的信息:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="7a5d" class="mm kx iq md b gy mn mo l mp mq">npm install express --save<br/>npm install nodemon -D<br/>npm install body-parser</span></pre><p id="273b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，让我们通过创建两个新目录和三个新文件来设置体系结构:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="3178" class="mm kx iq md b gy mn mo l mp mq">mkdir routes controllers<br/>touch server.js  routes/index.js controllers/index.js</span></pre><p id="b436" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们将修改<code class="fe ma mb mc md b">package.json</code>文件来支持nodemon。此外，我们可以通过创建一个新命令来促进开发:<code class="fe ma mb mc md b">npm run db:reset</code>。我们将设置删除数据库、创建数据库、运行迁移，并在需要时重新播种！</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="12e0" class="mm kx iq md b gy mn mo l mp mq">....<br/>  "scripts": {<br/>    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1",<br/>    "start": "nodemon server.js",<br/>    "db:reset": "npx sequelize-cli db:drop &amp;&amp; npx sequelize-cli db:create &amp;&amp; npx sequelize-cli db:migrate &amp;&amp; npx sequelize-cli db:seed:all"<br/>  },<br/>....</span></pre><p id="6099" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们开始构建我们的Express应用程序。在<code class="fe ma mb mc md b">server.js</code>文件中，添加以下内容:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="0e77" class="mm kx iq md b gy mn mo l mp mq">const express = require('express');<br/>const routes = require('./routes');<br/>const bodyParser = require('body-parser')</span><span id="5726" class="mm kx iq md b gy my mo l mp mq">const PORT = process.env.PORT || 3000;</span><span id="7344" class="mm kx iq md b gy my mo l mp mq">const app = express();</span><span id="dc20" class="mm kx iq md b gy my mo l mp mq">app.use(bodyParser.json())</span><span id="cfab" class="mm kx iq md b gy my mo l mp mq">app.use('/api', routes);</span><span id="15c1" class="mm kx iq md b gy my mo l mp mq">app.listen(PORT, () =&gt; console.log(`Listening on port: ${PORT}`))</span></pre><p id="3d6c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这里，我们创建了一个基本的Express服务器集来监听端口3000。但是我们没有在这个文件中定义路由，而是添加了<code class="fe ma mb mc md b">app.use('/api', routes)</code>来引用任何以<code class="fe ma mb mc md b">api</code>开头的请求到我们的<code class="fe ma mb mc md b">/routes</code>子目录中的<code class="fe ma mb mc md b">index.js</code>文件。</p><blockquote class="mr ms mt"><p id="7e60" class="jy jz mu ka b kb kc kd ke kf kg kh ki mv kk kl km mw ko kp kq mx ks kt ku kv ij bi translated">要了解更多有关序列式快速基本设置的信息，请参见:<br/> <a class="ae lz" rel="noopener ugc nofollow" target="_blank" href="/sequelize-cli-and-express-fb3ddefb9786"> <strong class="ka ir">序列式CLI和快速</strong> </a></p></blockquote><h1 id="162d" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">快速路由器和控制器</h1><p id="3516" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">我们将从设置根路由开始。打开<code class="fe ma mb mc md b">./routes/index.js</code>文件并添加以下代码:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="b1f9" class="mm kx iq md b gy mn mo l mp mq">const { Router } = require('express');<br/>const controllers = require('../controllers');<br/>const router = Router();</span><span id="c18a" class="mm kx iq md b gy my mo l mp mq">router.get('/', (req, res) =&gt; res.send('This is root!'))</span><span id="d128" class="mm kx iq md b gy my mo l mp mq">module.exports = router</span></pre><p id="1dcb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">测试路线:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="5a9f" class="mm kx iq md b gy mn mo l mp mq">npm start</span></pre><p id="94d6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在在浏览器中打开根端点:<a class="ae lz" href="http://localhost:3000/api/" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/API/</a></p><p id="8a6e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">很好，我们的Express应用程序可以工作，但现在我们需要让它从Sequelize中传递数据。我们将通过创建一个控制器来处理我们所有的逻辑——我们创建新用户和项目、更新用户等的途径。</p><blockquote class="mr ms mt"><p id="04ab" class="jy jz mu ka b kb kc kd ke kf kg kh ki mv kk kl km mw ko kp kq mx ks kt ku kv ij bi translated">要了解更多有关使用带序列和快速路由器的控制器的信息，请参见:<br/> <a class="ae lz" rel="noopener ugc nofollow" target="_blank" href="/build-an-express-api-with-sequelize-cli-and-express-router-963b6e274561"> <strong class="ka ir">使用序列和快速路由器构建快速API</strong></a></p></blockquote><p id="fe20" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在打开<code class="fe ma mb mc md b">./controllers/index.js</code>并添加以下内容:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="931d" class="mm kx iq md b gy mn mo l mp mq">const { User } = require('../models');</span><span id="09f3" class="mm kx iq md b gy my mo l mp mq">const createUser = async (req, res) =&gt; {<br/>    try {<br/>        const user = await User.create(req.body);<br/>        return res.status(201).json({<br/>            user,<br/>        });<br/>    } catch (error) {<br/>        return res.status(500).json({ error: error.message })<br/>    }<br/>}</span><span id="29e5" class="mm kx iq md b gy my mo l mp mq">module.exports = {<br/>    createUser<br/>}</span></pre><p id="2252" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里，我们结合了在Sequelize中定义的<code class="fe ma mb mc md b">User</code>模型，根据API请求中的信息创建一个新的数据库条目。为了实现这一点，我们将在服务器上创建一个路由来连接请求和控制器:</p><p id="9d18" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<code class="fe ma mb mc md b">./routes/index.js</code>中，在您的“这是root！”后添加新的一行路线:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="c5a8" class="mm kx iq md b gy mn mo l mp mq">router.post('/users', controllers.createUser)</span></pre><p id="8992" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这将<code class="fe ma mb mc md b">/api/users</code>处的<code class="fe ma mb mc md b">POST</code>请求导向我们控制器中的<code class="fe ma mb mc md b">createUser</code>功能。为了测试它，你需要使用一个REST客户端(比如<a class="ae lz" href="https://www.postman.com/" rel="noopener ugc nofollow" target="_blank">邮递员</a>或者<a class="ae lz" href="https://insomnia.rest/" rel="noopener ugc nofollow" target="_blank">失眠</a>)。使用<code class="fe ma mb mc md b">POST</code>方法将下面的JSON主体发送到<a class="ae lz" href="http://localhost:3000/api/users" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/API/users</a>:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="a712" class="mm kx iq md b gy mn mo l mp mq">{<br/>  "firstName": "Jane",<br/>  "lastName": "Smith",<br/>  "email": "jane@smith.com",<br/>  "password": "123456789"<br/>}</span></pre><p id="95c7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以现在我们已经使用路由器和控制器将数据从Sequelize传递给我们的API用户。我们可以使用相同的策略将任何顺序查询连接到一个Express端点。</p><blockquote class="mr ms mt"><p id="4b82" class="jy jz mu ka b kb kc kd ke kf kg kh ki mv kk kl km mw ko kp kq mx ks kt ku kv ij bi translated">要了解有关自定义序列查询的更多信息，请参见:<a class="ae lz" rel="noopener ugc nofollow" target="_blank" href="/using-the-sequelize-cli-and-querying-4ba8d0ac4314"> <strong class="ka ir">使用序列CLI和查询</strong> </a></p></blockquote><p id="93ba" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们添加控制器来执行另外四个任务:获取所有用户及其相关的意愿列表项、获取特定用户和意愿列表、更新用户和删除用户。</p><p id="3e57" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">用以下内容替换您当前在<code class="fe ma mb mc md b">./controllers/index.js</code>中的内容:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="89a5" class="mm kx iq md b gy mn mo l mp mq">const { User, Item } = require('../models');</span><span id="adc7" class="mm kx iq md b gy my mo l mp mq">const createUser = async (req, res) =&gt; {<br/>    try {<br/>        const user = await User.create(req.body);<br/>        return res.status(201).json({<br/>            user,<br/>        });<br/>    } catch (error) {<br/>        return res.status(500).json({ error: error.message })<br/>    }<br/>}</span><span id="34f6" class="mm kx iq md b gy my mo l mp mq">const getAllUsers = async (req, res) =&gt; {<br/>    try {<br/>        const users = await User.findAll({<br/>            include: [<br/>                {<br/>                    model: Item<br/>                }<br/>            ]<br/>        });<br/>        return res.status(200).json({ users });<br/>    } catch (error) {<br/>        return res.status(500).send(error.message);<br/>    }<br/>}</span><span id="c70d" class="mm kx iq md b gy my mo l mp mq">const getUserById = async (req, res) =&gt; {<br/>    try {<br/>        const { id } = req.params;<br/>        const user = await User.findOne({<br/>            where: { id: id },<br/>            include: [<br/>                {<br/>                    model: Item<br/>                }<br/>            ]<br/>        });<br/>        if (user) {<br/>            return res.status(200).json({ user });<br/>        }<br/>        return res.status(404).send('User with the specified ID does not exists');<br/>    } catch (error) {<br/>        return res.status(500).send(error.message);<br/>    }<br/>}</span><span id="9937" class="mm kx iq md b gy my mo l mp mq">const updateUser = async (req, res) =&gt; {<br/>    try {<br/>        const { id } = req.params;<br/>        const [updated] = await User.update(req.body, {<br/>            where: { id: id }<br/>        });<br/>        if (updated) {<br/>            const updatedUser = await User.findOne({ where: { id: id } });<br/>            return res.status(200).json({ user: updatedUser });<br/>        }<br/>        throw new Error('User not found');<br/>    } catch (error) {<br/>        return res.status(500).send(error.message);<br/>    }<br/>};</span><span id="d97b" class="mm kx iq md b gy my mo l mp mq">const deleteUser = async (req, res) =&gt; {<br/>    try {<br/>        const { id } = req.params;<br/>        const deleted = await User.destroy({<br/>            where: { id: id }<br/>        });<br/>        if (deleted) {<br/>            return res.status(204).send("User deleted");<br/>        }<br/>        throw new Error("User not found");<br/>    } catch (error) {<br/>        return res.status(500).send(error.message);<br/>    }<br/>};</span><span id="6336" class="mm kx iq md b gy my mo l mp mq">module.exports = {<br/>    createUser,<br/>    getAllUsers,<br/>    getUserById,<br/>    updateUser,<br/>    deleteUser<br/>}</span></pre><p id="dd69" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们还将设置每条路线来击中正确的控制器。将<code class="fe ma mb mc md b">/routes/index.js</code>文件更改为如下所示:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="59bd" class="mm kx iq md b gy mn mo l mp mq">const { Router } = require('express');<br/>const controllers = require('../controllers')<br/>const router = Router();</span><span id="bfa1" class="mm kx iq md b gy my mo l mp mq">router.get('/', (req, res) =&gt; res.send('This is root!'))</span><span id="28e0" class="mm kx iq md b gy my mo l mp mq">router.post('/users', controllers.createUser)<br/>router.get('/users', controllers.getAllUsers)<br/>router.get('/users/:id', controllers.getUserById)<br/>router.put('/users/:id', controllers.updateUser)<br/>router.delete('/users/:id', controllers.deleteUser)</span><span id="7251" class="mm kx iq md b gy my mo l mp mq">module.exports = router;</span></pre><p id="3886" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">测试这些端点中的一些，在Postman中发出<code class="fe ma mb mc md b">GET</code>、<code class="fe ma mb mc md b">POST</code>、<code class="fe ma mb mc md b">PUT</code>或<code class="fe ma mb mc md b">DELETE</code>请求，以及每个端点的适当请求体。例如，在<a class="ae lz" href="http://localhost:3000/users/3" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/users/3</a>上的<code class="fe ma mb mc md b">PUT</code>请求的主体可能如下所示:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="df43" class="mm kx iq md b gy mn mo l mp mq">{<br/>    "firstName": "Johnny",<br/>    "lastName": "Stone",<br/>    "email": "john.e@stone.com"<br/>}</span></pre><p id="3f45" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您的手动测试进展顺利，是时候开始构建自动化单元测试了！</p><h1 id="8001" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">记录</h1><p id="323b" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">不过，首先，这是集成更好的日志记录的好时机。现在，如果我们在点击<a class="ae lz" href="http://localhost:3000/api/users/2" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/API/users/2</a>端点时检查我们的终端，我们将看到被执行的原始SQL。出于调试目的和更好的日志记录，让我们安装一个名为<a class="ae lz" href="https://www.npmjs.com/package/morgan" rel="noopener ugc nofollow" target="_blank"> morgan </a>的快速中间件:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="e6a2" class="mm kx iq md b gy mn mo l mp mq">npm install morgan</span></pre><p id="4265" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">修改您的<code class="fe ma mb mc md b">server.js</code>文件以使用Morgan(并添加<code class="fe ma mb mc md b">module.exports = app</code>，我们将在稍后的测试中使用):</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="8b31" class="mm kx iq md b gy mn mo l mp mq">const express = require('express');<br/>const bodyParser = require('body-parser');<br/>const logger = require('morgan');</span><span id="27f5" class="mm kx iq md b gy my mo l mp mq">const routes = require('./routes');</span><span id="0dcd" class="mm kx iq md b gy my mo l mp mq">const PORT = process.env.PORT || 3000;</span><span id="9088" class="mm kx iq md b gy my mo l mp mq">const app = express();<br/>app.use(bodyParser.json())<br/>app.use(logger('dev'))</span><span id="c0d4" class="mm kx iq md b gy my mo l mp mq">app.use('/api', routes);</span><span id="2b57" class="mm kx iq md b gy my mo l mp mq">app.listen(PORT, () =&gt; console.log(`Listening on port: ${PORT}`))</span><span id="a022" class="mm kx iq md b gy my mo l mp mq">module.exports = app</span></pre><p id="d815" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们看看结果:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="b206" class="mm kx iq md b gy mn mo l mp mq">npm start<br/>open <a class="ae lz" href="http://localhost:3000/api/users/2" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/api/users/2</a></span></pre><p id="5107" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，您应该在终端中看到类似这样的内容:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="5f5b" class="mm kx iq md b gy mn mo l mp mq">GET /api/users/2 304 104.273 ms</span></pre><p id="addf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那是摩根。</p><h1 id="f871" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">单元测试</h1><p id="98a7" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">现在我们将为单元测试配置Express JSON API。让我们安装<a class="ae lz" href="https://jestjs.io/" rel="noopener ugc nofollow" target="_blank">Jest</a>——一个令人愉快的专注于简单性的JavaScript测试框架:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="de75" class="mm kx iq md b gy mn mo l mp mq">npm install jest --save-dev</span></pre><p id="a33d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们还将使用<a class="ae lz" href="https://github.com/visionmedia/supertest#readme" rel="noopener ugc nofollow" target="_blank">超级测试</a>在我们的Express API上测试我们的HTTP端点:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="7c4f" class="mm kx iq md b gy mn mo l mp mq">npm install supertest --save-dev</span></pre><p id="5bd3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们需要在<code class="fe ma mb mc md b">package.json</code>中做两处修改来配置Jest。首先，在<code class="fe ma mb mc md b">"scripts"</code>属性下，让我们编辑我们的测试命令以使用Jest:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="090f" class="mm kx iq md b gy mn mo l mp mq">...<br/>"test": "jest",<br/>...</span></pre><p id="a9ba" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们需要Jest忽略我们的<code class="fe ma mb mc md b">./node_modules</code>文件夹，所以我们还需要添加以下代码片段:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="78ff" class="mm kx iq md b gy mn mo l mp mq">....<br/> "jest": {<br/>    "testEnvironment": "node",<br/>    "coveragePathIgnorePatterns": [<br/>      "/node_modules/"<br/>    ]<br/>  },<br/>....</span></pre><p id="ebf3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">太好了！让我们编写一个简单的测试来确保我们的设置有效。首先，我们将为我们的测试创建一个新目录，然后我们将创建一个名为<code class="fe ma mb mc md b">base.test.js</code>的文件:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="b393" class="mm kx iq md b gy mn mo l mp mq">mkdir tests<br/>touch tests/base.test.js</span></pre><p id="33f2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在在<code class="fe ma mb mc md b">base.test.js</code>中添加以下代码，以创建一个测试1 + 1是否等于2的测试:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="ec71" class="mm kx iq md b gy mn mo l mp mq">describe('Initial Test', () =&gt; {<br/>  it('should test that 1 + 1 === 2', () =&gt; {<br/>    expect(1+1).toBe(2)<br/>  })<br/>})</span></pre><p id="0f4c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">看一下这里的语法。我们传递字符串给测试一个标题，并描述它做什么。然后，如果传递给<code class="fe ma mb mc md b">expect()</code>的表达式评估为<code class="fe ma mb mc md b">.toBe()</code>内的值，测试将通过。让我们确保我们的设置工作正常:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="2c1a" class="mm kx iq md b gy mn mo l mp mq">npm test</span></pre><p id="9707" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好吧，那就放心了！Jest帮我们查了一下，原来<code class="fe ma mb mc md b">1+1</code>T19等于<code class="fe ma mb mc md b">2</code>。很快我们将开始把笑话付诸实践。</p><h1 id="655d" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">设置测试环境</h1><p id="c8e4" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">首先，我们需要设置我们的测试脚本来使用测试数据库——让我们的测试操作我们的真实数据不是一个好主意。我们将通过使用一个名为<a class="ae lz" href="https://www.npmjs.com/package/cross-env" rel="noopener ugc nofollow" target="_blank">跨环境</a>的npm包来安排:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="29d9" class="mm kx iq md b gy mn mo l mp mq">npm install cross-env --save-dev</span></pre><p id="69df" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Cross-env允许我们在npm脚本中传递环境变量，在本例中，我们将使用这些变量来指定测试环境。让我们再次配置我们的<code class="fe ma mb mc md b">package.json</code>的<code class="fe ma mb mc md b">“scripts”</code>部分来做到这一点:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="8efe" class="mm kx iq md b gy mn mo l mp mq">"test": "cross-env NODE_ENV=test jest --testTimeout=10000",<br/>"pretest": "cross-env NODE_ENV=test npm run db:reset",<br/>"db:create:test": "cross-env NODE_ENV=test npx sequelize-cli db:create",</span></pre><p id="6e6e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">试试看。</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="3297" class="mm kx iq md b gy mn mo l mp mq">npm run db:create:test<br/>npm test</span></pre><p id="f70c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在运行测试之前,<code class="fe ma mb mc md b">pretest</code>脚本会重新构建测试数据库——使用<code class="fe ma mb mc md b">NODE_ENV=test</code>可以让我们的脚本在不改变正常数据库的情况下完成所有工作。除此之外，您的终端还应该显示我们在Jest中的基本测试已经通过。</p><h1 id="bea4" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">用Jest和SuperTest编写测试</h1><p id="a964" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">是时候编写我们的第一个路由测试了。让我们为路由创建一个测试文件:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="135a" class="mm kx iq md b gy mn mo l mp mq">touch tests/routes.test.js</span></pre><p id="3ced" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将使用Jest框架编写这个程序，并使用SuperTest调用HTTP方法。</p><p id="6a83" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们测试一下<code class="fe ma mb mc md b">/api/users</code>端点。当我们向该端点发出一个<code class="fe ma mb mc md b">GET</code>请求时，我们应该得到数据库中所有用户的列表，对吗？打开<code class="fe ma mb mc md b">tests/routes.test.js</code>并添加以下代码:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="4783" class="mm kx iq md b gy mn mo l mp mq">const request = require('supertest')<br/>const app = require('../server.js')</span><span id="37fc" class="mm kx iq md b gy my mo l mp mq">describe('User API', () =&gt; {<br/>    it('should show all users', async () =&gt; {<br/>        const res = await request(app).get('/api/users')<br/>        expect(res.statusCode).toEqual(200)<br/>        expect(res.body).toHaveProperty('users')<br/>    }),<br/>})</span></pre><p id="770e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">测试一下！</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="470f" class="mm kx iq md b gy mn mo l mp mq">npm test</span></pre><p id="7540" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，您应该在两个测试套件中看到两个通过的测试。</p><p id="af24" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们将向同一个<code class="fe ma mb mc md b">User API</code>测试套件添加另一个测试，这个测试是针对<code class="fe ma mb mc md b">/api/users/3</code>端点的。在这个端点，<code class="fe ma mb mc md b">GET</code>请求应该从数据库返回一个特定的用户。在<code class="fe ma mb mc md b">tests/routes.test.js</code>中，将以下内容添加到先前测试的正下方:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="a199" class="mm kx iq md b gy mn mo l mp mq">    it('should show a user', async () =&gt; {<br/>        const res = await request(app).get('/api/users/3')<br/>        expect(res.statusCode).toEqual(200)<br/>        expect(res.body).toHaveProperty('user')<br/>    }),</span></pre><p id="ac4a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">测试一下！</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="6c49" class="mm kx iq md b gy mn mo l mp mq">npm test</span></pre><p id="a5e8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以为API的其他方面编写更多的测试。下面的代码包括在我们的应用中创建、更新和删除用户的测试:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="32b0" class="mm kx iq md b gy mn mo l mp mq">const request = require('supertest')<br/>const app = require('../server.js')</span><span id="a080" class="mm kx iq md b gy my mo l mp mq">describe('User API', () =&gt; {<br/>    it('should show all users', async () =&gt; {<br/>        const res = await request(app).get('/api/users')<br/>        expect(res.statusCode).toEqual(200)<br/>        expect(res.body).toHaveProperty('users')<br/>    }),</span><span id="270f" class="mm kx iq md b gy my mo l mp mq">    it('should show a user', async () =&gt; {<br/>        const res = await request(app).get('/api/users/3')<br/>        expect(res.statusCode).toEqual(200)<br/>        expect(res.body).toHaveProperty('user')<br/>    }),</span><span id="5106" class="mm kx iq md b gy my mo l mp mq">    it('should create a new user', async () =&gt; {<br/>        const res = await request(app)<br/>            .post('/api/users')<br/>            .send({<br/>                firstName: 'Bob',<br/>                lastName: 'Doe',<br/>                email: 'bob@doe.com',<br/>                password: '12345678'<br/>            })<br/>        expect(res.statusCode).toEqual(201)<br/>        expect(res.body).toHaveProperty('user')<br/>    }),</span><span id="107e" class="mm kx iq md b gy my mo l mp mq">    it('should update a user', async () =&gt; {<br/>        const res = await request(app)<br/>            .put('/api/users/3')<br/>            .send({<br/>                firstName: 'Bob',<br/>                lastName: 'Smith',<br/>                email: 'bob@doe.com',<br/>                password: 'abc123'<br/>            })<br/>        expect(res.statusCode).toEqual(200)<br/>        expect(res.body).toHaveProperty('user')<br/>    }),</span><span id="c8b3" class="mm kx iq md b gy my mo l mp mq">    it('should delete a user', async () =&gt; {<br/>        const res = await request(app)<br/>            .del('/api/users/3')<br/>        expect(res.statusCode).toEqual(204)<br/>    })<br/>})</span></pre><p id="f72c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您将看到新的测试使用了<code class="fe ma mb mc md b">.post()</code>、<code class="fe ma mb mc md b">.put()</code>和<code class="fe ma mb mc md b">.del()</code>方法，并且测试请求的主体可以在<code class="fe ma mb mc md b">.send()</code>中定义。</p><blockquote class="mr ms mt"><p id="ac36" class="jy jz mu ka b kb kc kd ke kf kg kh ki mv kk kl km mw ko kp kq mx ks kt ku kv ij bi translated">我们的每个示例测试都使用Jest的<code class="fe ma mb mc md b">.toEqual()</code>和/或<code class="fe ma mb mc md b">.toHaveProperty()</code>方法。要查看其他Jest“匹配者”，<a class="ae lz" href="https://jestjs.io/docs/en/expect" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">查看Jest文档</strong> </a>。</p></blockquote><p id="b588" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">运行测试:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="a7fc" class="mm kx iq md b gy mn mo l mp mq">npm test</span></pre><p id="d908" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您应该在两个套件中看到六个通过的测试。我们现在有了Express API的测试覆盖率！</p><blockquote class="mr ms mt"><p id="fcd0" class="jy jz mu ka b kb kc kd ke kf kg kh ki mv kk kl km mw ko kp kq mx ks kt ku kv ij bi translated">本文是与纽约市的软件工程师、编辑和作家杰里米·罗斯(Jeremy Rose)合著的。</p></blockquote><h1 id="a471" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">有关Sequelize CLI和Express的更多信息:</h1><ul class=""><li id="8dc1" class="mz na iq ka b kb lu kf lv kj nb kn nc kr nd kv ne nf ng nh bi translated">【Sequelize CLI入门</li><li id="a3bb" class="mz na iq ka b kb ni kf nj kj nk kn nl kr nm kv ne nf ng nh bi translated"><a class="ae lz" href="https://medium.com/@brunopgalvao/using-the-sequelize-cli-and-querying-4ba8d0ac4314" rel="noopener">使用顺序化CLI并查询</a></li><li id="2b97" class="mz na iq ka b kb ni kf nj kj nk kn nl kr nm kv ne nf ng nh bi translated"><a class="ae lz" href="https://medium.com/@brunopgalvao/creating-sequelize-associations-with-the-sequelize-cli-tool-d83caa902233" rel="noopener">使用序列CLI创建序列关联</a></li><li id="d3e6" class="mz na iq ka b kb ni kf nj kj nk kn nl kr nm kv ne nf ng nh bi translated"><a class="ae lz" rel="noopener ugc nofollow" target="_blank" href="/getting-started-with-sequelize-cli-using-faker-824b3f4c4cfe">使用Faker开始Sequelize CLI</a></li><li id="fa92" class="mz na iq ka b kb ni kf nj kj nk kn nl kr nm kv ne nf ng nh bi translated"><a class="ae lz" href="https://medium.com/@brunopgalvao/sequelize-cli-and-express-fb3ddefb9786" rel="noopener">对CLI和Express进行排序</a></li><li id="4e0e" class="mz na iq ka b kb ni kf nj kj nk kn nl kr nm kv ne nf ng nh bi translated"><a class="ae lz" rel="noopener ugc nofollow" target="_blank" href="/build-an-express-api-with-sequelize-cli-and-express-router-963b6e274561">使用序列CLI和快速路由器构建快速API</a></li></ul></div></div>    
</body>
</html>