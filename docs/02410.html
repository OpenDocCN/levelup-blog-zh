<html>
<head>
<title>EventBus in Java: Publish/Subscribe to the Rescue!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java中的EventBus:发布/订阅拯救！</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/eventbus-in-java-publish-subscribe-to-the-rescue-ca0505cb53b1?source=collection_archive---------1-----------------------#2020-03-11">https://levelup.gitconnected.com/eventbus-in-java-publish-subscribe-to-the-rescue-ca0505cb53b1?source=collection_archive---------1-----------------------#2020-03-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="5bd4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">任何需要发布/订阅架构的人都会发现EventBus是一个很好的工具。它很容易使用，并且有许多实现。但是我们应该小心，因为滥用这样的库可能会导致意想不到的后果。</p><p id="bc1d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本文中，我将重点介绍Greenbot对EventBus的实现。Guava也提供了自己的解决方案，但是无论我们在看哪个库，它们的使用都非常相似。</p><h1 id="81a8" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">什么是EventBus？</h1><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi lj"><img src="../Images/a242e3a81c7fa39248fcd173e87634b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h9fw9-AbGIqjEskbK-Rf6A.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated">EventBus提供了一个简单的API来向注册用户传递事件。</figcaption></figure><p id="d38d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">EventBus是一个软件总线，它允许您注册某些事件，并在与该事件相关的内容发布时得到通知。事件以类的形式出现。首先，将您的类注册到总线，然后定义使用<strong class="jp ir"> Subscribe </strong>注释的方法，以便注册到事件。您可以定制EventBus，甚至可以创建多个事件总线实例，但是为了简单起见，我们现在将使用默认的实例。</p><figure class="lk ll lm ln gt lo"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="a535" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在订阅了<strong class="jp ir"> TemperatureUpdateEvent </strong>之后，每当有人发布该事件时，就会调用您注册的方法。事件以下列方式发布:</p><blockquote class="mb mc md"><p id="021c" class="jn jo me jp b jq jr js jt ju jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj kk ij bi translated"><strong class="jp ir"> EventBus.getDefault()。post(新的温度更新事件(15.7))；</strong></p></blockquote><p id="d93c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦不再需要注册的类，就需要从EventBus中注销。如果没有取消注册，EventBus将保留对您的对象的引用，这将防止它被垃圾收集。在Android的片段/活动中取消注册很容易，因为它们有自己的生命周期方法，如onStop/onDestroy，它们提供了一个取消注册的好地方。然而，对于普通的java类，您可能需要将注册的责任交给另一个类。</p><blockquote class="mb mc md"><p id="1339" class="jn jo me jp b jq jr js jt ju jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj kk ij bi translated"><strong class="jp ir"> EventBus.getDefault()。注销(这个)；</strong></p></blockquote><h1 id="67c3" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">EventBus线程模式</h1><p id="7560" class="pw-post-body-paragraph jn jo iq jp b jq mi js jt ju mj jw jx jy mk ka kb kc ml ke kf kg mm ki kj kk ij bi translated">Greenbot的EventBus库中有5种线程模式。其中3个是安卓特有的(与UI线程相关)。</p><ul class=""><li id="804c" class="mn mo iq jp b jq jr ju jv jy mp kc mq kg mr kk ms mt mu mv bi translated">发布-这是默认的线程模式。事件被传递给发布者线程中的所有订阅者。</li><li id="c8ce" class="mn mo iq jp b jq mw ju mx jy my kc mz kg na kk ms mt mu mv bi translated">MAIN——在Android的UI线程中调用订阅者。这对于小的UI更新来说非常好。</li><li id="e5b6" class="mn mo iq jp b jq mw ju mx jy my kc mz kg na kk ms mt mu mv bi translated">MAIN_ORDERED —假设您当前正在主线程中执行某个操作，如果您再次发布事件，将立即调用指定主线程模式的订阅者，就像方法调用一样。但是如果订阅者的线程模式恰好是thread mode。MAIN_ORDERED，订户的事件交付将简单地排队，您将继续执行您正在做的任何事情。一段时间后，当UI线程再次可用时，排队的事件将被执行。</li><li id="18e0" class="mn mo iq jp b jq mw ju mx jy my kc mz kg na kk ms mt mu mv bi translated">背景—在Java上，这基本上与发布模式是一回事。但是在Android上如果发帖线程是主线程，它会排队等待EventBus的后台线程执行。</li><li id="de15" class="mn mo iq jp b jq mw ju mx jy my kc mz kg na kk ms mt mu mv bi translated">ASYNC —所有事情都在单独的线程上处理。这是完全异步的，所以发布线程不会等待任何东西。它可用于耗时的任务，如网络操作。使用过多的异步可能会导致性能问题。</li></ul><figure class="lk ll lm ln gt lo"><div class="bz fp l di"><div class="lz ma l"/></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated">Greenbot EventBus线程模式</figcaption></figure><h1 id="cdb1" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">棘手事件</h1><p id="6388" class="pw-post-body-paragraph jn jo iq jp b jq mi js jt ju mj jw jx jy mk ka kb kc ml ke kf kg mm ki kj kk ij bi translated">有时，您希望您的对象接收在创建之前发布的事件。在这种情况下，可以使用粘性事件来接收最后发布的事件。您可以选择自动或手动接收。</p><blockquote class="mb mc md"><p id="2159" class="jn jo me jp b jq jr js jt ju jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj kk ij bi translated"><strong class="jp ir"> EventBus.getDefault()。postSticky(新时区变化事件(" GMT "))；</strong></p></blockquote><figure class="lk ll lm ln gt lo"><div class="bz fp l di"><div class="lz ma l"/></div></figure><h1 id="9162" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">当心！事件交付顺序可能不是你想的那样！</h1><p id="703b" class="pw-post-body-paragraph jn jo iq jp b jq mi js jt ju mj jw jx jy mk ka kb kc ml ke kf kg mm ki kj kk ij bi translated">您可能认为至少在默认发布模式下，嵌套事件会像函数调用一样工作。不对！</p><p id="d1fc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你的当前线程还没有发布一些东西，它确实像一个函数调用一样工作。但如果是，嵌套的post会在前一个post完成后执行。</p><p id="e7aa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们检查以下代码:</p><figure class="lk ll lm ln gt lo"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="4610" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们假设它像常规函数调用一样工作，您将会看到以下顺序的打印结果:</p><blockquote class="mb mc md"><p id="eb6e" class="jn jo me jp b jq jr js jt ju jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj kk ij bi translated">E̵v̵e̵n̵t̵A̵ ̵i̵s̵ ̵c̵a̵l̵l̵e̵d̵！̵̵<br/>e̵v̵e̵n̵t̵b̵̵i̵s̵̵c̵a̵l̵l̵e̵d̵！̵̵<br/>k̵e̵e̵p̵̵g̵o̵i̵n̵g̵̵i̵n̵̵e̵v̵e̵n̵t̵̵h̵a̵n̵d̵l̵e̵r̵̵a̵！̵̵<br/>k̵e̵e̵p̵̵g̵o̵i̵n̵g̵̵i̵n̵̵c̵o̵n̵s̵t̵r̵u̵c̵t̵o̵r̵！̵</p></blockquote><p id="de1d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但事实是这样的:</p><blockquote class="mb mc md"><p id="4856" class="jn jo me jp b jq jr js jt ju jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj kk ij bi translated">EventA叫！<br/>在事件处理程序A中继续！<br/>调用EventB！<br/>在构造器里继续走！</p></blockquote><p id="5782" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你真的查看这个库的内部来发布事件，有一个状态叫做<strong class="jp ir"> postingState。</strong>如果当前线程已经处于这种状态，那么你在该线程中发布的新事件将被排队等待以后执行。</p><figure class="lk ll lm ln gt lo"><div class="bz fp l di"><div class="lz ma l"/></div></figure><h1 id="9765" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">包裹</h1><h2 id="7c2f" class="nb km iq bd kn nc nd dn kr ne nf dp kv jy ng nh kz kc ni nj ld kg nk nl lh nm bi translated">赞成的意见</h2><ul class=""><li id="6f58" class="mn mo iq jp b jq mi ju mj jy nn kc no kg np kk ms mt mu mv bi translated">好用。使您不必实现自己的发布/订阅者体系结构和/或观察器。</li><li id="57bb" class="mn mo iq jp b jq mw ju mx jy my kc mz kg na kk ms mt mu mv bi translated">减少类的耦合，从而减少依赖性。</li><li id="958d" class="mn mo iq jp b jq mw ju mx jy my kc mz kg na kk ms mt mu mv bi translated">实现通常是轻量级的。</li><li id="3105" class="mn mo iq jp b jq mw ju mx jy my kc mz kg na kk ms mt mu mv bi translated">非常适合更新UI层。</li><li id="e8e8" class="mn mo iq jp b jq mw ju mx jy my kc mz kg na kk ms mt mu mv bi translated">能够指定线程模式而不是自己手动处理它是很方便的。</li></ul><p id="9bf1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">缺点</strong></p><ul class=""><li id="c7b6" class="mn mo iq jp b jq jr ju jv jy mp kc mq kg mr kk ms mt mu mv bi translated">随着时间的推移，跟踪哪个类处理哪个事件变得越来越困难。这会让你的代码变得复杂/难以理解。</li><li id="1b19" class="mn mo iq jp b jq mw ju mx jy my kc mz kg na kk ms mt mu mv bi translated">在Android中，将信息从一个活动传递到另一个活动可能很棘手。不过，粘性事件在某种程度上提供了实现这一点的方法。</li><li id="d7f5" class="mn mo iq jp b jq mw ju mx jy my kc mz kg na kk ms mt mu mv bi translated">忘记取消注册可能会导致内存泄漏(软引用支持可能会解决这个问题)。</li><li id="b52a" class="mn mo iq jp b jq mw ju mx jy my kc mz kg na kk ms mt mu mv bi translated">容易滥用它。请记住，它仅用于简单的事件交付。不要用EventBus代替简单的函数调用，除非你想毁了你的内部API，迷惑所有人。</li></ul></div></div>    
</body>
</html>