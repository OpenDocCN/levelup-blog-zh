# 设计 SolidJS:抽象

> 原文：<https://levelup.gitconnected.com/designing-solidjs-abstraction-66d8c63fa7d1>

## 开发人员体验是一个有很多权衡的领域。我们怎样才能找到正确的平衡？

![](img/94ed5195e883a71a4300310447d144ed.png)

叶夫根尼·切博塔列夫拍摄的《白灯笼》

[*SolidJS*](https://github.com/ryansolid/solid) *是一个高性能的 JavaScript UI 库。本系列文章深入探讨了设计该库的技术和决策。使用 Solid 不需要了解这些内容。今天的文章主要关注 Solid 的抽象方法。*

我花了很长时间才写完 2020 年的第一篇文章。在这种情况下，我想反思一下过去 10 年发生了什么变化，以及这些变化如何影响了 Solid 的设计。我总是说，Solid 只是建立在过去发生的工作(大部分是十年前)的基础上。但是让它脱颖而出的是某些选择的组合，传统的逻辑会导致你不兼容，从而不可能。

我在其他的设计 SolidJS 文章中已经讨论了很多这样的主题(见下面的链接)。我仍然发现经常需要解释这些选择，即使是对爱好者和那些熟悉反应库的人。许多人加入“黑暗面”来逃避 React，类似 Svelte 的东西提供了这种回归到更简单的时间开发者体验，然而我一直在称赞和模仿 React 的 API 决策。我也收到了关于 Solid 不如 Vue 简单的建议和批评，但这有很多原因。

Solid 是仔细回顾的结果，如果这意味着解决 reactivity 的核心缺陷，它对杀死它的英雄和拥抱它的反对者没有什么疑虑。

# 基本面

抽象本身是一个巨大的话题。最重要的是，它可以引用从底层数据模型到我们如何公开 API 的任何东西。今天我将会谈到以上所有的一些内容。我一直坚持的绝对真理，有时被称为软件工程的基本定理，是:

> 计算机科学中的所有问题都可以通过增加一层间接来解决，除了增加太多间接层的问题。

这里有一点需要解释。但是在核心上，这意味着不管你选择什么工具、语言、框架等等，你都可以用它达到几乎相同的效果。问题很少是你能不能做某事，而是做这件事的可行性有多大？这种属性，虽然严格来说不是软件领域独有的，但在产生如此广泛使用的工件的其他地方却不太容易被利用。我们都受制于物理学，但我们的整个过程都是基于建模。抽象是所有软件工程的基础。

这与后果无关。可能存在性能考虑、操作和开发成本，或者模型中的不一致性和漏洞。这一切归结起来就是:

> 我们抽象是为了以简单为代价让事情变得更简单。

容易和简单不一样。简单的事情可以很容易，但也可以用复杂的方式。在某一点上，不管这些片段有多简单，我们都希望抽象出来使事情变得更简单。可以说是“摆脱样板文件”。你最终得到的是一个更容易使用但天生更复杂的系统。这里的权衡并非没有后果。重要的是要了解其影响，这样我们才能有目的地做出决定，而不是被矛盾的目标所困扰，或者更糟的是，在短暂的“轻松”追求中失去所有身份。

# 原始的力量

大约 10 年前，我第一次被介绍给 KnockoutJS 。尽管我不能准确地定位它，但我知道我在看一些特别的东西。正当网络发展势头越来越猛的时候，我来到了编程的时代。几年后，在 ASP.NET 最辉煌的时候，我进入了专业行业。这是不同的。当然，当时我还不知道是什么原因，但是在服务器端呈现的 web 应用程序上使用了多年的组件、容器和生命周期方法之后，再次使用 JavaScript 做了这么多事情，真是令人耳目一新。当我用 Knockout 获得第一份全职工作时，就发生了这样的事情。

```
{ observable } = require "knockout"function Example() {
  // Declare a new state variable, which we'll call "count"
  count = observable(0)
  onClick = => count(count() + 1)return { count, onClick }
}applyBindings(Example())// HTML rendered somewhere else:
<div>
  <p>You clicked <span data-bind="text: count"/> times</p>
  <button data-bind="click: onClick">
    Click me
  </button>
</div>
```

如果您在过去的一年中使用过 React，其中的一些部分应该看起来很熟悉——函数组件、原始“钩子”、析构、箭头函数和可组合的声明性数据。除了语法，所有的部分都在 2010 年。Vue 3“新”合成 API 大概更接近。

这就是软件中好的模式一次又一次出现的原因。这种声明性数据方法，其中数据及其行为在可组合的块中描述，是 21 世纪初反应式库的主要模式，随着生命周期组件的兴起，它不再受欢迎，而生命周期组件是虚拟 DOM 的更自然的模型。然而，React 表明这些模式是可取的，其他库也在争相效仿。其他作者已经详细论述了钩子的好处，所以我不需要重复，但我只想问:

> 如果钩子是核心模型而不是另一个抽象，会怎么样？

首先，他们可以没有组件模型。在这一点上，一切只是变成了许多功能。组件只是函数，高阶钩子也是。开发体验的每一部分都只是在可组合的函数中组织这些原语。难以置信的简单，但是如果没有指导，它会变得复杂。功能仍然应该有一个特定的角色。但这是一个惯例问题，而不是一个要求。这是该方法的一个特征，而不是在其上添加另一层。

# 固体成分

对于 Solid，人们认识到，要包含它的反应性，就要包含包装这些反应性原语的功能构造的类型。固体不过是这些基元的组合。它的渲染器只是组成您在应用程序代码中使用的相同原语。编译器将 JSX 转换成这些相同的原语和包装器。这就是为什么 Solid 作为一个渲染器如此具有可扩展性，即使它是反应式的。一个简单的扩展行为，就像你写任何其他应用程序代码一样。

## 1.更高级别的挂钩

钩子(或者反应性原语)可以在块中一起工作来描述更复杂的行为。在 so 中，包装其他钩子的创建的函数是最简单的包装器，从函数式编程的词源来看，这些钩子通常被称为“高级钩子”。它们只是简单的工厂函数。您使用这种模式来模块化可重用的行为。它们是全局存储的基础，存在于任何渲染系统知识之外。有了反应式库，你会发现自己如此频繁地使用它们，以至于你可能都懒得给它们起个名字。

## 2.组件和更高级别的组件

这些也是工厂函数，但是它们有一个关于传递 props 对象的约定，并且它们的执行范围没有被跟踪。就是这样。虽然比更高级别的挂钩更严格，但它们仍然非常灵活。从概念上讲，只要它们的父组件能够处理它们的输出，它们甚至不需要返回 DOM 节点。你可以把它想象成数据的孩子，就像你在 HTML `<select>`和`<option>`对中找到的一样。这允许任何人编写丰富的嵌套组件系统，比如前面提到的 select，或者甚至控制渲染流，比如 Solid 的`<Switch>`组件。

## 3.访问器包装

这些是反应库专有的。由于跟踪发生在一个反应范围内，简单地将反应表达式包装在一个函数中就可以将它转移到执行它的范围。

```
const [state, setState] = createState({ name: "John" }),
  upperCaseName = () => state.name.toUpperCase();createEffect(() => console.log(upperCaseName()));
```

`state.name`的依赖和解析只发生在效果中。我们可以在执行任何数据转换之前组合它们。我用 Solid 创建了 [SolidRX](https://github.com/ryansolid/solid/tree/master/packages/solid-rx) ，这是一个受 RxJS 启发的配套库，可以帮助进行这类转换。

Solid 的组件属性也是访问器包装器，组件也不是绑定到自身的实体。这是通过将它们映射到 props 对象上的对象 getters 来实现的，这样简单的属性访问就可以触发它们的执行。这意味着所有动态道具都被延迟评估，以保持它们在被读取的地方被跟踪的能力。这也意味着，无论反应式数据在哪里定义，在使用它之前都不会被访问。虽然分层的组件最终会产生一个基本上是平面的依赖图，但却是以声明方式转换数据的另一种方式。

# 实体中的图元

因此，反向工作，理解我们希望如何创建我们的应用程序应该通知原语的设计。细粒度的反应库都由两个基本原语组成:一个反应原子，通常称为可观察的 or 信号，以及一个跟踪上下文，称为计算的 or 计算。从这里开始，常见的是将计算拆分，从产生副作用的更一般的计算中获得值。在固体中，那些分别是`createMemo`和`createEffect`。此外，在现代库中，我们经常看到使用代理来创建深度反应树，因为深度包装和映射嵌套结构的工作是相当大的手工工作。

我使用过许多反应式库，经历过好的和坏的时期，在自己使用它们和教授其他开发人员的同时，学到了很多东西。没有指导的写作练习是困扰早期的问题之一。视图模型虽然与组件非常相似，但却是一个重载的构造，因为它们几乎适用于所有东西。如前一节所述，通过分类，我们现在有了一个更加结构化的方法。反应式原语也有类似的问题。

## 1.隐式依赖

首先，如果有副作用的话，自动依赖检测对所有的好处来说都是难以维持的。事后看来，这是一种显而易见的说法，但早期的图书馆并没有指出其中的区别，也没有指出你应该意识到这一点。实际上，我在早期用一种方法包装了 Knockout，以加强显式依赖。我告诉我的开发人员，如果他们的计算没有返回值，他们就必须使用它，如果有返回值，就不应该写入任何其他可观察对象。为什么不让纯计算来陈述它们的依赖关系呢？主要是他们似乎从来没有引起问题。一般来说，您只需要跟踪产生特定值所需数据。这些永远不会产生无限循环。

正如许多人所知，虽然 Solid 有一个需要显式依赖的原语`createDependentEffect`,但这不是默认的。我确实讨论过这个问题，但是视图绑定需要自动跟踪。最重要的是，我发现最近几年对`createEffect`的需求明显减少。几乎所有我们以前有效的计算都是基于数据加载和回调的，这些数据加载和回调具有不可预测的解析时间，这可能导致意想不到的依赖性。处理这些问题的承诺和原语使这变得更加顺畅。另一个常见的情况是更新深度嵌套结构中的数据。代理现在可以很容易地处理这个问题。剩下的情况主要是与商店或一些外部系统同步。这正是它想要做的。尽管如此，每个设计良好的反应式库都应该有一种方法来设置显式依赖关系。

## 2.隐藏的反应

与随着时间的推移而减少的隐式依赖问题不同，这种情况只会变得更糟。随着我们添加更多的 getter/setter 和代理，我们不再意识到我们在处理反应式数据。很自然地认为 getters 是更大的问题，因为您不能轻易地判断正在跟踪什么。然而，我们很可能只访问我们需要的值，以获得价值或产生效果。如果其中一个变化触发了。大部分认知开销被 getters 减少了，因为将它们作为传递给函数的值或派生新值来访问没有任何干扰。如果在这些派生中你将数据视为不可变的，你将永远不会有任何问题。跟踪一个依赖项并不等同于做更多的工作。

触发一个会。当我们更新反应数据时，我们应该非常清楚，因为那是工作发生的时候。指责依赖跟踪就像抱怨你的函数需要参数。调用函数才是真正的成本。那么，为什么反应式库中两个非常主要的模式应该被认为是反模式，双向绑定和代理/对象设置器，就应该很明显了。

```
// Does this do anything other than set a value?
data.name = "John";// Why does my library require me to assign an array again?
array.push({ name: "John" });
array = array;
```

这是一些反应库的代码。你知道这是干什么吗？当然，调用一个显式 setter 并不能说明所有发生的事情，但至少我知道是这样的。我没有不小心设置了一个值，然后看着我的视图崩溃。

## 3.缺乏对方向性的强调

知道显式 setters 最好的部分是什么吗？读/写隔离。这有什么大不了的？虽然面向对象模型完全可以服务，因为我们在每一层中处理许多具有相关行为的数据点——我的意思是它对我来说就像一个类——但是将它们组合在一起并不能提供适当的控制级别。

看看我们在上一节中处理的内容。我们的视图只是数据转换的组合，通过函数来组织我们的心智模型。结果与函数式反应式编程没有太大区别。有点像 RxJS 流，只是你是分层构建的。而不是专注于单一信息流随时间的完全转变，这会让你的反应粒度更粗。你处理许多小原子，你通过添加层来绘制它们的轨迹。但是最后你基本上还是以一堆流结束。

我们也知道写反应式数据很有分量，务实的我们应该明确。如果我们让任何获得数据的人也能够写数据，我们如何保持一个强有力的契约？

# 错误的观点？

我也这么认为直到我看到了 saw React 的钩子抽象，我才明白了一切。但是更重要的是理解这些决定对你的库所能表达的内容的影响。我对什么样的品质使图书馆具有规模有了新的理解。

从很多方面来看，像 React 这样的库和 Angular 这样的框架没有多少共同之处(见[尤雨溪](https://medium.com/u/4f198f5f1f12?source=post_page-----66d8c63fa7d1--------------------------------)关于权衡的精彩视频[https://www.youtube.com/watch?v=ANtSWq-zI0s&VL = en](https://www.youtube.com/watch?v=ANtSWq-zI0s&vl=en))。但我注意到他们都关注一件事。他们确保自己能够很好地适应许多事情。即使 React 让事情变得简单和有棱角，不介意抽象一点让事情变得简单，他们也不会回避对拥有许多东西所带来的复杂性的预期。React 可能会导致模式有更多的样板，Angular 可能会导致您需要使用更具体的对象，但两者都不觉得有必要将事情抽象成一件简单的事情。他们承认事情可能很复杂，解决方案并不总是将事情进一步抽象(这会增加复杂性)。抽象滋生了复杂性，这是我们唯一不能用更多的抽象来解决的软件问题。

开发者永远不会因此而感谢他们。相反，我们想知道为什么事情不能变得更简单。但是我们错了。不是非黑即白。但是我们也应该看看哪一个给了我们适应性最强的工具，而没有对我们隐藏所有的细节。你总是可以抽象出样板文件，但是去除抽象要困难得多。

[](https://github.com/ryansolid/solid) [## 瑞安固体/固体

### 一个用于构建用户界面的声明式、高效且灵活的 JavaScript 库。—瑞安固体/固体

github.com](https://github.com/ryansolid/solid) [](https://itnext.io/designing-solidjs-reactivity-75180a4c74b4) [## 设计固体:反应性

### 2019 年前端开发的热点按钮话题。这很大程度上归功于苗条而富有的哈里斯…

itnext.io](https://itnext.io/designing-solidjs-reactivity-75180a4c74b4) [](https://medium.com/javascript-in-plain-english/designing-solidjs-immutability-f1e46fe9f321) [## 设计固体:不变性

### 反应式状态管理可以既是不可变的又是最高效的吗？

medium.com](https://medium.com/javascript-in-plain-english/designing-solidjs-immutability-f1e46fe9f321) [](https://medium.com/@ryansolid/designing-solidjs-dualities-69ee4c08aa03) [## 设计固体:二元性

### 看对立面能否帮助我们重新定义看待整体问题空间的方式？

medium.com](https://medium.com/@ryansolid/designing-solidjs-dualities-69ee4c08aa03)