<html>
<head>
<title>QFormat</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">QFormat</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/qformat-92b4e570235f?source=collection_archive---------16-----------------------#2020-07-10">https://levelup.gitconnected.com/qformat-92b4e570235f?source=collection_archive---------16-----------------------#2020-07-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><h1 id="de7b" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">介绍</h1><p id="2396" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><a class="ae lm" href="https://en.wikipedia.org/wiki/Q_(number_format))" rel="noopener ugc nofollow" target="_blank"> Q格式</a>是一种二进制定点数格式。<a class="ae lm" href="https://github.com/danmcleran/tinymind" rel="noopener ugc nofollow" target="_blank"> Tinymind </a>包含一个模板库，允许我们指定整数位数和小数位数作为模板参数。当定点精度足够时(或者当我们根本没有FPU时),可以用q格式代替浮点数。).见<a class="ae lm" href="https://en.wikipedia.org/wiki/Q_(number_format)" rel="noopener ugc nofollow" target="_blank"> Q格式</a>深潜。</p><h1 id="1ace" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">Tinymind QValue</h1><p id="97c5" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><a class="ae lm" href="https://github.com/danmcleran/tinymind" rel="noopener ugc nofollow" target="_blank"> Tinymind </a>包含一个C++模板库，用于定义和使用Q格式值。模板类称为QValue。模板声明在这里:</p><figure class="ln lo lp lq gt lr"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="d5b8" class="pw-post-body-paragraph ko kp it kq b kr lu kt ku kv lv kx ky kz lw lb lc ld lx lf lg lh ly lj lk ll im bi translated"><strong class="kq iu"> NumFixedBits </strong> —定点值的整数部分的位数。</p><p id="7d5e" class="pw-post-body-paragraph ko kp it kq b kr lu kt ku kv lv kx ky kz lw lb lc ld lx lf lg lh ly lj lk ll im bi translated"><strong class="kq iu"> NumFractionalBits </strong> —定点值的小数部分的位数。</p><p id="ccfa" class="pw-post-body-paragraph ko kp it kq b kr lu kt ku kv lv kx ky kz lw lb lc ld lx lf lg lh ly lj lk ll im bi translated"><strong class="kq iu"> QValueIsSigned </strong> — true —整数部分保留1位给符号位，false —无符号位</p><p id="7ef8" class="pw-post-body-paragraph ko kp it kq b kr lu kt ku kv lv kx ky kz lw lb lc ld lx lf lg lh ly lj lk ll im bi translated"><strong class="kq iu">QValueRoundingPolicy</strong>—<a class="ae lm" href="https://riptutorial.com/cplusplus/example/10838/template-template-parameters" rel="noopener ugc nofollow" target="_blank">模板模板参数</a>，指定处理舍入的策略类。Tinymind 提供了两个选项，但是您也可以定义自己的选项。tinymind 提供的一个选项是截断政策。这通过丢弃低位来舍入Q格式值(例如，整数除法就是这样做的)。tinymind提供的另一个选项是RoundUpPolicy。RoundUpPolicy向上舍入到最接近的小数值。</p><h1 id="174f" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">示例使用</h1><p id="6bc9" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">使用模板，我们可以为几乎任何种类的Q格式数量声明类型。单元测试的一些例子:</p><figure class="ln lo lp lq gt lr"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="2866" class="pw-post-body-paragraph ko kp it kq b kr lu kt ku kv lv kx ky kz lw lb lc ld lx lf lg lh ly lj lk ll im bi translated">可以像任何其他类一样声明和初始化此类型的实例:</p><figure class="ln lo lp lq gt lr"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="4687" class="pw-post-body-paragraph ko kp it kq b kr lu kt ku kv lv kx ky kz lw lb lc ld lx lf lg lh ly lj lk ll im bi translated">这里我们声明并初始化一个带符号的Q24.8值为负一的表示。我们可以把这个变量当作一个普通的旧整数来使用:</p><figure class="ln lo lp lq gt lr"><div class="bz fp l di"><div class="ls lt l"/></div></figure><h1 id="d3f1" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">Tinymind QValue类图</h1><p id="da15" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">QValue使用qformat.hpp中的几个类来实现它的目标。这里显示了类之间的关系。</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="gh gi lz"><img src="../Images/de819f904a073aef9b5394b70cb26234.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kqyJHu9dNytaACfc"/></div></div><figcaption class="mg mh gj gh gi mi mj bd b be z dk translated">图1: QValue类图</figcaption></figure><h1 id="477e" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">编译时类型选择</h1><p id="5c55" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">QValue使用编译时类型选择来选择最小大小的类型:固定部分、小数部分以及整数值表示(固定+小数)。</p><figure class="ln lo lp lq gt lr"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="574a" class="pw-post-body-paragraph ko kp it kq b kr lu kt ku kv lv kx ky kz lw lb lc ld lx lf lg lh ly lj lk ll im bi translated">从上面的代码片段中可以看出，它是通过一个模板类来实现的，这个模板类的目的是选择最佳类型，即QTypeChooser。</p><figure class="ln lo lp lq gt lr"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="915b" class="pw-post-body-paragraph ko kp it kq b kr lu kt ku kv lv kx ky kz lw lb lc ld lx lf lg lh ly lj lk ll im bi translated">QTypeChooser将固定位数和小数位数相加，并将该值和有符号标志一起传递给FullWidthFieldTypeChooser。实际上，每个人都使用FullWidthFieldTypeChooser类来选择类型。FullWidthFieldTypeChooser在编译时分析固定位数+小数位数以及符号位的模板参数，并进行类型选择。</p><figure class="ln lo lp lq gt lr"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="058a" class="pw-post-body-paragraph ko kp it kq b kr lu kt ku kv lv kx ky kz lw lb lc ld lx lf lg lh ly lj lk ll im bi translated">这使得我们可以像处理常规整数一样处理Q格式的值。<a class="ae lm" href="https://github.com/danmcleran/tinymind/blob/master/cpp/qformat.hpp" rel="noopener ugc nofollow" target="_blank"> qformat.hpp </a>中的大部分代码都提供了必要的操作符重载，将q值视为常规整数。</p><p id="e55c" class="pw-post-body-paragraph ko kp it kq b kr lu kt ku kv lv kx ky kz lw lb lc ld lx lf lg lh ly lj lk ll im bi translated">让我们看一个例子。来自单元测试<a class="ae lm" href="https://github.com/danmcleran/tinymind/blob/master/unit_test/qformat/qformat_unit_test.cpp" rel="noopener ugc nofollow" target="_blank"> qformat_unit_test.cpp </a>:</p><figure class="ln lo lp lq gt lr"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="28ce" class="pw-post-body-paragraph ko kp it kq b kr lu kt ku kv lv kx ky kz lw lb lc ld lx lf lg lh ly lj lk ll im bi translated">这定义了一种Q格式类型，它使用8位来表示Q格式值的固定部分以及8位来表示Q格式值的小数部分。我们通过模板参数“false”选择了unsigned。舍入策略从默认值TruncatePolicy被覆盖为RoundUpPolicy。通过检查QTypeChooser代码，您可以看到我们将为Q格式值的固定部分和小数部分选择uint16_t。因为我们对小数部分使用8位，所以在0和1之间有256个唯一值。我们的分辨率计算为2^-8或0.00390625(浮点)。为了用这种格式表示值1.5，我们将把它写成0x180。这是左移了小数位数的值1+小数位数提供的范围的1/2(即2⁸ &gt;&gt; 1或2⁷，即0x80)。</p><h1 id="547b" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">使用q值</h1><p id="a4be" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">从单元测试<a class="ae lm" href="https://github.com/intel/cppnnml/blob/master/unit_test/qformat/qformat_unit_test.cpp" rel="noopener ugc nofollow" target="_blank"> qformat_unit_test.cpp </a>中我们可以学习如何使用QValues。因为我们应该支持所有常见的数学运算符，所以我们可以将它们视为普通的pod(普通数据)。</p><h1 id="621d" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">编译单元测试</h1><p id="77cf" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">要编译单元测试，切换到unit_test/qformat/目录并使用make来构建它们。</p><pre class="ln lo lp lq gt mk ml mm bn mn mo bi"><span id="4ea8" class="mp jr it ml b be mq mr l ms mt">cd unit_test/qformat<br/>make</span></pre><p id="d3ab" class="pw-post-body-paragraph ko kp it kq b kr lu kt ku kv lv kx ky kz lw lb lc ld lx lf lg lh ly lj lk ll im bi translated">Makefile如下所示。</p><pre class="ln lo lp lq gt mk ml mm bn mn mo bi"><span id="cea2" class="mp jr it ml b be mq mr l ms mt"># Simple Makefile for the q-format unit test<br/># Enable C++ iostreams<br/>qformat_unit_test: qformat_unit_test.cpp<br/>#   Make an output dir to hold the executable<br/>    mkdir -p ./output<br/>#   Build the unit tests<br/>    g++ -g -Wall -o ./output/qformat_unit_test qformat_unit_test.cpp -DTINYMIND_ENABLE_OSTREAMS=1 -I../../cpp -I${BOOST_HOME}<br/><br/><br/># Remove all object files<br/>clean:<br/>    rm -f ./output/*</span></pre><p id="105c" class="pw-post-body-paragraph ko kp it kq b kr lu kt ku kv lv kx ky kz lw lb lc ld lx lf lg lh ly lj lk ll im bi translated">将目录更改为输出目录，以运行单元测试。</p><pre class="ln lo lp lq gt mk ml mm bn mn mo bi"><span id="7192" class="mp jr it ml b be mq mr l ms mt">cd ./output/<br/>./qformat_unit_test</span></pre><p id="1060" class="pw-post-body-paragraph ko kp it kq b kr lu kt ku kv lv kx ky kz lw lb lc ld lx lf lg lh ly lj lk ll im bi translated">您应该会看到下面的输出:</p><pre class="ln lo lp lq gt mk ml mm bn mn mo bi"><span id="d41b" class="mp jr it ml b be mq mr l ms mt">Running 10 test cases..<br/><br/><br/>*** No errors detected</span></pre><h1 id="b472" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">添加</h1><p id="8c00" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们可以将相同类型的其他qvalue以及具有相同的完整值的底层表示的整数相加。参见<a class="ae lm" href="https://github.com/danmcleran/tinymind/blob/master/unit_test/qformat/qformat_unit_test.cpp" rel="noopener ugc nofollow" target="_blank"> qformat_unit_test.cpp </a>中的test_case_addition。</p><figure class="ln lo lp lq gt lr"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="9df3" class="pw-post-body-paragraph ko kp it kq b kr lu kt ku kv lv kx ky kz lw lb lc ld lx lf lg lh ly lj lk ll im bi translated">q值可以彼此相加，也可以与整数常量相加。</p><h1 id="b1c8" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">减法</h1><p id="45b9" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">减法也是类似的故事。我们可以从同类型的其他q值中减去q值，也可以从q值中减去整数。参见<a class="ae lm" href="https://github.com/danmcleran/tinymind/blob/master/unit_test/qformat/qformat_unit_test.cpp" rel="noopener ugc nofollow" target="_blank"> qformat_unit_test.cpp </a>中的test_case_subtraction。</p><figure class="ln lo lp lq gt lr"><div class="bz fp l di"><div class="ls lt l"/></div></figure><h1 id="e85a" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">前/后增量和减量</h1><p id="ce8d" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">有符号和无符号Q格式类型都支持前后递增和递减。参见<a class="ae lm" href="https://github.com/danmcleran/tinymind/blob/master/unit_test/qformat/qformat_unit_test.cpp" rel="noopener ugc nofollow" target="_blank"> qformat_unit_test.cpp </a>中的test_case_increment_decrement。</p><figure class="ln lo lp lq gt lr"><div class="bz fp l di"><div class="ls lt l"/></div></figure><h1 id="e4a8" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">增加</h1><p id="4d5e" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">QValues可以相互相乘，也可以与整数值相乘，就像普通的pod一样。参见<a class="ae lm" href="https://github.com/danmcleran/tinymind/blob/master/unit_test/qformat/qformat_unit_test.cpp" rel="noopener ugc nofollow" target="_blank"> qformat_unit_test.cpp </a>中的test_case_multiplication。</p><figure class="ln lo lp lq gt lr"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="0c9d" class="pw-post-body-paragraph ko kp it kq b kr lu kt ku kv lv kx ky kz lw lb lc ld lx lf lg lh ly lj lk ll im bi translated">支持与同类型的其他QValues相乘，也支持与整数常量相乘。</p><h1 id="45d5" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">分开</h1><p id="880c" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">就像普通的pod一样，q值可以互相除，也可以被整数除。参见<a class="ae lm" href="https://github.com/danmcleran/tinymind/blob/master/unit_test/qformat/qformat_unit_test.cpp" rel="noopener ugc nofollow" target="_blank"> qformat_unit_test.cpp </a>中的test_case_division。</p><figure class="ln lo lp lq gt lr"><div class="bz fp l di"><div class="ls lt l"/></div></figure><h1 id="a441" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">比较器</h1><p id="9dfc" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">q值可以与其他q值以及整数进行比较。参见<a class="ae lm" href="https://github.com/danmcleran/tinymind/blob/master/unit_test/qformat/qformat_unit_test.cpp" rel="noopener ugc nofollow" target="_blank"> qformat_unit_test.cpp </a>中的test_case_comparators。</p><figure class="ln lo lp lq gt lr"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="2e43" class="pw-post-body-paragraph ko kp it kq b kr lu kt ku kv lv kx ky kz lw lb lc ld lx lf lg lh ly lj lk ll im bi translated">支持与其他QValues以及整数常量进行比较。</p><h1 id="eff2" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">转换</h1><p id="fc47" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">从另一个QValue类型转换后，可以为q value赋值。参见<a class="ae lm" href="https://github.com/danmcleran/tinymind/blob/master/unit_test/qformat/qformat_unit_test.cpp" rel="noopener ugc nofollow" target="_blank"> qformat_unit_test.cpp </a>中的test_case_conversion。为了支持转换，QValue定义了一个模板方法。</p><figure class="ln lo lp lq gt lr"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="c17f" class="pw-post-body-paragraph ko kp it kq b kr lu kt ku kv lv kx ky kz lw lb lc ld lx lf lg lh ly lj lk ll im bi translated">该方法利用编译时类型选择来选择适当的移位策略，以便在从其他QValue类型转换到被赋值的QValue类型时应用。</p><figure class="ln lo lp lq gt lr"><div class="bz fp l di"><div class="ls lt l"/></div></figure><h1 id="27ae" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">结论</h1><p id="3bb2" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">Q值表示Q格式的数字，用于没有浮点的系统，或者用于定点分辨率已经足够的情况。QValues可以被视为正常的pod。加法、减法、除法和乘法都可以在q值上执行，就像它们是普通的旧整数一样。</p></div></div>    
</body>
</html>