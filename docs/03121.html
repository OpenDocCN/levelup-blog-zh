<html>
<head>
<title>JavaScript Interview Questions — Harder DOM Questions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript面试问题—更难的DOM问题</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-interview-questions-harder-dom-questions-310748dc914d?source=collection_archive---------10-----------------------#2020-04-20">https://levelup.gitconnected.com/javascript-interview-questions-harder-dom-questions-310748dc914d?source=collection_archive---------10-----------------------#2020-04-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/855a0007ed233cb9f18173db88213ef7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GJiXyCHU08VG2NVT"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">由<a class="ae kf" href="https://unsplash.com/@toddquackenbush?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">托德·夸肯布什</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="20e4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了得到一份前端开发人员的工作，我们需要搞定编码面试。</p><p id="4750" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将研究一些关于DOM操作的更难的问题。</p><h1 id="281d" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">如何检查一个元素是否是父元素的后代？</h1><p id="7c37" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以使用DOM元素的<code class="fe mh mi mj mk b">parentNode</code>属性来检查一个元素是否是另一个元素的子元素。</p><p id="c666" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们编写以下函数检查一个节点是否是一个子节点的父节点:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="980c" class="mt lf it mk b gy mu mv l mw mx">const isDescendant = (parent, child) =&gt; {<br/>  while (child.parentNode) {<br/>    if (child.parentNode == parent)<br/>      return true;<br/>    else<br/>      child = child.parentNode;<br/>  }<br/>  return false;<br/>}</span></pre><p id="8a4f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<code class="fe mh mi mj mk b">isDescendant</code>函数中，我们用<code class="fe mh mi mj mk b">parentNode</code>属性获取<code class="fe mh mi mj mk b">child</code>的父节点，直到到达顶层。</p><p id="bbac" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在每个父节点中，我们检查<code class="fe mh mi mj mk b">parentNode</code>属性是否引用了与<code class="fe mh mi mj mk b">parent</code>相同的节点。</p><p id="f279" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果是这样，我们返回<code class="fe mh mi mj mk b">true</code>。否则，如果我们发现<code class="fe mh mi mj mk b">parentNode</code>与<code class="fe mh mi mj mk b">parent</code>是同一个节点，我们将遍历祖父级、曾祖父级并一直到顶层，然后返回<code class="fe mh mi mj mk b">true</code>。</p><p id="a686" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">否则，如果没有一个与<code class="fe mh mi mj mk b">parent</code>相同，我们返回<code class="fe mh mi mj mk b">false</code>。</p><p id="f561" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有以下HTML:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="d09b" class="mt lf it mk b gy mu mv l mw mx">&lt;div&gt;<br/>  &lt;p&gt;<br/>    &lt;span&gt;&lt;/span&gt;<br/>  &lt;/p&gt;<br/>&lt;/div&gt;</span><span id="8c25" class="mt lf it mk b gy my mv l mw mx">&lt;div id='foo'&gt;&lt;/div&gt;</span></pre><p id="d19c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么如果我们有下面的代码:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="f2f7" class="mt lf it mk b gy mu mv l mw mx">const div = document.querySelector('div');<br/>const p = document.querySelector('p');<br/>const span = document.querySelector('span');<br/>const foo = document.querySelector('#foo');</span><span id="2559" class="mt lf it mk b gy my mv l mw mx">console.log(isDescendant(div, p));<br/>console.log(isDescendant(div, span));<br/>console.log(isDescendant(foo, span));</span></pre><p id="3bb8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">前两个应该记录<code class="fe mh mi mj mk b">true</code>，最后一个应该记录<code class="fe mh mi mj mk b">false</code>，因为第一个div是p的父类和span的祖父类。</p><p id="b061" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">ID为foo的div不是任何其他节点的父节点。</p><h1 id="5cf9" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">innerHTML和appendChild有什么区别？</h1><p id="ac6e" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mh mi mj mk b">innerHTML</code>删除元素的所有当前子节点。然后JavaScript解释器解析该字符串，然后将解析后的字符串作为子元素分配给该元素。</p><p id="2bac" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">appendChild</code>顾名思义，将子节点附加到它所调用的父节点。</p><p id="42b2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有以下HTML:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="8f4e" class="mt lf it mk b gy mu mv l mw mx">&lt;div&gt;<br/>  &lt;p&gt;foo&lt;/p&gt;<br/>&lt;/div&gt;</span></pre><p id="4ebf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么如果我们写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="39a9" class="mt lf it mk b gy mu mv l mw mx">const div = document.querySelector('div');<br/>div.innerHTML = '&lt;p&gt;bar&lt;/p&gt;';</span></pre><p id="52dd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们只在屏幕上看到‘bar ’,因为我们设置了<code class="fe mh mi mj mk b">innerHTML</code>属性来覆盖那里的内容。</p><p id="ccbb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一方面，如果我们如下使用<code class="fe mh mi mj mk b">appendChild</code>:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="68d8" class="mt lf it mk b gy mu mv l mw mx">const div = document.querySelector('div');</span><span id="af68" class="mt lf it mk b gy my mv l mw mx">const p = document.createElement("p");<br/>const bar = document.createTextNode("bar");<br/>p.appendChild(bar);</span><span id="3e46" class="mt lf it mk b gy my mv l mw mx">div.appendChild(p);</span></pre><p id="ecea" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们添加带有文本节点“bar”的p元素，并调用<code class="fe mh mi mj mk b">appendChild</code>将<code class="fe mh mi mj mk b">p</code>追加到<code class="fe mh mi mj mk b">div</code>中，我们看到:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="5353" class="mt lf it mk b gy mu mv l mw mx">foo</span><span id="0036" class="mt lf it mk b gy my mv l mw mx">bar</span></pre><p id="365c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为我们在div的子元素列表的末尾添加了一个新的子元素。</p><h1 id="fb04" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">什么是createDocumentFragment，为什么您可能会使用它？</h1><p id="b85b" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mh mi mj mk b">document.createDocumentFragment</code>让我们创建一个新的<code class="fe mh mi mj mk b">DocumentFragment</code>，可以在其中添加DOM节点来构建一个屏幕外DOM树。</p><p id="7662" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有以下HTML:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="cc8c" class="mt lf it mk b gy mu mv l mw mx">&lt;ul&gt;&lt;/ul&gt;</span></pre><p id="d4cc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们可以使用如下的<code class="fe mh mi mj mk b">createDocumentFragment</code>来创建一个屏幕外的片段，然后将整个东西插入到DOM中:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="76e3" class="mt lf it mk b gy mu mv l mw mx">const element = document.querySelector('ul');<br/>const fragment = document.createDocumentFragment();<br/>const fruits = ['apple', 'orange', 'grape'];</span><span id="205e" class="mt lf it mk b gy my mv l mw mx">fruits.forEach((fruit) =&gt; {<br/>  const li = document.createElement('li');<br/>  li.textContent = fruit;<br/>  fragment.appendChild(li);<br/>});</span><span id="5cda" class="mt lf it mk b gy my mv l mw mx">element.appendChild(fragment);</span></pre><p id="4ba5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用<code class="fe mh mi mj mk b">createDocumentFragment</code>，我们首先将所有节点添加到片段中，然后使用<code class="fe mh mi mj mk b">appendChild</code>将整个内容添加到我们的<code class="fe mh mi mj mk b">ul</code>元素中。</p><p id="3966" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">是DOM或DOM子树的轻量级或最小部分。这对于多次操作DOM的一部分很有用。</p><p id="8c9a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在内存中进行管理，这样CPU就不会被昂贵的操作所累。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/d533e438b0d7664696289e4c10668a40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vdwSukA_jWbLKwGD"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@cierrawoodard?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Cierra Woodard </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="1e1a" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">什么是回流？什么导致了回流？我们如何减少回流？</h1><p id="e06d" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">重排是指我们根据屏幕大小或位置的变化来改变元素的位置。</p><p id="4c5b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们改变屏幕的宽度，比如当我们旋转手机屏幕时，那么所有的东西都必须被移动以显示在屏幕属性中。</p><p id="64d8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">回流是昂贵的，因为所有的东西都要移动，尤其是像手机这样的小设备。</p><p id="d527" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">重排是由改变布局、调整窗口大小、改变任何元素的尺寸、以任何方式改变字体、移动DOM元素、添加或移除样式表以及任何其他类似的改变引起的。</p><p id="fa9b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了避免重排，我们避免设置多个内嵌样式，将动画应用于固定或绝对位置的元素，并避免使用表格进行布局。</p><h1 id="bc60" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="e77b" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以使用节点的<code class="fe mh mi mj mk b">parentNode</code>属性来获取节点的父节点。</p><p id="870d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">设置元素的<code class="fe mh mi mj mk b">innerHTML</code>属性会覆盖所有现有的子元素，并用我们设置的字符串中的新元素替换它们。</p><p id="8e70" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">appendChild</code>在子树的末尾附加一个新的子元素。</p><p id="a0e7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">DocumentFragments</code>是轻量级的屏幕外元素，包含DOM元素。它在内存中管理，可以像任何其他元素一样添加到屏幕上。</p><p id="c315" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">重排是根据屏幕上的一些其他变化来改变元素的位置。这是一个应该避免的昂贵的手术。</p></div></div>    
</body>
</html>