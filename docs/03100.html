<html>
<head>
<title>Ugly dependency graph? The Mediator Design Pattern is the solution for you.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">难看的依赖图？中介设计模式是您的解决方案。</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/ugly-dependency-graph-the-mediator-design-pattern-is-the-solution-for-you-8b35df60558b?source=collection_archive---------10-----------------------#2020-04-19">https://levelup.gitconnected.com/ugly-dependency-graph-the-mediator-design-pattern-is-the-solution-for-you-8b35df60558b?source=collection_archive---------10-----------------------#2020-04-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="872d" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">设计模式系列</h2><div class=""/><div class=""><h2 id="e372" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">使用中介设计模式增强和简化对象依赖图。</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/f13fc0b97f1059304922de53003de872.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hr70iG3rlARmS9G8iQ2Evw.jpeg"/></div></div></figure><h2 id="0137" class="ld le it bd lf lg lh dn li lj lk dp ll lm ln lo lp lq lr ls lt lu lv lw lx iz bi translated">介绍</h2><p id="c5be" class="pw-post-body-paragraph ly lz it ma b mb mc kd md me mf kg mg lm mh mi mj lq mk ml mm lu mn mo mp mq im bi translated">通过自我教育的旅程，我终于明白了一个调解人。当你成为一名开发人员时，中介设计模式可以成为你工具箱中一个有益的工具。</p><h2 id="13fa" class="ld le it bd lf lg lh dn li lj lk dp ll lm ln lo lp lq lr ls lt lu lv lw lx iz bi translated">先决条件</h2><p id="1f6a" class="pw-post-body-paragraph ly lz it ma b mb mc kd md me mf kg mg lm mh mi mj lq mk ml mm lu mn mo mp mq im bi translated">本教程期望你了解C#语言和面向对象编程的基础。</p><h2 id="40ae" class="ld le it bd lf lg lh dn li lj lk dp ll lm ln lo lp lq lr ls lt lu lv lw lx iz bi translated">图书定义</h2><p id="0139" class="pw-post-body-paragraph ly lz it ma b mb mc kd md me mf kg mg lm mh mi mj lq mk ml mm lu mn mo mp mq im bi translated">中介设计模式(Mediator)在一本名为<a class="ae mr" href="https://en.m.wikipedia.org/wiki/Design_Patterns" rel="noopener ugc nofollow" target="_blank">Design Patterns:Elements of Reusable Object-Oriented Software</a>的书中首次被正式引入。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/96e1689510888e78c854fe081670bdd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:656/format:webp/1*Przj_UNYooXIz6-idWWi5g.jpeg"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">书籍封面设计图案</figcaption></figure><p id="8acb" class="pw-post-body-paragraph ly lz it ma b mb mx kd md me my kg mg lm mz mi mj lq na ml mm lu nb mo mp mq im bi translated">Mediator封装了对象如何相互交互和通信。这种模式促进了对象的<a class="ae mr" href="https://en.wikipedia.org/wiki/Loose_coupling" rel="noopener ugc nofollow" target="_blank">松散耦合</a>，以避免难看的<a class="ae mr" href="https://en.wikipedia.org/wiki/Dependency_graph" rel="noopener ugc nofollow" target="_blank">依赖图</a>。</p><p id="82cb" class="pw-post-body-paragraph ly lz it ma b mb mx kd md me my kg mg lm mz mi mj lq na ml mm lu nb mo mp mq im bi translated">丑陋的依赖图，这正是你我应该尽量避免的。松散耦合是实现这一点的方法之一。而调解员是做这件事的具体实施者。</p><p id="6a15" class="pw-post-body-paragraph ly lz it ma b mb mx kd md me my kg mg lm mz mi mj lq na ml mm lu nb mo mp mq im bi translated">中介器通过将通信封装在中央中介器对象中，使对象能够避免直接相互引用。</p><p id="1614" class="pw-post-body-paragraph ly lz it ma b mb mx kd md me my kg mg lm mz mi mj lq na ml mm lu nb mo mp mq im bi translated">想象一下你的代码库中有一堆对象。如果每个对象都必须与所有其他目的相关联和通信，这很快就会变得很糟糕。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/dc6416f0095cf975613664f135918ef1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*j8qa9q9rgIm2EwgG7EqAjw.jpeg"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">图片来自Pexels的Pixabay</figcaption></figure><h2 id="480b" class="ld le it bd lf lg lh dn li lj lk dp ll lm ln lo lp lq lr ls lt lu lv lw lx iz bi translated">开发者友好的解释</h2><p id="2097" class="pw-post-body-paragraph ly lz it ma b mb mc kd md me mf kg mg lm mh mi mj lq mk ml mm lu mn mo mp mq im bi translated">使用Mediator，我们创建了一个中心Mediator对象。这个单独的对象唯一负责维护对我们的“对象束”中的对象的引用。</p><p id="c90a" class="pw-post-body-paragraph ly lz it ma b mb mx kd md me my kg mg lm mz mi mj lq na ml mm lu nb mo mp mq im bi translated">它还负责转发这些对象之间的任何消息或通信。你可以把仲裁者想象成一个<strong class="ma jd">通信枢纽</strong>。</p><p id="79e0" class="pw-post-body-paragraph ly lz it ma b mb mx kd md me my kg mg lm mz mi mj lq na ml mm lu nb mo mp mq im bi translated">调解人通常由以下四个部分组成:</p><ol class=""><li id="7259" class="nd ne it ma b mb mx me my lm nf lq ng lu nh mq ni nj nk nl bi translated">调解人—定义同事之间的沟通。</li><li id="993b" class="nd ne it ma b mb nm me nn lm no lq np lu nq mq ni nj nk nl bi translated">具体调解人—实现同事之间的沟通。</li><li id="028c" class="nd ne it ma b mb nm me nn lm no lq np lu nq mq ni nj nk nl bi translated">同事—仅与调解人沟通。</li><li id="4dc7" class="nd ne it ma b mb nm me nn lm no lq np lu nq mq ni nj nk nl bi translated">具体的同事—接收来自调解人的消息。</li></ol><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/e336db6296dc8d6b82118b16089cb4c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:802/format:webp/1*07RUx2uAm5fHXz64t6o0SQ.jpeg"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">关系图</figcaption></figure><h2 id="5019" class="ld le it bd lf lg lh dn li lj lk dp ll lm ln lo lp lq lr ls lt lu lv lw lx iz bi translated">组件之间的关系</h2><p id="105a" class="pw-post-body-paragraph ly lz it ma b mb mc kd md me mf kg mg lm mh mi mj lq mk ml mm lu mn mo mp mq im bi translated">Mediator通常是一个基于抽象的类。具体中介从基本中介继承，并实现主要由中介中的契约或基本方法定义的通信。</p><p id="ebbc" class="pw-post-body-paragraph ly lz it ma b mb mx kd md me my kg mg lm mz mi mj lq na ml mm lu nb mo mp mq im bi translated">collaborate也是一个基于抽象的类，但是它代表了一个相关的对象集合。它只引用它的中介并与之通信。你可以把这想象成<strong class="ma jd">调解人和同事之间的双向</strong>。</p><p id="ab1d" class="pw-post-body-paragraph ly lz it ma b mb mx kd md me my kg mg lm mz mi mj lq na ml mm lu nb mo mp mq im bi translated">具体的同事只是继承自抽象同事基类并定义特定行为的不同类型的子类。</p><h2 id="ee0b" class="ld le it bd lf lg lh dn li lj lk dp ll lm ln lo lp lq lr ls lt lu lv lw lx iz bi translated">履行</h2><p id="fb87" class="pw-post-body-paragraph ly lz it ma b mb mc kd md me mf kg mg lm mh mi mj lq mk ml mm lu mn mo mp mq im bi translated">让我们深入代码，实现我们的第一个中介。首先，我们需要创建一个名为Mediator的抽象类及其抽象方法Send。</p><p id="c41e" class="pw-post-body-paragraph ly lz it ma b mb mx kd md me my kg mg lm mz mi mj lq na ml mm lu nb mo mp mq im bi translated">然后创建一个抽象类同事。</p><p id="5099" class="pw-post-body-paragraph ly lz it ma b mb mx kd md me my kg mg lm mz mi mj lq na ml mm lu nb mo mp mq im bi translated">如你所见，我添加了一点实现。</p><p id="3d02" class="pw-post-body-paragraph ly lz it ma b mb mx kd md me my kg mg lm mz mi mj lq na ml mm lu nb mo mp mq im bi translated">首先，我们为同事提供了一个构造函数，它接受一个中介并将其设置到一个受保护的字段中。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/1e53e0532142d41328713a2b104feca6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1392/format:webp/1*7qpANzgCAehIaWSn7HXEhA.jpeg"/></div></figure><p id="354f" class="pw-post-body-paragraph ly lz it ma b mb mx kd md me my kg mg lm mz mi mj lq na ml mm lu nb mo mp mq im bi translated">然后，我实现了send方法，该方法将通过Send方法向我们存储在受保护字段中的中介发送消息。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/f8aca897b3ec2e5be3b9f2c1b90dc729.png" data-original-src="https://miro.medium.com/v2/resize:fit:1392/format:webp/1*bBObxqXaDlhQOVlst9Ubxw.png"/></div></figure><p id="85d6" class="pw-post-body-paragraph ly lz it ma b mb mx kd md me my kg mg lm mz mi mj lq na ml mm lu nb mo mp mq im bi translated">最后，我在底部有一个抽象的HandleNotification方法。想想看，我们需要一个接收信息的地方。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/f6f44390806d8b977f8ad0010d08248e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1392/format:webp/1*lLXk9tHXOw_t21viYJNXfQ.png"/></div></figure><p id="27d4" class="pw-post-body-paragraph ly lz it ma b mb mx kd md me my kg mg lm mz mi mj lq na ml mm lu nb mo mp mq im bi translated">现在让我们添加继承自这个抽象同事类的具体同事。</p><p id="9725" class="pw-post-body-paragraph ly lz it ma b mb mx kd md me my kg mg lm mz mi mj lq na ml mm lu nb mo mp mq im bi translated">当我从抽象类collaborate继承时，我必须实现HandleNotification方法。实现是将收到的消息的简单通知打印到控制台中。</p><p id="f4ed" class="pw-post-body-paragraph ly lz it ma b mb mx kd md me my kg mg lm mz mi mj lq na ml mm lu nb mo mp mq im bi translated">最后一类需要定义，它是一个具体的中介。</p><p id="fb3b" class="pw-post-body-paragraph ly lz it ma b mb mx kd md me my kg mg lm mz mi mj lq na ml mm lu nb mo mp mq im bi translated">看发送方法。如您所见，中介正在处理对象之间的通信。在这个具体的情况下，我在同事1和同事2之间传递信息，反之亦然。</p><p id="5781" class="pw-post-body-paragraph ly lz it ma b mb mx kd md me my kg mg lm mz mi mj lq na ml mm lu nb mo mp mq im bi translated">现在让我们进入Program.cs来使用所有这些。</p><p id="260d" class="pw-post-body-paragraph ly lz it ma b mb mx kd md me my kg mg lm mz mi mj lq na ml mm lu nb mo mp mq im bi translated">让我们实例化ConcreteMediator。然后我需要两个同事的实例作为对象c1和c2。请注意，我将中介传递给了两者。之后，我们还必须设置Mediator的两个属性，并由此定义已经提到的<strong class="ma jd">双向</strong>引用。现在我们不能开始发送消息。构建并运行代码。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nt"><img src="../Images/1221d69cb6c676142db6a40a72963d73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XbeCXAIWg_crECq-omr8gg.png"/></div></div></figure><p id="be14" class="pw-post-body-paragraph ly lz it ma b mb mx kd md me my kg mg lm mz mi mj lq na ml mm lu nb mo mp mq im bi translated">我们可以看到，同事之间互相传递和接收信息。</p><h2 id="1a78" class="ld le it bd lf lg lh dn li lj lk dp ll lm ln lo lp lq lr ls lt lu lv lw lx iz bi translated">结论</h2><p id="2780" class="pw-post-body-paragraph ly lz it ma b mb mc kd md me mf kg mg lm mh mi mj lq mk ml mm lu mn mo mp mq im bi translated">中介是对象之间的通信枢纽。它为您解析正确的消息方向。中介器的主要好处之一是能够封装对象间松散耦合的对象交互。</p><p id="c2c3" class="pw-post-body-paragraph ly lz it ma b mb mx kd md me my kg mg lm mz mi mj lq na ml mm lu nb mo mp mq im bi translated">请记住，模式只是导轨，而不是一成不变的指令性实现规则。许多不同的实现是可接受的。</p></div><div class="ab cl nu nv hx nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="im in io ip iq"><div class="ks kt ku kv gt ob"><a href="https://www.danielrusnok.com/daniel-rusnoks-newsletter" rel="noopener  ugc nofollow" target="_blank"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd jd gy z fp og fr fs oh fu fw jc bi translated">丹尼尔·鲁斯诺克的时事通讯</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">每个月我都会给你发一封电子邮件，列出我的最新文章。这当然是友好的联系…</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">www.danielrusnok.com</p></div></div><div class="ok l"><div class="ol l om on oo ok op lb ob"/></div></div></a></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><a href="https://www.buymeacoffee.com/danielrusnok"><div class="gh gi oq"><img src="../Images/88f0e07ab6797fc4fcd13ed7410af039.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/1*yzOQeIJSJCaRDN_oP5OidA.png"/></div></a></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><a href="https://itixo.com"><div class="gh gi or"><img src="../Images/f3d94d9b86b4ee7080bab6d72172b50a.png" data-original-src="https://miro.medium.com/v2/resize:fit:180/format:webp/1*mLQH7u1-b2HPVcLURnQ9NQ.png"/></div></a></figure></div></div>    
</body>
</html>