<html>
<head>
<title>Deploying a Simple Golang Webapp on Heroku</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Heroku上部署一个简单的Golang Webapp</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/deploying-a-simple-golang-webapp-on-heroku-4dbd00bc9b0e?source=collection_archive---------9-----------------------#2021-02-23">https://levelup.gitconnected.com/deploying-a-simple-golang-webapp-on-heroku-4dbd00bc9b0e?source=collection_archive---------9-----------------------#2021-02-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><h1 id="450a" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">如何将Golang Web应用程序部署到Heroku</h1><p id="0542" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><a class="ae lm" href="https://golang.org/" rel="noopener ugc nofollow" target="_blank"> Go编程语言</a>，通常被称为“golang”，已经在DevOps社区中获得了很多受之无愧的关注。许多最流行的工具如<a class="ae lm" href="https://www.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker </a>、<a class="ae lm" href="https://kubernetes.io/" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>和<a class="ae lm" href="https://www.terraform.io/" rel="noopener ugc nofollow" target="_blank"> Terraform </a>都是用Go编写的，但它也是构建web应用程序和API的一个很好的选择。</p><p id="021c" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">Go为您提供了编译语言的所有速度和性能，但感觉像是用解释语言编码。这归结为一个很棒的工具，你可以从默认提供的编译器、运行器、测试套件和代码格式化程序中获得。此外，为了最大限度地利用当今的多核或多cpu执行环境，Go社区发展如此迅速的原因显而易见。</p><p id="8e6a" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">Go给人的感觉是，它是根据特定的目标创建的，这导致了一种看似简单的语言设计，这种设计简单易学，而且不影响功能。</p><p id="84bb" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">在这篇文章中，我将向您展示在Go中开发一个简单的web应用程序，将其打包成一个轻量级Docker映像，并将其部署到<a class="ae lm" href="https://heroku.com/" rel="noopener ugc nofollow" target="_blank"> Heroku </a>是多么容易。我还将展示Go的一个相当新的特性:内置的包管理。</p><h1 id="0bdb" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">Go模块</h1><p id="d426" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">对于本文，我将使用Go的内置模块支持。</p><p id="319a" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">Go 1.0于2012年3月发布。直到1.11版本(2018年8月发布)，开发Go应用需要<a class="ae lm" href="https://golang.org/doc/gopath_code.html" rel="noopener ugc nofollow" target="_blank">为每个“工作区”管理一个GOPATH </a>，类似于java的<code class="fe ls lt lu lv b">JAVA_HOME</code>，你所有的Go源代码和任何第三方库都存储在<code class="fe ls lt lu lv b">GOPATH</code>下面。</p><p id="b045" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">我总是觉得这有点令人不快，相比之下，用Ruby或Javascript之类的语言开发代码，我可以用更简单的目录结构来隔离每个项目。在这两种语言中，一个文件(<code class="fe ls lt lu lv b">Gemfile</code>用于Ruby，<code class="fe ls lt lu lv b">package.json</code>用于Javascript)列出了所有的外部库，包管理器为我跟踪管理和安装依赖项。</p><blockquote class="lw lx ly"><p id="5455" class="ko kp lz kq b kr ln kt ku kv lo kx ky ma lp lb lc mb lq lf lg mc lr lj lk ll im bi translated"><em class="it">我不是说你不能管理</em> <code class="fe ls lt lu lv b"><em class="it">GOPATH</em></code> <em class="it">环境变量来将项目相互隔离。我特别发现包管理器方法更容易。</em></p></blockquote><p id="1563" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">谢天谢地，Go now内置了优秀的包管理，所以这不再是个问题。然而，您可能会发现在许多旧的博客帖子和文章中提到了<code class="fe ls lt lu lv b">GOPATH</code>,这可能有点令人困惑。</p><h1 id="3f87" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">你好，世界！</h1><p id="16d1" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">让我们开始我们的web应用程序。像往常一样，这将是一个非常简单的“你好，世界！”app，因为我想把重点放在开发和部署过程上，把这篇文章控制在合理的长度。</p><h1 id="4898" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">先决条件</h1><p id="e735" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">你需要:</p><ul class=""><li id="5588" class="md me it kq b kr ln kv lo kz mf ld mg lh mh ll mi mj mk ml bi translated">golang的最新版本(我用的是1.14.9。)</li><li id="ba1c" class="md me it kq b kr mm kv mn kz mo ld mp lh mq ll mi mj mk ml bi translated">码头工人</li><li id="aa67" class="md me it kq b kr mm kv mn kz mo ld mp lh mq ll mi mj mk ml bi translated">一个<a class="ae lm" href="https://heroku.com/" rel="noopener ugc nofollow" target="_blank"> Heroku </a>账户(免费账户在这个例子中运行良好。)</li><li id="4551" class="md me it kq b kr mm kv mn kz mo ld mp lh mq ll mi mj mk ml bi translated">Heroku命令行客户端</li><li id="d2cf" class="md me it kq b kr mm kv mn kz mo ld mp lh mq ll mi mj mk ml bi translated"><a class="ae lm" href="https://git-scm.com/" rel="noopener ugc nofollow" target="_blank"> git </a></li></ul><h1 id="942a" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">开始模式初始化</h1><p id="f78c" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">为了创建我们的新项目，我们需要为它创建一个目录，并使用<code class="fe ls lt lu lv b">go mod init</code>命令将其初始化为Go模块。</p><pre class="mr ms mt mu gt mv lv mw mx aw my bi"><span id="9218" class="mz jr it lv b gy na nb l nc nd">mkdir helloworld<br/>cd helloworld<br/>go mod init digitalronin/helloworld</span></pre><blockquote class="lw lx ly"><p id="7ec9" class="ko kp lz kq b kr ln kt ku kv lo kx ky ma lp lb lc mb lq lf lg mc lr lj lk ll im bi translated"><em class="it">通常的做法是使用您的github用户名来保持您的项目名称的全局唯一性，并避免与您的任何项目依赖项的名称冲突，但是您可以使用您喜欢的任何名称。</em></p></blockquote><p id="a134" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">现在您会在目录中看到一个<code class="fe ls lt lu lv b">go.mod</code>文件。这是Go跟踪任何项目依赖关系的地方。如果您查看该文件的内容，它们应该如下所示:</p><pre class="mr ms mt mu gt mv lv mw mx aw my bi"><span id="f08a" class="mz jr it lv b gy na nb l nc nd">module digitalronin/helloworld<br/><br/>go 1.14</span></pre><p id="8cac" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">让我们开始提交我们的更改:</p><pre class="mr ms mt mu gt mv lv mw mx aw my bi"><span id="8862" class="mz jr it lv b gy na nb l nc nd">git init<br/>git add *<br/>git commit -m "Initial commit"</span></pre><h1 id="b302" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">杜松子酒</h1><p id="3aaa" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们将在我们的web应用程序中使用<a class="ae lm" href="https://github.com/gin-gonic/gin" rel="noopener ugc nofollow" target="_blank"> gin </a>。Gin是一个轻量级的web框架，类似于Ruby的<a class="ae lm" href="http://sinatrarb.com/" rel="noopener ugc nofollow" target="_blank"> Sinatra </a>，Javascript的<a class="ae lm" href="https://expressjs.com/" rel="noopener ugc nofollow" target="_blank"> express.js </a>，或者Python的<a class="ae lm" href="https://pypi.org/project/Flask/" rel="noopener ugc nofollow" target="_blank"> Flask </a>。</p><p id="edb1" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">创建一个名为<code class="fe ls lt lu lv b">hello.go</code>的文件，包含以下代码:</p><pre class="mr ms mt mu gt mv lv mw mx aw my bi"><span id="cad7" class="mz jr it lv b gy na nb l nc nd">package main<br/><br/>import "github.com/gin-gonic/gin"<br/><br/>func main() {<br/>	r := gin.Default()<br/><br/>	r.GET("/hello", func(c *gin.Context) {<br/>		c.String(200, "Hello, World!")<br/>	})<br/><br/>	r.Run(":3000")<br/>}</span></pre><p id="00fe" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">让我们稍微分解一下:</p><p id="526f" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated"><code class="fe ls lt lu lv b">r := gin.Default()</code></p><p id="6e00" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">这将创建一个路由器对象<code class="fe ls lt lu lv b">r</code>，使用gin自带的默认设置。</p><p id="9670" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">然后，我们为路径<code class="fe ls lt lu lv b">/hello</code>的任何HTTP GET请求分配一个处理函数，并返回字符串“Hello，World！”和200 (HTTP OK)状态代码:</p><pre class="mr ms mt mu gt mv lv mw mx aw my bi"><span id="dc13" class="mz jr it lv b gy na nb l nc nd">        r.GET("/hello", func(c *gin.Context) {<br/>		c.String(200, "Hello, World!")<br/>	})</span></pre><p id="7cf4" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">最后，我们启动web服务器，并告诉它监听端口3000:</p><pre class="mr ms mt mu gt mv lv mw mx aw my bi"><span id="9bc4" class="mz jr it lv b gy na nb l nc nd">r.Run(":3000")</span></pre><p id="ab7f" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">要运行此代码，请执行:</p><p id="e1a8" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated"><code class="fe ls lt lu lv b">go run hello.go</code></p><p id="2941" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">您应该会看到如下输出:</p><pre class="mr ms mt mu gt mv lv mw mx aw my bi"><span id="8d91" class="mz jr it lv b gy na nb l nc nd">go: finding module for package github.com/gin-gonic/gin<br/>go: found github.com/gin-gonic/gin in github.com/gin-gonic/gin v1.6.3<br/>[GIN-debug] [WARNING] Creating an Engine instance with the Logger and Recovery middleware already attached.<br/><br/>[GIN-debug] [WARNING] Running in "debug" mode. Switch to "release" mode in production.<br/> - using env:   export GIN_MODE=release<br/> - using code:  gin.SetMode(gin.ReleaseMode)<br/><br/>[GIN-debug] GET    /hello                    --&gt; main.main.func1 (3 handlers)<br/>[GIN-debug] Listening and serving HTTP on :3000</span></pre><p id="d9f6" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">现在，如果你在网络浏览器中访问<code class="fe ls lt lu lv b">http://localhost:3000/hello</code>，你应该会看到“你好，世界！”</p><p id="d597" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">注意，我们不必单独安装gin，甚至不必编辑我们的<code class="fe ls lt lu lv b">go.mod</code>文件来声明它是一个依赖项。Go发现了这一点，并为我们做了必要的更改，这就是我们在输出中看到这些行时发生的情况:</p><pre class="mr ms mt mu gt mv lv mw mx aw my bi"><span id="2933" class="mz jr it lv b gy na nb l nc nd">go: finding module for package github.com/gin-gonic/gin<br/>go: found github.com/gin-gonic/gin in github.com/gin-gonic/gin v1.6.3</span></pre><p id="db38" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">如果您查看<code class="fe ls lt lu lv b">go.mod</code>文件，您会看到它现在包含以下内容:</p><pre class="mr ms mt mu gt mv lv mw mx aw my bi"><span id="9498" class="mz jr it lv b gy na nb l nc nd">module digitalronin/helloworld<br/><br/>go 1.14<br/><br/>require github.com/gin-gonic/gin v1.6.3 // indirect</span></pre><p id="5f30" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">你现在还会看到一个<code class="fe ls lt lu lv b">go.sum</code>文件。这是一个文本文件，包含对所有包依赖关系的特定版本的引用，以及它们的依赖关系，以及相关模块版本内容的加密散列。</p><p id="7520" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">对于Javascript项目来说,<code class="fe ls lt lu lv b">go.sum</code>文件的功能类似于<code class="fe ls lt lu lv b">package-lock.json</code>,或者在Ruby项目中类似于<code class="fe ls lt lu lv b">Gemfile.lock</code>,你应该总是将它和你的源代码一起签入版本控制。</p><p id="98f8" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">让我们现在就开始吧:</p><pre class="mr ms mt mu gt mv lv mw mx aw my bi"><span id="9d18" class="mz jr it lv b gy na nb l nc nd">git add *<br/>git commit -m "Add 'Hello world' web server"</span></pre><h1 id="56d6" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">提供HTML和JSON</h1><p id="7312" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我不打算深入研究用gin可以构建什么，但是我想演示更多的功能。特别是发送JSON响应和服务静态文件。</p><p id="5417" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">我们先来看看JSON的响应。将以下代码添加到您的<code class="fe ls lt lu lv b">hello.go</code>文件中，就在<code class="fe ls lt lu lv b">r.GET</code>块之后:</p><pre class="mr ms mt mu gt mv lv mw mx aw my bi"><span id="7c48" class="mz jr it lv b gy na nb l nc nd">api := r.Group("/api")<br/><br/>api.GET("/ping", func(c *gin.Context) {<br/>  c.JSON(200, gin.H{<br/>    "message": "pong",<br/>  })<br/>})</span></pre><p id="70cc" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">这里，我们在路径<code class="fe ls lt lu lv b">/api</code>后面创建了一个“组”路由，其中有一个路径<code class="fe ls lt lu lv b">/ping</code>，它将返回一个JSON响应。</p><p id="af55" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">有了这些代码，用<code class="fe ls lt lu lv b">go run</code>运行服务器，然后点击新的API端点:</p><p id="1bc1" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated"><code class="fe ls lt lu lv b">curl <a class="ae lm" href="http://localhost:3000/api/ping" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/api/ping</a></code></p><p id="963a" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">您应该得到响应:</p><p id="9146" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated"><code class="fe ls lt lu lv b">{"message":"pong"}</code></p><p id="0c4c" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">最后，让我们的web服务器服务静态文件。Gin为此提供了一个额外的库。</p><p id="750c" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">将<code class="fe ls lt lu lv b">hello.go</code>文件顶部的导入块改为:</p><pre class="mr ms mt mu gt mv lv mw mx aw my bi"><span id="6404" class="mz jr it lv b gy na nb l nc nd">import (<br/>	"github.com/gin-gonic/contrib/static"<br/>	"github.com/gin-gonic/gin"<br/>)</span></pre><blockquote class="lw lx ly"><p id="2182" class="ko kp lz kq b kr ln kt ku kv lo kx ky ma lp lb lc mb lq lf lg mc lr lj lk ll im bi translated"><em class="it">最流行的代码编辑器都有golang支持包，你可以安装它们，它们会自动为你处理</em> <code class="fe ls lt lu lv b"><em class="it">import</em></code> <em class="it">声明，当你在代码中使用新模块时，它们会自动更新。</em></p></blockquote><p id="a501" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">然后，在<code class="fe ls lt lu lv b">main</code>函数中添加这一行:</p><pre class="mr ms mt mu gt mv lv mw mx aw my bi"><span id="556f" class="mz jr it lv b gy na nb l nc nd">r.Use(static.Serve("/", static.LocalFile("./views", true)))</span></pre><p id="98d1" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">我们的web应用程序的完整代码现在如下所示:</p><p id="e085" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated"><code class="fe ls lt lu lv b">hello.go</code></p><pre class="mr ms mt mu gt mv lv mw mx aw my bi"><span id="a5a8" class="mz jr it lv b gy na nb l nc nd">package main<br/><br/>import (<br/>	"github.com/gin-gonic/contrib/static"<br/>	"github.com/gin-gonic/gin"<br/>)<br/><br/>func main() {<br/>	r := gin.Default()<br/><br/>	r.GET("/hello", func(c *gin.Context) {<br/>		c.String(200, "Hello, World!")<br/>	})<br/><br/>	api := r.Group("/api")<br/><br/>	api.GET("/ping", func(c *gin.Context) {<br/>		c.JSON(200, gin.H{<br/>			"message": "pong",<br/>		})<br/>	})<br/><br/>	r.Use(static.Serve("/", static.LocalFile("./views", true)))<br/><br/>	r.Run()<br/>}</span></pre><p id="e535" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated"><code class="fe ls lt lu lv b">r.Use(static.Serve...</code>行使我们的web服务器能够服务来自<code class="fe ls lt lu lv b">views</code>目录的任何静态文件，所以让我们添加一些:</p><pre class="mr ms mt mu gt mv lv mw mx aw my bi"><span id="b370" class="mz jr it lv b gy na nb l nc nd">mkdir -p views/css</span></pre><p id="52b1" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated"><code class="fe ls lt lu lv b">views/css/stylesheet.css</code></p><pre class="mr ms mt mu gt mv lv mw mx aw my bi"><span id="2478" class="mz jr it lv b gy na nb l nc nd">body {<br/>  font-family: Arial;<br/>}<br/><br/>h1 {<br/>  color: red;<br/>}</span></pre><p id="1bd6" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated"><code class="fe ls lt lu lv b">views/index.html</code></p><pre class="mr ms mt mu gt mv lv mw mx aw my bi"><span id="15d8" class="mz jr it lv b gy na nb l nc nd">&lt;html&gt;<br/>  &lt;head&gt;<br/>    &lt;link rel="stylesheet" href="/css/stylesheet.css" /&gt;<br/>  &lt;/head&gt;<br/>  &lt;body&gt;<br/>    &lt;h1&gt;Hello, World!&lt;/h1&gt;<br/>  &lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="72d1" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">现在，使用<code class="fe ls lt lu lv b">go run hello.go</code>重启网络服务器，并访问<code class="fe ls lt lu lv b">http://localhost:3000</code>，您应该会看到这样的消息:</p><figure class="mr ms mt mu gt nf gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi ne"><img src="../Images/5b83252474a0227e99d61dc1c3bb71b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*tIrhRF_eOQsOF4w7.png"/></div></div></figure><h1 id="54f0" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">归档</h1><p id="0dad" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们已经编写了go web应用程序，现在让我们将它打包成Docker图像。我们可以把它创建成Heroku buildpack，但是Go的一个很好的特性是你可以把你的软件作为一个单独的二进制文件分发。这是Go真正大放异彩的领域，使用基于Docker的Heroku部署让我们可以利用这一点。此外，这种技术并不局限于Go应用程序:您可以对任何语言的项目使用基于Docker的Heroku部署。所以，这是一个很好理解的技巧。</p><p id="9d72" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">到目前为止，我们已经用<code class="fe ls lt lu lv b">go run</code>命令运行了我们的代码。要将其编译成一个可执行的二进制文件，我们只需运行:</p><p id="1989" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated"><code class="fe ls lt lu lv b">go build</code></p><p id="14b8" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">这将编译我们所有的Go源代码并创建一个文件。默认情况下，输出文件将根据模块名命名，因此在我们的例子中，它将被称为<code class="fe ls lt lu lv b">helloworld</code>。</p><p id="7117" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">我们可以这样运行:</p><p id="5bc0" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated"><code class="fe ls lt lu lv b">./helloworld</code></p><p id="1b71" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">我们可以像以前一样访问相同的HTTP端点，无论是使用<code class="fe ls lt lu lv b">curl</code>还是我们的网络浏览器。</p><blockquote class="lw lx ly"><p id="4218" class="ko kp lz kq b kr ln kt ku kv lo kx ky ma lp lb lc mb lq lf lg mc lr lj lk ll im bi translated"><em class="it">静态文件没有编译成二进制，所以如果你把</em> <code class="fe ls lt lu lv b"><em class="it">helloworld</em></code> <em class="it">文件放在不同的目录下，它将找不到</em> <code class="fe ls lt lu lv b"><em class="it">views</em></code> <em class="it">目录来为我们的HTML和CSS内容服务。</em></p></blockquote><p id="d4c5" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">这就是我们为我们正在开发的任何平台(在我的例子中，我的Mac笔记本电脑)创建二进制文件所需要做的全部工作。然而，要在Docker容器中运行(为了最终部署到Heroku ),我们需要为Docker容器将要运行的任何架构编译一个二进制文件。</p><p id="6e05" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">我将使用<a class="ae lm" href="https://www.alpinelinux.org/" rel="noopener ugc nofollow" target="_blank"> alpine linux </a>，所以让我们在那个操作系统上构建我们的二进制文件。用以下内容创建一个<code class="fe ls lt lu lv b">Dockerfile</code>:</p><pre class="mr ms mt mu gt mv lv mw mx aw my bi"><span id="f5dc" class="mz jr it lv b gy na nb l nc nd">FROM golang:1.14.9-alpine<br/>RUN mkdir /build<br/>ADD go.mod go.sum hello.go /build/<br/>WORKDIR /build<br/>RUN go build</span></pre><p id="86b3" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">在这个映像中，我们从<code class="fe ls lt lu lv b">golang</code>基础映像开始，添加我们的源代码，并运行<code class="fe ls lt lu lv b">go build</code>来创建我们的<code class="fe ls lt lu lv b">helloworld</code>二进制文件。</p><p id="1f0f" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">我们可以这样建立我们的码头工人形象:</p><p id="7b1f" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated"><code class="fe ls lt lu lv b">docker build -t helloworld .</code></p><blockquote class="lw lx ly"><p id="d92a" class="ko kp lz kq b kr ln kt ku kv lo kx ky ma lp lb lc mb lq lf lg mc lr lj lk ll im bi translated"><em class="it">不要忘记该命令末尾的</em> <code class="fe ls lt lu lv b"><em class="it">.</em></code> <em class="it">。它告诉Docker我们想要使用当前目录作为构建上下文。</em></p></blockquote><p id="e1ad" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">这创建了一个Docker映像，其中包含我们的<code class="fe ls lt lu lv b">helloworld</code>二进制文件，但它也包含了所有需要<strong class="kq iu">编译</strong>我们的代码的Go工具，我们不希望在最终的部署映像中包含这些，因为这会使映像变得不必要的大。在Docker映像上安装不必要的可执行文件也有安全风险。</p><p id="4ede" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">我们可以看到Docker图像的大小，如下所示:</p><pre class="mr ms mt mu gt mv lv mw mx aw my bi"><span id="83c1" class="mz jr it lv b gy na nb l nc nd">$ docker images helloworld<br/>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE<br/>helloworld          latest              9657ec1ca905        4 minutes ago       370MB</span></pre><p id="afa9" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">相比之下，<code class="fe ls lt lu lv b">alpine</code>映像(一个轻量级linux发行版，通常用作docker映像的基础)要小得多:</p><pre class="mr ms mt mu gt mv lv mw mx aw my bi"><span id="8898" class="mz jr it lv b gy na nb l nc nd">$ docker images alpine<br/>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE<br/>alpine              latest              caf27325b298        20 months ago       5.53MB</span></pre><p id="1a36" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">在我的Mac上，<code class="fe ls lt lu lv b">helloworld</code>二进制文件大约有14MB，所以golang图像比它需要的要大得多。</p><p id="ec4a" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">我们想要做的是使用这个docker文件来<strong class="kq iu">构建</strong>我们的helloworld二进制文件以在alpine linux上运行，然后将编译后的二进制文件复制到alpine基础映像中，而不需要所有额外的golang工具。</p><p id="7f90" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">我们可以使用“多级”Docker构建来实现这一点。将docker文件更改为如下所示:</p><pre class="mr ms mt mu gt mv lv mw mx aw my bi"><span id="ef57" class="mz jr it lv b gy na nb l nc nd">FROM golang:1.14.9-alpine AS builder<br/>RUN mkdir /build<br/>ADD go.mod go.sum hello.go /build/<br/>WORKDIR /build<br/>RUN go build<br/><br/>FROM alpine<br/>RUN adduser -S -D -H -h /app appuser<br/>USER appuser<br/>COPY --from=builder /build/helloworld /app/<br/>COPY views/ /app/views<br/>WORKDIR /app<br/>CMD ["./helloworld"]</span></pre><p id="722a" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">在第一行，我们将最初的Docker图像标记为<code class="fe ls lt lu lv b">AS builder</code>。</p><p id="2408" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">稍后，我们切换到不同的基础映像<code class="fe ls lt lu lv b">FROM alpine</code>，然后从我们的构建器映像中复制<code class="fe ls lt lu lv b">helloworld</code>二进制文件，如下所示:</p><pre class="mr ms mt mu gt mv lv mw mx aw my bi"><span id="f21d" class="mz jr it lv b gy na nb l nc nd">COPY --from=builder /build/helloworld /app/</span></pre><p id="7ac9" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">建立新的Docker形象:</p><p id="3ed0" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated"><code class="fe ls lt lu lv b">docker build -t helloworld .</code></p><p id="d994" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">现在，这是你所期望的基本阿尔卑斯山图像加上我们的helloworld双星的大小:</p><pre class="mr ms mt mu gt mv lv mw mx aw my bi"><span id="d7bb" class="mz jr it lv b gy na nb l nc nd">$ docker images helloworld<br/>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE<br/>helloworld          latest              1d6d9cb64c7e        8 seconds ago       20.7MB</span></pre><p id="5245" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">我们可以像这样从Docker映像运行我们的web服务器。(如果您使用<code class="fe ls lt lu lv b">go run hello.go</code>或<code class="fe ls lt lu lv b">./helloworld</code>运行另一个版本，您需要首先停止那个版本，以释放端口3000。)</p><p id="0251" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated"><code class="fe ls lt lu lv b">docker run --rm -p 3000:3000 helloworld</code></p><blockquote class="lw lx ly"><p id="6427" class="ko kp lz kq b kr ln kt ku kv lo kx ky ma lp lb lc mb lq lf lg mc lr lj lk ll im bi translated"><em class="it">除了</em>  <em class="it">之外，</em> <code class="fe ls lt lu lv b"><em class="it">go run hello.go</em></code> <em class="it">和</em> <code class="fe ls lt lu lv b"><em class="it">./helloworld</em></code> <em class="it">版本</em> <strong class="kq iu"> <em class="it">中的web服务器都有自己的静态文件副本。因此，如果您更改了</em> <code class="fe ls lt lu lv b"><em class="it">views/</em></code> <em class="it">中的任何文件，您将不会看到这些更改，直到您重新构建Docker映像并重启容器。</em></strong></p></blockquote><h1 id="907a" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">部署到Heroku</h1><p id="a7e2" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">现在我们有了dockerized web应用程序，让我们将它部署到Heroku。Heroku是一个PaaS提供商，它简化了应用程序的部署和托管。您可以通过Heroku UI或Heroku CLI设置和部署您的应用程序。对于这个例子，我们将使用Heroku命令行应用程序。</p><h1 id="a9d6" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">从环境变量获取端口</h1><p id="288b" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">我们已经将我们的web服务器硬编码为在端口3000上运行，但这在Heroku上不起作用。相反，我们需要修改它，使其运行在环境变量<code class="fe ls lt lu lv b">PORT</code>中指定的端口号上，Heroku会自动提供这个端口号。</p><p id="a2a1" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">为此，修改靠近我们的<code class="fe ls lt lu lv b">hello.go</code>文件底部的<code class="fe ls lt lu lv b">r.Run</code>行，并删除<code class="fe ls lt lu lv b">":3000"</code>字符串值，这样该行变成:</p><p id="71db" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated"><code class="fe ls lt lu lv b">r.Run()</code></p><p id="e46d" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">gin的默认行为是在<code class="fe ls lt lu lv b">PORT</code>环境变量中的任何端口上运行(或者端口8080，如果没有指定的话)。这正是Heroku需要的行为。</p><h1 id="b50e" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">设置我们的Heroku应用程序</h1><p id="6080" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">首先，登录Heroku:</p><p id="38d6" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated"><code class="fe ls lt lu lv b">heroku login</code></p><p id="41a6" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">现在，创建一个应用:</p><p id="c399" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated"><code class="fe ls lt lu lv b">heroku create</code></p><p id="cff7" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">告诉Heroku我们想使用docker文件而不是buildpack来构建这个项目:</p><p id="c8e0" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated"><code class="fe ls lt lu lv b">heroku stack:set container</code></p><p id="b89b" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">为此，我们还需要创建一个<code class="fe ls lt lu lv b">heroku.yml</code>文件，如下所示:</p><pre class="mr ms mt mu gt mv lv mw mx aw my bi"><span id="aa56" class="mz jr it lv b gy na nb l nc nd">build:<br/>  docker:<br/>    web: Dockerfile<br/><br/>run:<br/>  web: ./helloworld</span></pre><p id="03af" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated"><code class="fe ls lt lu lv b">heroku.yml</code>文件是一个清单，它定义了我们的应用程序，并允许我们指定在应用程序供应期间使用的附加组件和配置变量。</p><p id="2053" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">接下来，添加git并提交这些文件，然后推送到heroku进行部署:</p><p id="1403" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated"><code class="fe ls lt lu lv b">git push heroku main</code></p><blockquote class="lw lx ly"><p id="3ad4" class="ko kp lz kq b kr ln kt ku kv lo kx ky ma lp lb lc mb lq lf lg mc lr lj lk ll im bi translated"><em class="it">我的git配置使用</em> <code class="fe ls lt lu lv b"><em class="it">main</em></code> <em class="it">作为默认分支。如果你的默认分支叫做</em> <code class="fe ls lt lu lv b"><em class="it">master</em></code> <em class="it">，那么改为运行</em> <code class="fe ls lt lu lv b"><em class="it">git push heroku master</em></code> <em class="it">。</em></p></blockquote><p id="e868" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">您应该看到Heroku从您的Docker文件构建图像，并将其推送到Heroku Docker注册表。命令完成后，您可以通过运行以下命令在浏览器中查看部署的应用程序:</p><p id="211b" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated"><code class="fe ls lt lu lv b">heroku open</code></p><h1 id="746b" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">结论</h1><p id="efa1" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">简单回顾一下，下面是我们今天所学内容的总结:</p><ul class=""><li id="8e6f" class="md me it kq b kr ln kv lo kz mf ld mg lh mh ll mi mj mk ml bi translated">创建golang web应用程序，使用go模块和gin web框架来提供字符串、JSON和静态文件</li><li id="ec5f" class="md me it kq b kr mm kv mn kz mo ld mp lh mq ll mi mj mk ml bi translated">使用多级Docker文件创建轻量级Docker映像</li><li id="329d" class="md me it kq b kr mm kv mn kz mo ld mp lh mq ll mi mj mk ml bi translated">使用<code class="fe ls lt lu lv b">heroku stack:set container</code>和<code class="fe ls lt lu lv b">heroku.yml</code>文件将基于Docker的应用程序部署到Heroku</li></ul><p id="6e3c" class="pw-post-body-paragraph ko kp it kq b kr ln kt ku kv lo kx ky kz lp lb lc ld lq lf lg lh lr lj lk ll im bi translated">关于如何使用Go构建web应用程序和API，我在本文中只触及了皮毛。我希望这足以让您开始使用自己的golang web应用程序。</p></div></div>    
</body>
</html>