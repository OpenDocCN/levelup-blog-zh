<html>
<head>
<title>Simple caching with local storage</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用本地存储的简单缓存</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/simple-caching-with-local-storage-bbb02dd12d7a?source=collection_archive---------5-----------------------#2020-04-17">https://levelup.gitconnected.com/simple-caching-with-local-storage-bbb02dd12d7a?source=collection_archive---------5-----------------------#2020-04-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c083" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">电脑很快。非常快。那么，为什么我们会在网上看到这么多的加载spinners，并且要等这么长时间才能加载东西呢…</h2></div><p id="a9b8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">电脑很快。非常快。那么，为什么我们会在网上看到这么多加载微调器，并且要等这么长时间才能加载呢？因为网络很慢！在世界各地发送信息很慢，通过使用出色的第三方服务来解决我们的问题——Netlify、Stripe、AWS等——在用户有机会与页面交互之前，我们的webapps可以向世界各地发出请求。这是一个要解决的复杂问题，可能需要很多聪明的devops人员和技术领导，或者我们可以在JS中解决一部分吗？剧透，我们可以！</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="e449" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的视频和这篇博客的例子一样，但是对于那些视觉学习者/在实现缓存的时候想要一些额外的陪伴的人来说可能更有趣！</p><p id="803b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">比方说，我们有一个请求，点击东尼·霍克职业选手API并请求所有选手。</p><blockquote class="li lj lk"><p id="a874" class="kf kg ll kh b ki kj jr kk kl km ju kn lm kp kq kr ln kt ku kv lo kx ky kz la ij bi translated">注意:为了简单起见，我使用了axios库，但这肯定可以用fetch来完成</p></blockquote><pre class="lb lc ld le gt lp lq lr ls aw lt bi"><span id="d242" class="lu lv iq lq b gy lw lx l ly lz">import axios from 'axios'<br/><br/>const getSkaters = async () =&gt; {<br/>  const url = 'https://thps.now.sh/api/skaters'<br/><br/>  // wait for a response from the API<br/>  const { data } = await axios.get(url)<br/><br/>  return data<br/>}</span></pre><p id="f9f4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这将返回如下所示的响应。</p><pre class="lb lc ld le gt lp lq lr ls aw lt bi"><span id="f687" class="lu lv iq lq b gy lw lx l ly lz">[<br/>  {<br/>    "name": "Tony Hawk",<br/>    "style": "Vert",<br/>    "stance": "Goofy",<br/>    "speed": 6,<br/>    "air": 7,<br/>    "hangtime": 5<br/>  },<br/>  {<br/>    "name": "Bob Burnquist",<br/>    "style": "All around",<br/>    "stance": "Regular",<br/>    "speed": 5,<br/>    "air": 6,<br/>    "hangtime": 5<br/>  },<br/>  ...<br/>]</span></pre><p id="dc03" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每次我们调用<code class="fe ma mb mc lq b">getSkaters()</code>函数时，我们都在等待我们的应用程序向托尼·霍克API发送请求。在理想情况下，这可能只需要几毫秒的时间——低API流量，小数据集，我们的应用程序和API托管在相似的地理位置——但要解决我敢肯定你们都在想的问题，每天肯定有数百万人整天都想不停地访问API以获得那些甜蜜的溜冰者统计数据！</p><p id="c444" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们不能对第一个请求做太多事情，因为客户端不知道球员的统计数据，直到我们的API告诉他们，但是，我们可以在第一次实现我们自己的缓存数据的方法——使它在没有到API服务器的完整往返的情况下可用。现在，我们将如何建立一个缓存？缓存只是我们记得从特定请求(或URL)中获取的一些数据。谢天谢地，浏览器有这个奇妙而简单的方法来存储数据，叫做<code class="fe ma mb mc lq b">localStorage</code>。</p><pre class="lb lc ld le gt lp lq lr ls aw lt bi"><span id="3642" class="lu lv iq lq b gy lw lx l ly lz">localStorage.setItem(key, data) // writes the data against that key<br/><br/>localStorage.getItem(key) // returns the data associated with that key</span></pre><p id="ec3c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">LocalStorage允许我们从浏览器的存储中读取和写入键/值对。要将一些数据写入localStorage，我们需要一个键——用来标识我们的数据的唯一的东西——以及我们想要存储在那里的数据。让我们构建一些方便的函数来与localStorage接口。</p><pre class="lb lc ld le gt lp lq lr ls aw lt bi"><span id="f6c8" class="lu lv iq lq b gy lw lx l ly lz">// src/utils/cache.js<br/><br/>const writeToCache = (url, data) =&gt;<br/>  localStorage.setItem(url, JSON.stringify(data))<br/><br/>const readFromCache = url =&gt; JSON.parse(localStorage.getItem(url)) || null<br/><br/>export { readFromCache, writeToCache }</span></pre><p id="dad5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">希望您对上面使用的ES6语法、箭头函数和隐式返回感到满意。如果没有，这是两个从缓存中抽象读写的函数。<code class="fe ma mb mc lq b">=&gt;</code>右边的是从函数返回的内容。</p><p id="0cf8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用<code class="fe ma mb mc lq b">url</code>作为我们的密钥，因为它总是独一无二的。</p><p id="0ddc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里还发生了一些奇怪的事情，尤其是<code class="fe ma mb mc lq b">parse</code>和<code class="fe ma mb mc lq b">stringify</code>。这些函数互为反函数。一个获取一个json对象并将其转换成一个大字符串(stringify)，另一个获取一个大字符串并将其转换成一个json对象(parse)。这是必需的，因为localStorage只允许我们存储字符串。</p><p id="2675" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ma mb mc lq b">||</code>语法用于提供一个回退值。因此，我们检查是否有任何存储在该url下的数据可以解析成json对象，如果没有，我们希望返回<code class="fe ma mb mc lq b">null</code>。</p><p id="1a78" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ma mb mc lq b">export</code>用于从文件中暴露这些函数，以便其他文件可以<code class="fe ma mb mc lq b">import</code>它们。</p><p id="89da" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们希望将我们的请求从我们的<code class="fe ma mb mc lq b">getSkaters()</code>函数中抽象出来，使它更通用，更可缓存。</p><pre class="lb lc ld le gt lp lq lr ls aw lt bi"><span id="eb1e" class="lu lv iq lq b gy lw lx l ly lz">// src/utils/request.js<br/><br/>import axios from 'axios'<br/>import { writeToCache } from './cache'<br/><br/>const getFreshData = async (url, cacheResponse = false) =&gt; {<br/>  const { data } = await axios.get(url)<br/>  cacheResponse &amp;&amp; writeToCache(url, data)<br/>  return data<br/>}</span></pre><p id="14c6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，我们正在创建一个新文件来抽象出我们的可重用逻辑。我们的<code class="fe ma mb mc lq b">getFreshData()</code>函数现在接受一个<code class="fe ma mb mc lq b">url</code>和一个<code class="fe ma mb mc lq b">cacheResponse</code>布尔值。<code class="fe ma mb mc lq b">url</code>用于从API请求我们的数据，而<code class="fe ma mb mc lq b">cacheResponse</code>告诉我们的函数是否要将响应写入缓存。让我们扩展这个文件以包含一个<code class="fe ma mb mc lq b">getCachedData()</code>函数。</p><pre class="lb lc ld le gt lp lq lr ls aw lt bi"><span id="55e6" class="lu lv iq lq b gy lw lx l ly lz">const getCachedData = url =&gt; readFromCache(url)</span></pre><p id="84a1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个文件实际上只是包装了<code class="fe ma mb mc lq b">readFromCache</code>，但这意味着任何需要请求数据的东西都可以使用这个文件，而不管他们想要的是新内容还是缓存的内容。该文件的最终版本应该如下所示。</p><pre class="lb lc ld le gt lp lq lr ls aw lt bi"><span id="bb5a" class="lu lv iq lq b gy lw lx l ly lz">import axios from 'axios'<br/>import { readFromCache, writeToCache } from './cache'<br/><br/>const getFreshData = async (url, cacheResponse = false) =&gt; {<br/>  const { data } = await axios.get(url)<br/>  cacheResponse &amp;&amp; writeToCache(url, data)<br/>  return data<br/>}<br/><br/>const getCachedData = url =&gt; readFromCache(url)<br/><br/>export { getCachedData, getFreshData }</span></pre><p id="d9e3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们创建我们的<code class="fe ma mb mc lq b">Skaters</code>组件。</p><pre class="lb lc ld le gt lp lq lr ls aw lt bi"><span id="a9f9" class="lu lv iq lq b gy lw lx l ly lz">import React, { useState } from 'react'<br/><br/>const renderSkater = ({ name, stance }) =&gt; (<br/>  &lt;div key={name}&gt;<br/>    &lt;p&gt;<br/>      {name} - {stance}<br/>    &lt;/p&gt;<br/>  &lt;/div&gt;<br/>)<br/><br/>const Skaters = () =&gt; {<br/>  const [skaters, setSkaters] = useState([])<br/><br/>  return (<br/>    &lt;&gt;<br/>      &lt;div&gt;{skaters.map(renderSkater)}&lt;/div&gt;<br/>      &lt;button&gt;Load&lt;/button&gt;<br/>    &lt;/&gt;<br/>  )<br/>}<br/><br/>export default Skaters</span></pre><p id="c5c7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这只是简单地交互一组溜冰者并显示每个人的名字和姿势。</p><p id="59a5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们扩展它以获取一个<code class="fe ma mb mc lq b">useCache</code>道具，并请求一个新的或缓存版本的溜冰者。</p><pre class="lb lc ld le gt lp lq lr ls aw lt bi"><span id="0068" class="lu lv iq lq b gy lw lx l ly lz">import React, { useState } from 'react'<br/>import { getCachedData, getFreshData } from './utils/request'<br/><br/>const url = 'https://thps.now.sh/api/skaters'<br/><br/>const renderSkater = ({ name, stance }) =&gt; (<br/>  &lt;div key={name}&gt;<br/>    &lt;p&gt;<br/>      {name} - {stance}<br/>    &lt;/p&gt;<br/>  &lt;/div&gt;<br/>)<br/><br/>const Skaters = ({ useCache }) =&gt; {<br/>  const [skaters, setSkaters] = useState([])<br/><br/>  const getSkaters = async () =&gt; {<br/>    setSkaters([])<br/><br/>    if (useCache) {<br/>      const cachedSkaters = getCachedData(url)<br/>      if (cachedSkaters) {<br/>        setSkaters(cachedSkaters)<br/>      }<br/>    } else {<br/>      const freshSkaters = await getFreshData(url, useCache)<br/>      setSkaters(freshSkaters)<br/>    }<br/>  }<br/><br/>  return (<br/>    &lt;div&gt;<br/>      &lt;div&gt;{skaters.map(renderSkater)}&lt;/div&gt;<br/>      &lt;button onClick={getSkaters}&gt;Load&lt;/button&gt;<br/>    &lt;/div&gt;<br/>  )<br/>}<br/><br/>export default Skaters</span></pre><p id="2b84" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">很好，现在我们可以呈现我们的溜冰者组件了，要么显示缓存中的溜冰者列表，要么从API请求一个新的副本。不过这里有几个bug。</p><ol class=""><li id="b0e8" class="md me iq kh b ki kj kl km ko mf ks mg kw mh la mi mj mk ml bi translated">如果我们还没有请求新的选手并将他们写入缓存，我们实际上不能显示缓存中的选手。</li><li id="695e" class="md me iq kh b ki mm kl mn ko mo ks mp kw mq la mi mj mk ml bi translated">一旦我们将溜冰者写入缓存，他们就永远在那里了。如果API更新，我们永远也不能覆盖它们或者得到新的溜冰者。</li></ol><p id="bb6f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">解决这两个问题并显著改善用户体验的方法是，首先请求缓存版本，然后请求新的副本，而不管它是否在缓存中。这意味着如果我们有一个缓存版本，它会立即显示，当新的内容可用时，它会自动更新用户界面。这听起来很复杂，但我们真正要做的是移除包装新请求逻辑的<code class="fe ma mb mc lq b">else</code>。</p><pre class="lb lc ld le gt lp lq lr ls aw lt bi"><span id="d667" class="lu lv iq lq b gy lw lx l ly lz">import React, { useState } from 'react'<br/>import { getCachedData, getFreshData } from './utils/request'<br/><br/>const url = 'https://thps.now.sh/api/skaters'<br/><br/>const renderSkater = ({ name, stance }) =&gt; (<br/>  &lt;div key={name}&gt;<br/>    &lt;p&gt;<br/>      {name} - {stance}<br/>    &lt;/p&gt;<br/>  &lt;/div&gt;<br/>)<br/><br/>const Skaters = ({ useCache }) =&gt; {<br/>  const [skaters, setSkaters] = useState([])<br/><br/>  const getSkaters = async () =&gt; {<br/>    setSkaters([])<br/><br/>    if (useCache) {<br/>      const cachedSkaters = getCachedData(url)<br/>      if (cachedSkaters) {<br/>        setSkaters(cachedSkaters)<br/>      }<br/>    }<br/><br/>    const freshSkaters = await getFreshData(url, useCache)<br/>    setSkaters(freshSkaters)<br/>  }<br/><br/>  return (<br/>    &lt;div&gt;<br/>      &lt;div&gt;{skaters.map(renderSkater)}&lt;/div&gt;<br/>      &lt;button onClick={getSkaters}&gt;Load&lt;/button&gt;<br/>    &lt;/div&gt;<br/>  )<br/>}<br/><br/>export default Skaters</span></pre><p id="4607" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">厉害！现在，我们的用户将立即看到缓存的版本，并在API响应后收到任何更新。这里有一个gif演示了这是什么样子。</p><figure class="lb lc ld le gt lf gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/510ff989c941c69dbfc4c923874d2c07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1088/1*M3cZ_pHq1eezHeDN4hb18A.gif"/></div></figure><p id="dd17" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如你所看到的，我们不能在用户第一次访问页面时提供缓存版本，但是每次他们回来看到那些甜蜜的溜冰者统计数据时，我们可以让体验感觉更加灵敏！</p><p id="e51c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">看看这个例子的<a class="ae mu" href="https://thps.now.sh/" rel="noopener ugc nofollow" target="_blank">现场版本</a>或者<a class="ae mu" href="https://github.com/dijonmusters/thps" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>看看它们是如何一起点击的！</p><blockquote class="li lj lk"><p id="4c89" class="kf kg ll kh b ki kj jr kk kl km ju kn lm kp kq kr ln kt ku kv lo kx ky kz la ij bi translated">注意:您需要清除dev工具中的本地存储，以便在缓存版本中再次看到第一个请求(右图)。</p></blockquote><p id="b02a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在下一篇博客中，我们将着眼于把<code class="fe ma mb mc lq b">getCachedData()</code>和<code class="fe ma mb mc lq b">getFreshData()</code>抽象成我们可以在任何应用程序中使用的钩子！</p></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><div class="lb lc ld le gt nc"><a href="https://skilled.dev" rel="noopener  ugc nofollow" target="_blank"><div class="nd ab fo"><div class="ne ab nf cl cj ng"><h2 class="bd ir gy z fp nh fr fs ni fu fw ip bi translated">编写面试问题</h2><div class="nj l"><h3 class="bd b gy z fp nh fr fs ni fu fw dk translated">一个完整的平台，在这里我会教你找到下一份工作所需的一切，以及…</h3></div><div class="nk l"><p class="bd b dl z fp nh fr fs ni fu fw dk translated">技术开发</p></div></div><div class="nl l"><div class="nm l nn no np nl nq ms nc"/></div></div></a></div></div></div>    
</body>
</html>