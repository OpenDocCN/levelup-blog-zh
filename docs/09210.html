<html>
<head>
<title>Circular Locks and Graph Theory</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">圆形锁和图论</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/circular-locks-and-graph-theory-472ad8e1e66d?source=collection_archive---------8-----------------------#2021-07-15">https://levelup.gitconnected.com/circular-locks-and-graph-theory-472ad8e1e66d?source=collection_archive---------8-----------------------#2021-07-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/5aa47594949f861b58ac33e3de0ea276.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S0yu3ECqFFjVPEV63lLm7g.jpeg"/></div></div></figure><div class=""/></div><div class="ab cl kb kc hx kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="im in io ip iq"><p id="e8bd" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated"><em class="lg">这篇短文将探讨在编码面试中，图论算法如何出现在看似不相关的问题中。</em></p><p id="3bff" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated"><em class="lg">随意探索</em> <a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/arbitrage-and-graph-theory-ecd26391908b"> <em class="lg">往期</em> </a> <em class="lg"> </em> <a class="ae lh" href="https://cppcodingzen.medium.com/cycles-in-directed-graphs-in-unexpected-places-c5306460b60e" rel="noopener"> <em class="lg">帖子</em> </a> <em class="lg">阅读更多涉及图算法的问题(及其解答)</em></p></div><div class="ab cl kb kc hx kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="im in io ip iq"><h1 id="fd57" class="li lj je bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">问题:</h1><p id="f50d" class="pw-post-body-paragraph ki kj je kk b kl mg kn ko kp mh kr ks kt mi kv kw kx mj kz la lb mk ld le lf im bi translated">给你一个有三个轮子的圆形锁，每个轮子都按顺序显示数字<code class="fe ml mm mn mo b">0</code>到<code class="fe ml mm mn mo b">9</code>。这些轮子中的每一个都顺时针和逆时针旋转。</p><p id="8576" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">此外，锁有一定数量的“死胡同”，这意味着如果你把轮子转到这些组合中的一个，锁就会卡在那个状态，无法打开。</p><p id="b1e4" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">让我们把“移动”看作是单个轮子在任一方向上转动一个数字。给定一个初始设置为<code class="fe ml mm mn mo b">000</code>的锁、一个目标组合和一个死胡同列表，编写一个函数，返回达到目标状态所需的最少移动次数，如果不可能，则编写<code class="fe ml mm mn mo b">-1</code>。</p><h1 id="56ff" class="li lj je bd lk ll mp ln lo lp mq lr ls lt mr lv lw lx ms lz ma mb mt md me mf bi translated">解决方案:</h1><p id="37a6" class="pw-post-body-paragraph ki kj je kk b kl mg kn ko kp mh kr ks kt mi kv kw kx mj kz la lb mk ld le lf im bi translated">这个问题有一个基于图算法的显而易见的解决方案——只要你正确地表述它。这里有一种表达算法的方法:</p><ol class=""><li id="fb36" class="mu mv je kk b kl km kp kq kt mw kx mx lb my lf mz na nb nc bi translated">每个锁的组合，就像<code class="fe ml mm mn mo b">{1, 2, 3}</code>一样，构成了图形的一个节点。</li><li id="699f" class="mu mv je kk b kl nd kp ne kt nf kx ng lb nh lf mz na nb nc bi translated">一位数不同的组合形成图的相邻节点(并通过边连接)(例如<code class="fe ml mm mn mo b">{1, 2, 3}</code>的邻居是<code class="fe ml mm mn mo b">{0, 2, 3}, {2, 2, 3}, {1, 1, 3}, {1, 3, 3}, {1, 2, 2}, {1, 2, 4}</code>)。</li><li id="af0c" class="mu mv je kk b kl nd kp ne kt nf kx ng lb nh lf mz na nb nc bi translated">“死胡同”在图中根本不存在，没有边进出它们！</li><li id="ee14" class="mu mv je kk b kl nd kp ne kt nf kx ng lb nh lf mz na nb nc bi translated">寻找最少移动次数的问题归结为寻找这个图中的最短路径！它可以使用标准的图形算法来解决，如<em class="lg">广度优先搜索(BFS) </em>！</li></ol><p id="abce" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">在实现BFS算法之前，让我们先做一些准备:我们将定义数据结构来表示一个密码锁。我们将使用一个三元素数组<code class="fe ml mm mn mo b">std::array&lt;int, 3&gt;</code>来完成这个任务。此外，</p><ol class=""><li id="ffdd" class="mu mv je kk b kl km kp kq kt mw kx mx lb my lf mz na nb nc bi translated">我们将定义一个<code class="fe ml mm mn mo b">unordered_set</code>锁组合来存储访问过的锁组合。为了定义集合，我们需要在<code class="fe ml mm mn mo b">std::array</code>上定义一个哈希函数。我们的散列函数将简单地把数组转换成一个三位数的整数(<code class="fe ml mm mn mo b">arr[0] * 100 + arr[1] * 10 + arr[2]</code>)。</li><li id="268d" class="mu mv je kk b kl nd kp ne kt nf kx ng lb nh lf mz na nb nc bi translated">最后，我们需要定义一个队列类型来保持一对锁的组合和步数(int): <code class="fe ml mm mn mo b">std::queue&lt;std::pair&lt;std::array&lt;int, 3&gt;, int&gt;&gt;</code>。</li></ol><figure class="ni nj nk nl gt iv"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="54f7" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">我们现在准备实现我们主要的<em class="lg">广度优先搜索(BFS) </em>算法，系统地迭代不同的锁组合，找到从初始组合<code class="fe ml mm mn mo b">{0, 0, 0}</code>到目标组合的最短路径。</p><ol class=""><li id="e3df" class="mu mv je kk b kl km kp kq kt mw kx mx lb my lf mz na nb nc bi translated">我们将初始节点<code class="fe ml mm mn mo b">{0, 0, 0}</code>插入到BFS <em class="lg">队列中。</em>我们还插入<code class="fe ml mm mn mo b">0</code>来表示达到初始状态所需的最少移动次数。</li><li id="0e45" class="mu mv je kk b kl nd kp ne kt nf kx ng lb nh lf mz na nb nc bi translated">在每次迭代中，我们弹出队列的最前面。我们计算队列前面的<em class="lg">有效</em>邻居。有效邻居被定义为先前没有被访问过并且不是死角的邻居节点。</li><li id="94f8" class="mu mv je kk b kl nd kp ne kt nf kx ng lb nh lf mz na nb nc bi translated">我们将步数加1，并将每个有效的邻居连同这个步数一起插入BSF队列。</li><li id="185c" class="mu mv je kk b kl nd kp ne kt nf kx ng lb nh lf mz na nb nc bi translated">一旦到达目标节点，我们就返回步数。如果我们清空BFS队列，并且从未到达目标节点，我们返回-1，表示目标节点不可到达。</li></ol><p id="aa56" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">下面是使用上面定义的数据结构的C++实现:</p><figure class="ni nj nk nl gt iv"><div class="bz fp l di"><div class="nm nn l"/></div></figure><h1 id="01d9" class="li lj je bd lk ll mp ln lo lp mq lr ls lt mr lv lw lx ms lz ma mb mt md me mf bi translated">测试:</h1><p id="f7e1" class="pw-post-body-paragraph ki kj je kk b kl mg kn ko kp mh kr ks kt mi kv kw kx mj kz la lb mk ld le lf im bi translated">下面是一些可以尝试的测试案例:</p><ol class=""><li id="f7bc" class="mu mv je kk b kl km kp kq kt mw kx mx lb my lf mz na nb nc bi translated">“不可能”的目的地，即所有路径都通向死胡同的目的地</li><li id="8318" class="mu mv je kk b kl nd kp ne kt nf kx ng lb nh lf mz na nb nc bi translated">没有死角</li><li id="290b" class="mu mv je kk b kl nd kp ne kt nf kx ng lb nh lf mz na nb nc bi translated">死胡同/目的地的复杂组合。</li></ol><figure class="ni nj nk nl gt iv"><div class="bz fp l di"><div class="nm nn l"/></div></figure></div><div class="ab cl kb kc hx kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="im in io ip iq"><p id="e5dc" class="pw-post-body-paragraph ki kj je kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated"><em class="lg">原载于</em> <a class="ae lh" href="https://cppcodingzen.com/?p=3202" rel="noopener ugc nofollow" target="_blank"> <em class="lg"> https://This。com</em></a><em class="lg">2021年7月15日。</em></p></div></div>    
</body>
</html>