<html>
<head>
<title>What Does Kubernetes Do, Anyway?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes到底是做什么的？</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/what-does-kubernetes-do-anyway-fa4efc3b57f8?source=collection_archive---------6-----------------------#2020-02-20">https://levelup.gitconnected.com/what-does-kubernetes-do-anyway-fa4efc3b57f8?source=collection_archive---------6-----------------------#2020-02-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="577b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">你知道这是革命性的。你知道这是你应该学的东西。你只是不知道它有什么用。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6f3139b70e73da1f3d88ac557629de39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*eQonmCsOTJ7HFz0p"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">丹尼尔·利维斯·佩鲁西在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="411c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你开发软件，你会知道Kubernetes是最近的热门话题。随着Kubernetes的普及，它已经改变了我们部署应用程序的方式。它正迅速成为一种标准，越来越多的工程师被期望学习如何使用它。</p><p id="a360" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了当你弄不清楚它到底<em class="lv">做什么</em>的时候，你很难去了解它。</p><h1 id="e85c" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">解释库伯内特的另一种方法</h1><p id="e0f0" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我最近经常使用Kubernetes。但就在不久前，当我不断听到它的时候，我根本不知道它是什么。我花了很多时间在网上搜索，询问同事，阅读Kubernetes的书籍。最终，一些事情发生了，Kubernetes突然明白了。事实证明，Kubernetes相当简单——至少在概念上是这样。但是当你是一个初学者的时候，它确实看起来不是这样的。</p><p id="d90e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回顾我读过的所有资料，似乎它们都集中在Kubernetes的“如何”上，并假设读者对“是什么”和“为什么”有基本的理解。</p><p id="a3df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我希望在学习Kubernetes时就有的文章。在这里，我们将走一条不同于大多数其他在线资源的道路:</p><ul class=""><li id="a734" class="mt mu it lb b lc ld lf lg li mv lm mw lq mx lu my mz na nb bi translated">我们将研究导致库伯内特斯的历史。Kubernetes并不是突然出现的，而是devops发展过程中的一个环节，以满足特定的需求。</li><li id="434d" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">我们将更多地关注概念，而不是技术细节。事实上，无论如何我都不是Kubernetes专家。虽然我不打算提供任何错误的信息(当然),但我将依靠隐喻和抽象来帮助理解这一点。</li><li id="1b6d" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">为了真正掌握Kubernetes，我们将把重点放在作为工程师的你特别需要理解的事情上。</li></ul><p id="3c3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦你了解了Kubernetes存在的原因和它的作用，并从概念的角度理解了它，<em class="lv">然后</em>你就可以开始钻研现有的在线资源了。</p></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><h1 id="5c70" class="lw lx it bd ly lz no mb mc md np mf mg jz nq ka mi kc nr kd mk kf ns kg mm mn bi translated">回到过去</h1><p id="a53c" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">在我们进入Kubernetes之前，让我们从头开始。很久以前，当我们都还在学习“万维网”现象的时候。当人们刚刚意识到互联网不仅仅是一个学术上的好奇心，它实际上可能是一个赚钱的平台。</p><p id="29b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们在谈论，像，几十年前。</p><p id="4107" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当时，网站直接在硬件上运行。从字面上看，几乎每个“网络公司”都有巨大的空调房间(要么在内部，要么在数据中心),其中他们的服务器——披萨盒大小的金属盒，为他们的网站、数据库等提供动力——发出咔哒咔哒的声音，散发出热量和强烈的金属气味。</p><p id="228a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">重要的是，出于安全和资源管理的原因，一个应用程序的一个实例运行在一台物理服务器上。这意味着10台Apache服务器(每台服务器都由一台WebLogic应用服务器支持)访问一个Oracle数据库需要21台物理服务器。此外，增加额外的容量来处理增加的负载实际上需要在机架中安装新的物理服务器。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/88c715e1e14478ccde4dd53cd26886f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*z04YU40oVmZO8awg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">那时候是这样的</figcaption></figure><p id="43e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它很贵。当涉及到测试之类的事情时，它也容易出错。很难确保测试环境与生产环境完全匹配，开发人员也不可能在任何类似生产的环境中进行本地测试。操作系统、应用服务器版本等方面的差异。在不同的环境中，无法保证在将变更部署到生产环境之前，能够对其进行充分的测试。</p><h2 id="783f" class="nu lx it bd ly nv nw dn mc nx ny dp mg li nz oa mi lm ob oc mk lq od oe mm of bi translated">虚拟化</h2><p id="6853" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">虚拟化开始改变这种状况。<a class="ae ky" href="https://en.wikipedia.org/wiki/Virtual_machine" rel="noopener ugc nofollow" target="_blank">虚拟机(VMs) </a>的出现让我们可以在一台物理机上运行多个独立的操作系统实例。这意味着单个物理服务器现在可以托管多个应用程序，同时仍然保持应用程序隔离。与其在硬件上花费大量金钱，组织现在可以简单地花费大量金钱。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/8fcfad3a44dfd5b785793fb741d8b8e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BeQDIZ95PbxUXx5P"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">较好的</figcaption></figure><p id="4b47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">VMs还提高了测试的可靠性。事实证明，在多个环境中部署单个虚拟机比让每台物理机都安装相同的补丁要容易得多，从而确保无论在什么环境中，应用程序总是运行在完全相同的操作系统版本和配置上。</p><h2 id="d839" class="nu lx it bd ly nv nw dn mc nx ny dp mg li nz oa mi lm ob oc mk lq od oe mm of bi translated">容器和图像</h2><p id="3a56" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">集装箱更进一步。尽管容器与虚拟机非常相似(从概念上讲，我们可以简单地将它们视为更轻量级或更高效的虚拟机)，但容器利用了底层操作系统的大量功能。这种额外的效率提供了一些基本的好处。</p><p id="1fe0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，一台机器上可以运行更多的容器。这使得在虚拟机中运行容器变得非常普遍，许多虚拟机本身被部署到一台物理机上。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/b00738d6ced4bc3f67fbaed3c94d73f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*atnv3UgA059mivwg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">现在我们有所发现</figcaption></figure><p id="462b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，我们可以超越确保跨环境的一致运行时，而是将所有东西(操作系统、服务器、配置、<em class="lv">和</em>我们的应用程序代码)打包到一个不可变的映像中。然后，我们可以在本地桌面、QA、暂存和生产中运行该映像。这确保了我们在所有这些环境中进行一致的测试。</p><p id="cc29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">(术语的快速注释，以确保没有混淆。一个<em class="lv">映像</em>指的是我们创建并上传到存储库中的包。一个<em class="lv">容器</em>是该图像的一个运行实例。把图像想象成蓝图，而运行的容器是蓝图的表现。)</p><h1 id="16b9" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">进入Kubernetes</h1><p id="eac8" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">作为工程师，创建我们自己的图像很简单。例如，Docker 允许我们从一个基本图像开始，然后在上面叠加额外的图像。我们可以选择一个基础操作系统(比如Ubuntu)，添加一个Java运行时作为另一个层，稍后添加我们的JAR文件作为另一个层，然后打包成一个映像。那么，目标就是将这些映像的运行实例部署为容器。</p><p id="dc0b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们已经创建了映像，准备部署到生产环境中。现在我们该怎么办？</p><p id="3515" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们第一次将它部署到生产环境中时，我们可能会手工完成。例如(假设我们可以访问我们的生产环境),我们可以执行如下内容:</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="3a51" class="nu lx it oj b gy on oo l op oq">docker run -d -p 80:8080 my-registry-loc/cool-application:1.0.0</span></pre><p id="7837" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">瞧，我们的“酷应用”图像将作为一个运行容器启动。</p><p id="2baf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是我们每次都想这样启动我们的应用程序吗？大概不会。很快，我们会想做更多的事情，例如:</p><ul class=""><li id="1138" class="mt mu it lb b lc ld lf lg li mv lm mw lq mx lu my mz na nb bi translated">启动应用程序的多个并发实例来处理负载。</li><li id="dba8" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">随着负载的增加，增加同时运行的实例数量…</li><li id="5c26" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">…同样，随着负载的减少，实例的数量也会减少</li><li id="2b23" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">重新启动任何崩溃或挂起的正在运行的实例</li><li id="693f" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">执行<a class="ae ky" href="https://dev.to/mostlyjason/intro-to-deployment-strategies-blue-green-canary-and-more-3a3" rel="noopener ugc nofollow" target="_blank">滚动、淡黄色和蓝/绿色部署</a></li><li id="d9e2" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">对多个应用程序和服务执行上述所有操作</li></ul><p id="bbd2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将是非常令人生畏的手动实现。你说，写一堆脚本来实现自动化？嗯…也许吧。</p><p id="06ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者，我们可以用Kubernetes。因为<em class="lv">那个</em>就是它的用途。</p><h2 id="1aa7" class="nu lx it bd ly nv nw dn mc nx ny dp mg li nz oa mi lm ob oc mk lq od oe mm of bi translated">快速定义</h2><p id="f4e1" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">Kubernetes是由Google构想出来的，来自另一个叫做Borg的内部容器管理系统。它现在是开源的，是第一批捐赠给<a class="ae ky" href="https://en.wikipedia.org/wiki/Cloud_Native_Computing_Foundation" rel="noopener ugc nofollow" target="_blank">云本地计算基金会(CNCF) </a>的项目之一。</p><p id="7c08" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Kubernetes这个名字是一个希腊词，意思是“舵手”或“领航员”(船的)。如今，Kubernetes经常被缩写为<em class="lv"> k8s ( </em>即一个“k”和“s”，中间还有8个其他字符)。</p><p id="ae4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">k8s通常被定义为一个<em class="lv">容器编排系统</em>。实际上，这意味着k8s是一个处理映像部署、管理容器的伸缩和负载平衡以及执行一系列其他相关操作的平台。</p><p id="8fca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为一名开发人员，这意味着什么呢？</p><h2 id="9fa6" class="nu lx it bd ly nv nw dn mc nx ny dp mg li nz oa mi lm ob oc mk lq od oe mm of bi translated">Kubernetes是一个平台</h2><p id="8490" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">为了与Kubernetes互动，你必须首先运行一个Kubernetes <em class="lv">集群</em>。简而言之，k8s集群是一组工作机，或者说<em class="lv">节点、</em>的集合，容器将被部署和运行到这些节点上。(我们稍后将更详细地讨论节点。)</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi or"><img src="../Images/8c57118553343573860844a7cb13530b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1210/0*DWMG6PiQQ8lxlti7"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">集群实际上只是一堆节点…</figcaption></figure><p id="6805" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，在该集群中，必须运行一个<em class="lv">控制平面</em>。控制平面是一组实际处理Kubernetes操作的组件。这些组件实际上作为集群节点中的容器运行，就像您自己的应用程序和服务一样。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi or"><img src="../Images/5c431370d997a22709756f3ae796b2f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1210/0*NviFMJzcP5YamFDV"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">…已经部署了一些容器</figcaption></figure><p id="6310" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为开发人员，<em class="lv">你不需要关心这些组件</em>。但是如果你好奇的话，我们会在稍后讨论它们，一旦我们了解了更多。</p><p id="d882" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，在开始与Kubernetes交互之前，集群必须启动并运行。但是作为开发人员，您几乎永远不会参与它们的供应。那么，你在哪里可以找到一个呢？</p><ul class=""><li id="54d2" class="mt mu it lb b lc ld lf lg li mv lm mw lq mx lu my mz na nb bi translated"><em class="lv">在您组织自己的数据中心</em>。在这种情况下，通常由专门的团队(例如运营团队)来创建和管理集群和控制平面。你永远都不需要处理它。</li><li id="4c21" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated"><em class="lv">使用云提供商</em>。谷歌云平台提供<a class="ae ky" href="https://cloud.google.com/kubernetes-engine" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> GKE(谷歌Kubernetes引擎)</strong> </a>作为运行k8s的绝佳地点。亚马逊网络服务提供<a class="ae ky" href="https://aws.amazon.com/eks/" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> EKS(弹性Kubernetes服务)</strong> </a>。Azure还提供<a class="ae ky" href="https://azure.microsoft.com/en-us/services/kubernetes-service/" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> Azure Kubernetes服务(AKS) </strong> </a>。当然，你需要告诉云提供商你想要为你的项目提供Kubernetes，但是细节已经为你处理好了。</li><li id="e1b3" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated"><em class="lv">本地</em>。<a class="ae ky" href="https://kubernetes.io/docs/tasks/tools/install-minikube/" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> MiniKube </strong> </a>是一个工具，它允许你在本地计算机上运行一个小型的单节点集群。它将自动创建集群和控制平面。然而，安装MiniKube本身所需的所有组件可能很棘手。<br/>更好的选择是<a class="ae ky" href="https://www.docker.com/blog/get-to-know-docker-desktop/" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> Docker桌面</strong> </a>。它具有在您的机器上运行单节点集群的能力，并且它的<a class="ae ky" href="https://medium.com/@dt_23597/the-easiest-and-cheapest-way-to-try-kubernetes-for-yourself-d7367ff1d6e" rel="noopener">设置比MiniKube </a>简单得多。</li></ul><h2 id="9edb" class="nu lx it bd ly nv nw dn mc nx ny dp mg li nz oa mi lm ob oc mk lq od oe mm of bi translated">与Kubernetes互动</h2><p id="4311" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">假设我们有一个可用的集群和控制平面。那么我们将如何使用Kubernetes呢？</p><p id="ebe4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用Kubernetes作为开发人员，我们只需要两件事情。第一个是理解YAML文件的文本编辑器。我们会写很多关于YAML的文章。接下来是<a class="ae ky" href="https://kubernetes.io/docs/reference/kubectl/overview/" rel="noopener ugc nofollow" target="_blank"> <em class="lv"> kubectl </em> </a>命令行工具。<em class="lv">我们与Kubernetes的每一次互动都将通过kubectl进行。</em></p><p id="6747" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是我们如何与Kubernetes互动呢？首先，重要的是要明白我们不会告诉Kubernetes <em class="lv">去做什么。我们只是描述我们想要的状态。为了达到那种状态，Kubernetes会想出该做什么，以及如何去做。</em></p><p id="05ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这似乎是一个微妙的问题，但实际上非常重要。例如，假设我们想要我们的my-app:v1.0.0 映像的两个实例，作为各有500MB内存的容器运行。如果Kubernetes的设计有所不同，我们可能会指示Kubernetes:</p><ul class=""><li id="3357" class="mt mu it lb b lc ld lf lg li mv lm mw lq mx lu my mz na nb bi translated">使用我们的<em class="lv"> my-app:v1.0.0 </em>映像启动两个容器</li><li id="d0bc" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">给每个分配500MB的内存</li></ul><p id="9f36" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">据推测，Kubernetes会尽职尽责地遵循我们的指示。现在想象一下，我们的一个容器变得不健康并崩溃了。不幸的是，Kubernetes可能已经完成了我们的指示。我们将只剩下一个容器实例来处理所有的负载(当然，直到那个容器也崩溃)。</p><p id="d8d7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相反，我们只是描述我们想要的状态，Kubernetes将确保我们的集群总是反映这种状态。这意味着Kubernetes将不仅推出我们的集装箱；它将持续监控集群，并在需要时采取措施。因此，如果我们的两个容器正在运行，其中一个崩溃，Kubernetes将启动另一个。</p><p id="bce3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如你可能已经猜到的，我们在YAML文件中描述了这种理想状态。然后我们告诉<em class="lv"> kubectl </em>将YAML文件中描述的状态应用到正在运行的集群。下面的<code class="fe os ot ou oj b">my-app-pod.yml</code>文件提供了一个简单的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ov ow l"/></div></figure><p id="7cb5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我们已经指出，我们希望我们的<code class="fe os ot ou oj b">my-image-repo/my-app</code>映像的版本<em class="lv"> 1.0.0 </em>在某个分配的内存范围内运行。我们将在命令行上用<em class="lv"> kubectl </em>来应用它:</p><p id="d9bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe os ot ou oj b">kubectl create -f my-app-pod.yml</code></p><p id="c689" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们可以这样验证容器的当前状态:</p><p id="602e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe os ot ou oj b">kubectl get pod my-app</code></p><p id="4da4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是你将在Kubernetes上做的所有事情的简要介绍。</p><p id="b9a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于<em class="lv"> kubectl </em>的一个小提示。我们知道我们的集群可以在任何地方运行(例如，在本地使用MiniKube或Docker Desktop，或者使用云提供商，或者在我们公司的数据中心)。然而在任何情况下，kubectl都在我们的桌面上本地运行。那么……它如何知道与哪个集群对话呢？kubectl 可能看起来有点神奇，但它也是通灵的吗？</p><p id="3918" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事实上，我们可以配置多个集群通过本地<em class="lv"> kubectl </em>实例进行访问。这些集群存储在本地的<code class="fe os ot ou oj b">~/.kube/config</code>。每个集群代表一个“上下文”<em class="lv"> </em>，<em class="lv"> kubectl </em>将在任何给定的点在一个上下文下运行。因此，无论我们当前在哪个集群环境下运行，都是我们要与之交互的集群。</p><p id="e14d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，您可能有一个本地Docker桌面集群，以及您组织的GKE集群。您可以使用<br/> <code class="fe os ot ou oj b">kubectl config set-cluster ...</code> <br/>命令添加每一个。您可以稍后使用<br/> <code class="fe os ot ou oj b">kubectl config use-context <em class="lv">my-cluster-name</em></code>在上下文之间切换。</p></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><h1 id="a94d" class="lw lx it bd ly lz no mb mc md np mf mg jz nq ka mi kc nr kd mk kf ns kg mm mn bi translated">Kubernetes的基本构件</h1><p id="0c66" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">现在，让我们看看Kubernetes给我们的积木。在其他k8s教程中，你可能会发现这些对象呈现得有些随意。相反，我们将从基础开始，然后研究它们是如何相互构建的。</p><p id="b406" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">需要理解的两个最重要的构建模块是<em class="lv">节点</em>和<em class="lv">pod</em>。如果你理解了它们，剩下的就一帆风顺了。</p><h2 id="7d64" class="nu lx it bd ly nv nw dn mc nx ny dp mg li nz oa mi lm ob oc mk lq od oe mm of bi translated">你的东西在节点上运行</h2><p id="cc83" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我们之前提到过“节点”，在使用Kubernetes时，您会经常听到这个术语。节点可以简单地定义为一个运行Kubernetes工作负载的<em class="lv">逻辑机器</em>。</p><p id="a89c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该定义的第一部分— <em class="lv">逻辑机器</em> —意味着一个节点既可以由一个物理硬件来表示，也可以由运行在物理硬件上的虚拟机来表示。事实上，一个节点也可以代表运行在另一个虚拟机中的一个虚拟机，而另一个虚拟机最终运行在物理硬件上。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ox"><img src="../Images/4afb9fc470b744b0d4a65caabe549d03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*X6ZKpasXeZ2yRxYE"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">一个节点可以映射到一个物理服务器、一个虚拟机或另一个虚拟机中的一个虚拟机…</figcaption></figure><p id="2c1f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为开发人员，这对您意味着什么？本质上，您不知道——也不关心——节点在幕后映射到什么。您只关心在您的集群中已经创建了一个或多个逻辑机器——每个都有资源限制——并且您的每个容器都将被分配给一个。(好吧，这不完全是<em class="lv">说的</em>事实。一旦你熟悉了Kubernetes，就可以<em class="lv">指定容器运行的节点，但这是大多数开发人员不需要担心的。</em></p><p id="4296" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，群集中的节点在功能上可能有所不同(例如，可用内存、可用CPU等)。Kubernetes的部分工作是确保容器在满足容器资源需求的节点上运行。</p><p id="68ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样值得注意的是，一个集群可以由一个节点组成。事实上，MiniKube和Docker Desktop都提供了<em class="lv">单节点集群</em>，在本地计算机上的单个虚拟机中运行。正如您可能猜到的那样，在单个节点上启动和运行多个容器是可能的，也是常见的。</p><p id="f249" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">前面，我们了解到Kubernetes的控制平面由运行在集群节点上的许多组件组成。虽然值得重申的是，作为开发人员，您不需要了解这些组件，但出于好奇，我们将在这里简要讨论它们。</p><p id="dc93" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，让我们充实之前的图像:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi or"><img src="../Images/379833c9a13da0f01943c2000bf58e97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1210/0*M48BYMjlMcMmHvrx"/></div></figure><p id="4072" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个节点被视为<em class="lv">主节点</em>，在其上运行:</p><ul class=""><li id="a697" class="mt mu it lb b lc ld lf lg li mv lm mw lq mx lu my mz na nb bi translated"><a class="ae ky" href="https://etcd.io/" rel="noopener ugc nofollow" target="_blank"> <em class="lv"> etcd </em> </a>:维护集群状态的键值存储</li><li id="f356" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated"><em class="lv">调度器</em>:顾名思义，它调度我们希望在集群上完成的所有事情</li><li id="009d" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated"><em class="lv">控制器管理器</em>:监控集群并确保维持所需状态</li><li id="20d9" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated"><em class="lv"> API服务器</em>:提供ReST API发布命令，更新etcd。事实上，当我们使用<em class="lv"> kubectl </em>与集群通信时，这就是我们正在交谈的内容。</li></ul><p id="c9c6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其余的节点——我们的容器将在其上运行——被称为<em class="lv">工作节点</em>。除了我们的容器之外，每个容器都运行:</p><ul class=""><li id="ed92" class="mt mu it lb b lc ld lf lg li mv lm mw lq mx lu my mz na nb bi translated">kubelet :与API服务器通信的服务，管理Pod中的容器</li><li id="408e" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated"><em class="lv">容器运行时</em>:运行容器的环境；例如码头工人</li><li id="343a" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">kube-proxy:实现容器、pod和节点之间通信的组件</li></ul><h2 id="33c4" class="nu lx it bd ly nv nw dn mc nx ny dp mg li nz oa mi lm ob oc mk lq od oe mm of bi translated">您的容器被部署为豆荚</h2><p id="8d0e" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">所以我们的集群由一个或多个节点组成，我们在这些节点上运行我们的东西。但是这个<em class="lv">东西</em>到底是什么？正如我们之前讨论的，Kubernetes的存在是为了将我们的图像作为容器来运行和管理。那么，我们是否简单地将Kubernetes指向我们想要部署的映像？</p><p id="8288" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不完全是。当我们与Kubernetes互动时，我们就用Kubernetes对象来说话。Kubernetes提供了许多现成的对象(我们可以向我们的集群添加其他API来提供额外的对象)。这些对象中最基本的一个你已经见过了:Pod<em class="lv">和</em>。</p><p id="a5f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，把Pod想象成我们想要运行的图像的包装器。我们在Pod定义文件中定义了一个Pod。在前面几节中，我们看了一个简单的Pod定义文件的例子；让我们再看一遍。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ov ow l"/></div></figure><p id="bb88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以马上看到，这不仅仅是简单地告诉Kubernetes您想要部署哪个映像。让我们检查定义文件的各个部分:</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="9027" class="nu lx it oj b gy on oo l op oq">apiVersion: v1<br/>kind: Pod</span></pre><p id="be2b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个Kubernetes定义文件都将以参数<code class="fe os ot ou oj b">apiVersion</code>和<code class="fe os ot ou oj b">kind</code>开始。对于标准的Kubernetes对象来说，<code class="fe os ot ou oj b">apiVersion</code>通常等于<em class="lv"> v1 </em>或<em class="lv"> apps/v1 </em>(对象的文档会告诉你其他的信息)。来自附加API的对象将具有不同的<code class="fe os ot ou oj b">apiVersion</code>;例如，来自<a class="ae ky" href="https://tekton.dev/" rel="noopener ugc nofollow" target="_blank"> Tekton </a> API的对象可能有一个类似<code class="fe os ot ou oj b">apiVersion: tekton.dev/v1alpha1</code>的<code class="fe os ot ou oj b">apiVersion</code>值。</p><p id="8554" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe os ot ou oj b">kind</code>，正如你可能猜到的，表示我们正在定义的对象的种类。当然，这里我们定义的是一个Pod。</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="d2f5" class="nu lx it oj b gy on oo l op oq">metadata:<br/>  ...<br/>spec:<br/>  ...</span></pre><p id="d488" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，几乎所有的定义文件都将包含一个<code class="fe os ot ou oj b">metadata</code>和一个<code class="fe os ot ou oj b">spec</code>部分。在这里，我们给对象加上名字和标签，随着我们部署越来越多的对象，这些会变得很有用。在我们的示例中，我们将Pod命名为“my-app”。</p><p id="a37c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe os ot ou oj b">spec</code>是真正的肉的定义:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ov ow l"/></div></figure><p id="279b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在它们的<code class="fe os ot ou oj b">spec</code>部分中，不同对象的定义文件将包含不同的子部分。在一个Pod定义文件中，我们将找到一个<code class="fe os ot ou oj b">containers</code>子部分。这里，我们定义了希望Kubernetes管理的容器。我们已经给了容器本身一个名称，并定义了要使用的图像。我们还提供了初始(250MB)和最大(500MB)内存分配(注意:<em class="lv"> Mi </em> =兆字节)。</p><p id="ef77" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如前所示，一旦我们创建了Pod定义文件并用任意名称保存它(我们将使用<code class="fe os ot ou oj b">my-app-pod.yml</code>)，我们就可以通知Kubernetes我们希望这个Pod运行:</p><p id="b5ad" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe os ot ou oj b">kubectl create -f my-app-pod.yml</code></p><p id="313e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此时，Kubernetes将找到一个具有所需内存量的可用节点，并运行我们的Pod。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi or"><img src="../Images/50e2835a981c37f8dc1e8f2d5ffadf9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1210/0*9leSZ1oze1A3FukT"/></div></figure><p id="e5da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我可以运行<code class="fe os ot ou oj b">kubectl get pod</code>，这将显示所有当前正在运行的pod。如果一切顺利，结果会是这样:</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="6478" class="nu lx it oj b gy on oo l op oq">NAME      READY STATUS  RESTARTS AGE<br/>my-app   <!-- --> 1/1   Running 0        30s</span></pre><p id="003a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这表明我有一个单独的Pod在运行:<em class="lv"> my-app </em>。Pod中的一个(<em class="lv"> 1/1 </em>)容器准备就绪。Pod已经运行了30秒，并且从未重新启动。</p><p id="9f54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们想要旋转Pod，我们可以引用我们的Pod定义文件:</p><p id="647d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe os ot ou oj b">kubectl delete -f my-app-pod.yml</code></p><p id="52df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者我们可以通过名字来终止Pod:</p><p id="95ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe os ot ou oj b">kubectl delete pod my-app</code></p><p id="3271" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，你可能已经注意到了一些事情。首先，定义文件需要一个<code class="fe os ot ou oj b">containers</code>，而不是<code class="fe os ot ou oj b">container</code>，子部分。此外，我们刚刚看到<em class="lv"> kubectl </em>告诉我们在Pod中部署了多少容器。这是否意味着我们可以在一个Pod中部署多个容器？答案是:是的……但是现在不用担心。当我们讨论<em class="lv">边车</em>的时候，我们会探讨你什么时候以及为什么要这么做。</p><h2 id="0443" class="nu lx it bd ly nv nw dn mc nx ny dp mg li nz oa mi lm ob oc mk lq od oe mm of bi translated">多个pod由部署管理</h2><p id="6e19" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">如果您在生产环境中使用过微服务，您可能会发现一些困扰您的问题。也就是说，在告诉Kubernetes部署单个Pod时，我们已经部署了单个容器。通常，为了处理负载和保持弹性，我们希望部署一个容器的多个实例。</p><p id="01cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为此，我们将转向另一个Kubernetes对象。</p><p id="4ff8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不久以前，我们会使用一个<em class="lv">复制集</em>。根据Kubernetes文档，副本集的目的是“在任何给定的时间保持一个稳定的副本集运行”。换句话说，ReplicaSet确保指定数量的相同pod同时运行(同样是为了处理负载和确保弹性)。</p><p id="18e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">部署</em>是在复制集之后引入的。它们执行与副本集相同的功能(事实上，部署实际上是在幕后管理副本集),同时提供额外的功能。出于这个原因，为了运行一个容器的多个实例，我们现在更喜欢声明部署而不是复制集。</p><p id="454a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">花点时间想象一下我们该如何做。我们已经创建了一个Pod定义文件，对吗？因此，我们的部署定义文件可能会定义要运行的Pod实例的数量，然后以某种方式引用我们现有的Pod定义文件来定义要运行的内容。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/98471df70fd92073819d3cacbe146220.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1sHwf3Yh9t_Wu815"/></div></div></figure><p id="a842" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对吗？</p><p id="b303" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你会这样想，但事实并非如此。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/9bba587a36c6e5e8e8bb9769d850b465.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Ap6P86u5bWLkBFbv"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">没有。</figcaption></figure><p id="e820" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实际上，当我们创建一个部署定义文件时，我们实际上会<em class="lv">复制Pod定义文件的内容</em>:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ov ow l"/></div></figure><p id="d268" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意一些事情:</p><ul class=""><li id="d7c8" class="mt mu it lb b lc ld lf lg li mv lm mw lq mx lu my mz na nb bi translated"><em class="lv">种</em>变成了<code class="fe os ot ou oj b">Deployment</code></li><li id="88ce" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">我们的<em class="lv">规格</em>部分看起来有点不同。具体来说，我们现在指出我们想要部署多少个<em class="lv">副本</em>(具体来说是4个)。<em class="lv">选择器</em>部分告诉我们<strong class="lb iu"> <em class="lv">什么是我们想要的4个副本的</em> </strong>(我们将在下面详细讨论)。</li><li id="1791" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">在我们的<em class="lv">规范</em>小节中，我们还有一个新的<em class="lv">模板</em>小节。在这里，我们定义了应该构成我们的部署的实际单元。我们使用<code class="fe os ot ou oj b">metadata:labels</code>部分为我们的Pod定义分配一个标签(<code class="fe os ot ou oj b">my-app-pod</code>)。然后我们从先前的Pod定义文件中复制&amp;粘贴<em class="lv">规格</em>部分。(所以，是的，在部署定义文件中，我们将有一个<em class="lv">规范</em>部分嵌入到另一个<em class="lv">规范</em>部分中)。</li></ul><p id="d46c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们更详细地看看<em class="lv">选择器</em>部分，因为它有点混乱。您可能认为，在创建部署定义文件时，我们应该简单地告诉Kubernetes我们想要部署哪个Pod。实际上，有一个间接的层次。让我们特别关注这一部分:</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="7ab7" class="nu lx it oj b gy on oo l op oq">selector:<br/>    matchLabels:<br/>      app: my-app-pod</span></pre><p id="8480" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，我们告诉Kubernetes<strong class="lb iu">选择</strong>包含<strong class="lb iu">标签</strong>的对象，该标签<strong class="lb iu">匹配<em class="lv"> app: my-app-pod </em> </strong>。</p><p id="0fc4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在让我们关注<em class="lv">模板</em>部分的这一部分:</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="8a0a" class="nu lx it oj b gy on oo l op oq">template:<br/>    metadata:<br/>      labels:<br/>        app: my-app-pod<br/>    spec: <br/>      ... &lt;pod definition&gt; ...</span></pre><p id="3ff5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，在<em class="lv">规格</em>部分定义pod之前，该模板已被赋予<strong class="lb iu">标签<strong class="lb iu"> <em class="lv"> app的</em></strong>:my-app-Pod</strong>。因此，Kubernetes将通过<em class="lv">和</em>来决定创建什么样的复制品。</p><p id="fbfe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这种间接性现在看起来可能有点奇怪。但是随着我们的集群变得越来越复杂，它变得越来越重要，随着您了解越来越多的k8s对象，您会经常看到这种模式。</p><p id="5871" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们将部署定义文件保存到一个<code class="fe os ot ou oj b">my-app-deployment.yml</code>文件中并运行</p><p id="a352" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe os ot ou oj b">kubectl create -f my-app-deployment.yml</code></p><p id="e5ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，我们将完成如下所示的部署:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oz"><img src="../Images/29b261f9516dc08df04cf3a4c24cca39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WIvhZGMGaDLP8RvD"/></div></div></figure><p id="d932" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，实际的部署对象将被部署到集群中。反过来，部署在后台管理一个副本集，因此也部署了一个副本集对象。然后，如你所料，四个吊舱也将被部署。如前所述，我们不知道——也不关心——这些对象部署在哪个节点上。</p><h1 id="1887" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">其他Kubernetes对象</h1><p id="ccc9" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">至此，我们已经介绍了Kubernetes的基础知识，包括两个常见的对象:pod和部署。但是在使用Kubernets时，您可能会与更多的对象进行交互。虽然我们不会在这里创建一个详尽的列表，但是让我们来看几个更常见的Kubernetes对象，这样您就可以对那里有所了解。</p><h2 id="f51e" class="nu lx it bd ly nv nw dn mc nx ny dp mg li nz oa mi lm ob oc mk lq od oe mm of bi translated">服务</h2><p id="afde" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我们有一组容器在它们自己的舱里运行。现在我们该怎么办？</p><p id="f9ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通常，我们希望以某种方式访问我们的pod，为此，我们需要能够对我们的pod进行寻址。</p><p id="4a6b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以查找我们的pod的IP地址，并使用它们来访问pod。但是这也有一些问题。首先，pod来来去去…它们的IP地址也是如此。每当pod的IP地址发生变化时，手动跟踪它们是不可行的。相反，我们需要某种形式的服务发现。第二，为了利用pod的部署，我们希望它们之间的流量负载平衡。</p><p id="422b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="lv">服务</em>为我们执行这两项活动。服务是一个轻量级的k8s对象，它定义了pod的逻辑集合，以及访问它们的策略。换句话说，服务为一个或一组Pod提供稳定的寻址。有两种主要类型的服务:</p><ul class=""><li id="6677" class="mt mu it lb b lc ld lf lg li mv lm mw lq mx lu my mz na nb bi translated"><strong class="lb iu"> <em class="lv"> ClusterIP </em> </strong>服务在Kubernetes集群内提供访问<em class="lv">。换句话说，它允许同一个集群中的不同pod相互查找和通信。</em></li><li id="dadd" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated"><strong class="lb iu"> <em class="lv">节点端口</em> </strong>服务提供来自集群外部<em class="lv">的访问。例如，使用节点端口服务，我们可以使用本地web浏览器访问部署在集群内部的web应用程序。</em></li></ul><p id="399c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与其他k8s对象一样，我们在YAML文件中定义了一个服务，并使用<em class="lv"> kubectl </em>应用它。此外，服务依赖于我们上面看到的“选择器”模式，以便识别它要提供寻址的pod。一个小的示例YAML文件可能如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ov ow l"/></div></figure><p id="d171" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面，我们创建了一个<em class="lv">节点端口</em> <em class="lv">服务</em>，它提供了对任何带有标签<em class="lv"> app: my-app-pod </em>的pod的寻址，并将Pod的端口80作为端口30080向外界公开(不幸的是服务端口必须在30000–32767的范围内)。因此，它会将流量转发到其规范部分包含以下内容的任何Pod或部署的端口80:</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="6537" class="nu lx it oj b gy on oo l op oq">  metadata:<br/>    labels:<br/>      app: my-app-pod</span></pre><p id="c964" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我们希望确保将该元数据添加到我们希望流量路由到的Pod或部署的定义文件中(并且该文件中只有<em class="lv">和</em>)!).</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi pa"><img src="../Images/6315afb0444c136aa869ce7b79a33e90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1172/0*_INQgYiINVN8LZpC"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">两种服务，红色。NodePort服务提供对我们的web应用程序的外部访问，而ClusterIP服务允许web应用程序Pods从集群内部访问其他对象。</figcaption></figure><p id="118e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">服务易于设置和使用，但有些过于简单。当您开发生产就绪系统时，您会发现存在更强大的寻址和负载平衡选项。</p><p id="b6f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">(注意:不幸的是，我们习惯于使用术语“服务”来表示正在运行的应用程序；即“微服务”的简称。使用Kubernetes时，请记住“服务”有特定的含义。)</p><h2 id="c0a0" class="nu lx it bd ly nv nw dn mc nx ny dp mg li nz oa mi lm ob oc mk lq od oe mm of bi translated">名称空间</h2><p id="0516" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">随着我们的组织和集群的增长，我们希望对容器和我们部署的其他对象进行逻辑分组。例如，我们可能希望将不同的功能应用程序组合在一起。或者我们可以隔离开发环境。或者，我们可能希望按垂直团队对应用程序进行分组。</p><p id="7543" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们使用<em class="lv">名称空间</em>来做到这一点。和服务一样，名称空间也是轻量级的k8s对象。它们允许我们在单个物理k8s集群中创建“虚拟集群”。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pb"><img src="../Images/0d8ecd54c449f632dc7056653127c9e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RJbL6qzEx4SD3aN8"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">两个名称空间。注意相同名称的不同对象如何存在于不同的名称空间中。</figcaption></figure><p id="8b5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同一命名空间中的对象可以直接访问。对于一个名称空间中的对象，要寻址另一个名称空间中的对象，必须使用另一个对象的完全限定域名(FQDN)。FQDN的形式是<code class="fe os ot ou oj b">&lt;service-name&gt;.&lt;namespace-name&gt;.svc.cluster.local</code>，所以如果我们在“产品”名称空间中放置一个名为<code class="fe os ot ou oj b">my-app-internal-service</code>的服务，它的FQDN就是<code class="fe os ot ou oj b">my-app-internal-service.product.svc.cluster.local</code>。“分析”名称空间中的Pod将使用该FQDN来寻址<code class="fe os ot ou oj b">my-app-internal-service</code>。</p><p id="99de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">名称空间定义文件非常简单:</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="9ca7" class="nu lx it oj b gy on oo l op oq">  apiVersion: v1,<br/>  kind: Namespace,<br/>  metadata: <br/>    name: products</span></pre><p id="85f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将通过向其他对象的定义文件中添加以下内容来放置这些对象:</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="1f0b" class="nu lx it oj b gy on oo l op oq">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: my-ns-app-deployment<br/>  <strong class="oj iu">namespace: products</strong><br/>...</span></pre><p id="1f29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦一个对象被部署在一个名称空间中，我们将需要向<em class="lv"> kubectl </em>提供一个<code class="fe os ot ou oj b">-n</code>选项来告诉工具要查看哪个名称空间。例如，以下将无法定位<code class="fe os ot ou oj b">my-ns-app-deployment</code>:</p><p id="8196" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe os ot ou oj b">kubectl get deployment my-ns-app-deployment</code></p><p id="e593" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相反，我们需要以下内容:</p><p id="141a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe os ot ou oj b">kubectl get deployment -n products my-ns-app-deployment</code></p><p id="f8b5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Kubernetes提供了一个“默认”名称空间，没有指定特定名称空间的对象被放入其中。到目前为止，在本文中我们看到的例子中，我们使用了默认的名称空间。</p><p id="e87a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于名称空间的另一个有趣的注意事项。回想一下，在我们关于k8s控制平面的讨论中，我们了解到Kubernetes自己的组件在集群中作为容器/pod运行。这些组件运行在一个特殊的<em class="lv"> kube-system </em>命名空间中。所以我们不会简单地通过<code class="fe os ot ou oj b">kubectl get pods</code>看到那些豆荚。但是<code class="fe os ot ou oj b">kubectl get pods -n kube-system</code>会起作用。</p><h2 id="c874" class="nu lx it bd ly nv nw dn mc nx ny dp mg li nz oa mi lm ob oc mk lq od oe mm of bi translated">秘密</h2><p id="6701" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我们可能希望在定义文件中包含敏感数据。例如，不久前我想尝试将规范的MongoDB容器部署到我的本地k8s集群。正如您可能想到的，我需要指定用于我的MongoDB容器的凭证。最初，我的MongoDB Pod定义文件包括如下内容:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ov ow l"/></div></figure><p id="8c29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好的，这只是在我的本地集群中运行，这些显然是伪造的凭证。尽管如此，我还是不喜欢将<em class="lv">的任何</em>凭证作为明文传递的想法。</p><p id="340c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以我创建了一个秘密定义文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ov ow l"/></div></figure><p id="53b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您会注意到<em class="lv">用户名</em>和<em class="lv">密码</em>是base64编码的值。我按照找到的说明创建了它们，创建一个包含秘密值的文本文件，然后运行<code class="fe os ot ou oj b">cat secret.txt | tr -d \\n | base64</code>将值输入到我的秘密定义文件中(kubectl也提供了一个<code class="fe os ot ou oj b">create secret</code>命令)。</p><p id="20f3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我的MongoDB定义文件看起来更像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ov ow l"/></div></figure><p id="cd0d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实际上，base64编码并不比明文更安全。但是将秘密从Pod/部署定义文件中分离出来提供了一定的灵活性来支持事情。尽管如此，在组织的生产环境中，您不太可能看到秘密定义文件被签入源代码。</p><h1 id="a625" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">其他Kubernetes概念</h1><p id="5275" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">当你了解Kubernetes的时候，你会听到其他的概念。下面是对其中一些概念的快速概述。</p><h2 id="cfa4" class="nu lx it bd ly nv nw dn mc nx ny dp mg li nz oa mi lm ob oc mk lq od oe mm of bi translated">健康检查</h2><p id="3b79" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我们已经讨论了Kubernetes在路由流量之前确保pod准备好处理流量，以及重新启动不健康的pod。但是，Kubernetes如何知道一个豆荚是准备好了…还是健康的？</p><p id="727f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是通过健康检查完成的。从本质上讲，健康检查只是Kubernetes(或任何其他想要检查系统健康的东西)可以ping通的一个URL。成功的<em class="lv"> (20x </em>)响应表明运行状况良好，而失败的响应(通常为<em class="lv"> 50x </em> …或超时)表明存在问题。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pc"><img src="../Images/1fac836cc2653fbf743a4aff4a585451.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*I0TNR2dOMqSW6NoN"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@impulsq?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">在线营销</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="78bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">过去，我们通常只提供一张支票。然而，Kubernetes希望指定两种健康检查:一种是<em class="lv">准备状态</em>检查——表明Pod是否能够处理流量——另一种是<em class="lv">活性状态</em>检查——表明Pod是否健康。</p><p id="90ec" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为什么是两个？当然，两者之间有一些重叠。例如，内存不足的Pod既不能处理流量，也不健康。然而，在很多情况下，一个Pod可能是健康的，但是没有准备好处理流量；例如:</p><ul class=""><li id="1d69" class="mt mu it lb b lc ld lf lg li mv lm mw lq mx lu my mz na nb bi translated">新启动的Pod可能需要先填充缓存，然后才能处理流量。很健康，但还没准备好。</li><li id="0f3b" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">Pod可能无法连接到资源，如数据库。问题很可能出在数据库方面，但是在连接恢复之前，Pod不应该处理流量。</li><li id="b033" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">一个Pod可能已经获得了一个长时间运行的CPU密集型任务，在此期间，我们不希望它接受任何更多的流量</li></ul><p id="8c13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果一个Pod从它的<em class="lv">就绪</em>检查中得到一个失败的响应，Kubernetes简单地停止向它发送流量，直到开始返回一个成功的响应。然而，如果Pod从其<em class="lv">活性</em>检查中得到失败的响应，Kubernetes将认为Pod不健康并尝试重启它。</p><p id="5460" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果使用单一的组合健康检查，那么您可以想象我们的缓存填充Pod被一次又一次地重新启动，永远没有机会为流量提供服务！或者，如果pod在无法连接到其依赖项的任何时候报告为不健康，将会发生一连串的重启。</p><p id="10fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么我们如何实施健康检查呢？假设我们的pod正在运行某种ReST或RPC服务器，只需添加两个端点:例如<code class="fe os ot ou oj b">GET /readiness</code>和<code class="fe os ot ou oj b">GET /liveness</code>。一般来说，活跃度端点应该比ping多一点，只需做很少的工作就可以立即返回。就绪端点可以检查与外部依赖性的连接，以及可能影响Pod处理流量的能力的任何其他条件。</p><p id="58a9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦我们实现了端点，我们只需在Pod/部署定义文件中声明它们:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ov ow l"/></div></figure><h2 id="1950" class="nu lx it bd ly nv nw dn mc nx ny dp mg li nz oa mi lm ob oc mk lq od oe mm of bi translated">操纵对象的其他方式</h2><p id="95f4" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">“配置即代码”是指像对待代码一样对待配置的实践:将配置登记到某个存储库中，跟踪变更，执行审查和批准，等等。如今，这被认为是一种最佳实践。正是由于这个原因，我们在讨论中的例子展示了如何使用YAML文件来创建我们的Kubernetes对象。</p><p id="14be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是还有其他的方法。例如，以下简单命令将创建一个部署:</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="b54e" class="nu lx it oj b gy on oo l op oq">kubectl run my-app --image my-image-repo/my-app:1.0.0</span></pre><p id="2171" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还可以在运行时对现有对象进行更改。以下代码查找所有标有<code class="fe os ot ou oj b">app:my-app</code>的运行窗格，并对它们应用另一个标签<code class="fe os ot ou oj b">tier:frontend</code>:</p><pre class="kj kk kl km gt oi oj ok ol aw om bi"><span id="95a5" class="nu lx it oj b gy on oo l op oq">kubectl label pods -l app=my-app tier=frontend</span></pre><p id="44e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然使用这样的一次性命令更快，但是不要这样做。相反，在学习Kubernetes的同时练习编写定义文件。这些概念将会更快地被理解，并且您将会养成编写配置工件的习惯，并且遵守“按代码配置”的最佳实践。</p><h2 id="543e" class="nu lx it bd ly nv nw dn mc nx ny dp mg li nz oa mi lm ob oc mk lq od oe mm of bi translated">舵图</h2><p id="e7fd" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">假设我们已经创建了许多组成整个应用程序套件的组件。我们已经部署了web应用容器和后端微服务容器。我们已经创建了一个ClusterIP服务来允许webapp访问后端，还创建了一个NodePort服务，以便全世界都可以访问webapp。也许我们也创造了一些秘密。我们已经为它们建立了一个命名空间。</p><p id="2905" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们希望能够随意地将所有对象以适当的顺序部署到一个集群中。我们如何做到这一点？我们可以编写shell脚本。或者我们可以使用现有的工具来做这件事；即<a class="ae ky" href="https://helm.sh/" rel="noopener ugc nofollow" target="_blank"> <em class="lv">掌舵</em> </a>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pd"><img src="../Images/e37bebc2148878c00df03400e0cde184.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*U1J8bJF-e7YBIWpT"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">弗兰克·艾弗特在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="483d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">严格地说，Helm是作为Kubernetes的包管理器而创建的。也就是说，<em class="lv"> Helm </em>大致类似于Maven、NPM、Pip或者你选择的语言所使用的任何包管理器。依次，<a class="ae ky" href="https://helm.sh/docs/topics/charts/" rel="noopener ugc nofollow" target="_blank"> <em class="lv">图表</em> </a>代表包或库。</p><p id="d06b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Helm的一个典型用例可能是一个供应商，其产品由许多Kubernetes对象组成。供应商可以提供掌舵图，而不是向用户提供用户负责手动编辑和手动部署的少量YAML文件。从本质上来说，图表只是组织在公共目录结构中的文件的集合。最重要的部分是:</p><ul class=""><li id="10da" class="mt mu it lb b lc ld lf lg li mv lm mw lq mx lu my mz na nb bi translated">这个目录中(当然)有任意数量的模板。模板实际上是一个标准的Kubernetes定义文件，利用<a class="ae ky" href="https://golang.org/pkg/text/template/" rel="noopener ugc nofollow" target="_blank"> Go模板语言</a>允许变量替换。</li><li id="6ed8" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated"><code class="fe os ot ou oj b">values.yaml</code>这是图表用户可以编辑的文件。正如您可能猜到的，它包含用户可定制的值。模板文件中的许多变量都被替换为该文件中的值。</li><li id="300d" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated"><code class="fe os ot ou oj b">Chart.yaml</code>这通常是一个小文件，包含关于图表的元数据。</li></ul><p id="def2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Helm是非常约定驱动的(感觉有点像Ruby on Rails)，所以它不需要太多的配置。虽然Helm是作为Kubernetes的包管理器存在的，但是在您使用自己的本地Kubernetes集群进行实践时，您可能会发现它很有用。这肯定比维护手写的shell脚本要好！</p><h2 id="027e" class="nu lx it bd ly nv nw dn mc nx ny dp mg li nz oa mi lm ob oc mk lq od oe mm of bi translated">边车</h2><p id="adf6" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">不久前，我们注意到在一个Pod中运行多个容器是可能的(现在也很常见)。事实上，Pod配置文件的<code class="fe os ot ou oj b">containers</code>部分就是这样命名的——容器——我们可以在那里轻松地定义多个映像。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pe"><img src="../Images/45f610e38fb54694ff55a7641ad468de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yAacYXmAfk3bWztS"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@austriannationallibrary?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">奥地利国家图书馆</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="31a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Kubernetes世界中，我们就是这样实现<em class="lv">边车</em>模式的。在边车模式中，两个或多个集装箱作为一个单元展开。它们一起启动，一起扩展，一起重启(如果需要)，一起销毁。</p><p id="28a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，容器不是任何任意的容器。一个容器是应用程序容器——基本上，这是Pod的首要原因。其他容器为应用程序容器提供支持功能。与摩托车边车非常相似，边车容器增强了应用程序容器；没有它，它就不会存在或发挥作用。</p><p id="b907" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为什么我们要在一个单元中部署多个容器？考虑一个典型的微服务架构。虽然不同的微服务归不同的团队所有，但整个组织都希望在跨领域的关注点上实现标准化。例如，服务可能需要相互传递特定的头。数据在传输时可能需要加密(并在接收后解密)。日志应该以指定的格式发送到指定的位置。</p><p id="7631" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">传统上，我们会开发一个内部框架来处理这些跨领域的任务。但是越来越多的时候，我们开始了解到自主开发的框架所带来的问题。首先，他们将我们的组织限制在单一语言或平台上(当然，除非我们计划为多个平台构建和维护我们的框架)。将我们所有的服务持续升级到框架的最新版本也很困难。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pf"><img src="../Images/971100e0e4ba5228386f23701d03122e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ImxO5RxPpJ1zVG3P"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">左图:我们曾经在可执行应用程序中包含横切代码。右图:边车就不是这样了。</figcaption></figure><p id="fb1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是有了Kubernetes，我们可以从那些横切任务中制作一个图像，并把它作为一个容器与我们的应用程序容器一起部署。此外，我们可以只将边车暴露给外部流量，从而确保在流量到达应用服务器之前，TLS终止、解密等都得到处理，并且标题、日志、指标等都得到统一和自动的处理。</p><p id="3db6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过这样做，我们避免了框架所面临的问题。我们的sidecar服务可以用Golang编写，而我们的团队可以用Java、Node、Python等编写微服务。升级到sidecar的最新版本比升级到framework的最新版本要容易得多。最坏的情况是，每个团队在他们的定义文件中手工改变sidecar服务的版本号。在最好的情况下，我们的运营团队会在部署pod时自动注入sidecar服务，从而消除了单个团队的任何工作。</p><h2 id="0fe2" class="nu lx it bd ly nv nw dn mc nx ny dp mg li nz oa mi lm ob oc mk lq od oe mm of bi translated">服务网格</h2><p id="e03b" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">如果你听说过Kubernetes，你可能也听说过很多关于服务网格的事情。与Kubernetes一样，很明显，它们在微服务领域正变得越来越重要。同样，什么是服务网格<em class="lv">是</em>也不是很明显。</p><p id="b892" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了理解服务网格，让我们快速后退一步来理解催生服务网格的需求。成功的微服务架构依赖于某些交叉概念:</p><ul class=""><li id="ed49" class="mt mu it lb b lc ld lf lg li mv lm mw lq mx lu my mz na nb bi translated"><strong class="lb iu"> <em class="lv">服务发现</em> </strong>:随着微服务的部署和取消部署，其他服务需要知道如何找到它们并解决它们。</li><li id="0940" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated"><strong class="lb iu"> <em class="lv">负载平衡</em> </strong>:为了利用一组相同的服务，必须智能地分配流量。</li><li id="1a1a" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated"><strong class="lb iu"> <em class="lv">可观察性</em> </strong>:必须发布指标，以便可以创建仪表板和警报。日志必须包括跨度和跟踪id，以允许分布式跟踪。</li><li id="2bb1" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated"><strong class="lb iu"> <em class="lv">弹性</em> </strong>:执行同步网络调用的微服务应该支持自动重试、断路器和其他弹性模式。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi pg"><img src="../Images/4a3ffd87955767b7c2dc0ea4a391e7a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZPbTiZ8YF7j1o3cU"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@ripato?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Ricardo Gomez Angel </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="7cd1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了标准化和实施这一点，组织通常依赖于框架。但是正如我们在sidecar部分所讨论的，笨重的框架已经被证明会引起问题。</p><p id="d854" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">好消息是。在理解我们关于边车的讨论时，您已经理解了服务网格是做什么的。实际上，您可以将服务网格视为一个基础设施层，通过sidecar容器实现，处理那些横切概念。</p><p id="bfaa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Istio (开源并由Google、IBM和Lyft支持)可能是最常见的服务网格产品。Istio通过利用现有的开源sidecar代理，<a class="ae ky" href="https://www.envoyproxy.io/" rel="noopener ugc nofollow" target="_blank"> Envoy </a>(由Lyft开发)来实现这一点。</p><p id="b27c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，真正掌握和学习服务网格还有很多事情要做。但从概念上讲，它们就是这么简单。</p><h1 id="cd26" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">下一步是什么？</h1><p id="8393" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">到目前为止，您应该已经理解了Kubernetes存在的原因以及它的作用。现在是时候<a class="ae ky" href="https://medium.com/@dt_23597/the-easiest-and-cheapest-way-to-try-kubernetes-for-yourself-d7367ff1d6e" rel="noopener">建立你自己的集群</a>了，开始玩吧。</p><p id="2399" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有许多在线教程和课程。但是我发现最好的学习方法是规划你自己的道路。在我学习的过程中，我给自己的任务变得越来越复杂，当我陷入困境时，我会求助于在线文档(这是很多！)</p><p id="92e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以，拿出你自己的示例应用程序——用你对Kubernetes能为你做什么的理解武装起来——弄清楚如何完成它！</p><h1 id="7022" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">资源</h1><ul class=""><li id="6ecf" class="mt mu it lb b lc mo lf mp li ph lm pi lq pj lu my mz na nb bi translated">https://kubernetes.io/docs/reference/kubectl/overview/<a class="ae ky" href="https://kubernetes.io/docs/reference/kubectl/overview/" rel="noopener ugc nofollow" target="_blank"/></li><li id="7606" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">【https://helm.sh/docs/topics/charts/ T4】</li><li id="8a48" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated"><a class="ae ky" href="https://istio.io/docs/concepts/what-is-istio/" rel="noopener ugc nofollow" target="_blank">https://istio.io/docs/concepts/what-is-istio/</a></li><li id="16bf" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated"><a class="ae ky" href="https://www.oreilly.com/library/view/designing-distributed-systems/9781491983638/ch02.html" rel="noopener ugc nofollow" target="_blank">https://www . oreilly . com/library/view/designing-distributed-systems/9781491983638/ch02 . html</a></li><li id="6e8a" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated"><a class="ae ky" href="https://rollout.io/blog/configuration-as-code-everything-need-know/" rel="noopener ugc nofollow" target="_blank">https://rollout . io/blog/configuration-as-code-everything-need-know/</a></li><li id="6927" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated"><a class="ae ky" href="https://cloud.google.com/blog/products/gcp/kubernetes-best-practices-setting-up-health-checks-with-readiness-and-liveness-probes" rel="noopener ugc nofollow" target="_blank">https://cloud . Google . com/blog/products/GCP/kubernetes-best-practices-setting-up-health-checks-with-readiness-and-liveness-probes</a></li><li id="3f96" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated"><a class="ae ky" href="https://kubernetes.io/docs/concepts/" rel="noopener ugc nofollow" target="_blank">https://kubernetes.io/docs/concepts/</a></li><li id="9ab0" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated"><a class="ae ky" href="https://en.wikipedia.org/wiki/Kubernetes" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Kubernetes</a></li></ul></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><p id="de55" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">觉得这个故事有用？想多读点？只需<a class="ae ky" href="https://dt-23597.medium.com/subscribe" rel="noopener">在这里订阅</a>就可以将我的最新故事直接发送到你的收件箱。</p><p id="2825" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你也可以支持我和我的写作——并获得无限数量的故事——通过今天成为媒体会员。</p></div></div>    
</body>
</html>