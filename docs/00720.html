<html>
<head>
<title>Advanced Unit and Snapshot Testing with React Native</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React Native进行高级单元和快照测试</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/advanced-unit-and-snapshot-testing-with-react-native-ea746feb5b2e?source=collection_archive---------3-----------------------#2019-07-07">https://levelup.gitconnected.com/advanced-unit-and-snapshot-testing-with-react-native-ea746feb5b2e?source=collection_archive---------3-----------------------#2019-07-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/68e6faea3d0cfa0a614bfa30b98d2b37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZG_gG0h9xlF__q2NlYHqew.png"/></div></div></figure><p id="f55e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">随着React Native被越来越多的人采用，这个社区已经得到了极大的扩展，因此它的核心也有了很多变化。目前，0.6是下一个候选版本。我从0.4开始使用React Native，正如你们中的许多人可能知道的那样，即使是小版本升级也很有可能会有突破性的变化(特别是对于推送通知的<code class="fe kw kx ky kz b">react-native-firebase</code>)，所以也许在未来，我可能会写一篇文章来单独解决这些问题。本文的主要目的是帮助那些真正希望React原生应用程序拥有100%代码覆盖率的人，因为这是推动我们发现这些技术的原因。</p><p id="0e49" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我将使用Jest和Enzyme来捕捉这些场景，因为Jest是由脸书为React创建的，Enzyme是一个很好的快照测试工具，涵盖了各种UI相关的测试。还有，在这个项目中，我用的是<code class="fe kw kx ky kz b"><a class="ae la" href="https://github.com/reduxjs/redux-thunk" rel="noopener ugc nofollow" target="_blank">redux-thunk</a></code>。关于如何利用<a class="ae la" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> <em class="lb"> Redux </em> </a>我就不赘述了，因为有足够多的文章讨论这个问题。</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><p id="09e1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先让我们处理一些配置。</p><p id="9377" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里是<code class="fe kw kx ky kz b">package.json</code>文件:</p><figure class="lj lk ll lm gt jr"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="1347" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Jest的一个我觉得很酷的特性是<code class="fe kw kx ky kz b">coverageThreshold</code>对象，它允许在执行代码覆盖方面的高度可重配置性。例如，我们为关键组件设置了更高的阈值，特别是那些更难调试的组件，比如我们的<em class="lb"> Redux </em>相关代码。这为我们提供了关于应用程序行为的高度确定性。</p><p id="af40" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了本文的目的，我只列出了几个依赖项，但是可能还有其他的<em class="lb">需要在生产中复制。</em></p><p id="508a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你注意到了，我还使用了一个由传递给Jest的<code class="fe kw kx ky kz b">setupFilesAfterEnv</code>数组执行的<code class="fe kw kx ky kz b">setupTests</code>文件。这是为了设置应用程序中最常被<em class="lb">模仿的</em>功能。将这个添加到<code class="fe kw kx ky kz b">coveragePathIgnorePatterns</code>数组中很重要，这样我们就不会因为跟踪一个不应该被测试的文件而降低我们的覆盖率。看一下安装文件:</p><figure class="lj lk ll lm gt jr"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="32f6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">很好，现在设置已经完成，让我们开始创建我们的页面。</p><p id="b127" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以在这个例子中，我们有一个页面，用户可以禁用和启用<strong class="ka ir">生物认证</strong>，以及<strong class="ka ir">推送通知</strong>。尽管这里发生了一些事情。主要是:</p><ol class=""><li id="f79c" class="lp lq iq ka b kb kc kf kg kj lr kn ls kr lt kv lu lv lw lx bi translated">我们需要处理用户何时离开应用程序，以便在他们的本地设备设置中启用通知。</li><li id="6ffc" class="lp lq iq ka b kb ly kf lz kj ma kn mb kr mc kv lu lv lw lx bi translated">我们需要用户确认他们确实打算通过某种级别的授权来启用生物认证，在这种情况下，这将是重新输入他们的密码。</li></ol><p id="006b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这些任务涉及异步活动，例如访问设备存储和将应用程序放在后台，这改变了我们测试的前景。让我们看看我们的<code class="fe kw kx ky kz b">SettingsPage</code>容器。</p><figure class="lj lk ll lm gt jr"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="3027" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以让我们试着分析一下，我们的函数在这里做了什么。</p><p id="a9dc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的<code class="fe kw kx ky kz b">onUpdateNotificationPermissions</code>功能允许我们将用户发送到他们各自设备上的设置页面，这当然是<code class="fe kw kx ky kz b">async</code>，因为一旦我们请求权限，我们必须首先等待响应。</p><p id="acd7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的<code class="fe kw kx ky kz b">init</code>功能将从设备的存储器中加载用户可能已经选择的先前保存的设置。我们不想向不具备这些功能的设备显示生物特征选项，因此我们做了一些检查来确定是否应该呈现<code class="fe kw kx ky kz b">icon</code>和<code class="fe kw kx ky kz b">toggleSwitch</code> <em class="lb"> </em>。</p><p id="37a3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的<code class="fe kw kx ky kz b">updateNotificationPermissionStatus</code>函数将异步更新我们的内部状态，以显示用户是否选择了启用推送通知。</p><p id="cca5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的<code class="fe kw kx ky kz b">handleAppStateChange</code>将处理应用程序进出前台的场景，并相应地更新我们的内部状态。</p><p id="0232" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的<code class="fe kw kx ky kz b">onBiometricAuthenticationSwitch</code>实际上设置了内部状态，当用户想要改变生物特征设置时，我们切换一个模态(因此分派到模态动作)来请求他们的凭证。</p><p id="135a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的<code class="fe kw kx ky kz b">checkBiometricAuthenticationForUpdate</code>将运行每个渲染，看看用户是否改变了他们的生物特征设置。</p><p id="41d5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">既然已经解释了主要功能，让我们看看测试。</p><figure class="lj lk ll lm gt jr"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="a67b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，我们导入了一些在整个测试中使用的实用程序或助手函数，这有助于我们抽象出设置测试的一些必要的细节，尤其是较新版本的<code class="fe kw kx ky kz b">jest</code>、<code class="fe kw kx ky kz b">enzyme</code>和<code class="fe kw kx ky kz b">react-native</code>。我稍后将讨论该文件，但是让我们在这里检查一些测试。</p><p id="bddc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们看看如何测试它<code class="fe kw kx ky kz b">Should update notification permissions after app resume</code>。我们将推送通知权限设置为<strong class="ka ir"> false </strong>，并将<strong class="ka ir"> AppState </strong>对象从react native设置为<em class="lb"> active。</em>通过Jest的快照功能，我们可以对按钮的外观进行快照，我们希望它是关闭的——在这种情况下，<code class="fe kw kx ky kz b">isOn</code>被设置为<strong class="ka ir">false</strong>——因为这是我们在模拟函数中设置的推送通知权限。然后，我们将应用程序置于后台，将权限设置为<strong class="ka ir">真</strong>，然后<em class="lb">等待</em> <strong class="ka ir"> <em class="lb"> </em> </strong>应用程序返回活动状态，并期望<code class="fe kw kx ky kz b">isOn</code>现在被设置为<strong class="ka ir">真</strong>。</p><p id="5b8c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">生物认证的一个重要方面显然是它的安全性，因此我们必须确保我们正在妥善保护任何秘密。当用户想要在这个设置中验证他们自己时，我们必须首先将他们的身份存储在<a class="ae la" href="https://developer.apple.com/documentation/security/keychain_services" rel="noopener ugc nofollow" target="_blank"> <em class="lb">钥匙链</em> </a> <em class="lb">，</em>中，然后我们可以在稍后的时间点检索它。</p><p id="0540" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以我们来看一下<code class="fe kw kx ky kz b">Should reset keychain and async storage on biometric option</code>测试。当用户不再希望启用生物认证时，我们必须重置钥匙串的通用密码，并永久存储用户不再希望以这种方式签名的信息。所以最终我们会期望biometric被设置为<strong class="ka ir"> false </strong>，并期望我们的<em class="lb">resetGenericPassword</em><strong class="ka ir"/>被调用。</p><p id="b1a3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以我希望通过阅读这些测试能够很容易理解，因为这是将许多技术细节抽象到下面的文件<code class="fe kw kx ky kz b">testUtils.js</code>中的主要原因，我将对此进行解释。</p><figure class="lj lk ll lm gt jr"><div class="bz fp l di"><div class="ln lo l"/></div></figure><p id="3f41" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从<code class="fe kw kx ky kz b">render</code>函数开始，由于redux，我们有多种不同的方法来呈现一个组件进行测试。我提出的一个特殊的<a class="ae la" href="https://github.com/airbnb/enzyme/issues/2185" rel="noopener ugc nofollow" target="_blank">问题</a>与使用<code class="fe kw kx ky kz b">reduxForms</code>进行渲染有关，这需要多次调用<code class="fe kw kx ky kz b">dive</code>方法。对于<code class="fe kw kx ky kz b">pureComponent</code>渲染方法来说，在测试中有时我们也想更深入一些。</p><p id="195a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">还有一些其他的实用程序来帮助<a class="ae la" href="https://jestjs.io/docs/en/es6-class-mocks#keeping-track-of-usage-spying-on-the-mock" rel="noopener ugc nofollow" target="_blank">监视</a>函数，因此有了<code class="fe kw kx ky kz b">SpyContainer</code>，但这只是为了让测试更具可读性。</p><p id="cb1f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">感谢您花时间阅读这篇文章，我希望它是有用的。如果您喜欢它和/或发现它有帮助，请留下👏。如果没有，请留下评论，让我知道我可以为下一个改进什么。我是一名全栈开发人员，擅长React Native和Angular。单元测试快乐！</p></div></div>    
</body>
</html>