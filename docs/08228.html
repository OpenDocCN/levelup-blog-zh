<html>
<head>
<title>Build A Proof of Stake Blockchain in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Go中构建一个股权证明区块链</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/build-a-proof-of-stake-blockchain-in-go-a765cb217d35?source=collection_archive---------3-----------------------#2021-04-13">https://levelup.gitconnected.com/build-a-proof-of-stake-blockchain-in-go-a765cb217d35?source=collection_archive---------3-----------------------#2021-04-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="61b2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一项正在兴起的区块链技术。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c04e0f83f885f7cb646a44689893fbf8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ySYbr-2Ji2Vu7mrs.jpg"/></div></div></figure><p id="d7d3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi lq translated">到2021年，区块链的领域将继续爆发。加密货币的指数级增长只有在私人和公共应用中采用区块链解决方案才能与之匹敌。市场分析预测<strong class="kw iu">全球区块链市场规模将从2020年的30亿美元激增至2025年的397亿美元</strong>，2020–2025年期间的有效复合年增长率(CAGR)为<strong class="kw iu"> 67.3%。</strong></p><p id="44aa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">提醒你一下，这个增长率是包含整个市场的平均值。想象一下这个领域的真正赢家会有怎样的表现。</p><p id="e696" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">此外，67%的CAGR不考虑<strong class="kw iu">加密货币</strong> <strong class="kw iu">空间</strong>的巨大收益，全球市值<strong class="kw iu">2万亿美元，并且还在增长。</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lz"><img src="../Images/e4ede690962f66feca3748b2e1619b3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pyaAkkNSbWwn7ZeGtNeCbg.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">来自<a class="ae me" href="https://coinmarketcap.com/charts/" rel="noopener ugc nofollow" target="_blank"> CoinMarketCap </a></figcaption></figure><p id="a6a5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">想象一下，如果你在2020年1月至7月的交易量增加期间买入。问题是，这显然是可能的，但你需要了解市场和它的发展方向。</p><blockquote class="mf mg mh"><p id="50df" class="ku kv mi kw b kx ky ju kz la lb jx lc mj le lf lg mk li lj lk ml lm ln lo lp im bi translated"><em class="it">随着区块链给世界市场带来的变革，</em> <strong class="kw iu"> <em class="it">在做出未来预测之前，了解基本面是至关重要的。</em> </strong> <em class="it">在本文中，我们将探讨Stake Proof的基本原理，这是一种区块链协议，类似于在区块链中锻造新区块的抽奖方法。</em></p></blockquote><p id="0add" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">本文的主要目标如下:</p><ol class=""><li id="94bd" class="mm mn it kw b kx ky la lb ld mo lh mp ll mq lp mr ms mt mu bi translated">了解区块链领域的当前绩效趋势(完成)。</li><li id="90b0" class="mm mn it kw b kx mv la mw ld mx lh my ll mz lp mr ms mt mu bi translated">通过GoLang中的一个工作示例了解利害关系的证明。</li><li id="3cb7" class="mm mn it kw b kx mv la mw ld mx lh my ll mz lp mr ms mt mu bi translated">提高你的计算机科学和编程技能。</li></ol><p id="c488" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这对霍德勒和地鼠来说都是一个有趣的游戏，让我们来编码吧！</p></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><h1 id="6241" class="nh ni it bd nj nk nl nm nn no np nq nr jz ns ka nt kc nu kd nv kf nw kg nx ny bi translated">理解利害关系的证据</h1><p id="c5c4" class="pw-post-body-paragraph ku kv it kw b kx nz ju kz la oa jx lc ld ob lf lg lh oc lj lk ll od ln lo lp im bi translated">我们将保持这一部分的简短，因为利益证明(PoS)的基本原理实际上相当简单。当然，这个系统的核心部分是区块链本身。简单地说，<strong class="kw iu">区块链</strong>是一个<strong class="kw iu">不可变的分类帐</strong>，其中<strong class="kw iu">每个单独的块都是从它之前的块加密构建的。你永远不能改变区块链的任何部分，因为每个连接到网络的人都会很容易看到这些变化，并反驳你的区块链版本。</strong></p><p id="510a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">创建新块的过程是由你的区块链协议定义的T2。比特币建立在工作证明(PoW)协议的基础上，需要越来越多的计算能力来通过数学过程验证之前的交易。每次你验证一个区块内包含的交易列表，你就会获得比特币形式的奖励。</p><p id="9c41" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，你交易历史的证据就是你投入的工作量——完成这项工作的人被称为“矿工”。随着时间的推移，解决这些数学难题需要巨大的计算能力,这是PoW 日益增长的一个<strong class="kw iu">问题。不仅如此，如果任何一个实体获得了超过51%的计算能力，他们理论上可以将区块链发散为他们想要的任何形式(这被称为<strong class="kw iu"> 51%攻击</strong>)。</strong></p><p id="af76" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">股权证明是根本不同的。</strong>不是验证和扩展区块链的计算能力，而是在区块链网络上“下注”一定数量的代币(不一定是加密货币)。这通常是通过创建你自己的“节点”来实现的，这有助于你加入区块链生态系统。节点可以是您自己的计算机，也可以是计算机网络。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/096961f7e5cefc7f39a366055017e23c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*gR4kiHYn1uoGk_sJ.jpg"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">功率与位置</figcaption></figure><p id="59cf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里细节并不重要，核心思想是，如果你的节点在做<strong class="kw iu">诚实的工作</strong>，你将有<strong class="kw iu">更高的机会</strong>在区块链<strong class="kw iu">铸造一个新的区块</strong>并且<strong class="kw iu">除了你原来的股份之外还会得到奖励</strong>。被选中伪造下一个区块的概率也随着你在网络上下注的代币数量成比例增加。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi of"><img src="../Images/0550ef155d50d4809245406e180b13e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*32PUevXiq3lReYH_v4Z6aQ.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">用LucidChart做的</figcaption></figure><p id="fea6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，如果你做了<strong class="kw iu">不诚实的行为</strong>，你的股份可能会被<strong class="kw iu">处罚</strong>甚至完全收回。这种<strong class="kw iu">奖励</strong>和<strong class="kw iu">惩罚</strong>的方法意在<strong class="kw iu">促进区块链的诚实工作</strong>而没有与工作证明相关的计算可伸缩性瓶颈。</p><p id="1458" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们已经有了PoS与power的概念，让我们继续在Go中编写一个工作的PoS示例。</p></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><h1 id="c62e" class="nh ni it bd nj nk nl nm nn no np nq nr jz ns ka nt kc nu kd nv kf nw kg nx ny bi translated">围棋股份证明</h1><p id="4e89" class="pw-post-body-paragraph ku kv it kw b kx nz ju kz la oa jx lc ld ob lf lg lh oc lj lk ll od ln lo lp im bi translated">让我们面对它，如果我已经建立了一个生产级的股权区块链证明，我不认为一个博客帖子足以解释它。这将是一个<strong class="kw iu">简单</strong>但<strong class="kw iu">功能</strong>的扩展示例，我希望你会像我在构建它时一样喜欢它。也就是说，这里仍然有相当多的复杂性，所以我们要一点一点来。如果你成功了，我相信你能创造出你自己的PoS区块链的新版本，可能比我的更好！:-)</p><h2 id="b467" class="og ni it bd nj oh oi dn nn oj ok dp nr ld ol om nt lh on oo nv ll op oq nx or bi translated">导入“区块链”</h2><p id="0ad8" class="pw-post-body-paragraph ku kv it kw b kx nz ju kz la oa jx lc ld ob lf lg lh oc lj lk ll od ln lo lp im bi translated">首先，除了定义我们的自定义对象类型之外，我们需要在项目中包含一些Go包。这里是你需要的包——我们将使用<code class="fe os ot ou ov b">math/rand</code>、<code class="fe os ot ou ov b">crypto/sha256</code>和<code class="fe os ot ou ov b">encoding/hex</code>来实现我们的加密区块链方法。当然，<code class="fe os ot ou ov b">errors</code>是围棋里的标配！</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ow ox l"/></div></figure><p id="0889" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来是我们的定制数据类型。Go通过使用<code class="fe os ot ou ov b">structs</code>让这变得超级简单。这里我们有三个自定义的<code class="fe os ot ou ov b">types</code>，第一个是<code class="fe os ot ou ov b">PoSNetwork</code>，这里我们有一个<code class="fe os ot ou ov b">Blockchain</code>字段，它是一个<em class="mi">引用</em>到<code class="fe os ot ou ov b">Block</code> <code class="fe os ot ou ov b">struct</code>实例的数组。我们将通过<code class="fe os ot ou ov b">BlockchainHead</code>字段跟踪最近添加的块，我们还将有一个数组<em class="mi">引用</em>到<code class="fe os ot ou ov b">Node</code> <code class="fe os ot ou ov b">struct</code>来充当<code class="fe os ot ou ov b">Validators</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ow ox l"/></div></figure><p id="f414" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe os ot ou ov b">Node</code>结构将有一个Stake字段，表示它添加到网络中的令牌数量。该地址将是一个随机生成的字符串，以便我们可以跟踪哪个节点成功验证了下一个块。</p><p id="a0ab" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，<code class="fe os ot ou ov b">Block</code> <code class="fe os ot ou ov b">struct</code>将包含我们需要的信息，以便<strong class="kw iu">跟踪我们的区块链</strong>。我们将有一个<code class="fe os ot ou ov b">Timestamp</code>用于表示块何时被创建，一个来自前一个块的前一个散列，<code class="fe os ot ou ov b">Hash</code>表示它自己，以及验证这个块的<code class="fe os ot ou ov b">Node</code>的地址——都是类型<code class="fe os ot ou ov b">string</code>。</p><h2 id="41ec" class="og ni it bd nj oh oi dn nn oj ok dp nr ld ol om nt lh on oo nv ll op oq nx or bi translated">一砖一瓦地建造区块链</h2><p id="76ca" class="pw-post-body-paragraph ku kv it kw b kx nz ju kz la oa jx lc ld ob lf lg lh oc lj lk ll od ln lo lp im bi translated">这是我们建立区块链的第一个方法——让我们来分解它。首先在我们的函数签名中，我们将该方法附加到<code class="fe os ot ou ov b">PoSNetwork</code> <code class="fe os ot ou ov b">struct</code>上，并将该结构引用为<code class="fe os ot ou ov b">n</code>。然后，我们把对一个<code class="fe os ot ou ov b">Node</code>的引用作为唯一的参数。我们将返回一个新的<code class="fe os ot ou ov b">Block</code>引用数组来表示新的<code class="fe os ot ou ov b">Blockchain</code>，一个对成为新的<code class="fe os ot ou ov b">BlockchainHead</code>的<code class="fe os ot ou ov b">Block</code>的引用，以及一个可能的<code class="fe os ot ou ov b">error</code>(如果事情变得棘手的话)。</p><p id="0a0c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你会注意到，在我们试图添加任何东西之前，我们立即调用了方法<code class="fe os ot ou ov b">ValidateBlockchain()</code>。我们稍后将进行验证，但只要知道如果我们发现我们的区块链被更改，<strong class="kw iu">有处罚一个</strong> <code class="fe os ot ou ov b">Node</code> <strong class="kw iu">的逻辑。</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ow ox l"/></div></figure><p id="1066" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在检查我们的<code class="fe os ot ou ov b">Blockchain</code>是否完好后，我们得到系统的当前时间，并在实例化一个新的<code class="fe os ot ou ov b">Block</code>时将其存储为<code class="fe os ot ou ov b">Timestamp</code>。我们还附上了之前散列的<code class="fe os ot ou ov b">Hash</code>，由于有了<code class="fe os ot ou ov b">BlockchainHead</code>，我们可以很容易地访问它。然后我们将调用<code class="fe os ot ou ov b">BlockchainHead</code>上的方法<code class="fe os ot ou ov b">NewBlockHash()</code>，并将输入<code class="fe os ot ou ov b">Node</code>的地址指定为我们的验证器地址。</p><p id="f126" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一旦新<code class="fe os ot ou ov b">Block</code>的字段被填充，我们就调用新<code class="fe os ot ou ov b">Block</code>上的<code class="fe os ot ou ov b">ValidateBlockCandidate()</code>并查看是否有任何<code class="fe os ot ou ov b">errors</code>。如果有，我们惩罚罪犯<code class="fe os ot ou ov b">Node</code>并返回一个<code class="fe os ot ou ov b">error</code>。如果一切顺利，我们将新的块添加到我们的<code class="fe os ot ou ov b">Blockchain</code>中。如果我们没有捕捉到一个<code class="fe os ot ou ov b">error</code>，那么第22行的return语句就是一个默认值。</p><p id="2dc5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是你会问<code class="fe os ot ou ov b">NewBlockHash()</code>是如何工作的？谢天谢地，这里没发生什么事情。我们有两个函数来完成为每个<code class="fe os ot ou ov b">Block</code>创建一个唯一的<code class="fe os ot ou ov b">Hash</code>的任务。函数<code class="fe os ot ou ov b">NewBlockHash()</code>简单地获取<code class="fe os ot ou ov b">Block</code>的所有信息，并将其连接成一个字符串传递给<code class="fe os ot ou ov b">newHash()</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ow ox l"/></div></figure><p id="1504" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，<code class="fe os ot ou ov b">newHash()</code>将利用<code class="fe os ot ou ov b">crypto/sha256</code>包创建一个新的SHA256对象，存储为<code class="fe os ot ou ov b">h</code>。然后，我们将输入字符串<code class="fe os ot ou ov b">s</code>转换成一个字节数组，并将其写入<code class="fe os ot ou ov b">h</code>。最后，我们调用<code class="fe os ot ou ov b">h.Sum()</code>将<code class="fe os ot ou ov b">h</code>转换成我们可以调用<code class="fe os ot ou ov b">hex.EncodeToString()</code>的格式，这样我们就有一个<code class="fe os ot ou ov b">string</code>作为我们的最终输出。</p><p id="53b1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">还在跟踪我？很好！</p><h2 id="28e4" class="og ni it bd nj oh oi dn nn oj ok dp nr ld ol om nt lh on oo nv ll op oq nx or bi translated">验证我们的区块链</h2><p id="88d2" class="pw-post-body-paragraph ku kv it kw b kx nz ju kz la oa jx lc ld ob lf lg lh oc lj lk ll od ln lo lp im bi translated">如果你不能证实，区块链是没有用的。这里我们将<code class="fe os ot ou ov b">ValidateBlockchain()</code>方法附加到我们的<code class="fe os ot ou ov b">PoSNetwork</code> <code class="fe os ot ou ov b">struct</code>并返回一个可能的<code class="fe os ot ou ov b">error</code>。如果区块链是空的或者只有一个块，我们没有办法确保它是正确的，所以我们只为<code class="fe os ot ou ov b">error</code>返回<code class="fe os ot ou ov b">nil</code>。</p><p id="4e8e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，我们评估区块链中每对积木之间的<strong class="kw iu">三个独立条件</strong>。首先检查前一个<code class="fe os ot ou ov b">Block</code>的<code class="fe os ot ou ov b">Hash</code>是否等于当前<code class="fe os ot ou ov b">Block</code>为其前一个<code class="fe os ot ou ov b">Hash</code>存储的数据。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ow ox l"/></div></figure><p id="0a29" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们还检查在任何一点上先前的<code class="fe os ot ou ov b">Block’s</code> <code class="fe os ot ou ov b">Timestamp</code>是否比当前的<code class="fe os ot ou ov b">Block</code>新。如果现在的<code class="fe os ot ou ov b">Block</code>是2020年做的，而之前的<code class="fe os ot ou ov b">Block</code>是2021年做的，你就知道不对劲了。</p><p id="8231" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后我们检查一下，如果我们直接计算前一个<code class="fe os ot ou ov b">Block</code>的<code class="fe os ot ou ov b">Hash</code>，我们仍然得到当前<code class="fe os ot ou ov b">Block</code>的<code class="fe os ot ou ov b">Hash</code>。如果这些条件中的任何一个成立，那么我们返回一个<code class="fe os ot ou ov b">error</code>，因为我们的区块链处于被篡改的状态。</p><p id="71aa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">既然我们已经验证了整个区块链，<strong class="kw iu">我们需要确保下一个要添加的块也是有效的</strong>。这遵循与上面相同的条件检查，只是针对要添加的单个新块。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ow ox l"/></div></figure><h2 id="9752" class="og ni it bd nj oh oi dn nn oj ok dp nr ld ol om nt lh on oo nv ll op oq nx or bi translated">获胜者，象征性晚餐</h2><p id="fc94" class="pw-post-body-paragraph ku kv it kw b kx nz ju kz la oa jx lc ld ob lf lg lh oc lj lk ll od ln lo lp im bi translated">好了，现在我们已经完成了向区块链添加新块以及验证其正确性的步骤。那么，我们如何决定何时添加新块呢？这就是我们的验证器发挥作用的地方。对于在网络中有股份的每个节点，我们将通过抽奖方法随机选择一个节点来伪造我们的区块链中的下一个块并获得奖励。</p><p id="3d9a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是首先，我们首先需要一个<code class="fe os ot ou ov b">Node</code>。为了给我们的<code class="fe os ot ou ov b">PoSNetwork</code>添加一个新的<code class="fe os ot ou ov b">Node</code>，我们调用<code class="fe os ot ou ov b">NewNode()</code>，它接受<code class="fe os ot ou ov b">Node</code>的初始股份并返回一个新的<code class="fe os ot ou ov b">Node</code>引用数组。这里没有什么特别的，我们只是添加到我们的<code class="fe os ot ou ov b">n.Validators</code>数组，并调用<code class="fe os ot ou ov b">randAddress()</code>为新的<code class="fe os ot ou ov b">Node</code>生成一个唯一的地址。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ow ox l"/></div></figure><p id="5045" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">那么，我们实际上如何挑选一个赢家呢？<strong class="kw iu">用一点概率统计！</strong>在<code class="fe os ot ou ov b">SelectWinner()</code>方法中，我们首先通过在<code class="fe os ot ou ov b">n.Validators</code>范围内进行测距，找到网络内持有的总股份。我们还将任何stake大于零的节点添加到数组<code class="fe os ot ou ov b">winnerPool</code>中以供选择。</p><p id="b0ad" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们发现<code class="fe os ot ou ov b">winnerPool</code>是空的，我们返回一个<code class="fe os ot ou ov b">error</code>。没有人喜欢一个破产的赌徒。然后，我们使用<code class="fe os ot ou ov b">Intn()</code>方法选择一个中奖号码，该方法将在0和我们的总赌注之间选择一个随机数。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ow ox l"/></div></figure><p id="79e4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后一部分是概率发挥作用的地方。为了保持每个节点都有与其在网络中的总<code class="fe os ot ou ov b">Stake</code>成比例的获胜机会，我们递增地将当前<code class="fe os ot ou ov b">Node</code>的<code class="fe os ot ou ov b">Stake</code>添加到<code class="fe os ot ou ov b">tmp</code>变量中。如果在任何时候中奖号码小于<code class="fe os ot ou ov b">tmp</code>，则<code class="fe os ot ou ov b">Node</code>将被选为我们的赢家。</p><p id="d381" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">那是怎么回事？嗯，也不是太复杂。假设中奖号码是45，我们有四个节点，分别标有10、30、20和40个代币。如果我们跟踪节点的累积值，并比较中奖号码是否小于该累积值，我们将会把中奖概率分配到成比例的“桶”中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oy"><img src="../Images/ddba407b20e7dff4e5330e4c87c33c35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aAuCQFWc3NjZUsCz1frKyw.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">用LucidChart做的</figcaption></figure><p id="2c52" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">看上面的图片，随机中奖号码落在前10个令牌桶中的概率有多大？嗯，10/(10+30+20+40) = 10/100 = 10%。是成比例的！具有累加和<code class="fe os ot ou ov b">tmp</code>的for循环只允许每个节点的赌注分散到桶中。你的赌注越大，你的桶就越大，因此你赢得和铸造新积木的几率就越大。</p><h2 id="1a3a" class="og ni it bd nj oh oi dn nn oj ok dp nr ld ol om nt lh on oo nv ll op oq nx or bi translated">将这一切结合在一起</h2><p id="9ce9" class="pw-post-body-paragraph ku kv it kw b kx nz ju kz la oa jx lc ld ob lf lg lh oc lj lk ll od ln lo lp im bi translated">我们现在所需要的是将我们的函数和数据类型结合在一起。我们在我们的<code class="fe os ot ou ov b">main()</code>函数中做了所有好的事情。第一步是设置一个随机种子，将当前时间作为我们的输入。不要使用时间作为随机种子的输入，因为它实际上会在解码您的哈希输出时引入安全漏洞。在本例中，我们需要用Genesis区块(也称为区块链的第一个区块)实例化一个新的股权证明网络。一旦我们这样做了，我们也设置网络的BlockchainHead等于第一个块。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ow ox l"/></div></figure><p id="9557" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，我们向网络中添加两个<code class="fe os ot ou ov b">Nodes</code>作为验证器，用60和40个令牌作为它们的初始<code class="fe os ot ou ov b">Stake</code>。在五次迭代中，我们将为我们的<code class="fe os ot ou ov b">Blockchain</code>选择一个新的获胜者，如果有任何错误，我们的程序就会崩溃——因为原型制作。我们通过新选择的获胜者来生成一个新的<code class="fe os ot ou ov b">Block</code>，并打印出每一轮每一个<code class="fe os ot ou ov b">Node</code>的总数<code class="fe os ot ou ov b">Stake</code>。</p><p id="93e5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">想知道为什么我有所有这些函数的返回类型，而不是直接把它们添加到PoSNetwork结构中吗？好吧，Go不喜欢你这样做——所以你实际上必须将新构造的数组或对象返回到初始函数调用中。我希望有更好的解决办法。</p><p id="cdca" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这一切结束时，我们将打印出我们新制作的区块链。下面是一个运行示例:</p><pre class="kj kk kl km gt oz ov pa pb aw pc bi"><span id="6065" class="og ni it ov b gy pd pe l pf pg">$ go run main.go <br/>Round  0<br/>        Address: f8d44bb083078de97b8428f4f9548130 -Stake: 70<br/>        Address: de6ae18584f02b3388569191a04a4b4a -Stake: 40<br/>Round  1<br/>        Address: f8d44bb083078de97b8428f4f9548130 -Stake: 70<br/>        Address: de6ae18584f02b3388569191a04a4b4a -Stake: 50<br/>Round  2<br/>        Address: f8d44bb083078de97b8428f4f9548130 -Stake: 80<br/>        Address: de6ae18584f02b3388569191a04a4b4a -Stake: 50<br/>Round  3<br/>        Address: f8d44bb083078de97b8428f4f9548130 -Stake: 90<br/>        Address: de6ae18584f02b3388569191a04a4b4a -Stake: 50<br/>Round  4<br/>        Address: f8d44bb083078de97b8428f4f9548130 -Stake: 100<br/>        Address: de6ae18584f02b3388569191a04a4b4a -Stake: 50<br/>Block 0 Info:<br/>        Timestamp: 2021-04-12 MDT m=+0.000120025<br/>        Previous Hash: <br/>        Hash: c5d04de14efed52ce84889c6382f9d307d5b98093d93a84b419478<br/>        Validator Address: <br/>Block 1 Info:<br/>        Timestamp: 2021-04-12 MDT m=+0.000277288<br/>        Previous Hash: c5d04de14efed52ce84889c6382f9d307d5b98093d93a<br/>        Hash: d58e90a75b71ac62ef938fc0148314a7f864ad50bd702f959e2d27<br/>        Validator Address: f8d44bb083078de97b8428f4f9548130<br/>Block 2 Info:<br/>        Timestamp: 2021-04-12 MDT m=+0.000306562<br/>        Previous Hash: d58e90a75b71ac62ef938fc0148314a7f864ad50bd702<br/>        Hash: e6bfdd6c2c869607e2d9a81b84ddf4478756fedff78a03746cde11<br/>        Validator Address: de6ae18584f02b3388569191a04a4b4a<br/>Block 3 Info:<br/>        Timestamp: 2021-04-12 MDT m=+0.000321755<br/>        Previous Hash: e6bfdd6c2c869607e2d9a81b84ddf4478756fedff78a0<br/>        Hash: 8e3dbacc4a610b1665658bc9e7238963eda0d5bbbf3ce809e8fa6e<br/>        Validator Address: f8d44bb083078de97b8428f4f9548130<br/>Block 4 Info:<br/>        Timestamp: 2021-04-12 MDT m=+0.000333024<br/>        Previous Hash: 8e3dbacc4a610b1665658bc9e7238963eda0d5bbbf3ce<br/>        Hash: 22760f8deb96c354a4050a3c48741be062bccfa9c51571c170065a<br/>        Validator Address: f8d44bb083078de97b8428f4f9548130<br/>Block 5 Info:<br/>        Timestamp: 2021-04-12 MDT m=+0.000347521<br/>        Previous Hash: 22760f8deb96c354a4050a3c48741be062bccfa9c5157<br/>        Hash: d2a5047f7d8a7696c1d0fb9ec49b56d2e71bbcedaaebc83a18b7a5<br/>        Validator Address: f8d44bb083078de97b8428f4f9548130</span></pre><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ph ox l"/></div></figure></div><div class="ab cl na nb hx nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="im in io ip iq"><h1 id="19ab" class="nh ni it bd nj nk nl nm nn no np nq nr jz ns ka nt kc nu kd nv kf nw kg nx ny bi translated">下一步是什么</h1><p id="14d7" class="pw-post-body-paragraph ku kv it kw b kx nz ju kz la oa jx lc ld ob lf lg lh oc lj lk ll od ln lo lp im bi translated">我已经听出来了，你的例子不是分散的！这是弱验证！什么事都要自己做！等等等等。听着，如果你在这个例子中看到你认为可以做得更好的东西——就去做。当你建立了一个比现在更好更酷的区块链，写一篇文章告诉我吧！如果你能找到改进这个例子的方法，同时将知识分享给社区，我认为这是一件好事。</p><p id="c8e5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你想知道在这个例子的基础上下一步可以做什么，我有消息告诉你。以下是一些想法的简短列表:</p><ul class=""><li id="f2c0" class="mm mn it kw b kx ky la lb ld mo lh mp ll mq lp pi ms mt mu bi translated">测试——你会注意到我没有包括任何测试，这在现代软件工程中是一种亵渎！编写一些基本的单元测试，并确保我的例子至少通过其中的一些测试。</li><li id="1eb8" class="mm mn it kw b kx mv la mw ld mx lh my ll mz lp pi ms mt mu bi translated">并发性(Concurrency)—这些都在一个线程中运行，这在现实世界中永远不会发生。尝试为主线程托管单个TCP服务器，并让连接节点同时尝试添加到区块链。</li><li id="1bf2" class="mm mn it kw b kx mv la mw ld mx lh my ll mz lp pi ms mt mu bi translated"><strong class="kw iu">去中心化</strong>——你能制造一个不在单台计算机上运行的PoS机，并推广为网络所有吗？</li><li id="14c2" class="mm mn it kw b kx mv la mw ld mx lh my ll mz lp pi ms mt mu bi translated"><strong class="kw iu">重构</strong> —这段代码可以简单地进行一些清理，使其更加高效、优雅和简洁。试着做一个比我的更容易理解的例子吧！</li><li id="493d" class="mm mn it kw b kx mv la mw ld mx lh my ll mz lp pi ms mt mu bi translated"><strong class="kw iu">加权</strong> —如果单个节点开始以巨大的股份控制网络会怎样？你能指数平均权重吗，或者有更好的选择吗？</li><li id="a19f" class="mm mn it kw b kx mv la mw ld mx lh my ll mz lp pi ms mt mu bi translated"><strong class="kw iu">令牌化</strong> —如何让交易在这个网络上运行？新积木的象征性奖励如何随时间减少以防止通货膨胀？</li></ul><p id="cce7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">无论你做什么，我希望这篇文章教会你一些新的东西，无论是关于区块链、围棋，还是只是一些编程的乐趣。无论你对这篇文章有什么想法，我都希望在下面的评论中听到它们！感谢阅读。</p></div></div>    
</body>
</html>