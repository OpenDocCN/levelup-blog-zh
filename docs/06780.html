<html>
<head>
<title>Find, Filter, Map and Reduce put to action</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">查找、过滤、映射和减少付诸行动</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/find-filter-map-and-reduce-put-to-action-e4f1a38e5607?source=collection_archive---------10-----------------------#2020-12-30">https://levelup.gitconnected.com/find-filter-map-and-reduce-put-to-action-e4f1a38e5607?source=collection_archive---------10-----------------------#2020-12-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="7ac4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">找</em>，<em class="kl">滤镜</em>，<em class="kl">贴图</em>和<em class="kl">减少</em>都是很神奇的<em class="kl">数组</em> <em class="kl">方法</em>来自<em class="kl"> JavaScript </em>，但是有时候我觉得大部分人还是有点搞不清楚它们🧐.所以在这篇短文中，我想用一些简单的代码片段展示这四个高阶函数<em class="kl">在实践中做了什么。</em></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi km"><img src="../Images/ba6ea56135ee91dc061402fcedee5ce4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/1*bmb4GMME67Qb--1PpVw6ag.png"/></div></figure><blockquote class="ku kv kw"><p id="b554" class="jn jo kl jp b jq jr js jt ju jv jw jx kx jz ka kb ky kd ke kf kz kh ki kj kk ij bi translated">我们称高阶函数为接受其他函数作为参数的函数，例如:find、filter、map和reduce。</p></blockquote><p id="7725" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们想象一下，我们正在与一个社交媒体API合作，我们正在获取用户的活动。我们收到的响应类似于下面的代码—请注意，对于所有用户，响应的模式并不相同:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="gh gi la"><img src="../Images/2b792818db92ba88d68a0ff040e2fdaa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U-hWNg14s5Yeia0sv0mdsA.png"/></div></div><figcaption class="lf lg gj gh gi lh li bd b be z dk translated">响应API</figcaption></figure></div><div class="ab cl lj lk hu ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="ij ik il im in"><h1 id="89d2" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">发现</h1><p id="72bb" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">第一个场景是:<strong class="jp ir">我们希望通过用户的id来查找用户。</strong>我们可以很容易地使用<em class="kl">查找</em> <em class="kl">方法</em>，传递搜索<em class="kl">参数</em> : <em class="kl"> user.id === id </em>。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="gh gi mt"><img src="../Images/4f049e8301a09ff17f38d9fcd1ee65bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-dXQJpzauwYBrmnzo9Dn2g.png"/></div></div><figcaption class="lf lg gj gh gi lh li bd b be z dk translated">函数通过id获取用户，使用find方法</figcaption></figure><ul class=""><li id="905d" class="mu mv iq jp b jq jr ju jv jy mw kc mx kg my kk mz na nb nc bi translated">这个<em class="kl">方法</em>返回找到的项目本身(本例中是一个对象)。</li><li id="25f2" class="mu mv iq jp b jq nd ju ne jy nf kc ng kg nh kk mz na nb nc bi translated">即使有多个条目与语句<strong class="jp ir">匹配，也只会返回第一个匹配的条目。</strong></li><li id="568d" class="mu mv iq jp b jq nd ju ne jy nf kc ng kg nh kk mz na nb nc bi translated">如果没有<em class="kl">值</em>匹配，将返回<em class="kl">未定义</em>。</li></ul><pre class="kn ko kp kq gt ni nj nk nl aw nm bi"><span id="8b8f" class="nn lr iq nj b gy no np l nq nr">The <em class="kl">Find method</em> signature is:<br/><strong class="nj ir"><em class="kl">array.find(callback(element,[, index[, array]]))<br/></em></strong><em class="kl">* index and array are optional</em></span></pre></div><div class="ab cl lj lk hu ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="ij ik il im in"><h1 id="e456" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">过滤器</h1><p id="1b96" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated"><em class="kl"> Filter </em> <em class="kl">方法</em>与<em class="kl"> find </em>非常相似，但在这种情况下，<strong class="jp ir">我们感兴趣的是过滤列表，并最终根据我们定义的定界获得多个项目</strong>:<em class="kl">user . reaction[type]【反应类型】&gt;值。</em></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="gh gi ns"><img src="../Images/5be87d7481a643fff228af759aa2e49e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vOwyZPSik_OueBSx-4r5dA.png"/></div></div><figcaption class="lf lg gj gh gi lh li bd b be z dk translated">函数来获得反应，使用过滤方法。</figcaption></figure><ul class=""><li id="25d4" class="mu mv iq jp b jq jr ju jv jy mw kc mx kg my kk mz na nb nc bi translated">这个<em class="kl">方法</em>总是返回一个项目的<em class="kl">数组</em>。</li><li id="24e0" class="mu mv iq jp b jq nd ju ne jy nf kc ng kg nh kk mz na nb nc bi translated">重点:<strong class="jp ir"/><strong class="jp ir"><em class="kl">滤镜</em> <em class="kl">方法</em>返回完整项。</strong>我们无法选择返回，例如，只有来自用户的id，在这种情况下，我们必须使用另一种<em class="kl">方法</em>来获得这个。</li></ul><pre class="kn ko kp kq gt ni nj nk nl aw nm bi"><span id="2558" class="nn lr iq nj b gy no np l nq nr">The <em class="kl">Filter method</em> signature is:<br/><strong class="nj ir"><em class="kl">array.filter(callback(currentValue[, index[, array]])<br/></em></strong><em class="kl">* index and array are optional</em></span></pre></div><div class="ab cl lj lk hu ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="ij ik il im in"><h1 id="34dd" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">地图</h1><p id="45c5" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated"><em class="kl">贴图</em> <em class="kl">方法</em>常用于<em class="kl">反应JS、</em>但是<em class="kl"> </em>原因就不那么清楚了。当<strong class="jp ir">我们想要迭代一个<em class="kl">数组</em>并获得一个新的<em class="kl">数组</em> </strong>时，我们使用这个<em class="kl">方法</em>——可能具有独占属性，就像我在关于<em class="kl">过滤器</em>的主题中举例说明的情况。在下面的例子中，我们想通过某种类型得到用户的反应，所以我们使用<em class="kl"> map </em>迭代，只得到具体的反应类型。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="gh gi nt"><img src="../Images/140b4b9e679dd11a07e26e567cbb2c98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bAm8auK0ZFrdX4_n-bebMw.png"/></div></div><figcaption class="lf lg gj gh gi lh li bd b be z dk translated">函数通过类型获得反应，使用map方法。</figcaption></figure><ul class=""><li id="4876" class="mu mv iq jp b jq jr ju jv jy mw kc mx kg my kk mz na nb nc bi translated"><em class="kl">映射</em> <strong class="jp ir">返回一个<em class="kl">数组</em>，该数组总是与原始数组</strong>具有相同的长度，这可能很棘手！在本例中，id为3的用户没有属性<em class="kl"> reactions.comments </em>，因此它将在最终数组中作为<em class="kl"> undefined </em>返回——在这种情况下，您可能会考虑使用<em class="kl">过滤器</em>链，但我们将在前面看到更好的解决方案。</li><li id="286b" class="mu mv iq jp b jq nd ju ne jy nf kc ng kg nh kk mz na nb nc bi translated">这个<em class="kl">方法</em>已经<strong class="jp ir"> <em class="kl">推送</em>每个<em class="kl">循环</em> </strong>返回的<em class="kl">值</em>，所以我们可以省略<em class="kl">推送</em>关键字。</li><li id="8613" class="mu mv iq jp b jq nd ju ne jy nf kc ng kg nh kk mz na nb nc bi translated">如果我们只想改变数组上的某个东西，那么<strong class="jp ir"> <em class="kl"> forEach </em> <em class="kl">方法</em>就足够了——这个<em class="kl">方法</em>没有返回。</strong></li><li id="1426" class="mu mv iq jp b jq nd ju ne jy nf kc ng kg nh kk mz na nb nc bi translated">在<em class="kl"> React JS </em>中，我们总是使用<em class="kl">映射</em>来遍历列表，并返回列表中的所有项目，以呈现在屏幕上，<strong class="jp ir">所以我们使用<em class="kl">映射</em>，因为我们需要<em class="kl">数组的</em>返回。</strong></li></ul><pre class="kn ko kp kq gt ni nj nk nl aw nm bi"><span id="5177" class="nn lr iq nj b gy no np l nq nr">The <em class="kl">Map method</em> signature is:<br/><strong class="nj ir"><em class="kl">array.map(callback(currentValue[, index[, array]])<br/></em></strong><em class="kl">* index and array are optional</em></span></pre></div><div class="ab cl lj lk hu ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="ij ik il im in"><h1 id="56eb" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">减少</h1><p id="701e" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">最后但并非最不重要的是，<em class="kl">方法</em> <em class="kl">减少</em>造成了很多恐惧和困惑🥺，但一旦你明白如何使用它，你就会爱上它！<strong class="jp ir">这个<em class="kl">方法</em>用于将一个<em class="kl">数组</em>还原为一个新值(可能是一个<em class="kl">字符串</em>，一个<em class="kl">数字</em>，另一个<em class="kl">数组</em>，一个<em class="kl">对象</em>)。</strong></p><p id="71f5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl"> Reduce </em>能够解决我们在<em class="kl"> map </em>用法上遇到的问题:我们想通过类型获得用户的反应，但是用户的对象没有相同的模式，所以我们需要验证类型是否存在。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="gh gi nu"><img src="../Images/8b356db6792511e62e97083502867fe9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uu1S6cDdGUzLG0-hY2whsQ.png"/></div></div><figcaption class="lf lg gj gh gi lh li bd b be z dk translated">函数使用reduce方法按类型获取反应。</figcaption></figure><ul class=""><li id="b807" class="mu mv iq jp b jq jr ju jv jy mw kc mx kg my kk mz na nb nc bi translated">这个<em class="kl">方法</em>返回<em class="kl">累加器</em>，它的类型根据我们在初始<em class="kl">值参数</em>上的设置而变化，这里是:【】(一个<em class="kl">数组</em>)。如果没有初始<em class="kl">值</em>，来自<em class="kl">数组</em>的第一个<em class="kl">值</em>将是<em class="kl">累加器</em>。</li><li id="5e16" class="mu mv iq jp b jq nd ju ne jy nf kc ng kg nh kk mz na nb nc bi translated">不要忘记返回<em class="kl">方法</em>内部的东西，否则会返回<em class="kl">未定义的</em>。一个常见的错误是这样写:<em class="kl">return reactions list . push(reaction)。</em>但是在这种情况下问题是<em class="kl"> push </em> <em class="kl">方法</em>返回<em class="kl">数组</em>的<em class="kl"> length </em>表示我们正在推送一些东西，这会弄乱你的代码！所以总是返回<em class="kl">累加器</em>值本身。</li></ul><blockquote class="ku kv kw"><p id="5ae7" class="jn jo kl jp b jq jr js jt ju jv jw jx kx jz ka kb ky kd ke kf kz kh ki kj kk ij bi translated">黄金提示:如果你用的是贴图+滤镜，闻起来像是缩小版！<em class="iq">🤯</em>T99】</p></blockquote><pre class="kn ko kp kq gt ni nj nk nl aw nm bi"><span id="0339" class="nn lr iq nj b gy no np l nq nr">The magical formula is basically this:<br/><strong class="nj ir"><em class="kl">array.reduce(callback(accumulator, currentValue, [, index[, array]] )[, initialValue])<br/></em></strong><em class="kl">* index, array and initialValue are optional</em></span></pre></div><div class="ab cl lj lk hu ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="ij ik il im in"><p id="d37d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我希望我能让你明白我们使用这些强有力的方法的区别和原因，如果你喜欢这篇文章，再见，鼓掌50次！🍄</p></div></div>    
</body>
</html>