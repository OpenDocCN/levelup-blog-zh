<html>
<head>
<title>DIY: Multithreading vs Multiprocessing in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">DIY:Python中的多线程与多处理</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/diy-multithreading-vs-multiprocessing-in-python-fb93698ca7f3?source=collection_archive---------5-----------------------#2020-04-13">https://levelup.gitconnected.com/diy-multithreading-vs-multiprocessing-in-python-fb93698ca7f3?source=collection_archive---------5-----------------------#2020-04-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/637ff64004f694642fb0bcea4809f30f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F8ckVaR__PlBssnf-mn76A.png"/></div></div></figure><p id="7f20" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">DIY？你是说，自己动手？多线程？多重处理？那只是同时做多项任务，对吧？我不用担心，我的电脑会处理好的。但是怎么做呢？</p><p id="b32e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本文中，我们将学习Python中多线程和多重处理的内容、原因和方式。在我们深入研究代码之前(这里有<a class="ae kw" href="https://github.com/varunkumar032/python_threading_vs_multiprocessing" rel="noopener ugc nofollow" target="_blank">和</a>，让我们理解这些术语的含义。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><p id="3c2f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一个<strong class="ka ir">程序</strong>是一个可执行文件，它由一组执行某项任务的指令组成，通常存储在你电脑的磁盘上。</p><p id="4d57" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一个<strong class="ka ir">进程</strong>就是我们所说的一个程序，它已经和它运行所需的所有资源一起被加载到内存中。它有自己的存储空间。</p><p id="14bd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一个<strong class="ka ir">线程</strong>是一个进程中的执行单元。一个进程可以有多个线程作为它的一部分运行，其中每个线程使用进程的内存空间并与其他线程共享。</p><p id="92db" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">多线程</strong>是一种技术，在这种技术中，一个进程产生多个线程，在几乎相同的时间一个接一个地执行不同的任务。这给你一种线程并行运行的错觉，但它们实际上是以并发方式运行的。在Python中，全局解释器锁(GIL)防止线程同时运行。</p><p id="ef2c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">多重处理</strong>是一种实现最真实的并行性的技术。多个进程跨多个CPU内核运行，这些内核之间不共享资源。每个进程可以有许多线程在自己的内存空间中运行。在Python中，每个进程都有自己的Python解释器实例来执行指令。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><p id="4f76" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">唷，有很多关键词。现在，事不宜迟，让我们进入程序，尝试以六种不同的方式执行两种不同类型的函数:<strong class="ka ir"> IO绑定的</strong>和<strong class="ka ir"> CPU绑定的</strong>。在IO绑定的函数中，我们要求CPU闲置并打发时间，而在CPU绑定的函数中，CPU将忙于生成一些数字。</p><h2 id="f238" class="le lf iq bd lg lh li dn lj lk ll dp lm kj ln lo lp kn lq lr ls kr lt lu lv lw bi translated">要求:</h2><ol class=""><li id="a4ea" class="lx ly iq ka b kb lz kf ma kj mb kn mc kr md kv me mf mg mh bi translated">一台Windows电脑(我的机器有6个内核)。</li><li id="a36b" class="lx ly iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated">Python 3.x已安装。</li><li id="3148" class="lx ly iq ka b kb mi kf mj kj mk kn ml kr mm kv me mf mg mh bi translated">编写Python程序的任何文本编辑器/IDE(我在这里使用Sublime Text)。</li></ol><p id="1cf9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是我们程序的结构，它在所有六个部分中都是通用的。在我提到<code class="fe mn mo mp mq b"># YOUR CODE SNIPPET HERE</code>的地方，边走边用各个部分的代码片段替换。</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="fb52" class="le lf iq mq b gy mz na l nb nc">import time, os<br/>from threading import Thread, current_thread<br/>from multiprocessing import Process, current_process</span><span id="169d" class="le lf iq mq b gy nd na l nb nc">COUNT = 200000000<br/>SLEEP = 10</span><span id="0240" class="le lf iq mq b gy nd na l nb nc">def io_bound(sec):<br/>    pid = os.getpid()<br/>    threadName = current_thread().name<br/>    processName = current_process().name<br/>    print(f"{pid} * {processName} * {threadName} \<br/>        ---&gt; Start sleeping...")<br/>    time.sleep(sec)<br/>    print(f"{pid} * {processName} * {threadName} \<br/>        ---&gt; Finished sleeping...")</span><span id="4970" class="le lf iq mq b gy nd na l nb nc">def cpu_bound(n):<br/>    pid = os.getpid()<br/>    threadName = current_thread().name<br/>    processName = current_process().name<br/>    print(f"{pid} * {processName} * {threadName} \<br/>        ---&gt; Start counting...")<br/>    while n&gt;0:<br/>        n -= 1<br/>    print(f"{pid} * {processName} * {threadName} \<br/>        ---&gt; Finished counting...")</span><span id="a5e8" class="le lf iq mq b gy nd na l nb nc">if __name__=="__main__":<br/>    start = time.time()</span><span id="08e8" class="le lf iq mq b gy nd na l nb nc">    # YOUR CODE SNIPPET HERE</span><span id="80bb" class="le lf iq mq b gy nd na l nb nc">    end = time.time()<br/>    print('Time taken in seconds -', end - start)</span></pre></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h2 id="59f9" class="le lf iq bd lg lh li dn lj lk ll dp lm kj ln lo lp kn lq lr ls kr lt lu lv lw bi translated">第1部分:运行两次IO绑定任务，一个接一个…</h2><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="c60d" class="le lf iq mq b gy mz na l nb nc">    # Code snippet for Part 1<br/>    io_bound(SLEEP)<br/>    io_bound(SLEEP)</span></pre><p id="46eb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里，我们要求我们的CPU执行函数<code class="fe mn mo mp mq b">io_bound()</code>，它接受一个整数(这里是10)作为参数，并要求CPU休眠那么多秒。这个执行总共需要20秒，因为每个函数的执行需要10秒才能完成。注意，是同一个<em class="ne">主进程</em>使用它的默认线程<em class="ne">主线程</em>一个接一个地调用我们的函数两次。</p><figure class="mr ms mt mu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nf"><img src="../Images/82da76546ce29c853098da2f9e74f895.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f9eR9uNh8AwKEUM9y0gRsQ.jpeg"/></div></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">第1部分的输出</figcaption></figure></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h2 id="e974" class="le lf iq bd lg lh li dn lj lk ll dp lm kj ln lo lp kn lq lr ls kr lt lu lv lw bi translated">第2部分:使用线程运行IO绑定任务…</h2><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="ffbe" class="le lf iq mq b gy mz na l nb nc">    # Code snippet for Part 2<br/>    t1 = Thread(target=io_bound, args=(SLEEP,))<br/>    t2 = Thread(target=io_bound, args=(SLEEP,))<br/>    t1.start()<br/>    t2.start()<br/>    t1.join()<br/>    t2.join()</span></pre><p id="220d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里，让我们使用Python中的线程来加速函数的执行。线程<em class="ne"> Thread-1 </em>和<em class="ne"> Thread-2 </em>由我们的<em class="ne">主进程</em>启动，它们几乎同时调用我们的函数。这两个线程同时完成了休眠10秒的工作。这将我们整个程序的总执行时间显著减少了50%。因此，多线程是执行任务的首选解决方案，其中CPU的空闲时间可以用来执行其他任务。因此，通过利用等待时间来节省时间。</p><figure class="mr ms mt mu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nk"><img src="../Images/add85cebda39b7b61e273703fef8299e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y0mOWms49SXvS-sCA0unCQ.jpeg"/></div></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">第2部分的输出</figcaption></figure></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h2 id="c162" class="le lf iq bd lg lh li dn lj lk ll dp lm kj ln lo lp kn lq lr ls kr lt lu lv lw bi translated">第3部分:运行两次CPU绑定的任务，一个接一个…</h2><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="b005" class="le lf iq mq b gy mz na l nb nc">    # Code snippet for Part 3<br/>    cpu_bound(COUNT)<br/>    cpu_bound(COUNT)</span></pre><p id="ee03" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里，我们将调用我们的函数<code class="fe mn mo mp mq b">cpu_bound()</code>，它接受一个大数字(这里是200000000)作为参数，并在每一步递减它，直到它为零。我们的CPU被要求在每次函数调用时进行倒计时，大概需要12秒左右(这个数字在您的机器上可能会有所不同)。因此，整个程序的执行花费了我大约26秒的时间。请注意，这又是我们的<em class="ne">主进程</em>在其默认线程<em class="ne">主线程</em>中一个接一个地调用该函数两次。</p><figure class="mr ms mt mu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nl"><img src="../Images/3b5d4eeb92235fb798e6607ba1a78dc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-FKbygXelyxbdTnB9LENeA.jpeg"/></div></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">第3部分的输出</figcaption></figure></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h2 id="35fc" class="le lf iq bd lg lh li dn lj lk ll dp lm kj ln lo lp kn lq lr ls kr lt lu lv lw bi translated">第4部分:线程化能加速我们CPU受限的任务吗？</h2><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="f025" class="le lf iq mq b gy mz na l nb nc">    # Code snippet for Part 4<br/>    t1 = Thread(target=cpu_bound, args=(COUNT,))<br/>    t2 = Thread(target=cpu_bound, args=(COUNT,))<br/>    t1.start()<br/>    t2.start()<br/>    t1.join()<br/>    t2.join()</span></pre><p id="c880" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好了，我们刚刚证明了线程对于多个IO绑定的任务非常有效。让我们使用同样的方法来执行CPU受限的任务。最初，它确实同时启动了我们的线程，但是最后，我们看到整个程序的执行用了大约40秒！刚刚发生了什么？这是因为当<em class="ne">线程-1 </em>启动时，它获得了全局解释器锁(GIL ),这阻止了<em class="ne">线程-2 </em>使用CPU。因此，<em class="ne"> Thread-2 </em>必须等待<em class="ne"> Thread-1 </em>完成其任务并释放锁，这样它才能获得锁并执行其任务。锁的获取和释放增加了总执行时间的开销。因此，我们可以有把握地说，对于需要CPU处理的任务，线程不是理想的解决方案。</p><figure class="mr ms mt mu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nm"><img src="../Images/70724037c71a00fe625748ed404a6206.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Au4tNl_ad4AeZixQ5xMupw.jpeg"/></div></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">第4部分的输出</figcaption></figure></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h2 id="dbc5" class="le lf iq bd lg lh li dn lj lk ll dp lm kj ln lo lp kn lq lr ls kr lt lu lv lw bi translated">第5部分:那么，将任务分割成独立的过程有效吗？</h2><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="a621" class="le lf iq mq b gy mz na l nb nc">    # Code snippet for Part 5<br/>    p1 = Process(target=cpu_bound, args=(COUNT,))<br/>    p2 = Process(target=cpu_bound, args=(COUNT,))<br/>    p1.start()<br/>    p2.start()<br/>    p1.join()<br/>    p2.join()</span></pre><p id="e4d6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们开门见山吧。多重处理是答案。在这里，<em class="ne">主进程</em>旋转出两个子进程，具有不同的PID，每个子进程都负责将数字减为零。每个进程并行运行，利用独立的CPU内核和自己的Python解释器实例，因此整个程序的执行只花了12秒。请注意，输出可能会以无序的方式打印，因为流程是相互独立的。每个进程在自己的默认线程<em class="ne">主线程</em>中执行该功能。在程序执行期间打开任务管理器。您可以看到Python解释器的3个实例，分别对应于<em class="ne">主进程</em>、<em class="ne">进程-1 </em>和<em class="ne">进程-2 </em>。您还可以看到，在程序执行期间，两个子进程的功耗“非常高”，因为它们正在执行的任务实际上消耗了它们自己的CPU内核，如CPU性能图中的峰值所示。</p><figure class="mr ms mt mu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nn"><img src="../Images/405022cb096e66aad606111bb85c7e85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BIVXyucOqAqZOZeOqYNhZQ.jpeg"/></div></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">第5部分的输出</figcaption></figure><figure class="mr ms mt mu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi no"><img src="../Images/7389d74d020bd7ee8fc598705660fe38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ou231U5wHRBLXay6Z8f1vg.jpeg"/></div></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">任务管理器中的进程:CPU受限任务的多重处理</figcaption></figure><figure class="mr ms mt mu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi np"><img src="../Images/57572d0c7ab8c8dcb69f276f0d4f85d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-WphIJ_iEERHdk65gQYjsQ.jpeg"/></div></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">任务管理器的性能:CPU受限任务的多重处理</figcaption></figure></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h2 id="c3ba" class="le lf iq bd lg lh li dn lj lk ll dp lm kj ln lo lp kn lq lr ls kr lt lu lv lw bi translated">第6部分:嘿，让我们为IO绑定的任务使用多处理…</h2><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="9788" class="le lf iq mq b gy mz na l nb nc">    # Code snippet for Part 6<br/>    p1 = Process(target=io_bound, args=(SLEEP,))<br/>    p2 = Process(target=io_bound, args=(SLEEP,))<br/>    p1.start()<br/>    p2.start()<br/>    p1.join()<br/>    p2.join()</span></pre><p id="2420" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">既然我们对多处理帮助我们实现并行有了一个合理的想法，我们将尝试使用这种技术来运行我们的IO绑定任务。我们确实观察到结果是不同寻常的，就像多线程的情况一样。由于进程<em class="ne"> Process-1 </em>和<em class="ne"> Process-2 </em>正在执行请求它们自己的CPU内核空闲几秒钟的任务，我们没有发现高功耗。但是创建进程本身是一项CPU繁重的任务，比创建线程需要更多的时间。此外，进程比线程需要更多的资源。因此，对于IO绑定的任务，最好将多处理作为第二选择，多线程作为第一选择。</p><figure class="mr ms mt mu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nq"><img src="../Images/95b6c27bdd2e576cbc3d64721b0fd551.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OSn2I8ylwF-19YEMm0CpjA.jpeg"/></div></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">第6部分的输出</figcaption></figure><figure class="mr ms mt mu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nr"><img src="../Images/98885c151599bbdd680659631873cab9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nlpM8lz9EL3Rk_OlHcaePQ.jpeg"/></div></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">任务管理器中的进程:IO绑定任务的多重处理</figcaption></figure><figure class="mr ms mt mu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ns"><img src="../Images/5b5ba87bb5f36be627711f30426b83b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6U9lUA2TMhG1_W7FS3HKoA.jpeg"/></div></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">任务管理器的性能:IO绑定任务的多重处理</figcaption></figure></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><p id="4dca" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">嗯，那真是一段旅程。我们看到了六种不同的方法来执行一项任务，大约需要10秒钟，这取决于任务在CPU上是轻是重。</p><p id="01a8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">底线</strong>:IO绑定任务的多线程。CPU密集型任务的多重处理。</p></div></div>    
</body>
</html>