<html>
<head>
<title>Enumerability of JavaScript Objects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript对象的可枚举性</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/enumerability-of-javascript-objects-4388993f03d7?source=collection_archive---------17-----------------------#2020-04-28">https://levelup.gitconnected.com/enumerability-of-javascript-objects-4388993f03d7?source=collection_archive---------17-----------------------#2020-04-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/92af51f8213482cd3d72e8695d5f071a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Vdb74_AwVKt92Ey5"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@jakobowens1?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">雅各布·欧文</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="8163" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">JavaScript对象是动态的。可以动态地添加和删除这些属性，并且可以用描述它们如何工作的各种属性描述符来设置它们。</p><p id="84f7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将研究JavaScript对象属性的可枚举性，这是属性的描述符之一。</p><h1 id="a6a6" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">ES6中的可枚举性</h1><p id="91f0" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">可枚举性是对象属性的描述符。每个对象有零个或多个属性。每个属性都有一个键和另外3个属性。</p><p id="ba51" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">描述符存储关于属性的信息。所有属性都具有以下属性:</p><ul class=""><li id="bd38" class="mh mi it ki b kj kk kn ko kr mj kv mk kz ml ld mm mn mo mp bi translated"><code class="fe mq mr ms mt b">enumerable</code> —一个布尔属性，如果它被设置为<code class="fe mq mr ms mt b">false</code>，则在某些操作中隐藏该属性</li><li id="ce07" class="mh mi it ki b kj mu kn mv kr mw kv mx kz my ld mm mn mo mp bi translated"><code class="fe mq mr ms mt b">configurabvle</code> —将此项设置为<code class="fe mq mr ms mt b">false</code>可防止更改属性描述符。除了<code class="fe mq mr ms mt b">value</code>之外的描述符不能更改，属性不能删除。</li></ul><p id="8a0f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正常属性有以下描述符:</p><ul class=""><li id="6a91" class="mh mi it ki b kj kk kn ko kr mj kv mk kz ml ld mm mn mo mp bi translated"><code class="fe mq mr ms mt b">value</code> —房产的价值</li><li id="e0cf" class="mh mi it ki b kj mu kn mv kr mw kv mx kz my ld mm mn mo mp bi translated"><code class="fe mq mr ms mt b">writable</code> —控制该值是否可以更改。</li></ul><p id="aced" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">访问者具有以下属性:</p><ul class=""><li id="234f" class="mh mi it ki b kj kk kn ko kr mj kv mk kz ml ld mm mn mo mp bi translated"><code class="fe mq mr ms mt b">get</code> —保存一个getter，这是一个函数</li><li id="1cfb" class="mh mi it ki b kj mu kn mv kr mw kv mx kz my ld mm mn mo mp bi translated"><code class="fe mq mr ms mt b">set</code> —保存一个setter，这也是一个函数</li></ul><h1 id="161d" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">受可枚举性影响的构造</h1><p id="e3db" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">下面的代码受属性的可枚举性影响。<code class="fe mq mr ms mt b">for-in</code>循环只遍历可枚举的键。</p><p id="477b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mq mr ms mt b">Object.keys</code>返回可枚举且不从其“原型”继承的字符串键。</p><p id="9c60" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mq mr ms mt b">JSON.stringify</code> only stringifies仅可枚举带有字符串键的属性。</p><p id="18f4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mq mr ms mt b">Object.assign</code>只复制可枚举的自身属性。字符串和符号键都被复制。</p><h1 id="20e8" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">可枚举性的用例</h1><p id="d4d2" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">可枚举性不是一个非常有用的特性。它不会对所有操作隐藏属性。</p><p id="80aa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，它对于隐藏像<code class="fe mq mr ms mt b">for...in</code>循环这样的遗留代码仍然很有用。</p><p id="47ce" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，它还用于防止属性被<code class="fe mq mr ms mt b">jQuery</code>的<code class="fe mq mr ms mt b">extend</code>方法复制。<code class="fe mq mr ms mt b">extend</code>将继承的属性作为非继承的属性复制到返回的对象中，这很可能不是我们想要的。</p><p id="6028" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mq mr ms mt b">Object.assign</code>在合并或复制对象时也会忽略不可枚举的属性。这更有用，因为它不会混淆非继承属性和继承属性。</p><h1 id="fb63" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">将属性标记为私有</h1><p id="6a18" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">使用可枚举性描述符将属性标记为私有并不是很好。这是因为我们仍然可以以某种方式检索它们。像<code class="fe mq mr ms mt b">for...in</code>这样的操作会跳过不可枚举的属性，但是<code class="fe mq mr ms mt b">Object.getOwnPropertyNames</code>除了返回可枚举的键之外，还会返回不可枚举的键。</p><p id="b2c7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从外部代码中获取不可枚举的属性非常容易，所以不可枚举不会使属性私有。</p><h1 id="b0d0" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">对<code class="fe mq mr ms mt b">JSON.stringify()</code>隐藏自己的属性</h1><p id="dbc7" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mq mr ms mt b">JSON.stringify</code>跳过不可枚举的属性不被字符串化。然而，我们也可以给我们的对象添加一个<code class="fe mq mr ms mt b">toJSON</code>方法来指定我们应该如何字符串化我们的对象。</p><p id="6acf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="mz na nb nc gt nd mt ne nf aw ng bi"><span id="3655" class="nh lf it mt b gy ni nj l nk nl">const obj = {<br/>  foo: 1,<br/>  toJSON() {<br/>    return {<br/>      bar: 2<br/>    };<br/>  },<br/>};</span></pre><p id="ffed" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后当我们写下:</p><pre class="mz na nb nc gt nd mt ne nf aw ng bi"><span id="1635" class="nh lf it mt b gy ni nj l nk nl">JSON.stringify(obj)</span></pre><p id="a20f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它将返回<code class="fe mq mr ms mt b">{“bar”:2}</code>，这是我们在<code class="fe mq mr ms mt b">toJSON</code>中返回的。</p><figure class="mz na nb nc gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nm"><img src="../Images/198d1f323f00ce7b44da0754e5ef7302.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SB6T0cggsKghrcOe"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@garrettk9?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Garrett Karoski </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="c48a" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">命名不一致</h1><p id="3813" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">有些方法返回不可枚举的属性，有些不返回。例如，<code class="fe mq mr ms mt b">Object.keys</code>忽略不可枚举的属性。然而，<code class="fe mq mr ms mt b">Object.getOwnPropertyNames</code>列出了所有的属性名。</p><p id="b07d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mq mr ms mt b">Reflect.ownKeys</code>忽略可枚举性，返回所有属性的键。</p><h1 id="22f1" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="dc8a" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">可枚举性是一个d属性描述符，它指定一个属性如果是<code class="fe mq mr ms mt b">false</code>的话，可能会对某些操作隐藏。</p><p id="dcad" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它不适合隐藏属性，因为它很容易被一些方法访问。</p><p id="e01a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，最好不要处理属性的可枚举性，除非我们正在处理非常旧的代码。</p></div></div>    
</body>
</html>