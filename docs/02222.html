<html>
<head>
<title>Why it’s time to use the async-await in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么是时候在JavaScript中使用异步等待了</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/why-its-time-to-use-the-async-await-in-javascript-8cbe4c1f0ff4?source=collection_archive---------8-----------------------#2020-02-27">https://levelup.gitconnected.com/why-its-time-to-use-the-async-await-in-javascript-8cbe4c1f0ff4?source=collection_archive---------8-----------------------#2020-02-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/f6b9b1547d8f7cd12ecf1a85f4f870aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*skQfvUzrFkxgAETa"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@johnprice?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">约翰·普莱斯</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="3cfe" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">异步代码是JavaScript的常规部分。随着web应用变得越来越复杂，对异步代码的需求也会越来越多，因为JavaScript是单线程的，异步代码可以防止阻塞主线程。</p><p id="a8e7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将看看为什么<code class="fe le lf lg lh b">async</code>和<code class="fe le lf lg lh b">await</code>是编写异步代码的方法。</p><h1 id="fa43" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">编写Promise代码的老方法</h1><p id="81f8" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">在我们看<code class="fe le lf lg lh b">async</code>和<code class="fe le lf lg lh b">await</code>之前，我们必须看看它在过去是什么样子的。</p><p id="d92a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在过去，我们通过写下类似下面的东西来锁住承诺:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="4971" class="mt lj it lh b gy mu mv l mw mx">Promise.resolve(1)<br/>  .then(val =&gt; Promise.resolve(2))<br/>  .then(val =&gt; Promise.resolve(3))<br/>  .then(val =&gt; Promise.resolve(4))<br/>  .then(val =&gt; Promise.resolve(5))<br/>  .then(val =&gt; Promise.resolve(6))</span></pre><p id="3035" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我们所看到的，我们必须调用<code class="fe le lf lg lh b">then</code>很多次，在每个<code class="fe le lf lg lh b">then</code>调用中，我们必须传递一个回调函数来返回下一个承诺。这是一个痛苦，因为它非常冗长。如果我们想从每个承诺中收集解析的值，那么代码会变得更长。</p><p id="cca5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，要将解析的值收集到一个数组中，我们必须编写如下代码:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="779b" class="mt lj it lh b gy mu mv l mw mx">let vals = [];<br/>Promise.resolve(1)<br/>  .then(val =&gt; {<br/>    vals.push(val);<br/>    return Promise.resolve(2)<br/>  })<br/>  .then(val =&gt; {<br/>    vals.push(val);<br/>    return Promise.resolve(3)<br/>  })<br/>  .then(val =&gt; {<br/>    vals.push(val);<br/>    return Promise.resolve(4)<br/>  })<br/>  .then(val =&gt; {<br/>    vals.push(val);<br/>    return Promise.resolve(5)<br/>  })<br/>  .then(val =&gt; {<br/>    vals.push(val);<br/>    return Promise.resolve(6)<br/>  })<br/>  .then(val =&gt; {<br/>    vals.push(val);<br/>    console.log(vals)<br/>  });</span></pre><p id="3d1b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们得到<code class="fe le lf lg lh b">[1, 2, 3, 4, 5, 6]</code>作为<code class="fe le lf lg lh b">vals</code>的值。</p><p id="00b8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我们所看到的，与第一个例子相比，代码行数激增。</p><p id="d9f7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">文件中有很多重复的内容，会占用很多空间。</p><p id="56b1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了解决这个问题，是时候用<code class="fe le lf lg lh b">async-await</code>语法来链接承诺了。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi my"><img src="../Images/778b285c9cf1e8719e4ab89a4d9d79fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*aNOFiUc8kIEVMBPt"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上<a class="ae kf" href="https://unsplash.com/@berkaygumustekin?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Berkay Gumustekin </a>拍摄的照片</figcaption></figure><h1 id="3ed3" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">异步和等待</h1><p id="b851" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">为了清理上面例子中的代码，我们可以使用<code class="fe le lf lg lh b">async</code>和<code class="fe le lf lg lh b">await</code>来完成。</p><p id="bdaa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们用<code class="fe le lf lg lh b">async</code>开始一个函数声明，并在里面使用<code class="fe le lf lg lh b">await</code>关键字。<code class="fe le lf lg lh b">await</code>与<code class="fe le lf lg lh b">then</code>回调做同样的事情。它接受承诺的价值，并让我们用它做事情。</p><p id="6ec5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过<code class="fe le lf lg lh b">async</code>和<code class="fe le lf lg lh b">await</code>，我们可以转动:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="5da0" class="mt lj it lh b gy mu mv l mw mx">let vals = [];<br/>Promise.resolve(1)<br/>  .then(val =&gt; {<br/>    vals.push(val);<br/>    return Promise.resolve(2)<br/>  })<br/>  .then(val =&gt; {<br/>    vals.push(val);<br/>    return Promise.resolve(3)<br/>  })<br/>  .then(val =&gt; {<br/>    vals.push(val);<br/>    return Promise.resolve(4)<br/>  })<br/>  .then(val =&gt; {<br/>    vals.push(val);<br/>    return Promise.resolve(5)<br/>  })<br/>  .then(val =&gt; {<br/>    vals.push(val);<br/>    return Promise.resolve(6)<br/>  })<br/>  .then(val =&gt; {<br/>    vals.push(val);<br/>    console.log(vals)<br/>  });</span></pre><p id="83cc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">变成:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="d22a" class="mt lj it lh b gy mu mv l mw mx">(async () =&gt; {<br/>  const val = await Promise.resolve(1);<br/>  const val2 = await Promise.resolve(2);<br/>  const val3 = await Promise.resolve(3);<br/>  const val4 = await Promise.resolve(4);<br/>  const val5 = await Promise.resolve(5);<br/>  const val6 = await Promise.resolve(6);<br/>  const vals = [val, val2, val3, val4, val5, val6];<br/>  console.log(vals);<br/>})();</span></pre><p id="c5e7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面代码中的<code class="fe le lf lg lh b">await</code>表示它右边的代码返回一个承诺，它将等待这个承诺被实现，直到它移动到下一个。同样，解析的值可以用<code class="fe le lf lg lh b">=</code>和它左边的变量或常量来赋值。</p><p id="1a38" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这些值可以聚集到函数末尾的一个数组中，我们可以记录下来。</p><p id="8053" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">尽管这看起来像同步代码，<code class="fe le lf lg lh b">async</code>函数只能返回承诺，所以如果我们返回<code class="fe le lf lg lh b">vals</code>，我们将得到一个解析为<code class="fe le lf lg lh b">vals</code>值的承诺。</p><p id="8792" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这意味着:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="fafe" class="mt lj it lh b gy mu mv l mw mx">const getVals = () =&gt; {<br/>  let vals = [];<br/>  Promise.resolve(1)<br/>    .then(val =&gt; {<br/>      vals.push(val);<br/>      return Promise.resolve(2)<br/>    })<br/>    .then(val =&gt; {<br/>      vals.push(val);<br/>      return Promise.resolve(3)<br/>    })<br/>    .then(val =&gt; {<br/>      vals.push(val);<br/>      return Promise.resolve(4)<br/>    })<br/>    .then(val =&gt; {<br/>      vals.push(val);<br/>      return Promise.resolve(5)<br/>    })<br/>    .then(val =&gt; {<br/>      vals.push(val);<br/>      return Promise.resolve(6)<br/>    })<br/>    .then(val =&gt; {<br/>      vals.push(val);<br/>      return Promise.resolve(vals);<br/>    });<br/>}</span></pre><p id="e150" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">与以下内容相同:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="3a2d" class="mt lj it lh b gy mu mv l mw mx">const getValsAsyncAwait = async () =&gt; {<br/>  const val = await Promise.resolve(1);<br/>  const val2 = await Promise.resolve(2);<br/>  const val3 = await Promise.resolve(3);<br/>  const val4 = await Promise.resolve(4);<br/>  const val5 = await Promise.resolve(5);<br/>  const val6 = await Promise.resolve(6);<br/>  const vals = [val, val2, val3, val4, val5, val6];<br/>  return vals;<br/>};</span></pre><p id="f2e9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以在两者上使用<code class="fe le lf lg lh b">await</code>,看看我们会得到什么。</p><p id="9e79" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此区块:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="11d8" class="mt lj it lh b gy mu mv l mw mx">const getVals = () =&gt; {<br/>  let vals = [];<br/>  return Promise.resolve(1)<br/>    .then(val =&gt; {<br/>      vals.push(val);<br/>      return Promise.resolve(2)<br/>    })<br/>    .then(val =&gt; {<br/>      vals.push(val);<br/>      return Promise.resolve(3)<br/>    })<br/>    .then(val =&gt; {<br/>      vals.push(val);<br/>      return Promise.resolve(4)<br/>    })<br/>    .then(val =&gt; {<br/>      vals.push(val);<br/>      return Promise.resolve(5)<br/>    })<br/>    .then(val =&gt; {<br/>      vals.push(val);<br/>      return Promise.resolve(6)<br/>    })<br/>    .then(val =&gt; {<br/>      vals.push(val);<br/>      return Promise.resolve(vals);<br/>    });<br/>}</span><span id="ef7d" class="mt lj it lh b gy mz mv l mw mx">(async () =&gt; {<br/>  const values = await getVals();<br/>  console.log(values);<br/>})()</span></pre><p id="9b02" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从<code class="fe le lf lg lh b">console.log</code>中获取<code class="fe le lf lg lh b">[1, 2, 3, 4, 5, 6]</code>。</p><p id="0beb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">并且:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="b894" class="mt lj it lh b gy mu mv l mw mx">const getValsAsyncAwait = async () =&gt; {<br/>  const val = await Promise.resolve(1);<br/>  const val2 = await Promise.resolve(2);<br/>  const val3 = await Promise.resolve(3);<br/>  const val4 = await Promise.resolve(4);<br/>  const val5 = await Promise.resolve(5);<br/>  const val6 = await Promise.resolve(6);<br/>  const vals = [val, val2, val3, val4, val5, val6];<br/>  return vals;<br/>};</span><span id="9ee8" class="mt lj it lh b gy mz mv l mw mx">(async () =&gt; {<br/>  const values = await getValsAsyncAwait();<br/>  console.log(values);<br/>})()</span></pre><p id="f7d1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">也让我们从<code class="fe le lf lg lh b">console.log</code>中得到<code class="fe le lf lg lh b">[1, 2, 3, 4, 5, 6]</code>。所以它们做完全相同的事情，只是代码行少得多。</p><h1 id="57be" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">捕捉错误</h1><p id="60a8" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">在过去，我们用<code class="fe le lf lg lh b">catch</code>捕捉错误，回调传递给它。</p><p id="5076" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们写下这样的内容:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="d322" class="mt lj it lh b gy mu mv l mw mx">Promise.resolve(1)<br/>  .then(val =&gt; console.log(val))<br/>  .catch(err =&gt; console.log(err));</span></pre><p id="0d32" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们可以将<code class="fe le lf lg lh b">try...catch</code>与<code class="fe le lf lg lh b">async</code>和<code class="fe le lf lg lh b">await</code>一起使用:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="d129" class="mt lj it lh b gy mu mv l mw mx">(async () =&gt; {<br/>  try {<br/>    const val = await Promise.resolve(1);<br/>  } catch (err) {<br/>    console.log(err);<br/>  }<br/>})();</span></pre><p id="c2b1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这并没有节省多少空间，但在出现错误的情况下，这仍然可以派上用场。</p><p id="9c6e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我们所见，<code class="fe le lf lg lh b">async</code>和<code class="fe le lf lg lh b">await</code>使得链接承诺的代码变得更短。从2017年就有了，所以大部分现代浏览器都支持。现在绝对是使用它来清理代码的时候了。</p></div></div>    
</body>
</html>