<html>
<head>
<title>Clone Graph Blind 75 LeetCode Question</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">克隆图形盲75 LeetCode问题</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/clone-graph75-leetcode-questions-e7230ea6e017?source=collection_archive---------0-----------------------#2022-08-31">https://levelup.gitconnected.com/clone-graph75-leetcode-questions-e7230ea6e017?source=collection_archive---------0-----------------------#2022-08-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/233f7b7164048b52af92f795588847c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GSA2Ul0b176EDevw"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">托马斯·库亚尔在<a class="ae kc" href="https://unsplash.com/?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h2 id="4b19" class="kd ke iq bd kf kg kh dn ki kj kk dp kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">任务描述:</h2><p id="e900" class="pw-post-body-paragraph kz la iq lb b lc ld le lf lg lh li lj km lk ll lm kq ln lo lp ku lq lr ls lt ij bi translated">给定一个<a class="ae kc" href="https://en.wikipedia.org/wiki/Connectivity_(graph_theory)#Connected_graph" rel="noopener ugc nofollow" target="_blank"> <strong class="lb ir">连通的</strong> </a>无向图中一个节点的引用。</p><p id="a104" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">返回一个<a class="ae kc" href="https://en.wikipedia.org/wiki/Object_copying#Deep_copy" rel="noopener ugc nofollow" target="_blank"> <strong class="lb ir">深度复制</strong> </a>(克隆)的图形。</p><p id="b65b" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">图中的每个节点包含一个值(<code class="fe lz ma mb mc b">int</code>)和一个它的邻居列表(<code class="fe lz ma mb mc b">List[Node]</code>)。</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="aba9" class="kd ke iq mc b gy ml mm l mn mo">class Node {<br/>    public int val;<br/>    public List&lt;Node&gt; neighbors;<br/>}</span></pre><p id="e3ed" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated"><strong class="lb ir">测试用例格式:</strong></p><p id="43df" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">为简单起见，每个节点的值与节点的索引相同(索引为1)。例如，第一个节点带有<code class="fe lz ma mb mc b">val == 1</code>，第二个节点带有<code class="fe lz ma mb mc b">val == 2</code>，以此类推。该图在测试用例中使用邻接表来表示。</p><p id="da59" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated"><strong class="lb ir">邻接表</strong>是无序列表<strong class="lb ir">的集合</strong>用来表示一个有限图。每个列表描述了图中节点的一组邻居。</p><p id="e0df" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">给定的节点将总是带有<code class="fe lz ma mb mc b">val = 1</code>的第一个节点。您必须返回给定节点的<strong class="lb ir">副本，作为对克隆图的引用。</strong></p><p id="5a5b" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated"><strong class="lb ir">例1: </strong></p><figure class="md me mf mg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mp"><img src="../Images/c9d45f1417f760af0673be2b4f2dda18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*SIon8ryq29WTH13_.png"/></div></div></figure><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="4e61" class="kd ke iq mc b gy ml mm l mn mo"><strong class="mc ir">Input:</strong> adjList = [[2,4],[1,3],[2,4],[1,3]]<br/><strong class="mc ir">Output:</strong> [[2,4],[1,3],[2,4],[1,3]]<br/><strong class="mc ir">Explanation:</strong> There are 4 nodes in the graph.<br/>1st node (val = 1)'s neighbors are 2nd node (val = 2) and 4th node (val = 4).<br/>2nd node (val = 2)'s neighbors are 1st node (val = 1) and 3rd node (val = 3).<br/>3rd node (val = 3)'s neighbors are 2nd node (val = 2) and 4th node (val = 4).<br/>4th node (val = 4)'s neighbors are 1st node (val = 1) and 3rd node (val = 3).</span></pre><p id="1a06" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated"><strong class="lb ir">例2: </strong></p><figure class="md me mf mg gt jr gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/c449eacfbc2bad46c80532a3c3f0edc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:326/format:webp/0*7_Y6u0HJUVWiDsL_.png"/></div></figure><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="a9ef" class="kd ke iq mc b gy ml mm l mn mo"><strong class="mc ir">Input:</strong> adjList = [[]]<br/><strong class="mc ir">Output:</strong> [[]]<br/><strong class="mc ir">Explanation:</strong> Note that the input contains one empty list. The graph consists of only one node with val = 1 and it does not have any neighbors.</span></pre><p id="29c3" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated"><strong class="lb ir">例3: </strong></p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="4fc5" class="kd ke iq mc b gy ml mm l mn mo"><strong class="mc ir">Input:</strong> adjList = []<br/><strong class="mc ir">Output:</strong> []<br/><strong class="mc ir">Explanation:</strong> This an empty graph, it does not have any nodes.</span></pre><p id="a544" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated"><strong class="lb ir">约束:</strong></p><ul class=""><li id="9329" class="mr ms iq lb b lc lu lg lv km mt kq mu ku mv lt mw mx my mz bi translated">图中的节点数在范围<code class="fe lz ma mb mc b">[0, 100]</code>内。</li><li id="3b35" class="mr ms iq lb b lc na lg nb km nc kq nd ku ne lt mw mx my mz bi translated"><code class="fe lz ma mb mc b">1 &lt;= Node.val &lt;= 100</code></li><li id="ed7d" class="mr ms iq lb b lc na lg nb km nc kq nd ku ne lt mw mx my mz bi translated"><code class="fe lz ma mb mc b">Node.val</code>对每个节点都是唯一的。</li><li id="502e" class="mr ms iq lb b lc na lg nb km nc kq nd ku ne lt mw mx my mz bi translated">图中没有重复的边，也没有自循环。</li><li id="e807" class="mr ms iq lb b lc na lg nb km nc kq nd ku ne lt mw mx my mz bi translated">该图是连通的，并且可以从给定节点开始访问所有节点。</li></ul><h2 id="3f5e" class="kd ke iq bd kf kg kh dn ki kj kk dp kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">推理:</h2><p id="332e" class="pw-post-body-paragraph kz la iq lb b lc ld le lf lg lh li lj km lk ll lm kq ln lo lp ku lq lr ls lt ij bi translated">我们一如既往地关注问题，这可能看起来很有挑战性。正如我一直建议的，如果你感到卡住了或者不知道如何解决问题，从和自己交谈开始。所以我们有一个图表，我们需要克隆它，一个想法必须立即出现在你的脑海里。没有完整的遍历/探索，就没有办法复制一个完整的东西。很好。我们知道哪些遍历图/树的方法？修正BFS(面包优先搜索)或DFS(深度优先搜索)。我们选哪一个有关系吗？我不这么认为。我们刚刚迈出了解决问题的第一步。我们来看看简单的DFS。</p><figure class="md me mf mg gt jr"><div class="bz fp l di"><div class="nf ng l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">使用DFS和队列迭代方法遍历图的代码</figcaption></figure><p id="9736" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">现在我们有了探索给定图形的代码，但是我们不仅需要访问它们，还需要为图形中的每个节点创建一个副本。我故意不告诉你任何关于在我们要复制的节点之间创建链接的事情，我稍后会讲到，现在让我们把注意力放在创建副本上。我们需要一些数据结构来存储原始节点和它的副本之间的关系。同时，它应该支持2个功能，一个用于添加链接，第二个用于获取副本。它应该尽可能快地工作。有些人可能已经猜到了Java中的HashMap或者其他编程语言中的HashTable。我们只需要在函数中添加几行代码。</p><figure class="md me mf mg gt jr"><div class="bz fp l di"><div class="nf ng l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">更新了方法traverseGraph的逻辑</figcaption></figure><p id="f016" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">让我们来看看到目前为止我们都做了些什么。假设我们得到了这张图表</p><figure class="md me mf mg gt jr gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/48f0e2d963bbfacd06931e476001a075.png" data-original-src="https://miro.medium.com/v2/resize:fit:706/format:webp/1*jZCLjUjJ9KO6IlzcN9ZedQ.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">给定图形</figcaption></figure><p id="2fb7" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">然后在我们的原始复制图中，我们有这样的东西</p><figure class="md me mf mg gt jr gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/4506c854ae6cab8fe9dd5cb40c60711c.png" data-original-src="https://miro.medium.com/v2/resize:fit:726/format:webp/1*S4R_0aajJWZMOAS3kPBUhg.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">从原始图形复制节点</figcaption></figure><p id="3c3c" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">唯一剩下的。我们需要以某种方式连接克隆的节点，以便它们之间的连接与原始图形完全相同。我们如何做到这一点，我们可以利用原始复制地图吗？答案我们必须用它。在完成第一次遍历后，我们将进行第二次遍历，使用来自该图的数据，我们可以在克隆的节点之间复制/建立连接，以便它们重复原始节点。</p><figure class="md me mf mg gt jr"><div class="bz fp l di"><div class="nf ng l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">用于在节点之间遍历和创建链接的代码</figcaption></figure><p id="d394" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">在执行了traverseGraphAndCreateLinksBetweenNodes方法之后，我们应该会得到这个复制的图形</p><figure class="md me mf mg gt jr gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/672a0421dfe8f2559d2666d501f42f94.png" data-original-src="https://miro.medium.com/v2/resize:fit:664/format:webp/1*YWVUyams2zxNifLWhXecxw.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">带边的克隆图</figcaption></figure><h2 id="8742" class="kd ke iq bd kf kg kh dn ki kj kk dp kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">解决方案:</h2><p id="12f4" class="pw-post-body-paragraph kz la iq lb b lc ld le lf lg lh li lj km lk ll lm kq ln lo lp ku lq lr ls lt ij bi translated">我们用三个简单的步骤解决了给定的问题。这是完整的源代码</p><figure class="md me mf mg gt jr"><div class="bz fp l di"><div class="nf ng l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">解决办法</figcaption></figure><p id="0e77" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">我们可以在这里停下来，为另一个解决的问题而高兴。但是你们中的一些人可能已经注意到了，我们的代码中有一些重复的部分，我们可以去掉，让我们使用递归来使我们的代码更简洁。</p><figure class="md me mf mg gt jr"><div class="bz fp l di"><div class="nf ng l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">递归方法</figcaption></figure><p id="9be9" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">我希望本文能帮助您理解这个问题背后的逻辑，并使用它来解决其他任务。</p><p id="dc90" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">回头见！</p></div></div>    
</body>
</html>