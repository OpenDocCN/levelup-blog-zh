<html>
<head>
<title>How to Build an HTML Parser in C++</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用C++构建一个HTML解析器</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-build-an-html-parser-in-c-ec618bfd176c?source=collection_archive---------8-----------------------#2022-11-22">https://levelup.gitconnected.com/how-to-build-an-html-parser-in-c-ec618bfd176c?source=collection_archive---------8-----------------------#2022-11-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/1fce49c7a808e498f9e1fe51ff328bad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Pavpgx7cjJz2a5QX.png"/></div></div></figure><p id="d694" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="kz">最初发布于</em><a class="ae la" href="https://devtails.xyz/@adam/how-to-build-an-html-parser-in-c++" rel="noopener ugc nofollow" target="_blank"><em class="kz">https://devtails . XYZ</em></a><em class="kz">。</em></p></div><div class="ab cl lb lc hx ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="im in io ip iq"><h2 id="ea75" class="li lj it bd lk ll lm dn ln lo lp dp lq km lr ls lt kq lu lv lw ku lx ly lz ma bi translated">介绍</h2><p id="1ff2" class="pw-post-body-paragraph kb kc it kd b ke mb kg kh ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky im bi translated">我已经开始<a class="ae la" href="https://devtails.xyz/@adam/building-a-web-browser-with-sdl-in-c++" rel="noopener ugc nofollow" target="_blank">构建一个web浏览器</a>，并且最初用一个相对粗糙的正则表达式设置它来“解析”HTML。这不考虑嵌套结构，并且很可能有各种各样的其他问题。</p><p id="4c8e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">谷歌搜索“用c++构建html解析器”的结果只出现了一个教程，它一次只解释一行html。随着我对这个项目的深入，我可能会对我所拥有的进行一些修改，但目前下面的代码已经满足了我的基本需求。</p><h2 id="3448" class="li lj it bd lk ll lm dn ln lo lp dp lq km lr ls lt kq lu lv lw ku lx ly lz ma bi translated">最终产品</h2><p id="d41b" class="pw-post-body-paragraph kb kc it kd b ke mb kg kh ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky im bi translated">我发现一次看到所有东西有助于对所有东西是如何组合在一起的有一个大致的了解。接下来的部分将对其进行更深入的分析。</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="c338" class="li lj it ml b gy mp mq l mr ms">#include &lt;string&gt;<br/>#include &lt;vector&gt;<br/>#include &lt;cassert&gt;<br/><br/>using namespace std;<br/><br/>class HTMLElement<br/>{<br/>public:<br/>  string tagName;<br/>  vector&lt;struct HTMLElement *&gt; children;<br/>  struct HTMLElement *parentElement;<br/>  string textContent;<br/>};<br/><br/>enum State<br/>{<br/>  STATE_INIT,<br/>  STATE_START_TAG,<br/>  STATE_READING_TAG,<br/>  STATE_READING_ATTRIBUTES,<br/>  STATE_END_TAG,<br/>  STATE_BEGIN_CLOSING_TAG<br/>};<br/><br/>bool isWhitespace(char c)<br/>{<br/>  return c == ' ';<br/>}<br/><br/>HTMLElement *HTMLParser(string input)<br/>{<br/>  HTMLElement *root = new HTMLElement();<br/><br/>  State state = STATE_INIT;<br/>  HTMLElement *lastParent = root;<br/>  string tagName = "";<br/><br/>  for (auto c : input) {<br/>    if (c == '&lt;') {<br/>      state = STATE_START_TAG;<br/>    } else if (state == STATE_START_TAG) {<br/>      if (c == '/') {<br/>        state = STATE_BEGIN_CLOSING_TAG;<br/>      } else if (!isWhitespace(c)) {<br/>        state = STATE_READING_TAG;<br/>        tagName = c;<br/>      }<br/>    } else if (state == STATE_READING_TAG) {<br/>      if (isWhitespace(c)) {<br/>        state = STATE_READING_ATTRIBUTES;<br/>      } else if(c == '&gt;') {<br/>        state = STATE_END_TAG;<br/><br/>        auto parent = new HTMLElement(); <br/>        parent-&gt;tagName = tagName;<br/>        parent-&gt;parentElement = lastParent;<br/><br/>        lastParent-&gt;children.push_back(parent);<br/>        lastParent = parent;<br/>      } else {<br/>        tagName += c;<br/>      }<br/>    } else if(state == STATE_READING_ATTRIBUTES) {<br/>      if (c == '&gt;') {<br/>        state = STATE_END_TAG;<br/><br/>        auto parent = new HTMLElement(); <br/>        parent-&gt;tagName = tagName;<br/>        parent-&gt;parentElement = lastParent;<br/><br/>        lastParent-&gt;children.push_back(parent);<br/>        lastParent = parent;<br/>      }<br/>    } else if (state == STATE_END_TAG) {<br/>      lastParent-&gt;textContent += c;<br/>    } else if (state == STATE_BEGIN_CLOSING_TAG) {<br/>      if (c == '&gt;') {<br/>        lastParent = lastParent-&gt;parentElement;<br/>      }<br/>    }<br/>  }<br/><br/>  return root;<br/>}<br/><br/>int main()<br/>{<br/>  HTMLElement *el = HTMLParser("&lt;h1&gt;Hello World!&lt;/h1&gt;");<br/><br/>  assert(el-&gt;children.size() == 1);<br/><br/>  return 0;<br/>}</span></pre><h2 id="41bc" class="li lj it bd lk ll lm dn ln lo lp dp lq km lr ls lt kq lu lv lw ku lx ly lz ma bi translated">html元素</h2><p id="02d5" class="pw-post-body-paragraph kb kc it kd b ke mb kg kh ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky im bi translated">我遵循了<a class="ae la" href="https://www.w3schools.com/jsref/dom_obj_all.asp" rel="noopener ugc nofollow" target="_blank"> DOM元素</a>的属性命名约定。如果您习惯于在JavaScript中使用DOM，这应该会让您感觉很熟悉。这个过程还帮助我理解了这些属性是如何作用于DOM元素的。</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="8aa4" class="li lj it ml b gy mp mq l mr ms">class HTMLElement<br/>{<br/>public:<br/>  string tagName;<br/>  vector&lt;struct HTMLElement *&gt; children;<br/>  struct HTMLElement *parentElement;<br/>  string textContent;<br/>};</span></pre><h2 id="9572" class="li lj it bd lk ll lm dn ln lo lp dp lq km lr ls lt kq lu lv lw ku lx ly lz ma bi translated">状态机</h2><p id="edb3" class="pw-post-body-paragraph kb kc it kd b ke mb kg kh ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky im bi translated">就像我开始说的，我真的没有找到一个好的资源来工作，所以结束了我自己绘制的课程。对我来说，状态机是最简单的可视化和工作方式。我想一次一个字符地遍历html文本。状态机允许代码跟踪它在解析过程中的位置，并且(至少对我来说)更容易理解发生了什么。</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="12fc" class="li lj it ml b gy mp mq l mr ms">enum State<br/>{<br/>  STATE_INIT,<br/>  STATE_START_TAG,<br/>  STATE_READING_TAG,<br/>  STATE_READING_ATTRIBUTES,<br/>  STATE_END_TAG,<br/>  STATE_BEGIN_CLOSING_TAG<br/>};</span></pre><h2 id="50cb" class="li lj it bd lk ll lm dn ln lo lp dp lq km lr ls lt kq lu lv lw ku lx ly lz ma bi translated">状态初始化</h2><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="245f" class="li lj it ml b gy mp mq l mr ms">// Detects when a new html tag has begun (whenever "&lt;" is detected we enter this state)<br/>if (c == '&lt;') {<br/>  state = STATE_START_TAG;<br/>}</span></pre><h2 id="8a76" class="li lj it bd lk ll lm dn ln lo lp dp lq km lr ls lt kq lu lv lw ku lx ly lz ma bi translated">状态_开始_标签</h2><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="f1fc" class="li lj it ml b gy mp mq l mr ms">if (state == STATE_START_TAG) {<br/>  // Ignore any whitespace characters until we hit a real character<br/>  if (!isWhitespace(c)) {<br/>    state = STATE_READING_TAG;<br/>    tagName = c;<br/>  }<br/>}</span></pre><h2 id="a1e9" class="li lj it bd lk ll lm dn ln lo lp dp lq km lr ls lt kq lu lv lw ku lx ly lz ma bi translated">状态_阅读_标签</h2><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="13fa" class="li lj it ml b gy mp mq l mr ms">// Once we have detected the start of a tag, we proceed to read any characters that follow and this forms the `tagName` property<br/>if (state == STATE_READING_TAG) {<br/>  // Once we hit a whitespace character we transition to STATE_READING_ATTRIBUTES<br/>  if (isWhitespace(c)) {<br/>    state = STATE_READING_ATTRIBUTES;<br/>  }<br/>  // If we hit a &gt; this indicates that we're done reading the start of the tag, so we create a new HTMLElement with the tagName we read <br/>  else if(c == '&gt;') {<br/>    state = STATE_END_TAG;<br/><br/>    auto parent = new HTMLElement(); <br/>    parent-&gt;tagName = tagName;<br/>    parent-&gt;parentElement = lastParent;<br/><br/>    lastParent-&gt;children.push_back(parent);<br/>    lastParent = parent;<br/>  } else {<br/>    tagName += c;<br/>  }<br/>}</span></pre><h2 id="f437" class="li lj it bd lk ll lm dn ln lo lp dp lq km lr ls lt kq lu lv lw ku lx ly lz ma bi translated">状态_读数_属性</h2><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="200a" class="li lj it ml b gy mp mq l mr ms">// [TODO] I've avoided actually reading attributes for now<br/>if(state == STATE_READING_ATTRIBUTES) {<br/>  // For now, it is good enough to move to STATE_END_TAG once a "&gt;" is detected<br/>  if (c == '&gt;') {<br/>    state = STATE_END_TAG;<br/><br/>    auto parent = new HTMLElement(); <br/>    parent-&gt;tagName = tagName;<br/>    parent-&gt;parentElement = lastParent;<br/><br/>    lastParent-&gt;children.push_back(parent);<br/>    lastParent = parent;<br/>  }<br/>}</span></pre><h2 id="29c0" class="li lj it bd lk ll lm dn ln lo lp dp lq km lr ls lt kq lu lv lw ku lx ly lz ma bi translated">状态结束标签</h2><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="0509" class="li lj it ml b gy mp mq l mr ms">// This state will be exited when the next "&lt;" is detected and we return to STATE_START_TAG<br/>if (state == STATE_END_TAG) {<br/>  // Once in this state, we extract any characters into the `textContent` property<br/>  lastParent-&gt;textContent += c;<br/>}</span></pre><h2 id="1244" class="li lj it bd lk ll lm dn ln lo lp dp lq km lr ls lt kq lu lv lw ku lx ly lz ma bi translated">状态_开始_标签</h2><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="b949" class="li lj it ml b gy mp mq l mr ms">// At this point, the html is either closing out a tag or starting a new nested element<br/>if (state == STATE_START_TAG) {<br/>  // If it's closing one, the "/" character moves us to STATE_BEGIN_CLOSING_TAG<br/>  if (c == '/') {<br/>    state = STATE_BEGIN_CLOSING_TAG;<br/>  } <br/>  // If it's not a closing tag, the process begins and we start reading a new html element with the previous node as the `parentElement`<br/>  else if (!isWhitespace(c)) {<br/>    state = STATE_READING_TAG;<br/>    tagName = c;<br/>  }<br/>}</span></pre><h2 id="2131" class="li lj it bd lk ll lm dn ln lo lp dp lq km lr ls lt kq lu lv lw ku lx ly lz ma bi translated">状态_开始_结束_标记</h2><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="c5be" class="li lj it ml b gy mp mq l mr ms">if (state == STATE_BEGIN_CLOSING_TAG) {<br/>  // When a tag has been closed, we set the `lastParent` to its parent<br/>  if (c == '&gt;') {<br/>    // This ensures each sibling gets the correct `parentElement` attached<br/>    lastParent = lastParent-&gt;parentElement;<br/>  }<br/>}</span></pre><h2 id="d89b" class="li lj it bd lk ll lm dn ln lo lp dp lq km lr ls lt kq lu lv lw ku lx ly lz ma bi translated">结论</h2><p id="ae59" class="pw-post-body-paragraph kb kc it kd b ke mb kg kh ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky im bi translated">可能有几种情况下这不起作用。然而，使用这个起点，当问题出现时，确定需要添加什么来解决问题应该是相当容易的。</p><p id="d209" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我已经用这个替换了浏览器中的regex版本，到目前为止，它看起来像预期的那样工作。</p></div><div class="ab cl lb lc hx ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="im in io ip iq"><h1 id="780c" class="mt lj it bd lk mu mv mw ln mx my mz lq na nb nc lt nd ne nf lw ng nh ni lz nj bi translated">分级编码</h1><p id="8d6a" class="pw-post-body-paragraph kb kc it kd b ke mb kg kh ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky im bi translated">感谢您成为我们社区的一员！在你离开之前:</p><ul class=""><li id="ce06" class="nk nl it kd b ke kf ki kj km nm kq nn ku no ky np nq nr ns bi translated">👏为故事鼓掌，跟着作者走👉</li><li id="cef9" class="nk nl it kd b ke nt ki nu km nv kq nw ku nx ky np nq nr ns bi translated">📰查看<a class="ae la" href="https://levelup.gitconnected.com/?utm_source=pub&amp;utm_medium=post" rel="noopener ugc nofollow" target="_blank">升级编码出版物</a>中的更多内容</li><li id="574c" class="nk nl it kd b ke nt ki nu km nv kq nw ku nx ky np nq nr ns bi translated">🔔关注我们:<a class="ae la" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">Twitter</a>|<a class="ae la" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>|<a class="ae la" href="https://newsletter.levelup.dev" rel="noopener ugc nofollow" target="_blank">时事通讯</a></li></ul><p id="2f52" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">🚀👉<a class="ae la" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="kd iu">加入升级达人集体，找到一份惊艳的工作</strong> </a></p></div></div>    
</body>
</html>