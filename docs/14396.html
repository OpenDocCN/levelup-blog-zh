<html>
<head>
<title>How to Build an HTML Parser in C++</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">å¦‚ä½•ç”¨C++æ„å»ºä¸€ä¸ªHTMLè§£æå™¨</h1>
<blockquote>åŸæ–‡ï¼š<a href="https://levelup.gitconnected.com/how-to-build-an-html-parser-in-c-ec618bfd176c?source=collection_archive---------8-----------------------#2022-11-22">https://levelup.gitconnected.com/how-to-build-an-html-parser-in-c-ec618bfd176c?source=collection_archive---------8-----------------------#2022-11-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/1fce49c7a808e498f9e1fe51ff328bad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Pavpgx7cjJz2a5QX.png"/></div></div></figure><p id="d694" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="kz">æœ€åˆå‘å¸ƒäº</em><a class="ae la" href="https://devtails.xyz/@adam/how-to-build-an-html-parser-in-c++" rel="noopener ugc nofollow" target="_blank"><em class="kz">https://devtails . XYZ</em></a><em class="kz">ã€‚</em></p></div><div class="ab cl lb lc hx ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="im in io ip iq"><h2 id="ea75" class="li lj it bd lk ll lm dn ln lo lp dp lq km lr ls lt kq lu lv lw ku lx ly lz ma bi translated">ä»‹ç»</h2><p id="1ff2" class="pw-post-body-paragraph kb kc it kd b ke mb kg kh ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky im bi translated">æˆ‘å·²ç»å¼€å§‹<a class="ae la" href="https://devtails.xyz/@adam/building-a-web-browser-with-sdl-in-c++" rel="noopener ugc nofollow" target="_blank">æ„å»ºä¸€ä¸ªwebæµè§ˆå™¨</a>ï¼Œå¹¶ä¸”æœ€åˆç”¨ä¸€ä¸ªç›¸å¯¹ç²—ç³™çš„æ­£åˆ™è¡¨è¾¾å¼è®¾ç½®å®ƒæ¥â€œè§£æâ€HTMLã€‚è¿™ä¸è€ƒè™‘åµŒå¥—ç»“æ„ï¼Œå¹¶ä¸”å¾ˆå¯èƒ½æœ‰å„ç§å„æ ·çš„å…¶ä»–é—®é¢˜ã€‚</p><p id="4c8e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">è°·æ­Œæœç´¢â€œç”¨c++æ„å»ºhtmlè§£æå™¨â€çš„ç»“æœåªå‡ºç°äº†ä¸€ä¸ªæ•™ç¨‹ï¼Œå®ƒä¸€æ¬¡åªè§£é‡Šä¸€è¡Œhtmlã€‚éšç€æˆ‘å¯¹è¿™ä¸ªé¡¹ç›®çš„æ·±å…¥ï¼Œæˆ‘å¯èƒ½ä¼šå¯¹æˆ‘æ‰€æ‹¥æœ‰çš„è¿›è¡Œä¸€äº›ä¿®æ”¹ï¼Œä½†ç›®å‰ä¸‹é¢çš„ä»£ç å·²ç»æ»¡è¶³äº†æˆ‘çš„åŸºæœ¬éœ€æ±‚ã€‚</p><h2 id="3448" class="li lj it bd lk ll lm dn ln lo lp dp lq km lr ls lt kq lu lv lw ku lx ly lz ma bi translated">æœ€ç»ˆäº§å“</h2><p id="d41b" class="pw-post-body-paragraph kb kc it kd b ke mb kg kh ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky im bi translated">æˆ‘å‘ç°ä¸€æ¬¡çœ‹åˆ°æ‰€æœ‰ä¸œè¥¿æœ‰åŠ©äºå¯¹æ‰€æœ‰ä¸œè¥¿æ˜¯å¦‚ä½•ç»„åˆåœ¨ä¸€èµ·çš„æœ‰ä¸€ä¸ªå¤§è‡´çš„äº†è§£ã€‚æ¥ä¸‹æ¥çš„éƒ¨åˆ†å°†å¯¹å…¶è¿›è¡Œæ›´æ·±å…¥çš„åˆ†æã€‚</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="c338" class="li lj it ml b gy mp mq l mr ms">#include &lt;string&gt;<br/>#include &lt;vector&gt;<br/>#include &lt;cassert&gt;<br/><br/>using namespace std;<br/><br/>class HTMLElement<br/>{<br/>public:<br/>  string tagName;<br/>  vector&lt;struct HTMLElement *&gt; children;<br/>  struct HTMLElement *parentElement;<br/>  string textContent;<br/>};<br/><br/>enum State<br/>{<br/>  STATE_INIT,<br/>  STATE_START_TAG,<br/>  STATE_READING_TAG,<br/>  STATE_READING_ATTRIBUTES,<br/>  STATE_END_TAG,<br/>  STATE_BEGIN_CLOSING_TAG<br/>};<br/><br/>bool isWhitespace(char c)<br/>{<br/>  return c == ' ';<br/>}<br/><br/>HTMLElement *HTMLParser(string input)<br/>{<br/>  HTMLElement *root = new HTMLElement();<br/><br/>  State state = STATE_INIT;<br/>  HTMLElement *lastParent = root;<br/>  string tagName = "";<br/><br/>  for (auto c : input) {<br/>    if (c == '&lt;') {<br/>      state = STATE_START_TAG;<br/>    } else if (state == STATE_START_TAG) {<br/>      if (c == '/') {<br/>        state = STATE_BEGIN_CLOSING_TAG;<br/>      } else if (!isWhitespace(c)) {<br/>        state = STATE_READING_TAG;<br/>        tagName = c;<br/>      }<br/>    } else if (state == STATE_READING_TAG) {<br/>      if (isWhitespace(c)) {<br/>        state = STATE_READING_ATTRIBUTES;<br/>      } else if(c == '&gt;') {<br/>        state = STATE_END_TAG;<br/><br/>        auto parent = new HTMLElement(); <br/>        parent-&gt;tagName = tagName;<br/>        parent-&gt;parentElement = lastParent;<br/><br/>        lastParent-&gt;children.push_back(parent);<br/>        lastParent = parent;<br/>      } else {<br/>        tagName += c;<br/>      }<br/>    } else if(state == STATE_READING_ATTRIBUTES) {<br/>      if (c == '&gt;') {<br/>        state = STATE_END_TAG;<br/><br/>        auto parent = new HTMLElement(); <br/>        parent-&gt;tagName = tagName;<br/>        parent-&gt;parentElement = lastParent;<br/><br/>        lastParent-&gt;children.push_back(parent);<br/>        lastParent = parent;<br/>      }<br/>    } else if (state == STATE_END_TAG) {<br/>      lastParent-&gt;textContent += c;<br/>    } else if (state == STATE_BEGIN_CLOSING_TAG) {<br/>      if (c == '&gt;') {<br/>        lastParent = lastParent-&gt;parentElement;<br/>      }<br/>    }<br/>  }<br/><br/>  return root;<br/>}<br/><br/>int main()<br/>{<br/>  HTMLElement *el = HTMLParser("&lt;h1&gt;Hello World!&lt;/h1&gt;");<br/><br/>  assert(el-&gt;children.size() == 1);<br/><br/>  return 0;<br/>}</span></pre><h2 id="41bc" class="li lj it bd lk ll lm dn ln lo lp dp lq km lr ls lt kq lu lv lw ku lx ly lz ma bi translated">htmlå…ƒç´ </h2><p id="02d5" class="pw-post-body-paragraph kb kc it kd b ke mb kg kh ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky im bi translated">æˆ‘éµå¾ªäº†<a class="ae la" href="https://www.w3schools.com/jsref/dom_obj_all.asp" rel="noopener ugc nofollow" target="_blank"> DOMå…ƒç´ </a>çš„å±æ€§å‘½åçº¦å®šã€‚å¦‚æœæ‚¨ä¹ æƒ¯äºåœ¨JavaScriptä¸­ä½¿ç”¨DOMï¼Œè¿™åº”è¯¥ä¼šè®©æ‚¨æ„Ÿè§‰å¾ˆç†Ÿæ‚‰ã€‚è¿™ä¸ªè¿‡ç¨‹è¿˜å¸®åŠ©æˆ‘ç†è§£äº†è¿™äº›å±æ€§æ˜¯å¦‚ä½•ä½œç”¨äºDOMå…ƒç´ çš„ã€‚</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="8aa4" class="li lj it ml b gy mp mq l mr ms">class HTMLElement<br/>{<br/>public:<br/>  string tagName;<br/>  vector&lt;struct HTMLElement *&gt; children;<br/>  struct HTMLElement *parentElement;<br/>  string textContent;<br/>};</span></pre><h2 id="9572" class="li lj it bd lk ll lm dn ln lo lp dp lq km lr ls lt kq lu lv lw ku lx ly lz ma bi translated">çŠ¶æ€æœº</h2><p id="edb3" class="pw-post-body-paragraph kb kc it kd b ke mb kg kh ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky im bi translated">å°±åƒæˆ‘å¼€å§‹è¯´çš„ï¼Œæˆ‘çœŸçš„æ²¡æœ‰æ‰¾åˆ°ä¸€ä¸ªå¥½çš„èµ„æºæ¥å·¥ä½œï¼Œæ‰€ä»¥ç»“æŸäº†æˆ‘è‡ªå·±ç»˜åˆ¶çš„è¯¾ç¨‹ã€‚å¯¹æˆ‘æ¥è¯´ï¼ŒçŠ¶æ€æœºæ˜¯æœ€ç®€å•çš„å¯è§†åŒ–å’Œå·¥ä½œæ–¹å¼ã€‚æˆ‘æƒ³ä¸€æ¬¡ä¸€ä¸ªå­—ç¬¦åœ°éå†htmlæ–‡æœ¬ã€‚çŠ¶æ€æœºå…è®¸ä»£ç è·Ÿè¸ªå®ƒåœ¨è§£æè¿‡ç¨‹ä¸­çš„ä½ç½®ï¼Œå¹¶ä¸”(è‡³å°‘å¯¹æˆ‘æ¥è¯´)æ›´å®¹æ˜“ç†è§£å‘ç”Ÿäº†ä»€ä¹ˆã€‚</p><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="12fc" class="li lj it ml b gy mp mq l mr ms">enum State<br/>{<br/>  STATE_INIT,<br/>  STATE_START_TAG,<br/>  STATE_READING_TAG,<br/>  STATE_READING_ATTRIBUTES,<br/>  STATE_END_TAG,<br/>  STATE_BEGIN_CLOSING_TAG<br/>};</span></pre><h2 id="50cb" class="li lj it bd lk ll lm dn ln lo lp dp lq km lr ls lt kq lu lv lw ku lx ly lz ma bi translated">çŠ¶æ€åˆå§‹åŒ–</h2><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="245f" class="li lj it ml b gy mp mq l mr ms">// Detects when a new html tag has begun (whenever "&lt;" is detected we enter this state)<br/>if (c == '&lt;') {<br/>  state = STATE_START_TAG;<br/>}</span></pre><h2 id="8a76" class="li lj it bd lk ll lm dn ln lo lp dp lq km lr ls lt kq lu lv lw ku lx ly lz ma bi translated">çŠ¶æ€_å¼€å§‹_æ ‡ç­¾</h2><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="f1fc" class="li lj it ml b gy mp mq l mr ms">if (state == STATE_START_TAG) {<br/>  // Ignore any whitespace characters until we hit a real character<br/>  if (!isWhitespace(c)) {<br/>    state = STATE_READING_TAG;<br/>    tagName = c;<br/>  }<br/>}</span></pre><h2 id="a1e9" class="li lj it bd lk ll lm dn ln lo lp dp lq km lr ls lt kq lu lv lw ku lx ly lz ma bi translated">çŠ¶æ€_é˜…è¯»_æ ‡ç­¾</h2><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="13fa" class="li lj it ml b gy mp mq l mr ms">// Once we have detected the start of a tag, we proceed to read any characters that follow and this forms the `tagName` property<br/>if (state == STATE_READING_TAG) {<br/>  // Once we hit a whitespace character we transition to STATE_READING_ATTRIBUTES<br/>  if (isWhitespace(c)) {<br/>    state = STATE_READING_ATTRIBUTES;<br/>  }<br/>  // If we hit a &gt; this indicates that we're done reading the start of the tag, so we create a new HTMLElement with the tagName we read <br/>  else if(c == '&gt;') {<br/>    state = STATE_END_TAG;<br/><br/>    auto parent = new HTMLElement(); <br/>    parent-&gt;tagName = tagName;<br/>    parent-&gt;parentElement = lastParent;<br/><br/>    lastParent-&gt;children.push_back(parent);<br/>    lastParent = parent;<br/>  } else {<br/>    tagName += c;<br/>  }<br/>}</span></pre><h2 id="f437" class="li lj it bd lk ll lm dn ln lo lp dp lq km lr ls lt kq lu lv lw ku lx ly lz ma bi translated">çŠ¶æ€_è¯»æ•°_å±æ€§</h2><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="200a" class="li lj it ml b gy mp mq l mr ms">// [TODO] I've avoided actually reading attributes for now<br/>if(state == STATE_READING_ATTRIBUTES) {<br/>  // For now, it is good enough to move to STATE_END_TAG once a "&gt;" is detected<br/>  if (c == '&gt;') {<br/>    state = STATE_END_TAG;<br/><br/>    auto parent = new HTMLElement(); <br/>    parent-&gt;tagName = tagName;<br/>    parent-&gt;parentElement = lastParent;<br/><br/>    lastParent-&gt;children.push_back(parent);<br/>    lastParent = parent;<br/>  }<br/>}</span></pre><h2 id="29c0" class="li lj it bd lk ll lm dn ln lo lp dp lq km lr ls lt kq lu lv lw ku lx ly lz ma bi translated">çŠ¶æ€ç»“æŸæ ‡ç­¾</h2><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="0509" class="li lj it ml b gy mp mq l mr ms">// This state will be exited when the next "&lt;" is detected and we return to STATE_START_TAG<br/>if (state == STATE_END_TAG) {<br/>  // Once in this state, we extract any characters into the `textContent` property<br/>  lastParent-&gt;textContent += c;<br/>}</span></pre><h2 id="1244" class="li lj it bd lk ll lm dn ln lo lp dp lq km lr ls lt kq lu lv lw ku lx ly lz ma bi translated">çŠ¶æ€_å¼€å§‹_æ ‡ç­¾</h2><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="b949" class="li lj it ml b gy mp mq l mr ms">// At this point, the html is either closing out a tag or starting a new nested element<br/>if (state == STATE_START_TAG) {<br/>  // If it's closing one, the "/" character moves us to STATE_BEGIN_CLOSING_TAG<br/>  if (c == '/') {<br/>    state = STATE_BEGIN_CLOSING_TAG;<br/>  } <br/>  // If it's not a closing tag, the process begins and we start reading a new html element with the previous node as the `parentElement`<br/>  else if (!isWhitespace(c)) {<br/>    state = STATE_READING_TAG;<br/>    tagName = c;<br/>  }<br/>}</span></pre><h2 id="2131" class="li lj it bd lk ll lm dn ln lo lp dp lq km lr ls lt kq lu lv lw ku lx ly lz ma bi translated">çŠ¶æ€_å¼€å§‹_ç»“æŸ_æ ‡è®°</h2><pre class="mg mh mi mj gt mk ml mm mn aw mo bi"><span id="c5be" class="li lj it ml b gy mp mq l mr ms">if (state == STATE_BEGIN_CLOSING_TAG) {<br/>  // When a tag has been closed, we set the `lastParent` to its parent<br/>  if (c == '&gt;') {<br/>    // This ensures each sibling gets the correct `parentElement` attached<br/>    lastParent = lastParent-&gt;parentElement;<br/>  }<br/>}</span></pre><h2 id="d89b" class="li lj it bd lk ll lm dn ln lo lp dp lq km lr ls lt kq lu lv lw ku lx ly lz ma bi translated">ç»“è®º</h2><p id="ae59" class="pw-post-body-paragraph kb kc it kd b ke mb kg kh ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky im bi translated">å¯èƒ½æœ‰å‡ ç§æƒ…å†µä¸‹è¿™ä¸èµ·ä½œç”¨ã€‚ç„¶è€Œï¼Œä½¿ç”¨è¿™ä¸ªèµ·ç‚¹ï¼Œå½“é—®é¢˜å‡ºç°æ—¶ï¼Œç¡®å®šéœ€è¦æ·»åŠ ä»€ä¹ˆæ¥è§£å†³é—®é¢˜åº”è¯¥æ˜¯ç›¸å½“å®¹æ˜“çš„ã€‚</p><p id="d209" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">æˆ‘å·²ç»ç”¨è¿™ä¸ªæ›¿æ¢äº†æµè§ˆå™¨ä¸­çš„regexç‰ˆæœ¬ï¼Œåˆ°ç›®å‰ä¸ºæ­¢ï¼Œå®ƒçœ‹èµ·æ¥åƒé¢„æœŸçš„é‚£æ ·å·¥ä½œã€‚</p></div><div class="ab cl lb lc hx ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="im in io ip iq"><h1 id="780c" class="mt lj it bd lk mu mv mw ln mx my mz lq na nb nc lt nd ne nf lw ng nh ni lz nj bi translated">åˆ†çº§ç¼–ç </h1><p id="8d6a" class="pw-post-body-paragraph kb kc it kd b ke mb kg kh ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky im bi translated">æ„Ÿè°¢æ‚¨æˆä¸ºæˆ‘ä»¬ç¤¾åŒºçš„ä¸€å‘˜ï¼åœ¨ä½ ç¦»å¼€ä¹‹å‰:</p><ul class=""><li id="ce06" class="nk nl it kd b ke kf ki kj km nm kq nn ku no ky np nq nr ns bi translated">ğŸ‘ä¸ºæ•…äº‹é¼“æŒï¼Œè·Ÿç€ä½œè€…èµ°ğŸ‘‰</li><li id="cef9" class="nk nl it kd b ke nt ki nu km nv kq nw ku nx ky np nq nr ns bi translated">ğŸ“°æŸ¥çœ‹<a class="ae la" href="https://levelup.gitconnected.com/?utm_source=pub&amp;utm_medium=post" rel="noopener ugc nofollow" target="_blank">å‡çº§ç¼–ç å‡ºç‰ˆç‰©</a>ä¸­çš„æ›´å¤šå†…å®¹</li><li id="574c" class="nk nl it kd b ke nt ki nu km nv kq nw ku nx ky np nq nr ns bi translated">ğŸ””å…³æ³¨æˆ‘ä»¬:<a class="ae la" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">Twitter</a>|<a class="ae la" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>|<a class="ae la" href="https://newsletter.levelup.dev" rel="noopener ugc nofollow" target="_blank">æ—¶äº‹é€šè®¯</a></li></ul><p id="2f52" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">ğŸš€ğŸ‘‰<a class="ae la" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="kd iu">åŠ å…¥å‡çº§è¾¾äººé›†ä½“ï¼Œæ‰¾åˆ°ä¸€ä»½æƒŠè‰³çš„å·¥ä½œ</strong> </a></p></div></div>    
</body>
</html>