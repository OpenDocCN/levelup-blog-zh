<html>
<head>
<title>Secure Your Data in Under 5 Minutes with AES128-bit Encryption in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python中的AES128位加密，在5分钟内保护您的数据</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/coding-aes128-bit-encryption-in-python-in-less-than-5-minutes-f6bcbddd2b82?source=collection_archive---------2-----------------------#2020-08-27">https://levelup.gitconnected.com/coding-aes128-bit-encryption-in-python-in-less-than-5-minutes-f6bcbddd2b82?source=collection_archive---------2-----------------------#2020-08-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="beae" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用Fernet密码快速实现对称密钥加密，在Python的密码库中。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/fb299735c6d33d683ab36e2dd726ad88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WHecU3F9WcYslRgd"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">这就是你忘记关方向锁的后果。马库斯·斯皮斯克在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="48ac" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">对称密钥加密</strong>是最简单的消息加密形式之一，发送方和接收方使用完全相同的密钥进行加密和解密。想要读取密文的各方都可以安全地共享密钥，他们通过将密文加载到用于编码密文的算法中来解密密文。这里，我们将使用AES128位<a class="ae le" href="https://cryptography.io/en/latest/fernet/#" rel="noopener ugc nofollow" target="_blank"> Fernet </a>密码和Python的<a class="ae le" href="https://cryptography.io/en/latest/installation/" rel="noopener ugc nofollow" target="_blank">密码术</a>库。</p><blockquote class="lf lg lh"><p id="3a2e" class="jq jr li js b jt ju jv jw jx jy jz ka lj kc kd ke lk kg kh ki ll kk kl km kn im bi translated">密码学中的“密钥”或“秘密”只是由密码方法(加密算法)生成的一串字节，一端用于加密消息，另一端用于解密消息。想象一下，例如:“我将把这个消息中的每个字母移动一位，移动到字母表中的下一个字母，所以当你得到这个密文时，将每个字母移动一位，移动到前一个字母，以显示我原始的、编码的消息。”</p><p id="e90b" class="jq jr li js b jt ju jv jw jx jy jz ka lj kc kd ke lk kg kh ki ll kk kl km kn im bi translated">试着用我刚才描述的密钥破译这个秘密消息:Dbo zpv sfbe uijt？Cf tvsf up esjol zprs pwbmujof。</p></blockquote><p id="53a6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，计算机生成的密钥文件内部通常是这样的:</p><p id="bb7b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lm ln lo lp b">s_g6nE4J-nKktINfrO2b8qyX1H7cpfsqyMnxrWoVSQU=</code></p><p id="9728" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">只要你和另一个人有相同的字节串，你就能把一条信息加密成一串难以辨认的字母和数字，没有密钥，没有人能破译你写的东西，或者至少有一些量子计算能力供他们使用。</p><p id="4fea" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">与<strong class="js iu">不对称加密</strong>不同，在不对称加密中，每个人都有自己唯一的私钥和公开共享的公钥，对称加密简单、直接且易于管理，适用于基本项目和各种加密需求。棘手的部分是安全地共享密钥而不暴露给史努比探听者。</p><p id="c865" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你刚刚开始，想快速、轻松地掌握一些质量不错的小消息加密技术，请继续阅读。</p><h1 id="ec89" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">第一部分。在加密库中进行设置</h1><p id="43d0" class="pw-post-body-paragraph jq jr it js b jt mo jv jw jx mp jz ka kb mq kd ke kf mr kh ki kj ms kl km kn im bi translated"><strong class="js iu">第一步:</strong>安装密码术。详细说明请点击<a class="ae le" href="https://cryptography.io/en/latest/installation/" rel="noopener ugc nofollow" target="_blank">这里</a>。否则，只需从命令行开始:</p><pre class="kp kq kr ks gt mt lp mu mv aw mw bi"><span id="1d58" class="mx lr it lp b gy my mz l na nb">pip install cryptography # or pip3</span></pre><p id="50ba" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">第二步:</strong>将你的库放在顶部，导入到一个新的python文件中。建议:不想想名字就叫<em class="li"> fernet_encryption.py </em>好了。</p><pre class="kp kq kr ks gt mt lp mu mv aw mw bi"><span id="4eee" class="mx lr it lp b gy my mz l na nb"># Import the Fernet class. <br/>from cryptography.fernet import Fernet</span></pre><h1 id="8df6" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">第2部分:加密秘密消息</h1><p id="dc3b" class="pw-post-body-paragraph jq jr it js b jt mo jv jw jx mp jz ka kb mq kd ke kf mr kh ki kj ms kl km kn im bi translated">现在，要产生一个秘密信息，我们需要一些东西。</p><ol class=""><li id="fd91" class="nc nd it js b jt ju jx jy kb ne kf nf kj ng kn nh ni nj nk bi translated">生成一个新密钥。</li><li id="9e09" class="nc nd it js b jt nl jx nm kb nn kf no kj np kn nh ni nj nk bi translated">创建要编码的消息。</li><li id="7668" class="nc nd it js b jt nl jx nm kb nn kf no kj np kn nh ni nj nk bi translated">用密钥加密消息，并将其存储为密文变量。</li><li id="cd62" class="nc nd it js b jt nl jx nm kb nn kf no kj np kn nh ni nj nk bi translated">将该消息传递给接收者。</li></ol><h2 id="2a7f" class="mx lr it bd ls nq nr dn lw ns nt dp ma kb nu nv me kf nw nx mi kj ny nz mm oa bi translated">1.生成密钥:</h2><p id="299c" class="pw-post-body-paragraph jq jr it js b jt mo jv jw jx mp jz ka kb mq kd ke kf mr kh ki kj ms kl km kn im bi translated">首先，我们将生成密钥，然后将它写入一个. key文件。我们现在将使用python文件所在的文件夹，但是您可以选择任何路径。</p><pre class="kp kq kr ks gt mt lp mu mv aw mw bi"><span id="025b" class="mx lr it lp b gy my mz l na nb"># Use Fernet to generate the key file.<br/>key = Fernet.generate_key() </span><span id="3a83" class="mx lr it lp b gy ob mz l na nb"># Store the file to disk to be accessed for en/de:crypting later.<br/>with open('secret.key', 'wb') as new_key_file:<br/>    new_key_file.write(key)</span><span id="2de8" class="mx lr it lp b gy ob mz l na nb">print(key)</span><span id="673f" class="mx lr it lp b gy ob mz l na nb">&gt;&gt;&gt; b'G5mX1vlxKVaQkdg3CfhH6pVQIctECVw3MN6uCXbJpGo='</span></pre><blockquote class="lf lg lh"><p id="1c0c" class="jq jr li js b jt ju jv jw jx jy jz ka lj kc kd ke lk kg kh ki ll kk kl km kn im bi translated"><strong class="js iu">编码类型:</strong>消息前面的‘b’表示它被存储为字节。编码类型是存储相同数据的不同方式。在这里，这是一个“UTF-8”类型的编码，这些是用来编码的字符。这是一个更高级的主题，如果您对密码学非常深入，您将需要在不同的类型之间来回转换，如“base64”或“hex ”,但对于本简介，甚至不用担心它。当你看到b的时候，只要想“那不是字符串，那是字节！”</p><p id="1e5a" class="jq jr li js b jt ju jv jw jx jy jz ka lj kc kd ke lk kg kh ki ll kk kl km kn im bi translated">Python为我们提供了一种非常简单的方法，用。encode()和。decode()函数。如果您开始得到有趣的错误，确保您的字符串在需要时被编码(string.encode())，您的字节字符串消息在需要时被解码(bytes_msg.decode())。</p></blockquote><h2 id="6c2d" class="mx lr it bd ls nq nr dn lw ns nt dp ma kb nu nv me kf nw nx mi kj ny nz mm oa bi translated"><strong class="ak"> 2。创建要编码的消息:</strong></h2><p id="3a75" class="pw-post-body-paragraph jq jr it js b jt mo jv jw jx mp jz ka kb mq kd ke kf mr kh ki kj ms kl km kn im bi translated">这是你的加密“hello world ”,所以随便选吧，没关系。我用的是这个:</p><pre class="kp kq kr ks gt mt lp mu mv aw mw bi"><span id="3593" class="mx lr it lp b gy my mz l na nb">msg = "Into the valley of death, rode the 600."</span><span id="54e4" class="mx lr it lp b gy ob mz l na nb"># Encode this as bytes to feed into the algorithm.<br/># (Refer to <strong class="lp iu">Encoding types</strong> above).</span><span id="0ce3" class="mx lr it lp b gy ob mz l na nb">msg = msg.encode()</span></pre><h2 id="890b" class="mx lr it bd ls nq nr dn lw ns nt dp ma kb nu nv me kf nw nx mi kj ny nz mm oa bi translated">3.加密邮件:</h2><p id="41ed" class="pw-post-body-paragraph jq jr it js b jt mo jv jw jx mp jz ka kb mq kd ke kf mr kh ki kj ms kl km kn im bi translated">使用刚刚创建的键，将一个<code class="fe lm ln lo lp b">Fernet()</code>对象实例化为<code class="fe lm ln lo lp b">f</code>。这告诉算法使用该密钥进行加密和解密。然后，把你的信息传进去，并作为加密信息储存起来<code class="fe lm ln lo lp b">ciphertext.</code></p><pre class="kp kq kr ks gt mt lp mu mv aw mw bi"><span id="1832" class="mx lr it lp b gy my mz l na nb"># Instantiate the object with your key.<br/>f = Fernet(key)</span><span id="78e2" class="mx lr it lp b gy ob mz l na nb"># Pass your bytes type message into encrypt.<br/>ciphertext = f.encrypt(msg)</span><span id="f88d" class="mx lr it lp b gy ob mz l na nb">print(ciphertext)</span></pre><p id="8612" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您应该会看到类似这样的内容:</p><pre class="kp kq kr ks gt mt lp mu mv aw mw bi"><span id="cfa3" class="mx lr it lp b gy my mz l na nb">b'gAAAAABfRyALC7N-3gxMZsGYMjZMZIegYgBca2ZNzjtyS--TNYCqBP10YsZTQnzOMlrLuuSUALkq9GnNb5BBZeHwuztqM7ir_Yh9hoXwsQH6ywbW7ehbgUIUNtmasBuj63vHD-EHNo9U'</span></pre><p id="4d35" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">女士们，先生们，这就是你们的密文。这是我的。你的会看起来不一样。为什么？因为它是通过将您的消息字符串转换成字节，输入到Fernet对象的<code class="fe lm ln lo lp b">encrypt</code>方法中而创建的消息，该方法是用您的私钥创建的。你是怎么读的？你猜对了——费尔内的<code class="fe lm ln lo lp b">decrypt</code>法。</p><h1 id="098b" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated"><strong class="ak">第三部分。解密接收的消息。</strong></h1><p id="6cda" class="pw-post-body-paragraph jq jr it js b jt mo jv jw jx mp jz ka kb mq kd ke kf mr kh ki kj ms kl km kn im bi translated">让我们假设您不在创建消息的同一个运行时上。因此，我们要加载密钥。如果密钥与python文件在同一个文件夹中，下面的代码会将密钥存储为一个变量，并使用它来解密新消息。该密钥必须与用于生成密文的密钥相同。</p><h2 id="bdcb" class="mx lr it bd ls nq nr dn lw ns nt dp ma kb nu nv me kf nw nx mi kj ny nz mm oa bi translated">收件人的文件:</h2><pre class="kp kq kr ks gt mt lp mu mv aw mw bi"><span id="818e" class="mx lr it lp b gy my mz l na nb">from cryptography.fernet import Fernet</span><span id="c3a5" class="mx lr it lp b gy ob mz l na nb"># Load the private key from a file.<br/>with open('secret.key', 'rb') as my_private_key:<br/>    key = my_private_key.read()</span><span id="1b2a" class="mx lr it lp b gy ob mz l na nb"># Instantiate Fernet on the recip system.<br/>f = Fernet(key)</span><span id="96e7" class="mx lr it lp b gy ob mz l na nb"># Decrypt the message.<br/>cleartext = f.decrypt(ciphertext)</span><span id="7118" class="mx lr it lp b gy ob mz l na nb"># Decode the bytes back into a string.<br/>cleartext = cleartext.decode()</span><span id="9c5b" class="mx lr it lp b gy ob mz l na nb">print(cleartext)<br/>&gt;&gt;&gt; Into the valley of death, rode the 600.</span></pre><p id="6b67" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">事实上就是这样。现在，您可以发送和接收使用AES128加密技术加密的消息，128位加密技术非常可靠:</p><blockquote class="oc"><p id="51ec" class="od oe it bd of og oh oi oj ok ol kn dk translated">“2017年……世界上最强大的计算机仍然需要大约885万亿年来暴力破解128位AES密钥。”—<a class="ae le" href="https://proprivacy.com/guides/aes-encryption" rel="noopener ugc nofollow" target="_blank">proprivacy.com</a></p></blockquote><p id="b959" class="pw-post-body-paragraph jq jr it js b jt om jv jw jx on jz ka kb oo kd ke kf op kh ki kj oq kl km kn im bi translated">具体来说，来自Fernet <a class="ae le" href="https://cryptography.io/en/latest/fernet/#implementation" rel="noopener ugc nofollow" target="_blank">文档</a>:</p><blockquote class="lf lg lh"><p id="8333" class="jq jr li js b jt ju jv jw jx jy jz ka lj kc kd ke lk kg kh ki ll kk kl km kn im bi translated">Fernet建立在许多标准加密原语的基础上。具体来说，它使用:</p><p id="8813" class="jq jr li js b jt ju jv jw jx jy jz ka lj kc kd ke lk kg kh ki ll kk kl km kn im bi translated"><code class="fe lm ln lo lp b"><a class="ae le" href="https://cryptography.io/en/latest/hazmat/primitives/symmetric-encryption/#cryptography.hazmat.primitives.ciphers.algorithms.AES" rel="noopener ugc nofollow" target="_blank">AES</a></code>在<code class="fe lm ln lo lp b"><a class="ae le" href="https://cryptography.io/en/latest/hazmat/primitives/symmetric-encryption/#cryptography.hazmat.primitives.ciphers.modes.CBC" rel="noopener ugc nofollow" target="_blank">CBC</a></code>模式下用128位密钥进行加密；使用<code class="fe lm ln lo lp b"><a class="ae le" href="https://cryptography.io/en/latest/hazmat/primitives/padding/#cryptography.hazmat.primitives.padding.PKCS7" rel="noopener ugc nofollow" target="_blank">PKCS7</a></code>填充。</p><p id="b604" class="jq jr li js b jt ju jv jw jx jy jz ka lj kc kd ke lk kg kh ki ll kk kl km kn im bi translated"><code class="fe lm ln lo lp b"><a class="ae le" href="https://cryptography.io/en/latest/hazmat/primitives/mac/hmac/#cryptography.hazmat.primitives.hmac.HMAC" rel="noopener ugc nofollow" target="_blank">HMAC</a></code>使用<code class="fe lm ln lo lp b"><a class="ae le" href="https://cryptography.io/en/latest/hazmat/primitives/cryptographic-hashes/#cryptography.hazmat.primitives.hashes.SHA256" rel="noopener ugc nofollow" target="_blank">SHA256</a></code>进行认证。</p><p id="d862" class="jq jr li js b jt ju jv jw jx jy jz ka lj kc kd ke lk kg kh ki ll kk kl km kn im bi translated">使用<code class="fe lm ln lo lp b">os.urandom()</code>生成初始化向量。</p></blockquote><p id="3409" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你想隐藏核秘密，咨询安全专家。但是，如果你只是想保持对所有明文数据的窥探，这是一个非常可靠、超级简单的选择。</p><h1 id="e778" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">潜得更深</h1><p id="3631" class="pw-post-body-paragraph jq jr it js b jt mo jv jw jx mp jz ka kb mq kd ke kf mr kh ki kj ms kl km kn im bi translated">为了进一步阅读，如果你想了解一些关于加密n00bs的好建议，请从<a class="ae le" href="https://latacora.singles/2018/04/03/cryptographic-right-answers.html" rel="noopener ugc nofollow" target="_blank"> Latacora的加密权利答案</a>开始。我将在以后的文章中介绍为Python推荐的<a class="ae le" href="https://pypi.org/project/PyNaCl/" rel="noopener ugc nofollow" target="_blank"> PyNaCl </a>库，但这应该能让你马上上手。</p><h2 id="2700" class="mx lr it bd ls nq nr dn lw ns nt dp ma kb nu nv me kf nw nx mi kj ny nz mm oa bi translated">下载可用模块中的上述代码:</h2><p id="5e0b" class="pw-post-body-paragraph jq jr it js b jt mo jv jw jx mp jz ka kb mq kd ke kf mr kh ki kj ms kl km kn im bi translated">如果你想在你的代码中使用它，这里是一个类:<a class="ae le" href="https://github.com/sachio222/medium/blob/master/FernetCipher.py" rel="noopener ugc nofollow" target="_blank">https://github . com/sachio 222/medium/blob/master/fernetcipher . py</a></p><p id="8887" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它包含基本相同的方法，只是排列方式不同，以便您可以在代码中轻松调用它们:</p><p id="0b9d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">加密快乐！</p></div></div>    
</body>
</html>