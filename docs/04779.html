<html>
<head>
<title>Kubernetes Cluster for Node API with Socket.io and automatic SSL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有Socket.io和自动SSL的Kubernetes节点API集群</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/kubernetes-cluster-for-node-api-with-socket-io-and-automatic-ssl-3aa6e2310a6f?source=collection_archive---------10-----------------------#2020-07-14">https://levelup.gitconnected.com/kubernetes-cluster-for-node-api-with-socket-io-and-automatic-ssl-3aa6e2310a6f?source=collection_archive---------10-----------------------#2020-07-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/8d7248659d1479adbd48ec56ec6d19b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fQutjy8H0ZQh9ZHO7wIx5A.png"/></div></div></figure><p id="a330" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">完整的节点API示例，包含创建一个支持socket.io/websockets和自动SSL的廉价Kubernetes集群所需的所有配置文件。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><blockquote class="ld le lf"><p id="9d03" class="jy jz lg ka b kb kc kd ke kf kg kh ki lh kk kl km li ko kp kq lj ks kt ku kv ij bi translated"><em class="iq">所有代码和配置在</em> <a class="ae lk" href="https://github.com/ehacke/node-gke-cluster" rel="noopener ugc nofollow" target="_blank"> <em class="iq"> GitHub </em> </a>上可用</p></blockquote><p id="bcde" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">作为免责声明，我不是说这是一个完美的适合每个人。不同的应用程序有不同的技术要求，以及不同的正常运行时间或可用性标准。</p><p id="1bb1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是我的目标是概述廉价的GKE集群的基础知识，并考虑节点微服务。<a class="ae lk" href="https://asserted.io" rel="noopener ugc nofollow" target="_blank"> Asserted </a>使用与此类似的配置来运行其所有微服务。</p><h1 id="7071" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">集群功能</h1><ul class=""><li id="fd45" class="mj mk iq ka b kb ml kf mm kj mn kn mo kr mp kv mq mr ms mt bi translated"><a class="ae lk" href="https://cloud.google.com/kubernetes-engine/docs/how-to/preemptible-vms" rel="noopener ugc nofollow" target="_blank">可抢占节点</a>降低成本(可选)</li><li id="b5a0" class="mj mk iq ka b kb mu kf mv kj mw kn mx kr my kv mq mr ms mt bi translated">使用<a class="ae lk" href="https://cloud.google.com/kubernetes-engine/docs/how-to/managed-certs" rel="noopener ugc nofollow" target="_blank">谷歌托管证书</a> ‍的自动SSL管理</li><li id="5eb9" class="mj mk iq ka b kb mu kf mv kj mw kn mx kr my kv mq mr ms mt bi translated">入口websocket粘性</li></ul><h2 id="559c" class="mz lm iq bd ln na nb dn lr nc nd dp lv kj ne nf lz kn ng nh md kr ni nj mh nk bi translated">为什么是集群？为什么不只是一个虚拟机呢？</h2><p id="f069" class="pw-post-body-paragraph jy jz iq ka b kb ml kd ke kf mm kh ki kj nl kl km kn nm kp kq kr nn kt ku kv ij bi translated">如果你唯一考虑的是价格，那么使用虚拟机可能更便宜。然而，部署到一个集群中提供了许多优势，而不需要花费太多的钱。</p><p id="b703" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">GKE集群为你提供了大量免费的东西，否则你将不得不自己动手或改造。</p><ul class=""><li id="6b00" class="mj mk iq ka b kb kc kf kg kj no kn np kr nq kv mq mr ms mt bi translated">Dockerized应用程序确保可移植和可复制的构建</li><li id="a286" class="mj mk iq ka b kb mu kf mv kj mw kn mx kr my kv mq mr ms mt bi translated">部署在推出时会自动进行运行状况检查，如果出现问题，部署会停止</li><li id="a2f6" class="mj mk iq ka b kb mu kf mv kj mw kn mx kr my kv mq mr ms mt bi translated">失败的实例会自动从负载平衡器中移除并重新启动</li><li id="70d6" class="mj mk iq ka b kb mu kf mv kj mw kn mx kr my kv mq mr ms mt bi translated">入口控制器可以自动提供和更新您的SSL证书</li><li id="1604" class="mj mk iq ka b kb mu kf mv kj mw kn mx kr my kv mq mr ms mt bi translated">资源管理变得更加容易，因为单个应用程序可能会受到CPU或内存的限制，并在机器上进行优化分配</li><li id="ca82" class="mj mk iq ka b kb mu kf mv kj mw kn mx kr my kv mq mr ms mt bi translated">可以以最低的复杂性部署新的应用程序</li><li id="1054" class="mj mk iq ka b kb mu kf mv kj mw kn mx kr my kv mq mr ms mt bi translated">高可用性变成了你愿意支付多少钱的问题，而不是一个工程问题</li></ul><p id="ae27" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我看来，反对这一切的唯一真正理由就是集群的成本。但是经过适当的配置，可以以最低的成本部署一个简单的集群。</p><h2 id="39c8" class="mz lm iq bd ln na nb dn lr nc nd dp lv kj ne nf lz kn ng nh md kr ni nj mh nk bi translated">高可用性</h2><p id="1e1b" class="pw-post-body-paragraph jy jz iq ka b kb ml kd ke kf mm kh ki kj nl kl km kn nm kp kq kr nn kt ku kv ij bi translated">在这种情况下，我需要我的集群能够在不停机的情况下执行部署和节点更新，因为这两个事件可能相对频繁。</p><p id="ef7d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">也就是说，我不需要也负担不起100%的正常运行时间。我不需要多区冗余，也绝对不需要多云故障转移。如果能显著降低我的成本，我可以忍受大约一个月一次长达一分钟左右的意外停机风险。</p><p id="a5cc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您将所有服务设计为无状态，并利用Cloud PubSub对工作进行排队，而不是通过HTTP直接调用其他服务，则有可能让整个微服务的pods在一两分钟内变得不可用，而不会产生任何持久的(或者甚至是明显的)影响。</p><h2 id="070c" class="mz lm iq bd ln na nb dn lr nc nd dp lv kj ne nf lz kn ng nh md kr ni nj mh nk bi translated">可抢占的节点</h2><p id="0abd" class="pw-post-body-paragraph jy jz iq ka b kb ml kd ke kf mm kh ki kj nl kl km kn nm kp kq kr nn kt ku kv ij bi translated">这是一个可选步骤，但却是节省大量成本的来源。可抢占的e2-small的成本是标准虚拟机的30%。但是伴随而来的是一些警告:</p><ul class=""><li id="68d9" class="mj mk iq ka b kb kc kf kg kj no kn np kr nq kv mq mr ms mt bi translated"><strong class="ka ir">可抢占的节点可以随时被杀死。</strong>甚至在开始的几分钟内(虽然在我的经验中很少见)。‍</li><li id="fa99" class="mj mk iq ka b kb mu kf mv kj mw kn mx kr my kv mq mr ms mt bi translated"><strong class="ka ir">谷歌声称他们总是在24小时内重启实例</strong>，尽管我发现这并不总是case‍</li><li id="a28e" class="mj mk iq ka b kb mu kf mv kj mw kn mx kr my kv mq mr ms mt bi translated">可抢占的节点可能并不总是可用的。对于较大的虚拟机来说，这似乎是一个更大的问题，我从未见过较小的虚拟机出现这种问题。</li></ul><p id="febe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您的服务是无状态的，这应该不是什么大问题。唯一真正的问题是，如果节点的生命周期是同步的，而谷歌决定同时杀死所有节点。这种风险可以通过运行类似于<a class="ae lk" href="https://github.com/estafette/estafette-gke-preemptible-killer" rel="noopener ugc nofollow" target="_blank">preemptable-killer</a>的东西来最小化，但是我还没有发现这是必要的。</p><h1 id="57f9" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">创建集群</h1><h2 id="317b" class="mz lm iq bd ln na nb dn lr nc nd dp lv kj ne nf lz kn ng nh md kr ni nj mh nk bi translated">集群详细信息</h2><p id="c75f" class="pw-post-body-paragraph jy jz iq ka b kb ml kd ke kf mm kh ki kj nl kl km kn nm kp kq kr nn kt ku kv ij bi translated">集群是用一个单独的<strong class="ka ir"> gcloud </strong>命令创建的。如果集群已经存在，您可以使用类似的参数创建一个新的节点池。</p><figure class="nr ns nt nu gt jr"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="a3ec" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">运行此命令后，需要几分钟才能完成。</p><h2 id="fc0e" class="mz lm iq bd ln na nb dn lr nc nd dp lv kj ne nf lz kn ng nh md kr ni nj mh nk bi translated">API实现</h2><p id="1d1c" class="pw-post-body-paragraph jy jz iq ka b kb ml kd ke kf mm kh ki kj nl kl km kn nm kp kq kr nn kt ku kv ij bi translated">示例API只有几行代码，但是有相当多的代码演示了各种集群特性。</p><figure class="nr ns nt nu gt jr"><div class="bz fp l di"><div class="nv nw l"/></div></figure><h2 id="dd8c" class="mz lm iq bd ln na nb dn lr nc nd dp lv kj ne nf lz kn ng nh md kr ni nj mh nk bi translated">命名空间</h2><p id="71cd" class="pw-post-body-paragraph jy jz iq ka b kb ml kd ke kf mm kh ki kj nl kl km kn nm kp kq kr nn kt ku kv ij bi translated">首先创建名称空间。</p><pre class="nr ns nt nu gt nx ny nz oa aw ob bi"><span id="43b0" class="mz lm iq ny b gy oc od l oe of">kubectl apply -f cluster/namespace.yml</span></pre><h2 id="2a42" class="mz lm iq bd ln na nb dn lr nc nd dp lv kj ne nf lz kn ng nh md kr ni nj mh nk bi translated">部署Redis</h2><p id="7e42" class="pw-post-body-paragraph jy jz iq ka b kb ml kd ke kf mm kh ki kj nl kl km kn nm kp kq kr nn kt ku kv ij bi translated">Redis仅作为集群内部署包含在本例中。在生产环境中，如果需要Redis，您可能不希望它出现在可抢占的实例中。</p><p id="8fab" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">更好的选择是使用节点选择器或节点亲缘关系将其部署到不可抢占的VM上，如果预算允许，甚至可以用Redis Memorystore来代替。一个最小的Redis Memorystore实例有点昂贵，但我认为值得。</p><p id="1797" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">也就是说，如果您设计您的微服务，将Redis视为一个短暂的美好的全局缓存，并在它消失时让连接优雅地失败，您可以在preemptible上的集群中运行它。同样，这取决于您的应用、成本敏感度和正常运行时间要求。</p><pre class="nr ns nt nu gt nx ny nz oa aw ob bi"><span id="d375" class="mz lm iq ny b gy oc od l oe of">kubectl apply -f cluster/redis</span></pre><h2 id="90cc" class="mz lm iq bd ln na nb dn lr nc nd dp lv kj ne nf lz kn ng nh md kr ni nj mh nk bi translated">创建API IP地址</h2><p id="d33a" class="pw-post-body-paragraph jy jz iq ka b kb ml kd ke kf mm kh ki kj nl kl km kn nm kp kq kr nn kt ku kv ij bi translated">创建一个公共外部API IP来绑定到入口。</p><pre class="nr ns nt nu gt nx ny nz oa aw ob bi"><span id="e7c4" class="mz lm iq ny b gy oc od l oe of">gcloud compute addresses create test-api-ip — global</span></pre><p id="dd99" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将您的DNS提供商配置为指向IP。</p><h2 id="71a1" class="mz lm iq bd ln na nb dn lr nc nd dp lv kj ne nf lz kn ng nh md kr ni nj mh nk bi translated">配置图和API部署</h2><p id="2451" class="pw-post-body-paragraph jy jz iq ka b kb ml kd ke kf mm kh ki kj nl kl km kn nm kp kq kr nn kt ku kv ij bi translated">配置图和部署大部分都很标准，但是我将强调重要的细节。</p><p id="d29e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> deploy.yml </strong>指定了pod反亲缘关系，以便在节点间尽可能广泛地传播API pods。<a class="ae lk" href="https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#built-in-node-labels" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">拓扑关键字</strong> </a>允许部署确定给定的pod是否与另一个pod位于同一资源上。</p><figure class="nr ns nt nu gt jr"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="37cf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">应用配置图和API部署，并等待它们启动。</p><pre class="nr ns nt nu gt nx ny nz oa aw ob bi"><span id="be3d" class="mz lm iq ny b gy oc od l oe of">kubectl apply -f cluster/api/configMap.yml<br/>kubectl apply -f cluster/api/deploy.yml</span></pre><h2 id="8956" class="mz lm iq bd ln na nb dn lr nc nd dp lv kj ne nf lz kn ng nh md kr ni nj mh nk bi translated">BackendConfig</h2><p id="76be" class="pw-post-body-paragraph jy jz iq ka b kb ml kd ke kf mm kh ki kj nl kl km kn nm kp kq kr nn kt ku kv ij bi translated">在GKE，BackendConfig是一个不太广为人知的配置选项，但是它对于使websockets在多个节点上正确地实现负载平衡是必不可少的。</p><p id="f951" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">后端配置本身如下所示:</p><figure class="nr ns nt nu gt jr"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="0fef" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这将负载平衡器配置为具有基于IP的会话粘性，以便连接不会不断地循环到每个API pod。否则，socket.io将无法在轮询时保持连接。</p><p id="ed94" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="lg">连接排放</em>选项只是增加了允许排放连接的时间，因为旧的API容器被新的替换了。默认值为0，这会导致连接提前中断。</p><pre class="nr ns nt nu gt nx ny nz oa aw ob bi"><span id="2c8f" class="mz lm iq ny b gy oc od l oe of">kubectl apply -f cluster/api/backend.yml</span></pre><p id="5098" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后这个BackendConfig被<strong class="ka ir"> service.yml </strong>和<strong class="ka ir"> ingress.yml </strong>引用。</p><h2 id="7730" class="mz lm iq bd ln na nb dn lr nc nd dp lv kj ne nf lz kn ng nh md kr ni nj mh nk bi translated">API服务</h2><p id="5186" class="pw-post-body-paragraph jy jz iq ka b kb ml kd ke kf mm kh ki kj nl kl km kn nm kp kq kr nn kt ku kv ij bi translated">该服务创建一个连接到每个API pod的外部负载平衡器。</p><figure class="nr ns nt nu gt jr"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="e4cc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这种情况下，重要的额外细节是规范中的注释和sessionAffinity。</p><pre class="nr ns nt nu gt nx ny nz oa aw ob bi"><span id="45e7" class="mz lm iq ny b gy oc od l oe of">kubectl apply -f cluster/api/service.yml</span></pre><h2 id="fcf6" class="mz lm iq bd ln na nb dn lr nc nd dp lv kj ne nf lz kn ng nh md kr ni nj mh nk bi translated">受管证书和入口</h2><p id="7f4e" class="pw-post-body-paragraph jy jz iq ka b kb ml kd ke kf mm kh ki kj nl kl km kn nm kp kq kr nn kt ku kv ij bi translated">入口端接SSL，并将服务和负载平衡器连接到固定的外部IP。</p><figure class="nr ns nt nu gt jr"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="a15a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里重要的额外细节还是注释。它们将入口链接到正确的证书、IP和后端。并且在nginx中启用websocket负载平衡，没有它websocket连接将无法工作。</p><p id="9d22" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">受管证书尝试为其配置中指定的域创建SSL证书。它要求在托管证书切换到活动状态之前，部署并运行之前的所有内容。</p><figure class="nr ns nt nu gt jr"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="4731" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">创建证书和入口。</p><pre class="nr ns nt nu gt nx ny nz oa aw ob bi"><span id="e028" class="mz lm iq ny b gy oc od l oe of">kubectl apply -f cluster/api/managedCert.yml<br/>kubectl apply -f cluster/api/ingress.yml</span></pre><p id="6c64" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">创建托管证书最多需要20分钟。您可以通过分别运行以下命令来监控证书创建和入口创建:</p><pre class="nr ns nt nu gt nx ny nz oa aw ob bi"><span id="8d69" class="mz lm iq ny b gy oc od l oe of">watch kubectl describe managedcertificate<br/>watch kubectl get ingress</span></pre><h1 id="8837" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">成功！</h1><p id="ba7c" class="pw-post-body-paragraph jy jz iq ka b kb ml kd ke kf mm kh ki kj nl kl km kn nm kp kq kr nn kt ku kv ij bi translated">一旦一切就绪，您应该能够导航到您绑定到外部IP的URL，并看到以下内容:</p><figure class="nr ns nt nu gt jr gh gi paragraph-image"><div class="gh gi og"><img src="../Images/5e670668202751399fb01d1864580151.png" data-original-src="https://miro.medium.com/v2/resize:fit:886/format:webp/0*VORSdMoGmdPUmZiG.png"/></div></figure><p id="0bde" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">刷新时，连接的主机名不应改变，这表明socket.io和会话亲缘关系正在工作。</p><p id="00cc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，您已经拥有了使用自动SSL和websocket/socket.io支持的Kubernetes集群所需的所有基本配置！</p></div></div>    
</body>
</html>