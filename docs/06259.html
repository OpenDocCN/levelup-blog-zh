<html>
<head>
<title>Memory management in swift (Part -01)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">swift中的内存管理(第一部分)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/arc-memory-management-in-swift-165fd0329f16?source=collection_archive---------8-----------------------#2020-11-09">https://levelup.gitconnected.com/arc-memory-management-in-swift-165fd0329f16?source=collection_archive---------8-----------------------#2020-11-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="66ad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">描述如何在Swift中使用自动引用计数来管理应用程序内存。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/4ec0ab04fc40b9361d9b69f617172d0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nAVeH4muYbtwXnjShsRvdQ.jpeg"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">瓦伦丁·塔纳索维奇通过<a class="ae lb" href="https://www.pexels.com/@pixabay" rel="noopener ugc nofollow" target="_blank">派克斯</a>拍摄的照片</figcaption></figure><h1 id="f834" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">概观</h1><p id="7619" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">开发移动应用程序时，内存是一个大问题。不寻常的内存访问会降低应用程序的性能，导致应用程序意外崩溃。幸运的是，Swift使用ARC(自动引用计数)来管理您的应用程序内存。大多数情况下，ARC会自己清理内存，但有时会因为某些关系而无法清理。在本教程中，我们将学习如何使用ARC来释放Swift的内存。</p><blockquote class="mf mg mh"><p id="8e6e" class="jn jo mi jp b jq jr js jt ju jv jw jx mj jz ka kb mk kd ke kf ml kh ki kj kk ij bi translated"><em class="iq">本教程使用</em> <strong class="jp ir"> <em class="iq"> Swift 5，Xcode 12.1编写。</em>T9】</strong></p></blockquote><h1 id="0ede" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">什么是ARC？</h1><p id="e155" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">当我们使用init()创建一个类的实例时，会为它分配一些内存块。当不再使用这个实例时，调用deinit()方法，ARC释放该对象占用的内存。</p><p id="5b2c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但事情并不是每次都这么简单。有时由于某种关系，deinit()方法不执行，ARC不能释放内存。您可能会注意到，在iOS开发中，有时变量使用弱关键字或无主关键字声明。这些关键字实际上与一个变量和一个类联系在一起。我们将学习如何聪明地处理它们并释放未使用的内存。</p><h1 id="4101" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">“强”参考和保留周期</h1><p id="03c7" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">假设我们有一个简单的类<strong class="jp ir"> Student </strong>，它有一个属性初始化器来初始化它的属性。</p><pre class="km kn ko kp gt mm mn mo mp aw mq bi"><span id="18e7" class="mr ld iq mn b gy ms mt l mu mv">class Student {<br/>    let studentName: String<br/>    init(studentName: String) {<br/>        self.studentName = studentName<br/>        print("\(studentName) created")<br/>    }</span><span id="fba1" class="mr ld iq mn b gy mw mt l mu mv"><strong class="mn ir">    </strong>deinit {<br/>        print("Deinit student \(studentName)")<br/>    }<br/>}</span></pre><p id="bdfa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">学生类也有一个反初始化器。当一个类的属性被ARC从内存中取消初始化时，将调用deinit()方法。</p><p id="c5e7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们创建一个简单的变量<strong class="jp ir">学生</strong>的<strong class="jp ir">学生</strong>类。该变量将创建一个对<strong class="jp ir"> Student </strong>类的强引用，Student类的引用计数将变为0比1。</p><pre class="km kn ko kp gt mm mn mo mp aw mq bi"><span id="29d6" class="mr ld iq mn b gy ms mt l mu mv">var student: Student? = Student(studentName: “John”)</span><span id="c170" class="mr ld iq mn b gy mw mt l mu mv"><strong class="mn ir">Console output:</strong><br/><em class="mi">John created</em></span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/b8e5a927ad2f96fd6cbb7973695a9d5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:938/format:webp/1*fs5X541jLadMlnyONCx2hA.png"/></div></figure><p id="73d6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以通过将<strong class="jp ir">学生</strong>变量值设置为零来移除引用。<strong class="jp ir"> <em class="mi">注意</em> </strong> <strong class="jp ir"> <em class="mi">注意，通过将变量设置为零，我们不是删除变量，而不仅仅是删除引用。</em>T29】</strong></p><pre class="km kn ko kp gt mm mn mo mp aw mq bi"><span id="6d2a" class="mr ld iq mn b gy ms mt l mu mv">student = nil</span><span id="53ad" class="mr ld iq mn b gy mw mt l mu mv"><strong class="mn ir">Console output:<br/></strong><em class="mi">Deinit student John</em></span></pre><p id="18c0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该语句将删除<strong class="jp ir">学生</strong>变量与<strong class="jp ir">学生</strong>类的关系，执行deinit()方法，并且<strong class="jp ir">学生</strong>类引用计数从1变为0。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi my"><img src="../Images/4e10be4e003d2756a80b40ff042d5c2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:942/format:webp/1*eF-VE_eLwYVOWtch5YMdCQ.png"/></div></figure><p id="56a6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在假设我们有两个不同的班级作为<strong class="jp ir">学生</strong>和<strong class="jp ir">课程</strong></p><pre class="km kn ko kp gt mm mn mo mp aw mq bi"><span id="1f08" class="mr ld iq mn b gy ms mt l mu mv">class Student {<br/>    var course: Course?<br/>    let studentName: String<br/>    init(studentName: String) {<br/>        self.studentName = studentName<br/>        print("\(studentName) created")<br/>    }<br/><strong class="mn ir">    </strong>deinit {<br/>        print("Deinit student \(studentName)")<br/>    }<br/>}</span><span id="d1fb" class="mr ld iq mn b gy mw mt l mu mv">class Course{<br/>    var student: Student?<br/>    let courseName: String<br/>    init(courseName: String) {<br/>        self.courseName = courseName<br/>        print("\(courseName) generated")<br/>    }<br/>    deinit {<br/>        print("Deinit course \(courseName)")<br/>    }<br/>}</span></pre><p id="3eb9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们初始化<strong class="jp ir">学生</strong> &amp; <strong class="jp ir">课程</strong>班级如下</p><pre class="km kn ko kp gt mm mn mo mp aw mq bi"><span id="372e" class="mr ld iq mn b gy ms mt l mu mv">var student: Student? = Student(studentName: “John”)<br/>var course: Course? = Course(courseName: “CS-190”)</span><span id="b383" class="mr ld iq mn b gy mw mt l mu mv"><strong class="mn ir">Console output:<br/></strong><em class="mi">John created<br/>CS-190 generated</em></span></pre><p id="c8d7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在这两个类的引用计数都是1，因为我们为它们创建了两个单独的引用。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/6155d8a684baa18ffbcdab7fea2d1093.png" data-original-src="https://miro.medium.com/v2/resize:fit:964/format:webp/1*0iLC01zBcwvwU9V07Zk-Sw.png"/></div></figure><p id="a56d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我们分别为<strong class="jp ir">学生</strong>和<strong class="jp ir">课程</strong>类中的<strong class="jp ir">课程</strong>和<strong class="jp ir">学生</strong>属性设置值时，它们之间会创建一个强引用。两个类的引用计数都从1变为2。</p><pre class="km kn ko kp gt mm mn mo mp aw mq bi"><span id="ec6c" class="mr ld iq mn b gy ms mt l mu mv">student?.course = course<br/>course?.student = student</span><span id="f084" class="mr ld iq mn b gy mw mt l mu mv"><strong class="mn ir">Console output:<br/></strong><em class="mi">John created<br/>CS-190 generated</em></span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/3636cdf2c248b3e5c30aaf5e67bc1565.png" data-original-src="https://miro.medium.com/v2/resize:fit:964/format:webp/1*5bJQQ4fi7Z_nnLHQyIp4Lg.png"/></div></figure><p id="8d71" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是现在如果我们打破<strong class="jp ir">学生</strong>和<strong class="jp ir">课程</strong>变量的强引用，将它们设置为零，那么<strong class="jp ir">学生</strong> &amp; <strong class="jp ir">课程</strong>的引用计数将不会像我们预期的那样从2下降到0。这两个类的引用计数都是1😮</p><pre class="km kn ko kp gt mm mn mo mp aw mq bi"><span id="37ab" class="mr ld iq mn b gy ms mt l mu mv">course = nil<strong class="mn ir"><br/></strong>student = nil</span><span id="2169" class="mr ld iq mn b gy mw mt l mu mv"><strong class="mn ir">Console output:<br/></strong><em class="mi">John created<br/>CS-190 generated</em></span></pre><p id="4c08" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">检查您的控制台输出。您将找不到任何关于取消初始化的内容，因为您的<strong class="jp ir"> deinit() </strong>方法没有执行。虽然<strong class="jp ir">课程</strong> &amp; <strong class="jp ir">学生</strong>被明确设置为0，但是各班之间相互参照。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi my"><img src="../Images/1224a115b9c03667d17626660d8ffd35.png" data-original-src="https://miro.medium.com/v2/resize:fit:942/format:webp/1*C2yG_MwsipyEgVwUD0QDnw.png"/></div></figure><p id="41bd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种情况被称为<strong class="jp ir">内存泄漏</strong>。ARC无法释放内存，因为这两个类之间都有一个<strong class="jp ir">强</strong>保留循环。</p><h1 id="9b83" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">“弱”引用以避免保留循环</h1><p id="36f4" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">根据swift文档，</p><blockquote class="mf mg mh"><p id="72d8" class="jn jo mi jp b jq jr js jt ju jv jw jx mj jz ka kb mk kd ke kf ml kh ki kj kk ij bi translated">弱引用不会在它所引用的实例上保留据点，当弱引用仍在引用它时，该实例有可能被释放。因此，当它引用的实例被释放时，ARC自动将弱引用设置为nil。</p></blockquote><p id="2ae4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">弱</strong>属性不保留据点，所以如果我们设置一个属性为<strong class="jp ir">弱</strong>，它不会增加相关类的引用计数。使用<strong class="jp ir">弱</strong>参考的时间，将<strong class="jp ir">学生</strong>内的<strong class="jp ir">课程</strong>变量设置为</p><pre class="km kn ko kp gt mm mn mo mp aw mq bi"><span id="d408" class="mr ld iq mn b gy ms mt l mu mv">weak var course: Course?</span></pre><p id="2537" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这将在很大程度上影响到<strong class="jp ir">学生</strong> &amp; <strong class="jp ir">课程</strong>班级的关系。让我们看看它如何避免内存泄漏。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi na"><img src="../Images/37ebae45a13f24f5123e5179d93440e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:970/format:webp/1*bBraMVD1OGMHi9WTMBngig.png"/></div></figure><p id="a61c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">目前，<strong class="jp ir">学生</strong>类有两个强引用，而<strong class="jp ir">课程</strong>类有一个强引用，另一个弱引用。如果我们设置<strong class="jp ir">进程</strong>变量为<strong class="jp ir"> nil，</strong>它<strong class="jp ir"> </strong>将解决<strong class="jp ir">内存泄漏</strong>😲 😲</p><p id="db22" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">是的，这背后的黑客是当我们将<strong class="jp ir">课程</strong>变量设置为0时，<strong class="jp ir">课程</strong> &amp; <strong class="jp ir">学生</strong>类之间的强关系不复存在(自动移除，因为<strong class="jp ir">课程</strong>引用被移除)。</p><p id="9f85" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是另一个弱引用呢？弱参考将在设置为<strong class="jp ir">零</strong>的过程后立即通过ARC设置为<strong class="jp ir">零</strong>。这就是弱关键字的力量😃</p><p id="60f3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在设置<strong class="jp ir">航向</strong>变量<strong class="jp ir"> </strong>为<strong class="jp ir">零</strong>并看到你的控制台出来。</p><pre class="km kn ko kp gt mm mn mo mp aw mq bi"><span id="bd7a" class="mr ld iq mn b gy ms mt l mu mv">course = nil</span><span id="1f9e" class="mr ld iq mn b gy mw mt l mu mv"><strong class="mn ir">Console output:<br/></strong>John created<br/>CS-190 generated<br/>Deinit course CS-190</span></pre><p id="5627" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">调用<strong class="jp ir">课程</strong>类中的deinit() </strong>方法。这意味着ARC成功地从内存中删除了<strong class="jp ir">航向</strong>变量。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi na"><img src="../Images/2bb73ded3145dd0bd320fd76684282c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:970/format:webp/1*lxCq-tjXYf4D6gm3VXpH-A.png"/></div></figure><p id="fb2c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">看不到更多的保留周期，没有更多的内存泄漏。现在，如果不再需要，您也可以将<strong class="jp ir">学生</strong>变量设置为<strong class="jp ir">零</strong>。</p><h1 id="9ca8" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">“无主”引用</h1><p id="b089" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated"><strong class="jp ir">无主</strong>是另一种最小化引用计数的方法。类似于<strong class="jp ir">弱</strong>但两者略有区别。<strong class="jp ir">弱</strong>参考必须是可选类型。这就是为什么当不再需要引用时，ARC可以将nil设置为弱引用。</p><p id="a089" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">无主的不能是可有可无的，并期望总有一些价值。所以ARC不能把一个未知的参考值设置为nil。请考虑以下事实，注意使用unowned。根据swift文档，</p><blockquote class="mf mg mh"><p id="be84" class="jn jo mi jp b jq jr js jt ju jv jw jx mj jz ka kb mk kd ke kf ml kh ki kj kk ij bi translated">仅当您确定引用总是引用尚未被释放的实例时，才使用无主引用。</p><p id="28ce" class="jn jo mi jp b jq jr js jt ju jv jw jx mj jz ka kb mk kd ke kf ml kh ki kj kk ij bi translated">如果您试图在实例被释放后访问一个无主引用的值，您将得到一个运行时错误。</p></blockquote><p id="42e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们来看一个与<strong class="jp ir">无主相关的例子。我们有两个班级<strong class="jp ir">学生</strong> &amp; <strong class="jp ir">大学</strong>。班级之间的关系与以前的班级略有不同。一个学生可能有也可能没有任何大学，但每个大学都必须有学生。这就是为什么我们把<strong class="jp ir">大学</strong>类<strong class="jp ir"> </strong>里面的<strong class="jp ir">学生</strong>变量声明为<strong class="jp ir">无主</strong>不能再可选了。</strong></p><pre class="km kn ko kp gt mm mn mo mp aw mq bi"><span id="a06e" class="mr ld iq mn b gy ms mt l mu mv">class Students {<br/>    let studentName: String<br/>    var university: University?</span><span id="9995" class="mr ld iq mn b gy mw mt l mu mv">    init(studentName: String) {<br/>        self.studentName = studentName<br/>    }<br/>    deinit { <br/>        print(“\(studentName) is being deinitialized”) }<br/>    }</span><span id="3693" class="mr ld iq mn b gy mw mt l mu mv">class University {<br/>    let universityName: String<br/>    unowned let student: Students</span><span id="59a0" class="mr ld iq mn b gy mw mt l mu mv">    init(universityName: String, student: Students) {<br/>        self.universityName = universityName <br/>        self.student = student<br/>    }</span><span id="2071" class="mr ld iq mn b gy mw mt l mu mv">    deinit {<br/>        print(“\(universityName) is being deinitialized”) }<br/>    }</span><span id="778c" class="mr ld iq mn b gy mw mt l mu mv">var student: Students?<br/>student = Students(studentName: “John”)<br/>student!.university = University(universityName: “ABC”, student: student!)</span></pre><p id="a30b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在这两个阶级之间的关系就像下图一样</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/cb6e1128a1aad61662e9a1404541125f.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/format:webp/1*2FpJXPe83ObLEss92vdtFA.png"/></div></figure><p id="1aef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们想释放你的内存，只需将<strong class="jp ir">学生</strong>变量设置为<strong class="jp ir">零</strong>。</p><pre class="km kn ko kp gt mm mn mo mp aw mq bi"><span id="d09b" class="mr ld iq mn b gy ms mt l mu mv">student = nil</span><span id="438e" class="mr ld iq mn b gy mw mt l mu mv"><strong class="mn ir">Console output:<br/></strong>John is being deinitialized<br/>ABC is being deinitialized</span></pre><p id="15f4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">检查你的控制台，ARC成功地从内存中删除了对象的引用，酷😎其输出将如下所示。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/0c298cf7eef19c2dd4c155707f8b6ed4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/1*hRfawoDTiaIwMzMIoj89cQ.png"/></div></figure><p id="d461" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是等到<strong class="jp ir">无主的时候</strong>会出问题吗？将<strong class="jp ir"> student </strong>对象设置为<strong class="jp ir"> nil </strong>后，尝试如下访问<strong class="jp ir"> University </strong>类的<strong class="jp ir"> student </strong>属性。</p><pre class="km kn ko kp gt mm mn mo mp aw mq bi"><span id="611f" class="mr ld iq mn b gy ms mt l mu mv">student = nil<br/>university.student //Run time error</span></pre><p id="9eb4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">根据<strong class="jp ir"> unowned </strong>的定义，它必须有一个对该对象的非零引用。由于所有者对象已经被释放，它崩溃了。</p><p id="854c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我想现在您已经对使用Swift编程语言进行内存管理有了一些了解。如果你想了解更多，查看我的内存管理教程第二部分<a class="ae lb" href="https://medium.com/@arifulislam14/memory-management-in-swift-part-02-b5b5f9fbb12b" rel="noopener">这里</a>。你会在<a class="ae lb" href="https://docs.swift.org/swift-book/LanguageGuide/AutomaticReferenceCounting.html" rel="noopener ugc nofollow" target="_blank"> Swift的官方文档</a>中找到对它们的简短讨论。</p><p id="6445" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">如果你觉得这篇文章有用，请分享并鼓掌</strong>👏👏👏<br/>在<a class="ae lb" href="https://medium.com/@arifulislam14" rel="noopener"> Medium </a>上查看我的其他文章，在<a class="ae lb" href="https://www.linkedin.com/in/arifparvez14/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上帮我联系。</p><p id="3bf6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">感谢您阅读&amp;快乐编码🙂</p></div></div>    
</body>
</html>