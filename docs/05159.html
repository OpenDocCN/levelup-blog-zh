<html>
<head>
<title>Design Patterns with Typescript: Interfaces vs Abstract classes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用类型脚本的设计模式:接口与抽象类</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/design-patterns-with-typescript-interfaces-vs-abstract-classes-b6aab6e2ad21?source=collection_archive---------1-----------------------#2020-08-08">https://levelup.gitconnected.com/design-patterns-with-typescript-interfaces-vs-abstract-classes-b6aab6e2ad21?source=collection_archive---------1-----------------------#2020-08-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/285db18f33025554d6a59e47dcda7229.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SVj05yE_a1zgDJUG"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">由<a class="ae kc" href="https://unsplash.com/@robsonhmorgan?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">罗布森·哈苏卡米·摩根</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="6601" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将回顾:</p><ol class=""><li id="141d" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">为什么以及何时我们应该使用接口——它们给代码库带来了什么</li><li id="cedb" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">接口:函数的看门人，带语法使用示例</li><li id="f6ae" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">抽象类:使用语法获得免费功能的契约使用示例</li><li id="6963" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">差异和相似之处——何时使用接口和抽象类</li></ol></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><p id="70fb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们开始之前——如果您对TypeScript语法不熟悉，或者如果您需要关于设置类型的快速提示，请务必阅读文章<a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/a-walk-through-setting-the-types-in-typescript-annotations-vs-inference-1da62e7492ae">A Walk Through Setting the TypeScript:Annotations vs Inference</a>。</p></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><p id="fe19" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在任何代码库中，代码的可重用性总是受欢迎的。这已经用干原理和常识重复了很多次。然而，编写更抽象的代码并不像为手头的特定任务提出解决方案那样容易。</p><p id="b18e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在JavaScript中，如果不看实现，我们永远无法确定函数需要什么参数，也无法确定调用函数时会用到什么参数。调用参数的方法，甚至访问嵌套的对象属性，都会导致脆弱的代码。为了避免这种限制，我们必须编写类似于<code class="fe lw lx ly lz b">object &amp;&amp; object.prop &amp;&amp; object.prop.func()</code>的重复检查，尽管有快捷语法，但这很快就会失控。</p><p id="ef49" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了解决这个问题，TypeScript引入了允许我们描述一个对象或一组值的结构的接口。毫无疑问，它非常方便，但我认为我们可以更进一步。我们可以使用接口来实现普通JavaScript无法比拟的代码可重用性。</p><blockquote class="ma mb mc"><p id="9a9f" class="kd ke md kf b kg kh ki kj kk kl km kn me kp kq kr mf kt ku kv mg kx ky kz la ij bi translated">我喜欢把接口想象成一个函数的看门人。在一个接口的帮助下，函数可以执行契约“匹配这个结构，你就可以得到这个功能。”</p></blockquote></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h2 id="4e59" class="mh mi iq bd mj mk ml dn mm mn mo dp mp ko mq mr ms ks mt mu mv kw mw mx my mz bi translated">在TypeScript: BubbleSorter类中使用接口</h2><p id="9aa9" class="pw-post-body-paragraph kd ke iq kf b kg na ki kj kk nb km kn ko nc kq kr ks nd ku kv kw ne ky kz la ij bi translated">让我们假设我们想做一个BubbleSorter类，它可以对一个数字数组、一个字符串和一个链表进行排序。这听起来像是另一个JavaScript笑话的开始，因为这些是非常不同的数据结构:</p><ul class=""><li id="1af7" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la nf lh li lj bi translated">数组有一个内置的排序方法，所以这个方法很简单</li><li id="ddea" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la nf lh li lj bi translated">一个字符串是不可变的，不能被直接操作，但是我们可以用<code class="fe lw lx ly lz b">.split()</code>和<code class="fe lw lx ly lz b">.join()</code>把它转换成一个数组</li><li id="ebbb" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la nf lh li lj bi translated">链表——没那么容易。默认情况下，它不存在于JavaScript/TypeScript中，因此它将是一个自定义实现</li></ul><p id="8c18" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您需要快速提醒，冒泡排序是O(n2)排序算法，它有一个嵌套的<code class="fe lw lx ly lz b">for</code>循环来遍历集合。冒泡排序有两个明显的特性可以帮助我们:</p><ul class=""><li id="2710" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la nf lh li lj bi translated">它<em class="md">比较</em>两个相邻的值。索引1处的值带有索引2处的值，然后索引2带有3，3带有4，依此类推</li><li id="1a31" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la nf lh li lj bi translated">如果索引1处的值大于索引2处的值——冒泡排序<em class="md">交换</em>它们，导致较大的值“冒泡”到集合的末尾</li></ul><p id="8d07" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这意味着我们的sorter类可以对任何东西进行排序，只要它知道如何比较两个元素以及如何交换它们。这是一个界面的完美工作。看一下这段代码:</p><figure class="ng nh ni nj gt jr"><div class="bz fp l di"><div class="nk nl l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">可以对不同的数据集合进行排序的通用BubbleSorter</figcaption></figure><p id="3fd5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个BubbleSorter类不知道它需要排序的集合的类型。在<code class="fe lw lx ly lz b">Sortable</code>接口的帮助下，我们实现了一个“契约”说:<br/>它可以是任何数据集合。只要您提供以下内容，BubbleSorter就可以对其进行排序:<br/> a)数据集合的长度<br/> b)比较结构中两个元素的函数<br/> c)交换两个元素的函数</p><p id="f590" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我不知道你个人的情况，但是我怀疑大多数工程师是否能够很容易地想出对链表进行排序的方法。我知道这可能需要我花很多时间去谷歌一下。然而，实现<code class="fe lw lx ly lz b">compare</code>和<code class="fe lw lx ly lz b">swap</code>功能没什么大不了的。有了这种类型的设置，我们可以重用排序本身的逻辑，并通过提供几个简单的函数来排序我们想要的任何东西。</p><p id="0df5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">BubbleSorter类与其余代码完全解耦，可以在任何地方使用。</p><p id="178c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">综上所述，TypeScript中的接口有:</p><ul class=""><li id="fe66" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la nf lh li lj bi translated">描述对象或一组值的结构的工具</li><li id="89c2" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la nf lh li lj bi translated">函数和类的看门人</li><li id="3ed4" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la nf lh li lj bi translated">一种执行“契约”的方法:匹配结构—获得功能</li></ul></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h2 id="f5d5" class="mh mi iq bd mj mk ml dn mm mn mo dp mp ko mq mr ms ks mt mu mv kw mw mx my mz bi translated">抽象类:重构BubbleSorter类</h2><p id="dc83" class="pw-post-body-paragraph kd ke iq kf b kg na ki kj kk nb km kn ko nc kq kr ks nd ku kv kw ne ky kz la ij bi translated">到目前为止，我们的BubbleSorter运行良好；只剩下一个需要改进的地方了。这种交互有点奇怪，我们需要用我们的数据集合创建一个BubbleSorter类的实例，然后在每次需要排序时调用<code class="fe lw lx ly lz b">.sort()</code>。这不是你所期望的工作方式。通常，如果某个类有一个内置的方法来排序自己，我们需要做的就是在它的一个实例上调用<code class="fe lw lx ly lz b">.sort()</code>。</p><p id="1078" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么，我们如何将BubbleSorter重构为:</p><ol class=""><li id="2b37" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">重用排序逻辑，避免将它复制粘贴到我们想要排序的其他类中</li><li id="5ad5" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">避免在每次我们想对集合进行排序时创建一个新的BubbleSorter实例</li></ol><p id="bb08" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了实现这一点，TypeScript还有另一个普通JavaScript中现有的特性——抽象类。正如你可能已经猜到的，抽象类是一个永远不会被实例化的类。它的目的就是成为某个其他类的父类，并在类似的类之间共享功能。这最后一部分不是由TypeScript本身强制执行的，但是被认为是一个好的实践，因为使用抽象类<em class="md">在类</em>之间引入了紧密耦合。</p><p id="a60a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">看一下下面的例子:</p><figure class="ng nh ni nj gt jr"><div class="bz fp l di"><div class="nk nl l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">抽象类BubbeSorter</figcaption></figure><p id="6392" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这次重构中，我们做了一些改动:</p><ol class=""><li id="3142" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">向BubbleSorter类添加了<code class="fe lw lx ly lz b">abstract</code>关键字。关键字将阻止创建此类的实例。</li><li id="55b7" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">在BubbleSorter类<em class="md">中定义了三个<em class="md">抽象</em>属性。</em>这确保了<code class="fe lw lx ly lz b">extends BubbleSorter</code>必须实现所需功能和属性的任何类。</li><li id="427e" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">集合类(NumbersCollection、CharCollection和LinkedList)现在是<code class="fe lw lx ly lz b">extend BubbleSorter</code>类而不是<code class="fe lw lx ly lz b">implements Sortable</code>接口。所以我们可以删除独立接口<code class="fe lw lx ly lz b">Sortable</code>,因为我们不再在代码中使用它。</li><li id="7a3b" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">为了对任何一个集合进行排序，我们可以在这个集合的实例中调用<code class="fe lw lx ly lz b">.sort()</code>。集合类不需要知道排序是如何发生的，也不需要知道任何排序细节。</li></ol><p id="5656" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用抽象类来引入由不同类的成员共享的功能是经典的类型脚本模式之一。抽象类在不同的类之间建立了一个契约，代价是它们之间的强耦合。这意味着如果没有BubbleSorter类，集合类将无法正常工作，并且BubbleSorter类不能独立实例化，没有集合类也没有多大意义。</p></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h2 id="7c96" class="mh mi iq bd mj mk ml dn mm mn mo dp mp ko mq mr ms ks mt mu mv kw mw mx my mz bi translated">差异和相似之处</h2><p id="df38" class="pw-post-body-paragraph kd ke iq kf b kg na ki kj kk nb km kn ko nc kq kr ks nd ku kv kw ne ky kz la ij bi translated">接口和抽象类无疑是最强大的TypeScript特性列表的顶端。这两个特性都在JavaScript世界中引入了新的OOP风格的功能，并促进了编写抽象的、更通用的、更可重用的代码。</p><p id="9aea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">总而言之，我们应该总是首先使用接口，当我们想要将功能“注入”到类似的类中时，就求助于抽象类的使用。</p><p id="66ab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">接口:</strong></p><ul class=""><li id="666d" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la nf lh li lj bi translated">促进松散耦合</li><li id="675f" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la nf lh li lj bi translated">在不同的类之间建立一个契约</li><li id="1e40" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la nf lh li lj bi translated">充当某项职能的“看门人”</li><li id="6050" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la nf lh li lj bi translated">当我们想要一起工作的对象非常不同时，效果最好</li></ul><p id="e44e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">继承/抽象类:</strong></p><ul class=""><li id="6568" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la nf lh li lj bi translated">将类强耦合在一起</li><li id="a4ad" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la nf lh li lj bi translated">在不同的类之间建立一个契约</li><li id="b793" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la nf lh li lj bi translated">当我们试图建立一个对象的定义时，效果最好</li></ul></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><p id="aa08" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我希望这能让TypeScript中的接口和抽象类的概念更加清晰。</p><p id="46f0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">完整实现请查看<a class="ae kc" href="https://github.com/arstrel/sorting-anything" rel="noopener ugc nofollow" target="_blank"> my GitHub </a>。</p><p id="84e9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们回顾了:</p><ul class=""><li id="8f2b" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la nf lh li lj bi translated">用接口和抽象类构建“排序任何东西”的BubbleSorter类的例子</li><li id="eaf2" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la nf lh li lj bi translated">两个概念的区别、相似之处和最佳用例</li></ul><p id="d49c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">感谢您的阅读！</p><p id="31f4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">构建漂亮而有弹性的应用程序，用TypeScript编写可重用的代码，一如既往地快乐编码！</p></div></div>    
</body>
</html>