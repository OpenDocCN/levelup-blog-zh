<html>
<head>
<title>Java Optional as a Stream</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java可选为流</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/java-optional-as-a-stream-c7bd79500619?source=collection_archive---------7-----------------------#2021-02-12">https://levelup.gitconnected.com/java-optional-as-a-stream-c7bd79500619?source=collection_archive---------7-----------------------#2021-02-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6ab3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">可选类型和流类型的唯一关系。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/cbce320c2313a96c12e17e3ecce8bc1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ooHTJzc-FTk5sRVM9D6poA.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图片来自<a class="ae ky" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=204398" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae ky" href="https://pixabay.com/users/christian_birkholz-76800/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=204398" rel="noopener ugc nofollow" target="_blank"> Christian_Birkholz </a></figcaption></figure><p id="4a1e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最近，我一直在用<a class="ae ky" href="https://projectreactor.io/" rel="noopener ugc nofollow" target="_blank">项目反应堆</a>和它们的两种主要类型<code class="fe lv lw lx ly b">Mono</code>和<code class="fe lv lw lx ly b">Flux</code>做很多工作。一个<code class="fe lv lw lx ly b">Mono</code>和一个<code class="fe lv lw lx ly b">Flux</code>的主要区别在于一个<code class="fe lv lw lx ly b">Mono</code>只能表示零个或一个元素，而一个<code class="fe lv lw lx ly b">Flux</code>可以表示零个或无限个元素。最近，我真正理解了<code class="fe lv lw lx ly b">Mono</code>和<code class="fe lv lw lx ly b">Flux</code>以及Java <code class="fe lv lw lx ly b">Optional</code>和<code class="fe lv lw lx ly b">Stream</code>类型之间的相似性。事实上，从Java 9开始，您可以使用<code class="fe lv lw lx ly b">stream()</code>方法将一个<code class="fe lv lw lx ly b">Optional</code>转换成一个<code class="fe lv lw lx ly b">Stream</code>。</p><p id="4f99" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于我们这些无法完全按照预期使用<code class="fe lv lw lx ly b">Optional</code>类型的人来说，这种相似性非常有帮助。自从Java 8第一次问世以来，我就接受了<code class="fe lv lw lx ly b">Stream</code>类型，但是<code class="fe lv lw lx ly b">Optional</code>类型我是后来才采用的。我认为这是因为它没有像streams那样被视为突破。</p><p id="9fbe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">Optional</code>型与<code class="fe lv lw lx ly b">Stream</code>型、<code class="fe lv lw lx ly b">filter</code>、<code class="fe lv lw lx ly b">map</code>和<code class="fe lv lw lx ly b">flatMap</code>共有几种方法。在每种情况下，它们的行为都像<code class="fe lv lw lx ly b">Stream</code>一样，如果“流”是空的，它们都返回空的。在Java 9中，使用<code class="fe lv lw lx ly b">Optional</code>类型的<code class="fe lv lw lx ly b">stream()</code>方法带来了整个<code class="fe lv lw lx ly b">Stream</code>方法套件，其中一些有意义，而另一些则没那么有意义。</p><p id="f79f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我最近的一篇文章中，<a class="ae ky" href="https://medium.com/swlh/all-loops-are-a-code-smell-6416ac4865d6" rel="noopener">所有的循环都是一种代码味道</a>，我建议(有点夸张地)我们为一个表示循环的函数消除日常循环，我们只使用流提供循环内部发生的事情。我还谈到了类似地表示if语句，但是我演示的唯一例子是使用<code class="fe lv lw lx ly b">Optional.ofNullable</code>删除普遍存在的<code class="fe lv lw lx ly b">if(x != null)</code>语句。但是进一步思考一下，我可以看到if语句<em class="lz">是while语句</em>，但是有零次或一次迭代，我可以看到模式。</p><p id="f027" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们能够使用<code class="fe lv lw lx ly b">Optional</code>而不是If语句，我们也可以返回一个类似于Scala从if语句返回值的值。但是我们需要一个接受测试值和谓词函数的方法。如果谓词函数返回true，将返回测试值(可能已转换)，否则，将返回空值。你可以用一个<code class="fe lv lw lx ly b">Optional</code>来做这件事:</p><pre class="kj kk kl km gt ma ly mb mc aw md bi"><span id="a556" class="me mf it ly b gy mg mh l mi mj">Optional&lt;T&gt; ret = Optional.of(test)<br/>  .filter(t -&gt; t.equals(expected));<br/>  .map(t -&gt; transform(t)); // add a possible transformation</span></pre><p id="7ece" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这相当于:</p><pre class="kj kk kl km gt ma ly mb mc aw md bi"><span id="9a7d" class="me mf it ly b gy mg mh l mi mj">T ret = null;<br/>if(test.equals(expected)) {<br/>  ret = transform(test);<br/>}</span></pre><p id="9f7f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是没有了<code class="fe lv lw lx ly b">null</code>的生意。</p><p id="e70b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于<code class="fe lv lw lx ly b">Optional</code>没有类似<code class="fe lv lw lx ly b">ofNullable()</code>的方法<code class="fe lv lw lx ly b">ifConditional()</code>，我们必须创建一个:</p><pre class="kj kk kl km gt ma ly mb mc aw md bi"><span id="6302" class="me mf it ly b gy mg mh l mi mj">static &lt;T, R&gt; Optional&lt;R&gt; ifConditional(T test, <br/>            Predicate&lt;T&gt; conditional, <br/>            Function&lt;T, Optional&lt;R&gt;&gt; map) {<br/>  return conditional.test(test) <br/>          ? map.apply(test) <br/>          : Optional.empty();<br/>}</span></pre><p id="1190" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">给定该函数，您可以更改此<code class="fe lv lw lx ly b">if/else</code>链:</p><pre class="kj kk kl km gt ma ly mb mc aw md bi"><span id="a43c" class="me mf it ly b gy mg mh l mi mj">static String getSoundWithIf(Pet pet) {<br/>  if(pet == Pet.dog) {<br/>    return "bark";<br/>  } else if(pet == Pet.cat) {<br/>    return "meow";<br/>  } else if(pet == Pet.bird) {<br/>    return "squawk";<br/>  } else if(pet == Pet.mouse) {<br/>    return "squeek";<br/>  } else {<br/>    return "beep";<br/>  }<br/>}</span></pre><p id="5fb8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相当于:</p><pre class="kj kk kl km gt ma ly mb mc aw md bi"><span id="c8f4" class="me mf it ly b gy mg mh l mi mj">static String getSoundWithOptional(Pet pet) {<br/>  return ifConditional(pet, <br/>    p1 -&gt; p1 == Pet.dog, p1 -&gt; Optional.of("bark"))<br/>      .orElseGet(() -&gt; ifConditional(pet,<br/>    p1 -&gt; p1 == Pet.cat, p1 -&gt; Optional.of("meow"))<br/>      .orElseGet(() -&gt; ifConditional(pet,<br/>    p1 -&gt; p1 == Pet.bird, p1 -&gt; Optional.of("squawk"))<br/>      .orElseGet(() -&gt; ifConditional(pet,<br/>    p1 -&gt; p1 == Pet.mouse, p1 -&gt; Optional.of("squeak"))<br/>      .orElse("beep"))));<br/>}</span></pre><p id="e6d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，我并不是建议你去掉所有的if/else链或者switch语句。if/else链是惯用的，看起来很舒服。这仅仅是一个关于<code class="fe lv lw lx ly b">Optional</code>和<code class="fe lv lw lx ly b">Stream</code>以及<code class="fe lv lw lx ly b">if</code>和<code class="fe lv lw lx ly b">while</code>语句之间对称性的思想实验。以这种方式展示，它展示了我们如何使用函数式编程在这两者之间移动。</p><p id="8f8f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">也许有一天，函数构造会像结构化编程构造一样惯用，编译器会了解它们并为它们做更好的优化。任何Scala程序员都可以更简洁地给出最后一个解决方案，但是我在这里用Java给出它，因为许多Java开发人员仍然需要学习函数式编程。学习从谓词和功能、供应商和消费者类型的角度进行思考是非常有用的。</p></div></div>    
</body>
</html>