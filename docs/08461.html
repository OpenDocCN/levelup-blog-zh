<html>
<head>
<title>How to call Haskell functions from C</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何从C中调用Haskell函数</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/when-how-and-why-you-should-call-haskell-functions-from-c-db7a356e6274?source=collection_archive---------14-----------------------#2021-05-04">https://levelup.gitconnected.com/when-how-and-why-you-should-call-haskell-functions-from-c-db7a356e6274?source=collection_archive---------14-----------------------#2021-05-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/d988132b069f20fc1a456c4e84a490a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SEYJfd4Hh9vpP2Ij8IpoOQ.jpeg"/></div></div></figure><p id="f033" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">将近50年后，C编程语言仍然被认为是快速的低级代码选择之一。它是一种相对较小的语言，非常容易学习，广泛传播，而且大家都知道它很快。非常非常快。</p><p id="0788" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">C的问题在于，由于语言的低级本质，一些算法可能变得难以编写、阅读和调试。有时候，用另一种语言编写这些算法可能是一个不错的选择。</p><p id="ae88" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有很多语言可以与c互操作。然而，有一种语言与c完全不同，但仍然是编写复杂算法的绝佳选择:Haskell。</p><p id="51a9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">事实上，Haskell是一种纯函数式编程语言，与C相比有很多优势:</p><ul class=""><li id="8c90" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated">高级编程语言</li><li id="f7c3" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">否<code class="fe ln lo lp lq b">null</code></li><li id="bd55" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">完全没有副作用</li><li id="34a4" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">更模块化的代码</li><li id="62ed" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">懒惰评估</li><li id="a987" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">更易于并行化</li></ul><p id="ac8e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">诸如此类。</p><p id="147a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">就性能而言，在大多数情况下，Haskell的执行速度非常接近c。这使得Haskell成为更快编写复杂算法的好选择。</p><p id="bb00" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">例如，假设我们想用两种语言实现快速排序算法。我们的C版本应该是这样的:</p><figure class="lr ls lt lu gt ju"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="a2d0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们的Haskell版本:</p><figure class="lr ls lt lu gt ju"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="386e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">好吧，也许这不是性能最好的Haskell QuickSort实现，但是你可以清楚地看到它是多么的简洁、容易和漂亮。</p><p id="a8a9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">想再举个例子吗？让我们看看如何在两种语言中使用Caesar密码加密字符串。</p><p id="6d5f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用C #中的Caesar密码加密字符串:</p><figure class="lr ls lt lu gt ju"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="8aec" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在Haskell中使用Caesar密码加密字符串:</p><figure class="lr ls lt lu gt ju"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="6036" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">两种完全不同的方法。但是他们做同样的工作！现在让我们试着运行两者:</p><figure class="lr ls lt lu gt ju"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="8f81" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">输出(在MacBook Pro 2020 16英寸、16GB内存、2,6 GHz 6核英特尔酷睿i7上):</p><figure class="lr ls lt lu gt ju"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="4e43" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">哈斯克尔竞争相当激烈！如果你不熟悉语法，Haskell一开始可能有点吓人。但是一旦你习惯了，你会发现Haskell程序比C程序更容易编写、理解和调试！</p><h1 id="6a52" class="lx ly it bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">从C调用Haskell</h1><p id="39d4" class="pw-post-body-paragraph kb kc it kd b ke mv kg kh ki mw kk kl km mx ko kp kq my ks kt ku mz kw kx ky im bi translated">现在让我们举一个微不足道的例子(为了简单起见)。我们想在Haskell中创建一个简单的<code class="fe ln lo lp lq b">fibonacci</code>函数，然后从c中调用它，首先:让我们写下我们的Haskell函数(取自Haskell官方wiki):</p><figure class="lr ls lt lu gt ju"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="d958" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">难以置信的简单明了！现在我们可能想从C程序中调用它，如下所示:</p><figure class="lr ls lt lu gt ju"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="f793" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们应该如何编译我们的Haskell程序？首先，我们需要为C生成存根，以使它与Haskell类型一起工作:</p><figure class="lr ls lt lu gt ju"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="2d43" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如你所见，我们正在将<code class="fe ln lo lp lq b">fibonacci_hs</code>参数从<code class="fe ln lo lp lq b">CInt</code>转换为<code class="fe ln lo lp lq b">Int</code>，以使其与我们原来的<code class="fe ln lo lp lq b">fibonacci</code>函数兼容。然后我们将结果转换回<code class="fe ln lo lp lq b">CInt</code>，使其与c兼容。最后但同样重要的是，我们使用<code class="fe ln lo lp lq b">foreign export</code>导出我们的<code class="fe ln lo lp lq b">fibonacci_hs</code>函数。</p><p id="d0aa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们编译我们的Haskell程序:</p><figure class="lr ls lt lu gt ju"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="76f3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这将生成以下文件:</p><ul class=""><li id="754c" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated"><code class="fe ln lo lp lq b">main.hi</code></li><li id="f056" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated"><code class="fe ln lo lp lq b">main.o</code></li><li id="e9c3" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated"><code class="fe ln lo lp lq b">main_stub.h</code></li></ul><p id="e049" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们来看看<code class="fe ln lo lp lq b">main_stub.h</code>的内容:</p><figure class="lr ls lt lu gt ju"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="8867" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">太好了！我们现在需要在C程序中包含这个头文件:</p><figure class="lr ls lt lu gt ju"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="a282" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">太好了！让我们用<code class="fe ln lo lp lq b">gcc</code>编译这个文件并测试它:</p><figure class="lr ls lt lu gt ju"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="7f81" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">厉害！您已经编译了您的第一个Haskell-to-C程序！</p><h1 id="eb94" class="lx ly it bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">什么时候真正有用？</h1><p id="1cae" class="pw-post-body-paragraph kb kc it kd b ke mv kg kh ki mw kk kl km mx ko kp kq my ks kt ku mz kw kx ky im bi translated">在很多情况下，将Haskell编译成C会非常有用。一个主要原因是当算法太复杂而不能用c语言编写时，Haskell是一种高级的垃圾收集语言，所以大多数时候，编写算法会容易得多。</p><p id="0b86" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">其他编程语言也可能出现同样的问题。有时候，用Java、Go和其他语言编写算法可能比用Haskell编写算法更复杂。用C编译你的函数意味着你可以从其他语言调用代码。事实上，许多编程语言可以与C互操作，用于低级任务或性能关键的算法。</p><p id="9349" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">将Haskell编译成C意味着您可以从以下语言中调用您的原始Haskell函数:</p><ul class=""><li id="068c" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated">去</li><li id="a0a3" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">Java 语言(一种计算机语言，尤用于创建网站)</li><li id="c22b" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">计算机编程语言</li><li id="4a61" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">节点. js</li><li id="03da" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">二郎/仙丹</li></ul><p id="9355" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">诸如此类。</p><p id="1948" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">那么…你准备好与Haskell互操作了吗？会很有趣的，我保证！您可以在这里找到包含代码示例<a class="ae na" href="https://github.com/Hackdoor-io/articles-codebase/tree/master/articles/when-how-and-why-you-should-call-haskell-functions-from-c" rel="noopener ugc nofollow" target="_blank">的存储库。</a></p><figure class="lr ls lt lu gt ju gh gi paragraph-image"><a href="https://github.com/sponsors/micheleriva"><div class="gh gi nb"><img src="../Images/e05f00ed2cddfd2907284cb397168c3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xAIiY1uBKSNdw12oq2BbjA.png"/></div></a></figure></div></div>    
</body>
</html>