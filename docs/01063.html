<html>
<head>
<title>How to Create PDFs with Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Node.js创建pdf</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-create-pdfs-with-node-js-c2eb94034f01?source=collection_archive---------0-----------------------#2019-11-02">https://levelup.gitconnected.com/how-to-create-pdfs-with-node-js-c2eb94034f01?source=collection_archive---------0-----------------------#2019-11-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/1999c567e5fbc4b78d1880cb1f194321.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uXXPlmGj7m7nNGplzVysqg.jpeg"/></div></div></figure><p id="65dd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">每个人都使用pdf——不言而喻，它是最常见的文档格式之一。因此，许多应用程序的一个功能是从其他类型的文档创建pdf。通过使用第三方库，在Node.js中创建pdf很容易，我们可以轻松地将该功能添加到我们自己的应用程序中。</p><p id="35bb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在本文中，我们将构建一个应用程序，让用户在富文本编辑器中输入他们的文档，并从中生成PDF。我们将使用Express作为后端，React作为前端。</p><h1 id="8711" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">后端</h1><p id="dcf8" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">我们将从后端开始。首先，我们将创建一个项目目录，其中包含一个<code class="fe mc md me mf b">backend</code>文件夹。然后在<code class="fe mc md me mf b">backend</code>文件夹中，运行<code class="fe mc md me mf b">npx express-generator</code>创建快递app。然后运行<code class="fe mc md me mf b">npm i</code>安装软件包。</p><p id="a1a5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们安装自己的软件包。我们需要Babel使用最新版本的JavaScript运行应用程序，CORS用于前端的跨域请求，HTML-PDF用于将HTML字符串转换为PDF，Multer用于文件上传，Sequelize用于ORM，SQLite3用于我们的数据库。</p><p id="b537" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们通过运行<code class="fe mc md me mf b">npm i @babel/cli @babel/core @babel/node @babel/preset-env cors html-pdf sequelize sqlite3 multer</code>来安装这些。</p><p id="9344" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">之后，我们将<code class="fe mc md me mf b">package.json</code>的<code class="fe mc md me mf b">scripts</code>部分改为:</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="86c4" class="mo la it mf b gy mp mq l mr ms">"start": "nodemon --exec npm run babel-node --  ./bin/www",<br/>"babel-node": "babel-node"</span></pre><p id="c9fd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这让我们可以用Babel而不是常规的节点运行时来运行我们的应用程序。</p><p id="60d8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后我们需要在<code class="fe mc md me mf b">backend</code>文件夹中创建一个<code class="fe mc md me mf b">.babelrc</code>文件，并添加:</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="2788" class="mo la it mf b gy mp mq l mr ms">{<br/>    "presets": [<br/>        "<a class="ae mt" href="http://twitter.com/babel/preset-env" rel="noopener ugc nofollow" target="_blank">@babel/preset-env</a>"<br/>    ]<br/>}</span></pre><p id="4f53" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这指定我们用最新版本的JavaScript运行我们的应用程序。</p><p id="f4ea" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们添加数据库代码。运行<code class="fe mc md me mf b">backend</code>文件夹中的<code class="fe mc md me mf b">npx sequelize-cli init</code>生成序列代码。</p><p id="84a8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们现在应该在项目中有一个<code class="fe mc md me mf b">config.js</code>。在那里加上:</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="77c7" class="mo la it mf b gy mp mq l mr ms">{<br/>  "development": {<br/>    "dialect": "sqlite",<br/>    "storage": "development.db"<br/>  },<br/>  "test": {<br/>    "dialect": "sqlite",<br/>    "storage": "test.db"<br/>  },<br/>  "production": {<br/>    "dialect": "sqlite",<br/>    "storage": "production.db"<br/>  }<br/>}</span></pre><p id="6fa0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这为我们的数据库声明了SQLite。</p><p id="f421" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，通过运行以下命令来创建我们的模型和迁移:</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="43be" class="mo la it mf b gy mp mq l mr ms">npx sequelize-cli model:create --name Document --attributes name:string,document:text,pdfPath:string</span></pre><p id="1d46" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这将创建一个<code class="fe mc md me mf b">Document</code>模型和<code class="fe mc md me mf b">Documents</code>表格。</p><p id="2f06" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了创建我们的数据库，我们运行:</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="cfcd" class="mo la it mf b gy mp mq l mr ms">npx sequelize-cli db:migrate</span></pre><p id="3d57" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们需要创建我们的路线。在<code class="fe mc md me mf b">routes</code>文件夹中创建一个<code class="fe mc md me mf b">pdf.js</code>文件，并添加:</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="3297" class="mo la it mf b gy mp mq l mr ms">var express = require("express");<br/>var pdf = require("html-pdf");<br/>const models = require("../models");<br/>var multer = require("multer");<br/>const fs = require("fs");<br/>var router = express.Router();<br/>const storage = multer.diskStorage({<br/>  destination: (req, file, cb) =&gt; {<br/>    cb(null, "./files");<br/>  },<br/>  filename: (req, file, cb) =&gt; {<br/>    cb(null, `${file.fieldname}_${+new Date()}.jpg`);<br/>  }<br/>});</span><span id="9533" class="mo la it mf b gy mu mq l mr ms">const upload = multer({<br/>  storage<br/>});</span><span id="58b7" class="mo la it mf b gy mu mq l mr ms">router.get("/", async (req, res, next) =&gt; {<br/>  const documents = await models.Document.findAll();<br/>  res.json(documents);<br/>});</span><span id="84cc" class="mo la it mf b gy mu mq l mr ms">router.post("/", async (req, res, next) =&gt; {<br/>  const document = await models.Document.create(req.body);<br/>  res.json(document);<br/>});</span><span id="897d" class="mo la it mf b gy mu mq l mr ms">router.put("/:id", async (req, res, next) =&gt; {<br/>  const id = req.params.id;<br/>  const { name, document } = req.body;<br/>  const doc = await models.Document.update(<br/>    { name, document },<br/>    { where: { id } }<br/>  );<br/>  res.json(doc);<br/>});</span><span id="5668" class="mo la it mf b gy mu mq l mr ms">router.delete("/:id", async (req, res, next) =&gt; {<br/>  const id = req.params.id;<br/>  await models.Document.destroy({ where: { id } });<br/>  res.json({});<br/>});</span><span id="d651" class="mo la it mf b gy mu mq l mr ms">router.get("/generatePdf/:id", async (req, res, next) =&gt; {<br/>  const id = req.params.id;<br/>  const documents = await models.Document.findAll({ where: { id } });<br/>  const document = documents[0];<br/>  const stream = await new Promise((resolve, reject) =&gt; {<br/>    pdf.create(document.document).toStream((err, stream) =&gt; {<br/>      if (err) {<br/>        reject(reject);<br/>        return;<br/>      }<br/>      resolve(stream);<br/>    });<br/>  });</span><span id="119c" class="mo la it mf b gy mu mq l mr ms">const fileName = `${+new Date()}.pdf`;<br/>  const pdfPath = `${__dirname}/../files/${fileName}`;<br/>  stream.pipe(fs.createWriteStream(pdfPath));<br/>  const doc = await models.Document.update(<br/>    { pdfPath: fileName },<br/>    { where: { id } }<br/>  );<br/>  res.json(doc);<br/>});</span><span id="cbfb" class="mo la it mf b gy mu mq l mr ms">router.post("/uploadImage", upload.single('upload'), async (req, res, next) =&gt; {<br/>  res.json({<br/>    uploaded: true,<br/>    url: `${process.env.BASE_URL}/${req.file.filename}`<br/>  });<br/>});</span><span id="be67" class="mo la it mf b gy mu mq l mr ms">module.exports = router;</span></pre><p id="b7c0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在前4条路线中，我们对<code class="fe mc md me mf b">Documents</code>表执行标准的CRUD操作。我们有GET用于获取所有的<code class="fe mc md me mf b">Documents</code>，post用于从POST参数创建一个<code class="fe mc md me mf b">Document</code>，PUT用于通过ID更新一个<code class="fe mc md me mf b">Document</code>，DELETE用于通过ID查找删除一个<code class="fe mc md me mf b">Document</code>。我们在<code class="fe mc md me mf b">document</code>字段中有HTML，用于稍后生成PDF。</p><p id="331b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe mc md me mf b">generatePdf</code>是允许我们构建PDF的函数。我们从URL获取ID，然后使用HTML-PDF包生成PDF。我们通过用HTML-PDF包将HTML文档转换成文件流对象来生成PDF。然后，我们将流写入一个文件，并将文件的路径保存在带有URL参数中的ID的<code class="fe mc md me mf b">Document</code>模型中。</p><p id="4db7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们也有一个<code class="fe mc md me mf b">uploadImage</code>路线，让用户用CKEditor上传图片。插件期望函数返回的响应中有<code class="fe mc md me mf b">uploaded</code>和<code class="fe mc md me mf b">url</code>。</p><p id="9b04" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后我们需要在<code class="fe mc md me mf b">backend</code>目录下添加一个<code class="fe mc md me mf b">files</code>文件夹。</p><p id="89fb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来在<code class="fe mc md me mf b">app.js</code>中，我们将现有代码替换为:</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="88cb" class="mo la it mf b gy mp mq l mr ms">var createError = require("http-errors");<br/>var express = require("express");<br/>var path = require("path");<br/>var cookieParser = require("cookie-parser");<br/>var logger = require("morgan");<br/>var cors = require("cors");</span><span id="cda8" class="mo la it mf b gy mu mq l mr ms">var indexRouter = require("./routes/index");<br/>var pdfRouter = require("./routes/pdf");</span><span id="2d8b" class="mo la it mf b gy mu mq l mr ms">var app = express();</span><span id="7194" class="mo la it mf b gy mu mq l mr ms">// view engine setup<br/>app.set("views", path.join(__dirname, "views"));<br/>app.set("view engine", "jade");</span><span id="7bcd" class="mo la it mf b gy mu mq l mr ms">app.use(logger("dev"));<br/>app.use(express.json());<br/>app.use(express.urlencoded({ extended: false }));<br/>app.use(cookieParser());<br/>app.use(express.static(path.join(__dirname, "public")));<br/>app.use(express.static(path.join(__dirname, "files")));<br/>app.use(cors());</span><span id="94f8" class="mo la it mf b gy mu mq l mr ms">app.use("/", indexRouter);<br/>app.use("/pdf", pdfRouter);</span><span id="3f53" class="mo la it mf b gy mu mq l mr ms">// catch 404 and forward to error handler<br/>app.use(function(req, res, next) {<br/>  next(createError(404));<br/>});</span><span id="2602" class="mo la it mf b gy mu mq l mr ms">// error handler<br/>app.use(function(err, req, res, next) {<br/>  // set locals, only providing error in development<br/>  res.locals.message = err.message;<br/>  res.locals.error = req.app.get("env") === "development" ? err : {};</span><span id="392a" class="mo la it mf b gy mu mq l mr ms">// render the error page<br/>  res.status(err.status || 500);<br/>  res.render("error");<br/>});</span><span id="3e1d" class="mo la it mf b gy mu mq l mr ms">module.exports = app;</span></pre><p id="3620" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们用以下内容公开文件夹:</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="6c32" class="mo la it mf b gy mp mq l mr ms">app.use(express.static(path.join(__dirname, "files")));</span></pre><p id="ddff" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">并暴露出<code class="fe mc md me mf b">pdf</code>路线:</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="1a4a" class="mo la it mf b gy mp mq l mr ms">var pdfRouter = require("./routes/pdf");<br/>app.use("/pdf", pdfRouter);</span></pre><h1 id="a012" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">前端</h1><p id="922b" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">既然后端已经完成，我们可以开始前端了。使用创建React应用程序创建React应用程序。我们在项目的根文件夹中运行<code class="fe mc md me mf b">npx create-react-app frontend</code>。</p><p id="b7ca" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后我们安装我们的软件包。我们将使用CKEditor作为富文本编辑器，Axios作为HTTP请求，Bootstrap作为样式，MobX作为简单的状态管理，React Router作为将URL路由到组件，Formik和Yup分别作为表单值处理和表单验证。</p><p id="ff84" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">运行<code class="fe mc md me mf b">npm i @ckeditor/ckeditor5-build-classic @ckeditor/ckeditor5-react axios bootstrap formik mobx mobx-react react-bootstrap react-router-dom yup</code>安装所有软件包。</p><p id="a700" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">安装好软件包后，我们就可以开始了。在<code class="fe mc md me mf b">App.js</code>中，我们将现有代码替换为:</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="2596" class="mo la it mf b gy mp mq l mr ms">import React from "react";<br/>import HomePage from "./HomePage";<br/>import { Router, Route } from "react-router-dom";<br/>import { createBrowserHistory as createHistory } from "history";<br/>import TopBar from "./TopBar";<br/>import { DocumentStore } from "./store";<br/>import "./App.css";<br/>const history = createHistory();<br/>const documentStore = new DocumentStore();</span><span id="bef3" class="mo la it mf b gy mu mq l mr ms">function App() {<br/>  return (<br/>    &lt;div className="App"&gt;<br/>      &lt;Router history={history}&gt;<br/>        &lt;TopBar /&gt;<br/>        &lt;Route<br/>          path="/"<br/>          exact<br/>          component={props =&gt; (<br/>            &lt;HomePage {...props} documentStore={documentStore} /&gt;<br/>          )}<br/>        /&gt;<br/>      &lt;/Router&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span><span id="1d05" class="mo la it mf b gy mu mq l mr ms">export default App;</span></pre><p id="5a38" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这将我们的顶部酒吧和路线添加到主页。</p><p id="9378" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在<code class="fe mc md me mf b">App.css</code>中，我们将现有代码替换为:</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="3872" class="mo la it mf b gy mp mq l mr ms">.page {<br/>  padding: 20px;<br/>}</span><span id="3d8d" class="mo la it mf b gy mu mq l mr ms">.content-invalid-feedback {<br/>  width: 100%;<br/>  margin-top: 0.25rem;<br/>  font-size: 80%;<br/>  color: #dc3545;<br/>}</span><span id="9122" class="mo la it mf b gy mu mq l mr ms">nav.navbar {<br/>  background-color: green !important;<br/>}</span></pre><p id="feab" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这为我们的页面添加了一些填充，为富文本编辑器设计了验证消息的样式，并改变了<code class="fe mc md me mf b">navbar</code>的颜色。</p><p id="5997" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们创建用于添加和编辑文档的表单。在<code class="fe mc md me mf b">src</code>文件中创建一个<code class="fe mc md me mf b">DocumentForm.js</code>并添加:</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="e5f3" class="mo la it mf b gy mp mq l mr ms">import React from "react";<br/>import * as yup from "yup";<br/>import Form from "react-bootstrap/Form";<br/>import Col from "react-bootstrap/Col";<br/>import Button from "react-bootstrap/Button";<br/>import { observer } from "mobx-react";<br/>import { Formik, Field } from "formik";<br/>import { addDocument, editDocument, getDocuments, APIURL } from "./request";<br/>import CKEditor from "<a class="ae mt" href="http://twitter.com/ckeditor/ckeditor5-react" rel="noopener ugc nofollow" target="_blank">@ckeditor/ckeditor5-react</a>";<br/>import ClassicEditor from "<a class="ae mt" href="http://twitter.com/ckeditor/ckeditor5-build-classic" rel="noopener ugc nofollow" target="_blank">@ckeditor/ckeditor5-build-classic</a>";</span><span id="c6e5" class="mo la it mf b gy mu mq l mr ms">const schema = yup.object({<br/>  name: yup.string().required("Name is required")<br/>});</span><span id="2cc6" class="mo la it mf b gy mu mq l mr ms">function DocumentForm({ documentStore, edit, onSave, doc }) {<br/>  const [content, setContent] = React.useState("");<br/>  const [dirty, setDirty] = React.useState(false);</span><span id="090c" class="mo la it mf b gy mu mq l mr ms">  const handleSubmit = async evt =&gt; {<br/>    const isValid = await schema.validate(evt);<br/>    if (!isValid || !content) {<br/>      return;<br/>    }<br/>    const data = { ...evt, document: content };<br/>    if (!edit) {<br/>      await addDocument(data);<br/>    } else {<br/>      await editDocument(data);<br/>    }<br/>    getAllDocuments();<br/>  };</span><span id="3a20" class="mo la it mf b gy mu mq l mr ms">  const getAllDocuments = async () =&gt; {<br/>    const response = await getDocuments();<br/>    documentStore.setDocuments(response.data);<br/>    onSave();<br/>  };</span><span id="5785" class="mo la it mf b gy mu mq l mr ms">  return (<br/>    &lt;&gt;<br/>      &lt;Formik<br/>        validationSchema={schema}<br/>        onSubmit={handleSubmit}<br/>        initialValues={edit ? doc : {}}<br/>      &gt;<br/>        {({<br/>          handleSubmit,<br/>          handleChange,<br/>          handleBlur,<br/>          values,<br/>          touched,<br/>          isInvalid,<br/>          errors<br/>        }) =&gt; (<br/>          &lt;Form noValidate onSubmit={handleSubmit}&gt;<br/>            &lt;Form.Row&gt;<br/>              &lt;Form.Group as={Col} md="12" controlId="name"&gt;<br/>                &lt;Form.Label&gt;Name&lt;/Form.Label&gt;<br/>                &lt;Form.Control<br/>                  type="text"<br/>                  name="name"<br/>                  placeholder="Name"<br/>                  value={values.name || ""}<br/>                  onChange={handleChange}<br/>                  isInvalid={touched.name &amp;&amp; errors.name}<br/>                /&gt;<br/>                &lt;Form.Control.Feedback type="invalid"&gt;<br/>                  {errors.name}<br/>                &lt;/Form.Control.Feedback&gt;<br/>              &lt;/Form.Group&gt;<br/>            &lt;/Form.Row&gt;</span><span id="19fb" class="mo la it mf b gy mu mq l mr ms">            &lt;Form.Row&gt;<br/>              &lt;Form.Group as={Col} md="12" controlId="content"&gt;<br/>                &lt;Form.Label&gt;Content&lt;/Form.Label&gt;<br/>                &lt;CKEditor<br/>                  editor={ClassicEditor}<br/>                  data={content || ""}<br/>                  onInit={editor =&gt; {<br/>                    if (edit) {<br/>                      setContent(doc.document);<br/>                    }<br/>                  }}<br/>                  onChange={(event, editor) =&gt; {<br/>                    const data = editor.getData();<br/>                    setContent(data);<br/>                    setDirty(true);<br/>                  }}<br/>                  config={{<br/>                    ckfinder: {<br/>                      uploadUrl:<br/>                        `${APIURL}/pdf/uploadImage`<br/>                    }<br/>                  }}<br/>                /&gt;<br/>                &lt;div className="content-invalid-feedback"&gt;<br/>                  {dirty &amp;&amp; !content ? "Content is required" : null}<br/>                &lt;/div&gt;<br/>              &lt;/Form.Group&gt;<br/>            &lt;/Form.Row&gt;</span><span id="c3fb" class="mo la it mf b gy mu mq l mr ms">            &lt;Button type="submit" style={{ marginRight: 10 }}&gt;<br/>              Save<br/>            &lt;/Button&gt;<br/>            &lt;Button type="button"&gt;Cancel&lt;/Button&gt;<br/>          &lt;/Form&gt;<br/>        )}<br/>      &lt;/Formik&gt;<br/>    &lt;/&gt;<br/>  );<br/>}</span><span id="9288" class="mo la it mf b gy mu mq l mr ms">export default observer(DocumentForm);</span></pre><p id="aa83" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将React引导程序<code class="fe mc md me mf b">Form</code>包装在<code class="fe mc md me mf b">Formik</code>组件中，以从Formik获取表单处理函数，我们直接在React引导程序表单字段中使用该函数。</p><p id="fa89" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们不能用CKEditor做同样的事情，所以我们为富文本编辑器编写自己的表单处理程序。我们在<code class="fe mc md me mf b">CKEditor</code>中设置<code class="fe mc md me mf b">data</code>属性来设置富文本编辑器的输入值。当用户试图编辑现有文档时，使用<code class="fe mc md me mf b">onInit</code>函数，因为我们必须通过运行<code class="fe mc md me mf b">setContent(doc.document);</code>来设置编辑器初始化的<code class="fe mc md me mf b">data</code>属性。<code class="fe mc md me mf b">onChange</code>属性是每当更新时设置<code class="fe mc md me mf b">content</code>的处理函数，因此<code class="fe mc md me mf b">data</code>属性将具有最新的值，当用户单击保存时我们将提交该值。</p><p id="a3af" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们使用CKFinder插件来上传图片。为了使它工作，我们将图片上传URL设置为后端上传路径的URL。</p><p id="b715" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">表单验证模式由我们在代码顶部创建的Yup <code class="fe mc md me mf b">schema</code>对象提供。我们检查<code class="fe mc md me mf b">name</code>字段是否存在。</p><p id="18d2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe mc md me mf b">handleSubmit</code>功能是向后端提交数据。我们检查<code class="fe mc md me mf b">content</code>和<code class="fe mc md me mf b">evt</code>对象以查看两个字段是否都存在，因为我们不能将Formik表单处理程序直接合并到<code class="fe mc md me mf b">CKEditor</code>组件中。</p><p id="e3f8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果一切都有效，那么我们根据<code class="fe mc md me mf b">edit</code>属性是否为<code class="fe mc md me mf b">true</code>来添加新文档或更新文档。</p><p id="5c21" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当保存成功时，我们调用<code class="fe mc md me mf b">getAllDocuments</code>，通过运行<code class="fe mc md me mf b">documentStore.setDocuments(response.data);</code>将最新的文档填充到我们的MobX存储中。</p><p id="7a73" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们通过在<code class="fe mc md me mf b">src</code>文件夹中创建<code class="fe mc md me mf b">HomePage.js</code>来构建我们的主页，并添加:</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="5628" class="mo la it mf b gy mp mq l mr ms">import React, { useState, useEffect } from "react";<br/>import { withRouter } from "react-router-dom";<br/>import DocumentForm from "./DocumentForm";<br/>import Modal from "react-bootstrap/Modal";<br/>import ButtonToolbar from "react-bootstrap/ButtonToolbar";<br/>import Button from "react-bootstrap/Button";<br/>import Table from "react-bootstrap/Table";<br/>import { observer } from "mobx-react";<br/>import { getDocuments, deleteDocument, generatePDF, APIURL } from "./request";</span><span id="8174" class="mo la it mf b gy mu mq l mr ms">function HomePage({ documentStore, history }) {<br/>  const [openAddModal, setOpenAddModal] = useState(false);<br/>  const [openEditModal, setOpenEditModal] = useState(false);<br/>  const [initialized, setInitialized] = useState(false);<br/>  const [doc, setDoc] = useState([]);</span><span id="aeea" class="mo la it mf b gy mu mq l mr ms">  const openAddTemplateModal = () =&gt; {<br/>    setOpenAddModal(true);<br/>  };</span><span id="e98a" class="mo la it mf b gy mu mq l mr ms">  const closeAddModal = () =&gt; {<br/>    setOpenAddModal(false);<br/>    setOpenEditModal(false);<br/>  };</span><span id="3d28" class="mo la it mf b gy mu mq l mr ms">  const cancelAddModal = () =&gt; {<br/>    setOpenAddModal(false);<br/>  };</span><span id="b625" class="mo la it mf b gy mu mq l mr ms">  const cancelEditModal = () =&gt; {<br/>    setOpenEditModal(false);<br/>  };</span><span id="7f13" class="mo la it mf b gy mu mq l mr ms">  const getAllDocuments = async () =&gt; {<br/>    const response = await getDocuments();<br/>    documentStore.setDocuments(response.data);<br/>    setInitialized(true);<br/>  };</span><span id="babb" class="mo la it mf b gy mu mq l mr ms">  const editTemplate = d =&gt; {<br/>    setDoc(d);<br/>    setOpenEditModal(true);<br/>  };</span><span id="6d7f" class="mo la it mf b gy mu mq l mr ms">  const onSave = () =&gt; {<br/>    cancelAddModal();<br/>    cancelEditModal();<br/>  };</span><span id="feea" class="mo la it mf b gy mu mq l mr ms">  const deleteSingleDocument = async id =&gt; {<br/>    await deleteDocument(id);<br/>    getAllDocuments();<br/>  };</span><span id="991f" class="mo la it mf b gy mu mq l mr ms">  const generateSinglePdf = async id =&gt; {<br/>    await generatePDF(id);<br/>    alert("PDF Generated");<br/>    getAllDocuments();<br/>  };</span><span id="76bb" class="mo la it mf b gy mu mq l mr ms">  useEffect(() =&gt; {<br/>    if (!initialized) {<br/>      getAllDocuments();<br/>    }<br/>  });</span><span id="1b28" class="mo la it mf b gy mu mq l mr ms">  return (<br/>    &lt;div className="page"&gt;<br/>      &lt;h1 className="text-center"&gt;Documents&lt;/h1&gt;<br/>      &lt;ButtonToolbar onClick={openAddTemplateModal}&gt;<br/>        &lt;Button variant="primary"&gt;Add Document&lt;/Button&gt;<br/>      &lt;/ButtonToolbar&gt;</span><span id="6638" class="mo la it mf b gy mu mq l mr ms">      &lt;Modal show={openAddModal} onHide={closeAddModal}&gt;<br/>        &lt;Modal.Header closeButton&gt;<br/>          &lt;Modal.Title&gt;Add Document&lt;/Modal.Title&gt;<br/>        &lt;/Modal.Header&gt;<br/>        &lt;Modal.Body&gt;<br/>          &lt;DocumentForm<br/>            onSave={onSave.bind(this)}<br/>            cancelModal={cancelAddModal.bind(this)}<br/>            documentStore={documentStore}<br/>          /&gt;<br/>        &lt;/Modal.Body&gt;<br/>      &lt;/Modal&gt;</span><span id="a9ec" class="mo la it mf b gy mu mq l mr ms">      &lt;Modal show={openEditModal} onHide={cancelEditModal}&gt;<br/>        &lt;Modal.Header closeButton&gt;<br/>          &lt;Modal.Title&gt;Edit Document&lt;/Modal.Title&gt;<br/>        &lt;/Modal.Header&gt;<br/>        &lt;Modal.Body&gt;<br/>          &lt;DocumentForm<br/>            edit={true}<br/>            doc={doc}<br/>            onSave={onSave.bind(this)}<br/>            cancelModal={cancelEditModal.bind(this)}<br/>            documentStore={documentStore}<br/>          /&gt;<br/>        &lt;/Modal.Body&gt;<br/>      &lt;/Modal&gt;<br/>      &lt;br /&gt;<br/>      &lt;Table striped bordered hover&gt;<br/>        &lt;thead&gt;<br/>          &lt;tr&gt;<br/>            &lt;th&gt;Name&lt;/th&gt;<br/>            &lt;th&gt;PDF&lt;/th&gt;<br/>            &lt;th&gt;Generate PDF&lt;/th&gt;<br/>            &lt;th&gt;Edit&lt;/th&gt;<br/>            &lt;th&gt;Delete&lt;/th&gt;<br/>          &lt;/tr&gt;<br/>        &lt;/thead&gt;<br/>        &lt;tbody&gt;<br/>          {documentStore.documents.map(d =&gt; {<br/>            return (<br/>              &lt;tr key={d.id}&gt;<br/>                &lt;td&gt;{d.name}&lt;/td&gt;<br/>                &lt;td&gt;<br/>                  &lt;a href={`${APIURL}/${d.pdfPath}`} target="_blank"&gt;<br/>                    Open<br/>                  &lt;/a&gt;<br/>                &lt;/td&gt;<br/>                &lt;td&gt;<br/>                  &lt;Button<br/>                    variant="outline-primary"<br/>                    onClick={generateSinglePdf.bind(this, d.id)}<br/>                  &gt;<br/>                    Generate PDF<br/>                  &lt;/Button&gt;<br/>                &lt;/td&gt;<br/>                &lt;td&gt;<br/>                  &lt;Button<br/>                    variant="outline-primary"<br/>                    onClick={editTemplate.bind(this, d)}<br/>                  &gt;<br/>                    Edit<br/>                  &lt;/Button&gt;<br/>                &lt;/td&gt;<br/>                &lt;td&gt;<br/>                  &lt;Button<br/>                    variant="outline-primary"<br/>                    onClick={deleteSingleDocument.bind(this, d.id)}<br/>                  &gt;<br/>                    Delete<br/>                  &lt;/Button&gt;<br/>                &lt;/td&gt;<br/>              &lt;/tr&gt;<br/>            );<br/>          })}<br/>        &lt;/tbody&gt;<br/>      &lt;/Table&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span><span id="fbdf" class="mo la it mf b gy mu mq l mr ms">export default withRouter(observer(HomePage));</span></pre><p id="658c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们有一个React引导表，用于列出带有编辑或删除文档按钮的文档，以及一个生成PDF的按钮。此外，每行都有一个打开PDF的ppen链接。我们有一个按钮在桌面上创建PDF。</p><p id="f1c6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当页面加载时，我们调用<code class="fe mc md me mf b">getAllDocuments</code>并在MobX存储中填充它们。我们用<code class="fe mc md me mf b">openAddTemplateModal</code>、<code class="fe mc md me mf b">closeAddModal</code>、<code class="fe mc md me mf b">cancelAddModal</code>、<code class="fe mc md me mf b">cancelEditModal</code>功能打开和关闭添加和编辑模式。</p><p id="695c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来在<code class="fe mc md me mf b">src</code>文件夹中创建<code class="fe mc md me mf b">request.js</code>并添加:</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="3707" class="mo la it mf b gy mp mq l mr ms">export const APIURL = "<a class="ae mt" href="http://localhost:3000" rel="noopener ugc nofollow" target="_blank">http://localhost:3000</a>";<br/>const axios = require("axios");</span><span id="3b75" class="mo la it mf b gy mu mq l mr ms">export const getDocuments = () =&gt; axios.get(`${APIURL}/pdf`);</span><span id="328d" class="mo la it mf b gy mu mq l mr ms">export const addDocument = data =&gt; axios.post(`${APIURL}/pdf`, data);</span><span id="7fdf" class="mo la it mf b gy mu mq l mr ms">export const editDocument = data =&gt; axios.put(`${APIURL}/pdf/${data.id}`, data);</span><span id="f0df" class="mo la it mf b gy mu mq l mr ms">export const deleteDocument = id =&gt; axios.delete(`${APIURL}/pdf/${id}`);</span><span id="d031" class="mo la it mf b gy mu mq l mr ms">export const generatePDF = id =&gt; axios.get(`${APIURL}/pdf/generatePdf/${id}`);</span></pre><p id="6258" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">添加在后端向我们的路由发出请求的功能。</p><p id="ac46" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后我们创建我们的MobX商店。在<code class="fe mc md me mf b">src</code>文件夹中创建<code class="fe mc md me mf b">store.js</code>，并将:</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="be46" class="mo la it mf b gy mp mq l mr ms">import { observable, action, decorate } from "mobx";</span><span id="0603" class="mo la it mf b gy mu mq l mr ms">class DocumentStore {<br/>  documents = [];</span><span id="4d2d" class="mo la it mf b gy mu mq l mr ms">setDocuments(documents) {<br/>    this.documents = documents;<br/>  }<br/>}</span><span id="1390" class="mo la it mf b gy mu mq l mr ms">DocumentStore = decorate(DocumentStore, {<br/>  documents: observable,<br/>  setDocuments: action<br/>});</span><span id="aa48" class="mo la it mf b gy mu mq l mr ms">export { DocumentStore };</span></pre><p id="374a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们有函数<code class="fe mc md me mf b">setDocuments</code>将照片数据放入商店，这是我们在<code class="fe mc md me mf b">HomePage</code>和<code class="fe mc md me mf b">DocumentForm</code>中使用的，我们在导出之前实例化了它，这样我们只需要在一个地方完成它。</p><p id="1b47" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">此区块:</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="4797" class="mo la it mf b gy mp mq l mr ms">DocumentStore = decorate(DocumentStore, {<br/>  documents: observable,<br/>  setDocuments: action<br/>});</span></pre><p id="ade2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">将<code class="fe mc md me mf b">DocumentStore</code>中的<code class="fe mc md me mf b">documents</code>数组指定为可由组件观察变化的实体。<code class="fe mc md me mf b">setDocuments</code>函数被指定为可用于设置存储器中的<code class="fe mc md me mf b">documents</code>数组的函数。</p><p id="4351" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们通过在<code class="fe mc md me mf b">src</code>文件夹中创建一个<code class="fe mc md me mf b">TopBar.js</code>文件来创建顶栏，并添加:</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="2a51" class="mo la it mf b gy mp mq l mr ms">import React from "react";<br/>import Navbar from "react-bootstrap/Navbar";<br/>import Nav from "react-bootstrap/Nav";<br/>import { withRouter } from "react-router-dom";</span><span id="012b" class="mo la it mf b gy mu mq l mr ms">function TopBar({ location }) {<br/>  return (<br/>    &lt;Navbar bg="primary" expand="lg" variant="dark"&gt;<br/>      &lt;Navbar.Brand href="#home"&gt;PDF App&lt;/Navbar.Brand&gt;<br/>      &lt;Navbar.Toggle aria-controls="basic-navbar-nav" /&gt;<br/>      &lt;Navbar.Collapse id="basic-navbar-nav"&gt;<br/>        &lt;Nav className="mr-auto"&gt;<br/>          &lt;Nav.Link href="/" active={location.pathname == "/"}&gt;<br/>            Home<br/>          &lt;/Nav.Link&gt;<br/>        &lt;/Nav&gt;<br/>      &lt;/Navbar.Collapse&gt;<br/>    &lt;/Navbar&gt;<br/>  );<br/>}</span><span id="e8a5" class="mo la it mf b gy mu mq l mr ms">export default withRouter(TopBar);</span></pre><p id="4189" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这包含了React引导程序<code class="fe mc md me mf b">Navbar</code>来显示一个带有主页链接和应用程序名称的顶栏。我们只显示本地存储器中的<code class="fe mc md me mf b">token</code>。我们检查<code class="fe mc md me mf b">pathname</code>，通过设置<code class="fe mc md me mf b">active</code>道具来突出显示正确的链接。</p><p id="c632" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来在<code class="fe mc md me mf b">index.html</code>中，我们将现有代码替换为:</p><pre class="mg mh mi mj gt mk mf ml mm aw mn bi"><span id="6a82" class="mo la it mf b gy mp mq l mr ms">&lt;!DOCTYPE html&gt;<br/>&lt;html lang="en"&gt;<br/>  &lt;head&gt;<br/>    &lt;meta charset="utf-8" /&gt;<br/>    &lt;link rel="shortcut icon" href="%PUBLIC_URL%/favicon.ico" /&gt;<br/>    &lt;meta name="viewport" content="width=device-width, initial-scale=1" /&gt;<br/>    &lt;meta name="theme-color" content="#000000" /&gt;<br/>    &lt;meta<br/>      name="description"<br/>      content="Web site created using create-react-app"<br/>    /&gt;<br/>    &lt;link rel="apple-touch-icon" href="logo192.png" /&gt;<br/>    &lt;!--<br/>      manifest.json provides metadata used when your web app is installed on a<br/>      user's mobile device or desktop. See <a class="ae mt" href="https://developers.google.com/web/fundamentals/web-app-manifest/" rel="noopener ugc nofollow" target="_blank">https://developers.google.com/web/fundamentals/web-app-manifest/</a><br/>    --&gt;<br/>    &lt;link rel="manifest" href="%PUBLIC_URL%/manifest.json" /&gt;<br/>    &lt;!--<br/>      Notice the use of %PUBLIC_URL% in the tags above.<br/>      It will be replaced with the URL of the `public` folder during the build.<br/>      Only files inside the `public` folder can be referenced from the HTML.</span><span id="7e7a" class="mo la it mf b gy mu mq l mr ms">Unlike "/favicon.ico" or "favicon.ico", "%PUBLIC_URL%/favicon.ico" will<br/>      work correctly both with client-side routing and a non-root public URL.<br/>      Learn how to configure a non-root public URL by running `npm run build`.<br/>    --&gt;<br/>    &lt;title&gt;PDF App&lt;/title&gt;<br/>    &lt;link<br/>      rel="stylesheet"<br/>      href="<a class="ae mt" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" rel="noopener ugc nofollow" target="_blank">https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css</a>"<br/>      integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T"<br/>      crossorigin="anonymous"<br/>    /&gt;<br/>  &lt;/head&gt;<br/>  &lt;body&gt;<br/>    &lt;noscript&gt;You need to enable JavaScript to run this app.&lt;/noscript&gt;<br/>    &lt;div id="root"&gt;&lt;/div&gt;<br/>    &lt;!--<br/>      This HTML file is a template.<br/>      If you open it directly in the browser, you will see an empty page.</span><span id="68cf" class="mo la it mf b gy mu mq l mr ms">You can add webfonts, meta tags, or analytics to this file.<br/>      The build step will place the bundled scripts into the &lt;body&gt; tag.</span><span id="5de9" class="mo la it mf b gy mu mq l mr ms">To begin the development, run `npm start` or `yarn start`.<br/>      To create a production bundle, use `npm run build` or `yarn build`.<br/>    --&gt;<br/>  &lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="d4be" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这增加了引导CSS并改变了标题。</p><p id="e0e5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">写完所有代码后，我们就可以运行我们的应用程序了。在运行任何东西之前，通过运行<code class="fe mc md me mf b">npm i -g nodemon</code>来安装<code class="fe mc md me mf b">nodemon</code>，这样当文件改变时，我们就不必自己重启后端了。</p><p id="d085" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后通过运行<code class="fe mc md me mf b">backend</code>文件夹中的<code class="fe mc md me mf b">npm start</code>和<code class="fe mc md me mf b">frontend</code>文件夹中的<code class="fe mc md me mf b">npm start</code>来启动后端，如果要求您从不同的端口运行它，请选择“是”。</p><p id="d229" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后你会得到:</p><figure class="mg mh mi mj gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mv"><img src="../Images/9d3939c0abb023f3445773a0ab53af29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kcfYaQZbC7ucXwsyodsUrQ.png"/></div></div></figure><figure class="mg mh mi mj gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mw"><img src="../Images/0c7fc5c115edb2969a0b2faa4a336345.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0eDnFer9Y5vVquyyLCrZ5w.png"/></div></div></figure><figure class="mg mh mi mj gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mv"><img src="../Images/bddb22b9c9344a37784523ae112b237d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KK7YXgjorOR0zxo3ByGLpA.png"/></div></div></figure><figure class="mg mh mi mj gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mv"><img src="../Images/03bf2bdd3c3fac5892cc8dce659218c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OFTlwcNMyHP3oqEFvXiI4w.png"/></div></div></figure></div></div>    
</body>
</html>