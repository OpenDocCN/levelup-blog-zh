<html>
<head>
<title>Testing Legacy Troubles</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">测试遗留问题</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/testing-legacy-troubles-7f3aedf2db17?source=collection_archive---------1-----------------------#2022-02-06">https://levelup.gitconnected.com/testing-legacy-troubles-7f3aedf2db17?source=collection_archive---------1-----------------------#2022-02-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><blockquote class="jn"><p id="3d38" class="jo jp iq bd jq jr js jt ju jv jw jx dk translated">如果你遵循Michael Feathers对遗留代码的定义(每一个没有被测试覆盖的代码)，那么处理一些需要更新的遗留代码的第一步就是把它放入测试工具中(为它写一个测试)。但这往往说起来容易做起来难。由于处理依赖关系的方式，在测试中实例化一个(遗留)类可能会非常困难。</p></blockquote><p id="a7d5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku jx ij bi translated">让我们来看看两个最常见的问题，以及我们如何解决它们。</p><h1 id="5b9d" class="kv kw iq bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">刺激性参数的情况</h1><p id="1308" class="pw-post-body-paragraph jy jz iq ka b kb lt kd ke kf lu kh ki kj lv kl km kn lw kp kq kr lx kt ku jx ij bi translated">假设我们正在构建一个网店应用程序。为了计算产品价格，我们需要应用一些业务逻辑(折扣、凭证……)并将增值税(税款)考虑在内，增值税由一些外部服务提供:</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="28db" class="mh kw iq md b gy mi mj l mk ml">class <strong class="md ir">CalculatePrice</strong><br/>{<br/>	public function <strong class="md ir">__construct</strong>(private VatDotComClient $vatProvider)<br/>	{<br/>	}<br/><br/>	public function <strong class="md ir">calculate</strong>(Product $product)<br/>	{<br/>		$taxRate = $this-&gt;vatProvider-&gt;getRate($product-&gt;countryCode());<br/>		// some business logic to calculate price<br/>	}<br/>}</span></pre><p id="55a1" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku jx ij bi translated">为了在测试中实例化我们的<code class="fe mr ms mt md b">CalculatePrice</code>服务，我们编写:</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="f74e" class="mh kw iq md b gy mi mj l mk ml">public function <strong class="md ir">itAppliesTheTaxRate</strong>()<br/>{<br/>	$calculateTax = new <strong class="md ir">CalculatePrice</strong>(<br/>		new <strong class="md ir">VatDotComClient</strong>('api-key', 'secret')<br/>	);<br/>        // ...<br/>}</span></pre><p id="1361" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku jx ij bi translated">你能发现这里的问题吗？我们想要测试的是我们服务中的业务逻辑——考虑到增值税率(无论可能是什么),它是否计算出正确的价格。但是每次我们运行这个测试时<code class="fe mr ms mt md b">VatDotComClient</code>都会对提供者进行HTTP调用。这使得我们的测试很慢(并且依赖于提供者)。</p><p id="6917" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku jx ij bi translated">不要误解我的意思，通过一个(集成)测试来确认我们的<code class="fe mr ms mt md b">VatDotComClient</code>可以与提供者对话是没有错的，但是我们不需要每次在我们的领域中测试一些业务逻辑时都测试那个集成。</p><p id="7df5" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku jx ij bi translated">如果我们创建一些虚拟的VAT客户端，返回一些我们控制的数据(而不是通过网络与一些真实的提供商交谈)，会怎么样呢？然后，我们可以在测试中使用虚拟提供者，在产品代码中使用真实的提供者。听起来不错，但我们的服务依赖于(真实的)<code class="fe mr ms mt md b">VatDotComClient</code>。气人吧？</p><p id="bef8" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku jx ij bi translated">为了解决这个问题，我们可以应用<em class="mu">提取接口</em>重构。首先，我们创建一个接口(基于<code class="fe mr ms mt md b">VatDotComClient</code>):</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="6437" class="mh kw iq md b gy mi mj l mk ml">interface <strong class="md ir">VatProvider</strong><br/>{<br/>	public function <strong class="md ir">getRate</strong>(string $countryCode): float;<br/>}</span></pre><p id="5761" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku jx ij bi translated">然后我们让我们的<code class="fe mr ms mt md b">CalculatePrice</code>服务依赖于这个接口(而不是具体的实现)。</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="6935" class="mh kw iq md b gy mi mj l mk ml">class <strong class="md ir">CalculatePrice</strong><br/>{<br/>	public function <strong class="md ir">__construct</strong>(private VatProvider $vatProvider)<br/>	{<br/>	}<br/><br/>	public function <strong class="md ir">calculate</strong>(Product $product)<br/>	{<br/>		$taxRate = $this-&gt;vatProvider-&gt;getRate($product-&gt;countryCode());<br/>		// some business logic to calculate price<br/>	}<br/>}</span></pre><p id="7399" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku jx ij bi translated">现在我们现有的<code class="fe mr ms mt md b">VatDotComClient</code>是我们在生产中使用的<code class="fe mr ms mt md b">VatProvider</code>的实现，但是我们还将创建我们的虚拟实现:</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="eae1" class="mh kw iq md b gy mi mj l mk ml">class <strong class="md ir">TestProvider</strong> implements <strong class="md ir">VatProvider</strong><br/>{<br/>	public function <strong class="md ir">__construct</strong>(private float $rate)<br/>	{<br/>	}<br/><br/>	public function <strong class="md ir">getRate</strong>(string $countryCode)<br/>	{<br/>		return $this-&gt;rate;<br/>	}<br/>}</span></pre><p id="6e49" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku jx ij bi translated">我们可以在测试中使用:</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="c921" class="mh kw iq md b gy mi mj l mk ml">public function <strong class="md ir">itAppliesTheTaxRate</strong>()<br/>{<br/>	$calculateTax = new <strong class="md ir">CalculatePrice</strong>(<br/>		new <strong class="md ir">TestProvider</strong>(0.25)<br/>	);<br/><br/>	// ... Assert price what expected (with 0.25 tax rate)<br/>}</span></pre><p id="9351" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku jx ij bi translated">这个<code class="fe mr ms mt md b">TestProvider</code>的好处是它不会调用一些真实的基础设施(在本例中是HTTP调用)，我们还可以控制它返回的虚拟数据，所以我们可以在设置测试断言时考虑到这一点。</p><h1 id="7947" class="kv kw iq bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">隐藏依赖的情况</h1><p id="3c68" class="pw-post-body-paragraph jy jz iq ka b kb lt kd ke kf lu kh ki kj lv kl km kn lw kp kq kr lx kt ku jx ij bi translated">既然我们可以计算产品的价格，人们也在购买产品，我们还需要处理他们的付款。假设我们有这样的服务:</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="6911" class="mh kw iq md b gy mi mj l mk ml">class <strong class="md ir">ProcessPayment</strong><br/>{<br/>	public function <strong class="md ir">__construct</strong>()<br/>	{<br/>		// ...<br/>	}<br/><br/>	public function <strong class="md ir">process</strong>(Payment $payment)<br/>	{<br/>		// ...<br/>	}<br/>}</span></pre><p id="79f3" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku jx ij bi translated">根据其构造函数判断，该服务没有依赖关系，因此很容易在测试中实例化:</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="36e7" class="mh kw iq md b gy mi mj l mk ml">public function <strong class="md ir">itRecordsThePayment</strong>()<br/>{<br/>	$payment = new <strong class="md ir">Payment</strong>(340, 'EUR', 12);<br/><br/>	$processPayment = new <strong class="md ir">ProcessPayment</strong>();<br/>	$processpayments-&gt;process($payment);<br/>	<br/>	// ... Assert stuff<br/>}</span></pre><p id="c0ea" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku jx ij bi translated">我们写下了我们的断言，我们的测试通过了，这一切都很好…但是，等一下，用户突然抱怨他们收到了电子邮件确认他们从来没有支付！</p><p id="1e06" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku jx ij bi translated">嗯，在进一步检查我们的<code class="fe mr ms mt md b">ProcessPayment</code>服务后，我们看到它确实依赖于一个<code class="fe mr ms mt md b">Mailer</code>类，但是隐藏在构造函数中(或者在某个方法中),在所有业务逻辑之间的某个地方有一个对它的调用来发送电子邮件。</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="b523" class="mh kw iq md b gy mi mj l mk ml">class <strong class="md ir">ProcessPayment</strong><br/>{<br/>	public function <strong class="md ir">__construct</strong>()<br/>	{<br/>		// some code<br/>		$this-&gt;mailer = new <strong class="md ir">Mailer</strong>('api-key', 'secret');<br/>		// some code<br/>	}<br/><br/>	public function <strong class="md ir">process</strong>(Payment $payment)<br/>	{<br/>		// ...<br/>	<br/>		$this-&gt;mailer-&gt;send($payment-&gt;receiver(), new PaymentNotificationMessage($payment)):<br/>		<br/>	}<br/>}</span></pre><p id="95a7" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku jx ij bi translated">现在第一步是使隐式(隐藏的)依赖显式化。为此，我们应用了<em class="mu">参数化构造函数</em>重构<em class="mu"> : </em></p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="ab3a" class="mh kw iq md b gy mi mj l mk ml">class <strong class="md ir">ProcessPayment</strong><br/>{<br/>	public function <strong class="md ir">__construct</strong>(Mailer $mailer)<br/>	{<br/>		$this-&gt;mailer = $mailer;<br/>	}<br/><br/>	public function <strong class="md ir">process</strong>(Payment $payment)<br/>	{<br/>		// ...<br/>	}<br/>}</span></pre><p id="4efe" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku jx ij bi translated">现在，我们可以应用<em class="mu"> Extract Interface </em>步骤，并实现一些我们可以在测试中使用的虚拟邮件程序，这样我们就不会在ProcessPayment服务中测试业务逻辑时实际发送电子邮件(当然，我们仍然可以进行一些集成测试，看看我们真正的邮件程序服务是否可以实际发送电子邮件)。</p><h1 id="94b4" class="kv kw iq bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">测试和良好设计的协同作用</h1><p id="f6c0" class="pw-post-body-paragraph jy jz iq ka b kb lt kd ke kf lu kh ki kj lv kl km kn lw kp kq kr lx kt ku jx ij bi translated">如果你看看重构后的代码，你会发现它现在使用了一个众所周知的优秀设计原则— <a class="ae mv" href="https://en.wikipedia.org/wiki/Dependency_injection#:~:text=In%20software%20engineering%2C%20dependency%20injection,object%20is%20called%20a%20service.&amp;text=The%20service%20is%20made%20part%20of%20the%20client's%20state." rel="noopener ugc nofollow" target="_blank">依赖注入</a>。此外，我们的服务不再依赖于具体的实现，而是依赖于抽象(良好设计的另一个原则)。这允许我们交换这些具体的实现(<a class="ae mv" href="https://en.wikipedia.org/wiki/Strategy_pattern" rel="noopener ugc nofollow" target="_blank">策略</a>设计模式)。因此，现在不仅我们的代码更易测试，而且我们的设计也得到了改进。</p><p id="b279" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku jx ij bi translated">在可测试性和良好的设计之间有这种协同作用。设计良好的代码很容易编写测试，反之亦然。</p><p id="2cce" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku jx ij bi translated">这就是为什么在开发新代码时，您应该努力使用测试驱动开发。至于遗留问题，如果你需要更多关于处理遗留问题的指导，请查看Michael Feathers <strong class="ka ir"> <em class="mu">有效处理遗留代码</em> </strong> <a class="ae mv" href="https://www.goodreads.com/book/show/44919.Working_Effectively_with_Legacy_Code" rel="noopener ugc nofollow" target="_blank">一书</a>以获得更多的技巧和建议。</p><figure class="ly lz ma mb gt mx gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi mw"><img src="../Images/876d1f3c85d6a07031518736cc77e4c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:604/format:webp/1*enPNjxorLBkqL1JD8slIcw.jpeg"/></div></div></figure></div></div>    
</body>
</html>