<html>
<head>
<title>Software Design — Orthogonality</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">软件设计—正交性</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/software-design-orthogonality-7cd2d50267b6?source=collection_archive---------11-----------------------#2021-12-10">https://levelup.gitconnected.com/software-design-orthogonality-7cd2d50267b6?source=collection_archive---------11-----------------------#2021-12-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/5c7d37bc4a371eca81676510d5e596cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*xyeky8KiZiOvWAMArkTt2Q.png"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">功劳归于<a class="ae jy" href="https://www.instagram.com/maldonaut/" rel="noopener ugc nofollow" target="_blank"> <strong class="bd jz">马尔多瑙</strong> </a></figcaption></figure><blockquote class="ka kb kc"><p id="3d1b" class="kd ke kf kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">软件设计可能看起来棘手或复杂，它可能会远离你。幸运的是，随着多年软件开发的发展，设计干净、健壮的软件已经有了很好的原则和指南。</p><p id="f9f7" class="kd ke kf kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">其中一个原则是正交性，所以让我们看看这意味着什么，为什么它在软件开发和设计中如此重要。</p></blockquote></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h1 id="5af5" class="lj lk iq bd jz ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">什么是正交性？</h1><p id="b45a" class="pw-post-body-paragraph kd ke iq kg b kh mg kj kk kl mh kn ko mi mj kr ks mk ml kv kw mm mn kz la lb ij bi translated">正交性的起源来自数学！如果两条直线相交成直角，它们就是正交的。也可以用向量来解释——<em class="kf">两个向量若独立则正交</em>。<em class="kf"> ( </em> <a class="ae jy" href="https://en.wikipedia.org/wiki/Orthogonality" rel="noopener ugc nofollow" target="_blank"> <em class="kf">阅读更多</em> </a> <em class="kf"> ) </em></p><figure class="mp mq mr ms gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi mo"><img src="../Images/bbfb64806386b9f9920b7da51b9e55ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ipugzzv8p_KG2Jxq6I9FZA.png"/></div></div></figure><h1 id="b714" class="lj lk iq bd jz ll mx ln lo lp my lr ls lt mz lv lw lx na lz ma mb nb md me mf bi translated">但是…我们在写代码！</h1><p id="4b12" class="pw-post-body-paragraph kd ke iq kg b kh mg kj kk kl mh kn ko mi mj kr ks mk ml kv kw mm mn kz la lb ij bi translated">在软件开发中，我们使用正交性来定义软件组件之间的分离或独立性。用最简单的术语来说，这意味着<strong class="kg ir">改变A不会改变B </strong>。</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="a0fd" class="pw-post-body-paragraph kd ke iq kg b kh ki kj kk kl km kn ko mi kq kr ks mk ku kv kw mm ky kz la lb ij bi translated">虽然认为你的系统可以100%正交是幼稚的。这里的目标是在设计您的系统时遵循这一原则，以获得可能的最佳结果。</p><p id="4ce5" class="pw-post-body-paragraph kd ke iq kg b kh ki kj kk kl km kn ko mi kq kr ks mk ku kv kw mm ky kz la lb ij bi translated">一个简单的现实世界的例子是收音机，其中改变电台不改变音量，反之亦然。非正交系统是直升机，改变速度会影响方向。</p><blockquote class="ka kb kc"><p id="e71b" class="kd ke kf kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">为什么这很重要？</p></blockquote><p id="280e" class="pw-post-body-paragraph kd ke iq kg b kh ki kj kk kl km kn ko mi kq kr ks mk ku kv kw mm ky kz la lb ij bi translated">编写具有单一定义目的的自包含、独立的组件将使您能够构建一个更容易开发、测试、扩展和最小化错误风险的软件系统。</p><blockquote class="ka kb kc"><p id="f020" class="kd ke kf kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">一个原则是如何实现所有这些的？</p></blockquote><p id="a751" class="pw-post-body-paragraph kd ke iq kg b kh ki kj kk kl km kn ko mi kq kr ks mk ku kv kw mm ky kz la lb ij bi translated">想象一下，有一个数据库，每当您在前端接口上更改一个字段时，它都需要更改。听起来很可怕，对吧？这就是为什么分离软件组件很重要。这是一个简单而显而易见的例子，但是我们将在本文后面深入探讨更多在软件开发中可能被忽略的例子</p><h1 id="c9c5" class="lj lk iq bd jz ll mx ln lo lp my lr ls lt mz lv lw lx na lz ma mb nb md me mf bi translated">探索代码中的正交性</h1><p id="e783" class="pw-post-body-paragraph kd ke iq kg b kh mg kj kk kl mh kn ko mi mj kr ks mk ml kv kw mm mn kz la lb ij bi translated">为了理解代码中的正交性，我们将会看到一个<strong class="kg ir">非正交用户</strong>类和一个<strong class="kg ir">正交用户</strong>类。</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="ne nd l"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">NonOrthogonalUser.java</figcaption></figure><h2 id="c72c" class="nf lk iq bd jz ng nh dn lo ni nj dp ls mi nk nl lw mk nm nn ma mm no np me nq bi translated">是什么使得这不是正交的呢？</h2><ul class=""><li id="b905" class="nr ns iq kg b kh mg kl mh mi nt mk nu mm nv lb nw nx ny nz bi translated">作为Java中的一个普通对象类，它定义了一些属性和一个初始化它的构造函数。现在显然有一个突出的属性— <code class="fe oa ob oc od b">textFileStrings</code>。</li></ul><blockquote class="oe"><p id="21e4" class="of og iq bd oh oi oj ok ol om on lb dk translated">用户类正在处理一个它不应该负责的任务，导致它与<code class="fe oa ob oc od b">loadFile()</code>函数以及它返回的值紧密耦合。</p></blockquote><ul class=""><li id="902b" class="nr ns iq kg b kh oo kl op mi oq mk or mm os lb nw nx ny nz bi translated">对<code class="fe oa ob oc od b">loadFile()</code>函数或返回数据格式的更改将波及到<code class="fe oa ob oc od b">User</code>类，导致该类的修改。</li><li id="f4b2" class="nr ns iq kg b kh ot kl ou mi ov mk ow mm ox lb nw nx ny nz bi translated">将这个逻辑放在<code class="fe oa ob oc od b">User</code>类中可以防止它被单独重用。此外，知识和功能也不能分开测试。</li></ul></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="ne nd l"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">OrthogonalUser.java</figcaption></figure><h2 id="9207" class="nf lk iq bd jz ng nh dn lo ni nj dp ls mi nk nl lw mk nm nn ma mm no np me nq bi translated">是什么让这个正交？</h2><ul class=""><li id="086d" class="nr ns iq kg b kh mg kl mh mi nt mk nu mm nv lb nw nx ny nz bi translated">现在这个<code class="fe oa ob oc od b">User</code>类符合您通常所期望的。</li></ul><blockquote class="oe"><p id="0162" class="of og iq bd oh oi oj ok ol om on lb dk translated"><code class="fe oa ob oc od b">CustomerTextObjectReader</code>类包含解析文本文件的功能，专门用于执行这个单一的功能。</p></blockquote><ul class=""><li id="5274" class="nr ns iq kg b kh oo kl op mi oq mk or mm os lb nw nx ny nz bi translated">比方说，我们想修改加载数据的方式——使用数据库或从API获取数据，可以修改reader类来实现这一目的，而不会影响<code class="fe oa ob oc od b">User</code>类。</li><li id="d344" class="nr ns iq kg b kh ot kl ou mi ov mk ow mm ox lb nw nx ny nz bi translated">如果数据对象改变了，只有<code class="fe oa ob oc od b">CustomTextObject</code>和<code class="fe oa ob oc od b">CustomerTextObjectReader</code>类需要改变。</li><li id="855f" class="nr ns iq kg b kh ot kl ou mi ov mk ow mm ox lb nw nx ny nz bi translated">最后，为了真正说明这一点，可测试性也得到了提高——它可以单独测试，因为功能被很好地封装了。您可以使用模块或单元级测试来测试功能。例如，这些比集成测试更容易实现。</li></ul><h1 id="c11e" class="lj lk iq bd jz ll mx ln lo lp my lr ls lt mz lv lw lx na lz ma mb nb md me mf bi translated">正交性的好处</h1><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="oy nd l"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated"><a class="ae jy" href="https://giphy.com/johnbcrist/" rel="noopener ugc nofollow" target="_blank">演职员表<strong class="ak">约翰·克里斯喜剧</strong>演职员表</a></figcaption></figure><h2 id="970a" class="nf lk iq bd jz ng nh dn lo ni nj dp ls mi nk nl lw mk nm nn ma mm no np me nq bi translated">生产力</h2><p id="daa2" class="pw-post-body-paragraph kd ke iq kg b kh mg kj kk kl mh kn ko mi mj kr ks mk ml kv kw mm mn kz la lb ij bi translated">正交系统减少了编写测试甚至开发时间，因为组件是自包含的。我认为我们都可以欣赏为一个独立的组件编写测试，而不是担心所有不同的连接部分需要被合并以运行测试。</p><h2 id="9c07" class="nf lk iq bd jz ng nh dn lo ni nj dp ls mi nk nl lw mk nm nn ma mm no np me nq bi translated">复用性</h2><p id="054c" class="pw-post-body-paragraph kd ke iq kg b kh mg kj kk kl mh kn ko mi mj kr ks mk ml kv kw mm mn kz la lb ij bi translated">当我们开始设计正交系统时，每个组件都应该是独立的，有一个明确的目的。这促进了可重用性，因为当您将它们合并到多个位置时，您不必担心意外的副作用。</p><p id="30a5" class="pw-post-body-paragraph kd ke iq kg b kh ki kj kk kl km kn ko mi kq kr ks mk ku kv kw mm ky kz la lb ij bi translated">组件可以为了不同的目的而被重新配置和重新设计，即使不是组件的作者最初设想的。</p><h2 id="9a57" class="nf lk iq bd jz ng nh dn lo ni nj dp ls mi nk nl lw mk nm nn ma mm no np me nq bi translated">测试和最小化风险</h2><p id="8a62" class="pw-post-body-paragraph kd ke iq kg b kh mg kj kk kl mh kn ko mi mj kr ks mk ml kv kw mm mn kz la lb ij bi translated">正交系统的测试要简单得多，它们通常在模块或单元级进行。如上所述，这比集成测试更可取，在集成测试中，您需要担心设置多个其他组件来测试一个<code class="fe oa ob oc od b">Reader</code>类的简单功能。</p><p id="6318" class="pw-post-body-paragraph kd ke iq kg b kh ki kj kk kl km kn ko mi kq kr ks mk ku kv kw mm ky kz la lb ij bi translated">当系统的一部分出现故障时，它将被控制住。它们可以被视为“患病”模块，应该用正交方法隔离，这样它就不会扩散。</p><p id="299a" class="pw-post-body-paragraph kd ke iq kg b kh ki kj kk kl km kn ko mi kq kr ks mk ku kv kw mm ky kz la lb ij bi translated">此外，由于组件的隔离，调试和修复错误变得更简单，错误将被本地化，比在高度耦合的系统中更容易定位。</p><p id="24c0" class="pw-post-body-paragraph kd ke iq kg b kh ki kj kk kl km kn ko mi kq kr ks mk ku kv kw mm ky kz la lb ij bi translated">如果真的是正交的，那么与外部供应商通信的接口应该可以被多个供应商重用，以避免供应商锁定。</p><h1 id="89c0" class="lj lk iq bd jz ll mx ln lo lp my lr ls lt mz lv lw lx na lz ma mb nb md me mf bi translated">设计正交系统</h1><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="oz nd l"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated"><a class="ae jy" href="https://giphy.com/chrisgannon" rel="noopener ugc nofollow" target="_blank">演职员表<strong class="ak">克里斯</strong>甘农</a></figcaption></figure><p id="bb13" class="pw-post-body-paragraph kd ke iq kg b kh ki kj kk kl km kn ko mi kq kr ks mk ku kv kw mm ky kz la lb ij bi translated">至此，您可能已经了解了设计正交系统的要点……我保证，我们就快完成了！以下是设计系统时需要记住的一些最终想法。</p><ul class=""><li id="0582" class="nr ns iq kg b kh ki kl km mi pa mk pb mm pc lb nw nx ny nz bi translated">正交系统包含一组协作模块。每个模块服务于一个目的，并且独立于其他模块实现该功能。</li><li id="22ad" class="nr ns iq kg b kh ot kl ou mi ov mk ow mm ox lb nw nx ny nz bi translated">抽象是正交系统的关键组成部分。抽象层只使用下面一层提供的抽象，这允许在不影响其他代码的情况下更灵活地改变底层实现。</li><li id="a0a1" class="nr ns iq kg b kh ot kl ou mi ov mk ow mm ox lb nw nx ny nz bi translated">第三方库可以极大地简化您的工作量，但是要小心，它不会对您的代码强加不应该有的更改。如前所述，将这些从代码中分离出来有助于避免供应商锁定。<strong class="kg ir">不要依赖你无法控制的东西的属性。</strong></li></ul><blockquote class="oe"><p id="126b" class="of og iq bd oh oi oj ok ol om on lb dk translated">如果你戏剧性地改变了特定功能背后的需求，有多少模块会受到影响？答案应该是1。</p><p id="c29f" class="of og iq bd oh oi pd pe pf pg ph lb dk translated">—务实的程序员</p></blockquote></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><p id="4c22" class="pw-post-body-paragraph kd ke iq kg b kh ki kj kk kl km kn ko mi kq kr ks mk ku kv kw mm ky kz la lb ij bi translated">我希望你在阅读这篇文章的时候发现了一些有价值的信息。如果你想深入了解这个原则，我在下面列出了一些相关的主题。为建立更好的系统干杯！🍻</p><h2 id="b76a" class="nf lk iq bd jz ng nh dn lo ni nj dp ls mi nk nl lw mk nm nn ma mm no np me nq bi translated">干燥原理</h2><ul class=""><li id="6ebe" class="nr ns iq kg b kh mg kl mh mi nt mk nu mm nv lb nw nx ny nz bi translated">不要重复你自己</li></ul><h2 id="4d8a" class="nf lk iq bd jz ng nh dn lo ni nj dp ls mi nk nl lw mk nm nn ma mm no np me nq bi translated">害羞原则</h2><ul class=""><li id="99ac" class="nr ns iq kg b kh mg kl mh mi nt mk nu mm nv lb nw nx ny nz bi translated">不要向别人暴露你自己</li><li id="dd52" class="nr ns iq kg b kh ot kl ou mi ov mk ow mm ox lb nw nx ny nz bi translated">不向他人透露任何不必要的东西，并且不依赖他人实现的模块</li></ul><h2 id="9e95" class="nf lk iq bd jz ng nh dn lo ni nj dp ls mi nk nl lw mk nm nn ma mm no np me nq bi translated">德米特里定律</h2><ul class=""><li id="9d5e" class="nr ns iq kg b kh mg kl mh mi nt mk nu mm nv lb nw nx ny nz bi translated">Demeter法则规定，一个模块不应该知道它所操作的对象的内部细节。换句话说，软件组件或对象不应该知道其他对象或组件的内部工作原理。</li></ul></div></div>    
</body>
</html>