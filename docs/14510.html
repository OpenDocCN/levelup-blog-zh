<html>
<head>
<title>Delegates Part 4: Lambda Expressions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">委托第4部分:Lambda表达式</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/delegates-part-4-lambda-expressions-98aaa4f0bfb6?source=collection_archive---------5-----------------------#2022-12-03">https://levelup.gitconnected.com/delegates-part-4-lambda-expressions-98aaa4f0bfb6?source=collection_archive---------5-----------------------#2022-12-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/689a681865457d75835b4b4366f480a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HpkkTcmLsXJaS_FLJ5uGNQ.png"/></div></div></figure><div class=""/><p id="0906" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用<em class="kz"> Lambda表达式</em>是将一个方法转换成一行代码的好方法。让我们使用我以前关于<em class="kz">委托</em>的文章中的一个方法示例，并将其转换为<em class="kz"> Lambda表达式</em>。</p></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><p id="91b2" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里我们有一个<em class="kz">返回</em>类型<em class="kz">功能</em>委托，它接受一个<em class="kz">字符串</em>值并输出一个<em class="kz"> int </em>值。</p><pre class="lh li lj lk gt ll lm ln bn lo lp bi"><span id="2e5d" class="lq lr je lm b be ls lt l lu lv">private Func&lt;string, int&gt; StringLength;</span></pre><p id="4e92" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="kz">字符串长度</em>委托变量被赋予<em class="kz">获取字符串长度</em>方法的值。然后向<em class="kz">控制台</em>发送一条消息，返回带有我的名字<em class="kz"> Jared </em>的给定<em class="kz">参数</em>的字符串的值。</p><pre class="lh li lj lk gt ll lm ln bn lo lp bi"><span id="a0fe" class="lq lr je lm b be ls lt l lu lv">StringLength = GetStringLength;<br/>Debug.Log("The string count is " + StringLength("Jared"));</span></pre><p id="9e34" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">该方法接受一个字符串<em class="kz">参数</em>并返回它的<em class="kz">长度</em>。</p><pre class="lh li lj lk gt ll lm ln bn lo lp bi"><span id="db6a" class="lq lr je lm b be ls lt l lu lv">private int GetStringLength(string text)<br/>{<br/>    return text.Length;<br/>}</span></pre></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><p id="03a3" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们通过将<em class="kz">字符串长度</em>变量赋给<em class="kz"> lambda </em>而不是<em class="kz">方法</em>来将其转换为<em class="kz"> lambda表达式</em>。我就<em class="kz">点评</em>出之前的作业，供参考。</p><p id="24ed" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">要声明一个<em class="kz"> lambda表达式</em>，首先要为委托提供<em class="kz">参数</em>。在本例中，它是一个<em class="kz">字符串</em>值。我将在这里使用变量名<em class="kz">文本</em>，因为这是我在原始方法中使用的。接下来，使用<em class="kz"> lambda运算符</em>，它是一个<em class="kz">等于</em> <em class="kz">符号</em>后跟一个<em class="kz">右尖括号</em> <strong class="kd jf"> = &gt; </strong>。<em class="kz">λ运算符</em>表示<em class="kz">“转到”</em>。然后我是<em class="kz">‘将要’</em>在<em class="kz">方法</em>、<em class="kz"> </em>中的命令，也就是<em class="kz">返回被传入的<em class="kz">字符串</em>的<em class="kz">长度</em>。</em></p><pre class="lh li lj lk gt ll lm ln bn lo lp bi"><span id="c474" class="lq lr je lm b be ls lt l lu lv">//StringLength = GetStringLength;<br/>StringLength = (text) =&gt; text.Length;<br/>Debug.Log("The string count is " + StringLength("Jared"));</span></pre><p id="fc2b" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我现在可以注释掉现有的<em class="kz">获取字符串长度</em>方法，因为<em class="kz"> lambda表达式</em>的<em class="kz">功能</em>将与<em class="kz">相同</em>。</p><pre class="lh li lj lk gt ll lm ln bn lo lp bi"><span id="00d8" class="lq lr je lm b be ls lt l lu lv">//private int GetStringLength(string text)<br/>//{<br/>    //return text.Length;<br/>//}</span></pre><p id="db80" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">此处<em class="kz">控制台</em>中<em class="kz"> Jared </em>的<em class="kz">串长</em>为<em class="kz"> 5 </em>。</p><figure class="lh li lj lk gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi lw"><img src="../Images/99987d3be0e8aafbce59bad24e23d112.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1M_FZzukuMV5jcCiEFprXw.png"/></div></div></figure></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><p id="17e1" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd jf">练习:</strong> <strong class="kd jf"> <em class="kz">用Lambda表达式代表</em> </strong></p><p id="e17a" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="kz">创建一个</em><strong class="kd jf"><em class="kz">void</em></strong><em class="kz">类型的委托，用</em> <strong class="kd jf"> <em class="kz">参数</em> </strong> <em class="kz">计算两个数之和。</em></p><p id="24ea" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里有一个<em class="kz">动作</em>委托，它接受两个<em class="kz">整数</em>值作为<em class="kz">参数</em>，以便计算总和。</p><pre class="lh li lj lk gt ll lm ln bn lo lp bi"><span id="90a4" class="lq lr je lm b be ls lt l lu lv">private Action&lt;int, int&gt; Sum;</span></pre><p id="dfec" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面是在将逻辑转换成lambda表达式之前，用来计算逻辑的方法。</p><pre class="lh li lj lk gt ll lm ln bn lo lp bi"><span id="5107" class="lq lr je lm b be ls lt l lu lv">private void CalculateSum(int a, int b)<br/>{<br/>    var SumTotal = a + b;<br/>    Debug.Log("The Calculated Sum is " + SumTotal);<br/>}</span></pre><p id="719e" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">将<em class="kz">求和动作</em>分配给<em class="kz">计算求和</em>方法，然后在下一行输入所需的<em class="kz">参数</em>值。</p><pre class="lh li lj lk gt ll lm ln bn lo lp bi"><span id="0ec1" class="lq lr je lm b be ls lt l lu lv">Sum = CalculateSum;<br/>if (Sum != null)<br/>    Sum(7, 7);</span></pre><p id="bf12" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">7和3的<em class="kz">值</em>相加，在<em class="kz">控制台</em>中显示为10。</p><figure class="lh li lj lk gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi lx"><img src="../Images/5855e86b8054f641082a012027b04984.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wySzTnTDg_c69QVFUMkXBA.png"/></div></div></figure><p id="adea" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">专用方法被注释掉，现在<em class="kz"> Sum动作委托</em>被转换为使用<em class="kz"> lambda表达式</em>。<em class="kz"> int </em>值更改为7和7，以产生不同的结果。</p><pre class="lh li lj lk gt ll lm ln bn lo lp bi"><span id="dfcf" class="lq lr je lm b be ls lt l lu lv">Sum = (a, b) =&gt; { var SumTotal = a + b; Debug.Log("The Calculated Sum is " + SumTotal); };<br/>if (Sum != null)<br/>    Sum(7, 7);</span></pre><p id="024a" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在控制台告诉我总数是14。</p><figure class="lh li lj lk gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ly"><img src="../Images/fd899b774c5a977ab9db975a4d3b9b47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dB1PcM2CaWDjox7saMHt4w.png"/></div></div></figure></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><p id="23e6" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="kz">创建一个</em><strong class="kd jf"><em class="kz">void</em></strong><em class="kz">类型的委托，用</em> <strong class="kd jf"> <em class="kz">无参数</em> </strong> <em class="kz">告知游戏对象的名称。</em></p><p id="4b9d" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里有一个新的<em class="kz">动作</em>委托，没有<em class="kz">参数</em>，它将打印脚本附加到的<em class="kz">游戏对象</em>的<em class="kz">名称</em>。</p><pre class="lh li lj lk gt ll lm ln bn lo lp bi"><span id="11b4" class="lq lr je lm b be ls lt l lu lv">private Action onGetObjectName;</span></pre><p id="fad4" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里有一个<em class="kz">方法</em>来打印<em class="kz">游戏对象</em>的<em class="kz">名称</em>。</p><pre class="lh li lj lk gt ll lm ln bn lo lp bi"><span id="08e3" class="lq lr je lm b be ls lt l lu lv">private void GetName()<br/>{<br/>    Debug.Log("This object name is " + this.gameObject.name);<br/>}</span></pre><p id="68ab" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="kz"> onGetObjectName </em>被分配给<em class="kz"> GetName </em>方法。要在没有参数的情况下运行它，只需像普通方法一样调用它的委托。</p><pre class="lh li lj lk gt ll lm ln bn lo lp bi"><span id="86f5" class="lq lr je lm b be ls lt l lu lv">onGetObjectName = GetName;<br/>if (onGetObjectName != null)<br/>    onGetObjectName();</span></pre><p id="0741" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里你可以看到这个脚本附加的对象叫做<em class="kz">代理管理器</em>。</p><figure class="lh li lj lk gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi lz"><img src="../Images/1382d898b2562f1f8f0cc71ecc506da2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0pjn-TObBMzPh1shHbagBA.png"/></div></div></figure><p id="3e94" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">该方法被移除并转换为使用一个<em class="kz">λ表达式</em>来代替。因为这个委托<em class="kz">没有参数</em>，方法<em class="kz">签名</em>用空的<em class="kz">括号声明。</em></p><pre class="lh li lj lk gt ll lm ln bn lo lp bi"><span id="a807" class="lq lr je lm b be ls lt l lu lv">onGetObjectName = () =&gt; Debug.Log("This object name is " + this.gameObject.name);<br/>if (onGetObjectName != null)<br/>    onGetObjectName();</span></pre><p id="231d" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">就像使用专用方法一样，对象的名称打印在控制台中。</p><figure class="lh li lj lk gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi lz"><img src="../Images/1382d898b2562f1f8f0cc71ecc506da2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0pjn-TObBMzPh1shHbagBA.png"/></div></div></figure></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><p id="416c" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="kz">创建一个</em> <strong class="kd jf"> <em class="kz">返回</em> </strong> <em class="kz">类型的委托用</em> <strong class="kd jf"> <em class="kz">无参数</em> </strong> <em class="kz">即计算一个游戏对象名称的长度。</em></p><p id="f553" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个例子类似于我返回我的名字Jared的长度的例子。唯一的区别是返回游戏对象名称的长度。</p><p id="7162" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于一个<em class="kz">返回</em>类型的委托，让我们带上<em class="kz"> Func </em>！因为它是一个返回类型，我们需要指定返回的值<em class="kz"> type </em>，在本例中是一个<em class="kz"> int </em>值。</p><pre class="lh li lj lk gt ll lm ln bn lo lp bi"><span id="c918" class="lq lr je lm b be ls lt l lu lv">private Func&lt;int&gt; onNameLength;</span></pre><p id="0e79" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面是返回这个脚本附加到的<em class="kz">对象</em>的<em class="kz">名称长度</em>的方法。</p><pre class="lh li lj lk gt ll lm ln bn lo lp bi"><span id="af80" class="lq lr je lm b be ls lt l lu lv">private int ReturnObjectNameLength()<br/>{<br/>    var count = this.gameObject.name.Length;<br/>    Debug.Log("character count is " + count);<br/>    return count;<br/>}</span></pre><p id="1fb1" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">委托<em class="kz">变量</em>被分配给<em class="kz">方法</em>并被<em class="kz">无参数</em>调用。</p><pre class="lh li lj lk gt ll lm ln bn lo lp bi"><span id="d10e" class="lq lr je lm b be ls lt l lu lv">onNameLength = ReturnObjectNameLength;<br/>if (onNameLength != null)<br/>    onNameLength();</span></pre><p id="4e2a" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">控制台告诉我字符数是15，代表<em class="kz"> DelegateManager </em>对象。</p><figure class="lh li lj lk gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ma"><img src="../Images/0ed33c8ce71887ce764c873e823c1940.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wZxZyQHXfBHyDnMZLT_Atw.png"/></div></div></figure><p id="653d" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在让我们移除专用方法，并将其转换为一个<em class="kz">λ表达式</em>。现在把名字的长度从这里发送到控制台。</p><pre class="lh li lj lk gt ll lm ln bn lo lp bi"><span id="0968" class="lq lr je lm b be ls lt l lu lv">onNameLength = () =&gt; this.gameObject.name.Length;<br/>if (onNameLength != null)<br/>{<br/>    int characterCount = onNameLength();<br/>    Debug.Log("The character count of this object is " + characterCount);<br/>}</span></pre><p id="81ce" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">同样，字符数是15。</p><figure class="lh li lj lk gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mb"><img src="../Images/ac51492d8c0beb1ba370884166c76ba1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6gASMhAmolG08tYHzO5vyA.png"/></div></div></figure></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><p id="e893" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="kz">创建一个</em> <strong class="kd jf"> <em class="kz">返回</em> </strong> <em class="kz">类型的委托，用</em> <strong class="kd jf"> <em class="kz">参数</em> </strong> <em class="kz">得出两个数之和。</em></p><p id="1065" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个例子与上一个计算两个数之和的例子相同，只是使用了一个<em class="kz"> return </em>类型的委托，而不是一个<em class="kz"> void </em>类型。</p><p id="753b" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里有一个<em class="kz">返回</em>类型的委托，它接受<em class="kz">两个int值</em>，而<em class="kz">返回</em>一个<em class="kz"> int值</em>。</p><pre class="lh li lj lk gt ll lm ln bn lo lp bi"><span id="959f" class="lq lr je lm b be ls lt l lu lv">private Func&lt;int, int, int&gt; onReturnSum;</span></pre><p id="2e5b" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里的<em class="kz">方法</em>接收两个值，并将它们相加。总和存储在<em class="kz">总变量</em>中，该变量被发送到<em class="kz">控制台</em>。</p><pre class="lh li lj lk gt ll lm ln bn lo lp bi"><span id="ab41" class="lq lr je lm b be ls lt l lu lv">private int ReturnSumValue(int a, int b)<br/>{<br/>    var total = a + b;<br/>    Debug.Log("The total Sum is " + total);<br/>    return a + b;<br/>}</span></pre><p id="1b11" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里输入12和3以满足<em class="kz">参数</em>。</p><pre class="lh li lj lk gt ll lm ln bn lo lp bi"><span id="3794" class="lq lr je lm b be ls lt l lu lv">onReturnSum = ReturnSumValue;<br/>if (onReturnSum != null)<br/>    onReturnSum(12, 3);</span></pre><p id="d93a" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">控制台告诉我这些数字的总和是15。</p><figure class="lh li lj lk gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi lz"><img src="../Images/7ba4c1533b28bd80a28ad2fec832a3ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SjCoArlPurnyNPn0dgtAQA.png"/></div></div></figure><p id="069b" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在让我们把它转换成一个λ表达式。</p><pre class="lh li lj lk gt ll lm ln bn lo lp bi"><span id="14da" class="lq lr je lm b be ls lt l lu lv">onReturnSum = (a, b) =&gt; a + b;<br/>if (onReturnSum != null)<br/>    Debug.Log("The total sum is " + onReturnSum(10, 3));</span></pre><p id="0505" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在有了10和3的新值，<em class="kz">控制台</em>告诉我<em class="kz">和</em>是13。注意，这样做时，你实际上不需要使用<em class="kz">返回</em>关键字，即使委托是一个<em class="kz">返回类型</em>。</p><figure class="lh li lj lk gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ly"><img src="../Images/256421f7cb86804ce9cf1e7f4d83896b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*56E3YAfy5W2SlGO-3-6UGg.png"/></div></div></figure><p id="29ed" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你想添加进一步的逻辑，你可以这样做，但是然后将需要使用<em class="kz">返回关键字</em>来返回一个<em class="kz">值</em>。</p><pre class="lh li lj lk gt ll lm ln bn lo lp bi"><span id="79eb" class="lq lr je lm b be ls lt l lu lv">onReturnSum = (a, b) =&gt; { var totalSum = a + b; Debug.Log("The total sum is " + totalSum); return totalSum; };<br/>if (onReturnSum != null)<br/>    onReturnSum(12, 10);</span></pre><p id="e961" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里12和10的值加在一起是22。</p><figure class="lh li lj lk gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ly"><img src="../Images/d77eee955dd5eacf0299fc7063d3999c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NqCzTVGYt5Dq4StPdjOgfg.png"/></div></div></figure><p id="bb65" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我希望喜欢这篇关于lambda表达式的文章，感谢阅读！</p></div></div>    
</body>
</html>