<html>
<head>
<title>JavaScript Best Practices — Better DOM, String, and Array Methods</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript最佳实践—更好的DOM、字符串和数组方法</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-best-practices-better-dom-string-and-array-methods-ae5c34e8bf14?source=collection_archive---------15-----------------------#2020-07-20">https://levelup.gitconnected.com/javascript-best-practices-better-dom-string-and-array-methods-ae5c34e8bf14?source=collection_archive---------15-----------------------#2020-07-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/f96d078caa03b545ae741117c5e4fc11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-elKsJ-cJddiDhZw"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@braintax?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">奥利·伍德曼</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="22b9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了使代码易于阅读和维护，我们应该遵循一些最佳实践。</p><p id="0f90" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这篇文章中，我们将看看我们应该遵循的一些最佳实践，以使每个人的生活更轻松。</p><h1 id="95bf" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">使用<code class="fe mc md me mf b">.flatMap(…)</code>超过<code class="fe mc md me mf b">.map(…).flat()</code></h1><p id="a989" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">我们一起使用<code class="fe mc md me mf b">flatMap</code>而不是<code class="fe mc md me mf b">map</code>和<code class="fe mc md me mf b">flat</code>，因为我们可以用<code class="fe mc md me mf b">flatMap</code>做两件事，</p><p id="3be2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，不要写:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="d12c" class="mt lf it mf b gy mu mv l mw mx">[1, 2, 3].map(i =&gt; [i]).flat();</span></pre><p id="b112" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们写道:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="0717" class="mt lf it mf b gy mu mv l mw mx">[1, 2, 3].flatMap(i =&gt; [i]);</span></pre><h1 id="32d3" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">在检查存在或不存在时，<code class="fe mc md me mf b">Use .includes()</code>而不是<code class="fe mc md me mf b">.indexOf()</code></h1><p id="ad3b" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">在检查存在或不存在时，<code class="fe mc md me mf b">includes</code>比<code class="fe mc md me mf b">indexOf</code>更好。</p><p id="1be1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mc md me mf b">includes</code>更短。</p><p id="76a4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以与其写:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="16f9" class="mt lf it mf b gy mu mv l mw mx">[].indexOf('foo') !== -1;</span></pre><p id="20e0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们写道:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="c514" class="mt lf it mf b gy mu mv l mw mx">[].includes('foo');</span></pre><h1 id="7319" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">使用现代DOM APIs</h1><p id="90b9" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">我们应该使用新的DOM方法，而不是旧的。</p><p id="a97a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，不写:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="c582" class="mt lf it mf b gy mu mv l mw mx">foo.replaceChild(baz, bar);<br/><br/>foo.insertBefore(baz, bar);<br/><br/>foo.insertAdjacentText('position', bar);<br/><br/>foo.insertAdjacentElement('position', bar);</span></pre><p id="e643" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们写道:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="9ac6" class="mt lf it mf b gy mu mv l mw mx">foo.replaceWith(bar);</span><span id="86a8" class="mt lf it mf b gy my mv l mw mx">foo.before(bar);</span><span id="4fe2" class="mt lf it mf b gy my mv l mw mx">foo.prepend(bar);</span><span id="ae59" class="mt lf it mf b gy my mv l mw mx">foo.append(bar);</span></pre><h1 id="2ec3" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">对切片和拼接使用超过<code class="fe mc md me mf b">.length - index</code>的负索引</h1><p id="c300" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated"><code class="fe mc md me mf b">slice</code>和<code class="fe mc md me mf b">splice</code>的负指标比<code class="fe mc md me mf b">length — index</code>短。</p><p id="424a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，不写:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="2727" class="mt lf it mf b gy mu mv l mw mx">foo.slice(foo.length - 3, foo.length - 1);<br/>foo.splice(foo.length - 1, 1);</span></pre><p id="442b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们写道:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="19e4" class="mt lf it mf b gy mu mv l mw mx">foo.slice(-3, -1);<br/>foo.splice(-1, 1);</span></pre><p id="bd3f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它对我们的大脑来说更短更容易。</p><h1 id="989d" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated"><code class="fe mc md me mf b">Use Node#append()</code>超过<code class="fe mc md me mf b">Node#appendChild()</code></h1><p id="e228" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">我们应该使用<code class="fe mc md me mf b">append</code>而不是<code class="fe mc md me mf b">appendChild</code>将元素追加到父元素中。</p><p id="b4fc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mc md me mf b">append</code>除了节点，我们还可以添加字符串。</p><p id="2271" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mc md me mf b">append</code>有节点返回值。</p><p id="e577" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以用它附加几个节点和字符串。</p><p id="63be" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，不写:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="ec9f" class="mt lf it mf b gy mu mv l mw mx">foo.appendChild(bar);</span></pre><p id="2f03" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们写道:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="4f52" class="mt lf it mf b gy mu mv l mw mx">foo.append(bar);<br/>foo.append(bar, 'baz');</span></pre><h1 id="3163" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">使用<code class="fe mc md me mf b">childNode.remove()</code>超过<code class="fe mc md me mf b">parentNode.removeChild(childNode)</code></h1><p id="21f6" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">我们可以使用<code class="fe mc md me mf b">remove</code>直接移除一个节点，而不是获取父节点并调用<code class="fe mc md me mf b">removeChild</code>来移除一个节点。</p><p id="9df5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，不写:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="cd66" class="mt lf it mf b gy mu mv l mw mx">parentNode.removeChild(foo);</span></pre><p id="0bcd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们写道:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="babb" class="mt lf it mf b gy mu mv l mw mx">foo.remove();</span></pre><h1 id="b476" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">在全局属性上使用静态属性</h1><p id="d611" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">数字静态特性优于全局特性。</p><p id="fdbd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mc md me mf b">Number.isNaN</code>和<code class="fe mc md me mf b">Number.isFinite</code>在检查之前不转换参数的类型。</p><p id="be9f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，不写:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="cb8b" class="mt lf it mf b gy mu mv l mw mx">const foo = parseInt('20', 2);<br/>const foo = parseFloat('30.5');<br/>const foo = isNaN(20);<br/>const foo = isFinite(20);<br/>if (Object.is(foo, NaN)) {}</span></pre><p id="2cef" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们写道:"</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="2ebb" class="mt lf it mf b gy mu mv l mw mx">const foo = Number.parseInt('20', 2);<br/>const foo = Number.parseFloat('30.5');<br/>const foo = Number.isNaN(20);<br/>const foo = Number.isFinite(20);<br/>if (Object.is(foo, Number.NaN)) {}</span></pre><h1 id="3c71" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">使用c <code class="fe mc md me mf b">atch</code>绑定参数</h1><p id="716f" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">如果没有使用<code class="fe mc md me mf b">catch</code>的绑定参数，那么应该省略它。</p><p id="8d11" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以与其写:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="af26" class="mt lf it mf b gy mu mv l mw mx">try {} catch (error) {}</span></pre><p id="249c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们写道:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="7a22" class="mt lf it mf b gy mu mv l mw mx">try {} catch {}</span></pre><h1 id="adca" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">在<code class="fe mc md me mf b">.getElementById()</code>上使用<code class="fe mc md me mf b">.querySelector()</code>，在<code class="fe mc md me mf b">.getElementsByClassName()</code>和<code class="fe mc md me mf b">.getElementsByTagName()</code>上使用<code class="fe mc md me mf b">.querySelectorAll()</code></h1><p id="230e" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated"><code class="fe mc md me mf b">querySelector</code>比<code class="fe mc md me mf b">getElementById</code>更通用，因为前者可以使用任何选择器。</p><p id="b38b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mc md me mf b">querySelectorAll</code>比<code class="fe mc md me mf b">getElementsByClassName</code>和<code class="fe mc md me mf b">getElementsByTagName</code>更通用，因为它采用任何选择器。</p><p id="8ae1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以与其写:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="85d4" class="mt lf it mf b gy mu mv l mw mx">document.getElementById('baz');<br/>document.getElementsByClassName('baz bar');<br/>document.getElementsByTagName('main');</span></pre><p id="a75f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们写道:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="afd5" class="mt lf it mf b gy mu mv l mw mx">document.querySelector('main #baz .bar');<br/>document.querySelectorAll('.baz .bar');</span></pre><h1 id="1fd3" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">使用<code class="fe mc md me mf b">Reflect.apply()</code>超过<code class="fe mc md me mf b">Function#apply()</code></h1><p id="0705" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated"><code class="fe mc md me mf b">Reflect.apply</code>比<code class="fe mc md me mf b">Function.apply</code>简短易懂。</p><p id="a5fe" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们知道它永远不会被覆盖，不像<code class="fe mc md me mf b">Function.apply</code>。</p><p id="4efc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以与其写:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="7f91" class="mt lf it mf b gy mu mv l mw mx">function foo() {}</span><span id="8c57" class="mt lf it mf b gy my mv l mw mx">foo.apply(null, [42]);</span></pre><p id="0787" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们写道:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="52a4" class="mt lf it mf b gy mu mv l mw mx">function foo() {}</span><span id="de60" class="mt lf it mf b gy my mv l mw mx">Reflect.apply(foo, null, [42]);</span></pre><h1 id="c7eb" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">在带有全局标志的正则表达式搜索中使用<code class="fe mc md me mf b">String#replaceAll()</code></h1><p id="6eae" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated"><code class="fe mc md me mf b">replaceAll</code>比正则表达式搜索替换子字符串更容易理解。</p><p id="04e0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，不写:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="53c6" class="mt lf it mf b gy mu mv l mw mx">string.replace(/foo/g, '');</span></pre><p id="8c9b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们写道:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="70a9" class="mt lf it mf b gy mu mv l mw mx">string.replaceAll('foo', '');</span></pre><h1 id="6302" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated"><code class="fe mc md me mf b">Use Set#has()</code>检查存在或不存在时越过<code class="fe mc md me mf b">Array#includes()</code></h1><p id="7e0d" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">我们可以用<code class="fe mc md me mf b">has</code>代替<code class="fe mc md me mf b">includes</code>来检查存在或不存在，因为它更快。</p><p id="c795" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，不写:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="91ad" class="mt lf it mf b gy mu mv l mw mx">const array = [1, 2, 3, 4, 5];<br/>const hasValue = value =&gt; array.includes(value);</span></pre><p id="b615" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们写道:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="8b08" class="mt lf it mf b gy mu mv l mw mx">const set = new Set([1, 2, 3, 4, 5]);<br/>const hasValue = value =&gt; set.has(value);</span></pre><h1 id="3e45" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">在<code class="fe mc md me mf b">Array.from()</code>上使用扩展运算符</h1><p id="d93e" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">我们应该在<code class="fe mc md me mf b">Array.from</code>上使用spread运算符。</p><p id="43d3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是将类似数组的对象转换为数组的一种更简单的方法。</p><p id="2b3b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，不写:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="c8cb" class="mt lf it mf b gy mu mv l mw mx">Array.from(set).filter(() =&gt; {});</span></pre><p id="e05f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们写道:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="ca66" class="mt lf it mf b gy mu mv l mw mx">[...set].filter(() =&gt; {});</span></pre><h1 id="11b5" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">使用<code class="fe mc md me mf b">String#startsWith()</code> &amp; <code class="fe mc md me mf b">String#endsWith()</code>检查字符串的开始和结束</h1><p id="6630" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">我们应该使用<code class="fe mc md me mf b">startsWith</code>或<code class="fe mc md me mf b">endsWith</code>来检查一个字符串是以给定的字符串开始还是结束。</p><p id="a3c3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，不写:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="2b7e" class="mt lf it mf b gy mu mv l mw mx">/^bar/.test(foo);<br/>/bar$/.test(foo);</span></pre><p id="d93c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们写道:</p><pre class="ml mm mn mo gt mp mf mq mr aw ms bi"><span id="7b57" class="mt lf it mf b gy mu mv l mw mx">foo.startsWith('bar');<br/>foo.endsWith('bar');</span></pre><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/2281f9101a3359d92c2e942d32f70420.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*oJNey-oidCJ6hkuy"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">扬·伊沃·亨策在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="3573" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="982a" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">我们应该使用现代的JavaScript方法来使我们的生活变得更容易。</p><p id="e798" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有许多字符串和数组方法使我们的生活变得更加容易。</p><p id="f2ee" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还应该注意新DOM方法，并使用它们来代替以前可用的方法。</p></div></div>    
</body>
</html>