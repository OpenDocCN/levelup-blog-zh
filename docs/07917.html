<html>
<head>
<title>Applying the Observer Pattern (Part 3)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">应用观察者模式(第3部分)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/applying-the-observer-pattern-part-3-e46ce30c2d32?source=collection_archive---------10-----------------------#2021-03-21">https://levelup.gitconnected.com/applying-the-observer-pattern-part-3-e46ce30c2d32?source=collection_archive---------10-----------------------#2021-03-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jn jo jp jq gh gi paragraph-image"><div class="ab gu cl jr"><img src="../Images/f56304e6a017e72d558bcf5f3e3cd1fe.png" data-original-src="https://miro.medium.com/v2/format:webp/0*55eLFcyH1xpMZ5Mf.png"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">礼貌:timeanddate.com</figcaption></figure><p id="c620" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">欢迎回到本系列的第三个教程。正如在前面的教程中所指出的，我们在秒表中有一个逻辑问题。为了查看秒表的时间，我们只是打印出时间，但在大多数应用程序中，我们不希望时间在控制台上打印出来，(事实上，现在没有应用程序有控制台)。我们希望秒表将时间异步返回给客户端，这样客户端就可以对时间做任何想做的事情。看起来是个不错的设计问题，对吧？</p><p id="65c9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kw">观察者模式来营救</em>。</p><h1 id="26ff" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">之前的教程</h1><p id="7c2b" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">如果您是第一次阅读这一部分，那么您一定要看看本系列的第2部分。</p><ul class=""><li id="e587" class="ma mb iq ka b kb kc kf kg kj mc kn md kr me kv mf mg mh mi bi translated"><a class="ae mj" href="https://github.com/rajtilakls2510/Stopwatch/tree/S2_Encapsulating_Thread_logic_in_stopwatch" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">代号</strong> </a>直到现在。</li><li id="8714" class="ma mb iq ka b kb mk kf ml kj mm kn mn kr mo kv mf mg mh mi bi translated"><a class="ae mj" href="https://rajtilakls2510.medium.com/encapsulating-the-thread-logic-in-stopwatch-part-2-746d2e051abd" rel="noopener">第二部分</a></li></ul></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><p id="d006" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们去看看我们说的这个观察者模式是什么。</p><p id="0079" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里涉及到两个主要的身份:</p><ul class=""><li id="7dde" class="ma mb iq ka b kb kc kf kg kj mc kn md kr me kv mf mg mh mi bi translated">可观察量</li><li id="e9ce" class="ma mb iq ka b kb mk kf ml kj mm kn mn kr mo kv mf mg mh mi bi translated">观察者</li></ul><p id="8b08" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">可观察</strong>是需要别人观察的人。当它的内部状态改变时，它应该通知所有正在观察这个家伙的<strong class="ka ir">观察者</strong>。我们举个例子把这个具体化。</p><p id="4255" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们都知道报纸订阅是如何运作的，对吗？(示例:头部优先设计模式)</p><ul class=""><li id="053f" class="ma mb iq ka b kb kc kf kg kj mc kn md kr me kv mf mg mh mi bi translated">报纸出版商开始经商，开始出版报纸。</li><li id="d174" class="ma mb iq ka b kb mk kf ml kj mm kn mn kr mo kv mf mg mh mi bi translated">你订阅了一个特定的出版商，每次有新的版本就会送到你手中。只要你还是订户，你就能得到新报纸。</li><li id="f9ff" class="ma mb iq ka b kb mk kf ml kj mm kn mn kr mo kv mf mg mh mi bi translated">当你不想要报纸时，你可以退订，这样报纸就不会被投递了。</li><li id="fe80" class="ma mb iq ka b kb mk kf ml kj mm kn mn kr mo kv mf mg mh mi bi translated">当出版商仍在经营时，人们、酒店、航空公司和其他企业不断地订阅和取消订阅报纸出版物。</li></ul><p id="71c3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本例中，报纸发行物是可观察的<strong class="ka ir"/>，顾客是观察者<strong class="ka ir"/>。</p><figure class="mx my mz na gt jq gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi mw"><img src="../Images/27b17c353a74d52b6bd5009720a09359.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ijj-fll1hxyJFXp4XbylrQ.png"/></div></div></figure><p id="abbc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">观察者模式的正式定义是:</p><p id="81ad" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kw"/><strong class="ka ir"><em class="kw">观察者模式</em> </strong> <em class="kw">定义了对象之间一对多的依赖关系，这样当一个对象改变状态时，它所有的依赖对象都会被自动通知和更新。</em></p><p id="0070" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如何用代码实现这一点？看一下一般的类图:</p><figure class="mx my mz na gt jq gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi mw"><img src="../Images/7bd7665433c8cee021c565592d1bf4a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xmKBZCQEaLYY46yxopIMSQ.png"/></div></div></figure><p id="3434" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">主要有两个接口:<strong class="ka ir">可观测者</strong>和<strong class="ka ir">观测者</strong>。Observable接口有三个方法:registerObserver()、removeObserver()和notifyObservers()。</p><ul class=""><li id="42ed" class="ma mb iq ka b kb kc kf kg kj mc kn md kr me kv mf mg mh mi bi translated">registerObserver()负责为这个可观察对象订阅一个观察器。</li><li id="664c" class="ma mb iq ka b kb mk kf ml kj mm kn mn kr mo kv mf mg mh mi bi translated">removeObserver()负责观察者的取消订阅。</li><li id="1cad" class="ma mb iq ka b kb mk kf ml kj mm kn mn kr mo kv mf mg mh mi bi translated">notifyObservers()负责通过调用每个观察器的update()方法来通知所有观察器状态的变化。</li></ul><p id="5aa5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Observer接口只有一个方法:update()。这个方法负责接收观察对象的更新状态，并对其进行处理。</p><p id="452d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">与我们的示例相比，我们可以让我们的<strong class="ka ir">秒表</strong>类实现<strong class="ka ir">观察器</strong>，因为客户端想要观察秒表的时间，并且所有客户端都将实现<strong class="ka ir">观察器</strong>。我们的应用程序的类图将如下所示:</p><figure class="mx my mz na gt jq gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi mw"><img src="../Images/4d4cec1ad30b30655fdd4e8d017910da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r2WlIXuJnxMRwmyRG1LEWg.png"/></div></div></figure><p id="3678" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意，这里我们没有在Observable接口中实现removeObserver()方法，因为这是一个非常简单的方法，您可以自己找出删除逻辑。</p><p id="1ab1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们从制作两个接口开始:</p><p id="cfca" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Observable.java</p><pre class="mx my mz na gt nf ng nh ni aw nj bi"><span id="54de" class="nk ky iq ng b gy nl nm l nn no">public interface Observable {<br/>    public void registerObserver(Observer o);<br/>    public void notifyObservers();<br/>}</span></pre><p id="23f0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在observable的registerObserver()方法中，一个Observer被传递给Observable，当我们编写具体的类时，我们将使用ArrayList在内部存储它。</p><p id="7241" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Observer.java</p><pre class="mx my mz na gt nf ng nh ni aw nj bi"><span id="a4e3" class="nk ky iq ng b gy nl nm l nn no">public interface Observer {<br/>    public void update(long time);<br/>}</span></pre><p id="1d96" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在观察者的update()方法中，更新的时间是从可观察对象传递过来的，然后观察者可以用它做任何事情。</p><p id="14f4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们从在秒表类中实现Observable接口及其方法开始。</p><pre class="mx my mz na gt nf ng nh ni aw nj bi"><span id="f683" class="nk ky iq ng b gy nl nm l nn no">public class Stopwatch implements Runnable, Observable<br/>{<br/>    ...</span><span id="434b" class="nk ky iq ng b gy np nm l nn no">    @Override<br/>    public void registerObserver(Observer o) {<br/>        <br/>    }<br/><br/>    @Override<br/>    public void notifyObservers() {<br/>    <br/>    }</span><span id="e186" class="nk ky iq ng b gy np nm l nn no">}</span></pre><p id="3968" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们创建一个数组列表来存储我们的观察者，并在构造函数中初始化它(不要忘记导入它)。</p><pre class="mx my mz na gt nf ng nh ni aw nj bi"><span id="4b41" class="nk ky iq ng b gy nl nm l nn no">import java.util.*;<br/>public class Stopwatch implements Runnable, Observable<br/>{<br/>    ...<br/>    private ArrayList&lt;Observer&gt; observers;</span><span id="7bbd" class="nk ky iq ng b gy np nm l nn no">    public Stopwatch()<br/>    {<br/>         ...<br/>        observers = new ArrayList&lt;&gt;();<br/>    }</span><span id="b960" class="nk ky iq ng b gy np nm l nn no">}</span></pre><p id="0262" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当调用registerObserver()时，我们希望将它添加到ArrayList中。</p><pre class="mx my mz na gt nf ng nh ni aw nj bi"><span id="dfaa" class="nk ky iq ng b gy nl nm l nn no">@Override<br/>public void registerObserver(Observer o) {<br/>    observers.add(o);<br/>}</span></pre><p id="80f2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们编写notifyObservers()方法。我们将遍历所有的观察器，并调用它们的update()方法。但是我们将遵循另一个你会经常遇到的小设计模式:迭代器模式。使用迭代器的优势是巨大的，但是现在，要明白迭代器就像一个保存迭代状态的光标，有非常方便的方法:hasNext()和Next()，它们隐藏了底层数据结构的内部实现，帮助我们遍历数据结构，甚至不用担心它是由什么组成的。不要忘乎所以，这很容易理解。只看代码。</p><pre class="mx my mz na gt nf ng nh ni aw nj bi"><span id="9752" class="nk ky iq ng b gy nl nm l nn no">@Override<br/>public void notifyObservers() {<br/>    Iterator&lt;Observer&gt; iter = observers.iterator();<br/>    while(iter.hasNext())<br/>    {<br/>        Observer o = iter.next();<br/>        o.update(getTime());<br/>    }<br/>}</span></pre><p id="c815" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里，observers数组列表有一个方法iterator()，它返回迭代器对象。然后，我们可以只使用“iter”对象的hasNext()和Next()方法遍历观察者列表。如果有更多的观察者，hasNext()返回“the next()返回数组列表中的下一个观察者。然后我们调用每个观察者的update()方法，并使用getTime()方法来传递时间。</p><p id="9655" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">秒表类中剩下的最后一件事是更新run()方法，该方法当前打印出时间，通知所有观察者。每隔10 ms，线程应该通知所有的观察者。那是我们的目标，对吗？</p><pre class="mx my mz na gt nf ng nh ni aw nj bi"><span id="1d90" class="nk ky iq ng b gy nl nm l nn no">@Override<br/>public void run() {<br/>    while(!isStopped)<br/>    {<br/>        notifyObservers();<br/>        try {<br/>            Thread.<em class="kw">sleep</em>(10);<br/>        } catch (InterruptedException e) {<br/>            e.printStackTrace();<br/>        }<br/>    }<br/>}</span></pre><p id="bbe1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于可观察的部分，您可能会想:让StopwatchTest类实现可观察的。在某种程度上你是对的，但是由于静态main()方法的存在，我们可能不得不绕道而行。只有当您自己实现它并得到一个编译时错误时，您才会理解为什么这是一个问题。</p><p id="149b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将为观察者创建一个单独的类，它只负责打印时间。我们又做了同样的印刷，但是，相信我，当我们加入Swing时，这种设计模式会给我们很大帮助。</p><p id="1ad6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们创建了一个名为StopwatchObserver.java的新文件，它实现了观察者接口。</p><pre class="mx my mz na gt nf ng nh ni aw nj bi"><span id="74c9" class="nk ky iq ng b gy nl nm l nn no">public class StopwatchObserver implements Observer{<br/><br/><br/>    @Override<br/>    public void update(long time) {<br/>        System.<em class="kw">out</em>.print("\rTime: "+time);<br/>    }<br/>}</span></pre><p id="93dc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是秒表观察器的完整代码。就是这样。</p><p id="e39b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们修改我们的StopwatchTest类来测试这个新设计的秒表。我们只需要再添加两行:创建一个观察者并注册该观察者。所有的打印都将由观察者自己处理。</p><pre class="mx my mz na gt nf ng nh ni aw nj bi"><span id="2301" class="nk ky iq ng b gy nl nm l nn no">public class StopwatchTest {<br/>    public static void main(String[] args) {<br/>        Stopwatch sw = new Stopwatch();<br/>        StopwatchObserver ob = new StopwatchObserver();<br/>        sw.registerObserver(ob);<br/><br/>        <em class="kw">// Rest of the start and stop methods remain same<br/>    }<br/>}</em></span></pre><p id="53cb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">就是这样。我们正努力履行我们的承诺，尽可能减少客户端代码。在这里，客户端只需要实现观察者接口，然后工作就完成了。现在，让我们来看看输出。</p><figure class="mx my mz na gt jq gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/602853b5adaf0cd09ec3e143fd3d51e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:908/format:webp/1*GOqPPS5dX7roS_vvoaSGuQ.png"/></div></figure><p id="dbb8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">输出保持不变，但是输出到屏幕上的方式每次都在变化。随着更强大的设计模式的使用，它变得越来越好。</p><p id="ba86" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">太好了！现在我们的秒表类已经完全可以用于商业用途了。现在是构建使用这个秒表的应用程序的大好时机。从下一个教程开始，我们将从我们的Swing应用程序开始，制作一个合适的秒表应用程序。下一集见。</strong></p><h1 id="7a81" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">下一个教程:</h1><p id="d058" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated"><a class="ae mj" href="https://rajtilakls2510.medium.com/starting-with-the-swing-app-part-4-7b9395a5960c" rel="noopener">从Swing App开始</a></p><h1 id="bc30" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated"><strong class="ak">全码</strong></h1><p id="4a80" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">完整的代码在这里。</p><p id="e78d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Observable.java</p><pre class="mx my mz na gt nf ng nh ni aw nj bi"><span id="bee9" class="nk ky iq ng b gy nl nm l nn no">public interface Observable {<br/>    public void registerObserver(Observer o);<br/>    public void notifyObservers();<br/>}<br/></span></pre><p id="1698" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Observer.java</p><pre class="mx my mz na gt nf ng nh ni aw nj bi"><span id="68c5" class="nk ky iq ng b gy nl nm l nn no">public interface Observer {<br/><br/>    public void update(long time);<br/>}</span></pre><p id="f672" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Stopwatch.java</p><pre class="mx my mz na gt nf ng nh ni aw nj bi"><span id="33f2" class="nk ky iq ng b gy nl nm l nn no">import java.util.ArrayList;<br/>import java.util.Iterator;<br/><br/>public class Stopwatch implements Runnable, Observable<br/>{<br/>    private long offset, currentStart;<br/>    private boolean isStopped;<br/>    private Thread th;<br/>    private ArrayList&lt;Observer&gt; observers;<br/><br/>    public Stopwatch()<br/>    {<br/>        offset = 0L;<br/>        currentStart = System.<em class="kw">currentTimeMillis</em>();<br/>        isStopped = true;<br/>        observers = new ArrayList&lt;&gt;();<br/>    }<br/><br/>    public void start()<br/>    {<br/>        if(isStopped)<br/>        {<br/>            th = new Thread(this);<br/>            th.start();<br/>            currentStart = System.<em class="kw">currentTimeMillis</em>() - offset;<br/>        }<br/><br/>        isStopped = false;<br/>    }<br/><br/>    public void stop()<br/>    {<br/>        if(!isStopped)<br/>        {<br/>            th = null;<br/>            offset = System.<em class="kw">currentTimeMillis</em>() - currentStart;<br/>        }<br/>        isStopped = true;<br/>    }<br/><br/>    public long getTime()<br/>    {<br/>        if(!isStopped)<br/>            return System.<em class="kw">currentTimeMillis</em>() - currentStart;<br/>        else<br/>            return offset;<br/>    }<br/><br/>    @Override<br/>    public void run() {<br/>        while(!isStopped)<br/>        {<br/>            notifyObservers();<br/>            try {<br/>                Thread.<em class="kw">sleep</em>(10);<br/>            } catch (InterruptedException e) {<br/>                e.printStackTrace();<br/>            }<br/>        }<br/>    }<br/><br/>    @Override<br/>    public void registerObserver(Observer o) {<br/>        observers.add(o);<br/>    }<br/><br/>    @Override<br/>    public void notifyObservers() {<br/>        Iterator&lt;Observer&gt; iter = observers.iterator();<br/>        while(iter.hasNext())<br/>        {<br/>            Observer o = iter.next();<br/>            o.update(getTime());<br/>        }<br/>    }<br/>}</span></pre><p id="0407" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">StopwatchObserver.java</p><pre class="mx my mz na gt nf ng nh ni aw nj bi"><span id="49d1" class="nk ky iq ng b gy nl nm l nn no">public class StopwatchObserver implements Observer{<br/><br/><br/>    @Override<br/>    public void update(long time) {<br/>        System.<em class="kw">out</em>.print("\rTime: "+time);<br/>    }<br/>}</span></pre><p id="bee5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">StopwatchTest.java</p><pre class="mx my mz na gt nf ng nh ni aw nj bi"><span id="d527" class="nk ky iq ng b gy nl nm l nn no">public class StopwatchTest {<br/>    public static void main(String[] args) {<br/>        Stopwatch sw = new Stopwatch();<br/>        StopwatchObserver ob = new StopwatchObserver();<br/>        sw.registerObserver(ob);<br/><br/>        System.<em class="kw">out</em>.println("\nStarting Stopwatch: ");<br/>        sw.start();<br/>        <em class="kw">sleep</em>(2000);<br/>        sw.stop();<br/>        System.<em class="kw">out</em>.println("\nStopwatch Stopped. ");<br/><br/>        <em class="kw">sleep</em>(2000);<br/><br/>        System.<em class="kw">out</em>.println("\nStarting Stopwatch: ");<br/>        sw.start();<br/>        <em class="kw">sleep</em>(2000);<br/>        sw.stop();<br/>        System.<em class="kw">out</em>.println("\nStopwatch Stopped. ");<br/><br/>    }<br/><br/>    public static void sleep(int time)<br/>    {<br/>        try {<br/>            Thread.<em class="kw">sleep</em>(time);<br/>        } catch (InterruptedException e) {<br/>            e.printStackTrace();<br/>        }<br/>    }<br/><br/><br/>}</span></pre><h1 id="ffad" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">参考资料:</h1><ul class=""><li id="9f89" class="ma mb iq ka b kb lv kf lw kj nr kn ns kr nt kv mf mg mh mi bi translated">书:<a class="ae mj" href="https://www.oreilly.com/library/view/head-first-design/0596007124/" rel="noopener ugc nofollow" target="_blank"> Head First设计模式</a>，作者埃里克·弗里曼、伊丽莎白·罗布森、伯特·贝茨、凯西·塞拉。</li></ul></div></div>    
</body>
</html>