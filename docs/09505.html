<html>
<head>
<title>A Real-World Example to Apply TypeScript Advanced Types</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">应用TypeScript高级类型的真实示例</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/achieve-type-safety-with-typescript-magic-fef5ff939c98?source=collection_archive---------14-----------------------#2021-08-16">https://levelup.gitconnected.com/achieve-type-safety-with-typescript-magic-fef5ff939c98?source=collection_archive---------14-----------------------#2021-08-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1001" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">探索TypeScript高级类型的强大功能</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2b51b4421907b3362a0314e718934402.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XPF3uCquD68KR43pUyvXjA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@raaminka?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">拉明·卡</a>在<a class="ae ky" href="https://unsplash.com/collections/pPAmn-uII_E/magician?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="592d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">TypeScript高级类型功能强大。这些包括条件类型、泛型、联合类型、分布条件类型和类型推断。它是一个复杂的工具箱，具有许多功能，并且在不断发展。</p><p id="9513" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我学习TypeScript时，我发现许多例子要么是琐碎的，要么是做作的。从这些例子中，很难联想到高级类型的实际应用。本文将讨论一个使用高级类型的实际例子。</p><h2 id="b084" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">问题是</h2><p id="f0d2" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我们正在重构现有的节点应用程序。在应用程序中，各种功能都有一个配置常量。示例配置如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="053d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此常量的目的是提供功能切换。“设置”中的每个设置项代表一个可以打开/关闭的功能。</p><p id="ab48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的函数用于应用程序中的每个组件。它用于确定可配置功能是否启用。</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="7225" class="lv lw it mw b gy na nb l nc nd">function isFuncEnabled(module:string, feature:string, functionkey: string) {}</span></pre><p id="86f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">显然，它不是类型安全的。不正确的参数可能会被传递到函数中，从而导致运行时错误。即使参数编码正确，也很难维护。比方说，当现有设置被重命名时，开发人员可能不记得相应地更新参数。</p><p id="bbd7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的目标是为函数参数创建一个强类型。</p><h2 id="97c1" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">快速解</h2><p id="b8a9" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">使函数参数成为强类型的最快方法是使用联合类型。如下所示，我们创建了3个新的联合类型来表示模块、特性和功能键。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="f8c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个解决方案优于现有的代码。所有3个参数都被限制为它们自己的一组值。但还不理想。我们还有两个问题:</p><ul class=""><li id="e6c4" class="ne nf it lb b lc ld lf lg li ng lm nh lq ni lu nj nk nl nm bi translated">3个联合类型中的值与<code class="fe nn no np mw b">FeatureConfig</code>常量重复。如果我们添加或删除一个设置项，那么新创建的联合类型将会过时。</li><li id="bdc7" class="ne nf it lb b lc nq lf nr li ns lm nt lq nu lu nj nk nl nm bi translated">参数之间没有约束。我们可能在他们之间有一个不匹配。</li></ul><p id="0706" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更好的方法是重构代码，使用高级类型约束参数。</p><h2 id="2212" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">改进的解决方案</h2><p id="9fbb" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">首先，我们将<a class="ae ky" href="https://mariusschulz.com/blog/const-assertions-in-literal-expressions-in-typescript#:~:text=A%20const%20assertion%20is%20a%20special%20type%20assertion%20that%20uses,literal%20expression%20will%20be%20widened.&amp;text=Array%20literals%20will%20become%20readonly%20tuples." rel="noopener ugc nofollow" target="_blank">常量断言表达式</a>应用于源常量。它使常量属性成为字符串文字类型。因此，我们可以在此基础上使用其他类型转换。</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="15d5" class="lv lw it mw b gy na nb l nc nd">export const FeatureConfig = { ... } <strong class="mw iu">as const</strong>;</span></pre><p id="ceed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们还在下面创建了两个类型助手。它们用于将类型属性值/键转换为联合类型。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="7168" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了这两个类型帮助器，我们可以将原始FeatureConfig类型转换为flatten类型。我们想要达到的目标如下。</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="aa9b" class="lv lw it mw b gy na nb l nc nd">{<br/>    readonly module: "order";<br/>    readonly feature: "orderApproval";<br/>    readonly settings: "emailNotification" | "showAuditLog";<br/> };</span></pre><h2 id="22f2" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">分配条件类型</h2><p id="f539" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我们使用分布式条件类型创建了FlatternArray类型。分布式意味着编译器将对联合的所有成员逐一应用运算。在这种类型中，它应用于t的每个键。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="c102" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们应用FlatternArray时，TypeScript编译器实际做的是:</p><pre class="kj kk kl km gt mv mw mx my aw mz bi"><span id="bd29" class="lv lw it mw b gy na nb l nc nd">type FeatureSetting = FlatternArray&lt;{<br/>    readonly module: "admin";<br/>    readonly feature: "userManagement";<br/>    readonly settings: {<br/>        readonly resetPassword: "on";<br/>        readonly delegation: "on";<br/>        readonly referral: "off";<br/>    };<br/>}&gt; | FlatternArray&lt;{<br/>    readonly module: "order";<br/>    readonly feature: "orderApproval";<br/>    readonly settings: {<br/>        readonly emailNotification: "on";<br/>        readonly showAuditLog: "on";<br/>    };<br/>}&gt;&gt;</span></pre><h2 id="4606" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">参数类型</h2><p id="b97a" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">现在，我们可以为每个参数实现一个类型。分别是“<em class="nv">模块</em>”、“<em class="nv">特性by模块</em>”和“<em class="nv">设置by特性</em>”。对于后两种情况，先前键入的参数作为泛型传入。我们使用条件类型缩小了这两种类型的范围。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><h2 id="344e" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">把它们放在一起</h2><p id="fb22" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">最后，我们可以将上述参数类型应用于函数类型“getFeatureSettingType”。通过用新的函数类型注释我们的函数，TypeScript编译器能够将参数<em class="nv">模块、特征、</em>和<em class="nv">键</em>推断为类型<em class="nv"> m、f、k </em>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="4b44" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果将鼠标悬停在参数上，可以看到如下类型。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/417674c200c603b053d01aa5b4d6988d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1378/format:webp/1*FSwshy3MzI_qkQjeHqau9A.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">强类型关键参数</figcaption></figure><p id="44d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看新重构的代码有什么好处。</p><ul class=""><li id="f07c" class="ne nf it lb b lc ld lf lg li ng lm nh lq ni lu nj nk nl nm bi translated"><strong class="lb iu">简洁的类型约束</strong>。当我们现在传入一个不匹配的参数时，编译器会显示一个友好的错误信息。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/405feb52da1fbefeb4adcfc2e680d92b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p-WQQ0y5U2bPYYyiUqKlWQ.png"/></div></div></figure><ul class=""><li id="31ce" class="ne nf it lb b lc ld lf lg li ng lm nh lq ni lu nj nk nl nm bi translated"><strong class="lb iu">真理的单一来源</strong>。如果源常量有变化，变化将自动更新到参数类型！</li></ul><p id="29da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里是<a class="ae ky" href="https://gist.github.com/sunnyy02/d3cb1c814fcd4f3a28546a883d90aec1" rel="noopener ugc nofollow" target="_blank">完整的样本代码</a>供你参考。</p><h2 id="0f47" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">摘要</h2><p id="1c42" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">在本文中，我们将介绍一个使用高级类型的真实重构示例。结果是一个简洁且约束良好的类型。对源常量的任何更改都会触发下游类型的自动更新。我们实现了TypeScript的主要目标:类型安全。</p><p id="ccc4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你喜欢这篇文章，你可能也会喜欢我的其他打字稿。</p><p id="1ee1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读！</p></div></div>    
</body>
</html>