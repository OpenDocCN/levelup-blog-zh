<html>
<head>
<title>Implementing a Binary Search Tree in Javascript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Javascript实现二叉查找树</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/implementing-a-binary-search-tree-in-javascript-78a2f28d0493?source=collection_archive---------7-----------------------#2020-03-06">https://levelup.gitconnected.com/implementing-a-binary-search-tree-in-javascript-78a2f28d0493?source=collection_archive---------7-----------------------#2020-03-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/d502ea68b116bd6c32af52a596261df6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LqUDkv4w1sTM3TLknOaJfw.jpeg"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">马克斯·尼尔森在<a class="ae jg" href="https://unsplash.com/s/photos/code-tree?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><div class=""/><p id="f7f8" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">今天，我们将创建自己的二叉查找树实现，但在编写一行代码之前，最好先了解一下基本原理。</p><h1 id="3881" class="le lf jj bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">二叉树到底是什么？</h1><p id="f025" class="pw-post-body-paragraph kg kh jj ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">二叉树是一种数据结构，类似于链表，由节点组成。</p><p id="2715" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">节点是存储数据的容器。在这个特殊的例子中，它存储了一个值和两个指针，<em class="mh">，因此是binary (2) </em>。每个指针将引用另一个节点，一个向左，另一个向右，依此类推，如下图所示。</p><figure class="mj mk ml mm gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mi"><img src="../Images/295497ad0d3d85033c0cdb58283f4b60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*i9bAVwZUucPMt-jd.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">所有图片都是由您真实创作的</figcaption></figure><p id="ecb8" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所有的树都以根<strong class="ki jk">开始</strong>。这是第一个节点。此节点没有任何父节点。</p><h1 id="eca0" class="le lf jj bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">下面是一些使用树时感兴趣的有用术语。</h1><p id="6dc1" class="pw-post-body-paragraph kg kh jj ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><strong class="ki jk">边</strong>:两个节点之间的连接。(上图中的线)</p><p id="3235" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki jk">级别</strong>:找到一个节点的深度。从根开始，从1开始，在每个边沿之后增加。</p><p id="e52e" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki jk">叶</strong>:没有子节点的节点。</p><p id="5c21" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki jk">树的高度:</strong>树的高度是树中从根到最低节点的边数。</p><p id="a378" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki jk">完美树</strong>:每一层节点数量相同的树。在现实世界的应用中，树很少是完美的。</p><blockquote class="mn mo mp"><p id="e461" class="kg kh mh ki b kj kk kl km kn ko kp kq mq ks kt ku mr kw kx ky ms la lb lc ld im bi translated">二叉树中的每个节点可以有两个子节点<strong class="ki jk"/>(左和右)、<strong class="ki jk">一个</strong>(左或右)或<strong class="ki jk">无</strong>(叶)。</p></blockquote><h1 id="3b4c" class="le lf jj bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">为什么要使用二叉查找树</h1><p id="5799" class="pw-post-body-paragraph kg kh jj ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">树中的值需要花费<strong class="ki jk"> O(h) </strong>时间才能找到。其中<strong class="ki jk"> h </strong>是树的高度？虽然这仍然比链表快，但我们可以做得更好。</p><p id="b90a" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki jk">二分搜索法树</strong>比数组、链表等线性数据结构有一大优势，甚至比<strong class="ki jk">正则树</strong> s. A <strong class="ki jk"> BST </strong>都可以在<strong class="ki jk"> log(n) </strong> time中搜索到。</p><h1 id="d340" class="le lf jj bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">它是怎么工作的？</h1><p id="6f42" class="pw-post-body-paragraph kg kh jj ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">在常规二叉树中，任何值都可以向左或向右。但是在BST中，<strong class="ki jk">值必须按</strong>排序。当引入一个新值时，我们从比较根的值和将要插入的值开始。</p><p id="d082" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果新值小于根节点的值，它将移动到左侧节点，否则它将移动到右侧。如果它们相等，它可以向任何方向移动，但这取决于程序员来实现它。</p><p id="0382" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是递归地<em class="mh">完成的</em>,直到到达一个叶节点。然后，根据最后一次比较，从左或右插入该值。</p><p id="a927" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，值<strong class="ki jk"> 12 </strong>将被添加到先前的树中。我们来分析一下。</p><ol class=""><li id="f44f" class="mt mu jj ki b kj kk kn ko kr mv kv mw kz mx ld my mz na nb bi translated"><strong class="ki jk"> 12 </strong>大于<strong class="ki jk"> 10 </strong>，→ <strong class="ki jk">右移</strong></li><li id="c636" class="mt mu jj ki b kj nc kn nd kr ne kv nf kz ng ld my mz na nb bi translated"><strong class="ki jk"> 12 </strong>小于<strong class="ki jk"> 15 </strong>，a <strong class="ki jk"> 15 </strong>是<strong class="ki jk">叶节点</strong>，→ <strong class="ki jk">左移</strong>加12</li></ol><figure class="mj mk ml mm gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nh"><img src="../Images/f971e39aa81051d4df268e106d1a4093.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5QBloMyoj00dWO9N.png"/></div></div></figure><p id="f088" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在您应该开始理解为什么在BST中搜索值比在任何线性数据结构中搜索要快得多。</p><h1 id="5cbd" class="le lf jj bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">可能的缺点</h1><p id="400d" class="pw-post-body-paragraph kg kh jj ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">如果我们按顺序插入值会怎么样？如果我们的树是空的，我们想按顺序插入1、2和3，我们的BST将退化为一个美化的链表，使得搜索时间为O(n) 。(如下图所示)</p><figure class="mj mk ml mm gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ni"><img src="../Images/c5dd5d21edcdbabc77ca3c83ca83fa2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Cgnm4XMrq57nZUnm.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">从某个角度看，它有点像一个链表</figcaption></figure><div class="is it gp gr iu nj"><a href="https://medium.com/javascript-in-plain-english/implementing-a-hash-table-in-javascript-29aca1edfe2b" rel="noopener follow" target="_blank"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd jk gy z fp no fr fs np fu fw ji bi translated">用JavaScript实现哈希表</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">今天我们将在JavaScript/TypeScript中创建我们自己的散列表数据结构。</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">medium.com</p></div></div><div class="ns l"><div class="nt l nu nv nw ns nx ja nj"/></div></div></a></div><h2 id="bcaf" class="ny lf jj bd lg nz oa dn lk ob oc dp lo kr od oe ls kv of og lw kz oh oi ma oj bi translated">开始之前，请注意以下几点</h2><blockquote class="mn mo mp"><p id="ea5f" class="kg kh mh ki b kj kk kl km kn ko kp kq mq ks kt ku mr kw kx ky ms la lb lc ld im bi translated">typescript和javascript的唯一区别是变量类型的声明。在下面的代码片段中，代码是用typescript编写的，但是通过删除类型定义，可以很容易地将其转换成javascript。</p></blockquote><p id="3713" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如</p><pre class="mj mk ml mm gt ok ol om on aw oo bi"><span id="a59d" class="ny lf jj ol b gy op oq l or os"><strong class="ol jk">//in typescript</strong><br/>var addOne(num: number): number {<br/>     return num++;<br/>}<strong class="ol jk">//in javascript</strong><br/>var addOne(num) {<br/>     return num++;<br/>}</span></pre><p id="e681" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不是说我们已经得到了我们的方式，让我们挖！</p><h1 id="1060" class="le lf jj bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">是时候把手弄脏了</h1><p id="1aa6" class="pw-post-body-paragraph kg kh jj ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">让我们首先创建一个类作为我们的节点。</p><figure class="mj mk ml mm gt iv"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="4b32" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以看到一个节点有三个属性。节点的值和左右两个指针属于同一类型。</p><p id="22cd" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">默认情况下，一个节点没有子节点，因此两个指针都是空值。</p><h1 id="1e75" class="le lf jj bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">创建树类</h1><figure class="mj mk ml mm gt iv"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="feca" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以看到这个类只有一个同类型<strong class="ki jk"> <em class="mh"> BinaryNode </em> </strong>的<strong class="ki jk">根</strong>属性。该属性将保存我们树中的第一个节点。</p><p id="c555" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你也可以注意到它叫做<strong class="ki jk"> BinaryTreeR </strong>。<strong class="ki jk"> <em class="mh"> R代表递归</em> </strong>，因为这是我们实现这个数据结构的方式。</p><h1 id="1aa7" class="le lf jj bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">插入值</h1><p id="80c1" class="pw-post-body-paragraph kg kh jj ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">插入值时有两种可能的情况。</p><p id="1ae7" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在递归方法中，我们开始沿着树向下移动(从根开始),根据我们想要插入的值选择向左或向右移动。</p><p id="1940" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，在此之前，我们必须检查我们的根不是空的，因为这意味着我们的树是空的。如果是这种情况，我们简单地用新值给树的根属性分配一个节点。</p><figure class="mj mk ml mm gt iv"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="6ca1" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里我们可以看到，我们的递归函数需要一个节点和一个值，节点值将根据我们正在移动的节点而变化。</p><p id="3993" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当函数在自身内部被调用时，它会更新节点参数，这样它就可以在树中移动。</p><h1 id="aa24" class="le lf jj bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">搜索节点</h1><p id="dd4b" class="pw-post-body-paragraph kg kh jj ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">在我们实现删除方法之前，(<em class="mh">提示:这是最难的部分</em>)，让我们通过实现一个检查值是否存在的方法来检查我们的插入代码是否工作。</p><figure class="mj mk ml mm gt iv"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="5534" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个方法非常简单。首先，它检查值，将其与作为参数给出的节点进行比较，并相应地移动。如果找到了值，它将返回该节点。</p><h1 id="feb2" class="le lf jj bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">最终老板:删除价值观</h1><p id="b975" class="pw-post-body-paragraph kg kh jj ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">在我们实现这段代码之前，花点时间想一想为什么很难从树中删除一个节点。T2应该很容易，对吗？我们可以搜索它，然后删除它。</p><blockquote class="ov"><p id="aca1" class="ow ox jj bd oy oz pa pb pc pd pe ld dk translated">如果我们想删除一个有子节点的节点，而这个子节点又有更多的子节点呢？</p></blockquote><p id="39dd" class="pw-post-body-paragraph kg kh jj ki b kj pf kl km kn pg kp kq kr ph kt ku kv pi kx ky kz pj lb lc ld im bi translated">删除包含子节点的节点而不容纳它们也将导致它们被删除。</p><blockquote class="ov"><p id="0e89" class="ow ox jj bd oy oz pa pb pc pd pe ld dk translated">如果5个人挂在悬崖上的一根绳子上，第一个人割断了他下面的绳子，其余的人就会掉下悬崖。</p></blockquote><p id="f1ac" class="pw-post-body-paragraph kg kh jj ki b kj pf kl km kn pg kp kq kr ph kt ku kv pi kx ky kz pj lb lc ld im bi translated">删除节点时，我们必须考虑三种情况。</p><h2 id="99e4" class="ny lf jj bd lg nz oa dn lk ob oc dp lo kr od oe ls kv of og lw kz oh oi ma oj bi translated">当节点是叶子时</h2><p id="b939" class="pw-post-body-paragraph kg kh jj ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">这是所有方法中最简单的一种，因为我们可以简单地删除节点并完成它。</p><h2 id="2110" class="ny lf jj bd lg nz oa dn lk ob oc dp lo kr od oe ls kv of og lw kz oh oi ma oj bi translated">当节点有一个子节点时</h2><p id="d92f" class="pw-post-body-paragraph kg kh jj ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><strong class="ki jk">我们必须在目标节点的子节点和父节点之间创建一个链接</strong>。</p><figure class="mj mk ml mm gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pk"><img src="../Images/a5377b4bdbd68fbde8dacb04fd6045c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VE-u-1mCNAZT6ODMUNu7LA.png"/></div></div></figure><h1 id="cbee" class="le lf jj bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结果</h1><figure class="mj mk ml mm gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pk"><img src="../Images/40c019c466d226c971141eb2709d6a5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iGbD3L01y_O8N8_IgpyR8Q.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">删除带有一个子节点的目标节点后得到的树</figcaption></figure><h2 id="f488" class="ny lf jj bd lg nz oa dn lk ob oc dp lo kr od oe ls kv of og lw kz oh oi ma oj bi translated">当节点有两个子节点时</h2><p id="4f8c" class="pw-post-body-paragraph kg kh jj ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">因为我们想要删除一个有两个子节点的节点，我们必须采取额外的步骤来确保我们的结构保持有序。为此，我们必须向右移动一次，找到该节点左侧的最小值。然后，我们必须将目标节点左边的节点连接到树右边最小的节点。</p><p id="c5cb" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我知道，这听起来确实令人困惑，但这里有一些插图，使它更容易消化。</p><p id="77aa" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设我们想要删除这个示例树中的节点5。</p><p id="c725" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">5是我们的目标节点(我们想要删除的节点)</p><figure class="mj mk ml mm gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pl"><img src="../Images/302ee60c3de3a18811c29e15f3cc77b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e14vW6sTyNZGxPH6Pc1e5g.png"/></div></div></figure><p id="eae5" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们只是删除它，我们的树的一些数据会受到损害。它看起来会像这样。</p><figure class="mj mk ml mm gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pl"><img src="../Images/471dd9872a584491f1b20d0f3fdc0b0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_350L8Q2Q2dOggPiQ6acxg.png"/></div></div></figure><p id="e171" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">相反，我们希望实现一些额外的步骤来确保我们的树保持有序。首先，我们移动到目标节点(5)的右边。然后我们一直向左走，直到到达一个叶节点。</p><figure class="mj mk ml mm gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pl"><img src="../Images/0da2e6e9c694c1f0f3b6876e7082f56d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zdl_zy20iWmQECV4mHJIlw.png"/></div></div></figure><p id="c763" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们已经找到了5右边最左边的节点(6 ),我们需要将5的左边节点移到6之后，就像这样。</p><figure class="mj mk ml mm gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pm"><img src="../Images/9d15a38f5f811cc155ceb04a0cb43a45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PUy_o9DhhK1EFOednBVhwQ.png"/></div></div></figure><p id="dac2" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最终的结果不会是一个理想的树，它开始看起来更像一个链表，但我们的搜索树仍然是正确排序的。</p><h1 id="e4ce" class="le lf jj bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结果</h1><figure class="mj mk ml mm gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pn"><img src="../Images/d6b8f1c7d68d551a5256b4cffe2e814b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HLkGjF5NPvzVdyDuzkNPYw.png"/></div></div></figure><p id="9ee6" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在已经清楚了删除算法的工作原理，让我们把它翻译成代码(困难的部分)。</p><figure class="mj mk ml mm gt iv"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="940c" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">哇！代码太多了。花点时间仔细通读所有内容，并尝试将它与我们刚刚学到的视觉内容联系起来。</p><p id="6525" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还可以看到，如果我们要删除的节点是树的根，那么会有一种特殊情况。</p><p id="a1e6" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，在最后一种情况下，调用一个名为<em class="mh"> goLeft </em>的方法。这个方法将从任何给定的节点开始返回最左边的值。</p><h1 id="e760" class="le lf jj bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">重构方法</h1><p id="f671" class="pw-post-body-paragraph kg kh jj ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">最后，让我们创建新的方法，这样用户在插入或删除节点时就不必接触任何东西。用户应该能够输入一个值并添加或删除它，而不必担心从哪个节点开始或任何事情如何工作。</p><figure class="mj mk ml mm gt iv"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="7d07" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们使用一个虚拟变量来访问根，因为我们从来不想直接访问或修改它。如果我们搞砸了，我们可能会删除或修改对它的引用，基本上是在内存中丢失了整棵树。</p><figure class="mj mk ml mm gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi po"><img src="../Images/8bb08eecf443731caa24ad5ad320dacd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NbR5M-DDcdwU8CkrDhJuvQ.png"/></div></div></figure><h1 id="b968" class="le lf jj bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">最后的结果</h1><figure class="mj mk ml mm gt iv"><div class="bz fp l di"><div class="ot ou l"/></div></figure><p id="bdc9" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">今天到此为止。</p><p id="98c2" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">敬请关注即将到来的图表故事！</p></div><div class="ab cl pp pq hx pr" role="separator"><span class="ps bw bk pt pu pv"/><span class="ps bw bk pt pu pv"/><span class="ps bw bk pt pu"/></div><div class="im in io ip iq"><h1 id="758d" class="le lf jj bd lg lh pw lj lk ll px ln lo lp py lr ls lt pz lv lw lx qa lz ma mb bi translated">分级编码</h1><p id="bca3" class="pw-post-body-paragraph kg kh jj ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">感谢您成为我们社区的一员！在你离开之前:</p><ul class=""><li id="af17" class="mt mu jj ki b kj kk kn ko kr mv kv mw kz mx ld qb mz na nb bi translated">👏为故事鼓掌，跟着作者走👉</li><li id="6d24" class="mt mu jj ki b kj nc kn nd kr ne kv nf kz ng ld qb mz na nb bi translated">📰更多内容请查看<a class="ae jg" href="https://levelup.gitconnected.com/?utm_source=pub&amp;utm_medium=post" rel="noopener ugc nofollow" target="_blank">升级编码刊物</a></li><li id="22a9" class="mt mu jj ki b kj nc kn nd kr ne kv nf kz ng ld qb mz na nb bi translated">🔔关注我们:<a class="ae jg" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">推特</a> | <a class="ae jg" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a> | <a class="ae jg" href="https://newsletter.levelup.dev" rel="noopener ugc nofollow" target="_blank">时事通讯</a></li></ul><p id="da9f" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">🚀👉<a class="ae jg" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="ki jk">加入升级人才集体，找到一份神奇的工作</strong> </a></p></div></div>    
</body>
</html>