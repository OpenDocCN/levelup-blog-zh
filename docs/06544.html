<html>
<head>
<title>Test Your Client Apps With Polly</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Polly测试您的客户端应用</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/level-up-your-client-tests-with-polly-5f240a58bf53?source=collection_archive---------9-----------------------#2020-12-04">https://levelup.gitconnected.com/level-up-your-client-tests-with-polly-5f240a58bf53?source=collection_archive---------9-----------------------#2020-12-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ac9b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">以及为什么录音比模仿更进一步。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/91221cd8971d74a23167db334a7780a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tm2kimrDYHnJhCT7tswZZg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">图片来自Unsplash，作者为<a class="ae kv" href="https://unsplash.com/@flowforfrank" rel="noopener ugc nofollow" target="_blank"> Ferenc Almasi </a></figcaption></figure><p id="c288" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于任何调用外部API端点的应用程序，一个常见的问题是如何最好地为与API调用相关联的客户端逻辑编写自动化测试。</p><p id="8119" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">考虑下面的<code class="fe ls lt lu lv b">UserService</code>。它只是调用一个服务器端点(<code class="fe ls lt lu lv b">APIService</code>)并返回一个格式化的响应。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="c009" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有几个原因可以解释为什么<code class="fe ls lt lu lv b">UserService</code>的测试应该与实际的<code class="fe ls lt lu lv b">APIService</code>分离。在基本层面上，服务器通常以<a class="ae kv" href="https://en.wikipedia.org/wiki/State_%28computer_science%29" rel="noopener ugc nofollow" target="_blank">有状态</a>的形式存在，如果您想为孤立的场景编写确定性测试，这是有问题的。也就是说，如果您的测试依赖于实际用户，那么如果他们的概要文件被删除或更新，会发生什么呢？</p><p id="bb4e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">更具体地说，服务器可能只是对单元测试来说太慢了，或者对实时呼叫收费。</p><p id="ad31" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是我们使用<a class="ae kv" href="https://en.wikipedia.org/wiki/Test_double" rel="noopener ugc nofollow" target="_blank"> test doubles </a>的原因——它是“<em class="ly">对象或过程的通称，这些对象或过程的行为类似于它们面向发布的对应物，但实际上是降低复杂性和便于测试的简化版本。</em></p><p id="af1b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">尽管测试替身有不同的风格，我们上下文中的标准方法是使用<em class="ly">模拟</em>——简而言之，预先编程的简化来替换选定的模块。使用<a class="ae kv" href="https://jestjs.io/" rel="noopener ugc nofollow" target="_blank"> Jest </a>，一个广泛采用的JavaScript测试框架，我们可以模仿<code class="fe ls lt lu lv b">APIService</code>如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="3af2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这当然比没有测试要好，但是模拟的缺点是它们必须被维护。也就是说，您没有明显的方法来检测API行为的变化，并且您的测试可能会产生误报。</p><p id="d9f1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这让我想到了我们的主要问题:是否有一个test-double的实现来确保快速、确定性的测试，并且只需要最少的努力来与实际的API保持一致？</p><p id="8c52" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可能有多种答案，但是<em class="ly">录音</em>引起了我的注意。</p><p id="f8b4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">简而言之，记录的方法包括调用一个API端点<em class="ly">一次</em>，记录它的响应，并在未来的测试中重放它——“T23”存根”实际的HTTP调用。</p><p id="8e7e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我最近开始使用<a class="ae kv" href="https://netflix.github.io/pollyjs" rel="noopener ugc nofollow" target="_blank"> Polly </a>，一个由网飞维护的JavaScript库，在我的测试中实现录音。重要的是，Polly要求您为记录设置一个截止日期，这迫使您用API来更新您的测试。</p><p id="0d5f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以我们的<code class="fe ls lt lu lv b">UserService</code>为例，您可以将Polly添加到Jest测试中，如下所示:</p><ol class=""><li id="1524" class="lz ma iq ky b kz la lc ld lf mb lj mc ln md lr me mf mg mh bi translated">通过运行<code class="fe ls lt lu lv b">npm install — save-dev @pollyjs/core<a class="ae kv" href="http://@pollyjs/adapter-node-http" rel="noopener ugc nofollow" target="_blank"> @pollyjs/adapter-node-http</a><a class="ae kv" href="https://www.npmjs.com/package/@pollyjs/adapter-node-http" rel="noopener ugc nofollow" target="_blank"> @pollyjs/persister-fs</a> setup-polly-jest</code>安装依赖项。</li><li id="0d30" class="lz ma iq ky b kz mi lc mj lf mk lj ml ln mm lr me mf mg mh bi translated">创建一个新文件来配置Polly。</li></ol><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="1877" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最复杂的配置是<code class="fe ls lt lu lv b">matchRequestBy</code>。它规定了如何为请求生成唯一标识符，以及相应地如何将请求与记录相匹配。换句话说，请求是通过HTTP还是HTTPS发出的有关系吗？请求的顺序相关吗？两个标题不同的相同请求是否分开分类？</p><p id="eefd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于一个简单的实现，您可以通过<code class="fe ls lt lu lv b">method</code>和<code class="fe ls lt lu lv b">body</code>，以及URL <code class="fe ls lt lu lv b">hostname</code>、<code class="fe ls lt lu lv b">pathname</code>和<code class="fe ls lt lu lv b">query</code>字符串配置Polly来匹配请求。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="8ab0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，你所要做的就是在你的测试中给波利打电话。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="b5ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一次运行测试时，它们会调用服务器端点，并将其响应保存在文件系统中。该记录将用于所有后续运行，一旦过期，Polly将向您发出警告。</p><p id="bbca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，您可能希望Polly在您的机器上的行为不同于在CI上的行为。例如，我更喜欢只在我的机器<em class="ly">上创建录音</em>，并在CI上禁用它们。</p><p id="2108" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要创建这个逻辑，您可以利用<code class="fe ls lt lu lv b">CI</code>环境变量(至少在CircleCI或Travis上)进行如下配置:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="1b47" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Et voilà:快速、确定性的测试与保持与API一致的机制、良好的文档和简单的设置相结合。</p><p id="b1a3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">测试愉快！🚀</p></div></div>    
</body>
</html>