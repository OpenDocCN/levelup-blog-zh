<html>
<head>
<title>Introduction to Git Flow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Git流简介</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/introduction-to-git-flow-3ad331d097fa?source=collection_archive---------6-----------------------#2021-06-12">https://levelup.gitconnected.com/introduction-to-git-flow-3ad331d097fa?source=collection_archive---------6-----------------------#2021-06-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/ec0e177f3cb8a4ad39ab04575ea1f7fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:550/format:webp/1*-Wt5cIM3FpDRAv0C9kKhCA.png"/></div></figure><h1 id="7932" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">概观</h1><p id="bf11" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">Git流是Git工作流的抽象概念。它有助于持续的软件开发和实现DevOps实践。Git Flow工作流定义了一个围绕项目发布设计的严格的分支模型。这为管理大型项目提供了一个健壮的框架。</p><p id="64f2" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">Git流非常适合具有预定发布周期的项目，以及持续交付的DevOps最佳实践。<strong class="ku ir">它将非常具体的角色分配给不同的分支，并定义它们应该如何以及何时交互。它使用单独的分支来准备、维护和记录发布。</strong></p><h1 id="55be" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">Git流的工作</h1><h1 id="14db" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">1.发展和掌握分支机构</h1><p id="688b" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">Git Flow使用两个分支来记录项目的历史，而不是一个主分支。它基于两个具有无限生命周期的主要分支，即<strong class="ku ir">主控和开发</strong>。</p><ul class=""><li id="c17d" class="lv lw iq ku b kv lq kz lr ld lx lh ly ll lz lp ma mb mc md bi translated"><strong class="ku ir">主分支:</strong>主分支包含生产代码并存储官方发布历史。</li><li id="4180" class="lv lw iq ku b kv me kz mf ld mg lh mh ll mi lp ma mb mc md bi translated"><strong class="ku ir">开发分支:</strong>开发分支包含预生产代码，并作为特性的集成分支。</li></ul><p id="e45f" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">主分支和开发分支工作流在给定的图表中演示:</p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/e62aead3e0ad3d97bc9812e773749ade.png" data-original-src="https://miro.medium.com/v2/resize:fit:1124/format:webp/0*5JkyvsrYLG1uTICY.png"/></div></figure><p id="d543" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">用版本号标记主分支中的所有提交也很方便。</p><p id="a804" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">假设我们在总分行有回购协议。第一步是<strong class="ku ir">用一个开发分支</strong>来补充默认主文件。一个简单的方法是让一个开发人员在本地创建一个空的开发分支，并将其推送到服务器。这个分支将包含项目的完整历史。其他开发人员现在应该克隆中央存储库，并为develop创建一个跟踪分支。</p><h2 id="4ded" class="mo jv iq bd jw mp mq dn ka mr ms dp ke ld mt mu ki lh mv mw km ll mx my kq mz bi translated">1.1.创建开发分支</h2><p id="3d57" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">如果没有git-flow扩展:</p><ul class=""><li id="a250" class="lv lw iq ku b kv lq kz lr ld lx lh ly ll lz lp ma mb mc md bi translated"><code class="fe na nb nc nd b">git branch develop</code></li><li id="a941" class="lv lw iq ku b kv me kz mf ld mg lh mh ll mi lp ma mb mc md bi translated"><code class="fe na nb nc nd b">git push -u origin develop</code></li></ul><p id="c337" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">当使用git-flow扩展时:</p><ul class=""><li id="8b67" class="lv lw iq ku b kv lq kz lr ld lx lh ly ll lz lp ma mb mc md bi translated"><code class="fe na nb nc nd b">git flow init</code></li></ul><p id="addc" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">当使用git-flow扩展库时，在现有的repo上执行<code class="fe na nb nc nd b">git flow init </code>将创建develop分支。</p><h1 id="7e2f" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">2.特征分支</h1><p id="3b6a" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">每一个新特性都应该驻留在它的分支中，这个分支可以被推送到中央存储库进行备份/协作。特征分支使用最新开发的<strong class="ku ir">作为其父分支</strong>。当一个特性完成时，它会被<strong class="ku ir">合并回开发</strong>。特性应该<strong class="ku ir">永远不要与主</strong>分支<strong class="ku ir">直接交互。</strong></p><p id="b9af" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">特征分支工作流在给定的图表中演示:</p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/ba1fc77bc3f4a4ef1ca255be0173df8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1112/format:webp/0*HWcqXNq71UkaMBxo.png"/></div></figure><h2 id="422c" class="mo jv iq bd jw mp mq dn ka mr ms dp ke ld mt mu ki lh mv mw km ll mx my kq mz bi translated">2.1.创建特征分支</h2><p id="511e" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">没有git-flow扩展:</p><ul class=""><li id="dfbf" class="lv lw iq ku b kv lq kz lr ld lx lh ly ll lz lp ma mb mc md bi translated"><code class="fe na nb nc nd b">git checkout develop</code></li><li id="dff8" class="lv lw iq ku b kv me kz mf ld mg lh mh ll mi lp ma mb mc md bi translated"><code class="fe na nb nc nd b">git checkout -b feature_branch</code></li></ul><p id="5f74" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">使用git-flow扩展:</p><ul class=""><li id="8e27" class="lv lw iq ku b kv lq kz lr ld lx lh ly ll lz lp ma mb mc md bi translated"><code class="fe na nb nc nd b">git flow feature start feature_branch</code></li></ul><h2 id="6cef" class="mo jv iq bd jw mp mq dn ka mr ms dp ke ld mt mu ki lh mv mw km ll mx my kq mz bi translated">2.2.完成特征分支</h2><p id="ff39" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">没有git-flow扩展:</p><ul class=""><li id="7cc7" class="lv lw iq ku b kv lq kz lr ld lx lh ly ll lz lp ma mb mc md bi translated"><code class="fe na nb nc nd b">git checkout develop</code></li><li id="c70c" class="lv lw iq ku b kv me kz mf ld mg lh mh ll mi lp ma mb mc md bi translated"><code class="fe na nb nc nd b">git merge feature_branch</code></li></ul><p id="e55c" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">使用git-flow扩展:</p><ul class=""><li id="37ba" class="lv lw iq ku b kv lq kz lr ld lx lh ly ll lz lp ma mb mc md bi translated"><code class="fe na nb nc nd b">git flow feature finish feature_branch</code></li></ul><h1 id="19f0" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">3.发布分支</h1><p id="3b5d" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">一旦develop为一个发布获得了足够的特性(或者预定的发布日期即将到来)，我们<strong class="ku ir">从develop </strong>中分出一个发布分支。创建这个分支<strong class="ku ir">将开始下一个发布周期</strong>，因此在这之后不能添加新的特性——只有错误修复、文档生成和其他面向发布的任务应该放在这个分支中。发布分支可能从开发分支，并且<strong class="ku ir">必须合并到主和开发</strong>中。</p><p id="2856" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">在给定的图表中演示了发布分支工作流:</p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/8b1017ac909c3059fd4144802aee1bf8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1104/format:webp/0*U0pKOcwz-LK7F_Y1.png"/></div></figure><p id="9cbc" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">一旦发布分支准备好发布，它就被合并到主版本中，并且用版本号标记<strong class="ku ir">。此外，它应该被<strong class="ku ir">合并回开发中，因为关键更新可能已经被添加到</strong>发布分支中，并且它们需要被新特性访问。因此，一旦发布版本准备好发布，它将被合并到主开发中，然后<strong class="ku ir">发布分支将被删除</strong>。</strong></p><p id="3799" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">使用一个专门的分支来准备发布，使得一个团队可以改进当前的发布，而另一个团队可以继续为下一个发布开发特性。</p><h2 id="3d86" class="mo jv iq bd jw mp mq dn ka mr ms dp ke ld mt mu ki lh mv mw km ll mx my kq mz bi translated">3.1.创建发布分支</h2><p id="b022" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">如果没有git-flow扩展:</p><ul class=""><li id="d144" class="lv lw iq ku b kv lq kz lr ld lx lh ly ll lz lp ma mb mc md bi translated"><code class="fe na nb nc nd b">git checkout develop</code></li><li id="44e1" class="lv lw iq ku b kv me kz mf ld mg lh mh ll mi lp ma mb mc md bi translated"><code class="fe na nb nc nd b">git checkout -b release/0.1.0</code></li></ul><p id="142a" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">当使用git-flow扩展时:</p><ul class=""><li id="3f21" class="lv lw iq ku b kv lq kz lr ld lx lh ly ll lz lp ma mb mc md bi translated"><code class="fe na nb nc nd b">git flow release start 0.1.0</code></li><li id="7045" class="lv lw iq ku b kv me kz mf ld mg lh mh ll mi lp ma mb mc md bi translated"><code class="fe na nb nc nd b">Switched to a new branch 'release/0.1.0'</code></li></ul><h2 id="97e9" class="mo jv iq bd jw mp mq dn ka mr ms dp ke ld mt mu ki lh mv mw km ll mx my kq mz bi translated">3.2.完成发布分支</h2><p id="b5ba" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">没有git-flow扩展:</p><ul class=""><li id="98e3" class="lv lw iq ku b kv lq kz lr ld lx lh ly ll lz lp ma mb mc md bi translated"><code class="fe na nb nc nd b">git checkout master</code></li><li id="6126" class="lv lw iq ku b kv me kz mf ld mg lh mh ll mi lp ma mb mc md bi translated"><code class="fe na nb nc nd b">git merge release/0.1.0</code></li></ul><p id="39c5" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">使用git-flow扩展:</p><ul class=""><li id="1ad9" class="lv lw iq ku b kv lq kz lr ld lx lh ly ll lz lp ma mb mc md bi translated"><code class="fe na nb nc nd b">git flow release finish 0.1.0</code></li></ul><h1 id="d898" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">4.修补程序分支</h1><p id="a2c4" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">维护或“热修复”分支<strong class="ku ir">用于快速修补生产版本</strong>。热修复分支对于在不希望的主服务器状态下立即采取行动是必要的。热修复分支很像发布分支和特性分支，除了它们基于主分支而不是开发分支。这是唯一应该直接从主分叉的<strong class="ku ir">分支。一旦修复完成，它应该被<strong class="ku ir">合并到主和开发(或者当前发布分支)</strong>中，并且<strong class="ku ir">主分支应该被标记上更新的版本号</strong>。</strong></p><p id="e2f4" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">热修复分支工作流在给定的图表中演示:</p><figure class="mk ml mm mn gt jr gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/617fd7fe969a2aa95356912290f9cfcd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1110/format:webp/0*4l_7lT1qH1wv7I99.png"/></div></figure><p id="caad" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">拥有一个专门的bug修复开发线<strong class="ku ir">可以让你的团队在不中断工作流程的剩余部分</strong>或者等待下一个发布周期的情况下解决问题。</p><h2 id="0ab2" class="mo jv iq bd jw mp mq dn ka mr ms dp ke ld mt mu ki lh mv mw km ll mx my kq mz bi translated">4.1.创建修补程序分支</h2><p id="61ff" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">没有git-flow扩展:</p><ul class=""><li id="61dd" class="lv lw iq ku b kv lq kz lr ld lx lh ly ll lz lp ma mb mc md bi translated"><code class="fe na nb nc nd b">git checkout master</code></li><li id="f61e" class="lv lw iq ku b kv me kz mf ld mg lh mh ll mi lp ma mb mc md bi translated"><code class="fe na nb nc nd b">git checkout -b hotfix_branch</code></li></ul><p id="cf30" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">使用git-flow扩展:</p><ul class=""><li id="4481" class="lv lw iq ku b kv lq kz lr ld lx lh ly ll lz lp ma mb mc md bi translated"><code class="fe na nb nc nd b">git flow hotfix start hotfix_branch</code></li></ul><h2 id="5f4b" class="mo jv iq bd jw mp mq dn ka mr ms dp ke ld mt mu ki lh mv mw km ll mx my kq mz bi translated">4.2.完成修复分支</h2><p id="256e" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">没有git-flow扩展:</p><ul class=""><li id="aa4c" class="lv lw iq ku b kv lq kz lr ld lx lh ly ll lz lp ma mb mc md bi translated"><code class="fe na nb nc nd b">git checkout master</code></li><li id="8e7a" class="lv lw iq ku b kv me kz mf ld mg lh mh ll mi lp ma mb mc md bi translated"><code class="fe na nb nc nd b">git merge hotfix_branch</code></li><li id="7754" class="lv lw iq ku b kv me kz mf ld mg lh mh ll mi lp ma mb mc md bi translated"><code class="fe na nb nc nd b">git checkout develop</code></li><li id="ff23" class="lv lw iq ku b kv me kz mf ld mg lh mh ll mi lp ma mb mc md bi translated"><code class="fe na nb nc nd b">git merge hotfix_branch</code></li></ul><p id="cf2d" class="pw-post-body-paragraph ks kt iq ku b kv lq kx ky kz lr lb lc ld ls lf lg lh lt lj lk ll lu ln lo lp ij bi translated">使用git-flow扩展:</p><ul class=""><li id="57c1" class="lv lw iq ku b kv lq kz lr ld lx lh ly ll lz lp ma mb mc md bi translated"><code class="fe na nb nc nd b">git branch -D hotfix_branch</code></li><li id="f886" class="lv lw iq ku b kv me kz mf ld mg lh mh ll mi lp ma mb mc md bi translated"><code class="fe na nb nc nd b">git flow hotfix finish hotfix_branch</code></li></ul><h1 id="afac" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">Git流的优势</h1><p id="96d7" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">现在让我们总结一下Git flow提供的主要优势:</p><ul class=""><li id="6cbc" class="lv lw iq ku b kv lq kz lr ld lx lh ly ll lz lp ma mb mc md bi translated">确保在项目生命周期的任何给定时刻，分支都处于干净的状态</li><li id="9236" class="lv lw iq ku b kv me kz mf ld mg lh mh ll mi lp ma mb mc md bi translated">分支的命名约定遵循一个系统化的模式，这样更容易理解</li><li id="fbe7" class="lv lw iq ku b kv me kz mf ld mg lh mh ll mi lp ma mb mc md bi translated">在大多数使用的git工具上有扩展和支持</li><li id="099d" class="lv lw iq ku b kv me kz mf ld mg lh mh ll mi lp ma mb mc md bi translated">非常适合在生产中维护多个版本的情况</li><li id="5d57" class="lv lw iq ku b kv me kz mf ld mg lh mh ll mi lp ma mb mc md bi translated">非常适合基于发布的软件工作流。</li><li id="a571" class="lv lw iq ku b kv me kz mf ld mg lh mh ll mi lp ma mb mc md bi translated">为生产热修复提供专用渠道。</li></ul><h1 id="55db" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">Git流的缺点</h1><p id="0938" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">没有什么是理想的，所以Git流也有一些缺点，比如:</p><ul class=""><li id="7fa5" class="lv lw iq ku b kv lq kz lr ld lx lh ly ll lz lp ma mb mc md bi translated">Git历史变得不可读</li><li id="0940" class="lv lw iq ku b kv me kz mf ld mg lh mh ll mi lp ma mb mc md bi translated">主/开发分支的分离被认为是多余的，并且使得连续交付/集成更加困难</li><li id="3ae1" class="lv lw iq ku b kv me kz mf ld mg lh mh ll mi lp ma mb mc md bi translated">在生产中维护单一版本的情况下，不建议使用</li></ul><h1 id="ea3a" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">摘要</h1><p id="f171" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">这里我们讨论了Git流工作流。Git流是您和您的团队可以利用的许多Git工作流风格之一。让我们总结一下Git Flow的整个工作流程:</p><ul class=""><li id="bff6" class="lv lw iq ku b kv lq kz lr ld lx lh ly ll lz lp ma mb mc md bi translated">开发分支是从主文件创建的</li><li id="5c4a" class="lv lw iq ku b kv me kz mf ld mg lh mh ll mi lp ma mb mc md bi translated">特征分支是从开发中创建的</li><li id="d4c1" class="lv lw iq ku b kv me kz mf ld mg lh mh ll mi lp ma mb mc md bi translated">当一个特征完成时，它被合并到开发分支中</li><li id="72f1" class="lv lw iq ku b kv me kz mf ld mg lh mh ll mi lp ma mb mc md bi translated">发布分支是从开发中创建的</li><li id="7366" class="lv lw iq ku b kv me kz mf ld mg lh mh ll mi lp ma mb mc md bi translated">当发布分支完成后，它将被合并到开发和主控中</li><li id="b3a8" class="lv lw iq ku b kv me kz mf ld mg lh mh ll mi lp ma mb mc md bi translated">如果检测到主服务器中有问题，将从主服务器创建一个热修复分支</li><li id="8ffc" class="lv lw iq ku b kv me kz mf ld mg lh mh ll mi lp ma mb mc md bi translated">一旦修补程序完成，它将被合并到开发人员和主控人员</li></ul></div></div>    
</body>
</html>