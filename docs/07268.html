<html>
<head>
<title>Kubernetes is deprecating Docker in 2021</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes在2021年贬低Docker</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/kubernetes-is-deprecating-docker-in-2021-fa8317f9f070?source=collection_archive---------3-----------------------#2021-02-05">https://levelup.gitconnected.com/kubernetes-is-deprecating-docker-in-2021-fa8317f9f070?source=collection_archive---------3-----------------------#2021-02-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4e4f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Docker的结尾是？</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/cd068d8c724b45410a5fcafb790326ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XF4kX2toI9_AiC_W1ZnXLA.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">乌斯曼·尤萨夫在<a class="ae kv" href="https://unsplash.com/s/photos/panic?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="341f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在版本<a class="ae kv" href="https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG/CHANGELOG-1.20.md#deprecation" rel="noopener ugc nofollow" target="_blank"> 1.20 </a>之后，Kubernetes不再将Docker作为容器运行时。</p><p id="abe4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Docker作为一个底层运行时正在被弃用，取而代之的是使用为Kubernetes创建的<a class="ae kv" href="https://kubernetes.io/blog/2016/12/container-runtime-interface-cri-in-kubernetes/" rel="noopener ugc nofollow" target="_blank">容器运行时接口(CRI) </a>的运行时。</p><p id="766c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你是Kubernetes的终端用户，并不会给你带来太大的改变。这并不意味着Docker的消亡，也不意味着你不能或者不应该再使用Docker作为开发工具。Docker仍然是构建容器的有用工具，运行docker build生成的映像仍然可以在您的Kubernetes集群中运行。</p><p id="7be3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您使用的是托管的Kubernetes服务，比如GKE、EKS或AKS(默认情况下是容器化的)，那么在未来的Kubernetes版本中移除Docker支持之前，您需要确保您的工作节点使用的是受支持的容器运行时。如果您有节点定制，您可能需要根据您的环境和运行时需求来更新它们。</p><p id="b722" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您想要推出自己的集群，您还需要进行更改以避免集群崩溃。在1.20版中，您将收到Docker弃用警告。如果在未来的Kubernetes版本中删除了docker运行时支持(<strong class="ky ir">目前计划在2021年</strong>下半年成为1.22版本)，将不再支持它，您需要切换到其他兼容的容器运行时，如containerd或CRI -O。只要确保您选择的运行时支持当前使用的Docker守护进程的配置(如日志记录)。</p><h2 id="8360" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">那么，为什么人们看到这个公告时会感到恐慌呢？</h2><p id="cda7" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">两种环境正在被讨论，这造成了混乱。在Kubernetes集群中，有一个叫做容器运行时的东西，它负责获取和运行容器映像。Docker是该运行时的一个流行选择，但是Docker没有被设计成嵌入到Kubernetes中，这就导致了问题。</p><p id="af82" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Docker 是一个完整的技术堆栈，其中一部分是一个名为“containerd”的东西，它本身就是一个高级容器运行时。Docker很酷也很有用，因为它有许多UX增强功能，使得在进行开发工作时与人交互变得非常容易，但对于Kubernetes来说，这些UX增强功能是不必要的，因为它不是人类。</p><p id="a841" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为这个用户友好的抽象层，Kubernetes必须使用另一个叫做Dockershim的工具来获得它真正需要的东西，这个工具就是containerd。这并不伟大，因为它提供了另一个必须维护并且可能被损坏的东西。事实上，这里发生的事情是，Dockershim最早将在1.23版本中从Kubelet中移除，从而移除对Docker作为容器运行时的支持。</p><h2 id="baea" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">为什么需要Dockershim？</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mr"><img src="../Images/5b9ce21195012ab03f54a1fe2b0745cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4H3hV0Y_ov9mMUFwKey4Mg.png"/></div></div></figure><p id="6204" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Docker与CRI不兼容，<a class="ae kv" href="https://kubernetes.io/blog/2016/12/container-runtime-interface-cri-in-kubernetes/" rel="noopener ugc nofollow" target="_blank">容器运行时接口</a>。如果是的话，我们就不需要垫片了，这就不是一件事了。</p><p id="5dd1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Dockershim是由Kubernetes社区提出的一个临时解决方案(因此得名:shim ),目的是增加对Docker的支持，以便它可以用作其容器运行时。Dockershim的弃用，只是意味着将停止Dockershim在Kubernetes代码库中的代码维护。</p><p id="135e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是因为Dockershim已经成为Kubernetes维护者的沉重负担。随着这一变化，Kubernetes社区将只能维护Kubernetes容器运行时接口(CRI)。</p><h2 id="9c60" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">我们继续使用Dockerfiles吗？</h2><p id="7b7e" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">这一变化针对的是一个不同于大多数开发人员用来与Docker交互的环境。开发中使用的Docker安装与Kubernetes集群中的Docker运行时无关。</p><p id="b6d3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">作为一名开发人员，Docker在所有方面仍然是有用的，就像这个变化宣布之前一样。Docker产生的形象并不是Docker特有的形象——它是OCI ( <a class="ae kv" href="https://opencontainers.org/" rel="noopener ugc nofollow" target="_blank">开放集装箱倡议</a>)的形象。任何符合OCI标准的图像，不管你用什么工具构建，在Kubernetes看来都是一样的。containerd和CRI-O都知道如何提取和运行这些图像。</p><h2 id="f741" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated"><strong class="ak">更改CRI实施时，我们应该验证什么？</strong></h2><p id="32d5" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">尽管Docker和大多数CRI之间的底层容器化代码是相同的，但在边缘处还是有一些差异。迁移时要考虑的一些常见事项有:</p><ul class=""><li id="38eb" class="ms mt iq ky b kz la lc ld lf mu lj mv ln mw lr mx my mz na bi translated">日志记录配置</li><li id="a783" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated">运行时资源限制</li><li id="8906" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated">通过docker的控制套接字调用或使用docker的节点配置脚本</li><li id="86c3" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated">需要docker CLI或控制套接字的Kubectl插件</li><li id="79a6" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated">需要直接访问Docker的Kubernetes工具(例如kube-imagepuller)</li><li id="fa29" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated">像<code class="fe ng nh ni nj b">registry-mirrors</code>和不安全注册中心这样的功能配置</li><li id="43c7" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated">其他支持脚本或守护进程期望Docker可用，并在Kubernetes之外运行(例如监控或安全代理)</li><li id="822b" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated">GPU或特殊硬件，以及它们如何与您的运行时和Kubernetes集成</li></ul><h2 id="8740" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">结论</h2><p id="497c" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">所以，这种改变正在到来。它会给一些人带来问题，但不是灾难性的，一般来说，这是一件好事。取决于你如何与Kubernetes互动，这可能对你没有任何意义，或者它可能意味着一些工作。从长远来看，这将使事情变得更容易。</p></div></div>    
</body>
</html>