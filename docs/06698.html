<html>
<head>
<title>Utilizing GitHub Actions to build and test your project on multiple platforms</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用GitHub动作在多个平台上构建和测试您的项目</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/utilizing-github-actions-to-build-and-test-on-multiple-platforms-a7fe3aa6ce2a?source=collection_archive---------4-----------------------#2020-12-21">https://levelup.gitconnected.com/utilizing-github-actions-to-build-and-test-on-multiple-platforms-a7fe3aa6ce2a?source=collection_archive---------4-----------------------#2020-12-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="7a7a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我如何在三个不同的平台上构建和测试一个C++应用程序。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/bb656ea3ed56709d2d1aec13ac61ee76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_kINOuyWDkL0Kl3e.png"/></div></div></figure><p id="3e4c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">无论您使用C、C++、Java、Python还是<em class="kx">在此插入选择的语言</em>，有一点是肯定的:为多个平台构建和测试您的项目是困难的。无论您使用哪种语言，每个平台都有细微差别，在不同程度上可能需要对我们编写的代码、我们实现的构建系统或两者都进行更改。在考虑这些问题之前，您首先需要访问所有的目标平台！</p><p id="567c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对我来说不幸的是，我不得不处理我在从事业余编程项目<a class="ae ky" href="https://github.com/lambda-sh/lamscript" rel="noopener ugc nofollow" target="_blank"> Lamscript </a>时列出的所有上述问题。该项目是用C++编写的，我利用<a class="ae ky" href="https://cmake.org/" rel="noopener ugc nofollow" target="_blank"> CMake </a> &amp; <a class="ae ky" href="https://www.gnu.org/software/make/manual/make.html" rel="noopener ugc nofollow" target="_blank"> Make </a>在我基于Linux的系统上配置、编译和链接该项目。虽然我创建的构建过程在Linux上运行得非常好，但我想将项目扩展到MacOS和Windows上，使它更容易访问。这时我才知道在另一个平台上构建一个项目是多么令人沮丧和复杂。虽然获得对MacOS/Windows操作系统的虚拟访问并不困难，但是开发一种直接从我的代码库到平台上持续构建&amp;测试项目的方法。对我来说幸运的是，我不需要看很远就能发现<a class="ae ky" href="https://github.com/features/actions" rel="noopener ugc nofollow" target="_blank"> GitHub Actions </a>及其潜力。</p><p id="3eed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你已经或正在使用GitHub，你很可能听说过GitHub的动作。我知道在将它集成到Lamscript之前我是这样做的，但是我并没有完全理解它的功能以及它如何对我有用。在通读GitHub和其他使用该平台解决与我面临的问题类似的问题的开发人员提供的所有文档时，我觉得没有任何文档能够抓住如何使用GitHub操作的要点，而是只关注他们的特定用例。这导致了大量的交叉引用，花费了大量的时间来区分GitHub操作的预期和实际行为，并对当前的构建系统进行了大量的更改，以使其可以在CI系统中运行，如GitHub操作和多个平台。虽然我将使用我创建的GitHub action config来演示GitHub Actions的一些功能，但我计划展示我在使用该工具方面学到的东西，以及我认为什么使它最有效，而不深入我的项目的细节。事不宜迟，让我向您展示我是如何用不到100行配置在多个平台上一致地构建和测试Lamscript的。</p><h1 id="832c" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">入门指南</h1><p id="2290" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">为了使用GitHub动作，您必须:</p><ol class=""><li id="63d1" class="mc md iq jp b jq jr ju jv jy me kc mf kg mg kk mh mi mj mk bi translated">拥有GitHub帐户</li><li id="d853" class="mc md iq jp b jq ml ju mm jy mn kc mo kg mp kk mh mi mj mk bi translated">拥有一个项目(公共或私人)</li></ol><p id="3a1d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">很简单，不是吗？一旦这两个先决条件得到满足，就可以开始用两种不同的方法设置GitHub动作。</p><ul class=""><li id="0129" class="mc md iq jp b jq jr ju jv jy me kc mf kg mg kk mq mi mj mk bi translated"><strong class="jp ir">图形化</strong> —每个项目都有一个actions选项卡，允许你创建、更新和管理GitHub动作。提供了一些不错的模板，但是我不会讨论这个方法，因为它实际上与通过下一个方法在你的文本编辑器中做的是一样的。</li><li id="7caf" class="mc md iq jp b jq ml ju mm jy mn kc mo kg mp kk mq mi mj mk bi translated"><strong class="jp ir">编辑器</strong> —在您的项目根目录中，(您的项目<code class="fe mr ms mt mu b">.git </code>文件夹所在的位置)，您可以通过创建文件夹<code class="fe mr ms mt mu b">.github</code>然后创建嵌套文件夹:<code class="fe mr ms mt mu b">.github/workflows</code>来开始创建GitHub动作。创建了文件夹后，我们现在可以开始创建yaml配置文件，这些文件描述了在我们的操作中应该发生的事情。</li></ul><p id="6d42" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个示例文件路径和我在Lamscript中使用的路径如下:<code class="fe mr ms mt mu b">.github/workflows/compile_and_test.yml</code>。但是您可以随意使用您创建的GitHub动作的名称。该操作的唯一约束是文件内容由有效的yaml组成。</p><p id="980e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">GitHub动作使用yaml来描述你希望GitHub执行的动作，给定你围绕该动作设置的约束。虽然我无法在本文中介绍yaml，但总结它的最简单方法是将它视为使用JSON配置和保存设置的替代方法。记住这一点，在分解主要组件之前，让我们先来看看我创建的整个配置。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mv mw l"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">用于编译和测试我的编程语言Lamscript的整个Github操作。</figcaption></figure><p id="5865" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">根据你对GitHub操作的熟悉程度，这可能看起来很可怕，也可能看起来不可怕，但是一旦我们完成了这个配置所描述的内容，它就会变得更有意义。关于配置的整体，最重要的是<em class="kx">只描述了一次构建我们项目的步骤。</em></p><h1 id="0076" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">定义我们的行动</h1><p id="23b4" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">首先，我们需要给我们的行动起一个名字。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mv mw l"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">将我们的构建管道命名为“编译和测试”。</figcaption></figure><p id="10fc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每当我们触发Actions选项卡时，该名称就会显示在其中。为了触发这个动作，我们需要指定事件的类型和与这些事件相关的数据，这个动作应该监听和响应这些事件。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mv mw l"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">GitHub操作的触发器</figcaption></figure><p id="dd7e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我的配置中，我告诉GitHub我想让这个动作监听Lamscript内部的分支<code class="fe mr ms mt mu b">main</code>上发生的任何<code class="fe mr ms mt mu b">push</code>或<code class="fe mr ms mt mu b">pull_request</code>。<code class="fe mr ms mt mu b">workflow_dispatch </code>允许您从GitHub Actions标签中触发动作。您可以为您的操作指定尽可能多的分支来响应，但是私有项目被限制为每月2000分钟的运行时间。这实际上给了你每月可以运行的有限数量的动作，与动作运行的时间成比例。</p><blockquote class="nb nc nd"><p id="09cb" class="jn jo kx jp b jq jr js jt ju jv jw jx ne jz ka kb nf kd ke kf ng kh ki kj kk ij bi translated">每月2000分钟/每个动作4分钟=每月500个动作</p></blockquote><p id="7a88" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">描述我们操作的最后一条元信息是为设置步骤而隐式设置的默认值</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mv mw l"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">默认情况下，我们的GitHub操作作业对任何shell命令都使用bash。</figcaption></figure><p id="4720" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该位设置默认shell，供<code class="fe mr ms mt mu b">run</code>命令使用bash。您可以在这里指定您喜欢的任何shell，但是bash受Linux、MacOS甚至Windows的git-bash 支持。</p><p id="c390" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">已经编写了bash脚本来完成Linux的所有设置、构建和测试；GitHub Actions允许在所有平台上使用bash，这使我能够在所有平台上使用相同的脚本，而不必(太)担心特定于平台的系统。我不会过多地详细介绍这些脚本，但是如果您对我的构建过程感兴趣，我会在最后提供每个脚本的链接。现在，是时候来布局一下这个动作本身最重要的部分了:<code class="fe mr ms mt mu b">jobs</code>。</p><h1 id="0bd2" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">作业和步骤</h1><p id="dcf2" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">作业是当GitHub上的活动触发动作时预期运行的步骤。默认情况下，作业并行运行，但可以设置为依赖于另一个作业的完成，从而允许它们线性运行。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mv mw l"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">将作业build_and_test添加到GitHub操作中。</figcaption></figure><p id="6b80" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mr ms mt mu b">build_and_test</code>成为作业的名称，是执行该作业所需的所有信息的映射。下面，我们设置构建的名称以及它运行的平台。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mv mw l"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">运行时作业build_and_test将执行并验证成功的步骤。</figcaption></figure><p id="4c88" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mr ms mt mu b">name</code> —定义作业的名称。这将显示在GitHub Actions选项卡中。</p><p id="24a7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mr ms mt mu b">${{ matrix.os }}</code> —存储在<code class="fe mr ms mt mu b">matrix</code>中的变量<code class="fe mr ms mt mu b">os</code>的评估。我们稍后会更详细地讨论这个问题，但是把<code class="fe mr ms mt mu b">matrix</code>想象成一个存储当前构建信息的地图。<code class="fe mr ms mt mu b">os</code>是映射的一个属性，它包含运行构建的当前操作系统的名称。</p><p id="fb82" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mr ms mt mu b">${{ matrix.compiler }}</code> —存储在<code class="fe mr ms mt mu b">matrix</code>中的变量<code class="fe mr ms mt mu b">compiler</code>的另一次评估。我们稍后还将介绍这是从哪里来的，但它只是用于当前工作的编译器。</p><p id="921d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mr ms mt mu b">runs-on</code> —定义运行该构建的平台。我们使用前面提到的<code class="fe mr ms mt mu b">matrix.os</code>变量来获取我们的构建将在其上运行的当前操作系统。</p><h1 id="2339" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">矩阵从何而来？</h1><p id="bfc3" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">通过定义一个<code class="fe mr ms mt mu b">strategy</code>将<code class="fe mr ms mt mu b">matrix</code>赋予我们的构建。一个<code class="fe mr ms mt mu b">strategy</code>允许我们通过从我们提供的数据构建所有可能组合的<code class="fe mr ms mt mu b">matrix</code>来定义多个要运行的作业。这听起来很多，所以让我们来看看yaml并解开它。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mv mw l"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">如何运行作业构建和测试的策略以及每次运行中使用的变量。</figcaption></figure><p id="472a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mr ms mt mu b">strategy</code> —允许我们配置当前作业，以利用<code class="fe mr ms mt mu b">matrix</code>来存储关于我们想要生成的构建类型的信息，并允许他们访问。</p><p id="db4d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mr ms mt mu b">matrix</code> —存储我们想要用来创建多个工作的信息。</p><p id="a346" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mr ms mt mu b">os</code> —我们希望为其运行作业的一系列不同的操作系统。</p><p id="0999" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mr ms mt mu b">compiler</code> —我们希望为其运行作业的一系列编译器。</p><p id="6042" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们进一步讨论之前，让我们先来看看矩阵中的这些定义值:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mv mw l"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">具有两个变量的简单矩阵，每个变量存储一个或多个唯一值的数组。</figcaption></figure><p id="547c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该矩阵将产生两个总构建，如下所示:</p><pre class="km kn ko kp gt nh mu ni nj aw nk bi"><span id="3c8f" class="nl la iq mu b gy nm nn l no np"># First build<br/>${{ matrix.os }} -&gt; ubuntu-latest<br/>${{ matrix.compiler }} -&gt; g++-10</span><span id="af90" class="nl la iq mu b gy nq nn l no np"># Second build<br/>${{ matrix.os }} -&gt; macos-latest<br/>${{ matrix.compiler }} -&gt; g++-10</span></pre><p id="2c88" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">理解这一步非常关键。我们的矩阵定义允许我们通过创建我们提供的所有可能的数据组合来生成2个不同的作业。为了<code class="fe mr ms mt mu b">include</code>一个特定的作业或覆盖一个将由<code class="fe mr ms mt mu b">matrix</code>创建的作业，您只需像前面一样使它成为矩阵的一个属性:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="d16b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mr ms mt mu b">include</code>中的前两项覆盖了我们之前的两个构建，提供了一个名为<code class="fe mr ms mt mu b">target</code>的新数据。<code class="fe mr ms mt mu b">target</code>是一个属性，我的bash脚本将使用它来确定正在编译的操作系统，并运行特定于我的项目的命令。<code class="fe mr ms mt mu b">include</code>中的最后一项添加了一个新任务，其属性为:</p><pre class="km kn ko kp gt nh mu ni nj aw nk bi"><span id="4bc5" class="nl la iq mu b gy nm nn l no np"># Third build<br/>${{ matrix.os }} -&gt; windows-latest<br/>${{ matrix.compiler }} -&gt; cl<br/>${{ matrix.target }} -&gt; Windows</span></pre><p id="13bb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">总的来说，我们现在有3个不同的作业，它们将利用我们在<code class="fe mr ms mt mu b">matrix</code>中定义的属性来填充我们的动作属性的元数据，以及每个作业将采取的完成步骤。通过利用<code class="fe mr ms mt mu b">strategy</code>,我们现在已经在一个要运行的作业定义中定义了3个作业，现在我们需要做的就是创建所有这些作业将采取的步骤。</p><h1 id="6937" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">走向终点线</h1><p id="444e" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">最后，是时候定义这个动作要完成的步骤了。如果这些步骤中的任何一个在任何一个构建中失败，那么整个操作都会失败。下面是三个作业中的每个作业在构建Lamscript时将执行的所有步骤。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mv mw l"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">作业构建和测试的所有步骤</figcaption></figure><p id="167f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mr ms mt mu b">steps</code>是我们工作的一个属性，作为工作应该执行的线性步骤集。让我们按发生的时间来分解这些步骤:</p><ol class=""><li id="6079" class="mc md iq jp b jq jr ju jv jy me kc mf kg mg kk mh mi mj mk bi translated"><strong class="jp ir">结账</strong></li></ol><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mv mw l"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">使用预定义的GitHub操作步骤的Checkout命令。</figcaption></figure><p id="43dd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这将检查运行到我的项目的git目录中的当前作业。这允许我运行所有的脚本，就好像您要手动构建它一样。</p><p id="4fd4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mr ms mt mu b">uses:actions/checkout@v2 </code> —定义用于当前步骤的动作。GitHub动作最酷的一点是，你可以在自己的构建管道中使用GitHub上的任何动作。这使您能够自动完成原本需要自己完成的任务。</p><p id="7d98" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2.<strong class="jp ir"> Lamscript设置</strong></p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mv mw l"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">运行我的项目的安装脚本。</figcaption></figure><p id="0d10" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在签入项目目录后，我运行<code class="fe mr ms mt mu b">./scripts/setup.sh</code>来设置项目，并传入<code class="fe mr ms mt mu b">--within-ci true</code>来让脚本知道它正在CI环境中运行。这仅与Lamscript相关，因为我的设置脚本能够设置带有额外依赖项的开发环境，但是在CI中不需要它们来验证我们的构建。</p><p id="45e3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mr ms mt mu b">runs</code> —允许我们在当前任务上运行命令。还记得我们设置默认<code class="fe mr ms mt mu b">shells</code>为bash吗？这保证了所有平台都利用bash来执行我们的命令。</p><p id="b1a1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3.<strong class="jp ir">为Windows配置</strong></p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mv mw l"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">仅当当前操作系统是windows时才运行的步骤。</figcaption></figure><p id="50ed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们的设置之后，这个下一步是一个<em class="kx">条件步骤</em>，它仅在<code class="fe mr ms mt mu b">matrix.os</code>的当前值为<code class="fe mr ms mt mu b">windows-latest</code>时运行。每个作业都会评估该步骤，但该步骤仅在windows作业中运行。这一步在Linux或MacOS环境中不起作用，但在Windows环境中绝对需要。如果条件评估为真，则执行该步骤。如果条件评估为false，则跳过该步骤并继续作业。</p><p id="4be2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mr ms mt mu b">uses: microsoft/estup-msbuild@v1.0.2</code> —是微软提供的一个动作，将最新版本的MSBuild添加到应用程序路径中。我的脚本使用它在不使用Visual Studio的情况下在Windows上构建Lamscript。</p><p id="fb68" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">4.<strong class="jp ir">编译、链接和生产我们的工件</strong></p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mv mw l"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">使用矩阵提供的值编译Lamscript的发布版本。</figcaption></figure><p id="4a91" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们的环境已经设置好了，是时候构建我们的项目了。使用绑定到当前作业的属性，我们利用<code class="fe mr ms mt mu b">matrix.compiler</code>使用哪个编译器，利用<code class="fe mr ms mt mu b">matrix.target</code>获得期望的平台。同样，这个脚本高度特定于我的项目，可以通过编写自己的脚本或简单地在步骤本身内部编写bash来实现。在这一步中发生的最重要的事情是，由于每个作业都有相似的属性和唯一的值，脚本在每个作业上生成一个工作构建。</p><p id="ebda" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">5.<strong class="jp ir">运行所有测试</strong></p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mv mw l"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">运行Lamscript的测试运行程序。</figcaption></figure><p id="8949" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我运行所有的测试来验证一切都正常工作。如果是的话，那么这个任务就完成了，这个构建被验证为正在工作并被测试！如果没有，我想我还有工作要做！</p><h1 id="bd78" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">结果呢</h1><p id="a9f3" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">下面是我刚才带你看的GitHub中的动作。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nr"><img src="../Images/5296e9ae2bcb301eb539f4bade367fd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a308R8ELEC8F8kF-NNkdLw.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">由主分支触发的操作</figcaption></figure><p id="4496" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">“总体”菜单显示了在矩阵中运行的所有构建的状态。每个作业彼此并行运行，并允许您查看该作业执行的所有步骤的状态和输出。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ns"><img src="../Images/51534a3969a976443b1734040fda1163.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gApSOVh7iqxF9_i0IsYbmQ.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">用gcc-10在Ubuntu上构建Lamscript的步骤。</figcaption></figure><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nr"><img src="../Images/1000ca0d020ea9b78f65e0180a0b48a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rBBG1nTYjYhV3lt9Fc0MCQ.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">用g++-10在MacOS上构建Lamscript的步骤。</figcaption></figure><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nt"><img src="../Images/4099fa2626a984beea6338adc9bf1111.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lcb7MH4hSmX0wL3YNBBHQw.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">用cl在Windows上构建Lamscript的步骤。</figcaption></figure><p id="512a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">经过几天的努力，我终于能够创建一个工作流，让我能够在我打算支持的所有平台上轻松地构建和测试我的代码。我希望这个关于我如何使用GitHub Actions的演示能帮助你理解这个平台是什么，以及它如何潜在地应用在你的工作流程中。</p><h1 id="341a" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">资源</h1><ul class=""><li id="7e62" class="mc md iq jp b jq lx ju ly jy nu kc nv kg nw kk mq mi mj mk bi translated">Lamscript  —这个项目用来演示GitHub动作是如何工作的。</li><li id="f3cb" class="mc md iq jp b jq ml ju mm jy mn kc mo kg mp kk mq mi mj mk bi translated"><a class="ae ky" href="https://github.com/lambda-sh/lamscript/actions/runs/432761465" rel="noopener ugc nofollow" target="_blank">路过岗位截图</a></li><li id="ce08" class="mc md iq jp b jq ml ju mm jy mn kc mo kg mp kk mq mi mj mk bi translated"><a class="ae ky" href="https://github.com/features/actions" rel="noopener ugc nofollow" target="_blank"> GitHub动作</a></li><li id="9120" class="mc md iq jp b jq ml ju mm jy mn kc mo kg mp kk mq mi mj mk bi translated"><a class="ae ky" href="https://docs.github.com/en/free-pro-team@latest/actions" rel="noopener ugc nofollow" target="_blank"> GitHub动作文档</a></li></ul></div></div>    
</body>
</html>