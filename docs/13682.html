<html>
<head>
<title>DynamoDB: 5 specific ways to supercharge your database design</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">DynamoDB:增强数据库设计的5种具体方法</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/dynamodb-5-specific-ways-to-supercharge-your-database-design-574ffb7f5b8a?source=collection_archive---------4-----------------------#2022-09-27">https://levelup.gitconnected.com/dynamodb-5-specific-ways-to-supercharge-your-database-design-574ffb7f5b8a?source=collection_archive---------4-----------------------#2022-09-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/d710b17057736477a9ca03b70791113a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KgHnG6nhDKt3NRNSxI07Jg.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">信用数字云培训</figcaption></figure><p id="be1a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">你已经开始开发你的第一个无服务器应用程序，你对后端应用程序的设计略知一二，但你也曾使用过Express或任何后端框架，以及Prisma、Sequelize或TypeORM等ORM后面的Postgres。不管出于什么原因，我们决定使用AWS无服务器堆栈来构建一个新的服务。到了栈的数据库部分，DynamoDB几乎总是且唯一是AWS无服务器世界中的首选数据库。</p><p id="81de" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">你开始思考:等等，这个“数据库”不支持连接吗？难道<strong class="ke ir">只有一桌</strong>？这肯定是一个恶心的玩笑😳？天啊，你只能基于<strong class="ke ir">主键</strong>来查询数据，至于什么是<strong class="ke ir">哈希键</strong>，什么是<strong class="ke ir">排序键</strong>排序到底是什么？如果我需要基于主键以外的任何东西进行查询，我需要一个<strong class="ke ir">全局二级索引</strong>吗？这到底是什么意思🤦🏻‍♂️?</p><figure class="lb lc ld le gt jr gh gi paragraph-image"><div class="gh gi la"><img src="../Images/f58aac9d9fcfb62e5db6b23969743746.png" data-original-src="https://miro.medium.com/v2/resize:fit:750/1*nvBQresjucE1wqUSTVDP7w.gif"/></div></figure><p id="6b85" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">对于我们中的许多人来说，当我们刚刚开始使用DynamoDB时，这些问题是值得关注的。毕竟，这不是我们在大学里学到的，也不是我们过去几十年一直在做的。</p><p id="0f06" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">但是这里有一个好消息:一旦你真正理解了DynamoDB的用途、它的基本原理，并且对你要构建的应用程序有了很好的理解，你就会开始觉得有点神奇了！无限可扩展，具有非常低的延迟数，并且不需要维护任何基础架构。更好的是，我认为如果你的数据库设计得很好，你甚至不需要像Redis这样的内存缓存！</p><p id="e475" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">好了，下面是提升DynamoDB设计水平的5种具体方法。</p></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><h1 id="08a1" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">I .熟悉特定于DynamoDB的概念</h1><p id="c4cf" class="pw-post-body-paragraph kc kd iq ke b kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz ij bi translated">DynamoDB与行业标准的SQL和NoSQL数据库有一些共同的数据库概念，但也有许多只适用于它的概念。让我们看看一些特定于DynamoDB的概念，并讨论它们的重要性。</p><h2 id="8021" class="mp ln iq bd lo mq mr dn ls ms mt dp lw kn mu mv ma kr mw mx me kv my mz mi na bi translated"><strong class="ak"> <em class="nb">分区</em> </strong></h2><p id="990a" class="pw-post-body-paragraph kc kd iq ke b kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz ij bi translated">我相信这是真正理解的最关键的一块。从表面上看，DynamoDB数据库只是一个表。但这种数据库适用于亚马逊、Snap、迪士尼和Zoom等大公司的原因很大程度上与分区有关。当您在DynamoDB中存储一个项目时，它会被分配一个分区。</p><p id="7745" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">分区是由SSD驱动器支持的逻辑空间，将保存您存储的数据。您不需要创建分区，而是根据分配给给定项目的分区键来确定分区。这是允许DynamoDB如此好地伸缩的许多属性之一:理想情况下，尽管它是一个表，但数据应该均匀地分布在只存在于幕后的分区中。</p><p id="c78f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这里，您的心理模型应该从<strong class="ke ir">表和行</strong>变为同一个分区上的<strong class="ke ir">分区和项目</strong>。</p><h2 id="a37a" class="mp ln iq bd lo mq mr dn ls ms mt dp lw kn mu mv ma kr mw mx me kv my mz mi na bi translated">分区键(散列键)</h2><p id="bc59" class="pw-post-body-paragraph kc kd iq ke b kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz ij bi translated">如果您有关系背景，或者在大学里学过数据库设计课程，在那里您很可能学习了SQL、规范化和关系等知识，那么您可能会认为分区键相当于SQL中的主键。不完全是！</p><p id="3583" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">虽然分区键可以用来惟一地标识给定DynamoDB数据库中的一个项目，但是它的主要功能是确定DynamoDB在后台将您的项目存储在键空间的什么位置。因此，在选择分区键时，一定要非常慎重和有目的，它们对于一个好的DynamoDB数据库设计是绝对必要的。</p><h2 id="6366" class="mp ln iq bd lo mq mr dn ls ms mt dp lw kn mu mv ma kr mw mx me kv my mz mi na bi translated">分类关键字(范围关键字)</h2><p id="e752" class="pw-post-body-paragraph kc kd iq ke b kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz ij bi translated">一旦DynamoDB确定了在后台使用哪个分区来存储您的项目，它就会使用range键对同一个分区上的多个项目进行排序。</p><p id="1c45" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">默认情况下，当您在Dynamo中运行查询操作时，您会得到一个条目数组，这些条目根据排序键按升序排序。</p><p id="65ee" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这里有个问题，我发现人们很怀念这个:</p><blockquote class="nd ne nf"><p id="e4d8" class="kc kd ng ke b kf kg kh ki kj kk kl km nh ko kp kq ni ks kt ku nj kw kx ky kz ij bi translated">一个项目由分区键和排序键的组合唯一标识，即两者的组合是主键！</p></blockquote><h2 id="f0ad" class="mp ln iq bd lo mq mr dn ls ms mt dp lw kn mu mv ma kr mw mx me kv my mz mi na bi translated">全球二级指数(GSI)</h2><p id="70ef" class="pw-post-body-paragraph kc kd iq ke b kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz ij bi translated">Dynamo的一个非常特殊的属性是，它只能通过其主键进行查询。它与它的键紧密相连，这可能是一件好事，也可能是一件坏事。我承认，有时这可能有点令人沮丧！</p><p id="96e1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">GSI将允许您查询原始表中非散列或范围键的属性。其工作方式是，您将从任何现有属性中为该索引选择新的散列和范围键，Dynamo将在后台将数据从主表异步复制到索引。从那时起，您可以使用这个新的键来查询基于您选择的新属性的索引。</p><p id="34f5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">根据需要使用尽可能多的索引来满足您的需求，但是如果这些索引开始失去控制，您可能会有一个试图做太多事情的庞然大物！</p><h2 id="882e" class="mp ln iq bd lo mq mr dn ls ms mt dp lw kn mu mv ma kr mw mx me kv my mz mi na bi translated">GetItem操作</h2><p id="9325" class="pw-post-body-paragraph kc kd iq ke b kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz ij bi translated">这与大多数ORM中的findOne方法没有太大区别。它总是将<strong class="ke ir"> <em class="ng">主键</em> </strong>(哈希键&amp;范围键)作为参数，从给定的表中返回一个<strong class="ke ir"> <em class="ng">单项</em> </strong>。</p><p id="8d27" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">当您有足够的上下文来知道项目的确切主键时，比如说当用户在UI上的products表中选择一行时，这将触发一个API调用，您将希望在您的应用程序中使用它。这又会在后台使用GetItem Dynamo方法通过主键获取特定的产品。</p><h2 id="27b2" class="mp ln iq bd lo mq mr dn ls ms mt dp lw kn mu mv ma kr mw mx me kv my mz mi na bi translated">查询操作</h2><p id="a9f4" class="pw-post-body-paragraph kc kd iq ke b kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz ij bi translated">我们已经讨论过分区的概念以及如何使用它。Dynamo查询操作将接受分区键作为参数，还可以选择接受排序键，并将返回存储在该分区上的所有按范围键排序的项目。</p><p id="6660" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这就是为什么慎重使用分区键是至关重要的:如果您有意将项目存储在给定的分区中，您将获得所有这些项目，并且通常具有非常低的延迟！</p></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><h1 id="d925" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">二。在设计阶段投入一些时间</h1><p id="ffe8" class="pw-post-body-paragraph kc kd iq ke b kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz ij bi translated">不要误解我，不管是DynamoDB、Postgres还是MongoDB，你都应该这样做。在数据库设计上投入时间绝对是永恒的，但是在使用DynamoDB时，这一点更加重要。</p><p id="08a2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我从这个人身上学到了一些技巧<a class="nk nl ep" href="https://medium.com/u/3c9962a8238?source=post_page-----574ffb7f5b8a--------------------------------" rel="noopener" target="_blank"> Alex DeBrie </a>在他在DynamoDB上的<a class="ae nc" href="https://www.dynamodbbook.com/" rel="noopener ugc nofollow" target="_blank">书</a>里，读起来绝对是一种享受！然而，我也加入了我自己的想法。让我们来看一下设计DynamoDB数据库的基本构件。</p><h2 id="1d44" class="mp ln iq bd lo mq mr dn ls ms mt dp lw kn mu mv ma kr mw mx me kv my mz mi na bi translated">域实体</h2><p id="8a82" class="pw-post-body-paragraph kc kd iq ke b kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz ij bi translated">首先明确定义您的领域实体:</p><ul class=""><li id="a4e6" class="nm nn iq ke b kf kg kj kk kn no kr np kv nq kz nr ns nt nu bi translated">从功能的角度来看，这个实体是什么？</li><li id="61cb" class="nm nn iq ke b kf nv kj nw kn nx kr ny kv nz kz nr ns nt nu bi translated">它的属性是什么？</li><li id="9376" class="nm nn iq ke b kf nv kj nw kn nx kr ny kv nz kz nr ns nt nu bi translated">什么能唯一地识别它？</li><li id="c238" class="nm nn iq ke b kf nv kj nw kn nx kr ny kv nz kz nr ns nt nu bi translated">它与其他域实体有关系吗？如果有，基数是多少？</li></ul><p id="72ca" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果感觉有太多的域实体和太多的关系，这可能是另一个大开眼界，这可能是您试图在一个服务的上下文中做太多的事情！</p><p id="daa4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">假设我们正在构建一个访问管理服务，您将有三个域实体:</p><ul class=""><li id="3685" class="nm nn iq ke b kf kg kj kk kn no kr np kv nq kz nr ns nt nu bi translated"><strong class="ke ir"> <em class="ng">用户</em> </strong>:将访问您的应用程序的用户。一个用户可以有许多角色。</li><li id="2926" class="nm nn iq ke b kf nv kj nw kn nx kr ny kv nz kz nr ns nt nu bi translated"><strong class="ke ir"> <em class="ng">角色</em> </strong>:用户可以拥有的给定角色。它决定了他们可以从后端访问什么数据，以及他们在UI上看到什么。</li><li id="c223" class="nm nn iq ke b kf nv kj nw kn nx kr ny kv nz kz nr ns nt nu bi translated"><strong class="ke ir"> <em class="ng">组织</em> </strong>:用户链接的组织。一个组织可以有多个用户，但是一个用户只能属于一个组织。</li></ul><h2 id="a672" class="mp ln iq bd lo mq mr dn ls ms mt dp lw kn mu mv ma kr mw mx me kv my mz mi na bi translated">访问模式</h2><p id="fa7f" class="pw-post-body-paragraph kc kd iq ke b kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz ij bi translated">列出一旦这些实体存储在数据库中，您希望如何访问它们。这通常会映射到您的API响应，这些响应将在客户端或由另一个后端服务使用。</p><p id="1018" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在我们的访问管理服务中，可能是这样的:</p><ul class=""><li id="3580" class="nm nn iq ke b kf kg kj kk kn no kr np kv nq kz nr ns nt nu bi translated">对于给定的<strong class="ke ir">用户</strong>，获取他们拥有的所有角色</li><li id="0fd7" class="nm nn iq ke b kf nv kj nw kn nx kr ny kv nz kz nr ns nt nu bi translated">对于给定的<strong class="ke ir">组织</strong>，获取链接到它的所有用户</li><li id="8131" class="nm nn iq ke b kf nv kj nw kn nx kr ny kv nz kz nr ns nt nu bi translated">对于给定的<strong class="ke ir">角色</strong>，获取拥有该角色的用户数量(这的确很难，DynamoDB并不真正支持聚合，至少不是直接支持。)</li></ul><p id="d830" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在这里，您还应该指定是从主表还是从GSI获取实体。</p><h2 id="9802" class="mp ln iq bd lo mq mr dn ls ms mt dp lw kn mu mv ma kr mw mx me kv my mz mi na bi translated">实体模式</h2><p id="b716" class="pw-post-body-paragraph kc kd iq ke b kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz ij bi translated">您可能知道DynamoDB是无模式的，这意味着它不会强制任何模式。您将在这里放在一起的这个模式必须由您的应用程序代码强制执行。</p><p id="9015" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">对我来说，我喜欢通过TypeScript接口符号来记录模式，我知道我有偏见，毕竟这是我最喜欢的语言！</p><p id="8fef" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">另一方面，TypeScript也不会强制您的模式，因为它不会在运行时验证数据。为此，您将需要运行时验证，最好通过我最喜欢的TS库<a class="ae nc" href="https://github.com/colinhacks/zod" rel="noopener ugc nofollow" target="_blank"> Zod </a>来完成！</p><p id="126e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">对于用户来说，模式可能是这样的:</p><figure class="lb lc ld le gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oa"><img src="../Images/3e5a2cfe73c480d5b02a0e06f3705129.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T8m29-hRxl2oqxWUIA7nug.png"/></div></div></figure><p id="09ab" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">一个组织:</p><figure class="lb lc ld le gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ob"><img src="../Images/c93f62daf327aca9e6e90e465c13048d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k8tpKoHwJyAwaDfxBty4CQ.png"/></div></div></figure><h2 id="8fb5" class="mp ln iq bd lo mq mr dn ls ms mt dp lw kn mu mv ma kr mw mx me kv my mz mi na bi translated">把它放在一起</h2><p id="c782" class="pw-post-body-paragraph kc kd iq ke b kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz ij bi translated">最后，整个文档应该尽可能地贴近团队中的开发人员。为此，我发现最好的地方写它是在一个markdown文件中，它位于你的项目的根目录下！</p></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><h1 id="a61b" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">三。知道如何以及何时使用单表设计</h1><p id="eaeb" class="pw-post-body-paragraph kc kd iq ke b kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz ij bi translated">在我自己开发的产品中，我们经常使用这种数据库设计。还记得我提到过，具有相同分区键的项目将在后台存储在同一个分区上吗？这是设计DynamoDB数据库的一个小秘密。</p><p id="ce16" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">从本质上讲，单表设计就是将分区键和排序键通用化，并重载它们。通常，它们将分别表示为PK和SK。您也可以对GSI做同样的事情，在需要的时候添加GSIPKs和gsisk。</p><p id="620c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">下面是如何创建这样一个表的一个小的无服务器框架片段:</p><figure class="lb lc ld le gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oc"><img src="../Images/1a4238138903562af4e5c34b6b05cb57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8Jc6CYs4PcNG8siiNQA-fQ.png"/></div></div></figure><p id="2d29" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">因此，在我们的访问管理示例中，我们的访问模式之一是为一个给定的组织服务所有链接到它的用户。在这种情况下，一个组织实体和一个用户实体共享一个分区键是有意义的，即生活在同一个分区上。这将允许我们针对该分区键运行查询操作，Dynamo将返回该分区上的所有内容！</p><p id="e5ba" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">因此，您可以在DynamoDB中存储一个组织实体，大致如下所示:</p><figure class="lb lc ld le gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ob"><img src="../Images/86f46b5d3637ab7793dd12f702ac5311.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IJ65SufFwX9LOOYg5w9iWw.png"/></div></div></figure><p id="2eb0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">一些用户看起来像这样:</p><figure class="lb lc ld le gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ob"><img src="../Images/fc9c502b8587817f5a3ebc2afd75e066.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ab2KOv8pBrWDMBJS7D1Q-w.png"/></div></div></figure><figure class="lb lc ld le gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ob"><img src="../Images/b2fe4ed508fdaf597e1de287e5545a7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rgnyxGMukhS7Ny3Ri3iOkA.png"/></div></div></figure><p id="a81d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">因此，现在当您查询“ORG # LFC ltd”PK时，您会得到所有三个项目。实际上，你刚才所做的就是模仿SQL中的一个join，故意选择PK！</p><p id="7058" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">将导致返回所有三个项目的查询操作将如下所示，这里我再次使用了TypeScript:</p><figure class="lb lc ld le gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oc"><img src="../Images/0442d9849fb3ab572d22e2f5703193e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6JGtwoD-sk9gRF1p1lBIeg.png"/></div></div></figure><p id="7cb2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这种类型的设计非常强大，可以实现非常低的延迟响应，并且扩展性非常好。但这只有在以下情况下才有效:</p><ul class=""><li id="b4be" class="nm nn iq ke b kf kg kj kk kn no kr np kv nq kz nr ns nt nu bi translated">你的服务足够精益，它并没有试图做太多。它并不试图覆盖数十个领域实体，否则，复杂性将迅速增长</li><li id="5fc3" class="nm nn iq ke b kf nv kj nw kn nx kr ny kv nz kz nr ns nt nu bi translated">您知道您试图很好地实现的访问模式，并且对您的服务的功能有很好的理解</li><li id="fcff" class="nm nn iq ke b kf nv kj nw kn nx kr ny kv nz kz nr ns nt nu bi translated">没有特别的查询要求，这意味着最终用户可以按照自己的意愿查询您的数据库。它适用于SQL，但完全不适用于单表设计</li></ul></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><h1 id="e197" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">四。使用GraphQL时支持多表设计</h1><p id="bdc2" class="pw-post-body-paragraph kc kd iq ke b kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz ij bi translated">有时候使用DynamoDB的多表设计比单表设计更有意义。如果你在AWS世界中使用GraphQL或AppSync，就会出现这种情况。</p><p id="6cb1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我绝对喜欢GraphQL，也喜欢AppSync，尽管我对VTL解析器一点都不感兴趣，并且仍然耐心地等待着<a class="ae nc" href="https://github.com/aws/aws-appsync-community/issues/147" rel="noopener ugc nofollow" target="_blank"> TS/JS解析器</a>。AppSync的一般前提是定义一个模式，该模式将包含应用程序的域对象、域对象中的字段以及两个非常重要的顶级对象:</p><ul class=""><li id="632e" class="nm nn iq ke b kf kg kj kk kn no kr np kv nq kz nr ns nt nu bi translated">一个<strong class="ke ir"> <em class="ng">查询</em> </strong>:定义所有将要用来取数据的查询</li><li id="718e" class="nm nn iq ke b kf nv kj nw kn nx kr ny kv nz kz nr ns nt nu bi translated">一个<strong class="ke ir"> <em class="ng">突变</em> </strong>:定义所有将被用来写/更新/删除数据的操作</li></ul><p id="75b7" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们熟悉的许多规范化概念在这里都适用。在我们的访问管理示例中，我们现在将在两个单独的表中存储一个用户对象和一个组织对象。该图，也就是我们的模式，可能看起来像这样:</p><figure class="lb lc ld le gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oc"><img src="../Images/7b45bdd3df0472ffdac49cc9066202a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v-n6e2VdNMw_KRfoawowHQ.png"/></div></div></figure><p id="6069" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在，这个GraphQL API的消费者在使用<strong class="ke ir"><em class="ng">getUserByOrgId</em></strong>查询获取用户时可以做出选择:</p><ul class=""><li id="2440" class="nm nn iq ke b kf kg kj kk kn no kr np kv nq kz nr ns nt nu bi translated"><strong class="ke ir">他们不需要组织信息</strong>，因此他们选择省略用户对象中看到的组织嵌套解析器。这意味着我们只访问了一个表，即用户表</li><li id="87bd" class="nm nn iq ke b kf nv kj nw kn nx kr ny kv nz kz nr ns nt nu bi translated"><strong class="ke ir">他们确实需要详细的组织信息</strong>，比如他们正在构建的UI，因此将使用我们的嵌套解析器。这很酷，因为我们的API现在将用一个用户对象和一个嵌套的组织对象来响应。在这种情况下，我们将碰到两个表。但是GraphQL为我们处理了'<strong class="ke ir"> <em class="ng">加入'</em> </strong>！</li></ul><p id="4332" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这很好，因为它给了我们很大的灵活性，可以使用我们需要的任何数量的表，让我们的消费者选择他们想要获取的数据。最后，GraphQL模式现在是事实的最终来源，也就是我们的文档！</p><p id="c1cb" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">但是，请记住，这是以增加API的延迟为代价的。最后，尽管GraphQL负责连接，但您仍然要向两个独立的DynamoDB表发出两个后续请求，而不是像我们在上一节中那样发出一个请求。</p></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><h1 id="7194" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">动词 （verb的缩写）使用CDC(变更数据捕获)添加对聚合和缓存的支持</h1><p id="d147" class="pw-post-body-paragraph kc kd iq ke b kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz ij bi translated">DynamoDB有DynamoDB streams (MongoDB也有类似的特性)，这是一个漂亮的特性，每当表中的一个项目发生状态变化时，它就会将一个事件发布到一个流中。这可以是下列之一:</p><ul class=""><li id="2267" class="nm nn iq ke b kf kg kj kk kn no kr np kv nq kz nr ns nt nu bi translated">创造</li><li id="5755" class="nm nn iq ke b kf nv kj nw kn nx kr ny kv nz kz nr ns nt nu bi translated">修改</li><li id="7354" class="nm nn iq ke b kf nv kj nw kn nx kr ny kv nz kz nr ns nt nu bi translated">删除</li></ul><p id="c3cb" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">就在最近，AWS增加了对DynamoDB流中事件映射的支持。也就是说，一个流的订阅者，比如一个lambda函数，只有在事件模式匹配时才会被触发。在这方面非常类似于事件桥。在无服务器框架中，可能是这样的:</p><figure class="lb lc ld le gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ob"><img src="../Images/b2cf5de5229cc6d32bf718a3f06ba6d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SSbzlxLCpDunFEIu1OemBw.png"/></div></div></figure><p id="082d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">其工作方式是，只有当相关项目具有属性<strong class="ke ir"><em class="ng"/></strong><strong class="ke ir"><em class="ng"/></strong>类型字符串并且其值为<strong class="ke ir"> <em class="ng">用户时，才会触发AddUserCount Lambda函数。</em> </strong>这是我喜欢用的另一个小技巧<strong class="ke ir"><em class="ng"/></strong>特别是在单表设计中，要有一个静态的<strong class="ke ir"> <em class="ng">类</em> </strong>属性，定义一个条目是什么域实体<strong class="ke ir"> <em class="ng">。</em>T24】</strong></p><p id="e240" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">回到我们稍微复杂的访问模式，获取链接到给定组织的用户数量。使用DynamoDB流的方法是检查用户的PK，即他们属于哪个组织，然后在相关的组织实体上运行<strong class="ke ir"> <em class="ng"> Update </em> </strong>操作。这将导致添加一个Number、<strong class="ke ir"> <em class="ng"> userCount、</em> </strong>类型的属性，预先计算好并准备就绪，在Lambda代码中您什么也不用做！</p><p id="5cf9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这看起来会像这样:</p><figure class="lb lc ld le gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ob"><img src="../Images/560823bad2003a2680041d4e1c023992.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CxyewnqS872X3o3naOJdFA.png"/></div></div></figure><p id="d75c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">问题是，我见过的人们使用DynamoDB流的大多数用例都是将数据从Dynamo转移到另一种类型的OLAP数据库，比如红移或弹性搜索。这确实是一个非常有效的用例，但是不要在使用DynamoDB流进行聚合上睡大觉。不仅仅是计数，还有总和！</p></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><h1 id="7ef0" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">分级编码</h1><p id="bccc" class="pw-post-body-paragraph kc kd iq ke b kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz ij bi translated">感谢您成为我们社区的一员！在你离开之前:</p><ul class=""><li id="8ef5" class="nm nn iq ke b kf kg kj kk kn no kr np kv nq kz nr ns nt nu bi translated">👏为故事鼓掌，跟着作者走👉</li><li id="16ad" class="nm nn iq ke b kf nv kj nw kn nx kr ny kv nz kz nr ns nt nu bi translated">📰查看<a class="ae nc" href="https://levelup.gitconnected.com/?utm_source=pub&amp;utm_medium=post" rel="noopener ugc nofollow" target="_blank">升级编码出版物</a>中的更多内容</li><li id="516d" class="nm nn iq ke b kf nv kj nw kn nx kr ny kv nz kz nr ns nt nu bi translated">🔔关注我们:<a class="ae nc" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">Twitter</a>|<a class="ae nc" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>|<a class="ae nc" href="https://newsletter.levelup.dev" rel="noopener ugc nofollow" target="_blank">时事通讯</a></li></ul><p id="c22e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">🚀👉<a class="ae nc" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="ke ir">将像你这样的开发人员安置在顶级创业公司和科技公司</strong> </a></p></div></div>    
</body>
</html>