<html>
<head>
<title>MVC, MVP &amp; MVVM: Comparisons</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">MVC，MVP和MVVM:比较</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/mvc-mvp-and-mvvm-comparations-d2bddb467e11?source=collection_archive---------14-----------------------#2020-09-29">https://levelup.gitconnected.com/mvc-mvp-and-mvvm-comparations-d2bddb467e11?source=collection_archive---------14-----------------------#2020-09-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1a0f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">干净的代码促进了iOS中的现代架构</h2></div><p id="e2a5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">MVC、MVP和MVVM是iOS开发和Android等其他平台的三大架构。这些都是好的架构，这完全取决于开发者的选择。苹果在推广MVC。大多数开发人员都在使用MVP。MVVM + RxSwift成为应用程序开发中处理异步请求的现代架构。这三种架构更像是一个从MVC、MVP到MVVM的演进过程。但是它总是坚持一个原则:</p><blockquote class="le"><p id="eabb" class="lf lg it bd lh li lj lk ll lm ln ld dk translated">使代码具有可读性、可伸缩性和可靠性</p></blockquote><p id="acde" class="pw-post-body-paragraph ki kj it kk b kl lo ju kn ko lp jx kq kr lq kt ku kv lr kx ky kz ls lb lc ld im bi translated">在这篇文章中，我将介绍和比较这三种模式，并解释一下我的个性化架构。</p><h1 id="c157" class="lt lu it bd lv lw lx ly lz ma mb mc md jz me ka mf kc mg kd mh kf mi kg mj mk bi translated">MVC(模型—视图—控制器)</h1><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi ml"><img src="../Images/c0988c2c8f048f9da022e31654ab1ffa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gw9RZIsJPOA1h7xhCCQ84g.png"/></div></div></figure><h2 id="33ba" class="mx lu it bd lv my mz dn lz na nb dp md kr nc nd mf kv ne nf mh kz ng nh mj ni bi translated">视角</h2><p id="0bef" class="pw-post-body-paragraph ki kj it kk b kl nj ju kn ko nk jx kq kr nl kt ku kv nm kx ky kz nn lb lc ld im bi translated">视图应该只关注与客户的交互，而没有任何业务逻辑。我们可以很容易地用故事板和笔尖做到这一点。在这一层中，它只包含:</p><ul class=""><li id="ad5c" class="no np it kk b kl km ko kp kr nq kv nr kz ns ld nt nu nv nw bi translated">子类:从基本的<code class="fe nx ny nz oa b">UIView</code>到复杂的用户界面控件。</li><li id="9f73" class="no np it kk b kl ob ko oc kr od kv oe kz of ld nt nu nv nw bi translated">属于UIKit/AppKit的类。</li><li id="adb0" class="no np it kk b kl ob ko oc kr od kv oe kz of ld nt nu nv nw bi translated">核心动画。</li><li id="6c71" class="no np it kk b kl ob ko oc kr od kv oe kz of ld nt nu nv nw bi translated">核心图形。</li></ul><h2 id="f57b" class="mx lu it bd lv my mz dn lz na nb dp md kr nc nd mf kv ne nf mh kz ng nh mj ni bi translated">模型</h2><p id="7ad6" class="pw-post-body-paragraph ki kj it kk b kl nj ju kn ko nk jx kq kr nl kt ku kv nm kx ky kz nn lb lc ld im bi translated">模型层更加通用，包括所有的网络、持久性、常量和扩展代码。它还包含服务于业务逻辑的所有模型。</p><p id="fdb0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">就个人而言，我希望将网络和持久性类转移到存储库层。其他的，比如常量、管理器和扩展，将被移动到支持层。模型层仅用于数据模型。因此，对于这一层，它是可定制的。</p><h2 id="9e9c" class="mx lu it bd lv my mz dn lz na nb dp md kr nc nd mf kv ne nf mh kz ng nh mj ni bi translated">控制器</h2><p id="3bd3" class="pw-post-body-paragraph ki kj it kk b kl nj ju kn ko nk jx kq kr nl kt ku kv nm kx ky kz nn lb lc ld im bi translated">在iOS中，视图控制器是一个处理视图交互的类。它通常包含许多委托/数据源(TableViewDataSource和TableViewDelegate等)。)和查看生命周期(ViewDidLoad、ViewDidAppear和ViewWillAppear等)。).对于用户来说，这是一个很好的设计，可以在特定时间处理不同类型的交互。</p><p id="663b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，我们的委托越多，我们在每个函数中需要的逻辑就越多。这很快增加了ViewController的大小。如果一个视图控制器有成千上万行难以维护的代码，你会经常看到这种情况。</p><p id="071c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于控制器层不是MVC中的最佳实践，我们肯定可以做些什么来清理这一层。最好的方法是将控制器中的大部分逻辑提取到其他层，如Presenter和ViewModel层。然后，我们定义了演示者/视图模型和控制器之间的通信模式。我们迎来了MVP和MVVM。</p><h1 id="e7cd" class="lt lu it bd lv lw lx ly lz ma mb mc md jz me ka mf kc mg kd mh kf mi kg mj mk bi translated">MVP(模型-视图-演示者)</h1><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi og"><img src="../Images/78ce101623f8bb0977ca497901ce7cb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UzqMJB2kG_L4u-6ZOmKihg.png"/></div></div></figure><p id="4c22" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我在MVC中提到的，MVP和MVC看起来很相似。MVP更好的原因是它有一个包含所有业务逻辑的表示层。它使用委托和闭包与视图层通信。</p><p id="61c7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在视图层，它包括MVC中引入的视图元素。此外，它还包括该层中的ViewControllers。因此，处理生命周期和视图委托的UIView代码和ViewController代码应该被视为视图代码。</p><h1 id="7c87" class="lt lu it bd lv lw lx ly lz ma mb mc md jz me ka mf kc mg kd mh kf mi kg mj mk bi translated">MVVM(模型-视图-视图模型)</h1><p id="d649" class="pw-post-body-paragraph ki kj it kk b kl nj ju kn ko nk jx kq kr nl kt ku kv nm kx ky kz nn lb lc ld im bi translated">MVVM和MVP是相似的:所有的视图层和模型层都是一样的。ViewModel和Presenter持有大部分业务逻辑。区别在于视图和业务逻辑之间的交流。</p><p id="3fa7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们对大量异步代码使用MVP，我们必须在ViewController中使用大量委托，或者在异步结果返回之前使用大量闭包将值保存在内存中。此外，我们可能需要大量dispatchqueue.main.async样式的代码来将结果传递给主线程。</p><p id="41f1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">MVVM就是为了解决这个问题而诞生的。</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi oh"><img src="../Images/d72ac8b7fe0e8c5f3475885b559c7406.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yIPzuYKpdd7U_VPxYEboRw.png"/></div></div></figure><p id="01d6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用MVVM，ViewModel中的变量被绑定到UI元素。</p><p id="c959" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">ViewModel中发生的任何更改都会自动传递到视图中。来自视图的任何交互都直接反映了视图模型。因此，不需要委托和闭包等。代码看起来干净多了。</p><h1 id="94eb" class="lt lu it bd lv lw lx ly lz ma mb mc md jz me ka mf kc mg kd mh kf mi kg mj mk bi translated">最后的想法</h1><p id="5548" class="pw-post-body-paragraph ki kj it kk b kl nj ju kn ko nk jx kq kr nl kt ku kv nm kx ky kz nn lb lc ld im bi translated">总的来说，对于这三种架构，我们关注的是业务逻辑。我们应该把它放在哪里，以及我们如何处理通信。无论我们如何改变它，只有一个规则——让代码更干净(可读和可伸缩)。所以，我想分享一下我一直用的架构。希望对你有帮助。</p><figure class="mm mn mo mp gt mq gh gi paragraph-image"><div role="button" tabindex="0" class="mr ms di mt bf mu"><div class="gh gi oi"><img src="../Images/77fa35617a09d969bcccc229ba5bccec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S4hiXd8siifEq_NZKUU9Pg.png"/></div></div></figure><p id="dfa5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如您从本文中了解到的那样，没有必要讨论视图、视图模型。让我们扩展模型层。</p><p id="cf64" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">网络层和持久层由存储库层管理，所有数据都必须经过存储库层。通过这样做，逻辑层不必担心数据来自哪里。</p><p id="c08b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">域是从视图模型中提取的可重用逻辑，它具有单一的职责并且是可重用的。ViewModel只关注它所服务的视图，并提供相应的只服务于视图的变量和函数。</p><p id="050f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我希望这篇文章对你自己的应用程序架构有所启发。欢迎你对这篇文章留下任何意见。我感谢任何建议。</p></div></div>    
</body>
</html>