<html>
<head>
<title>Understanding the “Stack Too Deep” Error in Solidity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解坚实度中的“堆栈过深”错误</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/stack-too-deep-error-in-solidity-ca83326ff0f0?source=collection_archive---------2-----------------------#2019-01-07">https://levelup.gitconnected.com/stack-too-deep-error-in-solidity-ca83326ff0f0?source=collection_archive---------2-----------------------#2019-01-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3401" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">了解以太坊虚拟机如何管理堆栈，以及常见的堆栈过深错误如何出现在您的Solidity代码中</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/3b8b0b6cfd7b33ca70ce6c3004687224.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*EP_QYlK_-Fgc2JclN_fLKA.png"/></div></figure><p id="923c" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">新年快乐，愿我们在2019年都能大有作为！Aventus欢迎你从寒假回来，我们自己的Alex Pinto写了一篇关于坚固性错误的文章。</p></div><div class="ab cl lj lk hu ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="ij ik il im in"><p id="030b" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">当一个人开始在Solidity中编写智能合同时，迟早他/她会遇到一个非常讨厌的障碍。“堆栈过深”错误。人们很容易陷入这个陷阱，当这种情况发生时，往往很难找到出路。公平地说，根本原因不在于可靠性本身，而在于以太坊虚拟机(EVM)，因此会影响编译成EVM的其他语言(即LLL、Serpent、Viper)，但这是编写智能合同的日常工作中的一个微妙区别。</p><p id="e2e5" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">考虑到这种错误是如此的普遍和令人讨厌，找到关于如何处理它的好资源是令人惊讶的困难，所以我决定写这篇文章来试图揭示它，为了我自己的利益，也为了其他可能与之斗争的人。</p><p id="5cf5" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">一般来说，当代码需要访问堆栈中深度超过第16个元素(从上往下数)的槽时，就会产生“堆栈过深”错误。这是如何发生的，可以有许多不同的方式。这篇文章的目的不是提供这个错误是如何产生的完整理论:根据我的经验，有太多的方法可以做到这一点。但是它将为通用触发器提供一个很好的理论基础，并有望让读者更加了解EVM是如何管理其堆栈的。甚至有可能将相同的逻辑扩展到发生错误的其他情况，并寻找避免错误的方法。</p><p id="649c" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在坚固性方面，大多数类型(即基本类型(例如数字、地址和布尔值，但不是数组、结构或映射)通过值传递给函数。当调用该函数时，堆栈的一部分(堆栈帧)被分配来保存返回位置。这是函数返回时程序应该去的地方(“返回地址”)。它还保存了函数值类型输入和输出参数的副本。每个参数通常在堆栈中保存一个槽，每个槽是256位。</p><p id="a6ca" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这提供了解决“堆栈过深”错误的最基本方法:总共有16个以上的输入和输出参数。但是实际上，如果我们想让这个函数做一些有用的事情，我们几乎肯定需要减少参数的数量。</p><p id="1892" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">为了测试这一点，我在<a class="ae lq" href="https://remix.ethereum.org/" rel="noopener ugc nofollow" target="_blank"> <em class="lr"> Remix </em> </a>中创建了一个小契约，如下所示:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="4947" class="lx ly iq lt b gy lz ma l mb mc">pragma solidity ^0.4.24;<br/>contract TestStackError {<br/>  event LogValue(uint);<br/>  function logArg(uint a1) public {<br/>    emit LogValue(a1);<br/>  }<br/>}</span></pre><p id="59b1" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">Remix非常适合研究这样的问题，因为我们可以快速编写一个契约并查询它，还因为Remix提供了一个强大的调试器，具有操作码反汇编和堆栈、内存和存储的完整列表。此外，在代码中来回移动很容易，这是我在任何语言中拥有的最好的调试体验之一。</p><p id="51df" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这个契约非常简单:它没有状态变量，只有一个函数，也非常简单。这个函数接受一个参数并记录下来。</p><p id="3d7b" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我将这个契约复制到Remix中的一个新文件中，编译它，并部署它。应该没有错误和警告，所以我转到<code class="fe md me mf lt b">Run</code> <em class="lr"> </em>选项卡并点击<code class="fe md me mf lt b">Deploy</code>。</p><p id="ae45" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">然后，我扩展了<code class="fe md me mf lt b">SimpleFunction</code>合同的列表，并在<em class="lr"> logArg </em>前面的框中输入一个值。我按下按钮，检查控制台中的输出:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi mg"><img src="../Images/4c4943971d14652968459f246dd5f6db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lPrvLApnthc2G_N-"/></div></div></figure><p id="6413" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">如您所见，我输入了值<em class="lr"> 7 </em>，它作为日志中唯一的元素被返回。尽管日志值得另发一篇文章，但我还是要在这里提几件事。</p><p id="6e2d" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这是这个调用的JSON格式的logs对象:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="f9c0" class="lx ly iq lt b gy lz ma l mb mc">logs [<br/>{<br/>  "from": "0xef55bfac4228981e850936aaf042951f7b146e41",<br/>  "topic": "0xfcf771399d75a67a6d0e730ae98d34c40b6bfe6ebf8053b98ddf4da8c2706250",<br/>  "event": "LogValue",<br/>  "args": {<br/>    "0": "7",<br/>    "length": 1<br/>  }<br/>}</span></pre><ul class=""><li id="24a3" class="ml mm iq kp b kq kr kt ku kw mn la mo le mp li mq mr ms mt bi translated">日志是由solidity中的<code class="fe md me mf lt b">emit</code>关键字创建的，它提升了一个solidity <code class="fe md me mf lt b">event</code>并对应于<code class="fe md me mf lt b">LOGn</code>操作码。</li><li id="e004" class="ml mm iq kp b kq mu kt mv kw mw la mx le my li mq mr ms mt bi translated">离线运行的客户端应用程序可以过滤日志。过滤器是日志中任何可用主题的条件。</li><li id="9c63" class="ml mm iq kp b kq mu kt mv kw mw la mx le my li mq mr ms mt bi translated">日志总是有一个主题0，它是事件签名的编码。</li><li id="8a8f" class="ml mm iq kp b kq mu kt mv kw mw la mx le my li mq mr ms mt bi translated">可以通过索引一个参数来创建更多的主题。最多可以有3个索引参数。其余的被认为是事件数据</li></ul><p id="d013" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在这个简单的例子中，我们可以很容易地识别出只有一个主题(<code class="fe md me mf lt b">"0xfcf771399d75a67a6d0e730ae98d34c40b6bfe6ebf8053b98ddf4da8c2706250"</code>)，并且数据显示为log对象的<code class="fe md me mf lt b">args</code>成员的一部分。我们还可以验证代码是否按预期运行。</p><p id="46db" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">现在让我们测试这个契约的限制，并更改函数以接受最大数量的参数。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="56f5" class="lx ly iq lt b gy lz ma l mb mc">pragma solidity ^0.4.24;</span><span id="9d1c" class="lx ly iq lt b gy mz ma l mb mc">contract TestStackError {<br/>  event LogValue(uint);<br/>  function logArg(uint a1, uint a2, uint a3, uint a4,<br/>	uint a5, uint a6, uint a7, uint a8,<br/>	uint a9, uint a10, uint a11, uint a12,<br/>	uint a13, uint a14, uint a15, uint a16<br/>  ) public {<br/>    emit LogValue(a16);<br/>  }<br/>}</span></pre><p id="a666" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我有16个输入变量，没有输出变量，因此我只需要使用16个堆栈槽。我调用传递值1到16的函数，并发出最后一个值。我检查日志，发现值为16。太棒了，这个管用！</p><p id="7605" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">然后，我对我的契约做了一个很小的修改:改为记录第一个参数:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi mg"><img src="../Images/aed621b308a8e264adbba7e24a4a7cdc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*sivXW-uI1SlS8Q1X"/></div></div></figure><p id="2724" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">等等，什么？！简单地记录一个不同的参数已经把一个完美的契约变成了一个“栈太深”的错误。哇，这是怎么回事？</p><p id="1c08" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这不是固性所能阐明的。在这个层面上，这种变化看起来完全无害。我需要深入到EVM字节码中去理解发生了什么。但在此之前，我想做另一个测试，收集一些线索。我创建了这个契约的第三个版本，但是改为记录a2:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="5f8c" class="lx ly iq lt b gy lz ma l mb mc">pragma solidity ^0.4.24;</span><span id="0440" class="lx ly iq lt b gy mz ma l mb mc">contract TestStackError {<br/>  event LogValue(uint);<br/>  function logArg(uint a1, uint a2, uint a3, uint a4,<br/>	uint a5, uint a6, uint a7, uint a8,<br/>	uint a9, uint a10, uint a11, uint a12,<br/>	uint a13, uint a14, uint a15, uint a16<br/>  ) public {<br/>    emit LogValue(a2);<br/>  }<br/>}</span></pre><p id="6b6a" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这可以工作并记录正确的值。当我记录<code class="fe md me mf lt b">a3</code>时，同样的情况也会发生。我假设<code class="fe md me mf lt b">a2</code>和<code class="fe md me mf lt b">a16</code>之间的所有争论都可以被正确记录。</p><p id="cdd0" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">产生的操作码在以下三个文件中:</p><p id="e994" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><a class="ae lq" href="http://coders-errand.com/wp-content/uploads/2018/12/opcode_log_a2.txt" rel="noopener ugc nofollow" target="_blank"><em class="lr">【a2】</em></a></p><p id="ff0b" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><a class="ae lq" href="http://coders-errand.com/wp-content/uploads/2018/12/opcode_log_a3.txt" rel="noopener ugc nofollow" target="_blank"><em class="lr">【a3】</em></a></p><p id="2886" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><a class="ae lq" href="http://coders-errand.com/wp-content/uploads/2018/12/opcode_log_a16.txt" rel="noopener ugc nofollow" target="_blank"><em class="lr">【a16】</em></a></p><p id="2845" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我比较了所有3个日志，第一个让我吃惊的是它们的大小都不同(行数)。第二件事是，在第237行之前，它们是显著相等的，只有一个例外。这一行之后的代码非常不同，显然是不可预测的。然而，由于这似乎是在函数返回之后发生的，我将简单地忽略它。</p><p id="0faf" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">然后我把注意力集中在第237行和第198行之间的一个区别上。我很高兴地证实了一个想法，我曾认为这个想法可以解释堆栈过深错误——在代码的某些地方，我们逻辑上需要调用一些不存在的DUP或交换操作码。这里的情况确实如此:在第237行之前，所有3个版本都是相同的，只有第198行有一处不同:</p><ul class=""><li id="12f9" class="ml mm iq kp b kq kr kt ku kw mn la mo le mp li mq mr ms mt bi translated"><code class="fe md me mf lt b">log(a2): DUP16</code></li><li id="29b9" class="ml mm iq kp b kq mu kt mv kw mw la mx le my li mq mr ms mt bi translated"><code class="fe md me mf lt b">log(a3): DUP15</code></li><li id="b1ad" class="ml mm iq kp b kq mu kt mv kw mw la mx le my li mq mr ms mt bi translated"><code class="fe md me mf lt b">log(a16): DUP2</code></li></ul><p id="5cc5" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">操作码DUPn复制堆栈第n层的值。这样的操作码只有16个，从DUP1到DUP16。DUP1将当前位于顶部的值的副本推送到堆栈中，DUP16复制堆栈中第16个最高的值。变量在参数列表中的位置和这一行中DUPn的值之间有明显的关系，如果我将其推断到案例日志(a1)，这条规则意味着我们将需要一个操作码DUP17。但是这样的操作码并不存在，它指向堆栈中比我们所能达到的更低的值，这证明了错误消息“Stack Too Deep”是正确的。</p><p id="de69" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">满足于此，我自然的好奇心提出了问题:这个DUP操作码在这里扮演什么角色？它的目的是什么？</p><p id="be7f" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">字节码令人生畏。上一次我带着某种程度的理解去看汇编代码是在我十几岁的时候，当时我正在玩Spectrum的Z80处理器。我没有任何使用EVM的经验，所以我不打算在脑子里解析200行类似汇编的清单。但是Remix在这方面确实提供了相当好的工具。在debug选项卡中，我们可以一个操作码一个操作码地重放事务操作码，并且一眼就能看到堆栈、内存和存储等的内容。</p><p id="f59d" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在我继续之前，我想把你引向Alejandro Santander在Zeppelin博客中关于汇编EVM代码结构的系列文章<a class="ae lq" href="https://blog.zeppelin.solutions/deconstructing-a-solidity-contract-part-i-introduction-832efd2d7737" rel="noopener ugc nofollow" target="_blank"><em class="lr">。这是一个无价的介绍EVM大会，将节省我不得不解释样板。另一个非常有用的链接是这个EVM操作码<a class="ae lq" href="https://ethervm.io/" rel="noopener ugc nofollow" target="_blank"> <em class="lr">列表</em> </a>，这是我最喜欢用来查找每个操作码功能的参考。我强烈推荐。</em></a></p><p id="f96c" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这个函数没有多少内容，大部分字节码都是重复的。操作码CALLDATALOAD出现了17次。第一个出现在代码的第一个块中，在函数分派之前。它检查calldata是否太短(第12行)，在这种情况下，该函数将恢复。之后，它将函数选择器与契约已知的方法进行比较(在本例中，只有一个:<code class="fe md me mf lt b">e898288f</code>)，如果匹配，就将流程导向实现该函数的地址。否则，呼叫恢复。</p><p id="a873" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在这种情况下，代码已经调用了唯一的现有函数，因此流程跳转到地址70(第25行)来处理它。</p><p id="563c" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">CALLDATALOAD的其余16个实例正好是我们拥有的参数数量，它们正好以9行的间隔出现，并且可能负责处理函数的每个参数。所以，我用Remix调试器运行了这几行，观察到它们确实将每个连续的参数加载到了堆栈中(我并不担心这9个操作码是如何复制这些数据的)。接下来是3个<code class="fe md me mf lt b">POP</code>指令，清除我们不再需要的堆栈部分(用于计算要读取的下一个参数在调用数据中的位置)。此时，栈顶保存第16个参数，第二个元素保存第15个参数，依此类推。在这个阶段，堆栈的第16个元素是第一个参数。随后是函数的返回地址(<code class="fe md me mf lt b">0x109</code>)和函数选择器。</p><p id="23dd" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">然后，代码将主题0 <code class="fe md me mf lt b">fcf771399d75a67a6d0e730ae98d34c40b6bfe6ebf8053b98ddf4da8c2706250</code>的32字节标识符推入堆栈，这将第一个输入推出堆栈的前16个元素，随后是DUP操作码，该操作码将日志事件的参数放在堆栈的顶部(例如<code class="fe md me mf lt b">a2</code>或<code class="fe md me mf lt b">a16</code>)。</p><p id="cfbe" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">接下来的20行让内存准备好在内存位置<code class="fe md me mf lt b">0x80</code>保存日志事件的参数，并保证堆栈的前两个位置有这个地址和数据的长度(<code class="fe md me mf lt b">0x20</code>)。然后，它调用操作码LOG1，该操作码使用堆栈中前3个位置的数据发出一个带有一个参数和一个主题的日志事件:</p><ul class=""><li id="7fd2" class="ml mm iq kp b kq kr kt ku kw mn la mo le mp li mq mr ms mt bi translated">0: <code class="fe md me mf lt b">0x0000000000000000000000000000000000000000000000000000000000000080</code></li><li id="2261" class="ml mm iq kp b kq mu kt mv kw mw la mx le my li mq mr ms mt bi translated">1: <code class="fe md me mf lt b">0x0000000000000000000000000000000000000000000000000000000000000020</code></li><li id="8436" class="ml mm iq kp b kq mu kt mv kw mw la mx le my li mq mr ms mt bi translated">2: <code class="fe md me mf lt b">0xfcf771399d75a67a6d0e730ae98d34c40b6bfe6ebf8053b98ddf4da8c2706250</code></li></ul><p id="bf86" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">总共有五个LOGn操作码，LOG0到LOG4，其中n表示日志中主题的数量。Topic0始终是事件类型的标识符，由其签名的哈希定义，但可以通过使用LOG0跳过它，LOG0指定匿名事件。每个额外的主题都需要堆栈中的另一个槽，将更多的参数推出可达列表。</p><p id="4799" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">该分析表明，带有一个参数的事件阻止使用一个变量，因为topic0放在堆栈中事件数据之前。这引发了几个问题:</p><ul class=""><li id="df58" class="ml mm iq kp b kq kr kt ku kw mn la mo le mp li mq mr ms mt bi translated">如果我们有更多的话题呢？它们也放在数据之前吗？</li><li id="2167" class="ml mm iq kp b kq mu kt mv kw mw la mx le my li mq mr ms mt bi translated">而更多的事件争论有什么影响，是在话题之后推还是之前推？</li></ul><p id="0196" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">为了验证这一点，我将再次更改合同。请注意，事件可以有任意数量的参数，其中最多有3个可以被索引。索引参数成为主题，而其他参数则集中在数据部分。在这个阶段，我的假设是，每个主题(索引参数)将放在数据之前的堆栈中，因此将阻止对更多早期变量的访问。</p><p id="da0b" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在我的测试中，我涵盖了几个场景，但它们都导致相同的结论，所以我将为您节省分钟的细节。我将用另一个有趣的反直觉的例子来说明，然后得出最后的结论。</p><p id="8b62" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">首先，让我们试试这个版本的契约，其中事件有一个索引值和两个非索引值。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="262e" class="lx ly iq lt b gy lz ma l mb mc">pragma solidity ^0.4.24;</span><span id="2cc5" class="lx ly iq lt b gy mz ma l mb mc">contract TestStackError {<br/>  event LogValue(uint indexed a1, uint a2, uint a3);<br/>  function logArg(uint a1, uint a2, uint a3, uint a4,<br/>	uint a5, uint a6, uint a7, uint a8,<br/>	uint a9, uint a10, uint a11, uint a12,<br/>	uint a13, uint a14, uint a15, uint a16<br/>  ) public {<br/>    emit LogValue(a2, a3, a4);<br/>  }<br/>}</span></pre><p id="3f1d" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这个函数的字节码(在函数分派之后)直到事件被发出为止是这样的:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="f67c" class="lx ly iq lt b gy lz ma l mb mc">265 JUMPDEST<br/>266 DUP15<br/>267 PUSH32 a5397a5faa0ec7cfb89428503b91a13bbd737592f7561e6773fa3e1458c8735c<br/>300 DUP16<br/>301 DUP16<br/>302 PUSH1 40<br/>304 MLOAD<br/>305 DUP1<br/>306 DUP4<br/>307 DUP2<br/>308 MSTORE<br/>309 PUSH1 20<br/>311 ADD<br/>312 DUP3<br/>313 DUP2<br/>314 MSTORE<br/>315 PUSH1 20<br/>317 ADD<br/>318 SWAP3<br/>319 POP<br/>320 POP<br/>321 POP<br/>322 PUSH1 40<br/>324 MLOAD<br/>325 DUP1<br/>326 SWAP2<br/>327 SUB<br/>328 SWAP1<br/>329 LOG2</span></pre><p id="159a" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">发出事件的操作码是<code class="fe md me mf lt b">LOG2</code>。这意味着我们有两个主题，一个是默认主题0(即事件签名)，另一个是事件签名中唯一的索引参数。其余两个值在内存中分组。<br/>如果我们检查这个操作码的<a class="ae lq" href="https://ethervm.io/#A2" rel="noopener ugc nofollow" target="_blank"> <em class="lr"> Ethervm </em> </a>，我们会看到从堆栈中读取的最后一个值，以及第一个被推送到它上面的<em class="lr"/>，是topic1，即索引参数— <code class="fe md me mf lt b">a2</code>。最初，它被放置在堆栈的位置15。操作码<code class="fe md me mf lt b">DUP15</code>将该值的副本放在堆栈的顶部，并因此将所有其他参数压下。比如从现在开始，<code class="fe md me mf lt b">a2</code>在16号位，<code class="fe md me mf lt b">a1</code>在17号位。</p><p id="f646" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">下一条指令将一个32位的值压入堆栈，这只是对应于主题0。这个值是硬编码的。这也有再次压制论点的效果。现在，<code class="fe md me mf lt b">a2</code>在17号位。</p><p id="9780" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">以下指令是两个<code class="fe md me mf lt b">DUP16</code>操作码。第一个复制位置16的值，这是当前的第三个参数<code class="fe md me mf lt b">a3</code>。但是由于这将一个新元素推到堆栈上，当调用下一个操作码时，<code class="fe md me mf lt b">DUP16</code>将把第四个参数复制到函数<code class="fe md me mf lt b">a4</code>中。在这个阶段，在堆栈的顶部，我们有事件的数据(两个单词)、索引参数和事件唯一标识符。</p><p id="ffce" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">下面几行将前两个值复制到内存中:</p><ul class=""><li id="0880" class="ml mm iq kp b kq kr kt ku kw mn la mo le mp li mq mr ms mt bi translated">(302–305):将内存<code class="fe md me mf lt b">0x40</code>的内容放在堆栈的顶部，两次。这是事件数据在内存中的位置(在我的执行中是<code class="fe md me mf lt b">0x80</code>)。</li><li id="edf4" class="ml mm iq kp b kq mu kt mv kw mw la mx le my li mq mr ms mt bi translated">(306–308):将第一个数据字放在内存的第一个空闲位置(即将<code class="fe md me mf lt b">a3</code>放在位置<code class="fe md me mf lt b">0x80</code>)</li><li id="a472" class="ml mm iq kp b kq mu kt mv kw mw la mx le my li mq mr ms mt bi translated">(309–311):将内存中的下一个空闲位置放在堆栈的顶部</li><li id="3888" class="ml mm iq kp b kq mu kt mv kw mw la mx le my li mq mr ms mt bi translated">(312–314):将第二个数据字放在内存中的下一个空闲位置(即将<code class="fe md me mf lt b">a4</code>放在位置<code class="fe md me mf lt b">0xa0</code>)</li><li id="ad2e" class="ml mm iq kp b kq mu kt mv kw mw la mx le my li mq mr ms mt bi translated">(315–321):在删除不再需要的值后，计算内存中的下一个空闲位置，并将其放在堆栈的顶部。</li><li id="9da1" class="ml mm iq kp b kq mu kt mv kw mw la mx le my li mq mr ms mt bi translated">(322–327):通过从内存中下一个空闲位置的当前值(保存在堆栈顶部)中减去该位置的初始地址，得出提交给事件的数据的长度。</li><li id="5f6c" class="ml mm iq kp b kq mu kt mv kw mw la mx le my li mq mr ms mt bi translated">(328):对堆栈的前两个元素重新排序，使第一个元素成为事件数据的开头，第二个地址成为该数据的长度。</li><li id="265e" class="ml mm iq kp b kq mu kt mv kw mw la mx le my li mq mr ms mt bi translated">(329):最后调用日志操作码。</li></ul><p id="bc44" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我给出了这个详细的解释，以便你可以理解这个过程是如何工作的，如果你愿意的话。在这种情况下，也许你现在可以解释下一个明显的奇怪现象。仅将事件的签名更改为:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="060d" class="lx ly iq lt b gy lz ma l mb mc">event LogValue(uint a1, uint indexed a2, uint a3);</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi mg"><img src="../Images/8f534d1a84da66a9f88f647d9ab0cdb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*I1P6ynrR_IeYmi4S"/></div></div></figure><p id="e183" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">是的，另一个堆栈太深的错误。你能看出是什么引起的吗？<br/> …</p><p id="70cb" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi">……</p><p id="4bed" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi">………</p><p id="13f0" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">字节码变化不大。我们仍然有相同数量的主题，所以最后的操作码仍然是<code class="fe md me mf lt b">LOG2</code>。并且它仍然期望以相同的顺序接收它的参数，即首先是主题，然后是数据。</p><p id="76fe" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">现在，必须首先加载第二个主题，所以<code class="fe md me mf lt b">a3</code>将是第一个用<code class="fe md me mf lt b">DUP14</code>推入堆栈的值。那么topic0将被推出。现在，EVM将把需要存储在内存中的两个参数放在堆栈的顶部，<code class="fe md me mf lt b">a2</code>和<code class="fe md me mf lt b">a4</code>。这些最初是在位置15和13。然而，EVM已经两次推动，使这些位置17和15。不可能将第一个值放入堆栈(<code class="fe md me mf lt b">DUP17</code>不存在)，因此会出现编译错误。</p><p id="1aa8" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">现在我们明白了这一点，我试着再改变一件事，将log函数改为:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="474a" class="lx ly iq lt b gy lz ma l mb mc">emit LogValue(a3, a2, a4);</span></pre><p id="5882" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这段代码是有效的，因为它非常接近于我改变索引参数顺序之前的最后一个代码块。在这段代码中，用<code class="fe md me mf lt b">a2</code>调用了事件的索引值。在这个版本中，传递到那个位置的仍然是<code class="fe md me mf lt b">a2</code>，其他保持不变。字节码的解释实际上是一样的。</p><h2 id="aa92" class="lx ly iq bd na nb nc dn nd ne nf dp ng kw nh ni nj la nk nl nm le nn no np nq bi translated">结论</h2><p id="9e2d" class="pw-post-body-paragraph kn ko iq kp b kq nr jr ks kt ns ju kv kw nt ky kz la nu lc ld le nv lg lh li ij bi translated">这是一个很长的帖子。如果您已经到了这一步，那么有必要让您对正在发生的事情有一个有条理的了解，这样您就可以回到您的程序，并思考您的“堆栈过深”错误是否是由类似的行为引起的。虽然这篇文章只讨论了发出事件的情况，但是其他函数将使用其他操作码，但是仍然具有相同的逻辑，在需要一些计算时将函数参数(或中间值)复制到堆栈中。</p><p id="dad2" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">因此，以下是一些需要记住的简化笔记:</p><ul class=""><li id="c83f" class="ml mm iq kp b kq kr kt ku kw mn la mo le mp li mq mr ms mt bi translated">当一个函数被调用时，一个堆栈框架被创建。这从下到上包括:</li><li id="65ec" class="ml mm iq kp b kq mu kt mv kw mw la mx le my li mq mr ms mt bi translated">功能选择器</li><li id="7f95" class="ml mm iq kp b kq mu kt mv kw mw la mx le my li mq mr ms mt bi translated">寄信人地址</li><li id="2be3" class="ml mm iq kp b kq mu kt mv kw mw la mx le my li mq mr ms mt bi translated">函数最左边的值类型参数</li><li id="8c5e" class="ml mm iq kp b kq mu kt mv kw mw la mx le my li mq mr ms mt bi">…</li><li id="e8dc" class="ml mm iq kp b kq mu kt mv kw mw la mx le my li mq mr ms mt bi translated">函数最右边的值类型参数</li><li id="30e7" class="ml mm iq kp b kq mu kt mv kw mw la mx le my li mq mr ms mt bi translated">“堆栈过深”错误取决于操作的核心操作码(如算术、散列、调用另一个函数、发出事件等)。)</li><li id="b967" class="ml mm iq kp b kq mu kt mv kw mw la mx le my li mq mr ms mt bi translated">如果这些核心操作是在纯函数参数上执行的，那么它们传递给函数的顺序可能决定“堆栈过深”错误的发生。(栈槽也可以用于中间计算和局部变量，但是我打算在以后的文章中研究这些。)</li><li id="49cd" class="ml mm iq kp b kq mu kt mv kw mw la mx le my li mq mr ms mt bi translated">了解操作码参数的数量和顺序至关重要。这些参数通常从堆栈中读取(唯一的例外是<code class="fe md me mf lt b">PUSH</code>操作码)。</li><li id="bab5" class="ml mm iq kp b kq mu kt mv kw mw la mx le my li mq mr ms mt bi translated">在执行操作码之前，必须将操作码参数压入堆栈。每个<code class="fe md me mf lt b">PUSH</code>将函数参数下移至少一个槽。堆栈中较深的函数参数是最先处理的参数，即函数签名中最左边的参数。</li><li id="406f" class="ml mm iq kp b kq mu kt mv kw mw la mx le my li mq mr ms mt bi translated">如果操作码操作中没有使用某些函数参数，那么它们应该出现在函数签名中的第一位，以减少操作码参数在需要堆栈时超出范围的机会。</li><li id="0e53" class="ml mm iq kp b kq mu kt mv kw mw la mx le my li mq mr ms mt bi translated">操作码使用堆栈中不同级别的参数。先推更深的层次。如果一个参数在另一个参数之后被压入，它也应该出现在函数签名中的前一个参数之后，否则它会在使用前将另一个参数压入堆栈。示例:</li></ul><ol class=""><li id="42ec" class="ml mm iq kp b kq kr kt ku kw mn la mo le mp li nw mr ms mt bi translated"><em class="lr">考虑一个带有两个索引参数</em> <code class="fe md me mf lt b"><em class="lr">t1</em></code> <em class="lr">和</em> <code class="fe md me mf lt b"><em class="lr">t2</em></code> <em class="lr">的事件，按此顺序调用一个带有多个参数的函数，其中</em> <code class="fe md me mf lt b"><em class="lr">a1</em></code> <em class="lr">在</em> <code class="fe md me mf lt b"><em class="lr">a2</em></code>之前</li><li id="c40c" class="ml mm iq kp b kq mu kt mv kw mw la mx le my li nw mr ms mt bi translated"><em class="lr">如果事件是用</em> <code class="fe md me mf lt b"><em class="lr">t1 = a1</em></code> <em class="lr">和</em> <code class="fe md me mf lt b"><em class="lr">t2 = a2</em></code> <em class="lr">发出的，那么操作码</em> <code class="fe md me mf lt b"><em class="lr">LOG3</em></code> <em class="lr">就会被调用。</em></li><li id="66d3" class="ml mm iq kp b kq mu kt mv kw mw la mx le my li nw mr ms mt bi translated"><em class="lr">在调用这个操作码之前，</em> <code class="fe md me mf lt b"><em class="lr">t2 = a2</em></code> <em class="lr">会先被压入堆栈。</em></li><li id="8a5d" class="ml mm iq kp b kq mu kt mv kw mw la mx le my li nw mr ms mt bi translated"><em class="lr">这会将</em> <code class="fe md me mf lt b"><em class="lr">a1</em></code> <em class="lr">下推，到时候再推</em> <code class="fe md me mf lt b"><em class="lr">t1 = a1</em></code> <em class="lr">的值就有不可达的风险。</em></li><li id="b367" class="ml mm iq kp b kq mu kt mv kw mw la mx le my li nw mr ms mt bi translated"><em class="lr">如果在函数签名中</em> <code class="fe md me mf lt b"><em class="lr">a1</em></code> <em class="lr">在</em> <code class="fe md me mf lt b"><em class="lr">a2</em></code> <em class="lr">之后，这将被避免，因为它在堆栈中比</em> <code class="fe md me mf lt b"><em class="lr">a2</em></code> <em class="lr">更高。假设</em> <code class="fe md me mf lt b"><em class="lr">a2</em></code> <em class="lr">被推送时是可达的，那么</em> <code class="fe md me mf lt b"><em class="lr">a1</em></code> <em class="lr">之后也是可达的。</em></li></ol><ul class=""><li id="47a9" class="ml mm iq kp b kq kr kt ku kw mn la mo le mp li mq mr ms mt bi translated">上面的帖子只关注了<code class="fe md me mf lt b">LOGn</code>操作码，特别是在堆栈中需要3或4个参数的版本。更困难的情况是调用其他契约或库中的函数，因为操作码<code class="fe md me mf lt b">CALL</code>和<code class="fe md me mf lt b">DELEGATECALL</code>各接受7或6个输入参数，操作码和函数参数之间有更多交互的可能性。</li></ul><p id="d392" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我希望这能给你一些关于如何调试和处理“栈太深”错误的线索。还有很多话要说，但那要等其他机会了。</p><p id="9a27" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">下次见。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi nx"><img src="../Images/9c2558d79b8a408e9c5771eb58a52244.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xh5WG6RxRX2-sFG8aCqGXQ.jpeg"/></div></div><figcaption class="ny nz gj gh gi oa ob bd b be z dk translated">Alexandre Pinto——Artos(Aventus生态系统党)的区块链开发人员</figcaption></figure><p id="66ce" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">Alex是我们生态系统合作伙伴Artos的软件工程师，在区块链工程团队工作。他拥有20年的技术工作经验，完成了计算机科学博士学位和密码学博士后学位。作为研究的一部分，Alex <a class="ae lq" href="https://www.researchgate.net/profile/Alexandre_Pinto2" rel="noopener ugc nofollow" target="_blank">发表了关于Kolmogorov复杂性、密码学、数据库匿名化和代码混淆的论文</a>。</p><p id="60ff" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">Pinto还花了七年时间在Maia大学学院讲课，包括指导计算机科学和信息系统与软件学士学位课程。</p><p id="d6ea" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这篇文章最初发表在他的博客上。</p><p id="b3c0" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">既然你在这里，我们希望你能在<a class="ae lq" href="https://t.me/joinchat/HIDa30p_VOA2Mk-V14EVMA" rel="noopener ugc nofollow" target="_blank"><strong class="kp ir"/></a><strong class="kp ir"/><a class="ae lq" href="https://www.reddit.com/r/Aventus/" rel="noopener ugc nofollow" target="_blank"><strong class="kp ir">Reddit</strong></a><strong class="kp ir"/><a class="ae lq" href="https://twitter.com/AventusNetwork" rel="noopener ugc nofollow" target="_blank"><strong class="kp ir">Twitter</strong></a><strong class="kp ir"/><a class="ae lq" href="https://www.facebook.com/AventusNetwork/" rel="noopener ugc nofollow" target="_blank"><strong class="kp ir">【脸书</strong></a><strong class="kp ir"/><a class="ae lq" href="http://www.youtube.com/c/AventusNetwork" rel="noopener ugc nofollow" target="_blank"><strong class="kp ir">Youtube</strong><strong class="kp ir"/></a><a class="ae lq" href="https://www.instagram.com/aventusnetwork/" rel="noopener ugc nofollow" target="_blank"><strong class="kp ir">insta gram上与我们联系</strong></a></p><p id="f91d" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">此外，我们已经为票务开发者/其他开发者建立了一个<a class="ae lq" href="https://www.linkedin.com/groups/12118192/" rel="noopener ugc nofollow" target="_blank"> <strong class="kp ir"> LinkedIn群组</strong></a>来参与、加入我们并开始对话。</p></div><div class="ab cl lj lk hu ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="ij ik il im in"><figure class="kg kh ki kj gt kk gh gi paragraph-image"><a href="https://levelup.gitconnected.com/"><div class="gh gi oc"><img src="../Images/439094b9a664ef0239afbc4565c6ca49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S9uYu-fFL3hIQLGVu0o-EQ.png"/></div></a></figure><div class="od oe gp gr of og"><a href="https://gitconnected.com/learn/solidity" rel="noopener  ugc nofollow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd ir gy z fp ol fr fs om fu fw ip bi translated">学习坚固性-最佳坚固性教程(2019) | gitconnected</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">14大坚实度教程。课程由开发者提交并投票，让你找到最好的稳定性…</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">gitconnected.com</p></div></div><div class="op l"><div class="oq l or os ot op ou kl og"/></div></div></a></div></div></div>    
</body>
</html>