<html>
<head>
<title>Python Decorators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python装饰者</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/python-decorators-b530bff0f3e3?source=collection_archive---------7-----------------------#2020-09-07">https://levelup.gitconnected.com/python-decorators-b530bff0f3e3?source=collection_archive---------7-----------------------#2020-09-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="81b0" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">关于如何使用python decorator语法进行更简洁编码的教程</h2></div><p id="5fe6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Python附带了许多语法人工制品，使开发人员能够更快地构建应用程序，最重要的是，代码简洁。如果你是程序员，你就知道代码质量和可靠性有多重要！所以在这篇文章中，我将简单介绍一下python decorators。如果你对更干净有效的编码感兴趣，可以看看我下面的文章。</p><div class="lb lc gp gr ld le"><a href="https://towardsdatascience.com/python-generators-393455aa48a3" rel="noopener follow" target="_blank"><div class="lf ab fo"><div class="lg ab lh cl cj li"><h2 class="bd ir gy z fp lj fr fs lk fu fw ip bi translated">Python生成器</h2><div class="ll l"><h3 class="bd b gy z fp lj fr fs lk fu fw dk translated">使用yield关键字开发python生成器函数的教程</h3></div><div class="lm l"><p class="bd b dl z fp lj fr fs lk fu fw dk translated">towardsdatascience.com</p></div></div><div class="ln l"><div class="lo l lp lq lr ln ls lt le"/></div></div></a></div><p id="792a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们开始使用python decorators之前，我们需要理解python函数是如何工作的。Python函数被认为是<strong class="kh ir">一级函数</strong>，这意味着它们可以被当作对象来对待，可以随意传递。</p><p id="8d44" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Python可以在函数中定义函数，称为<strong class="kh ir">内部函数</strong>。一个函数也可以从另一个函数返回(这是在Python中实现开关操作符的一种方式)。</p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="gh gi lu"><img src="../Images/3dd43b8a6c882f43f5b347eb8fb2ffc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lgYZIiL3QHPaPLDz5KxinA.jpeg"/></div></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">马库斯·斯皮斯克在<a class="ae mj" href="https://unsplash.com/s/photos/decorate?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="e5e2" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">函数作为面向对象对象的应用</h1><h2 id="4e15" class="nc ml iq bd mm nd ne dn mq nf ng dp mu ko nh ni mw ks nj nk my kw nl nm na nn bi translated">开关盒实现</h2><p id="4093" class="pw-post-body-paragraph kf kg iq kh b ki no jr kk kl np ju kn ko nq kq kr ks nr ku kv kw ns ky kz la ij bi translated">Python字典是一种对象构造，其中对象将被返回给它所引用的键。因为Python没有显式的switch操作符，所以我们使用<code class="fe nt nu nv nw b">dict</code>构造来创建一个。请看这个例子。</p><pre class="lv lw lx ly gt nx nw ny nz aw oa bi"><span id="740f" class="nc ml iq nw b gy ob oc l od oe">op_switch = {<br/>    'sqr': lambda x: x**2,<br/>    'sqrt': lambda x: x**0.5,<br/>    'abs': lambda x: abs(x)<br/>}</span></pre><p id="e3fb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的开关案例是基于一个字符串来选择<strong class="kh ir">操作</strong>。字典返回一个函数。为了简化代码，我使用了lambda函数定义。它们的行为类似于函数的行为(不完全相同！).可以通过以下方式访问它们。</p><pre class="lv lw lx ly gt nx nw ny nz aw oa bi"><span id="408c" class="nc ml iq nw b gy ob oc l od oe">&gt;&gt;&gt; switch['sqr'](12)<br/>144<br/>&gt;&gt;&gt; switch['sqrt'](25)<br/>5.0</span></pre><h2 id="7c5f" class="nc ml iq bd mm nd ne dn mq nf ng dp mu ko nh ni mw ks nj nk my kw nl nm na nn bi translated">将一个函数传递给另一个函数</h2><p id="fbdf" class="pw-post-body-paragraph kf kg iq kh b ki no jr kk kl np ju kn ko nq kq kr ks nr ku kv kw ns ky kz la ij bi translated">考虑一种需要包装另一个函数的情况。想象一下，包装函数可以被许多其他函数共享。在我给你讲一个真实的工作例子之前，让我们先来看看这个宠物场景。</p><p id="1063" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设您需要一个函数来执行函数并返回答案。如果抛出异常，将返回<code class="fe nt nu nv nw b"><strong class="kh ir">None</strong></code>。</p><pre class="lv lw lx ly gt nx nw ny nz aw oa bi"><span id="cfa2" class="nc ml iq nw b gy ob oc l od oe">def deco_function(func, *args):<br/>    try:<br/>        return func(*args)<br/>    except:<br/>        print("Error occured")<br/>        return None<br/>    <br/>def divide(a, b):<br/>    return a/b</span></pre><p id="c3bc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的<code class="fe nt nu nv nw b">deco_function</code>函数将使用作为<code class="fe nt nu nv nw b">*args</code>传递的一组参数来执行传递的函数。为了简单起见，我省略了关键字参数。如果我们运行这个，我们将看到我们给定的每个参数的如下输出。</p><pre class="lv lw lx ly gt nx nw ny nz aw oa bi"><span id="6c32" class="nc ml iq nw b gy ob oc l od oe">&gt;&gt;&gt; deco_function(divide, 10, 2)<br/>5.0<br/>&gt;&gt;&gt; deco_function(divide, 10, 0)<br/>Error occured</span></pre><p id="2a9a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">很漂亮对吧！</p><blockquote class="of og oh"><p id="ceef" class="kf kg oi kh b ki kj jr kk kl km ju kn oj kp kq kr ok kt ku kv ol kx ky kz la ij bi translated">这种方法的主要问题是包装函数的函数签名必须是众所周知的。我们需要传递函数本身和参数。这在复杂的场景中更难维护！</p></blockquote><h1 id="2666" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">Python Decorators简介</h1><p id="2e94" class="pw-post-body-paragraph kf kg iq kh b ki no jr kk kl np ju kn ko nq kq kr ks nr ku kv kw ns ky kz la ij bi translated">使用python decorators语法，可以用更好的语法来修饰上面的相同函数。让我们看看怎么做。</p><pre class="lv lw lx ly gt nx nw ny nz aw oa bi"><span id="4111" class="nc ml iq nw b gy ob oc l od oe">def deco_function(func):<br/>    def wrapped(*args):<br/>        """<br/>        This is the wrapper for a function to be fail safe<br/>        """<br/>        try:<br/>            return func(*args)<br/>        except:<br/>            print("Error occured")<br/>            return None<br/>    return wrapped<br/>    <br/>@deco_function<br/>def divide(a, b):    <br/>    """<br/>    This is a function to divide two numbers<br/>    """<br/>    return a/b</span></pre><p id="3bf3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个例子中，我们用<code class="fe nt nu nv nw b">deco_function</code>装饰器来装饰<code class="fe nt nu nv nw b">divide</code>函数。在装饰器中，包装器被放置在传递的函数周围，并返回<code class="fe nt nu nv nw b">wrapper</code>。这类似于下面的语句。</p><pre class="lv lw lx ly gt nx nw ny nz aw oa bi"><span id="7b9e" class="nc ml iq nw b gy ob oc l od oe">divide = deco_function(divide)</span></pre><p id="e89c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，我们现在可以自由地忘记call_function实现了。这真是太棒了！</p><h2 id="4e87" class="nc ml iq bd mm nd ne dn mq nf ng dp mu ko nh ni mw ks nj nk my kw nl nm na nn bi translated">真实世界的装饰用法！</h2><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="gh gi om"><img src="../Images/2af57c099e96f2f38e3a4751812f58b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8M2ILwDAhQ_FOAbN38apjA.png"/></div></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">作者截图取自<a class="ae mj" href="https://flask.palletsprojects.com/en/1.1.x/quickstart/#routing" rel="noopener ugc nofollow" target="_blank"> Flask网站</a></figcaption></figure><p id="5162" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你不熟悉装饰用例；让我们来看看Flask服务器。</p><p id="d4be" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae mj" href="https://flask.palletsprojects.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir"> Flask是python的服务器实现。</strong> </a>截图显示了如何使用decorators在<strong class="kh ir"> Flask </strong>中实现路由。我们只需提及激活该功能的途径。到目前为止，我们还没有讨论如何将参数传递给装饰者。我们将很快讨论这个问题！</p><h2 id="1c4d" class="nc ml iq bd mm nd ne dn mq nf ng dp mu ko nh ni mw ks nj nk my kw nl nm na nn bi translated">正确使用装饰符和函数名</h2><p id="717e" class="pw-post-body-paragraph kf kg iq kh b ki no jr kk kl np ju kn ko nq kq kr ks nr ku kv kw ns ky kz la ij bi translated">需要记住的一点是，包装一个函数会导致对其身份的混淆。这是因为一旦我们用别的东西包装它，函数就不再是它自己了。</p><pre class="lv lw lx ly gt nx nw ny nz aw oa bi"><span id="1591" class="nc ml iq nw b gy ob oc l od oe">&gt;&gt;&gt; divide.__name__<br/>wrapped<br/>&gt;&gt;&gt; print(divide.__doc__)</span><span id="ab6f" class="nc ml iq nw b gy on oc l od oe">This is the wrapper for a function to be fail safe</span></pre><p id="aa0e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">函数的<code class="fe nt nu nv nw b">__name__</code>属性返回函数名本身，打印<code class="fe nt nu nv nw b">__doc__</code>返回文档字符串。然而，我们可以看到，这两个属性的值都是从包装函数中获得的，而不是从引用函数中获得的。这在大型软件中会导致严重的混乱。以下是修复方法。</p><pre class="lv lw lx ly gt nx nw ny nz aw oa bi"><span id="e793" class="nc ml iq nw b gy ob oc l od oe"><strong class="nw ir">import functools</strong></span><span id="2e79" class="nc ml iq nw b gy on oc l od oe">def deco_function(func):<br/>    <strong class="nw ir">@functools.wraps(func)</strong><br/>    def wrapped(*args):<br/>        """<br/>        This is the wrapper for a function to be fail safe<br/>        """<br/>        try:<br/>            return func(*args)<br/>        except:<br/>            print("Error occured")<br/>            return None<br/>    return wrapped<br/>    <br/>@deco_function<br/>def divide(a, b):    <br/>    """<br/>    This is a function to divide two numbers<br/>    """<br/>    return a/b</span></pre><p id="f306" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意<strong class="kh ir">粗体</strong>中的代码。我们导入<code class="fe nt nu nv nw b"><strong class="kh ir">functools</strong></code>并装饰我们的包装。这个<code class="fe nt nu nv nw b">functiontools.wraps</code>装饰器将<strong class="kh ir"> docstring </strong>和<strong class="kh ir"> name </strong>属性注入到包装器中，以便我们在打印<code class="fe nt nu nv nw b">__name__</code>和<code class="fe nt nu nv nw b">__doc__</code>时获得正确的属性。</p><pre class="lv lw lx ly gt nx nw ny nz aw oa bi"><span id="fa87" class="nc ml iq nw b gy ob oc l od oe">&gt;&gt;&gt; print(divide.__name__)<br/>divide<br/>&gt;&gt;&gt; print(divide.__doc__)</span><span id="ff2c" class="nc ml iq nw b gy on oc l od oe">This is a function to divide two numbers</span></pre><h2 id="baba" class="nc ml iq bd mm nd ne dn mq nf ng dp mu ko nh ni mw ks nj nk my kw nl nm na nn bi translated">了解参数和关键字参数的工作原理</h2><p id="d3c6" class="pw-post-body-paragraph kf kg iq kh b ki no jr kk kl np ju kn ko nq kq kr ks nr ku kv kw ns ky kz la ij bi translated">Python接受<strong class="kh ir">有序参数</strong>，后跟<strong class="kh ir">关键字参数</strong>。这可以通过以下方式证明。</p><pre class="lv lw lx ly gt nx nw ny nz aw oa bi"><span id="a354" class="nc ml iq nw b gy ob oc l od oe">import functools</span><span id="56d7" class="nc ml iq nw b gy on oc l od oe">def print_args(func):<br/>    @functools.wraps(func)<br/>    def wrapped(*args, **kwargs):<br/>        args_arr = [(n, a) for n, a in enumerate(args)]                      <br/>        kwargs_arr = [(k, v) for k, v in kwargs.items()]</span><span id="c94b" class="nc ml iq nw b gy on oc l od oe">for k, v in args_arr + kwargs_arr:<br/>            print(k, v)<br/>    return wrapped<br/>    <br/>@print_args<br/>def test_function(*args, **kwargs):    <br/>    return a/b</span></pre><p id="0d4c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">调用上面的<code class="fe nt nu nv nw b">test_function</code>函数会得到下面的结果。</p><pre class="lv lw lx ly gt nx nw ny nz aw oa bi"><span id="b313" class="nc ml iq nw b gy ob oc l od oe">&gt;&gt;&gt; test_function('name', 'age', height=150, weight=50)<br/>0 name<br/>1 age<br/>height 150<br/>weight 50</span></pre><p id="a0cd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">根据上述观察，必须注意到<strong class="kh ir">自变量</strong>是在<strong class="kh ir">关键字自变量</strong>之前组织的。参数中的顺序必须保持不变，关键字参数中的顺序无关紧要。在包装器中，参数和关键字参数都必须传递给被包装的函数。这确保了包装的更广泛的可用性。</p><h1 id="4aba" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">有争论的装饰者</h1><p id="8aa7" class="pw-post-body-paragraph kf kg iq kh b ki no jr kk kl np ju kn ko nq kq kr ks nr ku kv kw ns ky kz la ij bi translated">现在我们已经清楚地了解了装饰器是如何工作的，让我们看看如何使用带有参数的装饰器。</p><pre class="lv lw lx ly gt nx nw ny nz aw oa bi"><span id="fc8f" class="nc ml iq nw b gy ob oc l od oe">def powered(power):<br/>    def powered_decorator(func):<br/>        def wrapper(*args):<br/>            return func(*args)**power<br/>        return wrapper<br/>    return powered_decorator</span><span id="c2d7" class="nc ml iq nw b gy on oc l od oe">@powered(2)<br/>def add(*args):<br/>    return sum(args)</span></pre><p id="d031" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的例子中，我们有一个带有属性的包装器。简单地说，这个包装器要求将答案提升到由属性指定的幂。下面是几个可以找到参数化装饰器的例子。</p><ol class=""><li id="b357" class="oo op iq kh b ki kj kl km ko oq ks or kw os la ot ou ov ow bi translated">验证输入字段、JSON字符串、文件存在等。</li><li id="78be" class="oo op iq kh b ki ox kl oy ko oz ks pa kw pb la ot ou ov ow bi translated">实现开关外壳装饰器</li></ol><h1 id="fe09" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">装饰者的高级用例</h1><p id="a043" class="pw-post-body-paragraph kf kg iq kh b ki no jr kk kl np ju kn ko nq kq kr ks nr ku kv kw ns ky kz la ij bi translated">装饰器可以以类似的方式用于类。然而，这里我们可以讨论两种使用装饰者的方法；在一个班级里，也为了一个班级。</p><h2 id="7b38" class="nc ml iq bd mm nd ne dn mq nf ng dp mu ko nh ni mw ks nj nk my kw nl nm na nn bi translated">一个类中的装饰者</h2><p id="f96a" class="pw-post-body-paragraph kf kg iq kh b ki no jr kk kl np ju kn ko nq kq kr ks nr ku kv kw ns ky kz la ij bi translated">在下面的例子中，我在类<code class="fe nt nu nv nw b">Calculator</code>的函数上使用了装饰器。这有助于我在操作失败时优雅地获取值。</p><pre class="lv lw lx ly gt nx nw ny nz aw oa bi"><span id="151f" class="nc ml iq nw b gy ob oc l od oe">import functools</span><span id="d51a" class="nc ml iq nw b gy on oc l od oe">def try_safe(func):<br/>    @functools.wraps(func)<br/>    def wrapped(*args):<br/>        try:<br/>            return func(*args)<br/>        except:<br/>            print("Error occured")<br/>            return None<br/>    return wrapped</span><span id="3757" class="nc ml iq nw b gy on oc l od oe">class Calculator:<br/>    <br/>    def __init__(self):<br/>        pass<br/>    <br/>    @try_safe<br/>    def add(self, *args):<br/>        return sum(args)<br/>    <br/>    @try_safe<br/>    def divide(self, a, b):<br/>        return a/b</span></pre><p id="5bbe" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的代码可以如下使用。</p><pre class="lv lw lx ly gt nx nw ny nz aw oa bi"><span id="dc84" class="nc ml iq nw b gy ob oc l od oe">&gt;&gt;&gt; calc = Calculator()<br/>&gt;&gt;&gt; calc.divide(10, 2)<br/>5.0</span></pre><h2 id="2da3" class="nc ml iq bd mm nd ne dn mq nf ng dp mu ko nh ni mw ks nj nk my kw nl nm na nn bi translated">一个类的装饰者</h2><p id="c3e3" class="pw-post-body-paragraph kf kg iq kh b ki no jr kk kl np ju kn ko nq kq kr ks nr ku kv kw ns ky kz la ij bi translated">对一个类使用装饰器将在函数的实例化过程中激活装饰器。例如，下面的代码将使用构造函数参数检查对象的创建是否正常。如果操作失败，<code class="fe nt nu nv nw b">None</code>将代替<code class="fe nt nu nv nw b">Calculator</code>类中的对象返回。</p><pre class="lv lw lx ly gt nx nw ny nz aw oa bi"><span id="b905" class="nc ml iq nw b gy ob oc l od oe">import functools</span><span id="eec7" class="nc ml iq nw b gy on oc l od oe">def try_safe(cls):<br/>    @functools.wraps(cls)<br/>    def wrapped(*args):<br/>        try:<br/>            return cls(*args)<br/>        except:<br/>            print("Error occured")<br/>            return None<br/>    return wrapped</span><span id="381c" class="nc ml iq nw b gy on oc l od oe">@try_safe<br/>class Calculator:<br/>    <br/>    def __init__(self, a, b):<br/>        self.ratio = a/b</span></pre><h2 id="2da6" class="nc ml iq bd mm nd ne dn mq nf ng dp mu ko nh ni mw ks nj nk my kw nl nm na nn bi translated">使用Decorators为函数注入状态</h2><p id="93ab" class="pw-post-body-paragraph kf kg iq kh b ki no jr kk kl np ju kn ko nq kq kr ks nr ku kv kw ns ky kz la ij bi translated">在包装函数的过程中，可以向函数中注入一个状态。让我们看看下面的例子。</p><pre class="lv lw lx ly gt nx nw ny nz aw oa bi"><span id="1473" class="nc ml iq nw b gy ob oc l od oe">import functools</span><span id="cd8e" class="nc ml iq nw b gy on oc l od oe">def record(func):<br/>    @functools.wraps(func)<br/>    def wrapped(*args):<br/>        wrapped.record += 1<br/>        print(f"Ran for {wrapped.record} time(s)")<br/>        return func(*args)<br/>    wrapped.record = 0<br/>    return wrapped</span><span id="8eb4" class="nc ml iq nw b gy on oc l od oe">@record<br/>def test():<br/>    print("Running")</span></pre><p id="8d63" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">运行上面的示例会得到下面的输出。</p><pre class="lv lw lx ly gt nx nw ny nz aw oa bi"><span id="5953" class="nc ml iq nw b gy ob oc l od oe">&gt;&gt;&gt; test()<br/>Ran for 1 time(s)<br/>Running<br/>&gt;&gt;&gt; test()<br/>Ran for 2 time(s)<br/>Running<br/>&gt;&gt;&gt; test()<br/>Ran for 3 time(s)<br/>Running</span></pre><p id="33e2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这在使用decorators创建单例时很有用。接下来让我们看看。</p><h2 id="b067" class="nc ml iq bd mm nd ne dn mq nf ng dp mu ko nh ni mw ks nj nk my kw nl nm na nn bi translated">使用Python装饰器的单例</h2><p id="8292" class="pw-post-body-paragraph kf kg iq kh b ki no jr kk kl np ju kn ko nq kq kr ks nr ku kv kw ns ky kz la ij bi translated"><strong class="kh ir"> Singleton </strong>指的是调用之间共享的实例，不会因为任何原因而重复。简单地说，首先，创建一个实例。在下面创建实例的调用中，将返回现有的实例。</p><p id="ec68" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们看看如何使用decorators实现一个singleton。</p><pre class="lv lw lx ly gt nx nw ny nz aw oa bi"><span id="eaf0" class="nc ml iq nw b gy ob oc l od oe">import functools</span><span id="34b3" class="nc ml iq nw b gy on oc l od oe">def singleton(cls):<br/>    @functools.wraps(cls)<br/>    def wrapped(*args, **kwargs):<br/>        if not wrapped.object:<br/>            wrapped.object = cls(*args, **kwargs)<br/>        return wrapped.object<br/>    wrapped.object = None<br/>    return wrapped</span><span id="d4ef" class="nc ml iq nw b gy on oc l od oe">@singleton<br/>class SingularObject:<br/>    def __init__(self):<br/>        print("The object is being created")</span></pre><p id="ac0b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以按如下方式确认功能。</p><pre class="lv lw lx ly gt nx nw ny nz aw oa bi"><span id="959c" class="nc ml iq nw b gy ob oc l od oe">&gt;&gt;&gt; first = SingularObject()<br/>The object is being created<br/>&gt;&gt;&gt; second = SingularObject()<br/>&gt;&gt;&gt; second is first<br/>True</span></pre><p id="3abd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些对象引用同一个实例。因此，我们保证不再创建更多的对象。这样一个独生子！</p><h2 id="ccda" class="nc ml iq bd mm nd ne dn mq nf ng dp mu ko nh ni mw ks nj nk my kw nl nm na nn bi translated">制作包装器/装饰器类</h2><p id="bb1b" class="pw-post-body-paragraph kf kg iq kh b ki no jr kk kl np ju kn ko nq kq kr ks nr ku kv kw ns ky kz la ij bi translated">到目前为止，我们只考虑了作为包装器或装饰器的函数。然而，在OOP程序中，类可能是首选。我们只需对我们的<strong class="kh ir">记录</strong>示例做一些修改就可以实现这一点。让我们看看代码。</p><pre class="lv lw lx ly gt nx nw ny nz aw oa bi"><span id="4546" class="nc ml iq nw b gy ob oc l od oe"><strong class="nw ir">import functools</strong></span><span id="a2de" class="nc ml iq nw b gy on oc l od oe">class Record:<br/>    def __init__(self, func):<br/>        <strong class="nw ir">functools.update_wrapper(self, func)</strong><br/>        self.func = func<br/>        self.record = 0</span><span id="24a3" class="nc ml iq nw b gy on oc l od oe">def __call__(self, *args, **kwargs):<br/>        self.record += 1<br/>        print(f"Ran for {self.record} time(s)")<br/>        return self.func(*args, **kwargs)</span><span id="b1a0" class="nc ml iq nw b gy on oc l od oe">@Record<br/>def test():<br/>    print("Run")</span></pre><p id="b1d6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意<strong class="kh ir">粗体</strong>中的部分。我们使用<code class="fe nt nu nv nw b"><strong class="kh ir">functools</strong></code>来更新函数属性。我们使用<code class="fe nt nu nv nw b">__call__</code>重载来定义函数调用的动作。构造函数<code class="fe nt nu nv nw b">__init__</code>初始化变量，类似于我们在前面的有状态装饰器例子中在包装函数之后所做的。上述示例的输出如下。</p><pre class="lv lw lx ly gt nx nw ny nz aw oa bi"><span id="fa13" class="nc ml iq nw b gy ob oc l od oe">&gt;&gt;&gt; test()<br/>Ran for 1 time(s)<br/>Run<br/>&gt;&gt;&gt; test()<br/>Ran for 2 time(s)<br/>Run<br/>&gt;&gt;&gt; test()<br/>Ran for 2 time(s)<br/>Run</span></pre><h1 id="9b62" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">结束语</h1><p id="9001" class="pw-post-body-paragraph kf kg iq kh b ki no jr kk kl np ju kn ko nq kq kr ks nr ku kv kw ns ky kz la ij bi translated">在本文中，我展示了如何使用decorators以一种更加简单和干净的方式实现包装器。下面是您可能在下一个项目中使用包装器的几个例子。</p><ol class=""><li id="0bf6" class="oo op iq kh b ki kj kl km ko oq ks or kw os la ot ou ov ow bi translated">例如，在AWS lambda函数中实现路由机制</li><li id="5b69" class="oo op iq kh b ki ox kl oy ko oz ks pa kw pb la ot ou ov ow bi translated">API缓存机制，您可能希望跟踪最后几次函数调用</li><li id="e20a" class="oo op iq kh b ki ox kl oy ko oz ks pa kw pb la ot ou ov ow bi translated">物联网应用中的去抖(限制短时间内发生的函数调用)</li></ol><p id="3391" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我知道你是否能想到任何其他你可能使用过装饰者的创造性应用。我很想听听。</p><p id="2374" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我希望你喜欢这篇文章。干杯！</p></div></div>    
</body>
</html>