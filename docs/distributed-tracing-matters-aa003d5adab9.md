# 分布式跟踪事务

> 原文：<https://levelup.gitconnected.com/distributed-tracing-matters-aa003d5adab9>

## 总体可观察性

## 构建分布式系统是一项具有挑战性的任务。使用分布式跟踪解决方案，让操作部分变得令人愉快。

![](img/9a4f09dfa0bdd2fcf2c8ee24c3e73619.png)![](img/4d37c26deb2ad1c39e493146d327362d.png)![](img/2e4eb25430d2bfc053c36b9e7d7704be.png)

照片由 [**亚历克斯·蒙特斯、**](https://www.pexels.com/@alex-montes-892479?utm_content=attributionCopyText&utm_medium=referral&utm_source=pexels) [**阿克维兹**](https://www.pexels.com/@akwice?utm_content=attributionCopyText&utm_medium=referral&utm_source=pexels)**&**布鲁诺·蒙特斯** 发自 [**Pexels**](https://pexels.com)**

**面对一个整体的问题是很容易调查的。您可以查找执行跟踪，并详细查看错误和瓶颈。有时，快速查看堆栈跟踪可以发现您的业务流程有什么问题。**

**对于分布式系统，尤其是无服务器云架构，情况并非如此。单个流程通常会调用几个函数或调度消息，从而导致事件驱动的处理。调试如此复杂的分布式系统可能会很困难。将请求和操作关联起来并不是一件简单的任务，但这恰恰是发现 bug、不一致或瓶颈所需要的。**

**这就是为什么你需要分布式追踪，支配你的团队结构和生态系统。它通过为您提供关于专用请求或触发的业务流程的所有已执行代码的详细见解，提供了极大的帮助。**

**在本文中，我将向您介绍 OpenTracing API、W3C 的跟踪上下文规范，以及如何构建您自己的定制集成，您可以使用该集成为您选择的跟踪工具创建和扩展跟踪上下文。**

*   **推理——为什么分布式追踪很重要**
*   **一个独立于供应商的框架**
*   ***概念* —跨度、范围&螺纹**
*   ***深潜* —了解跟踪父级&跟踪状态**
*   ***动手* —初始化轨迹，打开&关闭跨度**
*   ***关键要点***

# **为什么分布式跟踪不是可选的**

**现代软件架构通常是多个协同工作的系统的融合。一个系统上的单个请求可能会导致生态系统中的大量操作和流程。有时，它们甚至不是同步的，而是通过基于事件的驱动架构完全解耦的。**

**这使得调试成为一项繁琐而复杂的任务。此外，观察单个事务并不容易。您不能简单地依赖单个系统的堆栈跟踪，因为代码是在多个系统上执行的。**

**![](img/06df01028998478ddac9fce68fc56644.png)**

**具有多个解耦操作的分布式系统**

**看一下 AWS 上一些虚构架构的例子，我们看到有许多代码在不同的系统上执行，只是为了一个外部触发器。**

*   **数据被写入 DynamoDB，但更改通过流转发。**
*   **消息被排队到 SQS，然后由另一个 Lambda 函数处理。**
*   **发出对外部服务的调用，这将导致进一步的传入请求。**

**尽管操作看起来是分离的，但它们通常与同一个触发器相关，因此从业务角度来看是耦合的。只有当您能够将完整业务流程中包含的每个操作关联起来时，发生的问题才能得到解决。**

**![](img/4c952a6c7ee40f3f144350bff3aa6036.png)**

**跨越多个独立团队的多个系统的过程**

**如果你正在进行一个多团队项目，而产品是由独立团队开发的，这就变得更加明显了。事实上，每个团队都会监控自己负责的资源和微服务。但是，如果客户抱怨请求缓慢，并且没有团队报告任何性能瓶颈，该怎么办呢？如果没有任何团队总体的请求关联，就不可能详细调查这些问题。**

**总结一下:有很多理由支持分布式跟踪。**

## **概述**

**如果您想在多个系统上跟踪您的请求，您需要收集路线上每一步的数据。**

**![](img/49078ecbc666971918c709fa8500d64f.png)**

**多个服务上的 Web 事务，向跟踪收集器发送上下文信息**

**在我们的示例中，我们的浏览器提交第一个请求，这将启动整个操作的上下文。它需要发送请求本身，并附加关于上下文的更多信息，以便您的跟踪收集器可以稍后关联请求，并且所有后续系统可以通过添加关于它们执行的代码的细节来扩展它。**

**流程中涉及的每个系统都需要将其有关已执行代码的详细信息发送到中央处理实例，我们稍后可以使用该实例来分析我们的结果。**

# **OpenTracing API**

**[引用简介](https://opentracing.io/docs/overview/what-is-tracing/):**

> **OpenTracing 由 API 规范、实现该规范的框架和库以及项目文档组成。OpenTracing 允许开发人员使用 API 向他们的应用程序代码添加工具，这些 API 不会将他们局限于任何特定的产品或供应商。**

**尽管它不是一个标准，但它被许多框架和服务广泛使用，允许创建遵循定义的准则的定制实现。**

# **概念**

**本段介绍了核心概念和术语。我们将详细了解一下`Spans`、`Scopes`和`Threads`。**

## **跨度**

**跨度是分布式跟踪的基本概念。跨度代表执行的代码或工作的具体数量。看看 OpenTracing 规范，它包含:**

*   **操作的名称**
*   **开始和结束时间**
*   **一组标记(用于查询)和日志(用于特定于 span 的消息)**
*   **一个背景**

**这意味着请求中涉及的生态系统中的每个组件应该至少贡献一个跨度。因为一个跨度可以引用其他跨度，所以我们可以从这些多个跨度中构建一个完整的堆栈跟踪，以覆盖单个请求中的所有操作。span 的细粒度是没有限制的。这条线基本上可以画在任何地方，从覆盖整个复杂的过程到跨越单一功能甚至操作。**

**![](img/e3ea346e1723d6abec64d6dd00d949c1.png)**

**涵盖 DynamoDB 查询操作的范围，包括名称和时间戳**

## **范围和线程**

**看看应用程序中的专用线程，它一次只能有一个活动跨度，称为`ActiveSpan`。这并不意味着不能有多个跨度，但是其他的需要被阻塞或等待。**

**如果产生了一个新的 span，如果没有另外指定，当前活动的 span 将自动成为它的父 span。**

# **深潜**

**在系统之间传输我们的上下文围绕着两个不同的 HTTP 头:`traceparent`和`tracestate`。它将包含关于如何关联所有相关范围的信息的所有信息。它是由 W3C 的跟踪上下文指定的。**

*   **`traceparent` —指定对追踪系统的要求，不依赖于任何供应商。**
*   **`tracestate` —包括请求的特定于供应商的详细信息。**

## **跟踪父项**

**`traceparent`头携带四种不同的信息:版本、跟踪标识符、父标识符和标志。**

**![](img/448021e2ef6489c9cc3ac91405a68ff6.png)**

**traceparent HTTP 头示例**

*   **版本—标识版本，当前为`00`。**
*   **TraceID —分布式跟踪的唯一标识符。**
*   **ParentID —调用者已知的请求标识符。**
*   **跟踪标志—用于指定采样或跟踪级别等选项。**

**跟踪系统需要 trace parent 来关联我们的请求，并将它们聚合成一个多跨度请求。**

## **跟踪状态**

**`tracestate`头是跟踪父对象的伴随物，添加了特定于供应商的跟踪信息。**

**看看 NewRelic 的一个例子:**

**![](img/e80589b367e4a94617a6f51b577848f6.png)**

**NewRelic 发送的 tracestate HTTP 标头示例**

**我们可以识别父设备、时间跨度的时间戳以及我们的供应商。跟踪状态头可以携带哪些信息，或者它应该是什么样子，并没有固定的规则，因此根据您使用的跟踪工具，它可能会有很大的不同。**

# **亲自动手**

**现在我们已经讨论了这些概念。让我们通过理解如何利用这一概念来初始化跟踪，以及如何通过自己打开和关闭跨度来扩展跟踪，从而将这一点付诸实践。**

**尽管分布式跟踪工具为许多不同的语言和框架提供了代理，但是如果您需要手动扩展您的跟踪，这可能很重要。**

**让我们来看一个基本的场景，在这个场景中，我们想要添加到分布式跟踪中的系统只通过调用另一个外部调用来执行较小的业务逻辑。**

**![](img/da79e1e7e53a861b351e53c8d49781a7.png)**

**这使得我们的例子很小，我们必须采取的基本步骤相当简单:**

*   **如果还没有跟踪，我们将初始化一个新的(根跨度)**
*   **我们可以在处理该请求或操作的每个系统上为每个流程边界(例如外部调用)打开一个新的跨度**
*   **我们将在它们完成后关闭我们打开的跨度**
*   **我们将跨度详细信息提交给我们的跟踪收集器系统**

**我们可以在单个系统中打开任意多的跨度。我们只需要确保正确地嵌套它们并分别关闭它们。因此，手动实现需要跟踪跨度堆栈。**

**![](img/c161f63e6c1b137b5e4960ed3a7d6b6d.png)**

## **设置我们的追踪**

**如果我们想用手动的方式来做这件事，我们首先需要什么？我们需要我们的系统已经打开并因此需要关闭的所有跨度的堆栈。**

**如果没有跟踪状态头传入我们的系统，我们可以自己生成一个新的跟踪状态头。如果已经有一个，我们将通过打开新的跨度来扩展跟踪。**

**现在我们已经有了根，我们可以继续以我们自己的粒度打开操作或流程的范围。**

## **催生新的跨越**

**为了在单个系统中跟踪我们的跨度，我们需要一个堆栈来保存我们已经打开的跨度，如前所述。**

**我更喜欢使用有两个专用对象的请求上下文**

*   **按照跨度打开时间的顺序跟踪跨度名称的列表**
*   **一个对象，保存 span 的必要细节:打开时的时间戳和 span 的标识符**

**![](img/cc135363837834e02b1b1bc601d6ad44.png)**

**我们的根仅用于跟踪我们的跟踪标识符。在此基础上，我们将跟踪所有已打开的范围，并在操作或流程完成时删除每个范围。**

## **关闭跨度并提交跟踪信息**

**当我们需要关闭操作或流程结束的跨度时，我们可以从栈顶弹出该跨度。我们还可以根据我们在 span 中保存的信息或堆栈中剩余的信息来计算所需的信息。**

*   **我们的父代的跨度标识符——这就是现在位于堆栈顶部的跨度**
*   **操作的持续时间——现在和我们在 span 中保存的时间戳之间的差值**
*   **跟踪标识符——保存在我们的根区域，它总是在堆栈的底部。**

**在这个例子中，我们将跨度信息提交给 NewRelic(使用他们自己的格式)。根据您使用的追踪工具，这将有所不同。**

**仅此而已。你现在只需要在所有地方调用`openNewSpan`和`closeSpan`方法。将它放入某个注释中是有意义的，这样您只需要注释您想要跟踪的方法或过程，并且自动调用打开和关闭操作。**

# **关键要点**

**构建一个分布式系统是一项复杂的任务，但通过 AWS、Azure 或 GCP 等云提供商以及利用 CloudFormation 的无服务器框架等高级基础设施作为代码工具，可以非常快地完成。请记住，您需要分布式跟踪来分析您的系统和整个生态系统的运行情况，并系统地调试问题。**

**本文向您介绍了跟踪上下文标准，以及如何使用它来跟踪多个系统和服务上的请求。**

**感谢您的阅读。**