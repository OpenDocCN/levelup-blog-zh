# 模仿静态方法的不同方式

> 原文：<https://levelup.gitconnected.com/different-ways-to-mock-static-method-bf2eb760515a>

## 莫奇托让嘲笑变得毫不费力

![](img/69c10d8bc6d26dfe772345b7c309db6e.png)

约尔根·哈兰在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的照片

有时在产品代码中使用静态方法是不可避免的。

像`UUID.randomUUID().toString()`和`LocalDateTime.now()`这样的静态方法经常在我们的生产代码中使用，有时编写覆盖它的测试用例仍然很重要。

举个例子，我们有一个`itemService`类，它有一个`createItem(id, name):item`方法，需要与一个静态方法`LocalDateTime.now()`交互来创建一个带有`createdDate`的项目。

下面是一些测试包含静态方法的产品代码的通用技术。

# 模仿静态方法的传统方式

传统的方法是模拟方法的最基本的技术，并且应用起来也很简单。然而，它涉及到重构产品代码，以便静态方法是可重写的，并使测试总是按预期进行。它不太理想，因为我们必须接触产品代码，但变化是微不足道的。此外，我们必须在测试中创建一个子类来覆盖该方法。

# 模仿静态方法的模仿方式

前面的例子展示了模拟静态方法的传统方式。我们可以通过使用 Mockito 进行嘲讽来进一步改进。使用 Mockito 中的 Spy，我们可以消除之前在测试中引入的额外代码`ItemServiceForTest`。然而，我们仍然需要重构产品代码来覆盖静态方法。

# Mockito 静态模拟

由于我们在前面的例子中已经使用了 Mockito，我们可以进一步扩展以消除重构产品代码的需要。通过在 Mockito 中使用静态 mock，我们可以用更少的努力和更干净的测试代码获得相同的结果。

# 结论

从传统到模拟静态方法的三种不同方法实现了相同的结果，从而能够用静态方法进行测试。

不那么“神奇”的传统方法根本不使用依赖，但是它需要更改产品代码并添加更多的类来模拟静态方法。

另一方面，Mockito 中的 static mock 只需要测试用例中的几行代码就可以轻松地进行模仿。有了 lambda 函数，它使得测试用例看起来更干净。这是迄今为止我最喜欢的模仿静态方法的方式，因为它不需要改变产品代码来实现静态方法模仿。