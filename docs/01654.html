<html>
<head>
<title>TypeScript Advanced Types — Conditional Types</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript高级类型—条件类型</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/typescript-advanced-types-conditional-types-95fe6e837614?source=collection_archive---------3-----------------------#2020-01-20">https://levelup.gitconnected.com/typescript-advanced-types-conditional-types-95fe6e837614?source=collection_archive---------3-----------------------#2020-01-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/373d916c1f0345b61c75edd19742d1b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jmJBhuf0tw7TEPYI"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@wwwynand?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Wynand van Poortvliet </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="40f9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">TypeScript具有许多高级类型功能，这使得编写动态类型代码变得容易。它还有助于采用现有的JavaScript代码，因为它允许我们在使用TypeScript的类型检查功能的同时保留JavaScript的动态功能。TypeScript中有多种高级类型，如交集类型、联合类型、类型保护、可空类型和类型别名等等。</p><p id="af2d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将研究条件类型。</p><h1 id="5d2e" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">条件类型</h1><p id="bbb7" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">从TypeScript 2.8开始，我们可以用条件测试来定义类型。这使我们可以向数据添加类型，根据我们设置的条件，数据可以有不同的类型。在TypeScript中定义条件类型的一般表达式如下:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="ba6e" class="mq lf it mm b gy mr ms l mt mu">T extends U ? X : Y</span></pre><p id="327d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mv mw mx mm b">T extends U</code>描述了通用类型<code class="fe mv mw mx mm b">T</code>和<code class="fe mv mw mx mm b">U</code>之间的关系。如果<code class="fe mv mw mx mm b">T extends U</code>是<code class="fe mv mw mx mm b">true</code>，那么<code class="fe mv mw mx mm b">X</code>类型是预期的。否则，预计为<code class="fe mv mw mx mm b">Y</code>型。例如，我们可以在下面的代码中使用它:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="2644" class="mq lf it mm b gy mr ms l mt mu">interface Animal {  <br/>  kind: string;<br/>}</span><span id="c154" class="mq lf it mm b gy my ms l mt mu">interface Cat extends Animal {<br/>  name: string;<br/>}</span><span id="bce0" class="mq lf it mm b gy my ms l mt mu">interface Dog {<br/>  name: string;<br/>}</span><span id="0e0f" class="mq lf it mm b gy my ms l mt mu">type CatAnimal = Cat extends Animal ? Cat : Dog;<br/>let catAnimal: CatAnimal = &lt;Cat&gt;{<br/>  name: 'Joe',<br/>  kind: 'cat'<br/>}</span></pre><p id="df90" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们创建了<code class="fe mv mw mx mm b">CatAnimal</code>类型别名，如果<code class="fe mv mw mx mm b">Cat extends Animal</code>被设置为<code class="fe mv mw mx mm b">Cat</code>类型。否则设置为<code class="fe mv mw mx mm b">Dog</code>。由于<code class="fe mv mw mx mm b">Cat</code>确实扩展了<code class="fe mv mw mx mm b">Animal</code>，因此<code class="fe mv mw mx mm b">CatAnimal</code>类型别名被设置为<code class="fe mv mw mx mm b">Cat</code>类型。</p><p id="4920" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这意味着在上面的例子中，如果我们像下面的代码那样将<code class="fe mv mw mx mm b">&lt;Cat&gt;</code>改为<code class="fe mv mw mx mm b">&lt;Dog&gt;</code>:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="9618" class="mq lf it mm b gy mr ms l mt mu">interface Animal {  <br/>  kind: string;<br/>}</span><span id="801d" class="mq lf it mm b gy my ms l mt mu">interface Cat extends Animal {<br/>  name: string;<br/>}</span><span id="83f6" class="mq lf it mm b gy my ms l mt mu">interface Dog {<br/>  name: string;<br/>}</span><span id="9111" class="mq lf it mm b gy my ms l mt mu">type CatAnimal = Cat extends Animal ? Cat : Dog;<br/>let catAnimal: CatAnimal = &lt;Dog&gt;{<br/>  name: 'Joe',<br/>  kind: 'cat'<br/>}</span></pre><p id="5d89" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将得到以下错误消息:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="6a2b" class="mq lf it mm b gy mr ms l mt mu">Property 'kind' is missing in type 'Dog' but required in type 'Cat'.(2741)</span></pre><p id="f936" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这确保我们根据类型中表达的条件为<code class="fe mv mw mx mm b">catAnimal</code>选择正确的类型。如果我们想让<code class="fe mv mw mx mm b">Dog</code>成为<code class="fe mv mw mx mm b">catAnimal</code>的类型，那么我们可以改为编写以下代码:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="a1c5" class="mq lf it mm b gy mr ms l mt mu">interface Animal {  <br/>  kind: string;<br/>}</span><span id="ccd6" class="mq lf it mm b gy my ms l mt mu">interface Cat  {<br/>  name: string;<br/>}</span><span id="d4e5" class="mq lf it mm b gy my ms l mt mu">interface Dog extends Animal {<br/>  name: string;<br/>}</span><span id="82da" class="mq lf it mm b gy my ms l mt mu">type CatAnimal = Cat extends Animal ? Cat : Dog;<br/>let catAnimal: CatAnimal = &lt;Dog&gt;{<br/>  name: 'Joe'<br/>}</span></pre><p id="ca1a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还可以使用嵌套条件来从多个条件中确定实际类型。例如，我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="1427" class="mq lf it mm b gy mr ms l mt mu">interface Animal {  <br/>  kind: string;<br/>}</span><span id="f1f1" class="mq lf it mm b gy my ms l mt mu">interface Bird  {<br/>  name: string;<br/>}</span><span id="bdb5" class="mq lf it mm b gy my ms l mt mu">interface Cat  {<br/>  name: string;<br/>}</span><span id="5ae3" class="mq lf it mm b gy my ms l mt mu">interface Dog extends Animal {<br/>  name: string;<br/>}</span><span id="8535" class="mq lf it mm b gy my ms l mt mu">type AnimalTypeName&lt;T&gt; =<br/>  T extends Animal ? Cat :    <br/>  T extends Animal ? Dog :    <br/>  T extends Animal ? Bird :<br/>  Animal</span><span id="16e9" class="mq lf it mm b gy my ms l mt mu">type t0 = AnimalTypeName&lt;Cat&gt;;  <br/>type t1 = AnimalTypeName&lt;Dog&gt;;<br/>type t2 = AnimalTypeName&lt;Animal&gt;;<br/>type t3 = AnimalTypeName&lt;Bird&gt;;</span></pre><p id="91e4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们得到类型别名<code class="fe mv mw mx mm b">t0</code>、<code class="fe mv mw mx mm b">t1</code>、<code class="fe mv mw mx mm b">t2</code>和<code class="fe mv mw mx mm b">t3</code>的如下类型:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="62e1" class="mq lf it mm b gy mr ms l mt mu">type t0 = Animal<br/>type t1 = Cat<br/>type t2 = Cat<br/>type t3: Animal</span></pre><p id="2853" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">确切的不一定要马上选择，我们也可以有这样的东西:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="a17f" class="mq lf it mm b gy mr ms l mt mu">interface Foo {</span><span id="cb54" class="mq lf it mm b gy my ms l mt mu">}</span><span id="9604" class="mq lf it mm b gy my ms l mt mu">interface Bar extends Foo {<br/>  <br/>}</span><span id="cfc4" class="mq lf it mm b gy my ms l mt mu">function bar(x) {<br/>  return x;<br/>}</span><span id="4376" class="mq lf it mm b gy my ms l mt mu">function foo&lt;T&gt;(x: T) {<br/>  let y: T extends Foo ? string : number = bar(x);<br/>  let z: string | number = y;<br/>}</span><span id="5174" class="mq lf it mm b gy my ms l mt mu">foo&lt;Bar&gt;(1);<br/>foo&lt;Bar&gt;('1');<br/>foo&lt;Bar&gt;(false);</span></pre><p id="7840" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我们所看到的，我们可以向<code class="fe mv mw mx mm b">foo</code>传递任何东西，即使我们已经设置了条件类型。这是因为类型条件中的实际类型还没有被选择。，所以TypeScript没有对我们可以给<code class="fe mv mw mx mm b">foo</code>函数中的变量赋什么做任何假设。</p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/5b873aea6b5efa8f367d78ebca69acd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CwusZY8MHeV1fr-w"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">马库斯·斯皮斯克在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="3f56" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">分配条件类型</h1><p id="ca42" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">条件类型是分布式的。如果我们有多个条件类型可以扩展一个类型，如下面的代码所示:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="cf4a" class="mq lf it mm b gy mr ms l mt mu">interface A {}<br/>interface B {}<br/>interface C {}<br/>interface D {}<br/>interface X {}<br/>interface Y {}</span><span id="f58a" class="mq lf it mm b gy my ms l mt mu">type TypeName = (A | B | C) extends D ? X : Y;</span></pre><p id="df75" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么最后一行相当于:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="b567" class="mq lf it mm b gy mr ms l mt mu">(A extends D ? X : Y) | (B extends D ? X : Y) | (C extends D ? X : Y)</span></pre><p id="a8da" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以用它来过滤出各种条件的类型。例如，我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="8054" class="mq lf it mm b gy mr ms l mt mu">type Diff&lt;T, U&gt; = T extends U ? never : T;</span></pre><p id="7801" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从<code class="fe mv mw mx mm b">T</code>中移除可分配给<code class="fe mv mw mx mm b">U</code>的类型。如果是<code class="fe mv mw mx mm b">T extends U</code>，那么<code class="fe mv mw mx mm b">Diff&lt;T, U&gt;</code>的类型就是<code class="fe mv mw mx mm b">never</code>，这意味着我们可以给它赋值任何东西，否则它就取类型<code class="fe mv mw mx mm b">T</code>。同样，我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="a54a" class="mq lf it mm b gy mr ms l mt mu">type Filter&lt;T, U&gt; = T extends U ? T : never;</span></pre><p id="f315" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从<code class="fe mv mw mx mm b">T</code>中移除不可分配给<code class="fe mv mw mx mm b">U</code>的类型。在这种情况下，如果<code class="fe mv mw mx mm b">T extends U</code>，那么过滤器类型与<code class="fe mv mw mx mm b">T</code>类型相同，否则，它采用<code class="fe mv mw mx mm b">never</code>类型。例如，如果我们有:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="6589" class="mq lf it mm b gy mr ms l mt mu">type Diff&lt;T, U&gt; = T extends U ? never : T;<br/>type TypeName = Diff&lt;string| number | boolean, boolean&gt;;</span></pre><p id="9032" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么<code class="fe mv mw mx mm b">TypeName</code>具有类型<code class="fe mv mw mx mm b">string | number</code>。这是因为<code class="fe mv mw mx mm b">Diff&lt;string| number | boolean, boolean&gt;</code>与:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="d91e" class="mq lf it mm b gy mr ms l mt mu">(string extends boolean ? never : string) | (number extends boolean ? never: number) | (boolean extends boolean ? never: boolean)</span></pre><p id="398e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一方面，如果我们写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="6231" class="mq lf it mm b gy mr ms l mt mu">type Filter&lt;T, U&gt; = T extends U ? T : never;<br/>type TypeName = Filter&lt;string| number | boolean, boolean&gt;;</span></pre><p id="4897" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">则<code class="fe mv mw mx mm b">TypeName</code>具有<code class="fe mv mw mx mm b">boolean</code>类型。这是因为<code class="fe mv mw mx mm b">Diff&lt;string| number | boolean, boolean&gt;</code>与:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="fd2c" class="mq lf it mm b gy mr ms l mt mu">(string extends boolean ? string: never) | (number extends boolean ? number: never) | (boolean extends boolean ? boolean: never)</span></pre><h1 id="1848" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">预定义的条件类型</h1><p id="4b40" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">TypeScript 2.8具有以下预定义的条件类型，它们是:</p><ul class=""><li id="e833" class="na nb it ki b kj kk kn ko kr nc kv nd kz ne ld nf ng nh ni bi translated"><code class="fe mv mw mx mm b">Exclude&lt;T, U&gt;</code>–从<code class="fe mv mw mx mm b">T</code>中排除可分配给<code class="fe mv mw mx mm b">U</code>的类型。</li><li id="9cb1" class="na nb it ki b kj nj kn nk kr nl kv nm kz nn ld nf ng nh ni bi translated"><code class="fe mv mw mx mm b">Extract&lt;T, U&gt;</code>–从<code class="fe mv mw mx mm b">T</code>中提取可分配给<code class="fe mv mw mx mm b">U</code>的类型。</li><li id="cb2a" class="na nb it ki b kj nj kn nk kr nl kv nm kz nn ld nf ng nh ni bi translated"><code class="fe mv mw mx mm b">NonNullable&lt;T&gt;</code>–从<code class="fe mv mw mx mm b">T</code>中排除<code class="fe mv mw mx mm b">null</code>和<code class="fe mv mw mx mm b">undefined</code>。</li><li id="02f3" class="na nb it ki b kj nj kn nk kr nl kv nm kz nn ld nf ng nh ni bi translated"><code class="fe mv mw mx mm b">ReturnType&lt;T&gt;</code>–获取函数类型的返回类型。</li><li id="54d6" class="na nb it ki b kj nj kn nk kr nl kv nm kz nn ld nf ng nh ni bi translated"><code class="fe mv mw mx mm b">InstanceType&lt;T&gt;</code>–获取构造函数类型的实例类型。</li></ul><p id="a99b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从TypeScript 2.8开始，我们可以用条件测试来定义类型。在TypeScript中定义条件类型的一般表达式是<code class="fe mv mw mx mm b">T extends U ? X : Y</code>。它们是分布式的，所以<code class="fe mv mw mx mm b">(A | B | C) extends D ? X : Y;</code>和<code class="fe mv mw mx mm b">(A extends D ? X : Y) | (B extends D ? X : Y) | (C extends D ? X : Y)</code>是一样的。</p></div></div>    
</body>
</html>