# 使用 Nginx 的负缓存

> 原文：<https://levelup.gitconnected.com/negative-cache-with-nginx-e3af193718fe>

而不使用单独的子系统

![](img/0ade65a9cb459f4cb87d2c51e84f64dc.png)

[亚历山大·波波夫](https://unsplash.com/@5tep5?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍照

非人类的 bot 客户端可能会严重滥用 REST API 调用，这些调用用于在允许操作完成之前检查某些东西的状态。通常，对于 REST API，响应状态将通知调用服务动作是否可以完成或已经成功完成。2xx 范围内的肯定响应代码通常与让动作继续相关联。否定响应代码通常在 4xx 范围内，但也可能在 5xx 范围内，表示阻止操作或操作失败。系统可能会因端点上的请求而降级或在高负载下经历中断，这些请求指示某个操作无法完成或不成功，并且该状态与事务无关，而是与系统的某个其他方面有关。

**示例**
这种 API 调用的一个很好的例子是库存可用性检查，以确定将产品添加到购物车的操作是否可以完成。如果一个电子商务网站有一种低库存、高需求的产品，点击将产品添加到购物车 API 的 bot 流量的增加将导致商业系统的购物车服务和库存系统的沉重负担。当高需求产品尚未上市或已售完时，这种情况就会发生，这是这种产品的典型情况。在疯狂销售后进入售罄状态的产品将继续在某些端点上以高比率抛出错误，即使他们没有任何产品可供销售。**运营团队可能** **对这种高流量影响束手无策**，因为他们知道在产品销售一空之前什么也做不了，因为他们看着自己的系统遭受损失。

在有可用库存之前，该产品的状态不会改变，因此，**缓存这些调用的否定响应**或者使用短生存时间(TTL)触发该调用的请求资源可能是一个好主意，以减轻后端系统上不必要的负载。在负面响应上设置缓存可以让负担过重的上游恢复。毫不奇怪，这被称为**负缓存**。

> 注意:本文将重点关注使用 nginx-plus 处理负缓存，但是开源 nginx 或 openresty 应该仍然能够以相同的方式工作。此外，如果 nginx 前面有 CDN，如 Akamai 或 Fastly，如果对实现有意义并且可能做到，则应该将此逻辑移到该层。在某些情况下，在边缘和原点有一个负缓存层可能是有意义的，只要记住 TTLs 可能会堆叠。

# 意外错误

> 场景:营销部门推出了一个新产品，当产品页面被激活时，唤醒了经销商机器人，即使该产品在推出前没有库存。繁忙的交通导致站点出现重大错误，从而触发事件响应。支持技术人员团结起来解决问题。

库存系统通常会提供可用性检查 URI，当请求将产品添加到用户的包中时会调用该功能。当经销商机器人在网站上活跃时，通常它会完成一系列请求:

1.  创建会话
2.  通过向袋子中添加任何产品来创建购物车
3.  重复将所需产品添加到袋子中，直到添加到袋子请求成功
4.  从袋子中取出购物车创建产品(步骤 2)
5.  添加运输/账单信息
6.  添加付款
7.  提交订单

许多机器人代理将在各种云提供商之间被激活，以便在想要的产品上线时尽可能多地获取产品。添加到购物车活动将增加系统的负荷，即使还没有产品可用。添加到购物车可用性检查是放置负缓存以减少开销的好地方。

> 注意:为时间敏感的端点添加一个 short 可以带来巨大的好处，但是必须对其进行监控和调整，以满足系统的需求。

# PII / PCI-DSS 和可缓存性

在启用任何缓存之前，应该针对 PII 或 PCI-DSS 数据评估正在缓存的响应。如果响应有效负载具有任何可能允许客户端接收导致来自另一个客户端的数据被公开的信息的头或主体数据，则必须在缓存该有效负载之前对其进行修改，以排除那些头或主体数据。

理想情况下，可缓存资源不应该有任何与客户端会话相关的响应数据，也不应该有任何会干扰缓存响应的数据。

> 注意:如果响应中有 Set-Cookie 头或 Vary 头，默认情况下不会被缓存。为系统缓存响应可能还有其他考虑，但这些是最重要的。有关缓存这些类型的响应的详细信息，请参见 proxy_hide_header 和 proxy_ignore_headers 指令。

# 负缓存

在本例中，对于缺货响应，产品可用性请求将获得一个短暂的负缓存。

> 注意:根据系统架构，可用性检查可能是将产品添加到行李功能的一部分，并且可能涉及更多内容。根据架构的不同，将产品添加到包资源也是放置缓存的好地方。

## 可用性 URI

让我们定义一个没有库存的基本可用性请求和响应:

请求:
获取/API/产品/检查可用性/{产品编号}

回复:
{ "数量 _ 可用"，数量}

响应状态代码为:
* 200 如果产品可用，10 个以上
* 201 如果产品缺货，小于 10 个
* 400 如果产品编号无效
* 500。

## 缓存键

为了缓存项目的可用性调用，我们需要创建一个对项目有意义的缓存键。在这种情况下，我们将使用 nginx 映射将 URI 中的产品编号分离到一个变量中:

由于 nginx 映射只有在使用时才会被评估，所以这是一种为缓存键捕获产品号的有效方法。它只在我们需要的地方被评估:在处理可用性呼叫的位置块中。

## 缓存配置

要为此调用配置缓存，需要在 http{}块中配置 proxy_cache_path 指令。应该为此配置一些 proxy_cache_*设置，这些设置将在 location 块中设置。下面是负缓存的代理模块配置:

*   如果 5 分钟的非活动 TTL 未过期，并且后端出现问题，并且响应状态代码为 500、502、503 或 504，则此配置将从缓存提供服务。
*   Nginx 将在出现错误、超时或请求更新缓存时从缓存中提供服务。
*   如果缓存在代理到后端服务器进行响应之前正在更新，对同一缓存键的重复请求将等待 5s。

这些指令记录在 nginx 代理模块文档中[这里](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_cache_path):
[http://nginx.org/en/docs/http/ngx_http_proxy_module.html](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_cache_path)

在产品可用性位置{}块中，以下指令将完成不同缓存的配置:

*   这将在活动缓存中缓存状态为 400 的响应 1 分钟，非活动缓存 TTL 为 5 分钟。
*   如果请求方法是 POST，则需要取消对 proxy_cache_methods 指令的注释。

# 结论

请记住从缓存的响应中删除任何可能导致问题的头，如 Set-Cookie、Vary 或任何可能暴露 PII / PCI-DSS 数据的头。

将可能以“失败”状态为目标的请求 URIs 上的负缓存高速放置，以减少后端影响。

感谢阅读。