<html>
<head>
<title>Comparing suitability of RabbitMQ over Redis queue</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">RabbitMQ对Redis队列的适用性比较</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/comparing-suitability-of-rabbitmq-over-redis-queue-82c538e21b7?source=collection_archive---------5-----------------------#2022-08-11">https://levelup.gitconnected.com/comparing-suitability-of-rabbitmq-over-redis-queue-82c538e21b7?source=collection_archive---------5-----------------------#2022-08-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div class="gh gi ir"><img src="../Images/6d1b41334f1e9ffac8b7278a91a498cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*rFhzy10QkwJay9BrQL60cg.jpeg"/></div><figcaption class="iy iz gj gh gi ja jb bd b be z dk translated">RabbitMQ vs Redis</figcaption></figure><div class=""/><h1 id="e2dd" class="kb kc je bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">议程</h1><p id="52d7" class="pw-post-body-paragraph kz la je lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">在构建工作队列时，RabbitMQ和Redis是作为消息代理的可用选择。</p><p id="712a" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">Redis没有内置的队列数据结构。然而，它内置了对列表的支持，Redis列表允许在列表的两端插入和删除。因此，这个列表可以用作FIFO队列。</p><p id="f4de" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">Resque 以及<a class="ae mc" href="https://github.com/rq/rq" rel="noopener ugc nofollow" target="_blank"> python-rq </a>使用Redis作为队列。</p><p id="6210" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">在本文中，我们试图理解RabbitMQ比Redis队列更好的情况。</p><p id="a70e" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">我们期望以下先决条件:<br/> - RabbitMQ安装<br/> - Redis安装<br/> - Python安装</p><p id="be0b" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">使用Docker容器运行RabbitMQ和Redis非常简单，所以如果您没有RabbitMQ或Redis安装，可以使用Docker方法。</p><p id="9f79" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">我们将讨论一个实际的例子，并使用Python来构建它。因此，熟悉Python会有所帮助。</p><p id="507e" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">然而，我们会尽量少用Python，即使你不熟悉，你也应该能够理解。</p><h1 id="c970" class="kb kc je bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">RabbitMQ可以更可靠</h1><p id="f062" class="pw-post-body-paragraph kz la je lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">RabbitMQ内置了对消息确认的支持。因此，只有当消费者/工作者向RabbitMQ确认它已经处理了消息时，才从队列中删除消息。</p><p id="1067" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">如果处理消息的消费者/工作者崩溃，消息将留在队列中，并被分派给下一个消费者。这确保了没有消息未被处理或丢失。从而确保高可靠性。</p><p id="4596" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">如果使用Redis列表，工人通常会从列表中弹出。Redis没有确认机制。因此，消费者/工作者没有办法向Redis确认消息的处理状态。<br/>如果工作者在处理消息时崩溃，Redis没有办法知道这个消息没有被处理。因此，它不能传递给下一个工人。</p><p id="19cc" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">我们来看一个例子。</p><h2 id="7d8b" class="md kc je bd kd me mf dn kh mg mh dp kl lk mi mj kp lo mk ml kt ls mm mn kx mo bi translated">Redis方法</h2><p id="feb4" class="pw-post-body-paragraph kz la je lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">我们将编写一个发布队列的发布者和一个从队列中消费的消费者。让我们首先采用Redis方法。</p><p id="fef0" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">让我们创建一个名为<em class="mp"> redis_publisher.py </em>的文件。它应该如下所示:</p><figure class="mq mr ms mt gt iv"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="a792" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">这里，我们创建一个名为<em class="mp"> hello </em>的Redis列表，并在这个列表中推送一条消息。我们从清单的左侧推进，将从右侧消费。因此，这个列表的行为就像一个队列。</p><p id="1871" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">你需要确保软件包<em class="mp"> redis </em>已经安装。此外，确保在本地主机的端口6379上运行一个<em class="mp"> redis-server </em>。否则，相应地修改代码以连接到正确的主机和端口。</p><p id="2648" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">尝试调用此脚本，以确保发布者端的一切工作正常。</p><pre class="mq mr ms mt gt mw mx my mz aw na bi"><span id="0007" class="md kc je mx b gy nb nc l nd ne">$ python redis_publisher.py hello redis</span></pre><p id="f5e6" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">您应该会看到以下输出:</p><pre class="mq mr ms mt gt mw mx my mz aw na bi"><span id="e6fc" class="md kc je mx b gy nb nc l nd ne">Message sent: hello redis</span></pre><p id="347f" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">让我们创建一个名为<em class="mp"> redis_consumer.py </em>的文件。它应该如下所示:</p><figure class="mq mr ms mt gt iv"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="caf6" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">我们不断地从名单的右边冒出来。为了模拟一个耗时的任务，我们做了一个<em class="mp"> time.sleep() </em>和消息长度一样多的秒数。</p><p id="7066" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">让我们从消费者开始。在新的终端上启动它。</p><pre class="mq mr ms mt gt mw mx my mz aw na bi"><span id="8a5b" class="md kc je mx b gy nb nc l nd ne">$ python redis_consumer.py</span></pre><p id="3c21" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">您应该会在用户终端上看到以下内容。</p><pre class="mq mr ms mt gt mw mx my mz aw na bi"><span id="1fd4" class="md kc je mx b gy nb nc l nd ne">Received: hello redis<br/>Processed: hello redis</span></pre><p id="fdf0" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">此外，在“已接收:你好redis”和“已处理:你好redis”之间应该有11秒钟的停顿。这是因为time.sleep()代码。</p><p id="6a28" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">从上一个终端，再次触发生产者。</p><pre class="mq mr ms mt gt mw mx my mz aw na bi"><span id="af64" class="md kc je mx b gy nb nc l nd ne">$ python redis_publisher.py redis vs rabbitmq</span></pre><p id="d98b" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">同样的信息应该打印在用户终端上。</p><pre class="mq mr ms mt gt mw mx my mz aw na bi"><span id="a537" class="md kc je mx b gy nb nc l nd ne">Received: redis vs rabbitmq<br/>Processed: redis vs rabbitmq</span></pre><p id="e7da" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">我们来发布一条长消息。这是为了确保消费者需要很长时间来处理此消息。</p><pre class="mq mr ms mt gt mw mx my mz aw na bi"><span id="06ea" class="md kc je mx b gy nb nc l nd ne">$ python redis_publisher.py does redis have message acknowledgement</span></pre><p id="21d4" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">消费终端应该已经打印出来了。</p><pre class="mq mr ms mt gt mw mx my mz aw na bi"><span id="dbd5" class="md kc je mx b gy nb nc l nd ne">Received: does redis have message acknowledgement</span></pre><p id="a6ba" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">让我们通过按Ctrl+c来中断消费者。这是为了模拟消费者崩溃。</p><p id="ddc3" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">此时，我们可以假设消费者在处理消息时崩溃了。在一个好的面向消息的解决方案中，我们期望消费者有一种方式来确认队列的消息处理的完成。并且只有在接收到确认之后，队列才应该驱逐消息。</p><p id="391e" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">然而，我们在使用Redis时没有这样的选项。</p><p id="ec20" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">让我们再次启动消费者。</p><pre class="mq mr ms mt gt mw mx my mz aw na bi"><span id="5f1f" class="md kc je mx b gy nb nc l nd ne">$ python redis_consumer.py</span></pre><p id="1e08" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">从发布者终端发布另一条消息。</p><pre class="mq mr ms mt gt mw mx my mz aw na bi"><span id="8c15" class="md kc je mx b gy nb nc l nd ne">$ python redis_publisher.py next message</span></pre><p id="8448" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">您会看到在用户终端上打印了以下内容。</p><pre class="mq mr ms mt gt mw mx my mz aw na bi"><span id="3d32" class="md kc je mx b gy nb nc l nd ne">Received: next message<br/>Processed: next message</span></pre><p id="dacb" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">因此，消费者崩溃时正在处理的早期消息丢失了。</p><h2 id="91f8" class="md kc je bd kd me mf dn kh mg mh dp kl lk mi mj kp lo mk ml kt ls mm mn kx mo bi translated">RabbitMQ方法</h2><p id="5668" class="pw-post-body-paragraph kz la je lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">继续之前，先熟悉一下<a class="ae mc" href="https://www.rabbitmq.com/tutorials/tutorial-one-python.html" rel="noopener ugc nofollow" target="_blank">https://www.rabbitmq.com/tutorials/tutorial-one-python.html</a>。这将确保您对RabbitMQ连接、通道、交换和队列有一个基本的了解。</p><p id="4ac0" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">让我们为rabbitmq创建发布者代码。让我们称这个模块为<em class="mp">rabbit MQ _ publisher . py .<br/></em>它看起来应该是这样的:</p><figure class="mq mr ms mt gt iv"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="1895" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">这里，我们创建了一个名为“hello”的队列，并在这个队列中推送一条消息。</p><p id="8a60" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">您需要确保软件包“pika”已安装。此外，确保rabbitmq正在本地主机上运行。否则，相应地修改代码以连接到正确的主机和端口。</p><p id="cd84" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">尝试调用此脚本，以确保发布者端的一切工作正常。</p><pre class="mq mr ms mt gt mw mx my mz aw na bi"><span id="81db" class="md kc je mx b gy nb nc l nd ne">$ python rabbitmq_publisher.py hello rabbit</span></pre><p id="d1a1" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">您应该会看到以下输出:</p><pre class="mq mr ms mt gt mw mx my mz aw na bi"><span id="5e1d" class="md kc je mx b gy nb nc l nd ne">Message sent: hello rabbit</span></pre><p id="f05b" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">让我们创建一个名为<em class="mp"> rabbitmq_consumer.py </em>的文件。它应该如下所示:</p><figure class="mq mr ms mt gt iv"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="b0ac" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">我们通过标记<code class="fe nf ng nh mx b">auto_ack=False</code>禁用了通道上的自动确认。</p><p id="9686" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">此外，我们在回调方法中使用了<code class="fe nf ng nh mx b">basic_ack</code>,这将确保一旦消费者处理了消息，就发送手动确认。</p><p id="94a1" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">让我们从消费者开始。在新的终端上启动它。</p><pre class="mq mr ms mt gt mw mx my mz aw na bi"><span id="ad48" class="md kc je mx b gy nb nc l nd ne">$ python rabbitmq_consumer.py</span></pre><p id="369e" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">您应该会在用户终端上看到以下内容。</p><pre class="mq mr ms mt gt mw mx my mz aw na bi"><span id="d4ac" class="md kc je mx b gy nb nc l nd ne">Received: hello rabbit<br/>Processed: hello rabbit</span></pre><p id="38aa" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">从上一个终端，再次触发生产者。</p><pre class="mq mr ms mt gt mw mx my mz aw na bi"><span id="3f7b" class="md kc je mx b gy nb nc l nd ne">$ python rabbitmq_publisher.py redis vs rabbitmq</span></pre><p id="eebc" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">同样的信息应该打印在用户终端上。</p><pre class="mq mr ms mt gt mw mx my mz aw na bi"><span id="cdd7" class="md kc je mx b gy nb nc l nd ne">Received: redis vs rabbitmq<br/>Processed: redis vs rabbitmq</span></pre><p id="88e3" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">我们来发布一条长消息。这是为了确保消费者需要很长时间来处理此消息。</p><pre class="mq mr ms mt gt mw mx my mz aw na bi"><span id="40f8" class="md kc je mx b gy nb nc l nd ne">$ python rabbitmq_publisher.py does rabbitmq have message acknowledgement</span></pre><p id="a6a1" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">消费终端应该已经打印出来了。</p><pre class="mq mr ms mt gt mw mx my mz aw na bi"><span id="066f" class="md kc je mx b gy nb nc l nd ne">Received: does rabbitmq have message acknowledgement</span></pre><p id="74e8" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">让我们通过按Ctrl+c来中断消费者。这是为了模拟消费者崩溃。</p><p id="a682" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">此时，我们可以假设消费者在处理消息时崩溃了。</p><p id="9ae0" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">让我们开始另一个消费者。</p><pre class="mq mr ms mt gt mw mx my mz aw na bi"><span id="754c" class="md kc je mx b gy nb nc l nd ne">$ python rabbitmq_consumer.py</span></pre><p id="34a3" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">您会注意到，这个消费者收到的消息与之前崩溃的消费者未处理的消息相同。输出将证实这一点。</p><pre class="mq mr ms mt gt mw mx my mz aw na bi"><span id="4b2b" class="md kc je mx b gy nb nc l nd ne">Received: does rabbitmq have message acknowledgement</span></pre><p id="1660" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">在42秒的time.sleep()之后，您将看到处理后的消息。</p><pre class="mq mr ms mt gt mw mx my mz aw na bi"><span id="612f" class="md kc je mx b gy nb nc l nd ne">Processed: b’does rabbitmq have message acknowledgement’</span></pre><p id="4d6a" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">然后<code class="fe nf ng nh mx b">ch.basic_ack</code>将从消费者端被触发，RabbitMQ将意识到消费者已经完成了消息的处理。然后只有这条消息会被从队列中清除。</p><p id="c388" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">这表明RabbitMQ在这种可靠性至关重要且未处理的消息不应丢失的场景中可能是更可靠的解决方案。</p><h1 id="dfd9" class="kb kc je bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">RabbitMQ允许更好的路由</h1><p id="5bbf" class="pw-post-body-paragraph kz la je lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">由于交换的概念，RabbitMQ具有更好的路由能力。消息从不直接发送到队列，而是发送到交换。并且基于交换类型和其他参数交换路由到一个或多个队列。</p><p id="da6c" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">假设我们正在开发一个web应用程序。这个应用程序允许用户注册。<br/>目前用户注册时需要发送一封欢迎邮件。由于发送电子邮件是一个网络呼叫，可能会很耗时，因此它是由一个工人执行的。因此，应用程序将用户id添加到队列中，工作人员订阅该队列，并在消息添加到队列中时采取适当的操作。</p><p id="1ac6" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">假设明天需求发生变化，除了欢迎电子邮件之外，还需要在注册时向用户发送一条sms消息。因此，我们将增加另一个工人来处理它。但是我们也将不得不引入一个新的队列，生产者代码将不得不在另一个队列上添加相同的消息。</p><p id="2aec" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">本质上，因为我们希望在一个事件上执行更多不同的工作单元，所以我们将创建相应的workers。但是我们还需要创建对应于每个工人的相关队列。</p><p id="14bc" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">让我们看看它的实际效果。创建一个名为<em class="mp">的文件redis_user_signup.py </em>。这模拟了用户的注册，因此为用户生成了一个数据库id。该数据库id被添加到Redis队列中。</p><figure class="mq mr ms mt gt iv"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="5252" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">让我们添加将从该队列中读取并模拟发送电子邮件的工人。我们姑且称这个模块为<em class="mp"> redis_email.py </em>。</p><figure class="mq mr ms mt gt iv"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="aa5f" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">让我们通过运行<em class="mp"> redis_user_signup.py </em>来触发用户注册。</p><pre class="mq mr ms mt gt mw mx my mz aw na bi"><span id="7e98" class="md kc je mx b gy nb nc l nd ne">$ python redis_user_signup.py</span></pre><p id="1bd9" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">输出将类似于:</p><pre class="mq mr ms mt gt mw mx my mz aw na bi"><span id="cede" class="md kc je mx b gy nb nc l nd ne">User signed up. Id: 7384</span></pre><p id="3b28" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">让我们在另一个终端上启动worker。</p><pre class="mq mr ms mt gt mw mx my mz aw na bi"><span id="2804" class="md kc je mx b gy nb nc l nd ne">$ python redis_email.py</span></pre><p id="8f79" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">输出应该如下所示:</p><pre class="mq mr ms mt gt mw mx my mz aw na bi"><span id="1486" class="md kc je mx b gy nb nc l nd ne">Received User Id: 7384<br/>Sent email to user 7384</span></pre><p id="c81b" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">两行输出之间应该有2秒钟的停顿。这是因为“time.sleep()”代码。</p><p id="68a9" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">比方说，现在我们希望用户注册时也能发送短信。我们需要再定义一个队列，并修改生成器代码，以便向该队列添加一个条目。</p><p id="4e47" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">修改后的代码如下所示:</p><figure class="mq mr ms mt gt iv"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="7872" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">让我们添加另一个工作者，它将从队列“sms”中消费，并模拟发送sms。我们姑且称这个模块为<em class="mp"> redis_sms.py </em>。它看起来像下面这样:</p><figure class="mq mr ms mt gt iv"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="b51a" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">再次调用脚本<em class="mp"> redis_user_signup </em>，以便一条消息在队列<em class="mp"> email </em>上排队，另一条消息在队列<em class="mp"> sms </em>上排队。</p><pre class="mq mr ms mt gt mw mx my mz aw na bi"><span id="e994" class="md kc je mx b gy nb nc l nd ne">$ python redis_user_signup.py</span></pre><p id="0c30" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">输出将类似于:</p><pre class="mq mr ms mt gt mw mx my mz aw na bi"><span id="aadc" class="md kc je mx b gy nb nc l nd ne">User signed up. Id: 1176</span></pre><p id="ddb2" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">在另一个终端上启动消费者<em class="mp"> redis_email.py </em>。</p><pre class="mq mr ms mt gt mw mx my mz aw na bi"><span id="6f53" class="md kc je mx b gy nb nc l nd ne">$ python redis_email.py</span></pre><p id="fcdf" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">您将看到以下类型的输出。</p><pre class="mq mr ms mt gt mw mx my mz aw na bi"><span id="00cb" class="md kc je mx b gy nb nc l nd ne">Received User Id: 1176<br/>Sent email to user 1176</span></pre><p id="9238" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">在另一个终端上启动消费者<em class="mp"> redis_sms.py </em>。</p><pre class="mq mr ms mt gt mw mx my mz aw na bi"><span id="4c37" class="md kc je mx b gy nb nc l nd ne">$ python redis_sms.py</span></pre><p id="28fe" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">您将看到以下类型的输出。</p><pre class="mq mr ms mt gt mw mx my mz aw na bi"><span id="3811" class="md kc je mx b gy nb nc l nd ne">Received User Id: 1176<br/>Sent sms to user 1176</span></pre><p id="782f" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">如果我们希望发生更多的动作，比如说发送一条whatsapp消息，那么我们将不得不引入另一个队列和工人。现在，发送whatsapp信息是消费者关心的事情。但是，我们还必须修改生成器代码，以便将消息排入相关队列。因此，它导致了紧密耦合的应用程序。</p><p id="0673" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">应该有一种更好的方法，生产者不需要修改，任何对此事件感兴趣的消费者都可以得到消息并据此采取行动。</p><p id="40a4" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">从而进入RabbitMQ及其扇出交换机制。</p><p id="0b6a" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">使用RabbitMQ，我们将编写生产者代码。生产者将消息发布到交易所。交换将是一个<strong class="lb jf">扇出</strong>交换。因此，任何订阅这种交换的消费者都能得到消息。</p><p id="7b1e" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">让我们在模块<em class="mp">rabbit MQ _ user _ sign up . py</em>中编写生产者代码</p><figure class="mq mr ms mt gt iv"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="f997" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">让我们在模块<em class="mp"> rabbitmq_email.py </em>中编写邮件发送代码</p><p id="0bc5" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">触发消费者代码，以便它开始监听绑定到交换的队列。</p><pre class="mq mr ms mt gt mw mx my mz aw na bi"><span id="8df9" class="md kc je mx b gy nb nc l nd ne">$ python rabbitmq_email.py</span></pre><p id="171e" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">在另一个终端上，触发发布者，以便发生用户注册，并且用户id被发布到交换。</p><pre class="mq mr ms mt gt mw mx my mz aw na bi"><span id="1461" class="md kc je mx b gy nb nc l nd ne">$ python rabbitmq_user_signup.py</span></pre><p id="b263" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">您应该会在用户终端上看到以下输出，即<em class="mp"> rabbitmq_email.py </em>。</p><pre class="mq mr ms mt gt mw mx my mz aw na bi"><span id="b711" class="md kc je mx b gy nb nc l nd ne">Received User Id: b’396'<br/>Sent email to user b’396'</span></pre><p id="bebd" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">您会注意到，publisher不必担心运行消费者rabbitmq_email的队列。生产者只是关心一个交换。消费者创建了一个队列，并将其绑定到交换中，这样就可以得到任何添加到交换中的消息的通知。</p><p id="e6ce" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">让我们添加另一个通知代码，即注册时向用户发送短信的代码。因此用下面的代码创建一个模块<em class="mp"> rabbitmq_sms.py </em>。</p><figure class="mq mr ms mt gt iv"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="5174" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">在另一个终端上启动此消费者。</p><pre class="mq mr ms mt gt mw mx my mz aw na bi"><span id="7221" class="md kc je mx b gy nb nc l nd ne">$ python rabbitmq_sms.py</span></pre><p id="3eb6" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">触发发布者，以便模拟用户注册。</p><pre class="mq mr ms mt gt mw mx my mz aw na bi"><span id="f2c1" class="md kc je mx b gy nb nc l nd ne">$ python rabbitmq_user_signup.py</span></pre><p id="53e9" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">您会注意到消息被打印在两个消费者的终端上。</p><p id="15e8" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">以下内容应打印在<em class="mp"> rabbitmq_email.py </em>终端上。</p><pre class="mq mr ms mt gt mw mx my mz aw na bi"><span id="6cf1" class="md kc je mx b gy nb nc l nd ne">Received User Id: b’5174'<br/>Sent email to user b’5174'</span></pre><p id="7f32" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">并且在<em class="mp"> rabbitmq_sms.py </em>终端上应该打印出以下内容。</p><pre class="mq mr ms mt gt mw mx my mz aw na bi"><span id="63af" class="md kc je mx b gy nb nc l nd ne">Received User Id: b’5174'<br/>Sent sms to user b’5174'</span></pre><p id="49c6" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">这证实了预订交换的两个消费者都得到通知。您一定已经注意到，发布者代码不需要任何更改。</p><p id="4378" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">因此，发布者和消费者现在是分离的。<br/>如果我们想在用户注册时发送另一种通知，比如whatsapp消息，那么可以定义多一个消费者。然而，发布者不需要知道它，因此将保持与消费者的分离。</p><p id="ebf8" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">这说明了在多个消费者想要订阅一个事件的场景中，RabbitMQ是一个更好的选择。此外，RabbitMQ在这种情况下会带来更好的解耦解决方案。</p><h1 id="5f3c" class="kb kc je bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">外卖食品</h1><ul class=""><li id="b0ab" class="ni nj je lb b lc ld lg lh lk nk lo nl ls nm lw nn no np nq bi translated">RabbitMQ支持消息确认。因此，在某些情况下，它可以帮助构建容错和可靠的解决方案。</li><li id="5f71" class="ni nj je lb b lc nr lg ns lk nt lo nu ls nv lw nn no np nq bi translated">RabbitMQ有更好的路由机制。一个这样的例子是扇出交换，它可以帮助构建解耦的生产者和消费者。</li></ul></div><div class="ab cl nw nx hx ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="im in io ip iq"><h1 id="b4e1" class="kb kc je bd kd ke od kg kh ki oe kk kl km of ko kp kq og ks kt ku oh kw kx ky bi translated">分级编码</h1><p id="89bd" class="pw-post-body-paragraph kz la je lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">感谢您成为我们社区的一员！在你离开之前:</p><ul class=""><li id="388e" class="ni nj je lb b lc lx lg ly lk oi lo oj ls ok lw nn no np nq bi translated">👏为故事鼓掌，跟着作者走👉</li><li id="b410" class="ni nj je lb b lc nr lg ns lk nt lo nu ls nv lw nn no np nq bi translated">📰查看<a class="ae mc" href="https://levelup.gitconnected.com/?utm_source=pub&amp;utm_medium=post" rel="noopener ugc nofollow" target="_blank">升级编码出版物</a>中的更多内容</li><li id="d01c" class="ni nj je lb b lc nr lg ns lk nt lo nu ls nv lw nn no np nq bi translated">🔔关注我们:<a class="ae mc" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">Twitter</a>|<a class="ae mc" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>|<a class="ae mc" href="https://newsletter.levelup.dev" rel="noopener ugc nofollow" target="_blank">时事通讯</a></li></ul><p id="5f1c" class="pw-post-body-paragraph kz la je lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">🚀👉<a class="ae mc" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="lb jf">加入升级人才集体，找到一份惊艳的工作</strong> </a></p></div></div>    
</body>
</html>