<html>
<head>
<title>How I Built a Self-Updating Blog Catalog Using a Bot — Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我如何使用机器人构建自我更新的博客目录——第1部分</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-i-built-a-self-updating-blog-catalog-using-a-bot-part-1-bd7399ba1e4f?source=collection_archive---------14-----------------------#2021-02-11">https://levelup.gitconnected.com/how-i-built-a-self-updating-blog-catalog-using-a-bot-part-1-bd7399ba1e4f?source=collection_archive---------14-----------------------#2021-02-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7e3e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用GitHub操作和Python</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a492e10e88a522280f6be9bc04b010ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EhoON1zCBkg8hjq4JKtwSg.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://www.pexels.com/@lee-campbell-18167?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">李·坎贝尔</a>从<a class="ae ky" href="https://www.pexels.com/photo/apple-books-desk-keyboard-115655/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">佩克斯</a>拍摄</figcaption></figure><p id="cb1c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">几周前，我更换了我的网站，增加了一个<a class="ae ky" href="https://mahbub.ninja/blog.html" rel="noopener ugc nofollow" target="_blank">博客版块</a>，在那里我列出了我所有的媒体文章。但是我立即遇到了一个问题，这意味着这个小任务比我预期的需要更多的手工工作。由于我使用JSON文件作为博客目录数据的来源，所以每次我在Medium上发布一篇新的博客文章时，我都必须将它的标题和URL添加到JSON文件中，并将其推送到GitHub。最后，由于<a class="ae ky" href="https://docs.netlify.com/site-deploys/create-deploys/#deploy-with-git" rel="noopener ugc nofollow" target="_blank">持续部署</a>，它自动部署到<a class="ae ky" href="https://www.netlify.com/" rel="noopener ugc nofollow" target="_blank">网络</a>。</p><p id="3baf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">总的来说，没那么糟糕。但是我不想手动更新JSON文件。相反，我决定用GitHub Actions和Python为我写一个更新JSON文件的机器人。它节省了我大约五分钟。这听起来可能不多，但你愿意花多少钱来换取每周半小时或每月两小时？这一切都说明了。</p><blockquote class="lv lw lx"><p id="faa3" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">你可以使用同样的技术来更新你网站上任何你想更新的东西。</p></blockquote></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="79ed" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">设置</h1><p id="e4e0" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">你需要安装<a class="ae ky" href="https://www.python.org/downloads/" rel="noopener ugc nofollow" target="_blank"> Python </a>并从<a class="ae ky" href="https://github.com/lifeparticle/Medium-Blog-Bot" rel="noopener ugc nofollow" target="_blank"> GitHub </a>下载一个git库。对于这个设置，我使用Python版本<code class="fe ng nh ni nj b">3.8.4</code>和macOS。</p><p id="90f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我用这四个步骤创建了我的自动更新机器人。</p><ol class=""><li id="8120" class="nk nl it lb b lc ld lf lg li nm lm nn lq no lu np nq nr ns bi translated">用初始博客目录数据创建一个JSON文件。</li><li id="2e3b" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated">创建网页来显示博客目录数据。</li><li id="2de9" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated">创建一个Python脚本。</li><li id="638f" class="nk nl it lb b lc nt lf nu li nv lm nw lq nx lu np nq nr ns bi translated">创建GitHub操作。</li></ol><h2 id="eae8" class="ny mk it bd ml nz oa dn mp ob oc dp mt li od oe mv lm of og mx lq oh oi mz oj bi translated">1.创建一个JSON文件</h2><p id="870f" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">这里是<a class="ae ky" href="https://github.com/lifeparticle/Medium-Blog-Bot/blob/main/blog_links.json" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上JSON文件<strong class="lb iu"> blog_links.json </strong>的链接。这个文件是我博客目录的唯一真实来源。我的目标是每当有新帖子时更新这个文件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">JSON文件格式</figcaption></figure><h2 id="c4c0" class="ny mk it bd ml nz oa dn mp ob oc dp mt li od oe mv lm of og mx lq oh oi mz oj bi translated">2.创建网页</h2><p id="1de2" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">这里是blog.html的HTML文件<strong class="lb iu">在<a class="ae ky" href="https://github.com/lifeparticle/Medium-Blog-Bot/blob/main/blog.html" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上的链接。这个文件从<strong class="lb iu"> blog_links.json </strong>加载数据。在博客目录的顶部，我添加了一个目录搜索功能。我将CSS框架<a class="ae ky" href="https://getbootstrap.com/" rel="noopener ugc nofollow" target="_blank"> Bootstrap </a>用于响应式设计，将JavaScript库<a class="ae ky" href="https://jquery.com/" rel="noopener ugc nofollow" target="_blank"> jQuery </a>用于HTML DOM操作、事件处理等。</strong></p><p id="234f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我需要一个web服务器来本地加载blog.html页面。对于这篇文章，我使用了Python web服务器。python命令<code class="fe ng nh ni nj b">python -m http.server</code>将运行<code class="fe ng nh ni nj b">http.server</code>模块。你可以在<a class="ae ky" href="https://docs.python.org/3/using/cmdline.html" rel="noopener ugc nofollow" target="_blank"> Python文档</a>和<a class="ae ky" href="https://docs.python.org/3/library/http.server.html" rel="noopener ugc nofollow" target="_blank"> Python文档</a>上阅读更多的命令行选项。</p><pre class="kj kk kl km gt om nj on bn oo op bi"><span id="6816" class="oq mk it nj b be or os l ot ou">cd Medium-Blog-Bot<br/>python -m http.server</span></pre><p id="9f7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您不使用web服务器，您将会得到类似下面的错误。</p><pre class="kj kk kl km gt om nj on bn oo op bi"><span id="0c4c" class="oq mk it nj b be or os l ot ou">from origin 'null' has been blocked by CORS policy:</span></pre><p id="eae0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">出于安全原因，它限制访问。你可以在<a class="ae ky" href="https://tools.ietf.org/html/rfc6454" rel="noopener ugc nofollow" target="_blank">互联网工程任务组</a>网站上了解更多。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/0e68a4ec11fc92a0666235fc4f67ad53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1314/format:webp/1*f2YrLoEZWFLIEdIRAkMpDQ.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">博客页面</figcaption></figure><p id="f3af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，用你最喜欢的网页浏览器访问<a class="ae ky" href="http://localhost:8000/blog.html" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu">http://localhost:8000/blog . html</strong></a>网址，你应该会看到类似上面截图的东西。</p><h2 id="ef4c" class="ny mk it bd ml nz oa dn mp ob oc dp mt li od oe mv lm of og mx lq oh oi mz oj bi translated">3.创建Python脚本</h2><p id="6f28" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">这里是<a class="ae ky" href="https://github.com/lifeparticle/Medium-Blog-Bot/blob/main/build_json.py" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上到Python文件<strong class="lb iu"> build_json.py </strong>的链接。此文件比较来自介质的<strong class="lb iu"> blog_links.json </strong>和<a class="ae ky" href="https://help.medium.com/hc/en-us/articles/214874118-Using-RSS-feeds-of-profiles-and-publications" rel="noopener"><strong class="lb iu">RSS feed</strong></a><strong class="lb iu"/>数据。最后，如果在<strong class="lb iu"> RSS提要</strong>中有新数据，它会更新<strong class="lb iu"> blog_links.json </strong>文件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ok ol l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><code class="fe ng nh ni nj b">build_json.py</code></figcaption></figure><p id="df40" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我想重点介绍一下<code class="fe ng nh ni nj b">compare_data(oldData, newData)</code>函数。<code class="fe ng nh ni nj b">oldData</code>保存来自<strong class="lb iu"> blog_links.json </strong>文件的数据，<code class="fe ng nh ni nj b">newData</code>保存来自<strong class="lb iu"> RSS提要</strong>的数据。如你所见，我使用了一个名为<a class="ae ky" href="https://pypi.org/project/fuzzywuzzy/" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> FuzzyWuzzy </strong> </a>的python模块。<code class="fe ng nh ni nj b">ratio()</code>函数使用<a class="ae ky" href="https://en.wikipedia.org/wiki/Levenshtein_distance" rel="noopener ugc nofollow" target="_blank"> Levenshtein距离</a>计算两个字符串之间的相似度。但是有经验的程序员可能会奇怪，为什么我不只是用传统的方法比较两个标题。</p><p id="65be" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你比较一下<strong class="lb iu"> blog_links.json </strong>和<strong class="lb iu"> RSS feed </strong>的标题，你会看到两个略有不同的标题。这是因为我发布帖子后改了标题。但是<strong class="lb iu"> RSS提要</strong>并没有反映最近的变化。</p><pre class="kj kk kl km gt om nj ow ox aw oy bi"><span id="d2c2" class="ny mk it nj b gy oz pa l pb ou">An Introduction to Ruby Hashes<br/>vs<br/>An Introduction to Ruby Hash</span></pre><p id="cfc7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我不使用比率来比较两个字符串，Python脚本会将这一个帖子视为两个帖子。在这里，我使用了90%的相似度。你可以根据你的要求来设置。使用以下命令在本地运行<strong class="lb iu"> build_json.py </strong>。</p><pre class="kj kk kl km gt om nj ow ox aw oy bi"><span id="0fb8" class="ny mk it nj b gy oz pa l pb ou">pip install requests<br/>pip install fuzzywuzzy<br/>cd <!-- -->Medium-Blog-Bot<br/>python build_json.py</span></pre><h2 id="8bb6" class="ny mk it bd ml nz oa dn mp ob oc dp mt li od oe mv lm of og mx lq oh oi mz oj bi translated">4.创建GitHub操作</h2><p id="7220" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">这里是<a class="ae ky" href="https://github.com/lifeparticle/Medium-Blog-Bot/blob/main/.github/workflows/python-app.yml" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上到YML文件<strong class="lb iu"> python-app.yml </strong>的链接，它会在每天午夜(<a class="ae ky" href="https://docs.github.com/en/actions/reference/events-that-trigger-workflows#scheduled-events-schedule" rel="noopener ugc nofollow" target="_blank"> UTC </a>)和主分支上的每次git推送运行python脚本。阅读更多关于<a class="ae ky" href="https://docs.github.com/en/actions" rel="noopener ugc nofollow" target="_blank"> GitHub动作</a>的信息。</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h1 id="da1a" class="mj mk it bd ml mm mn mo mp mq mr ms mt jz mu ka mv kc mw kd mx kf my kg mz na bi translated">包裹</h1><p id="401d" class="pw-post-body-paragraph kz la it lb b lc nb ju le lf nc jx lh li nd lk ll lm ne lo lp lq nf ls lt lu im bi translated">确定你是否需要机器人的一个好方法是在日常生活中重复。如果是这样的话，您很有可能可以将其自动化。</p><p id="e4f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然这个场景并没有节省很多时间，但它让我的生活变得更容易，因为我不用担心更新我的网站(希望如此！)，而这也是写一个bot的足够理由。编码快乐！</p></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><p id="0338" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您在第1部分学到了新东西，请阅读第2部分。</p><div class="pc pd gp gr pe pf"><a rel="noopener  ugc nofollow" target="_blank" href="/how-i-built-a-self-updating-blog-catalog-using-a-bot-part-2-a67968be5f42"><div class="pg ab fo"><div class="ph ab pi cl cj pj"><h2 class="bd iu gy z fp pk fr fs pl fu fw is bi translated">我如何使用机器人构建自我更新的博客目录——第2部分</h2><div class="pm l"><h3 class="bd b gy z fp pk fr fs pl fu fw dk translated">改进比较功能</h3></div><div class="pn l"><p class="bd b dl z fp pk fr fs pl fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="po l"><div class="pp l pq pr ps po pt ks pf"/></div></div></a></div></div></div>    
</body>
</html>