<html>
<head>
<title>The Ultimate Guide To Sets In Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python集合的终极指南</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/the-ultimate-guide-to-sets-in-python-c7556402726c?source=collection_archive---------3-----------------------#2022-10-08">https://levelup.gitconnected.com/the-ultimate-guide-to-sets-in-python-c7556402726c?source=collection_archive---------3-----------------------#2022-10-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="5a97" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">计算机编程语言</h2><div class=""/><div class=""><h2 id="30ba" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">你需要知道的一切。</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/ece3127cbbd09f55f5ed7a2305295f37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Btce62wAULdrdrQcmcrRrw.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">由<a class="ae lh" href="https://medium.com/@dreamferus" rel="noopener"> Jacob Ferus </a>使用Midjourney生成。</figcaption></figure><p id="3fc0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">set类是Python中的关键数据结构之一。这是一个无序的<em class="me"> </em>元素集合，没有重复。在某种程度上，它表示一个数学集合，许多常用的集合数学运算都存在于Python中。通常集合的操作比列表的操作要快得多，因此，要编写有效的代码，集合是必不可少的。在本文中，我将解释set类的来龙去脉。我们开始吧。</p><h1 id="cff1" class="mf mg it bd mh mi mj mk ml mm mn mo mp ki mq kj mr kl ms km mt ko mu kp mv mw bi translated">初始化</h1><p id="09bf" class="pw-post-body-paragraph li lj it lk b ll mx kd ln lo my kg lq lr mz lt lu lv na lx ly lz nb mb mc md im bi translated">在Python中有两种创建set对象的方法:使用<code class="fe nc nd ne nf b">set(iterable)</code>或将元素放在花括号<code class="fe nc nd ne nf b">{ ... }</code>中，用逗号分隔。例外情况是，如果花括号是空的，即<code class="fe nc nd ne nf b">{}</code>，那么将创建一个字典，而不是一个空集。对于空集，使用<code class="fe nc nd ne nf b">set()</code>。请注意，元素的顺序无关紧要，重复的元素将被删除。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="ff5e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">集合中可以包含哪些元素？答案是只有<strong class="lk jd">不可变* </strong>类型的对象。这些类型包括float、int、string、bool等。这与<strong class="lk jd">易变的</strong>类型相反，比如列表、字典和集合本身。如果你想学习更多关于Python中不同类型变量的知识，我推荐你阅读这篇文章。因此，以下内容将导致错误:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="ae4e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">但是，当您需要存储(例如)一个集合中的唯一序列时，该怎么办呢？我将在本文的最后一节详细讨论这一点。</p><h1 id="9e9e" class="mf mg it bd mh mi mj mk ml mm mn mo mp ki mq kj mr kl ms km mt ko mu kp mv mw bi translated">*关于不变性的说明</h1><p id="8fa4" class="pw-post-body-paragraph li lj it lk b ll mx kd ln lo my kg lq lr mz lt lu lv na lx ly lz nb mb mc md im bi translated">不变性只是内置类型的一个约束。实际上，对象只需要是<em class="me">可散列的</em>就可以插入到集合中，或者是字典中的关键字。默认情况下，自定义类有一个基于其id的散列，相等性由它们的id定义。这意味着两个属性相同的对象在进行相等性检查时是不相等的，除非它们是同一个对象或者已经定义了一个自定义的<code class="fe nc nd ne nf b">__eq__</code>操作符。</p><p id="06f3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果定义了一个自定义<code class="fe nc nd ne nf b">__eq__</code>操作符，它们将不再可用<em class="me">，除非定义了一个自定义<code class="fe nc nd ne nf b">__hash__</code>操作符</em>。这里很重要的一点是，如果两个对象相等，它们的哈希值也必须相等。否则，将对象添加到字典或字典集时会出现问题，因为在检查字典键和字典集是否存在时，会测试哈希值和相等性。</p><p id="8499" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">将可变对象放在集合中或作为字典键有意义的唯一情况是，它没有基于其可变属性的相等运算符。如果您确实有一个基于对象属性的相等运算符和相应的散列函数，那么如果您首先将它添加到一个集合，然后更改它，则用于将其保存在集合中的散列值将与当前散列值不同。这是不好的做法。</p><h1 id="e117" class="mf mg it bd mh mi mj mk ml mm mn mo mp ki mq kj mr kl ms km mt ko mu kp mv mw bi translated">添加元素</h1><p id="c706" class="pw-post-body-paragraph li lj it lk b ll mx kd ln lo my kg lq lr mz lt lu lv na lx ly lz nb mb mc md im bi translated">向集合中添加元素有多种方式。为了<em class="me">变异</em>一个集合，你使用<code class="fe nc nd ne nf b">.add()</code>添加单个元素，使用<code class="fe nc nd ne nf b">.update()</code>或等价的<code class="fe nc nd ne nf b">|=</code>添加可迭代的元素:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="782f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">通过变异，我的意思是改变原来的对象。您也可以添加不会修改原始集的元素。这可以通过使用<code class="fe nc nd ne nf b">union()</code>或等效地使用<code class="fe nc nd ne nf b">|</code>来完成:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="d226" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">使用<code class="fe nc nd ne nf b">.update()</code>和<code class="fe nc nd ne nf b">.union()</code>在行为上的明显差异可以在下面的例子中看出:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="b519" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">最后，您还可以使用析构来连接两个集合:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="d0b2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这将像一个<code class="fe nc nd ne nf b">union()</code>的功能，但我会推荐<code class="fe nc nd ne nf b">union()</code>代替它。</p><p id="c8de" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">注意，我在上面的例子中使用了<code class="fe nc nd ne nf b">.update()</code>，但是你也可以使用<code class="fe nc nd ne nf b">|=</code>。这意味着<code class="fe nc nd ne nf b">a |= b</code> ( <code class="fe nc nd ne nf b">.update()</code>)是<strong class="lk jd">而不是<em class="me"> </em> </strong>与<code class="fe nc nd ne nf b">a = a | b</code> ( <code class="fe nc nd ne nf b">.union()</code>)是一回事，因为第一个对<code class="fe nc nd ne nf b">a</code>中的对象进行变异，而第二个给<code class="fe nc nd ne nf b">a</code>赋值。</p><h1 id="dfa3" class="mf mg it bd mh mi mj mk ml mm mn mo mp ki mq kj mr kl ms km mt ko mu kp mv mw bi translated">删除元素</h1><p id="8d71" class="pw-post-body-paragraph li lj it lk b ll mx kd ln lo my kg lq lr mz lt lu lv na lx ly lz nb mb mc md im bi translated">就像添加元素一样，<em class="me">移除</em>元素也有等效的操作。下面我将向您展示前面显示的加法运算符的相应删除运算符:</p><ul class=""><li id="bf26" class="ni nj it lk b ll lm lo lp lr nk lv nl lz nm md nn no np nq bi translated"><code class="fe nc nd ne nf b">.add()</code>是<code class="fe nc nd ne nf b">.remove()</code></li><li id="0ccd" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md nn no np nq bi translated"><code class="fe nc nd ne nf b">.update()</code>是<code class="fe nc nd ne nf b">.difference_update()</code>还是<code class="fe nc nd ne nf b">-=</code></li><li id="9401" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md nn no np nq bi translated"><code class="fe nc nd ne nf b">.union()</code>是<code class="fe nc nd ne nf b">.difference()</code>还是<code class="fe nc nd ne nf b">-</code></li></ul><p id="9979" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">示例:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="af50" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">再次，要注意<code class="fe nc nd ne nf b">a -= b</code>(突变)和<code class="fe nc nd ne nf b">a = a — b</code>(未突变)的区别。</p><p id="89d0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">还有一些其他有用的删除方法:</p><ul class=""><li id="b970" class="ni nj it lk b ll lm lo lp lr nk lv nl lz nm md nn no np nq bi translated"><code class="fe nc nd ne nf b">.clear()</code>将删除列表中的所有元素。</li><li id="9aa4" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md nn no np nq bi translated">如果存在的话<code class="fe nc nd ne nf b">.remove()</code>只移除一个元素<em class="me">(否则抛出一个错误)，如果元素不存在的话<code class="fe nc nd ne nf b">.discard()</code>将什么都不做。</em></li><li id="a9ac" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md nn no np nq bi translated"><code class="fe nc nd ne nf b">.pop()</code>将从集合中移除并返回一个随机元素。</li></ul><h1 id="36f6" class="mf mg it bd mh mi mj mk ml mm mn mo mp ki mq kj mr kl ms km mt ko mu kp mv mw bi translated">其他修改操作</h1><p id="54dc" class="pw-post-body-paragraph li lj it lk b ll mx kd ln lo my kg lq lr mz lt lu lv na lx ly lz nb mb mc md im bi translated">Python中集合的强大之处之一是为它们提供了大量的内置操作。您已经看到了添加和删除元素，但是您还可以执行以下操作:</p><h2 id="722c" class="nw mg it bd mh nx ny dn ml nz oa dp mp lr ob oc mr lv od oe mt lz of og mv iz bi translated">交集</h2><p id="ac40" class="pw-post-body-paragraph li lj it lk b ll mx kd ln lo my kg lq lr mz lt lu lv na lx ly lz nb mb mc md im bi translated">两个集合之间的<em class="me">交集</em>是包含在两个集合中的元素集合。它的操作符是:</p><ul class=""><li id="e65e" class="ni nj it lk b ll lm lo lp lr nk lv nl lz nm md nn no np nq bi translated">非突变:<code class="fe nc nd ne nf b">.intersection()</code>或<code class="fe nc nd ne nf b">&amp;</code>，即<code class="fe nc nd ne nf b">a.intersection(b)</code>或<code class="fe nc nd ne nf b">a &amp; b</code></li><li id="d502" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md nn no np nq bi translated">变异:<code class="fe nc nd ne nf b">.intersection_update</code>或<code class="fe nc nd ne nf b">&amp;=</code></li></ul><p id="64dd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">示例:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ng nh l"/></div></figure><h2 id="5124" class="nw mg it bd mh nx ny dn ml nz oa dp mp lr ob oc mr lv od oe mt lz of og mv iz bi translated">对称差或析取并</h2><p id="85f3" class="pw-post-body-paragraph li lj it lk b ll mx kd ln lo my kg lq lr mz lt lu lv na lx ly lz nb mb mc md im bi translated">交集的反义词，即只属于集合中的<em class="me">一个</em>而不属于两个集合的所有元素称为<em class="me">对称差</em>或<em class="me">析取并</em>。它的操作符是:</p><ul class=""><li id="8714" class="ni nj it lk b ll lm lo lp lr nk lv nl lz nm md nn no np nq bi translated">非突变:<code class="fe nc nd ne nf b">.symmetric_difference()</code>或<code class="fe nc nd ne nf b">^</code>，即<code class="fe nc nd ne nf b">a.symmmetric_difference(b)</code>或<code class="fe nc nd ne nf b">a ^ b</code></li><li id="f8e7" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md nn no np nq bi translated">突变:<code class="fe nc nd ne nf b">.symmetric_difference_update()</code>或<code class="fe nc nd ne nf b">^=</code></li></ul><p id="c977" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">示例:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ng nh l"/></div></figure><h1 id="e0e7" class="mf mg it bd mh mi mj mk ml mm mn mo mp ki mq kj mr kl ms km mt ko mu kp mv mw bi translated">比较方法</h1><p id="986a" class="pw-post-body-paragraph li lj it lk b ll mx kd ln lo my kg lq lr mz lt lu lv na lx ly lz nb mb mc md im bi translated">我已经向您展示了如何修改集合，但是集合主要用于检查它们内部的元素是否<strong class="lk jd">快，</strong> <em class="me"> </em>否则使用列表会比较慢。让我们看看哪些操作可以做到这一点。</p><h2 id="ce54" class="nw mg it bd mh nx ny dn ml nz oa dp mp lr ob oc mr lv od oe mt lz of og mv iz bi translated">检查集合中是否存在</h2><p id="9584" class="pw-post-body-paragraph li lj it lk b ll mx kd ln lo my kg lq lr mz lt lu lv na lx ly lz nb mb mc md im bi translated">这可能是您对器械包执行最多的操作。通过使用<code class="fe nc nd ne nf b">in</code>-操作符检查元素的存在或<code class="fe nc nd ne nf b">not in</code>检查元素的不存在。与在列表中查找元素相反，时间复杂度是常数，O(1)。也就是说，即使您添加越来越多的元素，操作仍然会一样快。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ng nh l"/></div></figure><h2 id="ae1c" class="nw mg it bd mh nx ny dn ml nz oa dp mp lr ob oc mr lv od oe mt lz of og mv iz bi translated">检查一个集合是否是另一个集合的子集</h2><p id="01bd" class="pw-post-body-paragraph li lj it lk b ll mx kd ln lo my kg lq lr mz lt lu lv na lx ly lz nb mb mc md im bi translated">如果第一个集合中的所有元素都存在于第二个集合中，那么这个集合就是另一个集合的子集。例如，(A，B，C)是(A，B，C，D)的子集。在Python中，这可以用<code class="fe nc nd ne nf b">.issubset</code>或<code class="fe nc nd ne nf b">&lt;=</code>来检查。要检查一个集合是否是另一个集合的<em class="me">真子集</em>，即它是一个子集并且它们不相等，可以使用<code class="fe nc nd ne nf b">&lt;</code>。但是注意也可以用<code class="fe nc nd ne nf b">&gt;=, &gt;</code>。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ng nh l"/></div></figure><h2 id="15d6" class="nw mg it bd mh nx ny dn ml nz oa dp mp lr ob oc mr lv od oe mt lz of og mv iz bi translated">检查集合是否没有共享元素</h2><p id="aae8" class="pw-post-body-paragraph li lj it lk b ll mx kd ln lo my kg lq lr mz lt lu lv na lx ly lz nb mb mc md im bi translated">如果集合不共享任何元素，它们被称为<em class="me">不相交</em>，在Python中，这可以用<code class="fe nc nd ne nf b">.isdisjoint()</code>来计算。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ng nh l"/></div></figure><h1 id="4d27" class="mf mg it bd mh mi mj mk ml mm mn mo mp ki mq kj mr kl ms km mt ko mu kp mv mw bi translated">集合理解</h1><p id="4678" class="pw-post-body-paragraph li lj it lk b ll mx kd ln lo my kg lq lr mz lt lu lv na lx ly lz nb mb mc md im bi translated">就像列表和字典一样，你可以使用<em class="me">理解力。</em>这是通过在花括号内添加理解表达式并在每个循环中返回一个可变元素来实现的:<code class="fe nc nd ne nf b">{ &lt;element&gt; for ... in ... }</code>。示例:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ng nh l"/></div></figure><h1 id="d527" class="mf mg it bd mh mi mj mk ml mm mn mo mp ki mq kj mr kl ms km mt ko mu kp mv mw bi translated">存储更复杂的类型</h1><p id="5c32" class="pw-post-body-paragraph li lj it lk b ll mx kd ln lo my kg lq lr mz lt lu lv na lx ly lz nb mb mc md im bi translated">想象一下，你在独立的迭代中从一个节点走到另一个节点。例如，假设您在图中走了两次，并获得了路径:</p><ul class=""><li id="23d7" class="ni nj it lk b ll lm lo lp lr nk lv nl lz nm md nn no np nq bi translated"><code class="fe nc nd ne nf b">A -&gt; B -&gt; D</code></li><li id="3a3c" class="ni nj it lk b ll nr lo ns lr nt lv nu lz nv md nn no np nq bi translated"><code class="fe nc nd ne nf b">D -&gt; C -&gt; E -&gt; B</code></li></ul><p id="f3b1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">之后，如果您已经走过了某条路径，您可能想要快速查找，由于它的查找速度，set是一个自然的选择。现在，当列表因为是可变的而不能被插入时，如何做到这一点呢？幸运的是，<strong class="lk jd">元组</strong>类<strong class="lk jd">，</strong>本质上是一个列表的不可变版本，可以在这些情况下使用。让我们看一个例子。</p><p id="d5c4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">首先，我将使用字典生成一个图。每个键代表一个节点，值将列出该节点所有可能的目的地。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="fc81" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这将生成下图:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/17b4c89613e9dc23a31bc162f8c391b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:540/format:webp/1*XKNmsSqx4x_SGO8hxJMRDQ.png"/></div></figure><p id="6665" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果您想知道我是如何生成该图的，它是使用<code class="fe nc nd ne nf b">graphviz</code>和以下代码完成的:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="1a20" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，我将执行长度为1-10的所谓的<em class="me">随机漫步</em>，然后将结果路径作为元组存储在一个集合中。让我们看看在100次行走中我们能产生多少条独特的路径:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="dbbb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在100次随机漫步中，有83次是不同的。</p><p id="3096" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在，如果我们不关心节点的顺序，而只想存储访问过的节点，会怎么样呢？那么使用集合是有意义的，但是集合也是可变的。相反，我们可以使用<strong class="lk jd"> frozenset </strong>类，一个不可变的集合。让我们为此添加一个新的循环:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ng nh l"/></div></figure><h1 id="ba0b" class="mf mg it bd mh mi mj mk ml mm mn mo mp ki mq kj mr kl ms km mt ko mu kp mv mw bi translated">摘要</h1><p id="8244" class="pw-post-body-paragraph li lj it lk b ll mx kd ln lo my kg lq lr mz lt lu lv na lx ly lz nb mb mc md im bi translated">由于某些操作的速度，集合是很有用的，它可以大大提高代码的效率。此外，Python中有许多简洁而有用的方法来简化代码。感谢阅读。</p></div><div class="ab cl oi oj hx ok" role="separator"><span class="ol bw bk om on oo"/><span class="ol bw bk om on oo"/><span class="ol bw bk om on"/></div><div class="im in io ip iq"><p id="d279" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果您有兴趣阅读更多关于Python的文章，请查看我下面的阅读列表:</p><div class="op oq gp gr or"><div role="button" tabindex="0" class="ab bv gv cb fp os ot bn ou lb ex"><div class="ov l"><div class="ab q"><div class="l di"><img alt="Jacob Ferus" class="l de bw ow ox fe" src="../Images/3fe8a4152942d124e84f4370bdeaa704.png" width="20" height="20" loading="lazy" data-original-src="https://miro.medium.com/v2/resize:fill:40:40/1*kBjZOzA4VnMIigyfQz5-KQ.png"/><div class="fb bw l ow ox fc n aw fd"/></div><div class="hh l fo"><p class="bd b dl z fp fq fr fs ft fu fv fw dk translated">雅各布·费罗斯</p></div></div><div class="pa pb gw l"><h2 class="bd jd uf ni fp ug fr fs uh fu fw jc bi translated">计算机编程语言</h2></div><div class="ab q"><div class="l fo"><a class="bd b be z bi ui au uj uk ul qv um an eh ei un uo up el em eo de bk ep" href="https://medium.com/@dreamferus/list/python-c8e4719d93da?source=post_page-----c7556402726c--------------------------------" rel="noopener follow" target="_top">View list</a></div><div class="uq l fo"><span class="bd b dl z dk">32 stories</span></div></div></div><div class="pn dh po fp ab pp fo di"><div class="di pf bv pg ph"><div class="dh l"><img alt="" class="dh" src="../Images/04c5beba0e198bb074b51dab1e99cea5.png" width="194" height="194" loading="lazy" role="presentation" data-original-src="https://miro.medium.com/v2/resize:fill:388:388/1*NDYYDnoigpuPoAeetcRcFg.png"/></div></div><div class="di pf bv pi pj pk"><div class="dh l"><img alt="" class="dh" src="../Images/ddc10e2a657adb0dca6dc40fbab3ef74.png" width="194" height="194" loading="lazy" role="presentation" data-original-src="https://miro.medium.com/v2/resize:fill:388:388/1*s5kLvTIF2VvEEahx_OJaXA.png"/></div></div><div class="di bv pl pm pk"><div class="dh l"><img alt="" class="dh" src="../Images/c0376aaf2f82f915fbbb9e6f86a2c621.png" width="194" height="194" loading="lazy" role="presentation" data-original-src="https://miro.medium.com/v2/resize:fill:388:388/1*m7BwF83vfu-cfexGQ8px0w.png"/></div></div></div></div></div><p id="9d57" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果你想成为中级会员，你可以使用我的<a class="ae lh" href="https://medium.com/@dreamferus/membership" rel="noopener">推荐链接</a>。祝你有愉快的一天。</p></div></div>    
</body>
</html>