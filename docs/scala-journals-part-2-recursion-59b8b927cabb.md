# Scala 期刊—递归

> 原文：<https://levelup.gitconnected.com/scala-journals-part-2-recursion-59b8b927cabb>

![](img/c73b91198284e0dbf585adee96239dae.png)

我们可以想象，任何非平凡的程序在某个阶段都必须循环某些东西，由于我们在函数式编程中谈论了太多的不变性，我们可能会对使用常规循环感到有点犹豫……递归拯救了我们，对吗？

## 什么是递归，它实际上是如何工作的，它与不变性有什么关系？

递归是一个调用自身直到满足退出条件的函数。这是一种将一个大问题分解成小问题的方法，当这些小问题都解决了，大问题也就解决了。从现实生活的角度来看:吹干我的头发可能是一种递归形式。把我的头发弄干一分钟。检查我的头发是否干燥。如果是干的，就停下来。否则，把我的头发弄干一分钟。

## 递归如何在堆栈上工作

在我们开始举例之前，我想先谈谈堆栈，因为这是递归内部的工作方式。让我们深入了解一下函数调用。

堆栈是内存中存储函数调用所创建的临时变量的地方。堆栈是后进先出(LIFO)数据结构，这意味着最后添加的元素将是第一个移除的元素。每当一个函数第一次被调用时，它会在堆栈中创建一个块，所有的参数、它创建的任何局部变量(以及更多)都会被放入这个块中。一旦函数退出，堆栈上的所有元素都被弹出(最后推入的元素将首先被弹出(LIFO))并且块被擦除。为了形象化它:

```
def fctn = { 
      val a = "a"     
      val b = "b"  
     }
```

给定上述函数，情况如下:

在`fctn`呼叫时:

1.  为`fctn`创建一个堆栈块
2.  推送变量— `a = "a"`
3.  推送变量— `b = "b"`

在`fctn`出口处:

1.  弹出变量(`b`)
2.  弹出变量(`a`)
3.  擦除`fctn`块

![](img/491729b459e65c5cdaab94135d6aa7f5.png)

现在是引进一本经典递归函数:阶乘的好时机。

```
def factorial(n: Int): Int = {     
    if(n <= 1) 1 // exit condition     
    else n * factorial(n - 1) // recursive call to itself  
  }
```

我们可以看到这个函数由两部分组成:

*   退出条件(又称基本情况)
*   在满足退出条件之前将被调用的递归调用

现在让我们看看阶乘在被调用时实际上是如何工作的。您会看到递归调用“向下”(到堆栈上)以及返回值“向上”(离开堆栈)，一旦调用函数被求值(有点简化，但本质上就是这样工作的)。正如我之前提到的，我们可以很好地看到如何解决一个小问题(阶乘(1))导致解决大问题(阶乘(4))。

![](img/987a88c937edc96ad19a755bf1448312.png)

通过上面的解释，我们很容易注意到当涉及到递归时，退出条件是多么重要。如果没有上面的退出条件，我们将继续无限调用阶乘函数。

# 头部递归

Head 递归是一种用更新的参数调用自身的递归，直到满足退出条件。一个很好的例子是我们的阶乘函数。正如你所想象的，堆栈大小是有限的，因此如果我们调用`factorial(1234)`，代码将抛出 StackOverflowException——堆栈上已经没有空间再进行另一次调用了。这是我们应该避免的事情，所以另一个选择是**尾递归**。

# 尾部递归

尾部递归(如果做得正确)是避免堆栈溢出异常的一种方法。尾递归函数是一个最后一次调用是对自身的调用的函数。有一个累加器，它允许在我们进行的过程中将计算出的值传递给下一个递归调用。在 Scala 中，它们可以用`@tailrec`来注释。

那么让我们重写我们的阶乘:

```
@tailrec  
def factorial(n: Int, accumulator: Int): Int =
    if(n <= 1) accumulator // exit condition     
    else factorial(n - 1, n * accumulator) // recursive call 
  }
```

头递归版本的几个区别:

*   Scala 允许你将这段代码注释为尾部递归
*   有一个蓄电池
*   不会像 head 递归中那样出现对堆栈的“金字塔”式调用，因为我们在进行过程中会累积计算出的值，并立即将其传递给下一个递归调用。

这些调用看起来会像这样…

![](img/1a2a1eb977b727ab2637f0a52a1a7ccc.png)

…这有点像 while 循环…

**剧情转折！在 Scala tail 中，递归函数实际上被优化为 while 循环。**

## 什么..那么递归对坚持不变性有帮助吗？

由于每个**头递归**调用都被推送到堆栈上，然后在函数退出时被求值，因此实际上没有变量的突变，只有函数调用。但是这可能会导致堆栈溢出，例如，如果我们要得到一个大数的阶乘，那么一般来说，编写**尾递归**函数是一个更好的主意。正如我之前提到的，在 Scala 中，它们实际上被自动优化为 while 循环，所以从技术上来说，尾部递归并不是一个完全不可变的解决方案。

所以这实际上取决于你个人的选择——递归还是循环。我对 Scala 的内部优化很有信心，所以我选择了尾部递归解决方案。除了 Scala 信心部分，我发现它们更有趣，通常与代码库的其余部分更一致，看起来更简洁，而且我也不必担心在让我自己的循环工作时可能引入的错误(比如减 1 左右)。

# 现实生活

你当然可以写一个小阶乘函数或者列出一些目录，但是在现实生活和实际代码中，哪里可能用到递归呢？

当我开始函数式编程之旅时，这个问题困扰了我很多。我是一个非常注重实践的工程师，所以当我看到 Scala 书籍谈论 map、flatmap、fold 等等，却没有提到那些我被告知必须掌握的递归函数时，我持怀疑态度。我只是不明白如何在真正的编程中应用递归，真正的问题。

原来有两件事没人告诉我:

*   大多数时候，你实际上使用变换/聚合方法，如 map、flatMap、foldLeft、foldRight、reduce、filter 等。与其绞尽脑汁想出递归，不如看看这个阶乘函数的线性实现，使用`foldLeft`(顺便说一下，它是作为尾部递归实现的):

`def factorial(i: Int) = (1 to i).toList.foldLeft(1)(_ * _)`

…或者`reduce`:

`def factorial(i: Int) = (1 to i).toList.reduce(_ * _)`

*   实际上，对于非常定制的问题，你将需要递归——在工作中，我实际上不得不为包含递归数据结构的嵌套 Json 编写许多递归函数——没有现成的现成解决方案，就像上面列表中的`foldLeft`。

我想强调的是，一旦你实现了一个递归函数，就要为它编写测试——不管这个解决方案看起来有多可靠。我总是测试快乐的路径，中庸的路径，还有“这永远不会发生”的路径。随着强大的能力而来的是巨大的责任，没有什么比生产中经过良好测试(尤其是递归)的代码更能让你晚上睡得安稳。

# 摘要

总而言之，我想强调编写递归函数的两条经验法则:

*   先写你的退出条件，再写别的(这里:`if n <= 1`)
*   确保在递归调用中向退出条件移动(这里:将`n - 1`传递给递归调用——每一步都向`1`移动)

但是请记住——就像一个聪明的女人曾经说过的:

> 有人在练习递归的地方，堆栈就会溢出，函数永远不会退出。

我去过那里，很多程序员也去过。一开始很难正确理解递归。但是我保证，如果你致力于递归地解决 30 个问题，你将开始看到一种新的思维方式的出现。

递归是函数式编程旅程中非常有用的工具。取决于你在做什么，你可能不会每天都用它…甚至可能不会每月都用。但是，时不时地，你会遇到一个定制的问题，这个问题需要递归地解决——这时你所有的练习都会得到回报。

参考资料:
*Scala 中的函数式编程:A. Alexander 的简化版*
和 A. Alexander 的 Scala 食谱