<html>
<head>
<title>Introduction to Reactive Programming with RxJS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">RxJS反应式编程简介</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/introduction-to-reactive-programming-with-rxjs-114fa5e57eb1?source=collection_archive---------10-----------------------#2020-01-26">https://levelup.gitconnected.com/introduction-to-reactive-programming-with-rxjs-114fa5e57eb1?source=collection_archive---------10-----------------------#2020-01-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/096f8325eb05238b1721d915bfa2935d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_cYyV2eWOeeBl6Ob"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@iyolanda?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Yolanda Sun </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="ca10" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">RxJS是一个反应式编程库，允许我们实现观察者模式。这种模式使我们能够观察程序中的变化，并相应地运行代码。可观测量是当它识别变化时发出值的实体。观察器是接收观察器发送的数据的实体。</p><p id="07ae" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将快速了解如何创建新的可观察对象，以便向观察者发送新的值。</p><h1 id="d4de" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">RxJS的组件</h1><p id="91e1" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">RxJS有几个部分。它们是:</p><ul class=""><li id="bf0c" class="mh mi it ki b kj kk kn ko kr mj kv mk kz ml ld mm mn mo mp bi translated">observables——获取变更并将其发送给观察者的实体。</li><li id="924b" class="mh mi it ki b kj mq kn mr kr ms kv mt kz mu ld mm mn mo mp bi translated">观察者——观察从可观察对象推送的新数据的实体。</li><li id="f7eb" class="mh mi it ki b kj mq kn mr kr ms kv mt kz mu ld mm mn mo mp bi translated">操作符——通过使用类似于<code class="fe mv mw mx my b">map</code>、<code class="fe mv mw mx my b">filter</code>、<code class="fe mv mw mx my b">concat</code>、<code class="fe mv mw mx my b">reduce</code>等操作来处理集合的函数。</li><li id="91e5" class="mh mi it ki b kj mq kn mr kr ms kv mt kz mu ld mm mn mo mp bi translated">主题—向多个观察者广播数据的事件发射器</li><li id="db4e" class="mh mi it ki b kj mq kn mr kr ms kv mt kz mu ld mm mn mo mp bi translated">调度程序—控制并发性的集中式调度程序。当计算发生时，它们让我们协调。</li></ul><h1 id="75ee" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">创造可观的</h1><p id="7994" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们需要可观测的东西来向观察者发送数据。有了RxJS，我们有了一个<code class="fe mv mw mx my b">Observable</code>构造函数，让我们可以向订阅者发出数据。</p><p id="a44a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="mz na nb nc gt nd my ne nf aw ng bi"><span id="f619" class="nh lf it my b gy ni nj l nk nl">const observable = new Rx.Observable(subscriber =&gt; {<br/>  subscriber.next(1);<br/>  subscriber.next(2);<br/>  setTimeout(() =&gt; {<br/>    subscriber.next(3);<br/>    subscriber.complete();<br/>  }, 1000);<br/>});</span></pre><p id="bb57" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的<code class="fe mv mw mx my b">observable</code>会随着订户立即发出1，2，1秒后发出3。<code class="fe mv mw mx my b">subscriber</code>是我们用来向观察者发送数据的订阅者。</p><p id="9c5c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mv mw mx my b">complete</code>阻止被观察方使用订阅方发出更多数据。</p><p id="1fb6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以使用<code class="fe mv mw mx my b">observable</code>获得如下发射值:</p><pre class="mz na nb nc gt nd my ne nf aw ng bi"><span id="c4f2" class="nh lf it my b gy ni nj l nk nl">observable.subscribe(val =&gt; console.log(val));</span></pre><p id="38c7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，我们可以将一个对象传递给<code class="fe mv mw mx my b">subscribe</code>方法，用<code class="fe mv mw mx my b">next</code>方法获取发出的值，<code class="fe mv mw mx my b">error</code>方法获取错误，用<code class="fe mv mw mx my b">complete </code>方法在可观察对象发送完数据后运行一些东西:</p><pre class="mz na nb nc gt nd my ne nf aw ng bi"><span id="1eda" class="nh lf it my b gy ni nj l nk nl">observable.subscribe({<br/>  next(x) {<br/>    console.log(x);<br/>  },<br/>  error(err) {<br/>    console.error(err);<br/>  },<br/>  complete() {<br/>    console.log("done");<br/>  }<br/>});</span></pre><h1 id="d441" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">拉与推</h1><p id="94aa" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">可观察对象是推送系统，数据从一个数据源发送到观察者。</p><p id="584a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它是多重价值的生产者。只有当观察者获得新值时，才进行评估。</p><h1 id="be98" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">可观测量就像函数一样</h1><p id="1292" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">观察值与函数相似，都返回其他实体的数据。我们可以在任何我们希望的地方使用返回的数据。</p><p id="a6ab" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有以下函数:</p><pre class="mz na nb nc gt nd my ne nf aw ng bi"><span id="9fd4" class="nh lf it my b gy ni nj l nk nl">const foo = () =&gt; 1</span></pre><p id="8607" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">和一个可观察的:</p><pre class="mz na nb nc gt nd my ne nf aw ng bi"><span id="6fca" class="nh lf it my b gy ni nj l nk nl">const foo = new Observable(subscriber =&gt; {  <br/>  subscriber.next(1);<br/>});<br/> <br/>foo.subscribe(x =&gt; {<br/>  console.log(x);<br/>});</span></pre><p id="712c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么它们都给我们值1。除了我们之前看到的，我们还可以用可观测值得到多个值，这是函数做不到的。</p><p id="2108" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，它们可以是同步或异步的函数。从第一个例子，我们有:</p><pre class="mz na nb nc gt nd my ne nf aw ng bi"><span id="b7d7" class="nh lf it my b gy ni nj l nk nl">subscriber.next(1);<br/>subscriber.next(2);</span></pre><p id="af18" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">逐行运行，同时:</p><pre class="mz na nb nc gt nd my ne nf aw ng bi"><span id="7799" class="nh lf it my b gy ni nj l nk nl">setTimeout(() =&gt; {<br/>  subscriber.next(3);<br/>  subscriber.complete();<br/>}, 1000);</span></pre><p id="aaac" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">运行前等待1秒，这意味着它是异步的。</p><figure class="mz na nb nc gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nm"><img src="../Images/cc2f335d60044f1e947e3a7444aeea3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2mZvq0HgFB2TRTuD"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@thepootphotographer?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">🇸🇮·扬科·菲利- @specialdaddy </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="37ec" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">可观察的部分</h1><p id="46dc" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">Observables是用<code class="fe mv mw mx my b">Obseravable</code>构造函数创建的，我们可以用observer订阅它。</p><p id="8795" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它向观察者发送<code class="fe mv mw mx my b">next</code>、<code class="fe mv mw mx my b">error</code>或<code class="fe mv mw mx my b">complete</code>通知。可观的东西一旦收到就会自动处理掉。</p><h2 id="ee2f" class="nh lf it bd lg nn no dn lk np nq dp lo kr nr ns ls kv nt nu lw kz nv nw ma nx bi translated">创造一个可观察的</h2><p id="212a" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mv mw mx my b">Obserable</code>构造函数接受一个带有<code class="fe mv mw mx my b">subscriber</code>参数的回调函数，该函数让我们的订户对象发出值。</p><p id="03ee" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="mz na nb nc gt nd my ne nf aw ng bi"><span id="de01" class="nh lf it my b gy ni nj l nk nl">const observable = new Observable((subscriber) =&gt; {<br/>  const id = setInterval(() =&gt; {<br/>    subscriber.next("foo");<br/>  }, 1000);<br/>});</span></pre><p id="aa27" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">每秒钟向观察者发出<code class="fe mv mw mx my b">'foo'</code>。</p><h2 id="2bd8" class="nh lf it bd lg nn no dn lk np nq dp lo kr nr ns ls kv nt nu lw kz nv nw ma nx bi translated">订阅Observables</h2><p id="c51c" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们调用可观察对象的<code class="fe mv mw mx my b">subscribe</code>方法来订阅它推送的值。例如，我们可以写:</p><pre class="mz na nb nc gt nd my ne nf aw ng bi"><span id="4ace" class="nh lf it my b gy ni nj l nk nl">observable.subscribe(x =&gt; console.log(x));</span></pre><p id="4fcd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">获取最新的值。</p><p id="ea27" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同一可观察对象的多个观察者不会共享<code class="fe mv mw mx my b">subscribe</code>呼叫。每次调用subscribe都会创建自己的观察器来观察值。</p><h2 id="3224" class="nh lf it bd lg nn no dn lk np nq dp lo kr nr ns ls kv nt nu lw kz nv nw ma nx bi translated">执行观察值</h2><p id="b644" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">代码:</p><pre class="mz na nb nc gt nd my ne nf aw ng bi"><span id="a2f9" class="nh lf it my b gy ni nj l nk nl">const observable = new Observable((subscriber) =&gt; {<br/>  //...<br/>});</span></pre><p id="96f5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">执行可观察的。它只发生在订阅的每个可观察对象上。</p><p id="6a3b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它可以提供以下价值:</p><ul class=""><li id="0920" class="mh mi it ki b kj kk kn ko kr mj kv mk kz ml ld mm mn mo mp bi translated">下一步—向观察者发送值</li><li id="7f0c" class="mh mi it ki b kj mq kn mr kr ms kv mt kz mu ld mm mn mo mp bi translated">错误—向观察者发送错误或异常</li><li id="e5b5" class="mh mi it ki b kj mq kn mr kr ms kv mt kz mu ld mm mn mo mp bi translated">完成—不发送任何内容</li></ul><p id="1eb3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Observables严格遵守可观察契约，所以一旦调用了<code class="fe mv mw mx my b">complete</code>，它就不会发送更多的数据。</p><p id="ed1f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如:</p><pre class="mz na nb nc gt nd my ne nf aw ng bi"><span id="5062" class="nh lf it my b gy ni nj l nk nl">const observable = new Observable(subscriber =&gt; {<br/>  subscriber.next(1);<br/>  subscriber.next(2);<br/>  subscriber.next(3);<br/>  subscriber.complete();<br/>  subscriber.next(4);<br/>});</span></pre><p id="19ae" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">4不会被发送到observables，因为<code class="fe mv mw mx my b">complete</code>已经被调用。</p><h2 id="f66d" class="nh lf it bd lg nn no dn lk np nq dp lo kr nr ns ls kv nt nu lw kz nv nw ma nx bi translated">处理可观察的执行</h2><p id="4677" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以调用<code class="fe mv mw mx my b">unsubscribe</code>来停止订阅可观察值。它会在被调用后停止观察更多的变化，并释放观察所需的资源。</p><p id="1016" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以返回一个<code class="fe mv mw mx my b">unsubscribe</code>函数来清理我们想要添加的代码。例如，我们可以写:</p><pre class="mz na nb nc gt nd my ne nf aw ng bi"><span id="37e1" class="nh lf it my b gy ni nj l nk nl">const observable = new Observable(function subscribe(subscriber) {<br/>  const intervalId = setInterval(() =&gt; {<br/>    subscriber.next("hi");<br/>  }, 1000);</span><span id="1036" class="nh lf it my b gy ny nj l nk nl">  return function unsubscribe() {<br/>    clearInterval(intervalId);<br/>  };<br/>});</span><span id="a91d" class="nh lf it my b gy ny nj l nk nl">const subscription = observable.subscribe(x =&gt; console.log(x));</span><span id="bd56" class="nh lf it my b gy ny nj l nk nl">setTimeout(() =&gt; {<br/>  subscription.unsubscribe();<br/>}, 3000);</span></pre><p id="00ac" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的代码有一个<code class="fe mv mw mx my b">unsubscribe</code>函数，用<code class="fe mv mw mx my b">setInterval</code>返回的ID调用<code class="fe mv mw mx my b">clearInterval</code>。然后我们调用<code class="fe mv mw mx my b">subscribe</code>来订阅我们的observable，它用<code class="fe mv mw mx my b">unsubscribe</code>方法返回一个对象。该方法在<code class="fe mv mw mx my b">setTimeout</code>回调3秒后被调用。</p><p id="b291" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用Rxjs，我们可以创建Observables来用<code class="fe mv mw mx my b">subscriber</code>对象发出值。然后我们可以订阅observables来观察值。</p><p id="6053" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还可以创建一个函数，在取消订阅时进行清理，然后当我们不想再订阅一个观察对象时调用<code class="fe mv mw mx my b">unsubscribe</code>。</p></div></div>    
</body>
</html>