<html>
<head>
<title>Old Photo Effect with CSS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用CSS的旧照片效果</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/old-photo-effect-with-css-54f5be9912b?source=collection_archive---------9-----------------------#2022-12-19">https://levelup.gitconnected.com/old-photo-effect-with-css-54f5be9912b?source=collection_archive---------9-----------------------#2022-12-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0b11" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用CSS创建老式照片的分步指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/dadc6166b40f3b7f86b8fa1fc90f11ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*4zf0at3NvWfjqTmM.png"/></div></div></figure><p id="ffb4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">本文将回顾如何只用CSS在任何图片上创建旧照片效果。不需要Photoshop或任何其他图像编辑器。所有这一切都只需要几行代码！</p><p id="3324" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将检查建立在彼此之上的三种不同的方法，通过每次迭代增加旧照片的效果，使其看起来更真实和更好。</p><p id="e22b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于本页的例子，我们将使用Filipp Romanovski 的照片。你可以在Unsplash 上找到它，还有许多其他令人惊叹的图片(由菲利普和许多其他作者拍摄)。)</p><h1 id="17b2" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">使用图像标签</h1><p id="c996" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">创建旧照片效果的最基本方法是直接将滤镜应用到<code class="fe mo mp mq mr b"><a class="ae lq" href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img" rel="noopener ugc nofollow" target="_blank">&lt;img /&gt;</a></code> <a class="ae lq" href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img" rel="noopener ugc nofollow" target="_blank">标签</a>中的图像。这种方法很快，效果会很好，但是结果可能太基础了。</p><p id="6bfd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们从HTML中的一个图像开始:</p><pre class="kj kk kl km gt ms mr mt bn mu mv bi"><span id="88e0" class="mw ls it mr b be mx my l mz na">&lt;img src="link-to-your-image.jpg" alt="Description of the image" /&gt;</span></pre><p id="62d4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后我们将在CSS 中应用一些<a class="ae lq" href="https://developer.mozilla.org/en-US/docs/Web/CSS/filter" rel="noopener ugc nofollow" target="_blank">滤镜和一个简单的</a><a class="ae lq" href="https://developer.mozilla.org/en-US/docs/Web/CSS/mask" rel="noopener ugc nofollow" target="_blank">蒙版</a>:</p><pre class="kj kk kl km gt ms mr mt bn mu mv bi"><span id="5eed" class="mw ls it mr b be mx my l mz na">img {<br/>  filter: grayscale(1) blur(1px) contrast(1.2) sepia(1);<br/>  -webkit-mask: radial-gradient(#000, #0009);<br/>}</span></pre><p id="9112" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们一个接一个地看看每个过滤器的作用:</p><ul class=""><li id="ea86" class="nb nc it kw b kx ky la lb ld nd lh ne ll nf lp ng nh ni nj bi translated"><code class="fe mo mp mq mr b">grayscale(1)</code>:将图片变成灰度。这会将一些区域混合成相似的灰色调，使图片失去一些细节。</li><li id="3993" class="nb nc it kw b kx nk la nl ld nm lh nn ll no lp ng nh ni nj bi translated"><code class="fe mo mp mq mr b">blur(1px)</code>:对图像应用高斯模糊。足以组合色彩区域，让画面失去更多细节。</li><li id="2374" class="nb nc it kw b kx nk la nl ld nm lh nn ll no lp ng nh ni nj bi translated"><code class="fe mo mp mq mr b">contrast(1.2)</code>:锐化图像。我们可以稍微调整一下这个值，使它符合我们的需要，并对每张图片进行个性化设置。但要注意:太高或太低，看起来都会很怪异。</li><li id="1dbd" class="nb nc it kw b kx nk la nl ld nm lh nn ll no lp ng nh ni nj bi translated"><code class="fe mo mp mq mr b">sepia(1)</code>:将颜色变为老照片的棕褐色。</li></ul><p id="42af" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">此外，我们可以添加一个额外的<code class="fe mo mp mq mr b">blur(0.5px)</code>(它不必是一个整数或大于1)，使照片有点模糊，并完成过滤效果。但是不需要。</p><p id="1205" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe mo mp mq mr b">-webkit-mask</code>多了一行。老照片看起来更集中在中心，但之后它们会退化，失去颜色，边缘变得有点模糊。我们可以通过在CSS中应用遮罩来实现这一点。<a class="ae lq" href="https://caniuse.com/?search=mask" rel="noopener ugc nofollow" target="_blank">遗憾的是，</a> <code class="fe mo mp mq mr b"><a class="ae lq" href="https://caniuse.com/?search=mask" rel="noopener ugc nofollow" target="_blank">mask</a></code> <a class="ae lq" href="https://caniuse.com/?search=mask" rel="noopener ugc nofollow" target="_blank">并非所有浏览器都支持</a>...幸运的是，供应商前缀是！所以我们可以使用<code class="fe mo mp mq mr b">-webkit-mask</code>来应用同样的效果。</p><p id="0cc3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用<code class="fe mo mp mq mr b">-webkit-mask: radial-gradient(#000, #0009)</code>，我们告诉浏览器使图像的边缘半透明(通过在中心使用一个完全可见的椭圆，向外渐变)，因此图片将渐变并与背景融合。请注意，这可能会有不同的结果，取决于背景的颜色！</p><p id="10cb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们应用这四行CSS后，就达到了老照片的效果。以下是原始照片和最终照片的对比:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/1a4793d81b65bba71f4eb07b42d207bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*GF1iXlgTb-joWohB.jpg"/></div></div></figure><p id="80d5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">不错，但是我们可以更进一步。</p><h1 id="60db" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">添加伪元素</h1><p id="6c3b" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">使用单个<code class="fe mo mp mq mr b">&lt;img /&gt;</code>标签的一个问题是，图像没有像<code class="fe mo mp mq mr b"><a class="ae lq" href="https://developer.mozilla.org/en-US/docs/Web/CSS/::before" rel="noopener ugc nofollow" target="_blank">::before</a></code>或<code class="fe mo mp mq mr b"><a class="ae lq" href="https://developer.mozilla.org/en-US/docs/Web/CSS/::after" rel="noopener ugc nofollow" target="_blank">::after</a></code>这样的伪元素，这限制了我们可以应用到元素上的效果。如果我们不使用<code class="fe mo mp mq mr b">&lt;img /&gt;</code>而是使用<code class="fe mo mp mq mr b">&lt;div&gt;</code>并添加图像作为背景，我们可以对其伪元素应用滤镜和遮罩，并获得更精确的效果。</p><p id="0ead" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">获得与<code class="fe mo mp mq mr b">&lt;img /&gt;</code>标签相似的结果很简单。HTML应该是这样的:</p><pre class="kj kk kl km gt ms mr mt bn mu mv bi"><span id="d851" class="mw ls it mr b be mx my l mz na">&lt;div class="old-style-photo demo-image"&gt;&lt;/div&gt;</span></pre><p id="62d6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，在CSS中，我们将使用元素来显示旧式照片，就像上一节中一样。唯一的区别是，我们还需要设置图像的大小和背景:</p><pre class="kj kk kl km gt ms mr mt bn mu mv bi"><span id="058f" class="mw ls it mr b be mx my l mz na">/* specific to the demo image */<br/>.demo-image {<br/>  width: 45vw;<br/>  aspect-ratio: 3/4;<br/>  background: url(link-to-image.jpg);<br/>  background-size: cover;<br/>}<br/><br/>/* needed for the pseudo-elements and old-photo effect */<br/>.old-style-photo {<br/>  position: relative;<br/>  filter: grayscale(1) blur(1px) contrast(1.2) sepia(1) blur(0.25px);<br/>  -webkit-mask: radial-gradient(#000, #000a);<br/>}</span></pre><p id="a6fc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">就这样，我们得到了与上一节相同的效果。我们将使用<code class="fe mo mp mq mr b">::before</code>伪元素来模糊图像的边缘。老照片中常见的东西。为了实现这一点，我们将再次使用一个面具。另一个从中心到边缘的径向渐变，但这一次将是相反的方向:在中心隐藏，在末端可见。这样，我们可以在图像本身上应用一个<code class="fe mo mp mq mr b"><a class="ae lq" href="https://developer.mozilla.org/en-US/docs/Web/CSS/backdrop-filter" rel="noopener ugc nofollow" target="_blank">backdrop-filter</a></code> <a class="ae lq" href="https://developer.mozilla.org/en-US/docs/Web/CSS/backdrop-filter" rel="noopener ugc nofollow" target="_blank">效果</a>。</p><p id="6cca" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用<code class="fe mo mp mq mr b">backdrop-filter</code>，我们可以对元素后面的区域应用滤镜。因为中心是用蒙版裁剪的，所以滤镜不会应用于图像的中心，而只会应用于可见区域和蒙版的可见程度。例如，如果我们应用一个<code class="fe mo mp mq mr b">blur()</code>背景滤镜，它在完全可见的边缘会比在部分可见的中间部分更模糊。</p><pre class="kj kk kl km gt ms mr mt bn mu mv bi"><span id="76bc" class="mw ls it mr b be mx my l mz na">.old-style-photo::before {<br/>  content: "";<br/>  position: absolute;<br/>  width: 100%;<br/>  height: 100%;<br/>  -webkit-mask: radial-gradient(farthest-side, #0000 30%, #000);<br/>  backdrop-filter: blur(5px) sepia(90%);<br/>}</span></pre><p id="fe54" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">生成的图像边缘更模糊，加上我们在混合中添加了更多的棕褐色(因此颜色组合得更多):</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/3455202c080c380db0d3093c61a809f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*EPjk4ClwAQbBKTk0.jpg"/></div></div></figure><h1 id="df1e" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">混合内嵌SVG</h1><p id="7db0" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">有些人会叫屈，说这“不是一个纯粹的CSS解决方案”(我从未声称它是)，并认为这一节作弊。相反，我们将称之为“<em class="nq">利用CSS提供的所有特性</em>”，并在我们的书中称之为胜利。</p><p id="a6e8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">是的，这是真的。这最后一步将包括一些SVG。现实情况是CSS有过滤器，但是它们不像SVG中的过滤器那样多样或先进。幸运的是，我们可以以一种相对简单的方式将这两种技术结合起来。</p><p id="e9e0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一种选择是在HTML中有一些内联SVG，并从我们的CSS中引用它。我们将使用的另一个选项是在CSS中直接内联SVG(不在HTML端添加任何东西)。)这可以通过添加SVG作为背景，使用<code class="fe mo mp mq mr b"><a class="ae lq" href="https://developer.mozilla.org/en-US/docs/Web/CSS/url" rel="noopener ugc nofollow" target="_blank">url()</a></code> <a class="ae lq" href="https://developer.mozilla.org/en-US/docs/Web/CSS/url" rel="noopener ugc nofollow" target="_blank">功能</a>结合<a class="ae lq" href="https://css-tricks.com/data-uris/" rel="noopener ugc nofollow" target="_blank">数据URIs </a>来实现:</p><pre class="kj kk kl km gt ms mr mt bn mu mv bi"><span id="2582" class="mw ls it mr b be mx my l mz na">data:[&lt;mime type&gt;][;charset=&lt;charset&gt;][;base64],&lt;encoded data&gt;</span></pre><p id="f26d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我们的例子中，我们甚至不需要进行base64编码。这是一个简单的SVG，我们可以将它作为文本放在数据URI中:</p><pre class="kj kk kl km gt ms mr mt bn mu mv bi"><span id="00f1" class="mw ls it mr b be mx my l mz na">&lt;svg xmlns='http://www.w3.org/2000/svg' width='100' height='100'&gt;<br/>  &lt;filter id='noise' x='0%' y='0%' width='100%' height='100%'&gt;<br/>    &lt;feTurbulence baseFrequency='0.5' /&gt;<br/>  &lt;/filter&gt;<br/>  &lt;rect x='0' y='0' width='100%' height='100%' filter='url(#noise)' /&gt;<br/>&lt;/svg&gt;</span></pre><p id="75c3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们唯一需要小心的是滤波器中的<code class="fe mo mp mq mr b">#</code>。它需要进行URL编码，并用一个<code class="fe mo mp mq mr b">%23</code>替换。然后我们将属性应用于<code class="fe mo mp mq mr b">::after</code>伪元素:</p><pre class="kj kk kl km gt ms mr mt bn mu mv bi"><span id="2e50" class="mw ls it mr b be mx my l mz na">.old-style-photo::after {<br/>  content: "";<br/>  position: absolute;<br/>  width: 100%;<br/>  height: 100%;<br/>  opacity: 0.6;<br/>  background:<br/>    url("data:image/svg+xml;utf8,&lt;svg xmlns='http://www.w3.org/2000/svg' width='100' height='100'&gt;&lt;filter id='noise' x='0%' y='0%' width='100%' height='100%'&gt;&lt;feTurbulence baseFrequency='0.5' /&gt;&lt;/filter&gt;&lt;rect x='0' y='0' width='100%' height='100%' filter='url(%23noise)' /&gt;&lt;/svg&gt;"), #f003;<br/>  filter: grayscale(100%) contrast(150%);<br/>  mix-blend-mode: darken;<br/>}</span></pre><p id="f0bf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">噪波本身有不同的颜色，但现在它将是单色的，因为我们对父元素应用了一些颜色过滤器，这也会影响伪元素。不过，我们可以应用额外的过滤器(不需要)和混合模式，以更好地与原始图片混合。我强烈推荐使用<a class="ae lq" href="https://developer.mozilla.org/en-US/docs/Web/CSS/mix-blend-mode" rel="noopener ugc nofollow" target="_blank"/><code class="fe mo mp mq mr b"><a class="ae lq" href="https://developer.mozilla.org/en-US/docs/Web/CSS/mix-blend-mode" rel="noopener ugc nofollow" target="_blank">mix-blend-mode</a></code>:<code class="fe mo mp mq mr b">darken</code>和<code class="fe mo mp mq mr b">multiply</code>的不同值来产生我们想要的效果(但也可以随意尝试其他值。)</p><p id="983e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">结果是和以前一样的图像，但是我们有一个颗粒/噪声效果，增加了旧照片图像的真实感:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/9aa23758bffc0ce452a5b7c3bb981e1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*wSTjQzwfqIYsMg7C.jpg"/></div></div></figure><h1 id="e5ba" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">结论</h1><p id="74c4" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">在本文中，我们看到了如何一步一步地创建一个旧照片效果，只使用CSS(和一个小的内联SVG)而不求助于外部文件。所有代码都是独立的，可以在我们希望达到的级别上应用:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/71a9030ceec2b573c7a9cd7d6f19f73c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*3FCVRheLa_oma4gX.jpg"/></div></div></figure><p id="777a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">更改滤镜和蒙版中的值将生成完全不同的图像。请随意下载代码并在本地试用，或者在CodePen 上玩这个演示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr ns l"/></div></figure><h1 id="fd33" class="lr ls it bd lt lu lv lw lx ly lz ma mb jz mc ka md kc me kd mf kf mg kg mh mi bi translated">更多示例</h1><p id="20ae" class="pw-post-body-paragraph ku kv it kw b kx mj ju kz la mk jx lc ld ml lf lg lh mm lj lk ll mn ln lo lp im bi translated">为了表明这种效果实际上在一般情况下有效，而不仅仅是演示图像特有的效果，我将它应用于另外几张图片(<a class="ae lq" href="https://unsplash.com/@filipp_roman_photography" rel="noopener ugc nofollow" target="_blank">全部由Filipp Romanovski在Unsplash </a>上原创):</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/ab0630cf98d937c201187a6a0c0649b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*xogcbPhcJ61-Kpy9.jpg"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/fc956bc2cd1267a369e42efed3084a62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*AfhQJtwZZ8FtAHqv.jpg"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/e41e9edede82490e3a8d92f8dbfc482b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*f49h5scDhMI5seze.jpg"/></div></div></figure><p id="8455" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以改变径向渐变的中心来聚焦于我们认为更重要的区域。例如，在这张照片中，渐变的中心更靠近脸部:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/364e9781d5837081cd3a05b49bc95c73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*bFMu_p4WJ0FZem-S.jpg"/></div></div></figure><p id="f27d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我喜欢用人物的照片来达到这种效果，但是没有人也可以。如果照片的主题是旧时代的物品，那就更好了:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/34a20ba58ae039d6131de8d879262ddc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*W73JYA0QqUT7JkNm.jpg"/></div></div></figure></div></div>    
</body>
</html>