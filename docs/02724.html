<html>
<head>
<title>Learning C++: The STL and Iterators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习c++:STL和迭代器</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/learning-c-the-stl-and-iterators-219abd83d786?source=collection_archive---------12-----------------------#2020-03-31">https://levelup.gitconnected.com/learning-c-the-stl-and-iterators-219abd83d786?source=collection_archive---------12-----------------------#2020-03-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/2766732a9efbbba43030f26cd916ca6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*O1v1fiQyOMlijPbH"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@cjred?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> CJ Dayrit </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="655e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">理解如何使用C++的标准模板库(STL)容器的关键之一是理解迭代器是如何工作的。在本文中，我将展示迭代器如何在高层工作(range <code class="fe le lf lg lh b">for</code>循环),然后如何更直接地使用它们来管理STL容器的移动。</p><h1 id="a9f7" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">迭代器和循环的范围</h1><p id="9777" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">大多数编程专家现在建议，当您考虑程序的数据存储时，您应该选择使用灵活的容器，如vector，而不是更不灵活的容器，如内置数组(如果您真的需要数组，STL的<code class="fe le lf lg lh b">array</code>类是更好的选择)。</p><p id="1dcf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，这些专家现在建议，当您访问容器的所有元素时，应该在索引循环上使用for-each-type循环，以便最大限度地减少代码中出现数组边界错误的可能性。在C++中，这种类型的循环是range for loop，自C++11发布以来就可以使用。</p><p id="e273" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">范围<code class="fe le lf lg lh b">for </code>循环的语法模板如下所示:</p><p id="d487" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="ml"> for(数据类型元素:容器){<br/>body；<br/> } </em></p><p id="a798" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们看看这在实践中是如何工作的。以下程序创建一个简单的数字向量，并使用range <code class="fe le lf lg lh b">for</code>循环显示向量中的每个数字:</p><pre class="mm mn mo mp gt mq lh mr ms aw mt bi"><span id="396c" class="mu lj it lh b gy mv mw l mx my">#include &lt;iostream&gt;<br/>#include &lt;vector&gt;<br/>using namespace std;</span><span id="57c3" class="mu lj it lh b gy mz mw l mx my">int main()<br/>{<br/>  vector&lt;int&gt; numbers{1,2,3,4,5};<br/>  for (int number : numbers) {<br/>    cout &lt;&lt; number &lt;&lt; " "; // displays 1 2 3 4 5<br/>  }<br/>  return 0;<br/>}</span></pre><p id="2808" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">range for循环的工作方式是创建一个指向向量的第一个元素的迭代器，然后依次访问向量的每个元素，直到迭代器到达向量的最后一个元素，然后循环终止。</p><p id="616c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有了这个背景，我们就可以了解如何使用迭代器直接访问容器的元素了。</p><h1 id="bb97" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">直接使用迭代器</h1><p id="7d77" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">范围<code class="fe le lf lg lh b">for</code>循环是迭代器的间接使用，因为迭代器是在幕后使用的。让我们看看如何使用迭代器直接遍历容器的内容。</p><p id="f360" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你可以把迭代器想象成一个指针，可以间接访问容器元素。迭代器使用以下语法声明:</p><p id="374f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="ml">容器类型&lt;数据类型&gt;::迭代器迭代器名；</em></p><p id="1cb9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面的代码片段演示了如何将迭代器声明为整数向量:</p><pre class="mm mn mo mp gt mq lh mr ms aw mt bi"><span id="52fc" class="mu lj it lh b gy mv mw l mx my">vector&lt;int&gt;::iterator iter;</span></pre><p id="1ccd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦迭代器被声明，它必须被初始化。STL容器有这样的功能。如果我们想创建一个标准的迭代器从容器的开头移动到结尾，这个函数就叫做<code class="fe le lf lg lh b">begin</code>。下面是它的使用方法:</p><pre class="mm mn mo mp gt mq lh mr ms aw mt bi"><span id="8674" class="mu lj it lh b gy mv mw l mx my">vector&lt;int&gt; numbers{1,2,3,4,5};<br/>vector&lt;int&gt;::iterator iter;<br/>iter = numbers.begin();</span></pre><p id="31d1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为迭代器指定数据类型有点冗长，所以大多数程序员使用auto关键字在一条语句中声明和初始化迭代器。下面是如何做到这一点，使用上面例子中的向量:</p><pre class="mm mn mo mp gt mq lh mr ms aw mt bi"><span id="d345" class="mu lj it lh b gy mv mw l mx my">vector&lt;int&gt; numbers{1,2,3,4,5};<br/>auto iter = numbers.begin();</span></pre><p id="0979" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">迭代器<code class="fe le lf lg lh b">iter</code>现在指向向量的第一个元素。我们可以通过使用解引用操作符(<code class="fe le lf lg lh b">*</code>)解引用迭代器来访问迭代器所指向的值，如下所示:</p><pre class="mm mn mo mp gt mq lh mr ms aw mt bi"><span id="bb06" class="mu lj it lh b gy mv mw l mx my">cout &lt;&lt; "first element: " &lt;&lt; *iter; // displays first element: 1</span></pre><p id="0391" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要移动到下一个元素，可以使用increment运算符将迭代器移动到下一个元素:</p><pre class="mm mn mo mp gt mq lh mr ms aw mt bi"><span id="0caf" class="mu lj it lh b gy mv mw l mx my">iter++;<br/>cout &lt;&lt; "second element: " &lt;&lt; *iter;//displays second element: 2</span></pre><p id="673c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在您可以看到如何使用迭代器遍历容器。但是你怎么知道什么时候停止呢？STL容器还有另一个功能，<code class="fe le lf lg lh b">end</code>，表示容器的结束。如果您是容器的结尾，该函数将返回true值，否则将返回false值。</p><p id="ab9d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是如何在一个循环中使用<code class="fe le lf lg lh b">end</code>函数来遍历一个向量的所有元素:</p><pre class="mm mn mo mp gt mq lh mr ms aw mt bi"><span id="fec5" class="mu lj it lh b gy mv mw l mx my">#include &lt;iostream&gt;<br/>#include &lt;vector&gt;<br/>using namespace std;</span><span id="8ed5" class="mu lj it lh b gy mz mw l mx my">int main()<br/>{<br/>  vector&lt;int&gt; numbers{1,2,3,4,5};<br/>  auto iter = numbers.begin();<br/>  while (iter != numbers.end()) {<br/>    cout &lt;&lt; *iter &lt;&lt; " "; // displays 1 2 3 4 5<br/>    iter++;<br/>  }<br/>  return 0;<br/>}</span></pre><h1 id="4d74" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">在容器上向后移动</h1><p id="3597" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">上面的例子演示了如何使用前向迭代器向前移动。还可以使用反向迭代器从容器的最后一个元素向后移动到容器的第一个元素。</p><p id="407d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">创建反向迭代器的函数是<code class="fe le lf lg lh b">rbegin</code>。决定你是否在一个容器的开头的函数是<code class="fe le lf lg lh b">rend</code>。下面是一个使用它们在向量上向后移动的示例:</p><pre class="mm mn mo mp gt mq lh mr ms aw mt bi"><span id="b3f7" class="mu lj it lh b gy mv mw l mx my">#include &lt;iostream&gt;<br/>#include &lt;vector&gt;<br/>using namespace std;</span><span id="391e" class="mu lj it lh b gy mz mw l mx my">int main()<br/>{<br/>  vector&lt;int&gt; numbers{1,2,3,4,5};<br/>  auto iter = numbers.rbegin();<br/>  while (iter != numbers.rend()) {<br/>    cout &lt;&lt; *iter &lt;&lt; " "; // displays 5 4 3 2 1<br/>    iter++;<br/>  }<br/>  return 0;<br/>}</span></pre><h1 id="87e0" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">使用带有迭代器的for循环</h1><p id="a095" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">我上面给出的例子使用了一个<code class="fe le lf lg lh b">while</code>循环来遍历向量，但是没有理由不能使用一个<code class="fe le lf lg lh b">for </code>循环，for循环甚至可能是迭代器的首选方法。下面是上面用<code class="fe le lf lg lh b">for</code>循环改写的两个例子:</p><pre class="mm mn mo mp gt mq lh mr ms aw mt bi"><span id="e5f0" class="mu lj it lh b gy mv mw l mx my">#include &lt;iostream&gt;<br/>#include &lt;vector&gt;<br/>using namespace std;</span><span id="66df" class="mu lj it lh b gy mz mw l mx my">// forward iterator<br/>int main()<br/>{<br/>  vector&lt;int&gt; numbers{1,2,3,4,5};<br/>  for (auto iter = numbers.begin(); iter != numbers.end();<br/>       iter++) {<br/>    cout &lt;&lt; *iter &lt;&lt; " "; // displays 1 2 3 4 5<br/>  }<br/>  return 0;<br/>}</span><span id="881e" class="mu lj it lh b gy mz mw l mx my">#include &lt;iostream&gt;<br/>#include &lt;vector&gt;<br/>using namespace std;</span><span id="4acf" class="mu lj it lh b gy mz mw l mx my">// reverse iterator<br/>int main()<br/>{<br/>  vector&lt;int&gt; numbers{1,2,3,4,5};<br/>  for (auto iter = numbers.rbegin(); iter != numbers.rend();<br/>       iter++) {<br/>    cout &lt;&lt; *iter &lt;&lt; " "; // displays 5 4 3 2 1<br/>  }<br/>  return 0;<br/>}</span></pre><h1 id="d35d" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">杂项迭代器技术</h1><p id="370b" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">在上面的例子中，我总是将迭代器递增1，但是没有理由你不能递增你想要的任何值。以下示例通过将迭代器递增2来显示随机生成的数字向量的每隔一个元素:</p><pre class="mm mn mo mp gt mq lh mr ms aw mt bi"><span id="7d4b" class="mu lj it lh b gy mv mw l mx my">#include &lt;iostream&gt;<br/>#include &lt;vector&gt;<br/>#include &lt;cstdlib&gt;<br/>#include &lt;ctime&gt;</span><span id="c319" class="mu lj it lh b gy mz mw l mx my">using namespace std;</span><span id="cd76" class="mu lj it lh b gy mz mw l mx my">int main()<br/>{<br/>  vector&lt;int&gt; numbers;<br/>  srand(time(0));<br/>  for (int i = 1; i &lt;= 20; i++) {<br/>    numbers.push_back(rand() % 100 + 1);<br/>  }<br/>  for (auto iter = numbers.begin(); iter != numbers.end();<br/>       iter += 2) {<br/>    cout &lt;&lt; *iter &lt;&lt; " ";<br/>  }<br/>  return 0;<br/>}</span></pre><p id="4143" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一种写法是使用<code class="fe le lf lg lh b">advance</code>函数。这个函数接受当前迭代器和一个数字，并将迭代器推进到容器中的许多位置。下面的代码片段演示了<code class="fe le lf lg lh b">advance</code>函数是如何工作的:</p><pre class="mm mn mo mp gt mq lh mr ms aw mt bi"><span id="92a5" class="mu lj it lh b gy mv mw l mx my">vector&lt;int&gt; numbers {1,2,3,4,5};<br/>auto iter = numbers.begin();<br/>advance(iter, 2);<br/>cout &lt;&lt; *iter; // displays 3</span></pre><p id="c71c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">next函数将迭代器返回到容器中当前迭代器位置之后的下一个位置。这里有一个例子:</p><pre class="mm mn mo mp gt mq lh mr ms aw mt bi"><span id="54ca" class="mu lj it lh b gy mv mw l mx my">vector&lt;int&gt; numbers {1,2,3,4,5};<br/>auto iter = numbers.begin();<br/>auto next_iter = next(iter);<br/>cout &lt;&lt; *next_iter; // displays 2<br/></span></pre><p id="fac3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后一个例子与其说是迭代器技术，不如说是迭代器的一种用法。STL算法<code class="fe le lf lg lh b">sort</code>使用迭代器来决定将容器的哪一部分排序。例如，如果你想对整个容器进行排序，你可以使用<code class="fe le lf lg lh b">begin</code>和<code class="fe le lf lg lh b">end </code>函数来指定整个容器。这里有一个关于<code class="fe le lf lg lh b">sort</code>功能如何工作的例子:</p><pre class="mm mn mo mp gt mq lh mr ms aw mt bi"><span id="8e08" class="mu lj it lh b gy mv mw l mx my">#include &lt;iostream&gt;<br/>#include &lt;vector&gt;<br/>#include &lt;cstdlib&gt;<br/>#include &lt;ctime&gt;<br/>#include &lt;algorithm&gt;</span><span id="f9ac" class="mu lj it lh b gy mz mw l mx my">using namespace std;</span><span id="accb" class="mu lj it lh b gy mz mw l mx my">int main()<br/>{<br/>  vector&lt;int&gt; numbers;<br/>  srand(time(0));<br/>  for (int i = 1; i &lt; 20; i++) {<br/>    numbers.push_back(rand() % 100 + 1);<br/>  }<br/>  for (int num : numbers) {<br/>    cout &lt;&lt; num &lt;&lt; " ";<br/>  }<br/>  sort(numbers.begin(), numbers.end());<br/>  cout &lt;&lt; endl;<br/>  for (int num : numbers) {<br/>    cout &lt;&lt; num &lt;&lt; " ";<br/>  }<br/>  return 0;<br/>}</span></pre><p id="6872" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个程序运行一次的输出是:</p><pre class="mm mn mo mp gt mq lh mr ms aw mt bi"><span id="ade7" class="mu lj it lh b gy mv mw l mx my">62 35 56 62 7 74 8 46 4 53 1 26 7 94 27 64 31 63 100<br/>1 4 7 7 8 26 27 31 35 46 53 56 62 62 63 64 74 94 100</span></pre><h1 id="1589" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">迭代器的重要性</h1><p id="9c53" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">排序函数并不是STL中唯一需要使用迭代器的函数。迭代器是所有STL容器的核心，如果你想充分利用STL容器，你需要熟悉迭代器的工作原理和使用方法。</p><p id="ef5f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢您阅读这篇文章，请给我发电子邮件，提出您的意见和建议。</p></div></div>    
</body>
</html>