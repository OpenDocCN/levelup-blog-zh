<html>
<head>
<title>Adding state to Storybook in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在React中将状态添加到故事书</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/adding-state-to-storybook-in-react-c6744fda25b4?source=collection_archive---------1-----------------------#2019-06-29">https://levelup.gitconnected.com/adding-state-to-storybook-in-react-c6744fda25b4?source=collection_archive---------1-----------------------#2019-06-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/27ef82dd9c5526ca801bf2101d2f5a58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tvjuiochhEQ_HgW-amI15A.jpeg"/></div></div></figure><p id="7e42" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Storybook是一个不可思议的开源沙盒，用于独立开发UI组件。我目前的一个项目是一个大型的多屏表单，其中有各种<a class="ae kw" href="https://reactjs.org/docs/forms.html#controlled-components" rel="noopener ugc nofollow" target="_blank">控制的组件</a>，这些组件依赖于它们的父容器作为唯一的真实来源。我发现虽然Storybook非常适合测试单个组件的状态，但我在每个受控组件将状态传递给父容器的故事中都编写了样板代码。</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="d41c" class="lg lh iq lc b gy li lj l lk ll">/* src/stories/index.js */</span><span id="c166" class="lg lh iq lc b gy lm lj l lk ll">import React, { useState } from "react";<br/>import { storiesOf } from "@storybook/react";<br/><br/>storiesOf("Input", module).add("controlled", () =&gt; {<br/>  function Parent({ children, ...props }) {<br/>    const [state, setState] = useState();<br/>    return &lt;div&gt;{children(state, setState)}&lt;/div&gt;;<br/>  }<br/><br/>  return (<br/>    &lt;Parent&gt;<br/>      {(state, setState) =&gt; (<br/>        &lt;input<br/>          value={state.value}<br/>          onChange={e =&gt; setState({ value: e.target.value })}<br/>        /&gt;<br/>      )}<br/>    &lt;/Parent&gt;<br/>  );<br/>});</span></pre><p id="17c2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个父组件可以很容易地被抽象出来并导入到相关的故事中，但是由于每个故事实际上都是一个渲染函数，所以理想的情况是将状态变量作为参数传递，即</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="dfc7" class="lg lh iq lc b gy li lj l lk ll">/* src/stories/index.js */</span><span id="b399" class="lg lh iq lc b gy lm lj l lk ll">import React, { useState } from "react";<br/>import { storiesOf } from "@storybook/react";<br/><br/>storiesOf("Input", module).add("controlled", (state, setState) =&gt; (<br/>  &lt;input <br/>    value={state.value} <br/>    onChange={e =&gt; setState({ value: e.target.value })}<br/>  /&gt;<br/>);</span></pre><p id="75ea" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这可以通过在<em class="ln">中创建两个组件和一个定制的<a class="ae kw" href="https://storybook.js.org/docs/addons/introduction/#1-decorators" rel="noopener ugc nofollow" target="_blank">装饰器</a>来实现。storybook/config.js </em>文件。第一个组件是一个作为子组件的函数，它通过充当呈现回调来模拟第一个示例中的父组件。第二个是表示组件，它接收状态作为道具，并在每个故事下面显示当前值。定制装饰器用这些组件和状态变量来扩充每个故事，其中组件将包装故事，状态值将作为参数传递。</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="2d56" class="lg lh iq lc b gy li lj l lk ll">/* .storybook/config.js */</span><span id="5da3" class="lg lh iq lc b gy lm lj l lk ll">import React, { useState } from "react";<br/>import { configure, addDecorator } from "@storybook/react";<br/><br/>function loadStories() {<br/>  require("../src/stories/index.js");<br/>}<br/><br/>// Component 1<br/>function Stage({ children, …props }) {<br/>  const [state, setState] = useState({});<br/>  return &lt;div {…props}&gt;{children(state, setState)}&lt;/div&gt;;<br/>}<br/>  <br/>// Component 2<br/>function State({ state, …props }) {<br/>  return (<br/>    &lt;div {…props}&gt;<br/>      Parent state: &lt;pre&gt;{JSON.stringify(state)}&lt;/pre&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}<br/><br/>// Custom decorator<br/>addDecorator(story =&gt; (<br/>  &lt;Stage&gt;<br/>    {(state, setState) =&gt; (<br/>      &lt;div style={{ display: "flex", flexFlow: "column" }}&gt;<br/>       {story(state, setState)}<br/>       &lt;State state={state} /&gt;<br/>      &lt;/div&gt;<br/>    )}<br/>  &lt;/Stage&gt;<br/>));<br/><br/>configure(loadStories, module);</span></pre><p id="4975" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，每个组件都可以选择从故事本身设置和检索提升的状态值，而无需任何样板代码💥</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="6732" class="lg lh iq lc b gy li lj l lk ll">/* src/stories/index.js */</span><span id="ed1b" class="lg lh iq lc b gy lm lj l lk ll">import React from "react";<br/>import { storiesOf } from "@storybook/react";<br/><br/>storiesOf("Input", module)<br/>  // stateless<br/>  .add("uncontrolled", () =&gt; &lt;input /&gt;)<br/><br/>  // stateful<br/>  .add("controlled", (state, setState) =&gt; (<br/>    &lt;input<br/>      value={state.value}<br/>      onChange={e =&gt; setState({ value: e.target.value })}<br/>    /&gt;<br/>));</span></pre><p id="cee4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以在<a class="ae kw" href="https://github.com/phunkren/storybook-state" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到这个库，下面快速浏览一下它的运行情况:</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lo"><img src="../Images/87c31e8ab2aee1a2129d096780442d89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*EJzUcE12iOpx8JPM8stdQw.gif"/></div></div></figure></div></div>    
</body>
</html>