<html>
<head>
<title>How to concatenate more than two slices in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Go中连接两个以上的切片</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-concatenate-more-than-two-slices-in-go-1a9139848a1a?source=collection_archive---------5-----------------------#2022-11-20">https://levelup.gitconnected.com/how-to-concatenate-more-than-two-slices-in-go-1a9139848a1a?source=collection_archive---------5-----------------------#2022-11-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/76504a4ca411c93771522eacadc5874b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WBO19OZRKV5QHQ15"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@krysamon?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Krys Amon </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="345f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这篇文章中，你可以看到以下在go中连接切片的方法</p><ol class=""><li id="51ae" class="le lf it ki b kj kk kn ko kr lg kv lh kz li ld lj lk ll lm bi translated">通常采用两片拼接</li><li id="3677" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">连接两个以上切片的简单解决方案</li><li id="2786" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">连接两个以上切片的有效解决方案</li></ol><h1 id="c424" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated"><strong class="ak">一般练习两片拼接</strong></h1><pre class="mq mr ms mt gt mu mv mw bn mx my bi"><span id="08b1" class="mz lt it mv b be na nb l nc nd">package main<br/><br/>import "fmt"<br/><br/>func main() {<br/>	slice1 := []string{"apple", "banana", "peach" }<br/>	slice2 := []string{"avacado", "kiwi", "pineapple"}<br/><br/>	slice3 := append(slice1, slice2...)<br/>	fmt.Println(slice3)<br/>}</span></pre><p id="6821" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Go中的切片拼接可以使用标准库中的内置<code class="fe ne nf ng mv b"><em class="nh">append()</em></code>函数来完成。</p><p id="565e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的例子中，切片(<code class="fe ne nf ng mv b"><em class="nh">slice1</em></code>)作为第一个参数，第二个切片(<code class="fe ne nf ng mv b"><em class="nh">slice2</em></code>)中的所有元素作为第二个参数。使用<strong class="ki iu"> append() </strong>函数，当我们将这些切片作为参数传递时，它返回一个包含所有元素的更新切片。</p><p id="c13b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe ne nf ng mv b"><em class="nh">append()</em></code>中第二个参数后面的三点运算符(<code class="fe ne nf ng mv b"><em class="nh">...</em></code>是因为它是一个<a class="ae kf" href="https://en.wikipedia.org/wiki/Variadic_function" rel="noopener ugc nofollow" target="_blank"> <em class="nh">变量函数</em> </a>并且接受无限数量的参数。</p><h1 id="84fc" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated"><strong class="ak">连接两个以上切片的简单解决方案</strong></h1><p id="794b" class="pw-post-body-paragraph kg kh it ki b kj ni kl km kn nj kp kq kr nk kt ku kv nl kx ky kz nm lb lc ld im bi translated">您可以传递给append函数的切片数量(2)是有限制的，假设您发现需要追加两个以上的切片，下面是合并方法的一个版本。</p><pre class="mq mr ms mt gt mu mv mw bn mx my bi"><span id="2f54" class="mz lt it mv b be na nb l nc nd">package main<br/><br/>import "fmt"<br/><br/>func main() {<br/><br/> slices := [][]string{{"apple", "banana", "peach"},<br/>  {"orange", "grape", "mango"},<br/>  {"strawberry", "blueberry", "raspberry"}}<br/> <br/> fmt.Println(concatAppend(slices))<br/><br/>}<br/>func concatAppend(slices [][]string) []string {<br/> var tmp []string<br/> for _, s := range slices {<br/>  tmp = append(tmp, s...)<br/> }<br/> return tmp<br/>}</span></pre><p id="68e6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们在这里所做的实际上是循环遍历<strong class="ki iu">切片</strong>并执行一个循环追加到<strong class="ki iu"> tmp </strong>数组以保持每次迭代。</p><h1 id="9069" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated"><strong class="ak">连接两个以上切片的高效解决方案(速度快2倍)</strong></h1><p id="214e" class="pw-post-body-paragraph kg kh it ki b kj ni kl km kn nj kp kq kr nk kt ku kv nl kx ky kz nm lb lc ld im bi translated">有些人发现这种创建一个空片然后追加的方法会导致许多不必要的分配，这些分配可以避免，并通过下面的方法将代码性能提高2倍</p><pre class="mq mr ms mt gt mu mv mw bn mx my bi"><span id="77f3" class="mz lt it mv b be na nb l nc nd">package main<br/><br/>import "fmt"<br/><br/>func main() {<br/><br/> slices := [][]string{{"apple", "banana", "peach"},<br/>  {"orange", "grape", "mango"},<br/>  {"strawberry", "blueberry", "raspberry"}}<br/> <br/> fmt.Println(concatCopyPreAllocate(slices))<br/><br/>}<br/><br/>func concatCopyPreAllocate(slices [][]string) []string {<br/> var totalLen int<br/> for _, s := range slices {<br/>  totalLen += len(s)<br/> }<br/> tmp := make([]string, totalLen)<br/> var i int<br/> for _, s := range slices {<br/>  i += copy(tmp[i:], s)<br/> }<br/> return tmp<br/>}</span></pre><p id="3db0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是Cameron Sparr关于StackOverflow 的回答的链接，并附有基准测试示例。</p><h1 id="f2bf" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">使用<code class="fe ne nf ng mv b">append()</code>进行切片拼接的副作用</h1><p id="a54e" class="pw-post-body-paragraph kg kh it ki b kj ni kl km kn nj kp kq kr nk kt ku kv nl kx ky kz nm lb lc ld im bi translated"><code class="fe ne nf ng mv b"><em class="nh">append()</em></code>函数并不总是为返回的切片创建新的底层数组。如果<strong class="ki iu">片1 </strong>的容量足够容纳来自<strong class="ki iu">片2 </strong>的元素，那么产生的片将与<strong class="ki iu">片1 </strong>共享相同的底层数组，这可能会产生意想不到的副作用。</p><p id="f718" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">举例:</strong></p><pre class="mq mr ms mt gt mu mv mw bn mx my bi"><span id="2666" class="mz lt it mv b be na nb l nc nd">package main<br/><br/>import "fmt"<br/><br/>func main() {<br/><br/> slice1 := make([]int, 3, 6)               // s1 has capacity of 5<br/> slice1[0], slice1[1], slice1[2] = 1, 2, 3 // s1 has length of 3<br/> slice2 := []int{4, 5, 6}<br/><br/> slice3 := append(slice1, slice2...)<br/><br/> fmt.Println("Before adding element to slice 3")<br/> fmt.Println("slice1:", slice1)<br/> fmt.Println("slice2:", slice2)<br/> fmt.Println("slice3:", slice3)<br/> //fmt.Println(slice1, slice3)<br/><br/> slice3[0] = 7<br/><br/> fmt.Println("After adding element to slice 3")<br/> fmt.Println("slice1:", slice1)<br/> fmt.Println("slice2:", slice2)<br/> fmt.Println("slice3:", slice3)<br/>}<br/><br/>//output <br/>Before adding element to slice 3<br/>slice1: [1 2 3]<br/>slice2: [4 5 6]<br/>slice3: [1 2 3 4 5 6]<br/>After adding element to slice 3<br/>slice1: [7 2 3]<br/>slice2: [4 5 6]<br/>slice3: [7 2 3 4 5 6]</span></pre><p id="089e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">改变<strong class="ki iu">切片3 </strong>中的元素值会导致<strong class="ki iu">切片1 </strong>也发生改变。发生这种情况是因为它们共享相同的底层数组，这可能会导致错误。可以通过确保由<code class="fe ne nf ng mv b"><em class="nh">append()</em></code>返回的片由新的底层数组支持来防止这个问题，而不管<strong class="ki iu">片1 </strong>的容量如何。</p><p id="5a03" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">方法如下:</strong></p><pre class="mq mr ms mt gt mu mv mw bn mx my bi"><span id="af7e" class="mz lt it mv b be na nb l nc nd">package main<br/><br/>import "fmt"<br/><br/>func main() {<br/><br/> slice1 := make([]int, 3, 6)               // s1 has capacity of 5<br/> slice1[0], slice1[1], slice1[2] = 1, 2, 3 // s1 has length of 3<br/> slice2 := []int{4, 5, 6}<br/><br/> slice3 := append(slice1[:len(slice1):len(slice1)], slice2...)<br/><br/> fmt.Println("Before adding element to slice 3")<br/> fmt.Println("slice1:", slice1)<br/> fmt.Println("slice2:", slice2)<br/> fmt.Println("slice3:", slice3)<br/> //fmt.Println(slice1, slice3)<br/><br/> slice3[0] = 7<br/><br/> fmt.Println("After adding element to slice 3")<br/> fmt.Println("slice1:", slice1)<br/> fmt.Println("slice2:", slice2)<br/> fmt.Println("slice3:", slice3)<br/>}<br/><br/>//output <br/>Before adding element to slice 3<br/>slice1: [1 2 3]<br/>slice2: [4 5 6]<br/>slice3: [1 2 3 4 5 6]<br/>After adding element to slice 3<br/>slice1: [1 2 3]<br/>slice2: [4 5 6]<br/>slice3: [7 2 3 4 5 6]</span></pre><p id="694a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">将附加功能调整为</p><pre class="mq mr ms mt gt mu mv mw bn mx my bi"><span id="1140" class="mz lt it mv b be na nb l nc nd">append(slice1[:len(slice1):len(slice1)], slice2...)<br/><br/>//output <br/>Before adding element to slice 3<br/>slice1: [1 2 3]<br/>slice2: [4 5 6]<br/>slice3: [1 2 3 4 5 6]<br/>After adding element to slice 3<br/>slice1: [1 2 3]<br/>slice2: [4 5 6]<br/>slice3: [7 2 3 4 5 6]</span></pre><h1 id="91d4" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">结论</h1><p id="5a0c" class="pw-post-body-paragraph kg kh it ki b kj ni kl km kn nj kp kq kr nk kt ku kv nl kx ky kz nm lb lc ld im bi translated">我们看到了在Go中连接两个或更多切片的两种方法，以及如何避免使用<code class="fe ne nf ng mv b"><em class="nh">append()</em></code>函数的副作用。如果您对Go中的切片连接有任何进一步的见解，欢迎发表评论。</p><p id="64a8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">编码快乐！</p></div><div class="ab cl nn no hx np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="im in io ip iq"><h1 id="0f75" class="ls lt it bd lu lv nu lx ly lz nv mb mc md nw mf mg mh nx mj mk ml ny mn mo mp bi translated">分级编码</h1><p id="db05" class="pw-post-body-paragraph kg kh it ki b kj ni kl km kn nj kp kq kr nk kt ku kv nl kx ky kz nm lb lc ld im bi translated">感谢您成为我们社区的一员！在你离开之前:</p><ul class=""><li id="29ba" class="le lf it ki b kj kk kn ko kr lg kv lh kz li ld nz lk ll lm bi translated">👏为故事鼓掌，跟着作者走👉</li><li id="0ce0" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld nz lk ll lm bi translated">📰查看<a class="ae kf" href="https://levelup.gitconnected.com/?utm_source=pub&amp;utm_medium=post" rel="noopener ugc nofollow" target="_blank">升级编码出版物</a>中的更多内容</li><li id="4baa" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld nz lk ll lm bi translated">🔔关注我们:<a class="ae kf" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">推特</a> | <a class="ae kf" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a> | <a class="ae kf" href="https://newsletter.levelup.dev" rel="noopener ugc nofollow" target="_blank">时事通讯</a></li></ul><p id="2836" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">🚀👉<a class="ae kf" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="ki iu">加入升级人才集体，找到一份惊艳的工作</strong> </a></p></div></div>    
</body>
</html>