<html>
<head>
<title>Multiple Ways to Traverse JavaScript Objects Keys</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">遍历JavaScript对象键的多种方法</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/multiple-ways-to-traverse-javascript-objects-keys-5a00a2773267?source=collection_archive---------1-----------------------#2020-05-06">https://levelup.gitconnected.com/multiple-ways-to-traverse-javascript-objects-keys-5a00a2773267?source=collection_archive---------1-----------------------#2020-05-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/f83ede951106fdc518df7608a832aed5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OIwSSllcbHdJb7Wn"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">蒂埃拉·马洛卡在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="bb28" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">JavaScript对象是JavaScript中的基本构件。在ES6或更高版本中，有很多方法可以遍历对象。</p><p id="a669" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将研究如何在JavaScript中遍历对象键。</p><h1 id="3864" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">遍历属性</h1><p id="0c46" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">有几种方法可以遍历JavaScript对象的属性。它们是:</p><ul class=""><li id="41bd" class="mh mi it ki b kj kk kn ko kr mj kv mk kz ml ld mm mn mo mp bi translated"><code class="fe mq mr ms mt b">Object.keys(obj)</code> —获取所有非继承(自有)属性的所有字符串键</li><li id="37c8" class="mh mi it ki b kj mu kn mv kr mw kv mx kz my ld mm mn mo mp bi translated"><code class="fe mq mr ms mt b">Object.getOwnPropertyNames(obj)</code> —获取所有自身属性的所有字符串键</li><li id="a7bc" class="mh mi it ki b kj mu kn mv kr mw kv mx kz my ld mm mn mo mp bi translated"><code class="fe mq mr ms mt b">Object.getOwnPropertySymbols(obj)</code> —获取所有自有属性的所有符号键</li><li id="0e0b" class="mh mi it ki b kj mu kn mv kr mw kv mx kz my ld mm mn mo mp bi translated"><code class="fe mq mr ms mt b">Reflect.ownKeys(obj)</code> —获取所有自有属性的所有密钥</li><li id="000b" class="mh mi it ki b kj mu kn mv kr mw kv mx kz my ld mm mn mo mp bi translated"><code class="fe mq mr ms mt b">for...in</code>循环——循环所有自己的和继承的可枚举属性</li></ul><h1 id="71c4" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">属性的遍历顺序</h1><p id="cc1b" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">遍历顺序没有定义。因此，<code class="fe mq mr ms mt b">for...in</code>循环的遍历顺序因浏览器而异。</p><p id="549a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们不应该依赖于代码中遍历的顺序。</p><h1 id="ce84" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated"><code class="fe mq mr ms mt b">Object.keys(obj)</code></h1><p id="fb61" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mq mr ms mt b">Object.keys</code>接受一个对象作为参数，并返回一个非继承的、可枚举的字符串键数组。</p><p id="6a86" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以如下使用它:</p><pre class="mz na nb nc gt nd mt ne nf aw ng bi"><span id="946d" class="nh lf it mt b gy ni nj l nk nl">const obj = {<br/>  a: 1,<br/>  b: 'foo',<br/>  c: false<br/>};</span><span id="c4fb" class="nh lf it mt b gy nm nj l nk nl">for (const key of Object.keys(obj)) {<br/>  console.log(key);<br/>}</span></pre><p id="bfc0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的代码遍历由<code class="fe mq mr ms mt b">Object.keys</code>返回的<code class="fe mq mr ms mt b">obj</code>的键。然后我们记录<code class="fe mq mr ms mt b">obj</code>的键，因为它们被循环通过。</p><p id="1ce4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们得到:</p><pre class="mz na nb nc gt nd mt ne nf aw ng bi"><span id="9134" class="nh lf it mt b gy ni nj l nk nl">a<br/>b<br/>c</span></pre><p id="4c31" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从控制台日志输出。</p><h1 id="817c" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">object . getownpropertymanames(obj)</h1><p id="0f91" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以使用<code class="fe mq mr ms mt b">Object.hetOwnPropertyNames</code>方法来检索所有的字符串键，包括不可枚举的。</p><p id="eb39" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以如下使用它:</p><pre class="mz na nb nc gt nd mt ne nf aw ng bi"><span id="1201" class="nh lf it mt b gy ni nj l nk nl">const obj = {<br/>  a: 1,<br/>  b: 'foo',<br/>};</span><span id="2e84" class="nh lf it mt b gy nm nj l nk nl">Object.defineProperty(obj, 'c', {<br/>  value: false,<br/>  enumerable: false<br/>})</span><span id="35cd" class="nh lf it mt b gy nm nj l nk nl">for (const key of Object.getOwnPropertyNames(obj)) {<br/>  console.log(key);<br/>}</span></pre><p id="2689" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们通过用一个指定属性设置为<code class="fe mq mr ms mt b">false</code>的对象调用<code class="fe mq mr ms mt b">Object.defineProperty</code>，在<code class="fe mq mr ms mt b">obj</code>中定义了一个不可枚举属性<code class="fe mq mr ms mt b">c</code>。</p><p id="5926" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后当我们循环通过由<code class="fe mq mr ms mt b">getOwnPropertyNames</code>返回的键时，我们得到:</p><pre class="mz na nb nc gt nd mt ne nf aw ng bi"><span id="c09a" class="nh lf it mt b gy ni nj l nk nl">a<br/>b<br/>c</span></pre><p id="728b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从控制台日志输出，因为可枚举和不可枚举属性都由<code class="fe mq mr ms mt b">getOwnPropertyNames</code>返回。</p><h1 id="486c" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">object . getownpropertymodals(obj)</h1><p id="b43b" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mq mr ms mt b">Object.getOwnPropertySymbols</code>方法接受一个对象并返回该对象的所有符号键。只返回自己的密钥。</p><p id="f19d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以如下使用它:</p><pre class="mz na nb nc gt nd mt ne nf aw ng bi"><span id="591b" class="nh lf it mt b gy ni nj l nk nl">const obj = {<br/>  [Symbol('a')]: 1,<br/>  [Symbol('b')]: 'foo',<br/>  [Symbol('c')]: false<br/>};</span><span id="7acd" class="nh lf it mt b gy nm nj l nk nl">for (const key of Object.getOwnPropertySymbols(obj)) {<br/>  console.log(key);<br/>}</span></pre><p id="1ba0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们得到:</p><pre class="mz na nb nc gt nd mt ne nf aw ng bi"><span id="2396" class="nh lf it mt b gy ni nj l nk nl">Symbol(a)<br/>Symbol(b)<br/>Symbol(c)</span></pre><p id="b60f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从控制台日志输出。</p><h1 id="7e3d" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">Reflect.ownKeys(obj)</h1><p id="b093" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mq mr ms mt b">Reflect.ownKeys</code>在返回的对象中返回字符串和符号非继承键。它接受一个我们想从中获取密钥的对象。</p><p id="6277" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以如下使用它:</p><pre class="mz na nb nc gt nd mt ne nf aw ng bi"><span id="9228" class="nh lf it mt b gy ni nj l nk nl">const obj = {<br/>  [Symbol('a')]: 1,<br/>  [Symbol('b')]: 'foo',<br/>  c: false<br/>};</span><span id="5306" class="nh lf it mt b gy nm nj l nk nl">for (const key of Reflect.ownKeys(obj)) {<br/>  console.log(key);<br/>}</span></pre><p id="f60e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们得到:</p><pre class="mz na nb nc gt nd mt ne nf aw ng bi"><span id="0468" class="nh lf it mt b gy ni nj l nk nl">c<br/>Symbol(a)<br/>Symbol(b)</span></pre><p id="c86c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">记录在控制台日志输出中。</p><figure class="mz na nb nc gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nn"><img src="../Images/d32bf266ac5a9bf13240e29e5bd601a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BzdEXhiQBfoQ-V9A"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">Erik Mclean 在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="320d" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">for(obj中的常量键)</h1><p id="6ac6" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以使用<code class="fe mq mr ms mt b">for...in</code>循环遍历继承的和非继承的可枚举属性键。</p><p id="0e7c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，给定以下类结构和对象:</p><pre class="mz na nb nc gt nd mt ne nf aw ng bi"><span id="4693" class="nh lf it mt b gy ni nj l nk nl">class Person {<br/>  constructor(firstName, lastName) {<br/>    this.firstName = firstName;<br/>    this.lastName = lastName;<br/>  }<br/>}</span><span id="4ca6" class="nh lf it mt b gy nm nj l nk nl">class Student extends Person {<br/>  constructor(firstName, lastName, studentId) {<br/>    super(firstName, lastName);<br/>    this.studentId = studentId;<br/>  }<br/>}</span><span id="3c5d" class="nh lf it mt b gy nm nj l nk nl">const student = new Student('Jane', 'Smith', '123');</span></pre><p id="2aed" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们得到<code class="fe mq mr ms mt b">student</code>对象的所有继承的和非继承的键。</p><p id="a152" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，当我们对<code class="fe mq mr ms mt b">student</code>对象运行<code class="fe mq mr ms mt b">for...in</code>循环时，如下所示:</p><pre class="mz na nb nc gt nd mt ne nf aw ng bi"><span id="a8d3" class="nh lf it mt b gy ni nj l nk nl">for (const key in student) {<br/>  console.log(key);<br/>}</span></pre><p id="1d54" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们得到:</p><pre class="mz na nb nc gt nd mt ne nf aw ng bi"><span id="d517" class="nh lf it mt b gy ni nj l nk nl">firstName<br/>lastName<br/>studentId</span></pre><p id="9241" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从控制台日志中。</p><p id="4dba" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们想遍历继承的和非继承的键，这是唯一的选择。</p><p id="25f4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">除了<code class="fe mq mr ms mt b">for...in</code>之外的选项都返回自己的键，所以没有多少选项可以循环所有的键。</p><p id="2916" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，如果我们不想遍历继承的键，那么其他选择会好得多，因为我们可以确定顺序，因为它们都返回数组。</p><h1 id="c496" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="26da" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">有很多方法可以循环对象的键。</p><p id="bddc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它们是:</p><ul class=""><li id="f05f" class="mh mi it ki b kj kk kn ko kr mj kv mk kz ml ld mm mn mo mp bi translated"><code class="fe mq mr ms mt b">Object.keys(obj)</code> —返回所有非继承(自有)属性的所有字符串键</li><li id="b71e" class="mh mi it ki b kj mu kn mv kr mw kv mx kz my ld mm mn mo mp bi translated"><code class="fe mq mr ms mt b">Object.getOwnPropertyNames(obj)</code> —返回所有自身属性的所有字符串键</li><li id="d720" class="mh mi it ki b kj mu kn mv kr mw kv mx kz my ld mm mn mo mp bi translated"><code class="fe mq mr ms mt b">Object.getOwnPropertySymbols(obj)</code> —返回所有自有属性的所有符号键</li><li id="170f" class="mh mi it ki b kj mu kn mv kr mw kv mx kz my ld mm mn mo mp bi translated"><code class="fe mq mr ms mt b">Reflect.ownKeys(obj)</code> —返回所有自有属性的所有键</li><li id="b5cd" class="mh mi it ki b kj mu kn mv kr mw kv mx kz my ld mm mn mo mp bi translated"><code class="fe mq mr ms mt b">for...in</code>循环—循环所有自己的和继承的可枚举属性</li></ul><p id="10ab" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这些涵盖了循环遍历键的所有可能性，比如循环遍历符号键、继承键和不可枚举键。</p></div></div>    
</body>
</html>