<html>
<head>
<title>3 Component Cohesion Principles Explained for a Junior Developer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为初级开发人员解释的3个组件内聚原则</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/3-component-cohesion-principles-explained-for-a-junior-developer-53576d1032b3?source=collection_archive---------13-----------------------#2022-09-06">https://levelup.gitconnected.com/3-component-cohesion-principles-explained-for-a-junior-developer-53576d1032b3?source=collection_archive---------13-----------------------#2022-09-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="4889" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我对鲍勃大叔老<a class="ae ko" href="https://cleancoders.com/" rel="noopener ugc nofollow" target="_blank">干净代码</a>系列的简明扼要的总结。即，关于公共闭包、公共重用和发布-重用等价原则的那一集。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi kp"><img src="../Images/8e59bbc2f929b4ec634fe29eb87d1260.png" data-original-src="https://miro.medium.com/v2/resize:fit:1316/format:webp/1*5h0d0X_9ewS8SkjH8g5weQ.png"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">遵循这些原则以避免系统像这样耦合</figcaption></figure><h2 id="8e5d" class="lb lc it bd ld le lf dn lg lh li dp lj kb lk ll lm kf ln lo lp kj lq lr ls lt bi translated">概观</h2><p id="3ada" class="pw-post-body-paragraph jq jr it js b jt lu jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn im bi translated">这三个原则向我们展示了如何构建我们系统中的组件。我们会发现每个原则都将组件拖向不同的方向，因此我们需要在它们之间找到正确的平衡。</p><p id="3662" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们会发现，组件内聚性原则类似于实体原则，但是在更高的层次上。如果SOLID教会我们如何构建函数和类，那么在本文中，我们将学习如何将这些类组织成组件或模块。</p><p id="5cb6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了简要回顾这些坚实的原则，我建议通读这篇关于<a class="ae ko" rel="noopener ugc nofollow" target="_blank" href="/each-of-the-solid-principles-explained-in-less-than-20-seconds-b73057625dfc">的文章，在不到20秒的时间内解释每一条坚实的原则</a>。</p><h2 id="d3f1" class="lb lc it bd ld le lf dn lg lh li dp lj kb lk ll lm kf ln lo lp kj lq lr ls lt bi translated">术语</h2><ul class=""><li id="5c71" class="lz ma it js b jt lu jx lv kb mb kf mc kj md kn me mf mg mh bi translated">一个<strong class="js iu">系统</strong>由<strong class="js iu">层</strong>(例如UI层、逻辑层、数据层)组成，这些层由<strong class="js iu">组件</strong>组成。</li><li id="14ec" class="lz ma it js b jt mi jx mj kb mk kf ml kj mm kn me mf mg mh bi translated">组件<strong class="js iu">是系统的一部分，它将自己的实现隐藏在接口之后。组件主要由<strong class="js iu">功能</strong>组成，数据被封装。</strong></li><li id="ad03" class="lz ma it js b jt mi jx mj kb mk kf ml kj mm kn me mf mg mh bi translated"><strong class="js iu">内聚</strong>是将这些功能保持在一起的<em class="mn">【力】</em>。例如，<strong class="js iu">类</strong>是内聚的第一层。</li></ul></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h2 id="366b" class="lb lc it bd ld le lf dn lg lh li dp lj kb lk ll lm kf ln lo lp kj lq lr ls lt bi translated">1.发布-重用等价原则</h2><p id="f0fd" class="pw-post-body-paragraph jq jr it js b jt lu jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn im bi translated">每个组件都由不同的文件组成。例如，它可以包含一个带有源代码的包、一套测试、文档等等。</p><p id="fa83" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此外，每个组件都意味着版本控制、维护和发布周期。</p><p id="c2ab" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">发布-重用原则声明一个组件应该足够大以证明发布周期的合理性。</strong>这可以用类的数量或代码的行数来衡量。</p><p id="6176" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一个系统的组件越多，花费在维护和发布上的时间就越多。</p><p id="27cf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，我们应该管理一些战略性的组件，而不是许多小组件。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/de65a07742e71a279844cf9cb1639cfa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1304/format:webp/1*YXqNuxty-A7CPp4QRdVcmg.png"/></div></figure></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h2 id="c900" class="lb lc it bd ld le lf dn lg lh li dp lj kb lk ll lm kf ln lo lp kj lq lr ls lt bi translated">2.普通闭合原理</h2><p id="4b59" class="pw-post-body-paragraph jq jr it js b jt lu jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn im bi translated">根据通用闭包原理，由于相同原因而改变的类属于同一个组件。</p><p id="2da0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这让人想起了单一责任原则，即SOLID中的“S”。但是，不同之处在于，现在我们正在学习将类分组到组件/模块中，而坚实的原则教我们如何构造这些类。</p><p id="cf49" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，如果需求发生变化，我们应该尽可能更新最少数量的组件。理想情况下，每层不超过一个组件。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h2 id="93bc" class="lb lc it bd ld le lf dn lg lh li dp lj kb lk ll lm kf ln lo lp kj lq lr ls lt bi translated">3.公共重用原则</h2><p id="af2b" class="pw-post-body-paragraph jq jr it js b jt lu jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn im bi translated">让我们假设我们有一个组件“<em class="mn">A”</em>，<em class="mn">T5】依赖于组件“<em class="mn">B”</em>——换句话说，<em class="mn">“A”</em>的类依赖于<em class="mn">“B”</em>的类。</em></p><p id="06aa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果<em class="mn">“A”</em>没有使用<em class="mn">“B”</em>的所有公共类，这将违反通用重用原则。</p><p id="125b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">这又让我们想起了固体原理，即界面分离原理。</strong></p><p id="963e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，这个原则鼓励我们创建更小、更细粒度的组件。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h2 id="0056" class="lb lc it bd ld le lf dn lg lh li dp lj kb lk ll lm kf ln lo lp kj lq lr ls lt bi translated">找到正确的平衡</h2><p id="3fcc" class="pw-post-body-paragraph jq jr it js b jt lu jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn im bi translated">正如我们所看到的，每个原则都有自己的优势，但是它将组件拖向不同的方向。例如，如果我们严格遵循公共闭包原则，我们将违反发布-重用等价原则。</p><p id="7dac" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，我们必须为我们设计的每个模块找到正确的平衡。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/d289e6a390bd3b02c687afd99a9edc2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1326/format:webp/1*In6CLLkNeEW3pWBUom1MyA.png"/></div></figure><p id="f645" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在下图中，我们可以看到我们已经讨论过的三个原则。如果我们的组件太靠近某个边缘，我们可能需要处理相应的问题。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi mx"><img src="../Images/e6da351017d9e0fe26060540383df5cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xL4FGI9FYCN_OO4Om7aRKA.png"/></div></div></figure><p id="a291" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此外，我们倾向于在项目开始时优先考虑公共重用和公共闭包。这些原则将保持组件的解耦，并将促进更快的开发。</p><p id="d6bb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是，当项目成熟时，我们将遵循绿色箭头，优先考虑重用-发布原则。换句话说，我们将关注可维护性和可扩展性，而不是重用性。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="06b7" class="nc lc it bd ld nd ne nf lg ng nh ni lj nj nk nl lm nm nn no lp np nq nr ls ns bi translated">分级编码</h1><p id="20c2" class="pw-post-body-paragraph jq jr it js b jt lu jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn im bi translated">感谢您成为我们社区的一员！在你离开之前:</p><ul class=""><li id="febd" class="lz ma it js b jt ju jx jy kb nt kf nu kj nv kn me mf mg mh bi translated">👏为故事鼓掌，跟着作者走👉</li><li id="9fe6" class="lz ma it js b jt mi jx mj kb mk kf ml kj mm kn me mf mg mh bi translated">📰查看<a class="ae ko" href="https://levelup.gitconnected.com/?utm_source=pub&amp;utm_medium=post" rel="noopener ugc nofollow" target="_blank">升级编码出版物</a>中的更多内容</li><li id="adf3" class="lz ma it js b jt mi jx mj kb mk kf ml kj mm kn me mf mg mh bi translated">🔔关注我们:<a class="ae ko" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">Twitter</a>|<a class="ae ko" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>|<a class="ae ko" href="https://newsletter.levelup.dev" rel="noopener ugc nofollow" target="_blank">时事通讯</a></li></ul><p id="bdd0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">🚀👉<a class="ae ko" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">加入升级人才集体，找到一份惊艳的工作</strong> </a></p></div></div>    
</body>
</html>