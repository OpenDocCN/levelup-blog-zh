<html>
<head>
<title>Practical SOLID in Golang: Open/Closed Principle</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">戈朗实用固体:开/闭原理</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/practical-solid-in-golang-open-closed-principle-1dd361565452?source=collection_archive---------3-----------------------#2021-10-30">https://levelup.gitconnected.com/practical-solid-in-golang-open-closed-principle-1dd361565452?source=collection_archive---------3-----------------------#2021-10-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="6642" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">坚实的原则</h2><div class=""/><div class=""><h2 id="7dab" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">我们将通过展示为应用程序提供灵活性的原则——开放/封闭原则，继续我们的坚实原则之旅。</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/4ace5df6c575fa8e088996fa274bf0b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9ZV3EjKrx91pQwXw"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">由<a class="ae lh" href="https://unsplash.com/@tekton_tools?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">泰克顿</a>在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="734a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">许多不同的方法和原则为我们的代码提供了长期的改进。他们中的一些人在软件开发社会中很有名，而一些人却不为人所知。</p><p id="2e45" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我的看法是，开/闭原理就是这样，它代表单词<em class="me"> SOLID </em>中的字母<em class="me"> O </em>。根据我的经验，只有渴望了解SOLID的人才能真正理解这个原则的含义。</p><p id="b158" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们有机会学习这个原则在<a class="ae lh" href="https://refactoring.guru/design-patterns/strategy" rel="noopener ugc nofollow" target="_blank">策略</a>模式中的一些应用，但没有意识到我们应用了它。尽管如此，战略模式只是OCP的一个应用。</p><p id="7367" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在本文中，我们将试图揭示这一原则的全部目的。像往常一样，所有的例子都将在Go。</p><pre class="ks kt ku kv gt mf mg mh mi aw mj bi"><span id="5495" class="mk ml it mg b gy mm mn l mo mp">Other articles from the SOLID series:</span><span id="1154" class="mk ml it mg b gy mq mn l mo mp"><strong class="mg jd">1. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-solid-in-golang-single-responsibility-principle-20afb8643483"><strong class="mg jd">Practical SOLID in Golang: Single Responsability Principle</strong></a><strong class="mg jd"><br/></strong></span><span id="444c" class="mk ml it mg b gy mq mn l mo mp">Some articles from the DDD series:</span><span id="fe20" class="mk ml it mg b gy mq mn l mo mp"><strong class="mg jd">1.</strong> <a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-ddd-in-golang-value-object-4fc97bcad70"><strong class="mg jd">Practical DDD in Golang: Value Object</strong></a></span><span id="e05e" class="mk ml it mg b gy mq mn l mo mp"><strong class="mg jd">2. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-ddd-in-golang-entity-40d32bdad2a3"><strong class="mg jd">Practical DDD in Golang: Entity</strong></a></span><span id="3d18" class="mk ml it mg b gy mq mn l mo mp"><strong class="mg jd">3. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-ddd-in-golang-aggregate-de13f561e629"><strong class="mg jd">Practical DDD in Golang: Aggregate</strong></a></span><span id="3e94" class="mk ml it mg b gy mq mn l mo mp"><strong class="mg jd">4. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-ddd-in-golang-repository-d308c9d79ba7"><strong class="mg jd">Practical DDD in Golang: Repository</strong></a></span><span id="6703" class="mk ml it mg b gy mq mn l mo mp"><strong class="mg jd">5. ...</strong></span></pre><div class="mr ms gp gr mt mu"><a href="https://blog.ompluscator.com/membership" rel="noopener  ugc nofollow" target="_blank"><div class="mv ab fo"><div class="mw ab mx cl cj my"><h2 class="bd jd gy z fp mz fr fs na fu fw jc bi translated">通过我的推荐链接加入媒体——马尔科·米洛耶维奇</h2><div class="nb l"><h3 class="bd b gy z fp mz fr fs na fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="nc l"><p class="bd b dl z fp mz fr fs na fu fw dk translated">blog.ompluscator.com</p></div></div><div class="nd l"><div class="ne l nf ng nh nd ni lb mu"/></div></div></a></div><h1 id="ddcb" class="nj ml it bd nk nl nm nn no np nq nr ns ki nt kj nu kl nv km nw ko nx kp ny nz bi translated">当我们不遵守开/关原则时</h1><blockquote class="oa ob oc"><p id="3743" class="li lj me lk b ll lm kd ln lo lp kg lq od ls lt lu oe lw lx ly of ma mb mc md im bi translated">您应该能够扩展系统的行为，而不必修改该系统。</p></blockquote><p id="d07c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">对OCP的要求，我们可以在上面看到，<a class="ae lh" href="https://twitter.com/unclebobmartin" rel="noopener ugc nofollow" target="_blank">鲍勃大叔</a>在他的<a class="ae lh" href="http://blog.cleancoder.com/uncle-bob/2014/05/12/TheOpenClosedPrinciple.html" rel="noopener ugc nofollow" target="_blank">博客</a>中提供。我更喜欢这种定义开/闭原则的方式，因为它展示了它的全部光辉。</p><p id="bf85" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">第一眼看完，我们可能会觉得这是一个荒谬的要求。是的，说真的，我们应该如何在不修改的情况下扩展某个东西？我是说，有没有可能在不改变的情况下改变一些东西？</p><p id="2df4" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">通过检查下面的代码示例，我们可以看到一些结构不遵守这个原则意味着什么以及可能的后果。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="299e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">该示例显示了一个结构<code class="fe oi oj ok mg b">PermissionChecker</code>。它应该检查是否有访问某些资源所需的权限，这取决于web应用程序的<code class="fe oi oj ok mg b">Context</code>，由包<a class="ae lh" href="https://github.com/gin-gonic/gin" rel="noopener ugc nofollow" target="_blank"> Gin </a>支持。</p><p id="7fa1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这里我们有主方法<code class="fe oi oj ok mg b">HasPermission</code>，它检查带有特定名称的权限是否与<code class="fe oi oj ok mg b">Context</code>中的数据相关联。</p><p id="47fc" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">根据用户是使用JWT令牌、基本授权还是应用程序密钥进行授权，从上下文中检索权限可能会有所不同。在该结构中，我们提供了权限片的所有不同提取。</p><p id="127d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果我们尊重<a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-solid-in-golang-single-responsibility-principle-20afb8643483">单一责任原则</a>，<code class="fe oi oj ok mg b">PermissionChecker</code>负责决定权限是否在<code class="fe oi oj ok mg b">Context</code>内部，与授权过程无关。</p><p id="3300" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">授权过程必须在其他地方定义，在其他结构中，甚至可能是不同的<a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-ddd-in-golang-module-51edf4c319ec">模块</a>。因此，如果我们想在其他地方扩展授权过程，我们也需要在这里调整逻辑。</p><p id="909f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">假设我们想要扩展授权逻辑并添加一些新的流程，比如将用户数据保存在会话中或者使用<a class="ae lh" href="https://httpwg.org/specs/rfc7616.html" rel="noopener ugc nofollow" target="_blank">摘要授权</a>。那样的话，我们也需要在<code class="fe oi oj ok mg b">PermissionChecker</code>进行改编。</p><p id="113b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这种实现带来了问题的激增:</p><ol class=""><li id="407a" class="ol om it lk b ll lm lo lp lr on lv oo lz op md oq or os ot bi translated"><code class="fe oi oj ok mg b">PermissionChecker</code>保持最初在其他地方处理的逻辑。</li><li id="8b5d" class="ol om it lk b ll ou lo ov lr ow lv ox lz oy md oq or os ot bi translated">授权逻辑的任何修改，可能是不同的模块，需要在<code class="fe oi oj ok mg b">PermissionChecker</code>中进行修改。</li><li id="b040" class="ol om it lk b ll ou lo ov lr ow lv ox lz oy md oq or os ot bi translated">要添加一种提取权限的新方式，我们总是需要修改<code class="fe oi oj ok mg b">PermissionChecker</code>。</li><li id="a938" class="ol om it lk b ll ou lo ov lr ow lv ox lz oy md oq or os ot bi translated"><code class="fe oi oj ok mg b">PermissionChecker</code>内部的逻辑不可避免地随着每个新的授权流而增长。</li><li id="c4a4" class="ol om it lk b ll ou lo ov lr ow lv ox lz oy md oq or os ot bi translated"><code class="fe oi oj ok mg b">PermissionChecker</code>的单元测试包含太多关于不同权限提取的技术细节。</li><li id="074e" class="ol om it lk b ll ou lo ov lr ow lv ox lz oy md oq or os ot bi">…</li></ol><p id="a634" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">所以，现在，我们又有一些代码要重构。</p><h1 id="045f" class="nj ml it bd nk nl nm nn no np nq nr ns ki nt kj nu kl nv km nw ko nx kp ny nz bi translated">我们如何尊重开放/封闭原则</h1><blockquote class="oa ob oc"><p id="b604" class="li lj me lk b ll lm kd ln lo lp kg lq od ls lt lu oe lw lx ly of ma mb mc md im bi translated">打开/关闭原则<a class="ae lh" href="https://deviq.com/principles/open-closed-principle" rel="noopener ugc nofollow" target="_blank">告诉</a>软件结构应该<strong class="lk jd">打开</strong>进行扩展，而<strong class="lk jd">关闭</strong>进行修改。</p></blockquote><p id="ab89" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">上面的陈述为我们应该尊重OCP的新代码提供了一些可能的方向。这段代码应该提供一些允许从外部进行扩展的东西。</p><p id="7707" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在面向对象编程中，我们通过对同一接口使用不同的实现来支持这种扩展。换句话说，我们使用<a class="ae lh" href="https://en.wikipedia.org/wiki/Polymorphism_(computer_science)" rel="noopener ugc nofollow" target="_blank">多态性</a>。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="40a0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在上面的例子中，我们可以看到一个尊重OCP的候选人。适配器<code class="fe oi oj ok mg b">PermissionChecker</code>没有隐藏从<code class="fe oi oj ok mg b">Context</code>中提取权限的技术细节。</p><p id="fbd3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">相反，我们引入了一个新的界面，<code class="fe oi oj ok mg b">PermissionProvider</code>。这个新的构造代表了放置不同权限提取的逻辑的位置。</p><p id="33da" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">比如可以是<code class="fe oi oj ok mg b">JwtPermissionProvider</code>，或者<code class="fe oi oj ok mg b">ApiKeyPermissionProvider</code>，或者<code class="fe oi oj ok mg b">AuthBasicPermissionProvider</code>。现在，负责授权的模块可能还包含权限提取器。</p><p id="35b3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这意味着我们可以将关于授权用户的逻辑放在一个地方，而不是分散到整个代码中。</p><p id="aba6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">另一方面，我们的主要目标，扩展<code class="fe oi oj ok mg b">PermissionChecker</code>，不需要修改它，现在是可能的。我们可以用任意多的不同的<code class="fe oi oj ok mg b">PermissionProviders</code>来初始化<code class="fe oi oj ok mg b">PermissionChecker</code>。</p><p id="eafb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">假设我们需要添加从会话密钥获取权限的可能性。在这种情况下，我们需要实现一个新的<code class="fe oi oj ok mg b">SessionPermissionProvider</code>，它将从上下文中提取cookie，并使用它从<code class="fe oi oj ok mg b">SessionStore</code>中获取权限。</p><p id="fd79" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们使得在需要时扩展PermissionChecker成为可能，而不再修改其内部逻辑。现在我们看到了什么是开放的扩展和封闭的修改。</p><h1 id="25ba" class="nj ml it bd nk nl nm nn no np nq nr ns ki nt kj nu kl nv km nw ko nx kp ny nz bi translated">更多的例子</h1><p id="872d" class="pw-post-body-paragraph li lj it lk b ll oz kd ln lo pa kg lq lr pb lt lu lv pc lx ly lz pd mb mc md im bi translated">前一个问题我们可以用稍微不同的方法来解决。让我们看看下面的代码片段:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="0347" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在新的实现中，我们从<code class="fe oi oj ok mg b">PermissionChecker</code>中移除了<code class="fe oi oj ok mg b">PermissionProviders</code>的内部片。相反，我们将正确的提供者定义为方法<code class="fe oi oj ok mg b">HasPermission</code>的参数。</p><p id="a887" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我更喜欢第一种方法，但这也可能是一种解决方案，这取决于我们在应用程序中的用例。</p><p id="a0e2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们可以将开放/封闭原则应用于方法，而不仅仅是结构。示例可能是下面的代码:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="c5ef" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">函数<code class="fe oi oj ok mg b">GetCities</code>从某个来源读取城市列表。该来源可以是文件或互联网上的一些资源。尽管如此，我们可能希望在将来从内存、Redis或任何其他来源读取数据。</p><p id="6612" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，无论如何，让读取原始数据的过程更抽象一点会更好。也就是说，我们可以从外部提供一个阅读策略作为方法参数。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="og oh l"/></div></figure><p id="8a70" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">正如你在上面的解决方案中看到的，在Go中，我们可以定义一个嵌入函数的新类型。在这里，我们描述了一个新的类型，<code class="fe oi oj ok mg b">DataReader</code>，表示从某个源读取原始数据的函数类型。</p><p id="11d3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">新方法<code class="fe oi oj ok mg b">ReadFromFile</code>和<code class="fe oi oj ok mg b">ReadFromLink</code>是<code class="fe oi oj ok mg b">DataReader</code>类型的实际实现。<code class="fe oi oj ok mg b">GetCities</code>方法期望将<code class="fe oi oj ok mg b">DataReader</code>的实际实现作为参数，然后它在函数体内执行并获取原始数据。</p><p id="d851" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">正如你所看到的，OCP的主要目的是给我们的代码和代码的用户更多的灵活性。只要有人能够扩展我们的库，而不分叉它们，不为它们提供拉请求，或者以任何方式修改它们，我们的库就有了真正的价值。</p><h1 id="b0f7" class="nj ml it bd nk nl nm nn no np nq nr ns ki nt kj nu kl nv km nw ko nx kp ny nz bi translated">结论</h1><p id="7806" class="pw-post-body-paragraph li lj it lk b ll oz kd ln lo pa kg lq lr pb lt lu lv pc lx ly lz pd mb mc md im bi translated">开/关原理是第二个立体原理，代表字母<em class="me"> O </em>。它说我们应该总是扩展我们的代码结构，而不实际修改它们。</p><p id="1521" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在它的源头，我们应该使用多态来满足这个需求。我们的代码应该提供一个简单的接口来增加这种可扩展性。</p></div></div>    
</body>
</html>