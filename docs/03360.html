<html>
<head>
<title>Performant JavaScript — Events and Objects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">性能JavaScript —事件和对象</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/performant-javascript-events-and-objects-64a809f340a1?source=collection_archive---------25-----------------------#2020-05-04">https://levelup.gitconnected.com/performant-javascript-events-and-objects-64a809f340a1?source=collection_archive---------25-----------------------#2020-05-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/7587e79d8ce29ad8c7e39c8c58ce6b56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*19PBUsnuRqaBGzyO"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@cathus?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">加里·尼萨姆</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="6a76" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">像任何程序一样，如果我们不小心编写代码，JavaScript程序会变得很慢很快。</p><p id="8e4c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将研究如何改进事件处理和对象操作来提高JavaScript应用程序的速度。</p><h1 id="0756" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">实施事件委托</h1><p id="b20a" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">事件委托是一种用一个事件处理程序处理来自多个来源的事件的方法。</p><p id="2dde" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于每个事件处理程序，我们必须添加它们，然后删除它们。每个事件处理程序占用更多的资源，因为它们必须能够监听事件。</p><p id="1806" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们想监听来自多个按钮的事件，我们可以编写以下代码:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="0e58" class="mq lf it mm b gy mr ms l mt mu">const foo = document.querySelector('#foo');<br/>const bar = document.querySelector('#bar');<br/>const baz = document.querySelector('#baz');</span><span id="491f" class="mq lf it mm b gy mv ms l mt mu">foo.addEventListener('click', () =&gt; alert('foo clicked'))</span><span id="e634" class="mq lf it mm b gy mv ms l mt mu">bar.addEventListener('click', () =&gt; alert('bar clicked'))</span><span id="2c57" class="mq lf it mm b gy mv ms l mt mu">baz.addEventListener('click', () =&gt; alert('baz clicked'))</span></pre><p id="dfbb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么我们应该重写如下:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="6ebc" class="mq lf it mm b gy mr ms l mt mu">document.addEventListener('click', (e) =&gt; {<br/>  alert(`${e.target.id} clicked`);<br/>})</span></pre><p id="c9cc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们只有一个事件处理程序，而不是3个。这要好得多，因为向任何元素添加事件处理程序都是一项开销很大的操作。</p><p id="75c0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还必须记得稍后清理它们，这样我们就可以释放那些被<code class="fe mw mx my mm b">addEventListener</code>调用的事件监听器所占用的所有资源。</p><p id="32e2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，代码也不太复杂。我们只是监听<code class="fe mw mx my mm b">document</code>对象，然后获取我们想要处理的元素的ID，然后用它做一些事情。</p><p id="9459" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它还可以处理动态生成的元素，不像<code class="fe mw mx my mm b">addEventListener</code>，我们必须对每个元素单独显式地调用它。</p><h1 id="50a4" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">不要两次加载同一个脚本</h1><p id="a1ac" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们绝对不应该两次加载同一个脚本。把所有东西都加载两次是没有用的，而且会因为加载两次而减慢我们的程序。此外，两次加载脚本可能会导致意外行为。</p><h1 id="59ee" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">提高物体检测的速度</h1><p id="cac5" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">当我们试图发现一个属性是否存在于一个对象中，并运行存在的函数时，我们应该把函数赋给一个对象，这样我们只有一个对函数的引用。</p><p id="24bc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，不是编写以下代码来检测对象，然后调用<code class="fe mw mx my mm b">if</code>块中的每个函数，如下所示:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="f00f" class="mq lf it mm b gy mr ms l mt mu">const addListener = (element, type, handler) =&gt; {<br/>  if (element.addEventListener) {<br/>    element.addEventListener(type, handler);<br/>  } else if (element.attachEvent) {<br/>    element.attachEvent(`on${type}`, handler);<br/>  }<br/>};</span></pre><p id="5f08" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">相反，我们应该编写以下代码:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="a128" class="mq lf it mm b gy mr ms l mt mu">const addListener = (element, type, handler) =&gt; {<br/>  if (element.addEventListener) {<br/>    return element.addEventListener(type, handler, false);<br/>  } else if (element.attachEvent) {<br/>    return element.attachEvent(`on${type}`, handler);<br/>  } else {<br/>    return () =&gt; {}<br/>  }<br/>};</span><span id="166a" class="mq lf it mm b gy mv ms l mt mu">const button = document.querySelector('button');<br/>const listener = addListener(button, 'click', () =&gt; alert('clicked'))</span></pre><p id="c55d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不同的是，我们返回了函数，然后我们可以用它来调用<code class="fe mw mx my mm b">removeListener</code>。</p><p id="264b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第一个例子没有办法做到这一点，所以我们应该总是返回一个侦听器，这样我们就可以在页面卸载时调用<code class="fe mw mx my mm b">removeListener</code>来运行清理代码以删除所有返回的侦听器。</p><h1 id="97df" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">不要使用eval</h1><p id="4f76" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mw mx my mm b">eval</code>是坏函数。它让我们从字符串中提取代码，这并不好，因为恶意代码可能会被注入。</p><p id="4211" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，它比从实际代码中运行代码要慢，因为浏览器不能对字符串中的代码进行优化，浏览器不知道它是代码。</p><p id="fbf9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我们不应该在代码中使用<code class="fe mw mx my mm b">eval</code>。</p><h1 id="8372" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">使用函数表达式</h1><p id="f8a4" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">函数表达式是当我们创建一个函数，然后把它赋给一个变量时定义的函数。</p><p id="b0a8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它们不会被提升，函数只在运行时创建。这意味着它们只在需要的时候被创建。因此，如果我们不需要它，那么它就不会被创建，节省了我们创建函数的时间和内存空间。</p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/daa2b109b582bf19eca97a3d88e6ff35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dpsPwGxdXQt0xHRC"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@jneric?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">乔·内里克</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="45ca" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">没有全局变量</h1><p id="dd71" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">肯定不应该创建全局变量，因为为了找到和使用它们，必须在整个程序中查找它们。</p><p id="52ef" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，它们很容易发生冲突，因为所有东西都共享同一个全局名称空间。因此，我们没有理由使用它们。</p><h1 id="8171" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="595a" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">事件委托让我们在事件处理程序中处理多个元素的事件，从而缩短了事件处理代码。</p><p id="9ac1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这消除了添加和删除元素侦听器所需的大量代码。</p><p id="0ec1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">全局变量不好，因为需要查找。</p><p id="a42c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mw mx my mm b">eval</code>也不好是因为它的安全问题和难以优化。</p><p id="a2de" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">加载脚本两次除了减慢我们的代码没有任何好处，所以我们不应该这样做。</p></div></div>    
</body>
</html>