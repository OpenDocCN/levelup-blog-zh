<html>
<head>
<title>Secure Groovy Script Execution in a Sandbox</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在沙箱中安全执行Groovy脚本</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/secure-groovy-script-execution-in-a-sandbox-ea39f80ee87?source=collection_archive---------4-----------------------#2021-03-18">https://levelup.gitconnected.com/secure-groovy-script-execution-in-a-sandbox-ea39f80ee87?source=collection_archive---------4-----------------------#2021-03-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/36eba8d33d0a612c380417ff399ebeb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eSYXRg4IeIJLLJUSgg7m9A.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">图片由作者从<a class="ae kc" href="http://groovy-lang.org" rel="noopener ugc nofollow" target="_blank">http://groovy-lang.org</a>和<a class="ae kc" href="https://www.compart.com/en/unicode/U+1F512" rel="noopener ugc nofollow" target="_blank">https://www.compart.com/en/unicode/U+1F512</a>合成</figcaption></figure><p id="35f2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我正在研究在沙箱中执行不可信的Groovy脚本。我从来都不是一个安全人员，所以这个过程是一次宝贵的学习经历。我将用这篇文章来总结我的发现。</p><p id="8957" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我在Capco.com<a class="ae kc" href="https://www.capco.com" rel="noopener ugc nofollow" target="_blank">做顾问。非常感谢我的同事们，他们慷慨地发表了意见。此处表达的观点不一定反映雇主的观点。</a></p><h1 id="40e6" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">Java沙盒</h1><p id="8fb4" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">概括地说，Java沙箱依赖于以下三个协同工作的组件:</p><ol class=""><li id="f0be" class="me mf iq kf b kg kh kk kl ko mg ks mh kw mi la mj mk ml mm bi translated">字节码检验器</li><li id="fb02" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">类加载器</li><li id="caae" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">安全管理器及其策略</li></ol><p id="c227" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">字节码验证器确保编译后的类文件是有效的，并且不会利用虚拟机。类装入器是分层创建的。如果您想象一个类装入器树，那么“叶子”类装入器只能在同一分支上访问它们的类和它们的父类。使用这种结构，您可以通过使用自定义类加载器在受限环境中执行代码。最后，安全管理器基于自定义策略文件提供运行时权限检查。</p><h1 id="cecc" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">项目要求</h1><p id="9995" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">众所周知，便利性和安全性之间是有权衡的。找到正确的平衡需要与所有关键利益相关者进行讨论和合作。在我们深入研究这篇文章之前，让我们假设这些是我们正在处理的事实:</p><ol class=""><li id="c035" class="me mf iq kf b kg kh kk kl ko mg ks mh kw mi la mj mk ml mm bi translated">今天，Groovy脚本是为非常特定的上下文编写的。他们有几百人。它们与主程序在同一个虚拟机中执行，并且可以从主程序中访问类。换句话说，他们是可信的。</li><li id="e739" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">展望未来，该特定上下文可能会向不可信方开放。我们需要一个计划来保护环境，以便将来运行不受信任的Groovy脚本。</li></ol><p id="0558" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">考虑到这些事实，我们决定使用安全管理器和各种Groovy编译器定制来关注运行时权限检查和可选的源代码级别检查。</p><h1 id="029a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">保护Groovy脚本执行环境的步骤</h1><h2 id="92a1" class="mt lc iq bd ld mu mv dn lh mw mx dp ll ko my mz lp ks na nb lt kw nc nd lx ne bi translated">步骤1:安全管理器和策略文件</h2><p id="be5c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">首先，我们需要安装一个安全管理器来执行运行时权限检查。如果Groovy脚本运行在同一个VM中，你不希望它调用<code class="fe nf ng nh ni b">System.exit(0)</code>。安全管理器与策略文件协同工作。策略文件声明授予每个基本代码的权限。Codebase基本上是一个描述代码从哪里加载的URL。幸运的是，所有由Groovy解释器解释的Groovy脚本都有<code class="fe nf ng nh ni b">file:/groovy/script</code>代码库或<code class="fe nf ng nh ni b">file:/groovy/shell</code>代码库。因此，将所有权限授予正在运行的程序而不是Groovy的策略文件应该是这样的:</p><pre class="nj nk nl nm gt nn ni no np aw nq bi"><span id="b5a2" class="mt lc iq ni b gy nr ns l nt nu">grant codeBase "file://&lt;your jar file&gt;" {<br/>  permission java.security.AllPermission;<br/>};</span><span id="e15d" class="mt lc iq ni b gy nv ns l nt nu">grant codeBase "file:/groovy/shell" {<br/>};</span><span id="7a1f" class="mt lc iq ni b gy nv ns l nt nu">grant codeBase "file:/groovy/script" {<br/>};</span></pre><p id="2bf8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有了策略文件后，我们可以通过添加以下命令行参数来应用它:</p><pre class="nj nk nl nm gt nn ni no np aw nq bi"><span id="6c5c" class="mt lc iq ni b gy nr ns l nt nu">-Djava.security.manager -Djava.security.policy=&lt;policy file&gt;</span></pre><h2 id="147d" class="mt lc iq bd ld mu mv dn lh mw mx dp ll ko my mz lp ks na nb lt kw nc nd lx ne bi translated">步骤2:管理策略违规</h2><p id="9ecd" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果你是绿地开发项目中的少数幸运儿，就没有必要担心这一点。但是如果你像我一样，试图保护一个现有的环境，肯定会有例外。现有的Groovy脚本可能需要策略文件中没有授予的权限。</p><p id="719c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我建议您使用<a class="ae kc" href="https://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/security/AccessController.html" rel="noopener ugc nofollow" target="_blank">access controller . doprivileged</a>调用，而不是更改策略文件来授予缺失的权限。该方法以“特权”方式执行代码块，这意味着没有权限检查。重要的是这段代码要尽可能的小。我提倡这种方法的原因是方法调用很容易识别，因此可以在不久的将来纠正。</p><p id="398b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们将看看Groovy提供的帮助保护脚本执行的具体措施。</p><h2 id="6e2a" class="mt lc iq bd ld mu mv dn lh mw mx dp ll ko my mz lp ks na nb lt kw nc nd lx ne bi translated">步骤3: Groovy绑定限制</h2><p id="f095" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">Groovy绑定是一种将变量传递给Groovy脚本的机制。如果Groovy脚本不可信，我们必须控制哪些内容可以传入Groovy脚本。这一点尤其正确，因为并非所有第三方库API都受到权限检查的保护。</p><h2 id="c989" class="mt lc iq bd ld mu mv dn lh mw mx dp ll ko my mz lp ks na nb lt kw nc nd lx ne bi translated">步骤4:应用Groovy脚本编译器配置</h2><p id="f447" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">Groovy脚本编译器也可以由不同的编译定制器定制。例如，<code class="fe nf ng nh ni b">ImportCustomizer</code>可以限制Groovy脚本可以导入的内容，而<code class="fe nf ng nh ni b">SecureASTCustomizer</code>试图限制Groovy脚本可以使用的结构。不幸的是，正如本文所述，这两种方法都可以很容易地解决:<a class="ae kc" href="https://kohsuke.org/2012/04/27/groovy-secureastcustomizer-is-harmful/" rel="noopener ugc nofollow" target="_blank">https://KOH suke . org/2012/04/27/groovy-secureeastcustomizer-is-habital/</a>(作者来自Jenkins的Kohsuke Kawaguchi)。这是一篇理解这些定制器局限性的好文章。</p><p id="36e6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，川口先生好心在Github上发布了Groovy沙盒项目:<a class="ae kc" href="https://github.com/jenkinsci/groovy-sandbox" rel="noopener ugc nofollow" target="_blank">https://github.com/jenkinsci/groovy-sandbox</a>和脚本安全插件(詹金斯专用):<a class="ae kc" href="https://github.com/jenkinsci/script-security-plugin" rel="noopener ugc nofollow" target="_blank">https://github.com/jenkinsci/script-security-plugin</a>。这两个项目绝对值得研究，以便有可能集成到您的项目中。</p><h1 id="58da" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">其他考虑</h1><p id="1c00" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">除了上述考虑之外，您还需要管理Groovy脚本可以消耗多少CPU和内存。如果这是您所关心的，您可以在不同于主程序的线程中执行Groovy脚本。如果有必要，可以使用一个监控线程来终止Groovy脚本线程。</p><p id="d7e7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在一个单独的容器中运行Groovy脚本也可以提供进一步的保护，但是它的操作成本更高，并且不容易调整到现有的实现中。</p><h1 id="2e6a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">最后的想法</h1><p id="8d77" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">根据定义，执行不受信任的代码是一件危险的事情。保护执行环境的选项可能会受到现有实现的限制。没有两个项目是相同的。通过在这里总结我的发现，我希望你也能从中受益。</p><h1 id="8504" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">附言（同postscript）；警官（police sergeant）</h1><p id="cbb5" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在这次练习中，我学到了很多东西。很难将它们融入文章的流程中。因此，我将把它们列在这里:</p><ol class=""><li id="7d55" class="me mf iq kf b kg kh kk kl ko mg ks mh kw mi la mj mk ml mm bi translated">Java安全管理器是一个系统级设置。要在每个线程的基础上控制权限检查，您必须编写自己的安全管理器，并使用<code class="fe nf ng nh ni b">ThreadLocal</code>来条件化权限检查。</li><li id="6936" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">同样，自定义安全管理器可以与自定义类加载器一起使用，以提供更大的灵活性。</li><li id="8aad" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">Java访问控制是基于代码库的，即代码是从哪里加载的。我发现在JUnit测试中运行Groovy脚本没有<code class="fe nf ng nh ni b">file:/groovy/shell</code>或<code class="fe nf ng nh ni b">file:/groovy/script</code>代码库。相反，它们继承了JUnit类的代码库。我花了无数令人沮丧的时间来调试本该正常工作的东西。</li><li id="552e" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">类似地，在开发过程中，运行Maven Spring Boot插件的Spring Boot应用程序具有不同的代码基础。你应该同时授予<code class="fe nf ng nh ni b">${user.dir}/target/classes</code>和<code class="fe nf ng nh ni b">${user.home}/.m2/repository</code>权限</li><li id="8280" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">策略可以通过编程方式添加，也可以使用策略文件添加。</li></ol></div></div>    
</body>
</html>