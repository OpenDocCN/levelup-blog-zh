<html>
<head>
<title>Curiosity Strikes! The Intricacies Before main() in C</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">好奇心来袭！C语言中main()之前的错综复杂</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/curiosity-strikes-the-intricacies-before-main-in-c-d4327714f8ee?source=collection_archive---------18-----------------------#2020-06-09">https://levelup.gitconnected.com/curiosity-strikes-the-intricacies-before-main-in-c-d4327714f8ee?source=collection_archive---------18-----------------------#2020-06-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/14b73c26402e19c6d3677f37137347ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7_Z7QZWhqnN8PWIbGVbgSA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">主之前的创世纪()</figcaption></figure><p id="5411" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在本文中，我将讨论通用嵌入式设备中的C程序如何进入main()。我这样写是因为网上的无数解释都是针对特定设备的。他们使用了许多特定于架构的术语，混淆了嵌入式设备复位机制背后的基本原理。我的目标是用简单的术语向您解释设备如何准备自己，以便main()可以完成它的工作。我希望这将为您的嵌入式系统工具箱打下坚实的基础。</p><p id="cc99" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">准备好了吗？让我们打开引擎盖下的东西😉</p><p id="040a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">你有没有注意到，每次你试图打开一个设备(从完全关机的状态)，在你看到主屏幕之前有相当长的等待时间？以你的手机为例，在你看到手机制造商的标志之前，它需要几秒钟(甚至几分钟)才能启动。在这段等待的时间里，你可能会也可能不会想它为什么会这样。如果你这样做，下面的讨论概述了一个非常简单的设备复位机制的解释。</p><h1 id="c070" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">用一个类比来解释Reset处理程序和main()</h1><p id="fc69" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">当您打开支持数字的设备时(假设从其复位状态(如完全断电状态)开始)，会执行数百条指令来调整设备，以准备好服务于最终用户命令它做的事情。有一个隐藏得很好的回调函数，通常称为Reset Handler，在将系统移交给main()之前执行这数百个步骤。我在解释这一点时经常使用的一个很好的类比是，当你给某人冲一杯速溶咖啡时，可能很简单:</p><ol class=""><li id="7bdb" class="md me iq ke b kf kg kj kk kn mf kr mg kv mh kz mi mj mk ml bi translated">打开咖啡袋</li><li id="8317" class="md me iq ke b kf mm kj mn kn mo kr mp kv mq kz mi mj mk ml bi translated">将小袋中的内容物倒入杯中</li><li id="cae4" class="md me iq ke b kf mm kj mn kn mo kr mp kv mq kz mi mj mk ml bi translated">向杯中加入热水</li><li id="9b01" class="md me iq ke b kf mm kj mn kn mo kr mp kv mq kz mi mj mk ml bi translated">搅动杯子</li><li id="cf7b" class="md me iq ke b kf mm kj mn kn mo kr mp kv mq kz mi mj mk ml bi translated">为顾客服务</li><li id="bdd2" class="md me iq ke b kf mm kj mn kn mo kr mp kv mq kz mi mj mk ml bi translated">顾客要么开始啜饮咖啡，要么先让咖啡冷却到他或她想要的温度，等等</li></ol><p id="633d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">事实上，即使像端一杯速溶咖啡这么简单，你还是要在把咖啡递给那个人之前做一些准备。您可以将它看作是由Reset处理程序执行的第1步到第5步，第6步由main()完成。</p><h1 id="bcc1" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">仔细看看CPU、Reset_Handler()和main()</h1><p id="8955" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">那么，设备如何知道如何找到复位处理程序并执行初步步骤呢？</p><p id="7436" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">嗯，现在的设备通常都有内置的CPU，它被预编程为包含复位处理程序入口点的内存地址。为了更好地理解，请看下图。</p><figure class="ms mt mu mv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mr"><img src="../Images/f99f5f95271595b1e1aa588b647c9162.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w3Esdp1PKIQuDNN3FXorNg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">在CPU获得addr_x的内容(即addr_y)后，PC现在指向复位处理程序</figcaption></figure><p id="63e6" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">当执行设备复位时，CPU <em class="mw">跳转</em>到包含信息的特定存储器地址(addr_x )(另一个存储器地址addr_y)。CPU将<em class="mw">加载</em>该信息(addr_y)到它自己的内部寄存器PC(程序计数器),该寄存器指向要执行的下一个<em class="mw">指令</em>,在这种情况下，是复位处理器()函数入口点。从这一点来说，大量的初始化被顺序执行，以使整个系统准备好执行高级应用任务。在最后一步，在先决条件步骤完成之后，处理程序<em class="mw">跳转</em>到内存地址(addr_z)，main()的入口点。</p><h1 id="3bba" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">摘要</h1><p id="0c86" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">总之，我已经讨论了通用嵌入式设备如何在调用main()之前设置自己，而没有深入研究特定于设备的架构，如ARM、PIC、AVR，甚至8051。也就是说，在预引导阶段，CPU的程序计数器(PC)最初包含复位处理程序的地址。CPU <em class="mw">跳转</em>到那个地址，并执行处理程序中的任何内容(通常是初始化例程)。重置处理程序的最后一步将使CPU <em class="mw">跳转到main()入口点，应用程序代码驻留在那里为最终用户服务。</em></p><p id="5e03" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这就是了。现在，您已经掌握了嵌入式设备复位机制的基本技术知识。如果你真的很好奇，可以随意调整这个概念并实现你自己的重置机制。希望这篇文章对你有用！</p></div></div>    
</body>
</html>