<html>
<head>
<title>JavaScript Built-In Functions and Objects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript内置函数和对象</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/lesson-6-javascript-built-in-functions-and-objects-fullstackroadmap-9834a2d6125a?source=collection_archive---------28-----------------------#2021-01-19">https://levelup.gitconnected.com/lesson-6-javascript-built-in-functions-and-objects-fullstackroadmap-9834a2d6125a?source=collection_archive---------28-----------------------#2021-01-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8172" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">#fullstackroadmap第6课</h2></div><p id="1a88" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae le" href="https://www.youtube.com/watch?v=O3iR-CIufKM" rel="noopener ugc nofollow" target="_blank">点击这里查看YouTube上的这一课</a></p><p id="3b1f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是我的fullstack开发者系列的一部分，在这个系列中，你将从没有编写过一行代码，到将你的第一个fullstack web应用程序部署到互联网上。<a class="ae le" href="https://www.zachgollwitzer.com/posts/2021/fullstack-developer-series/introduction/" rel="noopener ugc nofollow" target="_blank">点击此链接</a>了解这个系列的内容。</p><p id="c0f7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请在Twitter <a class="ae le" href="https://twitter.com/zg_dev" rel="noopener ugc nofollow" target="_blank"> @zg_dev </a>上给我加标签，并与<a class="ae le" href="https://twitter.com/search?q=%23100DaysOfCode&amp;src=typed_query" rel="noopener ugc nofollow" target="_blank"> #100DaysOfCode </a>分享这个系列！</p><h1 id="0e02" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">有用的系列链接</h1><ul class=""><li id="3ded" class="lx ly it kk b kl lz ko ma kr mb kv mc kz md ld me mf mg mh bi translated"><a class="ae le" href="https://www.zachgollwitzer.com/posts/2021/fullstack-developer-series/fullstack-roadmap-toc" rel="noopener ugc nofollow" target="_blank">系列目录</a></li><li id="6b0a" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld me mf mg mh bi translated"><a class="ae le" href="https://github.com/zachgoll/fullstack-roadmap-series" rel="noopener ugc nofollow" target="_blank"> Github仓库</a>——在这里你可以找到我们在这个系列中编写的所有代码</li><li id="c1a3" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld me mf mg mh bi translated"><a class="ae le" href="https://www.youtube.com/watch?v=ZZJT5uskuvI&amp;list=PLYQSCk-qyTW37zDPzcAyzCsnypFQrhUcq" rel="noopener ugc nofollow" target="_blank"> YouTube播放列表</a></li><li id="7300" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld me mf mg mh bi translated"><a class="ae le" href="https://www.zachgollwitzer.com/posts/2021/fullstack-developer-series/introduction/" rel="noopener ugc nofollow" target="_blank">系列概述</a></li><li id="5fb2" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld me mf mg mh bi translated"><a class="ae le" href="https://www.100daysofcode.com/" rel="noopener ugc nofollow" target="_blank"> 100天的代码挑战</a>——我强烈建议你在阅读本系列时接受这个挑战！</li><li id="154d" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld me mf mg mh bi translated">我的CodeWars档案——跟着我，我会跟着你回来。这是我们在整个系列中进行编码挑战的地方！</li><li id="41c6" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld me mf mg mh bi translated">我的推特资料——你可以在那里了解最新消息</li></ul><h1 id="6301" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">本课的目标是</h1><p id="8fb7" class="pw-post-body-paragraph ki kj it kk b kl lz ju kn ko ma jx kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">在之前的课程中，我们讨论了JavaScript的许多基本部分，在我们的<a class="ae le" href="https://www.youtube.com/watch?v=sqRk0Ly66Ps" rel="noopener ugc nofollow" target="_blank"> 25代码挑战</a>中，我们甚至探索了一些内置的JavaScript方法。</p><p id="35f1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这一课中，我不仅将教您如何阅读JavaScript MDN文档，还将向您展示开发人员可能会看到的最常见的内置对象和函数。</p><p id="ace2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我策划了10个代码挑战，这些挑战将强化帖子中解释的一些概念。</p><p id="f0ab" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是我们将涉及的主题。</p><ul class=""><li id="7667" class="lx ly it kk b kl km ko kp kr mq kv mr kz ms ld me mf mg mh bi translated">如何阅读文档</li><li id="a041" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld me mf mg mh bi translated">快速启动回调函数</li><li id="1357" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld me mf mg mh bi translated">原语与对象(在前面的课程中我一直在撒谎)</li><li id="ec65" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld me mf mg mh bi translated">日期</li><li id="9889" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld me mf mg mh bi translated">正则表达式</li><li id="c9cb" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld me mf mg mh bi translated">常见字符串方法</li><li id="ddb6" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld me mf mg mh bi translated">常见数组方法</li><li id="b038" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld me mf mg mh bi translated">数学图书馆</li><li id="0586" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld me mf mg mh bi translated">错误类型</li><li id="0ace" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld me mf mg mh bi translated">NaN，空，未定义</li></ul><p id="67bc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这将是我们讨论JavaScript基础知识系列的最后一篇文章。如果你想在我们讨论的基础上继续深造，我强烈推荐<a class="ae le" href="https://github.com/getify/You-Dont-Know-JS/tree/1st-ed" rel="noopener ugc nofollow" target="_blank">你不懂JavaScript </a>。</p><p id="1ef9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">还有额外的JavaScript概念，比如async/await、Promises和Classes，但是在我们具备HTML、CSS和JavaScript的基础知识之前，我们可能不会涉及这些概念。我确实打算报道他们，但还不是时候。</p><h1 id="a89a" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">如何阅读文档</h1><p id="76fa" class="pw-post-body-paragraph ki kj it kk b kl lz ju kn ko ma jx kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">我们将从一个作为程序员必须具备的非常重要的技能开始。你可能听过这个说法，RTFM，代表“阅读f********手册”。这在软件工程中很常见，因为大多数问题都可以通过阅读文档来解决。当我说“文档”的时候，我只是指那些解释如何使用某个框架、库或编程语言的指导性指南。</p><p id="da14" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为到目前为止我们只接触了JavaScript，所以最常见的文档来源是MDN (Mozilla Developer Network)。<a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript" rel="noopener ugc nofollow" target="_blank">这是JavaScript文档</a>的主页。</p><p id="505d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">每种语言/框架/库的文档会有所不同，但是高质量的文档通常为开发人员提供以下资源。</p><ol class=""><li id="96f3" class="lx ly it kk b kl km ko kp kr mq kv mr kz ms ld mt mf mg mh bi translated">快速入门或概述指南</li><li id="2070" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld mt mf mg mh bi translated">延伸教程</li><li id="4730" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld mt mf mg mh bi translated">API引用(通常简称为“引用”或“API”)</li></ol><p id="9b98" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">每当我开始学习一个新的框架时，快速入门和教程都是学习基础知识的好方法，然后我会在构建项目时根据需要参考API参考(以及非官方教程)。</p><p id="2fe1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference" rel="noopener ugc nofollow" target="_blank">这里是JavaScript编程语言的API引用</a>。由于JavaScript如此广泛，有几个网站提供了API参考，但通常，框架和库只有一套“官方”文档。</p><p id="e022" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当你翻阅JavaScript的参考资料时，你可能会感到困惑，这没关系。记住，参考文献记录了JavaScript的所有内容。不需要像读书一样去读。将其作为参考(因此得名)。</p><p id="1602" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设你正在解决上节课练习题中的一个<a class="ae le" href="https://www.youtube.com/watch?v=sqRk0Ly66Ps&amp;t=1833s" rel="noopener ugc nofollow" target="_blank">，你想了解更多关于我们在数组上使用的<code class="fe mu mv mw mx b">push()</code>方法。这是你到达那里的方法。</a></p><ol class=""><li id="f9cd" class="lx ly it kk b kl km ko kp kr mq kv mr kz ms ld mt mf mg mh bi translated">转到<a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference" rel="noopener ugc nofollow" target="_blank"> JavaScript参考</a></li><li id="d14f" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld mt mf mg mh bi translated">由于<code class="fe mu mv mw mx b">push()</code>是一个数组方法，找到数组数据类型<a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array" rel="noopener ugc nofollow" target="_blank">点击它</a>。</li><li id="64ad" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld mt mf mg mh bi translated">向下滚动到“实例方法”并<a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/push" rel="noopener ugc nofollow" target="_blank">点击推送方法</a>。</li><li id="a210" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld mt mf mg mh bi translated">阅读解释这个方法如何工作的那一页</li></ol><p id="b3de" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第四步说起来容易做起来难。阅读文档对初学者来说很难，所以让我们来看看如何去做。</p><h1 id="b9c6" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">概述部分</h1><p id="248c" class="pw-post-body-paragraph ki kj it kk b kl lz ju kn ko ma jx kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">我们来看一个叫做<code class="fe mu mv mw mx b">pop()</code>的数组方法。这是最简单的学习方法之一。<a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/pop" rel="noopener ugc nofollow" target="_blank">这里是截图来自</a>的文档。</p><figure class="mz na nb nc gt nd gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi my"><img src="../Images/d1c45417b9aa013b7b36efd4266192b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4iDQ9xmz0YVbSTKM"/></div></div></figure><p id="4eda" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">文档通常从函数的概述开始。这通常是你需要的唯一信息。从这个概述中，我们可以看到<code class="fe mu mv mw mx b">pop()</code>方法移除数组的最后一个元素(即修改原始数组)并返回被移除的元素。</p><p id="9dec" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是也许概述部分没有提供您需要的所有信息。向下滚动到语法部分。</p><h1 id="8104" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">句法</h1><p id="3eb2" class="pw-post-body-paragraph ki kj it kk b kl lz ju kn ko ma jx kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">这一节可能是记录一个函数最直接的方式。这向您解释了函数分别接收和返回的输入和输出。一旦你擅长阅读文档，并且对编程有了大体的了解，这一节通常就是你开始使用一个给定函数所需要的全部。</p><p id="5806" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们继续使用<code class="fe mu mv mw mx b">array.pop()</code>方法。</p><figure class="mz na nb nc gt nd gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/3daeebf0f1c1a3e04a38b0d02e06a61a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1174/0*PTc74eLe1mlhQlcQ"/></div></figure><p id="7f46" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过观察这一点，我们可以推断出<code class="fe mu mv mw mx b">pop()</code>方法不接受任何参数，并返回被移除的数组的值。</p><p id="6ef0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">与overview部分不同，这里还注意到，如果您在空数组上使用<code class="fe mu mv mw mx b">pop</code>方法，它将返回<code class="fe mu mv mw mx b">undefined</code>。您可以在您的开发工具控制台中进行尝试。</p><figure class="mz na nb nc gt nd"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="2d5b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们看看另一个稍微复杂一点的方法。这里是<code class="fe mu mv mw mx b">array.join()</code>方法的“语法”部分(<a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/join" rel="noopener ugc nofollow" target="_blank">链接到第</a>页)。</p><figure class="mz na nb nc gt nd gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi nn"><img src="../Images/67fb46220defb782ced273fca25167a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jn_ZRB-PUrar3fOU"/></div></div></figure><p id="9b21" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">与<code class="fe mu mv mw mx b">array.pop()</code>方法不同，这个方法只有一个可选的参数。我们可以看出这个参数是可选的，因为<code class="fe mu mv mw mx b">[separator]</code>周围有<code class="fe mu mv mw mx b">[]</code>。此外，在参数部分，它表示这是可选的。</p><p id="3a9b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">查看返回值，可以看到该方法返回一个字符串值，其中给定数组的所有元素都连接在一起。它还指出，如果您试图在空数组上使用此方法，返回值将是一个空字符串。</p><p id="a09e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是如何将这个文档翻译成代码。</p><figure class="mz na nb nc gt nd"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="5da7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是<code class="fe mu mv mw mx b">push()</code>方法的语法部分。</p><figure class="mz na nb nc gt nd gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi no"><img src="../Images/3612e9797026160eebbd162b7e683829.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QkYdMXh1qnr1tJz9"/></div></div></figure><p id="6042" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们从这部分开始:</p><figure class="mz na nb nc gt nd"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="9482" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这到底是怎么回事？！这试图解释的是函数的参数。首先，括号<code class="fe mu mv mw mx b">[]</code>表示参数是可选的(不要与我们之前学习的数组括号语法混淆)。在这种情况下，如果不传递参数，数组将保持不变。其次，你会注意到<code class="fe mu mv mw mx b">...</code>，它告诉我们这个方法接受无限数量的参数。</p><p id="18dd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们查看返回值时，我们可以看到它在推送操作后返回新数组的长度。看看下面的代码，猜猜<code class="fe mu mv mw mx b">result</code>变量等于什么。</p><figure class="mz na nb nc gt nd"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="ec26" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不，正如你所料，<code class="fe mu mv mw mx b">result</code>不等于<code class="fe mu mv mw mx b">[1, 2, 3, 4, 5, 6, 7, 8, 9]</code>。<code class="fe mu mv mw mx b">result</code>变量等于<code class="fe mu mv mw mx b">9</code>(新数组的长度)<code class="fe mu mv mw mx b">arr</code>等于新数组。</p><p id="adb9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你可能会问——我们用关键字<code class="fe mu mv mw mx b">const</code>分配了它，那么我们如何重新分配它呢？！我不想离题太远，所以<a class="ae le" href="https://stackoverflow.com/a/45597013/7437737" rel="noopener ugc nofollow" target="_blank">如果你好奇就去读读这个</a>。</p><p id="10d8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">好，让我们再看一个例子。</p><figure class="mz na nb nc gt nd gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi np"><img src="../Images/01262470bb6c4fe8ad785fc584ced054.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*33SnDr8e8h2SyTl-"/></div></div></figure><p id="f925" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，您会看到这个函数有两个参数。<code class="fe mu mv mw mx b">valueToFind</code>参数是必需的，而<code class="fe mu mv mw mx b">fromIndex</code>是可选的(您会注意到在其描述的底部，它说它默认为0)。</p><p id="84e5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">返回值是一个布尔值，它表明<code class="fe mu mv mw mx b">valueToFind</code>是否存在于我们正在搜索的<code class="fe mu mv mw mx b">arr</code>中。</p><p id="ffca" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">利用上面的信息，我们可以尝试使用这种方法的几种不同方式。</p><figure class="mz na nb nc gt nd"><div class="bz fp l di"><div class="nl nm l"/></div></figure><h1 id="0c10" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">示例、规格、浏览器兼容性</h1><p id="2dde" class="pw-post-body-paragraph ki kj it kk b kl lz ju kn ko ma jx kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">您将在文档中看到的与上述类似的特定方法的其余部分是有用的，但并不总是必需的。</p><p id="be19" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">示例部分是不言自明的。规范部分将向您展示在ECMAScript标准中的什么地方可以找到这种方法(还记得第2课吗？).</p><p id="6686" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，浏览器兼容性将向您展示该功能可以在哪些浏览器中正常工作。如果你看一下<code class="fe mu mv mw mx b">arr.includes()</code>方法，它不能在Internet Explorer中工作，所以如果你正在构建一个需要在IE中工作的应用程序(比如在一个大公司中)，你不应该使用<code class="fe mu mv mw mx b">arr.includes()</code>方法。一开始，我不会关注浏览器兼容性——学习编码已经够难的了！</p><h1 id="5578" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">回调函数:令人困惑，但很有必要</h1><p id="3bb1" class="pw-post-body-paragraph ki kj it kk b kl lz ju kn ko ma jx kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">在我们开始探索不同的内置JavaScript函数之前，您至少需要对回调函数有一个大致的了解。</p><p id="edfa" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不，这不是编写函数的不同类型。它们代表了使用函数的不同方式。</p><p id="9d67" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里是一些真正令人困惑的代码，我希望你从现在起有5分钟的基本理解。</p><figure class="mz na nb nc gt nd"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="0ecf" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这也可以简化为以下内容(做完全相同的事情):</p><figure class="mz na nb nc gt nd"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="ac8e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不幸的是，对于初学者来说，第二段代码是你最常看到的，因为它更简洁。</p><p id="c666" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们带着一些注释浏览第一个代码块。</p><figure class="mz na nb nc gt nd"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="878e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以通过给<code class="fe mu mv mw mx b">myCallback</code>打电话得到同样的结果。</p><figure class="mz na nb nc gt nd"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="fd77" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mu mv mw mx b">myCallback</code>没什么特别的。它只是一个函数，但是我们可以让<code class="fe mu mv mw mx b">mainFunction</code>为我们做，而不是单独调用这个函数！放大<code class="fe mu mv mw mx b">result = callback(randomNumber)</code>，您可以看到我们正在获取<code class="fe mu mv mw mx b">randomNumber</code>的值，在本例中是<code class="fe mu mv mw mx b">20</code>，并将其作为参数传递给<code class="fe mu mv mw mx b">callback</code>。什么是<code class="fe mu mv mw mx b">callback</code>？这是我们作为参数传入的函数。</p><p id="2ad1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以让我们用我们刚刚定义的函数，<code class="fe mu mv mw mx b">myCallback</code>，并把它作为一个参数传递给<code class="fe mu mv mw mx b">mainFunction</code>！</p><figure class="mz na nb nc gt nd"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="ad01" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当然，您不必将<code class="fe mu mv mw mx b">myCallback</code>定义为一个单独的函数。你可以用匿名函数或者箭头函数来实现。所有这些都会产生相同的结果。</p><figure class="mz na nb nc gt nd"><div class="bz fp l di"><div class="nl nm l"/></div></figure><h1 id="cd25" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">那么…回调有什么意义？</h1><p id="62b2" class="pw-post-body-paragraph ki kj it kk b kl lz ju kn ko ma jx kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">有两个优点:</p><ol class=""><li id="8907" class="lx ly it kk b kl km ko kp kr mq kv mr kz ms ld mt mf mg mh bi translated">功能的可重用性</li><li id="f898" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld mt mf mg mh bi translated">异步编程</li></ol><h2 id="b458" class="nq lg it bd lh nr ns dn ll nt nu dp lp kr nv nw lr kv nx ny lt kz nz oa lv ob bi translated">回调支持可重用性</h2><p id="c7ba" class="pw-post-body-paragraph ki kj it kk b kl lz ju kn ko ma jx kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">我们来看一个名为<code class="fe mu mv mw mx b">arr.map()</code>的内置JavaScript函数。<a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map" rel="noopener ugc nofollow" target="_blank">您可以在这里找到文档</a>，我鼓励您在我们开始讨论它之前尝试并弄清楚它。</p><figure class="mz na nb nc gt nd"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="8e89" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这个例子中，我将<code class="fe mu mv mw mx b">myCustomMapOperation</code>作为我的“回调”函数传递给内置的<code class="fe mu mv mw mx b">arr.map()</code> JavaScript函数。我写的这个自定义回调函数将使数组中的值加倍。</p><p id="3330" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是，如果我的数组中填充了字符串值，而我想创建一个只包含每个字符串的第一个字母的新数组，该怎么办呢？难道我不需要去寻找另一个内置的JavaScript函数来做这件事吗？</p><p id="bfe9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不要！！</p><p id="92d7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">回调函数使得东西可以重用。由于我们作为开发人员负责定义回调函数将做什么，我们可以出于各种目的重用<code class="fe mu mv mw mx b">arr.map()</code>函数。以下是我如何实现我刚才提出的想法。</p><figure class="mz na nb nc gt nd"><div class="bz fp l di"><div class="nl nm l"/></div></figure><h2 id="8cef" class="nq lg it bd lh nr ns dn ll nt nu dp lp kr nv nw lr kv nx ny lt kz nz oa lv ob bi translated">异步编程:回调、承诺和异步等待</h2><p id="1950" class="pw-post-body-paragraph ki kj it kk b kl lz ju kn ko ma jx kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">是的，我说了。“异步”是一个你将学会同时又爱又恨的词。</p><p id="16b1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在编程中，并不是所有的操作都像我们编写的代码一样几乎是即时发生的。例如，当一个web应用程序需要从数据库中获取一些数据，而当天互联网很慢时，会发生什么情况？此操作将需要几秒钟的时间，这取决于您的互联网的延迟。</p><p id="4a76" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你可能会说——那么，让我们等到它完成后再执行任何代码？</p><p id="7d63" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">回答错误，但想法不错。我们不能只是等待它发生，因为在许多应用程序中，有数百个这样的操作同时发生，如果我们等待每个操作，我们的网页将需要几分钟才能加载。没人想这样。</p><p id="8dba" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这一课中，我们不会深入到任何代码中，但将来会有一课专门讲述异步编程，因为这是一个很大的主题，可能会相当混乱。</p><h1 id="18bc" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">原语与对象</h1><p id="996a" class="pw-post-body-paragraph ki kj it kk b kl lz ju kn ko ma jx kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">如果您一直关注本系列课程，您可能已经听到我说过“JavaScript中的一切都是对象”。直到现在，我也没有解释清楚。</p><p id="4ec4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是因为我们将在这一课中讨论很多内置的JavaScript函数和对象，所以您需要对原语和对象有一个基本的了解。</p><p id="1d27" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我的意思是:</p><figure class="mz na nb nc gt nd"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="1786" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">还记得第三课的<code class="fe mu mv mw mx b">===</code>和<code class="fe mu mv mw mx b">==</code>吗？三重等于比较<em class="oc">类型</em>和<em class="oc">值</em>。Double equals只是比较<em class="oc">值</em>。</p><p id="aac2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这些“字符串”的值相等，但类型不相等(一个是对象，一个是字符串)。</p><p id="8011" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你可能在想——“所以你告诉我<code class="fe mu mv mw mx b">string1</code>不是一个字符串？？？!"。</p><p id="0ed8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这正是我要告诉你的。此外，有些人可能认为<code class="fe mu mv mw mx b">string2</code>不是一个字符串，因为它上面有“方法”。例如:</p><figure class="mz na nb nc gt nd"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="d41f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一个“字符串”怎么会有这样的方法呢？我们不会详细回答这个问题，但我想至少回答一下。</p><h1 id="3a6c" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">什么是原始值？</h1><p id="6eb2" class="pw-post-body-paragraph ki kj it kk b kl lz ju kn ko ma jx kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">把“原语”想象成某物最简单的形式。如果一种编码语言有一个“元素周期表”，它将被“原语”填充。</p><p id="ae20" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在JavaScript中，有六种原语。</p><ol class=""><li id="c265" class="lx ly it kk b kl km ko kp kr mq kv mr kz ms ld mt mf mg mh bi translated">线</li><li id="3092" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld mt mf mg mh bi translated">数字</li><li id="8a31" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld mt mf mg mh bi translated">bigint</li><li id="b503" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld mt mf mg mh bi translated">布尔型</li><li id="a34a" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld mt mf mg mh bi translated">不明确的</li><li id="8eed" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld mt mf mg mh bi translated">标志</li></ol><p id="099b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还没有谈到所有这些，没关系。</p><p id="2558" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一个“原始”数据类型没有任何附加的“方法”，但是在幕后，JavaScript <em class="oc">将</em>原始值与它们对应的对象值包装在一起。这就是为什么<code class="fe mu mv mw mx b">'some string'.toUpperCase()</code>是有效的JavaScript代码。</p><h1 id="3094" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">那我该怎么办？</h1><p id="8d1f" class="pw-post-body-paragraph ki kj it kk b kl lz ju kn ko ma jx kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">我创建了课程系列的这一部分，因为这是我在学习JavaScript时遇到的一个问题。</p><p id="5b13" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我建议您将此视为“值得注意”的信息，但不要再进一步。一旦你更有经验了，你就可以回去学习JavaScript语言的底层细节。如果你和我一样是个天生好奇的人，我建议你先看看下面的简短资源，然后再回到课上。</p><ul class=""><li id="3f08" class="lx ly it kk b kl km ko kp kr mq kv mr kz ms ld me mf mg mh bi translated"><a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String#string_primitives_and_string_objects" rel="noopener ugc nofollow" target="_blank">字符串原语与字符串对象</a></li><li id="3b9b" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld me mf mg mh bi translated"><a class="ae le" href="https://developer.mozilla.org/en-US/docs/Glossary/Primitive" rel="noopener ugc nofollow" target="_blank">什么是原语？</a></li></ul><p id="75ab" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们回到本节开头的代码，用一些注释来结束我们对原语的简短讨论。</p><figure class="mz na nb nc gt nd"><div class="bz fp l di"><div class="nl nm l"/></div></figure><h1 id="7d92" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">这个“新”关键词是什么？</h1><p id="af9f" class="pw-post-body-paragraph ki kj it kk b kl lz ju kn ko ma jx kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">我想访问这一部分的另一个原因是，随着我们进入JavaScript日期等主题(下一部分)，您将开始看到一个JavaScript关键字，<code class="fe mu mv mw mx b">new</code>。</p><p id="be8e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从技术上讲，<code class="fe mu mv mw mx b">new</code>是一个运算符，但是我们在关于运算符的课程中没有涉及到它。下面是<code class="fe mu mv mw mx b">new</code>操作员做的事情:</p><ol class=""><li id="6f99" class="lx ly it kk b kl km ko kp kr mq kv mr kz ms ld mt mf mg mh bi translated">创建一个空白JavaScript对象</li><li id="29df" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld mt mf mg mh bi translated">将这个新对象链接到“父”对象</li></ol><p id="8691" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">实际上还有一些额外的步骤，但与我们无关。</p><p id="9b20" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">简单地说，<code class="fe mu mv mw mx b">new</code>操作符创建一个现有对象的“实例”。我们将在本系列的后面重新讨论这个概念。现在，每当你看到<code class="fe mu mv mw mx b">new</code>操作符，就像这样想:</p><ol class=""><li id="071d" class="lx ly it kk b kl km ko kp kr mq kv mr kz ms ld mt mf mg mh bi translated">我们有一些现有的，预定义的对象，如<code class="fe mu mv mw mx b">Date</code></li><li id="226b" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld mt mf mg mh bi translated">我们想要一个可以存储在变量中对象的“副本”</li><li id="91ef" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld mt mf mg mh bi translated">所以…我们使用<code class="fe mu mv mw mx b">Date</code>作为“模板”来创建“副本”</li></ol><p id="fd4a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">说到约会…</p><h1 id="7eb1" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">日期</h1><p id="5e8d" class="pw-post-body-paragraph ki kj it kk b kl lz ju kn ko ma jx kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated"><a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date" rel="noopener ugc nofollow" target="_blank">官方文件</a>。</p><p id="ebeb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我要告诉你一个秘密——大多数开发人员都不太了解JavaScript日期。如果日期最初让你困惑，不要担心。如果你有兴趣深入研究，我有一整篇文章解释它们。</p><p id="8efc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">无论如何，这里是快速启动。创建一个新的日期对象(记住，<code class="fe mu mv mw mx b">new</code>只是创建了一个<code class="fe mu mv mw mx b">Date</code>模板的“副本”):</p><figure class="mz na nb nc gt nd"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="ec30" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">存储在此date对象中的值表示自UTC 1970年1月1日午夜以来经过的毫秒数。</p><p id="d4e9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以通过使用<code class="fe mu mv mw mx b">valueOf()</code>方法来查看该值。</p><figure class="mz na nb nc gt nd"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="ba54" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为什么是1970年1月1日？什么是UTC？再次，<a class="ae le" href="https://www.zachgollwitzer.com/posts/2020/js-dates/" rel="noopener ugc nofollow" target="_blank">如果你好奇，请阅读我的详细帖子</a>。</p><p id="23be" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果要定义一个特定的日期，可以将各种参数传递给date对象。同样，如果你想知道更多的细节，请阅读我在JS Dates上的帖子。</p><figure class="mz na nb nc gt nd"><div class="bz fp l di"><div class="nl nm l"/></div></figure><h1 id="8065" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">一些有用的日期方法</h1><ul class=""><li id="f464" class="lx ly it kk b kl lz ko ma kr mb kv mc kz md ld me mf mg mh bi translated"><code class="fe mu mv mw mx b">toString()</code></li><li id="a1f5" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld me mf mg mh bi translated"><code class="fe mu mv mw mx b">toISOString()</code></li><li id="cb4b" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld me mf mg mh bi translated"><code class="fe mu mv mw mx b">getDate()</code></li><li id="f86a" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld me mf mg mh bi translated"><code class="fe mu mv mw mx b">getMonth()</code></li><li id="5ba6" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld me mf mg mh bi translated"><code class="fe mu mv mw mx b">getFullYear()</code></li></ul><p id="1429" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这些是常见的。欲了解更多信息，<a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date" rel="noopener ugc nofollow" target="_blank">请访问文档</a>。</p><p id="50b8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里有一个如何使用这些方法的简单例子。</p><figure class="mz na nb nc gt nd"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="8b2a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我认为现在已经足够了。你不需要成为JS约会的专家，但肯定需要有一些熟悉度。</p><h1 id="dc69" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">正则表达式</h1><p id="66b5" class="pw-post-body-paragraph ki kj it kk b kl lz ju kn ko ma jx kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">“正则表达式”几乎可以被认为是一种独立的语言(当然不是图灵全集)。正则表达式的目的是根据您定义的特定模式在字符串中查找字符。</p><p id="6feb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是一个复杂且令人困惑的话题，但是作为开发人员，您将使用正则表达式。下面是正则表达式的10，000英尺总结。如果你想了解更多细节，请阅读我的详细帖子。在您的旅程的这一点上，深入研究正则表达式可能不是首要任务。现在重要的是知道它们是什么，它们做什么，以及如何阅读它们——而不是如何写它们。</p><p id="e8d3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp" rel="noopener ugc nofollow" target="_blank">这里是正则表达式的文档</a>。</p><p id="332d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以用来解释为什么正则表达式(通常缩写为“regex”或“regexp”)很重要的最好例子是表单数据的验证。</p><p id="f30f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设你有一个应用程序的用户注册表单，在过去的几周里，你已经收到了很多注册应用程序的无效电子邮件地址。你当然不想这样。你想要有效的电子邮件。</p><figure class="mz na nb nc gt nd gh gi paragraph-image"><div class="gh gi od"><img src="../Images/525ce882e7f3e298ae0b70d514f3f107.png" data-original-src="https://miro.medium.com/v2/resize:fit:670/0*AantrlQAIELbYW8J"/></div></figure><p id="e312" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了避免这种情况，您可以在注册用户之前用正则表达式验证用户的输入。下面是你可能做到这一点。</p><figure class="mz na nb nc gt nd"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="69fa" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">被认为是正则表达式，所有这些符号都代表非常具体的东西。这绝不是用来验证电子邮件的最好的正则表达式(它实际上忽略了很多场景)，但是它是我们的一个好的起点。</p><p id="176c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们解释这个模式之前，我想介绍一下正则表达式的基本知识。</p><p id="8ae4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">无论您使用哪种语言，正则表达式都遵循相同的结构。</p><ul class=""><li id="4440" class="lx ly it kk b kl km ko kp kr mq kv mr kz ms ld me mf mg mh bi translated">标识符</li><li id="7b12" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld me mf mg mh bi translated">量词</li></ul><h1 id="4bf0" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">标识符</h1><p id="f238" class="pw-post-body-paragraph ki kj it kk b kl lz ju kn ko ma jx kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">这些帮助您识别字符串中的字符。它们可以是任何东西，从单个字符到更高级的表达式。</p><p id="4d01" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，要识别包含字母<code class="fe mu mv mw mx b">g</code>的字符串，您可以这样做:</p><figure class="mz na nb nc gt nd"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="754d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你也可以检查整个单词。</p><figure class="mz na nb nc gt nd"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="a141" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正则表达式区分大小写，所以下面的表达式不匹配。</p><figure class="mz na nb nc gt nd"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="9e05" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">标识符不一定是字母、数字和单词。有“特殊”标识符可以识别<em class="oc">模式</em>。这里有一些常见的例子，但是你可以在我的<a class="ae le" href="https://www.zachgollwitzer.com/posts/2019/regexp-bash/" rel="noopener ugc nofollow" target="_blank">关于正则表达式的详细帖子</a>中找到更详尽的列表。</p><ul class=""><li id="27dd" class="lx ly it kk b kl km ko kp kr mq kv mr kz ms ld me mf mg mh bi translated"><code class="fe mu mv mw mx b">[A-Z]</code> -匹配所有大写字母</li><li id="ab14" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld me mf mg mh bi translated"><code class="fe mu mv mw mx b">[a-z]</code> -匹配所有小写字母</li><li id="5b54" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld me mf mg mh bi translated"><code class="fe mu mv mw mx b">[0-9]</code> -匹配所有数字</li><li id="2833" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld me mf mg mh bi translated"><code class="fe mu mv mw mx b">[A-Za-z0-9]</code> -匹配所有字母和数字</li><li id="e26f" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld me mf mg mh bi translated"><code class="fe mu mv mw mx b">.</code> -匹配任何字符(通配符)</li><li id="253d" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld me mf mg mh bi translated"><code class="fe mu mv mw mx b">\d</code> -匹配所有数字(另一种写法<code class="fe mu mv mw mx b">[0-9]</code>)</li><li id="97e6" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld me mf mg mh bi translated"><code class="fe mu mv mw mx b">\s</code> -匹配任何空白字符</li><li id="e3f1" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld me mf mg mh bi translated"><code class="fe mu mv mw mx b">\w</code> -匹配所有字母和数字(另一种写法<code class="fe mu mv mw mx b">[A-Za-z0-9]</code>)</li><li id="b088" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld me mf mg mh bi translated"><code class="fe mu mv mw mx b">^</code> -表示一行的开始</li><li id="dda8" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld me mf mg mh bi translated"><code class="fe mu mv mw mx b">$</code> -表示一行的结束</li><li id="8f92" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld me mf mg mh bi translated"><code class="fe mu mv mw mx b">(dog|cat)</code> -匹配“狗”或“猫”</li></ul><p id="cec1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们以<code class="fe mu mv mw mx b">[A-Za-z]</code>为例。这匹配所有字母(大写和小写)。</p><figure class="mz na nb nc gt nd"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="6a3e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">等等……如果<code class="fe mu mv mw mx b">[A-Za-z]</code>只匹配字母，那么为什么上面的表达式会返回<code class="fe mu mv mw mx b">true</code>？到目前为止，我们一直在使用<code class="fe mu mv mw mx b">test()</code>方法，它将检查您的正则表达式是否匹配字符串的任何部分。但是和哪个部分吻合呢？？要找出答案，您可以使用<code class="fe mu mv mw mx b">exec()</code>方法，它将返回一个数组，告诉您<em class="oc">在您的字符串中匹配了什么</em>。</p><figure class="mz na nb nc gt nd"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="0d82" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的例子中，数组的第一个元素是匹配的子字符串。第二个元素告诉你它是在字符串的哪个索引匹配的。在这种情况下，我们匹配每个字符串的第一个字母，它有一个<code class="fe mu mv mw mx b">0</code>索引。第三个元素是原始字符串，第四个元素显示匹配的组(但这是一个高级主题，我们不会讨论)。</p><p id="238e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么…为什么我们只匹配了每个字符串的第一个字母？<code class="fe mu mv mw mx b">[A-Za-z]</code>不都是字母匹配吗？</p><p id="89d0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">队列量词。</p><h1 id="2c7a" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">量词</h1><p id="e8aa" class="pw-post-body-paragraph ki kj it kk b kl lz ju kn ko ma jx kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">下面是量词。</p><ul class=""><li id="fc49" class="lx ly it kk b kl km ko kp kr mq kv mr kz ms ld me mf mg mh bi translated"><code class="fe mu mv mw mx b">*</code> -匹配0个或多个前面的字符</li><li id="f1fb" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld me mf mg mh bi translated"><code class="fe mu mv mw mx b">+</code> -匹配前面的一个或多个字符</li><li id="5b26" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld me mf mg mh bi translated"><code class="fe mu mv mw mx b">?</code> -匹配前面字符的0或1</li><li id="e905" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld me mf mg mh bi translated"><code class="fe mu mv mw mx b">{1}</code> -精确匹配前面的1个字符</li><li id="c606" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld me mf mg mh bi translated"><code class="fe mu mv mw mx b">{1,}</code> -匹配前面的一个或多个字符(等同于+)</li><li id="c1a9" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld me mf mg mh bi translated"><code class="fe mu mv mw mx b">{2,6}</code> -匹配前面字符的2到6个字符</li></ul><p id="d13c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这就是我们如何修改上面的代码来匹配所有的字母。通过在末尾添加<code class="fe mu mv mw mx b">*</code>，我们说，“匹配1个或多个字母”。</p><figure class="mz na nb nc gt nd"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="78f2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您会注意到两个数组的第一个元素都等于<code class="fe mu mv mw mx b">my</code>，这仍然不是我们想要匹配的！原因–我们没有匹配单词之间的空格！</p><p id="c977" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你所要做的就是在你的字符组中添加一个空格(括号)。</p><figure class="mz na nb nc gt nd"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="9a0d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，我们的<code class="fe mu mv mw mx b">exec()</code>方法返回所有的单词。</p><p id="57ea" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，如果我们想要匹配整个字符串，我们当然可以将<code class="fe mu mv mw mx b">0-9</code>添加到我们的字符组中，但是我将用一种稍微低效的方式来演示一些东西。</p><figure class="mz na nb nc gt nd"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="5cf1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这段代码中，我们要匹配任意字母或空格(标识符:<code class="fe mu mv mw mx b">[A-Za-z ]</code> ) 1次或多次(量词:<code class="fe mu mv mw mx b">+</code>)，然后匹配1个或多个数字(<code class="fe mu mv mw mx b">[0-9]+</code>)。如果我们颠倒了弦，我们的表达式将不再工作。</p><figure class="mz na nb nc gt nd"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="cf37" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们的<code class="fe mu mv mw mx b">exec()</code>函数返回<code class="fe mu mv mw mx b">null</code>,因为我们的正则表达式模式不再匹配字符串！</p><h1 id="2c73" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">编写正则表达式的另一种方法</h1><p id="cbc1" class="pw-post-body-paragraph ki kj it kk b kl lz ju kn ko ma jx kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">到目前为止，我们是这样写的:</p><figure class="mz na nb nc gt nd"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="59f7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你也可以这样写:</p><figure class="mz na nb nc gt nd"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="4194" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从我的经验来看，大多数开发者倾向于使用第二个版本。</p><p id="a855" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">至此，我们已经介绍了JavaScript正则表达式的基本知识，为了你我的理智，我们就此打住。您可以在以后学习更多关于正则表达式的知识，但是希望这个简短的概述能让您了解它们的作用以及如何阅读它们。</p><h1 id="6e85" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">常见字符串方法</h1><p id="a835" class="pw-post-body-paragraph ki kj it kk b kl lz ju kn ko ma jx kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">从上面的讨论中可以看出，字符串被认为是JavaScript中的“对象”，因此有内置的“方法”(只是“函数”的另一种说法)。我不打算涵盖所有的字符串方法(你可以在这里<a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String#instance_methods" rel="noopener ugc nofollow" target="_blank">找到它们</a>)，也不打算详细解释其中的任何一个。我的目的是向您展示一些常用的方法以及它们是如何工作的基础知识，这样到了使用它们的时候，您就已经有些熟悉了。</p><p id="b896" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是我发现自己使用最多的字符串方法。</p><ul class=""><li id="5de1" class="lx ly it kk b kl km ko kp kr mq kv mr kz ms ld me mf mg mh bi translated">replaceAll()</li><li id="d789" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld me mf mg mh bi translated">toUpperCase()</li><li id="31cd" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld me mf mg mh bi translated">子字符串()</li><li id="8c88" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld me mf mg mh bi translated">修剪()</li><li id="74e3" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld me mf mg mh bi translated">匹配()</li></ul><h1 id="f8c8" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">全部替换</h1><p id="8747" class="pw-post-body-paragraph ki kj it kk b kl lz ju kn ko ma jx kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated"><a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replaceAll" rel="noopener ugc nofollow" target="_blank">正式文件</a></p><p id="b84f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当您想要替换一个字符串中多次出现的值时，这种方法非常方便。</p><figure class="mz na nb nc gt nd"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="58e1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意到这里有什么不对吗？我们只替换了大写版的<code class="fe mu mv mw mx b">Dog</code>！这就是正则表达式派上用场的地方。<code class="fe mu mv mw mx b">replaceAll()</code>方法接受<em class="oc"/>一个字符串或者一个正则表达式作为它的第一个参数。</p><figure class="mz na nb nc gt nd"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="a33f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们编写了<code class="fe mu mv mw mx b">/[Dd]{1}og/g</code>作为正则表达式，它将精确匹配1个字符，要么是<code class="fe mu mv mw mx b">D</code>要么是<code class="fe mu mv mw mx b">d</code>后跟<code class="fe mu mv mw mx b">og</code>。结尾的<code class="fe mu mv mw mx b">g</code>字符不是我们之前讨论过的，但它代表“全局”标志(即匹配该模式的所有出现，而不仅仅是第一个)。关于正则表达式标志的更多信息，<a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#advanced_searching_with_flags_2" rel="noopener ugc nofollow" target="_blank">你可以阅读这个</a>。</p><p id="cadb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如您在上面看到的，我们用一个表达式替换了所有出现的“dog”(大写和小写)。</p><h1 id="3bf2" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">toUpperCase</h1><p id="51f5" class="pw-post-body-paragraph ki kj it kk b kl lz ju kn ko ma jx kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated"><a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/toUpperCase" rel="noopener ugc nofollow" target="_blank">正式文件</a></p><p id="fa15" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个方法正如它的名字所暗示的那样。它将给定字符串中的每个字母大写。</p><figure class="mz na nb nc gt nd"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="2ae2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您将在下一个方法<code class="fe mu mv mw mx b">substring()</code>中看到这个方法是如何有用的。</p><h1 id="1836" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">子链</h1><p id="9924" class="pw-post-body-paragraph ki kj it kk b kl lz ju kn ko ma jx kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated"><a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/substring" rel="noopener ugc nofollow" target="_blank">正式文件</a></p><p id="1b3b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您查看文档，您会看到以下两种方法。</p><figure class="mz na nb nc gt nd gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/88d4bb7a339d6de0384f38c3285db51f.png" data-original-src="https://miro.medium.com/v2/resize:fit:538/0*AnW6_NqJDc0IfG9G"/></div></figure><p id="5cec" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意到那个拇指朝下的图标了吗？这意味着该方法“已被否决”(不再受支持)。不推荐使用的方法在大多数情况下仍然有效，但随着时间的推移，某些浏览器可能会不支持这些方法。</p><p id="9a04" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">虽然在之前的课程中，在我们的一次代码挑战中，我不小心使用了<code class="fe mu mv mw mx b">substr()</code>,但是你应该总是使用<code class="fe mu mv mw mx b">substring()</code>,因为它没有被弃用。</p><p id="6541" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当您需要隔离字符串的一部分时，这种方法非常有用。</p><figure class="mz na nb nc gt nd"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="feed" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意我放在<code class="fe mu mv mw mx b">myString</code>的前几个字母上面的索引值。<code class="fe mu mv mw mx b">substring()</code>方法有两个参数——起始索引和结束索引。在本例中，我们从索引<code class="fe mu mv mw mx b">4</code>开始，到索引<code class="fe mu mv mw mx b">14</code>结束。如果您已经跳过了第一个参数(即<code class="fe mu mv mw mx b">myString.substring(4)</code>，该方法将返回从索引<code class="fe mu mv mw mx b">4</code>开始的整个字符串<em class="oc">。</em></p><p id="32f6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这种方法在很多情况下都能派上用场，但是这里有一个我发现自己使用了<code class="fe mu mv mw mx b">substring()</code>和<code class="fe mu mv mw mx b">toUpperCase()</code>的方法。</p><figure class="mz na nb nc gt nd"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="f2ce" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mu mv mw mx b">myString[0]</code>检索字符串的第一个字母。然后，我们使用<code class="fe mu mv mw mx b">toUpperCase()</code>将该值转换成大写。然后我们使用<code class="fe mu mv mw mx b">substring()</code>方法获取字符串的剩余部分(从索引1开始，它是第二个字母，到最后一个字母结束，它的索引应该等于字符串的长度)。最后，我们将这两个字符串“添加”或“连接”在一起。</p><h1 id="c0c5" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">整齐</h1><p id="63eb" class="pw-post-body-paragraph ki kj it kk b kl lz ju kn ko ma jx kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated"><a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/Trim" rel="noopener ugc nofollow" target="_blank">官方文件</a></p><p id="9538" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个方法将“修剪”掉字符串末尾的空白。为什么这很有用似乎并不明显，但是有时，当您从外部API或数据库获取数据时，您不能确定该数据的格式是否正确。</p><p id="f373" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，假设您从外部API获得以下数据。</p><figure class="mz na nb nc gt nd"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="60c9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">数据本身看起来不错，但是你有一些不需要的额外空间。下面是如何使用<code class="fe mu mv mw mx b">trim()</code>和一个基本的for循环来修复它(见上一课)。</p><figure class="mz na nb nc gt nd"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="84fb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您运行这段代码，您将看到数组中的对象周围不再有空格。需要注意的是<code class="fe mu mv mw mx b">trim()</code>仅删除字符串开始和结束的<em class="oc">处的空格；而不是单词之间的空格。这就是为什么我们的标题仍然有这些空间。</em></p><h1 id="f906" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">比赛</h1><p id="f2e3" class="pw-post-body-paragraph ki kj it kk b kl lz ju kn ko ma jx kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated"><a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/match" rel="noopener ugc nofollow" target="_blank">正式文件</a></p><p id="98b4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么……还记得几百个单词前我们如何谈论那些叫做“正则表达式”的东西吗？他们回来了。又来了。</p><p id="7a90" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mu mv mw mx b">match()</code>方法非常类似于我们谈到的正则表达式的<code class="fe mu mv mw mx b">exec()</code>方法。让我们来比较一下这两者。</p><figure class="mz na nb nc gt nd"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="1c81" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">只要您没有在正则表达式中使用<a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#advanced_searching_with_flags_2" rel="noopener ugc nofollow" target="_blank">全局标志</a>，这两个方法将返回相同的精确值。</p><h1 id="e3a8" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">常见数组方法</h1><p id="626b" class="pw-post-body-paragraph ki kj it kk b kl lz ju kn ko ma jx kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated"><a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array" rel="noopener ugc nofollow" target="_blank">阵列文档</a></p><p id="99e5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们在数组上！同样的规则也适用于这一部分——我并不打算提供一个详尽的清单和详尽的解释；只是概述了一些最常见的方法。</p><p id="4944" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是我发现自己使用最多的数组方法。请注意，它们中的大多数都需要对回调函数有一个相当好的理解，所以如果你对这些还不清楚的话，一定要再读一遍上一节。</p><ul class=""><li id="c7c7" class="lx ly it kk b kl km ko kp kr mq kv mr kz ms ld me mf mg mh bi translated">push() / pop() / shift() / unshift()</li><li id="6b02" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld me mf mg mh bi translated">切片()</li><li id="029d" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld me mf mg mh bi translated">拼接()</li><li id="ebf9" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld me mf mg mh bi translated">findIndex() / indexOf()</li><li id="5ee5" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld me mf mg mh bi translated">地图()</li><li id="e968" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld me mf mg mh bi translated">forEach()</li><li id="1b87" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld me mf mg mh bi translated">包括()</li><li id="563c" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld me mf mg mh bi translated">过滤器()</li><li id="0eb7" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld me mf mg mh bi translated">减少()</li></ul><p id="dca9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">记住，这些不是要背的！。你可以随时查找它们。我把它们展示给你，是为了让你意识到它们，并能确定它们什么时候会有用。</p><p id="eda6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我在这里的目标不是详细描述每种方法可以做的每一件事。文档已经做到了这一点。我的目标是指出<em class="oc">为什么</em>你可能想要使用这些方法。</p><h1 id="4457" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">推动、弹出、换档、取消换档</h1><p id="426d" class="pw-post-body-paragraph ki kj it kk b kl lz ju kn ko ma jx kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">公文— <a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/push" rel="noopener ugc nofollow" target="_blank">推送</a>、<a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/pop" rel="noopener ugc nofollow" target="_blank">弹出</a>、<a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/shift" rel="noopener ugc nofollow" target="_blank">移位</a>、<a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/unshift" rel="noopener ugc nofollow" target="_blank">未移位</a></p><p id="5f82" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这些是有关联的。它们允许你在数组中添加/删除元素。根据我的经验，<code class="fe mu mv mw mx b">push()</code>是你最常用的方法。</p><figure class="mz na nb nc gt nd"><div class="bz fp l di"><div class="nl nm l"/></div></figure><h1 id="0920" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">薄片</h1><p id="7cff" class="pw-post-body-paragraph ki kj it kk b kl lz ju kn ko ma jx kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated"><a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice" rel="noopener ugc nofollow" target="_blank">正式文件</a></p><p id="4396" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当您需要复制一个数组时，<code class="fe mu mv mw mx b">arr.slice()</code>方法就派上了用场。对于初学者来说，这可能看起来没有用，但是当你开始在像React这样的前端框架中处理不可变状态时，这种方法对你来说将是无价的。</p><figure class="mz na nb nc gt nd"><div class="bz fp l di"><div class="nl nm l"/></div></figure><h1 id="110d" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">拼接(不要与切片混淆)</h1><p id="519f" class="pw-post-body-paragraph ki kj it kk b kl lz ju kn ko ma jx kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated"><a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice" rel="noopener ugc nofollow" target="_blank">官方文件</a></p><p id="6da7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您想在数组的开头(<code class="fe mu mv mw mx b">unshift()</code>)或结尾(<code class="fe mu mv mw mx b">push()</code>)之外的地方添加元素，<code class="fe mu mv mw mx b">splice()</code>是您的方法。下面是常用的使用方法。更多使用案例见文档。</p><figure class="mz na nb nc gt nd"><div class="bz fp l di"><div class="nl nm l"/></div></figure><h1 id="5ff6" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">findIndex / indexOf</h1><p id="b42d" class="pw-post-body-paragraph ki kj it kk b kl lz ju kn ko ma jx kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated"><a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex" rel="noopener ugc nofollow" target="_blank">正式文件</a></p><p id="fa51" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mu mv mw mx b">findIndex</code>方法接受一个回调函数作为参数，并将在数组中找到与回调函数中设置的条件相匹配的第一个元素。</p><p id="b1b2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mu mv mw mx b">indexOf</code>方法只是搜索数组中第一个出现的值，这是一个简单得多的方法。</p><p id="d9bd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们从简单的<code class="fe mu mv mw mx b">indexOf</code>方法开始。这只是在数组中定位一个值，如果没有找到，就返回<code class="fe mu mv mw mx b">-1</code>。</p><figure class="mz na nb nc gt nd"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="29fd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是如果你有一个像这样更复杂的数组呢？</p><figure class="mz na nb nc gt nd"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="4eca" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们如何找到姓“多伊”的人？你可能会考虑这样做:</p><figure class="mz na nb nc gt nd"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="45fc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是行不通的，因为检查一个对象的相等性比仅仅把它作为一个值传入要复杂一些。</p><p id="2f02" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">用<code class="fe mu mv mw mx b">findIndex</code>，我们可以定位这个元素。</p><figure class="mz na nb nc gt nd"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="bb68" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mu mv mw mx b">findIndex()</code>方法提供了更多的灵活性！</p><h1 id="cecc" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">地图</h1><p id="d7db" class="pw-post-body-paragraph ki kj it kk b kl lz ju kn ko ma jx kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated"><a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map" rel="noopener ugc nofollow" target="_blank">正式文件</a></p><p id="8613" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在所有这些内置数组方法中，这一个可能是我用得最多的。这里有一个非常实际的例子。假设您从数据库中检索了一组博客文章，并且没有填写<code class="fe mu mv mw mx b">category</code>属性。对于所有这些博客文章，您希望将它们归类到“学习编码”类别中。</p><figure class="mz na nb nc gt nd"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="4249" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">映射方法可以用于许多不同的情况。如果您有一个数组，其中的每个元素都需要以类似的方式进行修改，那么map方法就会派上用场。</p><h1 id="9fba" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">为每一个</h1><p id="47f9" class="pw-post-body-paragraph ki kj it kk b kl lz ju kn ko ma jx kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated"><a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach" rel="noopener ugc nofollow" target="_blank">正式文件</a></p><p id="aa8e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">到目前为止，我只展示了如何编写一个基本的for循环。以下是我们看到的内容:</p><figure class="mz na nb nc gt nd"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="92cf" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是有一种更简单的方法来编写同样的for循环——<code class="fe mu mv mw mx b">forEach()</code>数组方法。</p><p id="e20d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请<a class="ae le" href="https://stackoverflow.com/a/43032526/7437737" rel="noopener ugc nofollow" target="_blank">阅读此</a>以比较基本<code class="fe mu mv mw mx b">for</code>回路和<code class="fe mu mv mw mx b">forEach</code>回路。简而言之——每种方式都有其优点，在大多数情况下，你选择哪种方式并不重要。</p><p id="c04a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是使用它的基本方法。</p><figure class="mz na nb nc gt nd"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="6ce4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是一种更简洁(但对初学者不太友好)的写法。这里，我们使用一个箭头函数作为回调函数，而不是单独定义它。</p><figure class="mz na nb nc gt nd"><div class="bz fp l di"><div class="nl nm l"/></div></figure><h1 id="a1d8" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">包含</h1><p id="2a3d" class="pw-post-body-paragraph ki kj it kk b kl lz ju kn ko ma jx kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated"><a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/includes" rel="noopener ugc nofollow" target="_blank">正式文件</a></p><p id="97e5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你需要判断一个数组中是否存在一个值，使用这个方法。请注意，您<em class="oc">不能</em>使用它来查找复杂的数据类型，如对象或其他数组。</p><p id="a618" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设你有下面这个数组，你想弄清楚颜色<code class="fe mu mv mw mx b">orange</code>是否存在于其中。你可以清楚地看到这一点，但在编写代码时，你不会总是这么清楚。也许这个数组来自一个数据库，你不知道会发生什么！</p><figure class="mz na nb nc gt nd"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="e3e6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里有一种方法可以让我们搞清楚:</p><figure class="mz na nb nc gt nd"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="116f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里有一个更简单的方法。</p><figure class="mz na nb nc gt nd"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="2f33" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是通过使用<code class="fe mu mv mw mx b">includes()</code>，我们可以做得更简单:</p><figure class="mz na nb nc gt nd"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="0c27" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，您甚至可以使用完全不同的方法来实现这一点。见下文:</p><figure class="mz na nb nc gt nd"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="609c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们知道，如果<code class="fe mu mv mw mx b">indexOf</code>没有在数组中找到元素，它将返回值<code class="fe mu mv mw mx b">-1</code>。我知道这一点，因为我读过文档。</p><figure class="mz na nb nc gt nd gh gi paragraph-image"><div class="gh gi of"><img src="../Images/ebe87b1801b448ea6f09fe67b1e57c39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1112/0*l_kgelJnQNKqthRD"/></div></figure><p id="8812" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以使用这个逻辑来确定数组中是否存在一个值；类似于<code class="fe mu mv mw mx b">includes()</code>的方法。</p><p id="8122" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您知道何时使用这些内置方法，那么您将开始看到这些内置方法可以为您节省多少代码！</p><h1 id="46ac" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">过滤器</h1><p id="2002" class="pw-post-body-paragraph ki kj it kk b kl lz ju kn ko ma jx kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated"><a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter" rel="noopener ugc nofollow" target="_blank">正式文件</a></p><p id="7e09" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<code class="fe mu mv mw mx b">map()</code>之后，这可能是我第二常用的内置数组方法。</p><p id="98c6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">与其他一些方法不同，<code class="fe mu mv mw mx b">filter()</code>方法有一个非常明显的用例，大多数人即使没有写很多代码也能产生共鸣。</p><p id="0037" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设我们正在为亚马逊构建“我的订单”页面。在此页面上，您可以查看您过去的所有订单，但也可以按各种条件进行筛选。您可以显示特定时间段的订单、未结订单、纯数字订单和已取消订单。</p><p id="b454" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当Amazon将数据加载到这个页面时，它很可能以数组的形式出现(这是一个虚构的表示):</p><figure class="mz na nb nc gt nd"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="e6df" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当用户单击过滤器只选择数字订单时，我们该如何编写代码来完成呢？当然是用<code class="fe mu mv mw mx b">filter()</code>的方法！我们也可以得到一个组合过滤器的数组！</p><p id="c897" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它是这样工作的——如果我们的回调函数的返回值对于一个特定的数组项是真的，那么这个数组项将包含在结果数组中。</p><figure class="mz na nb nc gt nd"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="b268" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个方法你会用很多，好好学！</p><h1 id="7683" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">减少</h1><p id="70e2" class="pw-post-body-paragraph ki kj it kk b kl lz ju kn ko ma jx kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated"><a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce" rel="noopener ugc nofollow" target="_blank">正式文件</a></p><p id="1486" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我把最难的留到了最后，因为虽然它会派上用场，但你并不需要它。看一下这个例子，但是不要强调学习这个，在接下来的几课中，我们有更重要的东西要学。</p><p id="3f09" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你现在可能已经意识到了:</p><figure class="mz na nb nc gt nd"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="7c9f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mu mv mw mx b">reduce()</code>方法只是编写这段代码的一种更短的方式。</p><p id="2b57" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是使用<code class="fe mu mv mw mx b">reduce()</code>方法重写的上面的相同代码。</p><figure class="mz na nb nc gt nd"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="dc4f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们从<code class="fe mu mv mw mx b">0</code>开始我们的<code class="fe mu mv mw mx b">sum</code>值，将它作为第二个参数传入(就像我们在之前的代码中所做的一样)。<code class="fe mu mv mw mx b">reducerCallback</code>将遍历数组中的每个值，并按数组中的每一项增加<code class="fe mu mv mw mx b">sum</code>的值。这个回调函数将返回“累积的”<code class="fe mu mv mw mx b">sum</code>。</p><h1 id="8412" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">但是如果我要做的事情没有方法呢？</h1><p id="e2ba" class="pw-post-body-paragraph ki kj it kk b kl lz ju kn ko ma jx kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">很高兴你问了。在某些情况下，您可能希望执行一些使用内置JavaScript方法无法完成的操作。</p><p id="e2c3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这种情况下，您有两个选择:</p><ol class=""><li id="098e" class="lx ly it kk b kl km ko kp kr mq kv mr kz ms ld mt mf mg mh bi translated">写一堆JavaScript代码来解决问题</li><li id="82ad" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld mt mf mg mh bi translated">使用JavaScript“库”</li></ol><p id="4583" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您试图通过编写“普通的”(普通的)JavaScript代码来比较对象的相等性，<a class="ae le" href="https://stackoverflow.com/a/1144249/7437737" rel="noopener ugc nofollow" target="_blank">下面是您需要编写的代码</a>。不推荐。</p><p id="828b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">更好的解决方案是使用类似Lodash的代码库。我们将在后面更多地讨论代码库以及如何使用它们，但是现在，只需浏览一下我下面写的代码(利用Lodash库)。</p><p id="d416" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">快速提示:Lodash库为各种数据类型提供了函数(类似于JavaScript内置函数)，我们通常称之为“函数式编程”。</p><figure class="mz na nb nc gt nd"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="1c3c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在以后的课程中，我们将演示如何使用这样的库。</p><h1 id="6cb7" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">JavaScript数学库</h1><p id="ec25" class="pw-post-body-paragraph ki kj it kk b kl lz ju kn ko ma jx kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">即使您没有构建金融web应用程序，您也需要了解JavaScript数学库中的几个常用函数。</p><p id="3763" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，在我们开始之前，我想谈一个小问题(至少在我们的旅程中)。看一下下面的代码。</p><figure class="mz na nb nc gt nd"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="868a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">日期和数学库是不相关的，但是您注意到上面的代码有什么奇怪的地方吗？我知道。在第一个代码片段中，我们使用<code class="fe mu mv mw mx b">new Date()</code>创建一个日期，而在第二个代码片段中，我们使用数学库作为<code class="fe mu mv mw mx b">Math.abs()</code>。</p><p id="2ea1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们不需要这么做吗？？？</p><figure class="mz na nb nc gt nd"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="4443" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不，这是使用数学库的不正确方法，如果你试图运行这段代码，你会得到下面的错误信息:</p><figure class="mz na nb nc gt nd"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="4b09" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那个词是什么，“构造者”？？</p><p id="ddc3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">嗯，它与JavaScript中的<em class="oc">构造</em>一个对象有关，它源于一种叫做“面向对象编程”(OOP)的东西。在本系列的后面，我们将讨论这一点以及“类”、“静态方法”和“实例方法”的概念。</p><p id="f56a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mu mv mw mx b">Math.abs()</code>是一个<em class="oc">静态方法</em>，而<code class="fe mu mv mw mx b">myDate.getFullYear()</code>被认为是一个<em class="oc">实例方法</em>。现在没有必要知道这些，但是我想指出来，这样当你将来看到它的时候，它就不是一个完全的惊喜了。</p><h1 id="1c72" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">数学库的一些常见用途</h1><p id="04c9" class="pw-post-body-paragraph ki kj it kk b kl lz ju kn ko ma jx kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">即使对初学者来说，数学库的<a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math" rel="noopener ugc nofollow" target="_blank">文档也不难阅读。</a></p><p id="dc76" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是使用它的一些常见方法(并非详尽):</p><figure class="mz na nb nc gt nd"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="bc91" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们继续之前，我想稍微多关注一下那个<code class="fe mu mv mw mx b">Math.random()</code>方法，因为如果你知道如何使用它，它会派上用场。</p><p id="6fa5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于它返回一个0到1之间的随机值，我们可以利用这个事实和一些基本逻辑来获得数组中的随机索引。我们已经在本系列的前几课中使用过，但是我还没有解释它是如何工作的。</p><figure class="mz na nb nc gt nd"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="d678" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可能不会在许多应用程序中使用这个技巧，但是它对于单元测试来说确实很有用！</p><h1 id="5ecb" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">JavaScript错误类型</h1><p id="cab5" class="pw-post-body-paragraph ki kj it kk b kl lz ju kn ko ma jx kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">我知道，这一课的其余部分看起来很无聊，但如果你已经做到了这一步，请留下来，因为理解错误类型，NaN，null和未定义的值是非常重要的！</p><p id="5ddb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当您试图执行无效或无法处理您赋予它的值的JavaScript代码时，就会发生JavaScript错误。</p><p id="335e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在JavaScript中，有几种不同的<em class="oc">类型的</em>错误，但是它们都是从<code class="fe mu mv mw mx b">Error</code>对象“继承”(这是一个面向对象的编程术语)，这<a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error" rel="noopener ugc nofollow" target="_blank">你可以在这里看到文档</a>。</p><p id="345c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">虽然不止有三种类型，但这三种是您将会看到的最常见的类型，并且需要对它们有一个高层次的了解。</p><ul class=""><li id="2c50" class="lx ly it kk b kl km ko kp kr mq kv mr kz ms ld me mf mg mh bi translated"><code class="fe mu mv mw mx b">ReferenceError</code></li><li id="2f7d" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld me mf mg mh bi translated"><code class="fe mu mv mw mx b">SyntaxError</code></li><li id="0e9a" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld me mf mg mh bi translated"><code class="fe mu mv mw mx b">TypeError</code></li></ul><h1 id="fd2e" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">JavaScript引用错误</h1><p id="681c" class="pw-post-body-paragraph ki kj it kk b kl lz ju kn ko ma jx kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated"><a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError" rel="noopener ugc nofollow" target="_blank">正式文件</a></p><p id="f217" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当你试图“引用”或“使用”一个不存在的值时，你会得到这个错误。下面是一个最简单的例子:</p><figure class="mz na nb nc gt nd"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="ebf8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">JavaScript试图在内存中找到对<code class="fe mu mv mw mx b">anotherVariable</code>的“引用”,但是因为我们从未声明过它，所以它根本不存在！</p><h1 id="d334" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">JavaScript语法错误</h1><p id="01e2" class="pw-post-body-paragraph ki kj it kk b kl lz ju kn ko ma jx kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated"><a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SyntaxError" rel="noopener ugc nofollow" target="_blank">正式文件</a></p><p id="69fb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们谈论“语法”时，我们谈论的是如何编写代码。如果你写了无效的JavaScript代码，编译器不知道该怎么做，会抛出一个<code class="fe mu mv mw mx b">SyntaxError</code>。这很容易解释——只需编写一些无效的JavaScript代码！看看你能不能找出下面的问题。</p><figure class="mz na nb nc gt nd"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="a4bb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你试图运行这段代码，你将得到一个显示为<code class="fe mu mv mw mx b">Unexpected token ';'</code>的<code class="fe mu mv mw mx b">SyntaxError</code>。这是因为在你的对象中需要<code class="fe mu mv mw mx b">,</code>而不是<code class="fe mu mv mw mx b">;</code>。以下是正确的做法:</p><figure class="mz na nb nc gt nd"><div class="bz fp l di"><div class="nl nm l"/></div></figure><h1 id="28bd" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">JavaScript类型错误</h1><p id="9bc7" class="pw-post-body-paragraph ki kj it kk b kl lz ju kn ko ma jx kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated"><a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError" rel="noopener ugc nofollow" target="_blank">官方文件</a></p><p id="6623" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这可能是三者中最难理解的。当您试图对特定类型的数据执行无法完成的操作时，就会发生这种情况。如果您试图将一个不兼容的参数传递给一个函数，试图修改一个不可变的值，或者只是不恰当地使用一个值，您将会得到这个错误。</p><p id="2b07" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这很令人困惑，因为有很多情况下<em class="oc">看起来</em>像是他们会抛出一个<code class="fe mu mv mw mx b">TypeError</code>，但并没有。考虑一下这个:</p><figure class="mz na nb nc gt nd"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="c739" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你不能把两个物体相加，对吗？？不，你不能，但如果你尝试，它不会向你抛出一个错误。它只是将两个对象组合成一个字符串。从逻辑上讲，这在我看来像是一个<code class="fe mu mv mw mx b">TypeError</code>。但是这里有几个例子确实抛出了这个错误。</p><figure class="mz na nb nc gt nd"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="8f1b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在第一种情况下，我们试图对一个数字使用字符串方法。在第二种情况下，当我们真正处理一个字符串时，我们试图调用一个函数。</p><h1 id="3a3b" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">什么是“错误处理”</h1><p id="e74a" class="pw-post-body-paragraph ki kj it kk b kl lz ju kn ko ma jx kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">我不想用错误掩盖的最后一件事是非常重要的，但是很多初学者(包括几年前的我自己)都忘记了。</p><p id="f8bf" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">“处理”错误的目的是什么，这意味着什么？</p><p id="1755" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">好吧，让我给你描述一下。假设您构建了一个类似于Instagram的应用程序，而您的一个用户在发布图片时失去了互联网连接。很明显，允许用户发布图片的代码是行不通的，因为用户没有互联网接入。</p><p id="57af" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们处理代码中的错误，我们可以在屏幕上打印出这样的内容:“您没有连接到互联网。请连接并重试”。</p><p id="224e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们不处理代码中的错误，我们的应用程序将会崩溃，用户将会不知道发生了什么。</p><p id="f3bc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以下一个问题是…我们试图处理什么样的错误？</p><p id="cd39" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">而这也是初学者难以理解错误处理的地方。在大多数情况下，我们想要处理的错误是由我们无法控制的<em class="oc">外部</em>代码引起的。我们将在后面的系列文章中深入讨论这个问题，但是现在，我将只向您展示<em class="oc">如何处理</em>错误。</p><figure class="mz na nb nc gt nd"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="c552" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当然，上面的代码是无用的，我们永远也不会写这样的东西，但是它展示了我们可以在JavaScript中用于错误处理的try/catch语法。</p><p id="0b93" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于我们将<code class="fe mu mv mw mx b">num.toUpperCase()</code>(它抛出一个<code class="fe mu mv mw mx b">TypeError</code>)放在“try”块中，我们的代码运行得很好，没有被中断。我们甚至可以打印关于这个错误的一些细节。</p><figure class="mz na nb nc gt nd"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="09f1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我提到的，我们将在本系列中再次讨论错误处理，所以请将此视为您的简要介绍。</p><h1 id="d342" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">NaN，null，在JavaScript中未定义</h1><p id="56f2" class="pw-post-body-paragraph ki kj it kk b kl lz ju kn ko ma jx kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">我会让这最后一部分简短明了。有三种“数据类型”我们没有花太多时间，它们是<code class="fe mu mv mw mx b">NaN</code>、<code class="fe mu mv mw mx b">null</code>和<code class="fe mu mv mw mx b">undefined</code>。</p><h1 id="ed14" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">南——“不是数”</h1><p id="4b49" class="pw-post-body-paragraph ki kj it kk b kl lz ju kn ko ma jx kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">你很少会看到这个或者用到这个，但是你应该知道这是什么。</p><p id="fe2d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从<a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN" rel="noopener ugc nofollow" target="_blank">文档</a>中，这里是将返回<code class="fe mu mv mw mx b">NaN</code>的最常见场景。</p><figure class="mz na nb nc gt nd"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="5196" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我说过，你不会看到或使用这么多。</p><h1 id="2beb" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">空</h1><p id="f614" class="pw-post-body-paragraph ki kj it kk b kl lz ju kn ko ma jx kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">不像南，你会一直遇到<code class="fe mu mv mw mx b">null</code>的价值观！一个<code class="fe mu mv mw mx b">null</code>值是一个JavaScript原始值(还记得本文前面的内容吗？)并表示故意缺少某个值。换句话说，你可以把它想成一个“占位符”值，必须由开发人员来设置。</p><p id="5e62" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当在操作中使用<code class="fe mu mv mw mx b">null</code>时，它表现为一个“假”值。见下文。</p><figure class="mz na nb nc gt nd"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="c5de" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null" rel="noopener ugc nofollow" target="_blank">这里是关于<code class="fe mu mv mw mx b">null</code>值的官方文档</a>。</p><h1 id="78a2" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">不明确的</h1><p id="dc9b" class="pw-post-body-paragraph ki kj it kk b kl lz ju kn ko ma jx kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">与<code class="fe mu mv mw mx b">null</code>非常相似，<code class="fe mu mv mw mx b">undefined</code>是一个原始值，表示没有值。</p><p id="cf16" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当您试图使用一个已经存在但还没有定义的变量时，您将得到一个<code class="fe mu mv mw mx b">undefined</code>值(并且还没有被赋予一个<code class="fe mu mv mw mx b">null</code>值)。</p><figure class="mz na nb nc gt nd"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="ea8a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为我们没有故意将<code class="fe mu mv mw mx b">myString</code>初始化为<code class="fe mu mv mw mx b">null</code>值，所以它带有一个<code class="fe mu mv mw mx b">undefined</code>值。</p><p id="1adb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mu mv mw mx b">myObj</code>的例子有点复杂。您可能会推断，因为<code class="fe mu mv mw mx b">myObj</code>还没有<code class="fe mu mv mw mx b">someFunction</code>属性，所以它会抛出一个错误。相反，所有未分配的对象属性都带有一个值<code class="fe mu mv mw mx b">undefined</code>。在这个例子中，当我们试图调用这个函数时，我们得到一个<code class="fe mu mv mw mx b">TypeError</code>，因为您不能“调用”和<code class="fe mu mv mw mx b">undefined</code>值。</p><p id="f1c1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">像<code class="fe mu mv mw mx b">null</code>一样，<code class="fe mu mv mw mx b">undefined</code>原语在条件中使用时被视为“假”值。</p><figure class="mz na nb nc gt nd"><div class="bz fp l di"><div class="nl nm l"/></div></figure><h1 id="ec70" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">恭喜，你成功了</h1><p id="1361" class="pw-post-body-paragraph ki kj it kk b kl lz ju kn ko ma jx kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">如果你真的读了整篇文章，上Twitter让我知道你的想法！我的句柄是<a class="ae le" href="https://twitter.com/zg_dev" rel="noopener ugc nofollow" target="_blank"> @zg_dev </a>。</p><p id="d732" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另外，祝贺你完成这个。我知道这种东西令人困惑，但是有了你完成这么长帖子的奉献精神，我知道你会成为一名成功的软件工程师！</p><p id="e5e9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是，如果你只是阅读我的帖子，你不会学习编码。你必须练习。所以继续挑战吧！</p><h1 id="7b88" class="lf lg it bd lh li lj lk ll lm ln lo lp jz lq ka lr kc ls kd lt kf lu kg lv lw bi translated">10个JavaScript挑战</h1><p id="491a" class="pw-post-body-paragraph ki kj it kk b kl lz ju kn ko ma jx kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">我为这节课选择了15个挑战，要求你应用我们在这里讨论的主题的基础知识，并结合你在之前的课程中获得的知识。</p><p id="5215" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了充分利用这些挑战，我推荐观看我的YouTube视频，在那里我与你一起解决所有这些问题。我向你展示我的思考过程，并希望从这些课程中填补一些空白。</p><p id="0649" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是挑战和解决方案。</p><ul class=""><li id="b7c8" class="lx ly it kk b kl km ko kp kr mq kv mr kz ms ld me mf mg mh bi translated">解决方案(即将推出)——<a class="ae le" href="https://gist.github.com/zachgoll/3b8281568f19db2ce752149ab826f230" rel="noopener ugc nofollow" target="_blank">YouTube视频</a></li><li id="871e" class="lx ly it kk b kl mi ko mj kr mk kv ml kz mm ld me mf mg mh bi translated">挑战集合— <a class="ae le" href="https://www.codewars.com/collections/lesson-6-challenges-number-fullstackroadmap" rel="noopener ugc nofollow" target="_blank">第六课关于代码战的集合</a></li></ul></div></div>    
</body>
</html>