<html>
<head>
<title>Implement Rate Limiting in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Python中实现速率限制</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/implement-rate-limiting-in-python-d4f86b09259f?source=collection_archive---------1-----------------------#2022-08-29">https://levelup.gitconnected.com/implement-rate-limiting-in-python-d4f86b09259f?source=collection_archive---------1-----------------------#2022-08-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="f18a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">速率限制是一种在特定时间段内限制请求数量的方法。当你有很多请求，想减轻负荷的时候，它是超级有用的。</p><p id="bf64" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这篇文章将向你展示在Python中从头开始实现速率限制的两种不同算法。</p><h1 id="c16d" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">朴素固定窗口算法</h1><p id="43b3" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">进行速率限制的最直接的算法是<strong class="js iu">固定窗口算法</strong>。</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi lr"><img src="../Images/be38fd5cc92a8b3578a064f878f47d55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d-6SPOjJSu6mWC79k3y-Bg.png"/></div></div><figcaption class="md me gj gh gi mf mg bd b be z dk translated">朴素的固定窗口算法做速率限制</figcaption></figure><p id="b82e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该窗口是计数器计数的<strong class="js iu">采样周期</strong>。每次收到请求时，我们都会增加计数器的值，每次新的采样周期开始时，我们都会重置计数器的值。</p><p id="89b6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，在上面的图像中，采样周期是60秒。一旦进入当前分钟，我们就将计数器重置为零，并从零开始对请求进行计数。</p><h2 id="b428" class="mh kp it bd kq mi mj dn ku mk ml dp ky kb mm mn lc kf mo mp lg kj mq mr lk ms bi translated">如何定义费率？</h2><p id="1951" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">它是当前采样周期内每秒的请求数，不包括前一分钟。</p><h2 id="873b" class="mh kp it bd kq mi mj dn ku mk ml dp ky kb mm mn lc kf mo mp lg kj mq mr lk ms bi translated">履行</h2><p id="8481" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">下面是实现固定窗口算法的代码。</p><figure class="ls lt lu lv gt lw"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="ad96" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这种速率限制并不十分精确，因为计数器会定期任意重置，从而允许定期的流量峰值通过速率限制器。</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi mv"><img src="../Images/674d4e661927cd219376f7ffc6aa1352.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tZlqMyCe4MDamEslc3n6Iw.png"/></div></div><figcaption class="md me gj gh gi mf mg bd b be z dk translated">速率(每秒请求数)与时间段的关系</figcaption></figure><h1 id="b346" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">滑动窗口算法</h1><p id="53ae" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">让我们对算法做一些调整，使它更准确。滑动窗口算法来了。</p><p id="b768" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">天真的固定窗口算法并没有那么糟糕:我们必须解决每当采样周期开始时完全重置计数器的问题。</p><p id="93e0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以使用来自<strong class="js iu">先前计数器的信息来推断请求速率的近似值。</strong></p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi mw"><img src="../Images/f934565b07731bea828618fd95cb3f13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VXygP6f2BuQA9CnFqGHk4Q.png"/></div></div><figcaption class="md me gj gh gi mf mg bd b be z dk translated">滑动窗口算法做速率限制</figcaption></figure><p id="cf66" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这个例子中，我在20秒前开始的当前一分钟内发出了18个请求，在之前的一分钟内发出了42个请求。基于此信息，速率近似值的计算如下:</p><pre class="ls lt lu lv gt mx my mz na aw nb bi"><span id="baea" class="mh kp it my b gy nc nd l ne nf">rate = (48 * 2/3 + 18 * 1/3)/60 = 0.63 seq/sec</span></pre><p id="63f5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是代码。</p><figure class="ls lt lu lv gt lw"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="0ff9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这种速率限制对于大多数情况来说已经足够好了。它消除了固定窗口方法存在的流量峰值问题。</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi ng"><img src="../Images/ccc57184b2cbad3f1b9b8fd1cd3edd3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9V5CCfhfuGdVQGNaCHM69g.png"/></div></div></figure><p id="7493" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当然，我们可以改进算法，但它在实践中证明足够好。</p><h1 id="9a26" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">集成示例</h1><p id="a733" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">我们来举一个整合上述算法的例子。</p><p id="0224" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们创建一个名为<code class="fe nh ni nj my b">Throttle</code>的类来实现固定/滑动窗口算法。当当前速率超过阈值时，我们会休眠一段时间。</p><p id="045d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">代码如下:</p><figure class="ls lt lu lv gt lw"><div class="bz fp l di"><div class="mt mu l"/></div></figure></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><p id="e7fa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我希望你喜欢读这篇文章。如果你愿意支持我成为一名作家，可以考虑注册<a class="ae nr" href="https://jerryan.medium.com/membership" rel="noopener">成为</a>中的一员。你还可以无限制地访问媒体上的每个故事。</p></div></div>    
</body>
</html>