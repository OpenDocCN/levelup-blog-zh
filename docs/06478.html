<html>
<head>
<title>Control Machines With Go Routines</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Go程序控制机器</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/control-machines-with-go-routines-fa90c6462bf2?source=collection_archive---------6-----------------------#2020-11-29">https://levelup.gitconnected.com/control-machines-with-go-routines-fa90c6462bf2?source=collection_archive---------6-----------------------#2020-11-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="3ba3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">获取Go中并发性的背景知识和应用技巧！</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/83967ed9a8e8fe0be813c9c6a3e18a71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*2M55YocUts1NQCjq.jpg"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">从<a class="ae le" href="https://deepdreamgenerator.com/u/quanchi" rel="noopener ugc nofollow" target="_blank">权池</a>开始，这不是很酷吗？！</figcaption></figure><p id="bebb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi lf translated"><span class="l lg lh li bm lj lk ll lm ln di"> Go </span>因其干净利落的并发性而声名鹊起。Go不使用进程或线程，而是使用自己的类型<em class="lo"> go例程</em>来提高程序的执行效率。这减轻了开发人员的大量工作，并允许在使用Go时更安全地处理并发编程。</p><p id="bfc3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">本文将详细介绍以下内容:</p><ul class=""><li id="ce1a" class="lp lq it js b jt ju jx jy kb lr kf ls kj lt kn lu lv lw lx bi translated">并发性与并行性的背景</li><li id="1128" class="lp lq it js b jt ly jx lz kb ma kf mb kj mc kn lu lv lw lx bi translated">围棋中的例子</li><li id="b9e4" class="lp lq it js b jt ly jx lz kb ma kf mb kj mc kn lu lv lw lx bi translated">你接下来需要学习的</li></ul><p id="99b3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们开始吧！</p></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h1 id="ef7a" class="mk ml it bd mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh bi translated">并发性的简要背景</h1><p id="8481" class="pw-post-body-paragraph jq jr it js b jt ni jv jw jx nj jz ka kb nk kd ke kf nl kh ki kj nm kl km kn im bi lf translated"><span class="l lg lh li bm lj lk ll lm ln di">到</span>回想一下，并发性包括将数据或信息分解成单独的块，以便一次全部处理。例如，假设您正在浏览1000个网站，并希望从它们的身体中获得某种信息进行处理。你可以一次只做一个网站，或者你可以设置10个围棋程序，让他们每个人负责100个网站。这有可能将你的程序提高一个数量级，至少在理论上是这样。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nn"><img src="../Images/b7f18b4b399dd08e85d76fdcb9cd3588.png" data-original-src="https://miro.medium.com/v2/resize:fit:1198/format:webp/0*dbxCQK9HxT2KX4QA.jpg"/></div></div></figure><p id="3f73" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我觉得知道这和<em class="lo">并行</em>不同是很有用的。这个过程与并发性的不同之处在于有<em class="lo">个独立的进程</em>执行<em class="lo">个独立的任务</em>。另一方面，并发性涉及相同的进程，但是多个线程处理来自父源的独立数据块。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi no"><img src="../Images/a8f3e5df0b72b12445c3debcfe011438.png" data-original-src="https://miro.medium.com/v2/resize:fit:818/format:webp/0*19GUFtLRdWHMKzBb.png"/></div></figure><p id="a97d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">实际上，<strong class="js iu">并行</strong>是获取额外计算能力的历史方法。关于这个主题已经有几十年的研究了，矩阵乘法就是一个例子。它需要至少两个CPU才能真正发挥作用，而且众所周知很难调试。</p><p id="a731" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">并发</strong>略有不同。这是一种相对较新的技术，主要目标是隐藏延迟。这就是为什么它对网络爬虫甚至是你的键盘有用的原因，因为它对每一次击键都有一个线程，从而隐藏了用户输入和贵由使用之间的延迟。并发可以在单个CPU上执行，并且具有不确定的输出，这使得调试非常困难。</p><blockquote class="np nq nr"><p id="0a50" class="jq jr lo js b jt ju jv jw jx jy jz ka ns kc kd ke nt kg kh ki nu kk kl km kn im bi translated">放在一句话里，并行就是<strong class="js iu"> <em class="it">一次做</em> </strong>多件事的方法，而并发就是<strong class="js iu"> <em class="it">一次处理</em> </strong>多件事。</p></blockquote></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><h1 id="7c50" class="mk ml it bd mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh bi translated">戈兰语示例</h1><p id="1455" class="pw-post-body-paragraph jq jr it js b jt ni jv jw jx nj jz ka kb nk kd ke kf nl kh ki kj nm kl km kn im bi translated">我们不会深入本质细节，比如Go并发性到底是如何利用计算机的CPU的。Go运行时和主机操作系统会处理好这一点，我们想知道如何从开发人员的角度提高工作效率。</p><p id="9678" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们首先看一个示例<em class="lo">异步</em>程序，这意味着我们一次执行一步代码。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="6005" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你能发现这个缺陷吗？当我们第一次调用<code class="fe nx ny nz oa b">printWithDelay()</code>时，我们陷入了一个无限for循环，给出了以下输出:</p><pre class="kp kq kr ks gt ob oa oc od aw oe bi"><span id="5d7c" class="of ml it oa b gy og oh l oi oj">1 May<br/>2 May<br/>3 May<br/>4 May<br/>5 May<br/>^Csignal: interrupt</span></pre><p id="a9c1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">介绍go套路！</strong></p><p id="85b7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了解决这个问题，我们可以简单地在对我们的<code class="fe nx ny nz oa b">printWithDelay</code>函数的前两次调用中包含<code class="fe nx ny nz oa b">go</code>关键字。这将告诉Go我们想要在后台运行这个程序<em class="lo">，然后<em class="lo">立即</em>继续主程序线程中的下一行代码。</em></p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="fda4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">用<code class="fe nx ny nz oa b">run main.go</code>运行这个程序将会给出输出:</p><pre class="kp kq kr ks gt ob oa oc od aw oe bi"><span id="c76b" class="of ml it oa b gy og oh l oi oj">1 be with you.<br/>1 May<br/>1 the Force<br/>2 May<br/>2 the Force<br/>2 be with you.<br/>^Csignal: interrupt</span></pre><p id="3263" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你注意到什么了吗？第一轮我们没有按照预期的顺序打印出字符串。这是因为go例程是<em class="lo">不确定的</em>，这意味着当我们并发运行它们时，我们无法预测事件的顺序。</p><p id="0f7d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">围棋程序非常高效——如果你的程序需要，你可以运行数百甚至数千个围棋程序。然而，在一个问题上添加无数的例程最终会导致回报递减，因为你已经最大限度地利用了你的CPU所执行的工作。</strong></p><blockquote class="np nq nr"><p id="4a4d" class="jq jr lo js b jt ju jv jw jx jy jz ka ns kc kd ke nt kg kh ki nu kk kl km kn im bi translated">更重要的是，你是否注意到我们不必担心杀死任何线程或处理垃圾收集，而在像C/C++这样的语言中，这是令人痛苦的。这就是Go作为一门通用编程语言真正脱颖而出的地方！</p></blockquote><p id="e3cc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是要小心！如果第11行对<code class="fe nx ny nz oa b">printWithDelay()</code>的第三次调用也是一个go例程，程序会编译但不会实际执行。这是由于go程序在程序的<em class="lo">后台</em>运行。所以，如果你用函数<code class="fe nx ny nz oa b">printWithDelay()</code>启动了三个go例程，除此之外什么都没有，那么主程序实际上会在go例程有机会启动之前就退出了。</p><p id="25f3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">用</strong> <code class="fe nx ny nz oa b"><strong class="js iu">WaitGroup</strong></code> <strong class="js iu"> : </strong>处理我们的围棋套路</p><p id="a2c4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用<code class="fe nx ny nz oa b">sync</code>包，我们可以在后台编排go例程的使用，而不必自己动手做一些程序阻塞。相反，我们利用了<code class="fe nx ny nz oa b">sync.WaitGroup</code>对象，它将初始化一个计数器来跟踪我们的go例程。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="343b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这个例子中，我们在第13–16行利用一个匿名函数(字面上只是一个没有名字的函数)来执行<code class="fe nx ny nz oa b">printWithDelay()</code>,并警告<code class="fe nx ny nz oa b">WaitGroup</code>我们已经完成了第15行的一个例程。如果您感到好奇，第16行的括号是您将输入传递给匿名函数的地方。</p><p id="4540" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，使用<code class="fe nx ny nz oa b">WaitGroup</code>可以让我们更好地控制我们的并发性，并且在后台go例程结束执行时仍然可以访问我们的主程序线程。</p></div><div class="ab cl md me hx mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="im in io ip iq"><p id="8fcf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">信不信由你，这是利用go例程并发的一个很好的基础。如果你想了解更多，我的下一篇文章将关注如何在通道的帮助下让我们的围棋程序变得有用。这些对象对于Go来说是唯一的，允许您轻松地传输信息，并为并发编程提供共享资源。</p><p id="aa7d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我希望你喜欢这篇文章，如果你想知道更多，我鼓励你在下面留下评论！感谢阅读。</p></div></div>    
</body>
</html>