<html>
<head>
<title>Master the Concurrency in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">掌握Python中的并发性</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/master-the-concurrency-in-python-cedd070a913c?source=collection_archive---------5-----------------------#2020-07-21">https://levelup.gitconnected.com/master-the-concurrency-in-python-cedd070a913c?source=collection_archive---------5-----------------------#2020-07-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="7544" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如何在我的Python代码中引入并发性？子进程、线程、多进程…</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/566ce5c85a7746efaf8eaecab74ae72d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AiP7zawEO2z0txES1ayzIg.png"/></div></div></figure><p id="fd1f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">TL；DR:使用<code class="fe la lb lc ld b">subprocess</code>运行并发外部程序，但是使用<code class="fe la lb lc ld b">multiprocessing</code>将我们编写到Python中的任务划分到多个进程中。请关注细节和真实世界的例子。</p><h1 id="e8a8" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">Python中的线程</h1><p id="20b0" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated"><strong class="js iu"> CPython实现细节</strong>:在CPython中，由于<a class="ae mh" href="https://docs.python.org/3.7/glossary.html#term-global-interpreter-lock" rel="noopener ugc nofollow" target="_blank">全局解释器锁</a>，一次只能有一个线程执行Python代码(尽管某些面向性能的库可能会克服这个限制)(可以有多个线程，但它们都共享同一个CPU内核)。</p><p id="026c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你想让你的应用更好的利用多核机器的计算资源，建议你使用<a class="ae mh" href="https://docs.python.org/3.7/library/multiprocessing.html#module-multiprocessing" rel="noopener ugc nofollow" target="_blank">多处理</a>或者<a class="ae mh" href="https://docs.python.org/3.7/library/concurrent.futures.html#concurrent.futures.ProcessPoolExecutor" rel="noopener ugc nofollow" target="_blank">concurrent . futures . processpoolexecutor</a>。但是，如果您想要同时运行多个I/O绑定的任务，线程仍然是一个合适的模型，为此可以使用<code class="fe la lb lc ld b"><a class="ae mh" href="https://docs.python.org/3.7/library/threading.html" rel="noopener ugc nofollow" target="_blank"><strong class="js iu">threading</strong></a></code> <a class="ae mh" href="https://docs.python.org/3.7/library/threading.html" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">模块</strong> </a>。</p><h1 id="bc6a" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated"><code class="fe la lb lc ld b">subprocess</code>模块vs <code class="fe la lb lc ld b">multiprocessing</code>包</h1><p id="6a7d" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">当我们想要运行和控制其他程序时，我们也可以用命令行运行这些程序，这时<code class="fe la lb lc ld b"><a class="ae mh" href="http://0.0.0.0:8000/language_python.html#the-subprocess-module" rel="noopener ugc nofollow" target="_blank"><strong class="js iu">subprocess</strong></a></code>模块就派上了用场。它让我们将<strong class="js iu">外部程序</strong>集成到Python代码中。</p><p id="3426" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然而，<code class="fe la lb lc ld b">multiprocessing</code>包是我们用来将我们编写到Python 中的<strong class="js iu">任务分成多个进程的东西。这使我们能够更好地利用所有可用的处理器，并提高性能。这个模块有一个类似于<code class="fe la lb lc ld b"><a class="ae mh" href="http://0.0.0.0:8000/language_python.html#threading-in-python" rel="noopener ugc nofollow" target="_blank">threading</a></code>模块的API。</strong></p><h1 id="4f46" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated"><code class="fe la lb lc ld b">multiprocessing</code>套餐</h1><p id="31d9" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated"><code class="fe la lb lc ld b"><a class="ae mh" href="https://docs.python.org/3.7/library/multiprocessing.html#module-multiprocessing" rel="noopener ugc nofollow" target="_blank"><strong class="js iu">multiprocessing</strong></a></code>是一个支持使用类似于<code class="fe la lb lc ld b"><a class="ae mh" href="http://0.0.0.0:8000/language_python.html#threading-in-python" rel="noopener ugc nofollow" target="_blank">threading</a></code>模块的API生成进程的包。它提供了本地和远程并发，通过使用子进程而不是线程，有效地避开了<a class="ae mh" href="https://docs.python.org/3.7/glossary.html#term-global-interpreter-lock" rel="noopener ugc nofollow" target="_blank">全局解释器锁</a>。由于这个原因，<code class="fe la lb lc ld b">multiprocessing</code>模块允许程序员充分利用给定机器上的多个处理器。</p><p id="4405" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"/><code class="fe la lb lc ld b"><strong class="js iu">Process</strong></code><strong class="js iu">类</strong></p><p id="7017" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过创建一个<code class="fe la lb lc ld b"><a class="ae mh" href="https://docs.python.org/3.7/library/multiprocessing.html#multiprocessing.Process" rel="noopener ugc nofollow" target="_blank"><strong class="js iu">Process</strong></a></code>对象，然后调用它的<code class="fe la lb lc ld b">start()</code>方法(使流程活动)来产生流程。<code class="fe la lb lc ld b">Process</code>遵循<code class="fe la lb lc ld b"><a class="ae mh" href="https://docs.python.org/3.7/library/threading.html#threading.Thread" rel="noopener ugc nofollow" target="_blank">threading.Thread</a></code>的API。</p><p id="7a0b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">可以使用进程的<code class="fe la lb lc ld b">pid</code>属性来检查进程的PID，并且可以使用其<code class="fe la lb lc ld b">is_alive()</code>方法来检查它是否仍在运行(在使用<code class="fe la lb lc ld b">start()</code>方法启动之后)。</p><p id="b349" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"/><code class="fe la lb lc ld b"><strong class="js iu">Manager</strong></code><strong class="js iu">类</strong></p><p id="5b5d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe la lb lc ld b"><a class="ae mh" href="https://docs.python.org/3.7/library/multiprocessing.html#managers" rel="noopener ugc nofollow" target="_blank"><strong class="js iu">Manager</strong></a></code><a class="ae mh" href="https://docs.python.org/3.7/library/multiprocessing.html#managers" rel="noopener ugc nofollow" target="_blank"><strong class="js iu"/></a>提供了一种创建可以在不同进程之间共享的数据的方法，包括在不同机器上运行的进程之间通过网络共享。管理器对象控制管理<strong class="js iu">共享对象</strong>的服务器进程。</p><p id="58fc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，检查以下<code class="fe la lb lc ld b">run_in_parallel</code>功能:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mi"><img src="../Images/d586b175999385b6ebbb0d05deb12a10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sGsrsV4NEs3AUrYzy8TR6w.png"/></div></div></figure><h1 id="b604" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated"><code class="fe la lb lc ld b">subprocess</code>模块</h1><p id="214a" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">注意:您可能想比较一下<code class="fe la lb lc ld b">subprocess</code>模块和<code class="fe la lb lc ld b"><a class="ae mh" href="http://0.0.0.0:8000/language_python.html#the-multiprocessing-package" rel="noopener ugc nofollow" target="_blank">multiprocessing</a></code>包。</p><p id="5286" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意:最好使用子进程而不是线程，因为CPython中的GIL允许所有线程使用同一个且只有一个CPU内核。此外，每个进程都有自己的内存，而线程共享相同的内存。</p><p id="b1d1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe la lb lc ld b"><a class="ae mh" href="https://docs.python.org/3.7/library/subprocess.html#module-subprocess" rel="noopener ugc nofollow" target="_blank">subprocess</a></code>模块允许您生成新的(多个)进程，连接到它们的输入/输出/错误管道，并获得它们的返回代码。该模块旨在取代几个较旧的模块和功能，如<code class="fe la lb lc ld b"><a class="ae mh" href="http://0.0.0.0:8000/language_python.html#the-os-module" rel="noopener ugc nofollow" target="_blank">os.system</a></code>和<code class="fe la lb lc ld b">os.spawn*</code>。</p><p id="4874" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意:可以从<code class="fe la lb lc ld b">subprocess</code>模块访问<code class="fe la lb lc ld b"><a class="ae mh" href="http://0.0.0.0:8000/language_python.html#the-os-module" rel="noopener ugc nofollow" target="_blank">os</a></code>作为<code class="fe la lb lc ld b"><strong class="js iu">subprocess.os</strong></code>。同样，<code class="fe la lb lc ld b"><a class="ae mh" href="http://0.0.0.0:8000/language_python.html#the-sys-and-platform-modules" rel="noopener ugc nofollow" target="_blank">sys</a></code>模块可以作为<code class="fe la lb lc ld b"><strong class="js iu">subprocess.sys</strong></code>访问。</p><p id="a91d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，检查下面的<code class="fe la lb lc ld b">shell_command</code>功能:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mi"><img src="../Images/a4cf0663acf1f4f4e404eac7518384b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tecfC2jIgxZVPPGbMiXq4w.png"/></div></div></figure><h1 id="7799" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">与<code class="fe la lb lc ld b">asyncio</code>的并发</h1><p id="17a9" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated"><code class="fe la lb lc ld b"><a class="ae mh" href="https://docs.python.org/3.7/library/asyncio.html" rel="noopener ugc nofollow" target="_blank"><strong class="js iu">asnyncio</strong></a></code>是一个使用async/await语法编写并发代码的库。</p><p id="0145" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它被用作提供高性能网络和web服务器、数据库连接库、分布式任务队列等的多个Python异步框架的基础。</p><p id="6590" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe la lb lc ld b">asyncio</code>通常非常适合IO绑定和高级结构化网络代码。</p><p id="7f03" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">协程:</strong>参考<a class="ae mh" href="https://docs.python.org/3.7/library/asyncio-task.html" rel="noopener ugc nofollow" target="_blank">协程和任务</a>。</p><h1 id="01be" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">并发性和未来</h1><p id="1f33" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated"><code class="fe la lb lc ld b"><a class="ae mh" href="https://docs.python.org/3.7/library/concurrent.futures.html" rel="noopener ugc nofollow" target="_blank"><strong class="js iu">concurrent.futures</strong></a></code>模块为异步执行可调用程序提供了一个高级接口。</p><p id="02f5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">异步执行可以使用<code class="fe la lb lc ld b">ThreadPoolExecutor</code>通过线程来执行，也可以使用<code class="fe la lb lc ld b">ProcessPoolExecutor</code>通过单独的进程来执行。两者都实现了相同的接口，该接口由抽象的<code class="fe la lb lc ld b">Executor</code>类定义。</p><p id="ab96" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">这里有一些相关的有趣故事，你可能会觉得有帮助:</strong></p><ul class=""><li id="1611" class="mj mk it js b jt ju jx jy kb ml kf mm kj mn kn mo mp mq mr bi translated"><a class="ae mh" href="https://medium.com/@goyalmunish/fluent-numpy-187cc14f2832" rel="noopener">流畅的数字</a></li><li id="b015" class="mj mk it js b jt ms jx mt kb mu kf mv kj mw kn mo mp mq mr bi translated"><a class="ae mh" href="https://medium.com/@goyalmunish/fluent-pandas-22473fa3c30d" rel="noopener">流利的熊猫</a></li><li id="5b37" class="mj mk it js b jt ms jx mt kb mu kf mv kj mw kn mo mp mq mr bi translated"><a class="ae mh" href="https://medium.com/@goyalmunish/the-why-and-how-of-mapreduce-524f71561daf" rel="noopener">MapReduce的原因和方式</a></li><li id="f932" class="mj mk it js b jt ms jx mt kb mu kf mv kj mw kn mo mp mq mr bi translated"><a class="ae mh" href="https://medium.com/@goyalmunish/automate-your-browser-with-python-7f5907612820" rel="noopener">使用Python自动完成浏览器任务</a></li></ul></div></div>    
</body>
</html>