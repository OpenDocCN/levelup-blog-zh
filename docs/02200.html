<html>
<head>
<title>Recursion: In Layman’s Terms</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">递归:通俗地说</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/recursion-in-laymans-terms-32100fe92c79?source=collection_archive---------21-----------------------#2020-02-25">https://levelup.gitconnected.com/recursion-in-laymans-terms-32100fe92c79?source=collection_archive---------21-----------------------#2020-02-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/60919c90f229657e4d5c8976ca7dd526.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VNmVMK1oEulT8IGYgFxQIA.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">曼德勃罗集合</figcaption></figure><p id="98fe" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">啊…递归…</p><p id="8af0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">计算机科学本科生在成为伟大程序员的旅程中遇到的第一个大概念之一。可视化递归非常容易，这是我在这篇文章中的目标。</p><h2 id="d5b7" class="la lb iq bd lc ld le dn lf lg lh dp li kn lj lk ll kr lm ln lo kv lp lq lr ls bi translated">为什么我应该使用递归？</h2><p id="c49d" class="pw-post-body-paragraph kc kd iq ke b kf lt kh ki kj lu kl km kn lv kp kq kr lw kt ku kv lx kx ky kz ij bi translated">递归及其背后的概念是计算机系统的核心和力量。电脑真的很擅长为我们自动化事情。</p><blockquote class="ly"><p id="7115" class="lz ma iq bd mb mc md me mf mg mh kz dk translated">递归可以很好地做一件事:稍微改变一下就重复同样的函数。</p></blockquote><p id="dd91" class="pw-post-body-paragraph kc kd iq ke b kf mi kh ki kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz ij bi translated">递归和循环之间也有特殊的联系。</p><h2 id="b84f" class="la lb iq bd lc ld le dn lf lg lh dp li kn lj lk ll kr lm ln lo kv lp lq lr ls bi translated">火箭发射器。</h2><p id="1706" class="pw-post-body-paragraph kc kd iq ke b kf lt kh ki kj lu kl km kn lv kp kq kr lw kt ku kv lx kx ky kz ij bi translated">你是埃隆·马斯克，想为你的火箭发射设定一个计时器。假设您想将其设置为10，因为您想在YouTube上庆祝倒计时。</p><p id="d83c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们用Python做吧。</p><figure class="mn mo mp mq gt jr"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="bef6" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这个剧本说了什么？</p><ol class=""><li id="c292" class="mt mu iq ke b kf kg kj kk kn mv kr mw kv mx kz my mz na nb bi translated">这是一个叫做火箭发射器的功能</li><li id="2153" class="mt mu iq ke b kf nc kj nd kn ne kr nf kv ng kz my mz na nb bi translated">它由一个<em class="nh"> if-else </em>结构组成。它根据NumbersLeft是否为正数进行选择</li><li id="d702" class="mt mu iq ke b kf nc kj nd kn ne kr nf kv ng kz my mz na nb bi translated">如果NumbersLeft是正数，<em class="nh">打印并再次调用相同的函数</em>，NumbersLeft减1</li><li id="2c7d" class="mt mu iq ke b kf nc kj nd kn ne kr nf kv ng kz my mz na nb bi translated">对于其他情况(如果NumbersLeft小于零)，打印“火箭正在发射”</li></ol><figure class="mn mo mp mq gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ni"><img src="../Images/aa2fefcc12ad002bf7451aa02c02535b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yb7Q_bJRvNUJPuUksJXauA.png"/></div></div></figure><p id="9a71" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">想象一下，它看起来像这样。假设函数是用大于0的整数调用的。然后，它将调用一个递减的参数，直到数字为零。每个红色箭头都是一个函数调用。一句话。基本情况是零或更小的所有整数。</p><p id="5256" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">你能在这上面做一个变化吗？这在哪里也能派上用场？</p><h2 id="94d3" class="la lb iq bd lc ld le dn lf lg lh dp li kn lj lk ll kr lm ln lo kv lp lq lr ls bi translated">阶乘</h2><p id="0379" class="pw-post-body-paragraph kc kd iq ke b kf lt kh ki kj lu kl km kn lv kp kq kr lw kt ku kv lx kx ky kz ij bi translated">你们大多数人都知道阶乘函数。5!(感叹号表示阶乘)，是<em class="nh"> 5*4*3*2*1。</em> 3！就是<em class="nh"> 3*2*1 </em>。你开始看到模式了吗？这是递归的经典例子。</p><figure class="mn mo mp mq gt jr"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="2f7d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">除了一点之外，这段代码看起来和前面的几乎一样。else分支将当前整数乘以一个函数调用，而不只是再次调用自身。这个中间表达式被保存。</p><p id="7207" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">中间结果是<em class="nh">保存在栈</em>上，想象一个书栈。每次在else分支中再次调用该函数时，堆栈都会变高一点。</p><figure class="mn mo mp mq gt jr gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/395e80fb42683aecb61d881c01b0d10d.png" data-original-src="https://miro.medium.com/v2/resize:fit:498/format:webp/1*dHoyu5sQYwKZp7wrM-nS6Q.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">一个堆栈，可视化</figcaption></figure><p id="d876" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">当达到基本情况时，计算中间结果。</p><p id="a2d1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">阶乘函数可以总结如下。真的试着理解这一点。这种模式反复出现。</p><figure class="mn mo mp mq gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ni"><img src="../Images/e4186e9091addbc6e2475308dd5dc36c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*shJpC95ID1KnszTiwtj5xw.png"/></div></div></figure><p id="6eef" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们来解构一下这个。</p><ul class=""><li id="e974" class="mt mu iq ke b kf kg kj kk kn mv kr mw kv mx kz nk mz na nb bi translated">从一个整数<strong class="ke ir">开始</strong>(大于零)。</li><li id="d6cd" class="mt mu iq ke b kf nc kj nd kn ne kr nf kv ng kz nk mz na nb bi translated"><strong class="ke ir">将当前结果</strong>(绿线)保存在堆栈上，再次调用当前函数。(红色箭头)</li><li id="b5a8" class="mt mu iq ke b kf nc kj nd kn ne kr nf kv ng kz nk mz na nb bi translated">直到达到1(紫色)。然后计算结果。</li><li id="039e" class="mt mu iq ke b kf nc kj nd kn ne kr nf kv ng kz nk mz na nb bi translated">结果被重新构造，直到你开始的那个整数。(如果你从5开始，蓝色箭头，乘法返回到5)</li><li id="ed4e" class="mt mu iq ke b kf nc kj nd kn ne kr nf kv ng kz nk mz na nb bi translated">所有其他结果无效(棕色)</li></ul><h2 id="b2d0" class="la lb iq bd lc ld le dn lf lg lh dp li kn lj lk ll kr lm ln lo kv lp lq lr ls bi translated">递归的定义。漏斗功能</h2><p id="14cc" class="pw-post-body-paragraph kc kd iq ke b kf lt kh ki kj lu kl km kn lv kp kq kr lw kt ku kv lx kx ky kz ij bi translated">我已经给出了两个递归派上用场的例子。现在，是时候下一个定义了。</p><p id="00b5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">递归是一个函数稍微改变一下就调用自己。递归由两部分组成:递归情况和基本情况。</p><ul class=""><li id="b47e" class="mt mu iq ke b kf kg kj kk kn mv kr mw kv mx kz nk mz na nb bi translated"><strong class="ke ir">递归用例</strong>:向基本用例调用自身</li><li id="cba8" class="mt mu iq ke b kf nc kj nd kn ne kr nf kv ng kz nk mz na nb bi translated"><strong class="ke ir">基本情况</strong>:通话到此结束。(注意:在阶乘的情况下，返回值还有待构造)</li></ul><figure class="mn mo mp mq gt jr gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/970a82994a9cefd735cc69f2be4ff735.png" data-original-src="https://miro.medium.com/v2/resize:fit:794/format:webp/1*erfD0vTxCUoL1dqnG77pIw.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">漏斗，递归的一个类比</figcaption></figure><p id="c3fe" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">最好想象成一个漏斗。在<strong class="ke ir">漏斗功能</strong>(是的，我刚刚发明了这个)中的每一个输入都是有效的，并确保呼叫流向中心。基本情况结束了这一切。</p><h2 id="66eb" class="la lb iq bd lc ld le dn lf lg lh dp li kn lj lk ll kr lm ln lo kv lp lq lr ls bi translated">最优化</h2><p id="3c01" class="pw-post-body-paragraph kc kd iq ke b kf lt kh ki kj lu kl km kn lv kp kq kr lw kt ku kv lx kx ky kz ij bi translated">递归算法可能会耗尽内存。当堆栈不够大，无法容纳所有中间结果时，就会出现这种情况。然后，发生堆栈溢出(没错，这就是著名站点的名字)。</p><p id="5843" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">优化可以是<em class="nh">尾递归，或者迭代</em>。与基本递归的最大区别是结果保存在函数调用的参数中。因此，中间结果不再存储在堆栈中，而是存储在函数调用中。大多数现代(函数式)语言都实现了这种优化。在这种情况下，Python没有。</p><figure class="mn mo mp mq gt jr"><div class="bz fp l di"><div class="mr ms l"/></div></figure><blockquote class="ly"><p id="908e" class="lz ma iq bd mb mc nm nn no np nq kz dk translated">在这个例子中，函数参数<em class="nr"> prod </em>保存最终结果。这是存储在内存中的一个地方，这是非常有效的！</p></blockquote><figure class="ns nt nu nv nw jr"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="ecf1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我已经包括了两个额外的例子。<strong class="ke ir"> While和for循环</strong>。这些本质上是迭代结构。结果未保存。Python是一种相当高级的语言，但是一旦你使用低级语言，你必须自己构建这些结构。</p><p id="a5df" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">注意:第一个函数(Elon Musk的火箭发射器)是一个迭代函数。</p><h2 id="1814" class="la lb iq bd lc ld le dn lf lg lh dp li kn lj lk ll kr lm ln lo kv lp lq lr ls bi translated">无限循环和分形</h2><p id="8495" class="pw-post-body-paragraph kc kd iq ke b kf lt kh ki kj lu kl km kn lv kp kq kr lw kt ku kv lx kx ky kz ij bi translated">这一部分对于理解这个概念来说并不重要，但是很有趣。</p><p id="c148" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">无限循环</strong>是一种永远不会到达基本情况的递归。这可能是因为基础用例不存在，或者功能从来没有朝向基础用例。这将导致可怕的堆栈溢出！</p><figure class="mn mo mp mq gt jr gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/6226d463c1adb617fc3d384a3e17cc44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*QC_dVt9F7QT9xbi9a9nAYA.png"/></div></figure><p id="006b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">无限循环是可能自相似的循环。并且自相似性存在于:<strong class="ke ir">分形</strong>！分形是自相似的结构。当你放大一个分形，你会看到同样的东西。这是非常了不起的。树木是自然界中自相似性的完美例子之一。你越放大，你就越能反复看到同样的东西。这对大脑有一种相当平静的效果，因为我们天生适合模式识别。</p><h2 id="344e" class="la lb iq bd lc ld le dn lf lg lh dp li kn lj lk ll kr lm ln lo kv lp lq lr ls bi translated">摘要</h2><ul class=""><li id="3b13" class="mt mu iq ke b kf lt kj lu kn ny kr nz kv oa kz nk mz na nb bi translated">递归使得实现<em class="nh">循环</em>变得非常容易</li><li id="fd05" class="mt mu iq ke b kf nc kj nd kn ne kr nf kv ng kz nk mz na nb bi translated">递归是<em class="nh">函数调用自己</em></li><li id="5736" class="mt mu iq ke b kf nc kj nd kn ne kr nf kv ng kz nk mz na nb bi translated">递归由<strong class="ke ir">基本案例和一个递归案例</strong>组成</li><li id="9a95" class="mt mu iq ke b kf nc kj nd kn ne kr nf kv ng kz nk mz na nb bi translated">迭代改进了递归:<em class="nh">需要更少的内存</em>。</li></ul><h2 id="af91" class="la lb iq bd lc ld le dn lf lg lh dp li kn lj lk ll kr lm ln lo kv lp lq lr ls bi translated">结论</h2><p id="c40d" class="pw-post-body-paragraph kc kd iq ke b kf lt kh ki kj lu kl km kn lv kp kq kr lw kt ku kv lx kx ky kz ij bi translated">这是我的第一个技术作品。我当然想做得更多。</p><p id="12c7" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">您可以采取的行动</p><ul class=""><li id="dfbf" class="mt mu iq ke b kf kg kj kk kn mv kr mw kv mx kz nk mz na nb bi translated">用递归和迭代实现斐波那契</li><li id="a4ee" class="mt mu iq ke b kf nc kj nd kn ne kr nf kv ng kz nk mz na nb bi translated">实现分形树</li></ul><p id="f856" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">问题</p><ul class=""><li id="01e8" class="mt mu iq ke b kf kg kj kk kn mv kr mw kv mx kz nk mz na nb bi translated">你在现实生活中哪里看到递归？(提示:无处不在，尽量注意)</li></ul><p id="815e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">你对更多感兴趣吗？你想要什么？</p><p id="7a16" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">跟我来:</p><p id="db5c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><a class="ae ob" href="https://github.com/SimonVervisch" rel="noopener ugc nofollow" target="_blank"> Github </a></p><p id="8c19" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><a class="ae ob" href="https://www.youtube.com/watch?v=_n7YjGSDIWs&amp;t=1s" rel="noopener ugc nofollow" target="_blank"> YouTube </a></p><p id="6d9d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><a class="ae ob" href="https://twitter.com/the_simon_v" rel="noopener ugc nofollow" target="_blank">推特</a></p></div></div>    
</body>
</html>