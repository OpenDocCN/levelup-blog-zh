<html>
<head>
<title>RxSwift. Improve readability with good naming and packaging</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">RxSwift。通过良好的命名和包装提高可读性</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/rxswift-improve-readability-with-good-naming-and-packaging-80c391443478?source=collection_archive---------9-----------------------#2022-06-01">https://levelup.gitconnected.com/rxswift-improve-readability-with-good-naming-and-packaging-80c391443478?source=collection_archive---------9-----------------------#2022-06-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/7de257ce1795ec5344044a760e41c860.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E5F0r2rjUMxZggA4IhfvFA.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://www.youtube.com/watch?v=74FA1dyVVKs" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=74FA1dyVVKs</a></figcaption></figure><h1 id="3c25" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">动机</h1><p id="73bb" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">一般来说，当使用<strong class="ld ir"> RxSwfit </strong>实现<strong class="ld ir">枚举</strong>、<strong class="ld ir">结构</strong>和<strong class="ld ir">类</strong>时，通常会包含<strong class="ld ir">可观察的</strong>属性。在实现这些类型时，我经历过许多混乱的情况，因为<strong class="ld ir">可观察的</strong> <strong class="ld ir">和其他数据类型</strong>混合在一起。为了解决这些困难，我受RxSwift内部代码的启发，建立了自己的约定，在此分享一下。</p><h1 id="2748" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">通过示例探索</h1><p id="5444" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">下面我们来看一些常见的例子。<strong class="ld ir"> Struct ScreenManager </strong>包含一个属性<strong class="ld ir"> isFullscreen </strong>返回一个值<strong class="ld ir"> isFullscreenRelay </strong>和一个属性<strong class="ld ir"> isFullscreenObservable </strong>返回一个<strong class="ld ir"> Observable </strong>类型来隐藏<strong class="ld ir"> isFullscreenRelay </strong>。</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="f175" class="pw-post-body-paragraph lb lc iq ld b le mf lg lh li mg lk ll lm mh lo lp lq mi ls lt lu mj lw lx ly ij bi translated">事实上，如果值类型和可观察类型只有一个或两个属性，可读性不会受到很大影响。还可以通过IDE的自动完成功能轻松访问它。</p><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mk"><img src="../Images/0cf554012a95cee184850cd96f61fa78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lY-kTrE5lcLGPVl80cVDFA.png"/></div></div></figure><p id="47a1" class="pw-post-body-paragraph lb lc iq ld b le mf lg lh li mg lk ll lm mh lo lp lq mi ls lt lu mj lw lx ly ij bi translated">然而，在我们的编码世界中，有更多的实现比示例中简单而简洁的实现复杂得多，并且具有许多属性。</p><p id="2de9" class="pw-post-body-paragraph lb lc iq ld b le mf lg lh li mg lk ll lm mh lo lp lq mi ls lt lu mj lw lx ly ij bi translated">下面的代码也不是很复杂，但是我添加它是为了解释在实践中处理的代码的复杂性。随着<strong class="ld ir">值类型和可观察类型</strong>属性的增加，复杂性增加，可读性降低。</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="369b" class="pw-post-body-paragraph lb lc iq ld b le mf lg lh li mg lk ll lm mh lo lp lq mi ls lt lu mj lw lx ly ij bi translated"><strong class="ld ir">如何获得更易读、更简洁的代码，即更易读的代码？</strong> <br/>可以从RxSwift的内部实现得到提示。您可以通过反应性扩展来打包可观察的和绑定的属性。</p><div class="ml mm gp gr mn mo"><a href="https://github.com/ReactiveX/RxSwift/blob/main/RxCocoa/iOS/UIScrollView%2BRx.swift" rel="noopener  ugc nofollow" target="_blank"><div class="mp ab fo"><div class="mq ab mr cl cj ms"><h2 class="bd ir gy z fp mt fr fs mu fu fw ip bi translated">rx swift/ui scroll view+rx . swift at main react vex/rx swift</h2><div class="mv l"><h3 class="bd b gy z fp mt fr fs mu fu fw dk translated">此文件包含双向Unicode文本，其解释或编译可能与下面显示的不同…</h3></div><div class="mw l"><p class="bd b dl z fp mt fr fs mu fu fw dk translated">github.com</p></div></div><div class="mx l"><div class="my l mz na nb mx nc jw mo"/></div></div></a></div><p id="8bb4" class="pw-post-body-paragraph lb lc iq ld b le mf lg lh li mg lk ll lm mh lo lp lq mi ls lt lu mj lw lx ly ij bi translated">和<strong class="ld ir"> RxSwift </strong>的内部实现一样，我尝试通过反应式扩展来改进<strong class="ld ir"> ScreenManager </strong>。<br/>通过分离正常值和反应相关的类型属性，我们得到了可读性更好的代码。</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="5dc5" class="pw-post-body-paragraph lb lc iq ld b le mf lg lh li mg lk ll lm mh lo lp lq mi ls lt lu mj lw lx ly ij bi translated">使用<strong class="ld ir"> ScreenManager </strong>的一方可以比以前更容易地访问对象中声明的属性。在用户方面，可以通过一种明显不同的方法快速找到一般值和无功相关属性。</p><p id="cf7e" class="pw-post-body-paragraph lb lc iq ld b le mf lg lh li mg lk ll lm mh lo lp lq mi ls lt lu mj lw lx ly ij bi translated">您可以像以前一样访问对象的general value属性，并通过rx名称空间访问Reactive相关的属性。</p><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nd"><img src="../Images/52cee4e4111b38ef3f11c31f8716057b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8G3yNBOPhUv1uyTX0cuyjQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">访问值属性</figcaption></figure><figure class="lz ma mb mc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ne"><img src="../Images/76369d03e5fc85871dbd6a52f830b911.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XqJ99Y9EPe8K1QV7e18gXQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">访问与反应相关的属性</figcaption></figure><h1 id="fc59" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">奖金！反应性延伸</h1><p id="b324" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated"><strong class="ld ir"> Struct Reactive </strong>在RxSwift中实现，为继承<strong class="ld ir"> ReactiveCompatible </strong>协议的类型提供了各种附加函数。通过使用这个，提供了由基本SDK提供的基本类的扩展功能。</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="553d" class="pw-post-body-paragraph lb lc iq ld b le mf lg lh li mg lk ll lm mh lo lp lq mi ls lt lu mj lw lx ly ij bi translated">它使得像上面的示例代码一样简单地使用UIKit的反应式扩展成为可能。<br/>甚至自定义类型也可以用反应式扩展提供多个扩展功能。</p><h2 id="88bd" class="nf ke iq bd kf ng nh dn kj ni nj dp kn lm nk nl kr lq nm nn kv lu no np kz nq bi translated">需要知道的事情</h2><p id="fbc4" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated"><strong class="ld ir">首先</strong>，RxSwift对<strong class="ld ir">n对象</strong>进行反应式扩展。要对其他类型使用反应式扩展，您必须继承<strong class="ld ir">反应式兼容</strong>协议。</p><p id="5fd4" class="pw-post-body-paragraph lb lc iq ld b le mf lg lh li mg lk ll lm mh lo lp lq mi ls lt lu mj lw lx ly ij bi translated"><strong class="ld ir">第二个</strong>，对于类、枚举、结构的反应式扩展方法是不同的。请参考下面的例子</p><figure class="lz ma mb mc gt jr"><div class="bz fp l di"><div class="md me l"/></div></figure><h1 id="3325" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">结论</h1><p id="03d0" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">这非常简单，但我认为在考虑整个项目时，这是一个值得使用的技巧。在<strong class="ld ir"> RxSwift </strong>以及<strong class="ld ir"> Combine </strong>中，可以使用这个<strong class="ld ir">包扩展方法</strong>来划分名称空间，根据角色划分属性。</p></div></div>    
</body>
</html>