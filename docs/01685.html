<html>
<head>
<title>XML to JSON in Golang Demystified</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Golang中的XML到JSON去神秘化</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/xml-to-json-in-golang-demystified-6639fb090c31?source=collection_archive---------3-----------------------#2020-01-22">https://levelup.gitconnected.com/xml-to-json-in-golang-demystified-6639fb090c31?source=collection_archive---------3-----------------------#2020-01-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/b256f5fe967f199d0a4de81db97842ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pchgM_V1wuJqX4Z_m4G7kw@2x.png"/></div></div></figure><p id="93eb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在每个开发人员的生活中，XML数据都是不可避免的。RSS提要试图让这变得更容易，但每个人都喜欢好的旧JSON，除非你是一个虐待狂。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><p id="a6c5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在Golang中，我们可以用多种方式解决这个问题，比如使用一个<a class="ae lg" href="https://github.com/basgys/goxml2json" rel="noopener ugc nofollow" target="_blank"> XML到JSON库</a>，但是为什么不使用Go标准库并节省一些销售问题呢？</p><h1 id="752c" class="lh li it bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">构建我们自己的XML到JSON函数</h1><p id="61c5" class="pw-post-body-paragraph kb kc it kd b ke mf kg kh ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky im bi translated">我最近在做一件需要发布到网站上的中等RSS提要的事情，我想为什么不使用运行在<a class="ae lg" href="https://www.openfaas.com/" rel="noopener ugc nofollow" target="_blank"> OpenFaaS </a>上的GoLang函数来完成这件事。</p><h2 id="cd54" class="mk li it bd lj ml mm dn ln mn mo dp lr km mp mq lv kq mr ms lz ku mt mu md mv bi translated">创建新功能</h2><p id="f90d" class="pw-post-body-paragraph kb kc it kd b ke mf kg kh ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky im bi translated">要创建我们的新函数，我们需要使用OpenFaaS CLI</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="69d6" class="mk li it nb b gy nf ng l nh ni">$ faas new medium2json --lang=go</span></pre><p id="080f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们为OpenFaaS提供了一个超级简单的Golang处理程序。</p><h2 id="728d" class="mk li it bd lj ml mm dn ln mn mo dp lr km mp mq lv kq mr ms lz ku mt mu md mv bi translated">导入我们的库</h2><p id="856e" class="pw-post-body-paragraph kb kc it kd b ke mf kg kh ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky im bi translated">我们的功能需要几个库。所以还是导入吧。打开<em class="nj">函数/handler.go </em>并在包下添加导入</p><figure class="mw mx my mz gt ju"><div class="bz fp l di"><div class="nk nl l"/></div><figcaption class="nm nn gj gh gi no np bd b be z dk translated">进口！！</figcaption></figure><p id="c47d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你会注意到我添加了net/http，所以让我们利用它。</p><p id="9c2a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> <em class="nj">获取</em>我们的RSS源</strong></p><p id="76d4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">普通媒体用户将会知道在<a class="ae lg" href="https://medium.com/feed/@affix" rel="noopener">https://medium.com/feed/@affix</a>为每个用户公开了一个RSS提要</p><p id="839d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以利用这个提要，通过Go中的<a class="ae lg" href="https://golang.org/pkg/net/http/" rel="noopener ugc nofollow" target="_blank"> net/http </a>包使用一个简单的HTTP GET来获取我们需要的内容。让我们将它添加到我们的<code class="fe nq nr ns nb b">Handle</code>函数中:</p><figure class="mw mx my mz gt ju"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="1578" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">上面的代码非常简单，但是我总是被问到关于<code class="fe nq nr ns nb b">defer</code>语句的问题。</p><blockquote class="nt nu nv"><p id="81c6" class="kb kc nj kd b ke kf kg kh ki kj kk kl nw kn ko kp nx kr ks kt ny kv kw kx ky im bi translated">如果你不推迟，会发生什么？</p></blockquote><p id="1ef8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">答案很简单。如果不推迟<code class="fe nq nr ns nb b">Close()</code>，就会造成资源泄漏。当应用程序运行时，用于创建请求的资源永远不会关闭，并且<a class="ae lg" href="https://en.wikipedia.org/wiki/File_descriptor" rel="noopener ugc nofollow" target="_blank">文件描述符</a>不会被释放。</p><blockquote class="nt nu nv"><p id="bcce" class="kb kc nj kd b ke kf kg kh ki kj kk kl nw kn ko kp nx kr ks kt ny kv kw kx ky im bi translated">我需要关闭请求吗？</p></blockquote><p id="d616" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果主体没有同时读取到EOF和closed，客户端的底层往返器(通常是传输)可能无法为后续的“保持活动”请求重用到服务器的持久TCP连接。</p><h2 id="0dbd" class="mk li it bd lj ml mm dn ln mn mo dp lr km mp mq lv kq mr ms lz ku mt mu md mv bi translated">解析XML</h2><p id="bb1b" class="pw-post-body-paragraph kb kc it kd b ke mf kg kh ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky im bi translated">现在我们有了一些数据，我们应该解析它。但在此之前，我们需要一个结构来<a class="ae lg" href="https://golang.org/pkg/encoding/xml/#Unmarshal" rel="noopener ugc nofollow" target="_blank">解组数据。</a></p><p id="e615" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在上面的handler.go文件中，函数让我们创建一个结构来匹配我们需要的数据。GoLang解组函数的美妙之处在于，它允许我们在结构中只指定我们需要的字段。</p><figure class="mw mx my mz gt ju"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="96b4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您查看Medium Feed返回的XML，您会注意到我省略了许多不必要的字段，如<code class="fe nq nr ns nb b">Channel.Title</code>和<code class="fe nq nr ns nb b">Channel.Image</code>，因此<code class="fe nq nr ns nb b">xml.Unmarshal</code>函数不会尝试将这些字段添加到结构中。</p><p id="d3b1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你可能还注意到我有一个<code class="fe nq nr ns nb b">Posts []struct</code>没有出现在RSS提要上。这来自XML文档的items元素，该元素在结构的末尾用<code class="fe nq nr ns nb b">xml:”item”</code> <em class="nj"> </em>指定。解组函数将获取所有的item元素，并将它们解析到<code class="fe nq nr ns nb b">Posts []struct</code>中。</p><p id="d3cc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此，让我们将数据解析成<code class="fe nq nr ns nb b">Handle</code>函数中的结构:</p><figure class="mw mx my mz gt ju"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="90a0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">解组函数解析XML编码的数据，并将结果存储在由<code class="fe nq nr ns nb b">v</code>指向的值中，该值必须是任意的结构、片或字符串。不适合<code class="fe nq nr ns nb b">v</code>的格式良好的数据被丢弃。</p><p id="34eb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因为解组使用反射包，所以它只能分配给导出的字段。解组使用区分大小写的比较来将XML元素名与标记值和结构字段名进行匹配。</p><p id="f75f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">转换为JSON并返回</strong></p><p id="8aa9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们有了我们的结构，我们可以<a class="ae lg" href="https://golang.org/pkg/encoding/json/#Marshal" rel="noopener ugc nofollow" target="_blank">将它编组</a>到JSON。</p><figure class="mw mx my mz gt ju"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="bae7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Marshal返回输入接口的JSON编码。</p><p id="18b8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Marshal递归遍历值<code class="fe nq nr ns nb b">v</code>。如果遇到的值实现了封送拆收器接口并且不是nil指针，则Marshal调用其MarshalJSON方法来产生JSON。</p><p id="0f09" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">由于Marshal函数产生了一个<code class="fe nq nr ns nb b">[]byte</code>，当我们使用<code class="fe nq nr ns nb b">string()</code>从<code class="fe nq nr ns nb b">Handle</code>函数返回时，我们需要将它转换成一个字符串。</p><h2 id="3a45" class="mk li it bd lj ml mm dn ln mn mo dp lr km mp mq lv kq mr ms lz ku mt mu md mv bi translated"><strong class="ak">部署到OpenFaaS </strong></h2><p id="f8ff" class="pw-post-body-paragraph kb kc it kd b ke mf kg kh ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky im bi translated">现在，我们可以将我们的功能部署到OpenFaaS集群:</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="3356" class="mk li it nb b gy nf ng l nh ni">$ faas up -f medium2json.yml</span></pre><blockquote class="nt nu nv"><p id="5c18" class="kb kc nj kd b ke kf kg kh ki kj kk kl nw kn ko kp nx kr ks kt ny kv kw kx ky im bi translated">$ FAAS up-f medium2json . yml<br/>【0】&gt;建筑medium 2 JSON。<br/>清除临时构建文件夹:。/build/medium2json/ <br/>准备。/medium2json/。/build/medium 2 JSON//function<br/>build:sticking xx/medium 2 JSON:最新带go模板。请稍候..<br/>将构建上下文发送到Docker守护程序7.68kB</p></blockquote><p id="7656" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一旦您部署了您的函数，您就可以使用curl来测试它:</p><pre class="mw mx my mz gt na nb nc nd aw ne bi"><span id="917c" class="mk li it nb b gy nf ng l nh ni">curl -X POST -d “affix” <a class="ae lg" href="https://gateway.faas.kfj.io/function/medium2json" rel="noopener ugc nofollow" target="_blank">https://gateway.faas.kfj.io/function/medium2json</a></span></pre><blockquote class="nt nu nv"><p id="f169" class="kb kc nj kd b ke kf kg kh ki kj kk kl nw kn ko kp nx kr ks kt ny kv kw kx ky im bi translated">curl -X POST -d "词缀"<a class="ae lg" href="https://gateway.faas.kfj.io/function/medium2json" rel="noopener ugc nofollow" target="_blank">https://gateway.faas.kfj.io/function/medium2json</a><br/>[{ " Title ":" # FAAS Friday—构建无服务器微博…</p></blockquote><p id="6a1b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">以上URL目前已部署，请随意查看使用结果。</p><h1 id="f926" class="lh li it bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">TLDR；完整的功能代码</h1><figure class="mw mx my mz gt ju"><div class="bz fp l di"><div class="nk nl l"/></div></figure></div></div>    
</body>
</html>