<html>
<head>
<title>The Many Ways to Write JavaScript Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编写JavaScript函数的多种方法</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/the-many-ways-to-write-javascript-functions-f5e42be0a30c?source=collection_archive---------13-----------------------#2020-06-30">https://levelup.gitconnected.com/the-many-ways-to-write-javascript-functions-f5e42be0a30c?source=collection_archive---------13-----------------------#2020-06-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="b93d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">函数可能是编程中的主要对象，但是您可能会在JavaScript中看到它们以许多不同的方式编写，甚至是在同一个代码库中——这是因为函数根据其定义方式而具有不同的属性。</p><p id="ad34" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是您在JavaScript编程之旅中可能遇到的不同类型函数的现场指南，来自MDN Web Docs 的<a class="ae kl" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions#Defining_functions" rel="noopener ugc nofollow" target="_blank">文档。</a></p><h1 id="19cd" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">概观</h1><p id="64f3" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">编写函数的语法决定了这些属性:函数是否被提升，是否被命名，是否有隐式返回，或者是否在词汇上绑定了关键字<code class="fe lp lq lr ls b">this</code>的值。</p><p id="7ffe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我制作了这个图表来总结我们的工作:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi lt"><img src="../Images/bdcc3d9bd1fb6c53763ca6651cc483d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cz7cauHdXcTG1Egid2ru1g.png"/></div></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">注意:函数和生成器函数都可以使用各自的对象构造函数来创建，但不推荐这样做。</figcaption></figure><h1 id="9343" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">函数声明</h1><p id="4429" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">我发现这是用普通JavaScript编写函数最常见的方式。这里有一个例子:</p><pre class="lu lv lw lx gt mj ls mk ml aw mm bi"><span id="064d" class="mn kn iq ls b gy mo mp l mq mr">cow() //=&gt; "moo"</span><span id="1143" class="mn kn iq ls b gy ms mp l mq mr">function cow() {return "moo"}</span></pre><p id="2acf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，该函数可以在声明之前调用，因为它的定义是在编译期间、代码执行之前放入内存中的。</p><p id="d060" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于函数声明，以及除箭头函数之外的所有其他类型的函数，<code class="fe lp lq lr ls b">this</code>关键字的值根据其执行上下文而变化。在ES2015中，<code class="fe lp lq lr ls b">.bind(someObj)</code>方法允许你在对象传入. bind时永久设置<code class="fe lp lq lr ls b">this</code>的值。</p><pre class="lu lv lw lx gt mj ls mk ml aw mm bi"><span id="3877" class="mn kn iq ls b gy mo mp l mq mr">function f() {<br/>  return this.a;<br/>}<br/><br/>var g = f.bind({a: 'azerty'});<br/>console.log(g()) //=&gt; azerty<br/><br/>var h = g.bind({a: 'yoo'}); // bind only works once!<br/>console.log(h()) //=&gt; azerty<br/><br/>var o = {a: 37};<br/>console.log(o.a, o.f(), o.g(), o.h()) //=&gt; 37,37, azerty, azerty</span></pre><p id="27d2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">(修改自:<a class="ae kl" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Reference/Operators/this</a>)</p><h1 id="75d5" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">函数表达式</h1><p id="5d32" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">函数表达式与函数声明不同，不必命名，也不需要提升。</p><p id="5ff1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">未命名的，或<em class="mt">匿名的</em>函数，通常被用作回调函数，因为它们会被立即调用。然而，MDN Web Docs指出，命名函数仍然是有用的，这样可以更容易地在调用栈中跟踪它们。</p><pre class="lu lv lw lx gt mj ls mk ml aw mm bi"><span id="e26f" class="mn kn iq ls b gy mo mp l mq mr">const dog = function() { return "bark" }</span><span id="591e" class="mn kn iq ls b gy ms mp l mq mr">dog() //=&gt; "bark"</span><span id="6909" class="mn kn iq ls b gy ms mp l mq mr">(function() {return "meow"})() //=&gt; "meow"</span></pre><p id="048d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">即使已命名，也不能重用立即调用的函数。</p><pre class="lu lv lw lx gt mj ls mk ml aw mm bi"><span id="c85b" class="mn kn iq ls b gy mo mp l mq mr">(function sheep() { return "baa" })() //=&gt; "baa"</span><span id="61bf" class="mn kn iq ls b gy ms mp l mq mr">sheep() //=&gt; ReferenceError: sheep is not defined</span></pre><h1 id="99da" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">函数*声明</h1><p id="c3a5" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">使用<code class="fe lp lq lr ls b">function*</code>关键字定义了一种特殊类型的函数，称为生成函数。</p><p id="c2de" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">与调用时一直执行的常规函数不同，生成器是可以退出的函数，以后可以在不同的点重新进入。这允许它们改变它们返回的值，即使是用相同的参数调用。</p><pre class="lu lv lw lx gt mj ls mk ml aw mm bi"><span id="c10f" class="mn kn iq ls b gy mo mp l mq mr">function* yieldAndReturn() {<br/>  yield "Yield"<br/>  return "Return"<br/>  yield "unreachable"<br/>}</span><span id="b7ba" class="mn kn iq ls b gy ms mp l mq mr">const gen = yieldAndReturn()</span><span id="a983" class="mn kn iq ls b gy ms mp l mq mr">console.log(gen.next()) //=&gt; { value: "Yield", done: false }</span><span id="d7f7" class="mn kn iq ls b gy ms mp l mq mr">console.log(gen.next()) //=&gt; { value: "Return", done: true }</span><span id="dadb" class="mn kn iq ls b gy ms mp l mq mr">console.log(gen.next()) //=&gt; { value: undefined, done: true }</span></pre><p id="de1e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">(修改自<a class="ae kl" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Reference/Statements/function *</a>)</p><p id="1514" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">调用时，生成器函数返回一个带有三个实例方法的生成器对象:<code class="fe lp lq lr ls b">.next</code>、<code class="fe lp lq lr ls b">.return</code>和<code class="fe lp lq lr ls b">.throw</code>。调用<code class="fe lp lq lr ls b">.next()</code>会返回一个带有键<code class="fe lp lq lr ls b">value</code>和<code class="fe lp lq lr ls b">done</code>的对象，键【】指向yield，键<code class="fe lp lq lr ls b">done</code>指向一个布尔值，指示生成器函数是否已经到达其主体的末尾。</p><p id="e4d6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">发电机功能和<code class="fe lp lq lr ls b"><a class="ae kl" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function" rel="noopener ugc nofollow" target="_blank">async functions</a></code>一起用于异步编程。</p><h1 id="d863" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">函数*表达式</h1><p id="62f2" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">生成器函数也可以写成表达式。函数*定义被提升，而函数*表达式不被提升。</p><pre class="lu lv lw lx gt mj ls mk ml aw mm bi"><span id="9d0b" class="mn kn iq ls b gy mo mp l mq mr">const foo = function* () {<br/>  yield 10<br/>  yield 20<br/>}</span><span id="d872" class="mn kn iq ls b gy ms mp l mq mr">console.log(foo().next()) //=&gt; { value: 10, done: false }<br/>console.log(foo().next()) //=&gt; { value: 10, done: false }</span></pre><p id="343c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">(修改自<a class="ae kl" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Reference/Statements/function *</a>)</p><p id="60e4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意(对于function*声明和表达式)您必须将函数返回的生成器对象保存在一个变量中，以便使用<code class="fe lp lq lr ls b">.next()</code>遍历函数。</p><pre class="lu lv lw lx gt mj ls mk ml aw mm bi"><span id="cb14" class="mn kn iq ls b gy mo mp l mq mr">const foo = function* () {<br/>  yield 10<br/>  yield 20<br/>}</span><span id="741a" class="mn kn iq ls b gy ms mp l mq mr">const gen = foo()</span><span id="031f" class="mn kn iq ls b gy ms mp l mq mr">console.log(gen.next()) //=&gt; { value: 10, done: false }</span><span id="8afd" class="mn kn iq ls b gy ms mp l mq mr">console.log(gen.next()) //=&gt; { value: 20, done: false }</span><span id="1409" class="mn kn iq ls b gy ms mp l mq mr">console.log(gen.next()) //=&gt; { value: undefined, done: true }</span></pre><p id="ec1c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每次调用该函数时，都会返回一个新的生成器对象。</p><pre class="lu lv lw lx gt mj ls mk ml aw mm bi"><span id="97eb" class="mn kn iq ls b gy mo mp l mq mr">const foo = function* () {<br/>  yield 10<br/>  yield 20</span><span id="c824" class="mn kn iq ls b gy ms mp l mq mr">}</span><span id="166f" class="mn kn iq ls b gy ms mp l mq mr">const gen = foo()<br/>const bar = foo()<br/>console.log(gen === bar) //=&gt; false</span></pre><h1 id="d146" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">箭头功能</h1><p id="f417" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">最后，箭头函数是编写函数的一种独特的、非命名的方式。它们没有被升起。</p><pre class="lu lv lw lx gt mj ls mk ml aw mm bi"><span id="d09e" class="mn kn iq ls b gy mo mp l mq mr">const arrowFn = () =&gt; "hi"<br/>arrowFn() // =&gt; "hi"</span><span id="0fab" class="mn kn iq ls b gy ms mp l mq mr">(() =&gt; "hi")() //immediately invoked arrow function</span></pre><p id="998a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当<em class="mt">定义</em>时，箭头函数隐式地将<code class="fe lp lq lr ls b">this</code>的值绑定到其词法上下文。</p><p id="cd4a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从语法上来说，箭头函数有一些变化。如果有一个参数，则左括号是可选的，但是如果有零个、两个或更多参数，则左括号必须出现。如果只有一个表达式，函数体的括号也是可选的，但是如果返回一个对象，就需要用括号括起来。</p><pre class="lu lv lw lx gt mj ls mk ml aw mm bi"><span id="2cfb" class="mn kn iq ls b gy mo mp l mq mr">param =&gt; expression <br/>(param) =&gt; { return expression }</span><span id="c756" class="mn kn iq ls b gy ms mp l mq mr">// these two are equivalent</span></pre></div></div>    
</body>
</html>