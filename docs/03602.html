<html>
<head>
<title>Using Truth Tables to Write Better Unit Tests</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用真值表编写更好的单元测试</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/using-truth-tables-to-write-better-unit-tests-dd187f4a08e6?source=collection_archive---------16-----------------------#2020-05-18">https://levelup.gitconnected.com/using-truth-tables-to-write-better-unit-tests-dd187f4a08e6?source=collection_archive---------16-----------------------#2020-05-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/4f3550b908eefb78c58ee7a703ffaf8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1106/format:webp/1*DpTsflVBBHOa0cGBoVskaQ.jpeg"/></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">除了外星阴谋论——这个家伙是用真值表编写单元测试的大力提倡者</figcaption></figure><p id="5567" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">几年前，我在一家小初创公司工作，该公司忙于测试，这对我来说是一个巨大的精神转变，因为我在一家大得多的公司工作了两年，编写了大约0个测试。是的，我以前的公司依赖于一个QA团队，在将我们的代码发布到野外之前，对我们能想象到的所有用户行为场景进行艰苦的测试。令人惊讶的是，这在很大程度上起了作用。</p><p id="a517" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">虽然不编写测试肯定会使开发更快(至少在最初)，但单元测试是大多数现代科技公司的标准，现在我发现自己不仅在为编写单元和集成测试的语法而奋斗，而且整个想法非常陌生，我经常不知道从哪里开始。当测试一个可能有许多排列的组件或方法时，我的测试看起来会像这样:</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="d458" class="li lj it le b gy lk ll l lm ln">//coolMethod.js</span><span id="dced" class="li lj it le b gy lo ll l lm ln">const maybeTruncate = (word, length = 5) =&gt; {</span><span id="6b6f" class="li lj it le b gy lo ll l lm ln">  if(!word.length){</span><span id="4d14" class="li lj it le b gy lo ll l lm ln">    return 'N/A';</span><span id="2edb" class="li lj it le b gy lo ll l lm ln">  }</span><span id="f888" class="li lj it le b gy lo ll l lm ln">  return word.length &gt; length ? `${word.slice(0, length)}...` : word;</span><span id="8f1b" class="li lj it le b gy lo ll l lm ln">}</span><span id="8775" class="li lj it le b gy lo ll l lm ln"><br/>//coolMethod.spec.js</span><span id="4bdf" class="li lj it le b gy lo ll l lm ln">it('supports long words', () =&gt; {</span><span id="c668" class="li lj it le b gy lo ll l lm ln">  expect(maybeTruncate('really big word')).to.equal('reall...')</span><span id="514c" class="li lj it le b gy lo ll l lm ln">})</span><span id="2109" class="li lj it le b gy lo ll l lm ln">it('supports short words', () =&gt; {</span><span id="81b4" class="li lj it le b gy lo ll l lm ln">  expect(maybeTruncate('short')).to.equal('short')</span><span id="06d0" class="li lj it le b gy lo ll l lm ln">})</span><span id="fea8" class="li lj it le b gy lo ll l lm ln">it('supports custom length', () =&gt; {</span><span id="8964" class="li lj it le b gy lo ll l lm ln">  expect(maybeTruncate('kinda big', 10)).to.equal('kinda big')</span><span id="d5b6" class="li lj it le b gy lo ll l lm ln">})</span><span id="0528" class="li lj it le b gy lo ll l lm ln">it('supports no word', () =&gt; {</span><span id="6194" class="li lj it le b gy lo ll l lm ln">  expect(maybeTruncate('')).to.equal('N/A')</span><span id="0326" class="li lj it le b gy lo ll l lm ln">})</span></pre><p id="187f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有一天，我团队中的一个聪明的开发人员审查了我的代码，看了一个与上面类似的测试，给了我一些好的建议:“不要再写那样的测试了，你这个傻瓜”或者类似的话。即使以软件开发者的标准来看，他也有点古怪。然后他打开了他神奇的编码包，向我展示了他写测试的方法。</p><p id="2d43" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在这个聪明的家伙特别适合提供测试建议，因为他已经为EmberJS开发人员编写了一个流行的库来模拟数据，他与我分享的这个测试知识的小金块从那时起就一直伴随着我。</p><h2 id="6918" class="li lj it bd lp lq lr dn ls lt lu dp lv km lw lx ly kq lz ma mb ku mc md me mf bi translated">使用真值表</h2><p id="1c67" class="pw-post-body-paragraph kb kc it kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated">在布尔代数中，真值表通常用来表示由值的组合产生的数学结果。我们可以通过编写一组条件和预期结果，将同样的逻辑应用于创建测试。这不仅使我们的代码更容易推理，还使测试更简洁，当我们的功能或组件不可避免地发生变化时，可以很容易地修改测试以添加不同的测试条件。</p><p id="91f7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">重构上面的测试以使用真值表看起来会像这样:</p><pre class="kz la lb lc gt ld le lf lg aw lh bi"><span id="1910" class="li lj it le b gy lk ll l lm ln">const tests = [<br/>  //test              word              length      expected<br/>  ['no word',         '',               undefined,  'N/A'],<br/>  ['short word',     'Short',           undefined,  'Short'],<br/>  ['long word',      'Not so short',    undefined,  'Not s...'],<br/>  ['custom length',  'Not short',       15,         'Not short'],<br/>]</span><span id="6561" class="li lj it le b gy lo ll l lm ln">test.forEach((test) =&gt; {<br/>  const [assertion, word, length, expected] = test;  <br/>  it(`supports ${assertion}`, () =&gt; {<br/>    expect(maybeTruncate(word, length)).to.equal(expected)<br/>  })<br/>})</span></pre><p id="d645" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，当一个新的场景需要测试时，只需向我们的真值表中插入一些值，然后让我们的测试套件自然运行。这减少了样板代码和过于冗长的测试，还明确定义了我们应该知道的输入可能性，而不是通过搜索一组测试来寻找怪异的边缘情况。</p><h2 id="390d" class="li lj it bd lp lq lr dn ls lt lu dp lv km lw lx ly kq lz ma mb ku mc md me mf bi translated">结论</h2><p id="5321" class="pw-post-body-paragraph kb kc it kd b ke mg kg kh ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky im bi translated">编写测试本身就是一种艺术形式，虽然我最初没有看到它们的价值，但我已经开始欣赏它们如何捕捉我最初没有准备好的场景，并且在重构不属于你的代码时，也可以让你感觉舒服得多。</p><p id="cc35" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">具有良好覆盖率的强大测试套件可以让您更加确信，您在五年前的文件中的第183行所做的更改没有破坏管道中的其他东西。真值表很有希望成为一种模式，你可以用它来使你的测试更简洁，更明确，也许更重要的是，写起来更有趣。</p></div></div>    
</body>
</html>