<html>
<head>
<title>Introduction to Using JSX and Rendering with React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用JSX和React渲染简介</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/introduction-to-using-jsx-and-rendering-with-react-38dfa1221a98?source=collection_archive---------14-----------------------#2020-02-18">https://levelup.gitconnected.com/introduction-to-using-jsx-and-rendering-with-react-38dfa1221a98?source=collection_archive---------14-----------------------#2020-02-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/a943afd67e854ff7671328e455f83f5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JGd_vrE_UbOjRORU"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@pepegombos?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Peter G </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><p id="2651" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">React是一个用于创建前端视图的库。它有一个庞大的图书馆生态系统与之合作。此外，我们可以用它来增强现有的应用程序。</p><p id="6b2c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">编写应用程序最简单的方法是使用JSX。在这篇文章中，我们将看看如何使用JSX来编写动态反应应用程序。</p><h1 id="c994" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">在JSX嵌入表达式</h1><p id="803b" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以在花括号之间嵌入JavaScript表达式。例如，我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="9f68" class="mq lf it mm b gy mr ms l mt mu">import React from "react";<br/>import ReactDOM from "react-dom";<br/>function App() {<br/>  const greeting = "Hello World";<br/>  return (<br/>    &lt;div&gt;<br/>      &lt;h1&gt;{greeting}&lt;/h1&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}<br/>const rootElement = document.getElementById("root");<br/>ReactDOM.render(&lt;App /&gt;, rootElement);</span></pre><p id="3529" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们又在屏幕上看到了Hello World。</p><p id="2344" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一些更有用的世界调用如下函数:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="2194" class="mq lf it mm b gy mr ms l mt mu">import React from "react";<br/>import ReactDOM from "react-dom";<br/>function App() {<br/>  const formatName = user =&gt; {<br/>    return `${user.firstName} ${user.lastName}`;<br/>  };</span><span id="a6b7" class="mq lf it mm b gy mv ms l mt mu">const user = {<br/>    firstName: "Jane",<br/>    lastName: "Smith"<br/>  };</span><span id="68a0" class="mq lf it mm b gy mv ms l mt mu">return (<br/>    &lt;div&gt;<br/>      &lt;h1&gt;{formatName(user)}&lt;/h1&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}<br/>const rootElement = document.getElementById("root");<br/>ReactDOM.render(&lt;App /&gt;, rootElement);</span></pre><p id="be3d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们在<code class="fe mw mx my mm b">App</code>组件中定义了一个<code class="fe mw mx my mm b">formatName</code>函数，它接受一个<code class="fe mw mx my mm b">user</code>对象并返回连接在一起的<code class="fe mw mx my mm b">user.firstName</code>和<code class="fe mw mx my mm b">user.lastName</code>。</p><p id="0a1d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们用这些属性定义了一个<code class="fe mw mx my mm b">user</code>对象，并在花括号内调用函数。</p><p id="0e48" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">无论返回什么，都将显示在大括号之间。在这种情况下，它会是简·史密斯。</p><h1 id="dfff" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">用JSX指定属性</h1><p id="5046" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以通过将kebab大小写或小写属性名改为camel大小写来为JSX添加HTML属性。</p><p id="1843" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="5262" class="mq lf it mm b gy mr ms l mt mu">import React from "react";<br/>import ReactDOM from "react-dom";<br/>function App() {<br/>  return (<br/>    &lt;div&gt;<br/>      &lt;h1 tabIndex="0"&gt;Foo&lt;/h1&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}<br/>const rootElement = document.getElementById("root");<br/>ReactDOM.render(&lt;App /&gt;, rootElement);</span></pre><p id="778a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在HTML中<code class="fe mw mx my mm b">tabindex</code>是属性，但在JSX，它被称为<code class="fe mw mx my mm b">tabIndex</code>。</p><p id="7f1e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mw mx my mm b">"0"</code>将被React解释为字符串。</p><p id="f198" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们想传入一个数字，我们必须写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="2b56" class="mq lf it mm b gy mr ms l mt mu">&lt;h1 tabIndex={0}&gt;Foo&lt;/h1&gt;</span></pre><p id="1af0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">任何其他有效的JavaScript表达式也可以在花括号之间。</p><p id="a406" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">其他重要的属性包括HTML <code class="fe mw mx my mm b">class</code>属性，在JSX是<code class="fe mw mx my mm b">className</code>。</p><h1 id="f1cf" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">JSX防止注射攻击</h1><p id="e025" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">JSX会对注射到任何地方的输入进行消毒。这意味着React在渲染之前会对嵌入在JSX中的任何内容进行转义。</p><p id="f0d3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这应该可以防止恶意代码从注入JSX代码的脚本中运行。</p><h1 id="bf02" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">JSX代表物体</h1><p id="c509" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">JSX代码和<code class="fe mw mx my mm b">React.createElement</code>返回的组件相同。</p><p id="1a70" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="ec23" class="mq lf it mm b gy mr ms l mt mu">const App = &lt;h1 className="hello"&gt;Hello, world!&lt;/h1&gt;;</span></pre><p id="cac9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">与以下内容相同:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="302b" class="mq lf it mm b gy mr ms l mt mu">const App = React.createElement("h1", { className: "hello" }, "Hello, world!");</span></pre><p id="1dfd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它们都被称为反应元素，描述我们在屏幕上看到的东西。React使用返回的对象来构造DOM并更新它。</p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/5a97e4f602678e4754ed61c163418a86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XQAYz7EiPcAm2WFS"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@mr_fresh?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Yura Fresh </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="5f9f" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">渲染元素</h1><p id="6ef2" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">React元素是普通对象，创建它们不需要太多资源。</p><p id="3e45" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我们在前面的例子中看到的，用React构建的应用程序被装载到单个元素中并被渲染。</p><p id="79bb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们想将React组件集成到现有的应用程序中，我们通常会做如下事情:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="5d62" class="mq lf it mm b gy mr ms l mt mu">import React from "react";<br/>import ReactDOM from "react-dom";</span><span id="f622" class="mq lf it mm b gy mv ms l mt mu">const App = &lt;h1&gt;Hello, world&lt;/h1&gt;;</span><span id="0541" class="mq lf it mm b gy mv ms l mt mu">const rootElement = document.getElementById("root");<br/>ReactDOM.render(App, rootElement);</span></pre><p id="bcaf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">React应用程序总是需要有一个根节点，在这里它可以挂载到一个现有的DOM元素中。</p><h1 id="9a09" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">更新呈现的元素</h1><p id="5a63" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">React元素是不可变的。因此，一旦它们被创建，我们就可以改变它的子元素或属性。</p><p id="bfdd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们想要更新内容，我们必须再次创建它并将其传递给<code class="fe mw mx my mm b">ReactDOM.render()</code>。</p><p id="e71b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们想用React创建一个时钟小部件，我们可以这样做:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="0281" class="mq lf it mm b gy mr ms l mt mu">import React from "react";<br/>import ReactDOM from "react-dom";</span><span id="c5de" class="mq lf it mm b gy mv ms l mt mu">function tick() {<br/>  const element = (<br/>    &lt;div&gt;<br/>      &lt;p&gt;{new Date().toLocaleTimeString()}&lt;/p&gt;<br/>    &lt;/div&gt;<br/>  );<br/>  ReactDOM.render(element, document.getElementById("root"));<br/>}</span><span id="a2b5" class="mq lf it mm b gy mv ms l mt mu">setInterval(tick, 1000);</span></pre><p id="10eb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们有一个包含<code class="fe mw mx my mm b">element</code>对象的<code class="fe mw mx my mm b">tick</code>函数，它是一个React组件，将当前日期格式化为时间字符串。</p><p id="1948" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后它通过传入<code class="fe mw mx my mm b">element</code>并将其安装在ID为<code class="fe mw mx my mm b">root</code>的元素中来调用<code class="fe mw mx my mm b">ReactDOM.render</code>。</p><p id="2775" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后一旦定义了<code class="fe mw mx my mm b">tick</code>函数，我们就把它传递给<code class="fe mw mx my mm b">setInterval</code>每秒调用一次。</p><h1 id="1675" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">React只更新必要的内容</h1><p id="152f" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">React将元素及其子节点与前一个元素进行比较，并将它们之间的差异应用于DOM。</p><p id="e748" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，只有日期字符串发生了变化，所以只有它会被更新。</p><p id="2ba9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在使用React构建应用程序时，这是一个不用担心的问题。</p><h1 id="7332" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="e06d" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以使用JSX轻松构建React应用程序。</p><p id="ef17" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了传入HTML属性，我们在camelCase中编写属性名，并在花括号之间传入任何值或表达式。如果是字符串，我们可以把内容放在引号中。</p><p id="8602" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了使我们编写的代码安全，React在呈现字符之前对它们进行转义，以便恶意代码无法运行。</p><p id="89d1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">React组件是不可变的。一旦它们被创建，我们就不能改变任何东西，除非用新数据再次创建它们。</p><p id="c272" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">React自动比较新的和以前的DOM结构，并且只应用需要应用的更改。</p></div></div>    
</body>
</html>