<html>
<head>
<title>Display Images like Google and Flickr with Vue.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Vue.js显示Google和Flickr等图像</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/display-images-like-google-and-flickr-with-vue-js-e4cb8159ecfa?source=collection_archive---------3-----------------------#2019-11-15">https://levelup.gitconnected.com/display-images-like-google-and-flickr-with-vue-js-e4cb8159ecfa?source=collection_archive---------3-----------------------#2019-11-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/6016d22f89e25797985162428082a57a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8X8-ZJyEBnUxXAhuOhTAxQ.png"/></div></div></figure><p id="f461" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你使用像谷歌图片搜索或Flickr这样的图片搜索网站，你会注意到它们的图片显示在一个网格中，看起来像一堵砖墙。这些图像高度不均匀，但宽度相等。这被称为砖石效应，因为它看起来像一堵砖墙。</p><p id="50bb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了实现砖石效果，我们必须将图像的宽度设置为与屏幕宽度成比例，并将图像的高度设置为与图像的纵横比成比例。</p><p id="1f12" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果在没有任何库的情况下完成，这是一件痛苦的事情，所以人们制作了一些包来创造这种效果。</p><p id="0848" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在本文中，我们将构建一个照片应用程序，允许用户搜索图像并在砖石网格中显示图像。图像网格将无限滚动，以获得更多的图像。我们将使用<code class="fe kz la lb lc b">vue-masonry</code>库渲染图像网格，使用<code class="fe kz la lb lc b"> vue-infinite-scroll</code>渲染无限滚动效果。</p><p id="2c60" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们的应用程序将显示来自Pixabay API的图像。您可以查看API文档并在<a class="ae ld" href="https://pixabay.com/api/docs/" rel="noopener ugc nofollow" target="_blank">https://pixabay.com/api/docs/</a>注册一个密钥</p><h2 id="6308" class="le lf it bd lg lh li dn lj lk ll dp lm km ln lo lp kq lq lr ls ku lt lu lv lw bi translated">入门指南</h2><p id="ed39" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">一旦我们有了Pixabay API密钥，我们就可以开始编写我们的应用程序了。首先，我们创建一个名为<code class="fe kz la lb lc b">photo-app</code>的项目。运行:</p><pre class="mc md me mf gt mg lc mh mi aw mj bi"><span id="58cb" class="le lf it lc b gy mk ml l mm mn">npx @vue/cli create photo-app</span></pre><p id="1824" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这将为我们的应用程序创建文件，并为内置库安装软件包。我们选择‘手动选择特性’并选择Babel、Vue路由器和CSS预处理器。</p><p id="1d90" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们安装自己的软件包。我们需要上面提到的<code class="fe kz la lb lc b"> vue-masonry</code>库和<code class="fe kz la lb lc b">vue-infinite-scroll</code>。此外，我们需要BootstrapVue进行样式化，Axios进行HTTP请求，Vee-Validate进行表单验证。</p><p id="39d3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们通过运行以下命令来安装所有软件包:</p><pre class="mc md me mf gt mg lc mh mi aw mj bi"><span id="2215" class="le lf it lc b gy mk ml l mm mn">npm i axios bootstrap-vue vee-validate vue-infinite-scroll vue-masonry</span></pre><h2 id="4b55" class="le lf it bd lg lh li dn lj lk ll dp lm km ln lo lp kq lq lr ls ku lt lu lv lw bi translated">构建应用程序</h2><p id="1a54" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">安装好所有的包后，我们就可以开始编写我们的应用程序了。在<code class="fe kz la lb lc b">src</code>目录下创建一个<code class="fe kz la lb lc b">mixins</code>文件夹，并创建一个<code class="fe kz la lb lc b">requestsMixin.js</code>文件。</p><p id="a6af" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后，我们将以下内容添加到文件中:</p><pre class="mc md me mf gt mg lc mh mi aw mj bi"><span id="b2d8" class="le lf it lc b gy mk ml l mm mn">const axios = require("axios");<br/>const APIURL = "<a class="ae ld" href="https://pixabay.com/api" rel="noopener ugc nofollow" target="_blank">https://pixabay.com/api</a>";</span><span id="1d00" class="le lf it lc b gy mo ml l mm mn">export const requestsMixin = {<br/>  methods: {<br/>    getImages(page = 1) {<br/>      return axios.get(`${APIURL}/?page=${page}&amp;key=${process.env.VUE_APP_API_KEY}`);<br/>    },</span><span id="0479" class="le lf it lc b gy mo ml l mm mn">    searchImages(keyword, page = 1) {<br/>      return axios.get(<br/>        `${APIURL}/?page=${page}&amp;key=${process.env.VUE_APP_API_KEY}&amp;q=${keyword}`<br/>      );<br/>    }<br/>  }<br/>};</span></pre><p id="b63d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们在这里调用端点来搜索图像。<code class="fe kz la lb lc b">process.env.VUE_APP_API_KEY</code>是从我们项目的根文件夹中的<code class="fe kz la lb lc b">.env</code>文件中获取的。注意，我们使用的环境变量需要有以<code class="fe kz la lb lc b">VUE_APP</code>开头的键。</p><p id="de2d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，在<code class="fe kz la lb lc b">Home.vue</code>中，将现有代码替换为:</p><pre class="mc md me mf gt mg lc mh mi aw mj bi"><span id="91d8" class="le lf it lc b gy mk ml l mm mn">&lt;template&gt;<br/>  &lt;div class="page"&gt;<br/>    &lt;h1 class="text-center"&gt;Home&lt;/h1&gt;<br/>    &lt;div<br/>      v-infinite-scroll="getImagesByPage"<br/>      infinite-scroll-disabled="busy"<br/>      infinite-scroll-distance="10"<br/>    &gt;<br/>      &lt;div<br/>        v-masonry="containerId"<br/>        transition-duration="0.3s"<br/>        item-selector=".item"<br/>        gutter="5"<br/>        fit-width="true"<br/>        class="masonry-container"<br/>      &gt;<br/>        &lt;div&gt;<br/>          &lt;img<br/>            :src="item.previewURL"<br/>            v-masonry-tile<br/>            class="item"<br/>            v-for="(item, index) in images"<br/>            :key="index"<br/>          /&gt;<br/>        &lt;/div&gt;<br/>      &lt;/div&gt;<br/>    &lt;/div&gt;<br/>  &lt;/div&gt;<br/>&lt;/template&gt;</span><span id="2efe" class="le lf it lc b gy mo ml l mm mn">&lt;script&gt;<br/>import { requestsMixin } from "../mixins/requestsMixin";</span><span id="6049" class="le lf it lc b gy mo ml l mm mn">export default {<br/>  name: "home",<br/>  mixins: [requestsMixin],<br/>  data() {<br/>    return {<br/>      images: [],<br/>      page: 1,<br/>      containerId: null<br/>    };<br/>  },<br/>  methods: {<br/>    async getImagesByPage() {<br/>      const response = await this.getImages(this.page);<br/>      this.images = this.images.concat(response.data.hits);<br/>      this.page++;<br/>    }<br/>  },<br/>  beforeMount() {<br/>    this.getImagesByPage();<br/>  }<br/>};<br/>&lt;/script&gt;</span></pre><p id="56cf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们在这里使用<code class="fe kz la lb lc b">vue-infinite-scroll</code>和<code class="fe kz la lb lc b">vue-masonry</code>包。注意，我们指定了<code class="fe kz la lb lc b">transition-duration</code>来调整从不显示到显示图像的过渡，并且<code class="fe kz la lb lc b">fit-width</code>使列适合容器。<code class="fe kz la lb lc b">gutter</code>以像素为单位指定每列之间的间距宽度。我们还在<code class="fe kz la lb lc b">v-masonry</code>容器中设置了一个CSS类名，以便以后更改样式。</p><p id="55de" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在<code class="fe kz la lb lc b">v-masonry</code> <code class="fe kz la lb lc b">div</code>中，我们循环遍历这些图像，我们设置<code class="fe kz la lb lc b">v-masonry-tile</code>来表示它是平铺的，这样它会将它们调整到砖石网格的大小。</p><p id="890d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在<code class="fe kz la lb lc b">script</code>对象中，我们用<code class="fe kz la lb lc b">beforeMount</code>钩子加载页面时获取图像。因为我们添加了无限滚动，所以当用户向下滚动时，我们不断向数组添加图像。当用户按照<code class="fe kz la lb lc b">v-infinite-scroll</code>道具的指示向下滚动时，我们调用<code class="fe kz la lb lc b">getImagesByPage</code>。我们将<code class="fe kz la lb lc b">infinite-scroll-disabled</code>设置为<code class="fe kz la lb lc b">busy</code>来设置禁用滚动。<code class="fe kz la lb lc b">infinite-scroll-distance</code>表示要触发的滚动距离页面底部的百分比。</p><p id="5342" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来在<code class="fe kz la lb lc b">views</code>文件夹中创建<code class="fe kz la lb lc b">ImageSearchPage.vue</code>并添加:</p><pre class="mc md me mf gt mg lc mh mi aw mj bi"><span id="9760" class="le lf it lc b gy mk ml l mm mn">&lt;template&gt;<br/>  &lt;div class="page"&gt;<br/>    &lt;h1 class="text-center"&gt;Image Search&lt;/h1&gt;<br/>    &lt;ValidationObserver ref="observer" v-slot="{ invalid }"&gt;<br/>      &lt;b-form <a class="ae ld" href="http://twitter.com/submit" rel="noopener ugc nofollow" target="_blank">@submit</a>.prevent="onSubmit" novalidate&gt;<br/>        &lt;b-form-group label="Keyword" label-for="keyword"&gt;<br/>          &lt;ValidationProvider name="keyword" rules="required" v-slot="{ errors }"&gt;<br/>            &lt;b-form-input<br/>              :state="errors.length == 0"<br/>              v-model="form.keyword"<br/>              type="text"<br/>              required<br/>              placeholder="Keyword"<br/>              name="keyword"<br/>            &gt;&lt;/b-form-input&gt;<br/>            &lt;b-form-invalid-feedback :state="errors.length == 0"&gt;Keyword is required&lt;/b-form-invalid-feedback&gt;<br/>          &lt;/ValidationProvider&gt;<br/>        &lt;/b-form-group&gt;</span><span id="d0c9" class="le lf it lc b gy mo ml l mm mn">        &lt;b-button type="submit" variant="primary"&gt;Search&lt;/b-button&gt;<br/>      &lt;/b-form&gt;<br/>    &lt;/ValidationObserver&gt;</span><span id="bcc0" class="le lf it lc b gy mo ml l mm mn">    &lt;br /&gt;</span><span id="7988" class="le lf it lc b gy mo ml l mm mn">    &lt;div<br/>      v-infinite-scroll="searchAllImages"<br/>      infinite-scroll-disabled="busy"<br/>      infinite-scroll-distance="10"<br/>    &gt;<br/>      &lt;div<br/>        v-masonry="containerId"<br/>        transition-duration="0.3s"<br/>        item-selector=".item"<br/>        gutter="5"<br/>        fit-width="true"<br/>        class="masonry-container"<br/>      &gt;<br/>        &lt;div&gt;<br/>          &lt;img<br/>            :src="item.previewURL"<br/>            v-masonry-tile<br/>            class="item"<br/>            v-for="(item, index) in images"<br/>            :key="index"<br/>          /&gt;<br/>        &lt;/div&gt;<br/>      &lt;/div&gt;<br/>    &lt;/div&gt;<br/>  &lt;/div&gt;<br/>&lt;/template&gt;</span><span id="68d5" class="le lf it lc b gy mo ml l mm mn">&lt;script&gt;<br/>import { requestsMixin } from "../mixins/requestsMixin";</span><span id="50ec" class="le lf it lc b gy mo ml l mm mn">export default {<br/>  mixins: [requestsMixin],<br/>  data() {<br/>    return {<br/>      form: {},<br/>      page: 1,<br/>      containerId: null,<br/>      images: []<br/>    };<br/>  },<br/>  methods: {<br/>    async onSubmit() {<br/>      const isValid = await this.$refs.observer.validate();<br/>      if (!isValid) {<br/>        return;<br/>      }<br/>      this.page = 1;<br/>      await this.searchAllImages();<br/>    },</span><span id="bda5" class="le lf it lc b gy mo ml l mm mn">    async searchAllImages() {<br/>      if (!this.form.keyword) {<br/>        return;<br/>      }<br/>      const response = await this.searchImages(this.form.keyword, this.page);<br/>      if (this.page == 1) {<br/>        this.images = response.data.hits;<br/>      } else {<br/>        this.images = this.images.concat(response.data.hits);<br/>      }<br/>      this.page++;<br/>    }<br/>  }<br/>};<br/>&lt;/script&gt;</span></pre><p id="7f4b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">无限滚动和砖石布局几乎相同，除了当<code class="fe kz la lb lc b">keyword</code>改变时，我们将<code class="fe kz la lb lc b">this.images</code>数组重新分配给新的项目，而不是一直将它们添加到现有的数组中，以便用户看到新的结果。</p><p id="3cfb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">表单被包装在<code class="fe kz la lb lc b">ValidationObserver</code>中，这样我们就可以得到里面整个表单的验证状态。在表单中，我们用<code class="fe kz la lb lc b">ValidationProvider</code>包装输入，以便可以验证表单字段并显示输入的验证错误消息。我们检查是否填写了<code class="fe kz la lb lc b">keyword</code>。</p><p id="5de5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一旦用户单击Search，就会运行<code class="fe kz la lb lc b">onSubmit</code>回调，它执行<code class="fe kz la lb lc b">await this.$refs.observer.validate();</code>来获得表单验证状态。如果结果为<code class="fe kz la lb lc b">true</code>，则<code class="fe kz la lb lc b">searchAllImages</code>将运行以获取图像。</p><p id="1862" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们用以下代码替换<code class="fe kz la lb lc b">App.vue</code>中的现有代码:</p><pre class="mc md me mf gt mg lc mh mi aw mj bi"><span id="336a" class="le lf it lc b gy mk ml l mm mn">&lt;template&gt;<br/>  &lt;div&gt;<br/>    &lt;b-navbar toggleable="lg" type="dark" variant="info"&gt;<br/>      &lt;b-navbar-brand href="#"&gt;Photo App&lt;/b-navbar-brand&gt;</span><span id="fa6e" class="le lf it lc b gy mo ml l mm mn">      &lt;b-navbar-toggle target="nav-collapse"&gt;&lt;/b-navbar-toggle&gt;</span><span id="c777" class="le lf it lc b gy mo ml l mm mn">      &lt;b-collapse id="nav-collapse" is-nav&gt;<br/>        &lt;b-navbar-nav&gt;<br/>          &lt;b-nav-item to="/" :active="path == '/'"&gt;Home&lt;/b-nav-item&gt;<br/>          &lt;b-nav-item to="/imagesearch" :active="path == '/imagesearch'"&gt;Image Search&lt;/b-nav-item&gt;<br/>        &lt;/b-navbar-nav&gt;<br/>      &lt;/b-collapse&gt;<br/>    &lt;/b-navbar&gt;<br/>    &lt;router-view /&gt;<br/>  &lt;/div&gt;<br/>&lt;/template&gt;</span><span id="2205" class="le lf it lc b gy mo ml l mm mn">&lt;script&gt;<br/>export default {<br/>  data() {<br/>    return {<br/>      path: this.$route &amp;&amp; this.$route.path<br/>    };<br/>  },<br/>  watch: {<br/>    $route(route) {<br/>      this.path = route.path;<br/>    }<br/>  }<br/>};<br/>&lt;/script&gt;</span><span id="1b7b" class="le lf it lc b gy mo ml l mm mn">&lt;style lang="scss"&gt;<br/>.page {<br/>  padding: 20px;<br/>}</span><span id="6936" class="le lf it lc b gy mo ml l mm mn">.item {<br/>  width: 30vw;<br/>}</span><span id="6c50" class="le lf it lc b gy mo ml l mm mn">.masonry-container {<br/>  margin: 0 auto;<br/>}<br/>&lt;/style&gt;</span></pre><p id="ee3f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们在这里添加了BootstrapVue <code class="fe kz la lb lc b">b-navbar</code>来显示一个带有页面链接的顶栏。在<code class="fe kz la lb lc b">script</code>部分，我们通过获取<code class="fe kz la lb lc b">this.$route.path</code>来观看当前路线。我们通过对照我们观察的<code class="fe kz la lb lc b">path</code>来检查路径来设置<code class="fe kz la lb lc b">active</code>道具，以突出链接。</p><p id="0454" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在<code class="fe kz la lb lc b">style</code>部分，我们用<code class="fe kz la lb lc b">page</code>类设置页面的填充，用<code class="fe kz la lb lc b">item</code>类设置图片宽度，如<code class="fe kz la lb lc b">v-masonry</code> div的<code class="fe kz la lb lc b"> item-selector</code>所示，我们将<code class="fe kz la lb lc b">masonry-container</code>的边距设置为<code class="fe kz la lb lc b">0 auto</code>，这样它将在页面上居中。</p><p id="e9eb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来在<code class="fe kz la lb lc b">main.js</code>中，将现有代码替换为:</p><pre class="mc md me mf gt mg lc mh mi aw mj bi"><span id="0eaa" class="le lf it lc b gy mk ml l mm mn">import Vue from "vue";<br/>import App from "./App.vue";<br/>import router from "./router";<br/>import "bootstrap/dist/css/bootstrap.css";<br/>import "bootstrap-vue/dist/bootstrap-vue.css";<br/>import BootstrapVue from "bootstrap-vue";<br/>import { ValidationProvider, extend, ValidationObserver } from "vee-validate";<br/>import { required } from "vee-validate/dist/rules";<br/>import { VueMasonryPlugin } from "vue-masonry";<br/>import infiniteScroll from "vue-infinite-scroll";</span><span id="df65" class="le lf it lc b gy mo ml l mm mn">Vue.config.productionTip = false;</span><span id="38ce" class="le lf it lc b gy mo ml l mm mn">extend("required", required);<br/>Vue.component("ValidationProvider", ValidationProvider);<br/>Vue.component("ValidationObserver", ValidationObserver);<br/>Vue.use(VueMasonryPlugin);<br/>Vue.use(infiniteScroll);<br/>Vue.use(BootstrapVue);</span><span id="afca" class="le lf it lc b gy mo ml l mm mn">new Vue({<br/>  router,<br/>  render: h =&gt; h(App)<br/>}).$mount("#app");</span></pre><p id="1ca3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这将添加我们在组件中使用的所有库以及我们使用的Vee-Validate验证规则。此外，我们在这里导入我们的引导样式，这样我们就可以在任何地方看到这些样式。</p><p id="996e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来在<code class="fe kz la lb lc b">router.js</code>中，将现有代码替换为:</p><pre class="mc md me mf gt mg lc mh mi aw mj bi"><span id="4e4f" class="le lf it lc b gy mk ml l mm mn">import Vue from "vue";<br/>import Router from "vue-router";<br/>import Home from "./views/Home.vue";<br/>import ImageSearchPage from "./views/ImageSearchPage.vue";</span><span id="abaf" class="le lf it lc b gy mo ml l mm mn">Vue.use(Router);</span><span id="22eb" class="le lf it lc b gy mo ml l mm mn">export default new Router({<br/>  mode: "history",<br/>  base: process.env.BASE_URL,<br/>  routes: [<br/>    {<br/>      path: "/",<br/>      name: "home",<br/>      component: Home<br/>    },<br/>    {<br/>      path: "/imagesearch",<br/>      name: "imagesearch",<br/>      component: ImageSearchPage<br/>    }<br/>  ]<br/>});</span></pre><p id="bd08" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这增加了我们的路线。</p><p id="b751" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一切完成后，我们通过执行<code class="fe kz la lb lc b">npm run start</code>来运行我们的应用程序，我们应该得到:</p><figure class="mc md me mf gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/28672656226dc6bf3eace15710a142df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZU4xaOP8lWy6DwdA_Ssdmg.png"/></div></div></figure><figure class="mc md me mf gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/6016d22f89e25797985162428082a57a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8X8-ZJyEBnUxXAhuOhTAxQ.png"/></div></div></figure></div></div>    
</body>
</html>