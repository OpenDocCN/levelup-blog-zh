<html>
<head>
<title>Create Swift Extensions like popular open source libraries</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">像流行的开源库一样创建Swift扩展</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/create-swift-extensions-like-popular-open-source-libraries-dee3e38dbe9d?source=collection_archive---------6-----------------------#2022-03-27">https://levelup.gitconnected.com/create-swift-extensions-like-popular-open-source-libraries-dee3e38dbe9d?source=collection_archive---------6-----------------------#2022-03-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/281dbc2ec3b4b5603e72e9f975d2e599.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3yL0XRPx9CZglFt5U44qBA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://www.xda-developers.com/download-iphone-se-3-2022-wallpapers/" rel="noopener ugc nofollow" target="_blank">https://www . xda-developers . com/download-iphone-se-3-2022-wallpapers/</a></figcaption></figure><h1 id="d851" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">介绍</h1><p id="1f47" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated"><strong class="ld ir"> Swift Extension </strong>比其他任何语言的扩展都更加灵活和强大。但如果因为自由度高而乱用扩展函数，极有可能成为意大利面代码。</p><p id="edcf" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">在这篇文章中，我将介绍如何使用<strong class="ld ir"> Swift协议</strong>和<strong class="ld ir">扩展</strong>实现像一个著名开源库那样的扩展功能。</p><h1 id="efc1" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">动机</h1><p id="51fc" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">我有一个习惯，就是看制作精良的开源库的内部实现。在查看<strong class="ld ir"> RxSwift </strong>内部时，我对<strong class="ld ir"> Reactive </strong>和<strong class="ld ir"> ReactiveCompatible </strong>的实现印象深刻。起初，我以为这是<strong class="ld ir"> RxSwift </strong>的独特实现，但这种实现在著名的开源库中很常见，就像模式一样。例如:翠鸟</p><h1 id="b3db" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">RxSwift代码</h1><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mj mk l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">RxSwift/Reactive.swift</figcaption></figure><p id="aeae" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">上面的实现被绘制成一个类图。针对雨燕语言的特点，没有一个工具可以完美的绘制，所以先把不能完美绘制的放在一边。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ml"><img src="../Images/0d69cc4b7686fc3e4f2363dd777241d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ic_hsrMfdEKHGN4_KnmdYQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">反应和反应相容的类图</figcaption></figure><p id="908b" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">它是一个简单的结构，ReactiveCompatible protocol合成Reactive class，ReactiveBase声明为<strong class="ld ir"> generic </strong>类型。反应类合成基地成<strong class="ld ir">通用</strong>型。</p><p id="9bec" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">光看这个很难确切知道会做出什么样的行动。让我们仔细看看下面的实现。</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="e514" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">啊哈！看看上面的实现，就更清楚了。当<strong class="ld ir"> ReactiveCompatible </strong>协议创建一个<strong class="ld ir"> Reactive </strong>类实例时，它注入<strong class="ld ir">自身</strong>作为<strong class="ld ir">基础</strong>。</p><p id="d37c" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">因此，<strong class="ld ir"> ReactiveCompatible </strong>的任何实现都会将<strong class="ld ir"> Reactive </strong>类的实例<strong class="ld ir"> rx </strong>作为属性作为<strong class="ld ir">基</strong>注入。</p><p id="2b21" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">读者会说，“那又怎样？它有什么作用？”你可以想不要心急，还是再专注一点吧。从现在开始，我们可以看到这一切的神奇之处。</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="0688" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated"><strong class="ld ir">n对象</strong>实现<strong class="ld ir">反应兼容</strong>。如你所知，<strong class="ld ir"> UIKit的</strong> <strong class="ld ir"> UIButton </strong>和<strong class="ld ir"> UIView </strong>大部分都是<strong class="ld ir">n object</strong>的子类。因此，<strong class="ld ir"> UIButton </strong>也是<strong class="ld ir"> ReactiveCompatible </strong>的实现。</p><p id="786a" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">如第3行所示，<code class="fe mm mn mo mp b">extension Reactive where Base: UIButton</code>通过实现这一点，您可以编写一个<strong class="ld ir">反应型</strong>类扩展函数，该函数只应用于<strong class="ld ir"> UIButton </strong>。</p><p id="6a3c" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">如下图所示，<strong class="ld ir"> rx </strong>扩展功能只能提供给特定的实现。</p><pre class="mf mg mh mi gt mq mp mr ms aw mt bi"><span id="e05c" class="mu ke iq mp b gy mv mw l mx my">let button = UIButton()<br/>button.rx.tap<br/>  .bind { print("tapped") }<br/>  .disposed(by: disposeBag)</span></pre><p id="c67d" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">这个简单的原则允许我们编写干净的代码，“对扩展开放，对变化封闭”。此外，由于<strong class="ld ir"> Reactive </strong>是一个<strong class="ld ir">结构</strong>，每当调用<strong class="ld ir"> rx </strong>属性时，就会创建并传递一个新实例，因此您可以利用<strong class="ld ir">的不变性</strong>。</p><h1 id="836a" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">申请</h1><p id="242f" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">你可能对<strong class="ld ir"> UIAlertController </strong>比较熟悉，它对于iOS应用开发是必不可少的。让我们将逻辑扩展到与<strong class="ld ir">反应式</strong>相同的结构。</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mj mk l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Alert.swift</figcaption></figure><p id="b5ac" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">以与RxSwift的<strong class="ld ir">反应</strong>和<strong class="ld ir">反应兼容</strong>相同的方式，创建<strong class="ld ir">警报</strong>和<strong class="ld ir">警报兼容</strong>，并将<strong class="ld ir">警报</strong>属性声明为<strong class="ld ir">警报</strong>实例。</p><p id="3ddd" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">声明<strong class="ld ir"> AlertCompatible </strong> <strong class="ld ir">扩展</strong>，通过将自身注入<strong class="ld ir"> alert </strong>属性的getter中，实现逻辑创建<strong class="ld ir"> Alert </strong>实例。</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mj mk l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">UIViewController+Alert.swift</figcaption></figure><p id="31ba" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">在扩展<strong class="ld ir"> UIViewController </strong>实现<strong class="ld ir"> AlertCompatible </strong>后，增加了必要的功能。现在，<strong class="ld ir"> UIViewController </strong>有了一个扩展功能，可以简单的呈现<strong class="ld ir"> UIAlertController </strong>。</p><p id="cae5" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">你可以像这样简单地使用它:</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mj mk l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">MyViewController.swift</figcaption></figure><p id="d660" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">如果在另一个类中需要<strong class="ld ir"> Alert </strong>函数，那么在相关类中实现<strong class="ld ir"> AlertCompatible </strong>并只添加必要的函数就足够了。</p><h1 id="2c67" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">结论</h1><p id="0956" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">不知道通过实现示例是否已经充分传达了优点。我使用这个方法已经有一段时间了，它非常有用，在结构上也非常令人满意。我希望您也将今天介绍的扩展函数实现方法引入到您的项目中。这肯定会是比现在更好的实现扩展的方式。</p><p id="c055" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">仅仅通过阅读写得好的、受欢迎的开源代码，你就可以取得很大的进步。作为奖励，你可能会在里面找到宝石。</p></div></div>    
</body>
</html>