<html>
<head>
<title>All About C# Value Types &amp; Reference Types</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于C#值类型和引用类型的所有内容</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/learn-c-value-types-reference-types-for-the-last-time-dc8345a3a8ca?source=collection_archive---------8-----------------------#2021-06-01">https://levelup.gitconnected.com/learn-c-value-types-reference-types-for-the-last-time-dc8345a3a8ca?source=collection_archive---------8-----------------------#2021-06-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/d4246c039b5c2109517fed74fd420b8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yCuXkBbkJxSkw6iI8ohrhw.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">在<a class="ae kf" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的<a class="ae kf" href="https://unsplash.com/@thisisengineering?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> ThisisEngineering RAEng </a></figcaption></figure><h1 id="f7f1" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">目录</h1><p id="3cbf" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated"><a class="ae kf" href="#acde" rel="noopener ugc nofollow">简介</a> <br/> ∘ <a class="ae kf" href="#d488" rel="noopener ugc nofollow">值类型引用类型表</a> <br/> <a class="ae kf" href="#0e54" rel="noopener ugc nofollow">值类型</a> <br/> ∘ <a class="ae kf" href="#a847" rel="noopener ugc nofollow">通过方法传递值类型</a> <br/> <a class="ae kf" href="#2e4b" rel="noopener ugc nofollow">引用类型</a> <br/> ∘ <a class="ae kf" href="#5dc2" rel="noopener ugc nofollow">通过方法传递引用类型变量</a> <br/> <a class="ae kf" href="#6bce" rel="noopener ugc nofollow">字符串</a> <br/> <a class="ae kf" href="#e185" rel="noopener ugc nofollow">的特殊场景不要搞混了</a> d <br/> <a class="ae kf" href="#a368" rel="noopener ugc nofollow">引用/值类型可以为空</a></p><blockquote class="mc md me"><p id="cc40" class="le lf mf lg b lh mg lj lk ll mh ln lo mi mj lr ls mk ml lv lw mm mn lz ma mb im bi translated">如果你愿意支持我成为一名作家，考虑报名参加<a class="ae kf" href="https://freelancingcult.medium.com/membership" rel="noopener">成为</a>的媒体成员。每月只需5美元，你就可以无限制地使用Medium。</p></blockquote><p id="4cac" class="pw-post-body-paragraph le lf it lg b lh mg lj lk ll mh ln lo lp mj lr ls lt ml lv lw lx mn lz ma mb im bi translated">这是c#开发人员应该真正了解的另一个关键领域。学习这两个概念对我阅读C#代码和理解正在发生的事情帮助很大。所以我想与我的读者分享我所学到的，这样你就不会感到困惑，比如“那东西是怎么改变的，我甚至没有打开那个文件？”</p><figure class="mo mp mq mr gt ju"><div class="bz fp l di"><div class="ms mt l"/></div></figure><h1 id="acde" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">介绍</h1><p id="582b" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">开门见山地说，<strong class="lg iu">值类型</strong>和<strong class="lg iu">引用类型</strong>是C#中主要的两种数据类型。这种值类型、引用类型的分离是基于每种类型在内存中存储其值的方式来完成的。如果你对每个变量类型在内存(RAM)中是如何存储的有一个清晰的了解，你可能一辈子都不会为值/引用混淆而烦恼！！！。</p><p id="9c9d" class="pw-post-body-paragraph le lf it lg b lh mg lj lk ll mh ln lo lp mj lr ls lt ml lv lw lx mn lz ma mb im bi translated">在继续之前，让我们看看这两个类别中的数据类型。</p><h2 id="d488" class="mu kh it bd ki mv mw dn km mx my dp kq lp mz na ku lt nb nc ky lx nd ne lc nf bi translated">值类型引用类型表</h2><pre class="mo mp mq mr gt ng nh ni nj aw nk bi"><span id="8cc4" class="mu kh it nh b gy nl nm l nn no">+-------------+-----------------+<br/>| Value Types | Reference Types |<br/>+-------------+-----------------+<br/>| bool        | String          |<br/>| byte        | Arrays          |<br/>| char        | Class           |<br/>| decimal     | Delegate        |<br/>| double      |                 |<br/>| enum        |                 |<br/>| float       |                 |<br/>| int         |                 |<br/>| long        |                 |<br/>| sbyte       |                 |<br/>| short       |                 |<br/>| struct      |                 |<br/>| uint        |                 |<br/>| ulong       |                 |<br/>| ushort      |                 |<br/>+-------------+-----------------+</span></pre><p id="0815" class="pw-post-body-paragraph le lf it lg b lh mg lj lk ll mh ln lo lp mj lr ls lt ml lv lw lx mn lz ma mb im bi translated">我们在程序中使用的变量存储在内存(ram)中。内存中有一个独立的空间块用来存储每个变量。并且这些单独的空间块中的每一个都具有用于识别的位置名称/id。我们称之为内存地址。示例存储器地址0x239010。</p><p id="5a2e" class="pw-post-body-paragraph le lf it lg b lh mg lj lk ll mh ln lo lp mj lr ls lt ml lv lw lx mn lz ma mb im bi translated">这种记忆是如何分配和创造的，是你应该探索的另一个世界。现在不是说这个的时候。</p><figure class="mo mp mq mr gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi np"><img src="../Images/7b1f822515a5613e701a5003033ac5c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:892/format:webp/1*cH9n1ltuHVj2r1RGOEyy_Q.png"/></div></div></figure><h1 id="0e54" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">值类型</h1><p id="8cfc" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">值类型变量将其值存储在自己的内存位置中。所以变量直接有赋值。</p><p id="7bf8" class="pw-post-body-paragraph le lf it lg b lh mg lj lk ll mh ln lo lp mj lr ls lt ml lv lw lx mn lz ma mb im bi translated">例如，让我们看看<code class="fe nq nr ns nh b">int number =156</code>是如何存储为值类型的。<br/>系统将值156存储在分配给变量名<code class="fe nq nr ns nh b">number</code>的相同存储空间中。</p><p id="a519" class="pw-post-body-paragraph le lf it lg b lh mg lj lk ll mh ln lo lp mj lr ls lt ml lv lw lx mn lz ma mb im bi translated">下图显示了该值如何存储在与变量名编号相同的内存位置0x239110中。</p><figure class="mo mp mq mr gt ju gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/fb4c89dd28992f108d804c127eea764e.png" data-original-src="https://miro.medium.com/v2/resize:fit:774/format:webp/1*pWj7JtouE8UbGnZM5ITKbQ.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">值类型-内存分配</figcaption></figure><p id="dfcd" class="pw-post-body-paragraph le lf it lg b lh mg lj lk ll mh ln lo lp mj lr ls lt ml lv lw lx mn lz ma mb im bi translated">当您了解引用类型内存分配时，您会对此有更多的感受。</p><h2 id="a847" class="mu kh it bd ki mv mw dn km mx my dp kq lp mz na ku lt nb nc ky lx nd ne lc nf bi translated">通过方法传递值类型</h2><p id="d8bc" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">当编写方法和函数时，我们传递参数。参数具有可变类型。所以如果你把值类型作为参数传递，你需要知道内部发生了什么。</p><p id="da53" class="pw-post-body-paragraph le lf it lg b lh mg lj lk ll mh ln lo lp mj lr ls lt ml lv lw lx mn lz ma mb im bi translated">当通过方法将值类型作为参数传递时，系统会创建一个单独的副本并发送它。如果值在方法内部被改变，它不会影响原始变量。</p><p id="498e" class="pw-post-body-paragraph le lf it lg b lh mg lj lk ll mh ln lo lp mj lr ls lt ml lv lw lx mn lz ma mb im bi translated">在main方法内的第16行代码中，它打印了100。<br/>然后将该变量作为参数传递给<code class="fe nq nr ns nh b">MySalary()</code>方法，在那里<code class="fe nq nr ns nh b">mysalary </code>变量被修改。<br/>当值类型将变量的副本传递给调用方法时，主方法中原来的<code class="fe nq nr ns nh b">friendsSalary </code>值不会改变。<br/>因此，它在第18行打印300，在第20和16行打印100。</p><figure class="mo mp mq mr gt ju"><div class="bz fp l di"><div class="nu mt l"/></div></figure><h1 id="2e4b" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">参考类型</h1><p id="7278" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">引用类型变量不直接用变量名存储值。它存储实际值的存储位置。</p><p id="ec05" class="pw-post-body-paragraph le lf it lg b lh mg lj lk ll mh ln lo lp mj lr ls lt ml lv lw lx mn lz ma mb im bi translated">所以在引用类型中，实际值存储在一个单独的地方，而创建的变量只存储实际值的内存地址。</p><p id="d853" class="pw-post-body-paragraph le lf it lg b lh mg lj lk ll mh ln lo lp mj lr ls lt ml lv lw lx mn lz ma mb im bi translated">从下图中你可以看到变量名存储了实际值的内存地址。实际值存储在单独的存储器位置(0x60001)。</p><figure class="mo mp mq mr gt ju gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/e4175e12149a541fdffbedfecf398bcf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1272/format:webp/1*7lkOJ60ulY6r7GsSc1eA0A.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">存储引用类型变量</figcaption></figure><h2 id="5dc2" class="mu kh it bd ki mv mw dn km mx my dp kq lp mz na ku lt nb nc ky lx nd ne lc nf bi translated">在方法中传递引用类型变量</h2><p id="5bd2" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">当我们将引用类型作为参数值传递时，我们应该理解一些事情。</p><p id="fe71" class="pw-post-body-paragraph le lf it lg b lh mg lj lk ll mh ln lo lp mj lr ls lt ml lv lw lx mn lz ma mb im bi translated">当传递引用类型时，它不像在值类型中那样创建副本，而是直接传递存储的引用地址。</p><p id="74b9" class="pw-post-body-paragraph le lf it lg b lh mg lj lk ll mh ln lo lp mj lr ls lt ml lv lw lx mn lz ma mb im bi translated">在下面的代码中，<code class="fe nq nr ns nh b">std1 </code>只存储对象的引用地址，它被传递给方法<code class="fe nq nr ns nh b">UpdateCourse</code>。因此，如果我们改变了方法中的变量值，它也会在其他方法中得到反映。</p><p id="f695" class="pw-post-body-paragraph le lf it lg b lh mg lj lk ll mh ln lo lp mj lr ls lt ml lv lw lx mn lz ma mb im bi translated">在这里，更改<code class="fe nq nr ns nh b">UpdateCourse</code>方法中的课程名称也反映在Main方法中。</p><p id="98e8" class="pw-post-body-paragraph le lf it lg b lh mg lj lk ll mh ln lo lp mj lr ls lt ml lv lw lx mn lz ma mb im bi translated">您可以看到同一个<code class="fe nq nr ns nh b">Console.WriteLine("Course: "+std1.Course);</code>在<code class="fe nq nr ns nh b">UpdateCourse()</code>方法调用前后打印了2个不同的值。</p><figure class="mo mp mq mr gt ju"><div class="bz fp l di"><div class="nu mt l"/></div></figure><p id="37b6" class="pw-post-body-paragraph le lf it lg b lh mg lj lk ll mh ln lo lp mj lr ls lt ml lv lw lx mn lz ma mb im bi translated">这就是对象作为引用类型变量被传递和修改的方式</p><h1 id="6bce" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">字符串的特殊情况</h1><p id="2f3b" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">正如我在前面的表格中提到的，<code class="fe nq nr ns nh b">string</code>是一个引用类型。但是它的行为不像普通的引用类型。因为字符串是不可变的。这意味着字符串值不能修改。如果我们试图修改一个字符串，它会在内存中创建一个新的变量。并对新变量进行更改。更改不会反映在原始字符串值中。</p><p id="f8fb" class="pw-post-body-paragraph le lf it lg b lh mg lj lk ll mh ln lo lp mj lr ls lt ml lv lw lx mn lz ma mb im bi translated">在下面的代码示例中，您可以看到在main方法内部，我们试图通过将字符串值“name”传递给<code class="fe nq nr ns nh b">ModifyingString()</code>方法来修改它。更改是成功的，但是更改没有像其他引用类型变量一样反映回主方法。</p><figure class="mo mp mq mr gt ju"><div class="bz fp l di"><div class="nu mt l"/></div></figure><h1 id="e185" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">不要搞混了</h1><p id="406c" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">第一个例子中的<code class="fe nq nr ns nh b">std1.StudentName</code> <code class="fe nq nr ns nh b">std2.StudentName</code>确实都是字符串值。但是请记住，我们将相关对象作为参数传递给了方法，而不是像第二个示例中那样直接传递字符串。</p><h1 id="a368" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">引用/值类型可以为空吗？</h1><p id="c513" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">是的，如果你认为引用类型不直接保存变量值。因此它们可以不引用任何对象而保持不变。但是值类型变量不能保持为null，因为它直接保存值。但是在</p><blockquote class="mc md me"><p id="c4a8" class="le lf mf lg b lh mg lj lk ll mh ln lo mi mj lr ls mk ml lv lw mm mn lz ma mb im bi translated"><strong class="lg iu">从C# 2.0开始引入了可空类型，你可以将空值赋给一个值类型。</strong></p></blockquote><p id="9fd8" class="pw-post-body-paragraph le lf it lg b lh mg lj lk ll mh ln lo lp mj lr ls lt ml lv lw lx mn lz ma mb im bi translated">这就是今天的内容，希望你喜欢这篇文章，并从中有所收获。</p><blockquote class="mc md me"><p id="a63e" class="le lf mf lg b lh mg lj lk ll mh ln lo mi mj lr ls mk ml lv lw mm mn lz ma mb im bi translated">我希望你喜欢读这篇文章。如果你愿意支持我成为一名作家，可以考虑注册<a class="ae kf" href="https://freelancingcult.medium.com/membership" rel="noopener">成为一名媒体成员</a>。每月只需5美元，你就可以无限制地使用Medium。</p></blockquote></div></div>    
</body>
</html>