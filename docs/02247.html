<html>
<head>
<title>Array Code Challenge Breakdown</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">阵列代码挑战分解</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/array-code-challenge-breakdown-8799f903d9cc?source=collection_archive---------3-----------------------#2020-02-29">https://levelup.gitconnected.com/array-code-challenge-breakdown-8799f903d9cc?source=collection_archive---------3-----------------------#2020-02-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/eba079a6642ef86dabda65ce8df75008.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*x5_o0e4JOuKqRMfeixO4rw.gif"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">当你真的想撒尿，必须排在队伍前面的时候…</figcaption></figure><p id="7806" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我最近完成了一个叫做<a class="ae kw" href="https://www.hackerrank.com/challenges/new-year-chaos/problem" rel="noopener ugc nofollow" target="_blank"> <em class="kx">新年混乱</em> </a>的HackerRank代码挑战。我编写了一个解决方案，在我的终端上运行该程序时产生了预期的结果，但是它没有通过HackerRank站点上的测试。在重构失败一段时间后，我做了一点研究。我找到了一两篇介绍这个问题并提供解决方案的文章，但是我找不到一篇用JavaScript表达解决方案的文章，也没有像我希望的那样完整地解释代码机制。我决定写这样一篇文章。</p></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><p id="47b9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">问题陈述描述了排队等候乘车的人群。队列被表示为一个<code class="fe lf lg lh li b">Array</code>。排队的人表示为<code class="fe lf lg lh li b">elements</code>。从队列开始的<code class="fe lf lg lh li b">1</code>开始，队列中的每个人都被顺序分配一个整数。八个人的队列可以表示为:</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="58a2" class="lr ls iq li b gy lt lu l lv lw">queue = [1, 2, 3, 4, 5, 6, 7, 8]</span></pre><p id="ff83" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">排队的人可以贿赂直接排在他们前面的人交换位置。然而，在切换时，两个人都保留他们的顺序标识符，<em class="kx">，即</em>分配给该特定索引的整数。一个人只能贿赂眼前这个人两次。如果<code class="fe lf lg lh li b">person 5</code>贿赂<code class="fe lf lg lh li b">person 4</code>调换位置，那么队伍将会是这样的:</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="1186" class="lr ls iq li b gy lt lu l lv lw">queue = [1, 2, 3, <strong class="li ir">5</strong>, 4, 6, 7, 8]</span></pre><p id="11b2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">挑战在于编写一个程序，接受长度大于<code class="fe lf lg lh li b">1</code>的任意整数<code class="fe lf lg lh li b">Array</code>，并确定产生<code class="fe lf lg lh li b">Array</code>的数字顺序所需的有效贿赂的最小数量。该程序应<em class="kx">打印</em>一个整数，表示产生输入的数字顺序<code class="fe lf lg lh li b">Array</code>所需的最小贿赂数，或者<em class="kx">打印</em> <code class="fe lf lg lh li b">Too chaotic</code>如果顺序无效，<em class="kx">即</em>要求一个人贿赂的人数超过<code class="fe lf lg lh li b">2</code>人。该解决方案将是一个<code class="fe lf lg lh li b">JavaScript</code>函数:</p><pre class="lj lk ll lm gt ln li lo lp aw lq bi"><span id="11f0" class="lr ls iq li b gy lt lu l lv lw"> 1  function minimumBribes(q) {<br/> 2    let swaps = 0<br/> 3<br/> 4    for (let i = 0; i &lt; q.length; i++) {<br/> 5      let bribes = q[i] - (i + 1)<br/> 6      let maxAdvance = q[i] - 2 &gt; 0 ? q[i] - 2 : 0<br/> 7<br/> 8      if (bribes &gt; 2) {<br/> 9        console.log('Too chaotic')<br/>10        return<br/>11      }<br/>12<br/>13      for (let j = maxAdvance; j &lt; i; j++) {<br/>14        if (q[j] &gt; q[i]) swaps++<br/>15      }<br/>16    }<br/>17    console.log(swaps)<br/>18  }<br/>19<br/>20 ///////////////////////////////////////////<br/>21 <br/>22  const q = [1, 2, 5, 3, 7, 8, 6, 4]<br/>23  minimumBribes(q)<br/>24  // =&gt; 7<br/>25<br/>26 ///////////////////////////////////////////<br/>27<br/>28  const q = [5, 1, 2, 3, 7, 8, 6, 4]<br/>29  minimumBribes(q)<br/>30  // =&gt; Too chaotic</span></pre><h2 id="789b" class="lr ls iq bd lx ly lz dn ma mb mc dp md kj me mf mg kn mh mi mj kr mk ml mm mn bi translated">所以，很好，这个函数起作用了，但是让我们把它分解一下，了解一下是如何起作用的。请继续阅读。</h2><p id="4829" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated">该函数被命名为<code class="fe lf lg lh li b">minimumBribes</code>，并被赋予一个<code class="fe lf lg lh li b">Array</code>参数，在本例中由变量<code class="fe lf lg lh li b">q</code>表示。在最外层的作用域中，<code class="fe lf lg lh li b">2</code>行上有一个名为<code class="fe lf lg lh li b">swaps</code>的变量，赋值为<code class="fe lf lg lh li b">0</code>。<code class="fe lf lg lh li b">swaps</code>将作为计数器变量，每次进行有效的贿赂和职位互换时，计数器变量将增加<code class="fe lf lg lh li b">1</code>。在第<code class="fe lf lg lh li b">17</code>行，<code class="fe lf lg lh li b">console.log()</code>将打印出由<code class="fe lf lg lh li b">swaps</code>表示的整数，除非输入数组无效。</p><p id="f74c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在同一范围内，第<code class="fe lf lg lh li b">4</code>行上有一个<code class="fe lf lg lh li b">for loop</code>。<code class="fe lf lg lh li b">for loop</code>的条件表明，只要<code class="fe lf lg lh li b">i</code>小于<code class="fe lf lg lh li b">Array</code>的长度，计数器变量<code class="fe lf lg lh li b">i</code>将从索引<code class="fe lf lg lh li b">0</code>(<code class="fe lf lg lh li b">Array</code>的第一个元素)开始，并递增<code class="fe lf lg lh li b">i++</code>(<code class="fe lf lg lh li b">1</code>)。</p><p id="8c0e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<code class="fe lf lg lh li b">for loop</code>的范围内，声明了两个变量，一个<code class="fe lf lg lh li b">if</code>语句和一个嵌套的<code class="fe lf lg lh li b">for loop</code>。第一个变量位于第<code class="fe lf lg lh li b">5</code>行，名为<code class="fe lf lg lh li b">bribes</code>，表示当前人(当前元素)行贿的次数。这是通过减去队列中的当前位置(或<code class="fe lf lg lh li b">Array</code>加<code class="fe lf lg lh li b">1</code>的索引)计算出来的。* <code class="fe lf lg lh li b">Array</code>索引从<code class="fe lf lg lh li b">0</code>开始，从被评估的当前元素的值开始，或者从处于该位置的人员的标识号开始。</p><p id="269e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如:在第<code class="fe lf lg lh li b">28</code>行的第二个输入示例中，第一个元素(<code class="fe lf lg lh li b">q[0]</code>)的值是<code class="fe lf lg lh li b">5</code>。人数<code class="fe lf lg lh li b">5</code>减去<code class="fe lf lg lh li b">i + 1</code> ( <code class="fe lf lg lh li b">0 + 1</code>或<code class="fe lf lg lh li b">1</code>，因为这是循环的第一次迭代)等于<code class="fe lf lg lh li b">4</code>。号码<code class="fe lf lg lh li b">5</code>必须将<code class="fe lf lg lh li b">4</code>的位置移向队伍的前方才能就位，于是人员<code class="fe lf lg lh li b">5</code>向<code class="fe lf lg lh li b">4</code>行贿。现在让我们暂时跳到第<code class="fe lf lg lh li b">8</code>行。</p><p id="1696" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<code class="fe lf lg lh li b">for loop</code>的每次迭代中，计算贿赂的次数。然后，在第<code class="fe lf lg lh li b">8</code>行，<code class="fe lf lg lh li b">if</code>语句评估此人行贿的金额是否大于<code class="fe lf lg lh li b">2</code>，从而使数组无效。如果是，消息<code class="fe lf lg lh li b">Too chaotic</code>被打印到终端，并且<code class="fe lf lg lh li b">return</code>语句跳出循环并结束函数的执行。</p><p id="ce90" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果贿赂金额<em class="kx">是</em>有效，那么该功能继续执行。让我们跳回到第<code class="fe lf lg lh li b">6</code>行，这里有一个名为<code class="fe lf lg lh li b">maxAdvance</code>的变量，它代表一个人通过贿赂可能获得的最远有效位置<code class="fe lf lg lh li b">2</code>。<code class="fe lf lg lh li b">maxAdvance</code>的值由条件运算符的评估决定。如果当前元素(人)的原始位置减去<code class="fe lf lg lh li b">2</code>(空格)大于<code class="fe lf lg lh li b">0</code>，那么<code class="fe lf lg lh li b">maxAdvance</code>的值就是当前元素(<code class="fe lf lg lh li b">q[i]</code>)减去<code class="fe lf lg lh li b">2</code>。否则，<code class="fe lf lg lh li b">maxAdvance</code>的值为<code class="fe lf lg lh li b">0</code>。条件操作符基本上确保占位符不能变成负数，<em class="kx">，即</em>不能移动到队列的第一个位置之外。在某个地方必须有一条线<em class="kx">的前面。</em></p><p id="f46e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在第<code class="fe lf lg lh li b">13</code>行，嵌套的<code class="fe lf lg lh li b">for loop</code>评估任何小于<code class="fe lf lg lh li b">3</code>的有效<code class="fe lf lg lh li b">bribes</code>值。嵌套<code class="fe lf lg lh li b">for loop</code>的条件表明，只要<code class="fe lf lg lh li b">j</code>小于外部<code class="fe lf lg lh li b">for loop</code>的当前索引(<code class="fe lf lg lh li b">i</code>),计数器变量<code class="fe lf lg lh li b">j</code>将从<code class="fe lf lg lh li b">maxAdvance</code>确定的索引开始，并以<code class="fe lf lg lh li b">1</code>递增(<code class="fe lf lg lh li b">i++</code>)。在嵌套的<code class="fe lf lg lh li b">for loop</code>的主体中，<code class="fe lf lg lh li b">if</code>语句评估人员编号(<code class="fe lf lg lh li b">Array</code>元素的值)是否大于队列中下一个人员的编号。如果是这样，这意味着更大的整数肯定已经贿赂了它，并且在第<code class="fe lf lg lh li b">2</code>行建立的名为<code class="fe lf lg lh li b">swaps</code>的计数器增加了<code class="fe lf lg lh li b">1</code>。这种评估将根据循环条件进行一次或两次，并适当增加和记录交换的次数。</p><p id="57c7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，只要没有无效贿赂被处理，行<code class="fe lf lg lh li b">17</code>上的<code class="fe lf lg lh li b">console.log()</code>就向终端打印产生输入数组的数字顺序所需的贿赂的最小数量。</p></div><div class="ab cl ky kz hu la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ij ik il im in"><p id="4a7a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个代码挑战相当具有挑战性，没有双关语(HAR！).它要求我测试和检查我对正在处理的数据的假设，并理解场景的机制，以便最有效地编写一个提供必要结果的函数。这表明代码是围绕解决方案精心制作的，而不是相反。</p><p id="121c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" href="https://github.com/dangrammer" rel="noopener ugc nofollow" target="_blank">github.com/dangrammer</a><br/><a class="ae kw" href="https://www.linkedin.com/in/danieljromans/" rel="noopener ugc nofollow" target="_blank">linked.com/in/danieljromans</a><br/>T26】danromans.com</p></div></div>    
</body>
</html>