<html>
<head>
<title>How to handle errors in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何处理围棋中的错误</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-handle-errors-in-go-df459a907c2f?source=collection_archive---------20-----------------------#2022-12-19">https://levelup.gitconnected.com/how-to-handle-errors-in-go-df459a907c2f?source=collection_archive---------20-----------------------#2022-12-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="b51e" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">权威指南</h2><div class=""/><figure class="gl gn jz ka kb kc gh gi paragraph-image"><div class="ab gu cl kd"><img src="../Images/f978ff3c276c492e1704f99d7a3a3cd0.png" data-original-src="https://miro.medium.com/v2/0*JdxYNy9rsPKOls53"/></div><figcaption class="kg kh gj gh gi ki kj bd b be z dk">Photo by <a class="ae kk" href="https://unsplash.com/@hhh13?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">傅甬 华</a> on <a class="ae kk" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="802e" class="pw-post-body-paragraph kl km it kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li im bi translated">Go中的错误处理不同于其他编程语言，例如Java或Python。Go内置错误不包含堆栈跟踪，也不支持常规的<code class="fe lj lk ll lm b">try</code> / <code class="fe lj lk ll lm b">catch</code>方法来处理它们。相反，Go中的错误只是函数返回的值。</p><p id="88c0" class="pw-post-body-paragraph kl km it kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li im bi translated">罗布·派克关于“错误”的一篇非常好的文章:<a class="ae kk" href="https://go.dev/blog/errors-are-values" rel="noopener ugc nofollow" target="_blank">https://go.dev/blog/errors-are-values</a></p><p id="697a" class="pw-post-body-paragraph kl km it kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li im bi translated">处理错误的方式与处理任何其他数据类型的方式非常相似，这导致了一个惊人的轻量级和简单的设计。</p><p id="4d47" class="pw-post-body-paragraph kl km it kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li im bi translated">在这里，我将演示在Go中处理错误的基础知识，以及一些简单的策略，你可以在你的代码中遵循这些策略来使你的程序健壮并易于调试。</p><p id="50f9" class="pw-post-body-paragraph kl km it kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li im bi translated">Go中的错误类型被实现为如下的接口，这意味着<code class="fe lj lk ll lm b">error</code>是实现以字符串形式返回错误消息的<code class="fe lj lk ll lm b">Error()</code>方法的任何东西。</p><pre class="ln lo lp lq gt lr lm ls bn lt lu bi"><span id="9d12" class="lv lw it lm b be lx ly l lz ma">type error interface {<br/>    Error() string<br/>}</span></pre><h1 id="e21a" class="mb lw it bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">如何构建错误</h1><p id="45d3" class="pw-post-body-paragraph kl km it kn b ko my kq kr ks mz ku kv kw na ky kz la nb lc ld le nc lg lh li im bi translated">构造错误有几种方法，其中一种是动态创建，可以使用Go内置的<code class="fe lj lk ll lm b">errors</code>或<code class="fe lj lk ll lm b">fmt</code>包来构造。例如，下面的函数使用<code class="fe lj lk ll lm b">errors</code>包返回一个新的错误和一条静态错误消息:</p><pre class="ln lo lp lq gt lr lm ls bn lt lu bi"><span id="2814" class="lv lw it lm b be lx ly l lz ma">package main</span></pre><pre class="nd lr lm ne nf aw ng bi"><span id="c9cf" class="nh lw it lm b gy ni nj l nk ma">import "errors"</span><span id="df3e" class="nh lw it lm b gy nl nj l nk ma">func SayHello() error {<br/>    return errors.New("I am unable to speak")<br/>}</span></pre><p id="5e99" class="pw-post-body-paragraph kl km it kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li im bi translated"><code class="fe lj lk ll lm b">fmt</code> package也可以用来给错误添加动态数据，比如一个<code class="fe lj lk ll lm b">int</code>、<code class="fe lj lk ll lm b">string</code>或另一个<code class="fe lj lk ll lm b">error</code>。例如:</p><pre class="ln lo lp lq gt lr lm ls bn lt lu bi"><span id="aea6" class="lv lw it lm b be lx ly l lz ma">package main</span></pre><pre class="nd lr lm ne nf aw ng bi"><span id="41c9" class="nh lw it lm b gy ni nj l nk ma">import "fmt"</span><span id="a568" class="nh lw it lm b gy nl nj l nk ma">func Divide(a, b int) (int, error) {<br/>    if b == 0 {<br/>        return 0, fmt.Errorf("can't divide '%d' by zero", a)<br/>    }<br/>    return a / b, nil<br/>}</span></pre><p id="1596" class="pw-post-body-paragraph kl km it kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li im bi translated">在上面的例子中，最后一行返回一个错误<code class="fe lj lk ll lm b">nil</code>,这意味着我们正在返回错误的默认值或“零”值。这很重要，因为检查<code class="fe lj lk ll lm b">if err != nil</code>是确定是否遇到错误的惯用方法</p><p id="9e77" class="pw-post-body-paragraph kl km it kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li im bi translated">当我们返回一个错误时，函数返回的其他参数通常作为它们的默认“零”值返回。类似地，对于没有错误的情况，<code class="fe lj lk ll lm b">err</code>返回为<code class="fe lj lk ll lm b">nil</code>(零值)</p><p id="86b0" class="pw-post-body-paragraph kl km it kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li im bi translated">错误消息的一般概念通常用小写字母书写，并且不以标点符号结尾。</p><h1 id="1bc4" class="mb lw it bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">预期误差</h1><p id="0387" class="pw-post-body-paragraph kl km it kn b ko my kq kr ks mz ku kv kw na ky kz la nb lc ld le nc lg lh li im bi translated">这是通过定义预期错误，以便可以在调用代码中显式检查它们，如果遇到特定类型的预期错误，这对于执行另一组指令是有用的。</p><h1 id="702a" class="mb lw it bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">哨兵误差</h1><p id="9ada" class="pw-post-body-paragraph kl km it kn b ko my kq kr ks mz ku kv kw na ky kz la nb lc ld le nc lg lh li im bi translated">根据前面的示例<code class="fe lj lk ll lm b">Divide</code>，功能错误信号可以通过预定义“标记”错误来改善。调用函数可以使用<code class="fe lj lk ll lm b">errors.Is</code>明确检查这个错误</p><pre class="ln lo lp lq gt lr lm ls bn lt lu bi"><span id="6b64" class="lv lw it lm b be lx ly l lz ma">package main</span></pre><pre class="nd lr lm ne nf aw ng bi"><span id="432c" class="nh lw it lm b gy ni nj l nk ma">import (<br/>    "errors"<br/>    "fmt"<br/>)</span><span id="2cd9" class="nh lw it lm b gy nl nj l nk ma">var ErrDivideByZero = errors.New("divide by zero error")</span><span id="e382" class="nh lw it lm b gy nl nj l nk ma">func Divide(a, b int) (int, error) {<br/>    if b == 0 {<br/>        return 0, ErrDivideByZero<br/>    }<br/>    return a / b, nil<br/>}</span><span id="792f" class="nh lw it lm b gy nl nj l nk ma">func main() {<br/>    a := 50<br/>    b := 0<br/>    res, err := Divide(a, b)<br/>    if err != nil {<br/>        switch {<br/>        case errors.Is(err, ErrDivideByZero):<br/>            fmt.Println("divide by zero error")<br/>        default:<br/>            fmt.Printf("unexpected error: %s\n", err)<br/>        }<br/>        return<br/>    }</span><span id="8b47" class="nh lw it lm b gy nl nj l nk ma">    fmt.Printf("%d / %d = %d\n", a, b, res)<br/>}</span></pre><h2 id="55dc" class="nh lw it bd mc nm nn dn mg no np dp mk kw nq nr mo la ns nt ms le nu nv mw iz bi translated">自定义错误类型</h2><p id="dccd" class="pw-post-body-paragraph kl km it kn b ko my kq kr ks mz ku kv kw na ky kz la nb lc ld le nc lg lh li im bi translated">大多数情况下，上述处理错误的方法已经足够，但是，有时您可能希望错误携带额外的数据字段，或者在记录错误时，错误消息应该具有动态值。</p><p id="797c" class="pw-post-body-paragraph kl km it kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li im bi translated">这可以在Go中通过实现一个定制的错误类型来完成。</p><p id="ecc0" class="pw-post-body-paragraph kl km it kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li im bi translated">下面介绍了一个新的类型<code class="fe lj lk ll lm b">DivisionError</code>，它实现了我们之前看到的<code class="fe lj lk ll lm b">Error</code> <code class="fe lj lk ll lm b">interface </code>，现在它可以利用<code class="fe lj lk ll lm b">errors.As</code>来检查标准误差，并将其转换为一个更具体的误差，我们的例子是<code class="fe lj lk ll lm b">DivisionError</code>。</p><pre class="ln lo lp lq gt lr lm ls bn lt lu bi"><span id="e752" class="lv lw it lm b be lx ly l lz ma">package main</span></pre><pre class="nd lr lm ne nf aw ng bi"><span id="b3be" class="nh lw it lm b gy ni nj l nk ma">import (<br/>    "errors"<br/>    "fmt"<br/>)</span><span id="2a0c" class="nh lw it lm b gy nl nj l nk ma">type DivisionError struct {<br/>    A int<br/>    B int<br/>    Msg  string<br/>}</span><span id="47a4" class="nh lw it lm b gy nl nj l nk ma">func (e *DivisionError) Error() string { <br/>    return e.Msg<br/>}</span><span id="db38" class="nh lw it lm b gy nl nj l nk ma">func Divide(a, b int) (int, error) {<br/>    if b == 0 {<br/>        return 0, &amp;DivisionError{<br/>            Msg: fmt.Sprintf("cannot divide '%d' by zero", a),<br/>            A: a, B: b,<br/>        }<br/>    }<br/>    return a / b, nil<br/>}</span><span id="a206" class="nh lw it lm b gy nl nj l nk ma">func main() {<br/>    a := 10<br/>    b := 0<br/>    res, err := Divide(a, b)<br/>    if err != nil {<br/>        var divErr *DivisionError<br/>        switch {<br/>        case errors.As(err, &amp;divErr):<br/>            fmt.Printf("%d / %d is not mathematically valid: %s\n",<br/>              divErr.A, divErr.B, divErr.Error())<br/>        default:<br/>            fmt.Printf("unexpected error: %s\n", err)<br/>        }<br/>        return<br/>    }</span><span id="e8d4" class="nh lw it lm b gy nl nj l nk ma">    fmt.Printf("%d / %d = %d\n", a, b, res)<br/>}</span></pre><h1 id="64f6" class="mb lw it bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">包装错误</h1><p id="22d5" class="pw-post-body-paragraph kl km it kn b ko my kq kr ks mz ku kv kw na ky kz la nb lc ld le nc lg lh li im bi translated">到目前为止，这些错误都是通过一个函数调用创建、返回或处理的。换句话说，使错误“冒泡”的函数堆栈只有一层深度。</p><p id="ff4f" class="pw-post-body-paragraph kl km it kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li im bi translated">通常会涉及更多的函数——从产生错误的函数，到最终处理错误的函数，以及中间的任何数量的附加函数。</p><p id="0fac" class="pw-post-body-paragraph kl km it kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li im bi translated">有像<code class="fe lj lk ll lm b">errors.Wrap</code>和<code class="fe lj lk ll lm b">errors.Unwrap</code>这样的函数，它们在为错误提供额外的上下文以及检查特定的错误类型时非常有用，不管错误已经被包装了多少次。</p><h1 id="3dee" class="mb lw it bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">如何包装一个错误？</h1><p id="1080" class="pw-post-body-paragraph kl km it kn b ko my kq kr ks mz ku kv kw na ky kz la nb lc ld le nc lg lh li im bi translated">下面的代码片段展示了如何使用带有动词<code class="fe lj lk ll lm b">%w</code>的<code class="fe lj lk ll lm b">fmt.Errorf</code>来“包装”错误，因为它们“冒泡”通过其他函数调用，这些函数调用添加了所需的上下文，这样就可以推断出调用堆栈中哪个先前的调用失败了</p><pre class="ln lo lp lq gt lr lm ls bn lt lu bi"><span id="2a8d" class="lv lw it lm b be lx ly l lz ma">package main</span></pre><pre class="nd lr lm ne nf aw ng bi"><span id="840d" class="nh lw it lm b gy ni nj l nk ma">import (<br/>    "errors"<br/>    "fmt"<br/>    "hey.com/fake/fruits/db"<br/>)</span><span id="1090" class="nh lw it lm b gy nl nj l nk ma">func FetchFruit(fruitName string) (*db.Fruit, error) {<br/> f, err := db.Find(fruitName)<br/> if err != nil {<br/>  return nil, fmt.Errorf("FetchFruit: failed executing db query: %w", err)<br/> }<br/> return f, nil<br/>}</span><span id="bc32" class="nh lw it lm b gy nl nj l nk ma">func SetFruitAge(f *db.Fruit, age int) error {<br/> if err := db.SetAge(f, age); err != nil {<br/>  return fmt.Errorf("SetFruitAge: failed executing db update: %w", err)<br/> }<br/>}</span><span id="d4d0" class="nh lw it lm b gy nl nj l nk ma">func FindAndSetFruitAge(fruitName string, age int) error {<br/> var fruit *Fruit<br/> var err error<br/> fruit, err = FetchFruit(fruitName)<br/> if err != nil {<br/>  return fmt.Errorf("FindAndSetFruitAge: %w", err)<br/> }<br/> if err = SetFruitAge(fruit, age); err != nil {<br/>  return fmt.Errorf("FindAndSetFruitAge: %w", err)<br/> }<br/> return nil<br/>}</span><span id="6dc8" class="nh lw it lm b gy nl nj l nk ma">func main() {<br/> if err := FindAndSetFruitAge("Banana", 15); err != nil {<br/>  fmt.Println("failed finding or updating fruit: %s", err)<br/>  return<br/> }<br/> fmt.Println("successfully updated fruits's age")<br/>}</span></pre><p id="ebc5" class="pw-post-body-paragraph kl km it kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li im bi translated">如果上面的程序遇到错误，日志应该打印以下内容:</p><pre class="ln lo lp lq gt lr lm ls bn lt lu bi"><span id="91bf" class="lv lw it lm b be lx ly l lz ma">&gt;_failed finding or updating fruit: FindAndSetFruitAge: SetFruitAge: failed executing db update: malformed request</span></pre><p id="c8b1" class="pw-post-body-paragraph kl km it kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li im bi translated">现在错误信息包含了我们可以看到问题起源于<code class="fe lj lk ll lm b">db.SetFruitAge</code>功能的信息。如果失败是在调用执行链中的几个函数之后，这将有助于缩小错误范围</p><p id="b636" class="pw-post-body-paragraph kl km it kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li im bi translated">错误包装可以以类似于堆栈跟踪的方式为错误提供额外的上下文。包装还保存了原始错误，这意味着<code class="fe lj lk ll lm b">errors.Is</code>和<code class="fe lj lk ll lm b">errors.As</code>继续工作，而不管错误已经包装了多少次。我们也可以使用<code class="fe lj lk ll lm b">errors.Unwrap</code>它来返回链中的前一个错误。</p><h1 id="a43f" class="mb lw it bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">结论</h1><p id="90af" class="pw-post-body-paragraph kl km it kn b ko my kq kr ks mz ku kv kw na ky kz la nb lc ld le nc lg lh li im bi translated">总而言之，</p><ul class=""><li id="012a" class="nw nx it kn b ko kp ks kt kw ny la nz le oa li ob oc od oe bi translated">Go中的错误是数值<a class="ae kk" href="https://go.dev/blog/errors-are-values" rel="noopener ugc nofollow" target="_blank">https://go.dev/blog/errors-are-values</a></li><li id="575b" class="nw nx it kn b ko of ks og kw oh la oi le oj li ob oc od oe bi translated">错误有助于排除程序失败的根本原因</li><li id="72c6" class="nw nx it kn b ko of ks og kw oh la oi le oj li ob oc od oe bi translated">包装错误提供了跟踪一系列函数调用的上下文</li></ul><p id="a9be" class="pw-post-body-paragraph kl km it kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li im bi translated">附加阅读</p><ul class=""><li id="a4f1" class="nw nx it kn b ko kp ks kt kw ny la nz le oa li ob oc od oe bi translated"><a class="ae kk" href="https://go.dev/blog/errors-are-values" rel="noopener ugc nofollow" target="_blank">https://go.dev/blog/errors-are-values</a></li><li id="7f37" class="nw nx it kn b ko of ks og kw oh la oi le oj li ob oc od oe bi translated">https://go.dev/blog/error-handling-and-go<a class="ae kk" href="https://go.dev/blog/error-handling-and-go" rel="noopener ugc nofollow" target="_blank"/></li><li id="0b31" class="nw nx it kn b ko of ks og kw oh la oi le oj li ob oc od oe bi translated">【https://gobyexample.com/errors T4】</li></ul></div></div>    
</body>
</html>