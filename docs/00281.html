<html>
<head>
<title>TypeScript Object-Oriented Concepts in a Nutshell</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">简而言之，面向对象的概念</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/typescript-object-oriented-concepts-in-a-nutshell-cb2fdeeffe6e?source=collection_archive---------0-----------------------#2018-12-17">https://levelup.gitconnected.com/typescript-object-oriented-concepts-in-a-nutshell-cb2fdeeffe6e?source=collection_archive---------0-----------------------#2018-12-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7285" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">TypeScript对象的所有主要方面都在一个地方，这样您就不必到处搜索它们了</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/aaa76c11406f90ea870c3dca5191dd78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gk2K5x3uZkR_mN5p9S37Xw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">(TypeScript ===具有超能力的JavaScript)= &gt; true</figcaption></figure><p id="493f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果您像我一样来自传统的面向对象(OO)背景，并且被JavaScript的怪癖吓住了——不要害怕——因为TypeScript已经覆盖了您。本教程将浏览TypeScript对象的所有要点，同时给出一些例子，并向您展示它们何时会派上用场。TypeScript对象的特性与传统的面向对象语言如Java和C#有很大的重叠，所以如果你是一个经验丰富的程序员，你可能已经熟悉了其中的一些。如果没有，这将是一个面向对象风格编程的伟大概述。</p></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="f32f" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">类型脚本对象与JavaScript对象</h1><p id="1e06" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">TypeScript对象只是JavaScript函数对象的语法糖。当在JavaScript中使用函数对象作为类时，有很多重复的代码，这就是为什么为ES6实现了<code class="fe mv mw mx my b">class</code>。TypeScript将ES6类带到了一个更高的现实层面，不仅添加了类型，还添加了对象特性，如<code class="fe mv mw mx my b">public</code>、<code class="fe mv mw mx my b">private</code>、<code class="fe mv mw mx my b">abstract</code>等。如果你有兴趣了解更多关于JavaScript函数对象的特性(我强烈推荐这样做),请点击这里查看我的中型文章<a class="ae mz" rel="noopener ugc nofollow" target="_blank" href="/the-javascript-object-paradigm-and-prototypes-explained-simply-e9cb9eaa49aa"/>。</p></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="e127" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">对象概述</h1><p id="a386" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">TypeScript中的对象(像在所有面向对象编程中一样)是有用的，因为它们让我们脱离真实世界的场景来建模我们的程序。对象是类的实例(以该对象为值类型的特定变量)。把类想象成一组方法和变量。假设我们想要一个名为<em class="na"> PetStore </em>的程序，只卖猫和狗。如果我们想知道狗的年龄，狗可以有像<code class="fe mv mw mx my b">age</code>和<code class="fe mv mw mx my b">breed</code>这样的属性，也可以有像<code class="fe mv mw mx my b">getRelativeAge</code>这样的方法。如果我们在谈论一个特定的狗对象，比如<code class="fe mv mw mx my b">Spot</code>或<code class="fe mv mw mx my b">Bingo</code>，它们的属性值被设置，那么这些对象就是<code class="fe mv mw mx my b">Dog</code>类的实例。</p><p id="8e82" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用<code class="fe mv mw mx my b">class</code>关键字实现类，就像在ES6中一样。为了创建一个对象，我们用关键字<code class="fe mv mw mx my b">new</code>调用这个类，它触发构造函数并返回一个<em class="na">实例-对象</em>，就像在普通JavaScript中一样。由于JavaScript中的对象在技术上只是一组键/值对，我喜欢用术语实例对象来指代用<code class="fe mv mw mx my b">new</code>关键字返回的对象。</p><p id="4a1c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe mv mw mx my b">Spot</code>是<code class="fe mv mw mx my b">Dog</code>的实例对象。</p><pre class="kg kh ki kj gt nb my nc nd aw ne bi"><span id="bfb4" class="nf lz iq my b gy ng nh l ni nj">class Dog<br/>{<br/>    age: number<br/>    breed: string</span><span id="f9c5" class="nf lz iq my b gy nk nh l ni nj">    constructor(age: number, breed: string)<br/>    {<br/>        this.age = age<br/>        this.breed = string<br/>    }</span><span id="dba8" class="nf lz iq my b gy nk nh l ni nj">    getRelativeAge(): number<br/>    {<br/>        return this.age * 7<br/>    }<br/>}</span><span id="84ee" class="nf lz iq my b gy nk nh l ni nj">let Spot = new Dog(2, 'Labrador')</span></pre><p id="1063" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">等效使用ES5中的函数对象。</p><pre class="kg kh ki kj gt nb my nc nd aw ne bi"><span id="5574" class="nf lz iq my b gy ng nh l ni nj">function Dog(age, breed)<br/>{<br/>    this.age = age<br/>    this.breed = breed<br/>}</span><span id="c2a9" class="nf lz iq my b gy nk nh l ni nj">Dog.prototype.getRelativeAge = function() {<br/>    return this.age * 7<br/>}</span><span id="266e" class="nf lz iq my b gy nk nh l ni nj">var Spot = new Dog(2, 'Labrador')</span></pre></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="29b3" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">遗产</h1><p id="f66e" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">既然您已经知道了如何创建对象，并且可以看到它们在JavaScript中是如何工作的，那么让我们开始学习TypeScript继承。在我们的宠物商店项目中，我们出售的是狗和猫，但也可能有不同品种的狗和猫，对吗？狗和猫也可能有一些相同的属性，比如<code class="fe mv mw mx my b">age</code>和<code class="fe mv mw mx my b">weight</code>。超类(也称为父类)允许将相关的对象组合在一起，以便它们可以继承相似的属性。为了从父类继承，我们使用了<code class="fe mv mw mx my b">extends</code>关键字。当你扩展一个类时，所有的属性和方法都会被传递下去。我们现在可以在父类<code class="fe mv mw mx my b">Animal</code>的基础上扩展，而不是每次在我们的宠物店添加新动物时都创建<code class="fe mv mw mx my b">age</code>和<code class="fe mv mw mx my b">weight</code>。通过扩展子类，多级继承也是可能的。</p><p id="883c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe mv mw mx my b">super</code>关键字在继承中有两个作用。首先，它作为一个函数，在父类的构造函数中使用。它必须在子对象构造函数中的<code class="fe mv mw mx my b">this</code>之前被调用。另一个是它允许我们访问父对象的方法(而不是属性)。</p><p id="a5f0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">动物是<code class="fe mv mw mx my b">Dog</code>的父类:</p><pre class="kg kh ki kj gt nb my nc nd aw ne bi"><span id="a5f1" class="nf lz iq my b gy ng nh l ni nj">class Animal<br/>{<br/>    age: number<br/>    breed: string</span><span id="1605" class="nf lz iq my b gy nk nh l ni nj">    constructor(age: number, breed: string)<br/>    { <br/>        this.age = age<br/>        this.breed = breed<br/>    }</span><span id="6b6c" class="nf lz iq my b gy nk nh l ni nj">    makeSound_(sound: string): void<br/>    {<br/>        console.log(sound)<br/>        console.log(sound)<br/>        console.log(sound)<br/>    }<br/>}</span></pre><p id="a659" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">基本继承使用<code class="fe mv mw mx my b">super</code>:</p><pre class="kg kh ki kj gt nb my nc nd aw ne bi"><span id="9b41" class="nf lz iq my b gy ng nh l ni nj">class Dog extends Animal<br/>{<br/>    playsFetch: boolean</span><span id="1e53" class="nf lz iq my b gy nk nh l ni nj">    constructor(age: number, breed: string, playsFetch: boolean)<br/>    {<br/>         <strong class="my ir">super</strong>(age, breed) // call parent constructor<br/>         this.playsFetch = playsFetch<br/>    }</span><span id="f208" class="nf lz iq my b gy nk nh l ni nj">    makeSound(): void<br/>    {<br/>        <strong class="my ir">super</strong>.makeSound_('woof woof')<br/>    }</span><span id="bba6" class="nf lz iq my b gy nk nh l ni nj">    getAgeInHumanYears(): number<br/>    {<br/>        return this.age * 7    // super.age will throw error<br/>    }<br/>}<br/></span><span id="9a77" class="nf lz iq my b gy nk nh l ni nj">class Cat extends Animal<br/>{<br/>    constructor(age: number, breed: string)<br/>    {<br/>        <strong class="my ir">super</strong>(age, breed)<br/>    }</span><span id="e195" class="nf lz iq my b gy nk nh l ni nj">    makeSound(): void<br/>    {<br/>        <strong class="my ir">super</strong>.makeSound_('meow meow')<br/>    }<br/>}</span></pre><blockquote class="nl nm nn"><p id="7d72" class="kv kw na kx b ky kz jr la lb lc ju ld no lf lg lh np lj lk ll nq ln lo lp lq ij bi translated">JavaScript ES6继承以同样的方式工作，但是在TypeScript中，当处理父类时有一个额外的访问控制特性。ES6也不允许在方法之外定义类级别的变量。</p></blockquote></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="ef6a" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">访问控制</h1><p id="6efc" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">访问控制指的是我们可以在哪里使用类的属性和方法。如果你曾经浏览过一个OO语言的代码，你可能会注意到像<code class="fe mv mw mx my b">public</code>、<code class="fe mv mw mx my b">private</code>和<code class="fe mv mw mx my b">protected</code>这样的关键词。让我们回顾一下每一项的用途以及它们为什么有用。</p><p id="5406" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">假设我们的PetStore程序有一个名为<code class="fe mv mw mx my b">PetStore</code>的类。如果这个类想要调用我们的<code class="fe mv mw mx my b">Dog</code>对象上的方法，那么这些方法将需要被标记为<code class="fe mv mw mx my b">public</code>。当一个方法或变量是公共的，这意味着它可以被我们程序的另一部分访问。当我们在一个变量或者方法上没有任何修饰符的时候，这和标记它<code class="fe mv mw mx my b">public</code>是一样的。</p><pre class="kg kh ki kj gt nb my nc nd aw ne bi"><span id="a48f" class="nf lz iq my b gy ng nh l ni nj">class Dog<br/>{<br/>    <strong class="my ir">public</strong> name: string // leaving out <strong class="my ir">'public'</strong> would work too<br/>}</span><span id="de8b" class="nf lz iq my b gy nk nh l ni nj">class PetStore<br/>{<br/>    dogs: Array&lt;Dog&gt;</span><span id="a8f7" class="nf lz iq my b gy nk nh l ni nj">    printAllDogNames(): void<br/>    {<br/>        this.dogs.forEach(dog =&gt; {<br/>            console.log(dog.name)<br/>        })<br/>    }<br/>}</span></pre><p id="5b6e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">允许其他编码人员直接访问对象的属性通常不是一个好主意。最好使用<em class="na">getter</em>和<em class="na">setter</em>来访问/修改类属性，这样我们可以在设置值时传递一些逻辑并防止错误。例如，狗的名字不应该是假的，而且应该在一定长度之内。一个真实的狗名绝不会超过10-20个字符。为了使一个类变量/方法只能在这个类中访问，我们应该把它标记为<code class="fe mv mw mx my b">private</code>。TypeScript类内置了<code class="fe mv mw mx my b">get</code>和<code class="fe mv mw mx my b">set</code>修饰符，每当试图访问一个属性时，它们将触发我们的getters和setters。</p><pre class="kg kh ki kj gt nb my nc nd aw ne bi"><span id="fab6" class="nf lz iq my b gy ng nh l ni nj">class Dog<br/>{<br/>    <strong class="my ir">private</strong> _name: string // beginning underscore is convention</span><span id="e7fc" class="nf lz iq my b gy nk nh l ni nj">    <strong class="my ir">get</strong> name(): string<br/>    {<br/>       return this._name<br/>    }</span><span id="cee7" class="nf lz iq my b gy nk nh l ni nj">    <strong class="my ir">set</strong> name(name: string): void<br/>    {<br/>        if(!name || name.length &gt; 20) {<br/>            throw new Error('Name invalid')<br/>        }<br/>        else {<br/>            this._name = name<br/>        }<br/>    }<br/>}</span><span id="e6bc" class="nf lz iq my b gy nk nh l ni nj">class PetStore<br/>{<br/>    <strong class="my ir">private</strong> _dogs: Array&lt;Dog&gt; // we changed this to private too</span><span id="ce4f" class="nf lz iq my b gy nk nh l ni nj">    constructor()<br/>    {<br/>        this._dogs = [new Dog()]<br/>        this._dogs[0].name = 'Fido' // will call <strong class="my ir">'set'<br/>    }</strong></span><span id="34f8" class="nf lz iq my b gy nk nh l ni nj">    printAllDogNames(): void<br/>    {<br/>        this._dogs.forEach(dog =&gt; {<br/>            console.log(dog.name) // will call <strong class="my ir">'get'</strong><br/>        })<br/>    }<br/>}</span></pre><p id="d480" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后，让我们看看<code class="fe mv mw mx my b">protected</code>关键字。受保护意味着变量/方法只能在父类的子类中访问。还记得<code class="fe mv mw mx my b">Animal</code>父类的<code class="fe mv mw mx my b">makeSound</code>方法吗？我们不应该能够在任何从动物或动物本身继承的类上从外部访问那个方法，因为动物不会发声。我喜欢在受保护的属性后面加上下划线，尽管这不是惯例。</p><pre class="kg kh ki kj gt nb my nc nd aw ne bi"><span id="0f4d" class="nf lz iq my b gy ng nh l ni nj">class Animal<br/>{<br/>    <strong class="my ir">protected</strong> makeSound_(sound: string): void<br/>    {<br/>        console.log(sound)<br/>        console.log(sound)<br/>        console.log(sound)<br/>    }<br/>}</span><span id="5926" class="nf lz iq my b gy nk nh l ni nj">class Dog extends Animal<br/>{<br/>    makeSound(): void<br/>    {<br/>        super.makeSound_('woof woof')<br/>    }<br/>}</span><span id="a924" class="nf lz iq my b gy nk nh l ni nj">class PetStore<br/>{</span><span id="fdc2" class="nf lz iq my b gy nk nh l ni nj">    makeSomeSounds(): void<br/>    {<br/>        let dog = new Dog()<br/>        dog.makeSound() // =&gt; <strong class="my ir">'woof woof' 'woof woof' 'woof woof'</strong></span><span id="c0f1" class="nf lz iq my b gy nk nh l ni nj">        let animal = new Animal()<br/>        animal.makeSound_() // =&gt; <strong class="my ir">NOT ALLOWED</strong><br/>    }<br/>}</span></pre></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="2d4e" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">其他修饰符</h1><p id="5543" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">在讨论TypeScript类时，还有另外两个重要的修饰符:<code class="fe mv mw mx my b">static</code>和<code class="fe mv mw mx my b">readonly</code>。如果我们想访问一个类的属性，而不必麻烦地返回一个实例对象(用<code class="fe mv mw mx my b">new</code>调用对象)，那么我们可以将它标记为<code class="fe mv mw mx my b">static</code>，它将被设置在类(函数对象)本身上。这对于不依赖于任何动态属性的方法和类变量很有用。例如，一只狗将永远是同一物种。</p><pre class="kg kh ki kj gt nb my nc nd aw ne bi"><span id="5ce8" class="nf lz iq my b gy ng nh l ni nj">class Dog<br/>{<br/>    <strong class="my ir">static</strong> species = 'Canis Familaris'<br/>    age = 10<br/>}</span><span id="7b88" class="nf lz iq my b gy nk nh l ni nj">class PetStore<br/>{<br/>    printSpecies(): void<br/>    {<br/>        console.log(Dog.species) // =&gt; <strong class="my ir">'Canis Familaris'</strong><br/>        console.log(Dog.age) // =&gt; <strong class="my ir">undefined</strong><br/>    }<br/>}</span></pre><p id="5589" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">关键字<code class="fe mv mw mx my b">readonly</code>是不言自明的。它用于类级别的变量，意味着该值不能被重新分配。创建类时初始化的值应该是只读的，并且你知道这些值永远不会改变。我们的<code class="fe mv mw mx my b">Dog</code>类的<code class="fe mv mw mx my b">species</code>属性就是一个很好的例子。无论我们赋予狗什么样的属性，它永远是同一物种。</p><pre class="kg kh ki kj gt nb my nc nd aw ne bi"><span id="7625" class="nf lz iq my b gy ng nh l ni nj">class Dog<br/>{<br/>    static<strong class="my ir"> readonly</strong> species = 'Canis Familaris'<br/>}</span><span id="8d34" class="nf lz iq my b gy nk nh l ni nj">class PetStore<br/>{<br/>    printSpecies(): void<br/>    {<br/>        console.log(Dog.species) // =&gt; <strong class="my ir">'Canis Familaris'</strong><br/>        Dog.species = 'Terdus Maximus' // =&gt; <strong class="my ir">NOT ALLOWED</strong><br/>    }<br/>}</span></pre></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="7982" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">接口</h1><p id="5583" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">每当我们想说被传递的对象有一组特定的属性时，我们可以使用接口。接口是漂亮的小工具，可用于多种情况。</p><p id="7384" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最直接想到的就是测试。假设我们的<code class="fe mv mw mx my b">Dog</code>类中有一个执行I/O调用的方法，我们想要对调用该方法的<code class="fe mv mw mx my b">PetStore</code>类中的方法进行单元测试。我们不想在每次运行单元测试时都触发I/O调用，但是我们仍然需要一个评估为<code class="fe mv mw mx my b">Dog</code>类型的对象。让我们创建一个<code class="fe mv mw mx my b">iDog</code>接口，它为我们为单元测试创建的常规类和模拟类指定了一个方法。</p><pre class="kg kh ki kj gt nb my nc nd aw ne bi"><span id="56fc" class="nf lz iq my b gy ng nh l ni nj">interface iDog<br/>{<br/>    getPedigree: Function<br/>}</span><span id="96a2" class="nf lz iq my b gy nk nh l ni nj">class Dog implements iDog<br/>{<br/>    getPedigree(): Promise&lt;Pedigree&gt;<br/>    {<br/>        return someThirdPartyIoCall('...')<br/>    }<br/>}</span><span id="bf85" class="nf lz iq my b gy nk nh l ni nj">class MockDog implements iDog<br/>{<br/>    getPedigree(): Promise&lt;Pedigree&gt;<br/>    {<br/>        return new DummyPedigreeObject()<br/>    }<br/>}</span><span id="1974" class="nf lz iq my b gy nk nh l ni nj">async function methodToBeTested(dog: iDog): Promise&lt;void&gt;<br/>{<br/>    try {<br/>        let pedigree = await dog.getPedigree()<br/>        // do assertions here<br/>    }<br/>    catch(err) {<br/>        console.log(err)<br/>    }<br/>}</span><span id="5d77" class="nf lz iq my b gy nk nh l ni nj"><br/>// Real World<br/>methodToBeTested(new Dog())</span><span id="167c" class="nf lz iq my b gy nk nh l ni nj"><br/>// During Testing<br/>methodToBeTested(new MockDog()) </span></pre><p id="185a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这只是使用接口的一个小例子，还有更多的用途。我建议查看这里的TypeScript文档<a class="ae mz" href="https://www.typescriptlang.org/docs/handbook/interfaces.html" rel="noopener ugc nofollow" target="_blank">以获取更多信息。</a></p></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="36fe" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">抽象类和方法</h1><p id="4509" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">可以把抽象类看作是常规父类和接口的结合。抽象类像接口一样为其他类定义属性，但是它们的一些方法可能包含不同于接口的实现。没有实现的方法必须标记为<code class="fe mv mw mx my b">abstract</code>，它的包含对象也必须如此。抽象类可能不会被实例化(不能使用<code class="fe mv mw mx my b">new</code>)并且在你知道你永远不会直接需要父类的时候有用。</p><p id="56ff" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对于猫和狗，我们都有<code class="fe mv mw mx my b">age</code>属性，并想知道它们各自的人类年龄。定义这一点的方法因动物而异。让我们使用一个抽象类。</p><pre class="kg kh ki kj gt nb my nc nd aw ne bi"><span id="4610" class="nf lz iq my b gy ng nh l ni nj"><strong class="my ir">abstract</strong> class Animal<br/>{<br/>    protected age_: number</span><span id="16f7" class="nf lz iq my b gy nk nh l ni nj">    <strong class="my ir">abstract</strong> getRelativeAge(): number;<br/>}</span><span id="8668" class="nf lz iq my b gy nk nh l ni nj">class Dog extends Animal<br/>{<br/>    getRelativeAge(): number<br/>    {<br/>        return this.age_ * 7<br/>    }<br/>}</span><span id="0cd2" class="nf lz iq my b gy nk nh l ni nj">class Cat extends Animal<br/>{<br/>    getRelativeAge(): number<br/>    {<br/>        return this.age_ * 6<br/>    }<br/>}</span></pre><blockquote class="nl nm nn"><p id="5936" class="kv kw na kx b ky kz jr la lb lc ju ld no lf lg lh np lj lk ll nq ln lo lp lq ij bi translated"><strong class="kx ir">注意</strong>:这并不是如何正确计算猫和狗的年龄的准确表述。</p></blockquote></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="9092" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">结论</h1><p id="598b" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">关于TypeScript类，还有比本教程所涵盖的更多的东西，但是希望这个快速简单的概述有助于更好地理解事情。无论您或其他人是否打算广泛使用TypeScript，这里涉及的面向对象概念与其他面向对象语言有很多重叠，这仍然是一本非常有用的读物。Typescript对于学习OO也很好，因为这是一种不如Java、C#或C++正式的语言。</p></div></div>    
</body>
</html>