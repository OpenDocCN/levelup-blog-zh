<html>
<head>
<title>Python Objects: Under the Hood</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python对象:引擎盖下</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/python-objects-under-the-hood-1b9c4a9cf41d?source=collection_archive---------12-----------------------#2020-05-27">https://levelup.gitconnected.com/python-objects-under-the-hood-1b9c4a9cf41d?source=collection_archive---------12-----------------------#2020-05-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/4b670787e6de20c6b746dd30dfa2c02d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Y4t3Oe0ojApBo-pw.jpg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">图片鸣谢pixabay.com:<a class="ae kf" href="https://pixabay.com/illustrations/python-python-logo-4785225/" rel="noopener ugc nofollow" target="_blank">https://pix abay . com/illustrations/python-python-logo-4785225/</a></figcaption></figure><p id="d51d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">简介:</strong> <br/> Python是一种面向对象的编程语言，顾名思义，是一种基于对象和类的编程方法。这与其他方法形成了对比，其他方法在数据片段之间有着松散的联系。知道这一点很重要，因为在大多数OOP语言中，一切都是对象，这对于数据如何在程序中处理和传递有许多含义。</p><p id="f32a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu"> ID和Type: <br/> </strong> ID和Type都是python中内置的函数，提供传递给它们的对象的信息，特别是它们各自的唯一标识和数据类型。例如，如果你有一个名为' a '的变量，并将其设置为等于另一个名为' b '的对象，它们将具有相同的标识，因为它们指向同一个对象。这就是所谓的别名，因为你并没有真正地创建一个新的对象，只是为同一个对象取了另一个名字。由于python内部的优化，只要对象是相同的，即使值是独立设置的，也会发生这种情况。利用id函数提供的信息特别有用，因为如果两个对象具有相同的id，它们就是同一个对象，改变其中一个也会改变另一个。请注意，“is”检查两个对象是否具有相同的id，而“==”检查两个对象是否具有相同的内容。</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div class="gh gi le"><img src="../Images/399e523bdab2f8cac2a99722a6aba159.png" data-original-src="https://miro.medium.com/v2/resize:fit:620/format:webp/1*RrT1f-JQLBeS6mVtqN_0qA.png"/></div></figure><p id="a954" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">可变对象:</strong> <br/>您可能在浏览文档或StackOverflow时遇到过‘可变’或‘不可变’这两个词。这些描述应用于数据类型时，用于指示数据在创建后是否可以更改。这种区别很重要，因为可变数据类型(如列表、字典和集合)与不可变数据类型(如元组、字符串和整型)的处理和存储方式不同。考虑下面的函数，这些函数展示了可变数据类型是如何被改变的，即使是在另一个函数中:</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div class="gh gi lj"><img src="../Images/01512a0d6976fcfb78f620be3fd1065c.png" data-original-src="https://miro.medium.com/v2/resize:fit:408/format:webp/1*cSm6Yd0bYZbfyfm5HaVKnA.png"/></div></figure><p id="f79a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">不可变对象:</strong> <br/>可变对象的对立面是不可变对象，创建后不能改变。不可变对象的例子包括诸如字符串、整型、浮点型和布尔型等数据类型。这对后台处理的数据意味着什么？每当一个对象被创建时，它在内存中被分配一个位置，如它的ID所示。请注意，当下面的a从1变为2时，它并没有改变不可变对象；它创造了一个全新的物体。重新分配指向该对象的变量不会删除该对象，因为它仍然存在于内存中，您只是失去了对它的绑定。</p><p id="9c09" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通常，一旦所有绑定丢失，原始对象将被删除，但是，由于NSMALLPOSINTS和NSMALLNEGINTS最常用的整数的值范围分别为0–256和-5–0。这些对象在python脚本运行的任何时候都会被预加载，然后创建一个新的变量可以指向同一个对象，因为它仍然存在于内存中。然而，情况并不总是如此，例如元组。其他预先分配的整数，例如在某个范围内，也会显示类似的效果。关于元组，值得注意的一个特别有趣的地方是，尽管它们是不可变的数据类型，但它们可以保存可以在元组中更改的可变数据类型。冻结集也是如此。</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div class="gh gi lk"><img src="../Images/49aa5ae8cd1174812144a50d091440f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:332/format:webp/1*MXmxWGxX0iJ_GnI-fRkHsg.png"/></div></figure><p id="bca6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">这有什么关系？:</strong> <br/>可变性和不可变性各有优缺点。可变对象可以根据需要进行更改和适应，这有其优点和缺点。可变对象的最大好处是，在任何需要改变的时候，不必复制新的实例。以一个简单的游戏为例，它有一个代表统计数据的列表。列表中的属性可能会因为游戏中的各种效果而频繁改变，如果需要的话，简单地改变列表中的值要比任何时候做一个新的列表要快得多。</p><p id="9229" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一方面，不可变对象通过它们的稳定性提供了好处。一般来说，不可变对象更容易构造、测试和使用，因为不需要考虑任何变化，所以需要准备更少的测试用例来发现异常。不可变对象还防止了由同时被多个对象引用而导致的副作用。以上面的视频游戏为例，如果一个值是一个永远不会改变的已知常数，让它成为不可变的将允许它更快地被引用，并减少可能发生错误的点。从本质上讲，当函数围绕它们的好处设计时，不可变对象只是使程序员的生活更简单。</p><p id="b3c7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">参数是如何传递给函数的，这对可变和不可变对象意味着什么？:<br/> </strong>理解这一点特别重要，因为python编译器根据发送的数据是可变的还是不可变的来处理函数参数。以下面的函数为例:</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div class="gh gi ll"><img src="../Images/8cbe00ae1c9d058df5ecda7f9528d153.png" data-original-src="https://miro.medium.com/v2/resize:fit:444/format:webp/1*fUFPLJ6I9Z-uLLgyGD91Mg.png"/></div></figure><p id="9d5b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在看答案之前，花点时间想想变量num1包含了什么。</p><p id="0a4e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当变量num1被初始设置时，它包含整数值99。它被传递给函数increment_1，该函数只是将值增加1。这里出现问题是因为整数，如前所述，是不可变的。因为不可变对象不能被改变，所以当它增加1时，反而创建整数的副本，并且不改变参数之外的原始num1。</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div class="gh gi lm"><img src="../Images/12332de4af5a6ac1c773626a726dcf61.png" data-original-src="https://miro.medium.com/v2/resize:fit:424/format:webp/1*-s3thKJT0syY4KJTfg-2vA.png"/></div></figure><p id="24a9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们看一个类似的例子，这次使用的是可变数据类型lists。</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div class="gh gi ln"><img src="../Images/85bab8b28d4eb804352e549a084c37c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:386/format:webp/1*V5P2MndMAZfHfb6wlKH73A.png"/></div></figure><p id="59e6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里也是一样，在继续阅读之前，想一想函数执行后list1应该包含什么。</p><p id="20e6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为list1是一个列表，一个可变的数据类型，而不是在更改时创建副本，所以原始对象被更改，导致下面的结果:</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div class="gh gi lo"><img src="../Images/02815846f2204bdb213779290c2a4aa1.png" data-original-src="https://miro.medium.com/v2/resize:fit:402/format:webp/1*sbkpjmM2Z7gAMSjw3IBs7g.png"/></div></figure><p id="b6d5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">关于python如何处理数据的讨论到此结束，我希望这是有帮助的。</p></div></div>    
</body>
</html>