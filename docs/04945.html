<html>
<head>
<title>Managing cloud infrastructure in code with Terraform: spawning your own JupyterHub instance on AWS with mounted S3 bucket</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Terraform在代码中管理云基础设施:使用挂载的S3桶在AWS上生成您自己的JupyterHub实例</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/managing-cloud-infrastructure-in-code-with-terraform-spawning-your-own-jupyterhub-instance-on-aws-4d67978f870?source=collection_archive---------11-----------------------#2020-07-25">https://levelup.gitconnected.com/managing-cloud-infrastructure-in-code-with-terraform-spawning-your-own-jupyterhub-instance-on-aws-4d67978f870?source=collection_archive---------11-----------------------#2020-07-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="b722" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://terraform.io/intro/index.html" rel="noopener ugc nofollow" target="_blank"> Terraform </a>是一款开源软件，通过代码管理云基础设施。只需几行代码，我们就可以启动实例、创建存储桶、供应数据库和许多其他资源。同时，Terraform允许以可复制的方式动态地改变和发展基础设施。在我们的例子中，我们将使用Terraform在AWS上推出我们自己的jupyterhub(使用<a class="ae kl" href="http://tljh.jupyter.org/en/latest/" rel="noopener ugc nofollow" target="_blank">最小的jupyterhub </a>发行版)，利用一个安装的S3存储桶进行永久存储。</p><p id="e683" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">完整的设置可以在<a class="ae kl" href="https://github.com/stelsemeyer/aws-tf-jh" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到，关于Terraform的非常好的介绍可以在<a class="ae kl" href="https://learn.hashicorp.com/terraform" rel="noopener ugc nofollow" target="_blank"> HashiCorp网站</a>上找到。</p><p id="e717" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将从一个非常简短的Terraform介绍开始(&gt; =0.12)，由三个步骤组成:定义、计划、应用。创建EC2实例和S3存储桶非常简单:我们定义资源，例如在一个名为<code class="fe km kn ko kp b">example.tf</code>的文件中:</p><pre class="kq kr ks kt gt ku kp kv kw aw kx bi"><span id="31d5" class="ky kz iq kp b gy la lb l lc ld">provider "aws" { <br/>  region = "eu-central-1" <br/>  access_key = "my-access-key" <br/>  secret_key = "my-secret-key" <br/>} </span><span id="18b3" class="ky kz iq kp b gy le lb l lc ld">resource "aws_instance" "my_tf_test_instance" { <br/>  ami = "ami-0b418580298265d5c" <br/>  instance_type = "t2.nano" <br/>} </span><span id="c09c" class="ky kz iq kp b gy le lb l lc ld">resource "aws_s3_bucket" "my_tf_test_bucket" { <br/>  bucket = "my-fantastic-tf-test-bucket" <br/>  acl = "private" <br/>}</span></pre><p id="ea41" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦我们通过<code class="fe km kn ko kp b">terraform plan</code>进行计划，我们就可以验证Terraform想要执行哪些操作来创建我们的资源:</p><pre class="kq kr ks kt gt ku kp kv kw aw kx bi"><span id="ac64" class="ky kz iq kp b gy la lb l lc ld">An execution plan has been generated and is shown below.<br/>Resource actions are indicated with the following symbols:<br/>  + create</span><span id="167f" class="ky kz iq kp b gy le lb l lc ld">Terraform will perform the following actions:</span><span id="9a62" class="ky kz iq kp b gy le lb l lc ld"># aws_instance.my_tf_test_instance will be created<br/>  + resource "aws_instance" "my_tf_test_instance" {<br/>      + ami                          = "ami-0b418580298265d5c"<br/>      + arn                          = (known after apply)<br/>      + associate_public_ip_address  = (known after apply)<br/>      + availability_zone            = (known after apply)<br/>      + cpu_core_count               = (known after apply)<br/>      + cpu_threads_per_core         = (known after apply)<br/>      + get_password_data            = false<br/>      + host_id                      = (known after apply)<br/>      + id                           = (known after apply)<br/>      + instance_state               = (known after apply)<br/>      + instance_type                = "t2.medium"<br/>      + ipv6_address_count           = (known after apply)<br/>      + ipv6_addresses               = (known after apply)<br/>      + key_name                     = (known after apply)<br/>      + network_interface_id         = (known after apply)<br/>      + password_data                = (known after apply)<br/>      + placement_group              = (known after apply)<br/>      + primary_network_interface_id = (known after apply)<br/>      + private_dns                  = (known after apply)<br/>      + private_ip                   = (known after apply)<br/>      + public_dns                   = (known after apply)<br/>      + public_ip                    = (known after apply)<br/>      + security_groups              = (known after apply)<br/>      + source_dest_check            = true<br/>      + subnet_id                    = (known after apply)<br/>      + tenancy                      = (known after apply)<br/>      + volume_tags                  = (known after apply)<br/>      + vpc_security_group_ids       = (known after apply)</span><span id="62a0" class="ky kz iq kp b gy le lb l lc ld">+ ebs_block_device {<br/>          + delete_on_termination = (known after apply)<br/>          + device_name           = (known after apply)<br/>          + encrypted             = (known after apply)<br/>          + iops                  = (known after apply)<br/>          + kms_key_id            = (known after apply)<br/>          + snapshot_id           = (known after apply)<br/>          + volume_id             = (known after apply)<br/>          + volume_size           = (known after apply)<br/>          + volume_type           = (known after apply)<br/>        }</span><span id="a6a8" class="ky kz iq kp b gy le lb l lc ld">+ ephemeral_block_device {<br/>          + device_name  = (known after apply)<br/>          + no_device    = (known after apply)<br/>          + virtual_name = (known after apply)<br/>        }</span><span id="b04d" class="ky kz iq kp b gy le lb l lc ld">+ metadata_options {<br/>          + http_endpoint               = (known after apply)<br/>          + http_put_response_hop_limit = (known after apply)<br/>          + http_tokens                 = (known after apply)<br/>        }</span><span id="29a8" class="ky kz iq kp b gy le lb l lc ld">+ network_interface {<br/>          + delete_on_termination = (known after apply)<br/>          + device_index          = (known after apply)<br/>          + network_interface_id  = (known after apply)<br/>        }</span><span id="b1cb" class="ky kz iq kp b gy le lb l lc ld">+ root_block_device {<br/>          + delete_on_termination = (known after apply)<br/>          + device_name           = (known after apply)<br/>          + encrypted             = (known after apply)<br/>          + iops                  = (known after apply)<br/>          + kms_key_id            = (known after apply)<br/>          + volume_id             = (known after apply)<br/>          + volume_size           = (known after apply)<br/>          + volume_type           = (known after apply)<br/>        }<br/>    }</span><span id="0e29" class="ky kz iq kp b gy le lb l lc ld"># aws_s3_bucket.my_tf_test_bucket will be created<br/>  + resource "aws_s3_bucket" "my_tf_test_bucket" {<br/>      + acceleration_status         = (known after apply)<br/>      + acl                         = "private"<br/>      + arn                         = (known after apply)<br/>      + bucket                      = "my-fantastic-tf-test-bucket"<br/>      + bucket_domain_name          = (known after apply)<br/>      + bucket_regional_domain_name = (known after apply)<br/>      + force_destroy               = false<br/>      + hosted_zone_id              = (known after apply)<br/>      + id                          = (known after apply)<br/>      + region                      = (known after apply)<br/>      + request_payer               = (known after apply)<br/>      + website_domain              = (known after apply)<br/>      + website_endpoint            = (known after apply)</span><span id="7abd" class="ky kz iq kp b gy le lb l lc ld">+ versioning {<br/>          + enabled    = (known after apply)<br/>          + mfa_delete = (known after apply)<br/>        }<br/>    }</span><span id="cb99" class="ky kz iq kp b gy le lb l lc ld">Plan: 2 to add, 0 to change, 0 to destroy.</span></pre><p id="80c8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们对计划满意，我们可以委托Terraform使用<code class="fe km kn ko kp b">terraform apply</code>创建计划的两个资源:</p><pre class="kq kr ks kt gt ku kp kv kw aw kx bi"><span id="cf8e" class="ky kz iq kp b gy la lb l lc ld">aws_instance.my_tf_test_instance: Creating...<br/>aws_s3_bucket.my_tf_test_bucket: Creating...<br/>aws_s3_bucket.my_tf_test_bucket: Still creating... [10s elapsed]<br/>aws_instance.my_tf_test_instance: Still creating... [10s elapsed]<br/>aws_s3_bucket.my_tf_test_bucket: Creation complete after 11s [id=my-fantastic-tf-test-bucket]<br/>aws_instance.my_tf_test_instance: Still creating... [20s elapsed]<br/>aws_instance.my_tf_test_instance: Creation complete after 25s [id=i-05f10xxxxxxdde4b]</span><span id="f49a" class="ky kz iq kp b gy le lb l lc ld">Apply complete! Resources: 2 added, 0 changed, 0 destroyed.</span></pre><p id="a1c7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于Terraform跟踪状态，并且还可以应用差异，因此我们可以轻松地修改我们已经创建的资源，例如，通过更改我们的实例类型或向我们的S3存储桶添加版本控制，然后再次应用:</p><pre class="kq kr ks kt gt ku kp kv kw aw kx bi"><span id="a7e2" class="ky kz iq kp b gy la lb l lc ld">resource "aws_instance" "my_tf_test_instance" {<br/>  ami                    = "ami-0b418580298265d5c"<br/>  instance_type          = "t2.nano"<br/>}</span><span id="a7eb" class="ky kz iq kp b gy le lb l lc ld">resource "aws_s3_bucket" "my_tf_test_bucket" {<br/>  bucket = "my-fantastic-tf-test-bucket"<br/>  acl    = "private"</span><span id="d088" class="ky kz iq kp b gy le lb l lc ld">versioning {<br/>    enabled = true<br/>  }<br/>}</span></pre><p id="72bc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦我们再次计划，我们将看到一个很好的差异渲染视图:</p><pre class="kq kr ks kt gt ku kp kv kw aw kx bi"><span id="be52" class="ky kz iq kp b gy la lb l lc ld">Refreshing Terraform state in-memory prior to plan...<br/>The refreshed state will be used to calculate this plan, but will not be<br/>persisted to local or remote state storage.</span><span id="068c" class="ky kz iq kp b gy le lb l lc ld">aws_s3_bucket.my_tf_test_bucket: Refreshing state... [id=my-fantastic-tf-test-bucket]<br/>aws_instance.my_tf_test_instance: Refreshing state... [id=i-05f10xxxxxxdde4b]</span><span id="9bd8" class="ky kz iq kp b gy le lb l lc ld">------------------------------------------------------------------------</span><span id="65ae" class="ky kz iq kp b gy le lb l lc ld">An execution plan has been generated and is shown below.<br/>Resource actions are indicated with the following symbols:<br/>  ~ update in-place</span><span id="40f2" class="ky kz iq kp b gy le lb l lc ld">Terraform will perform the following actions:</span><span id="b1da" class="ky kz iq kp b gy le lb l lc ld"># aws_instance.my_tf_test_instance will be updated in-place<br/>  ~ resource "aws_instance" "my_tf_test_instance" {<br/>        ami                          = "ami-0b418580298265d5c"<br/>        ...<br/>      ~ instance_type                = "t2.medium" -&gt; "t2.nano"<br/>        ...<br/>    }</span><span id="1915" class="ky kz iq kp b gy le lb l lc ld"># aws_s3_bucket.my_tf_test_bucket will be updated in-place<br/>  ~ resource "aws_s3_bucket" "my_tf_test_bucket" {<br/>        acl                         = "private"<br/>        arn                         = "arn:aws:s3:::my-fantastic-tf-test-bucket"<br/>        bucket                      = "my-fantastic-tf-test-bucket"<br/>        ...<br/>      ~ versioning {<br/>          ~ enabled    = false -&gt; true<br/>            mfa_delete = false<br/>        }<br/>    }</span><span id="6aac" class="ky kz iq kp b gy le lb l lc ld">Plan: 0 to add, 2 to change, 0 to destroy.</span></pre><p id="051f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们来点新鲜的，在一个使用Ubuntu的EC2实例上部署我们自己的juypterhub，包括挂载S3存储来持久化数据。</p><p id="10c4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在Terraform中，我们可以定义变量，例如。在一个<code class="fe km kn ko kp b">vars.tf</code>文件中，该文件可以在使用<code class="fe km kn ko kp b">var.var_name</code>的其他模块中被引用(例如<code class="fe km kn ko kp b">var.instance_type</code>):</p><pre class="kq kr ks kt gt ku kp kv kw aw kx bi"><span id="56fc" class="ky kz iq kp b gy la lb l lc ld">variable "aws_access_key" {}</span><span id="0ba8" class="ky kz iq kp b gy le lb l lc ld">variable "aws_secret_key" {}</span><span id="a8d0" class="ky kz iq kp b gy le lb l lc ld">variable "aws_region" {<br/>  default = "eu-central-1"<br/>}</span><span id="3842" class="ky kz iq kp b gy le lb l lc ld">variable "amis" {<br/>  type = map(string)<br/>  default = {<br/>    eu-central-1 = "ami-0b418580298265d5c"<br/>    us-east-1    = "ami-07ebfd5b3428b6f4d"<br/>  }<br/>}</span><span id="b602" class="ky kz iq kp b gy le lb l lc ld">variable "instance_type" {<br/>  default = "t2.large"<br/>}</span><span id="44a7" class="ky kz iq kp b gy le lb l lc ld">variable "bucket_name" {<br/>  default = "jh-storage"<br/>}</span></pre><p id="4d34" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以将机密文件留空，并在未分级的<code class="fe km kn ko kp b">terraform.tfvars</code>文件中定义它们:</p><pre class="kq kr ks kt gt ku kp kv kw aw kx bi"><span id="912a" class="ky kz iq kp b gy la lb l lc ld">aws_access_key = "my-access-key"<br/>aws_secret_key = "my-secret-key"<br/>aws_region     = "eu-central-1"<br/>jh_password    = "some-password-to-jh-ub"</span></pre><p id="2165" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于我们将使用AWS作为我们的提供者，我们将如下定义一个<code class="fe km kn ko kp b">provider.tf</code>:</p><pre class="kq kr ks kt gt ku kp kv kw aw kx bi"><span id="1a79" class="ky kz iq kp b gy la lb l lc ld">provider "aws" {<br/>  access_key = var.aws_access_key<br/>  secret_key = var.aws_secret_key<br/>  region     = var.aws_region<br/>}</span></pre><p id="9b8c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在一个<code class="fe km kn ko kp b">main.tf</code>中，我们可以定义我们的实例加安全组，以允许通过SSH和HTTP/HTTPS的入站流量和所有出站流量，此外，我们还添加了一个<code class="fe km kn ko kp b">iam_instance_profile</code>，这将在后面解释。如你所见，我们可以用点符号引用变量和其他资源，所以我们的实例的安全组通过<code class="fe km kn ko kp b">aws_security_group.instance.id</code>，我们的实例通过aws_instance.jh，等等。此外，我们将使用<code class="fe km kn ko kp b">templatefile</code>加载一个shell脚本并呈现包含的变量。</p><pre class="kq kr ks kt gt ku kp kv kw aw kx bi"><span id="27de" class="ky kz iq kp b gy la lb l lc ld">resource "aws_instance" "jh" {<br/>  ami                    = lookup(var.amis, var.aws_region)<br/>  instance_type          = var.instance_type<br/>  vpc_security_group_ids = [aws_security_group.instance.id]<br/>  iam_instance_profile   = aws_iam_instance_profile.jh.name</span><span id="141f" class="ky kz iq kp b gy le lb l lc ld">user_data = templatefile("script/install.sh", {<br/>    aws_region = var.aws_region<br/>    bucket_name = var.bucket_name<br/>    password = var.password<br/>  })</span><span id="91bb" class="ky kz iq kp b gy le lb l lc ld">tags = {<br/>    Name = "jh"<br/>  }<br/>}</span><span id="239b" class="ky kz iq kp b gy le lb l lc ld">resource "aws_security_group" "instance" {<br/>  ingress {<br/>    from_port   = 22<br/>    to_port     = 22<br/>    protocol    = "tcp"<br/>    cidr_blocks = ["0.0.0.0/0"]<br/>  }</span><span id="9b20" class="ky kz iq kp b gy le lb l lc ld">ingress {<br/>    from_port   = 80<br/>    to_port     = 80<br/>    protocol    = "tcp"<br/>    cidr_blocks = ["0.0.0.0/0"]<br/>  }</span><span id="b743" class="ky kz iq kp b gy le lb l lc ld">ingress {<br/>    from_port   = 443<br/>    to_port     = 443<br/>    protocol    = "tcp"<br/>    cidr_blocks = ["0.0.0.0/0"]<br/>  }</span><span id="0898" class="ky kz iq kp b gy le lb l lc ld">egress {<br/>    from_port   = 0<br/>    to_port     = 0<br/>    protocol    = -1<br/>    cidr_blocks = ["0.0.0.0/0"]<br/>  }</span><span id="9e50" class="ky kz iq kp b gy le lb l lc ld">tags = {<br/>    Name = "jh"<br/>  }<br/>}</span></pre><p id="4812" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">实例的<code class="fe km kn ko kp b">user data</code>是在initial(！idspnonenote)上执行的脚本。)实例的启动。这里我们引用一个bash脚本<code class="fe km kn ko kp b">script/install.sh</code>，它包含一些变量(<code class="fe km kn ko kp b">aws_region</code>、<code class="fe km kn ko kp b">bucket_name</code>、<code class="fe km kn ko kp b">password</code>)，这些变量将由<code class="fe km kn ko kp b">templatefile</code>呈现:</p><pre class="kq kr ks kt gt ku kp kv kw aw kx bi"><span id="5309" class="ky kz iq kp b gy la lb l lc ld">#!/bin/bash<br/>sudo sudo apt-get update</span><span id="1ad6" class="ky kz iq kp b gy le lb l lc ld"># install s3fs &amp; mount bucket <br/>sudo apt-get install s3fs<br/>sudo s3fs \<br/>    -o iam_role="auto" \<br/>    -o url="<a class="ae kl" href="https://s3-${aws_region}.amazonaws.com" rel="noopener ugc nofollow" target="_blank">https://s3-${aws_region}.amazonaws.com</a>" \<br/>    -o umask=000 \<br/>    -o allow_other \<br/>    ${bucket_name} /mnt</span><span id="fb58" class="ky kz iq kp b gy le lb l lc ld"># install tljh<br/>curl <a class="ae kl" href="https://raw.githubusercontent.com/jupyterhub/the-littlest-jupyterhub/master/bootstrap/bootstrap.py" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/jupyterhub/the-littlest-jupyterhub/master/bootstrap/bootstrap.py</a> \<br/>    | sudo python3 - \<br/>    --admin admin:${password} \<br/>    --user-requirements-txt-url   <a class="ae kl" href="https://raw.githubusercontent.com/stelsemeyer/aws-tf-jh/master/script/requirements.txt" rel="noopener ugc nofollow" target="_blank">https://raw.githubusercontent.com/stelsemeyer/aws-tf-jh/master/script/requirements.txt</a></span></pre><p id="ab70" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">安装脚本将安装并运行<code class="fe km kn ko kp b">s3fs</code>,使用(自动检测到的)IAM角色来装载我们的S3存储桶，以允许访问。我们还需要指定<code class="fe km kn ko kp b">allow_other</code>和<code class="fe km kn ko kp b">umask=000</code>来允许所有用户读写该文件夹中的所有文件。</p><p id="10b2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">之后，来自“littlest jupyterhub”(tljh)的安装脚本将安装jupyterhub，使用Terraform变量中的密码设置一个名为<code class="fe km kn ko kp b">admin</code>的用户，并从<code class="fe km kn ko kp b">requirements.txt</code>文件中预安装软件包。</p><p id="1b6e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">仍然缺少的是我们的IAM角色，它支持从我们的EC2无缝访问我们的S3时段。我们可以在一个<code class="fe km kn ko kp b">data.tf</code>中定义我们的策略(通常是json ),并通过以下方式在我们的角色相关资源中再次引用它们:</p><pre class="kq kr ks kt gt ku kp kv kw aw kx bi"><span id="f12a" class="ky kz iq kp b gy la lb l lc ld">data "aws_iam_policy_document" "s3" {<br/>  statement {<br/>    actions = [<br/>      "s3:*"<br/>    ]</span><span id="c10f" class="ky kz iq kp b gy le lb l lc ld"># add our bucket and all contained files<br/>    resources = [<br/>      "arn:aws:s3:::${var.bucket_name}",<br/>      "arn:aws:s3:::${var.bucket_name}/*"<br/>    ]<br/>  }<br/>}</span><span id="85ca" class="ky kz iq kp b gy le lb l lc ld">data "aws_iam_policy_document" "sts" {<br/>  statement {<br/>    actions = [<br/>      "sts:AssumeRole"<br/>    ]</span><span id="6b57" class="ky kz iq kp b gy le lb l lc ld">principals {<br/>      type        = "Service"<br/>      identifiers = ["ec2.amazonaws.com"]<br/>    }<br/>  }<br/>}</span></pre><p id="9482" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于我们的<code class="fe km kn ko kp b">main.tf</code>,我们将添加:</p><pre class="kq kr ks kt gt ku kp kv kw aw kx bi"><span id="a729" class="ky kz iq kp b gy la lb l lc ld">resource "aws_iam_role" "jh" {<br/>  name               = "jh_role"<br/>  assume_role_policy = data.aws_iam_policy_document.sts.json</span><span id="6317" class="ky kz iq kp b gy le lb l lc ld">tags = {<br/>    Name = "jh"<br/>  }<br/>}</span><span id="1c2b" class="ky kz iq kp b gy le lb l lc ld">resource "aws_iam_instance_profile" "jh" {<br/>  role = aws_iam_role.jh.name<br/>}</span><span id="c47f" class="ky kz iq kp b gy le lb l lc ld">resource "aws_iam_role_policy" "jh" {<br/>  role   = aws_iam_role.jh.id<br/>  policy = data.aws_iam_policy_document.s3.json<br/>}</span></pre><p id="fbc4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">综上所述，我们可以开始规划和应用我们的基础架构:</p><ul class=""><li id="f10e" class="lf lg iq jp b jq jr ju jv jy lh kc li kg lj kk lk ll lm ln bi translated">安装s3fs &amp; tljh的设置脚本<code class="fe km kn ko kp b">install.sh</code></li><li id="7149" class="lf lg iq jp b jq lo ju lp jy lq kc lr kg ls kk lk ll lm ln bi translated"><code class="fe km kn ko kp b">terraform.tfvars</code>带凭据</li></ul><p id="08ae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">大约10到15分钟后，我们可以通过输出中显示的公共主机名访问我们的实例:</p><pre class="kq kr ks kt gt ku kp kv kw aw kx bi"><span id="c07a" class="ky kz iq kp b gy la lb l lc ld">Outputs:</span><span id="8820" class="ky kz iq kp b gy le lb l lc ld">public_dns = ec2-aa-bb-cc-dd.eu-central-1.compute.amazonaws.com</span></pre><p id="0831" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您应该会看到以下登录页面:</p><figure class="kq kr ks kt gt lu gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/7c00df0ef612d005e1e1897d0c11feab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1232/format:webp/0*gkyYQZeQuPpV2ZQs.png"/></div></figure><p id="52c4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您也可以通过<code class="fe km kn ko kp b">New &gt; Terminal</code>访问实例的终端:</p><figure class="kq kr ks kt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="gh gi lx"><img src="../Images/d6c897523db58ca7787649570b5b2b89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*QxzzAtmntvzs0-i9.png"/></div></div></figure><p id="345d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们通过在挂载的文件夹中存储一些数据来尝试我们的S3连接，并检查它是否出现在我们的bucket中。理论上，我们还可以以一种非常舒适的方式(不需要额外的身份验证)使用boto从我们的(或者如果在我们的策略中定义的话)其他桶中获取数据:</p><pre class="kq kr ks kt gt ku kp kv kw aw kx bi"><span id="4009" class="ky kz iq kp b gy la lb l lc ld">import pandas as pd<br/>import boto3</span><span id="140a" class="ky kz iq kp b gy le lb l lc ld"># create dummy data and upload<br/>data = pd.DataFrame({'a': [1,2,3]})<br/>data.to_csv('/mnt/data.csv', index=False)</span><span id="0bf5" class="ky kz iq kp b gy le lb l lc ld"># download dummy data<br/>client = boto3.client('s3', region_name='eu-central-1')<br/>client.download_file('jh-storage', 'data.csv', '/tmp/data_download.csv')</span><span id="fa6e" class="ky kz iq kp b gy le lb l lc ld"># compare<br/>data_downloaded = pd.read_csv('/tmp/data_download.csv')<br/>data.equals(data_downloaded)</span><span id="c68d" class="ky kz iq kp b gy le lb l lc ld">## True</span></pre><p id="c500" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">还有一些需要改进的地方:在docker中运行Terraform是一个很好的实践，将它本身视为一个应用程序，并使用S3或类似工具跟踪状态。此外，重新调整我们的实例当前会卸载S3存储桶(因为用户数据仅在最初创建实例时运行)。我们可以使用一个脚本来重启S3fs，并在重启/调整实例大小后重新挂载S3。云初始化。此外，我们应该使用安全http: tljh通过letsencrypt 提供了一个<a class="ae kl" href="http://tljh.jupyter.org/en/latest/howto/admin/https.html" rel="noopener ugc nofollow" target="_blank">现成的解决方案，不幸的是，它不能与AWS品牌的端点一起工作，但需要一个适当的域(例如。经由53号公路)。</a></p><p id="70ac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们已经学习了Terraform的基础知识，如何使用模板和变量，以及如何在代码中高效、灵活地组合不同的资源，这使得我们可以轻松地为一次性分析或黑客马拉松生成实例。</p><p id="267e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">作为托管笔记本设置的替代方案，我们可以使用AWS Sagemarker或Google笔记本，这是一些无服务器的解决方案，并带有许多预装的自动ML、深度学习等框架。</p></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><p id="bb1a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mj">最初发表于</em><a class="ae kl" href="https://blog.telsemeyer.com/2020/04/19/managing-cloud-infrastructure-in-code-with-terraform-spawning-your-own-jupyterhub-instance-on-aws-with-mounted-s3-bucket/" rel="noopener ugc nofollow" target="_blank">T5【https://blog.telsemeyer.com】</a><em class="mj">。</em></p></div></div>    
</body>
</html>