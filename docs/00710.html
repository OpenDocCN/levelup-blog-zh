<html>
<head>
<title>A Complete Beginners Guide To Javascript — Part 2 (DOM and the Web)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Javascript初学者完全指南—第2部分(DOM和Web)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/a-complete-beginners-guide-to-javascript-part-2-501ec89af76c?source=collection_archive---------3-----------------------#2019-07-04">https://levelup.gitconnected.com/a-complete-beginners-guide-to-javascript-part-2-501ec89af76c?source=collection_archive---------3-----------------------#2019-07-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/a7911a0d954c49151da381f6cb814d77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JUVxbX50X0G8rotN_-l4Lg.png"/></div></div></figure><p id="06d5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是两个故事中的第二个，在这里你将学到开始使用Javascript编程所需要知道的一切。</p><p id="4939" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">就像第一部分中的<a class="ae kw" rel="noopener ugc nofollow" target="_blank" href="/a-complete-beginners-guide-to-javascript-part-1-d04919d0cb19?source=friends_link&amp;sk=f38ce5d145cc4768f6ad393f5483d2bf">一样，我建议使用类似</a><a class="ae kw" href="http://playcode.io/" rel="noopener ugc nofollow" target="_blank"> PlayCode.io </a>的东西跟随这个故事，这样你就可以真正掌握我们经历的一切。</p><p id="592f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个故事中，我们将了解如何使用DOM以及如何使用AJAX异步发出网络请求。我们将从看看DOM实际上是什么开始。</p><h1 id="af83" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">数字正射影像图</h1><p id="0ad4" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">DOM，即文档对象模型，就像它在tin上所说的那样，它获取XML或HTML文档并对其建模。我建模是什么意思？DOM获取所有的元素，并将它们转化为树上的节点。每个节点都是可以操作的对象。例如，一个简单的HTML文件可能如下所示:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="1a2d" class="mj ky iq mf b gy mk ml l mm mn">&lt;!DOCTYPE html&gt;<br/>&lt;html lang="en"&gt;<br/>    &lt;head&gt;<br/>        &lt;meta charset="utf-8" /&gt;<br/>        &lt;title&gt;Hello World&lt;/title&gt;<br/>    &lt;/head&gt;<br/>    &lt;body&gt;<br/>        &lt;h1&gt;Hello World&lt;/h1&gt;<br/>    &lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="d79b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于DOM，它看起来像这样:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="362c" class="mj ky iq mf b gy mk ml l mm mn">Document</span><span id="8d2d" class="mj ky iq mf b gy mo ml l mm mn">Root Element: &lt;html&gt; --- Attribute: lang</span><span id="343a" class="mj ky iq mf b gy mo ml l mm mn">Element: &lt;head&gt;<br/>            Element: &lt;meta&gt; --- Attribute: charset<br/>            Element: &lt;title&gt; --- Text: "Hello World"</span><span id="5120" class="mj ky iq mf b gy mo ml l mm mn">Element: &lt;body&gt;<br/>            Element: &lt;h1&gt; --- Text: "Hello World"</span></pre><p id="a001" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这里，您可以看到我们有多个分支，所有分支都以一个节点结束。您也可以像在Javascript中访问标准对象一样查看树。例如，让我们看看如何用伪代码得到标题文本。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="fd29" class="mj ky iq mf b gy mk ml l mm mn">document.html.head.title.text</span></pre><p id="7404" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里我们从主干开始，或者换句话说，从文档开始。然后我们转到<code class="fe mp mq mr mf b">&lt;html&gt;</code>分支，然后是<code class="fe mp mq mr mf b">&lt;head&gt;</code>分支，然后是<code class="fe mp mq mr mf b">&lt;title&gt;</code>分支，最后我们到达我们要寻找的<code class="fe mp mq mr mf b">text</code>节点。</p><p id="f05f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">DOM很棒，因为它允许我们动态地改变网页的结构、风格和内容。那么我们如何操纵DOM呢？就像在伪代码中一样，<code class="fe mp mq mr mf b">document</code>对象就是我们需求的答案。在我们操作任何东西之前，我们首先需要学习如何访问我们的HTML元素。</p><h1 id="11d4" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">访问DOM</h1><p id="a2e1" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">我们有三种方法来访问DOM中的元素:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="3aa0" class="mj ky iq mf b gy mk ml l mm mn">document.getElementById()<br/>document.getElementByTagName()<br/>document.getElementByClassName()</span></pre><p id="6155" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们从<code class="fe mp mq mr mf b">getElementById()</code>开始，因为这是最简单的，使用这个方法我们可以访问任何具有id属性的HTML元素。例如，如果我们的主体中有以下HTML:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="31d0" class="mj ky iq mf b gy mk ml l mm mn">&lt;div id="container"&gt;&lt;/div&gt;</span></pre><p id="4d65" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以执行以下操作来访问这个div:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="cde7" class="mj ky iq mf b gy mk ml l mm mn">let container = document.getElementById('container');</span></pre><p id="1dd8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里，我们的容器变量现在包含了HTML div的DOM对象。使用<code class="fe mp mq mr mf b">getElementById()</code>方法，您只能访问一个元素，这是因为元素的id必须是唯一的。然而，我们可能不仅仅想要一种元素。我们可能想要访问多个，这是其他两个方法发挥作用的地方。如您所料，<code class="fe mp mq mr mf b">getElementByTagName()</code>通过搜索标签获得元素，<code class="fe mp mq mr mf b">getElementByClassName()</code>通过搜索类获得元素。让我们更新我们的HTML，如下所示:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="7965" class="mj ky iq mf b gy mk ml l mm mn">&lt;ul id="vehiclesList"&gt;<br/>    &lt;li class="land-vehicle"&gt;Car&lt;/li&gt;<br/>    &lt;li class="land-vehicle"&gt;Truck&lt;/li&gt;<br/>    &lt;li class="sky-vehicle"&gt;Plane&lt;/li&gt;<br/>    &lt;li class="sky-vehicle"&gt;Helicopter&lt;/li&gt;<br/>&lt;/ul&gt;</span></pre><p id="fd67" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们想获得列表中的所有项目，那么我们可以使用<code class="fe mp mq mr mf b">getElementByTagName()</code>:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="de9c" class="mj ky iq mf b gy mk ml l mm mn">let listItems = document.getElementsByTagName('li');</span></pre><p id="abdc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们记录<code class="fe mp mq mr mf b">listItems</code>，那么我们会看到它是一个<code class="fe mp mq mr mf b">HTMLCollection</code>对象，这基本上是一个已经找到的HTML元素的数组。如果我们记录<code class="fe mp mq mr mf b">listItems.length</code>,那么我们会看到数组有四个条目，这是我们的四个<code class="fe mp mq mr mf b">&lt;li&gt;</code>元素。</p><p id="a9aa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在假设我们只想要陆地车辆，为此我们将使用<code class="fe mp mq mr mf b">getElementByClassName()</code>:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="3b0b" class="mj ky iq mf b gy mk ml l mm mn">let landVehicles = document.getElementsByClassName('land-vehicle');</span></pre><p id="5421" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们现在记录<code class="fe mp mq mr mf b">landVehicles.length</code>，我们将看到已经找到了两个元素，它们是我们的<code class="fe mp mq mr mf b">&lt;li&gt;</code>元素，具有类<code class="fe mp mq mr mf b">land-vehicle</code>。现在，如果我们将其中一个列表项更改为div，那么我们的数组中仍然会有两个列表项，这是因为<code class="fe mp mq mr mf b">getElementsByClassName()</code>并不关心它找到了什么类型的元素，只要它有这个类。</p><p id="e86a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">很好，我们现在知道了如何访问DOM中的元素，这意味着我们可以开始操作它了。</p><h1 id="2a7c" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">DOM操作</h1><p id="4386" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">在我们开始之前，让我们快速地为<code class="fe mp mq mr mf b">&lt;ul&gt;</code>写一些代码，为了得到所有的<code class="fe mp mq mr mf b">&lt;li&gt;</code>元素，我们将保持HTML不变。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="b470" class="mj ky iq mf b gy mk ml l mm mn">&lt;ul id="vehiclesList"&gt;<br/>    &lt;li class="land-vehicle"&gt;Car&lt;/li&gt;<br/>    &lt;li class="land-vehicle"&gt;Truck&lt;/li&gt;<br/>    &lt;li class="sky-vehicle"&gt;Plane&lt;/li&gt;<br/>    &lt;li class="sky-vehicle"&gt;Helicopter&lt;/li&gt;<br/>&lt;/ul&gt;</span><span id="f38f" class="mj ky iq mf b gy mo ml l mm mn">let vehiclesList = document.getElementById('vehiclesList');<br/>let vehicles = document.getElementsByTagName('li');</span></pre><p id="27e4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们开始说，我们想使所有的车辆大写。为此，我们需要改变<code class="fe mp mq mr mf b">&lt;li&gt;</code>元素的内容。要改变内容，我们可以使用<code class="fe mp mq mr mf b">innerHTML</code>属性。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="9d07" class="mj ky iq mf b gy mk ml l mm mn">let vehiclesList = document.getElementById('vehiclesList');<br/>let vehicles = document.getElementsByTagName('li');</span><span id="22a5" class="mj ky iq mf b gy mo ml l mm mn">for (vehicle of vehicles) {<br/>  vehicle.innerHTML = vehicle.innerHTML.toUpperCase();<br/>}</span></pre><p id="5a1b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里您可以看到,<code class="fe mp mq mr mf b">innerHTML</code>属性可以用来设置和获取元素的内容。如果您运行代码，那么<code class="fe mp mq mr mf b">&lt;li&gt;</code>元素中的所有内容现在都将是大写的。我们现在知道了如何操作内容，所以让我们来看看如何操作样式，让我们把所有的文本都变成红色。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="c233" class="mj ky iq mf b gy mk ml l mm mn">let vehiclesList = document.getElementById('vehiclesList');<br/>let vehicles = document.getElementsByTagName('li');</span><span id="a553" class="mj ky iq mf b gy mo ml l mm mn">for (vehicle of vehicles) {<br/>  vehicle.innerHTML = vehicle.innerHTML.toUpperCase();<br/>  vehicle.style.color = "#FF0000";<br/>}</span></pre><p id="913e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您运行代码，文本将全部为大写和红色。我们可以使用<code class="fe mp mq mr mf b">style</code>属性来改变我们想要的任何CSS值。</p><p id="ce06" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，我们还可以在元素上设置属性。例如，假设我们想把类名都改成相同的。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="820b" class="mj ky iq mf b gy mk ml l mm mn">let vehiclesList = document.getElementById('vehiclesList');<br/>let vehicles = document.getElementsByTagName('li');</span><span id="d1ed" class="mj ky iq mf b gy mo ml l mm mn">for (vehicle of vehicles) {<br/>  vehicle.innerHTML = vehicle.innerHTML.toUpperCase();<br/>  vehicle.style.color = "#FF0000";<br/>  vehicle.setAttribute('class', 'vehicle');<br/>}</span></pre><p id="d936" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了测试这是否可行，让我们添加下面的代码，将所有元素的类<code class="fe mp mq mr mf b">vehicle</code>更改为蓝色。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="4bd1" class="mj ky iq mf b gy mk ml l mm mn">let vehiclesList = document.getElementById('vehiclesList');<br/>let vehicles = document.getElementsByTagName('li');</span><span id="e5c6" class="mj ky iq mf b gy mo ml l mm mn">for (vehicle of vehicles) {<br/>  vehicle.innerHTML = vehicle.innerHTML.toUpperCase();<br/>  vehicle.style.color = "#FF0000";<br/>  vehicle.setAttribute('class', 'vehicle');<br/>}</span><span id="17aa" class="mj ky iq mf b gy mo ml l mm mn">let updatedVehicles = document.getElementsByClassName('vehicle');</span><span id="af46" class="mj ky iq mf b gy mo ml l mm mn">for (vehicle of updatedVehicles) {<br/>  vehicle.style.color = "#0000FF";<br/>}</span></pre><p id="bae0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">太好了，我们所有的内容现在都是蓝色的。我们现在对如何操作HTML元素有了基本的了解。现在让我们更进一步，创建一些元素。</p><h1 id="91fc" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">创建和删除元素</h1><p id="ddeb" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">让我们创建另一个列表，但这次我们将显示颜色而不是车辆。为了创建元素，我们使用了<code class="fe mp mq mr mf b">createElement()</code>方法。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="5c87" class="mj ky iq mf b gy mk ml l mm mn">let vehiclesList = document.getElementById('vehiclesList');<br/>let vehicles = document.getElementsByTagName('li');</span><span id="b629" class="mj ky iq mf b gy mo ml l mm mn">for (vehicle of vehicles) {<br/>  vehicle.innerHTML = vehicle.innerHTML.toUpperCase();<br/>  vehicle.style.color = "#FF0000";<br/>  vehicle.setAttribute('class', 'vehicle');<br/>}</span><span id="ed9b" class="mj ky iq mf b gy mo ml l mm mn">let coloursList = document.createElement('ul');</span></pre><p id="a1a3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里我们已经创建了无序列表，但是它现在对我们没有多大用处，因为它没有内容，所以让我们创建一些列表项。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="87c2" class="mj ky iq mf b gy mk ml l mm mn">let vehiclesList = document.getElementById('vehiclesList');<br/>let vehicles = document.getElementsByTagName('li');</span><span id="3d11" class="mj ky iq mf b gy mo ml l mm mn">for (vehicle of vehicles) {<br/>  vehicle.innerHTML = vehicle.innerHTML.toUpperCase();<br/>  vehicle.style.color = "#FF0000";<br/>  vehicle.setAttribute('class', 'vehicle');<br/>}</span><span id="7b62" class="mj ky iq mf b gy mo ml l mm mn">let coloursList = document.createElement('ul');</span><span id="fceb" class="mj ky iq mf b gy mo ml l mm mn">let redItem = document.createElement('li');<br/>let greenItem = document.createElement('li');<br/>let blueItem = document.createElement('li');</span></pre><p id="21c2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">太好了，我们现在有一些列表项目了。不过，这些对我们来说没什么用，因为它们没有内容，也不在我们的无序列表中。让我们给列表项添加一些内容。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="d386" class="mj ky iq mf b gy mk ml l mm mn">let vehiclesList = document.getElementById('vehiclesList');<br/>let vehicles = document.getElementsByTagName('li');</span><span id="c5bc" class="mj ky iq mf b gy mo ml l mm mn">for (vehicle of vehicles) {<br/>  vehicle.innerHTML = vehicle.innerHTML.toUpperCase();<br/>  vehicle.style.color = "#FF0000";<br/>  vehicle.setAttribute('class', 'vehicle');<br/>}</span><span id="0749" class="mj ky iq mf b gy mo ml l mm mn">let coloursList = document.createElement('ul');</span><span id="f70b" class="mj ky iq mf b gy mo ml l mm mn">let redItem = document.createElement('li');<br/>let greenItem = document.createElement('li');<br/>let blueItem = document.createElement('li');</span><span id="756b" class="mj ky iq mf b gy mo ml l mm mn">redItem.innerHTML = "Red";<br/>greenItem.innerHTML = "Green";<br/>blueItem.innerHTML = "Blue";</span></pre><p id="33ab" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们已经添加了内容，我们需要将列表项添加到无序列表中。为了将一个元素添加到另一个元素中，我们使用了<code class="fe mp mq mr mf b">appendChild()</code>方法。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="92bd" class="mj ky iq mf b gy mk ml l mm mn">let vehiclesList = document.getElementById('vehiclesList');<br/>let vehicles = document.getElementsByTagName('li');</span><span id="d7d7" class="mj ky iq mf b gy mo ml l mm mn">for (vehicle of vehicles) {<br/>  vehicle.innerHTML = vehicle.innerHTML.toUpperCase();<br/>  vehicle.style.color = "#FF0000";<br/>  vehicle.setAttribute('class', 'vehicle');<br/>}</span><span id="6e59" class="mj ky iq mf b gy mo ml l mm mn">let coloursList = document.createElement('ul');</span><span id="0ff9" class="mj ky iq mf b gy mo ml l mm mn">let redItem = document.createElement('li');<br/>let greenItem = document.createElement('li');<br/>let blueItem = document.createElement('li');</span><span id="c0bb" class="mj ky iq mf b gy mo ml l mm mn">redItem.innerHTML = "Red";<br/>greenItem.innerHTML = "Green";<br/>blueItem.innerHTML = "Blue";</span><span id="f3e0" class="mj ky iq mf b gy mo ml l mm mn">coloursList.appendChild(redItem);<br/>coloursList.appendChild(greenItem);<br/>coloursList.appendChild(blueItem);</span></pre><p id="1ad2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">太棒了，我们现在有一个完整的列表，但为什么我们看不到它？我们的列表也需要添加到一个元素中，在我们的例子中是<code class="fe mp mq mr mf b">&lt;body&gt;</code>元素。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="0f94" class="mj ky iq mf b gy mk ml l mm mn">let vehiclesList = document.getElementById('vehiclesList');<br/>let vehicles = document.getElementsByTagName('li');</span><span id="bd89" class="mj ky iq mf b gy mo ml l mm mn">for (vehicle of vehicles) {<br/>  vehicle.innerHTML = vehicle.innerHTML.toUpperCase();<br/>  vehicle.style.color = "#FF0000";<br/>  vehicle.setAttribute('class', 'vehicle');<br/>}</span><span id="af8c" class="mj ky iq mf b gy mo ml l mm mn">let coloursList = document.createElement('ul');</span><span id="1ef1" class="mj ky iq mf b gy mo ml l mm mn">let redItem = document.createElement('li');<br/>let greenItem = document.createElement('li');<br/>let blueItem = document.createElement('li');</span><span id="83a6" class="mj ky iq mf b gy mo ml l mm mn">redItem.innerHTML = "Red";<br/>greenItem.innerHTML = "Green";<br/>blueItem.innerHTML = "Blue";</span><span id="6dce" class="mj ky iq mf b gy mo ml l mm mn">coloursList.appendChild(redItem);<br/>coloursList.appendChild(greenItem);<br/>coloursList.appendChild(blueItem);</span><span id="7049" class="mj ky iq mf b gy mo ml l mm mn">document.getElementsByTagName('body')[0].appendChild(coloursList);</span></pre><p id="a033" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里我们已经将我们的<code class="fe mp mq mr mf b">coloursList</code>添加到了第一个<code class="fe mp mq mr mf b">&lt;body&gt;</code>标签的实例中。如果我们运行代码，那么我们应该看到我们的车辆列表和颜色列表。</p><p id="6eb0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">也许不是两个列表都有，我们想用颜色列表替换我们的车辆列表。要替换元素，我们可以使用<code class="fe mp mq mr mf b">replaceChild(new, old)</code>方法。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="e509" class="mj ky iq mf b gy mk ml l mm mn">let vehiclesList = document.getElementById('vehiclesList');<br/>let vehicles = document.getElementsByTagName('li');</span><span id="dc53" class="mj ky iq mf b gy mo ml l mm mn">for (vehicle of vehicles) {<br/>  vehicle.innerHTML = vehicle.innerHTML.toUpperCase();<br/>  vehicle.style.color = "#FF0000";<br/>  vehicle.setAttribute('class', 'vehicle');<br/>}</span><span id="a131" class="mj ky iq mf b gy mo ml l mm mn">let coloursList = document.createElement('ul');</span><span id="4367" class="mj ky iq mf b gy mo ml l mm mn">let redItem = document.createElement('li');<br/>let greenItem = document.createElement('li');<br/>let blueItem = document.createElement('li');</span><span id="0ac9" class="mj ky iq mf b gy mo ml l mm mn">redItem.innerHTML = "Red";<br/>greenItem.innerHTML = "Green";<br/>blueItem.innerHTML = "Blue";</span><span id="6b1a" class="mj ky iq mf b gy mo ml l mm mn">coloursList.appendChild(redItem);<br/>coloursList.appendChild(greenItem);<br/>coloursList.appendChild(blueItem);</span><span id="a252" class="mj ky iq mf b gy mo ml l mm mn">//document.getElementsByTagName('body')[0].appendChild(coloursList);<br/>document.getElementsByTagName('body')[0].replaceChild(coloursList, vehiclesList);</span></pre><p id="d51a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里我们用<code class="fe mp mq mr mf b">replaceChild()</code>方法替换了<code class="fe mp mq mr mf b">appendChild()</code>方法，如果我们运行这段代码，你将只能看到我们的颜色列表。</p><p id="1f33" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">很好，我们现在可以在DOM中创建和替换元素了。现在让我们来看看我们是如何删除元素的，为此我们使用了<code class="fe mp mq mr mf b">removeChild()</code>方法。让我们从颜色列表中删除<code class="fe mp mq mr mf b">blueItem</code>。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="5f5c" class="mj ky iq mf b gy mk ml l mm mn">let vehiclesList = document.getElementById('vehiclesList');<br/>let vehicles = document.getElementsByTagName('li');</span><span id="66f4" class="mj ky iq mf b gy mo ml l mm mn">for (vehicle of vehicles) {<br/>  vehicle.innerHTML = vehicle.innerHTML.toUpperCase();<br/>  vehicle.style.color = "#FF0000";<br/>  vehicle.setAttribute('class', 'vehicle');<br/>}</span><span id="5cb9" class="mj ky iq mf b gy mo ml l mm mn">let coloursList = document.createElement('ul');</span><span id="b419" class="mj ky iq mf b gy mo ml l mm mn">let redItem = document.createElement('li');<br/>let greenItem = document.createElement('li');<br/>let blueItem = document.createElement('li');</span><span id="cfed" class="mj ky iq mf b gy mo ml l mm mn">redItem.innerHTML = "Red";<br/>greenItem.innerHTML = "Green";<br/>blueItem.innerHTML = "Blue";</span><span id="8982" class="mj ky iq mf b gy mo ml l mm mn">coloursList.appendChild(redItem);<br/>coloursList.appendChild(greenItem);<br/>coloursList.appendChild(blueItem);</span><span id="1865" class="mj ky iq mf b gy mo ml l mm mn">document.getElementsByTagName('body')[0].replaceChild(coloursList, vehiclesList);</span><span id="498b" class="mj ky iq mf b gy mo ml l mm mn">coloursList.removeChild(blueItem);</span></pre><p id="6047" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，如果我们运行这段代码，我们的颜色列表将只包含红色和绿色项目。</p><p id="9629" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好了，我们现在对如何操作DOM有了很好的理解。我们在这里只讨论了基础知识，你还可以用DOM做更多的事情，还有更多的方法和属性可供我们使用，太多了，一个故事讲不完。既然您可以从DOM中更新、创建、添加、替换和删除元素，我建议尝试所有可用的方法和属性，看看哪些有效，哪些无效。我相信实验是深入理解DOM如何工作以及我们可以用它做什么的最好方法。</p><p id="6e51" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好了，让我们来看看Ajax。</p><h1 id="f419" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">创建交互式、快速动态网页应用的网页开发技术</h1><p id="c820" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">首先，什么是AJAX？AJAX是Javascript最伟大的补充之一，创建于1999年(Javascript创建4年后)。AJAX允许我们发出异步网络请求。换句话说，我们可以在页面加载后从服务器请求数据，并更新我们的web页面，而不必重新加载页面。我们还可以在后台向服务器发送数据，而无需重新加载页面。</p><p id="fade" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于AJAX，我们使用了<code class="fe mp mq mr mf b">XMLHttpRequest</code>对象，让我们看看它是如何工作的。我们需要做的第一件事是创建对象的新实例。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="4050" class="mj ky iq mf b gy mk ml l mm mn">let xhr = new XMLHttpRequest();</span></pre><p id="8331" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一旦我们创建了对象的实例，我们就可以打开一个连接，为此，我们使用了<code class="fe mp mq mr mf b">open</code>方法。<code class="fe mp mq mr mf b">open</code>方法有五个参数。这些是方法、url、异步、用户和密码。对于这个故事，我们将只使用前三个参数。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="6ba0" class="mj ky iq mf b gy mk ml l mm mn">let xhr = new XMLHttpRequest();</span><span id="a295" class="mj ky iq mf b gy mo ml l mm mn">xhr.open("GET", "<a class="ae kw" href="https://5cd182d9d4a78300147bec19.mockapi.io/api/users" rel="noopener ugc nofollow" target="_blank">https://5cd182d9d4a78300147bec19.mockapi.io/api/users</a>", true);</span></pre><p id="4ffa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里我们使用的是<code class="fe mp mq mr mf b">GET</code>方法，它只是用来从服务器中检索数据。这个URL是我为这个故事设置的一个模拟API，但是它可以是您想要的任何API URL。最后，我们将async参数设置为<code class="fe mp mq mr mf b">true</code>,以便异步执行请求。</p><p id="a01c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们将使用<code class="fe mp mq mr mf b">onreadystatechange</code>参数，这允许我们检查请求的就绪状态，换句话说就是请求的当前阶段。有五种就绪状态:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="f41e" class="mj ky iq mf b gy mk ml l mm mn">// This is from the official documentation</span><span id="bd70" class="mj ky iq mf b gy mo ml l mm mn">0 - UNSENT - Client has been created. open() not called yet.</span><span id="20ed" class="mj ky iq mf b gy mo ml l mm mn">1 - OPENED - open() has been called.</span><span id="3d02" class="mj ky iq mf b gy mo ml l mm mn">2 - HEADERS_RECEIVED - send() has been called, and headers and status are available</span><span id="70d6" class="mj ky iq mf b gy mo ml l mm mn">3 - LOADING - Downloading; responseText holds partial data.</span><span id="c212" class="mj ky iq mf b gy mo ml l mm mn">4 - DONE - The operation is complete.</span></pre><p id="5de7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将为<code class="fe mp mq mr mf b">onreadystatechange</code>属性设置一个函数，这是我们能够检查状态变化的方式。我们还将通过检查就绪状态4来查看请求是否完成。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="d218" class="mj ky iq mf b gy mk ml l mm mn">let xhr = new XMLHttpRequest();</span><span id="5008" class="mj ky iq mf b gy mo ml l mm mn">xhr.open("GET", "<a class="ae kw" href="https://5cd182d9d4a78300147bec19.mockapi.io/api/users" rel="noopener ugc nofollow" target="_blank">https://5cd182d9d4a78300147bec19.mockapi.io/api/users</a>", true);</span><span id="b855" class="mj ky iq mf b gy mo ml l mm mn">xhr.onreadystatechange = () =&gt; {</span><span id="c4db" class="mj ky iq mf b gy mo ml l mm mn">if (xhr.readyState === 4) {</span><span id="e18d" class="mj ky iq mf b gy mo ml l mm mn">// Our request is done</span><span id="0ab3" class="mj ky iq mf b gy mo ml l mm mn">}</span><span id="b1cc" class="mj ky iq mf b gy mo ml l mm mn">}</span></pre><p id="6ee5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于这个例子，我们不会检查任何其他就绪状态，因为我们只需要知道请求何时完成。现在我们知道请求已经完成，让我们检查请求的HTTP状态。检查HTTP状态允许我们确定请求是否成功。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="9100" class="mj ky iq mf b gy mk ml l mm mn">let xhr = new XMLHttpRequest();</span><span id="661d" class="mj ky iq mf b gy mo ml l mm mn">xhr.open("GET", "<a class="ae kw" href="https://5cd182d9d4a78300147bec19.mockapi.io/api/users" rel="noopener ugc nofollow" target="_blank">https://5cd182d9d4a78300147bec19.mockapi.io/api/users</a>", true);</span><span id="ba06" class="mj ky iq mf b gy mo ml l mm mn">xhr.onreadystatechange = () =&gt; {</span><span id="7994" class="mj ky iq mf b gy mo ml l mm mn">if (xhr.readyState === 4) {</span><span id="523c" class="mj ky iq mf b gy mo ml l mm mn">if (xhr.status === 200) {</span><span id="4714" class="mj ky iq mf b gy mo ml l mm mn">// The request was successful</span><span id="52db" class="mj ky iq mf b gy mo ml l mm mn">} else {</span><span id="4ba1" class="mj ky iq mf b gy mo ml l mm mn">// There was an error</span><span id="7582" class="mj ky iq mf b gy mo ml l mm mn">}</span><span id="36ca" class="mj ky iq mf b gy mo ml l mm mn">}</span><span id="7a3a" class="mj ky iq mf b gy mo ml l mm mn">}</span></pre><p id="31ff" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这里，我们检查状态是否为<code class="fe mp mq mr mf b">200</code>，这意味着一切正常。有相当多的HTTP状态代码可以检查，这里有一个完整的列表。好了，现在我们知道了请求完成的时间，以及它是否成功，现在让我们得到响应，如果有错误，也显示一个错误。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="4472" class="mj ky iq mf b gy mk ml l mm mn">let xhr = new XMLHttpRequest();</span><span id="da3e" class="mj ky iq mf b gy mo ml l mm mn">// Right let's change our endpoint back to users, and have a look at how we access the response.<br/>xhr.open("GET", "<a class="ae kw" href="https://5cd182d9d4a78300147bec19.mockapi.io/api/users" rel="noopener ugc nofollow" target="_blank">https://5cd182d9d4a78300147bec19.mockapi.io/api/users</a>", true);</span><span id="310f" class="mj ky iq mf b gy mo ml l mm mn">xhr.onreadystatechange = () =&gt; {</span><span id="dd55" class="mj ky iq mf b gy mo ml l mm mn">if (xhr.readyState === 4) {</span><span id="6443" class="mj ky iq mf b gy mo ml l mm mn">if (xhr.status === 200) {</span><span id="71b2" class="mj ky iq mf b gy mo ml l mm mn">let response = xhr.responseText;<br/>      response = JSON.parse(response);</span><span id="4f07" class="mj ky iq mf b gy mo ml l mm mn">response.forEach((item) =&gt; {<br/>        console.log(item);<br/>      });</span><span id="38f6" class="mj ky iq mf b gy mo ml l mm mn">} else {</span><span id="941d" class="mj ky iq mf b gy mo ml l mm mn">console.log(`Error with request: ${xhr.status}`);<br/>      console.log(xhr.responseText);</span><span id="7372" class="mj ky iq mf b gy mo ml l mm mn">}</span><span id="35ab" class="mj ky iq mf b gy mo ml l mm mn">}</span><span id="b637" class="mj ky iq mf b gy mo ml l mm mn">}</span></pre><p id="109d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们使用<code class="fe mp mq mr mf b">responseText</code>来获取请求的响应值，在我们的例子中，响应是在JSON中，所以我们也在记录之前解析这些数据。如果有错误，那么我们记录HTTP状态和responseText。</p><p id="e2bb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">只剩下一件事要做，我们现在需要发送请求。为了发送请求，我们使用了<code class="fe mp mq mr mf b">send()</code>方法。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="8775" class="mj ky iq mf b gy mk ml l mm mn">let xhr = new XMLHttpRequest();</span><span id="46e2" class="mj ky iq mf b gy mo ml l mm mn">// Right let's change our endpoint back to users, and have a look at how we access the response.<br/>xhr.open("GET", "<a class="ae kw" href="https://5cd182d9d4a78300147bec19.mockapi.io/api/users" rel="noopener ugc nofollow" target="_blank">https://5cd182d9d4a78300147bec19.mockapi.io/api/users</a>", true);</span><span id="892d" class="mj ky iq mf b gy mo ml l mm mn">xhr.onreadystatechange = () =&gt; {</span><span id="b2b0" class="mj ky iq mf b gy mo ml l mm mn">if (xhr.readyState === 4) {</span><span id="2d80" class="mj ky iq mf b gy mo ml l mm mn">if (xhr.status === 200) {</span><span id="5a63" class="mj ky iq mf b gy mo ml l mm mn">let response = xhr.responseText;<br/>      response = JSON.parse(response);</span><span id="4da9" class="mj ky iq mf b gy mo ml l mm mn">response.forEach((item) =&gt; {<br/>        console.log(item);<br/>      });</span><span id="e5ad" class="mj ky iq mf b gy mo ml l mm mn">} else {</span><span id="a3b3" class="mj ky iq mf b gy mo ml l mm mn">console.log(`Error with request: ${xhr.status}`);<br/>      console.log(xhr.responseText);</span><span id="88d3" class="mj ky iq mf b gy mo ml l mm mn">}</span><span id="d1c1" class="mj ky iq mf b gy mo ml l mm mn">}</span><span id="dfcc" class="mj ky iq mf b gy mo ml l mm mn">}</span><span id="f317" class="mj ky iq mf b gy mo ml l mm mn">xhr.send();</span></pre><p id="eef5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果运行这段代码，应该会看到多个日志显示模拟用户的详细信息。使用Ajax从服务器获取数据就是这么简单，现在让我们修改代码，将数据发送到服务器。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="ba6a" class="mj ky iq mf b gy mk ml l mm mn">let xhr = new XMLHttpRequest();</span><span id="6f74" class="mj ky iq mf b gy mo ml l mm mn">// Right let's change our endpoint back to users, and have a look at how we access the response.<br/>xhr.open("POST", "<a class="ae kw" href="https://5cd182d9d4a78300147bec19.mockapi.io/api/users" rel="noopener ugc nofollow" target="_blank">https://5cd182d9d4a78300147bec19.mockapi.io/api/users</a>", true);</span><span id="7dab" class="mj ky iq mf b gy mo ml l mm mn">xhr.onreadystatechange = () =&gt; {</span><span id="a83b" class="mj ky iq mf b gy mo ml l mm mn">if (xhr.readyState === 4) {</span><span id="5f03" class="mj ky iq mf b gy mo ml l mm mn">if (xhr.status === 200 || xhr.status === 201) {</span><span id="f71e" class="mj ky iq mf b gy mo ml l mm mn">let response = xhr.responseText;<br/>      response = JSON.parse(response);</span><span id="9add" class="mj ky iq mf b gy mo ml l mm mn">console.log(response);</span><span id="9309" class="mj ky iq mf b gy mo ml l mm mn">} else {</span><span id="683b" class="mj ky iq mf b gy mo ml l mm mn">console.log(`Error with request: ${xhr.status}`);<br/>      console.log(xhr.responseText);</span><span id="43f2" class="mj ky iq mf b gy mo ml l mm mn">}</span><span id="19f7" class="mj ky iq mf b gy mo ml l mm mn">}</span><span id="e2fc" class="mj ky iq mf b gy mo ml l mm mn">}</span><span id="a729" class="mj ky iq mf b gy mo ml l mm mn">xhr.setRequestHeader("Content-Type", "application/json");</span><span id="515f" class="mj ky iq mf b gy mo ml l mm mn">let data = {<br/>  name: "John Smith",<br/>  email: "johnsmith@johnsmith.com"<br/>};</span><span id="aa82" class="mj ky iq mf b gy mo ml l mm mn">xhr.send(JSON.stringify(data));</span></pre><p id="c5f3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，我们将<code class="fe mp mq mr mf b">open()</code>方法的方法参数改为<code class="fe mp mq mr mf b">"POST"</code>。接下来，我们将HTTP status <code class="fe mp mq mr mf b">201</code>添加到if语句中，检查请求是否成功。HTTP状态代码<code class="fe mp mq mr mf b">201</code>意味着已经成功创建了一个资源，这在我们的例子中意味着已经创建了一个新用户。在更新状态检查之后，我们移除了<code class="fe mp mq mr mf b">forEach</code>循环，只记录响应，这是因为我知道响应将是单个用户，即我们正在创建的用户。接下来，我们使用<code class="fe mp mq mr mf b">setRequestHeader()</code>方法让服务器知道我们正在发送JSON。设置头部后，我们创建一些要发送的数据，然后将数据作为JSON传递给<code class="fe mp mq mr mf b">send()</code>方法。</p><p id="3f58" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，如果我们运行这段代码，一切都将正常工作，我们将看到一个包含我们创建的新用户的响应。</p><h1 id="4280" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">结论</h1><p id="5856" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">操纵DOM和使用Ajax处理网络请求就是这么简单。现在，您已经了解了开始使用Javascript开发网站和web应用程序所需的一切。随着您更多地使用Javascript，您将对它的工作原理以及您可以用它做什么有更深的理解。就像我经常说的，现在最好的办法是开始尝试。也许试着建立一个待办事项列表或者一个天气应用程序，只要你在建立一些东西并推动你的知识向前发展，你建立什么并不重要。</p></div></div>    
</body>
</html>