<html>
<head>
<title>Road to Go Pro — Async Part 3: Locks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Pro之路—异步第3部分:锁</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/road-to-go-pro-async-part-3-locks-8bf60c476b12?source=collection_archive---------16-----------------------#2022-03-08">https://levelup.gitconnected.com/road-to-go-pro-async-part-3-locks-8bf60c476b12?source=collection_archive---------16-----------------------#2022-03-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="f894" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">在我们开始之前，你可以在这个</em> <a class="ae kp" href="https://github.com/songx23/RoadToGoPro" rel="noopener ugc nofollow" target="_blank"> <em class="ko">资源库</em> </a> <em class="ko">中找到本教程使用的代码。你可以在这里</em>  <em class="ko">找到Road to Go Pro </em> <a class="ae kp" href="https://medium.com/@songx/road-to-go-pro-f9d1f8a51fad" rel="noopener"> <em class="ko">的全部内容。如果你错过了最后一个，你可以通过这个</em> </a><a class="ae kp" rel="noopener ugc nofollow" target="_blank" href="/road-to-go-pro-async-part-2-channels-12645a160f73"> <em class="ko">链接</em> </a> <em class="ko">找到。好吧，我们开始吧。</em></p><p id="18ea" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在前面的故事中，我们了解了Go中的两个异步组件，即goroutine和channel。它们构成了异步流程的基础。在这个故事中，我们将看看在处理异步流程和竞争条件时的常见问题。以及如何通过使用不同类型的锁来解决这些问题。</p><h1 id="5c9f" class="kq kr it bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">竞赛条件</h1><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi lo"><img src="../Images/bf7d8b65e702827deedf2b191540bcd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*D0oUmbxqddADaxLM"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">拉尔夫·布隆伯格在<a class="ae kp" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="097d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们快速回顾一下什么是竞争条件。竞争是指代码试图从不同的goroutines中访问(读/写)一个非线程安全的元素。由于没有明确声明哪个goroutine应该首先访问元素，所以执行的顺序是不确定的。因此，在代码中包含竞争条件可能会导致意想不到的结果，并可能导致系统出现严重故障。因此，我们应该检测竞态条件并尽早解决它们。</p><p id="d380" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">竞争条件的定义很容易理解，但是即使是有经验的工程师也很难发现它们。并发是Go的头等公民，但并不是Go中的所有类型都是线程安全的。幸运的是，Go测试工具有一个内置的竞争检测功能，可以帮助尽早、快速、可靠地发现问题。</p><p id="d702" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们稍后会谈到竞争检测工具，但首先，让我们有目的地创建一个竞争条件。</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="me mf l"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">竞争条件:从两个goroutines写入非线程安全变量</figcaption></figure><p id="17b7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">示例函数想要实现的是将从<code class="fe mg mh mi mj b">x</code>到<code class="fe mg mh mi mj b">y</code>的所有整数相加。为了加速这个过程，我们可以把计算分成几个部分并行运行。在这个具体的例子中，我们对函数进行了硬编码，将计算分成两部分。例如，如果我们使用上面的函数对1到100的所有整数求和，将会有两个goroutines，一个计算1到50的和，另一个计算51到100的和。听起来不错，对吧？然而，当将整数相加时，这两个goroutines更新同一个<code class="fe mg mh mi mj b">sum</code>变量，这不是线程安全的。这就产生了一个竞争条件。让我们使用Go测试工具来证明这一点。</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="me mf l"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">sumUpWithRace函数的单元测试</figcaption></figure><p id="ec52" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们需要首先为目标函数创建一个单元测试。上面的单元测试运行良好，它产生正确的结果:5050。然而，如果我们使用竞争检测工具再次运行单元测试，我们将看到这次测试失败。</p><blockquote class="mk ml mm"><p id="e3dd" class="jq jr ko js b jt ju jv jw jx jy jz ka mn kc kd ke mo kg kh ki mp kk kl km kn im bi translated">这是运行带有竞争条件检测的单元测试的命令。</p></blockquote><pre class="lp lq lr ls gt mq mj mr ms aw mt bi"><span id="44bc" class="mu kr it mj b gy mv mw l mx my">go test -race -run &lt;function_name&gt;</span></pre><p id="d33b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">向测试工具致敬，没有多少语言提供这种现成的功能。</p><p id="0d01" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，是时候探索竞争条件的解决方案之一了，引入锁。</p><h1 id="47bf" class="kq kr it bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated"><strong class="ak">锁</strong></h1><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi mz"><img src="../Images/b1028e8a35f87aa85ac4c9450f3b136f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uKDgF2XxONp9B-PP"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated"><a class="ae kp" href="https://unsplash.com/@flyd2069?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">飞:D </a>在<a class="ae kp" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><p id="3509" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当访问非线程安全的元素时，我们可以使用锁来确保只有一个goroutine可以访问它。这可以防止竞态条件的发生。Go有两种类型的锁结构可从<code class="fe mg mh mi mj b">sync</code>包中获得。他们就是<code class="fe mg mh mi mj b">Mutex</code>和<code class="fe mg mh mi mj b">RWMutex</code>。</p><blockquote class="mk ml mm"><p id="25a3" class="jq jr ko js b jt ju jv jw jx jy jz ka mn kc kd ke mo kg kh ki mp kk kl km kn im bi translated"><code class="fe mg mh mi mj b">Mutex</code>表示互斥。<code class="fe mg mh mi mj b">RW</code>表示读写。</p></blockquote><p id="ffdd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们更深入地了解一下这两种锁的结构。</p><h2 id="3a74" class="mu kr it bd ks na nb dn kw nc nd dp la kb ne nf le kf ng nh li kj ni nj lm nk bi translated"><code class="fe mg mh mi mj b">Mutex</code></h2><p id="6ba5" class="pw-post-body-paragraph jq jr it js b jt nl jv jw jx nm jz ka kb nn kd ke kf no kh ki kj np kl km kn im bi translated">互斥是最简单的锁定机制。它提供了两个功能:<code class="fe mg mh mi mj b">Lock</code>和<code class="fe mg mh mi mj b">Unlock</code>。这两个函数包装的代码块一次只能由一个goroutine执行。</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="me mf l"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">使用互斥来避免竞争情况</figcaption></figure><p id="8c95" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如上所示，向示例代码添加互斥锁很简单。首先要做的是创建一个互斥结构。然后我们可以用它用它的<code class="fe mg mh mi mj b">Lock</code>和<code class="fe mg mh mi mj b">Unlock</code>函数包装并发写逻辑。不要忘记调用<code class="fe mg mh mi mj b">Unlock</code>函数，否则，Go将会死机，因为所有的goroutines都睡着了。您可以使用<code class="fe mg mh mi mj b">defer mux.Unlock()</code>来确保锁被释放。然而，这并不总是释放锁的最佳方式，因为您将失去对何时解锁的细粒度控制。锁定到位后，我们就可以告别比赛条件了。</p><p id="2f6d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们通过再次运行竞争检测测试工具来证明这个理论。不出所料，这次单元测试通过了。</p><pre class="lp lq lr ls gt mq mj mr ms aw mt bi"><span id="9b85" class="mu kr it mj b gy mv mw l mx my">ok      github.com/songx23/RoadToGoPro/Part9    0.135s</span></pre><h2 id="ea7c" class="mu kr it bd ks na nb dn kw nc nd dp la kb ne nf le kf ng nh li kj ni nj lm nk bi translated">RWMutex</h2><p id="abf2" class="pw-post-body-paragraph jq jr it js b jt nl jv jw jx nm jz ka kb nn kd ke kf no kh ki kj np kl km kn im bi translated">读写互斥与互斥略有不同。互斥体只提供一种类型的锁。这个锁只允许一个goroutine执行锁定的代码(不管读还是写)。而RWMutex提供了两种锁。其中一个是和互斥锁一样的锁，姑且称之为“写锁”。另一种是“读锁”。对于写锁，它使用相同的<code class="fe mg mh mi mj b">Lock</code>和<code class="fe mg mh mi mj b">Unlock</code>功能来防止多个并发写。对于读锁，它使用<code class="fe mg mh mi mj b">RLock</code>和<code class="fe mg mh mi mj b">RUnlock</code>函数来防止多个并发读。RWMutex有两种锁的原因是它允许同时读写。它服务于在写入时解除读阻塞的特定目的，也称为“脏读”。这允许更多的并发性，但是如果使用不当，也更容易受到竞争条件的影响。</p><blockquote class="mk ml mm"><p id="36f0" class="jq jr ko js b jt ju jv jw jx jy jz ka mn kc kd ke mo kg kh ki mp kk kl km kn im bi translated">强大的力量伴随着巨大的责任</p></blockquote><p id="d41c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们修改我们的函数来试验RWMutex锁。</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="me mf l"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">竞争条件:对一个非线程安全变量的多个并发读取</figcaption></figure><p id="9e55" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在更新后的函数中，我们有两个不耐烦的检查员，他们想在计算发生时检查<code class="fe mg mh mi mj b">sum</code>值。如果我们用竞争检测工具运行<a class="ae kp" href="https://github.com/songx23/RoadToGoPro/blob/master/Part09-lock/race_test.go#L33-L59" rel="noopener ugc nofollow" target="_blank">单元测试</a>，它将由于“脏读”而失败。是时候利用RWMutex带来的特性了。</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="b421" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">和Mutex一样，我们需要首先初始化一个RWMutex结构。然后，我们可以利用它的四个锁定/解锁功能来启用脏读。就像我们对互斥所做的一样，我们使用RWMutex的<code class="fe mg mh mi mj b">Lock</code>和<code class="fe mg mh mi mj b">Unlock</code>函数来消除并发写的竞争情况。在读取部分，我们使用<code class="fe mg mh mi mj b">RLock</code>和<code class="fe mg mh mi mj b">RUnlock</code>函数来启用脏读取，但防止多个并发读取。在运行同样的<a class="ae kp" href="https://github.com/songx23/RoadToGoPro/blob/master/Part09-lock/lock_test.go#L33-L59" rel="noopener ugc nofollow" target="_blank">测试</a>后，我们可以看到竞态条件没有了。</p><h1 id="bf5e" class="kq kr it bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">下一步是什么？</h1><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi nq"><img src="../Images/585bd742bc36a1817f270bf4a1cd3e2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PYSLIxn_gdf-ggG7"/></div></div></figure><p id="62fb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这篇文章中，我们谈到了Go！中的竞争条件和两种互斥锁。在处理并发性时，无意中编写带有难以检测的竞争条件的代码是非常常见的。谢天谢地，我们有一个方便的工具来发现这种问题，我们也有<code class="fe mg mh mi mj b">sync</code>包来帮助解决竞争条件。不过，给你一个建议，使用RWMutex时要小心。你需要确保它用在正确的地方。</p><p id="55be" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这就结束了我们的Go异步处理主题。在下一篇文章中，我们将探索如何使用Go编写一个简单的API服务器。</p><p id="2ece" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你遇到任何问题或者需要帮助，请在下面留下你的评论。随时欢迎反馈。感谢您的阅读！</p><p id="6b8d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你想支持我，你可以通过这个推荐链接成为一个中等会员。谢谢你。</p><div class="nr ns gp gr nt nu"><a href="https://songx.medium.com/membership" rel="noopener follow" target="_blank"><div class="nv ab fo"><div class="nw ab nx cl cj ny"><h2 class="bd iu gy z fp nz fr fs oa fu fw is bi translated">通过我的推荐链接——宋雪加入Medium</h2><div class="ob l"><h3 class="bd b gy z fp nz fr fs oa fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="oc l"><p class="bd b dl z fp nz fr fs oa fu fw dk translated">songx.medium.com</p></div></div><div class="od l"><div class="oe l of og oh od oi ly nu"/></div></div></a></div></div></div>    
</body>
</html>