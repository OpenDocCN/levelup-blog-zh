<html>
<head>
<title>How To Achieve Lazy Loading</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何实现懒加载</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-achieve-lazy-loading-11ede55ef6b6?source=collection_archive---------8-----------------------#2022-11-29">https://levelup.gitconnected.com/how-to-achieve-lazy-loading-11ede55ef6b6?source=collection_archive---------8-----------------------#2022-11-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c017" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">对于任何包含大量信息的网页来说，延迟加载都是必须的</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/9748e789a044bf5e677ab328b017de90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yIz5Cg4gBDf40RcUx5oKaQ.jpeg"/></div></div></figure><h2 id="284e" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">为什么需要延迟加载</h2><p id="9beb" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">通常当用户打开一个网页时，页面的全部内容将被下载并呈现在一个页面中。虽然允许浏览器缓存页面，但它们不能保证用户会查看所有下载的内容，例如，一个照片墙应用程序，用户可能只是查看第一个图像，然后就离开了，导致内存和带宽的浪费。所以我们只需要在用户需要访问页面的一部分时加载内容，而不是一开始就加载整个内容。</p><h2 id="5423" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">如何实现懒加载</h2><p id="64f2" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">当资源被呈现给网页(图像、视频)时，该资源引用小的占位符，并且当用户查看该页面时，实际的资源被浏览器缓存，并且当该资源在屏幕上可见时，占位符被替换，例如，如果用户加载该页面并立即离开该页面，则除了页面的顶部之外，不加载任何内容。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mg"><img src="../Images/b663dc7e1e000f92dd0ebf9b417a08b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xBmyFiRnNeOyOxQ1-41WMQ.png"/></div></div></figure><h2 id="f54b" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">延迟加载特定实现</h2><p id="90a6" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">以加载一张图片为例，我们需要在<code class="fe mh mi mj mk b">img </code>标签中设置一个<code class="fe mh mi mj mk b">data-src</code>属性，它指向我们实际需要加载的图片，而<code class="fe mh mi mj mk b">img </code>的<code class="fe mh mi mj mk b">src </code>指向一张默认图片，如果是空的，它也会向服务器发送请求。</p><pre class="kg kh ki kj gt ml mk mm bn mn mo bi"><span id="9085" class="mp ks iq mk b be mq mr l ms mt">&lt;img src="default.jpg" data-src="www.example.com/img1.jpg"&gt;</span></pre><p id="6de6" class="pw-post-body-paragraph ln lo iq lp b lq mu jr ls lt mv ju lv la mw lx ly le mx ma mb li my md me mf ij bi translated">稍后，当用户访问可视区域的<code class="fe mh mi mj mk b">img </code>元素时，<code class="fe mh mi mj mk b">src </code>值被替换为由<code class="fe mh mi mj mk b">data-src</code>指向的实际资源加载的图像</p><pre class="kg kh ki kj gt ml mk mm bn mn mo bi"><span id="85e9" class="mp ks iq mk b be mq mr l ms mt">const lazy = (el) =&gt; {<br/> let scrTop = getTop();<br/> let windowHeight = document.documentElement.clientHeight;<br/> function getTop(){<br/>  return document.documentElement.scrollTop || document.body.scrollTop; <br/> }<br/> function getOffset(node){<br/>  return node.getBoundingClientRect().top + scrTop;<br/> }<br/> function inView(node){<br/><br/> const threshold = 0;<br/> const viewTop = scrTop;<br/> const viewBot = viewTop + windowHeight;<br/><br/> const nodeTop = getOffset(node);<br/> const nodeBot = nodeTop + node.offsetHeight;<br/><br/> const offset = (threshold / 100) * windowHeight;<br/> console.log((nodeBot &gt;= viewTop - offset), (nodeTop &lt;= viewBot + offset))<br/>    return (nodeBot &gt;= viewTop - offset) &amp;&amp; (nodeTop &lt;= viewBot + offset)<br/> }<br/> function check(node){<br/>   let el = document.querySelector(node);<br/>   let images = [...el.querySelectorAll('img')];<br/>   images.forEach(img =&gt; {<br/>    if(inView(img)){<br/>     img.src = img.dataset.src;<br/>    }<br/>   })<br/> }<br/> check(el);<br/>}<br/><br/>window.onscroll = function(){<br/> lazy('.foo');<br/>}</span></pre><h2 id="620b" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">现代延迟加载实现方法</h2><p id="a22d" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">通过上面例子的实现，我们需要监听scroll事件来实现懒加载，虽然我们可以通过函数节流的方式来防止函数的高频率执行，但是我们还是需要计算<code class="fe mh mi mj mk b">scrollTop</code>、<code class="fe mh mi mj mk b">offsetHeight </code>等属性，没有简单的方法不需要计算这些属性，答案是肯定的- <code class="fe mh mi mj mk b">IntersectionObserver</code></p><blockquote class="mz na nb"><p id="be12" class="ln lo nc lp b lq mu jr ls lt mv ju lv nd mw lx ly ne mx ma mb nf my md me mf ij bi translated">IntersectionObserver API为开发人员提供了一种异步侦听目标元素的方法，这些目标元素与其祖先或视口处于相交状态。祖先元素和视口称为根。</p></blockquote><p id="bdb7" class="pw-post-body-paragraph ln lo iq lp b lq mu jr ls lt mv ju lv la mw lx ly le mx ma mb li my md me mf ij bi translated">这只是观察一个元素是否与另一个元素重叠的问题。</p><p id="b808" class="pw-post-body-paragraph ln lo iq lp b lq mu jr ls lt mv ju lv la mw lx ly le mx ma mb li my md me mf ij bi translated">IntersectionObserver初始化过程提供了三个主要元素的配置。</p><ol class=""><li id="ede6" class="ng nh iq lp b lq mu lt mv la ni le nj li nk mf nl nm nn no bi translated">root:这是用于观察的根元素。他定义了可观察元素的基本捕获框架。默认情况下，root指向浏览器的viewport，但实际上可以是任何Dom元素，注意:root在这种情况下，要观察的元素必须在root表示的DOM元素内部。</li></ol><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/7a30688025924ee81bd26f6b362bd378.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O26GIINfTgGMVHDpKs92sg.png"/></div></div></figure><p id="fb63" class="pw-post-body-paragraph ln lo iq lp b lq mu jr ls lt mv ju lv la mw lx ly le mx ma mb li my md me mf ij bi translated">2.rootMargin:在计算交集时添加到根边界框的矩形偏移量，可以用来有效地缩小或扩大根判定的范围，以满足计算的需要。选项类似于marginCSS，例如root margin:“50px 20px 10px 40px”(上、右、下、左)</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/52400b8414fc112011ba0227be70f5c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PsaWTRgTOY0JwwAq546ZrQ.png"/></div></div></figure><p id="53ad" class="pw-post-body-paragraph ln lo iq lp b lq mu jr ls lt mv ju lv la mw lx ly le mx ma mb li my md me mf ij bi translated">3.threshold:阈值列表，按升序排序，列表中的每个阈值都是侦听器对象的交集面积与边界面积的比率。当超过侦听器对象的任何阈值时，都会生成通知。如果没有值传递给构造函数，则默认值为0。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/5f48779ed62ea45bbb72f7548e879864.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pAwiI-FjiWFMuPkqiAe32g.png"/></div></div></figure><p id="1046" class="pw-post-body-paragraph ln lo iq lp b lq mu jr ls lt mv ju lv la mw lx ly le mx ma mb li my md me mf ij bi translated">为了告诉intersectionObserver我们想要什么配置，我们只需要将config对象和回调函数一起传递给Observer构造函数。</p><pre class="kg kh ki kj gt ml mk mm bn mn mo bi"><span id="e2b3" class="mp ks iq mk b be mq mr l ms mt">const config = {<br/>    root: null,<br/>    rootMargin: '0px',<br/>    threshold: 0.5<br/>}<br/>let observer = new IntersectionObserver(fucntion(entries){<br/>    // ...<br/>}, config)</span></pre><p id="7067" class="pw-post-body-paragraph ln lo iq lp b lq mu jr ls lt mv ju lv la mw lx ly le mx ma mb li my md me mf ij bi translated">现在我们需要去给<code class="fe mh mi mj mk b">IntersectionObserver </code>实际的元素来观察。</p><pre class="kg kh ki kj gt ml mk mm bn mn mo bi"><span id="167e" class="mp ks iq mk b be mq mr l ms mt">const img = document.querySelector('image');<br/>observer.observe(img);</span></pre><p id="632c" class="pw-post-body-paragraph ln lo iq lp b lq mu jr ls lt mv ju lv la mw lx ly le mx ma mb li my md me mf ij bi translated">关于这个实际观察到的元素，有几点需要注意:</p><ul class=""><li id="1978" class="ng nh iq lp b lq mu lt mv la ni le nj li nk mf ns nm nn no bi translated">首先他应该位于由<code class="fe mh mi mj mk b">root</code>代表的<code class="fe mh mi mj mk b">DOM </code>元素中</li><li id="392f" class="ng nh iq lp b lq nt lt nu la nv le nw li nx mf ns nm nn no bi translated">IntersectionObserver一次只能接受一个观察元素，不支持批量观察。这意味着，如果您需要观察几个元素(例如，一个页面上的几个图像)，您必须遍历所有元素，并分别观察每个元素。</li></ul><pre class="kg kh ki kj gt ml mk mm bn mn mo bi"><span id="c38f" class="mp ks iq mk b be mq mr l ms mt">const images = document.querySelecttorAll('img');<br/>images.forEach(image =&gt; {<br/>    observer.observe(image)<br/>})</span></pre><ul class=""><li id="9525" class="ng nh iq lp b lq mu lt mv la ni le nj li nk mf ns nm nn no bi translated">使用Observer加载页面时，您可能会注意到IntersectionObserver观察到的所有元素都触发了回调。我们可以用回调函数解决这个问题</li></ul><p id="6322" class="pw-post-body-paragraph ln lo iq lp b lq mu jr ls lt mv ju lv la mw lx ly le mx ma mb li my md me mf ij bi translated">IntersectionObserver回调函数</p><pre class="kg kh ki kj gt ml mk mm bn mn mo bi"><span id="5f6d" class="mp ks iq mk b be mq mr l ms mt">new IntersectionObserver(function(entries, self))</span></pre><p id="e226" class="pw-post-body-paragraph ln lo iq lp b lq mu jr ls lt mv ju lv la mw lx ly le mx ma mb li my md me mf ij bi translated">在条目中，我们将回调函数作为特殊类型的数组:<code class="fe mh mi mj mk b">IntersectionObserverEntry </code>首先，<code class="fe mh mi mj mk b">IntersectionObserverEntry </code>包含三个不同矩形的信息。</p><ul class=""><li id="c545" class="ng nh iq lp b lq mu lt mv la ni le nj li nk mf ns nm nn no bi translated">root bounds:capture frame(root+root margin)矩形</li><li id="136e" class="ng nh iq lp b lq nt lt nu la nv le nw li nx mf ns nm nn no bi translated">boundClientRect:观察元素本身的矩形</li><li id="b4dd" class="ng nh iq lp b lq nt lt nu la nv le nw li nx mf ns nm nn no bi translated">intersectionRect:捕获框架和观察元素相交的矩形。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ny"><img src="../Images/25298bfac822d9be4c75bac56fef1ae1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OLaZtWwOzoiO8-cBTqjYKA.png"/></div></div></figure><p id="9121" class="pw-post-body-paragraph ln lo iq lp b lq mu jr ls lt mv ju lv la mw lx ly le mx ma mb li my md me mf ij bi translated">此外，<code class="fe mh mi mj mk b">IntersectionObserverEntry</code>还提供了<code class="fe mh mi mj mk b">isIntersecting</code>，一个方便的属性，返回被观察元素是否与捕获帧相交。<br/>此外，<code class="fe mh mi mj mk b">IntersectionObserverEntry</code>提供了计算上有用的遍历属性<code class="fe mh mi mj mk b">intersctionRatio</code>:返回<code class="fe mh mi mj mk b">intersectionRect </code>与<code class="fe mh mi mj mk b">boundingClientRect</code>的比值。</p><p id="fea2" class="pw-post-body-paragraph ln lo iq lp b lq mu jr ls lt mv ju lv la mw lx ly le mx ma mb li my md me mf ij bi translated">简单介绍之后，让我们回到主题，使用这个IntersectionObserver实现一个现代的惰性加载方法:</p><pre class="kg kh ki kj gt ml mk mm bn mn mo bi"><span id="468f" class="mp ks iq mk b be mq mr l ms mt">const images = document.querySelectorAll('[data-src]')<br/>const config = {<br/>    rootMargin: '0px',<br/>    threshold: 0<br/>};<br/>let observer = new IntersectionObserver((entries, self)=&gt;{<br/>    entries.forEach(entry =&gt; {<br/>        if(entry.isIntersecting){<br/>         // Loading images<br/>         preloadImage(entry.target);<br/>         // Release from observation<br/>           self.unobserve(entry.target)<br/>        }<br/>    })<br/>}， config)<br/><br/>images.forEach(image =&gt; {<br/>  observer.observe(image);<br/>});<br/><br/>function preloadImage(img) {<br/>  const src = img.dataset.src<br/>  if (!src) { return; }<br/>  img.src = src;<br/>}</span></pre><p id="94f7" class="pw-post-body-paragraph ln lo iq lp b lq mu jr ls lt mv ju lv la mw lx ly le mx ma mb li my md me mf ij bi translated">相比以前的懒惰加载方法并不更加简洁，而且只有当观察元素和捕获帧交叉或重叠时，才会触发dropback功能。</p><h2 id="32b2" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">延迟装货的好处</h2><ul class=""><li id="6f3e" class="ng nh iq lp b lq lr lt lu la nz le oa li ob mf ns nm nn no bi translated">延迟加载在优化内容加载和简化最终用户体验之间取得了平衡。</li><li id="0a66" class="ng nh iq lp b lq nt lt nu la nv le nw li nx mf ns nm nn no bi translated">用户可以更快地加载内容，因为他们只需要在第一次打开网站时加载一部分内容。</li><li id="05df" class="ng nh iq lp b lq nt lt nu la nv le nw li nx mf ns nm nn no bi translated">该网站的用户保持率更高，因为不断向用户提供内容减少了他们离开网站的机会。</li><li id="5f9e" class="ng nh iq lp b lq nt lt nu la nv le nw li nx mf ns nm nn no bi translated">网站的资源成本更低，因为内容只在用户需要时才加载，而不是一次加载。</li></ul></div><div class="ab cl oc od hu oe" role="separator"><span class="of bw bk og oh oi"/><span class="of bw bk og oh oi"/><span class="of bw bk og oh"/></div><div class="ij ik il im in"><h1 id="1fb7" class="oj ks iq bd kt ok ol om kw on oo op kz jw oq jx ld jz or ka lh kc os kd ll ot bi translated">分级编码</h1><p id="2e63" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">感谢您成为我们社区的一员！在你离开之前:</p><ul class=""><li id="7e1a" class="ng nh iq lp b lq mu lt mv la ni le nj li nk mf ns nm nn no bi translated">👏为故事鼓掌，跟着作者走👉</li><li id="ebbc" class="ng nh iq lp b lq nt lt nu la nv le nw li nx mf ns nm nn no bi translated">📰查看<a class="ae ou" href="https://levelup.gitconnected.com/?utm_source=pub&amp;utm_medium=post" rel="noopener ugc nofollow" target="_blank">升级编码出版物</a>中的更多内容</li><li id="e4e3" class="ng nh iq lp b lq nt lt nu la nv le nw li nx mf ns nm nn no bi translated">🔔关注我们:<a class="ae ou" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">Twitter</a>|<a class="ae ou" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>|<a class="ae ou" href="https://newsletter.levelup.dev" rel="noopener ugc nofollow" target="_blank">时事通讯</a></li></ul><p id="92b2" class="pw-post-body-paragraph ln lo iq lp b lq mu jr ls lt mv ju lv la mw lx ly le mx ma mb li my md me mf ij bi translated">🚀👉<a class="ae ou" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="lp ir">加入升级人才集体，找到一份神奇的工作</strong> </a></p></div></div>    
</body>
</html>