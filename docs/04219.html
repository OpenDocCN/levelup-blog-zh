<html>
<head>
<title>JavaScript Problem Solvers: Create Target Array</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript问题解决程序:创建目标数组</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-problem-solvers-create-target-array-33cdb61c7a87?source=collection_archive---------13-----------------------#2020-06-15">https://levelup.gitconnected.com/javascript-problem-solvers-create-target-array-33cdb61c7a87?source=collection_archive---------13-----------------------#2020-06-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c0c2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">案例006:坚持目标</h2></div><p id="0103" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">插入算法可能相当复杂。尤其是在处理极大的数据集时，这些数据集会成倍地增加执行解决方案所需的时间和空间复杂性。</p><p id="2b10" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">今天的问题没有什么太复杂的，但仍然提供了一个适度的挑战来测试我们的问题解决技能，并让我们涉足插入算法。</p><p id="6dfe" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以，让我们开始解决。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h2 id="a13a" class="ll lm it bd ln lo lp dn lq lr ls dp lt kr lu lv lw kv lx ly lz kz ma mb mc md bi translated">问题是</h2><p id="9c7e" class="pw-post-body-paragraph ki kj it kk b kl me ju kn ko mf jx kq kr mg kt ku kv mh kx ky kz mi lb lc ld im bi translated"><a class="ae mj" href="https://leetcode.com/problems/create-target-array-in-the-given-order/" rel="noopener ugc nofollow" target="_blank"> <strong class="kk iu">这里是LeetCode </strong> </a>上问题的链接</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="8fab" class="ll lm it mp b gy mt mu l mv mw">Given two arrays of integers <em class="mx">nums</em> and <em class="mx">index</em>. Your task is to create <em class="mx">target</em> array under the following rules:</span><span id="9b24" class="ll lm it mp b gy my mu l mv mw">- Initially <em class="mx">target</em> array is empty.<br/> - From left to right read <em class="mx">nums[i]</em> and <em class="mx">index[i]</em>, insert at index <em class="mx">index[i]</em> the value <em class="mx">nums[i]</em> in <em class="mx">target</em> array.<br/> - Repeat the previous step until there are no elements to read in <em class="mx">nums</em> and <em class="mx">index</em>.<br/> - Return the target array.<br/> - It is guaranteed that the insertion operations will be valid.</span><span id="ea9b" class="ll lm it mp b gy my mu l mv mw">Constraints:<br/>  - 1 &lt;= nums.length, index.length &lt;= 100<br/>  - nums.length == index.length<br/>  - 0 &lt;= nums[i] &lt;= 100<br/>  - 0 &lt;= index[i] &lt;= i</span><span id="ca9c" class="ll lm it mp b gy my mu l mv mw">Test Cases:<br/>nums = [4,2,4,3,2], index = [0,0,1,3,1] =&gt; [2,2,4,4,3]</span><span id="4481" class="ll lm it mp b gy my mu l mv mw">Explanation:<br/>nums index target<br/>4    0     [4]<br/>2    0     [2,4]<br/>4    1     [2,4,4]<br/>3    3     [2,4,4,3]<br/>2    1     [2,2,4,4,3]</span><span id="b0ad" class="ll lm it mp b gy my mu l mv mw">-------------------------</span><span id="36dd" class="ll lm it mp b gy my mu l mv mw">nums = [0,1,2,3,4], index = [0,1,2,2,1] =&gt; [0,4,1,3,2]</span><span id="5275" class="ll lm it mp b gy my mu l mv mw">Explanation:<br/>nums index target<br/>0    0     [0]<br/>1    1     [0,1]<br/>2    2     [0,1,2]<br/>3    2     [0,1,3,2]<br/>4    1     [0,4,1,3,2]</span><span id="bf46" class="ll lm it mp b gy my mu l mv mw">-------------------------</span><span id="3fbd" class="ll lm it mp b gy my mu l mv mw">nums = [1,2,3,4,0], index = [0,1,2,3,0] =&gt; [0,1,2,3,4]</span><span id="355b" class="ll lm it mp b gy my mu l mv mw">Explanation:<br/>nums index target<br/>1    0     [1]<br/>2    1     [1,2]<br/>3    2     [1,2,3]<br/>4    3     [1,2,3,4]<br/>0    0     [0,1,2,3,4]</span><span id="3a0a" class="ll lm it mp b gy my mu l mv mw">nums = [1], index = [0] =&gt; [1]</span><span id="f92d" class="ll lm it mp b gy my mu l mv mw">Explanation:<br/>nums index target<br/>1    0     [1]</span></pre></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h2 id="19ca" class="ll lm it bd ln lo lp dn lq lr ls dp lt kr lu lv lw kv lx ly lz kz ma mb mc md bi translated">崩溃了</h2><p id="bcd8" class="pw-post-body-paragraph ki kj it kk b kl me ju kn ko mf jx kq kr mg kt ku kv mh kx ky kz mi lb lc ld im bi translated">与我们在本系列中试图解决的任何问题一样，让我们首先将问题的解释分解成更小的部分，以确保我们理解我们的任务是解决什么:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="9245" class="ll lm it mp b gy mt mu l mv mw">Given two arrays of integers <em class="mx">nums</em> and <em class="mx">index</em>. Your task is to create <em class="mx">target</em> array under the following rules…</span></pre><p id="990d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">看起来很简单，我们发现的第一件事是我们需要写的<code class="fe mz na nb mp b">function</code>必须接受两个<code class="fe mz na nb mp b">array</code>作为<code class="fe mz na nb mp b">argument</code>，我们还看到我们的<code class="fe mz na nb mp b">function</code>也需要<code class="fe mz na nb mp b">return</code>和<code class="fe mz na nb mp b">array</code>。</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="e3ec" class="ll lm it mp b gy mt mu l mv mw">Initially <em class="mx">target</em> array is empty.</span></pre><p id="693a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这再次确认了我们将返回一个<code class="fe mz na nb mp b">array</code>。再说一次，这看起来很简单，但是确保我们知道自己在做什么总是好的。这也告诉我，我们不想要<code class="fe mz na nb mp b">mutate</code><code class="fe mz na nb mp b">nums</code>或<code class="fe mz na nb mp b">index</code> <code class="fe mz na nb mp b">array</code>。</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="5225" class="ll lm it mp b gy mt mu l mv mw">From left to right read <em class="mx">nums[i]</em> and <em class="mx">index[i</em>], insert at index <em class="mx">index[i]</em> the value <em class="mx">nums[i]</em> in target array.</span></pre><p id="8426" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这里，事情可能开始变得有点混乱，所以让我们试着把事情分解得更细一些:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="c903" class="ll lm it mp b gy mt mu l mv mw">From left to right</span></pre><p id="36f3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这告诉我们应该从头到尾进行迭代。虽然我们在迭代一个<code class="fe mz na nb mp b">array</code>时总是有许多不同的选择，但是手头的任务明确指出我们需要从左向右迭代。虽然这可能会限制一些程序员，但我觉得它有助于给我们一个提示，告诉我们<code class="fe mz na nb mp b">function</code>应该如何操作，并且如果我们将来遇到问题，可以帮助消除对我们解决方案的怀疑。</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="50c9" class="ll lm it mp b gy mt mu l mv mw">read <em class="mx">nums[i]</em> and <em class="mx">index[i]</em></span></pre><p id="201d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里我们得到了关于我们的迭代需要如何操作的另一个线索。我们将同时遍历我们传递给我们的<code class="fe mz na nb mp b">function</code>的两个<code class="fe mz na nb mp b">array</code>。我相信嵌套迭代是不可思议的，所以我们在这里得到的线索有点令人宽慰。</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="a111" class="ll lm it mp b gy mt mu l mv mw">insert at index <em class="mx">index[i]</em> the value <em class="mx">nums[i]</em> in <em class="mx">target</em> array</span></pre><p id="e9d3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这就是告诉我们需要在<code class="fe mz na nb mp b">nums</code> <code class="fe mz na nb mp b">array</code>中给<code class="fe mz na nb mp b">target</code> <code class="fe mz na nb mp b">array</code>加上一个数字。<code class="fe mz na nb mp b">nums</code> <code class="fe mz na nb mp b">array</code>中该数字的<code class="fe mz na nb mp b">index</code>对应<code class="fe mz na nb mp b">index</code> <code class="fe mz na nb mp b">array</code>中某数字的<code class="fe mz na nb mp b">index</code>。它所对应的<code class="fe mz na nb mp b">index</code> <code class="fe mz na nb mp b">array</code>中的数字就是我们要加到<code class="fe mz na nb mp b">target</code> <code class="fe mz na nb mp b">array</code>的地方。</p><p id="f5f0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们的<code class="fe mz na nb mp b">nums</code> <code class="fe mz na nb mp b">array</code>看起来像这样:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="a089" class="ll lm it mp b gy mt mu l mv mw">[1, 3, 2]</span></pre><p id="cbc0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">而我们的<code class="fe mz na nb mp b">index</code> <code class="fe mz na nb mp b">array</code>看起来是这样的:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="7014" class="ll lm it mp b gy mt mu l mv mw">[2, 0, 1]</span></pre><p id="ba14" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们要在第二个<code class="fe mz na nb mp b">index</code>处将数字1插入到<code class="fe mz na nb mp b">target</code>到<code class="fe mz na nb mp b">array</code>中，因为我们的<code class="fe mz na nb mp b">nums</code> <code class="fe mz na nb mp b">array</code>中数字1的<code class="fe mz na nb mp b">index</code>是0，而<code class="fe mz na nb mp b">index</code> <code class="fe mz na nb mp b">array</code>中的数字在<code class="fe mz na nb mp b">index</code>处是2。</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="8de0" class="ll lm it mp b gy mt mu l mv mw">Repeat the previous step until there are no elements to read in <em class="mx">nums</em> and <em class="mx">index</em>.</span></pre><p id="4f39" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们从中获得了更多的信息。这可能感觉有点不必要，而且表面上看起来好像只是说我们需要完整地迭代两个<code class="fe mz na nb mp b">array</code>。</p><p id="f6d4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是我觉得这也告诉我们，我们所有的操作都需要在一个循环中执行。我们不应该在单次迭代的<code class="fe mz na nb mp b">scope</code>之外编写任何类型的额外迭代或re赋值，因为这可能会导致一些不想要的副作用。在这一点上，我可能是错的，但它成为我获得的一些东西，帮助我找到我想出的解决方案。</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="a4f5" class="ll lm it mp b gy mt mu l mv mw">Return the target array.</span></pre><p id="b416" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是相当直截了当的，证实了我之前的建议，我们确实需要<code class="fe mz na nb mp b">return</code>和<code class="fe mz na nb mp b">array</code>。</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="a92d" class="ll lm it mp b gy mt mu l mv mw">It is guaranteed that the insertion operations will be valid.</span></pre><p id="ccd2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这给了我们一个暗示，我们正在处理一个集中在插入算法上的问题。由于这是我们解决方案的一个规则，而不是一个约束，这意味着我们必须确保无论<code class="fe mz na nb mp b">nums</code>或<code class="fe mz na nb mp b">index</code>或<code class="fe mz na nb mp b">array</code>中的数字是什么，我们的算法都需要无误地工作。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h2 id="5d9b" class="ll lm it bd ln lo lp dn lq lr ls dp lt kr lu lv lw kv lx ly lz kz ma mb mc md bi translated">制约因素</h2><p id="576f" class="pw-post-body-paragraph ki kj it kk b kl me ju kn ko mf jx kq kr mg kt ku kv mh kx ky kz mi lb lc ld im bi translated">我们的约束也为我们提供了一些关于如何排除潜在边缘情况的有用信息，理解手头问题的约束与理解上下文同样重要:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="d5eb" class="ll lm it mp b gy mt mu l mv mw">1 &lt;= nums.length, index.length &lt;= 100</span></pre><p id="770b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里我们得到了在<code class="fe mz na nb mp b">nums</code>和<code class="fe mz na nb mp b">index</code> <code class="fe mz na nb mp b">array</code>中有多少个数字的下限和上限。有了<code class="fe mz na nb mp b">1 &lt;= nums.length</code>、<code class="fe mz na nb mp b">index.length</code>的下限总是有用的，因为它告诉我们永远不会遇到空的<code class="fe mz na nb mp b">array</code>。上限为100并不重要，但是它确实使我们能够创建一个测试用例来测试我们的长度为100的解决方案。</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="7dc4" class="ll lm it mp b gy mt mu l mv mw">nums.length == index.length</span></pre><p id="7a85" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这非常重要，因为它告诉我们<code class="fe mz na nb mp b">nums</code>和<code class="fe mz na nb mp b">index</code> <code class="fe mz na nb mp b">array</code>的长度彼此线性相关。这允许我们在同一个<code class="fe mz na nb mp b">for</code>循环中同时遍历两个数组。如果两个<code class="fe mz na nb mp b">array</code>都有基于不同约束的长度，这将导致一个问题。</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="7036" class="ll lm it mp b gy mt mu l mv mw">0 &lt;= nums[i] &lt;= 100</span></pre><p id="8c94" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们应该可以在<code class="fe mz na nb mp b">nums</code>数组中看到从0到100的任何数字。这并不像我们的其他一些约束那样重要，因为我们需要做的就是将<code class="fe mz na nb mp b">nums</code>数组中的数字插入到<code class="fe mz na nb mp b">target</code> <code class="fe mz na nb mp b">array</code>中。</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="fc90" class="ll lm it mp b gy mt mu l mv mw">0 &lt;= index[i] &lt;= i</span></pre><p id="5bc0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是关于<code class="fe mz na nb mp b">nums</code>和<code class="fe mz na nb mp b">array</code>的<code class="fe mz na nb mp b">element</code>或范围的更重要的信息。我们看到<code class="fe mz na nb mp b">index[i]</code>的下限是0，这是意料之中的，因为0是任何<code class="fe mz na nb mp b">array</code>的第一个指数。</p><p id="9535" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有趣的是，我们的上限是<code class="fe mz na nb mp b">i</code>，而不是一个静态的数字。<code class="fe mz na nb mp b">i</code>永远不会大于<code class="fe mz na nb mp b">index</code>T3的长度，因为如果它大于，我们的<code class="fe mz na nb mp b">for</code>循环就会结束。这意味着<code class="fe mz na nb mp b">index</code> <code class="fe mz na nb mp b">array</code>中的数字不会大于<code class="fe mz na nb mp b">index</code> <code class="fe mz na nb mp b">array</code>本身的长度，因此我们的<code class="fe mz na nb mp b">target</code> <code class="fe mz na nb mp b">array</code>的长度永远不会大于<code class="fe mz na nb mp b">index</code> <code class="fe mz na nb mp b">array</code>或<code class="fe mz na nb mp b">nums</code> <code class="fe mz na nb mp b">array</code>。当我们想要在我们的<code class="fe mz na nb mp b">target</code> <code class="fe mz na nb mp b">array</code>末尾添加一个数字时，这将变得非常有用。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h2 id="83fa" class="ll lm it bd ln lo lp dn lq lr ls dp lt kr lu lv lw kv lx ly lz kz ma mb mc md bi translated">边缘案例</h2><p id="8b77" class="pw-post-body-paragraph ki kj it kk b kl me ju kn ko mf jx kq kr mg kt ku kv mh kx ky kz mi lb lc ld im bi translated">这是我在LeetCode上遇到的第一个问题，我们可能需要考虑的每个边缘情况都包含在问题的解释或问题约束中。</p><p id="29e0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于为我们提供的约束，我们不必担心空的或真正大的数字。</p><p id="283f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mz na nb mp b">nums.length == index.length</code>和<code class="fe mz na nb mp b">0 &lt;= index[i] &lt;= i</code>的两个约束消除了如果<code class="fe mz na nb mp b">nums</code>或<code class="fe mz na nb mp b">index</code>具有不同长度时我们可能遇到的任何问题。</p><p id="6ec8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mz na nb mp b">0 &lt;= nums[i] &lt;= 100</code>还推断出我们在<code class="fe mz na nb mp b">nums</code> <code class="fe mz na nb mp b">array</code>中总会有数字，并且去掉了我可能必须为其他primatives编写的一些类型检查。</p><p id="7647" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mz na nb mp b">0 &lt;= index[i] &lt;= i</code>还推断出，既然<code class="fe mz na nb mp b">i</code>是一个数字，那么<code class="fe mz na nb mp b">index</code> <code class="fe mz na nb mp b">array</code>中的任何元素也将是一个数字，并且去掉了一些我们需要简化的类型检查。</p><p id="1e5a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，在彻底检查了提供给我们的所有信息后，我们可以开始思考如何解决这个问题。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h2 id="af0d" class="ll lm it bd ln lo lp dn lq lr ls dp lt kr lu lv lw kv lx ly lz kz ma mb mc md bi translated">嫌疑犯</h2><p id="5abd" class="pw-post-body-paragraph ki kj it kk b kl me ju kn ko mf jx kq kr mg kt ku kv mh kx ky kz mi lb lc ld im bi translated">这个问题的解决方案的提示散布在问题的解释、约束和测试用例中。它们可能不是非常明显，但是在仔细查看了所提供的信息之后，我找到了一个远没有我最初认为的那么复杂的解决方案。</p><p id="fe4b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们需要做的第一件事是定义一个空的<code class="fe mz na nb mp b">array</code>，我们将在其中插入数字，并在<code class="fe mz na nb mp b">function</code>的末尾插入<code class="fe mz na nb mp b">return</code>。姑且称之为<code class="fe mz na nb mp b">target</code>。</p><p id="5681" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于规则<code class="fe mz na nb mp b">Repeat the previous step until there are no elements to read in <em class="mx">nums</em> and <em class="mx">index</em>.</code>，我们将只编写一个<code class="fe mz na nb mp b">for</code>循环。这个<code class="fe mz na nb mp b">for</code>循环将同时遍历<code class="fe mz na nb mp b">nums</code>和<code class="fe mz na nb mp b">index </code>，并使用相同的迭代器。这是因为我们想要从<code class="fe mz na nb mp b">nums</code>插入到<code class="fe mz na nb mp b">target</code>中的数字的索引直接对应于<code class="fe mz na nb mp b">index</code>中的相同索引和数字。</p><p id="9aac" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们的单个<code class="fe mz na nb mp b">for</code>循环将有4个需要考虑的独立条件，因此我们的插入算法满足问题说明中概述的所有要求:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="5497" class="ll lm it mp b gy mt mu l mv mw">1.) A number in the index array is 0</span><span id="e692" class="ll lm it mp b gy my mu l mv mw">2.) A number in the index array is equal to the length of the index array</span><span id="5ab3" class="ll lm it mp b gy my mu l mv mw">3.) There is a number in the target array that is at the index we want to insert a number at (a collision)</span><span id="e790" class="ll lm it mp b gy my mu l mv mw">4.) All other cases</span></pre><p id="336e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们来分解一下我们将如何应对这些情况:</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="480d" class="ll lm it mp b gy mt mu l mv mw">A number in the index array is 0</span></pre><p id="e23b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这意味着我们想在<code class="fe mz na nb mp b">target</code>的开头插入一个数字，这很容易理解。我们将使用<code class="fe mz na nb mp b">unshift</code> ( <code class="fe mz na nb mp b">target.unshift(nums[i])</code>)将从<code class="fe mz na nb mp b">nums</code>到<code class="fe mz na nb mp b">target</code>的数字相加。</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="d611" class="ll lm it mp b gy mt mu l mv mw">A number in the index array is equal to the length of the index array</span></pre><p id="eaf5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这意味着我们想要在<code class="fe mz na nb mp b">target</code>的末尾插入一个数字，类似于我们在<code class="fe mz na nb mp b">target</code>的开头添加一个数字，我们将简单地使用<code class="fe mz na nb mp b">push</code> ( <code class="fe mz na nb mp b">target.push(nums[i])</code>)将<code class="fe mz na nb mp b">nums</code>中的数字添加到<code class="fe mz na nb mp b">target</code>中。</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="513d" class="ll lm it mp b gy mt mu l mv mw">There a number in the target array that is at the index we want to insert a number at (a collision)</span></pre><p id="8af3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是所有情况中最棘手的。如果我们想在某个特定的<code class="fe mz na nb mp b">index</code>处给<code class="fe mz na nb mp b">target</code>添加一个号码，但是那个<code class="fe mz na nb mp b">index</code>处已经有一个号码，我们需要拆分<code class="fe mz na nb mp b">target</code>然后插入该号码。</p><p id="be32" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们需要解决的第一件事是如何检测一个数字是否在当前的<code class="fe mz na nb mp b">index</code>。我们可以通过在我们想要插入(<code class="fe mz na nb mp b">target[index[i]]</code>)的<code class="fe mz na nb mp b">index</code>处测试<code class="fe mz na nb mp b">element</code>的真实性来做到这一点。我们可以单击<code class="fe mz na nb mp b">!target[index[i]]</code>来检查<code class="fe mz na nb mp b">target</code>中的元素是否在我们想要插入的索引处。但是由于<code class="fe mz na nb mp b">!</code>操作符用于检查falsey语句，如果一个元素在索引处，我们的布尔表达式将<code class="fe mz na nb mp b">return</code> <code class="fe mz na nb mp b">false</code>，如果不在索引处，将<code class="fe mz na nb mp b">return</code> <code class="fe mz na nb mp b">true</code>。我们需要反过来，可以用另一个bang ( <code class="fe mz na nb mp b">!!target[index[i]]</code>)来反转布尔表达式。</p><p id="6c94" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果在我们想要插入的<code class="fe mz na nb mp b">index</code>处有一个<code class="fe mz na nb mp b">element</code>，这将<code class="fe mz na nb mp b">return</code> <code class="fe mz na nb mp b">true</code>，如果没有<code class="fe mz na nb mp b">return</code> <code class="fe mz na nb mp b">false</code>。</p><p id="b72d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们得到布尔表达式的结果后，我们将不得不分割并重建<code class="fe mz na nb mp b">target</code>。我们可以通过使用<code class="fe mz na nb mp b">slice</code>和扩展操作符的组合来实现。我们可以<code class="fe mz na nb mp b">slice</code>我们想要在(<code class="fe mz na nb mp b">target.slice(0, index[i])</code>)处插入数字的<code class="fe mz na nb mp b">index</code>之前的所有内容，然后插入数字(<code class="fe mz na nb mp b">nums[i]</code>)，然后切片我们想要在(<code class="fe mz na nb mp b">target.slice(index[i], target[target.length])</code>)处插入数字的<code class="fe mz na nb mp b">index</code>之后的所有内容。</p><p id="4e99" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，由于<code class="fe mz na nb mp b">slice</code>将返回一个<code class="fe mz na nb mp b">array</code> ( <code class="fe mz na nb mp b">[ …target.slice(0, index[i]), nums[i], …target.slice(index[i], target[target.length]) ]</code>)，并且将<code class="fe mz na nb mp b">target</code>重新分配给重建的<code class="fe mz na nb mp b">array</code> ( <code class="fe mz na nb mp b">target = [ …target.slice(0, index[i]), nums[i], …target.slice(index[i], target[target.length]) ]</code>)，因此我们可以对两个<code class="fe mz na nb mp b">slice</code>操作使用扩展运算符来重建<code class="fe mz na nb mp b">target</code>。</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="9b9c" class="ll lm it mp b gy mt mu l mv mw">All other cases</span></pre><p id="e6bb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在所有其他情况下，我们只想在<code class="fe mz na nb mp b">index</code>中相应的<code class="fe mz na nb mp b">index</code>处插入一个来自<code class="fe mz na nb mp b">nums</code>的数字。我们可以通过将<code class="fe mz na nb mp b">target</code> ( <code class="fe mz na nb mp b">target[index[i]</code>)中<code class="fe mz na nb mp b">index</code> ( <code class="fe mz na nb mp b">index[i]</code>)处的<code class="fe mz na nb mp b">element</code>分配给我们想要从<code class="fe mz na nb mp b">nums</code> ( <code class="fe mz na nb mp b">target[index[i] = nums[i]</code>)插入的数字来实现。</p><p id="99e0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我们想要做的就是返回<code class="fe mz na nb mp b">target</code>。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h2 id="1171" class="ll lm it bd ln lo lp dn lq lr ls dp lt kr lu lv lw kv lx ly lz kz ma mb mc md bi translated">伪代码</h2><p id="bd5b" class="pw-post-body-paragraph ki kj it kk b kl me ju kn ko mf jx kq kr mg kt ku kv mh kx ky kz mi lb lc ld im bi translated">由于这个解决方案的工作方式可能很难想象，或者我没有很好地解释它，让我们从不同的角度来看看我们潜在的解决方案，并编写一些伪代码:</p><figure class="mk ml mm mn gt nc"><div class="bz fp l di"><div class="nd ne l"/></div></figure></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h2 id="2a2b" class="ll lm it bd ln lo lp dn lq lr ls dp lt kr lu lv lw kv lx ly lz kz ma mb mc md bi translated">评论</h2><p id="01e9" class="pw-post-body-paragraph ki kj it kk b kl me ju kn ko mf jx kq kr mg kt ku kv mh kx ky kz mi lb lc ld im bi translated">太好了。现在，让我们开始一步一步地编写代码，并以伪代码为基础:</p><p id="5010" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，让我们定义我们的<code class="fe mz na nb mp b">createTargetArray</code> <code class="fe mz na nb mp b">function</code>、我们的<code class="fe mz na nb mp b">target</code> <code class="fe mz na nb mp b">array</code>和我们的<code class="fe mz na nb mp b">return</code>值:</p><figure class="mk ml mm mn gt nc"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="81ff" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，让我们为如何将数字插入<code class="fe mz na nb mp b">target</code>设置条件语句:</p><figure class="mk ml mm mn gt nc"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="8270" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，让我们向条件语句中添加将数字插入到<code class="fe mz na nb mp b">target</code>中的逻辑:</p><figure class="mk ml mm mn gt nc"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="db81" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果一切按计划进行，我们应该通过所有的测试用例:</p><figure class="mk ml mm mn gt nc gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/ced8e23bd974409f439df9af171075d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1236/format:webp/1*ZQTGAl34hHW8iDhSWFVB7A.jpeg"/></div></figure></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h2 id="f7c1" class="ll lm it bd ln lo lp dn lq lr ls dp lt kr lu lv lw kv lx ly lz kz ma mb mc md bi translated">最终解决方案</h2><p id="8eab" class="pw-post-body-paragraph ki kj it kk b kl me ju kn ko mf jx kq kr mg kt ku kv mh kx ky kz mi lb lc ld im bi translated">让我们最后看一下不带注释的解决方案，并清理一些语法:</p><figure class="mk ml mm mn gt nc"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="91b6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">太棒了。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h2 id="ebb8" class="ll lm it bd ln lo lp dn lq lr ls dp lt kr lu lv lw kv lx ly lz kz ma mb mc md bi translated">任务完成</h2><p id="9962" class="pw-post-body-paragraph ki kj it kk b kl me ju kn ko mf jx kq kr mg kt ku kv mh kx ky kz mi lb lc ld im bi translated">我真的很喜欢这个问题，并选择写一篇关于它的博客，因为它不是一个通用的插入算法，并迫使我想出一个有点聪明的方法来正确地将元素插入目标数组。尽管这并不复杂，但我发现这是一个很好的练习。</p><p id="b25d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">再说一次，我写的关于解决LeetCode或HackerRank问题的博客并不是为了找到时间或空间复杂度最低的解决方案。他们关注的是解决问题的步骤。</p><p id="ab91" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我很清楚我的解决方案不会是最好的或最有效的，但不管怎样，我希望它们能帮助你或其他人找到一种方法来解决你在这个旅程中遇到的问题，我们称之为JavaScript。</p><p id="9a13" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">保持安全…保持健康…继续为正义而战。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><div class="mk ml mm mn gt ni"><a href="https://skilled.dev" rel="noopener  ugc nofollow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd iu gy z fp nn fr fs no fu fw is bi translated">编写面试问题</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">一个完整的平台，在这里我会教你找到下一份工作所需的一切，以及…</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">技术开发</p></div></div><div class="nr l"><div class="ns l nt nu nv nr nw ng ni"/></div></div></a></div></div></div>    
</body>
</html>