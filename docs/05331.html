<html>
<head>
<title>Running Go Unit Tests Inside a Docker Container</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Docker容器中运行Go单元测试</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/running-go-unit-tests-inside-a-docker-container-a41ebfcfd854?source=collection_archive---------1-----------------------#2020-08-20">https://levelup.gitconnected.com/running-go-unit-tests-inside-a-docker-container-a41ebfcfd854?source=collection_archive---------1-----------------------#2020-08-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/39dd652f0c4134ef711e07cde29cac57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TiYLRDXAbFD0gYRABUZQ_A.png"/></div></div></figure><p id="9876" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">99%的时候，我可以简单地在本地对我的项目进行单元测试，没有任何问题。然而，偶尔我会遇到这样的情况，我需要安装一些第三方软件来使应用程序正常工作，但我不想在我的笔记本电脑上安装这些软件。由于贵组织的安全规则，您也可能无法在您的笔记本电脑/PC上安装软件。这通常会导致不完整的单元测试，因为我不能完全测试依赖于第三方软件的代码的功能。幸运的是，我们可以在这个场景中使用Docker，并获得完整的单元测试覆盖率。</p><p id="de5b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我们开始之前，这篇文章绝对适用于任何需要在Docker容器中运行测试的语言。然而，在这篇文章中，我们将关注一个<a class="ae kz" href="https://github.com/atkinsonbg/go-goji-templating-pdf-generation" rel="noopener ugc nofollow" target="_blank">围棋项目</a>，我发现自己非常需要这个东西。</p></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><h1 id="a059" class="lh li it bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">设置</h1><p id="b8ce" class="pw-post-body-paragraph kb kc it kd b ke mf kg kh ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky im bi translated">对于这个项目，我通过<code class="fe mk ml mm mn b">http/template</code>包使用Go的模板引擎。我将模板的输出保存为HTML文件，然后将其转换为PDF。为了处理PDF转换，我使用了一个名为<a class="ae kz" href="https://wkhtmltopdf.org/" rel="noopener ugc nofollow" target="_blank"> wkhtmltopdf </a>的开源命令行工具。这是一个非常简单的工具，可以无头运行，这正是我所需要的。这是一个REST API，使用了<a class="ae kz" href="https://github.com/goji/goji" rel="noopener ugc nofollow" target="_blank"> Goji </a>框架，它应该在Docker容器中运行。安装wkhtmltopdf没有问题，你可以在我的Dockerfile文件中看到。</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="adb5" class="mw li it mn b gy mx my l mz na">FROM golang:latest as BUILD</span><span id="a676" class="mw li it mn b gy nb my l mz na">WORKDIR builddir</span><span id="fe19" class="mw li it mn b gy nb my l mz na">COPY . .</span><span id="90df" class="mw li it mn b gy nb my l mz na">RUN CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -ldflags="-s -w" -o go-goji-templating-pdf-generation-api</span><span id="d033" class="mw li it mn b gy nb my l mz na">FROM alpine:3.12.0</span><span id="b6c0" class="mw li it mn b gy nb my l mz na">RUN apk update &amp;&amp; \</span><span id="e2f2" class="mw li it mn b gy nb my l mz na">    apk add xvfb ttf-freefont fontconfig wkhtmltopdf ghostscript</span><span id="ab66" class="mw li it mn b gy nb my l mz na">COPY --from=BUILD ./go/builddir/go-goji-templating-pdf-generation-api .</span><span id="8a74" class="mw li it mn b gy nb my l mz na">ENTRYPOINT ["./go-goji-templating-pdf-generation-api"]</span></pre><p id="2f0c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这很简单，但是让我们打开它。首先，我们执行多阶段构建，使用Golang Docker映像来执行实际构建。接下来，我们使用Alpine容器来保持尽可能小的大小，并安装一些依赖项，其中之一是wkhtmltopdf。CSS渲染和压缩需要其他的包。最后，我们复制上一步的构建，我们就完成了。</p><p id="1474" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用<code class="fe mk ml mm mn b">os/exec</code>包调用wkhtmltopdf非常简单。在这个函数中，我们接受一个指向HTML文件所在位置的路径，以及我们希望PDF输出到的位置。</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="0600" class="mw li it mn b gy mx my l mz na">func ConvertHTMLtoPDF(htmlFilePath string, pdfFilePath string) error {</span><span id="f86e" class="mw li it mn b gy nb my l mz na">    args := []string{htmlFilePath, pdfFilePath}</span><span id="60b2" class="mw li it mn b gy nb my l mz na">    cmd := exec.Command("wkhtmltopdf", args...)</span><span id="ef90" class="mw li it mn b gy nb my l mz na">    err := cmd.Run()</span><span id="a012" class="mw li it mn b gy nb my l mz na">    if err != nil {</span><span id="156e" class="mw li it mn b gy nb my l mz na">        log.Print(err)</span><span id="47fc" class="mw li it mn b gy nb my l mz na">        return err</span><span id="3ef9" class="mw li it mn b gy nb my l mz na">    }</span><span id="07c9" class="mw li it mn b gy nb my l mz na">    return nil</span><span id="5151" class="mw li it mn b gy nb my l mz na">}</span></pre><p id="fb16" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是一个非常简单的函数，非常容易测试。除非运行测试的机器上没有安装wkhtmltopdf！此时，我只有一个选择，通过调用函数并检查错误来运行负测试。您将返回错误“exec: "wkhtmltopdf ":在$PATH中找不到可执行文件”。虽然这提高了您的覆盖率，但它并没有真正测试您的代码。</p></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><h1 id="962c" class="lh li it bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">码头工人来救援了</h1><p id="fcc9" class="pw-post-body-paragraph kb kc it kd b ke mf kg kh ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky im bi translated">为了在Docker中运行我们的单元测试，我们需要创建一个新的容器，其中安装了wkhtmltopdf以及我们未编译的代码。这个docker文件如下所示。</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="ad24" class="mw li it mn b gy mx my l mz na">FROM golang:latest as BUILD</span><span id="5952" class="mw li it mn b gy nb my l mz na">RUN apt-get update &amp;&amp; \</span><span id="e6c9" class="mw li it mn b gy nb my l mz na">    apt-get install -y xvfb wkhtmltopdf ghostscript</span><span id="f3a0" class="mw li it mn b gy nb my l mz na">WORKDIR testdir</span><span id="d82c" class="mw li it mn b gy nb my l mz na">COPY . .</span><span id="bd71" class="mw li it mn b gy nb my l mz na">ENTRYPOINT ["go", "test", "-v", "./...", "-coverprofile", "cover.out"]</span></pre><p id="f4bb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个docker文件比以前精简多了。我们可以使用Golang基本图像，因为我们不太关心运行测试的大小。此外，我们可以安装更少的包，至于单元测试，我不关心CSS渲染，只关心PDF转换。最后，我们将entrypoint作为我们的go test命令，并提供了一个覆盖报告作为衡量标准。我们需要这个文件<code class="fe mk ml mm mn b">Dockerfile.test</code>,因为我们只使用这个文件来运行测试。</p><p id="0df5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们现在可以用下面的命令构建这个容器:</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="ae88" class="mw li it mn b gy mx my l mz na">docker build -t github.com/atkinsonbg/go-goji-templating-pdf-generation/api/tests:latest -f Dockerfile.test .</span></pre><p id="61b8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以使用以下命令运行容器:</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="2ca4" class="mw li it mn b gy mx my l mz na">docker run github.com/atkinsonbg/go-goji-templating-pdf-generation/api/tests:latest</span></pre><p id="5d39" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">运行这个命令会在终端中生成所有测试的输出，我们可以成功地测试wkhtmltopdf，而无需在本地安装它！这在很多层面上都很棒。如果你在一个开发团队中工作，你不必担心本地设置。如果您的组织不允许在本地安装第三方软件，不用担心。如果你像我一样，只是喜欢一台原始的笔记本电脑，那么你就是黄金。如果您的CI/CD管道支持Docker容器，您现在甚至可以通过您的管道进行测试！生活是美好的。</p><p id="06f7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但是等等，我们的报道怎么办！我们正在成功地运行我们的测试，但是我们的覆盖报告在容器里！我们需要把它收回来，这样我们就可以有一个测试覆盖的记录。没问题，我们需要做的就是装载一个卷来获得覆盖报告。我们可以通过使用卷装载更新我们的run命令来做到这一点:</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="4178" class="mw li it mn b gy mx my l mz na">docker run -v ${PWD}:/go/testdir github.com/atkinsonbg/go-goji-templating-pdf-generation/api/tests:latest</span></pre><p id="9bb5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用这个新命令，我们只需将当前工作目录挂载到我们在Dockerfile.test文件中创建的工作目录。万一你错过了，我们在一个Golang容器中操作并使用go mods，所以我们必须在一个非根目录的工作目录中。因此，我们的挂载需要引用根“go”文件夹才能正常工作。</p><p id="2656" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">运行这个新命令将会把覆盖率报告放到我们的repo中。</p><figure class="mo mp mq mr gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nc"><img src="../Images/78bb4dbd4b7abc9f6b1e7dae504ee0fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*svBX2NnZTlDeFcMRzIn5-w.png"/></div></div></figure></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><h1 id="6a5a" class="lh li it bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">包扎</h1><p id="5ef5" class="pw-post-body-paragraph kb kc it kd b ke mf kg kh ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky im bi translated">Docker仍然是我日常发展的重要部分。即使在这个非常简单的例子中，您也可以看到它提供的功能和灵活性。如前所述，这与围棋没有直接联系。如果你在任何开发项目中有这样的需求，Docker都可以为你解决。</p></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><figure class="mo mp mq mr gt ju gh gi paragraph-image"><a href="https://ko-fi.com/O5O63ENS7"><div class="gh gi nd"><img src="../Images/3515ab52cb6fb5e74c27c7a2e06d3811.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*5imNjCtY48Wh3owQyPv6Cw.png"/></div></a></figure></div></div>    
</body>
</html>