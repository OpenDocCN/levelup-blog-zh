<html>
<head>
<title>Refactoring 010 — Extract Method Object</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">重构010 —提取方法对象</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/refactoring-010-extract-method-object-61506f8a2a67?source=collection_archive---------25-----------------------#2022-11-08">https://levelup.gitconnected.com/refactoring-010-extract-method-object-61506f8a2a67?source=collection_archive---------25-----------------------#2022-11-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="58b6" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated"><em class="kf">你有一个大的算法方法。让我们打破它。</em></h2></div><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi kg"><img src="../Images/c380c93b5417d12fd311628bca931130.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kpnwp7VXydSt1OF_pxwBKA.jpeg"/></div></div></figure><blockquote class="ks kt ku"><p id="8ac7" class="kv kw kx ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="iq">TL；DR:长方法不好。移动它们并打破它们。</em></p></blockquote><h1 id="9e17" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">解决的问题</h1><ul class=""><li id="749f" class="mk ml iq ky b kz mm lc mn mo mp mq mr ms mt lr mu mv mw mx bi translated">缺乏可测试性</li><li id="8d80" class="mk ml iq ky b kz my lc mz mo na mq nb ms nc lr mu mv mw mx bi translated">偶然复杂性</li><li id="79a2" class="mk ml iq ky b kz my lc mz mo na mq nb ms nc lr mu mv mw mx bi translated"><a class="ae nd" href="https://mcsee.medium.com/ef812f521a36" rel="noopener">测试私有方法</a></li></ul><h1 id="ebb8" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">相关代码气味</h1><div class="ne nf gp gr ng nh"><a href="https://blog.devgenius.io/code-smell-10-too-many-arguments-b44064610789" rel="noopener  ugc nofollow" target="_blank"><div class="ni ab fo"><div class="nj ab nk cl cj nl"><h2 class="bd ir gy z fp nm fr fs nn fu fw ip bi translated">代码味道10 —参数太多</h2><div class="no l"><h3 class="bd b gy z fp nm fr fs nn fu fw dk translated">对象或函数需要太多的参数才能工作</h3></div><div class="np l"><p class="bd b dl z fp nm fr fs nn fu fw dk translated">blog.devgenius.io</p></div></div><div class="nq l"><div class="nr l ns nt nu nq nv kq nh"/></div></div></a></div><div class="ne nf gp gr ng nh"><a href="https://blog.devgenius.io/code-smell-21-anonymous-functions-abusers-e6f1e3db6a3f" rel="noopener  ugc nofollow" target="_blank"><div class="ni ab fo"><div class="nj ab nk cl cj nl"><h2 class="bd ir gy z fp nm fr fs nn fu fw ip bi translated">代码气味21 —匿名函数滥用者</h2><div class="no l"><h3 class="bd b gy z fp nm fr fs nn fu fw dk translated">函数，lambdas，闭包。所以高阶，非声明，和热。</h3></div><div class="np l"><p class="bd b dl z fp nm fr fs nn fu fw dk translated">blog.devgenius.io</p></div></div><div class="nq l"><div class="nw l ns nt nu nq nv kq nh"/></div></div></a></div><div class="ne nf gp gr ng nh"><a href="https://blog.devgenius.io/code-smell-36-switch-case-elseif-else-if-statements-73f0215abf2b" rel="noopener  ugc nofollow" target="_blank"><div class="ni ab fo"><div class="nj ab nk cl cj nl"><h2 class="bd ir gy z fp nm fr fs nn fu fw ip bi translated">代码气味36 — Switch/case/elseif/else/if语句</h2><div class="no l"><h3 class="bd b gy z fp nm fr fs nn fu fw dk translated">第一节编程课:控制结构。高级开发人员的教训:避免它们。</h3></div><div class="np l"><p class="bd b dl z fp nm fr fs nn fu fw dk translated">blog.devgenius.io</p></div></div><div class="nq l"><div class="nx l ns nt nu nq nv kq nh"/></div></div></a></div><div class="ne nf gp gr ng nh"><a href="https://blog.devgenius.io/code-smell-112-testing-private-methods-ef812f521a36" rel="noopener  ugc nofollow" target="_blank"><div class="ni ab fo"><div class="nj ab nk cl cj nl"><h2 class="bd ir gy z fp nm fr fs nn fu fw ip bi translated">代码气味112 —测试私有方法</h2><div class="no l"><h3 class="bd b gy z fp nm fr fs nn fu fw dk translated">如果你从事单元测试，你迟早会面临这个困境</h3></div><div class="np l"><p class="bd b dl z fp nm fr fs nn fu fw dk translated">blog.devgenius.io</p></div></div><div class="nq l"><div class="ny l ns nt nu nq nv kq nh"/></div></div></a></div><div class="ne nf gp gr ng nh"><a href="https://blog.devgenius.io/code-smell-03-functions-are-too-long-accea7eb4ae9" rel="noopener  ugc nofollow" target="_blank"><div class="ni ab fo"><div class="nj ab nk cl cj nl"><h2 class="bd ir gy z fp nm fr fs nn fu fw ip bi translated">代码气味03 —函数太长</h2><div class="no l"><h3 class="bd b gy z fp nm fr fs nn fu fw dk translated">人类过了10线就烦了。</h3></div><div class="np l"><p class="bd b dl z fp nm fr fs nn fu fw dk translated">blog.devgenius.io</p></div></div><div class="nq l"><div class="nz l ns nt nu nq nv kq nh"/></div></div></a></div><div class="ne nf gp gr ng nh"><a href="https://blog.devgenius.io/code-smell-112-testing-private-methods-ef812f521a36" rel="noopener  ugc nofollow" target="_blank"><div class="ni ab fo"><div class="nj ab nk cl cj nl"><h2 class="bd ir gy z fp nm fr fs nn fu fw ip bi translated">代码气味112 —测试私有方法</h2><div class="no l"><h3 class="bd b gy z fp nm fr fs nn fu fw dk translated">如果你从事单元测试，你迟早会面临这个困境</h3></div><div class="np l"><p class="bd b dl z fp nm fr fs nn fu fw dk translated">blog.devgenius.io</p></div></div><div class="nq l"><div class="ny l ns nt nu nq nv kq nh"/></div></div></a></div><h1 id="6ebf" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">步伐</h1><ol class=""><li id="1000" class="mk ml iq ky b kz mm lc mn mo mp mq mr ms mt lr oa mv mw mx bi translated">创建一个对象来表示方法的调用</li><li id="eb5d" class="mk ml iq ky b kz my lc mz mo na mq nb ms nc lr oa mv mw mx bi translated">将大方法移动到新对象</li><li id="f7bd" class="mk ml iq ky b kz my lc mz mo na mq nb ms nc lr oa mv mw mx bi translated">将方法的临时变量转换为私有属性。</li><li id="802a" class="mk ml iq ky b kz my lc mz mo na mq nb ms nc lr oa mv mw mx bi translated">使用<a class="ae nd" href="https://blog.devgenius.io/refactoring-002-extract-method-1478f421b35a" rel="noopener ugc nofollow" target="_blank">提取方法</a>打破新对象中的大方法</li><li id="5722" class="mk ml iq ky b kz my lc mz mo na mq nb ms nc lr oa mv mw mx bi translated">通过将参数转换为私有属性，从方法调用中移除参数</li></ol><h1 id="24d0" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">示例代码</h1><h2 id="b277" class="ob lt iq bd lu oc od dn ly oe of dp mc mo og oh me mq oi oj mg ms ok ol mi om bi translated">以前</h2><pre class="kh ki kj kk gt on oo op oq aw or bi"><span id="1362" class="ob lt iq oo b gy os ot l ou ov">class BlockchainAccount {<br/>  // ...<br/>  public double balance() {<br/>    string address;    <br/>    // Very long untestable method<br/>  }<br/>}</span></pre><h2 id="d67c" class="ob lt iq bd lu oc od dn ly oe of dp mc mo og oh me mq oi oj mg ms ok ol mi om bi translated">在...之后</h2><pre class="kh ki kj kk gt on oo op oq aw or bi"><span id="ed90" class="ob lt iq oo b gy os ot l ou ov">class BlockchainAccount {<br/>  // ...<br/>  public double balance() {<br/>    return new BalanceCalculator(this).netValue();<br/>  }<br/>}</span><span id="250a" class="ob lt iq oo b gy ow ot l ou ov">// 1. Create an object to represent an invocation of the method<br/>// 2. Move the big method to the new object<br/>// 3. Convert the temporary variables of the method into private attributes.<br/>// 4. Break the big method in the new object by using The Extract Method<br/>// 5. Remove parameters from method invocation by also converting them to private attributes <br/></span><span id="28b7" class="ob lt iq oo b gy ow ot l ou ov">class BalanceCalculator {<br/>  private string address;<br/>  private BlockchainAccount account;</span><span id="cce1" class="ob lt iq oo b gy ow ot l ou ov">  public BalanceCalculator(BlockchainAccount account) {<br/>    this.account = account;<br/>  }</span><span id="72d6" class="ob lt iq oo b gy ow ot l ou ov">  public double netValue() {<br/>    this.findStartingBlock();<br/>    //...<br/>    this computeTransactions();<br/>  }<br/>}</span></pre><h1 id="30ca" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">类型</h1><p id="14f7" class="pw-post-body-paragraph kv kw iq ky b kz mm jr lb lc mn ju le mo ox lh li mq oy ll lm ms oz lp lq lr ij bi translated">[X]半自动</p><p id="53cc" class="pw-post-body-paragraph kv kw iq ky b kz la jr lb lc ld ju le mo lg lh li mq lk ll lm ms lo lp lq lr ij bi translated">一些ide拥有将函数提取到方法对象中的工具。</p><h1 id="87a2" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">安全</h1><p id="262f" class="pw-post-body-paragraph kv kw iq ky b kz mm jr lb lc mn ju le mo ox lh li mq oy ll lm ms oz lp lq lr ij bi translated">这是一个语法和结构的重构。</p><p id="9590" class="pw-post-body-paragraph kv kw iq ky b kz la jr lb lc ld ju le mo lg lh li mq lk ll lm ms lo lp lq lr ij bi translated">我们可以以一种安全的方式自动进行更改。</p><h1 id="8505" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">为什么代码更好？</h1><p id="0e24" class="pw-post-body-paragraph kv kw iq ky b kz mm jr lb lc mn ju le mo ox lh li mq oy ll lm ms oz lp lq lr ij bi translated">我们将逻辑提取到一个新的组件中。</p><p id="92e3" class="pw-post-body-paragraph kv kw iq ky b kz la jr lb lc ld ju le mo lg lh li mq lk ll lm ms lo lp lq lr ij bi translated">我们可以对它进行单元测试、重用、交换等等。</p><h1 id="6233" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">标签</h1><ul class=""><li id="c85c" class="mk ml iq ky b kz mm lc mn mo mp mq mr ms mt lr mu mv mw mx bi translated">膨胀者</li></ul><h1 id="838a" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">相关重构</h1><div class="ne nf gp gr ng nh"><a href="https://blog.devgenius.io/refactoring-002-extract-method-1478f421b35a" rel="noopener  ugc nofollow" target="_blank"><div class="ni ab fo"><div class="nj ab nk cl cj nl"><h2 class="bd ir gy z fp nm fr fs nn fu fw ip bi translated">重构002 —提取方法</h2><div class="no l"><h3 class="bd b gy z fp nm fr fs nn fu fw dk translated">找到一些可以分组并被原子调用的代码片段。</h3></div><div class="np l"><p class="bd b dl z fp nm fr fs nn fu fw dk translated">blog.devgenius.io</p></div></div><div class="nq l"><div class="pa l ns nt nu nq nv kq nh"/></div></div></a></div><h1 id="7cf7" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">请参见</h1><p id="c55f" class="pw-post-body-paragraph kv kw iq ky b kz mm jr lb lc mn ju le mo ox lh li mq oy ll lm ms oz lp lq lr ij bi translated"><a class="ae nd" href="https://en.wikipedia.org/wiki/Strategy_pattern" rel="noopener ugc nofollow" target="_blank">维基百科:战略模式</a></p><p id="cf1a" class="pw-post-body-paragraph kv kw iq ky b kz la jr lb lc ld ju le mo lg lh li mq lk ll lm ms lo lp lq lr ij bi translated"><a class="ae nd" href="https://learning.oreilly.com/library/view/smalltalk-best-practice/9780132852098/ch03.xhtml" rel="noopener ugc nofollow" target="_blank">方法对象定义</a></p><p id="dccd" class="pw-post-body-paragraph kv kw iq ky b kz la jr lb lc ld ju le mo lg lh li mq lk ll lm ms lo lp lq lr ij bi translated"><a class="ae nd" href="https://refactoring.guru/es/replace-method-with-method-object" rel="noopener ugc nofollow" target="_blank"> Refactoring.guru </a></p><p id="5d2f" class="pw-post-body-paragraph kv kw iq ky b kz la jr lb lc ld ju le mo lg lh li mq lk ll lm ms lo lp lq lr ij bi translated"><a class="ae nd" href="https://wiki.c2.com/?MethodObject" rel="noopener ugc nofollow" target="_blank"> C2维基</a></p><h1 id="4d14" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结论</h1><p id="cc65" class="pw-post-body-paragraph kv kw iq ky b kz mm jr lb lc mn ju le mo ox lh li mq oy ll lm ms oz lp lq lr ij bi translated">当我们使用几个提取方法在它们之间传递部分状态作为算法的一部分时，Method-Object是合适的。</p><p id="e90a" class="pw-post-body-paragraph kv kw iq ky b kz la jr lb lc ld ju le mo lg lh li mq lk ll lm ms lo lp lq lr ij bi translated">我们将这些部分计算存储在方法对象内部状态中。</p><p id="64c3" class="pw-post-body-paragraph kv kw iq ky b kz la jr lb lc ld ju le mo lg lh li mq lk ll lm ms lo lp lq lr ij bi translated">方法对象机会的一个强有力的指示器是当计算与宿主方法不紧密相关时。</p><p id="fb9d" class="pw-post-body-paragraph kv kw iq ky b kz la jr lb lc ld ju le mo lg lh li mq lk ll lm ms lo lp lq lr ij bi translated">我们也可以用更多原子的、内聚的和可测试的方法对象具体化匿名函数。</p><h1 id="1238" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">信用</h1><p id="aa46" class="pw-post-body-paragraph kv kw iq ky b kz mm jr lb lc mn ju le mo ox lh li mq oy ll lm ms oz lp lq lr ij bi translated">图片由<a class="ae nd" href="https://pixabay.com/users/mfuente-1590732/" rel="noopener ugc nofollow" target="_blank"> Manuel de la Fuente </a>在<a class="ae nd" href="https://pixabay.com/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>上拍摄</p></div><div class="ab cl pb pc hu pd" role="separator"><span class="pe bw bk pf pg ph"/><span class="pe bw bk pf pg ph"/><span class="pe bw bk pf pg"/></div><div class="ij ik il im in"><p id="5026" class="pw-post-body-paragraph kv kw iq ky b kz la jr lb lc ld ju le mo lg lh li mq lk ll lm ms lo lp lq lr ij bi translated">本文是重构系列的一部分。</p><div class="ne nf gp gr ng nh"><a href="https://mcsee.medium.com/how-to-improve-your-code-with-easy-refactorings-fe80b60e6a8e" rel="noopener follow" target="_blank"><div class="ni ab fo"><div class="nj ab nk cl cj nl"><h2 class="bd ir gy z fp nm fr fs nn fu fw ip bi translated">如何通过简单的重构来改进代码</h2><div class="no l"><h3 class="bd b gy z fp nm fr fs nn fu fw dk translated">重构对于增长和改进我们的代码是惊人的</h3></div><div class="np l"><p class="bd b dl z fp nm fr fs nn fu fw dk translated">mcsee.medium.com</p></div></div><div class="nq l"><div class="pi l ns nt nu nq nv kq nh"/></div></div></a></div></div></div>    
</body>
</html>