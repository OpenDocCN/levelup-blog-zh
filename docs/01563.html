<html>
<head>
<title>Better iOS Apps with Interaction-Driven Design</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">采用交互驱动设计的更好的iOS应用</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/better-ios-apps-with-interaction-driven-design-f9187e745641?source=collection_archive---------6-----------------------#2020-01-13">https://levelup.gitconnected.com/better-ios-apps-with-interaction-driven-design-f9187e745641?source=collection_archive---------6-----------------------#2020-01-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3940" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">构建干净、有组织和可维护的应用程序</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c1de281183318eb5df95e63148d8e1ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sfOs3BDpnYr5YWmxVnvQVg.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">菲利普·斯温伯恩在<a class="ae ky" href="https://unsplash.com/s/photos/wood-craft?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="9772" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我职业生涯的初期，我没有遵循任何真正的方法论来创建iOS应用程序。我非常擅长编写大规模视图控制器和创建<a class="ae ky" href="https://en.wikipedia.org/wiki/Big_ball_of_mud" rel="noopener ugc nofollow" target="_blank">大泥球</a>。</p><p id="2c1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是大约两年前，我开始在我的公司从事交互驱动设计。它改变了我构建软件的方式。它也会为你改变它。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="29be" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">什么是国际直拨电话？</h1><p id="d03a" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">桑德罗·曼库索在<a class="ae ky" href="https://codurance.com/2017/12/08/introducing-idd/" rel="noopener ugc nofollow" target="_blank">这篇文章</a>中介绍了交互驱动设计。下面的定义就是由此而来的:</p><blockquote class="mz"><p id="5b0f" class="na nb it bd nc nd ne nf ng nh ni lu dk translated">IDD是一种基于由外向内开发的软件设计和开发的迭代方法，它关注于根据系统的外部使用对行为进行建模，同时维护内聚业务组件的内部表示。</p></blockquote><p id="adfc" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">IDD是一种方法，在这种方法中，我们在构建系统时始终牢记如何使用它。我们采用由外向内的开发方式。什么是由外向内发展？我们稍后会谈到这一点。现在，让我们继续IDD的定义:</p><blockquote class="mz"><p id="66a0" class="na nb it bd nc nd ne nf ng nh ni lu dk translated">IDD的前提是应用程序的存在应该仅仅是为了满足用户或服务的外部需求——称为参与者。参与者和应用程序之间的每次交互都代表了应用程序必须满足的参与者的需求。IDD的目标是迭代地设计和构建满足这些需求的应用程序。</p></blockquote><p id="6e58" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">一个系统应该满足不同行为者的需求。你可以说这种肯定是显而易见的。如果一个系统不能增加某种价值或满足某人的需求，它就没有意义。但是你会对我们写的代码数量感到惊讶，“因为我们会需要它”。通常那个时刻永远不会到来。</p><p id="eb95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所有那些不必要的工作都不是免费的。它伴随着成本:开发和维护不能满足任何需求的东西的成本。我们必须避免这种情况。</p><p id="1d25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">IDD还关注于以迭代和增量的方式创建系统。这意味着我们应该将功能划分到不同的幻灯片中，一次处理一张幻灯片。这样我们减少了过度工程化，因为我们在给定的时间集中和开发系统的一小部分。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a8b1" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">由外向内发展还是由内向外发展？</h1><p id="cefc" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">有多少次你创建了一个类，一个模块甚至整个系统，试着使用它，却发现因为它不适合你的需求而需要修改？这在我身上发生了无数次。</p><p id="b467" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您首先专注于构建模型时，这可能会发生。您尽最大努力对每个细节进行建模，包括该领域中存在的所有概念和业务规则。你做到了。你做得对。</p><p id="c51e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是接下来就该用这个模型了。您会注意到它与用户界面、用例或持久性存储不太匹配。你需要改变一些东西或者到处添加一个方法。或者甚至模型的某些部分根本没有被使用。</p><p id="28dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是<strong class="lb iu">由内向外发展</strong>。您首先开发领域模型，它的使用方式是将来的事情。这种方法有其优点和缺点。通常这是我们开发软件的方式。</p><p id="59e2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是有一种不同的方式。这种方式叫做<strong class="lb iu">由外向内发展</strong>。使用这种方法，您只需编写足够的代码来满足任何外部需求(来自用户、不同的系统或另一段代码)。</p><p id="fdbb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您减少了推测性的工作，并避免使解决方案变得比需要的更复杂。开发是从用户界面(视图控制器或视图模型)向领域模型(动作、服务或实体)驱动的。</p><p id="5968" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">并且您应该将特性划分成一个个递增的片段，然后一个个地构建它们。</p><p id="1507" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">例如，您从UI中的一些用户交互开始。您创建满足这种交互所需的所有逻辑，仅此而已。这个逻辑包括视图控制器、视图模型、域模型、与外部服务的交互和持久性。当所有的逻辑都完成后，你可以继续下一个用户交互。</p><p id="ef48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想了解更多关于由外向内发展的信息，请查看<a class="ae ky" href="https://codurance.com/2017/10/23/outside-in-design/" rel="noopener ugc nofollow" target="_blank">这篇文章</a>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="47af" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">领域模型</h1><p id="623c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">什么是领域模型？《领域驱动设计的模式、原则和实践》一书将领域模型定义如下:</p><blockquote class="mz"><p id="1801" class="na nb it bd nc nd ne nf ng nh ni lu dk translated">领域模型是一个面向对象的模型，它结合了行为和数据。乍一看，它可能反映了数据持久性模型(如果使用关系数据库，则为数据模式)。尽管两者都包含数据，但是领域模型还包含业务流程和关联、规则以及丰富的领域逻辑。</p></blockquote><p id="c3ab" class="pw-post-body-paragraph kz la it lb b lc nj ju le lf nk jx lh li nl lk ll lm nm lo lp lq nn ls lt lu im bi translated">重点应该放在行为上。我们是在建模行为，而不是数据。以一种完全不知道持久性的方式创建域模型，就像没有数据库一样。数据结构将在以后出现，以满足期望的行为。</p><p id="4490" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">应用程序可以分为三个不同的层，每个层都有自己的职责:</p><ul class=""><li id="fcfe" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu nt nu nv nw bi translated"><strong class="lb iu">交付机制</strong>:一个系统如果不使用就没有意义。这一层表示用户如何呈现和消费系统。在iOS上，这一层依赖于<code class="fe nx ny nz oa b">UIKit</code>或者<code class="fe nx ny nz oa b">SwiftUI</code>。如果你使用MVC或MVVM，所有的视图、控制器和视图模型都属于这一层。该模型不属于交付机制，因为它是领域模型。</li><li id="eca5" class="no np it lb b lc ob lf oc li od lm oe lq of lu nt nu nv nw bi translated"><strong class="lb iu">领域模型</strong>:我们之前定义了什么是领域模型。关于这一点，我想强调两点。首先，领域模型对象不应该依赖于<code class="fe nx ny nz oa b">UIKit</code>或<code class="fe nx ny nz oa b">SwiftUI</code>。这是因为这些框架属于交付机制。第二，<a class="ae ky" href="https://medium.com/better-programming/why-model-objects-shouldnt-implement-swift-s-decodable-or-encodable-protocols-1249cb44d4b3" rel="noopener">域模型对象不应该实现</a> <code class="fe nx ny nz oa b"><a class="ae ky" href="https://medium.com/better-programming/why-model-objects-shouldnt-implement-swift-s-decodable-or-encodable-protocols-1249cb44d4b3" rel="noopener">Decodable</a></code> <a class="ae ky" href="https://medium.com/better-programming/why-model-objects-shouldnt-implement-swift-s-decodable-or-encodable-protocols-1249cb44d4b3" rel="noopener">或者</a> <code class="fe nx ny nz oa b"><a class="ae ky" href="https://medium.com/better-programming/why-model-objects-shouldnt-implement-swift-s-decodable-or-encodable-protocols-1249cb44d4b3" rel="noopener">Encodable</a></code> <a class="ae ky" href="https://medium.com/better-programming/why-model-objects-shouldnt-implement-swift-s-decodable-or-encodable-protocols-1249cb44d4b3" rel="noopener">协议</a>。那些协议属于基础设施。</li><li id="db51" class="no np it lb b lc ob lf oc li od lm oe lq of lu nt nu nv nw bi translated"><strong class="lb iu">基础设施</strong>:这一层提供了支持领域模型和交付机制的技术能力。例如，持久性细节或发出HTTP请求。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/49aeba196b5b96c2a1bace2af61b88f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lZfL63DKGpk0ZRnknHMSIg.png"/></div></div></figure><p id="098d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是域模型内部是什么呢？</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="08b4" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">领域模型构建块</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/9f9795be4dadbb6371bb3df88c352979.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2HnwQqGDkr0C_sqezJchCQ.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@alexjones?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">亚历克斯·琼斯</a>在<a class="ae ky" href="https://unsplash.com/collections/1189854/carpentry?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><p id="531f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">IDD使用不同的构建块来表示领域模型。这些模块基于领域驱动设计(DDD)的<a class="ae ky" href="https://vaadin.com/learn/tutorials/ddd/tactical_domain_driven_design" rel="noopener ugc nofollow" target="_blank">战术模式</a>。</p><p id="ea97" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了解释构建模块，我们将使用一个示例。想象一下像Twitter这样的应用程序，用户可以创建帖子，关注其他用户，并在时间轴上查看他们的帖子。我们可以使用IDD来设计这个应用程序。为了展示构建模块，我们将重点关注创建新帖子的用例。如果你对整个项目感兴趣，你可以在这里找到它。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oi"><img src="../Images/9e28228677ee27e916cce1bc4fbe7fd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8H4gv0PTDjmyQgNPtBYsbw@2x.jpeg"/></div></div></figure><p id="f356" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关于这个例子的一些说明:</p><ul class=""><li id="b66b" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu nt nu nv nw bi translated">该示例摘自<a class="ae ky" href="https://cleancoders.com/video-details/comparativeDesign-episode-15" rel="noopener ugc nofollow" target="_blank">系列视频</a>中创建的应用程序。在那里，桑德罗和鲍勃大叔对不同的TDD学校:伦敦和芝加哥学校做了一个比较案例研究。</li><li id="be4a" class="no np it lb b lc ob lf oc li od lm oe lq of lu nt nu nv nw bi translated">我假设你有一些反应式编程的经验。具体用<code class="fe nx ny nz oa b">RxSwift</code>。</li><li id="1c6d" class="no np it lb b lc ob lf oc li od lm oe lq of lu nt nu nv nw bi translated">几乎每个代码示例都包含一个具有单个类实现的协议。这是为了测试目的。这允许我在单元测试中模拟那个类。</li><li id="bf10" class="no np it lb b lc ob lf oc li od lm oe lq of lu nt nu nv nw bi translated">每个类使用依赖注入接收每个构造函数的协作者。也是为了测试目的。这允许我在单元测试中模仿它的依赖性。</li></ul><p id="d2de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">介绍够了。让我们深入了解构建模块。</p><h1 id="74ee" class="mc md it bd me mf oj mh mi mj ok ml mm jz ol ka mo kc om kd mq kf on kg ms mt bi translated">行动</h1><p id="8fb7" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">它们是领域模型的入口点。动作代表执行特定任务的外部请求。它们代表了系统的行为或用例。</p><p id="9312" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">他们控制某个操作的流程，但不做任何细节。它是不同领域概念的编排者，使它们执行完成操作所需的逻辑。</p><h2 id="a979" class="oo md it bd me op oq dn mi or os dp mm li ot ou mo lm ov ow mq lq ox oy ms oz bi translated">示例:创建帖子</h2><p id="8669" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">为用户创建新帖子的操作的好名字是什么？<code class="fe nx ny nz oa b">CreatePost</code>听起来不错:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pa pb l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">操作:创建帖子</figcaption></figure><p id="e1cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我喜欢我的动作只有一个名为<code class="fe nx ny nz oa b">execute</code>的公共方法来触发行为。</p><p id="5ccd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个动作是做什么的？显然，不多。它接收用户id和文章的文本，并将文章创建委托给<code class="fe nx ny nz oa b">PostService</code>。</p><p id="10d4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就这些吗？是的，就这些。至少在这种情况下。其他动作可能调用不同的服务，相互传递结果。动作应该编排领域概念。注意，这个动作不知道任何关于文章创建的事情。</p><p id="0d0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是为什么要有一个只包装了一个协作者而没有附加行为的类呢？我们能不能不上这门课？不。因为，尽管不包含任何额外的逻辑，这个类代表了系统能做什么。它为演员提供了什么。</p><p id="afa3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个动作还有一个额外的目的。它为消费领域模型提供了一种清晰明了的方式。与领域模型的每一次交互都必须通过一个动作来完成。</p><h1 id="53a3" class="mc md it bd me mf oj mh mi mj ok ml mm jz ol ka mo kc om kd mq kf on kg ms mt bi translated">域服务</h1><p id="b3a8" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">领域服务是领域模型的核心部分。它们代表行为。领域服务是领域概念的切入点。他们没有国籍，没有身份。</p><p id="e373" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它们包含了怎样的逻辑？域服务包含跨给定实体的多个实例的行为。但是它们可以包含不适合任何特定实体或者使用外部服务的逻辑。</p><h2 id="485e" class="oo md it bd me op oq dn mi or os dp mm li ot ou mo lm ov ow mq lq ox oy ms oz bi translated">示例:邮政服务</h2><p id="5f10" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><code class="fe nx ny nz oa b">CreatePost</code>动作将帖子创建委托给了一个<code class="fe nx ny nz oa b">PostService</code>。该服务是帖子领域概念的入口点，包含创建新帖子的业务规则:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pa pb l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">域服务:邮政服务</figcaption></figure><p id="099e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建一个新的职位，这不应该包含任何不适当的语言。如果是这种情况，则发出一个<code class="fe nx ny nz oa b">InappropriateLanguageError</code>信号。否则，帖子被创建，保存在一个<code class="fe nx ny nz oa b">PostRepository</code>中并被返回。</p><p id="7984" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">领域服务可以与其他领域服务协作来完成用例。帖子是否包含不适当语言的决定权被授予a <code class="fe nx ny nz oa b">LanguageService</code>。</p><h1 id="78e6" class="mc md it bd me mf oj mh mi mj ok ml mm jz ol ka mo kc om kd mq kf on kg ms mt bi translated">实体</h1><p id="6ef0" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">实体表示领域概念，在领域模型中具有唯一的身份和连续性。这种唯一的身份允许实体相互区分。只有当两个实体具有相同的标识时，它们才是相等的。</p><p id="6ab1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实体在域中通常有一个生命周期，并且在生命周期中可以发生变异。由于这种独特的身份，我们可以找到一个给定的实体，并改变它。</p><p id="0b9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实体包含什么样的逻辑？实体将包含仅与其内部状态相关的逻辑。</p><h2 id="2d79" class="oo md it bd me op oq dn mi or os dp mm li ot ou mo lm ov ow mq lq ox oy ms oz bi translated">示例:Post</h2><p id="5815" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated"><code class="fe nx ny nz oa b">Post</code>类代表一个帖子。真是个惊喜，对吧？它包含其唯一的身份、其创建者的身份、文本和创建日期。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pa pb l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">实体:帖子</figcaption></figure><p id="2499" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于<code class="fe nx ny nz oa b">Post</code>是可以变异的实体，所以我用了一个<code class="fe nx ny nz oa b">class</code>来表示。但是我默认不使用类来表示实体。通常情况下，我首先选择<code class="fe nx ny nz oa b">struct</code>，因为它具有不可变的特性，只有在有必要改变实体时，我才会选择<code class="fe nx ny nz oa b">class</code>。比起可变对象，我更喜欢不可变对象，但那是另一篇文章的主题。</p><p id="ee3f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，如果两个<code class="fe nx ny nz oa b">Post</code>实例具有相同的<code class="fe nx ny nz oa b">id</code>，则认为它们是相等的。</p><h1 id="3a6a" class="mc md it bd me mf oj mh mi mj ok ml mm jz ol ka mo kc om kd mq kf on kg ms mt bi translated">价值对象</h1><p id="071b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">值对象表示实体的状态。它描述了关于实体或它所拥有的事物的一些东西。值对象表示具有度量、大小或值的特定概念。</p><p id="7edc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">值对象没有标识，如果它们具有相同的值，则被视为相等。</p><p id="0e12" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使值对象不可变是一个好的实践。您应该用所需的值生成一个新的值对象，而不是改变值对象的值。</p><p id="1de6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用实体或值对象表示领域概念的决定取决于上下文。要知道你必须使用哪一个，你必须问下一个问题:<em class="pc">概念应该有自己的身份吗？</em>。如果答案是<em class="pc">是</em>，那么你可能需要一个实体。如果答案是<em class="pc">不，</em>那么就去找一个有价值的对象。但请记住，这个答案取决于上下文:同一个“东西”在某个域中可以有一个身份，但在其他域中没有。</p><h2 id="2402" class="oo md it bd me op oq dn mi or os dp mm li ot ou mo lm ov ow mq lq ox oy ms oz bi translated">示例:PostId</h2><p id="6d87" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这个类代表一篇文章的id。<code class="fe nx ny nz oa b">PostId</code>仅包含使用<code class="fe nx ny nz oa b">UUID</code>的原始表示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pa pb l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">值对象:PostId</figcaption></figure><p id="4668" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于值对象，我总是用一个<code class="fe nx ny nz oa b">struct</code>来表示。值对象和结构一样是不可变的。</p><p id="58b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是<code class="fe nx ny nz oa b">PostId</code>只包装了一个值。为什么我们要有这样一个结构呢？我认为有两个原因:</p><ul class=""><li id="2be1" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu nt nu nv nw bi translated">首先，我们可能决定改变id的表示方式。例如，我们可以决定使用<code class="fe nx ny nz oa b">Int</code>或<code class="fe nx ny nz oa b">String</code>来表示id，而不是<code class="fe nx ny nz oa b">UUID</code>。如果是这种情况，那么变化只影响<code class="fe nx ny nz oa b">PostId</code>类。如果我们直接使用<code class="fe nx ny nz oa b">UUID</code>,我们必须搜索所有的引用并立刻改变它们。相信我，我也经历过。</li><li id="86cb" class="no np it lb b lc ob lf oc li od lm oe lq of lu nt nu nv nw bi translated">第二，避免错误。作为人类，我们都会犯错。如果文章id和用户id都用<code class="fe nx ny nz oa b">UUID</code>表示，那么当需要用户id时，我们可能会错误地使用文章id，反之亦然。如果每个id类型都有自己的类，编译器可以为我们做这个检查。相信我，我也经历过。</li></ul><h1 id="9ba2" class="mc md it bd me mf oj mh mi mj ok ml mm jz ol ka mo kc om kd mq kf on kg ms mt bi translated">仓库</h1><p id="05a9" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">存储库代表一个特定实体的集合，它用于保存和检索该实体的实例。</p><p id="230d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们不应该在不同的域服务之间共享存储库。每个存储库只属于一个域服务。这是因为IDD将存储库视为域服务的助手。</p><p id="71bf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">给定的域服务不应该访问另一个域服务的存储库。这样，我们可以最小化不同领域概念之间的耦合。</p><p id="5af4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">持久性依赖于不能在域模型中使用的基础设施。因此，存储库接口属于领域模型，而它们的实现属于基础设施。</p><h2 id="28fd" class="oo md it bd me op oq dn mi or os dp mm li ot ou mo lm ov ow mq lq ox oy ms oz bi translated">示例:发布存储库</h2><p id="24bf" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">帖子创建后，这个帖子需要在某个地方持久化。我们需要一个<code class="fe nx ny nz oa b">PostRepository</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pa pb l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">存储库:后存储库</figcaption></figure><p id="37e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如前所述，只有存储库的接口属于域模型。注意<code class="fe nx ny nz oa b">PostRepository</code>是那个接口。到目前为止，它只是提供了一个向存储库中添加<code class="fe nx ny nz oa b">Post</code>的方法。</p><p id="4397" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">存储库的实现驻留在基础设施中。请注意，使用协议使我们能够使用任何类型的持久性存储。这可能是内存、用户默认值、文件、数据库或远程API。</p><p id="e048" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，选择的持久性存储是内存。所以这个实现叫做<code class="fe nx ny nz oa b">InMemoryPostRepository</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pa pb l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">存储库:InMemoryPostRepository</figcaption></figure><h1 id="76d6" class="mc md it bd me mf oj mh mi mj ok ml mm jz ol ka mo kc om kd mq kf on kg ms mt bi translated">基础设施服务</h1><p id="ef62" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">它们是一种特殊类型的服务。它们代表了对领域很重要的概念，比如领域服务。但是由于它们的实现，它们不能在域模型中。</p><p id="2200" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像存储库一样，它们的接口属于领域模型，它们的实现属于基础设施。</p><h2 id="7083" class="oo md it bd me op oq dn mi or os dp mm li ot ou mo lm ov ow mq lq ox oy ms oz bi translated">示例:语言服务</h2><p id="7e8b" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们需要知道我们是否试图用不恰当的词语来创建一个帖子。一个<code class="fe nx ny nz oa b">LanguageService</code>可以为我们做这个检查。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pa pb l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">基础设施服务:语言服务</figcaption></figure><p id="033e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于这个例子，被认为不合适的单词被存储在一个名为<code class="fe nx ny nz oa b">inappropriate_words.plist</code>的文件中。因此，我们需要将该文件的内容读入一个单词数组，并检查帖子中是否包含这些不合适的单词。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="pa pb l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">基础结构服务:文件语言服务</figcaption></figure><p id="5fcc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个实现叫做<code class="fe nx ny nz oa b">FileLanguageService</code>。由于对文件的访问是基础设施的事情，所以这种实现不能在域模型中。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="d513" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">交付机制呢？</h1><p id="69c3" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">IDD没有为交付机制定义构件。</p><p id="84a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">交付机制取决于您选择如何交付应用程序。它可能是使用<code class="fe nx ny nz oa b">UIKit</code>或<code class="fe nx ny nz oa b">SwiftUI</code>的iOS应用程序、Android应用程序或通过REST API使用的服务器。在任何情况下，您都可以在整个应用程序和领域模型的构建块中应用IDD的概念。</p><p id="d331" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于iOS开发，我喜欢和MVVM一起工作。我使用的构建模块是<strong class="lb iu">视图模型</strong>、<strong class="lb iu">视图控制器</strong>、<strong class="lb iu">视图、</strong>和<strong class="lb iu">协调器</strong>。</p><p id="46d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我不会在这篇文章中解释这些构建模块。<a class="ae ky" href="https://engineering.etermax.com/dealing-with-massive-view-models-using-mvvm-on-ios-74b2697557ce" rel="noopener ugc nofollow" target="_blank">我还有另外一个岗位在做</a>。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="cdf8" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">最后的想法</h1><p id="d3b8" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我向你们展示了交互驱动设计的概念。这种方法关注系统的行为，关注它将如何被使用或消费。它提出了一种为应用程序的不同区域定义边界的方法。它还提供了一系列构建模块来创建我们的领域模型，每个模块都有自己的职责。</p><p id="3ab1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">IDD最适用于您有丰富的领域要建模的应用程序，有许多不同的业务概念和规则。</p><p id="4c77" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是我通常用来开发软件的方法。我对结果很满意。现在我创造了更好的软件，更有条理，更干净，更容易维护。</p><p id="e59f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">试试看。</p><p id="3f8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢您的阅读！😄</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7344" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">链接和参考</h1><p id="52ee" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">您可以在这里找到<a class="ae ky" href="https://github.com/pmanuelli/social-networking" rel="noopener ugc nofollow" target="_blank">所用示例的完整项目。</a></p><div class="pd pe gp gr pf pg"><a href="https://github.com/pmanuelli/social-networking" rel="noopener  ugc nofollow" target="_blank"><div class="ph ab fo"><div class="pi ab pj cl cj pk"><h2 class="bd iu gy z fp pl fr fs pm fu fw is bi translated">pmanuelli/社交网络</h2><div class="pn l"><p class="bd b dl z fp pl fr fs pm fu fw dk translated">github.com</p></div></div><div class="po l"><div class="pp l pq pr ps po pt ks pg"/></div></div></a></div><p id="57e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">免责声明:项目中的代码可能与这里给出的不同。我还在研究，用它来练习不同的题目。</p><p id="b8e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你对桑德罗·曼库索和鲍勃大叔创造的解决方案感兴趣，你可以在这里找到它。从服务器的角度来看，它是用Java实现的。</p><div class="pd pe gp gr pf pg"><a href="https://github.com/sandromancuso/cleancoders_openchat/tree/openchat-outside-in" rel="noopener  ugc nofollow" target="_blank"><div class="ph ab fo"><div class="pi ab pj cl cj pk"><h2 class="bd iu gy z fp pl fr fs pm fu fw is bi translated">sandromancuso/clean coders _ open chat</h2><div class="pn l"><p class="bd b dl z fp pl fr fs pm fu fw dk translated">github.com</p></div></div><div class="po l"><div class="pu l pq pr ps po pt ks pg"/></div></div></a></div><p id="c6c9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，一些参考用来创建这个职位:</p><ul class=""><li id="8b02" class="no np it lb b lc ld lf lg li nq lm nr lq ns lu nt nu nv nw bi translated"><strong class="lb iu">引入交互驱动设计:</strong><a class="ae ky" href="https://codurance.com/2017/12/08/introducing-idd/" rel="noopener ugc nofollow" target="_blank">https://codurance.com/2017/12/08/introducing-idd/</a></li><li id="fe28" class="no np it lb b lc ob lf oc li od lm oe lq of lu nt nu nv nw bi translated"><strong class="lb iu">由外向内发展的一个案例:【https://codurance.com/2017/10/23/outside-in-design/】T22</strong></li><li id="5a0a" class="no np it lb b lc ob lf oc li od lm oe lq of lu nt nu nv nw bi translated"><strong class="lb iu">精心设计:</strong><a class="ae ky" href="https://jaxenter.com/crafted-design-an-introduction-to-interaction-driven-design-117563.html" rel="noopener ugc nofollow" target="_blank">https://jax enter . com/Crafted-Design-an-introduction-to-interaction-driven-Design-117563 . html</a></li></ul></div></div>    
</body>
</html>