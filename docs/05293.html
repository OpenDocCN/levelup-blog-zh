<html>
<head>
<title>Breadth-First Search (BFS) Guide — Examples, Java Code, and Coding Interview Tips</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">广度优先搜索(BFS)指南—示例、Java代码和编码面试技巧</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/breadth-first-search-bfs-guide-examples-java-code-and-coding-interview-tips-ce18adaf763?source=collection_archive---------12-----------------------#2020-08-17">https://levelup.gitconnected.com/breadth-first-search-bfs-guide-examples-java-code-and-coding-interview-tips-ce18adaf763?source=collection_archive---------12-----------------------#2020-08-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="2967" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">广度优先搜索，或称BFS，是我对编码面试必须知道的算法之一。本文将介绍什么是BFS，向您展示如何用Java编写BFS，并浏览一些BFS的编码面试技巧。有关如何在各种输入上运行算法的示例以及Java代码的逐行解释，请参阅我的3部分视频系列:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="kr ks l"/></div></figure><p id="038b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果这篇文章有帮助，请考虑<a class="ae kl" href="http://bit.ly/sub2rahul" rel="noopener ugc nofollow" target="_blank">订阅我的YouTube频道</a>或者<a class="ae kl" href="https://medium.com/@rahulsabnis19" rel="noopener">在媒体</a>上关注我以获得更多类似的内容！</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi kt"><img src="../Images/a6a50bd4e6d548680cf2381916b8b13f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fZk55Dc_4c0evbVf0uDrGQ.jpeg"/></div></div></figure><h1 id="879d" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">BFS解释道</h1><p id="bd6e" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">为了清楚起见，我将在本文中交替使用顶点和节点这两个术语。它们的意思是一样的。顶点通过边相互连接，形成一个类似图形的结构。</p><p id="cc74" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">广度优先搜索是一种算法，允许您在未加权的图中找到一个顶点和另一个顶点之间的最短路径。未加权意味着从图中的任何一个节点到另一个节点的成本与任何其他节点对的成本相同。如果我们有一个带权的图，BFS仍然可以用来寻找从一个顶点到另一个顶点是否存在路径。</p><p id="7b33" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">BFS的工作方式如下:</p><ol class=""><li id="150b" class="md me iq jp b jq jr ju jv jy mf kc mg kg mh kk mi mj mk ml bi translated">检查起始节点是否是我们的目的地。如果是这样，我们已经找到了一条路。如果不是，继续第2步，其中n等于1。n等于到我们所看到的起始节点的距离。</li><li id="a1a9" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated">检查距离起始节点n远的所有节点。如果我们在这个集合中找到了目的地，我们就找到了一条路径。如果没有，将这些节点标记为已访问(以确保我们不会重新访问这些节点)，并在距离起始节点n+1的未访问节点上重复步骤2。如果不再存在未访问的节点，请继续执行步骤3。</li><li id="67ad" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated">图中的起始节点和目的节点之间没有路径。</li></ol><p id="fc71" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">BFS的时间复杂度为O(|V| + |E|)。|V|是顶点集的基数，或者换句话说，是顶点的数量。|E|是边集的基数，或者换句话说，是边的数量。这是因为在最坏的情况下，BFS会要求你访问每一个顶点和每一条边。</p><h1 id="d20e" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">BFS Java代码</h1><p id="8378" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">下面是如何用Java实现BFS:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mr ks l"/></div></figure><h1 id="b65e" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">编码访谈中的BFS</h1><p id="7f69" class="pw-post-body-paragraph jn jo iq jp b jq ly js jt ju lz jw jx jy ma ka kb kc mb ke kf kg mc ki kj kk ij bi translated">什么时候应该考虑在面试中使用BFS:</p><ol class=""><li id="ce71" class="md me iq jp b jq jr ju jv jy mf kc mg kg mh kk mi mj mk ml bi translated">您需要在任何类似图形的结构中找到从一个顶点到另一个顶点的路径(尤其是那些离起始节点更近的)。还要注意，图形可以有多种形式(例如，树是一种类似图形的结构，因为它们由边连接的顶点组成)。</li><li id="f169" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated">你需要在任何未加权的图中找到从一个顶点到另一个顶点的最短路径。</li></ol><p id="87c3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当您不应该考虑使用BFS时:</p><ol class=""><li id="7d0b" class="md me iq jp b jq jr ju jv jy mf kc mg kg mh kk mi mj mk ml bi translated">你需要找到一个在你的图形深处的节点(它和起始节点之间的距离很大)。</li></ol><p id="3937" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些只是需要考虑的一些重要情况，但是除此之外，了解其他图搜索算法也很重要。其中包括深度优先搜索(DFS)，Djikstra的算法，等等。当您了解BFS的替代方案时，您可以更好地决定哪一个适合手头的问题。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ms"><img src="../Images/25e072ee408f593f661a878953a0210b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hPzJ39X5sA9M1gM2"/></div></div></figure><p id="9bbf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我的BFS算法指南到此结束。我希望你发现这个故事内容丰富！请与你认为可能从中受益的朋友分享！如果你喜欢这个帖子/视频，请随意留下掌声/喜欢，并关注/订阅我的<a class="ae kl" href="https://medium.com/@rahulsabnis19" rel="noopener">媒体</a>和<a class="ae kl" href="http://bit.ly/sub2rahul" rel="noopener ugc nofollow" target="_blank"> YouTube账户</a>以获得更多类似的内容。此外，当我发布新内容时，请在<a class="ae kl" href="https://twitter.com/sabnis_rahul" rel="noopener ugc nofollow" target="_blank"> Twitter </a>和<a class="ae kl" href="https://www.instagram.com/sabnis_rahul/" rel="noopener ugc nofollow" target="_blank"> Instagram </a>上关注我。我希望在下一集看到你们！</p></div></div>    
</body>
</html>