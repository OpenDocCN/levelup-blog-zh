<html>
<head>
<title>Understanding Recursive Algorithms, Iteratively (Java)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">迭代理解递归算法(Java)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/understanding-recursion-algorithms-iteratively-java-1bf79bf33e0f?source=collection_archive---------19-----------------------#2022-11-17">https://levelup.gitconnected.com/understanding-recursion-algorithms-iteratively-java-1bf79bf33e0f?source=collection_archive---------19-----------------------#2022-11-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="c28f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">递归是一种简单的解决问题的方法，通过将问题分解成子问题的块，直到得到具有预定义解决方案的最小可能单元。一旦到了这个最小的单元，执行方向就反过来了，把最初产生的所有子问题的解联结起来，就得到完整的解。</p><p id="b418" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不要太担心定义，递归算法背后的主要概念会随着你的阅读变得非常清晰。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/a9d87e77464dcf97139d176f605cfaec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fZ59lgZ3edfLf-hkA3DAeA.jpeg"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">弗兰克·科恩摄:<a class="ae lb" href="https://www.pexels.com/photo/white-lines-2230796/" rel="noopener ugc nofollow" target="_blank">https://www.pexels.com/photo/white-lines-2230796/</a></figcaption></figure><h1 id="048a" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">嗯！我刚才说的是迭代理解递归吗…🤔</h1><p id="ca83" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">嗯，这可能看起来违反直觉，我知道。但是术语<strong class="jp ir">迭代</strong>是有意选择的，假设至少你理解如何迭代地解决一些基本的算法问题<strong class="jp ir">(即</strong>with loops——for循环、while循环等)。</p><p id="2abd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将在迭代知识的基础上揭开递归这个看似困难的概念的神秘面纱，它看起来总是难以理解，甚至至少在一些有经验的程序员中也是如此。</p><blockquote class="mf mg mh"><p id="5f8d" class="jn jo mi jp b jq jr js jt ju jv jw jx mj jz ka kb mk kd ke kf ml kh ki kj kk ij bi translated">了解如何用你最喜欢的编程语言实现复杂问题(如合并排序、二分搜索法、二叉树问题等)的递归算法，会给你超能力，让你的雇主和同事惊叹不已。</p></blockquote><p id="82a1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，让我们言归正传。首先，本文中的例子是用<strong class="jp ir"> Java </strong>实现的，但是你也可以用你喜欢的语言来实现。所以，卷起袖子，让我们把手弄脏一点。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/8967e933c9eedc6904a29725b61698ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*5Ee7qJ4bE_d8r7pwDVjV-A.jpeg"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">图片由迪安·马斯顿·皮沙贝提供</figcaption></figure><p id="4e7b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">我们将从这个简单的问题开始，打印一个给定的字符串或者一个数组的元素，或者逆序的列表。</strong></p><pre class="km kn ko kp gt mn mo mp mq aw mr bi"><span id="7478" class="ms ld iq mo b gy mt mu l mv mw"><strong class="mo ir"><em class="mi">There are many efficient ways of doing this iteratively, (using STACK, DEQUE, or simply looping from the last element, etc.</em></strong></span><span id="707b" class="ms ld iq mo b gy mx mu l mv mw"><strong class="mo ir">&gt;&gt;&gt;</strong></span><span id="fae5" class="ms ld iq mo b gy mx mu l mv mw"><strong class="mo ir">So,</strong> this is <strong class="mo ir">NOT</strong> a comparison between <strong class="mo ir">Recurssion and Iteration</strong>, especially for this trivial problem. There's a hidden concept we will reveal about recursive algorithms with this simple and familiar problem.</span></pre><h1 id="a050" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated"><strong class="ak">作为一个例子，我们将通过简单地以逆序打印一个字符数组来了解递归函数是如何工作的。</strong></h1><blockquote class="mf mg mh"><p id="4b24" class="jn jo mi jp b jq jr js jt ju jv jw jx mj jz ka kb mk kd ke kf ml kh ki kj kk ij bi translated">我们在这里的目标不是真正的解决方案。我们选择这个简单的例子是因为几乎任何人都可以迭代地实现它。我们将用这个简单的例子来说明递归算法的惊人之处，一旦你能理解它，你就能把这一知识应用到广泛的问题中。</p></blockquote><p id="a04e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么，我们开始吧。</p><p id="3108" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在开始使用递归函数之前，有两件事你必须了解。</p><ol class=""><li id="70c6" class="my mz iq jp b jq jr ju jv jy na kc nb kg nc kk nd ne nf ng bi translated"><strong class="jp ir">首先，</strong>就像每一个有限循环都必须有一个指定的终止条件，否则，循环将无限期运行，<strong class="jp ir"><em class="mi">‘while(I&lt;array . length)do…；</em> </strong>所以每个递归函数都有一个你可以称之为<strong class="jp ir">的基本条件</strong>，它必须被指定，否则递归调用将无限期继续。但这甚至不是我们分析中有趣的部分，尽管它非常重要。现在，第二个和神奇的概念…</li><li id="8ff4" class="my mz iq jp b jq nh ju ni jy nj kc nk kg nl kk nd ne nf ng bi translated"><strong class="jp ir">每一个</strong>递归实现都发生在<strong class="jp ir">两个阶段</strong>中，这两个阶段被顺序独立地执行。随着本文的深入，您将理解这些阶段。</li></ol><pre class="km kn ko kp gt mn mo mp mq aw mr bi"><span id="ec69" class="ms ld iq mo b gy mt mu l mv mw">public class PrintStringInReverseOrder {</span><span id="be21" class="ms ld iq mo b gy mx mu l mv mw">    static int i = 0;</span><span id="8843" class="ms ld iq mo b gy mx mu l mv mw">    public static void printInReverse(char[] array) {<br/>     <br/>       if (i == array.length - 1) {<br/>           <strong class="mo ir"><em class="mi">...do something; (Terminating condition)</em></strong><br/>       }<br/>       <strong class="mo ir"><em class="mi">... do some stuff (FIRST PHASE- codes b4 the recursive call)</em></strong></span><span id="ec5e" class="ms ld iq mo b gy mx mu l mv mw">       printInReverse(array); //recursive call<br/>       <br/>       <strong class="mo ir"><em class="mi">... do some stuff (SECOND PHASE - after the recursive call<br/>                                      (Optional)</em></strong></span><span id="1ba9" class="ms ld iq mo b gy mx mu l mv mw">       return ...; <strong class="mo ir"><em class="mi">(Optional)</em></strong></span><span id="99d3" class="ms ld iq mo b gy mx mu l mv mw">    }<br/>}</span></pre><blockquote class="mf mg mh"><p id="e79e" class="jn jo mi jp b jq jr js jt ju jv jw jx mj jz ka kb mk kd ke kf ml kh ki kj kk ij bi translated">递归方法/函数是一个在自身内部调用自身的函数。从上面的代码片段可以看出，<strong class="jp ir"><em class="iq">printin reverse</em></strong><em class="iq">方法在自己的块范围内调用了自己。</em></p></blockquote><h2 id="aff1" class="ms ld iq bd le nm nn dn li no np dp lm jy nq nr lq kc ns nt lu kg nu nv ly nw bi translated">查看bolden语句，我们将递归函数的实现分为两个执行阶段。</h2></div><div class="ab cl nx ny hu nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="ij ik il im in"><pre class="km kn ko kp gt mn mo mp mq aw mr bi"><span id="b528" class="ms ld iq mo b gy mt mu l mv mw">public static void printInReverse(char[] array) {//method definition<br/>                          ...<br/>       <strong class="mo ir"><em class="mi">(FIRST PHASE- codes b4 the recursive call)</em></strong></span><span id="c598" class="ms ld iq mo b gy mx mu l mv mw">       printInReverse(array); //recursive call<br/>       <br/>       <strong class="mo ir"><em class="mi">(SECOND PHASE - after the recursive call) (Optional)</em></strong></span><span id="9321" class="ms ld iq mo b gy mx mu l mv mw">return ...; <strong class="mo ir"><em class="mi">(Optional)</em></strong></span><span id="f639" class="ms ld iq mo b gy mx mu l mv mw">}</span></pre><p id="df80" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mi"/><strong class="jp ir"><em class="mi">第一阶段</em> </strong> <em class="mi">(我个人喜欢这样称呼它)在递归调用完成后立即开始，在这个阶段中，位于方法/函数定义和递归调用之间的所有代码/指令都被执行。</em></p><p id="0f4e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mi"/><strong class="jp ir"><em class="mi">第二阶段</em> </strong> <em class="mi">在第一阶段终止后立即触发(</em> <strong class="jp ir"> <em class="mi">由设定的基本条件</em> </strong> <em class="mi">)。</em></p><blockquote class="oe"><p id="ca40" class="of og iq bd oh oi oj ok ol om on kk dk translated">这就是我们想要利用的第二个执行阶段。</p></blockquote><p id="4091" class="pw-post-body-paragraph jn jo iq jp b jq oo js jt ju op jw jx jy oq ka kb kc or ke kf kg os ki kj kk ij bi translated"><em class="mi">在这里，数据以直观的方式操作和访问，使得复杂的问题非常容易解决。利用这个执行阶段，不同程度的复杂问题可以非常优雅地得到解决。</em></p><p id="9d0c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mi">的例子有</em> <strong class="jp ir"> <em class="mi">排序和合并</em> </strong> <em class="mi">中的一种</em> <strong class="jp ir"> <em class="mi">合并排序</em> </strong> <em class="mi">递归算法，计算给定数字的斐波那契数列等。</em></p><p id="c59d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可能听说过全能的<strong class="jp ir">分治</strong>算法。</p><p id="ac1c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正是在这个<strong class="jp ir">第二阶段</strong>中，在<strong class="jp ir">第一阶段</strong>遍历结束<strong class="jp ir">分割</strong>之后，完成了<strong class="jp ir">征服</strong>。</p><p id="5e45" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了进一步理解这个概念，我们将首先尝试理解这些阶段是如何可能的。</p><p id="fd0d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将浅显地看一下<strong class="jp ir">堆栈</strong>，它是每个递归执行被消耗的地方。</p><p id="9e55" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">递归调用在内存<strong class="jp ir">堆栈中执行。</strong></p><blockquote class="oe"><p id="bcf1" class="of og iq bd oh oi oj ok ol om on kk dk translated">简单来说，堆栈可以被看作是一种存储数据的方式，其中数据以相反的顺序从堆栈中取出。(即。<strong class="ak"><em class="ot"/></strong><em class="ot">(LIFO)</em><strong class="ak"><em class="ot">)。</em>T11】</strong></p></blockquote><p id="eaff" class="pw-post-body-paragraph jn jo iq jp b jq oo js jt ju op jw jx jy oq ka kb kc or ke kf kg os ki kj kk ij bi translated">在递归执行的<strong class="jp ir">第一阶段</strong>期间，存储在变量中的数据、各种函数调用被<strong class="jp ir">推</strong>到<strong class="jp ir">堆栈</strong>，当满足终止条件且执行返回时，递归执行的<strong class="jp ir">第二阶段</strong>开始，存储在堆栈中的数据被<strong class="jp ir">弹出</strong>，其顺序与它们被推入的顺序相反。(<strong class="jp ir">后进先出)</strong></p><h2 id="34aa" class="ms ld iq bd le nm nn dn li no np dp lm jy nq nr lq kc ns nt lu kg nu nv ly nw bi translated"><strong class="ak">使用我们的反向字符数组问题的简单说明。</strong></h2><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ou"><img src="../Images/e04c037cae14f8b9450b34721639ab92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XcnLN4SVTHfbpTkX0583kw.png"/></div></div></figure><p id="85e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当上面的代码被编译和运行时，我们有这个…</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ov"><img src="../Images/3e2311f353f8cd583dddadd49779a224.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b_Un_ud39ei_r7sJrMoOtg.png"/></div></div></figure><p id="0e56" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是在执行的每个阶段发生的事情。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ow"><img src="../Images/b873b20c9244a1a544165a63e1e90c7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TQjxR4CGAGbSq3z_V85FJQ.png"/></div></div></figure><p id="0684" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">花点时间研究一下上图。</p><p id="f253" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它为我们的R <strong class="jp ir"> <em class="mi">反转字符数组问题</em> </strong>说明了两阶段执行的实现。我们操纵<strong class="jp ir"> <em class="mi">第二阶段</em> </strong>执行特征来得到我们想要的解决方案。</p><p id="0367" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从上图可以看出，在递归调用的第一阶段，随着第一阶段的进行，我们进行递归调用的那一行上面的代码都被相应地执行。</p><p id="f4ef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从我们的代码中，我们有终止块，它指定了终止第一阶段的条件，从而返回调用。</p><blockquote class="mf mg mh"><p id="a928" class="jn jo mi jp b jq jr js jt ju jv jw jx mj jz ka kb mk kd ke kf ml kh ki kj kk ij bi translated">注意:您的终止条件可能不包括return语句。它可能只是在最后一次调用时给变量赋值。这完全取决于问题的性质。</p></blockquote><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ov"><img src="../Images/5294e85bc70b53bf202a673068f48498.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l7CZF1Piptfjp1-ajjAmQg.png"/></div></div></figure><p id="c741" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是第一阶段执行的代码。随着第一阶段的进行，我们希望<strong class="jp ir">将数组中的每个字符按照数组中第一个字符到最后一个字符的顺序推送到<strong class="jp ir">堆栈</strong>中。</strong></p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ox"><img src="../Images/21898b19832d921195ae8d43fcf3efe3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1blPo8KI5WWPDdhq1mXldA.png"/></div></div></figure><p id="fc07" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这之后，我们递归地调用我们的方法/过程/函数。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/0bb5abf3b7ff455fe1f9748da1c2b847.png" data-original-src="https://miro.medium.com/v2/resize:fit:1186/format:webp/1*VEcYrYTmPvZAmTm3C1a3qg.png"/></div></figure><p id="a927" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后在我们的递归调用下面，发生了<strong class="jp ir">第二阶段执行</strong>，在此期间<strong class="jp ir">将</strong>推入堆栈的值<strong class="jp ir">弹出</strong>，我们放置了我们的<strong class="jp ir"> <em class="mi">打印函数</em> </strong>，当每个<strong class="jp ir">字符</strong>以<strong class="jp ir"> <em class="mi"> LIFO </em> </strong>的顺序从堆栈中弹出时，该函数将捕获它们。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ow"><img src="../Images/b873b20c9244a1a544165a63e1e90c7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TQjxR4CGAGbSq3z_V85FJQ.png"/></div></div></figure><h1 id="8eb4" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">递归函数有很多场景和应用。一旦你理解了递归算法背后的基本原理，你就能动态地提高你解决问题的技能。</h1><p id="d894" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">有对递归算法的优化叫做<strong class="jp ir">动态编程，</strong>用于优化有重叠调用的递归算法的时间复杂度。</p><p id="7354" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这篇文章只是基于递归函数如何工作的基本原理。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi oz"><img src="../Images/054a85378f418bd2f17cbf53b768465e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4yb3QYrnmzFh4SQl"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">自然界中的斐波那契…</figcaption></figure></div></div>    
</body>
</html>