<html>
<head>
<title>Building Expedited Two-Factor Authentication into Angular Apps with Authy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Authy在Angular应用程序中构建快速的双因素身份验证</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/building-expedited-two-factor-authentication-into-angular-apps-with-authy-903c182f32de?source=collection_archive---------3-----------------------#2019-11-18">https://levelup.gitconnected.com/building-expedited-two-factor-authentication-into-angular-apps-with-authy-903c182f32de?source=collection_archive---------3-----------------------#2019-11-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/534e454334abff863f09a57a607129ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*nB1sdzKzfYaMJkZh.png"/></div></div></figure><p id="d1fb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><a class="ae kz" href="https://www.twilio.com/docs/authy" rel="noopener ugc nofollow" target="_blank">双因素认证(2FA) </a>为web应用程序提供了一个重要的额外安全层，但是2FA要求用户在每次登录时执行一个额外的操作。对于频繁登录应用程序的用户来说，这一额外步骤可能会令人厌烦。在使应用程序方便回头客的同时，有可能保持第二个因素提供的安全性吗？就是用Angular，Node.js，还有<a class="ae kz" href="https://www.twilio.com/docs/authy" rel="noopener ugc nofollow" target="_blank"> Twilio Authy </a>。</p><p id="2357" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在登录页面上实现“记住我”复选框是用户表明他们将成为回头客的一种便捷方式。在后台，加密的安全cookie是一种方便的机制，用于识别之前选中了“记住我”框并从特定机器成功登录的用户。</p><p id="a9bb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有了<a class="ae kz" href="https://www.twilio.com/authy" rel="noopener ugc nofollow" target="_blank"> Twilio Authy </a>和一个加密的cookie，比如一个<a class="ae kz" href="https://jwt.io/" rel="noopener ugc nofollow" target="_blank"> JSON Web Token </a> (JWT)，您可以让登录过程变得快速便捷，同时保持二元身份验证所提供的额外安全性。您的回头客将能够快速访问您的应用，而您的应用仍将受到2FA的保护，以防未经授权的访问。JWT可以提供第三方验证的额外优势，增加额外的安全性元素。</p><p id="cda6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">虽然加密的cookie是在客户端安全存储数据的好地方，但是数据的范围应该限于用户知道的信息，如他们的用户ID和密码，或者与用户相关的数据，如他们的帐号和最近的订单日期。安全cookie不适合存放API密钥或用户与应用程序交互范围之外的其他敏感数据。</p><h1 id="78f0" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">了解流程</h1><p id="0e57" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">有两种常见的方法可以缩短返回用户的登录过程:用户可以跳过输入他们的凭据(用户ID和密码)或跳过第二因素身份验证。在这两种方法中，跳过凭证输入是一种更安全的方法，因为它要求用户仍然拥有带有加密安全cookie的机器和2FA设备，通常是智能手机。第二种更安全的技术是本文所展示的。</p><p id="ee53" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">确定用户登录和身份验证状态的过程涉及客户端和服务器。对于新用户，或者之前没有选中“记住我”复选框的用户，该应用程序需要创建加密的cookie。对于在当前机器上拥有有效cookie的返回用户，客户机代码需要将cookie中的数据传递回服务器，这样服务器代码就可以确定用户id和密码，而不需要用户输入它们。有了用户的ID，服务器就可以查找用户的Authy ID并调用API来启动2FA进程。当用户成功完成2FA过程时，可以创建或更新安全cookie。</p><h1 id="9c31" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">你将从这篇文章中学到什么</h1><p id="102b" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">通过在这篇文章中构建这个项目，你将学会如何在Angular Universal + Node.js网站中添加“记住我”功能。“记住我”功能将使返回的用户能够通过在其设备上批准身份验证请求来登录应用程序；他们不需要重新输入他们的用户ID和密码，所以他们只需轻轻一点就可以登录。</p><p id="45f4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您还将学习如何使用cookie来传输实现“记住我”和2FA所需的数据。为了使这个案例研究项目不那么复杂并且更容易理解，这个项目中的代码创建了一个明文cookie。Cookie加密和JWT实现将在另一篇文章中讨论。</p><h1 id="b2b0" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">先决条件</h1><p id="8f63" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">为了完成这篇文章中的任务，你需要:</p><ul class=""><li id="0fbf" class="md me it kd b ke kf ki kj km mf kq mg ku mh ky mi mj mk ml bi translated"><a class="ae kz" href="https://nodejs.org/" rel="noopener ugc nofollow" target="_blank"> Node.js和npm</a>(node . js安装也会安装NPM。)</li><li id="a399" class="md me it kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated"><a class="ae kz" href="https://cli.angular.io/" rel="noopener ugc nofollow" target="_blank">角CLI </a></li><li id="51ae" class="md me it kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated"><a class="ae kz" href="https://git-scm.com/downloads" rel="noopener ugc nofollow" target="_blank">吉特</a></li><li id="26cb" class="md me it kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated">Twilio账户(<a class="ae kz" href="https://www.twilio.com/try-twilio" rel="noopener ugc nofollow" target="_blank">注册</a>获得<a class="ae kz" href="https://www.twilio.com/try-twilio" rel="noopener ugc nofollow" target="_blank">免费Twilio账户</a>。)</li><li id="f4af" class="md me it kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated">一个<a class="ae kz" href="https://www.twilio.com/authy" rel="noopener ugc nofollow" target="_blank"> Twilio Authy </a> API密钥和一个注册用户(也是免费的，说明如下)</li></ul><p id="c5dd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">要从这篇文章中最有效地学习，你应该具备:</p><ul class=""><li id="8c2d" class="md me it kd b ke kf ki kj km mf kq mg ku mh ky mi mj mk ml bi translated">打字稿和Angular框架的工作知识</li><li id="d0c1" class="md me it kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated">熟悉角度观察值、依赖注入、路由和管道</li></ul><h1 id="f08c" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">设置基线角度2FA项目</h1><p id="71e8" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">这篇文章使用了本系列上一篇文章中的Angular + Node.js项目:<a class="ae kz" href="https://medium.com/javascript-in-plain-english/build-two-factor-authentication-in-angular-with-twilio-authy-b94f700d1866" rel="noopener">用Twilio Authy在Angular中构建双因素认证。如果您已经从上一篇文章中成功地构建了项目，那么您可以继续使用现有的代码。</a></p><p id="3221" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><a class="ae kz" href="https://www.twilio.com/blog/two-factor-authentication-angular-twilio-authy" rel="noopener ugc nofollow" target="_blank">如果你还没有构建那个项目，或者你想开始一个新的项目，你可以从</a> <a class="ae kz" href="https://github.com/maciejtreder/angular-authy-remember" rel="noopener ugc nofollow" target="_blank"> GitHub repo中为这篇文章</a>克隆代码。</p><p id="c6ba" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">通过在您想要创建项目目录的目录中执行以下命令来克隆它:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="768b" class="na lb it mw b gy nb nc l nd ne">git clone <a class="ae kz" href="https://github.com/maciejtreder/angular-authy-remember.git" rel="noopener ugc nofollow" target="_blank">https://github.com/maciejtreder/angular-authy-remember.git</a><br/>cd angular-authy-remember<br/>npm install</span></pre><h1 id="3a6c" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">设置授权和授权用户</h1><p id="e461" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">如果您已经从上一篇文章中完成了项目的构建，那么您可以使用Authy application Production API键和Authy ID作为您在该练习中设置的用户。</p><p id="f280" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你重新开始，你需要设置Authy和一个用户。请遵循以下说明:</p><p id="6033" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">拥有Twilio帐户后，登录并导航至<a class="ae kz" href="https://www.twilio.com/console" rel="noopener ugc nofollow" target="_blank"> Twilio控制台</a>的授权部分，然后完成以下步骤:</p><ol class=""><li id="9280" class="md me it kd b ke kf ki kj km mf kq mg ku mh ky nf mj mk ml bi translated">在Twilio控制台的Authy部分，创建一个新的应用程序。</li><li id="c8b0" class="md me it kd b ke mm ki mn km mo kq mp ku mq ky nf mj mk ml bi translated">将应用程序的生产API密钥复制到一个安全的地方。(如果您放错了，可以在应用程序的设置中找到密钥。)</li><li id="b303" class="md me it kd b ke mm ki mn km mo kq mp ku mq ky nf mj mk ml bi translated">在您创建的应用程序中，使用您首选的电子邮件地址和手机号码将自己注册为新用户。</li><li id="b428" class="md me it kd b ke mm ki mn km mo kq mp ku mq ky nf mj mk ml bi translated">将刚刚创建的用户的Authy ID复制到一个安全的地方。</li><li id="2909" class="md me it kd b ke mm ki mn km mo kq mp ku mq ky nf mj mk ml bi translated">在手机上安装Authy应用程序。您应该会收到一条文本通知，其中包含获取代码以完成安装的链接。</li></ol><h1 id="4228" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">将Twilio安全对象添加到服务器代码</h1><p id="7700" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">打开<em class="ng">angular-authy-twilio/server . ts</em>，在下面的常量声明中用您的生产API键替换占位符:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="c594" class="na lb it mw b gy nb nc l nd ne">const API_KEY = 'Production API key';</span></pre><p id="14fe" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">用您创建的用户的授权ID替换<code class="fe nh ni nj mw b">authy_id</code>占位符:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="e517" class="na lb it mw b gy nb nc l nd ne">authy.send_approval_request('authy id', {</span></pre><p id="dd66" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="ng">一旦您将您的生产API密钥和authid添加到</em> server.ts <em class="ng">文件中，</em> <strong class="kd iu">不要将它</strong> <em class="ng">签入一个公共可访问的地方，比如GitHub存储库。</em></p><h1 id="9f20" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">构建并测试应用程序</h1><p id="037e" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">在命令行的<em class="ng"> angular-twilio-authy </em>目录下运行以下指令:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="f70f" class="na lb it mw b gy nb nc l nd ne">npm run build:prod<br/>npm run server</span></pre><p id="4035" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">打开浏览器窗口，打开浏览器的开发者工具(F12)，然后选择网络选项卡。</p><p id="f71c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">导航到<a class="ae kz" href="http://localhost:8080" rel="noopener ugc nofollow" target="_blank"> http://localhost:8080 </a>(或者<a class="ae kz" href="https://localhost:8080" rel="noopener ugc nofollow" target="_blank"> https://localhost:8080 </a>，如果你已经实现了SSL/TLS)。您应该会看到<em class="ng">/登录</em>页面，如下所示:</p><figure class="mr ms mt mu gt ju gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/28ca69aba7809eeaa4976341b1f13153.png" data-original-src="https://miro.medium.com/v2/resize:fit:788/format:webp/0*ENWRMUGoy3YeljDs.jpg"/></div></figure><p id="0c06" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">输入凭证<strong class="kd iu">用户ID: </strong> foo和<strong class="kd iu">密码:</strong>栏。点击<strong class="kd iu">登录。</strong></p><p id="4e74" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您应该会在与您在Twilio控制台的Authy部分为您注册的用户提供的电话号码相关联的设备上的Authy应用程序中收到授权请求。</p><figure class="mr ms mt mu gt ju gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/721c4b527cccaab6c717ceb48e0ddccb.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/0*xb0CNO7MhIvxfxor.png"/></div></figure><figure class="mr ms mt mu gt ju gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/81af9ba1ef7270f1789b4f36c6a9b4f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/0*0CWflNzjeO3rFoFM.png"/></div></figure><p id="a6f7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">批准请求。</p><p id="c2d9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">授权后，您应该被重定向到<em class="ng"> /home </em>路径，该路径由应用程序中的授权守卫保护。(参见帖子<a class="ae kz" href="https://www.twilio.com/blog/two-factor-authentication-angular-twilio-authy" rel="noopener ugc nofollow" target="_blank">使用Twilio Authy在Angular中构建双因素身份验证</a>以了解更多关于其工作原理的信息。)</p><figure class="mr ms mt mu gt ju gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/ed2e84f85445b3156f5fc2555df6a3c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:862/format:webp/0*NF-65YlWYVL8WN5B.jpg"/></div></figure><p id="010f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果这个过程如所描述的那样工作，那么双因素身份验证在您的Angular应用程序中是有效的。</p><h1 id="69a6" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">实现回访用户认可</h1><p id="ceb6" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">授权服务<code class="fe nh ni nj mw b">AuthService</code>需要根据<code class="fe nh ni nj mw b">remember</code>字段的值做出不同的响应。如果值是<code class="fe nh ni nj mw b">true</code>，并且用户通过了第二个认证因子，那么服务告诉服务器在cookie中包含<code class="fe nh ni nj mw b">remember</code>字段的值。</p><p id="19d7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">打开<em class="ng">src/app/auth . service . ts</em>文件，用以下类型脚本代码替换<code class="fe nh ni nj mw b">auth</code>和<code class="fe nh ni nj mw b">secondFactor</code>方法:</p><figure class="mr ms mt mu gt ju"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="8173" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">加密的cookie是由服务器上的<em class="ng"> /auth/status </em>端点创建的，因此需要更新端点代码来生成cookie并设置过期时间<code class="fe nh ni nj mw b">maxAge</code>，过期时间以秒为单位。</p><p id="b943" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">打开<em class="ng"> server.ts </em>文件，并用以下内容替换<em class="ng"> /auth/status </em>端点的类型脚本代码:</p><figure class="mr ms mt mu gt ju"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="0569" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">注意在<code class="fe nh ni nj mw b">maxAge</code>参数中设置的cookie超时相对较短，第二因子cookie为1分钟，记忆cookie为5分钟。这是因为cookie存在的时间足够长，即使用户注销了，您也可以看到快速的2FA登录在工作，但不会太长，因为旧的cookie一直存在，妨碍了您的端到端测试。如果您正在快速构建这个项目，您可能需要自己删除cookie来重置您的浏览器以进行端到端测试。</p><h1 id="c0c5" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">向登录页添加一个“记住我”控件</h1><p id="7283" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">为了开始识别回头客，应用程序需要一种方式让用户表明他们希望被记住。除了使返回用户的登录过程更加方便之外，添加“记住我”控件还有助于符合<a class="ae kz" href="https://eugdpr.org/" rel="noopener ugc nofollow" target="_blank">欧盟通用数据保护条例</a>。</p><p id="07e8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现有代码有一个<code class="fe nh ni nj mw b">LoginPageComponent</code>，所以很容易添加另一个控件。</p><p id="145c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">用以下html标记替换<em class="ng">src/app/log in-page/log in-page . component . HTML</em>中的代码:</p><figure class="mr ms mt mu gt ju"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="18d9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">打开<em class="ng">src/app/log in-page/log in-page . component . ts</em>文件，进行如下类型脚本修改。</p><p id="cb93" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">将新创建的字段添加到<code class="fe nh ni nj mw b">loginForm</code> <code class="fe nh ni nj mw b">FormGroup</code>类初始化中:</p><figure class="mr ms mt mu gt ju"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="0bb0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">将<code class="fe nh ni nj mw b">remember</code>控件的值添加到<code class="fe nh ni nj mw b">onSubmit()</code>方法中<code class="fe nh ni nj mw b">AuthService.auth()</code>调用的参数中:</p><figure class="mr ms mt mu gt ju"><div class="bz fp l di"><div class="nn no l"/></div></figure><h1 id="e4ce" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">测试<code class="fe nh ni nj mw b">remember</code> cookie功能</h1><p id="8fab" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">此时，最好确保应用程序使用新的用户界面元素正确地处理输入，并正确地生成新的cookie。</p><p id="305a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在<em class="ng"> angular-twilio-authy </em>目录下执行以下命令行指令:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="5f21" class="na lb it mw b gy nb nc l nd ne">npm run build:prod<br/>npm run server</span></pre><p id="625d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">打开浏览器选项卡。打开选项卡的开发工具(F12)并切换到网络选项卡，这样您就可以看到浏览器和Node.js服务器之间的通信。</p><p id="d405" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">导航到<a class="ae kz" href="http://localhost:8080" rel="noopener ugc nofollow" target="_blank"> http://localhost:8080 </a>(或者https，如果你已经实现了SSL/TLS)。</p><p id="c7af" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你应该会看到<em class="ng">/登录</em>页面，如下所示。</p><figure class="mr ms mt mu gt ju gh gi paragraph-image"><div class="gh gi np"><img src="../Images/2c58708037a9e779fd833a3263d0e1ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:760/format:webp/0*KCAmLvS2mQ3ybV1s.jpg"/></div></figure><p id="7508" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">输入登录凭证<strong class="kd iu">用户ID: </strong> foo和<strong class="kd iu">密码:</strong>栏。勾选<strong class="kd iu">记住我</strong>复选框。点击<strong class="kd iu">登录</strong>按钮，在浏览器中查看网络选项卡。当<em class="ng"> /auth/status </em>端点返回HTTP 200回复和<code class="fe nh ni nj mw b">authResponse.approval_request.status</code>的值时，您应该会看到一系列的<code class="fe nh ni nj mw b">status</code>消息。</p><p id="a9e6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在您的移动设备上批准Twilio Authy身份验证请求。在浏览器开发工具的网络选项卡中，您应该看到最后一个<code class="fe nh ni nj mw b">status</code>响应包含一个cookie，该cookie包含一个<code class="fe nh ni nj mw b">authentication</code>字段和一个<code class="fe nh ni nj mw b">remember</code>字段。</p><p id="6e26" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在生产应用程序中，cookie和这些字段将被加密。在这个项目中它们是纯文本，因此您可以更容易地理解代码的行为。</p><p id="c31d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe nh ni nj mw b">remember</code>字段的值是登录用户的授权ID。虽然这个值是硬编码在<em class="ng"> server.ts </em>文件中的，以简化这个演示项目，但是在生产应用程序中，您通常会在验证用户ID和密码之后，通过查询用户ID从持久数据存储中检索它。这可以防止在cookie中设置Authy ID，除非输入了有效的用户ID和密码对。</p><p id="84e8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因为cookie是<code class="fe nh ni nj mw b">httpOnly</code>，所以不能从浏览器中运行的JavaScript访问它。因为它在生产应用程序中会被加密，所以很难在客户端机器上访问Authy ID。客户端代码只需要知道设置了cookie中的<code class="fe nh ni nj mw b">remember</code>字段，而不是它的值。</p><figure class="mr ms mt mu gt ju gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/a933af575cb2649d3b231b58716a251d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*qQsUrvcoz_6lALqT.jpg"/></div></figure><p id="0398" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您想使用GitHub存储库中的代码赶上这一步，请在您想要创建项目目录的目录中执行以下命令:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="96c6" class="na lb it mw b gy nb nc l nd ne">git clone <a class="ae kz" href="https://github.com/maciejtreder/angular-authy-remember.git" rel="noopener ugc nofollow" target="_blank">https://github.com/maciejtreder/angular-authy-remember.git</a><br/>cd angular-authy-remember<br/>git checkout step1</span></pre><p id="5af5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">按照上一节<em class="ng">将Twilio安全对象添加到服务器代码</em>中的说明，将您创建的用户的Authy Production API密钥和Authy ID添加到代码中。</p><p id="b0e4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在<em class="ng"> angular-authy-remember </em>目录中执行以下npm命令行指令:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="0107" class="na lb it mw b gy nb nc l nd ne">npm install</span></pre><p id="20e2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">按照本节开头的说明尝试“记住我”复选框功能。</p><h1 id="8c5d" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">将值传输到服务器端渲染的角度代码</h1><p id="2e64" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">您的应用程序不应该向客户端代码公开API密钥等生产机密。为了避免在我们的应用程序类型脚本中硬编码Authy Production API键，您可以使用与文章<a class="ae kz" href="https://medium.com/javascript-in-plain-english/how-to-transfer-files-and-data-between-angular-clients-and-node-js-backends-fb002ef3a1d" rel="noopener">如何在Angular和Node.js之间传输JavaScript应用程序中的文件和数据</a>中相同的技术。</p><p id="533a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">打开<em class="ng"> server.ts </em>文件，找到以下类型脚本代码:</p><figure class="mr ms mt mu gt ju"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="4e81" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在<code class="fe nh ni nj mw b">app.engine</code>方法调用中将<code class="fe nh ni nj mw b">API_KEY</code>常量添加到提供者列表中，如下所示:</p><figure class="mr ms mt mu gt ju"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="09e6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，您可以在负责在服务器端呈现内容的Angular应用程序部分中使用Node.js设置的cookie。因为cookie是<code class="fe nh ni nj mw b">httpOnly</code>，所以浏览器中执行的JavaScript无法访问它。该应用程序将检索记住的用户的Authy ID，使用Twilio Authy发出身份验证请求，并通过使用TransferState技术将检索到的Authy ID提供给浏览器。(你可以在帖子里了解更多关于使用<code class="fe nh ni nj mw b">TransferState</code>对象的知识:<a class="ae kz" href="https://www.twilio.com/blog/transfer-files-data-javascript-applications-angular-node-js" rel="noopener ugc nofollow" target="_blank">如何在Angular和Node.js </a>之间传输JavaScript应用中的文件和数据。)</p><p id="6e5b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">打开<em class="ng">src/app/auth . service . ts</em>文件，将以下代码添加到<code class="fe nh ni nj mw b">ìmport</code>指令列表中:</p><figure class="mr ms mt mu gt ju"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="73d2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">修改<code class="fe nh ni nj mw b">AuthService</code>构造函数，用由Node.js提供的Authy Production API键注入<code class="fe nh ni nj mw b">TransferState</code>对象。</p><p id="32f3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">用以下代码替换<em class="ng"> auth.service.ts </em>文件中现有的构造函数代码:</p><figure class="mr ms mt mu gt ju"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="39b3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe nh ni nj mw b">AuthService</code>需要一种方法来确定被记住的用户是否通过了Twilio Authy的第二因素验证。这个过程涉及到服务器和客户端的代码，使用一个叫做<code class="fe nh ni nj mw b">getRememberedToken()</code>的<code class="fe nh ni nj mw b">AuthService</code>方法。</p><p id="3250" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在服务器上执行的代码调用Twilio Authy API并调用Authy身份验证过程。如果用户在他们的设备上接受Authy应用程序中的认证请求，那么<code class="fe nh ni nj mw b">TransferState</code>对象中的<code class="fe nh ni nj mw b">authyToken</code>的值将被设置为用户的Authy ID。</p><p id="403e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果代码在客户机上运行，则从<code class="fe nh ni nj mw b">TransferState</code>对象中检索Authy ID。</p><p id="4213" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">通过在类定义的底部(在最后一个<code class="fe nh ni nj mw b">}</code>之前)插入以下类型脚本代码，将<code class="fe nh ni nj mw b">getRememberedToken()</code>方法添加到<em class="ng"> auth.service.ts </em>文件中:</p><figure class="mr ms mt mu gt ju"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="04f5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">该应用将需要一个<em class="ng">解析器</em>来实现角度<code class="fe nh ni nj mw b">Resolve</code>接口。解析器截获一个链接点击，并返回一个可在调用方法的代码中使用的值或可观察值。</p><p id="8922" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这个应用程序中，<code class="fe nh ni nj mw b">LoginResolverService</code>类将提供由<code class="fe nh ni nj mw b">getRememberedToken()</code>方法返回的可观察值。</p><p id="2b30" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">通过在<em class="ng"> angular-authy-remember </em>目录中执行以下Angular CLI命令，生成登录解析器文件:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="0bcf" class="na lb it mw b gy nb nc l nd ne">ng g s loginResolver --skipTests</span></pre><p id="180d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">通过用以下代码替换<em class="ng">src/app/log in-resolver . ts</em>文件的内容来实现<code class="fe nh ni nj mw b">LoginResolverService</code>类:</p><figure class="mr ms mt mu gt ju"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="7066" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当用户导航到<em class="ng">/登录</em>页面时，将使用解析器。</p><p id="f33d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">打开<em class="ng">src/app-routing . module . ts</em>文件，将以下代码添加到现有的<code class="fe nh ni nj mw b">import</code>指令列表中:</p><figure class="mr ms mt mu gt ju"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="9b19" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">用以下代码替换现有行，修改<em class="ng">/登录</em>路径的路由定义:</p><figure class="mr ms mt mu gt ju"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="14c7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在您可以重构<code class="fe nh ni nj mw b">LoginPageComponent</code>类来使用解析器和第二因素认证。</p><p id="d6c5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">用以下类型脚本代码替换<em class="ng">src/app/log in-page . component . ts</em>文件的内容:</p><figure class="mr ms mt mu gt ju"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="c906" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对<code class="fe nh ni nj mw b">LoginPageComponent</code>类的修改完成了许多任务:</p><p id="94a7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在<code class="fe nh ni nj mw b">LoginPageComponent</code>类中实现了<code class="fe nh ni nj mw b">OnInit</code>接口，以支持解析器的使用。</p><p id="0da0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一个<code class="fe nh ni nj mw b">ActivatedRoute</code>对象被注入到<code class="fe nh ni nj mw b">LoginPageComponent</code>类中，因此<code class="fe nh ni nj mw b">authToken</code>的值可以从路由器数据中获得。</p><p id="d1ea" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">第二认证因素的处理被转移到私有方法<code class="fe nh ni nj mw b">handleSecondFactor()</code>。</p><p id="af22" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe nh ni nj mw b">handleSecondFactor()</code>接收<code class="fe nh ni nj mw b">authService.auth()</code>方法的结果作为可观察值，指示第二因子请求是被授权(真)、被拒绝(假)还是超时(空)。</p><p id="979d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe nh ni nj mw b">handleSecondFactor()</code>在两个地方被称为:</p><ol class=""><li id="0024" class="md me it kd b ke kf ki kj km mf kq mg ku mh ky nf mj mk ml bi translated"><code class="fe nh ni nj mw b">onSubmit()</code>执行初始第一要素检查(用户ID和密码)。</li><li id="6cbc" class="md me it kd b ke mm ki mn km mo kq mp ku mq ky nf mj mk ml bi translated"><code class="fe nh ni nj mw b">ngOnInit()</code>使用解析器<code class="fe nh ni nj mw b">LoginResolverService</code>提供的<code class="fe nh ni nj mw b">TransferState</code>对象检查第二个因子的状态。</li></ol><p id="e1e0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">构建应用程序的最后一步是重构<code class="fe nh ni nj mw b">AuthorizationService</code>类。</p><p id="446f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">用以下类型脚本代码替换<em class="ng">src/app/auth . service . ts</em>文件中的代码:</p><figure class="mr ms mt mu gt ju"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="44cb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">上面的新代码添加了<code class="fe nh ni nj mw b">pollStatus()</code>方法并重构了<code class="fe nh ni nj mw b">secondFactor()</code>方法。</p><p id="cfc1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">逐行检查<code class="fe nh ni nj mw b">secondFactor</code>方法:</p><figure class="mr ms mt mu gt ju"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="a17a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">该方法返回一个可观察的。</p><p id="0306" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">用<code class="fe nh ni nj mw b">timer()</code>方法初始化可观察对象:它将在5分钟内每秒发出一个值，5分钟的限制由<code class="fe nh ni nj mw b">take(5 * 60)</code>设置。</p><p id="a93e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe nh ni nj mw b">concatMap()</code>将可观察对象的返回值更改为<code class="fe nh ni nj mw b">pollStatus()</code>方法输出。</p><p id="5035" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">过滤<code class="fe nh ni nj mw b">pollStatus()</code>输出以移除<code class="fe nh ni nj mw b">pending</code>状态。</p><p id="6870" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe nh ni nj mw b">map()</code>操作符返回一个基于认证状态的布尔值。</p><p id="10af" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当<code class="fe nh ni nj mw b">status</code>的值不是<code class="fe nh ni nj mw b">true</code>(批准)时，该过程通过<code class="fe nh ni nj mw b">takeWhile()</code>循环继续，或者直到迭代超时。</p><p id="d7af" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这就完成了应用程序的代码。应用程序流程如下图所示:</p><figure class="mr ms mt mu gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nr"><img src="../Images/6b3af37af5d1d545ccf52553de5d55d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ChqgacoM8rQOESco.png"/></div></div></figure><h1 id="96ea" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">测试完成的应用程序</h1><p id="4c2d" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">如果您成功地应用了所有代码更改，您应该能够看到应用程序的完整功能。</p><p id="cd21" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">通过在<em class="ng"> angular-authy-remember </em>目录中执行以下npm命令来构建并运行应用程序:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="7970" class="na lb it mw b gy nb nc l nd ne">npm run build:prod<br/>npm run server</span></pre><p id="0dce" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">打开一个新的浏览器标签，并打开浏览器的开发者工具(F12)。在开发者工具中选择网络选项卡。</p><p id="0907" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">转到<a class="ae kz" href="http://localhost:8080." rel="noopener ugc nofollow" target="_blank"> http://localhost:8080。</a>输入您之前使用的登录凭证，并勾选“记住我”复选框。单击登录按钮。</p><p id="42dc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您将在<em class="ng">/登录</em>页面上看到“等待第二个因素”,并且您应该开始在网络选项卡中看到<code class="fe nh ni nj mw b">status</code>事件。</p><p id="40f9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当您在设备上收到Authy身份验证请求时，请接受它。您将看到<code class="fe nh ni nj mw b">status</code>事件结束，随后是一个<code class="fe nh ni nj mw b">islogged</code>事件，应用程序会将您重定向到<em class="ng"> /home </em>路径，在那里您将看到“受保护页面工作！”消息。</p><p id="1310" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">刷新浏览器选项卡。因为您之前已经成功登录，已经设置了认证cookie，所以<em class="ng">/登录</em>页面将立即开始显示“等待第二个因素”，并且网络选项卡将开始显示<code class="fe nh ni nj mw b">status</code>消息。</p><p id="2554" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您不需要输入用户ID或密码，不需要选中“记住我”复选框，也不需要单击“登录”按钮。</p><p id="3300" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您应该还收到了来自设备上Authy应用程序的身份验证请求。批准它以完成登录序列。</p><p id="50fb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">就这样，您只需轻轻一点就可以登录到应用程序中！登录过程是安全的，因为只有当您在之前成功登录的设备上登录，并使用设备上的Authy应用程序验证自己时，登录过程才会有效。</p><p id="d264" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您想赶上这一步，或者将您的工作与项目报告中的代码进行比较，请遵循以下步骤:</p><p id="f80a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在要创建项目的目录中执行以下命令行指令:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="35a6" class="na lb it mw b gy nb nc l nd ne">git clone <a class="ae kz" href="https://github.com/maciejtreder/angular-authy-remember.git" rel="noopener ugc nofollow" target="_blank">https://github.com/maciejtreder/angular-authy-remember.git</a><br/>cd angular-authy-remember<br/>git checkout step2<br/>npm install</span></pre><p id="e8b9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如上所述，在<em class="ng"> server.ts </em>文件中添加您的授权生产API密钥和用户授权ID。</p><p id="c985" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在<em class="ng"> angular-authy-remember </em>目录中执行以下npm命令行指令:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="7d1b" class="na lb it mw b gy nb nc l nd ne">npm run build:prod<br/>npm run server</span></pre><p id="e02f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">执行<em class="ng">测试完成的应用</em>部分中的步骤。</p><h1 id="052a" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">使用角度和扭转身份验证的快速双因素身份验证摘要</h1><p id="8a97" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">在本文中，您了解了如何将“记住我”功能添加到Angular Universal + Node.js应用程序中。您还了解了如何使用Angular <code class="fe nh ni nj mw b">TransferState</code>对象和安全cookie来识别返回的用户。您让返回的用户只需点击Authy应用程序即可登录应用程序，绕过了重新输入凭据的步骤，同时保持了双因素身份验证的额外安全性。酷豆！</p><h1 id="24af" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">额外资源</h1><p id="8a93" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated"><a class="ae kz" href="https://angular.io/api/router" rel="noopener ugc nofollow" target="_blank"> @angular/router </a> API文档，包括Resolve接口。</p><p id="773b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><a class="ae kz" href="https://www.twilio.com/docs/authy/api" rel="noopener ugc nofollow" target="_blank"> Authy API </a>获取Twilio Authy的完整API文档。</p><p id="f33c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><a class="ae kz" href="https://jwt.io/" rel="noopener ugc nofollow" target="_blank"> jwt.io </a>了解更多关于JSON Web Token及其以标准格式传输数据并为Web应用程序增加额外安全性的能力。</p><p id="c914" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="ng">我是Maciej Treder，请通过</em><a class="ae kz" href="mailto:contact@maciejtreder.com" rel="noopener ugc nofollow" target="_blank"><em class="ng">【contact@maciejtreder.com】</em></a><em class="ng"/><a class="ae kz" href="https://www.maciejtreder.com/" rel="noopener ugc nofollow" target="_blank"><em class="ng">https://www.maciejtreder.com</em></a><em class="ng">或@ maciejtreder on</em><a class="ae kz" href="http://github.com/maciejtreder" rel="noopener ugc nofollow" target="_blank"><em class="ng">GitHub</em></a><em class="ng"/><a class="ae kz" href="https://twitter.com/maciejtreder" rel="noopener ugc nofollow" target="_blank"><em class="ng">Twitter</em></a><em class="ng">和</em> <a class="ae kz" href="https://www.linkedin.com/in/maciej-treder/" rel="noopener ugc nofollow" target="_blank"> <em class="ng"> LinkedIn </em></a></p><p id="9327" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="ng">本帖原载于</em> <a class="ae kz" href="https://www.twilio.com/blog/expedited-two-factor-authentication-angular-twilio-authy" rel="noopener ugc nofollow" target="_blank"> <em class="ng"> Twilio博客</em> </a> <em class="ng">。</em></p></div></div>    
</body>
</html>