<html>
<head>
<title>Lee algorithm — Typescript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Lee算法—类型脚本</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/lee-algorithm-typescript-b68df0a147c0?source=collection_archive---------8-----------------------#2020-05-16">https://levelup.gitconnected.com/lee-algorithm-typescript-b68df0a147c0?source=collection_archive---------8-----------------------#2020-05-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jn jo jp jq"><div class="bz fp l di"><div class="jr js l"/></div></figure></div><div class="ab cl jt ju hu jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="ij ik il im in"><p id="4339" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated">Lee算法最受欢迎的应用是解决最佳二进制迷宫搜索。这是一种广度优先搜索，通常用于矩阵搜索。</p><p id="f8b8" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated">想象你有一个迷宫，看起来像这样:</p><figure class="kz la lb lc gt jq gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi ky"><img src="../Images/affd6cd5b2df8bd40b52be2c8bdcb30b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6odkO8IqkoRbdhsAMgidQg.jpeg"/></div></div></figure></div><div class="ab cl jt ju hu jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="ij ik il im in"><p id="1da6" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated">红色是起点，紫色是终点，你的任务是找到到达终点的最短路线。</p><p id="6965" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated">矩阵通常表现为类似这样的二元迷宫:</p><pre class="kz la lb lc gt lj lk ll lm aw ln bi"><span id="c383" class="lo lp iq lk b gy lq lr l ls lt">var maze:number[][] = [</span><span id="c03c" class="lo lp iq lk b gy lu lr l ls lt">[ 1, 1, 1, 1, 1, 0, 0, 1, 1, 1 ],</span><span id="8e06" class="lo lp iq lk b gy lu lr l ls lt">[ 0, 1, 1, 1, 1, 1, 0, 1, 0, 1 ],</span><span id="903f" class="lo lp iq lk b gy lu lr l ls lt">[ 0, 0, 1, 0, 1, 1, 1, 0, 0, 1 ],</span><span id="651c" class="lo lp iq lk b gy lu lr l ls lt">[ 1, 0, 1, 1, 1, 0, 1, 1, 0, 1 ],</span><span id="4f00" class="lo lp iq lk b gy lu lr l ls lt">[ 0, 0, 0, 1, 0, 0, 0, 1, 0, 1 ],</span><span id="20d1" class="lo lp iq lk b gy lu lr l ls lt">[ 1, 0, 1, 1, 1, 0, 0, 1, 1, 0 ],</span><span id="85b4" class="lo lp iq lk b gy lu lr l ls lt">[ 0, 0, 0, 0, 1, 0, 0, 11, 0, 1 ],</span><span id="f3cc" class="lo lp iq lk b gy lu lr l ls lt">[ 0, 1, 1, 1, 1, 1, 1, 1, 0, 0 ],</span><span id="49df" class="lo lp iq lk b gy lu lr l ls lt">[ 1, 1, 1, 1, 1, 0, 0, 1, 1, 1 ],</span><span id="b10a" class="lo lp iq lk b gy lu lr l ls lt">[ 0, 0, 1, 0, 0, 1, 1, 0, 0, 1 ]</span><span id="a0fc" class="lo lp iq lk b gy lu lr l ls lt">];</span></pre></div><div class="ab cl jt ju hu jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="ij ik il im in"><p id="e001" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated">你会注意到终点标记为11。这里有许多方法可以达到最终目标，其中一些比Lee更有效，但是Lee是完成工作最明显和最彻底的方法。</p><h1 id="993c" class="lv lp iq bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">我们开始吧。</h1><p id="615e" class="pw-post-body-paragraph ka kb iq kc b kd ms kf kg kh mt kj kk kl mu kn ko kp mv kr ks kt mw kv kw kx ij bi translated">如果您想查看代码，请随意浏览:</p><p id="fca0" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated"><a class="ae mx" href="https://github.com/Clashbuster/lee-algorithm" rel="noopener ugc nofollow" target="_blank">https://github.com/Clashbuster/lee-algorithm</a></p><p id="ad88" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated">算法的核心功能就在这里:</p><pre class="kz la lb lc gt lj lk ll lm aw ln bi"><span id="78f5" class="lo lp iq lk b gy lq lr l ls lt">function LeesAlgorithm(position:number[], distance:number = 0){</span><span id="1009" class="lo lp iq lk b gy lu lr l ls lt">  distance += 1</span><span id="50cf" class="lo lp iq lk b gy lu lr l ls lt">  visited[position[0]][position[1]] = true</span><span id="c265" class="lo lp iq lk b gy lu lr l ls lt">  //pushes executable into queue after a bunch of checks for an orthogonal direction</span><span id="f836" class="lo lp iq lk b gy lu lr l ls lt">  if(exists([position[0] + 1, position[1]])){  </span><span id="f9f9" class="lo lp iq lk b gy lu lr l ls lt">    if( visited[position[0] +1][position[1]] === false){</span><span id="77d0" class="lo lp iq lk b gy lu lr l ls lt">      if(maze[position[0] +1][position[1]] === 1){</span><span id="a0cc" class="lo lp iq lk b gy lu lr l ls lt">        visited[position[0] +1][position[1]] = distance</span><span id="a6c1" class="lo lp iq lk b gy lu lr l ls lt">        queue.push(executable([position[0] + 1, position[1]], distance))</span><span id="15cc" class="lo lp iq lk b gy lu lr l ls lt">      } else if(maze[position[0] +1][position[1]] === 9){</span><span id="876e" class="lo lp iq lk b gy lu lr l ls lt">        toggle = false</span><span id="9c13" class="lo lp iq lk b gy lu lr l ls lt">        console.log(distance)</span><span id="e527" class="lo lp iq lk b gy lu lr l ls lt">      }</span><span id="0021" class="lo lp iq lk b gy lu lr l ls lt">   }</span><span id="87d2" class="lo lp iq lk b gy lu lr l ls lt">}</span><span id="fba1" class="lo lp iq lk b gy lu lr l ls lt">//pushes executable into queue after a bunch of checks for an orthogonal direction</span><span id="3eea" class="lo lp iq lk b gy lu lr l ls lt">if(exists([position[0] - 1, position[1]])){</span><span id="ac67" class="lo lp iq lk b gy lu lr l ls lt">  if( visited[position[0] -1][position[1]] === false){</span><span id="cf38" class="lo lp iq lk b gy lu lr l ls lt">    if(maze[position[0] -1][position[1]] === 1){</span><span id="8c0f" class="lo lp iq lk b gy lu lr l ls lt">      visited[position[0] -1][position[1]] = distance</span><span id="5286" class="lo lp iq lk b gy lu lr l ls lt">      queue.push(executable([position[0] - 1, position[1]], distance))</span><span id="6241" class="lo lp iq lk b gy lu lr l ls lt">    } else if(maze[position[0] -1][position[1]] === 9){</span><span id="96bd" class="lo lp iq lk b gy lu lr l ls lt">      toggle = false</span><span id="7314" class="lo lp iq lk b gy lu lr l ls lt">      console.log(distance)</span><span id="d86d" class="lo lp iq lk b gy lu lr l ls lt">    }</span><span id="d980" class="lo lp iq lk b gy lu lr l ls lt">  }</span><span id="00b9" class="lo lp iq lk b gy lu lr l ls lt">}</span><span id="096d" class="lo lp iq lk b gy lu lr l ls lt">//pushes executable into queue after a bunch of checks for an orthogonal direction</span><span id="28a7" class="lo lp iq lk b gy lu lr l ls lt">if(exists([position[0] , position[1]+1])){</span><span id="0e53" class="lo lp iq lk b gy lu lr l ls lt">  if( visited[position[0]][position[1]+1] === false){</span><span id="f5f5" class="lo lp iq lk b gy lu lr l ls lt">     if(maze[position[0]][position[1]+1] === 1){</span><span id="0734" class="lo lp iq lk b gy lu lr l ls lt">       visited[position[0]][position[1]+1] = distance</span><span id="cab3" class="lo lp iq lk b gy lu lr l ls lt">       queue.push(executable([position[0] , position[1]+1], distance))</span><span id="2c00" class="lo lp iq lk b gy lu lr l ls lt">     } else if(maze[position[0]][position[1]+1] === 9){</span><span id="32cb" class="lo lp iq lk b gy lu lr l ls lt">        toggle = false</span><span id="e5c7" class="lo lp iq lk b gy lu lr l ls lt">        console.log(distance)</span><span id="8104" class="lo lp iq lk b gy lu lr l ls lt">     }</span><span id="4315" class="lo lp iq lk b gy lu lr l ls lt">  }</span><span id="65c1" class="lo lp iq lk b gy lu lr l ls lt">}</span><span id="ae86" class="lo lp iq lk b gy lu lr l ls lt">//pushes executable into queue after a bunch of checks for an orthogonal direction</span><span id="fc39" class="lo lp iq lk b gy lu lr l ls lt">if(exists([position[0] , position[1]-1])){</span><span id="30c2" class="lo lp iq lk b gy lu lr l ls lt">  if( visited[position[0]][position[1]-1] === false){</span><span id="fd5d" class="lo lp iq lk b gy lu lr l ls lt">    if(maze[position[0]][position[1]-1] === 1){</span><span id="257f" class="lo lp iq lk b gy lu lr l ls lt">      visited[position[0]][position[1]-1] = distance</span><span id="58fc" class="lo lp iq lk b gy lu lr l ls lt">      queue.push(executable([position[0] , position[1]-1], distance))</span><span id="128d" class="lo lp iq lk b gy lu lr l ls lt">    } else if(maze[position[0]][position[1]-1] === 9){</span><span id="f9c5" class="lo lp iq lk b gy lu lr l ls lt">      toggle = false</span><span id="3768" class="lo lp iq lk b gy lu lr l ls lt">      console.log(distance) </span><span id="2648" class="lo lp iq lk b gy lu lr l ls lt">    }</span><span id="eab0" class="lo lp iq lk b gy lu lr l ls lt">  }</span><span id="3651" class="lo lp iq lk b gy lu lr l ls lt">}</span><span id="4ad1" class="lo lp iq lk b gy lu lr l ls lt">}</span></pre><p id="d0c2" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated">为了使该算法工作，您必须从起点开始，用当前距离标记所有有效的相邻位置，并将当前位置标记为已访问。然后，移动到那些有效的相邻位置，做完全相同的事情。冲洗并重复，直到找到终点。</p><p id="e472" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated">为了防止这变成深度优先搜索，并使最短路径总是首先到达终点，我使用了承诺队列。</p><p id="6a09" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated">像这样:</p><pre class="kz la lb lc gt lj lk ll lm aw ln bi"><span id="99ad" class="lo lp iq lk b gy lq lr l ls lt">const executable = (position:number[], distance:number) =&gt; {</span><span id="f80a" class="lo lp iq lk b gy lu lr l ls lt">  return () =&gt; {</span><span id="6dab" class="lo lp iq lk b gy lu lr l ls lt">    LeesAlgorithm(position, distance)</span><span id="2376" class="lo lp iq lk b gy lu lr l ls lt">  }</span><span id="33dc" class="lo lp iq lk b gy lu lr l ls lt">}</span><span id="b827" class="lo lp iq lk b gy lu lr l ls lt">//seed the executable queue</span><span id="db88" class="lo lp iq lk b gy lu lr l ls lt">queue.push(executable([0,0], 0))</span><span id="49d7" class="lo lp iq lk b gy lu lr l ls lt">//until we find 9, repeatedly pull from the executable queue and execute the lee's algorithm function</span><span id="aa68" class="lo lp iq lk b gy lu lr l ls lt">while(toggle){</span><span id="9400" class="lo lp iq lk b gy lu lr l ls lt">  queue.shift()()</span><span id="8a67" class="lo lp iq lk b gy lu lr l ls lt">}</span></pre><p id="3ca8" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated">这里发生了两件事。首先，我承诺。当leesAlgorithm函数找到一个有效的相邻位置时，它使用当前距离和要执行的位置调用executable。</p><p id="f884" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated">要执行的当前距离和位置被传递到另一个leesalgiothm调用中，但它直到稍后才真正执行leesalgiothm。</p><p id="ae0a" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated">这是函数找到有效邻接时执行的代码行:</p><pre class="kz la lb lc gt lj lk ll lm aw ln bi"><span id="b1da" class="lo lp iq lk b gy lq lr l ls lt">queue.push(executable([position[0] , position[1]-1], distance))</span></pre><p id="e574" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated">这是将承诺推入队列，因为我希望承诺以特定的顺序进行评估。如果函数以不受控制的顺序执行，算法将在迷宫中穿行，而不考虑其他路径，这是我们希望避免的，因为我们应该找到最佳路径。</p><p id="4650" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated">队列是一种数据结构，它将项目放在后面，但总是从前面移除项目，就像在DMV排队一样。</p><p id="b0d7" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated">我正在指示我的算法以完全相同的方式执行我的leesAlgorithm调用。通过这种方式，我的程序将总是在进入迷宫之前执行所有相邻的调用。</p><p id="203e" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated">因此，随着迷宫越走越深，算法会进行越来越多的调用，所以如果这是一个巨大的迷宫，我们肯定会看到一些减速。</p><p id="bee3" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated">这张图片不仅展示了我的程序正在研究的路径，还展示了程序正在进行的操作的一般顺序。</p><figure class="kz la lb lc gt jq gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi ky"><img src="../Images/15b1f476f7993cb6b82d93ffee87d986.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SBoU54_TNKvSjI3nFAwidg.jpeg"/></div></div></figure><p id="e917" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated">最后，一旦我的leesAlgorithm函数检测到终点，它就中断循环并抛出一个console.log(路径的)。在这种情况下，答案是13。</p><p id="bc62" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated">好了，这就是我今天的全部时间。</p><p id="194a" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated">很快我将发布一个博客，对什么是队列有更深入的了解。</p><p id="cf0e" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated">可视化是使用用户友好的渲染引擎ruby 2d实现的。</p></div></div>    
</body>
</html>