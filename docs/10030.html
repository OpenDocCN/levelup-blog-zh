<html>
<head>
<title>How I Have Used Python Professionally</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我如何专业地使用Python</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-i-have-used-python-professionally-e3f0849be824?source=collection_archive---------8-----------------------#2021-10-18">https://levelup.gitconnected.com/how-i-have-used-python-professionally-e3f0849be824?source=collection_archive---------8-----------------------#2021-10-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5002" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">尽管我基本上是一个C#的人，但它总是派上用场。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/02da797a1c1dc1023bfbe8e5019809af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JLDQ-ZF1ufZc2dAD"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">安东尼·里埃拉在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="025b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我是一名全职后端开发人员，我的主要工作通常是C#和Oracle——但我仍然有机会一直使用Python。虽然我更喜欢C#的结构元素和可靠的类型执行和调试，但每当我需要一个可能会出现也可能不会出现的自动化工作流，但创建一个完整的解决方案似乎有些多余时，Python就派上了用场。</p><p id="6a48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编写一个Python脚本可能只需要五分钟，而且这些任务经常涉及文件系统访问，在我看来Python非常可爱和方便。因此，让我谈一谈我在专业环境中发现的Python应用程序的用例。</p><p id="fa25" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个小好处是Python可以很好地处理VS代码，不像C#那样，你会错过ReSharper和全套Visual Studio的其他细节。只需打开一个新文档，写几行代码，然后直接从VS代码中的调试器运行它，就可以做你想要做的事情了。</p><h1 id="e2ae" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">解析文件名并提取id</h1><p id="1d86" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在我以前的工作中，我们经常不得不处理大量导出的文档，这些文档最终会保存在文件夹、网络驱动器、这样或那样的文件夹中。这常常令人困惑，经常会有最后一分钟的更改或简单的错误，导致正确的文件出现在错误的文件夹中。</p><p id="7744" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">手动搜索和找到这些文件中的任何一个都要花上5到10分钟，而且Windows search也不是微软操作系统的典范。所以很自然地，每个人都讨厌这些任务，足以让我坐下来写一点Python脚本。它需要一个输入路径列表和一个目标目录，一个包含在文件名中的id列表。然后，它将遍历所有文件夹，如果找到文件，它将把它复制到目标目录。</p><p id="9dc3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这仍然需要一些手动设置工作，但是正如您所料，查找和复制这些文件只需要几分钟，而不是几个小时。</p><h1 id="9145" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">解析PDF文件并提取id</h1><p id="a995" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">简单的事情有时会变得复杂，在前面的例子中，我们最终得到的不只是一两个文件，而是成千上万个大规模导出文件。然后，在手动检查过程中，我们在生成的实际文本中发现了一些错误，这些错误是基于错误的输入数据，在这些错误出现在最终报告中之前，我们无从得知。</p><p id="f6e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以现在，我们必须在修复bug后重新生成所有受影响的文件，但是如何找出这些文件中哪些需要重新生成呢？我们有受影响的客户id，但这次没有附加到文件名上，因为它们是按日期和邮政编码分组的。</p><p id="c479" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，重新生成所有的文件需要一周的时间，而我们只有不到一天的时间。因此，我们聚在一起，我写了一个小Python脚本，打开实际的PDF文件，搜索文本，看看它是否包括有问题的部分，然后将这些文件复制到“to_regenerate”文件夹中。与简单地解析文件名相比，这个过程很慢，但是我们聚在一起，在我们可以访问的每台计算机和服务器上运行这个脚本，设法在合理的时间内解析所有这些文件，以重新生成受影响的文件。</p><p id="f4dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这件事能以不同的方式处理吗？当然，本地分布的Python文件可能不是这项工作的最佳工具。但是我们有几个小时的空闲时间，实际的剧本可能花了一个小时来写，我处于一种既累又慌的奇怪状态——结果很好。</p><h1 id="9e32" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">批量重命名文件</h1><p id="3378" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">当您需要对所有文件应用相同的模式时，重命名文件通常很简单。我经常使用一个名为batch renamer的Windows工具，它非常强大，支持各种前缀、后缀甚至正则表达式——但它不是很灵活。</p><p id="49d6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您需要这个重命名过程的动态组件以及一些If条件和分组能力，那么Python是您最好的朋友。您只需编写类似“遍历该文件夹中的所有文件”这样的内容，然后编写一系列条件来确定该特定文件是否需要重命名以及如何重命名。</p><p id="54d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与RegEx magic相结合，这允许一些非常详细的规则集，全部在几分钟内完成。</p><h1 id="755a" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">批量删除文件</h1><p id="a193" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">这里，我们将powershell和Python分开，作为我最喜欢的处理批量删除的方法。Powershell通常做得很好，也很快——我只是讨厌处理它的语法。Powershell几乎和PHP一模一样，上帝知道，每当我看到变量声明前面的$符号时，我仍然会有战时倒叙。此外，Powershell有一种令人讨厌的方式，使用模糊的标志和语法，你需要谷歌来理解事情——而Python不是这样的。</p><p id="cf5d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很像重命名，你可以很容易地做一些像“循环文件，检查条件是否满足，删除文件”。当你的同事手动查看你试图删除的文件时，尽管你的电子邮件不要碰那个文件夹，添加一个try-catch，然后你可以为自己节省一些白发，并可以在那天晚上他们关闭计算机时解决问题。</p><h1 id="6033" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">订购和压缩文件</h1><p id="4e1b" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">如果你不得不做不止一次或两次，压缩文件是非常痛苦的。这要花很长时间，仍然是一个重复的过程，当我不得不做得太多的时候，我会痛哭流涕，但这不足以保证真正的自动化。</p><p id="1576" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但有时，你需要一次压缩数百个文件，然后写一点“if file . endswith(file extension):zip . add(file)”就开始有意义了——我的理智得救了。</p><h1 id="91f3" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">外卖:Python为我提供了千载难逢的好服务</h1><p id="ca71" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">虽然复杂的东西可以用Python来构建，简单的东西可以用C#来自动化，但我只是喜欢它们都倾向于某个特定方向的方式，并且将它们用于它们的主要优势，这给了我在一个冷酷、艰难的现实中温暖模糊的感觉。</p></div></div>    
</body>
</html>