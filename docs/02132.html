<html>
<head>
<title>Change Default Function Behavior in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">更改Python中的默认函数行为</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/changing-pythons-original-behavior-8a43b7d1c55d?source=collection_archive---------11-----------------------#2020-02-20">https://levelup.gitconnected.com/changing-pythons-original-behavior-8a43b7d1c55d?source=collection_archive---------11-----------------------#2020-02-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/4f04830c46c0e3ed26c6d8b334c0f2b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*uwnbPFUn6CuR0-dV.jpg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">Python中的恶作剧</figcaption></figure><p id="b12a" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">大家好，在这篇文章中，我们将讨论如何在Python中修改现有类方法或函数的原始行为。</p><h2 id="a636" class="ld le it bd lf lg lh dn li lj lk dp ll kq lm ln lo ku lp lq lr ky ls lt lu lv bi translated">你为什么需要它？</h2><p id="3b73" class="pw-post-body-paragraph kf kg it kh b ki lw kk kl km lx ko kp kq ly ks kt ku lz kw kx ky ma la lb lc im bi translated">有时你经常用相同值的参数调用一个函数。但是，有时您可能会忘记或错过一个没有指定该值的调用。使用<code class="fe mb mc md me b">partial</code>，您可以修改该函数的原始行为，并使其默认按照您想要的方式运行，而不必每次都指定。</p><h2 id="e943" class="ld le it bd lf lg lh dn li lj lk dp ll kq lm ln lo ku lp lq lr ky ls lt lu lv bi translated">你如何使用它？</h2><p id="d29c" class="pw-post-body-paragraph kf kg it kh b ki lw kk kl km lx ko kp kq ly ks kt ku lz kw kx ky ma la lb lc im bi translated"><code class="fe mb mc md me b">partial</code>的用法非常简单，让我们举一个简单的例子。</p><p id="277f" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">假设您总是使用<code class="fe mb mc md me b">pandas.read_csv</code>来读取一个tsv(制表符分隔值)文件，并且您不希望在解析一个错误的行时引发异常。您可以执行以下操作:</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="3389" class="ld le it me b gy mn mo l mp mq">from functools import partial<br/>import pandas as pd</span><span id="b80e" class="ld le it me b gy mr mo l mp mq">pd.read_csv = partial(pd.read_csv, sep='\t', error_bad_lines=False)</span></pre><p id="c6b9" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">此后对<code class="fe mb mc md me b">pd.read_csv</code>的每次调用都将默认使用制表符作为分隔符，而不是逗号。但是，如果仍然需要原来的行为呢？我们仍然可以做得更好，并通过执行以下操作来保留原始功能:</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="4a6f" class="ld le it me b gy mn mo l mp mq">pd.read_tsv = partial(pd.read_csv, sep='\t', error_bad_lines=False)</span></pre><p id="7fde" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">现在，我们有了自己的<code class="fe mb mc md me b">read_csv</code>版本，只处理tsv文件。所以，这给了我们一个不需要改变原始函数的单行实现。</p><h2 id="a160" class="ld le it bd lf lg lh dn li lj lk dp ll kq lm ln lo ku lp lq lr ky ls lt lu lv bi translated">它是如何工作的？</h2><p id="c593" class="pw-post-body-paragraph kf kg it kh b ki lw kk kl km lx ko kp kq ly ks kt ku lz kw kx ky ma la lb lc im bi translated">在Python中，一切正常。<code class="fe mb mc md me b">partial</code>只是一个函数，它接受一个函数和几个关键字参数，并返回该函数的修改版本。让我们试着从零开始实现(这只是一个简单的教育版):</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="1e29" class="ld le it me b gy mn mo l mp mq">def my_partial(func, *args, **kwargs):<br/>    def new_funct(*new_args, **new_kwargs):<br/>        new_kwargs.update(kwargs.copy())<br/>        return func(*args, *new_args, **kwargs)<br/>    return new_funct</span></pre><h2 id="b0fd" class="ld le it bd lf lg lh dn li lj lk dp ll kq lm ln lo ku lp lq lr ky ls lt lu lv bi translated">与函数一起工作！方法怎么样？</h2><p id="4a5e" class="pw-post-body-paragraph kf kg it kh b ki lw kk kl km lx ko kp kq ly ks kt ku lz kw kx ky ma la lb lc im bi translated">对于方法，我们总是用类似的方式来定义它们。</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="450c" class="ld le it me b gy mn mo l mp mq">class Example:<br/>   def my_method(self, arg1):<br/>       ...</span></pre><p id="43b9" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如果你用<code class="fe mb mc md me b">partial</code>来修补这个，那么<code class="fe mb mc md me b">self</code>参数就会被搞乱。Partial会将方法重定义为函数，这导致<code class="fe mb mc md me b">self</code>只是一个普通的参数。</p><p id="c1e7" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">对于方法，您将不得不使用来自<code class="fe mb mc md me b">functools</code>的<code class="fe mb mc md me b">partialmethod</code>。它允许您修补方法定义，而无需将它们更改为函数。在这种情况下，用法与<code class="fe mb mc md me b">partial</code>并无不同。</p><pre class="mf mg mh mi gt mj me mk ml aw mm bi"><span id="1a83" class="ld le it me b gy mn mo l mp mq">pd.DataFrame.to_tsv = partialmethod(pd.DataFrame.to_csv, sep='\t')</span></pre><p id="f7c1" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">现在，无论何时我们有了一个数据框架(例如<code class="fe mb mc md me b">df</code>),我们都可以马上调用<code class="fe mb mc md me b">df.to_tsv</code>。</p><h2 id="f24c" class="ld le it bd lf lg lh dn li lj lk dp ll kq lm ln lo ku lp lq lr ky ls lt lu lv bi translated">重要注意事项:</h2><ul class=""><li id="43e1" class="ms mt it kh b ki lw km lx kq mu ku mv ky mw lc mx my mz na bi translated">确保检查您的更改的范围，并确保如果您不小心导入，任何部分更改都不会影响整个项目。</li><li id="0878" class="ms mt it kh b ki nb km nc kq nd ku ne ky nf lc mx my mz na bi translated">您可以将原始函数存储在一个变量中，以便在需要时返回。</li><li id="992d" class="ms mt it kh b ki nb km nc kq nd ku ne ky nf lc mx my mz na bi translated">确保不要为文件名或要转换的值(例如<code class="fe mb mc md me b">partial(int, x=10)</code>)设置默认值，因为在某些情况下，您可能会无意中在内存中存储大型对象而没有意识到这一点。</li><li id="7ada" class="ms mt it kh b ki nb km nc kq nd ku ne ky nf lc mx my mz na bi translated">让你的队友知道你在代码库中的某个地方使用了<code class="fe mb mc md me b">partial</code>,否则，他们会带着不同的假设编码。</li></ul><h2 id="cf98" class="ld le it bd lf lg lh dn li lj lk dp ll kq lm ln lo ku lp lq lr ky ls lt lu lv bi translated">延伸阅读:</h2><ul class=""><li id="cfe9" class="ms mt it kh b ki lw km lx kq mu ku mv ky mw lc mx my mz na bi translated"><a class="ae ng" href="https://docs.python.org/3.8/library/functools.html#functools.partial" rel="noopener ugc nofollow" target="_blank">https://docs . python . org/3.8/library/func tools . html # func tools . partial</a></li><li id="f9d4" class="ms mt it kh b ki nb km nc kq nd ku ne ky nf lc mx my mz na bi translated">【https://en.wikipedia.org/wiki/Monkey_patch T4】</li></ul></div></div>    
</body>
</html>