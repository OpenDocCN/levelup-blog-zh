<html>
<head>
<title>Angular: The Single Rule To Get Better At RxJS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">角度:在RxJS上变得更好的唯一规则</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/angular-the-single-rule-to-get-better-at-rxjs-6bd9f9786429?source=collection_archive---------0-----------------------#2021-09-10">https://levelup.gitconnected.com/angular-the-single-rule-to-get-better-at-rxjs-6bd9f9786429?source=collection_archive---------0-----------------------#2021-09-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5165" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">帮助用RxJS以反应式编程方式开发angle应用程序和库的指南。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/02e93542e521d843d616b3e7f2a76a38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/0*nigHuCYvLjp9d92D.jpg"/></div></figure></div><div class="ab cl kq kr hx ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="im in io ip iq"><p id="bea9" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">尽管没有严格的规则，但是将命令式和声明式编程概念与<a class="ae lt" href="https://rxjs.dev/" rel="noopener ugc nofollow" target="_blank"> RxJS </a>结合起来可能会使开发更加困难，代码更加不干净。</p><p id="e084" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">将思维从(通常)默认的编程方式(即命令式)转变为反应式(即声明式)方法需要时间。</p><p id="c797" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">但是，有一个规则可以帮助您进行转换:</p><p id="f61d" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">⚠️做<strong class="kz iu">不</strong>亡国，期⚠️</p></div><div class="ab cl kq kr hx ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="im in io ip iq"><blockquote class="lu lv lw"><p id="7eab" class="kx ky lx kz b la lb ju lc ld le jx lf ly lh li lj lz ll lm ln ma lp lq lr ls im bi translated">对命令式和陈述式的区别感到困惑吗？看看比较两者的<a class="ae lt" href="https://twitter.com/joshuamorony" rel="noopener ugc nofollow" target="_blank">乔希莫罗尼</a>的优秀<a class="ae lt" href="https://eliteionic.com/tutorials/imperative-vs-declarative-programming-with-rxjs-search-filter/" rel="noopener ugc nofollow" target="_blank">篇</a>。</p></blockquote></div><div class="ab cl kq kr hx ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="im in io ip iq"><h1 id="1580" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">为什么？</h1><p id="2aef" class="pw-post-body-paragraph kx ky it kz b la mt ju lc ld mu jx lf lg mv li lj lk mw lm ln lo mx lq lr ls im bi translated">这个规则并不严格，它是一个准则，就像《加勒比海盗🏴‍☠️.守则》一样</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi my"><img src="../Images/ac3c5e455f26077649876b18ca78e8cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/0*VBCiXqgoBrlzo4tQ"/></div></figure><p id="eba7" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">这并不意味着你永远不应该订阅流，而是说，你应该尽量避免它。以这种方式，根据我的经验，你将慢慢地把命令式的编程方式转变成更多的声明式概念。</p><p id="b5f2" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">具体来说，在开发组件中的特性时，尽量使用在组件被破坏时自动取消订阅的<a class="ae lt" href="https://angular.io/" rel="noopener ugc nofollow" target="_blank"> Angular </a> <code class="fe mz na nb nc b">| async</code>管道，除了可以避免内存泄漏之外，还有助于改进编码风格。</p><p id="8b2c" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">为了探索这种操作方式，让我们重构一个混合了命令式和声明式编程概念的Angular应用程序。</p></div><div class="ab cl kq kr hx ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="im in io ip iq"><h1 id="4762" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">出发点</h1><p id="5b9c" class="pw-post-body-paragraph kx ky it kz b la mt ju lc ld mu jx lf lg mv li lj lk mw lm ln lo mx lq lr ls im bi translated">下面的演示使用<a class="ae lt" href="https://api.coinpaprika.com" rel="noopener ugc nofollow" target="_blank"> coinpaprika API </a>向用户显示加密货币列表。</p><p id="3141" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">代码源可在<a class="ae lt" href="https://github.com/peterpeterparker/rxjs-no-subscribe" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得。以下各章节(步骤<a class="ae lt" href="https://github.com/peterpeterparker/rxjs-no-subscribe/tree/step_1" rel="noopener ugc nofollow" target="_blank"> 1 </a>、<a class="ae lt" href="https://github.com/peterpeterparker/rxjs-no-subscribe/tree/step_2" rel="noopener ugc nofollow" target="_blank"> 2 </a>、<a class="ae lt" href="https://github.com/peterpeterparker/rxjs-no-subscribe/tree/step_3" rel="noopener ugc nofollow" target="_blank"> 3 </a>和<a class="ae lt" href="https://github.com/peterpeterparker/rxjs-no-subscribe/tree/step_4" rel="noopener ugc nofollow" target="_blank"> 4 </a>)是独立的分支。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi nd"><img src="../Images/204719b8b31dd33bbe62a8dba895a4f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yw5GBUxaeWBeC8bGIgMPlA.png"/></div></div></figure><p id="7481" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">它将HTTP查询委托给一个<code class="fe mz na nb nc b">coins.service</code>并在一个<code class="fe mz na nb nc b">coins.component</code>中呈现结果。</p></div><div class="ab cl kq kr hx ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="im in io ip iq"><h2 id="f0d3" class="ni mc it bd md nj nk dn mh nl nm dp ml lg nn no mn lk np nq mp lo nr ns mr nt bi translated">服务</h2><p id="7903" class="pw-post-body-paragraph kx ky it kz b la mt ju lc ld mu jx lf lg mv li lj lk mw lm ln lo mx lq lr ls im bi translated">提供者充当存储。它查询密码列表，过滤结果并保存在内存中。</p><p id="19ea" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">函数<code class="fe mz na nb nc b">list()</code>既是反应性的，通过告诉它想要什么(<code class="fe mz na nb nc b">httpClient.get</code>)，也是命令性的，通过检查和过滤结果。</p><pre class="kj kk kl km gt nu nc nv nw aw nx bi"><span id="ddd1" class="ni mc it nc b gy ny nz l oa ob">import { Injectable, OnDestroy } from '@angular/core';<br/>import { HttpClient } from '@angular/common/http';<br/><br/>import { Subject } from 'rxjs';<br/>import { takeUntil } from 'rxjs/operators';<br/><br/>export type Coin = Record&lt;string, string | number | boolean&gt;;<br/><br/>@Injectable({<br/>  providedIn: 'root'<br/>})<br/>export class CoinsService implements OnDestroy {<br/>  constructor(private httpClient: HttpClient) {}<br/><br/>  private coins: Coin[] = [];<br/><br/>  private destroy$: Subject&lt;void&gt; = new Subject();<br/><br/>  list() {<br/>    this.httpClient<br/>      .get&lt;Coin[]&gt;(`https://api.coinpaprika.com/v1/coins`)<br/>      .pipe(takeUntil(this.destroy$))<br/>      .subscribe((allCoins: Coin[]) =&gt; {<br/>        if (allCoins.length &gt; 10) {<br/>          this.coins = allCoins.filter(<br/>            (coin: Coin) =&gt;<br/>              !coin.is_new &amp;&amp; coin.rank &gt; 0 &amp;&amp; coin.rank &lt; 100<br/>          );<br/>        }<br/>      });<br/>  }<br/><br/>  getCoins(): Coin[] {<br/>    return this.coins;<br/>  }<br/><br/>  ngOnDestroy() {<br/>    this.destroy$.next();<br/>    this.destroy$.complete();<br/>  }<br/>}</span></pre></div><div class="ab cl kq kr hx ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="im in io ip iq"><h2 id="a54b" class="ni mc it bd md nj nk dn mh nl nm dp ml lg nn no mn lk np nq mp lo nr ns mr nt bi translated">成分</h2><p id="082c" class="pw-post-body-paragraph kx ky it kz b la mt ju lc ld mu jx lf lg mv li lj lk mw lm ln lo mx lq lr ls im bi translated">该组件初始化服务，并公开一个getter绑定来将结果解析到UI。</p><pre class="kj kk kl km gt nu nc nv nw aw nx bi"><span id="50e9" class="ni mc it nc b gy ny nz l oa ob">import { Component, OnInit } from '@angular/core';</span><span id="3007" class="ni mc it nc b gy oc nz l oa ob">import { CoinsService } from '../coins.service';<br/><br/>@Component({<br/>  selector: 'app-coins',<br/>  templateUrl: './coins.component.html',<br/>  styleUrls: ['./coins.component.css']<br/>})<br/>export class CoinsComponent implements OnInit {<br/>  constructor(private readonly coinsService: CoinsService) {}<br/><br/>  ngOnInit(): void {<br/>    this.coinsService.list();<br/>  }<br/><br/>  get coins() {<br/>    return this.coinsService.getCoins();<br/>  }<br/>}</span></pre></div><div class="ab cl kq kr hx ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="im in io ip iq"><h2 id="878c" class="ni mc it bd md nj nk dn mh nl nm dp ml lg nn no mn lk np nq mp lo nr ns mr nt bi translated">模板</h2><p id="891b" class="pw-post-body-paragraph kx ky it kz b la mt ju lc ld mu jx lf lg mv li lj lk mw lm ln lo mx lq lr ls im bi translated">HTML列出了硬币。</p><pre class="kj kk kl km gt nu nc nv nw aw nx bi"><span id="0a7a" class="ni mc it nc b gy ny nz l oa ob">&lt;article *ngFor="let coin of coins"&gt;<br/>  &lt;h1&gt;{{ coin.name }}&lt;/h1&gt;<br/>  &lt;p&gt;Symbol: {{ coin.symbol }}&lt;/p&gt;<br/>  &lt;p&gt;Rank: {{ coin.rank }}&lt;/p&gt;<br/>  &lt;hr /&gt;<br/>&lt;/article&gt;</span></pre></div><div class="ab cl kq kr hx ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="im in io ip iq"><h1 id="f5f3" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">步骤1:(更多)声明性</h1><p id="6d52" class="pw-post-body-paragraph kx ky it kz b la mt ju lc ld mu jx lf lg mv li lj lk mw lm ln lo mx lq lr ls im bi translated">尽管我在上面说过这条规则实际上是一条指导原则，但我还是建议<strong class="kz iu">永远不要</strong>订阅服务，分别对其在提供者中的应用比对在组件中的应用更严格，从而实际上避免内存泄漏。</p></div><div class="ab cl kq kr hx ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="im in io ip iq"><p id="746a" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">由于我们不想订阅，我们必须首先转换组件调用的方法，以返回一个<code class="fe mz na nb nc b">Observable</code>。</p><pre class="kj kk kl km gt nu nc nv nw aw nx bi"><span id="48fe" class="ni mc it nc b gy ny nz l oa ob">list(): Observable&lt;Coin[]&gt; {<br/>  return this.httpClient<br/>    .get&lt;Coin[]&gt;(`https://api.coinpaprika.com/v1/coins`)<br/>    ...<br/>}</span></pre><p id="7999" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">在没有任何其他改变的情况下，编译器会警告您返回值不匹配(因为我们仍在订阅流，因此实际上返回了一个<code class="fe mz na nb nc b">Subscription</code>)。这就是为什么我们用RxJS操作符替换了<code class="fe mz na nb nc b">subscribe</code>。在特殊情况下，我们使用<a class="ae lt" href="https://rxjs.dev/api/operators/tap" rel="noopener ugc nofollow" target="_blank"> tap </a>，因为我们仍然希望将结果分配给商店。</p><pre class="kj kk kl km gt nu nc nv nw aw nx bi"><span id="fe75" class="ni mc it nc b gy ny nz l oa ob">list(): Observable&lt;Coin[]&gt; {<br/>  return this.httpClient<br/>    .get&lt;Coin[]&gt;(`https://api.coinpaprika.com/v1/coins`)<br/>    .pipe(<br/>      tap((allCoins: Coin[]) =&gt; {<br/>        if (allCoins.length &gt; 10) {<br/>          this.coins = allCoins.filter(<br/>            (coin: Coin) =&gt;<br/>              !coin.is_new &amp;&amp; coin.rank &gt; 0 &amp;&amp; coin.rank &lt; 100<br/>          );<br/>        }<br/>      }),<br/>      takeUntil(this.destroy$))<br/>}</span></pre><p id="6b83" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">因为我们现在不再订阅了，所以我们可以移除<code class="fe mz na nb nc b">takeUntil</code>并让调用者处理它传输数据的方式。</p><pre class="kj kk kl km gt nu nc nv nw aw nx bi"><span id="d713" class="ni mc it nc b gy ny nz l oa ob">import { Injectable<strong class="nc iu"><em class="lx"> </em></strong>} from '@angular/core';<br/>import { HttpClient } from '@angular/common/http';<br/><br/>import { Observable } from 'rxjs';<br/>import { tap } from 'rxjs/operators';<br/><br/>export type Coin = Record&lt;string, string | number | boolean&gt;;<br/><br/>@Injectable({<br/>  providedIn: 'root'<br/>})<br/>export class CoinsService {<br/>  constructor(private httpClient: HttpClient) {}<br/><br/>  private coins: Coin[] = [];<br/><br/>  list(): Observable&lt;Coin[]&gt; {<br/>    return this.httpClient<br/>      .get&lt;Coin[]&gt;(`https://api.coinpaprika.com/v1/coins`)<br/>      .pipe(<br/>        tap((allCoins: Coin[]) =&gt; {<br/>          if (allCoins.length &gt; 10) {<br/>            this.coins = allCoins.filter(<br/>              (coin: Coin) =&gt;<br/>                !coin.is_new &amp;&amp; coin.rank &gt; 0 &amp;&amp; coin.rank &lt; 100<br/>            );<br/>          }<br/>        })<br/>      );<br/>  }<br/><br/>  getCoins(): Coin[] {<br/>    return this.coins;<br/>  }<br/>}</span></pre><p id="e701" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">代码已经变得更干净，不再有订阅和销毁生命周期，但是代码仍然混合了不同的方法。这就是为什么我们利用RxJS <a class="ae lt" href="https://rxjs.dev/api/operators/filter" rel="noopener ugc nofollow" target="_blank">过滤器</a>和<a class="ae lt" href="https://rxjs.dev/api/operators/map" rel="noopener ugc nofollow" target="_blank">映射</a>操作符使其更具反应性。</p><pre class="kj kk kl km gt nu nc nv nw aw nx bi"><span id="c254" class="ni mc it nc b gy ny nz l oa ob">list(): Observable&lt;Coin[]&gt; {<br/>  return this.httpClient<br/>    .get&lt;Coin[]&gt;(`https://api.coinpaprika.com/v1/coins`)<br/>    .pipe(<br/>      filter((allCoins: Coin[]) =&gt; allCoins.length &gt; 10),<br/>      map((allCoins: Coin[]) =&gt;<br/>        allCoins.filter(<br/>          (coin: Coin) =&gt;<br/>            !coin.is_new &amp;&amp; coin.rank &gt; 0 &amp;&amp; coin.rank &lt; 100<br/>        )<br/>      ),<br/>      tap((topCoins: Coin[]) =&gt; (this.coins = topCoins))<br/>    );<br/>}</span></pre><p id="c8ed" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">命令式<code class="fe mz na nb nc b">if</code>变成了反应式<code class="fe mz na nb nc b">filter</code>并且<code class="fe mz na nb nc b">array.filter</code>被移动到了<code class="fe mz na nb nc b">map</code>变压器。由于这些最后的修改，数据源流过描述我们想要的结果的流。</p></div><div class="ab cl kq kr hx ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="im in io ip iq"><h1 id="0f16" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">步骤2:订阅组件</h1><p id="96ef" class="pw-post-body-paragraph kx ky it kz b la mt ju lc ld mu jx lf lg mv li lj lk mw lm ln lo mx lq lr ls im bi translated">尽管代码仍在编译，但此时不再显示货币，因为没有调用者使用、订阅流。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi nd"><img src="../Images/79afc932c61b8c2789385b0d1c8f1884.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kNHqMcjFeNKFFOYNAZZMBg.png"/></div></div></figure><p id="f095" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">随着我们的迭代进行，我们基本上复制了我们之前在服务中移除的内容，我们在组件中订阅。</p><pre class="kj kk kl km gt nu nc nv nw aw nx bi"><span id="cd9b" class="ni mc it nc b gy ny nz l oa ob">import { Component, OnDestroy, OnInit } from '@angular/core';<br/><br/>import { Subject } from 'rxjs';<br/>import { takeUntil } from 'rxjs/operators';</span><span id="321c" class="ni mc it nc b gy oc nz l oa ob">import { CoinsService } from '../coins.service';</span><span id="c646" class="ni mc it nc b gy oc nz l oa ob">@Component({<br/>  selector: 'app-coins',<br/>  templateUrl: './coins.component.html',<br/>  styleUrls: ['./coins.component.css']<br/>})<br/>export class CoinsComponent implements OnInit, OnDestroy {<br/>  constructor(private readonly coinsService: CoinsService) {}<br/><br/>  private destroy$: Subject&lt;void&gt; = new Subject&lt;void&gt;();<br/><br/>  ngOnInit(): void {<br/>    this.coinsService<br/>      .list()<br/>      .pipe(takeUntil(this.destroy$))<br/>      .subscribe(() =&gt; {});<br/>  }<br/><br/>  ngOnDestroy() {<br/>    this.destroy$.next();<br/>    this.destroy$.complete();<br/>  }<br/><br/>  get coins() {<br/>    return this.coinsService.getCoins();<br/>  }<br/>}</span></pre><p id="8ea4" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">我知道，我说过“永远不要订阅”，这不是结束😉。然而，我们注意到密码再次被列出。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi nd"><img src="../Images/2e3d38c942e444f2b4e7549d16adfb23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HB1cJ9j7em8iz4QodbUvHg.png"/></div></div></figure></div><div class="ab cl kq kr hx ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="im in io ip iq"><h1 id="9ec2" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">步骤3:异步管道</h1><p id="92bb" class="pw-post-body-paragraph kx ky it kz b la mt ju lc ld mu jx lf lg mv li lj lk mw lm ln lo mx lq lr ls im bi translated">为了达到我们的最终目标，我们想要移除组件中的订阅，以便利用<code class="fe mz na nb nc b">| async</code>管道。因此，我们必须改进我们的服务。另一方面，我们还是想让它充当商店的角色。</p><p id="7342" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">这就是为什么，作为一个中间步骤，我们用一个<a class="ae lt" href="https://rxjs.dev/api/index/class/BehaviorSubject" rel="noopener ugc nofollow" target="_blank">行为主体</a>替换服务的命令状态<code class="fe mz na nb nc b">coins</code>，这是一种特殊类型的可观察对象，允许将值多播给许多观察者(<a class="ae lt" href="https://rxjs.dev/guide/subject" rel="noopener ugc nofollow" target="_blank">源</a>)，并将其作为<code class="fe mz na nb nc b">readonly Observable</code>变量公开公开。</p><pre class="kj kk kl km gt nu nc nv nw aw nx bi"><span id="cc9c" class="ni mc it nc b gy ny nz l oa ob">import { Injectable<strong class="nc iu"><em class="lx"> </em></strong>} from '@angular/core';<br/>import { HttpClient } from '@angular/common/http';<br/><br/>import { BehaviorSubject, Observable } from 'rxjs';<br/>import { filter, map, tap } from 'rxjs/operators';<br/><br/>export type Coin = Record&lt;string, string | number | boolean&gt;;<br/><br/>@Injectable({<br/>  providedIn: 'root'<br/>})<br/>export class CoinsService {<br/>  constructor(private httpClient: HttpClient) {}<br/><br/>  private coins: BehaviorSubject&lt;Coin[]&gt; = new BehaviorSubject&lt;<br/>    Coin[]<br/>  &gt;([]);<br/><br/>  readonly coins$: Observable&lt;Coin[]&gt; = this.coins.asObservable();<br/><br/>  list(): Observable&lt;Coin[]&gt; {<br/>    return this.httpClient<br/>      .get&lt;Coin[]&gt;(`https://api.coinpaprika.com/v1/coins`)<br/>      .pipe(<br/>        filter((allCoins: Coin[]) =&gt; allCoins.length &gt; 10),<br/>        map((allCoins: Coin[]) =&gt;<br/>          allCoins.filter(<br/>            (coin: Coin) =&gt;<br/>              !coin.is_new &amp;&amp; coin.rank &gt; 0 &amp;&amp; coin.rank &lt; 100<br/>          )<br/>        ),<br/>        tap((topCoins: Coin[]) =&gt; this.coins.next(topCoins))<br/>      );<br/>  }<br/>}</span></pre><p id="c625" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">与我们以前的变化相比，这是突破性的。这就是为什么我们必须修改组件来删除<code class="fe mz na nb nc b">getter</code>，并用一个我们最终可以在模板中使用的可观察对象来替换它。</p><pre class="kj kk kl km gt nu nc nv nw aw nx bi"><span id="3e0f" class="ni mc it nc b gy ny nz l oa ob">import { Component, OnDestroy, OnInit } from '@angular/core';<br/><br/>import { Observable, Subject } from 'rxjs';<br/>import { takeUntil } from 'rxjs/operators';<br/><br/>import { Coin, CoinsService } from '../coins.service';<br/><br/>@Component({<br/>  selector: 'app-coins',<br/>  templateUrl: './coins.component.html',<br/>  styleUrls: ['./coins.component.css']<br/>})<br/>export class CoinsComponent implements OnInit, OnDestroy {<br/>  constructor(private readonly coinsService: CoinsService) {}<br/><br/>  private destroy$: Subject&lt;void&gt; = new Subject&lt;void&gt;();<br/><br/>  coins$: Observable&lt;Coin[]&gt; = this.coinsService.coins$;<br/><br/>  ngOnInit(): void {<br/>    this.coinsService<br/>      .list()<br/>      .pipe(takeUntil(this.destroy$))<br/>      .subscribe(() =&gt; {});<br/>  }<br/><br/>  ngOnDestroy() {<br/>    this.destroy$.next();<br/>    this.destroy$.complete();<br/>  }<br/>}</span></pre><p id="7720" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">最后，我们介绍一下著名的<code class="fe mz na nb nc b">async</code>烟斗。</p><pre class="kj kk kl km gt nu nc nv nw aw nx bi"><span id="06b9" class="ni mc it nc b gy ny nz l oa ob">&lt;article <em class="lx">*</em>ngFor="let coin<strong class="nc iu"><em class="lx"> </em></strong>of coins$ | async"&gt;</span></pre></div><div class="ab cl kq kr hx ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="im in io ip iq"><h1 id="b1ae" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">步骤4:没有订阅和反应</h1><p id="5324" class="pw-post-body-paragraph kx ky it kz b la mt ju lc ld mu jx lf lg mv li lj lk mw lm ln lo mx lq lr ls im bi translated">我们当前的解决方案非常接近目标，我们使用流来获取数据并显示结果，但是我们仍然需要订阅来触发货币加载。</p><p id="52b4" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">这就是为什么我们试图删除主题。</p><pre class="kj kk kl km gt nu nc nv nw aw nx bi"><span id="d780" class="ni mc it nc b gy ny nz l oa ob">import { Injectable<strong class="nc iu"><em class="lx"> </em></strong>} from '@angular/core';<br/>import { HttpClient } from '@angular/common/http';<br/><br/>import { Observable } from 'rxjs';<br/>import { filter, map } from 'rxjs/operators';<br/><br/>export type Coin = Record&lt;string, string | number | boolean&gt;;<br/><br/>@Injectable({<br/>  providedIn: 'root'<br/>})<br/>export class CoinsService {<br/>  constructor(private httpClient: HttpClient) {}<br/><br/>  readonly coins$: Observable&lt;Coin[]&gt; = ... // &lt;- TODO<br/><br/>  list(): Observable&lt;Coin[]&gt; {<br/>    return this.httpClient<br/>      .get&lt;Coin[]&gt;(`https://api.coinpaprika.com/v1/coins`)<br/>      .pipe(<br/>        filter((allCoins: Coin[]) =&gt; allCoins.length &gt; 10),<br/>        map((allCoins: Coin[]) =&gt;<br/>          allCoins.filter(<br/>            (coin: Coin) =&gt;<br/>              !coin.is_new &amp;&amp; coin.rank &gt; 0 &amp;&amp; coin.rank &lt; 100<br/>          )<br/>        )<br/>      );<br/>  }<br/>}</span></pre><p id="0a25" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">我们注意到暴露的可观察对象<code class="fe mz na nb nc b">coins$</code>，现在缺少了一个来源。</p><p id="005a" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">另一方面，我们仍然有处理数据流的流。</p><p id="be8f" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">是的，没错，我们把两者联系起来。</p><pre class="kj kk kl km gt nu nc nv nw aw nx bi"><span id="b1c1" class="ni mc it nc b gy ny nz l oa ob">readonly coins$: Observable&lt;Coin[]&gt; = this.httpClient<br/>  .get&lt;Coin[]&gt;(`https://api.coinpaprika.com/v1/coins`)<br/>  .pipe(<br/>    filter((allCoins: Coin[]) =&gt; allCoins.length &gt; 10),<br/>    map((allCoins: Coin[]) =&gt;<br/>      allCoins.filter(<br/>        (coin: Coin) =&gt;<br/>          !coin.is_new &amp;&amp; coin.rank &gt; 0 &amp;&amp; coin.rank &lt; 100<br/>      )<br/>    )<br/>  );</span></pre><p id="325e" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">然而，这样做的话，由于使用了BehaviorSubject，我们确实失去了原有的状态管理特性。这就是为什么我们引入了一个<a class="ae lt" href="https://rxjs.dev/api/operators/shareReplay" rel="noopener ugc nofollow" target="_blank"> shareReplay </a>，它也将重放值，这也将使我们的服务充当一个商店。</p><pre class="kj kk kl km gt nu nc nv nw aw nx bi"><span id="3d0d" class="ni mc it nc b gy ny nz l oa ob">import { Injectable<strong class="nc iu"><em class="lx"> </em></strong>} from '@angular/core';<br/>import { HttpClient } from '@angular/common/http';<br/><br/>import { Observable } from 'rxjs';<br/>import {filter, map, shareReplay} from 'rxjs/operators';<br/><br/>export type Coin = Record&lt;string, string | number | boolean&gt;;<br/><br/>@Injectable({<br/>  providedIn: 'root'<br/>})<br/>export class CoinsService {<br/>  constructor(private httpClient: HttpClient) {}<br/><br/>  readonly coins$: Observable&lt;Coin[]&gt; = this.httpClient<br/>    .get&lt;Coin[]&gt;(`https://api.coinpaprika.com/v1/coins`)<br/>    .pipe(<br/>      filter((allCoins: Coin[]) =&gt; allCoins.length &gt; 10),<br/>      map((allCoins: Coin[]) =&gt;<br/>        allCoins.filter(<br/>          (coin: Coin) =&gt;<br/>            !coin.is_new &amp;&amp; coin.rank &gt; 0 &amp;&amp; coin.rank &lt; 100<br/>        )<br/>      ),<br/>      shareReplay({ bufferSize: 1, refCount: true })<br/>    );<br/>}</span></pre><blockquote class="lu lv lw"><p id="6813" class="kx ky lx kz b la lb ju lc ld le jx lf ly lh li lj lz ll lm ln ma lp lq lr ls im bi translated">如果您以前从未使用过shareReplay，请在使用时小心。在<a class="ae lt" href="http://kwintenp" rel="noopener ugc nofollow" target="_blank">kwi ten Pisman</a>的<a class="ae lt" href="https://blog.strongbrew.io/share-replay-issue/" rel="noopener ugc nofollow" target="_blank">博客文章</a>中阅读更多信息。</p></blockquote><p id="df76" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">最后，我们可以删除组件中的最后一个订阅，以及所有链接到目标的代码，以处理取消订阅。</p><pre class="kj kk kl km gt nu nc nv nw aw nx bi"><span id="0d64" class="ni mc it nc b gy ny nz l oa ob">import { Component<strong class="nc iu"><em class="lx"> </em></strong>} from '@angular/core';<br/><br/>import { Observable } from 'rxjs';<br/><br/>import { Coin, CoinsService } from '../coins.service';<br/><br/>@Component({<br/>  selector: 'app-coins',<br/>  templateUrl: './coins.component.html',<br/>  styleUrls: ['./coins.component.css']<br/>})<br/>export class CoinsComponent {<br/>  constructor(private readonly coinsService: CoinsService) {}<br/><br/>  readonly coins$: Observable&lt;Coin[]&gt; = this.coinsService.coins$;<br/>}</span></pre><p id="c7e4" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">如果与它的原始版本相比，组件不是变得非常简洁和易于理解了吗？</p><p id="6a6d" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">对GUI的最后一次检查。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi nd"><img src="../Images/2e3d38c942e444f2b4e7549d16adfb23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HB1cJ9j7em8iz4QodbUvHg.png"/></div></div></figure><p id="da6b" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">所有的密码仍然列出，代码是反应性的，我们不再使用任何“订阅”了🥳.</p></div><div class="ab cl kq kr hx ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="im in io ip iq"><h1 id="0364" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">摘要</h1><p id="23d7" class="pw-post-body-paragraph kx ky it kz b la mt ju lc ld mu jx lf lg mv li lj lk mw lm ln lo mx lq lr ls im bi translated">在Angular中尝试不使用RxJS并不是最终的结果，也不是一个严格的规则，但是，当作为一个指南应用时，可以帮助使代码更干净和更具反应性，可以帮助在RxJS中获得更好的体验和时间。</p><p id="ce36" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">到无限和更远的地方！</p><p id="2d65" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">大卫</p></div><div class="ab cl kq kr hx ks" role="separator"><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv kw"/><span class="kt bw bk ku kv"/></div><div class="im in io ip iq"><p id="54de" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">你可以通过推特或我的<a class="ae lt" href="https://daviddalbusco.com/" rel="noopener ugc nofollow" target="_blank">网站</a>联系我。</p><p id="2396" class="pw-post-body-paragraph kx ky it kz b la lb ju lc ld le jx lf lg lh li lj lk ll lm ln lo lp lq lr ls im bi translated">尝试一下<a class="ae lt" href="https://deckdeckgo.com/" rel="noopener ugc nofollow" target="_blank"> DeckDeckGo </a>，为你的下一个演示做准备。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><a href="https://deckdeckgo.com"><div class="gh gi od"><img src="../Images/2cc3dd6430bc3cb8fac6490468fbcf4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Wyp73BsMrFi8E4n_.png"/></div></a></figure></div></div>    
</body>
</html>