<html>
<head>
<title>Built-in Bash Parameters That Every Developer Should Know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">每个开发人员都应该知道的内置Bash参数</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/built-in-bash-parameters-that-every-developer-should-know-b6d7b73ccb7a?source=collection_archive---------5-----------------------#2022-07-03">https://levelup.gitconnected.com/built-in-bash-parameters-that-every-developer-should-know-b6d7b73ccb7a?source=collection_archive---------5-----------------------#2022-07-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6496" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用这些语法高效地编写干净的Shell脚本</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/39b89a2fd92ee27ec2a2830a2cc243f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f3wGXU6KmbZ1fNKac9hWtQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@claybanks?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">粘土银行</a>在<a class="ae ky" href="https://unsplash.com/s/photos/coding?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄，用Canva编辑</figcaption></figure><p id="ed5e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现代操作系统提供了两种用户交互机制:CLI和GUI。用户通常在终端程序中输入各种命令，通过CLI执行操作。另一方面，他们可以用鼠标或触摸屏等指示设备来操作GUI。由于灵活性、自动化支持、生产率和类似编程的语法，大多数程序员更喜欢使用面向CLI的方法。</p><p id="9c2e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Bash现在通过提供一个最小的命令-进程转换器和一个全功能的命令语言，帮助每个Unix/类Unix用户使用终端。DevOps工程师和程序员倾向于选择Bash来编写自动化脚本、实用程序脚本，甚至通用程序。了解鲜为人知的有用的Bash语法对所有程序员来说确实是一件好事。</p><p id="3ccb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Bash世界中，<a class="ae ky" href="https://www.gnu.org/software/bash/manual/html_node/Shell-Parameters.html" rel="noopener ugc nofollow" target="_blank">参数</a>指的是程序员在脚本执行期间可以用来存储数据的元素。Bash有三种参数类型:变量、位置参数和特殊参数。让我们用一些实际的例子来讨论这些参数类型——然后，您可以在您即将到来的自动化脚本中使用它们！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7acd" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">在脚本范围和函数范围中使用位置参数</h1><p id="132c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">有几种方法可以获得特定Bash脚本的附加输入。如果我们正在为人类编写一个Shell脚本，我们可以使用<code class="fe mz na nb nc b">read</code>内置命令以一种用户友好的方式从键盘捕获用户输入。如果我们创建的DevOps或实用程序脚本在脚本执行期间不需要友好的用户交互，我们可以使用命令行参数。位置参数帮助我们以索引的方式访问进程参数列表，就像c语言中的<code class="fe mz na nb nc b">argc</code>。</p><p id="c3f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请看下面的脚本，它显示了前两个整数参数值的总和:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="377a" class="nh md it nc b gy ni nj l nk nl">#!/bin/bash</span><span id="8fe0" class="nh md it nc b gy nm nj l nk nl">sum=$(($1 + $2))<br/>echo "sum = $sum"</span></pre><p id="0270" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码片段对前两个位置参数使用算术展开来获得总和。类似地，<code class="fe mz na nb nc b">$n</code>参数指的是<code class="fe mz na nb nc b">nth</code>命令行参数值。在函数内部，这些位置参数与函数参数进行映射，如下面的代码示例所示:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="994e" class="nh md it nc b gy ni nj l nk nl">#!/bin/bash</span><span id="7e28" class="nh md it nc b gy nm nj l nk nl">function sum() {<br/>    echo $(($1 + $2))<br/>}</span><span id="5e5b" class="nh md it nc b gy nm nj l nk nl">read -p "Enter num1: " n1<br/>read -p "Enter num2: " n2</span><span id="73f4" class="nh md it nc b gy nm nj l nk nl">echo "sum = $(sum $n1 $n2)"</span></pre><p id="d01e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们需要处理动态索引的参数呢？然后，我们可以解析整个参数列表，或者通过<code class="fe mz na nb nc b">$@</code>迭代，或者通过<a class="ae ky" href="https://www.gnu.org/software/bash/manual/html_node/Shell-Parameter-Expansion.html" rel="noopener ugc nofollow" target="_blank">间接扩展</a>访问每个参数，如下所示。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="42ae" class="nh md it nc b gy ni nj l nk nl">#!/bin/bash</span><span id="8c7d" class="nh md it nc b gy nm nj l nk nl">function parse_with_for_in() {<br/>    for arg in "$@"<br/>    do<br/>        echo $arg<br/>    done<br/>}</span><span id="afa7" class="nh md it nc b gy nm nj l nk nl">function parse_with_expansion() {<br/>    for ((i = 1; i &lt;= $#; i++))<br/>    do<br/>        echo ${!i} # Indirect expansion syntax<br/>    done<br/>}</span><span id="1e8d" class="nh md it nc b gy nm nj l nk nl">parse_with_for_in "$@"<br/>echo "---"<br/>parse_with_expansion "$@"</span></pre><p id="ec5d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第一个函数包含一个遍历所有参数的for-in循环。第二个函数通过索引提取参数值。例如，当<code class="fe mz na nb nc b">i</code>是<code class="fe mz na nb nc b">2</code>时，间接扩展首先构造<code class="fe mz na nb nc b">$2</code>，然后找到第二个参数的值。看下面的预告:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/8e2b701c286b4c6974f1b3f32bd75bd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Jlcmqg15BmoBolPnmt6URA.gif"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">在Bash中使用流程参数，作者截图</figcaption></figure><p id="3f51" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们提取第一个和第二个参数时，您也可以使用<code class="fe mz na nb nc b">$0</code>参数找到当前脚本的文件名。我们可以通过在上面的for-loop中添加一个<code class="fe mz na nb nc b">case</code>语句来用Bash开发完整的CLI程序。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6513" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">用特殊参数处理子进程</h1><p id="9ba7" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Bash是一个Shell解释程序和一种命令语言——因此您可以编写大部分脚本逻辑，而无需生成子进程。例如，由于众所周知的参数扩展特性，您可以在Bash中进行字符串操作、数组处理和基本的算术运算。然而，我们通常使用Bash来开发实用程序和DevOps脚本，因此使用子进程是不可避免的。</p><p id="98f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们通过Bash顺序执行其他二进制文件，因此Bash提供了<code class="fe mz na nb nc b">$?</code>参数来获取最近终止的进程的退出代码。执行命令并查看退出状态，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/e5e24b672317ba246dad4f1c9d086391.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*w9IF5J1IHN1ZMpAJ-ZykXA.gif"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">查找最近进程的退出代码，作者截图</figcaption></figure><p id="5e68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Bash还允许您使用<code class="fe mz na nb nc b">&amp;</code>符号在后台运行进程。如果您需要终止之前生成的后台命令，该怎么办？<code class="fe mz na nb nc b">$!</code>参数返回前一个后台命令的进程标识符(<a class="ae ky" href="https://en.wikipedia.org/wiki/Process_identifier" rel="noopener ugc nofollow" target="_blank"> PID </a>)。以下脚本打开gedit五秒钟:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="92b7" class="nh md it nc b gy ni nj l nk nl">#!/bin/bash</span><span id="4b0b" class="nh md it nc b gy nm nj l nk nl">gedit &amp;<br/>sleep 5<br/>kill $!</span></pre><p id="fb7e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您处理多个后台任务，请将<code class="fe mz na nb nc b">$!</code>值保存在临时变量中。<code class="fe mz na nb nc b">$$</code>参数返回当前Bash进程的进程标识符。在子shells中，它总是返回父Bash进程的标识符。一些旧的bash脚本使用<code class="fe mz na nb nc b">$$</code>来创建唯一的临时文件，但是它创建了可预测的临时文件，并为攻击者制造了一个<a class="ae ky" href="https://www.gnu.org/software/coreutils/manual/html_node/mktemp-invocation.html" rel="noopener ugc nofollow" target="_blank">漏洞</a>，所以使用<code class="fe mz na nb nc b">mktemp</code>命令来创建安全的临时文件。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="cceb" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">帮助我们高效调试Bash脚本的预定义变量</h1><p id="271c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">许多程序员使用<code class="fe mz na nb nc b">echo</code>命令调试Bash脚本，就像他们在JavaScript调试中使用<code class="fe mz na nb nc b">console.log</code>一样。对于开发简单的Bash脚本来说，这种方法无疑更加舒适和快速。但是，如果在一个特定的Bash脚本中处理更多的数据并执行许多命令，这种方法就会变得非常耗时。</p><p id="1e8e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如许多DevOps工程师所知，我们可以使用<code class="fe mz na nb nc b">-x</code>或<code class="fe mz na nb nc b">-xv</code> (verbose)标志来执行Bash解释器进程，以分别显示当前命令和代码片段。默认情况下，Bash将显示当前命令字符串的前缀<code class="fe mz na nb nc b">+</code>，如下面的预览所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/35ec85edac69598e29b7a56d82cb1898.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bzBWYEIVjNXGs2Hr8hCfxw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">调试Bash脚本，作者截图</figcaption></figure><p id="b45e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，这里我使用了下面的Shebang行来启用调试:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="6021" class="nh md it nc b gy ni nj l nk nl">#!/bin/bash -x</span></pre><p id="e85a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您稍后在脚本中调用<code class="fe mz na nb nc b">set -x</code>时，也会发生同样的行为。</p><p id="d8a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，我们可以使用内置的<code class="fe mz na nb nc b">PS4</code>和<code class="fe mz na nb nc b">LINENO</code>局部变量来使我们的调试任务更加高效！请看下面的代码片段:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="3763" class="nh md it nc b gy ni nj l nk nl">#!/bin/bash</span><span id="b854" class="nh md it nc b gy nm nj l nk nl">green='tput setaf 2'<br/>reset='tput sgr0'<br/>PS4='$($green)Line: $LINENO -&gt; $($reset)'</span><span id="731b" class="nh md it nc b gy nm nj l nk nl">set -x</span><span id="fe51" class="nh md it nc b gy nm nj l nk nl">a=10<br/>b=15</span><span id="6b7d" class="nh md it nc b gy nm nj l nk nl">echo "a = $a"<br/>echo "b = $b"</span></pre><p id="56a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在前面的例子中，<code class="fe mz na nb nc b">PS4</code>局部变量保存默认字符<code class="fe mz na nb nc b">+</code>作为指示当前命令的前缀。但是，现在我们将其定制为以绿色显示行号，如下所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/6770ca4e643ef2a0abf4d890f2528b6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*httyGIUMwn44YluVQEQCsg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">调试Bash脚本，作者截图</figcaption></figure><p id="9cb8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您需要调试一个导入多个源文件的Bash脚本，那么您可以使用<code class="fe mz na nb nc b">BASH_SOURCE</code>局部变量来显示带有<code class="fe mz na nb nc b">PS4</code>的当前脚本文件名。Bash还为您提供了<code class="fe mz na nb nc b">FUNCNAME</code>局部变量来获取当前的函数调用栈，您可以使用<code class="fe mz na nb nc b">${FUNCNAME[0]}</code>(或者仅仅是<code class="fe mz na nb nc b">$FUNCNAME</code>)来查找当前的函数名。</p><p id="bada" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">定义一个自定义的<code class="fe mz na nb nc b">PS4</code>作为全局变量，比如<a class="ae ky" href="https://stackoverflow.com/a/17805088/3565513" rel="noopener ugc nofollow" target="_blank"> this </a>来更快地调试Bash脚本！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="b1ad" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">像Python一样用IFS变量分割字符串</h1><p id="16e7" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们经常不得不在Bash脚本中处理字符串拆分任务。例如，在某些情况下，我们必须通过用逗号字符分割每一行来处理CSV文件。此外，有时，我们需要根据输入掩码用<code class="fe mz na nb nc b">read</code>命令捕获键盘输入。我们可以用IFS(内部字段分隔符)轻松处理这些场景。IFS是一个内部变量，它指示Bash将单词段与字符串分开。</p><p id="87e4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">IFS</code>变量的默认值是<code class="fe mz na nb nc b">&lt;space&gt;&lt;tab&gt;&lt;newline&gt;</code>，但是你可以根据自己的需要进行编辑，重新设置回原来的值。让我们从一个简单的例子开始。假设您想让用户输入一个<code class="fe mz na nb nc b">NN-NNNN</code>格式的序列号，并将两个屏蔽段保存在不同的变量中。默认情况下，<code class="fe mz na nb nc b">read</code>命令根据默认的<code class="fe mz na nb nc b">IFS</code>处理输入，但我们确实可以修改如下:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="2e49" class="nh md it nc b gy ni nj l nk nl">#!/bin/bash</span><span id="5ad7" class="nh md it nc b gy nm nj l nk nl">IFS=-<br/>read -p "Serial number (i.e., 12-2222): " seg1 seg2</span><span id="cb06" class="nh md it nc b gy nm nj l nk nl">echo "Segment 1: $seg1"<br/>echo "Segment 2: $seg2"</span></pre><p id="7f26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，您可以将这两个序列号段读入单独的变量，如以下预览所示:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nn"><img src="../Images/3ad34a834b88aafd08a7d216ef67518e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*zZHgRw-tLNlR7lFXZGs1YQ.gif"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">用IFS自定义read命令，作者截图</figcaption></figure><p id="edd6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用这种方法，您可以编写脚本来解析CSV文件，而无需使用外部二进制文件，如<code class="fe mz na nb nc b">sed</code>、<code class="fe mz na nb nc b">awk</code>或<a class="ae ky" href="https://betterprogramming.pub/bash-vs-python-vs-javascript-which-is-better-for-automation-92a277ef49e" rel="noopener ugc nofollow" target="_blank"> Python </a>。你可以从<a class="ae ky" href="https://github.com/shalithasuranga/bash-csv-parser-example" rel="noopener ugc nofollow" target="_blank">这里</a>看到一个示例CSV解析器脚本。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a487" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">在终端中检索Bash历史以提高生产率</h1><p id="7cf4" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">前面，我们讨论了使用一些内置的预定义参数高效地编写Shell脚本。让我们讨论一些Bash符号，它们有助于更快地使用终端。正如您已经知道的，Bash将命令历史存储在<code class="fe mz na nb nc b">~/.bash_history</code>文件中，我们可以用<code class="fe mz na nb nc b">history</code>命令浏览历史记录。</p><p id="0f7c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Bash提供了一些访问历史记录的快捷方式。例如，您可以使用以下符号来访问以前输入的命令:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="8cb0" class="nh md it nc b gy ni nj l nk nl">!-1   # Previous command. Alias: !!<br/>!-2   # Second command in history records<br/>!-3   # Third command in history records</span></pre><p id="9543" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些不是内置参数——而是一种被称为<a class="ae ky" href="https://www.gnu.org/software/bash/manual/html_node/History-Interaction.html" rel="noopener ugc nofollow" target="_blank">历史扩展</a>的特殊语法。您可以用<code class="fe mz na nb nc b">HISTSIZE</code>、<code class="fe mz na nb nc b">HISTTIMEFORMAT</code> —类变量配置历史文件。</p><p id="8b6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mz na nb nc b">$_</code>参数也有助于获得前一个命令的最后一个选项，因此我们可以跳过如下冗长的命令选项的重复输入:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="99ed" class="nh md it nc b gy ni nj l nk nl">touch long_file_name.sh<br/>chmod +x $_</span></pre><p id="7dff" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">下面的故事解释了更多的生产力技巧:</p><div class="nq nr gp gr ns nt"><a rel="noopener  ugc nofollow" target="_blank" href="/5-lesser-known-linux-terminal-tips-and-experiments-f14ac5739ea8"><div class="nu ab fo"><div class="nv ab nw cl cj nx"><h2 class="bd iu gy z fp ny fr fs nz fu fw is bi translated">5个鲜为人知的Linux终端技巧和实验</h2><div class="oa l"><h3 class="bd b gy z fp ny fr fs nz fu fw dk translated">开始试验您的终端，并找到新的方法来提高您的编程效率</h3></div><div class="ob l"><p class="bd b dl z fp ny fr fs nz fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="oc l"><div class="od l oe of og oc oh ks nt"/></div></div></a></div></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="720d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢阅读。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="8755" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">分级编码</h1><p id="8aa4" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">感谢您成为我们社区的一员！更多内容请参见<a class="ae ky" href="https://levelup.gitconnected.com/" rel="noopener ugc nofollow" target="_blank">升级编码出版物</a>。<br/>跟随:<a class="ae ky" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">推特</a>，<a class="ae ky" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank">领英</a>，<a class="ae ky" href="https://newsletter.levelup.dev/" rel="noopener ugc nofollow" target="_blank">通迅</a> <br/> <strong class="lb iu">升一级正在转型的理工大招聘➡️ </strong> <a class="ae ky" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">加入我们的人才集体</strong> </a></p></div></div>    
</body>
</html>