<html>
<head>
<title>Python features that you will miss in TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">您将在TypeScript中错过的Python特性</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/python-features-that-you-will-miss-in-typescript-78ecc440b8bc?source=collection_archive---------5-----------------------#2021-08-30">https://levelup.gitconnected.com/python-features-that-you-will-miss-in-typescript-78ecc440b8bc?source=collection_archive---------5-----------------------#2021-08-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4453" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">有时候，当你失去一样东西时，你才会真正珍惜它</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/bf1dc078bac556935b07ce0299540b6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*G6G1IweBv411ufK9"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">亚历克斯·丘马克在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="0afd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最近，我从python和django作为主要的后端语言切换到带有TypeScript的node.js。经过一段时间的学习，我可以说我喜欢这种转变。看到不同的语言和框架如何解决相似的问题总是很有趣。当您理解他们在方法上的一致或不同之处时，您就对编程本身有了更好的理解。</p><p id="0fb3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在许多方面，TypeScript/JavaScript和python是相似的。他们都是</p><ul class=""><li id="bd3b" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">…拥有现代语法</li><li id="481d" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">…最好保留为单线程应用程序</li><li id="f027" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">…最初是动态语言，后来添加了静态类型检查</li><li id="f9b0" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">…拥有一个包含许多模块/包的大型生态系统</li><li id="dbdc" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">…支持带有承诺和异步/等待的异步编程</li><li id="c0fb" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">…相当频繁地发布新版本(对于一种语言)</li></ul><p id="593c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是语言之间当然存在一些差异，有时需要一点距离才能完全理解python及其生态系统提供的特性。虽然我总体上喜欢用TypeScript编码，但有时我会遇到一些问题，我知道这些问题可以用python很好地解决。大多数情况下，TypeScript/JavaScript提供了一个类似的优雅解决方案，但有时我发现自己运气不好，最终我得到了一些我知道用python可以容易得多的东西。下面是我列出的一些特性，当你使用python时，这些特性很容易被认为是理所当然的，但是当你不得不在没有它们的情况下编码时，这些特性就会被忽略:上下文管理器、对类型的一级支持、数据库框架、pytest fixtures和字典理解。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="af5a" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">上下文管理器</h1><p id="b533" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">python中的上下文管理器有很多用例，比如打开和关闭文件，用锁保护代码，或者用设置和拆除来定制资源管理。当我在我们的后端工作时，我真的开始想念他们，我们需要数据库事务。在python中，这个问题得到了很好的解决。事实上，很多库，比如<a class="ae ky" href="https://docs.djangoproject.com/en/3.2/topics/db/transactions/" rel="noopener ugc nofollow" target="_blank"> django </a>，已经为此提供了上下文管理器！</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">python中的典型DB事务(上下文管理器可能由库提供)</figcaption></figure><p id="e817" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于TypeScript，我们使用了<a class="ae ky" href="https://node-postgres.com/features/transactions" rel="noopener ugc nofollow" target="_blank"> node-postgres </a>，python中最接近上下文管理器的解决方案涉及回调。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">带有TypeScript的典型数据库事务</figcaption></figure><p id="3926" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然这不是有史以来最差的实现，但不如pythons干净。如果你在async/await之前去过JavaScript的<a class="ae ky" href="https://www.geeksforgeeks.org/what-is-callback-hell-in-node-js/" rel="noopener ugc nofollow" target="_blank">回调地狱</a>，可能会触发PTSD。库不提供这个接口，所以你必须自己实现它，否则你最终会有很多try/catch博客来处理你的事务。我至少有一次犯了这样的错误，这导致了一个bug，幸运的是我在它投入生产之前就发现了它。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="37bc" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">对类型的一阶支持</h1><p id="6f51" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">在python中，我通常使用一个<code class="fe np nq nr ns b">dataclass</code>来定义消息的模式，用TypeScript声明一个<code class="fe np nq nr ns b">type</code>。在运行时，python仍然允许我检查<code class="fe np nq nr ns b">dataclass</code>类及其字段的类型。使用TypeScript，没有办法做到这一点，因为当它被编译成JavaScript时，所有的类型信息都丢失了。</p><p id="e86e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，这实际上在哪里有用呢？我非常喜欢基于属性的测试和生成测试用例以获得更好的覆盖率。Python有一个很好的测试框架，叫做<a class="ae ky" href="https://hypothesis.works/" rel="noopener ugc nofollow" target="_blank">假设</a>。它允许您从带有类型注释的<code class="fe np nq nr ns b">dataclass</code>中创建测试策略，这些策略将生成测试用例。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">假设推断字段和类型，并自动生成测试用例</figcaption></figure><p id="7a88" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Typescript/Javascript有自己的框架，<a class="ae ky" href="https://github.com/dubzzz/fast-check" rel="noopener ugc nofollow" target="_blank">快速检查</a>，对于大部分部分来说，和假设非常相似。它不能做的一件事是生成测试策略。您必须在类型和测试策略中重复您的对象的模式。在测试策略中，必须重复对类型的每一次更改。这不是世界末日，因为如果你忘记更新一个，编译器会提醒你。它还是很烦人，而且不是很干。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">快速检查无法推断字段及其类型</figcaption></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="ff8d" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">数据库框架</h1><p id="56b1" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">我不得不多说一点关于数据库包装器的内容。我主要关注SQL数据库的库，尤其是PostgreSQL。大多数情况下，一个简单的SQL数据库对于一个项目来说就足够了。Python有一些非常成熟的解决方案，比如Django自带的SQLAlchemy或ORM。TypeScript/JavaScript紧随其后，TypeORM是最受欢迎的。这些库允许你随着时间的推移进化你的模式，这种实践被称为<a class="ae ky" href="https://martinfowler.com/articles/evodb.html" rel="noopener ugc nofollow" target="_blank">进化数据库设计</a>。(SQLAlchemy的一个更实际的例子是这里的<a class="ae ky" href="https://benchling.engineering/move-fast-and-migrate-things-how-we-automated-migrations-in-postgres-d60aba0fc3d4" rel="noopener ugc nofollow" target="_blank"/>，这里的<a class="ae ky" href="https://betterprogramming.pub/typeorm-migrations-explained-fdb4f27cb1b3" rel="noopener ugc nofollow" target="_blank"/>是一个带有TypeORM的例子)。虽然两种语言都有成熟的解决方案，但我还是遇到了一个例子，python解决方案(在我的例子中是Django)比我见过的任何JavaScript解决方案都功能丰富。</p><p id="cbf7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">经过一两年的积极开发，您将已经创建了大量的迁移。我曾经参与过一个Django项目，在这个项目中，我确信在迁移过程中添加的大多数字段和表在以后的迁移中都被修改或删除了。Django实际上为压缩迁移提供了一个解决方案，以保持较低的迁移总数。您只能压缩已经应用于所有生产环境的迁移，因此压缩更像是一种清理，以保持您的代码库整洁，并使从头建立开发或测试数据库变得更加容易。我还没有见过任何试图压制迁移的TypeScript/JavaScript包，如果没有一些防护，我不会尝试这样做。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="8f21" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">Pytest夹具</h1><p id="6445" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">当我编写测试时，我会尽量减少每个测试所需的设置和拆卸量，但有时这是不可避免的，有时您希望在测试之间共享设置。y测试夹具是我的首选工具。它允许您设置和拆卸对象，无论是针对每个测试，还是跨模块共享，甚至是所有的测试。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">pytest夹具示例</figcaption></figure><p id="9c17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，JavaScript有办法运行测试的设置和拆卸代码。开玩笑的说，这是所有之前的<a class="ae ky" href="https://jestjs.io/docs/api#beforeallfn-timeout" rel="noopener ugc nofollow" target="_blank">/</a><a class="ae ky" href="https://jestjs.io/docs/api#beforeeachfn-timeout" rel="noopener ugc nofollow" target="_blank">之前的</a>做的几乎一样，除了一个例外:你不能把物体从夹具传入测试！常见的解决方法是使用一个在测试和安装/拆卸功能之间共享的变量。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">带有安装和拆卸方法的jest示例</figcaption></figure><p id="071a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是常见的做法，但也令人讨厌。一旦你有几个测试共享相同的设置/拆卸代码，它们都将访问相同的全局可变变量。这是我的警钟开始响起的地方。测试应该是独立的，它们之间没有任何共享状态。因为设置是在每个测试之前运行的，所以它们实际上并不共享同一个对象。只是遗憾的是，这不能用代码恰当地表达出来。</p><p id="f79b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">还有其他流行的TypeScript/JavaScript测试框架，比如<a class="ae ky" href="https://mochajs.org/" rel="noopener ugc nofollow" target="_blank"> Mocha </a>，但是据我所知，它们倾向于提供相同的<a class="ae ky" href="https://mochajs.org/#root-hook-plugins" rel="noopener ugc nofollow" target="_blank">before all/before each hooks</a>。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="6bea" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">词典释义</h1><p id="3d76" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">我经常发现自己在代码中有如下操作:我有一个对象集合，我想根据某个对象字段，通常是它们的ID来查找它们。Python有一个非常实用和优雅的语法:理解。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="6ccf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在JavaScript中，由于有了<a class="ae ky" href="https://lodash.com/docs/#keyBy" rel="noopener ugc nofollow" target="_blank"> lodash </a>模块，您也可以用很少的代码实现这一点。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="c267" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就其本身而言，这两种解决方案都是干净、实用且快速的。但是与python生成器相比，lodash感觉有点笨拙。它没有给你一个清晰的视觉映射<code class="fe np nq nr ns b">key: value</code>。当查找更复杂时，函数会修改键和值，可读性会降低很多。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h1 id="d06b" class="mq mr it bd ms mt mu mv mw mx my mz na jz nb ka nc kc nd kd ne kf nf kg ng nh bi translated">这些差异重要吗？</h1><p id="93d1" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">我已经咆哮过python比TypeScript更优雅的边缘情况。但是着眼于大局，我仍然喜欢用TypeScript编码。TypeScript在一些特性上优于python。例如，我发现用TypeScript编写更多更精确的类型比用python和MyPy更容易。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/335d958f017b5bb5e5ec82280f132baf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wnH40qHfyRl6dnbo"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@saltsup?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Piret Ilver </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="d2ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些差异重要吗？他们显然对我很重要，否则，我不会写这篇文章。写代码意味着简洁明了地表达你希望计算机做什么。它应该尽可能地关注“什么”,而不是在特定技术中“如何”完成。它使代码更容易阅读、编写和维护，最终导致更少的错误。在我给出的例子中，python比TypeScript做得稍好。</p><h1 id="6f12" class="mq mr it bd ms mt nu mv mw mx nv mz na jz nw ka nc kc nx kd ne kf ny kg ng nh bi translated">最后的想法</h1><p id="f767" class="pw-post-body-paragraph kz la it lb b lc ni ju le lf nj jx lh li nk lk ll lm nl lo lp lq nm ls lt lu im bi translated">这是否意味着如果我必须从头开始，我会选择python而不是TypeScript做后端？肯定不是。最终，两种语言的相似之处多于不同之处。其他因素更重要，比如你团队的专业知识。在我们的例子中，我的团队将同时开发前端和后端，这一事实使得TypeScript成为我们的最爱。</p><p id="0f79" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您正在寻找两种语言之间的更一般的比较，那么感谢您一直阅读本文。Hackernoon有几篇好文章<a class="ae ky" href="https://medium.com/hackernoon/could-pythons-popularity-outperform-javascript-in-the-next-five-years-abed4e307224" rel="noopener">在这里</a>和<a class="ae ky" href="https://medium.com/hackernoon/javascript-vs-python-in-2017-d31efbb641b4" rel="noopener">在这里</a>。</p><h2 id="4970" class="nz mr it bd ms oa ob dn mw oc od dp na li oe of nc lm og oh ne lq oi oj ng ok bi translated">资源</h2><ul class=""><li id="3fcc" class="lv lw it lb b lc ni lf nj li ol lm om lq on lu ma mb mc md bi translated"><a class="ae ky" href="https://hypothesis.works/" rel="noopener ugc nofollow" target="_blank">基于属性测试的pythons假设</a></li><li id="7cdc" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://github.com/dubzzz/fast-check" rel="noopener ugc nofollow" target="_blank">基于属性测试的JavaScripts快速检查</a></li><li id="1d0d" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://lodash.com/" rel="noopener ugc nofollow" target="_blank">用于高效列表和对象操作的JavaScripts lodash模块</a></li><li id="44a5" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://docs.pytest.org/en/6.2.x/fixture.html" rel="noopener ugc nofollow" target="_blank"> pytest夹具</a></li><li id="3f90" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://jestjs.io/" rel="noopener ugc nofollow" target="_blank"> jest JavaScript测试框架</a></li><li id="ff4f" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://martinfowler.com/articles/evodb.html" rel="noopener ugc nofollow" target="_blank">进化数据库设计</a></li><li id="b961" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://benchling.engineering/move-fast-and-migrate-things-how-we-automated-migrations-in-postgres-d60aba0fc3d4" rel="noopener ugc nofollow" target="_blank">使用SQAlchemy进行进化数据库设计的工作示例</a></li><li id="de06" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://betterprogramming.pub/typeorm-migrations-explained-fdb4f27cb1b3" rel="noopener ugc nofollow" target="_blank">使用类型表进行进化数据库设计的工作示例</a></li><li id="bd98" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">与姜戈一起镇压移民</li><li id="3969" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://medium.com/hackernoon/could-pythons-popularity-outperform-javascript-in-the-next-five-years-abed4e307224" rel="noopener"> python vs javascript文章#1 </a></li><li id="fb6d" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://medium.com/hackernoon/javascript-vs-python-in-2017-d31efbb641b4" rel="noopener"> python vs JavaScript文章#2 </a></li></ul></div></div>    
</body>
</html>