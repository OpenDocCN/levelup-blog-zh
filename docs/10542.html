<html>
<head>
<title>Patterns of Inter-Node Communication in Distributed Systems</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">分布式系统中节点间通信的模式</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/patterns-of-inter-node-communication-in-distributed-systems-da76f33796ea?source=collection_archive---------9-----------------------#2021-12-19">https://levelup.gitconnected.com/patterns-of-inter-node-communication-in-distributed-systems-da76f33796ea?source=collection_archive---------9-----------------------#2021-12-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/09435b0b34421fa0c63021c6b48c5350.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YLpkDmIuVlfJDMeZS7bMnw.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">图片来源:由fullvector / Freepik设计</figcaption></figure><p id="2363" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在分布式环境中，您的应用程序运行在一个<strong class="ke ir">多节点</strong>设置中，经常会有节点需要相互通信或在它们之间传递消息的需求。在这篇博客中，我们将讨论一些解决分布式系统中节点间通信问题的<strong class="ke ir">实用方法</strong>。</p><blockquote class="la lb lc"><p id="5a95" class="kc kd ld ke b kf kg kh ki kj kk kl km le ko kp kq lf ks kt ku lg kw kx ky kz ij bi translated">请注意，这不可能是一个详尽的模式列表。这个博客将涵盖一些我个人能想到的实用模式/方法。可能还有其他我完全不知道的模式。</p></blockquote></div><div class="ab cl lh li hu lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ij ik il im in"><h1 id="1c41" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">问题定义</h1><p id="d30e" class="pw-post-body-paragraph kc kd iq ke b kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv mq kx ky kz ij bi translated">让我们来看一个非常常见的场景，在节点上有一个<strong class="ke ir">内存缓存</strong>。<em class="ld">(节点可以是裸机服务器、虚拟机、Kubernetes Pod等任何东西，它只是运行服务的一些计算能力)。</em>我的意思是，我们没有使用分布式缓存，如Redis、Memcached，而是将一些数据直接存储在节点的RAM上，这样所有节点都维护着某些数据的隔离的<strong class="ke ir">本地副本</strong>。现在进行了一个API调用来更新该特定数据，收到该API调用的节点接受了请求，并在数据库中进行了必要的更新。现在，这个接收节点知道缓存需要被<strong class="ke ir">无效</strong>，它可以很容易地使本地缓存无效。但是其余的节点呢？他们还必须使缓存中的过时数据无效，对吗？但是这些节点怎么知道，信号是什么？我猜想此时接收节点需要某种方式将失效消息传递给所有其他节点，以便它们也更新它们的本地缓存。</p><p id="8e8e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这不仅限于缓存失效，还可能有很多其他类似的情况。因此，让我们尝试为跨节点的消息传输找到一个通用的解决方案，剩下的就交给特定的用例吧。</p></div><div class="ab cl lh li hu lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ij ik il im in"><h1 id="5269" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">潜在的解决方案</h1><p id="e62a" class="pw-post-body-paragraph kc kd iq ke b kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv mq kx ky kz ij bi translated">看完这个问题后，我可以想到3种解决方案。其中，两个稍微清晰，一个完全是实验性的。</p><ol class=""><li id="fcd0" class="mr ms iq ke b kf kg kj kk kn mt kr mu kv mv kz mw mx my mz bi translated">使用Kafka、RabbitMQ等技术的基于消息队列的扇出消息交换解决方案。</li><li id="7d09" class="mr ms iq ke b kf na kj nb kn nc kr nd kv ne kz mw mx my mz bi translated">使用Redis的简单<strong class="ke ir">发布/订阅</strong>解决方案。</li><li id="83da" class="mr ms iq ke b kf na kj nb kn nc kr nd kv ne kz mw mx my mz bi translated">基于<strong class="ke ir">八卦协议</strong>的解决方案。</li></ol><p id="ed28" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">前两个，我有一些模糊的视觉，但第三个对我来说完全是理论上的。</p><h1 id="e06f" class="lo lp iq bd lq lr nf lt lu lv ng lx ly lz nh mb mc md ni mf mg mh nj mj mk ml bi translated">基于消息队列的扇出交换</h1><p id="725f" class="pw-post-body-paragraph kc kd iq ke b kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv mq kx ky kz ij bi translated">扇出交换机类似于<strong class="ke ir">消息广播系统</strong>。您向交易所发送一条消息，然后它向多个消费者广播相同的消息。如果您不知道什么是消息交换，可以把它想象成系统中的一个点，所有传入的消息都到达这个点，然后根据一些规则被路由到各自的目的地。</p><p id="cc25" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">因此将有一个<strong class="ke ir">消息交换</strong>，其中接收更新数据呼叫的节点(从现在起将被称为生产者节点)将发布通知消息。所有其他节点将通过某种方式连接到该特定扇出交换机。并且当扇出交换机广播消息时，所有节点将获得由生产者节点发送的消息。</p><p id="97ab" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这也可以通过各种技术来实现。实际实现显然会有所不同，但概念是相同的。一个节点向扇出交换机发送消息，交换机以扇出方式向所有连接的用户广播该消息。</p><p id="c8e1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">让我们看看如何通过使用Kafka或RabbitMQ来实现这一点。这可以通过使用当今几乎所有的消息队列系统来实现。</p><h2 id="571b" class="nk lp iq bd lq nl nm dn lu nn no dp ly kn np nq mc kr nr ns mg kv nt nu mk nv bi translated">使用卡夫卡</h2><figure class="nx ny nz oa gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nw"><img src="../Images/252158ab547919ece45f621e747a9618.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r257WvErYOs78i7fpTsJbA.jpeg"/></div></div></figure><p id="3f70" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">构建Kafka扇出设置可能是这样的。你只需要把所有的节点放在不同的<strong class="ke ir">消费群、</strong>中，这样无论什么时候有消息发布到一个主题，所有的节点都会分别得到消息。但是您必须确保所有的消费者组中只有一个消费者/一个节点。它的工作方式是，当你在任何话题上发布一条信息时，它会被不同的消费者阅读。Kafka会跟踪任何特定消费者阅读的最后一条消息，这样就不会有消息被多次消费。所以现在这种跟踪是在消费者群体的基础上进行的。因此，如果在一个消费者组中有3个消费者，并且有一条id为“message-11100”的消息，只要这3个消费者中的一个阅读了该消息，该消息将被标记为该特定消费者组的已读，而其他2个节点将不会收到该消息。但问题是，由于这种跟踪是在使用者组的基础上进行的，如果存在其他使用者组，这些使用者组中的一个节点仍然有资格读取“message-11100”。因此，我们利用这一特性，在每个消费者组中只放置一个节点，这样所有节点现在都可以读取相同的消息，它们不再是竞争的消费者。</p><p id="6f67" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我知道如果你不了解卡夫卡，这可能有点令人难以接受，所以请在这里随意了解更多关于卡夫卡的基础知识。</p><h2 id="c1fa" class="nk lp iq bd lq nl nm dn lu nn no dp ly kn np nq mc kr nr ns mg kv nt nu mk nv bi translated">使用RabbitMQ</h2><figure class="nx ny nz oa gt jr gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/ba4f74dfa52368a0b01fde4e547829e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/format:webp/1*cn2ZIsFFQ54NLu0U53FiNg.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">图片来源:RabbitMQ博客</figcaption></figure><p id="58f3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">RabbitMQ对<strong class="ke ir">扇出交换</strong>有本地支持。其中发送到扇出交换机的消息实际上被广播到所有连接的队列。所以这个设置非常简单。我们首先创建一个扇出交换，并在这个扇出交换上为每个节点创建一个队列。现在设置变成这样，我们有一个扇出交换，即fan_ex_1，我们有成对的节点和队列，我们有由node_1订阅的q_1，由node_2订阅的q_2，等等。所以当任何一个节点在fan_ex_1上放一个消息，那么q_1，q_2 …q_n每个人都收到该消息，这意味着所有节点也收到该消息。同样的，如果你不太了解RabbitMQ，可以在这里随意阅读更多<a class="ae ob" href="https://www.cloudamqp.com/blog/part4-rabbitmq-for-beginners-exchanges-routing-keys-bindings.html" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="fe46" class="lo lp iq bd lq lr nf lt lu lv ng lx ly lz nh mb mc md ni mf mg mh nj mj mk ml bi translated">使用Redis发布/订阅</h1><p id="8069" class="pw-post-body-paragraph kc kd iq ke b kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv mq kx ky kz ij bi translated">Redis可能是分布式系统的瑞士刀，毫不奇怪，我们可以利用Redis发布/订阅来构建一个简单的类似<strong class="ke ir">消息总线</strong>的系统。</p><figure class="nx ny nz oa gt jr gh gi paragraph-image"><div class="gh gi od"><img src="../Images/6aee2754b704a6072bfc16ef819dfda5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1062/format:webp/1*8Fhe9TkvLxj35exhBLbNwQ.jpeg"/></div></figure><p id="cf74" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这将再次出现在类似的行上。我们有一个<strong class="ke ir">发布者</strong>，它发布消息，是我们的生产者节点。发布者将这条消息发布到一个Redis " <strong class="ke ir"> channel </strong>"上，这里类似于一条消息总线，就像一条源源不断的数据流。然后我们有消费者，他们订阅了这个通道，所以每当这个通道中有新消息时，所有的消费者都会得到一个<strong class="ke ir">回调</strong>，然后他们可以处理那个消息。正如您所看到的，生产者节点推送通知，因为所有其他节点都订阅了该特定的通知通道，所以每个人都会收到关于该新消息的ping。这可能是所有解决方案中最简单的，但是如果你想了解更多关于Redis发布/订阅的信息，请查看他们的文档<a class="ae ob" href="https://redis.io/topics/pubsub" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><blockquote class="la lb lc"><p id="de32" class="kc kd ld ke b kf kg kh ki kj kk kl km le ko kp kq lf ks kt ku lg kw kx ky kz ij bi translated">还有一种技术<strong class="ke ir"> Redis服务器辅助的客户端缓存</strong>，它也可以在这里工作。因为我对这个解决方案很满意，所以没有在这方面做太多探索。但是你可以在这里阅读更多关于这个的内容。</p></blockquote><h1 id="11f8" class="lo lp iq bd lq lr nf lt lu lv ng lx ly lz nh mb mc md ni mf mg mh nj mj mk ml bi translated">八卦协议</h1><blockquote class="la lb lc"><p id="02f2" class="kc kd ld ke b kf kg kh ki kj kk kl km le ko kp kq lf ks kt ku lg kw kx ky kz ij bi translated">对于这个特定的缓存失效用例来说，这是一个错误的选择。但我是在探索之后才发现的。如果您已经了解了gossip，请随意跳过这一部分，但是如果您想了解一点Gossip协议以及为什么它不适合这个用例，请留下来。</p></blockquote><p id="fb40" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这无疑是最有趣、最复杂、最耗时的选项，因此我最想构建它😝</p><p id="09e7" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">因此，gossip是一种网络协议/算法，其中多个节点形成一个gossip集群，集群中的所有节点通过定期共享<strong class="ke ir">心跳</strong> /元数据来了解所有其他节点。当我们必须将消息传播到集群中的所有节点时，生产者节点将随机选择一个节点来传递消息。然后接收节点再次将该消息发送到某个其他随机节点，这将继续下去。因此，消息最终到达所有其他节点。Cassandra、Consul等流行技术使用流言来形成集群。点击阅读更多关于八卦协议<a class="ae ob" href="https://www.educative.io/edpresso/what-is-gossip-protocol" rel="noopener ugc nofollow" target="_blank">的信息。</a></p><figure class="nx ny nz oa gt jr gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/2af54596d5cfa759085452f5ed695760.png" data-original-src="https://miro.medium.com/v2/resize:fit:964/format:webp/1*o5zWJWi7UtLSq9Q2zMpLMg.jpeg"/></div></figure><p id="8b3e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">想法是生产者将初始化消息链，然后所有节点最终将得到它。但是如果我走这条路，那么系统需要是高度幂等的。这些节点会定期在其他节点之间共享所有元数据，因此尽管其他节点会收到缓存失效消息，但它会继续共享这些元数据。即使我可以稍微调整一下算法，让这些通知类型的消息被读取，然后删除，这样该消息就不会被重新共享，那么我也不能保证该消息最多被发送一次。这就产生了经典的等幂问题。所有这些都清楚地表明，对于这个特殊的问题，这个选项是一个错误的选择，但是我确实学到了一些关于流言蜚语的东西。</p><blockquote class="la lb lc"><p id="5605" class="kc kd ld ke b kf kg kh ki kj kk kl km le ko kp kq lf ks kt ku lg kw kx ky kz ij bi translated">尽管Gossip不适合这个特定用例的解决方案，但它仍然是节点间通信的一个很好的选择。</p></blockquote></div><div class="ab cl lh li hu lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ij ik il im in"><h1 id="d126" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">选择设计</h1><p id="204a" class="pw-post-body-paragraph kc kd iq ke b kf mm kh ki kj mn kl km kn mo kp kq kr mp kt ku kv mq kx ky kz ij bi translated">现在我们已经了解了所有的方法，让我们看看我选择了哪一个，为什么。</p><p id="d156" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">流言蜚语的方法不适合用例。那么基于队列的方法还是基于Redis的方法呢？Redis是最简单的，对我的系统来说需要的基础工作最少。所以我选择了Redis发布/订阅解决方案。但是如果您已经将Kafka/ RabbitMQ集成到您的服务中，并且有一个非常了解这些技术的团队，那么基于队列的方法可能是您的最佳选择。如果给我所有的时间来构建它，我可能也会选择扇出解决方案，因为这是一个稍微更有弹性、更健壮的解决方案。</p></div><div class="ab cl lh li hu lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ij ik il im in"><p id="8b08" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">今天就到这里，谢谢大家的阅读！</p><blockquote class="la lb lc"><p id="a1c5" class="kc kd ld ke b kf kg kh ki kj kk kl km le ko kp kq lf ks kt ku lg kw kx ky kz ij bi translated"><em class="iq">我是Aritra Das，我是一名开发人员，我非常喜欢构建复杂的分布式系统。如有任何与科技相关的问题，请随时联系我</em><a class="ae ob" href="https://www.linkedin.com/in/dev-aritra/" rel="noopener ugc nofollow" target="_blank"><em class="iq">Linkedin</em></a><em class="iq">或</em><a class="ae ob" href="https://twitter.com/aritra__das" rel="noopener ugc nofollow" target="_blank"><em class="iq">Twitter</em></a><em class="iq">。</em></p><p id="d194" class="kc kd ld ke b kf kg kh ki kj kk kl km le ko kp kq lf ks kt ku lg kw kx ky kz ij bi translated"><em class="iq">快乐学习……</em></p></blockquote></div></div>    
</body>
</html>