# 设计模式:Pythonic 示例

> 原文：<https://levelup.gitconnected.com/designing-to-patterns-a-pythonic-example-14bc8ce34e81>

![](img/af7bf0ca5e407698e0b8ac3bee3b2c30.png)

[杰克·卡特](https://unsplash.com/@carterjack)在 [Unsplash](https://unsplash.com/) 上拍照

# 介绍

软件设计的主要目标不仅是软件的功能性，而且是软件易于维护和扩展。因此，可以很容易地添加新功能，并且可以很快地修复新出现的错误。为此，可靠的设计原则(下面介绍)可以用来识别代码中要重构的区域。但问题是这些原则规定了“什么”而不是“如何”。为了更深入地了解“如何”实现可扩展的模块化设计，可以利用设计模式。在本文中，我们将讨论从设计原则到设计模式再到重构代码的设计思想。这将通过 Python 中的一个例子来说明。

# 示例问题

考虑下面的情况。给定一个对象存根(不完全构建的对象)，它包含存储在持久键值存储中的数据单元的键，需要一个服务层函数来获取所有数据，并重新构造完整的对象。这样做的动机是，通过存储原始单元，而不是只存储构造的对象，在将单元转换成最终对象的算法改变的情况下，对象可以被重建。因此，无论重建的功能是什么，都有望改变。总共有 7 种不同的对象类型，它们都有一个共同点，即重建它们的数据被分割到多个单元:重建完整的对象需要多个数据库查询。然而，每个对象都有唯一的构造签名，所以一个接口是不够的。然而，构造对象遵循两种模式。第一个:

我们看到对象可以通过迭代调用特定于对象的`build()`函数来创建。第二种模式不同:

在这里，对象需要将所有的最终数据集中在一个地方，并调用一个聚合方法(有时分几个阶段)从所有单元中一次性构建对象。

给定这两种模式，以及每个对象的实际签名是唯一的这一事实，我们如何构建一个单一的服务层方法来为我们重新构造对象呢？设计目标不仅是重建对象的服务层，而且是在添加新对象类型的情况下易于扩展的服务层，以及在构造算法发生变化的情况下可以安全修改的服务层。

# 天真的解决方案

第一遍解决方案是值得注意的，因为这往往是真的写了什么。我有时在生产代码中看到这样的例子。

这是不应该的。这个例子违反了大多数坚实的原则，不符合我们的设计目标。让我们学习一些设计原则，然后看看一些设计模式来实现可扩展和可维护的代码。

# 设计原则

设计原则有助于识别需要重构的代码，并为重构的方向提供指导。它们是指路明灯，而不是必须遵循的严格规则，并且通常不足以告诉开发人员需要做什么，而是指示需要做*某事*，让开发人员自己找出如何做。您应该遵循设计原则的原因有几个。首先，通过按照一组原则编码，不管它们是什么，你的代码将变得更容易推理，因为相同的模式重复出现。你基本上知道在你自己的代码中会发生什么，而不是发现分散的混乱。其次，遵循设计原则有助于使代码更容易理解，更容易推理，更容易重用，因为这些原则本身实施共同的基本规则。不仅仅是模式被重复地遵循，而且模式本身有助于更好、更有凝聚力的设计。

固体原则就是这样一套指导原则，我们将在这里涵盖所有这些原则，但只使用其中的三个，因为它们与上面的例子相关，以及它们的同伴干原则(不要重复自己)。当我们讨论它们时，我们将指出它们将如何帮助改进代码的设计。作为参考，坚实的原则是:

*   单一责任原则
*   开闭原理
*   利斯科夫替代原理
*   界面分离原理
*   从属倒置原则

在介绍完固体原理之后，我们将介绍干燥原理。

## 单一责任原则

SRP 规定一个功能，或者一个类，或者一个模块应该被限制在一个单独的职责范围内。这也可以重申，因为它应该只有一个改变的理由。随着范围从函数到类的增加，等等。，理由就变得原则宽松了，但原则上还是应该坚持。函数或类的职责通常可以是，并且原则上应该从名称中推断出来。另一个有用的练习是检查代码并询问它可能改变的所有原因。如果可能的变更偏离了它的唯一职责，那么重构可能是需要的。一般来说，责任越少越好，但只是在一定程度上。为什么您应该遵循单一责任原则是因为代码变得更容易推理。如果你知道代码只做一件事，而且只做一件事，它的名字就能告诉你原因(或者至少它应该这样)。多用途要么产生很长的名字，要么产生一般的混乱，这只能通过仔细检查代码来解决。

在上面的例子中，我们的服务层功能的职责是从存储在数据库中的数据重建一个对象。它需要了解数据库和对象构造。回到我们天真的解决方案，有很多理由让它改变。如果数据库访问模式改变，那么代码必须在几个地方改变。如果任何对象的构造模式改变，该函数也需要改变。虽然这些可能的变化确实与服务层的职责一致，但我们将在下面看到如何做得更好，并进一步简化职责。

## 开闭原理

这个原则声明一个类应该对扩展开放，但对修改关闭。这就是它改变的原因，应该可以通过利用设计模式来配置。运行时配置或通过继承的静态扩展应该产生期望的行为，而不是通过改变代码来改变类的行为。遵循这个原则对于健壮的代码尤其重要，因为每次函数或类的代码必须改变时，都有可能引入新的错误。为确保代码安全可靠而付出的努力会随着每次修改而消失。

上面的例子违反了这个原则，因为它要求每次添加新的对象类型时都要手动更新 if-then-else 块。此外，如果对象的构建定义发生变化，类似地，需要修改函数来反映这些变化。事实上，大多数设计模式都处理使类遵循开闭原则的方法，我们将在下面看到。

## 利斯科夫替代原理

虽然在当前的例子中没有直接使用，但是在设计类和继承方案时记住这个原则是有帮助的。Liskov 替换原则是基类应该可以替换子类。换句话说，应该坚持严格的多态性。在静态类型语言中，被类型化为基类的变量应该以预期的方式运行，即使子类被分配给该变量。当子类被换入和换出基类时，在行为上应该没有意外的惊喜。

## 界面分离原理

简单地说，实现接口的类不应该实现任何无关的特性，即函数。在这种情况下，不同的函数应该放在两个独立的接口中，并且该类应该只实现其中一个接口。这不仅减少了应用程序中的样板文件，还引入了概念上的清晰性。通过保持概念上的清晰，您可以防止由于期望一个接口应该被满足而产生的混淆，而事实上它并没有被满足。接口分离原则与 Liskov 替换原则相关，因为遵守它可以确保满足接口的每个对象都可以得到相同的推理。

在下面的解决方案中，我们实际上会违背这一原则，因为我们必须适应两种独特的构造模式，这突出了在解决设计问题时实用主义的必要性。在大多数情况下，严格遵守所有已知的软件原则是不可能的，这让开发人员不得不仔细权衡一些原则优于其他原则的解决方案的利弊。在这种情况下，我们最初的设计目标是有一个单一的接口，可以容纳所有可能的方式来重建对象。所以本质上，接口分离原则必须被忽略，以服务于更广泛的目标。

## 从属倒置原则

依赖倒置原则导致设计倾向于使用接口和抽象类作为高级代码的直接依赖，并允许工厂和其他构造方法提供具体的类供使用。术语“依赖倒置”指的是这样一个事实，即从高级类的角度来看，具体类上的依赖箭头已经倒置:具体类现在依赖于接口或抽象类的细节，而不是高级类明确依赖于具体类。这有很多好处，主要是多态性。它还将设计决策从低级类的细节中分离出来，并实施严格的接口。所有这些都使代码松散耦合，易于扩展和维护。

上面这个天真的例子违反了这个原则，因为它依赖于构造函数的所有具体细节。它不仅依赖于构造函数本身，而且还清楚地知道构造是如何完成的。这种明确的知识违反了几个坚实的原则，应该谨慎地避免。正如我们将看到的，实现依赖倒置原则将有助于隔离细节，并且还将有助于加强单一责任原则和开闭原则。

## 不要重复自己的原则

虽然不是坚实原则的一部分，但这一点是必须提及的，因为它对基础软件开发至关重要。通常重复的代码应该被归纳和抽象成函数、类和模块，以便重用。这提供了一个不断增长的工具库，逐渐简化了您作为开发人员的生活，并防止了 copy-pasta:由于错误使用和错误重命名从另一部分复制过来的代码而导致的代码库错误。一个很好的经验法则是，如果你发现自己重复一个代码模式至少 3 次，那么是时候重构并将代码转移到另一个地方。

虽然有时候你不应该遵循这个原则。如果在泛化一个函数来处理每一个你打算用它替换的用例时，你需要把自己绑在结里来实现你的目的，这是特别正确的。抽象成公共函数和类的代码本身应该遵循良好的设计原则。基本上，如果你需要开始违反其他设计原则来完成不重复自己，那么重构应该在进行之前仔细考虑。

然而，在上面的天真的例子中，我们有两个需要处理的模式，并且每个模式都重复多次，所以这是抽象成更一般的东西的时机。但需要注意的是，这并不是改变的首要原因。在这里，单一责任原则和开闭原则的权重要大得多，所以最终解决方案中较少的重复只是满足这两个原则的额外收获。

# 设计模式

以上 6 个原则有助于在不断增长的代码库中寻找更好的设计解决方案，使代码更容易维护和扩展，但它们本身并不一定告诉你如何更改代码。为此，人们需要转向设计模式。权衡模式选项的利弊对于制定重构计划来说可能是有益的。在这里，我们将考虑三种模式，我们将一起使用，以产生一个更灵活的设计。首先，有 7 个不同的构造特征，我们希望适合一个公共接口。这暗示了适配器模式。第二，即使我们正在重建一个对象，它仍然是构造，所以应该考虑工厂模式，尽管有一点小小的变化。接下来，构造是分阶段进行的，而不是单个函数调用，因此还应该考虑构建器模式。我们将依次检查每一个。

应该注意的是，对于这些模式中的每一种，在 Gamma 等人的“[设计模式:可重用面向对象软件的元素](https://www.amazon.com/Design-Patterns-Object-Oriented-Addison-Wesley-Professional/dp/0201633612)”中有更正式、更严格的解释(也称为“四人组”的书，因为它有四个作者，并且在该领域中占有突出地位)，这里给出的解释是一种主观的解释。虽然理解模式最初布局时的全部复杂性是有帮助的，但是在您的代码中，大多数情况下您将实现模式的一个方面或一部分，而不总是按照其原始含义。这种特定于情况的解释对于软件开发人员来说至关重要。但是我建议读者参考上面的书以获得更深入的理解。

## 适配器模式

适配器模式使一个接口适合另一个接口，而不改变功能。举个简单的例子，许多旧的 Python 库本身并没有实现上下文管理器，而是提供了一个带有`close`方法的对象。为了利用这一点，并允许在现代 Python 语法中使用这样的库，contextlib 标准库提供了`closing`函数，该函数使 close 方法适应上下文管理器的需要。在`with`上下文中使用关闭函数可以确保对象在退出上下文时被正确关闭。通过这种方式，我们将一种模式(这里的`close`模式)适配到另一种模式(这里是上下文管理器模式),允许这两种模式协同使用，而不必重写任何一个接口(这也是装饰器模式的一个例子，我们同时在适配和装饰)。

## 工厂模式

工厂模式根据需要生成按照正确规范构建的对象。它将构造的细节从调用者那里抽象出来，允许工厂根据需要进行交换，并降低代码中的耦合性。一个常见的用例是构建 gui 组件。在跨平台 API 中，构建 gui 的底层代码可能因平台而异。因此，与在应用程序代码中直接调用本机 API 不同，对象的构造可以委托给一个工厂，该工厂具有公共接口，并且不同的工厂取决于平台。通过这种方式，应用程序不知道 gui 的细节，而是依赖正确的工厂按需生产平台原生组件。

# 构建器模式

不是所有的物体都可以一次建成。有时有可选的参数和可选的步骤，在需要向每个函数调用传递静态数量的参数的语言中，提供必要的灵活性的唯一方法是允许在构建器上一个接一个地调用方法，直到对象完全构建。考虑到语言的限制，构建器模式在 rust 语言中尤其普遍。考虑编写一个 RESTful API。需要用它配置的东西很多。端点、超时、缓存、认证方法等。利用构建器模式，您可以提供一组逐步添加配置选项的函数，直到构建完整的对象，并且可以启动服务器。如果利用得当，构建器模式比大量的 init 函数可读性更好，也更容易维护。如果您使用 rust 或类似的语言，这可能是唯一的选择。

# 解决方案

现在我们已经有了三种模式，让我们将它们编织成一个满足我们设计原则的解决方案。首先，我们需要设计一个接口来适应我们两种独特的构造模式。之后，我们将利用适配器模式使构造函数适合该接口。

# 连接

在设计界面时，让我们先从构建器模式开始。我们的两个构造模式有一个相似的模式。以下是包含这两者的伪代码:

1.  给定的建造者开始建造
2.  循环对象中的所有单元键
3.  给定单元密钥，从数据库获取数据
4.  要么(1)保存数据以备后用，要么(2)使用当前正在构建的数据
5.  结束循环
6.  要么(1)完成构建，要么(2)什么都不做，对象已经构建
7.  返回重构的对象

尽管在循环中和结束时有不同的选项，其中一个选项是什么也不做，但我们已经为所有 7 个对象准备了一个公共接口。这里我们来做三个改进。首先，我们将使用一个工厂为给定的对象创建构建器。其次，从创建构建器到返回对象之间的所有步骤都应该由构建器来处理，以保证逻辑完整性。这意味着不遍历对象中的键，而是将该行为委托给生成器。为此，我们将使构建器成为迭代器。第三，因为有一些行为必须在最后发生(完成构建)，这暗示了上下文管理器的 Python 构造。它提供了一个保证，即无论在上下文管理器的中间构建是如何完成的，末端总是会运行。这消除了编码过程中的模糊性和出错的可能性。

下面是我们最终的接口 Python 实现:

以这种方式实现接口意味着，因为这个函数不会在“if”语句中重复自己，所以它对扩展是开放的，因为工厂被期望扩展，并且接口足够灵活，任何构造模式都可以由它处理，并且它对修改是封闭的，因为不需要修改它来扩展它。此外，它具有将数据库连接到对象重构、将细节委托给工厂和构建器的单一职责，并且它反转依赖性，因为它仅依赖于工厂和构建器的抽象接口，而不依赖于低级对象的实现特定细节。

# 工厂

把我们的注意力转向工厂，我们怎样才能建造一个可以扩展但不能修改的工厂呢？幸运的是，从一开始回过头来看我们的反例，我们看到在每个阶段，分支是基于对象类型选择的。另一种模式是使用 Python 字典，它允许键和值之间的任意关联。工厂必须返回一个初始化的构建器，所以内部字典应该存储对象类型和构建器类之间的映射。通过提供一个可以更新字典的注册方法，可以使工厂具有可扩展性。这是:

我们在这里选择使用 dunder 方法 __call__ 以便它有一个类似工厂函数的接口来保持服务层代码简单。

# 建设者

我们有了一个接口和一个工厂，现在我们需要设计构建器。使用抽象基类符合我们对接口的需求。简而言之，抽象基类是 Python 声明从它继承的对象必须实现某些细节的方式。这些细节用“abstractmethod”装饰器标记。不实现它们将在类创建时抛出一个错误。使用这样的接口就是依赖倒置的用武之地。不是服务层直接依赖于实现细节，而是具体的类依赖于抽象的基类，因此依赖关系的箭头变反了。让我们实现上述接口的抽象基类:

这里我们做了一个设计决策，以防止重新构建一个已经构建好的对象。我们进一步复制该对象，以便对该对象的更改不会无意中影响可能已经引用了该对象的内容。此外，代码还会检查构建步骤被调用的次数，以及对象是否已构建。这是一种契约执行类型，以确保构建器被正确使用，并且单元被无意中跳过或错过，这在上面的天真解决方案中是缺乏的。这段代码还期望对象有一个接口。这也激发了为对象编写抽象基类的动机:

这里，我们利用抽象类中的属性来指定该类的属性契约，因为通常不可能指定抽象基类的子类应该具有某些属性。注意,“abstractmethod”装饰器必须在“property”装饰器的下面或里面。只读属性也是在类中实施数据保护的好方法。

让我们看看在我们考虑的两种构造模式中，混凝土建造者看起来是什么样的。记住，每个类都必须实现基类的所有抽象方法。首先是利用每个数据单元的部分构建的模式:

这里我们看到，我们只需要在 build 方法的每次传递中调用 objects 单元构造函数。接下来是利用 finalize 步骤的模式的具体实现:

在这种情况下，构建步骤在构建器内部收集单元，并存储它们以供最终确定步骤使用。由于这个过程对该模式的所有构建者都是通用的，因此将它移到父类(构建者抽象基类的子类)会有所帮助，这样做可以最大化代码重用。

# 摘要

在这个例子中，我们看到了如何使用设计原则来指导设计模式的选择和利用，以实现可扩展的、模块化的设计，这将有助于应用程序快速伸缩，并且缺陷更少。在最终的解决方案中，我们发现了一个额外的好处，即构建器可以被进一步抽象和重用，从而允许不仅从我们的数据库，而且从文件系统和网络 io 进行构建，至少有一些创造性。

现在，细心的读者会注意到:最终解决方案中的代码比原始解决方案中的多得多。这永远是真的。快速、肮脏的编程方式会给你最少的代码。创建一个强制接口会产生更多的代码。但是，从长远来看，阻力最小的路径最终总是会花费更多，因为应用程序变得脆弱，几乎无法维护。通过将应用程序分离成模块化、松散耦合的组件，维护和扩展变得更加容易。在我们的第一个解决方案中，所有的代码都在一个地方，但是构造代码可能会出于其他目的复制到其他地方，并且数据库访问模式会复制 7 次。任何一种改变都需要更多的重构。此外，由于开发人员不断地在数据库访问模式和对象构造模式中添加他们自己的扭曲，很难推断出元素之间的公共模式是什么，也不可能实施标准，这进一步使维护和扩展代码的过程变得复杂。通过实施接口，推断应用程序正在做什么以及任何给定的时间点变得更容易，从而使调试更容易，重构更简单。

最后一点，当解决设计问题时，牢记最终目标是有帮助的，并且有一个单一的总体目标。在这里，它将数据库访问代码保留在服务层中，并将显式的对象构造细节排除在外。接下来，研究设计原则，询问关于设计思想的尖锐问题，看看是否不能有一个更可操作的、更可概括和更抽象的设计。虽然单一责任原则驱动了我们的示例，但是开闭原则和依赖倒置原则有助于指导最终的解决方案。

最后，牢记目标和原则，考虑可以用来实现设计目标的设计模式。设计是一个迭代的过程，所以你会发现自己在设计过程中反复考虑模式，原则是如何阐明提出的模式的，并磨掉解决方案中的多余部分。有了最终的解决方案，转向语言特定的构造来进一步简化接口，并执行设计决策，可以使您的代码变得流畅美观。