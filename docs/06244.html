<html>
<head>
<title>Resource Handling of Collection of Resources in Scala and challenges with Java try-with-resources</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Scala中资源集合的资源处理和Java try-with-resources的挑战</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/resource-handling-on-collection-of-resources-in-scala-972678c6f99e?source=collection_archive---------3-----------------------#2020-11-07">https://levelup.gitconnected.com/resource-handling-on-collection-of-resources-in-scala-972678c6f99e?source=collection_archive---------3-----------------------#2020-11-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/ab8bd7d39fcb83b6c239d6e86dc0c043.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CCiVbsrEOnQRYyAM"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://unsplash.com/@tamanna_rumee?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Tamanna Rumee </a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><p id="2ea9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Scala生态系统中有很棒的资源处理库。我推荐以下内容作为快速开始。</p><ol class=""><li id="0a7c" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">由齐奥(<a class="ae kc" href="https://github.com/zio/zio" rel="noopener ugc nofollow" target="_blank">https://github.com/zio/zio</a>)管理</li><li id="775e" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">猫.效应.资源(<a class="ae kc" href="https://github.com/typelevel/cats" rel="noopener ugc nofollow" target="_blank">https://github.com/typelevel/cats</a>)</li></ol><p id="5d88" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些库优于其他流行语言中的许多库，尽管我发现主要是与java <code class="fe lp lq lr ls b">try-with-resources.</code>进行比较。这个博客的简单故事是，你可以利用上面提到的这些库的资源管理技术是<strong class="kf ir"> <em class="lt">而不仅仅是Java <code class="fe lp lq lr ls b">try-with-resources</code>的闪亮替代品</em> </strong>，因为一些(嗯，许多)重要的语义在<code class="fe lp lq lr ls b">try-with-resources,</code>中完全丢失了(下面将进一步详述)。因此，我发现在处理资源密集型用例时，这些库是必不可少的。这与基于纤程的并发模型一起，使我们能够并行获取数百万的资源，并针对中断和故障制定明确的释放策略。这些技术在3-4年前就可以在Scala(当谈到JVM时)中使用了。在这个博客中讨论所有这些是不可行的，因此我将集中在一个代码片段上来给出这些事情的要点。</p><p id="09ab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">注意</strong>:谈到并发性，Project Loom在JVM中随处可见，但是它并没有增加任何额外的东西，对于那些几年前就已经通过ZIO/Cats在JVM中使用基于纤程的并发模型的人来说，这并没有太大的惊喜。</p><h2 id="632c" class="lu lv iq bd lw lx ly dn lz ma mb dp mc ko md me mf ks mg mh mi kw mj mk ml mm bi translated">进一步阅读的先决条件</h2><p id="0169" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">1.Scala语法知识<br/> 2。<code class="fe lp lq lr ls b">cats.effect.Resource</code>中的知识</p><p id="83b8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个博客更多的是代码，对于那些已经通读过<code class="fe lp lq lr ls b">cats.effect.Resource</code>的人来说可能有意义。</p><p id="bec9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是博客的代码片段摘要，供那些想了解整个博客摘要的人参考。</p><p id="14d1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于那些想知道更多关于直觉和详细解释的人，请继续阅读“一个简单的例子”</p><pre class="ms mt mu mv gt mw ls mx my aw mz bi"><span id="6fbe" class="lu lv iq ls b gy na nb l nc nd">val listOfResources: List[Resource[Connection]] = List.fill(100)(Resource.mk(acquire)(release))</span><span id="00f6" class="lu lv iq ls b gy ne nb l nc nd">val resource: Resource[List[Connection]] = listOfResource.sequence</span><span id="99cf" class="lu lv iq ls b gy ne nb l nc nd">val dbResult: IO[DbResult] = resource.use(r =&gt; // use all connections or not, all connections will surely be closed)</span><span id="ba10" class="lu lv iq ls b gy ne nb l nc nd">// or use it one by one, making sure conn are closed as and when they are used.</span><span id="8181" class="lu lv iq ls b gy ne nb l nc nd">val dbResults: IO[List[DbResult]] = <br/>  listOfResources.traverse(resource =&gt; resource.use(con =&gt; getDbResult(con))</span></pre><h2 id="b346" class="lu lv iq bd lw lx ly dn lz ma mb dp mc ko md me mf ks mg mh mi kw mj mk ml mm bi translated">一个简单的例子。</h2><p id="00e9" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">假设您正在从<a class="ae kc" href="https://aws.amazon.com/free/?all-free-tier.sort-by=item.additionalFields.SortRank&amp;all-free-tier.sort-order=asc&amp;awsf.Free%20Tier%20Categories=categories%23storage&amp;trk=ps_a134p000006gEalAAE&amp;trkCampaign=acq_paid_search_brand&amp;sc_channel=PS&amp;sc_campaign=acquisition_ANZ&amp;sc_publisher=Google&amp;sc_category=Storage&amp;sc_country=ANZ&amp;sc_geo=APAC&amp;sc_outcome=acq&amp;sc_detail=%2Bamazon%20%2Bs3&amp;sc_content=S3_bmm&amp;sc_matchtype=b&amp;sc_segment=476957268618&amp;sc_medium=ACQ-P|PS-GO|Brand|Desktop|SU|Storage|S3|ANZ|EN|Text&amp;s_kwcid=AL!4422!3!476957268618!b!!g!!%2Bamazon%20%2Bs3&amp;ef_id=CjwKCAiAqJn9BRB0EiwAJ1SztQj-NWAzRMZqn-Qt0LF5ethVVWfF72GIFUxtrdyuGGYkVg4yxbeVghoC7VoQAvD_BwE:G:s&amp;s_kwcid=AL!4422!3!476957268618!b!!g!!%2Bamazon%20%2Bs3" rel="noopener ugc nofollow" target="_blank">亚马逊S3 </a>目录下载文件，并且在您将这些文件下载到您的本地机器/应用程序内存中之后，您正在进行一些处理——可能会将内容加密到一个单独的临时文件中，然后将这些加密的文件(以及获取它们的元数据，如大小、校验和等)发送到另一个下游系统。</p><p id="d323" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">可以有多个文件，也可以只有一个文件，用户可以选择一个接一个地发送，或者一起发送，或者同时发送。除此之外，您必须确保您没有向下游发送重复的文件，这意味着您还需要管理一个状态。</p><p id="52f6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里是一个快速的起点。这只是一个小装饰，但在猫身上却是有用的装饰。</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="fd66" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们创建一个可以从S3下载文件的<code class="fe lp lq lr ls b">downloadAllFiles</code>函数。不是一个伟大的名字，但名字真的不重要。抛开代码中的细节，主要重要的是<code class="fe lp lq lr ls b">downloadAllFiles</code>的签名。你能猜到它为什么返回类型<code class="fe lp lq lr ls b">Resources</code>吗？</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="c7e0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">总之，<code class="fe lp lq lr ls b">downloadAllFiles</code>不做任何事情——它只是返回<code class="fe lp lq lr ls b">List[cats.effect.Resource[IO, TemporaryFile]]</code>(还不是资源[IO，List[TemporaryFile]]),然后被封装在<code class="fe lp lq lr ls b">Resources</code>数据类型中。这在很多方面限制了用户。他们必须调用<code class="fe lp lq lr ls b">use</code>(或executeAll)来处理资源，这迫使他们在编译时考虑资源的获取和释放。</p><p id="d7aa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">简而言之，真正有保证的资源释放。让我们看看<code class="fe lp lq lr ls b">TemporaryFile</code>的实现。简而言之，它只是文件的<code class="fe lp lq lr ls b">cats.effect.Resource </code>。</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="24bd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是一段冗长的代码，但大多数情况下，它们将成为应用程序代码中的黑盒，它们的使用将成为各种用例的首选。</p><p id="db38" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我将浏览几个例子，这些例子清楚地揭示了用例。</p><h2 id="a297" class="lu lv iq bd lw lx ly dn lz ma mb dp mc ko md me mf ks mg mh mi kw mj mk ml mm bi translated">示例1:最明显的用法—一次发送一个文件，但保持一个状态</h2><pre class="ms mt mu mv gt mw ls mx my aw mz bi"><span id="79ea" class="lu lv iq ls b gy na nb l nc nd">downloadAllFiles(...).use((_, a) =&gt; sendFile(a))</span></pre><p id="8a97" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上述用法确保了以下几点:</p><ul class=""><li id="e496" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la nh lh li lj bi translated">所有文件将被单独下载，并将内容复制到本地重命名的文件中</li><li id="677b" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la nh lh li lj bi translated">在这个获取过程中的任何失败都将保证弹性行为——如果它同时打开了任何东西，它会捕捉并告诉用户正在关闭资源。</li><li id="38c3" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la nh lh li lj bi translated">通过将这些文件传递给sendFile(到某个目的地)来逐个使用它们。并保证单独清理与<strong class="kf ir"> i </strong> t相关的所有资源。在某种程度上，这意味着，在执行相应的sendFile之前，资源不会被分配。</li><li id="0c93" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la nh lh li lj bi translated">这禁止在需要传输之前下载多个文件(可能在s3路径中，具有适当的大小)。这在很大程度上避免了内存崩溃。此外，其中一个文件传输的失败会导致立即删除相应的资源。</li><li id="855f" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la nh lh li lj bi translated">你也可以保持一个执行状态，比如避免发送多个文件，或者累积文件的大小。由于这些文件在任何时候都不是一起存在的，所以我们需要保持一个状态。例如，下面给出的代码确保我们不会在没有将资源收集到内存中的情况下发送重复的文件，<em class="lt">允许即时清理</em>。</li></ul><pre class="ms mt mu mv gt mw ls mx my aw mz bi"><span id="454e" class="lu lv iq ls b gy na nb l nc nd">downloadFiles(...)<br/> .use(<br/>    Resources.trackDuplicate(sendFile)(_.toString)(<br/>      name =&gt;  s"Duplicate file tracked. ${name}"<br/>    )</span></pre><h2 id="512a" class="lu lv iq bd lw lx ly dn lz ma mb dp mc ko md me mf ks mg mh mi kw mj mk ml mm bi translated">示例2:execute all—收集所有资源以获取文件列表，一起发送它们并一起释放资源。</h2><pre class="ms mt mu mv gt mw ls mx my aw mz bi"><span id="88ae" class="lu lv iq ls b gy na nb l nc nd">downloadAllFiles(...)<br/>  .executeAll<br/>  .use(allFiles =&gt; sendAllFiles(allFiles))</span></pre><ul class=""><li id="825c" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la nh lh li lj bi translated">在这种情况下，资源是累积的(并且不会启动任何进一步的清理/使用过程，直到所有资源都被获取)</li><li id="4a86" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la nh lh li lj bi translated">也就是说，它允许您在以后的某个时间点将下载并重命名的文件集合<strong class="kf ir">与</strong>一起使用。<code class="fe lp lq lr ls b">sendAllFiles</code>就是一个例子。</li><li id="4e88" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la nh lh li lj bi translated">它保证在成功或失败执行<code class="fe lp lq lr ls b">sendAllFiles</code>之后，释放与集合关联的<strong class="kf ir">的所有资源</strong></li><li id="4b3d" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la nh lh li lj bi translated">一个实际的例子:对于使用spark的<strong class="kf ir"/>JDBC转移，我们可能需要整理文件的所有资源，只有在集体转移到SQL数据库后才关闭它们。</li></ul><h2 id="8a65" class="lu lv iq bd lw lx ly dn lz ma mb dp mc ko md me mf ks mg mh mi kw mj mk ml mm bi translated">示例3:收集资源，但逐个发送文件(示例2的一个版本)</h2><p id="64f9" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">您也可以一起获取资源，但是单独使用每个资源(可能是一些复杂的过程),并保证在所有时间点释放所有资源。</p><pre class="ms mt mu mv gt mw ls mx my aw mz bi"><span id="0e0a" class="lu lv iq ls b gy na nb l nc nd">downloadAllFiles(...)<br/>  .executeAll<br/>  .use(allFiles =&gt; allFiles.traverse(a =&gt; sendFile(a)))</span></pre><p id="4c84" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">整个想法相当于Java中的<code class="fe lp lq lr ls b">descriptive</code> <code class="fe lp lq lr ls b">try-with-resources</code>的<code class="fe lp lq lr ls b">Composable</code>(版本)的<code class="fe lp lq lr ls b">Collection</code>。但是这样的事情是不存在的。</p><h2 id="cb35" class="lu lv iq bd lw lx ly dn lz ma mb dp mc ko md me mf ks mg mh mi kw mj mk ml mm bi translated">Java中使用资源尝试的挑战</h2><p id="7afb" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">将上述资源处理的模块化解决方案移植回Java try-with-resource相当具有挑战性，但是，这是一个很好的尝试:</p><ul class=""><li id="7af4" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la nh lh li lj bi translated">try-with-resources有边缘情况(显然我听说它正在被修复),其中try(var f = foo())可能对可能失败的资源做一些事情，并且它从未在内部包装在try catch中。那就是你的第一次资源收购可能会失败。在这种情况下，您可能会用另一个try-catch(我不知道)来包装try-with-resources</li><li id="a34e" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la nh lh li lj bi translated">下一个挑战是，我们如何确保try-with-resources不会将资源的获取和释放以及它的使用混为一谈。你不能把它们分开，因为资源的“使用”应该伴随着它，这意味着我们如何在一个地方安全地获得资源，但在它们被用在其他地方后又让它们关闭。</li><li id="a6bd" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la nh lh li lj bi translated">另外，尝试并行获取资源并单独使用它们，但要确保在使用完所有资源后关闭所有资源。同时，如果任何一个使用失败，请确保释放所有其他资源。</li><li id="6dd3" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la nh lh li lj bi translated">如果你设法跳过了以上所有的障碍，那么阅读代码，看看我们是否能静态地证明所有的资源使用位置都与一个资源释放绑定在一起。</li></ul><p id="fdba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦这些都完成了，为了大家的利益，把你的结果贴在评论区吧:)</p><p id="e582" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我希望，你能从我的写作中有所收获。如果你认为它太抽象，我会用更多的上下文和推理来进一步改进它。</p><p id="ea2a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我感谢John De Goes分享了他关于Java资源尝试的精彩想法，这启发了我写更多关于资源尝试的挑战。我建议通过以下途径浏览约翰的课程:https://patreon.com/jdegoes</p><p id="df44" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">干杯！</p></div></div>    
</body>
</html>