<html>
<head>
<title>Go Module’s Replace</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go模块的更换</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/go-modules-replace-3ea6d0139c91?source=collection_archive---------4-----------------------#2020-12-18">https://levelup.gitconnected.com/go-modules-replace-3ea6d0139c91?source=collection_archive---------4-----------------------#2020-12-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/a6ada2756911490411b21bd94e286504.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JdDH0nv6D-8NRDHV"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">由<a class="ae kf" href="https://unsplash.com/@yskeong?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> SK Yeong </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="846b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我相信及时更新软件依赖关系是正确的。我从来不喜欢<em class="le">如果它没坏，就不要更新它</em>的方法。我以前写过关于这个的文章。对于我定期运行的Go项目:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="0a73" class="lo lp it lk b gy lq lr l ls lt">$ go get -u the/module/name</span></pre><p id="6c22" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用当前项目的/module/name<em class="le">来更新项目中的依赖关系。通常，这只是与<em class="le"> go.mod </em>文件相冲突，并做正确的事情，将所有模块及其依赖项更新到最新最好的。有时，当您运行这个时，如果一个依赖项引入了一个突破性的变化，您的代码将不会构建，或者您的测试会失败。此时，你只需<em class="le">做必要的事情</em>，修改你的代码，就大功告成了。</em></p><p id="812a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，偶尔您会遇到以下情况。你依赖模块<em class="le">一个</em>，后者依赖模块<em class="le"> X </em>。你也依赖模块<em class="le">两个</em>，那个<strong class="ki iu">也</strong>依赖模块<em class="le"> X ( </em>模块X被称为<a class="ae kf" href="https://en.wikipedia.org/wiki/Transitive_dependency" rel="noopener ugc nofollow" target="_blank">传递依赖</a>)。在这个场景中，X引入了一个突破性的变化，模块一对此做出了响应，但是模块二忽略了它。你被夹在中间，你想要最新的东西，但最新的想要最新的X，但最新的两个想要旧的，不兼容的X。</p><p id="38db" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你是做什么的？好吧，你可以等待，希望两个赶上来，也许礼貌地要求他们这样做，或者你可以尝试自己解决问题。</p><h2 id="96b8" class="lo lp it bd lu lv lw dn lx ly lz dp ma kr mb mc md kv me mf mg kz mh mi mj mk bi translated">好公民解决方案</h2><p id="04fb" class="pw-post-body-paragraph kg kh it ki b kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">你可以做一个好公民，做到以下几点:</p><ol class=""><li id="2e04" class="mq mr it ki b kj kk kn ko kr ms kv mt kz mu ld mv mw mx my bi translated">叉回购二</li><li id="cb2d" class="mq mr it ki b kj mz kn na kr nb kv nc kz nd ld mv mw mx my bi translated">运行<em class="le">go-u两个</em>处理突发变化。</li><li id="3e2b" class="mq mr it ki b kj mz kn na kr nb kv nc kz nd ld mv mw mx my bi translated">将更新提交到您的fork。</li><li id="b293" class="mq mr it ki b kj mz kn na kr nb kv nc kz nd ld mv mw mx my bi translated">在两点钟向你的叉子提交一个拉请求</li><li id="652d" class="mq mr it ki b kj mz kn na kr nb kv nc kz nd ld mv mw mx my bi translated">请他们接受更新</li><li id="aaab" class="mq mr it ki b kj mz kn na kr nb kv nc kz nd ld mv mw mx my bi translated">等待拉请求被合并</li></ol><p id="9034" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">希望他们很高兴有人帮助他们，合并你的更改，你现在可以更新你的原始项目，一切都会正常工作。</p><h2 id="c697" class="lo lp it bd lu lv lw dn lx ly lz dp ma kr mb mc md kv me mf mg kz mh mi mj mk bi translated">如果他们不合并变化呢？</h2><p id="55a0" class="pw-post-body-paragraph kg kh it ki b kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">如果拉请求没有被合并，Go有一个解决方案。你可以在你的<em class="le"> go.mod </em>中用你的叉子<a class="ae kf" href="https://golang.org/ref/mod#go-mod-file-replace" rel="noopener ugc nofollow" target="_blank">替换</a>原来的两个参考！</p><h2 id="0e90" class="lo lp it bd lu lv lw dn lx ly lz dp ma kr mb mc md kv me mf mg kz mh mi mj mk bi translated">实际例子</h2><p id="8d04" class="pw-post-body-paragraph kg kh it ki b kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">我有一个项目<a class="ae kf" href="https://github.com/nwillc/snipgo" rel="noopener ugc nofollow" target="_blank"> snipgo </a>，使用了github.com/gdamore/tcell和github.com/pgavlin/femto的<em class="le">:</em></p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="8264" class="lo lp it lk b gy lq lr l ls lt"><em class="le">module </em>github.com/nwillc/snipgo<br/><br/><em class="le">go </em>1.15<br/><br/><em class="le">require </em>(<br/>  ...<br/>   github.com/gdamore/tcell v1.4.0<br/>  ...<em class="le"><br/>   </em>github.com/pgavlin/femto v0.0.0-20191028012355-31a9964a50b5<br/>  ...<em class="le"><br/></em>)</span></pre><p id="6386" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另外，<em class="le">github.com/pgavlin/femto</em><strong class="ki iu">也</strong>用了<em class="le"> tcell </em>，所以在那里也是传递依赖。</p><p id="18c5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我跑的时候:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="0162" class="lo lp it lk b gy lq lr l ls lt">go get -u github.com/nwillc/snipgo</span></pre><p id="32b8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le"> tcell </em>模块更新了，以一种我可以轻松应对的中断方式，但是<em class="le"> femto </em>模块还没有更新。我遵循了上面的六个步骤…<em class="le">【蟋蟀的声音】</em>他们没有回应我的拉请求。</p><h2 id="d2c4" class="lo lp it bd lu lv lw dn lx ly lz dp ma kr mb mc md kv me mf mg kz mh mi mj mk bi translated">去模块更换救援！</h2><p id="199e" class="pw-post-body-paragraph kg kh it ki b kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">我不想让自己等着，所以有个解决办法。在我的分叉回购中，我做到了:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="b776" class="lo lp it lk b gy lq lr l ls lt">go list all -m github.com/nwillc/femto</span></pre><p id="b0cf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个命令显示了我的fork的详细版本信息。接下来，我编辑了我的原始项目的<em class="le"> go.mod </em>,在最后添加了一个替换版本信息:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="e52f" class="lo lp it lk b gy lq lr l ls lt">replace<em class="le"> </em>github.com/pgavlin/femto =&gt; github.com/nwillc/femto v0.0.0-20201217031030-474e70183a86</span></pre><p id="bc57" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那个用我的叉子<em class="le">github.com/nwillc/femto</em>把<em class="le">github.com/pgavlin/femto</em>给“替换”了。最后，回到snipgo，我再次尝试:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="7a94" class="lo lp it lk b gy lq lr l ls lt">go get -u github.com/nwillc/snipgo</span></pre><p id="49e9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">维奥拉。现在两个<em class="le"> tcell </em>和<em class="le"> femto </em>，特别是我用叉子替换的<em class="le"> femto </em>，两个都是同一版本，其他的都自己解决了！</p><h2 id="a05b" class="lo lp it bd lu lv lw dn lx ly lz dp ma kr mb mc md kv me mf mg kz mh mi mj mk bi translated">何必呢？</h2><p id="7a25" class="pw-post-body-paragraph kg kh it ki b kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">似乎过分了？何必呢？这条路线有几个主要优点:</p><ol class=""><li id="0d7a" class="mq mr it ki b kj kk kn ko kr ms kv mt kz mu ld mv mw mx my bi translated">你的好公民努力可能仍然有回报，他们可能会合并你的工作。</li><li id="7fd1" class="mq mr it ki b kj mz kn na kr nb kv nc kz nd ld mv mw mx my bi translated">在他们这么做之前，替换策略允许你<strong class="ki iu">保持你的代码导入不变</strong>，也允许你以一种对使用你的回购的人透明的方式<strong class="ki iu">将变更推送到你的项目的回购。</strong></li><li id="b1ad" class="mq mr it ki b kj mz kn na kr nb kv nc kz nd ld mv mw mx my bi translated">当Pull请求合并时，您可以轻松地删除replace。</li></ol><h2 id="1271" class="lo lp it bd lu lv lw dn lx ly lz dp ma kr mb mc md kv me mf mg kz mh mi mj mk bi translated">更新</h2><p id="06f0" class="pw-post-body-paragraph kg kh it ki b kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated"><em class="le"> femto </em>回购最终接受了我的PR，我只是移除了<em class="le"> replace </em>，项目使用原始回购一切正常。</p></div></div>    
</body>
</html>