<html>
<head>
<title>Generate a Sitemap With Next.js and TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Next.js和TypeScript生成站点地图</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/generate-a-sitemap-with-next-js-and-typescript-906add9df0a7?source=collection_archive---------10-----------------------#2021-03-02">https://levelup.gitconnected.com/generate-a-sitemap-with-next-js-and-typescript-906add9df0a7?source=collection_archive---------10-----------------------#2021-03-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0788" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">为你的Next.js项目改进搜索引擎优化</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/8a9d389eaa69726bca48d7d073e9aef6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qKWvSR2XaHmXrS1X"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">安妮·斯普拉特在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><blockquote class="kw kx ky"><p id="0704" class="kz la lb lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><em class="iq">作为一名React开发人员，你现在可能已经听说过Next.js了。它是一个优秀的基于React的框架，用于服务器端渲染和生成静态网站。它有许多开箱即用的功能。但是，它不提供关于站点地图的功能。幸运的是，只需很少的代码，就可以将这样的功能添加到任何Next.js项目中。本文将展示如何实现这一点。</em></p></blockquote><h1 id="a937" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">什么是网站地图？</h1><p id="7e12" class="pw-post-body-paragraph kz la iq lc b ld mo jr lf lg mp ju li mq mr ll lm ms mt lp lq mu mv lt lu lv ij bi translated">让我们回忆一下什么是网站地图。站点地图是一个文件，您可以在其中提供有关网站页面的信息。网站地图有助于搜索引擎更智能地抓取你的网站。</p><p id="08eb" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li mq lk ll lm ms lo lp lq mu ls lt lu lv ij bi translated">当一个网站包含大量页面时，提供一个站点地图是合适的。站点地图帮助解决的另一个用例是孤立页面。孤立页面是指在网站上的其他任何地方都不被引用的页面。通常孤立页面不会被爬虫发现。</p><p id="1b1b" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li mq lk ll lm ms lo lp lq mu ls lt lu lv ij bi translated">爬虫将浏览网站并打开它找到的链接。因此，如果页面没有链接到任何地方，它就不会被索引。网站地图告诉搜索引擎这些页面的存在，确保这些页面在你的网站抓取过程中被找到。</p><p id="4d2c" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li mq lk ll lm ms lo lp lq mu ls lt lu lv ij bi translated">值得注意的是，使用网站地图并不能保证网站地图中的所有项目都会被抓取和索引。搜索引擎的内部运作依赖于复杂的算法，而这些算法并不是公共知识。然而，在大多数情况下，你的站点会从拥有一个站点地图中受益，你永远不会因为拥有一个站点地图而受到惩罚。你可以在这里了解更多关于网站地图的信息。</p><h1 id="2a4a" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">网站地图的结构</h1><p id="37a5" class="pw-post-body-paragraph kz la iq lc b ld mo jr lf lg mp ju li mq mr ll lm ms mt lp lq mu mv lt lu lv ij bi translated">有多种文件格式可以用于站点地图文件。XML格式是最常用的。因此，本文使用XM来实现站点地图。站点地图的XML需要符合特定的模式。您可以在下面的代码片段中找到站点地图的示例。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="76c3" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li mq lk ll lm ms lo lp lq mu ls lt lu lv ij bi translated">协议的精确文档可以在<a class="ae kv" href="https://www.sitemaps.org/protocol.html" rel="noopener ugc nofollow" target="_blank">这里</a>找到。并非<code class="fe my mz na nb b">url</code>元素的所有子元素都是必需的。只有<code class="fe my mz na nb b">loc</code>元素是必需的，它描述了网页的URL。其余的元素是可选的。如果你不确定子元素和元素是什么意思，你可以在这里阅读更多关于XML的内容。</p><h1 id="5935" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">Next.js中的站点地图</h1><p id="a679" class="pw-post-body-paragraph kz la iq lc b ld mo jr lf lg mp ju li mq mr ll lm ms mt lp lq mu mv lt lu lv ij bi translated">那么如何在Next.js中生成站点地图呢？有多种方法可以解决这个问题。和大多数问题一样，已经有现成的解决方案。如果你愿意，你可以使用一个npm包，比如<a class="ae kv" href="https://www.npmjs.com/package/nextjs-sitemap-generator" rel="noopener ugc nofollow" target="_blank">nextjs-sitemap-generator</a>或者<a class="ae kv" href="https://www.npmjs.com/package/next-sitemap" rel="noopener ugc nofollow" target="_blank"> next-sitemap </a>来为你完成这项工作。</p><p id="f78e" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li mq lk ll lm ms lo lp lq mu ls lt lu lv ij bi translated">但是这有什么意思呢？我试图将我的项目依赖保持在最低限度。更不用说构建自己的实现会让您对所使用的工具有更多的经验和知识。</p><p id="bba6" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li mq lk ll lm ms lo lp lq mu ls lt lu lv ij bi translated">使用Next.js本身的推荐方式是静态页面生成。如果页面使用静态生成，则页面的标记在生成时生成。我们也可以选择只在构建时构建站点地图。如果网站是真正静态的，并且页面数量不变，这将是一个很好的解决方案。</p><p id="1df0" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li mq lk ll lm ms lo lp lq mu ls lt lu lv ij bi translated">但是，让我们考虑一下偶尔添加页面的网站场景，例如，博客或电子商务网站。在这种情况下，每当添加新页面时，让站点地图动态变化是很有用的。</p><h1 id="5618" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">实现功能</h1><p id="5d10" class="pw-post-body-paragraph kz la iq lc b ld mo jr lf lg mp ju li mq mr ll lm ms mt lp lq mu mv lt lu lv ij bi translated">网站地图将使用服务器端呈现在每个请求上动态生成。在呈现站点地图之前，需要知道网站上的页面。在Next.js中，页面基于包含在<code class="fe my mz na nb b">pages</code>目录中的文件。每个页面都根据其文件名与一个路径相关联。更多关于Next.js的路由可以在<a class="ae kv" href="https://nextjs.org/docs/routing/introduction" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="99ac" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li mq lk ll lm ms lo lp lq mu ls lt lu lv ij bi translated">一种选择是使用节点的文件系统模块遍历<code class="fe my mz na nb b">pages</code>文件夹，并手动解析文件名。然而，人们可能期望Next.js在构建时将它解析的路由存储在某个地方。事实的确如此；这些路径存储在<code class="fe my mz na nb b">.next\\server\\pages-manifest.json</code>文件的构建文件夹中。这可以用来收集静态路由，我们将在后面的章节中讨论动态路由。</p><p id="2c91" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li mq lk ll lm ms lo lp lq mu ls lt lu lv ij bi translated">这将证明是非常有用的。让我们在pages文件夹中创建一个名为<code class="fe my mz na nb b">sitemap.tsx</code>的文件。这个文件将负责呈现站点地图。该文件需要导出一个名为<code class="fe my mz na nb b">getServerSideProps</code>的函数，如这里的<a class="ae kv" href="https://nextjs.org/docs/basic-features/pages#server-side-rendering" rel="noopener ugc nofollow" target="_blank">所示</a>。</p><p id="4874" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li mq lk ll lm ms lo lp lq mu ls lt lu lv ij bi translated">在阅读这个函数的文档时，可以看到它接收了一个名为context的参数。这个对象的属性之一是<code class="fe my mz na nb b">res</code>，节点响应对象。该对象包含允许设置HTTP响应的头并直接写入响应体的函数。这些函数可用于将Content-Type头设置为XML，并将XML字符串写入响应正文。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="8160" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li mq lk ll lm ms lo lp lq mu ls lt lu lv ij bi translated">在上面的代码中，首先导入必要的模块。这些是Node的文件系统和路径模块，将用于读取清单文件。请注意，这些是服务器端模块。这样的模块可以安全地用在<code class="fe my mz na nb b">getServerSideProps</code>函数中，因为该函数中使用的模块不包含在Next.js的客户端包中</p><p id="fc45" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li mq lk ll lm ms lo lp lq mu ls lt lu lv ij bi translated">文件系统模块稍后会在另一个功能中使用。如果一个函数被声明并且没有在<code class="fe my mz na nb b">getServerSideProps</code>中使用，那么它将被包含在客户端包中。这导致了一些问题，因为文件系统模块本身不会包含在这个包中，但是使用它的函数会包含在这个包中。构建项目时，这种缺失会导致模块未找到:错误。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="c1e2" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li mq lk ll lm ms lo lp lq mu ls lt lu lv ij bi translated">将上面的代码添加到<code class="fe my mz na nb b">next.config.js</code>中可以解决这个问题。在这里可以找到一个非常有用的工具来检查客户端包中的代码。关于Next.js中代码拆分的详细解释可以在<a class="ae kv" href="https://maikelveen.com/blog/how-to-solve-module-not-found-cant-resolve-fs-in-nextjs" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="08c4" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li mq lk ll lm ms lo lp lq mu ls lt lu lv ij bi translated">接下来定义了一个叫做<code class="fe my mz na nb b">Url</code>的类型。此类型描述了表示站点地图中条目的对象的形状。然后定义一个名为Sitemap的react组件。这个组件是空的，因为在<code class="fe my mz na nb b">getServerSideProp</code>中，响应对象上的end方法被调用。调用此方法表示服务器应该认为此消息是完整的。</p><p id="b88c" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li mq lk ll lm ms lo lp lq mu ls lt lu lv ij bi translated">虽然看起来没什么用，但是组件的定义不能省略，因为<code class="fe my mz na nb b">getServerSideProps</code>函数需要一个组件来附加。如果组件没有包含在文件中，Next.js的构建过程将再次抛出一个错误:<code class="fe my mz na nb b">getServerSideProps</code> <em class="lb">不能附加到页面的组件中，必须从页面中导出。</em></p><p id="6949" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li mq lk ll lm ms lo lp lq mu ls lt lu lv ij bi translated">在我们深入研究该功能的细节之前，让我们考虑一下需要哪些步骤来实现最终目标。该过程的步骤如下:</p><ul class=""><li id="b882" class="nc nd iq lc b ld le lg lh mq ne ms nf mu ng lv nh ni nj nk bi translated">从文件系统中读取清单文件，并获取一个JSON对象。</li><li id="c799" class="nc nd iq lc b ld nl lg nm mq nn ms no mu np lv nh ni nj nk bi translated">解析JSON的内容并检索URL集合。</li><li id="a8c7" class="nc nd iq lc b ld nl lg nm mq nn ms no mu np lv nh ni nj nk bi translated">从构建文件夹输出文件中检索动态路由URL。</li><li id="293c" class="nc nd iq lc b ld nl lg nm mq nn ms no mu np lv nh ni nj nk bi translated">基于URL创建XML站点地图字符串</li></ul><p id="a9cc" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li mq lk ll lm ms lo lp lq mu ls lt lu lv ij bi translated">每个步骤都在单独的功能中实现。在函数<code class="fe my mz na nb b">ReadManifest</code>中读取清单文件。这个函数从清单中返回JSON，函数<code class="fe my mz na nb b">GetPathsFromManifest</code>将它用作构建URL集合的输入。只能从清单中收集静态URL，但是，<code class="fe my mz na nb b">GetPathsFromManifest</code>说明了动态URL。</p><p id="7b39" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li mq lk ll lm ms lo lp lq mu ls lt lu lv ij bi translated">函数<code class="fe my mz na nb b">GetSitemapXml</code>实现了基于URL构建XML字符串的最后一步。本文的以下部分讨论了每个具体步骤。基于所有收集的URL，符合站点地图标准的XML字符串。</p><p id="a7a2" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li mq lk ll lm ms lo lp lq mu ls lt lu lv ij bi translated">在上面的代码中，已经可以看到每个步骤的所有函数调用。在代码中还可以看到但尚未讨论的是<code class="fe my mz na nb b">excludedRoutes</code>数组。这些路径被定义和过滤，因为<a class="ae kv" href="https://nextjs.org/docs/advanced-features/custom-error-page" rel="noopener ugc nofollow" target="_blank">自定义错误页</a>也出现在清单中。如果我们不排除404页面的自定义错误页面，它会出现在站点地图中。这是不希望的，因为该页面实际上返回一个404 HTTP代码。</p><h1 id="7d45" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">读取清单文件</h1><p id="c939" class="pw-post-body-paragraph kz la iq lc b ld mo jr lf lg mp ju li mq mr ll lm ms mt lp lq mu mv lt lu lv ij bi translated">如果要从文件系统中读取清单文件，需要知道它的位置。相对路径是已知的。然而，要获得文件的绝对路径，还需要知道节点进程的工作目录。该值通过调用<code class="fe my mz na nb b">process.cwd</code>函数来检索。由于稍后在不同的函数中也需要这个值，所以它已经绑定到了<code class="fe my mz na nb b">basePath</code>变量。</p><p id="c460" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li mq lk ll lm ms lo lp lq mu ls lt lu lv ij bi translated">在<code class="fe my mz na nb b">ReadManifest</code>中，实现了清单的读取。这个函数中使用了节点的路径和文件系统模块。如前所述，Next.js将其解析的路由保存在pages-manifest JSON文件中。这个JSON文件包含一个键值对列表。</p><p id="9253" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li mq lk ll lm ms lo lp lq mu ls lt lu lv ij bi translated">键表示路由，值表示定义路由组件的文件的路径。该路径指向客户机包中的编译文件，因此如果您在。tsx文件，清单中的路径将有。js扩展。</p><p id="8b2d" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li mq lk ll lm ms lo lp lq mu ls lt lu lv ij bi translated">首先，清单的文件路径是通过将basePath函数参数与文件路径结合起来构建的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="9393" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li mq lk ll lm ms lo lp lq mu ls lt lu lv ij bi translated">在函数试图读取文件之前，会检查文件是否存在。如果文件不存在，函数返回原始的空值。如果是，它会同步读取文件，并使用内置的JSON对象解析内容。<code class="fe my mz na nb b">JSON.parse</code>函数返回一个对象，该对象也由<code class="fe my mz na nb b">ReadManifest</code>函数返回。</p><h1 id="9a99" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">从路由中获取URL</h1><p id="7a4f" class="pw-post-body-paragraph kz la iq lc b ld mo jr lf lg mp ju li mq mr ll lm ms mt lp lq mu mv lt lu lv ij bi translated"><code class="fe my mz na nb b">ReadManifest</code>函数返回一个对象。对于站点地图，需要一个URL列表。从对象中获取这个列表是在<code class="fe my mz na nb b">GetPathsFromManifest</code>函数中完成的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="77bd" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li mq lk ll lm ms lo lp lq mu ls lt lu lv ij bi translated">那么这个函数是怎么回事呢？首先，初始化一个包含路由的空字符串数组。然后，该函数遍历解析后的清单对象中的所有路由。对象的关键字对应于路线。</p><p id="0f80" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li mq lk ll lm ms lo lp lq mu ls lt lu lv ij bi translated">Next.js中有两种路线比较特别。动态路由段用于创建以下划线开头的动态页面和路由。动态路由包含方括号。以下划线开头的路由用于覆盖Next.js的某些默认行为。</p><p id="6989" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li mq lk ll lm ms lo lp lq mu ls lt lu lv ij bi translated">这些路由不应该包含在站点地图中。将使用<code class="fe my mz na nb b">isNextInternalUrl</code>功能过滤路线。该功能的实现方式如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="c26c" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li mq lk ll lm ms lo lp lq mu ls lt lu lv ij bi translated">该函数使用正则表达式来查找Next.js的特殊路线。如果您不熟悉正则表达式，可以使用各种在线资源来阅读它们。</p><h1 id="1242" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">动态路由</h1><p id="8050" class="pw-post-body-paragraph kz la iq lc b ld mo jr lf lg mp ju li mq mr ll lm ms mt lp lq mu mv lt lu lv ij bi translated">Next.js最吸引人的地方在于它能够用来自不同来源的数据动态构建页面。站点地图也应该包含这些页面。</p><p id="b748" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li mq lk ll lm ms lo lp lq mu ls lt lu lv ij bi translated">动态生成的页面是清单中包含方括号的页面。在前面的函数中，这些都被过滤掉，不予考虑。</p><p id="ff13" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li mq lk ll lm ms lo lp lq mu ls lt lu lv ij bi translated">Next.js有两种形式的预渲染:静态生成和服务器端渲染。本节介绍一种在站点地图中包含静态生成的页面的方法。它没有讨论使用服务器端渲染的动态路由，因为对于这种情况没有一个适合所有情况的解决方案。</p><p id="1a4d" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li mq lk ll lm ms lo lp lq mu ls lt lu lv ij bi translated">对于静态生成的页面，数据在构建时获取。该数据提取的逻辑在<code class="fe my mz na nb b">getStaticProps</code>函数中定义。当一个文件定义这个函数时，它还需要定义<code class="fe my mz na nb b">getStaticPaths</code>，返回所有静态预渲染的路由。</p><p id="196a" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li mq lk ll lm ms lo lp lq mu ls lt lu lv ij bi translated">当静态呈现的页面在构建时预呈现时，除了页面HTML文件之外，Next.js还会生成一个保存了<code class="fe my mz na nb b">getStaticProps</code>函数结果的JSON文件。这些文件存储在以下文件夹中:<code class="fe my mz na nb b">.next/server/pages</code></p><p id="3597" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li mq lk ll lm ms lo lp lq mu ls lt lu lv ij bi translated">例如，用Next.js创建的博客有由<code class="fe my mz na nb b">blog/[slug].tsx</code>定义的文章页面。在<code class="fe my mz na nb b">getStaticPaths</code>中定义了slug的可能值列表。对于这些值中的每一个，页面的属性将在构建时收集并保存在一个JSON文件中。有鼻涕虫<code class="fe my mz na nb b">how-to-start-with-react</code>的文章，就会有一个文件:<code class="fe my mz na nb b">.next/server/pages/blog/how-to-start-with-react.json</code>。</p><p id="0382" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li mq lk ll lm ms lo lp lq mu ls lt lu lv ij bi translated">可以遍历<code class="fe my mz na nb b">.next/server/pages</code>来读取JSON文件的所有文件名。以这种方式，收集了所有静态生成的页面的所有已知路由。下一节将讨论如何实现这种遍历。</p><h1 id="e099" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">遍历静态生成的页面属性</h1><p id="9df6" class="pw-post-body-paragraph kz la iq lc b ld mo jr lf lg mp ju li mq mr ll lm ms mt lp lq mu mv lt lu lv ij bi translated"><code class="fe my mz na nb b">GetPathsFromBuildFolder</code>函数负责遍历静态生成页面的保存属性。这些属性存储在<code class="fe my mz na nb b">server/pages</code>文件夹中的JSON文件中。</p><p id="a6cd" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li mq lk ll lm ms lo lp lq mu ls lt lu lv ij bi translated">需要记住的一点是可能的动态URL的深度。例如，您可以创建一个名为<code class="fe my mz na nb b">pages/posts/[id].js</code>的文件，生成的页面将驻留在server/pages文件夹中一个名为pos ts的文件夹中。</p><p id="b44f" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li mq lk ll lm ms lo lp lq mu ls lt lu lv ij bi translated">然而，可能存在不嵌套在文件夹中的页面。该函数需要考虑这两种可能性。基本上，需要完全遍历目录。这是使用递归的一个很好的例子。</p><p id="f336" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li mq lk ll lm ms lo lp lq mu ls lt lu lv ij bi translated">我们已经确定<code class="fe my mz na nb b">GetPathsFromBuildFolder</code>是一个递归函数；让我们深入研究代码！</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="165d" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li mq lk ll lm ms lo lp lq mu ls lt lu lv ij bi translated">如上面的代码所示，该函数有四个参数。参数<code class="fe my mz na nb b">dir</code>描述了在特定函数调用中被遍历的目录。<code class="fe my mz na nb b">urlList</code>存储所有收集的URL。<code class="fe my mz na nb b">host</code>描述了放入站点地图的URL的主机部分。最后，<code class="fe my mz na nb b">basePath</code>描述了Next.js的工作目录，如前所述。</p><p id="2a08" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li mq lk ll lm ms lo lp lq mu ls lt lu lv ij bi translated">首先，该函数读取dir参数中描述的目录内容中的所有元素。然后，对于这个目录中的每个项目，它检查它本身是否是一个目录。如果是，这个函数将被递归调用。</p><p id="a157" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li mq lk ll lm ms lo lp lq mu ls lt lu lv ij bi translated">如果项不是目录，项扩展名是JSON，我们就把它当成路由。扩展和基本路径被删除，路由被添加到<code class="fe my mz na nb b">urlList</code>。</p><h1 id="4f75" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">构建网站地图</h1><p id="080d" class="pw-post-body-paragraph kz la iq lc b ld mo jr lf lg mp ju li mq mr ll lm ms mt lp lq mu mv lt lu lv ij bi translated">至此，所有的URL都已收集完毕。只剩下一件事要做:生成一个XML字符串并在响应中返回它。与路线的实际收集相比，这是一个微不足道的任务。</p><p id="75be" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li mq lk ll lm ms lo lp lq mu ls lt lu lv ij bi translated"><code class="fe my mz na nb b">GetSitemapXML</code>函数使用<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals" rel="noopener ugc nofollow" target="_blank">模板文字</a>实现功能。所有的URL都通过<code class="fe my mz na nb b">GetUrlElement</code>函数映射到适当的XML。它们的实现方式如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><h1 id="63b3" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">结论</h1><p id="7979" class="pw-post-body-paragraph kz la iq lc b ld mo jr lf lg mp ju li mq mr ll lm ms mt lp lq mu mv lt lu lv ij bi translated">本文向您展示了如何为Next.js网站实现sitemap功能(完整代码可以在这里找到<a class="ae kv" href="https://gist.github.com/MaikelVeen/cb3622d398b5fe1742f12cb0365bc952" rel="noopener ugc nofollow" target="_blank"/>)。感谢您的阅读。可以对该功能进行许多改进，比如缓存和读取保存的属性以包含lastModified XML元素。</p><p id="ee2d" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li mq lk ll lm ms lo lp lq mu ls lt lu lv ij bi translated">如果您将代码集成到您的项目中，不要忘记让Google可以使用您的站点地图。有多种方法可以做到这一点，你可以在这里阅读更多关于那个<a class="ae kv" href="https://developers.google.com/search/docs/advanced/sitemaps/build-sitemap" rel="noopener ugc nofollow" target="_blank">的内容。</a></p><h1 id="6b9a" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">资源</h1><div class="nq nr gp gr ns nt"><a href="https://developers.google.com/search/docs/advanced/sitemaps/overview" rel="noopener  ugc nofollow" target="_blank"><div class="nu ab fo"><div class="nv ab nw cl cj nx"><h2 class="bd ir gy z fp ny fr fs nz fu fw ip bi translated">了解网站地图|谷歌搜索中心|谷歌开发者</h2><div class="oa l"><h3 class="bd b gy z fp ny fr fs nz fu fw dk translated">" type": "thumb-down "，" id ":" missingtheinformationneed "，" label ":"缺少我需要的信息" }，{ "type"…</h3></div><div class="ob l"><p class="bd b dl z fp ny fr fs nz fu fw dk translated">developers.google.com</p></div></div><div class="oc l"><div class="od l oe of og oc oh kp nt"/></div></div></a></div><div class="nq nr gp gr ns nt"><a href="https://www.w3schools.com/xml/default.asp" rel="noopener  ugc nofollow" target="_blank"><div class="nu ab fo"><div class="nv ab nw cl cj nx"><h2 class="bd ir gy z fp ny fr fs nz fu fw ip bi translated">XML教程</h2><div class="oa l"><h3 class="bd b gy z fp ny fr fs nz fu fw dk translated">XML代表可扩展标记语言。XML被设计用来存储和传输数据。XML被设计成既是…</h3></div><div class="ob l"><p class="bd b dl z fp ny fr fs nz fu fw dk translated">www.w3schools.com</p></div></div><div class="oc l"><div class="oi l oe of og oc oh kp nt"/></div></div></a></div><div class="nq nr gp gr ns nt"><a href="https://nextjs.org/docs/basic-features/pages#server-side-rendering" rel="noopener  ugc nofollow" target="_blank"><div class="nu ab fo"><div class="nv ab nw cl cj nx"><h2 class="bd ir gy z fp ny fr fs nz fu fw ip bi translated">基本功能:Pages | Next.js</h2><div class="oa l"><h3 class="bd b gy z fp ny fr fs nz fu fw dk translated">Next.js页面是在pages目录下的文件中导出的React组件。了解他们如何在这里工作。</h3></div><div class="ob l"><p class="bd b dl z fp ny fr fs nz fu fw dk translated">nextjs.org</p></div></div><div class="oc l"><div class="oj l oe of og oc oh kp nt"/></div></div></a></div><div class="nq nr gp gr ns nt"><a href="https://developers.google.com/search/docs/advanced/sitemaps/build-sitemap" rel="noopener  ugc nofollow" target="_blank"><div class="nu ab fo"><div class="nv ab nw cl cj nx"><h2 class="bd ir gy z fp ny fr fs nz fu fw ip bi translated">创建并提交网站地图|谷歌搜索中心|谷歌开发者</h2><div class="oa l"><h3 class="bd b gy z fp ny fr fs nz fu fw dk translated">" type": "thumb-down "，" id ":" missingtheinformationneed "，" label ":"缺少我需要的信息" }，{ "type"…</h3></div><div class="ob l"><p class="bd b dl z fp ny fr fs nz fu fw dk translated">developers.google.com</p></div></div><div class="oc l"><div class="ok l oe of og oc oh kp nt"/></div></div></a></div></div></div>    
</body>
</html>