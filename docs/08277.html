<html>
<head>
<title>Linq Behind the Scenes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">幕后的Linq</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/linq-behind-the-scenes-efd664d9ebf8?source=collection_archive---------1-----------------------#2021-04-18">https://levelup.gitconnected.com/linq-behind-the-scenes-efd664d9ebf8?source=collection_archive---------1-----------------------#2021-04-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="bd1e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">中迭代次数的比较。NET 5和。NET框架</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/034c7787d88df2d3c2c60e77a28955b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dlRCRVDlIl-n2mhf"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@matteocatanese" rel="noopener ugc nofollow" target="_blank"> Matteo Catanese </a>在<a class="ae ky" href="https://unsplash.com/photos/PI8Hk-3ZcCU" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="4136" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当下面的代码执行时，会发生多少次源代码“迭代”?</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><h2 id="8ca2" class="lx ly it bd lz ma mb dn mc md me dp mf li mg mh mi lm mj mk ml lq mm mn mo mp bi translated">假设</h2><p id="aaf0" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li ms lk ll lm mt lo lp lq mu ls lt lu im bi translated">大多数人认为两件事之一:</p><ol class=""><li id="0ff4" class="mv mw it lb b lc ld lf lg li mx lm my lq mz lu na nb nc nd bi translated">源只迭代一次，所以对于包含三个项目的源，需要三次迭代/循环。</li><li id="6845" class="mv mw it lb b lc ne lf nf li ng lm nh lq ni lu na nb nc nd bi translated">九次迭代(每个扩展方法迭代集合)。</li></ol><p id="5c4c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们找出正确的答案。</p><h2 id="dd2f" class="lx ly it bd lz ma mb dn mc md me dp mf li mg mh mi lm mj mk ml lq mm mn mo mp bi translated">什么是迭代？</h2><p id="1153" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li ms lk ll lm mt lo lp lq mu ls lt lu im bi translated">我们首先需要就迭代的定义达成一致。</p><p id="d5f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大多数人认为迭代是foreach/for/while等的一次循环。</p><p id="051f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是当你循环遍历一个foreach时会发生什么呢？</p><h2 id="a86d" class="lx ly it bd lz ma mb dn mc md me dp mf li mg mh mi lm mj mk ml lq mm mn mo mp bi translated">foreach句法糖的背后</h2><p id="16d8" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li ms lk ll lm mt lo lp lq mu ls lt lu im bi translated">在幕后，实现了<a class="ae ky" href="https://en.wikipedia.org/wiki/Iterator_pattern#C#" rel="noopener ugc nofollow" target="_blank">迭代器模式</a>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="3766" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的<code class="fe nj nk nl nm b">foreach</code>循环是以下内容的语法糖:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="7a3e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个<code class="fe nj nk nl nm b">foreach</code>循环可以被认为是对<code class="fe nj nk nl nm b">GetEnumerator()</code>的调用，一个<code class="fe nj nk nl nm b">while</code>循环，一个对<code class="fe nj nk nl nm b">MoveNext()</code>的调用和对<code class="fe nj nk nl nm b">Current</code>属性的访问。</p><h2 id="0c73" class="lx ly it bd lz ma mb dn mc md me dp mf li mg mh mi lm mj mk ml lq mm mn mo mp bi translated">迭代定义</h2><p id="d1c7" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li ms lk ll lm mt lo lp lq mu ls lt lu im bi translated">实际的迭代可以认为是对返回<code class="fe nj nk nl nm b">true</code>的<code class="fe nj nk nl nm b">MoveNext()</code>的调用(因为如果它返回<code class="fe nj nk nl nm b">false</code>，则<code class="fe nj nk nl nm b">foreach</code>不会迭代)，并读取<code class="fe nj nk nl nm b">Current</code>属性。</p><p id="113f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于本文的其余部分，记住这一点很重要。</p><h2 id="8baf" class="lx ly it bd lz ma mb dn mc md me dp mf li mg mh mi lm mj mk ml lq mm mn mo mp bi translated">幕后的Linq方法</h2><p id="89bf" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li ms lk ll lm mt lo lp lq mu ls lt lu im bi translated">让我们回到最初的代码片段:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="778d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了理解这里发生了什么，让我们剥去语法的糖衣。</p><h2 id="0e68" class="lx ly it bd lz ma mb dn mc md me dp mf li mg mh mi lm mj mk ml lq mm mn mo mp bi translated">没有句法糖</h2><p id="a5b5" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li ms lk ll lm mt lo lp lq mu ls lt lu im bi translated">上面的代码片段将编译成相同的CIL代码，如果你这样写的话:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="56ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的代码是使用<a class="ae ky" href="https://sharplab.io/" rel="noopener ugc nofollow" target="_blank"> sharplab.io </a>生成的，丑陋的编译器生成的名字被重命名为更加用户友好的名字。</p><p id="082b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我们可以看到在四块句法糖的掩盖下:</p><ol class=""><li id="4da5" class="mv mw it lb b lc ld lf lg li mx lm my lq mz lu na nb nc nd bi translated">Lambda表达式成为静态类成员。</li><li id="1b1a" class="mv mw it lb b lc ne lf nf li ng lm nh lq ni lu na nb nc nd bi translated">列表初始化器变成了单独的类实例，每一个都是使用<code class="fe nj nk nl nm b">List.Add()</code>添加的。</li><li id="6f4f" class="mv mw it lb b lc ne lf nf li ng lm nh lq ni lu na nb nc nd bi translated">扩展方法变成静态方法调用，以相反的书写顺序。</li><li id="4c34" class="mv mw it lb b lc ne lf nf li ng lm nh lq ni lu na nb nc nd bi translated">自动属性成为带有支持字段的属性。</li></ol><p id="bb29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">去掉语法糖的原因是因为这样更容易查看Linq方法发生了什么:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><h2 id="86e2" class="lx ly it bd lz ma mb dn mc md me dp mf li mg mh mi lm mj mk ml lq mm mn mo mp bi translated">ToList()，Where()和Select()</h2><p id="bd16" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li ms lk ll lm mt lo lp lq mu ls lt lu im bi translated">这里我们可以看到，<code class="fe nj nk nl nm b">Select()</code>的结果被用作<code class="fe nj nk nl nm b">Where()</code>的输入，<code class="fe nj nk nl nm b">Where()</code>的结果被用作<code class="fe nj nk nl nm b">ToList()</code>的输入。</p><p id="e3d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nj nk nl nm b">Select()</code>获取列表，以及选择器委托的一个实例，<code class="fe nj nk nl nm b">Where()</code>获取结果，以及谓词委托的一个实例。</p><p id="f8ee" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们检查一下每一项的代码。</p><h2 id="93aa" class="lx ly it bd lz ma mb dn mc md me dp mf li mg mh mi lm mj mk ml lq mm mn mo mp bi translated"><a class="ae ky" href="https://github.com/dotnet/runtime/blob/release/5.0/src/libraries/System.Linq/src/System/Linq/Select.cs#L13" rel="noopener ugc nofollow" target="_blank">选择()</a></h2><p id="3f01" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li ms lk ll lm mt lo lp lq mu ls lt lu im bi translated">英寸NET 5中，<code class="fe nj nk nl nm b">Enumerable</code>中的Linq扩展方法分布在多个文件中，这就是使用<code class="fe nj nk nl nm b">partial</code>关键字的原因。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="45d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nj nk nl nm b">Select()</code>只是返回一个<code class="fe nj nk nl nm b">SelectListIterator&lt;Foo, int&gt;</code>(一个<code class="fe nj nk nl nm b">IEnumerable&lt;T&gt;</code>)的实例，它包含一个对source ( <code class="fe nj nk nl nm b">list</code>)和<code class="fe nj nk nl nm b">selector</code> func的引用。</p><h2 id="22c9" class="lx ly it bd lz ma mb dn mc md me dp mf li mg mh mi lm mj mk ml lq mm mn mo mp bi translated"><a class="ae ky" href="https://github.com/dotnet/runtime/blob/release/5.0/src/libraries/System.Linq/src/System/Linq/Where.cs#L12" rel="noopener ugc nofollow" target="_blank"> Where() </a></h2><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="7a08" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nj nk nl nm b">Where()</code>调用最终创建了<code class="fe nj nk nl nm b">WhereEnumerableIterator&lt;int&gt;</code>的一个实例，传入了一个引用<code class="fe nj nk nl nm b">this</code>，它是充当<code class="fe nj nk nl nm b">Iterator</code>的<code class="fe nj nk nl nm b">SelectListIterator&lt;Foo, int&gt;</code>。</p><p id="88b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">需要注意的一点是，<code class="fe nj nk nl nm b">SelectListIterator&lt;Foo, int&gt;</code>有一个<code class="fe nj nk nl nm b">TSource</code> ( <code class="fe nj nk nl nm b">Foo</code>)和一个<code class="fe nj nk nl nm b">TResult</code> ( <code class="fe nj nk nl nm b">int</code>)，然而<code class="fe nj nk nl nm b">WhereEnumerableIterator&lt;int&gt;</code>只有<code class="fe nj nk nl nm b">TSource</code>被指定，因为<code class="fe nj nk nl nm b">TResult</code>总是<code class="fe nj nk nl nm b">bool</code>。</p><h2 id="54c5" class="lx ly it bd lz ma mb dn mc md me dp mf li mg mh mi lm mj mk ml lq mm mn mo mp bi translated">等级制度</h2><p id="cbf1" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li ms lk ll lm mt lo lp lq mu ls lt lu im bi translated">在我们看<code class="fe nj nk nl nm b">ToList()</code>之前，想象一下我们现在拥有的物体结构可能会有帮助。</p><p id="43fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe nj nk nl nm b">Where()</code>返回之后，在<code class="fe nj nk nl nm b">ToList()</code>被调用之前，我们在最高层有一个<code class="fe nj nk nl nm b">WhereEnumerableIterator&lt;int&gt;</code>实例，包含一个<code class="fe nj nk nl nm b">Func&lt;int, bool&gt;</code> ( <code class="fe nj nk nl nm b">bar =&gt; bar &lt; 4</code>)和一个<code class="fe nj nk nl nm b">IEnumerable&lt;Foo&gt;</code> ( <code class="fe nj nk nl nm b">SelectListIterator&lt;Foo, int&gt;</code>)。</p><p id="65d9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，<code class="fe nj nk nl nm b">SelectListIterator&lt;Foo, int&gt;</code>包含一个<code class="fe nj nk nl nm b">Func&lt;Foo, int&gt;</code>和一个<code class="fe nj nk nl nm b">IEnumerable&lt;Foo&gt;</code> ( <code class="fe nj nk nl nm b">List&lt;Foo&gt;</code>)。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/a4bea2d6750238bfe726066216d9fbd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/format:webp/1*tu3F7h0SvD8Ko9iQs7ve3g.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">对象组成/层次。</figcaption></figure><h2 id="91c2" class="lx ly it bd lz ma mb dn mc md me dp mf li mg mh mi lm mj mk ml lq mm mn mo mp bi translated"><a class="ae ky" href="https://github.com/dotnet/runtime/blob/release/5.0/src/libraries/System.Linq/src/System/Linq/ToCollection.cs#L22" rel="noopener ugc nofollow" target="_blank"> ToList() </a></h2><p id="89b8" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li ms lk ll lm mt lo lp lq mu ls lt lu im bi translated">最后，通过调用<code class="fe nj nk nl nm b">WhereEnumerableIterator&lt;int&gt;.ToList()</code>的<code class="fe nj nk nl nm b">IEnumerable&lt;Foo&gt;</code>接口，在<code class="fe nj nk nl nm b">WhereEnumerableIterator&lt;int&gt;</code>上调用<code class="fe nj nk nl nm b">ToList()</code>。</p><p id="b6fd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">到目前为止，什么都没有发生，我们只是创建并返回了一些对象。</p><p id="0287" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看<code class="fe nj nk nl nm b">WhereEnumerableIterator&lt;int&gt;.ToList()</code>会发生什么。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="703e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，<code class="fe nj nk nl nm b">WhereEnumerableIterator&lt;int&gt;.ToList()</code>遍历<code class="fe nj nk nl nm b">_source</code>，后者是一个<code class="fe nj nk nl nm b">SelectListIterator&lt;Foo, int&gt;</code>，将每个元素添加到一个局部<code class="fe nj nk nl nm b">list</code>。</p><h1 id="f0a5" class="no ly it bd lz np nq nr mc ns nt nu mf jz nv ka mi kc nw kd ml kf nx kg mo ny bi translated">第一次迭代</h1><p id="5bb3" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li ms lk ll lm mt lo lp lq mu ls lt lu im bi translated">如果你想自己调试源代码，你可以按照这些<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/how-to-debug-asp-net-core-source-code-448544c16473">指令</a>去做。</p><p id="3aaf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如我们之前了解到的，上面代码片段中的<code class="fe nj nk nl nm b">foreach</code>只是调用<code class="fe nj nk nl nm b">GetEnumerator()</code>的语法糖，一个<code class="fe nj nk nl nm b">while</code>循环调用枚举器上的<code class="fe nj nk nl nm b">MoveNext()</code>，并访问<code class="fe nj nk nl nm b">Current</code>属性。</p><h2 id="b65d" class="lx ly it bd lz ma mb dn mc md me dp mf li mg mh mi lm mj mk ml lq mm mn mo mp bi translated"><a class="ae ky" href="https://github.com/dotnet/runtime/blob/release/5.0/src/libraries/System.Linq/src/System/Linq/Iterator.cs#L79" rel="noopener ugc nofollow" target="_blank">选择列表迭代器&lt; Foo，int &gt;。GetEnumerator() </a></h2><p id="462e" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li ms lk ll lm mt lo lp lq mu ls lt lu im bi translated">作为<code class="fe nj nk nl nm b">foreach</code>的一部分，发生的第一件事是<code class="fe nj nk nl nm b">GetEnumerator()</code>在<code class="fe nj nk nl nm b">SelectListIterator&lt;Foo, int&gt;</code>的父类<code class="fe nj nk nl nm b">Iterator&lt;Foo&gt;</code>上被调用。这只是返回它自己，因为它已经是一个<code class="fe nj nk nl nm b">IEnumerator&lt;Foo&gt;</code>(也是一个<code class="fe nj nk nl nm b"> IEnumerable&lt;Foo&gt;</code>)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><h2 id="ec82" class="lx ly it bd lz ma mb dn mc md me dp mf li mg mh mi lm mj mk ml lq mm mn mo mp bi translated"><a class="ae ky" href="https://github.com/dotnet/runtime/blob/release/5.0/src/libraries/System.Linq/src/System/Linq/Select.cs#L218" rel="noopener ugc nofollow" target="_blank">选择列表迭代器&lt; Foo，int &gt;。MoveNext() </a></h2><p id="f36b" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li ms lk ll lm mt lo lp lq mu ls lt lu im bi translated">在一个<code class="fe nj nk nl nm b">foreach</code>中，在<code class="fe nj nk nl nm b">GetEnumerator()</code>被调用之后，<code class="fe nj nk nl nm b">MoveNext()</code>被调用。</p><p id="cceb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不要太在意<code class="fe nj nk nl nm b">switch</code>的说法。只知道<code class="fe nj nk nl nm b">_source.GetEnumerator()</code>只叫一次。这里的<code class="fe nj nk nl nm b">_source</code>就是原来的<code class="fe nj nk nl nm b">List&lt;Foo&gt;</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><h2 id="39ce" class="lx ly it bd lz ma mb dn mc md me dp mf li mg mh mi lm mj mk ml lq mm mn mo mp bi translated"><a class="ae ky" href="https://github.com/dotnet/coreclr/blob/master/src/System.Private.CoreLib/shared/System/Collections/Generic/List.cs#L576" rel="noopener ugc nofollow" target="_blank">列表&lt; Foo &gt;。GetEnumerator() </a></h2><p id="b456" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li ms lk ll lm mt lo lp lq mu ls lt lu im bi translated">这由上面代码片段中的第8行调用。这将返回一个<code class="fe nj nk nl nm b">Enumerator</code>结构的实例。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="fa3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回到<code class="fe nj nk nl nm b">SelectListIterator&lt;Foo, int&gt;.MoveNext()</code>内部，<code class="fe nj nk nl nm b">_enumerator.MoveNext()</code>在第12行被调用。</p><h2 id="e207" class="lx ly it bd lz ma mb dn mc md me dp mf li mg mh mi lm mj mk ml lq mm mn mo mp bi translated"><a class="ae ky" href="https://github.com/dotnet/coreclr/blob/master/src/System.Private.CoreLib/shared/System/Collections/Generic/List.cs#L1096" rel="noopener ugc nofollow" target="_blank">List&lt;Foo&gt;. enumerator . movenext()</a></h2><p id="f750" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li ms lk ll lm mt lo lp lq mu ls lt lu im bi translated">这里发生的主要事情是<code class="fe nj nk nl nm b">_current</code>属性被赋予了<code class="fe nj nk nl nm b">_list</code>中的下一项。</p><p id="b082" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">点击<a class="ae ky" href="https://stackoverflow.com/questions/66798333/why-does-listts-movenext-implementation-use-a-locallist" rel="noopener ugc nofollow" target="_blank">此处</a>了解他们为什么引入局部变量<code class="fe nj nk nl nm b">localList</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><h2 id="c8eb" class="lx ly it bd lz ma mb dn mc md me dp mf li mg mh mi lm mj mk ml lq mm mn mo mp bi translated">该过程</h2><p id="4fc4" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li ms lk ll lm mt lo lp lq mu ls lt lu im bi translated">我们现在有了所有感兴趣的代码片段。</p><p id="491b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们讨论正在发生的事情时，请随意向上滚动并查看相关的代码片段。</p><p id="0f6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在调用了<code class="fe nj nk nl nm b">List&lt;Foo&gt;.Enumerator.MoveNext()</code>之后，我们开始通过方法调用反向冒泡。</p><p id="89e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nj nk nl nm b">SelectListIterator&lt;Foo, int&gt;</code>是介于<code class="fe nj nk nl nm b">ToList()</code>(迭代开始的地方)和我们开始的底层<code class="fe nj nk nl nm b">List&lt;Foo&gt;</code>之间的中间人。</p><p id="914a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回到<code class="fe nj nk nl nm b">SelectListIterator&lt;Foo, int&gt;.MoveNext()</code>，我们根据返回<code class="fe nj nk nl nm b">int</code>的选择器，从<code class="fe nj nk nl nm b">List&lt;Foo&gt;</code>的<code class="fe nj nk nl nm b">Enumerator</code>的<code class="fe nj nk nl nm b">_current</code>属性中为其<code class="fe nj nk nl nm b">_current</code>属性赋值。</p><p id="ed6f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后<code class="fe nj nk nl nm b">SelectListIterator&lt;Foo, int&gt;.MoveNext()</code>调用将返回<code class="fe nj nk nl nm b">true</code>，回到它被调用的地方，在<code class="fe nj nk nl nm b">while</code>循环内(显示为<code class="fe nj nk nl nm b">foreach</code>循环)，在<a class="ae ky" href="https://github.com/dotnet/runtime/blob/release/5.0/src/libraries/System.Linq/src/System/Linq/Where.SpeedOpt.cs#L50" rel="noopener ugc nofollow" target="_blank"> ToList() </a>内。</p><p id="db7a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nj nk nl nm b">ToList()</code>然后使用它的谓词来确定<code class="fe nj nk nl nm b">int</code>是否低于4。如果是，则添加到本地<code class="fe nj nk nl nm b">list</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/ae2cc821655edf3a7db2f4d24a0a8dbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/format:webp/1*3wkuD1uD5PhgB70PiRgx1Q.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">“流程”的简化图。</figcaption></figure><h2 id="b768" class="lx ly it bd lz ma mb dn mc md me dp mf li mg mh mi lm mj mk ml lq mm mn mo mp bi translated">多少次迭代？</h2><p id="10ae" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li ms lk ll lm mt lo lp lq mu ls lt lu im bi translated">从上图可以看出，只有两个<code class="fe nj nk nl nm b">MoveNext()</code>方法被调用。</p><p id="8e61" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">foreach迭代仅在<code class="fe nj nk nl nm b">MoveNext()</code>返回<code class="fe nj nk nl nm b">true</code>时发生。</p><p id="f93c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以让我们算出这些<code class="fe nj nk nl nm b">MoveNext()</code>方法被调用了多少次，并返回<code class="fe nj nk nl nm b">true</code>。</p><p id="ea2f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<code class="fe nj nk nl nm b">List&lt;Foo&gt;</code>中有三个元素，我们有对返回<code class="fe nj nk nl nm b">true</code>的<code class="fe nj nk nl nm b">MoveNext()</code>的<code class="fe nj nk nl nm b">3 * 2 = 6</code>调用。</p><p id="179f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你用<code class="fe nj nk nl nm b">foreach</code>和<code class="fe nj nk nl nm b">yield return</code>写等价的代码，将会有六次迭代(每个<code class="fe nj nk nl nm b">foreach</code>三次)。</p><h1 id="5ec4" class="no ly it bd lz np nq nr mc ns nt nu mf jz nv ka mi kc nw kd ml kf nx kg mo ny bi translated">那在……NET框架？</h1><p id="7b94" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li ms lk ll lm mt lo lp lq mu ls lt lu im bi translated">。NET 5比。NET框架。</p><p id="abde" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大部分代码与。净5。主要区别是<code class="fe nj nk nl nm b">Where()</code>和<code class="fe nj nk nl nm b">ToList()</code>。</p><h2 id="673d" class="lx ly it bd lz ma mb dn mc md me dp mf li mg mh mi lm mj mk ml lq mm mn mo mp bi translated"><a class="ae ky" href="https://referencesource.microsoft.com/#system.core/system/linq/Enumerable.cs,119" rel="noopener ugc nofollow" target="_blank"> Where() </a></h2><p id="3670" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li ms lk ll lm mt lo lp lq mu ls lt lu im bi translated"><code class="fe nj nk nl nm b">WhereEnumerableIterator&lt;int&gt;</code>没有优化的<code class="fe nj nk nl nm b">ToList()</code>方法。</p><p id="8e32" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">相反，它只是实现了迭代器模式，使用<code class="fe nj nk nl nm b">predicate</code>在<code class="fe nj nk nl nm b">MoveNext()</code>方法中返回<code class="fe nj nk nl nm b">true</code>或<code class="fe nj nk nl nm b">false</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="c9f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">英寸NET 5，我们现在应该已经完成了，但是因为在。NET框架，<code class="fe nj nk nl nm b">WhereEnumerableIterator&lt;int&gt;</code>并不创建<code class="fe nj nk nl nm b">List&lt;int&gt;</code>，<code class="fe nj nk nl nm b">ToList()</code>必须为我们做这些，这是额外的一步。</p><h2 id="d7bf" class="lx ly it bd lz ma mb dn mc md me dp mf li mg mh mi lm mj mk ml lq mm mn mo mp bi translated"><a class="ae ky" href="https://referencesource.microsoft.com/#System.Core/System/Linq/Enumerable.cs,947" rel="noopener ugc nofollow" target="_blank"> ToList() </a></h2><p id="f3e4" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li ms lk ll lm mt lo lp lq mu ls lt lu im bi translated">这只是调用了<code class="fe nj nk nl nm b">List&lt;int&gt;</code>构造函数，传入了<code class="fe nj nk nl nm b">IEnumerable&lt;int&gt;</code>，也就是<code class="fe nj nk nl nm b">WhereEnumerableIterator&lt;int&gt;</code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><h2 id="ff6b" class="lx ly it bd lz ma mb dn mc md me dp mf li mg mh mi lm mj mk ml lq mm mn mo mp bi translated"><a class="ae ky" href="https://referencesource.microsoft.com/#mscorlib/system/collections/generic/list.cs,74" rel="noopener ugc nofollow" target="_blank">列表&lt; int &gt;建造师</a></h2><p id="502b" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li ms lk ll lm mt lo lp lq mu ls lt lu im bi translated">这里是额外的<code class="fe nj nk nl nm b">MoveNext()</code>调用。NET 5没有。</p><p id="9480" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它们不是组合<code class="fe nj nk nl nm b">List&lt;int&gt;</code>创建和<code class="fe nj nk nl nm b">where</code>谓词，而是在单独的步骤中完成。</p><p id="266b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nj nk nl nm b">List&lt;int&gt;</code>现在已经初始化，我们完成了。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lv lw l"/></div></figure><h1 id="0baf" class="no ly it bd lz np nq nr mc ns nt nu mf jz nv ka mi kc nw kd ml kf nx kg mo ny bi translated">摘要</h1><p id="4ece" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li ms lk ll lm mt lo lp lq mu ls lt lu im bi translated">英寸NET 5，只有两个等价的<code class="fe nj nk nl nm b">foreach</code>循环在幕后发生。然而在。NET框架中，有一个额外的发生，这意味着9次迭代发生，而不是6次。</p><p id="5024" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望您喜欢学习Linq的幕后工作方式。</p><p id="64f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">了解底层实现细节不仅有趣，它还能帮助您编写更好的代码(我相信您知道不要不必要地调用<code class="fe nj nk nl nm b">ToList()</code>)。</p><p id="0e8e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你有任何问题，请随时留下评论。</p></div><div class="ab cl oa ob hx oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="im in io ip iq"><h1 id="d018" class="no ly it bd lz np oh nr mc ns oi nu mf jz oj ka mi kc ok kd ml kf ol kg mo ny bi translated">分级编码</h1><p id="c87d" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li ms lk ll lm mt lo lp lq mu ls lt lu im bi translated">感谢您成为我们社区的一员！<a class="ae ky" href="https://www.youtube.com/channel/UC3v9kBR_ab4UHXXdknz8Fbg?sub_confirmation=1" rel="noopener ugc nofollow" target="_blank">订阅我们的YouTube频道</a>或者加入<a class="ae ky" href="https://skilled.dev/" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> Skilled.dev编码面试课程</strong> </a>。</p><div class="om on gp gr oo op"><a href="https://skilled.dev" rel="noopener  ugc nofollow" target="_blank"><div class="oq ab fo"><div class="or ab os cl cj ot"><h2 class="bd iu gy z fp ou fr fs ov fu fw is bi translated">编写面试问题+获得开发工作</h2><div class="ow l"><h3 class="bd b gy z fp ou fr fs ov fu fw dk translated">掌握编码面试的过程</h3></div><div class="ox l"><p class="bd b dl z fp ou fr fs ov fu fw dk translated">技术开发</p></div></div><div class="oy l"><div class="oz l pa pb pc oy pd ks op"/></div></div></a></div></div></div>    
</body>
</html>