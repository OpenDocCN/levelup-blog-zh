<html>
<head>
<title>Data Preprocessing — Machine Learning in R</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据预处理——R中的机器学习</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/machine-learning-in-r-4ac6d455bb65?source=collection_archive---------1-----------------------#2019-02-20">https://levelup.gitconnected.com/machine-learning-in-r-4ac6d455bb65?source=collection_archive---------1-----------------------#2019-02-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/9fec0319833b4cfc5778815d6a8ea5e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*92h6Lg1Bu1F9QqoVNrkLdQ.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">https://www.flickr.com/photos/mikemacmarketing/30212411048<a class="ae kf" href="https://www.flickr.com/photos/mikemacmarketing/30212411048" rel="noopener ugc nofollow" target="_blank"/></figcaption></figure><p id="0160" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在过去的几周里，我一直在研究机器学习软件<em class="le"> R </em>和<em class="le"> Python </em>并且还学习了几门课程。我注意到我所有的程序都有一个共同点，那就是对数据进行预处理，以便应用机器学习模型。大多数情况下，数据预处理过程分为以下步骤:</p><ul class=""><li id="e816" class="lf lg it ki b kj kk kn ko kr lh kv li kz lj ld lk ll lm ln bi translated">导入数据集。</li><li id="aa0b" class="lf lg it ki b kj lo kn lp kr lq kv lr kz ls ld lk ll lm ln bi translated">完成缺失的数据。</li><li id="8337" class="lf lg it ki b kj lo kn lp kr lq kv lr kz ls ld lk ll lm ln bi translated">编码分类数据。</li><li id="577a" class="lf lg it ki b kj lo kn lp kr lq kv lr kz ls ld lk ll lm ln bi translated">分割数据集。</li><li id="dec1" class="lf lg it ki b kj lo kn lp kr lq kv lr kz ls ld lk ll lm ln bi translated">特征缩放。</li></ul><h2 id="4918" class="lt lu it bd lv lw lx dn ly lz ma dp mb kr mc md me kv mf mg mh kz mi mj mk ml bi translated">导入数据集</h2><p id="fe2a" class="pw-post-body-paragraph kg kh it ki b kj mm kl km kn mn kp kq kr mo kt ku kv mp kx ky kz mq lb lc ld im bi translated">有几种方法可以导入<em class="le">数据集</em>。最简单的方法是从一个. csv文件中导入数据集<em class="le">。为此，您必须执行以下操作:</em></p><p id="0c57" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先你必须设置你的工作目录，</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="adc7" class="lt lu it mw b gy na nb l nc nd">#setwd("~/Desktop/ML/Project1") #Change it to your working directory<br/>setwd("&lt;directory_where_your_dataset_is_located&gt;")</span></pre><p id="c7bd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦您建立了工作目录，您必须导入<em class="le">数据集</em>，</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="b14f" class="lt lu it mw b gy na nb l nc nd">dataset = read.csv('Data.csv')</span></pre><p id="ad9e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">命令<code class="fe ne nf ng mw b">read.csv('filename')</code>接收不同的可选参数，根据数据集在<em class="le">上的排列方式，您必须使用其中一些参数。csv </em>文件。您可以设置<code class="fe ne nf ng mw b">sep</code>参数来指示文件上的分隔符。举个例子，</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="ec5e" class="lt lu it mw b gy na nb l nc nd">dataset = read.csv('Data.csv', sep = ';')<br/># sep = ';' indicates that the separator between each data is ;</span></pre><h2 id="28e5" class="lt lu it bd lv lw lx dn ly lz ma dp mb kr mc md me kv mf mg mh kz mi mj mk ml bi translated">完成缺失的数据</h2><p id="4ae7" class="pw-post-body-paragraph kg kh it ki b kj mm kl km kn mn kp kq kr mo kt ku kv mp kx ky kz mq lb lc ld im bi translated">填写缺失数据是可选的。如果你的<em class="le">数据集</em>是完整的，你显然不需要做这部分。但有时您会发现<em class="le">数据集</em>缺少一些单元格，在这种情况下，您可以做两件事:</p><ul class=""><li id="b84c" class="lf lg it ki b kj kk kn ko kr lh kv li kz lj ld lk ll lm ln bi translated">删除一整行(不推荐，您可能会删除关键信息)。</li><li id="acb8" class="lf lg it ki b kj lo kn lp kr lq kv lr kz ls ld lk ll lm ln bi translated">用该列含义来完成所缺的信息。</li></ul><p id="45e0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">拿下面这个不完整的<em class="le">数据集</em>，</p><figure class="mr ms mt mu gt ju"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="f37e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如您所见，有一些缺失的单元格，一个在<strong class="ki iu">年龄</strong>列，另一个在<strong class="ki iu">收入</strong>列。为了用每一列的平均值T27来填充那些缺失的单元格，你必须执行以下操作:</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="b6ee" class="lt lu it mw b gy na nb l nc nd">dataset$Age = ifelse(is.na(dataset$Age), ave(dataset$Age, FUN = function(x) mean(x, na.rm = TRUE )), dataset$Age)</span><span id="a994" class="lt lu it mw b gy nj nb l nc nd">dataset$Income = ifelse(is.na(dataset$Income), ave(dataset$Income, FUN = function(x) mean(x, na.rm = TRUE )), dataset$Income)</span></pre><p id="911c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们已经检查了每一列上是否有空单元格。如果有，那么空单元格将被替换为列的平均值。</p><p id="dee1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">输出如下所示，</p><figure class="mr ms mt mu gt ju"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="e2aa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">既然数据已经完成，我们可以进入下一步。</p><h2 id="c344" class="lt lu it bd lv lw lx dn ly lz ma dp mb kr mc md me kv mf mg mh kz mi mj mk ml bi translated">编码分类数据</h2><p id="1979" class="pw-post-body-paragraph kg kh it ki b kj mm kl km kn mn kp kq kr mo kt ku kv mp kx ky kz mq lb lc ld im bi translated">这一步也是可选的。根据您的<em class="le">数据集</em>，您可能从一开始就有一个<em class="le">数据集</em>，其中已经编码了分类数据。在那种情况下，你不需要这样做。</p><p id="99f1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们的例子中，我们有<strong class="ki iu">毕业生</strong>列，该列有2个可能的值，或者<strong class="ki iu">是</strong>或者<strong class="ki iu">否</strong>。为了能够处理这些数据，我们必须对其进行编码，这意味着将标签改为数字。在<em class="le"> R </em>中做到这一点真的很简单，你只需要做到以下几点，</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="9ad3" class="lt lu it mw b gy na nb l nc nd">dataset$Graduate = factor(dataset$Graduate, <br/>                         levels = c('yes', 'no'), <br/>                         labels = c(1, 0))</span></pre><p id="85c3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">输出如下所示，</p><figure class="mr ms mt mu gt ju"><div class="bz fp l di"><div class="nh ni l"/></div></figure><h2 id="c586" class="lt lu it bd lv lw lx dn ly lz ma dp mb kr mc md me kv mf mg mh kz mi mj mk ml bi translated">分割数据集</h2><p id="85d8" class="pw-post-body-paragraph kg kh it ki b kj mm kl km kn mn kp kq kr mo kt ku kv mp kx ky kz mq lb lc ld im bi translated">这一部分是强制性的，也是使用机器学习模型时最重要的部分之一。</p><p id="d61a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">分割<em class="le">数据集</em>意味着你要将整个数据集分成两部分，即<em class="le">训练集</em>和<em class="le">测试集</em>。当你想训练一个模型来解决或预测一件特定的事情时，你首先要训练你的模型，然后测试模型是否做了正确的预测。</p><p id="876c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通常比例为80% <em class="le">训练集</em>和20% <em class="le">测试集</em>，但可能会因您的型号而异。我们将按照这个比例分割数据集。</p><p id="589c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您首先必须通过执行以下操作来安装一个名为<code class="fe ne nf ng mw b">caTools</code>的包，</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="dfbe" class="lt lu it mw b gy na nb l nc nd">packages.install('caTools')</span></pre><p id="93b5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦安装完毕，你必须告诉用户你将使用这个库，</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="2347" class="lt lu it mw b gy na nb l nc nd">library(caTools)</span></pre><p id="c150" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下一步是创建一个<em class="le">种子</em>，这将有助于随机化数据分割方式，然后继续分割<em class="le">数据集</em>。为此，请键入以下内容，</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="194a" class="lt lu it mw b gy na nb l nc nd">#Creates a seed, you can type any number, not just 123<br/>set.seed(seed = 123)</span><span id="1c19" class="lt lu it mw b gy nj nb l nc nd">#SplitRatio indicates the size of the training set<br/>split = sample.split(dataset$Purchased, SplitRatio = 0.8)<br/>training_set = subset(dataset, split == TRUE)<br/>test_set = subset(dataset, split == FALSE)</span></pre><p id="6d8b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">既然数据已经分割，我们可以继续进行最后一步。</p><h2 id="657a" class="lt lu it bd lv lw lx dn ly lz ma dp mb kr mc md me kv mf mg mh kz mi mj mk ml bi translated">特征缩放</h2><p id="bb0a" class="pw-post-body-paragraph kg kh it ki b kj mm kl km kn mn kp kq kr mo kt ku kv mp kx ky kz mq lb lc ld im bi translated">这最后一步也不总是必要的。在数据集中，有一些值不在同一个范围内，例如，年龄和收入具有非常不同的范围。</p><p id="25d7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">大多数机器学习模型使用两点之间的<a class="ae kf" href="https://hlab.stanford.edu/brian/euclidean_distance_in.html" rel="noopener ugc nofollow" target="_blank">欧几里德距离</a>工作，但是由于尺度不同，两点之间的距离可能很大，这可能会给你的模型带来问题。</p><p id="ec5b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有些模型已经处理了这一点，因此您不必自己动手，但其他一些模型要求您先对要素进行缩放。为了扩展我们的数据，我们必须运行以下代码，</p><pre class="mr ms mt mu gt mv mw mx my aw mz bi"><span id="165e" class="lt lu it mw b gy na nb l nc nd">training_set[, 1:2] = scale(training_set[, 1:2])<br/>test_set[, 1:2] = scale(test_set[, 1:2])</span></pre><p id="65ed" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如您所看到的，<em class="le"> R </em>有一个缩放所选列的函数，在我们的例子中，我们从前两列开始缩放所有的行。</p><p id="bd00" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">编码的分类数据呢？我们也需要扩展它吗？</p><p id="96a6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有人说对分类数据进行编码是有用的，有人说没有必要。我实验过的是，没那么重要，看你自己。</p></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><h2 id="11f3" class="lt lu it bd lv lw lx dn ly lz ma dp mb kr mc md me kv mf mg mh kz mi mj mk ml bi translated">结论</h2><p id="fd39" class="pw-post-body-paragraph kg kh it ki b kj mm kl km kn mn kp kq kr mo kt ku kv mp kx ky kz mq lb lc ld im bi translated">在多次完成所有这些数据预处理步骤后，您会注意到，如果您的数据从一开始就做好了准备，这些步骤中的一些可以省略。</p><p id="4055" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为什么所有这些步骤都很重要？机器学习最关键的部分之一是拥有一个准备充分且值得信赖的<em class="le">数据集</em>，以正确的方式准备你的信息是拥有一个好的机器学习模型的进一步发展。</p></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><p id="50db" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">查看本文的python版本:<a class="ae kf" href="https://medium.com/@gmotzespina/machine-learning-with-python-d99f13a9e395" rel="noopener">https://medium . com/@ gmotzespina/machine-learning-with-python-d 99 f 13 a9 e 395</a></p></div></div>    
</body>
</html>