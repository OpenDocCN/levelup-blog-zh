<html>
<head>
<title>Learn React useState Hook</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习反应使用状态挂钩</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/learn-react-usestate-hook-a09ccf955537?source=collection_archive---------8-----------------------#2021-07-05">https://levelup.gitconnected.com/learn-react-usestate-hook-a09ccf955537?source=collection_archive---------8-----------------------#2021-07-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="c3f2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">有例子和练习</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/57e45dc63566c5c449c84561a7696560.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*RcO4FUtehN2wyJzl.jpg"/></div></div></figure><p id="5c75" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">钩子是React 16.8的新增功能。它支持在功能组件中使用状态。挂钩是使功能组件能够与react状态关联(挂钩)并使用react生命周期特性的功能。</p><div class="lq lr gp gr ls lt"><a href="https://javascript.plainenglish.io/beginners-guide-to-javascript-callbacks-d8195be73dc5" rel="noopener  ugc nofollow" target="_blank"><div class="lu ab fo"><div class="lv ab lw cl cj lx"><h2 class="bd iu gy z fp ly fr fs lz fu fw is bi translated">JavaScript回调初学者指南</h2><div class="ma l"><h3 class="bd b gy z fp ly fr fs lz fu fw dk translated">通过真实的项目代码样本学习回调的A-Z。</h3></div><div class="mb l"><p class="bd b dl z fp ly fr fs lz fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="mc l"><div class="md l me mf mg mc mh ks lt"/></div></div></a></div><h1 id="1205" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">容易的事情</h1><p id="e2ba" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">首先，你要记住状态是一种内存，用来存储与组件相关的数据。并且即使在重新渲染之后，该记忆也得以保留</p><p id="0df0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">先来看看第一个反应钩是<code class="fe na nb nc nd b">useState</code>钩。</p><p id="2989" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先，在文件开头导入useState挂钩。我们可以使用下面的代码直接从react导入它。<br/> <code class="fe na nb nc nd b">import React, { useState } from 'react';</code></p><p id="6973" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">而现在我们可以用进口的<code class="fe na nb nc nd b">useState</code>挂钩了。<br/>让我们使用<code class="fe na nb nc nd b">useState </code>钩子在函数组件中声明一个新的状态变量。参见下面的<br/>代码<code class="fe na nb nc nd b">const [name, setName] = useState("Initial name");</code></p><p id="8811" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你可以看到<code class="fe na nb nc nd b"> useState</code>已经返回了两个值<code class="fe na nb nc nd b">name </code>和<code class="fe na nb nc nd b">setName</code>。你还可以看到<code class="fe na nb nc nd b">useState </code>也消耗了一个字符串值。</p><p id="e8fa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们来看看返回的两个值是什么，以及这两个值的用法。</p><p id="a8e5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">1-首先是<strong class="kw iu">当前状态</strong>值(<strong class="kw iu">名称</strong>)。<br/> 2-第二，一个用于<strong class="kw iu">更新</strong>当前状态值的函数(<strong class="kw iu"> setName </strong>)。</p><p id="a4f7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用<a class="ae nj" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Array_destructuring" rel="noopener ugc nofollow" target="_blank">数组析构语法方法</a>访问这两个值。我们可以为第一个和第二个值定义任何名称。这里我用了<code class="fe na nb nc nd b">name</code>和<code class="fe na nb nc nd b">setName</code>。基于您的程序用例，您可以在访问<code class="fe na nb nc nd b">useState</code>时给出任何合适的名称。</p><h2 id="4517" class="nk mj it bd mk nl nm dn mo nn no dp ms ld np nq mu lh nr ns mw ll nt nu my nv bi translated">其他一些使用案例</h2><pre class="kj kk kl km gt nw nd nx ny aw nz bi"><span id="d17f" class="nk mj it nd b gy oa ob l oc od">const [age, setAge] = useState(42);<br/>const [fruit, setFruit] = useState('banana');<br/>const [todos, setTodos] = useState([{ text: 'Learn Hooks' }]);</span></pre><p id="513d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe na nb nc nd b">useState</code>拿一个初始论点来说。初始参数只使用一次。如果你初始化一个从0开始的计数器，初始参数将是0。初始参数可以是一个<strong class="kw iu">字符串、object、int、</strong>或任何东西。</p><p id="d541" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在上面的代码块中，我们使用了42 an <strong class="kw iu"> int </strong>值作为age的初始值。<br/>为果一<strong class="kw iu">串</strong>。对于todos，我们使用了一个<strong class="kw iu">对象</strong>。但是请记住，传递初始值仅在初始渲染时使用。之后，在每次渲染时，初始值被忽略。</p><h2 id="b5d0" class="nk mj it bd mk nl nm dn mo nn no dp ms ld np nq mu lh nr ns mw ll nt nu my nv bi translated">使用useState读取状态</h2><p id="ff21" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">通过访问一个<code class="fe na nb nc nd b">useState</code>钩子的返回值可以直接读取状态。你必须在“{}”中使用返回的变量</p><p id="9a3e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe na nb nc nd b">&lt;p&gt;This is my Current {age}&lt;/p&gt;</code></p><h2 id="ffd2" class="nk mj it bd mk nl nm dn mo nn no dp ms ld np nq mu lh nr ns mw ll nt nu my nv bi translated">使用useState更新状态</h2><p id="9154" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">在更新值时，我们可以使用<code class="fe na nb nc nd b">setCount</code>方法来传递新值。<br/>T3】</p><h2 id="2563" class="nk mj it bd mk nl nm dn mo nn no dp ms ld np nq mu lh nr ns mw ll nt nu my nv bi translated">通过例子学习</h2><p id="c0cb" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">示例交互代码—<a class="ae nj" href="https://replit.com/join/swbbobvaeq-lahirutech" rel="noopener ugc nofollow" target="_blank">https://replit.com/join/swbbobvaeq-lahirutech</a><br/>用于设置计数器的示例代码。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><a href="https://replit.com/join/swbbobvaeq-lahirutech"><div class="gh gi oe"><img src="../Images/4a1fb89ce9531ddfced320c1f8160c7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CzaRuIwsG_k98PsS7iaWcw.png"/></div></a></figure><p id="9e1b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在上面的代码中，有一个按钮，每点击一次，我们可以将它加1。所以你可以看到我们进口了<code class="fe na nb nc nd b">useState</code>吊钩。我们已经使用<code class="fe na nb nc nd b">count</code>变量访问了该值，并使用<code class="fe na nb nc nd b">setCount</code>方法操作了count变量的值，在<code class="fe na nb nc nd b">onlick </code>方法中调用了<code class="fe na nb nc nd b">setCount</code>方法。你可以从任何地方调用这个方法</p><p id="f804" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在真实的项目中，你可能正在处理对象，你可能需要使用<code class="fe na nb nc nd b">useState</code>来操作对象。让我们看看如何使用<code class="fe na nb nc nd b">useState</code>来完成这些操作</p><p id="915a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当使用对象作为状态变量时，需要考虑一些棘手的实际概念。</p><h1 id="29dd" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">记住…</h1><p id="5392" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">如果传递与当前状态相同的值来更新状态，react将不会触发重新渲染。<br/>所以如果你正在操纵一个物体作为状态。有一些技巧/实用的方法可以遵循。<br/>让我们看看如何使用<code class="fe na nb nc nd b">useState</code>钩子在<code class="fe na nb nc nd b">onclick</code>事件中操作一个带有键“name:”的状态对象。</p><h2 id="d540" class="nk mj it bd mk nl nm dn mo nn no dp ms ld np nq mu lh nr ns mw ll nt nu my nv bi translated">这种方法行不通</h2><pre class="kj kk kl km gt nw nd nx ny aw nz bi"><span id="6e1c" class="nk mj it nd b gy oa ob l oc od">const UserDetails = () =&gt; {<br/>  const [userObj, setuserObj] = useState({ name: ''});<br/><br/>  return (<br/>    &lt;div&gt;<br/>      &lt;input<br/>        type="text"<br/>        value={userObj.name}<br/>        placeholder="Enter Your Name"<br/>        onChange={e =&gt; {<br/>          userObj.name = e.target.value;<br/>          setuserObj(userObj); // Wrong approach will not work<br/>        }}<br/>      /&gt;<br/>      &lt;p&gt;<br/>        &lt;strong&gt;{userObj.name}&lt;/strong&gt;<br/>      &lt;/p&gt;<br/>  &lt;/div&gt;<br/>  );<br/>};</span></pre><p id="9ad4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">上面的代码块不会像预期的那样工作，因为它使用<code class="fe na nb nc nd b">setuserObj</code>方法将相同的名称<code class="fe na nb nc nd b">userObj</code>传递给了<code class="fe na nb nc nd b">useState</code>。</p><p id="759f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面是正确的做法</p><pre class="kj kk kl km gt nw nd nx ny aw nz bi"><span id="6ce9" class="nk mj it nd b gy oa ob l oc od">onChange={e =&gt; {<br/>  const newUserObj = { name: e.target.value };<br/>  setuserObj(newUserObj); // Now it works<br/>}}</span></pre><p id="cb7e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们已经用新名字创建了一个新对象，并将新值传递给了<code class="fe na nb nc nd b">useState</code> hook。它<strong class="kw iu">替换了</strong>之前的对象并渲染了组件。</p><p id="d941" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们要考虑的下一点是替换的性质。由<code class="fe na nb nc nd b">useState</code>返回的函数不会自动合并这些值，而是替换它们。所以新的<code class="fe na nb nc nd b">setuserObj </code>替换了现有的<code class="fe na nb nc nd b">{ name: ''}</code>对象，并用<code class="fe na nb nc nd b">{ name: 'user typed value'}</code>替换</p><h2 id="6a33" class="nk mj it bd mk nl nm dn mo nn no dp ms ld np nq mu lh nr ns mw ll nt nu my nv bi translated">用多个对象键更新状态。</h2><pre class="kj kk kl km gt nw nd nx ny aw nz bi"><span id="72c8" class="nk mj it nd b gy oa ob l oc od">const UserDetails = () =&gt; {<br/>  const [userObj, setuserObj] = useState({ name: '',address:' '});<br/><br/>  return (<br/>    &lt;div&gt;<br/>      &lt;input<br/>        type="text"<br/>        value={userObj.name}<br/>        placeholder="Enter Your Name"<br/>      onChange={e =&gt; {<br/>                const newUserObj = { name: e.target.value };<br/>                setuserObj(newUserObj); //address key get removed<br/>           }}<br/>      /&gt;<br/>      &lt;p&gt;<br/>        &lt;strong&gt;{userObj.name}&lt;/strong&gt;<br/>      &lt;/p&gt;<br/>  &lt;/div&gt;<br/>  );<br/>};</span></pre><p id="c728" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在上面的代码中，我们向状态<code class="fe na nb nc nd b">userObj</code>添加了另一个字段<code class="fe na nb nc nd b">address </code></p><pre class="kj kk kl km gt nw nd nx ny aw nz bi"><span id="c003" class="nk mj it nd b gy oa ob l oc od">const [userObj, setuserObj] = useState({ name: '',address:' '});</span><span id="e92d" class="nk mj it nd b gy of ob l oc od">onChange={e =&gt; {<br/>    const newUserObj = { name: e.target.value };<br/>    setuserObj(newUserObj); //address key get removed<br/>         }}</span></pre><p id="6cbb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们使用上面的<code class="fe na nb nc nd b">onchange </code>方法来更新状态，新的<code class="fe na nb nc nd b">userObj</code>将没有地址字段。</p><p id="6ad0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">结果<code class="fe na nb nc nd b">userObj</code>会是这样的。</p><pre class="kj kk kl km gt nw nd nx ny aw nz bi"><span id="d017" class="nk mj it nd b gy oa ob l oc od">{name: ''}</span></pre><p id="a8b5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe na nb nc nd b">The correctonchange</code>更新<code class="fe na nb nc nd b">userObj</code>状态的方法如下。</p><pre class="kj kk kl km gt nw nd nx ny aw nz bi"><span id="bcaa" class="nk mj it nd b gy oa ob l oc od">onChange={e =&gt; {<br/>  const val = e.target.value;<br/>  setuserObj(prevState =&gt; {<br/>    return { ...prevState, address: val }<br/>  });<br/>}}</span></pre><p id="88be" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe na nb nc nd b">prevState </code>将获得所有的对象属性，而<code class="fe na nb nc nd b">address:val</code>部分将被添加到对象的末尾。所以最终的状态对象应该是这样的。</p><pre class="kj kk kl km gt nw nd nx ny aw nz bi"><span id="5415" class="nk mj it nd b gy oa ob l oc od">{name: '', address:'new typed val'}</span></pre><h1 id="a01b" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">用嵌套对象更新状态</h1><p id="e086" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">考虑一下你是否想用钩子像这样更新一个状态对象。</p><pre class="kj kk kl km gt nw nd nx ny aw nz bi"><span id="a359" class="nk mj it nd b gy oa ob l oc od">const [adressObj, setAddress] = useState({<br/>  no: '',<br/>  address: {<br/>    city: 'kandy',<br/>    sreet: 'one'<br/>  }<br/>});</span></pre><p id="0e48" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">进行更改的正确方法是，在每个对象级别上，您必须将整个字段集复制到新对象中，并在每个级别中添加更改。参见下面的代码。</p><pre class="kj kk kl km gt nw nd nx ny aw nz bi"><span id="cca9" class="nk mj it nd b gy oa ob l oc od">setAddress(prevState =&gt; ({<br/>  ...prevState,           // copy all other field/objects<br/>  address: {         // recreate the object that contains the field to update    <br/>...prevState.message, // copy all the fields of the object</span><span id="602a" class="nk mj it nd b gy of ob l oc od">    city:'new City'    // overwrite the value of the field to update<br/>  }<br/>}));</span></pre><p id="e7dc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这就是如何使用<code class="fe na nb nc nd b">useState.</code>更新多级状态对象</p><h2 id="85b4" class="nk mj it bd mk nl nm dn mo nn no dp ms ld np nq mu lh nr ns mw ll nt nu my nv bi translated">练习-01</h2><p id="6b34" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">显示按钮内的增量计数值。取代<strong class="kw iu">点击我</strong>每次点击你可以看到更新的计数值。</p><h2 id="30a5" class="nk mj it bd mk nl nm dn mo nn no dp ms ld np nq mu lh nr ns mw ll nt nu my nv bi translated">练习-02</h2><p id="a3c7" class="pw-post-body-paragraph ku kv it kw b kx ne ju kz la nf jx lc ld ng lf lg lh nh lj lk ll ni ln lo lp im bi translated">使用<code class="fe na nb nc nd b">useState</code>钩子显示输入值</p><p id="fca0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">解决方案代码</strong><a class="ae nj" href="https://replit.com/join/ogcwhtubrw-lahirutech" rel="noopener ugc nofollow" target="_blank">https://replit.com/join/ogcwhtubrw-lahirutech</a></p></div></div>    
</body>
</html>