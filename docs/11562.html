<html>
<head>
<title>Vue Reactivity System is more powerful than you think</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Vue反应系统比你想象的更强大</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/vue-reactivity-system-is-more-powerful-than-you-think-37b1924d681b?source=collection_archive---------4-----------------------#2022-03-27">https://levelup.gitconnected.com/vue-reactivity-system-is-more-powerful-than-you-think-37b1924d681b?source=collection_archive---------4-----------------------#2022-03-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="c9d7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Vue 3及其组合API和增强的反应系统会让web开发人员笑逐颜开。我没开玩笑。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/5d99df6c0d04d7016d6a9f4530aa4560.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IV21R220IILvWhydp03L5A.jpeg"/></div></div></figure><p id="e80c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最近，我一直在我的项目中使用Vue，从为大学作业开发应用程序到作为网络开发人员的自由职业者的需求。我现在已经对Vue上瘾了。</p><p id="3b85" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">除了Vue.js的简单和渐进原则，这个框架还为前端开发提供了很多特性。起重要作用的主要部分是反应系统。</p><h1 id="e55f" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">为什么反应？</h1><p id="3b97" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">前端开发很简单。在一般情况下，您只需要显示从后端获得的数据，无论是动态的还是静态的。剩下的只是让界面看起来像✨eye-catchy✨，让用户体验更好。至少，“好用”两个字就够了。</p><p id="4cd8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用普通的js来处理逻辑是<em class="ma">好的</em>，但是这都是有趣的游戏，直到你需要处理当一些回调、条件或事件发生时需要在视图上更新的动态数据。简单地说，这就是用普通的javascript编写一个简单的计数器应用程序要做的事情。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="7ef0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于普通的js，我们需要大量的样板代码来保证工作正常。我们必须等待DOM准备好，查询DOM组件，设置<code class="fe md me mf mg b">onclick</code>事件，然后在事件发生时手动更新视图。</p><p id="780c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">是的，我知道这个例子过于简单，但是想象一下，你有复杂的应用程序，有复杂的特性和逻辑。做简单却显而易见的事情太费力了，不是吗？</p><p id="31b6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们看看如何使用Vue(使用Vite和Typescript)实现相同的功能。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="3c80" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">顺便说一下，上面的例子是用Vue的Composition API写的。它是Vue早期版本中引入的先前选项API的继承者。TLDR；Composition API引入了一种新的方式，用更健壮、更简单、回调更少的mess API编写Vue。我将在另一篇文章中解释这些API之间的区别。</p><p id="200a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，在<code class="fe md me mf mg b">src/components/Counter.vue</code>中，我在这个设置中添加了相同的计数器功能:</p><pre class="km kn ko kp gt mh mg mi mj aw mk bi"><span id="04bf" class="ml ky iq mg b gy mm mn l mo mp">&lt;script ... &gt;<br/>  ...<br/>  <br/><strong class="mg ir">  const count = ref(0);</strong><br/>&lt;/script&gt;</span><span id="7d43" class="ml ky iq mg b gy mq mn l mo mp">&lt;template&gt;<br/>  ...<br/>  &lt;span&gt;<strong class="mg ir">{{ count }}</strong>&lt;/span&gt;<br/>  &lt;primary-button title="-"     <strong class="mg ir">@click="count--"</strong> /&gt;<br/>  &lt;primary-button title="+"     <strong class="mg ir">@click="count++"</strong> /&gt;<br/>  &lt;danger-button  title="Reset" <strong class="mg ir">@click="count = 0"</strong> /&gt;<br/>&lt;/template&gt;</span></pre><p id="3f73" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用带有<code class="fe md me mf mg b">@click</code>事件绑定的<code class="fe md me mf mg b">ref</code>就足以完成这项工作。Vue的反应系统会处理剩下的。</p><p id="7ca1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">简单而有趣。但是你猜怎么着？<code class="fe md me mf mg b">ref</code>是一只巨猿。它能做一些超乎你想象的强大的事情。去看看<code class="fe md me mf mg b">src/components/Video.vue</code>里的文件</p><pre class="km kn ko kp gt mh mg mi mj aw mk bi"><span id="1460" class="ml ky iq mg b gy mm mn l mo mp">&lt;script ... &gt;  <br/>  ...</span><span id="4d5d" class="ml ky iq mg b gy mq mn l mo mp">  <strong class="mg ir">const video = ref&lt;</strong><a class="ae mr" href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLVideoElement" rel="noopener ugc nofollow" target="_blank"><strong class="mg ir">HTMLVideoElement</strong></a><strong class="mg ir">&gt;();</strong><br/><br/>  onMounted(async () =&gt; {<br/>    await setupVideo(video);<br/>    video.value.play();<br/>  });<br/>  <br/>  async function setupVideo(video: HTMLVideoElement) {<br/>    video.value.width = 640;<br/>    video.value.height = 320;<br/>    video.value.allowfullscreen = true;<br/>    video.value.controls = true;<br/>    video.value.type = "video/webm";<br/>    video.value.src = " ... ";<br/>  }<br/>&lt;/script&gt;</span><span id="c938" class="ml ky iq mg b gy mq mn l mo mp">&lt;template&gt;<br/>  <strong class="mg ir">&lt;video ref="video" /&gt;</strong><br/>&lt;/template&gt;</span></pre><p id="0956" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有了Composition API，<code class="fe md me mf mg b">ref</code>可以在接近0的配置下，用静态类型自动绑定DOM元素。你只需要声明与HTML <code class="fe md me mf mg b">ref</code>标签名和元素类型同名的<code class="fe md me mf mg b">ref</code>变量。大多数DOM类型都是从<code class="fe md me mf mg b"><a class="ae mr" href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement" rel="noopener ugc nofollow" target="_blank">HTMLElement</a></code>继承的，因此使用该类型就可以完成这项工作。</p><p id="7fe0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在以前版本的Vue中，可以通过<code class="fe md me mf mg b">this.$refs</code>访问<code class="fe md me mf mg b">ref</code>。在Vue 3中不再推荐这种方法，尤其是当您使用Typescript来避免静态类型问题时。</p><p id="c911" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我还没说完。工作过度却报酬过低。但是在我继续深入之前，是时候谈谈Vue中的状态管理理论了。</p><h1 id="bc20" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">会见州经理</h1><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/78abad03f9147cfe008ef8c70c397b58.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/1*1-JXdl-IoY845tz3o1uqoQ.gif"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">由<a class="ae mr" href="https://tenor.com/official/cartoonnetworkla" rel="noopener ugc nofollow" target="_blank">卡通网</a>在<a class="ae mr" href="https://tenor.com" rel="noopener ugc nofollow" target="_blank">上拍摄的照片</a></figcaption></figure><p id="a55c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你尝试过一些前端框架(比如Vue，React等。)，听到“国家管理”二字是常有的事。但如果你没有，我就简单解释一下。</p><p id="6d24" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从技术上讲，每个Vue组件实例已经“管理”了它的反应状态。正如上面的例子中所解释的，我们已经使用了<code class="fe md me mf mg b">ref</code>来管理组件实例状态。</p><p id="5f88" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">“组件”是由以下部分组成的独立单元:</p><ul class=""><li id="15ff" class="mx my iq jp b jq jr ju jv jy mz kc na kg nb kk nc nd ne nf bi translated">状态是驱动我们应用的真理的来源。</li><li id="df6f" class="mx my iq jp b jq ng ju nh jy ni kc nj kg nk kk nc nd ne nf bi translated">视图是状态的声明性映射。</li><li id="55df" class="mx my iq jp b jq ng ju nh jy ni kc nj kg nk kk nc nd ne nf bi translated">这些动作是状态响应来自视图的用户输入而改变的可能方式。</li></ul><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/fd18084041dceced824759ec8f46c57d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1008/format:webp/1*yuegjTVxKCwX7n0as0eZUQ.png"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">“单向数据流”概念的简单表示:</figcaption></figure><p id="106f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">根据给定的简单计数器示例，当用户单击递增、递减或重置按钮时，会发生相应的操作。状态是<code class="fe md me mf mg b">count</code>变量，视图是显示给用户的计数文本。</p><p id="efe4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种行为被称为“国家管理”。</p><p id="bdfc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，当我们有多个共享同一状态的组件时，状态管理的简单性就开始失效了:</p><ul class=""><li id="de9d" class="mx my iq jp b jq jr ju jv jy mz kc na kg nb kk nc nd ne nf bi translated">多个视图可能依赖于同一个状态。</li><li id="fb79" class="mx my iq jp b jq ng ju nh jy ni kc nj kg nk kk nc nd ne nf bi translated">来自不同视图的动作可能需要改变同一个状态。</li></ul><h1 id="614c" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">使用反应性API进行状态管理</h1><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/b07d7071c22fb66bd02186077c587b2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/1*EAowDhZbQmnIIZNvrsN_dg.gif"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">由<a class="ae mr" href="https://tenor.com/official/cartoonnetworkla" rel="noopener ugc nofollow" target="_blank">漫画网</a>在<a class="ae mr" href="https://tenor.com" rel="noopener ugc nofollow" target="_blank">上拍摄的照片</a></figcaption></figure><p id="9beb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有时候，随着你的应用变得越来越大，你需要管理全局应用的状态，而不仅仅是组件级的状态。这意味着每个组件都可以获得或改变应用程序全局上下文中的状态。</p><p id="123d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用Vue的Reactivity API来实现这一功能是轻而易举的事情。如果您有一个应该由多个组件实例共享的状态，您可以使用<code class="fe md me mf mg b">ref</code>创建一个反应对象，然后从多个组件导入它。</p><p id="f7a5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要在Vue中实现这样的功能，您只需要创建一个如下所示的<code class="fe md me mf mg b">store</code>实例:</p><pre class="km kn ko kp gt mh mg mi mj aw mk bi"><span id="3e61" class="ml ky iq mg b gy mm mn l mo mp"><strong class="mg ir"><em class="ma">// store.ts</em></strong><br/><em class="ma">import</em> { ref } <em class="ma">from</em> 'vue'<br/><br/><em class="ma">export</em> const store = ref({<br/>  count: 0,<br/>  increment() {<br/>    this.count++<br/>  }<br/>})</span></pre><p id="c27d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">并将其应用于Vue组件中。</p><pre class="km kn ko kp gt mh mg mi mj aw mk bi"><span id="456d" class="ml ky iq mg b gy mm mn l mo mp"><strong class="mg ir"><em class="ma">&lt;!-- ComponentA.vue --&gt;</em></strong><br/>&lt;script setup lang="ts"&gt;<br/><em class="ma">import</em> { store } <em class="ma">from</em> './store'<br/>&lt;/script&gt;<br/><br/>&lt;template&gt;<br/>  &lt;button @click="store.increment()"&gt;<br/>    From A: {{ store.count }}<br/>  &lt;/button&gt;<br/>&lt;/template&gt;</span></pre><p id="d4c3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">或者在其他Vue部件中。</p><pre class="km kn ko kp gt mh mg mi mj aw mk bi"><span id="a8e6" class="ml ky iq mg b gy mm mn l mo mp"><strong class="mg ir"><em class="ma">&lt;!-- ComponentB.vue --&gt;</em></strong><br/>&lt;script setup lang="ts"&gt;<br/><em class="ma">import</em> { store } <em class="ma">from</em> './store'<br/>&lt;/script&gt;</span><span id="943c" class="ml ky iq mg b gy mq mn l mo mp">&lt;template&gt;<br/>  &lt;button @click="store.increment()"&gt;<br/>    From B: {{ store.count }}<br/>  &lt;/button&gt;<br/>&lt;/template&gt;</span></pre><p id="dc4a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在每当<code class="fe md me mf mg b">store</code>变异的时候，<code class="fe md me mf mg b">&lt;ComponentA&gt;</code>和<code class="fe md me mf mg b">&lt;ComponentB&gt;</code>都会自动更新自己的观点。我们现在有了唯一的真相来源。这也意味着任何导入<code class="fe md me mf mg b">store</code>的组件都可以随意改变它，例如通过调用store对象中的<code class="fe md me mf mg b">increment()</code>。</p><blockquote class="nm nn no"><p id="d597" class="jn jo ma jp b jq jr js jt ju jv jw jx np jz ka kb nq kd ke kf nr kh ki kj kk ij bi translated"><em class="iq">注意按钮的点击处理程序使用带括号的</em> <code class="fe md me mf mg b"><em class="iq">store.increment()</em></code> <em class="iq">。因为它不是一个组件方法，所以有必要用适当的</em> <code class="fe md me mf mg b"><em class="iq">this</em></code> <em class="iq">上下文调用该方法。</em></p></blockquote><h1 id="ab5f" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">州管理图书馆</h1><p id="a64d" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">虽然使用Reactivity API解决方案的状态管理在简单的场景中就足够了，但是在大规模生产应用程序中还有许多事情需要考虑:</p><ul class=""><li id="deaf" class="mx my iq jp b jq jr ju jv jy mz kc na kg nb kk nc nd ne nf bi translated">团队协作的更强约定。</li><li id="87e3" class="mx my iq jp b jq ng ju nh jy ni kc nj kg nk kk nc nd ne nf bi translated">与Vue DevTools集成，包括时间轴、组件内检查和时间旅行调试。</li><li id="7bd8" class="mx my iq jp b jq ng ju nh jy ni kc nj kg nk kk nc nd ne nf bi translated">热模块更换。</li><li id="6ffe" class="mx my iq jp b jq ng ju nh jy ni kc nj kg nk kk nc nd ne nf bi translated">服务器端渲染支持。</li></ul><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/7adf33528a6c99f9eda93d31675b5388.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/1*c4nknITcU_bst0Mgs6_RVQ.gif"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">照片由<a class="ae mr" href="https://tenor.com/users/turtlepirate223" rel="noopener ugc nofollow" target="_blank">海龟223 </a> <strong class="bd kz"> </strong>在<a class="ae mr" href="https://tenor.com" rel="noopener ugc nofollow" target="_blank">男高音</a>上拍摄</figcaption></figure><p id="fefb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">考虑到以上需求，可以使用Vue的状态管理库比如<a class="ae mr" href="https://pinia.vuejs.org" rel="noopener ugc nofollow" target="_blank"> Pinia </a>或者<a class="ae mr" href="https://vuex.vuejs.org" rel="noopener ugc nofollow" target="_blank"> Vuex </a>。</p><p id="582e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Pinia是一个实现上述所有需求的状态管理库。它由Vue核心团队维护，可用于Vue 2和Vue 3。现有用户可能对Vuex很熟悉，它是Vue以前的官方状态管理库。</p><h1 id="5101" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">结论</h1><p id="5533" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">在一个简单的场景中，使用<code class="fe md me mf mg b">ref</code> Reactivity API作为状态管理器是如此轻而易举。对于复杂的用法、HMR和SSR支持，我们可以使用其他Vue的状态管理器，如Pinia或Vuex。没问题。</p><p id="bd6c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Vue的反应API使用起来简单有趣。然而，关于反应性API还有很多要讨论的。我迫不及待地想再写一篇关于这个的文章。</p></div></div>    
</body>
</html>