<html>
<head>
<title>In-depth analysis of Redis memory fragmentation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Redis内存碎片的深入分析</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/in-depth-analysis-of-redis-memory-fragmentation-25eeca1a85a2?source=collection_archive---------6-----------------------#2022-11-28">https://levelup.gitconnected.com/in-depth-analysis-of-redis-memory-fragmentation-25eeca1a85a2?source=collection_archive---------6-----------------------#2022-11-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="64a5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Redis内存碎片</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ko"><img src="../Images/b3b2753387aedea0cda63dcd887fe26d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*ke65_dcNYOOuXNIAoMW21g.jpeg"/></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">照片由<a class="ae la" href="https://unsplash.com/@philhearing?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">菲尔在<a class="ae la" href="https://unsplash.com/s/photos/house?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上听到</a></figcaption></figure><p id="87ba" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们先来看一个问题。假设Redis实例保存了5GB的数据，现在删除了2GB的数据，Redis进程占用的内存会减少吗？</p><p id="0f1c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">答案是:即使Redis数据只占用大约3GB，它仍然可能占用大约5GB的内存。</p><p id="cc9d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果没有设置<code class="fe lb lc ld le b">maxmemory</code>参数，Redis不会触发内存消除策略删除数据。</p><p id="93cc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Redis将继续为新写入的数据分配内存。分配失败将导致应用程序报告错误，但是当然，这不会导致停机。</p><blockquote class="lf lg lh"><p id="918a" class="jq jr li js b jt ju jv jw jx jy jz ka lj kc kd ke lk kg kh ki ll kk kl km kn im bi translated">注意:要设置<code class="fe lb lc ld le b">maxmemory</code>参数，执行<code class="fe lb lc ld le b">CONFIG SET maxmemory 100mb</code>命令，或者在<code class="fe lb lc ld le b">redis.conf </code>配置文件中设置<code class="fe lb lc ld le b">maxmemory 100mb</code>。</p></blockquote><p id="a207" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以确认数据已被删除，并使用<code class="fe lb lc ld le b">top</code>命令查看数据。为什么还占那么多内存？</p></div><div class="ab cl lm ln hx lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="im in io ip iq"><p id="6248" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">被释放的内存去了哪里？</strong></p><p id="47ef" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当我们使用top命令检查系统使用情况时，会发现内存仍然很高，Redis并没有真正释放内存。</p><p id="1e6e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所有的记忆都去哪了？这时候我们需要使用<code class="fe lb lc ld le b">info memory</code>命令来获取Redis内存相关指标。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="ca21" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Redis进程的内存消耗主要由以下几部分组成:</p><ul class=""><li id="acd1" class="lv lw it js b jt ju jx jy kb lx kf ly kj lz kn ma mb mc md bi translated">内存是Redis自己启动占用的。</li><li id="f285" class="lv lw it js b jt me jx mf kb mg kf mh kj mi kn ma mb mc md bi translated">存储对象数据存储器。</li><li id="bef5" class="lv lw it js b jt me jx mf kb mg kf mh kj mi kn ma mb mc md bi translated">缓冲内存:主要由客户端输出缓冲区、限制客户端输出缓冲区、副本积压缓冲区和AOF缓冲区组成。</li><li id="1884" class="lv lw it js b jt me jx mf kb mg kf mh kj mi kn ma mb mc md bi translated">内存碎片。</li></ul><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi mj"><img src="../Images/cea9c069c37c112308fccc4eb50c8ac2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6NJ3oXavz2n8XXiBB55h_A.png"/></div></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">作者图片</figcaption></figure><p id="4ad4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Redis自己的空进程占用的内存非常小，可以忽略不计，对象内存是最大的一个，它存储了所有的数据。</p><p id="c8f5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">缓冲区出现大流量场景容易失控，导致Redis内存不稳定，需要注意。</p><p id="6a40" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">内存碎片过多导致有空间可用，但数据无法存储。</p><p id="41d4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">碎片= used_memory_rss实际使用的物理内存(rss值)除以used_memory实际存储的数据内存。</strong></p></div><div class="ab cl lm ln hx lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="im in io ip iq"><p id="8737" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">什么是内存碎片？</strong></p><p id="1288" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">内存碎片会导致内存空间空闲，但数据无法存储。比如和女朋友去电影院看电影，肯定是想在一起的。</p><p id="bd9d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">假设现在有8个座位，已售出4张票，还有4张可供购买。但巧合的是，买票的人很奇怪，买的票隔了一个座位。</p><p id="2345" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">即使还有4个座位，你也不能买一张顺序连接两个座位的票。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi mo"><img src="../Images/7b9613b74e24ceb0a2cfee8f59aebddb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w6uqlyjfyOw1VqJnZBTPUw.png"/></div></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">作者图片</figcaption></figure><p id="1b83" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">什么原因导致内存碎片？</strong></p><p id="6e81" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有两个主要原因:</p><ul class=""><li id="c407" class="lv lw it js b jt ju jx jy kb lx kf ly kj lz kn ma mb mc md bi translated">内存分配器的分配策略。</li><li id="07ed" class="lv lw it js b jt me jx mf kb mg kf mh kj mi kn ma mb mc md bi translated">键值对的大小是不同的，删除操作。</li></ul><p id="5590" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们讨论实际发生的原因。</p><p id="beb5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="li"> # 1。内存分配器的分配策略。</em> </strong></p><p id="06bf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Redis默认的内存分配器使用<code class="fe lb lc ld le b">jemalloc</code>，可选的分配器有:<code class="fe lb lc ld le b">glibc</code>、<code class="fe lb lc ld le b">tcmalloc</code>。</p><p id="b12d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">内存分配器不能按需分配，而是使用固定范围的内存块进行分配。</p><p id="28b0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">比如8字节，16字节…，2 KB，4KB，当应用内存最接近某个固定值时，<code class="fe lb lc ld le b">jemalloc</code>会分配最接近固定值的空间。</p><p id="295e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这样就会出现内存碎片。</p><p id="5aec" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">比如程序只需要1.5 KB，内存分配器会分配2KB空间，那么这0.5KB就是碎片。</p><p id="b100" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这样做的目的是减少内存分配的数量。例如，如果你申请22字节的空间来存储数据，<code class="fe lb lc ld le b">jemalloc</code>将分配32字节。</p><p id="e89d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果后面需要写10个字节，不需要向操作系统申请空间。您可以使用之前请求的32字节。</p><p id="4233" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当一个键被删除时，Redis不会立即将内存返回给操作系统。发生这种情况是因为底层内存分配器的管理。例如，大多数已删除的键仍然与其他有效键分配在同一个内存页中。</p><p id="e59e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此外，为了重用空闲的内存块，分配器删除了原来5 GB数据中的2 GB。当数据再次添加到实例中时，Redis的RSS会保持稳定，不会增加太多。</p><p id="1f08" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为内存分配器基本上重用了前一次删除释放的2GB内存。</p><p id="9e27" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="li"> # 2。键值对的大小是不同的，删除操作。</em> </strong></p><p id="3823" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">由于内存分配器是按照固定的大小来分配内存的，所以分配的内存空间通常大于实际数据占用的大小，这样会造成碎片，降低内存的存储效率。</p><p id="07cb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另外，键值对的频繁修改和删除导致内存空间的扩大和释放。例如，如果最初占用32个字节的字符串现在被修改为占用20个字节的字符串，那么释放的12个字节就是自由空间。</p><p id="a0fd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果下一个数据存储请求需要申请一个13字节的字符串，那么刚刚释放的12字节空间就无法使用，导致碎片。</p><p id="d99e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">碎片化最大的问题:空间总量足够大，但是这些内存不是连续的，不一定能存储数据。</p></div><div class="ab cl lm ln hx lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="im in io ip iq"><p id="dce6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">如何解决？</strong></p><p id="f240" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先需要确定是否发生了内存碎片，重点是前面的<code class="fe lb lc ld le b">info memory</code>命令提示的<code class="fe lb lc ld le b">mem_fragmentation_ratio</code>指示器，表示内存碎片率。</p><pre class="kp kq kr ks gt mp le mq bn mr ms bi"><span id="b6a6" class="mt mu it le b be mv mw l mx my">mem_fragmentation_ratio = used_memory_rss/ used_memory</span></pre><p id="1efb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果<code class="fe lb lc ld le b">1 &lt; mem_fragmentation_ratio &lt; 1.5</code>，可以认为是合理的，如果大于1.5，说明破碎度已经超过50%，我们需要采取一些措施来解决破碎度过大的问题。</p><p id="4fad" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="li"> # 1。重启。</em> </strong></p><p id="92b7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最简单的方法就是重启。如果没有启用持久性，数据将会丢失。</p><p id="f3e9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果启用了持久性，您需要使用RDB或AOF来恢复数据。如果只有一个实例，那么大的数据会导致恢复阶段长时间无法提供服务，高可用性会大打折扣。</p><p id="63ae" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="li"> # 2。自动清理内存碎片。</em>T12】</strong></p><p id="27d6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Redis版之后，提供了内存碎片清理机制。</p><p id="9faa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于Redis来说，当连续的内存空间被分割成若干个不连续的空间时，操作系统首先将数据移动缝合在一起，释放原数据占用的空间，形成一个连续的空闲内存空间。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="mk ml di mm bf mn"><div class="gh gi mz"><img src="../Images/3552984a73018a70fe09b3ac06fbfdd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*owOtJrpy9RENl9cx7Ao8Gg.png"/></div></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">作者图片</figcaption></figure><p id="1436" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">自动清洗虽然好，但也不要蛮干。操作系统需要消耗资源将数据移动到新位置，然后释放原始空间。</p><p id="5c66" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Redis操作数据的指令是单线程的，所以在复制和移动数据时，只有在清理完碎片后才能处理请求，导致性能损失。</p><p id="fe0f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">如何避免清洁碎屑对性能的影响，实现自动清洁？</strong></p><p id="c6d9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">好问题，用以下两个参数控制内存碎片清理和结束的时机，避免占用过多CPU，减少清理碎片对Redis处理请求的性能影响。</p><p id="cc23" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">启用自动内存碎片整理。</strong></p><pre class="kp kq kr ks gt mp le mq bn mr ms bi"><span id="53e6" class="mt mu it le b be mv mw l mx my">CONFIG SET activedefrag yes</span></pre><p id="9237" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这只是为了启用自动清洗。当清洗需要同时满足以下两个条件时，就会触发清洗操作。</p><p id="664b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="li"> # 1。清洁条件。</em> </strong></p><p id="5129" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lb lc ld le b">active-defrag-ignore-bytes 200mb</code>:内存碎片占用的内存达到200MB，开始清理；</p><p id="ea6b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lb lc ld le b">active-defrag-threshold-lower 20</code>:内存碎片的空间超过系统分配给Redis的空间的20%，开始清理。</p><p id="14de" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="li"> # 2。避免性能影响。</em> </strong></p><p id="4cd5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">清理时间可用，清理对性能的影响需要控制。一个或两个设置首先分配清理碎片占用的CPU资源，以确保碎片可以正常清理，并避免对Redis处理请求的性能影响。</p><p id="206f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lb lc ld le b">active-defrag-cycle-min 20</code>:自动碎片整理过程中，CPU时间占用比例不低于20%，以保证清理任务能够正常进行。</p><p id="9768" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lb lc ld le b">active-defrag-cycle-max 50</code>:自动清洗过程占用CPU时间的比例不能高于50%。如果超过，将立即停止清理，以避免阻塞Redis并导致高延迟。</p></div><div class="ab cl lm ln hx lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="im in io ip iq"><p id="f386" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">总结一下。</strong></p><p id="9140" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你发现Redis存储数据占用的内存比操作系统分配给Redis的内存小很多，但是数据无法保存，可能会出现大量内存碎片。</p><p id="c912" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用<code class="fe lb lc ld le b">info memory</code>命令检查内存碎片<code class="fe lb lc ld le b">mem_fragmentation_ratio</code>指示灯是否正常。</p><p id="f5ec" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后我们启用自动清理，合理设置清理时间和CPU资源使用。这种机制涉及内存复制，这给Redis性能带来了潜在的风险。</p><p id="421e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果Redis性能变慢，检查是否是清理碎片造成的。如果是，减小<code class="fe lb lc ld le b">active-defrag-cycle-max</code>的值。</p></div><div class="ab cl lm ln hx lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="im in io ip iq"><p id="fe8c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你喜欢这样的故事，想支持我，请给我鼓掌。</p><p id="110c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你的支持对我很重要，谢谢。</p></div><div class="ab cl lm ln hx lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="im in io ip iq"><h1 id="3871" class="na mu it bd nb nc nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw bi translated">分级编码</h1><p id="17b0" class="pw-post-body-paragraph jq jr it js b jt nx jv jw jx ny jz ka kb nz kd ke kf oa kh ki kj ob kl km kn im bi translated">感谢您成为我们社区的一员！在你离开之前:</p><ul class=""><li id="ff3c" class="lv lw it js b jt ju jx jy kb lx kf ly kj lz kn ma mb mc md bi translated">👏为故事鼓掌，跟着作者走👉</li><li id="e100" class="lv lw it js b jt me jx mf kb mg kf mh kj mi kn ma mb mc md bi translated">📰查看<a class="ae la" href="https://levelup.gitconnected.com/?utm_source=pub&amp;utm_medium=post" rel="noopener ugc nofollow" target="_blank">升级编码出版物</a>中的更多内容</li><li id="547e" class="lv lw it js b jt me jx mf kb mg kf mh kj mi kn ma mb mc md bi translated">🔔关注我们:<a class="ae la" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">Twitter</a>|<a class="ae la" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>|<a class="ae la" href="https://newsletter.levelup.dev" rel="noopener ugc nofollow" target="_blank">时事通讯</a></li></ul><p id="ef22" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">🚀👉<a class="ae la" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">加入升级人才集体，找到一份神奇的工作</strong> </a></p></div></div>    
</body>
</html>