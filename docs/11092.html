<html>
<head>
<title>Previous Page Token for Cursor Pagination</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">光标分页的上一页标记</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/previous-page-token-for-cursor-pagination-d32429f1ea3b?source=collection_archive---------23-----------------------#2022-02-13">https://levelup.gitconnected.com/previous-page-token-for-cursor-pagination-d32429f1ea3b?source=collection_archive---------23-----------------------#2022-02-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/bdf2f89d1426fd47df836b4201dde929.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*cA01zNb0rPpps0n8.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">图片来源:<a class="ae kc" href="https://www.qwertee.io/blog/postgresql-b-tree-index-explained-part-1/" rel="noopener ugc nofollow" target="_blank">https://www . qwertee . io/blog/PostgreSQL-b-tree-index-explained-part-1/</a></figcaption></figure><p id="d5cf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们开始之前，重要的是要注意，通过甚至不包括前一页按钮的GUI(图形用户界面)设计，可以消除对前一页遍历的需要。无限卷轴就是一个例子。另一个是机器接口设计，其中客户机只是想运行整个结果集。<strong class="kf ir">如果光标分页是一个陌生的话题，请访问下面的帖子，因为这是一个扩展</strong>:</p><ul class=""><li id="198d" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated"><a class="ae kc" href="https://medium.com/swlh/how-to-implement-cursor-pagination-like-a-pro-513140b65f32" rel="noopener">如何像Pro </a> <em class="lk">一样实现光标分页(注1:本帖底部的时间复杂度分析对于1列光标比链接中的更精确。注2:我将对他们关于2列光标时间复杂度分析的准确性的帖子发表评论)</em></li><li id="1755" class="lb lc iq kf b kg ll kk lm ko ln ks lo kw lp la lg lh li lj bi translated"><a class="ae kc" href="https://slack.engineering/evolving-api-pagination-at-slack/" rel="noopener ugc nofollow" target="_blank">在空闲时发展API分页</a></li><li id="ceb9" class="lb lc iq kf b kg ll kk lm ko ln ks lo kw lp la lg lh li lj bi translated"><a class="ae kc" href="https://stackoverflow.com/questions/38017054/mysql-cursor-based-pagination-with-multiple-columns" rel="noopener ugc nofollow" target="_blank">基于光标的多列分页</a></li></ul><p id="c43f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第一个链接很好地解释了如何实现前一页遍历，然而，不同的外观可以帮助一些人更好地理解发生了什么。</p><h1 id="c07e" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">问题是</h1><p id="db81" class="pw-post-body-paragraph kd ke iq kf b kg mo ki kj kk mp km kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">游标分页SQL查询依赖于<em class="lk">索引列</em>和比较运算符，而不是<code class="fe mt mu mv mw b">OFFSET</code>子句。当遍历递增(<code class="fe mt mu mv mw b">ASC</code>)结果集的<em class="lk">下一页</em>时，这是非常简单的:</p><pre class="mx my mz na gt nb mw nc nd aw ne bi"><span id="25af" class="nf lr iq mw b gy ng nh l ni nj">SELECT * FROM entries WHERE (myCol &gt; 5) ORDER BY myCol ASC LIMIT 2;</span></pre><figure class="mx my mz na gt jr gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/e76dee98975ae39d8594bab7bcfa9878.png" data-original-src="https://miro.medium.com/v2/resize:fit:524/format:webp/0*1GVjZy7Tiq00r8y4.png"/></div></figure><p id="3db3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下一页:</p><pre class="mx my mz na gt nb mw nc nd aw ne bi"><span id="a11f" class="nf lr iq mw b gy ng nh l ni nj">SELECT * FROM entries WHERE (myCol &gt; 7) ORDER BY myCol ASC LIMIT 2;</span></pre><figure class="mx my mz na gt jr gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/4e4a41a39209bf283b6540de802cc58a.png" data-original-src="https://miro.medium.com/v2/resize:fit:528/format:webp/0*OwRaQQHjn6MC9sHF.png"/></div></figure><p id="2952" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当遍历递减(<code class="fe mt mu mv mw b">DESC</code>)结果集的<em class="lk">下一页</em>时，这也很简单:</p><pre class="mx my mz na gt nb mw nc nd aw ne bi"><span id="6f50" class="nf lr iq mw b gy ng nh l ni nj">SELECT * FROM entries WHERE (myCol &lt; 5) ORDER BY myCol DESC LIMIT 2;</span></pre><figure class="mx my mz na gt jr gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/73ffa5e52151471dcf7c6eba31db7f6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:530/format:webp/0*RWIVsvuQUrE1tyi1.png"/></div></figure><p id="f668" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下一页:</p><pre class="mx my mz na gt nb mw nc nd aw ne bi"><span id="c4a9" class="nf lr iq mw b gy ng nh l ni nj">SELECT * FROM entries WHERE (myCol &lt; 3) ORDER BY myCol DESC LIMIT 2;</span></pre><figure class="mx my mz na gt jr gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/bf99a35d49472488701f9a111909642a.png" data-original-src="https://miro.medium.com/v2/resize:fit:532/format:webp/0*NSs4LWLMux2N8saO.png"/></div></figure><p id="5f61" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，遍历<em class="lk">前几页</em>变得很棘手，因为当你在SQL查询中提供一个约束(例如<code class="fe mt mu mv mw b">&gt;</code>、<code class="fe mt mu mv mw b">&lt;</code>)，SQL数据库引擎(例如Postgres)会返回最左边的结果:</p><pre class="mx my mz na gt nb mw nc nd aw ne bi"><span id="d7e9" class="nf lr iq mw b gy ng nh l ni nj">SELECT * FROM entries WHERE (myCol &lt; 8) ORDER BY myCol ASC LIMIT 2;</span></pre><figure class="mx my mz na gt jr gh gi paragraph-image"><div class="gh gi no"><img src="../Images/3eae3d77eccc8e7e800cab2abd717c5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:534/format:webp/0*nKELGyVvZKA2vv1l.png"/></div></figure><p id="7133" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们想要6和7！</p><h1 id="e41e" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">解决方案</h1><p id="85c3" class="pw-post-body-paragraph kd ke iq kf b kg mo ki kj kk mp km kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">正确实现前一页遍历的解决方案是颠倒结果集的顺序(ASC vs DESC ),这样你想要的结果就在光标的右边。然后，一旦应用了限制，再次反转排序，使其与请求的排序相匹配:</p><pre class="mx my mz na gt nb mw nc nd aw ne bi"><span id="81b8" class="nf lr iq mw b gy ng nh l ni nj">SELECT pagination.* FROM(SELECT * FROM entries WHERE (myCol &lt; 8) ORDER BY myCol DESC LIMIT 2) AS pagination ORDER BY myCol ASC;</span></pre><p id="6479" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lk">注意:CTE(公共表表达式)也可以作为嵌套查询的替代。</em></p><figure class="mx my mz na gt jr gh gi paragraph-image"><div class="gh gi np"><img src="../Images/090068b95ed1355dea7d839dd77a96f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:788/format:webp/0*1R6GPf6PO3UaxEun.png"/></div></figure><p id="b4b9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">再次返回上一页:</p><pre class="mx my mz na gt nb mw nc nd aw ne bi"><span id="8a15" class="nf lr iq mw b gy ng nh l ni nj">SELECT pagination.* FROM(SELECT * FROM entries WHERE (myCol &lt; 6) ORDER BY myCol ASC LIMIT 2) AS pagination ORDER BY myCol DESC;</span></pre><figure class="mx my mz na gt jr gh gi paragraph-image"><div class="gh gi np"><img src="../Images/266d9e4c4852ad176c85bfd7a460336a.png" data-original-src="https://miro.medium.com/v2/resize:fit:788/format:webp/0*QvJVhgr0GiZPvzN7.png"/></div></figure><h1 id="b6bb" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">时间复杂性分析</h1><p id="fa3b" class="pw-post-body-paragraph kd ke iq kf b kg mo ki kj kk mp km kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated"><strong class="kf ir">前一页遍历</strong>与<strong class="kf ir">下一页遍历</strong>相比的性能开销可以忽略不计——这是<code class="fe mt mu mv mw b">O(log(N) + 2L)</code>与<code class="fe mt mu mv mw b">O(log(N) + L)</code>的区别，其中<code class="fe mt mu mv mw b">N</code>是表的大小，<code class="fe mt mu mv mw b">L</code>是限制的大小(从技术上讲，如果<code class="fe mt mu mv mw b">N &lt;= LIMIT </code>，<code class="fe mt mu mv mw b">L</code>可能等于<code class="fe mt mu mv mw b">N</code>)。此外，<code class="fe mt mu mv mw b">L</code>甚至可以被认为是一个常量，而不是一个无限的变量，因为页面大小在它迅速突破消息/有效负载大小限制之前只能有这么大。<code class="fe mt mu mv mw b">Log(N)</code>是DB引擎遍历索引树以找到满足<code class="fe mt mu mv mw b">WHERE</code>子句的叶节点所花费的时间。在<code class="fe mt mu mv mw b">L</code>非常小而<code class="fe mt mu mv mw b">N</code>非常大的情况下，<code class="fe mt mu mv mw b">log(N)</code>可能大于<code class="fe mt mu mv mw b">L</code>。值得注意的是，在这些查询中不需要排序，因为索引已经以排序的方式维护了数据(在索引树的叶节点中)。在前面的页面遍历中，由于上面提到的问题，需要进行与限制大小相等的第二次扫描来实现所需的顺序。</p></div></div>    
</body>
</html>