<html>
<head>
<title>Docker 101: Part 3 - Containers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">码头工人101:第3部分-集装箱</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/docker-101-part-3-containers-e2328ed3dda6?source=collection_archive---------6-----------------------#2022-08-13">https://levelup.gitconnected.com/docker-101-part-3-containers-e2328ed3dda6?source=collection_archive---------6-----------------------#2022-08-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/158b5cfebd19fb0c8a3e157a47c908d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5aIk2sUx6IxpUzbSGHQOqg.png"/></div></div></figure><p id="c1b8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">到目前为止，我们已经了解了与容器和用于管理图像的各种Docker命令相关的基础知识。在本文中，我们将更深入地研究容器及其相关的命令。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="13b0" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">容器生命周期</h1><p id="a0ea" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">容器在其整个生命周期中可以存在5种状态。这些状态如下图所示。</p><p id="83d5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本文中，我们将讨论使用容器需要了解的三种主要状态——运行、停止和删除</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/0072121490c99b79e8bdbfdd6f2c0329.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B-XKR3AT6aUWOX9Dw0mABg.png"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk translated">码头集装箱生命周期</figcaption></figure><blockquote class="mo mp mq"><p id="5ef8" class="jy jz mr ka b kb kc kd ke kf kg kh ki ms kk kl km mt ko kp kq mu ks kt ku kv ij bi translated"><strong class="ka ir">注:</strong>在Docker CLI中，处于运行状态的集装箱显示为<strong class="ka ir">上升</strong>，处于停止状态的集装箱显示为<strong class="ka ir">退出。</strong></p></blockquote></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="0eb8" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">集装箱运行模式</h1><p id="de18" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">运行图像有两种主要模式:</p><ul class=""><li id="9e19" class="mv mw iq ka b kb kc kf kg kj mx kn my kr mz kv na nb nc nd bi translated">前台模式(默认)</li><li id="dd9c" class="mv mw iq ka b kb ne kf nf kj ng kn nh kr ni kv na nb nc nd bi translated">分离/守护模式</li></ul><p id="5e31" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">前台模式进一步分为交互和非交互两种类型</p><h2 id="8f17" class="nj le iq bd lf nk nl dn lj nm nn dp ln kj no np lr kn nq nr lv kr ns nt lz nu bi translated">前台模式(非交互)</h2><p id="38eb" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">可以使用“容器运行”命令启动容器。</p><pre class="mg mh mi mj gt nv nw nx ny aw nz bi"><span id="49a5" class="nj le iq nw b gy oa ob l oc od">docker image pull hello-world</span><span id="7fb0" class="nj le iq nw b gy oe ob l oc od">docker container run hello-world</span></pre><blockquote class="mo mp mq"><p id="c5ed" class="jy jz mr ka b kb kc kd ke kf kg kh ki ms kk kl km mt ko kp kq mu ks kt ku kv ij bi translated"><strong class="ka ir">注意:</strong>要运行一个容器，不需要预先将映像下载到本地。如果在我们的系统上找不到映像，docker run命令会从Docker Hub中提取映像</p></blockquote><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi gj"><img src="../Images/5467ef3b1152fc7fd5011a84da494710.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A-3nkUfYFgMhvE_zVmg6mw.png"/></div></div></figure><p id="b118" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如你所见，容器<strong class="ka ir">开始</strong>运行<strong class="ka ir">命令</strong>，然后<strong class="ka ir">退出</strong>。值得注意的是，在非交互前台模式中，顾名思义，我们不能与正在运行的容器进行交互。</p><p id="ec4b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">容器在启动时是如何知道要执行什么的？</strong></p><p id="b652" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">启动时运行的命令由用于构建映像的Dockerfile决定(我们将在以后的文章中详细讨论这一点)。Dockerfile文件中指定了一个名为CMD的命令，它决定了容器运行时要执行的命令。</p><p id="28a1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有多种方法可以找出将在容器开始时执行的命令。一种检查方法是使用“图像检查”命令</p><pre class="mg mh mi mj gt nv nw nx ny aw nz bi"><span id="2ef2" class="nj le iq nw b gy oa ob l oc od">docker image inspect hello-world</span></pre><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi of"><img src="../Images/4bba6e1f46f74154acced11894f4ce84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hhUM8FKOlcCgaQJgkFKtOQ.png"/></div></div></figure><p id="810d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">输出向我们显示了与图像相关的所有元数据。我们正在寻找的密钥是CMD(在上面的图像中突出显示)</p><p id="9e95" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">获取此信息的另一种方法是直接查看Docker文件。这可以通过单击图像的Docker Hub页面上指定的标签来完成，这将带我们进入一个<a class="ae og" href="https://github.com/docker-library/hello-world/blob/3332fbee4210b41738d83f6cfdc301a42b96e30d/amd64/hello-world/Dockerfile" rel="noopener ugc nofollow" target="_blank"> GitHub </a> repo，其中包含用于构建图像的Docker文件(用于创建图像的Docker文件是开源的，任何人都可以查看)</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oh"><img src="../Images/a018673cc039be70e94bf6ab2a259c48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4eOXNoPoilDBH_SS0g8xjw.png"/></div></div></figure><p id="a60f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后一行CMD是我们正在寻找的，它与我们从“image inspect”命令看到的结果相匹配</p><h2 id="6961" class="nj le iq bd lf nk nl dn lj nm nn dp ln kj no np lr kn nq nr lv kr ns nt lz nu bi translated">前台模式(交互式)</h2><p id="e007" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">要在交互模式下运行容器，需要将一些附加参数传递给“容器运行”命令</p><pre class="mg mh mi mj gt nv nw nx ny aw nz bi"><span id="606f" class="nj le iq nw b gy oa ob l oc od">docker container run --name alpine -it alpine /bin/sh</span></pre><p id="4639" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们来分解一下上面的命令,<code class="fe oi oj ok nw b">--name</code>标志用于给图像(容器)的运行实例命名。这是一个可选标志，如果没有指定，将被随机分配。<code class="fe oi oj ok nw b">-it</code>标志用于指定我们希望以交互模式运行容器，并将容器的stdin附加到我们的终端(这允许我们在容器上执行命令)。<code class="fe oi oj ok nw b">/bin/sh</code>是我们希望在容器启动后运行的命令。</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ol"><img src="../Images/815fbc724e15ac0e16927c64cefd9aaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D6PEP5fBLZOymAj3yb-zYA.png"/></div></div></figure><p id="a312" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们在映像名称后指定的任何命令都将覆盖在映像创建期间在docker文件中指定的CMD语句。</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div class="gh gi om"><img src="../Images/a6670a353de6ea9fd64ebec8e6db5677.png" data-original-src="https://miro.medium.com/v2/resize:fit:1020/format:webp/1*iHpmTYD9UFOBC9ZAScdaHA.png"/></div></figure><blockquote class="mo mp mq"><p id="8e66" class="jy jz mr ka b kb kc kd ke kf kg kh ki ms kk kl km mt ko kp kq mu ks kt ku kv ij bi translated"><strong class="ka ir">注意:</strong>当我们使用run命令启动一个容器Docker时，首先在内部运行<strong class="ka ir"> create </strong>命令，该命令创建一个图像实例，并在其上添加一个可修改层。在这一点上，容器仍未启动，处于就绪状态，即，启动容器的配置已完成。在这个码头工人真正启动集装箱之后。</p></blockquote></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="6c12" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">列出容器</h1><p id="972d" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">正如前面在生命周期一节中所讨论的，Docker容器在其生命周期中可以处于多种状态。要查看<strong class="ka ir">所有</strong>容器，而不考虑它们的状态，我们可以使用“容器ls -a”命令。</p><pre class="mg mh mi mj gt nv nw nx ny aw nz bi"><span id="409a" class="nj le iq nw b gy oa ob l oc od">docker container ls -a</span></pre><p id="3c5e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果未使用<code class="fe oi oj ok nw b">-a</code>标志，则仅显示运行中的集装箱。</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi on"><img src="../Images/235be3e7d5189e1d7443f2f4bbdd1c2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FR_LWDC1C83HQh05giCFhw.png"/></div></div></figure><p id="cf7b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上图中，所有容器的状态都显示为Exited，这意味着它们都处于Stopped状态。</p><blockquote class="mo mp mq"><p id="95df" class="jy jz mr ka b kb kc kd ke kf kg kh ki ms kk kl km mt ko kp kq mu ks kt ku kv ij bi translated">对于任何想知道自动分配给容器的名字的人来说，总是一个形容词<strong class="ka ir">后跟一个科学家的名字<strong class="ka ir"/></strong></p></blockquote></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="e64e" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">移除容器</h1><p id="8025" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">一旦容器完成执行，它将进入退出(停止)状态。rm命令用于清理此类容器。</p><pre class="mg mh mi mj gt nv nw nx ny aw nz bi"><span id="3403" class="nj le iq nw b gy oa ob l oc od">docker container rm &lt;container-name&gt;</span></pre><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/6f68901df70290770faf062d8dbbc6ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1390/format:webp/1*mxVdZyKgRrj57MZibiK2BQ.png"/></div></figure><p id="de04" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们不希望交互式容器在我们使用后继续存在，那么我们可以在创建容器时传递<code class="fe oi oj ok nw b">--rm</code>标志。</p><pre class="mg mh mi mj gt nv nw nx ny aw nz bi"><span id="22bc" class="nj le iq nw b gy oa ob l oc od">docker container run --rm hello-world</span></pre><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi op"><img src="../Images/9085b77ae50b3562e6351c6fa378d6dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AL9LBR-8fBJBSmByPqBm1w.png"/></div></div></figure><p id="ddb4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如我们这次所观察到的，一旦容器执行完毕，我们就不会在容器列表中看到处于exited状态的容器。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="67a1" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">分离/守护模式</h1><p id="fd1b" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">以分离模式启动的容器在后台启动，不会将自己附加到我们的终端。让我们使用<a class="ae og" href="https://hub.docker.com/_/mysql" rel="noopener ugc nofollow" target="_blank"> MySQL </a>图片来尝试一下。</p><pre class="mg mh mi mj gt nv nw nx ny aw nz bi"><span id="ed5f" class="nj le iq nw b gy oa ob l oc od">docker image pull mysql</span><span id="9f0b" class="nj le iq nw b gy oe ob l oc od">docker container run --name mysql -d -e MYSQL_ROOT_PASSWORD=password -e MYSQL_ROOT_HOST=% mysql</span></pre><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oq"><img src="../Images/eada39541af52d1b7fff47bac957c2f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NWaVd2RKvv9NbjVT0iq-wg.png"/></div></div></figure><p id="ab59" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一些Docker图像允许定义用于配置图像所使用的一些参数的环境变量。我们可以使用<code class="fe oi oj ok nw b">-e</code>标志设置这些参数。</p><p id="2aef" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">可在图像上设置的参数列表可通过查看Docker Hub上图像的<a class="ae og" href="https://hub.docker.com/_/mysql" rel="noopener ugc nofollow" target="_blank">页面</a>找到。</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi or"><img src="../Images/1d1694fe016d8b4cf6c643af60e7310d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kvdh5MbwydFzghwsN38Jag.png"/></div></div></figure><p id="57d1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上图中的ports列将在下一篇文章中详细介绍。但简而言之，Docker允许我们在容器上公开一些端口，这些端口允许我们连接到容器并与容器中运行的服务进行交互。</p><p id="bc37" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">需要注意的是，这一次容器是在后台运行的，并且没有连接到您的终端。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="9cde" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">停止容器</h1><p id="2204" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">与交互式容器不同，分离的容器需要由用户显式停止(除非它们崩溃，在这种情况下它们会自动进入停止停止状态)</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi os"><img src="../Images/800a6f6eb49b509911eb0a59f71d598a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iKdNrtv9yNJplRXxIDRrSQ.png"/></div></div></figure><p id="608f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，一旦我们使用完一个容器，我们需要使用“容器停止”命令来停止它。</p><pre class="mg mh mi mj gt nv nw nx ny aw nz bi"><span id="72f5" class="nj le iq nw b gy oa ob l oc od">docker container stop &lt;container-name&gt;</span></pre><p id="a5fe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">或者，我们可以跳过stop命令，将<code class="fe oi oj ok nw b">-f</code>标志传递给rm命令，强制删除正在运行的容器。</p><pre class="mg mh mi mj gt nv nw nx ny aw nz bi"><span id="38ee" class="nj le iq nw b gy oa ob l oc od">docker container rm -f &lt;container-name&gt;</span></pre><p id="4ce4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另一种停止容器的方法是使用“容器终止”命令，虽然这两个命令的最终结果是相同的(停止容器),但它们以不同的方式执行。</p><pre class="mg mh mi mj gt nv nw nx ny aw nz bi"><span id="4325" class="nj le iq nw b gy oa ob l oc od">docker container kill &lt;container-name&gt;</span></pre><blockquote class="mo mp mq"><p id="0b6b" class="jy jz mr ka b kb kc kd ke kf kg kh ki ms kk kl km mt ko kp kq mu ks kt ku kv ij bi translated"><em class="iq">docker</em><strong class="ka ir"><em class="iq">stop</em></strong>命令发出<strong class="ka ir"> SIGTERM </strong>信号，而<em class="iq">docker</em><strong class="ka ir"><em class="iq">kill</em></strong>命令发出<strong class="ka ir"> SIGKILL </strong>信号</p></blockquote><p id="bf12" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">SIGTERM和SIGKILL是Linux信号，用于向进程表示事件的发生。需要理解的关键一点是，SIGTERM是SIGKILL的驯服操作。Stop命令导致容器进程被感激地终止(给容器中的进程几秒钟的时间来正确关闭)，不像kill命令会立即终止它。</p><p id="71d4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于码头工人的日常使用，最好坚持使用“集装箱停止”命令，除非有特殊原因需要使用kill命令。我附上了关于这个主题的参考资料，可以参考更多的细节。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="73cd" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">集装箱日志</h1><p id="01b4" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">一些Docker容器启用了日志记录，以便于调试和查找使用容器生命周期可能发生的错误。可以使用“容器日志”命令来访问这些日志。</p><pre class="mg mh mi mj gt nv nw nx ny aw nz bi"><span id="168f" class="nj le iq nw b gy oa ob l oc od">docker container logs &lt;container-name&gt;</span></pre><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ot"><img src="../Images/f80dfeb6a7228a9129931070fb166f6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kTIRYba5e46ZQaLllz3l2Q.png"/></div></div></figure><p id="9dae" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">可以将<code class="fe oi oj ok nw b">-f</code>标志传递给上述命令，以跟踪由容器实时生成的日志。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="5611" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">启动停止的容器</h1><p id="9a67" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">假设我们有一个停止的容器，我们想再次启动它，那么我们可以使用“容器启动”命令。</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ou"><img src="../Images/81f7b1461a587c74a49800d3443deccb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FQWddvhciTIfD0SaEy9jzQ.png"/></div></div></figure><p id="42df" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从上图中我们可以看到mysql容器是以分离模式启动的，过了一段时间容器被停止了，然后被停止的容器又被启动了。</p><p id="d5ac" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">默认情况下，容器将以使用“容器运行”命令创建时的模式重新启动。要在交互模式下重启分离的模式容器，可以使用<code class="fe oi oj ok nw b">-ai</code>标志。</p><pre class="mg mh mi mj gt nv nw nx ny aw nz bi"><span id="d5e2" class="nj le iq nw b gy oa ob l oc od">docker container start -ai &lt;container-name&gt;</span></pre></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="5af1" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated"><strong class="ak">执行容器上的命令</strong></h1><p id="7a5c" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">比方说，我们有一个正在运行的容器，我们想快速地对它运行一个命令，或者我们想调试容器中发生的一些错误，在这些情况下，我们可以使用“容器执行”命令。</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ov"><img src="../Images/fd712119e93b8234c705777c2c619dc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Uo75tDI91-08C93wOnLzbw.png"/></div></div></figure><p id="6241" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上图中，我们可以看到MySQL容器以分离模式启动，然后使用exec命令打印出当前用户的名称。</p><p id="9232" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">与“容器运行”命令不同，即使我们在容器上执行了一个命令，入口点也不会被覆盖，容器会继续正常运行。</p><p id="8a00" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过使用<code class="fe oi oj ok nw b">-it</code>标志，exec命令也可以用于在交互模式下连接到容器。<code class="fe oi oj ok nw b">-u</code>标志用于指定运行容器的用户的用户名id。</p><blockquote class="mo mp mq"><p id="41be" class="jy jz mr ka b kb kc kd ke kf kg kh ki ms kk kl km mt ko kp kq mu ks kt ku kv ij bi translated"><strong class="ka ir">注意:</strong>使用<code class="fe oi oj ok nw b">Ctrl + P + Q</code>快捷方式可以将一个交互容器转换成一个分离/守护容器，这甚至适用于使用“开始”和“运行”命令以交互模式启动的容器。</p></blockquote></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="ac52" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">集装箱统计</h1><p id="22d8" class="pw-post-body-paragraph jy jz iq ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">我们可以使用“container top”命令查看容器内部正在运行的所有进程。</p><pre class="mg mh mi mj gt nv nw nx ny aw nz bi"><span id="dd1a" class="nj le iq nw b gy oa ob l oc od">docker container top &lt;container-name&gt;</span></pre><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ow"><img src="../Images/eb21a67c48e6d910b9e2a129ef695c08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lUw6iFw6Cij2frEoWKmuoA.png"/></div></div></figure><p id="68d1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">类似地，要查看系统上运行的所有容器的资源利用率，可以使用“容器状态”命令。</p><pre class="mg mh mi mj gt nv nw nx ny aw nz bi"><span id="453e" class="nj le iq nw b gy oa ob l oc od">docker container status</span></pre><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ox"><img src="../Images/2ec1044254cdb7ecdccf62e424fd9a7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n-EQB3dWD2qeucsJCD07OQ.png"/></div></div></figure><p id="2399" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要查看与容器相关的所有元数据信息，可以使用“容器检查”命令。</p><pre class="mg mh mi mj gt nv nw nx ny aw nz bi"><span id="4e73" class="nj le iq nw b gy oa ob l oc od">docker container inspect &lt;container-name&gt;</span></pre><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oy"><img src="../Images/13195bfaa72579bd2bc25f6a8f905d7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LDup0ziXVyoNwQ44DfG6EA.png"/></div></div></figure></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h2 id="64c5" class="nj le iq bd lf nk nl dn lj nm nn dp ln kj no np lr kn nq nr lv kr ns nt lz nu bi translated">前一篇文章</h2><div class="oz pa gp gr pb pc"><a rel="noopener  ugc nofollow" target="_blank" href="/docker-101-part-2-images-cf845d1a4fcb"><div class="pd ab fo"><div class="pe ab pf cl cj pg"><h2 class="bd ir gy z fp ph fr fs pi fu fw ip bi translated">文档101:第2部分-图像</h2><div class="pj l"><h3 class="bd b gy z fp ph fr fs pi fu fw dk translated">在上一篇文章中，我们看了一些与容器相关的基本概念，以及容器与……</h3></div><div class="pk l"><p class="bd b dl z fp ph fr fs pi fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="pl l"><div class="pm l pn po pp pl pq jw pc"/></div></div></a></div></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><ul class=""><li id="6206" class="mv mw iq ka b kb kc kf kg kj mx kn my kr mz kv na nb nc nd bi translated"><a class="ae og" href="https://www.baeldung.com/ops/docker-stop-vs-kill" rel="noopener ugc nofollow" target="_blank">https://www.baeldung.com/ops/docker-stop-vs-kill</a></li><li id="69e9" class="mv mw iq ka b kb ne kf nf kj ng kn nh kr ni kv na nb nc nd bi translated"><a class="ae og" href="https://superuser.com/questions/756999/whats-the-difference-between-docker-stop-and-docker-kill" rel="noopener ugc nofollow" target="_blank">https://super user . com/questions/756999/docker-stop-and-docker-kill</a></li><li id="2648" class="mv mw iq ka b kb ne kf nf kj ng kn nh kr ni kv na nb nc nd bi translated"><a class="ae og" href="https://stackoverflow.com/questions/28339469/which-one-should-i-use-docker-kill-or-docker-stop" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/28339469/which-one-should-I-use-docker-kill-or-docker-stop</a></li><li id="164c" class="mv mw iq ka b kb ne kf nf kj ng kn nh kr ni kv na nb nc nd bi translated"><a class="ae og" href="https://k21academy.com/docker-kubernetes/docker-container-lifecycle-management/" rel="noopener ugc nofollow" target="_blank">https://k21 academy . com/docker-kubernetes/docker-container-life cycle-management/</a></li></ul></div></div>    
</body>
</html>