<html>
<head>
<title>What are WebSockets? — The Technology that Connects Clients and Servers Together</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是WebSockets？—将客户端和服务器连接在一起的技术</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/what-is-websocket-bring-that-multiplayer-feel-to-your-web-or-mobile-application-2c945a8e7246?source=collection_archive---------3-----------------------#2020-10-20">https://levelup.gitconnected.com/what-is-websocket-bring-that-multiplayer-feel-to-your-web-or-mobile-application-2c945a8e7246?source=collection_archive---------3-----------------------#2020-10-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/fad89e86eaf8dde850083088feb795a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JCu7OhDZx5nhmyVj"/></div></div></figure><p id="1be1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当您键入一个URL并按Enter键时，您的浏览器实际上向与该URL相关联的服务器发送了一个<a class="ae kw" href="https://www.tutorialspoint.com/http/http_requests.htm" rel="noopener ugc nofollow" target="_blank"> HTTP请求</a>。然后，服务器用一个<a class="ae kw" href="https://www.tutorialspoint.com/http/http_responses.htm" rel="noopener ugc nofollow" target="_blank"> HTTP响应</a>进行响应，并可能发回类似HTML文件的内容。</p><p id="fd71" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一旦建立了连接，交易完成，连接就不复存在。您的浏览器和服务器之间无法再进行通信。</p><p id="ac01" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们想构建一个聊天应用程序，让我们知道别人何时发送了新消息，那会怎么样？使用常规HTTP，您必须不断刷新页面才能看到新消息。但是这并不方便用户使用。我们可以做得更好。</p><h1 id="fbe4" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">实时网络通信的历史</h1><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lv"><img src="../Images/35031dfed5edf0b1619aa0bdedc62639.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*e66RYn8zq7AMQlNx"/></div></div></figure><p id="de7d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当客户端和服务器之间的实时通信问题在21世纪初首次出现时，答案是AJAX，即异步Javascript和XML。它允许web开发人员向服务器发出请求，而不必重新加载整个页面。现在，您可以发送特定信息的请求，并在页面上更新您的信息，而无需重新加载。</p><p id="6f7a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而AJAX的缺点是它是单向的。基本上，您的浏览器可以向服务器发送请求，查看是否有新数据。但是，服务器无法启动与您的浏览器的连接，也无法向您的浏览器发送数据更新。</p><p id="55b1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以开发人员创造性地使用AJAX，创造了一种叫做<strong class="ka ir"> <em class="ma">轮询的东西。本质上，你的浏览器会在设定的时间间隔发送请求，或者保持连接直到服务器传回新的数据。</em></strong></p><p id="9700" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">定期轮询是指在设定的时间间隔内发送AJAX请求。例如，使用聊天应用程序，您可以每5秒钟向服务器发送一次请求，以获取最新消息。</p><p id="c9af" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">长轮询是指服务器和客户机之间的连接保持足够长的时间，以便数据用新数据进行响应。一旦服务器提供了新的数据，连接就被关闭。但是，您可以立即向服务器发送一个新的长轮询请求，以模拟数据的实时事务。</p><h2 id="f3ee" class="mb ky iq bd kz mc md dn ld me mf dp lh kj mg mh ll kn mi mj lp kr mk ml lt mm bi translated">拯救世界的网络插座</h2><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mn"><img src="../Images/61b9dc4331c19418ff6dbd7daa4d21ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mrWQiJGRnk1a1let"/></div></div></figure><p id="4aa2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">AJAX只允许我们在需要的时候向服务器发送请求，但是它不允许服务器在需要的时候发送响应。</p><p id="3e69" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">WebSockets力挽狂澜。WebSockets允许双向(双工)通信。这意味着您可以让您的客户机和服务器在不中断连接的情况下相互通信。我们不再需要依赖HTTP协议进行实时通信。相反，我们“升级”了HTTP协议，这样我们就可以保持客户机和服务器之间的通信。</p><p id="7f74" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当WebSocket第一次启动时，它向您指定的URL发送一个简单的HTTP请求。从那里，HTTP请求“升级”为TCP套接字，实质上是HTTP握手发生后数据流动的安全隧道。握手可以被认为是客户机和服务器之间保持连接的“协议”。</p><h2 id="9a7c" class="mb ky iq bd kz mc md dn ld me mf dp lh kj mg mh ll kn mi mj lp kr mk ml lt mm bi translated">什么时候使用WebSockets？</h2><p id="882b" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated">尽管听起来很棒，但WebSockets并不能完全取代HTTP协议。使用WebSockets的最佳时机是当您需要服务器和客户端之间的低延迟实时通信时。</p><p id="17ea" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，如果你正在开发一个聊天应用程序，你希望你的用户应用程序与你的应用程序服务器保持连接，这样它就可以在用户回复信息时收到通知。WebSockets可以帮助实现连续的数据流。</p><p id="8efe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从本质上讲，当您希望通过互联网“流式传输”数据时，无论是客户端到服务器还是服务器到客户端，WebSockets都是一个好主意。</p><p id="d85a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">值得注意的是，WebSockets并不能在所有浏览器上工作。有些浏览器支持，有些不支持。用来测试WebSockets是否已经集成到浏览器中的一个很好的资源是CanIUse.com。</p><blockquote class="mt mu mv"><p id="bd14" class="jy jz ma ka b kb kc kd ke kf kg kh ki mw kk kl km mx ko kp kq my ks kt ku kv ij bi translated"><strong class="ka ir"> <em class="iq">你知道吗？<br/> </em> </strong> Google Drive不使用WebSockets来启用Drive的协作功能。他们使用自己的标准，与WebSockets略有不同。这个<a class="ae kw" href="https://stackoverflow.com/questions/35070217/what-technology-does-google-drive-use-to-get-real-time-updates" rel="noopener ugc nofollow" target="_blank">答案</a>解释的很好。</p><p id="1b04" class="jy jz ma ka b kb kc kd ke kf kg kh ki mw kk kl km mx ko kp kq my ks kt ku kv ij bi translated">Google可能已经决定这样做了，因为WebSockets还不是所有浏览器都支持的。许多人在国际上依赖于谷歌产品，因此旧技术也必须得到支持，以便提供更统一的用户体验，无论技术质量如何。</p><p id="523a" class="jy jz ma ka b kb kc kd ke kf kg kh ki mw kk kl km mx ko kp kq my ks kt ku kv ij bi translated">然而，这并不意味着您应该放弃WebSockets。仅仅因为Google不使用它并不意味着WebSockets不应该被使用。WebSockets有自己的时间和地点。尤其是当您的企业不关心大型浏览器支持时。</p></blockquote><h1 id="3530" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">WebSockets如何工作</h1><p id="09e7" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated">WebSockets使客户机和服务器之间的HTTP连接保持开放成为可能，这样它们就可以相互通信。这是网络通信的一个重大发展。以下是WebSockets的一些重要区别:</p><ul class=""><li id="c7bc" class="mz na iq ka b kb kc kf kg kj nb kn nc kr nd kv ne nf ng nh bi translated">WebSockets是一个独立的基于TCP的协议。HTTP是一个独立的基于TCP的协议来发送和接收数据。然而，WebSockets被设计为支持在TCP连接上运行的任何其他协议。本质上，您可以同时使用HTTP和WebSockets。</li><li id="ef21" class="mz na iq ka b kb ni kf nj kj nk kn nl kr nm kv ne nf ng nh bi translated">WebSockets是一个传输层，允许其他协议在其上运行。WebSockets API允许您定义子协议。子协议是帮助解释特定类型的其他协议的库。将子协议视为WebSockets技术的“插件”。</li><li id="9eba" class="mz na iq ka b kb ni kf nj kj nk kn nl kr nm kv ne nf ng nh bi translated">您可以运行的其他协议或“插件”的例子有XMPP、STOMP、SOAP、WAMP等。</li><li id="a788" class="mz na iq ka b kb ni kf nj kj nk kn nl kr nm kv ne nf ng nh bi translated">使用WebSockets的唯一要求是您使用一个Javascript库，该库可以处理“握手”并维护WebSockets连接。可以把Javascript库想象成一个模块，它允许你启动一个WebSockets连接并保持它打开。</li></ul><h2 id="9c67" class="mb ky iq bd kz mc md dn ld me mf dp lh kj mg mh ll kn mi mj lp kr mk ml lt mm bi translated">旅程的开始</h2><p id="00d0" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated">WebSocket连接从简单的HTTP请求开始。您的浏览器发送到网络服务器的连接，网络服务器将看到您想要“升级”您的连接。这开始了“握手”过程。一旦完成，就创建了一个WebSocket连接。</p><p id="3a32" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">具体情况是这样的:</p><ol class=""><li id="c2e8" class="mz na iq ka b kb kc kf kg kj nb kn nc kr nd kv nn nf ng nh bi translated">您的浏览器发送一个普通的HTTP请求，请求一个额外的头。</li><li id="9ddd" class="mz na iq ka b kb ni kf nj kj nk kn nl kr nm kv nn nf ng nh bi translated">web服务器获得HTTP请求并注意到对<code class="fe no np nq nr b">Upgrade</code>头的请求。这让web服务器知道我们正在请求WebSockets连接。</li><li id="1581" class="mz na iq ka b kb ni kf nj kj nk kn nl kr nm kv nn nf ng nh bi translated">如果服务器支持WebSockets协议，并且基本上以通信协议已经切换的确认来响应。</li></ol><p id="4e3a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">需要注意的是，WebSocket URLs使用了<code class="fe no np nq nr b">ws</code>或<code class="fe no np nq nr b">wss</code>方案。你将不再使用<code class="fe no np nq nr b">http</code>或<code class="fe no np nq nr b">https</code>来交流。</p><blockquote class="mt mu mv"><p id="3186" class="jy jz ma ka b kb kc kd ke kf kg kh ki mw kk kl km mx ko kp kq my ks kt ku kv ij bi translated"><strong class="ka ir"> <em class="iq">附加信息<br/> </em> </strong>如果您正在使用某种会话cookie来识别发起HTTP请求的用户，您会想知道如何防范CSRF(跨站点请求伪造)攻击。这里有一篇令人惊叹的文章<a class="ae kw" href="https://blog.securityps.com/2020/05/websockets-importance-of-firm-handshake.html" rel="noopener ugc nofollow" target="_blank">涵盖了为基于WebSockets的应用程序实现“稳固握手”的内容。</a></p></blockquote><p id="37f4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第一步中启动的常规HTTP请求的示例可能如下所示。我加粗了额外的标题，让web服务器知道我们正在尝试升级连接:</p><pre class="lw lx ly lz gt ns nr nt nu aw nv bi"><span id="f2a7" class="mb ky iq nr b gy nw nx l ny nz">GET wss://websocket.sunnychopper.com/ HTTP/1.1<br/>Origin: <a class="ae kw" href="http://sunnychopper.com" rel="noopener ugc nofollow" target="_blank">http://sunnychopper.com</a><br/>Connection: Upgrade<br/>Host: websocket.sunnychopper.com<br/><strong class="nr ir">Upgrade</strong>: <strong class="nr ir">websocket</strong></span></pre><h2 id="62af" class="mb ky iq bd kz mc md dn ld me mf dp lh kj mg mh ll kn mi mj lp kr mk ml lt mm bi translated">让交流成为可能</h2><p id="7273" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated">一旦HTTP请求被升级为WebSockets连接，您的浏览器和服务器现在就可以通信了。</p><p id="6dff" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">需要注意的是，移动设备行业的所有主要参与者都为他们的本地应用程序提供了WebSocket APIs。这意味着您可以在web浏览器之外使用WebSockets。您可以使用Swift和Java/Kotlin在移动应用程序中启用WebSockets。</p><blockquote class="mt mu mv"><p id="c663" class="jy jz ma ka b kb kc kd ke kf kg kh ki mw kk kl km mx ko kp kq my ks kt ku kv ij bi translated"><strong class="ka ir"> <em class="iq">用React Native或者Flutter之类的东西构建的应用呢？如果你正在使用React Native、Flutter、Ionic、Xamarin或其他混合方法开发应用程序，你可以随时检查该库是否支持WebSockets。</em></strong></p><p id="6f9d" class="jy jz ma ka b kb kc kd ke kf kg kh ki mw kk kl km mx ko kp kq my ks kt ku kv ij bi translated">例如，React Native有一个名为<code class="fe no np nq nr b"><a class="ae kw" href="https://www.npmjs.com/package/react-native-websocket" rel="noopener ugc nofollow" target="_blank">react-native-websocket</a></code>的NPM包，可以帮助建立WebSockets连接，尽管它不是直接用本地语言开发的。</p></blockquote><h1 id="7d4e" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">实现WebSockets</h1><p id="4f08" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated">为了开始使用WebSockets，您可以使用下面的WebSockets URL进行测试:<code class="fe no np nq nr b">wss://echo.websocket.org</code></p><p id="dc5b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是WebSockets背后的善良的人们提供给我们的一个公共地址，这样我们就可以熟悉这项技术，而不需要我们自己建立一个服务器。</p><p id="6114" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以通过链接<a class="ae kw" href="https://codepen.io/sunnychopper/project/editor/XkGLgG" rel="noopener ugc nofollow" target="_blank">在这里</a>查看所有的代码。它会把你带到CodePen，在那里你可以实时分析代码，并对其进行研究。</p><div class="oa ob gp gr oc od"><a href="https://codepen.io/sunnychopper/project/editor/XkGLgG" rel="noopener  ugc nofollow" target="_blank"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd ir gy z fp oi fr fs oj fu fw ip bi translated">连接到WebSockets</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">关于如何使用Javascript连接到WebSockets连接的基础教程。它涵盖了四个主要的…</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">codepen.io</p></div></div></div></a></div><blockquote class="mt mu mv"><p id="b43b" class="jy jz ma ka b kb kc kd ke kf kg kh ki mw kk kl km mx ko kp kq my ks kt ku kv ij bi translated"><strong class="ka ir"> <em class="iq">想自己设置后端服务器？<br/> </em> </strong>取决于你使用的后端技术(Node.js，PHP，Python等。)，将有不同的方法来实现WebSockets到您的web服务器中。</p><p id="d510" class="jy jz ma ka b kb kc kd ke kf kg kh ki mw kk kl km mx ko kp kq my ks kt ku kv ij bi translated">只需谷歌一下“node expressjs websockets”或“php laravel websockets”，你就会找到大量信息。</p></blockquote><h2 id="8e10" class="mb ky iq bd kz mc md dn ld me mf dp lh kj mg mh ll kn mi mj lp kr mk ml lt mm bi translated">WebSocket事件</h2><p id="8800" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated">WebSocket API有四种主要的事件类型:打开、消息、关闭和错误。</p><p id="508c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> <em class="ma"> Open </em> <br/> </strong>一旦客户端和服务器之间建立了连接，Open事件就会被触发。这也称为客户端和服务器之间的“初始握手”。</p><p id="6ba5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你想在连接建立后做一些动作，你需要定义一个<code class="fe no np nq nr b">onopen</code>函数。</p><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi om"><img src="../Images/bc5728b78063e3e62b8c6898a73ca6f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4eZwljbhCseVkcZzWEk0kA.jpeg"/></div></div><figcaption class="on oo gj gh gi op oq bd b be z dk translated">当WebSockets连接建立后更改按钮的文本。</figcaption></figure><p id="2caa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> <em class="ma">消息<br/> </em> </strong>每当服务器想要发送一些数据时，它就被称为“消息”，因为它实际上是浏览器将从服务器获得的新消息。消息可以是纯文本、二进制数据、JSON、图像数据等等。</p><p id="84d7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您想在浏览器收到来自服务器的消息时执行某种操作，那么您需要定义一个<code class="fe no np nq nr b">onmessage</code>函数。</p><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi or"><img src="../Images/8543a82ec461ff235ae46c51b6fbeebe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7mA9cSneGyk9V5xJST9-_Q.jpeg"/></div></div><figcaption class="on oo gj gh gi op oq bd b be z dk translated">基于从WebSockets连接接收的消息更新表。</figcaption></figure><p id="1bc9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，每当我向测试WebSockets连接发送消息时，它会立即发回一条消息，只是“回应”您所说的内容。</p><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi os"><img src="../Images/aef8e04f3f79931c06f76f240c6f16a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wpaNQrHPr1BETqFatYPMQw.jpeg"/></div></div><figcaption class="on oo gj gh gi op oq bd b be z dk translated">发送带有数据的请求并接收消息作为响应。</figcaption></figure><p id="8a72" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> <em class="ma">关闭<br/> </em> </strong>每当客户端和服务器之间的连接关闭时，就会触发关闭事件。由于连接不良或定义了一个<code class="fe no np nq nr b">onclose</code>事件，可以关闭一个连接。</p><p id="a461" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">连接关闭后，客户端和服务器不能再交换任何消息。在<code class="fe no np nq nr b">onclose</code>函数的定义中，您可以添加一些其他的功能，比如保存、缓存，或者您想在连接关闭之前做的任何事情。</p><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ot"><img src="../Images/8347702149be645f0a7d60fd41115bbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hkMm7wtIlx9IGzEhfnuaBw.jpeg"/></div></div><figcaption class="on oo gj gh gi op oq bd b be z dk translated">每当WebSockets连接关闭时运行一些代码。</figcaption></figure><p id="c48c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> <em class="ma">错误<br/> </em> </strong>每当客户端与服务器通信过程中出现错误，就会触发错误事件。您可以通过定义<code class="fe no np nq nr b">onerror</code>函数获得关于错误以及如何处理它的详细信息。</p><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ou"><img src="../Images/2ffe3d11b9a9bb72efdf61d23fef10e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YxjP7vOQD3DgzpfCgEEpww.jpeg"/></div></div><figcaption class="on oo gj gh gi op oq bd b be z dk translated">添加代码以在发生错误时将错误条目追加到我的表中。</figcaption></figure><h2 id="7369" class="mb ky iq bd kz mc md dn ld me mf dp lh kj mg mh ll kn mi mj lp kr mk ml lt mm bi translated">WebSocket操作</h2><p id="8041" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated">当某些事情发生时，事件被触发。事件是反动的。他们对某些事件的发生做出反应。这是您处理后端服务器扔给应用程序的数据的方式。</p><p id="afad" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另一方面，有行动。行动是主动的，有意图的。动作是当用户想要做某事时运行的东西。动作只能由客户端使用对WebSocket函数的显式调用来发起。</p><p id="5b8d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">主要有两个动作:<strong class="ka ir"> <em class="ma">发送</em> </strong>和<strong class="ka ir"> <em class="ma">关闭</em> </strong>。</p><p id="642f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> <em class="ma">发送</em> </strong> <br/>当您希望您的客户端应用程序向后端服务器发送一些数据时，您将需要使用<code class="fe no np nq nr b">send()</code>函数。例如，如果您正在开发一个实时聊天应用程序，每当用户想要向聊天发送消息时，您希望用户的浏览器向后端发送一个请求。</p><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ov"><img src="../Images/e4f08664874399698c1e25700df1147a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*khNsVTIlDjgMaGK6KCpoZw.jpeg"/></div></div><figcaption class="on oo gj gh gi op oq bd b be z dk translated">通过WebSockets连接将输入的值发送到后端服务器。</figcaption></figure><p id="62f8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> <em class="ma">关闭<br/> </em> </strong>如果您想关闭WebSockets连接，可以使用<code class="fe no np nq nr b">close()</code>功能。这种方法本质上是“告别握手”一旦连接被关闭，如果要进行进一步的通信，必须重新建立连接。</p><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ow"><img src="../Images/0fa073fd750d02f42c889b26e2c6fd3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TlO0jx9BgnQVWfsTnZAIDw.jpeg"/></div></div></figure><h2 id="75bf" class="mb ky iq bd kz mc md dn ld me mf dp lh kj mg mh ll kn mi mj lp kr mk ml lt mm bi translated">构建您的应用程序</h2><p id="9ebe" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated">这些是WebSockets的基础:事件和动作。一旦你理解了这四个事件和这两个动作，其他的事情就应该开始有条不紊了。</p><p id="bb76" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以使用<code class="fe no np nq nr b">send()</code>向服务器发送数据。这可以是字符串、JSON对象、XML对象或数组缓冲区。</p><p id="a53f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，假设您正在构建一个实时团队代码编辑器。您希望每个人都能看到每个人的光标在代码中的位置。每当团队中的任何人启动代码编辑器时，您就让他们的浏览器通过WebSockets连接到您的后端服务器。</p><p id="8e0b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以使用一些Javascript读取用户光标在代码中的位置，并使用<code class="fe no np nq nr b">send()</code>函数发送具体的光标位置信息。例如，您发送的对象的结构如下:</p><pre class="lw lx ly lz gt ns nr nt nu aw nv bi"><span id="b1a3" class="mb ky iq nr b gy nw nx l ny nz">{<br/>  line: 192,<br/>  column: 56,<br/>  userId: 424<br/>}</span></pre><p id="4c40" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">后端服务器可以接收、读取这些信息，并将您的新位置发送给其他所有连接到WebSockets连接的人。一旦你的队友通过一个<code class="fe no np nq nr b">onmessage</code>功能接收到你的新光标位置，他们的浏览器就可以更新你的光标在队友屏幕上的位置。</p><h1 id="da34" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">TL；DR —结论</h1><p id="b9b8" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated">在我看来，如果你想给你的产品增加“多人”的感觉，WebSockets是一项值得研究的技术。</p><p id="48fa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">与传统的RESTful API和HTTP相比，使用WebSockets连接有很多好处。以下是所有优势的总结:</p><ol class=""><li id="4437" class="mz na iq ka b kb kc kf kg kj nb kn nc kr nd kv nn nf ng nh bi translated"><strong class="ka ir">双向<br/>T5】传统的HTTP请求是单向的。它们只能从客户端发送到服务器。服务器无法启动与客户端的连接并向其发送数据。使用WebSockets，客户端和服务器都可以相互发送和接收消息。</strong></li><li id="f55f" class="mz na iq ka b kb ni kf nj kj nk kn nl kr nm kv nn nf ng nh bi translated"><strong class="ka ir">全双工</strong> <br/>本质上这意味着客户端和服务器可以同时向对方发送消息。客户端和服务器都不必等待响应。</li><li id="91b5" class="mz na iq ka b kb ni kf nj kj nk kn nl kr nm kv nn nf ng nh bi translated"><strong class="ka ir">单一TCP连接<br/> </strong>每当你使用一个简单的RESTful API时，每当你想发送数据时，你必须通过发送一个HTTP请求来创建一个到服务器的新的TCP连接。在您通过HTTP收到来自API的响应后，TCP连接被终止。另一方面，WebSockets升级HTTP连接并保持连接活动，以便客户端和服务器可以通过同一个TCP连接进行通信。这导致处理大量消息所需的时间大大减少。</li></ol><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ox"><img src="../Images/e3448dc2ac019a392d8a75d01377d921.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DEPNgF7EBE1_Gjdl"/></div></div><figcaption class="on oo gj gh gi op oq bd b be z dk translated">WebSockets在流式传输大量数据时，在性能方面抽RESTful API。</figcaption></figure><p id="3d13" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">WebSockets需要记住四个主要事件:打开、消息、错误和关闭。</p><p id="843e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Open ( <code class="fe no np nq nr b">socket.onopen</code>)在WebSockets连接建立后被触发。当客户端收到来自服务器的消息时，Message ( <code class="fe no np nq nr b">socket.onmessage</code>)被触发。当通过WebSockets连接的数据传输出错时，将触发Error ( <code class="fe no np nq nr b">socket.onerror</code>)。当WebSockets连接关闭时，Close ( <code class="fe no np nq nr b">socket.onclose</code>)被触发。</p><p id="6e41" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">用户可以采取两种主要的操作类型:发送或关闭。</p><p id="8362" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Send ( <code class="fe no np nq nr b">socket.send(data)</code>)允许客户端通过WebSockets连接向后端服务器发送数据。Close ( <code class="fe no np nq nr b">socket.close()</code>)允许客户端关闭与服务器的WebSockets连接。</p><h2 id="0f16" class="mb ky iq bd kz mc md dn ld me mf dp lh kj mg mh ll kn mi mj lp kr mk ml lt mm bi translated">有什么问题吗？</h2><p id="8d0b" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated">如果您对WebSockets有任何疑问，请随时在社交媒体上联系我。联系我的最好方式是通过Twitter ( <a class="ae kw" href="https://www.twitter.com/sunnychopper" rel="noopener ugc nofollow" target="_blank"> sunnychopper </a>)，我很乐意回答任何问题，甚至只是就技术和业务进行交谈。</p><p id="47d3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果这个指南帮助你对WebSockets有了基本的了解，以及它们能为你和你的企业做些什么，请留下一些掌声，因为它能帮助我决定下一步制作什么类型的内容！我一直在倾听反馈。💯</p></div></div>    
</body>
</html>