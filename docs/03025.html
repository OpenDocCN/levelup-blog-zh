<html>
<head>
<title>How to run Future Traverse that has a Side Effect</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何运行具有副作用的未来遍历</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-run-future-traverse-that-has-a-side-effect-2c4f466c7659?source=collection_archive---------12-----------------------#2020-04-15">https://levelup.gitconnected.com/how-to-run-future-traverse-that-has-a-side-effect-2c4f466c7659?source=collection_archive---------12-----------------------#2020-04-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/df8c5cd5b385bf7640fd138113f10485.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tPAcrZC0nrFMUK6P"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">最初发表于<a class="ae kc" href="https://edward-huang.com/scala/functional-programming/2020/04/14/how-to-run-future-traverse-that-has-side-effect/" rel="noopener ugc nofollow" target="_blank">https://edward-huang.com</a></figcaption></figure><p id="a47e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让您的程序异步已经成为性能和可伸缩性的不二法门。然而，异步编程的缺陷和问题很难解决。</p><p id="cccc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">几天前，我向我的一位同事解释了未来是如何运作的。我们讨论了如何执行一个未来列表来创建一个未来列表。</p><p id="cb2c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可能知道，操作本身已经被广泛使用，标准的Scala库有专门解决问题的函数，<code class="fe lb lc ld le b">Future.traverse</code>和<code class="fe lb lc ld le b">Future.sequence</code>。</p><p id="ba7d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们深入研究<code class="fe lb lc ld le b">traverse</code>和<code class="fe lb lc ld le b">sequence</code>的实现时，我想知道foldLeft在未来执行时是否会阻塞。</p><p id="e1ab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在对未来如何运作进行了无数的研究和理解后，我决定把我的发现和见解贴出来，这样你在处理未来时也能解决一些问题。</p><h1 id="74b0" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">问题陈述</h1><p id="a22d" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">让我们考虑一个问题，您需要创建一个函数getPrices，在这里您给出一个咖啡价格的URL列表。你批量提取。汇总所有URL中咖啡的价格，并将价格存储在现有的数据库中。将聚集的数据返回给用户。</p><p id="3d0a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一个条件是URL有重复。这意味着，它可能提供多个相同的URL，返回相同的价格。因此，您也需要处理这种情况。</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="195c" class="mq lg iq le b gy mr ms l mt mu">case class Coffee(url:String, price:Int)<br/><br/><em class="mv">// assuming this the fetch method for coffee<br/></em>def fetch(url:String): Future[Int] = ???<br/><br/><em class="mv">// write to DB for existing coffee<br/></em>def writeToDB(coffee:Coffee): Future[Unit] = ???<br/><br/><em class="mv">// read value from database<br/></em>def readfromDB(url:String): Future[Coffee] = ???<br/><br/>def isExistInDB(coffee:Coffee): Future[Boolean] = ???<br/><br/><br/><em class="mv">// your function here<br/></em>def batchCoffeePrice(coffeeUrls:List[String]): Future[List[Coffee]] = ???</span></pre><p id="d4a3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当您将<code class="fe lb lc ld le b">Coffee</code>写入数据库时，您需要检查该值是否存在于数据库中，然后再写入该值。</p><p id="da0d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设价格不会因为本文的说明而改变。</p><h1 id="11b8" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">执行顺序</h1><p id="e0f7" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">一种方法是检查数据库中是否存在该值。如果它不存在，获取URL并写入数据库。如果确实存在，从数据库中获取值并返回给用户。</p><p id="d69a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，执行是:</p><ol class=""><li id="361a" class="mw mx iq kf b kg kh kk kl ko my ks mz kw na la nb nc nd ne bi translated">检查数据库中是否存在该值</li><li id="434d" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated">如果该值存在，则获取该值并遍历下一个URL。</li><li id="01ef" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated">如果值不存在，获取URL并创建一个coffee实例。</li><li id="ec61" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated">将coffee实例写入数据库。</li></ol><p id="77db" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，第一本能会是这样做:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="167d" class="mq lg iq le b gy mr ms l mt mu">def batchCoffeePrice(coffeeUrls:List[String]): Future[List[Coffee]] = Future.traverse(coffeeUrls){url =&gt;<br/>  isExistInDB(url).flatMap{ boolean =&gt;<br/>    if(boolean) {<br/>      readFromDB(url)<br/>    }<br/>    else {<br/>      fetch(url).flatMap{<br/>        price =&gt;  {<br/>          val coffee = Coffee(url,price)<br/>          writeToDB(coffee)<br/>          coffee<br/>        }<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="3460" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">看起来不错，逻辑似乎也行得通。但是，当调用<code class="fe lb lc ld le b">batchCoffeePrice</code>时，如果coffeeUrls是重复的，它会将多个相同的值写入数据库。</p><p id="9de2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这似乎很奇怪。既然<code class="fe lb lc ld le b">isExistInDB</code>应该已经检查它是否存在于数据库中，然后执行操作，为什么它仍然有重复的写操作？</p><h1 id="029b" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">深入遍历</h1><p id="e776" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">问题靠<code class="fe lb lc ld le b">Future.traverse</code>。遍历是顺序执行还是并行执行未来列表？</p><p id="ad75" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你研究一下<code class="fe lb lc ld le b">Future.traverse</code>的实现:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="a1aa" class="mq lg iq le b gy mr ms l mt mu">def traverse[A](initial:List[A])(f:A =&gt; Future[B]): Future[List[B]] = initial.foldLeft(List.empty[B]){(acc, currA) =&gt; <br/>  val res = f(currA)<br/>  for{<br/>    a &lt;- acc<br/>    b &lt;- res<br/>  } yield a :+ b<br/>}</span></pre><p id="925f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你注意到foldLeft中的Traverse implements，<code class="fe lb lc ld le b">val res = f(currA)</code>解释了导致函数不一致的bug。</p><p id="7a94" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的遍历函数无阻塞地遍历所有的未来列表。不过，既然未来<strong class="kf ir">热切</strong>，那就看你怎么实现你的<code class="fe lb lc ld le b">f</code>功能了。它可以是顺序的，也可以是并行的。</p><p id="25df" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">返回语句<code class="fe lb lc ld le b">Future[List[B]]</code>没有区别，因为在函数结束时，它返回所有结果<code class="fe lb lc ld le b">f(currA)</code>。但是，如果你想用<code class="fe lb lc ld le b">f(currA)</code>做一些事情，你需要意识到，尤其是处理一些急切和副作用的事情，它是并行的。</p><p id="5425" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你想在将来处理副作用，比如获取数据库，你需要按顺序执行值列表，因为<strong class="kf ir">顺序</strong>很重要。</p><p id="8ec7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了解释上面的代码，函数将首先触发，然后连接到for-comprehensive。因此，并行调用<code class="fe lb lc ld le b">List[A]</code>中的所有值。然而，如果我们像这样将函数签名改为<code class="fe lb lc ld le b">lazy val res</code>:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="4958" class="mq lg iq le b gy mr ms l mt mu">def traverse[A](initial:List[A])(f:A =&gt; Future[B]): Future[List[B]] = initial.foldLeft(List.empty[B]){(acc, currA) =&gt; <br/>  lazy val res = f(currA)<br/>  for{<br/>    a &lt;- acc<br/>    b &lt;- res<br/>  } yield a :+ b<br/>}</span></pre><p id="e71f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们解决了让异步值顺序运行而不是并行运行的问题。</p><h1 id="0194" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">解决问题</h1><p id="fc9d" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">为了解决这个问题，我们实现了foldLeft，并遍历自己，使值懒惰。</p><p id="58de" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们想重构上面的代码并放入<code class="fe lb lc ld le b">Future.traverse</code>，你需要再次检查<code class="fe lb lc ld le b">f</code>函数<code class="fe lb lc ld le b">ifExistInDB</code>的内部。</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="24f0" class="mq lg iq le b gy mr ms l mt mu">def batchCoffeePrice(coffeeUrls:List[String]): Future[List[Coffee]] = Future.traverse(coffeeUrls){url =&gt;<br/>  isExistInDB(url).flatMap{ boolean =&gt;<br/>    if(boolean) {<br/>      readFromDB(url)<br/>    }<br/>    else {<br/>    for {<br/>      price &lt;- fetch(url)<br/>      exist &lt;- isExistInDB(url)<br/>    } yield {<br/>        val coffee = Coffee(url,price)<br/>        if(exist) writeToDB(coffee) <br/>        coffee<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="3cf5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，你最好不要用Future。遍历并使用<code class="fe lb lc ld le b">foldLeft</code>并使值连续，以在函数中创建更少的IO。</p><h1 id="d46a" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">主要外卖</h1><ul class=""><li id="2ab8" class="mw mx iq kf b kg md kk me ko nk ks nl kw nm la nn nc nd ne bi translated"><code class="fe lb lc ld le b">Future.traverse</code>适合执行一个互不依赖的列表(或者你未来的副作用)。如果你想在未来实现这个功能。执行并行，你可以做未来。</li><li id="5178" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nn nc nd ne bi translated">未来是天生渴望的。因此，一旦你调用<code class="fe lb lc ld le b">Future{something}</code>它就会立即执行。为了不让它急，可以改成IO。</li><li id="c313" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nn nc nd ne bi translated">Future.sequence使用未来。在引擎盖下穿行。</li></ul></div></div>    
</body>
</html>