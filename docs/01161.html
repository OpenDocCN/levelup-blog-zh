<html>
<head>
<title>A Guide to Managing Loading State for Angular App API Requests</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Angular应用程序API请求的加载状态管理指南</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/a-guide-to-managing-loading-state-for-angular-app-api-requests-83b7429d0e3a?source=collection_archive---------0-----------------------#2019-11-20">https://levelup.gitconnected.com/a-guide-to-managing-loading-state-for-angular-app-api-requests-83b7429d0e3a?source=collection_archive---------0-----------------------#2019-11-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="9a73" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">有角的</h2><div class=""/><div class=""><h2 id="960c" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">本教程将带您了解如何在Angular应用程序中跟踪API请求的状态，并显示加载UI。</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/8b6629c74e8ed5b0d8b229ae4305002a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dxDImcUV0gNXbdBEzKaSXg.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">图片由<a class="ae lh" href="https://unsplash.com/@goldcoastmedialab?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> GC图书馆创意技术实验室</a>在<a class="ae lh" href="https://unsplash.com/s/photos/coffee?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="5e3a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在本文中，我将分享在Angular应用程序中API调用期间管理加载状态的最佳方法之一。本文将分为以下几个部分:</p><ol class=""><li id="4cda" class="me mf it lk b ll lm lo lp lr mg lv mh lz mi md mj mk ml mm bi translated">概观</li><li id="fb0d" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">使用RxJS中的Subject创建一个装载服务</li><li id="e666" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">创建一个装载拦截器</li><li id="00fd" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">创建独立的加载组件</li><li id="6bca" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">将拦截器应用于整个项目</li></ol><p id="5fc2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><em class="ms">更多类似内容，请查看</em><a class="ae lh" href="https://betterfullstack.com" rel="noopener ugc nofollow" target="_blank"><em class="ms">https://betterfullstack.com</em></a></p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="cbde" class="na nb it bd nc nd ne nf ng nh ni nj nk ki nl kj nm kl nn km no ko np kp nq nr bi translated">概观</h1><p id="7b80" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">我们希望能够在一个简单且集中的位置管理应用程序的加载状态。</p><p id="2ff7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">有几种方法可以管理加载状态。</p><p id="a7ea" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">一种方法是在调用API的组件上创建一个<strong class="lk jd">加载变量</strong>，并将变量设置为<code class="fe nx ny nz oa b">true</code>。然后调用一个服务并订阅它，在API响应后将变量设置为<code class="fe nx ny nz oa b">false</code>。这一切都发生在每个组件中。</p><p id="32a5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">另一种方法是使用带有<code class="fe nx ny nz oa b">loading$</code>选择器的状态管理，在根视图组件中，我将从状态选择器订阅<code class="fe nx ny nz oa b">loading$</code>来显示或隐藏根容器组件中的加载组件。所以每次我们调度一个动作，我都要调度加载动作来设置加载状态为<code class="fe nx ny nz oa b">true</code> <strong class="lk jd"> </strong>和<code class="fe nx ny nz oa b">false</code>。这导致改变加载值的动作的代码重复。</p><p id="60dd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我最终达成了一个更简单的解决方案，使用<strong class="lk jd">事件总线发出</strong>加载事件，并将值设置为<code class="fe nx ny nz oa b">true</code>或<code class="fe nx ny nz oa b">false</code>。加载组件将侦听加载事件，以在屏幕上显示或隐藏加载。这在没有国家管理的情况下也能很好地工作。但是，我仍然必须在每次调用API时发出加载事件。</p><p id="4625" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">以上所有解决方案都有一个共同点——它们大量复制代码。所以我最终决定使用<strong class="lk jd">角度拦截器</strong>来处理装载。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="3edb" class="na nb it bd nc nd ne nf ng nh ni nj nk ki nl kj nm kl nn km no ko np kp nq nr bi translated">使用主题RxJS创建装载服务</h1><p id="6e7a" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">如果你不知道什么是主题，你可以阅读关于它的<a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/rxjs-subjects-explained-with-examples-78ae7b9edfc?source=friends_link&amp;sk=59c028b3e9fc6348f8faf54f1759701a"> RxJS主题用例子解释</a>。</p><blockquote class="ob oc od"><p id="c1a0" class="li lj ms lk b ll lm kd ln lo lp kg lq oe ls lt lu of lw lx ly og ma mb mc md im bi translated">一个<code class="fe nx ny nz oa b">Subject</code>就像一个<code class="fe nx ny nz oa b">Observable</code>，但是可以多播给许多<code class="fe nx ny nz oa b">Observers</code>。<code class="fe nx ny nz oa b">Subjects</code>就像<code class="fe nx ny nz oa b">EventEmitters</code>:他们维护着许多听众的注册表。</p></blockquote><p id="0131" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这里的想法是:</p><ul class=""><li id="c506" class="me mf it lk b ll lm lo lp lr mg lv mh lz mi md oh mk ml mm bi translated">创建一个名为<code class="fe nx ny nz oa b">LoadingService</code>的服务。我更喜欢使用<code class="fe nx ny nz oa b">ng g service loading</code>来创建服务文件。</li><li id="126b" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md oh mk ml mm bi translated">有一个<code class="fe nx ny nz oa b">loading$</code>主题，它将把最新的装载状态发送给他们的观察者。</li><li id="cd9c" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md oh mk ml mm bi translated">有2种方法:<code class="fe nx ny nz oa b">startLoading</code>和<code class="fe nx ny nz oa b">stopLoading</code>。这些方法会将<code class="fe nx ny nz oa b">true</code>和<code class="fe nx ny nz oa b">false</code>的值设置为<code class="fe nx ny nz oa b">loading$</code>。</li></ul><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oi oj l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">loading.service.ts</figcaption></figure></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="f1e4" class="na nb it bd nc nd ne nf ng nh ni nj nk ki nl kj nm kl nn km no ko np kp nq nr bi translated">创建一个装载拦截器</h1><p id="b14a" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">拦截器是一种对所有HTTP请求做出反应或修饰的技术。Angular将看到全球范围内的传出和传入的HTTP请求，我们可以将其挂钩，以围绕它构建功能。</p><ul class=""><li id="da7f" class="me mf it lk b ll lm lo lp lr mg lv mh lz mi md oh mk ml mm bi translated">拦截HTTP请求，并从加载服务添加<code class="fe nx ny nz oa b">startLoading</code>和<code class="fe nx ny nz oa b">stopLoading</code>方法。</li><li id="afdc" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md oh mk ml mm bi translated">检查多个请求的情况。</li></ul><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oi oj l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">loading-interceptor.service.ts</figcaption></figure></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="7403" class="na nb it bd nc nd ne nf ng nh ni nj nk ki nl kj nm kl nn km no ko np kp nq nr bi translated">创建独立的加载组件</h1><p id="d642" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">加载组件将做3件主要的事情:</p><ul class=""><li id="8338" class="me mf it lk b ll lm lo lp lr mg lv mh lz mi md oh mk ml mm bi translated">包括将在屏幕上显示加载的HTML</li><li id="0cd4" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md oh mk ml mm bi translated">收听来自装载服务的<code class="fe nx ny nz oa b">loading$</code></li><li id="705c" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md oh mk ml mm bi translated">根据状态值添加要显示和隐藏的样式</li><li id="4820" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md oh mk ml mm bi translated">当生命周期<code class="fe nx ny nz oa b">OnDestroy</code>发生时，移除订阅</li></ul><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oi oj l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">loading.component.ts</figcaption></figure><p id="e263" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">对于UI，您可以使用来自Angular material、Bootstrap或自定义的微调器。</p><p id="b546" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在生命周期<code class="fe nx ny nz oa b">AfterViewInit</code>中，您将从加载服务订阅<code class="fe nx ny nz oa b">loading$</code>来检查加载状态，并通过使用元素<code class="fe nx ny nz oa b">ref</code>来改变组件的样式。</p><p id="05e0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">请记住，当生命周期<strong class="lk jd">毁灭</strong>发生时，请取消订阅。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="4eec" class="na nb it bd nc nd ne nf ng nh ni nj nk ki nl kj nm kl nn km no ko np kp nq nr bi translated">将拦截器应用于整个项目</h1><p id="99c5" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">要将加载侦听器应用于整个项目，只需将加载侦听器添加到app模块中的提供程序中。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/dd695e3f4408d9270d8f99bdfae2f7b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1008/format:webp/1*R1eq8jVT_IOUJvdbMxCQuA.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">AppModule</figcaption></figure><p id="c20c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">记住，我们必须导入<code class="fe nx ny nz oa b">HttpClientModule</code>才能使用<code class="fe nx ny nz oa b">HTTP_INTERCEPTORS</code>。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="0c4f" class="na nb it bd nc nd ne nf ng nh ni nj nk ki nl kj nm kl nn km no ko np kp nq nr bi translated">摘要</h1><p id="c3be" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">本文为在Angular应用程序中向屏幕添加加载状态提供了一个很好的解决方案。</p><p id="35bc" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为此，我们只需要:</p><ul class=""><li id="e14a" class="me mf it lk b ll lm lo lp lr mg lv mh lz mi md oh mk ml mm bi translated">主题为<code class="fe nx ny nz oa b">loading$</code>的服务</li><li id="b790" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md oh mk ml mm bi translated">从服务调用方法的角度拦截器</li><li id="917f" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md oh mk ml mm bi translated">从服务订阅<code class="fe nx ny nz oa b">loading$</code>主题的加载组件</li></ul><p id="7534" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我希望这篇文章对你有用！你可以跟着我上<a class="ae lh" href="https://medium.com/@transonhoang?source=post_page---------------------------" rel="noopener">中型</a>。我也在<a class="ae lh" href="https://twitter.com/transonhoang" rel="noopener ugc nofollow" target="_blank">推特</a>上。欢迎在下面的评论中留下任何问题。我很乐意帮忙！</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><div class="ks kt ku kv gt ol"><a href="https://betterfullstack.com/stories/" rel="noopener  ugc nofollow" target="_blank"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd jd gy z fp oq fr fs or fu fw jc bi translated">故事-更好的全栈</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">关于JavaScript、Python和Wordpress的有用文章，有助于开发人员减少开发时间并提高…</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">betterfullstack.com</p></div></div><div class="ou l"><div class="ov l ow ox oy ou oz lb ol"/></div></div></a></div></div></div>    
</body>
</html>