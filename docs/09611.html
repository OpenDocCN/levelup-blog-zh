<html>
<head>
<title>Dependent &amp; Searchable Selections in Django Model Admin is now a cakewalk</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Django模型管理中的依赖和可搜索选择现在是一件轻而易举的事情</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/dependent-searchable-selections-in-django-model-admin-is-now-a-cakewalk-4b34c5e835f8?source=collection_archive---------5-----------------------#2021-08-26">https://levelup.gitconnected.com/dependent-searchable-selections-in-django-model-admin-is-now-a-cakewalk-4b34c5e835f8?source=collection_archive---------5-----------------------#2021-08-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="1805" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们都知道Django是一个很棒的框架，它提供了基于模型的默认管理界面。Django支持的默认功能解决了我们95%的用例，但在很多情况下，应用程序需要某些功能，我们必须按照我们需要的方式扩展内置的Django功能，这对新手来说是一场噩梦。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/a86fa9644454604e156709ccb0241c10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5jqYG0CGEOhldCEYanXR4A.jpeg"/></div></div></figure><p id="58e0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个这样的例子是我们迫切需要下面的功能。</p><p id="b2c2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">问题陈述</strong></p><ul class=""><li id="8732" class="kx ky iq jp b jq jr ju jv jy kz kc la kg lb kk lc ld le lf bi translated">一个选择字段可以派生一个或多个选择字段(<strong class="jp ir">一父多子</strong>)。</li><li id="bb0a" class="kx ky iq jp b jq lg ju lh jy li kc lj kg lk kk lc ld le lf bi translated">选择字段的数据可以基于一个或多个选择字段导出(<strong class="jp ir">一子多父</strong></li><li id="4c5e" class="kx ky iq jp b jq lg ju lh jy li kc lj kg lk kk lc ld le lf bi translated">一个选择字段可以派生出另一个选择字段，两个选择字段共同派生出几个其他选择字段(<strong class="jp ir">多父-多子</strong>)。</li><li id="be99" class="kx ky iq jp b jq lg ju lh jy li kc lj kg lk kk lc ld le lf bi translated">选择字段可以在同一个模型中，也可以在嵌套的内联中(<strong class="jp ir">应该支持多层内联</strong></li><li id="254c" class="kx ky iq jp b jq lg ju lh jy li kc lj kg lk kk lc ld le lf bi translated">选择字段应该可以使用全选或取消全选支持进行搜索。</li></ul><p id="dd0d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们已经寻找了很长时间，如果我们能找到一个很棒的库，可以轻松地处理我们的用例，但我们没有找到。因此，我们开始探索更多的选项，并决定编写我们的自定义库，以一种可以开源的通用方式来解决我们的用例，结果是</p><div class="ll lm gp gr ln lo"><a href="https://pypi.org/project/django-admin-kit/" rel="noopener  ugc nofollow" target="_blank"><div class="lp ab fo"><div class="lq ab lr cl cj ls"><h2 class="bd ir gy z fp lt fr fs lu fu fw ip bi translated">django-管理工具包</h2><div class="lv l"><h3 class="bd b gy z fp lt fr fs lu fu fw dk translated">Django管理工具包为Django管理员提供了额外的功能</h3></div><div class="lw l"><p class="bd b dl z fp lt fr fs lu fu fw dk translated">pypi.org</p></div></div><div class="lx l"><div class="ly l lz ma mb lx mc kv lo"/></div></div></a></div><p id="f1b1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本文中，我将详细介绍如何将这个包与您的Django项目集成，以及如何使用这个包来实现每一个用例。</p><p id="ed65" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">安装过程</strong></p><ul class=""><li id="092a" class="kx ky iq jp b jq jr ju jv jy kz kc la kg lb kk lc ld le lf bi translated">将包添加到requirements . txt<strong class="jp ir">(django-admin-kit = = 0 . 0 . 17是当前的稳定版本</strong>)</li><li id="ec57" class="kx ky iq jp b jq lg ju lh jy li kc lj kg lk kk lc ld le lf bi translated">将<strong class="jp ir"> admin_kit </strong>添加到设置文件中的INSTALLED_APPS。</li><li id="6f90" class="kx ky iq jp b jq lg ju lh jy li kc lj kg lk kk lc ld le lf bi translated">将它添加到您的根urls.py中</li></ul><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi md"><img src="../Images/07976ea1c1b12601c4bcf478890e078c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zAsKpXhp50g10fzipSWkag.png"/></div></div></figure><p id="56d2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">使用流程</strong></p><p id="6201" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们已经建立了依赖关系，让我们试着用一个场景来逐个理解用例。</p><p id="9e13" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">场景-1 </strong> - &gt; <strong class="jp ir">有一组地区，每个地区有一组国家。现在，基于区域选择，我需要填充国家。</strong></p><p id="5d3c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">步骤1 -&gt;导入模型中的依赖项</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi me"><img src="../Images/8b5c693fe095297925e9ecd0cc5e7e09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tjE_hQt738VKOTc1aLIBYQ.png"/></div></div></figure><p id="660a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">步骤2 -&gt;定义字段之间的关系</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mf"><img src="../Images/79be5a6a53b8ea050aa59e7aa3407da8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PVYoSbrWpZueiYc2Mfj7PA.png"/></div></div></figure><p id="760a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦导入了SelectField，就会在其中添加一个名为kit_config的特殊属性，您可以在其中定义关系b/w字段和一些元数据。</p><ul class=""><li id="c201" class="kx ky iq jp b jq jr ju jv jy kz kc la kg lb kk lc ld le lf bi translated"><strong class="jp ir">标识符</strong> - &gt;作为依赖字段的标识符，指定它依赖于哪个源字段。注意，一个视图中的多个字段的标识符不应该是相同的。<strong class="jp ir">这是每个SelectField的必需属性。</strong></li><li id="dde9" class="kx ky iq jp b jq lg ju lh jy li kc lj kg lk kk lc ld le lf bi translated"><strong class="jp ir"> ajax-source - &gt; </strong>如果一个字段依赖于另一个字段，只需用源字段的逗号分隔标识符定义ajax-source即可。在我们的例子中，它只依赖于source_region，只需在ajax-source或source_countries中定义source_region的标识符。</li><li id="3579" class="kx ky iq jp b jq lg ju lh jy li kc lj kg lk kk lc ld le lf bi translated"><strong class="jp ir"> source_router </strong> - &gt;一旦您从source_region中选择了一个项目，应用程序就会得到一个带有router_path的回调，并且应用程序会将数据发送回客户端。</li></ul><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mg"><img src="../Images/7066a8beda4a89e73447b2e81e01878c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XKcADqiqfVAS9sTW_9y1tA.png"/></div></div></figure><p id="fb55" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">来自AJAX调用的数据应该是一个2D列表，其中外部列表表示一个项目，内部列表表示一个项目的元数据。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/edb0e3d3fb01732130242c01a474d525.png" data-original-src="https://miro.medium.com/v2/resize:fit:1308/format:webp/1*xVZ-e8Am04tlGqdGaQ6_7A.png"/></div></figure><p id="fe5f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">内部列表中的第一个元素是将要显示的文本，内部列表中的第二个元素是存储在DB中的值。</p><p id="7e10" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">结果是这样的。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mi"><img src="../Images/b624909454ca4ffe13e4bd79c2eae990.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g7jIAczX_-WsPGcJtOVHKQ.png"/></div></div></figure><p id="341a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">帖子选择，界面如下图</strong></p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mj"><img src="../Images/ac8e7189d86dfbe84af07796f19b2ba2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lra8Kk8aL2IgNfgE_EebXw.png"/></div></div></figure><p id="70a0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在主要的问题来了，我如何注册我的ajax调用？嗯，这很简单。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mk"><img src="../Images/54d9615255a9c1ff6498ba7c5d8fcfe5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RRiWCgLYwMpouN5suSBqaw.png"/></div></div></figure><p id="1b62" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在应用程序内的ajax.py文件中，用<strong class="jp ir"> source_router </strong>注册您的类。</p><ul class=""><li id="92e6" class="kx ky iq jp b jq jr ju jv jy kz kc la kg lb kk lc ld le lf bi translated">类名可以是任何东西。</li><li id="d7af" class="kx ky iq jp b jq lg ju lh jy li kc lj kg lk kk lc ld le lf bi translated">该类应该只有一个参数，即<strong class="jp ir"> admin_kit.ajax.Ajax </strong></li><li id="8ed3" class="kx ky iq jp b jq lg ju lh jy li kc lj kg lk kk lc ld le lf bi translated">该类应该有一个包含两个参数的run方法。作为请求一部分的数据在第一个参数中发送，任何附加属性作为kwargs的一部分发送。</li><li id="fa09" class="kx ky iq jp b jq lg ju lh jy li kc lj kg lk kk lc ld le lf bi translated">所有父字段选择信息都将是请求查询参数的一部分，我们可以获取信息，在选择的基础上执行相应的业务逻辑，并返回包含数据(文本和实际值)的数据的2D列表</li></ul><p id="c03e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">耶，就是这样。我们已经成功完成了我们的第一个基本用例。</p><p id="29b5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">场景二</strong></p><p id="c4ad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们已经看到了一个字段依赖于一个字段属性的选择的用例，我们可能还会看到一个字段的数据是基于多个父选择而派生出来的。</p><p id="5e4d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">啊，很难吗？答案是否定的。</p><p id="0955" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你所要做的就是，在ajax-source中不要指定一个标识符，你需要指定一个逗号分隔的标识符列表，这个字段依赖于这个列表。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ml"><img src="../Images/126d80f8ef6513735ad1393bdc306864.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ol21bOAUBigmspH7TeznaQ.png"/></div></div></figure><p id="b9d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">看看这个简单的例子，其中字段B依赖于字段A的选择，并将它的ajax-source指定为单独的A，并指定它可以从中获取数据的路由器。</p><p id="318d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是对于字段C，它既取决于字段A的选择，也取决于字段B的选择。因此，它将其ajax-source指定为字段A、字段B标识符和一个源路由器，在A和B选择中可以从源路由器获取字段C的数据。</p><p id="11d6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从管理，我们将发送一个回调到B一旦A被选中，我们发送一个回调到C只有当A &amp; B被选中。</p><p id="e29c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在有多个父节点的情况下，回调URL看起来是这样的(<strong class="jp ir">示例</strong>)。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mm"><img src="../Images/1de1ce18d7c08dac81de6365026287a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gdY5qfDOWTGToOeKz1AEEw.png"/></div></div></figure><ul class=""><li id="f24e" class="kx ky iq jp b jq jr ju jv jy kz kc la kg lb kk lc ld le lf bi translated">gi _ fetch _ region _ by _ promo _ code _ vertical是源路由器</li><li id="690c" class="kx ky iq jp b jq lg ju lh jy li kc lj kg lk kk lc ld le lf bi translated">id_vertical和id_promocode是父代的标识符。</li></ul><p id="683a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">场景3 </strong></p><p id="f859" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们讨论的另外两个场景是父字段和依赖字段在同一个模型中。但是，如果父字段在视图的一个模型中，而子字段在另一个模型中，并且父字段和子字段之间的关系是一对多的，该怎么办呢？</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mn"><img src="../Images/f21baa37b35516ea54e63571d03af1b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E5RH17Ff_u8j93ua8bRRgQ.png"/></div></div></figure><p id="085d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这里，我们可以继续添加一个子模型，因为它在一个外键关系w.r.t父模型中。</p><p id="1231" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们确保在他们的项目中集成这个包的人不会有任何不便。<strong class="jp ir">在这种情况下，开发者甚至不需要改变配置</strong>。</p><p id="d64d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每次添加表单集(内联模型)时，我们都会在后台创建一个依赖树，并向其中添加动作事件侦听器，以便admin_kit包检查整个表单主体的父表单，并侦听对它们所做的更改。</p><p id="2a59" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就ajax回调而言，什么都不需要改变。它与场景2完全相同</p><p id="d1a1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">场景四</strong></p><p id="a065" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">除了解决方案之外，最复杂的场景是一样的。</p><p id="6dbf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果有一个祖父模型，它与Parent Model是一对多关系，而ParentModel与ChildModel是一对多关系。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/2d81c260306dccbf7917f78e1fa8258b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a-YcduLm0CipwcKFFhBpSA.png"/></div></div></figure><p id="54e8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里的问题是，假设视图是这样的。</p><ul class=""><li id="2438" class="kx ky iq jp b jq jr ju jv jy kz kc la kg lb kk lc ld le lf bi translated">1个祖父母，2个父母，每个父母有2个孩子。</li></ul><p id="cae0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，字段B的标识符在两个父模型中保持不变。当我们试图添加一个子模型时，它是从哪个B选择中得到的？</p><p id="0dd8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">它将基于第一个父B选择还是第二个父B选择获得？</strong></p><p id="a1b4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们确保它是从最近的父代中派生出来的。</p><ul class=""><li id="112b" class="kx ky iq jp b jq jr ju jv jy kz kc la kg lb kk lc ld le lf bi translated">当添加了Parent-1模型的子模型时，字段C将基于祖父A和Parent-1 B派生</li><li id="2fac" class="kx ky iq jp b jq lg ju lh jy li kc lj kg lk kk lc ld le lf bi translated">当添加了Parent-2模型的子模型时，字段C将基于祖父A和Parent-2 B派生。</li></ul><p id="b59a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就ajax回调而言，什么都不需要改变。它与场景2完全相同</p><p id="3a21" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">我们去掉了配置字段之间关系的复杂性，并确保客户端只指定当前字段依赖于哪些字段，不多不少。</strong></p><p id="ad1e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">场景-5</strong>-&gt;-<strong class="jp ir">可搜索选择</strong></p><p id="63ba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在Select2 JQuery插件的帮助下，模型提供了默认的可搜索选择支持。</p><p id="5532" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">场景-6 - &gt;选择所有支持</strong></p><p id="ddca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在多选的情况下，如果客户端希望有一个全选选项，我们启用了SelectField旁边的复选框。如果选中该复选框，将选择所有选项，如果再次取消选中该复选框，将删除所有选项。</p><p id="900c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">希望我已经涵盖了所有的场景，并希望看到该软件包集成到您的项目中。如果你有任何问题，请留言或发邮件到</strong> <code class="fe mo mp mq mr b"><strong class="jp ir">codeforlyf@gmail.com</strong></code> <strong class="jp ir">给我，我很乐意帮助你们。</strong></p></div></div>    
</body>
</html>