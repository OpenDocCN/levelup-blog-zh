<html>
<head>
<title>solc-js: Compiling Ethereum Smart Contracts Locally with JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">solc-js:用JavaScript在本地编译以太坊智能合约</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/compiling-ethereum-smart-contracts-locally-0-5-2-0-5-x-ebfea0aed3a9?source=collection_archive---------1-----------------------#2019-01-25">https://levelup.gitconnected.com/compiling-ethereum-smart-contracts-locally-0-5-2-0-5-x-ebfea0aed3a9?source=collection_archive---------1-----------------------#2019-01-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/3d2d5931f815464f9f31e614b410d978.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wKE4jzv28di0sj380IKXTg.png"/></div></div></figure><div class=""/><div class=""><h2 id="fd2b" class="pw-subtitle-paragraph jy ja jb bd b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp dk translated">本教程将带你在本地环境中编译Solidity契约。(坚实度0 . 5 . 2–0.5 . x)</h2></div><p id="6a93" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在为Ethereum平台开发时，能够使用solc编译器是一项重要的技能，尤其是当您不想依赖像Remix这样的基于web的ide时。了解如何使用solc将有助于您理解开发智能合同的工具链。在本教程中，您将学习如何使用<code class="fe lm ln lo lp b">solc-js</code>来编译两个非常简单的智能合约。</p><h1 id="435e" class="lq lr jb bd ls lt lu lv lw lx ly lz ma kh mb ki mc kk md kl me kn mf ko mg mh bi translated"><strong class="ak">安装依赖关系:</strong></h1><p id="56b5" class="pw-post-body-paragraph kq kr jb ks b kt mi kc kv kw mj kf ky kz mk lb lc ld ml lf lg lh mm lj lk ll ij bi translated">您将使用solc-js编译两个简单的智能契约。首先你需要<a class="ae mn" href="https://nodejs.org/en/download/" rel="noopener ugc nofollow" target="_blank">安装Node.js </a>。</p><p id="b401" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">安装Node.js后，创建一个项目文件夹并初始化项目。</p><pre class="mo mp mq mr gt ms lp mt mu aw mv bi"><span id="d57a" class="mw lr jb lp b gy mx my l mz na">mkdir MyProject // creating the project folder<br/>cd MyProject<br/>npm init // npm will guide you trough the initialisation process</span></pre><p id="dfed" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">让我们也安装一些稍后需要的依赖项。</p><pre class="mo mp mq mr gt ms lp mt mu aw mv bi"><span id="d0af" class="mw lr jb lp b gy mx my l mz na">npm install solc fs-extra path</span></pre><p id="a005" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在我们的项目文件夹中创建一个新文件夹<code class="fe lm ln lo lp b">contracts</code>，它将包含智能合同。您的文件夹结构现在应该看起来像这样:</p><figure class="mo mp mq mr gt is gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/bd801c8d236c980156311da2aee33cf5.png" data-original-src="https://miro.medium.com/v2/resize:fit:892/format:webp/1*e1TClaI1ciBHmTCn8dpqig.png"/></div></figure><h1 id="e39f" class="lq lr jb bd ls lt lu lv lw lx ly lz ma kh mb ki mc kk md kl me kn mf ko mg mh bi translated"><strong class="ak">智能合约</strong></h1><p id="1185" class="pw-post-body-paragraph kq kr jb ks b kt mi kc kv kw mj kf ky kz mk lb lc ld ml lf lg lh mm lj lk ll ij bi translated">现在您将创建2个非常简单的智能契约<code class="fe lm ln lo lp b">DogCollection.sol</code>，它从<code class="fe lm ln lo lp b">Dog.sol</code>的状态变量中收集Dog类型的智能契约。为了使本文简单，在contracts文件夹中创建这两个文件，并复制源代码。</p><figure class="mo mp mq mr gt is"><div class="bz fp l di"><div class="nc nd l"/></div><figcaption class="ne nf gj gh gi ng nh bd b be z dk translated">狗集合. sol</figcaption></figure><figure class="mo mp mq mr gt is"><div class="bz fp l di"><div class="nc nd l"/></div><figcaption class="ne nf gj gh gi ng nh bd b be z dk translated">狗狗. sol</figcaption></figure><h1 id="e49d" class="lq lr jb bd ls lt lu lv lw lx ly lz ma kh mb ki mc kk md kl me kn mf ko mg mh bi translated">编译智能合同</h1><p id="1830" class="pw-post-body-paragraph kq kr jb ks b kt mi kc kv kw mj kf ky kz mk lb lc ld ml lf lg lh mm lj lk ll ij bi translated">现在有趣的部分可以开始了！在项目文件夹的根目录下创建一个名为<code class="fe lm ln lo lp b">compile.js</code>的JavaScript文件。这个文件将包含所有的代码，你将需要编译我们的Solidity智能合同。我会解释每一步。</p><figure class="mo mp mq mr gt is"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="3c76" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在文件的顶部，导入先前安装的node_modules。接下来的几个代码片段将由不同的函数组成，在文件的最后，这些函数将用于创建编译我们的智能合同的工作流。</p><figure class="mo mp mq mr gt is"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="9655" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在编译之前，需要定义一个构建路径，并删除旧的编译源代码。</p><figure class="mo mp mq mr gt is"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="13c2" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">要使用<code class="fe lm ln lo lp b">solc</code>编译器，需要一个配置对象。该对象包含应该编译的每个智能协定的名称和来源。我们只关心入口点，而不关心Solidity文件内部的<code class="fe lm ln lo lp b">import</code>语句中使用的入口点，Solidity文件将在后面处理。编译器特别需要被告知为我们编译<code class="fe lm ln lo lp b">DogCollection.sol</code>，而不是<code class="fe lm ln lo lp b">Dog.sol</code>，因为它只被导入到<code class="fe lm ln lo lp b">DogCollection.sol</code>中。您可以为想要编译的每个智能协定重复此步骤。</p><figure class="mo mp mq mr gt is"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="4d66" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">GetImports处理智能合约的导入。<code class="fe lm ln lo lp b">DogCollection.sol</code>导入<code class="fe lm ln lo lp b">Dog.sol</code>，因此我们必须将<code class="fe lm ln lo lp b">Dog.sol</code>声明为依赖项。</p><figure class="mo mp mq mr gt is"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="60f6" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">最后，可以添加编译智能合同的方法。为编译器方法提供作为回调的<code class="fe lm ln lo lp b">getImports</code>函数，以搜索在<code class="fe lm ln lo lp b">import</code>语句中声明的智能契约。在这个例子中，<code class="fe lm ln lo lp b">DogCollection.sol</code>导入了<code class="fe lm ln lo lp b">Dog.sol</code>。将编译方法包装在一个<code class="fe lm ln lo lp b">try — catch</code>中，以防出错。编译成功后，将返回一个包含编译后的源代码和潜在错误的对象。</p><figure class="mo mp mq mr gt is"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="1a52" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">如上一段所述，包含已编译的智能合约的对象也包含潜在的错误。幸运的是<code class="fe lm ln lo lp b">solc</code>已经对错误信息进行了格式化，以便于阅读。</p><figure class="mo mp mq mr gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ni"><img src="../Images/33a25c87c81afaa7b0b1d93716ca8af4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0dEZMUV5EtvIEZev4CDaLQ.png"/></div></div><figcaption class="ne nf gj gh gi ng nh bd b be z dk translated">错误输出示例。</figcaption></figure><figure class="mo mp mq mr gt is"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="8ba5" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">编译并处理潜在错误后，再次创建<code class="fe lm ln lo lp b">build</code>文件夹。编译后的源代码包含<code class="fe lm ln lo lp b">abi</code>、<code class="fe lm ln lo lp b">bytecode</code>等，在循环每个编译后的契约后，作为JSON文件写入构建文件夹。</p><figure class="mo mp mq mr gt is"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="6bfb" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">最后在<code class="fe lm ln lo lp b">compile.js</code>底部将以上创建的功能组合成一个工作流。</p><p id="5eec" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">对文件夹结构进行快速比较。编译后，它应该看起来像这样:</p><figure class="mo mp mq mr gt is gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/eb647e9f246ab6027bf0b1fcacaedfb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1216/format:webp/1*9oXDoYnyizDfunIDXTTolA.png"/></div></figure><h1 id="b7fc" class="lq lr jb bd ls lt lu lv lw lx ly lz ma kh mb ki mc kk md kl me kn mf ko mg mh bi translated">让它做这件事！</h1><p id="5776" class="pw-post-body-paragraph kq kr jb ks b kt mi kc kv kw mj kf ky kz mk lb lc ld ml lf lg lh mm lj lk ll ij bi translated">让你自己编写的编译程序来一次旋转。在项目文件夹中，在终端中键入以下内容:</p><pre class="mo mp mq mr gt ms lp mt mu aw mv bi"><span id="fefa" class="mw lr jb lp b gy mx my l mz na">node compile</span></pre><p id="c8b4" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">结果应该是这样的:</p><figure class="mo mp mq mr gt is gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/4dce0b074af24556ffdb908ce95a8e55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1128/format:webp/1*oTxRfp9M5MBaHneePhFJ4Q.png"/></div></figure><h1 id="b718" class="lq lr jb bd ls lt lu lv lw lx ly lz ma kh mb ki mc kk md kl me kn mf ko mg mh bi translated">Compile.js:完整源代码</h1><p id="1d9b" class="pw-post-body-paragraph kq kr jb ks b kt mi kc kv kw mj kf ky kz mk lb lc ld ml lf lg lh mm lj lk ll ij bi translated">对于只想复制粘贴完整源码的:<a class="ae mn" href="https://github.com/DodoTheDeveloper/solc-js-compile-0.5.2-0.5.x" rel="noopener ugc nofollow" target="_blank">https://github . com/DodoTheDeveloper/solc-js-compile-0 . 5 . 2-0.5 . x</a></p><figure class="mo mp mq mr gt is"><div class="bz fp l di"><div class="nc nd l"/></div></figure><h1 id="38f9" class="lq lr jb bd ls lt lu lv lw lx ly lz ma kh mb ki mc kk md kl me kn mf ko mg mh bi translated">结论</h1><p id="8700" class="pw-post-body-paragraph kq kr jb ks b kt mi kc kv kw mj kf ky kz mk lb lc ld ml lf lg lh mm lj lk ll ij bi translated">现在你知道如何借助Node.js和<code class="fe lm ln lo lp b">solc-js</code>在本地编译智能合约了。通过分而治之，你把一个相当复杂的主题分解成小的、更容易理解的部分，当结合起来的时候，给了我们一个为以太坊平台开发的强大工具。</p></div><div class="ab cl nl nm hu nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ij ik il im in"><figure class="mo mp mq mr gt is gh gi paragraph-image"><a href="https://levelup.gitconnected.com"><div class="gh gi ns"><img src="../Images/9914c5dd23ac08b70eea6f4f9ba6fed2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E6CoI_MRyZ1JInNPsBSHtA.png"/></div></a></figure><div class="ip iq gp gr ir nt"><a href="https://gitconnected.com/learn/solidity" rel="noopener  ugc nofollow" target="_blank"><div class="nu ab fo"><div class="nv ab nw cl cj nx"><h2 class="bd jc gy z fp ny fr fs nz fu fw ja bi translated">学习坚固性-最佳坚固性教程(2019) | gitconnected</h2><div class="oa l"><h3 class="bd b gy z fp ny fr fs nz fu fw dk translated">14大坚实教程-免费学习坚实。课程由开发人员提交和投票，使您能够…</h3></div><div class="ob l"><p class="bd b dl z fp ny fr fs nz fu fw dk translated">gitconnected.com</p></div></div><div class="oc l"><div class="od l oe of og oc oh ix nt"/></div></div></a></div><div class="ip iq gp gr ir nt"><a href="https://gitconnected.com/learn/javascript" rel="noopener  ugc nofollow" target="_blank"><div class="nu ab fo"><div class="nv ab nw cl cj nx"><h2 class="bd jc gy z fp ny fr fs nz fu fw ja bi translated">学习JavaScript -最佳JavaScript教程(2019) | gitconnected</h2><div class="oa l"><h3 class="bd b gy z fp ny fr fs nz fu fw dk translated">前65名JavaScript教程-免费学习JavaScript。课程由开发人员提交并投票，从而实现…</h3></div><div class="ob l"><p class="bd b dl z fp ny fr fs nz fu fw dk translated">gitconnected.com</p></div></div><div class="oc l"><div class="oi l oe of og oc oh ix nt"/></div></div></a></div></div></div>    
</body>
</html>