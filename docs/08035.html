<html>
<head>
<title>OOP and D&amp;D: Abstraction and Abstract Classes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向对象程序设计和D&amp;D:抽象和抽象类</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/oop-and-d-d-abstraction-and-abstract-classes-70e7336a8faf?source=collection_archive---------14-----------------------#2021-03-29">https://levelup.gitconnected.com/oop-and-d-d-abstraction-and-abstract-classes-70e7336a8faf?source=collection_archive---------14-----------------------#2021-03-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2478" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">用D&amp;D理解OOP的四大支柱，第二部分</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/ddf77149440477a2e86afb54991bb21f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4KkI25OBBscAO7gZWWQ-kA.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">图片来源:<a class="ae kv" href="https://roguewatson.files.wordpress.com/2018/09/tomb-of-annihilation-session-2-aremag.jpg" rel="noopener ugc nofollow" target="_blank">RogueWatson.files.WordPress.com</a></figcaption></figure><p id="d35b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上次，我们详细讨论了面向对象编程中的继承原则。继承是OOP语言中的一个特性，它允许父类/超类将属性、数据和方法传递给它们的子类/子类。这样做的一个主要好处是，开发人员可以减少冗余代码，因为他们不需要在许多具有层次关系(父子关系)的类中反复显式地编程一个方法，因为子类已经继承了这些方法，并且可以隐式地传递它们。</p><p id="1e00" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">继承还允许方法重写，即子类与其父类共享一个方法，但实现方法不同。请考虑以下情况:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/5fc75b0b835c35284d25dea713f1d01b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1222/format:webp/1*ST79wcNOXfABSxI_fNbWJw.png"/></div></figure><p id="bdc4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如您所见，由于继承，<code class="fe lt lu lv lw b">Fox</code>对象可以隐式地访问其父类的<code class="fe lt lu lv lw b">speak()</code>方法。然而，狐狸不会发出“普通的动物声音”。正如伊尔维斯曾经问过的:狐狸说了什么？</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi lx"><img src="../Images/9a9c2a89af48c1f519a49cd4310c6ddc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1216/format:webp/1*R9FoceqWF7ky_EgP2JoZ4A.png"/></div></figure><p id="381c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe lt lu lv lw b">Fox</code>类仍然是<code class="fe lt lu lv lw b">Animal</code>类的子类，并继承了<code class="fe lt lu lv lw b">speak()</code>方法。然而，<code class="fe lt lu lv lw b">Fox</code>类可以为该方法提供自己的实现，覆盖它，这样它返回的东西更适合子类。这种能力打开了多态性的闸门，我们将在下周进一步讨论。现在只需要知道继承在OOP语言中是一个非常重要和强大的特性。</p><p id="14b8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">今天，我们关注OOP的另一个支柱:抽象。</p><h1 id="b735" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">什么是抽象？</h1><p id="fb1e" class="pw-post-body-paragraph kw kx iq ky b kz mq jr lb lc mr ju le lf ms lh li lj mt ll lm ln mu lp lq lr ij bi translated">抽象只是向用户展示他们需要的信息，而不是让这些信息工作的底层代码。上一次我提到过，这类似于打开汽车的过程。一般的司机只会说你只需要“转动钥匙”或者“按下按钮”就可以了。然而，任何一个齿轮头都会告诉你，这些只是过程中发生的一小部分。但是一般的司机真的需要知道整个过程才能发动他们的车吗？没有。</p><p id="29a7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">OOP也是一样。开发人员可以创建充满复杂方法和代码的包，但用户不需要知道或看到所有这些。他们只需要知道如何使用它。</p><h1 id="d5e0" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">抽象和抽象类有关系吗？</h1><p id="b784" class="pw-post-body-paragraph kw kx iq ky b kz mq jr lb lc mr ju le lf ms lh li lj mt ll lm ln mu lp lq lr ij bi translated">没有。</p><h2 id="b415" class="mv lz iq bd ma mw mx dn me my mz dp mi lf na nb mk lj nc nd mm ln ne nf mo ng bi translated">那么我们为什么要讨论抽象类呢？？</h2><p id="92f0" class="pw-post-body-paragraph kw kx iq ky b kz mq jr lb lc mr ju le lf ms lh li lj mt ll lm ln mu lp lq lr ij bi translated">三个原因！</p><ol class=""><li id="e6e5" class="nh ni iq ky b kz la lc ld lf nj lj nk ln nl lr nm nn no np bi translated">抽象是一个非常容易理解的概念，不需要很长时间来解释。如果您曾经导入过Pandas并执行过类似于<code class="fe lt lu lv lw b">pd.DataFrame.isna().sum().sum()</code>(用于查找数据帧中NaN值的总数)的方法，您就会体验到抽象的好处。挺棒的！</li><li id="90cc" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">如果你像我一样，疯狂地学习抽象、抽象类、接口等概念，以至于几乎不记得那个周末发生的任何事情，你也可能有突触失灵，认为这两者之间有联系。</li><li id="538e" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">当我在D&amp;D机制中实现OOP时，我需要为自己的判断失误赎罪。</li></ol><p id="547e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可能还记得上一次，我强调了掷骰子是D&amp;D中最重要的行为。然后我们创建了一个名为<code class="fe lt lu lv lw b">DiceSet</code>的类，它创建了一组骰子，并有一个名为<code class="fe lt lu lv lw b">ability_check</code>的方法。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/f2fd48a9cfaf38a3db17ac5beed77a00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1218/format:webp/0*-T_3L_LtxWKLtmPH.png"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/0a4cd817474b81941b26cc29f50ceeac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1222/format:webp/0*mRhmti3w-0Xy2chW.png"/></div></figure><p id="e84f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后我声明了<code class="fe lt lu lv lw b">ability_check</code>是D &amp; D(玩家角色、怪物、非玩家角色)中所有众生共有的行为。这就是为什么我选择让我们的下一个班级<code class="fe lt lu lv lw b">Sentient</code>成为<code class="fe lt lu lv lw b">DiceSet</code>的孩子。这样,<code class="fe lt lu lv lw b">Sentient</code>类将继承<code class="fe lt lu lv lw b">ability_check</code>方法。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/add01696a8c1a2393116f5c44b195b84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1214/format:webp/0*6KLXz3nWzvBL9HAA.png"/></div></figure><p id="4bf0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不过，这个逻辑有一个问题，我提到过。OOP的要点是用代码表示真实世界的对象(或者在D&amp;D的例子中是虚构的对象)。这意味着父子类这样的层次关系应该是有意义的。然而，<code class="fe lt lu lv lw b">Sentient</code>对象不是<code class="fe lt lu lv lw b">DiceSet</code>。那么是哪里出了问题呢？我太专注于游戏机制和继承，以至于没有考虑对象之间的关系。</p><p id="90ab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这一点上，我不得不再次向弗洛里安·萨利霍维奇喊一声。不仅让我注意到这个问题，还因为他的<a class="ae kv" href="https://tigerarcades.medium.com/object-oriented-dungeons-dragon-ccc54e2586ff" rel="noopener">优秀文章</a>，他用自己的方法解决了这个问题。我强烈推荐阅读这本书，因为他出色地展示了对象和类的关系应该如何决定你的设计选择。这表现在他如何将游戏机制和角色/NPC(在他的文章中称为<code class="fe lt lu lv lw b">Agents</code>)视为两个独立的实体。这太有道理了！游戏机制类似于物理定律；它们定义了什么是可能的，什么是不可能的，所有的物理实体都服从于它们。玩家不是规则(父子关系)，他们也没有规则(这是复合，你在类中创建一个引用另一个对象的实例)。所以，我再次强烈推荐阅读他的文章“<a class="ae kv" href="https://tigerarcades.medium.com/object-oriented-dungeons-dragon-ccc54e2586ff" rel="noopener">面向对象的地下城&amp;龙</a>”。</p><p id="37ff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以现在我们知道我做错了什么，让我们来弥补吧！我们需要做的第一件事是删除对<code class="fe lt lu lv lw b">DiceSet</code>类的引用。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/4ba9eef31ad2179e627f2109bdeacad9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1212/format:webp/1*zqb89DCunud2V4HhQjrdbg.png"/></div></figure><p id="c4c9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">很好，我们修好了！现在，您可能会注意到这个类的一些奇怪之处。默认参数全部为空或<code class="fe lt lu lv lw b">None</code>。这是为什么呢？嗯，我们有意将<code class="fe lt lu lv lw b">Sentient</code>职业设计成尽可能通用的，这样我们就可以为玩家、怪物和NPC设计更多的子类。这样，每个子类都可以提供自己的实现。以这种方式设计的类被称为“抽象类”。正式定义是包含一个或多个抽象方法(没有定义实现的方法)的类。它们的目的是为其他类提供一个框架，同时给它们定义适合它们需求的方法的自由。</p><p id="18a3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为我们的<code class="fe lt lu lv lw b">Sentient</code>类很大程度上是一个抽象类(它只是缺少了抽象方法来使它符合正式定义),所以让我们继续把它正式化。我们将添加一个名为<code class="fe lt lu lv lw b">calculate_hit_points</code>的抽象方法，以确保它符合定义，同时使这个类不仅仅是一个数据容器。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi lx"><img src="../Images/255fda7cc03a6a20f99bd24db5d6ba5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1216/format:webp/1*LqTpOqHNAyAbjFv0GhUIow.png"/></div></figure><p id="e5a7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在Python中，要创建一个抽象类或方法，首先需要从<code class="fe lt lu lv lw b">abc</code>包中导入<code class="fe lt lu lv lw b">ABC </code>(抽象基类的首字母缩写)和<code class="fe lt lu lv lw b">abstractmethod</code>。我们用<code class="fe lt lu lv lw b">class Sentient(ABC):</code>声明我们的类是抽象的。要创建一个抽象方法，首先用<code class="fe lt lu lv lw b">@abstractmethod</code>声明它，并命名你的方法，将<code class="fe lt lu lv lw b">self</code>作为参数传入。用<code class="fe lt lu lv lw b">pass</code>将方法留空，以便其他类可以设置自己的实现。</p><p id="9c82" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可能想知道，如果在初始化器中已经列出了一个属性，为什么还有一个计算命中点的方法。好吧，让我们来看看龙龟的条目:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/06948e6dc6fda90f6f23dc450dd952c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1212/format:webp/1*p0q-k9ZUxv1VfsnQoWAj1g.png"/></div></figure><p id="cf43" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意它的生命值是341，还有(22d20 + 110)。这是给地下城主的选择。他们可以选择一个默认的，所有龙龟生命值的中间值341，或者对于一个更多样化的体验，每只龙龟可以有生命值是22个20面骰子的总和加上额外的110生命值。这意味着你可以拥有一只132 (22*(1) + 110)生命值的“矮子”(最小值)，或者一只550 (22*(20) + 110)生命值的特别强壮的龙龟(最大值)。</p><p id="a0cc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们继续制作我们的<code class="fe lt lu lv lw b">Monster</code>类:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/0ec44d034ab3d2018ae8b27cda94a0aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1214/format:webp/1*6c7RmS-9EbdzRkLs1Icbjg.png"/></div></figure><p id="173b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您会注意到<code class="fe lt lu lv lw b">Monster</code>也有一个具体的方法(它提供了一个实现。尽管如此，<code class="fe lt lu lv lw b">Monster</code>仍然是抽象的，因为它没有为<code class="fe lt lu lv lw b">calculate_hit_points</code>方法提供实现。抽象类的子类必须提供所有方法的实现，使它们变得“具体”和可实例化。</p><p id="c2d4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为此，我们来为龙龟们上一堂课。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/a8d04aeac6561258c2a7cf5bc1429336.png" data-original-src="https://miro.medium.com/v2/resize:fit:1214/format:webp/1*RkSBW0LMrY8bTPT2mRzgFQ.png"/></div></figure><blockquote class="nz oa ob"><p id="1570" class="kw kx nx ky b kz la jr lb lc ld ju le oc lg lh li od lk ll lm oe lo lp lq lr ij bi translated">注意:通常，当我们定义<code class="fe lt lu lv lw b">DragonTurtle</code>类时，我会检查并确保每个属性也被填充，因为这些属性在<code class="fe lt lu lv lw b">DragonTurtle</code>对象的所有实例中是共享的。然而，为了节省时间，我跳过了这一步，因为主要焦点是抽象方法的实现。</p></blockquote><p id="805a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在<code class="fe lt lu lv lw b">DragonTurtle</code>已经为<code class="fe lt lu lv lw b">calculate_hit_points</code>方法提供了一个实现，这个类被认为是具体的。我们甚至创造了一个名叫伯莎的<code class="fe lt lu lv lw b">DragonTurtle</code>，她拥有378点生命值。</p><h1 id="2df5" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">为什么这很重要？</h1><p id="b66e" class="pw-post-body-paragraph kw kx iq ky b kz mq jr lb lc mr ju le lf ms lh li lj mt ll lm ln mu lp lq lr ij bi translated">正如类是对象的模板一样，抽象类也是其他类的模板。当你想为一个方法的不同实现提供一个公共接口时，抽象类是个不错的选择。它们用于帮助创建程序的API和插件。</p><p id="7014" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下周加入我们对多态性的讨论吧！</p></div></div>    
</body>
</html>