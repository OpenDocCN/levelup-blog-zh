<html>
<head>
<title>The MutationObserver Web API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">变异观测器Web API</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/the-mutationobserver-web-api-cf469261eb36?source=collection_archive---------10-----------------------#2021-05-11">https://levelup.gitconnected.com/the-mutationobserver-web-api-cf469261eb36?source=collection_archive---------10-----------------------#2021-05-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="dc87" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对MutationObserver Web API的介绍，它提供了监视对文档所做的更改的能力。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/a2e82ba7147a3ba50da648393cbc6a18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uslRrEbuAeXmZvnKzhpPaQ.jpeg"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">来源论坛<a class="ae le" href="https://www.resetera.com/threads/magneto-or-professor-x-who-do-you-side-with-more.291911/" rel="noopener ugc nofollow" target="_blank"> resetera </a></figcaption></figure><p id="5ade" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我最近在<a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver" rel="noopener ugc nofollow" target="_blank"> MutationObserver Web API </a>的帮助下开发了多个跨项目的特性。令我有点惊讶的是，我注意到一些同事从未使用过它，甚至以前从未听说过它。这就是为什么我有了这篇博文的想法。</p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><h1 id="983b" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">介绍</h1><p id="e55c" class="pw-post-body-paragraph jq jr it js b jt mk jv jw jx ml jz ka kb mm kd ke kf mn kh ki kj mo kl km kn im bi translated"><code class="fe mp mq mr ms b"><a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver" rel="noopener ugc nofollow" target="_blank">MutationObserver</a></code>接口提供了观察对<code class="fe mp mq mr ms b"><a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model" rel="noopener ugc nofollow" target="_blank">DOM</a></code>树所做的更改的能力(来源<a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver" rel="noopener ugc nofollow" target="_blank"> MDN Web Docs </a>)。</p><p id="44a4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是一个web特性，在所有浏览器中都有实现(是的，根据<a class="ae le" href="https://caniuse.com/?search=mutationobserver" rel="noopener ugc nofollow" target="_blank">可以使用</a>的说法，甚至是Internet Explorer v11)，它允许我们检测文档和网页的变化。</p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><h1 id="6454" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">换句话说</h1><p id="3788" class="pw-post-body-paragraph jq jr it js b jt mk jv jw jx ml jz ka kb mm kd ke kf mn kh ki kj mo kl km kn im bi translated">我不喜欢《最后一战》这部电影，但是，你还记得罗格注射疫苗来消除她的能力吗？没有任何其他信息，我们仍然不知道治疗是否有效。要解决问题(3)，我们必须试试运气并取得联系，但不知道会有什么结果。另一方面，由于他的心灵转化能力，X教授将能够检测到变异，并知道它是否成功。</p><p id="858f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们的网页遵循同样的想法。</p><p id="9fd6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当我们对DOM (1)进行修改时，比如修改一个标签或者一个属性，不管有没有框架，它都会被浏览器(2)解释和呈现。即使操作真的很快，如果我们查询(3)随后修改所涉及的DOM元素，我们也不能100%确定修改已经被应用了。幸运的是，多亏了<code class="fe mp mq mr ms b">MutationObserver</code>，我们可以检测到这种突变，从而知道它何时以及是否有效地发生了。</p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><h1 id="ab5a" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">走查</h1><p id="b775" class="pw-post-body-paragraph jq jr it js b jt mk jv jw jx ml jz ka kb mm kd ke kf mn kh ki kj mo kl km kn im bi translated">要初始化一个<code class="fe mp mq mr ms b">MutationObserver</code>，你应该调用它的<code class="fe mp mq mr ms b">constructor</code>一个<code class="fe mp mq mr ms b">callback</code>函数，当DOM发生变化时调用这个函数。</p><pre class="kp kq kr ks gt mt ms mu mv aw mw bi"><span id="2bac" class="mx ln it ms b gy my mz l na nb">const observer = new MutationObserver(callback);</span></pre><p id="ddc9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">回调函数获取一个已经应用的单个DOM突变的数组作为参数。</p><p id="2625" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了观察目标节点并开始通过回调接收通知，您可以调用函数<code class="fe mp mq mr ms b">observe()</code>。</p><pre class="kp kq kr ks gt mt ms mu mv aw mw bi"><span id="bb53" class="mx ln it ms b gy my mz l na nb">observer.observe(targetNode, config);</span></pre><p id="ad1d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">作为第二个参数，应该传递一个配置。它定义了我们要观察的突变类型。这些都记录在优秀的<a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver/observe" rel="noopener ugc nofollow" target="_blank"> MDN Web文档</a>中。对于我来说，我经常使用<code class="fe mp mq mr ms b">attributes</code>来观察对<code class="fe mp mq mr ms b">style</code>和<code class="fe mp mq mr ms b">class</code>的修改，或者像前面的例子一样，使用<code class="fe mp mq mr ms b">childlist</code>来观察对一个元素的子元素的修改。</p><p id="c747" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了阻止<code class="fe mp mq mr ms b">MutationObserver</code>接收进一步的通知，除非<code class="fe mp mq mr ms b">observe()</code>再次被调用，应使用函数<code class="fe mp mq mr ms b">disconnect()</code>。只要在实例上调用它，就可以在回调或任何地方调用它。</p><pre class="kp kq kr ks gt mt ms mu mv aw mw bi"><span id="51a1" class="mx ln it ms b gy my mz l na nb">observer.disconnect();</span></pre><p id="e3e4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后但同样重要的是，它公开了一个函数<code class="fe mp mq mr ms b">takeRecords()</code>，可以查询该函数来删除所有未决的通知。</p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><h1 id="2a66" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">具体例子</h1><p id="8be5" class="pw-post-body-paragraph jq jr it js b jt mk jv jw jx ml jz ka kb mm kd ke kf mn kh ki kj mo kl km kn im bi translated">我在对<a class="ae le" href="https://deckdeckgo.com" rel="noopener ugc nofollow" target="_blank"> DeckDeckGo </a>的WYSIWYG内联编辑器进行一些改进，我必须对用户通过输入字段输入的选择应用一种颜色，同时保留范围，以便每次用户输入一种新颜色时，它都会应用到相同的选定文本🤪。</p><p id="feea" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">总结如下:</p><pre class="kp kq kr ks gt mt ms mu mv aw mw bi"><span id="0915" class="mx ln it ms b gy my mz l na nb">class Cmp {<br/>  <br/>  private range = window.getSelection()?.getRangeAt(0);<br/>  <br/>  applyColor() {<br/>    const selection = window.getSelection();<br/>    <br/>    selection?.removeAllRanges();<br/>    selection?.addRange(this.range);<br/>    <br/>    const color = document.querySelector('input').value;<br/>    <br/>    document.execCommand('foreColor', false, color);<br/>    <br/>    this.range = selection?.getRangeAt(0);<br/>  }<br/>}</span></pre><p id="a49a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它应该工作了吧？嗯，不，它没有或至少没有完全😉。</p><p id="1f20" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">事实上，获得并应用颜色到选区确实如预期的那样工作了，但是，后来我无法保存范围，<code class="fe mp mq mr ms b">this.range</code>没有像我预期的那样被重新分配。</p><p id="2e8e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">幸运的是，我能够用<code class="fe mp mq mr ms b">MutationObserver</code>解决这个问题。</p><pre class="kp kq kr ks gt mt ms mu mv aw mw bi"><span id="716d" class="mx ln it ms b gy my mz l na nb">class Cmp {<br/>  <br/>  private range = window.getSelection()?.getRangeAt(0);<br/>  <br/>  applyColor() {<br/>    const selection = window.getSelection();<br/>    <br/>    selection?.removeAllRanges();<br/>    selection?.addRange(this.range);<br/>    <br/>    const color = document.querySelector('input').value;</span><span id="0a6f" class="mx ln it ms b gy nc mz l na nb">    // A. Create an observer<br/>    const observer = new MutationObserver(_mutations =&gt; {<br/>        // D. Disconnect it when triggered as I only needed it once<br/>        observer.disconnect();<br/><br/>        // E. Save the range as previously implemented<br/>        this.range = selection?.getRangeAt(0);<br/>    });<br/><br/>    // B. Get the DOM element to observe<br/>    const anchorNode = selection?.anchorNode;<br/><br/>    // C. Observe 👀<br/>    observer.observe(anchorNode, {childList: true});<br/>    <br/>    document.execCommand('foreColor', false, color);<br/>  }<br/>}</span></pre><p id="6d02" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，我创建了一个新的<code class="fe mp mq mr ms b">MutationObserver</code>。我定义了必须观察哪个节点元素(在我的例子中是父元素)( B ),并配置了观察器(C ),以便在DOM发生变化时通过其回调函数接收通知。在回调中，我首先断开(d)它，因为只有一个事件对我的用例感兴趣，最后(e)能够像预期的那样保存范围🥳.</p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><h1 id="374e" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">更进一步</h1><p id="5f78" class="pw-post-body-paragraph jq jr it js b jt mk jv jw jx ml jz ka kb mm kd ke kf mn kh ki kj mo kl km kn im bi translated">如果你喜欢这个关于<code class="fe mp mq mr ms b">MutationObserver</code>的介绍，我可以建议你更进一步，去看看<a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver" rel="noopener ugc nofollow" target="_blank">尺寸观测器</a>和<a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserver" rel="noopener ugc nofollow" target="_blank">交叉观测器</a>。</p><p id="e777" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，第一个可以用于检测可编辑字段大小的变化，第二个用于延迟加载内容。</p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><h1 id="0789" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">摘要</h1><p id="b55a" class="pw-post-body-paragraph jq jr it js b jt mk jv jw jx ml jz ka kb mm kd ke kf mn kh ki kj mo kl km kn im bi translated">您可能不会每天都使用观察器，但是在检测应用于DOM的更改时，它们非常有用。此外，用这些来开发特性也很有趣🤙。</p><p id="6277" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">到无限和更远的地方！</p><p id="36bb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">大卫</p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><p id="2e73" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你可以通过<a class="ae le" href="https://twitter.com/daviddalbusco" rel="noopener ugc nofollow" target="_blank"> Twitter </a>或我的<a class="ae le" href="https://daviddalbusco.com/" rel="noopener ugc nofollow" target="_blank">网站</a>联系我。</p><p id="7580" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">尝试使用<a class="ae le" href="https://deckdeckgo.com/" rel="noopener ugc nofollow" target="_blank"> DeckDeckGo </a>制作您的下一张幻灯片。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><a href="https://deckdeckgo.com"><div class="gh gi nd"><img src="../Images/c10750c018f0c5d1ca890b1188fc0b2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*FjFb_wbbMa8RAWhA.png"/></div></a></figure></div></div>    
</body>
</html>