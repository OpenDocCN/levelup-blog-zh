<html>
<head>
<title>Building a Microsoft Teams Bot is Easy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">构建微软团队机器人很容易</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/building-a-microsoft-teams-bot-is-easy-8e39a344c253?source=collection_archive---------4-----------------------#2021-09-05">https://levelup.gitconnected.com/building-a-microsoft-teams-bot-is-easy-8e39a344c253?source=collection_archive---------4-----------------------#2021-09-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="2a33" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">再也看不到电子邮件</em></p><p id="fc80" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">到目前为止，我相信我们都知道电子邮件是一种糟糕的在线交流方式:信息很容易丢失，对话很难整理成线索，客户端软件很容易阻止内容/附件，破坏了你美丽信息的外观。随着最近微软团队的使用和宣布<a class="ae km" href="https://techcrunch.com/2021/06/24/microsoft-teams-will-be-built-directly-into-windows-11/" rel="noopener ugc nofollow" target="_blank">团队将自动安装Windows 11 </a>的所有副本，很多人希望开始以这种方式发送他们所有的消息是有道理的。你自己写的信息可以很容易地转移到团队中，但是大部分的电子邮件——自动发送的邮件呢？“但是怎么会呢？!"我听到你在问——请继续阅读，寻找答案！</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi kn"><img src="../Images/f2ebd2ba0a861890f703c5df466aac0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T5jVLwOLbZkAxMp5v7dOCg.jpeg"/></div></div></figure><h1 id="32ae" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">快速事实(对于像我这样没有耐心的开发人员)</h1><ul class=""><li id="9dff" class="lx ly iq jp b jq lz ju ma jy mb kc mc kg md kk me mf mg mh bi translated"><strong class="jp ir">我们在本文中构建的是:</strong>一种直接向MS Teams用户发送消息的方式——基本上是电子邮件客户端的Teams版本。</li><li id="640a" class="lx ly iq jp b jq mi ju mj jy mk kc ml kg mm kk me mf mg mh bi translated"><strong class="jp ir">技术栈:</strong> C#/.NET5(但是可以用微软的botbuilder库支持的任何语言来完成)&amp; Azure TableStorage(可以随意用你喜欢的任何数据库来替换它)</li><li id="c0cd" class="lx ly iq jp b jq mi ju mj jy mk kc ml kg mm kk me mf mg mh bi translated"><strong class="jp ir">代码示例:</strong> <a class="ae km" href="https://github.com/pyramid-scheme-ceo/MailBot" rel="noopener ugc nofollow" target="_blank"> MailBot </a></li></ul><h1 id="991f" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">“积极主动”？</h1><p id="8520" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mn ka kb kc mo ke kf kg mp ki kj kk ij bi translated">你可以为微软团队开发两种类型的机器人:“对话型”和“主动型”。它们之间没有任何正式的区别(即它们不是使用不同的工具或库构建的)，但是它们被编程为以不同的方式运行。对话机器人位于聊天的一端，并对用户的消息做出响应，而主动机器人能够在没有提示的情况下向用户发送消息。主动机器人的一个主要用例是在发送系统生成的通知时使用团队来代替电子邮件/短信。</p><h1 id="19ee" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">它是如何工作的</h1><p id="dcba" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mn ka kb kc mo ke kf kg mp ki kj kk ij bi translated">对我们来说不幸的是，发送团队消息并不像“这是用户的电子邮件地址，给他们发个消息”那么简单。实际上，它遵循如下所示的有状态过程:</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi mq"><img src="../Images/dbecbab3cbaf7019b6b0c62159cdf18a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1reDxNtcYRfrsSu3t9MhVg.jpeg"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">使用这种循环，我们能够不断地向MS团队中的用户发送主动消息</figcaption></figure><ol class=""><li id="b5e3" class="lx ly iq jp b jq jr ju jv jy mv kc mw kg mx kk my mf mg mh bi translated">用户和我们的机器人第一次“见面”(例如，用户安装了我们的应用程序)。</li><li id="7a00" class="lx ly iq jp b jq mi ju mj jy mk kc ml kg mm kk my mf mg mh bi translated">我们会立即存储用户的详细信息，以便以后向他们发送信息——就像记下一个电话号码一样。</li><li id="c0f3" class="lx ly iq jp b jq mi ju mj jy mk kc ml kg mm kk my mf mg mh bi translated">我们一直等到有理由给用户发送消息…</li><li id="0c80" class="lx ly iq jp b jq mi ju mj jy mk kc ml kg mm kk my mf mg mh bi translated">我们的机器人使用MS Graph创建与用户的对话并发送消息。</li><li id="45be" class="lx ly iq jp b jq mi ju mj jy mk kc ml kg mm kk my mf mg mh bi translated">创建对话后，我们会更新数据库中的用户信息，以便我们可以在将来的消息中重用该对话。</li></ol><p id="8932" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从这里，我们返回并永远重复步骤3-5。简单。😁</p><h1 id="556c" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">公平的警告</h1><p id="c690" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mn ka kb kc mo ke kf kg mp ki kj kk ij bi translated">MS Teams离完美的产品还很远。我是从最终用户的角度来说的，更不用说从像你我这样试图为它构建应用程序的开发者的角度了。我现在已经在两家不同的公司建立了主动机器人，根据我的经验，我发现库不完整，MS Graph权限远远不够细粒度，团队强迫你持有一些自己的数据(显然微软没有足够的自己的数据库空间？)，认证很难集成，如果你想让你的机器人上应用商店，验证是一个绝对的噩梦。</p><p id="7b5b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">听起来很棒，对吧？我们走吧！</p><h1 id="90b7" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">让乐趣开始:设置开发环境</h1><p id="c52b" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mn ka kb kc mo ke kf kg mp ki kj kk ij bi translated">我开始把这一部分写进文章里，只是意识到它应该有自己的一篇文章。所以这就是我开始做的事情——只是意识到这些说明仍然太复杂，无法在另一篇博客文章中写下来。我最终决定记录我自己一步步建立一个基本团队机器人的过程，你可以在下面看到(如果你喜欢，在视频的描述中也有一个书面的清单):</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="mz na l"/></div></figure><h1 id="0341" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">会见用户</h1><p id="f2f8" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mn ka kb kc mo ke kf kg mp ki kj kk ij bi translated">回到我们最初的任务…我们发现自己处于的第一个状态是我们(作为机器人)<em class="kl">第一次遇见</em>一个用户。</p><p id="ab95" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">简而言之，你不能向没有安装你的应用的人发送消息。这是微软非常有意的举动，以确保机器人不能轻易向他们的用户发送垃圾邮件。对我们来说，幸运的是，微软已经实现了一个相当宽松的“会见”用户的定义。我发现实践中发生这种情况的两种主要方式是用户:</p><ul class=""><li id="69b4" class="lx ly iq jp b jq jr ju jv jy mv kc mw kg mx kk me mf mg mh bi translated">安装你的机器人</li><li id="112a" class="lx ly iq jp b jq mi ju mj jy mk kc ml kg mm kk me mf mg mh bi translated">被添加到安装了您的机器人的频道中(或者被安装到用户已经是其成员的频道中的机器人)</li></ul><p id="c331" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里是主动机器人系统最重要的一点:<strong class="jp ir">当我们的机器人第一次遇到用户时，我们必须捕获并存储他们的用户ID </strong>。</p><p id="e23f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">顺便说一下，这不是普通的旧用户ID。这个变量被简单地称为<code class="fe nb nc nd ne b">user.id</code>，这个ID对于你的机器人和那个用户是唯一的。这样，它更像是一个机器人用户ID，如果你想给那个特定的用户发送消息，你<em class="kl">需要</em>它。</p><p id="3f0b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">出于某种神秘/未知的原因，微软决定他们不会把这个非常重要的ID存储在任何我们以后可以再次访问的地方。每次用户与你的机器人交互时，你都会收到它，但实际上这并不经常发生。人们不会在一天内多次添加或删除自己或你的机器人，如果你的机器人的主要目的是发送通知，用户也没有真正的理由发送消息。所以在大多数情况下，我们第一次见到用户时保存这个ID是非常重要的。这一过程如下图所示:</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi mq"><img src="../Images/e044df7fe7b9ef06867bea682bf32b86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FmNmiWwA_f1ZpJaQuA78gw.jpeg"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">如何交朋友</figcaption></figure><ol class=""><li id="5aea" class="lx ly iq jp b jq jr ju jv jy mv kc mw kg mx kk my mf mg mh bi translated">一个用户遇到了我们的机器人——也许他们被添加到一个已经安装了我们的机器人的频道中，或者他们就是安装它的人。</li><li id="d30a" class="lx ly iq jp b jq mi ju mj jy mk kc ml kg mm kk my mf mg mh bi translated">一个事件通知被发送到Azure，它触发一个webhook将事件转发到我们的web应用程序。</li><li id="3569" class="lx ly iq jp b jq mi ju mj jy mk kc ml kg mm kk my mf mg mh bi translated">我们从事件中提取userId，并将其保存在我们自己的数据库中供以后使用。</li></ol><p id="a3e3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面的要点显示了我为完成这三个步骤而添加到我们的bot中的函数。你可以通读一下<code class="fe nb nc nd ne b">TeamsInfoShim</code>和<code class="fe nb nc nd ne b">TeamsUserService</code>的抽象，但是如果你好奇的话，你可以在完整的库<a class="ae km" href="https://github.com/pyramid-scheme-ceo/MailBot/blob/master/MailBot.Domain/BusinessLayer/TeamsInfoShim.cs" rel="noopener ugc nofollow" target="_blank">这里</a>和<a class="ae km" href="https://github.com/pyramid-scheme-ceo/MailBot/blob/master/MailBot.Domain/BusinessLayer/Services/TeamsUserService.cs" rel="noopener ugc nofollow" target="_blank">这里</a>找到这些类。</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="nf na l"/></div></figure><p id="e1c2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以通过安装我们的bot(个人安装或安装到一个渠道)来测试此功能，并确保渠道/对话的所有成员都添加到我们的数据库中。下面你可以看到我自己安装了这个机器人的结果:</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi ng"><img src="../Images/e1b991943d1f4fcf69b3e2aca36428f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZUa7UFrmOol3huQU6ubcww.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">1.我已经被添加为数据库中TeamsUsers表的用户。</figcaption></figure><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi nh"><img src="../Images/9e97e992874680f6afcb84866b815853.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wxcj-oflkud_jPfhI8YyfA.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">2.该机器人向我发送一条消息，表明它已成功安装。</figcaption></figure><h1 id="e336" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">发送第一条消息</h1><p id="0342" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mn ka kb kc mo ke kf kg mp ki kj kk ij bi translated">要发送消息，我们需要创建一个<em class="kl">对话</em>，这需要四个独立的东西(再次感谢微软让这变得简单):</p><ol class=""><li id="d796" class="lx ly iq jp b jq jr ju jv jy mv kc mw kg mx kk my mf mg mh bi translated">机器人用户标识</li><li id="bd25" class="lx ly iq jp b jq mi ju mj jy mk kc ml kg mm kk my mf mg mh bi translated">用户的服务URL</li><li id="8648" class="lx ly iq jp b jq mi ju mj jy mk kc ml kg mm kk my mf mg mh bi translated">用户所属的Azure租户的ID</li><li id="7ebb" class="lx ly iq jp b jq mi ju mj jy mk kc ml kg mm kk my mf mg mh bi translated">机器人的应用程序注册ID</li></ol><p id="664a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">幸运的是，在上一步中，我们在数据库中存储了第1–3项，所以只需再次获取数据以使用它。第4项只是我们配置文件中的<code class="fe nb nc nd ne b">MicrosoftAppId</code>。</p><p id="d0ae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们已经获得了所有需要的信息，向用户发送第一条消息的过程如下所示:</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi mq"><img src="../Images/e403426030ac0cae33d6106b985ed0d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*63wy1-6-SoL42w8IvDkm9g.jpeg"/></div></div></figure><ol class=""><li id="d600" class="lx ly iq jp b jq jr ju jv jy mv kc mw kg mx kk my mf mg mh bi translated">我们的应用程序接收发送消息的原因，例如，用户做了某事或发生了定时事件。不管我们是如何到达这里的，这个事件都需要向我们提供两件事情:我们想要向其发送消息的用户的电子邮件地址和Azure租户的ID，以便在其中发送消息。</li><li id="1ec2" class="lx ly iq jp b jq mi ju mj jy mk kc ml kg mm kk my mf mg mh bi translated">我们的应用程序通过搜索具有匹配的电子邮件地址和Azure租户的记录来获取所需的详细信息(bot-user-ID和服务URL)。</li><li id="f966" class="lx ly iq jp b jq mi ju mj jy mk kc ml kg mm kk my mf mg mh bi translated">然后，我们联系MS Graph，与该用户展开对话。</li><li id="b3d6" class="lx ly iq jp b jq mi ju mj jy mk kc ml kg mm kk my mf mg mh bi translated">Graph创建了一个与目标用户的对话，并返回一个<code class="fe nb nc nd ne b">conversationId</code>,我们将它存储起来供以后的消息使用。</li><li id="ad3d" class="lx ly iq jp b jq mi ju mj jy mk kc ml kg mm kk my mf mg mh bi translated">我们将消息和对话ID一起发送回Graph。</li><li id="0963" class="lx ly iq jp b jq mi ju mj jy mk kc ml kg mm kk my mf mg mh bi translated">我们的用户很高兴在他们的MS团队聊天中收到消息🎉</li></ol><p id="071c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个步骤的完整逻辑包含在<a class="ae km" href="https://github.com/pyramid-scheme-ceo/MailBot/blob/master/MailBot.Domain/BusinessLayer/Services/ConversationService.cs" rel="noopener ugc nofollow" target="_blank">对话服务</a>中，但是重要的部分(创建对话)也包含在下面的要点中:</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="nf na l"/></div></figure><p id="4d72" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你会注意到在完整的存储库中，我添加了<a class="ae km" href="https://github.com/pyramid-scheme-ceo/MailBot/blob/master/MailBot.API/Controllers/TenantMessagesController.cs" rel="noopener ugc nofollow" target="_blank">一个控制器</a>，它调用<code class="fe nb nc nd ne b">ConversationService</code>，这就是我测试这部分流程工作的方式。在确保您的应用程序安装到与您的用户的对话中后，只需打开<a class="ae km" href="https://www.postman.com/" rel="noopener ugc nofollow" target="_blank"> Postman </a>(或任何其他HTTP开发工具)，向应用程序发送POST请求，并观看神奇的事情发生。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi ni"><img src="../Images/87e3f96afbc80700a6375b124ec2dceb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f7hJ4QNjF3-YISGB6X4pxg.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">请求URL和有效负载(左)以及以团队形式发送给我的消息(右)。</figcaption></figure><h1 id="7a58" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">发送更多消息</h1><p id="7a19" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mn ka kb kc mo ke kf kg mp ki kj kk ij bi translated">令人惊讶的是，从这里开始，一切相对顺利。发送更多消息的过程与上面的简单相同，但是没有步骤3和4:</p><ol class=""><li id="3683" class="lx ly iq jp b jq jr ju jv jy mv kc mw kg mx kk my mf mg mh bi translated">我们的应用程序收到一个发送消息的理由(同样，带有用户的电子邮件和租户ID)。</li><li id="eb83" class="lx ly iq jp b jq mi ju mj jy mk kc ml kg mm kk my mf mg mh bi translated">我们的应用程序获取该用户的对话ID。</li><li id="2a28" class="lx ly iq jp b jq mi ju mj jy mk kc ml kg mm kk my mf mg mh bi translated">我们将消息文本和对话ID一起发送给Graph。</li><li id="47d3" class="lx ly iq jp b jq mi ju mj jy mk kc ml kg mm kk my mf mg mh bi translated">用户惊讶地收到了来自我们的另一条消息！</li></ol><p id="818c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我只是在示例存储库中使用了控制器端点，但是您能想到的任何调用<code class="fe nb nc nd ne b">ConversationService</code>的方法都可以😀</p><h1 id="0551" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">后续步骤</h1><p id="719b" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mn ka kb kc mo ke kf kg mp ki kj kk ij bi translated">恭喜你，你再也不用看电子邮件了*！从这里，您可以部署您的。NET应用程序到你平常使用的任何地方(Azure、AWS、VM等)。)只要你的机器人在Azure中的配置指向正确的URL，一切都应该正常工作。</p><p id="8fda" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您想进入下一个级别，您可以遵循验证流程，并将您的应用程序添加到MS Teams应用程序商店。不幸的是，退一步说，我在这个过程中的所有经历都相当艰难，但是如果你有一个很好的理由在app store上获得它，希望事情会进展顺利。</p><p id="0083" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">祝你好运，随时留下你的任何问题/评论！😊</p><p id="1786" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">*没有承诺</p></div></div>    
</body>
</html>