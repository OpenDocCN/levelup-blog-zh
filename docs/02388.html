<html>
<head>
<title>Demystify Builder Pattern in Scala</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">揭开Scala中构建器模式的神秘面纱</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/demystify-builder-pattern-in-scala-3a5f561ab62c?source=collection_archive---------9-----------------------#2020-03-10">https://levelup.gitconnected.com/demystify-builder-pattern-in-scala-3a5f561ab62c?source=collection_archive---------9-----------------------#2020-03-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/55c83efe802c8d6cb32aceba1261839e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1332/0*pEJoVm_4LTNtM8mg"/></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated"><em class="kb">最初发表于</em><a class="ae kc" href="https://edward-huang.com/scala/software-development/programming/2020/03/09/demystify-builder-pattern-in-scala/" rel="noopener ugc nofollow" target="_blank"><em class="kb">https://edward-huang.com</em></a><em class="kb">。</em></figcaption></figure><p id="9a8f" class="pw-post-body-paragraph kd ke it kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la im bi translated">当您需要一步一步地构造一个复杂的对象而又不使构造代码复杂化时，构建器模式解决了这个问题。</p><p id="89c4" class="pw-post-body-paragraph kd ke it kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la im bi translated">想象一下设计一个HTTP处理程序，其中您需要构造一个HTTP客户端，它接收URL、各种头部，以及一个有效载荷主体，这取决于您想要的请求类型。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="cd77" class="lk ll it lg b gy lm ln l lo lp">val postRequestClient = HttpClientRequest(endpoint = "https://someURL.com", method = "POST", header = Map("content-type" -&gt; "application/json"), body = "your json body")<br/><br/><em class="lq">// send your post request<br/></em>HttpClient.send(postRequestClient)</span></pre><p id="6b59" class="pw-post-body-paragraph kd ke it kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la im bi translated">你可以这样设计上面<code class="fe lr ls lt lg b">HttpClient</code>的构造函数:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="b7c6" class="lk ll it lg b gy lm ln l lo lp">class HttpClientRequest(endpoint:String, method:String, header:Map[String, String], body:Option[String])</span></pre><p id="cf70" class="pw-post-body-paragraph kd ke it kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la im bi translated">然后，你还需要考虑没有<code class="fe lr ls lt lg b">requestBody</code>的get方法。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="1036" class="lk ll it lg b gy lm ln l lo lp"><em class="lq">// inside HttpClientRequest class<br/></em><br/><em class="lq">// add another constructor<br/></em>def this(endPoint:String header:Map[String,String]) {<br/>  HttpClientRequest(endpoint, "GET", header, None)<br/>}</span></pre><p id="006e" class="pw-post-body-paragraph kd ke it kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la im bi translated">可以想象，一步一步初始化许多字段和嵌套对象的费力过程。创建这种初始化的代码极其复杂和冗余——有各种构造函数字段的组合。如果新构造函数参数的大小增加，类中构造函数的几种组合也会增加。</p><p id="6455" class="pw-post-body-paragraph kd ke it kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la im bi translated">我们将如何解决这个问题？</p><h1 id="8572" class="lu ll it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">拯救建筑模式</h1><p id="9863" class="pw-post-body-paragraph kd ke it kf b kg mr ki kj kk ms km kn ko mt kq kr ks mu ku kv kw mv ky kz la im bi translated">builder模式建议您将初始化模式从常规构造函数抽象到builder类。</p><p id="85cd" class="pw-post-body-paragraph kd ke it kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la im bi translated"><code class="fe lr ls lt lg b">builder</code>类将这个对象的创建分成一系列步骤。因此，当您想要初始化这个对象时，您需要执行builder对象中的一系列步骤。</p><p id="181e" class="pw-post-body-paragraph kd ke it kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la im bi translated">重要的是，当调用者执行对象创建中的一系列步骤时，他们不需要调用所有的步骤。执行对象所需步骤的必要调用方。</p><p id="b88d" class="pw-post-body-paragraph kd ke it kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la im bi translated">让我们用名为<code class="fe lr ls lt lg b">HttpClientBuilder</code>的构建器类重构上面的<code class="fe lr ls lt lg b">HttpClient</code>例子。</p><p id="9fc3" class="pw-post-body-paragraph kd ke it kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la im bi translated">注意:Scala通过使用带有默认参数和命名参数的不可变<code class="fe lr ls lt lg b">case class</code>为上述问题提供了一个优雅的解决方案。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="2205" class="lk ll it lg b gy lm ln l lo lp">class HttpClientRequest(endpoint:String, method:String, header: Map[String,String], body:Option[String])<br/><br/>object HttpClientRequest {<br/>  def builder(): HttpClientRequestBuilder = HttpClientRequestBuilder("")<br/>}<br/><br/><em class="lq">// creating method case class<br/></em>sealed trait Method<br/>case object GET extends method<br/>case object POST extends method<br/>case object PUT extends method<br/>case object DELETE extends method<br/>case object PATCH extends Method<br/><br/>class HttpClientRequestBuilder(endpoint:String, method:Method = GET, header: Map[String,String] = Map.empty[String,String], body:String = "") {<br/>  def withEndPoint(endpoint:String): HttpClientRequestBuilder = copy(endpoint = endpoint)<br/>  <br/>  def withMethod(method:Method): HttpClientRequestBuilder = copy(method = method)<br/>  <br/>  def withHeader(headers:Map[String,String]): HttpClientRequestBuilder = copy(header = headers)<br/>  <br/>  def withBody(body:String): HttpClientRequestBuilder = copy(body = body)<br/>  <br/>  <br/>  def build: HttpClientRequest = new HttpClientRequest(endpoint, method, header)<br/>}</span></pre><p id="b752" class="pw-post-body-paragraph kd ke it kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la im bi translated">我创建了一个密封的特征，这样它就把调用者限制在这个方法上。</p><p id="350f" class="pw-post-body-paragraph kd ke it kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la im bi translated">Scala <code class="fe lr ls lt lg b">case class</code>已经为您提供了一个内置的方法<code class="fe lr ls lt lg b">copy</code>，该方法使用参数中指定的不同对象创建当前对象到新对象的深层副本。</p><p id="d03c" class="pw-post-body-paragraph kd ke it kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la im bi translated">HttpClientBuilder在初始化<code class="fe lr ls lt lg b">HttpClient</code>时创建一系列步骤。</p><p id="9bee" class="pw-post-body-paragraph kd ke it kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la im bi translated">现在，您可以像这样创建HttpClient方法:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="fe57" class="lk ll it lg b gy lm ln l lo lp">val postClientRequest = HttpClient.builder.withEndPoint("https://someURL.com")<br/>  .withMethod(POST)<br/>  .withHeader(Map("content-type" -&gt; "application/json"))<br/>  .withBody("json body ... ").build<br/><br/>HttpClient.send(postClientRequest)</span></pre><h1 id="f4e5" class="lu ll it bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">外卖食品</h1><p id="5adb" class="pw-post-body-paragraph kd ke it kf b kg mr ki kj kk ms km kn ko mt kq kr ks mu ku kv kw mv ky kz la im bi translated">构建器模式允许您逐步构建一个复杂的对象，这样您就可以通过相同的构建代码创建对象的各种表示。</p><p id="06ad" class="pw-post-body-paragraph kd ke it kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la im bi translated">Builder模式使用builder类将初始化作为一系列要执行的步骤。关于builder类最重要的一点是，调用者能够只提供配置对象所需的必要步骤。</p><p id="535c" class="pw-post-body-paragraph kd ke it kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la im bi translated">Scala提供了一个不可变的case类以及默认实参和命名形参的组合，这与builder模式的目的是一样的。</p><p id="6005" class="pw-post-body-paragraph kd ke it kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la im bi translated"><strong class="kf iu">感谢阅读！如果你喜欢这篇文章，请随意订阅我的时事通讯中的</strong><a class="ae kc" href="https://edward-huang.com/subscribe/" rel="noopener ugc nofollow" target="_blank"><strong class="kf iu"/></a><strong class="kf iu">来接收关于科技职业的每周文章、有趣的链接和内容！</strong></p><p id="3621" class="pw-post-body-paragraph kd ke it kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la im bi translated">你可以关注我，也可以在<a class="ae kc" href="https://medium.com/@edwardgunawan880" rel="noopener">媒体</a>上关注我，以获得更多类似的帖子。</p></div></div>    
</body>
</html>