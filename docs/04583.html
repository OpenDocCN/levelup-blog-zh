<html>
<head>
<title>Do GitHub Action like a Pro!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">像专业人士一样做GitHub动作！</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/do-github-action-like-a-pro-594bcb813b22?source=collection_archive---------3-----------------------#2020-07-04">https://levelup.gitconnected.com/do-github-action-like-a-pro-594bcb813b22?source=collection_archive---------3-----------------------#2020-07-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="aebd" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">最佳CI/CD实践</h2><div class=""/><div class=""><h2 id="e297" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">一组您希望在发布第一个动作之前就知道的最佳开发实践。</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/00af6930af4cdc9f72bcf72b8a20f0d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Tv7l1cHUf5kT1l27"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">Marc Sendra Martorell 在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="492f" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi mb translated"><span class="l mc md me bm mf mg mh mi mj di">我不知道你怎么想，但是软件工程让我感兴趣，因为它能让事情自动化，让我变得懒惰。现在发生的大多数开发从根本上自动化了一个或另一个服务。然而，任何大规模的事情都意味着将会有更多的任务，作为开发人员工作流的一部分，这些任务只有在自动化的情况下才能帮助加速快速开发。</span></p><p id="db1f" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">不，即使听起来有一点相似，我也不想成为DevOps的拥护者，因为这个术语的解释非常多样和广泛。</p><p id="b429" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">现在，当谈到开发工作流时，有相当多的东西可以自动化，而不仅仅是CI/CD服务通常提供的“构建/测试/打包”周期。这就是为什么GitHub Actions是处理它的完美工具——因为你已经在一个地方得到了代码、文档、问题、拉请求、代码审查、发布，甚至<a class="ae le" href="https://github.com/features/packages" rel="noopener ugc nofollow" target="_blank">包</a>！</p><h1 id="be8b" class="mk ml iq bd mm mn mo mp mq mr ms mt mu kf mv kg mw ki mx kj my kl mz km na nb bi translated">TL；博士；医生</h1><p id="4b35" class="pw-post-body-paragraph lf lg iq lh b li nc ka lk ll nd kd ln lo ne lq lr ls nf lu lv lw ng ly lz ma ij bi translated">希望现在我已经说服你至少试一试，并且用一杯咖啡阅读文档，我应该消除一个误解——GitHub动作仍然是代码片段，并且对于曾经编写的每一个代码，它也有自己的一套开发实践要记住。</p><p id="34a6" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">这些构建可重用操作的推荐实践是本文的重点。所以，事不宜迟，让我澄清一下本文的范围:</p><ul class=""><li id="6b15" class="nh ni iq lh b li lj ll lm lo nj ls nk lw nl ma nm nn no np bi translated">为什么发布动作而不是编写bash/python/{ insert scripting language }脚本？</li><li id="c63f" class="nh ni iq lh b li nq ll nr lo ns ls nt lw nu ma nm nn no np bi translated">动作发布的自动化构建和打包。</li><li id="6b38" class="nh ni iq lh b li nq ll nr lo ns ls nt lw nu ma nm nn no np bi translated">按照<a class="ae le" href="https://github.com/actions/toolkit/blob/master/docs/action-versioning.md#versioning" rel="noopener ugc nofollow" target="_blank"> GitHub建议</a>自动对您的操作进行适当的版本控制。</li><li id="6ed7" class="nh ni iq lh b li nq ll nr lo ns ls nt lw nu ma nm nn no np bi translated">写测试！(你真的不认为没有它你就能逃脱吗？:D)</li></ul><h1 id="8705" class="mk ml iq bd mm mn mo mp mq mr ms mt mu kf mv kg mw ki mx kj my kl mz km na nb bi translated">为什么要使用/发布动作</h1><p id="1f13" class="pw-post-body-paragraph lf lg iq lh b li nc ka lk ll nd kd ln lo ne lq lr ls nf lu lv lw ng ly lz ma ij bi translated">自动化工作流程需要对该工作流程的每个单独任务进行编程，这需要另一个单位来维护仪器。即使像安装构建依赖项这样简单的任务也可能会突然失败，需要进行调试。那么，像发送短信提醒或发布新闻稿这样的复杂任务呢？</p><p id="5ae9" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">当然，您的团队可能会自己为这些任务编写一个shell或python脚本，但考虑到长期维护和稳定性，这只是要求额外的工作来拖累开发。</p><p id="633a" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">让我们讨论另一种情况，您的团队确实为一个项目编写并维护了这样一个脚本，但是您发现另一个项目需要用类似的用例来编写一个任务。当然，为了解决这个问题，您可能会将该脚本放在它自己的repo/gist中，并在需要的地方卷曲它。听起来像黑客？是啊，我也有同感:)。</p><p id="efbe" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">幸运的是，GitHub意识到一个简单的CI/CD工作流无法满足它，部分原因是上述问题，并提供了一个<a class="ae le" href="https://github.com/marketplace?type=actions" rel="noopener ugc nofollow" target="_blank"> Marketplace </a>来存储和记录所有这些可重用的程序，称为Actions，它们被用作大多数工作流的构建块。也就是说，工作流的每个作业都有一组步骤，其中每个步骤代表一个单独的任务，并且可以运行命令或这些操作之一。</p><h1 id="7233" class="mk ml iq bd mm mn mo mp mq mr ms mt mu kf mv kg mw ki mx kj my kl mz km na nb bi translated">动作发布的自动化构建和打包。</h1><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nv nw l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">自动化无处不在！:P</figcaption></figure><p id="e478" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi mb translated"><span class="l mc md me bm mf mg mh mi mj di">在</span>首先，我认为这些动作听起来类似于NPM托管的大量JS开发库，特别是因为GitHub runner完全支持Javascript动作。然而，Javascript Actions和NodeJS库有一个主要的区别——<strong class="lh ja"><em class="nx">package . JSON</em>在Actions </strong>的情况下完全没有用。虽然编写npm脚本在开发这些动作时确实很方便，但GitHub Action只需要<em class="nx"> action.yml </em> manifest文件，该文件描述了要运行的动作名称、输入和主JS文件。见鬼，即使是包版本也没关系，因为动作是通过指定提交引用(标记/分支/提交SHA)在工作流中使用的。</p><p id="5224" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">由于这些动作并没有真正打包并存储在一个中央存储库中(不像NPM)，而是直接使用GitHub在一个正在运行的作业中获取所需的动作，所以它们可以非常灵活地<a class="ae le" href="https://docs.github.com/en/actions/creating-actions/about-actions#choosing-a-location-for-your-action" rel="noopener ugc nofollow" target="_blank">存储</a>并在公共和私有存储库中使用。但是，我将只关注将动作存储在它自己的存储库中，简化它的维护、发现和发布管理。</p><p id="792f" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">根据GitHub的建议，我们应该为他们的动作发布使用标签。然而，这里有一个警告——正在运行的作业获取动作源代码，压缩成一个tarball，由该标签指向提交。这意味着带标签的提交应该有一个现成的构建代码，即主JS来运行。但是，在VCS从不提交<a class="ae le" href="https://byjoeybaker.com/why-you-should-never-commit-node-modules-in-nodejs" rel="noopener ugc nofollow" target="_blank"> <em class="nx"> node_modules/ </em> </a>或<a class="ae le" href="https://kentcdodds.com/blog/why-i-dont-commit-generated-files-to-master/" rel="noopener ugc nofollow" target="_blank"><em class="nx">build</em>code</a>不是众所周知的惯例吗？难道我们不先提交<a class="ae le" href="https://www.toptal.com/developers/gitignore/" rel="noopener ugc nofollow" target="_blank"> <em class="nx">。忽略任何新项目的第一步？</em></a></p><p id="9c73" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">为了探索避免提交构建代码的方法，我查看了官方的GitHub操作，如<a class="ae le" href="https://github.com/actions/setup-go" rel="noopener ugc nofollow" target="_blank"> setup-go </a>，但是你会发现他们确实提交了构建代码，<a class="ae le" href="https://github.com/actions/setup-go/blob/master/dist/index.js" rel="noopener ugc nofollow" target="_blank"><em class="nx">dist/index . js</em></a>，尽管通过使用<a class="ae le" href="https://github.com/vercel/ncc" rel="noopener ugc nofollow" target="_blank"> @zeit/ncc </a>构建一个单独的文件来避免提交<em class="nx"> node_modules </em>。不，我不能忍受那个黑客，特别是知道我很可能在提交之前忘记运行<em class="nx"> npm run build </em>(虽然<a class="ae le" href="https://github.com/typicode/husky" rel="noopener ugc nofollow" target="_blank"> husky </a>可以解决这个问题，但是这会使我的提交动作有点慢)。</p><p id="0ec8" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">探索更多的动作，我喜欢在它自己的发布分支中“检入”构建的代码，然后标记它的想法，就像在<a class="ae le" href="https://github.com/engineerd/setup-kind" rel="noopener ugc nofollow" target="_blank">设置类动作</a>中使用的那样(并在<a class="ae le" href="https://github.com/actions/typescript-action#publish-to-a-distribution-branch" rel="noopener ugc nofollow" target="_blank">官方动作模板</a>中记录)。虽然这是一个非常优雅的解决方案，但我也意识到它仍然在我的工作流程中添加了一些手动任务…这是使用Github Actions来自动化它的一个完美理由！</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ny nw l"/></div></figure><p id="4826" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我写了这个工作流程，它可以作为你自己行动发布管理需求的模板。让我首先澄清我的一些假设:</p><ol class=""><li id="1b84" class="nh ni iq lh b li lj ll lm lo nj ls nk lw nl ma nz nn no np bi translated">根据<em class="nx"> package.json </em>对动作进行版本控制。</li><li id="5a36" class="nh ni iq lh b li nq ll nr lo ns ls nt lw nu ma nz nn no np bi translated"><em class="nx">主</em>分支受到保护，任何对其的推送都将有不同的包版本。</li><li id="e0ed" class="nh ni iq lh b li nq ll nr lo ns ls nt lw nu ma nz nn no np bi translated">“构建包”步骤在<em class="nx"> dist/ </em>文件夹中输出构建好的代码，不需要<em class="nx"> node_modules </em>。</li></ol><p id="390b" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">这样，人们也可以为JS动作重用用于版本化节点库的标准技术(如<a class="ae le" href="https://www.npmjs.com/package/semver" rel="noopener ugc nofollow" target="_blank"> semver </a>)。</p><p id="7bcb" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">名为“添加并提交”的步骤强制添加(因为它在<em class="nx">中)。gitignore </em>)在<em class="nx"> dist/ </em>文件夹中构建的代码，提交给它一个新的发布分支，“release/v &lt; version &gt;”并适当地标记它。</p><p id="9043" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">“发布”作业在“构建”作业之后运行，根据前一个作业中使用的标签创建一个新的发布，从而很好地管理打包和发布。</p><p id="dd35" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><strong class="lh ja"> PS: </strong>目前有一个GitHub bug，即由Action创建的发布不能发布到Marketplace，尽管这些标签仍然可以在工作流中使用。</p><h1 id="88aa" class="mk ml iq bd mm mn mo mp mq mr ms mt mu kf mv kg mw ki mx kj my kl mz km na nb bi translated">P 对您的操作进行适当的版本控制</h1><p id="9b17" class="pw-post-body-paragraph lf lg iq lh b li nc ka lk ll nd kd ln lo ne lq lr ls nf lu lv lw ng ly lz ma ij bi translated">大多数开发项目都将语义版本化放在心上，并鼓励开发人员在严格约束和宽松约束之间取得平衡，通常会根据semver选择对补丁发布灵活的约束。</p><p id="e340" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">然而，GitHub建议在<a class="ae le" href="https://github.com/actions/toolkit/blob/master/docs/action-versioning.md#versioning" rel="noopener ugc nofollow" target="_blank">他们的文档</a>中版本化你自己的动作时，要有一个稍微不同的视角:</p><blockquote class="oa ob oc"><p id="2ea5" class="lf lg nx lh b li lj ka lk ll lm kd ln od lp lq lr oe lt lu lv of lx ly lz ma ij bi translated">绑定到主要版本是该主要版本的最新版本(例如，v1 == "1。*" )</p><p id="12b5" class="lf lg nx lh b li lj ka lk ll lm kd ln od lp lq lr oe lt lu lv of lx ly lz ma ij bi translated">主要版本应该保证兼容性。主要版本可以添加新功能，但不应破坏现有的输入兼容性或现有的工作流。</p></blockquote><p id="fb62" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">通过主版本绑定，用户可以期望操作的主版本包括必要的关键修复和安全补丁，同时仍然与他们现有的工作流保持兼容。每当您的更改影响到兼容性时，您应该考虑发布一个新的主版本。</p><p id="839d" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">GitHub建议了一个<a class="ae le" href="https://github.com/actions/toolkit/blob/master/docs/action-versioning.md#recommendations" rel="noopener ugc nofollow" target="_blank">很好的方式</a>来两全其美——语义版本化和主版本绑定。基本上，遵循语义版本化实践，让上面的工作流自己创建一个版本。然后使用git，强制创建一个<a class="ae le" href="http://alblue.bandlem.com/2011/04/git-tip-of-week-tags.html" rel="noopener ugc nofollow" target="_blank">注释标签</a>，使用各自的主要版本，指向发布的标签。</p><pre class="kp kq kr ks gt og oh oi oj aw ok bi"><span id="cb79" class="ol ml iq oh b gy om on l oo op">git tag -fa v1 -m "Update v1 tag"<br/>git push origin v1 --force</span></pre><p id="8a87" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">就像你可能已经猜到的那样，有一种方法可以自动完成这项艰巨的任务，:D！您可以使用<a class="ae le" href="https://github.com/Actions-R-Us/actions-tagger" rel="noopener ugc nofollow" target="_blank"> actions-tagger </a>来自动保持您的主要版本在任何新版本上保持最新。以下是您可以直接使用的模板工作流程:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ny nw l"/></div></figure><h1 id="106e" class="mk ml iq bd mm mn mo mp mq mr ms mt mu kf mv kg mw ki mx kj my kl mz km na nb bi translated">写测试！</h1><blockquote class="oa ob oc"><p id="e891" class="lf lg nx lh b li lj ka lk ll lm kd ln od lp lq lr oe lt lu lv of lx ly lz ma ij bi translated">"所有代码都是有罪的，直到被证明是无辜的."</p></blockquote><p id="6a3c" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我希望您不只是计划为您的操作直接发布未测试的代码？:P <br/>虽然在这一点上它是非常多余的，就像任何其他代码一样，但是你应该致力于编写测试，这样它就不会让一个有效的工作流失败。大多数动作使用<a class="ae le" href="https://www.npmjs.com/package/jest" rel="noopener ugc nofollow" target="_blank"> Jest </a>来满足他们的测试需求，所以我想这就足够了。</p><p id="e1f0" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我有一个建议——确保只有经过测试的代码被合并到master中，否则，您可能会无意中创建了一个没有通过测试的新版本。</p><h1 id="0bf2" class="mk ml iq bd mm mn mo mp mq mr ms mt mu kf mv kg mw ki mx kj my kl mz km na nb bi translated">一些令人兴奋的动作！</h1><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="oq nw l"/></div></figure><h2 id="1909" class="ol ml iq bd mm or os dn mq ot ou dp mu lo ov ow mw ls ox oy my lw oz pa na iw bi translated"><a class="ae le" href="https://github.com/TriPSs/conventional-changelog-action" rel="noopener ugc nofollow" target="_blank">常规变更日志操作</a></h2><p id="2d44" class="pw-post-body-paragraph lf lg iq lh b li nc ka lk ll nd kd ln lo ne lq lr ls nf lu lv lw ng ly lz ma ij bi translated">难以管理大型项目中的所有PRs和版本冲突？不要担心，也有一个行动！假设您的项目遵循<a class="ae le" href="https://www.conventionalcommits.org/en/v1.0.0/" rel="noopener ugc nofollow" target="_blank">常规提交标准</a>，</p><h2 id="77cd" class="ol ml iq bd mm or os dn mq ot ou dp mu lo ov ow mw ls ox oy my lw oz pa na iw bi translated"><a class="ae le" href="https://github.com/machine-learning-apps/actions-chatops" rel="noopener ugc nofollow" target="_blank"> ChatOps动作</a></h2><p id="eeba" class="pw-post-body-paragraph lf lg iq lh b li nc ka lk ll nd kd ln lo ne lq lr ls nf lu lv lw ng ly lz ma ij bi translated">有没有希望有一个机器人跟踪你的回购问题，监听你的命令来触发一些可怕的行动？是的，<a class="ae le" href="https://www.pagerduty.com/blog/what-is-chatops/" rel="noopener ugc nofollow" target="_blank"> ChatOps </a>也入侵了Github Actions！:D</p><h1 id="4726" class="mk ml iq bd mm mn mo mp mq mr ms mt mu kf mv kg mw ki mx kj my kl mz km na nb bi translated">有用的链接</h1><ul class=""><li id="d3ee" class="nh ni iq lh b li nc ll nd lo pb ls pc lw pd ma nm nn no np bi translated"><a class="ae le" href="https://github.com/actions/typescript-action" rel="noopener ugc nofollow" target="_blank">官方JS行动模板</a></li><li id="c636" class="nh ni iq lh b li nq ll nr lo ns ls nt lw nu ma nm nn no np bi translated"><a class="ae le" href="https://docs.github.com/en/actions/creating-actions/creating-a-javascript-action" rel="noopener ugc nofollow" target="_blank">创建一个JS动作</a></li></ul></div><div class="ab cl pe pf hu pg" role="separator"><span class="ph bw bk pi pj pk"/><span class="ph bw bk pi pj pk"/><span class="ph bw bk pi pj"/></div><div class="ij ik il im in"><h1 id="f9bc" class="mk ml iq bd mm mn pl mp mq mr pm mt mu kf pn kg mw ki po kj my kl pp km na nb bi translated">漫无边际的讲话</h1><p id="5f3f" class="pw-post-body-paragraph lf lg iq lh b li nc ka lk ll nd kd ln lo ne lq lr ls nf lu lv lw ng ly lz ma ij bi translated">我开始写我在创建自己的动作时获得的所有知识，<a class="ae le" href="https://github.com/shivanshs9/setup-k8s-operator-sdk" rel="noopener ugc nofollow" target="_blank"> setup-k8s-operator-sdk </a>。我确实搞砸了一些初始版本，所以决定记录一些我希望以前就知道的技巧。谢谢你一直读到最后，我希望听到一些反馈和更多有用的建议！</p></div></div>    
</body>
</html>