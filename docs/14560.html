<html>
<head>
<title>Avoid using switch statements like this in your code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">避免在代码中使用这样的switch语句</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/avoid-using-switch-statements-like-this-in-your-code-b3dedea66d9?source=collection_archive---------6-----------------------#2022-12-07">https://levelup.gitconnected.com/avoid-using-switch-statements-like-this-in-your-code-b3dedea66d9?source=collection_archive---------6-----------------------#2022-12-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/33792e45c2701ca92f9318633b65f0f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*fY7ctb_FE98fk0fz.png"/></div></div></figure><p id="74d0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">切换语句(<strong class="ka ir"> <em class="kw">或if)..else…else if block for the matter</em></strong>)是每个程序员都熟悉的任何编程语言中教授的最基本的概念。在这篇文章中，我们将学习这个简单的概念如何在你的源代码中被误用，导致一个糟糕的代码设计，以及我们如何修复它。我们走吧！！🚶</p><p id="74aa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">考虑一个简单的OOP应用程序，其中我们有一个<code class="fe kx ky kz la b">Employee</code>类。</p><pre class="lb lc ld le gt lf la lg bn lh li bi"><span id="b7b6" class="lj lk iq la b be ll lm l ln lo">class Employee<br/>{<br/>  ...............<br/>  ...........<br/><br/>  function calculateSalary()<br/>  {<br/>    switch(this.type)<br/>    {<br/>      case EMPLOYED    :  return this.totalSalary - 10% of this.totalSalary;<br/>      case FULL_TIME   :  return this.salary;<br/>      case FLEXIBLE    :  return this.working hours * 10;<br/>      default          :  throw new Exception();<br/>    }<br/>  }<br/><br/>  ................<br/>  ........<br/>}</span></pre><p id="2068" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您认为这段代码有什么问题吗？可能不是现在，对吗？</p><p id="c69d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在假设同一个类需要添加另一个函数来计算雇员的税款。</p><pre class="lb lc ld le gt lf la lg bn lh li bi"><span id="6e51" class="lj lk iq la b be ll lm l ln lo">class Employee<br/>{<br/>  ...............<br/>  ...........<br/>  //somewhere in the same Employee class<br/>  function calculateTax()<br/>  {<br/>    switch(this.type) // the same switch statement used here<br/>    {<br/>      case EMPLOYED    :  // return something<br/>      case FULL_TIME   :  // return something else<br/>      case FLEXIBLE    :  // return something else again<br/>      default          :  throw new Exception();<br/>    }<br/>  }<br/><br/>  ................<br/>  ........<br/>}</span></pre><p id="6bd0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个类中如何使用switch语句有几个问题。首先，显而易见的是:<em class="kw">方法中的代码重复</em>使得类变大了(当您必须添加新类型的雇员时，<em class="kw">或者将来会变大)。这个类中有明显的代码重复，因为同一个switch语句在多个方法中被重用。这里明显违反了<strong class="ka ir"><em class="kw">【SRP】</em></strong>。</em></p><p id="ce8d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第二，这个类也违反了<strong class="ka ir"> <em class="kw">开闭原则(OCP) </em> </strong>，因为当你在应用程序中添加新类型的雇员时，你将不得不在两个不同的函数中做同样的改变:在<code class="fe kx ky kz la b">calculateTax</code>和<code class="fe kx ky kz la b">calculateSalary</code>方法中添加一个<code class="fe kx ky kz la b">case-return</code>对。当你需要在你的应用程序中删除一个雇员类型时也是如此，即从两个方法中删除<code class="fe kx ky kz la b">case-return</code>对。甚至不要让我开始思考在类<code class="fe kx ky kz la b">Employee</code>上怎么会有像<code class="fe kx ky kz la b">calculateEligibleLeave</code>和<code class="fe kx ky kz la b">calculateBonus</code>这样的方法可以一次又一次地重用同一个switch语句。😩 😩</p><p id="d244" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">引用罗伯特·马丁在他的名著<a class="ae lp" href="https://www.oreilly.com/library/view/clean-code-a/9780136083238/" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">中的干净代码</strong> </a>:</p><blockquote class="lq lr ls"><p id="3f83" class="jy jz kw ka b kb kc kd ke kf kg kh ki lt kk kl km lu ko kp kq lv ks kt ku kv ij bi translated">我对switch语句的一般规则是，如果它们只出现一次，被用来创建多态对象，并且隐藏在继承关系之后，系统的其他部分看不到它们，那么它们是可以容忍的。</p></blockquote><p id="0ed2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那么，有什么解决办法呢？解决方法就是简单的把switch语句埋在一个<strong class="ka ir"> <em class="kw">抽象工厂</em> </strong>的地下室里。工厂将使用<em class="kw"> switch </em>语句来创建<code class="fe kx ky kz la b">Employee</code>派生的适当实例，各种功能将通过<code class="fe kx ky kz la b">Employee</code>接口进行多态调度。</p><pre class="lb lc ld le gt lf la lg bn lh li bi"><span id="eb71" class="lj lk iq la b be ll lm l ln lo">//a new class that is just responsible to take a employee and return an apropriate instance via its employee type<br/>class EmployeeFactory<br/>{<br/>  public Employee makeEmployee(Employee emp)<br/>  {<br/>    switch(emp.type)<br/>    {<br/>      case EMPLOYED    :  return new EmployedEmployee();<br/>      case FULL_TIME   :  return new FulltimeEmployee();<br/>      case FLEXIBLE    :  return new FlexibleEmploye();<br/>      default          :  throw new Exception();<br/>  }<br/>}</span></pre><p id="3e4b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">看到所有新的职业，像<code class="fe kx ky kz la b">EmployedEmployee</code>和<code class="fe kx ky kz la b">FulltimeEmployee</code>。他们现在要有方法:<code class="fe kx ky kz la b">calculateTax</code>和<code class="fe kx ky kz la b">calculateSalary</code>。</p><pre class="lb lc ld le gt lf la lg bn lh li bi"><span id="aab1" class="lj lk iq la b be ll lm l ln lo">class EmployedEmployee extends Employee<br/>{<br/>  function calculateTax()<br/>  {<br/>    // return something<br/>  }<br/><br/>  function calculateSalary()<br/>  {<br/>    return this.totalSalary - 10% of this.totalSalary;<br/>  }<br/>}</span></pre><p id="c2e5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，在计算任何员工的税或工资时，只需这样做:</p><pre class="lb lc ld le gt lf la lg bn lh li bi"><span id="28c3" class="lj lk iq la b be ll lm l ln lo">//a better solution<br/>class Employee<br/>{<br/>  ...............<br/>  ...........<br/>  function calculateTax()<br/>  {<br/>    return EmployeeFactory.makeEmployee(this).calculateTax();<br/>  }<br/><br/>  function calculateSalary()<br/>  {<br/>    return EmployeeFactory.makeEmployee(this).calculateSalary();<br/>  }<br/><br/>  ................<br/>  ........<br/>}<br/></span></pre><h2 id="abbf" class="lw lk iq bd lx ly lz dn ma mb mc dp md kj me mf mg kn mh mi mj kr mk ml mm mn bi translated">那么这段代码怎么比前面的好呢？</h2><ol class=""><li id="feed" class="mo mp iq ka b kb mq kf mr kj ms kn mt kr mu kv mv mw mx my bi translated">该准则是否仍然违反<em class="kw">单一责任原则</em>？<strong class="ka ir">否</strong>。因为switch语句只负责一件事:返回一个雇员的多态实例，仅此而已。</li><li id="30a1" class="mo mp iq ka b kb mz kf na kj nb kn nc kr nd kv mv mw mx my bi translated">代码是否仍然违反<em class="kw">开闭原则(OCP) </em>？<strong class="ka ir">否</strong>。因为当增加新员工时，我们必须在一个地方做出改变。在哪里？当然是在<code class="fe kx ky kz la b">EmployeeFactory</code>的<code class="fe kx ky kz la b">switch</code>语句里面。如果您的应用程序需要添加新类型的雇员，请在<code class="fe kx ky kz la b">EmployeeFactory</code>的<code class="fe kx ky kz la b">makeEmployee</code>方法中添加新的<code class="fe kx ky kz la b">case: return</code>对。像<code class="fe kx ky kz la b">EmployedEmployee</code>和<code class="fe kx ky kz la b">FullTimeEmployee</code>一样，为新员工类型添加一个新类。就是这样！不需要改变任何现有的类。</li></ol><p id="ed65" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以下次你写一个<code class="fe kx ky kz la b">switch</code>或者<code class="fe kx ky kz la b">if … else … elseif</code>语句的时候，试着想想<em class="kw">相同的switch语句</em>是否会被写在你源代码的另一个地方。如果是这样，你可能要考虑应用<strong class="ka ir">抽象工厂设计模式</strong>。</p><p id="4546" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">感谢您阅读文章并坚持到最后。😃</p></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><p id="fe82" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">参考文献</strong></p><p id="8ddc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">[1]单一责任原则<a class="ae lp" href="https://en.wikipedia.org/wiki/Single-responsibility_principle" rel="noopener ugc nofollow" target="_blank">https://en . Wikipedia . org/wiki/Single-respons ibility _ Principle</a></p><p id="184f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">[2]开闭原理<a class="ae lp" href="https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle</a></p><p id="44ce" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">[3]抽象工厂模式<a class="ae lp" href="https://en.wikipedia.org/wiki/Abstract_factory_pattern" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Abstract_factory_pattern</a></p><p id="e165" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">[4]罗伯特·塞西尔·马丁的《干净的代码》</p></div></div>    
</body>
</html>