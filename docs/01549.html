<html>
<head>
<title>The Sliding Window Strategy for Solving Algorithms</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">求解算法的滑动窗口策略</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/the-sliding-window-strategy-for-solving-algorithms-34c95c80c506?source=collection_archive---------5-----------------------#2020-01-12">https://levelup.gitconnected.com/the-sliding-window-strategy-for-solving-algorithms-34c95c80c506?source=collection_archive---------5-----------------------#2020-01-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="8c39" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你想学习如何解决算法，滑动窗口技术是首先要熟悉的工具之一。<a class="ae kl" rel="noopener ugc nofollow" target="_blank" href="/how-to-solve-an-anagram-algorithm-using-a-frequency-counter-5bb1f0b817ef?source=friends_link&amp;sk=ba35bb0ca601145b6f7e7dc5803eaed3">频率计数器</a>、<a class="ae kl" rel="noopener ugc nofollow" target="_blank" href="/solving-a-palindrome-algorithm-using-recursion-f228ac816bcd?source=friends_link&amp;sk=662a97867a517a187deccf4697f054d2">递归</a>和<a class="ae kl" rel="noopener ugc nofollow" target="_blank" href="/using-the-multiple-pointers-strategy-to-solve-algorithms-b90a98f854db?source=friends_link&amp;sk=269d62783f47e3cc37af28503c9c3a6d">多重指针</a>是其他一些需要尽早掌握的策略。掌握算法的一个重要技能是知道在什么情况下使用哪种技术。上面提到的所有策略都是解决许多不同算法的有用和有效的方法，但是滑动窗口技术对于不同类型的问题是重要的。</p><p id="d699" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个策略包括创建一个窗口，或者一个数组的子集，并根据你写的条件上下移动它。这是跟踪数据的一个小子集的一种有用的方法，当您在数组中移动时，您可以将它与下一个数据子集进行比较。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/4131aae7d0523f8045e1759e79d9ca6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8mXHGeS5kdtejUbHrAbAmQ.jpeg"/></div></div></figure><p id="a16d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我将在本指南中使用的算法称为maxSubarraySum。该算法的目的是找到数组中连续数字的最大可能和。这是一个相当简单的滑动窗口算法的例子。我将在本指南中使用JavaScript。</p><p id="47da" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">和往常一样，我们要做的第一件事是声明一个函数并传入参数。这个函数接受两个参数:一个未排序的正数数组和一个整数，它告诉我们应该检查子数组的长度以得到总和。在这个例子中，我们寻找一个长度为3的子数组。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi ky"><img src="../Images/af06c77c8c6f38b3437330090cd141ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fGFiUn541ee-7keypmb83w.png"/></div></div></figure><p id="c71d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来我们要做的是声明两个变量，一个是临时变量，另一个是保存当前最大总和的变量。我们希望将它们都设置为零，因为算法的参数指定这些数字都是正数。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi ky"><img src="../Images/197359dc9a12e68a6d03d9e066e46c7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iV0FP82Spb4O5ePf1cEZRA.png"/></div></div></figure><p id="48ae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个边缘案例可以马上处理。如果数组的长度比我们应该检查的项数短，我们可以返回null。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi ky"><img src="../Images/877aa0923ab98b734e9e3a2bbb356507.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w-u9OIIW4zAWt5rsTaS0ZA.png"/></div></div></figure><p id="1810" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来我们需要做的是遍历数组，并将这些数字添加到运行总和中。如果我们从零开始<strong class="jp ir"> i </strong>并让它增加到num的长度，我们已经有效地增加了正确长度的子数组的总数。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi ky"><img src="../Images/4e153e7620badb40463a697a98860ce1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W8mpDedZOB71X6MkjAPRLA.png"/></div></div></figure><p id="072d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦我们找到了当前最高的和，我们希望将tempSum和maxSum都设置为等于这个数。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi ky"><img src="../Images/bcb8ca6135fec76d868b977f6fd88e87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cOIXnCGf9Z2lHjhumZzhAA.png"/></div></div></figure><p id="b7bb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在下一个循环中，我们将创建滑动窗口。这一次，我们从第一次循环中已经达到的长度(num)开始迭代<strong class="jp ir"> i </strong>。当我们在整个数组的长度上循环时，我们不断地将tempSum设置为等于一个新的子数组的和，这个新的子数组是通过从前一个子数组中减去第一个数字，然后加上前一个子数组末尾之后的索引中的数字而得到的。每次子阵列向前递增时，我们减去被移出子阵列的那个，加上它前面的那个，从而创建一个滑动窗口。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi kz"><img src="../Images/c2d9ec904419134156fc31ac1bd44763.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ev5gSu4rRjhZTi86JBvblg.png"/></div></div></figure><p id="1f24" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，到目前为止的编写方式是用每次迭代覆盖tempSum。我们永远也不可能知道实际可能的最高金额。我们需要做的是取tempSum和maxSum之间的最大值，并用它来更新maxSum。我们可以通过Math.max()轻松做到这一点。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi kz"><img src="../Images/dcb9fdbd1f3a5c141b80eb628bb1742c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pttR9FYMe0j60KNGtTFMOw.png"/></div></div></figure><p id="11e0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在该循环的每次迭代中，maxSum将与临时变量tempSum进行比较。如果新数字更大，maxSum将被设置为等于更大的数字。在这个循环结束时，maxSum将等于给定长度的任何子数组的最大可能和。我们现在需要做的就是返回maxSum。确保在循环之外执行此操作。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi kz"><img src="../Images/97b50ef8cd5139708df39319675720e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PYgfzisnOTIwiD_WwsymbQ.png"/></div></div></figure><p id="9196" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就是这样！希望这有助于你在将来研究算法时利用滑动窗口策略。</p><p id="b6cb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">阿曼达·特劳特勒</p></div></div>    
</body>
</html>