<html>
<head>
<title>SOLID Principles Illustrated By Examples: 2. Open-Closed Principle(OCP)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">举例说明坚实的原则:2。开闭原则(OCP)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/solid-principles-illustrated-by-examples-2-open-closed-principle-ocp-2122c9d80dd7?source=collection_archive---------10-----------------------#2022-12-06">https://levelup.gitconnected.com/solid-principles-illustrated-by-examples-2-open-closed-principle-ocp-2122c9d80dd7?source=collection_archive---------10-----------------------#2022-12-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="1a97" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">结账单责任原则<a class="ae kl" href="https://medium.com/@manojchemate/solid-principles-illustrated-by-examples-1-single-responsibility-principle-srp-9eeb2849ceec" rel="noopener">这里</a>如果你还没有，</p><p id="d93a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">开合原理:</strong></p><blockquote class="km"><p id="fa05" class="kn ko iq bd kp kq kr ks kt ku kv kk dk translated">模块应该对扩展开放，对修改关闭。</p><p id="f088" class="kn ko iq bd kp kq kr ks kt ku kv kk dk translated">非正式地说，现有的代码不应该因为新的需求而有任何改变。</p></blockquote><p id="17b1" class="pw-post-body-paragraph jn jo iq jp b jq kw js jt ju kx jw jx jy ky ka kb kc kz ke kf kg la ki kj kk ij bi translated">对于任何系统，根据业务需求，总会有更多的变化需要集成到现有的代码库中。如果一个模块不遵循OCP，那么一个模块中的变化可能导致其他模块中的级联故障，为了避免这种情况</p><p id="5abb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以这样一种方式设计你的类、接口和方法，</p><blockquote class="km"><p id="d993" class="kn ko iq bd kp kq kr ks kt ku kv kk dk translated">开放扩展:未来的需求应该通过添加新的类、接口或函数来满足，这些新的类、接口或函数可以扩展或实现现有的类、接口或函数。</p><p id="220f" class="kn ko iq bd kp kq kr ks kt ku kv kk dk translated">对修改关闭:不修改现有的类、接口或函数。</p></blockquote><figure class="lc ld le lf lg lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi lb"><img src="../Images/1593e0d121c474697ab261e0a8dd9f30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*TMdXfFjhz0Zksbc3"/></div></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk translated">照片由<a class="ae kl" href="https://unsplash.com/@timmossholder?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">蒂姆·莫斯霍尔德</a>在<a class="ae kl" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="39e4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">怎么做？</strong></p><blockquote class="km"><p id="cd01" class="kn ko iq bd kp kq kr ks kt ku kv kk dk translated">抽象是关键。</p></blockquote><p id="f50c" class="pw-post-body-paragraph jn jo iq jp b jq kw js jt ju kx jw jx jy ky ka kb kc kz ke kf kg la ki kj kk ij bi translated">首先，让我们看一个违反OCP教的流行例子</p><p id="9a90" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有一个<em class="ls"> ShapeDrawer </em>类可以绘制所有支持的形状类型。</p><figure class="lt lu lv lw gt lh"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="66c8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，在未来，如果我们想要支持三角形形状，我们必须添加一个<em class="ls">三角形</em>类，但是我们需要修改现有的<em class="ls">形状类型</em>枚举和<em class="ls">形状抽屉</em>类的<em class="ls"> drawAllShapes() </em>方法，这违反了OCP原则。<em class="ls"> ShapeDrawer </em>没有关闭进行修改。</p><p id="aa82" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看看如何使用抽象来避免它，</p><figure class="lt lu lv lw gt lh"><div class="bz fp l di"><div class="lx ly l"/></div></figure><ol class=""><li id="e2f8" class="lz ma iq jp b jq jr ju jv jy mb kc mc kg md kk me mf mg mh bi translated">在上面的代码中，为了支持三角形，我们只需要用<em class="ls"> draw() </em>方法添加<em class="ls">三角形</em>类，而不需要修改<em class="ls"> ShapeDrawer </em>类，因此它符合OCP。</li><li id="68e8" class="lz ma iq jp b jq mi ju mj jy mk kc ml kg mm kk me mf mg mh bi translated"><em class="ls">形状</em>界面打开进行扩展，<em class="ls">形状抽屉</em>关闭进行修改绘制新的形状。</li><li id="7ced" class="lz ma iq jp b jq mi ju mj jy mk kc ml kg mm kk me mf mg mh bi translated">这并不意味着它对所有未来的需求都是封闭的，但是如果你能找出系统的动态组件，并对它们进行适当的抽象，那么这个系统将是僵化的。</li></ol><p id="d444" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">OCP，</p><ol class=""><li id="4dad" class="lz ma iq jp b jq jr ju jv jy mb kc mc kg md kk me mf mg mh bi translated">确保未来的变化不会导致意外的副作用。</li><li id="93c2" class="lz ma iq jp b jq mi ju mj jy mk kc ml kg mm kk me mf mg mh bi translated">确保代码的灵活性、可重用性和可维护性。</li></ol><p id="eba1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是我们应该如何使用继承和多态这样的抽象结构来符合OCP呢？有什么原则吗？</p><p id="f6ff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">是的，接下来里斯科夫替代原理有助于它</p><div class="mn mo gp gr mp mq"><a href="https://medium.com/@manojchemate/solid-principles-illustrated-by-examples-3-liskov-substitution-principle-lsp-b182c2848a9c" rel="noopener follow" target="_blank"><div class="mr ab fo"><div class="ms ab mt cl cj mu"><h2 class="bd ir gy z fp mv fr fs mw fu fw ip bi translated">举例说明坚实的原则:3。利斯科夫替代原理</h2><div class="mx l"><h3 class="bd b gy z fp mv fr fs mw fu fw dk translated">通过实例了解利斯科夫替代原理(LSP)！</h3></div><div class="my l"><p class="bd b dl z fp mv fr fs mw fu fw dk translated">medium.com</p></div></div><div class="mz l"><div class="na l nb nc nd mz ne lm mq"/></div></div></a></div></div></div>    
</body>
</html>