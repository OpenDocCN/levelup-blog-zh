<html>
<head>
<title>Performance Optimizations using Redux Reselect</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Redux重选进行性能优化</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/performance-optimizations-using-redux-reselect-ef976dad7a72?source=collection_archive---------4-----------------------#2021-12-16">https://levelup.gitconnected.com/performance-optimizations-using-redux-reselect-ef976dad7a72?source=collection_archive---------4-----------------------#2021-12-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/9aeee8b78c20888543de050545ba3882.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WfaaWAc78NnB7lCpcIwBGA.jpeg"/></div></div></figure><p id="5df8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这篇博客的目的是解释为什么需要npm包<code class="fe kz la lb lc b">reselect</code>来优化React/Redux应用程序的性能。</p><h2 id="3fbd" class="ld le it bd lf lg lh dn li lj lk dp ll km lm ln lo kq lp lq lr ku ls lt lu lv bi translated">假设:</h2><p id="3840" class="pw-post-body-paragraph kb kc it kd b ke lw kg kh ki lx kk kl km ly ko kp kq lz ks kt ku ma kw kx ky im bi translated">您熟悉一般的React和Redux架构。</p><h2 id="19f9" class="ld le it bd lf lg lh dn li lj lk dp ll km lm ln lo kq lp lq lr ku ls lt lu lv bi translated">问题:</h2><p id="40f5" class="pw-post-body-paragraph kb kc it kd b ke lw kg kh ki lx kk kl km ly ko kp kq lz ks kt ku ma kw kx ky im bi translated">假设您有一个用于React组件的mapStateToProps <strong class="kd iu"> (MSTP) </strong>函数。</p><pre class="mb mc md me gt mf lc mg mh aw mi bi"><span id="1043" class="ld le it lc b gy mj mk l ml mm">mapStateToProps = (state, ownProps) = {<br/> const people = state.peopleReducer.people.filter(person =&gt;     ownProps.neededPeople.includes(person))<br/> return { people }<br/>}</span></pre><p id="b7d1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这个MSTP函数中，我们将一组人存储在某个地方的reducer中，任意过滤这些人。乍一看，这个功能似乎还可以。但是，这个函数可能会成为UI性能下降的潜在原因！</p><p id="70e6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">每次Redux中的reducer有更新时，每个挂载的MSTP函数都会运行。如果MSTP函数检测到它返回的值发生了变化，它将触发重新呈现。在上面的例子中，每次MSTP函数触发时，我们执行的过滤函数将创建一个全新的数组对象，从而导致应用程序中不必要的重新呈现。</p><p id="f962" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在想象一下，被过滤的人的数组由数千或数百万个对象组成。这段代码会让你的UI超级慢！那么我们如何解决这个问题呢？</p><h1 id="e420" class="mn le it bd lf mo mp mq li mr ms mt ll mu mv mw lo mx my mz lr na nb nc lu nd bi translated">我们需要创建一个选择器！</h1><p id="1371" class="pw-post-body-paragraph kb kc it kd b ke lw kg kh ki lx kk kl km ly ko kp kq lz ks kt ku ma kw kx ky im bi translated">当我们创建选择器函数时，我们的MSTP中的过滤器逻辑如下所示:</p><pre class="mb mc md me gt mf lc mg mh aw mi bi"><span id="368e" class="ld le it lc b gy mj mk l ml mm">const people = filterPeople(state, ownProps);</span></pre><p id="8962" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在一个名为<code class="fe kz la lb lc b"> peopleSelector.js</code>的文件中，我将编写选择器逻辑，并将它导入到包含低效MSTP函数的组件文件中。</p><p id="c1f3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我们下载了<code class="fe kz la lb lc b">reselect</code>包之后，我们将像这样在我们的选择器文件中导入<code class="fe kz la lb lc b">createSelector</code>。</p><pre class="mb mc md me gt mf lc mg mh aw mi bi"><span id="674a" class="ld le it lc b gy mj mk l ml mm">import { createSelector } from ‘reselect’;</span></pre><p id="a9be" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这将允许我们创建一个函数，它将函数列表作为第一个参数，将另一个函数作为第二个参数。</p><pre class="mb mc md me gt mf lc mg mh aw mi bi"><span id="83c5" class="ld le it lc b gy mj mk l ml mm">const filterPeople = createSelector(<br/> [getPeople, getNeededPeople], (people, neededPeople) =&gt; {<br/> return people.filter(person =&gt; neededPeople.includes(person))<br/> }<br/>)</span></pre><p id="9aa2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">功能列表</strong></p><p id="c5f4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我通常在我打算声明的选择器函数上面声明这些函数。当我们调用函数时，它们将从传递给函数的状态和属性中提取所需的数据。</p><pre class="mb mc md me gt mf lc mg mh aw mi bi"><span id="2da7" class="ld le it lc b gy mj mk l ml mm">const getPeople = (state) =&gt; state.peopleReducer.people;</span><span id="e993" class="ld le it lc b gy ne mk l ml mm">const getNeededPeople = (_, props) =&gt; props.neededPeople;</span></pre><p id="9ece" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">第二个参数是一个函数，它接受我们作为第一个参数传入的函数列表的返回值。</p><p id="c436" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">createSelector函数监视我们传入的第一个函数列表的返回值。假设它们与前面调用MSTP中的选择器函数时返回的值相同。在这种情况下，这个选择器函数将返回一个由第二个参数函数返回的记忆值。</p><p id="0de8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果函数数组中的任何返回值与先前返回的不同，那么第二个参数函数将根据需要重新计算选择器返回值。</p><p id="0a0a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">注意</strong>:我强烈建议你在MSTP函数中有创建新数组或对象(过滤、映射、排序等)的逻辑时，创建一个选择器函数。).</p><p id="e631" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一旦我们声明了这个函数，我们就可以将它导入到需要它的文件中，并在我们的MSTP函数中使用它。</p><pre class="mb mc md me gt mf lc mg mh aw mi bi"><span id="e9fa" class="ld le it lc b gy mj mk l ml mm">mapStateToProps = (state, ownProps) = {<br/> const people = filterPeople(state, ownProps)<br/> return { people }<br/>}</span></pre><p id="26e6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">性能优化万岁！</p><h1 id="25e1" class="mn le it bd lf mo mp mq li mr ms mt ll mu mv mw lo mx my mz lr na nb nc lu nd bi translated">资源:</h1><div class="nf ng gp gr nh ni"><a href="https://github.com/reduxjs/reselect" rel="noopener  ugc nofollow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd iu gy z fp nn fr fs no fu fw is bi translated">GitHub-reduxjs/reseselect:Redux的选择器库</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">一个用于创建记忆“选择器”函数的库。通常与Redux一起使用，但也可用于任何普通的JS不可变…</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">github.com</p></div></div><div class="nr l"><div class="ns l nt nu nv nr nw jz ni"/></div></div></a></div><div class="nf ng gp gr nh ni"><a href="https://redux.js.org/" rel="noopener  ugc nofollow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd iu gy z fp nn fr fs no fu fw is bi translated">redux-JavaScript应用程序的可预测状态容器。|还原</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">JS Apps Redux的可预测状态容器帮助您编写行为一致的应用程序，运行在不同的…</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">redux.js.org</p></div></div><div class="nr l"><div class="nx l nt nu nv nr nw jz ni"/></div></div></a></div></div></div>    
</body>
</html>