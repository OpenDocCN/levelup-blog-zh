<html>
<head>
<title>Mapping it Out</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">规划出来</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/mapping-it-out-71b7939c3a6d?source=collection_archive---------19-----------------------#2020-07-19">https://levelup.gitconnected.com/mapping-it-out-71b7939c3a6d?source=collection_archive---------19-----------------------#2020-07-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5d24" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated"><strong class="ak">地图枚举器如何工作</strong></h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/3bc7c51e980ed39bccbef215a9717baf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0CM8z4ltzNQpV975LTkOuw.png"/></div></div></figure><p id="1175" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">不管你用哪种语言编程，你最终会用到的一个基本函数或方法就是“映射”函数。如果您对“映射”不熟悉，这里有一个JavaScript中的语法示例:</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="cee5" class="ls lt iq lo b gy lu lv l lw lx">const numbers = [2, 4, 6, 8]</span><span id="9338" class="ls lt iq lo b gy ly lv l lw lx">const newNubmers = numbers.map(num =&gt; {<br/>  return num * 2<br/>}</span><span id="b074" class="ls lt iq lo b gy ly lv l lw lx">console.log(newNumbers)<br/>//expected output: [4, 8, 12, 16]</span></pre><p id="d002" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里发生的事情是，我们遍历数组中的每个索引，并对其执行一些操作。在这种情况下，我们将每个数字乘以2。在这篇博文的剩余部分，我将分解“映射”枚举器，它是如何工作的，以及如何从头构建一个。</p><h1 id="9de5" class="lz lt iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">什么是地图枚举器？</h1><p id="37d1" class="pw-post-body-paragraph kr ks iq kt b ku mq jr kw kx mr ju kz la ms lc ld le mt lg lh li mu lk ll lm ij bi translated">映射枚举器是一个在数组上调用的函数，当被调用时，它将遍历该数组，对该数组中的每个实例执行一些操作，并向我们返回一个包含新信息的新数组。</p><p id="8d0d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，要从头开始重新创建地图，我们需要执行几个步骤。首先，我们需要找到一种方法来遍历数组。一旦我们知道了使用什么类型的循环，我们就需要计算出我们的循环将运行多少次。然后，我们需要对数组中的每一项执行一些操作。接下来，一旦操作完成，我们需要将结果添加到一个新数组中。一旦完成，我们必须最终返回新的数组。</p><h2 id="1af2" class="ls lt iq bd ma mv mw dn me mx my dp mi la mz na mk le nb nc mm li nd ne mo nf bi translated">什么是循环？</h2><p id="2298" class="pw-post-body-paragraph kr ks iq kt b ku mq jr kw kx mr ju kz la ms lc ld le mt lg lh li mu lk ll lm ij bi translated">上面我提到了我们如何遍历数组中的每个索引。如果你熟悉编程，那么当你读到这句话时，你的脑海中很可能会出现“循环”这个词。如果你不熟悉，这里有一个简单的解释。在任何编程语言中，循环都是一系列的命令，这些命令将被执行，直到满足某个条件。</p><p id="8225" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在JavaScript中，有几种类型的循环。如<a class="ae ng" href="https://www.w3schools.com/js/js_loop_for.asp" rel="noopener ugc nofollow" target="_blank">w3schools.com</a>所述:</p><ul class=""><li id="bcc0" class="nh ni iq kt b ku kv kx ky la nj le nk li nl lm nm nn no np bi translated"><code class="fe nq nr ns lo b">for</code> -多次循环通过一个代码块</li><li id="f72e" class="nh ni iq kt b ku nt kx nu la nv le nw li nx lm nm nn no np bi translated"><code class="fe nq nr ns lo b">for/in</code> -遍历对象的属性</li><li id="895f" class="nh ni iq kt b ku nt kx nu la nv le nw li nx lm nm nn no np bi translated"><code class="fe nq nr ns lo b">for/of</code> -遍历一个可迭代对象的值</li><li id="9af5" class="nh ni iq kt b ku nt kx nu la nv le nw li nx lm nm nn no np bi translated"><code class="fe nq nr ns lo b">while</code> -当指定的条件为真时，循环通过代码块</li><li id="e002" class="nh ni iq kt b ku nt kx nu la nv le nw li nx lm nm nn no np bi translated"><code class="fe nq nr ns lo b">do/while</code> -当指定的条件为真时，也循环通过一个代码块</li></ul><p id="b0fa" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在我们的例子中，我们将使用“while”循环或“do/while”循环。这样做的原因是，我们将有一个“指定的条件”在这种情况下，我们的数组的长度。这两个循环的主要区别在于，当运行代码时和检查条件时是相反的，因此，即使要满足的条件为假，do/while循环也总是至少运行一次。以下是两者的语法:</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="35c5" class="ls lt iq lo b gy lu lv l lw lx">//while loop</span><span id="2899" class="ls lt iq lo b gy ly lv l lw lx">while (condtion) {<br/>  // code to be executed<br/>}</span><span id="ee7f" class="ls lt iq lo b gy ly lv l lw lx">// do/while loop<br/>do {<br/>  //code to be executed<br/>}<br/>while (condtion)</span></pre><p id="c2db" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因为我们只希望我们的循环在我们的条件开始为真时运行，所以我们将使用“while循环”而不是“do/while”循环</p><h2 id="4c3c" class="ls lt iq bd ma mv mw dn me mx my dp mi la mz na mk le nb nc mm li nd ne mo nf bi translated">我们的情况如何？</h2><p id="0736" class="pw-post-body-paragraph kr ks iq kt b ku mq jr kw kx mr ju kz la ms lc ld le mt lg lh li mu lk ll lm ij bi translated">为了映射数组中的每个索引，我们必须将索引变量与数组的长度属性进行比较。这样，不管数组有多长，只要索引变量小于数组的长度，我们的代码就会运行:</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="7a4c" class="ls lt iq lo b gy lu lv l lw lx">while (i &lt; arr.length){<br/>  //code to be executed<br/>}<br/></span></pre><p id="d0c0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，我们已经选择了一个循环，并找出了我们的条件，我们现在可以创建一个函数，该函数将循环遍历我们的数字数组，并返回每个数字都加倍的数组。</p><h1 id="518f" class="lz lt iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">构建一个函数来映射数组</h1><p id="4a55" class="pw-post-body-paragraph kr ks iq kt b ku mq jr kw kx mr ju kz la ms lc ld le mt lg lh li mu lk ll lm ij bi translated">既然我们已经选择了我们的循环，弄清楚了我们的条件，并且知道了我们将要执行什么代码，那么就把一个函数放在一起，这个函数可以在一个数字数组上被调用，并通过它映射来执行我们的操作。</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="8005" class="ls lt iq lo b gy lu lv l lw lx">const numbers = [2, 4, 6, 8]<br/>const mapMyNumbers = () =&gt;{}</span></pre><p id="aa47" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先，我们将添加一个名为arr的参数，这样这个函数必须通过一个作为参数传递的数组来调用，并且我们可以控制台记录该数组。</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="30b9" class="ls lt iq lo b gy lu lv l lw lx">const numbers = [2, 4, 6, 8]<br/>const mapMyNumbers = (arr) =&gt;{<br/>  console.log(arr)<br/>}</span></pre><p id="ded2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您打开开发工具并运行“mapMyNumbers()”，您应该会看到类似这样的内容:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/1d33ac4c1315471b7cf8854b60aa4c12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1088/format:webp/1*j2t9b-_QCrtNl7yR105Z7Q.png"/></div></figure><p id="ca08" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里我们的console.log是未定义的。如果不传入参数“numbers”，console.log中没有任何内容。现在，如果我们在“mapMyNumbers(numbers)”中传递该参数，我们应该会看到:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/530b54b984e81f51719684e7bf016719.png" data-original-src="https://miro.medium.com/v2/resize:fit:1076/format:webp/1*7o0HHYzxUeiwNPkwoKBydA.png"/></div><figcaption class="oa ob gj gh gi oc od bd b be z dk translated">我们在这里也看到了另一个未定义的，因为我们目前不返回任何东西！</figcaption></figure><p id="2416" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我们已经设置了函数需要的参数，我们可以开始用适当的条件设置循环了。为此，我们将创建一个变量I作为我们的索引占位符，并将其设置为零，从任何数组的开头开始。然后，我们可以设置我们的条件，使其比较“I”和数组的长度。如果“I”小于我们的“数组长度”,我们将在特定索引处控制台记录该数组中的特定项。最后，在循环结束时，我们将变量“I”加1。</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="2863" class="ls lt iq lo b gy lu lv l lw lx">const numbers = [2, 4, 6, 8]<br/>const mapMyNumbers = (arr) =&gt;{<br/>  let i = 0<br/>  while (i &lt; arr.length) {<br/>    console.log(arr[i])<br/>    i++<br/>  }<br/>}</span></pre><p id="1c28" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果我们在控制台中再次调用这个函数，我们将会看到:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/96d94b1616f50b256e87f026e10ec33b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1068/format:webp/1*wsygDhYd5tXR7Pik1HWE2Q.png"/></div></figure><p id="3648" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然而，我们在这里的目标是将我们的项目乘以2(n * 2 ),并快速更改我们可以控制的代码。</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="2ae1" class="ls lt iq lo b gy lu lv l lw lx">const numbers = [2, 4, 6, 8]<br/>const mapMyNumbers = (arr) =&gt;{<br/>  let i = 0<br/>  while (i &lt; arr.length) {<br/>    console.log(arr[i] * 2)<br/>    i++<br/>  }<br/>}</span></pre><p id="9916" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们的结果显示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi of"><img src="../Images/1d9ba6c2167d4bc29d441c16284aa2b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1032/format:webp/1*bRckSnq6hG459pSJoVnIow.png"/></div></figure><p id="3757" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我们有了条件、操作和循环，是时候将这些对象添加到数组中了。为此，我们将在名为“newNumbers”的循环之前初始化一个空数组，然后将运算结果推入新数组，最后我们将添加一个返回语句，该语句将在循环结束后返回newNumbers。</p><pre class="kg kh ki kj gt ln lo lp lq aw lr bi"><span id="6ac4" class="ls lt iq lo b gy lu lv l lw lx">const numbers = [2, 4, 6, 8]<br/>const mapMyNumbers = (arr) =&gt;{<br/>  let i = 0<br/>  let newNumbers = []<br/>  while (i &lt; arr.length) {<br/>    newNumbers.push(arr[i] * 2)<br/>    i++<br/>  }<br/>  return newNumbers<br/>}</span></pre><p id="35e8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一旦我们运行此代码，我们将看到:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi og"><img src="../Images/7ad3c9c780faef5d5d8d210204bf6c54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1036/format:webp/1*EX8FVuQlpC3sdjMbOorQWw.png"/></div></figure><p id="4374" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了确保我们的结果与运行映射函数的结果相同，我们也可以运行映射枚举器:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/96c3cfc17505ef53468102cc0326e61f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1092/format:webp/1*0nYNMqt4QVgeNxpSNvGQhQ.png"/></div></figure><p id="406e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">正如我们所见，我们的结果是一样的！</p><h1 id="1e97" class="lz lt iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">结论</h1><p id="e043" class="pw-post-body-paragraph kr ks iq kt b ku mq jr kw kx mr ju kz la ms lc ld le mt lg lh li mu lk ll lm ij bi translated">至此，我们已经成功地为数组重新创建了映射枚举器。虽然我总是建议使用枚举器来节省代码行，并减少开发人员出现人为错误的机会，但了解一些东西如何工作以及为什么工作总是一个好主意。编码快乐！！！</p></div></div>    
</body>
</html>