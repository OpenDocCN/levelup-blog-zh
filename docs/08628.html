<html>
<head>
<title>Taking control of the control plane</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">控制控制平面</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/taking-control-of-the-control-plane-30189b6706ec?source=collection_archive---------10-----------------------#2021-05-18">https://levelup.gitconnected.com/taking-control-of-the-control-plane-30189b6706ec?source=collection_archive---------10-----------------------#2021-05-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="6432" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<a class="ae kl" rel="noopener ugc nofollow" target="_blank" href="/untangling-the-service-mesh-24797e29eb92">解开服务网</a>和理解<a class="ae kl" href="https://medium.com/nerd-for-tech/etcd-the-easy-way-4c01e243f285" rel="noopener">ETCD——最简单的方式</a>之后，让我们继续本系列的第三篇文章。这一次我们将关注kubernetes集群的一大块，即控制平面。</p><p id="4fd9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">简而言之，控制平面是一组用于规划、管理、调度和监控群集其他元素的组件。它托管在群集的主节点上，从这里它与其余的工作节点进行交互。</p><p id="fdd1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么，组成控制平面的这些组件是什么呢？</p><h1 id="46a9" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">作文</h1><p id="3524" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">一个基本控制平面有4个基本组件— etcd、kibe调度程序、控制器管理器和api服务器。</p><h2 id="ca61" class="lp kn iq bd ko lq lr dn ks ls lt dp kw jy lu lv la kc lw lx le kg ly lz li ma bi translated">ETCD</h2><p id="476f" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">正如在<a class="ae kl" href="https://medium.com/nerd-for-tech/etcd-the-easy-way-4c01e243f285" rel="noopener">上一篇博客</a>中详细解释的那样，etcd是一个分布式键值存储，存储关于集群的所有必要细节。这些数据是维护集群状态所必需的，也是所有<code class="fe mb mc md me b">kubectl get</code>命令的重要来源。</p><p id="b6f0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在etcd中更新资源状态之前，对任何资源执行的所有操作都不会被视为完成。</p><h2 id="4708" class="lp kn iq bd ko lq lr dn ks ls lt dp kw jy lu lv la kc lw lx le kg ly lz li ma bi translated">kube-调度程序</h2><p id="9936" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">顾名思义，kube-scheduler在不同的节点上调度容器。它根据容器对资源(如内存和CPU)的要求、节点托管容器的能力、节点上已经运行的容器数量以及其他一些因素(如节点亲和力、污点和容忍度)来确定每个容器的正确节点。</p><p id="08d9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">调度器首先过滤掉没有足够容量来托管容器的节点。然后，它根据在剩余节点上调度pod后剩余的资源量对剩余节点进行排序。例如，假设有4个节点，CPU容量分别为3、5、10和8。</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/f9c1ca830fb3c80741c2100c60eea85b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1334/format:webp/1*bJ03U8AoSmP7y0wyTHrlYg.png"/></div></figure><p id="5de7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在假设需要调度一个需要6个vCPUs的新容器。显然，蓝色和绿色节点无法处理它，因此被过滤掉了。<br/>为了对剩余节点进行排序，计算调度容器后剩余的资源。这使得粉色节点的值为4 vCPUs，橙色节点的值为2 vCPUs。因此，粉色节点比橙色节点获得更高的等级，如果没有其他策略或规则阻止它，容器将被调度到粉色节点。</p><p id="243c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您使用kubeadm来设置集群，那么kube调度程序已经存在，作为一个pod运行。</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi mn"><img src="../Images/e31f5b920e41a945cbbc50659de3b0e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ieHpUIDDWhGIwyOCYXhVoA.png"/></div></div></figure><p id="8ca3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是如果你正在从头开始建立一个集群，你可以从发布页面下载二进制文件，并使用<a class="ae kl" href="https://kubernetes.io/docs/reference/command-line-tools-reference/kube-scheduler/" rel="noopener ugc nofollow" target="_blank">这些命令</a>解压运行它。或者，您可以编写您的调度程序，它将按照您指定的逻辑进行调度。为此，您必须与绑定API交互，并使用pod的POST调用设置<code class="fe mb mc md me b">nodeName</code>的值。</p><h2 id="dad4" class="lp kn iq bd ko lq lr dn ks ls lt dp kw jy lu lv la kc lw lx le kg ly lz li ma bi translated">控制者-管理者</h2><p id="8963" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">对于维护kubernetes集群所需的几乎所有组件和主要功能，都有一个控制器。</p><blockquote class="ms mt mu"><p id="32b5" class="jn jo mv jp b jq jr js jt ju jv jw jx mw jz ka kb mx kd ke kf my kh ki kj kk ij bi translated">将它们全部命名为— attachdetach、bootstrapsigner、cloud-node-lifecycle、clusterrole-aggregation、cronjob、csrapproving、csrcleaner、csrsigning、daemonset、deployment、disruption、endpointslice、endpointslicemirroring、prosper-volume、garbagecollector、horizontalpodautoscaling、job、namespace、nodeipam、nodelifecycle、persistentvolume-binder、persistentvolume-expander、podgc、pv-protection、pvc-protection、replicaset、replicaset</p></blockquote><p id="74c6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这需要很多控制器，需要有人来管理它们。这是由集群中运行的单个进程完成的。</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi mz"><img src="../Images/fe81a6d5f91c80812e03fff78e28f9c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E2nXF2zH3uhAmVC91f3MIA.png"/></div></div></figure><p id="cb66" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">默认情况下，它管理除bootstrapsigner和tokencleaner控制器之外的所有上述状态控制器，但是如果您手动部署控制器管理器，您可以使用<code class="fe mb mc md me b">--controllers</code>选项选择特定的控制器，如这里的<a class="ae kl" href="https://kubernetes.io/docs/reference/command-line-tools-reference/kube-controller-manager/" rel="noopener ugc nofollow" target="_blank">所述</a>。</p><p id="9f1c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么这么多控制器有什么用呢？<br/>控制器持续监控给定组件的状态，并努力使组件的状态达到所需状态。让我们以其中的几个为例<br/> <strong class="jp ir">节点控制器</strong> —它每5秒检查一次节点的状态(节点监控周期)。如果一个节点没有响应，那么它会等待40秒的宽限期来响应。等待40秒后，如果该节点仍然不可达，则该节点将被标记为不可达。一旦标记为不可访问，节点控制器会再等待5分钟(逐出超时)以使节点恢复。如果它无法恢复，则作为副本集一部分的该节点上托管的pod将被重新调度到其他节点上<br/> <strong class="jp ir">复制控制器</strong> —监控所有副本集中pod的状态。当容器由于不健康或报废的容器而低于最小限度时，复制控制器发出命令来创建新的容器，以便保持容器的期望数量。</p><h2 id="9896" class="lp kn iq bd ko lq lr dn ks ls lt dp kw jy lu lv la kc lw lx le kg ly lz li ma bi translated">kube API-服务器</h2><p id="513b" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">kubernetes集群中所有管理组件之间的通信基于中心辐射模型，kubeapi-server位于其中心。</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi na"><img src="../Images/d274e70f23a543d46e9c2a52bec10956.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kXk7R11_1DapcP-yV33dEQ.png"/></div></div></figure><p id="1205" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">kubeapi服务器以多种方式用于实现不同的功能。外部用户使用它通过像kubectl这样的API包装器与集群进行交互。控制器也用它来监视不同资源的状态。工作节点使用kubelets与主节点通信，这种通信是通过kubeapi-server完成的。</p><blockquote class="ms mt mu"><p id="586c" class="jn jo mv jp b jq jr js jt ju jv jw jx mw jz ka kb mx kd ke kf my kh ki kj kk ij bi translated"><strong class="jp ir">快速事实检查:</strong><br/>kube let——运行在每个工作者节点上的进程，充当与主节点的所有通信的端点。它还负责按照kube-scheduler的指示在节点上创建pod</p></blockquote><p id="e3c6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通常，与kubeapi服务器的所有通信都发生在HTTPS(端口443)上，并且启用了一种或多种形式的身份验证。理想情况下，应该为节点提供集群的公共根证书，以便它们可以使用有效的客户端凭证安全地连接到apiserver。<br/>然而，以下从apiserver到节点、pod和服务的连接是通过普通HTTP进行的。</p><h1 id="79dc" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">设置</h1><p id="6f62" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">设置控制平面是创建kubernetes集群的第一步。要使用<code class="fe mb mc md me b">kubeadm</code>设置控制平面，只需运行</p><pre class="mg mh mi mj gt nb me nc nd aw ne bi"><span id="a80c" class="lp kn iq me b gy nf ng l nh ni">kubeadm init</span></pre><p id="6131" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以选择使用DNS提供商或使用<code class="fe mb mc md me b">--control-plane-endpoint</code>选项的负载平衡器来公开控制平面。当您有多个控制平面节点以实现高可用性和弹性时，可以使用这种设置。要参考定制配置的其他选项，请在此处选择<a class="ae kl" href="https://kubernetes.io/docs/reference/setup-tools/kubeadm/kubeadm-init/" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="1c7c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">完成后，该命令将输出一个<code class="fe mb mc md me b">kubeadm join</code>命令，您应该注意这个命令，因为它将用于将新节点加入集群。</p><p id="1e7d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在你有了，你的控制平面设置好了。</p><h1 id="8731" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">离别赠言</h1><p id="d7cd" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">至此，我们完成了本系列的第三篇博客。希望它能帮助您理解kubernetes集群的概念和另一个组件。下次见！</p></div></div>    
</body>
</html>