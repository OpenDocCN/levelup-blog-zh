<html>
<head>
<title>Learn to NOT program to boost your productivity as a programmer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">作为程序员，学会不编程来提高你的生产力</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/learn-to-not-program-to-boost-your-productivity-as-a-programmer-adaca7ed6539?source=collection_archive---------20-----------------------#2020-04-07">https://levelup.gitconnected.com/learn-to-not-program-to-boost-your-productivity-as-a-programmer-adaca7ed6539?source=collection_archive---------20-----------------------#2020-04-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0f28" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何在简单的CLI工具已经足够的情况下不进行编程——使用合适的工具完成工作。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/05fd730444bde23a76afa03888f9f52e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gLi4eX2j52UW4YLmiFggVw.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">卡斯帕·卡米尔·鲁宾在<a class="ae ky" href="https://unsplash.com/s/photos/programming?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="686c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">程序员不喜欢手工。他们总是倾向于找到最有效的工具来处理临时工作。</p><p id="baa2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当没有适合这项工作的工具时，大多数人会转向为它编写脚本(或程序)。毕竟，我们是程序员。</p><p id="58fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是我的建议是在编写脚本之前考虑使用老式的CLI工具。在处理基于文本的数据文件时尤其如此。在Unix/Linux生态系统中已经有许多内置工具来操作文本，因为Unix有一个传统，即<a class="ae ky" href="https://en.wikipedia.org/wiki/Unix_philosophy" rel="noopener ugc nofollow" target="_blank">比其他数据格式更喜欢文本</a>。</p><p id="e449" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对那些只有MS-Windows背景的程序员的一个建议:认真考虑学习Unix，即使是基础水平，那么一个新的世界将向你打开。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e70f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">一个简单的要求</h1><p id="92bd" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">假设我们从老板那里得到一份工作:</p><ul class=""><li id="49dc" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated">有两个文本文件:A.txt和B.txt .每个文件有1048576行(这是现代MS Office Excel中的行数上限，所以你无法用Excel完成这项工作🤪).</li><li id="8528" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">这些文件中的每一行都是社会安全号码，格式为“AAA-GG-SSSS”</li><li id="b302" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">我们想要的是存在于A.txt中而不存在于B.txt中的SSN(即A-B)。</li><li id="9043" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">然后从上一步的结果集中提取“AAA”部分到一个单独的列中，将每一行转换为“AAA，AAA-GG-SSSS”。</li><li id="9054" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">然后从结果集中删除重复项。</li><li id="b5d4" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated">最后，按降序对结果集进行排序。</li></ul><p id="9426" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">看起来没有单一的工具可以解决这个问题，让我们用我最近最喜欢的编程语言Golang来写吧。</p><h1 id="ea54" class="mc md it bd me mf nn mh mi mj no ml mm jz np ka mo kc nq kd mq kf nr kg ms mt bi translated">与Golang一起完成任务</h1><p id="394a" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">这是一个没有任何惊喜的琐碎脚本。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="8809" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这90行代码不言自明。我们一步一步地解决问题。</p><p id="0494" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们读取文件，计算差异，进行转换，消除重复，对结果进行排序，最后打印输出。</p><p id="3da8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们可以运行它:</p><pre class="kj kk kl km gt nu nv nw nx aw ny bi"><span id="bda2" class="nz md it nv b gy oa ob l oc od">$ go run main.go A.txt B.txt</span></pre><p id="a476" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个脚本简单明了，非常适合这个任务。我的MBP只用了不到五秒钟就处理了数百万行。</p><p id="2a80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">唯一的缺点是对Golang工具链的依赖，因为Golang目前没有预装在大多数机器上。</p><h1 id="8337" class="mc md it bd me mf nn mh mi mj no ml mm jz np ka mo kc nq kd mq kf nr kg ms mt bi translated">用Python重写脚本</h1><p id="63c7" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">至于预装，Python和Golang完全不一样。它存在于几乎所有的Linux/Unix发行版中。就连MacOSX也已经预装了。</p><p id="32ca" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们可以用Python脚本来完成这项工作，那么需要的先决条件就更少了。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="d47f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">感谢Python简洁的语法，我们用不到30行代码就达到了同样的目的。向上运行:</p><pre class="kj kk kl km gt nu nv nw nx aw ny bi"><span id="f1c5" class="nz md it nv b gy oa ob l oc od">python3 diff.py A.txt B.txt</span></pre><p id="3f78" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个脚本的性能大致相当于Golang版本。但是它显然更容易维护，因为它更短。</p><p id="97d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，Python脚本似乎是当前任务的更好解决方案。它适用于世界上大多数非Windows计算机，简单易学，使用起来令人愉快。</p><p id="0465" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有没有更好的解决办法？是的，有。是终极一个。</p><h1 id="a0a5" class="mc md it bd me mf nn mh mi mj no ml mm jz np ka mo kc nq kd mq kf nr kg ms mt bi translated">利用shell命令</h1><p id="9aae" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们可以编写几个Linux/Unix命令行工具来完成这项工作。</p><ul class=""><li id="de39" class="mz na it lb b lc ld lf lg li nb lm nc lq nd lu ne nf ng nh bi translated"><strong class="lb iu"> comm </strong>:选择或拒绝两个文件共有的行。我们使用这个命令来执行“A-B”操作。<code class="fe oe of og nv b">comm</code>要求两个输入文件应该排序。</li><li id="fe70" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated"><strong class="lb iu"> awk </strong>:我们用它来转换结果集的每一行。</li><li id="8686" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated"><strong class="lb iu"> uniq </strong>:删除重复行。</li><li id="5b56" class="mz na it lb b lc ni lf nj li nk lm nl lq nm lu ne nf ng nh bi translated"><strong class="lb iu">排序:</strong>对文本行进行排序。</li></ul><p id="4b60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">放在一起:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="c11f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">打印出结果大约需要20秒钟。</p><pre class="kj kk kl km gt nu nv nw nx aw ny bi"><span id="3c2e" class="nz md it nv b gy oa ob l oc od">sh diff.sh A.txt B.txt</span></pre><p id="f12f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如上所述，命令<code class="fe oe of og nv b">comm</code>要求其输入文件应该被排序。所以我们先对这两个文件进行排序，将结果重定向到临时文件<em class="oh"> sortedA.txt </em>和<em class="oh"> sortedB.txt </em>。在这个脚本的最后，我们删除这两个文件。</p><p id="45ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个脚本的核心是下面的一行:</p><pre class="kj kk kl km gt nu nv nw nx aw ny bi"><span id="8558" class="nz md it nv b gy oa ob l oc od">comm -23 sortedA.txt sortedB.txt|awk -F'-' '{print $1","$0;}'|uniq|sort -r</span></pre><p id="c4d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里有四个命令，用“<code class="fe oe of og nv b">|</code>”(流水线字符)联系。这意味着这些命令像链条一样连接在一起。前一个命令的输出将成为下一个命令的输入。关于这些命令的详细用法，你可以参考他们的手册。</p><p id="d0de" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是这里的要点是，我们成功地将脚本的行数从90减少到了8。</p><p id="aca1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">而且这些命令都是现代*nix (Linux/Unix/MacOSX)电脑内置的。你不必安装任何新的程序来做这些琐碎的工作。</p><p id="7da8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意</strong>:事实上，有一个简单的解决方案。只是把<code class="fe oe of og nv b">comm</code>换成了<code class="fe oe of og nv b">grep</code>:</p><pre class="kj kk kl km gt nu nv nw nx aw ny bi"><span id="f7ab" class="nz md it nv b gy oa ob l oc od">grep -vFf B.txt A.txt|awk -F'-' '{print $1","$0;}'|uniq|sort -r</span></pre><p id="d4da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于在使用<code class="fe oe of og nv b">grep</code>之前不需要对输入文件进行排序，这个解决方案是我能发现的最短最简单的一个。但它有一个不可接受的缺点，那就是比<code class="fe oe of og nv b">comm</code>版本慢得多。我甚至没有耐心去计算要花多少时间才能完成。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9ff7" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="87a5" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">程序员喜欢编程。但是在某些情况下，你应该学会不编程。</p><p id="01cb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">程序员的责任是用正确的工具构建一个合适的解决方案，用最少的资源解决问题。</p><p id="a39f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">编码是我们的工作，但不是全部。</strong></p><p id="0250" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">干杯。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="24d5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另请参见:</p><p id="4675" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">车丹用300行代码在Golang中构建一个终端仪表板</p></div></div>    
</body>
</html>