<html>
<head>
<title>Count Citations in a Word document with Python and Regular Expressions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python和正则表达式计算Word文档中的引用</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/count-citations-in-a-word-document-with-python-and-regular-expressions-d068218c50b9?source=collection_archive---------19-----------------------#2020-04-05">https://levelup.gitconnected.com/count-citations-in-a-word-document-with-python-and-regular-expressions-d068218c50b9?source=collection_archive---------19-----------------------#2020-04-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/d9becc7a5908186b0e57b90ca54f9b6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HVDGHXcsERTfVCOta2qJ7g.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://www.pexels.com/photo/woman-programming-on-a-notebook-1181359/" rel="noopener ugc nofollow" target="_blank">(来源)</a></figcaption></figure><p id="3a4e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我正在写我的论文的文献综述，我已经记不清到目前为止我已经引用了多少次了。</p><p id="5329" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为我还在写初稿，所以我一直在手工输入引文，形式是("<em class="lb"> reference_title </em>"，p. <em class="lb"> page_number </em>)或者简单地("<em class="lb"> reference_title </em>")。例如(“学习分析——定义、过程和潜力”，第2页)或(“Wanted:理解集成学习系统的路线图”)。</p><p id="4f61" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我想查找我在哪里引用了特定的文档，这已经足够好了，但是要知道文本中有多少引用，或者更糟糕的是，使用了哪些引用，我不得不承认我提出的这种格式是一团乱麻。</p><p id="e712" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我想出了一个简短的Python脚本来解决我的问题。它加载Word文档，使用正则表达式(Regex)找到这个“引用格式”的所有实例，并返回找到的引用。该脚本使用<a class="ae kc" href="https://pypi.org/project/docx2txt/" rel="noopener ugc nofollow" target="_blank"> docx2txt </a>包将Word文件(扩展名为. docx的文件)加载到单个Python字符串中。</p><h1 id="4796" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">用我自己的格式查找引文</h1><p id="d0e1" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">为了展示这个脚本是如何工作的，我们将使用传统的Lorem Ipsum文本，其中混合了一些引文(这些引文包含在以下代码要点的开头):</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mj mk l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">我的引用格式的脚本</figcaption></figure><p id="75be" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第一部分(直到第17行)非常简单:导入docx2txt和Python的标准正则表达式库，从Word文件中以单个字符串的形式加载文本(第10行),并用常规双引号替换文本中的任何风格化引号(第16和17行)。</p><p id="511c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二部分(第19–23行)是我定义regex模式查找引文(第21行)并实际尝试在文本中找到它们(第23行)的地方。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/f4cf8376acd22174641e0a290027da61.png" data-original-src="https://miro.medium.com/v2/resize:fit:466/format:webp/1*efRT-XXOrKNYCFELnALKGg.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">正则表达式模式(我的引用格式)</figcaption></figure><p id="2012" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上图中，我通过颜色编码将图案分为三部分:</p><ul class=""><li id="fe99" class="mm mn iq kf b kg kh kk kl ko mo ks mp kw mq la mr ms mt mu bi translated">红色:任何引文的左括号(前面的反斜杠对括号进行转义，以便匹配作为第一个字符的文字括号)</li><li id="82d9" class="mm mn iq kf b kg mv kk mw ko mx ks my kw mz la mr ms mt mu bi translated">蓝色:文字双引号(用来分隔引用文档的标题)</li><li id="3ea5" class="mm mn iq kf b kg mv kk mw ko mx ks my kw mz la mr ms mt mu bi translated">绿色:匹配双引号之间非双引号的任何字符(即引用文档的标题)</li></ul><p id="83e0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">换句话说，上面的正则表达式模式匹配任何用引号括起来并以左括号为前缀的文档标题。例如，对于引用<code class="fe na nb nc nd b">("Learning Analytics — Definitions, Processes and Potential", p.2)</code>，该模式只匹配从开始直到第二个双引号<code class="fe na nb nc nd b">("Learning Analytics — Definitions, Processes and Potential"</code>。毕竟，只有引用的标题是相关的。左括号有助于识别文档标题。</p><p id="6d76" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">带有脱字符号(^)和方括号内的双引号的绿色部分意味着模式正在寻找不是双引号的单个字符<strong class="kf ir">。括号外的星号称为通配符，表示单个字符选择可以重复零次或多次。在完整模式的上下文中，绿色部分负责查找用双引号括起来的文档标题(蓝色部分)。</strong></p><p id="c680" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，第三部分(第25行到结尾)遍历找到的匹配/引用的iterable，将它们保存在一个列表中。因为每个匹配都包括匹配子串相对于原始文本/字符串的第一个和最后一个索引，所以我们使用这些索引来提取匹配部分。剩下的就是简单的Python来打印找到的所有引文，首先打印所有引文，然后只打印唯一的引文(将引文的<code class="fe na nb nc nd b">list</code>转换成<code class="fe na nb nc nd b">set</code>会删除重复的引文，将唯一的引文转换回<code class="fe na nb nc nd b">list</code>只是个人偏好的问题)。</p><p id="1a4d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，这个脚本和示例的输出。docx文件是:</p><pre class="mf mg mh mi gt ne nd nf ng aw nh bi"><span id="3ee8" class="ni ld iq nd b gy nj nk l nl nm">All citations found: 3</span><span id="ad7b" class="ni ld iq nd b gy nn nk l nl nm">("Wanted: A road map for understanding Integrated Learning Systems"</span><span id="6028" class="ni ld iq nd b gy nn nk l nl nm">("Wanted: A road map for understanding Integrated Learning Systems"</span><span id="7e71" class="ni ld iq nd b gy nn nk l nl nm">("Learning Analytics - Definitions, Processes and Potential"</span><span id="5aa0" class="ni ld iq nd b gy nn nk l nl nm">Unique citations: 2</span><span id="aea8" class="ni ld iq nd b gy nn nk l nl nm">("Wanted: A road map for understanding Integrated Learning Systems"</span><span id="e33c" class="ni ld iq nd b gy nn nk l nl nm">("Learning Analytics - Definitions, Processes and Potential"</span></pre><p id="a9fb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我本可以从引文中去掉左括号，但保留它也没关系。即使我想对结果进行排序，我也可以简单地调用唯一引用列表上的<code class="fe na nb nc nd b">sorted()</code>函数。</p><h1 id="1310" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">APA引用的通用解决方案</h1><p id="fe60" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">虽然上面的解决方案解决了我的具体问题，但我决定更进一步，创建一个适用于实际引用的正则表达式，特别是那些使用<a class="ae kc" href="https://aus.libguides.com/apa" rel="noopener ugc nofollow" target="_blank"> APA </a>风格编写的引用。正如您在第二个代码要点中看到的，代码中唯一改变的是regex模式(好吧，开头的引用示例和。准确地说，加载docx文件也是不同的)。</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mj mk l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">APA引用格式的脚本</figcaption></figure><p id="0f33" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在解释正则表达式之前，让我解释一下它实际上在寻找什么:括号中包含的所有内容。APA引文不包括文件标题，而是包括作者和日期/年份，因此我认为完整的引文是相关的。此外，这些(错误的)引用例子有一些变化，遵循一些可能的APA式引用场景:</p><ul class=""><li id="1fd2" class="mm mn iq kf b kg kh kk kl ko mo ks mp kw mq la mr ms mt mu bi translated">作者可以是一个或多个作者，匿名(被识别为匿名)或者实际上是用双引号括起来的文档标题(对于没有作者的在线帖子/文章)</li><li id="9e21" class="mm mn iq kf b kg mv kk mw ko mx ks my kw mz la mr ms mt mu bi translated">日期可以是一年、缺失日期(标识为n.d .)，也可以是该作者在该年的多个出版物之一(标识为带有字母后缀的年份)</li></ul><p id="ec4f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在是正则表达式怪物:</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi no"><img src="../Images/7c9d3f7deb9ebf62eaf930dedfdba3a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pelyl6ZSybv80Q3iWNppDw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">正则表达式模式(APA引用格式)</figcaption></figure><p id="9e6d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">黑色部分(引用的括号)是唯一不在<em class="lb"> regex组</em>中的东西。正则表达式组用括号括起来，这就是为什么黑色的那一对前面有反斜杠，这样模式就可以匹配引用的文字括号。</p><p id="ddee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该模式中的三个组用颜色编码:</p><ul class=""><li id="545d" class="mm mn iq kf b kg kh kk kl ko mo ks mp kw mq la mr ms mt mu bi translated">红色:与引用作者相匹配的组，无论是哪种类型的作者</li><li id="0be6" class="mm mn iq kf b kg mv kk mw ko mx ks my kw mz la mr ms mt mu bi translated">绿色:分组以匹配分隔作者和年份的逗号和空格</li><li id="6270" class="mm mn iq kf b kg mv kk mw ko mx ks my kw mz la mr ms mt mu bi translated">蓝色:与年份相匹配的组，无论是哪种类型的年份</li></ul><p id="e7ba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，由于匹配作者和年份的组内部有多个模式，让我更详细地解释每个组。首先是作者群。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi np"><img src="../Images/ace4773e6992129d8441ebf983b57afa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UB3UpVJlo9P-EMTuXbSm6A.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">正则表达式作者组</figcaption></figure><p id="2f97" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了方便阅读，我把这个组的括号和竖线都改成了黑色。从颜色可以看出，根据前面提到的可能的作者备选方案，这个寻找作者的小组本身有三个备选方案。在简单的英语中，知道竖线意味着另一种匹配的可能性，第一个正则表达式组匹配引用的作者为:“任何数量的字符，不是双引号或右括号或单词Anonymous或在线文章/文章标题，只要它不包含嵌套的双引号或右括号”。现在一个一个来:</p><ul class=""><li id="3e46" class="mm mn iq kf b kg kh kk kl ko mo ks mp kw mq la mr ms mt mu bi translated">第一个选项(红色)寻找最常见的选项，有单个作者、两个或更多作者；这种逻辑与我使用的引用样式的正则表达式模式非常相似</li><li id="6632" class="mm mn iq kf b kg mv kk mw ko mx ks my kw mz la mr ms mt mu bi translated">第二个选项(绿色)只是查找单词Anonymous。对于匹配为引文作者的单词Anonymous，您可以认为<code class="fe na nb nc nd b">\b</code>确保该单词作为一个完整的单词被找到，谢天谢地，作者和日期之间的逗号以及引文的左括号作为分隔符来确认它是一个完整的单词</li><li id="6292" class="mm mn iq kf b kg mv kk mw ko mx ks my kw mz la mr ms mt mu bi translated">第三个选项(蓝色)与第一个选项相同，但这次包含了双引号，因为这是第三个作者选项的写法，文章的标题用双引号括起来</li></ul><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/0afe98d54ce81c90eaf94718c6cc6865.png" data-original-src="https://miro.medium.com/v2/resize:fit:128/format:webp/1*f8-bDEFCg35s_HxOmVWTJQ.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Regex作者-日期分隔符组</figcaption></figure><p id="29e6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二组模式对分隔作者和引用日期的逗号和空格进行文字匹配。非常简单，谢天谢地，所见即所得。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/18860fe5b0c60fbb63aac390861eda2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:936/format:webp/1*lGMRKcG5I2gLyMQNUCrI1w.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">正则表达式日期组</figcaption></figure><p id="93fa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好吧，再解释一遍，我保证这是正则表达式“废话”的终结。同样，就像author组一样，date组有三个选项，用竖线隔开。首先在英语中，这个组是如何匹配引用日期的:“任何连续出现一次以上的数字(即，一年)或n.d .表达式或一年后跟一个字母)。这是一个相对简单的模式，但下面是对每种选择的更具体的解释:</p><ul class=""><li id="364c" class="mm mn iq kf b kg kh kk kl ko mo ks mp kw mq la mr ms mt mu bi translated">第一个备选项(红色)匹配一个或多个连续数字(<code class="fe na nb nc nd b">\d</code>匹配数字，即0到9)。括号外的加号是另一个通配符，表示该模式查找一个或多个连续数字(不可能找到年份，尽管我可以指定它查找4个连续数字，而不是查找一个或多个数字)</li><li id="1065" class="mm mn iq kf b kg mv kk mw ko mx ks my kw mz la mr ms mt mu bi translated">第二个选项(绿色)简单地寻找n.d .(无日期)类型的日期。每个句点都被转义，因为在regex中，句点匹配任何字符，而我们在这里需要的是文字句点</li><li id="799a" class="mm mn iq kf b kg mv kk mw ko mx ks my kw mz la mr ms mt mu bi translated">最后一个选项(蓝色)看起来像红色的一年，但这次它必须在结尾有一个额外的字母(<code class="fe na nb nc nd b">\w</code>匹配任何字母，a-z)</li></ul><p id="386a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，第二个脚本的输出:</p><pre class="mf mg mh mi gt ne nd nf ng aw nh bi"><span id="4a88" class="ni ld iq nd b gy nj nk l nl nm">All citations found: 21</span><span id="37ed" class="ni ld iq nd b gy nn nk l nl nm">(Anonymous, 2010)</span><span id="c745" class="ni ld iq nd b gy nn nk l nl nm">("Barcelona to Ban Burqa", 2010)</span><span id="16e6" class="ni ld iq nd b gy nn nk l nl nm">(Sabbagh, n.d.)</span><span id="522e" class="ni ld iq nd b gy nn nk l nl nm">(Sabbagh, 2009)</span><span id="24ea" class="ni ld iq nd b gy nn nk l nl nm">(Qianyi Gu &amp; Sumner, 2006)</span><span id="09c6" class="ni ld iq nd b gy nn nk l nl nm">(Anonymous, n.d.)</span><span id="433e" class="ni ld iq nd b gy nn nk l nl nm">(Sabbagh, n.d.)</span><span id="48db" class="ni ld iq nd b gy nn nk l nl nm">(Sabbagh, 2010a)</span><span id="98b8" class="ni ld iq nd b gy nn nk l nl nm">(Sabbagh, 2010b)</span><span id="f429" class="ni ld iq nd b gy nn nk l nl nm">(Anonymous, 2010)</span><span id="cbae" class="ni ld iq nd b gy nn nk l nl nm">("Barcelona to Ban Burqa", 2010)</span><span id="6cde" class="ni ld iq nd b gy nn nk l nl nm">(Qianyi Gu &amp; Sumner, 2006)</span><span id="2054" class="ni ld iq nd b gy nn nk l nl nm">(Sabbagh, 2009)</span><span id="e7b7" class="ni ld iq nd b gy nn nk l nl nm">(Anonymous, n.d.)</span><span id="7482" class="ni ld iq nd b gy nn nk l nl nm">(Qianyi Gu &amp; Sumner, 2006)</span><span id="11a8" class="ni ld iq nd b gy nn nk l nl nm">(Anonymous, n.d.)</span><span id="f10b" class="ni ld iq nd b gy nn nk l nl nm">(Despotovic-Zrakic et al., 2012)</span><span id="a55b" class="ni ld iq nd b gy nn nk l nl nm">(Despotovic-Zrakic et al., 2012)</span><span id="ee1d" class="ni ld iq nd b gy nn nk l nl nm">("Barcelona to Ban Burqa", 2010)</span><span id="14c5" class="ni ld iq nd b gy nn nk l nl nm">(Anonymous, 2010)</span><span id="2106" class="ni ld iq nd b gy nn nk l nl nm">("Barcelona to Ban Burqa", 2010)</span><span id="a8e2" class="ni ld iq nd b gy nn nk l nl nm">Unique citations: 9</span><span id="6add" class="ni ld iq nd b gy nn nk l nl nm">(Qianyi Gu &amp; Sumner, 2006)</span><span id="e640" class="ni ld iq nd b gy nn nk l nl nm">(Sabbagh, 2009)</span><span id="f8c2" class="ni ld iq nd b gy nn nk l nl nm">(Sabbagh, 2010b)</span><span id="35db" class="ni ld iq nd b gy nn nk l nl nm">("Barcelona to Ban Burqa", 2010)</span><span id="f16d" class="ni ld iq nd b gy nn nk l nl nm">(Sabbagh, n.d.)</span><span id="d928" class="ni ld iq nd b gy nn nk l nl nm">(Anonymous, 2010)</span><span id="f8c7" class="ni ld iq nd b gy nn nk l nl nm">(Sabbagh, 2010a)</span><span id="dbc6" class="ni ld iq nd b gy nn nk l nl nm">(Anonymous, n.d.)</span><span id="2018" class="ni ld iq nd b gy nn nk l nl nm">(Despotovic-Zrakic et al., 2012)</span></pre><h1 id="183c" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">结论</h1><p id="5662" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">编写这两个脚本和你正在阅读的这篇文章是我度过周日下午的一种有趣方式，而不是继续我的文献综述:)编写代码非常容易，耗费大量时间的是拿出那些正则表达式来查找引用。</p><p id="57d7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">顺便说一下，需要用默认的双引号来代替风格化的双引号是因为/。docx文件使用前者而不是后者，这意味着正则表达式找不到结果。是的，我本可以搜索风格化的引号，但是为什么不用Python来替换呢？</p><p id="e438" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后一点，使用<code class="fe na nb nc nd b">finditer()</code>函数来执行匹配是为了节省内存。前一个函数不是用<code class="fe na nb nc nd b">findall()</code>函数直接在内存中创建匹配列表，而是返回一个迭代器，也就是说，在匹配之后，你可以一次一个匹配地遍历这个迭代器，而不是一次用一个列表把它们都放在内存中。然而，在脚本的最后，为了演示的缘故，我忽略了内存问题。</p><p id="75b7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你想自己运行这些脚本，可以在<a class="ae kc" href="https://repl.it/@ze1598/MyCitations" rel="noopener ugc nofollow" target="_blank">这里</a>获得“我的引用”格式的交互式演示，在这里可以获得另一个APA引用<a class="ae kc" href="https://repl.it/@ze1598/APACitations" rel="noopener ugc nofollow" target="_blank">格式的演示。脚本和各自的。GitHub上也有docx样本文件</a><a class="ae kc" href="https://github.com/Ze1598/medium-articles/tree/master/Count%20citations%20in%20a%20Word%20document%20with%20Python%20and%20Regular%20Expressions" rel="noopener ugc nofollow" target="_blank"/>。</p></div></div>    
</body>
</html>