<html>
<head>
<title>4 custom closures, syntax and semantics illustrated using SwiftUI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用SwiftUI展示了4个自定义闭包、语法和语义</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/4-custom-closures-syntax-and-semantics-illustrated-using-swiftui-c48db97e4210?source=collection_archive---------19-----------------------#2021-01-17">https://levelup.gitconnected.com/4-custom-closures-syntax-and-semantics-illustrated-using-swiftui-c48db97e4210?source=collection_archive---------19-----------------------#2021-01-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a931" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在Swift中处理延迟</h2></div><p id="c557" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您曾经尝试过编写访问web或云的代码，您会对闭包很熟悉。熟悉，因为它们是苹果框架最喜欢的特性。一个超级有用的代码组件，你可以在自己的应用程序中使用；尽管语法有时有点晦涩难懂。</p><p id="8fcf" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">考虑到这一点，我认为回顾一些简单的例子可能是好的。首先是最基本的。</p><h2 id="2deb" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">一个简单的自定义关闭。</h2><p id="8682" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">案情摘要。要求是下载X，一直等到作业完成才呈现X. Simple。这里的目标是展示如何在代码中使用闭包来管理事件的顺序。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi mc"><img src="../Images/0b65bb1f5556de9b5be2a03cddd38648.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*1-2G8NB3x5GTX-O927vIew.gif"/></div></div></figure><p id="952c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面这个动画背后的代码。</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="e75f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">查看代码时，您应该注意的几点是download方法下的代码在完成之前不会执行。在下载方法中，我执行了两次延迟来模拟某种网络延迟。</p><h2 id="a561" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">带有参数的自定义闭包</h2><p id="fe23" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">接下来，我为下一个版本做了两个小改动。这个函数在调用“theDownload”时传递一个参数，如果您愿意，可以命名为X。</p><pre class="md me mf mg gt mq mr ms mt aw mu bi"><span id="6048" class="le lf it mr b gy mv mw l mx my">.onAppear(perform: {<br/>  theDownload("orange") {<br/>    self.color = .orange<br/>    self.text = "orange"<br/>    self.timer.upstream.connect().cancel()<br/>  }<br/>})</span></pre><p id="0f0a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">新的下载方法。</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="mo mp l"/></div></figure><h2 id="fa99" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">带有参数+参数的自定义闭包</h2><p id="1b8a" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">代码的第三个版本不仅命名了要下载的X，而且下载方法返回了完成这项工作所花费的时间——当然，所有这些都是通过一个自定义闭包来来回回传递的。</p><pre class="md me mf mg gt mq mr ms mt aw mu bi"><span id="d970" class="le lf it mr b gy mv mw l mx my">.onAppear(perform: {<br/>  theDownload("orange") { timeReturned in<br/>  self.color = .orange<br/>  self.text = "orange downloaded in \(timeReturned) seconds"<br/>  self.timer.upstream.connect().cancel()<br/>  }<br/>})</span></pre><p id="704a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">新的下载方法。注意，我在这里添加了一个随机下载时间，以使它表现得更真实。</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="mo mp l"/></div></figure><h2 id="b5a3" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">带有参数+带有返回值的参数的自定义闭包</h2><p id="d30c" class="pw-post-body-paragraph ki kj it kk b kl lx ju kn ko ly jx kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">最后也是最复杂的。这做了版本1到3做的所有事情，增加了一个从返回的下载方法返回的参数。在这种情况下，返回将最终消息更改为“下载完成”。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi mc"><img src="../Images/ab44ca3b3fa2bed1cb03aa2dce5c676d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*gHXNQewftwUZlBCXnJOk5Q.gif"/></div></div></figure><p id="ef43" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最终版本的新代码如下所示。</p><pre class="md me mf mg gt mq mr ms mt aw mu bi"><span id="706c" class="le lf it mr b gy mv mw l mx my">.onAppear(perform: {<br/>  theDownload("orange") {timeReturned -&gt; String in<br/>  self.color = .orange<br/>  self.text = "orange downloaded in \(timeReturned) seconds" <br/>  self.timer.upstream.connect().cancel()<br/>  return "finished downloading"<br/>  }<br/>})</span></pre><p id="a93d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这段代码展示了新的theDownload方法。</p><figure class="md me mf mg gt mh"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="2db0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这就把我带到了这篇短文的结尾。我希望你发现它是未来有用的参考。在medium.com上跟随我，以确保你得到关于编码的未来帖子的副本。</p><p id="c1b0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">保持冷静，继续编码。</p></div></div>    
</body>
</html>