<html>
<head>
<title>Nuxt.js — Custom scrollBehavior fired after page loaded</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Nuxt.js —页面加载后触发的自定义scrollBehavior</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/nuxt-js-custom-scrollbehavior-fired-after-page-loaded-cd94fd6ddd12?source=collection_archive---------0-----------------------#2019-10-19">https://levelup.gitconnected.com/nuxt-js-custom-scrollbehavior-fired-after-page-loaded-cd94fd6ddd12?source=collection_archive---------0-----------------------#2019-10-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="0b72" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">路线之间的滚动行为起着重要的作用，因为它极大地影响了你的网站的可读性。js允许开发者定制他们自己的滚动行为。然而，在我开始工作后不久，我发现了一个非常令人讨厌的问题，基本上没有人谈论如何解决它。</p></div><div class="ab cl ko kp hx kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="im in io ip iq"><p id="8144" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">问题</strong></p><p id="0171" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了定制您的滚动行为，您可以在Nuxt路由器中覆盖默认的滚动行为。假设您希望当用户单击“上一页”时，您的页面返回到上一个位置，但是当用户进入新页面时，您的页面滚动回顶部。你可以这样做:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="a2eb" class="le lf it la b gy lg lh l li lj">export default function (to, from, savedPosition) {<br/>  return savedPosition || { x: 0, y: 0 };<br/>}</span></pre><p id="8a7b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它看起来很直截了当，<strong class="js iu">但它不起作用</strong>！问题是<strong class="js iu">它不会等到带有异步数据的页面完全加载后才开始滚动</strong>。</p><figure class="kv kw kx ky gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi lk"><img src="../Images/45f4c5665948083e1a482713364623bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*cmx_ftzkWAxsY4A6FNKvBw.gif"/></div></div></figure><p id="b10e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从上面的GIF可以看出，当用户点击上一页时，滚动是在页面加载之前立即完成的。从用户的角度来看，这看起来非常不专业。最重要的是，<strong class="js iu">滚动位置根本不正确</strong>！</p><p id="7fde" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">预期内容:</p><figure class="kv kw kx ky gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi lk"><img src="../Images/d28813444a05c1517b52e66e9b483976.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*P8b6XHRkmItESH-kc7whUg.gif"/></div></div></figure></div><div class="ab cl ko kp hx kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="im in io ip iq"><p id="956b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">解决方案</strong></p><p id="4c20" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Nuxt路由器支持scrollBehavior的异步定义。因此，我首先想到的是这样的事情:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="c2f3" class="le lf it la b gy lg lh l li lj">export default function (to, from, savedPosition) {<br/>  return new Promise(resolve =&gt; {<br/>    (...a callback after page loaded).then(() =&gt; {<br/>      resolve(savedPosition || { x: 0, y: 0 });<br/>    })<br/>  })<br/>}</span></pre><p id="8a5f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但问题是，<strong class="js iu">谷歌</strong>零搜索结果！</p><p id="8f22" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了解决这个问题，我查阅了scrollBehavior的官方文档。我发现解决方法比我想象的要复杂得多。以下是我的代码:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="26fe" class="le lf it la b gy lg lh l li lj">if (process.client) {<br/>  if ('scrollRestoration' in window.history) {<br/>    window.history.scrollRestoration = 'manual'</span><span id="d996" class="le lf it la b gy ls lh l li lj">// reset scrollRestoration to auto when leaving page, allowing page reload<br/>    // and back-navigation from other pages to use the browser to restore the<br/>    // scrolling position.<br/>    window.addEventListener('beforeunload', () =&gt; {<br/>      window.history.scrollRestoration = 'auto'<br/>    })</span><span id="ed65" class="le lf it la b gy ls lh l li lj">// Setting scrollRestoration to manual again when returning to this page.<br/>    window.addEventListener('load', () =&gt; {<br/>      window.history.scrollRestoration = 'manual'<br/>    })<br/>  }<br/>}</span><span id="95ca" class="le lf it la b gy ls lh l li lj">export default function (to, from, savedPosition) {<br/>  let position;</span><span id="0345" class="le lf it la b gy ls lh l li lj">//Your Code Starts Here</span><span id="b389" class="le lf it la b gy ls lh l li lj">position = savedPosition || { x: 0, y: 0 };</span><span id="a15c" class="le lf it la b gy ls lh l li lj">//Your Code Ends Here</span><span id="35aa" class="le lf it la b gy ls lh l li lj">const nuxt = window.&lt;%= globals.nuxt %&gt;;</span><span id="59f8" class="le lf it la b gy ls lh l li lj">// triggerScroll is only fired when a new component is loaded<br/>  if (to.path === from.path &amp;&amp; to.hash !== from.hash) {<br/>    nuxt.$nextTick(() =&gt; nuxt.$emit('triggerScroll'))<br/>  }</span><span id="1591" class="le lf it la b gy ls lh l li lj">return new Promise((resolve) =&gt; {<br/>    // wait for the out transition to complete (if necessary)<br/>    nuxt.$once('triggerScroll', () =&gt; {<br/>      // coords will be used if no selector is provided,<br/>      // or if the selector didn't match any element.<br/>      if (to.hash) {<br/>        let hash = to.hash<br/>        // CSS.escape() is not supported with IE and Edge.<br/>        if (typeof window.CSS !== 'undefined' &amp;&amp; typeof window.CSS.escape !== 'undefined') {<br/>          hash = '#' + window.CSS.escape(hash.substr(1))<br/>        }<br/>        try {<br/>          if (document.querySelector(hash)) {<br/>            // scroll to anchor by returning the selector<br/>            position = { selector: hash }<br/>          }<br/>        } catch (e) {<br/>          console.warn('Failed to save scroll position. Please add CSS.escape() polyfill (<a class="ae lt" href="https://github.com/mathiasbynens/CSS.escape).'" rel="noopener ugc nofollow" target="_blank">https://github.com/mathiasbynens/CSS.escape).'</a>)<br/>        }<br/>      }<br/>      resolve(position)<br/>    })<br/>  })<br/>}</span></pre><p id="512d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是我从默认的scrollBehavior中提取的内容。简单地说，你需要首先改变浏览器的滚动行为。之后，您需要将您的滚动挂钩到Nuxt实例，告诉它在页面呈现完成后滚动到哪里。就是这样。如果想试试效果如何，也可以直接访问<a class="ae lt" href="https://onyourmarkhk.com" rel="noopener ugc nofollow" target="_blank">我的网站</a>。</p><p id="4706" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我花了一天的时间来解决这个问题，因为文档非常少。甚至想出一个正确的谷歌关键词都不容易。希望我的文章可以节省你一些时间！</p></div></div>    
</body>
</html>