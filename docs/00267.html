<html>
<head>
<title>The JavaScript Object Paradigm and Prototypes Explained Simply</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">简单解释了JavaScript对象范例和原型</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/the-javascript-object-paradigm-and-prototypes-explained-simply-e9cb9eaa49aa?source=collection_archive---------0-----------------------#2018-11-27">https://levelup.gitconnected.com/the-javascript-object-paradigm-and-prototypes-explained-simply-e9cb9eaa49aa?source=collection_archive---------0-----------------------#2018-11-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0fcc" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">关于JavaScript对象的所有令人困惑的地方都暴露出来了，所以你可以停止对它们的厌恶</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/5b9c94a18cd2246cc66ba67d8f2bef43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bF20HEclFo2afymdAsgQdg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">Ughhh，为什么JavaScript一定要这样？</figcaption></figure><p id="78fd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对于许多新开发人员来说，JavaScript世界可能看起来相当令人厌烦，尤其是对于那些来自传统面向对象背景的人来说。仅仅在谷歌上搜索一些JavaScript代码和解释可能会发现相当混乱的代码和令人困惑的术语。为了使事情变得简单，本文将向您概述简单的、基于原型的继承，这样您就可以为使用JavaScript编程打下良好的基础。</p><blockquote class="lr ls lt"><p id="8899" class="kv kw lu kx b ky kz jr la lb lc ju ld lv lf lg lh lw lj lk ll lx ln lo lp lq ij bi translated">只是指出一点，我知道试图解释JavaScript对象的文章已经做得够多了，但是我觉得我从来没有真正读过一篇彻底或清楚地解释它们的文章。他们经常只关注继承，而忽略了其他重要的点，或者没有给出足够的例子。这里的目的是以最简单的方式向您简要介绍JavaScript对象和原型继承。</p></blockquote></div><div class="ab cl ly lz hu ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ij ik il im in"><h2 id="7f4d" class="mf mg iq bd mh mi mj dn mk ml mm dp mn le mo mp mq li mr ms mt lm mu mv mw mx bi translated">什么是对象？</h2><p id="df9d" class="pw-post-body-paragraph kv kw iq kx b ky my jr la lb mz ju ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">最基本的对象可以被认为是一个键/值对的列表，其中键总是一个字符串，值是……当然也可以是其他的。这类似于其他语言中你可能称之为<em class="lu">【地图】</em>。您在JavaScript中键入的所有非原语的内容(参见最后一节了解更多关于原语的信息)都是对象。对象使得打包和移动数据变得容易，创建新的对象比其他面向对象的语言(如Java/C#)更简单。</p><p id="91d6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在谈论物品时，你会经常听到使用术语<em class="lu">、</em>。这是指对象上特定的键/值对。为了让您了解对象的样子，我们将从一个简单的具有两个属性的对象示例开始:<code class="fe nd ne nf ng b">age</code>和<code class="fe nd ne nf ng b">weight</code>。</p><pre class="kg kh ki kj gt nh ng ni nj aw nk bi"><span id="d1e6" class="mf mg iq ng b gy nl nm l nn no">var Dog = {<br/>    age: 8,<br/>    weight: 65<br/>}</span></pre><blockquote class="lr ls lt"><p id="836d" class="kv kw lu kx b ky kz jr la lb lc ju ld lv lf lg lh lw lj lk ll lx ln lo lp lq ij bi translated">注意:我们刚才的代码片段是一个使用对象文字的例子。object-literal严格地指的是花括号内的代码。object-literal不是变量或返回值。</p></blockquote></div><div class="ab cl ly lz hu ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ij ik il im in"><h2 id="5f4f" class="mf mg iq bd mh mi mj dn mk ml mm dp mn le mo mp mq li mr ms mt lm mu mv mw mx bi translated">函数是对象</h2><p id="63b5" class="pw-post-body-paragraph kv kw iq kx b ky my jr la lb mz ju ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">如前所述，所有不是原语的东西都是对象，包括函数…我知道怪异，对吗？很难把函数想象成一组键/值对。由于函数是对象，它们通常被称为<em class="lu">函数对象</em>。函数对象是一组特殊的键/值对，具有执行代码和传递值的特定属性。我们将在下一节讨论这些属性是什么。首先让我们谈谈为什么函数很重要。</p><p id="6574" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">你可以说函数对象有两个主要目的。如果我们想创建一个执行的逻辑块，我们可以使用函数对象:就像任何其他编程语言中的<em class="lu">【方法】</em>。下一个目的是JavaScript变得有点时髦。如果我们想创建既有值又有方法的对象，也许还需要一些逻辑来设置这些值，我们也可以使用函数对象。在这里，您可以认为函数对象的行为类似于面向对象语言(如Java/C#)中的<em class="lu">“类”</em>。</p><blockquote class="lr ls lt"><p id="1164" class="kv kw lu kx b ky kz jr la lb lc ju ld lv lf lg lh lw lj lk ll lx ln lo lp lq ij bi translated"><strong class="kx ir">注意</strong>:你会听到JavaScript中有时会用到的术语“<em class="iq">方法”</em>。在JavaScript中，方法是指作为包含对象的属性而存在的函数对象。</p></blockquote><p id="3962" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在标准情况下，JavaScript中的函数看起来像任何其他语言中的函数；它们执行块逻辑来执行特定的任务。在下面的代码片段中，<code class="fe nd ne nf ng b">bark</code>是函数对象执行代码。</p><pre class="kg kh ki kj gt nh ng ni nj aw nk bi"><span id="42b7" class="mf mg iq ng b gy nl nm l nn no">function bark() {<br/>    console.log('woof woof')<br/>}</span><span id="db5d" class="mf mg iq ng b gy np nm l nn no">bark() =&gt; 'woof woof'</span></pre><p id="eb7e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果我们想打包一小组数据，就像之前在<code class="fe nd ne nf ng b">Dog</code>对象中的2个属性，那么一个简单的键/值对列表就可以了。如果我们想要创建多个狗对象呢？也许有些值需要是静态的，而有些值需要是动态的。这就是函数对象派上用场的地方。当我们用<code class="fe nd ne nf ng b">new</code>调用一个函数时，一个对象(又名<em class="lu">实例-对象</em>)被返回，带有从函数内的<code class="fe nd ne nf ng b">this</code>关键字设置的属性。</p><pre class="kg kh ki kj gt nh ng ni nj aw nk bi"><span id="4ab4" class="mf mg iq ng b gy nl nm l nn no">function Dog(age, weight) {<br/>    this.species = 'Canis Familiaris'<br/>    this.age = age<br/>    this.weight = weight<br/>    this.bark = bark &lt;-- bark() from prev snippet<br/>}</span><span id="775c" class="mf mg iq ng b gy np nm l nn no">// Spot and Bingo are <strong class="ng ir">'instance-objects'</strong> of Dog<br/>var Spot = <strong class="ng ir">new</strong> Dog(8, 65)<br/>var Bingo = <strong class="ng ir">new</strong> Dog(10, 70)</span><span id="6b3b" class="mf mg iq ng b gy np nm l nn no">Spot.species =&gt; 'Canis Familiaris'</span><span id="ffbe" class="mf mg iq ng b gy np nm l nn no">// bark is a <strong class="ng ir">'method'</strong> of Dog<br/>Bingo.bark() =&gt; 'woof woof'</span></pre></div><div class="ab cl ly lz hu ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ij ik il im in"><h2 id="9f6e" class="mf mg iq bd mh mi mj dn mk ml mm dp mn le mo mp mq li mr ms mt lm mu mv mw mx bi translated">对象与原型</h2><p id="719a" class="pw-post-body-paragraph kv kw iq kx b ky my jr la lb mz ju ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">既然你对对象，更重要的是对功能对象有了一个很好的理解，让我们来谈谈原型。您经常听说JavaScript是一种基于原型的语言。那么这是否意味着对象和原型是同一件事呢？不完全是。<em class="lu">原型是一种特殊类型的对象，作为功能对象的属性而存在。当我们试图访问一个函数对象上的键时，JavaScript会查看它的<code class="fe nd ne nf ng b">prototype</code>属性，看看它是否在那里。如果没有，它将沿着<strong class="kx ir">原型链</strong>向上尝试找到它。为了理解原型链，我们需要了解函数和继承。</em></p></div><div class="ab cl ly lz hu ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ij ik il im in"><h2 id="334f" class="mf mg iq bd mh mi mj dn mk ml mm dp mn le mo mp mq li mr ms mt lm mu mv mw mx bi translated">函数和继承</h2><p id="1541" class="pw-post-body-paragraph kv kw iq kx b ky my jr la lb mz ju ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">每当使用<code class="fe nd ne nf ng b">new</code>从函数调用中返回一个实例对象时，它就被赋予一个带有键<code class="fe nd ne nf ng b">__proto__</code>的属性。这个属性的值是创建它的函数的<code class="fe nd ne nf ng b">prototype</code>属性。</p><pre class="kg kh ki kj gt nh ng ni nj aw nk bi"><span id="64e3" class="mf mg iq ng b gy nl nm l nn no">Bingo.__proto__ === Dog.prototype<br/>Spot.__proto__ === Dog.prototype</span></pre><p id="8773" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果我们试图访问实例对象上的一个属性，而它不在那里，JavaScript将首先转到<code class="fe nd ne nf ng b">__proto__</code>并查看它是否在父函数的原型上。为了看到这一点，让我们在狗对象的<code class="fe nd ne nf ng b">prototype</code>键上设置一个属性，当我们调用<code class="fe nd ne nf ng b">Spot['whatever the key name is']</code>或<code class="fe nd ne nf ng b">Bingo['whatever the key name is']</code>时，我们将得到相同的值。这将工作，即使在两个狗实例对象已经创建。</p><pre class="kg kh ki kj gt nh ng ni nj aw nk bi"><span id="8fe7" class="mf mg iq ng b gy nl nm l nn no">Dog.prototype.bark = function() {<br/>    console.log('woof woof')<br/>}</span><span id="f76e" class="mf mg iq ng b gy np nm l nn no">Spot.bark() // =&gt; 'woof woof'<br/>Bingo.bark() // =&gt; 'woof woof'</span></pre><p id="d6d7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">以这种方式设置方法(与在函数内部使用<code class="fe nd ne nf ng b">this</code>相比)特别有用，因为方法实现只会发生一次，而不是每次调用<code class="fe nd ne nf ng b">new</code>时。这将节省内存并提高性能。</p></div><div class="ab cl ly lz hu ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ij ik il im in"><h2 id="faf2" class="mf mg iq bd mh mi mj dn mk ml mm dp mn le mo mp mq li mr ms mt lm mu mv mw mx bi translated">现在让我们更深入地研究一下继承吧！</h2><p id="6d0c" class="pw-post-body-paragraph kv kw iq kx b ky my jr la lb mz ju ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">所有JavaScript继承的核心是<code class="fe nd ne nf ng b">Object</code>关键字，它是一个函数对象。所有实例对象都继承自它。当我们创建一个object-literal时，幕后的JavaScript实际上是在调用<code class="fe nd ne nf ng b">new Object()</code>。新对象的<code class="fe nd ne nf ng b">__proto__</code>将指向<code class="fe nd ne nf ng b">Object</code>的原型。所以所有由object-literal构成的对象实际上都是<code class="fe nd ne nf ng b">Object</code>的实例对象。这为我们提供了很多像<code class="fe nd ne nf ng b">hasOwnProperty</code>这样有用的方法，可以告诉我们一个对象上是否存在一个属性。如果我们试图直接访问function-object上的属性，JavaScript将首先查看<code class="fe nd ne nf ng b">prototype</code>，然后使用原型上的<code class="fe nd ne nf ng b">__proto__</code>沿着链向上移动。</p><p id="af0d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们看几个JavaScript沿着原型链向上移动来访问一些对象上的<code class="fe nd ne nf ng b">hasOwnProperty</code>的例子。</p><p id="9b11" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对象文字:</p><pre class="kg kh ki kj gt nh ng ni nj aw nk bi"><span id="2412" class="mf mg iq ng b gy nl nm l nn no">var insect = {legs: 6}</span><span id="aa90" class="mf mg iq ng b gy np nm l nn no">// insect.__proto__ === Object.prototype<br/>// insect.hasOwnProperty === Object.prototype.hasOwnProperty</span><span id="5fde" class="mf mg iq ng b gy np nm l nn no">insect.hasOwnProperty('legs') // =&gt; true</span></pre><p id="9e9f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">实例对象:</p><pre class="kg kh ki kj gt nh ng ni nj aw nk bi"><span id="5097" class="mf mg iq ng b gy nl nm l nn no">var Bingo = new Dog()</span><span id="4c43" class="mf mg iq ng b gy np nm l nn no">// Bingo.__proto__ === Dog.prototype<br/>// Dog.prototype.__proto__ === Object.prototype</span><span id="8f9d" class="mf mg iq ng b gy np nm l nn no">Bingo.hasOwnProperty('weight') // =&gt; true</span></pre><p id="577c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">直接在功能对象上:</p><pre class="kg kh ki kj gt nh ng ni nj aw nk bi"><span id="3ea7" class="mf mg iq ng b gy nl nm l nn no">function Foo() {<br/>    this.something = 'blah'<br/>}</span><span id="15df" class="mf mg iq ng b gy np nm l nn no">// Foo.prototype.__proto__ === Object.prototype</span><span id="a122" class="mf mg iq ng b gy np nm l nn no">Foo.hasOwnProperty('name') // =&gt; true<br/>Foo.hasOwnProperty('something') // =&gt; false, set on instance-object not on the function</span></pre></div><div class="ab cl ly lz hu ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ij ik il im in"><h2 id="942a" class="mf mg iq bd mh mi mj dn mk ml mm dp mn le mo mp mq li mr ms mt lm mu mv mw mx bi translated">那么函数对象的__proto__呢？</h2><p id="6ad7" class="pw-post-body-paragraph kv kw iq kx b ky my jr la lb mz ju ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">如前所述，<code class="fe nd ne nf ng b">__proto__</code>有助于将对象链接到它们所继承的原型。但是直接在函数对象上调用<code class="fe nd ne nf ng b">__proto__</code>呢？JavaScript实际上有一个内置的函数对象，叫做<code class="fe nd ne nf ng b">Function</code>。每个函数的<code class="fe nd ne nf ng b">__proto__</code>属性都指向<code class="fe nd ne nf ng b">Function.prototype</code>，它是一个函数，但没有<code class="fe nd ne nf ng b">prototype</code>属性，返回<code class="fe nd ne nf ng b">undefined</code>。<code class="fe nd ne nf ng b">Function.prototype</code>定义所有函数继承的默认行为。像函数对象的所有<code class="fe nd ne nf ng b">prototype</code>属性一样，它仍然有指向<code class="fe nd ne nf ng b">Object.prototype</code>的<code class="fe nd ne nf ng b">__proto__</code>。</p><pre class="kg kh ki kj gt nh ng ni nj aw nk bi"><span id="2ecb" class="mf mg iq ng b gy nl nm l nn no">Dog.__proto__ === Function.prototype       <br/>Object.__proto__ === Function.prototype    <br/>Function.__proto__ === Function.prototype  </span><span id="b5f3" class="mf mg iq ng b gy np nm l nn no">Function.prototype.__proto__ === Object.prototype</span></pre></div><div class="ab cl ly lz hu ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ij ik il im in"><h2 id="d53c" class="mf mg iq bd mh mi mj dn mk ml mm dp mn le mo mp mq li mr ms mt lm mu mv mw mx bi translated">咻，太多了…</h2><p id="0e53" class="pw-post-body-paragraph kv kw iq kx b ky my jr la lb mz ju ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">所有这些都有点令人困惑，对吗？也许这张照片可以让事情变得简单一点。注意<code class="fe nd ne nf ng b">Object.prototype</code>是一切的起源。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/fda396ff2cfd0bf678a9c96e0503ede8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KNCFqc7YytARCUXJGgYn1Q.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">原型链</figcaption></figure></div><div class="ab cl ly lz hu ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ij ik il im in"><h2 id="073c" class="mf mg iq bd mh mi mj dn mk ml mm dp mn le mo mp mq li mr ms mt lm mu mv mw mx bi translated">多层次继承</h2><p id="854b" class="pw-post-body-paragraph kv kw iq kx b ky my jr la lb mz ju ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">当我们说到继承时，我们通常会想到从函数返回的实例对象。使用<code class="fe nd ne nf ng b">prototype</code>你也可以做多层次的继承，让函数对象从其他函数对象继承。您所要做的就是将子功能对象的原型设置为父功能对象原型的另一个实例。然后将复制父对象的所有属性。如果父函数在<code class="fe nd ne nf ng b">Dog</code>中接收参数，如年龄和体重，使用<code class="fe nd ne nf ng b">.call</code>设置子对象的<code class="fe nd ne nf ng b">this</code>属性。</p><p id="ed8b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe nd ne nf ng b">Labrador</code>继承自<code class="fe nd ne nf ng b">Dog</code>:</p><pre class="kg kh ki kj gt nh ng ni nj aw nk bi"><span id="3b43" class="mf mg iq ng b gy nl nm l nn no">function Labrador(furColor, age, weight) {<br/>    this.furColor = furColor<br/>    this.breed = 'labrador'<br/>    Dog.call(this, age, weight)<br/>}</span><span id="12b4" class="mf mg iq ng b gy np nm l nn no">Labrador<!-- -->.prototype = Object.create(Dog.prototype)</span><span id="00d7" class="mf mg iq ng b gy np nm l nn no">var Fido = new Labrador('white', 4, 41)<br/>Fido.bark()</span></pre></div><div class="ab cl ly lz hu ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ij ik il im in"><h2 id="cdae" class="mf mg iq bd mh mi mj dn mk ml mm dp mn le mo mp mq li mr ms mt lm mu mv mw mx bi translated">班级</h2><p id="f11b" class="pw-post-body-paragraph kv kw iq kx b ky my jr la lb mz ju ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">JavaScript中为ES6创建的类只是功能对象之上的语法糖。不用一遍又一遍地输入<code class="fe nd ne nf ng b">prototype</code>来定义函数的方法，使用<code class="fe nd ne nf ng b">class</code>关键字我们可以在一个类中定义一组方法。有了<code class="fe nd ne nf ng b">extends</code>关键字，类可以从其他类继承，而不必做<code class="fe nd ne nf ng b">Object.create</code>和<code class="fe nd ne nf ng b">Object.call</code>。我更喜欢使用类，但是记住不是所有的浏览器都支持它们(ES6)。这就是巴别塔这样的工具被创造出来的原因。</p><p id="d6d9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用功能对象:</p><pre class="kg kh ki kj gt nh ng ni nj aw nk bi"><span id="de0a" class="mf mg iq ng b gy nl nm l nn no">function Dog(age, weight) {<br/>    this.age = age<br/>    this.weight = weight<br/>}</span><span id="4d50" class="mf mg iq ng b gy np nm l nn no">Dog.prototype.bark = function() {console.log('woof woof')}</span><span id="fc5f" class="mf mg iq ng b gy np nm l nn no"><br/>function Labrador(furColor, age, weight) {<br/>    this.furColor = furColor<br/>    this.breed = 'labrador'<br/>    Dog.call(this, age, weight)<br/>}</span><span id="367f" class="mf mg iq ng b gy np nm l nn no">Labrador<!-- -->.prototype = Object.create(Dog.prototype)</span></pre><p id="9d71" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">等效使用类:</p><pre class="kg kh ki kj gt nh ng ni nj aw nk bi"><span id="6d38" class="mf mg iq ng b gy nl nm l nn no">class Dog {<br/>    constructor(age, weight) {<br/>        this.age = age<br/>        this.weight = weight<br/>    }</span><span id="b3a2" class="mf mg iq ng b gy np nm l nn no">    bark() {<br/>        console.log('woof woof')<br/>    }<br/>}</span><span id="e95a" class="mf mg iq ng b gy np nm l nn no">class Labrador extends Dog {<br/>    constructor(furColor, age, weight) {<br/>        super(age, weight)<br/>        this.furColor = furColor<br/>        this.breed = 'labrador'<br/>    }<br/>}</span></pre></div><div class="ab cl ly lz hu ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ij ik il im in"><h2 id="eaec" class="mf mg iq bd mh mi mj dn mk ml mm dp mn le mo mp mq li mr ms mt lm mu mv mw mx bi translated">对象与原语</h2><p id="0dbd" class="pw-post-body-paragraph kv kw iq kx b ky my jr la lb mz ju ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">JavaScript代码本质上可以归结为两种基本类型:原语和对象。JavaScript中有5种原语:<code class="fe nd ne nf ng b">boolean</code>、<code class="fe nd ne nf ng b">number</code>、<code class="fe nd ne nf ng b">string</code>、<code class="fe nd ne nf ng b">null</code>和<code class="fe nd ne nf ng b">undefined</code>。原语只是没有属性的简单值。其中3个原语:<code class="fe nd ne nf ng b">boolean</code>、<code class="fe nd ne nf ng b">number</code>和<code class="fe nd ne nf ng b">string</code>都有JavaScript在某些操作中强制使用的对象对应。例如，<code class="fe nd ne nf ng b">"some string".length</code>将调用<code class="fe nd ne nf ng b">new String()</code>并将返回的实例对象包装在string原语周围，这样就可以访问<code class="fe nd ne nf ng b">length</code>属性。如上所述，所有实例对象都继承自<code class="fe nd ne nf ng b">Object</code>。所以对于一个字符串，你仍然可以使用像<code class="fe nd ne nf ng b">hasOwnProperty</code>这样的方法。</p><pre class="kg kh ki kj gt nh ng ni nj aw nk bi"><span id="297f" class="mf mg iq ng b gy nl nm l nn no">// String.prototype.__proto__ === Object.prototype</span><span id="e173" class="mf mg iq ng b gy np nm l nn no">String.hasOwnProperty('length')  // =&gt; true</span></pre></div><div class="ab cl ly lz hu ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ij ik il im in"><h1 id="90ac" class="nr mg iq bd mh ns nt nu mk nv nw nx mn jw ny jx mq jz nz ka mt kc oa kd mw ob bi translated">结论</h1><p id="ae61" class="pw-post-body-paragraph kv kw iq kx b ky my jr la lb mz ju ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">是啊是啊，我知道这很让人头疼；这看起来像是没完没了的接二连三。就个人而言，我认为JavaScript中的继承比它需要的要复杂得多，这就是我使用TypeScript的原因。如果您正在努力成为一名优秀的前端开发人员，了解并理解JavaScript超级集合的存在是有帮助的。</p><p id="aec4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你觉得这篇文章有帮助，请点击拍手按钮。祝网络设计愉快！</p></div><div class="ab cl ly lz hu ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ij ik il im in"><figure class="kg kh ki kj gt kk gh gi paragraph-image"><a href="https://levelup.gitconnected.com/"><div class="gh gi oc"><img src="../Images/439094b9a664ef0239afbc4565c6ca49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S9uYu-fFL3hIQLGVu0o-EQ.png"/></div></a></figure><div class="od oe gp gr of og"><a href="https://gitconnected.com/learn/javascript" rel="noopener  ugc nofollow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd ir gy z fp ol fr fs om fu fw ip bi translated">学习JavaScript -最佳JavaScript教程(2019) | gitconnected</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">排名前64的JavaScript教程。课程由开发者提交并投票，使您能够找到最好的…</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">gitconnected.com</p></div></div><div class="op l"><div class="oq l or os ot op ou kp og"/></div></div></a></div></div></div>    
</body>
</html>