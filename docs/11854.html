<html>
<head>
<title>Deep Dive into CQRS — A Great Microservices Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">深入CQRS —一个伟大的微服务模式</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/what-is-cqrs-8ddd74ca05bb?source=collection_archive---------0-----------------------#2022-04-24">https://levelup.gitconnected.com/what-is-cqrs-8ddd74ca05bb?source=collection_archive---------0-----------------------#2022-04-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8f10" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">什么是CQRS，为什么它越来越受欢迎？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2808c637ad2b23d4a8d3b69df8be5112.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9L4yuRn0CWM2jKScMt0wTw.png"/></div></div></figure><p id="e695" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">CQRS是一种架构模式，经常与领域驱动设计(DDD)和事件源联系在一起。Greg Young在2010年创造了这个术语，CQRS的内容基于Bertrand Meyer的CQS设计模式。但是这背后是什么呢？</p><p id="9f06" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu"> CQS </strong>(命令查询分离)设计模式建议将一个对象的方法映射成两类:要么一个方法改变了对象的内部状态，然后不返回任何东西，要么只返回元数据。这样的方法叫做<strong class="kw iu">命令</strong>。或者一个方法返回信息但不改变内部状态。这样的方法叫做<strong class="kw iu">查询</strong>。</p><p id="42ac" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">根据CQS的观点，一个方法不应该同时是两者。比如你看栈的典型数据结构，push函数是命令，而top是查询。最后，pop函数违反了CQS模式，因为它修改了堆栈的内部状态并同时返回信息。</p><p id="59c9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，CQS的核心是将对单个对象的写入和读取分离开来。这一点尤其重要，例如，当代码要并行执行时:由于没有副作用，查询可以被并行化而没有任何问题，但是命令不能。</p><p id="e865" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">基于CQS模式，Greg Young在2010年创造了<strong class="kw iu"> CQRS </strong>(命令查询责任分离)架构模式。它也把写作和阅读分开了，但是在API方面。因此，它提出了独立的API，一个专用于更改应用程序状态的命令路由，另一个用于查询返回应用程序状态信息的路由。</p><p id="c029" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">从技术上来说，这可以在HTTP中实现，以便命令API专门用POST routes实现，而查询API专门用GET routes实现。实际的语义被转移到URL。例如，下订单需要向<em class="lq"> /submit-order </em>路由发出POST请求。这与REST形成对比，REST只允许HTTP动词作为动词，因此技术语义已经在API级别丢失了。</p><p id="5e0d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你进一步理解CQRS的思想，将API背后的数据库分成两个数据库也是有意义的。一个应该为写而优化，另一个应该为读而优化——例如，对一个进行高度规范化，而对另一个进行反规范化。这样，在写入时可以确保良好的完整性和一致性，同时在读取时实现高效率和高性能。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lr"><img src="../Images/0493a05de61bdab20310c4775d4cd31f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*THq8gXGG_KTAKoo-Qpdzyg.jpeg"/></div></div></figure><h1 id="429b" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">与CQRS一起开发API</h1><p id="61fc" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">如果您想在API中实现CQRS模式，通过POST和GET来分离路由是不够的。您还必须考虑如何确保命令不返回任何内容，或者至少只返回元数据。</p><p id="8fa2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">情况类似于查询API。这里，URL路径描述了所需的查询，但是在这种情况下，参数是使用查询字符串传输的，因为它是一个GET请求。由于查询访问读优化的非规范化数据库，因此可以快速有效地执行查询。</p><p id="e2c0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，问题是，如果不定期提取查询路由，客户端就不会发现命令是否已经被处理以及结果是什么。因此，建议使用第三个API，即Events API，它通过web套接字、HTTP流或类似的机制通过推送通知来通知事件。</p><p id="034b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">任何了解GraphQL并在描述命令、查询和事件API时被提醒了变异、查询和订阅概念的人都是正确的:GraphQL是实现基于CQRS的API的理想选择。</p><h1 id="2539" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">DDD CQRS和活动采购</h1><p id="e41d" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">如前所述，CQRS经常与<strong class="kw iu">领域驱动设计</strong> (DDD)和<strong class="kw iu">事件源</strong>一起被提及。虽然这三个概念是独立的，<strong class="kw iu">他们很好地互补！</strong></p><p id="665e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">发送到基于CQRS的应用程序的命令API的命令也可以在DDD意义上被解释为<strong class="kw iu">用于集合</strong>的命令。然后，聚合<strong class="kw iu">按顺序产生一个或多个域事件</strong>，可以使用事件源将这些域事件<strong class="kw iu">存储在事件存储库</strong>中，并用于聚合的稍后重放。</p><p id="0d90" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">此外，流程中生成的域事件也被转发到events API，后者又将它们传递给各种连接的客户端，这些客户端接收关于应用程序内技术流程的准实时更新。</p><p id="9d96" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">此外，域事件也被转发到应用程序的read页面，以更新那里的(预先计算的)视图。为此，使用了所谓的投影，它决定技术领域事件与哪个视图的相关性，然后在CRUD语句的帮助下相应地调整受影响的视图。</p><p id="bb89" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这种情况下，事件存储代表真实的单一来源，在它的帮助下，任何视图都可以在以后建立。然而，应该注意的是，写入视图与写入事件存储是分离的，所以开发人员应该熟悉CAP定理和最终的一致性。</p><h1 id="812a" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">上限和最终一致性</h1><p id="4344" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">原则上，CAP定理描述了一个三角形，其角代表<strong class="kw iu">一致性</strong>、<strong class="kw iu">可用性</strong>和<strong class="kw iu">分区容差</strong>。如果在向客户端确认写访问之前，先将写访问复制到所有其他应用程序节点，则分布式应用程序表现一致(一致性)。分布式系统的所有节点总是能够提供一致的响应。</p><p id="1dce" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">另一方面，可用性描述了分布式系统可以在任何时候对读和写请求做出反应——不会因为系统的状态而有任何等待时间或被拒绝的请求。最后，分区容差要求分布式应用程序即使在单个节点出现故障或它们之间的网络连接中断时也能继续运行。</p><p id="9f5b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">CAP定理现在声明这三个方面中只有两个是可能的。特别是，这意味着一个始终一致和可用的系统(CA)只有在您能够排除任何硬件故障的情况下才是可能的，而这实际上是不可能的。因此，在实践中，您只能在CP和AP之间进行选择，也就是说，如果服务器或网络出现故障，分布式系统是否应该放弃可用性或一致性。</p><p id="fa71" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">缺乏一致性乍听起来很危险，但这是“没有一致性”，而是一种“延迟一致性”。最后，一旦故障服务器再次可用，一致性就会恢复。</p><p id="b70d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">只要您不是为高度安全关键领域(公共基础设施、医疗系统……)开发应用程序，最终的一致性应该不是问题。放弃总是有保证的强一致性会导致更易访问和反应性更强的应用程序，这可能是一个很大的(商业)优势，尤其是在web和云环境中。还应该记住，现实只在极少数情况下表现出绝对的一致性。</p><h1 id="bd66" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">为什么是CQRS？</h1><p id="d912" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">最后，问题仍然是为什么要和CQRS打交道。一个显而易见的原因是它对其他几个概念如DDD、事件源和GraphQL的补充。此外，通过从一开始就将写作和阅读分开，CQRS的目标是分布式架构，使其非常适用于运行在网络或云上的基于服务的系统。</p><p id="7ec3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，CQRS也提供了<strong class="kw iu">微服务架构</strong>的所有优势，比如单个服务的可伸缩性、可维护性和可测试性。使用CQRS，不同版本的业务逻辑的操作也很容易，并且可以明确限制单个服务的访问权限，这反过来有利于整个系统的安全性。</p><p id="dd54" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然而，缺点在于固有的比传统的客户机-服务器系统更复杂的体系结构——但是应该记住，CQRS也有几个优点，但这是有代价的。</p><p id="2a2f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">CQRS最大的优势之一是将技术代码和业务代码分开的可能性，特别是在DDD和事件外包方面。因此，业务逻辑可以在不改变技术基础结构的情况下进行调整。同样适用，更重要的是，反之亦然，有利于商业逻辑的长期稳定和绝对自信。</p><p id="fa6e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">由于上面提到的复杂性，建议您考虑是否在已经实现了CQRS和事件源的合适框架上构建您的应用程序，以便作为开发人员，您可以主要专注于设计和编写技术代码。这种框架可用于许多技术、语言和平台，如Spring (Java)或NestJS (TypeScript，NodeJS)。</p><h1 id="4e9d" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">结论</h1><p id="9392" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">CQRS是一种令人兴奋的分布式架构方法，可以发挥其优势，特别是DDD和事件源。尽管复杂性超过了传统的客户机-服务器体系结构，但您也可以获得一个更具可伸缩性的应用程序，它始终能更好地映射基本功能。</p><p id="37c1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">感谢您阅读我关于CQRS的文章。我希望你能从中吸取一些东西。关注更多。</p><p id="7b13" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">干杯！</p></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="596e" class="ls lt it bd lu lv mw lx ly lz mx mb mc jz my ka me kc mz kd mg kf na kg mi mj bi translated">接下来阅读</h1><div class="nb nc gp gr nd ne"><a rel="noopener  ugc nofollow" target="_blank" href="/microservices-with-cqrs-in-typescript-and-nestjs-5a8af0a56c3a"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd iu gy z fp nj fr fs nk fu fw is bi translated">CQRS微服务和NestJS类型脚本中的事件源</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">基于领域驱动设计、CQRS和事件源的简单银行API</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="nn l"><div class="no l np nq nr nn ns ks ne"/></div></div></a></div><div class="nb nc gp gr nd ne"><a rel="noopener  ugc nofollow" target="_blank" href="/domain-driven-design-in-software-development-f92c3f58d012"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd iu gy z fp nj fr fs nk fu fw is bi translated">微服务:深入领域驱动的设计</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">软件开发背景下的领域驱动设计</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="nn l"><div class="nt l np nq nr nn ns ks ne"/></div></div></a></div><div class="nb nc gp gr nd ne"><a rel="noopener  ugc nofollow" target="_blank" href="/basics-of-event-sourcing-12ebe0b86788"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd iu gy z fp nj fr fs nk fu fw is bi translated">什么是活动采购(为什么)?</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">深入了解活动采购</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="nn l"><div class="nu l np nq nr nn ns ks ne"/></div></div></a></div></div><div class="ab cl mp mq hx mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="im in io ip iq"><h1 id="94a8" class="ls lt it bd lu lv mw lx ly lz mx mb mc jz my ka me kc mz kd mg kf na kg mi mj bi translated">分级编码</h1><p id="bcaf" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">感谢您成为我们社区的一员！升级正在改变技术招聘。<a class="ae nv" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="kw iu">在最好的公司</strong>找到你最理想的工作 </a> <strong class="kw iu">。</strong></p><div class="nb nc gp gr nd ne"><a href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener  ugc nofollow" target="_blank"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd iu gy z fp nj fr fs nk fu fw is bi translated">升级-改变技术招聘</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">升级-改变技术招聘🔥使软件工程师能够找到完美的角色…</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">作业. levelup.dev</p></div></div><div class="nn l"><div class="nw l np nq nr nn ns ks ne"/></div></div></a></div></div></div>    
</body>
</html>