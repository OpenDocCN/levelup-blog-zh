<html>
<head>
<title>JavaScript Best Practices — Performance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript最佳实践—性能</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-best-practices-performance-a549bc87ed20?source=collection_archive---------3-----------------------#2020-02-05">https://levelup.gitconnected.com/javascript-best-practices-performance-a549bc87ed20?source=collection_archive---------3-----------------------#2020-02-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/806fc6bbdcad5c5a0ac1a6f6b5e784e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*R3M8eY2xJoK7YKGw"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@harleydavidson?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">哈雷戴维森</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="1ae4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">像任何其他编程语言一样，JavaScript有自己的最佳实践列表，使程序更容易阅读和维护。JavaScript有很多棘手的部分，所以我们应该避免降低代码质量的事情。通过遵循最佳实践，我们可以创建优雅且易于管理的代码，任何人都可以轻松使用。</p><p id="97a7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这篇文章中，我们将看看如何提高我们的应用程序的性能。动作包括在变量中缓存数据，使用最快的方式遍历变量，减少页面上的DOM访问和元素，以及推迟脚本加载。</p><h1 id="f0a6" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">减少对变量和属性的访问</h1><p id="293f" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们应该减少在应用程序中访问变量和对象属性的次数。</p><p id="ac5b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是因为每次我们这样做时，CPU必须一次又一次地访问内存中的项目来计算结果。</p><p id="fb38" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我们应该尽可能少地这样做。</p><p id="e19f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有一个循环，我们不应该写如下:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="3df7" class="mq lf it mm b gy mr ms l mt mu">for (let i = 0; i &lt; arr.length; i++) {</span><span id="6bd1" class="mq lf it mm b gy mv ms l mt mu">}</span></pre><p id="4c62" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">相反，我们应该写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="2d2f" class="mq lf it mm b gy mr ms l mt mu">let length = arr.length;<br/>for (let i = 0; i &lt; length; i++) {</span><span id="e3d9" class="mq lf it mm b gy mv ms l mt mu">}</span></pre><p id="b8a2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这样，<code class="fe mw mx my mm b">arr.length</code>在我们的循环中只被引用一次，而不是在每次迭代中访问它。</p><h1 id="4302" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">遍历变量的最快方法</h1><p id="3c0e" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">在JavaScript中，有多种方法可以遍历iterable对象。一个是传统的<code class="fe mw mx my mm b">for</code>循环。其他方法包括<code class="fe mw mx my mm b">for...of</code>循环，数组的<code class="fe mw mx my mm b">forEach</code>方法。<code class="fe mw mx my mm b">map</code>和<code class="fe mw mx my mm b">filter</code>也在映射和过滤操作完成时循环遍历数组。还有一个<code class="fe mw mx my mm b">while</code>循环。</p><p id="ce74" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在所有运行循环的方法中，<code class="fe mw mx my mm b">for</code>循环是最快的方法，不管有没有缓存<code class="fe mw mx my mm b">length</code>，就像我们上面做的那样。然而，缓存<code class="fe mw mx my mm b">length</code>有时会使循环执行得更好。</p><p id="86c0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一些浏览器引擎已经优化了<code class="fe mw mx my mm b">for</code>循环，但没有缓存length属性。</p><p id="fa39" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">步进递减的<code class="fe mw mx my mm b">while</code>循环大约比<code class="fe mw mx my mm b">for</code>循环慢1.5倍</p><p id="66a6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用<code class="fe mw mx my mm b">forEach</code>循环比<code class="fe mw mx my mm b">for</code>循环慢10倍，所以最好避免使用，尤其是对于大型数组。</p><p id="ba3f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以在这里看到结果<a class="ae kf" href="https://stackoverflow.com/questions/5349425/whats-the-fastest-way-to-loop-through-an-array-in-javascript" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="50d1" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">减少DOM访问</h1><p id="a5f3" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">访问DOM是一项开销很大的操作，因为浏览器必须从网页中获取元素，然后从中创建一个对象并返回它。</p><p id="d88f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了减少DOM访问，如果我们需要多次操作DOM节点对象，我们应该将它设置为一个变量。</p><p id="23d3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有下面的HTML，我们想在几秒钟后为它设置一些文本:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="dd4d" class="mq lf it mm b gy mr ms l mt mu">&lt;p id='foo'&gt;</span><span id="368a" class="mq lf it mm b gy mv ms l mt mu">&lt;/p&gt;</span></pre><p id="dca7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为此，我们可以编写以下代码:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="bf5e" class="mq lf it mm b gy mr ms l mt mu">const setText = (element, textContent) =&gt; {<br/>  return new Promise((resolve) =&gt; {<br/>    setTimeout(() =&gt; {<br/>      element.textContent = textContent;<br/>      resolve();<br/>    }, 3000)<br/>  })<br/>}</span><span id="a87b" class="mq lf it mm b gy mv ms l mt mu">(async () =&gt; {<br/>  const foo = document.querySelector('#foo');<br/>  await setText(foo, 'foo');<br/>  await setText(foo, 'bar');<br/>  await setText(foo, 'baz');<br/>})();</span></pre><p id="c822" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们有一个函数来获取我们想要操作的HTML元素，以及我们想要设置的文本内容。</p><p id="7118" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mw mx my mm b">setText</code>函数返回一个承诺，在3秒钟后将文本设置为给定的元素。</p><p id="39cf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们有一个<code class="fe mw mx my mm b">async</code>函数来设置文本3次。重要的部分是我们在每个调用中传递对元素的引用。这样我们就不必三次从网页中获取元素，这是一个开销很大的操作。</p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/616854635d3c5a77f6e1ed2cbe7a7abe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*B_bepUV9RP_u-Bxi"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@sawyerbengtson?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Sawyer Bengtson </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="9725" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">减小DOM大小</h1><p id="9eac" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">渲染DOM树很慢。因此，我们必须缩小树的大小。</p><p id="be9e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">除了让我们的网页尽可能简单之外，别无他法。</p><p id="5f7f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">较小的DOM使得用<code class="fe mw mx my mm b">querySelector</code>、<code class="fe mw mx my mm b">getElementById</code>或<code class="fe mw mx my mm b">getElementsByTagName</code>等方法搜索元素更快，因为要找的东西更少。</p><p id="0159" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，页面渲染性能也会提高，因为加载的内容更少了。对于手机和平板电脑等速度较慢的设备来说尤其如此。</p><h1 id="ed3f" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">不要声明不必要的变量</h1><p id="bac8" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">每次我们声明变量时，浏览器都必须为变量保留内存空间。因此，为了减少内存的使用，我们应该声明太多的变量。</p><p id="c0fb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有以下HTML:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="affe" class="mq lf it mm b gy mr ms l mt mu">&lt;div id='foo'&gt;<br/>  &lt;p&gt;</span><span id="53b6" class="mq lf it mm b gy mv ms l mt mu">  &lt;/p&gt;<br/>&lt;/div&gt;</span></pre><p id="1a74" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">并且我们想要设置<code class="fe mw mx my mm b">p</code>元素的文本内容，我们不应该这样写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="fff6" class="mq lf it mm b gy mr ms l mt mu">const foo = document.querySelector('#foo');<br/>const p = foo.querySelector('p');<br/>p.textContent = 'foo';</span></pre><p id="2886" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为我们有两个变量。这意味着我们的计算机必须存储2个JavaScript变量的值。</p><p id="4450" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">相反，我们可以通过编写以下代码来减少变量声明:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="1da2" class="mq lf it mm b gy mr ms l mt mu">document.querySelector('#foo p').textContent = 'foo';</span></pre><p id="9574" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我们所见，我们可以使用<code class="fe mw mx my mm b">querySelector</code>方法用CSS选择器选择任何东西。这意味着我们应该使用这个方法和相关的<code class="fe mw mx my mm b">querySelectorAll</code>方法来选择元素，因为它们都可以使用CSS选择器来选择任何HTML元素节点。</p><h1 id="f0bb" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">推迟加载脚本</h1><p id="293a" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">加载JavaScript文件是一项开销很大的操作。浏览器必须下载文件，解析内容，然后将其转换为机器代码并运行。</p><p id="cc9c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">浏览器会一行一行地下载一个文件，所以它会阻止任何其他操作的发生。</p><p id="b60d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以，要尽量拖延。我们可以通过将<code class="fe mw mx my mm b">script</code>标签放在末尾来做到这一点。同样，我们可以使用<code class="fe mw mx my mm b">script</code>标签上的<code class="fe mw mx my mm b">defer</code>属性来实现这一点。</p><p id="c224" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，我们可以在页面加载后运行脚本，方法是动态创建<code class="fe mw mx my mm b">script</code>元素，并按如下方式添加:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="250b" class="mq lf it mm b gy mr ms l mt mu">window.onload = () =&gt; {<br/>  const element = document.createElement("script");<br/>  element.src = "<a class="ae kf" href="https://code.jquery.com/jquery-1.12.4.min.js" rel="noopener ugc nofollow" target="_blank">https://code.jquery.com/jquery-1.12.4.min.js</a>";<br/>  document.body.appendChild(element);<br/>};</span></pre><p id="ae0f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">任何可以在页面加载后加载的内容都可以使用这种脚本加载方法。</p><p id="08e9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以通过做一些事情来加速我们的页面。首先，我们可以在变量中缓存数据，这样我们就不必重复访问它们。然后我们可以用<code class="fe mw mx my mm b">for</code>循环更快地遍历条目。</p><p id="4814" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，我们可以减小DOM的大小，以减少需要加载的项目。我们还可以通过将DOM对象赋给变量来缓存它们。</p><p id="d962" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们也不应该声明不必要的变量，我们应该尽可能推迟脚本的加载，这样就不会耽误我们的浏览器。</p></div></div>    
</body>
</html>