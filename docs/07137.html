<html>
<head>
<title>The Ultimate Webpack Tutorial: Understanding the Wizard Behind the Magic of Modern Javascript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">终极Webpack教程:理解现代Javascript魔力背后的向导</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/the-ultimate-webpack-tutorial-understanding-the-wizard-behind-the-magic-of-modern-javascript-a0efd12a2cdc?source=collection_archive---------16-----------------------#2021-01-26">https://levelup.gitconnected.com/the-ultimate-webpack-tutorial-understanding-the-wizard-behind-the-magic-of-modern-javascript-a0efd12a2cdc?source=collection_archive---------16-----------------------#2021-01-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="621a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本文中，我们将了解webpack是什么，以及它的魔力如何革新了React、Vue.js、Angular等Javascript库和框架。我们将尝试将webpack作为一个独立的捆绑包，从零开始创建一个用于生产的捆绑包。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/cacaf02aa5a16dc962a3a09109995a7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4RqQlH2oKdgMyuxq2xugKQ.jpeg"/></div></div></figure><p id="af29" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">过去，浏览器在处理Javascript时非常得心应手。对于用户的几乎每一个动作，浏览器都会向服务器发送一个请求，服务器将处理应用程序背后的逻辑，用有限的Javascript构建一个新的HTML页面，然后将其发送回客户端。页面中包含的Javascript代码仅限于隐藏/显示一些元素、验证输入、处理简单计算或其他琐碎任务。</p><p id="f879" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">随着时间的推移，更多的任务从服务器端转移到了客户端。这极大地改善了用户体验，因为用户的每个动作，浏览器都在本地处理逻辑并相应地修改网站。向服务器发送请求的需求减少了，因此消除了请求-响应交换的时间延迟。</p><p id="1d5c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然而，这种改进是以代码复杂性为代价的。客户端处理的动作越多，浏览器中要执行的Javascript代码就越多。随着Javascript的增加，代码需要被分割到不同的文件中，有时需要数百个文件。这些大量的文件，在大多数情况下是相互依赖的，创建了一个非常复杂的依赖结构。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="6204" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">假设您正在导入所有这些相互依赖的文件。您很容易打乱导入它们的顺序，特别是当您试图在一段时间后维护代码和添加文件时。Webpack的建立就是为了解决web开发中的这个主要问题。</p><p id="85b9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Webpack是一个模块捆绑器。它获取所有Javascript文件，为它们创建模块，构建依赖关系图，并将它们捆绑到一个Javascript文件中，您可以在html中导入该文件，而不必再担心依赖关系。这不是Webpack的唯一功能。通过使用加载器，它还可以将其他文件扩展名转换为常见的Javascript，如Typescript和ES6。但是我们稍后会谈到这个。换句话说，Webpack对React、Vue.js和Angular的发展至关重要。</p><p id="2056" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">区别:web pack-dev-server vs . web pack CLI</strong></p><p id="43f9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">值得注意的是webpack开发服务器和webpack cli之间的区别。前者是一个在开发过程中本地运行的服务器，它通过允许我们访问额外的特性，如热模块重载和自动绑定，使我们在开发过程中的生活变得更加轻松。热模块重装就是每次开发者修改代码时，自动重装正在开发的app。自动绑定用于打包新的修改；它使用webpack-cli。另一方面，webpack cli是一个命令行工具，我们可以使用它将代码捆绑在一个文件中进行生产。</p><p id="4710" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">教程:使用webpack从零开始捆绑一个简单的代码</strong></p><p id="72b8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你曾经开发过React应用程序，你肯定用过webpack。React工具为您管理webpack，因此您可能还没有从头开始使用它。本教程是让你开始。</p><p id="a70e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您没有在本地安装webpack和webpack-cli，您需要首先安装它们。</p><pre class="kq kr ks kt gt ld le lf lg aw lh bi"><span id="8d5d" class="li lj it le b gy lk ll l lm ln"><em class="ko">npm init<br/>npm install --save-dev webpack<br/>npm install --save-dev webpack-cli</em></span></pre><p id="9b0e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们创建一个应用程序来计算阶乘(！)的一定数量:4！=4x3x2x1，并在浏览器的控制台中显示结果。</p><p id="e6a7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在项目主目录中，创建一个目录“src ”,我们将在这里放置Javascript源代码。我们将创建3个Javascript模块，一个定义乘法，一个定义阶乘积(取决于乘法)，一个调用特定整数参数的阶乘和乘法函数。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="lb lc l"/></div></figure><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="lb lc l"/></div></figure><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="e84b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">需要注意的是，在“index.js”中，“factorial”是在“multiply”之前以编程方式加载的。但是webpack会确保multiply会按照下面显示的依赖图加载。因此，它将忽略index.js中的第2行。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi lo"><img src="../Images/6046ea46ef02f2aeb4503255cf8a09d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9gS6qAPOG59B2Ppvk6olPA.jpeg"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated">依赖图</figcaption></figure><p id="f171" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们还需要做一件事来捆绑我们的代码。我们需要配置我们的webpack才能正常工作。在React或其他任何库或框架中，这部分完全由create-react-app之类的工具管理。我们需要在项目基本目录中(而不是在“src”中)创建一个webpack.config.js文件。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="3911" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这个配置文件中，我们告诉webpack从“index.js”开始解析依赖项，并将它与它在。/dist/ directory(意思是发行版，其他人可能称之为‘build’)，在一个名为bundle.js的文件中。</p><p id="ff6d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要启动捆绑:<br/><em class="ko">web pack-tutorial % npx web pack-config web pack . config . js</em></p><p id="7525" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在导入<em class="ko">。/dist/bundle.js </em>并检查应用程序是否正常工作。</p><p id="83f3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">使用装载机</strong></p><p id="97a4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">比方说，我们的Javascript文件是用ES6编写的(箭头函数)。为了能够捆绑这些文件，webpack需要将它们转换成公共的JS。因此，我们需要引用一个webpack可以用来进行这种转换的加载器。目前最受欢迎的是巴别塔。</p><p id="ef22" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了使用Babel loader，我们将需要3个依赖项:<code class="fe lt lu lv le b">babel-loader, babel-core,</code>和<code class="fe lt lu lv le b">babel-preset-es2015 </code>，因为我们想要处理ES2015代码并将其转换为ES5。</p><p id="44e2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">webpack配置文件修改如下:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="5338" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以看到loaders是一个数组，这意味着我们最终可以根据应用程序的需要使用任意多的加载器。</p><ul class=""><li id="d4f5" class="lw lx it js b jt ju jx jy kb ly kf lz kj ma kn mb mc md me bi translated"><code class="fe lt lu lv le b">test</code>:这是一个正则表达式，用于捕获带扩展名的文件名。仅js</li><li id="4a47" class="lw lx it js b jt mf jx mg kb mh kf mi kj mj kn mb mc md me bi translated"><code class="fe lt lu lv le b">loader</code>:要使用的加载器</li><li id="1f4f" class="lw lx it js b jt mf jx mg kb mh kf mi kj mj kn mb mc md me bi translated"><code class="fe lt lu lv le b">exclude</code>:我们不希望Babel处理node_modules下的任何文件</li><li id="1fef" class="lw lx it js b jt mf jx mg kb mh kf mi kj mj kn mb mc md me bi translated"><code class="fe lt lu lv le b">query.presets</code>:我们需要应用的巴别塔法则</li></ul><p id="65f3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是对Webpack实际能做什么的一个小介绍。下一个明显的实验是处理。css文件使用css-loader，Angular和Typescript文件，缩小和丑化代码。</p><p id="c2c4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们越来越努力地改善用户的UX/用户界面。随着业界大量使用不同的Javascript框架，我坚信Webpack是每个web开发人员的必备工具，现在比以往任何时候都更是如此。</p></div><div class="ab cl mk ml hx mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="im in io ip iq"><p id="7890" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">源代码:</strong><a class="ae mr" href="https://github.com/andgiete/webpack-tutorial" rel="noopener ugc nofollow" target="_blank">https://github.com/andgiete/webpack-tutorial</a></p></div></div>    
</body>
</html>