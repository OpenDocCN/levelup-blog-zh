<html>
<head>
<title>TypeScript 4.3 — I object, your honour!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">打字稿4.3 —我反对，法官大人！</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/typescript-4-3-i-object-your-honour-2db0368c07cb?source=collection_archive---------0-----------------------#2021-05-26">https://levelup.gitconnected.com/typescript-4-3-i-object-your-honour-2db0368c07cb?source=collection_archive---------0-----------------------#2021-05-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="0441" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了庆祝TypeScript 4.3，我看了一下TypeScript的面向对象特性，并看看这个版本带来的新特性。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/7e3b7f0755a595f35ab0503dd9c0fb57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ONRhkqT_fRWZYhC1.jpg"/></div></div></figure></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><p id="1838" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">TypeScript为面向对象编程和面向函数编程都提供了很好的支持(我不说函数编程，因为我不想让纯粹主义者追杀我)。</p><p id="9270" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这篇文章中，我将回顾TypeScript中的OO支持，并展示在<a class="ae le" href="https://devblogs.microsoft.com/typescript/announcing-typescript-4-3/" rel="noopener ugc nofollow" target="_blank"> TypeScript 4.3 </a>中提供的最新OO特性。</p><p id="e7a8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我将快速介绍:</p><ul class=""><li id="3be2" class="lf lg iq jp b jq jr ju jv jy lh kc li kg lj kk lk ll lm ln bi translated">基本类机制&amp;基于原型的系统</li><li id="ad8a" class="lf lg iq jp b jq lo ju lp jy lq kc lr kg ls kk lk ll lm ln bi translated">可访问性和参数属性</li><li id="c392" class="lf lg iq jp b jq lo ju lp jy lq kc lr kg ls kk lk ll lm ln bi translated">继承、类型和类型断言</li><li id="c935" class="lf lg iq jp b jq lo ju lp jy lq kc lr kg ls kk lk ll lm ln bi translated">访问器和4.3对不同类型的支持</li><li id="ac23" class="lf lg iq jp b jq lo ju lp jy lq kc lr kg ls kk lk ll lm ln bi translated">ECMAScript Private和4.3对方法和访问器的扩展</li><li id="bd46" class="lf lg iq jp b jq lo ju lp jy lq kc lr kg ls kk lk ll lm ln bi translated">4.3的新<code class="fe lt lu lv lw b">override</code>关键字</li></ul><h1 id="56ab" class="lx ly iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">打字稿OO评论</h1><h2 id="b5dd" class="mv ly iq bd lz mw mx dn md my mz dp mh jy na nb ml kc nc nd mp kg ne nf mt ng bi translated">类、对象和原型，天啊！</h2><p id="aef5" class="pw-post-body-paragraph jn jo iq jp b jq nh js jt ju ni jw jx jy nj ka kb kc nk ke kf kg nl ki kj kk ij bi translated">JavaScript中的面向对象编程总是有点奇怪，随着TypeScript成为JavaScript的超集，一些恐惧仍然悬而未决。</p><p id="a098" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">用于管理类的<a class="ae le" href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Object_prototypes" rel="noopener ugc nofollow" target="_blank">原型系统</a>来自其他面向对象的语言，如Java、C#或C++，可能会感觉奇怪。在JavaScript中，类实际上在内存中创建一个对象，就像任何其他对象一样，包含该类的所有实例共享的公共功能(通常是方法)。这个对象是<strong class="jp ir">原型</strong>，通过类的<code class="fe lt lu lv lw b">prototype</code>属性和所有实例的<code class="fe lt lu lv lw b">__proto__</code>属性来访问。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nm"><img src="../Images/938c4414584e7a49d9e30ae3ac0cc3e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*rpwGTVSXszEuZmvo.png"/></div></div></figure><p id="76ed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我们实例化一个类的对象时，我们实际上创建了一个新的<strong class="jp ir"> <em class="nn">空白</em> </strong>对象，但是这个空白对象有一个指向共享实例的原型，所以<em class="nn">继承了</em>它的行为。构造函数运行，通常用属性填充<em class="nn">空白</em>对象。</p><p id="02e0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在过去，这在我们实际上将类写成函数并操纵函数/类的原型时更为明显。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="bac9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当然，从ECMAScript 2015 (ES6)开始，我们有了合适的类语法:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="bfbf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种语法也适用于TypeScript:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="97d7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是要意识到底层的<em class="nn">行为</em>是相同的，有构造函数和原型对象。</p><h2 id="5d0f" class="mv ly iq bd lz mw mx dn md my mz dp mh jy na nb ml kc nc nd mp kg ne nf mt ng bi translated">可访问性、属性和参数属性</h2><p id="79f9" class="pw-post-body-paragraph jn jo iq jp b jq nh js jt ju ni jw jx jy nj ka kb kc nk ke kf kg nl ki kj kk ij bi translated">注意，在TypeScript的<code class="fe lt lu lv lw b">Circle</code>类中，我们必须定义一个<code class="fe lt lu lv lw b">radius</code>属性。此属性可以配置为私有、受保护或公共(默认为公共)。这些可访问性修饰符也适用于方法。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="a3c0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在构造函数中，通常情况下，我们用传递给构造函数的参数初始化<code class="fe lt lu lv lw b">radius</code>属性。这可以通过向构造器参数添加一个可访问性修饰符来简化，使其成为一个<a class="ae le" href="https://www.typescriptlang.org/docs/handbook/classes.html#parameter-properties" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">参数属性</strong> </a>。这消除了属性声明和初始化的需要。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="186f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们也可以将属性限定为<code class="fe lt lu lv lw b"><strong class="jp ir">readonly</strong></code>。这也有助于创建参数属性。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="bb97" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我们也可以在构造函数之外初始化属性。甚至使用其他属性和方法。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="no np l"/></div></figure><h2 id="ad3e" class="mv ly iq bd lz mw mx dn md my mz dp mh jy na nb ml kc nc nd mp kg ne nf mt ng bi translated">遗产</h2><p id="33f4" class="pw-post-body-paragraph jn jo iq jp b jq nh js jt ju ni jw jx jy nj ka kb kc nk ke kf kg nl ki kj kk ij bi translated"><a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain" rel="noopener ugc nofollow" target="_blank">原型链支持OO继承</a>，使用<code class="fe lt lu lv lw b">extends</code>很容易实现。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="no np l"/></div></figure><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nm"><img src="../Images/24f5fe0af544e8a19111b08a058dbb54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dTSOSaIdgoT6k3Em.gif"/></div></div></figure><h2 id="bad8" class="mv ly iq bd lz mw mx dn md my mz dp mh jy na nb ml kc nc nd mp kg ne nf mt ng bi translated">铅字里有什么</h2><p id="d32e" class="pw-post-body-paragraph jn jo iq jp b jq nh js jt ju ni jw jx jy nj ka kb kc nk ke kf kg nl ki kj kk ij bi translated">对于TypeScript中的类，要记住的一个关键概念是，由于其原型，对象<em class="nn">是类的实例</em>。</p><p id="ad77" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，当我们从JSON中反序列化时，我们正在重新创建与我们编写的任何类都没有链接的对象。它们将<strong class="jp ir">而不是</strong>作为序列化之前最初创建它们的类的实例出现，并且它们没有任何方法。</p><p id="a316" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">即使我们包含了类型断言，也是如此。认识到类型断言不是强制转换；我们只是做一个断言。我们通知编译器一些它自己不能推断的事情。这通常发生在I/O边界或者调用非类型化的JavaScript时。然而，我们有可能给出不正确的信息——比如断言一个基本对象是一个类的实例。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="3aad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是为什么在传输数据时使用没有方法的<strong class="jp ir">接口</strong>通常更好。您可能会发现，由于这个原因，使用TypeScript时，您倾向于使用更加面向函数的方法，使用遵循接口的基本对象和将这些对象作为输入的自由函数。</p><h1 id="80ac" class="lx ly iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">最新功能</h1><h2 id="a089" class="mv ly iq bd lz mw mx dn md my mz dp mh jy na nb ml kc nc nd mp kg ne nf mt ng bi translated">带转换的访问器</h2><p id="8721" class="pw-post-body-paragraph jn jo iq jp b jq nh js jt ju ni jw jx jy nj ka kb kc nk ke kf kg nl ki kj kk ij bi translated">访问器对于提供一个像属性一样使用的接口很有用，但是其背后有更复杂的逻辑。使用<code class="fe lt lu lv lw b">get</code>和/或<code class="fe lt lu lv lw b">set</code>，我们可以将属性绑定到getter和/或setter函数。例如，这在创建计算属性时非常有用。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="6a2e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这里，<code class="fe lt lu lv lw b">diameter</code>看起来和感觉上都像是消费者的属性，但实际上它调用的是读写<code class="fe lt lu lv lw b">radius</code>的函数。</p><p id="b5ef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">TypeScript 4.3增加了对setter类型多于getter类型的支持。这对于支持编写最终将被转换为规范类型的多种数据类型非常有用。比如下面，我们可以把<code class="fe lt lu lv lw b">diameter</code>写成一个数字或者字符串，但是我们总是读回一个数字。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="530f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然您不希望在任何地方都这样做，但是用类似的行为包装现有的API是很有用的。在4.3中，我们还支持在一个接口中指定单独的getter和setter类型。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="d640" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">唯一的限制是getter类型<em class="nn">必须</em>可分配给setter类型。</p><h2 id="b101" class="mv ly iq bd lz mw mx dn md my mz dp mh jy na nb ml kc nc nd mp kg ne nf mt ng bi translated">真正的私有成员</h2><p id="399d" class="pw-post-body-paragraph jn jo iq jp b jq nh js jt ju ni jw jx jy nj ka kb kc nk ke kf kg nl ki kj kk ij bi translated">值得注意的是，像TypeScript中的许多东西一样，<code class="fe lt lu lv lw b">private</code>和<code class="fe lt lu lv lw b">protected</code>修饰符只在编译时适用。他们在那里帮助和保护开发者。在运行时，当所有内容都被转换成JavaScript时，所有属性都将存在于对象中，并且是可访问的。这包括我们将对象序列化到JSON的时候。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="b72a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">连载出来的是:</p><pre class="km kn ko kp gt nq lw nr ns aw nt bi"><span id="32e4" class="mv ly iq lw b gy nu nv l nw nx">{<br/>    "key": "123",<br/>    "id": "abc"<br/>}</span></pre><p id="68a9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了提供真正的隐私，TypeScript在版本<a class="ae le" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-8.html#ecmascript-private-fields" rel="noopener ugc nofollow" target="_blank"> 3.8 </a>中增加了对<a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Private_class_fields" rel="noopener ugc nofollow" target="_blank"> ECMAScript私有字段</a>的支持。这只是JavaScript的第三阶段提案(在撰写本文时),但从3.8版本开始，它就是类型脚本语言的一部分。这些字段以<code class="fe lt lu lv lw b">#</code>为前缀。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="be40" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这存储了对象外部的字段/属性的值，所以当我们序列化时，私有字段不存在。因此，这个<code class="fe lt lu lv lw b">Secrets</code>类的一个实例连续出现如下:</p><pre class="km kn ko kp gt nq lw nr ns aw nt bi"><span id="7a28" class="mv ly iq lw b gy nu nv l nw nx">{}</span></pre><p id="1e56" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将它编译成旧的JavaScript很有趣——它为每个字段创建了一个模块级<code class="fe lt lu lv lw b">WeakMap</code>,一个对象必须在这个结构中查找它的字段值，使用它自己作为键。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="8e35" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae le" href="https://devblogs.microsoft.com/typescript/announcing-typescript-4-3/" rel="noopener ugc nofollow" target="_blank"> TypeScript 4.3 </a>扩展了ECMAScript私有支持，以包括方法和访问器。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="no np l"/></div></figure><h2 id="9f70" class="mv ly iq bd lz mw mx dn md my mz dp mh jy na nb ml kc nc nd mp kg ne nf mt ng bi translated">覆盖中的清晰度</h2><p id="ce53" class="pw-post-body-paragraph jn jo iq jp b jq nh js jt ju ni jw jx jy nj ka kb kc nk ke kf kg nl ki kj kk ij bi translated">在TypeScript 4.3之前，当在子类中重写方法时，只需使用相同的名称。当基类改变但子类没有更新时，这可能会导致细微的错误。例如，当基类方法被移除时。</p><p id="1c00" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">TypeScript 4.3引入了<code class="fe lt lu lv lw b">override</code>关键字来显式地将方法标记为被重写。如果没有合适的基本条目可以覆盖，则会标记一个错误。这也能更好地向读者传达意图。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="e01f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了避免中断-改变，当一个方法在没有这个关键字的情况下覆盖一个基方法<em class="nn">时，一个新的编译器开关<code class="fe lt lu lv lw b">--noImplicitOverride</code>会标记错误。</em></p><h1 id="2f80" class="lx ly iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">结论</h1><p id="baf0" class="pw-post-body-paragraph jn jo iq jp b jq nh js jt ju ni jw jx jy nj ka kb kc nk ke kf kg nl ki kj kk ij bi translated">我希望这是对TypeScript中面向对象支持的有用总结。如您所见，TypeScript 4.3为这种范式增加了一些有用的特性。</p><p id="b630" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你还没有这样做，看看我的帖子，展示了<a class="ae le" href="https://medium.com/swlh/crazy-powerful-typescript-4-1-features-26036f4de6bc" rel="noopener"> TypeScript 4.1 </a>和<a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/crazy-powerful-typescript-tuple-types-9b121e0a690c"> TypeScript 4.2 </a>中一些有用的特性。</p><p id="6177" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另外，一定要看看我们的<a class="ae le" href="https://instil.co/courses/typescript-introduction/" rel="noopener ugc nofollow" target="_blank">打字稿</a>课程。我们也很乐意使用TypeScript提供<a class="ae le" href="https://instil.co/courses/introduction-to-angular/" rel="noopener ugc nofollow" target="_blank"> Angular </a> &amp; <a class="ae le" href="https://instil.co/courses/react-with-typescript/" rel="noopener ugc nofollow" target="_blank"> React培训</a>。我们几乎为世界各地的公司提供服务，并且很乐意根据您团队的水平和具体需求定制我们的课程。来看看我们是否能帮助你和你的团队。</p><p id="2a6d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">原贴<a class="ae le" href="https://instil.co/blog/typescript-43-objects/" rel="noopener ugc nofollow" target="_blank">此处</a>。</p></div></div>    
</body>
</html>