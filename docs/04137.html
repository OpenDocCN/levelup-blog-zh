<html>
<head>
<title>How to build a secure, serverless, persistent and real-time single-page chat</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何建立一个安全，无服务器，持久和实时的单页聊天</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/multichat-a-secure-serverless-persistent-and-real-time-chat-proof-of-concept-22d3dddc0345?source=collection_archive---------7-----------------------#2020-06-11">https://levelup.gitconnected.com/multichat-a-secure-serverless-persistent-and-real-time-chat-proof-of-concept-22d3dddc0345?source=collection_archive---------7-----------------------#2020-06-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9807" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用WebRTC、PeerJS、Vue和javascript vanilla cookies不到3个小时</h2></div></div><div class="ab cl kf kg hu kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="ij ik il im in"><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/928d9a720f3e3a4e724bd3098b4d5df2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3Wqd6ge_J1lIhc-4KavNQw.jpeg"/></div></div></figure><p id="7898" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">今天的互联网基础设施依赖于数据中心，而数据中心有着<strong class="la ir">成本</strong>和<strong class="la ir">环境影响</strong>。更具体地说，<a class="ae lu" href="https://www.climatechangenews.com/2017/12/11/tsunami-data-consume-one-fifth-global-electricity-2025/" rel="noopener ugc nofollow" target="_blank">数据中心负责大约。4%的世界能源消耗</a>，并且还在增长。但是，如果没有你每天的狂看点播电视，你会怎样度过你的一天呢？</p><blockquote class="lv"><p id="d326" class="lw lx iq bd ly lz ma mb mc md me lt dk translated">如果我们可以在不需要服务器的情况下通信/交换数据会怎么样？如果个人数据可以存储在本地，远离大公司的数据中心，会怎么样？</p></blockquote><p id="41c0" class="pw-post-body-paragraph ky kz iq la b lb mf jr ld le mg ju lg lh mh lj lk ll mi ln lo lp mj lr ls lt ij bi translated">幸运的是，由于点对点连接是互联网的基础，有些人比我更早想到这一点；这导致了<a class="ae lu" href="https://webrtc.org/" rel="noopener ugc nofollow" target="_blank"><strong class="la ir"><em class="mk">WebRTC</em></strong></a>的发展。在本文中，我将介绍WebRTC的优势，并通过一个简单、易用、安全、几乎无服务器、持久的实时聊天概念验证来展示它的威力。但是，WebRTC的也有自己的局限性；但这是另一个后来的故事。</p><blockquote class="ml mm mn"><p id="b154" class="ky kz mk la b lb lc jr ld le lf ju lg mo li lj lk mp lm ln lo mq lq lr ls lt ij bi translated">我能理解这篇文章吗？</p></blockquote><p id="dcf6" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在本文中，我涵盖了大型全栈开发主题，这些主题需要一些互联网通信、javascript数据、状态管理以及HTML/CSS方面的知识。如果你没有全部，你会学到一些有用的技巧和窍门！</p></div><div class="ab cl kf kg hu kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="ij ik il im in"><h1 id="5cd3" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">挑战</h1><p id="67fb" class="pw-post-body-paragraph ky kz iq la b lb nj jr ld le nk ju lg lh nl lj lk ll nm ln lo lp nn lr ls lt ij bi translated">该项目的目标是简化和演示浏览器中无服务器数据交换的<em class="mk">功能、安全性/保密性</em>和<em class="mk">持久性</em>。以下是我选择的标准的完整列表:</p><ul class=""><li id="d732" class="no np iq la b lb lc le lf lh nq ll nr lp ns lt nt nu nv nw bi translated">带有用户名的基本聊天应用程序</li><li id="5b16" class="no np iq la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated">任何用户必须能够加入任何其他用户(在聊天室)</li><li id="b093" class="no np iq la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated">安全:数据交换必须加密</li><li id="d9a1" class="no np iq la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated"><strong class="la ir">持续性:</strong>数据必须在整个会话期间保存(用户名、聊天)</li><li id="c6a3" class="no np iq la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated">无服务器:数据必须在不需要服务器的情况下在对等体之间交换</li><li id="ddd4" class="no np iq la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated">简单:任何人都必须能够在没有任何知识的情况下使用这个项目</li></ul></div><div class="ab cl kf kg hu kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="ij ik il im in"><h1 id="4a77" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">解决方案</h1><p id="3241" class="pw-post-body-paragraph ky kz iq la b lb nj jr ld le nk ju lg lh nl lj lk ll nm ln lo lp nn lr ls lt ij bi translated">我设计了最简单的解决方案来满足前面的要求，使用:</p><ul class=""><li id="dfd0" class="no np iq la b lb lc le lf lh nq ll nr lp ns lt nt nu nv nw bi translated"><a class="ae lu" href="https://webrtc.org/" rel="noopener ugc nofollow" target="_blank"><strong class="la ir"/></a>WebRTC，用于安全、可靠、无服务器的数据交换</li><li id="ab1e" class="no np iq la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated"><a class="ae lu" href="https://vuejs.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="la ir"> Vue.js </strong> </a>，用于快速&amp;轻量级动态渲染和状态管理</li><li id="17ac" class="no np iq la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated"><a class="ae lu" href="https://peerjs.com" rel="noopener ugc nofollow" target="_blank"> <strong class="la ir"> PeerJS </strong> </a>，用于简化WebRTC上的开发</li><li id="3482" class="no np iq la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated"><a class="ae lu" href="https://materializecss.com/" rel="noopener ugc nofollow" target="_blank"><strong class="la ir">【materialiecss】</strong></a>，用于快速现代设计</li><li id="aad4" class="no np iq la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated"><a class="ae lu" href="https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage" rel="noopener ugc nofollow" target="_blank"><strong class="la ir">JavaScript local storage</strong></a>，用于数据持久性</li></ul><p id="97c2" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">WebRTC是谷歌浏览器内对等通信的开源基础，使用<a class="ae lu" href="https://en.wikipedia.org/wiki/QUIC" rel="noopener ugc nofollow" target="_blank"> QUIC协议</a>(最新的、快速的&amp;可靠的<a class="ae lu" href="https://en.wikipedia.org/wiki/Transport_layer" rel="noopener ugc nofollow" target="_blank">传输层</a> <a class="ae lu" href="https://en.wikipedia.org/wiki/Network_protocol" rel="noopener ugc nofollow" target="_blank">网络协议</a>)。几乎每一个像样的浏览器都支持它，它提供了一种在支持任何类型数据(包括实时音频和视频)的两个浏览器(对等体)之间建立数据通道的方法。</p><p id="59ac" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">PeerJS提供了一种将客户机连接到服务器端点的方法，等待来自其他客户机的对等连接。一旦建立了连接，两个对等体就通过WebRTC数据通道进行通信，只有它们可以读/写。</p></div><div class="ab cl kf kg hu kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="ij ik il im in"><h1 id="44dd" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">代码</h1><p id="64e5" class="pw-post-body-paragraph ky kz iq la b lb nj jr ld le nk ju lg lh nl lj lk ll nm ln lo lp nn lr ls lt ij bi translated">让我们从创建网页的框架开始:因为我们想要一个单页面应用程序，我们将在一个index.html文件中编写所有的CSS代码<strong class="la ir">和</strong> JS代码。我们还需要在html中导入每个依赖项。我们的主体将包含一个主<em class="mk"> #app </em> div。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="oc od l"/></div><figcaption class="oe of gj gh gi og oh bd b be z dk translated">主应用程序框架</figcaption></figure><p id="3c39" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">然后，我们需要为用户管理两个屏幕:登录屏幕和聊天屏幕(因为我们不希望用户在登录后更改用户名)。为此，我选择在应用程序的状态中存储一个屏幕变量，该值指示要显示的屏幕。</p><blockquote class="ml mm mn"><p id="57ef" class="ky kz mk la b lb lc jr ld le lf ju lg mo li lj lk mp lm ln lo mq lq lr ls lt ij bi translated">你不应该这样做！通常，我们为2个不同的屏幕创建2个不同的组件，并使用Vue的路由器在它们之间切换。为了简单起见，我选择简单地创建一个组件来允许我直接访问我的应用程序的所有状态！</p></blockquote><p id="4bb1" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">因此，我们可以创建两个屏幕，放在我们的<em class="mk"> #app </em>中:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="oc od l"/></div><figcaption class="oe of gj gh gi og oh bd b be z dk translated">index.html渲染</figcaption></figure><p id="6bee" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">如果您忽略所有的样式类和图标，您会发现一些在我们的屏幕中使用的Vue变量和函数:</p><ul class=""><li id="41ee" class="no np iq la b lb lc le lf lh nq ll nr lp ns lt nt nu nv nw bi translated"><em class="mk">屏幕</em>:包含显示屏幕名称的变量</li><li id="d35e" class="no np iq la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated"><em class="mk">用户名输入</em>:用户输入的用户名(登录后必须保持不变)</li><li id="bd72" class="no np iq la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated"><em class="mk"> peerError </em>:发生错误时显示的消息</li><li id="e569" class="no np iq la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated"><em class="mk">加载</em>:一个布尔值，表示应用是否正在加载</li><li id="2ab5" class="no np iq la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated"><em class="mk"> targetIdInput </em>:输入要连接的目标用户名</li><li id="f8cf" class="no np iq la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated">peerIds :我们所连接的对等id列表</li><li id="32cf" class="no np iq la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated"><em class="mk">聊天</em>:聊天对象列表(发送者、消息)</li><li id="765b" class="no np iq la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated"><em class="mk">聊天消息输入</em>:用户当前输入的聊天消息</li><li id="4d1c" class="no np iq la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated"><em class="mk"> submitLogin </em>:在提交登录表单时调用，触发适当的javascript事件</li><li id="57f9" class="no np iq la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated"><em class="mk"> submitConnection </em>:连接表单提交时调用，连接目标客户端(<em class="mk"> targetIdInput </em>)</li><li id="9131" class="no np iq la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated"><em class="mk"> submitChat </em>:发送聊天消息时调用(通过聊天表单提交)</li></ul><p id="271e" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">有了这些变量和函数，我们就能够运行我们的应用程序了。让我们来编写应用程序的实例化和渲染逻辑！首先，我们需要考虑它将如何工作:</p><ul class=""><li id="f5fe" class="no np iq la b lb lc le lf lh nq ll nr lp ns lt nt nu nv nw bi translated">每个用户都有一个用户名，每个对等方(浏览器)都有一个id，用于在信令服务器上唯一地标识它，由对等方使用。使用用户名和对等id会很方便。但是为了确保规模上的唯一性和可用性(信令服务器不仅仅由我们使用)，我们必须为每个用户名添加一个唯一的前缀，这样我们就可以获得一个几乎唯一的对等id。为了做到这一点，我们简单地编写了两个util函数，我们可以用它们将对等id转换成用户名，反之亦然。我们将它们作为Vue组件的方法来编写，以便能够在渲染时使用它们。</li><li id="7298" class="no np iq la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated">我们想要一个持久的聊天，我们已经选择将数据保存为cookies。不幸的是，cookies只允许保存字符串。<br/>真巧，JavaScript天生允许我们序列化和反序列化JSON对象！让我们从“聊天”cookie中读取之前存储的聊天内容。最后，我们还可以使用cookies来存储我们以前使用的用户名，以便在我们的下一次会话中启动它(这就是下面要做的！)</li><li id="2e4c" class="no np iq la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated">我们希望每当收到新的聊天消息时，我们的聊天框自动向下滚动:每当<em class="mk"> chats </em>变量更新时，我们需要将我们的聊天框滚动到它的最大位置。为此，我们使用Vue的观察器，将观察器命名为<em class="mk"> chats() </em></li></ul><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="oc od l"/></div><figcaption class="oe of gj gh gi og oh bd b be z dk translated">index.html Vue应用程序行为和渲染逻辑</figcaption></figure><h2 id="177a" class="oi ms iq bd mt oj ok dn mx ol om dp nb lh on oo nd ll op oq nf lp or os nh ot bi translated">快到了！</h2><p id="729d" class="pw-post-body-paragraph ky kz iq la b lb nj jr ld le nk ju lg lh nl lj lk ll nm ln lo lp nn lr ls lt ij bi translated">让我们通过实现我们的应用程序的后台逻辑、实例化和连接对等体来完成这个简单的应用程序。但首先，让我们想一想:</p><ul class=""><li id="382b" class="no np iq la b lb lc le lf lh nq ll nr lp ns lt nt nu nv nw bi translated">我们必须跟踪我们拥有的每一个活动连接，并将它们映射到它们对应的远程对等体id。<br/> <em class="mk">但是我们已经存储了活动连接的远程对等体id！这不是多余的吗？<br/> </em>不幸的是，Vue没有提供一种直接的方法来跟踪赋予Vue数据对象的任何新属性。我的选择是将远程对等id映射到它们在Vue数据对象中对应的连接(<em class="mk">连接</em>)，以及在另一个Vue数据数组中独立的远程对等id(<em class="mk">peer ids</em>)(更新触发Vue组件渲染)。另一种选择是注册我们添加到<em class="mk">连接的属性(每次添加连接时使用<a class="ae lu" href="https://vuejs.org/v2/api/#Vue-set" rel="noopener ugc nofollow" target="_blank"><em class="mk">vue . set</em></a><em class="mk">)</em>，这将触发组件呈现。</em></li><li id="c49f" class="no np iq la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated">我们必须考虑对等连接；为了简单起见，我们在这里没有接受/拒绝连接。<br/>让我们考虑一下<strong class="la ir">爱丽丝</strong>和<strong class="la ir">大家</strong>在聊天室<strong class="la ir"> A </strong>和<strong class="la ir">鲍勃</strong>和<strong class="la ir">卡罗尔</strong>在聊天室<strong class="la ir"> B </strong>。连接过程简单来说就是:</li></ul><ol class=""><li id="e807" class="no np iq la b lb lc le lf lh nq ll nr lp ns lt ou nu nv nw bi translated">来自聊天室<strong class="la ir"> A </strong>的爱丽丝向来自聊天室<strong class="la ir"> B </strong>的鲍勃发送一份要约，其中包含聊天室<strong class="la ir">A</strong>(<strong class="la ir">所有人</strong>)中已连接用户的列表</li><li id="ba03" class="no np iq la b lb nx le ny lh nz ll oa lp ob lt ou nu nv nw bi translated"><strong class="la ir">鲍勃</strong>回答<strong class="la ir">爱丽丝</strong>的提议，并将提议发送给聊天室<strong class="la ir">A</strong>T49】鲍勃未连接到的<strong class="la ir">每个人</strong>，并列出聊天室<strong class="la ir">B</strong>(<strong class="la ir">Carole</strong>)中已连接的用户列表</li><li id="dffa" class="no np iq la b lb nx le ny lh nz ll oa lp ob lt ou nu nv nw bi translated"><strong class="la ir"> Alice </strong>现在连接到<strong class="la ir"> Bob </strong>并向<strong class="la ir"> Carole </strong>发送要约，其中包含Alice 连接到的用户列表(<strong class="la ir"> Bob，Everyone </strong>)</li><li id="fe69" class="no np iq la b lb nx le ny lh nz ll oa lp ob lt ou nu nv nw bi translated"><strong class="la ir">每个人</strong>回答<strong class="la ir">鲍勃</strong>的提议，以及每个人所连接的用户列表(<strong class="la ir">爱丽丝</strong>)</li><li id="b0ad" class="no np iq la b lb nx le ny lh nz ll oa lp ob lt ou nu nv nw bi translated">Carole 回答Alice 的提议，以及Carole 连接到的用户列表([ <strong class="la ir"> Bob </strong>)</li><li id="0c66" class="no np iq la b lb nx le ny lh nz ll oa lp ob lt ou nu nv nw bi translated"><strong class="la ir"> Carole </strong>现在连接到<strong class="la ir"> Alice </strong>并向<strong class="la ir"> Everyone </strong>发送要约，其中包含Carole 连接到的用户列表([ <strong class="la ir"> Alice，Bob </strong> ])</li><li id="b2da" class="no np iq la b lb nx le ny lh nz ll oa lp ob lt ou nu nv nw bi translated"><strong class="la ir"> Everyone </strong>回答<strong class="la ir"> Carole </strong>的提议，以及Everyone 与<strong class="la ir">的用户列表(<strong class="la ir"> Alice，Bob </strong>)</strong></li><li id="ec42" class="no np iq la b lb nx le ny lh nz ll oa lp ob lt ou nu nv nw bi translated">Carole 现在连接到<strong class="la ir">每个人</strong>(字面意思)</li></ol><ul class=""><li id="d2f3" class="no np iq la b lb lc le lf lh nq ll nr lp ns lt nt nu nv nw bi translated">最后，我们必须为我们的对等通信建立一种数据格式。<br/>对于这个项目来说，只说任何传递的数据必须包含一个<em class="mk">类型</em>属性就足够了。根据这个属性的值，我们将以不同的方式查询数据。</li></ul><blockquote class="ml mm mn"><p id="bd9e" class="ky kz mk la b lb lc jr ld le lf ju lg mo li lj lk mp lm ln lo mq lq lr ls lt ij bi translated">总是考虑两个通信端点之间的数据格式是一个有用的习惯，这样您就有了弹性的行为/解释。您不希望查询一个意外抛出错误的API！<br/>另外:如果你需要来自同一个端点的不同行为，也许你应该把你的端点分成两个不同的端点，每个端点都有自己的原子角色！</p></blockquote><p id="211b" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">您将在下面找到我们的主要Vue组件中缺少的方法列表，这些方法允许完全实现上述逻辑:</p><ul class=""><li id="ced0" class="no np iq la b lb lc le lf lh nq ll nr lp ns lt nt nu nv nw bi translated"><em class="mk"> initiateConnection </em>在提供连接时被调用。<br/>它必须实现已连接用户的初始列表发送(作为连接元数据)！</li><li id="5a64" class="no np iq la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated"><em class="mk">配置连接</em>在提供<strong class="la ir">和</strong>应答连接时被调用(用于注册数据和行为监听器)<br/>它必须使用接收到的连接用户列表(作为连接元数据)实现连接初始化！</li><li id="97eb" class="no np iq la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated">createPeer 还处理对等点配置，它本质上实现了当接收到提议时的自动应答(如果我们想要实现接受/拒绝屏幕，我们会停用它)</li></ul><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="oc od l"/></div></figure></div><div class="ab cl kf kg hu kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="ij ik il im in"><blockquote class="lv"><p id="dc2a" class="lw lx iq bd ly lz ma mb mc md me lt dk translated">因此，我们已经建立了一个持久的实时聊天webapp，但如果我们仍然需要一个信令服务器来建立连接，它是如何做到无服务器的呢？怎么才算真正安全？</p></blockquote><h1 id="aaae" class="mr ms iq bd mt mu ov mw mx my ow na nb jw ox jx nd jz oy ka nf kc oz kd nh ni bi translated">WebRTC当然不是无服务器的！</h1><p id="debf" class="pw-post-body-paragraph ky kz iq la b lb nj jr ld le nk ju lg lh nl lj lk ll nm ln lo lp nn lr ls lt ij bi translated">该解决方案的优势在于其简单性和安全性:</p><ul class=""><li id="b87a" class="no np iq la b lb lc le lf lh nq ll nr lp ns lt nt nu nv nw bi translated">任何用户都可以用用户名登录，并加入它认识的任何其他朋友</li><li id="02c6" class="no np iq la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated">任何用户都可以完全访问其聊天记录</li><li id="1b5a" class="no np iq la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated">数据交换是完全加密的，不能被中间人破解(更多信息请参见<a class="ae lu" href="https://webrtc-security.github.io/" rel="noopener ugc nofollow" target="_blank">WebRTC安全性研究</a></li></ul><p id="5c71" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">然而，类似的无服务器应用程序的许多方面仍有待讨论和重新思考:</p><ul class=""><li id="b983" class="no np iq la b lb lc le lf lh nq ll nr lp ns lt nt nu nv nw bi translated">你不会使用将数据存储为javascript cookies的应用程序！</li><li id="df19" class="no np iq la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated">仍然需要一个服务器来建立对等连接(参见<a class="ae lu" rel="noopener ugc nofollow" target="_blank" href="/webrtc-the-ice-framework-stun-and-turn-servers-10b2972483bb"> WebRTC: the ICE Framework，STUN and TURN Servers </a>了解更多原因)。在我们的例子中，我们默认使用高级PeerJS信令服务器，而不是低级STUN服务器(我们可以使用低级代码)</li><li id="71d9" class="no np iq la b lb nx le ny lh nz ll oa lp ob lt nt nu nv nw bi translated">交换的数据只能由对等体读取和写入，这就是为什么这个解决方案甚至不适合交换(例如)游戏数据(任何用户都可能作弊！)</li></ul><p id="d95a" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">这一点，以及WebRTC和更一般的此类无服务器应用程序所具有的所有限制，将在后面的故事中讨论！</p><p id="939c" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">你可以在这里找到这个应用程序的在线版本<a class="ae lu" href="https://multichat.milon.dev" rel="noopener ugc nofollow" target="_blank">，在</a><a class="ae lu" href="https://github.com/Rubilmax/peerjs-multichat" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上可以找到这个项目的资源库。</p></div></div>    
</body>
</html>