<html>
<head>
<title>Program GPIO on Raspberry Pi and Jetson Nano with Multiple Languages</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用多种语言在Raspberry Pi和Jetson Nano上编程GPIO</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/program-gpio-on-raspberry-pi-and-jetson-nano-with-multiple-languages-b937c456f96b?source=collection_archive---------5-----------------------#2020-05-14">https://levelup.gitconnected.com/program-gpio-on-raspberry-pi-and-jetson-nano-with-multiple-languages-b937c456f96b?source=collection_archive---------5-----------------------#2020-05-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="a23b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">已经有很多关于如何在Raspberry Pi或Jetson Nano上使用GPIO的文章，这个项目试图专注于如何简化事情并编写在这两个系统上运行的可移植程序。我们将构建一个简单的LED电路，由一个晶体管连接，其基极插入GPIO引脚，供我们的程序控制。</p><p id="37d9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将使用3种编程语言:<br/> 1。c编程语言<br/> 2。Python编程语言<br/> 3。Bash脚本</p><p id="f0f2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上述每个程序都将用于控制Raspberry Pi和Jetson Nano系统上的LED电路，以演示如何为这两个系统编写可移植的程序。</p><p id="ea6a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">图1两个系统演示</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/baff808dedea246cb84048aa53141fb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AfyP9Jj01X1ksX62zv5p0Q.jpeg"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">图1两个系统演示</figcaption></figure><h1 id="ed8e" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">1.系统配置</h1><h2 id="63cc" class="lz lc iq bd ld ma mb dn lh mc md dp ll jy me mf lp kc mg mh lt kg mi mj lx mk bi translated">树莓Pi 4型号B版本1.2 2019</h2><ul class=""><li id="2ecb" class="ml mm iq jp b jq mn ju mo jy mp kc mq kg mr kk ms mt mu mv bi translated">四核ARM 64位WiFi蓝牙(4GB)</li><li id="05fc" class="ml mm iq jp b jq mw ju mx jy my kc mz kg na kk ms mt mu mv bi translated">Linux raspberrypi 4.19.97-v7l+</li><li id="b367" class="ml mm iq jp b jq mw ju mx jy my kc mz kg na kk ms mt mu mv bi translated">gcc(Raspbian 8 . 3 . 0–6+rpi 1)8 . 3 . 0(用于C编程)</li><li id="aca5" class="ml mm iq jp b jq mw ju mx jy my kc mz kg na kk ms mt mu mv bi translated">RPi。GPIO安装在系统上(用于Python编程)</li></ul><h2 id="e1f9" class="lz lc iq bd ld ma mb dn lh mc md dp ll jy me mf lp kc mg mh lt kg mi mj lx mk bi translated">捷成纳米B01</h2><ul class=""><li id="e3dd" class="ml mm iq jp b jq mn ju mo jy mp kc mq kg mr kk ms mt mu mv bi translated">不带WiFi/BT的四核ARM 64位(4GB)</li><li id="5082" class="ml mm iq jp b jq mw ju mx jy my kc mz kg na kk ms mt mu mv bi translated">Linux jetsonnano 4.9.140-tegra</li><li id="bf2e" class="ml mm iq jp b jq mw ju mx jy my kc mz kg na kk ms mt mu mv bi translated">添加并配置了OKN WiFi 6 AX200 802.11ax WiFi卡</li><li id="3af7" class="ml mm iq jp b jq mw ju mx jy my kc mz kg na kk ms mt mu mv bi translated">gcc(Ubuntu/Linaro 7 . 5 . 0–3ubuntu 1 ~ 18.04)7 . 5 . 0(用于C编程)</li><li id="f422" class="ml mm iq jp b jq mw ju mx jy my kc mz kg na kk ms mt mu mv bi translated">还安装了以下GPIO包(用于Python编程)</li><li id="d90e" class="ml mm iq jp b jq mw ju mx jy my kc mz kg na kk ms mt mu mv bi translated">【https://github.com/NVIDIA/jetson-gpio T4】</li></ul><p id="4989" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">这两个系统都配置为通过WiFi进行SSH和VNC访问，因此它们可以在只连接电源线的情况下无头运行。</strong></p><h2 id="1017" class="lz lc iq bd ld ma mb dn lh mc md dp ll jy me mf lp kc mg mh lt kg mi mj lx mk bi translated">主机PC是Windows 10机器</h2><ul class=""><li id="17dc" class="ml mm iq jp b jq mn ju mo jy mp kc mq kg mr kk ms mt mu mv bi translated">安装并配置了TightVNC (v0.51.0)</li><li id="fc81" class="ml mm iq jp b jq mw ju mx jy my kc mz kg na kk ms mt mu mv bi translated">安装了VSCode (v1.45.0)</li><li id="00ed" class="ml mm iq jp b jq mw ju mx jy my kc mz kg na kk ms mt mu mv bi translated">VSCode中添加了远程SSH (v0.51.0)扩展</li></ul><p id="1b11" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有了以上配置，我可以通过以下三种方式在我的电脑上访问Raspberry Pi或Jetson Nano或两者:</p><ol class=""><li id="eadd" class="ml mm iq jp b jq jr ju jv jy nc kc nd kg ne kk nf mt mu mv bi translated">通过VSCode经由Remote-SSH；(附录中的图5)</li><li id="7d0b" class="ml mm iq jp b jq mw ju mx jy my kc mz kg na kk nf mt mu mv bi translated">通过命令行SSH(附录中的图6)</li><li id="f080" class="ml mm iq jp b jq mw ju mx jy my kc mz kg na kk nf mt mu mv bi translated">在绝对需要的时候通过TightVNC。(我们没有使用配置。在本项目中)(附录图7)</li></ol><h1 id="2689" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">2.LED电路设计</h1><h2 id="7480" class="lz lc iq bd ld ma mb dn lh mc md dp ll jy me mf lp kc mg mh lt kg mi mj lx mk bi translated">成分</h2><ul class=""><li id="09be" class="ml mm iq jp b jq mn ju mo jy mp kc mq kg mr kk ms mt mu mv bi translated">红色LED (x2)</li><li id="2c2a" class="ml mm iq jp b jq mw ju mx jy my kc mz kg na kk ms mt mu mv bi translated">晶体管NPN PN2222 (x2)</li><li id="8865" class="ml mm iq jp b jq mw ju mx jy my kc mz kg na kk ms mt mu mv bi translated">电阻器10K (x2) 330 (x2)</li><li id="fbb7" class="ml mm iq jp b jq mw ju mx jy my kc mz kg na kk ms mt mu mv bi translated">试验板(x1)</li><li id="34cd" class="ml mm iq jp b jq mw ju mx jy my kc mz kg na kk ms mt mu mv bi translated">母对公Depont线(x6)</li></ul><h2 id="3877" class="lz lc iq bd ld ma mb dn lh mc md dp ll jy me mf lp kc mg mh lt kg mi mj lx mk bi translated">设计</h2><p id="9ce6" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy ng ka kb kc nh ke kf kg ni ki kj kk ij bi translated">请注意，上述组件用于为Raspberry Pi和Jetson Nano系统构建两个相同的电路，如图1所示，您也可以只构建一个电路，然后一次手动切换到一个系统(附录中的图3和图4)。通过使用在线免费试用设计工具(<a class="ae nb" href="https://www.digikey.com/schemeit/project/" rel="noopener ugc nofollow" target="_blank">https://www.digikey.com/schemeit/project/</a>)，我们得到了图2所示的电路图。</p><p id="cca4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于这是一个非常简单的电路，一旦我们插上试验板上的所有元件，我们就可以将每个电路上的三条线连接到两个系统上相同的对应物理引脚:(如果您只是构建一个电路，您可以一次用一个系统测试您的电路和代码)。由于这是一个相当简单的电路，所以不打算解释细节。基本上，我们的软件程序使用晶体管的基极，通过系统板上的GPIO引脚控制LED的开关。</p><ol class=""><li id="ceff" class="ml mm iq jp b jq jr ju jv jy nc kc nd kg ne kk nf mt mu mv bi translated">线路图上显示“5V”的线的母端应插在系统板上的2号针脚上；</li><li id="09fb" class="ml mm iq jp b jq mw ju mx jy my kc mz kg na kk nf mt mu mv bi translated">线路图上显示“GND”的线的母端应插在系统板上的6号针脚上；</li><li id="734c" class="ml mm iq jp b jq mw ju mx jy my kc mz kg na kk nf mt mu mv bi translated">线路图上显示“至针脚12”的电线的母端应插入系统板上的针脚12。</li></ol><p id="188e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">(提示:完成所有连接后，您可以简单地将LED阴极端直接连接到系统板上的地。LED应该是亮的，如果不是，可能是LED坏了)</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nj"><img src="../Images/98ce6bdaf4b4994ff7d69c138e7f0182.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bNJ5ie0XoB67oUmnPKvZ8g.jpeg"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">图2 LED电路图</figcaption></figure><h1 id="dceb" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">3.软件设计</h1><p id="f71a" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy ng ka kb kc nh ke kf kg ni ki kj kk ij bi translated">现在是时候设计我们的软件了。我们的目标是设计控制LED的软件。为了显示效果，我们计划打开和关闭红色LED 10次，打开和关闭之间的时间间隔为1秒。一旦完成，我们将退出我们的程序。这很简单，但是正如我们前面所说的，我们的重点是编写可移植的软件，这样每个程序都可以在两个系统上运行，而无需任何代码更改。这个练习帮助我们开始思考现实世界中的这类问题。应该有许多有效的方法来处理这类问题，本文演示的只是其中之一。</p><h2 id="71f8" class="lz lc iq bd ld ma mb dn lh mc md dp ll jy me mf lp kc mg mh lt kg mi mj lx mk bi translated">BASH Shell脚本— blink.sh</h2><p id="b982" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy ng ka kb kc nh ke kf kg ni ki kj kk ij bi translated">让我们先从bash脚本开始，因为它不需要任何编译器或解释器来运行。</p><pre class="km kn ko kp gt nk nl nm nn aw no bi"><span id="2d7e" class="lz lc iq nl b gy np nq l nr ns"># Check to see if the computer model file exists or not<br/>FILE=/proc/device-tree/model<br/>if [ ! -f "$FILE" ]; then<br/>    echo "Blink only runs on Raspberry Pi 4 or Jetson Nano"<br/>    echo "Please check your computer model"<br/>    exit 0<br/>fi<br/><br/># Get the computer model string<br/># You can add elif to support other computer configurations<br/># with different GPIO pin layouts<br/>model=$(tr -d '\0' &lt; /proc/device-tree/model)<br/><br/>gpio='gpio'<br/><br/>if [[ $model =~ "NVIDIA Jetson Nano" ]]<br/>then<br/>    # Jetson Nano gpio79 is pin 12 on the board<br/>    pin='79'<br/>	<br/>elif [[ $model =~ "Raspberry Pi 4" ]]<br/>then<br/>    # Raspberry Pi 4 gpio18 is pin 12 on the board<br/>    pin='18'<br/>	<br/>else<br/>    echo "Blink only runs on Raspberry Pi 4 or Jetson Nano"<br/>    echo "Please check your computer model"<br/>	<br/>    exit 0<br/>fi<br/><br/># Setup the GPIO pin<br/>gpiopin="${gpio}""${pin}"<br/>	<br/># Set the pin to export<br/>echo "${pin}" &gt; /sys/class/gpio/export<br/><br/># Set Direction to output<br/>echo out &gt; /sys/class/gpio/${gpiopin}/direction<br/><br/># loop 10 times<br/>for number in {1..10}<br/>do<br/>    echo 1 &gt; /sys/class/gpio/${gpiopin}/value<br/>    sleep 1s<br/>	<br/>    echo 0 &gt; /sys/class/gpio/${gpiopin}/value<br/>	sleep 1s<br/>	<br/>done<br/><br/># Clean GPIO Pin<br/>echo "${pin}" &gt; /sys/class/gpio/unexport</span></pre><p id="1250" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我知道你只是想先尝试一下，看看这是否可行，请继续复制脚本，保存到“blink.sh”。然后，您可以在您的系统上运行它，请注意，您需要以root权限运行它:</p><pre class="km kn ko kp gt nk nl nm nn aw no bi"><span id="01f9" class="lz lc iq nl b gy np nq l nr ns">sudo ./blink.sh</span></pre><p id="4ae2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有用吗？如果是，恭喜你！如果没有，是不是忘了让文件可执行？</p><pre class="km kn ko kp gt nk nl nm nn aw no bi"><span id="0a83" class="lz lc iq nl b gy np nq l nr ns">chmod +x blink.sh</span></pre><p id="f918" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果电路连接正确，应该可以解决问题。</p><p id="4f0c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个脚本中，有几个部分负责不同的任务:</p><ol class=""><li id="b16c" class="ml mm iq jp b jq jr ju jv jy nc kc nd kg ne kk nf mt mu mv bi translated">检测并识别脚本运行在什么系统下:在这个脚本中，我们查看系统“/proc/device-tree/model”中的一个文件。这里的事情是，我们知道Raspberry Pi和Jetson Nano都有这样的文件，其中包含它们的身份，这样一旦找到，我们就可以在这两个系统上成功地运行我们的脚本。然而，有人可能会尝试我们的程序在其他系统上运行脚本，因为我们还没有在其他系统上完成我们的测试，我们需要小心地查看该文件是否存在。(我很快在我的主机上进行了测试，WSL子系统没有这样的文件来举例避免这样的问题):</li></ol><pre class="km kn ko kp gt nk nl nm nn aw no bi"><span id="8563" class="lz lc iq nl b gy np nq l nr ns"># Check to see if the computer model file exists or not<br/>FILE=/proc/device-tree/model<br/>if [ ! -f "$FILE" ]; then<br/>    echo "Blink only runs on Raspberry Pi 4 or Jetson Nano"<br/>    echo "Please check your computer model"<br/>    exit 0<br/>fi</span></pre><p id="4e4e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，上面的脚本将计算机模型文件及其路径分配给“file”变量，然后测试它是否存在，如果不存在，它将打印出一条警告消息并退出脚本。否则，我们继续。</p><p id="3e1d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2.脚本的下一部分是找出我们是否有Raspberry Pi或Jetson Nano或其他东西，即使我们在前面的讨论中已经检测到计算机模型文件确实存在:</p><pre class="km kn ko kp gt nk nl nm nn aw no bi"><span id="418a" class="lz lc iq nl b gy np nq l nr ns"># Get the computer model string<br/># You can add elif to support other computer configurations<br/># with different GPIO pin layouts<br/>model=$(tr -d '\0' &lt; /proc/device-tree/model)<br/><br/>gpio='gpio'<br/><br/>if [[ $model =~ "NVIDIA Jetson Nano" ]]<br/>then<br/>    # Jetson Nano gpio79 is pin 12 on the board<br/>    pin='79'<br/>    <br/>elif [[ $model =~ "Raspberry Pi 4" ]]<br/>then<br/>    # Raspberry Pi 4 gpio18 is pin 12 on the board<br/>    pin='18'<br/>    <br/>else<br/>    echo "Blink only runs on Raspberry Pi 4 or Jetson Nano"<br/>    echo "Please check your computer model"<br/>    <br/>    exit 0<br/>fi</span></pre><p id="36bd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们获取计算机模型字符串，并将其赋给“模型”变量。这里唯一棘手的是“tr -d '\0 '”部分，这是为了去掉字符串中的空字节，以便在不这样做的情况下抑制来自系统的警告。</p><p id="521e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该型号字符串将对照“NVIDIA Jetson Nano”和“Raspberry Pi 4”进行测试，如果找到匹配项，则会分配相应的pin号“79”或“18 ”,进而连接到“gpiopin”变量:</p><pre class="km kn ko kp gt nk nl nm nn aw no bi"><span id="0093" class="lz lc iq nl b gy np nq l nr ns"># Setup the GPIO pin<br/>gpiopin="${gpio}""${pin}"</span></pre><p id="cfc9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果既没有检测到Jetson Nano也没有检测到Raspberry Pi，我们将打印出一条警告消息并退出脚本。</p><p id="9147" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3.一旦我们成功地达到这一点，我们就可以使用GPIO了:</p><pre class="km kn ko kp gt nk nl nm nn aw no bi"><span id="592a" class="lz lc iq nl b gy np nq l nr ns"># Set the pin to export<br/>echo "${pin}" &gt; /sys/class/gpio/export<br/><br/># Set Direction to output<br/>echo out &gt; /sys/class/gpio/${gpiopin}/direction</span></pre><p id="fe3f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要启用GPIO功能，我们需要写入要导出的特定pin号。GPIO也有方向:输入或输出。在我们的设计和示例中，我们使用输出功能，这意味着我们的程序决定将引脚设置为高电平还是低电平，而不是在引脚用作输入引脚时读取引脚来查看它是高电平还是低电平。</p><p id="46dd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">4.完成上述所有准备和设置后，我们可以循环10次，观察我们壮观的LED秀:</p><pre class="km kn ko kp gt nk nl nm nn aw no bi"><span id="22ed" class="lz lc iq nl b gy np nq l nr ns"># loop 10 times<br/>for number in {1..10}<br/>do<br/>    echo 1 &gt; /sys/class/gpio/${gpiopin}/value<br/>    sleep 1s<br/>    <br/>    echo 0 &gt; /sys/class/gpio/${gpiopin}/value<br/>    sleep 1s<br/>    <br/>done</span></pre><p id="4f2e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我们将引脚值设置为“1”时，GPIO引脚进入高电压状态，这又会触发我们的红色LED点亮，我们让节目持续1秒钟，然后将GPIO引脚设置为“0”，这又会将电压切换到低状态，从而关闭红色LED 1秒钟。经过10次的交换，我们都完成了，退出了循环。</p><p id="e79a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">5.作为一名优秀的工程师，我们总是在任务完成后清理现场，让我们在自己或他人的下一次展示中保持这种方式:</p><pre class="km kn ko kp gt nk nl nm nn aw no bi"><span id="c88b" class="lz lc iq nl b gy np nq l nr ns"># Clean GPIO Pin<br/>echo "${pin}" &gt; /sys/class/gpio/unexport</span></pre><p id="f1ec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">随着我们第一次浏览bash脚本过程，浏览下面的其他两个程序应该会容易得多。</p><h2 id="d1eb" class="lz lc iq bd ld ma mb dn lh mc md dp ll jy me mf lp kc mg mh lt kg mi mj lx mk bi translated">c程序— blink.c</h2><pre class="km kn ko kp gt nk nl nm nn aw no bi"><span id="bf70" class="lz lc iq nl b gy np nq l nr ns">#include &lt;errno.h&gt;<br/>#include &lt;fcntl.h&gt;<br/>#include &lt;stdio.h&gt;<br/>#include &lt;stdlib.h&gt;<br/>#include &lt;string.h&gt;<br/>#include &lt;sys/stat.h&gt;<br/>#include &lt;sys/types.h&gt;<br/>#include &lt;unistd.h&gt;<br/><br/>int main()<br/>{<br/>	char JetsonNano[] = "NVIDIA Jetson Nano";<br/>	char RPi4[] = "Raspberry Pi 4";<br/>	char model[] = "/proc/device-tree/model";<br/>	char export[] = "/sys/class/gpio/export";<br/>	char unexport[] = "/sys/class/gpio/unexport";<br/>	char gpio[] = "/sys/class/gpio/gpio";<br/>	char out[] = "out";<br/>	char p18[] = "18";<br/>	char p79[] = "79";<br/>	char high[] = "1";<br/>	char low[] = "0";<br/>	char pin[4];<br/>	char direction[256] = "";<br/>	char value[256] = "";<br/>	<br/>    FILE *stream;<br/>    char line[256];<br/>    int len = 256;<br/><br/>    // Find the computer model we support:<br/>    stream = fopen(model, "r");<br/>    if ( stream == NULL ) {<br/>        perror("Error: it cannot run the program as it doesn't know the computer model!");<br/>		<br/>        exit(EXIT_FAILURE);<br/>    } else {<br/>		fgets(line, len, stream);<br/>		<br/>        if ( (line != NULL) &amp;&amp; (strstr(line,JetsonNano) != NULL) ) {<br/>			strcpy(pin,p79);<br/>		} else if ( (line != NULL) &amp;&amp; (strstr(line,RPi4) != NULL) ) {<br/>			strcpy(pin,p18);<br/>		} else {<br/>			// something wrong: clean up and exit<br/>            fclose(stream);<br/>			<br/>			perror("Error: it cannot run this program as it doesn't support the computer model!");<br/>			<br/>			exit(EXIT_FAILURE);<br/>		}<br/>		<br/>		// build direction and value paths/files<br/>		// /sys/class/gpio/gpioxx/direction<br/>		// /sys/class/gpio/gpioxx/value<br/>		strcat(direction, gpio);<br/>		strcat(direction, pin);<br/>		strcat(value,direction);<br/>		strcat(value,"/value");<br/>		strcat(direction, "/direction");<br/>			<br/>	    // found a board we support, clean up and continue		<br/>        fclose(stream);<br/>	}<br/><br/>    // Check and setup export<br/>    int fd = open(export, O_WRONLY);<br/>    if (fd == -1) {<br/>        perror("Error: cannot open the export file!");<br/>        exit(EXIT_FAILURE);<br/>    }<br/><br/>    if (write(fd, pin, 2) != 2) {<br/>        perror("Error: cannot write to the export!");<br/>        exit(EXIT_FAILURE);<br/>    }<br/><br/>    close(fd);<br/><br/>    // Check and setup direction to output<br/>    fd = open(direction, O_WRONLY);<br/>    if (fd == -1) {<br/>        perror("Error: cannot open the direction file!");<br/>        exit(EXIT_FAILURE);<br/>    }<br/><br/>    if (write(fd, out, 3) != 3) {<br/>        perror("Error: cannot write the direction!");<br/>        exit(EXIT_FAILURE);<br/>    }<br/><br/>    close(fd);<br/><br/>    fd = open(value, O_WRONLY);<br/>    if (fd == -1) {<br/>        perror("Error: cannot open the value file!");<br/>        exit(EXIT_FAILURE);<br/>    }<br/><br/>    // Ready to go and loop 10 times with one second intervals<br/>    for (int i = 0; i &lt; 10; i++) {<br/>        if (write(fd, high, 1) != 1) {<br/>            perror("Error: cannot write the value!");<br/>            exit(EXIT_FAILURE);<br/>        }<br/>        sleep(1);<br/><br/>        if (write(fd, low, 1) != 1) {<br/>            perror("Error: cannot write the value!");<br/>            exit(EXIT_FAILURE);<br/>        }<br/>        sleep(1);<br/>    }<br/><br/>    close(fd);<br/><br/>    // We are done and clean up with the unexport<br/>    fd = open(unexport, O_WRONLY);<br/>    if (fd == -1) {<br/>        perror("Error: cannot open the unexport file!");<br/>        exit(EXIT_FAILURE);<br/>    }<br/><br/>    if (write(fd, pin, 2) != 2) {<br/>        perror("Error: cannot write the unexport!");<br/>        exit(EXIT_FAILURE);<br/>    }<br/><br/>    close(fd);<br/><br/>    return 0;<br/>}</span></pre><p id="8766" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要运行它，请复制代码并保存到一个文件中，比如“blink.c”。因为它是如此简单的程序，我们没有make或build文件，而是简单地从命令行快速编译它:</p><pre class="km kn ko kp gt nk nl nm nn aw no bi"><span id="eb97" class="lz lc iq nl b gy np nq l nr ns">gcc -o blink blink.c</span></pre><p id="e759" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果没有显示错误，您可以运行它:</p><pre class="km kn ko kp gt nk nl nm nn aw no bi"><span id="23b9" class="lz lc iq nl b gy np nq l nr ns">sudo ./blink</span></pre><p id="d240" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">c是非常强大和原始的编程语言。在这个程序中，我们倾向于定义很多字符串，这样我们可以避免在代码中嵌入文本字符串。我们还花了相当多的步骤来连接字符串，以处理我们的每个任务。编程逻辑和工作流程非常类似于我们在之前的“blink.sh”讨论中讨论的细节。一个人比较这些步骤并坚持下去应该没有问题。</p><p id="d1ba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有几件事需要注意:我们没有分配和释放内存，只是简单地使用堆栈来处理这么简单的程序中的所有字符串操作。我们经常检查错误条件，这在我们的项目中应该是一件好事。当然，当需要时，我们需要在每个步骤中勤奋地清理。</p><h2 id="2d69" class="lz lc iq bd ld ma mb dn lh mc md dp ll jy me mf lp kc mg mh lt kg mi mj lx mk bi translated">Python程序— blink.py</h2><pre class="km kn ko kp gt nk nl nm nn aw no bi"><span id="4c53" class="lz lc iq nl b gy np nq l nr ns"># Both Raspberry Pi 4 and Jetson Nano can be supported by Mode BCM Pin 18 mapped on BOARD Pin 12.<br/>#<br/>import sys<br/>import time<br/><br/># Check if GPIO module is available or not<br/>try:<br/>    import RPi.GPIO as GPIO<br/>except ImportError:<br/>    print ("Cannot locate RPi.GPIO module!")<br/>    sys.exit(1)<br/><br/># Check to see if we have found the system we support<br/>def checkSystem(line):<br/>    if ( ('NVIDIA Jetson Nano' not in line) and ('Raspberry Pi 4' not in line) ): <br/>        print ("The system is not supported by this program!")<br/>        sys.exit(1)<br/><br/>def main():<br/>    # Exam the system model file<br/>    try:<br/>        with open('/proc/device-tree/model') as f:<br/>            for line in f:<br/>                checkSystem(line)<br/>                break<br/>    except Exception as error:<br/>        print ("The system is not supported by this program!")<br/>        sys.exit(1)<br/>    <br/>    # Setup BCM Mode<br/>    GPIO.setmode(GPIO.BCM)<br/>    <br/>    # Setup pin number<br/>    pin =  18<br/><br/>    # Setup the pin as output direction<br/>    GPIO.setup(pin, GPIO.OUT)<br/>  <br/>    # Loop 10 times with one second intervals<br/>    for i in range(10):<br/>        # Output pin value high and then sleep for 1 second    <br/>        value = GPIO.HIGH<br/>        GPIO.output(pin, value)<br/>        time.sleep(1)<br/>        <br/>        # Output pin value low and then sleep for 1 second<br/>        value = GPIO.LOW<br/>        GPIO.output(pin, value)<br/>        time.sleep(1)       <br/><br/>    # Clean it up<br/>    GPIO.cleanup()<br/><br/>if __name__ == '__main__':<br/>    main()</span></pre><p id="01f8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以运行它:</p><pre class="km kn ko kp gt nk nl nm nn aw no bi"><span id="e562" class="lz lc iq nl b gy np nq l nr ns">python blink.py</span></pre><p id="2c01" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">尽管与之前的blink.sh和blink.c程序具有相似的逻辑和工作流程，但Python程序版本blink.py确实存在一些差异:</p><ol class=""><li id="c7ef" class="ml mm iq jp b jq jr ju jv jy nc kc nd kg ne kk nf mt mu mv bi translated">因为对Python的GPIO支持可以作为一个包安装，例如，在我们的Jetson Nano系统中，我们必须从<a class="ae nb" href="https://github.com/NVIDIA/jetson-gpio" rel="noopener ugc nofollow" target="_blank">https://github.com/NVIDIA/jetson-gpio</a>安装，这样我们就可以在我们的程序中导入它，以便与GPIO一起工作。为此，我们添加了一个检查来查看这个包是否真正安装了。对于杰特森来说有一件有趣的事。GPIO包是你可以用任何一个“Jetson。GPIO”或“RPi”。GPIO”来标识要导入的包，我不需要任何鼓励就可以使用“Import RPi”。GPIO as GPIO”在我们的程序中:</li></ol><pre class="km kn ko kp gt nk nl nm nn aw no bi"><span id="d910" class="lz lc iq nl b gy np nq l nr ns"># Check if GPIO module is available or not<br/>try:<br/>    import RPi.GPIO as GPIO<br/>except ImportError:<br/>    print ("Cannot locate RPi.GPIO module!")<br/>    sys.exit(1)</span></pre><p id="85e0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2.杰特森。GPIO包支持4种不同的模式:GPIO。GPIO板。BCM，GPIO。CVM和GPIO。泰格拉_SOC。因为我们正在设计一个与Raspberry Pi和RPi兼容的程序。GPIO支持BCM模式，我们为什么要让自己的生活艰难？因此，我们为Raspberry Pi和Jetson Nano系统选择了BCM模式，pin码匹配良好，因此我们甚至不需要像在早期程序中那样选择不同的pin码。这其实让我们的生活更早了！</p><pre class="km kn ko kp gt nk nl nm nn aw no bi"><span id="ddc1" class="lz lc iq nl b gy np nq l nr ns"># Setup BCM Mode<br/>    GPIO.setmode(GPIO.BCM)<br/>    <br/>    # Setup pin number<br/>    pin =  18<br/><br/>    # Setup the pin as output direction<br/>    GPIO.setup(pin, GPIO.OUT)</span></pre><p id="eae9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以下循环10次的代码非常简单。最后，因为我们都是优秀的程序员，所以一旦完成，我们就清理它！</p><pre class="km kn ko kp gt nk nl nm nn aw no bi"><span id="2045" class="lz lc iq nl b gy np nq l nr ns"># Loop 10 times with one second intervals<br/>    for i in range(10):<br/>        # Output pin value high and then sleep for 1 second    <br/>        value = GPIO.HIGH<br/>        GPIO.output(pin, value)<br/>        time.sleep(1)<br/>        <br/>        # Output pin value low and then sleep for 1 second<br/>        value = GPIO.LOW<br/>        GPIO.output(pin, value)<br/>        time.sleep(1)       <br/><br/>    # Clean it up<br/>    GPIO.cleanup()</span></pre><h1 id="100c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">Bonus — switch.py</h1><pre class="km kn ko kp gt nk nl nm nn aw no bi"><span id="63b3" class="lz lc iq nl b gy np nq l nr ns"># Both Raspberry Pi 4 and Jetson Nano can be supported<br/># Please note the mapping between mode and board pins<br/># For instance: Mode BCM Pin 18 is BOARD Pin 12.<br/>#<br/># Usage:<br/># python switch.py (BCM pin number) (1 or 0 -- means on or off)<br/>#<br/># For instance: <br/># python switch.py 18  1<br/>#<br/><br/>import sys<br/><br/>try:<br/>    import RPi.GPIO as GPIO<br/>except ImportError:<br/>    print ("Cannot locate RPi.GPIO module!")<br/>    sys.exit(1)<br/><br/># Check to see if we have found the system we support<br/>def checkSystem(line):<br/>    if ( ('NVIDIA Jetson Nano' not in line) and ('Raspberry Pi 4' not in line) ): <br/>        print ("The system is not supported by this program!")<br/>        sys.exit(1)<br/><br/>def main():<br/>    # Exam the system model file<br/>    try:<br/>        with open('/proc/device-tree/model') as f:<br/>            for line in f:<br/>                checkSystem(line)<br/>                break<br/>    except Exception as error:<br/>        print ("The system is not supported by this program!")<br/>        sys.exit(1)<br/><br/>    # Check commandline inputs<br/>    if ( len(sys.argv) &lt; 3 ):<br/>        print ("Please provide two numbers: (BCM pin number; and 1/0 for on/off output)")<br/>        print ("python switch.py number_1  number_2")<br/>        sys.exit(1)<br/><br/>    # Setup BCM Mode<br/>    GPIO.setmode(GPIO.BCM)<br/>    <br/>    # Setup pin number<br/>    pin = int(sys.argv[1])<br/><br/>    # Get on/off instruction<br/>    onoff = sys.argv[2]<br/><br/>    # Suppress warning message <br/>    # in case the pin was used before<br/>    GPIO.setwarnings(False)<br/><br/>    # Setup the pin as output direction<br/>    GPIO.setup(pin, GPIO.OUT)<br/><br/>    if ( onoff == "1" ):  <br/>        value = GPIO.HIGH<br/>        <br/>    if ( onoff == "0" ):<br/>        value = GPIO.LOW<br/><br/>    GPIO.output(pin, value)<br/><br/>    # Press a key to exit<br/>    print ("Please press a key to exit the program...")<br/>    ch = sys.stdin.read(1)<br/><br/>    # Clean it up<br/>    GPIO.cleanup(pin)<br/><br/>if __name__ == '__main__':<br/>    main()</span></pre><p id="101a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是奖金计划，这实际上是我用来测试我的程序和系统。一步一步测试引脚或其他东西是很有用的。您可以通过提供两个参数来运行它:</p><pre class="km kn ko kp gt nk nl nm nn aw no bi"><span id="65f9" class="lz lc iq nl b gy np nq l nr ns">python switch.py &lt;pin number&gt; &lt;1 or 0&gt;</span></pre><p id="0015" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我甚至用它拍了图1的照片(打开两个发光二极管)</p><p id="cfab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我还发现RPi之间的不一致。Raspberry Pi和Jetson Nano上的GPIO:一旦你打开LED并退出程序，即使在清理后，Jetson Nano上的LED仍保持打开，而Raspberry Pi上的LED关闭。你自己试试！</p><p id="6c0f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我还注意到另一个问题:如果一个人在退出前没有清理，他会得到一个错误消息，有时甚至无法继续运行另一个具有相同pin码的GPIO程序，直到他清理完系统！有一种简单的方法可以使用blink.sh中的一个语句来修复它，但是如果您遇到这种情况，这是您的家庭作业。</p><h1 id="03fa" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">附录—系统配置图像</h1><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/e096bba0b7f99c64edfedce73acf4e79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y0rFcAWbFVAfCUOjyI_-VA.jpeg"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">图3树莓Pi系统</figcaption></figure><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/d1f3df718d64c3bbd5baf1817f1e4df3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qzT71e7dgYAFatnJ9IKh2Q.jpeg"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">图4杰特森纳米系统</figcaption></figure><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nt"><img src="../Images/b70472487d52f85873c1b5e36155153c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lfb6W7RDCfugnjKryLwPeg.jpeg"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">图5支持两种系统的VSCode</figcaption></figure><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nt"><img src="../Images/fc6c7cb01a4e05b97759ab581510adb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0Qq3HNWHyme40tkgLrrJMA.jpeg"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">图6 SSH命令行与两个系统一起工作</figcaption></figure><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nu"><img src="../Images/c94ee1a21631d5530f0904ea0a1b78bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aaZTow7QYHE9Ydn9w_bJDg.jpeg"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">图7 VNC与两个系统一起工作</figcaption></figure></div></div>    
</body>
</html>