<html>
<head>
<title>Donut Gauges with Angular and D3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带角度和D3的环形仪表</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/donut-gauges-with-angular-and-d3-7be1b5f39492?source=collection_archive---------0-----------------------#2022-02-06">https://levelup.gitconnected.com/donut-gauges-with-angular-and-d3-7be1b5f39492?source=collection_archive---------0-----------------------#2022-02-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/d7baca1c12b6a0c0225d61ca093a7488.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9cbb9BiOyv37snt9A3cSGQ.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">具有圆环图的移动设备</figcaption></figure><p id="9d76" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">谁不爱吃甜甜圈？人们在应用程序的报告、仪表盘和卡片元素上尽情享用。您可以轻松地在Angular中创建环形量规，而无需使用庞大的库或购买商业组件。只要有一点点诀窍，我们就能制作出一些你尝过的最美味的甜甜圈图！</p><blockquote class="la lb lc"><p id="feb4" class="kc kd ld ke b kf kg kh ki kj kk kl km le ko kp kq lf ks kt ku lg kw kx ky kz ij bi translated">本文是带角度和D3的<a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/sparklines-with-angular-and-d3-d279dbac0c38">迷你图的姊妹篇</a>，在这里你可以学习如何创建漂亮的迷你图。</p></blockquote><p id="c61b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">为了烘培它，我们<strong class="ke ir">T5</strong>将使用<a class="ae lh" href="https://d3js.org/" rel="noopener ugc nofollow" target="_blank"> D3.js </a>，在维基百科上描述为:</p><blockquote class="la lb lc"><p id="439e" class="kc kd ld ke b kf kg kh ki kj kk kl km le ko kp kq lf ks kt ku lg kw kx ky kz ij bi translated">D3.js(也称为D3，是数据驱动文档的缩写)是一个JavaScript库，用于在web浏览器中生成动态、交互式数据可视化。它利用了广泛实现的可缩放矢量图形(SVG)、HTML5和级联样式表(CSS)标准。</p><p id="4010" class="kc kd ld ke b kf kg kh ki kj kk kl km le ko kp kq lf ks kt ku lg kw kx ky kz ij bi translated"><strong class="ke ir">注意:<br/> </strong>没有 D3.js也有其他方法来构建一个圆环图<strong class="ke ir">，也许用直接的SVG代码也一样简单。然而，我将把它留到另一篇文章中来讨论！</strong></p></blockquote><h1 id="1af4" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">先决条件</h1><p id="fb1a" class="pw-post-body-paragraph kc kd iq ke b kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ij bi translated">最近我看到的大多数Angular目标教程都喜欢带你安装Angular并创建一个全新的项目。我不打算这么做，因为我坚信在你到达这里之前，你应该有一个框架的基础知识。然而，我会提供一个如何开始使用Angular的链接，所以如果你是新手，请浏览教程(英雄之旅),然后回来和我们一起制作一些甜甜圈！<a class="ae lh" href="https://angular.io/tutorial" rel="noopener ugc nofollow" target="_blank">角斗士英雄之旅</a></p><p id="e2d1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">您需要安装D3库，这可以在提示符下完成:<code class="fe ml mm mn mo b"><strong class="ke ir">npm install d3 --save</strong></code></p><p id="65c9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然后，为了确保我们在实现D3时不会发疯，我们需要键入:<code class="fe ml mm mn mo b"><strong class="ke ir">npm install @types/d3 --save-dev</strong></code></p><h2 id="7419" class="mp lj iq bd lk mq mr dn lo ms mt dp ls kn mu mv lw kr mw mx ma kv my mz me na bi translated">tsconfig.json</h2><p id="c8f7" class="pw-post-body-paragraph kc kd iq ke b kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ij bi translated">在我们继续之前，我喜欢在构建Angular应用程序时使用路径快捷方式。这样我只需用<strong class="ke ir">~ app/feature/demo/demo . component</strong>就可以访问<strong class="ke ir">src/app/feature/demo/demo . component . ts</strong>。为此，您需要打开根目录中的<strong class="ke ir"> tsconfig.json </strong>文件，并将以下内容添加到compilerOptions部分，我通常将该部分插入到moduleResolution的正下方和importHelpers的前面。</p><pre class="nb nc nd ne gt nf mo ng nh aw ni bi"><span id="ea11" class="mp lj iq mo b gy nj nk l nl nm"><strong class="mo ir">"paths": {<br/>      "~app/*": ["src/app/*"],<br/>      "~assets/*": ["src/assets/*"],<br/>      "~environment/*": ["src/environments/*"]<br/>},</strong></span></pre><h1 id="fbf2" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">图表组件</h1><p id="7aac" class="pw-post-body-paragraph kc kd iq ke b kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ij bi translated">我们需要一个组件来实际显示圆环图。我们将通过使用:<br/> <code class="fe ml mm mn mo b"><strong class="ke ir">ng generate component feature/chart</strong></code>生成一个图表组件来实现</p><p id="a9b6" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">创建完成后，我们打开:<strong class="ke ir">app/feature/chart/chart . component . ts</strong></p><h2 id="5343" class="mp lj iq bd lk mq mr dn lo ms mt dp ls kn mu mv lw kr mw mx ma kv my mz me na bi translated">图表.组件. ts</h2><p id="62a4" class="pw-post-body-paragraph kc kd iq ke b kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ij bi translated">我们将利用相当多的核心角度接口，包括<strong class="ke ir"><em class="ld">AfterViewInit</em></strong>，<strong class="ke ir"> <em class="ld"> ElementRef </em> </strong>，<strong class="ke ir"> <em class="ld"> HostListener </em> </strong>，<strong class="ke ir"> <em class="ld"> Input </em> </strong>，以及<strong class="ke ir"> <em class="ld"> ViewChild </em> </strong>。我们通过导入来做到这一点。<br/>替换现有的:<br/> <code class="fe ml mm mn mo b"><strong class="ke ir">import { Component, OnInit } from '@angular/core';</strong></code></p><p id="4449" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><br/>同:<code class="fe ml mm mn mo b"><strong class="ke ir">import { AfterViewInit, Component, ElementRef, HostListener, Input, ViewChild } from '@angular/core';</strong></code></p><p id="6f1b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">一旦完成，让我们导入D3库:<br/> <code class="fe ml mm mn mo b"><strong class="ke ir">import * as d3 from 'd3';</strong></code></p><p id="6fd5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">好的，这应该能让我们成功！</p><p id="ee69" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这里可能会有一个错误，因为我们实现的是OnInit而不是AfterViewInit，所以我们需要做两处调整:</p><p id="257e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">替换包含<code class="fe ml mm mn mo b"><strong class="ke ir">export class ChartComponent implements OnInit {</strong></code>的第10行或其附近的出口声明</p><p id="c0f4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">用<code class="fe ml mm mn mo b"><strong class="ke ir">export class ChartComponent implements AfterViewInit {</strong></code></p><p id="45ad" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们还需要用<strong class="ke ir">ngafterviewit()</strong>替换<strong class="ke ir"> ngOnInit() </strong>方法。在14号线上或周围更换<code class="fe ml mm mn mo b"><strong class="ke ir">ngOnInit(): void {}</strong></code></p><p id="0134" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">用<code class="fe ml mm mn mo b"><strong class="ke ir">ngAfterViewInit(): void {}</strong></code></p><p id="26b6" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">为什么这很重要？如果你对<a class="ae lh" href="https://angular.io/guide/lifecycle-hooks" rel="noopener ugc nofollow" target="_blank">Angular Component life cycle</a>不太熟悉，它本质上是一种在组件生命周期中的特定事件(创建、更新和销毁)将代码“注入”到组件中的方法。来自官方的Angular文档:</p><blockquote class="la lb lc"><p id="4cf4" class="kc kd ld ke b kf kg kh ki kj kk kl km le ko kp kq lf ks kt ku lg kw kx ky kz ij bi translated">组件实例的生命周期始于Angular实例化组件类并呈现组件视图及其子视图。生命周期继续进行更改检测，Angular检查数据绑定属性何时更改，并根据需要更新视图和组件实例。当Angular销毁组件实例并从DOM中删除其呈现模板时，生命周期结束。指令也有类似的生命周期，Angular在执行过程中创建、更新和销毁实例。</p></blockquote><p id="6703" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">因此，在尝试绘制任何东西之前，我们希望等到组件尽可能初始化。这一点尤其重要，因为我们将利用<strong class="ke ir"> ViewChild </strong>装饰器，根据Angular文档，该装饰器设置在调用<strong class="ke ir">ngafterviewit()</strong>之前，但在其他初始化生命周期挂钩之后。</p><blockquote class="la lb lc"><p id="c9e4" class="kc kd ld ke b kf kg kh ki kj kk kl km le ko kp kq lf ks kt ku lg kw kx ky kz ij bi translated">视图查询是在调用<code class="fe ml mm mn mo b"><strong class="ke ir"><em class="iq">ngAfterViewInit</em></strong></code>回调之前设置的。</p></blockquote><p id="408a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">主持听众<br/> </strong>好吧！现在，我们还想确保当调整窗口大小时，我们的图表也随之调整大小。我们希望捕获任何窗口大小调整事件，以便在其容器内适当地重新绘制图表。最简单的方法是通过Angular host listener——我们捕获任何'<strong class="ke ir"> window:resize </strong>'事件，然后执行我们的re-draw方法<strong class="ke ir"> this.resize() </strong>，我们将在本文中进一步实现它。</p><pre class="nb nc nd ne gt nf mo ng nh aw ni bi"><span id="5ee6" class="mp lj iq mo b gy nj nk l nl nm"><strong class="mo ir">@HostListener('window:resize', ['$event'])<br/>onResize() {<br/>    this.resize();<br/>}</strong></span></pre><p id="99de" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"> Input </strong> <br/>我们还需要来自调用组件的一些信息来初始化图表并适当地调整大小。</p><pre class="nb nc nd ne gt nf mo ng nh aw ni bi"><span id="b1e4" class="mp lj iq mo b gy nj nk l nl nm"><strong class="mo ir">/* The colors of the donut chart, starting with the fill color, followed by the gauge background color. */<br/>@Input() colors: string[] = [];</strong></span><span id="a38a" class="mp lj iq mo b gy nn nk l nl nm"><strong class="mo ir">/* The value to fill the donut, followed by the "unfilled" amount e.g. if we were displaying a donut representing 100% and we wanted to fill 88% of it, we'd supply [88,11] here. */<br/>@Input() data: number[] = []; </strong></span><span id="4698" class="mp lj iq mo b gy nn nk l nl nm"><strong class="mo ir">/* The height of the donut */<br/>@Input() height: number;</strong></span><span id="5509" class="mp lj iq mo b gy nn nk l nl nm"><strong class="mo ir">/* Label for the inside of the donut, if desired */<br/>@Input() label: string;</strong></span><span id="d604" class="mp lj iq mo b gy nn nk l nl nm"><strong class="mo ir">/* Color of the label inside of the donut */<br/>@Input() labelColor: string = 'rgba(80,80,80,.8)'; </strong></span><span id="b0be" class="mp lj iq mo b gy nn nk l nl nm"><strong class="mo ir">/* The title of the chart, if desired */ <br/>@Input() title: string;</strong></span><span id="da29" class="mp lj iq mo b gy nn nk l nl nm"><strong class="mo ir">/* The width of the donut. */<br/>@Input() width: number;</strong></span></pre><p id="7793" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">请记住，如果您不想使用RGBA值，您可以简单地使用十六进制代码，如'<strong class="ke ir"> #4682B4' </strong>，或颜色的名称，如<strong class="ke ir">'矢车菊蓝'，</strong>，但我喜欢允许自己自由的不透明度(RGBA数组中的第四个数字，范围在0-完全透明和1-不透明之间，如0.4)</p><p id="da9f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">查看子节点</strong></p><p id="bea6" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">继续前进！我们还想利用Angular的<strong class="ke ir"> ViewChild </strong>来方便地(不需要生成或要求特定的元素id，这在显示多个图表时会非常麻烦)引用容器和图表DOM元素。</p><pre class="nb nc nd ne gt nf mo ng nh aw ni bi"><span id="8694" class="mp lj iq mo b gy nj nk l nl nm"><strong class="mo ir">@ViewChild('chart', {static: false}) chart: ElementRef&lt;SVGElement&gt;;</strong></span><span id="bb10" class="mp lj iq mo b gy nn nk l nl nm"><strong class="mo ir">@ViewChild('container', {static: false}) container: ElementRef&lt;HTMLDivElement&gt;;</strong></span><span id="aaaf" class="mp lj iq mo b gy nn nk l nl nm"><strong class="mo ir">@ViewChild('titleContainer') titleContainer: ElementRef&lt;HTMLDivElement&gt;;</strong></span></pre><p id="7081" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">最后，我们需要存储一个SVG全局变量，以便在构建甜甜圈时引用。</p><pre class="nb nc nd ne gt nf mo ng nh aw ni bi"><span id="0d88" class="mp lj iq mo b gy nj nk l nl nm"><strong class="mo ir">public svg: any;</strong></span></pre><h2 id="6dd3" class="mp lj iq bd lk mq mr dn lo ms mt dp ls kn mu mv lw kr mw mx ma kv my mz me na bi translated">快速回顾</h2><p id="a41c" class="pw-post-body-paragraph kc kd iq ke b kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ij bi translated">到目前为止，我们的<strong class="ke ir"> chart.component.ts </strong>文件看起来应该与此非常相似:</p><pre class="nb nc nd ne gt nf mo ng nh aw ni bi"><span id="4162" class="mp lj iq mo b gy nj nk l nl nm"><strong class="mo ir">import { AfterViewInit, Component, ElementRef, HostListener, Input, ViewChild } from '@angular/core';<br/>import * as d3 from 'd3'</strong></span><span id="21ae" class="mp lj iq mo b gy nn nk l nl nm"><strong class="mo ir">@Component({<br/>    selector: 'app-chart',<br/>    templateUrl: './chart.component.html',<br/>    styleUrls: ['./chart.component.scss']<br/>})<br/>export class ChartComponent implements AfterViewInit {</strong></span><span id="9f80" class="mp lj iq mo b gy nn nk l nl nm"><strong class="mo ir">  @HostListener('window:resize', ['$event'])<br/>  onResize() {<br/>    this.resize();<br/>  }</strong></span><span id="9e3f" class="mp lj iq mo b gy nn nk l nl nm"><strong class="mo ir">  /* The colors of the donut chart, starting with the fill color, followed by the gauge background color. */<br/>  @Input() colors: string[] = [];</strong></span><span id="cf16" class="mp lj iq mo b gy nn nk l nl nm"><strong class="mo ir">  /* The value to fill the donut, followed by the "unfilled" amount e.g. if we were displaying a donut representing 100% and we wanted to fill 88% of it, we'd supply [88,11] here. */<br/>  @Input() data: number[] = [];</strong></span><span id="46dc" class="mp lj iq mo b gy nn nk l nl nm"><strong class="mo ir">  /* The height of the donut */<br/>  @Input() height: number;</strong></span><span id="4c69" class="mp lj iq mo b gy nn nk l nl nm"><strong class="mo ir">  /* Label for the inside of the donut, if desired */<br/>  @Input() label: string;</strong></span><span id="3621" class="mp lj iq mo b gy nn nk l nl nm"><strong class="mo ir">  /* Color of the label inside of the donut */<br/>  @Input() labelColor: string = 'rgba(80,80,80,.8)';</strong></span><span id="7466" class="mp lj iq mo b gy nn nk l nl nm"><strong class="mo ir">  /* The title of the chart, if desired */ <br/>  @Input() title: string;</strong></span><span id="a23c" class="mp lj iq mo b gy nn nk l nl nm"><strong class="mo ir">  /* The width of the donut. */<br/>  @Input() width: number;</strong></span><span id="03bf" class="mp lj iq mo b gy nn nk l nl nm"><strong class="mo ir">  @ViewChild('chart') chart: ElementRef&lt;SVGElement&gt;;<br/>  @ViewChild('container') container: ElementRef&lt;HTMLDivElement&gt;;<br/>  @ViewChild('titleContainer') titleContainer: ElementRef&lt;HTMLDivElement&gt;;</strong></span><span id="d3d0" class="mp lj iq mo b gy nn nk l nl nm"><strong class="mo ir">  public svg: any;</strong></span><span id="1510" class="mp lj iq mo b gy nn nk l nl nm"><strong class="mo ir">  constructor() { }</strong></span><span id="1d28" class="mp lj iq mo b gy nn nk l nl nm"><strong class="mo ir">  ngAfterViewInit(): void {<br/>  }</strong></span><span id="296f" class="mp lj iq mo b gy nn nk l nl nm"><strong class="mo ir">}</strong></span></pre><h2 id="655e" class="mp lj iq bd lk mq mr dn lo ms mt dp ls kn mu mv lw kr mw mx ma kv my mz me na bi translated">调整大小</h2><p id="0d8c" class="pw-post-body-paragraph kc kd iq ke b kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ij bi translated">我们想要实现的第一个方法是resize。这将允许我们在触发resize事件时修改图表的高度和宽度，并允许我们执行初始大小设置。我们将使用<strong class="ke ir"> ViewChild </strong>对<strong class="ke ir"> this.container </strong>和<strong class="ke ir"> this.chart </strong>的定义，然后访问它们的<strong class="ke ir"> nativeElement </strong>属性。</p><blockquote class="la lb lc"><p id="0fa9" class="kc kd ld ke b kf kg kh ki kj kk kl km le ko kp kq lf ks kt ku lg kw kx ky kz ij bi translated"><strong class="ke ir">注意</strong> : <br/>如果你不熟悉你在整个代码示例中看到的反斜线<code class="fe ml mm mn mo b"><strong class="ke ir"><em class="iq">`</em></strong></code>，这不是一个粗心的错误！使用反斜线代替引号<code class="fe ml mm mn mo b"><strong class="ke ir"><em class="iq">'</em></strong></code>或双引号<code class="fe ml mm mn mo b"><strong class="ke ir"><em class="iq">"</em></strong></code>就是JavaScript中的插值或模板文字。MDN Web Docs将模板文字描述为:<strong class="ke ir">模板文字是用反斜杠(</strong> <code class="fe ml mm mn mo b"><strong class="ke ir"><em class="iq">`</em></strong></code> <strong class="ke ir">)分隔的文字，允许被称为<em class="iq">替换</em>的嵌入式表达式。</strong>你可以在这里找到更多信息:<a class="ae lh" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Reference/Template _ literals</a></p></blockquote><pre class="nb nc nd ne gt nf mo ng nh aw ni bi"><span id="337c" class="mp lj iq mo b gy nj nk l nl nm"><strong class="mo ir">private resize(): void {<br/>  this.height = (this.height &amp;&amp; !isNaN(this.height) &amp;&amp; this.height &gt; 0) ? this.height : this.container.nativeElement.parentElement.parentElement.offsetHeight;</strong></span><span id="9547" class="mp lj iq mo b gy nn nk l nl nm"><strong class="mo ir">  this.width = (this.width &amp;&amp; !isNaN(this.width) &amp;&amp; this.width &gt; 0) ? this.width : this.container.nativeElement.parentElement.parentElement.offsetWidth;</strong></span><span id="521a" class="mp lj iq mo b gy nn nk l nl nm"><strong class="mo ir">  this.chart.nativeElement.style.height = `${this.height}px`;<br/>  this.container.nativeElement.style.height = `${this.height}px`;<br/>  this.chart.nativeElement.style.width = `${this.width}px`;<br/>  this.container.nativeElement.style.width = `${this.width}px`;<br/>}</strong></span></pre><p id="449b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在我们有了resize事件，让我们将它添加到我们的<strong class="ke ir">ngafterview it</strong>方法中，以便在初始化时设置我们的高度和宽度。此外，让我们稍后用一个<strong class="ke ir"> d3.select() </strong>更容易地引用我们的实际图表。</p><pre class="nb nc nd ne gt nf mo ng nh aw ni bi"><span id="3f12" class="mp lj iq mo b gy nj nk l nl nm"><strong class="mo ir">ngAfterViewInit(): <em class="ld">void</em> {<br/>    this.resize();<br/>    this.buildChart();<br/>}</strong></span></pre><h2 id="8417" class="mp lj iq bd lk mq mr dn lo ms mt dp ls kn mu mv lw kr mw mx ma kv my mz me na bi translated">建筑图</h2><p id="2a73" class="pw-post-body-paragraph kc kd iq ke b kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ij bi translated">现在我们开始讨论事情的实质。我们需要生成并绘制我们的甜甜圈。首先，让我们创建一个方法:buildChart()。</p><pre class="nb nc nd ne gt nf mo ng nh aw ni bi"><span id="8479" class="mp lj iq mo b gy nj nk l nl nm"><strong class="mo ir">private buildChart(): void { }</strong></span></pre><p id="4c31" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">故事的标题<br/> </strong>如果您想在甜甜圈标尺上方的卡片上显示一个标题，我们将检查标题并通过<strong class="ke ir"> <em class="ld"> innerHTML </em> </strong>添加它。</p><pre class="nb nc nd ne gt nf mo ng nh aw ni bi"><span id="2e9c" class="mp lj iq mo b gy nj nk l nl nm"><strong class="mo ir">if (this.title) {<br/>  this.titleContainer.nativeElement.innerHTML = this.title;<br/>}</strong></span></pre><p id="966a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">创建SVG <br/> </strong>让我们在ViewChild变量<code class="fe ml mm mn mo b"><strong class="ke ir">chart</strong></code>上通过D3 <code class="fe ml mm mn mo b"><strong class="ke ir">select()</strong></code>方法创建我们的SVG元素。</p><pre class="nb nc nd ne gt nf mo ng nh aw ni bi"><span id="5c31" class="mp lj iq mo b gy nj nk l nl nm"><strong class="mo ir">this.svg = d3.select(this.chart.nativeElement)<br/>  .append('g')<br/>  .attr('overflow', 'visible')<br/>  .attr('transform', `translate(${this.width / 2},${this.height / 2})`);</strong></span></pre><p id="b5e8" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"> Colors <br/> </strong>接下来，我们需要设置D3的<code class="fe ml mm mn mo b"><strong class="ke ir">scaleOrdinal()</strong></code>方法，它最终是一个映射方法，将我们的颜色通过它们在它们的域和范围内的顺序位置映射到我们的值。来自官方D3.js文档:</p><blockquote class="la lb lc"><p id="0f8c" class="kc kd ld ke b kf kg kh ki kj kk kl km le ko kp kq lf ks kt ku lg kw kx ky kz ij bi translated">用指定的<a class="ae lh" href="https://github.com/d3/d3-scale#ordinal_domain" rel="noopener ugc nofollow" target="_blank"> <em class="iq">域</em> </a>和<a class="ae lh" href="https://github.com/d3/d3-scale#ordinal_range" rel="noopener ugc nofollow" target="_blank"> <em class="iq">范围</em> </a>构造一个新的序数刻度。如果没有指定<em class="iq">域</em>，则默认为空数组。如果没有指定<em class="iq">范围</em>，则默认为空数组；在定义非空范围之前，序号始终返回未定义。</p></blockquote><pre class="nb nc nd ne gt nf mo ng nh aw ni bi"><span id="b862" class="mp lj iq mo b gy nj nk l nl nm"><strong class="mo ir">const color = d3.scaleOrdinal(this.data, this.colors);</strong></span></pre><p id="0da6" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">弧线<br/> </strong>我们将需要利用弧线生成器来创建一个圆形图表。D3有一个<code class="fe ml mm mn mo b"><strong class="ke ir">arc()</strong></code>方法可以做到这一点。这将生成一个具有内外半径的圆弧，该圆弧将有效地确定圆环的宽度。</p><pre class="nb nc nd ne gt nf mo ng nh aw ni bi"><span id="bb18" class="mp lj iq mo b gy nj nk l nl nm"><strong class="mo ir">const arc = d3.arc()<br/>  .innerRadius(Math.min(this.width, this.height) / 3)<br/>  .outerRadius(Math.min(this.width, this.height) / 2)<br/>  .cornerRadius(0);</strong></span></pre><p id="97bd" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">谁知道要做一个油炸圈饼，你需要一个馅饼？D3的<code class="fe ml mm mn mo b"><strong class="ke ir">pie()</strong></code>方法生成将表格数据集表示为饼图或圆环图所需的角度。为了实际创建圆环图，我们将饼图传递给上面的弧线生成器。然而，首先，我们需要创建一个饼图，不加修改地将我们的数据集传递给它<code class="fe ml mm mn mo b"><strong class="ke ir">(d: any) =&gt; d)</strong></code>。</p><pre class="nb nc nd ne gt nf mo ng nh aw ni bi"><span id="1e94" class="mp lj iq mo b gy nj nk l nl nm"><strong class="mo ir">const pie = d3.pie()<br/>  .value((d: any) =&gt; d);</strong></span></pre><p id="b929" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">该做油炸圈饼了！现在一切都为我们的计算做好了准备，我们可以开始画我们的甜甜圈了。我们将<code class="fe ml mm mn mo b"><strong class="ke ir">this.data</strong></code>传递给我们的<code class="fe ml mm mn mo b"><strong class="ke ir">pie()</strong></code>方法进行计算。然后，我们输入并附加一个路径，该路径有一个从饼图和数据生成的弧线。</p><pre class="nb nc nd ne gt nf mo ng nh aw ni bi"><span id="a0f4" class="mp lj iq mo b gy nj nk l nl nm"><strong class="mo ir">const path = this.svg.selectAll('path')<br/>  .data(pie(this.data))<br/>  .enter()<br/>  .append('path')<br/>  .attr('d', &lt;any&gt;arc)<br/>  .attr('fill', (d:any) =&gt; color(d))<br/>  .attr('stroke', 'none');</strong></span></pre><p id="63c9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">标记为<br/> </strong>如果我们想在圆环图中显示一个值，我们只需将<code class="fe ml mm mn mo b"><strong class="ke ir">text</strong></code>追加到我们的svg中。我们还对它应用了<code class="fe ml mm mn mo b"><strong class="ke ir">chart-label</strong></code>类，并用<code class="fe ml mm mn mo b"><strong class="ke ir">this.labelColor</strong></code>提供的颜色填充它。</p><pre class="nb nc nd ne gt nf mo ng nh aw ni bi"><span id="1760" class="mp lj iq mo b gy nj nk l nl nm"><strong class="mo ir">if (this.label) {<br/>  this.svg.append('text')<br/>    .attr('alignment-baseline', 'middle')<br/>    .attr('class', 'chart-label')<br/>    .attr('fill', this.labelColor)<br/>    .attr('text-anchor', 'middle')<br/>    .attr('x', 0)<br/>    .attr('y', 0)<br/>    .text(`${this.label}`);<br/>}</strong></span></pre><p id="f525" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">结束</strong> <br/>现在我们已经完成了所有这些，您的<code class="fe ml mm mn mo b"><strong class="ke ir">buildChart()</strong></code> <strong class="ke ir"> </strong>方法应该是这样的:</p><pre class="nb nc nd ne gt nf mo ng nh aw ni bi"><span id="7ee4" class="mp lj iq mo b gy nj nk l nl nm"><strong class="mo ir">private buildChart(): void {<br/>  if (this.title) {<br/>    this.titleContainer.nativeElement.innerHTML = this.title;<br/>  }</strong></span><span id="b083" class="mp lj iq mo b gy nn nk l nl nm"><strong class="mo ir">  this.svg = d3.select(this.chart.nativeElement)<br/>    .append('g')<br/>    .attr('overflow', 'visible')<br/>    .attr('transform', `translate(${this.width / 2},${this.height / 2})`);<br/>  <br/>  const color = d3.scaleOrdinal(this.data, this.colors);</strong></span><span id="bc41" class="mp lj iq mo b gy nn nk l nl nm"><strong class="mo ir">  const arc = d3.arc()<br/>    .innerRadius(Math.min(this.width, this.height) / 3)<br/>    .outerRadius(Math.min(this.width, this.height) / 2)<br/>    .cornerRadius(0);</strong></span><span id="f14c" class="mp lj iq mo b gy nn nk l nl nm"><strong class="mo ir">  const pie = d3.pie()<br/>    .value((d: any) =&gt; d);</strong></span><span id="3f82" class="mp lj iq mo b gy nn nk l nl nm"><strong class="mo ir">  const path = this.svg.selectAll('path')<br/>    .data(pie(this.data))<br/>    .enter()<br/>    .append('path')<br/>    .attr('d', &lt;any&gt;arc)<br/>    .attr('fill', (d:any) =&gt; color(d))<br/>    .attr('stroke', 'none');</strong></span><span id="3f28" class="mp lj iq mo b gy nn nk l nl nm"><strong class="mo ir">  if (this.label) {<br/>    this.svg.append('text')<br/>      .attr('alignment-baseline', 'middle')<br/>      .attr('class', 'chart-label')<br/>      .attr('fill', this.labelColor)<br/>      .attr('text-anchor', 'middle')<br/>      .attr('x', 0)<br/>      .attr('y', 0)<br/>      .text(`${this.label}`);<br/>  }</strong></span><span id="f36f" class="mp lj iq mo b gy nn nk l nl nm"><strong class="mo ir">}</strong></span></pre><p id="1170" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">初始化它<br/></strong></p><pre class="nb nc nd ne gt nf mo ng nh aw ni bi"><span id="f842" class="mp lj iq mo b gy nj nk l nl nm"><strong class="mo ir">ngAfterViewInit(): void {<br/>    this.resize();<br/>    this.buildChart();<br/>}</strong></span></pre><p id="95c3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">总结<br/> </strong>在所有这些有趣的事情之后，我们应该得到一个如下所示的chart.component.ts文件:</p><pre class="nb nc nd ne gt nf mo ng nh aw ni bi"><span id="e35d" class="mp lj iq mo b gy nj nk l nl nm"><strong class="mo ir">import { AfterViewInit, Component, ElementRef, HostListener, Input, ViewChild } from '@angular/core';<br/>import * as d3 from 'd3'</strong></span><span id="aed8" class="mp lj iq mo b gy nn nk l nl nm"><strong class="mo ir">@Component({<br/>    selector: 'app-chart',<br/>    templateUrl: './chart.component.html',<br/>    styleUrls: ['./chart.component.scss']<br/>})<br/>export class ChartComponent implements AfterViewInit {</strong></span><span id="ebc9" class="mp lj iq mo b gy nn nk l nl nm"><strong class="mo ir">@HostListener('window:resize', ['$event'])<br/>  onResize() {<br/>    this.resize();<br/>  }</strong></span><span id="5c2f" class="mp lj iq mo b gy nn nk l nl nm"><strong class="mo ir">  /* The colors of the donut chart, starting with the fill color, followed by the gauge background color. */<br/>  @Input() colors: string[] = [];</strong></span><span id="801d" class="mp lj iq mo b gy nn nk l nl nm"><strong class="mo ir">  /* The value to fill the donut, followed by the "unfilled" amount e.g. if we were displaying a donut representing 100% and we wanted to fill 88% of it, we'd supply [88,11] here. */<br/>  @Input() data: number[] = [];</strong></span><span id="5ee2" class="mp lj iq mo b gy nn nk l nl nm"><strong class="mo ir">  /* The height of the donut */<br/>  @Input() height: number;</strong></span><span id="10c9" class="mp lj iq mo b gy nn nk l nl nm"><strong class="mo ir">  /* Label for the inside of the donut, if desired */<br/>  @Input() label: string;</strong></span><span id="4c3c" class="mp lj iq mo b gy nn nk l nl nm"><strong class="mo ir">  /* Color of the label inside of the donut */<br/>  @Input() labelColor: string = 'rgba(80,80,80,.8)';</strong></span><span id="ff1c" class="mp lj iq mo b gy nn nk l nl nm"><strong class="mo ir">  /* The title of the chart, if desired */ <br/>  @Input() title: string;</strong></span><span id="0ce7" class="mp lj iq mo b gy nn nk l nl nm"><strong class="mo ir">  /* The width of the donut. */<br/>  @Input() width: number;</strong></span><span id="85c1" class="mp lj iq mo b gy nn nk l nl nm"><strong class="mo ir">  @ViewChild('chart') chart: ElementRef&lt;SVGElement&gt;;<br/>  @ViewChild('container') container: ElementRef&lt;HTMLDivElement&gt;;<br/>  @ViewChild('titleContainer') titleContainer: ElementRef&lt;HTMLDivElement&gt;;</strong></span><span id="fc6e" class="mp lj iq mo b gy nn nk l nl nm"><strong class="mo ir">  public svg: any;</strong></span><span id="55d8" class="mp lj iq mo b gy nn nk l nl nm"><strong class="mo ir">  constructor() { }</strong></span><span id="ade6" class="mp lj iq mo b gy nn nk l nl nm"><strong class="mo ir">  ngAfterViewInit(): <em class="ld">void</em> {<br/>    this.resize();<br/>    this.buildChart();<br/>  }</strong></span><span id="4f92" class="mp lj iq mo b gy nn nk l nl nm"><strong class="mo ir">  private buildChart(): void {<br/>    if (this.title) {<br/>      this.titleContainer.nativeElement.innerHTML = this.title;<br/>    }</strong></span><span id="52db" class="mp lj iq mo b gy nn nk l nl nm"><strong class="mo ir">    this.svg = d3.select(this.chart.nativeElement)<br/>      .append('g')<br/>      .attr('overflow', 'visible')<br/>      .attr('transform', `translate(${this.width / 2},${this.height / 2})`);<br/>  <br/>    const color = d3.scaleOrdinal(this.data, this.colors);</strong></span><span id="73cc" class="mp lj iq mo b gy nn nk l nl nm"><strong class="mo ir">    const arc = d3.arc()<br/>      .innerRadius(Math.min(this.width, this.height) / 3)<br/>      .outerRadius(Math.min(this.width, this.height) / 2)<br/>      .cornerRadius(0);</strong></span><span id="b05e" class="mp lj iq mo b gy nn nk l nl nm"><strong class="mo ir">    const pie = d3.pie()<br/>      .value((d: any) =&gt; d);</strong></span><span id="2a09" class="mp lj iq mo b gy nn nk l nl nm"><strong class="mo ir">    const path = this.svg.selectAll('path')<br/>      .data(pie(this.data))<br/>      .enter()<br/>      .append('path')<br/>      .attr('d', &lt;any&gt;arc)<br/>      .attr('fill', (d:any) =&gt; color(d))<br/>      .attr('stroke', 'none');</strong></span><span id="0fe7" class="mp lj iq mo b gy nn nk l nl nm"><strong class="mo ir">    if (this.label) {<br/>      this.svg.append('text')<br/>        .attr('alignment-baseline', 'middle')<br/>        .attr('class', 'chart-label')<br/>        .attr('fill', this.labelColor)<br/>        .attr('text-anchor', 'middle')<br/>        .attr('x', 0)<br/>        .attr('y', 0)<br/>        .text(`${this.label}`);<br/>    }</strong></span><span id="e242" class="mp lj iq mo b gy nn nk l nl nm"><strong class="mo ir">  }</strong></span><span id="98a8" class="mp lj iq mo b gy nn nk l nl nm"><strong class="mo ir">  private resize(): void {<br/>    this.height = (this.height &amp;&amp; !isNaN(this.height) &amp;&amp; this.height &gt; 0) ? this.height : this.container.nativeElement.parentElement.parentElement.offsetHeight;</strong></span><span id="aba7" class="mp lj iq mo b gy nn nk l nl nm"><strong class="mo ir">    this.width = (this.width &amp;&amp; !isNaN(this.width) &amp;&amp; this.width &gt; 0) ? this.width : this.container.nativeElement.parentElement.parentElement.offsetWidth;</strong></span><span id="be59" class="mp lj iq mo b gy nn nk l nl nm"><strong class="mo ir">    this.chart.nativeElement.style.height = `${this.height}px`;<br/>    this.container.nativeElement.style.height = `${this.height}px`;<br/>    this.chart.nativeElement.style.width = `${this.width}px`;<br/>    this.container.nativeElement.style.width = `${this.width}px`;<br/>  }</strong></span><span id="2ab9" class="mp lj iq mo b gy nn nk l nl nm"><strong class="mo ir">}</strong></span></pre><h2 id="fa37" class="mp lj iq bd lk mq mr dn lo ms mt dp ls kn mu mv lw kr mw mx ma kv my mz me na bi translated">chart.component.html</h2><p id="8d83" class="pw-post-body-paragraph kc kd iq ke b kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ij bi translated">我们的组件很棒，但是我们还没有显示任何东西。让我们在chart.component.html用以下内容快速替换Angular中的占位符:</p><pre class="nb nc nd ne gt nf mo ng nh aw ni bi"><span id="6a42" class="mp lj iq mo b gy nj nk l nl nm"><strong class="mo ir">&lt;div #titleContainer class="chart-title"&gt;&lt;/div&gt;<br/>&lt;div #container&gt;<br/>  &lt;svg #chart&gt;&lt;/svg&gt;<br/>&lt;/div&gt;</strong></span></pre><p id="d9f0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">您应该认识上面的<strong class="ke ir">#容器</strong>、<strong class="ke ir">#图表</strong>和<strong class="ke ir">#标题容器</strong>标识符——这些是我们在<strong class="ke ir">图表.组件. ts </strong>中用<strong class="ke ir"> ViewChild </strong>引用的</p><h1 id="45fe" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">演示组件</h1><p id="fcc9" class="pw-post-body-paragraph kc kd iq ke b kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ij bi translated">图表组件现在已经完成，但是我们没有使用它。让我们以使用它为目的创建一个新组件。</p><p id="45ec" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe ml mm mn mo b"><strong class="ke ir">ng generate component feature/demo</strong></code></p><h2 id="28e9" class="mp lj iq bd lk mq mr dn lo ms mt dp ls kn mu mv lw kr mw mx ma kv my mz me na bi translated">演示.组件. ts</h2><p id="bb6c" class="pw-post-body-paragraph kc kd iq ke b kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ij bi translated">我们只需要设置一个<code class="fe ml mm mn mo b">data</code>变量，它将保存我们量表的值和剩余的值来完成量表。我们将使用传入的数据变量来传递我们的<strong class="ke ir">demo.component.html</strong>文件，该文件实际上调用了我们的图表组件。</p><pre class="nb nc nd ne gt nf mo ng nh aw ni bi"><span id="44d0" class="mp lj iq mo b gy nj nk l nl nm"><strong class="mo ir">import { AfterViewInit, Component } from '@angular/core';</strong></span><span id="1081" class="mp lj iq mo b gy nn nk l nl nm"><strong class="mo ir">@Component({<br/>  selector: 'app-demo',<br/>  templateUrl: './demo.component.html',<br/>  styleUrls: ['./demo.component.scss']<br/>})<br/>export class DemoComponent implements AfterViewInit {</strong></span><span id="f960" class="mp lj iq mo b gy nn nk l nl nm"><strong class="mo ir">  public data: number[] = [88, 12];</strong></span><span id="fc2e" class="mp lj iq mo b gy nn nk l nl nm"><strong class="mo ir">  constructor() { }</strong></span><span id="8fce" class="mp lj iq mo b gy nn nk l nl nm"><strong class="mo ir">  ngAfterViewInit(): void {}</strong></span><span id="11cc" class="mp lj iq mo b gy nn nk l nl nm"><strong class="mo ir">}</strong></span></pre><h2 id="7d85" class="mp lj iq bd lk mq mr dn lo ms mt dp ls kn mu mv lw kr mw mx ma kv my mz me na bi translated">demo.component.html</h2><p id="576d" class="pw-post-body-paragraph kc kd iq ke b kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ij bi translated">现在让我们来显示圆环图仪表。我们会把它包起来，让它更显眼。我们将在下一节中设计这些样式。注意我们是如何将<strong class="ke ir"> [data]="data" </strong>发送到app-chart组件的。</p><pre class="nb nc nd ne gt nf mo ng nh aw ni bi"><span id="4f16" class="mp lj iq mo b gy nj nk l nl nm"><strong class="mo ir">&lt;div class="content"&gt;<br/>  &lt;div class="card"&gt;<br/>    &lt;div class="card-content"&gt;<br/>      &lt;div class="chart-wrapper"&gt;<br/>        &lt;app-chart <br/>            [colors]="['#3DA5EE', '#E8E8E8']"<br/>            [data]="data"<br/>            [height]="300"<br/>            [label]="'88%'"<br/>            [title]="'Completed'"<br/>            [width]="300"<br/>        &gt;&lt;/app-chart&gt;<br/>      &lt;/div&gt;<br/>    &lt;/div&gt;<br/>  &lt;/div&gt;<br/>&lt;/div&gt;</strong></span></pre><h1 id="877e" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">风格</h1><p id="8dea" class="pw-post-body-paragraph kc kd iq ke b kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ij bi translated">所有这些工作都很棒，但是除非它们看起来很吸引人，否则我们为什么会在这里？我说的对吗？让我们打开<strong class="ke ir"> src </strong>目录下的<strong class="ke ir"> styles.scss </strong>文件。</p><blockquote class="la lb lc"><p id="1e7c" class="kc kd ld ke b kf kg kh ki kj kk kl km le ko kp kq lf ks kt ku lg kw kx ky kz ij bi translated"><strong class="ke ir">抬头！</strong> <br/>如果你在生成Angular项目时没有指定<code class="fe ml mm mn mo b"><strong class="ke ir"><em class="iq">--style scss</em></strong></code>，那么你将会根据你的选择来寻找<strong class="ke ir"> styles.css、styles.less或styles.sass </strong>。如果您根本没有指定<code class="fe ml mm mn mo b"><strong class="ke ir"><em class="iq">--style</em></strong></code>，那么您将会寻找<strong class="ke ir"> styles.css </strong></p></blockquote><pre class="nb nc nd ne gt nf mo ng nh aw ni bi"><span id="ac4e" class="mp lj iq mo b gy nj nk l nl nm"><a class="ae lh" href="http://twitter.com/import" rel="noopener ugc nofollow" target="_blank"><strong class="mo ir">@import</strong></a><strong class="mo ir"> url('</strong><a class="ae lh" href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@400;600;800&amp;display=swap'" rel="noopener ugc nofollow" target="_blank"><strong class="mo ir">https://fonts.googleapis.com/css2?family=Open+Sans:wght@400;600;800&amp;display=swap'</strong></a><strong class="mo ir">);</strong></span><span id="0409" class="mp lj iq mo b gy nn nk l nl nm"><strong class="mo ir">:root {<br/>  font-family: 'Open Sans', sans-serif;<br/>  font-size: 12px;<br/>}</strong></span><span id="c9e9" class="mp lj iq mo b gy nn nk l nl nm"><strong class="mo ir">.card {<br/>  align-content: flex-start;<br/>  align-items: flex-start;<br/>  border-radius: 8px;<br/>  box-shadow: 0 0 8px 0 rgba(40, 40, 40, .3);<br/>  display: flex;<br/>  flex: 0 0a 300px;<br/>  flex-flow: row wrap;<br/>  justify-content: flex-start;<br/>  margin: 8px;<br/>  padding: 16px;<br/>  position: relative;<br/>  width: 300px;<br/>}</strong></span><span id="c962" class="mp lj iq mo b gy nn nk l nl nm"><strong class="mo ir">.card-content {<br/>  height: 100%;<br/>  width: 100%;<br/>}</strong></span><span id="bdda" class="mp lj iq mo b gy nn nk l nl nm"><strong class="mo ir">.chart-label {<br/>  color: rgba(120,120,120,.4);<br/>  font-size: 4rem;<br/>  font-weight: 600;<br/>  text-align: center;<br/>}</strong></span><span id="b90d" class="mp lj iq mo b gy nn nk l nl nm"><strong class="mo ir">.chart-title {<br/>  color: rgba(40,40,40,.8);<br/>  font-size: 1.4rem;<br/>  font-weight: 600;<br/>  margin: 0px 0px 8px 0px;<br/>  text-align: center;<br/>  width: 100%;<br/>}</strong></span><span id="ca96" class="mp lj iq mo b gy nn nk l nl nm"><strong class="mo ir">.chart-wrapper {<br/>  min-height: 300px;<br/>  min-width: 300px;<br/>  width: 300px;<br/>}</strong></span><span id="3fef" class="mp lj iq mo b gy nn nk l nl nm"><strong class="mo ir">.content {<br/>  display: flex;<br/>  flex-flow: row wrap;<br/>  justify-content: space-evenly;<br/>}</strong></span></pre><h1 id="db5f" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">应用</h1><p id="50db" class="pw-post-body-paragraph kc kd iq ke b kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ij bi translated">最后，我们需要设置更多的项目，如样式和路由(这样我们就可以进入我们的演示组件)。</p><h2 id="57f4" class="mp lj iq bd lk mq mr dn lo ms mt dp ls kn mu mv lw kr mw mx ma kv my mz me na bi translated">app-routing.module.ts</h2><p id="25ba" class="pw-post-body-paragraph kc kd iq ke b kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ij bi translated">让我们打开位于<strong class="ke ir">app/app-routing . module . ts</strong>中的<strong class="ke ir"> app-routing.module.ts </strong>文件，设置我们的路由并默认到演示组件。路由超出了本文的范围，所以如果您不确定这里发生了什么，我建议您阅读Angular Router。</p><pre class="nb nc nd ne gt nf mo ng nh aw ni bi"><span id="4f1e" class="mp lj iq mo b gy nj nk l nl nm"><strong class="mo ir">import { NgModule } from '@angular/core';<br/>import { Routes, RouterModule } from '@angular/router';</strong></span><span id="e247" class="mp lj iq mo b gy nn nk l nl nm"><strong class="mo ir">import { DemoComponent } from '~app/feature/demo/demo.component';</strong></span><span id="788f" class="mp lj iq mo b gy nn nk l nl nm"><strong class="mo ir">const routes: Routes = [<br/>  {<br/>    path: '',<br/>    pathMatch: 'full',<br/>    redirectTo: 'demo',<br/>  },<br/>  {<br/>    component: DemoComponent,<br/>    path: 'demo'<br/>  }<br/>];</strong></span><span id="eaa7" class="mp lj iq mo b gy nn nk l nl nm"><strong class="mo ir">@NgModule({<br/>  imports: [RouterModule.forRoot(routes)],<br/>  exports: [RouterModule]<br/>})<br/>export class AppRoutingModule { }</strong></span></pre><h2 id="483e" class="mp lj iq bd lk mq mr dn lo ms mt dp ls kn mu mv lw kr mw mx ma kv my mz me na bi translated">app.component.html</h2><p id="d51f" class="pw-post-body-paragraph kc kd iq ke b kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ij bi translated">我们将清除我们的<strong class="ke ir"> app/app.component.html </strong>文件中的所有无意义内容，并用一个简单的liner替换它。不，真的，这就是我们想要的文件。</p><pre class="nb nc nd ne gt nf mo ng nh aw ni bi"><span id="c064" class="mp lj iq mo b gy nj nk l nl nm"><strong class="mo ir">&lt;router-outlet&gt;&lt;/router-outlet&gt;</strong></span></pre><h1 id="85be" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">成品</h1><p id="c36c" class="pw-post-body-paragraph kc kd iq ke b kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ij bi translated">如果一切顺利，当你加载你的应用程序时，你会看到一个带有圆环标尺的卡片(通常是<a class="ae lh" href="http://localhost:4200)." rel="noopener ugc nofollow" target="_blank"><strong class="ke ir">http://localhost:4200</strong>)。</a></p><figure class="nb nc nd ne gt jr gh gi paragraph-image"><div class="gh gi no"><img src="../Images/766572afd2bd22b45eca89ac74b00899.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/format:webp/1*7J5oz0zClQ90-FpLRFbnsw.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">完成的圆环图仪表的屏幕截图</figcaption></figure><h1 id="f0b3" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">Git储存库</h1><p id="89bd" class="pw-post-body-paragraph kc kd iq ke b kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ij bi translated">你可以在github这里访问完整的项目:<a class="ae lh" href="https://github.com/johnathanesanders/angular-d3-donut-gauge" rel="noopener ugc nofollow" target="_blank">https://github.com/johnathanesanders/angular-d3-donut-gauge</a></p><p id="0d2a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">感谢阅读！</strong></p><p id="e1f3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="ld">甜甜圈照片由</em> <a class="ae lh" href="https://www.pexels.com/@mikael-blomkvist?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> <em class="ld">迈克尔·布隆维斯特</em> </a> <em class="ld">发自</em> <a class="ae lh" href="https://www.pexels.com/photo/a-cellphone-beside-a-vase-6483588/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> <em class="ld">像素</em> </a></p></div></div>    
</body>
</html>