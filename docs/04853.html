<html>
<head>
<title>Raw SQL vs Query Builder vs ORM</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">原始SQL与查询生成器和ORM</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/raw-sql-vs-query-builder-vs-orm-eee72dbdd275?source=collection_archive---------0-----------------------#2020-07-20">https://levelup.gitconnected.com/raw-sql-vs-query-builder-vs-orm-eee72dbdd275?source=collection_archive---------0-----------------------#2020-07-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9420" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何与您的关系数据库对话</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2fe39305bb0c742c82a8b038f7130939.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qVvejuQezddtFwrWDbFqjw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:马丁·托马斯拍摄的phpmyadmin截图</figcaption></figure><p id="cbe8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">数据库是几乎所有web应用程序存储状态的核心。因此，处理与数据库的交互对于确保应用程序持续运行至关重要。与大多数关系数据库交互的方式是SQL——SQL的<strong class="la iu"> <em class="lu"> S </em> </strong> <em class="lu">结构化</em><strong class="la iu"><em class="lu">Q</em></strong><em class="lu">uery</em><strong class="la iu"><em class="lu">L</em></strong><em class="lu">语言</em>。SQL使得切换实际的数据库系统或使用该数据库的客户机变得极其简单。到处都是SQL而已。你需要一个<em class="lu">数据库驱动</em>，然后你可以进行典型的CRUD交互:<strong class="la iu">C</strong>create，<strong class="la iu"> R </strong> ead，<strong class="la iu"> U </strong> pdate和<strong class="la iu">D</strong>delete data。</p><p id="3b0e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">读完这篇文章，你会知道什么时候使用原始SQL，一个查询生成器和一个ORM。您还将知道如何在Python中使用它们。</p><p id="0201" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">本文中的所有代码都是可运行的。你只需要<a class="ae lv" href="https://gist.github.com/MartinThoma/95b603226f84f3be25f4eaf2393fba9e" rel="noopener ugc nofollow" target="_blank">初始化数据库</a>并添加环境变量。我使用<a class="ae lv" href="https://direnv.net/" rel="noopener ugc nofollow" target="_blank"> direnv </a>来设置环境变量:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><h1 id="3c04" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated"><strong class="ak">原始SQL </strong></h1><p id="7114" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated"><em class="lu">原始SQL，</em>有时也叫<em class="lu">原生SQL，</em>是最基本、最底层的数据库交互形式。你用数据库的语言告诉数据库做什么。大多数开发人员应该了解SQL的基础知识。这意味着如何创建表和视图，如何选择和连接数据，如何更新和删除数据。对于更复杂的东西，如<a class="ae lv" href="https://en.wikipedia.org/wiki/Stored_procedure" rel="noopener ugc nofollow" target="_blank">存储过程</a>，T-SQL，PL-SQL，关于索引及其效果的深入知识，你将很难找到有知识的人。SQL比许多开发人员想象的要强大得多。例如，我不知道<a class="ae lv" href="http://wiki.postgresql.org/wiki/Mandelbrot_set" rel="noopener ugc nofollow" target="_blank">如何用SQL </a>创建Mandelbrot集合。</p><p id="634f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了说明原始SQL语句的问题，以一个图书门户为例。用户可以看到关于书籍的数据，例如书名、原文和作者:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/33f6dd46f8c369e2e555c3ff3f516666.png" data-original-src="https://miro.medium.com/v2/resize:fit:1198/format:webp/1*y7HrJPVrBTnXOuIKGH0k1A.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">每本书都有一个作者，但是每个作者可能有任意数量的书。</figcaption></figure><p id="eec5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于一个作者页面，我们被给定了<code class="fe mw mx my mz b">authors.id</code>，并希望看到该作者写的所有<code class="fe mw mx my mz b">books.title</code>的列表:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">您需要通过“pip install pymysql”安装驱动程序pymysql</figcaption></figure><p id="8aed" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">装饰器是项目可能会经常用到的实用程序代码。</p><p id="9249" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">从积极的一面来看，原始SQL会发生什么是非常清楚的。你只需要Python和SQL的知识。无需深谙第三方软件。</p><p id="3102" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，使用原始SQL有六个不好的方面需要注意。</p><h2 id="9b9a" class="na lz it bd ma nb nc dn me nd ne dp mi lh nf ng mk ll nh ni mm lp nj nk mo nl bi translated">问题1: SQL注入</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/c610bdf2bc01e2926cae3b17b5e7dcfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1332/format:webp/1*P4nj9fJjSeJ9-c0rwSZqlg.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图片来源:<a class="ae lv" href="https://xkcd.com/327/" rel="noopener ugc nofollow" target="_blank"> xkcd </a></figcaption></figure><p id="a28f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">SQL注入是对在SQL查询中有占位符的服务的攻击，攻击者可以以意想不到的方式填充占位符。例如:</p><pre class="kj kk kl km gt nn mz no np aw nq bi"><span id="53cd" class="na lz it mz b gy nr ns l nt nu">sql = "SELECT user_id FROM users WHERE name='{name}' AND pw='{pw}';"</span></pre><p id="74cd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">采用这种方法，攻击者可以在<code class="fe mw mx my mz b">pw</code>中填入<code class="fe mw mx my mz b">' OR name='admin' AND '1'='1</code>,在名称中留空。这将导致查询</p><pre class="kj kk kl km gt nn mz no np aw nq bi"><span id="d433" class="na lz it mz b gy nr ns l nt nu">SELECT user_id <br/>FROM users<br/>WHERE name='' AND pw=<!-- -->''<br/>OR name='admin' AND '1'='1'</span></pre><p id="8d51" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这将基本上告诉应用程序，用户作为管理员登录。</p><p id="5bb4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当然，对引号进行转义，而不是直接粘贴到用户输入中，这才是你应该做的。但是开发者会犯错。原始SQL查询很容易犯这种错误。</p><h2 id="2ee7" class="na lz it bd ma nb nc dn me nd ne dp mi lh nf ng mk ll nh ni mm lp nj nk mo nl bi translated">问题SQL命令中的拼写错误</h2><p id="8c76" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">字符串编程的第一个明显问题是子语言中的错别字不能被编辑器发现。</p><pre class="kj kk kl km gt nn mz no np aw nq bi"><span id="214a" class="na lz it mz b gy nr ns l nt nu">sql = "SELECT * FROM books;"</span></pre><h2 id="bf9b" class="na lz it bd ma nb nc dn me nd ne dp mi lh nf ng mk ll nh ni mm lp nj nk mo nl bi translated">问题3:缺少编辑器支持</h2><p id="4ade" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">这个问题很愚蠢，但对于许多语言/编辑器来说仍然是一个公开的问题:当开发人员仅仅用他们语言中的一个字符串编写他们的SQL时，编辑器应该如何知道这个字符串需要被解析？编辑器如何知道他们想要语法高亮和自动完成？</p><p id="d496" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你可以在上面的例子中看到，语法突出显示不见了，但是让我给你一些著名编辑器的截图:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nv"><img src="../Images/6f4a0614782d4150b82de33cb3394b95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qzKYVFCrlVxXBOC2uhldFw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">崇高文字3.2，截图由马丁托马斯拍摄</figcaption></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nw"><img src="../Images/237ac7677c067dca6a25a9a07bd07619.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pPYivdszaoNiU2eVLl3E1g.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">VS代码1.47，截图由马丁·托马斯拍摄</figcaption></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/ba1e7af8c65c6da299933e0614d3ba2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_ZlAqcNmK0kmPJs2UmXVww.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">vim 8.1，截图由马丁·托马斯拍摄</figcaption></figure><p id="fa5e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">相比之下，下面是一个<code class="fe mw mx my mz b">query.sql</code>文件中的相同查询:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ny"><img src="../Images/5510c0314232d182c53ff4561a7e2a91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H-lgQ9zmjX-hJALguh6zrA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">崇高文字3.2，截图由马丁托马斯拍摄</figcaption></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/37658450797fb05d0f13406ed9760f06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6HwHnH8ih5L1upUmtmfz_w.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">VS代码1.47，截图由马丁·托马斯拍摄</figcaption></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/776961607a07980479659464e1e73301.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_V2p9mUs6ctisyBuJU4xWA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">vim 8.1，截图由马丁·托马斯拍摄</figcaption></figure><p id="2abe" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我也试过皮查姆。除了琴弦有另一种颜色，看起来都一样。它不识别字符串包含SQL。</p><p id="fc6f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您确实需要原始查询，并且仍然希望突出显示语法，那么您可以将每个查询放在它自己的query.sql文件中。这样，编辑器知道如何使用SQL语法高亮显示。</p><h2 id="7888" class="na lz it bd ma nb nc dn me nd ne dp mi lh nf ng mk ll nh ni mm lp nj nk mo nl bi translated">问题4:表或列名中的拼写错误</h2><pre class="kj kk kl km gt nn mz no np aw nq bi"><span id="ebd1" class="na lz it mz b gy nr ns l nt nu">sql = "SELECT * from boks;"</span></pre><p id="b372" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这组错误更难发现。现在，检查代码不仅需要知道SQL如何工作，还需要知道您的数据。更准确地说是数据库模式。</p><h2 id="6b89" class="na lz it bd ma nb nc dn me nd ne dp mi lh nf ng mk ll nh ni mm lp nj nk mo nl bi translated">问题5:变革管理</h2><p id="ed2d" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">数据库会随着时间而变化。对于原始SQL，您通常得不到任何支持。您必须自己迁移模式和所有查询。</p><h2 id="3f49" class="na lz it bd ma nb nc dn me nd ne dp mi lh nf ng mk ll nh ni mm lp nj nk mo nl bi translated">问题6:查询扩展</h2><p id="1c2d" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">如果您有一个分析查询，如果您可以对它进行轻微的修改就好了。例如，假设跟踪数据，您想知道有多少用户点击了一个按钮。对此，您可能有一个“基本查询”。根据使用案例，您可能希望针对特定的时间框架或用户特征进行过滤。当您有原始SQL时，可以扩展查询，但这很麻烦。您需要接触原始查询并添加占位符。</p><h1 id="e6a9" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated"><strong class="ak">查询生成器</strong></h1><p id="2aa1" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">用您使用的编程语言编写的库，使用本地类和函数来构建SQL查询，称为<em class="lu">查询构建器</em>。查询构建器通常有一个<a class="ae lv" href="https://en.wikipedia.org/wiki/Fluent_interface" rel="noopener ugc nofollow" target="_blank">流畅的接口</a>。这意味着查询是由使用方法链接的面向对象接口构建的:</p><pre class="kj kk kl km gt nn mz no np aw nq bi"><span id="75de" class="na lz it mz b gy nr ns l nt nu">query = Query.from_(books) \<br/>             .select("*") \<br/>             .where(books.author_id == aid)</span></pre><p id="9364" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">还有一些图形工具，有时也被称为查询构建器，但在本文中我不是指它们。</p><p id="b028" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">JavaScript <a class="ae lv" href="http://knexjs.org/" rel="noopener ugc nofollow" target="_blank"> Knex </a>，PHP有<a class="ae lv" href="https://www.doctrine-project.org/projects/doctrine-dbal/en/2.10/reference/query-builder.html#sql-query-builder" rel="noopener ugc nofollow" target="_blank">主义</a>，Java有<a class="ae lv" href="http://www.querydsl.com/" rel="noopener ugc nofollow" target="_blank"> QueryDSL </a>和<a class="ae lv" href="http://www.jooq.org/" rel="noopener ugc nofollow" target="_blank"> JOOQ </a>。</p><p id="4da7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Pypika是Python中查询构建器的一个例子。上面的示例查询可以像这样构建和执行:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="d87d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意，结果查询仍然与原始代码中的相同。它只是以另一种方式建造的。这意味着数据库性能仍然相同。并且查询构建不是一项复杂的任务，所以应用程序的整体性能应该保持不变。</p><p id="2d41" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您还可以看到，连接处理仍然像以前一样完成。与原始SQL示例相比，代码的总行数增加了3行。但是，该查询更容易扩展和重用。例如，您可以想象您有一组复杂的连接和许多WHERE语句。对于一个普通的SQL查询，您将开始在那里添加选项。使用查询生成器，扩展和重用查询变得更加简单。为了使其可重用，您可以在某处公开查询<code class="fe mw mx my mz b">q</code>。</p><p id="fbc0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">查询生成器可防止所提供零件中的打字错误。上例中的<code class="fe mw mx my mz b">select</code>、<code class="fe mw mx my mz b">.from_</code>、<code class="fe mw mx my mz b">.where</code>。它对列名没有帮助，因为它们仍然只是字符串。换句话说:查询构建器解决了问题1和2，解决了问题3，但仍然有问题4和5。</p><h1 id="902a" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">ORM:对象关系映射器</h1><p id="fa1a" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">ORMs为每个数据库表创建一个对象。这样，就有了一个语言本地的表示，因此所有的语言生态系统特性，比如自动完成和语法突出显示都可以工作。</p><p id="620b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">ORMs在很多语言中都极其流行:Java有<a class="ae lv" href="http://hibernate.org/" rel="noopener ugc nofollow" target="_blank"> Hibernate </a>，PHP有<a class="ae lv" href="https://laravel.com/docs/5.0/eloquent" rel="noopener ugc nofollow" target="_blank">雄辩</a>，Ruby有<a class="ae lv" href="https://guides.rubyonrails.org/active_record_basics.html" rel="noopener ugc nofollow" target="_blank"> activerecord </a>，JavaScript有<a class="ae lv" href="https://sequelize.org/" rel="noopener ugc nofollow" target="_blank"> Sequelize </a>和<a class="ae lv" href="https://typeorm.io/" rel="noopener ugc nofollow" target="_blank"> TypeORM </a>，Python有<a class="ae lv" href="https://www.sqlalchemy.org/" rel="noopener ugc nofollow" target="_blank"> SQLAlchemy </a>。</p><p id="2cc6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">以下是使用SQLAlchemy的图书示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="3169" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">ORM很酷的一点是，它们有时有助于改变。在Python中，有一个<a class="ae lv" href="https://alembic.sqlalchemy.org/en/latest/" rel="noopener ugc nofollow" target="_blank"> Alembic </a>，它可以自动检测你的模型相对于数据库最后已知状态的变化。然后，Alembic可以为您创建模式迁移文件。它们看起来像这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="4dee" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最初需要在代码中表示数据库，这样就有了表示数据库表的对象。完成最初的工作后，您需要确保数据库与查询构建器代码库同步。当您只需要编写新的查询时，您从这种努力中获得的是更快的开发。由于您还可以获得语法突出显示和自动格式化，它还可以通过使查询更容易阅读来减少维护。</p><h2 id="6de7" class="na lz it bd ma nb nc dn me nd ne dp mi lh nf ng mk ll nh ni mm lp nj nk mo nl bi translated">过量提取问题</h2><p id="26ba" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">当您使用ORM执行查询时，您往往会得到超出您需要的结果。例如，如果您想直接使用ORM进行上面的图书查询，您可以像这样定义外键:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="894e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然后数据库接收这两个查询:</p><pre class="kj kk kl km gt nn mz no np aw nq bi"><span id="d182" class="na lz it mz b gy nr ns l nt nu">SELECT authors.id         AS authors_id, <br/>       authors.first_name AS authors_first_name, <br/>       authors.last_name  AS authors_last_name <br/>FROM   authors <br/>WHERE  authors.id = 1;</span><span id="01ea" class="na lz it mz b gy ob ns l nt nu">SELECT books.id        AS books_id, <br/>       books.title     AS books_title, <br/>       books.author_id AS books_author_id <br/>FROM   books <br/>WHERE  1 = books.author_id</span></pre><p id="c6e8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是低效的，原因有多种:</p><ol class=""><li id="3e0a" class="oc od it la b lb lc le lf lh oe ll of lp og lt oh oi oj ok bi translated">我根本不想要作者信息。</li><li id="1343" class="oc od it la b lb ol le om lh on ll oo lp op lt oh oi oj ok bi translated">数据库需要执行两个查询，而不是一个。</li><li id="e9c4" class="oc od it la b lb ol le om lh on ll oo lp op lt oh oi oj ok bi translated">我不想要图书ID或作者ID。当然，这是一个无关紧要的小例子。但是想象一下，您的查询将返回几百行，也有几百列。也许有些会填充相当大的内容，例如<a class="ae lv" href="https://mariadb.com/kb/en/longblob/" rel="noopener ugc nofollow" target="_blank"> LONGBLOB </a>。</li></ol><p id="258e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当然，你可以这样做:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="be40" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这导致了以下查询:</p><pre class="kj kk kl km gt nn mz no np aw nq bi"><span id="5b45" class="na lz it mz b gy nr ns l nt nu">SELECT authors.id         AS authors_id, <br/>       authors.first_name AS authors_first_name, <br/>       authors.last_name  AS authors_last_name, <br/>       books_1.id         AS books_1_id, <br/>       books_1.title      AS books_1_title <br/>FROM   authors <br/>       LEFT OUTER JOIN books AS books_1 <br/>                    ON authors.id = books_1.author_id <br/>WHERE  authors.id = 1</span></pre><p id="dbc5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在更糟了。我起初认为这是一个错误，但我认为这很好地展示了如何在使用ORM时以一种非常复杂的方式获得正确的结果。当然，正确的方法应该是:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="6d7a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这导致了以下查询:</p><pre class="kj kk kl km gt nn mz no np aw nq bi"><span id="0e4a" class="na lz it mz b gy nr ns l nt nu">SELECT books.title AS books_title <br/>FROM   books, <br/>       authors <br/>WHERE  authors.id = 1</span></pre><p id="fa10" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个例子的重点不是ORM使得做正确的事情变得困难。最后一个例子当然很容易理解。但是它们也使得创建查询变得容易，而这些查询在某种程度上是错误的。假设您收到了<code class="fe mw mx my mz b">orms2.py</code>或<code class="fe mw mx my mz b">orms3.py</code>示例进行回顾。他们做了正确的事情，单元测试也不慢。你能确定找出不必要的复杂性吗？当所需的查询变得更加复杂时。</p><p id="d81f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于原始的SQL和查询构建器，您必须不怕麻烦地提出类似的复杂查询。在那里很难编写太复杂的查询，并且很容易发现它们。</p><h2 id="a8fa" class="na lz it bd ma nb nc dn me nd ne dp mi lh nf ng mk ll nh ni mm lp nj nk mo nl bi translated">N+1问题:初始提取不足</h2><p id="6460" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">假设您想打印一份包含作者姓名的所有书籍的列表。在原始SQL中，您将执行以下查询:</p><pre class="kj kk kl km gt nn mz no np aw nq bi"><span id="e979" class="na lz it mz b gy nr ns l nt nu">SELECT b.id, <br/>       b.title, <br/>       a.first_name, <br/>       a.last_name <br/>FROM   books AS b <br/>       LEFT JOIN authors AS a <br/>              ON b.author_id = a.id</span></pre><p id="76f0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于ORM，您可能想这样做:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="ff26" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它看起来很好，因为在for循环中没有看到<code class="fe mw mx my mz b">session.query</code>，但是对于其中的每个元素，它都会触发一个查询。因此，如果您在第一个查询中收到了<code class="fe mw mx my mz b">n</code>本书，您将执行您可能不知道的<code class="fe mw mx my mz b">n</code>查询。您有<code class="fe mw mx my mz b">n+1</code>个查询，而不是<code class="fe mw mx my mz b">1</code>。</p><h2 id="fe46" class="na lz it bd ma nb nc dn me nd ne dp mi lh nf ng mk ll nh ni mm lp nj nk mo nl bi translated">泄漏抽象问题</h2><p id="ab6d" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">抽象是一枚双面硬币:一方面，它简化了事物。开发人员不必处理数据库交互和查询构建的细节。另一方面，开发人员不知道他们实际上从数据库中查询了什么，也不知道他们发送了多少查询。由于这个原因，一些交互比他们需要的效率更低(<a class="ae lv" href="https://www.youtube.com/watch?v=3TJfR1Ta4GU" rel="noopener ugc nofollow" target="_blank">例子</a>)。ORM可能不知道就在下一行代码中触发了一个非常相似的查询，它可以与第一行结合起来。例如，假设您有一个图书门户，人们可以在那里给出一个作者列表，然后您返回给他们这些作者写的所有图书的列表。您可能会尝试这样做:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="731b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，您为每个作者发送一次查询。当然，您可以在一个查询中做到这一点。您应该这样做，因为尽管上面的循环看起来不错，但您在两者之间有一个网络连接。这是使用单个查询的方法:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><h1 id="d1de" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">奖金:LINQ</h1><p id="1b4e" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">语言集成查询(简称:LINQ)在C#中可用，并且可能是查询构建者试图解决的问题的内置解决方案。这里有一个来自维基百科的<a class="ae lv" href="https://en.wikipedia.org/wiki/Language_Integrated_Query#Language_extensions" rel="noopener ugc nofollow" target="_blank">例子:</a></p><pre class="kj kk kl km gt nn mz no np aw nq bi"><span id="fb42" class="na lz it mz b gy nr ns l nt nu">var results =  <strong class="mz iu">from</strong> c <strong class="mz iu">in</strong> SomeCollection<br/>               <strong class="mz iu">where</strong> c.SomeProperty &lt; 10<br/>               <strong class="mz iu">select</strong> <strong class="mz iu">new</strong> {c.SomeProperty, c.OtherProperty};</span></pre><p id="91f9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这真是太棒了，不是吗？</p><h1 id="a4b5" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">查询类型和渐变</h1><p id="461c" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">我使用了一个非常简单的示例查询。当然，查询会变得更加复杂。我自己编写了几百行的查询。有两组典型的工作负载:<a class="ae lv" href="https://en.wikipedia.org/wiki/Online_transaction_processing" rel="noopener ugc nofollow" target="_blank"> OLTP </a>和<a class="ae lv" href="https://en.wikipedia.org/wiki/Online_analytical_processing" rel="noopener ugc nofollow" target="_blank"> OLAP </a>。OLTP工作负载有大量的小型插入/更新/删除，而OLAP工作负载运行少量复杂的选择查询进行分析。</p><p id="b45f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当然，如果您处于大多数查询都相当简单的场景中，那么切换到查询构建器或ORM是很容易的。但是如果您有复杂的查询，切换到ORM甚至是不可能的。</p><p id="8580" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这就是渐变发挥作用的地方。类似于<a class="ae lv" href="https://medium.com/analytics-vidhya/type-annotations-in-python-3-8-3b401384403d" rel="noopener"> Python支持逐步输入</a>，一些ORMs查询构建器允许你使用原始SQL。一些查询构建器允许您首先使用字符串作为表名和列名，然后根据需要转换为对象。如果你可以只取感觉自然的抽象量，你的开发速度不会受到阻碍。如果你有一个复杂的查询，你首先想得到正确的，只需写它的原始数据。稍后查询构建器仍然可以将其更改为表达式。</p><h1 id="5022" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">结论</h1><p id="b52e" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">原始SQL肯定是与数据库交互的最强大的方式，因为它是数据库的本地语言。缺点是您可能会使用特定于该数据库的特性，这使得将来的数据库切换更加困难。另一个缺点是缺少语法高亮和自动完成等核心编辑器特性。扩展查询很麻烦，SQL注入的风险也更高。</p><p id="9505" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">与原始SQL相比，查询构建器增加了很少的开发开销，没有相关的运行时开销，并且防止了SQL关键字中的拼写错误。它们使扩展查询变得更容易，而使SQL注入变得更困难。</p><p id="c086" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">orm提供了最高形式的抽象，不仅可以防止SQL关键字中的拼写错误，还可以防止表名和列名中的拼写错误。无论是从学习曲线的角度还是从初始开发开销的角度来看，它们都比查询构建器需要更长的启动时间。因为它们抽象了很多，所以执行昂贵的查询或太多查询的风险更高。</p><h1 id="09b8" class="ly lz it bd ma mb mc md me mf mg mh mi jz mj ka mk kc ml kd mm kf mn kg mo mp bi translated">信用</h1><p id="9d2b" class="pw-post-body-paragraph ky kz it la b lb mq ju ld le mr jx lg lh ms lj lk ll mt ln lo lp mu lr ls lt im bi translated">非常感谢<a class="ae lv" href="https://www.linkedin.com/in/marcel-kost/" rel="noopener ugc nofollow" target="_blank"> Marcel Kost </a>和<a class="ae lv" href="https://www.linkedin.com/in/adrian-vogelsgesang-95485a7a/?originalSubdomain=de" rel="noopener ugc nofollow" target="_blank"> Adrian Vogelsgesang </a>，他们为本文指出了许多有趣的方面。他们建立了在Tableau内部使用的超级数据库，所以当涉及到复杂的查询以及数据库系统如何处理这些查询时，他们是专家。谢谢你🤗</p></div></div>    
</body>
</html>