<html>
<head>
<title>Practical DDD in Golang: Aggregate</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">戈朗实用DDD:骨料</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/practical-ddd-in-golang-aggregate-de13f561e629?source=collection_archive---------1-----------------------#2021-09-20">https://levelup.gitconnected.com/practical-ddd-in-golang-aggregate-de13f561e629?source=collection_archive---------1-----------------------#2021-09-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="473b" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">领域驱动设计</h2><div class=""/><div class=""><h2 id="83a6" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">一个DDD模式来统治他们。</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/4fe0316966c858a2cb70dfd1ae832cb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FjIab6D-75AJ-oVu"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">拉斐尔·比斯卡尔迪在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="6e9a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我花了几年时间理解和实践DDD方法。大多数原则都易于理解并在代码中实现。然而，有一个引起了我的特别注意。</p><p id="1277" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我必须说，聚合是DDD最关键的模式，没有它，整个战术领域驱动的设计可能没有意义。它将业务逻辑绑定在一起。</p><p id="e714" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在阅读过程中，您可能会发现Aggregate更像是一组模式，但这是一种误解。聚合是域层的中心点。没有它，就没有使用DDD的理由。</p><pre class="ks kt ku kv gt me mf mg mh aw mi bi"><span id="b553" class="mj mk it mf b gy ml mm l mn mo">Other articles from DDD series:</span><span id="ed2b" class="mj mk it mf b gy mp mm l mn mo"><strong class="mf jd">1. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-ddd-in-golang-value-object-4fc97bcad70"><strong class="mf jd">Practical DDD in Golang: Value Object</strong></a></span><span id="ec6f" class="mj mk it mf b gy mp mm l mn mo"><strong class="mf jd">2. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-ddd-in-golang-entity-40d32bdad2a3"><strong class="mf jd">Practical DDD in Golang: Entity</strong></a></span><span id="ada2" class="mj mk it mf b gy mp mm l mn mo"><strong class="mf jd">3. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-ddd-in-golang-domain-service-4418a1650274"><strong class="mf jd">Practical DDD in Golang: Domain Service</strong></a></span><span id="7530" class="mj mk it mf b gy mp mm l mn mo"><strong class="mf jd">4. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-ddd-in-golang-domain-event-de02ad492989"><strong class="mf jd">Practical DDD in Golang: Domain Event</strong></a></span><span id="df48" class="mj mk it mf b gy mp mm l mn mo"><strong class="mf jd">5. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-ddd-in-golang-module-51edf4c319ec"><strong class="mf jd">Practical DDD in Golang: Module</strong></a></span></pre><div class="mq mr gp gr ms mt"><a href="https://blog.ompluscator.com/membership" rel="noopener  ugc nofollow" target="_blank"><div class="mu ab fo"><div class="mv ab mw cl cj mx"><h2 class="bd jd gy z fp my fr fs mz fu fw jc bi translated">通过我的推荐链接加入媒体——马尔科·米洛耶维奇</h2><div class="na l"><h3 class="bd b gy z fp my fr fs mz fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="nb l"><p class="bd b dl z fp my fr fs mz fu fw dk translated">blog.ompluscator.com</p></div></div><div class="nc l"><div class="nd l ne nf ng nc nh lb mt"/></div></div></a></div><h1 id="a02b" class="ni mk it bd nj nk nl nm nn no np nq nr ki ns kj nt kl nu km nv ko nw kp nx ny bi translated">商业不变量</h1><p id="679b" class="pw-post-body-paragraph li lj it lk b ll nz kd ln lo oa kg lq lr ob lt lu lv oc lx ly lz od mb mc md im bi translated">在真实的商业世界中，有些规则是灵活的。例如，如果你从银行贷款，你需要支付一些利息。利息总额是可以调整的，这取决于你的投资资本和偿还债务的期限。</p><p id="f834" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在某些情况下，银行可能会给你一个宽限期。或者因为你过去的忠诚而给你一个更好的整体报价。或者给你一生一次的机会，或者强迫你抵押一所房子。</p><p id="4465" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">所有这些来自商业世界的灵活规则，在DDD，我们实现了策略模式(我将在下面的文章中讨论这一点)。它们依赖于许多特定的情况，为此，它们要求更复杂的代码结构。</p><blockquote class="oe of og"><p id="a7d4" class="li lj oh lk b ll lm kd ln lo lp kg lq oi ls lt lu oj lw lx ly ok ma mb mc md im bi translated">在现实的商业世界中，有一些不变的规则。无论我们如何努力，我们都无法改变它们，也无法改变它们在我们业务中的应用。每当物体从一个状态转移到另一个状态时，这些规则仍然必须适用。它们被称为业务不变量。</p></blockquote><p id="4f7b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">例如，任何人都不应该被允许删除银行中的客户帐户，如果与该客户相关联的任何银行帐户有钱或有债务。</p><p id="5b77" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在许多银行，一个客户可能有多个相同货币的银行账户。但是，有些银行不允许客户持有外币，也不允许客户在同一个银行开立多个账户。</p><p id="6f6e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当这样的业务规则发生时，它们就成为业务不变量。它们从我们创建对象的那一刻起就存在，直到我们删除它。破坏它们意味着破坏应用程序的整个目的。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ol om l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">业务不变量的例子</figcaption></figure><p id="f9f1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在上面的例子中，我们可以在Go中看到一些代码结构，用<code class="fe on oo op mf b">CustomerAccount</code>作为一个实体和集合。除此之外，还有<code class="fe on oo op mf b">BankAccount</code>和<code class="fe on oo op mf b">Currency</code>作为实体。</p><p id="4854" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">另外，这三个实体都有自己的业务规则。有些是灵活的，有些是不变的。尽管如此，当它们相互作用时，一些不变量会影响所有的元素。这就是我们放置骨料的地方。</p><p id="a5d5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们有一个<code class="fe on oo op mf b">BankAccount</code>创造的逻辑，它依赖于特定<code class="fe on oo op mf b">CustomerAccount</code>的所有<code class="fe on oo op mf b">BankAccounts</code>。在这种情况下，一个<code class="fe on oo op mf b">Customer</code>不能有多个<code class="fe on oo op mf b">BankAccounts</code>具有相同的<code class="fe on oo op mf b">Currency</code>。</p><p id="d42e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">此外，如果连接到<code class="fe on oo op mf b">CustomerAccount</code>的所有<code class="fe on oo op mf b">BankAccounts</code>都不处于干净状态，我们也不能删除<code class="fe on oo op mf b">CustomerAccount</code>。他们不应该假装或拥有任何钱。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oq"><img src="../Images/c1371bcd78d12b657d2c676b9ec33ac3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MVIeWdlstbnG-LvJKgvhZw.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">商业不变量应用领域</figcaption></figure><p id="0fb0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">上图显示了我们已经讨论过的三个实体的集群。它们都与业务不变量联系在一起，确保Aggregate始终处于可靠的状态。</p><p id="34b9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果任何其他实体或值对象属于相同的业务不变量，那么这些新对象将成为相同聚合的一部分。</p><p id="b2ed" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果在同一个集合中，我们没有一个单一的不变量将一个对象与其余的对象绑定在一起，那么这个对象就不属于这个集合。</p><h1 id="fc41" class="ni mk it bd nj nk nl nm nn no np nq nr ki ns kj nt kl nu km nv ko nw kp nx ny bi translated">分界线</h1><p id="d27d" class="pw-post-body-paragraph li lj it lk b ll nz kd ln lo oa kg lq lr ob lt lu lv oc lx ly lz od mb mc md im bi translated">我多次使用DDD，有一个关于如何定义总边界的问题。在游戏中加入每一个新的实体或价值对象，这个问题总是会出现。</p><p id="d2a9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">到目前为止，很清楚，聚合不仅仅是一些对象的集合。这是一个领域概念。其成员定义了一个逻辑集群。如果不对它们进行分组，我们就不能保证它们处于有效状态。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ol om l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">客户总数</figcaption></figure><p id="0bc7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在上面的代码片段中，您可以看到<code class="fe on oo op mf b">Customer</code>聚合。不仅在这里，在许多应用程序中，您都将拥有一个名为<code class="fe on oo op mf b">Customer</code>的实体，而且几乎总是，它也将是一个集合。</p><p id="74be" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这里我们有一些定义特定<code class="fe on oo op mf b">Customer</code>合法性的业务不变量，这取决于我们谈论的是<code class="fe on oo op mf b">Person</code>还是<code class="fe on oo op mf b">Company</code>。应该有更多的业务不变量，但是现在，一个就足够了。</p><p id="7edd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当我们处理一个银行的申请时，困难在于<code class="fe on oo op mf b">CustomerAccount</code>和<code class="fe on oo op mf b">Customer</code>是否属于同一个集合。它们之间是有联系的，一些业务规则把它们绑定在一起，但是它们是不变的吗？</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi or"><img src="../Images/1507cd71b065006dc80aa0b28058da8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v_IfkEKm_sOwXt6BN8Nc0Q.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">领域层中的新实体</figcaption></figure><p id="dd71" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">一个<code class="fe on oo op mf b">Customer</code>可以有多个<code class="fe on oo op mf b">CustomerAccounts</code>(或者没有)。我们可以看到<code class="fe on oo op mf b">Customer</code>周围的对象和<code class="fe on oo op mf b">CustomerAccount</code>周围的对象有一些业务不变量。</p><p id="54a3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">从不变量的确切定义出发，如果我们找不到任何把<code class="fe on oo op mf b">Customer</code>和<code class="fe on oo op mf b">CustomerAccount</code>联系在一起的不变量，那么我们应该把它们分割成集合。我们带入画面的任何其他集群都需要同样对待——它们是否与已经存在的聚集共享一些不变量？</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi os"><img src="../Images/bef46944d6fd92da3d2e211bf136e579.png" data-original-src="https://miro.medium.com/v2/resize:fit:1284/format:webp/1*KvFhU-qyIsQbiqSr3WT0eA.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">多个聚合连接</figcaption></figure><p id="7553" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">使聚合尽可能小始终是一个好的做法。聚合成员一起保存在存储中(就像数据库一样)，在一个事务中添加太多的表并不是一个好的做法。</p><p id="d812" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在这里，我们已经看到，我们应该在聚合级别上定义存储库，并只通过该存储库持久化其所有成员，如下例所示。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ol om l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">整个聚合的存储库示例</figcaption></figure><p id="e988" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们可以将<code class="fe on oo op mf b">Person</code>和<code class="fe on oo op mf b">Company</code>定义为实体(或者值对象)，但是即使它们有自己的标识，我们也要用<code class="fe on oo op mf b">CustomerRepository</code>从<code class="fe on oo op mf b">Customer</code>开始更新。</p><p id="34e8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">直接使用<code class="fe on oo op mf b">Person</code>或<code class="fe on oo op mf b">Company</code>工作，或者在没有<code class="fe on oo op mf b">Customer</code>和其他对象的情况下持久化它们会破坏业务不变量。我们希望确保所有的事务一起被传递，或者是否有必要回滚所有的更改。</p><p id="d301" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">除了持久化之外，聚合的删除必须同时发生。这意味着，通过删除<code class="fe on oo op mf b">Customer</code>实体，我们也必须删除<code class="fe on oo op mf b">Person</code>和<code class="fe on oo op mf b">Company</code>实体。它们没有单独存在的理由。</p><p id="7599" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如你所见，一个集合不能太小也不能太大。它必须用业务不变量精确界定。边界内的一切我们必须一起使用，边界外的一切属于其他集合。</p><h1 id="ce6f" class="ni mk it bd nj nk nl nm nn no np nq nr ki ns kj nt kl nu km nv ko nw kp nx ny bi translated">关系</h1><p id="0f1e" class="pw-post-body-paragraph li lj it lk b ll nz kd ln lo oa kg lq lr ob lt lu lv oc lx ly lz od mb mc md im bi translated">正如您在本文前面看到的，聚合之间存在关系。那些关系应该总是在代码中，但是它们必须尽可能简单。</p><p id="18ed" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了避免复杂的连接，我们应该首先避免引用集合，而是对关系使用标识——下面的代码片段就是一个例子。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ol om l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">使用标识避免引用。</figcaption></figure><p id="4a32" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">另一个问题可能是关系的方向。最好的情况是当它们之间有一个单向连接时，我们避免任何双向连接。</p><p id="fcca" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这不是一个容易决定的过程，它取决于我们在有限环境中的用例。如果我们为ATM编写软件，其中用户通过使用借记卡与<code class="fe on oo op mf b">CustomerAccount</code>交互，那么我们有时会通过在<code class="fe on oo op mf b">CustomerAccount</code>中拥有其身份来访问<code class="fe on oo op mf b">Customer</code>。</p><p id="3048" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在另一种情况下，我们的有界上下文可能是一个从一个<code class="fe on oo op mf b">Customer</code>管理所有<code class="fe on oo op mf b">CustomerAccounts</code>的应用程序。用户可以对所有<code class="fe on oo op mf b">BankAccounts</code>进行授权和操作。在这种情况下，<code class="fe on oo op mf b">Customer</code>应该包含一个与<code class="fe on oo op mf b">CustomerAccounts</code>相关联的身份列表。</p><h1 id="910e" class="ni mk it bd nj nk nl nm nn no np nq nr ki ns kj nt kl nu km nv ko nw kp nx ny bi translated">聚集根</h1><p id="16df" class="pw-post-body-paragraph li lj it lk b ll nz kd ln lo oa kg lq lr ob lt lu lv oc lx ly lz od mb mc md im bi translated">本文中的所有聚合都与一些实体同名，比如<code class="fe on oo op mf b">Customer</code>实体和聚合。这些唯一的实体是聚合根和聚合内部的主要对象。</p><p id="9e9c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">聚合根是访问所有其他实体、值对象和集合的网关。我们不应该直接更改聚合的成员，而应该通过聚合根来更改。</p><p id="f8d8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">聚合根公开了表示其丰富行为的方法。它应该定义访问内部属性或对象的方法，以及操作这些数据的方法。即使聚合根返回一个对象，它也应该只返回它的一个副本。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ol om l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">丰富行为的示例</figcaption></figure><p id="e4a9" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">由于Aggregate包含多个实体和值对象，因此其中会出现许多不同的标识。在这些情况下，有两种类型的身份。</p><p id="4bd3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">聚合根具有全局标识。该标识在全球范围内是唯一的，在应用程序中没有任何地方可以找到具有相同标识的实体。我们可以从聚合的外部引用聚合根的身份。</p><p id="2a2a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">聚合中的所有其他实体都有本地标识。此类身份仅在聚合内部是唯一的，但在聚合外部可能会重复。只有Aggregate保存关于本地身份的信息，我们不应该在Aggregate之外引用它们。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="ol om l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">全球和本地身份</figcaption></figure><h1 id="61f5" class="ni mk it bd nj nk nl nm nn no np nq nr ki ns kj nt kl nu km nv ko nw kp nx ny bi translated">结论</h1><p id="7f7d" class="pw-post-body-paragraph li lj it lk b ll nz kd ln lo oa kg lq lr ob lt lu lv oc lx ly lz od mb mc md im bi translated">聚合是由业务不变量定义的领域概念。业务不变量定义了在应用程序的任何状态下都必须有效的规则。它们代表一个集合体的边界。</p><p id="7506" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">聚合必须一起保存和删除。聚合根是聚合的其他成员的网关。只能通过聚合根来访问它们。</p><pre class="ks kt ku kv gt me mf mg mh aw mi bi"><span id="a58e" class="mj mk it mf b gy ml mm l mn mo">Other articles from DDD series:</span><span id="b863" class="mj mk it mf b gy mp mm l mn mo"><strong class="mf jd">1. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-ddd-in-golang-value-object-4fc97bcad70"><strong class="mf jd">Practical DDD in Golang: Value Object</strong></a></span><span id="6cf1" class="mj mk it mf b gy mp mm l mn mo"><strong class="mf jd">2. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-ddd-in-golang-entity-40d32bdad2a3"><strong class="mf jd">Practical DDD in Golang: Entity</strong></a></span><span id="6144" class="mj mk it mf b gy mp mm l mn mo"><strong class="mf jd">3. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-ddd-in-golang-domain-service-4418a1650274"><strong class="mf jd">Practical DDD in Golang: Domain Service</strong></a></span><span id="aa18" class="mj mk it mf b gy mp mm l mn mo"><strong class="mf jd">4. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-ddd-in-golang-domain-event-de02ad492989"><strong class="mf jd">Practical DDD in Golang: Domain Event</strong></a></span><span id="79da" class="mj mk it mf b gy mp mm l mn mo"><strong class="mf jd">5. </strong><a class="ae lh" rel="noopener ugc nofollow" target="_blank" href="/practical-ddd-in-golang-module-51edf4c319ec"><strong class="mf jd">Practical DDD in Golang: Module</strong></a></span></pre><h1 id="2087" class="ni mk it bd nj nk nl nm nn no np nq nr ki ns kj nt kl nu km nv ko nw kp nx ny bi translated">有用的资源:</h1><ul class=""><li id="6b85" class="ot ou it lk b ll nz lo oa lr ov lv ow lz ox md oy oz pa pb bi translated"><a class="ae lh" href="https://martinfowler.com/" rel="noopener ugc nofollow" target="_blank">https://martinfowler.com/</a></li><li id="18a3" class="ot ou it lk b ll pc lo pd lr pe lv pf lz pg md oy oz pa pb bi translated"><a class="ae lh" href="https://www.domainlanguage.com/" rel="noopener ugc nofollow" target="_blank">https://www.domainlanguage.com/</a></li></ul></div></div>    
</body>
</html>