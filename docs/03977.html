<html>
<head>
<title>TypeScript Best Practices — Namespaces, Exceptions, and Type Definitions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript最佳实践—命名空间、异常和类型定义</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/typescript-best-practices-namespaces-exceptions-and-type-definitions-131d85579fa3?source=collection_archive---------7-----------------------#2020-06-04">https://levelup.gitconnected.com/typescript-best-practices-namespaces-exceptions-and-type-definitions-131d85579fa3?source=collection_archive---------7-----------------------#2020-06-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/ae60ecc48d2506332f848f95bfbed4a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Nm8GPT-Rvc3hcwsd"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">加布里埃尔·亨德森在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="ca6a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">TypeScript是一个简单易学的JavaScript扩展。编写运行并执行某些操作的程序很容易。然而，很难考虑所有的用例并编写健壮的类型脚本代码。</p><p id="810d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将研究使用TypeScript编写代码时要遵循的最佳实践，包括禁止使用TypeScript模块和命名空间。</p><p id="8eba" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，在可选的链接表达式之后，我们不需要非空断言。如果我们创建和使用模块，我们应该使用JavaScript模块。我们应该抛出异常，而不是抛出文字。</p><p id="23c1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">而且，我们可能想用一种方式而不是两种方式来声明类型。</p><h1 id="041c" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">不要使用自定义TypeScript模块和命名空间</h1><p id="29fa" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">因为我们有ES6模块作为JavaScript的标准，所以我们不需要定制的TypeScript模块和名称空间来组织我们的代码。</p><p id="9349" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">相反，我们应该使用带有<code class="fe mh mi mj mk b">import</code>和<code class="fe mh mi mj mk b">export</code>的标准JavaScript模块。</p><p id="1fdb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，不写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="96f7" class="mt lf it mk b gy mu mv l mw mx">module foo {}<br/>namespace foo {}</span></pre><p id="a766" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">或者:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="b52e" class="mt lf it mk b gy mu mv l mw mx">declare module foo {}<br/>declare namespace foo {}</span></pre><p id="2484" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们写道:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="f8d5" class="mt lf it mk b gy mu mv l mw mx">export default foo;</span></pre><p id="b85c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这将从一个模块中导出<code class="fe mh mi mj mk b">foo</code>对象。</p><p id="250c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还可以导出模块的单个成员:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="3f1c" class="mt lf it mk b gy mu mv l mw mx">export foo;<br/>export bar;</span></pre><h1 id="f2f5" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">不要在可选链表达式后使用非空断言</h1><p id="041d" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们不应该在可选链表达式后使用非空断言，因为它们与可选链表达式相反。</p><p id="11b8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">根据其性质，表达式可以返回<code class="fe mh mi mj mk b">undefined</code>。</p><p id="ba78" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，不写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="543a" class="mt lf it mk b gy mu mv l mw mx">foo?.bar!;</span></pre><p id="f0f7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">或者:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="b27b" class="mt lf it mk b gy mu mv l mw mx">foo?.bar()!;</span></pre><p id="b95a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们写道:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="1f46" class="mt lf it mk b gy mu mv l mw mx">foo?.bar;</span></pre><p id="d242" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">或者:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="6b68" class="mt lf it mk b gy mu mv l mw mx">foo?.bar();</span></pre><h1 id="ab77" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">不要使用非空断言！后缀运算符</h1><p id="2a0f" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">非空断言取消了严格的空检查模式的好处。</p><p id="1d8b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我们可能要删除额外的<code class="fe mh mi mj mk b">!</code>操作符。</p><p id="da3b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，不写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="893a" class="mt lf it mk b gy mu mv l mw mx">interface Foo {<br/>  bar?: string;<br/>}</span><span id="5a28" class="mt lf it mk b gy my mv l mw mx">const includesBaz: boolean = foo.bar!.includes('qux');</span></pre><p id="e9d7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">相反，我们应该写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="8e86" class="mt lf it mk b gy mu mv l mw mx">interface Foo {<br/>  bar?: string;<br/>}</span><span id="4a3d" class="mt lf it mk b gy my mv l mw mx">const hasQux: boolean = foo.bar &amp;&amp; foo.bar.includes('qux');</span></pre><h1 id="591c" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">不要在类构造函数中使用参数属性</h1><p id="e0cf" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">对于刚接触TypeScript的人来说，参数属性很容易混淆，所以我们可能希望停止使用它。</p><p id="5102" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是一种不太明确的声明和初始化类成员的方式。</p><p id="bee2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，不写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="5348" class="mt lf it mk b gy mu mv l mw mx">class Foo {<br/>  constructor(readonly name: string) {}<br/>}</span></pre><p id="cf37" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们写道:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="5f4c" class="mt lf it mk b gy mu mv l mw mx">class Foo {<br/>  constructor(name: string) {}<br/>}</span></pre><h1 id="8f2b" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">不要使用require()来导入模块</h1><p id="6405" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">既然ES6模块是标准的，我们就不用再用<code class="fe mh mi mj mk b">require</code>来导入CommonJS模块了。</p><p id="f3e3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，与其写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="389f" class="mt lf it mk b gy mu mv l mw mx">const lib = require('lib');</span></pre><p id="8dd0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们写道:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="5f8a" class="mt lf it mk b gy mu mv l mw mx">import { foo } from 'lib';</span></pre><h1 id="8658" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">不要给这个取别名</h1><p id="c455" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">现在我们有了箭头函数，我们不需要将<code class="fe mh mi mj mk b">this</code>设置为另一个变量来保持它的值。</p><p id="1693" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，不写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="6cc4" class="mt lf it mk b gy mu mv l mw mx">const self = this;<br/><br/>setTimeout(function() {<br/>  self.foo();<br/>});</span></pre><p id="86c4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们应该写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="3b16" class="mt lf it mk b gy mu mv l mw mx">setTimeout(() =&gt; {<br/>  this.foo();<br/>});</span></pre><h1 id="95d0" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">不要将文字作为异常抛出</h1><p id="8d00" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们应该用<code class="fe mh mi mj mk b">throw</code>而不是文字来抛出<code class="fe mh mi mj mk b">Error</code>对象，因为它给了我们更多的信息，比如发生异常的行、堆栈跟踪和错误类型。</p><p id="4d5b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，不写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="9b89" class="mt lf it mk b gy mu mv l mw mx">throw 'error';</span></pre><p id="7302" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们写道:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="5513" class="mt lf it mk b gy mu mv l mw mx">const err = new Error();<br/>throw err;</span></pre><p id="759e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">或者:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="4129" class="mt lf it mk b gy mu mv l mw mx">class BadError extends Error {<br/>  // ...<br/>};<br/>throw new BadError();</span></pre><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/103d0bed1210c7bdd1fb1be23fa54a9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*31auGzpn5j0jqklB"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@shootdelicious?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Eiliv-Sonas Aceron </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><h1 id="6aa1" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">不要使用类型别名</h1><p id="bda7" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可能希望禁止使用类型别名。</p><p id="f29c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">类型别名可以作为其他类型的别名，这样我们就可以用更简单的名称来引用它们。</p><p id="10f7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="d6e5" class="mt lf it mk b gy mu mv l mw mx">type Person = {<br/>    firstName: string,<br/>    lastName: string,<br/>    age: number<br/>};</span><span id="c8f0" class="mt lf it mk b gy my mv l mw mx">let person: Person;</span></pre><p id="deef" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">而不是:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="3d4e" class="mt lf it mk b gy mu mv l mw mx">let person: {<br/>    firstName: string,<br/>    lastName: string,<br/>    age: number<br/>};</span></pre><p id="797f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它还可以充当接口，就像前面的例子一样。</p><p id="42c3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">或者它也可以作为一个映射，让我们快速修改。</p><p id="9efe" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="526e" class="mt lf it mk b gy mu mv l mw mx">type ReadOnly&lt;T&gt; = { readonly [P in keyof T]: T[P] };</span><span id="8b07" class="mt lf it mk b gy my mv l mw mx">type Person = {<br/>  firstName: string;<br/>  lastName: string;<br/>  age: number;<br/>};</span></pre><p id="1aab" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于它们表现得像接口的情况，也许我们只是想把它们转换成接口。</p><p id="0c53" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这样，我们得到了一种类型注释，而不是代码中的两种。</p><h1 id="223d" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="b18c" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">如果我们的类型别名像接口一样使用，我们可能希望坚持使用接口来声明类型。</p><p id="e615" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，现在我们有了箭头函数，我们不需要<code class="fe mh mi mj mk b">this</code>的别名。</p><p id="0718" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们引发异常时，我们应该抛出<code class="fe mh mi mj mk b">Error</code>对象，而不是抛出文字。</p></div></div>    
</body>
</html>