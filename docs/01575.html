<html>
<head>
<title>Faster Lists In Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的快速列表</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/faster-lists-in-python-4c4287502f0a?source=collection_archive---------0-----------------------#2020-01-14">https://levelup.gitconnected.com/faster-lists-in-python-4c4287502f0a?source=collection_archive---------0-----------------------#2020-01-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/dc7d7b419edc6c6ee0c1eb53fdc3a2a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/1*4fZa5i8-ptTw0OHXsa_5Kg.jpeg"/></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">来源:Inverse.com</figcaption></figure><p id="6927" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">Python列表是漂亮的动态数据结构。它们是许多事情的首选数据结构，所以意识到每个操作的速度是最重要的。这通常被称为解决方案的大O或时间复杂度。</p><h1 id="e746" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated"><strong class="ak">列表创建</strong></h1><p id="5d84" class="pw-post-body-paragraph kc kd it ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz im bi translated">在python中有许多创建数组的方法，所以让我们看看哪种方法花费的时间最少。下面是我们使用的设置:</p><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="62ca" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated"><strong class="ke iu">列表理解</strong>是创建数组的第一种方法。它们简单易读，这使得它们也很容易写。</p><pre class="md me mf mg gt mj mk ml mm aw mn bi"><span id="d112" class="mo lb it mk b gy mp mq l mr ms">listComp = [i for i in range(0, end)]</span></pre><p id="3789" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated"><strong class="ke iu">追加</strong>是下一个方法。我倾向于使用这个解决方案，因为它是更容易使用的解决方案之一。这类似于在大多数其他语言中添加列表的方式。</p><pre class="md me mf mg gt mj mk ml mm aw mn bi"><span id="d53d" class="mo lb it mk b gy mp mq l mr ms">append_list = []<br/>for i in range(0,end):<br/>  append_list.append(i)</span></pre><p id="89be" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated"><strong class="ke iu">预分配</strong>是我们将测试的最终方法。这只适用于具有预定长度的数组。这涉及到预先创建所有的数组对象，然后通过索引修改它们的值。</p><pre class="md me mf mg gt mj mk ml mm aw mn bi"><span id="2043" class="mo lb it mk b gy mp mq l mr ms">preAllocate = [0] * end<br/>for i in range(0, end):<br/>  preAllocate[i] = i</span></pre><p id="d4d2" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated"><strong class="ke iu">结果:</strong>虽然列表理解在这里并不总是最有意义，但它们显然是赢家。我不建议你尝试把每个for循环都塞进一个理解中。当您使用简单的for循环或创建特别大的数组时，它才有意义。</p><pre class="md me mf mg gt mj mk ml mm aw mn bi"><span id="011c" class="mo lb it mk b gy mp mq l mr ms"><strong class="mk iu">Method:            Median Time:</strong><br/>listComprehension  0.5556 ms<br/>preAllocate        1.1466 ms<br/>append             1.3842 ms</span></pre><h1 id="cee5" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">比较列表</h1><p id="c331" class="pw-post-body-paragraph kc kd it ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz im bi translated">对此的测试与上面的类似。我们用0到50，000之间的50，000个随机数创建了两个列表。然后我们比较这两个列表，看看是否</p><p id="eb61" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated"><strong class="ke iu"> Double For循环:</strong>这应该有O(n)的时间复杂度。对于每个元素，我们必须遍历第二个列表的一部分或全部。</p><pre class="md me mf mg gt mj mk ml mm aw mn bi"><span id="5cd0" class="mo lb it mk b gy mp mq l mr ms">for i in list_a:<br/>  for j in list_b:<br/>    if i == j:<br/>      break</span></pre><p id="0fa3" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated"><strong class="ke iu">在搜索:</strong>‘在’的时间复杂度比较混乱。知道double for循环在O(n)时间内执行，那么“in”访问以类似的方式操作是有意义的。好像没有。它似乎在更接近O(n log n)的时间内运行。如果有人碰巧熟悉CPython中的“in”实现，请在下面留下评论，我会在这里给出答案。</p><pre class="md me mf mg gt mj mk ml mm aw mn bi"><span id="8688" class="mo lb it mk b gy mp mq l mr ms">for i in list_a:<br/>  if i in list_b:<br/>    continue</span></pre><p id="5c30" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated"><strong class="ke iu">集合搜索</strong>时间复杂度略有不同。Python中set的实现本质上是一个散列表，因此它的访问速度为O(1)。因此，因为我们遍历列表一次，并且检查第二个列表是O(1)操作，所以集合搜索应该在O(n)时间内操作。</p><pre class="md me mf mg gt mj mk ml mm aw mn bi"><span id="a96c" class="mo lb it mk b gy mp mq l mr ms">unique = set(list_b)<br/>for i in list_a:<br/>  if i in unique:<br/>    continue</span></pre><p id="ba84" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated"><strong class="ke iu">结果:</strong>与器械包的比较非常好。对于任何想知道的人来说，double for循环是一个我从来没有想到会做得很好的循环。让我感到惊讶的是使用' in '操作符比使用double for少花了多少时间。</p><pre class="md me mf mg gt mj mk ml mm aw mn bi"><span id="168d" class="mo lb it mk b gy mp mq l mr ms"><strong class="mk iu">Method:       Median Time:   Big O: <br/></strong>Set Syntax:   0.0046ms       O(n)<br/>In Syntax:    3.4710ms       O(n log n)<br/>Double For:   42.3418ms      O(n^2)</span></pre><h1 id="c7d6" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated"><strong class="ak">排序列表</strong></h1><p id="5f5e" class="pw-post-body-paragraph kc kd it ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz im bi translated">在最后一节中，我们将讨论python中的列表排序。有很多常见的排序算法我们会比较。要查看更完整的排序算法列表，请查看<a class="ae kb" href="https://stackabuse.com/sorting-algorithms-in-python/" rel="noopener ugc nofollow" target="_blank"> StackAbuse </a>了解更多信息。</p><p id="6d48" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">当谈到排序时，我们需要记住有稳定和不稳定的排序算法。如果算法保持相等项的原始顺序，那么它就是稳定的。下面是一个说明稳定性为何如此重要的例子:</p><h2 id="23bf" class="mo lb it bd lc mt mu dn lg mv mw dp lk kn mx my lo kr mz na ls kv nb nc lw nd bi translated"><strong class="ak">稳定例子</strong></h2><p id="28ce" class="pw-post-body-paragraph kc kd it ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz im bi translated">假设我们的代码中有一个bug，我们想看看哪里出错了。我们可能会查看日志文件，并按用户对请求进行排序。以下是我们的示例日志文件:</p><pre class="md me mf mg gt mj mk ml mm aw mn bi"><span id="3808" class="mo lb it mk b gy mp mq l mr ms">user10: { 'request_number': 2 }<br/>user11: { 'request_number': 1 }<br/>user10: { 'request_number': 1 }</span></pre><p id="3775" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">在不稳定排序中，我们可能会得到类似这样的结果，其中请求是由用户排序的，但是因为它不稳定，我们丢失了事件的原始序列。我们可能永远也不会发现我们的bug，因为我们无法看到user10让请求2在请求1之前到达服务器。</p><pre class="md me mf mg gt mj mk ml mm aw mn bi"><span id="fdd4" class="mo lb it mk b gy mp mq l mr ms"># Unstable Sort Result<br/>user10: { 'request_number': 1 }<br/>user10: { 'request_number': 2 }<br/>user11: { 'request_number': 1 }</span><span id="e20f" class="mo lb it mk b gy ne mq l mr ms"># Stable Sort Result<br/>user10: { 'request_number': 2 }<br/>user10: { 'request_number': 1 }<br/>user11: { 'request_number': 1 }</span></pre><p id="4939" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated"><strong class="ke iu">堆排序</strong>的典型时间复杂度为O(n log n)。然而，这不是一种稳定的排序算法，因此无法保证项目将处于其原始顺序。该算法的工作原理是将项目放置在一棵二叉树上，该二叉树的根节点是最大值。然后，它将解构该树以形成排序后的数组。</p><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="1104" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated"><strong class="ke iu"> Mergesort </strong>是一个分治算法，典型的时间复杂度为O(n log n)。该算法将列表分成两半，这两半各占一半，直到剩下单独的元素。然后这些元素被配对、排序并重复合并，直到列表再次完整。这种算法是稳定的，所以它是伟大的地方是必要的。</p><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="3776" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated"><strong class="ke iu">快速排序</strong>是一种非常常用的算法，因为它易于实现，平均时间复杂度为O(n log n)。这样做的问题是，一切都是基于选择一个已经在适当位置的好支点，并围绕它进行排序。选择一个差的支点可能导致O(n)时间复杂度。这与它不稳定的事实联系在一起，导致我不推荐它。</p><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="48a9" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated"><strong class="ke iu"> Timsort </strong>是一种你可能从未听说过的排序。这种排序以其发明者Tim Peters的名字命名，是二分搜索法、插入排序和合并排序的组合。它的平均时间复杂度是O(n log n ),但是它能够以更好的一致性达到这一点，并且具有O(n)的最佳情况复杂度。此外，这是一个稳定的算法，这使得它可以在任何地方使用。</p><p id="9a60" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">最好的部分是在python中使用Timsort只需要一行代码。没错。它是内置的排序函数。</p><pre class="md me mf mg gt mj mk ml mm aw mn bi"><span id="a91a" class="mo lb it mk b gy mp mq l mr ms">array.sort()</span></pre><p id="0e83" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated"><strong class="ke iu">结果:</strong> Timsort优于所有其他算法，这就是为什么它是python的核心排序算法。下一个合并排序和快速排序并驾齐驱。最后，Heapsort排在最后…至少是这个列表的最后。还有很多更差的排序算法，比如随机排序。</p><pre class="md me mf mg gt mj mk ml mm aw mn bi"><span id="37b3" class="mo lb it mk b gy mp mq l mr ms"><strong class="mk iu">Algorithm:</strong>   <strong class="mk iu">Time:</strong>          <br/>timsort      0.001594 ms<br/>mergesort    0.033845 ms<br/>quicksort    0.097097 ms<br/>heapsort     0.365555 ms</span></pre><p id="b028" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">这里有一个图表显示了所有这些排序算法的主要部分。此外，我们还有空间复杂度，即完成算法需要多少额外的空间。</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/6db51752f4179175c3f9630858cf3d3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1194/format:webp/1*duNXSiw0F3owZqDeyd7VmQ.png"/></div></figure><p id="103a" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">这就是这个列表的全部内容。现在向前迈进，在你的日常Python中使用这些，并跟随获得更多的提示和技巧。</p></div></div>    
</body>
</html>