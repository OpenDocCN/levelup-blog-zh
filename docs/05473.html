<html>
<head>
<title>Inheritance Mapping with JPA/Hibernate</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JPA/Hibernate的继承映射</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/inheritance-mapping-with-jpa-hibernate-338f0c0b8450?source=collection_archive---------9-----------------------#2020-09-01">https://levelup.gitconnected.com/inheritance-mapping-with-jpa-hibernate-338f0c0b8450?source=collection_archive---------9-----------------------#2020-09-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="8913" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当使用JPA生成数据库时，我们必须做的最重要的事情之一就是映射继承。在这篇文章中，你将会学到一些我们在映射继承时必须知道的基本知识。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ko"><img src="../Images/a91924b2a97e81f190997ca759d3ebe1.png" data-original-src="https://miro.medium.com/v2/resize:fit:652/format:webp/1*Gz5UI_q4J39SHqjkdsz3CQ.jpeg"/></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">遗产</figcaption></figure><p id="7936" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于<a class="ae la" href="https://github.com/sef-global/scholarx" rel="noopener ugc nofollow" target="_blank"> ScholarX </a>项目，我必须向spring-boot项目添加JPA注释，以便生成MySQL数据库。已经为实体创建了模型。为了启动这个任务，我得到了一个类图。否则，可能很难找到数据类型、关系等。如果你想知道什么是类图，点击这里。</p></div><div class="ab cl lb lc hx ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="im in io ip iq"><p id="c35c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">好吧，那么…回到主题。JPA有几个继承策略。</p><ul class=""><li id="f973" class="li lj it js b jt ju jx jy kb lk kf ll kj lm kn ln lo lp lq bi translated"><em class="lr">mapped超类</em></li><li id="30ec" class="li lj it js b jt ls jx lt kb lu kf lv kj lw kn ln lo lp lq bi translated">单一表格</li><li id="d135" class="li lj it js b jt ls jx lt kb lu kf lv kj lw kn ln lo lp lq bi translated">连接表</li><li id="91e4" class="li lj it js b jt ls jx lt kb lu kf lv kj lw kn ln lo lp lq bi translated">每类表格</li></ul><p id="a635" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你已经检查了我们的<a class="ae la" href="https://drive.google.com/file/d/13BsmmxXJBgv3Ul5khC2Isac3Z7IxdfOU/view" rel="noopener ugc nofollow" target="_blank">类图</a>，你可能会注意到我们为所有实体都提供了一个名为“BaseScholarxModel”的基础模型。还有另一个名为“EnrolledUser”的父模型，由基本模型扩展而来。这两种型号我们不需要桌子。因此，我不得不利用上述不同的策略。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi lx"><img src="../Images/5c3da8d2bd61019f01bd752d44a1febb.png" data-original-src="https://miro.medium.com/v2/resize:fit:554/format:webp/1*5vXCndz93Zt94JhaA600ew.png"/></div><figcaption class="kw kx gj gh gi ky kz bd b be z dk translated">类图的一部分</figcaption></figure><h1 id="d69e" class="ly lz it bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">mapped超类</h1><p id="5ec6" class="pw-post-body-paragraph jq jr it js b jt mw jv jw jx mx jz ka kb my kd ke kf mz kh ki kj na kl km kn im bi translated">这是最简单的继承策略之一。我们只需要在类上面添加<code class="fe nb nc nd ne b">@MappedSuperclass</code>注释。但是请记住，我们在这里没有使用<code class="fe nb nc nd ne b">@Entity</code>注释，因为我们不需要为基础模型创建一个单独的表。然而，我们只能有一个<code class="fe nb nc nd ne b">@MappedSuperclass</code>。在我的例子中，您可以看到有两个父类，它们在层次结构中不应该有表。但是我们可以对最顶层的父节点使用这个注释。</p><p id="8041" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">mapped超类继承</p><p id="0638" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">(在我们的另一个项目“AcadeMiX”中，我们只有一个基本模型。因此，我们只能使用MappedSuperclass策略)</p><h1 id="bd21" class="ly lz it bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">每类表格</h1><p id="d09c" class="pw-post-body-paragraph jq jr it js b jt mw jv jw jx mx jz ka kb my kd ke kf mz kh ki kj na kl km kn im bi translated">这和之前的策略很像。但是这个策略也为父类定义了实体。但是，它不会为父类生成表。它为父模型扩展的每个模型创建单独的表。要使用它，我们只需将<code class="fe nb nc nd ne b">@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)</code>放在类的上方来定义继承类型。</p><p id="2a2e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于我的情况来说，这是完美的解决方案。</p><p id="5148" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">每类表继承策略</p><p id="c1b7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">到目前为止，我们已经讨论了两种继承策略。还有两个。我会简单解释一下。</p><h1 id="7192" class="ly lz it bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">单一表格</h1><p id="ff0c" class="pw-post-body-paragraph jq jr it js b jt mw jv jw jx mx jz ka kb my kd ke kf mz kh ki kj na kl km kn im bi translated">这是默认的继承策略。所以如果你希望使用它，你必须在类的上面加上<code class="fe nb nc nd ne b">@Inheritance</code>注释。或者可以将策略定义为SINGLE_TABLE。这将为每个类层次结构创建一个表。为了区分对象，生成了一个鉴别器值列。也可以定制。在我看来，这个策略让事情变得复杂了。</p><pre class="kp kq kr ks gt nf ne ng nh aw ni bi"><span id="ae27" class="nj lz it ne b gy nk nl l nm nn"><a class="ae la" href="http://twitter.com/Entity" rel="noopener ugc nofollow" target="_blank">@Entity</a><br/><a class="ae la" href="http://twitter.com/Inheritance" rel="noopener ugc nofollow" target="_blank">@Inheritance</a>(strategy = InheritanceType.SINGLE_TABLE)<br/>public class Parent {</span><span id="4886" class="nj lz it ne b gy no nl l nm nn">private long id;<br/> <br/> // getters and setters <br/>}</span></pre><h1 id="00d2" class="ly lz it bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">连接表</h1><p id="2355" class="pw-post-body-paragraph jq jr it js b jt mw jv jw jx mx jz ka kb my kd ke kf mz kh ki kj na kl km kn im bi translated">在这个策略中，为父对象创建一个表。子表是用父表的外键创建的。所以如果我们想得到一个实体，我们必须连接表。您可以如下所示定义这种继承。</p><p id="7a54" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">父类:</p><pre class="kp kq kr ks gt nf ne ng nh aw ni bi"><span id="728d" class="nj lz it ne b gy nk nl l nm nn"><a class="ae la" href="http://twitter.com/Entity" rel="noopener ugc nofollow" target="_blank">@Entity</a><br/><a class="ae la" href="http://twitter.com/Inheritance" rel="noopener ugc nofollow" target="_blank">@Inheritance</a>(strategy = InheritanceType.JOINED)<br/>public class Vehicle{<br/>    private long id;</span><span id="f672" class="nj lz it ne b gy no nl l nm nn">// getters and setters <br/>}</span></pre><p id="ed88" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">子类别:</p><pre class="kp kq kr ks gt nf ne ng nh aw ni bi"><span id="a4cd" class="nj lz it ne b gy nk nl l nm nn"><a class="ae la" href="http://twitter.com/Entity" rel="noopener ugc nofollow" target="_blank">@Entity</a><br/><a class="ae la" href="http://twitter.com/PrimaryKeyJoinColumn" rel="noopener ugc nofollow" target="_blank">@PrimaryKeyJoinColumn</a>(name = “busId”)<br/>public class Bus extends Vehicle{<br/>    // code<br/>}</span></pre></div><div class="ab cl lb lc hx ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="im in io ip iq"><p id="685d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以我简要描述了JPA(Hibernate)继承策略。通过<a class="ae la" href="https://github.com/sef-global/scholarx/pull/16" rel="noopener ugc nofollow" target="_blank">点击此处</a>查看我对此任务的请求。促成<a class="ae la" href="https://github.com/sef-global" rel="noopener ugc nofollow" target="_blank"> SEF </a>。如果你是编程新手，我们在GitHub repos中有很多好的第一期(特别是在<a class="ae la" href="https://github.com/sef-global/sef-site/issues" rel="noopener ugc nofollow" target="_blank"> sef-site </a>)。如果你想解决某个问题，就在这里发表评论吧。</p><p id="39c6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">还有…今天就到此为止。希望你学到了新的东西。或者你已经找到了解决你一直在努力的问题的方法。感谢阅读！！再见！</p></div></div>    
</body>
</html>