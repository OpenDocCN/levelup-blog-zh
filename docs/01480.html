<html>
<head>
<title>The Ultimate Guide to Blazing-Fast Performance in Rails</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Rails超高速性能的终极指南</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/ultimate-guide-to-blazing-fast-performance-in-rails-1-77e281a1df52?source=collection_archive---------3-----------------------#2020-01-06">https://levelup.gitconnected.com/ultimate-guide-to-blazing-fast-performance-in-rails-1-77e281a1df52?source=collection_archive---------3-----------------------#2020-01-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1b48" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何让Rails扩展到每分钟数百万个请求？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e1c889139515f457f6676f618cbfe7a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*o4gbs9lWrkbfRWD8"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">马里奥·卡尔沃在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="f64b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当你希望你的项目或创业有高的开发速度时，Ruby on Rails是一个巨大的框架。它开箱即用，并附带了大量的幕后魔术，使您的生活更加轻松。然而，就性能而言，它并不被认为是最快的框架。您会发现个人和公司偏离Rails而转向其他事物的例子。尽管如此，仍有许多公司成功地扩展了Rails，并取得了成功——看看Airbnb、Github、Gitlab和Shopify就知道了。</p><p id="9679" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以在您跳槽之前，您应该考虑在使用Rails时将性能放在第一位，您也可以成功。本文旨在列出我多年来学到的最重要的技巧和诀窍，让Rails以极快的速度运行，并扩展到每分钟数百万个请求。</p><h2 id="2bdd" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">目录</h2><ol class=""><li id="3bf1" class="mo mp it lb b lc mq lf mr li ms lm mt lq mu lu mv mw mx my bi translated"><a class="ae ky" href="#ab52" rel="noopener ugc nofollow">通用提示</a></li><li id="fc5e" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated"><a class="ae ky" href="#fbdb" rel="noopener ugc nofollow">活动记录(数据库)</a></li><li id="f86e" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated"><a class="ae ky" href="#4b25" rel="noopener ugc nofollow">服务器&amp;硬件</a></li><li id="5e42" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated"><a class="ae ky" href="#a05e" rel="noopener ugc nofollow">顶上的樱桃(杂项)</a></li><li id="d00f" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu mv mw mx my bi translated"><a class="ae ky" href="#19aa" rel="noopener ugc nofollow">高级</a></li></ol></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h1 id="ab52" class="nl lw it bd lx nm nn no ma np nq nr md jz ns ka mg kc nt kd mj kf nu kg mm nv bi translated">一般提示</h1><p id="0eba" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">首先，有一些在Rails项目中实现的通用技巧，可以帮助你走向成功。</p><h2 id="2448" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">建立一个APM</h2><p id="6663" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">如果您不首先度量它，您就不能提高性能，这使得有必要跟踪和监控正确的度量。您应该跟踪加载时间、请求时间和数据库查询时间等。就我个人而言，我发现<a class="ae ky" href="https://newrelic.com/" rel="noopener ugc nofollow" target="_blank"> New Relic </a>是Rails最好的APM工具之一，但是价格有点贵。一个更实惠的选择是SkyLight的免费试用。</p><h2 id="9732" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">保持最新</h2><p id="efe6" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">我个人知道为你的项目更新Rails版本是多么可怕，如果你让它过时太久，我同情那些经历这种折磨的人。所以帮你自己一个忙，试着与Ruby和Rails的新版本保持同步。这将有助于您避免跨越多个版本的痛苦，并确保您拥有所有更新的性能增强。</p><h2 id="f2ef" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">帕累托原则(80/20法则)</h2><p id="1dcd" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">这是一个众所周知的软件开发规则——帕累托原则。它也被称为“重要的少数法则”，指出对于大多数事件，80%的结果是由20%的原因产生的。这背后的想法是，当您有更大的问题需要解决时，不要在微优化上浪费时间。如果您的数据库查询非常慢，那么通过在序列化中减少毫秒数，您不会有太大的成就。所以小心选择你的战斗。</p><h2 id="c7df" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">保持精简</h2><p id="a55e" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">Rails背后有一个令人惊叹的社区和一个宝石库支持，可以轻松帮助您完成复杂的任务。但是很容易忘乎所以地将宝石添加到项目中，导致膨胀。在选择添加到项目中的gem时要小心，并尽量保持依赖关系的精简。</p><h2 id="1b6d" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">偷懒——在后台工作中做</h2><p id="c20b" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">每当你需要做一些复杂或长时间运行的事情时，考虑把它扔给后台工作人员——发送电子邮件、推送通知、上传图片等等。最小化主线程中的工作将确保对用户的快速响应。对我们来说，好消息是Rails有多种选择来轻松实现这一点——<a class="ae ky" href="https://github.com/mperham/sidekiq" rel="noopener ugc nofollow" target="_blank">Sidekiq</a>、<a class="ae ky" href="https://github.com/resque/resque" rel="noopener ugc nofollow" target="_blank"> Rescue </a>或<a class="ae ky" href="https://guides.rubyonrails.org/v4.2/active_job_basics.html" rel="noopener ugc nofollow" target="_blank"> ActiveJob </a>。</p><h2 id="658b" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated"><strong class="ak">改变你的串行器</strong></h2><p id="cb64" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">如果您的项目中有一个API，您最有可能使用ActiveModelSerializers gem来序列化您的数据。我强烈建议切换到网飞的fast_jsonapi。这个gem比默认的ActiveModelSerializers快得多，我个人可以凭经验证明这一点。</p><h2 id="6422" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">把我藏在外面</h2><p id="e7b8" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">有时，如果您有大量静态数据，或者您不能让事情变得更快，另一种替代方法是使用缓存。Rails使得开箱即用变得非常容易。下面是一个使用到期时间进行缓存的简单示例:</p><pre class="kj kk kl km gt od oc oe of aw og bi"><span id="c557" class="lv lw it oc b gy oh oi l oj ok"># Lets say you have some categories you offer in your project.</span><span id="cddb" class="lv lw it oc b gy ol oi l oj ok">Rails.cache.fetch("categories", expires_in: 5.minutes) do <br/>   Categories.all.map(&amp;:name)<br/>end</span></pre></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h1 id="fbdb" class="nl lw it bd lx nm nn no ma np nq nr md jz ns ka mg kc nt kd mj kf nu kg mm nv bi translated">活动记录(数据库)</h1><p id="827e" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">ActiveRecord是Rails提供的神奇的ORM(有史以来最好的ORM之一)。很容易陷入易用性而不了解细节，这可能会在未来导致瓶颈。</p><h2 id="ac8e" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated"><strong class="ak">使用你的数据库</strong></h2><p id="186a" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">这是许多开发人员没有注意到或没有实现的事情，因为他们急于用代码做所有的事情，或者可能他们被编写原始SQL吓倒了。但是只要可能或方便，你应该使用你的数据库。在Ruby中处理和排序数据结构会占用大量CPU时间，而你的数据库可以毫不费力地做到这一点。</p><h2 id="3756" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">偷看窗帘后面</h2><p id="9373" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">不要沉迷于动态记录的魔力，而不去担心幕后发生的事情。为了清除性能瓶颈，您需要查看被触发的实际查询并理解它们。在开发环境中，Rails将打印出所有正在运行的查询，这允许您注意到任何不必要的查询。此外，这里有一些技巧可以帮助你更深入地挖掘:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><h2 id="ad23" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">SQL魔法</h2><p id="6754" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">别担心，我不会建议你用原始的SQL查询写所有的东西。但是学习SQL和数据库设计的基础知识将帮助您更好地理解幕后发生的事情，并允许您根据需要优化查询。作为一名软件开发人员，这是一项很有价值的技能，将对你的职业生涯大有帮助。</p><h2 id="e136" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">吝啬</h2><p id="d457" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">提高查询效率的一个方法是只选择您真正需要的内容。指定需要数据库检索哪些列，而不是执行<code class="fe nz oa ob oc b">SELECT *</code>。默认情况下，ActiveRecord选择所有内容，但是您可以利用<code class="fe nz oa ob oc b">select</code>或<code class="fe nz oa ob oc b">pluck</code>来解决这个问题。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure><h2 id="585d" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">N+1个查询</h2><p id="f4ca" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">这是一个经典问题。如果您从数据库加载一个<code class="fe nz oa ob oc b">Blog</code>，然后试图通过遍历记录来查找该博客的所有评论，那么您是在强迫Rails为每个评论运行一个查询。这可以通过预加载注释<code class="fe nz oa ob oc b">Blog.includes(:comments)</code>来消除，并有助于避免N+1查询问题。<strong class="lb iu"> Pro提示:</strong>看看<a class="ae ky" href="https://github.com/flyerhzm/bullet" rel="noopener ugc nofollow" target="_blank"> Bullet </a> gem帮你找到任何N+1的查询问题。</p><h2 id="3763" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">组合查询</h2><p id="6c6a" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">当在一个项目中与多个开发人员的大型团队合作时，有时您会注意到每个接触代码库的人可能会在整个代码路径中添加查询。通常，这些查询可以在代码路径的顶部合并成更少的查询。这确保了没有重复的查询，并允许数据库有策略地完成繁重的工作。</p><h2 id="074a" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">索引，索引，索引</h2><p id="a112" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">这是不应被忽视的数据库最佳实践。如果索引不正确，将会对数据库性能产生负面影响，并导致不必要的表扫描。当构建一个新特性时，要提前考虑项目中将要查询的内容，并尝试添加正确的索引。如果你有一个现有的项目，你总是可以使用<a class="ae ky" href="https://github.com/gregnavis/active_record_doctor" rel="noopener ugc nofollow" target="_blank">活动记录医生</a>或<a class="ae ky" href="https://github.com/plentz/lol_dba" rel="noopener ugc nofollow" target="_blank"> LolDBA </a>来嗅出缺失的索引。</p><h2 id="e591" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">迁移</h2><p id="5b08" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">当您大规模运行时，您的表中有数百万条记录，不幸的是，在Rails中运行迁移的正常方式将会失败。他们会在很长一段时间内出错或锁定表格，使您的网站瘫痪。在过去处理过这个问题之后，有两个工具可以为您解决这个棘手问题:</p><ul class=""><li id="f56d" class="mo mp it lb b lc ld lf lg li oo lm op lq oq lu or mw mx my bi translated"><a class="ae ky" href="https://github.com/github/gh-ost" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu"> Gh-ost </strong> </a> <strong class="lb iu"> : </strong>这是一个MySQL的无触发在线模式迁移解决方案，也是唯一一个适合我大规模使用的工具。</li><li id="d9b5" class="mo mp it lb b lc mz lf na li nb lm nc lq nd lu or mw mx my bi translated"><a class="ae ky" href="https://github.com/soundcloud/lhm" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu">LHM</strong></a><strong class="lb iu">:</strong>这将在您的表仍在线时迁移它们，而不会锁定您的表。</li></ul><h2 id="8b8f" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">极端提示:如果你敢，就使用原始SQL</h2><p id="fdd3" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">如果有一个端点迫切需要性能，您可以考虑将整个功能中的所有活动记录查询合并到顶部的一个大规模SQL查询中，以提取满足用例所需的任何记录。<strong class="lb iu">免责声明:</strong>是的，维护海量的原始SQL查询很难，可读性也比较差。但我确实提到这只是在绝望的情况下。</p></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h1 id="4b25" class="nl lw it bd lx nm nn no ma np nq nr md jz ns ka mg kc nt kd mj kf nu kg mm nv bi translated">服务器和硬件</h1><p id="0a8c" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">在部署Rails项目时，需要记住一些关于底层基础设施和架构的事情。</p><h2 id="b25a" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">选择可扩展的架构</h2><p id="60ae" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">随着云基础设施的发展，构建裸机服务器来扩展应用程序的日子已经一去不复返了。当决定Rails项目的底层架构时，您应该利用可伸缩的基于云的系统。例如，您可以使用AWS Fargate或Kubernetes根据需要自动扩展dockerized Rails应用程序。</p><h2 id="6963" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">布罗特利压缩</h2><p id="5e0f" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">Brotli是另一种基于gzip的压缩算法，有多处改进，压缩比更好。现在大多数web服务器都支持它，添加它是优化压缩速度的一种简单方法。嗯，谁不想免费提高网络性能呢？(参考:<a class="ae ky" href="http://www.instantshift.com/2018/03/02/gzip-vs-brotli-compression/" rel="noopener ugc nofollow" target="_blank"> Brotli vs Gzip </a>)</p><h2 id="d9f6" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">给它更多的果汁</h2><p id="1e92" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">Rails因使用大量内存而臭名昭著，尤其是当您有多个puma workers在运行时。所以不要让你的应用程序口渴，从一开始就给它一些果汁。您可以利用云提供商上的内存优化实例来帮助您取得成功。不要忘记留意服务器上的交换使用情况。</p><h2 id="8ef1" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">调谐</h2><p id="35a9" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">从Rails 5开始，Rails的web服务器已经切换到Puma，默认情况下，它将只运行一个worker。一旦设置好Rails部署，就要确保将工作线程的数量增加到机器上可用的内核或更合理的数量。</p><h2 id="0cb8" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">HTTP/2</h2><p id="da9e" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">如果您正在使用类似Nginx的反向代理，请确保您打开了HTTP/2选项，以获得所有的性能优势。</p></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h1 id="a05e" class="nl lw it bd lx nm nn no ma np nq nr md jz ns ka mg kc nt kd mj kf nu kg mm nv bi translated">顶端的樱桃(杂项)</h1><p id="c96e" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">我们就要到达终点了——这一部分是关于性能的一些额外提示。</p><h2 id="4b4d" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">不要使用动态方法</h2><p id="ec86" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">Rails magic是有代价的。其中一些方法会消耗大量资源，最好不要使用它们。例如，<code class="fe nz oa ob oc b">find_by()</code>和<code class="fe nz oa ob oc b">find_all_by()</code>有点慢，因为它们需要遍历<code class="fe nz oa ob oc b">method_missing</code>并根据数据库中的列列表解析名称。</p><h2 id="9cc4" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">节流</h2><p id="6d61" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">随着您的扩展，您肯定会在各种端点上遇到恶意尝试，这些尝试无法被缓存，并且会导致消耗资源的昂贵操作。为了解决这个问题，我建议添加一个类似<a class="ae ky" href="https://github.com/kickstarter/rack-attack" rel="noopener ugc nofollow" target="_blank"> rack-attack </a>的插件，在登录、重置密码或注册等端点上实现节流。</p><h2 id="4d1d" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">了解你的O(n) vs O(1)</h2><p id="a198" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">随着数据集大小的增加，我们需要注意代码在时间复杂度方面的影响。在需要处理或循环大量数据的情况下，可以考虑使用散列，而不是默认使用数组。</p><h2 id="3039" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">总是使用CDN</h2><p id="ec9e" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">你所有的静态资产都应该由CDN提供，并确保缓存策略是合理的。如果您想要对缓存失效进行粒度控制，可以考虑使用e标签和缓存控制。</p></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h1 id="19aa" class="nl lw it bd lx nm nn no ma np nq nr md jz ns ka mg kc nt kd mj kf nu kg mm nv bi translated">先进的</h1><p id="27c1" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">极端情况下，可以考虑一些高级优化。我认为，如果你已经达到了这一点，可能是时候考虑为你的项目的某些计算密集型部分使用其他语言了，所以我将保持这一部分的简短。</p><h2 id="8297" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">复习C语言</h2><p id="6c58" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">Ruby的主要实现是用C语言编写的，这允许你用C语言重写代码中较慢的部分——例如，如果你正在使用加密算法来生成证书。如果您对深入C代码的想法不感兴趣，您可以利用Rails社区用C编写的第三方gem。</p><h2 id="0410" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">更快的后台作业</h2><p id="a61d" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">随着后台工作量的增加，您可以将后台工作人员切换到性能更好的语言。通过利用Redis或亚马逊SQS这样的队列，工作人员可以脱离到他们自己的微服务中。检查这个Sidekiq兼容的<a class="ae ky" href="https://github.com/jrallison/go-workers" rel="noopener ugc nofollow" target="_blank"> go-workers </a>库或者用<a class="ae ky" href="https://github.com/mperham/sidekiq.cr" rel="noopener ugc nofollow" target="_blank">水晶</a>编写的sidekick版本作为两个选项。</p><h2 id="089d" class="lv lw it bd lx ly lz dn ma mb mc dp md li me mf mg lm mh mi mj lq mk ml mm mn bi translated">尝试更快版本的Ruby</h2><p id="9bde" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">有一些Ruby的实现旨在提高性能。如果你对这些变化感兴趣，快速浏览一下<a class="ae ky" href="https://github.com/oracle/truffleruby" rel="noopener ugc nofollow" target="_blank">松露红宝石</a>或<a class="ae ky" href="https://www.jruby.org/" rel="noopener ugc nofollow" target="_blank"> JRub </a> y</p></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><h1 id="df1d" class="nl lw it bd lx nm nn no ma np nq nr md jz ns ka mg kc nt kd mj kf nu kg mm nv bi translated">底线</h1><p id="9151" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">如果我们看看使用Rails的公司，我们会发现他们能够利用Rails惊人的开发速度将客户放在第一位，并在扩展时设法提高性能。在本文中，我们讨论了提高性能的多种技巧和诀窍。我希望这个指南对你有所帮助。下次见。</p><h1 id="f814" class="nl lw it bd lx nm os no ma np ot nr md jz ou ka mg kc ov kd mj kf ow kg mm nv bi translated">喜欢谈论科技或创业？</h1><p id="ace2" class="pw-post-body-paragraph kz la it lb b lc mq ju le lf mr jx lh li nw lk ll lm nx lo lp lq ny ls lt lu im bi translated">你很幸运，我也是！如果你想聊聊前沿技术、企业家精神或创业的风险，可以在推特(Twitter)或领英(LinkedIn)上找到我。</p></div></div>    
</body>
</html>