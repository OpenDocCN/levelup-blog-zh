<html>
<head>
<title>Don’t be a STUPID programmer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">不要做一个愚蠢的程序员</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/dont-be-a-stupid-programmer-be53ed49f99?source=collection_archive---------3-----------------------#2021-07-12">https://levelup.gitconnected.com/dont-be-a-stupid-programmer-be53ed49f99?source=collection_archive---------3-----------------------#2021-07-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="dcc3" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" href="https://medium.com/tag/thought-programmer" rel="noopener">思维程序员</a></h2><div class=""/><div class=""><h2 id="fa6b" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">我们应该避免的6种代码气味</h2></div><p id="3dc9" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><em class="ln">这些是原则，不是法律！</em></p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi lo"><img src="../Images/35624e4cdbe3cf50a22535f31b2032a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*d0MksJUFSI3mN_Zn"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">照片由<a class="ae me" href="https://unsplash.com/@neonbrand?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> NeONBRAND </a>在<a class="ae me" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="0f2a" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">愚蠢是基于六种代码气味的首字母缩略词，我们在编写程序时应该避免这六种气味。</p><p id="dae4" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">这就是我们的代码愚蠢的地方。</p><ul class=""><li id="b5d6" class="mf mg it kt b ku kv kx ky la mh le mi li mj lm mk ml mm mn bi translated"><strong class="kt jd">英格尔顿模式</strong></li><li id="5ae4" class="mf mg it kt b ku mo kx mp la mq le mr li ms lm mk ml mm mn bi translated"><strong class="kt jd"> T </strong>右侧联轴器</li><li id="4e99" class="mf mg it kt b ku mo kx mp la mq le mr li ms lm mk ml mm mn bi translated">不稳定性</li><li id="b28d" class="mf mg it kt b ku mo kx mp la mq le mr li ms lm mk ml mm mn bi translated">P 剩余优化</li><li id="f02b" class="mf mg it kt b ku mo kx mp la mq le mr li ms lm mk ml mm mn bi translated">I 非描述性命名</li><li id="0517" class="mf mg it kt b ku mo kx mp la mq le mr li ms lm mk ml mm mn bi translated"><strong class="kt jd"> D </strong>复制</li></ul><blockquote class="mt"><p id="3792" class="mu mv it bd mw mx my mz na nb nc lm dk translated">代码味道指的是可能的迹象，表明我们的代码中有些地方不太对劲，我们可能不得不重构它。</p></blockquote><h1 id="7e81" class="nd ne it bd nf ng nh ni nj nk nl nm nn ki no kj np kl nq km nr ko ns kp nt nu bi translated">S代表什么？一个</h1><p id="359d" class="pw-post-body-paragraph kr ks it kt b ku nv kd kw kx nw kg kz la nx lc ld le ny lg lh li nz lk ll lm im bi translated">我相信你知道这个模式，因为它是一个简单而广泛的模式。它通过确保一个类只有一个实例，同时提供对该实例的全局访问点，使您的设计保持简单。</p><pre class="lp lq lr ls gt oa ob oc od aw oe bi"><span id="8fe3" class="of ne it ob b gy og oh l oi oj">import java.io.Serializable;<br/><br/>public class SerializedSingleton implements Serializable{<br/><br/>    private static final long serialVersionUID = -7604766932017737115L;<br/><br/>    private SerializedSingleton(){}<br/>    <br/>    private static class SingletonHelper{<br/>        private static final SerializedSingleton instance = new SerializedSingleton();<br/>    }<br/>    <br/>    public static SerializedSingleton getInstance(){<br/>        return SingletonHelper.instance;<br/>    }<br/>    <br/>}</span><span id="3661" class="of ne it ob b gy ok oh l oi oj">public static void main(String[] args) {</span><span id="387f" class="of ne it ob b gy ok oh l oi oj">...<br/>}</span></pre><h2 id="b6b0" class="of ne it bd nf ol om dn nj on oo dp nn la op oq np le or os nr li ot ou nt iz bi translated">什么使它变坏了？</h2><pre class="lp lq lr ls gt oa ob oc od aw oe bi"><span id="7875" class="of ne it ob b gy og oh l oi oj">Stop using the singleton pattern from now</span></pre><p id="4c19" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">这就是为什么我们不应该使用这种模式</p><ul class=""><li id="c658" class="mf mg it kt b ku kv kx ky la mh le mi li mj lm mk ml mm mn bi translated">我们不确定将来是否会需要任何额外的东西，但是需求总是会改变，而singleton不会。</li><li id="057c" class="mf mg it kt b ku mo kx mp la mq le mr li ms lm mk ml mm mn bi translated">它通常将我们的对象实例暴露给应用程序的全局上下文，使它容易在任何时候被修改并失去控制。</li><li id="e381" class="mf mg it kt b ku mo kx mp la mq le mr li ms lm mk ml mm mn bi translated">进行单元测试可能是地狱，因为每个测试必须完全独立于前一个测试，这是不可能的，所以通过保持状态，应用程序变得难以测试。</li></ul><h2 id="7b37" class="of ne it bd nf ol om dn nj on oo dp nn la op oq np le or os nr li ot ou nt iz bi translated">如何避免？</h2><p id="73a6" class="pw-post-body-paragraph kr ks it kt b ku nv kd kw kx nw kg kz la nx lc ld le ny lg lh li nz lk ll lm im bi translated">我们应该将类的生命周期管理与类本身分开。</p><h1 id="afc7" class="nd ne it bd nf ng nh ni nj nk nl nm nn ki ov kj np kl ow km nr ko ox kp nt nu bi translated"><strong class="ak">T代表什么？T </strong>右联轴器</h1><p id="359e" class="pw-post-body-paragraph kr ks it kt b ku nv kd kw kx nw kg kz la nx lc ld le ny lg lh li nz lk ll lm im bi translated">也称为强耦合。</p><pre class="lp lq lr ls gt oa ob oc od aw oe bi"><span id="fddf" class="of ne it ob b gy og oh l oi oj">Tight coupling is a generalization of the <strong class="ob jd">singleton</strong> problem.</span></pre><p id="8f1a" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">耦合是衡量在一个模块中进行更改所需的其他模块中的更改的标准。它越大，代码的耦合性就越强。</p><p id="25e5" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">紧密耦合的模块很难使用，更改成本很高，也很难测试。基本上，您应该减少模块之间的耦合。</p><h1 id="2409" class="nd ne it bd nf ng nh ni nj nk nl nm nn ki ov kj np kl ow km nr ko ox kp nt nu bi translated"><strong class="ak">U代表什么？不稳定性</strong></h1><pre class="lp lq lr ls gt oa ob oc od aw oe bi"><span id="a8a8" class="of ne it ob b gy og oh l oi oj">Most of the time, untestability is caused by <strong class="ob jd">tight coupling</strong>.</span></pre><p id="2dea" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">一般来说，紧密耦合以及隐藏的依赖使得测试模块更加困难和昂贵。</p><p id="292c" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">每当我们<code class="fe oy oz pa ob b">don’t unit test</code>我们的代码是因为<code class="fe oy oz pa ob b">there is no time</code>，真正的原因是我们的代码是<code class="fe oy oz pa ob b">bad</code>。</p><h1 id="622b" class="nd ne it bd nf ng nh ni nj nk nl nm nn ki ov kj np kl ow km nr ko ox kp nt nu bi translated">P代表什么？剩余优化</h1><p id="0b64" class="pw-post-body-paragraph kr ks it kt b ku nv kd kw kx nw kg kz la nx lc ld le ny lg lh li nz lk ll lm im bi translated">根据高德纳的说法:</p><pre class="lp lq lr ls gt oa ob oc od aw oe bi"><span id="7385" class="of ne it ob b gy og oh l oi oj">Premature optimization is the root of all evil. Only costs alone, and no good.</span></pre><p id="1647" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">优化的系统比仅仅写一个循环或者用前增量代替后增量要复杂得多。你最终会得到不可读的代码。这就是系统优化更加困难的原因。</p><p id="52c9" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">优化应用程序有两个规则:</p><ul class=""><li id="d578" class="mf mg it kt b ku kv kx ky la mh le mi li mj lm mk ml mm mn bi translated">不要这样做</li><li id="d0ea" class="mf mg it kt b ku mo kx mp la mq le mr li ms lm mk ml mm mn bi translated">暂时不要对此进行优化</li></ul><h1 id="8404" class="nd ne it bd nf ng nh ni nj nk nl nm nn ki ov kj np kl ow km nr ko ox kp nt nu bi translated">我是为了什么？I 非描述性命名</h1><p id="f359" class="pw-post-body-paragraph kr ks it kt b ku nv kd kw kx nw kg kz la nx lc ld le ny lg lh li nz lk ll lm im bi translated">我们应该使用有意义的名字来命名变量、类、方法。等等。</p><pre class="lp lq lr ls gt oa ob oc od aw oe bi"><span id="d494" class="of ne it ob b gy og oh l oi oj">Don’t write code that only you can understand.</span></pre><p id="22cd" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">既然我们是给人写代码，而不是给机器写代码(<em class="ln">计算机只理解0和1 </em>)。</p><ul class=""><li id="7d58" class="mf mg it kt b ku kv kx ky la mh le mi li mj lm mk ml mm mn bi translated">适当地命名你的类、方法、属性和变量</li><li id="b04e" class="mf mg it kt b ku mo kx mp la mq le mr li ms lm mk ml mm mn bi translated">不要缩写它们，永远不要！</li></ul><pre class="lp lq lr ls gt oa ob oc od aw oe bi"><span id="d5d3" class="of ne it ob b gy og oh l oi oj">// you shouldn't<br/>const n = 3.14;<br/>const r = 5</span><span id="75c9" class="of ne it ob b gy ok oh l oi oj">const a = r * n * n </span><span id="ac28" class="of ne it ob b gy ok oh l oi oj">// you should<br/>const piNumber = 3.14;<br/>const radius = 5;</span><span id="c513" class="of ne it ob b gy ok oh l oi oj">const areaOfCiricle = radius * piNumber * piNumber</span></pre><p id="bde2" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">请记住，我们总是让我们的程序对其他人可读。</p><h1 id="4a9a" class="nd ne it bd nf ng nh ni nj nk nl nm nn ki ov kj np kl ow km nr ko ox kp nt nu bi translated"><strong class="ak">D代表什么？D </strong>复制</h1><p id="0736" class="pw-post-body-paragraph kr ks it kt b ku nv kd kw kx nw kg kz la nx lc ld le ny lg lh li nz lk ll lm im bi translated">程序员很懒:</p><pre class="lp lq lr ls gt oa ob oc od aw oe bi"><span id="9f68" class="of ne it ob b gy og oh l oi oj">Be lazy the right way — write code only once!</span></pre><p id="6d08" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">重复的代码是不好的，所以请<em class="ln">不要重复自己</em>，还有<em class="ln">保持简单，笨蛋</em>。</p><ul class=""><li id="652c" class="mf mg it kt b ku kv kx ky la mh le mi li mj lm mk ml mm mn bi translated">“<em class="ln">不要重复自己</em>原则背后的想法是重用你以前写的代码，而不是重复它。</li><li id="b425" class="mf mg it kt b ku mo kx mp la mq le mr li ms lm mk ml mm mn bi translated">“<em class="ln">保持简单，愚蠢的</em>”原则指出，如果事情保持简单而不是复杂，它们会更好地发挥作用。</li></ul><h1 id="4890" class="nd ne it bd nf ng nh ni nj nk nl nm nn ki ov kj np kl ow km nr ko ox kp nt nu bi translated">结论</h1><p id="ab1a" class="pw-post-body-paragraph kr ks it kt b ku nv kd kw kx nw kg kz la nx lc ld le ny lg lh li nz lk ll lm im bi translated">今天，我试图简单明了地解释你在编写代码时应该避免的原则。愚蠢的方法导致难以维护和难以测试的代码设计。在实践中，为了不成为一个愚蠢的程序员，你可以应用SOLID⁴原则。</p><ul class=""><li id="5b78" class="mf mg it kt b ku kv kx ky la mh le mi li mj lm mk ml mm mn bi translated"><strong class="kt jd"> <em class="ln">单一责任原则</em> </strong>:一个类的改变不应该有一个以上的原因。</li><li id="7597" class="mf mg it kt b ku mo kx mp la mq le mr li ms lm mk ml mm mn bi translated"><strong class="kt jd"> <em class="ln">开闭原则</em> </strong>:软件实体对于扩展应该是开放的，对于修改应该是封闭的。</li><li id="9a28" class="mf mg it kt b ku mo kx mp la mq le mr li ms lm mk ml mm mn bi translated"><strong class="kt jd"> <em class="ln">利斯科夫替换原则</em> </strong>:程序中的对象应该可以用它们的子类型的实例替换，而不改变程序的正确性。</li><li id="56d1" class="mf mg it kt b ku mo kx mp la mq le mr li ms lm mk ml mm mn bi translated"><strong class="kt jd"> <em class="ln">接口分离原则</em> </strong>:多个客户端专用接口比一个通用接口要好。</li><li id="230a" class="mf mg it kt b ku mo kx mp la mq le mr li ms lm mk ml mm mn bi translated"><strong class="kt jd"> <em class="ln">依赖倒置原则</em> </strong>:高层模块不应该依赖低层模块。两者都应该依赖于抽象。</li></ul><p id="0ebd" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我之前的一篇文章《<a class="ae me" href="https://javascript.plainenglish.io/rethinking-solid-principles-in-javascript-7effdd4dc37d" rel="noopener ugc nofollow" target="_blank">重新思考坚实的原则</a>》可以帮助你在编程中获得更多新的思路。</p><p id="9f6e" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">很简单，对吧？</p></div><div class="ab cl pb pc hx pd" role="separator"><span class="pe bw bk pf pg ph"/><span class="pe bw bk pf pg ph"/><span class="pe bw bk pf pg"/></div><div class="im in io ip iq"><h1 id="fe4c" class="nd ne it bd nf ng pi ni nj nk pj nm nn ki pk kj np kl pl km nr ko pm kp nt nu bi translated">参考</h1><p id="3e73" class="pw-post-body-paragraph kr ks it kt b ku nv kd kw kx nw kg kz la nx lc ld le ny lg lh li nz lk ll lm im bi translated">[1]<a class="ae me" href="https://en.wikipedia.org/wiki/Singleton_pattern" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Singleton_pattern</a></p><p id="e140" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><a class="ae me" href="https://martinfowler.com/ieeeSoftware/coupling.pdf" rel="noopener ugc nofollow" target="_blank">https://martinfowler.com/ieeeSoftware/coupling.pdf</a></p><p id="d952" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">[3]<a class="ae me" href="http://wiki.c2.com/?PrematureOptimization" rel="noopener ugc nofollow" target="_blank">http://wiki.c2.com/?PrematureOptimization</a></p><p id="0021" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">[4]<a class="ae me" href="https://javascript.plainenglish.io/rethinking-solid-principles-in-javascript-7effdd4dc37d" rel="noopener ugc nofollow" target="_blank">https://JavaScript . plain English . io/refreshing-solid-principles-in-JavaScript-7 eff DD 4d c37 d</a></p></div></div>    
</body>
</html>