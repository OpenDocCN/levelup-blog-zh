<html>
<head>
<title>JavaScript Function Construction (Part 3)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript函数构造(第3部分)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-function-construction-part-3-d673ff247541?source=collection_archive---------8-----------------------#2020-04-02">https://levelup.gitconnected.com/javascript-function-construction-part-3-d673ff247541?source=collection_archive---------8-----------------------#2020-04-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9d20" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">生活和原型遗传</h2></div><p id="cb38" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/function-construction-whats-your-function-5a282b81fc62">第1部分</a> | <a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/function-construction-part-2-f6a711075b11">第2部分</a> | <strong class="kk iu">第3部分</strong> | <a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/javascript-function-construction-part-4-d532f0a5e4af">第4部分</a> | <a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/javascript-function-construction-part-5-90733a0e6369">第5部分</a> | <a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/javascript-function-construction-part-6-72cfd6b18a7c">第6部分</a> | <a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/javascript-function-construction-part-7-17c5661e6ea7">第7部分</a></p><p id="fe5b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我之前关于函数构造器的博客中，我们将getTime库变成了一个IIFE(或IIFC ),并想出了如何正确地将其导入和导出到其他普通JS脚本以及浏览器中。我们还设法弄清楚如何让<code class="fe lf lg lh li b">getTime.js</code>同时在VSC和浏览器中正常运行。</p><p id="748c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们取得了很大进步，但我认为还有进一步改进的空间。</p><p id="2dc0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是在我们开始重构<code class="fe lf lg lh li b">getTime.js</code>之前，让我们花点时间回顾一下将会推动我们今天所做的改变的一些方法。</p><p id="d9cd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">再说遗产。</p></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h2 id="5b30" class="lq lr it bd ls lt lu dn lv lw lx dp ly kr lz ma mb kv mc md me kz mf mg mh mi bi translated">继承客观的客观性</h2><p id="ea83" class="pw-post-body-paragraph ki kj it kk b kl mj ju kn ko mk jx kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">继承可以被定义为一种共享对象的方法和属性的方式。当一个对象获得对另一个对象的属性和方法的访问权，或者从一个单独的对象接收属性时，我们说它继承了它们。我们可以通过几种不同的方式做到这一点。</p><p id="0112" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一个例子是使用<code class="fe lf lg lh li b">.call()</code>方法。<code class="fe lf lg lh li b">.call()</code>方法调用一个函数，并允许对<code class="fe lf lg lh li b">‘this’</code>变量进行重新赋值。<code class="fe lf lg lh li b">.call()</code>方法还让我们在对象之间传递参数。</p><p id="5387" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在下面的例子中，我们有两个函数使用<code class="fe lf lg lh li b">‘this’</code>关键字将属性分配给两个独立的函数构造函数。在第二个对象中，我们用<code class="fe lf lg lh li b">.call()</code>方法调用<code class="fe lf lg lh li b">obj1</code>。这允许我们将<code class="fe lf lg lh li b">obj1</code>的属性传递给<code class="fe lf lg lh li b">obj2</code>，并且我们可以通过将<code class="fe lf lg lh li b">‘this’</code>关键字作为参数传递来将<code class="fe lf lg lh li b">obj1</code>的执行上下文发送给<code class="fe lf lg lh li b">obj2</code>。</p><p id="f138" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们将每个对象存储到一个变量中并对它们进行<code class="fe lf lg lh li b">console.log</code>，我们将会看到<code class="fe lf lg lh li b">obj2</code>通过<code class="fe lf lg lh li b">.call()</code>方法继承了obj1的属性:</p><pre class="mo mp mq mr gt ms li mt mu aw mv bi"><span id="5105" class="lq lr it li b gy mw mx l my mz">function obj1() {<br/> this.prop1 = ‘string1’<br/> this.prop2 = ‘string2’<br/>}</span><span id="70e5" class="lq lr it li b gy na mx l my mz">function obj2() {<br/> obj1.call(this)</span><span id="d3e7" class="lq lr it li b gy na mx l my mz"> this.prop3 = 1<br/> this.prop4 = 2<br/>}</span><span id="79ab" class="lq lr it li b gy na mx l my mz">let createObj1 = new obj1()<br/>let createObj2 = new obj2()</span><span id="ea87" class="lq lr it li b gy na mx l my mz">console.log(createObj1)<br/>console.log(createObj2)</span></pre><figure class="mo mp mq mr gt nc gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/347060b64c6e6a5f2a50ff36182e6a7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:714/format:webp/1*JuKH_hh0lhrfAJfD3Jx8kg.jpeg"/></div></figure><p id="59bc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">很简单…但是如果我们想在一个对象被创建后给它添加一个属性或函数呢？</p><p id="ff95" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是我们可以利用另一个概念的地方，我们会看到很多所谓的原型继承。</p></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h2 id="2919" class="lq lr it bd ls lt lu dn lv lw lx dp ly kr lz ma mb kv mc md me kz mf mg mh mi bi translated"><strong class="ak">你是原型</strong></h2><p id="2827" class="pw-post-body-paragraph ki kj it kk b kl mj ju kn ko mk jx kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">所有对象、函数和数组都有一个原型对象。该对象包含JavaScript引擎为给定数据类型预先定义的一组方法。</p><p id="88b6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">重要的是我们可以使用一个叫做<code class="fe lf lg lh li b">.prototype</code>的方法来为我们正在创建的对象或函数分配自定义方法。我们希望将我们的自定义方法存储在<code class="fe lf lg lh li b">.prototype</code>对象中，这样我们就不会在每次通过函数构造器构建新对象时都创建一组新方法。请记住，当我们将对象存储到变量中时，我们是通过引用来访问对象的。我们不创造新的物体。这非常适合我们如何使用<code class="fe lf lg lh li b">.prototype</code>。</p><p id="f7fb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这也节省了内存空间，因为我们不会在每次初始化一个新对象时都创建一组新的方法。最重要的是，<code class="fe lf lg lh li b">.prototype</code>方法的伟大之处在于它允许两个独立的对象共享同一个原型对象。这叫做原型继承。</p><p id="5716" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们看一些例子。</p><p id="97a2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，让我们看看JavaScript为我们提供的一些默认方法。</p><p id="e9ed" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们在浏览器中对一个数组调用<code class="fe lf lg lh li b">.prototype</code>，我们会看到很多熟悉的面孔:</p><figure class="mo mp mq mr gt nc gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi nf"><img src="../Images/c7f7a470ec5a2e781445e3dab530e663.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zWPy7NaocGd3UX3jyItHsg.jpeg"/></div></div></figure><p id="f982" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">或者一个物体:</p><figure class="mo mp mq mr gt nc gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi nk"><img src="../Images/072441b8fc2880775be374e4a2632fdc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EiQw3DCUJKx9rc4qjtwkDw.jpeg"/></div></div></figure><p id="6dc5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">甚至是一个字符串:</p><figure class="mo mp mq mr gt nc gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/9c4e0c8847701b601662e103f0850f3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:888/format:webp/1*DTq8HuO97UbS4Xrbv5nOEQ.jpeg"/></div></figure><p id="444a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> <em class="nm">重要提示</em> </strong> : <em class="nm">函数构造函数和</em> <code class="fe lf lg lh li b"><em class="nm">.prototype</em></code> <em class="nm">不能与箭头函数一起使用。ES6 arrow函数自动将</em> <code class="fe lf lg lh li b"><em class="nm">‘this'</em></code> <em class="nm">关键字绑定到正在创建的执行上下文中，会抛出很多错误。坚持使用熟悉的</em> <code class="fe lf lg lh li b"><em class="nm">function(){}</em></code> <em class="nm">。</em></p><p id="7b2a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">酷，但是添加一个我们想写的新方法呢？</p><p id="01fd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">好吧，让我们试试。</p><p id="5d1f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以创建一个新的函数构造函数，这一次，向构造函数传递一些参数:</p><pre class="mo mp mq mr gt ms li mt mu aw mv bi"><span id="6cdf" class="lq lr it li b gy mw mx l my mz">function createObj(a, b, c) {<br/> this.prop1 = a<br/> this.prop2 = b<br/> this.prop3 = c<br/>}</span></pre><p id="b63c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以用<code class="fe lf lg lh li b">.prototype</code>添加一个新的属性或功能。我们可以设置方法的名称并将其存储到一个变量中，或者将其设置为另一个函数。</p><p id="535f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还可以使用<code class="fe lf lg lh li b">‘this’</code>访问原型方法被添加到的对象的属性:</p><pre class="mo mp mq mr gt ms li mt mu aw mv bi"><span id="f1df" class="lq lr it li b gy mw mx l my mz">createObj.prototype.addProps = function(){<br/> return this.prop1 + this.prop2 + this.prop3<br/>}</span></pre><p id="1acd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后创建新对象:</p><pre class="mo mp mq mr gt ms li mt mu aw mv bi"><span id="ba2f" class="lq lr it li b gy mw mx l my mz">let obj1 = new createObj(1, 2, 3)</span></pre><p id="e3dd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们正在添加的功能是:</p><pre class="mo mp mq mr gt ms li mt mu aw mv bi"><span id="40f5" class="lq lr it li b gy mw mx l my mz">console.log(obj1.addProps())</span></pre><figure class="mo mp mq mr gt nc gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/9204a9cf69dce672c9fabbbb02f1c9ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:576/format:webp/1*R9b7dfuOhnCto0OI_Oig3g.jpeg"/></div></figure><p id="da87" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们也可以用<code class="fe lf lg lh li b">createObject()</code>创建另一个新对象，但是传递一些不同的变量:</p><pre class="mo mp mq mr gt ms li mt mu aw mv bi"><span id="4313" class="lq lr it li b gy mw mx l my mz">let obj2 = new createObj(4, 5, 6)</span></pre><p id="014d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">而<code class="fe lf lg lh li b">console.log</code>的<code class="fe lf lg lh li b"> .addProps()</code>功能对于<code class="fe lf lg lh li b">obj2</code>来说又得到一个不同的结果:</p><figure class="mo mp mq mr gt nc gh gi paragraph-image"><div class="gh gi no"><img src="../Images/091f68e34221ba5c372b0e72958816a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:608/format:webp/1*JcMzncvXX9TNVngcBULQqw.jpeg"/></div></figure><p id="4539" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在浏览器中，我们可以使用一个叫做<code class="fe lf lg lh li b">.__proto__</code>的方法来访问我们的两个对象的原型。</p><p id="a7c1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们应该看到他们继承的<code class="fe lf lg lh li b">.addProps()</code>方法:</p><p id="9b69" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">obj1:</p><figure class="mo mp mq mr gt nc gh gi paragraph-image"><div class="gh gi np"><img src="../Images/c6b7cb5b88483513c80042484d49c80f.png" data-original-src="https://miro.medium.com/v2/resize:fit:656/format:webp/1*btVJjmwvtxx6PcgwAU5r4w.jpeg"/></div></figure><p id="6fa1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">obj2:</p><figure class="mo mp mq mr gt nc gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/7dc88c3e76f6323de909984cae92169a.png" data-original-src="https://miro.medium.com/v2/resize:fit:662/format:webp/1*AC3Hz8IQ_zFn0FepzCOlhQ.jpeg"/></div></figure><p id="9606" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们看到<code class="fe lf lg lh li b">.addProps()</code>方法出现在<code class="fe lf lg lh li b">obj1</code>和<code class="fe lf lg lh li b">obj2</code>中，并且也出现在它们的构造器原型<code class="fe lf lg lh li b">createObj()</code>中。</p><p id="1e1b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这意味着两个对象共享位于<code class="fe lf lg lh li b">createObj()</code>函数构造器原型对象中的<code class="fe lf lg lh li b">.addProps()</code>方法。</p><p id="50ab" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">很好。</p><p id="8320" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> <em class="nm">重要提示:</em> </strong> <em class="nm">使用原型时，</em> <strong class="kk iu"> <em class="nm">仅</em> </strong> <em class="nm">使用</em> <code class="fe lf lg lh li b"><em class="nm"> .__proto__</em></code> <em class="nm">进行采样/测试。</em><strong class="kk iu"><em class="nm"/></strong><em class="nm">使用</em> <code class="fe lf lg lh li b"><em class="nm">.prototype</em></code> <em class="nm">方法。由于</em> <code class="fe lf lg lh li b"><em class="nm">.__proto___</em></code> <em class="nm">方法处理JavaScript引擎提供的默认方法集，修改</em> <code class="fe lf lg lh li b"><em class="nm">.__proto__</em></code> <em class="nm">可能会有一些严重的负面影响。</em></p></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h2 id="5db5" class="lq lr it bd ls lt lu dn lv lw lx dp ly kr lz ma mb kv mc md me kz mf mg mh mi bi translated"><strong class="ak">添加原型</strong></h2><p id="a057" class="pw-post-body-paragraph ki kj it kk b kl mj ju kn ko mk jx kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">我们将进行一些重构。我想把重点放在使用原型继承来改进<code class="fe lf lg lh li b">getTime.js</code>的内部功能上。这将最终改善我们用来从其他文件调用<code class="fe lf lg lh li b">getTime.js</code>的语法。</p><p id="93bd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">目前，下面是我们正在处理的文件:</p><p id="8516" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">文件结构:</p><figure class="mo mp mq mr gt nc gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/4b004018ef82f44fbad167cc53e27551.png" data-original-src="https://miro.medium.com/v2/resize:fit:452/format:webp/1*2vVDWwI_7IM0pyVza5L4Sw.jpeg"/></div></figure><p id="0069" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">getTime.js:</p><pre class="mo mp mq mr gt ms li mt mu aw mv bi"><span id="140f" class="lq lr it li b gy mw mx l my mz">(function(env) {<br/>  var getTime = function(){<br/>    return new getTime.init()<br/>  }</span><span id="0db7" class="lq lr it li b gy na mx l my mz">  getTime.init = function(){</span><span id="3c0a" class="lq lr it li b gy na mx l my mz">    this.date = new Date()</span><span id="6895" class="lq lr it li b gy na mx l my mz">    this.now = function() {<br/>      let hours = this.date.getHours() % 12<br/>      let ampm = this.date.getHours() &lt;= 12 ? ‘PM’ : ‘AM’<br/>      let minutes = this.date.getMinutes()</span><span id="b77a" class="lq lr it li b gy na mx l my mz">      hours = hours ? hours : 12<br/>      minutes = minutes &lt; 10 ? ‘0’ + minutes : minutes</span><span id="d617" class="lq lr it li b gy na mx l my mz">      return hours + ‘:’ + minutes + ‘ ‘ + ampm<br/>    }</span><span id="38cd" class="lq lr it li b gy na mx l my mz">    this.day = function() {<br/>      return this.date.getDate()<br/>    }</span><span id="84ac" class="lq lr it li b gy na mx l my mz">    this.month = function() {<br/>      return (this.date.getMonth() + 1)<br/>    }</span><span id="b520" class="lq lr it li b gy na mx l my mz">    this.year = function() {<br/>      return this.date.getFullYear()<br/>    }</span><span id="47e9" class="lq lr it li b gy na mx l my mz">    this.fullDate = function() {<br/>      return ‘(‘ + this.now() + ‘)’ + ‘ ‘ + this.month() + ‘/’ + this.day() + ‘/’ + this.year()<br/>    }<br/>  }</span><span id="1dfc" class="lq lr it li b gy na mx l my mz">  env.getTime = getTime</span><span id="b376" class="lq lr it li b gy na mx l my mz">})(typeof window === “undefined” ? global : window)</span></pre><p id="b40a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">main.js</p><pre class="mo mp mq mr gt ms li mt mu aw mv bi"><span id="edb2" class="lq lr it li b gy mw mx l my mz">if (typeof window === “undefined”) {<br/>  var getTime = require(‘./getTime’)<br/>  getTime = global.getTime<br/>} else {<br/>  document.addEventListener(“DOMContentLoaded”, addTime)<br/>  function addTime() {<br/>    const timeDiv = document.querySelector(“.time”)<br/>    timeDiv.innerText = `${getTime().now()}`<br/>  }<br/>}</span><span id="4786" class="lq lr it li b gy na mx l my mz">console.log(getTime().now())</span></pre><p id="16f4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">index.html:</p><pre class="mo mp mq mr gt ms li mt mu aw mv bi"><span id="0eb6" class="lq lr it li b gy mw mx l my mz">&lt;html&gt;<br/>  &lt;head&gt;<br/>    &lt;title&gt;Example&lt;/title&gt;<br/>    &lt;script src=’scripts/getTime.js’&gt;&lt;/script&gt;<br/>    &lt;script src=’scripts/main.js’&gt;&lt;/script&gt;<br/>  &lt;/head&gt;<br/>  &lt;body&gt;<br/>    &lt;div class=’time’&gt;&lt;/div&gt;<br/>  &lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="cbe6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">简而言之，<code class="fe lf lg lh li b">index.html</code>加载了我们的两个脚本:<code class="fe lf lg lh li b">getTime.js</code>和<code class="fe lf lg lh li b">main.js</code>。</p><p id="290f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">根据<code class="fe lf lg lh li b">main.js</code>执行的环境(VSC或浏览器)，它需要和/或导入<code class="fe lf lg lh li b">getTime.js</code>。</p><p id="a18d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，<code class="fe lf lg lh li b">main.js</code>调用IIFC并创建一个内置了我们的方法的新对象。</p><p id="e47d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后返回它创建的对象，并将该对象附加到全局执行上下文中。我们可以通过调用<code class="fe lf lg lh li b">getTime()</code>来执行所有这些。</p><p id="5110" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们可以将一个方法链接到那个调用上(比如<code class="fe lf lg lh li b">.now()</code>或<code class="fe lf lg lh li b">.fullDate()</code>)，并获取当前时间、当前日期、当前年份等等</p><p id="350d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们通过<code class="fe lf lg lh li b">main.js</code>调用<code class="fe lf lg lh li b">getTime.js</code>，因为我们希望能够在我们正在处理的任何其他普通JS文件中使用<code class="fe lf lg lh li b">getTime.js</code>，所以我们正在测试我们的IIFC是否被正确地导出/导入到其他普通JS文件中。否则，我们可以移除<code class="fe lf lg lh li b">main.js</code>并单独运行<code class="fe lf lg lh li b">getTime.js</code>。无论哪种方式，它应该没有问题。</p><p id="585e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们要做的第一件事是向我们的IIFC添加一个原型对象。然后我们想让我们的<code class="fe lf lg lh li b">init()</code>函数继承我们正在构建的原型对象。</p><p id="dbfc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们最终将把我们所有的时间方法移到原型对象中，但是现在让我们只添加一个测试方法:</p><pre class="mo mp mq mr gt ms li mt mu aw mv bi"><span id="11bf" class="lq lr it li b gy mw mx l my mz">getTime.prototype = {<br/>  test: function() {<br/>    return ‘test string’<br/>  }<br/>}</span></pre><p id="d15b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们在浏览器中尝试console.log <code class="fe lf lg lh li b">getTime.js</code>，我们似乎在任何地方都找不到“测试”功能:</p><figure class="mo mp mq mr gt nc gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi ns"><img src="../Images/d1c98288ece35d5fc0c4d56b7f0bc197.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AbdunkGszAGLc83H3InV2g.jpeg"/></div></div></figure><p id="17b9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">嗯…我们返回的对象叫做<code class="fe lf lg lh li b">getTime.init</code>…而不是getTime…那么如果我们尝试将<code class="fe lf lg lh li b">getTime.init</code>的原型设置为getTime的原型，因为我们返回的是对<code class="fe lf lg lh li b">getTime.init</code>的调用，会怎么样呢？</p><pre class="mo mp mq mr gt ms li mt mu aw mv bi"><span id="e296" class="lq lr it li b gy mw mx l my mz">getTime.prototype = {<br/>  test: function() {<br/>    return ‘test string’<br/>  }<br/>}</span><span id="9e5a" class="lq lr it li b gy na mx l my mz">getTime.init.prototype = getTime.prototype</span></pre><figure class="mo mp mq mr gt nc gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi nt"><img src="../Images/7e6c9c79d22266451832564b396c4258.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Om86_Z1lazKkHlDR4vr7yw.jpeg"/></div></div></figure><p id="8420" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">找到了。</p><p id="e66e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们<code class="fe lf lg lh li b">console.log</code>测试函数:</p><figure class="mo mp mq mr gt nc gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/a130cb7ffdec2d40d6b3ae37a684da36.png" data-original-src="https://miro.medium.com/v2/resize:fit:688/format:webp/1*RkxIas7bVjiWNaKIzgkZbQ.jpeg"/></div></figure><p id="3a4b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">太好了。</p><p id="7a44" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将<code class="fe lf lg lh li b">getTime.init.prototype</code>设置为等于<code class="fe lf lg lh li b">getTime.prototype</code>，因为我们用来构建对象的函数被称为<code class="fe lf lg lh li b">getTime.init</code>，而<code class="fe lf lg lh li b">getTime.init</code>当前在其原型对象中没有任何内容。所以我们可以设置<code class="fe lf lg lh li b">getTime.init.prototype</code>到<code class="fe lf lg lh li b">getTime.prototype</code>来建立一个原型链，并继承我们存储在<code class="fe lf lg lh li b">getTime.prototype</code>中的方法。</p><p id="2974" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当一个对象继承了另一个对象的属性，而没有重写原对象的属性时，称为纯原型继承。</p><p id="569a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们设置<code class="fe lf lg lh li b">getTime.init.prototype</code>等于<code class="fe lf lg lh li b">getTime.prototype</code>，我们是通过引用访问<code class="fe lf lg lh li b">getTime.prototype</code>，而不是创建一个新对象。</p><p id="3225" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于JavaScript的原型链，我们还可以访问原型对象中的<code class="fe lf lg lh li b">.test()</code>函数，而不必编写<code class="fe lf lg lh li b">.prototype.test()</code>。</p><p id="3692" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">原型链是一个函数、对象或数组从其他函数、对象或数组继承的原型对象链。JavaScript引擎将在一个链中的所有原型对象中查找属性，但是如果找不到它正在查找的属性或函数，则返回undefined。</p><p id="ebb5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">示例:如果我们有一个看起来像这样的原型链:</p><pre class="mo mp mq mr gt ms li mt mu aw mv bi"><span id="fd0e" class="lq lr it li b gy mw mx l my mz">obj.prototype.prototype.prototype.prop1</span></pre><p id="3b9c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们只需输入<code class="fe lf lg lh li b">obj.prop1</code>就可以访问prop1</p><p id="43f7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们已经建立了基本的原型链，让我们将所有的自定义方法移入原型对象，并将所有内容格式化为键/值对:</p><figure class="mo mp mq mr gt nc gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/e3f5f32607c26b314a0413d9854137b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1086/format:webp/1*eBisCqFbm3buXFIjIRfDHg.jpeg"/></div></figure><p id="b608" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们唯一没有移入原型的是日期属性。这更像是一个美学原因，我想用一些东西初始化init对象(不过我稍后会更改)。如果我们真的想的话，我们可以把日期移到原型对象上。</p><p id="0cb4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过将date属性保存在init对象中，我们可以<code class="fe lf lg lh li b">console.log(getTime)</code>获得一个漂亮整洁的对象，日期保存在init对象中，其他内容保存在我们的prototype对象中:</p><figure class="mo mp mq mr gt nc gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi nt"><img src="../Images/c31b849fc9c0c1aa85c8f60500857df4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5COTZ1MhkC7TbIUlegO8ag.jpeg"/></div></div></figure><p id="4d1c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那很好。</p><p id="7790" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是如果我们想调用这些方法中的任何一个，我们仍然需要做这样的事情:</p><pre class="mo mp mq mr gt ms li mt mu aw mv bi"><span id="aba0" class="lq lr it li b gy mw mx l my mz">getTime().now()<br/>getTime().day()<br/>getTime().month()<br/>getTime().year()</span></pre><p id="0c33" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">…老实说，那个双括号实在是太难看了。</p><p id="b114" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果不是将方法链接到<code class="fe lf lg lh li b">getTime()</code>上，而是将参数传递到<code class="fe lf lg lh li b">getTime()</code>，并让我们的函数构造器计算出要调用哪个方法，会怎么样？</p><p id="fac4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">大概是这样的:</p><pre class="mo mp mq mr gt ms li mt mu aw mv bi"><span id="9364" class="lq lr it li b gy mw mx l my mz">getTime(‘now‘)<br/>getTime(‘day‘)<br/>getTime(‘month‘)<br/>getTime(‘year‘)</span></pre><p id="5d25" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">…如果我们不向<code class="fe lf lg lh li b">getTime()</code>传递任何参数，我们会得到一个默认方法，或者类似的错误消息？</p><p id="591c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这将是非常巧妙的，对不对？</p><p id="28fa" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们开始吧。</p></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h2 id="5da4" class="lq lr it bd ls lt lu dn lv lw lx dp ly kr lz ma mb kv mc md me kz mf mg mh mi bi translated"><strong class="ak">添加关键字参数</strong></h2><p id="de6b" class="pw-post-body-paragraph ki kj it kk b kl mj ju kn ko mk jx kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">我们要做的第一件事是重构我们的<code class="fe lf lg lh li b">init()</code>函数，接受我们要传递给它的关键字，然后沿着原型链向下发送，并寻找相应的方法。</p><p id="ce54" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，如果我们用关键字调用<code class="fe lf lg lh li b">getTime</code>:</p><pre class="mo mp mq mr gt ms li mt mu aw mv bi"><span id="5642" class="lq lr it li b gy mw mx l my mz">getTime(‘now‘)</span></pre><p id="6006" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们希望init函数获取该关键字，并在原型对象中找到匹配的键/值对。我们已经返回了对<code class="fe lf lg lh li b">init()</code>的调用，所以我们也可以返回对<code class="fe lf lg lh li b">init.prototype()</code>中函数的调用。</p><p id="8c72" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以这样做:将对<code class="fe lf lg lh li b">init()</code>的调用存储到一个变量中，然后通过<code class="fe lf lg lh li b">init()</code>的计算成员访问操作符传递我们希望它找到的关键字，并返回它:</p><pre class="mo mp mq mr gt ms li mt mu aw mv bi"><span id="18cd" class="lq lr it li b gy mw mx l my mz">var getTime = function(keyword){<br/>  var init = new getTime.init(keyword)<br/>  return init[keyword]<br/>}</span></pre><p id="0db5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，如果我们将<code class="fe lf lg lh li b">‘now’</code>传递给<code class="fe lf lg lh li b">getTime()</code>，关键字参数将等于<code class="fe lf lg lh li b">‘now’</code>，我们可以将它传递给原型链，并像以前一样返回对<code class="fe lf lg lh li b">‘now’</code>函数的调用。</p><p id="fde3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">目前，如果我们尝试<code class="fe lf lg lh li b">console.log(getTime(‘now’))</code>，我们得到的只是一个函数定义。我们得到了<code class="fe lf lg lh li b">‘now’</code>的函数定义，所以它的工作方式是:</p><figure class="mo mp mq mr gt nc gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/61668d2af298e6172aecbe5781514fe6.png" data-original-src="https://miro.medium.com/v2/resize:fit:690/format:webp/1*oqp6QW0XviZAfNKIBar3kA.jpeg"/></div></figure><p id="6d87" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们试图引用这个定义呢？</p><figure class="mo mp mq mr gt nc gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/dda7fd771d4fd489433df18bd41b71a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:958/format:webp/1*caV-x9LTHxbszM9nVHWf4A.jpeg"/></div></figure><p id="03b2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有意思…</p><p id="18c9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们尝试从<code class="fe lf lg lh li b">init()</code>函数中调用函数定义会怎么样？</p><pre class="mo mp mq mr gt ms li mt mu aw mv bi"><span id="8502" class="lq lr it li b gy mw mx l my mz">getTime.init = function(keyword){<br/>  this.date = new Date()<br/>  this[keyword]()<br/>}</span></pre><p id="6b8e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们再次得到函数定义:</p><figure class="mo mp mq mr gt nc gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/61668d2af298e6172aecbe5781514fe6.png" data-original-src="https://miro.medium.com/v2/resize:fit:690/format:webp/1*oqp6QW0XviZAfNKIBar3kA.jpeg"/></div></figure><p id="30c6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">好吧…奇怪…让我们试着像添加原型对象之前一样，在<code class="fe lf lg lh li b">init()</code>函数中设置一个测试变量:</p><pre class="mo mp mq mr gt ms li mt mu aw mv bi"><span id="497e" class="lq lr it li b gy mw mx l my mz">getTime.init = function(keyword){<br/>  this.date = new Date()</span><span id="8f95" class="lq lr it li b gy na mx l my mz">  this[keyword] = ‘test’<br/>}</span></pre><p id="6384" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们尝试<code class="fe lf lg lh li b">console.log getTime('now')</code>时，现在会发生什么？</p><figure class="mo mp mq mr gt nc gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/03a956654e8d0255f04cc18965bc1eec.png" data-original-src="https://miro.medium.com/v2/resize:fit:698/format:webp/1*J4D6WV3Ocg93dncwygOXcQ.jpeg"/></div></figure><p id="2850" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们拿回‘测试’。</p><p id="4f68" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这很好。</p><p id="a3e3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这意味着我们正在<code class="fe lf lg lh li b">init()</code>中创建一个动态属性。</p><p id="87f7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">唯一的问题是被调用的函数没有找到它需要的属性。</p><p id="50b7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们知道我们传递的关键字被接受到了<code class="fe lf lg lh li b">init() </code>函数中。我们也知道JavaScript总是会沿着原型链寻找变量定义。我们知道，每次调用一个函数都会创建一个新的执行上下文，这会改变“this”关键字所指向的引用。所以我们需要<code class="fe lf lg lh li b">init() </code>在原型对象中找到并调用方法，使<code class="fe lf lg lh li b">init()</code>和<code class="fe lf lg lh li b">init.prototype</code>共享相同的执行上下文。</p><p id="2de2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么，如果我们将<code class="fe lf lg lh li b">init()</code>中的动态属性设置为等于自身的调用，会怎么样呢？</p><pre class="mo mp mq mr gt ms li mt mu aw mv bi"><span id="a56c" class="lq lr it li b gy mw mx l my mz">getTime.init = function(keyword){<br/>  this.date = new Date()<br/>  this[keyword] = this[keyword]()<br/>}</span></pre><p id="88fb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">…如果我们再次尝试<code class="fe lf lg lh li b">console.log getTime(‘now')</code>呢？</p><figure class="mo mp mq mr gt nc gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/8b3da2e37163547e75cee1c76201f83b.png" data-original-src="https://miro.medium.com/v2/resize:fit:696/format:webp/1*l6F8DXQuV9-Jg55rrchkxQ.jpeg"/></div></figure><p id="0b21" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">杰克波特。</p><p id="ed47" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们能在浏览器里<code class="fe lf lg lh li b">console.log(getTime.prototype)</code>吗？</p><figure class="mo mp mq mr gt nc gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/27db4a267120ce6e166aa9a8b0709087.png" data-original-src="https://miro.medium.com/v2/resize:fit:756/format:webp/1*VbpEzD6lmRFS7hvfttjFgw.jpeg"/></div></figure><p id="0ec4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">布林戈。</p><p id="9763" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们不争论会怎么样？</p><figure class="mo mp mq mr gt nc gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/e12e5e09d59a6f5bb55a67f2ea5f1802.png" data-original-src="https://miro.medium.com/v2/resize:fit:818/format:webp/1*MWYlYXACRmg73BDoOP-IgA.jpeg"/></div></figure><p id="af7b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">嗯……有意思。这很有道理。</p><p id="fe3e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为我们没有向<code class="fe lf lg lh li b">getTime()</code>传递参数，所以函数构造函数在原型链中没有任何东西可找，并且抛出一个TypeError，因为它找不到一个带有我们给它的参数的方法(其实什么都没有)。</p><p id="a32d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以让我们做一些错误处理。</p><p id="fad3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以使用三元运算符来检查<code class="fe lf lg lh li b">this[keyword]</code>是否为真，如果不是，则返回一个错误消息。否则，调用我们沿着原型链发送的动态方法:</p><pre class="mo mp mq mr gt ms li mt mu aw mv bi"><span id="799e" class="lq lr it li b gy mw mx l my mz">getTime.init = function(keyword){<br/>  this.date = new Date()</span><span id="5618" class="lq lr it li b gy na mx l my mz">  this[keyword] = this[keyword] ? this[keyword]() : ‘Error. Please pass an argument into getTime()’<br/>}</span></pre><p id="a182" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在如果我们没有任何争论？</p><figure class="mo mp mq mr gt nc gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/d15f840c4ea570278215959b803b596d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1086/format:webp/1*LBDOUgKhQJW14UIAk5fE3w.jpeg"/></div></figure><p id="5c6c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">太美了。</p><p id="58b5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们稍微扩展一下这个错误消息。</p><p id="4c4e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们的三元运算符为falsey语句返回一个错误函数:</p><pre class="mo mp mq mr gt ms li mt mu aw mv bi"><span id="de49" class="lq lr it li b gy mw mx l my mz">getTime.init = function(keyword){<br/>  this.date = new Date()</span><span id="dcea" class="lq lr it li b gy na mx l my mz">  this[keyword] = this[keyword] ? this[keyword]() : this.error(keyword)<br/>}</span></pre><p id="8d1f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果没有传递参数，则返回一条错误消息，如果传递了无效的关键字，则返回一条错误消息:</p><p id="4bce" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<code class="fe lf lg lh li b">getTime.prototype</code>中:</p><pre class="mo mp mq mr gt ms li mt mu aw mv bi"><span id="6963" class="lq lr it li b gy mw mx l my mz">error: function(keyword) {<br/>  if (keyword === ‘’ || keyword === null || keyword === undefined) {<br/>    return ‘Please enter a keyword’<br/>  } else {<br/>    return `${keyword} is an invalid keyword`<br/>  }<br/>}</span></pre><p id="fa8d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以现在如果我们再一次没有任何参数的情况下……</p><figure class="mo mp mq mr gt nc gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/1fecd29ab7c5145c03b3978266891cb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:702/format:webp/1*i1D-oDDR1-cDiGEBk3_8Ww.jpeg"/></div></figure><p id="4d4d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">无效关键词怎么办？</p><figure class="mo mp mq mr gt nc gh gi paragraph-image"><div class="gh gi od"><img src="../Images/0e5623f9303308930c3c0b35f969776d.png" data-original-src="https://miro.medium.com/v2/resize:fit:706/format:webp/1*VuU6v7zfBVxI5VwjS5mlug.jpeg"/></div></figure><p id="8302" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">太棒了。</p><p id="2b70" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是对我们的2个脚本的最后一次检查(我将this.date移动到了原型对象中):</p><p id="20b3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">getTime.js:</p><pre class="mo mp mq mr gt ms li mt mu aw mv bi"><span id="6567" class="lq lr it li b gy mw mx l my mz">(function(env) {</span><span id="062a" class="lq lr it li b gy na mx l my mz">  var getTime = function(keyword){<br/>    var init = new getTime.init(keyword)<br/>    return init[keyword]<br/>  }</span><span id="6749" class="lq lr it li b gy na mx l my mz">  getTime.init = function(keyword){<br/>    this[keyword] = this[keyword] ? this[keyword]() : this.error(keyword)<br/>  }</span><span id="9bfb" class="lq lr it li b gy na mx l my mz">  getTime.prototype = {<br/>    date: new Date(),</span><span id="5300" class="lq lr it li b gy na mx l my mz">    now: function() {<br/>      let hours = this.date.getHours() % 12<br/>      let ampm = this.date.getHours() &lt;= 12 ? 'AM' : 'PM'<br/>      let minutes = this.date.getMinutes()</span><span id="2019" class="lq lr it li b gy na mx l my mz">      hours = hours ? hours : 12<br/>      minutes = minutes &lt; 10 ? '0' + minutes : minutes</span><span id="4dd8" class="lq lr it li b gy na mx l my mz">      return hours + ':' + minutes + ' ' + ampm<br/>    },</span><span id="c3c4" class="lq lr it li b gy na mx l my mz">    day: function() {<br/>      return this.date.getDate()<br/>    },</span><span id="d283" class="lq lr it li b gy na mx l my mz">    month: function() {<br/>      return (this.date.getMonth() + 1)<br/>    },</span><span id="89c4" class="lq lr it li b gy na mx l my mz">    year: function() {<br/>      return this.date.getFullYear()<br/>    },</span><span id="da73" class="lq lr it li b gy na mx l my mz">    fullDate: function() {<br/>      return '(' + this.now() + ')' + ' ' + this.month() + '/' + this.day() + '/' + this.year()<br/>    },</span><span id="a959" class="lq lr it li b gy na mx l my mz">    error: function(keyword) {<br/>      if (keyword === '' || keyword === null || keyword === undefined) {<br/>        return 'Please enter a keyword'<br/>      } else {<br/>        return `${keyword} is an invalid keyword`<br/>      }<br/>    }<br/>  }</span><span id="7112" class="lq lr it li b gy na mx l my mz">  getTime.init.prototype = getTime.prototype</span><span id="262a" class="lq lr it li b gy na mx l my mz">  env.getTime = getTime</span><span id="78fa" class="lq lr it li b gy na mx l my mz">})(typeof window === "undefined" ? global : window)</span></pre><p id="ca36" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">main.js</p><pre class="mo mp mq mr gt ms li mt mu aw mv bi"><span id="4078" class="lq lr it li b gy mw mx l my mz">if (typeof window === "undefined") {<br/>  var getTime = require('./getTime')<br/>  getTime = global.getTime<br/>} else {<br/>  document.addEventListener("DOMContentLoaded", addTime)<br/>  function addTime() {<br/>    const timeDiv = document.querySelector(".time")<br/>    timeDiv.innerText = `${getTime('now')}`<br/>  }<br/>}</span><span id="48db" class="lq lr it li b gy na mx l my mz">console.log(getTime())</span></pre><p id="1cc4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们所要做的就是向函数中传递一个关键字来访问原型方法:</p><pre class="mo mp mq mr gt ms li mt mu aw mv bi"><span id="12d4" class="lq lr it li b gy mw mx l my mz">console.log(getTime('now'))<br/>console.log(getTime('day'))<br/>console.log(getTime('month'))<br/>console.log(getTime('year'))<br/>console.log(getTime('fullDate'))</span></pre><p id="b882" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要获得我们想要的回报:</p><figure class="mo mp mq mr gt nc gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/c734f9f6bfa9393a22bc3454a8104deb.png" data-original-src="https://miro.medium.com/v2/resize:fit:696/format:webp/1*FTgw8dP0l6ZxxFKPA_kKWw.jpeg"/></div></figure><p id="b833" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">太棒了。</p></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h2 id="e1ef" class="lq lr it bd ls lt lu dn lv lw lx dp ly kr lz ma mb kv mc md me kz mf mg mh mi bi translated">任务完成</h2><p id="65a1" class="pw-post-body-paragraph ki kj it kk b kl mj ju kn ko mk jx kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">对于我们的<code class="fe lf lg lh li b">getTime.js</code>，我们还可以做更多的事情，但我认为这是这个博客的一个很好的停止点。</p><p id="1305" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">函数构造函数非常有用和灵活，通过我们重构<code class="fe lf lg lh li b">getTime.js</code>的方式，我们使用它的结构来构建非常通用的函数构造函数，这些函数构造函数抽象出大量代码，否则我们会重复这些代码(我们将在下一篇关于fetch请求的博客中这样做)。</p><p id="1cae" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我计划的下一篇博客包括一些小的补充，以及如何将<code class="fe lf lg lh li b">getTime.js</code>导入React应用程序的教程。我希望这篇博客是前两篇的后续，我期待在JavaScript函数构造的第4部分中讨论这个主题。</p></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h1 id="ceba" class="oe lr it bd ls of og oh lv oi oj ok ly jz ol ka mb kc om kd me kf on kg mh oo bi translated">JavaScript函数构造</h1><p id="652f" class="pw-post-body-paragraph ki kj it kk b kl mj ju kn ko mk jx kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated"><a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/function-construction-whats-your-function-5a282b81fc62">第1部分</a> | <a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/function-construction-part-2-f6a711075b11">第2部分</a> | <strong class="kk iu">第3部分</strong> | <a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/javascript-function-construction-part-4-d532f0a5e4af">第4部分</a> | <a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/javascript-function-construction-part-5-90733a0e6369">第5部分</a> | <a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/javascript-function-construction-part-6-72cfd6b18a7c">第6部分</a> | <a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/javascript-function-construction-part-7-17c5661e6ea7">第7部分</a></p></div></div>    
</body>
</html>