<html>
<head>
<title>Movie Recommendation System in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的电影推荐系统</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/movie-recommendation-system-in-python-162b4d587c7b?source=collection_archive---------2-----------------------#2020-10-06">https://levelup.gitconnected.com/movie-recommendation-system-in-python-162b4d587c7b?source=collection_archive---------2-----------------------#2020-10-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/f0f83fbf8bc3d793c962013c38e0ec70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yXX1oWQoTanTROGv_b3mig.jpeg"/></div></div></figure><p id="2049" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本文中，我将介绍如何构建一个具有集成图形用户界面的基本电影推荐系统。</p><p id="1e96" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，我们需要数据。为了更好地了解推荐系统的实际表现，我们需要一个相当大的数据集。为此，我们将使用MovieLens 25M数据集，您可以从这里下载:</p><div class="kw kx gp gr ky kz"><a href="https://grouplens.org/datasets/movielens/25m/" rel="noopener  ugc nofollow" target="_blank"><div class="la ab fo"><div class="lb ab lc cl cj ld"><h2 class="bd ir gy z fp le fr fs lf fu fw ip bi translated">MovieLens 25M数据集</h2><div class="lg l"><h3 class="bd b gy z fp le fr fs lf fu fw dk translated">2500万电影收视率。稳定的基准数据集。2500万个评级和100万个标签应用程序适用于…</h3></div><div class="lh l"><p class="bd b dl z fp le fr fs lf fu fw dk translated">grouplens.org</p></div></div><div class="li l"><div class="lj l lk ll lm li ln jw kz"/></div></div></a></div><p id="dfc7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">数据集由六个部分组成。csv文件和解释数据集的自述文件。如果你愿意，请随意看一看。我们将只使用这3:</p><p id="7105" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">movies.csv评级. CSV；tags.csv</p><p id="ed0c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您还没有python库，还需要安装几个python库:</p><p id="47bb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">-numpy<br/>-pandas<br/>-progress(pip安装进度)<br/> -fuzzywuzzy (pip安装fuzzywuzzy &amp; pip安装python-Levenshtein)<br/>-easy GUI</p><p id="5578" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我相信他们都可以pip安装，确切的命令将取决于操作系统。一旦我们安装了数据和库，我们就可以开始了。任何python IDE都可以工作，我用的是Geany，它是Raspbian的一个轻量级IDE。</p><p id="9d58" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">快速浏览数据集:</p><figure class="lp lq lr ls gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lo"><img src="../Images/ff25562d4f8e1747e6ec238520774e20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*706g6F9m94etFSsX3B-hjQ.png"/></div></div><figcaption class="lt lu gj gh gi lv lw bd b be z dk translated">电影. csv</figcaption></figure><p id="ff06" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面我们有movies.csv文件，它有3列，即:movieId、标题和类型。一切都非常方便和直接。我们将使用全部3个。</p><p id="a8e0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是tags.csv文件。在这里，我们将只使用“movieId”和“tag”列，这两个列将标记链接到movieId列，这两个列也可以在movies.csv和ratings.csv中找到</p><figure class="lp lq lr ls gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lo"><img src="../Images/dec41c171f8e5015ab7c1e44221df811.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_zjVFDkivchZD9QbRF4FCA.png"/></div></div><figcaption class="lt lu gj gh gi lv lw bd b be z dk translated">tags.csv</figcaption></figure><p id="13a2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后但同样重要的是，ratings.csv，从这个家伙，我们将使用“电影Id”和“评级”列。</p><figure class="lp lq lr ls gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lo"><img src="../Images/1433c584005042741200343c1e4b15c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n5B3IOY8stn8g4hFi-EcSg.png"/></div></div><figcaption class="lt lu gj gh gi lv lw bd b be z dk translated">评级. csv</figcaption></figure><p id="f69e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">太棒了，现在让我们启动IDE开始吧。</p><p id="13cf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从导入库开始，如下所示。熊猫和numpy在数据科学领域非常有名。据我所知，Fuzzywuzzy、easygui和progress library不太为人所知，但你可能对它们很熟悉。我将在代码中添加大量的注释，尽可能使代码更加清晰。让我们直入主题吧。</p><figure class="lp lq lr ls gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lo"><img src="../Images/05fd9b6e276d7bac69968e19c613cb37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5Ol-3ayAMkaiXkMN0iP_FQ.png"/></div></div></figure><p id="1be6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">除了数据集的初始加载和gui的显示设置之外，该程序将主要由一系列函数组成，GUI将被输入一个numpy数组。如果没有第12行的显示设置…如果推荐系统推荐的电影列表太长，我们会得到一个不太有用的截断表示。</p><p id="a180" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有几种不同的方法可以让显示排序，例如循环遍历数组，将每一行追加到一个初始化为空列表的变量中，但是，这(第12行)是我们将使用的方法。</p><p id="fb2e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第16、17、33和35行基本上是python progress库中进度条的语法。循环只运行一次，并执行其中的代码块。一旦完成，进度条就完成了它的工作。数据集在我的系统上加载大约需要30秒，这就是为什么我们使用进度条来指示数据集在你启动程序后正在加载，如下所示。之后，我们就不必在浏览GUI时再次加载它了。</p><figure class="lp lq lr ls gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lo"><img src="../Images/7919e156b7707426ec5c4fc631513f0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FEdY9JNi3P9fcOmW0BSrsQ.png"/></div></div><figcaption class="lt lu gj gh gi lv lw bd b be z dk translated">数据集加载&amp;图形用户界面的主菜单</figcaption></figure><p id="376c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在循环内部，我们将数据集加载到pandas数据帧中，并对数据进行一些处理，以使其具有更理想的格式。我们首先将电影和收视率数据帧合并成1。评级列有几个NaN值，我们将通过在整个评级列中计算出的平均评级来填充它。由于一些电影有数百个评级，我们希望获得每部电影的平均评级，并按照与电影名称相关联的movieId对它们进行分组。现在我们有了更容易接受的数据，是时候构建函数了。</p><p id="4d46" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第一个函数被称为which_way()</p><p id="5fbb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个函数产生GUI的主菜单，并提示用户做出选择。按类型或标签搜索电影。用户当然也可以按下取消键，根本不搜索电影，这完全由他们决定。</p><figure class="lp lq lr ls gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lo"><img src="../Images/b6acfdeb208a06c975a9bf4f6a640583.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dVxzsy2HhIRHHQUDLcqYgQ.png"/></div></div><figcaption class="lt lu gj gh gi lv lw bd b be z dk translated">哪个方向()</figcaption></figure><p id="55bc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个函数中，我们定义了显示给用户的easygui chiocebox的参数。用户单击的选项的文本(字符串)将被返回并存储在fieldValues变量中。然后，我们有一个条件语句，它根据用户的选择将用户引导到下一个功能/窗口。</p><p id="379c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果用户点击取消，那么程序将会终止。但是，如果用户点击:按类型搜索电影或按标签搜索电影，那么函数genre_entry()或tag_entry()将被调用，一个被称为easygui multenterbox的东西将出现。</p><figure class="lp lq lr ls gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lo"><img src="../Images/5a47a0dd77b68948cc6569f691919832.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3UWjRyPI5f1B1znHo-vmBQ.png"/></div></div></figure><p id="58ef" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如您可以从它的名字推断的那样，如果需要，这个输入框可以接受多个输入。genre_entry()和tag_entry()函数都非常相似，所以我只解释1，但我会在源代码中包含这两个函数。让我们看看tag_entry()。</p><figure class="lp lq lr ls gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lo"><img src="../Images/775d919be5b816bee2501708b468c64c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LPXWRkReWFePGdM_jlZn1g.png"/></div></div></figure><p id="454a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在将显示参数传递给multenterbox之后，我们调用另一个函数来检查用户输入。用户输入将从此field_check函数返回。让我们快速访问这个函数。</p><figure class="lp lq lr ls gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lo"><img src="../Images/ef678075cc27f8f0c2981a062bb129fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mM_yKyDEWDnXYQmOhg1svQ.png"/></div></div></figure><p id="a36a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有时用户输入空白字段，可能是由于错误等。为了控制这种行为并使gui更加可靠，我们需要这样的函数。我在easygui文档页面上找到了这个特定的函数。基本上，只要你输入一个空字段，你就会被告知该字段是必填的，并陷入循环。</p><figure class="lp lq lr ls gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lo"><img src="../Images/a66e993876cd703ba5a58e16106f41ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5FMhHId3DCdn7DJiqh55KA.png"/></div></div></figure><p id="81bb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一旦用户输入内容，文本(字符串)将存储在fieldValues变量中，代码将在tag_entry函数的第114行继续。</p><p id="f4fc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">来自easygui多输入框输入行的用户输入以列表形式返回。按下“取消”按钮时，返回“无”。为了在其他函数中使用这个用户输入，我们需要将变量声明为全局变量。</p><p id="1765" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们现在对从multenterbox返回的用户输入列表进行切片，并将其保存为变量user_input_2。我们只对用户不按cancel时返回的文本感兴趣，因此有条件语句:</p><p id="517a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">" if fieldValues！=无:"</p><p id="8819" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果用户好心地输入一些文本，我们继续使用similarity_test2()函数，它基本上包含了这个推荐系统的主要内容，或者用户返回到主菜单。….similarity _ test1()&amp; similarity _ test2()都非常相似，就像genre_entry &amp; tag_entry共享相似性一样。这里我只涉及similarity_test2()。让我们来看看:</p><figure class="lp lq lr ls gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lo"><img src="../Images/5a8e759e7ce4b291f58d6e9e98f26b5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-nmS7lnh1omk9CkbumvKzQ.png"/></div></div></figure><p id="9805" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如我们所看到的，它采用了一个参数，即tag_entry()函数中的user_input_2变量。还记得我们在tags.csv文件的第19行创建的dataframe吗？因此，首先我们要从tag列中收集所有唯一的标记，并将其存储在一个变量中。</p><p id="8a0e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有许多方法可以利用fuzzywuzzy库，这取决于您想要实现的目标。对于这个应用程序，我们将使用以下语法:“output = process.extract(query，choices)”</p><p id="48e4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我相信你可以在这里传递一个额外的参数来定义计分器的类型。我们将只使用默认语法。基本上fuzzywuzzy所做的是，它使用Levenshtein距离来计算序列之间的差异，并返回满分为100分的分数。</p><p id="f693" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个fuzzywuzzy“process . extract(query，choices)”函数返回分数的方式是在一个列表中，每个字符串及其分数放在括号中，就像so (string，95)作为列表元素。</p><p id="a2d3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在循环遍历整个标签列表并查找针对user_input_2变量的匹配后，我们循环遍历分数列表，只截取90%以上的匹配，并将它们保存在变量“final_2”中。我们将它声明为全局的，这样我们可以在下一个函数中使用它。如果fuzzywuzzy没有为我们找到匹配，它将返回“[]”。所以我们创建了一个条件，如果没有找到匹配，就让用户返回tag_entry()函数再试一次。或者，如果我们有90%以上的匹配，我们现在可以把它们带到下一个名为“tag()”的函数，如下所示:</p><figure class="lp lq lr ls gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lo"><img src="../Images/85700029ecc867ac801fe27958053b39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*44KCaOOpz_togG0_NIdY3Q.png"/></div></div><figcaption class="lt lu gj gh gi lv lw bd b be z dk translated">标签()</figcaption></figure><p id="90d5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们有了&gt; 90%的匹配，我们循环遍历它们，查看“df_tags”数据帧“tag”列的每一行，看看哪些标记与我们从fuzzywuzzy返回的字符串匹配。现在，我们将tag列中的所有tag匹配项以及它们的movieId保存在一个名为“final_1”的变量中。为了清理附加的数据，我们对第一个元素进行切片，并重置数据帧索引。我们现在可以删除名为index的列，并从“movieId”列中删除所有重复项。</p><p id="feea" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了以降序方式首先显示评分最高的电影，我们相应地对数据帧进行排序，并删除评分低于2.5/5.0的所有电影</p><p id="1ebe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们现在可以在数据框的顶部插入一个新行，基本上复制它们上面的列名。这仅用于easygui显示目的。Easygui codebox不太喜欢你给它传递一个pandas dataframe，所以我们需要把它改成一个更合适的格式。</p><p id="d778" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的方法是将数据帧的每一列转换成一个列表，然后使用numpy重组它。好了，现在我们只需用稀薄的空气替换括号，并转到easygui代码框进行显示。就是这样！</p><p id="9e57" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们通过标签搜索电影:“黑客”，看看它返回什么…</p><figure class="lp lq lr ls gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lo"><img src="../Images/d71874c707ff36c003a57ec41959a0e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5_D79vlI97eTEdTlsjnc_g.png"/></div></div></figure><figure class="lp lq lr ls gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lo"><img src="../Images/fa4d61bff334290fce0efd1f2fe33910.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7K474jkj6ai0PZ8B8ZDvIw.png"/></div></div></figure><p id="3ab8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">看起来它正在工作…请随意使用它，如果我在什么地方犯了错误，请告诉我！下面是源代码:</p><pre class="lp lq lr ls gt lx ly lz ma aw mb bi"><span id="7a4d" class="mc md iq ly b gy me mf l mg mh"># Importing necessary libraries <br/>from fuzzywuzzy import fuzz <br/>from fuzzywuzzy import process<br/>from progress.bar import IncrementalBar<br/>from easygui import *<br/>import easygui as gui<br/>import pandas as pd<br/>import numpy as np<br/>import sys</span><span id="e37a" class="mc md iq ly b gy mi mf l mg mh"># maxing out numpy arrray display size for easygui display <br/>np.set_printoptions(threshold=sys.maxsize)</span><span id="3e34" class="mc md iq ly b gy mi mf l mg mh"># as its a relatively big dataset, the initial load will take about 30sec<br/># depending on your pc , thus an indication of loading is appopriate <br/>progress_bar = IncrementalBar('Loading Movie Database...', max=1)<br/>for i in range(1):<br/>    # reading in csv files<br/>    df_tags = pd.read_csv("tags.csv", usecols = [1,2])<br/>    df_movies = pd.read_csv("movies.csv")<br/>    df_ratings = pd.read_csv("ratings.csv", usecols = [1,2])<br/>    <br/>    # merging columns from seperate dataframes into new dataframe<br/>    df_1 = pd.merge(df_movies ,df_ratings, on='movieId', how='outer')<br/>    # filling NaN rating values with mean rating<br/>    df_1['rating'] = df_1['rating'].fillna(df_1['rating'].mean()) <br/>    # gouping df rows by average rating per movie<br/>    df_1 = pd.DataFrame(df_1.groupby('movieId')['rating'].mean().reset_index().round(1))<br/>    # adding title and genres column to df<br/>    df_1['title'] = df_movies['title']<br/>    df_1['genres'] = df_movies['genres']<br/>    <br/>    progress_bar.next()<br/>    # progress bar completion on successful load of dataset <br/>progress_bar.finish()</span><span id="4130" class="mc md iq ly b gy mi mf l mg mh">def which_way():<br/>    '''<br/>    First function of program which gets executed when running the program. <br/>    This functions as a cross roads, either you choose to search movies by<br/>    tag or by genre. Based on user choice, user gets directed to next window.<br/>    <br/>    '''<br/>    <br/>    # defining easygui choicebox parameters<br/>    msg = "Choose an option:"<br/>    title = "Main Menu"<br/>    choices = ["Search recommended movies by genre:","Search recommended movies by tag:"]<br/>    fieldValues = choicebox(msg,title, choices)<br/>    <br/>    # fieldValues variable is the user input which gets returned from the gui<br/>    # conditional statement to guide user to the next interface based on input<br/>    if fieldValues == "Search recommended movies by genre:":<br/>        genre_entry()<br/>    <br/>    elif fieldValues == "Search recommended movies by tag:":<br/>        tag_entry()</span><span id="e541" class="mc md iq ly b gy mi mf l mg mh">def field_check(msg, title, fieldNames):<br/>    '''<br/>    This function checks for missing user input values in the multienterbox<br/>    and returns the user input as fieldValues variable<br/>    <br/>    Parameters:<br/>    <br/>    msg, title and fieldnames of the multi-enterbox GUI<br/>    <br/>    '''<br/>    <br/>    fieldValues = multenterbox(msg, title, fieldNames)<br/>    <br/>    # Loop with conditionals to make sure that none of the user input <br/>    # fields are left blank<br/>    while 1:<br/>        if fieldValues is None: break<br/>        errmsg = ""<br/>        for i in range(len(fieldNames)):<br/>            if fieldValues[i].strip() == "":<br/>                errmsg += ('"%s" is a required field.\n\n' % fieldNames[i])<br/>        if errmsg == "":<br/>            break # if no empty fields found, proceed with next codeblock<br/>        # Saving user input as list in fieldValues variable<br/>        fieldValues = multenterbox(errmsg, title, fieldNames, fieldValues)<br/>    <br/>    return fieldValues</span><span id="a620" class="mc md iq ly b gy mi mf l mg mh">def tag_entry():<br/>    ''' <br/>    This function defines the easygui multenterbox parameters and calls<br/>    on the field_check functions, if field/user input is retrieved function<br/>    calls on similarity test and if a match is not found user gets returned <br/>    to the same window  <br/>    '''<br/>    <br/>    # defining easygui multenterbox parameters<br/>    msg = "Enter movie tag for example: world war 2 | brad pitt | documentary \nIf tag not found you will be returned to this window"<br/>    title = 'Search by tag'                        <br/>    fieldNames = ["Tag"]<br/>    <br/>    # calling on field_check() to check for missing user input and to<br/>    # save user input as fieldValues variable<br/>    fieldValues = field_check(msg, title, fieldNames)<br/>    <br/>    # If user input is not empty, slice list element and save in variable<br/>    if fieldValues != None:<br/>        global user_input_2<br/>        user_input_2 = fieldValues[0]<br/>        <br/>        # here we call on a function which basically tests for string<br/>        # similarity. if user press cancel, user gets returned to main menu <br/>        similarity_test2(user_input_2)<br/>    else:<br/>        which_way()</span><span id="7dd4" class="mc md iq ly b gy mi mf l mg mh">def tag():<br/>    '''<br/>    This function adds all tag-matched movies to pandas dataframe,<br/>    alter the dataframe for correct easygui display by dropping some <br/>    columns, resetting df index, merging df's and sorting movies to display<br/>    only movies rated &gt;= 2.5 , it also casts the final df columns to lists<br/>    and rearrange them in a numpy array for easygui display.  <br/>    '''<br/>    <br/>    # append tag matched movies as dataframe object<br/>    final_1 = []<br/>    for i in final_2:<br/>        final_1.append(df_tags.loc[df_tags['tag'].isin(i)])<br/>    <br/>    # reset df index, drop index column as well as duplicate entries<br/>    lst = final_1[0]<br/>    lst = lst.reset_index()<br/>    lst.drop('index', axis=1, inplace=True)<br/>    lst = lst.drop_duplicates(subset='movieId')</span><span id="38a2" class="mc md iq ly b gy mi mf l mg mh"># merge movieId with movie names and genres + drop tag and movieId column<br/>    df = pd.merge(lst, df_1, on='movieId', how='left')<br/>    df.drop('tag', axis=1, inplace=True)<br/>    df.drop('movieId', axis=1, inplace=True)</span><span id="01db" class="mc md iq ly b gy mi mf l mg mh"># sort movies by ratings, display only movies rated above or = 2.5 rating<br/>    data = df.sort_values(by='rating', ascending=False)<br/>    data = data[data['rating'] &gt;= 2.5]<br/>    heading = [] # add column names as first dataframe row for easygui display<br/>    heading.insert(0, {'rating': 'Rating', 'title': '----------Title',<br/>     'genres': '----------Genre'})<br/>    data = pd.concat([pd.DataFrame(heading), data], ignore_index=True, sort=True)<br/>    <br/>    # casting dataframe columns to lists<br/>    rating = data['rating'].tolist()<br/>    title = data['title'].tolist()<br/>    genres = data['genres'].tolist()<br/>    <br/>    # compiling numpy array from dataframe column lists for easygui display<br/>    data = np.concatenate([np.array(i)[:,None] for i in [rating,title,genres]], axis=1)<br/>    data = str(data).replace('[','').replace(']','')<br/>    <br/>    # displaying matched movies to user<br/>    gui.codebox(msg='Movies filtered by tag returned from database:',<br/>    text=(data),title='Movies')<br/>    <br/>    which_way()</span><span id="83e8" class="mc md iq ly b gy mi mf l mg mh">def genre_entry():<br/>    ''' <br/>    This function defines the easygui multenterbox parameters and calls<br/>    on the field_check functions, if field/user input is retrieved function<br/>    calls on similarity test and if a match is not found user gets returned <br/>    to the same window  <br/>    '''<br/>    # defining easygui multenterbox parameters<br/>    msg = "Enter movie genre for example: mystery | action comedy | war \nIf genre not found you will be returned to this window"<br/>    title = "Search by genre"<br/>    fieldNames = ["Genre"]<br/>    <br/>    # calling on field_check() to check for missing user input and to<br/>    # save user input as fieldValues variable<br/>    fieldValues = field_check(msg, title, fieldNames)<br/>    <br/>    # If user input is not empty, slice list element and save in variable<br/>    if fieldValues != None:<br/>        global user_input<br/>        user_input = fieldValues[0]<br/>        <br/>    # here we call on a function which basically tests for string<br/>    # similarity. if user press cancel, user gets returned to main menu <br/>        similarity_test1(user_input)<br/>    else:<br/>        which_way()</span><span id="4bcf" class="mc md iq ly b gy mi mf l mg mh">def genre():<br/>    '''<br/>    This function adds all genre-matched movies to pandas dataframe,<br/>    alter the dataframe for correct easygui display by dropping some <br/>    columns, resetting df index, merging df's and sorting movies to display<br/>    only movies rated &gt;= 2.5 , it also casts the final df columns to lists<br/>    and rearrange them in a numpy array for easygui display.  <br/>    '''<br/>    <br/>    # append genre matched movies as dataframe object<br/>    final_1 = []<br/>    for i in final:<br/>        final_1.append(df_movies.loc[df_movies['genres'].isin(i)])<br/>    <br/>    # reset df index, drop index columns as well as duplicate entries<br/>    lst = final_1[0]<br/>    lst = lst.reset_index()<br/>    lst.drop('index', axis=1, inplace=True)<br/>    lst.drop('title', axis=1, inplace=True)<br/>    lst.drop('genres', axis=1, inplace=True)<br/>    lst = lst.drop_duplicates(subset='movieId')<br/>    <br/>    # merge movieId with movie names, rating and genres + drop index, title and genres column<br/>    df = pd.merge(lst, df_1, on='movieId', how='left')<br/>    <br/>    # sort movies by ratings, display only movies rated above or = 2.5 rating<br/>    data = df.sort_values(by='rating', ascending=False)<br/>    data.drop('movieId', axis=1, inplace=True)<br/>    data = data[data['rating'] &gt;= 2.5]<br/>    heading = [] # add column names as first dataframe row for easygui display<br/>    heading.insert(0, {'rating': 'Rating', 'title': '----------Title',<br/>     'genres': '----------Genre'})<br/>    data = pd.concat([pd.DataFrame(heading), data], ignore_index=True, sort=True)<br/>    <br/>    # casting dataframe columns to lists<br/>    rating = data['rating'].tolist()<br/>    title = data['title'].tolist()<br/>    genres = data['genres'].tolist()<br/>    <br/>    # compiling numpy array from dataframe column lists for easygui display<br/>    data = np.concatenate([np.array(i)[:,None] for i in [rating,title,genres]], axis=1)<br/>    data = str(data).replace('[','').replace(']','')<br/>    <br/>    # displaying matched movies to user<br/>    gui.codebox(msg='Movies filtered by genre returned from database:',<br/>    text=(data),title='Movies')<br/>    <br/>    which_way()</span><span id="9649" class="mc md iq ly b gy mi mf l mg mh">def similarity_test1(user_input):<br/>    '''<br/>    This function tests for string similarity by matching user input<br/>    to movies genres, match/es &gt; 90% gets saved in variable which<br/>    then gets passed on to genre function for database match and<br/>    return unless no match is found<br/>    '''<br/>    # saving movie genre/s as test base and user input to test for <br/>    genre_list = df_movies['genres'].unique()<br/>    query = user_input<br/>    choices = genre_list <br/>    # here fuzzywuzzy does its magic to test for similarity<br/>    output = process.extract(query, choices)<br/>    <br/>    # saving returned matches in variable and passing it on to next function<br/>    global final<br/>    final = [i for i in output if i[1] &gt; 90]<br/>    <br/>    # if no match of &gt; 90%  is found, return to genre entry window for retry<br/>    if final == []:<br/>        genre_entry()<br/>    else:<br/>        genre()</span><span id="8a98" class="mc md iq ly b gy mi mf l mg mh">def similarity_test2(user_input_2):<br/>    '''<br/>    This function tests for string similarity by matching user input<br/>    to movie tags, match/es &gt; 90% gets saved in variable which<br/>    then gets passed on to tag function for database match and<br/>    return unless no match is found<br/>    '''<br/>    # saving movie tag as test base and user input to test for<br/>    tag_list = df_tags['tag'].unique()<br/>    query = user_input_2<br/>    choices = tag_list <br/>    # here fuzzywuzzy does its magic to test for similarity<br/>    output = process.extract(query, choices)<br/>    <br/>    # saving returned matches in variable and passing it on to next function<br/>    global final_2<br/>    final_2 = [i for i in output if i[1] &gt; 90]<br/>    <br/>    # if no match of &gt; 90%  is found, return to tag entry window for retry<br/>    if final_2 == []:<br/>        tag_entry()<br/>    else:<br/>        tag()</span><span id="0c02" class="mc md iq ly b gy mi mf l mg mh">if __name__ == '__main__':<br/>    which_way()</span></pre></div></div>    
</body>
</html>