# 编码问题:Go 中排序的正方形数组

> 原文：<https://levelup.gitconnected.com/coding-problem-sorted-squared-array-in-go-b6880ee409a6>

学习两种解决方案，编写表驱动测试！

![](img/dac3242033bc1bab981c5586250228bf.png)

BO1982 */* 伊斯托克

我认为软件工程师日常练习编码面试问题**是一个很好的练习**。它们不仅能让你的计算机科学基础保持敏锐，而且还能挑战你的大脑，让你在需要或想要寻找新工作机会时有所准备。当我自己练习这些编码问题时，我想标准化这些方法并在我的博客上分享这些步骤。

在这个编码问题中，我们将使用我最喜欢的编程语言——Go 来解决排序平方数组。我们将把这个问题分成三个独立的部分:第一步，了解问题，写下一些例子。下一步是编写测试(hello TDD)，最后一步是为我们的测试编写解决方案！

> 能够理解编码问题、编写测试和开发最佳解决方案鼓励你成为一名全面的软件工程师。

我们开始吧！

# 了解排序的方形数组

这是一个初学者级别的编码问题，输入一个排序的数组，输出该数组的平方值，也是排序的。您可能会想到这样一个简单的例子:

```
Input:  [0, 1, 2, 3]
Output: [0, 1, 4, 9]
```

好的，**但是不要操之过急**。这里一个常见的错误是忘记了输入数组中的负值。当你平方一个数时，结果总是正的。输入数字的绝对值*决定输出数字的大小。因此，非常小但为负的输入数字会变成非常大但为正的输出数字。这是另一个例子:*

```
Input:  [-5, -1, 2, 4]
Output: [1, 4, 16, 25]
```

这里最小的输入值`-5`变成了最大的输出值`25`。本质上，输入值离零越远，输出数就越大。当我们在本文后面开始实际解决这个问题时，这是一个重要的细节。

# 写作测试

有些人可能会说，编写测试应该在你写完解决方案之后，但是我更喜欢尽可能地实践测试驱动开发(TDD)。它不仅能给你手头的问题一个更清晰的定义，而且写一个通过你已有的测试的解决方案是一件令人满意的事情。

谢天谢地，在编写测试时，Go 非常棒。你可以使用 Go 中的**表驱动测试**为一个方法编写多个测试用例。首先，让我们为测试提供一些输入和结果输出的例子。我认为最好想出最简单的例子，然后沿着逻辑链往上走。

```
----- Example 1 -----
Input:  []
Output: []
----- Example 2 -----
Input:  [0]
Output: [0]
----- Example 3 -----
Input:  [0,1,3]
Output: [0,1,9]
----- Example 4 -----
Input:  [-2,-1]
Output: [1,4]
----- Example 5 -----
Input:  [-4, 2, 6]
Output: [4, 16, 36]
```

现在让我们在 Go 中编写一些实际的测试。我将跳过这些教程中的项目设置，因为它太花时间了。您只需要两个文件，一个保存您的代码逻辑，另一个保存测试。包含代码逻辑的第一个文件应该只包含函数的基本结构:

好了，现在让我们来分解测试。我们创建函数`TestSortedSquaredArray()`，它接受对`*testing.T`的引用。这告诉 Go 我们想要运行这个函数来测试同一个`sorting`包中的另一个文件中的`SortedSquaredArray()`。

表格驱动测试灵活方便。第一步是创建一个名为`testCases`的结构，它有三个字段`name`、`input`和`expectedResult`，其中后两个都是整数数组类型。

然后，我们打开一对新的括号`{}`，以*测试用例*作为第 14–18 行的例子。在这里，我们可以指定单个`testCases`结构的具体值。正如你所看到的，我们的第一个测试用例验证了如果`input`是一个空数组`[]int{}`，那么`expectedResult`也应该是一个空数组`[]int{}`。

但是这些测试用例是如何运行的呢？一旦我们完成了测试用例结构的定义，我们在第 41 行开始一个`for`循环，在`testCases`之上`ranges`。对于循环的每一次迭代，我们将一个单独的测试用例定义为`tc`，并将其设置为等于我们正在进行的当前测试`testCase[i]`。

接下来我们调用`t.Run()`，它将来自当前测试用例的`property`以及`func(t *testing.T)`作为参数，让我们知道我们想要运行一个实际的测试。在`t.Run()`中，我们可以调用`t.Parallel()`来提高性能，我们所有的测试将同时执行。

最后，通过将`tc.input`作为参数传递并将返回值存储到`actualResult`中，我们可以从`SortedSquaredArray()`获得输出。然后我们可以通过使用`assert.Equal()`将`actualResult`与当前测试用例`expectedResult`进行比较，T5 也将测试对象`t`作为输入。

唷！希望这有意义。我们现在可以使用下面的命令运行我们的测试。

```
$ go test *.go
--- FAIL: TestSortedSquaredArray (0.00s)
    --- FAIL: TestSortedSquaredArray/array_with_negative_values (0.00s)
        example_test.go:48: 
                Error Trace:    example_test.go:48
                Error:          Not equal: 
                                expected: []int{}
                                actual  : []int{1, 4}

                                Diff:
                                --- Expected
                                +++ Actual
                                @@ -1,2 +1,4 @@
                                -([]int) {
                                +([]int) (len=2) {
                                + (int) 1,
                                + (int) 4
                                 }
                Test:           TestSortedSquaredArray/array_with_negative_values
    --- FAIL: TestSortedSquaredArray/array_with_single_value (0.00s)
        example_test.go:48:
.....
```

我们实际上可以看到 4/5 的测试失败了，但是我们能够成功地通过空数组的第一个测试。现在我们已经有了测试，让我们继续我们的解决方案！

# 解决方案#1 — O(NlogN)时间，O(N)空间

像往常一样，让我们看看暴力解决方案开始。假设我们不能改变输入数组，我们需要首先为`result`数组分配内存。我们可以使用`make()`函数来实现，其中第一个参数表示我们想要一个整数数组`[]int`，第二个参数是我们想要的数组的大小`len(array)`。

然后，我们复制输入`array`中每个元素的平方值并存储到`result`数组中。我们可以简单地调用`sort.Ints(result)`对`result`数组中的平方值进行排序，然后返回。

由于排序算法的时间通常为 O(NlogN ),而 for 循环只覆盖数组的 N 个元素，因此我们的时间复杂度为 O(NlogN ),空间复杂度为 O(N ),因为我们必须创建一个与输入数组大小相同的新数组。

如果我们再次运行我们的测试，我们看到我们通过了所有的测试。

```
$ go test *.go
ok      command-line-arguments  0.301s
```

# 解决方案 2 — O(N)时间，O(N)空间

下一个解决方案依赖于这个问题的原理。正值或负值从零进一步增长会发生什么？平方结果变得越来越大。所以我们真正关心的是输入数组中每个元素的*绝对值*。

**记住，输入数组已经排序**——所以我们可以通过让索引从数组的开头和结尾开始来跟踪输入`array`中的最小绝对值和最大绝对值。然后，我们可以迭代地检查哪个索引代表输入数组中较大的绝对值。

如果最右边的值大于，我们选择它作为下一个要平方的值，并复制到`result`数组中。如果最左边的值更大，那么我们选择存储那个值。然后，我们将分别递增或递减最左边和最右边的索引。

此外，我们可以编写一个助手方法`abs()`，它返回一个整数的绝对值。最终的代码如下所示:

这改进了我们的时间复杂度，因为我们从不检查输入数组中的 N 个以上的元素。因此，最终的时间复杂度是 O(N ),空间复杂度仍然是 O(N ),因为我们没有任何改进。

如果我们再次运行我们的测试，我们仍然通过所有的测试。

```
$ go test *.go
ok      command-line-arguments  0.301s
```

我希望你喜欢阅读这篇文章，并能够学到一些新的东西。我计划继续写关于常见编码面试问题的教程，所以如果你有任何提示或建议，请在下面留下评论！感谢阅读。