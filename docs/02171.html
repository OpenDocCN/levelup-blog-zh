<html>
<head>
<title>Create Pipeline to Push Docker Image to ECR and Deploy a Containerised App to Elastic Beanstalk</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">创建将Docker映像推送到ECR的管道，并将一个集装箱化的应用程序部署到Elastic Beanstalk</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/create-pipeline-to-push-docker-image-to-ecr-deploy-containerised-app-to-elastic-beanstalk-e721af796f33?source=collection_archive---------2-----------------------#2020-02-24">https://levelup.gitconnected.com/create-pipeline-to-push-docker-image-to-ecr-deploy-containerised-app-to-elastic-beanstalk-e721af796f33?source=collection_archive---------2-----------------------#2020-02-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/7e7126e5fd1f5ca5b36cd2605a81eeca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SfrC_dDxgQr2y7QGr9nOcw.png"/></div></div></figure><p id="2a19" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我最近<a class="ae kz" rel="noopener ugc nofollow" target="_blank" href="/build-test-deploy-node-js-app-with-codecommit-codepipeline-codebuild-elastic-beanstalk-c6d89f971ef2">发表了一篇关于使用AWS工具创建CI/CD管道以简化Node.js应用程序交付的文章</a>。如果你已经通读了它，我希望它有助于你熟悉这些有用的服务，即代码提交、代码构建和代码管道。CodeCommit不一定是一个CI/CD工具，但非常适合这个空间或讨论，因为它是一个提供通过我们管道的源代码的服务。</p><p id="5ecd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在本文中，我将再次使用这些服务，包括用于部署的Elastic Beanstalk，但这一次我将交付一个容器化的应用程序。正如我通常所做的那样，我们将部署的实际应用程序将是最基本的，因为这不是本文的重点。我们将使用的另一个AWS服务是ECR(弹性容器注册)。ECR本质上相当于AWS的<a class="ae kz" href="https://hub.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker Hub </a>，除了它是一个专有的Docker图像库，而<a class="ae kz" href="https://hub.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker Hub </a>允许你存储公共图像。</p><p id="06c6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这篇文章的目的是演示如何创建一个管道，允许您构建和测试应用程序的Docker映像，如果它成功地通过了构建阶段，就将它推送到ECR。之后，我们的容器化应用程序将被部署到Elastic Beanstalk。</p><p id="8559" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后一点，本文假设您对Docker有所了解，并且能够熟练使用CLI在本地构建映像和运行容器。</p><p id="145d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你喜欢这篇文章，请在这里给我买杯咖啡<a class="ae kz" href="https://www.buymeacoffee.com/lukemwila" rel="noopener ugc nofollow" target="_blank">☕️</a>😃。</p><h1 id="9b41" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">AWS服务快速概述</h1><figure class="lz ma mb mc gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ly"><img src="../Images/f39ab654462dda4569ff20bfa60db1b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*53HR1o6bjbu_2TPgAiPS6Q.png"/></div></div><figcaption class="md me gj gh gi mf mg bd b be z dk translated">亚马逊网络服务</figcaption></figure><h2 id="f928" class="mh lb it bd lc mi mj dn lg mk ml dp lk km mm mn lo kq mo mp ls ku mq mr lw ms bi translated">代码提交</h2><p id="c55e" class="pw-post-body-paragraph kb kc it kd b ke mt kg kh ki mu kk kl km mv ko kp kq mw ks kt ku mx kw kx ky im bi translated">这是一个像GitHub和Bitbucket一样的源代码控制服务，它允许你托管基于git的存储库(仅限私有存储库)。</p><h2 id="1eae" class="mh lb it bd lc mi mj dn lg mk ml dp lk km mm mn lo kq mo mp ls ku mq mr lw ms bi translated">electroniccashregister电子现金出纳机</h2><p id="714a" class="pw-post-body-paragraph kb kc it kd b ke mt kg kh ki mu kk kl km mv ko kp kq mw ks kt ku mx kw kx ky im bi translated">如上所述，它是一个私有的Docker图像库。具体来说，它是一个完全托管的Docker容器注册中心，使开发人员可以轻松地存储、管理和部署Docker容器映像。</p><h2 id="fc29" class="mh lb it bd lc mi mj dn lg mk ml dp lk km mm mn lo kq mo mp ls ku mq mr lw ms bi translated">代码构建</h2><p id="0966" class="pw-post-body-paragraph kb kc it kd b ke mt kg kh ki mu kk kl km mv ko kp kq mw ks kt ku mx kw kx ky im bi translated">这是一个CI(持续集成)服务，它编译源代码，运行测试，并生成可以部署的软件包。</p><h2 id="b3e1" class="mh lb it bd lc mi mj dn lg mk ml dp lk km mm mn lo kq mo mp ls ku mq mr lw ms bi translated">代码管道</h2><p id="193f" class="pw-post-body-paragraph kb kc it kd b ke mt kg kh ki mu kk kl km mv ko kp kq mw ks kt ku mx kw kx ky im bi translated">这是一项CD(连续交付)服务，允许我们自动化整个部署和发布周期。</p><h2 id="61f8" class="mh lb it bd lc mi mj dn lg mk ml dp lk km mm mn lo kq mo mp ls ku mq mr lw ms bi translated">弹性豆茎</h2><p id="004b" class="pw-post-body-paragraph kb kc it kd b ke mt kg kh ki mu kk kl km mv ko kp kq mw ks kt ku mx kw kx ky im bi translated">这是一种编排服务，通过编排各种AWS服务来安全、可预测地部署应用程序。</p><p id="0ef8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将手动(或使用基于点击的方法)构建我们的管道，而不是通过使用CloudFormation或Terraform的IaC(基础设施即代码)方法自动构建。这确实是一个有点乏味的过程，但我认为如果你只是被介绍到这些服务中，从长远来看，它可以很好地为你服务。然而，我确实打算发布关于用上述(CloudFormation和Terraform)自动化这个过程的帖子，但是现在，你必须满足于使用好的旧AWS控制台。</p><h1 id="640c" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">我们的代码提交库</h1><figure class="lz ma mb mc gt ju gh gi paragraph-image"><div class="gh gi my"><img src="../Images/b1388644080d40608facc4857b0dab6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/1*oMQnSfELxlg4Ep791s-oVQ.png"/></div></figure><p id="4223" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">正如我已经提到的，我将使用<a class="ae kz" href="https://aws.amazon.com/codecommit/" rel="noopener ugc nofollow" target="_blank"> AWS CodeCommit </a>作为该项目的源代码库，以及我们的管道将用来构建和部署我们的应用程序的源代码。CodeCommit存储库是私有的，因此只能由IAM策略和组中设置的用户访问。然而，源代码也可以在一个公共的GitHub存储库中获得。</p><p id="8ae8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这些是我们将要遵循的简单步骤:</p><h2 id="6c3f" class="mh lb it bd lc mi mj dn lg mk ml dp lk km mm mn lo kq mo mp ls ku mq mr lw ms bi translated">步骤1:创建存储库</h2><p id="76fc" class="pw-post-body-paragraph kb kc it kd b ke mt kg kh ki mu kk kl km mv ko kp kq mw ks kt ku mx kw kx ky im bi translated">使用IAM登录到AWS控制台，然后转到CodeCommit。记住，根据你所在的地区，检查你是否在适当的地区创建了回购。接下来的步骤非常简单，所以您可以直接完成呈现给您的表单。</p><p id="00a3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我已经把我的库叫做<strong class="kd iu"> dockerized-nginx-react </strong>。</p><h2 id="9457" class="mh lb it bd lc mi mj dn lg mk ml dp lk km mm mn lo kq mo mp ls ku mq mr lw ms bi translated">步骤2:为IAM帐户上的CodeCommit生成Git凭据</h2><p id="f8f0" class="pw-post-body-paragraph kb kc it kd b ke mt kg kh ki mu kk kl km mv ko kp kq mw ks kt ku mx kw kx ky im bi translated">一旦您创建了repo，您应该能够在CodeCommit上的repositories下面看到它。但是，您还不能克隆它(除非您已经获得了IAM帐户的Git凭证)。接下来，转到IAM，创建或选择您希望向其提供凭据的用户。在选中的用户上，点击安全凭证选项卡，滚动到标题为“<strong class="kd iu">AWS代码提交的HTTPS Git凭证</strong>”的部分。</p><p id="c138" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">点击<strong class="kd iu">生成凭证</strong>并将凭证保存在安全的地方🔒。</p><h2 id="f367" class="mh lb it bd lc mi mj dn lg mk ml dp lk km mm mn lo kq mo mp ls ku mq mr lw ms bi translated">步骤3:克隆创建的回购协议</h2><p id="e664" class="pw-post-body-paragraph kb kc it kd b ke mt kg kh ki mu kk kl km mv ko kp kq mw ks kt ku mx kw kx ky im bi translated">获得IAM用户的Git凭证后，返回CodeCommit并单击您几分钟前创建的存储库。在那里，使用CLI将repo克隆到您机器上的本地目录中。然后会提示您输入用户名和密码，请确保使用为您选择的IAM用户生成的Git凭据，而不是您的AWS控制台凭据。</p><p id="5efb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这应该会成功地将<strong class="kd iu"> dockerized-nginx-react </strong>库克隆到您的机器上。</p><h1 id="5ea4" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">我们的ECR存储库</h1><figure class="lz ma mb mc gt ju gh gi paragraph-image"><div class="gh gi my"><img src="../Images/5fd70be950b10f7b4446edcb80b20e86.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/1*6mSQVht24ahl_B_CWezTxw.png"/></div></figure><p id="b9a8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，转到AWS控制台中的ECR(弹性容器注册中心),创建一个存储库来存储您的图像。您会注意到，您正在创建的存储库的名称空间将以您的<strong class="kd iu"> AWS帐户ID </strong>为前缀，并且还应该包含存储您的存储库的<strong class="kd iu">区域</strong>。确保在过渡期间将这些值保存在安全的地方，因为稍后我们将在我们的<em class="mz"> buildspec </em>文件中使用它们。</p><p id="e91b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe na nb nc nd b"><strong class="kd iu">AWS_ACCOUNT_ID</strong>.dkr.ecr.<strong class="kd iu">AWS_REGION</strong>.amazonaws.com/<strong class="kd iu">REPO_NAME</strong></code></p><h1 id="5744" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">我们的备案申请</h1><figure class="lz ma mb mc gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ne"><img src="../Images/50f6bcd1e66d413bc0dc1a46708cd733.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t-MbgtyLlYGbidjYX6GIsg.png"/></div></div></figure><p id="c4be" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这一次，我们不打算部署Node.js应用程序，而是部署dockerized React应用程序。我通常使用<em class="mz"> create-react-app </em>来初始化我的react应用程序，所以请转到您从CodeCommit克隆到您的机器上的空git存储库，并运行以下命令(假设您已经安装了相关的CLI):</p><pre class="lz ma mb mc gt nf nd ng nh aw ni bi"><span id="09a5" class="mh lb it nd b gy nj nk l nl nm">npx create-react-app .<br/>Or create-react-app .</span></pre><p id="167c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我通常把<em class="mz"> yarn </em>换成<em class="mz"> npm </em>作为我的包管理器，所以我假设你在这种情况下也会这么做。React应用程序安装完成后，您可以继续运行<em class="mz"> npm start </em>来确保一切正常运行。如果你愿意，可以随意修改这个应用程序。我将有两个Docker文件，一个配置用于开发环境以及管道构建阶段的测试目的，另一个用于生产级容器。两者之间的主要区别是后者将是一个多阶段的Docker文件，它将有一个<a class="ae kz" href="https://www.nginx.com/" rel="noopener ugc nofollow" target="_blank"> nginx </a>网络服务器来服务我们的网站内容。</p><p id="e3db" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面是我的两个Docker文件，你可以继续测试它们的构建和运行。</p><p id="5586" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> Dockerfile.dev </strong></p><pre class="lz ma mb mc gt nf nd ng nh aw ni bi"><span id="4f91" class="mh lb it nd b gy nj nk l nl nm">FROM node:alpine</span><span id="fceb" class="mh lb it nd b gy nn nk l nl nm">WORKDIR '/app'</span><span id="5c12" class="mh lb it nd b gy nn nk l nl nm">COPY package.json .<br/>RUN npm install</span><span id="c277" class="mh lb it nd b gy nn nk l nl nm">COPY . .</span><span id="336e" class="mh lb it nd b gy nn nk l nl nm">CMD ["npm", "run", "start"]</span></pre><p id="f56a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> Dockerfile </strong></p><pre class="lz ma mb mc gt nf nd ng nh aw ni bi"><span id="946f" class="mh lb it nd b gy nj nk l nl nm">FROM node:alpine as build <br/>WORKDIR /app<br/>COPY package*.json ./<br/>RUN npm install <br/>COPY . .<br/>RUN npm run build</span><span id="2843" class="mh lb it nd b gy nn nk l nl nm">FROM nginx <br/>EXPOSE 80<br/>COPY --from=build /app/build /usr/share/nginx/html</span></pre><p id="ec77" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">要构建开发docker映像:</p><p id="f37f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe na nb nc nd b">docker build -t <strong class="kd iu">yourImageTag</strong> -f Dockerfile.dev .</code></p><p id="2111" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">要构建prod docker映像:</p><p id="209a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe na nb nc nd b">docker build -t <strong class="kd iu">yourImageTag</strong> .</code></p><p id="62f8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">要启动和运行容器并设置端口转发:</p><p id="af16" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe na nb nc nd b">docker run -d -p 3000:3000 <strong class="kd iu">yourImageTag</strong></code></p><p id="3bfd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">要访问正在运行的容器:</p><p id="5441" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe na nb nc nd b">docker exec -it <strong class="kd iu">containerId</strong> bash</code>或<code class="fe na nb nc nd b">docker exec -it <strong class="kd iu">containerId</strong> sh</code></p><p id="0a2e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一旦进入React app容器，就可以运行<em class="mz"> npm运行测试</em>。</p><p id="8581" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们的nginx服务器默认监听端口80，所以当您测试Dockerfile映像(产品)的容器实例时，请记住这一点。</p><p id="2e77" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一旦完成，我们就可以转移到<strong class="kd iu"> buildspec.yml </strong>文件。正如我在以前的帖子中提到的，这个文件将指定代表CodeBuild在构建的每个阶段运行的命令的阶段。你可以在这里阅读关于buildspec文件<a class="ae kz" href="https://docs.aws.amazon.com/codebuild/latest/userguide/build-spec-ref.html" rel="noopener ugc nofollow" target="_blank">的更多细节。</a></p><p id="264f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="mz">安装</em>:安装构建<br/> <em class="mz"> pre_build </em>可能需要的依赖项:构建<br/> <em class="mz"> build </em>之前要执行的最终命令:实际构建命令<br/> <em class="mz"> post_build </em>:收尾工作</p><p id="2495" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我们的buildspec文件中，我们希望执行以下操作:</p><ul class=""><li id="1594" class="no np it kd b ke kf ki kj km nq kq nr ku ns ky nt nu nv nw bi translated">登录到ECR</li><li id="f7d5" class="no np it kd b ke nx ki ny km nz kq oa ku ob ky nt nu nv nw bi translated">构建我们的Dockerfile.dev映像，从中创建一个实例(容器)并运行测试</li><li id="4600" class="no np it kd b ke nx ki ny km nz kq oa ku ob ky nt nu nv nw bi translated">从Dockerfile构建生产级映像并推送到ECR</li></ul><p id="6baf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> buildspec.yml </strong></p><pre class="lz ma mb mc gt nf nd ng nh aw ni bi"><span id="0f47" class="mh lb it nd b gy nj nk l nl nm">version: 0.2<br/>phases:<br/>  install:<br/>    runtime-versions:<br/>      docker: 18<br/>  pre_build:<br/>    commands:<br/>      - echo Logging in to Amazon ECR...<br/>      - $(aws ecr get-login --no-include-email --region $AWS_DEFAULT_REGION)<br/>  build:<br/>    commands:<br/>      - echo Build started on `date`<br/>      - echo Building Docker test image...<br/>      - docker build -t $IMAGE_REPO_NAME:$TEST_IMAGE_TAG -f Dockerfile.dev .<br/>      - docker run -e CI=true $IMAGE_REPO_NAME:$TEST_IMAGE_TAG npm run test<br/>      - echo Build started on `date`<br/>      - echo Building the Docker image...<br/>      - docker build -t $IMAGE_REPO_NAME:$IMAGE_TAG .<br/>      - docker tag $IMAGE_REPO_NAME:$IMAGE_TAG $AWS_ACCOUNT_ID.dkr.ecr.$AWS_DEFAULT_REGION.amazonaws.com/$IMAGE_REPO_NAME:$IMAGE_TAG<br/>  post_build:<br/>    commands:<br/>      - echo Build completed on `date`<br/>      - echo Pushing the Docker image...<br/>      - docker push $AWS_ACCOUNT_ID.dkr.ecr.$AWS_DEFAULT_REGION.amazonaws.com/$IMAGE_REPO_NAME:$IMAGE_TAG</span></pre><p id="ce4a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这就把应用方面的事情都做完了。在我们继续在控制台中创建CodeBuild项目之前，请确保将您的更改提交到您的存储库的主分支。</p><pre class="lz ma mb mc gt nf nd ng nh aw ni bi"><span id="9703" class="mh lb it nd b gy nj nk l nl nm">$ git add .<br/>$ git commit -m "type: commit message"<br/>$ git push -u origin master</span></pre><h1 id="5930" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">我们的代码构建项目</h1><p id="059e" class="pw-post-body-paragraph kb kc it kd b ke mt kg kh ki mu kk kl km mv ko kp kq mw ks kt ku mx kw kx ky im bi translated">这一步非常简单。前往CodeBuild并点击“创建项目”。为项目命名，也可以选择描述。欢迎您继续进行自己的环境配置，只是要确保将AWS CodeCommit设置为源代码提供者。CodeBuild项目的其他设置如下:</p><ul class=""><li id="a167" class="no np it kd b ke kf ki kj km nq kq nr ku ns ky nt nu nv nw bi translated">环境映像—托管映像</li><li id="18a7" class="no np it kd b ke nx ki ny km nz kq oa ku ob ky nt nu nv nw bi translated">操作系统— Ubuntu</li><li id="6546" class="no np it kd b ke nx ki ny km nz kq oa ku ob ky nt nu nv nw bi translated">运行时—标准</li><li id="d9fd" class="no np it kd b ke nx ki ny km nz kq oa ku ob ky nt nu nv nw bi translated">图像— aws/codebuild/standard:2.0</li><li id="69b0" class="no np it kd b ke nx ki ny km nz kq oa ku ob ky nt nu nv nw bi translated">映像版本—始终使用最新的映像</li><li id="9dcc" class="no np it kd b ke nx ki ny km nz kq oa ku ob ky nt nu nv nw bi translated">环境类型— Linux</li><li id="123a" class="no np it kd b ke nx ki ny km nz kq oa ku ob ky nt nu nv nw bi translated"><strong class="kd iu">特权(如果您想要构建Docker映像或想要您的构建获得提升的特权，请启用此标志)—是(复选框)</strong></li><li id="016a" class="no np it kd b ke nx ki ny km nz kq oa ku ob ky nt nu nv nw bi translated">服务角色—新的服务角色</li><li id="5567" class="no np it kd b ke nx ki ny km nz kq oa ku ob ky nt nu nv nw bi translated">构建规范—使用构建规范文件</li></ul><h1 id="ea5f" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">我们服务角色的策略</h1><p id="5e8d" class="pw-post-body-paragraph kb kc it kd b ke mt kg kh ki mu kk kl km mv ko kp kq mw ks kt ku mx kw kx ky im bi translated">在创建CodeBuild项目时，我们选择在流程中创建一个新的服务角色。默认情况下，我们的代码构建项目没有访问ECR以及将图像推送到我们创建的存储库的必要权限。因此，我们将创建一个具有这些权限的策略，并将该策略附加到为CodeBuild项目创建的服务角色。在AWS中，策略定义了可以分配给用户、组或角色的AWS权限。</p><p id="f184" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">转到IAM并单击角色。您可能想知道如何才能找到已经创建的服务角色。服务角色是使用以下命名约定创建的:</p><p id="82fb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe na nb nc nd b">codebuild-<strong class="kd iu">YourCodeBuildProjectName</strong>-service-role</code></p><p id="f3ac" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我将我的代码构建项目命名为'<strong class="kd iu">dockerized-nginx-react-build</strong>'，因此我的服务角色被保存为<strong class="kd iu">code build-dockerized-nginx-react-build-service-role</strong>。</p><p id="aef9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一旦您确定了您的服务角色，您就可以前往<strong class="kd iu">策略</strong>并开始创建新策略的过程。</p><figure class="lz ma mb mc gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oc"><img src="../Images/dbc4c671ff849b477542b334dc9b124e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Nt16p6iUzlgmPet4yNdyWw.png"/></div></div><figcaption class="md me gj gh gi mf mg bd b be z dk translated">创建策略</figcaption></figure><p id="a391" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当出现要为其创建策略的服务列表时，选择<strong class="kd iu">弹性容器注册表</strong>。您也可以在搜索输入字段中输入此信息，以加快选择过程。选择ECR后，您可以转到服务选择部分下的“Actions”。您可以通过单击该部分右侧的“全部展开”链接来查看所有访问级别。我们将为我们的策略授予以下权限:</p><ul class=""><li id="a0c3" class="no np it kd b ke kf ki kj km nq kq nr ku ns ky nt nu nv nw bi translated"><strong class="kd iu">BatchCheckLayerAvailability</strong>(Read)-授予检查指定注册表和存储库中多个图像层可用性的权限</li><li id="5611" class="no np it kd b ke nx ki ny km nz kq oa ku ob ky nt nu nv nw bi translated"><strong class="kd iu"> GetAuthoizationToken </strong>(读取)—授予检索令牌的权限，该令牌对指定的注册表在12小时内有效</li><li id="8ff6" class="no np it kd b ke nx ki ny km nz kq oa ku ob ky nt nu nv nw bi translated"><strong class="kd iu">InitiateLayerUpload</strong>(Write)-授予通知Amazon ECR您打算上传图像层的权限</li><li id="0307" class="no np it kd b ke nx ki ny km nz kq oa ku ob ky nt nu nv nw bi translated"><strong class="kd iu"> PutImage </strong>(写)—授予创建或更新与映像相关联的映像清单的权限</li><li id="a22a" class="no np it kd b ke nx ki ny km nz kq oa ku ob ky nt nu nv nw bi translated"><strong class="kd iu"> CompleteLayerUpload </strong>(写)—授予通知Amazon ECR指定注册表、存储库名称和上传ID的图像层上传已完成的权限</li><li id="9c9c" class="no np it kd b ke nx ki ny km nz kq oa ku ob ky nt nu nv nw bi translated"><strong class="kd iu"> UploadLayerPart </strong>(写)—授予将图像层部件上传到Amazon ECR的权限</li></ul><p id="feb4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后，您可以转到下面的资源部分，我们将选择这次的所有资源，但更安全的方法是通过列出其<em class="mz"> ARN(亚马逊资源名称)</em>，将该策略专门应用于将要使用它的资源。之后，您可以单击屏幕右下方的“审查政策”按钮，这应该会将您重定向到命名政策的最后一步。我将我的策略命名为<strong class="kd iu"> CodeBuildToECR </strong>。欢迎你效仿😄。</p><p id="cab1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后，我们可以回到角色，单击您之前确定的服务角色。这将带您进入一个页面，该页面允许您将其他策略附加到该角色。我们希望附加我们刚刚创建的策略，因此继续操作并单击“Attach Policy ”,然后搜索您刚刚创建的策略并将其附加到您的服务角色。您可以查看您的<strong class="kd iu"> CodeBuildToECR </strong>策略版本，并确保当您选择JSON查看器模式时，它看起来像这样:</p><pre class="lz ma mb mc gt nf nd ng nh aw ni bi"><span id="dc08" class="mh lb it nd b gy nj nk l nl nm">{<br/>    "Version": "2012-10-17",<br/>    "Statement": [<br/>        {<br/>            "Sid": "VisualEditor0",<br/>            "Effect": "Allow",<br/>            "Action": [<br/>                "ecr:CompleteLayerUpload",<br/>                "ecr:GetAuthorizationToken",<br/>                "ecr:UploadLayerPart",<br/>                "ecr:InitiateLayerUpload",<br/>                "ecr:BatchCheckLayerAvailability",<br/>                "ecr:PutImage"<br/>            ],<br/>            "Resource": "*"<br/>        }<br/>    ]<br/>}</span></pre><p id="79ad" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们快完成了。剩下的就是创建我们的弹性Beanstalk环境，然后创建并触发我们的管道。</p><h1 id="8293" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">我们的应用环境</h1><p id="0c49" class="pw-post-body-paragraph kb kc it kd b ke mt kg kh ki mu kk kl km mv ko kp kq mw ks kt ku mx kw kx ky im bi translated"><a class="ae kz" href="https://aws.amazon.com/elasticbeanstalk/" rel="noopener ugc nofollow" target="_blank"> AWS Elastic Beanstalk </a>是轻松部署应用程序的绝佳工具。使用Beanstalk是免费的，但是，您需要为获得的底层资源付费。</p><p id="f642" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">切换回AWS控制台，前往弹性豆茎。在本节中，我们将遵循以下简单步骤:</p><h2 id="1689" class="mh lb it bd lc mi mj dn lg mk ml dp lk km mm mn lo kq mo mp ls ku mq mr lw ms bi translated">步骤1:创建新的应用程序</h2><p id="38c6" class="pw-post-body-paragraph kb kc it kd b ke mt kg kh ki mu kk kl km mv ko kp kq mw ks kt ku mx kw kx ky im bi translated">在右上角，您应该会看到一个蓝色标签，上面写着“<strong class="kd iu">创建新应用程序</strong>”，请点击它。然后，您可以随意命名应用程序，除非您愿意，否则不必填写描述字段。我们不会包括任何标签，所以也不用担心。</p><h2 id="b701" class="mh lb it bd lc mi mj dn lg mk ml dp lk km mm mn lo kq mo mp ls ku mq mr lw ms bi translated">步骤2:创建和选择环境层</h2><p id="4640" class="pw-post-body-paragraph kb kc it kd b ke mt kg kh ki mu kk kl km mv ko kp kq mw ks kt ku mx kw kx ky im bi translated">接下来，我们必须创建并选择希望Beanstalk为我们设置的环境类型。继续为您的应用程序创建一个新环境。因为我们正在设置一个标准的web API，所以您可以继续默认选择<strong class="kd iu"> Web服务器环境</strong>。</p><h2 id="8e01" class="mh lb it bd lc mi mj dn lg mk ml dp lk km mm mn lo kq mo mp ls ku mq mr lw ms bi translated">步骤3:配置环境</h2><p id="5671" class="pw-post-body-paragraph kb kc it kd b ke mt kg kh ki mu kk kl km mv ko kp kq mw ks kt ku mx kw kx ky im bi translated">在这最后一步，我们真的不需要改变太多。如果愿意，您可以更新应用程序的环境名，但是我将保留我的环境名不变。这里重要的一步是在基本配置部分选择一个预配置的平台。您必须选择Docker容器选项，因为我们正在部署一个容器化应用程序。</p><p id="b40c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这就是弹性豆茎😃，继续保存环境，Beanstalk将根据我们的选择供应和配置底层资源。一旦Beanstalk完成，环境应该是健康的，并且所有设置都有一个到示例应用程序的链接(见下图)。在您的情况下，<strong class="kd iu">运行版本</strong>应该有“<strong class="kd iu">示例应用程序</strong>”。</p><h1 id="5e10" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">我们的构建管道</h1><p id="0356" class="pw-post-body-paragraph kb kc it kd b ke mt kg kh ki mu kk kl km mv ko kp kq mw ks kt ku mx kw kx ky im bi translated">让我们把注意力转向<a class="ae kz" href="https://aws.amazon.com/codepipeline/" rel="noopener ugc nofollow" target="_blank"> AWS CodePipeline </a>，这是一种完全托管的CD(连续交付)服务，有助于自动化发布管道。我们现在要创建一个新的管道。以下是我们将要遵循的步骤:</p><h2 id="d4ad" class="mh lb it bd lc mi mj dn lg mk ml dp lk km mm mn lo kq mo mp ls ku mq mr lw ms bi translated">步骤1:选择管道设置</h2><p id="3ec0" class="pw-post-body-paragraph kb kc it kd b ke mt kg kh ki mu kk kl km mv ko kp kq mw ks kt ku mx kw kx ky im bi translated">首先为您的管道起一个名字和一个新的服务角色</p><h2 id="37bf" class="mh lb it bd lc mi mj dn lg mk ml dp lk km mm mn lo kq mo mp ls ku mq mr lw ms bi translated">步骤2:添加源</h2><p id="d280" class="pw-post-body-paragraph kb kc it kd b ke mt kg kh ki mu kk kl km mv ko kp kq mw ks kt ku mx kw kx ky im bi translated">接下来，让我们为我们的应用程序选择源代码，即CodeCommit。确保选择相关的存储库和分支。至于'<strong class="kd iu">变化检测'</strong>选项，我们将保留默认设置<a class="ae kz" href="https://aws.amazon.com/cloudwatch/" rel="noopener ugc nofollow" target="_blank"> Amazon CloudWatch </a>。</p><h2 id="d4f0" class="mh lb it bd lc mi mj dn lg mk ml dp lk km mm mn lo kq mo mp ls ku mq mr lw ms bi translated">步骤3:添加构建阶段</h2><p id="64f4" class="pw-post-body-paragraph kb kc it kd b ke mt kg kh ki mu kk kl km mv ko kp kq mw ks kt ku mx kw kx ky im bi translated">现在我们来到构建阶段。因为我们已经创建了CodeBuild项目，所以我们只需在输入字段中搜索它，并在它出现在建议中时选择它。</p><h2 id="990a" class="mh lb it bd lc mi mj dn lg mk ml dp lk km mm mn lo kq mo mp ls ku mq mr lw ms bi translated">步骤4:添加部署阶段</h2><p id="d912" class="pw-post-body-paragraph kb kc it kd b ke mt kg kh ki mu kk kl km mv ko kp kq mw ks kt ku mx kw kx ky im bi translated">最后，我们到了最后一个主要步骤——部署阶段。如果您想知道弹性Beanstalk应用程序的目的是什么，现在就需要它了。我们将使用Elastic Beanstalk作为我们的部署提供商。记得选择相关的应用程序和环境。</p><h2 id="8b21" class="mh lb it bd lc mi mj dn lg mk ml dp lk km mm mn lo kq mo mp ls ku mq mr lw ms bi translated">步骤5:审核和创建管道</h2><p id="700b" class="pw-post-body-paragraph kb kc it kd b ke mt kg kh ki mu kk kl km mv ko kp kq mw ks kt ku mx kw kx ky im bi translated">一旦我们完成了这些，剩下的就是检查管道并继续创建它。</p><h1 id="cdb4" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">触发新版本</h1><p id="8399" class="pw-post-body-paragraph kb kc it kd b ke mt kg kh ki mu kk kl km mv ko kp kq mw ks kt ku mx kw kx ky im bi translated">我们的管道已经准备好了🚀。在这个阶段，您需要做的就是提交一个更新的变更，并将其推送到您的远程存储库，以测试CI/CD管道。</p><p id="e1cd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果每个阶段都是成功的，那么您可以前往Elastic Beanstalk查看您的应用程序环境的健康状况，并转到提供的链接查看您的Dockerized React应用程序的运行情况。</p><figure class="lz ma mb mc gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi od"><img src="../Images/1ab5efa2f89b19e2edbdd40f778bd016.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gG90ugc2Q5pjK0aapsRzGg.png"/></div></div></figure></div><div class="ab cl oe of hx og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="im in io ip iq"><p id="bef1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你可以在这里找到这个基础项目<a class="ae kz" href="https://github.com/LukeMwila/dockerized-nginx-react-app" rel="noopener ugc nofollow" target="_blank">的源代码</a>😃，快乐编码！</p></div></div>    
</body>
</html>