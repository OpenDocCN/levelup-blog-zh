<html>
<head>
<title>JavaScript Refactoring — Conditionals</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript重构—条件</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-refactoring-conditionals-6d74a1138c96?source=collection_archive---------8-----------------------#2020-05-25">https://levelup.gitconnected.com/javascript-refactoring-conditionals-6d74a1138c96?source=collection_archive---------8-----------------------#2020-05-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/58a7d6634a623fe1915b26f765744414.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vwwGpXXZCRa1qVKW"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@shotsbywolf?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Geert Pieters </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="bcaa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以清理我们的JavaScript代码，这样我们可以更容易地使用它们。</p><p id="8fa5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将研究一些与清理JavaScript条件相关的重构思想。</p><h1 id="d626" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">分解条件</h1><p id="f5dc" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以把长的条件表达式分解成更小的条件表达式，命名为。</p><p id="2bb4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，不写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="5226" class="mq lf it mm b gy mr ms l mt mu">let ieIEMac = navigator.userAgent.toLowerCase().includes("mac") &amp;&amp; navigator.userAgent.toLowerCase().includes("ie")</span></pre><p id="f3c9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们写道:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="ba33" class="mq lf it mm b gy mr ms l mt mu">let userAgent = navigator.userAgent.toLowerCase();<br/>let isMac = userAgent.includes("mac");<br/>let isIE = userAgent.includes("ie");<br/>let isMacIE = isMac &amp;&amp; isIE;</span></pre><p id="9490" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们打破了条件表达式，将更小的表达式分配到它们自己的变量中，然后将它们组合起来，使一切更容易阅读。</p><h1 id="733b" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">巩固条件表达式</h1><p id="5a78" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">如果我们有多个短条件表达式分配给它们自己的变量，那么我们可以把它们合并成一个。</p><p id="8dab" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，不要写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="7587" class="mq lf it mm b gy mr ms l mt mu">const x = 5;<br/>const bigEnough = x &gt; 5;<br/>const smallEnough = x &lt; 6;<br/>const inRange = bigEnough &amp;&amp; smallEnough;</span></pre><p id="9998" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们写道:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="eb36" class="mq lf it mm b gy mr ms l mt mu">const x = 5;<br/>const inRange = x &gt; 5 &amp;&amp; x &lt; 6;</span></pre><p id="a455" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为表达式很短，即使把它们组合在一起也不会让它变得更长，所以我们可以这样做。</p><h1 id="95ed" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">合并重复的条件片段</h1><p id="6ccc" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">如果我们在一个条件块中有重复的表达式或语句，那么我们可以将它们移出。</p><p id="dd8a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，不写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="1c6c" class="mq lf it mm b gy mr ms l mt mu">if (price &gt; 100) {<br/>  //...<br/>  complete();<br/>} else {<br/>  //...<br/>  complete();<br/>}</span></pre><p id="adee" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们写道:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="08f2" class="mq lf it mm b gy mr ms l mt mu">if (price &gt; 100) {<br/>  //...  <br/>} else {<br/>  //...  <br/>}<br/>complete();</span></pre><p id="d785" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这样，我们就不必重复调用<code class="fe mv mw mx mm b">complete</code>函数了。</p><h1 id="2534" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">移除控制标志</h1><p id="0572" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">如果我们对一个循环使用了控制标志，那么我们经常会看到这样的循环:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="0cd2" class="mq lf it mm b gy mr ms l mt mu">let done = false;<br/>while (!done) {<br/>  if (condition) {<br/>    done = true;<br/>  }<br/>  //...<br/>}</span></pre><p id="cde2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，<code class="fe mv mw mx mm b">done</code>是控制标志，我们将<code class="fe mv mw mx mm b">done</code>设置为<code class="fe mv mw mx mm b">true</code>，以便当<code class="fe mv mw mx mm b">condition</code>为<code class="fe mv mw mx mm b">true</code>时，我们停止<code class="fe mv mw mx mm b">while</code>循环。</p><p id="668e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">相反，我们可以使用<code class="fe mv mw mx mm b">break</code>来停止循环，如下所示:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="e664" class="mq lf it mm b gy mr ms l mt mu">let done = false;<br/>while (!done) {<br/>  if (condition) {<br/>    break;<br/>  }<br/>  //...<br/>}</span></pre><h1 id="c8b1" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">用保护子句替换嵌套条件</h1><p id="1a32" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">嵌套的条件语句非常难读，所以我们可以使用guard子句来代替它们。</p><p id="57c9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，代替下面的嵌套条件语句:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="823b" class="mq lf it mm b gy mr ms l mt mu">const fn = () =&gt; {<br/>  if (foo) {<br/>    if (bar) {<br/>      if (baz) {<br/>        //...<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="25b1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们写道:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="c5da" class="mq lf it mm b gy mr ms l mt mu">const fn = () =&gt; {<br/>  if (!foo) {<br/>    return;<br/>  }</span><span id="daad" class="mq lf it mm b gy my ms l mt mu">  if (!bar) {<br/>    return;<br/>  }</span><span id="9c1e" class="mq lf it mm b gy my ms l mt mu">  if (baz) {<br/>    //...<br/>  }<br/>}</span></pre><p id="fd98" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，保护子句是:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="60c2" class="mq lf it mm b gy mr ms l mt mu">if (!foo) {<br/>  return;<br/>}</span></pre><p id="f03a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">并且:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="f26c" class="mq lf it mm b gy mr ms l mt mu">if (!bar) {<br/>  return;<br/>}</span></pre><p id="4e65" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果这些条件为假，它们会提前返回函数。</p><p id="dbfd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有了它，我们就不需要筑巢了。</p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/6f89e4f68259a13f1826390a9f6d2891.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mJfSZp_-NRfwGFjT"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@neonbrand?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> NeONBRAND </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="aa4b" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">用多态替换条件</h1><p id="03e8" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以为每种数据创建子类，然后拥有不同的方法来适应它所调用的对象类型，而不是用一个<code class="fe mv mw mx mm b">switch</code>语句对不同类型的数据做同样的事情。</p><p id="aee9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，不要写以下内容:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="7c52" class="mq lf it mm b gy mr ms l mt mu">class Animal {<br/>  constructor(type) {<br/>    this.type = type;<br/>  }</span><span id="c3ad" class="mq lf it mm b gy my ms l mt mu">  getBaseSpeed() {<br/>    return 100;<br/>  }</span><span id="e23a" class="mq lf it mm b gy my ms l mt mu">  getSpeed() {<br/>    switch (this.type) {<br/>      case ('cat'): {<br/>        return getBaseSpeed() * 1.5<br/>      }<br/>      case ('dog'): {<br/>        return getBaseSpeed() * 2<br/>      }<br/>      default: {<br/>        return getBaseSpeed()<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="284c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们写下如下内容:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="9920" class="mq lf it mm b gy mr ms l mt mu">class Animal {<br/>  constructor(type) {<br/>    this.type = type;<br/>  }</span><span id="059e" class="mq lf it mm b gy my ms l mt mu">  getBaseSpeed() {<br/>    return 100;<br/>  }<br/>}</span><span id="b984" class="mq lf it mm b gy my ms l mt mu">class Cat extends Animal {<br/>  getSpeed() {<br/>    return super.getBaseSpeed() * 1.5;<br/>  }<br/>}</span><span id="5085" class="mq lf it mm b gy my ms l mt mu">class Dog extends Animal {<br/>  getSpeed() {<br/>    return super.getBaseSpeed() * 2;<br/>  }<br/>}</span></pre><p id="16d1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们的<code class="fe mv mw mx mm b">switch</code>语句很长，我们必须为不同种类的对象定制<code class="fe mv mw mx mm b">case</code>块。</p><p id="03da" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我们最好将switch语句变成它们自己的子类，这样它们就可以有自己的方法来获得速度。</p><h1 id="02b6" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">引入空对象</h1><p id="e841" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">如果我们重复检查了<code class="fe mv mw mx mm b">null</code>或<code class="fe mv mw mx mm b">undefined</code>，那么我们可以定义一个子类来表示这个类的<code class="fe mv mw mx mm b">null</code>或<code class="fe mv mw mx mm b">undefined</code>版本，然后使用它。</p><p id="64fb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，不写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="b919" class="mq lf it mm b gy mr ms l mt mu">class Person {<br/>  //...<br/>}</span></pre><p id="be3e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们写道:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="86b2" class="mq lf it mm b gy mr ms l mt mu">class Person {<br/>  //...<br/>}</span><span id="7858" class="mq lf it mm b gy my ms l mt mu">class NullPerson extends Person {<br/>  //...<br/>}</span></pre><p id="474e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，不是设置对象的属性，其中<code class="fe mv mw mx mm b">Person</code>是<code class="fe mv mw mx mm b">null</code>或<code class="fe mv mw mx mm b">undefined</code>，而是将其设置为<code class="fe mv mw mx mm b">NullPerson</code>实例。</p><p id="6c8e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这消除了用条件检查这些值的需要。</p><h1 id="7d2d" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="8ba3" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以创建一个<code class="fe mv mw mx mm b">null</code>或<code class="fe mv mw mx mm b">undefined</code>版本的类来设置它，而不是<code class="fe mv mw mx mm b">null</code>或<code class="fe mv mw mx mm b">undefined</code>。</p><p id="c818" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，我们可以将长条件表达式分解成更小的表达式，并将小表达式组合成大表达式。</p></div></div>    
</body>
</html>