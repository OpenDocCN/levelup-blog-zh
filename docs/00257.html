<html>
<head>
<title>Using React 16 Portals to build a global UX tooltip management for a legacy application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React 16门户为遗留应用程序构建全局UX工具提示管理</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/using-react-16-portals-to-build-a-global-ux-tooltip-management-application-f6389f24c1a7?source=collection_archive---------1-----------------------#2018-11-18">https://levelup.gitconnected.com/using-react-16-portals-to-build-a-global-ux-tooltip-management-application-f6389f24c1a7?source=collection_archive---------1-----------------------#2018-11-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="fc52" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本文中，我们将通过一个小而简单的教程来了解如何使用React 16的新特性Portals来显示交互式工具提示，以便在项目中获得更好的用户体验。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/5376a63fc43b9c1bec07c943cf33305e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3vQSlkW-pVY4AOZj"/></div></div></figure></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="468a" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">介绍</h1><p id="cb0b" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated"><strong class="jp ir">我们为什么喜欢React JS？</strong>这个令人敬畏的库的主要优势之一是可以用Javascript创建可重用的组件来构建复杂的UI。由于逻辑是用Javascript以声明性和结构良好的方式编写的——不需要HTML模板和DOM操作——当组件状态改变时，React将有效地呈现/更新用户界面。</p><p id="c42e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">这些问题是从哪里提出来的？</strong>当您的前端应用程序完全用React编写时，React非常强大——您可以通过React组件属性和状态完美地控制您的UI，并且很容易在您的应用程序层次结构中注入新组件或更改现有组件以附加新事件或任何附加逻辑。</p><p id="b8bc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当然也有一些例外，即静态内容可以只是HTML(但是无状态React组件在许多情况下也可以工作得很好)。但是想象一下，当你的前端应用程序的一部分以Angular、jQuery或普通HTML等格式呈现时，你正在处理遗留代码。—但是<strong class="jp ir">不受你的React应用</strong>控制。您需要将React应用程序或多个应用程序注入到现有项目中。在我看来，这是一个主要的弱点——当你需要处理结构良好的JSX之外的所有东西时。在这一点上，出现了许多问题:</p><ul class=""><li id="75ba" class="mh mi iq jp b jq jr ju jv jy mj kc mk kg ml kk mm mn mo mp bi translated">你如何将这些应用程序渲染到现有项目中(<a class="ae mq" href="https://github.com/ngReact/ngReact" rel="noopener ugc nofollow" target="_blank">示例</a>)？</li><li id="c49d" class="mh mi iq jp b jq mr ju ms jy mt kc mu kg mv kk mm mn mo mp bi translated">你如何在应用程序之间共享数据？</li><li id="8694" class="mh mi iq jp b jq mr ju ms jy mt kc mu kg mv kk mm mn mo mp bi translated">你将如何处理来自非反应源的事件？</li></ul><p id="f2be" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">等等。等等。等等。…..</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/e3637df54bc723a598ce8121ec5c2f22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*080xsA79yLouZAPS"/></div></div></figure><p id="69e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">与Angular或jQuery不同，React在处理来自其他库/框架/普通HTML的遗留代码方面不太好。如果您需要将多个React应用程序中的一些公共逻辑集成到页面上的不同DOM节点中，您也可以从中获得很多乐趣。你可以反驳这一点，但这是我在工作中经常面临的挑战之一。</p><p id="f4dd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这方面的一个例子是<a class="ae mq" href="https://en.wikipedia.org/wiki/Tooltip" rel="noopener ugc nofollow" target="_blank">工具提示</a>。假设您想为用户提供一些提示，让他们了解您的整个应用程序——让他们知道如何使用它，主要功能是什么等等。您还希望这些工具提示是可忽略的(如果您不能关闭它，会很烦人)、交互式的(它们中的一些可以在某些事件或超时时弹出)并且理想地从一个应用程序控制(因此您只有一个地方来控制与提示和工具提示相关的UI的当前状态)。假设你的UI不是一个单独的React应用——它可以是多个应用+部分HTML代码+少量Angular或其他框架。或者你有一个复杂的React应用程序，它有很深的层次结构，这使得它很难为了工具提示而传递道具。</p><p id="4ea9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">尽管您希望集成新的逻辑，尽可能避免复制/粘贴…</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/74b3cbd0b0a09d6da865c35218c61008.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LYcB4tzjvVTqRnyc"/></div></div></figure><p id="b323" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在是时候让<a class="ae mq" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"> React 16 </a>及其令人惊叹的新功能<a class="ae mq" href="https://reactjs.org/docs/portals.html" rel="noopener ugc nofollow" target="_blank">门户</a>大放异彩了。让我们来看看官方文档。</p><pre class="km kn ko kp gt mw mx my mz aw na bi"><span id="1734" class="nb lf iq mx b gy nc nd l ne nf">Portals provide a first-class way to render children into a DOM node that exists outside the DOM hierarchy of the parent component.</span></pre><p id="c45d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它是这样工作的:</p><pre class="km kn ko kp gt mw mx my mz aw na bi"><span id="d92a" class="nb lf iq mx b gy nc nd l ne nf">ReactDOM.createPortal(child, container)</span></pre><p id="14b1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">其中<code class="fe ng nh ni mx b">child</code>是一个react组件，而<code class="fe ng nh ni mx b">container</code>是一个目标DOM节点。</p><p id="1585" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">听起来正是我们需要的。此外，根据React JS官方教程，各种模态和弹出窗口是React门户特性的良好用例。在本教程中，我们将尝试使用这个功能来建立一个交互式用户界面工具提示层。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="7149" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">任务定义和假设</h1><p id="aed1" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">我们需要建立应用程序来控制我们的UI工具提示，应该是:</p><ul class=""><li id="c55e" class="mh mi iq jp b jq jr ju jv jy mj kc mk kg ml kk mm mn mo mp bi translated">能够指向从不同来源呈现的UI元素</li><li id="f3e9" class="mh mi iq jp b jq mr ju ms jy mt kc mu kg mv kk mm mn mo mp bi translated">可忽略—用户可以关闭工具提示</li><li id="a324" class="mh mi iq jp b jq mr ju ms jy mt kc mu kg mv kk mm mn mo mp bi translated">能够触发事件(即显示一个接一个的工具提示链)</li><li id="1b4c" class="mh mi iq jp b jq mr ju ms jy mt kc mu kg mv kk mm mn mo mp bi translated">能够在某些事件上显示(例如，点击按钮时，其他工具提示关闭)</li></ul><p id="8c41" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于本教程，我们还做了几个假设:</p><ul class=""><li id="2417" class="mh mi iq jp b jq jr ju jv jy mj kc mk kg ml kk mm mn mo mp bi translated">UI部分在React APP中呈现，部分作为HTML模板呈现</li><li id="0c1a" class="mh mi iq jp b jq mr ju ms jy mt kc mu kg mv kk mm mn mo mp bi translated">我们需要一次只显示一个工具提示</li><li id="c420" class="mh mi iq jp b jq mr ju ms jy mt kc mu kg mv kk mm mn mo mp bi translated">我们使用一个简单的工具提示样式，取自<a class="ae mq" href="https://www.w3schools.com/css/c" rel="noopener ugc nofollow" target="_blank"> w3schools </a></li><li id="dff4" class="mh mi iq jp b jq mr ju ms jy mt kc mu kg mv kk mm mn mo mp bi translated">工具提示里面没有任何动作按钮(只有关闭按钮)</li><li id="5039" class="mh mi iq jp b jq mr ju ms jy mt kc mu kg mv kk mm mn mo mp bi translated">我们不使用任何国家管理工具——只有古老的<code class="fe ng nh ni mx b">setState</code>:)</li></ul></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="82dc" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">实施解决方案</h1><p id="b938" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">为了简化应用程序创建过程，我们只需使用facebook提供的<a class="ae mq" href="https://github.com/facebook/create-react-app" rel="noopener ugc nofollow" target="_blank"> create-react-app </a>工具。你可以遵循官方文档或者使用我的其他教程。对于本教程，我们不需要任何额外的包，只要确保你有一个现代版本的<a class="ae mq" href="https://github.com/KilroggD/react-tooltip/blob/3e25d904d90d29b27e3e543c78c935c09aabe581/package.json#L6" rel="noopener ugc nofollow" target="_blank"> React JS </a>。如果你想看到整个解决方案的工作——随意克隆<a class="ae mq" href="https://github.com/KilroggD/react-tooltip" rel="noopener ugc nofollow" target="_blank">https://github.com/KilroggD/react-tooltip</a>并启动应用程序。</p><p id="f6b7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我将尝试解释我们需要为这个特定的教程做的主要步骤。</p><ul class=""><li id="ed2f" class="mh mi iq jp b jq jr ju jv jy mj kc mk kg ml kk mm mn mo mp bi translated">就约定达成一致。让我们用一个特定的类名<strong class="jp ir"><em class="nj">class = " tooltip-target "</em></strong>来标记我们需要工具提示指向的所有块。同样，让我们给每个块一个唯一的id来表示工具提示位置，即`<strong class="jp ir"><em class="nj">id = " TM-event-tooltip "</em></strong>`。假设<code class="fe ng nh ni mx b">tm</code>是“工具提示管理器”的首字母缩写。</li><li id="adaf" class="mh mi iq jp b jq mr ju ms jy mt kc mu kg mv kk mm mn mo mp bi translated">将用户界面的非反应部分添加到索引中。html文件。让我们把欢迎标题放在我们的应用程序之外，再加一个隐藏的消息块。我们将通过单击react应用程序中的按钮来显示该块，并显示该事件的工具提示。<code class="fe ng nh ni mx b">root</code>容器将包含主React应用程序。</li></ul><pre class="km kn ko kp gt mw mx my mz aw na bi"><span id="09b7" class="nb lf iq mx b gy nc nd l ne nf">    &lt;div class="welcome-msg"&gt;<br/>        &lt;div id="tm-welcome-tooltip" class="tooltip-target"&gt;<br/>            Welcome to the Tooltip Manager Demo<br/>        &lt;/div&gt;<br/>    &lt;/div&gt;<br/>    &lt;div id="root"&gt;&lt;/div&gt;<br/>    &lt;div id="event-message" class="event-msg  hidden"&gt;<br/>      &lt;div id="tm-event-tooltip" class="tooltip-target"&gt;<br/>        &lt;span&gt;This is the test app to show how we can use React Portals to create a Tooltip Manager.&lt;/span&gt;<br/>      &lt;/div&gt;<br/>    &lt;/div&gt;</span></pre><ul class=""><li id="a6e1" class="mh mi iq jp b jq jr ju jv jy mj kc mk kg ml kk mm mn mo mp bi translated">为工具提示属性定义<a class="ae mq" href="https://github.com/KilroggD/react-tooltip/blob/master/src/tooltips/tooltip-templates.js" rel="noopener ugc nofollow" target="_blank">模板</a>。让我们假设每个工具提示都有3个属性——标题、文本和位置(与给定工具提示所指向的组件的id相关)</li></ul><pre class="km kn ko kp gt mw mx my mz aw na bi"><span id="d059" class="nb lf iq mx b gy nc nd l ne nf">"welcome": {<br/>        title: 'Welcome!',<br/>        text: 'Welcome to react-tooltips example app. Those tooltips    will show you all UX tips',<br/>        position: 'welcome-tooltip',<br/>    },</span></pre><ul class=""><li id="6bfa" class="mh mi iq jp b jq jr ju jv jy mj kc mk kg ml kk mm mn mo mp bi translated">创建简单的无状态工具提示组件,它将呈现工具提示本身</li></ul><pre class="km kn ko kp gt mw mx my mz aw na bi"><span id="af59" class="nb lf iq mx b gy nc nd l ne nf"><strong class="mx ir">const </strong>Tooltip = props =&gt; {<br/>    <strong class="mx ir">return </strong>(<br/>        &lt;div className="tooltip"&gt;<br/>            &lt;div className="tooltip__content"&gt;<br/>                &lt;p className="tooltip__header"&gt;{ props.title }&lt;/p&gt;<br/>                &lt;p className="tooltip__text"&gt;{ props.text }&lt;/p&gt;<br/>            &lt;/div&gt;<br/>            &lt;button onClick={ props.onClose } className="tooltip__close-btn"&gt;x&lt;/button&gt;<br/>        &lt;/div&gt;<br/>    );<br/>};</span></pre><ul class=""><li id="618c" class="mh mi iq jp b jq jr ju jv jy mj kc mk kg ml kk mm mn mo mp bi translated">创建将呈现所有工具提示的组件。这是魔法开始的地方。让我们的组件只接受两个属性:<code class="fe ng nh ni mx b">currentTooltip</code>——显示哪个工具提示当前是活动的，以及<code class="fe ng nh ni mx b">onTooltipClose</code> —在tooltipClose上触发的回调。使用第一个工具，我们可以从模板对象中获得实际工具提示的道具</li></ul><pre class="km kn ko kp gt mw mx my mz aw na bi"><span id="35b0" class="nb lf iq mx b gy nc nd l ne nf"><strong class="mx ir">import </strong>TOOLTIPS <strong class="mx ir">from </strong>'./tooltip-templates';</span><span id="7642" class="nb lf iq mx b gy nk nd l ne nf"><strong class="mx ir">&lt;...&gt;</strong></span><span id="3dd0" class="nb lf iq mx b gy nk nd l ne nf"><strong class="mx ir">get </strong>tooltipProps() {<br/>    <strong class="mx ir">return </strong>TOOLTIPS[<strong class="mx ir">this</strong>.props.currentTooltip] || {};<br/>}</span></pre><p id="58bd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该组件的主要用途是使用React Portals功能在DOM树的不同位置呈现工具提示</p><pre class="km kn ko kp gt mw mx my mz aw na bi"><span id="65ee" class="nb lf iq mx b gy nc nd l ne nf">render() {<br/>        if (!this.props.currentTooltip) {<br/>            return null;<br/>        }<br/>        const tooltip = &lt;Tooltip { ...this.tooltipProps } onClose={ this.props.onTooltipClose } /&gt;;<br/>        return ReactDOM.createPortal(tooltip, this.tooltipContainer);<br/>    }</span></pre><p id="bd3d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是我们不想完全替换目标DOM节点的内容。一个可能的解决方案是在目标DOM节点中创建一个容器div(如果它不存在),并在创建的块中呈现一个工具提示。</p><pre class="km kn ko kp gt mw mx my mz aw na bi"><span id="250f" class="nb lf iq mx b gy nc nd l ne nf"><strong class="mx ir">get </strong>tooltipContainer() {<br/>    <strong class="mx ir">const </strong>targetNode = document.querySelector(`#tm-${<strong class="mx ir">this</strong>.tooltipProps.position}`);<br/>    <strong class="mx ir">let </strong>tooltipContainer = targetNode.querySelector('.tooltip-container');<br/>    <strong class="mx ir">if </strong>(!tooltipContainer) {<br/>        tooltipContainer = document.createElement('div');<br/>        tooltipContainer.classList.add('tooltip-container');<br/>        targetNode.appendChild(tooltipContainer);<br/>    }<br/>    <strong class="mx ir">return </strong>tooltipContainer;<br/>}</span></pre><p id="5552" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还添加了删除这些容器的代码，以防万一:)</p><pre class="km kn ko kp gt mw mx my mz aw na bi"><span id="6faf" class="nb lf iq mx b gy nc nd l ne nf">componentWillUnmount() {<br/>    [].slice.call(document.querySelectorAll('.tooltip-containter')).forEach(el =&gt; { el.remove(); });<br/>}</span></pre><ul class=""><li id="4f5e" class="mh mi iq jp b jq jr ju jv jy mj kc mk kg ml kk mm mn mo mp bi translated">创建在React中呈现的UI部件。这里没什么特别的——只是简单的带有按钮的<a class="ae mq" href="https://github.com/KilroggD/react-tooltip/blob/master/src/homepage.react-component.js" rel="noopener ugc nofollow" target="_blank">主页</a>组件(带有onClick事件),如果你需要的话，你可以自由添加更多的组件:)</li></ul><pre class="km kn ko kp gt mw mx my mz aw na bi"><span id="6779" class="nb lf iq mx b gy nc nd l ne nf"><strong class="mx ir">const </strong>Homepage = props =&gt; {<br/>    <strong class="mx ir">return </strong>(<br/>        &lt;div className="app__homepage"&gt;<br/>           &lt;div className="app__action"&gt;<br/>                &lt;div id="tm-first-action-tooltip" className="tooltip-target"&gt;<br/>                    &lt;button onClick={ props.onClick }&gt;CLICK ME!&lt;/button&gt;<br/>                &lt;/div&gt;<br/>            &lt;/div&gt;<br/>        &lt;/div&gt;<br/>    );<br/>};</span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nl"><img src="../Images/2c21e9c562f756a749e4d37943d8a1ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KpEjcVBVhjKF8nWaOof9fg.png"/></div></div></figure><p id="b660" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，我们对工具提示目标节点使用相同的约定。</p><ul class=""><li id="3ece" class="mh mi iq jp b jq jr ju jv jy mj kc mk kg ml kk mm mn mo mp bi translated">现在是时候创建我们的应用程序状态了。对于本教程，我们只是将整个状态保存在<a class="ae mq" href="https://github.com/KilroggD/react-tooltip/blob/master/src/App.js" rel="noopener ugc nofollow" target="_blank"> App </a>容器中。为了使我们的应用程序更加强大，我们可以使用<a class="ae mq" rel="noopener ugc nofollow" target="_blank" href="/enhancing-your-react-graphql-app-with-redux-and-redux-thunk-90c556aff1c5"> Redux </a>或<a class="ae mq" rel="noopener ugc nofollow" target="_blank" href="/managing-react-application-state-with-mobx-full-stack-tutorial-part-1-372a7825847a"> MobX </a>作为状态管理库。如果你想这样做，你可以查看上面链接的我的教程，或者按照官方文档。因为我们只是保持简单</li></ul><pre class="km kn ko kp gt mw mx my mz aw na bi"><span id="dadc" class="nb lf iq mx b gy nc nd l ne nf"><strong class="mx ir">class </strong>App <strong class="mx ir">extends </strong>Component {<br/><br/>  constructor(props) {<br/>    <strong class="mx ir">super</strong>(props);<br/>    <strong class="mx ir">this</strong>.state = {<br/>      currentTooltipName: <strong class="mx ir">null</strong>,<br/>    };<br/>  }<br/>  render() {<br/>    return (<br/>      &lt;div className="app"&gt;<br/>          &lt;Homepage onClick={ this.firstAction } /&gt;<br/>          &lt;TooltipManager<br/>              currentTooltip={ this.state.currentTooltipName }<br/>              onTooltipClose={ this.onTooltipClose }<br/>          /&gt;<br/>      &lt;/div&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="0821" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如你所看到的——我们在状态对象中只有一个键，定义了我们当前工具提示的名称。让我们默认执行步骤<code class="fe ng nh ni mx b">'welcome'</code></p><pre class="km kn ko kp gt mw mx my mz aw na bi"><span id="14a6" class="nb lf iq mx b gy nc nd l ne nf">componentDidMount() {<br/>  <strong class="mx ir">this</strong>.setState({ currentTooltipName: 'welcome' });<br/>}</span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nm"><img src="../Images/3ce4df241d7d3bfacfe4d1b348200183.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hH8cXe2iclT6-90KQem4NQ.png"/></div></div></figure><p id="418c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，我们定义一个方法来重置工具提示关闭时的状态</p><pre class="km kn ko kp gt mw mx my mz aw na bi"><span id="75e9" class="nb lf iq mx b gy nc nd l ne nf">onTooltipClose = () =&gt; {<br/>    <strong class="mx ir">this</strong>.setState({<br/>        currentTooltipName: <strong class="mx ir">null</strong>,<br/>    });<br/>}</span></pre><p id="cafc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，让我们创建一个可能的场景——“链式”UI工具提示一个接一个地打开，显示所有必要的提示，以获得更好的用户体验。</p><pre class="km kn ko kp gt mw mx my mz aw na bi"><span id="9afd" class="nb lf iq mx b gy nc nd l ne nf">componentDidUpdate(prevProps, prevState) {<br/>  <strong class="mx ir">if </strong>(prevState.currentTooltipName === 'welcome' &amp;&amp; <strong class="mx ir">this</strong>.state.currentTooltipName === <strong class="mx ir">null</strong>) {<br/>      <strong class="mx ir">return this</strong>.setState({ currentTooltipName: 'first_action' });<br/>  }<br/>}</span></pre><p id="6224" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果<code class="fe ng nh ni mx b">welcome</code>工具提示被关闭——立即打开<code class="fe ng nh ni mx b">first_action</code>工具提示。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nn"><img src="../Images/4633d763c792a477bc11d819ce325e19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ONjHcsNLUiq9OtIN7uNTNg.png"/></div></div></figure><p id="873d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们为“CLICK ME”按钮创建一个动作，使我们的应用程序具有动态性和交互性。首先，我们为按钮创建一个动作。</p><pre class="km kn ko kp gt mw mx my mz aw na bi"><span id="8d27" class="nb lf iq mx b gy nc nd l ne nf">firstAction = () =&gt; {<br/>  setTimeout(() =&gt; {<br/>      <strong class="mx ir">this</strong>.setState({ currentTooltipName: 'event' });<br/>      document.querySelector('#event-message').classList.remove('hidden');<br/>  }, 500);<br/>}</span></pre><p id="482a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该按钮将显示React JS外部呈现的<code class="fe ng nh ni mx b">event-message</code>块，并将状态切换到<code class="fe ng nh ni mx b">event</code>步骤。</p><p id="7cfb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">别忘了添加一些花哨的<a class="ae mq" href="https://github.com/KilroggD/react-tooltip/blob/master/src/App.css" rel="noopener ugc nofollow" target="_blank">风格</a>——就是这样！我们的应用已经准备好了。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi no"><img src="../Images/a4de1280a5a451179c194e3a101e121d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*LPpv49cvQWeJAOkupRayDA.gif"/></div></div></figure></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="ba66" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><ul class=""><li id="97e7" class="mh mi iq jp b jq mc ju md jy np kc nq kg nr kk mm mn mo mp bi translated">如果您需要React组件在根应用程序节点之外呈现并由一个状态控制，React Portals是一个非常棒的解决方案。</li><li id="0eea" class="mh mi iq jp b jq mr ju ms jy mt kc mu kg mv kk mm mn mo mp bi translated">我们可以随时随地显示工具提示——在渲染时/在某些事件触发时/在其他工具提示关闭时等等。</li><li id="a6ad" class="mh mi iq jp b jq mr ju ms jy mt kc mu kg mv kk mm mn mo mp bi translated">它们也适用于异步呈现和向DOM中注入组件</li><li id="37b7" class="mh mi iq jp b jq mr ju ms jy mt kc mu kg mv kk mm mn mo mp bi translated">各种模态、弹出窗口和工具提示都是门户的良好用例</li><li id="a491" class="mh mi iq jp b jq mr ju ms jy mt kc mu kg mv kk mm mn mo mp bi translated">使用MobX或Redux(可能是不同的文章)这样的状态管理工具，本教程会更加强大和灵活</li><li id="551a" class="mh mi iq jp b jq mr ju ms jy mt kc mu kg mv kk mm mn mo mp bi translated">我们需要解决使用门户的React应用程序的单元测试问题</li></ul></div></div>    
</body>
</html>