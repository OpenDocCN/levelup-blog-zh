<html>
<head>
<title>How does TypeScript Know Which Types are Compatible? — Objects and Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript如何知道哪些类型是兼容的？—对象和功能</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-does-typescript-know-which-types-are-compatible-with-each-other-objects-and-functions-924086117004?source=collection_archive---------18-----------------------#2020-02-04">https://levelup.gitconnected.com/how-does-typescript-know-which-types-are-compatible-with-each-other-objects-and-functions-924086117004?source=collection_archive---------18-----------------------#2020-02-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/740f34fbfe4c3198fa80f6ca2f38e116.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tyCibjBHkwnhZ-Je"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">Vincent van Zalinge 在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="d21f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">与JavaScript相比，TypeScript的优势在于我们可以用它来注释变量、函数和其他实体的数据类型。这使我们能够在文本编辑器中自动完成，并且它还为构建应用程序添加了一个编译步骤，这意味着编译时检查可以捕获更多错误，如未定义的错误和意外的数据类型错误，否则这些错误将在运行时被捕获。</p><p id="c2d1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为此，TypeScript根据实体的结构和其他方面(如参数的数量和每个参数的类型等)检查不同的变量是否具有相同的类型。在本文中，我们将了解TypeScript如何确定哪些数据类型相互兼容。</p><p id="f539" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">TypeScript的类型系统允许一些在编译时无法知道的操作是安全的。当一个类型系统不允许编译时未知的动作时，它就是健全的。然而，由于TypeScript是JavaScript的超集，它必须允许在编译时执行一些不合理的操作。</p><h1 id="62b0" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">基本类型兼容性</h1><p id="1e3a" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">TypeScript用来确定类型兼容性的最基本的规则是，如果两种类型具有相同的结构，那么它就被认为是兼容的类型。具有相同的结构意味着两种类型具有相同的成员名称，并且每个成员具有相同的类型。例如，如果我们有:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="6cd7" class="mq lf it mm b gy mr ms l mt mu">interface A {<br/>  name: string;<br/>  age: number;<br/>}</span><span id="d9bd" class="mq lf it mm b gy mv ms l mt mu">interface B {<br/>  name: string;<br/>  age: number;<br/>}</span><span id="01a5" class="mq lf it mm b gy mv ms l mt mu">let x: A = { name: 'Joe', age: 10 };<br/>let y: B = { name: 'Jane', age: 20 };<br/>x = y;</span></pre><p id="7cb4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后TypeScript将接受代码并编译它，因为两个接口<code class="fe mw mx my mm b">A</code>和<code class="fe mw mx my mm b">B</code>都有<code class="fe mw mx my mm b">name</code>和<code class="fe mw mx my mm b">age</code>作为它们的字段，并且两个接口中的<code class="fe mw mx my mm b">name</code>和<code class="fe mw mx my mm b">age</code>都具有相同的类型。此外，如果一个对象具有一个类型的所有属性和接口中没有的额外属性，那么该对象也可以被赋给一个没有类型注释的变量，然后该变量可以被赋给一个设置了类型的变量。例如，如果我们有以下代码:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="317c" class="mq lf it mm b gy mr ms l mt mu">interface A {<br/>  name: string;<br/>  age: number;<br/>}</span><span id="cba9" class="mq lf it mm b gy mv ms l mt mu">let y: A;<br/>let x = { name: 'Joe', age: 10, gender: 'male' };<br/>y = x;</span></pre><p id="31d4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">其中<code class="fe mw mx my mm b">y</code>的数据类型为<code class="fe mw mx my mm b">A</code>，那么我们可以将一个对象赋给一个没有数据类型注释的变量，即<code class="fe mw mx my mm b">x</code>，然后我们可以将它赋给类型为<code class="fe mw mx my mm b">A</code>的<code class="fe mw mx my mm b">y</code>。这是因为只有对象文字有多余属性检查。变量没有这种检查。</p><p id="99bf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，在将函数赋给变量时，也会检查函数的数据类型。我们可以传入一个比参数类型有更多属性的对象。例如，我们可以编写类似下面的代码:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="f5a2" class="mq lf it mm b gy mr ms l mt mu">interface Person {<br/>  name: string;<br/>  age: number;<br/>}</span><span id="a1fb" class="mq lf it mm b gy mv ms l mt mu">let person = { name: 'Joe', age: 10, gender: 'male' };</span><span id="f2d1" class="mq lf it mm b gy mv ms l mt mu">function echo(person: Person) {<br/>  return person;<br/>}</span><span id="b9d0" class="mq lf it mm b gy mv ms l mt mu">echo(person);</span></pre><p id="64f8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mw mx my mm b">person</code>对象有一个不在<code class="fe mw mx my mm b">Person</code>接口中的<code class="fe mw mx my mm b">gender</code>属性。但是<code class="fe mw mx my mm b">echo</code>函数中的<code class="fe mw mx my mm b">person</code>参数属于<code class="fe mw mx my mm b">Person</code>类型。考虑到这一点，我们仍然可以将<code class="fe mw mx my mm b">person</code>作为<code class="fe mw mx my mm b">echo</code>函数调用的第一个参数传递给它。TypeScript不关心我们传入的参数中是否有额外的属性。另一方面，如果我们的参数缺少属性，那么TypeScript会给我们一个错误，并且不会编译代码。例如，如果我们有以下代码:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="df90" class="mq lf it mm b gy mr ms l mt mu">interface Person {<br/>  name: string;<br/>  age: number;<br/>}</span><span id="ec17" class="mq lf it mm b gy mv ms l mt mu">let person = { name: 'Joe' };</span><span id="485e" class="mq lf it mm b gy mv ms l mt mu">function echo(person: Person) {<br/>  return person;<br/>}</span><span id="46e7" class="mq lf it mm b gy mv ms l mt mu">echo(person);</span></pre><p id="1362" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们会得到错误:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="54d4" class="mq lf it mm b gy mr ms l mt mu">Argument of type '{ name: string; }' is not assignable to parameter of type 'Person'.</span><span id="86aa" class="mq lf it mm b gy mv ms l mt mu">Property 'age' is missing in type '{ name: string; }' but required in type 'Person'.(2345)</span><span id="f5fe" class="mq lf it mm b gy mv ms l mt mu">input.ts(3, 3): 'age' is declared here.</span></pre><p id="23af" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">类型兼容性的结构检查是递归完成的。所以同样的检查也适用于任何嵌套层次的对象。例如，如果我们有:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="1ef0" class="mq lf it mm b gy mr ms l mt mu">interface Person {<br/>  name: string;<br/>  age: number;<br/>  address: {<br/>    street: string;<br/>  }<br/>}</span><span id="3a7b" class="mq lf it mm b gy mv ms l mt mu">let person = { name: 'Joe', age: 20, address: {street: '123 A St.'} };</span><span id="9269" class="mq lf it mm b gy mv ms l mt mu">function echo(person: Person) {<br/>  return person;<br/>}</span><span id="59ad" class="mq lf it mm b gy mv ms l mt mu">echo(person);</span></pre><p id="ba69" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这将通过由TypeScript完成的结构类型检查，因为每个级别的所有属性都存在。另一方面，如果我们有:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="1383" class="mq lf it mm b gy mr ms l mt mu">interface Person {<br/>  name: string;<br/>  age: number;<br/>  address: {<br/>    street: string;<br/>  }<br/>}</span><span id="0f7b" class="mq lf it mm b gy mv ms l mt mu">let person = { name: 'Joe', age: 20, address: { } };</span><span id="7ecf" class="mq lf it mm b gy mv ms l mt mu">function echo(person: Person) {<br/>  return person;<br/>}</span><span id="1779" class="mq lf it mm b gy mv ms l mt mu">echo(person);</span></pre><p id="6a7a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么TypeScript编译器会给出以下错误:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="f1c8" class="mq lf it mm b gy mr ms l mt mu">Argument of type '{ name: string; age: number; address: {}; }' is not assignable to parameter of type 'Person'.</span><span id="8c54" class="mq lf it mm b gy mv ms l mt mu">Types of property 'address' are incompatible.</span><span id="2263" class="mq lf it mm b gy mv ms l mt mu">Property 'street' is missing in type '{}' but required in type '{ street: string; }'.(2345)</span><span id="2b1e" class="mq lf it mm b gy mv ms l mt mu">input.ts(5, 5): 'street' is declared here.</span></pre><p id="cd98" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为分配给<code class="fe mw mx my mm b">address</code>属性的对象中缺少<code class="fe mw mx my mm b">street</code>属性。</p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/d14483b349b4140d0902c2e2af72a68b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GKXM_HmKsRJHeXQ_"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@luipeng?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">雷鹏</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><h1 id="b3ee" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">比较函数</h1><p id="073f" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">比较对象及其类型的原始值非常简单。然而，确定哪些函数具有相互兼容的类型是比较困难的。在TypeScript中，我们可以将参数较少的函数赋给参数较多但函数签名相同的函数。例如，如果我们有:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="0af8" class="mq lf it mm b gy mr ms l mt mu">let x = (a: number) =&gt; 0;<br/>let y = (a: number, b: string) =&gt; 0;</span></pre><p id="8230" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们可以将<code class="fe mw mx my mm b">x</code>赋值给<code class="fe mw mx my mm b">y</code>，就像我们在下面的代码中做的那样:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="f586" class="mq lf it mm b gy mr ms l mt mu">y = x;</span></pre><p id="c007" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是因为，在JavaScript中，我们经常可以将默认情况下应该有更多参数的函数分配给有更少参数的函数。例如，array <code class="fe mw mx my mm b">map</code>方法接受一个回调函数，它有两个参数，一个是正在处理的数组条目，另一个是条目的数组索引。然而，我们有时只是传入一个只有第一个参数的回调函数，如下面的代码所示:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="12fa" class="mq lf it mm b gy mr ms l mt mu">let arr = ['a', 'b', 'c'];<br/>arr.map(a =&gt; a);</span></pre><p id="26e8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">TypeScript必须允许丢弃参数，以保持与JavaScript的兼容性。同样，为了比较返回类型，TypeScript确定返回类型具有更多属性的函数与具有较少属性但结构相同的函数兼容。例如，如果我们有如下代码中的两个函数:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="02ab" class="mq lf it mm b gy mr ms l mt mu">let fn1 = () =&gt; ({ name: "Alice" });<br/>let fn2 = () =&gt; ({ name: "Joe", age: 20 });</span></pre><p id="b606" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们可以将<code class="fe mw mx my mm b">fn2</code>赋值给<code class="fe mw mx my mm b">fn1</code>，如以下代码所示:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="2f92" class="mq lf it mm b gy mr ms l mt mu">fn1 = fn2;</span></pre><p id="0559" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，反过来就不行了:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="ece3" class="mq lf it mm b gy mr ms l mt mu">fn2 = fn1;</span></pre><p id="46ee" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们尝试编译上面的代码，我们会从TypeScript编译器得到以下错误:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="c4d7" class="mq lf it mm b gy mr ms l mt mu">Type '() =&gt; { name: string; }' is not assignable to type '() =&gt; { name: string; age: number; }'.</span><span id="b0c2" class="mq lf it mm b gy mv ms l mt mu">Property 'age' is missing in type '{ name: string; }' but required in type '{ name: string; age: number; }'.(2322)</span><span id="8bfc" class="mq lf it mm b gy mv ms l mt mu">input.ts(2, 33): 'age' is declared here.</span></pre><p id="c56e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我们所看到的，TypeScript接受属性更多的返回类型，而不是属性更少但结构相同的返回类型。</p><h1 id="721f" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="c49d" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">TypeScript通过对象和函数的结构来检查它们的数据类型。通常，如果两种类型具有相同的属性和数据类型，那么它们被认为是相同的类型。否则，属性比另一个多但结构相同的对象也被认为是兼容的。</p><p id="9db4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，如果一个函数的参数比另一个少，但结构相同，那么它们被认为是相同的。这也适用于由函数返回的对象的结构。如果一个函数返回的对象的属性比另一个函数多，而另一个函数返回的对象的属性比另一个函数少，但结构相同，那么这两种返回类型被认为是兼容的。</p></div></div>    
</body>
</html>