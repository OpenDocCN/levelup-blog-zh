# python——面向对象编程概述

> 原文：<https://levelup.gitconnected.com/python-object-oriented-programming-overview-f19f46eced85>

## 我对 Python 面向对象能力的笔记

你知道吗，父母更愿意让他们的孩子学习 Python 而不是法语？

![](img/8a4ab2fa2a1a35f4f187b5d444b6a14b.png)

在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上由 [Hitesh Choudhary](https://unsplash.com/@hiteshchoudhary?utm_source=medium&utm_medium=referral) 拍摄的照片

这是 Ocado Technology 不久前在英国进行的一项研究得出的结论。根据他们的说法，60%的父母宁愿让他们的孩子学习 Python 而不是法语。很有趣，不是吗？😉

考虑到这一点以及我手中的一些空闲时间，我决定尝试一下 Python，并从面向对象的角度重新审视该语言的基本关键特性。

从一个有趣的问题开始…

# Python 是面向对象的吗？

![](img/bed06e799c2e255e408e02887c0a48cf.png)

照片由[克里斯蒂娜·莫里洛](https://www.pexels.com/@divinetechygirl?utm_content=attributionCopyText&utm_medium=referral&utm_source=pexels)从 [Pexels](https://www.pexels.com/photo/python-book-1181671/?utm_content=attributionCopyText&utm_medium=referral&utm_source=pexels) 拍摄

一些作者会说 Python 可以被认为是一种基于对象的语言，而不是真正的面向对象的语言。主要是因为在 Python 中一切都是对象，但面向对象编程本身只是语言中的一个可选特性，与 Java 等语言相反。

从这个角度来看，人们也可以说 Python 是一种多范例语言，完全支持**面向对象编程**、**结构化编程**，以及对**函数式编程**的一些支持。

接下来让我们仔细看看 Python 是如何实现关键的 O.O .概念的:

# 目标

对象是面向对象编程的主要明星，旨在通过将数据和行为封装在单个实体中来表示现实世界的元素。如果你问我的话，这是一个非常重要的角色！

在 Python 中，**一切**都是对象。这包括任何东西，甚至数字、字符串、函数和模块。因此一切都可以分配给一个**变量**。

使用 Python，我们从**类**规范中创建对象。

# 班级

类是用于创建对象的蓝图。它们定义了一个对象可以**拥有** *的状态——数据——***以及一个对象可以**做什么***——行为*。**

**如果机器人是对象，那么机器人类就是它的蓝图。**

**类别定义示例**

**每当需要或请求一个新对象时，Python 程序将从其蓝图中构造这些对象。构造的对象将包含所有指定的函数和属性。**

# **方法**

**方法指定对象可以做什么。在 Python 中，我们使用 ***def*** 关键字定义方法——就像函数一样，但是方法包含在类中。在我们前面的例子中， ***sayHello*** 是一个方法定义。**

**所有方法都必须将 ***self*** 作为它们的第一个参数。**

# **自己**

**Python 程序中作为方法中第一个参数的 ***self*** 参数，指的是类本身的实例。**

**需要注意的是， ***self*** 只是一个变量名，与 C++、C#、Java 等语言的*关键字不同，***self***可以根据需要进行更改，尽管**不鼓励这样做。*****

***在这里，最被接受的惯例是总是使用 ***自我*** 。***

***方法接收**自身**和**人员名称**参数***

# ***构造器***

***Python 使用 ***__init__*** 方法来构造一个处于**预定义初始状态**的对象。 ***__init__*** 方法是一个**构造函数**方法，一旦对象被实例化就会被执行。***

***与任何其他方法一样，对正在构造的实例的引用作为第一个参数传递。***

***使用**构造函数**的类定义***

# ***包装***

***Python 主要用于将行为和数据捆绑和封装在一起，防止外部代理无意中造成副作用，它主要为我们提供了 3 个级别的封装和一些注意事项:***

*   *****私有**:方法和变量以双下划线**__** 为前缀***
*   *****受保护的**:方法和变量以单下划线**_** 为前缀***
*   ***公共的:其他的一切***

***两个封装字段:**_ _ 名称**和 **__isEnabled*****

***在上例中， ***__name*** 和 *__isEnabled* 都是 **private*** 变量。***

******** 关于封装，Python 只是隐藏了被封装的成员，但是仍然可以使用类的父类名+字段名来访问该成员。按照我们的例子，那将是***_ 机器人 _ _ 名字***** 。***

***Python 从未真正限制对受保护的成员的访问。因此，在 Python 中没有什么是真正私有的。***

**** *上面的黑客很有趣，但是，现在你必须保证永远不会在任何产品代码中使用它！😁***

**** * *说真的，永远不要用它…***

# ***性能***

***如果需要访问内部成员以向外界公开内部字段，那么可以而且应该使用属性。***

***在 Python 中，属性是通过属性的用法来定义的: ***、@property*** 、 ***、@setter*** 和 ***、@deleter:******

***使用**属性**作为私有字段的访问器***

# ***遗产***

***Python 继承将允许我们从父类中派生出类— *又名:基类*。***

***要从基类创建子类，子类必须在其声明名称前包含一组括号，指定其父基类:***

***带有**机器人基类**的**飞行机器人**的虚拟例子***

***子类将可以访问基类的所有实例变量和方法，**包括**私有和受保护的方法。***

# ***接口***

***一个接口定义了一个对象必须拥有的所有方法，不管它的真实类型是什么。该接口将定义应该由其子类型实现的抽象方法。***

***这里重要的是:***

*   ***Python 为我们提供了两种不同的接口定义方式:非正式接口和正式接口***
*   ***Python 不包含`interface`关键字(…我看着你们这些 Java 和 C#的乡亲们！)***

## ***非正式界面***

***非正式接口是一个 Python 类，它定义了应该被它的子类覆盖的方法，但是这种覆盖不是必须的。***

***非正式界面***

## ***正式接口——又名:抽象基类(ABC)***

***正式接口是强制实现的接口。这些是通过使用`abc` Python 模块创建的:***

***与 ABC 的正式接口***

# ***静态方法***

***静态方法是不绑定到对象，而是绑定到类的方法。因此不强制要求为了执行它们而需要创建对象。***

***定义静态方法时，使用属性 ***@staticmethod*** :***

***静态方法**版本()*****

# ***最后的想法***

***花时间去理解像面向对象这样一个已知的概念是如何在 Python 中使用的，以及围绕它的语言的思维模式，对我来说是非常有启发性和令人满意的。***

***事实证明，Python 是一种简单的语言，不需要太多的设置就可以开始编码，语法简单明了，看起来非常像简单明了的英语。毫不奇怪，这种语言在脚本、自动化，包括最近的科学领域，如数据分析、人工智能，以及有时替代 MATLAB 和 r。***

***回到那些宁愿让他们的孩子学习 Python 而不是法语的父母(…我自己也尝试过法语，但放弃了太多次😉)，他们可能终究有道理。***

***关于 Python 的 ***面向对象的*** 能力，它们似乎符合语言的动态本质。提供了大部分核心概念，而没有对编码人员的能力做太多限制。***

***从该语言处理私有字段和封装的方式也可以看出这一点。并不是真的阻止我们访问私有字段和信息，而是把它们放在一边或者隐藏起来。C++和 Java 之类的语言没有这种思维模式。***

***用我在 Python 邮件列表上找到的一句话简单地说…***

> ***“…我们都是自愿的成年人…”—[Python 邮件](https://mail.python.org/pipermail/tutor/2003-October/025932.html)***

# ***其他资源***

*   ***[Python 文档](https://docs.python.org/3/)***
*   ***[Python 下载](https://www.python.org/downloads/)***
*   ***[什么是 Pythonic？](https://mail.python.org/pipermail/tutor/2003-October/025932.html)***