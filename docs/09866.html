<html>
<head>
<title>Truth About { SOAP vs REST vs GRPC vs GraphQL } Checklist</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">{ SOAP vs REST vs GRPC vs GraphQL }清单的真相</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/truth-about-soap-vs-rest-vs-grpc-vs-graphql-checklist-f50bcb475adf?source=collection_archive---------2-----------------------#2021-09-25">https://levelup.gitconnected.com/truth-about-soap-vs-rest-vs-grpc-vs-graphql-checklist-f50bcb475adf?source=collection_archive---------2-----------------------#2021-09-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/5c49ff360f6dd09b0d71e01dcf9290f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u7wcLwOgCroYs8JrOHGCoQ.jpeg"/></div></div></figure><p id="db6e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">简介</strong></p><p id="ad0e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">随着比较的进行，这似乎有点奇怪。虽然前两个是通用的竞争“标准”，但这两个不同的标准具有某种独特的范围。<br/>他们的共同点是经常出现的统计操纵的概念。它们中的每一个都允许外部实体在一定限度内访问您的信息。</p><p id="d9cf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">肥皂</strong></p><p id="d678" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">“简单对象访问协议”(虽然这个意思已经被遗忘了，因为它很简单)是我大学里最古老也是最忌讳的文件访问机器。<strong class="kd iu"> </strong>它通过HTTP传递XML内容的使用(大多数时候<strong class="kd iu"> </strong>，然而，遍历不是时尚<strong class="kd iu">，</strong>的一部分，所以它应该在任何东西上使用)用于通过服务调用检测标准的特定目的。<br/>这迫使提供者描述可用的程序、它们的参数和类型、正文格式、响应等。、和对象。我敢打赌，你一定看到了简单在很久以前就消失了。</p><p id="ff06" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">优点</strong></p><ul class=""><li id="bdfb" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated">SOAP批准了主要基于XML的代码技术，XML是众所周知的，并且无处不在，具有很大的灵活性(例如，名称空间)。</li><li id="da89" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">因为它是基于文本的，所以调试很方便，并且对传输没有限制。由于这些方法是在WSDL中描述的，因此该文件充当赞赏消息和类型的绑定契约。</li></ul><p id="70ef" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">缺点</strong></p><ul class=""><li id="977c" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated">XML非常冗长，对消息的度量往往呈指数级增长。SOAP必然是单向的(因为客户机不能添加服务器，反之亦然，即使每个功能都可以充当网络服务器)。</li><li id="b4ac" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">当前语言对代码技术的支持很少(你的首选是Java、Python和C#，而带有Go/Rust/PHP/Elixir的SOAP是令人失望的训练例程)<strong class="kd iu">。</strong></li><li id="4eec" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">总的来说，<strong class="kd iu">，</strong> SOAP仍然在支持更灵活、更环保的口头交流技术(尽管在一些保险和银行<strong class="kd iu"> </strong>工作之后，我的噩梦又回来了)。排)。</li></ul><p id="28ce" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">休息</strong></p><ul class=""><li id="4782" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated">当有人说<strong class="kd iu">“</strong>Web API”时，大多数人可能会假设这是代表性转换。事实上，这是众所周知的，当有人说“API”时，它就是人类使用的元素，更不用说网络(或HTTP)部分了。</li><li id="4dc4" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">作为一个标准，它是极其轻量级的，因为它指定了<strong class="kd iu"> </strong>专门使用HTTP和HTTP标准(动词、代码、状态等。)</li><li id="e96a" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">这导致了许多围绕<strong class="kd iu"> </strong> REST的最佳<strong class="kd iu"> </strong>实践场景，处理非dit:如何描述和排序URIs，将操纵的统计限制到某个URI，如何封装数据，如何返回以及返回什么，等等。</li><li id="ae39" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">REST提供的另一个重要特性是无状态性:请求之间没有上下文，每个请求都被单独处理，并且必须有自己的<strong class="kd iu">目的。</strong></li><li id="74da" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">虽然JSON是REST数据最常见的内容类型，但是XML已经不是什么<strong class="kd iu"> </strong>的谜了，HTML本身就有了。</li></ul><p id="8da0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">优点</strong></p><p id="6c66" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">基于现有的HTTP请求，它具有所有的灵活性和限制。大多数流量问题都是通过使用当前需求并随其发展而解决的。与交易相关的动词(例如，简化CRUD交易的映射)，证券借贷实体，以及这对URIs意味着什么。简单的约定使得与REST API的交互相当简单。JSON使得REST特别容易用于前端服务，在前端服务中，JS普遍存在于记录到对象的即时转换中。此外，JSON可读性很强，对于调试也很有用。</p><p id="b9ab" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">缺点</strong></p><p id="448c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">实际上，REST服务几乎从未接近预期。当检测到的实体与统计层中建模的信息相匹配时(提示:不要透露事实)，使用哪些动词有无数的争论。那种细节，用DTO赢。).灵活性经常导致实现混乱，最重要的是，在用于消息的形式上没有绑定契约。我的一个国内小偷是当一个人仍然返回一个HTTP 200响应，并进而将错误的感觉编码到响应体中。</p><p id="743f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> GRPC </strong></p><ul class=""><li id="b651" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated">gRPC是来自Google的现代轻量级通信协议。…它是一个递归缩写，代表grpc远程过程调用。gRPC起源于2015年的Google。它基于一个名为Stubby的谷歌内部项目，这是一个gRPC的内部框架，但只针对谷歌服务。</li><li id="64db" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">gRPC是一个现代的、开源的远程过程调用(RPC)框架，可以在任何地方运行。它使客户机和服务器应用程序能够透明地通信，并使构建连接的系统变得更加容易。</li></ul><p id="869c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">优点</strong></p><p id="e1bd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">非常有效。它利用了HTTP/2所提供的一切，因此您可以同步发送问题(等待响应)，可以广播，可以多路传输，所有这些都在同一个连接上进行。加上二进制消息非常小的事实，对于整体性能至关重要的情况，您有很多好处。代码时代使它变得更容易，而HTTP/2需要TLS，所以您在一些压力下需要最低限度的安全性。</p><p id="5cbf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">缺点</strong></p><p id="8eed" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">难以调试，因为消息是二进制的，现在人类无法阅读。虽然它在所有语言中都受支持，但仍有一些障碍(例如，没有PHP gRPC服务器，只有一个客户端),并且由于HTTP / 2的性质，该应用程序的用户界面中可能没有任何帮助(目前)。因为您应该(而且应该)在任何地方都有TLS，所以您可能希望安装一个基本组件(无论是从可信CA获得内部使用的证书，还是开发一个CA)来解决您自己的内部证书问题，但是，您可能希望在整个基础结构/容器等中将其添加为可信组件。</p><p id="e65d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">图表QL </strong></p><p id="248f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">GraphQL允许您在单个查询中查询您想要的内容，从而节省带宽并减少瀑布请求。它还使客户能够请求他们自己独特的数据规范。API开发人员使用GraphQL创建一个模式来描述客户端可以通过该服务查询的所有可能的数据。GraphQL模式由对象类型组成，对象类型定义了您可以请求哪种对象以及它拥有哪些字段。当查询进来时，GraphQL根据模式验证查询。</p><p id="b6c4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">优点</strong></p><p id="8843" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">它对JSON的依赖使它成为非常强大的REST，但是通过引入自适应查询功能的优势，您可以以自己喜欢的方式请求您想要的统计信息= &gt;不，要获得您需要的一切，需要的条件不止一个。它有模式验证和输入，所以这个测试非常接近gRPC如何定义事物。</p><p id="58ae" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">缺点</strong></p><p id="e0c9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所有的灵活性都会影响缓存的潜力。几乎没有GraphQL查询可以与委托缓存相比。尽管有这个名字，但它不再是一个设计精美的界面。例如，你不能得到一个守护实体的所有祖先。</p><p id="274a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">感谢您的阅读，请在评论区告诉我您的问题、想法或反馈。感谢您的反馈和鼓励。</p><p id="2a6d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">继续学习！</p></div></div>    
</body>
</html>