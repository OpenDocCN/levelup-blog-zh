<html>
<head>
<title>The “ref” keyword in Rust</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Rust中的“ref”关键字</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/the-ref-keyword-in-rust-a81e64cda3af?source=collection_archive---------5-----------------------#2020-11-20">https://levelup.gitconnected.com/the-ref-keyword-in-rust-a81e64cda3af?source=collection_archive---------5-----------------------#2020-11-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/4209f0acee7dd4a332e3ab977e3b843c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zpRBVaZMzVdgZa9c"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">贝丝·麦克唐纳在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="ec40" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Rust有一个非常强大的模式匹配系统。您可以匹配文字、结构、枚举、切片(不同长度)、结构中的特定字段(通过解构造)、嵌套字段、引用、范围等。</p><p id="6690" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设我们对Rust中的模式匹配有一个相当好的理解，让我们探索一下<code class="fe lb lc ld le b">ref</code>关键字以及<code class="fe lb lc ld le b">ref</code>和<code class="fe lb lc ld le b">&amp;</code>之间的关系，当涉及到模式匹配的时候。</p><p id="06a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Eg1:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="5f55" class="ln lo iq le b gy lp lq l lr ls">let x:i32 = 1;<br/>match x {<br/>  ref y =&gt; println!("{}", *y),<br/>  _ =&gt; ()<br/>}</span></pre><p id="7d26" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的代码片段是一个非常简单的例子(<em class="lt">很明显,“默认”条件永远不会被满足。但是这里我们可以忽略这一点，为了这个话题</em>。基本上，<code class="fe lb lc ld le b">ref</code>在比赛结束后开始发挥作用。即“匹配，然后将绑定变量视为引用”。这里，匹配后，变量<code class="fe lb lc ld le b">y</code>被绑定到<code class="fe lb lc ld le b">x</code>的引用。</p><p id="e80a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们看下一个例子:</p><p id="9c51" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Eg2:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="6fce" class="ln lo iq le b gy lp lq l lr ls">let x:i32 = 1;<br/>match &amp;x {<br/>  y =&gt; println!("{}", *y),<br/>  _ =&gt; ()<br/>}</span></pre><p id="bc46" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里，<code class="fe lb lc ld le b">match</code>的操作数是一个引用，这意味着变量<code class="fe lb lc ld le b">y</code>将被绑定到整个操作数。这是另一个例子，</p><p id="9403" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Eg3:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="f56a" class="ln lo iq le b gy lp lq l lr ls">let x:i32 = 1;<br/>match &amp;x {<br/>  &amp;y =&gt; println!("{}", y),<br/>  _ =&gt; ()<br/>}</span></pre><p id="805d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">操作数is <code class="fe lb lc ld le b">&amp;x</code>在case ( <code class="fe lb lc ld le b">&amp;y</code>)中被解构造，只有值部分<code class="fe lb lc ld le b">y</code>被提取(复制)。注意区别；<code class="fe lb lc ld le b">&amp;</code>参与匹配过程，而<code class="fe lb lc ld le b">ref</code>不参与。如果操作数不是引用，此示例将给出编译错误。</p><p id="0b54" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从可读性的角度来看，Eg1更好。实际上没有必要把引用传递给<code class="fe lb lc ld le b">match</code>块，如果类型不是<code class="fe lb lc ld le b">Copy</code>呢？Eg3不会编译，因为当一个值在一个引用后面时，你不能将它移出。</p><p id="5131" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们再看一些例子。</p><p id="8e5a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里有一个例子，我们去构造一个自定义类型(枚举)并引用它的变体的字段。</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="2b20" class="ln lo iq le b gy lp lq l lr ls"><strong class="le ir">enum Shape {<br/>  Circle(u8),<br/>  Rectangle(u8, u8),<br/>  Triangle(u8, u8)<br/>}</strong></span><span id="da2c" class="ln lo iq le b gy lu lq l lr ls"><em class="lt">// where `shape` is an instance of `Shape`</em> <br/><strong class="le ir">match shape {<br/>   </strong><em class="lt">// `radius` is of type &amp;u8, due to ref<br/></em><strong class="le ir">   Circle(ref radius) =&gt; circle_area(radius),</strong></span><span id="c1ca" class="ln lo iq le b gy lu lq l lr ls"><strong class="le ir">   </strong><em class="lt">// `length` and `width` are of type &amp;u8, due to ref<br/></em>  <strong class="le ir"> Rectangle(ref length, ref width) =&gt; rect_area(length, width),</strong> </span><span id="753c" class="ln lo iq le b gy lu lq l lr ls"><em class="lt">   // `base` and `height` are of type &amp;u8, due to ref</em><br/>   <strong class="le ir">Triangle(ref base, ref height) =&gt; triangle_area(base, height)</strong> <br/><strong class="le ir">}</strong></span></pre><p id="c1e3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里有一个例子，我们解构造了<code class="fe lb lc ld le b">struct</code>，然后匹配它的一个字段，并在另一个字段上引用。</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="80f8" class="ln lo iq le b gy lp lq l lr ls">enum FoodType {<br/>    Soda,<br/>    Pizza<br/>}</span><span id="ad30" class="ln lo iq le b gy lu lq l lr ls">struct Details {<br/>    name : String,<br/>    calories : u16,<br/>}</span><span id="118d" class="ln lo iq le b gy lu lq l lr ls">struct Food {<br/>    category : FoodType,<br/>    details : Details<br/>}</span><span id="19aa" class="ln lo iq le b gy lu lq l lr ls">fn consume(p: Food) {<br/>    match p {<br/>        Food {<br/>            category: Soda,<br/>            details: ref d,<br/>        } =&gt; sip(d),<br/>        Food {<br/>            category: Pizza,<br/>            details: ref d,<br/>        } =&gt; bite(d),<br/>    }<br/>}</span></pre><p id="91cc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们将<code class="fe lb lc ld le b">&amp;p</code>传递给<code class="fe lb lc ld le b">match</code>块会怎么样？那能编译吗？</p><p id="4702" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">是啊！它可以编译。注意案例中的模式。它们都是值，所以为了匹配，编译器首先自动解引用(<code class="fe lb lc ld le b">*p</code>)。如果它是<code class="fe lb lc ld le b">&amp;&amp;p</code>，那么它将自动去友两次，以此类推...</p><p id="f3cb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这意味着<code class="fe lb lc ld le b">d</code>是一个引用，因为操作数是一个引用。</p><p id="f9f0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么我们还需要保留关键字<code class="fe lb lc ld le b">ref</code>吗？虽然代码仍然可以编译，但是这个场景中的<code class="fe lb lc ld le b">ref</code>是多余的，我们在这里不需要它。</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="d8fb" class="ln lo iq le b gy lp lq l lr ls"><strong class="le ir">fn consume(p: Food) {</strong><br/>    <strong class="le ir">match &amp;p {</strong>  // could very well be &amp;&amp;p, &amp;&amp;&amp;p ...<br/>        <strong class="le ir">Food {<br/>            category: Soda,<br/>            details: d,</strong> // `ref d` or `d`,both are same i.e &amp;Details<br/>        <strong class="le ir">} =&gt; sip(d),<br/>        Food {<br/>            category: Pizza,<br/>            details: d,</strong> // `ref d` or `d`,both are same i.e &amp;Details<br/>        <strong class="le ir">} =&gt; bite(d),<br/>    }<br/>}</strong></span></pre><p id="bf47" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一个鲜为人知的用法(模式匹配之外)是引用变量。</p><p id="1c30" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">基本上是下面的片段:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="4073" class="ln lo iq le b gy lp lq l lr ls">let y = &amp;mut x;</span></pre><p id="7d1d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">可以写成</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="164b" class="ln lo iq le b gy lp lq l lr ls">let ref mut y = x;</span></pre><p id="3eab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就是这样！希望你会发现这篇简短的文章信息丰富。</p></div></div>    
</body>
</html>