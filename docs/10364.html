<html>
<head>
<title>Let’s Loop Data Inside a React Component</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们在React组件中循环数据</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/lets-loop-data-inside-a-react-component-832e9130ed0f?source=collection_archive---------1-----------------------#2021-11-29">https://levelup.gitconnected.com/lets-loop-data-inside-a-react-component-832e9130ed0f?source=collection_archive---------1-----------------------#2021-11-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a7e5" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">一篇文章中的所有方法都有沙盒代码可供使用</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/5c30785da41c40ade40f0e398c2c126f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*nXHTj1Wu1QHrgXNE.png"/></div></div></figure><p id="3afe" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">今天我将讨论我作为初学者开发React应用程序时面临的主要疑惑之一。我总是不得不使用StackOverflow并查看循环方法来从JSON响应中获取值。</p><p id="23d8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我想到了在react组件中添加所有基本的循环方法。</p><p id="55a5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们从API获取数据主要有两种方式。最常见的是通过JSON数组。我们使用的另一种方法是在单个JSON对象中循环。</p><h1 id="3240" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">遍历数组</h1><h2 id="64af" class="mi lr it bd ls mj mk dn lw ml mm dp ma ld mn mo mc lh mp mq me ll mr ms mg mt bi translated">遍历JSON数组对象</h2><p id="6468" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">这是我们大部分时间不得不处理的最常见的方法</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="1b1b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以使用<code class="fe nb nc nd ne b">.map</code>遍历数组，并使用模板文字<code class="fe nb nc nd ne b">{}</code>访问每个对象元素</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/225238752d5c85d470f8bf8f54b7886a.png" data-original-src="https://miro.medium.com/v2/resize:fit:666/format:webp/1*WRZVv4jiPuZCNHRwn5gmtw.png"/></div></figure><p id="e730" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您查看控制台，您会在控制台中看到以下警告</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/206eb72614e9957b7e5a713115e0076d.png" data-original-src="https://miro.medium.com/v2/resize:fit:632/format:webp/1*xkghKS7jEBEf3q81MHL7uA.png"/></div></figure><p id="ee34" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这个警告是说给每个元素添加一个关键道具。原因与react识别UI变化的方式有关。react.js被创建的主要原因是其优化的DOM树呈现。React使用这个唯一的键值来标识每次渲染时列表中是否有变化。如果值1被更改，它只在dom中呈现该值并更新它，这使得在dom操作中反应如此之快。</p><p id="ae35" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们像这样添加一个键值</p><pre class="kj kk kl km gt nh ne ni nj aw nk bi"><span id="5a7d" class="mi lr it ne b gy nl nm l nn no">{people.map((data, idx) =&gt; (<br/>&lt;p key={idx}&gt;{data.name}&lt;/p&gt;<br/>))}</span></pre><h1 id="4195" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">对对象循环作出反应</h1><h2 id="2483" class="mi lr it bd ls mj mk dn lw ml mm dp ma ld mn mo mc lh mp mq me ll mr ms mg mt bi translated">循环遍历对象而不是数组</h2><p id="1752" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">如果我们想循环遍历一个对象，我们必须使用<code class="fe nb nc nd ne b">Object.keys(objectName)</code>方法。然后我们可以用对象的所有键值创建一个数组。</p><p id="830e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后我们可以使用<code class="fe nb nc nd ne b">map</code>遍历这些键值，并得到如下所示的值</p><pre class="kj kk kl km gt nh ne ni nj aw nk bi"><span id="2957" class="mi lr it ne b gy nl nm l nn no">{Object.keys(person).map((key) =&gt; (<br/>&lt;p&gt;{person[key]}&lt;/p&gt;<br/>))}</span></pre><h2 id="2d12" class="mi lr it bd ls mj mk dn lw ml mm dp ma ld mn mo mc lh mp mq me ll mr ms mg mt bi translated">为什么总是映射</h2><p id="086d" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">因为不像<code class="fe nb nc nd ne b">foreach </code>或者<code class="fe nb nc nd ne b">for</code>循环。map()返回一个新数组。所以当发送参数到函数映射内部的返回方法时，因为它返回一个数组。</p><pre class="kj kk kl km gt nh ne ni nj aw nk bi"><span id="e266" class="mi lr it ne b gy nl nm l nn no">return([array])</span></pre><h2 id="592f" class="mi lr it bd ls mj mk dn lw ml mm dp ma ld mn mo mc lh mp mq me ll mr ms mg mt bi translated">对于循环</h2><p id="8eba" class="pw-post-body-paragraph ku kv it kw b kx mu ju kz la mv jx lc ld mw lf lg lh mx lj lk ll my ln lo lp im bi translated">我们可以在返回函数之外使用for循环来创建一个包含所需jsx的数组，并将整个数组添加到返回函数中</p><p id="7573" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">参见下面的代码</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi np"><img src="../Images/1b256e6457907ea1dcf39ce7ea07508d.png" data-original-src="https://miro.medium.com/v2/resize:fit:798/format:webp/1*CQ3ekY15W7EgeJIjV2V_gA.png"/></div></figure><p id="8782" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以像这样在返回中添加错误细节</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/faffbff71f498f74e9293d4cafcd5fa6.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*Fe-9A59TcKNOqzhlU9H2nw.png"/></div></figure><p id="fdec" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以使用任何形式的js数组<code class="fe nb nc nd ne b">while</code> <code class="fe nb nc nd ne b">foreach</code>或者任何外部的return。生成预期的jsx并将其添加到数组中。然后在返回函数中使用该数组。</p><p id="b2dd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">下面的沙盒中给出了完整的代码，供您尝试和测试</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nr na l"/></div></figure><blockquote class="ns nt nu"><p id="8a94" class="ku kv nv kw b kx ky ju kz la lb jx lc nw le lf lg nx li lj lk ny lm ln lo lp im bi translated">我希望你喜欢读这篇文章。如果你愿意支持我作为一个作家和我分享知识的时间，考虑注册<a class="ae nz" href="https://freelancingcult.medium.com/membership" rel="noopener">成为一个媒体成员</a>。每月只需5美元，你就可以无限制地使用Medium。</p></blockquote><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="1b21" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">输出</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/fd26064cd0cf22b0164def60111b3868.png" data-original-src="https://miro.medium.com/v2/resize:fit:714/format:webp/1*UvT7U2MNzMDLTmX900IsLA.png"/></div></figure><blockquote class="ns nt nu"><p id="e42d" class="ku kv nv kw b kx ky ju kz la lb jx lc nw le lf lg nx li lj lk ny lm ln lo lp im bi translated">如果你愿意支持我成为一名作家，考虑注册<a class="ae nz" href="https://freelancingcult.medium.com/membership" rel="noopener">成为一名媒体成员</a>。这样我就可以花更多的时间来分享知识。每月只需5美元，你就可以无限制地使用Medium。</p></blockquote></div></div>    
</body>
</html>