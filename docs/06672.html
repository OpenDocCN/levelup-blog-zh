<html>
<head>
<title>Road to Go Pro — Packages &amp; Modules</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Pro之路—软件包和模块</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/road-to-go-pro-packages-modules-5b8aebe6a4e4?source=collection_archive---------8-----------------------#2020-12-18">https://levelup.gitconnected.com/road-to-go-pro-packages-modules-5b8aebe6a4e4?source=collection_archive---------8-----------------------#2020-12-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="85a2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">开始前说几句。你可以在这个</em> <a class="ae kp" href="https://github.com/songx23/RoadToGoPro" rel="noopener ugc nofollow" target="_blank"> <em class="ko">资源库</em> </a> <em class="ko">中找到本教程使用的代码。你可以在这里</em>  <em class="ko">找到Road to Go Pro </em> <a class="ae kp" href="https://medium.com/@songx/road-to-go-pro-f9d1f8a51fad" rel="noopener"> <em class="ko">的全部内容。如果你错过了最后一个，你可以通过这个</em> </a><a class="ae kp" rel="noopener ugc nofollow" target="_blank" href="/road-to-go-pro-pointer-functions-1b4f18b4fdb0"> <em class="ko">链接</em> </a> <em class="ko">找到它。</em></p><p id="3a1c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">感谢您关注Go Pro之路。我们已经在前面的教程中学习了围棋的基础知识。在这一节中，我们将探索包和模块。当你开始构建围棋项目时，这些知识会派上用场。在我们开始之前，我强烈推荐查看这个<a class="ae kp" href="https://github.com/songx23/RoadToGoPro/tree/master/Part05-packages-and-modules" rel="noopener ugc nofollow" target="_blank">存储库(第05部分)</a>中的示例项目。让我们开始吧。</p><h1 id="27e0" class="kq kr it bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">包装</h1><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi lo"><img src="../Images/9b34c7b1e0ad957ac82319b2521cd2a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0iZv0zTCsJI8HDaD"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">照片由<a class="ae kp" href="https://unsplash.com/@brandablebox?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">可贴牌盒</a>放在<a class="ae kp" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上</figcaption></figure><p id="a95c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你可能在很多编程语言中听说过包这个概念，比如Java、C#和python。通常，包是一个可重用和可移植的代码单元。在大多数Go项目中，你可以找到外部包(来自第三方模块)和内部包。使用包的好处是:</p><ol class=""><li id="629d" class="me mf it js b jt ju jx jy kb mg kf mh kj mi kn mj mk ml mm bi translated">使用外部包有助于节省大量时间来从头构建我们想要的功能。<em class="ko">“不要多此一举。”</em></li><li id="4d5c" class="me mf it js b jt mn jx mo kb mp kf mq kj mr kn mj mk ml mm bi translated">将相关代码分组到内部包中使代码库更具可读性和可维护性。</li><li id="2c6e" class="me mf it js b jt mn jx mo kb mp kf mq kj mr kn mj mk ml mm bi translated">当重新编译包中的代码时，它只会重新编译发生变化的部分。</li></ol><p id="71be" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，让我们看看如何在Go中声明包。</p><h2 id="ff5d" class="ms kr it bd ks mt mu dn kw mv mw dp la kb mx my le kf mz na li kj nb nc lm nd bi translated">申报</h2><p id="b904" class="pw-post-body-paragraph jq jr it js b jt ne jv jw jx nf jz ka kb ng kd ke kf nh kh ki kj ni kl km kn im bi translated">要创建一个包，我们需要创建三样东西:</p><ol class=""><li id="95e6" class="me mf it js b jt ju jx jy kb mg kf mh kj mi kn mj mk ml mm bi translated">项目中的包目录。在示例项目中，您可以在<code class="fe nj nk nl nm b">pkg</code>目录中看到一个名为<code class="fe nj nk nl nm b">stringset</code>的目录。注意，这个包目录不是直接放在根目录下。这完全没问题。你可以把它放在任何你想放的地方。按照惯例，内部包放在<code class="fe nj nk nl nm b">pkg</code>目录下。</li><li id="1f06" class="me mf it js b jt mn jx mo kb mp kf mq kj mr kn mj mk ml mm bi translated">包目录中至少有一个Go文件。在示例项目中，您可以看到在<code class="fe nj nk nl nm b">stringset</code>目录下有两个文件。</li><li id="fd80" class="me mf it js b jt mn jx mo kb mp kf mq kj mr kn mj mk ml mm bi translated"><code class="fe nj nk nl nm b">package</code>文件中的声明。在<code class="fe nj nk nl nm b">stringset</code>目录下的文件中，你可以发现它们都以一个包声明开始:<code class="fe nj nk nl nm b">package stringset</code>。</li></ol><p id="b2d4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有了这三样东西，就在Go中创建了一个包。很简单。但是，一个只有这三样东西的包，用处不大。当向包中添加函数和结构之类的东西时，我们需要考虑它们是否需要被导出。</p><h2 id="8181" class="ms kr it bd ks mt mu dn kw mv mw dp la kb mx my le kf mz na li kj nb nc lm nd bi translated">出口</h2><p id="f05b" class="pw-post-body-paragraph jq jr it js b jt ne jv jw jx nf jz ka kb ng kd ke kf nh kh ki kj ni kl km kn im bi translated">我们在之前的<a class="ae kp" rel="noopener ugc nofollow" target="_blank" href="/road-to-go-pro-flow-control-dfcc7b9a5395">教程</a>中讨论过<strong class="js iu">“变量作用域”</strong>。当时，我们简要地谈到了无障碍问题。在本节中，我们将再次讨论这个话题。</p><p id="3660" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">围棋中没有<code class="fe nj nk nl nm b">export</code>关键字。哪个元素被导出到“外部世界”是由其名称决定的。如果名称以大写字母开头，则会导出，反之亦然:以小写字母开头的名称不会导出。在示例项目中，您可以看到像<code class="fe nj nk nl nm b">NewUniqueStringSet</code>、<code class="fe nj nk nl nm b">Add</code>、<code class="fe nj nk nl nm b">Remove</code>和<code class="fe nj nk nl nm b">Format</code>这样的函数被导出。因此，它们可用于<code class="fe nj nk nl nm b">main.go</code>(在<code class="fe nj nk nl nm b">stringset</code>封装之外)。</p><p id="d32f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">包中声明的任何内容都可以导出。然而，我们需要关注导出元素的“依赖性”。例如，如果我们不从<code class="fe nj nk nl nm b">stringset</code>包中导出struct <code class="fe nj nk nl nm b">UniqueStringSet</code>，它的一个导出函数<code class="fe nj nk nl nm b">NewUniqueStringSet()</code>将返回一个未导出的struct，这给消费者带来了不便。因此，最好导出依赖项，比如在导出函数的签名中使用的结构。</p><h2 id="7d8e" class="ms kr it bd ks mt mu dn kw mv mw dp la kb mx my le kf mz na li kj nb nc lm nd bi translated">导入</h2><p id="13e5" class="pw-post-body-paragraph jq jr it js b jt ne jv jw jx nf jz ka kb ng kd ke kf nh kh ki kj ni kl km kn im bi translated">进口是出口的反义词。作为包的消费者，我们需要导入它以便使用它。从<a class="ae kp" href="https://medium.com/swlh/road-to-go-pro-types-structures-21e5fedc5fe0" rel="noopener">第二教程</a>(即<code class="fe nj nk nl nm b">import "fmt"</code>)开始我们就一直在用导入。当导入包时，我们需要在一条import语句中指定包名。如果您需要导入多个包，包名需要用括号括起来(包之间没有逗号)。或者，您可以为包名声明别名。通常，我们对长名字的包使用别名，以便引用它们变得更容易和更干净。</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="nn no l"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">导入包</figcaption></figure><h2 id="f4ed" class="ms kr it bd ks mt mu dn kw mv mw dp la kb mx my le kf mz na li kj nb nc lm nd bi translated">初始化功能</h2><p id="4630" class="pw-post-body-paragraph jq jr it js b jt ne jv jw jx nf jz ka kb ng kd ke kf nh kh ki kj ni kl km kn im bi translated"><code class="fe nj nk nl nm b">init</code>是围棋中的特殊功能。一个包可以被多次导入，但是它的<code class="fe nj nk nl nm b">init</code>函数在应用程序的生命周期中只运行一次。因此，<code class="fe nj nk nl nm b">init</code>功能被广泛用于初始化目的。它不是软件包中的一个强制功能，如果你不需要它，可以省略它。</p><p id="2abd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在示例包(<code class="fe nj nk nl nm b">stringset</code>)中，我使用了<code class="fe nj nk nl nm b">init</code>函数来初始化一个字符串处理器，该处理器将在后面的包中使用。</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="nn no l"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">初始化函数示例</figcaption></figure><h2 id="f78b" class="ms kr it bd ks mt mu dn kw mv mw dp la kb mx my le kf mz na li kj nb nc lm nd bi translated">证明文件</h2><p id="935d" class="pw-post-body-paragraph jq jr it js b jt ne jv jw jx nf jz ka kb ng kd ke kf nh kh ki kj ni kl km kn im bi translated">文档是包中必不可少的组成部分之一，尤其是当包被外部团体使用时。Go提供了一个工具<code class="fe nj nk nl nm b">godoc</code>，来帮助从注释中生成HTML文档。你可以从<a class="ae kp" href="https://godoc.org/" rel="noopener ugc nofollow" target="_blank"> GoDoc网站</a>查看Go文档的样子。它托管为公共包生成的文档。</p><p id="a70b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe nj nk nl nm b">godoc</code>在生成文档时，不接受所有的注释。它只获取声明顶部的注释。这些注释应该以声明的名称开始。有一个例外，对于包，注释应该以<code class="fe nj nk nl nm b">Package &lt;Package_Name&gt;</code>开始。</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="nn no l"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">godoc注释示例</figcaption></figure><p id="c43b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上例中的注释由<code class="fe nj nk nl nm b">godoc</code>收集，并生成漂亮的HTML文档(如下所示)。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi np"><img src="../Images/e2fe82817e3ba91057a9e7558fe32a92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lGstztX9fjcy0IDyGjCgXg.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">godoc HTML文档示例</figcaption></figure><p id="a999" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您想提供包的详细概述，您可能会发现在包声明的顶部添加长注释看起来很混乱。您可以通过创建一个<code class="fe nj nk nl nm b">doc.go</code>文件来优雅地解决这个问题。这是一个文档专用文件。您可以在其中添加任意多的细节。对了，Go中的多行注释符号是<code class="fe nj nk nl nm b">/* ... */</code>。</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="nn no l"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">专用doc.go示例</figcaption></figure><p id="bf4a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe nj nk nl nm b">doc.go</code>中的内容将出现在HTML文档的概述部分。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi nq"><img src="../Images/557a7ae1085332ee8b19cdc91f0a4541.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u0RhqX2KbqC9gOvoQ62A-Q.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">godoc HTML概述示例</figcaption></figure><p id="48ca" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要生成HTML文档，您需要运行<code class="fe nj nk nl nm b">godoc</code>命令行工具。默认情况下，运行<code class="fe nj nk nl nm b">godoc</code>会在端口<code class="fe nj nk nl nm b">6060</code>启动一个文档服务器。您可以在此找到关于此CLI <a class="ae kp" href="https://godoc.org/golang.org/x/tools/cmd/godoc" rel="noopener ugc nofollow" target="_blank">的更多详细信息。在示例项目的README文件中，您将找到关于<code class="fe nj nk nl nm b">godoc</code>的部分，它向您展示了如何导航到<code class="fe nj nk nl nm b">stringset</code>包文档。</a></p><h1 id="63aa" class="kq kr it bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">模块</h1><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi nr"><img src="../Images/4dc6292f129a3461430a3887034cf8c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YA95TV4qxqKwZonz"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated"><a class="ae kp" href="https://unsplash.com/@calebeangel?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">凯勒·安吉尔</a>在<a class="ae kp" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="fabe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Go在1.11版本中引入了新的依赖管理系统Go Modules。在过去，您需要将代码及其依赖项放在<code class="fe nj nk nl nm b">$GOPATH</code>下，Go才能正常工作。这很烦人，也违背了直觉。在本文撰写之时，Go的最新稳定版本是1.15。而且幸运的是，从1.13开始，围棋模块成为围棋开发的默认模式。现在，您可以将代码放在任何地方，并使用模块轻松管理依赖关系。</p><p id="90f1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Go模块是存储在一个带有<code class="fe nj nk nl nm b">go.mod</code>文件的目录中的包的集合。一个<code class="fe nj nk nl nm b">go.mod</code>文件，非常类似于Javascript世界中的一个<code class="fe nj nk nl nm b">package.json</code>文件，存储了关于当前项目中使用的依赖项的信息。</p><p id="66c2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要初始化新的Go模块，只需运行</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="nn no l"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">“go mod init”命令</figcaption></figure><p id="a013" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于如何命名一个模块没有特别的规则，但是通常，模块名以组织名开始，然后是模块名。例如，如果一个模块托管在Github上，那么完整的模块名应该类似于<code class="fe nj nk nl nm b">github.com/go-chi/chi</code>。</p><p id="2da5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一旦运行了<code class="fe nj nk nl nm b">go mod init</code>命令，您应该会看到在项目的根目录下创建了一个新的<code class="fe nj nk nl nm b">go.mod</code>文件。在该文件中，您应该看到您声明的模块名和您正在使用的当前go版本。</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="nn no l"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">go.sum文件示例</figcaption></figure><h2 id="2dfb" class="ms kr it bd ks mt mu dn kw mv mw dp la kb mx my le kf mz na li kj nb nc lm nd bi translated">属国</h2><p id="eb9f" class="pw-post-body-paragraph jq jr it js b jt ne jv jw jx nf jz ka kb ng kd ke kf nh kh ki kj ni kl km kn im bi translated">Go模块中使用的依赖项可以分为两类，分别是外部依赖项和内部包。</p><p id="1b6d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">外部依赖性</strong></p><p id="9113" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">外部依赖是已建立的模块，您可以将它们添加到您的模块中，并直接开始使用它们。添加外部依赖项非常简单。您运行<code class="fe nj nk nl nm b">go get</code>命令向您的模块添加所需的依赖项。</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="nn no l"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">添加依赖关系</figcaption></figure><p id="8c7b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">运行这个之后，您会在<code class="fe nj nk nl nm b">go.mod</code>文件中找到一个新行。</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="nn no l"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">go.mod文件中的外部依赖项</figcaption></figure><p id="f565" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这一行记录了您刚刚添加的依赖项的版本和模块名。注意,<code class="fe nj nk nl nm b">indirect</code>注释意味着您目前没有在任何源文件中使用依赖项。一旦开始使用，在终端中运行<code class="fe nj nk nl nm b">go mod tidy</code>后，间接注释就会消失。</p><p id="3c75" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您想升级您的依赖项的版本，您需要在<code class="fe nj nk nl nm b">go get</code>命令中添加<code class="fe nj nk nl nm b">-u</code>标志。</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="nn no l"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">升级依赖关系</figcaption></figure><p id="2e60" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Go模块也有一个供应商模式。如果它是打开的，Go会保存依赖项的源文件的副本。您可以选择在存储库中提交它们。这样，依赖关系对于任何使用这个库的人来说都是一致的。要启用供应商模式，您可以运行以下命令。</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="nn no l"/></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">打开供应商模式</figcaption></figure><p id="26c3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你会发现在根目录下创建了一个名为<code class="fe nj nk nl nm b">vendor</code>的新目录。依赖项的源文件存储在那里。当Go编译器检测到模块中有一个<code class="fe nj nk nl nm b">vendor</code>文件夹时，它会在检查你的<code class="fe nj nk nl nm b">$GOPATH</code>之前使用它。</p><p id="9725" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">内部包</strong></p><p id="e35e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在开发Go模块时，为一个工作单元创建一个包是非常常见的。对于您在模块内部创建的包，您无需运行<code class="fe nj nk nl nm b">go get</code>命令就可以引用它。</p><p id="f18d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要导入一个内部包，您需要将<code class="fe nj nk nl nm b">&lt;module_name&gt;/&lt;path_to_package&gt;</code>添加到import语句中。例如，在示例项目中，您可以通过引用import语句中的<code class="fe nj nk nl nm b">github.com/songx23/RoadToGoPro/part05/pkg/stringset</code>来导入<code class="fe nj nk nl nm b">stringset</code>包。</p><h1 id="d22c" class="kq kr it bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">下一步是什么？</h1><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi ns"><img src="../Images/7c0c88a9f56bb95a782fc84af5a03976.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HQpgzld6aftzEan9"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk translated">照片由<a class="ae kp" href="https://unsplash.com/@lsgr?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Olesya Grichina </a>在<a class="ae kp" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="74b6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是2020年要走的最后一段路。接下来的2021年，我们将讨论其他令人兴奋的话题，如并发性、如何构建API等。敬请关注。</p><p id="0820" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">圣诞快乐&amp;新年快乐！祝大家假期愉快。</p><p id="f911" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你遇到任何问题或者需要帮助，请在下面留下你的评论。随时欢迎反馈。感谢您的阅读！</p><p id="17c2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="ko">特别感谢</em> </strong> <a class="ae kp" href="https://medium.com/@mhumecook" rel="noopener"> <strong class="js iu"> <em class="ko">马克谟-库克</em> </strong> </a> <strong class="js iu"> <em class="ko">对本教程的点评。</em> </strong></p></div></div>    
</body>
</html>