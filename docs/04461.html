<html>
<head>
<title>Messaging Queue Comparison : NSQ and Apache Kafka</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">消息队列比较:NSQ和阿帕奇卡夫卡</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/messaging-platform-comparison-nsq-and-apache-kafka-60f96f7466b1?source=collection_archive---------5-----------------------#2020-06-28">https://levelup.gitconnected.com/messaging-platform-comparison-nsq-and-apache-kafka-60f96f7466b1?source=collection_archive---------5-----------------------#2020-06-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/a3abad4dc7c1940fb0329db26f0720c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:906/format:webp/1*Uy8qZnn845e2hv8XrqCmnQ.jpeg"/></div></figure><p id="3a1e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">随着系统变得越来越大，为了避免任何单点故障，我们经常从旧的整体架构切换到微服务架构。通过将应用程序划分为更小的独立单元，每个单元之间的交互次数将显著增加。</p><p id="eab2" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">消息队列提供了另一种异步通信和协调的方式，尤其是在这个解耦的单元中，同时提高了性能、可靠性和可伸缩性。将消息添加到队列中的组件称为生产者，而检索和处理消息的组件称为消费者。消费者和生产者不直接交互，通常使用代理来管理队列。</p><p id="0b75" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">阿帕奇卡夫卡和NSQ是我目前真正感兴趣的消息队列的例子。那么让我们开始吧。</p><h1 id="21c8" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">1.神经过敏症量表问卷调查</h1><figure class="lr ls lt lu gt jr gh gi paragraph-image"><div class="gh gi lq"><img src="../Images/435963842ef07d81b0bbbb127e6b6965.png" data-original-src="https://miro.medium.com/v2/resize:fit:840/0*_3VUwdeswTM_6ZNA.gif"/></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated">NSQ拓扑学</figcaption></figure><p id="835d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">NSQ是一个实时分布式消息平台，它是简单队列T2的继承者。</p><p id="9977" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">NSQ的核心组件包括:</p><ul class=""><li id="d358" class="ma mb iq jw b jx jy kb kc kf mc kj md kn me kr mf mg mh mi bi translated"><em class="lz"> nsqd </em>是一个守护进程，负责接收、排队和向客户端发送消息。</li><li id="ecb5" class="ma mb iq jw b jx mj kb mk kf ml kj mm kn mn kr mf mg mh mi bi translated"><em class="lz"> nsqlookupd </em>是管理拓扑信息的守护进程。<br/>客户端查询<em class="lz"> nsqlookupd </em>以发现特定主题的nsqd生产者，并且<em class="lz"> nsqd </em>节点广播主题和频道信息。</li><li id="be5f" class="ma mb iq jw b jx mj kb mk kf ml kj mm kn mn kr mf mg mh mi bi translated"><em class="lz"> nsqadmin </em>是一个Web UI，用于实时查看聚合的集群统计信息，并执行各种管理任务。</li></ul><p id="3c78" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">NSQ提供:</p><ul class=""><li id="891d" class="ma mb iq jw b jx jy kb kc kf mc kj md kn me kr mf mg mh mi bi translated">将SPOF降至最低的高可用性拓扑。<br/>通过为<em class="lz"> nsqd </em>和<em class="lz"> nsqlookupd设置多个实例来提高可用性。</em></li><li id="92d8" class="ma mb iq jw b jx mj kb mk kf ml kj mm kn mn kr mf mg mh mi bi translated">保证消息至少传递一次。</li><li id="c84a" class="ma mb iq jw b jx mj kb mk kf ml kj mm kn mn kr mf mg mh mi bi translated">一定程度的坚持。该消息被存储，直到消费者发送结束信号。</li><li id="11e4" class="ma mb iq jw b jx mj kb mk kf ml kj mm kn mn kr mf mg mh mi bi translated">易于配置</li></ul><p id="4708" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">单个<em class="lz"> nsqd </em>实例被设计成一次处理多个数据流。流被称为“主题”，一个主题有一个或多个“通道”。每个通道接收一个主题的所有消息的副本。</p><p id="15dc" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">主题和频道都不是预先配置的。主题是在命名主题首次发布时创建的，或者是通过订阅命名主题的频道创建的。频道是在第一次使用订阅命名频道时创建的。<br/>并且两者相互独立地缓冲数据。</p><p id="b210" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">一个通道通常有多个连接的客户端，每个消息将被传递给一个随机的客户端</p><p id="24d3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">NSQ需要重新考虑一些事情，例如:</p><ul class=""><li id="0175" class="ma mb iq jw b jx jy kb kc kf mc kj md kn me kr mf mg mh mi bi translated">您正在使用的拓扑将始终影响可靠性<br/>仅使用单个实例将使其更容易出现单点故障。NSQ设计用于多个实例。</li><li id="e73e" class="ma mb iq jw b jx mj kb mk kf ml kj mm kn mn kr mf mg mh mi bi translated">当服务器NSQD意外崩溃时，可能会丢失数据。因为没有内置的复制。</li><li id="2a5d" class="ma mb iq jw b jx mj kb mk kf ml kj mm kn mn kr mf mg mh mi bi translated">无序消息<br/>由于所有nsqd实例彼此之间不通信，无序消息可能会出现。</li><li id="f888" class="ma mb iq jw b jx mj kb mk kf ml kj mm kn mn kr mf mg mh mi bi translated">重复的消息。任何消费者超时的情况下，NSQ都会为消息做重新排队，造成重复消息的可能性。</li></ul><h1 id="e9d8" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">2.阿帕奇卡夫卡</h1><p id="037f" class="pw-post-body-paragraph ju jv iq jw b jx mo jz ka kb mp kd ke kf mq kh ki kj mr kl km kn ms kp kq kr ij bi translated">将Kafka流媒体平台与NSQ等消息系统进行比较，并不是苹果与苹果之间的比较。所以我们要经历的只是卡夫卡式的信息系统。</p><p id="4f10" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Kafka说，与其他消息队列相比，它们具有更好的吞吐量。内置分区和复制还支持容错，使其成为可靠的消息传递系统之一。</p><p id="e1c9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">主题是记录发布到的类别或提要名称。卡夫卡的主题总是多订户的；也就是说，一个主题可以有零个、一个或多个消费者订阅写入其中的数据。</p><p id="f4dc" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">对于每个主题，Kafka集群维护一个如下所示的分区日志:</p><figure class="lr ls lt lu gt jr gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/7d6053224295fc4c025f206d1e5fbd10.png" data-original-src="https://miro.medium.com/v2/resize:fit:832/format:webp/0*yReolkXCfthMyUWR.png"/></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated">卡夫卡的主题剖析</figcaption></figure><p id="ea75" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">每个分区都是一个有序的、不可变的记录序列，它不断地追加到结构化提交日志中。分区中的每个记录都被分配一个称为<em class="lz">偏移量</em>的顺序id号，该id号唯一地标识分区中的每个记录。</p><p id="1466" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Kafka集群使用可配置的保留期来持久保存所有记录，无论它们是否已被使用。例如，如果我们将保留期设置为五天，那么消息在发布后仍将保留五天，并且仍可供使用。</p><p id="5e71" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">与由生产者和消费者组成的其他消息传递系统相同。卡夫卡对这两种作品都有独特的方式:</p><ul class=""><li id="7b0a" class="ma mb iq jw b jx jy kb kc kf mc kj md kn me kr mf mg mh mi bi translated">生产者</li></ul><p id="d70b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">将数据发布到他们选择的主题。生产者负责选择将哪个记录分配给主题中的哪个分区。这可以通过简单的循环方式来平衡负载，也可以根据某种语义分区函数来完成(比如基于记录中的某个键)。</p><ul class=""><li id="aadf" class="ma mb iq jw b jx jy kb kc kf mc kj md kn me kr mf mg mh mi bi translated">消费者</li></ul><p id="6dca" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">消费者用一个<em class="lz">消费者组</em>名称来标记他们自己，并且发布到一个主题的每个记录被交付到每个订阅消费者组中的一个消费者实例。消费者实例可以在不同的进程中，也可以在不同的机器上。</p><p id="7f8b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果所有的消费者实例都有相同的消费者组，那么记录将有效地在消费者实例之间进行负载平衡。</p><p id="fc3a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果所有的消费者实例都有不同的消费者组，那么每个记录都将被广播给所有的消费者进程。</p><figure class="lr ls lt lu gt jr gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/a4d59ffc67bf67e903064d6a67272ec2.png" data-original-src="https://miro.medium.com/v2/resize:fit:948/format:webp/0*_FYxVELrsPI28Dad.png"/></div></figure><h1 id="ec85" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">3.比较</h1><p id="a13e" class="pw-post-body-paragraph ju jv iq jw b jx mo jz ka kb mp kd ke kf mq kh ki kj mr kl km kn ms kp kq kr ij bi translated">这两个消息队列都有一种独特方式来定义它们的体系结构以及它们的代理如何工作，但是在几个方面，这可能是您选择哪个平台的一个考虑因素:</p><ul class=""><li id="4471" class="ma mb iq jw b jx jy kb kc kf mc kj md kn me kr mf mg mh mi bi translated">有效性</li></ul><p id="c33f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果NSQD服务器意外崩溃，可能会丢失数据。<br/> Kafka内置复制和分区功能，使其具有更高的可用性和可靠性。使用复制因子N，Kafka可以容忍N-1个服务器故障，而不会丢失任何记录。</p><p id="c2c5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为了解决这种问题，我们可以在单独的主机上创建冗余的NSQD对，以接收完全相同的消息副本。</p><ul class=""><li id="87e7" class="ma mb iq jw b jx jy kb kc kf mc kj md kn me kr mf mg mh mi bi translated">坚持</li></ul><p id="4afc" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果用户已经发送该消息的结束信号，NSQ将删除该消息。</p><p id="e3fa" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Kafka有另一个规则，通过设置保留时间(无论是基于时间还是基于大小),但是消息在从它们被发布的时刻起的特定时间/大小之后仍然保持。</p><ul class=""><li id="0e0e" class="ma mb iq jw b jx jy kb kc kf mc kj md kn me kr mf mg mh mi bi translated">可重放的消息</li></ul><p id="e449" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">由于卡夫卡有记录的持久存储系统，他们提供了一遍又一遍重放信息的能力，只要它仍然被存储。</p><ul class=""><li id="52c5" class="ma mb iq jw b jx jy kb kc kf mc kj md kn me kr mf mg mh mi bi translated">消息的顺序</li></ul><p id="d389" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">由于NSQD的多个实例不能相互通信，因此总是有可能出现无序的消息。虽然Kafka将它们的每个分区维护为有序的记录序列，但是Kafka将总是在一个分区中提供消息的精确顺序。</p><h1 id="4931" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">4.类似</h1><p id="ecb0" class="pw-post-body-paragraph ju jv iq jw b jx mo jz ka kb mp kd ke kf mq kh ki kj mr kl km kn ms kp kq kr ij bi translated">NSQ和卡夫卡都是传统信息经纪人中的佼佼者，因为他们都使用发布/订阅模式，而且卡夫卡的消费群体与NSQ的渠道系统有相似之处。</p><p id="f797" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">尽管如此，这两种方法在各自的程度上都提供了更高的可靠性、可伸缩性和持久性。</p><h1 id="433d" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">5.管见所及</h1><p id="c19f" class="pw-post-body-paragraph ju jv iq jw b jx mo jz ka kb mp kd ke kf mq kh ki kj mr kl km kn ms kp kq kr ij bi translated">对于一个开源消息队列，NSQ提供了一个相当宏伟的架构和用例，而另一方面，Kafka从持久性、可靠性和可用性方面提供了一个更加健壮的平台。</p><p id="7dcd" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在这种情况下，你选择哪个平台只基于这一个问题。</p><blockquote class="mv"><p id="51e5" class="mw mx iq bd my mz na nb nc nd ne kr dk translated">你能接受数据丢失吗？</p></blockquote><p id="1882" class="pw-post-body-paragraph ju jv iq jw b jx nf jz ka kb ng kd ke kf nh kh ki kj ni kl km kn nj kp kq kr ij bi translated">如果答案是否定的，那么卡夫卡就是答案。</p><p id="2e5e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我的另一个观点是，如果你的系统已经是Java的，并且可能有兴趣实现Kafka，那么Kafka的流媒体平台可能是一个值得考虑的因素。</p><p id="b549" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">是的，流媒体平台比消息系统贵多了。但是看到它是如何工作的，让我真的想到通过将一切实现为一个流，而不仅仅是一个单一的消息记录，未来会有多少可能性。</p><p id="ab3c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">像往常一样，我们在东京有一个空缺。我们是一家印度尼西亚科技公司，以通过技术实现商业民主化为使命，帮助每个人实现更大成就。<br/>在Tokopedia和我们一起寻找你梦想的工作！https://www.tokopedia.com/careers/<br/>T3</p><p id="5e78" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><a class="ae nk" href="https://kafka.apache.org/" rel="noopener ugc nofollow" target="_blank">https://kafka.apache.org/</a>T7<a class="ae nk" href="https://nsq.io/" rel="noopener ugc nofollow" target="_blank">https://nsq.io/</a></p></div></div>    
</body>
</html>