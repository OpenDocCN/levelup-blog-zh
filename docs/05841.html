<html>
<head>
<title>Building a Game With TypeScript. Colors and Layers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用TypeScript构建游戏。颜色和图层</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/building-a-game-with-typescript-colors-and-layers-337b0e4d71f?source=collection_archive---------5-----------------------#2020-10-06">https://levelup.gitconnected.com/building-a-game-with-typescript-colors-and-layers-337b0e4d71f?source=collection_archive---------5-----------------------#2020-10-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="167c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">教程<a class="ae kl" href="https://medium.com/@gregsolo/gamedev-patterns-and-algorithms-in-action-with-typescript-d29b913858e" rel="noopener">系列</a>的第四章讲述了如何用类型脚本和本地浏览器API从头开始构建一个游戏</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/342c4704af0b99671f8e9b0b37be2e9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WNuzIOJ_dWQ56oW-US__Rw.jpeg"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated"><a class="ae kl" href="https://www.freepik.com/free-photos-vectors/design" rel="noopener ugc nofollow" target="_blank">free pik创建的设计向量</a></figcaption></figure><p id="a4d8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">很高兴看到你回来，读者！在这一系列教程中，我们学习如何使用<strong class="jp ir">类型脚本</strong>、原生<strong class="jp ir">浏览器的API</strong>、<strong class="jp ir">固体</strong>架构、<strong class="jp ir">增量</strong>方法和<strong class="jp ir">单元测试</strong>从头构建一个简单的回合制游戏。</p><p id="9ad0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是第四章的第一部分。本章将向我们介绍游戏的新元素:<code class="fe lc ld le lf b">Ships</code>。这些是玩家可以在棋盘上移动并攻击其他玩家的船只的元素。游戏的最终目标是摧毁所有的敌舰。如果您正在寻找本系列的其他章节，您可以在这里找到它们:</p><ul class=""><li id="6101" class="lg lh iq jp b jq jr ju jv jy li kc lj kg lk kk ll lm ln lo bi translated"><a class="ae kl" href="https://medium.com/@gregsolo/gamedev-patterns-and-algorithms-in-action-with-typescript-d29b913858e" rel="noopener">简介</a></li><li id="3677" class="lg lh iq jp b jq lp ju lq jy lr kc ls kg lt kk ll lm ln lo bi translated"><a class="ae kl" href="https://medium.com/@gregsolo/entity-component-system-in-action-with-typescript-f498ca82a08e" rel="noopener">第一章实体组件系统</a></li><li id="8f15" class="lg lh iq jp b jq lp ju lq jy lr kc ls kg lt kk ll lm ln lo bi translated">第二章。游戏循环(<a class="ae kl" href="https://medium.com/@gregsolo/gamedev-patterns-and-algorithms-with-typescript-game-loop-part-1-2-699919bb9b71" rel="noopener">第一部</a>，<a class="ae kl" href="https://medium.com/@gregsolo/gamedev-patterns-and-algorithms-in-action-with-typescript-game-loop-2-2-c0d57a8e5ec2" rel="noopener">第二部</a>)</li><li id="dfee" class="lg lh iq jp b jq lp ju lq jy lr kc ls kg lt kk ll lm ln lo bi translated">第三章。绘制网格(<a class="ae kl" href="https://medium.com/@gregsolo/building-a-game-with-typescript-drawing-grid-1-5-aaf68797a0bb" rel="noopener">第1部分</a>、<a class="ae kl" href="https://medium.com/javascript-in-plain-english/building-a-game-with-typescript-drawing-grid-2-5-206555719490" rel="noopener">第2部分</a>、<a class="ae kl" href="https://medium.com/@gregsolo/building-a-game-with-typescript-drawing-grid-3-5-1fb94211c4aa" rel="noopener">第3部分</a>、<a class="ae kl" href="https://medium.com/@gregsolo/building-a-game-with-typescript-iii-drawing-grid-4-5-398af1dd638d" rel="noopener">第4部分</a>、<a class="ae kl" href="https://medium.com/@gregsolo/building-a-game-with-typescript-drawing-grid-5-5-49454917b3af" rel="noopener">第5部分</a>)</li><li id="6380" class="lg lh iq jp b jq lp ju lq jy lr kc ls kg lt kk ll lm ln lo bi translated">第四章。舰船(第一部分，<a class="ae kl" href="https://medium.com/@gregsolo/building-a-game-with-typescript-team-and-fleet-f223d39e9248" rel="noopener">第二部分</a>，<a class="ae kl" href="https://medium.com/@gregsolo/building-a-game-with-typescript-drawing-ship-14e6c19caa38" rel="noopener">第三部分</a>，<a class="ae kl" href="https://gregsolo.medium.com/building-a-game-with-typescript-ship-and-locomotion-4f5969675993" rel="noopener">第四部分</a></li><li id="486b" class="lg lh iq jp b jq lp ju lq jy lr kc ls kg lt kk ll lm ln lo bi translated">第五章输入系统(<a class="ae kl" href="https://gregsolo.medium.com/building-a-game-with-typescript-input-system-1-3-46d0b3dd7662" rel="noopener">第一部分</a>、<a class="ae kl" href="https://gregsolo.medium.com/building-a-game-with-typescript-input-system-2-3-cd419e36027c" rel="noopener">第二部分</a>、<a class="ae kl" href="https://gregsolo.medium.com/building-a-game-with-typescript-input-system-3-3-8492552579f1" rel="noopener">第三部分</a>)</li><li id="39cc" class="lg lh iq jp b jq lp ju lq jy lr kc ls kg lt kk ll lm ln lo bi translated">第六章。寻路和移动(<a class="ae kl" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-17-introduction" rel="noopener ugc nofollow" target="_blank">第一部分</a>、<a class="ae kl" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-27-highlighting-locomotion-range" rel="noopener ugc nofollow" target="_blank">第二部分</a>、<a class="ae kl" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-37-graph-and-priority-queue" rel="noopener ugc nofollow" target="_blank">第三部分</a>、<a class="ae kl" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-47-pathfinder" rel="noopener ugc nofollow" target="_blank">第四部分</a>、<a class="ae kl" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-57-finding-the-path" rel="noopener ugc nofollow" target="_blank">第五部分</a>、<a class="ae kl" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-6-instant-locomotion" rel="noopener ugc nofollow" target="_blank">第六部分</a>、<a class="ae kl" href="https://blog.gregsolo.me/articles/pathfinding-and-movement-7-animated-locomotion" rel="noopener ugc nofollow" target="_blank">第七部分</a>)</li><li id="dd68" class="lg lh iq jp b jq lp ju lq jy lr kc ls kg lt kk ll lm ln lo bi translated">第七章。玛奇纳州</li><li id="0682" class="lg lh iq jp b jq lp ju lq jy lr kc ls kg lt kk ll lm ln lo bi translated">第八章。攻击系统:生命和伤害</li><li id="6aa5" class="lg lh iq jp b jq lp ju lq jy lr kc ls kg lt kk ll lm ln lo bi translated">第九章。比赛的输赢</li><li id="457f" class="lg lh iq jp b jq lp ju lq jy lr kc ls kg lt kk ll lm ln lo bi translated">第十章敌人AI</li></ul><blockquote class="lu lv lw"><p id="bfa6" class="jn jo lx jp b jq jr js jt ju jv jw jx ly jz ka kb lz kd ke kf ma kh ki kj kk ij bi translated">随意切换到<a class="ae kl" href="https://github.com/soloschenko-grigoriy/gamedev-patterns-ts" rel="noopener ugc nofollow" target="_blank">库</a>的<code class="fe lc ld le lf b"><em class="iq">drawing-grid-5</em></code>分支。它包含了前几篇文章的工作成果，是这篇文章的一个很好的起点。</p></blockquote></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><p id="ca8f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这一点上，我们不打算使用高保真图形。我们的目标是理解原理和构建系统，而不是运送AAA游戏。所以，我们的<em class="lx">飞船</em>看起来会相当谦虚:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mi"><img src="../Images/a3a4e0dee9f60451dce165a347cfe732.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aTj-_LPHryv8simtyNUOkw.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">是的，这些圆圈实际上是船</figcaption></figure><p id="e2fc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但不要因此而气馁。事实上，我们用简单的形状来代表移动的元素并不意味着我们的系统功能会更弱。我们专注于游戏的编程方面，并建立了一个类似的原型。这并不意味着我们不能将高质量的图形放在我们稍后构建的代码之上。</p><p id="879d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在最后几章中，我们构建了几个实用程序来帮助我们处理游戏的许多方面:<code class="fe lc ld le lf b">Vector2D</code>、<code class="fe lc ld le lf b">Entities and Components</code>、<code class="fe lc ld le lf b">Lifecycle Events</code>。我们开始相当广泛地处理绘图和颜色，所以是时候介绍另一个实用程序:<code class="fe lc ld le lf b">Color</code>助手了。</p></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><h1 id="df6a" class="mj mk iq bd ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng bi translated">目录</h1><ol class=""><li id="856d" class="lg lh iq jp b jq nh ju ni jy nj kc nk kg nl kk nm lm ln lo bi translated">颜色实用程序</li><li id="ca94" class="lg lh iq jp b jq lp ju lq jy lr kc ls kg lt kk nm lm ln lo bi translated">测试颜色实用程序</li><li id="b262" class="lg lh iq jp b jq lp ju lq jy lr kc ls kg lt kk nm lm ln lo bi translated">画圆</li><li id="972a" class="lg lh iq jp b jq lp ju lq jy lr kc ls kg lt kk nm lm ln lo bi translated">画布前景层</li><li id="0e6c" class="lg lh iq jp b jq lp ju lq jy lr kc ls kg lt kk nm lm ln lo bi translated">结论</li></ol></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><h1 id="46cf" class="mj mk iq bd ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng bi translated">颜色实用程序</h1><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nn"><img src="../Images/2e48b2eda92990f58e335c34d1a7faac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RaCa42Q4oWDRltn5HzkmSw.jpeg"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated"><a class="ae kl" href="https://www.freepik.com/vectors/background" rel="noopener ugc nofollow" target="_blank">宏矢量创建的背景矢量——www.freepik.com</a></figcaption></figure><p id="109e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以前，我们用native canvas的方式处理颜色:作为一个字符串。但是<code class="fe lc ld le lf b">string</code>是一个相当不安全的结构，而且不太灵活。例如，看看我们如何设置<code class="fe lc ld le lf b">Node</code>颜色:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="72f7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该字符串包含4条不同的信息:4个颜色通道的颜色设置(红色、绿色、蓝色、Alpha)。如果我们想改变任何频道，我们必须做一些奇怪的字符串操作。更不用说，我们有零验证或类型检查，可能会意外设置某些东西<code class="fe lc ld le lf b">rgva(245, 245, 245, 1)</code>甚至<code class="fe lc ld le lf b">rgba(-245, 245, 2450, 10)</code>。总的来说，最好有一个专用的数据类型来满足我们丰富多彩的需求:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="929f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我希望你已经习惯了每次我们创建一个新东西的时候更新桶文件:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="6549" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们应该能够用显式颜色通道实例化<code class="fe lc ld le lf b">Color</code>类，存储并提供公共读取访问:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="d6c3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，我们应该首先验证参数，并且只有当它们满足我们的约束时才进行实例化。为此，在这种情况下，我们必须跳过方便的TypeScript快捷方式，手动设置字段:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="226c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">验证本身很简单。我们应该验证每个数字都在合理的范围内(颜色通道为0–255，alpha通道为0–1):</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="ae53" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另外，颜色通道应该是一个整数:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="01ad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们可以在构造函数中运行验证了:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="no np l"/></div></figure><blockquote class="lu lv lw"><p id="f5af" class="jn jo lx jp b jq jr js jt ju jv jw jx ly jz ka kb lz kd ke kf ma kh ki kj kk ij bi translated">为什么<code class="fe lc ld le lf b">IsValidChannel</code>是静态的？因为提供的验证规则与<code class="fe lc ld le lf b">Color</code>的实例无关，也就是特定的<code class="fe lc ld le lf b">color</code>。这些规则对于整个类型是通用的。</p></blockquote><p id="30cf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于Canvas API使用了<code class="fe lc ld le lf b">strings</code>，新的<code class="fe lc ld le lf b">Color</code>助手应该提供一种将其值转换为字符串的方法:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="5a90" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们更新<code class="fe lc ld le lf b">Settings</code>以包含<code class="fe lc ld le lf b">Color</code>而不是字符串:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="070f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lc ld le lf b">Canvas</code>现在可以用<code class="fe lc ld le lf b">Color</code>而不是弦了:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="d5fd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这将需要更新<code class="fe lc ld le lf b">canvas.spec.ts</code>:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="6a90" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不错！此时，我们的代码应该通过<code class="fe lc ld le lf b">npm start</code>成功编译，所有测试应该通过<code class="fe lc ld le lf b">npm t</code>:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nq"><img src="../Images/e4658a55f04cf53b6e606f36dc368d46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yJExi9iqlZbRBMiYpSaCfw.png"/></div></div></figure><p id="325e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们使用方便的小转换器方法<code class="fe lc ld le lf b">AsString</code>。让我们绕个弯，添加相反的转换功能:<code class="fe lc ld le lf b">FromString</code>这个静态方法能够将string转换成<code class="fe lc ld le lf b">Color</code>的实例:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="2a06" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该方法解析提供的字符串并验证每个组件确实是一个数字，然后实例化新的<code class="fe lc ld le lf b">Color</code>。</p></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><h1 id="ef53" class="mj mk iq bd ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng bi translated">测试颜色实用程序</h1><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nr"><img src="../Images/29e7e880e5e1131403b02b9eee84910d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eroaWcv4yodEgWmK4XEJKA.jpeg"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">www.freepik.com弗里皮克创作的<a class="ae kl" href="https://www.freepik.com/photos/pattern" rel="noopener ugc nofollow" target="_blank">图案照片</a></figcaption></figure><p id="7251" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">厉害！我们剩下的工作就是用单元测试来覆盖我们的新助手:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="c771" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们可以断言<code class="fe lc ld le lf b">Color</code>可以被正确实例化:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="da69" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们只是验证新创建的<code class="fe lc ld le lf b">Color</code>的每个通道都有一个合适的值。接下来，我们应该检查验证是否正常工作:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="7a67" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们向<code class="fe lc ld le lf b">Color</code>提供每个通道的无效选项，并确保每次它报告各自的错误。</p><p id="342f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">太好了！我们已经介绍了构造函数，现在我们应该将注意力转移到其他方法上:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="5729" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lc ld le lf b">AsString</code>转换器应该获取<code class="fe lc ld le lf b">Color</code>的一个实例，并返回一个格式正确的字符串:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="8bca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了验证<code class="fe lc ld le lf b">Color.FromString</code>，我们可以提供一个字符串，并检查每个通道是否有正确的值:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="c57e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我们可以检查不同的无效字符串，并预期会抛出错误:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="bde2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此时，我们的代码应该通过<code class="fe lc ld le lf b">npm start</code>成功编译，并且所有测试应该通过<code class="fe lc ld le lf b">npm t</code>:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi ns"><img src="../Images/f36d08e5c6ba1e0c3c87be31e3ef34e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U36JdDCxXGPCe34F6Jxhig.png"/></div></div></figure><p id="74bc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">厉害！现在，当我们设置好<code class="fe lc ld le lf b">Color</code>助手后，我们终于可以开始绘制船只了。或者我应该说，圆圈？</p></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><h1 id="6108" class="mj mk iq bd ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng bi translated">画圆</h1><p id="3c0e" class="pw-post-body-paragraph jn jo iq jp b jq nh js jt ju ni jw jx jy nt ka kb kc nu ke kf kg nv ki kj kk ij bi translated">正如我之前提到的，在我们的游戏中，船只被简单地表示为圆圈。如果你还记得我们有一个很棒的微型渲染引擎，我们在前面的章节中已经设置好了:<code class="fe lc ld le lf b">Canvas</code>。但是除了矩形之外，我们没有工具来画任何东西。是时候解决这个不便了！</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nw"><img src="../Images/3628c55df2f5cf48fb7e8ca6f2f54a6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bEyW-xCtD3tSN8vuEmfdow.jpeg"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated"><a class="ae kl" href="https://www.freepik.com/vectors/background" rel="noopener ugc nofollow" target="_blank">rawpixel.com创建的背景向量</a></figcaption></figure><p id="5b0e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们需要一种能为我们画圆的新方法:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="a7d7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们用天然画布<code class="fe lc ld le lf b">rect</code>画出矩形并填充。然后，我们对一个循环重复这种方法，但多亏了<code class="fe lc ld le lf b">arc</code>方法:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="6602" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当然，我们应该用测试来覆盖这个新功能:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="1313" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">与我们测试<code class="fe lc ld le lf b">FillRect</code>的方式相同，我们将监视本机API，并期望它在调用<code class="fe lc ld le lf b">canvas.FillCircle</code>后被执行:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="4f16" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不错！此时，我们的代码应该可以用<code class="fe lc ld le lf b">npm start</code>成功编译，并且所有的测试都应该通过<code class="fe lc ld le lf b">npm t</code>:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nx"><img src="../Images/9b2ecad912302af2c95a9561fb5b7ad1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2nYT2memiaxrSa1SwPuJXg.png"/></div></div></figure></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><h1 id="0585" class="mj mk iq bd ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng bi translated">前景画布层</h1><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi ny"><img src="../Images/9daf0a3d19951a28cfee41ab1992832e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WDjEAH7XXSK_NgHLuyTZBQ.jpeg"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated"><a class="ae kl" href="https://www.freepik.com/vectors/background" rel="noopener ugc nofollow" target="_blank">Sketchepedia创建的背景矢量</a></figcaption></figure><p id="7581" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">形状不是唯一区别于网格的东西。它们总是被画在网格的顶部。换句话说，它们应该绘制在顶层“层”上。但是我们只有一个“背景”层:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="aef7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">没问题！添加新层是一项简单的任务:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="214d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该过程与我们用于<code class="fe lc ld le lf b">background</code>的过程相同:我们实例化适当大小的新<code class="fe lc ld le lf b">Canvas</code>，唤醒它，并将其链接到私有字段。你可以想象，几乎所有的代码都是重复的。让我们定义一个单独的方法来避免重复我们自己:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="3e77" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在在<code class="fe lc ld le lf b">Background</code>和<code class="fe lc ld le lf b">Foreground</code>getter中使用这个新方法:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="12ee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不错！但是我们在这里有一个小问题:这两张画布是相同的。唯一的区别就是他们的名字:<code class="fe lc ld le lf b">background</code> vs <code class="fe lc ld le lf b">foreground</code>。没有什么<em class="lx">实际上</em>让<code class="fe lc ld le lf b">foreground</code>躺在上面。</p><p id="dd3d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">事实上，每个画布都是一个DOM元素。为了将它们放在不同的“级别”上，我们可以使用good 'ol CSS:具有更高<code class="fe lc ld le lf b">z-index</code>的元素更接近查看者(假设它们属于同一个父元素，这正是我们的情况)。</p><p id="e2b2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们有很多方法可以实现这一点。其中之一是让<code class="fe lc ld le lf b">Canvas</code>处理样式，而<code class="fe lc ld le lf b">CanvasLayer</code>只利用特定的规则。通过这种方式，他们将维护自己的职责:<code class="fe lc ld le lf b">Canvas</code>管理画布DOM元素，<code class="fe lc ld le lf b">CanvasLayer</code>创建画布层。</p><p id="ca65" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了实现这个行为，我们应该在<code class="fe lc ld le lf b">Canvas</code>中提供一个新的API:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="073a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该方法采用可能的CSS选项，并将它们应用于canvas元素:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="no np l"/></div></figure><blockquote class="lu lv lw"><p id="add6" class="jn jo lx jp b jq jr js jt ju jv jw jx ly jz ka kb lz kd ke kf ma kh ki kj kk ij bi translated"><em class="iq">注意，我使用</em> <code class="fe lc ld le lf b"><em class="iq">Partial</em></code> <em class="iq">让消费者只提供几个可能的选项。</em></p></blockquote><p id="7bd5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们现在可以更新单元测试来验证这种行为:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="ee0d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">并将其连接到<code class="fe lc ld le lf b">CanvasLayer</code>:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="1528" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">厉害！让我们通过测试新的<code class="fe lc ld le lf b">Foreground</code>层在蛋糕上加一颗樱桃:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="4f70" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">测试<code class="fe lc ld le lf b">Foreground</code>的方法与<code class="fe lc ld le lf b">Background</code>的方法完全相同:无论我们请求这个层多少次，<code class="fe lc ld le lf b">Canvas</code>实例化应该只发生一次。</p><p id="1471" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此时，我们的代码应该通过<code class="fe lc ld le lf b">npm start</code>成功编译，所有测试应该通过<code class="fe lc ld le lf b">npm t</code>:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/8a403cd1cec4dfcbf73219c264523cef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1140/format:webp/1*91pa61MWxkjhsMBx34xDKw.png"/></div></figure><blockquote class="lu lv lw"><p id="4949" class="jn jo lx jp b jq jr js jt ju jv jw jx ly jz ka kb lz kd ke kf ma kh ki kj kk ij bi translated">你可以在<a class="ae kl" href="https://github.com/soloschenko-grigoriy/gamedev-patterns-ts" rel="noopener ugc nofollow" target="_blank">库</a>的<code class="fe lc ld le lf b">ships-1</code>分支中找到这篇文章的完整源代码。</p></blockquote></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><h1 id="8eac" class="mj mk iq bd ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng bi translated">结论</h1><p id="917d" class="pw-post-body-paragraph jn jo iq jp b jq nh js jt ju ni jw jx jy nt ka kb kc nu ke kf kg nv ki kj kk ij bi translated">酷！我们做好了一切必要的准备，搭起了画船的舞台。我们创造了一个方便的工具来帮助我们处理颜色。此外，我们更新了我们的渲染引擎，以支持一个新的原始形状:圆形。当然，我们引入了一个新的画布层:<code class="fe lc ld le lf b">Foreground</code>，这是一个为我们未来的船只准备的特殊位置，以确保它们总是停留在图像的顶部。</p><p id="e70b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下次我们将谈论团队和对手。我们还将为<strong class="jp ir">舰队</strong>创建一个专用实体。没错:我们将拥有自己的舰队！</p><p id="22ca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我真的很想听听你的想法！如果你有任何<strong class="jp ir">评论</strong>、<strong class="jp ir">建议</strong>、<strong class="jp ir">问题</strong>，或者任何其他<strong class="jp ir">反馈</strong>，请不要犹豫，给我发私信或者在下面留下评论！如果你喜欢这篇文章，请与他人分享。它真的帮助我继续努力。感谢您的阅读，我们下次再见！</p></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><p id="b3c3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="lx">这是系列教程</em> <strong class="jp ir"> <em class="lx">用TypeScript </em> </strong> <em class="lx">构建游戏的第四章。其他章节可点击此处:</em></p><ul class=""><li id="9fd4" class="lg lh iq jp b jq jr ju jv jy li kc lj kg lk kk ll lm ln lo bi translated"><a class="ae kl" href="https://medium.com/@gregsolo/gamedev-patterns-and-algorithms-in-action-with-typescript-d29b913858e" rel="noopener">简介</a></li><li id="b129" class="lg lh iq jp b jq lp ju lq jy lr kc ls kg lt kk ll lm ln lo bi translated"><a class="ae kl" href="https://medium.com/@gregsolo/entity-component-system-in-action-with-typescript-f498ca82a08e" rel="noopener">第一章实体组件系统</a></li><li id="5bb2" class="lg lh iq jp b jq lp ju lq jy lr kc ls kg lt kk ll lm ln lo bi translated">第二章。游戏循环(<a class="ae kl" href="https://medium.com/@gregsolo/gamedev-patterns-and-algorithms-with-typescript-game-loop-part-1-2-699919bb9b71" rel="noopener">第一部分</a>，<a class="ae kl" href="https://medium.com/@gregsolo/gamedev-patterns-and-algorithms-in-action-with-typescript-game-loop-2-2-c0d57a8e5ec2" rel="noopener">第二部分</a>)</li><li id="97be" class="lg lh iq jp b jq lp ju lq jy lr kc ls kg lt kk ll lm ln lo bi translated">第三章。绘制网格(<a class="ae kl" href="https://medium.com/@gregsolo/building-a-game-with-typescript-drawing-grid-1-5-aaf68797a0bb" rel="noopener">第一部分</a>、<a class="ae kl" href="https://medium.com/javascript-in-plain-english/building-a-game-with-typescript-drawing-grid-2-5-206555719490" rel="noopener">第二部分</a>、<a class="ae kl" href="https://medium.com/@gregsolo/building-a-game-with-typescript-drawing-grid-3-5-1fb94211c4aa" rel="noopener">第三部分</a>、<a class="ae kl" href="https://medium.com/@gregsolo/building-a-game-with-typescript-iii-drawing-grid-4-5-398af1dd638d" rel="noopener">第四部分</a>、<a class="ae kl" href="https://medium.com/@gregsolo/building-a-game-with-typescript-drawing-grid-5-5-49454917b3af" rel="noopener">第五部分</a>)</li><li id="26ae" class="lg lh iq jp b jq lp ju lq jy lr kc ls kg lt kk ll lm ln lo bi translated">第四章。船舶(第1部分，<a class="ae kl" href="https://medium.com/@gregsolo/building-a-game-with-typescript-team-and-fleet-f223d39e9248" rel="noopener">第2部分</a>，<a class="ae kl" href="https://medium.com/@gregsolo/building-a-game-with-typescript-drawing-ship-14e6c19caa38" rel="noopener">第3部分</a>，<a class="ae kl" href="https://gregsolo.medium.com/building-a-game-with-typescript-ship-and-locomotion-4f5969675993" rel="noopener">第4部分</a>)</li><li id="2a7f" class="lg lh iq jp b jq lp ju lq jy lr kc ls kg lt kk ll lm ln lo bi translated">第五章输入系统(<a class="ae kl" href="https://gregsolo.medium.com/building-a-game-with-typescript-input-system-1-3-46d0b3dd7662" rel="noopener">第一部分</a>、<a class="ae kl" href="https://gregsolo.medium.com/building-a-game-with-typescript-input-system-2-3-cd419e36027c" rel="noopener">第二部分</a>、<a class="ae kl" href="https://gregsolo.medium.com/building-a-game-with-typescript-input-system-3-3-8492552579f1" rel="noopener">第三部分</a>)</li><li id="022a" class="lg lh iq jp b jq lp ju lq jy lr kc ls kg lt kk ll lm ln lo bi translated">第六章。寻路与移动(<a class="ae kl" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-17-introduction" rel="noopener ugc nofollow" target="_blank">第一部分</a>、<a class="ae kl" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-27-highlighting-locomotion-range" rel="noopener ugc nofollow" target="_blank">第二部分</a>、<a class="ae kl" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-37-graph-and-priority-queue" rel="noopener ugc nofollow" target="_blank">第三部分</a>、<a class="ae kl" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-47-pathfinder" rel="noopener ugc nofollow" target="_blank">第四部分</a>、<a class="ae kl" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-57-finding-the-path" rel="noopener ugc nofollow" target="_blank">第五部分</a>、<a class="ae kl" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-6-instant-locomotion" rel="noopener ugc nofollow" target="_blank">第六部分</a>、<a class="ae kl" href="https://blog.gregsolo.me/articles/pathfinding-and-movement-7-animated-locomotion" rel="noopener ugc nofollow" target="_blank">第七部分</a>)</li><li id="2370" class="lg lh iq jp b jq lp ju lq jy lr kc ls kg lt kk ll lm ln lo bi translated">第七章。玛奇纳州</li><li id="b605" class="lg lh iq jp b jq lp ju lq jy lr kc ls kg lt kk ll lm ln lo bi translated">第八章。攻击系统:生命和伤害</li><li id="636c" class="lg lh iq jp b jq lp ju lq jy lr kc ls kg lt kk ll lm ln lo bi translated">第九章。比赛的输赢</li><li id="10ff" class="lg lh iq jp b jq lp ju lq jy lr kc ls kg lt kk ll lm ln lo bi translated">第十章敌人AI</li></ul></div></div>    
</body>
</html>