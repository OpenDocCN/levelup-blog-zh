<html>
<head>
<title>Level Order Traversal Of A Binary Tree</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">二叉树的层次顺序遍历</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/level-order-traversal-of-a-binary-tree-a3425ebb4256?source=collection_archive---------13-----------------------#2021-09-28">https://levelup.gitconnected.com/level-order-traversal-of-a-binary-tree-a3425ebb4256?source=collection_archive---------13-----------------------#2021-09-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/24b44bd36313899d68d14c031e34ea90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iv8KIzoWvOC6tSNOi0RS3w.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">来源:通过<a class="ae kc" href="https://unsplash.com/photos/tGTVxeOr_Rs" rel="noopener ugc nofollow" target="_blank">Unsplash.com</a>的Niko照片</figcaption></figure><p id="ede9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一棵树！自然和宁静的象征。但对我们计算机科学家来说，我们用它们来存储数据和翻转数据，因为它看起来更酷，而且总是在室内，几乎看不到树。</p><p id="4c8a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">树形数据结构允许机器以二进制方式遍历数据。数据被一分为二，以使遍历更容易。我们将讨论层次顺序遍历，这也是一个常见的面试问题。</p><h1 id="1b7f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">问题陈述</h1><figure class="ma mb mc md gt jr gh gi paragraph-image"><div class="gh gi lz"><img src="../Images/0120989f19238b230f5db4de823e25b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1264/format:webp/1*p4XRf9PRk0fFz6WBKMtIyQ.png"/></div></figure><p id="571e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">层级顺序遍历也称为广度优先搜索，从上到下导航。我们将引入一个辅助数据结构，称为队列。</p><p id="9aa9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们从根节点100开始，将它插入到我们的队列数据结构中，这个过程称为入队。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div class="gh gi me"><img src="../Images/58db080a680bd50aed75b2a254a3985c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1152/format:webp/1*qINZy4vGU71lzsjMhBn_jw.png"/></div></figure><p id="f64b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后查看队列中的项目，输出/打印号码。</p><p id="cc71" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">产量:100</p><p id="ca0f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦我们达到顶点并打印出数字，我们就让它出队并探索它的子节点。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/7804d4eb184450c6b50d2acde9a80e12.png" data-original-src="https://miro.medium.com/v2/resize:fit:468/format:webp/1*13ejeFuQg203qjM6LbgVyw.png"/></div></figure><p id="7304" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">100的子节点是50和200。然后，我们将把它们插入(排队)到队列数据结构中，从左边的子节点开始，然后是右边的子节点。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/fb767fb82b85013e59dce8dde35a0bea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1148/format:webp/1*mUHxT_emjfjXasg5URCt6w.png"/></div></figure><p id="f984" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们将队列中的第一个项目增加到峰值，即50。我们继续输出、打印它并将其出队(从我们的队列中删除)。</p><p id="1f91" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">产量:50</p><p id="3942" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们研究50的子节点，即25和75，并将它们排列到队列数据结构中，从左节点开始，然后是右节点。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/f844ea98feaabf7ecbfeb02bbc8a3656.png" data-original-src="https://miro.medium.com/v2/resize:fit:310/format:webp/1*6cLqsYABtrO83D5ip-yOSw.png"/></div></figure><figure class="ma mb mc md gt jr gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/9ecbe52c0f21924b38642809887dea53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1150/format:webp/1*qhyMD2TVCaNjb2QW9EEvIA.png"/></div></figure><p id="51af" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们到达顶点并检查，这是队列中的第一个项目。我们注意到它是200，我们输出/打印200，然后将其出队。然后继续探索它的子节点。</p><p id="05e1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">产量:200</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/15f40d1708888c35cc2f64c1dcadd966.png" data-original-src="https://miro.medium.com/v2/resize:fit:314/format:webp/1*4ntjRyacK_QOpjrZhFtbbA.png"/></div></figure><p id="2c19" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们看到200只有一个子节点，即350，因此我们将把它添加到队列中。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/5496806b50808229a5c6dca1003e4837.png" data-original-src="https://miro.medium.com/v2/resize:fit:1146/format:webp/1*as1heI-qkZCxWCNo8-HVUQ.png"/></div></figure><p id="981c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们再次开始这个过程，我们查看队列中的第一个元素是什么。我们看到它是25。然后我们输出/打印它，并将其从队列中移除(出列)。</p><p id="b4fc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">产量:25</p><p id="b3a3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们评估25的子节点，看到它们都不是，我们继续处理队列中的下一个项目。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/67ee9471d33cb1f0264a2d7fd1550c23.png" data-original-src="https://miro.medium.com/v2/resize:fit:152/format:webp/1*kn6aP-XDwDPZTBqFeDh7NQ.png"/></div></figure><figure class="ma mb mc md gt jr gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/f1a81f6a783ebef876eaa5c22b7276f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1122/format:webp/1*A1_kqsWOokfUND1wYouJFw.png"/></div></figure><p id="aaff" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们接着看peak，我们队列中的第一项，75。我们将它输出/打印出来，然后从列表中删除它(出列)。</p><p id="a3db" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">产量:75</p><p id="7a2f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们检查75的子节点，发现它们都不是。我们继续处理队列中的下一项。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/2cbe2d4c133385cb05e90cd79c8ae625.png" data-original-src="https://miro.medium.com/v2/resize:fit:110/format:webp/1*TvqD9Wau8OAgyinjyng_Yw.png"/></div></figure><p id="abb9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们重新开始，我们检查队列中的第一个项目350。我们输出/打印它，然后从队列中移除350(出列)该项目。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/1ed704f6b933d9371568a875427e27f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1128/format:webp/1*z6NUV1pmCQrU4YoIukK9rg.png"/></div></figure><p id="b39a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">产量:350</p><p id="91e8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们接着检查，350的子节点是什么。我们看到它们都不是，我们完成了我们的层次顺序遍历。</p><figure class="ma mb mc md gt jr gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/b1eb46d4487664e0caa2c3a6db639500.png" data-original-src="https://miro.medium.com/v2/resize:fit:242/format:webp/1*gum_AACpnOauG7PJF9Wliw.png"/></div></figure><p id="eb68" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是一个相当累人的编写过程，幸运的是，计算机可以很容易地做到这一点，利用了一个被称为递归的过程。让我们把我们的过程写成代码。</p><h1 id="0a9c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">代码实现</h1><h2 id="42ed" class="mq lc iq bd ld mr ms dn lh mt mu dp ll ko mv mw lp ks mx my lt kw mz na lx nb bi translated">算法</h2><ol class=""><li id="f974" class="nc nd iq kf b kg ne kk nf ko ng ks nh kw ni la nj nk nl nm bi translated">我们需要定义队列数据结构，以便于层次顺序遍历。</li><li id="52a0" class="nc nd iq kf b kg nn kk no ko np ks nq kw nr la nj nk nl nm bi translated">我们将根节点插入到队列中。</li><li id="560b" class="nc nd iq kf b kg nn kk no ko np ks nq kw nr la nj nk nl nm bi translated">将节点从队列数据结构中出队。</li><li id="c62f" class="nc nd iq kf b kg nn kk no ko np ks nq kw nr la nj nk nl nm bi translated">打印节点中的元素</li><li id="22ca" class="nc nd iq kf b kg nn kk no ko np ks nq kw nr la nj nk nl nm bi translated">将左边的孩子排入队列</li><li id="ecb2" class="nc nd iq kf b kg nn kk no ko np ks nq kw nr la nj nk nl nm bi translated">将正确的孩子排入队列</li></ol><p id="e7cf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将使用Python来实现代码。</p><p id="19c7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将从实现队列数据结构开始。</p><pre class="ma mb mc md gt ns nt nu nv aw nw bi"><span id="5719" class="mq lc iq nt b gy nx ny l nz oa">form queue import Queue</span></pre><p id="a306" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后创建一个二叉树类，我们不能只是遍历一棵树，而不告诉我们不太聪明的朋友，解释器我们想要创建一棵树。然后我们需要告诉它遍历树，以及如何遍历树。</p><pre class="ma mb mc md gt ns nt nu nv aw nw bi"><span id="cac5" class="mq lc iq nt b gy nx ny l nz oa">class BinaryTreeNode:<br/>    def__init__(self,data):<br/>        self.data = data<br/>        self.leftChild = None<br/>        self.rightChild = None</span></pre><p id="6cad" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们已经告诉解释器创建一个二叉树节点，它将接受数据作为输入，左右子节点将开始为空。</p><pre class="ma mb mc md gt ns nt nu nv aw nw bi"><span id="475c" class="mq lc iq nt b gy nx ny l nz oa">def levelorder(root):<br/>    Q = Queue()<br/>    Q.put(root)<br/>    while(not Q.empty()):<br/>        node = Q.get()<br/>        if node == None:<br/>            continue<br/>        print(node.data)<br/>Q.put(node.leftChild)<br/>Q.put(node.rightChild)<br/></span></pre><p id="89cf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面是我们的层次顺序函数，它告诉解释器如何遍历二叉树。</p><p id="4d0b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，当我们的队列不为空时，我们将根节点插入(入队)到队列中，输出/打印根节点的值，然后将其从队列中出队。然后评估根节点的子节点，如果有子节点的话，首先将它们插入到队列中的左子节点，然后是右子节点。</p><pre class="ma mb mc md gt ns nt nu nv aw nw bi"><span id="163f" class="mq lc iq nt b gy nx ny l nz oa">def insert (root, newValue):<br/>    if root is None:<br/>        root = BinaryTreeNode(NewValue)<br/>            return root<br/>    if newValue &lt; root.data:<br/>        root.leftChild = insert(root.leftChild,newValue)<br/>    else:<br/>        root.rightChild = insert(root.rightChild,newValue)<br/>            return root<br/></span></pre><p id="e679" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以上是我们的插入函数，我们如何告诉解释器插入项目。如果根节点是空的，那么创建一个二叉树并创建一个新节点，它将是根节点。</p><p id="a8c8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果新值大于当前值(根)，则将该值插入左侧。如果值小于根，则将其插入右侧。</p><pre class="ma mb mc md gt ns nt nu nv aw nw bi"><span id="4938" class="mq lc iq nt b gy nx ny l nz oa">root = insert(None, 100)<br/>insert(root,50)<br/>insert(root,200)<br/>insert(root,25)<br/>insert(root,75)<br/>insert(root,350)</span></pre><p id="ad8f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们给解释器我们想要它执行遍历的值。</p></div></div>    
</body>
</html>