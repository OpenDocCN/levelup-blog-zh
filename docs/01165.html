<html>
<head>
<title>Closures, Private Data, and Inheritance in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的闭包、私有数据和继承</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/inheritance-private-data-and-closures-in-javascript-5618bc78ebf2?source=collection_archive---------4-----------------------#2019-11-20">https://levelup.gitconnected.com/inheritance-private-data-and-closures-in-javascript-5618bc78ebf2?source=collection_archive---------4-----------------------#2019-11-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="192b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">理解闭包是在JavaScript中实现私有数据的关键。</h2></div><p id="8cd6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">众所周知，JavaScript有好的部分，也有不好的部分。</p><p id="df9e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这使得开发人员的工作变得非常容易:</p><ol class=""><li id="f997" class="le lf it kk b kl km ko kp kr lg kv lh kz li ld lj lk ll lm bi translated">使用好的部分。</li><li id="2456" class="le lf it kk b kl ln ko lo kr lp kv lq kz lr ld lj lk ll lm bi translated">不要用坏的部分。</li></ol><p id="d190" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">JavaScript的一个优点是<strong class="kk iu">闭包</strong>。闭包是通过定义函数来创建的。函数和函数块中的变量保留对定义时在范围内的数据的访问。这是一个非常强大的工具。为了创建一个闭包，我们<strong class="kk iu">定义了一个返回函数</strong>的函数，这个内部函数会记住在外部函数中创建的变量的值。</p><figure class="ls lt lu lv gt lw"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="4543" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这个例子中，由函数<code class="fe lz ma mb mc b">counter</code>创建的闭包包含对以下内容的引用:</p><ol class=""><li id="98f5" class="le lf it kk b kl km ko kp kr lg kv lh kz li ld lj lk ll lm bi translated">定义时全局范围内的任何变量。</li><li id="eb53" class="le lf it kk b kl ln ko lo kr lp kv lq kz lr ld lj lk ll lm bi translated"><code class="fe lz ma mb mc b">count</code>局部变量。</li></ol><p id="ca88" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，当<code class="fe lz ma mb mc b">addCounter</code>被赋值指向第10行<code class="fe lz ma mb mc b">counter()</code>的返回值时，从<code class="fe lz ma mb mc b">counter()</code>返回的函数可以被调用而不会引发异常。<code class="fe lz ma mb mc b">addCounter</code>保留对局部变量<code class="fe lz ma mb mc b">count</code>的访问，因为<code class="fe lz ma mb mc b">count</code>在由<code class="fe lz ma mb mc b">counter()</code>创建的<strong class="kk iu">闭包</strong>内。因此，<code class="fe lz ma mb mc b">count</code>可以随着<code class="fe lz ma mb mc b">addCounter()</code>的调用而递增，即使<code class="fe lz ma mb mc b">addCounter()</code>在声明<code class="fe lz ma mb mc b">count</code>的范围之外被调用。</p><blockquote class="md me mf"><p id="6942" class="ki kj mg kk b kl km ju kn ko kp jx kq mh ks kt ku mi kw kx ky mj la lb lc ld im bi translated">需要注意的一点是<code class="fe lz ma mb mc b">count</code>是私有数据；除了<code class="fe lz ma mb mc b">addCounter()</code>之外，它不能被任何东西引用或访问。</p></blockquote><p id="2c78" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是一张(手绘)图，显示了<code class="fe lz ma mb mc b">addCounter()</code>如何引用和重新分配<code class="fe lz ma mb mc b">count</code>。</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mk"><img src="../Images/524a92a6c6611b8436aba2c89fe1a0a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6ep-R9G4i10lSolW8X183Q.jpeg"/></div></div></figure><p id="0c03" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对<code class="fe lz ma mb mc b">count</code>的引用被维护，并且在<code class="fe lz ma mb mc b">counter</code>被调用后不会被垃圾收集，因为仍然有一个变量<code class="fe lz ma mb mc b">addCounter</code>，它引用由<code class="fe lz ma mb mc b">counter()</code>创建的闭包。</p><p id="d1cd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">闭包封装数据的能力非常有用。当讨论转向对象、继承和私有数据时，请记住这一点。</p></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="31ac" class="my mz it bd na nb nc nd ne nf ng nh ni jz nj ka nk kc nl kd nm kf nn kg no np bi translated">对象和私有数据</h1><p id="5eb5" class="pw-post-body-paragraph ki kj it kk b kl nq ju kn ko nr jx kq kr ns kt ku kv nt kx ky kz nu lb lc ld im bi translated">在JavaScript中使用对象产生的一个问题是缺乏隐私。因为对象是可以用<strong class="kk iu">点</strong>或<strong class="kk iu">括号符号</strong>访问的属性集合，所以对于懂JavaScript的人来说，访问保存在对象内部的数据是一件小事。</p><figure class="ls lt lu lv gt lw"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="7765" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个问题甚至更深层次。假设一个应用程序中涉及到继承层次结构；开发人员如何保护可以通过原型查找链访问的数据？</p><p id="e0d1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要回答这个问题，请检查下面的代码。这是<strong class="kk iu">伪经典继承</strong>的一个例子，也是一种常见的创建模式，用于在JavaScript中创建相互继承的对象。</p><figure class="ls lt lu lv gt lw"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="d019" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如第17-20行所示，<code class="fe lz ma mb mc b">Person</code>或<code class="fe lz ma mb mc b">Teacher</code>的任何属性都可以通过使用<strong class="kk iu">点</strong>或<strong class="kk iu">括号符号</strong>来访问。对于任何来自Ruby背景的人来说，这里有封装数据的私有方法、类和对象——这段代码应该发出一些危险信号。</p><p id="b4c7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">JavaScript开发人员可以在他们的程序中实现私有数据的一种方法是将对象数据的访问限制为只有方法或函数调用。通过限制对方法或函数调用的属性访问，开发人员可以控制<strong class="kk iu">如何</strong>和<strong class="kk iu">何时</strong>引用或操作对象中存储的数据。</p><p id="5cb0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了同时实现封装和继承，可以使用寄生继承，这是由道格拉斯·克洛克福特提出的概念。</p></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="958e" class="my mz it bd na nb nc nd ne nf ng nh ni jz nj ka nk kc nl kd nm kf nn kg no np bi translated">寄生继承支持私有数据</h1><p id="59d0" class="pw-post-body-paragraph ki kj it kk b kl nq ju kn ko nr jx kq kr ns kt ku kv nt kx ky kz nu lb lc ld im bi translated">几乎没有人喜欢<em class="mg">寄生</em>这个词。当一个人说出这个词时，扁虱、绦虫和一大堆其他讨厌的生物就会浮现在脑海里。</p><p id="3613" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，在编程环境中，寄生行为可能非常有效。</p><p id="6a20" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">寄生虫成功的原因是什么？</p><p id="3da5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">寄生虫非常足智多谋。它依靠宿主的资源生存。它需要做的工作越少，它就是一个越好的寄生虫。</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi nv"><img src="../Images/b3d7dbce8ea60a5cdb9f0ca1e339814a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ftD494u0ffrp6-whLYBXbw.jpeg"/></div></div><figcaption class="nw nx gj gh gi ny nz bd b be z dk translated">这些不是真正的寄生虫——没人想看真的。</figcaption></figure><p id="04e0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在JavaScript中，开发人员可以通过在一个函数中调用另一个函数来复制这种寄生行为。这样，一个函数可以使用另一个函数调用的资源和工作。这里有一个可以被认为是<strong class="kk iu">寄生</strong>的函数的例子。</p><figure class="ls lt lu lv gt lw"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="8a96" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">可以看到，<code class="fe lz ma mb mc b">parasiteSum</code>除了调用一个函数并返回那个值之外，不需要做任何实际的工作。<code class="fe lz ma mb mc b">sumAllNumbers</code>是完成计算所有<code class="fe lz ma mb mc b">...numbers</code>总和这一艰巨任务的函数。这可以被认为是寄生行为。</p><p id="a7c3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">继承也可以用这个概念来复制。</p><p id="0d0e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">出于本文的目的，假设有一个应用程序需要表示人及其未来职业的对象。</p><p id="fe01" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，声明一个名为<code class="fe lz ma mb mc b">Person</code>的函数。这是<code class="fe lz ma mb mc b">Person</code>对象被实例化和返回的地方。返回一个可以访问<code class="fe lz ma mb mc b">name</code>属性和<code class="fe lz ma mb mc b">age</code>属性的对象。</p><figure class="ls lt lu lv gt lw"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="8308" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">读者可能想知道:这个练习的目的不就是创建私有数据吗？<code class="fe lz ma mb mc b">name</code>和<code class="fe lz ma mb mc b">age</code>很容易被访问，除了在<code class="fe lz ma mb mc b">Person</code>对象上没有任何启用数据访问的方法。</p><p id="f515" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">修改是必要的。这个问题要求<code class="fe lz ma mb mc b">name</code>和<code class="fe lz ma mb mc b">age</code>属性是私有的，但是它们也必须是可访问的，并且与返回的<code class="fe lz ma mb mc b">Person</code>对象一起传递。因为属性不能是私有的，所以使用属性来存储数据对于这个问题来说不是一个好主意。</p><p id="a600" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">回想一下<strong class="kk iu">闭包</strong>。有没有办法在函数范围内保留对变量的引用？</p><p id="ebdd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">是的，有。当<code class="fe lz ma mb mc b">name</code>和<code class="fe lz ma mb mc b">age</code>被定义为<code class="fe lz ma mb mc b">Person</code>的参数时，局部变量通过它们各自的名称被声明。下面的代码展示了JavaScript如何处理函数及其参数。</p><figure class="ls lt lu lv gt lw"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="b5ce" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为这些参数在<code class="fe lz ma mb mc b">Person</code>的闭包中被隐式声明为局部变量，所以从<code class="fe lz ma mb mc b">Person</code>返回的对象可以访问最初传递给<code class="fe lz ma mb mc b">Person</code>的参数，因为它们被存储为局部变量。<code class="fe lz ma mb mc b">Person</code>对象保留对<code class="fe lz ma mb mc b">name</code>和<code class="fe lz ma mb mc b">age</code>的访问，因为它们是其闭包的一部分。</p><blockquote class="md me mf"><p id="caec" class="ki kj mg kk b kl km ju kn ko kp jx kq mh ks kt ku mi kw kx ky mj la lb lc ld im bi translated">这与本文开始时负责<code class="fe lz ma mb mc b">addCounter</code>功能的机制相同。</p></blockquote><p id="d803" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">重构之前的解决方案。在返回对象内部，包含两个<strong class="kk iu"> getter </strong>方法:一个用于<code class="fe lz ma mb mc b">name</code>，一个用于<code class="fe lz ma mb mc b">age</code>。这些方法将用于保留对变量<code class="fe lz ma mb mc b">name</code>和<code class="fe lz ma mb mc b">age</code>的访问。</p><figure class="ls lt lu lv gt lw"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="3cc8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">可以看到，对象上不再有存储数据的属性；相反，有一些方法可以访问属性保存的数据。结果，闭包和getter方法的组合为<code class="fe lz ma mb mc b">Person</code>对象创建了封装。</p><p id="2954" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下一步是实现<code class="fe lz ma mb mc b">Person</code>和<code class="fe lz ma mb mc b">Teacher</code>之间的继承。选择“老师”是因为<strong class="kk iu">所有的</strong>老师都是<strong class="kk iu">人</strong>。因此，<code class="fe lz ma mb mc b">Teacher</code>继承了<code class="fe lz ma mb mc b">Person</code>的行为，因为它们是类<code class="fe lz ma mb mc b">Person</code>的成员。</p><p id="0afc" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">声明一个以<code class="fe lz ma mb mc b">name</code>、<code class="fe lz ma mb mc b">age</code>和<code class="fe lz ma mb mc b">subject</code>为参数的<code class="fe lz ma mb mc b">Teacher</code>函数。在<code class="fe lz ma mb mc b">Teacher</code>函数中，返回一个继承自<code class="fe lz ma mb mc b">Person</code>的对象。此外，该对象应该具有行为<code class="fe lz ma mb mc b">teach</code>，该行为返回一个字符串，说明<code class="fe lz ma mb mc b">Teacher</code>的<code class="fe lz ma mb mc b">name</code>以及它们所教授的<code class="fe lz ma mb mc b">subject</code>。</p><figure class="ls lt lu lv gt lw"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="7a78" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这个解决方案中，<code class="fe lz ma mb mc b">self</code>指向从<code class="fe lz ma mb mc b">Person()</code>返回的<code class="fe lz ma mb mc b">Person</code>对象。通过将对象实例化外包给<code class="fe lz ma mb mc b">Person</code>，寄生行为被用在<code class="fe lz ma mb mc b">Teacher</code>函数中。然后，<code class="fe lz ma mb mc b">self</code>被赋予一个属性<code class="fe lz ma mb mc b">teach</code>，它作为<code class="fe lz ma mb mc b">subject</code>局部变量的<strong class="kk iu"> getter </strong>方法。最后，<code class="fe lz ma mb mc b">Teacher</code>返回<code class="fe lz ma mb mc b">self</code>，它是<code class="fe lz ma mb mc b">Person</code>对象，但是具有额外的数据和行为。</p><p id="4357" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">多亏了闭包，<code class="fe lz ma mb mc b">Teacher</code>对象保留了对局部变量<code class="fe lz ma mb mc b">name</code>、<code class="fe lz ma mb mc b">age</code>和<code class="fe lz ma mb mc b">subject</code>的访问。</p><p id="38e1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">可以看到，<strong class="kk iu">寄生继承</strong>可以用来创建私有数据和对象之间的继承。</p></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="806c" class="my mz it bd na nb nc nd ne nf ng nh ni jz nj ka nk kc nl kd nm kf nn kg no np bi translated">最后的想法</h1><p id="0dd4" class="pw-post-body-paragraph ki kj it kk b kl nq ju kn ko nr jx kq kr ns kt ku kv nt kx ky kz nu lb lc ld im bi translated">这个问题非常适合寄生遗传；然而，大多数关于原型继承的问题并不是这样。在大多数使用继承的情况下，应该有一些方法来引用调用对象的父对象。</p><p id="5d48" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">寄生继承是可能的，但是伪经典继承和OLOO(链接到其他对象的对象)做得更好，因为它们可以使用<code class="fe lz ma mb mc b">Object</code>和<code class="fe lz ma mb mc b">Object.prototype</code>方法来引用对象的<strong class="kk iu">原型对象</strong>。</p><p id="0123" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">寄生继承失败的另一个领域是不必要的重复。<code class="fe lz ma mb mc b">Teacher</code>的每个实例都有来自<code class="fe lz ma mb mc b">Person</code>的方法的实际副本。理想的解决方案是，当调用那些方法时，<code class="fe lz ma mb mc b">Teacher</code>实例引用来自<code class="fe lz ma mb mc b">Person</code>的方法，从而将方法的工作和存储外包给单个对象。OLOO和伪经典遗传比寄生遗传更能减少冗余。</p><p id="6440" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，当一个问题需要封装数据并且对象存在于继承层次结构中时，寄生继承可能是完美的解决方案。</p><p id="bf85" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">编码快乐！</p></div></div>    
</body>
</html>