<html>
<head>
<title>How to do Twitter Network Analysis and Visualization in R</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在R中进行Twitter网络分析和可视化</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-do-amazing-twitter-network-analysis-in-r-2c258537dd7d?source=collection_archive---------4-----------------------#2022-06-26">https://levelup.gitconnected.com/how-to-do-amazing-twitter-network-analysis-in-r-2c258537dd7d?source=collection_archive---------4-----------------------#2022-06-26</a></blockquote><div><div class="fc ij ik il im in"/><div class="io ip iq ir is"><div class=""/><div class=""><h2 id="4470" class="pw-subtitle-paragraph js iu iv bd b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj dk translated">以英国政治家的Twitter网络为例，学习如何进行引人入胜的网络分析和可视化</h2></div><p id="ffec" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">在这篇文章中，我将向你展示如何分析Twitter上有趣的人群网络。感谢像<code class="fe lg lh li lj b">rtweet</code>这样伟大的R包，使用像<code class="fe lg lh li lj b">igraph</code>这样的经典包和像<code class="fe lg lh li lj b">ggraph</code>这样的可视化工具，这里的一切都是令人惊讶的。在文章的最后，我还将给出如何使用Javascript的D3来创建最令人惊叹的交互式可视化的指导，就像这样:</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi lk"><img src="../Images/0d74d4100fd21efadc4ed1172398343b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0iC9-Tq6t5UkOrNoBZU_fw.png"/></div></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk translated">作者使用Javascript中的D3创建的交互式英国MP Twitter网络(此处提供<a class="ae ma" href="https://ona-book.org/mp_twitter.html" rel="noopener ugc nofollow" target="_blank">和</a></figcaption></figure><p id="d8d4" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">本文中的说明是我的新书《用R和Python进行网络分析》后面章节中更全面说明的总结版本，该书现在可以在网上免费获得，也可以从CRC出版社获得。</p><p id="5435" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">在这个例子中，我将基于英国国会议员的Twitter互动建立一个网络。Twitter互动被视为提及、回复、转发或引用另一名议员的推文。在我们的网络中，如果两个议员在过去的500条推文中至少有一次互动，他们就会被连接起来，互动的数量将决定连接的强度。</p><h2 id="6704" class="mb mc iv bd md me mf dn mg mh mi dp mj kt mk ml mm kx mn mo mp lb mq mr ms mt bi translated">提取Twitter数据</h2><p id="77c5" class="pw-post-body-paragraph kk kl iv km b kn mu jw kp kq mv jz ks kt mw kv kw kx mx kz la lb my ld le lf io bi translated"><code class="fe lg lh li lj b">rtweet</code>包允许通过Twitter API轻松提取数据。在这种情况下，我们将基于英国议员之间的互动来构建我们的网络。英国议员和他们所代表的政党的推特详细信息列表可以在<em class="mz">政治社交</em>网站<a class="ae ma" href="https://www.politics-social.com/list/party" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="30a0" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">要访问Twitter API，你需要一个Twitter账户，然后你需要通过<a class="ae ma" href="https://developer.twitter.com/en" rel="noopener ugc nofollow" target="_blank"> Twitter开发者平台</a>注册访问API。一旦您注册并设置了一个应用程序，您将获得一组密码，您可以在<code class="fe lg lh li lj b">rtweet</code>中使用这些密码通过<code class="fe lg lh li lj b">create_token()</code>功能验证您的访问。</p><pre class="ll lm ln lo gt na lj nb nc aw nd bi"><span id="723b" class="mb mc iv lj b gy ne nf l ng nh">library(rtweet)</span><span id="6c88" class="mb mc iv lj b gy ni nf l ng nh">token &lt;- create_token(<br/>  app = "YOUR_APP_NAME",<br/>  consumer_key = "YOUR_API_KEY",<br/>  consumer_secret = "YOUR_API_KEY_SECRET",<br/>  access_token = "YOUR_ACCESS_TOKEN",<br/>  access_secret = "YOUR_ACCESS_TOKEN_SECRET"<br/>)</span></pre><p id="6fc6" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">这是一次性的身份验证，您的访问凭证现在将永久地存储在R环境中，因此在以后的会话中不需要重新进行身份验证。</p><p id="8fdc" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">现在我们已经通过了认证，我们需要下载所有议员的时间表，以便在他们之间建立联系。首先我们从<em class="mz">政治社交:</em>下载议员名单</p><pre class="ll lm ln lo gt na lj nb nc aw nd bi"><span id="76fa" class="mb mc iv lj b gy ne nf l ng nh"># download MP list from Politics Social<br/>url &lt;- "<a class="ae ma" href="https://www.politics-social.com/api/list/csv/party" rel="noopener ugc nofollow" target="_blank">https://www.politics-social.com/api/list/csv/party</a>"<br/>mp_list &lt;- read.csv(url)</span></pre><p id="7f00" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated"><code class="fe lg lh li lj b">Screen.name</code>列为我们提供了这些议员的Twitter句柄，因此我们可以在<code class="fe lg lh li lj b">rtweet</code>的<code class="fe lg lh li lj b">get_timeline()</code>函数中使用这个句柄来提取每个议员的最后500条推文。由于Twitter API在15分钟内运行180条时间线的速率限制，我们将不得不把我们的API调用分成间隔15分钟的几次尝试。例如，我们的第一个电话将是:</p><pre class="ll lm ln lo gt na lj nb nc aw nd bi"><span id="1edf" class="mb mc iv lj b gy ne nf l ng nh"># first batch<br/>results1 &lt;- rtweet::get_timeline(<br/>  user = mp_list$Screen.name[1:180],<br/>  n = rep(500, 180)<br/>)</span></pre><p id="769f" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">这可能需要一段时间。一旦完成，等待15分钟，然后逐步尝试下面的方法，最后将它们捆绑起来。</p><pre class="ll lm ln lo gt na lj nb nc aw nd bi"><span id="d13b" class="mb mc iv lj b gy ne nf l ng nh"># second batch (at least 15 mins since first batch)<br/>results2 &lt;- rtweet::get_timeline(<br/>  user = mp_list$Screen.name[181:360],<br/>  n = rep(500, 180)<br/>)</span><span id="ba4d" class="mb mc iv lj b gy ni nf l ng nh"># third batch (at least 15 mins since second batch)<br/>results3 &lt;- rtweet::get_timeline(<br/>  user = mp_list$Screen.name[361:540],<br/>  n = rep(500, 180)<br/>)</span><span id="abe7" class="mb mc iv lj b gy ni nf l ng nh"># fourth batch (at least 15 mins since third batch)<br/>results4 &lt;- rtweet::get_timeline(<br/>  user = mp_list$Screen.name[541:length(mp_list$Screen.name)],<br/>  n = rep(500, length(mp_list$Screen.name) - 540)<br/>)</span><span id="5cfb" class="mb mc iv lj b gy ni nf l ng nh"># combine all results<br/>results &lt;- rbind(results1, results2, results3, results4)</span></pre><p id="29f6" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">这提供了一个非常丰富的数据集，每个议员最近500条推文中的每条都有90列数据，包括指示任何其他被提及、回复、引用或转发的Twitter句柄的特定字段。这是一个很好的数据集，我们可以用它来构建我们的网络图。</p><h2 id="85f8" class="mb mc iv bd md me mf dn mg mh mi dp mj kt mk ml mm kx mn mo mp lb mq mr ms mt bi translated">创建图边列表和顶点集</h2><p id="eb4f" class="pw-post-body-paragraph kk kl iv km b kn mu jw kp kq mv jz ks kt mw kv kw kx mx kz la lb my ld le lf io bi translated">在我们从Twitter中提取的大型数据集中，我们感兴趣的每个MP tweet有四个字段:<code class="fe lg lh li lj b">mentions_screen_name</code>、<code class="fe lg lh li lj b">retweet_screen_name</code>、<code class="fe lg lh li lj b">reply_to_screen_name</code>和<code class="fe lg lh li lj b">quoted_screen_name</code>。由于所有这些都以<code class="fe lg lh li lj b">screen_name</code>结尾，我们可以使用一些好的<code class="fe lg lh li lj b">tidyverse</code>函数来创建一个网络边列表。我们希望我们的网络边缘列表包括<code class="fe lg lh li lj b">from</code>和<code class="fe lg lh li lj b">to</code> Twitter句柄以及权重，这将是一个MP到另一个MP的交互次数的计数。注意，Twitter是一个有向网络，所以不同方向的两个MP之间的交互是分开统计的。</p><p id="4a35" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">首先，我们编写一个函数来为给定的MP生成网络:</p><pre class="ll lm ln lo gt na lj nb nc aw nd bi"><span id="2a15" class="mb mc iv lj b gy ne nf l ng nh">library(tidyverse)</span><span id="2e8f" class="mb mc iv lj b gy ni nf l ng nh"># function to create edgelist for single MP<br/>count_and_group &lt;- function (df) {<br/>  df |&gt; <br/>    dplyr::select(ends_with("screen_name")) |&gt; <br/>    unlist() |&gt; <br/>    tibble(interacted_with = _) |&gt; <br/>    tidyr::drop_na() |&gt; <br/>    dplyr::group_by(interacted_with) |&gt; <br/>    dplyr::summarise(weight = n()) |&gt; <br/>    dplyr::filter(<br/>      # ensures that only MP interactions are returned<br/>      interacted_with %in% substr(mp_list$Screen.name, 2, nchar(mp_list$Screen.name))<br/>    )<br/>}</span></pre><p id="8b02" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">现在我们编写一个函数，将该函数应用于数据帧中的所有MPs:</p><pre class="ll lm ln lo gt na lj nb nc aw nd bi"><span id="319c" class="mb mc iv lj b gy ne nf l ng nh"># function to generate edgelist across all MPs<br/>create_edgelist &lt;- function(tweet_df) {<br/>  tweet_df |&gt; <br/>    dplyr::nest_by(screen_name) |&gt; <br/>    dplyr::summarise(count_and_group(data)) |&gt; <br/>    # ignore interactions with self<br/>    dplyr::filter(screen_name != interacted_with) |&gt; <br/>    dplyr::rename(from = screen_name, to = interacted_with)<br/>}</span></pre><p id="37d4" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">现在，我们简单地将我们的<code class="fe lg lh li lj b">create_edgelist()</code>函数应用于我们从Twitter中提取的大型<code class="fe lg lh li lj b">results</code>数据帧，这将为我们生成我们的edgelist。</p><pre class="ll lm ln lo gt na lj nb nc aw nd bi"><span id="a86d" class="mb mc iv lj b gy ne nf l ng nh"># create final edgelist<br/>mp_edgelist &lt;- create_edgelist(results)</span></pre><p id="7288" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">这应该是我们的edgelist的前几行，有一个<code class="fe lg lh li lj b">from</code>、<code class="fe lg lh li lj b">to</code>和<code class="fe lg lh li lj b">weight</code>列。</p><pre class="ll lm ln lo gt na lj nb nc aw nd bi"><span id="444e" class="mb mc iv lj b gy ne nf l ng nh">          from              to weight<br/>1 _OliviaBlake    Afzal4Gorton      2<br/>2 _OliviaBlake alanwhiteheadmp      4<br/>3 _OliviaBlake   Alex_Stafford      4<br/>4 _OliviaBlake       alexsobel      4<br/>5 _OliviaBlake  AlokSharma_RDG      1<br/>6 _OliviaBlake  AndyMcDonaldMP      2</span></pre><p id="699f" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">我们还可以为每个议员创建一组包含各种有趣属性的顶点，比如他们的政党、选区、Twitter追随者的数量。我们甚至可以从我们的<code class="fe lg lh li lj b">results</code>数据框中获得他们的Twitter个人资料图片的URL，我们还可以添加一些官方政党的颜色。所有这些都将有助于创造伟大的直观形象。</p><pre class="ll lm ln lo gt na lj nb nc aw nd bi"><span id="2327" class="mb mc iv lj b gy ne nf l ng nh"># create vertex dataframe<br/>mp_vertices &lt;- results %&gt;%<br/>  select(screen_name, profile_image_url, followers_count) %&gt;%<br/>  distinct() |&gt; <br/>  left_join(<br/>    mp_list |&gt; <br/>      dplyr::mutate(<br/>        screen_name = substr(Screen.name, 2, nchar(Screen.name))<br/>      ) |&gt; <br/>      dplyr::select(<br/>        screen_name,<br/>        constituency = Constituency,<br/>        party = Party,<br/>        name = Name<br/>      )<br/>  )</span><span id="a938" class="mb mc iv lj b gy ni nf l ng nh"># add party colours from politics social<br/>parties &lt;- mp_vertices$party |&gt; unique()<br/>party_colours &lt;- c("#000000", "#216a4d", "#008a49",<br/>                   "#d3c200", "#3d8028", "#f5b52e",<br/>                   "#dd0339", "#cccccc", "#66ab21",<br/>                   "#c2282a", "#018fda", "#eec52e")</span><span id="db01" class="mb mc iv lj b gy ni nf l ng nh">color_df &lt;- data.frame(<br/>  party = parties,<br/>  colour = party_colours<br/>)</span><span id="fbc1" class="mb mc iv lj b gy ni nf l ng nh">mp_vertices &lt;- mp_vertices |&gt; <br/>  left_join(color_df)</span></pre><p id="8c3c" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">最后，过去的Twitter交互可能是与不再活跃的议员的Twitter帐户发生的，这将导致我们的网络图出现问题，因此我们可以快速摆脱这些:</p><pre class="ll lm ln lo gt na lj nb nc aw nd bi"><span id="c958" class="mb mc iv lj b gy ne nf l ng nh">mp_edgelist &lt;- mp_edgelist |&gt; <br/>  dplyr::filter(to %in% mp_vertices$screen_name)</span></pre><h2 id="a685" class="mb mc iv bd md me mf dn mg mh mi dp mj kt mk ml mm kx mn mo mp lb mq mr ms mt bi translated">创建和可视化我们的MP Twitter网络</h2><p id="3cdb" class="pw-post-body-paragraph kk kl iv km b kn mu jw kp kq mv jz ks kt mw kv kw kx mx kz la lb my ld le lf io bi translated">现在我们有了边列表和顶点数据框架，我们的大量艰苦工作已经完成。由此创建网络图相当简单。为了简单起见，让我们创建一个无向图，其中我们将两个MP之间在任何方向上的任何交互视为一个连接。为此，我们将使用<code class="fe lg lh li lj b">igraph</code>包中的<code class="fe lg lh li lj b">graph_from_data_frame()</code>函数。</p><pre class="ll lm ln lo gt na lj nb nc aw nd bi"><span id="3413" class="mb mc iv lj b gy ne nf l ng nh">library(igraph)</span><span id="d1ef" class="mb mc iv lj b gy ni nf l ng nh">(mp_graph_undirected &lt;- igraph::graph_from_data_frame(<br/>  mp_edgelist, <br/>  vertices = mp_vertices,<br/>  directed = FALSE<br/>))</span></pre><p id="0cd1" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">现在，我们可以快速查看一下我们的网络属性:</p><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi nj"><img src="../Images/173b55f72baf740e64f32f5ddc10cd70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EcX5y8c4L3awnXEhNtLDcw.png"/></div></div></figure><p id="157d" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">这表明我们有一个585个顶点和26，833条边的无向、命名和加权网络。顶点具有属性<code class="fe lg lh li lj b">name</code>、<code class="fe lg lh li lj b">profile_image_url</code>、<code class="fe lg lh li lj b">followers_count</code>、<code class="fe lg lh li lj b">constituency</code>、<code class="fe lg lh li lj b">party</code>和<code class="fe lg lh li lj b">colour</code>，而边具有属性<code class="fe lg lh li lj b">weight</code>。</p><p id="3165" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">如果我们愿意，我们可以对网络进行可视化，每个顶点都用政党来着色。如果我们使用力定向算法，具有较强连接的顶点将更容易相互吸引，而没有连接强度或连接强度低的顶点将被推得更远。我们可以使用<code class="fe lg lh li lj b">ggraph</code>包来创建使用<code class="fe lg lh li lj b">ggplot2 </code>语法的图表。</p><pre class="ll lm ln lo gt na lj nb nc aw nd bi"><span id="01d0" class="mb mc iv lj b gy ne nf l ng nh">library(ggraph)</span><span id="10a2" class="mb mc iv lj b gy ni nf l ng nh"># visualize ground truth political party communities<br/>party_colours &lt;- mp_vertices |&gt; <br/>  dplyr::select(party, colour) |&gt; <br/>  dplyr::distinct()</span><span id="a661" class="mb mc iv lj b gy ni nf l ng nh">set.seed(123)<br/>ggraph(mp_graph_undirected, layout = "fr") +<br/>  geom_edge_link(color = "grey", alpha = 0.7) + <br/>  geom_node_point(aes(color = factor(party)), size = 1) +<br/>  theme_void() + <br/>  scale_colour_manual(limits = party_colours$party, <br/>                      values = party_colours$colour, name = "Party")</span></pre><figure class="ll lm ln lo gt lp gh gi paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="gh gi nk"><img src="../Images/923c93d69bc6dbceb45338472b8bcac7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*opTSkilpf5eI-st6Y-j2XQ.png"/></div></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk translated">英国国会议员推特网络受政党影响的武力导向图</figcaption></figure><p id="6e8b" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">正如我们所看到的，政党倾向于被分组在一起，这表明同一政党的成员之间有很强的Twitter互动。这只是我们可以用我们的网络做什么的一个小例子，你可以发现更多可以做的可能的分析，包括社区和小团体检测，以及在我的书的第10章中识别网络中的重要参与者。</p><h2 id="2cf8" class="mb mc iv bd md me mf dn mg mh mi dp mj kt mk ml mm kx mn mo mp lb mq mr ms mt bi translated">在Javascript中使用D3创建令人惊叹的可视化效果</h2><p id="9d24" class="pw-post-body-paragraph kk kl iv km b kn mu jw kp kq mv jz ks kt mw kv kw kx mx kz la lb my ld le lf io bi translated">为了保持本文的长度合理，我不会在这里深入介绍复杂的细节，但是如果你足够勇敢，敢于尝试一些Javascript编程，你可以将你的网络数据导出为JSON，并使用它和D3的force directed网络功能来创建令人惊叹的MP Twitter网络的交互式可视化，例如<a class="ae ma" href="https://ona-book.org/mp_twitter.html" rel="noopener ugc nofollow" target="_blank">这个</a>。</p><p id="c3da" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">在我的书的第11章的<a class="ae ma" href="https://ona-book.org/advanced-viz.html" rel="noopener ugc nofollow" target="_blank">中，我给出了关于如何将你的<code class="fe lg lh li lj b">igraph</code>对象导出为JSON，以及如何在D3中编写一个强制导向网络的完整说明，包括如下特性:</a></p><ul class=""><li id="2e0e" class="nl nm iv km b kn ko kq kr kt nn kx no lb np lf nq nr ns nt bi translated">通过度中心性缩放节点，以显示网络中的重要参与者</li><li id="c4e9" class="nl nm iv km b kn nu kq nv kt nw kx nx lb ny lf nq nr ns nt bi translated">按政党划分的彩色编码节点</li><li id="7bab" class="nl nm iv km b kn nu kq nv kt nw kx nx lb ny lf nq nr ns nt bi translated">向节点添加Twitter个人资料图片，以便更容易识别演员</li><li id="39c6" class="nl nm iv km b kn nu kq nv kt nw kx nx lb ny lf nq nr ns nt bi translated">添加节点搜索功能</li><li id="a08c" class="nl nm iv km b kn nu kq nv kt nw kx nx lb ny lf nq nr ns nt bi translated">添加ego网络</li><li id="1990" class="nl nm iv km b kn nu kq nv kt nw kx nx lb ny lf nq nr ns nt bi translated">添加酷的滑动标度来改变网络中要连接的两个MP的交互阈值。</li></ul></div><div class="ab cl nz oa hz ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="io ip iq ir is"><p id="97ee" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated">这篇文章快速介绍了对Twitter网络进行有趣、深刻和有趣的分析和可视化的一些可能性。要获得更深入的技术指导，请查阅我的书，其中包含了以上各章节中所有方法的完整教程。如果你决定用它来建立你自己的Twitter网络，请与社区分享你的成果。</p><p id="ae87" class="pw-post-body-paragraph kk kl iv km b kn ko jw kp kq kr jz ks kt ku kv kw kx ky kz la lb lc ld le lf io bi translated"><em class="mz">图表和网络手册为使用R和Python处理图表和执行网络分析提供了理论和技术指导。现在可以在</em><a class="ae ma" href="https://ona-book.org" rel="noopener ugc nofollow" target="_blank"><em class="mz">https://ona-book.org</em></a><em class="mz">免费获得，或者从</em><a class="ae ma" href="https://www.routledge.com/Handbook-of-Graphs-and-Networks-in-People-Analytics-With-Examples-in-R/McNulty/p/book/9781032204970" rel="noopener ugc nofollow" target="_blank"><em class="mz">CRC Press</em></a><em class="mz">获得印刷版/Kindle版。我所有的印刷版/Kindle销售收入都会捐给乌克兰红十字会。</em></p></div></div>    
</body>
</html>