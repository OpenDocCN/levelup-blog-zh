<html>
<head>
<title>Managing image uploads in your Browser: Base64 vs ObjectURLs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在浏览器中管理图像上传:Base64与ObjectURLs</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/managing-image-uploads-in-your-browser-base64-vs-objecturls-part-1-cec5ee9af7be?source=collection_archive---------1-----------------------#2020-02-06">https://levelup.gitconnected.com/managing-image-uploads-in-your-browser-base64-vs-objecturls-part-1-cec5ee9af7be?source=collection_archive---------1-----------------------#2020-02-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="9c72" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">图像统治着互联网，每天有超过20亿张照片被传到网上。因为图像是网络体验中不可或缺的一部分，所以浏览器和HTML有一些“内置”工具来有效地处理图像。我将介绍在浏览器中导入、管理和显示图像的最佳方式。</p><p id="9847" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是我的项目中的一个例子，<a class="ae kp" href="https://app.watermarks.io/#/design" rel="noopener ugc nofollow" target="_blank"> watermarks.io </a>。试试看。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div class="gh gi kq"><img src="../Images/d94b03da5e7276435616d978d3ec6a60.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*-8Yc10q-Zfe-cvUYpx3u4g.gif"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">从我的网站样本，<a class="ae kp" href="https://app.watermarks.io" rel="noopener ugc nofollow" target="_blank">水印。io </a>。在300毫秒内保存20mb的照片</figcaption></figure><p id="4804" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们把手弄脏，学习如何像上面的例子一样快速导入。</p><p id="d4ea" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">第1部分:</em>将介绍导入和存储图像数据的方法。</p><p id="9c89" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">第2部分:</em>将介绍异步多图像导入(即将推出)</p><p id="9e58" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"><em class="ko">TL；</em> </strong> <em class="ko">博士一路垫底:)</em></p></div><div class="ab cl lc ld hx le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="im in io ip iq"><h1 id="f2d4" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">基础知识—导入图像</h1><p id="b389" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated">我将尽可能简单地解释这一点，因为为了理解和构建更健壮的导入解决方案，基础知识是必要的。</p><p id="166f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您的浏览器可以通过<code class="fe mm mn mo mp b">File</code>界面访问计算机的本地文件系统。每个<code class="fe mm mn mo mp b">File</code>都存储在一个<code class="fe mm mn mo mp b">FileList</code>对象中，该对象由与<code class="fe mm mn mo mp b">&lt;input type="file&gt;</code>元素交互的用户填充。<code class="fe mm mn mo mp b">FileList</code>中的<code class="fe mm mn mo mp b">File</code>对象只是对本地文件系统中文件的引用。</p><p id="40cf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请记住，<code class="fe mm mn mo mp b">File</code>对象只是对您计算机上实际文件的引用，因此要在浏览器中使用该文件的实际数据，我们需要使用<code class="fe mm mn mo mp b">FileReader()</code>来“导入”它。</p><p id="1122" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面我们来看一个例子。</p><p id="bf48" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所有浏览器导入(任何文件类型)都必须通过一个<code class="fe mm mn mo mp b">&lt;input&gt;</code>元素导入，在我们的例子中是一个<code class="fe mm mn mo mp b">type="file"</code>属性。您可以添加<code class="fe mm mn mo mp b">accept="image/*"</code>属性，通知您的Mac Finder或Windows资源管理器仅显示图像作为导入选项。当用户选择要添加的文件时，<code class="fe mm mn mo mp b">&lt;input&gt;</code>的<code class="fe mm mn mo mp b">onchange</code>方法被触发，我们的函数<code class="fe mm mn mo mp b">importFileandPreview()</code>运行。</p><pre class="kr ks kt ku gt mq mp mr ms aw mt bi"><span id="d260" class="mu lk it mp b gy mv mw l mx my">&lt;input type="file" onchange="importFileandPreview()"&gt;&lt;br&gt;<br/>&lt;img src="" height="200" alt="Image preview..."&gt;</span></pre><p id="fd99" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面，我们向由<code class="fe mm mn mo mp b">reader</code>表示的<code class="fe mm mn mo mp b">FileReader()</code>添加一个事件监听器。</p><p id="d9ab" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以使用DOM选择器<code class="fe mm mn mo mp b">document.querySelector('input[type=file]').files[0];</code>抓取用户上传的文件(w/ JS)</p><p id="2db9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一旦你有了对那个文件的引用，<code class="fe mm mn mo mp b">myFile</code>你将使用<code class="fe mm mn mo mp b"><strong class="js iu">readAsDataUrl()</strong></code>方法把它传递给<code class="fe mm mn mo mp b">FileReader</code>。<strong class="js iu">该方法将读取用户上传的文件内容，并将获取的数据存储为Base64 DataUrl。</strong>我们将在本文的下一节重点讨论什么是数据Url。</p><p id="be1f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一旦<code class="fe mm mn mo mp b">readAsDataURL</code>方法读取完我们本地文件的内容，它就会被“转换”成一个DataUrl，存储在内存中供我们的JS使用。在大多数情况下，一旦<code class="fe mm mn mo mp b">File</code>被读取为<code class="fe mm mn mo mp b">DataUrl</code>，图像元素的<code class="fe mm mn mo mp b">src</code>被设置为<code class="fe mm mn mo mp b">DataUrl</code>以显示或预览文件。</p><pre class="kr ks kt ku gt mq mp mr ms aw mt bi"><span id="d0d7" class="mu lk it mp b gy mv mw l mx my">var reader  = new FileReader();<br/>var myFile  = document.querySelector('input[type=file]').files[0];</span><span id="ecfe" class="mu lk it mp b gy mz mw l mx my">reader.addEventListener("load", function () {<br/>    // do something with reader.result<br/>    console.log(file.name)<br/>  }, false);<br/>  <br/>  reader.readAsDataURL(myFile);<br/>}</span></pre><p id="1548" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="ko">注意</em> </strong> <em class="ko">:我的例子不是为了复制粘贴，如果你想要可运行的代码，使用完整的CodePen例子</em></p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">尝试导入图像</figcaption></figure><h1 id="8d6a" class="lj lk it bd ll lm nc lo lp lq nd ls lt lu ne lw lx ly nf ma mb mc ng me mf mg bi translated">Base64 (DataURL)与ObjectURL</h1><p id="21d2" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated">在上面的导入中，我们导入了一个二进制<code class="fe mm mn mo mp b">File</code>对象，并将其表示为浏览器可以轻松解释的Base64编码字符串(DataURL)。需要注意的一点是，Base64编码的图像比原始文件大33%。</p><blockquote class="nh"><p id="5d61" class="ni nj it bd nk nl nm nn no np nq kn dk translated">请注意，Base64编码的图像比原始文件大33%。</p></blockquote><p id="b532" class="pw-post-body-paragraph jq jr it js b jt nr jv jw jx ns jz ka kb nt kd ke kf nu kh ki kj nv kl km kn im bi translated">如果你正在处理大量高质量的图片，你的浏览器(和JS)将很快因DataURL的增加而不堪重负。假设您有一个20mb的图像导入到浏览器中。如果它被编码为DataURL，那么它就是一个26.6mb *的字符串，现在通过您的Web应用程序进行管理。你对它做的任何操作，都意味着你在移动一个巨大的字符串，这对性能和内存管理都是不利的。</p><p id="8522" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在浏览器中处理多个大图像的更好方法是使用ObjectURL的。</p><p id="86a4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">ObjectURL创建一个URL(即引用)到一个对象(类型为<code class="fe mm mn mo mp b">File</code>或<code class="fe mm mn mo mp b">Blob</code>)。在图像的情况下，ObjectURL创建一个对<em class="ko">原始</em> <code class="fe mm mn mo mp b">File</code>对象的URL引用。最棒的是，<code class="fe mm mn mo mp b">&lt;img&gt;</code>元素可以直接使用ObjectURL来显示图像。</p><blockquote class="nh"><p id="ed23" class="ni nj it bd nk nl nm nn no np nq kn dk translated"><code class="fe mm mn mo mp b">File</code>物体不能直接用于显示图像。然而，ObjectURL可以直接表示一个<code class="fe mm mn mo mp b">File</code>对象，并且可以用作一个<code class="fe mm mn mo mp b">&lt;img&gt;</code>元素的src。</p></blockquote><ul class=""><li id="2094" class="nw nx it js b jt nr jx ns kb ny kf nz kj oa kn ob oc od oe bi translated"><em class="ko">回想一下，当用户导入一个图像时，它最初是一个</em> <code class="fe mm mn mo mp b"><em class="ko">File</em></code> <em class="ko">对象。浏览器不能直接显示</em> <code class="fe mm mn mo mp b"><em class="ko">File</em></code> <em class="ko">对象，这就是为什么需要将其编码为DataURL或表示为ObjectURL。</em></li></ul><p id="b981" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">导入图像并将其表示为ObjectURL的设置与本文开头的示例非常相似:</p><p id="ad9e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里的神奇之处在于<code class="fe mm mn mo mp b"><strong class="js iu">window.URL.createObjectURL(file);</strong></code>它创建了一个ObjectUrl，您可以在应用程序的任何地方将它用作<code class="fe mm mn mo mp b">src</code>元素。最重要的是，可以很容易地将这个小字符串从一个小部件传递到另一个小部件，传递到一个HTML画布，或者用于服务器上传。</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="e267" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">比较从这支笔到第一支DataUrl笔的<code class="fe mm mn mo mp b">src</code>属性长度！ObjectURLs要轻得多，建议用于大文件和多次导入。</p><h1 id="27b8" class="lj lk it bd ll lm nc lo lp lq nd ls lt lu ne lw lx ly nf ma mb mc ng me mf mg bi translated">TL；博士；医生</h1><p id="dec0" class="pw-post-body-paragraph jq jr it js b jt mh jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj ml kl km kn im bi translated">浏览器喜欢图像，有几种方法可以显示本地文件系统图像。文件/图像不能直接来自浏览器，因此需要“导入”或编码才能在浏览器中查看。有两种方法可以做到这一点:</p><ol class=""><li id="6ce7" class="nw nx it js b jt ju jx jy kb of kf og kj oh kn oi oc od oe bi translated">您可以显示一个<strong class="js iu">数据URL </strong>。DataUrl是原始图像的Base64编码字符串，非常大。所有数据都包含在Base64字符串中，这导致它们的总大小膨胀了约33%。这些巨大的字符串存储在JS内存中，对性能不利，尤其是在应用程序中或向服务器移动图像数据时。</li><li id="f362" class="nw nx it js b jt oj jx ok kb ol kf om kj on kn oi oc od oe bi translated">您可以使用<strong class="js iu"> ObjectURL </strong>的。从非常简单的意义上来说，ObjectURL是浏览器创建的对本地文件系统中文件的“本地”URL引用。这些URL访问的是文件的二进制数据，所以图像数据本身并没有膨胀。ObjectURL可以很容易地在您的WebApp中传递，传递到HTML画布，或者用于服务器上传。ObjectURL是正确的选择！只要确保撤销网址，如果你用/显示一个图像。</li></ol><p id="b40f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<a class="ae kp" href="https://app.watermarks.io/" rel="noopener ugc nofollow" target="_blank"> app.watermarks.io </a>中随意尝试图片上传，并在上传后检查<code class="fe mm mn mo mp b">src</code>属性。它们是干净整洁的ObjectURL，速度非常快。</p><p id="5fc4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">接下来，我将在第二部分介绍异步多映像导入</em></p><p id="b0e7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">干杯！</p></div></div>    
</body>
</html>