<html>
<head>
<title>Dockerizing a Flask application with a Postgres Database</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Postgres数据库对接Flask应用程序</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/dockerizing-a-flask-application-with-a-postgres-database-b5e5bfc24848?source=collection_archive---------0-----------------------#2020-02-15">https://levelup.gitconnected.com/dockerizing-a-flask-application-with-a-postgres-database-b5e5bfc24848?source=collection_archive---------0-----------------------#2020-02-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="2dc3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本教程中，我们将构建一个包含Postgres数据库的Flask服务器，并对应用程序进行dockerize。本文分为三个部分:</p><ol class=""><li id="ae29" class="ko kp it js b jt ju jx jy kb kq kf kr kj ks kn kt ku kv kw bi translated">创建Hello World！应用</li><li id="a762" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated">服务容器化</li><li id="a3a4" class="ko kp it js b jt kx jx ky kb kz kf la kj lb kn kt ku kv kw bi translated">数据库和迁移</li></ol><p id="2114" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">希望你喜欢阅读！</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi lc"><img src="../Images/995020b702ded702fffa79c9346ac3b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4hw-cMzE6PZQYl3hHChkeQ.png"/></div></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk translated">烧瓶(贴有标签以便重复使用的图片)</figcaption></figure><h1 id="66cd" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">你好世界！</h1><p id="4d9c" class="pw-post-body-paragraph jq jr it js b jt mq jv jw jx mr jz ka kb ms kd ke kf mt kh ki kj mu kl km kn im bi mv translated">每当我在做一个新项目时，我做的第一件事就是尝试创建尽可能少的应用程序。通过创建最小的应用程序，您——在某种程度上——已经准备好了项目结构。对于flask hello world应用程序，您可以遵循这里的说明:【https://flask.palletsprojects.com/en/1.1.x/quickstart/】T2。这正是我开始从事这个项目时所做的。</p><p id="c7f6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于想要跟随的人来说，步骤是这样的:</p><p id="4633" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">1.创建一个python新项目(这将为您创建所有必要的目录，包括虚拟环境)</p><p id="7e41" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">2.安装flask并将其添加到requirements.txt:</p><pre class="ld le lf lg gt nf ng nh ni aw nj bi"><span id="71a7" class="nk lt it ng b gy nl nm l nn no">pip install Flask<br/>pip freeze &gt; requirements.txt</span></pre><p id="4d96" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">3.创建app.py文件并添加以下代码:</p><pre class="ld le lf lg gt nf ng nh ni aw nj bi"><span id="63a9" class="nk lt it ng b gy nl nm l nn no">from flask import Flask<br/>app = Flask(__name__)</span><span id="2d78" class="nk lt it ng b gy np nm l nn no">@app.route('/', methods=['GET'])<br/>def hello_world():<br/>    return {<br/>        'hello': 'world'<br/>    }</span></pre><p id="b609" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">4.要运行该应用程序，您可以运行以下命令:</p><pre class="ld le lf lg gt nf ng nh ni aw nj bi"><span id="861e" class="nk lt it ng b gy nl nm l nn no">export FLASK_APP=src/app.py<br/>flask run</span></pre><p id="d250" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">5.然后你会在<a class="ae ne" href="http://127.0.0.1:5000/" rel="noopener ugc nofollow" target="_blank"> http://127.0.0.1:5000/ </a>中看到这个字符串</p><p id="e928" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我希望你能坚持到现在！如果是这样，恭喜你！</p><h1 id="74bc" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">将服务和数据库容器化</h1><p id="f4d5" class="pw-post-body-paragraph jq jr it js b jt mq jv jw jx mr jz ka kb ms kd ke kf mt kh ki kj mu kl km kn im bi mv translated">我发现这一步非常重要，因为应用程序容器使开发变得更快更容易。您不必处理大量的配置，相反，您只需几行配置代码就可以启动并运行您的应用程序和所有相关服务。</p><p id="1247" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，我想简单回顾一下<strong class="js iu"> docker-compose </strong>。正如docker文档中所说，“compose是一个定义和运行多容器Docker应用程序的工具”(<a class="ae ne" href="https://docs.docker.com/compose/" rel="noopener ugc nofollow" target="_blank">https://docs.docker.com/compose/</a>)。如果您有多个运行的服务来组成一个更大系统的不同部分，您可以使用docker-compose，用一个简单的配置文件来创建和启动所有这些服务。</p><p id="6250" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们的docker-compose将有两个服务:服务器和数据库。代码如下:</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="nq nr l"/></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk translated">docker-compose.yml</figcaption></figure><p id="3d93" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第一个服务是主服务本身，它现在是“hello world”服务器，第二个服务是Postgres数据库的配置。当您运行“docker-compose up”时，您会看到这两个服务都将被创建，并且它们可以使用docker-compose文件中的名称找到彼此并与之通信。正如您在这个示例中看到的，您可以通过使用“db”名称从服务访问数据库。</p><p id="aabd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">docker-compose之后，另一个重要的文件是<strong class="js iu"> Dockerfile </strong>。当“docker build”运行时，它会将该文件作为创建必要服务的手册。在我们的例子中，当我们运行docker-compose up时，服务部分中的build命令(参见上面docker-compose.yml的第5行)告诉compose运行Dockerfile。关于Dockerfile的更多信息，可以参考官方文档:【https://docs.docker.com/engine/reference/builder/<a class="ae ne" href="https://docs.docker.com/engine/reference/builder/" rel="noopener ugc nofollow" target="_blank"/></p><p id="7863" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们的docker文件看起来像这样:</p><pre class="ld le lf lg gt nf ng nh ni aw nj bi"><span id="83c3" class="nk lt it ng b gy nl nm l nn no"># pull official base image<br/>FROM python:3.8.0-alpine</span><span id="a828" class="nk lt it ng b gy np nm l nn no"># set work directory<br/>WORKDIR /usr/src/app</span><span id="165a" class="nk lt it ng b gy np nm l nn no"># set environment variables<br/>ENV <em class="ns">PYTHONDONTWRITEBYTECODE </em>1<br/>ENV <em class="ns">PYTHONUNBUFFERED </em>1</span><span id="793c" class="nk lt it ng b gy np nm l nn no">RUN apk update &amp;&amp; apk add postgresql-dev gcc python3-dev musl-dev</span><span id="e5c5" class="nk lt it ng b gy np nm l nn no"># install dependencies<br/>RUN pip install --upgrade pip<br/>COPY ./requirements.txt /usr/src/app/requirements.txt<br/>RUN export LDFLAGS="-L/usr/local/opt/openssl/lib"<br/>RUN pip install -r requirements.txt</span><span id="5507" class="nk lt it ng b gy np nm l nn no"># copy project<br/>COPY . /usr/src/app/</span><span id="ec73" class="nk lt it ng b gy np nm l nn no">EXPOSE 5000</span><span id="6be8" class="nk lt it ng b gy np nm l nn no">RUN ls -la app/</span><span id="82aa" class="nk lt it ng b gy np nm l nn no">ENTRYPOINT ["app/docker-entrypoint.sh"]</span></pre><p id="94c7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我不会深入这个文件的细节，但最重要的是最后一个命令，它定义了Docker映像的入口点。</p><p id="3126" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我认为现在是时候谈谈<strong class="js iu">入口点</strong>了。“入口点”使您能够将容器作为可执行文件运行。你可以在这里阅读更多关于Entrypoint的内容:<a class="ae ne" href="https://docs.docker.com/engine/reference/builder/#entrypoint" rel="noopener ugc nofollow" target="_blank">https://docs . docker . com/engine/reference/builder/# entry point</a></p><p id="59d0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">到目前为止，我们的架构是这样的:</p><blockquote class="nt nu nv"><p id="b2f9" class="jq jr ns js b jt ju jv jw jx jy jz ka nw kc kd ke nx kg kh ki ny kk kl km kn im bi translated">docker-compose-&gt; API-&gt; docker file-&gt; docker-entry point . sh</p><p id="34dc" class="jq jr ns js b jt ju jv jw jx jy jz ka nw kc kd ke nx kg kh ki ny kk kl km kn im bi translated">docker-撰写-&gt;数据库</p></blockquote><p id="a32f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">docker-entrypoint.sh非常简单，看起来像这样:</p><pre class="ld le lf lg gt nf ng nh ni aw nj bi"><span id="d85e" class="nk lt it ng b gy nl nm l nn no"><strong class="ng iu">#!/bin/sh</strong></span><span id="ff83" class="nk lt it ng b gy np nm l nn no">set -e</span><span id="523a" class="nk lt it ng b gy np nm l nn no">flask db upgrade</span><span id="ee2c" class="nk lt it ng b gy np nm l nn no">gunicorn -c gunicorn.config.py wsgi:app</span></pre><p id="b315" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个<strong class="js iu"> sh </strong>文件执行的两个非常重要且实际上唯一的操作是运行命令来升级数据库，方法是检查是否有新的迁移，然后使用<strong class="js iu"> gunicorn </strong>运行flask应用程序。</p><p id="ae3a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在下一节中，我们将讨论数据库设置，然后您将更好地理解“flask db upgrade”命令。</p><p id="478f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果想了解gunicorn，可以在这里阅读:<a class="ae ne" href="https://flask.palletsprojects.com/en/1.1.x/deploying/wsgi-standalone/" rel="noopener ugc nofollow" target="_blank">https://flask . pallets projects . com/en/1.1 . x/deploying/wsgi-standalone/</a></p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/607e37caf9be2d402af452350cbe4d79.png" data-original-src="https://miro.medium.com/v2/resize:fit:438/format:webp/1*simRMwtCcZmMnXlZtaqSOw.png"/></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk translated">你友好的邻居数据库:Postgres</figcaption></figure><h1 id="469a" class="ls lt it bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">数据库和迁移</h1><p id="dbda" class="pw-post-body-paragraph jq jr it js b jt mq jv jw jx mr jz ka kb ms kd ke kf mt kh ki kj mu kl km kn im bi mv translated">服务器中最重要的东西之一是保存数据的地方，也就是数据库。为此，我们将使用Postgres，但在此之前，我们必须实现一种方法来处理数据库相关工作的所有配置。跟踪迁移是该配置中最重要的部分之一。为此，我们将使用Flask-Migrate:</p><pre class="ld le lf lg gt nf ng nh ni aw nj bi"><span id="146e" class="nk lt it ng b gy nl nm l nn no">pip install Flask-Migrate<br/>pip freeze &gt; requirements.txt</span></pre><p id="fcc1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">完成上述步骤后，要进行初始化，我们只需运行以下命令:</p><pre class="ld le lf lg gt nf ng nh ni aw nj bi"><span id="e1e5" class="nk lt it ng b gy nl nm l nn no">flask db init</span></pre><p id="59c1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此命令将在应用程序的根目录下创建一个迁移文件夹。我们可以把这个文件夹看作是跟踪数据库版本的一种方式。</p><p id="ce74" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要添加新的迁移，我们只需运行以下命令:</p><pre class="ld le lf lg gt nf ng nh ni aw nj bi"><span id="5688" class="nk lt it ng b gy nl nm l nn no">flask db revision -m "create accounts table"</span></pre><p id="89c2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您将会看到，在“迁移/版本”下，有一个针对此迁移的新文件。如你所见，这里有两个功能:升级和降级。顾名思义，其中一个是升级数据库并在该文件中添加已定义的数据库对象，另一个是删除这些对象并返回到数据库的先前状态。以下是迁移文件:</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="nq nr l"/></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk translated">首次迁移</figcaption></figure><p id="2edc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ns">注意:如果您想将其复制并粘贴到您的项目中，只需勾选升级和降级两个功能。</em></p><p id="be16" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是一个简单的表添加，有5列，正如您在定义中看到的。</p><p id="dbe0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">关于数据库代码的更多细节，你可以查看GitHub上的代码:【https://github.com/ytimocin/flask-postgres-server<a class="ae ne" href="https://github.com/ytimocin/flask-postgres-server" rel="noopener ugc nofollow" target="_blank"/></p><p id="7ef8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后一部分是添加将在数据库中创建帐户对象的端点:</p><pre class="ld le lf lg gt nf ng nh ni aw nj bi"><span id="9347" class="nk lt it ng b gy nl nm l nn no">@app.route('/accounts/', methods=['POST'])<br/>def create_user():<br/>    <em class="ns">"""Create an account."""<br/>    </em>data = request.get_json()<br/>    name = data['name']<br/>    if name:<br/>        new_account = Account(name=name,<br/>                              created_at=dt.now())<br/>        db.session.add(new_account)  # Adds new User record to database<br/>        db.session.commit()  # Commits all changes<br/>        return make_response(f"{new_account} successfully created!")<br/>    else:<br/>        return make_response(f"Name can't be null!")</span></pre><p id="ab20" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这将获取请求，读取参数，然后在DB中创建一个Account对象。下面是调用端点并检查数据库中新数据的(低质量)gif:</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/a5e16703ce57b0a43af17f7b85670b86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*aoT3VQd8ByZ6efzSJOMV_g.gif"/></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk translated">通过调用端点创建帐户对象</figcaption></figure><p id="e220" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ns">特别感谢TablePlus(一个了不起的DB编辑器)和Postman。</em></p><p id="dc70" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我将增加这个项目的其他功能，但现在，这是这篇文章的结尾。如上所述，这个项目的链接是<a class="ae ne" href="https://github.com/ytimocin/flask-postgres-server" rel="noopener ugc nofollow" target="_blank">https://github.com/ytimocin/flask-postgres-server</a>。我很感激你的任何反馈，所以请随时在这里发表你的反馈，或者发邮件给我，地址是ytimocin@gmail.com。</p><p id="66e5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">感谢您的阅读！</p></div></div>    
</body>
</html>