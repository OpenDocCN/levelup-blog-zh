# 给你下一次面试编码挑战的提示

> 原文：<https://levelup.gitconnected.com/tips-for-your-next-coding-challenge-7c1c90c121d0>

一份软件开发工作要经历许多关。第一扇门通过成功完成他们扔给你的编码挑战来解锁。在这篇文章中，我会给你一些解决这些挑战的方法，这些方法是我从自己的经历中获得的。希望其中一把钥匙能帮你打开自己的门。

# 序言——编码挑战和面试

编码方面的挑战会让面试变得非常两极分化；他们要么进展顺利，要么进展不顺利。作为面试官和求职者，我已经参加了大约 50 次面试，我可以告诉你，情况不一定是这样的。挑战的对错性质愚弄了我们，让我们认为我们的面试要么通过，要么失败。

挑战只是过程的一部分。还有其他品质，如沟通、个性、文化契合度、成长潜力等。和你的技术能力一样重要。我见过一些天才拒绝了一份工作，因为他们不是一个很好的文化适应者，或者他们很难共事，等等。所以不用担心，你完成编码挑战的能力不会让你生/死。

话虽如此，你需要超越一定的技术熟练程度门槛，编码挑战有助于面试官判断你是否准备好了申请的工作。您可能非常了解如何构建高质量的代码，但遗憾的是，我们必须通过编码挑战来交流我们的技术熟练程度。我将试着帮助你用“编码挑战”的语言更好地交流。

# 3 把钥匙

![](img/5f88abc4c0fab6d0278c693fca55d322.png)

弗洛里安·伯杰在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄的照片

在我们进入要点之前，让我们先了解一些基础知识和准备工作:

*   你需要了解如何分析一个算法的时间和空间复杂度。
*   回顾你的数据结构和算法。尤其是那些你认为不相关的(因为根据我的经验，那些是*总是*在面试中出现的……)
*   确保你精通至少一门编程语言。面试可能压力很大。你不希望本应帮助你战胜挑战的语言成为你失败的原因。
*   做网上练习题。有很多像 [LeetCode](https://leetcode.com/) 、 [HackerRank](https://www.hackerrank.com/) 这样的网站有丰富的练习材料。

有很多其他的方法来准备，但是我相信你已经知道了。你来这里是为了好东西…嗯，在这里！

# 横向思维

有些问题被“巧妙地”设计来测试你的[横向思维](https://en.wikipedia.org/wiki/Lateral_thinking)。你能从多少不同的角度来解决一个问题？通常，你对问题的第一个解释会导致最低效的解决方案。当你的面试官要求你“做得更好”的时候，是时候把那些横向思维齿轮转移到位了。

横向思维就是要突破任何“感知”的限制。我不能教你怎么做，否则，我们都是天才。我*能做的*就是教你如何营造一个培养横向思维的环境。

秘密是——你不应该做任何事情……那是你的意识。看完问题，消化完，你的潜意识就会开始向你吐槽想法。似乎不知从哪里冒出来的想法。你的工作是评估和探索这些想法的优点。最终，一点灵感会帮助你找到解决办法。

不必要的想法会分散你的注意力，阻碍你的思考能力。像这样的想法:

*   如果我得不到这个解决方案怎么办？我会面试失败吗？
*   我还剩多少时间？我如何在 7 分钟内解决这个问题？

这些想法就像一个通往恶性循环的大门，最终导致恐慌。把这些想法从你的头脑中驱散，把注意力集中在这个问题上。不要让这些无用的想法占据了宝贵的产生思想的不动产，应该分配给解决问题的不动产。

> 面试时保持冷静。压力和恐慌会阻碍你解决问题的能力。试着享受乐趣，保持放松，让你的大脑做它最擅长的事情。

当然，告诉你“不要惊慌”说起来容易做起来难，但这将随着实践而自然发生。现在我们来看一个问题。

## 低买高卖

给你一只股票的历史价格数据:

![](img/e2dff18db906aaaa016690adf27b5460.png)

你必须找到一个*开始时间*和*结束时间*，这样在*开始时间*买入一只股票，在*结束时间*卖出这只股票会产生最高的利润。显然，*结束时间*必须在*开始时间:*之后

![](img/59fd7422e201018783c7e3fd8d14a015.png)

你可以在这里停下来，试着想出一个解决方案。您的输入数据是一个价格数组，您的输出必须是买入/卖出的指数:

```
Input:
[5, 3, 2, 4, 6, 7, 6, 5, 5, 6, 7, 9, 10, 9, 7, 5, 6]Output:
(2, 12)
```

您可能会考虑的第一个解决方案是“暴力”解决方案。您创建一个外部/内部循环来考虑每一对*开始*和*结束时间。*你在循环过程中跟踪哪双鞋的价格差异最大，并在结束时返回那双鞋:

该算法的复杂度为 O(N)。我们能做得更好吗？当然可以！这就是横向思维发挥作用的地方。这个问题是以时间的概念为框架的，我们知道时间只能向前，不能向后。因此，我们的大脑会吐出“向前”的解决方案，也就是说从左到右。没有任何限制不允许我们反向遍历数据。

我们知道我们将总是在某个局部最小值买入，在某个局部最大值卖出(除非图形总是在下降)。问题的根源是将每个局部最小值与一个局部最大值配对，并选择利润最高的配对。“向前”方法的困难在于问题的时间性质。当我们从左到右时，我们必须记住我们过去见过的每个局部最小值/最大值的*，以防将来出现更好的配对。这种配对逻辑在一个循环中编程极其复杂。*

如果我们从右到左，我们不需要跟踪每个本地最小值/最大值的*。问题就变得简单多了。我们知道过去还没有遍历过的数据，所以我们只需要跟踪我们看到的最好的数据，如果我们发现更好的数据，就替换它:*

代码的简要说明:对于每个局部最大值，我们跟踪“最佳”局部最小值，直到找到更高的局部最大值。我们重复这个逻辑，直到遍历完数组，始终跟踪最佳配对。下面的图表说明了该算法:

![](img/aa3d6cc2f851ae19a3247790159cfc82.png)

该算法的复杂度为 O(N)。当然，这是我们能做的最好的了。对于这个问题，横向思考意味着**倒退**。您可以考虑探索“向后”方法的情况:

*   当您处理时态数据时，就像我们在这个问题中所做的那样。
*   当你使用字符串(英语)时，我们从左到右阅读。如果向后遍历字符串更容易呢？

**练习**:这里有一个练习的编码挑战:[退格字符串比较](https://leetcode.com/problems/backspace-string-compare/)

# 使用数据结构

要想在编程面试中脱颖而出，你需要对数据结构有很好的掌握。当你开始写代码时，看起来“足够简单”的问题变得令人毛骨悚然。在这些情况下，利用数据结构来帮助简化您需要编写的代码是至关重要的。您可能需要使用多种数据结构，或者创建自己的数据结构。

## LRU 高速缓存

在 LRU(最近最少使用的)缓存中，缓存中最陈旧的项目会被驱逐，以便为新项目腾出空间:

![](img/330c064a7f3379b4d7eeae5cb55998be.png)

让我们考虑如何开发一个带有 *get* 和 *put* 操作的 LRU 缓存。

如果我们使用链表形式的队列会怎么样？对于 *put* 操作，我们将一个项目插入到队列中，如果队列已满，则驱逐最陈旧(最后)的项目。对于 *get* 操作*，*我们遍历队列来查找物品。如果找到，我们从当前位置移除该项目，并将其重新插入列表，从而使其“新鲜”:

![](img/889a8349e70a0e55af112dc2bc9453c4.png)

*put* 操作将一个项目插入到队列中，如果需要，如果队列已满，则弹出一个项目。它的运行时间复杂度为 O(1)。在最坏的情况下， *get* 操作必须遍历整个队列来找到一个条目。该操作的运行时间复杂度为 O(N)。缓存通常针对读取进行优化(即 *get* 操作)，所以我们需要一个更好的实现，最好是 O(1)。(你知道一个简单的链表实现是不够的……)

下一个想到的数据结构是集合或散列表。具有 O(1)查找的东西。但是我们如何编纂陈旧呢？链表漂亮地表现了一个条目的陈旧程度(条目在列表中的位置)。集合没有任何顺序的概念。

如果我们也在散列表中存储一个条目的“陈旧性”会怎么样？那会有帮助吗？然后，关键字将是该项目的散列，值将是它的陈旧性。我们的缓存命中/未命中逻辑是 O(1)，我们只需要确认该项是否存在于我们的 hashmap 中。我们仍然需要弄清楚如何在缓存命中时更新该项的“陈旧性”。

一个可能的解决方案是保持递增的计数。我们可以使用该计数来更新缓存命中时间的过期时间。较低的计数意味着一个潜行者项目。在 *put* 操作期间，如果我们需要驱逐一个项目，我们会驱逐计数最低的项目:

![](img/ba2631c5b75802e84406b09be12d961e.png)

*get* 操作现在的运行时复杂度为 O(1)，而 *put* 操作的运行时复杂度为 O(N)(因为如果我们需要驱逐一个项目，我们必须遍历整个 hashmap 来找到最陈旧的项目)。使用一个聪明的技巧，我们已经成功地优化了 *get* 操作。让我们看看我们是否能做得更好…

我们的链表方法给出了一个 O(1) *put* 操作。我们的 hashmap 方法给了我们一个 O(1) *get* 操作。如果我们能以某种方式找到一种方法来合并这两种方法，我们就能实现恒定时间的 *get* 和 *put* 操作。

*我准备在下一段描述解决方法，看你能不能想明白了再继续。*

链表的“缺点”是我们必须在 *get* 操作中遍历每一项。假设我们有一个散列表，我们不需要遍历列表。散列表的“糟糕”之处在于，当找到要驱逐的条目时，我们必须遍历散列表中的所有条目。如果我们有一个链表，那么我们可以弹出最后一个条目，这样我们就知道在散列表中应该删除哪个条目了。看起来散列表和链表互相利用了对方的弱点。让我们开始推理通过*得到&放*的操作。

要添加一个新条目，我们将把它插入到散列表和链表中:

![](img/e05b657b059d6f2879f32205e17abbc0.png)

缓存满了怎么办？驱逐会是什么样子？对于驱逐，我们可以删除队列中的最后一项。因为我们手头有被驱逐的条目，所以我们也可以将它从散列表中移除:

![](img/3cd0c9d20bd116466820b6039f77f8f1.png)

太好了，效果很好。好了，现在让我们考虑一下*得到*的操作。检查条目是否存在很简单，我们只需检查散列表。如果没有，我们说这是缓存未命中。如果存在呢？我们需要更新该项目的过期时间。这就是事情变得棘手的地方。我们需要遍历链表来找到条目，并把它移到前面。困难在于必须遍历列表。我们能以某种方式避免遍历吗？

在某种意义上，链表是指向节点的指针的集合。我们需要遍历链表来得到我们想要的指针。我们需要另一种方法来访问这个指针。如果我们有一个常量时间查找数据结构来存储这些指针就好了…哦，等等，我们有！

让我们跟踪链表中每一项的指针，将它们作为值存储在 hashmap 中。现在我们可以使用 hashmap 来访问指针，并使用指针来重新定位链表中的条目:

![](img/6f3da7679087a71784fc871d3ccc3acb.png)

瞧啊。我们现在有了一个带有 O(1) *get* 操作和 O(1) *put* 操作的 LRU 缓存，这都是因为我们按照自己的意愿改变了数据结构。相当漂亮的东西。

**练习**:我将让您来编写这个解决方案。这并不是说我懒，我*会*把它编码并粘贴在这里……但是你可能会在面试中被问到这个问题，或者类似的问题，做这个练习是很好的练习。还有，我有点懒…

# 理解时间和空间

几乎你尝试的每个问题都会有不同程度的运行时和时空复杂度的解决方案。就我所见，运行时复杂性和时空复杂性在某种程度上是相关的。

当面试官问你是否可以比你最初的方法做得更好时，你可能需要牺牲时空复杂度来获得更好的运行时复杂度。幸运的是，面试官很少关心时空复杂性。他们可能会要求你分析，但很少会要求你改进。

运行时和时空复杂性之间权衡的例子数不胜数。以**寻找重复**为例:

给定一个数组，如果有重复的数字，返回 True，否则返回 False:

```
[0, 1, 2, 3] -> False
[3, 1, 2, 3] -> True
```

一个 O(1)时空的解决方案是使用一个外/内循环来比较每一个数字与每一个其他数字，如果两个数字相同，则返回 True。这个解决方案的运行时间复杂度为 O(N)。

![](img/861cfe8250c9ebaaa0c7a39e31f61e13.png)

让我们牺牲一些时空复杂度，创建一个排序数组。副本现在彼此相邻，我们只需遍历数组就可以找到它们。我们已经从 O(1)到 O(N)时空复杂度，并且我们已经将我们的运行时间复杂度降低到 O(N log N)。

![](img/b7b7739172f1fab3f54028631ebe8480.png)

让我们牺牲更多的时空复杂性，使用散列表。我们将遍历列表，使用数字作为 hashmap 的键，并记录我们看到这个数字作为值的次数。一旦我们创建了 hashmap，我们就遍历 hashmap，如果看到任何大于 1 的值，就返回 True:

![](img/f27e92075679c24a0bb574f6509e859f.png)

我们的运行时复杂度降低到 O(N ),时空复杂度略有增加(因为 hashmap 的内存效率低于数组),尽管仍然是 O(N)。

还有无数其他的编码挑战展示了同样的时间-空间权衡。以我们在上一节中开发的 LRU 缓存为例。运行时效率最高的解决方案也使用了最多的空间。理解时间-空间复杂性权衡为您提供了一种系统的方法来提高解决方案的运行时复杂性。如果你被要求找到一个更好的方法，问问你自己，我如何利用空间成为我的优势:

*   有什么我可以预先计算的有用值吗？
*   我能不能以一种优化的方式重新格式化我的输入，以配合我的算法？
*   我可以映射数据来表示我熟悉的问题吗？

在某些情况下，您将被要求改善时间/空间的复杂性，而您将无法变出任何能够拯救您的数据结构。这类问题旨在难倒你，通常问题中有一个细节或问题的一个属性是你没有利用的。所以一定要非常仔细的看问题。

# 结束语

希望我的“提示”能改变你看待编码问题的方式，并在面试中帮助你。我将再次重复它们:

*   **横向思维**——让你的大脑探索解决问题的不同方法。
*   **使用数据结构**——使用数据结构来获得更干净、更高效的代码。
*   **理解时间和空间** —牺牲空间换取更好的时间复杂度(反之亦然)。当要求改善时间/空间时，尝试利用问题的属性/细节。

当然，仅仅完成编码题并不足以通过面试。面试官还会考虑其他事情。在面试过程中，确保你:

*   谈谈你的想法。我在这个问题的这个方面遇到了麻烦，我在想是否有什么办法可以绕过它。)
*   积极点！轻松的谈话和微笑会有很大的帮助。
*   提问。你对公司的评价和他们对你的评价一样多。这是一家你每天都想为之工作的公司吗？

## 练习

本文涉及的问题相对简单，但足以说明问题。除了每个部分中列出的练习之外，还有一些其他的编码挑战可以帮助您练习:

*   [**两笔总和**](https://leetcode.com/problems/two-sum/)
*   [合并间隔 ](https://leetcode.com/problems/merge-intervals/)
*   **条目顺序数据结构**:编写一个数据结构，用于跟踪列表中条目的顺序。数据结构应该有 *insert_item* 、 *delete_item* 和 *reorder_item* 操作。所有的操作都应该有 O(1)的运行时间复杂度。

祝你下次编码挑战好运！:)