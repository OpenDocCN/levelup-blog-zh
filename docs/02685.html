<html>
<head>
<title>Creating Observables with Mobx</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Mobx创建可观察对象</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/creating-observables-with-mobx-e333f7798fa4?source=collection_archive---------13-----------------------#2020-03-29">https://levelup.gitconnected.com/creating-observables-with-mobx-e333f7798fa4?source=collection_archive---------13-----------------------#2020-03-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/b2ed4166100c0e33663d3ffec9f9901d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1o7w6_kkCBweufaW"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@freddymarschall?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Freddy Marschall </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="5d92" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Mobx是JavaScript应用程序的状态管理解决方案。它让我们观察来自商店的值，然后设置这些值，这些值将立即反映在商店中。</p><p id="61d3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将看看如何创建一个可观察对象，让我们订阅它，然后改变它的值。</p><h1 id="4c34" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">可观察函数</h1><p id="b02f" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">Mobx <code class="fe mh mi mj mk b">observable</code>函数接受一个对象。它也可以以decorator的形式提供，我们可以直接设置它的值。</p><p id="41f8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它可以按如下方式使用:</p><ul class=""><li id="e287" class="ml mm it ki b kj kk kn ko kr mn kv mo kz mp ld mq mr ms mt bi translated"><code class="fe mh mi mj mk b">observable(value)</code></li><li id="949e" class="ml mm it ki b kj mu kn mv kr mw kv mx kz my ld mq mr ms mt bi translated"><code class="fe mh mi mj mk b">@observable classProperty = value</code></li></ul><p id="9faf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它根据传入的值返回各种类型的值。<code class="fe mh mi mj mk b">value</code>可以是JavaScript原始值、引用、普通对象、类实例、数组和映射。</p><p id="119a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有一些转换规则适用于传递给<code class="fe mh mi mj mk b">observable</code>函数的值。它们是:</p><ul class=""><li id="2580" class="ml mm it ki b kj kk kn ko kr mn kv mo kz mp ld mq mr ms mt bi translated">如果<code class="fe mh mi mj mk b">value</code>是ES6 <code class="fe mh mi mj mk b">Map</code>，那么将返回一个新的可观测地图。如果我们想要对特定条目中的变化以及条目的添加或删除做出反应，可观察地图是非常有用的。</li><li id="a710" class="ml mm it ki b kj mu kn mv kr mw kv mx kz my ld mq mr ms mt bi translated">如果<code class="fe mh mi mj mk b">value</code>是ES6 <code class="fe mh mi mj mk b">Set</code>，那么将返回一个新的可观测集合。</li><li id="da24" class="ml mm it ki b kj mu kn mv kr mw kv mx kz my ld mq mr ms mt bi translated">如果<code class="fe mh mi mj mk b">value</code>是一个数组，那么将返回一个新的可观测数组。</li><li id="53fd" class="ml mm it ki b kj mu kn mv kr mw kv mx kz my ld mq mr ms mt bi translated">如果<code class="fe mh mi mj mk b">value</code>是一个没有原型的对象，那么它的所有当前属性都将是可观察的</li><li id="2d50" class="ml mm it ki b kj mu kn mv kr mw kv mx kz my ld mq mr ms mt bi translated">如果<code class="fe mh mi mj mk b">value</code>是一个带有原型、JavaScript原语或函数的对象，那么<code class="fe mh mi mj mk b">observable</code>将抛出。我们应该使用盒装可观察的可观测量。</li></ul><p id="cd9a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以如下使用<code class="fe mh mi mj mk b">observable</code>:</p><pre class="mz na nb nc gt nd mk ne nf aw ng bi"><span id="1d0a" class="nh lf it mk b gy ni nj l nk nl">import { observable } from "mobx";<br/>const map = observable.map({ foo: "value" });<br/>map.observe(({ oldValue, newValue }) =&gt; console.log(oldValue, newValue));</span><span id="98b2" class="nh lf it mk b gy nm nj l nk nl">map.set("foo", "new value");</span></pre><p id="1659" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们使用了<code class="fe mh mi mj mk b">observable.map</code>函数来创建一个可观察的地图。</p><p id="becb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们给它附加一个监听器，用<code class="fe mh mi mj mk b">observe</code>函数来观察这些值。侦听器给我们一个带有<code class="fe mh mi mj mk b">oldValue</code>和<code class="fe mh mi mj mk b">newValue</code>属性的对象，这样我们就可以检索它们。</p><p id="7161" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们打电话时:</p><pre class="mz na nb nc gt nd mk ne nf aw ng bi"><span id="3996" class="nh lf it mk b gy ni nj l nk nl">map.set("foo", "new value");</span></pre><p id="789e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们将看到侦听器记录的值。</p><p id="4543" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们也可以对数组做类似的事情:</p><pre class="mz na nb nc gt nd mk ne nf aw ng bi"><span id="941d" class="nh lf it mk b gy ni nj l nk nl">import { observable } from "mobx";<br/>const array = observable([1, 2, 3]);<br/>array.observe(({ oldValue, newValue }) =&gt; console.log(oldValue, newValue));</span><span id="8160" class="nh lf it mk b gy nm nj l nk nl">array[1] = 5;</span></pre><p id="0dcd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们向函数<code class="fe mh mi mj mk b">observable</code>传递了一个数组，该函数返回一个可观察的数组。然后我们可以像以前一样在它上面调用<code class="fe mh mi mj mk b">observe</code>来观察它的值。</p><p id="fb46" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，当我们对<code class="fe mh mi mj mk b">array</code>进行更改时，我们传递给<code class="fe mh mi mj mk b">observe</code>的监听器将记录新值和旧值。</p><p id="a3fa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了使原语可观察，我们可以使用如下的<code class="fe mh mi mj mk b">box</code>方法:</p><pre class="mz na nb nc gt nd mk ne nf aw ng bi"><span id="d3da" class="nh lf it mk b gy ni nj l nk nl">import { observable } from "mobx";<br/>const num = observable.box(3);<br/>num.observe(({ oldValue, newValue }) =&gt; console.log(oldValue, newValue));</span><span id="2cda" class="nh lf it mk b gy nm nj l nk nl">num.set(10);</span></pre><p id="1d4b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们用<code class="fe mh mi mj mk b">box</code>方法创建了一个可观察的原语。观察值变化的代码与前面相同。</p><p id="11a3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们可以使用<code class="fe mh mi mj mk b">set</code>为<code class="fe mh mi mj mk b">num</code>可观察原语设置一个新值。</p><figure class="mz na nb nc gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nn"><img src="../Images/027773f2c4a703109463139fa2e4f3e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*t6B96aRnXjY7alQG"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@iyolanda?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Yolanda Sun </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="1fef" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">@可观察的装饰者</h1><p id="306a" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">如果我们的代码库支持ES7或TypeScript，那么我们可以使用<code class="fe mh mi mj mk b">@observable</code> decorator来使类属性可见。</p><p id="a3c2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以如下使用它们:</p><pre class="mz na nb nc gt nd mk ne nf aw ng bi"><span id="f50e" class="nh lf it mk b gy ni nj l nk nl">import { observable, computed } from "mobx";</span><span id="bf65" class="nh lf it mk b gy nm nj l nk nl">class Person {<br/>  @observable firstName = "Jane";<br/>  @observable lastName = "Smith";</span><span id="4be3" class="nh lf it mk b gy nm nj l nk nl">  @computed get fullName() {<br/>    return `${this.firstName} ${this.lastName}`;<br/>  }<br/>}</span><span id="1d98" class="nh lf it mk b gy nm nj l nk nl">const person = new Person();<br/>console.log(person.firstName);<br/>console.log(person.lastName);<br/>console.log(person.fullName);</span></pre><p id="d1c4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们创建了<code class="fe mh mi mj mk b">Person</code>类，它具有可观察的属性，如使用<code class="fe mh mi mj mk b">observable</code>装饰器所指示的。我们还有一个属性<code class="fe mh mi mj mk b">computed</code>是getter。</p><p id="db0c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们创建一个新的<code class="fe mh mi mj mk b">Person</code>实例，我们可以记录这些值。</p><p id="8db9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们也可以像往常一样通过赋值来设置这些值。</p><p id="a8d9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要使用decorators，我们可以使用一个类似packages的构建系统，然后将<code class="fe mh mi mj mk b">@babel/core</code>、<code class="fe mh mi mj mk b">@babel/plugin-proposal-class-properties</code>、<code class="fe mh mi mj mk b">@babel/plugin-proposal-decorators</code>和<code class="fe mh mi mj mk b">@babel/preset-env</code>包添加到<code class="fe mh mi mj mk b">plugins</code>部分的<code class="fe mh mi mj mk b">.babelrc</code>中，如下所示:</p><pre class="mz na nb nc gt nd mk ne nf aw ng bi"><span id="9daf" class="nh lf it mk b gy ni nj l nk nl">{<br/>  "presets": [<br/>    "@babel/preset-env"<br/>  ],<br/>  "plugins": [<br/>    [<br/>      "@babel/plugin-proposal-decorators",<br/>      {<br/>        "legacy": true<br/>      }<br/>    ],<br/>    [<br/>      "@babel/plugin-proposal-class-properties",<br/>      {<br/>        "loose": true<br/>      }<br/>    ]<br/>  ]<br/>}</span></pre><h1 id="6b5e" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="5399" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以用<code class="fe mh mi mj mk b">observable</code>对象创建可观察的值。只要使用正确的方法来创造可观察的价值，它可以用于各种各样的对象。</p><p id="b55f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们可以使用<code class="fe mh mi mj mk b">observe</code>方法来观察返回的可观察值，并对其进行操作。</p><p id="b2e4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们也可以使用带有类的<code class="fe mh mi mj mk b">observable</code>装饰器来创建一个具有可观察属性的类。</p><p id="f143" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要使用decorators，我们要么使用Babel，要么使用TypeScript。</p></div></div>    
</body>
</html>