<html>
<head>
<title>14 Tips for Effortlessly Improving your Weak Ass React Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">14个小贴士，可以毫不费力地改善你脆弱的代码</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/14-tips-for-effortlessly-improving-your-weak-ass-react-code-4aea5500559c?source=collection_archive---------2-----------------------#2022-06-21">https://levelup.gitconnected.com/14-tips-for-effortlessly-improving-your-weak-ass-react-code-4aea5500559c?source=collection_archive---------2-----------------------#2022-06-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/da5ad550d987017435dfa77a77f0904b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IjBjRtnP2sUjSMnM"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">乔纳森·丹尼尔斯在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="3208" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">2014年开始学JS，大概一年后被介绍去React。起初它看起来令人困惑，但是多年的使用它得到了回报。无论您是在专业环境中使用它，用于家庭作业，作为面试编码练习的一部分，甚至是一个辅助项目，都有一些简单的快捷方式可以让您的生活变得更轻松。以下是我想到的14个节省时间的建议。</p><h1 id="dbb0" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">质量和编码风格</h1><h2 id="b9d8" class="mc lf it bd lg md me dn lk mf mg dp lo kr mh mi ls kv mj mk lw kz ml mm ma mn bi translated">1.用棉绒！</h2><p id="82e6" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">这是有原因的，它被包括在CRA的设置中，这是成年人应该做的事情。去<a class="ae kf" href="https://eslint.org/docs/user-guide/getting-started" rel="noopener ugc nofollow" target="_blank">这里</a>看看为什么我把这个作为我的第一条建议。我使用ESLint是因为它把我杂乱无章、语无伦次、满是bug的东西变得一致，有战斗价值。通常，当我建立一个全新的回购协议时，我会参考阿龙·瓦拉吉的这篇文章。</p><div class="mt mu gp gr mv mw"><a href="https://medium.com/dailyjs/adding-eslint-to-your-project-7bd4feca35a8" rel="noopener follow" target="_blank"><div class="mx ab fo"><div class="my ab mz cl cj na"><h2 class="bd iu gy z fp nb fr fs nc fu fw is bi translated">将ESlint添加到项目中</h2><div class="nd l"><h3 class="bd b gy z fp nb fr fs nc fu fw dk translated">在这篇文章中，我将通过几个简单的步骤，使用……</h3></div><div class="ne l"><p class="bd b dl z fp nb fr fs nc fu fw dk translated">medium.com</p></div></div><div class="nf l"><div class="ng l nh ni nj nf nk jz mw"/></div></div></a></div><h2 id="34ec" class="mc lf it bd lg md me dn lk mf mg dp lo kr mh mi ls kv mj mk lw kz ml mm ma mn bi translated">2.导入基本规则</h2><p id="6d7f" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">一旦你有你的棉绒设置，扔在那个坏男孩一些规则！<a class="ae kf" href="https://github.com/airbnb/javascript/tree/master/packages/eslint-config-airbnb" rel="noopener ugc nofollow" target="_blank"> Airbnb的。自我记事以来，eslintrc config </a>一直是备受瞩目的行业标准。<a class="ae kf" href="https://github.com/SonarSource/eslint-plugin-sonarjs" rel="noopener ugc nofollow" target="_blank"> Sonarjs </a>是离合器；jsx-a11y 也是另一个很棒的。我们稍后会详细讨论最后一个问题。</p><figure class="nm nn no np gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nl"><img src="../Images/ca52df569bb69b1b9969f39a9f64396b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kFo3MzcYgJLK72LKPOG54w.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">ESLint规则</figcaption></figure><h2 id="357a" class="mc lf it bd lg md me dn lk mf mg dp lo kr mh mi ls kv mj mk lw kz ml mm ma mn bi translated">3.使用更漂亮的</h2><p id="e66d" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">顾名思义，这会让你的代码看起来更漂亮。它带来的最大改进是，如果你真的懒于修改你的ESLint规则，它会为你重写代码。</p><figure class="nm nn no np gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nr"><img src="../Images/234a7e5fb5b0659dc6f4157a408629f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qyKbCZLI6uvUlY3azOFU6Q.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">较美丽</figcaption></figure><h2 id="9800" class="mc lf it bd lg md me dn lk mf mg dp lo kr mh mi ls kv mj mk lw kz ml mm ma mn bi translated">4.考虑使用Typescript</h2><p id="6b7a" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">Typescript与React配合得很好，它保护您免于自己的鲁莽。如果你正在传递一个本该是数字的变量，而你试图给一个字符串赋值，它会让你崩溃🤯。有时候类型强制对你有利，但是这种捷径可能会导致以后的错误。</p><figure class="nm nn no np gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ns"><img src="../Images/3348bbeb040c635a68172ccc1a3f7991.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xfjyvc694rHAkflpszE_sg.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">以打字打的文件</figcaption></figure><figure class="nm nn no np gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nt"><img src="../Images/45bc5792875490006f4c39f16b7742ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1s_LRceVKg249LFHV4agng.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">又打字了</figcaption></figure><h2 id="37f6" class="mc lf it bd lg md me dn lk mf mg dp lo kr mh mi ls kv mj mk lw kz ml mm ma mn bi translated">5.清理你的目录结构</h2><p id="3f2c" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">这个技巧需要更多的训练。你会发现定义辅助函数、样式组件、类型等工作变得更简单。当你着急的时候，就在你的组件代码旁边。我认为应该有单独的<code class="fe nu nv nw nx b">components</code>、<code class="fe nu nv nw nx b">types</code>、<code class="fe nu nv nw nx b">styles</code>和<code class="fe nu nv nw nx b">utilities</code>目录:</p><figure class="nm nn no np gt ju gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/1799b1f6ed4b94f316051441378b002e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/format:webp/1*nH7ctCU4BkRPnTQmECWkng.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">目录结构</figcaption></figure><h1 id="6720" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">表演</h1><h2 id="b3dd" class="mc lf it bd lg md me dn lk mf mg dp lo kr mh mi ls kv mj mk lw kz ml mm ma mn bi translated">6.避免不必要的重新渲染</h2><p id="4fab" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">疏忽的教育在反应中泛滥，所以给孩子一些爱...组件。React有一个名为<code class="fe nu nv nw nx b">memo</code>的内在高阶组件。当类组件还很酷的时候，你可以用几乎完全相同的方式调用<code class="fe nu nv nw nx b"><a class="ae kf" href="https://reactjs.org/docs/react-component.html#shouldcomponentupdate" rel="noopener ugc nofollow" target="_blank">shouldComponentUpdate</a></code>。(<em class="nq">补充说明:功能组件现在在大多数地方比类组件更受欢迎，因为它们是无状态的，并且不使用生命周期方法，最终留给您的是一个纯粹的功能</em>)。</p><figure class="nm nn no np gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nz"><img src="../Images/26fc628373fd10ae8acf1f7dab752694.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hmfudsDam21QgvT65BiJxA.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">反应备忘录</figcaption></figure><p id="24c5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，有两个有用的React钩子叫做<code class="fe nu nv nw nx b">useMemo</code>和<code class="fe nu nv nw nx b">useCallback</code>，帮助我们避免不必要的重新渲染。<code class="fe nu nv nw nx b">useMemo</code>缓存昂贵计算的结果，而<code class="fe nu nv nw nx b">useCallback</code>缓存函数本身，每次返回相同的值。当你有一个点击处理程序，无论你点击什么，它都会做同样的事情时，这是很有用的。</p><h2 id="8199" class="mc lf it bd lg md me dn lk mf mg dp lo kr mh mi ls kv mj mk lw kz ml mm ma mn bi translated">7.尽可能使用虚拟DOM</h2><p id="6478" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">如果您来自普通的JS背景，React有一种更简单的方法来操作DOM。如果你想在面试中表现得酷一点，这就叫做虚拟世界或虚拟世界。这是你在屏幕上看到的轻量级副本。它也只更新那些需要改变的元素。此外，React使用批处理机制来操作实际的DOM，而不是在每次状态改变时都发送更新。</p><p id="5260" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下面的代码为例:</p><pre class="nm nn no np gt oa nx ob oc aw od bi"><span id="860c" class="mc lf it nx b gy oe of l og oh">const videos = ["https://example.com/video1.mp4", "https://example.com/video2.mp4", ..., "https://example.com/video100.mp4"];</span><span id="4181" class="mc lf it nx b gy oi of l og oh">const App = () =&gt; {</span><span id="2481" class="mc lf it nx b gy oi of l og oh">  const [selectedVideo, setSelectedVideo] = useState('');</span><span id="9532" class="mc lf it nx b gy oi of l og oh">  const handleClickPlay = () =&gt; {<br/>    const videoElement = document.getElementById(selectedVideo);<br/>    const currentlyPlayings = document.getElementsByClassName('playing');<br/>    Array.from(currentlyPlayings).forEach((cp) =&gt; {<br/>      cp.classList.remove('selected');<br/>      cp.classList.remove('playing');<br/>      cp.classList.add('paused');<br/>      cp.pause();<br/>    });<br/>    videoElement.classList.remove('paused');<br/>    videoElement.classList.add('selected');<br/>    videoElement.classList.add('playing');<br/>    videoElement.play();<br/>  };<br/>  <br/>  const handleClickPause = () =&gt; {<br/>    const videoElement = document.getElementById(selectedVideo);<br/>    videoElement.classList.add('selected');<br/>    videoElement.classList.remove('playing');<br/>    videoElement.classList.add('paused');<br/>    videoElement.pause();<br/>  };</span><span id="939f" class="mc lf it nx b gy oi of l og oh">  return (<br/>    &lt;div&gt;<br/>      {videos.map((video, index) =&gt; (<br/>        &lt;video<br/>          id={`${index}`}<br/>          key={`${index}`}<br/>          onClick={() =&gt; setSelectedVideo(`${index}`)}<br/>          src={video}<br/>        /&gt;<br/>      ))}<br/>    &lt;button onClick={handleClickPlay}&gt;<br/>      Play<br/>    &lt;/button&gt;<br/>    &lt;button onClick={handleClickPause}&gt;<br/>      Pause<br/>    &lt;/button&gt;<br/>    &lt;/div&gt;<br/>  );<br/>};</span></pre><p id="f5c2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">理解这里发生的事情很痛苦，但是我们只希望选择一个视频，并在任何给定的时间播放。这意味着当我们选择一个新的视频时，我们必须在整个树中搜索当前正在播放的视频并暂停它们。即使只有100个视频，这也不是一个非常可扩展的模式。现在，看看我们如何用ref完成同样的事情:</p><pre class="nm nn no np gt oa nx ob oc aw od bi"><span id="32f4" class="mc lf it nx b gy oe of l og oh">const videos = ["https://example.com/video1.mp4", "https://example.com/video2.mp4", ..., "https://example.com/video100.mp4"];</span><span id="426f" class="mc lf it nx b gy oi of l og oh">const App = () =&gt; {<br/>  const selected = useRef();</span><span id="bca1" class="mc lf it nx b gy oi of l og oh">const handleSelectVideo = ({ currentTarget }) =&gt; {<br/>    if (selected.current) {<br/>      selected.current.classList.remove('playing');<br/>    }<br/>    selected.current = currentTarget;<br/>  };</span><span id="eb42" class="mc lf it nx b gy oi of l og oh">const handleClickPlay = (e) =&gt; {<br/>    selected.current.play();<br/>    selected.current.classList.remove('paused');<br/>    selected.current.classList.add('playing');<br/>  };</span><span id="168d" class="mc lf it nx b gy oi of l og oh">const handleClickPause = (e) =&gt; {<br/>    selected.current.pause();<br/>    selected.current.classList.remove('playing');<br/>    selected.current.classList.add('paused');<br/>  };<br/>  <br/>  return (<br/>    &lt;div&gt;<br/>      {videos.map((video, index) =&gt; (<br/>        &lt;video<br/>          id={`${index}`}<br/>          key={`${index}`}<br/>          onClick={handleSelectVideo}<br/>          src={video}<br/>        /&gt;<br/>      ))}<br/>    &lt;button onClick={handleClickPlay}&gt;<br/>      Play<br/>    &lt;/button&gt;<br/>    &lt;button onClick={handleClickPause}&gt;<br/>      Pause<br/>    &lt;/button&gt;<br/>    &lt;/div&gt;<br/>  );<br/>};</span></pre><p id="6c87" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当简单地通过<code class="fe nu nv nw nx b">getElementById</code>获取一个元素并改变它时，并没有快多少。当处理复杂子树的更新时，竞争优势就来了。这显然是一个简单的例子，但是当涉及到重型前端优化时，refs每次都会胜过直接的DOM操作。</p><h2 id="2ebe" class="mc lf it bd lg md me dn lk mf mg dp lo kr mh mi ls kv mj mk lw kz ml mm ma mn bi translated">8.合并和减少API调用</h2><p id="5777" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">这个提示不是React特有的，主要信息是<em class="nq">“不要像REST一样使用GraphQL】。以下面的代码为例:</em></p><pre class="nm nn no np gt oa nx ob oc aw od bi"><span id="dba3" class="mc lf it nx b gy oe of l og oh">import React, { useEffect, useState } from 'react';</span><span id="711d" class="mc lf it nx b gy oi of l og oh">const App = () =&gt; {<br/>  const [name, setName] = useState('');<br/>  const [numFollowers, setNumFollowers] = useState(0);<br/>  const [error, setError] = useState(undefined);<br/>  useEffect(() =&gt; {<br/>    /**<br/>    * query GetUser {<br/>    *   getUser {<br/>    *     id<br/>    *     name<br/>    *     email<br/>    *   }<br/>    * }<br/>    */<br/>    getUser().then(({ name }) =&gt; setName).catch(setError);<br/>    /**<br/>    * query GetNumFollowers($userid: ID!) {<br/>    *   getNumFollowers(userId: $userid)<br/>    * }<br/>    */<br/>    getNumFollowers().then(setNumFollowers).catch(setError);<br/>  });<br/>  return (<br/>    &lt;&gt;<br/>      &lt;p&gt;Hi my name is {name}&lt;/p&gt;<br/>      &lt;p&gt;I have {numFollowers} followers&lt;/p&gt;<br/>    &lt;/&gt;<br/>  );<br/>};</span></pre><p id="3fd4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">网络请求越多，速度越慢，那么为什么不利用GraphQL的竞争优势呢？</p><pre class="nm nn no np gt oa nx ob oc aw od bi"><span id="2d54" class="mc lf it nx b gy oe of l og oh">import React, { useEffect, useState } from "react";</span><span id="4a85" class="mc lf it nx b gy oi of l og oh">const App = () =&gt; {<br/>  const [name, setName] = useState("");<br/>  const [numFollowers, setNumFollowers] = useState(0);<br/>  const [error, setError] = useState(undefined);<br/>  useEffect(() =&gt; {<br/>    /**<br/>    * query GetUser {<br/>    *   getUser {<br/>    *     name<br/>    *     followers<br/>    *   }<br/>    * }<br/>    */<br/>    getUser()<br/>      .then(({ name, followers }) =&gt; {<br/>        setName(name);<br/>        setNumFollowers(followers.length);<br/>      })<br/>      .catch(setError);<br/>  });<br/>  return error ? &lt;Alert /&gt; : (<br/>    &lt;&gt;<br/>      &lt;p&gt;Hi my name is {name}&lt;/p&gt;<br/>      &lt;p&gt;I have {numFollowers} followers&lt;/p&gt;<br/>    &lt;/&gt;<br/>  );<br/>};</span></pre><p id="3d95" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您还可以通过在父组件级别保存从状态API获取的数据，并通过props或<a class="ae kf" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank"> React上下文API </a>共享它，来减少网络调用的数量。</p><div class="mt mu gp gr mv mw"><a href="https://reactjs.org/docs/context.html" rel="noopener  ugc nofollow" target="_blank"><div class="mx ab fo"><div class="my ab mz cl cj na"><h2 class="bd iu gy z fp nb fr fs nc fu fw is bi translated">上下文反应</h2><div class="nd l"><h3 class="bd b gy z fp nb fr fs nc fu fw dk translated">上下文提供了一种通过组件树传递数据的方法，而不必每次都手动传递属性</h3></div><div class="ne l"><p class="bd b dl z fp nb fr fs nc fu fw dk translated">reactjs.org</p></div></div><div class="nf l"><div class="oj l nh ni nj nf nk jz mw"/></div></div></a></div><h2 id="cb42" class="mc lf it bd lg md me dn lk mf mg dp lo kr mh mi ls kv mj mk lw kz ml mm ma mn bi translated">9.利用浏览器存储</h2><p id="257e" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">浏览器存储不再是你在可耻的行为后必须记得删除的东西。其实在很多方面可以让你的生活更轻松，用户体验更好！React通常使用的许多第三方库在浏览器存储周围有包装器，或者在幕后使用它。然而，现在是你更好地了解它的时候了。<code class="fe nu nv nw nx b">localStorage</code>可用于缓存关闭和重新打开浏览器时保存的内容。<code class="fe nu nv nw nx b">localStorage</code>数据的一个例子是用户的搜索历史或页面书签。<code class="fe nu nv nw nx b">sessionStorage</code>可用于短暂的数据。<code class="fe nu nv nw nx b">sessionStorage</code>数据的一个例子是用于API调用的OAuth令牌。<code class="fe nu nv nw nx b">indexedDB</code>可用于后台web工作人员数据。<code class="fe nu nv nw nx b">indexedDB</code>数据的一个例子是离线时在应用程序中进行的待定更改，一旦网络连接恢复，就可以执行这些更改。此外，使用web workers执行CPU密集型任务将提高React应用程序的性能，因为它们将在单独的线程上运行，不会降低主线程上运行的进程的速度。</p><h2 id="1b5d" class="mc lf it bd lg md me dn lk mf mg dp lo kr mh mi ls kv mj mk lw kz ml mm ma mn bi translated">10.虚拟化大型阵列</h2><p id="7859" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">如果你装载一个非常大的数组到内存中，你可能会想要在屏幕上显示条目(也就是说，这样你的用户可以像僵尸一样无意识地滚动)。一次把所有东西都渲染到DOM中1)会花很长时间，2)一旦加载完毕会很慢。看一看<a class="ae kf" href="https://github.com/bvaughn/react-window" rel="noopener ugc nofollow" target="_blank">反应窗口</a>和<a class="ae kf" href="https://github.com/bvaughn/react-virtualized" rel="noopener ugc nofollow" target="_blank">反应虚拟化</a>，它们提供了用于虚拟化大型阵列的组件。</p><h2 id="564c" class="mc lf it bd lg md me dn lk mf mg dp lo kr mh mi ls kv mj mk lw kz ml mm ma mn bi translated">11.代码分割</h2><p id="4f20" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">没有劈叉那么难！动态和惰性加载是这个游戏的名字，官方的React文档告诉你如何相当容易地做到这一点。</p><div class="mt mu gp gr mv mw"><a href="https://reactjs.org/docs/code-splitting.html" rel="noopener  ugc nofollow" target="_blank"><div class="mx ab fo"><div class="my ab mz cl cj na"><h2 class="bd iu gy z fp nb fr fs nc fu fw is bi translated">代码分解-反应</h2><div class="nd l"><h3 class="bd b gy z fp nb fr fs nc fu fw dk translated">大多数React应用程序会使用Webpack、Rollup或Browserify等工具“捆绑”文件。捆绑是一个过程…</h3></div><div class="ne l"><p class="bd b dl z fp nb fr fs nc fu fw dk translated">reactjs.org</p></div></div><div class="nf l"><div class="ok l nh ni nj nf nk jz mw"/></div></div></a></div><h1 id="9ccd" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">用户体验</h1><h2 id="5bc5" class="mc lf it bd lg md me dn lk mf mg dp lo kr mh mi ls kv mj mk lw kz ml mm ma mn bi translated">12.添加误差边界</h2><p id="c99f" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">这将捕捉你的应用程序可能抛出的任何错误。这样，当你的应用程序不可避免地崩溃时，你的终端用户就不会看到红色屏幕。对于普通的JS，直接从<a class="ae kf" href="https://reactjs.org/docs/error-boundaries.html#introducing-error-boundaries" rel="noopener ugc nofollow" target="_blank">的React文档</a>中复制。对于打字稿，在谷歌上快速搜索会找到一个要点，你也可以复制。一定要给你的顾客开5美元的谷歌搜索费发票。</p><h2 id="9118" class="mc lf it bd lg md me dn lk mf mg dp lo kr mh mi ls kv mj mk lw kz ml mm ma mn bi translated">13.标准化并重用您的通用组件</h2><p id="8d6f" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">网页都使用标准组件，所以要确保它们看起来都一样。通常怀疑的是按钮、输入和链接。但是对于标准化<a class="ae kf" href="https://github.com/reactjs/react-modal" rel="noopener ugc nofollow" target="_blank">模态</a>、<a class="ae kf" href="https://mui.com/material-ui/react-alert/" rel="noopener ugc nofollow" target="_blank">警告</a>和<a class="ae kf" href="https://github.com/davidhu2000/react-spinners" rel="noopener ugc nofollow" target="_blank">微调器</a>来说，还是有一些东西要说的。如果你有时间<a class="ae kf" href="https://medium.com/gumgum-tech/writing-a-shared-react-component-library-with-storybook-78e723438338" rel="noopener">拿出一个组件库</a>是一个值得的努力。</p><div class="mt mu gp gr mv mw"><a href="https://medium.com/gumgum-tech/writing-a-shared-react-component-library-with-storybook-78e723438338" rel="noopener follow" target="_blank"><div class="mx ab fo"><div class="my ab mz cl cj na"><h2 class="bd iu gy z fp nb fr fs nc fu fw is bi translated">用storybook编写共享的React组件库</h2><div class="nd l"><h3 class="bd b gy z fp nb fr fs nc fu fw dk translated">在GumGum，我的团队构建并开发了许多React JS web应用程序。随着应用数量的增长，我们发现自己…</h3></div><div class="ne l"><p class="bd b dl z fp nb fr fs nc fu fw dk translated">medium.com</p></div></div></div></a></div><h2 id="6ca4" class="mc lf it bd lg md me dn lk mf mg dp lo kr mh mi ls kv mj mk lw kz ml mm ma mn bi translated">14.国际化(i18n)和无障碍化(a11y)</h2><p id="f377" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">不要成为史诗翻译失败的牺牲品。赢得像BTS这样的全球观众也可能发生在你的React side项目上！<a class="ae kf" href="https://github.com/i18next/react-i18next" rel="noopener ugc nofollow" target="_blank"> react-i18next </a>是一个非常酷的项目，它实际上使用一个名为<a class="ae kf" href="https://locize.com/?lng=en" rel="noopener ugc nofollow" target="_blank"> locize </a>的后端服务器动态地提供翻译。有了这个库，你可以节省大量的时间和金钱。</p><div class="mt mu gp gr mv mw"><a href="https://medium.com/@jamuhl/get-your-react-js-application-translated-with-style-4ad090aefc2c" rel="noopener follow" target="_blank"><div class="mx ab fo"><div class="my ab mz cl cj na"><h2 class="bd iu gy z fp nb fr fs nc fu fw is bi translated">让您的react.js应用程序翻译得有风格…</h2><div class="nd l"><h3 class="bd b gy z fp nb fr fs nc fu fw dk translated">生活变得更简单…</h3></div><div class="ne l"><p class="bd b dl z fp nb fr fs nc fu fw dk translated">medium.com</p></div></div><div class="nf l"><div class="ol l nh ni nj nf nk jz mw"/></div></div></a></div><p id="aac0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我之前提到的，<a class="ae kf" href="https://github.com/jsx-eslint/eslint-plugin-jsx-a11y#readme" rel="noopener ugc nofollow" target="_blank"> eslint-plugin-jsx-a11y </a>可以帮助你在编写jsx时保持克制。根据github自述文件:</p><blockquote class="om on oo"><p id="2fa2" class="kg kh nq ki b kj kk kl km kn ko kp kq op ks kt ku oq kw kx ky or la lb lc ld im bi translated">该插件对JSX进行静态评估，以发现React应用程序中的可访问性问题。因为它只捕捉静态代码中的错误，所以结合<a class="ae kf" href="https://github.com/dequelabs/axe-core-npm/tree/develop/packages/react" rel="noopener ugc nofollow" target="_blank"> @axe-core/react </a>使用它来测试呈现的DOM的可访问性。把这些工具看作是更大的a11y测试过程的一个步骤，并且总是用辅助技术测试你的应用。</p></blockquote><p id="a8b4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里他们提到了axe-core，它是由Deque为包括JS在内的各种语言开发的。</p><div class="mt mu gp gr mv mw"><a href="https://github.com/dequelabs/axe-core-npm/tree/develop/packages/react" rel="noopener  ugc nofollow" target="_blank"><div class="mx ab fo"><div class="my ab mz cl cj na"><h2 class="bd iu gy z fp nb fr fs nc fu fw is bi translated">axe-core-NPM/packages/react at developer dequelabs/axe-core-NPM</h2><div class="nd l"><h3 class="bd b gy z fp nb fr fs nc fu fw dk translated">使用axe-core可访问性测试库测试您的React应用程序。结果将显示在Chrome开发工具中…</h3></div><div class="ne l"><p class="bd b dl z fp nb fr fs nc fu fw dk translated">github.com</p></div></div><div class="nf l"><div class="os l nh ni nj nf nk jz mw"/></div></div></a></div><p id="272d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，无论是否使用React，您都应该养成编写正确语义HTML的习惯。React官方文档提供了更多关于如何提高网站可访问性的技巧:</p><div class="mt mu gp gr mv mw"><a href="https://reactjs.org/docs/accessibility.html" rel="noopener  ugc nofollow" target="_blank"><div class="mx ab fo"><div class="my ab mz cl cj na"><h2 class="bd iu gy z fp nb fr fs nc fu fw is bi translated">可访问性-反应</h2><div class="nd l"><h3 class="bd b gy z fp nb fr fs nc fu fw dk translated">用于构建用户界面的JavaScript库</h3></div><div class="ne l"><p class="bd b dl z fp nb fr fs nc fu fw dk translated">reactjs.org</p></div></div><div class="nf l"><div class="ot l nh ni nj nf nk jz mw"/></div></div></a></div><p id="54b6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">TL；你可以为此使用图书馆</p><h1 id="5409" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="f1d5" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">除了这里提到的技巧之外，您还可以实施非React专用的最佳实践，例如使用CDN、在API和DB级别缓存、导入UX设计器线框、树抖动、减少总捆绑包大小等。这份清单可以一直列下去，但是你明白了。</p><p id="e1f7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你喜欢我老套的写作风格，请跟我来。我每月发表约1次文章，我喜欢社交。谢谢</p></div></div>    
</body>
</html>