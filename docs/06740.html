<html>
<head>
<title>Creating a minimal RabbitMQ client using Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Go创建一个最小的RabbitMQ客户端</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/creating-a-minimal-rabbitmq-client-using-go-cbcec1470950?source=collection_archive---------2-----------------------#2020-12-25">https://levelup.gitconnected.com/creating-a-minimal-rabbitmq-client-using-go-cbcec1470950?source=collection_archive---------2-----------------------#2020-12-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/4d4d1dbd5d85872f51e2c58447c1c8e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CKouIkjnVRhFloLK"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@ffstop?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Fotis Fotopoulos </a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="7868" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi lb translated"><span class="l lc ld le bm lf lg lh li lj di"> Go </span>是一种开源编程语言，可以轻松构建简单、可靠、高效的软件。RabbitMQ是一个开源的消息代理软件，它最初实现了高级消息队列协议，后来用一个插件架构进行了扩展，以支持面向流文本的消息协议、MQ遥测传输和其他协议。</p><blockquote class="lk ll lm"><p id="42ed" class="kd ke ln kf b kg kh ki kj kk kl km kn lo kp kq kr lp kt ku kv lq kx ky kz la ij bi translated"><em class="iq">在本教程中，我们将创建一个最小的RabbitMQ客户端，它允许其他包使用RabbitMQ或向rabbit MQ发布消息。最终的源代码可以在我的</em><a class="ae kc" href="https://github.com/mehrdadep/rmq" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir"><em class="iq">GitHub</em></strong></a><em class="iq">上找到。</em></p></blockquote><h1 id="bdb4" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">先决条件</h1><ul class=""><li id="a0b1" class="mp mq iq kf b kg mr kk ms ko mt ks mu kw mv la mw mx my mz bi translated">我假设你已经安装了<code class="fe na nb nc nd b">Go</code>。如果不是，在这里检查<a class="ae kc" href="https://golang.org/doc/install" rel="noopener ugc nofollow" target="_blank">和</a>。</li><li id="74e2" class="mp mq iq kf b kg ne kk nf ko ng ks nh kw ni la mw mx my mz bi translated">你需要了解一点关于<a class="ae kc" href="https://blog.golang.org/using-go-modules" rel="noopener ugc nofollow" target="_blank">围棋模块</a>的知识。我们将使用模块作为我们的依赖管理解决方案。</li><li id="9efe" class="mp mq iq kf b kg ne kk nf ko ng ks nh kw ni la mw mx my mz bi translated">您需要对RabbitMQ的工作原理有所了解。我们不打算涵盖消费和发布消息的每个方面和类型。</li></ul><h1 id="e3d0" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">第一步</h1><p id="7b42" class="pw-post-body-paragraph kd ke iq kf b kg mr ki kj kk ms km kn ko nj kq kr ks nk ku kv kw nl ky kz la ij bi translated">首先，您需要用您的模块名创建一个目录。我准备把它命名为<code class="fe na nb nc nd b">rmq</code>。然后使用<code class="fe na nb nc nd b">go mod init</code>命令初始化go模块。现在，您必须使用<code class="fe na nb nc nd b">go get github.com/streadway/amqp.</code>获得主依赖项</p><p id="00aa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在在你的模块的根目录下创建一个<code class="fe na nb nc nd b">main.go</code>文件。这个文件是所有事情开始的地方(也可能是结束的地方)。您的主文件应该是这样的:</p><pre class="nm nn no np gt nq nd nr ns aw nt bi"><span id="a09c" class="nu ls iq nd b gy nv nw l nx ny">package rmq</span></pre><p id="7e2e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们创建一个名为<code class="fe na nb nc nd b">RabbitClient</code>的定制类型。我们将在这个客户端中分别添加消费者和发布者通道以及连接。</p><pre class="nm nn no np gt nq nd nr ns aw nt bi"><span id="a785" class="nu ls iq nd b gy nv nw l nx ny"><em class="ln">type </em>RabbitClient <em class="ln">struct </em>{<br/>   sendConn *amqp.Connection<br/>   recConn  *amqp.Connection<br/>   sendChan *amqp.Channel<br/>   recChan  *amqp.Channel<br/>}</span></pre><h1 id="b9a8" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">连接和创建频道</h1><p id="ae8d" class="pw-post-body-paragraph kd ke iq kf b kg mr ki kj kk ms km kn ko nj kq kr ks nk ku kv kw nl ky kz la ij bi translated">在这一部分中，我们将为我们的自定义类型添加两个私有方法，尝试连接到RabbitMQ，然后基于连接类型(消费者|发布者)和重新连接(如果已经存在，尝试重新连接)创建一个通道。</p><p id="df42" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe na nb nc nd b">connect</code>方法接收两个布尔参数来了解连接类型和重新连接模式。我们假设您已经在一个名为<code class="fe na nb nc nd b">config</code>的自定义类型中拥有了关于RabbitMQ服务的信息(用户名、密码、主机和端口)。</p><pre class="nm nn no np gt nq nd nr ns aw nt bi"><span id="f528" class="nu ls iq nd b gy nv nw l nx ny">// Create a connection to rabbitmq<br/>func (rcl *RabbitClient) connect(isRec, reconnect bool) (*amqp.Connection, error) {<br/> if reconnect {<br/>  if isRec {<br/>   rcl.recConn = nil<br/>  } else {<br/>   rcl.sendConn = nil<br/>  }<br/> }<br/> if isRec &amp;&amp; rcl.recConn != nil {<br/>  return rcl.recConn, nil<br/> } else if !isRec &amp;&amp; rcl.sendConn != nil {<br/>  return rcl.sendConn, nil<br/> }<br/> var c string<br/> if config.Username == "" {<br/>  c = fmt.Sprintf("amqp://%s:%s/", config.Host, config.Port)<br/> } else {<br/>  c = fmt.Sprintf("amqp://%s:%s@%s:%s/", config.Username, config.Password, config.Host, config.Port)<br/> }<br/> conn, err := amqp.Dial(c)<br/> if err != nil {<br/>  log.Printf("\r\n--- could not create a conection ---\r\n")<br/>  time.Sleep(1 * time.Second)<br/>  return nil, err<br/> }<br/> if isRec {<br/>  rcl.recConn = conn<br/>  return rcl.recConn, nil<br/> } else {<br/>  rcl.sendConn = conn<br/>  return rcl.sendConn, nil<br/> }<br/>}</span></pre><p id="fe5b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">与<code class="fe na nb nc nd b">connect</code>方法相同，<code class="fe na nb nc nd b">channel</code>方法接收两个布尔参数来了解连接类型和重新连接模式。这个方法永远尝试连接到RabbitMQ服务，然后根据连接类型创建一个通道。</p><pre class="nm nn no np gt nq nd nr ns aw nt bi"><span id="40fe" class="nu ls iq nd b gy nv nw l nx ny"><em class="ln">func </em>(rcl *RabbitClient) channel(isRec, recreate bool) (*amqp.Channel, error) {<br/>   <em class="ln">if </em>recreate {<br/>      <em class="ln">if </em>isRec {<br/>         rcl.recChan = <em class="ln">nil<br/>      </em>} <em class="ln">else </em>{<br/>         rcl.sendChan = <em class="ln">nil<br/>      </em>}<br/>   }<br/>   <em class="ln">if </em>isRec &amp;&amp; rcl.recConn == <em class="ln">nil </em>{<br/>      rcl.recChan = <em class="ln">nil<br/>   </em>}<br/>   <em class="ln">if </em>!isRec &amp;&amp; rcl.sendConn == <em class="ln">nil </em>{<br/>      rcl.recChan = <em class="ln">nil<br/>   </em>}<br/>   <em class="ln">if </em>isRec &amp;&amp; rcl.recChan != <em class="ln">nil </em>{<br/>      <em class="ln">return </em>rcl.recChan, <em class="ln">nil<br/>   </em>} <em class="ln">else if </em>!isRec &amp;&amp; rcl.sendChan != <em class="ln">nil </em>{<br/>      <em class="ln">return </em>rcl.sendChan, <em class="ln">nil<br/>   </em>}<br/>   <em class="ln">for </em>{<br/>      _, err := rcl.connect(isRec, recreate)<br/>      <em class="ln">if </em>err == <em class="ln">nil </em>{<br/>         <em class="ln">break<br/>      </em>}<br/>   }<br/>   <em class="ln">var </em>err error<br/>   <em class="ln">if </em>isRec {<br/>      rcl.recChan, err = rcl.recConn.Channel()<br/>   } <em class="ln">else </em>{<br/>      rcl.sendChan, err = rcl.sendConn.Channel()<br/>   }<br/>   <em class="ln">if </em>err != <em class="ln">nil </em>{<br/>      log.Println("--- could not create channel ---")<br/>      time.Sleep(1 * time.<em class="ln">Second</em>)<br/>      <em class="ln">return nil</em>, err<br/>   }<br/>   <em class="ln">if </em>isRec {<br/>      <em class="ln">return </em>rcl.recChan, err<br/>   } <em class="ln">else </em>{<br/>      <em class="ln">return </em>rcl.sendChan, err<br/>   }<br/>}</span></pre><p id="1e42" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">既然我们能够连接和创建通道，那么让我们开始消费和发布消息。我们将声明在消费和发布模式下都持久的惰性模式队列。你可以把它改成任何适合你的问题的。</p><h1 id="5f5c" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">让我们消费一些东西</h1><p id="401e" class="pw-post-body-paragraph kd ke iq kf b kg mr ki kj kk ms km kn ko nj kq kr ks nk ku kv kw nl ky kz la ij bi translated"><code class="fe na nb nc nd b">Consume</code>方法接收两个参数，一个是队列的名称，另一个是处理被消费消息体的函数。我们将根据该函数的结果执行<code class="fe na nb nc nd b">ack|nack</code>。</p><pre class="nm nn no np gt nq nd nr ns aw nt bi"><span id="6c40" class="nu ls iq nd b gy nv nw l nx ny">// Consume based on name of the queue<br/>func (rcl *RabbitClient) Consume(n string, f func(interface{}) error) {<br/> for {<br/>  for {<br/>   _, err := rcl.channel(true, true)<br/>   if err == nil {<br/>    break<br/>   }<br/>  }<br/>  log.Printf("--- connected to consume '%s' ---\r\n", n)<br/>  q, err := rcl.recChan.QueueDeclare(<br/>   n,<br/>   true,<br/>   false,<br/>   false,<br/>   false,<br/>   amqp.Table{"x-queue-mode": "lazy"},<br/>  )<br/>  if err != nil {<br/>   log.Println("--- failed to declare a queue, trying to reconnect ---")<br/>   continue<br/>  }<br/>  connClose := rcl.recConn.NotifyClose(make(chan *amqp.Error))<br/>  connBlocked := rcl.recConn.NotifyBlocked(make(chan amqp.Blocking))<br/>  chClose := rcl.recChan.NotifyClose(make(chan *amqp.Error))<br/>  m, err := rcl.recChan.Consume(<br/>   q.Name,<br/>   uuid.NewV4().String(),<br/>   false,<br/>   false,<br/>   false,<br/>   false,<br/>   nil,<br/>  )<br/>  if err != nil {<br/>   log.Println("--- failed to consume from queue, trying again ---")<br/>   continue<br/>  }<br/>  shouldBreak := false<br/>  for {<br/>   if shouldBreak {<br/>    break<br/>   }<br/>   select {<br/>   case _ = &lt;-connBlocked:<br/>    log.Println("--- connection blocked ---")<br/>    shouldBreak = true<br/>    break<br/>   case err = &lt;-connClose:<br/>    log.Println("--- connection closed ---")<br/>    shouldBreak = true<br/>    break<br/>   case err = &lt;-chClose:<br/>    log.Println("--- channel closed ---")<br/>    shouldBreak = true<br/>    break<br/>   case d := &lt;-m:<br/>    err := f(d.Body)<br/>    if err != nil {<br/>     _ = d.Ack(false)<br/>     break<br/>    }<br/>    _ = d.Ack(true)<br/>   }<br/>  }<br/> }<br/>}</span></pre><p id="6e55" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe na nb nc nd b">Consume</code>方法处理来自连接和通道的<code class="fe na nb nc nd b">NotifyClose</code>、<code class="fe na nb nc nd b">NotifyBlocked</code>和<code class="fe na nb nc nd b">NotifyClose</code>，并在需要时尝试重新连接或重新创建它们。</p><h1 id="9dae" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">我们发表点什么吧</h1><p id="e7f5" class="pw-post-body-paragraph kd ke iq kf b kg mr ki kj kk ms km kn ko nj kq kr ks nk ku kv kw nl ky kz la ij bi translated"><code class="fe na nb nc nd b">Publish</code>方法接收三个参数，一个是队列名，另一个是字节数组，包含消息体。</p><pre class="nm nn no np gt nq nd nr ns aw nt bi"><span id="bdc4" class="nu ls iq nd b gy nv nw l nx ny">// Publish an array of bytes to a queue<br/>func (rcl *RabbitClient) Publish(n string, b []byte) {</span><span id="e644" class="nu ls iq nd b gy nz nw l nx ny"> r := false<br/> for {<br/>  for {<br/>   _, err := rcl.channel(false, r)<br/>   if err == nil {<br/>    break<br/>   }<br/>  }<br/>  q, err := rcl.sendChan.QueueDeclare(<br/>   n,<br/>   true,<br/>   false,<br/>   false,<br/>   false,<br/>   amqp.Table{"x-queue-mode": "lazy"},<br/>  )<br/>  if err != nil {<br/>   log.Println("--- failed to declare a queue, trying to resend ---")<br/>   r = true<br/>   continue<br/>  }<br/>  err = rcl.sendChan.Publish(<br/>   "",<br/>   q.Name,<br/>   false,<br/>   false,<br/>   amqp.Publishing{<br/>    MessageId:    uuid.NewV4().String(),<br/>    DeliveryMode: amqp.Persistent,<br/>    ContentType:  "text/plain",<br/>    Body:         b,<br/>   })<br/>  if err != nil {<br/>   log.Println("--- failed to publish to queue, trying to resend ---")<br/>   r = true<br/>   continue<br/>  }<br/>  break<br/> }<br/>}</span></pre><p id="292b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果需要，该方法处理信道的重新连接或重建。</p><h1 id="56de" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">使用</h1><p id="ce55" class="pw-post-body-paragraph kd ke iq kf b kg mr ki kj kk ms km kn ko nj kq kr ks nk ku kv kw nl ky kz la ij bi translated">创建一个<code class="fe na nb nc nd b">RabbitClient</code>类型的实例，并使用<code class="fe na nb nc nd b">Consume</code>或<code class="fe na nb nc nd b">Publish</code>方法。</p><pre class="nm nn no np gt nq nd nr ns aw nt bi"><span id="4bd1" class="nu ls iq nd b gy nv nw l nx ny"><em class="ln">var </em>rc rmq.RabbitClient</span><span id="f9b1" class="nu ls iq nd b gy nz nw l nx ny">rc.Consume("test-queue", funcName)</span><span id="8c8c" class="nu ls iq nd b gy nz nw l nx ny">rc.Publish("test-queue", mBody)</span></pre><h1 id="fcb1" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">我没有提到的是</h1><ul class=""><li id="96dd" class="mp mq iq kf b kg mr kk ms ko mt ks mu kw mv la mw mx my mz bi translated">不同类型的队列检测</li><li id="6d23" class="mp mq iq kf b kg ne kk nf ko ng ks nh kw ni la mw mx my mz bi translated">使用交换</li><li id="2d0a" class="mp mq iq kf b kg ne kk nf ko ng ks nh kw ni la mw mx my mz bi translated">单元测试</li></ul></div></div>    
</body>
</html>