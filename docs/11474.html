<html>
<head>
<title>Port an existing C/C++ app (Dungeon Crawler — Rogue) to Flutter with Dart FFI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">移植一个现有的C/C++应用程序(地牢爬虫——流氓),使之与Dart FFI一起跳动</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/port-an-existing-c-c-app-dungeon-crawler-rogue-to-flutter-with-dart-ffi-a701284aa289?source=collection_archive---------7-----------------------#2022-03-20">https://levelup.gitconnected.com/port-an-existing-c-c-app-dungeon-crawler-rogue-to-flutter-with-dart-ffi-a701284aa289?source=collection_archive---------7-----------------------#2022-03-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="04e4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在之前的<a class="ae kl" rel="noopener ugc nofollow" target="_blank" href="/port-an-existing-c-c-app-to-flutter-with-dart-ffi-8dc401a69fd7"> <em class="km">文章</em> </a>中，我们开始了将现有C/C++应用移植到Flutter的旅程。我们学习了如何在Flutter环境中使用C/C++。现在我们开始实际移植一个应用程序。</p><h1 id="6464" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">流氓5.4</h1><p id="c3a6" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">我们选择了地牢爬行，幻想角色扮演游戏——流氓。</p><p id="ff33" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Rogue在终端上运行，使用Curses库来管理其基于文本的用户界面。这个游戏很古老。通过下面的截图，你会相信这是真的。但是游戏被认为是经典。它的风格有一个狂热的T4，一直延续到今天。为具有Flutter功能的移动设备重新想象这款经典游戏，就像给旧滑板添加一个电动马达一样。但是如果我们正确地完成这项任务，我们将会取得胜利。也许我们的名字会被铭刻在流氓地牢的末日传说中。</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div class="gh gi lq"><img src="../Images/c2a49c67889038d1f43ca13dd50d3410.png" data-original-src="https://miro.medium.com/v2/resize:fit:1398/format:webp/1*WYw2_67LrZkWKrJjyoIp9A.png"/></div></figure><h1 id="8063" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">战略</h1><p id="c0f1" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">我们应对这一挑战的方法如下:</p><ol class=""><li id="de99" class="ly lz iq jp b jq jr ju jv jy ma kc mb kg mc kk md me mf mg bi translated">编译Rogue作为Flutter app构建过程的一部分；</li><li id="8d7d" class="ly lz iq jp b jq mh ju mi jy mj kc mk kg ml kk md me mf mg bi translated">编译PDCurses —将Curses UI替换为一个可以定制为与Dart对话的UI；</li><li id="da4c" class="ly lz iq jp b jq mh ju mi jy mj kc mk kg ml kk md me mf mg bi translated">构建应用程序渲染器—编写我们的Flutter UI代码；</li><li id="e559" class="ly lz iq jp b jq mh ju mi jy mj kc mk kg ml kk md me mf mg bi translated">调整应用程序——让它可以在移动设备上播放；</li><li id="119f" class="ly lz iq jp b jq mh ju mi jy mj kc mk kg ml kk md me mf mg bi translated">使游戏图形现代化；</li></ol></div><div class="ab cl mm mn hu mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ij ik il im in"><p id="3e9e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="km">警告:从现在开始，我将假设您已经</em> <a class="ae kl" rel="noopener ugc nofollow" target="_blank" href="/port-an-existing-c-c-app-to-flutter-with-dart-ffi-8dc401a69fd7"> <em class="km">阅读了之前的文章</em> </a> <em class="km">。这是先决条件。</em></p><p id="f33f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本文完成的项目源代码位于:</p><pre class="lr ls lt lu gt mt mu mv mw aw mx bi"><span id="b8dc" class="my ko iq mu b gy mz na l nb nc">git clone <a class="ae kl" href="https://github.com/icedman/rogue_flutter" rel="noopener ugc nofollow" target="_blank">https://github.com/icedman/rogue_flutter</a></span></pre><p id="2699" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个应用程序包含从上一篇文章中摘录的代码:</p><pre class="lr ls lt lu gt mt mu mv mw aw mx bi"><span id="26ae" class="my ko iq mu b gy mz na l nb nc">git clone <a class="ae kl" href="https://github.com/icedman/flutter_ffi_test" rel="noopener ugc nofollow" target="_blank">https://github.com/icedman/flutter_ffi_test</a></span></pre></div><div class="ab cl mm mn hu mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ij ik il im in"><h1 id="8bb1" class="kn ko iq bd kp kq nd ks kt ku ne kw kx ky nf la lb lc ng le lf lg nh li lj lk bi translated"><strong class="ak">添加第三方C/C++库</strong></h1><p id="40b6" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">我们的策略包括向我们的应用程序添加两个第三方库。Rogue-5.4，我们的C/C++游戏；PDCurses-3.4是我们的Curses替代品。</p><h2 id="e763" class="my ko iq bd kp ni nj dn kt nk nl dp kx jy nm nn lb kc no np lf kg nq nr lj ns bi translated"><em class="nt">编译流氓</em></h2><p id="8753" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">我们必须确保现有的代码和第三方库至少可以在Flutter环境下编译。目标是还没有运行一个可玩的游戏。而是调查在构建过程中是否有任何可能需要处理的障碍。</p><p id="04ec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们先查Linux和Android。回想一下第一篇文章，这些系统可以共享同一个<em class="km"> CMakeLists </em>文件。我们可以测试我们的理论:“写一次，在任何地方运行”( T21)。出于本文的目的，测试将只针对Linux和Android。而且在这个阶段，测试还没有在任何地方运行。不过<em class="km"> </em>仅仅是<em class="km">写一次</em>，<strong class="jp ir"> <em class="km">随时随地打造。</em> </strong></p><p id="0759" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在目录<em class="km"> libs </em>下，我们创建一个目录<em class="km"> rogue-5.4 </em>，其中将包含Rogue 5.4的源代码。</p><pre class="lr ls lt lu gt mt mu mv mw aw mx bi"><span id="4533" class="my ko iq mu b gy mz na l nb nc">libs\rogue-5.4\<br/>  ./armor.c<br/>  ./chase.c<br/>...</span></pre><p id="c2f7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们编辑<em class="km"> libs\CMakeLists.txt </em>文件并定义一个静态库<em class="km"> rogue: </em></p><pre class="lr ls lt lu gt mt mu mv mw aw mx bi"><span id="7b5d" class="my ko iq mu b gy mz na l nb nc">add_library(rogue<br/>  STATIC<br/>  ./rogue-5.4/armor.c<br/>  ./rogue-5.4/chase.c<br/>...</span></pre><p id="e2cd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还定义了包含目录，以便在构建过程中找到头文件:</p><pre class="lr ls lt lu gt mt mu mv mw aw mx bi"><span id="e711" class="my ko iq mu b gy mz na l nb nc">target_include_directories(rogue <br/>    PRIVATE<br/>    ./rogue-5.4/<br/>)</span></pre><p id="17aa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们自己的库— <em class="km"> libapi.so </em>(在Linux和Android上)，以前配置为:</p><pre class="lr ls lt lu gt mt mu mv mw aw mx bi"><span id="f04f" class="my ko iq mu b gy mz na l nb nc">add_library(api<br/>  SHARED<br/>  ./api.cpp<br/>  exports.def<br/>)</span></pre><p id="b5ad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将把新的静态库rogue链接到我们的api库:</p><pre class="lr ls lt lu gt mt mu mv mw aw mx bi"><span id="5656" class="my ko iq mu b gy mz na l nb nc">target_include_directories(api <br/>    PRIVATE<br/>    ./rogue-5.4/<br/>)</span><span id="1202" class="my ko iq mu b gy nu na l nb nc">target_link_libraries(api PRIVATE rogue)</span></pre><h2 id="51aa" class="my ko iq bd kp ni nj dn kt nk nl dp kx jy nm nn lb kc no np lf kg nq nr lj ns bi translated"><em class="nt">首次构建</em></h2><pre class="lr ls lt lu gt mt mu mv mw aw mx bi"><span id="7623" class="my ko iq mu b gy mz na l nb nc">flutter build linux -v</span></pre><p id="e83d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我的Linux系统上，这可以毫无问题地构建库。这很奇怪。流氓使用，我们还没注入的诅咒。编译时缺少Curses头，或者链接时缺少引用，构建应该会失败。</p><p id="a01c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">原因是我的Linux系统安装了<em class="km"> libncurses </em>。Flutter构建过程选择了这个库和它的头文件路径，并且毫无怨言地继续进行。这是一个值得注意的陷阱。请记住，我们将删除诅咒，并实现我们自己的UI。</p><pre class="lr ls lt lu gt mt mu mv mw aw mx bi"><span id="9091" class="my ko iq mu b gy mz na l nb nc">flutter build apk -v</span></pre><p id="e69d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Android构建运行如预期的那样失败。<em class="km">“写一次，随处运行”</em>的一个推论应该是<em class="km">“失败一次，处处失败”。</em></p><p id="c890" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将继续进行，同时在心里记下这个麻烦——就像遇到蝙蝠后继续进行地牢爬行一样。</p><h2 id="07ba" class="my ko iq bd kp ni nj dn kt nk nl dp kx jy nm nn lb kc no np lf kg nq nr lj ns bi translated">编译程序</h2><p id="9f9c" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">PD Curses——公共域Curses——是Curses的一个可移植实现。它实现了大多数Curses函数调用，同时允许我们用自己的实现轻松地覆盖它们。我们将定制PDCurses，以允许我们的应用程序在终端之外运行。</p><p id="f626" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将<em class="km"> pdcurses </em>源代码复制到<em class="km"> libs </em>文件夹中。就像我们对<em class="km">流氓</em>做的一样。并修改我们的CMakeLists来定义我们的<em class="km"> pdcurses </em>库。</p><pre class="lr ls lt lu gt mt mu mv mw aw mx bi"><span id="e34d" class="my ko iq mu b gy mz na l nb nc">add_library(pdcurses<br/>  STATIC<br/>  ./PDCurses-3.4/pdcurses/addch.c<br/>  ./PDCurses-3.4/pdcurses/addchstr.c<br/>...</span></pre><p id="72c2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将静态<em class="km"> pdcurses </em>库链接到我们的<em class="km"> rogue </em>库和我们的<em class="km"> api </em>库，并配置头路径:</p><pre class="lr ls lt lu gt mt mu mv mw aw mx bi"><span id="af3f" class="my ko iq mu b gy mz na l nb nc">target_include_directories(rogue <br/>    PRIVATE<br/>   ./pdcurses-3.4<br/>   ./rogue-5.4/<br/>...<br/>target_link_libraries(rogue PRIVATE pdcurses)</span><span id="41ee" class="my ko iq mu b gy nu na l nb nc">target_include_directories(api <br/>    PRIVATE<br/>   ./pdcurses-3.4<br/>...<br/>target_link_libraries(api PRIVATE rogue pdcurses)</span></pre><p id="0d61" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们的<em class="km"> api.cpp </em>代码中——我们正在编写的库——我们现在可以使用第三方库<em class="km"> pdcurses </em>和<em class="km"> rogue </em>。</p><pre class="lr ls lt lu gt mt mu mv mw aw mx bi"><span id="7590" class="my ko iq mu b gy mz na l nb nc">#include &lt;curses&gt;<br/>#include &lt;rogue.h&gt;</span><span id="b576" class="my ko iq mu b gy nu na l nb nc">...<br/>initscr(); // pdcurses library call<br/>rogue_main(); // rogue library call</span></pre><h2 id="2c4b" class="my ko iq bd kp ni nj dn kt nk nl dp kx jy nm nn lb kc no np lf kg nq nr lj ns bi translated">第二次构建</h2><pre class="lr ls lt lu gt mt mu mv mw aw mx bi"><span id="5dd8" class="my ko iq mu b gy mz na l nb nc">flutter build linux -v<br/>flutter build apk -v</span></pre><p id="c755" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于Linux和Android，这两个命令现在都可以正确构建了。</p><h1 id="3e85" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">一些快进</h1><p id="d9c6" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">我已经对<em class="km">盗贼</em>和<em class="km">诅咒</em>库做了一些改动。</p><p id="f065" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我禁用了可能不存在或无法在其他系统上工作的代码和功能，或者可能需要特定权限的代码和功能，例如涉及文件读写的代码和功能，或者涉及会在Android上崩溃的系统调用(如<em class="km"> getuid() </em>)的代码和功能。这些涉及到一些构建、运行、失败、修改，我在这里就不详述了。</p><p id="143e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我还通过定制<em class="km"> pdcurses </em>实现了Flutter和我们的原生流氓应用之间的双向通信。现在，Rogue中的每个相关诅咒调用都会经过这个文件:</p><pre class="lr ls lt lu gt mt mu mv mw aw mx bi"><span id="a9fb" class="my ko iq mu b gy mz na l nb nc">libs/PDCurses-3.4/impl/pdc_impl.c</span></pre><p id="48c1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的<em class="km"> pdcurses </em>实现捕获并保存curses所做的所有屏幕更新。它还提供了一种模拟用户按键输入的方法。我们的Flutter/Dart应用程序通过调用<em class="km"> getScreenBuffer </em>()读取屏幕数据。Flutter/Dart应用程序通过调用<em class="km"> pushKey()向我们的库写入一个键输入。</em></p><h2 id="cb5b" class="my ko iq bd kp ni nj dn kt nk nl dp kx jy nm nn lb kc no np lf kg nq nr lj ns bi translated"><strong class="ak">重访球棒</strong></h2><p id="c145" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">如果我们对我们的代码进行一次测试，我们将再次遇到Linux构建中提到的麻烦。原来<em class="km"> libncursesw.so </em>在创建窗口时加载了Flutter <em class="km"> runner </em>(我们的应用程序可执行文件)。我们的PDCurses实现永远不会被调用，因为现有的Curses库符号已经被<em class="km"> libncursesw </em>加载了。</p><p id="74e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">编辑<em class="km"> linux/CMakeLists.txt </em>:</p><pre class="lr ls lt lu gt mt mu mv mw aw mx bi"><span id="831a" class="my ko iq mu b gy mz na l nb nc">target_link_libraries(${BINARY_NAME} PRIVATE flutter)<br/>target_link_libraries(${BINARY_NAME} PRIVATE PkgConfig::GTK)<br/><strong class="mu ir">target_link_libraries(${BINARY_NAME} PRIVATE api)</strong></span></pre><p id="95d1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们不是仅仅在运行时用Dart FFI<em class="km">dynamic library . open来加载我们的<em class="km"> api </em>库，而是用Flutter <em class="km"> runner来链接我们的<em class="km"> api </em>库。</em>这具有在<em class="km"> libncursesw </em>上预加载我们的<em class="km"> api </em>库和<em class="km"> pdcurses </em>符号的效果。</em></p><h1 id="5624" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">运行流氓应用程序</h1><p id="b508" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">考虑以下代码:</p><pre class="lr ls lt lu gt mt mu mv mw aw mx bi"><span id="e515" class="my ko iq mu b gy mz na l nb nc">extern "C" {<br/>   int rogue_main(int argc, char **argv);<br/>}</span><span id="793a" class="my ko iq mu b gy nu na l nb nc">EXPORT<br/>int initApp() {</span><span id="89b0" class="my ko iq mu b gy nu na l nb nc">   const char *argv[] = {<br/>        "rogue",<br/>        "--scr-width=80",<br/>        "--scr-height=25",<br/>        "--sec-width=80",<br/>        "--sec-height=25",<br/>    };<br/>    <br/>  return rogue_main(5, (char**)argv);<br/>}</span></pre><p id="2072" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们导出函数<em class="km"> initApp — </em>，我们将从我们的Flutter/Dart应用程序中调用它。这又会调用<em class="km"> rogue_main — </em>流氓app的入口点。</p><p id="12a2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">问题是<em class="km"> rogue_main </em>是阻塞调用。它永远不会退出或返回。它会无休止地循环查询输入、计算游戏逻辑、更新游戏状态、刷新屏幕等等。Flutter应用程序会变得没有响应。</p><h2 id="c9ac" class="my ko iq bd kp ni nj dn kt nk nl dp kx jy nm nn lb kc no np lf kg nq nr lj ns bi translated">线程上的流氓</h2><p id="ff6b" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">因此，我们需要在一个单独的线程中运行<em class="km"> rogue_main </em>。这里我们将使用<em class="km"> pthread </em>。这个库可以在Linux、Android、macOS、iOS上使用。Windows有自己的线程库，但是<em class="km"> pthread </em> wrappers存在。</p><pre class="lr ls lt lu gt mt mu mv mw aw mx bi"><span id="f187" class="my ko iq mu b gy mz na l nb nc">void* run_thread(void*) {<br/>  const char *argv[] = {<br/>        "rogue",<br/>        "--scr-width=80",<br/>        "--scr-height=25",<br/>        "--sec-width=80",<br/>        "--sec-height=25",<br/>    };<br/>    <br/>  rogue_main(5, (char**)argv);<br/>}</span><span id="424b" class="my ko iq mu b gy nu na l nb nc">EXPORT<br/>int initApp() {<br/>   <strong class="mu ir">pthread_create(&amp;threadId, NULL, &amp;run_thread, (void*)"");</strong><br/>   return 0;<br/>}</span></pre><p id="8f2e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的游戏现在有效地与我们的Flutter应用程序并行运行。在Flutter中，我们通过对<em class="km">char</em>* g<em class="km">etScreenBuffer()、</em>和<em class="km"> void pushKey(int key)的同步调用，与本地应用线程进行通信。</em></p><pre class="lr ls lt lu gt mt mu mv mw aw mx bi"><span id="b423" class="my ko iq mu b gy mz na l nb nc">extern "C" {<br/>   char *getScreenData();<br/>   void pushKey(int k);<br/>}</span><span id="ddd0" class="my ko iq mu b gy nu na l nb nc">EXPORT<br/>char* read() {<br/>  return getScreenData();<br/>}</span><span id="5d3f" class="my ko iq mu b gy nu na l nb nc">EXPORT<br/>void write(int key) {<br/>  pushKey(key);<br/>}</span></pre><p id="fa1d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在Flutter上，我们将这些导出的函数绑定在我们的<em class="km"> FFIBridge </em>类上；</p><pre class="lr ls lt lu gt mt mu mv mw aw mx bi"><span id="9ef6" class="my ko iq mu b gy mz na l nb nc">class FFIBridge {</span><span id="cec6" class="my ko iq mu b gy nu na l nb nc">...</span><span id="a970" class="my ko iq mu b gy nu na l nb nc">final _initApp = nativeApiLib.lookup&lt;NativeFunction&lt;Void Function()&gt;&gt;('initApp');<br/><strong class="mu ir">initApp</strong> = _initApp.asFunction&lt;void Function()&gt;();</span><span id="2ad5" class="my ko iq mu b gy nu na l nb nc">final _getSB = nativeApiLib        .lookup&lt;NativeFunction&lt;Pointer&lt;Utf8&gt; Function()&gt;&gt;('read');<br/><strong class="mu ir">_getScreenBuffer</strong> = _getSB.asFunction&lt;Pointer&lt;Utf8&gt; Function()&gt;();</span><span id="d372" class="my ko iq mu b gy nu na l nb nc">final _pk = nativeApiLib.lookup&lt;NativeFunction&lt;Void Function(Pointer&lt;Utf8&gt;)&gt;&gt;('write');<br/><strong class="mu ir">_pushKey</strong> = _pk.asFunction&lt;void Function(Pointer&lt;Utf8&gt;)&gt;();</span><span id="e8c1" class="my ko iq mu b gy nu na l nb nc">...</span><span id="891a" class="my ko iq mu b gy nu na l nb nc">}</span></pre><h2 id="58b9" class="my ko iq bd kp ni nj dn kt nk nl dp kx jy nm nn lb kc no np lf kg nq nr lj ns bi translated"><strong class="ak">螺纹安全</strong></h2><p id="ed79" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">屏幕缓冲区是一个预先分配和初始化的80x25字符的固定内存缓冲区。<em class="km"> getScreenBuffer </em>操作应该是内存访问安全的。<em class="km">按键</em>操作将单个<em class="km">字符</em>推送到流氓线程，也应该是安全的原子操作。</p><h1 id="ca97" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">快速回顾</h1><p id="3d48" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">我们已经完成了以下工作:</p><ol class=""><li id="d51a" class="ly lz iq jp b jq jr ju jv jy ma kc mb kg mc kk md me mf mg bi translated">编译两个第三方库Rogue-5.4，和PD curses-3.4；</li><li id="07bf" class="ly lz iq jp b jq mh ju mi jy mj kc mk kg ml kk md me mf mg bi translated">将这些库链接到我们的api库；</li><li id="9898" class="ly lz iq jp b jq mh ju mi jy mj kc mk kg ml kk md me mf mg bi translated">在PDCurses上添加实现来捕获屏幕上的字符，并模拟用户输入；</li><li id="45ae" class="ly lz iq jp b jq mh ju mi jy mj kc mk kg ml kk md me mf mg bi translated">增加Rogue和Flutter之间的通信方法；</li><li id="2e1e" class="ly lz iq jp b jq mh ju mi jy mj kc mk kg ml kk md me mf mg bi translated">使用<em class="km"> pthread </em>并行运行两个应用——Flutter和Rogue</li></ol><h1 id="0d1f" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated"><strong class="ak">在Flutter上构建渲染器</strong></h1><p id="ee3a" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">一个非常基本的渲染器可以在几分钟内完成:</p><pre class="lr ls lt lu gt mt mu mv mw aw mx bi"><span id="5d7d" class="my ko iq mu b gy mz na l nb nc">1. // query the PDCurses buffer</span><span id="93b9" class="my ko iq mu b gy nu na l nb nc">buffer = FFIBridge.getScreenBuffer();</span><span id="5025" class="my ko iq mu b gy nu na l nb nc">2. // loop through the buffer and display character by character</span><span id="7004" class="my ko iq mu b gy nu na l nb nc">for(int row=0; row&lt;25; row++) {<br/>   for(int col=0; col&lt;25; col++) { <br/>      drawCharacter(row, col, character: buffer[row*80 + col]);<br/>   }<br/>}</span></pre><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="nw nx di ny bf nz"><div class="gh gi nv"><img src="../Images/f1e14a433136c3e35eb1b0a7178bad63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b30HWEGuWdbvJPiKqc4COg.png"/></div></div></figure><p id="fc3d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面的实现简单地使用了一个组合了<em class="km">列、行和文本</em>的小部件。</p><p id="1375" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于用户输入，我们将监听<em class="km"> onKey </em>事件，并将输入传递给我们的本地库:</p><pre class="lr ls lt lu gt mt mu mv mw aw mx bi"><span id="c641" class="my ko iq mu b gy mz na l nb nc"><em class="km">onKey</em>: (FocusNode <em class="km">node</em>, RawKeyEvent <em class="km">event</em>) {<br/>    FIBridge.pushString(event.keyLabel);<br/>}</span></pre><p id="20bc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在Android上我们添加了一个不可见的<em class="km">TextField；</em>给它焦点来激活虚拟键盘；并且同样听取关键事件。</p><p id="9277" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">没有太多的调整现有的流氓应用程序，我们有一个游戏，可在Linux和Android上运行。</p><h1 id="a3e9" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">流氓闪亮的新图形</h1><p id="46fa" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated"><em class="km">进入下一关……</em></p><p id="750e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">流氓游戏屏幕有三个部分。这是地牢的地图<em class="km">和</em>。墙壁用“-”、“|”表示，路径用“#”表示，英雄用“@”表示。一切都是性格。</p><p id="49d5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">底部有<em class="km">统计</em>行，显示生命、黄金、地下城等级。</p><p id="a634" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">还有一个<em class="km">消息</em>行，告诉游戏的事件，或者提示输入。</p><p id="4686" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将分别呈现这些部分。</p><p id="c018" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用正则表达式可以分解<em class="km"> stats </em>行。然后，我们可以用样式化的文本或图形分别呈现每个状态项。</p><pre class="lr ls lt lu gt mt mu mv mw aw mx bi"><span id="f9bb" class="my ko iq mu b gy mz na l nb nc">// parse status "Level: 1  Gold: 0      Hp: 12(12)  Str: 16(16)  Arm: 4   Exp: 1/0"</span><span id="14da" class="my ko iq mu b gy nu na l nb nc">String status = getLine(23);<br/>RegExp regExp = RegExp(r"(([a-zA-Z]{0,9}):\s{0,8}([0-9()/]{0,9}))")</span><span id="f549" class="my ko iq mu b gy nu na l nb nc">res = regExp.matchAll(status);</span><span id="fab7" class="my ko iq mu b gy nu na l nb nc">drawStats(res)</span></pre><p id="f77c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">并且地图可以简单地通过将每个字符映射到其自己的颜色或效果来着色:</p><pre class="lr ls lt lu gt mt mu mv mw aw mx bi"><span id="1aa4" class="my ko iq mu b gy mz na l nb nc">colorMap['^'] = const Color.fromRGBO(0x50, 0xff, 0x55, 1);<br/>colorMap['%'] = const Color.fromRGBO(0x50, 0xff, 0x55, 1);<br/>colorMap['+'] = Colors.orange;<br/>colorMap['@'] = const Color.fromRGBO(0xff, 0xff, 0xaa, 1);<br/>...</span><span id="55df" class="my ko iq mu b gy nu na l nb nc">drawCharacter(row, col, character: c, color: colorMap[c]);</span></pre><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="nw nx di ny bf nz"><div class="gh gi oa"><img src="../Images/c296560ff6c70492d37a06afb9b0303b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0kDKfhsqlkj0WKNNzWyb2Q.png"/></div></div></figure><h2 id="d2f3" class="my ko iq bd kp ni nj dn kt nk nl dp kx jy nm nn lb kc no np lf kg nq nr lj ns bi translated">进一步下降…</h2><p id="e09e" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">我们也可以用图像或精灵在地图上绘制角色:</p><pre class="lr ls lt lu gt mt mu mv mw aw mx bi"><span id="e462" class="my ko iq mu b gy mz na l nb nc">tilesetMap[':'] = Sprite('food.png'); // food<br/>tilesetMap['!'] = Sprite('potion.png'); // potion</span><span id="a716" class="my ko iq mu b gy nu na l nb nc">...</span><span id="da9b" class="my ko iq mu b gy nu na l nb nc">drawCharacter(row, col, image: tilesetMap[c]);</span></pre><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="nw nx di ny bf nz"><div class="gh gi nv"><img src="../Images/649e7393edbee18c0809a92a3a48e66d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9COzKJuYyU6dyw-i6BqceQ.png"/></div></div></figure><p id="d744" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">图形现代化。</p><h1 id="d3eb" class="kn ko iq bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk bi translated">挑战完成</h1><p id="12cd" class="pw-post-body-paragraph jn jo iq jp b jq ll js jt ju lm jw jx jy ln ka kb kc lo ke kf kg lp ki kj kk ij bi translated">我们已经成功地将经典的地牢爬行游戏Rogue 5.4移植到Flutter和Android上，而没有重写游戏本身的任何重要部分。</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/a85e86b85a2992862fc3cfa275752baa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/format:webp/1*xGi9nZ5ftc1kMxlp9V-ENA.jpeg"/></div><figcaption class="oc od gj gh gi oe of bd b be z dk translated">Android上的应用程序</figcaption></figure><pre class="lr ls lt lu gt mt mu mv mw aw mx bi"><span id="640e" class="my ko iq mu b gy mz na l nb nc">git clone <a class="ae kl" href="https://github.com/icedman/rogue_flutter" rel="noopener ugc nofollow" target="_blank">https://github.com/icedman/rogue_flutte</a>r<br/>cd rogue_flutter<br/>flutter pub get<br/>flutter run -v</span></pre></div><div class="ab cl mm mn hu mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ij ik il im in"><p id="7a74" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个github项目包含我没有讨论过的代码:一个Spritesheet类和使用<em class="km"> CustomPainter </em>的渲染器，带有工具栏和虚拟键盘的输入类。我倾向于把事情看得过于简单。但是颤振方面只有900行左右的代码。PDCurses实现大约有500行。这些代码值得一读。</p></div><div class="ab cl mm mn hu mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ij ik il im in"><p id="24c3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这款应用有出版价值之前，还有很多润色工作要做。所以挑战并没有真正结束。但是就像在《侠盗猎车手》游戏中一样，穿越地下城的旅程和完成寻找难以捉摸的延多护身符一样重要。</p></div></div>    
</body>
</html>