<html>
<head>
<title>Learn Angular Component Design Patterns — Creating a Drawer Component</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习角度组件设计模式—创建抽屉组件</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/learn-angular-component-design-patterns-creating-a-drawer-component-c31c3244c974?source=collection_archive---------6-----------------------#2021-03-22">https://levelup.gitconnected.com/learn-angular-component-design-patterns-creating-a-drawer-component-c31c3244c974?source=collection_archive---------6-----------------------#2021-03-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="89bb" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">因为简单的重构不会伤害任何人！</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e0d9ed5f575db52152281c173eaabb97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TILQtPoE1BimH1bDft1Czw.jpeg"/></div></div></figure><p id="7ba9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个故事最初发表在《深度》杂志上:</p><div class="ln lo gp gr lp lq"><a href="https://indepth.dev/posts/1439/learn-angular-component-design-patterns-creating-a-drawer-component-2" rel="noopener  ugc nofollow" target="_blank"><div class="lr ab fo"><div class="ls ab lt cl cj lu"><h2 class="bd ir gy z fp lv fr fs lw fu fw ip bi translated">学习角度组件设计模式——创建抽屉组件——角度深度</h2><div class="lx l"><h3 class="bd b gy z fp lv fr fs lw fu fw dk translated">我一直告诉人们Angular比youtube教的更有力量。学习设计模式将有助于…</h3></div><div class="ly l"><p class="bd b dl z fp lv fr fs lw fu fw dk translated">深度开发</p></div></div><div class="lz l"><div class="ma l mb mc md lz me kp lq"/></div></div></a></div><blockquote class="mf"><p id="9a41" class="mg mh iq bd mi mj mk ml mm mn mo lm dk translated">“重复是所有软件罪恶的根源”——马丁·福勒</p></blockquote><p id="7a1a" class="pw-post-body-paragraph kr ks iq kt b ku mp jr kw kx mq ju kz la mr lc ld le ms lg lh li mt lk ll lm ij bi mu translated">我一直对人们说，Angular比youtube上教的更有力量。Angular提供了强大的模式和工具来创建高度可伸缩、结构化和可维护的web应用程序。</p><p id="a451" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">学习时很容易错过这些模式，因为大多数教程似乎忽略了高级概念。</p><p id="7898" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">本文将尝试创建一个简单的抽屉组件，使它更加灵活和可重用，逐版本。我们的目标不是创建一个完美的抽屉组件，而是学习可以</p><h1 id="297e" class="nd ne iq bd nf ng nh ni nj nk nl nm nn jw no jx np jz nq ka nr kc ns kd nt nu bi translated">角组件设计模式</h1><p id="5263" class="pw-post-body-paragraph kr ks iq kt b ku nv jr kw kx nw ju kz la nx lc ld le ny lg lh li nz lk ll lm ij bi translated">不久前，我写了一篇关于材料组件的角度组件设计模式的文章，其中我讨论了组件设计，在素材库中做出的决定，以及我们如何在我们的项目中得到同样的启发。本文将是相同的实现，我们创建一个自定义的侧抽屉组件，并使用多种设计模式解决方案来完善实现，这将为我们提供吃和干净的解决方案。</p><p id="1b7e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们的最终结果应该看起来像是媒体弹出来显示对一篇文章的回应。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/6129692a8cfe482e698e2f549085fa43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*SvqJzjAywq_4Q6oR8bgtug.gif"/></div></div></figure><p id="2b06" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在我们知道我们需要什么了，让我们开始吧！</p><h1 id="59b2" class="nd ne iq bd nf ng nh ni nj nk nl nm nn jw no jx np jz nq ka nr kc ns kd nt nu bi translated">它是如何开始的— v1</h1><p id="f75b" class="pw-post-body-paragraph kr ks iq kt b ku nv jr kw kx nw ju kz la nx lc ld le ny lg lh li nz lk ll lm ij bi translated">对于最初的实现，让我们遵循这种方法</p><ol class=""><li id="4831" class="oc od iq kt b ku kv kx ky la oe le of li og lm oh oi oj ok bi translated">为抽屉创建一个组件(comment-drawer.component)。</li><li id="88b6" class="oc od iq kt b ku ol kx om la on le oo li op lm oh oi oj ok bi translated">使用<code class="fe oq or os ot b">@Input</code>控制为<code class="fe oq or os ot b">isOpen</code>状态。</li><li id="e914" class="oc od iq kt b ku ol kx om la on le oo li op lm oh oi oj ok bi translated">动态更新<code class="fe oq or os ot b">left</code> CSS属性来打开/关闭抽屉。</li><li id="4c52" class="oc od iq kt b ku ol kx om la on le oo li op lm oh oi oj ok bi translated">使用<code class="fe oq or os ot b">@Output</code>通知抽屉何时关闭。</li></ol><p id="b99a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">直来直去就这么简单！</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ou ov l"/></div></figure><p id="95ef" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们使用样式绑定来控制元素的<code class="fe oq or os ot b">right</code>属性。打开(<code class="fe oq or os ot b">isOpen == true</code>)时，元件位于<code class="fe oq or os ot b">right:0</code>，否则位于<code class="fe oq or os ot b">-400px</code>(元件宽度)。</p><p id="7652" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有了这几行CSS代码，这是实现侧边栏或抽屉的一种非常经典的方式。</p><p id="3001" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们的组件类可以简单地是，</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ou ov l"/></div></figure><p id="12ed" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后在父组件中，我们可以继续使用我们的抽屉组件，</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ou ov l"/></div></figure><p id="9c11" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们得到了一个非常好用的解决方案。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ow"><img src="../Images/159fcadf58e72e849b9bd65f64c6f7e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*gWk9gdcI3LoxizziHJ3uXw.gif"/></div></div><figcaption class="ox oy gj gh gi oz pa bd b be z dk translated">v1输出</figcaption></figure><p id="5fe0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">哇，看起来真不错！</p><p id="fd82" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">是吗？</p><h1 id="732a" class="nd ne iq bd nf ng nh ni nj nk nl nm nn jw no jx np jz nq ka nr kc ns kd nt nu bi translated">更上一层楼— v2</h1><p id="f293" class="pw-post-body-paragraph kr ks iq kt b ku nv jr kw kx nw ju kz la nx lc ld le ny lg lh li nz lk ll lm ij bi translated">现在，假设我们必须在应用程序的其他部分实现相同的行为。要显示用户数据，比如说。</p><p id="00fd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当前的实施已经就绪，您将如何着手实施？</p><p id="7b7b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们必须创建一个新组件，将所有内容复制到该组件并引导它。</p><p id="0eb3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">还有，如果你需要另一个从左边打开的抽屉呢？</p><p id="64f3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在实践中，<a class="ae oa" rel="noopener ugc nofollow" target="_blank" href="/mistakes-i-made-as-an-angular-developer-509277d60a10?gi=b8a01d51d03f">我们将重复刚刚做过的一切</a>。</p><p id="10c1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">而且我们都知道复制粘贴同样的代码是一个<strong class="kt ir">大</strong>小<strong class="kt ir">不</strong>！</p><p id="1351" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在让我们想出另一种方法，将上面的组件重构为一个更灵活和可重用的组件。</p><p id="f2e7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们将遵循下面的方法。</p><ol class=""><li id="5414" class="oc od iq kt b ku kv kx ky la oe le of li og lm oh oi oj ok bi translated">为抽屉创建一个包装组件(drawer.component)</li><li id="f2d4" class="oc od iq kt b ku ol kx om la on le oo li op lm oh oi oj ok bi translated">将打开、关闭的逻辑移动到包装组件</li><li id="83dc" class="oc od iq kt b ku ol kx om la on le oo li op lm oh oi oj ok bi translated">让<code class="fe oq or os ot b">comment-drawer.component</code>在内部使用<code class="fe oq or os ot b">drawer.component</code>,并将内容(评论)传递给它。</li></ol><p id="4464" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这听起来不舒服吗？让我们写一些代码。</p><p id="c672" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们的<code class="fe oq or os ot b">drawer.component</code>模板将简单地投影(使用内容投影)传递给它的模板。它还会有一个关闭触发<code class="fe oq or os ot b">onDrawerClose()</code>的窗格的图标，这样家长就可以在需要时听取和执行操作。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ou ov l"/></div></figure><p id="2a2b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">该组件接受几个输入并发出<code class="fe oq or os ot b">drawerClosed()</code>事件。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ou ov l"/></div></figure><p id="3f15" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">上面的<code class="fe oq or os ot b">position</code>属性指的是抽屉打开的那一面。默认情况下，它从右端打开，如上面的演示视频所示。</p><p id="264b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们现在可以利用输入并将样式传递给<code class="fe oq or os ot b">.drawer-container</code>,</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ou ov l"/></div></figure><p id="1ccd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">getter <code class="fe oq or os ot b">drawerStyles</code>将有条件地将样式传递给模板，</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ou ov l"/></div></figure><p id="745f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们的包装组件(抽屉组件)现在已经准备好了。现在让我们修改<code class="fe oq or os ot b">comment-drawer.component</code>来使用这个包装器。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ou ov l"/></div></figure><p id="675b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">v2现在已经准备好了！</p><p id="b6d1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您可以验证重构对screenreader没有任何影响，但使开发人员将来可以在应用程序中的任何地方插入抽屉，并使其快速工作。</p><blockquote class="pb pc pd"><p id="6ec9" class="kr ks pe kt b ku kv jr kw kx ky ju kz pf lb lc ld pg lf lg lh ph lj lk ll lm ij bi translated"><strong class="kt ir">提示:</strong>您可能希望将您的打开/关闭逻辑转移到一个具有可观察性的服务中。你可以去我的<a class="ae oa" href="https://medium.com/dev-hub/how-i-added-dark-mode-in-my-personal-blog-with-angular-css-variables-and-rxjs-a62056c52e16" rel="noopener">黑暗模式的文章中寻找灵感。</a></p></blockquote><p id="8726" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">呜！那现在已经是一大步了！</p><h1 id="1b3d" class="nd ne iq bd nf ng nh ni nj nk nl nm nn jw no jx np jz nq ka nr kc ns kd nt nu bi translated">多内容投影，实现更好的控制- v3</h1><p id="8756" class="pw-post-body-paragraph kr ks iq kt b ku nv jr kw kx nw ju kz la nx lc ld le ny lg lh li nz lk ll lm ij bi translated">我们先别停下来。</p><p id="3149" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们已经在利用上面的<strong class="kt ir">内容投影</strong>。让我们继续前进。让我们实现<strong class="kt ir">多重内容投影</strong>。对于多内容投影来说，这可能不是最好的场景，但是学习一些新的东西也无妨！</p><p id="e5f3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">多内容投影</strong>，顾名思义，就是从用户(父)向组件投影多个模板的技术。基本上，我们不是一次投射两者之间的所有内容，而是一点一点地投射内容。在我们的例子中，我们将有两块；一份给出票人<code class="fe oq or os ot b">header</code>，一份给出票人<code class="fe oq or os ot b">body</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ou ov l"/></div></figure><p id="b586" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe oq or os ot b">select</code>属性用于将正确的内容挑选到正确的占位符中。</p><p id="c34f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">实际上，我们将投影内容分为<code class="fe oq or os ot b">header</code>和<code class="fe oq or os ot b">body</code>。</p><p id="9aca" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，对于用户来说，</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ou ov l"/></div></figure><blockquote class="pb pc pd"><p id="b7bc" class="kr ks pe kt b ku kv jr kw kx ky ju kz pf lb lc ld pg lf lg lh ph lj lk ll lm ij bi translated"><strong class="kt ir">提示:</strong>上面的<code class="fe oq or os ot b">selector</code>是指CSS选择器。任何有效的CSS选择器在这里都有效。您可能已经注意到，在上面的例子中，我使用了带有方括号语法的属性选择器。</p></blockquote><p id="3961" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">那么，我们为什么要这么做？</p><p id="a924" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">v2的一个不好的方面是任何内容都可以被投影到抽屉中。这种自由会导致对内容的控制减少。在v3中，我们明确表示抽屉可以有一个<code class="fe oq or os ot b">header</code>和一个<code class="fe oq or os ot b">body</code>，甚至可以提供基本的样式，这样用户就不会把它弄乱了。</p><h1 id="b40f" class="nd ne iq bd nf ng nh ni nj nk nl nm nn jw no jx np jz nq ka nr kc ns kd nt nu bi translated"><code class="fe oq or os ot b">'exportAs’</code>灵活性属性— v4</h1><p id="c04f" class="pw-post-body-paragraph kr ks iq kt b ku nv jr kw kx nw ju kz la nx lc ld le ny lg lh li nz lk ll lm ij bi translated">我们当前实现的一个主要限制是，我们无法从外部提供关闭按钮。但是在应用程序的某些部分，我们可能需要将关闭按钮和标题一起投影。或者可能需要不同的关闭按钮样式。</p><p id="89c7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们怎么做呢？</p><p id="d780" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一种方法是在用户(<code class="fe oq or os ot b">comment-drawer.component</code>)中使用<code class="fe oq or os ot b">@ViewChild</code>并显式调用<code class="fe oq or os ot b">onDrawerClose()</code>。这可能导致更多的样板代码。</p><p id="262f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这就是<code class="fe oq or os ot b">exportAs</code>可以帮忙的地方。</p><p id="1269" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">角度组件元数据有一个名为<code class="fe oq or os ot b">exportAs</code>的属性。<code class="fe oq or os ot b">exportAs</code>属性采用组件实例在模板中导出时使用的名称。</p><p id="4691" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您可以把它想象成一个引用模板中组件的变量。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ou ov l"/></div></figure><p id="3348" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们现在可以去掉<code class="fe oq or os ot b">drawer.component</code>中僵硬的关闭按钮，</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ou ov l"/></div></figure><p id="dddf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">很美，你不觉得吗？</p><h1 id="c199" class="nd ne iq bd nf ng nh ni nj nk nl nm nn jw no jx np jz nq ka nr kc ns kd nt nu bi translated">面向性能的延迟加载— v5</h1><p id="449d" class="pw-post-body-paragraph kr ks iq kt b ku nv jr kw kx nw ju kz la nx lc ld le ny lg lh li nz lk ll lm ij bi translated">每当你创建一个想要重用的组件时(顺便说一下，每个组件都必须是想要重用的！)，您应该向您的应用程序提出这些问题</p><p id="3b76" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">在页面初始加载的时候一定要渲染这个组件吗？它里面的信息在初始加载的时候呈现是至关重要的吗？</strong></p><p id="ad30" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您的答案是否定的或者可能的，那么您应该考虑延迟加载组件。因为否则，我们会增加浏览器的开销，使我们的应用程序更慢更笨拙。</p><p id="e7d7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您可能会想，<code class="fe oq or os ot b">body</code>中的一个无害文本会导致什么样的开销。现在，假设您的抽屉正在向服务器发出API请求，以获取所有的注释。额外的API调用将在初始加载时触发，导致页面加载缓慢，但对屏幕阅读器没有任何价值！</p><p id="b58e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">是的，这是一个很好的惰性加载组件的用例。我们需要告诉Angular在抽屉打开之前不要加载任何内容。</p><p id="2f32" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你对这里的实施有什么初步想法？</p><p id="3170" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一个简单的实现方案是在<code class="fe oq or os ot b">drawer.component</code>中结合使用<code class="fe oq or os ot b">isOpen</code>和<code class="fe oq or os ot b">*ngIf</code>，以确保在抽屉打开之前，主体不会被渲染。</p><p id="74eb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是如果您需要更高级的条件延迟加载呢？可能是部件上的零件？上面的方法很容易变得混乱。</p><p id="6540" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我已经在下面的文章中详细讨论了延迟加载组件，同样的技术也可以应用到这里，让你的抽屉组件更有性能！</p><div class="ln lo gp gr lp lq"><a href="https://medium.com/better-programming/why-and-how-to-lazy-load-components-in-angular-b4aff3797c6d" rel="noopener follow" target="_blank"><div class="lr ab fo"><div class="ls ab lt cl cj lu"><h2 class="bd ir gy z fp lv fr fs lw fu fw ip bi translated">为什么以及如何在Angular中延迟加载组件</h2><div class="lx l"><h3 class="bd b gy z fp lv fr fs lw fu fw dk translated">创建一个可重用的Angular accordion组件并延迟加载其内容</h3></div><div class="ly l"><p class="bd b dl z fp lv fr fs lw fu fw dk translated">medium.com</p></div></div><div class="lz l"><div class="pi l mb mc md lz me kp lq"/></div></div></a></div><h1 id="aa82" class="nd ne iq bd nf ng nh ni nj nk nl nm nn jw no jx np jz nq ka nr kc ns kd nt nu bi translated">CSS变量的魔力— v6</h1><p id="8177" class="pw-post-body-paragraph kr ks iq kt b ku nv jr kw kx nw ju kz la nx lc ld le ny lg lh li nz lk ll lm ij bi translated">这可能会让你大吃一惊。您知道可以使用样式绑定来绑定元素的CSS属性吗？</p><p id="4ecf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">好的，坚持住。</p><p id="c1ab" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们现在应用样式的方式是通过抽屉组件中的getter。这个管用。但是控制器中有许多代码和条件，只是为了让样式有条件地应用。有没有更好的，本土的方式？</p><p id="8ffb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">原来，是有的！</p><p id="848d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">计划是这样的</p><p id="4a5a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们将通过绑定到抽屉组件的属性来传递我们的<code class="fe oq or os ot b">width</code>属性。然后我们使用类绑定来确定，</p><ol class=""><li id="08fc" class="oc od iq kt b ku kv kx ky la oe le of li og lm oh oi oj ok bi translated">抽屉是否打开，使用<code class="fe oq or os ot b">isOpen</code>属性</li><li id="9db2" class="oc od iq kt b ku ol kx om la on le oo li op lm oh oi oj ok bi translated">如果打开，使用<code class="fe oq or os ot b">position</code>属性确定是从左边还是右边打开</li></ol><p id="1c09" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这种方法也意味着我们不再需要传递<code class="fe oq or os ot b">width</code>作为输入属性。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ou ov l"/></div></figure><p id="0f5f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们将类<code class="fe oq or os ot b">is-open</code>、<code class="fe oq or os ot b">position-left</code>、<code class="fe oq or os ot b">position-right</code>绑定到容器。注意，我们不再有<code class="fe oq or os ot b">ngStyle</code>绑定，条件getter也将随之消失。</p><p id="aa0b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">剩下的唯一工作就是实现上面的类。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ou ov l"/></div></figure><p id="1bee" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们使用<code class="fe oq or os ot b">:host</code>选择器定义了<code class="fe oq or os ot b">--drawer-width</code>,使其在组件样式表中全局可用。</p><p id="9f2e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">具有<code class="fe oq or os ot b">position-right</code>类的元素，在这种情况下，我们需要将<code class="fe oq or os ot b">right</code>属性设置到右端，以便抽屉保持不可见(这是必需的，因为我们正在使用transition)。当抽屉处于<code class="fe oq or os ot b">isOpen</code>状态时，让我们将<code class="fe oq or os ot b">right</code>属性设为<code class="fe oq or os ot b">0</code>，这样抽屉现在就可见了，并且将有一个平滑的动画入口。</p><p id="d875" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">上面的解释适用于放置在左边的元素和<code class="fe oq or os ot b">position-left</code>类。</p></div><div class="ab cl pj pk hu pl" role="separator"><span class="pm bw bk pn po pp"/><span class="pm bw bk pn po pp"/><span class="pm bw bk pn po"/></div><div class="ij ik il im in"><p id="b19b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们在这里结束它，尽管我们仍然可以对这个组件进行许多改进，使它更接近完美。</p></div></div>    
</body>
</html>