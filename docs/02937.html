<html>
<head>
<title>Omit Is Being Removed in Lodash 5</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Lodash 5中删除了省略</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/omit-is-being-removed-in-lodash-5-c1db1de61eaf?source=collection_archive---------5-----------------------#2020-04-11">https://levelup.gitconnected.com/omit-is-being-removed-in-lodash-5-c1db1de61eaf?source=collection_archive---------5-----------------------#2020-04-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="ee6b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">现在你可以使用一些替代方案来保持领先一步</h2></div><p id="8474" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">***感谢<a class="le lf ep" href="https://medium.com/u/90ddf2f59e02?source=post_page-----c1db1de61eaf--------------------------------" rel="noopener" target="_blank"> tzar </a>指出我的ES6 + Lodash unset方法的一个bug。如果该选项用于展平路径，即<code class="fe lg lh li lj b">level1prop.level2prop</code>，你将<strong class="kk iu">结束修改你的原始对象。</strong>我将它留在这里，作为ES2019的一个更快的替代方案，用于多个属性，但我不建议将其用于扁平化属性。***</p><p id="75f2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">超受欢迎的JavaScript实用程序库Lodash ，由于性能不佳，已经决定移除它那非常方便的<code class="fe lg lh li lj b"><a class="ae lk" href="https://lodash.com/docs/4.17.15#omit" rel="noopener ugc nofollow" target="_blank">omit</a></code>函数。在本文中，我们来看看一些可以用来从对象中省略属性的替代方法。</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi ll"><img src="../Images/a96d98e25fd817a50faa6af9909c412a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4dOVeed9fV8PrW--"/></div></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk translated"><a class="ae lk" href="https://unsplash.com/@jeisblack?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Jason Blackeye </a>在<a class="ae lk" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="4256" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">什么是_。省略，我什么时候使用它？</h1><p id="863c" class="pw-post-body-paragraph ki kj it kk b kl mt ju kn ko mu jx kq kr mv kt ku kv mw kx ky kz mx lb lc ld im bi translated"><code class="fe lg lh li lj b"><a class="ae lk" href="https://lodash.com/docs/4.17.15#omit" rel="noopener ugc nofollow" target="_blank">Omit</a></code>是一个函数，它接受一个<code class="fe lg lh li lj b">object</code>作为输入，以及一个或多个属性名，这些属性名将从该函数返回的结果新对象中删除。</p><figure class="lm ln lo lp gt lq"><div class="bz fp l di"><div class="my mz l"/></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk translated">Lodash的省略函数的例子。请注意，原始对象不会改变。</figcaption></figure><h2 id="d03d" class="na mc it bd md nb nc dn mh nd ne dp ml kr nf ng mn kv nh ni mp kz nj nk mr nl bi translated">在什么情况下我需要这样的功能？</h2><p id="a04c" class="pw-post-body-paragraph ki kj it kk b kl mt ju kn ko mu jx kq kr mv kt ku kv mw kx ky kz mx lb lc ld im bi translated">这里列出的用例太多了，即使我知道所有的用例。但是我需要省略的一些原因是:</p><ul class=""><li id="bc9a" class="nm nn it kk b kl km ko kp kr no kv np kz nq ld nr ns nt nu bi translated">当一个API不需要，或者如果我包含了我的对象的所有属性，甚至可能会中断</li><li id="18b5" class="nm nn it kk b kl nv ko nw kr nx kv ny kz nz ld nr ns nt nu bi translated">当我插入一个数据库时，我希望数据库生成一个<code class="fe lg lh li lj b">ID</code>属性，但是它可能已经在代码中添加到我的对象中了</li><li id="76b8" class="nm nn it kk b kl nv ko nw kr nx kv ny kz nz ld nr ns nt nu bi translated">当我为了在UI上显示而添加属性，但想在提交给服务器之前再次删除它们时</li><li id="799c" class="nm nn it kk b kl nv ko nw kr nx kv ny kz nz ld nr ns nt nu bi translated">当用户提交了一个对象，但我希望服务器端代码覆盖某些属性时</li></ul><h1 id="90c1" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">为什么会被删除？</h1><p id="6c50" class="pw-post-body-paragraph ki kj it kk b kl mt ju kn ko mu jx kq kr mv kt ku kv mw kx ky kz mx lb lc ld im bi translated">诸如<a class="ae lk" href="https://react.semantic-ui.com/" rel="noopener ugc nofollow" target="_blank"> Semantic UI React </a>和<a class="ae lk" href="https://formidable.com/open-source/victory/" rel="noopener ugc nofollow" target="_blank"> Victory </a>之类的库注意到了由于使用Lodash的<code class="fe lg lh li lj b">omit</code>而导致的不良性能，其中Semantic UI React特别注意到在切换到原生替代品之后，UI组件呈现时间大约有<strong class="kk iu"> 12，000倍</strong> <strong class="kk iu">的改进</strong>。</p><p id="5452" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于这些原因，作出了<a class="ae lk" href="https://github.com/lodash/lodash/issues/2930#issuecomment-370295020" rel="noopener ugc nofollow" target="_blank">设计决定</a>以完全移除该功能。</p><p id="88bb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果像我一样，您已经使用<code class="fe lg lh li lj b">omit</code>从现有对象创建了部分对象，请继续阅读，查看一些替代方案。</p><h1 id="626b" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">有哪些替代方案？</h1><p id="fe93" class="pw-post-body-paragraph ki kj it kk b kl mt ju kn ko mu jx kq kr mv kt ku kv mw kx ky kz mx lb lc ld im bi translated">Lodash的<code class="fe lg lh li lj b"><a class="ae lk" href="https://lodash.com/docs/4.17.15#omit" rel="noopener ugc nofollow" target="_blank">omit</a></code>函数有很多替代方法，我将讨论使用不同Lodash函数的选项，以及一些本地替代方法。</p><h2 id="d10f" class="na mc it bd md nb nc dn mh nd ne dp ml kr nf ng mn kv nh ni mp kz nj nk mr nl bi translated">本地替代品</h2><p id="befe" class="pw-post-body-paragraph ki kj it kk b kl mt ju kn ko mu jx kq kr mv kt ku kv mw kx ky kz mx lb lc ld im bi translated">第一个是ES6原生JavaScript函数，它使用<a class="ae lk" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment" rel="noopener ugc nofollow" target="_blank">析构</a>来移除<em class="oa">单个</em>属性:</p><figure class="lm ln lo lp gt lq"><div class="bz fp l di"><div class="my mz l"/></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk translated">Lodash omit的替代方法，它允许您忽略单个属性。</figcaption></figure><p id="e12c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">注默认</strong> <code class="fe lg lh li lj b"><strong class="kk iu">{}</strong></code> <strong class="kk iu">关于我们对象的论证。这是必要的，以防止错误，如果我们在这里传入未定义。</strong></p><p id="d929" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来是一个<em class="oa">几乎</em>与Lodash的<code class="fe lg lh li lj b">omit</code>功能完全匹配的功能，因为它允许您指定任意数量的要删除的属性:</p><figure class="lm ln lo lp gt lq"><div class="bz fp l di"><div class="my mz l"/></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk translated">一个本机省略函数，允许您指定要省略的多个属性。</figcaption></figure><p id="b28a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不幸的是，正如我们所见，<code class="fe lg lh li lj b">data.some</code>的“平坦路径”没有被移除，就像Lodash的<code class="fe lg lh li lj b">omit</code>一样。</p></div><div class="ab cl ob oc hx od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="im in io ip iq"><p id="ae4a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后一个本机替代方法也不支持省略展平路径，但它是省略多个顶级属性的最快方法。看起来是这样的:</p><figure class="lm ln lo lp gt lq"><div class="bz fp l di"><div class="my mz l"/></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk translated">仅在顶层支持省略多个属性</figcaption></figure><p id="1829" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我们将在最新的基准测试中看到的，这是迄今为止省略多个顶级属性的最快方法。</p><h2 id="da6d" class="na mc it bd md nb nc dn mh nd ne dp ml kr nf ng mn kv nh ni mp kz nj nk mr nl bi translated">Lodash替代品——仍然是平坦道路的王者</h2><p id="6382" class="pw-post-body-paragraph ki kj it kk b kl mt ju kn ko mu jx kq kr mv kt ku kv mw kx ky kz mx lb lc ld im bi translated">从上面我们可以看到，<code class="fe lg lh li lj b">data</code>子对象中的<code class="fe lg lh li lj b">some</code>属性没有被移除。这就是这些本地函数和Lodash的<code class="fe lg lh li lj b">omit</code>的区别。</p><blockquote class="oi oj ok"><p id="cfff" class="ki kj oa kk b kl km ju kn ko kp jx kq ol ks kt ku om kw kx ky on la lb lc ld im bi translated">Lodash虽然速度较慢，但允许为省略提供扁平的属性路径</p></blockquote><p id="b79c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是，如果Lodash正在扼杀<code class="fe lg lh li lj b">omit</code>，我们如何仍然可以使用它来执行相同的功能？</p><p id="38cd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">根据<a class="ae lk" href="https://github.com/lodash/lodash/issues/2930#issuecomment-272298477" rel="noopener ugc nofollow" target="_blank">这个线程</a>，Lodash的创建者<a class="ae lk" href="https://github.com/jdalton" rel="noopener ugc nofollow" target="_blank"> jdalton </a>推荐使用<code class="fe lg lh li lj b"><a class="ae lk" href="https://lodash.com/docs/4.17.15#pick" rel="noopener ugc nofollow" target="_blank">pick</a></code>或<code class="fe lg lh li lj b"><a class="ae lk" href="https://lodash.com/docs/4.17.15#pickBy" rel="noopener ugc nofollow" target="_blank">pickBy</a></code>代替。他认为，指定一个你想保留的变量的白名单比把你不需要的变量列入黑名单更明确。因此对于<code class="fe lg lh li lj b">pick</code>，我们将使用以下内容:</p><p id="1b9a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">洛达什“挑选”</strong></p><figure class="lm ln lo lp gt lq"><div class="bz fp l di"><div class="my mz l"/></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk translated">使用“pick”来明确选择我们想要保留的属性，而不是扔掉我们不想要的属性。</figcaption></figure><p id="9c8c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这可能适用于小对象，或者当我们只想选择几个属性时，但是如果我们只想从一个大对象中省略一小部分属性，这可能会很麻烦。</p><p id="99a8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们来看看如何使用Lodash的<code class="fe lg lh li lj b">pickBy</code>函数。</p><p id="a7df" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">洛达什“匹克比”</strong></p><figure class="lm ln lo lp gt lq"><div class="bz fp l di"><div class="my mz l"/></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk translated">使用Lodash pickBy省略多个路径，但不支持展平路径</figcaption></figure><p id="28e7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面已经成功地从我们的对象中移除了我们的<code class="fe lg lh li lj b">_id</code>属性，但是同样，这里不支持<strong class="kk iu">而不是<em class="oa"> </em> </strong>展平的路径。</p><p id="43fe" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一个选择是使用<code class="fe lg lh li lj b">ES6</code> <code class="fe lg lh li lj b"><a class="ae lk" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters" rel="noopener ugc nofollow" target="_blank">rest</a></code>操作符克隆对象，并使用Lodash <code class="fe lg lh li lj b">unset</code>来省略展平路径。这个方法的问题是我们不执行深度复制，所以当使用展平路径时，我们也会修改我们的原始对象。</p><p id="e516" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">ES6“rest”、“forEach”和Lodash“unset”</strong></p><figure class="lm ln lo lp gt lq"><div class="bz fp l di"><div class="my mz l"/></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk translated">使用ES6 rest、forEach和Lodash取消设置来省略多个展平路径</figcaption></figure><p id="a862" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以上允许我们模仿<code class="fe lg lh li lj b">omit</code>的功能，<strong class="kk iu">除了它修改你的原始对象，如果使用展平路径，</strong>，即<code class="fe lg lh li lj b">data.some</code>。</p><p id="4bc5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我建议只使用它来删除非平坦路径。</p></div><div class="ab cl ob oc hx od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="im in io ip iq"><p id="9841" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">Lodash“cloneDeep”、“for… of”和Lodash“unset”</strong></p><p id="3286" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">真正匹配Lodash <code class="fe lg lh li lj b">omit's</code>功能的一个选项是使用对象自己的<code class="fe lg lh li lj b">cloneDeep</code>函数执行对象的深度克隆。正如我们将在下面看到的，这将大大降低函数的运行速度。此外，物体越大越复杂，速度越慢。</p><p id="59b0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该函数如下所示:</p><figure class="lm ln lo lp gt lq"><div class="bz fp l di"><div class="my mz l"/></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk translated">允许省略展平路径，并且不修改我们的原始对象，但是太慢了(详见基准测试部分)</figcaption></figure><p id="4319" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">复制Lodash omit的源代码</strong></p><p id="a33a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们需要省略展平路径<em class="oa">并且</em>不修改我们的原始对象，我们最后也是最好的选择是简单地复制Lodash <code class="fe lg lh li lj b">omit</code>的<a class="ae lk" href="https://github.com/lodash/lodash/blob/npm/omit.js" rel="noopener ugc nofollow" target="_blank">源代码</a>。</p></div><div class="ab cl ob oc hx od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="im in io ip iq"><h1 id="4dd6" class="mb mc it bd md me oo mg mh mi op mk ml jz oq ka mn kc or kd mp kf os kg mr ms bi translated">基准—原始结果(已过时)</h1><p id="e718" class="pw-post-body-paragraph ki kj it kk b kl mt ju kn ko mu jx kq kr mv kt ku kv mw kx ky kz mx lb lc ld im bi translated">如果您要在大型对象上执行许多这样的操作，那么明智的做法可能是查看每种替代方法的执行情况。我使用j <a class="ae lk" href="https://jsbench.me/" rel="noopener ugc nofollow" target="_blank"> sbench.me </a>和下面的大(&gt; 100kb)对象比较了三个可以删除多个属性的函数:</p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi ot"><img src="../Images/a6db8e32ee28d7afad670b2dbaa10d18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VwwYzdB_Ew6Z_AN-rkQ1KA.png"/></div></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk translated">我们提出的三个多属性省略函数与Lodash省略函数的性能比较</figcaption></figure><p id="9614" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我们所见——正如我们所料——与<code class="fe lg lh li lj b">Lodash pickBy</code>选项相比，<code class="fe lg lh li lj b">ES2019 Pure</code>功能领先于其他功能，非常显著。</p><p id="3658" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以放弃<code class="fe lg lh li lj b">pickBy</code>选项，因为它太慢并且没有任何好处。</p><p id="97e7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一方面，<code class="fe lg lh li lj b">ES6 and Lodash unset</code>函数紧随其后，它允许使用指定平坦路径，如<code class="fe lg lh li lj b">data.some</code>。如果您需要该功能，可能值得考虑。</p><p id="407a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样值得注意的是，<code class="fe lg lh li lj b">ES6 and Lodash unset</code>函数比<code class="fe lg lh li lj b">Lodash omit</code>快得多，这可能表明<code class="fe lg lh li lj b">Lodash omit</code>比我们的<code class="fe lg lh li lj b">unset</code>函数做得更多，或者它的实现不是最优的。</p><p id="9338" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，我将测试两个性能最好的函数，但是<strong class="kk iu">不支持省略展平路径吗:</strong></p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi ou"><img src="../Images/10fd0e992814ce31728acf7815e1b4d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RKW3zB-f5Xpo7m0toMaXSA.png"/></div></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk translated">ES6 Rest单属性省略与支持多属性省略的ES2019函数省略单个属性</figcaption></figure><p id="488d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的结果表明，如果我们可能需要这个功能，保留我们的单属性省略<code class="fe lg lh li lj b">ES6 Rest</code>函数是值得的。</p><blockquote class="oi oj ok"><p id="a583" class="ki kj oa kk b kl km ju kn ko kp jx kq ol ks kt ku om kw kx ky on la lb lc ld im bi translated">Lodash的<code class="fe lg lh li lj b">omit</code>函数允许我们指定<code class="fe lg lh li lj b">flattened paths</code>，而我们的本地替代函数不允许。如果需要此功能，请保留您自己的代码版本，但当您的键没有嵌套时，请使用本机版本。</p></blockquote><h1 id="1669" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">新基准(2020年4月12日)</h1><p id="663b" class="pw-post-body-paragraph ki kj it kk b kl mt ju kn ko mu jx kq kr mv kt ku kv mw kx ky kz mx lb lc ld im bi translated">在尝试了一些其他选项后，我再次运行了多次测试，结果表明<code class="fe lg lh li lj b">ES6 Rest + Lodash unset</code>选项比<code class="fe lg lh li lj b">pure ES2019</code>实现要快得多。</p><p id="8ecf" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这再加上它允许您省略<code class="fe lg lh li lj b">flattened paths</code>的事实是一个巨大的惊喜，但是如果您不介意将<code class="fe lg lh li lj b">Lodash</code>导入到您的代码中，那么这个选项似乎是省略多个属性的好方法。</p><p id="8de7" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">更新:ES6 Rest + Lodash unset如果与展平路径一起使用，将修改您的原始对象。我将把这些基准留在这里，但是要小心使用。如果您不想修改原始对象，请使用替代方法。</strong></p><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi ov"><img src="../Images/424fee226ab4861145291c613e6394bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hpj_ULGTK11AF7PGOanOKA.png"/></div></div></figure></div><div class="ab cl ob oc hx od" role="separator"><span class="oe bw bk of og oh"/><span class="oe bw bk of og oh"/><span class="oe bw bk of og"/></div><div class="im in io ip iq"><h1 id="a968" class="mb mc it bd md me oo mg mh mi op mk ml jz oq ka mn kc or kd mp kf os kg mr ms bi translated">新基准(2020年4月18日)</h1><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi ow"><img src="../Images/26bbe9a3860d16bf96e9feeaa19f4a7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SNfaXNbo5A8g66QpjZC7hw.png"/></div></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk translated">ES2019与ES6 +删除多个属性</figcaption></figure><figure class="lm ln lo lp gt lq gh gi paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="gh gi ox"><img src="../Images/507c08b12a8c3e8feca2ab81e4634654.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IaV_SQZ2OQD__TjRRk9wPw.png"/></div></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk translated">Lodsah cloneDeep + unset对Lodash省略</figcaption></figure><h1 id="bb63" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">总结(2020年4月12日更新)</h1><p id="0193" class="pw-post-body-paragraph ki kj it kk b kl mt ju kn ko mu jx kq kr mv kt ku kv mw kx ky kz mx lb lc ld im bi translated">以下是我们调查结果的总结:</p><h2 id="e8f0" class="na mc it bd md nb nc dn mh nd ne dp ml kr nf ng mn kv nh ni mp kz nj nk mr nl bi translated">ES6休息</h2><pre class="lm ln lo lp gt oy lj oz pa aw pb bi"><span id="b644" class="na mc it lj b gy pc pd l pe pf">const omit = (keyToOmit, { [keyToOmit]: _, ...omittedPropObj } = {}) =&gt; omittedPropObj;</span><span id="552c" class="na mc it lj b gy pg pd l pe pf"><strong class="lj iu">Fastest                 : YES<br/>Omit single property    : YES<br/>Omit multiple properties: NO<br/>Omit flattened paths    : NO</strong></span></pre><h2 id="af4a" class="na mc it bd md nb nc dn mh nd ne dp ml kr nf ng mn kv nh ni mp kz nj nk mr nl bi translated">ESRest + JavaScript删除</h2><pre class="lm ln lo lp gt oy lj oz pa aw pb bi"><span id="66e1" class="na mc it lj b gy pc pd l pe pf">const omit = (originalObject = {}, keysToOmit = []) =&gt; {  <br/>    const clonedObject = { ...originalObject };              </span><span id="3b6c" class="na mc it lj b gy pg pd l pe pf">    for (const path of keysToOmit) {                <br/>      delete clonedObject[path]       <br/>    }           </span><span id="6b9d" class="na mc it lj b gy pg pd l pe pf">    return clonedObject;<br/>}</span><span id="1bd1" class="na mc it lj b gy pg pd l pe pf"><strong class="lj iu">Fastest                 : YES, for multiple top level properties<br/>Omit single property    : YES<br/>Omit multiple properties: YES<br/>Omit flattened paths    : NO</strong></span></pre><h2 id="b8b9" class="na mc it bd md nb nc dn mh nd ne dp ml kr nf ng mn kv nh ni mp kz nj nk mr nl bi translated">ES6剩余+ Lodash未设置</h2><pre class="lm ln lo lp gt oy lj oz pa aw pb bi"><span id="e1e0" class="na mc it lj b gy pc pd l pe pf">const omit = (originalObject = {}, keysToOmit = []) =&gt; {    <br/>    const clonedObject = { ...originalObject };      <br/>    <br/>    for (const path of keysToOmit) {        <br/>        _.unset(clonedObject, path)    <br/>    }     <br/>  <br/>    return clonedObject;<br/>}</span><span id="97b8" class="na mc it lj b gy pg pd l pe pf"><strong class="lj iu">Fastest                 : YES, for multiple properties<br/>Omit single property    : YES<br/>Omit multiple properties: YES<br/>Omit flattened paths    : YES, but will modify ORIGINAL object</strong></span></pre><h2 id="8c28" class="na mc it bd md nb nc dn mh nd ne dp ml kr nf ng mn kv nh ni mp kz nj nk mr nl bi translated">ES2019来自条目+条目</h2><pre class="lm ln lo lp gt oy lj oz pa aw pb bi"><span id="6c88" class="na mc it lj b gy pc pd l pe pf">const omit = (originalObj = {}, keysToOmit = []) =&gt;          <br/>   Object.fromEntries(Object.entries(originalObj).filter(([key]) =&gt; <br/>      !keysToOmit.includes(key)<br/>   )<br/>)</span><span id="c5c8" class="na mc it lj b gy pg pd l pe pf"><strong class="lj iu">Fastest                 : NO, Slowest<br/>Omit single property    : YES<br/>Omit multiple properties: YES<br/>Omit flattened paths    : NO</strong></span></pre><h2 id="c42c" class="na mc it bd md nb nc dn mh nd ne dp ml kr nf ng mn kv nh ni mp kz nj nk mr nl bi translated">Lodash cloneDeep + Lodash unset</h2><pre class="lm ln lo lp gt oy lj oz pa aw pb bi"><span id="3846" class="na mc it lj b gy pc pd l pe pf">const omit = (originalObject = {}, keysToOmit = []) =&gt; {<br/>   const clonedObject = _.cloneDeep(originalObject); </span><span id="ff65" class="na mc it lj b gy pg pd l pe pf">    for (const path of keysToOmit) {       <br/>        _.unset(clonedObject, path)    <br/>    }     </span><span id="9911" class="na mc it lj b gy pg pd l pe pf">    return clonedObject;<br/>}</span><span id="1af2" class="na mc it lj b gy pg pd l pe pf"><strong class="lj iu">Fastest                 : NO, Extremely slow<br/>Omit single property    : YES<br/>Omit multiple properties: YES<br/>Omit flattened paths    : YES</strong></span></pre><p id="9b48" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我个人建议创建一个包含以下内容的实用程序类:</p><ul class=""><li id="86ee" class="nm nn it kk b kl km ko kp kr no kv np kz nq ld nr ns nt nu bi translated">用于省略单个顶级属性的ES6 Rest函数</li><li id="8d58" class="nm nn it kk b kl nv ko nw kr nx kv ny kz nz ld nr ns nt nu bi translated">用于省略多个顶级属性的ES6 Rest + Delete函数</li></ul><p id="5cdb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，如果您<em class="oa">需要</em>省略展平的路径，我建议要么只为<code class="fe lg lh li lj b">omit</code>功能安装Lodash 4+,而为其他所有功能使用Lodash 5+。</p><p id="a889" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为读书欢呼。</p><p id="339b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">抢劫</p><h2 id="25c5" class="na mc it bd md nb nc dn mh nd ne dp ml kr nf ng mn kv nh ni mp kz nj nk mr nl bi translated">参考</h2><ol class=""><li id="64c1" class="nm nn it kk b kl mt ko mu kr ph kv pi kz pj ld pk ns nt nu bi translated"><a class="ae lk" href="https://lodash.com/docs/4.17.15#omit" rel="noopener ugc nofollow" target="_blank">https://lodash.com/docs/4.17.15#omit</a></li><li id="dbe4" class="nm nn it kk b kl nv ko nw kr nx kv ny kz nz ld pk ns nt nu bi translated"><a class="ae lk" href="https://lodash.com/docs/4.17.15#pick" rel="noopener ugc nofollow" target="_blank">https://lodash.com/docs/4.17.15#pick</a></li><li id="e9af" class="nm nn it kk b kl nv ko nw kr nx kv ny kz nz ld pk ns nt nu bi translated"><a class="ae lk" href="https://lodash.com/docs/4.17.15#pickBy" rel="noopener ugc nofollow" target="_blank">https://lodash.com/docs/4.17.15#pickBy</a></li><li id="07f3" class="nm nn it kk b kl nv ko nw kr nx kv ny kz nz ld pk ns nt nu bi translated"><a class="ae lk" href="https://lodash.com/docs/4.17.15#unset" rel="noopener ugc nofollow" target="_blank">https://lodash.com/docs/4.17.15#unset</a></li><li id="11ff" class="nm nn it kk b kl nv ko nw kr nx kv ny kz nz ld pk ns nt nu bi translated"><a class="ae lk" href="https://codepen.io/travist/full/jrBjBz/" rel="noopener ugc nofollow" target="_blank">https://codepen.io/travist/full/jrBjBz/</a></li><li id="bc9d" class="nm nn it kk b kl nv ko nw kr nx kv ny kz nz ld pk ns nt nu bi translated"><a class="ae lk" href="https://jsbench.me/" rel="noopener ugc nofollow" target="_blank">https://jsbench.me/</a></li><li id="fcba" class="nm nn it kk b kl nv ko nw kr nx kv ny kz nz ld pk ns nt nu bi translated">https://github.com/lodash/lodash/issues/2930<a class="ae lk" href="https://github.com/lodash/lodash/issues/2930" rel="noopener ugc nofollow" target="_blank"/></li><li id="a3a5" class="nm nn it kk b kl nv ko nw kr nx kv ny kz nz ld pk ns nt nu bi translated"><a class="ae lk" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/fromEntries" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Reference/Global _ Objects/Object/from entries</a></li><li id="4769" class="nm nn it kk b kl nv ko nw kr nx kv ny kz nz ld pk ns nt nu bi translated"><a class="ae lk" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Reference/Global _ Objects/Object/entries</a></li><li id="10ec" class="nm nn it kk b kl nv ko nw kr nx kv ny kz nz ld pk ns nt nu bi translated"><a class="ae lk" href="https://github.com/lodash/lodash/blob/npm/omit.js" rel="noopener ugc nofollow" target="_blank">https://github.com/lodash/lodash/blob/npm/omit.js</a></li><li id="d811" class="nm nn it kk b kl nv ko nw kr nx kv ny kz nz ld pk ns nt nu bi translated"><a class="ae lk" href="https://react.semantic-ui.com/" rel="noopener ugc nofollow" target="_blank">语义UI反应</a></li><li id="9686" class="nm nn it kk b kl nv ko nw kr nx kv ny kz nz ld pk ns nt nu bi translated"><a class="ae lk" href="https://formidable.com/open-source/victory/" rel="noopener ugc nofollow" target="_blank">胜利</a></li></ol></div></div>    
</body>
</html>