<html>
<head>
<title/>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1/>
<blockquote>原文：<a href="https://levelup.gitconnected.com/kubernetes-scheduler-101-751f65841fa0?source=collection_archive---------3-----------------------#2019-09-02">https://levelup.gitconnected.com/kubernetes-scheduler-101-751f65841fa0?source=collection_archive---------3-----------------------#2019-09-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><p id="c20d" class="pw-post-body-paragraph ir is it iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp im bi translated"><em class="jq">本文最初发表于https://www.magalix.com/blog/kubernetes-scheduler-101</em><a class="ae jr" href="https://www.magalix.com/blog/kubernetes-scheduler-101" rel="noopener ugc nofollow" target="_blank"/></p><h1 id="c142" class="js jt it bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">Kubernetes调度程序101</h1><p id="649f" class="pw-post-body-paragraph ir is it iu b iv kq ix iy iz kr jb jc jd ks jf jg jh kt jj jk jl ku jn jo jp im bi translated">如果你读过任何<a class="ae jr" href="https://www.magalix.com/blog/kubernetes-101-concepts-and-why-it-matters" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>的文档、书籍或文章，你肯定在短语中见过“schedule”这个词，比如“the <a class="ae jr" href="https://www.magalix.com/blog/kubernetes-pods-101-the-cluster-sailors" rel="noopener ugc nofollow" target="_blank"> Pod </a>被安排到下一个可用的<a class="ae jr" href="https://kubernetes.io/docs/concepts/architecture/nodes/" rel="noopener ugc nofollow" target="_blank">节点</a>”。Kubernetes的调度不仅仅是在一个节点上放置一个pod。在本文中，我们讨论了Kubernetes在需要处理新pod时遵循的不同机制，以及该过程中包含的组件。</p><p id="f0a6" class="pw-post-body-paragraph ir is it iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp im bi translated">几秒钟后，Pod就可以在一个集群节点上启动并运行。然而，在这几秒钟内发生了很多事情。让我们看看:</p><ol class=""><li id="4f4e" class="kv kw it iu b iv iw iz ja jd kx jh ky jl kz jp la lb lc ld bi translated">在扫描<a class="ae jr" href="https://kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver/" rel="noopener ugc nofollow" target="_blank"> API服务器</a>(它一直在扫描)时，<a class="ae jr" href="https://kubernetes.io/docs/concepts/scheduling/kube-scheduler/" rel="noopener ugc nofollow" target="_blank"> Kubernetes调度程序</a>检测到有一个没有nodeName参数的新Pod。节点名显示了哪个节点应该拥有这个Pod。</li><li id="5d1e" class="kv kw it iu b iv le iz lf jd lg jh lh jl li jp la lb lc ld bi translated">调度程序为这个Pod选择一个合适的节点，并用节点名(通过node name参数)更新Pod定义。</li><li id="1bf5" class="kv kw it iu b iv le iz lf jd lg jh lh jl li jp la lb lc ld bi translated">通知所选节点上的<a class="ae jr" href="https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet/" rel="noopener ugc nofollow" target="_blank"> kubelet </a>有一个pod正在等待执行。</li><li id="8041" class="kv kw it iu b iv le iz lf jd lg jh lh jl li jp la lb lc ld bi translated">kubelet执行Pod，后者开始在节点上运行。</li></ol><p id="bd44" class="pw-post-body-paragraph ir is it iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp im bi translated">也许上述步骤中最困难的部分是当调度器决定应该选择哪个节点来运行pod时。事实上，这一部分的工作量最大，因为调度程序必须使用几个算法来做出这个决定。其中一些算法依赖于用户提供的选项，而Kubernetes自己计算其他算法。它们可以被解释为调度器要求节点决定的一组问题。</p><h1 id="cbcd" class="js jt it bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">您有运行这个Pod(谓词)所需要的东西吗？</h1><p id="ad09" class="pw-post-body-paragraph ir is it iu b iv kq ix iy iz kr jb jc jd ks jf jg jh kt jj jk jl ku jn jo jp im bi translated">一个节点可能会过载，因为太多繁忙的pod消耗了它的大部分CPU和内存。因此，当调度程序有一个Pod要部署时，它会确定该节点是否有必要的资源。例如，如果一个Pod被部署到一个节点，而该节点没有足够的Pod所请求的内存，则托管的应用程序可能会异常运行，甚至崩溃。</p><p id="b4fc" class="pw-post-body-paragraph ir is it iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp im bi translated">有时候，用户需要代表Kubernetes做出这个决定。假设您最近购买了几台配备SSD磁盘的机器，并且您希望将它们明确用于应用程序的MongoDB部分。为此，您可以通过pod定义中的节点标签来选择节点。当某个节点与提供的标签不匹配时，不会选择该节点来部署Pod。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi lj"><img src="../Images/824dcd948cbdd84ef7ec423d982e31db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*6JBOArHyFdqmsCb5.png"/></div></div></figure><p id="120b" class="pw-post-body-paragraph ir is it iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp im bi translated">如上图所示，谓词决策要么为真(是，在该节点上部署pod)，要么为假(否，不在该节点上部署)。</p><h1 id="2b54" class="js jt it bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">你是拥有这个Pod(优先级)的更好的候选人吗？</h1><p id="6a5c" class="pw-post-body-paragraph ir is it iu b iv kq ix iy iz kr jb jc jd ks jf jg jh kt jj jk jl ku jn jo jp im bi translated">除了真/假决策(也称为谓词)之外，调度程序还执行一些计算(或函数)来确定哪个节点更适合托管所讨论的pod。</p><p id="f652" class="pw-post-body-paragraph ir is it iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp im bi translated">例如，一个已经存在pod映像的节点(就像它在之前的<a class="ae jr" href="https://www.magalix.com/blog/kubernetes-deployments-101" rel="noopener ugc nofollow" target="_blank">部署</a>中已经被拉出)有更好的机会让pod调度到它，因为不会浪费时间再次下载映像。</p><p id="07ef" class="pw-post-body-paragraph ir is it iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp im bi translated">另一个例子是当调度程序倾向于不包括相同<a class="ae jr" href="https://www.magalix.com/blog/kubernetes-services-101-the-pods-interfaces" rel="noopener ugc nofollow" target="_blank">服务</a>的其他pod的节点时。该算法有助于将服务单元尽可能分散到多个节点上，这样一个节点故障不会导致整个服务停止。这样的决策方法称为扩散函数。</p><p id="9584" class="pw-post-body-paragraph ir is it iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp im bi translated">像上面的例子一样，对几个决策进行分组，并根据最终的决策计算每个节点的权重。优先级最高的节点赢得pod部署。</p><h1 id="43b9" class="js jt it bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">最后的决定</h1><p id="e4d0" class="pw-post-body-paragraph ir is it iu b iv kq ix iy iz kr jb jc jd ks jf jg jh kt jj jk jl ku jn jo jp im bi translated">您可能会问，如果Kubernetes调度程序在选择部署pod的节点之前必须考虑这么多因素，那么它如何选择正确的节点呢？</p><ol class=""><li id="24ea" class="kv kw it iu b iv iw iz ja jd kx jh ky jl kz jp la lb lc ld bi translated">决策过程是这样完成的:</li><li id="4540" class="kv kw it iu b iv le iz lf jd lg jh lh jl li jp la lb lc ld bi translated">调度程序确定它知道它们存在并且健康的所有节点。</li><li id="e572" class="kv kw it iu b iv le iz lf jd lg jh lh jl li jp la lb lc ld bi translated">调度程序运行谓词测试来过滤掉不合适的节点。其余的节点形成一组可能的节点。</li><li id="6a79" class="kv kw it iu b iv le iz lf jd lg jh lh jl li jp la lb lc ld bi translated">调度程序对可能的节点运行优先级测试。候选人按分数排序，分数最高的在最上面。此时，得分最高的可能节点被选中。但是有时可能有多个节点具有相同的分数。</li><li id="f0d7" class="kv kw it iu b iv le iz lf jd lg jh lh jl li jp la lb lc ld bi translated">如果节点具有相同的分数，它们将被移动到最终列表中。Kubernetes调度程序以循环方式选择获胜节点，以确保它在机器之间平均分配负载。</li></ol><h1 id="8921" class="js jt it bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">如果这不是最好的决定呢？</h1><p id="d46c" class="pw-post-body-paragraph ir is it iu b iv kq ix iy iz kr jb jc jd ks jf jg jh kt jj jk jl ku jn jo jp im bi translated">在busy <a class="ae jr" href="https://www.magalix.com/blog/kubernetes-101-concepts-and-why-it-matters" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>集群中，从调度程序选择正确的节点到kubelet在该节点上执行pod之间的时间可能足以在节点上发生变化。即使这个时间不超过几毫秒，一个<a class="ae jr" href="https://www.magalix.com/blog/kubernetes-pods-101-the-cluster-sailors" rel="noopener ugc nofollow" target="_blank"> pod </a>也可能在一个由于内存不足而被过滤掉的节点上终止。那个节点只有在当时没有过载的情况下才能在优先级测试中获得更高的分数。但是现在，也许一个不太合适的节点被选作了分离舱。</p><p id="5c3a" class="pw-post-body-paragraph ir is it iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp im bi translated">一些项目旨在解决这种情况，如Kubernetes解调度器项目。在这个应用程序中，如果另一个节点被证明是pod调度的更好选择，那么pod将被自动从该节点中逐出。该单元将返回到计划中，以将其再次部署到正确的节点。</p><p id="1df5" class="pw-post-body-paragraph ir is it iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp im bi translated">当相反的情况发生时，也许会出现更困难的情况。假设测试了一个节点是否能提供2 GB的内存。当调度程序进行谓词检查时，节点确实有一些空闲RAM。然而，当kubelet对节点执行pod时，一个<a class="ae jr" href="https://www.magalix.com/blog/kubernetes-daemonsets-101" rel="noopener ugc nofollow" target="_blank"> DaemonSet </a>被部署到同一个节点。这个DaemonSet需要一些消耗大量资源的操作，消耗剩余的2 GB。现在，当pod试图运行时，由于它缺少正常运行所需的内存量，它会失败。如果这个pod仅仅使用一个pod定义来部署，那么运行它的应用程序将无法启动，Kubernetes对此无能为力。然而，如果这个pod是pod控制器的一部分，如<a class="ae jr" href="https://www.magalix.com/blog/kubernetes-deployments-101" rel="noopener ugc nofollow" target="_blank">部署</a>或<a class="ae jr" href="https://www.magalix.com/blog/kubernetes-replicaset-101" rel="noopener ugc nofollow" target="_blank">副本集</a>，那么一旦它失败，控制器将检测到副本的数量比它应该处理的数量少。因此，控制器将请求调度另一个pod。调度程序将再次运行所有检查，并将pod调度到不同的节点。这就是为什么在创建pod时总是建议使用更高级别的对象(如部署)的原因之一。</p><p id="25ce" class="pw-post-body-paragraph ir is it iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp im bi translated">在本文的前面，我们提到用户可以简单地选择使用pod定义或模板中的<a class="ae jr" href="https://kubernetes.io/docs/concepts/configuration/assign-pod-node/" rel="noopener ugc nofollow" target="_blank"> .spec.nodeSelector </a>参数在特定节点上运行Pod。这</p><p id="b411" class="pw-post-body-paragraph ir is it iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp im bi translated">nodeSelector选择具有特定一个或多个标签的节点。然而，有时，用户</p><p id="c3f4" class="pw-post-body-paragraph ir is it iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp im bi translated">需求变得更加复杂。例如，nodeSelector选择在参数中定义了所有标签的节点。如果要做更灵活的选择呢？</p><h1 id="a703" class="js jt it bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">节点关联性</h1><p id="fac8" class="pw-post-body-paragraph ir is it iu b iv kq ix iy iz kr jb jc jd ks jf jg jh kt jj jk jl ku jn jo jp im bi translated">让我们考虑一下我们之前的例子，当我们想要安排我们的pod在带有SSD磁盘的机器上运行时。假设我们希望他们也使用八核主机。节点关联性允许像这样的灵活决策。以下pod模板选择标签为“功能=ssd”或“功能=八核”的节点:</p><pre class="lk ll lm ln gt lv lw lx ly aw lz bi"><span id="bdbc" class="ma jt it lw b gy mb mc l md me">apiVersion: v1<br/>kind: Pod<br/>metadata:<br/> name: mongo<br/>spec:<br/> affinity:<br/>   nodeAffinity:<br/>     requiredDuringSchedulingIgnoredDuringExecution:<br/>       nodeSelectorTerms:<br/>       - matchExpressions:<br/>         - key: feature<br/>           operator: In<br/>           values:<br/>           - ssd<br/>           - eight-cores<br/> containers:<br/> - name: mongodb<br/>   image: mogo</span></pre><h1 id="7cc7" class="js jt it bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">RequiredDuringSchedulingIgnoredDuring执行选项</h1><p id="a0e4" class="pw-post-body-paragraph ir is it iu b iv kq ix iy iz kr jb jc jd ks jf jg jh kt jj jk jl ku jn jo jp im bi translated">这里有一个新的选项:<a class="ae jr" href="https://kubernetes.io/docs/concepts/configuration/assign-pod-node/" rel="noopener ugc nofollow" target="_blank">requiredduringschedulingignoredduringeexecution</a>。这比看起来容易。这意味着我们只需要在标有特性=固态硬盘或特性=八核的节点上运行这些pod。我们不希望调度程序在这组节点之外做出决策。这与nodeSelector的行为相同，但语法更具表现力。</p><h1 id="51c5" class="js jt it bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">preferred during schedulingignoredduring执行选项</h1><p id="21d1" class="pw-post-body-paragraph ir is it iu b iv kq ix iy iz kr jb jc jd ks jf jg jh kt jj jk jl ku jn jo jp im bi translated">假设我们对在我们选择的节点上运行pod感兴趣。但是，因为启动pod是绝对优先的，所以我们要求即使所选节点不可用也要运行它。在这种情况下，我们可以使用<a class="ae jr" href="https://kubernetes.io/docs/concepts/configuration/assign-pod-node/" rel="noopener ugc nofollow" target="_blank">preferred during schedulingignoredduringeexecution</a>选项。该选项将尝试在选择器指定的节点上运行pod。但是如果这些节点不可用(测试失败)，调度程序将尝试在下一个最佳节点上运行pod。</p><h1 id="166d" class="js jt it bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">节点反亲和性</h1><p id="257e" class="pw-post-body-paragraph ir is it iu b iv kq ix iy iz kr jb jc jd ks jf jg jh kt jj jk jl ku jn jo jp im bi translated">有些场景要求除了特定的pod之外，不要使用一个或多个节点。想象一下托管您的监控应用程序的节点。由于其角色的性质，这些节点不应该有很多资源。因此，如果没有安装监控应用程序的其他pod被调度到这些节点，它们会破坏监控，还会降低它们托管的应用程序的性能。在这种情况下，您需要使用节点反亲缘关系来使pod远离一组节点。以下是之前添加了反亲缘关系的pod定义:</p><pre class="lk ll lm ln gt lv lw lx ly aw lz bi"><span id="629f" class="ma jt it lw b gy mb mc l md me">apiVersion: v1<br/>kind: Pod<br/>metadata:<br/> name: mongo<br/>spec:<br/> affinity:<br/>   nodeAffinity:<br/>     requiredDuringSchedulingIgnoredDuringExecution:<br/>       nodeSelectorTerms:<br/>       - matchExpressions:<br/>         - key: feature<br/>           operator: In<br/>           values:<br/>           - ssd<br/>           - eight-cores<br/>         - key: role<br/>           operator: NotIn<br/>           values:<br/>           - monitoring<br/><br/> containers:<br/> - name: mongodb<br/>   image: mogo</span></pre><p id="58f2" class="pw-post-body-paragraph ir is it iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp im bi translated">使用操作符NotIn向matchExpressions添加另一个键将避免在任何标记为role=monitoring的节点上调度mongo pods。</p><h1 id="23df" class="js jt it bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">节点污染和容忍</h1><p id="bd9e" class="pw-post-body-paragraph ir is it iu b iv kq ix iy iz kr jb jc jd ks jf jg jh kt jj jk jl ku jn jo jp im bi translated">虽然节点反关联性模式允许您阻止pod在特定节点上运行，但是它们有一个缺点:pod定义必须显式声明它不应该在这些节点上运行。那么，如果一个新成员加入了开发团队，为她的应用程序编写了一个部署，但是忘记了从目标节点中排除监控节点，该怎么办呢？Kubernetes管理员需要一种方法来从节点中排除pod，而不必修改每个pod定义。这就是<a class="ae jr" href="https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/" rel="noopener ugc nofollow" target="_blank">污点和宽容</a>的作用。</p><p id="01a9" class="pw-post-body-paragraph ir is it iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp im bi translated">当您污染一个节点时，它会自动从pod调度中排除。当调度在受感染的节点上运行谓词测试时，它们将失败，除非pod能够容忍该节点。例如，让我们污染监控节点mon01:</p><pre class="lk ll lm ln gt lv lw lx ly aw lz bi"><span id="1a4d" class="ma jt it lw b gy mb mc l md me">kubectl taint nodes mon01 role=monitoring:NoSchedule</span></pre><p id="f9ca" class="pw-post-body-paragraph ir is it iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp im bi translated">现在，要让一个pod在这个节点上运行，它必须有一个容忍度。例如，下面的特殊公差:</p><pre class="lk ll lm ln gt lv lw lx ly aw lz bi"><span id="60ad" class="ma jt it lw b gy mb mc l md me">tolerations: - key: "role" operator: "Equal" value: "monitoring" effect: "NoSchedule"</span></pre><p id="f4cf" class="pw-post-body-paragraph ir is it iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp im bi translated">匹配mon01上污点的键、值和效果。这意味着当调度程序决定是否可以使用mon01来部署这个pod时，mon 01将通过谓词测试。</p><p id="f71e" class="pw-post-body-paragraph ir is it iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp im bi translated">不过，需要注意的一件重要事情是，容忍可能会使一个受感染的节点接受一个pod，但它不能保证这个pod在那个特定的节点上运行。换句话说，受污染的节点mon01将被视为运行我们的pod的候选节点之一。然而，如果另一个节点具有更高的优先级分数，它将被选择。对于这种情况，您需要将容错与nodeSelector或node affinity参数结合起来。</p><ul class=""><li id="6e42" class="kv kw it iu b iv iw iz ja jd kx jh ky jl kz jp mf lb lc ld bi translated">Kubernetes调度器是负责确定哪个节点最适合运行pods的组件。</li><li id="2940" class="kv kw it iu b iv le iz lf jd lg jh lh jl li jp mf lb lc ld bi translated">它通过两个主要的决策过程来实现这一点:</li><li id="9a99" class="kv kw it iu b iv le iz lf jd lg jh lh jl li jp mf lb lc ld bi translated">谓词:这是一组测试，每一个都可以判断为真或假。谓词失败的节点被排除在流程之外。</li><li id="059b" class="kv kw it iu b iv le iz lf jd lg jh lh jl li jp mf lb lc ld bi translated">优先级:每个节点都被一些函数测试，这些函数会给它一个分数。具有最高分数的节点被选择用于pod部署。</li><li id="585a" class="kv kw it iu b iv le iz lf jd lg jh lh jl li jp mf lb lc ld bi translated">Kubernetes调度程序还支持影响其决策的用户定义的因素:</li><li id="6e18" class="kv kw it iu b iv le iz lf jd lg jh lh jl li jp mf lb lc ld bi translated">节点选择器:pod定义中的. spec.nodeSelector参数将节点选择范围缩小到那些在Node Selector中定义了标签的节点。</li><li id="066a" class="kv kw it iu b iv le iz lf jd lg jh lh jl li jp mf lb lc ld bi translated">节点相似性和反相似性:它们用于在节点选择中提供更大的灵活性，因为它们允许更具表达性的选择标准。节点相似性可用于保证仅使用匹配的节点，或者仅用于设置偏好。</li><li id="6708" class="kv kw it iu b iv le iz lf jd lg jh lh jl li jp mf lb lc ld bi translated">污点和容忍以与节点相似性相同的方式工作。然而，他们的默认动作是从受感染的节点中排斥豆荚，除非豆荚具有必要的耐受性(这只是一个键、一个值和一个效果)。容错通常与节点相似性或节点选择器参数相结合，以保证只有匹配的节点用于pod调度。</li></ul></div><div class="ab cl mg mh hx mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="im in io ip iq"><p id="814d" class="pw-post-body-paragraph ir is it iu b iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp im bi translated"><em class="jq">原载于2019年9月2日</em><a class="ae jr" href="https://www.magalix.com/blog/kubernetes-scheduler-101" rel="noopener ugc nofollow" target="_blank"><em class="jq">【https://www.magalix.com】</em></a><em class="jq">。</em></p></div></div>    
</body>
</html>