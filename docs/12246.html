<html>
<head>
<title>What Is a JWT (And Why)?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是JWT(为什么)？</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/what-is-a-jwt-nd-why-2bd0c74aa26f?source=collection_archive---------11-----------------------#2022-05-25">https://levelup.gitconnected.com/what-is-a-jwt-nd-why-2bd0c74aa26f?source=collection_archive---------11-----------------------#2022-05-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a4f6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">想象你是一个服务器…</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/892b4ad376e28bf1e7c1e3025da3d55f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HXZdAc9iXZmagehxCn4HUQ.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">泰勒·维克在<a class="ae ky" href="https://unsplash.com/s/photos/network?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="ed09" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">JWT是一个JSON Web令牌。没错。既然这么说了，我们也没什么进展。让我们一起来探索JWT的用途，以及JWT是如何构建的。以及jwt如何允许我们设计一个“无状态”的服务器。但是首先…</p><h1 id="d928" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">JWT是干什么的？</h1><p id="cc57" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">要理解jwt的要点，您必须首先理解它们试图解决的问题。想象你是一个服务器，在数据中心的一个机架上耐心地等待。你收到了一条信息，上面写着“显示主页”。或者说HTTP，一个“GET /index”请求。</p><p id="6f47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您生成主页并将其发送回去。到目前为止一切顺利。</p><p id="7973" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在想象一下，在主页上，您的程序员上级指示您显示请求页面的人的名字，如果他们已经登录的话。</p><p id="1857" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">或者想象这个人请求一个页面，比如/secret。你知道这个页面只对员工开放，或者只对那些已经订阅的人开放。从服务器的角度来看，你如何处理呢？换句话说:当服务器收到消息时，它如何知道是谁发送的呢？</p><p id="c2f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当然，在某个时候，用户登录了。他或她输入了电子邮件和密码，所以我们(服务器)知道<em class="ms">然后</em>是谁。当服务器收到带有电子邮件和密码的登录消息时，它会检查数据库中的电子邮件和密码是否匹配。如果没有，则返回错误。</p><p id="c5c0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是让我们想象一下，这条给/login的消息是在10分钟前发送的。让我们假设有数百人，每个人都有不同的权限，他们也在登录。服务器如何知道这个消息(或请求)来自那个用户的<em class="ms">？</em></p><p id="6235" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是请求头出现的地方。我们可以把信息放在里面。我们可以添加用户的电子邮件来识别他们。但这对于恶搞来说是微不足道的。我们可以添加密码，但这意味着两件事:</p><ul class=""><li id="41d0" class="mt mu it lb b lc ld lf lg li mv lm mw lq mx lu my mz na nb bi translated">首先，每次收到请求时都必须检查数据库，这是很昂贵的</li><li id="1777" class="mt mu it lb b lc nc lf nd li ne lm nf lq ng lu my mz na nb bi translated">其次，需要在每条消息中发送密码，这是有风险的。</li></ul><p id="b3d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">显然，这并不理想。</p><h1 id="175e" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">第一种解决方案</h1><p id="3951" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">已经使用了很长时间的解决方案是创建一种临时密码(一个秘密),用户在登录时会收到一个响应。服务器记住这个秘密和那个用户之间的联系。</p><p id="60ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当浏览器与服务器对话时，它发送这个秘密(通过请求头)。然后，当服务器接收到消息时，在存储器中检查该秘密是否对应于用户。这个秘密就是所谓的“会话”标识符。当您只有一台服务器时，所有这些都可以很好地工作。</p><p id="3ac2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是想象一下，您正在管理一个拥有数百台服务器的应用程序。而在这些服务器的前面，有一个负载均衡器，它会向使用较少的服务器发送消息。因此，当消息到达时，它与用于登录的服务器在同一个服务器上的可能性很小。</p><p id="af1d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以我们不能依赖服务器将秘密保存在内存中。</p><p id="d547" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以创建一个中央数据库，可能在内存中。但是如果我们能让我们的服务器“无状态”，那就更好了。也就是说，能够处理请求，而不必在请求之间将状态保存在内存中。如果我们能做到这一点，它将允许更容易的可伸缩性。因为不需要在服务器之间传递共享状态。</p><p id="60da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是JWT的用武之地。</p><p id="78a0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">JWT或JavaScript Web令牌解决了这个问题。管理状态的不再是服务器，而是包含状态的这个令牌。这是怎么回事？好吧，让我们看看JWT是如何建造的。</p><h1 id="83e6" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">JWT的结构</h1><p id="9a5c" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">一个JWT看起来就像这个字母和数字的胡言乱语的大杂烩:eyjhbgcioijiuzi 1 nij 9 . eyjuw1 lijoism 9 lienvzgvyin 0.5 DLP 7 gmzil 2 QS 06 szgk 4 mtaqv 0 _ xx 4 of outd h1 zhk 4 u</p><p id="5d67" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你仔细观察，你会发现有三个文本块被点分开。这些块是JWT的三个部分，即:头部、主体和签名。</p><p id="f9bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">每个部分都用Base64编码。不是为了安全目的，而是为了允许令牌通过HTTP消息和平地传输。让我们来看看这三个部分:</p><p id="30b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">1/<strong class="lb iu">报头</strong>指定用于签名的算法，其中“alg”字段为“算法”</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="a6af" class="nm lw it ni b gy nn no l np nq">{ “alg”: “HS256” }</span></pre><p id="db6d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，在这个例子中，HS256指示令牌应该用SHA 256中的密钥来签名。</p><p id="6520" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2/第二部分，<strong class="lb iu">主体</strong>，包含权利要求。这也是一个JSON文档。这是令牌声明(例如)令牌属于哪个用户、它的id和它的权限的地方。我们可以(并且，如果我们想做好这件事，我们必须)指定令牌的创建和到期日期。</p><p id="151b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">JWT标准规定了这些字段的名称。例如，“exp”字段指定到期的时间戳。(时间戳是一个日期，指定为自纪元以来的秒数，即自1970年1月1日以来)。因此(非base64版本)可能如下所示:</p><pre class="kj kk kl km gt nh ni nj nk aw nl bi"><span id="19c7" class="nm lw it ni b gy nn no l np nq">{<br/>“id”: 42,<br/>“name”: “Kodaps”,<br/>“role”: “admin”,<br/>“exp”: 1647807974<br/>}</span></pre><p id="6078" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是存储状态并最终允许服务器以无状态方式工作的部分。</p><p id="efaf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">3/最后是<strong class="lb iu">加密签名</strong>。这是允许我们验证令牌的部分。这个想法是用只有服务器知道的秘密对令牌进行签名。</p><p id="bb00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这样，如果签名与这个秘密匹配，我(服务器)知道我可以信任这个令牌及其声明。而不需要查询数据库。</p><p id="7e19" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">JWT的第一个优势是它允许服务器“无状态”，即不需要在它们自己的内存中存储任何状态。</p><p id="2d33" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="ms">的第二个</em>优势是jwt可以用在移动应用程序的上下文中，在这种情况下cookies或会话没有什么意义。或者在与API通信的环境中，同样地，会话实际上并不存在。</p><p id="0ea3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">第三个<em class="ms">优势是使用非对称密钥对，任何拥有公钥</em>的人都可以<em class="ms">验证用私钥签名的令牌。</em></p><p id="35ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，这意味着一个中央机构——我们知道它是可信的——可以发布一个可验证的证书，该证书声明(例如):“这个用户具有这些特征。你可以用我公布的公钥来验证他的JWT令牌是否有效。”</p><p id="4202" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，不仅是发送服务器可以验证证书，任何人都可以访问公钥。</p><h1 id="3ccf" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">总结一下。</h1><p id="4cb5" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">JWT是具有加密签名的对象，它封装了表示为“声明”的状态。根据所使用的算法，令牌可以由服务器本身进行验证。这在应用程序、API调用或无状态服务器的情况下非常有用。</p><p id="8a09" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用私有/公共密钥对为我们提供了建立可信第三方机制的方法。</p><p id="a35c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">jwt并不总是比会话更好(它们确实有一些缺点，比如增加了消息的大小)，但是在适当的情况下，它们会非常有用。</p></div></div>    
</body>
</html>