<html>
<head>
<title>My tips for .NET code-review</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我的建议。NET代码-审查</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/my-tips-for-net-code-review-f1a47feece43?source=collection_archive---------1-----------------------#2020-10-19">https://levelup.gitconnected.com/my-tips-for-net-code-review-f1a47feece43?source=collection_archive---------1-----------------------#2020-10-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="6155" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">代码审查在我们的日常开发中很重要。一些开发人员可能会花很多时间学习语言的新特性，DDD，分布式系统或一些新奇的东西，但我们应该记住的第一件事是我们需要编写健壮的，可维护的代码。这里是我最近的代码审查的一些提示，我希望对你有所帮助。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/818e85bc2f44e1b3d607c52dc58918d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XN25duaxZnbj326pvl3pzg.png"/></div></div></figure><h1 id="5c5c" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">NullReferenceException系列</h1><p id="8338" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">这个<code class="fe md me mf mg b">NullReferenceException</code>真烦人。避免这种情况的最好方法是在使用变量之前检查它是否为空。以下是一些潜在的问题。我在这里还包括了其他的例外比如<code class="fe md me mf mg b">ArgumentNullException</code>。</p><h1 id="8dd3" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">总是在声明集合时初始化它</h1><p id="b72c" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">一个常见的错误是，有时我们声明了一个集合，但在使用它之前没有初始化它。像这样:</p><pre class="kp kq kr ks gt mh mg mi mj aw mk bi"><span id="f88c" class="ml lb it mg b gy mm mn l mo mp">List&lt;Person&gt; persons;<br/>// Some logics<br/>// If you use persons directly you may got a null object</span></pre><p id="c395" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以更好的方法是在声明集合时总是初始化它:</p><pre class="kp kq kr ks gt mh mg mi mj aw mk bi"><span id="4427" class="ml lb it mg b gy mm mn l mo mp">List&lt;Person&gt; persons = new List&lt;Persons&gt;();<br/>// Then you can do something as usual</span></pre><p id="e765" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">尤其是如果我们有一个拥有自己私有领域的财产:</p><pre class="kp kq kr ks gt mh mg mi mj aw mk bi"><span id="1a6a" class="ml lb it mg b gy mm mn l mo mp">// It is good to initialize the private field when we declare it.<br/>private ObservableCollection&lt;Person&gt; _personList = new ObservableCollection&lt;Person&gt;();<br/>public ObservableCollection&lt;Person&gt; PersonList<br/>{<br/>     get =&gt; _personList;<br/>     set =&gt; SetProperty(ref _personList, value);<br/>}</span></pre><h1 id="1071" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">不要从返回集合的方法中返回空值</h1><p id="dddd" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">另一个提示是，如果我们有一个返回集合的方法，不要返回<code class="fe md me mf mg b">null</code>。相反，如果没有满意的元素，我们应该返回一个空集合。</p><pre class="kp kq kr ks gt mh mg mi mj aw mk bi"><span id="1de5" class="ml lb it mg b gy mm mn l mo mp">public List&lt;Person&gt; GetPersons()<br/>{<br/>    // Some logic to retrieve the objects. If not found, then return an empty collection. DO NOT return null.<br/>    return new List&lt;Person&gt;();<br/>}</span></pre><h1 id="f6a4" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated"><code class="fe md me mf mg b">FirstOrDefault()</code>还是<code class="fe md me mf mg b">First()</code>？</h1><p id="f988" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">LINQ有一些类似的方法，如<code class="fe md me mf mg b">First()</code>和<code class="fe md me mf mg b">FirstOrDefault()</code>。主要区别在于空集合的行为。如果集合为空或者没有满足条件的元素，那么<code class="fe md me mf mg b">First()</code>将抛出<code class="fe md me mf mg b">InvalidOperationException</code>。对于这种情况，<code class="fe md me mf mg b">FirstOrDefault()</code>是安全的，因为它可以为空集合返回默认值，或者没有元素满足条件。但是我们应该真正清楚默认值是否为空——这是导致<code class="fe md me mf mg b">NullReferenceException</code> - <strong class="js iu">引用和可空类型的默认值是</strong> <code class="fe md me mf mg b"><strong class="js iu">null</strong></code>的另一个原因。所以如果我们这样做会更好:</p><pre class="kp kq kr ks gt mh mg mi mj aw mk bi"><span id="9ca2" class="ml lb it mg b gy mm mn l mo mp">var firstPerson = persons.FirstOrDefault(x =&gt; x.Age &gt; 18);<br/>// Check if the variable is null<br/>if (firstPerson != null)<br/>{<br/>    // Do something to the firstPerson<br/>}</span></pre><p id="6667" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">同样，<code class="fe md me mf mg b">Single()</code>和<code class="fe md me mf mg b">SingleOrDefault()</code>也有不同的结果。<code class="fe md me mf mg b">Single()</code>在这些情况下抛出<code class="fe md me mf mg b">InvalidOperationException</code>:</p><ul class=""><li id="8816" class="mq mr it js b jt ju jx jy kb ms kf mt kj mu kn mv mw mx my bi translated">源集合为空</li><li id="e267" class="mq mr it js b jt mz jx na kb nb kf nc kj nd kn mv mw mx my bi translated">没有元素满足该条件</li><li id="a8d3" class="mq mr it js b jt mz jx na kb nb kf nc kj nd kn mv mw mx my bi translated"><strong class="js iu">多个元素</strong>满足条件</li></ul><p id="e0ed" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于<code class="fe md me mf mg b">SingleOrDefault()</code>，如果集合为空或者没有找到满意的元素，也返回默认值。我们应该在使用返回值之前检查它是否为null。</p><p id="aa02" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另一种处理空集合的方法是使用<code class="fe md me mf mg b">DefaultIfEmpty()</code>扩展方法，如下所示:</p><pre class="kp kq kr ks gt mh mg mi mj aw mk bi"><span id="9bcc" class="ml lb it mg b gy mm mn l mo mp">List&lt;int&gt; numbers = new List&lt;int&gt; { };<br/>// Setting the default value to 1 by using DefaultIfEmpty() in the query.<br/>int firstNumber = numbers.DefaultIfEmpty(1).First();<br/>// Now the firstNumber is 1, not 0.</span></pre><p id="8754" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">参考消息:<a class="ae ne" href="https://docs.microsoft.com/en-us/dotnet/api/system.linq.enumerable.first?view=netcore-3.1&amp;WT.mc_id=DT-MVP-5001643" rel="noopener ugc nofollow" target="_blank">可枚举。第一个</a> <a class="ae ne" href="https://docs.microsoft.com/en-us/dotnet/api/system.linq.enumerable.firstordefault?view=netcore-3.1&amp;WT.mc_id=DT-MVP-5001643" rel="noopener ugc nofollow" target="_blank">可枚举。FirstOrDefault </a>，<a class="ae ne" href="https://docs.microsoft.com/en-us/dotnet/api/system.linq.enumerable.single?view=netcore-3.1&amp;WT.mc_id=DT-MVP-5001643" rel="noopener ugc nofollow" target="_blank">可枚举。单个</a>，<a class="ae ne" href="https://docs.microsoft.com/en-us/dotnet/api/system.linq.enumerable.singleordefault?view=netcore-3.1&amp;WT.mc_id=DT-MVP-5001643" rel="noopener ugc nofollow" target="_blank">可枚举。单一故障</a></p><h1 id="e2ff" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">检查字典中是否存在该关键字</h1><p id="d9ae" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated"><code class="fe md me mf mg b">NullReferenceException</code>的一个可能原因与字典有关。我在代码审查中见过它很多次。除非我们100%确定我们知道这个键存在于字典中，(例如，字典是硬编码的。)我们应该总是先检查一下。因为有时字典来自API，或者它有其他依赖项。我们不能保证我们想要的键在字典中存在。所以试着用这种方式:</p><pre class="kp kq kr ks gt mh mg mi mj aw mk bi"><span id="8491" class="ml lb it mg b gy mm mn l mo mp">var persons = new Dictionary&lt;string, Person&gt; = new Dictionary&lt;string, Person&gt;();<br/>// Add some values<br/>if (persons.ContainsKey("Jack"))<br/>{<br/>    var person = persons["Jack"];<br/>    // Do something<br/>}<br/>// Alternatively, we can use TryGetValue() method which checks and gets the value in one method:<br/>if (persons.TryGetValue("Jack", out Person person))<br/>{<br/>    // Do something<br/>}</span></pre><p id="0608" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们不检查钥匙，我们可能会得到一个<code class="fe md me mf mg b">KeyNotFoundException</code>。仅供参考:<a class="ae ne" href="https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.dictionary-2.item?view=netcore-3.1&amp;WT.mc_id=DT-MVP-5001643" rel="noopener ugc nofollow" target="_blank">字典&lt; TKey，TValue &gt;。</a>，<a class="ae ne" href="https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.dictionary-2.containskey?view=netcore-3.1&amp;WT.mc_id=DT-MVP-5001643" rel="noopener ugc nofollow" target="_blank">项字典&lt; TKey，TValue &gt;。ContainsKey(TKey) </a></p><p id="22a5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此外，当您将键/值对添加到字典中时，您应该检查字典中是否已经存在该键。</p><h1 id="458b" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated"><code class="fe md me mf mg b">as</code>还是<code class="fe md me mf mg b">is</code>？</h1><p id="0c49" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">当我们转换对象类型时，我们可以使用<code class="fe md me mf mg b">as</code>，例如:</p><pre class="kp kq kr ks gt mh mg mi mj aw mk bi"><span id="4a1f" class="ml lb it mg b gy mm mn l mo mp">protected override void SetValueImpl(object target, SomeStatus value)<br/>{<br/>    var ctrl = target as ControlA;<br/>    ctrl.Status = newValue;<br/>}</span></pre><p id="5b42" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe md me mf mg b">as</code>操作符将表达式的结果显式转换为给定的引用或可空值类型。即使转换不可能，它也不会抛出异常，但是在这种情况下，它会返回<code class="fe md me mf mg b">null</code>。所以通常情况下，它比<a class="ae ne" href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/type-testing-and-cast#cast-expression?WT.mc_id=DT-MVP-5001643" rel="noopener ugc nofollow" target="_blank"> cast表达式</a>更安全，但是我们仍然需要检查结果是否为<code class="fe md me mf mg b">null</code>。</p><p id="b51a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe md me mf mg b">is</code>操作符检查表达式结果的运行时类型是否与给定类型兼容。因此，使用以下代码更安全:</p><pre class="kp kq kr ks gt mh mg mi mj aw mk bi"><span id="9165" class="ml lb it mg b gy mm mn l mo mp">if (target is ControlA)<br/>{<br/>    var ctrl = target as ControlA;<br/>    ctrl.Status = newValue;<br/>}</span></pre><p id="1a36" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从C# 7开始，我们可以使用<code class="fe md me mf mg b">is</code>同时检查和转换类型:</p><pre class="kp kq kr ks gt mh mg mi mj aw mk bi"><span id="80eb" class="ml lb it mg b gy mm mn l mo mp">if (target is ControlA ctrl)<br/>{<br/>    //You can use ctrl variable directly now because the result is already assigned to it<br/>    ctrl.Status = newValue;<br/>}</span></pre><p id="f9ec" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">参考消息:<a class="ae ne" href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/type-testing-and-cast?WT.mc_id=DT-MVP-5001643" rel="noopener ugc nofollow" target="_blank">类型测试运算符和转换表达式</a></p><h1 id="cb5f" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">检查来自深度睡眠模式的DI容器的实例</h1><p id="629e" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">这个问题可能发生在移动设备上。如果我们对移动应用程序使用依赖注入，通常我们只是从DI容器中获取服务实例。但在移动设备上，我们需要处理太多棘手的情况，例如深度睡眠模式、后台任务和推送通知等。例如，如果用户点击通知来执行一些动作，DI容器可能还没有初始化。换句话说，应用的生命周期可能不是我们预期的那样。我已经遇到了一些相关的问题，但我不想在这里展开太多，因为它很少发生在其他应用程序。</p><h1 id="8e71" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">有没有更好的方法来代替<code class="fe md me mf mg b">if</code>语句进行空值检查？</h1><p id="d9d5" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">是的。您可以使用空条件运算符来简化它。用<code class="fe md me mf mg b">?</code>把表达式短路就行了。例如:</p><pre class="kp kq kr ks gt mh mg mi mj aw mk bi"><span id="eb75" class="ml lb it mg b gy mm mn l mo mp">A?.B?.Do(C)</span></pre><p id="f6db" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果<code class="fe md me mf mg b">A</code>为空，链的其余部分不执行。如果<code class="fe md me mf mg b">B</code>为空，则<code class="fe md me mf mg b">Do(C)</code>不执行。</p><p id="7ae3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">类似地，您可以使用<code class="fe md me mf mg b">?[]</code>进行元素访问。<code class="fe md me mf mg b">A?.B?[C]</code>例。即使<code class="fe md me mf mg b">B</code>为空也是安全的。</p><p id="6f70" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">调用delegate/Action/Func也是一个不错的选择。例如:</p><pre class="kp kq kr ks gt mh mg mi mj aw mk bi"><span id="b14f" class="ml lb it mg b gy mm mn l mo mp">class Counter<br/>{<br/>    public event EventHandler ThresholdReached;<br/>    protected virtual void OnThresholdReached(EventArgs e)<br/>    {<br/>        // Use ? to avoid null reference exception<br/>        ThresholdReached?.Invoke(this, e);<br/>    }<br/>}</span></pre><p id="e147" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">顺便说一下，如果它不是<code class="fe md me mf mg b">null</code>，您可以使用空合并操作符<code class="fe md me mf mg b">??</code>返回其左侧操作数的值；否则，它返回右操作数的值。例如，如果我们需要给一个变量赋值:</p><pre class="kp kq kr ks gt mh mg mi mj aw mk bi"><span id="62fe" class="ml lb it mg b gy mm mn l mo mp">if (variable is null)<br/>{<br/>    variable = expression;<br/>}</span></pre><p id="05c8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以下代码在C# 8.0中可用:</p><pre class="kp kq kr ks gt mh mg mi mj aw mk bi"><span id="3fc1" class="ml lb it mg b gy mm mn l mo mp">variable ??= expression;</span></pre><p id="f265" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">参考消息:<a class="ae ne" href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/member-access-operators?WT.mc_id=DT-MVP-5001643" rel="noopener ugc nofollow" target="_blank">成员访问运算符和表达式</a></p><p id="e0b3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae ne" href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/null-coalescing-operator?WT.mc_id=DT-MVP-5001643" rel="noopener ugc nofollow" target="_blank">零合并算子</a></p><h1 id="e693" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">使用<code class="fe md me mf mg b">TryParse()</code>，而不是<code class="fe md me mf mg b">Parse()</code></h1><p id="27fa" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">我认为大部分。NET开发人员已经知道了这一点。</p><h1 id="048b" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">任务/异步/等待</h1><p id="da6a" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">你可以在StackOverflow、GitHub或其他人的博客上找到大量关于<code class="fe md me mf mg b">Task</code>、<code class="fe md me mf mg b">async</code>和<code class="fe md me mf mg b">await</code>的帖子/问题/博客。我确实读过很多文章，但是我不会添加任何新的内容，我只想强调异步编程中的一些最佳实践。</p><h1 id="93bd" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">避免使用<code class="fe md me mf mg b">async void</code>方法，除非您将它用于事件处理程序</h1><p id="1069" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">如果<code class="fe md me mf mg b">async</code>方法可行，返回<code class="fe md me mf mg b">Task</code>或<code class="fe md me mf mg b">Task&lt;T&gt;</code>。如果你返回一个<code class="fe md me mf mg b">void</code>方法，编译器不会抱怨，但是这样不好，因为任何异常都会被吃掉，所以你不能正确地捕捉它。</p><p id="1c80" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一个特殊的场景是创建一个<code class="fe md me mf mg b">async</code>事件处理程序。通常事件处理程序不返回任何类型，它只返回<code class="fe md me mf mg b">void</code>。但是请确保您已经在事件处理程序中处理了可能的异常。对于所有其他情况，不要使用<code class="fe md me mf mg b">async void</code>方法。</p><h1 id="c4f1" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">避免将<code class="fe md me mf mg b">async</code>和<code class="fe md me mf mg b">sync</code>方法混合在一起</h1><p id="0d3a" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">我们应该记住<strong class="js iu">始终是异步的</strong>，这意味着我们不应该在大多数情况下混合异步和同步代码。更特别的是，<strong class="js iu">永远不要用</strong> <code class="fe md me mf mg b"><strong class="js iu">Task.Wait()</strong></code> <strong class="js iu">和</strong> <code class="fe md me mf mg b"><strong class="js iu">Task.Result</strong></code> <strong class="js iu">来阻塞异步代码</strong>。<code class="fe md me mf mg b">Task.Wait()</code>是同步的，可能会阻塞呼叫。如果我在代码审查中看到<code class="fe md me mf mg b">Task.Wait()</code>，这无疑是一个强烈的信号，表明代码可能导致死锁。此外，死锁导致的错误很难跟踪，所以请不要再使用它。</p><h1 id="9ccd" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">返回任务，不返回等待</h1><p id="0969" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">如果您已经有一个异步任务，并且您需要在另一个任务中调用它，只需返回该任务，而不是将其设为异步然后等待。例如:</p><pre class="kp kq kr ks gt mh mg mi mj aw mk bi"><span id="4e56" class="ml lb it mg b gy mm mn l mo mp">public async Task&lt;string&gt; GetDataFromApiAsync()<br/>{<br/>    //Do some async jobs<br/>}<br/>​<br/>// You can do it like this <br/>public async Task&lt;string&gt; GetDataAsync()<br/>{<br/>    return await GetDataFromApiAsync();<br/>}<br/>​<br/>// But this one is better<br/>public Task&lt;string&gt; GetData()<br/>{<br/>    // Just return the task<br/>    return GetDataFromApiAsync();<br/>}</span></pre><p id="951d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">每次我们将一个方法声明为async时，编译器都会创建一个状态机类来包装逻辑。所以如果你在方法中没有其他的<code class="fe md me mf mg b">await</code>，请直接返回任务。这有助于我们不创建额外的资源来在不同的线程之间切换。</p><h1 id="f134" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">如果我们不得不阻止异步代码呢？</h1><p id="da61" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">出于某种原因，我们必须将异步代码转换成同步代码，那么你最好使用<code class="fe md me mf mg b">Task.GetAwaiter().GetResult()</code>。对于<code class="fe md me mf mg b">Task.Wait()</code>来说也是一样，如果任务成功执行，好处是如果任务出错，它可以返回一个正常的异常。但是<code class="fe md me mf mg b">Task.Wait()</code>将异常包装在一个<code class="fe md me mf mg b">AggregateException</code>中，所以很难诊断这个问题。</p><h1 id="4647" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">使用<code class="fe md me mf mg b">Task.WhenAll()</code>运行多个任务</h1><p id="b89b" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">如果您有多个任务要执行，并且它们之间没有依赖关系，您可以使用<code class="fe md me mf mg b">await Task.WhenAll()</code>来并行运行它们。类似地，您可以使用<code class="fe md me mf mg b">Task.WhenAny()</code>等待任何任务完成，然后继续下一个代码。</p><h1 id="5748" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">使用<code class="fe md me mf mg b">ConfigureAwait(false)</code>避免死锁</h1><p id="d4d0" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated"><a class="ae ne" href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.synchronizationcontext?view=netcore-3.1&amp;WT.mc_id=DT-MVP-5001643" rel="noopener ugc nofollow" target="_blank"> SynchronizationContext </a>类提供了在各种同步模型中传播同步上下文的基本功能。基本上，使用<code class="fe md me mf mg b">ConfigureAwait(false)</code>可以提高性能，避免死锁。总的指导方针是:</p><ul class=""><li id="23e6" class="mq mr it js b jt ju jx jy kb ms kf mt kj mu kn mv mw mx my bi translated">不要在应用级代码中使用<code class="fe md me mf mg b">ConfigureAwait(false)</code>。</li><li id="42c4" class="mq mr it js b jt mz jx na kb nb kf nc kj nd kn mv mw mx my bi translated">在通用库代码中使用<code class="fe md me mf mg b">ConfigureAwait(false)</code>。</li></ul><p id="2213" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">换句话说，如果你正在开发一个Windows窗体/WPF/ASP。NET核心应用程序，通常你不需要使用它。但是如果你开发一个通用的库，你最好使用它，因为这个库不关心环境，所以不需要保持相同的<code class="fe md me mf mg b">SynchronizationContext</code>。</p><p id="7219" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我强烈推荐以下关于任务/异步/等待的文章:</p><ul class=""><li id="c50c" class="mq mr it js b jt ju jx jy kb ms kf mt kj mu kn mv mw mx my bi translated"><a class="ae ne" href="https://docs.microsoft.com/en-us/archive/msdn-magazine/2013/march/async-await-best-practices-in-asynchronous-programming?WT.mc_id=DT-MVP-5001643" rel="noopener ugc nofollow" target="_blank"> Async/Await —异步编程的最佳实践</a>—Stephen Cleary</li><li id="33f4" class="mq mr it js b jt mz jx na kb nb kf nc kj nd kn mv mw mx my bi translated"><a class="ae ne" href="https://blog.stephencleary.com/2012/02/async-and-await.html" rel="noopener ugc nofollow" target="_blank">异步等待</a>斯蒂芬·克利里</li><li id="4531" class="mq mr it js b jt mz jx na kb nb kf nc kj nd kn mv mw mx my bi translated">Stephen Toub的<a class="ae ne" href="https://devblogs.microsoft.com/pfxteam/asyncawait-faq/?WT.mc_id=DT-MVP-5001643" rel="noopener ugc nofollow" target="_blank">异步/等待常见问题解答</a></li><li id="304f" class="mq mr it js b jt mz jx na kb nb kf nc kj nd kn mv mw mx my bi translated">Stephen Toub的<a class="ae ne" href="https://devblogs.microsoft.com/dotnet/configureawait-faq/?WT.mc_id=DT-MVP-5001643" rel="noopener ugc nofollow" target="_blank">配置等待常见问题解答</a></li></ul><h1 id="d9ac" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">例外</h1><p id="e331" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">所有的应用程序都可能有例外。但是一个设计良好的应用程序可以处理异常和错误以防止崩溃。一些常见问题是:</p><h1 id="9d0e" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">抛出异常，不返回错误代码。</h1><p id="b90d" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">例外并不可怕。我见过一些代码试图隐藏异常，然后返回错误代码。这样不好，因为调用者可能不会检查返回代码。异常确保可以正确处理故障。</p><h1 id="3877" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">尽可能使用标准异常类型</h1><p id="9d7a" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">。NET框架已经提供了很多异常类型，例如<code class="fe md me mf mg b">ArgumentException</code>、<code class="fe md me mf mg b">ArgumentNullException</code>、<code class="fe md me mf mg b">InvalidOperationException</code>等。仅当预定义的异常类型不适用时，才引入新的异常类型。</p><h1 id="a126" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">为自定义异常提供附加属性</h1><p id="c7dd" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">如果您设计了自定义异常，请将附加信息附加到该异常，这对诊断很有用。例如，<code class="fe md me mf mg b">ArgumentNullException</code>具有参数名称属性，<code class="fe md me mf mg b">FileNotFoundException</code>具有<code class="fe md me mf mg b">FileName</code>属性。信息越多，调试就越容易。</p><h1 id="d4af" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">不要吃try-catch块中的异常</h1><p id="125d" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">我看过下面的代码:</p><pre class="kp kq kr ks gt mh mg mi mj aw mk bi"><span id="2dde" class="ml lb it mg b gy mm mn l mo mp">try<br/>{<br/>    // Do something<br/>}<br/>catch (Exception ex)<br/>{<br/>    // Log the exception<br/>    throw ex;<br/>}</span></pre><p id="83e5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这并不好，因为它会重置堆栈跟踪。正确的做法是:</p><pre class="kp kq kr ks gt mh mg mi mj aw mk bi"><span id="e4a6" class="ml lb it mg b gy mm mn l mo mp">try<br/>{<br/>    // Do something<br/>}<br/>catch (Exception ex)<br/>{<br/>    // Log the exception<br/>    throw;<br/>}</span></pre><p id="2076" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">用<code class="fe md me mf mg b">throw</code>保持原来的栈迹即可。所以打电话的人会知道发生了什么。此外，您可能会看到以下代码:</p><pre class="kp kq kr ks gt mh mg mi mj aw mk bi"><span id="95d0" class="ml lb it mg b gy mm mn l mo mp">catch (Exception ex)<br/>{<br/>    throw new MyException("error occurs", ex); // This will wrap the original stack trace<br/>    //or<br/>    throw new MyException("error occurs"); // This will replace the original stack trace<br/>}</span></pre><p id="9528" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以请确保正确地抛出异常。不要吃它们！</p><p id="3cce" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我推荐你阅读下面的文章:</p><ul class=""><li id="6b86" class="mq mr it js b jt ju jx jy kb ms kf mt kj mu kn mv mw mx my bi translated"><a class="ae ne" href="https://docs.microsoft.com/en-us/dotnet/standard/exceptions/best-practices-for-exceptions?WT.mc_id=DT-MVP-5001643" rel="noopener ugc nofollow" target="_blank">例外情况的最佳实践</a></li><li id="1733" class="mq mr it js b jt mz jx na kb nb kf nc kj nd kn mv mw mx my bi translated"><a class="ae ne" href="https://www.c-sharpcorner.com/UploadFile/a777ce/difference-between-throw-and-throw-ex-in-C-Sharp/" rel="noopener ugc nofollow" target="_blank">c#中Throw和Throw ex的区别</a></li></ul><h1 id="f37d" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">HttpClient</h1><p id="d353" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">说实话，这个<code class="fe md me mf mg b">HttpClient</code>班在。NET还不够好，因为每天都有很多开发人员在寻找如何正确使用它。所以这里有一些建议:</p><h1 id="be88" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">不要使用<code class="fe md me mf mg b">using</code>显式地处理<code class="fe md me mf mg b">HttpClient</code>实例</h1><p id="ab2a" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">我认为很多。NET开发人员已经知道了这一点。这是一些初级开发人员的常见错误，因为<code class="fe md me mf mg b">HttpClient</code>实现了<code class="fe md me mf mg b">IDisposable</code>接口。此外，您可能会在Microsoft官方文档的一些代码示例中找到以下代码:</p><pre class="kp kq kr ks gt mh mg mi mj aw mk bi"><span id="b0a3" class="ml lb it mg b gy mm mn l mo mp">using (var httpClient = new HttpClient())<br/>{<br/>    // Do something<br/>}</span></pre><p id="3c19" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是可以理解的，因为它是一个<code class="fe md me mf mg b">IDisposable</code>对象，我们应该使用<code class="fe md me mf mg b">using</code>语句。但是对于这种情况，上面的用法是完全错误的。我们应该为整个应用程序共享一个实例，而不是为每个请求创建一个新的实例。因为即使您处置了<code class="fe md me mf mg b">HttpClient</code>实例，底层的套接字连接也不能立即被处置(通常，在Windows上它会被保持240秒),所以如果您一次又一次地创建新的实例，可用的套接字端口将很快耗尽。</p><p id="96b7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正确的做法是为<code class="fe md me mf mg b">HttpClient</code>保留一个singleton实例。可以使用静态实例或者使用单例模式来维护<code class="fe md me mf mg b">HttpClient</code>实例。但是我们还有另一个问题。</p><h1 id="9ed6" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated"><code class="fe md me mf mg b">HttpClient</code>不考虑DNS更改</h1><p id="307c" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">对于大多数场景，为所有请求维护一个单一实例就足够了。英寸NET Framework 4.x，<code class="fe md me mf mg b">HttpClient</code>不考虑DNS更改。换句话说，如果端点更改了DNS记录(当我们执行蓝/绿部署时可能会发生这种情况)，当前的<code class="fe md me mf mg b">HttpClient</code>实例无法检测到这种更改，因此它将被阻塞，直到套接字连接关闭。在最近。网芯，已经改进了。</p><p id="81fa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">仅供参考:<a class="ae ne" href="http://byterot.blogspot.com/2016/07/singleton-httpclient-dns.html" rel="noopener ugc nofollow" target="_blank"> Singleton HttpClient？小心这种严重的行为以及如何修复它</a></p><p id="675d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae ne" href="https://github.com/dotnet/runtime/issues/18348" rel="noopener ugc nofollow" target="_blank">单例HttpClient不支持DNS更改</a></p><h1 id="9a93" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">指定<code class="fe md me mf mg b">HttpHeaders</code>为<code class="fe md me mf mg b">HttpClient</code>还是<code class="fe md me mf mg b">HttpRequestMessage</code>？</h1><p id="8af7" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">出于某种原因，我们需要指定<code class="fe md me mf mg b">HttpHeaders</code>。我们可以通过两种方式做到这一点:</p><ul class=""><li id="5f99" class="mq mr it js b jt ju jx jy kb ms kf mt kj mu kn mv mw mx my bi translated">使用<code class="fe md me mf mg b">HttpClient.DefaultRequestHeaders.Add()</code>更新<code class="fe md me mf mg b">HttpClient</code>实例的标题。</li><li id="1083" class="mq mr it js b jt mz jx na kb nb kf nc kj nd kn mv mw mx my bi translated">使用<code class="fe md me mf mg b">HttpRequestMessage.Headers.Add()</code>更新每个请求的标题。</li></ul><p id="8792" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第二种方式更好。因为通常我们会重用singleton <code class="fe md me mf mg b">HttpClient</code>实例。即使<code class="fe md me mf mg b">HttpClient</code>是线程安全的，如果我们频繁改变<code class="fe md me mf mg b">DefaultRequestHeaders</code>集合，也可能导致下面的<code class="fe md me mf mg b">InvalidOperationException</code>:</p><pre class="kp kq kr ks gt mh mg mi mj aw mk bi"><span id="b2fc" class="ml lb it mg b gy mm mn l mo mp">Operations that change non-concurrent collections must have exclusive access. A concurrent update was performed on this collection and corrupted its state. The collection's state is no longer correct.</span></pre><p id="f51e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">原因是<code class="fe md me mf mg b">HttpClient</code>的<code class="fe md me mf mg b">DefaultRequestHeaders</code>属性不是线程安全的。当有未完成的请求时，不应该修改它。仅供参考:<a class="ae ne" href="https://docs.microsoft.com/en-us/dotnet/api/system.net.http.httpclient.defaultrequestheaders?view=netcore-3.1?WT.mc_id=DT-MVP-5001643" rel="noopener ugc nofollow" target="_blank"> HttpClient。默认请求标题</a></p><h1 id="d5b0" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">重试请求</h1><p id="ccce" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">HTTP请求可能会失败，所以通常我们需要使用<strong class="js iu"> Polly </strong>来重试失败的请求。因此，您可能会看到另一个例外:</p><pre class="kp kq kr ks gt mh mg mi mj aw mk bi"><span id="fde1" class="ml lb it mg b gy mm mn l mo mp">InvalidOperation exception: The request message was already sent. Cannot send the same request message multiple times.</span></pre><p id="64fe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是因为Polly只是重试请求，而不是改变它。然而，如果<code class="fe md me mf mg b">HttpClient</code>检查到它发送了相同的请求，它将抛出上述异常。解决方案很简单——只需创建一个<code class="fe md me mf mg b">clone()</code>方法来创建请求的另一个副本:</p><pre class="kp kq kr ks gt mh mg mi mj aw mk bi"><span id="77cf" class="ml lb it mg b gy mm mn l mo mp">public static HttpRequestMessage Clone(this HttpRequestMessage req)<br/>{<br/>    HttpRequestMessage clone = new HttpRequestMessage(req.Method, req.RequestUri);<br/>​<br/>    clone.Content = req.Content;<br/>    clone.Version = req.Version;<br/>​<br/>    foreach (KeyValuePair&lt;string, object&gt; prop in req.Properties)<br/>    {<br/>        clone.Properties.Add(prop);<br/>    }<br/>​<br/>    foreach (KeyValuePair&lt;string, IEnumerable&lt;string&gt;&gt; header in req.Headers)<br/>    {<br/>        clone.Headers.TryAddWithoutValidation(header.Key, header.Value);<br/>    }<br/>​<br/>    return clone;<br/>}</span></pre><p id="aa93" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">参考消息:<a class="ae ne" href="https://github.com/App-vNext/Polly/issues/313" rel="noopener ugc nofollow" target="_blank">Polly如何防止InvalidOperation异常SendAsync </a></p><p id="ac31" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">英寸NET Core 2.1，微软提供<code class="fe md me mf mg b">HttpClientFactory</code>试图解决一些问题。它更好，但我不喜欢的一点是它与微软的DI紧密结合。下面是GitHub上一个有趣的线程:<a class="ae ne" href="https://github.com/dotnet/extensions/issues/1345" rel="noopener ugc nofollow" target="_blank">使用HttpClientFactory而不依赖注入</a>。</p><h1 id="cbf4" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">收藏/列表</h1><p id="0178" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">. NET中有太多关于<code class="fe md me mf mg b">Collections</code> / <code class="fe md me mf mg b">List</code>的话题，但我只想在这里强调以下提示:</p><h1 id="1ff1" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">总是在声明集合时初始化它</h1><p id="1d33" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">哦，我刚刚意识到我在这篇文章的开头提到过它。所以请记住这一点，因为当我做代码审查的时候，我已经在这个问题上挣扎过很多次了。</p><h1 id="cefe" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated"><code class="fe md me mf mg b">ToList()</code>首先还是直接用<code class="fe md me mf mg b">foreach</code>代替<code class="fe md me mf mg b">IEnumerable</code>？</h1><p id="a202" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">我相信你已经看到了下面的代码:</p><pre class="kp kq kr ks gt mh mg mi mj aw mk bi"><span id="8159" class="ml lb it mg b gy mm mn l mo mp">// GetList() will return an IEnumerable object<br/>foreach (var item in GetList())<br/>{<br/>    await HandleItemAsync(item);<br/>}</span></pre><p id="8ea0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们确切地知道，当我们对一个<code class="fe md me mf mg b">IEnumerable</code>对象使用<code class="fe md me mf mg b">foreach</code>时，它将遍历整个集合。对于大多数场景，这一个也是一样的:</p><pre class="kp kq kr ks gt mh mg mi mj aw mk bi"><span id="48f2" class="ml lb it mg b gy mm mn l mo mp">foreach (var item in GetList().ToList())<br/>{<br/>    await HandleItemAsync(item);<br/>}</span></pre><p id="3103" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">不同之处在于，当您使用<code class="fe md me mf mg b">IEnumerable</code>时，编译器有机会将工作推迟到以后，有可能优化方式。如果使用<code class="fe md me mf mg b">ToList()</code>，编译器会强制立即得到结果。一个例子是，当我们从数据库中查询数据时，我们通常有LINQ条件，所以最好推迟评估，直到我们执行它。但在这种情况下，我们应该意识到<code class="fe md me mf mg b">foreach</code>体内的<code class="fe md me mf mg b">async</code>方法。考虑这个场景:假设我们有一个Azure blob。我们需要获取blob存储中的所有文件，然后删除它们。所以代码可能是这样的:</p><pre class="kp kq kr ks gt mh mg mi mj aw mk bi"><span id="aa32" class="ml lb it mg b gy mm mn l mo mp">var files = container.ListBlobs(null, true, BlobListingDetails.None);// List all the files in the blob. It will return an IEnumerable object.<br/>foreach (var file in files)<br/>{<br/>    await file.DeleteIfExistsAsync();<br/>}</span></pre><p id="8725" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">好像不错。但风险在于这是一个云应用。<code class="fe md me mf mg b">ListBlobs()</code>如果无法在指定持续时间内完成，方法可能会超时。因此，如果有一堆文件要删除，对于<code class="fe md me mf mg b">ListBlobs()</code>方法来说会花费相当多的时间。然后你会得到一个超时异常。</p><p id="dfa3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以安全的方法是在进行迭代之前使用<code class="fe md me mf mg b">ToList()</code>:</p><pre class="kp kq kr ks gt mh mg mi mj aw mk bi"><span id="f6b4" class="ml lb it mg b gy mm mn l mo mp">var files = container.ListBlobs(null, true, BlobListingDetails.None).ToList();// List all the files in the blob then convert to a List.<br/>foreach (var file in files)<br/>{<br/>    await file.DeleteIfExistsAsync();<br/>}</span></pre><p id="ac2c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在你马上查询文件列表。那么就不需要担心超时问题了。所以不好说哪种方法更好。看情况。</p><h1 id="7f63" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">IEnumerable的可能多重枚举</h1><p id="8a0f" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">如果使用Resharper，您可能会看到此警告。以下代码来自Jetbrains:</p><pre class="kp kq kr ks gt mh mg mi mj aw mk bi"><span id="2686" class="ml lb it mg b gy mm mn l mo mp">IEnumerable&lt;string&gt; names = GetNames();<br/>foreach (var name in names)<br/>    Console.WriteLine("Found " + name);<br/>var allNames = new StringBuilder();<br/>foreach (var name in names)<br/>    allNames.Append(name + " ");</span></pre><p id="bb05" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">假设<code class="fe md me mf mg b">GetNames()</code>返回一个<code class="fe md me mf mg b">IEnumerable&lt;string&gt;</code>，代码在两个<code class="fe md me mf mg b">foreach</code>语句中进行两次枚举。如果<code class="fe md me mf mg b">GetNames()</code>查询数据库或者调用一个API，这两个调用可能会得到不同的结果，因为原始数据已经被其他进程改变了。所以可以通过将<code class="fe md me mf mg b">IEnumerable&lt;string&gt;</code>转换为<code class="fe md me mf mg b">List</code>来解决:</p><pre class="kp kq kr ks gt mh mg mi mj aw mk bi"><span id="40fc" class="ml lb it mg b gy mm mn l mo mp">List&lt;string&gt; names = GetNames().ToList();</span></pre><p id="6889" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以这两个枚举会得到相同的结果。</p><h1 id="9807" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">并发收款</h1><p id="98b2" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated"><code class="fe md me mf mg b">List</code>和<code class="fe md me mf mg b">Dictionary</code>不是线程安全的。考虑在多线程情况下使用并发收集。你可以在这里找到更多信息:<a class="ae ne" href="https://docs.microsoft.com/en-us/dotnet/api/system.collections.concurrent?view=netcore-3.1?WT.mc_id=DT-MVP-5001643" rel="noopener ugc nofollow" target="_blank">系统。Collections.Concurrent命名空间</a></p><h1 id="1c12" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">多方面的</h1><h1 id="7345" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated"><code class="fe md me mf mg b">==</code>还是<code class="fe md me mf mg b">Equals</code>？</h1><p id="a8a2" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">它们都用于比较两个值类型数据项或引用类型数据项。不同的是，如果它们引用同一个对象，<code class="fe md me mf mg b">==</code>将返回<code class="fe md me mf mg b">true</code>。如果内容相同，<code class="fe md me mf mg b">Equals()</code>返回<code class="fe md me mf mg b">true</code>。所以他们不一样。仅供参考:</p><ul class=""><li id="594a" class="mq mr it js b jt ju jx jy kb ms kf mt kj mu kn mv mw mx my bi translated"><a class="ae ne" href="https://docs.microsoft.com/en-us/dotnet/api/system.object.equals?view=netcore-3.1?WT.mc_id=DT-MVP-5001643" rel="noopener ugc nofollow" target="_blank">对象。等于方法</a></li><li id="cdfc" class="mq mr it js b jt mz jx na kb nb kf nc kj nd kn mv mw mx my bi translated"><a class="ae ne" href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/equality-operators?WT.mc_id=DT-MVP-5001643" rel="noopener ugc nofollow" target="_blank">相等运算符(C#参考)</a></li><li id="cf0f" class="mq mr it js b jt mz jx na kb nb kf nc kj nd kn mv mw mx my bi translated"><a class="ae ne" href="https://www.c-sharpcorner.com/UploadFile/3d39b4/difference-between-operator-and-equals-method-in-C-Sharp/" rel="noopener ugc nofollow" target="_blank">c#中等号运算符(==)和Equals()方法的区别</a></li></ul><h1 id="869f" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">对抽象类使用<code class="fe md me mf mg b">protected</code>构造函数</h1><p id="ee1e" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">去做吧。</p><h1 id="5b1c" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">事件模式</h1><p id="ae61" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">我遇到了一个关于事件模式的错误。基本上，该类维护一个全局状态字段。如果应用程序检测到状态变化，该类将发布一个事件来通知订阅者。但是它首先发布事件，然后更新全局状态字段。所以当调用者收到事件时，全局状态可能还没有改变。它导致了间歇性故障。因此，如果调用者需要使用一些全局值，请确保发布者首先更新状态，然后发布事件。</p><h1 id="6d7c" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">删除无用的代码</h1><p id="71af" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">如果有些代码没有用，可以为当前版本添加<code class="fe md me mf mg b">Obsolete</code>属性。然后在未来的版本中彻底删除它们。没有必要在你的解决方案中保留无用的代码。它很丑。我见过很多被评论的代码，但是我不知道为什么它们还在那里。以后还会恢复吗？没人知道。所以如果你不需要，请删除它。或者你可以留下评论，说明为什么要暂时保留它。</p><h1 id="87f1" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">不要对一个方法使用太多的参数。</h1><p id="8028" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">如果一个方法有太多的参数，考虑将它作为一个类来重构。</p><h1 id="b2bd" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">摘要</h1><p id="1338" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">这是一个杂乱的笔记，但事实上我遇到过这些问题很多次。当我有更多的想法时，我可以在这个系列中添加更多的主题。谢了。</p></div></div>    
</body>
</html>