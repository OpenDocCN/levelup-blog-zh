<html>
<head>
<title>Build Auth Once with a Shared Lambda Authorizer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用共享的Lambda授权器构建一次授权</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/build-auth-once-with-a-shared-lambda-authorizer-9936dc7e7897?source=collection_archive---------11-----------------------#2021-02-12">https://levelup.gitconnected.com/build-auth-once-with-a-shared-lambda-authorizer-9936dc7e7897?source=collection_archive---------11-----------------------#2021-02-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/d3bcbee3938bad99d270f72d4640cd37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kft0xHI5eAgd9qXQX5isfg.jpeg"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">图片来自<a class="ae jg" href="https://pixabay.com/?utm_source=link-attribution&amp;amp;utm_medium=referral&amp;amp;utm_campaign=image&amp;amp;utm_content=2168233" rel="noopener ugc nofollow" target="_blank">皮克斯拜</a></figcaption></figure><div class=""/><div class=""><h2 id="4301" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">大型组织使用许多AWS帐户来管理他们的应用程序。了解如何在所有帐户之间共享一个lambda authorizer，这样您只需构建auth一次。</h2></div><p id="c1b1" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">每个人都有关于如何使用AWS账户的意见。</p><p id="ed94" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有些人认为你应该有一个单一账户，把你的AWS生态系统中的所有东西都存储在一个地方。</p><p id="7c7c" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">其他人认为一个单独的应用程序(由多个微服务组成)属于一个单独的AWS帐户。</p><p id="0080" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">而其他人则走极端，在AWS账户中保留单个微服务。</p><p id="50ab" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这些方法没有一个是无意中出错的(除了你可能会遇到一些单一账户的<a class="ae jg" href="https://docs.aws.amazon.com/general/latest/gr/aws_service_limits.html" rel="noopener ugc nofollow" target="_blank">资源限制</a>，但是它们都遇到了同样的问题:</p><p id="5aad" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="lu">您如何在不同账户间保持一致的授权？</em></p><p id="7a4e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您使用定制的Lambda授权器，答案既简单又不那么简单。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="e4fb" class="mc md jj bd me mf mg mh mi mj mk ml mm kp mn kq mo ks mp kt mq kv mr kw ms mt bi translated">什么是Lambda授权器？</h1><p id="b198" class="pw-post-body-paragraph ky kz jj la b lb mu kk ld le mv kn lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">如果你选择阅读这篇文章，你可能已经知道什么是λ授权者。</p><p id="f3d6" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是作为一个补充，<em class="lu">Lambda authorizer是一个API网关特性，它使用Lambda函数来执行对API调用的授权。</em></p><p id="9903" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它可以验证OAuth或SAML令牌，应用一些业务逻辑来确定访问，以及介于两者之间的任何事情。</p><p id="2ca0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于无服务器应用程序，在API网关上安装一个Lambda授权器会很有用，有助于对各个端点的控制进行微调。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7040" class="mc md jj bd me mf mg mh mi mj mk ml mm kp mn kq mo ks mp kt mq kv mr kw ms mt bi translated">在SAM中定义Lambda授权者</h1><p id="33a5" class="pw-post-body-paragraph ky kz jj la b lb mu kk ld le mv kn lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated"><a class="ae jg" href="https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/what-is-sam.html" rel="noopener ugc nofollow" target="_blank">无服务器应用模型(SAM) </a>是CloudFormation之上的一层，旨在使无服务器应用的定义变得简单易行。</p><p id="4d18" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了最简单的易用性和可移植性，本文中的所有示例都将在SAM模板中定义，因此您可以将学到的内容立即部署到您自己的AWS帐户中。不需要摸索通过控制台。</p><p id="0c43" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">λ授权器只是一个函数。它的声明方式没有什么特别的。它只是期望一个<a class="ae jg" href="https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-lambda-authorizer-input.html" rel="noopener ugc nofollow" target="_blank">不同的事件主体</a>而不是一个由API网关代理的Lambda。</p><p id="f672" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在<a class="ae jg" href="https://github.com/allenheltondev/aws-cross-account-lambda-authorizer" rel="noopener ugc nofollow" target="_blank">我的示例repo </a>中，我们这样定义Lambda授权器:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="7e43" class="ni md jj ne b gy nj nk l nl nm">LambdaAuthorizerCrossAccountFunction: <br/>  Type: AWS::Serverless::Function <br/>  Properties: <br/>    CodeUri: lambdas/lambda-authorizer<br/>    Runtime: nodejs12.x<br/>    Handler: lambda-authorizer.lambdaHandler<br/>    Role: !GetAtt LambdaAuthorizerRole.Arn<br/>     FunctionName: LambdaAuthorizer</span></pre><p id="fefc" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">示例repo有SAM模板，但没有实现授权者的代码。例如构建授权器本身，AWS在GitHub 上有<a class="ae jg" href="https://github.com/awslabs/aws-apigateway-lambda-authorizer-blueprints" rel="noopener ugc nofollow" target="_blank">蓝图。</a></p><p id="6790" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">定义了授权者功能后，下一步是允许其他帐户使用它。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1e98" class="mc md jj bd me mf mg mh mi mj mk ml mm kp mn kq mo ks mp kt mq kv mr kw ms mt bi translated">建筑授权者权限</h1><p id="563d" class="pw-post-body-paragraph ky kz jj la b lb mu kk ld le mv kn lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">对于AWS来说，跨帐户权限可能很棘手。需要在源帐户中定义权限，以允许消费者访问他们的资源。这意味着你必须提前了解你的消费者(老实说，这是一件好事)。</p><p id="acec" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有了Lambda授权器，权限就一目了然了。您必须在消费者帐户中授予API Gateway执行授权者功能的权限。</p><figure class="mz na nb nc gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nn"><img src="../Images/2e919a4ee7742b4b0577e6e0d3615d1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*lG7Amg7Tuwv1W_iG.jpg"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated"><em class="no">其他账户中API网关如何使用Lambda授权器的示意图</em></figcaption></figure><p id="35e6" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我们的SAM模板中，所需的权限定义为:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="edf0" class="ni md jj ne b gy nj nk l nl nm">ConsumerOneAuthorizerPermission: <br/>  Type: AWS::Lambda::Permission <br/>  Properties: <br/>    Action: lambda:InvokeFunction<br/>    FunctionName: !Ref LambdaAuthorizerCrossAccountFunction <br/>    Principal: apigateway.amazonaws.com<br/>    SourceArn: !Sub arn:${AWS::Partition}:execute-api:${AWS::Region}:${ConsumerOneAccountId}:*/authorizers/*</span></pre><p id="4ca1" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个代码片段说API网关，即<em class="lu">主体</em>，被允许调用一个具有特定名称的函数。<em class="lu"> SourceArn </em>表示允许哪个资源执行该功能。我已经参数化了帐户id以及AWS分区(商业或GovCloud)和区域。</p><p id="c1f9" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">每个消费账户都需要一个权限来执行授权。由于我们正在实践POLP，这似乎是一个值得的权衡，因为随着时间的推移，我们将不得不保持这一点，因为我们为组织带来了新的客户。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9a24" class="mc md jj bd me mf mg mh mi mj mk ml mm kp mn kq mo ks mp kt mq kv mr kw ms mt bi translated">在另一个账户中使用授权人</h1><p id="4825" class="pw-post-body-paragraph ky kz jj la b lb mu kk ld le mv kn lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">这就是乐趣的开始。随着授权器的建立和权限的创建，我们可以设置我们的消费帐户来开始使用它。</p><p id="949e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我们的一个消费帐户的SAM模板中，无服务器API和授权者是用下面的代码片段定义的:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="d251" class="ni md jj ne b gy nj nk l nl nm">ConsumerServiceApi: <br/>  Type: AWS::Serverless::Api <br/>  Properties: <br/>    StageName: test<br/>    Auth: <br/>      DefaultAuthorizer: LambdaAuthorizer<br/>      AddDefaultAuthorizerToCorsPreflight: false<br/>      Authorizers: <br/>        LambdaAuthorizer: <br/>          FunctionPayloadType: REQUEST<br/>          FunctionArn: !Sub arn:${AWS::Partition}:lambda:${AWS::Region}:${AuthorizerAccountId}:function:LambdaAuthorizer <br/>        Identity: <br/>          Headers: <br/>            - Authorization <br/>          ReauthorizeEvery: 3600</span></pre><p id="b9b0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里要注意的主要部分是我们正在创作的<code class="fe np nq nr ne b">FunctionArn</code>。为了安全起见，我们将<code class="fe np nq nr ne b">AuthorizerAccountId</code>存储在一个参数中，并在部署时将其传入，这样帐户id就不会出现在源代码中。</p><p id="1ce2" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这类似于我们在上面定义授权者本身时所做的。它组装arn并使用它来指向我们想要的资源。</p><p id="001f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">部署该模板时(<a class="ae jg" href="https://github.com/allenheltondev/aws-cross-account-lambda-authorizer#usage" rel="noopener ugc nofollow" target="_blank">参见部署说明</a>)，将在消费者账户中创建一个Lambda授权人，其使用的功能位于授权人账户中。</p><p id="ebb1" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这就把我带到了最后一部分:SAM缺陷的解决方案。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="dfc3" class="mc md jj bd me mf mg mh mi mj mk ml mm kp mn kq mo ks mp kt mq kv mr kw ms mt bi translated">修复故障</h1><p id="21b3" class="pw-post-body-paragraph ky kz jj la b lb mu kk ld le mv kn lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">SAM模板只是一个花哨的CloudFormation脚本，它有一堆在部署时转换的别名。SAM提供了创建无服务器功能和所述功能的触发器的简单快捷方式。</p><p id="f7a3" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在部署时，由AWS维护的一个<code class="fe np nq nr ne b">Transform</code>被调用，以获取规范中写的快捷方式，并将它们转换成完整的CloudFormation资源。将<a class="ae jg" href="https://docs.aws.amazon.com/whitepapers/latest/introduction-devops-aws/infrastructure-as-code.html" rel="noopener ugc nofollow" target="_blank">基础设施写成代码</a>要简单得多。</p><p id="8602" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">不幸的是，这个转换中有一个错误，它阻止我们在不同的帐户中使用Lambda authorizer。</p><p id="777d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">SAM尝试将lambda权限从消费者帐户中的授权者配置到授权者帐户中的功能。由于IAM的工作方式，设置权限方向不起作用。</p><figure class="mz na nb nc gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ns"><img src="../Images/861339566bcc015cf9cb5ef92d4a38b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*igUjictRb7oqu9Po.jpg"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated"><em class="no">必须在资源所在的帐户中声明对跨帐户资源的权限</em></figcaption></figure><p id="d961" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">SAM尽量友好地配置授权者调用该功能所需的权限。但是它不知道该函数存在于另一个帐户中，因此它创建的权限将使部署失败。</p><p id="0f05" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了解决这个问题，我们可以创建一个CloudFormation宏来自动删除权限。</p><p id="101e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae jg" rel="noopener ugc nofollow" target="_blank" href="/automate-your-automation-with-cloudformation-macros-e3dc36f62ade">宏是在部署时运行的函数</a>，为您自动转换资源。在这种情况下，我们希望删除由SAM生成的权限资源。</p><p id="d783" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我在NodeJS中创建了一个宏，完全改编自报告的GitHub问题中的示例，并将其添加到<a class="ae jg" href="https://github.com/allenheltondev/aws-cross-account-lambda-authorizer/blob/main/prerequisites/template.yaml" rel="noopener ugc nofollow" target="_blank">示例报告</a>中的<code class="fe np nq nr ne b">prerequisite</code>堆栈中。</p><p id="c5b9" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">创建并部署宏后，必须更新所有使用交叉帐户授权者的堆栈才能使用它。</p><p id="808f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在您的SAM模板中，有一个<code class="fe np nq nr ne b">Transform</code>属性已经调用了AWS SAM宏。要添加Lambda authorizer宏，我们可以将该属性设为数组，它将在部署时开始运行。</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="e7a2" class="ni md jj ne b gy nj nk l nl nm">AWSTemplateFormatVersion: '2010-09-09' <br/>Transform: [ AWS::Serverless-2016-10-31, RemoveAuthorizerLambdaPermissions ] <br/>Description: &gt; <br/>  Consumer Stack. This AWS Account will consume the authorizer created in the *authorizer stack*</span></pre><p id="2bbb" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有了这个宏，消费者栈就可以部署了，你就有了一个跨账户Lambda授权者！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6e3e" class="mc md jj bd me mf mg mh mi mj mk ml mm kp mn kq mo ks mp kt mq kv mr kw ms mt bi translated">最后的想法</h1><p id="42eb" class="pw-post-body-paragraph ky kz jj la b lb mu kk ld le mv kn lg lh mw lj lk ll mx ln lo lp my lr ls lt im bi translated">重用代码和资源是大规模可维护性的关键。只要有意义，就尽量重复使用。授权/认证是可重用性的完美例子，也为您的应用程序提供了一种内聚的感觉。</p><p id="32ab" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">每个人都想重新发明轮子，自己造。这就是开发者的本性。当您在整个组织中使用代码、资源、API和其他特性时，需要治理，这不仅仅是一个技术问题。</p><p id="07a9" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">消除技术障碍是第一步。第二步是付诸行动。</p><p id="bf54" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我已经向您展示了在您的软件生态系统中维护一致授权的第一步。</p><p id="59a1" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在轮到你了。</p></div></div>    
</body>
</html>