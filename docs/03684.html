<html>
<head>
<title>Continuous delivery with Flux</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通量连续输送</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/continuous-delivery-with-flux-c9b9f7523cd6?source=collection_archive---------12-----------------------#2020-05-22">https://levelup.gitconnected.com/continuous-delivery-with-flux-c9b9f7523cd6?source=collection_archive---------12-----------------------#2020-05-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="84bc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首字母缩写词“CI/CD”及其相应的短语(<a class="ae kl" href="https://www.atlassian.com/continuous-delivery/principles/continuous-integration-vs-delivery-vs-deployment" rel="noopener ugc nofollow" target="_blank"> <em class="km">持续集成&amp;持续[交付|部署】</em> </a>)有时会混淆在一起，然而<strong class="jp ir">对每一个都有明确的定义</strong>和界限，尽管有许多CI/CD产品使您能够使用相同的工具使用单个框架来实现CI/CD等式的两个方面。</p><p id="f783" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">连续交付的意图非常简单:获取一个构建的、测试的、验证的工件，并将其“交付或部署”到一个或多个目标执行环境中。CI/CD系统中的“工件”到底是什么完全取决于每个应用程序和目标执行环境。它可能是要部署到一组虚拟机的NPM包、JAR文件或ZIP文件；或者它可以是一个Docker映像，需要部署到一个容器运行时或容器编排器，如Kubernetes。</p><p id="ee36" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于Kubernetes部署目标，CI/CD等式的<strong class="jp ir"> <em class="km">交付方</em> </strong>的工具之一是<a class="ae kl" href="https://fluxcd.io/" rel="noopener ugc nofollow" target="_blank"> Flux </a> a <a class="ae kl" href="https://www.cncf.io/" rel="noopener ugc nofollow" target="_blank"> CNCF沙盒项目</a> t</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi kn"><img src="../Images/6961915a165ae35a1825ee2994f8a546.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*L7hVYlw9ZHKaeGNa"/></div></div></figure><h1 id="c3f7" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">Flux: GitOps centric k8s交付</h1><p id="250e" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">首先，仅供参考；这篇文章纯粹是基于我个人使用<a class="ae kl" href="https://github.com/fluxcd/flux" rel="noopener ugc nofollow" target="_blank"> Flux </a>的经验，主要是针对我个人的CD使用案例。这篇文章并没有详尽地涵盖每一个Flux特性或功能。</p><p id="cb48" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当你看到无数不同的CI/CD平台、框架和基于云的服务时，<a class="ae kl" href="https://github.com/fluxcd/flux" rel="noopener ugc nofollow" target="_blank"> Flux </a>脱颖而出有几个原因。首先，它<strong class="jp ir"> <em class="km">只处理CI/CD中“斜杠”的连续交付</em> </strong>方(Flux不用于构建工件)，其次，它专门针对Kubernetes执行环境，第三，它以GitOps为中心。</p><p id="498f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，你问的“GitOps”是什么？每当你开发定制软件时，CI/CD管道确实是软件..)一般你要把你系统的“状态”或者“期望状态”存储在某个地方；这可能是一个RDBMS，NoSQL数据库系统等等……使用GitOps，你可以用Git描述你的系统的预期状态，并利用Git为历史等提供的所有内置结构和功能，而不是自己编写所有的内容。Git成为您的系统在一段时间内所采取的所有操作的历史和血统的最终来源。通过利用Git作为所有行为的来源，您可以(理论上)总是将您的状态“重置”回任何先前的时间点；当然，这取决于所述状态的消费者的能力。</p><p id="1d02" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以说到底，GitOps基本上是一种开发运维的方式，对Git库的更改会触发您环境中的所有下游操作，这正是Flux在其中运行的范例。值得注意的是，这个驱动CD系统的Git存储库<em class="km">可能是也可能不是CI系统用来构建工件的存储库，CD系统随后将这些工件交付给目标执行环境；<em class="km">也就是说，您可以将CD系统状态配置存储在与您的应用程序源代码完全不同的存储库中。</em></em></p><h1 id="32df" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">Flux高层架构</h1><p id="72ff" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">使用Flux，您可以<a class="ae kl" href="https://docs.fluxcd.io/en/latest/tutorials/get-started-helm/" rel="noopener ugc nofollow" target="_blank">将Flux守护进程</a>安装到目标Kubernetes集群上，您希望该集群成为您的CD系统的目标(即应用程序工件被部署到的地方)。每个Flux守护进程都与一个Git存储库有一对一的关系，守护进程从这个存储库中获取配置，告诉Flux应该将什么“状态”应用于Flux守护进程所在的k8s集群。(即Git repo包含标准k8s YAML清单和/或<em class="km"> HelmRelease </em>图表声明)。Flux基本上对这个Git存储库中的变化做出反应，并通过应用更新的k8s YAML清单(或通过<a class="ae kl" href="https://github.com/fluxcd/helm-operator" rel="noopener ugc nofollow" target="_blank"> Flux helm-operator </a>调用集群本身内的Helm来调用<em class="km"> HelmReleases </em>)在Kubernetes中做出必要的改变。(仅供参考，Flux <a class="ae kl" href="https://docs.fluxcd.io/en/1.19.0/references/fluxyaml-config-files/" rel="noopener ugc nofollow" target="_blank">也可以通过Kustomize等工具选择性地生成原始k8s YAML清单</a>)</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi mc"><img src="../Images/f63b1fb33aa90cc2c3eb4b38ba702625.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DF3K23WGY4musVwu"/></div></div></figure><p id="2574" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Flux还有一个额外的好处，那就是它可以通过它的“自动化”特性对每个Docker <em class="km">映像:标签</em>进行监控，这些映像和标签在Git存储库的k8s YAML或<em class="km"> HelmReleases </em>中被引用。这样做的效果是，当新的Docker映像版本被推送到映像注册表时，Flux可以检测到这一点，并使用检测到的新映像标签自动更新先前应用的k8s YAML，将更改应用到集群(并随后使用新的映像引用双向更新Flux关联的Git储存库)。第三…您可以通过一个名为的CLI工具在Flux守护进程上手动强制进行更改，一旦应用了您请求的更改，它将再次反映到Git存储库中，以确保声明的状态是最新的。例如，您可以通过<a class="ae kl" href="https://docs.fluxcd.io/en/1.19.0/references/fluxctl/" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> <em class="km"> fluxctl </em> </strong> </a>手动更新名为“workload”的运行中的Flux，将pod更新到集群上的新映像，并依次更新Flux git存储库中的YAML/赫尔姆版本配置……完成所有良好的git沿袭、历史和跟踪。<em class="km"> fluxctl </em> CLI具有<a class="ae kl" href="https://docs.fluxcd.io/en/1.19.0/references/fluxctl/" rel="noopener ugc nofollow" target="_blank">众多其他功能</a>，如锁定/解锁、回滚、切换工作负载自动化等。</p><p id="a7eb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">哇，那是一堆…这里有一个总结，你可以用Flux控制什么得到<em class="km">【持续交付】</em>你的Kubernetes集群。</p><ul class=""><li id="73cc" class="md me iq jp b jq jr ju jv jy mf kc mg kg mh kk mi mj mk ml bi translated"><strong class="jp ir">手动更改并提交Flux Git repo中更新的k8s清单或Helm配置？</strong> <em class="km"> Flux可以自动应用到集群。</em></li><li id="cca7" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated"><strong class="jp ir">新<em class="km">图片:标签</em>被CI系统推送到一个注册表中，用于一个Flux工作负载？</strong> <em class="km"> Flux可以自动应用到集群并更新Flux Git repo。</em></li><li id="f05f" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated"><strong class="jp ir">通过fluxctl CLI手动调整工作量？</strong> <em class="km"> Flux可以自动应用到集群并更新Flux Git repo。</em></li><li id="4a16" class="md me iq jp b jq mm ju mn jy mo kc mp kg mq kk mi mj mk ml bi translated"><strong class="jp ir">通过kubectl或其他非通量工具/api对正在运行的k8s工作负载进行更改？<em class="km">没有！</em> </strong> <em class="km">通量不会检测到这种变化。</em></li></ul><p id="13e0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">总的来说……我想:正是这种功能让Flux给人留下了深刻的印象。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi mr"><img src="../Images/b26c7994ab750548489ff0ecc6fb5437.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5Vc129KUIBrT1YJZNMCVTQ.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated"><em class="mw"> Vanilla Flux行为:监视其k8s YAML清单的Git存储库和可选的docker注册表，以发现要应用于目标k8s集群的更改。</em></figcaption></figure><h1 id="e21e" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">通量和舵</h1><p id="327e" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">开箱即用，Flux只能处理基本标准的Kubernetes“种类”的YAML货单(静态的或<a class="ae kl" href="https://docs.fluxcd.io/en/1.19.0/references/fluxyaml-config-files/" rel="noopener ugc nofollow" target="_blank">生成的</a>，想<em class="km">吊舱</em>，<em class="km">部署</em>等。).但是如果你的应用是通过Helm管理的呢？正如前面提到的，这就是<a class="ae kl" href="https://github.com/fluxcd/helm-operator" rel="noopener ugc nofollow" target="_blank">通量舵操作员项目</a>的目的。在k8s集群上安装helm-operator(与Flux守护进程安装在同一个集群上)。运营商增加了对新赫尔姆CRD API(<em class="km">“helm . fluxcd . io/v1”</em>)的支持，该API支持“<em class="km"> HelmRelease </em>类型的新k8s API“种类”。有了HelmRelease清单，你可以声明你想要安装/升级哪个图表，它的值等等，就像管理Helm release的类似工具一样，比如<a class="ae kl" href="https://github.com/roboll/helmfile" rel="noopener ugc nofollow" target="_blank"> helmfile </a>。简而言之，你在YAML宣布舵释放。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi mx"><img src="../Images/9733a61991ee75953bb127b58a6a1c10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U-hQTE1RWQa39QxzObrx6w.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated"><em class="mw"> helm-operator增强的Flux行为:监控其“helmRelease”清单的Git存储库和可选的docker注册表，以发现要应用于目标k8s集群的更改，这些更改通过在集群本身内执行的Helm进行安装/更新。</em></figcaption></figure><p id="2c66" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么这些Flux Git仓库和它的内容实际上是什么样子的呢？对于我的用例，我使用helm-operator自动安装应用程序，使用<a class="ae kl" href="https://github.com/bitsofinfo/appdeploy" rel="noopener ugc nofollow" target="_blank"> appdeploy Helm chart </a>，使用<em class="km">Helm release</em>“Kind】和在原始k8s YAML清单中声明的各种配置图。这里有一个非常简单的例子:</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="gh gi my"><img src="../Images/7a8db96661a1abf199ebc974f397fb8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wA8E7jrmrjtotv4Dd7zg3A.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated"><em class="mw">Flux守护进程监控的Git存储库及其内容的示例视图。Flux将自动检测这些文件的更改，并自动将它们应用到k8s集群。这些文件也可以在Git中通过fluxctl或image registry automation(如果启用的话)进行双向更新。</em></figcaption></figure><h1 id="e4b1" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">通量警告</h1><p id="ba6a" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">以下是我在使用Flux时注意到的事情。它们不一定是交易破坏者，但可能会也可能不会影响您的使用情形，需要注意的是:</p><h2 id="b136" class="mz la iq bd lb na nb dn lf nc nd dp lj jy ne nf ln kc ng nh lr kg ni nj lv nk bi translated">Flux Git存储库与Flux守护进程的一对一关系</h2><p id="d528" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">如果您只管理一个应用程序或几个简单的应用程序，这可能不是太大的问题，但是如果您有许多应用程序，都有不同的发布周期等，您可能不希望将所有k8s yaml/helm发布配置混合在一个共享的Git存储库中。一种解决方案是运行多个Flux守护进程，每个守护进程都绑定到自己的Git存储库，这并不理想，但可以工作。有一个<a class="ae kl" href="https://github.com/fluxcd/flux/issues/1164" rel="noopener ugc nofollow" target="_blank">开放的问题，这与通量</a>以及一个<a class="ae kl" href="https://github.com/justinbarrick/flux-operator" rel="noopener ugc nofollow" target="_blank">定制的CRD解决办法，它在这里</a>。</p><h2 id="8430" class="mz la iq bd lb na nb dn lf nc nd dp lj jy ne nf ln kc ng nh lr kg ni nj lv nk bi translated">您的k8s YAML或头盔版本也利用其他设置的当前图像标签</h2><p id="715d" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">如果您的<em class="km"> HelmReleases </em>或k8s YAML清单利用了<strong class="jp ir"><em class="km">fluxcd.io/automated:“真”</em> </strong>注释通量将方便地自动处理将这些更改应用到您的集群，并在Git中双向反向更新您的YAML，如果<em class="km"> fluxctl </em>命令发出或检测到新的图像版本等。但是，如果您的<em class="km"> HelmReleases </em>或raw k8s YAML清单中有其他值也引用了图像标签/版本，则当通过<em class="km"> fluxctl </em>或自动注册表图像标签检测发生版本更改时，这些值不会自动更新。默认情况下，在您的YAML清单或<em class="km"> HelmRelease </em>声明中唯一会获得最新图像标签/版本值的是众所周知的位置中的<a class="ae kl" href="https://docs.fluxcd.io/en/1.19.0/references/helm-operator-integration/#automated-image-detection" rel="noopener ugc nofollow" target="_blank">引用。绕过这个</a><a class="ae kl" href="https://docs.fluxcd.io/en/1.19.0/references/fluxyaml-config-files/" rel="noopener ugc nofollow" target="_blank">的一个方法可能是通过清单生成支持特性</a>，使用<a class="ae kl" href="https://kustomize.io/" rel="noopener ugc nofollow" target="_blank"> Kustomize </a>和/或自定义命令(注意，您只能使用默认Flux docker映像中可用的命令集)。<a class="ae kl" href="https://cloud-native.slack.com/archives/CLAJ40HV3/p1590098823244700" rel="noopener ugc nofollow" target="_blank">更多信息请点击通量松弛通道。</a></p><h1 id="5b2b" class="kz la iq bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">摘要</h1><p id="03ed" class="pw-post-body-paragraph jn jo iq jp b jq lx js jt ju ly jw jx jy lz ka kb kc ma ke kf kg mb ki kj kk ij bi translated">总的来说，我真的很喜欢Flux，并且肯定会推荐在绿地项目中使用它。如果您现有的部署工作流使用其他定制程度不同的工具，迁移到Flux可能会更具挑战性，但这将因具体情况而异。Flux无疑是一个你需要适应的固执己见的CD系统，它相当开放，但也有一些你需要知道的限制。总的来说，在使用它时，它感觉非常有凝聚力，并且与图像注册表和fluxctl选项的自动化紧密联系在一起。请记住，对于Flux，如果您喜欢fluxctl提供的更多手动控制，自动化是完全可选的。</p><p id="47e4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我希望这有所帮助，我强烈建议检查一下。</p></div><div class="ab cl nl nm hu nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ij ik il im in"><p id="13f5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="km">原载于2020年5月22日http://bitsofinfo.wordpress.com</em><a class="ae kl" href="https://bitsofinfo.wordpress.com/2020/05/22/continuous-delivery-with-flux/" rel="noopener ugc nofollow" target="_blank"><em class="km"/></a><em class="km">。</em></p></div></div>    
</body>
</html>