<html>
<head>
<title>How to Ensure that a Function Accepts a Value but not a Promise in TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在TypeScript中确保函数接受值而不是承诺</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-is-promise-t-be-assignable-to-t-f147d13d1e76?source=collection_archive---------4-----------------------#2020-10-20">https://levelup.gitconnected.com/how-is-promise-t-be-assignable-to-t-f147d13d1e76?source=collection_archive---------4-----------------------#2020-10-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="d62f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">今天我不得不在TypeScript中写一个函数<code class="fe kl km kn ko b">foo</code>，它将接受类型为<code class="fe kl km kn ko b">object</code>的单个参数。然后我有了另一个<code class="fe kl km kn ko b">async</code>函数<code class="fe kl km kn ko b">bar</code>，它将返回<code class="fe kl km kn ko b">object</code>。这些功能将会被其他工程师大量使用，并在我们的系统中扮演重要的角色——“核心功能”</p><pre class="kp kq kr ks gt kt ko ku kv aw kw bi"><span id="4627" class="kx ky iq ko b gy kz la l lb lc">function foo(arg: object) {<br/>  // ...<br/>}</span><span id="60e0" class="kx ky iq ko b gy ld la l lb lc">async function bar(): Promise&lt;object&gt; {<br/>  // ...<br/>}</span></pre><p id="94f2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些函数的典型用法是将从<code class="fe kl km kn ko b">bar </code>返回的<strong class="jp ir">值</strong>传递给<code class="fe kl km kn ko b">foo</code></p><pre class="kp kq kr ks gt kt ko ku kv aw kw bi"><span id="0968" class="kx ky iq ko b gy kz la l lb lc">const value = bar()<br/>foo(value) // no compile time error</span></pre><p id="f82b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你看问题对吗？我们没有等待<code class="fe kl km kn ko b">bar()</code>。这种设置的不好之处在于，尽管<code class="fe kl km kn ko b">value</code>是类型<code class="fe kl km kn ko b">Promise&lt;object&gt;</code>的，但它仍然可以赋值给类型<code class="fe kl km kn ko b">object</code>，因此编译器没有什么可抱怨的。但是我们有一个特例，只有承诺是不可接受的，其他的都是不可接受的，因为我们想确保其他工程师不会忘记在将<code class="fe kl km kn ko b">object</code>传递给<code class="fe kl km kn ko b">foo</code>之前解决它</p><figure class="kp kq kr ks gt lf gh gi paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="gh gi le"><img src="../Images/fafb8f14a6cc05e355c415aa6609ad70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1oprDzgKIJD4_uEgP5RpBw.png"/></div></div></figure><p id="4994" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么我们如何确保<code class="fe kl km kn ko b">foo</code>传递的是一个值而不是一个承诺呢？天真的方法是创建一个类似于<code class="fe kl km kn ko b">arg</code>的包装器:</p><pre class="kp kq kr ks gt kt ko ku kv aw kw bi"><span id="dfe9" class="kx ky iq ko b gy kz la l lb lc">type FooArg = {<br/>  value: object<br/>}</span><span id="c7ac" class="kx ky iq ko b gy ld la l lb lc">function foo({ value }: FooArg) {<br/>  // ...<br/>}</span><span id="c267" class="kx ky iq ko b gy ld la l lb lc">async function bar(): Promise&lt;FooArg&gt; {<br/>  // ...<br/>}</span></pre><p id="4818" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有了这个设置，如果我们再次没有<code class="fe kl km kn ko b">await</code>并意外地将promise传递给<code class="fe kl km kn ko b">foo</code>，typescript将捕获类型不兼容</p><pre class="kp kq kr ks gt kt ko ku kv aw kw bi"><span id="98a9" class="kx ky iq ko b gy kz la l lb lc">const value = bar()<br/>foo(value) // TS Error: Type 'Promise&lt;FooArg&gt;' has no properties in common with type 'FooArg'.</span></pre><p id="a009" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">而用<code class="fe kl km kn ko b">await</code>就可以了</p><pre class="kp kq kr ks gt kt ko ku kv aw kw bi"><span id="774c" class="kx ky iq ko b gy kz la l lb lc">const value = await bar()<br/>foo(value) // OK</span></pre><h1 id="1906" class="lm ky iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">更多地依赖TypeScript</h1><p id="f538" class="pw-post-body-paragraph jn jo iq jp b jq mj js jt ju mk jw jx jy ml ka kb kc mm ke kf kg mn ki kj kk ij bi translated">我们可以将我们的函数转换为<em class="mo">泛型</em>，使用<em class="mo">类型参数推断</em>并添加<em class="mo">条件类型</em>来将Promise从可接受的参数中排除。</p><pre class="kp kq kr ks gt kt ko ku kv aw kw bi"><span id="03c8" class="kx ky iq ko b gy kz la l lb lc">function foo&lt;T&gt;(arg: T extends Promise&lt;unknown&gt; ? never : T) {<br/>  // ...<br/>}</span><span id="be6d" class="kx ky iq ko b gy ld la l lb lc">async function bar(): Promise&lt;object&gt; {<br/>  // ...<br/>}</span></pre><p id="a51f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这里，我们通过在条件类型定义的真分支中提供<code class="fe kl km kn ko b">never</code>类型，告诉TS如果<code class="fe kl km kn ko b">T</code>可赋值给<code class="fe kl km kn ko b">Promise&lt;unknown&gt;</code>，这是不可能发生的，否则让<code class="fe kl km kn ko b">T</code>保持原样。</p><p id="58d6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，当我们在没有明确提供类型参数<code class="fe kl km kn ko b">foo&lt;SomeType&gt;(...)</code> vs <code class="fe kl km kn ko b">foo(...)</code>的情况下调用<code class="fe kl km kn ko b">foo</code>时，编译器将从传入的参数类型中推断出<code class="fe kl km kn ko b">T</code>的类型。如果参数是一个承诺，那么<code class="fe kl km kn ko b">T</code>变成<code class="fe kl km kn ko b">never</code>，它不能被赋值，所以我们现在很好，我们的函数永远不会接受任何承诺。所有其他类型都是可以接受的。</p><blockquote class="mp mq mr"><p id="f3c1" class="jn jo mo jp b jq jr js jt ju jv jw jx ms jz ka kb mt kd ke kf mu kh ki kj kk ij bi translated"><em class="iq">没有</em>类型是<code class="fe kl km kn ko b">never</code>的子类型或可分配给<code class="fe kl km kn ko b">never</code>(除了<code class="fe kl km kn ko b">never</code>本身)</p></blockquote><pre class="kp kq kr ks gt kt ko ku kv aw kw bi"><span id="9d04" class="kx ky iq ko b gy kz la l lb lc">const value = bar()</span><span id="b8c7" class="kx ky iq ko b gy ld la l lb lc">foo(value) // Argument of type 'Promise&lt;object&gt;' is not assignable to parameter of type 'never'.</span></pre><p id="1673" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在…期间</p><pre class="kp kq kr ks gt kt ko ku kv aw kw bi"><span id="2f09" class="kx ky iq ko b gy kz la l lb lc">const value = await bar()</span><span id="8717" class="kx ky iq ko b gy ld la l lb lc">foo(value) // All fine!</span></pre><p id="acaf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">希望你觉得这有用！</p></div></div>    
</body>
</html>