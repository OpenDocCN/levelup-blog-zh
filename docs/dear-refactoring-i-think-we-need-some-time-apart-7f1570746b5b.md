# 亲爱的重构:我想我们需要分开一段时间

> 原文：<https://levelup.gitconnected.com/dear-refactoring-i-think-we-need-some-time-apart-7f1570746b5b>

![](img/2ab0d944a9e0cf190c8f328f476f463e.png)

照片由 [KT](https://unsplash.com/@ktphotographyx?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 在 [Unsplash](/s/photos/craft?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上拍摄

## 发展中的开发商

## 设定界限，这样我对重构的热爱就不会妨碍按时交付代码

我喜欢重构。**爱**它。当我进行 TDD 时，只要我的测试通过，我就可以专注于重构我的代码:调整和改进我的代码，让它变得更棒。我非常喜欢这一部分。它迎合了我对修补的喜爱和对效率的渴望。

![](img/8d2cf1db3b1783fe1afc3f94091cb476.png)

在厄里斯魔镜前出神(*哈利波特与魔法石，2001)*

你知道《哈利·波特》第一部中的那面镜子——厄里斯魔镜吗？镜子展示了一个人内心最深处的渴望，有些人花了无尽的时间盯着镜子而不是活着。邓布利多教授说得好:

> 人们在它面前虚度光阴，被他们所看到的东西迷住心窍，或者被逼疯，不知道它所展示的是真实的还是可能的。

朋友们，这正是重构对我的影响。重构，尽管很棒，但对我来说可能会成为一种干扰:一种我愿意选择的干扰，因为它感觉起来像是一种生产活动。

> 我经常选择花时间改进足够好的代码，而不是重新开始下一个要解决的问题。

我的典型项目工作流程如下所示:

1.  选择要处理的要素。
2.  为该特性编写测试。
3.  实现这个特性是为了让我的测试通过，知道解决方案的第一次通过是不错的，尽管可能不太好。
4.  重构我的代码并优化，确保我的测试继续通过。让我的代码棒极了。
5.  船。有时，这意味着集成到主分支并部署代码。有时，这意味着告诉我的客户该特性已经可以进行演示了。

当我的代码没有按时交付时，您可能会认为这是因为我在第 3 步卡住了。毫无疑问，困难在于找到一个可行的解决方案。但更常见的是，我的代码延迟发布的原因是因为我在步骤 4 上花了太多时间——事实上，花了太多时间，以至于这个*功能没有演示，下一个*功能没有开始。

> 我们应该如何思考重构，这样我们就能知道什么时候开始有成效的重构变得令人分心了？

我们需要的是确保我们清楚重构的目的，然后我们将拜访 T2，问自己几个问题，这样我们就可以决定是继续重构还是继续前进。

![](img/e3bd8c4506ae124f26e0bb1672181d5f.png)

照片由[万花筒](https://unsplash.com/@kaleidico?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)在 [Unsplash](/s/photos/whiteboard?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上拍摄

# 再次提醒我——重构的目的是什么？

顺便说一下，如果你*还没有*爱上重构，我推荐马丁·福勒和肯特·贝克的[《重构》。这是一本充满例子的优秀入门书，我一次又一次地重温它，作为参考和提醒。](https://www.martinfowler.com/books/refactoring.html)

当我们回顾*为什么*重构代码时，让我们参考福勒的书来了解他概述的目的。以下内容一字不差地摘自他的书的第二章:

*   重构改进了软件的设计。
*   重构让软件更容易理解。
*   重构帮助我找到 bug。
*   重构帮助我更快地编程。

非常好。既然重构的*目的*还历历在目，我们需要学习如何在重构中设定界限，这样我们就可以在改进现有代码和冒险编写新代码之间找到平衡。要做到这一点，让我们思考我们应该做什么样的重构，然后如何评估我们应该何时停止。

![](img/ce80e2d6f6f3338df8af2ff40f165b5d.png)

Evelyn Mostrom 在 Unsplash 上的照片

# 我应该做什么样的重构？

这是一个巨大的问题，但它的答案实际上取决于你是什么样的程序员。每个程序员都有不同的风格，倾向于不同的[代码味道](https://martinfowler.com/bliki/CodeSmell.html#:~:text=A%20code%20smell%20is%20a,deeper%20problem%20in%20the%20system.&text=You%20have%20to%20look%20deeper,rather%20than%20the%20problem%20themselves.)。所以，以下问题的答案对你来说可能和对我来说不一样。尽管如此，我还是提出以下建议供大家思考。

## 当我在写新代码的时候，我应该养成什么样的重构习惯？

我和妻子喜欢一起在厨房做饭。这些年来，我们学到的一个教训就是在你做饭的时候洗碗。当然，在整个准备过程中，每隔一段时间就要花一两分钟；但是当这顿饭吃完时，回报是*巨大的*。当我们给食物上盘时，对一大堆肮脏的锅碗瓢盆没有恐惧的目光。我们不会在吃饭的整个过程中害怕吃完饭后要做的清理工作。

> 做饭的时候洗盘子。在我们编写新代码的时候，有一些类型的重构是我们可以养成的习惯。

随着你对可用重构种类的了解越来越多，你会发现越来越多的重构会慢慢发展成你在编码时无意识的习惯。那是一个很棒的地方。不过，现在，我提供了两种在编码过程中几乎总是要做的重构。从这些开始，然后逐渐积累你的技能。

1.  [提取功能](https://refactoring.com/catalog/extractFunction.html)

如果我写的函数开始看起来很长(超过 10 行)，也许它做得太多了。也许我需要写一些更小的函数来调用这个更大的函数。

如果我发现自己需要注释代码来解释发生了什么，也许我需要将下面的代码块提取到它自己的函数中，以不再需要注释的方式命名函数。

如果我*曾经*发现自己从另一个文件复制/粘贴了一段代码到我正在处理的文件，我需要抵制偷懒的诱惑——这显然是想要重用的代码。我应该把它粘贴到自己的文件中，这样它就只存在于一个地方。然后，需要该函数的两个文件都可以调用它。

2.[引入参数对象](https://refactoring.com/catalog/introduceParameterObject.html)

如果我一直看到同样的几个变量作为函数参数一起重复出现，也许我应该把它们移到一个对象中。例如，我有几个函数总是采用相同的三个参数。

```
function sendEmail (firstName, lastName, email) { ... }
function logNotification (firstName, lastName, email) { ... }
function verifyIdentity (firstName, lastName, email) { ... }
```

也许这些参数应该只是一个包含三段数据的单一对象。

```
function sendEmail (userObject) { ... }
function sendEmail (userObject) { ... }
function sendEmail (userObject) { ... }
```

对我来说，以上两类重构都是唾手可得的果实。只要我遵守纪律，不偷懒，在我写代码的时候做这些事情很容易。

在我写新代码的时候习惯性地重构*是确保我不会在发布前的代码评审重构中花费太多时间的关键。这需要训练，而训练可能需要几个月或几年的时间。*

## 当我检查将要提交的代码时，我应该优先考虑哪种重构？

到目前为止，我只关注我的代码。如果我要提交这段代码，那么要么它将开始被其他人使用，要么它将通过代码审查(或者两者都有)。这是我真正需要关注可读性的时候。

> 在这一点上，我不应该再问，“这是解决这个问题的最佳方式吗？”相反，我应该问，“我在这段代码中的意图对任何阅读它的人来说都是清楚的吗？”

如果我将要提交，并且我正在考虑重构，那么我就不应该再考虑“解决这个问题的最好方法”对不起，那艘船已经起航了。

1.  如果有一个变量或函数，根据它的名字，它是什么或它做什么并不十分明显，那么这个名字需要改变。我可能需要[改变函数声明](https://refactoring.com/catalog/changeFunctionDeclaration.html)或[重命名变量](https://refactoring.com/catalog/renameVariable.html)或[重命名字段](https://refactoring.com/catalog/renameField.html)。
2.  如果我在第 5 行声明了一个变量，但是我直到第 20 行才使用它，那么我应该[滑动语句](https://refactoring.com/catalog/slideStatements.html)并将声明移到第 19 行。如果我引用了它，那么我应该马上使用它。否则，读者会对为什么它在上面感到困惑。他们在阅读中遗漏了什么吗？是不是在某个他们没抓到的地方被引用了？

## 在准备编写新特性的过程中，我应该做什么样的重构？

我非常喜欢这种重构，因为它吊起了我对新特性的新编码的胃口，但是我已经抱着这样的心态，这种重构只是开胃菜(所以不要忘乎所以！).

这种准备重构对我来说通常涉及以下类型:

1.  *更多* [提取功能](https://refactoring.com/catalog/extractFunction.html)。我可能会看到更多的重复代码，如果我怀疑我将在即将构建的功能中重用这些代码，我会特别敏感。当需要使用它的时候，知道我已经重构了它将是多么令人高兴。
2.  在这个阶段，福勒推荐(我也同意)[参数化函数](https://refactoring.com/catalog/parameterizeFunction.html)。如果我开始看到做几乎同样事情的多个函数定义，除了这里或那里的一点点差异，也许我可以将它们合并成一个函数，只需添加一个参数来覆盖差异。例如，四个函数`add`、`subtract`、`multiply`和`divide`每个都接受两个整数并执行一个操作，也许我应该只拥有一个接受两个整数和一个操作参数的`calculate`函数。

虽然有许多种重构方式，但我发现自己一次又一次地重复使用相同的方式，因为我的编码风格总是倾向于重复代码。

> 对我来说，如果我只是专注于删除重复的代码——当我编写新代码时，当我准备提交时，当我准备开始一个新功能时——那么我希望我的代码质量和可读性会显著提高。

![](img/e25c177e9993d4c92acd2adb70c61784.png)

照片由 [Kristaps Grundsteins](https://unsplash.com/@grundsteins?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 在 [Unsplash](/s/photos/stop?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上拍摄

# 我应该什么时候停止重构？

现在，我们需要开始讨论界限。我热爱重构，总会有重构让我去做。但是我不可能永远做重构。新功能需要完成。代码需要发货。

所以，在重构的时候，我需要不断地问自己以下问题:

## *这是一个好的停车点吗？*

我这里说的不是已经做了多少重构，或者没有做多少重构。相反，我只是简单地询问我的代码是否处于所有测试都能通过的状态，并且我可以签入它。如果是这样，那么这是一个很好的停止点。

如果我开始进行另一个重构，那么我就进入了另一个持续时间，在此期间我没有处于一个好的停止点。该持续时间可能是 5 分钟，也可能是 2 小时。但是，当我在做的时候，我的代码*坏了*。为了达到一个好的停止点，我需要要么完成重构，要么回滚。

不要对自己说，“*这不是一个好的停止点。我还可以做更多的重构工作*你总是可以做更多的重构。

> 如果您的所有测试都通过了，并且您可以签入您的代码，那么这是一个非常好的停止点。

## 我能承受更多的重构吗？

假设我*在*一个好的停止点，下一个问题是:*我应该做更多吗？但是，我们不要这样问问题。我的内心(因为我热爱重构)总是用“是的，当然！多做！感觉太好了！”*

一个更好的问题是:*我能负担得起做更多的重构吗？*

> 理想情况下，我们会在**可以**的时候停止重构，而不是在**必须**的时候。

“能停就停”和“必须停就停”有什么区别？

“*能停就停”*的意思是能够说“嗯，这是一个很好的停止点，代码看起来足够干净；此外，从下一期开始对我也有好处。”感觉不错吧？这就像，在一顿真正的大餐快结束的时候，有自制力说，“真好吃。我很满意。吃饱了才需要吃。”然后我放下叉子。

*“必须停止时停止”*可能是这样的:我从一个队友那里收到一封疯狂的电子邮件，说客户端演示将在 10 分钟内完成，那么为什么最新的功能分支还没有集成呢？同时，我只需要弄干这个函数，清除那个条件，即使我真的很想把那个代码块移到它自己的函数里…好吧好吧好吧，我会运行测试并签入它。

*“该停的时候就停”*是被迫的、狂乱的、非常不满足的。如果你能控制“能停下来就停下来”，你会对结束工作会议的方式感到更加满意。

所以，回到这个问题:*我能负担得起做更多的重构吗？*

*   如果我在下一个好的停止点签入我的代码，并且我已经为代码审查或特性演示做好了充分的准备，那么我就可以进行更多的重构。否则，这段代码就“足够好”了，准备工作优先。
*   如果没有一个不同的问题或特性是我需要处理的，但是因为我不知道如何开始而推迟了，那么我就可以进行更多的重构。

## 我真的让我的代码…可读性更差了吗？

适当的重构会使代码更易于维护和阅读。但是有时候，我认为我在做代码重构，而实际上我已经滑入了代码优化。

也许是因为我已经做了太长时间，或者是因为我不自觉地推迟了下一个需要解决的问题。但是，我开始抛弃我所知道的关于适当重构的一切，并开始试图以牺牲可读性为代价，使我的代码简洁优雅。我为了所谓的优雅牺牲了理解力。

> 代码看起来仍然可读，但只是对我而言。那是知识的[诅咒](https://en.wikipedia.org/wiki/Curse_of_knowledge)。对我来说，它看起来是可读的，因为在我弄乱它之前，我知道(并且不能不知道)代码的意图是什么。它可能仍然有效，但对于新鲜的眼睛来说，它不再容易理解。

当我开始走这条路时，我越早抓住自己，越好。总有一天修补不再有用。一旦我意识到我正在降低代码的可读性，我就需要回滚并注销一天。

![](img/48843ca913b3e6adb5080ee67372c03a.png)

由[诺德伍德主题](https://unsplash.com/@nordwood?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)在 [Unsplash](/s/photos/waiting?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上拍摄的照片

# 重构:我认为我们可以做到。我们只是需要一些界限。

我们需要界限。首先，让我们弄清楚我们应该做什么样的重构。在特性实现的不同阶段，会有不同种类的重构会更合适。哪种类型取决于你作为程序员的倾向。

接下来，让我们问一些边界问题，这样我们就知道什么时候应该停止重构。当你在一个好的停止点时，要意识到。问问你自己，你是否真的能够承担更多的重构。检查一下你自己，看看你是否真的在可读性方面适得其反。

**不要问这些问题:**

*   完美吗？
*   完成了吗？

> 它永远不会完美。它永远不会完整。而是问这个问题:这样更好吗？

在重构的时候，给自己设定一些界限。就像生活中你喜欢或讨厌的任何事情一样，你需要界限。特别是如果你是一个修补者，你喜欢重构，你需要边界。否则，你将永远这样做，你将永远不会发布你的代码。