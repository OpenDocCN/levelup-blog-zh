<html>
<head>
<title>Learning C++: Value and Reference Parameters</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习C++:值和参考参数</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/learning-c-value-and-reference-parameters-d3cbfd176b42?source=collection_archive---------5-----------------------#2020-08-21">https://levelup.gitconnected.com/learning-c-value-and-reference-parameters-d3cbfd176b42?source=collection_archive---------5-----------------------#2020-08-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/71917cc558fed214aab7a86d655cd443.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6XAfVsYmBK_3fUHO"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">图片由<a class="ae kf" href="https://unsplash.com/@bugsster?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Taras Shypka </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="e950" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">初学C++的程序员最难理解的概念之一是通过值传递函数参数和通过引用传递函数参数之间的区别。在本文中，我将解释两者的区别，并演示何时以及为什么应该使用每种参数类型。</p><h1 id="0c40" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">按定义的值传递</h1><p id="ccea" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">当函数接收参数的副本时，函数参数通过值传递。这意味着参数值存储在为函数调用保留的内存中。这是C++的默认行为。</p><p id="4855" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了演示按值传递意味着什么，这里有一个简单的例子:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="cc2e" class="mq lf it mm b gy mr ms l mt mu">#include &lt;iostream&gt;<br/>using namespace std;</span><span id="e812" class="mq lf it mm b gy mv ms l mt mu">void changeParam(int param) {<br/>  param += 5;<br/>  cout &lt;&lt; "Parameter: " &lt;&lt; param &lt;&lt; endl;<br/>}</span><span id="10fb" class="mq lf it mm b gy mv ms l mt mu">int main ()<br/>{<br/>  int number = 0;<br/>  changeParam(number);<br/>  cout &lt;&lt; "Number: " &lt;&lt; number &lt;&lt; endl;<br/>  return 0;<br/>}</span></pre><p id="c048" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个程序的输出是:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="e532" class="mq lf it mm b gy mr ms l mt mu">Parameter: 5<br/>Number: 0</span></pre><p id="0548" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">变量<code class="fe mw mx my mm b">number</code>作为变量(参数)传递给函数。在函数内部，参数值增加5，该值显示在屏幕上。该功能结束，控制返回到<code class="fe mw mx my mm b">main</code>。然后访问<code class="fe mw mx my mm b">number</code>的值，显示仍为0。</p><p id="9479" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">变量的值没有改变，因为当<code class="fe mw mx my mm b">number</code>被传递给函数时，它的值的副本被放入参数中。该值是由函数体增加的值，当函数结束时，与该函数相关的所有存储器，包括参数及其值，都被擦除。</p><p id="2d5d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在很大程度上，这正是我们想要的C++函数的行为。事实上，编写函数是为了执行计算，但是当传递给函数的数据可以被函数改变时，理解程序如何工作就变得更加困难了。</p><h1 id="32f4" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">通过定义的引用传递</h1><p id="ff3a" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">通过在参数名前面加上地址运算符(<code class="fe mw mx my mm b">&amp;</code>)来引用传递参数。当参数通过引用传递时，编译器访问参数的内存位置并直接使用该值，而不是像通过值传递参数那样使用该值的副本。</p><p id="00b1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是上面的程序，它被修改为使用引用参数而不是值参数:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="af0b" class="mq lf it mm b gy mr ms l mt mu">void changeParam(int &amp;param) {<br/>  param += 5;<br/>  cout &lt;&lt; "Parameter: " &lt;&lt; param &lt;&lt; endl;<br/>}</span><span id="470c" class="mq lf it mm b gy mv ms l mt mu">int main ()<br/>{<br/>  int number = 0;<br/>  changeParam(number);<br/>  cout &lt;&lt; "Number: " &lt;&lt; number &lt;&lt; endl;<br/>  return 0;<br/>}</span></pre><p id="4304" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是这个程序的输出:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="270a" class="mq lf it mm b gy mr ms l mt mu">Parameter: 5<br/>Number: 5</span></pre><p id="61c6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为参数是通过引用传递的，所以在函数中所做的更改是永久的，当在<code class="fe mw mx my mm b">main</code>中访问变量时，将显示<code class="fe mw mx my mm b">number</code>的新值。</p><h1 id="3952" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">引用传递的一个实例</h1><p id="719c" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">需要对其参数进行永久更改的函数的一个很好的例子是交换函数。在排序应用程序中，交换变量值可能会发生数百次或更多次，因此为此创建一个交换函数是有意义的。</p><p id="30c7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们首先看看如果我们使用值参数编写交换函数会发生什么:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="9cb7" class="mq lf it mm b gy mr ms l mt mu">void swap(int val1, int val2) {<br/>  int temp = val1;<br/>  val1 = val2;<br/>  val2 = temp;<br/>}</span><span id="2b35" class="mq lf it mm b gy mv ms l mt mu">int main ()<br/>{<br/>  int number1 = 1;<br/>  int number2 = 2;<br/>  cout &lt;&lt; "number1: " &lt;&lt; number1 &lt;&lt;", number2: "<br/>       &lt;&lt; number2 &lt;&lt; endl;<br/>  swap(number1, number2);<br/>  cout &lt;&lt; "number1: " &lt;&lt; number1 &lt;&lt;", number2: "<br/>       &lt;&lt; number2 &lt;&lt; endl;<br/>  return 0;<br/>}</span></pre><p id="2c33" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个程序的输出是:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="dc1e" class="mq lf it mm b gy mr ms l mt mu">number1: 1, number2: 2<br/>number1: 1, number2: 2</span></pre><p id="3c87" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这些值没有交换，因为它们是通过值传递给函数的，一旦函数结束，变量中的值就与传递给函数之前的值相同。</p><p id="9965" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您所要做的就是让参数引用参数，然后函数就可以正常工作了:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="f792" class="mq lf it mm b gy mr ms l mt mu">void swap(int &amp;val1, int &amp;val2) {<br/>  int temp = val1;<br/>  val1 = val2;<br/>  val2 = temp;<br/>}</span><span id="fb47" class="mq lf it mm b gy mv ms l mt mu">int main ()<br/>{<br/>  int number1 = 1;<br/>  int number2 = 2;<br/>  cout &lt;&lt; "number1: " &lt;&lt; number1 &lt;&lt;", number2: "<br/>       &lt;&lt; number2 &lt;&lt; endl;<br/>  swap(number1, number2);<br/>  cout &lt;&lt; "number1: " &lt;&lt; number1 &lt;&lt;", number2: "<br/>       &lt;&lt; number2 &lt;&lt; endl;<br/>  return 0;<br/>}</span></pre><p id="b136" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个程序的输出是:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="ae9d" class="mq lf it mm b gy mr ms l mt mu">number1: 1, number2: 2<br/>number1: 2, number2: 1</span></pre><p id="52aa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">显然，通过引用传递可以解决问题，并使变量交换成为可能。</p><h1 id="0ff1" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">默认情况下，数组是引用参数</h1><p id="1e54" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">默认情况下，C++中的一些对象是引用参数。这种对象的一个例子是数组。您可以将一个数组传递给一个函数，而不需要提供address-of运算符，并且函数中对数组的任何更改都是永久的。</p><p id="8338" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个函数示例，该函数将传递给它的数组中的分数曲线化:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="d096" class="mq lf it mm b gy mr ms l mt mu">void curver(int arr[], int numEles, int amount) {<br/>  for (int i = 0; i &lt; numEles; i++) {<br/>    arr[i] += amount;<br/>  }<br/>}</span><span id="5847" class="mq lf it mm b gy mv ms l mt mu">int main ()<br/>{<br/>  const int numElements = 5;<br/>  int grades[] = {71, 67, 88, 72, 66};<br/>  for (const int grade : grades) {<br/>    cout &lt;&lt; grade &lt;&lt; " ";<br/>  }<br/>  cout &lt;&lt; endl;<br/>  curver(grades, numElements, 5);<br/>  for (const int grade : grades) {<br/>    cout &lt;&lt; grade &lt;&lt; " ";<br/>  }<br/>  return 0;<br/>}</span></pre><p id="5bd0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是该程序的输出:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="47bf" class="mq lf it mm b gy mr ms l mt mu">71 67 88 72 66<br/>76 72 93 77 71</span></pre><h1 id="6fd4" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">默认情况下，向量是值参数</h1><p id="e2c5" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">与数组不同，向量在默认情况下是值参数，如果您想对函数中的向量进行更改，您必须使用address-of运算符将向量作为引用参数传递。</p><p id="1a41" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是上面的分数示例，使用向量代替了数组:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="b8c8" class="mq lf it mm b gy mr ms l mt mu">#include &lt;iostream&gt;<br/>#include &lt;vector&gt;<br/>using namespace std;</span><span id="0221" class="mq lf it mm b gy mv ms l mt mu">void curver(vector&lt;int&gt; &amp;vec, int amount) {<br/>  for (int i = 0; i &lt; vec.size(); i++) {<br/>    vec[i] += 5;<br/>  }<br/>}</span><span id="9c5a" class="mq lf it mm b gy mv ms l mt mu">int main ()<br/>{<br/>  vector&lt;int&gt; grades = {71, 67, 88, 72, 66};<br/>  for (const int grade : grades) {<br/>    cout &lt;&lt; grade &lt;&lt; " ";<br/>  }<br/>  cout &lt;&lt; endl;<br/>  curver(grades, 5);<br/>  for (const int grade : grades) {<br/>    cout &lt;&lt; grade &lt;&lt; " ";<br/>  }<br/>  return 0;<br/>}</span></pre><p id="c10f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个程序的输出是:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="0861" class="mq lf it mm b gy mr ms l mt mu">71 67 88 72 66<br/>76 72 93 77 71</span></pre><p id="13ce" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果向量按值传递，程序将运行，但函数调用后成绩不会改变。</p><h1 id="a853" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">何时使用每个参数传递类型</h1><p id="fb09" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">一般来说，您编写的函数应该使用通过值传递的参数来编写。大多数函数都是根据传递给它们的数据生成新值的。但是，有些情况下需要通过引用传递参数，例如交换变量值和修改向量值。</p><p id="2fe9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，许多初学编程的人了解引用参数，并将它们视为解决所有函数问题的方法。你自己不要犯这种错误。必要时使用引用参数，其余时间使用赋值参数。</p><p id="4647" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢您的阅读，请发送电子邮件至<a class="ae kf" href="mailto:mmmcmillan1@att.net" rel="noopener ugc nofollow" target="_blank">mmmcmillan1@att.net</a>向我提出意见和建议。如果你对我的在线编程课程感兴趣，请访问https://learningcpp.teachable.com<a class="ae kf" href="https://learningcpp.teachable.com" rel="noopener ugc nofollow" target="_blank"/>。</p></div></div>    
</body>
</html>