<html>
<head>
<title>Handling Errors in JavaScript: The Definitive Guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的错误处理:权威指南</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/the-definite-guide-to-handling-errors-gracefully-in-javascript-58424d9c60e6?source=collection_archive---------0-----------------------#2018-11-13">https://levelup.gitconnected.com/the-definite-guide-to-handling-errors-gracefully-in-javascript-58424d9c60e6?source=collection_archive---------0-----------------------#2018-11-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/69b164f0d98867f6bc665bdb4f52560d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9Tz6tILBcr8i4TkWVrcc0w.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/photos/BvFFyByZt7U?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> rawpixel </a>在<a class="ae kc" href="https://unsplash.com/search/photos/safety?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="fc70" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">继我的上一篇文章之后，我想谈谈错误。错误是好的——我肯定你以前听过这句话。乍一看，我们害怕错误，因为它们通常包括在公共场合受到伤害或感到羞辱。通过犯错误，我们实际上学会了如何做某事，以及下次如何做得更好。</p><p id="64b2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这显然是关于从现实生活中的错误中学习。编程中的错误有点不同。它们为我们提供了很好的特性来改进我们的代码，并告诉用户什么时候有问题(也许还会告诉他们如何修复)。</p><p id="a698" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这篇文章将分为三个部分，首先我们将看看一般的错误。之后，我们将重点关注后端(Node.js + Express.js ),最后我们将看到如何处理React.js中的错误。我选择了这些框架，因为它们是目前最受欢迎的，但是您应该能够轻松地将新发现的知识应用到其他框架中！</p><p id="d29d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">完整的示例项目可在<a class="ae kc" href="https://github.com/gisderdube/graceful-error-handling" rel="noopener ugc nofollow" target="_blank"> github </a>上获得。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="50e9" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">I. JavaScript错误和一般处理</h1><p id="a086" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated"><code class="fe ml mm mn mo b">throw new Error('something went wrong')</code> —将在JavaScript中创建一个错误实例，并且<strong class="kf ir">停止脚本的执行</strong>，除非您对该错误进行处理。当你作为一名JavaScript开发人员开始你的职业生涯时，你很可能不会自己去做，而是从其他库(或运行时)那里看到它在做，例如“reference error:fs not defined”或类似的。</p><h2 id="7996" class="mp lj iq bd lk mq mr dn lo ms mt dp ls ko mu mv lw ks mw mx ma kw my mz me na bi translated">错误对象</h2><p id="3e5f" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">错误对象有两个内置的属性供我们使用。第一个是消息，它是作为参数传递给错误构造函数的，例如<code class="fe ml mm mn mo b">new Error('This is the message')</code>。您可以通过<code class="fe ml mm mn mo b">message</code>属性访问该消息:</p><pre class="nb nc nd ne gt nf mo ng nh aw ni bi"><span id="1b53" class="mp lj iq mo b gy nj nk l nl nm">const myError = new Error(‘please improve your code’)</span><span id="1b91" class="mp lj iq mo b gy nn nk l nl nm">console.log(myError.message) // please improve your code</span></pre><p id="2e8f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二个也是非常重要的一个是错误堆栈跟踪。您可以通过“stack”属性访问它。错误堆栈会给你一个历史记录(调用堆栈),告诉你是什么文件导致了这个错误。堆栈还在顶部包含消息，然后是实际的堆栈，从最近/孤立的错误点开始，向下到最外部的“负责”文件:</p><pre class="nb nc nd ne gt nf mo ng nh aw ni bi"><span id="79d9" class="mp lj iq mo b gy nj nk l nl nm">Error: please improve your code<br/> at Object.&lt;anonymous&gt; (/Users/gisderdube/Documents/_projects/hacking.nosync/error-handling/src/general.js:1:79)<br/> at Module._compile (internal/modules/cjs/loader.js:689:30)<br/> at Object.Module._extensions..js (internal/modules/cjs/loader.js:700:10)<br/> at Module.load (internal/modules/cjs/loader.js:599:32)<br/> at tryModuleLoad (internal/modules/cjs/loader.js:538:12)<br/> at Function.Module._load (internal/modules/cjs/loader.js:530:3)<br/> at Function.Module.runMain (internal/modules/cjs/loader.js:742:12)<br/> at startup (internal/bootstrap/node.js:266:19)<br/> at bootstrapNodeJSCore (internal/bootstrap/node.js:596:3)</span></pre><h2 id="7cd6" class="mp lj iq bd lk mq mr dn lo ms mt dp ls ko mu mv lw ks mw mx ma kw my mz me na bi translated">投掷和处理错误</h2><p id="7c73" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">现在，错误实例本身不会引起任何问题。例如<code class="fe ml mm mn mo b">new Error('...')</code>什么都不做。当误差达到<code class="fe ml mm mn mo b">throw</code> n时，就变得更有趣了。然后，如前所述，您的脚本将停止执行，除非您在流程中以某种方式处理它。请记住，如果您手动<code class="fe ml mm mn mo b">throw </code>一个错误，这并不重要，它是由库抛出的，甚至是运行时本身(节点或浏览器)。让我们来看看如何在不同的场景中处理这些错误。</p><figure class="nb nc nd ne gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi no"><img src="../Images/4ea686e615b90385dace402fb2d35bc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YCZW1Jmpw1kKa1mBmc_YzA.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">约翰·托尔卡西奥在<a class="ae kc" href="https://unsplash.com/search/photos/catch?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h2 id="5d5d" class="mp lj iq bd lk mq mr dn lo ms mt dp ls ko mu mv lw ks mw mx ma kw my mz me na bi translated"><code class="fe ml mm mn mo b">try .... catch</code></h2><p id="2c01" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">这是最简单的，但经常被遗忘的处理错误的方法——多亏了async / await，它现在又被更多地使用了，见下文。这可用于捕捉任何类型的<strong class="kf ir">同步</strong>错误。示例:</p><figure class="nb nc nd ne gt jr"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="54bd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们不在try … catch块中包装<code class="fe ml mm mn mo b">console.log(b)</code>,脚本执行将会停止。</p><h2 id="171f" class="mp lj iq bd lk mq mr dn lo ms mt dp ls ko mu mv lw ks mw mx ma kw my mz me na bi translated">…终于</h2><p id="eb80" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">有时无论是否有错误，都有必要执行代码。为此，您可以使用第三个可选模块<code class="fe ml mm mn mo b">finally</code>。通常，这与在try … catch语句后有一行代码是一样的，但有时它会很有用。</p><figure class="nb nc nd ne gt jr"><div class="bz fp l di"><div class="np nq l"/></div></figure><h2 id="9f33" class="mp lj iq bd lk mq mr dn lo ms mt dp ls ko mu mv lw ks mw mx ma kw my mz me na bi translated">进入异步状态—回调</h2><p id="aea7" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">异步，这是使用JavaScript时必须考虑的一个话题。当你有一个异步函数，并且该函数内部发生错误时，你的脚本已经继续执行了，所以不会立即出现任何错误。当处理带有回调的异步函数时(顺便说一下，不推荐)，您通常会在回调函数中收到两个参数，看起来像这样:</p><figure class="nb nc nd ne gt jr"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="e367" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果有错误，<code class="fe ml mm mn mo b">err</code>参数将等于该错误。否则，参数将为“未定义”或“空”。重要的是要么在<code class="fe ml mm mn mo b">if(err)</code>块中返回一些东西，要么将你的其他指令包装在<code class="fe ml mm mn mo b">else</code>块中，否则你可能会得到另一个错误，例如<code class="fe ml mm mn mo b">result</code>可能是未定义的，而你试图访问<code class="fe ml mm mn mo b">result.data</code>或类似的。</p><h2 id="bdd9" class="mp lj iq bd lk mq mr dn lo ms mt dp ls ko mu mv lw ks mw mx ma kw my mz me na bi translated">异步—承诺</h2><p id="afe2" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">处理异步的一个更好的方法是使用承诺。这里，除了有更多可读的代码，我们还改进了错误处理。只要我们有一个<code class="fe ml mm mn mo b">catch</code>块，我们就不再需要如此关心准确的错误捕捉。当链接承诺时，一个<code class="fe ml mm mn mo b">catch</code>块捕获自执行承诺或上一个catch块以来的所有错误。注意，没有<code class="fe ml mm mn mo b">catch</code> -block的承诺不会终止脚本，但是会给你一个可读性较差的消息，比如</p><pre class="nb nc nd ne gt nf mo ng nh aw ni bi"><span id="ebeb" class="mp lj iq mo b gy nj nk l nl nm"><em class="nr">(node:7741) UnhandledPromiseRejectionWarning: Unhandled promise rejection (rejection id: 1): Error: something went wrong<br/>(node:7741) DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code. */</em></span></pre><p id="9ea6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，总是在你的承诺中加上一个catch block。让我们来看看:</p><figure class="nb nc nd ne gt jr"><div class="bz fp l di"><div class="np nq l"/></div></figure><h2 id="6d7c" class="mp lj iq bd lk mq mr dn lo ms mt dp ls ko mu mv lw ks mw mx ma kw my mz me na bi translated">再试一次……接住</h2><p id="313a" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">随着JavaScript中async / await的引入，我们又回到了最初处理错误的方式，try … catch … finally使处理错误变得轻而易举:</p><figure class="nb nc nd ne gt jr"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="bb2f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为这也是我们用来处理“正常”同步错误的相同方法，所以如果需要的话，可以更容易地使用更宽范围的catch语句。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="db33" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">二。在服务器中生成和处理错误</h1><p id="2416" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">现在我们有了处理错误的工具，让我们看看在真实的情况下我们能做些什么。生成错误并在后端正确处理它们是应用程序的关键部分。关于如何处理错误，有不同的方法。我将向您展示一种带有自定义错误构造函数和错误代码的方法，我们可以轻松地将它们传递给您的前端或任何API消费者。你如何详细地构建你的后端并不重要，想法是一样的。</p><p id="4612" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将使用Express.js作为路由框架。让我们考虑一下我们想要最有效的错误处理的结构。我们想要:</p><ol class=""><li id="1118" class="ns nt iq kf b kg kh kk kl ko nu ks nv kw nw la nx ny nz oa bi translated">一般的错误处理，某种回退，基本上只是说:“出错了，请再试一次或联系我们”。这不是特别聪明，但至少通知用户有问题——而不是无限加载或类似的。</li><li id="dd63" class="ns nt iq kf b kg ob kk oc ko od ks oe kw of la nx ny nz oa bi translated">特定的错误处理，以便向用户提供有关错误的详细信息以及如何修复错误，例如，缺少一些信息、数据库中已经存在条目等。</li></ol><h2 id="de2b" class="mp lj iq bd lk mq mr dn lo ms mt dp ls ko mu mv lw ks mw mx ma kw my mz me na bi translated">构建自定义错误构造函数</h2><p id="9541" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">我们将使用现有的错误构造函数并扩展它。JavaScript中的继承是一件有风险的事情，但在这种情况下，我体验到它非常有用。我们为什么需要它？我们仍然希望堆栈跟踪为我们提供良好的调试体验。扩展原生JavaScript错误构造函数给了我们免费的堆栈跟踪。我们唯一要添加的是一个<code class="fe ml mm mn mo b">code</code>，稍后我们可以通过<code class="fe ml mm mn mo b">err.code</code>访问它，以及一个状态(http状态代码)传递给前端。</p><figure class="nb nc nd ne gt jr"><div class="bz fp l di"><div class="np nq l"/></div></figure><figure class="nb nc nd ne gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi og"><img src="../Images/45069af27b53183aca46527b247da763.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YiuxJFsUpJ7x-qQa7bQ5MQ.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">乔恩·摩尔在<a class="ae kc" href="https://unsplash.com/search/photos/red-fence?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h2 id="5210" class="mp lj iq bd lk mq mr dn lo ms mt dp ls ko mu mv lw ks mw mx ma kw my mz me na bi translated">如何处理路由</h2><p id="ea49" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">随着我们的自定义错误准备就绪，我们需要设置路由结构。正如我所指出的，我们希望错误处理具有单点真实性，这意味着对于每条路由，我们都希望具有相同的错误处理行为。默认情况下，express并不真正支持这一点，因为路由都是封装的。</p><p id="340b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了解决这个问题，我们可以实现一个路由处理器，并将我们的实际路由逻辑定义为普通函数。这样，如果route函数(或其中的任何函数)抛出一个错误，它将被返回给route处理器，然后路由处理器可以将它传递给前端。每当后端出现错误时，我们都希望将响应传递给前端——假设是JSON API——格式如下:</p><pre class="nb nc nd ne gt nf mo ng nh aw ni bi"><span id="861c" class="mp lj iq mo b gy nj nk l nl nm">{<br/>    error: 'SOME_ERROR_CODE',<br/>    description: 'Something bad happened. Please try again or     contact support.'<br/>}</span></pre><p id="164e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">做好被淹没的准备。当我说:</p><blockquote class="oh oi oj"><p id="b47b" class="kd ke nr kf b kg kh ki kj kk kl km kn ok kp kq kr ol kt ku kv om kx ky kz la ij bi translated">如果你第一眼看不明白所有的事情，那也没关系。只要使用它，过一会儿你就会发现它为什么有意义。</p></blockquote><p id="eaa7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">顺便说一下，这也叫做自上而下的学习，我非常喜欢这种学习方式。</p><p id="6af1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是路由处理程序本身的样子:</p><figure class="nb nc nd ne gt jr"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="5091" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我希望你能阅读代码中的注释，我认为这比在这里解释更有意义。现在让我们看看实际的路由文件是什么样子的:</p><figure class="nb nc nd ne gt jr"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="85d5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这些例子中，我没有对实际的请求做任何事情，我只是假装不同的错误场景。例如，<code class="fe ml mm mn mo b">GET /city</code>会出现在第3行，<code class="fe ml mm mn mo b">POST /city</code>会出现在第8行，依此类推。这也适用于查询参数，例如<code class="fe ml mm mn mo b">GET /city?startsWith=R</code>。本质上，您要么会有一个未处理的错误，前端将收到</p><pre class="nb nc nd ne gt nf mo ng nh aw ni bi"><span id="47e8" class="mp lj iq mo b gy nj nk l nl nm">{<br/>    error: 'GENERIC',<br/>    description: 'Something went wrong. Please try again or contact support.'<br/>}</span></pre><p id="2543" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者你会手动抛出一个“CustomError ”,例如</p><pre class="nb nc nd ne gt nf mo ng nh aw ni bi"><span id="74f8" class="mp lj iq mo b gy nj nk l nl nm">throw new CustomError('MY_CODE', 400, 'Error description')</span></pre><p id="b218" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这变成了</p><pre class="nb nc nd ne gt nf mo ng nh aw ni bi"><span id="9deb" class="mp lj iq mo b gy nj nk l nl nm">{<br/>    error: 'MY_CODE',<br/>    description: 'Error description'<br/>}</span></pre><p id="5071" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们有了这个漂亮的后端设置，我们不再有错误日志泄露到前端，并且将总是返回关于哪里出错的有用信息。</p><p id="8727" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">确保你在<a class="ae kc" href="https://github.com/gisderdube/graceful-error-handling" rel="noopener ugc nofollow" target="_blank"> github </a>上看过完整的回购。请随意将它用于您的任何项目，并根据您的需要进行修改！</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="4139" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">三。向用户显示错误</h1><p id="4d5c" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">下一步也是最后一步是管理前端的错误。这里，您希望使用第一部分中描述的工具来处理前端逻辑本身产生的错误。然而，也必须显示来自后端的错误。让我们首先看看如何显示错误。如前所述，我们将在演练中使用React。</p><figure class="nb nc nd ne gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi on"><img src="../Images/2383bd5ad31264b17115fd360a5e3599.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nidY6HBfwDaiYn_suN7P-w.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">由<a class="ae kc" href="https://unsplash.com/photos/wi-vfhwCDAg?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">安德森·詹森</a>在<a class="ae kc" href="https://unsplash.com/search/photos/stop-sign?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h2 id="4fe0" class="mp lj iq bd lk mq mr dn lo ms mt dp ls ko mu mv lw ks mw mx ma kw my mz me na bi translated">在反应状态下保存错误</h2><p id="4a23" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">正如其他数据、错误和错误消息可能会改变一样，因此您希望将它们放在组件的状态中。默认情况下，在安装时，您希望重置错误，以便当用户第一次看到页面时，看不到任何错误。</p><p id="2ed7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来我们要澄清的是匹配视觉表征的不同类型的错误。就像在后端一样，有3种类型:</p><ol class=""><li id="622a" class="ns nt iq kf b kg kh kk kl ko nu ks nv kw nw la nx ny nz oa bi translated">全局错误，例如，我们的一个一般性错误从后端返回，或者用户没有登录，等等。</li><li id="1ebe" class="ns nt iq kf b kg ob kk oc ko od ks oe kw of la nx ny nz oa bi translated">来自后端的特定错误，例如，用户将其登录凭据发送到后端。后端回答密码不匹配。这不能被前端验证，所以它必须来自后端。</li><li id="193a" class="ns nt iq kf b kg ob kk oc ko od ks oe kw of la nx ny nz oa bi translated">前端本身导致的特定错误，例如电子邮件输入验证失败。</li></ol><p id="3adb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">2.第三。非常相似，可以在相同的状态下处理(如果需要)，但是具有不同的来源。我们将在代码中看到这是如何发生的。</p><p id="8fd7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我将使用React的原生状态实现，但是您也可以使用像MobX或Redux这样的状态管理系统。</p><h2 id="7d78" class="mp lj iq bd lk mq mr dn lo ms mt dp ls ko mu mv lw ks mw mx ma kw my mz me na bi translated">全局错误</h2><p id="0893" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">通常，我将这些错误保存在最外面的有状态组件中，并呈现一个静态UI元素，这可以是屏幕顶部的红色横幅、模态或其他任何东西，设计实现取决于你。</p><figure class="nb nc nd ne gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oo"><img src="../Images/8189d337b68c8e77c0efa9eedc1fb68b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xSpVDWEQ4wMHQ5kObFwf8w.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">全局错误的UI元素示例</figcaption></figure><p id="ed88" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们看一下代码:</p><figure class="nb nc nd ne gt jr"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="8085" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如您所见，我们在<code class="fe ml mm mn mo b">Application.js</code>的状态中有错误。我们也有重置和改变错误值的方法。我们将值和重置方法传递给“global error ”-组件，该组件会在单击“x”时显示并重置它。让我们看看<code class="fe ml mm mn mo b">GlobalError</code>-组件是什么样子的:</p><figure class="nb nc nd ne gt jr"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="d00b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如你在第5行看到的，如果没有错误，我们不渲染任何东西。这可以防止我们的页面上一直有一个空的红框。当然，您可以更改该组件的外观和行为。例如，您可以用一个几秒钟后重置错误状态的<code class="fe ml mm mn mo b">Timeout</code>来代替“x”。</p><p id="ddae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，您已经准备好在任何您想要的地方使用这个全局错误状态，只需从<code class="fe ml mm mn mo b">Application.js</code>传递<code class="fe ml mm mn mo b">_setError</code>，您就可以设置全局错误，例如，当来自后端的请求返回字段<code class="fe ml mm mn mo b">error: 'GENERIC'</code>时。示例:</p><figure class="nb nc nd ne gt jr"><div class="bz fp l di"><div class="np nq l"/></div></figure></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><p id="2cf1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你懒的话，可以到此为止。即使您有特定的错误，您也可以只更改全局错误状态，并在页面顶部显示错误框。但是，我将向您展示如何处理和显示特定的错误。为什么？首先，这是关于处理错误的明确指南，所以我不能就此打住。第二，如果你只显示所有的错误，UX人可能会抓狂。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h2 id="a107" class="mp lj iq bd lk mq mr dn lo ms mt dp ls ko mu mv lw ks mw mx ma kw my mz me na bi translated">处理特定的请求错误</h2><figure class="nb nc nd ne gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi op"><img src="../Images/93f276f6adad6edba5884b90803d546b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bnNmuxkwSUD4JWvjw5Omng.jpeg"/></div></div></figure><p id="8a31" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">与全局错误类似，我们也可以在其他组件中使用<strong class="kf ir">本地错误状态</strong>。程序是相同的:</p><figure class="nb nc nd ne gt jr"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="289b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">需要记住的一点是，清除错误通常有不同的触发器。用“x”来删除错误是没有意义的。在这里，在发出新请求时清除错误会更有意义。您也可以在用户进行更改时清除错误，例如，当输入值更改时。</p><h2 id="0779" class="mp lj iq bd lk mq mr dn lo ms mt dp ls ko mu mv lw ks mw mx ma kw my mz me na bi translated">前端原点误差</h2><figure class="nb nc nd ne gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oq"><img src="../Images/7bdba858d3bb659ff148a33007b33eb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tpmtTom2eSmH7AnrAI55QQ.jpeg"/></div></div></figure><p id="8df5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如前所述，这些错误可以用与来自后端的特定错误相同的方式(状态)来处理。这次让我们使用带有输入字段的示例，只允许用户删除一个城市，而他实际上提供了输入:</p><figure class="nb nc nd ne gt jr"><div class="bz fp l di"><div class="np nq l"/></div></figure><h2 id="8af0" class="mp lj iq bd lk mq mr dn lo ms mt dp ls ko mu mv lw ks mw mx ma kw my mz me na bi translated">使用错误代码的错误国际化</h2><p id="6bb9" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">也许你一直想知道为什么我们会有这些错误代码，例如<code class="fe ml mm mn mo b">GENERIC</code>，我们只是显示从后端传来的错误描述。现在，一旦你的应用程序增长，你将有希望征服新的市场，并在某个时候面临必须支持多种语言的问题。如果您处于这种情况，您可以使用提到的错误代码以用户语言显示正确的标题。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><p id="189f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我希望你对如何处理错误有所了解。快速输入和快速忘记<code class="fe ml mm mn mo b">console.error(err)</code>现在应该是过去的事情了。使用它进行调试是必要的，但是它不应该在您的产品构建中结束。为了防止这种情况，我建议你使用日志库，我过去一直在使用<a class="ae kc" href="https://www.npmjs.com/package/loglevel" rel="noopener ugc nofollow" target="_blank">日志级别</a>，我对它非常满意。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><p id="86f8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="nr">关于作者:Lukas Gisder-Dubé作为CTO共同创立并领导了一家初创公司1年半，建立了技术团队和架构。离开创业公司后，他在</em><a class="or os ep" href="https://medium.com/u/1ff093a3da32?source=post_page-----58424d9c60e6--------------------------------" rel="noopener" target="_blank"><em class="nr">iron hack</em></a><em class="nr">担任首席讲师教授编码，现在正在柏林建立一家创业机构&amp;咨询公司。查看</em><a class="ae kc" href="https://dube.io" rel="noopener ugc nofollow" target="_blank"><em class="nr">Dube . io</em></a><em class="nr">了解更多。</em></p><figure class="nb nc nd ne gt jr gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/840b0ca008c4fa8e0a1d00791a6c9f9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/1*p-l0Cee1IHvX0RQkVTOceQ.png"/></div></figure></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><figure class="nb nc nd ne gt jr gh gi paragraph-image"><a href="https://levelup.gitconnected.com/"><div class="gh gi ou"><img src="../Images/ff5028ba5a0041d2d76d2a155f00f05e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JaoZbi7tTKJ5vL7i2OAYMQ.png"/></div></a></figure><div class="ov ow gp gr ox oy"><a href="https://gitconnected.com/learn/javascript" rel="noopener  ugc nofollow" target="_blank"><div class="oz ab fo"><div class="pa ab pb cl cj pc"><h2 class="bd ir gy z fp pd fr fs pe fu fw ip bi translated">学习JavaScript -最佳JavaScript教程(2019) | gitconnected</h2><div class="pf l"><h3 class="bd b gy z fp pd fr fs pe fu fw dk translated">排名前64的JavaScript教程。课程由开发者提交并投票，使您能够找到最好的…</h3></div><div class="pg l"><p class="bd b dl z fp pd fr fs pe fu fw dk translated">gitconnected.com</p></div></div><div class="ph l"><div class="pi l pj pk pl ph pm jw oy"/></div></div></a></div></div></div>    
</body>
</html>