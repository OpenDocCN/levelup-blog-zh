<html>
<head>
<title>Implementing a BST in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用JavaScript实现BST</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/implementing-a-bst-in-javascript-dc818ba50633?source=collection_archive---------8-----------------------#2020-04-12">https://levelup.gitconnected.com/implementing-a-bst-in-javascript-dc818ba50633?source=collection_archive---------8-----------------------#2020-04-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="e7b0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将实现一个BST，并复习一些有用的定义和描述</p><h2 id="076e" class="ko kp it bd kq kr ks dn kt ku kv dp kw kb kx ky kz kf la lb lc kj ld le lf lg bi translated">BST到底是什么来着？</h2><p id="f659" class="pw-post-body-paragraph jq jr it js b jt lh jv jw jx li jz ka kb lj kd ke kf lk kh ki kj ll kl km kn im bi translated"><strong class="js iu"> <em class="lm">二叉查找树</em> </strong>或<strong class="js iu"><em class="lm">BST</em></strong>是某种类型的<strong class="js iu"> <em class="lm">二叉树</em> </strong>，二叉树只是一个数据结构，它有一个指向子节点集合的根节点。每个节点都有一个值(在本例中是一个整数值)，每个节点最多有2个子节点(leftNode和rightNode)。</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi ln"><img src="../Images/86310c220841d06f33228ffd8c91301b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OSEoDBe7UTL8fBGDYeTOFg.png"/></div></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk translated">未排序、不平衡的二叉树</figcaption></figure><p id="b1e7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">普通的二进制树没有排序或平衡约束，这使得查找时间非常短。在最坏的情况下，您必须触摸每个节点<strong class="js iu"> O(N) </strong>。</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi md"><img src="../Images/90b508c78f3771071e1fd7af07faaa1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1356/format:webp/1*M0mK4-LeDebQPzQS7x6EZw.png"/></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk translated">平衡，有序，二叉查找树</figcaption></figure><p id="b8fe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以通过向集合中添加一个简单的属性来提高对<strong class="js iu">O(log(N)】</strong>的查找速度:</p><p id="7ede" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="lm">一个节点的值必须</em> <strong class="js iu"> <em class="lm">大于其左侧的所有值</em></strong><em class="lm">；一个节点的值必须</em> <strong class="js iu"> <em class="lm">小于其右侧的所有值。</em></strong><em class="lm"/></p><p id="da22" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">换句话说，当我们调用<code class="fe me mf mg mh b">currentNode.left</code>时，我们应该期望得到一个小于  <em class="lm"> </em> <code class="fe me mf mg mh b">currentNode.data</code>的值</p><p id="50f6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">同样，当我们称<code class="fe me mf mg mh b">currentNode.right</code>时，我们应该期望得到一个大于  <em class="lm"> </em> <code class="fe me mf mg mh b">currentNode.data</code>的值</p><p id="e066" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可能想知道……我们如何处理重复项？答案是…这取决于您自己，以及什么对您的实现有意义！有些人认为副本不属于一棵树，有些人会将它们分配到左边，有些人甚至会将它们放在该节点的数组中，或者在该节点上添加一个<code class="fe me mf mg mh b">dupeCount</code>变量来跟踪它们；你挑吧！</p><h2 id="74da" class="ko kp it bd kq kr ks dn kt ku kv dp kw kb kx ky kz kf la lb lc kj ld le lf lg bi translated">履行</h2><p id="7830" class="pw-post-body-paragraph jq jr it js b jt lh jv jw jx li jz ka kb lj kd ke kf lk kh ki kj ll kl km kn im bi translated">让我们言归正传吧，宝贝！我们将使用<strong class="js iu"> ES2015 </strong>引入的语法；<code class="fe me mf mg mh b">class</code>关键字。这是一点语法糖，它抽象出了JavaScript现有的基于原型的继承模型。</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi mi"><img src="../Images/f2e714ca6abf726c62eb94628b158bd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1_k5aW2g8tdznmKUqjrqrA.png"/></div></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk translated">我们需要两个类来为我们的BST建模</figcaption></figure><p id="2c58" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们需要一个<code class="fe me mf mg mh b">Node</code>和一个<code class="fe me mf mg mh b">BST</code>类来构建我们的树。我们将要构建的<code class="fe me mf mg mh b">BST</code>将包含帮助我们与树交互的方法，而<code class="fe me mf mg mh b">Node</code>类将保存数据并跟踪它的两个子类。</p><p id="33e5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们还将使用两种不同的方法:<code class="fe me mf mg mh b">insert()</code>和<code class="fe me mf mg mh b">delete()</code>，我们将在下面跳到这两种方法。您可以使用while循环遍历节点，也可以使用递归。在每一个例子中，我都选择使用迭代，因为在我看来它更容易阅读和理解。</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><h2 id="81b0" class="ko kp it bd kq kr ks dn kt ku kv dp kw kb kx ky kz kf la lb lc kj ld le lf lg bi translated">插入(新节点):</h2><p id="36dc" class="pw-post-body-paragraph jq jr it js b jt lh jv jw jx li jz ka kb lj kd ke kf lk kh ki kj ll kl km kn im bi translated">当将一个节点插入BST时，我们将像往常一样从根节点开始并询问:“我们插入的值是大于当前节点的值还是小于当前节点的值？”如果值<em class="lm">大于</em>，我们继续向下通过<code class="fe me mf mg mh b">currentNode.right</code>，否则如果值<em class="lm">小于</em>，我们继续向下通过<code class="fe me mf mg mh b">currentNode.left</code>。如果子节点的值是<code class="fe me mf mg mh b">null</code>，那么我们已经找到了BST上需要覆盖的节点位置。</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi mq"><img src="../Images/ba054406348e89e3987831449b058d0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*US0K_wbrr1AeZkqx2ul59g.png"/></div></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk translated">BST的insert()方法的实现</figcaption></figure><h2 id="d4d1" class="ko kp it bd kq kr ks dn kt ku kv dp kw kb kx ky kz kf la lb lc kj ld le lf lg bi translated">删除(旧节点):</h2><p id="c911" class="pw-post-body-paragraph jq jr it js b jt lh jv jw jx li jz ka kb lj kd ke kf lk kh ki kj ll kl km kn im bi translated">当从BST中删除一个节点时，我们将从根节点重新开始，并询问:“我们删除的值是大于当前节点的值还是小于当前节点的值？”如果值<em class="lm">大于</em>，我们向下遍历<code class="fe me mf mg mh b">currentNode.right</code>，否则如果值<em class="lm">小于</em>，我们向下遍历<code class="fe me mf mg mh b">currentNode.left</code>。然而，一旦我们找到了想要删除的值，事情就有点棘手了。首先，我们必须跟踪<code class="fe me mf mg mh b">prevNode </code>，例如<code class="fe me mf mg mh b">parentNode</code>，一旦我们到达差异节点，就会有很多<code class="fe me mf mg mh b">if/else</code>案例的<strong class="js iu">和</strong>，所以让我们浏览一下:</p><p id="54ea" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">我们到达那里，节点的两个子节点都是空的(它没有子节点):</strong>这是一个比较简单的情况——在这种情况下，您只需将<code class="fe me mf mg mh b">parentNode</code>设置为<code class="fe me mf mg mh b">null</code>并返回。</p><p id="2950" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">我们到达那里，只有一个节点的子节点不为空(它有一个子节点):</strong>这将是另一个简单的情况——这里您可以用任何不是<code class="fe me mf mg mh b">null</code>的<code class="fe me mf mg mh b">childNode</code>来覆盖<code class="fe me mf mg mh b">parentNode</code>。</p><p id="d55f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">我们到达那里，节点的两个子节点都不为空(它有两个子节点):</strong>在这种情况下，我们需要在<code class="fe me mf mg mh b">parentNode</code>的<strong class="js iu">右子树</strong>中寻找<strong class="js iu">最小的</strong> <strong class="js iu">值</strong>，然后我们将取这个最小值节点并用这个最小的右子树值覆盖<code class="fe me mf mg mh b">parentNode</code>的值。</p><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi mr"><img src="../Images/41413dfb547954f333fa376cbf4b915a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fuU3KxadD8w-xrwhsDK0MQ.png"/></div></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk translated">remove()的helper方法</figcaption></figure></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi ms"><img src="../Images/794b78ddc08a64ce69e139c6241d9fa4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p8R-K39j6R9inWu0nmBPYQ.png"/></div></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk translated">remove()方法的实现</figcaption></figure><p id="afa7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我希望这是对BST实现的一个很好的概述。我的目标是在另一篇文章中扩展这个实现，也许以后还会处理一棵时髦的红黑树！在那之前，保重！</p></div><div class="ab cl mj mk hx ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="im in io ip iq"><div class="lo lp lq lr gt mt"><a href="https://skilled.dev" rel="noopener  ugc nofollow" target="_blank"><div class="mu ab fo"><div class="mv ab mw cl cj mx"><h2 class="bd iu gy z fp my fr fs mz fu fw is bi translated">编写面试问题</h2><div class="na l"><h3 class="bd b gy z fp my fr fs mz fu fw dk translated">编码面试课程</h3></div><div class="nb l"><p class="bd b dl z fp my fr fs mz fu fw dk translated">技术开发</p></div></div><div class="nc l"><div class="nd l ne nf ng nc nh lx mt"/></div></div></a></div></div></div>    
</body>
</html>