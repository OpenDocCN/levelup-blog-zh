<html>
<head>
<title>Using ‘prototype’ vs ‘this’ in a Javascript class can help save memory</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Javascript类中使用“prototype”和“this”可以帮助节省内存</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/using-prototype-vs-this-in-a-javascript-class-can-help-save-memory-816636418c3e?source=collection_archive---------7-----------------------#2020-04-09">https://levelup.gitconnected.com/using-prototype-vs-this-in-a-javascript-class-can-help-save-memory-816636418c3e?source=collection_archive---------7-----------------------#2020-04-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="704c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">“原型”有助于消除代码冗余，从而提高应用程序的性能。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/6326e1b2eee673bfaf5750807371a948.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gHYHD8d9nNZ9x5-e"/></div></div></figure><p id="51ee" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi la translated"><span class="l lb lc ld bm le lf lg lh li di">如果</span>您正在寻求优化应用程序的资源或内存，您应该使用<code class="fe lj lk ll lm b">prototype</code>。在构造函数中声明<code class="fe lj lk ll lm b">this</code>会导致对象冗余，尤其是当属性是方法时。想象一下，使用大量带有重复信息的构造函数和对象构建一个复杂的应用程序。让我们探索一下<code class="fe lj lk ll lm b">this</code> vs <code class="fe lj lk ll lm b">prototype.</code>的用例</p><h1 id="d8c3" class="ln lo it bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">在开始之前</h1><p id="2bbb" class="pw-post-body-paragraph jq jr it js b jt ml jv jw jx mm jz ka kb mn kd ke kf mo kh ki kj mp kl km kn im bi translated">值得注意的是，Javascript是一种面向原型的语言。您使用的每一种数据类型都将来自现有的原型。当我们创建新对象时，它是从一个主构造函数创建的(它有自己的绑定方法)。这将允许新变量和方法之间的访问。这里有一个<a class="ae mq" href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Object_prototypes" rel="noopener ugc nofollow" target="_blank">链接</a>到MDN，它提供了更多关于对象原型的背景知识。</p></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="9ce3" class="ln lo it bd lp lq my ls lt lu mz lw lx ly na ma mb mc nb me mf mg nc mi mj mk bi translated">在构造函数中使用“this”</h1><p id="a29b" class="pw-post-body-paragraph jq jr it js b jt ml jv jw jx mm jz ka kb mn kd ke kf mo kh ki kj mp kl km kn im bi translated">我们从创建一个对象构造器<em class="nd">开始，不使用‘原型’</em>。注意我们是如何使用<code class="fe lj lk ll lm b">this</code>的。让我们创建一个CoffeeOrder类，它具有一个调用客户订单的函数:</p><pre class="kp kq kr ks gt ne lm nf ng aw nh bi"><span id="afc1" class="ni lo it lm b gy nj nk l nl nm">class CoffeeOrder {<br/>  constructor(name, drink) {<br/>    this.name = name;<br/>    this.drink = drink;<br/>    this.callOrder = function() {<br/>     return `I have a ${this.drink} for ${this.name}!`;<br/>    }<br/>  }<br/>}</span><span id="7cc5" class="ni lo it lm b gy nn nk l nl nm">const order1 = new CoffeeOrder('Eleanor', 'Vanilla Latte');<br/>const order2 = new CoffeeOrder('Bob', 'Drip Coffee');</span></pre><p id="02ee" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果将属性添加到<code class="fe lj lk ll lm b">CoffeeOrder</code>类中的<code class="fe lj lk ll lm b">this</code>，那么<code class="fe lj lk ll lm b">CoffeeOrder</code> <em class="nd">的所有未来实例都将获得其自己的属性和方法的副本</em>，这会导致冗余。另一方面，使用<code class="fe lj lk ll lm b">this</code>对于访问和操作私有变量非常有用。但是让我们假设我们正在处理公共变量。</p><p id="f62b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是我们调用两个订单时的结果:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi no"><img src="../Images/72d96cff5bb74a1303e670f61d2192fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Z5_FQtCDoTbXJiHs.png"/></div></div><figcaption class="np nq gj gh gi nr ns bd b be z dk translated">order1和order2各自获得自己的callOrder方法副本。</figcaption></figure><p id="ac3e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"/><code class="fe lj lk ll lm b"><strong class="js iu">CoffeeOrder</strong></code><strong class="js iu">的每个实例都会收到一个</strong> <code class="fe lj lk ll lm b"><strong class="js iu">callOrder()</strong></code> <strong class="js iu">方法的副本。</strong>当<code class="fe lj lk ll lm b">callOrder()</code>方法在每个实例中都重复时，这可能会成为问题，因为它开始影响应用程序的性能和内存。</p><p id="dfc3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此外，我们可以看到两个<code class="fe lj lk ll lm b">callOrder()</code>方法是如何分开的，并维护它们自己的副本:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nt"><img src="../Images/e7556b88ecd79b6a87e94d10b000c9cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*bwKNoXxTJV-aqlp1.png"/></div></div><figcaption class="np nq gj gh gi nr ns bd b be z dk translated">订单1的callOrder与订单2的callOrder不同。每个人都有自己的副本。</figcaption></figure></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><h1 id="52f2" class="ln lo it bd lp lq my ls lt lu mz lw lx ly na ma mb mc nb me mf mg nc mi mj mk bi translated">原型是解决方案</h1><p id="9eaf" class="pw-post-body-paragraph jq jr it js b jt ml jv jw jx mm jz ka kb mn kd ke kf mo kh ki kj mp kl km kn im bi translated">以下是使用原型方法的一些优点:</p><ol class=""><li id="4795" class="nu nv it js b jt ju jx jy kb nw kf nx kj ny kn nz oa ob oc bi translated">如果你给<code class="fe lj lk ll lm b">callOrder.prototype</code>添加了一个属性，那么这个属性将<strong class="js iu">在与类</strong>相关的所有对象中共享，包括所有使用<code class="fe lj lk ll lm b">new CoffeeOrder</code>创建的未来对象。<em class="nd">共享</em>属性不同于<em class="nd">复制</em>。实例可以通过原型链借用这个方法，这将进一步讨论。</li><li id="ae60" class="nu nv it js b jt od jx oe kb of kf og kj oh kn nz oa ob oc bi translated">改变通过原型链继承的方法中的属性值将改变相关对象中的所有值。</li><li id="334c" class="nu nv it js b jt od jx oe kb of kf og kj oh kn nz oa ob oc bi translated">在大多数情况下，使用<code class="fe lj lk ll lm b">prototype</code>或<code class="fe lj lk ll lm b">this</code>是相似的，但是<code class="fe lj lk ll lm b">prototype</code>允许你节省内存，因为它只有一个实例，而不是每个对象都有自己的实例。</li></ol><p id="872c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们使用上面相同的例子，除了修订<code class="fe lj lk ll lm b">this.callOrder</code>和使用<code class="fe lj lk ll lm b">CoffeeOrder.<strong class="js iu">prototype</strong>.callOrder</code>代替:</p><pre class="kp kq kr ks gt ne lm nf ng aw nh bi"><span id="35d0" class="ni lo it lm b gy nj nk l nl nm">class CoffeeOrder {<br/>  constructor(name, drink) {<br/>    this.name = name;<br/>    this.drink = drink;<br/>   }<br/>}</span><span id="552a" class="ni lo it lm b gy nn nk l nl nm">CoffeeOrder.prototype.callOrder = function() {<br/> return `I have a ${this.drink} for ${this.name}!`;<br/>}</span><span id="5db5" class="ni lo it lm b gy nn nk l nl nm">const order1 = new CoffeeOrder("Eleanor", "Vanilla Latte");<br/>const order2 = new CoffeeOrder("Bob", "Drip Coffee");</span></pre><p id="a020" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">每个订单都有独特的名称和饮料，这就是为什么在<code class="fe lj lk ll lm b">name</code>和<code class="fe lj lk ll lm b">drink</code>上使用<code class="fe lj lk ll lm b">this</code>是可以接受的。但是所有的命令都以同样的方式发出，那么为什么<code class="fe lj lk ll lm b">callOrder</code>要一遍又一遍地重复呢？当我们运行我们的函数时，<code class="fe lj lk ll lm b">CoffeeOrder</code>的每个实例都复制我们的<code class="fe lj lk ll lm b">callOrder()</code>方法，因为它现在是原型的一部分，不能被复制:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oi"><img src="../Images/8e0eec11bdda8a23f8ad4b1db210e71f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*occtOVGFkFFDrcuK.png"/></div></div><figcaption class="np nq gj gh gi nr ns bd b be z dk translated">我们可以在<code class="fe lj lk ll lm b">__proto__</code>下面看到<code class="fe lj lk ll lm b">callOrder</code></figcaption></figure><p id="0ed8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">原型链可以在<code class="fe lj lk ll lm b">__proto__</code>下找到，它是每个实例中的一个<strong class="js iu">对象，指向创建它的原型。另一方面，在JS中创建的每个函数中都可以找到<code class="fe lj lk ll lm b">prototype</code>属性。它是类构造函数的<strong class="js iu">属性。</strong></strong></p><p id="a54c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe lj lk ll lm b">__proto__: Object</code>向我们展示了JavaScript如何将<code class="fe lj lk ll lm b">order1</code>和<code class="fe lj lk ll lm b">order2</code>分配给一个对象构造函数——这允许我们从分配的原型中访问所有方法。因此，两种<code class="fe lj lk ll lm b">callOrder()</code>方法可以共享:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oj"><img src="../Images/813caf2c5e8114198a48b66a0bbd6d79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*l3QoMTvckpd_F5tn.png"/></div></div><figcaption class="np nq gj gh gi nr ns bd b be z dk translated">callOrder在order1和order2中使用的方法，因为我们可以从原型访问相同的方法。</figcaption></figure></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><p id="c935" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们之前实现了<code class="fe lj lk ll lm b">CoffeeOrder.<strong class="js iu">prototype</strong>.callOrder</code>，现在知道了方法是如何共享的。这是它的叫法。同样，所有的咖啡订单都是以同样的方式发出的，所以之前使用<code class="fe lj lk ll lm b">prototype</code>非常有用并且节省内存:</p><pre class="kp kq kr ks gt ne lm nf ng aw nh bi"><span id="9c59" class="ni lo it lm b gy nj nk l nl nm">order1.callOrder();<br/>&gt; "I have a Vanilla Latte for Eleanor!"</span><span id="4b8e" class="ni lo it lm b gy nn nk l nl nm">order2.callOrder();<br/>&gt; "I have a Drip Coffee for Bob!"</span></pre><h1 id="d2e2" class="ln lo it bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">最后的想法</h1><p id="7ee1" class="pw-post-body-paragraph jq jr it js b jt ml jv jw jx mm jz ka kb mn kd ke kf mo kh ki kj mp kl km kn im bi translated">在<code class="fe lj lk ll lm b">this</code>示例中，我们将属性<code class="fe lj lk ll lm b">callOrder</code>添加到通过该类创建的每个实例中。在<code class="fe lj lk ll lm b">prototype</code>的例子中，我们与用<code class="fe lj lk ll lm b">CoffeeOrder</code>类创建的所有实例共享<code class="fe lj lk ll lm b">callOrder</code>属性。我们现在可以节省内存和性能！如果你对已经运行的测试感兴趣(展示原型如何节省内存)，那么看看这个<a class="ae mq" href="https://stackoverflow.com/a/3493725/12375740" rel="noopener ugc nofollow" target="_blank">stack overflow线程。</a></p></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><p id="ef2c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请随时伸出手或分享一个例子，当你使用原型与这一点。感谢阅读！</p></div></div>    
</body>
</html>