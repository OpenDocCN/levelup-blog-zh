# 对反应钩的深入研究

> 原文：<https://levelup.gitconnected.com/dissecting-react-hooks-how-to-use-them-and-are-they-replacing-redux-4bb96fa7569d>

![](img/ae124fd88824ede120bb29ab2d68f830.png)

Shane Aldendorff 在 [Unsplash](https://unsplash.com/search/photos/magnifying-glass?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上拍摄的照片

Hooks 刚刚登陆 React v16.8 的生产版本，它带来了一种新的思考和使用 React 的方式。简而言之，React 挂钩将我们构建组件的方式从面向对象(类)转向了函数式方法。正如在[文档](https://reactjs.org/docs/hooks-intro.html)中所述，使用类/继承以及为类方法绑定`this`的需要让很多人感到困惑，尤其是初学者。有了 React 钩子，就不再是这样了。事实上，现在编写组件的速度非常快，用状态来改造组件不需要您将整个组件从功能组件重写为类组件。

我强烈推荐阅读关于钩子的[文档](https://reactjs.org/docs/hooks-intro.html)，这会给你一个关于钩子的很好的概述。有些例子会与 React 主页上的非常相似，甚至完全匹配，但我想为以后的思考和实验打下基础。

这里有一个完整的工作库。您可以克隆它以拥有一个操场，并返回到不同的提交，每个提交代表本文的一个部分。

# 简单状态

现在使用状态非常简单。您可以使用`useState`钩子来定义和检索状态及其变更处理程序:

第 4 行是用钩子定义一个状态变量和一个状态改变处理程序所需要的全部内容。仅这一点就比类组件状态处理有很大的优势。此外，您还可以快速插入和取出状态。`count`是您的状态变量，`setCount`是状态变化处理程序，`useState()`调用中的`0`定义了一个初始值。

## 浅谈操作者和绩效

如果你只想了解语用钩子的用法，你可以跳过这一部分。

拥有一个类组件并使用类方法进行状态修改给了你一个优势:原型继承。也许这对你来说并没有真正的意义，如果是这样，不用担心。这意味着所有的组件实例都是从一个蓝图——原型——派生出来的，并且仍然是连接在一起的。当定义类方法时，函数只在原型中声明一次，所有组件实例都有指向该函数的指针。关键是有很多组件实例，例如 2000 个计数器，仍然只有一个共享函数声明。功能组件没有那个。在功能组件中使用状态处理程序迫使我们使用箭头函数，在组件的呈现/返回部分调用状态改变处理程序。拥有 2000 个计数器会导致在每次(重新)渲染时声明 2000 个箭头函数。

我确信开发 React 的人考虑到了这一点，他们推荐使用 [react-window](https://github.com/bvaughn/react-window) 来显示更长的组件列表，但这仍然是一个困扰我的问题。如果你有解释，请告诉我。

> 更新:事实证明，正常用例没有明显的性能缺陷。只有在极端情况下才会影响性能。详细回答见[此处](https://reactjs.org/docs/hooks-faq.html#are-hooks-slow-because-of-creating-functions-in-render)。

# 处理更复杂的状态

处理更大的对象或多个状态变量通常是必要的。在这种情况下，像`0`这样简单的初始值是不够的。虽然您可能会将`0`(来自反例)重新分配给一个对象或任何其他对象，但这绝对是不推荐的**。相反，我们有其他选择来处理更复杂的状态。**

1.  **又多了一个`useState`钩子:**

**对于很多变量使用这种结构会变得混乱，并且不建议增加复杂性，但是对于一两个其他状态值，这应该没问题。**

**2.具有状态对象:**

**就是这里，老好人`setState`。对于复杂的状态来说，这可能不是最干净的解决方案(我们马上就会看到哪个更好)，但是对于中等大小的状态来说，这肯定是可行的，因为在这些状态中，reducers 的使用太多了**

**3.使用减速器:**

**如果您以前使用过 redux，这可能对您来说很熟悉。这不是巧合，因为[丹·阿布拉莫夫](https://overreacted.io)(Redux 的最初创造者)已经在脸书工作了一段时间，并且非常积极地参与 React 钩子的开发。正如你所看到的，通过`useReducer`使用 reducers 有更大的开销，但是它给了你一个清晰的结构，并且将一些逻辑保留在组件本身之外。虽然我是 [MobX](https://mobx.js.org/) 的忠实粉丝，但是有一个预定义的钩子来使用减速器的可能性是很好的。它只是让你有可能以你喜欢的方式处理你的状态。**

**![](img/bbea76f82fab3de06200408b8c88e903.png)**

**照片由[阿格巴洛斯](https://unsplash.com/photos/rBPOfVqROzY?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)在 [Unsplash](https://unsplash.com/search/photos/timer?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上拍摄**

# **AJAX、定时器、事件监听器等等**

**这些被称为副作用，意味着组件触发了页面或脚本中某处的变化，而这些变化不包含在组件本身中，也不局限于组件本身。假设我们想要进行一个后端调用，获取一些数据，然后用 React 呈现它。我们必须启动后端调用，它也将返回一些数据。无论组件是否仍然安装，调用都会返回。超时和间隔也是如此。**

**使用 class-syntax，您可以编写一个`componentDidMount()`方法来启动请求，设置计时器或时间间隔等。——还有`componentWillUnmount()`收拾一切。我们如何用钩子做到这一点？**

**`useEffect`是 React 团队的回答。它接受两个参数，一个是渲染后触发的函数，另一个是可能的状态值数组，这意味着如果且仅当其中一个值发生变化时，效果函数才会被触发。默认情况下，在每次(重新)渲染后，效果函数被调用**。我们还可以从效果函数中返回另一个函数，姑且称之为清理函数。这将在卸载或每次(重新)渲染之前调用，取决于“监视”数组。****

**让我们看一下代码:**

**总结一下:**

1.  **如果 count 的值触发了重新渲染，则在第一次渲染之后、每次渲染之后以及每次重新渲染之后，都会调用效果函数。**
2.  **如果 count 的值触发了重新渲染，则清理功能会在重新渲染之前运行。此外，这正好在卸载之前运行。**
3.  **“watch”-数组(注意，这不是它的真名，我只是想解释一下意思)定义了在决定调用 1 时，React 应该考虑哪些变量。第二。这可以指组件状态甚至道具。**

**当传递一个空数组`[]`时，没有任何变量需要“观察”，效果函数在第一次渲染后只运行一次。清理功能也是如此，它在卸载之前运行。**

**根据您的用例，您必须提供 React 应该观察的变量。AJAX 调用、超时和时间间隔应该只设置一次，而根据您的状态进行更改应该在每次您的状态改变时运行。**

## **设置间隔**

**在写这篇文章的时候，我想试用一下我常用的工具`setInterval`。我试着设置计数器来增加每秒的计数。我的第一次尝试是这样的:**

**我认为时间间隔应该设置一次，并且只在卸载前清理，将`[]`作为“监视”数组传递。玩了一圈后，我意识到有问题，计数器只增加一次。内部似乎有一个问题(React dev 团队已知)，阻止了`setInterval`正常工作。我试图删除“watch”数组，认为我没有正确理解它，结果如下:**

**它在工作，但不正确。事实上，该间隔在组件渲染之前被中断，实际上触发了重新渲染本身，并在渲染之后重新开始。这将导致每个间隔有几毫秒的延迟。**

**环顾四周，我发现推荐的解决方案是实现一个定制的挂钩:**

**来源:丹·阿布拉莫夫对[反应过度](https://overreacted.io/making-setinterval-declarative-with-react-hooks/)**

**似乎区间回调在 React 的深处“迷失”了，需要手动处理它。我同意丹·阿布拉莫夫的说法:**

> **即使一个 API 简化了一百个用例，讨论也总是集中在变得更难的用例上。**

**然而，我不明白为什么首先，`useInterval` -hook 没有包含在 React 本身中——`setInterval`不是一个病态用例，至少在我看来是这样——其次，为什么 React 文档中没有提到它。**

> **更新:文章这一部分的措辞不完全正确。从字面上看，没有“问题”，也没有什么“丢失”,这实际上是预期的行为，是由 JavaScript 闭包引起的。**

## **事件监听器**

**根据文档，就性能而言，事件侦听器似乎可以在每次渲染时进行清理和设置。这意味着您可以省略“watch”数组。我认为在卸载之前只清理一次并保留事件监听器更干净，提供一个空的“监视”数组，如下所示:**

> **更新:虽然这个设置适用于给定的示例，但是空的“watch”-array(dependencies-array)是否有利于这样做是有争议的。[文档](https://reactjs.org/docs/hooks-effect.html#tip-optimizing-performance-by-skipping-effects)声明传递一个空的“监视”数组是可能的，但不一定推荐，因为这可能会导致错误。“更干净”这个词可能应该换成“一开始更直观”。**

## **使用效果总结**

**在我看来效果似乎还不错。他们将`componentDidMount`、`componentWillUpdate`以及`componentWillUnmount`组合在一个 API 中，但是我认为它变得太复杂了。如果这些函数中的逻辑增加，组件的大小也会增加，尽管您可能应该使用更复杂的逻辑来实现[定制钩子](https://reactjs.org/docs/hooks-custom.html)。返回一个清理函数确实感觉有点不舒服，并且调用默认渲染效果(设置+清理)的原因对我来说似乎不直观。**

**![](img/e38893920d7bb09d85abb1762f3ee4c6.png)**

**查尔斯·弗劳恩德在 [Unsplash](https://unsplash.com/search/photos/train-station?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上拍摄的照片**

# **全球状态和环境**

**不久前 React 介绍了上下文。上下文应该用于定义和共享多个组件级别的状态，**而**不需要像`props`一样将状态向下传递到每个级别。基本上，这就是像 Redux 和 MobX 这样的状态管理系统的目标:以一种分离的和可伸缩的方式处理状态。使用上下文的想法是好的，但是声明和用法不是。为什么？要使用它，你必须用`<Context.Consumer />`包装组件。有了钩子，hoc 的必要性应该消失了，我们应该能够在我们的组件中直接使用上下文。**

**React 文档没有告诉我们太多关于用法的信息。我们得到的唯一一句话是:**

```
const context = useContext(Context);
```

**第一个想法是检索上下文非常简单，无论上下文提供什么，您都可以通过`useContext`接收它。然而，自从引入上下文以来，对上下文状态的定义并没有改变。这意味着我们必须在组件本身中保持上下文状态，并在顶层呈现一个`<Context.Provider />`(或者至少在上下文消费之上)。**

**我们最终得到以下结果:**

**为了处理上下文状态，我们最终创建了一个 ContextProvider 组件。拥有多个 ContextProviders 会导致混乱，一般来说，以组件的形式声明上下文没有多大意义。曾经，声明的上下文很容易被`useContext()`消耗掉。**

**理想的解决方案应该是这样的:**

**不知道语法可行性有多大。我假设当调用`useState()`或`useReducer()`钩子时，当前创建一个组件被订阅的状态。在我看来，为了上下文做同样的事情应该不成问题。此外，保存上下文状态的组件不做其他任何事情，所以为什么还要有那个组件呢。**

**我不确定 React hooks + context 是否是可伸缩状态管理的可行解决方案。声明 ContextProvider 的最后一步似乎很繁琐。**

**然而，我们目前只有来自上面的解决方案。最后，钩子是一种非常受欢迎的反应改进，不亚于向函数式方法的范式转变。**

***关于作者:Lukas Gisder-Dubé作为 CTO 共同创立并领导了一家初创公司 1 年半，建立了技术团队和架构。离开创业公司后，他作为首席讲师在*[*iron hack*](https://medium.com/u/1ff093a3da32?source=post_page-----4bb96fa7569d--------------------------------)*教授编程，现在正在柏林建立一家创业机构&咨询公司。查看*[*Dube . io*](https://dube.io)*了解更多。***

**![](img/840b0ca008c4fa8e0a1d00791a6c9f9f.png)****[![](img/9914c5dd23ac08b70eea6f4f9ba6fed2.png)](https://levelup.gitconnected.com)****[](https://gitconnected.com/learn/react) [## 学习 React -最佳 React 教程(2019) | gitconnected

### 排名前 49 的 React 教程-免费学习 React。课程由开发人员提交并投票，使您能够…

gitconnected.com](https://gitconnected.com/learn/react)**