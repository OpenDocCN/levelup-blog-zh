<html>
<head>
<title>WebSocket Simplified</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">简化的WebSocket</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/websocket-simplified-b532f266cc9f?source=collection_archive---------2-----------------------#2019-07-03">https://levelup.gitconnected.com/websocket-simplified-b532f266cc9f?source=collection_archive---------2-----------------------#2019-07-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/74a5964a1f3b6393d390abdf04c0602b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4YPF_CbZaviAbpRLJ1UpAg.jpeg"/></div></div></figure><p id="4c43" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是我将撰写的WebSocket系列的第一篇文章，目标是尽可能用最简单的方式解释事情。让我们直接开始吧。</p><p id="5b09" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">WebSockets允许用户通过持久的双向连接向服务器发送和接收消息。所以基本上，这是<strong class="kd iu">客户端</strong>和<strong class="kd iu">服务器</strong>之间的一种通信方式。让我们先了解一下这个<strong class="kd iu">通信</strong>，我们一会儿再回到WebSockets。</p><h1 id="0d54" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">客户端和服务器</h1><p id="20fe" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">Web浏览器(客户端)和服务器通过TCP/IP进行通信。超文本传输协议(HTTP)是位于TCP/IP之上的标准应用协议<em class="mc">，支持请求(来自网络浏览器)和响应(来自服务器)。</em></p><h1 id="ffa3" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">这是如何工作的？</h1><p id="7f5c" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">让我们通过这些简单的步骤:-</p><ol class=""><li id="fe5e" class="md me it kd b ke kf ki kj km mf kq mg ku mh ky mi mj mk ml bi translated">客户端向服务器发送请求。</li><li id="b900" class="md me it kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated">建立了连接。</li><li id="c121" class="md me it kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated">服务器发回响应。</li><li id="265a" class="md me it kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated">客户端收到响应。</li><li id="6647" class="md me it kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated">连接已关闭。</li></ol><p id="79cd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是对客户机和服务器之间的标准通信如何工作的简单概述。现在仔细看看第五步。</p><blockquote class="mr ms mt"><p id="53ea" class="kb kc mc kd b ke kf kg kh ki kj kk kl mu kn ko kp mv kr ks kt mw kv kw kx ky im bi translated"><em class="it">连接关闭。</em></p></blockquote><p id="2eb0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">HTTP请求已经达到了它的目的，不再需要它，因此连接被关闭。</p><h2 id="82d5" class="mx la it bd lb my mz dn lf na nb dp lj km nc nd ln kq ne nf lr ku ng nh lv ni bi translated">如果服务器想给客户端发送消息怎么办</h2><p id="be84" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">在我们的标准请求/响应场景中，必须从请求开始建立连接以开始通信。如果服务器想要发送一条消息，客户端必须发送另一个请求来建立连接并接收消息。</p><h2 id="2bda" class="mx la it bd lb my mz dn lf na nb dp lj km nc nd ln kq ne nf lr ku ng nh lv ni bi translated">客户端如何知道服务器想要发送消息？</h2><p id="407b" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">考虑这个例子:<br/> <em class="mc">客户快要饿死了，在网上订购了一些食物。他每秒发出一个请求来检查订单是否准备好了。</em></p><blockquote class="mr ms mt"><p id="2d95" class="kb kc mc kd b ke kf kg kh ki kj kk kl mu kn ko kp mv kr ks kt mw kv kw kx ky im bi translated">食物准备好了吗？(客户端)<br/> 0秒:不，等等。(服务器)<br/> 1秒:菜好了吗？(客户端)<br/> 1秒:不，等等。2秒:食物准备好了吗？2秒:不，等等。3秒:食物准备好了吗？是的，先生，这是您点的菜。(服务器)</p></blockquote><p id="9210" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这就是你所谓的<strong class="kd iu"> HTTP轮询</strong>。客户端反复向服务器发出请求，并检查是否有消息要接收。</p><p id="2922" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如你所见，这不是很有效率。我们正在使用不必要的资源，失败请求的数量也很麻烦。</p><h2 id="61a6" class="mx la it bd lb my mz dn lf na nb dp lj km nc nd ln kq ne nf lr ku ng nh lv ni bi translated">有什么方法可以克服这个问题吗</h2><p id="6b50" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">是的，有一种轮询技术可以用来克服这种缺陷，它被称为<strong class="kd iu"> <em class="mc">长轮询</em> </strong>。</p><blockquote class="mr ms mt"><p id="9b73" class="kb kc mc kd b ke kf kg kh ki kj kk kl mu kn ko kp mv kr ks kt mw kv kw kx ky im bi translated"><em class="it">长轮询基本上包括向服务器发出一个HTTP请求，然后保持连接打开，以允许服务器稍后响应(由服务器决定)。</em></p></blockquote><p id="d1e3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">考虑上面例子的<strong class="kd iu">长轮询</strong>版本:-</p><blockquote class="mr ms mt"><p id="4094" class="kb kc mc kd b ke kf kg kh ki kj kk kl mu kn ko kp mv kr ks kt mw kv kw kx ky im bi translated">食物准备好了吗？是的，先生，这是您点的菜。(服务器)</p></blockquote><p id="4d04" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">耶，问题解决了。<br/>不完全是。虽然长轮询有效，但它在CPU、内存和带宽方面非常昂贵(<em class="mc">，因为我们在保持连接打开时阻塞了资源</em>)。</p><p id="a37c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们现在要干嘛？看起来事情正在失去控制。让我们回到我们的救世主:<strong class="kd iu"> WebSocket </strong>。</p><h1 id="28ac" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">为什么选择WebSockets</h1><p id="33fd" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">如您所见，为了模拟客户机和服务器之间的实时通信，轮询和长轮询都是非常昂贵的选择。这种性能瓶颈是您希望使用WebSocket的原因。</p><p id="8eb3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">WebSockets不需要你发送请求来响应。它们允许双向数据流，所以你只需要监听任何数据。</p><blockquote class="mr ms mt"><p id="525e" class="kb kc mc kd b ke kf kg kh ki kj kk kl mu kn ko kp mv kr ks kt mw kv kw kx ky im bi translated">你可以监听服务器，当它可用时，它会给你发送一条信息。</p></blockquote><p id="79f0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们看看WebSocket的性能方面。</p><h1 id="cea5" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">资源消耗</h1><p id="2ed5" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">下图显示了在一个相对常见的用例中，WebSockets与长轮询之间的带宽消耗差异:</p><figure class="nk nl nm nn gt ju gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/4803f32db2cdca434ea4ae6bafd6e841.png" data-original-src="https://miro.medium.com/v2/resize:fit:1006/format:webp/0*84f2Tr-e6RU1FJQx.png"/></div></figure><p id="5cdf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这种差异是巨大的，并且随着请求的数量呈指数增长。</p><h1 id="b0e0" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">速度</h1><p id="753c" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">以下是每秒钟每个连接处理1、10和50个请求的结果:</p><figure class="nk nl nm nn gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi no"><img src="../Images/2be4f3c0b9bedd717110ac03cd7c8a3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*GCWL3VKsi_uDD9p1.png"/></div></div></figure><p id="0a2e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如您所见，使用<a class="ae np" href="https://hashnode.com/util/redirect?url=http://Socket.io" rel="noopener ugc nofollow" target="_blank"> Socket.io </a>为每个连接发出一个请求要慢50%,因为必须首先建立连接。这种开销较小，但对于十个请求来说仍然很明显。对于来自同一连接的50个请求，<a class="ae np" href="https://hashnode.com/util/redirect?url=http://Socket.io" rel="noopener ugc nofollow" target="_blank"> Socket.io </a>已经快了50%。为了更好地了解峰值吞吐量，我们将查看每个连接请求数量更大(500、1000和2000)的基准:</p><figure class="nk nl nm nn gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi no"><img src="../Images/a12ca866e8d24aebde5ff01d23163911.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*DJvadHqs1ok7HZ2Q.png"/></div></div></figure><p id="d3ec" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里您可以看到HTTP基准测试的峰值大约是每秒950个请求，而<a class="ae np" href="https://hashnode.com/util/redirect?url=http://Socket.io" rel="noopener ugc nofollow" target="_blank"> Socket.io </a>每秒处理大约3900个请求。有效吧？</p><blockquote class="mr ms mt"><p id="947b" class="kb kc mc kd b ke kf kg kh ki kj kk kl mu kn ko kp mv kr ks kt mw kv kw kx ky im bi translated"><em class="it">注:</em><a class="ae np" href="https://hashnode.com/util/redirect?url=http://Socket.io" rel="noopener ugc nofollow" target="_blank"><em class="it">socket . io</em></a><em class="it">是一个面向实时web应用的JavaScript库。它在内部实现WebSocket。可以把它看作WebSocket的包装器，它提供了更多的特性</em>(本系列的下一篇博文将详细解释<a class="ae np" href="https://hashnode.com/util/redirect?url=http://Socket.io" rel="noopener ugc nofollow" target="_blank">socket . io</a>)<em class="it">。</em></p></blockquote><h1 id="129e" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">WebSockets如何工作</h1><p id="6ad6" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">这些是建立WebSocket连接所涉及的步骤。</p><ol class=""><li id="990b" class="md me it kd b ke kf ki kj km mf kq mg ku mh ky mi mj mk ml bi translated">客户端(浏览器)向服务器发送一个HTTP请求。</li><li id="3a1a" class="md me it kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated">通过HTTP协议建立连接。</li><li id="2ef8" class="md me it kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated">如果服务器支持WebSocket协议，它同意升级连接。这叫做握手。</li><li id="31d4" class="md me it kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated">既然握手已经完成，初始的HTTP连接就被一个使用相同的底层TCP/IP协议的WebSocket连接所取代。</li><li id="adc5" class="md me it kd b ke mm ki mn km mo kq mp ku mq ky mi mj mk ml bi translated">此时，数据可以在客户机和服务器之间自由地来回流动。</li></ol><p id="4b2f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将创建两个文件:一个服务器和一个客户端。<br/>首先，创建一个名为<code class="fe nq nr ns nt b">client.html</code>的简单的<code class="fe nq nr ns nt b">&lt;html&gt;</code>文档，其中包含一个<code class="fe nq nr ns nt b">&lt;script&gt;</code>标签。让我们看看它看起来怎么样</p><h1 id="925a" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">Client.html</h1><pre class="nk nl nm nn gt nu nt nv nw aw nx bi"><span id="41e7" class="mx la it nt b gy ny nz l oa ob">&lt;html&gt;<br/><br/>&lt;script&gt;<br/>    // Our code goes here<br/>&lt;/script&gt;<br/><br/>&lt;body&gt;<br/>    &lt;h1&gt;This is a client page&lt;/h1&gt;<br/>&lt;/body&gt;<br/><br/>&lt;/html&gt;</span></pre><h1 id="dac0" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">Server.js</h1><p id="e9a1" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">现在创建另一个文件<code class="fe nq nr ns nt b">server.js</code>。导入HTTP模块并创建服务器。让它听<code class="fe nq nr ns nt b">port 8000</code>的。</p><p id="337c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这将作为一个简单的<code class="fe nq nr ns nt b">http</code>服务器监听<code class="fe nq nr ns nt b">port 8000</code>。让我们也来看看:</p><pre class="nk nl nm nn gt nu nt nv nw aw nx bi"><span id="35e8" class="mx la it nt b gy ny nz l oa ob">//importing http module<br/>const http = require('http');<br/><br/>//creating a http server<br/>const server = http.createServer((req, res) =&gt; {<br/>    res.end("I am connected");<br/>});<br/><br/>//making it listen to port 8000<br/>server.listen(8000);</span></pre><blockquote class="mr ms mt"><p id="a45f" class="kb kc mc kd b ke kf kg kh ki kj kk kl mu kn ko kp mv kr ks kt mw kv kw kx ky im bi translated"><em class="it">运行命令</em> <code class="fe nq nr ns nt b"><em class="it">node server.js</em></code> <em class="it">开始监听</em> <code class="fe nq nr ns nt b"><em class="it">port 8000</em></code> <em class="it">。你可以选择任何你喜欢的端口，我只是选择了8000，没有具体原因。</em></p></blockquote><p id="fb00" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">客户端和服务器的基本设置已经完成。很简单，对吧？现在让我们来看看好东西。</p><h1 id="2982" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">客户端设置</h1><p id="c9c2" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">要构造一个<strong class="kd iu"> WebSocket </strong>，使用返回<code class="fe nq nr ns nt b">websocket</code>对象的<code class="fe nq nr ns nt b">WebSocket()</code>构造函数。该对象提供了用于创建和管理到<strong class="kd iu">服务器</strong>的WebSocket连接的API。</p><p id="c462" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">简而言之，这个<code class="fe nq nr ns nt b">websocket</code>对象将帮助我们建立与服务器的连接，并创建双向数据流，即<em class="mc">从两端</em>发送和接收数据。</p><p id="c3bd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们看看如何:</p><pre class="nk nl nm nn gt nu nt nv nw aw nx bi"><span id="65d8" class="mx la it nt b gy ny nz l oa ob">&lt;html&gt;<br/><br/>&lt;script&gt;<br/>    //calling the constructor which gives us the websocket object: ws<br/>    let ws = new WebSocket('url'); <br/>&lt;/script&gt;<br/><br/>&lt;body&gt;<br/>    &lt;h1&gt;This is a client page&lt;/h1&gt;<br/>&lt;/body&gt;<br/><br/>&lt;/html&gt;</span></pre><p id="df2a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe nq nr ns nt b">WebSocket</code>构造函数需要一个URL来监听。在我们的例子中是<code class="fe nq nr ns nt b">'ws://localhost:8000'</code>,因为我们的服务器在那里运行。现在，这可能和你习惯的有点不同。我们没有使用<code class="fe nq nr ns nt b">HTTP</code>协议，而是使用<code class="fe nq nr ns nt b">WebSocket</code>协议。这将告诉客户端<strong class="kd iu">‘嘿，我们正在使用websocket协议’</strong>，因此是<code class="fe nq nr ns nt b">'ws://'</code>而不是<code class="fe nq nr ns nt b">'http://'</code>。够简单吗？现在让我们在<code class="fe nq nr ns nt b">server.js</code>中实际创建一个WebSocket服务器。</p><h1 id="b3fe" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">服务器设置</h1><p id="0b12" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">我们的节点服务器中需要一个第三方模块<code class="fe nq nr ns nt b">ws</code>来使用和设置<code class="fe nq nr ns nt b">WebSocket</code>服务器。</p><p id="e12f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，我们将导入<code class="fe nq nr ns nt b">ws</code>模块。然后我们将创建一个websocket服务器，并把监听<code class="fe nq nr ns nt b">port 8000</code>的<code class="fe nq nr ns nt b">HTTP</code>服务器交给它。</p><blockquote class="mr ms mt"><p id="1fa4" class="kb kc mc kd b ke kf kg kh ki kj kk kl mu kn ko kp mv kr ks kt mw kv kw kx ky im bi translated"><em class="it"> HTTP服务器监听端口8000，WebSocket服务器监听该HTTP服务器。基本上，就是听听者的话。</em></p></blockquote><p id="c3f8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们的websocket正在观察<code class="fe nq nr ns nt b">port 8000</code>上的流量。这意味着一旦客户端可用，它将尝试建立连接。我们的<code class="fe nq nr ns nt b">server.js</code>文件将如下所示:</p><pre class="nk nl nm nn gt nu nt nv nw aw nx bi"><span id="05f3" class="mx la it nt b gy ny nz l oa ob">const http = require('http');<br/>//importing ws module<br/>const websocket = require('ws');<br/><br/>const server = http.createServer((req, res) =&gt; {<br/>    res.end("I am connected");<br/>});<br/>//creating websocket server<br/>const wss = new websocket.Server({ server });<br/><br/>server.listen(8000);</span></pre><p id="c9d7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">正如我们之前讨论过的——<code class="fe nq nr ns nt b">WebSocket()</code>构造函数返回一个websocket对象，提供API来创建和管理到<strong class="kd iu">服务器</strong>的WebSocket连接。</p><p id="cbc5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这里，<code class="fe nq nr ns nt b">wss</code>对象会帮助我们监听某些事情发生时发出的<code class="fe nq nr ns nt b">Event</code>。如连接建立或握手完成或连接关闭等。</p><p id="884b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们来看看如何收听留言:</p><pre class="nk nl nm nn gt nu nt nv nw aw nx bi"><span id="e09a" class="mx la it nt b gy ny nz l oa ob">const http = require('http');<br/>const websocket = require('ws');<br/><br/>const server = http.createServer((req, res) =&gt; {<br/>    res.end("I am connected");<br/>});<br/>const wss = new websocket.Server({ server });<br/>//calling a method 'on' which is available on websocket object<br/>wss.on('headers', (headers, req) =&gt; {<br/>    //logging the header<br/>    console.log(headers);<br/>});<br/><br/>server.listen(8000);</span></pre><p id="318e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">方法<code class="fe nq nr ns nt b">'on'</code>需要两个参数:事件名和回调。事件名是我们想要监听/发出的，回调指定了如何处理它。在这里，我们只是记录了<code class="fe nq nr ns nt b">headers</code>事件。让我们看看我们得到了什么:</p><figure class="nk nl nm nn gt ju gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/37e836e4799940e69ddc1d8dde8fb71b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1316/format:webp/0*zdak5v9UpQDfNjmu.png"/></div></figure><p id="9aa9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是我们的HTTP头，我想让你对它好奇，因为这正是幕后发生的事情。让我们分解一下，以便更好地理解它。</p><ul class=""><li id="be9f" class="md me it kd b ke kf ki kj km mf kq mg ku mh ky od mj mk ml bi translated">您将注意到的第一件事是我们获得了状态代码<code class="fe nq nr ns nt b">101</code>。您可能见过<code class="fe nq nr ns nt b">200</code>、<code class="fe nq nr ns nt b">201</code>、<code class="fe nq nr ns nt b">404</code>状态代码，但这看起来不同。<code class="fe nq nr ns nt b">101</code>实际上是交换协议的状态码。上面写着<strong class="kd iu">“嘿，我想升级”</strong>。</li><li id="543d" class="md me it kd b ke mm ki mn km mo kq mp ku mq ky od mj mk ml bi translated">第二行显示升级信息。它指定它想要升级到<code class="fe nq nr ns nt b">websocket</code>协议。</li><li id="3884" class="md me it kd b ke mm ki mn km mo kq mp ku mq ky od mj mk ml bi translated">这实际上是握手过程中发生的事情。浏览器使用<code class="fe nq nr ns nt b">HTTP</code>连接建立使用<code class="fe nq nr ns nt b">HTTP/1.1</code>协议的连接，然后<code class="fe nq nr ns nt b">Upgrade</code>连接到<code class="fe nq nr ns nt b">websocket</code>协议。</li></ul><p id="2483" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在这将更有意义。</p><p id="0841" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">作为握手的一部分，在响应头被写入套接字之前发出<code class="fe nq nr ns nt b">Headers</code>事件。这允许您在发送前检查/修改标题。这意味着您可以修改标题以接受、拒绝或其他任何您喜欢的内容。默认情况下，它接受请求。</p><p id="e440" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">类似地，我们可以再添加一个事件<code class="fe nq nr ns nt b">connection</code>，当握手完成时发出这个事件。成功建立连接后，我们将向客户端发送一条消息。让我们看看如何:</p><pre class="nk nl nm nn gt nu nt nv nw aw nx bi"><span id="5c1f" class="mx la it nt b gy ny nz l oa ob">const http = require('http');<br/>const websocket = require('ws');<br/><br/>const server = http.createServer((req, res) =&gt; {<br/>    res.end("I am connected");<br/>});<br/>const wss = new websocket.Server({ server });<br/><br/>wss.on('headers', (headers, req) =&gt; {<br/>    //console.log(headers); Not logging the header anymore<br/>});<br/><br/>//Event: 'connection'<br/>wss.on('connection', (ws, req) =&gt; {<br/>    ws.send('This is a message from server, connection is established');<br/>    //receive the message from client on Event: 'message'<br/>    ws.on('message', (msg) =&gt; {<br/>        console.log(msg);<br/>    });<br/>});<br/><br/>server.listen(8000);</span></pre><p id="8f41" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们也在监听来自客户的事件<code class="fe nq nr ns nt b">message</code>。让我们来创建它:-</p><pre class="nk nl nm nn gt nu nt nv nw aw nx bi"><span id="5cf4" class="mx la it nt b gy ny nz l oa ob">&lt;html&gt;<br/><br/>&lt;script&gt;<br/>    let ws = new WebSocket('url'); <br/>    //logging the websocket property properties<br/>    console.log(ws);<br/>    //sending a message when connection opens<br/>    ws.onopen = (event) =&gt; ws.send("This is a message from client");<br/>    //receiving the message from server<br/>    ws.onmessage = (message) =&gt; console.log(message);<br/>&lt;/script&gt;<br/><br/>&lt;body&gt;<br/>    &lt;h1&gt;This is a client page&lt;/h1&gt;<br/>&lt;/body&gt;<br/><br/>&lt;/html&gt;</span></pre><p id="ecbf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是它在浏览器中的样子:-</p><figure class="nk nl nm nn gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oe"><img src="../Images/2f113ca31ced23c30b56943f5ebf76b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*xbBPZSeSut6wSwNl.png"/></div></div></figure><p id="4c5b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">第一个日志是列出websocket对象所有属性的<code class="fe nq nr ns nt b">WebSocket</code>，第二个日志是具有<code class="fe nq nr ns nt b">data</code>属性的<code class="fe nq nr ns nt b">MessageEvent</code>。如果你仔细看，你会看到我们从服务器上得到我们的信息。</p><p id="8cb4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">服务器日志将如下所示:</p><figure class="nk nl nm nn gt ju gh gi paragraph-image"><div class="gh gi of"><img src="../Images/686b91e296eded5fc189494c3f90cf72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1292/format:webp/0*kTl1R_LpvjaOVpTM.png"/></div></figure><p id="ff00" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们正确地接收了客户的信息。这标志着我们的连接成功建立。干杯！</p><h1 id="93f9" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">结论</h1><p id="2d83" class="pw-post-body-paragraph kb kc it kd b ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku mb kw kx ky im bi translated">综上所述，让我们回顾一下我们所学的内容:</p><ul class=""><li id="2b1e" class="md me it kd b ke kf ki kj km mf kq mg ku mh ky od mj mk ml bi translated">我们已经介绍了HTTP服务器如何工作，什么是轮询，长轮询。</li><li id="d9f4" class="md me it kd b ke mm ki mn km mo kq mp ku mq ky od mj mk ml bi translated">什么是WebSockets，为什么我们需要它们。</li><li id="275d" class="md me it kd b ke mm ki mn km mo kq mp ku mq ky od mj mk ml bi translated">我们讨论了它们在幕后是如何工作的，并对所使用的头文件有了更好的理解。</li><li id="60a6" class="md me it kd b ke mm ki mn km mo kq mp ku mq ky od mj mk ml bi translated">我们创建了自己的客户端和服务器，并成功地建立了它们之间的连接。</li></ul><p id="6b0a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是WebSockets及其工作原理的基础。本系列的下一篇文章将会更详细地介绍和使用<code class="fe nq nr ns nt b">socket.io</code>。我们还将看到，当唯一的原生<code class="fe nq nr ns nt b">WebSocket()</code>运行良好时，我们到底为什么需要<code class="fe nq nr ns nt b">socket.io</code>。当我们可以很好地成功发送和接收消息时，为什么要使用笨重臃肿的库呢？</p><p id="d4ad" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你觉得这篇文章有帮助，请分享，并关注下一篇。<br/>沙德。</p><h1 id="7776" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">参考</h1><ul class=""><li id="2956" class="md me it kd b ke lx ki ly km og kq oh ku oi ky od mj mk ml bi translated">Web socket—Web API | MDN:<a class="ae np" href="https://developer.mozilla.org/en-US/docs/Web/API/WebSocket" rel="noopener ugc nofollow" target="_blank">https://developer.mozilla.org/en-US/docs/Web/API/WebSocket</a></li><li id="c0df" class="md me it kd b ke mm ki mn km mo kq mp ku mq ky od mj mk ml bi translated"><code class="fe nq nr ns nt b">ws</code>节点服务器| Docs的模块:<a class="ae np" href="https://github.com/websockets/ws/blob/HEAD/doc/ws.md#event-headers" rel="noopener ugc nofollow" target="_blank">https://github . com/web sockets/ws/blob/HEAD/doc/ws . MD # event-headers</a></li></ul></div><div class="ab cl oj ok hx ol" role="separator"><span class="om bw bk on oo op"/><span class="om bw bk on oo op"/><span class="om bw bk on oo"/></div><div class="im in io ip iq"><p id="33eb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="mc">最初发布于</em><a class="ae np" href="https://iamshadmirza.hashnode.dev/websocket-simplified-cjxjzcu0m002i3hs1eewt2p80" rel="noopener ugc nofollow" target="_blank"><em class="mc">https://iamshadmirza . hashnode . dev</em></a><em class="mc">。</em></p></div></div>    
</body>
</html>