<html>
<head>
<title>Non-Blocking Java — Beyond the Hype</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">非阻塞Java——超越宣传</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/non-blocking-java-beyond-the-hype-dfdc405848d7?source=collection_archive---------8-----------------------#2020-05-18">https://levelup.gitconnected.com/non-blocking-java-beyond-the-hype-dfdc405848d7?source=collection_archive---------8-----------------------#2020-05-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="99dd" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">集装箱化世界中阻塞与非阻塞的比较</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/a47b9f18f6b230f084c8c06c7e99ce32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fiFa_AJDzGISU8WrAVTzbg.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图片由来自<a class="ae ky" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=567950" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae ky" href="https://pixabay.com/users/RyanMcGuire-123690/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=567950" rel="noopener ugc nofollow" target="_blank">瑞恩·麦奎尔</a>拍摄</figcaption></figure><p id="2b17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本月早些时候，我写了一篇名为<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/how-to-use-kubernetes-cron-jobs-to-periodically-read-the-news-8b3b4513f8b7">如何使用Kubernetes Cron Jobs定期阅读新闻</a>的文章。在其中，我创建了两个微服务:一个定期读取新闻API并将其存储在数据库中，另一个读取数据库并返回存储的新闻。读取数据库的微服务是用Java完成的，我用的是WebFlux，这是Spring Boot的反应式web服务。</p><p id="5133" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我使用WebFlux是因为我越来越欣赏它所呈现的流畅API的优雅。它迫使我在转换和过滤器方面进行思考，类似于Java 8刚问世时Java流库如何影响我的编码风格。现在，即使是一个<code class="fe lv lw lx ly b">List</code>对我来说也太具体了，我希望一切都是一个<code class="fe lv lw lx ly b">Flux</code>。</p><p id="bd0a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我不打算写WebFlux或者它所基于的<a class="ae ky" href="https://projectreactor.io/" rel="noopener ugc nofollow" target="_blank"> projectreactor.io </a>的教程。外面有很多好的教程；也许有一天我会写一些关于它的东西。我真正好奇的是对性能的要求，尽管我过去使用过WebFlux，但我从未有机会将其与传统的Spring服务进行比较。</p><p id="f592" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，对于本文，我将制作一个新的微服务，它与旧的微服务相同，只是它使用了老派的Spring。然后，我将使用<a class="ae ky" href="https://gatling.io/" rel="noopener ugc nofollow" target="_blank"> Gatling </a>创建一些性能测试，并运行反应式和非反应式测试，看看我会得出什么结果。最后，由于微服务是在Kubernetes上运行的，我将对它们进行扩展，看看这对性能有什么影响。</p><p id="887e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这篇文章的所有代码和脚本都可以在我的GitHub页面上找到，你可以在最后找到链接。为了跟上本文，你应该熟悉Java、Scala和一般的编程。您还应该可以访问Kubernetes集群，例如我在<a class="ae ky" href="https://medium.com/better-programming/kubernetes-from-scratch-4691283e3995" rel="noopener"> Kubernetes中从头开始构建的集群</a>，以及我在上面提到的<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/how-to-use-kubernetes-cron-jobs-to-periodically-read-the-news-8b3b4513f8b7">中构建的微服务系统如何使用Kubernetes Cron作业来定期阅读新闻</a>。</p><p id="901a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我从GitHub存储库中取出原始的<code class="fe lv lw lx ly b"><a class="ae ky" href="https://github.com/rkamradt/readnews/tree/v1.1" rel="noopener ugc nofollow" target="_blank">readnews</a></code>代码，并制作了一个名为<code class="fe lv lw lx ly b"><a class="ae ky" href="https://github.com/rkamradt/readnewsblock/tree/v1.0" rel="noopener ugc nofollow" target="_blank">readnewsblock</a></code>的新GitHub存储库。然后我用非反应式的风格重新写了一遍。让我们看看反应式的read微服务的核心。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="6b2e" class="md me it ly b gy mf mg l mh mi">  @GetMapping(path="", produces = MediaType.TEXT_EVENT_STREAM_VALUE)<br/>  Flux&lt;Inserts.Articles&gt; getFromMongo(<br/>           final Instant from, <br/>           final Instant to, <br/>           final Long limit) {<br/>    long actualLimit = limit == null <br/>           || limit == 0 <br/>           || limit &gt; MAX_LIMIT <br/>         ? MAX_LIMIT<br/>         : limit;<br/>    return newsReactiveRepository<br/>          .findAll()<br/>          .flatMap(r -&gt; Flux.fromIterable(r.getArticles()))<br/>          .filter(r -&gt; filterByDate(r, from, to))<br/>          .limitRequest(actualLimit);<br/>  }</span></pre><p id="1aab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，让我们看看非反应式风格的同一段代码。</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="b656" class="md me it ly b gy mf mg l mh mi">  @GetMapping(path="", produces = MediaType.APPLICATION_JSON_VALUE)<br/>  List&lt;Inserts.Articles&gt; getFromMongo(<br/>         final Instant from, <br/>         final Instant to, <br/>         final Long limit) {<br/>    long actualLimit = limit == null <br/>           || limit == 0 <br/>           || limit &gt; MAX_LIMIT <br/>         ? MAX_LIMIT<br/>         : limit;<br/>    return newsRepository<br/>          .findAll()<br/>          .stream()<br/>          .flatMap(r -&gt; r.getArticles().stream())<br/>          .filter(r -&gt; filterByDate(r, from, to))<br/>          .limit(actualLimit)<br/>          .collect(Collectors.toList());<br/>  }</span></pre><p id="628f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">风格其实很像。这是因为projectreactor.io API大量借用了Java流库的术语。把<code class="fe lv lw lx ly b">Flux</code>换成<code class="fe lv lw lx ly b">List</code>，实际上代码是一样的。我应该指出，这两个系统都不是非常有效的系统。它读取整个数据库并进行过滤。更好的选择是创建一个索引表，让数据库应用日期过滤器。但是我们在这里不是测试数据库，而是测试应用程序。有时您必须做出选择，这可能会导致使用暴力方法的代码。</p><p id="486e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">不过，我可以马上发现非反应式代码中的其他低效之处。MongoDB存储库的<code class="fe lv lw lx ly b">findAll</code>方法返回一个列表，控制器方法<code class="fe lv lw lx ly b">getFromMongo</code>也返回一个列表。这意味着返回的数据集必须在内存中保存两次，而反应式版本倾向于处理流中的项，可能永远不会一次在内存中保存多个项。不过，所谓的背压也有细微差别，反应式版本的最坏情况是所有项目同时保存在内存中。但这是被动反应的最坏情况，也是被动反应的唯一情况。代码的这一方面将通知我的测试，稍后您将会看到。</p><h2 id="d9d3" class="md me it bd mj mk ml dn mm mn mo dp mp li mq mr ms lm mt mu mv lq mw mx my mz bi translated">创建另一个Kubernetes服务。</h2><p id="0329" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">我将使用我的新代码库，并从中创建一个映像。这是通过<code class="fe lv lw lx ly b">mvn clean install jib:build</code>命令完成的。这将创建一个名为<code class="fe lv lw lx ly b">readnewsblock</code>的图像，可以在Kubernetes描述文件中使用。我将添加一个新的<code class="fe lv lw lx ly b">readnewsblock.yaml</code>到我的<a class="ae ky" href="https://github.com/rkamradt/news-deploy/tree/v1.1" rel="noopener ugc nofollow" target="_blank">部署新闻</a>库。以下是新服务的描述文件:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="29f8" class="md me it ly b gy mf mg l mh mi">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: readnewsblock-deployment<br/>  labels:<br/>    app: readnewsblock<br/>spec:<br/>  selector:<br/>    matchLabels:<br/>      app: readnewsblock<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: readnewsblock<br/>    spec:<br/>      containers:<br/>      - name: readnewsblock<br/>        image: docker.io/rlkamradt/readnewsblock:latest<br/>        ports:<br/>        - containerPort: 8080<br/>        env:<br/>          - name: MONGO_USER<br/>            valueFrom:<br/>              secretKeyRef:<br/>                name: mongo-secret<br/>                key: username<br/>          - name: MONGO_PASS<br/>            valueFrom:<br/>              secretKeyRef:<br/>                name: mongo-secret<br/>                key: password<br/>          - name: MONGO_HOST<br/>            value: mongodb-0.mongodb           <br/>        livenessProbe:<br/>          httpGet:<br/>            path: /actuator/health<br/>            port: 8080<br/>          timeoutSeconds: 10<br/>          initialDelaySeconds: 20<br/>          periodSeconds: 10<br/>---<br/>apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: readnewsblock-service<br/>spec:<br/>  type: ClusterIP<br/>  selector:<br/>    app: readnewsblock<br/>  ports:<br/>  - port: 8080<br/>    targetPort: 8080</span></pre><p id="e06a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这创建了一个<code class="fe lv lw lx ly b">readnewsblock</code>微服务的部署，以及一个为其提供内部IP和端口的服务。我在这个服务和原始服务中添加了一个东西，那就是<code class="fe lv lw lx ly b">livenessProbe</code>；这很容易添加，因为只要添加执行器依赖，Spring Boot应用程序就会有健康端点。超时默认为1秒，但是我们的服务非常紧张，所以我们必须将超时设置为10秒，以允许偶尔的垃圾收集暂停。</p><p id="9d2a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我们需要为新服务添加一个入口点。我要用一个新的虚拟主机叫做<code class="fe lv lw lx ly b">readnewsblock.local</code>。这是新的入口描述:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="44e0" class="md me it ly b gy mf mg l mh mi">apiVersion: networking.k8s.io/v1beta1<br/>kind: Ingress<br/>metadata:<br/>  name: readnews-ingress<br/>  annotations:<br/>    cert-manager.io/issuer: ca-issuer <br/>spec:<br/>  rules:<br/>  - host: readnews.local<br/>    http:<br/>      paths:<br/>      - backend:<br/>          serviceName: readnews-service<br/>          servicePort: 8080<br/>        path: /<br/>  - host: readnewsblock.local<br/>    http:<br/>      paths:<br/>      - backend:<br/>          serviceName: readnewsblock-service<br/>          servicePort: 8080<br/>        path: /<br/>  tls:<br/>  - hosts:<br/>    - readnewsblock.local<br/>    secretName: readnewsblock-cert<br/>  - hosts:<br/>    - readnews.local<br/>    secretName: readnews-cert</span></pre><p id="122c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在我们可以应用新的<code class="fe lv lw lx ly b">readnewsblock.yaml</code>描述和更新的<code class="fe lv lw lx ly b">vhost-ingress.yaml</code>描述:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="4b92" class="md me it ly b gy mf mg l mh mi">kubectl apply -f readnewsblock.yaml<br/>kubectl apply -f vhost-ingress.yaml</span></pre><p id="92f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我还将向入口部署添加一些副本。添加副本相对容易，只需一个命令:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="07bf" class="md me it ly b gy mf mg l mh mi">kubectl scale deployment ingress-nginx-controller --replicas=6 \<br/>    -n ingress-nginx</span></pre><p id="53bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这种情况下，我的入口控制器被称为<code class="fe lv lw lx ly b">ingress-nginx-controller</code>，它位于名称空间<code class="fe lv lw lx ly b">ingress-nginx</code>中。注意，这种扩展是暂时的，下次部署入口控制器时，它将回到描述中的状态。</p><h2 id="d8ba" class="md me it bd mj mk ml dn mm mn mo dp mp li mq mr ms lm mt mu mv lq mw mx my mz bi translated">用加特林进行性能测试。</h2><p id="1396" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">我将使用<a class="ae ky" href="https://gatling.io/" rel="noopener ugc nofollow" target="_blank">加特林3.3.0 </a>并从他们的示例性能测试中复制到一个新的<code class="fe lv lw lx ly b"><a class="ae ky" href="https://github.com/rkamradt/readnewsperf/tree/v1.0" rel="noopener ugc nofollow" target="_blank">readnewsperf</a></code>存储库中。Gatling测试是用Scala编写的，但是DSL的特性使得它相对容易。此外，我们不会做任何火箭科学，我把它留给我的日常工作。确保安装了<code class="fe lv lw lx ly b">sbt</code>和<code class="fe lv lw lx ly b">scala</code>；Mac用户可以用<code class="fe lv lw lx ly b">brew</code>，PC用户可以借朋友的Mac。</p><p id="e47b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于我的新加特林项目，我复制了<a class="ae ky" href="https://github.com/gatling/gatling-sbt-plugin-demo" rel="noopener ugc nofollow" target="_blank">加特林SBT插件演示</a>并修改了测试以达到我的终点。下面是基本的测试场景:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="eefc" class="md me it ly b gy mf mg l mh mi">class ReadNewsSimulation extends Simulation {<br/>  val httpConfBlocking = http<br/>    .baseUrl("<a class="ae ky" href="https://readnewsblock.local" rel="noopener ugc nofollow" target="_blank">https://readnewsblock.local</a>")<br/>    .acceptHeader("application/json")</span><span id="841f" class="md me it ly b gy nf mg l mh mi">  val httpConfNonBlocking = http<br/>    .baseUrl("<a class="ae ky" href="https://readnews.local" rel="noopener ugc nofollow" target="_blank">https://readnews.local</a>")<br/>    .acceptHeader("text/event-stream")</span><span id="3629" class="md me it ly b gy nf mg l mh mi">  def generateReadScenario(scenarioName: String,<br/>                           requestName: String,<br/>                           limit: Int):ScenarioBuilder = {<br/>    scenario(scenarioName)<br/>      .exec(http(requestName)<br/>        .get(s"/v1/headlines?limit=${limit}&amp;to=2021-01-01T00:00:00Z"))<br/>  }<br/>  val testTime = 60<br/>  val users = 20</span><span id="0776" class="md me it ly b gy nf mg l mh mi">  setUp(<br/>     generateReadScenario(<br/>       "BigNonBlocking",<br/>       "big-non-blocking",<br/>       1000).inject(<br/>       constantConcurrentUsers(users)<br/>           .during(testTime)).protocols(httpConfNonBlocking),<br/>     generateReadScenario(<br/>       "MedNonBlocking",<br/>       "med-non-blocking",<br/>       100).inject(<br/>       constantConcurrentUsers(users)<br/>           .during(testTime)).protocols(httpConfNonBlocking),<br/>     generateReadScenario(<br/>       "SmallNonBlocking",<br/>       "small-non-blocking",<br/>       1).inject(<br/>       constantConcurrentUsers(users)<br/>           .during(testTime)).protocols(httpConfNonBlocking),<br/>     generateReadScenario(<br/>       "BigBlocking",<br/>       "big-blocking",<br/>       1000).inject(<br/>       constantConcurrentUsers(users)<br/>           .during(testTime)).protocols(httpConfBlocking),<br/>     generateReadScenario(<br/>       "MedBlocking",<br/>       "med-blocking",<br/>       100).inject(<br/>       constantConcurrentUsers(users)<br/>           .during(testTime)).protocols(httpConfBlocking),<br/>     generateReadScenario(<br/>       "SmallBlocking",<br/>       "small-blocking",<br/>       1).inject(<br/>       constantConcurrentUsers(users)<br/>           .during(testTime)).protocols(httpConfBlocking)<br/>   )<br/>}</span></pre><p id="9878" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这首先创建了六个场景。对于阻塞和非阻塞，我分别针对1条记录、100条记录和1000条记录使用了read服务。我将运行测试60秒，我将有20个并发用户。因为时间和用户数量是固定的，所以我们可以得到平均响应时间和服务能够响应的请求数量。有许多不同类型的时间/用户变化，我将让您来尝试它们。</p><p id="72d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我把它分成1、100和1000条记录，因为我想看看传统的Java对于必须在内存中创建列表会有什么反应。我的猜测是，1条记录请求在阻塞和非阻塞之间的性能是一样的，1000条记录将是最大的差异。</p><p id="cf7d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果您对反应式Java的风格不感兴趣，但希望获得理论上的性能提升，那么1条记录和1000条记录处理之间的区别就很重要。如果您需要流过大量记录，而不需要一次或多次将它们都放在内存中，那么您只需要尝试reactive Java。例如，如果您必须对记录进行排序，那么reactive可能不会为您带来任何性能提升，因为无论如何您都需要将它们一次全部存储到内存中。</p><p id="8325" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但这都是理论上的，这篇文章的重点是看它在现实生活中是否发挥作用。</p><h2 id="3929" class="md me it bd mj mk ml dn mm mn mo dp mp li mq mr ms lm mt mu mv lq mw mx my mz bi translated">把这些放在一起。</h2><p id="b2b4" class="pw-post-body-paragraph kz la it lb b lc na ju le lf nb jx lh li nc lk ll lm nd lo lp lq ne ls lt lu im bi translated">有了在Kubernetes中运行的<code class="fe lv lw lx ly b">readnews</code>和<code class="fe lv lw lx ly b">readnewsblock</code>服务，以及分别将<a class="ae ky" href="https://readnews.local" rel="noopener ugc nofollow" target="_blank"> https://readnews.local </a>和<a class="ae ky" href="https://readnewsblock.local" rel="noopener ugc nofollow" target="_blank">https://read news block . local</a>指向每个服务的入口服务，我们就可以运行测试了。请注意，我将在这个测试中使用的数据库是在我的文章<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/how-to-use-kubernetes-cron-jobs-to-periodically-read-the-news-8b3b4513f8b7">如何使用Kubernetes Cron Jobs定期读取新闻</a>中创建的，这个cronjob已经运行了几个星期，填满了我的数据库。如果你想复制我的结果，你必须等待。但是现在，你可以在我的<a class="ae ky" href="https://github.com/rkamradt/readnewsperf/tree/v1.0" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>中找到测试。一旦你克隆了它们，你可以运行<code class="fe lv lw lx ly b">sbt</code>来打开<code class="fe lv lw lx ly b">sbt</code>外壳，然后运行<code class="fe lv lw lx ly b">gatling:test</code>来运行测试。您应该会看到类似这样的内容:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="036b" class="md me it ly b gy mf mg l mh mi">Simulation net.kamradtfamily.readnewsperf.ReadNewsSimulation completed in 67 seconds<br/>Parsing log file(s)...<br/>Parsing log file(s) done<br/>Generating reports...</span><span id="d3c3" class="md me it ly b gy nf mg l mh mi">================================================================================<br/>---- Global Information --------------------------------------------------------<br/>&gt; request count                                       1751 (OK=1751   KO=0     )<br/>&gt; min response time                                     92 (OK=92     KO=-     )<br/>&gt; max response time                                  35355 (OK=35355  KO=-     )<br/>&gt; mean response time                                  4353 (OK=4353   KO=-     )<br/>&gt; std deviation                                       5551 (OK=5551   KO=-     )<br/>&gt; response time 50th percentile                       2350 (OK=2350   KO=-     )<br/>&gt; response time 75th percentile                       5797 (OK=5797   KO=-     )<br/>&gt; response time 95th percentile                      15798 (OK=15798  KO=-     )<br/>&gt; response time 99th percentile                      25809 (OK=25809  KO=-     )<br/>&gt; mean requests/sec                                  25.75 (OK=25.75  KO=-     )<br/>---- Response Time Distribution ------------------------------------------------<br/>&gt; t &lt; 800 ms                                           644 ( 37%)<br/>&gt; 800 ms &lt; t &lt; 1200 ms                                  60 (  3%)<br/>&gt; t &gt; 1200 ms                                         1047 ( 60%)<br/>&gt; failed                                                 0 (  0%)<br/>================================================================================</span><span id="44e9" class="md me it ly b gy nf mg l mh mi">Reports generated in 0s.<br/>Please open the following file: /Users/randalkamradt/github/readnewsperf/target/gatling/readnewssimulation-20200515200505568/index.html<br/>[info] Simulation ReadNewsSimulation successful.<br/>[info] Simulation(s) execution ended.<br/>[success] Total time: 71 s (01:11), completed May 15, 2020, 1:06:14 PM<br/>sbt:readnewsperf&gt;</span></pre><p id="bd45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要查看输出文件，请在浏览器中为日志末尾引用的文件加上file:///前缀。这应该会将您带到这个屏幕:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/2f9fd42ac6458a7d77962f4ca06601f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uxuKjqoG2uv-6a9qsV7s1A.png"/></div></div></figure><p id="6c8a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这不是很有趣，它只是告诉你，平均来说，你所有的请求都花了一秒多的时间来完成。向下滚动到下一个面板，查看更多有趣的结果</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/851940c937eeab7111dfdfb545124c33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*trq_yxharXPVN9fRMW-67g.png"/></div></div></figure><p id="6f75" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这向您展示了能够通过的请求数量，以及我们场景中六个元素的响应时间。我按平均反应时间排序。正如我所猜测的，大请求比小请求花费的时间长，阻塞比非阻塞花费的时间长。</p><p id="531b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这绝不是证明非阻塞比阻塞更具执行性的积极证据。你可以运行几次，看看有什么变化。我运行了几次，得到了不同但相似的结果。您还可以尝试调整测试，看看每个测试在不同环境下的表现。</p><p id="1210" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们尝试另一件事，我们将扩大Kubernetes中的豆荚，看看它们的表现如何。运行以下命令:</p><pre class="kj kk kl km gt lz ly ma mb aw mc bi"><span id="8900" class="md me it ly b gy mf mg l mh mi">kubectl scale deployments readnews-deployment --replicas=2<br/>kubectl scale deployments readnewsblock-deployment --replicas=2</span></pre><p id="bb9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">再次运行测试，看看你得到了什么。这是我得到的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/126df49d3aed7fc56237fcefdec68ce2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Uj2ghj7F054mZuGD0Uk7Kg.png"/></div></div></figure><p id="bb5a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">事情有点复杂，med-blocking测试表现最好。在确保我已经正确地进行了缩放之后，我又运行了几次这个测试，并且得到了不同的结果。显然，阻塞比非阻塞对更多的豆荚反应更好。这可能是因为我们没有扩展MongoDB，这对测试有更大的影响。</p><p id="3e72" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是让我们把豆荚扩大到三个复制品。以下是我用三种方法得到的结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/48d8124b8a35dfad1c000125203d2a48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OhDJ3RVKyVMm6S_QfxvOew.png"/></div></div></figure><p id="468e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们回到了性能更高的非阻塞测试，但是中型测试比小型测试运行得更好。真不敢相信这里是另一个运行:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/40298eb7d048eab441622f52065a3009.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rQKyRl-ESrzJXBxIVFELJw.png"/></div></div></figure><p id="5b9a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一次大无堵做得最好！</p><p id="ba18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">同样，由于这个程序的构造方式，所有的变化都必须贯穿整个数据集，只有返回的数据是不同的。有了额外的副本，返回数据的大小不会对整体性能产生太大影响，读取MongoDB是瓶颈。也许在我的下一篇文章中，我会尝试向外扩展MongoDB。</p><p id="5c91" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一件要考虑的事情是，反应式Java只使用几个线程，而不是传统的每个请求使用一个线程。我们可以测试这一点的方法是用<code class="fe lv lw lx ly b">atOnceUsers</code>替换测试中的<code class="fe lv lw lx ly b">constantConcurrentUsers</code>调用，这将一次命中系统，并查看处理每个请求需要多长时间。我尝试了一下，发现reactive Java能够在大约相同的时间内处理请求，并且能够更快地产生响应。在我的测试的六个实例中，每个实例都使用了50个用户，总共300个用户，所有用户都同时请求。以下是med-blocking测试的结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/8c19383e83d14a5adb120df24aa567c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ay8AklUj6MIZJQCf8YcsyQ.png"/></div></div></figure><p id="6620" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">对于med-非阻断试验:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/d43ce5bd7416631b6c20d301eab07a47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6q9KSaTDztjUjOVhA97n8g.png"/></div></div></figure><p id="708c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">其他规模的测试进行得也差不多。为了找到这些屏幕，您必须选择details选项卡，然后您可以单独选择每个测试来查看每个测试的详细统计信息。</p><p id="a8da" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">目前，我很高兴反应式Java在大多数情况下肯定不比传统Java差，而且在许多情况下可能更好。因为我喜欢它提供的流畅的API，这足以让我在所有的Java编程冒险中坚持使用它。我不得不做更多的测试来证明反应式Java确实更有性能，我也想找到它没有性能的情况，这样我就可以做出更明智的决定。</p><p id="1265" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你真的能够跟随并让这个装置在家里工作，继续玩它，尝试优化事情。玩是最好的学习方式，这是一个很好的、简单的沙盒，可以在里面进行尝试。以下是所有代码和脚本的链接:</p><p id="dd2d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">【https://github.com/rkamradt/readnewsperf/tree/v1.0 T2】号</p><p id="68d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">【https://github.com/rkamradt/news-deploy/tree/v1.1 T4】</p><p id="3bed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://github.com/rkamradt/readnewsblock/tree/v1.0" rel="noopener ugc nofollow" target="_blank">https://github.com/rkamradt/readnewsblock/tree/v1.0</a></p><p id="fc3c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://github.com/rkamradt/readnews/tree/v1.1" rel="noopener ugc nofollow" target="_blank">https://github.com/rkamradt/readnews/tree/v1.1</a></p></div></div>    
</body>
</html>