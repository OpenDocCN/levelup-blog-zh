<html>
<head>
<title>Introduction to Vue.js Computed Properties and Watchers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Vue.js计算属性和观察器简介</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/introduction-to-vue-js-computed-properties-and-watchers-2707e4b0413d?source=collection_archive---------17-----------------------#2020-02-25">https://levelup.gitconnected.com/introduction-to-vue-js-computed-properties-and-watchers-2707e4b0413d?source=collection_archive---------17-----------------------#2020-02-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/4b4e1b26209ecdb0c27e3dde3d984bd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OtrIQGpCO0-RtJcK"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">保罗·吉尔摩在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="2c4e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Vue.js是一个易于使用的web应用框架，我们可以用它来开发交互式前端应用。</p><p id="3f1b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将研究Vue.js计算属性和观察器。</p><h1 id="67da" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">计算属性</h1><p id="c6f8" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">为了使更多的模板表达式更加简洁和可重用，我们可以创建计算属性，以便在现有属性的值发生变化时计算它们的结果。</p><p id="c112" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以在Vue实例中定义计算出的属性，方法是将它们放入options对象的<code class="fe mh mi mj mk b">computed</code>属性中，然后传递给<code class="fe mh mi mj mk b">Vue</code>构造函数。</p><p id="b5de" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以在<code class="fe mh mi mj mk b">src/index.js</code>中写下如下内容:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="e6f3" class="mt lf it mk b gy mu mv l mw mx">new Vue({<br/>  el: "#app",<br/>  data: {<br/>    message: "foo"<br/>  },<br/>  computed: {<br/>    spelledMessage() {<br/>      return this.message.split("").join("-");<br/>    }<br/>  }<br/>});</span></pre><p id="2c1d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们可以像使用HTML模板中的任何其他字段一样使用它。所以在<code class="fe mh mi mj mk b">index.html</code>中，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="3fd5" class="mt lf it mk b gy mu mv l mw mx">&lt;!DOCTYPE html&gt;<br/>&lt;html&gt;<br/>  &lt;head&gt;<br/>    &lt;title&gt;Hello&lt;/title&gt;<br/>    &lt;meta charset="UTF-8" /&gt;<br/>    &lt;script src="<a class="ae kf" href="https://cdn.jsdelivr.net/npm/vue/dist/vue.js" rel="noopener ugc nofollow" target="_blank">https://cdn.jsdelivr.net/npm/vue/dist/vue.js</a>"&gt;&lt;/script&gt;<br/>  &lt;/head&gt;</span><span id="6755" class="mt lf it mk b gy my mv l mw mx">  &lt;body&gt;<br/>    &lt;div id="app"&gt;<br/>      &lt;p&gt;{{message}}&lt;/p&gt;<br/>      &lt;p&gt;{{spelledMessage}}&lt;/p&gt;<br/>    &lt;/div&gt;<br/>    &lt;script src="./src/index.js"&gt;&lt;/script&gt;<br/>  &lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="54c9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们应该得到:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="0507" class="mt lf it mk b gy mu mv l mw mx">foo</span><span id="0805" class="mt lf it mk b gy my mv l mw mx">f-o-o</span></pre><p id="8ef7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们的屏幕上。</p><p id="a939" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">spelledMessage</code>方法是Vue.js使用的一个getter。它获取它的返回值，然后把它放在<code class="fe mh mi mj mk b">{{spelledMessage}}</code>的位置。</p><p id="7ade" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，模板中占位符的名称必须与返回我们在<code class="fe mh mi mj mk b">computed</code>对象中想要的值的方法名称相同。</p><p id="b8b9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还可以从返回的Vue实例中获取值，如下所示:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="f2bf" class="mt lf it mk b gy mu mv l mw mx">const vm = new Vue({<br/>  el: "#app",<br/>  data: {<br/>    message: "foo"<br/>  },<br/>  computed: {<br/>    spelledMessage() {<br/>      return this.message.split("").join("-");<br/>    }<br/>  }<br/>});</span><span id="e892" class="mt lf it mk b gy my mv l mw mx">console.log(vm.spelledMessage);</span></pre><p id="7f1d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们应该看到从<code class="fe mh mi mj mk b">console.log</code>记录的<code class="fe mh mi mj mk b">f-o-o</code>。</p><p id="1b69" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以像绑定任何其他属性一样绑定到模板中的计算属性。Vue知道<code class="fe mh mi mj mk b">vm.spelledMessage</code>依赖于<code class="fe mh mi mj mk b">vm.message</code>，所以<code class="fe mh mi mj mk b">vm.message</code>更新时绑定也会更新。</p><p id="730b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">computed getter方法不会产生副作用，这使得它易于测试和理解。</p><h1 id="2a0b" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">计算缓存与方法</h1><p id="87a6" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">计算属性的一个很好的特性是它的结果被缓存。</p><p id="8fb2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从方法返回的结果没有缓存。</p><p id="3ea6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，在我们从现有属性中计算某些东西的情况下，我们应该使用计算属性，而不是使用方法。</p><p id="62df" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">只有在反应属性更新后，才会重新计算计算属性。</p><p id="2afd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="2d36" class="mt lf it mk b gy mu mv l mw mx">const vm = new Vue({<br/>  el: "#app",<br/>  data: {<br/>    message: "foo"<br/>  },<br/>  computed: {<br/>    now() {<br/>      return Date.now();<br/>    }<br/>  }<br/>});</span></pre><p id="47e0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在第一次计算后，它将永远不会更新，因为它不依赖于来自<code class="fe mh mi mj mk b">data</code>属性的任何反应属性。</p><p id="9fab" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果不缓存计算的属性，则计算的属性会一直作为它们所依赖的反应性属性进行更改，这意味着应用程序会随着计算的属性所依赖的反应性属性的更改而变慢。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/e9e975650a0d713961f0303d535eb76b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0ChK7BYiRNU_17Wf"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">约翰·托尔卡西奥在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="1b3c" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">计算属性与监视属性</h1><p id="67a0" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">顾名思义，监视属性对于监视属性的变化非常有用。</p><p id="560b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，由于计算属性的缓存特性，我们应该尽可能多地使用它们。</p><p id="05c0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以简化以下内容:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="6061" class="mt lf it mk b gy mu mv l mw mx">new Vue({<br/>  el: "#app",<br/>  data: {<br/>    name: "Joe",<br/>    age: 1,<br/>    person: undefined<br/>  },<br/>  watch: {<br/>    name: {<br/>      immediate: true,<br/>      handler(newVal) {<br/>        this.person = `${newVal} - ${this.age}`;<br/>      }<br/>    },<br/>    age: {<br/>      immediate: true,<br/>      handler(newVal) {<br/>        this.person = `${this.name} - ${newVal}`;<br/>      }<br/>    }<br/>  }<br/>});</span></pre><p id="7827" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">收件人:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="036a" class="mt lf it mk b gy mu mv l mw mx">new Vue({<br/>  el: "#app",<br/>  data: {<br/>    name: "Joe",<br/>    age: 1<br/>  },<br/>  computed: {<br/>    person() {<br/>      return `${this.name} - ${this.age}`;<br/>    }<br/>  }<br/>});</span></pre><p id="a5f3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我们所看到的，第一个例子要复杂得多。我们必须在每个属性中设置<code class="fe mh mi mj mk b">immediate</code>到<code class="fe mh mi mj mk b">true</code>,这样它就可以观察初始值的变化。然后，我们必须为每个反应属性定义值更改处理程序。</p><p id="2527" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后在每个处理程序中，我们必须设置<code class="fe mh mi mj mk b">person</code>属性，这样我们就可以组合<code class="fe mh mi mj mk b">name</code>和<code class="fe mh mi mj mk b">age</code>。</p><p id="1fb9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一方面，对于计算属性，我们只有一个方法返回以我们想要的方式组合的字段。</p><p id="d53e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这对于我们来说更方便，而且由于缓存，我们创建的应用程序也更快。</p><h1 id="e2ae" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">计算设定值</h1><p id="4996" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们还可以为计算属性创建一个setter函数。</p><p id="e96d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="3bc5" class="mt lf it mk b gy mu mv l mw mx">new Vue({<br/>  el: "#app",<br/>  data: {<br/>    name: "Joe",<br/>    age: 1<br/>  },<br/>  computed: {<br/>    person: {<br/>      get() {<br/>        return `${this.name} - ${this.age}`;<br/>      },<br/>      set(newValue) {<br/>        const [name, age] = newValue.split("-");<br/>        this.name = name.trim();<br/>        this.age = age.trim();<br/>      }<br/>    }<br/>  }<br/>});</span></pre><p id="db6f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">getter函数返回和以前一样的东西，但是现在我们还有一个setter函数。</p><p id="b8ef" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">setter函数分割<code class="fe mh mi mj mk b">newValue</code>，它具有getter函数计算的值，我们分割结果并将结果设置回相应的reactive属性。</p><p id="dc0d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以如下使用setter。我们可以将以下内容放入<code class="fe mh mi mj mk b">src/index.js</code>:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="410b" class="mt lf it mk b gy mu mv l mw mx">new Vue({<br/>  el: "#app",<br/>  data: {<br/>    firstName: "Joe",<br/>    lastName: "Smith"<br/>  },<br/>  computed: {<br/>    name: {<br/>      get() {<br/>        return `${this.firstName} ${this.lastName}`;<br/>      },<br/>      set(newValue) {<br/>        const [firstName, lastName] = newValue.split(" ");<br/>        this.firstName = (firstName || "").trim();<br/>        this.lastName = (lastName || "").trim();<br/>      }<br/>    }<br/>  }<br/>});</span></pre><p id="d148" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<code class="fe mh mi mj mk b">index.html</code>中，我们放入:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="7618" class="mt lf it mk b gy mu mv l mw mx">&lt;!DOCTYPE html&gt;<br/>&lt;html&gt;<br/>  &lt;head&gt;<br/>    &lt;title&gt;Hello&lt;/title&gt;<br/>    &lt;meta charset="UTF-8" /&gt;<br/>    &lt;script src="<a class="ae kf" href="https://cdn.jsdelivr.net/npm/vue/dist/vue.js" rel="noopener ugc nofollow" target="_blank">https://cdn.jsdelivr.net/npm/vue/dist/vue.js</a>"&gt;&lt;/script&gt;<br/>  &lt;/head&gt;</span><span id="7b74" class="mt lf it mk b gy my mv l mw mx">  &lt;body&gt;<br/>    &lt;div id="app"&gt;<br/>      &lt;p&gt;{{name}}&lt;/p&gt;<br/>      &lt;input type="text" v-model="name" /&gt;<br/>    &lt;/div&gt;<br/>    &lt;script src="./src/index.js"&gt;&lt;/script&gt;<br/>  &lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="f446" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，当我们改变输入中的值时，我们用setter把新值赋回给<code class="fe mh mi mj mk b">firstName</code>和<code class="fe mh mi mj mk b">lastName</code>字段。</p><h1 id="a90a" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="1d8d" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以使用计算属性来计算现有属性的值。</p><p id="5dda" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">缓存计算属性的返回值，以减少所需的计算量。</p><p id="694c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">计算属性也可以有setter，在这里我们可以用计算属性getter返回的新值做一些事情。</p></div></div>    
</body>
</html>