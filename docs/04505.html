<html>
<head>
<title>Linked List Tutorial for New Gophers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">新地鼠的链表教程</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/a-singly-linked-list-tutorial-for-new-go-programmers-921445c270e3?source=collection_archive---------31-----------------------#2020-06-29">https://levelup.gitconnected.com/a-singly-linked-list-tutorial-for-new-go-programmers-921445c270e3?source=collection_archive---------31-----------------------#2020-06-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="1cdd" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">本文讨论了线性链表的概念及其在Go中的实现。</h2></div><h1 id="bc70" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">什么是单链表</h1><p id="1e4e" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">单链表是一种线性的、动态的数据结构，其中每个元素都是一个独立的对象。它们一起代表一个序列。节点的基本形式是数据和指向下一个节点的指针。</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi lw"><img src="../Images/515ec39e3758cc4c7a988773b72a713b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wc-5pewXJrN4IxOEzhnvbg.png"/></div></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk translated">图一。单向链表</figcaption></figure><p id="9c89" class="pw-post-body-paragraph la lb it lc b ld mm ju lf lg mn jx li lj mo ll lm ln mp lp lq lr mq lt lu lv im bi translated">第一个节点叫做<em class="mr">头</em>，最后一个节点叫做<em class="mr">尾</em>。<em class="mr"> Head </em>给出了对整个链表的访问，<em class="mr"> tail </em>给出了对最后一个节点的访问。最后一个节点的下一个字段是<em class="mr"> nil </em>，表示链表的结束。</p><p id="72f2" class="pw-post-body-paragraph la lb it lc b ld mm ju lf lg mn jx li lj mo ll lm ln mp lp lq lr mq lt lu lv im bi translated"><strong class="lc iu">优点:</strong></p><ul class=""><li id="65b9" class="ms mt it lc b ld mm lg mn lj mu ln mv lr mw lv mx my mz na bi translated">链表的大小是动态的，这意味着它们可以根据需要增长和收缩。</li><li id="b4a0" class="ms mt it lc b ld nb lg nc lj nd ln ne lr nf lv mx my mz na bi translated">链表具有高效的内存利用率。您不需要在声明期间指定元素的数量。当您需要插入一个节点时分配内存，当删除一个节点时释放内存。</li></ul><p id="bdb3" class="pw-post-body-paragraph la lb it lc b ld mm ju lf lg mn jx li lj mo ll lm ln mp lp lq lr mq lt lu lv im bi translated"><strong class="lc iu">缺点:</strong></p><ul class=""><li id="d1a3" class="ms mt it lc b ld mm lg mn lj mu ln mv lr mw lv mx my mz na bi translated">因为有一个指针存储地址，所以链表会占用更多的空间。</li><li id="747c" class="ms mt it lc b ld nb lg nc lj nd ln ne lr nf lv mx my mz na bi translated">由于遍历，搜索节点可能很耗时。我们不能随机访问一个索引为N的节点，相反，我们迭代链表来找到这个节点。</li></ul><h1 id="8d61" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">链表类型</h1><p id="1c50" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">在编写代码之前，我们需要声明两种数据类型:</p><ul class=""><li id="746e" class="ms mt it lc b ld mm lg mn lj mu ln mv lr mw lv mx my mz na bi translated">一个<em class="mr">列表</em>类型将封装所有与指针相关的复杂性。<em class="mr">列表</em>类型由指向第一个节点的头和指向最后一个节点的尾组成。</li></ul><figure class="lx ly lz ma gt mb"><div class="bz fp l di"><div class="ng nh l"/></div></figure><ul class=""><li id="0f15" class="ms mt it lc b ld mm lg mn lj mu ln mv lr mw lv mx my mz na bi translated">一个<em class="mr">节点</em>类型是一个具有<em class="mr">数据</em>字段和对同一类型节点的引用的结构。数据有一个类型接口{}，所以我们可以在链表中插入任何类型的值。下一个字段是指向下一个节点的指针。由于一个节点包含一个指向同类型节点的指针，所以这个节点叫做<em class="mr">自引用</em>。</li></ul><figure class="lx ly lz ma gt mb"><div class="bz fp l di"><div class="ng nh l"/></div></figure><h1 id="704b" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">链表方法</h1><p id="3721" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">本节讨论链表(或<em class="mr"> list </em>)方法的实现及其图例。</p><p id="83c2" class="pw-post-body-paragraph la lb it lc b ld mm ju lf lg mn jx li lj mo ll lm ln mp lp lq lr mq lt lu lv im bi translated">在这些代码示例中，我们使用了一个<em class="mr">标记</em>节点，它与<em class="mr">节点</em>类型具有相同的结构。<em class="mr">标记</em>是一个特定的节点，在我们插入一个新的节点之前/之后，或者我们需要删除，或者我们使用得到的前一个节点。</p><p id="c053" class="pw-post-body-paragraph la lb it lc b ld mm ju lf lg mn jx li lj mo ll lm ln mp lp lq lr mq lt lu lv im bi translated">我们不按数据字段比较节点，因为不清楚节点有什么类型的数据。例如字符串、整数、浮点等。所以，我们只比较节点。</p><h2 id="c0e2" class="ni kj it bd kk nj nk dn ko nl nm dp ks lj nn no ku ln np nq kw lr nr ns ky nt bi translated">列表。InsertLast(数值数据)*节点</h2><p id="7c16" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">此方法在列表末尾插入一个新节点，并返回插入的节点。</p><figure class="lx ly lz ma gt mb"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="eb8f" class="pw-post-body-paragraph la lb it lc b ld mm ju lf lg mn jx li lj mo ll lm ln mp lp lq lr mq lt lu lv im bi translated">在插入节点之前，我们需要考虑两种情况:</p><ul class=""><li id="0b1f" class="ms mt it lc b ld mm lg mn lj mu ln mv lr mw lv mx my mz na bi translated">列表是空的，</li><li id="abbd" class="ms mt it lc b ld nb lg nc lj nd ln ne lr nf lv mx my mz na bi translated">列表非空。</li></ul><p id="a03e" class="pw-post-body-paragraph la lb it lc b ld mm ju lf lg mn jx li lj mo ll lm ln mp lp lq lr mq lt lu lv im bi translated">在第一种情况下，我们使用<strong class="lc iu"> list.head == nil </strong>进行检查。我们在列表中插入一个新的节点作为头和尾(列表中只有一个节点)。</p><p id="5960" class="pw-post-body-paragraph la lb it lc b ld mm ju lf lg mn jx li lj mo ll lm ln mp lp lq lr mq lt lu lv im bi translated">第二种情况如图2所示。这里我们有一个由几个节点组成的列表:1→ 2→ <em class="mr"> nil </em>。新的节点是<strong class="lc iu">节点{数据:3，下一个:零} </strong>。因为我们可以访问尾部，所以不需要遍历列表。我们在<strong class="lc iu"> list.tail.next </strong>中插入新节点，并用新节点<strong class="lc iu"> list.tail = newNode </strong>替换旧节点。</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi nu"><img src="../Images/06e7b2d05a19f830defb545930f0eea3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9P66eZEk-NQzNzHGvczViw.png"/></div></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk translated">图2. InsertLast()方法</figcaption></figure><h2 id="63e8" class="ni kj it bd kk nj nk dn ko nl nm dp ks lj nn no ku ln np nq kw lr nr ns ky nt bi translated">列表。InsertFront(数值数据)*节点</h2><p id="1268" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">此方法在列表的开头插入一个新节点，并返回插入的节点。</p><figure class="lx ly lz ma gt mb"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="a54b" class="pw-post-body-paragraph la lb it lc b ld mm ju lf lg mn jx li lj mo ll lm ln mp lp lq lr mq lt lu lv im bi translated">这里，我们检查与InsertLast()方法中相同的情况。</p><p id="570b" class="pw-post-body-paragraph la lb it lc b ld mm ju lf lg mn jx li lj mo ll lm ln mp lp lq lr mq lt lu lv im bi translated">如果一个列表是空的，我们创建一个头和一个尾。我们将代码为<strong class="lc iu"> list.head = newNode </strong>和<strong class="lc iu"> list.tail = newNode </strong>的新节点分别分配给头部和尾部。</p><p id="d578" class="pw-post-body-paragraph la lb it lc b ld mm ju lf lg mn jx li lj mo ll lm ln mp lp lq lr mq lt lu lv im bi translated">在图片#3中，我们在非空列表中插入<strong class="lc iu">节点{data:3，next:nil} </strong>。为了将<em class="mr"> newNode </em>连接到列表中的第一个节点，我们使用<strong class="lc iu"> newNode.next = list.head </strong>，因为当前的头是<strong class="lc iu"> Node{data:1，next: next node} </strong>，然后用<strong class="lc iu"> list.head = newNode </strong>更改列表中的头。</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi nu"><img src="../Images/312e67cd2828dc9b9be954df357c17e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kb2t4XSPvPTzazIcAALVbA.png"/></div></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk translated">图3. InsertFront()方法</figcaption></figure><h2 id="bb88" class="ni kj it bd kk nj nk dn ko nl nm dp ks lj nn no ku ln np nq kw lr nr ns ky nt bi translated">列表。InsertBefore(数值数据，标记*节点)*节点</h2><p id="7810" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">该方法在列表中的<em class="mr">标记</em>之前插入一个新节点，并返回插入的节点。</p><figure class="lx ly lz ma gt mb"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="69d3" class="pw-post-body-paragraph la lb it lc b ld mm ju lf lg mn jx li lj mo ll lm ln mp lp lq lr mq lt lu lv im bi translated">第一步是检查那个<strong class="lc iu">标记！=零</strong>。如果<em class="mr">标志</em>为<em class="mr"> nil </em>，该方法停止执行，因为我们不能在链表中插入一个<em class="mr"> nil </em>节点。Nil节点既不包含数据也不包含到下一个节点的链接。</p><p id="1d36" class="pw-post-body-paragraph la lb it lc b ld mm ju lf lg mn jx li lj mo ll lm ln mp lp lq lr mq lt lu lv im bi translated">然后我们检查头部是否等于<em class="mr">标记</em>。如果相等，我们将当前头分配给<em class="mr">新节点</em>并返回<em class="mr">新节点</em>。如果不相等，我们遍历列表找到<strong class="lc iu">节点。</strong></p><p id="b0da" class="pw-post-body-paragraph la lb it lc b ld mm ju lf lg mn jx li lj mo ll lm ln mp lp lq lr mq lt lu lv im bi translated">在下图中，我们展示了如何在一个完整的列表中找到<em class="mr">标记</em>，这个列表有一个头、一个中间节点和一个尾。这里我们有一个列表3→ 1→ 2→ <em class="mr">零</em>。我们需要在<em class="mr">标记</em>之前插入<strong class="lc iu">节点{data:4，next: mark} </strong>。<em class="mr">标记</em>为<strong class="lc iu">节点{data:1，next: next node} </strong>。从头开始，我们迭代列表并检查条件<strong class="lc iu"> node.next == mark </strong>。如果为真，我们用下面的语句<strong class="lc iu"> node.next = newNode </strong>将<em class="mr"> newNode </em>赋值给<strong class="lc iu"> node.next </strong>。因此，新节点现在位于<em class="mr">标记</em>之前。</p><p id="1c43" class="pw-post-body-paragraph la lb it lc b ld mm ju lf lg mn jx li lj mo ll lm ln mp lp lq lr mq lt lu lv im bi translated">如果该方法返回<em class="mr"> nil </em>，则<em class="mr">标记</em>在列表中不存在。</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi nv"><img src="../Images/0fc721124c2ce5d3b4a1b425a24f8ef8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xfnrAlDIotuleSPjMZ9gBA.png"/></div></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk translated">图4. InsertBefore()方法</figcaption></figure><h2 id="d1d3" class="ni kj it bd kk nj nk dn ko nl nm dp ks lj nn no ku ln np nq kw lr nr ns ky nt bi translated">列表。InsertAfter(数值数据，标记*节点)*节点</h2><p id="6882" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">该方法在列表中的<em class="mr">标记</em>后插入一个新节点，并返回插入的节点。</p><figure class="lx ly lz ma gt mb"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="4d8b" class="pw-post-body-paragraph la lb it lc b ld mm ju lf lg mn jx li lj mo ll lm ln mp lp lq lr mq lt lu lv im bi translated">检查<em class="mr">标记</em>等于InsertBefore()方法。</p><p id="67ce" class="pw-post-body-paragraph la lb it lc b ld mm ju lf lg mn jx li lj mo ll lm ln mp lp lq lr mq lt lu lv im bi translated">如果<em class="mr">标记</em>不是<em class="mr">零</em>，我们迭代列表找到等于<em class="mr">标记</em>的节点。在图片5中，你可以看到该方法是如何工作的。最初，我们有一个包含几个节点3 → 1 → 2→ <em class="mr"> nil </em>的列表。如果我们需要在<em class="mr">标记</em>之后插入<em class="mr"> newNode </em>，我们将遍历列表并搜索<strong class="lc iu"> node == mark。</strong>如果找到，我们将<em class="mr">新节点</em>分配给<strong class="lc iu">节点。下一个</strong>。所以，现在<em class="mr"> newNode </em>跟着<em class="mr"> mark </em>走。</p><p id="337e" class="pw-post-body-paragraph la lb it lc b ld mm ju lf lg mn jx li lj mo ll lm ln mp lp lq lr mq lt lu lv im bi translated">如果没有找到<em class="mr">标记</em>，则<em class="mr">标记</em>在列表中不存在。</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi nw"><img src="../Images/9efa0edf1df740e9ddcd20f1f73288ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UbyI0F6m26Ve2eHaODVJZw.png"/></div></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk translated">图5. InsertAfter()方法</figcaption></figure><p id="b87e" class="pw-post-body-paragraph la lb it lc b ld mm ju lf lg mn jx li lj mo ll lm ln mp lp lq lr mq lt lu lv im bi translated">还有，<em class="mr">标记</em>可以等于尾部。在这种情况下，我们只要用下面的表达式<strong class="lc iu"> list.tail = newNode </strong>将<em class="mr"> newNode </em>赋给尾部即可。</p><p id="b397" class="pw-post-body-paragraph la lb it lc b ld mm ju lf lg mn jx li lj mo ll lm ln mp lp lq lr mq lt lu lv im bi translated">InsertBefore()和InsertAfter()方法都不检查<strong class="lc iu"> head == nil </strong>，因为假定列表必须为非空才能在现有节点之前或/和之后插入新节点。</p><h2 id="9bd3" class="ni kj it bd kk nj nk dn ko nl nm dp ks lj nn no ku ln np nq kw lr nr ns ky nt bi translated">节点。下一个()*节点</h2><p id="d005" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">此方法返回下一个节点。</p><figure class="lx ly lz ma gt mb"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="1796" class="pw-post-body-paragraph la lb it lc b ld mm ju lf lg mn jx li lj mo ll lm ln mp lp lq lr mq lt lu lv im bi translated">因为我们有一个到下一个节点的链接，我们可以用<strong class="lc iu"> return node.next </strong>代码返回这个节点。该方法的接收者是一个节点，而不是一个列表。</p><h2 id="74e4" class="ni kj it bd kk nj nk dn ko nl nm dp ks lj nn no ku ln np nq kw lr nr ns ky nt bi translated">列表。前一个(标记*节点)*节点</h2><p id="6a0d" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">该方法返回<em class="mr">标记</em>之前的节点。</p><figure class="lx ly lz ma gt mb"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="62f0" class="pw-post-body-paragraph la lb it lc b ld mm ju lf lg mn jx li lj mo ll lm ln mp lp lq lr mq lt lu lv im bi translated">在线性链表中，我们不能访问前一个节点。在这种情况下，我们遍历列表并将<strong class="lc iu"> node.next </strong>与<em class="mr">标记</em>进行比较。如果它们相等，我们返回当前节点。如果不相等，<em class="mr">标记</em>不存在。</p><h2 id="0ff9" class="ni kj it bd kk nj nk dn ko nl nm dp ks lj nn no ku ln np nq kw lr nr ns ky nt bi translated">列表。删除(标记*节点)错误</h2><p id="0041" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">该方法从列表中删除<em class="mr">标记</em>。</p><figure class="lx ly lz ma gt mb"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="6c5e" class="pw-post-body-paragraph la lb it lc b ld mm ju lf lg mn jx li lj mo ll lm ln mp lp lq lr mq lt lu lv im bi translated">在删除<em class="mr">标记</em>之前，有两种情况需要检查:</p><ul class=""><li id="9c20" class="ms mt it lc b ld mm lg mn lj mu ln mv lr mw lv mx my mz na bi translated">mark可以是head，</li><li id="ab99" class="ms mt it lc b ld nb lg nc lj nd ln ne lr nf lv mx my mz na bi translated">马克可以在头后。</li></ul><p id="6cbb" class="pw-post-body-paragraph la lb it lc b ld mm ju lf lg mn jx li lj mo ll lm ln mp lp lq lr mq lt lu lv im bi translated">使用以下表达式检查第一种情况:</p><figure class="lx ly lz ma gt mb"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="2bcc" class="pw-post-body-paragraph la lb it lc b ld mm ju lf lg mn jx li lj mo ll lm ln mp lp lq lr mq lt lu lv im bi translated">换句话说，如果第一个节点等于<em class="mr">标记</em>，我们将下一个节点(在第一个节点之后)分配给头部。并且如果在这种情况下<em class="mr">标记</em>也等于tail(当列表中有一个节点时会发生这种情况)，那么<strong class="lc iu"> list.tail == nil </strong>。</p><p id="533d" class="pw-post-body-paragraph la lb it lc b ld mm ju lf lg mn jx li lj mo ll lm ln mp lp lq lr mq lt lu lv im bi translated">第二种情况用下面的语句检查:</p><figure class="lx ly lz ma gt mb"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="b40f" class="pw-post-body-paragraph la lb it lc b ld mm ju lf lg mn jx li lj mo ll lm ln mp lp lq lr mq lt lu lv im bi translated">在图片#6中，你可以看到我们如何实现前面的<em class="mr"> if </em>条件。</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi nw"><img src="../Images/f9cd245491ec32864beb3bc166ad61f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mxb0rJQzheK8hWfbBUtK2A.png"/></div></div><figcaption class="mi mj gj gh gi mk ml bd b be z dk translated">图6. Delete()方法</figcaption></figure><p id="3a10" class="pw-post-body-paragraph la lb it lc b ld mm ju lf lg mn jx li lj mo ll lm ln mp lp lq lr mq lt lu lv im bi translated">我们有一个由几个节点3→ 1→ 4→ 2→ <em class="mr"> nil </em>组成的列表。<em class="mr">标记</em>为<strong class="lc iu">节点{data:4，next: next node} </strong>。在第二次迭代中，我们得到了<strong class="lc iu"> node.next == mark </strong>。然后，该迭代中的当前节点连接到<strong class="lc iu">标记。下一个</strong>。因此，<em class="mr">标记</em>从列表中删除。</p><p id="0dc5" class="pw-post-body-paragraph la lb it lc b ld mm ju lf lg mn jx li lj mo ll lm ln mp lp lq lr mq lt lu lv im bi translated">在这种情况下，我们检查最后一个节点是否也等于<em class="mr">标记</em>。如果<em class="mr">为真</em>，我们改变<strong class="lc iu"> list.tail = node </strong>。</p><p id="e7aa" class="pw-post-body-paragraph la lb it lc b ld mm ju lf lg mn jx li lj mo ll lm ln mp lp lq lr mq lt lu lv im bi translated">如果<em class="mr">标记</em>不存在，该方法返回错误。</p><h2 id="7801" class="ni kj it bd kk nj nk dn ko nl nm dp ks lj nn no ku ln np nq kw lr nr ns ky nt bi translated">列表。Size() int</h2><p id="f367" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">这个方法返回列表的大小。</p><figure class="lx ly lz ma gt mb"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="388f" class="pw-post-body-paragraph la lb it lc b ld mm ju lf lg mn jx li lj mo ll lm ln mp lp lq lr mq lt lu lv im bi translated">如果<strong class="lc iu"> head == nil </strong>，我们返回0。如果列表非空，我们遍历它并增加大小变量，直到列表结束。</p><h1 id="1f9b" class="ki kj it bd kk kl km kn ko kp kq kr ks jz kt ka ku kc kv kd kw kf kx kg ky kz bi translated">开源代码库</h1><p id="2ddc" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">带测试的源代码你可以在这里看到<a class="ae nx" href="https://github.com/kozhevnikova/go-data-structures" rel="noopener ugc nofollow" target="_blank"/>。</p></div></div>    
</body>
</html>