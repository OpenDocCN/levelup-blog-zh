<html>
<head>
<title>10 Things You Should Know Before Writing Your Next Vue.js Component</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在编写下一个Vue.js组件之前你应该知道的10件事</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/10-things-you-should-know-before-writing-your-next-vuejs-component-4f97964611f4?source=collection_archive---------1-----------------------#2019-06-15">https://levelup.gitconnected.com/10-things-you-should-know-before-writing-your-next-vuejs-component-4f97964611f4?source=collection_archive---------1-----------------------#2019-06-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8f9f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">构建更好的Vue组件指南</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f73c2ede0bcc1737b7f27684d10bbfab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wzA-iwC_Dj52T17PgA9SaA.png"/></div></div></figure><h1 id="ab0d" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">1.组件可以在全局或本地加载</h1><p id="df14" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">Vue.js提供了两种加载组件的方法——一种是在Vue实例上全局加载，另一种是在组件级加载。这两种方法都有各自的好处。</p><p id="0859" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">通过全局加载组件，可以从应用程序中的任何模板访问该组件，包括子组件。它限制了将全局组件导入子组件的次数。此外，如果你全局加载组件，你不会得到Vue寄存器组件错误<code class="fe mn mo mp mq b">“did you register the component correctly?”</code>。注意，尽量少加载全局组件。它会使您的应用程序膨胀，即使不使用它，它仍然会包含在您的Webpack构建中。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="d5b3" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">本地加载组件为您提供了隔离组件并仅在必要时加载它们的能力。当与Webpack结合使用时，您可以仅在组件被使用时延迟加载它们。这使您的初始应用程序文件变得非常小，并减少了初始加载时间。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div></figure><h1 id="ec9b" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">2.延迟加载/异步组件</h1><p id="17a6" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">使用Webpack的动态导入延迟加载组件。Vue支持渲染时组件的延迟加载和代码分割。这些优化允许组件代码只在需要的时候加载，减少了HTTP请求和文件大小，并自动提升了性能。这个特性的伟大之处在于，它既可以处理全局加载的组件，也可以处理本地加载的组件。</p><p id="deae" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">全局加载异步组件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="b0cb" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">本地加载异步组件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div></figure><blockquote class="mt mu mv"><p id="5df9" class="lm ln mw lo b lp mi ju lr ls mj jx lu mx mk lx ly my ml mb mc mz mm mf mg mh im bi translated"><a class="ae na" href="https://www.nccgroup.trust/uk/about-us/resources/cook-real-user-monitoring-case-study/?style=Website+Performance&amp;resources=Case+Studies" rel="noopener ugc nofollow" target="_blank">库克将平均页面加载时间减少了850毫秒，转换率提高了7%，跳出率降低了7%，每个会话的页面增加了10% </a></p></blockquote><div class="nb nc gp gr nd ne"><a href="https://developers.google.com/web/fundamentals/performance/why-performance-matters/" rel="noopener  ugc nofollow" target="_blank"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd iu gy z fp nj fr fs nk fu fw is bi translated">为什么性能很重要|网络基础| Google开发者</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">由于移动设备和网络的激增，使用网络的人比以往任何时候都多。作为这个用户群…</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">developers.google.com</p></div></div><div class="nn l"><div class="no l np nq nr nn ns ks ne"/></div></div></a></div><h1 id="8134" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">3.必需的道具</h1><p id="c134" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">有许多方法可以为组件创建道具；您可以传递一个表示属性名的字符串数组，也可以传递一个带有作为属性名的键的对象和一个配置对象。</p><p id="5aee" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">使用基于对象的方法，您可以为单个道具创建一些关键配置更改，其中一个是必需的关键。所需的键需要一个<code class="fe mn mo mp mq b">true</code>或<code class="fe mn mo mp mq b">false</code>值。如果使用组件时未设置属性，True将引发错误；如果未设置属性，false(默认值)将不要求或引发错误。在共享组件时，为其他开发人员以及您自己使用所需的道具是一个好的实践，以提醒您道具对于组件是至关重要的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div></figure><h1 id="7184" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">4.用<code class="fe mn mo mp mq b">$emit</code>触发自定义事件</h1><p id="46e6" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">子组件和父组件之间的通信可以通过使用组件内置函数<code class="fe mn mo mp mq b">$emit</code>发出自定义事件来完成。<code class="fe mn mo mp mq b">$emit</code>函数接受一个事件名称字符串和一个要发出的可选值。要监听事件，只需向发出事件的组件添加“<code class="fe mn mo mp mq b">@eventName</code>”，并传入您的事件处理程序。这是保持单一真实来源并让数据从子组件流向父组件的好方法。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div></figure><h1 id="5b9d" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">5.将组件分解成逻辑块</h1><p id="860d" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">说起来容易做起来难，但是如何定义一个逻辑片段来将一个组件分解成几个部分呢？分解组件的第一种方法是基于数据变化率。如果数据在组件的一个部分持续变化，而在其他部分没有变化，那么它可能是它自己的组件。</p><p id="e1b1" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">原因是如果你的数据/HTML在你的模板的一个部分持续变化，整个事情都需要检查和更新。但是，如果将相同的HTML放入它自己的组件中，并使用props传递数据，那么当它的props改变时，只更新那个组件。</p><p id="b74c" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">逻辑上分解组件的另一种方式是为了可重用性。如果你有HTML，图形，或者在你的应用程序中一直使用的功能，比如按钮，复选框，图标动画，行动号召或者有简单修改文本的图形——这将是一个很好的候选隔离到一个可以重用的新组件中。可重用组件有一个隐藏的好处，即更容易维护，因为您只需更改一个组件，而不必在代码库中寻找替换和更改多个区域。</p><h1 id="7638" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">6.验证你的道具</h1><p id="14b4" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">不要使用字符串数组来定义你的属性，而是使用对象符号来配置每个属性。两种非常有用的配置风格是“类型”和验证器。</p><p id="2efc" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">使用类型参数，Vue将自动类型检查您的属性值。例如，如果我们期待一个数字属性，但收到一个字符串，您将在控制台中得到类似于以下内容的警告:</p><pre class="kj kk kl km gt nt mq nu nv aw nw bi"><span id="1aa4" class="nx kv it mq b gy ny nz l oa ob">[Vue warn]: Invalid prop: type check failed for prop “count”. Expected Number</span></pre><p id="97d8" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">对于更复杂的验证，我们可以将一个函数传递给validator属性，该属性接受值作为参数并返回<code class="fe mn mo mp mq b">true</code>或<code class="fe mn mo mp mq b">false</code>。这非常强大，因为它允许我们针对传递给特定属性的值编写自定义验证。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div></figure><h1 id="fd32" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">7.多道具绑定和覆盖</h1><p id="eebe" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">如果你的组件有很多道具，比如说5个、6个、7个或者更多，那么不断地为每个道具设置绑定可能会变得很乏味。幸运的是，有一种快速的方法可以为组件的所有属性设置绑定，那就是使用<code class="fe mn mo mp mq b">v-bind</code>绑定一个对象，而不仅仅是一个属性。</p><p id="9faf" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">使用对象绑定的另一个好处是，您可以覆盖对象的任何绑定。在我们的例子中，如果我们在person对象中将<code class="fe mn mo mp mq b">isActive</code>设置为false，那么我们可以在实际的person组件上进行另一个绑定，并将<code class="fe mn mo mp mq b">isActive</code>设置为true，不覆盖原来的内容。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div></figure><h1 id="9eb1" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">8.修改组件中的属性</h1><p id="4349" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">在某些情况下，您可能希望修改从属性传入的值。然而，这样做会给你一个警告“避免直接改变道具”,这是有充分理由的。相反，使用prop值作为本地数据属性的默认值。这样做将使您能够看到原始值，但修改本地数据不会改变属性值。</p><p id="10d9" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">这里有一个权衡。使用这种方法，您的本地数据属性不会对属性值做出反应，因此父组件对属性值的任何更改都不会更新您的本地值。但是，如果您确实需要这些更新，也可以使用计算属性来组合值。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div></figure><h1 id="3f17" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">9.测试实用安装与浅安装</h1><p id="fc73" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">有两种方法可以在Vue测试工具中创建和引导组件。一个是座式，另一个是浅座式；两者各有优缺点。</p><p id="0139" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">当您想要在一个组件及其子组件之间进行相互依赖的测试时，挂载技术非常有用。允许您测试父组件是否如预期的那样与其子组件正确交互。相反，顾名思义，浅挂载技术只实例化和呈现完全隔离的父组件，而不考虑它的任何子组件。</p><p id="5fe9" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">那么哪种方法更好呢？这取决于你。你选择的策略应该取决于你可衡量的目标。尝试在完全隔离的情况下单独测试一个组件，浅层方法效果很好。需要在一个包含子组件的组件上工作，并希望确保通信，然后使用挂载选项。一个很好的选择是两者都用。你不局限于只有一个，所以混合和匹配，以满足您的测试需求。</p><h1 id="1050" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">10.Vue-cli的强大功能</h1><p id="07f3" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">Vue CLI是一个强大的命令行界面，允许开发人员快速利用大量功能来加快您的工作流程。</p><p id="1742" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">我经常使用的一个特性是运行<code class="fe mn mo mp mq b">vue serve</code>并传入一个Vue组件的路径。这样做的好处是，你可以完全独立地开发一个组件，但也可以热重载和迭代组件，直到它的核心功能消失。无需临时将新组件导入到页面上进行开发。</p><pre class="kj kk kl km gt nt mq nu nv aw nw bi"><span id="0bd2" class="nx kv it mq b gy ny nz l oa ob">vue serve ./components/views/GoldenRule</span></pre><p id="2754" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">在团队中工作时，您可能希望拿出一个特定的组件并与其他人共享。这引出了下一个特性Vue CLI将Vue组件导出为库的能力。当被调用时，Vue将自动构建一个单独的文件组件，将CSS移动到一个外部CSS文件中(可选的，你也可以内联它),并创建UMD和通用。用于导入其他js项目的JS文件。</p><pre class="kj kk kl km gt nt mq nu nv aw nw bi"><span id="7393" class="nx kv it mq b gy ny nz l oa ob">vue build —-target lib --name goldenRule ./components/views/GoldenRule</span></pre><div class="nb nc gp gr nd ne"><a href="https://cli.vuejs.org/" rel="noopener  ugc nofollow" target="_blank"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd iu gy z fp nj fr fs nk fu fw is bi translated">Vue CLI</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">用于Vue.js开发的🛠️标准工具</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">cli.vuejs.org</p></div></div><div class="nn l"><div class="oc l np nq nr nn ns ks ne"/></div></div></a></div></div><div class="ab cl od oe hx of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="im in io ip iq"><div class="kj kk kl km gt ne"><a href="https://gitconnected.com/learn/vue-js" rel="noopener  ugc nofollow" target="_blank"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd iu gy z fp nj fr fs nk fu fw is bi translated">学习Vue.js -最佳Vue.js教程(2019) | gitconnected</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">28大Vue.js教程-免费学习Vue.js。课程由开发人员提交并投票，使您能够…</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">gitconnected.com</p></div></div><div class="nn l"><div class="ok l np nq nr nn ns ks ne"/></div></div></a></div></div></div>    
</body>
</html>