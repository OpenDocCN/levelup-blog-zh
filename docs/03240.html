<html>
<head>
<title>How to build a K8S Operator using Ansible and Operator SDK</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Ansible和Operator SDK构建K8S运算符</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-build-a-k8s-operator-using-ansible-and-operator-sdk-8f98226abfbe?source=collection_archive---------8-----------------------#2020-04-27">https://levelup.gitconnected.com/how-to-build-a-k8s-operator-using-ansible-and-operator-sdk-8f98226abfbe?source=collection_archive---------8-----------------------#2020-04-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/92bbcd13be347cb407c67ff8d02c0444.png" data-original-src="https://miro.medium.com/v2/resize:fit:1138/format:webp/1*5bnN5dE82S5FYweZ7LF7nA.png"/></div></figure><p id="0f52" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">今天我将与你们分享如何使用Ansible实现“真实世界”操作符的信息。我们先来了解一下什么是运营商。操作符是Kubernetes的软件扩展，它允许我们创建定制资源来管理应用程序及其资源。通过操作符，我们可以创建一个抽象的、高层的对象，它将引用Kubernetes的目标，并以自动化的方式创建那些资源。操作员将充当该对象创建的监听器。</p><p id="e1d2" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">除了这个对象(又名自定义资源，CR)之外，我们还将创建一个CRD(又名自定义资源定义)，它将成为CR的模板。例如，要在Kubernetes上创建ELK堆栈，我们必须为pod、这些pod的服务、PV、PVC、routs等创建清单。为了简化在我们的K8S集群上部署这样一个ELK堆栈的过程，我们可以创建一个CR，它将被称为例如<code class="fe ks kt ku kv b">elk_stack</code>，并且将具有自己的属性(属性将被存储在CRD中)，例如num_elastic_nodes、num_kibana_nodes、num_logstash_instances等。</p><p id="c40b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">创建此CR时，运营商将根据最终用户的规格自动做出反应并创建所需的资源。最终，最终用户将拥有一个可以运行的、功能性的ELK堆栈供使用。</p><p id="cd02" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">做完这个简短的介绍后，让我们来谈谈我们为这个演示准备了什么。在这个演示中，我们将使用这个项目，它使用五个用不同编程语言(Ruby、Python、Node)编写的简单微服务。我们将构建一个对我们创建的每个CR做出反应的操作符。CR是一个集群，将所有这五个微服务聚集到一个对象中。创建CR时，运营商将在幕后创建部署、服务、路由等。最终，我们将得到一个使用CR及其属性创建的<code class="fe ks kt ku kv b">dockercoins</code>集群。如果你想一想，在现实世界中，我们可以使用任何我们拥有的应用程序，并使用操作符实现一些逻辑。这个逻辑将执行第一天的操作(如初始部署)和第二天的操作(如迁移、扩展等)，我们所要做的就是使用正确的清单。</p><p id="f40e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们简单介绍一下<code class="fe ks kt ku kv b">dockercoins</code>微服务架构，以便更好地了解动态变化:</p><ul class=""><li id="cf41" class="kw kx iq jw b jx jy kb kc kf ky kj kz kn la kr lb lc ld le bi translated">rng服务—生成随机字节的书面web服务</li><li id="e6b8" class="kw kx iq jw b jx lf kb lg kf lh kj li kn lj kr lb lc ld le bi translated">哈希服务—计算发布数据哈希的web服务</li><li id="dac5" class="kw kx iq jw b jx lf kb lg kf lh kj li kn lj kr lb lc ld le bi translated">使用rng和hasher的工作服务后台进程</li><li id="0775" class="kw kx iq jw b jx lf kb lg kf lh kj li kn lj kr lb lc ld le bi translated">WebUI服务—查看进度的web界面</li><li id="b394" class="kw kx iq jw b jx lf kb lg kf lh kj li kn lj kr lb lc ld le bi translated">Redis服务—存储进度信息</li></ul><p id="5e25" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">worker服务获取由rng服务生成的字节，使用hasher服务对它们进行散列，并将进度信息写入Redis。WebUI服务然后从Redis中提取信息，并在屏幕上呈现一个漂亮的散列/分钟图表。</p><p id="9a66" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们从演示开始吧！</p><h1 id="90f1" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">先决条件</h1><ul class=""><li id="5d47" class="kw kx iq jw b jx mi kb mj kf mk kj ml kn mm kr lb lc ld le bi translated">一个正在运行的Openshift集群(我的是4.3.8)</li><li id="8a4f" class="kw kx iq jw b jx lf kb lg kf lh kj li kn lj kr lb lc ld le bi translated">可执行操作符-SDK二进制文件(v0.16.0)</li></ul><p id="2294" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们在Openshift中创建一个新项目，在其中部署dockercoins集群:</p><pre class="mn mo mp mq gt mr kv ms mt aw mu bi"><span id="3e55" class="mv ll iq kv b gy mw mx l my mz">$ oc new-project dockercoins</span></pre><p id="5e62" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在，我们将使用operator-SDK命令生成dockercoins-operator清单，然后更改目录上下文:</p><pre class="mn mo mp mq gt mr kv ms mt aw mu bi"><span id="0f98" class="mv ll iq kv b gy mw mx l my mz">$ operator-sdk new dockercoins --type=ansible --api-version=dockercoins.example.com/v1alpha1 --kind=Dockercoins &amp;&amp; cd dockercoins</span></pre><p id="bb96" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">该命令将创建一个文件夹，其中包含我们构建操作符所需的所有文件。接下来，我们将从Ansible Galaxy中提取dockercoins ansible角色:</p><pre class="mn mo mp mq gt mr kv ms mt aw mu bi"><span id="9798" class="mv ll iq kv b gy mw mx l my mz">$ ansible-galaxy install shonpaz123.dockercoins -p ./roles<br/>$ rm -rf roles/dockercoins<br/>$ mv roles/shonpaz123.dockercoins roles/dockercoins</span></pre><p id="ce9f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">默认情况下，操作员SDK将创建一个名为shonpaz123.dockercoins的角色，因此要使用watchers中指定的相同角色。YAML文件，我们将删除由操作员SDK创建的角色，并将安装的角色重命名为<code class="fe ks kt ku kv b">dockercoins</code>。</p><h1 id="4211" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">关于码头工人的职责</h1><p id="1855" class="pw-post-body-paragraph ju jv iq jw b jx mi jz ka kb mj kd ke kf na kh ki kj nb kl km kn nc kp kq kr ij bi translated">在这个演示中，我们将使用可变角色来构建操作员的逻辑。每次最终用户创建一个CR时，操作员都会查看一下观察器。YAML文件(以了解应该执行哪个角色),并将触发ansible-runner调用所需的剧本。在这些行动手册中，我们可以使用所有可实现的目标，如Jinja模板、默认变量、任务等。在我们的情况下，主要的。YAML剧本调用其他剧本来创建所需的Kubernetes资源。这些剧本使用Jinja模板来呈现变量和创建所需的资源。让我们快速看一下实现:</p><pre class="mn mo mp mq gt mr kv ms mt aw mu bi"><span id="a774" class="mv ll iq kv b gy mw mx l my mz">$ cat roles/dockercoins/tasks/main.yml<br/>---<br/>- name: start redis deployment to "{{ state }}"<br/>  k8s:<br/>   state: "{{ state }}"<br/>   definition: "{{ lookup('template', 'redis-deployment.yaml.j2') | from_yaml }}"<br/>   namespace: "{{ meta.namespace }}"</span></pre><p id="a2ab" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这个例子说明了。由ansible-runner调用的YAML剧本使用K8S ansible模块与我们的Openshift集群进行交互。此任务在templates目录中查找Jinja模板，该模板如下所示:</p><pre class="mn mo mp mq gt mr kv ms mt aw mu bi"><span id="94c7" class="mv ll iq kv b gy mw mx l my mz">$ cat roles/dockercoins/templates/redis-deployment.yaml.j2 <br/>                                                                           <br/>kind: Deployment<br/>apiVersion: apps/v1<br/>metadata:<br/>  name: redis<br/>spec:<br/>  replicas: {{ redis_replicas|default(size) }}<br/>  selector:<br/>    matchLabels:    <br/>      app: redis<br/>  template:    <br/>    metadata:<br/>      labels:  <br/>        app: redis<br/>    spec:<br/>      containers:<br/>        - name: redis<br/>          image: redis<br/>          ports:<br/>            - containerPort: 6379<br/>              protocol: TCP</span></pre><p id="7427" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如您所见，这看起来像是创建Redis部署的常规Kubernetes部署，这正是我们在创建CR之后将创建的内容。我们还可以指定将通过CR spec部分传输的ansi ble extra-var(例如redis_replicas ),行动手册会将这些var呈现到行动手册中。我们稍后会看到这是如何发生的。总而言之，基本架构是:</p><figure class="mn mo mp mq gt jr gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/c5d1fd31d435b0d6db8d9d499f614bce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1358/format:webp/1*bHV4UlOnaSAyb6JqoN3Rvw.png"/></div></figure><p id="052a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在我们对事情的工作原理有了更多的了解之后，让我们继续演示。我们要做的下一件事是创建将用作CR模板的CRD:</p><pre class="mn mo mp mq gt mr kv ms mt aw mu bi"><span id="03bc" class="mv ll iq kv b gy mw mx l my mz">$ oc create -f deploy/crds/dockercoins.example.com_dockercoins_crd.yaml</span></pre><p id="98d9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在我们可以建立我们的运营商形象了:</p><pre class="mn mo mp mq gt mr kv ms mt aw mu bi"><span id="df24" class="mv ll iq kv b gy mw mx l my mz">$ sudo operator-sdk build shonpaz123/dockercoins-operator:v0.0.1  <br/>                                                          <br/>INFO[0000] Building OCI image shonpaz123/dockercoins-operator:v0.0.1 <br/>Sending build context to Docker daemon  63.49kB<br/>Step 1/5 : FROM quay.io/operator-framework/ansible-operator:v0.16.0<br/> ---&gt; 19ba5006a265<br/>Step 2/5 : COPY requirements.yml ${HOME}/requirements.yml<br/> ---&gt; Using cache<br/> ---&gt; 1374cf30e0a8<br/>Step 3/5 : RUN ansible-galaxy collection install -r ${HOME}/requirements.yml  &amp;&amp; chmod -R ug+rwx ${HOME}/.ansible<br/> ---&gt; Using cache<br/> ---&gt; b0b4385a4b17<br/>Step 4/5 : COPY watches.yaml ${HOME}/watches.yaml<br/> ---&gt; Using cache<br/> ---&gt; 80f801af37eb<br/>Step 5/5 : COPY roles/ ${HOME}/roles/<br/> ---&gt; 79199b06bc4b<br/>Successfully built 79199b06bc4b<br/>Successfully tagged shonpaz123/dockercoins-operator:v0.0.1<br/>INFO[0000] Operator build complete.</span></pre><p id="a66f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们已经使用operator-SDK命令构建了包含标记的操作符容器映像，现在我们可以将它推送到容器注册中心(在我们的例子中，是Docker Hub)。请注意，对于断开连接的容器注册中心，您需要添加一些额外的配置(添加pull secrets并将它们链接到正确的服务帐户)。<br/>来推图:</p><pre class="mn mo mp mq gt mr kv ms mt aw mu bi"><span id="9ea0" class="mv ll iq kv b gy mw mx l my mz">$ sudo docker push shonpaz123/dockercoins-operator:v0.0.1</span></pre><p id="7239" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">推送成功后，我们需要替换操作员部署中的操作员映像名称:</p><pre class="mn mo mp mq gt mr kv ms mt aw mu bi"><span id="bb26" class="mv ll iq kv b gy mw mx l my mz">$ sed -i  "s|\"REPLACE_IMAGE\"|shonpaz123/dockercoins-operator:v0.0.1|g" deploy/operator.yaml</span></pre><p id="03d2" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">该命令将正确的映像名称提交到操作员的部署YAML中。让我们继续创建RBAC角色、服务帐户和安全约束:</p><pre class="mn mo mp mq gt mr kv ms mt aw mu bi"><span id="dd8d" class="mv ll iq kv b gy mw mx l my mz">$ oc create -f deploy/service_account.yaml<br/>$ oc create -f deploy/role.yaml<br/>$ oc create -f deploy/role_binding.yaml<br/>$ oc adm policy add-role-to-user admin system:serviceaccount:dockercoins:dockercoins<br/>$ oc adm policy add-scc-to-user anyuid -z default</span></pre><p id="82fa" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这些清单至关重要，我们需要它们来允许operator-SDK创建的用户与我们的Openshift集群进行交互。现在我们可以部署我们的操作员了:</p><pre class="mn mo mp mq gt mr kv ms mt aw mu bi"><span id="4fd3" class="mv ll iq kv b gy mw mx l my mz">$ oc create -f deploy/operator.yaml</span></pre><p id="a34e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在让我们来看看这些豆荚:</p><pre class="mn mo mp mq gt mr kv ms mt aw mu bi"><span id="126a" class="mv ll iq kv b gy mw mx l my mz">$ oc get pods<br/>                                                                                                                          <br/>NAME                           READY   STATUS        RESTARTS   AGE<br/>dockercoins-84446678bc-6zpkq   1/1     Running       0          8m</span></pre><p id="04e7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">因此，我们看到我们的操作员正在运行，并在创建CR之前等待CR创建。让我们看一下CR清单:</p><pre class="mn mo mp mq gt mr kv ms mt aw mu bi"><span id="3466" class="mv ll iq kv b gy mw mx l my mz">$ cat deploy/crds/dockercoins.example.com_v1alpha1_dockercoins_cr.yaml  <br/>                                                                <br/>apiVersion: dockercoins.example.com/v1alpha1<br/>kind: Dockercoins<br/>metadata:<br/>  name: example-dockercoins<br/>spec:<br/>  # Add fields here<br/>  size: 3</span></pre><p id="c8b4" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">因此，我们的默认CR看起来像这样，让我们稍微改变一下，以了解我们如何使用ansible extra-vars来创建更大的灵活性。在之前的演示中，我们看到在Jinja模板中有一个变量定义<code class="fe ks kt ku kv b">{{ redis_replicas|default(size) }}</code>,这个定义表示如果我们定义了redis_replicas变量，我们可以使用它，如果没有，我们将从目录中的默认变量中获取它。var和defaults目录中都没有<code class="fe ks kt ku kv b">redis_replicas</code>变量。这就是为什么我们将使用CR的spec部分将这些变量呈现给ansible。CR应该是这样的:</p><pre class="mn mo mp mq gt mr kv ms mt aw mu bi"><span id="9e0f" class="mv ll iq kv b gy mw mx l my mz">apiVersion: dockercoins.example.com/v1alpha1<br/>kind: Dockercoins<br/>metadata:<br/>  name: dockercoins-cluster<br/>spec:<br/>  # Add fields here<br/>  redis_replicas: 2<br/>  worker_replicas: 2 <br/>  webui_replicas: 4</span></pre><p id="36d2" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如您所见，我们已经使用了创建<code class="fe ks kt ku kv b">dockercoins</code>集群的属性，并且我们可以控制哪些变量可以在我们的角色中进行更改。这个CR将创建一个集群，其中我们对hasher和rng服务使用默认大小(3 ),但是其余的服务将使用下面的CR获得它们的副本大小。现在我们可以创建CR并查看这些变量是否成功地呈现给ansible-runner:</p><pre class="mn mo mp mq gt mr kv ms mt aw mu bi"><span id="9839" class="mv ll iq kv b gy mw mx l my mz">$ oc create -f deploy/crds/dockercoins.example.com_v1alpha1_dockercoins_cr.yaml</span></pre><p id="51e6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们来看看豆荚:</p><pre class="mn mo mp mq gt mr kv ms mt aw mu bi"><span id="12b5" class="mv ll iq kv b gy mw mx l my mz">$ oc get pods <br/>                                                                                                                       <br/>NAME                           READY   STATUS    RESTARTS   AGE<br/>dockercoins-84446678bc-6zpkq   1/1     Running   0          105m<br/>hasher-7fb454b674-plbz9        1/1     Running   0          17s<br/>hasher-7fb454b674-qj2xf        1/1     Running   0          17s<br/>hasher-7fb454b674-snlwp        1/1     Running   0          17s<br/>redis-8687bfc768-xcddq         1/1     Running   0          20s<br/>redis-8687bfc768-zgcvg         1/1     Running   0          20s<br/>rng-58c7d9748-tcrfx            1/1     Running   0          14s<br/>rng-58c7d9748-w78sl            1/1     Running   0          14s<br/>rng-58c7d9748-xk7kl            1/1     Running   0          14s<br/>webui-5c7654c5bc-cvtq4         1/1     Running   0          9s<br/>webui-5c7654c5bc-f2k5w         1/1     Running   0          9s<br/>webui-5c7654c5bc-ppz52         1/1     Running   0          9s<br/>webui-5c7654c5bc-tmb8j         1/1     Running   0          9s<br/>worker-746686b79d-9gq8t        1/1     Running   0          10s<br/>worker-746686b79d-bnsm6        1/1     Running   0          10s</span></pre></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><pre class="mr kv ms mt aw mu bi"><span id="3184" class="mv ll iq kv b gy nl nm nn no np mx l my mz">$ oc get pods | grep -v "NAME" | grep -v "dockercoins" | awk '{print $1}' | awk -F "-" '{print $1}' | uniq -c  <br/>               <br/>      3 hasher<br/>      2 redis<br/>      3 rng<br/>      4 webui<br/>      2 worker</span></pre><p id="4656" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如您所见，对于指定的副本，我们有指定的数量，但是对于那些没有指定的副本，ansible使用默认的大小。让我们缩小WebUI服务并应用配置:</p><pre class="mn mo mp mq gt mr kv ms mt aw mu bi"><span id="1d6b" class="mv ll iq kv b gy mw mx l my mz">apiVersion: dockercoins.example.com/v1alpha1<br/>kind: Dockercoins<br/>metadata:<br/>  name: dockercoins-cluster<br/>spec:<br/>  # Add fields here<br/>  redis_replicas: 2<br/>  worker_replicas: 2 <br/>  webui_replicas: 2</span></pre></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><pre class="mr kv ms mt aw mu bi"><span id="1bb4" class="mv ll iq kv b gy nl nm nn no np mx l my mz">$ oc apply -f deploy/crds/dockercoins.example.com_v1alpha1_dockercoins_cr.yaml</span></pre><p id="bd66" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们看到有2个副本处于终止状态，这意味着服务已经缩减:</p><pre class="mn mo mp mq gt mr kv ms mt aw mu bi"><span id="efb4" class="mv ll iq kv b gy mw mx l my mz">$ oc get pods          <br/>                                                                                                              <br/>NAME                           READY   STATUS        RESTARTS   AGE<br/>dockercoins-84446678bc-6zpkq   1/1     Running       0          111m<br/>hasher-7fb454b674-plbz9        1/1     Running       0          6m28s<br/>hasher-7fb454b674-qj2xf        1/1     Running       0          6m28s<br/>hasher-7fb454b674-snlwp        1/1     Running       0          6m28s<br/>redis-8687bfc768-xcddq         1/1     Running       0          6m31s<br/>redis-8687bfc768-zgcvg         1/1     Running       0          6m31s<br/>rng-58c7d9748-tcrfx            1/1     Running       0          6m25s<br/>rng-58c7d9748-w78sl            1/1     Running       0          6m25s<br/>rng-58c7d9748-xk7kl            1/1     Running       0          6m25s<br/>webui-5c7654c5bc-cvtq4         1/1     Terminating   0          6m20s<br/>webui-5c7654c5bc-f2k5w         1/1     Running       0          6m20s<br/>webui-5c7654c5bc-ppz52         1/1     Terminating   0          6m20s<br/>webui-5c7654c5bc-tmb8j         1/1     Running       0          6m20s<br/>worker-746686b79d-9gq8t        1/1     Running       0          6m21s<br/>worker-746686b79d-bnsm6        1/1     Running       0          6m21s</span></pre><p id="05cf" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们验证一下:</p><pre class="mn mo mp mq gt mr kv ms mt aw mu bi"><span id="4730" class="mv ll iq kv b gy mw mx l my mz">$ oc get pods | grep -v "NAME" | grep -v "dockercoins" | awk '{print $1}' | awk -F "-" '{print $1}' | uniq -c<br/>                 <br/>      3 hasher<br/>      2 redis<br/>      3 rng<br/>      2 webui<br/>      2 worker</span></pre><p id="4c67" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">您可以使用<code class="fe ks kt ku kv b">oc get svc</code>来确保所有服务都按预期创建，让我们看看为WebUI创建的路由，看看我们是否能看到WebUI图:</p><pre class="mn mo mp mq gt mr kv ms mt aw mu bi"><span id="f755" class="mv ll iq kv b gy mw mx l my mz">$ oc get route</span><span id="b7d3" class="mv ll iq kv b gy nq mx l my mz">NAME    HOST/PORT                            PATH   SERVICES   PORT   TERMINATION   WILDCARD<br/>webui   webui-dockercoins.apps-crc.testing          webui      80                   None</span></pre><p id="dc00" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在让我们访问<code class="fe ks kt ku kv b">webui-dockercoins.apps-crc.testing</code>,看看我们是否得到了图表:</p><figure class="mn mo mp mq gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi nr"><img src="../Images/4444246c42600cadaf58157845d250a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*og21ivHvVRLFsRYtI70Y6w.png"/></div></div></figure><p id="8a16" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们成功了！</p><h1 id="25aa" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">结论</h1><p id="398d" class="pw-post-body-paragraph ju jv iq jw b jx mi jz ka kb mj kd ke kf na kh ki kj nb kl km kn nc kp kq kr ij bi translated">因此，我们看到了如何创建一个能够监听我们CR作品的运营商。这种开发方法在处理K8S/Openshift时变得非常流行，允许开发人员使用K8S资源和众所周知的缩写。希望你喜欢这个演示，感谢阅读:)</p></div></div>    
</body>
</html>