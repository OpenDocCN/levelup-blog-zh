<html>
<head>
<title>Mocking HTTP Call in Golang a Better Way</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Golang更好地模拟HTTP调用</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/mocking-http-call-in-golang-a-better-way-5cb97e3d5ffe?source=collection_archive---------1-----------------------#2021-12-17">https://levelup.gitconnected.com/mocking-http-call-in-golang-a-better-way-5cb97e3d5ffe?source=collection_archive---------1-----------------------#2021-12-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/387593e0b9251f027b99e3971ff9d123.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qn1RLDKsxdwidpTR"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><em class="kc">照片由</em><a class="ae kd" href="https://unsplash.com/@jim_reardan" rel="noopener ugc nofollow" target="_blank"><em class="kc">@ Jim _ rear Dan</em></a><em class="kc">在Unsplash上</em></figcaption></figure><h1 id="e237" class="ke kf iq bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">介绍</h1><p id="4395" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">作为一名软件工程师，你需要每天学习以保持你的知识是最新的。任何方面的改进都会帮助你写出更好的代码。写了越来越多的Golang代码后，我意识到我可以改进<a class="ae kd" href="https://clavinjune.dev/en/blogs/mocking-http-call-in-golang/" rel="noopener ugc nofollow" target="_blank">这篇博文</a>。</p><p id="303a" class="pw-post-body-paragraph lc ld iq le b lf ma lh li lj mb ll lm ln mc lp lq lr md lt lu lv me lx ly lz ij bi translated">正如您在那篇文章中看到的，您需要<a class="ae kd" href="https://clavinjune.dev/en/blogs/mocking-http-call-in-golang/#http-client-mock" rel="noopener ugc nofollow" target="_blank">模拟HTTP客户端</a>来正确模拟HTTP调用。此外，您需要更改您的<a class="ae kd" href="https://clavinjune.dev/en/blogs/mocking-http-call-in-golang/#api-implementation-struct" rel="noopener ugc nofollow" target="_blank"> API实现</a>来使用HTTPClient接口。从长远来看，这是一个相当大的问题，因为你不知道HTTP客户端在Golang代码库的下一个版本中会得到什么样的改进。如果您模仿HTTP客户端，这就是您遇到的问题。相反，您可以改变视角，开始模仿HTTP服务器。</p><p id="f9e3" class="pw-post-body-paragraph lc ld iq le b lf ma lh li lj mb ll lm ln mc lp lq lr md lt lu lv me lx ly lz ij bi translated">在这篇博文中，您将学习如何使用内置测试库模拟HTTP服务器。没有必要创建自己的接口，因为它们都是由Golang标准库<code class="fe mf mg mh mi b">httptest</code>提供的。</p><h1 id="44f4" class="ke kf iq bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">目录结构</h1><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="e71f" class="mr kf iq mi b gy ms mt l mu mv">$ go mod init example<br/>go: creating new go.mod: module example<br/>$ mkdir -p external<br/>$ touch external/{external.go,external_test.go}<br/>$ tree .<br/>.<br/>├── external<br/>│   ├── external.go<br/>│   └── external_test.go<br/>└── go.mod</span><span id="8915" class="mr kf iq mi b gy mw mt l mu mv">1 directory, 3 files</span></pre><h1 id="68b5" class="ke kf iq bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">实施文件内容</h1><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="b243" class="mr kf iq mi b gy ms mt l mu mv">// external.go<br/>package external</span><span id="b937" class="mr kf iq mi b gy mw mt l mu mv">import (<br/>    "context"<br/>    "encoding/json"<br/>    "errors"<br/>    "fmt"<br/>    "net/http"<br/>    "time"<br/>)</span><span id="83d7" class="mr kf iq mi b gy mw mt l mu mv">var (<br/>    ErrResponseNotOK error = errors.New("response not ok")<br/>)</span><span id="a712" class="mr kf iq mi b gy mw mt l mu mv">type (<br/>    Data struct {<br/>        ID   string `json:"id"`<br/>        Name string `json:"name"`<br/>    }</span><span id="7617" class="mr kf iq mi b gy mw mt l mu mv">External interface {<br/>        FetchData(ctx context.Context, id string) (*Data, error)<br/>    }</span><span id="2ea9" class="mr kf iq mi b gy mw mt l mu mv">v1 struct {<br/>        baseURL string<br/>        client  *http.Client<br/>        timeout time.Duration<br/>    }<br/>)</span><span id="2528" class="mr kf iq mi b gy mw mt l mu mv">func New(baseURL string, client *http.Client, timeout time.Duration) *v1 {<br/>    return &amp;v1{<br/>        baseURL: baseURL,<br/>        client:  client,<br/>        timeout: timeout,<br/>    }<br/>}</span><span id="93dd" class="mr kf iq mi b gy mw mt l mu mv">func (v *v1) FetchData(ctx context.Context, id string) (*Data, error) {<br/>    url := fmt.Sprintf("%s/?id=%s", v.baseURL, id)</span><span id="5027" class="mr kf iq mi b gy mw mt l mu mv">ctx, cancel := context.WithTimeout(ctx, v.timeout)<br/>    defer cancel()</span><span id="a91f" class="mr kf iq mi b gy mw mt l mu mv">req, err := http.NewRequestWithContext(ctx, http.MethodGet, url, nil)<br/>    if err != nil {<br/>        return nil, err<br/>    }</span><span id="c002" class="mr kf iq mi b gy mw mt l mu mv">resp, err := v.client.Do(req)<br/>    if err != nil {<br/>        return nil, err<br/>    }<br/>    defer resp.Body.Close()</span><span id="dd10" class="mr kf iq mi b gy mw mt l mu mv">if resp.StatusCode != http.StatusOK {<br/>        return nil, fmt.Errorf("%w. %s", ErrResponseNotOK, http.StatusText(resp.StatusCode))<br/>    }</span><span id="898b" class="mr kf iq mi b gy mw mt l mu mv">var d *Data<br/>    return d, json.NewDecoder(resp.Body).Decode(&amp;d)<br/>}</span></pre><p id="2f6d" class="pw-post-body-paragraph lc ld iq le b lf ma lh li lj mb ll lm ln mc lp lq lr md lt lu lv me lx ly lz ij bi translated">它与您之前实现的略有不同，但目标仍然是对外部服务进行HTTP调用。让我们把重点放在你需要嘲笑的<code class="fe mf mg mh mi b">External interface</code>上。</p><h1 id="f814" class="ke kf iq bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">测试文件内容</h1><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="eed6" class="mr kf iq mi b gy ms mt l mu mv">package external_test</span><span id="10fb" class="mr kf iq mi b gy mw mt l mu mv">import (<br/>    "example/external"<br/>    "fmt"<br/>    "net/http"<br/>    "net/http/httptest"<br/>    "testing"<br/>    "time"<br/>)</span><span id="4e21" class="mr kf iq mi b gy mw mt l mu mv">var (<br/>    server *httptest.Server<br/>    ext    external.External<br/>)</span><span id="479e" class="mr kf iq mi b gy mw mt l mu mv">func TestMain(m *testing.M) {<br/>    fmt.Println("mocking server")<br/>    server = httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {<br/>        // mock here<br/>    }))</span><span id="7bde" class="mr kf iq mi b gy mw mt l mu mv">fmt.Println("mocking external")<br/>    ext = external.New(server.URL, http.DefaultClient, time.Second)</span><span id="5668" class="mr kf iq mi b gy mw mt l mu mv">fmt.Println("run tests")<br/>    m.Run()<br/>}</span></pre><p id="b0c0" class="pw-post-body-paragraph lc ld iq le b lf ma lh li lj mb ll lm ln mc lp lq lr md lt lu lv me lx ly lz ij bi translated">首先，您需要模拟HTTP服务器和<code class="fe mf mg mh mi b">External object</code>。</p><p id="5936" class="pw-post-body-paragraph lc ld iq le b lf ma lh li lj mb ll lm ln mc lp lq lr md lt lu lv me lx ly lz ij bi translated">正如您在第24行看到的:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="db48" class="mr kf iq mi b gy ms mt l mu mv">...<br/>ext = external.New(server.URL, http.DefaultClient, time.Second)<br/>...</span></pre><p id="c894" class="pw-post-body-paragraph lc ld iq le b lf ma lh li lj mb ll lm ln mc lp lq lr md lt lu lv me lx ly lz ij bi translated">您可以将<code class="fe mf mg mh mi b">server.URL</code>用作<code class="fe mf mg mh mi b">baseURL</code>，这样所有对<code class="fe mf mg mh mi b">baseURL</code>的HTTP调用都将由<code class="fe mf mg mh mi b">httptest.Server</code>处理。这就是你模拟HTTP服务器而不是HTTP调用的方式。</p><p id="c29d" class="pw-post-body-paragraph lc ld iq le b lf ma lh li lj mb ll lm ln mc lp lq lr md lt lu lv me lx ly lz ij bi translated">创建模拟服务器之后，您还需要模拟端点。例如:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="d837" class="mr kf iq mi b gy ms mt l mu mv">...</span><span id="7438" class="mr kf iq mi b gy mw mt l mu mv">func mockFetchDataEndpoint(w http.ResponseWriter, r *http.Request) {<br/>    ids, ok := r.URL.Query()["id"]</span><span id="9ace" class="mr kf iq mi b gy mw mt l mu mv">sc := http.StatusOK<br/>    m := make(map[string]interface{})</span><span id="6408" class="mr kf iq mi b gy mw mt l mu mv">if !ok || len(ids[0]) == 0 {<br/>        sc = http.StatusBadRequest<br/>    } else {<br/>        m["id"] = "mock"<br/>        m["name"] = "mock"<br/>    }</span><span id="ada7" class="mr kf iq mi b gy mw mt l mu mv">w.Header().Set("Content-Type", "application/json")<br/>    w.WriteHeader(sc)<br/>    json.NewEncoder(w).Encode(m)<br/>}</span><span id="9207" class="mr kf iq mi b gy mw mt l mu mv">...</span></pre><p id="6544" class="pw-post-body-paragraph lc ld iq le b lf ma lh li lj mb ll lm ln mc lp lq lr md lt lu lv me lx ly lz ij bi translated">然后，将端点放入模拟服务器中。</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="102a" class="mr kf iq mi b gy ms mt l mu mv">...</span><span id="a5be" class="mr kf iq mi b gy mw mt l mu mv">server = httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {<br/>    switch strings.TrimSpace(r.URL.Path) {<br/>    case "/":<br/>        mockFetchDataEndpoint(w, r)<br/>    default:<br/>        http.NotFoundHandler().ServeHTTP(w, r)<br/>    }<br/>}))</span><span id="da6d" class="mr kf iq mi b gy mw mt l mu mv">...</span></pre><p id="0477" class="pw-post-body-paragraph lc ld iq le b lf ma lh li lj mb ll lm ln mc lp lq lr md lt lu lv me lx ly lz ij bi translated">这样模仿HTTP服务器的好处是，您可以将所有需要的端点都放在一个服务器上。它将在<code class="fe mf mg mh mi b">m.Run()</code>之前被创建一次，然后被同一个包中的所有测试使用。</p><h1 id="b61b" class="ke kf iq bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">创建单元测试</h1><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="08c7" class="mr kf iq mi b gy ms mt l mu mv">...</span><span id="4fd0" class="mr kf iq mi b gy mw mt l mu mv">func fatal(t *testing.T, want, got interface{}) {<br/>    t.Helper()<br/>    t.Fatalf(`want: %v, got: %v`, want, got)<br/>}</span><span id="df7a" class="mr kf iq mi b gy mw mt l mu mv">func TestExternal_FetchData(t *testing.T) {<br/>    tt := []struct {<br/>        name     string<br/>        id       string<br/>        wantData *external.Data<br/>        wantErr  error<br/>    }{<br/>        {<br/>            name:     "response not ok",<br/>            id:       "",<br/>            wantData: nil,<br/>            wantErr:  external.ErrResponseNotOK,<br/>        },<br/>        {<br/>            name: "data found",<br/>            id:   "mock",<br/>            wantData: &amp;external.Data{<br/>                ID:   "mock",<br/>                Name: "mock",<br/>            },<br/>            wantErr: nil,<br/>        },<br/>    }</span><span id="683a" class="mr kf iq mi b gy mw mt l mu mv">for i := range tt {<br/>        tc := tt[i]</span><span id="cf12" class="mr kf iq mi b gy mw mt l mu mv">t.Run(tc.name, func(t *testing.T) {<br/>            t.Parallel()</span><span id="9884" class="mr kf iq mi b gy mw mt l mu mv">gotData, gotErr := ext.FetchData(context.Background(), tc.id)</span><span id="6550" class="mr kf iq mi b gy mw mt l mu mv">if !errors.Is(gotErr, tc.wantErr) {<br/>                fatal(t, tc.wantErr, gotErr)<br/>            }</span><span id="755c" class="mr kf iq mi b gy mw mt l mu mv">if !reflect.DeepEqual(gotData, tc.wantData) {<br/>                fatal(t, tc.wantData, gotData)<br/>            }<br/>        })<br/>    }<br/>}</span></pre><p id="859d" class="pw-post-body-paragraph lc ld iq le b lf ma lh li lj mb ll lm ln mc lp lq lr md lt lu lv me lx ly lz ij bi translated">现在您已经模拟了HTTP服务器，单元测试本身没有什么特别的。您可以像往常一样开始编写单元测试。例如:</p><h1 id="0c4c" class="ke kf iq bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">结论</h1><p id="5779" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">通过改变视角，你已经提高了单元测试很多。模拟HTTP服务器比模拟HTTP调用更具可读性，也更合适。您不需要创建HTTP客户端的接口，并开始使用标准的方式通过使用<code class="fe mf mg mh mi b">httptest</code>来模拟调用。</p><p id="7c43" class="pw-post-body-paragraph lc ld iq le b lf ma lh li lj mb ll lm ln mc lp lq lr md lt lu lv me lx ly lz ij bi translated">感谢您的阅读！</p></div><div class="ab cl mx my hu mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ij ik il im in"><p id="723b" class="pw-post-body-paragraph lc ld iq le b lf ma lh li lj mb ll lm ln mc lp lq lr md lt lu lv me lx ly lz ij bi translated"><em class="ne">原载于2021年12月17日</em><a class="ae kd" href="https://clavinjune.dev/en/blogs/mocking-http-call-in-golang-a-better-way/" rel="noopener ugc nofollow" target="_blank"><em class="ne">https://clavinjune . dev</em></a><em class="ne">。</em></p></div></div>    
</body>
</html>