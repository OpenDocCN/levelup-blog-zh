<html>
<head>
<title>Be More Lazy, Become More Productive</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">变得更懒，变得更有效率</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/be-more-lazy-become-more-productive-816c629a06c5?source=collection_archive---------13-----------------------#2020-07-30">https://levelup.gitconnected.com/be-more-lazy-become-more-productive-816c629a06c5?source=collection_archive---------13-----------------------#2020-07-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/223c237ea369e0b2bee9e2f586ba1c1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ONPUdc8o9E9eCi967nnxxg.jpeg"/></div></div></figure><p id="4b1b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这篇标题矛盾的文章中，我们将懒惰作为Python中函数式编程的一个核心方面来研究。我说的不是<a class="ae kw" href="https://melreams.com/2017/05/rich-hickey-hammock-driven-development/" rel="noopener ugc nofollow" target="_blank">吊床驱动开发</a>或者一些这样悠闲的有标题的范式，而是<a class="ae kw" href="https://en.wikipedia.org/wiki/Lazy_evaluation" rel="noopener ugc nofollow" target="_blank">懒评</a>。我们将看到懒惰评估如何通过重构一个小例子来提高可重用性和可组合性，从而提高您的工作效率，同时引入懒惰。</p><p id="0180" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">简单地说，惰性求值意味着直到需要表达式的结果时才会对其求值。对比一下<em class="kx">急切评估</em>，这是命令式编程的标准。在急切求值下，函数在被调用时会立即计算它们的结果(并执行它们的副作用)。例如，考虑这个名为<code class="fe ky kz la lb b">get_json</code>的python函数，它调用一个web api作为副作用，并将响应解析为json:</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="7664" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，假设我们想要实现一个带有简单回退机制的重试策略。我们可以采取急切的方法并适应<code class="fe ky kz la lb b">get_json</code>:</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="f3dc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是可行的，但是这个解决方案有一个巨大的缺点:我们不能对其他类型的HTTP请求重用重试策略。或者替代地，但等价地:<code class="fe ky kz la lb b">get_json</code>违反了单一责任原则，因为它现在有三种责任:</p><ul class=""><li id="2c88" class="li lj iq ka b kb kc kf kg kj lk kn ll kr lm kv ln lo lp lq bi translated">调用api</li><li id="2ceb" class="li lj iq ka b kb lr kf ls kj lt kn lu kr lv kv ln lo lp lq bi translated">解析json</li><li id="39b1" class="li lj iq ka b kb lr kf ls kj lt kn lu kr lv kv ln lo lp lq bi translated">再试</li></ul><p id="d820" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这使得它很难重复使用。让我们通过偷懒来解决它。为了保持一般性，我们将定义一个类型别名来模拟惰性值，这些惰性值产生时有或没有副作用。让我们称这个别名为<code class="fe ky kz la lb b">Effect</code>,因为它允许我们将副作用视为可以由我们的程序操纵的一级值，从而从“副作用”中取出“副作用”。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="b281" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将使用这个别名来实现函数<code class="fe ky kz la lb b">retry</code>，它可以接受任何<code class="fe ky kz la lb b">Effect</code>，并使用之前相同的回退机制重试:</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="5dcf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ky kz la lb b">retry</code>将(例如)HTTP请求的结果视为可以操作的惰性值。我在这里使用术语<em class="kx">懒惰值</em>，因为它非常符合我们的主题，但实际上我可以说<code class="fe ky kz la lb b">retry</code>使用<code class="fe ky kz la lb b">get_json</code>作为高阶函数。通过将函数视为可以传递的惰性值，<code class="fe ky kz la lb b">retry</code>或多或少地实现了总的可重用性。</p><p id="5b57" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">到目前为止一切顺利。现在让我们实现一个名为<code class="fe ky kz la lb b">run_async</code>的函数，它并行执行惰性值。显然，我们希望能够将<code class="fe ky kz la lb b">run_async</code>与<code class="fe ky kz la lb b">get_json</code>和<code class="fe ky kz la lb b">retry</code>一起使用:</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="15e9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">(这实际上是行不通的，因为我们已经有了lambdas，而且<code class="fe ky kz la lb b">multipocessing</code>不喜欢没有第三方库，但是请原谅我。)</p><p id="e6eb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这很好，但是你可能会反对我们把代码弄得一团糟。我同意。特别是我认为我们的“粘合”功能<code class="fe ky kz la lb b">get_json_with_retry</code>和<code class="fe ky kz la lb b">get_json_async_with_retry</code>笨拙得令人尴尬。在我看来，缺少的是将懒惰值粘合在一起的通用解决方案，这会使这些专用粘合函数变得多余。</p><p id="9936" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了实现这一点，我们将使用以下教条:</p><ul class=""><li id="06b1" class="li lj iq ka b kb kc kf kg kj lk kn ll kr lm kv ln lo lp lq bi translated">执行副作用的函数返回<code class="fe ky kz la lb b">Effect</code>实例。换句话说，它们不是直接执行计算或副作用，而是返回<em class="kx">一个结果(和/或副作用)的惰性描述，该描述可以与在</em> <code class="fe ky kz la lb b"><em class="kx">Effect</em></code> <em class="kx">实例</em>上操作的函数相结合。</li><li id="5f1e" class="li lj iq ka b kb lr kf ls kj lt kn lu kr lv kv ln lo lp lq bi translated">对<code class="fe ky kz la lb b">Effect</code>实例进行操作的函数返回新的<code class="fe ky kz la lb b">Effect</code>实例</li></ul><p id="7b43" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用这种方案，任何惰性结果都可以由对惰性结果进行操作的函数无限组合。的确，对懒惰结果进行操作的函数可以与它们自己进行组合！</p><p id="d66b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，让我们通过把我们的懒惰提高到纨绔子弟的昏睡水平来最大化我们解决方案的可重用性。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lw"><img src="../Images/980aa356897849d03dc116e881b9ac59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*idYV_ikbOvio8Q4F"/></div></div></figure><p id="eb1c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们从重构<code class="fe ky kz la lb b">get_json</code>返回一个<code class="fe ky kz la lb b">Effect</code>开始。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="c0d4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">相当直接。现在让我们对<code class="fe ky kz la lb b">retry</code>和<code class="fe ky kz la lb b">run_async</code>做同样的事情</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="440e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有了这个，我们就可以用最少的努力，按照我们内心的愿望，组合出我们功能的任何变化:</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="c41f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，要意识到我们可以进一步重用<code class="fe ky kz la lb b">get_json_with_retry</code>和<code class="fe ky kz la lb b">get_json_async_with_retry</code>以及操作<code class="fe ky kz la lb b">Effect</code>实例的任何函数。此外，请注意<em class="kx">懒惰</em>(或高阶函数)使我们能够以这种程度的重用进行编程，并允许在这种高抽象级别上的组合性(最终在整个程序的级别上)。</p><p id="aba8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当函数式程序员声称用函数式风格编程使你更有效率时，这就是原因:函数式编程(通常涉及懒惰评估)可以极大地提高可重用性和可组合性，这意味着你可以用更少的资源做更多的事情。所有这些优点都是我创作库<a class="ae kw" href="http://pfun.rtfd.io" rel="noopener ugc nofollow" target="_blank"> pfun </a>的动机的一部分，这个库使得用函数式风格编写Python成为可能，在这个例子中没有所有的样板文件和仪式。</p><p id="9d5f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">额外的好处是，函数式程序通常更容易预测，也更容易推理。此外，通过少量修改，我们在这里开发的模式可以扩展到完全类型安全的<a class="ae kw" href="https://pfun.dev/effectful_but_side_effect_free#the-module-pattern" rel="noopener ugc nofollow" target="_blank">依赖注入</a>和<a class="ae kw" href="https://pfun.dev/effectful_but_side_effect_free#error-handling" rel="noopener ugc nofollow" target="_blank">错误处理</a>。此外，静态类型检查变得更加有用，因为所有函数都必须返回值，即使它们仅仅产生副作用(在这种情况下，它们将返回<code class="fe ky kz la lb b">Effect[None]</code>)。</p><p id="963b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了重构我们的例子，我们已经在某种程度上重新发明了一个通用的函数模式:神秘的<a class="ae kw" href="https://en.wikipedia.org/wiki/Monad_(functional_programming)#IO_monad_(Haskell)" rel="noopener ugc nofollow" target="_blank"> IO </a>类型(在我们的例子中我们称之为<code class="fe ky kz la lb b">Effect</code>，我希望你在这一点上一点也不觉得神秘)。关于<code class="fe ky kz la lb b">IO</code>是什么和做什么有很多困惑，尤其是在Haskell和Scala程序员的函数式编程俱乐部之外。因此，你有时会听到<code class="fe ky kz la lb b">IO</code>被解释为:</p><ul class=""><li id="fe32" class="li lj iq ka b kb kc kf kg kj lk kn ll kr lm kv ln lo lp lq bi translated">执行副作用的函数返回<code class="fe ky kz la lb b">IO</code></li><li id="f7a6" class="li lj iq ka b kb lr kf ls kj lt kn lu kr lv kv ln lo lp lq bi translated">不产生副作用的函数不会产生副作用</li></ul><p id="266a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虽然这个解释严格来说并不是不正确的，但它非常不充分，因为它没有提到任何关于懒惰的事情，而懒惰是<code class="fe ky kz la lb b">IO</code>的核心特征。基于这种天真的解释，您可能会尝试这样的事情:</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="d2e0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个<code class="fe ky kz la lb b">IO</code>实现只是简单地标记执行IO的函数的返回值，让调用者清楚地知道涉及到了副作用。这是否有用是<a class="ae kw" href="https://degoes.net/articles/no-effect-tracking" rel="noopener ugc nofollow" target="_blank">有些争议的问题</a>，<em class="kx">但是它没有带来我们在本文中讨论的任何函数式编程的好处，因为这个</em> <code class="fe ky kz la lb b"><em class="kx">IO</em></code> <em class="kx">版本是热切的</em>。</p><p id="afdc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">总之:懒惰(或高阶函数)可以实现彻底的重用和组合，这两者都会让你更有效率。要开始使用Python进行函数式编程，请查阅<a class="ae kw" href="https://pfun.dev" rel="noopener ugc nofollow" target="_blank"> pfun </a>文档，或者<a class="ae kw" href="http://github.com/suned/pfun" rel="noopener ugc nofollow" target="_blank"> github库</a>。</p></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><p id="e65d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kx">最初发布于</em><a class="ae kw" href="https://dev.to/suned/be-more-lazy-become-more-productive-2cnb" rel="noopener ugc nofollow" target="_blank"><em class="kx">dev . to</em></a><em class="kx">。</em></p></div></div>    
</body>
</html>