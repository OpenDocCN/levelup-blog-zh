<html>
<head>
<title>RegEx — The only Ex you need to Remember!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">正则表达式——你唯一需要记住的表达式！</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/regex-the-only-ex-you-need-to-remember-5eb5e5e04af5?source=collection_archive---------9-----------------------#2022-10-03">https://levelup.gitconnected.com/regex-the-only-ex-you-need-to-remember-5eb5e5e04af5?source=collection_archive---------9-----------------------#2022-10-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/100787812d724797144b255614117573.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*44YU_TpRtvCfa62yJNaSEQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><strong class="bd kc">作者图片</strong></figcaption></figure><p id="a4ea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正则表达式(RegEx)是处理文本和数据的非常强大的工具。从搜索引擎到文本编辑器，再到编程语言，它们被广泛应用于各种应用中。在Python中，正则表达式可以通过内置的<code class="fe lb lc ld le b"><strong class="kf ir"><em class="lf">re</em></strong></code> <strong class="kf ir"> <em class="lf"> </em> </strong>模块获得。</p><p id="3390" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该模块提供了许多用于处理正则表达式的<strong class="kf ir">函数</strong>和<strong class="kf ir">类</strong>。当与NLP管道结合时，它成为从文本中提取<strong class="kf ir">特征、字符串替换、</strong>和其他<strong class="kf ir">字符串操作</strong>的强大资产。在这里阅读官方文件<a class="ae lg" href="https://docs.python.org/3/howto/regex.html" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir"/></a>。</p><p id="e014" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这篇博文将解释正则表达式的基础知识以及如何在Python中使用它们。阅读完本文后，您将能够使用正则表达式来解决各种现实世界的问题。</p><h1 id="a918" class="lh li iq bd kc lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">正则表达式中的函数</h1><p id="89e6" class="pw-post-body-paragraph kd ke iq kf b kg me ki kj kk mf km kn ko mg kq kr ks mh ku kv kw mi ky kz la ij bi translated"><code class="fe lb lc ld le b"><strong class="kf ir">re</strong></code>模块提供了一系列函数，允许我们在字符串中搜索我们定义的模式，但是这里只包含最常用的函数。</p><pre class="mj mk ml mm gt mn le mo mp aw mq bi"><span id="991f" class="mr li iq le b gy ms mt l mu mv"><strong class="le ir">re.search(<em class="lf">pattern</em>, <em class="lf">string</em>):<br/></strong>Searches the string for a match, returns only the first occurrence of the match if there is a match None otherwise.</span><span id="3062" class="mr li iq le b gy mw mt l mu mv"><strong class="le ir">re.findall(</strong><strong class="le ir"><em class="lf">pattern</em>, <em class="lf">string</em></strong><strong class="le ir">):</strong><br/>Return a list of all non-overlapping matches in the string else <!-- -->None<!-- --> if no position in the string matches the pattern.</span><span id="d8ab" class="mr li iq le b gy mw mt l mu mv"><strong class="le ir">re.split(<em class="lf">pattern</em>, <em class="lf">string</em>):<br/></strong>It returns a list where the string has been split at each match.</span><span id="c121" class="mr li iq le b gy mw mt l mu mv"><strong class="le ir">re.sub(<em class="lf">pattern</em>, <em class="lf">replacement</em>, <em class="lf">string</em>):<br/></strong>This replaces the matches with the text of your choice.</span></pre><h2 id="1332" class="mr li iq bd kc mx my dn lm mz na dp lq ko nb nc lu ks nd ne ly kw nf ng mc nh bi translated"><strong class="ak"> 1。重新搜索(<em class="ni">模式</em>，<em class="ni">字符串</em> ) </strong></h2><p id="0ed0" class="pw-post-body-paragraph kd ke iq kf b kg me ki kj kk mf km kn ko mg kq kr ks mh ku kv kw mi ky kz la ij bi translated">它将寻找第一次出现的<strong class="kf ir">模式/正则表达式</strong>，并返回一个<strong class="kf ir">匹配对象</strong>，否则，它返回<strong class="kf ir"> "null" </strong>。它将验证目标字符串的所有行。</p><figure class="mj mk ml mm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nj"><img src="../Images/da21d2f36900db575c56f0168bda4254.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2qDBin7cMaiNcTj0A1tE8A.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><strong class="bd kc">搜索:作者图片</strong></figcaption></figure><h2 id="d3b8" class="mr li iq bd kc mx my dn lm mz na dp lq ko nb nc lu ks nd ne ly kw nf ng mc nh bi translated">2.re.findall(模式，字符串)</h2><p id="ae78" class="pw-post-body-paragraph kd ke iq kf b kg me ki kj kk mf km kn ko mg kq kr ks mh ku kv kw mi ky kz la ij bi translated">该函数用于寻找<strong class="kf ir"> "all" </strong>循环遍历目标字符串所有行的模式的可能非重叠外观。</p><figure class="mj mk ml mm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nj"><img src="../Images/9174059ba03a4a6a52cb53e6c56e4d61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*geHxl_edcT__2l6-oBbs5A.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><strong class="bd kc"> re.findall:作者图片</strong></figcaption></figure><h2 id="3939" class="mr li iq bd kc mx my dn lm mz na dp lq ko nb nc lu ks nd ne ly kw nf ng mc nh bi translated"><strong class="ak"> 3。re.split( <em class="ni">模式</em>、<em class="ni">字符串、</em>、</strong> maxsplit <strong class="ak"> ) </strong></h2><p id="0e9e" class="pw-post-body-paragraph kd ke iq kf b kg me ki kj kk mf km kn ko mg kq kr ks mh ku kv kw mi ky kz la ij bi translated">这个函数<strong class="kf ir">按照regex模式的出现次数分割字符串</strong>，从而返回一个包含<strong class="kf ir">结果子字符串</strong>的列表。Maxplit定义了您想要执行的分割数量。</p><figure class="mj mk ml mm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nk"><img src="../Images/ec159890b236075d5ac56a06367f814b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NyEHL-6bWmnUH-NUenasTw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><strong class="bd kc">重新分割:作者图片</strong></figcaption></figure><h2 id="a796" class="mr li iq bd kc mx my dn lm mz na dp lq ko nb nc lu ks nd ne ly kw nf ng mc nh bi translated">4.re.sub(模式、复制、字符串)</h2><p id="7b3a" class="pw-post-body-paragraph kd ke iq kf b kg me ki kj kk mf km kn ko mg kq kr ks mh ku kv kw mi ky kz la ij bi translated">该函数在字符串中搜索模式，并用替换符<code class="fe lb lc ld le b"><strong class="kf ir">repl</strong></code>替换匹配的字符串。</p><figure class="mj mk ml mm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nj"><img src="../Images/392ec78985e187e2125934fd90e289bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CpSI4oVhr4Ffr2wCsLVxzw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><strong class="bd kc">回复:作者图片</strong></figcaption></figure><h1 id="043a" class="lh li iq bd kc lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">正则表达式中的元字符</h1><p id="62b0" class="pw-post-body-paragraph kd ke iq kf b kg me ki kj kk mf km kn ko mg kq kr ks mh ku kv kw mi ky kz la ij bi translated">元字符是具有特殊含义的字符。元字符本身不匹配。相反，它们表明了一些规则。这些是我们将在这里讨论的元字符👇</p><pre class="mj mk ml mm gt mn le mo mp aw mq bi"><span id="f0c5" class="mr li iq le b gy ms mt l mu mv"><strong class="le ir">1. []</strong> - A set of characters class you wish to match. You can also specify a range of characters using <strong class="le ir">-</strong> inside square brackets.</span><span id="e97e" class="mr li iq le b gy mw mt l mu mv"><strong class="le ir">    - [abc]</strong> This will match(single character) any of the characters a, b or c this is the same as <strong class="le ir">[a-c]</strong>.</span><span id="740e" class="mr li iq le b gy mw mt l mu mv"><strong class="le ir">    - [1-4]</strong> is the same as <strong class="le ir">[1234]</strong><strong class="le ir">.</strong></span><span id="4b1d" class="mr li iq le b gy mw mt l mu mv"><strong class="le ir">   Note:</strong> <em class="lf">You can match the characters not listed within the class by complementing the set using </em><strong class="le ir"><em class="lf">^</em></strong><em class="lf"> as the first character of the class.</em></span><span id="b686" class="mr li iq le b gy mw mt l mu mv"><strong class="le ir">    - [^5]</strong> will match any character except <strong class="le ir">'5'</strong>.</span><span id="5d81" class="mr li iq le b gy mw mt l mu mv"><strong class="le ir">    - [5^]</strong> <!-- -->will match either a <strong class="le ir">'5' or a '^'</strong>.</span><span id="17c9" class="mr li iq le b gy mw mt l mu mv"><strong class="le ir">2. </strong><strong class="le ir">\</strong> <!-- -->- Signals a special sequence (can also be used to escape special characters). the backslash can be followed by various characters to signal various special sequences. It’s also used to escape all the metacharacters so you can still match them in patterns.</span><span id="b08e" class="mr li iq le b gy mw mt l mu mv"><strong class="le ir">3. </strong><strong class="le ir">.</strong> - Any character (except newline character).</span><span id="a51b" class="mr li iq le b gy mw mt l mu mv"><strong class="le ir">4. </strong><strong class="le ir">^</strong> - Starts with / matches the beginning of line.</span><span id="2e53" class="mr li iq le b gy mw mt l mu mv"><strong class="le ir">5. </strong><strong class="le ir">$</strong> - Ends with / matches the end of line.</span><span id="3d06" class="mr li iq le b gy mw mt l mu mv"><strong class="le ir">6. </strong><strong class="le ir">*</strong> - Zero or more occurrences of the pattern to its left(&gt;=0).</span><span id="7b18" class="mr li iq le b gy mw mt l mu mv"><strong class="le ir">7. </strong><strong class="le ir">+</strong> - One or more occurrences of the pattern to its left(&gt;=0).</span><span id="6424" class="mr li iq le b gy mw mt l mu mv"><strong class="le ir">8. </strong><strong class="le ir">?</strong> - Zero or one occurrences of the pattern to its left (0&gt;= &amp; &lt;=1).</span><span id="86c7" class="mr li iq le b gy mw mt l mu mv"><strong class="le ir">9. </strong><strong class="le ir">{}</strong> - Exactly the specified number of occurrences.</span><span id="6d9b" class="mr li iq le b gy mw mt l mu mv"><strong class="le ir">10. </strong><strong class="le ir">|</strong> - Either or.</span><span id="a7c4" class="mr li iq le b gy mw mt l mu mv"><strong class="le ir">11. () </strong>- To group sub-patterns.</span></pre><h2 id="48a1" class="mr li iq bd kc mx my dn lm mz na dp lq ko nb nc lu ks nd ne ly kw nf ng mc nh bi translated">贪婪模式:</h2><p id="2b81" class="pw-post-body-paragraph kd ke iq kf b kg me ki kj kk mf km kn ko mg kq kr ks mh ku kv kw mi ky kz la ij bi translated">在python正则表达式中，量词以贪婪模式工作。这意味着量词将尽可能地匹配它们前面的元素。首先，搜索找到模式最左边的匹配，其次，它试图用尽尽可能多的字符串，即<strong class="kf ir"> + </strong>和<strong class="kf ir"> * </strong>尽可能远。</p><figure class="mj mk ml mm gt jr"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="d67b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">'<strong class="kf ir">*</strong>'</code>、<code class="fe lb lc ld le b"><strong class="kf ir">'+</strong>'</code>、<code class="fe lb lc ld le b">'<strong class="kf ir">?</strong>'</code>限定符都是<em class="lf">贪心</em>；它们匹配尽可能多的文本。有时这种行为是不可取的；如果RE <code class="fe lb lc ld le b"><strong class="kf ir">&lt;.*&gt;</strong></code>与<code class="fe lb lc ld le b">'<strong class="kf ir">&lt;a&gt; b &lt;c&gt;</strong>'</code>匹配，它将匹配整个字符串，而不仅仅是<code class="fe lb lc ld le b"><strong class="kf ir">'&lt;a&gt;'</strong></code>。在限定符后添加<code class="fe lb lc ld le b"><strong class="kf ir">?</strong></code>使其以<strong class="kf ir"> <em class="lf">非贪婪</em> </strong>或<strong class="kf ir"> <em class="lf">最小</em> </strong>方式进行匹配；因为将匹配尽可能少的字符。使用正则表达式<code class="fe lb lc ld le b"><strong class="kf ir">&lt;.*?&gt;</strong></code>将只匹配<code class="fe lb lc ld le b">'<strong class="kf ir">&lt;a&gt;'</strong></code>。</p><h1 id="95a1" class="lh li iq bd kc lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">正则表达式中的特殊序列</h1><p id="0fb2" class="pw-post-body-paragraph kd ke iq kf b kg me ki kj kk mf km kn ko mg kq kr ks mh ku kv kw mi ky kz la ij bi translated">正则表达式的强大之处在于它们可以指定模式，而不仅仅是固定的字符。以下是匹配单个字符的最基本模式。</p><pre class="mj mk ml mm gt mn le mo mp aw mq bi"><span id="3544" class="mr li iq le b gy ms mt l mu mv"><strong class="le ir">\d </strong>- Matches any decimal digit; this is equivalent to the class <strong class="le ir">[0-9]</strong>.</span><span id="f911" class="mr li iq le b gy mw mt l mu mv"><strong class="le ir">\D </strong>- Matches any non-digit character; this is equivalent to the class <strong class="le ir">[^0-9]</strong>.</span><span id="8c68" class="mr li iq le b gy mw mt l mu mv"><strong class="le ir">\w</strong> - Matches any alphanumeric character; this is equivalent to the class <strong class="le ir">[a-zA-Z0-9_]</strong>.</span><span id="9926" class="mr li iq le b gy mw mt l mu mv"><strong class="le ir">\W - </strong>Matches any non-alphanumeric character; this is equivalent to the class <strong class="le ir">[^a-zA-Z0-9_]</strong>.</span><span id="1109" class="mr li iq le b gy mw mt l mu mv"><strong class="le ir">\s -</strong> Matches any whitespace character; this is equivalent to the class <strong class="le ir">[\t\n\r\f\v]</strong>.</span><span id="0933" class="mr li iq le b gy mw mt l mu mv"><strong class="le ir">\S - </strong>Matches any non-whitespace character; this is equivalent to the class <strong class="le ir">[^ \t\n\r\f\v]</strong>.</span><span id="ecf2" class="mr li iq le b gy mw mt l mu mv"><strong class="le ir">\Z -</strong> Returns a match if the specified characters are at the end of the string.</span></pre><p id="d468" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正则表达式可以串联起来形成新的正则表达式；如果<strong class="kf ir"> <em class="lf"> A </em> </strong>和<strong class="kf ir"> <em class="lf"> B </em> </strong>都是正则表达式，那么<strong class="kf ir"> <em class="lf"> AB </em> </strong>也是正则表达式。一般情况下，如果一串<em class="lf"> p </em>匹配<strong class="kf ir"> <em class="lf"> A </em> </strong>而另一串<em class="lf"> q </em>匹配<strong class="kf ir"> <em class="lf"> B </em> </strong>，则该串<em class="lf"> pq </em>会匹配<strong class="kf ir"> AB </strong>。</p><p id="a5fa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们通过一些例子来测试我们的概念:</p><h2 id="c65d" class="mr li iq bd kc mx my dn lm mz na dp lq ko nb nc lu ks nd ne ly kw nf ng mc nh bi translated">1.从文本中抓取数字</h2><figure class="mj mk ml mm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nn"><img src="../Images/a18b86c3fa1910048689cebf4ceab8f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wi0fTORZh4fkjZqmkrumkw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><strong class="bd kc">示例:作者图片</strong></figcaption></figure><p id="2cec" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它生成以下输出👇</p><pre class="mj mk ml mm gt mn le mo mp aw mq bi"><span id="3130" class="mr li iq le b gy ms mt l mu mv"><strong class="le ir">['3', '10', '7', '6', '2022']</strong></span></pre><h2 id="4fb0" class="mr li iq bd kc mx my dn lm mz na dp lq ko nb nc lu ks nd ne ly kw nf ng mc nh bi translated">2.抓取电话号码(美国国内格式XXX-XXX-XXXX)</h2><figure class="mj mk ml mm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi no"><img src="../Images/fd8f22afe445d1833a24637bbe4e65f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O4mjcafztavCXOvFLCCtCA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><strong class="bd kc">示例:作者图片</strong></figcaption></figure><p id="44fa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这三种方法返回相同的输出，但是您认为哪种方法是三种方法中最好的呢？当你知道你在寻找什么的时候，最好的做法是定义完全相同的模式，这样你就可以更好地控制它。在这里，<strong class="kf ir">模式&amp;模式1 </strong>比<strong class="kf ir">模式2 </strong>给你更多的控制，因为由于它贪婪的本性，它可以获取比3更多的数字。</p><pre class="mj mk ml mm gt mn le mo mp aw mq bi"><span id="f3e2" class="mr li iq le b gy ms mt l mu mv"><strong class="le ir">['123-456-7890']<br/>['123-456-7890']<br/>['123-456-7890']</strong></span></pre><p id="df12" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就是正则表达式的美妙之处，做一件事有很多方法。你只需要想想🧠！！！</p><figure class="mj mk ml mm gt jr"><div class="bz fp l di"><div class="np nm l"/></div></figure><h2 id="a41d" class="mr li iq bd kc mx my dn lm mz na dp lq ko nb nc lu ks nd ne ly kw nf ng mc nh bi translated">3.从文本中抓取电子邮件</h2><p id="4297" class="pw-post-body-paragraph kd ke iq kf b kg me ki kj kk mf km kn ko mg kq kr ks mh ku kv kw mi ky kz la ij bi translated">让我们在这里生成一些真正真实的电子邮件👻</p><pre class="mj mk ml mm gt mn le mo mp aw mq bi"><span id="8f21" class="mr li iq le b gy ms mt l mu mv"><strong class="le ir">Optimus_prime@gmail.com<br/>Harry.Potter@hogwarts.ac.in<br/>Bond_007@bond.net<br/>temp1234@fake.in<br/>temp-1234@fake.in</strong></span></pre><p id="b57b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的直觉会是👉一些字符(一个或多个)，接着是<strong class="kf ir"> @ </strong>然后是一些域，&amp;我们最终会生成这样的东西👇</p><pre class="mj mk ml mm gt mn le mo mp aw mq bi"><span id="9500" class="mr li iq le b gy ms mt l mu mv"><strong class="le ir">‘</strong><strong class="le ir">\w+@\w+.\w+’</strong></span></pre><p id="07cd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这能行吗？如上所述，<code class="fe lb lc ld le b"><strong class="kf ir">\w</strong></code>抓取字母数字字符，因此它将无法检测任何<code class="fe lb lc ld le b"><strong class="kf ir">‘-’</strong></code> <strong class="kf ir"> </strong>或<code class="fe lb lc ld le b">‘<strong class="kf ir">.’</strong></code></p><pre class="mj mk ml mm gt mn le mo mp aw mq bi"><span id="51ea" class="mr li iq le b gy ms mt l mu mv"><strong class="le ir">['Optimus_prime@gmail.com', <br/> 'Potter@hogwarts.ac', <br/> 'Bond_007@bond.net', <br/> 'temp1234@fake.in', <br/> '1234@fake.in']</strong></span></pre><p id="73e5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，让我们定制我们的模式，以便它获取完整的电子邮件地址</p><figure class="mj mk ml mm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nq"><img src="../Images/8a04f9214b27db15ea694c63221da6ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B8y3ybloanY4CbfQ6VlgTA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><strong class="bd kc">示例:作者图片</strong></figcaption></figure><p id="2bff" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们得到以下结果:</p><pre class="mj mk ml mm gt mn le mo mp aw mq bi"><span id="4b49" class="mr li iq le b gy ms mt l mu mv"><strong class="le ir">['Optimus_prime@gmail.com', 'Harry.Potter@hogwarts.ac.in', 'Bond_007@bond.net', 'temp1234@fake.in', 'temp-1234@fake.in']</strong></span></pre><p id="4177" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些是在处理NLP问题时非常基本但非常常用的概念。为了找到一个模式，可以有多个正则表达式，还有更多。我们只是触及了它的表面。</p><p id="3398" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以在这里查看RegEx存储库，我将在这里用更多的例子更新笔记本。</p><p id="9212" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">恭喜👏！！！现在我们知道了一些关于正则表达式的东西&amp;我希望这个表达式会非常有用😝。</p><p id="6577" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我将尝试提出更多的机器学习/数据科学概念，并将尝试将听起来花哨的术语和概念分解成更简单的术语和概念。</p><p id="a0c1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我希望你喜欢这篇文章！您可以<strong class="kf ir">关注我</strong> <a class="ae lg" href="https://medium.com/u/430bc504f9d9?source=post_page-----ffbeb5f76a92--------------------------------" rel="noopener"> Afaque Umer </a>获取更多<strong class="kf ir">此类文章。</strong></p><figure class="mj mk ml mm gt jr"><div class="bz fp l di"><div class="nr nm l"/></div></figure><h2 id="595e" class="mr li iq bd kc mx my dn lm mz na dp lq ko nb nc lu ks nd ne ly kw nf ng mc nh bi translated">感谢阅读🙏</h2><h2 id="a424" class="mr li iq bd kc mx my dn lm mz na dp lq ko nb nc lu ks nd ne ly kw nf ng mc nh bi translated">继续学习🧠继续分享🤝保持敬畏🤘</h2></div></div>    
</body>
</html>