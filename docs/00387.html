<html>
<head>
<title>Let’s build a functional, reusable Modal component in React with Portals</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们在React with Portals中构建一个功能性的、可重用的模态组件</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/lets-build-a-functional-reusable-modal-component-in-react-with-portals-edff0b8d4bf7?source=collection_archive---------0-----------------------#2019-02-01">https://levelup.gitconnected.com/lets-build-a-functional-reusable-modal-component-in-react-with-portals-edff0b8d4bf7?source=collection_archive---------0-----------------------#2019-02-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/633c3cb0ba54ff13f1e06e86da31c559.png" data-original-src="https://miro.medium.com/v2/resize:fit:654/format:webp/1*At5nA4HBuYG-_bzkzhAZgw.jpeg"/></div></figure><p id="04b8" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">模态已经成为跨所有设备的应用程序的组成部分，但是它们的实现有很大的不同。我认为，普遍的看法是，它需要一点CSS魔法(与z-index或其他东西有关，对吗？？)，但是我想出了一个在我的几个项目中非常成功地为我工作的方法，我想与你分享它(当然，它确实使用了一点CSS魔法)。</p><p id="7673" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如标题所示，不会涉及基于类的组件，因为我是React钩子的狂热粉丝(如果你不了解钩子，可以看看我的其他帖子或者参考<a class="ae ks" href="https://reactjs.org/docs/hooks-intro.html" rel="noopener ugc nofollow" target="_blank"> React文档</a>来了解更多关于它们的信息)。所以让我们开始吧。在设计React时，我们将使用我最喜欢的库。</p><p id="16a6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为了简单起见，我将在用<code class="fe kt ku kv kw b">create-react-app</code>构建的React应用程序的上下文中解释这种类型组件的用例。在你的公共目录中(你可能很少冒险)，在<code class="fe kt ku kv kw b">index.html</code>里面为我们即将出现的模态组件添加一个定位点，就在我们应用程序的下面。</p><pre class="kx ky kz la gt lb kw lc ld aw le bi"><span id="dc83" class="lf lg iq kw b gy lh li l lj lk">...</span><span id="9fba" class="lf lg iq kw b gy ll li l lj lk">&lt;div id="root"&gt;&lt;/div&gt;<br/>&lt;div id="modal"&gt;&lt;/div&gt;</span><span id="6436" class="lf lg iq kw b gy ll li l lj lk">...</span></pre><p id="a886" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">就是这样！这就是全部了。开玩笑的。回到我们的<code class="fe kt ku kv kw b">src</code>目录，让我们在<code class="fe kt ku kv kw b">src/Modal.js</code>中创建我们的模态组件:</p><pre class="kx ky kz la gt lb kw lc ld aw le bi"><span id="eae4" class="lf lg iq kw b gy lh li l lj lk">import React, { useEffect } from "react";<br/>import { createPortal } from "react-dom";<br/>import styled from "styled-components";<br/>import PropTypes from "prop-types"; </span><span id="53c4" class="lf lg iq kw b gy ll li l lj lk">const Portal = ({ children }) =&gt; {  <br/> const modalRoot = document.getElementById("modal");<br/> const el = document.createElement("div");<br/>  <br/> useEffect(() =&gt; {    <br/>  modalRoot.appendChild(el);  <br/> }, []);   </span><span id="4c96" class="lf lg iq kw b gy ll li l lj lk"> useEffect(() =&gt; {    <br/>  return () =&gt; modalRoot.removeChild(el); <br/> });   </span><span id="0f8e" class="lf lg iq kw b gy ll li l lj lk">return createPortal(children, el);</span><span id="ceec" class="lf lg iq kw b gy ll li l lj lk">};</span><span id="1402" class="lf lg iq kw b gy ll li l lj lk">const Modal = ({ children, toggle, open }) =&gt; (  <br/> &lt;Portal&gt;    <br/>  {open &amp;&amp; (      <br/>   &lt;ModalWrapper&gt;       <br/>    &lt;ModalCard&gt;          <br/>     &lt;CloseButton onClick={toggle}&gt;            <br/>      &lt;img src="https:icon.now.sh/x/ff0000" alt="close" /<br/>     &lt;/CloseButton&gt;<br/>      {children}<br/>    &lt;/ModalCard&gt;<br/>    &lt;Background onClick={toggle} /&gt;      <br/>   &lt;/ModalWrapper&gt;    <br/>  )}  <br/> &lt;/Portal&gt;<br/>); </span><span id="bc73" class="lf lg iq kw b gy ll li l lj lk">export default Modal; </span><span id="1661" class="lf lg iq kw b gy ll li l lj lk">Modal.propTypes = {  <br/> children: PropTypes.arrayOf(PropTypes.object).isRequired,<br/> toggle: PropTypes.func.isRequired,<br/> on: PropTypes.bool.isRequired<br/>}; </span><span id="2af0" class="lf lg iq kw b gy ll li l lj lk">const ModalWrapper = styled.div`<br/>  position: fixed;  top: 50%;<br/>  left: 50%;<br/>  transform: translate(-50%, -50%);<br/>  width: 100%;  height: 100%;<br/>  display: flex;<br/>  justify-content: center;<br/>  align-items: center;<br/>`;</span><span id="1d39" class="lf lg iq kw b gy ll li l lj lk">const ModalCard = styled.div`<br/>  position: relative;<br/>  min-width: 320px;<br/>  z-index: 10;<br/>  margin-bottom: 100px;<br/>  background: white;<br/>  border-radius: 5px;<br/>  padding: 15px;<br/>  box-shadow: 2px 2px 10px rgba(0, 0, 0, 0.3);<br/>`; </span><span id="dc59" class="lf lg iq kw b gy ll li l lj lk">const CloseButton = styled.button`<br/>  position: absolute;<br/>  top: 0;<br/>  right: 0;<br/>  border: none;<br/>  background: transparent;<br/>  padding: 10px;<br/>  &amp;:hover {    <br/>    cursor: pointer;<br/>  }`; </span><span id="7d81" class="lf lg iq kw b gy ll li l lj lk">const Background = styled.div`<br/>  position: absolute;<br/>  width: 100%;<br/>  height: 100%;<br/>  top: 0;<br/>  left: 0;<br/>  background: black;<br/>  opacity: 0.5;<br/>`;</span></pre><p id="f1f5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">哇哦。这看起来像一堆废话。真的不是，我们来解剖一下。首先，注意这是二合一的组件。我完全支持将组件分离到它们各自的文件中，但是我用<code class="fe kt ku kv kw b">React.createPortal</code>创建的门户(我们稍后会讲到)是专门为前面的模态组件设计的。我觉得让他们生活在同一个文件中似乎没什么问题。</p><p id="1847" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">对于那些不熟悉<code class="fe kt ku kv kw b">styled-components</code>的人来说，在模型的道具类型下面定义的所有东西都是样式化的组件，这保证了它们自己的位置(而且非常棒)。</p><p id="250a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">那么React中的“<em class="lm">门户</em>”是什么呢？嗯，根据<a class="ae ks" href="https://reactjs.org/docs/portals.html" rel="noopener ugc nofollow" target="_blank">反应文件</a>:</p><p id="66f0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">"<em class="lm">门户提供了一种一流的方式来将子组件呈现到存在于父组件的DOM层次结构之外的DOM节点中。</em>"我还将引用<a class="ae ks" href="https://medium.com/@siobhanpmahoney" rel="noopener"> Siobhan Mahoney </a>的话，她在题为" React.js 中的<a class="ae ks" href="https://medium.com/@siobhanpmahoney/portals-in-react-js-5d98bb89797c" rel="noopener">门户"的文章中很好地解释了这一点，"<em class="lm">门户可用于在父组件的DOM节点之外呈现元素，同时保留它在React层次结构中的位置，允许它保留它从React树继承的属性和行为。</em></a></p><p id="e3ff" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我宁愿引用别人的话也不愿意自己解释，因为，完全透明，我喜欢用门户不代表我完全理解！</p><p id="b0e9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">好了，现在我们对React中的门户有了一个大致的了解，让我们浏览一下上面定义的<code class="fe kt ku kv kw b">Portal</code>组件。注意我是如何从props中析构<code class="fe kt ku kv kw b">children</code>的，然后把它作为第一个参数传递给<code class="fe kt ku kv kw b">React.createPortal</code>。再次引用React文档，"第一个参数是任何 <a class="ae ks" href="https://reactjs.org/docs/react-component.html#render" rel="noopener ugc nofollow" target="_blank"> <em class="lm">可呈现的React子级</em> </a> <em class="lm">，比如元素、字符串或片段。第二个参数是一个DOM元素[充当React子元素的容器] </em>。这个“容器”是在<code class="fe kt ku kv kw b">Portal</code>组件的顶部创建的，就在我们之前在<code class="fe kt ku kv kw b">index.html</code>建立的定位点之后。</p><p id="112a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在第一个<code class="fe kt ku kv kw b">useEffect</code>钩子(相当于基于类的React中的<code class="fe kt ku kv kw b">componentDidMount</code>生命周期方法)中，我们挂载了容器元素。在第二个<code class="fe kt ku kv kw b">useEffect</code>中，类似于<code class="fe kt ku kv kw b">componentWillUnmount</code>，我们本质上是在自己之后下马或清理。</p><p id="c25f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在事情变得有趣了。让我们浏览一下<code class="fe kt ku kv kw b">Modal</code>组件，它利用了我们新创建的React门户。注意这个组件是如何利用<code class="fe kt ku kv kw b">toggle</code>和<code class="fe kt ku kv kw b">on</code>属性的，前者用于切换模态的可见性，后者作为布尔属性来决定模态是“开”还是“关”(“开”或类似的效果也可以，命名是任意的)。在这个<code class="fe kt ku kv kw b">Modal</code>组件中，我们渲染了之前定义的<code class="fe kt ku kv kw b">Portal</code>组件，利用我们花哨的样式化组件使其看起来更漂亮。本质上，这个组件所做的就是将<code class="fe kt ku kv kw b">children</code>传递给React门户的实例。它的用户界面看起来像这样(来自我以前制作的一个联系人应用程序):</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="gh gi ln"><img src="../Images/98762c90df6a7a704c3fd4a2b0941689.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7hMgQLjGak0APHtnA_uRiQ.png"/></div></div></figure><p id="0687" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">右上角的关闭按钮，以及更粗的红色X都使用了<code class="fe kt ku kv kw b">toggle</code>处理程序来关闭模态，并且您可以根据您的用例在模态中连接您想要的任何其他点击处理程序。我不会深入讨论样式化组件所涉及的CSS，因为，首先，它很无聊，其次，它是你可以编写(或复制)一次就再也不用处理的东西。</p><p id="39ad" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我经常结合这个<code class="fe kt ku kv kw b">Modal</code>组件使用的一个React钩子是我写的一个自定义的<code class="fe kt ku kv kw b">useToggle</code>钩子，我在<a class="ae ks" rel="noopener ugc nofollow" target="_blank" href="/two-simple-reusable-custom-hooks-for-your-react-apps-a0275724f8ab">之前的一篇文章</a>中详细讨论过。总的来说，这些组件中的每一个都提供了一个真正可重用的，而且我敢说看起来相当漂亮的模态体验，供您在React应用程序中使用！我希望这对你有用，因为我每次需要模型的时候都会用到它。</p><p id="75e5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">感谢您的倾听。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><figure class="kx ky kz la gt jr gh gi paragraph-image"><a href="https://levelup.gitconnected.com"><div class="gh gi lz"><img src="../Images/9914c5dd23ac08b70eea6f4f9ba6fed2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E6CoI_MRyZ1JInNPsBSHtA.png"/></div></a></figure><div class="ma mb gp gr mc md"><a href="https://gitconnected.com/learn/react" rel="noopener  ugc nofollow" target="_blank"><div class="me ab fo"><div class="mf ab mg cl cj mh"><h2 class="bd ir gy z fp mi fr fs mj fu fw ip bi translated">学习React -最佳React教程(2019) | gitconnected</h2><div class="mk l"><h3 class="bd b gy z fp mi fr fs mj fu fw dk translated">排名前49的React教程-免费学习React。课程由开发人员提交并投票，使您能够…</h3></div><div class="ml l"><p class="bd b dl z fp mi fr fs mj fu fw dk translated">gitconnected.com</p></div></div><div class="mm l"><div class="mn l mo mp mq mm mr js md"/></div></div></a></div></div></div>    
</body>
</html>