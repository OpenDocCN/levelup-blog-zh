<html>
<head>
<title>How to deal with asynchronous code in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何处理JavaScript中的异步代码</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-deal-with-asynchronous-code-in-javascript-e9f437b46832?source=collection_archive---------0-----------------------#2019-05-01">https://levelup.gitconnected.com/how-to-deal-with-asynchronous-code-in-javascript-e9f437b46832?source=collection_archive---------0-----------------------#2019-05-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><blockquote class="jq"><p id="6a2e" class="jr js it bd jt ju jv jw jx jy jz ka dk translated">JavaScript默认为<strong class="ak"> <em class="kb">同步</em> </strong>并且是单线程的。<br/>这意味着代码不能创建新的线程，它会在<strong class="ak"> <em class="kb">提升</em> </strong>之后按顺序执行你的代码块。</p></blockquote><p id="fe4e" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky ka im bi translated">像C、Java、C#、PHP、Go、Ruby、Swift和Python这样的编程语言在默认情况下都是同步的，其中一些语言通过使用线程和产生新的进程来处理异步。</p><p id="9c8a" class="pw-post-body-paragraph kc kd it ke b kf kz kh ki kj la kl km kn lb kp kq kr lc kt ku kv ld kx ky ka im bi translated">这是一个同步代码的例子</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="6de9" class="ln lo it lj b gy lp lq l lr ls">const a = 1;<br/>console.log(a + 1);<br/>console.log('3');<br/>handleSomething();</span></pre><p id="2725" class="pw-post-body-paragraph kc kd it ke b kf kz kh ki kj la kl km kn lb kp kq kr lc kt ku kv ld kx ky ka im bi translated">一行行代码被一个接一个地连续执行。</p><p id="540c" class="pw-post-body-paragraph kc kd it ke b kf kz kh ki kj la kl km kn lb kp kq kr lc kt ku kv ld kx ky ka im bi translated">由于JavaScript诞生于浏览器内部，它的主要工作，在开始时，是响应用户的动作，如<code class="fe lt lu lv lj b">onClick</code>、<code class="fe lt lu lv lj b">onMouseOver</code>、<code class="fe lt lu lv lj b">onChange</code>、<code class="fe lt lu lv lj b">onSubmit</code>等等。它如何用同步编程模型做到这一点呢？</p><p id="b170" class="pw-post-body-paragraph kc kd it ke b kf kz kh ki kj la kl km kn lb kp kq kr lc kt ku kv ld kx ky ka im bi translated">在某些情况下，例如当你想从一个服务器获取一些数据时(这可能需要一段未知的时间),如果你的程序在等待获取数据时完全冻结，效率会非常低。因此，通常不这样做，而是在后台运行获取任务。<br/>这意味着如果一行中有两个函数，而函数A是<strong class="ke iu"> <em class="lw">异步的</em> </strong>，那么函数B将在函数A仍在运行时执行。在这种情况下，如果函数B依赖于函数A获取的数据，你就会遇到问题。</p><blockquote class="jq"><p id="21c2" class="jr js it bd jt ju lx ly lz ma mb ka dk translated">异步意味着事情可以独立于主程序流发生。</p></blockquote><h1 id="3717" class="mc lo it bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">复试</h1><p id="be3c" class="pw-post-body-paragraph kc kd it ke b kf mz kh ki kj na kl km kn nb kp kq kr nc kt ku kv nd kx ky ka im bi translated">这个问题用<strong class="ke iu"> <em class="lw">回调</em> </strong>解决了。</p><p id="64ec" class="pw-post-body-paragraph kc kd it ke b kf kz kh ki kj la kl km kn lb kp kq kr lc kt ku kv ld kx ky ka im bi translated">回调是一个简单的函数，作为一个值传递给另一个函数，只在事件发生时执行。有了回调，你可以保证函数B只在函数A完成它的任务后被调用，因为函数A实际上是负责调用函数B的人。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="7c83" class="ln lo it lj b gy lp lq l lr ls">// doSomething =&gt; functionA<br/>// callback =&gt; functionB</span><span id="179b" class="ln lo it lj b gy ne lq l lr ls">function doSomething (options, callback) {<br/>    callback (options);<br/>}</span><span id="35e2" class="ln lo it lj b gy ne lq l lr ls">doSomething<!-- -->(options, <!-- -->callback<!-- -->);</span></pre><p id="fdbe" class="pw-post-body-paragraph kc kd it ke b kf kz kh ki kj la kl km kn lb kp kq kr lc kt ku kv ld kx ky ka im bi translated">回调对于简单的情况很有用，但是每个回调都会增加一层嵌套，当你有很多回调的时候，代码会很快变得复杂。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="f2c0" class="ln lo it lj b gy lp lq l lr ls">window.addEventListener('load', () =&gt; {<br/>  document.getElementById('button').addEventListener('click', () =&gt; {<br/>    setTimeout(() =&gt; {<br/>      items.forEach(item =&gt; {<br/>        //your code here<br/>      })<br/>    }, 2000)<br/>  })<br/>})</span></pre><p id="8e8a" class="pw-post-body-paragraph kc kd it ke b kf kz kh ki kj la kl km kn lb kp kq kr lc kt ku kv ld kx ky ka im bi translated">这只是一个简单的4层代码，但是你已经看到了更多的嵌套层，这并不有趣。</p><blockquote class="nf ng nh"><p id="ee68" class="kc kd lw ke b kf kz kh ki kj la kl km ni lb kp kq nj lc kt ku nk ld kx ky ka im bi translated"><strong class="ke iu"> <em class="it">从ES6 </em> </strong>开始，JavaScript引入了几个特性来帮助我们处理不涉及回调的异步代码:</p></blockquote><h1 id="7b23" class="mc lo it bd md me mf mg mh mi mj mk ml mm nl mo mp mq nm ms mt mu nn mw mx my bi translated">承诺</h1><p id="a1f8" class="pw-post-body-paragraph kc kd it ke b kf mz kh ki kj na kl km kn nb kp kq kr nc kt ku kv nd kx ky ka im bi translated"><strong class="ke iu"> <em class="lw">承诺</em> </strong>是处理回调困境和防止在代码中编写过多回调的一种方法。</p><p id="2aa0" class="pw-post-body-paragraph kc kd it ke b kf kz kh ki kj la kl km kn lb kp kq kr lc kt ku kv ld kx ky ka im bi translated">一旦承诺被调用，它将从<strong class="ke iu">未决状态</strong>开始。这意味着调用者函数继续执行，同时等待承诺进行自己的处理，并给调用者函数一些反馈。</p><p id="3abf" class="pw-post-body-paragraph kc kd it ke b kf kz kh ki kj la kl km kn lb kp kq kr lc kt ku kv ld kx ky ka im bi translated">此时，调用者函数等待它返回处于<strong class="ke iu">已解决状态</strong>或<strong class="ke iu">已拒绝状态</strong>的承诺，但是<em class="lw">函数继续执行，同时承诺工作</em>。</p><p id="ffa4" class="pw-post-body-paragraph kc kd it ke b kf kz kh ki kj la kl km kn lb kp kq kr lc kt ku kv ld kx ky ka im bi translated">promise对象的构造函数语法是:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="6f61" class="ln lo it lj b gy lp lq l lr ls">let promise = new Promise(function(resolve, reject) {<br/>  // executor (the producing code, "singer")<br/>});</span></pre><p id="40fa" class="pw-post-body-paragraph kc kd it ke b kf kz kh ki kj la kl km kn lb kp kq kr lc kt ku kv ld kx ky ka im bi translated">产生的<code class="fe lt lu lv lj b">promise</code>对象具有内部属性:</p><ul class=""><li id="d908" class="no np it ke b kf kz kj la kn nq kr nr kv ns ka nt nu nv nw bi translated"><code class="fe lt lu lv lj b">state</code> —最初为“待定”，然后变为“已履行”或“已拒绝”，</li><li id="cd01" class="no np it ke b kf nx kj ny kn nz kr oa kv ob ka nt nu nv nw bi translated"><code class="fe lt lu lv lj b">result</code> —您选择的任意值，最初为<code class="fe lt lu lv lj b">undefined</code>。</li></ul><p id="b3e9" class="pw-post-body-paragraph kc kd it ke b kf kz kh ki kj la kl km kn lb kp kq kr lc kt ku kv ld kx ky ka im bi translated">当执行程序完成作业时，它应该调用一个作为参数获得的函数:</p><ul class=""><li id="4e5a" class="no np it ke b kf kz kj la kn nq kr nr kv ns ka nt nu nv nw bi translated"><code class="fe lt lu lv lj b">resolve(value)</code> —表示作业成功完成:</li><li id="f45f" class="no np it ke b kf nx kj ny kn nz kr oa kv ob ka nt nu nv nw bi translated">将<code class="fe lt lu lv lj b">state</code>设置为<code class="fe lt lu lv lj b">"fulfilled"</code>，</li><li id="c8fb" class="no np it ke b kf nx kj ny kn nz kr oa kv ob ka nt nu nv nw bi translated">将<code class="fe lt lu lv lj b">result</code>设置为<code class="fe lt lu lv lj b">value</code>。</li><li id="fe72" class="no np it ke b kf nx kj ny kn nz kr oa kv ob ka nt nu nv nw bi translated"><code class="fe lt lu lv lj b">reject(error)</code> —表示发生了错误:</li><li id="a95f" class="no np it ke b kf nx kj ny kn nz kr oa kv ob ka nt nu nv nw bi translated">将<code class="fe lt lu lv lj b">state</code>设置为<code class="fe lt lu lv lj b">"rejected"</code>，</li><li id="0ddc" class="no np it ke b kf nx kj ny kn nz kr oa kv ob ka nt nu nv nw bi translated">将<code class="fe lt lu lv lj b">result</code>设置为<code class="fe lt lu lv lj b">error</code>。</li></ul><figure class="le lf lg lh gt od gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/1a9d96672bb3c7517fd0c2a5d6f0549b.png" data-original-src="https://miro.medium.com/v2/resize:fit:968/format:webp/1*HLqQgC-xODR5xCJlPxt3jg.png"/></div></figure><blockquote class="nf ng nh"><p id="3d5b" class="kc kd lw ke b kf kz kh ki kj la kl km ni lb kp kq nj lc kt ku nk ld kx ky ka im bi translated"><code class="fe lt lu lv lj b"><strong class="ke iu">resolve</strong></code>和<code class="fe lt lu lv lj b"><strong class="ke iu">reject</strong></code> —这些函数由JavaScript引擎预定义。所以我们不需要创建它们。相反，我们应该编写执行程序在准备好的时候调用它们。</p></blockquote><p id="4ac8" class="pw-post-body-paragraph kc kd it ke b kf kz kh ki kj la kl km kn lb kp kq kr lc kt ku kv ld kx ky ka im bi translated">下面是一个Promise构造函数和一个简单的executor函数的例子:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="fd7d" class="ln lo it lj b gy lp lq l lr ls">let promise = new Promise(function(resolve, reject) {<br/>  // the function is executed automatically when the promise is constructed<br/><br/>  // after 1 second signal that the job is done with the result "done"<br/>  setTimeout(() =&gt; resolve("done"), 1000);<br/>});</span></pre><p id="b9ec" class="pw-post-body-paragraph kc kd it ke b kf kz kh ki kj la kl km kn lb kp kq kr lc kt ku kv ld kx ky ka im bi translated">“处理”一秒钟后，执行者调用<code class="fe lt lu lv lj b">resolve("done")</code>产生结果:</p><figure class="le lf lg lh gt od gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/b67fdf7b89feacf79980f9bcd399e9c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:968/format:webp/1*AB5voEjzd3OEB7-yH1ORbA.png"/></div></figure><p id="da07" class="pw-post-body-paragraph kc kd it ke b kf kz kh ki kj la kl km kn lb kp kq kr lc kt ku kv ld kx ky ka im bi translated">这是一个成功完成工作的例子，一个“实现的承诺”。现在让我们看一个执行者错误地拒绝承诺的例子:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="4260" class="ln lo it lj b gy lp lq l lr ls">let promise = new Promise(function(resolve, reject) {<br/>  // after 1 second signal that the job is finished with an error<br/>  setTimeout(() =&gt; reject(new Error("Whoops!")), 1000);<br/>});</span></pre><p id="2ad5" class="pw-post-body-paragraph kc kd it ke b kf kz kh ki kj la kl km kn lb kp kq kr lc kt ku kv ld kx ky ka im bi translated">执行人要做一些通常需要时间的事情然后调用<code class="fe lt lu lv lj b">resolve</code>或者<code class="fe lt lu lv lj b">reject</code>来改变对应的承诺对象的状态。</p><blockquote class="nf ng nh"><p id="fa09" class="kc kd lw ke b kf kz kh ki kj la kl km ni lb kp kq nj lc kt ku nk ld kx ky ka im bi translated">许诺可以<strong class="ke iu"> <em class="it">消耗</em> </strong>或者使用。</p></blockquote><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="1889" class="ln lo it lj b gy lp lq l lr ls">const doSomething = new Promise()<br/>//...<br/><br/>const checkIfItsDone = () =&gt; {<br/>  doSomething<br/>    .then(ok =&gt; {<br/>      console.log(ok)<br/>    })<br/>    .catch(err =&gt; {<br/>      console.error(err)<br/>    })<br/>}</span></pre><p id="33f4" class="pw-post-body-paragraph kc kd it ke b kf kz kh ki kj la kl km kn lb kp kq kr lc kt ku kv ld kx ky ka im bi translated">运行<code class="fe lt lu lv lj b">checkIfItsDone()</code>将执行<code class="fe lt lu lv lj b">doSomething()</code>承诺，并等待它解决，使用<code class="fe lt lu lv lj b">then</code>回调，如果有错误，它将在<code class="fe lt lu lv lj b">catch </code>回调中处理它。</p><blockquote class="nf ng nh"><p id="4f17" class="kc kd lw ke b kf kz kh ki kj la kl km ni lb kp kq nj lc kt ku nk ld kx ky ka im bi translated">承诺的引入是为了解决著名的<em class="it">回调困境</em>，但是它们本身引入了复杂性和语法复杂性。</p></blockquote><h1 id="7923" class="mc lo it bd md me mf mg mh mi mj mk ml mm nl mo mp mq nm ms mt mu nn mw mx my bi translated">异步/等待</h1><p id="ffcc" class="pw-post-body-paragraph kc kd it ke b kf mz kh ki kj na kl km kn nb kp kq kr nc kt ku kv nd kx ky ka im bi translated">由于ES2017异步JavaScript使用了async/await语法，因此更加简单。</p><h2 id="b0a9" class="ln lo it bd md og oh dn mh oi oj dp ml kn ok ol mp kr om on mt kv oo op mx oq bi translated">异步函数</h2><p id="3abd" class="pw-post-body-paragraph kc kd it ke b kf mz kh ki kj na kl km kn nb kp kq kr nc kt ku kv nd kx ky ka im bi translated">以一种更舒适的方式，他们减少了承诺周围的样板文件，以及链接承诺的“不要打破链条”的限制。它非常容易理解和使用。</p><p id="d857" class="pw-post-body-paragraph kc kd it ke b kf kz kh ki kj la kl km kn lb kp kq kr lc kt ku kv ld kx ky ka im bi translated"><code class="fe lt lu lv lj b">async</code>关键字放在函数之前，关键字<code class="fe lt lu lv lj b">await</code>让JavaScript等待，直到承诺完成并返回结果。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="5290" class="ln lo it lj b gy lp lq l lr ls">async function f() {<br/><br/>  let promise = new Promise((resolve, reject) =&gt; {<br/>    setTimeout(() =&gt; resolve("done!"), 1000)<br/>  });<br/><br/>  let result = await promise; // wait till the promise resolves (*)<br/><br/>  alert(result); // "done!"<br/>}<br/><br/>f();</span></pre><p id="d91b" class="pw-post-body-paragraph kc kd it ke b kf kz kh ki kj la kl km kn lb kp kq kr lc kt ku kv ld kx ky ka im bi translated">在任何函数前面加上<code class="fe lt lu lv lj b">async</code>关键字意味着该函数将返回一个承诺，并将非承诺包装在其中。<code class="fe lt lu lv lj b">await</code>字面意思是让JavaScript等到承诺达成，然后继续处理结果。这不会消耗任何CPU资源，因为引擎可以同时做其他工作:执行其他脚本，处理事件等。</p><p id="0f54" class="pw-post-body-paragraph kc kd it ke b kf kz kh ki kj la kl km kn lb kp kq kr lc kt ku kv ld kx ky ka im bi translated">如果你想获得更多的阅读资料，这里有一些我最喜欢的关于承诺和异步/等待编码的博文:</p><div class="or os gp gr ot ou"><a rel="noopener  ugc nofollow" target="_blank" href="/understand-javascript-promises-by-building-a-promise-from-scratch-84c0fd855720"><div class="ov ab fo"><div class="ow ab ox cl cj oy"><h2 class="bd iu gy z fp oz fr fs pa fu fw is bi translated">JavaScript承诺——通过构建一个简单的承诺示例来理解JavaScript承诺</h2><div class="pb l"><h3 class="bd b gy z fp oz fr fs pa fu fw dk translated">一步一步的教程，确保你完全理解JavaScript的承诺是如何工作的，从…</h3></div><div class="pc l"><p class="bd b dl z fp oz fr fs pa fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="pd l"><div class="pe l pf pg ph pd pi oe ou"/></div></div></a></div><div class="or os gp gr ot ou"><a href="https://flaviocopes.com/javascript-promises/" rel="noopener  ugc nofollow" target="_blank"><div class="ov ab fo"><div class="ow ab ox cl cj oy"><h2 class="bd iu gy z fp oz fr fs pa fu fw is bi translated">理解JavaScript承诺</h2><div class="pb l"><h3 class="bd b gy z fp oz fr fs pa fu fw dk translated">学习JavaScript？下载我的免费JavaScript手册🔥承诺通常被定义为一种价值的代表…</h3></div><div class="pc l"><p class="bd b dl z fp oz fr fs pa fu fw dk translated">flaviocopes.com</p></div></div><div class="pd l"><div class="pj l pf pg ph pd pi oe ou"/></div></div></a></div><div class="or os gp gr ot ou"><a href="https://hackernoon.com/javascript-promises-and-why-async-await-wins-the-battle-4fc9d15d509f" rel="noopener  ugc nofollow" target="_blank"><div class="ov ab fo"><div class="ow ab ox cl cj oy"><h2 class="bd iu gy z fp oz fr fs pa fu fw is bi translated">JavaScript:承诺和为什么Async/Await赢得了这场战斗</h2><div class="pb l"><h3 class="bd b gy z fp oz fr fs pa fu fw dk translated">异步函数在JavaScript中有好有坏。好的一面是异步函数…</h3></div><div class="pc l"><p class="bd b dl z fp oz fr fs pa fu fw dk translated">hackernoon.com</p></div></div><div class="pd l"><div class="pk l pf pg ph pd pi oe ou"/></div></div></a></div><p id="2ec8" class="pw-post-body-paragraph kc kd it ke b kf kz kh ki kj la kl km kn lb kp kq kr lc kt ku kv ld kx ky ka im bi translated">感谢阅读！:)</p></div></div>    
</body>
</html>