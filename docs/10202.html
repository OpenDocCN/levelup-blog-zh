<html>
<head>
<title>Practical Aspects of Interfaces in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">围棋界面的实用方面</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/practical-aspects-of-interfaces-in-go-53a088b9b361?source=collection_archive---------3-----------------------#2021-11-05">https://levelup.gitconnected.com/practical-aspects-of-interfaces-in-go-53a088b9b361?source=collection_archive---------3-----------------------#2021-11-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/47fa390373307ccba46eeabd9533c4ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*--1YwwE6YSUFF2ol"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">Josue Michel 在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="4a98" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">关于Go中的接口有很多很好的讨论，其中一些是我的，但是我想提交一篇关于实践方面的更抽象的文章。为此，我们首先需要讨论编程语言中接口的概念。</p><h2 id="5847" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">编程中的接口是什么？</h2><p id="ddd0" class="pw-post-body-paragraph kg kh it ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">从概念上讲，接口就是抽象地定义应该由某个东西实现的特定行为集。一门语言可能会完全忽略这个概念，或者用接口、协议、鸭类型或其他机制来实现这个概念。</p><p id="6853" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">考虑一个发票系统，要生成一张发票，你只需要知道一个项目的价格和它是否需要纳税。一种方法是定义一个<em class="mc">可开票</em> <em class="mc">接口</em>，描述两个行为，价格和应税，任何你想添加到发票上的项目，一辆汽车，一个香蕉，一只鸭子，只需要<em class="mc">实现</em> <em class="mc">可开票</em>。从概念上讲，这可以在运行时完成，在运行时动态地询问项目的兼容性，或者在编译时完成，在编译时编译器必须能够确定项目实现了接口。两个众所周知的具体例子是Java中的<em class="mc"> Iterable </em>接口，由集合实现以提供统一的内容访问，或者Go中的<em class="mc"> Stringer </em>接口，由任何想要提供字符串表示的对象实现。</p><h2 id="1072" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">Go中的接口有什么值得注意的</h2><p id="382f" class="pw-post-body-paragraph kg kh it ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">Go提供了在编译时强制执行的接口。如果你在代码中指出某个东西需要<em class="mc">可调用</em>，那么只有当这个东西实际上实现了<em class="mc">可调用</em>接口时，代码才会被编译。有很多方法可以破坏这一点，但是相信这种说法通常是没问题的。</p><blockquote class="md me mf"><p id="5d28" class="kg kh mc ki b kj kk kl km kn ko kp kq mg ks kt ku mh kw kx ky mi la lb lc ld im bi translated">关于Go的实现值得注意的是，它不需要像Java那样将项目显式标记为实现Invoiceable，而是在编译时查询项目。</p></blockquote><h2 id="cdac" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">赞成的意见</h2><p id="3207" class="pw-post-body-paragraph kg kh it ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">Go方法的优点是接口的存在与应用它的项目是分离的。被询问的物品需要事先不知道该接口。您可以在您的代码<em class="mc">中定义<em class="mc">可调用</em>，并从第三方代码中测试一些东西，如果该项目实现了<em class="mc">可调用</em>的行为，代码将会正确编译并运行。这是一种非常灵活的方法，仍然可以在编译时执行。</em></p><h2 id="7271" class="le lf it bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">骗局</h2><p id="8cf6" class="pw-post-body-paragraph kg kh it ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">Go的分离方法对于维护代码来说也是有问题的。考虑这样一个场景，第三方将他们的<em class="mc">价格</em>方法全局重命名为<em class="mc">项目价格</em>。编译器将获得并报告他们的<em class="mc">项</em>不再是<em class="mc">可调用的</em>，然而，无论你在哪里使用他们代码的接口，都会到处报告。它可能会非常强大和分散，使得隔离问题变得非常棘手。</p><p id="d3e0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于这个问题，有一个可以采用的程序修复方法，即在一个逻辑集中的位置显式地执行以下操作:</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="1084" class="le lf it mo b gy ms mt l mu mv">var (<br/>   _ Invoiceable = (*honda.Vehicle)(nil)<br/>   _ Invoiceable = (*chevy.Truck)(nil)<br/>   _ Invoiceable = (*autozone.Part)(nil)<br/>)</span></pre><p id="a94d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这不是魔术，它只是创建一个中心位置，编译器将在这里询问第三方项目是否符合可调用接口。虽然您仍然会收到所有零散的编译器投诉，但现在您会从某个地方收到一个主要投诉，它会立即提示您问题的本质。</p></div></div>    
</body>
</html>