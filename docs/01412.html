<html>
<head>
<title>Creating a Conversational Telegram Bot in Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Node.js中创建对话电报机器人</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/creating-a-conversational-telegram-bot-in-node-js-with-a-finite-state-machine-and-async-await-ca44f03874f9?source=collection_archive---------2-----------------------#2019-12-26">https://levelup.gitconnected.com/creating-a-conversational-telegram-bot-in-node-js-with-a-finite-state-machine-and-async-await-ca44f03874f9?source=collection_archive---------2-----------------------#2019-12-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6c52" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用有限状态机和async/await创建一个带有节点的对话机器人</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/be330ecbc49894069310c4c0241516ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YkLI0bwi0_W3hVldWd_5nw.jpeg"/></div></div></figure><p id="adbe" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Telegram是一款免费的多平台消息应用。他们经常发布具有有趣特性的新版本，其中最大的一个是他们的机器人平台。我最近在开发几个机器人的过程中得到了一些乐趣，我想到了一个基于有限状态机的基于对话的机器人的解决方案，该解决方案利用了ECMAScript即将推出的async/await，我认为它很不错，也很有趣，值得分享。我将通过从头创建一个新的机器人来解释它。</p><h1 id="dd49" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">介绍</h1><p id="40aa" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">Telegram的bot API是无状态的。关于之前的对话，您获得的唯一数据是用户正在回复的消息的ID(如果有的话)。最初，这意味着机器人只能轻松地响应单个命令，而不能进行更自然的对话来完成复杂的任务。</p><p id="9242" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将构建一个简单的回声机器人，但具有一些对话特征。当机器人收到<code class="fe mn mo mp mq b">/start</code>命令时，它会询问用户的名字。之后，它将开始回显，提到它回显的用户的名字。收到<code class="fe mn mo mp mq b">/stop</code>命令后，它会要求确认。如果用户说是，那么机器人将停止回显，如果用户说不是，它将返回回显，如果用户说了其他任何事情，它将要求澄清。</p><p id="138b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我发现Node.js适合作为构建机器人的平台——通过Telegram的API进行的所有操作都是异步的，大多数时候我最终依赖IO来实现机器人的特定功能。Node.js使得构建可以同时响应多个对话而不会阻塞的机器人变得更加容易。</p><p id="ab39" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">你可以在这里看到所有的代码。如果你想尝试，你必须注册一个机器人，并在一个<code class="fe mn mo mp mq b">.env</code>文件中设置它的密钥。请参阅自述文件中的确切说明。</p><h1 id="54b4" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">第一次提交</h1><p id="129d" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">第一次提交并没有真正针对这个主题，所以我将简单介绍一下我们将使用的工具和库。也许唯一稍微相关的是添加babel，我们最终需要它来传输异步函数，但是我们需要为此做更多的配置。因此，如果您对该基本设置不感兴趣，请随意跳到下一部分。</p><p id="2e4f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">查看package.json文件，我们的开发依赖项中有eslint，还有babel-eslint，eslint需要它来很好地处理我们的异步函数。我还使用nodemon在开发过程中自动重新加载我的文件。运行时依赖项包括babel和babel-register，以方便地传输我们的代码，babel为ES2015预设的以及dotenv，以从. env文件加载bot的令牌。</p><p id="08c7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">index.js文件只是使用dotenv从。env，启动babel-register并初始化bot(此时它只是登录到控制台并退出)。</p><p id="e22a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">其余的是各种工具的配置文件。eslintrc for ESLint，。巴别塔的巴别塔。用NVM和指定节点的版本。编写代码时保持一致的风格。</p><h1 id="018e" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">反照现象</h1><p id="e232" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">下一步是让机器人实际做一些事情。在深入研究代码之前，我们必须在平台中实际创建机器人。为此，请与<a class="ae mr" href="http://twitter.com/BotFather" rel="noopener ugc nofollow" target="_blank">@机器人父亲</a>交谈并按照步骤操作。归结起来就是给你的机器人一个名字。之后，您将获得一个令牌，机器人将在查询Telegram的API时使用它来标识自己。把它放在安全的地方，让我们开始做一些基本的功能。</p><p id="3244" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先，有一段时间我一直在手工编写与Telegram的API的交互，使用request或got来发出请求。在NPM有很多已经实现的解决方案，所以这次我选择了node-telegram-bot-api。它实现了大部分API功能，并且很好地处理了回复。所以让我们安装它:</p><pre class="kj kk kl km gt ms mq mt mu aw mv bi"><span id="90dc" class="mw lr it mq b gy mx my l mz na">npm i node-telegram-bot-api --save</span></pre><p id="39b7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在让我们更新我们的<code class="fe mn mo mp mq b">Bot</code>类——它将使用由<code class="fe mn mo mp mq b">node-telegram-bot-api</code>导出的类的一个实例作为客户端来与Telegram的API交互:</p><pre class="kj kk kl km gt ms mq mt mu aw mv bi"><span id="c88f" class="mw lr it mq b gy mx my l mz na">import TelegramBotClient from 'node-telegram-bot-api'<br/><br/>export default class Bot {<br/>  constructor(token) {<br/>    this.client = new TelegramBotClient(token, { polling: true })<br/>  }<br/><br/>  start() {<br/>    this.client.on('message', message =&gt; {<br/>      console.log('Got a message', message)<br/>    })<br/>  }<br/>}<br/></span></pre><p id="d1a7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意，我们需要向客户端传递两个参数——这个令牌非常简单，它是我们从<a class="ae mr" href="http://twitter.com/BotFather" rel="noopener ugc nofollow" target="_blank"> @BotFather </a>那里得到的令牌。options对象正在设置客户端以轮询更新。你的机器人有两种方法从电报获取信息。第一个是使用webhook。您可以配置平台，将消息推送到您拥有的某个端点，并从那里读取消息。这是一个干净的解决方案，但同时也意味着更多的配置。例如，端点必须可以通过HTTPS访问。自签名证书可以工作，但是配置它仍然比使用轮询更麻烦。</p><p id="49ec" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">轮询方法(实际上是长轮询)请求Telegram获取更新。如果没有，Telegram的服务器会一直等待，直到有一个或超时。这样，在新的更新到来后，Telegram会立即解决未决的请求，您的机器人几乎会立即得到它。</p><p id="7364" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">那么，我们如何将机器人的令牌发送给客户端呢？这就是dotenv的用武之地。我们不希望令牌是硬编码的，任何人都可以访问代码。所以我们将把令牌放在一个. env文件中，比如</p><pre class="kj kk kl km gt ms mq mt mu aw mv bi"><span id="db85" class="mw lr it mq b gy mx my l mz na">BOT_TOKEN=123456789:abcdefghijklmnoprqstuvwxyz</span></pre><p id="281b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因为我们已经在我们的<code class="fe mn mo mp mq b">index.js</code>文件中调用了<code class="fe mn mo mp mq b">dotenv.load()</code>，所以我们在<code class="fe mn mo mp mq b">process.env</code>中可以得到<code class="fe mn mo mp mq b">.env</code>上的所有内容。所以我们将更新<code class="fe mn mo mp mq b">index.js</code>来将这个令牌传递给我们的<code class="fe mn mo mp mq b">Bot</code>实例:</p><p id="7ef8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">到目前为止，我们的机器人记录它收到的每条消息。让我们再走一步，让它无论收到什么都有回音。使用<code class="fe mn mo mp mq b">node-telegram-bot-api</code>非常简单，我们只需要告诉它我们想要发送什么消息(我们得到的确切文本)和哪个聊天(我们得到它的那个):</p><pre class="kj kk kl km gt ms mq mt mu aw mv bi"><span id="4be5" class="mw lr it mq b gy mx my l mz na">-    console.log('Got a message', message)<br/>+    this.client.on('message', message =&gt; {<br/>+      this.client.sendMessage(message.chat.id, message.text)<br/>+    })<br/></span></pre><p id="6158" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">就是这样！在这一点上，我们有一个机器人，无论我们向它发送什么，它都会回应。让我们继续利用<code class="fe mn mo mp mq b">async</code> / <code class="fe mn mo mp mq b">await</code>进行一个非常简单的对话。</p><h1 id="4564" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">异步/等待</h1><p id="c596" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">现在我们想让我们的机器人停止回应。当机器人收到消息说<em class="nb">停止</em>时，它只会说它停止了回应。为此，我们希望强制用户回复机器人的每个回应。你可以在第三次提交中看到所有的代码。</p><p id="3557" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这可以不等待回复就完成——如果用户发送了“停止”消息，就让机器人发送“停止”消息。实际上<em class="nb">不会阻止</em>做任何事情，但最终结果是一样的。现在让我们等待用户的回复，然后我们将在下一步看到一个真正需要回复的例子。</p><p id="033e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将使用send messages API中的<code class="fe mn mo mp mq b">ForceReply</code>选项让Telegram自动向用户显示UI，以回复机器人的最后一条消息。我们发送回显的代码将如下所示:</p><pre class="kj kk kl km gt ms mq mt mu aw mv bi"><span id="b50b" class="mw lr it mq b gy mx my l mz na">this.client.sendMessage(message.chat.id, `echo: ${text}`, {<br/>  reply_markup: JSON.stringify({ force_reply: true }),<br/>})</span></pre><p id="8dd1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意，我们必须以字符串的形式传递选项，因此我们将使用<code class="fe mn mo mp mq b">JSON.stringify</code>来实现这一点。</p><p id="982c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe mn mo mp mq b">sendMessage</code>返回一个承诺，该承诺在发送的消息通过后得到解决，其中包含一些有趣的信息，即可以用来等待回复的id。<code class="fe mn mo mp mq b">node-telegram-bot-api</code>有一个名为<code class="fe mn mo mp mq b">onReplyToMessage</code>的方法，该方法将在消息到达时执行回调，该消息是对特定消息id的回复。所以让我们把这两个放在一起处理我们用户的第一个回复:</p><pre class="kj kk kl km gt ms mq mt mu aw mv bi"><span id="75c8" class="mw lr it mq b gy mx my l mz na">this.client<br/>  .sendMessage(message.chat.id, `echo: ${text}`, {<br/>    reply_markup: JSON.stringify({ force_reply: true }),<br/>  })<br/>  .then(reply =&gt; console.log(reply))</span></pre><p id="c3e7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">很好。那么我们实际上想对回复做什么呢？嗯，如果<code class="fe mn mo mp mq b">reply.text === 'stop'</code>，我们要停止回响，否则我们要再次回响。并等待另一个回复。基本上和我们刚才做的一样。让我们把它提取到一个方法中:</p><pre class="kj kk kl km gt ms mq mt mu aw mv bi"><span id="2b68" class="mw lr it mq b gy mx my l mz na">respondTo(message) {<br/>  if (message.text === 'stop') {<br/>    this.client.sendMessage(message.chat.id, 'Stopping')<br/>  } else {<br/>    this.respondToMessage(message)<br/>  }<br/>}<br/><br/>respondToMessage(message) {<br/>  this.client<br/>    .sendMessage(message.chat.id, `echo: ${text}`, {<br/>      reply_markup: JSON.stringify({ force_reply: true }),<br/>    })<br/>    .then(sentMessage =&gt; {<br/>      this.client.onReplyToMessage(<br/>        sentMessage.chat.id,<br/>        sentMessage.message_id,<br/>        reply =&gt; {<br/>          if (reply.text === 'stop') {<br/>            this.client.sendMessage(message.chat.id, 'Stopping')<br/>          } else {<br/>            this.respondToMessage(reply)<br/>          }<br/>        }<br/>      )<br/>    })<br/>}<br/></span></pre><p id="7f40" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这应该能行，对吧？嗯，是的。但是代码(也许可以说)比同步代码更难阅读。当算法基本上是一个<code class="fe mn mo mp mq b">while</code>循环时，我们有一些嵌套。那么，如果代码看起来更像这样会怎么样呢:</p><pre class="kj kk kl km gt ms mq mt mu aw mv bi"><span id="3b90" class="mw lr it mq b gy mx my l mz na">respondTo(message) {<br/>  let text = message.text<br/><br/>  while (text !== 'stop') {<br/>    let sentMessage = this.client.sendMessage(<br/>      message.chat.id,<br/>      `echo: ${text}`,<br/>      { reply_markup: JSON.stringify({ force_reply: true }) }<br/>    )<br/>    let reply = this.client.onReplyToMessage(<br/>      sentMessage.chat.id,<br/>      sentMessage.message_id<br/>    )<br/>    text = reply.text<br/>  }<br/><br/>  this.client.sendMessage(message.chat.id, 'Stopping')<br/>}<br/></span></pre><p id="78ca" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">提示:它可以，也将会。这就是异步和等待的用武之地。Async Functions提案旨在简化编写上述异步代码的过程。它利用了生成器和承诺的力量——实际上可以认为是两者之上的语法糖——使得编写与承诺交互的代码变得非常简单。</p><p id="9760" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">第一个关键字async用在函数声明中，以表明它们是异步的。实际上，这意味着他们会兑现承诺。在我们的例子中，我们只需要将respondTo声明为async respondTo。</p><p id="c0cb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">await只能在异步函数中使用。它将接受随后的承诺，并停止执行，直到它解决。将这两者放在一起，大致意味着以下两个片段是等效的:</p><pre class="kj kk kl km gt ms mq mt mu aw mv bi"><span id="c348" class="mw lr it mq b gy mx my l mz na">function syncFunction() {<br/>  return someAsyncOperation()<br/>    .then(result =&gt; result + 1)<br/>    .catch(err =&gt; console.error(err))<br/>}<br/><br/>async function asyncFunction() {<br/>  try {<br/>    let result = await someAsyncOperation()<br/>    return result + 1<br/>  } catch (err) {<br/>    console.error(err)<br/>  }<br/>}<br/></span></pre><p id="c0d7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">回到我们的代码，我们需要采取的第一步是配置Babel来支持异步功能。因为它们还不是规范的一部分，所以默认情况下它们不受支持。所以首先，我们想安装<code class="fe mn mo mp mq b">babel-plugin-transform-async-to-generator</code>和<code class="fe mn mo mp mq b">babel-polyfill</code>:</p><pre class="kj kk kl km gt ms mq mt mu aw mv bi"><span id="62e9" class="mw lr it mq b gy mx my l mz na">npm i babel-plugin-transform-async-to-generator babel-polyfill --save</span></pre><p id="f084" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一旦完成，我们需要在我们的<code class="fe mn mo mp mq b">index.js</code>文件中要求<code class="fe mn mo mp mq b">babel-register</code>之前添加<code class="fe mn mo mp mq b">require('babel-polyfill')</code>，并在我们的<code class="fe mn mo mp mq b">.babelrc</code>文件中配置Babel使用异步转换插件:</p><pre class="kj kk kl km gt ms mq mt mu aw mv bi"><span id="a70e" class="mw lr it mq b gy mx my l mz na">{<br/>  "presets": ["es2015"],<br/>  "plugins": ["transform-async-to-generator"]<br/>}</span></pre><p id="0f75" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们可以在机器人代码中使用异步函数了。我们可以直接将<code class="fe mn mo mp mq b">await</code>与<code class="fe mn mo mp mq b">this.client.sendMessage</code>一起使用，因为正如我们之前看到的，它返回一个承诺。<code class="fe mn mo mp mq b">this.client.onReplyToMessage</code>稍微复杂一点——它不返回一个承诺，而是执行一个回调，当回复到达时，回调作为最后一个参数接收。我们必须把它变成一个承诺，但幸运的是这一点也不难:</p><pre class="kj kk kl km gt ms mq mt mu aw mv bi"><span id="b717" class="mw lr it mq b gy mx my l mz na">let reply = await new Promise(resolve =&gt;<br/>  this.client.onReplyToMessage(<br/>    sentMessage.chat.id,<br/>    sentMessage.message_id,<br/>    resolve<br/>  )<br/>)</span></pre><p id="6a10" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我不会深入承诺创建的细节，因为那里有很好的帖子，但它的要点是，我们正在创建一个新的承诺，当<code class="fe mn mo mp mq b">this.client.onReplyToMessage</code>执行其回调时，该承诺将被解析，它解析的值是传递给该回调的参数。所以如果我们把所有的东西放在一起，我们最终会得到这样的结果:</p><pre class="kj kk kl km gt ms mq mt mu aw mv bi"><span id="a6d9" class="mw lr it mq b gy mx my l mz na">async respondTo(message) {<br/>  let text = (text = message.text)<br/><br/>  while (text !== 'stop') {<br/>    let sentMessage = await this.client.sendMessage(<br/>      message.chat.id,<br/>      `echo: ${text}`,<br/>      { reply_markup: JSON.stringify({ force_reply: true }) }<br/>    )<br/>    let reply = await new Promise(resolve =&gt;<br/>      this.client.onReplyToMessage(<br/>        sentMessage.chat.id,<br/>        sentMessage.message_id,<br/>        resolve<br/>      )<br/>    )<br/>    text = reply.text<br/>  }<br/><br/>  this.client.sendMessage(message.chat.id, 'Stopping')<br/>}</span></pre><p id="cf6f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意，我们将<code class="fe mn mo mp mq b">respondTo</code>标记为<code class="fe mn mo mp mq b">async</code>，然后在<code class="fe mn mo mp mq b">while</code>循环体中使用了两个<code class="fe mn mo mp mq b">await</code>。就是这样！代码读起来当然容易多了，几乎就像是同步的一样。如果我们不必“承诺”对<code class="fe mn mo mp mq b">this.client.onReplyToMessage</code>的呼叫，这可能会更好，但这肯定比没有<code class="fe mn mo mp mq b">async</code> / <code class="fe mn mo mp mq b">await</code>的版本更容易理解。</p><p id="2308" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们必须做的另一个改变是——虽然用户回复将在<code class="fe mn mo mp mq b">this.client.onReplyToMessage</code>中得到回调，但它们也是常规消息，所以它们也会在我们对<code class="fe mn mo mp mq b">this.client.on('message')</code>的回调中显示。因此，我们必须更新回调，以便只考虑不是回复的消息。回复将已经被循环捕获。</p><pre class="kj kk kl km gt ms mq mt mu aw mv bi"><span id="baec" class="mw lr it mq b gy mx my l mz na">start() {<br/>  this.client.on('message', message =&gt; {<br/>    if (!message.reply_to_message) {<br/>      this.respondTo(message)<br/>    }<br/>  })<br/>}</span></pre><p id="a91e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">完成这些之后，是时候以状态机的形式建模更复杂的行为了。</p><h1 id="e387" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">有限状态机</h1><p id="2017" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">让我们记住我们期望机器人的最终功能。它应该在<code class="fe mn mo mp mq b">/start</code>上询问我们的名字。然后，它应该开始回应我们发送给它的任何东西，直到我们说<code class="fe mn mo mp mq b">/stop</code>。当我们发送命令时，它应该要求我们确认。如果我们说“是”，执行就应该结束。如果我们说“不”，它应该回到呼应。如果我们说什么，它应该要求澄清。</p><p id="ef16" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">可能有几种方法来模拟这种行为。我可以肯定的是，我希望避免在每个回复中检查一堆标志和复杂的条件，因为编写它们的痛苦比不上维护它们的痛苦。因此，创建它的心理模型的一个可能的方法是将机器人想象成几种状态中的一种，并且能够在它们之间转换:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/761a3d3388dd6f4266dfdaf2dea55cdd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1126/format:webp/0*5kP-dojhcjvEUtsv.png"/></div></figure><p id="3ca4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我学习有限状态机已经有一段时间了，所以我不打算假装我记得足够清楚来解释它。我会为他们参考永远值得信赖的维基百科文章，但是如果你想要一个快速的解释，这就足够了。</p><p id="b850" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有限状态机(从现在开始称为FSM)是一种由状态以及状态之间的转换组成的模型。机器总是处于这些状态中的一种，直到一个事件发生，使它改变到另一种状态。这些状态中的一些可以被认为是最终的或终结的。</p><p id="d774" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">毫不奇怪，这个模型非常符合上面的机器人图。机器人将处于几种状态中的一种，这些状态主要代表它在等待什么——<code class="fe mn mo mp mq b">/start</code>命令、名称、要回应的文本等等。我们的工作是根据机器的当前状态和我们从Telegram的API得到的消息来确定相应的事件。</p><p id="d672" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">同样，您可以检查<a class="ae mr" href="https://github.com/julioolvr/telegram-bot-example/commit/ffb568314ad5f8f531828246495f0cc1852e0e2c" rel="noopener ugc nofollow" target="_blank">对应的提交</a>来查看更改。</p><h1 id="9d5d" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">定义状态机</h1><p id="659f" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">让我们从安装一个处理FSM内部的库开始。我会选<code class="fe mn mo mp mq b"><a class="ae mr" href="https://www.npmjs.com/package/javascript-state-machine" rel="noopener ugc nofollow" target="_blank">javascript-state-machine</a></code>，但很可能还有很多其他的。</p><pre class="kj kk kl km gt ms mq mt mu aw mv bi"><span id="336c" class="mw lr it mq b gy mx my l mz na">npm i javascript-state-machine --save</span></pre><p id="0db6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在让我们使用这个库来编写FSM。因为FSM的一个实例跟踪它的当前状态，所以我们希望每个会话有一个实例。所以我们将从定义一个创建机器的函数开始:</p><pre class="kj kk kl km gt ms mq mt mu aw mv bi"><span id="bd21" class="mw lr it mq b gy mx my l mz na">import StateMachine from 'javascript-state-machine'</span><span id="da7f" class="mw lr it mq b gy nd my l mz na">function createFsm() {<br/>  return StateMachine.create({<br/>    initial: 'waitingstart',<br/>    final: 'final',<br/>    events: [<br/>      { name: 'gotstart', from: 'waitingstart', to: 'waitingname' },<br/>      { name: 'gotname', from: 'waitingname', to: 'echoing' },<br/>      { name: 'gottext', from: 'echoing', to: 'echoing' },<br/>      { name: 'gotstop', from: 'echoing', to: 'confirm' },<br/>      { name: 'confirmed', from: 'confirm', to: 'final' },<br/>      { name: 'cancelled', from: 'confirm', to: 'echoing' },<br/>      { name: 'invalid', from: 'confirm', to: 'confirm' },<br/>    ],<br/>  })<br/>}</span></pre><p id="b239" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您看一下每个事件，它们代表了图中定义的转换。这些状态没有明确列出，但是您会在转换中看到它们。我们可以使用<code class="fe mn mo mp mq b">respondTo</code>中的函数为对话获取一个新的FSM。此外，现在我们有了一个更好的方法来检查对话是否已经结束——我们可以使用状态机的方法<code class="fe mn mo mp mq b">isFinished</code>来检查最终状态。让我们更新代码:</p><pre class="kj kk kl km gt ms mq mt mu aw mv bi"><span id="f6b6" class="mw lr it mq b gy mx my l mz na">async respondTo(message) {<br/>  let fsm = createFsm()<br/>  let lastReply = message</span><span id="2110" class="mw lr it mq b gy nd my l mz na">  while (!fsm.isFinished()) {<br/>    let text = lastReply.text<br/>    let event = eventFromStateAndMessageText(fsm.current, text)</span><span id="f210" class="mw lr it mq b gy nd my l mz na">    if (!event || fsm.cannot(event)) {<br/>      this.client.sendMessage(<br/>        message.chat.id,<br/>        "I wasn't expecting that, try /start"<br/>      )<br/>      break<br/>    }</span><span id="eed9" class="mw lr it mq b gy nd my l mz na">    fsm[event](lastReply)</span><span id="9446" class="mw lr it mq b gy nd my l mz na">    let sentMessage = await lastMessage<br/>    lastReply = await new Promise(resolve =&gt;<br/>      this.client.onReplyToMessage(<br/>        sentMessage.chat.id,<br/>        sentMessage.message_id,<br/>        resolve<br/>      )<br/>    )<br/>  }<br/>}</span></pre><p id="6343" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">除了使用<code class="fe mn mo mp mq b">fsm.isFinished()</code>作为我们的<code class="fe mn mo mp mq b">while</code>条件，我们还使用了<code class="fe mn mo mp mq b">fsm.cannot(event)</code>。这意味着，一旦我们弄清楚什么事件对应于接收到的消息，我们就可以检查机器是否可以实际应用该转换。否则，这意味着用户发送了我们没有预料到的东西。这不一定适用于这种情况，因为我们在决定应该触发哪个事件时已经考虑了当前状态，但是在更复杂的情况下这很有用。</p><p id="ef5b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意，我们有一个还没有定义的<code class="fe mn mo mp mq b">lastMessage</code>变量。让我们暂时把它放在那里，我们会回头再看它，但基本上它保存了机器人发送的最后一条消息，所以我们可以等待它的回复。</p><p id="a426" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">还要注意，我们调用<code class="fe mn mo mp mq b">fsm[event](lastReply)</code>来实现FSM转换状态。对于我们为其定义的每个事件，FSM都有一个方法来触发这样的事件。我们可以向该方法传递任意参数，稍后我们将在回调中使用这些参数。</p><p id="e834" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在让我们转到那个<code class="fe mn mo mp mq b">eventFromStateAndMessageText</code>函数。我们将传递当前的机器状态和上一次用户回复的文本，并期望收到一个包含事件的字符串。我们考虑事件为<code class="fe mn mo mp mq b">undefined</code>的情况，因为在给定当前状态的情况下，我们得到的消息可能没有有效的事件。该函数中的逻辑类似于“如果我在等待/start命令，并且我得到了/start文本，则事件为‘got start’，”如果我在等待名称，则我收到的任何文本都会生成‘got name’事件”等等:</p><pre class="kj kk kl km gt ms mq mt mu aw mv bi"><span id="08b8" class="mw lr it mq b gy mx my l mz na">function eventFromStateAndMessageText(state, text) {<br/>  switch (state) {<br/>    case 'waitingstart':<br/>      return text === '/start' &amp;&amp; 'gotstart'<br/>      break<br/>    case 'waitingname':<br/>      return 'gotname'<br/>      break<br/>    case 'echoing':<br/>      return text === '/stop' ? 'gotstop' : 'gottext'<br/>      break<br/>    case 'confirm':<br/>      if (text === 'yes') {<br/>        return 'confirmed'<br/>      } else if (text === 'no') {<br/>        return 'cancelled'<br/>      } else {<br/>        return 'invalid'<br/>      }<br/>  }<br/>}</span></pre><h1 id="754f" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">定义机器的行为</h1><p id="47a1" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">现在到最后一部分:我们实际上在哪里回复用户？嗯，FSM为我们提供了几个回调函数，特别是当机器进入和离开一个状态时，以及在执行一个事件之前和之后。每个都有自己的用例，但我们认为我们的机器人在这里我相信使用事件回调是有意义的——在我得到/开始后，我想问名字。有了名字之后，我想开始附和，诸如此类。</p><p id="63a3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们想把这些回调附加到<code class="fe mn mo mp mq b">respondTo</code>内部的机器上，因为我们需要它们的一些上下文——我们想要我们响应的聊天id，我们想要访问电报客户端，以便能够发送回消息。因此，在<code class="fe mn mo mp mq b">while</code>循环之前，我们将定义所有的回调:</p><pre class="kj kk kl km gt ms mq mt mu aw mv bi"><span id="c24a" class="mw lr it mq b gy mx my l mz na">let name<br/>let lastMessage</span><span id="ec83" class="mw lr it mq b gy nd my l mz na">fsm.ongotstart = () =&gt; {<br/>  lastMessage = this.client.sendMessage(<br/>    message.chat.id,<br/>    "Let's begin! What's your name?",<br/>    {<br/>      reply_markup: JSON.stringify({ force_reply: true }),<br/>    }<br/>  )<br/>}</span><span id="4bcc" class="mw lr it mq b gy nd my l mz na">fsm.ongotname = (event, from, to, message) =&gt; {<br/>  name = message.text<br/>  lastMessage = this.client.sendMessage(<br/>    message.chat.id,<br/>    `Got it ${name}, I'll begin echoing your replies until you respond with /stop`,<br/>    { reply_markup: JSON.stringify({ force_reply: true }) }<br/>  )<br/>}</span><span id="6f8f" class="mw lr it mq b gy nd my l mz na">fsm.ongottext = (event, from, to, message) =&gt; {<br/>  lastMessage = this.client.sendMessage(<br/>    message.chat.id,<br/>    `Echoing for ${name}: ${message.text}`,<br/>    {<br/>      reply_markup: JSON.stringify({ force_reply: true }),<br/>    }<br/>  )<br/>}</span><span id="e151" class="mw lr it mq b gy nd my l mz na">/*...*/</span></pre><p id="547c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了简洁起见，我省略了一些回调，但是它们都非常相似。我相信，这就是将机器人建模为FSM如此有用的原因。一旦应用了转换，我们就可以将转换(我收到了这条消息，我正在等待这件事情)与实际行为分开。我们的<code class="fe mn mo mp mq b">oncancelled</code>回调知道我们在回显并得到一个/stop命令，然后这个命令被取消了。它所要做的就是发回适当的信息。甚至不转换到另一个状态FSM会处理它。</p><p id="3aa8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们定义了两个新的变量，在回调之外的不同消息中我们将需要这两个变量— <code class="fe mn mo mp mq b">name</code>，其中我们将存储用户为当前对话提供的名称，以及之前看到的<code class="fe mn mo mp mq b">lastMessage</code>，这样我们就可以等待它被发送，并在需要时期待回复。</p><p id="2900" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">仅此而已！看看<a class="ae mr" href="https://github.com/shivapendem/conversation_telegram_bot.git" rel="noopener ugc nofollow" target="_blank"> Github </a>上完成的代码。当然，还可以对机器人做更多的事情。例如，停止那些<code class="fe mn mo mp mq b">this.client.sendMessage</code>调用，也许创建一个定制的类来包装FSM并保持所需的上下文(特别是，<code class="fe mn mo mp mq b">javascript-state-machine</code>有一个<code class="fe mn mo mp mq b">target</code>选项来扩展另一个类的现有实例并将其转换成FSM)。但是我认为，在目前的状态下，它已经显示了将机器人建模为FSM是多么有用，以及使用<code class="fe mn mo mp mq b">async</code> / <code class="fe mn mo mp mq b">await</code>的代码是多么干净和可读。</p></div><div class="ab cl ne nf hx ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="im in io ip iq"><p id="d443" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你觉得这篇文章是有帮助的，如果你能给下面的地址提示乙醚，将不胜感激。谢谢大家！</p><pre class="kj kk kl km gt ms mq mt mu aw mv bi"><span id="17bd" class="mw lr it mq b gy mx my l mz na">0xe8312ec868303fc3f14DeA8C63A1013608038801</span></pre><p id="6a8e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">更多信息请打我的电报id <a class="ae mr" href="https://t.me/chigovera" rel="noopener ugc nofollow" target="_blank"> @chigovera </a>联系我。</p></div></div>    
</body>
</html>