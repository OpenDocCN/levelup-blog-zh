<html>
<head>
<title>Learn React Hooks By Building An Auth Based To Do App</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过构建一个基于授权的待办事项应用程序来学习React Hooks</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/learn-react-hooks-by-building-an-auth-based-to-do-app-c2d143928b0b?source=collection_archive---------0-----------------------#2019-05-28">https://levelup.gitconnected.com/learn-react-hooks-by-building-an-auth-based-to-do-app-c2d143928b0b?source=collection_archive---------0-----------------------#2019-05-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/79d6088f94bc2711978ad279d65886cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mxA59nnMwtSmJxb-CZPwDA.png"/></div></div></figure><p id="a2a9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">学习<a class="ae kz" href="https://reactjs.org/docs/hooks-reference.html" rel="noopener ugc nofollow" target="_blank"> React钩子</a>可能有点吓人，因为这是一种不同的组件工作方式。以前专属于基于类的组件的功能现在可以与功能组件一起使用。通过钩子，功能组件可以用来管理状态，利用组件的生命周期事件，以及连接到React应用程序的<a class="ae kz" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank">上下文</a>。</p><p id="3957" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此，我们的功能组件将比我们可能习惯的要复杂一些。也就是说，并不是你写的每个函数组件都必须使用钩子。我认为有这样一种模式还是不错的，即我们有包含业务逻辑的容器组件和负责UI表示的表示组件。</p><p id="afcb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我应该从一开始就这么说，有很多关于理解React钩子的文章和教程，我遇到的大多数都非常好。这篇文章的目的是为开发者提供一个替代现有指南的选择。我不会说这种方法更好，但如果你像我一样，喜欢钻研构建一个小应用程序来演示和解释你正在学习的东西，那么这种方法适合你😉。</p><p id="420f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你喜欢这篇文章，请在这里给我买杯咖啡<a class="ae kz" href="https://www.buymeacoffee.com/lukemwila" rel="noopener ugc nofollow" target="_blank">☕️</a>😃。</p><h1 id="4c8f" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">ReactEurope 2020虚拟会议</h1><p id="deba" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">我有幸在虚拟版本的<a class="ae kz" href="https://www.react-europe.org/" rel="noopener ugc nofollow" target="_blank"> ReactEurope 2020 </a>上以演示格式分享了这篇文章，如果你热衷于观看视频演练，请继续查看下面的视频。</p><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="mh mi l"/></div></figure><h1 id="4571" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated"><strong class="ak">一些基本规则</strong></h1><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="mj mi l"/></div></figure><p id="d24e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">像生活中的大多数事情一样，我们不能在任何地方以任何方式使用这些钩子——有<a class="ae kz" href="https://reactjs.org/docs/hooks-rules.html" rel="noopener ugc nofollow" target="_blank"> <em class="mk">规则</em> </a>。您只能在函数组件的顶层使用这些钩子。因此，我们不能在嵌套函数或代码块中启动/实现钩子，比如if语句、for循环语句或任何其他形式的嵌套。它们必须出现在功能组件的根级别的顶部。</p><h1 id="3e9d" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated"><strong class="ak">边构建边学习</strong></h1><p id="305e" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">为了让你对React挂钩有更多的实际感受，我们将通过构建一个非常小的应用程序来学习一些主要的或核心的挂钩，该应用程序具有基本的身份验证(没有注册步骤或实际的数据库)和非常普通的“待办事项”示例🙄。这样做的主要目的是给你一个如何在你自己的应用程序中利用各种钩子的实际想法。</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/0e4dd3da1c61600438ed426fbbdbe5fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1228/format:webp/1*b__H2ynow6Qjx_2XelLbzA.png"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk translated">基本待办事项应用程序</figcaption></figure><h1 id="5897" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated"><strong class="ak">快速设置</strong></h1><p id="0705" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">在这个练习中，我将使用<a class="ae kz" href="https://github.com/facebook/create-react-app" rel="noopener ugc nofollow" target="_blank"> create-react-app </a>和<a class="ae kz" href="https://www.npmjs.com/package/typescript" rel="noopener ugc nofollow" target="_blank"> TypeScript </a>。如果你不太确定如何让TypeScript与脸书的样板文件一起工作，你可以快速查看我的另一篇文章<a class="ae kz" href="https://itnext.io/create-stripe-subscription-payments-using-react-aws-lambda-pt-2-building-our-react-frontend-28a6a167f7b9" rel="noopener ugc nofollow" target="_blank">这里</a>，并通过处理初始设置步骤和删除我们不需要的样板文件代码的部分来工作。</p><p id="9f06" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">出于样式化的目的，我将使用<a class="ae kz" href="https://www.styled-components.com/" rel="noopener ugc nofollow" target="_blank">样式化组件</a>和<a class="ae kz" href="https://reactstrap.github.io/" rel="noopener ugc nofollow" target="_blank"> reactstrap </a>、<a class="ae kz" href="https://www.npmjs.com/package/validator" rel="noopener ugc nofollow" target="_blank">验证器</a>进行输入验证，并使用<a class="ae kz" href="https://www.npmjs.com/package/uuid" rel="noopener ugc nofollow" target="_blank"> uuid </a>生成唯一id。您可以使用以下命令安装每个类型定义包及其各自的类型定义包:</p><pre class="md me mf mg gt mq mr ms mt aw mu bi"><span id="ab0c" class="mv lb it mr b gy mw mx l my mz">npm i --save bootstrap reactstrap styled-components validator uuid<br/>npm i --save-dev @types/reactstrap @types/styled-components @types/validator @types/uuid</span></pre><p id="57d2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我们的<strong class="kd iu"> src </strong>文件夹中，您可以设置以下文件夹结构:</p><pre class="md me mf mg gt mq mr ms mt aw mu bi"><span id="0a15" class="mv lb it mr b gy mw mx l my mz">├── components<br/>├── containers<br/>├── contexts<br/>├── custom-types<br/>└── utils</span></pre><p id="7eca" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> utils </strong>文件夹是我们的定制钩子、常量和辅助函数所在的地方。现在，我们将在一个名为的文件中添加一个助手函数，你猜对了😄，<strong class="kd iu"> Helpers.ts </strong>。当我们想要发出API请求时，这个实用函数将被导入和调用。</p><pre class="md me mf mg gt mq mr ms mt aw mu bi"><span id="53e8" class="mv lb it mr b gy mw mx l my mz">/**<br/> * API Request handler<br/> * <a class="ae kz" href="http://twitter.com/param" rel="noopener ugc nofollow" target="_blank">@param</a> url - api endpoint<br/> * <a class="ae kz" href="http://twitter.com/param" rel="noopener ugc nofollow" target="_blank">@param</a> method - http method<br/> * <a class="ae kz" href="http://twitter.com/param" rel="noopener ugc nofollow" target="_blank">@param</a> bodyParams - body parameters of request<br/> */</span><span id="5a9d" class="mv lb it mr b gy na mx l my mz">export const apiRequest = async (<br/>  url: string,<br/>  method: string,<br/>  bodyParams?: { email: string; password: string }<br/>): Promise&lt;any&gt; =&gt; {<br/>  const response = await fetch(url, {<br/>    method,<br/>    headers: {<br/>      Accept: "application/json",<br/>      "Content-Type": "application/json"<br/>    },<br/>    body: bodyParams ? JSON.stringify(bodyParams) : undefined<br/>  });</span><span id="d227" class="mv lb it mr b gy na mx l my mz">return await response.json();<br/>};</span></pre><p id="9cee" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在<strong class="kd iu">组件</strong>文件夹中，您可以创建一个<strong class="kd iu"> Styles.tsx </strong>文件，并添加我们将在整个应用程序中使用的以下样式组件:</p><pre class="md me mf mg gt mq mr ms mt aw mu bi"><span id="6a5a" class="mv lb it mr b gy mw mx l my mz">import styled from "styled-components";</span><span id="b0d9" class="mv lb it mr b gy na mx l my mz">export const Wrapper = styled.div`<br/>  height: 100vh;<br/>  display: flex;<br/>  align-items: center;<br/>  justify-content: center;<br/>  &amp; button {<br/>    background: rgba(51, 51, 255, 1) !important;<br/>  }<br/>`;</span><span id="7f18" class="mv lb it mr b gy na mx l my mz">export const ToDoContainer = styled.div`<br/>  width: 400px;<br/>`;</span><span id="1607" class="mv lb it mr b gy na mx l my mz">export const ToDoItem = styled.div`<br/>  text-align: center;<br/>  font-weight: bold;<br/>  cursor: pointer;<br/>  text-decoration: ${(props: { complete?: boolean }) =&gt;<br/>    props.complete ? "line-through" : "none"};<br/>`;</span><span id="bd7e" class="mv lb it mr b gy na mx l my mz">export const JokeContainer = styled.div`<br/>  padding: 30px;<br/>  text-align: center;<br/>`;</span><span id="6185" class="mv lb it mr b gy na mx l my mz">export const Header = styled.h4`<br/>  text-transform: capitalize;<br/>  letter-spacing: 1px;<br/>  font-weight: bold;<br/>  text-align: center;<br/>`;</span><span id="0b02" class="mv lb it mr b gy na mx l my mz">export const Input = styled.input`<br/>  width: 100%;<br/>  border: 1px solid #f2f2f2;<br/>  padding: 10px;<br/>  margin-bottom: 10px;<br/>`;</span></pre><p id="3b37" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一旦你完成了这些，你就可以在<strong class="kd iu">容器</strong>文件夹中添加一个根容器(<strong class="kd iu"> RootContainer.tsx </strong>)。现在它将是一个基本的功能组件，但是稍后我们将向它添加更多的逻辑。</p><pre class="md me mf mg gt mq mr ms mt aw mu bi"><span id="3726" class="mv lb it mr b gy mw mx l my mz">import * as React from "react";</span><span id="bd24" class="mv lb it mr b gy na mx l my mz">/** Presentation */<br/>import { Wrapper } from "../components/Styles";</span><span id="4269" class="mv lb it mr b gy na mx l my mz">import Login from "./Login";</span><span id="87c1" class="mv lb it mr b gy na mx l my mz">function RootContainer(){<br/>  return (<br/>    &lt;Wrapper&gt;<br/>      &lt;Login /&gt;<br/>    &lt;/Wrapper&gt;<br/>  );<br/>};</span><span id="ef7f" class="mv lb it mr b gy na mx l my mz">export default RootContainer;</span></pre><p id="bcbd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我知道你在想什么，“钩子在哪里？”那么，不要再浪费时间了…</p><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="nb mi l"/></div></figure><h1 id="b22b" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated"><strong class="ak">使用状态钩子(useState) </strong></h1><p id="f604" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">使用状态钩子允许我们给功能组件添加状态。它返回一个状态值和一个更新该值的函数。我们通过<a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment" rel="noopener ugc nofollow" target="_blank">析构赋值</a>语法来使用它，就像我们对其他钩子所做的一样。你会注意到在下面的例子中，我们可以通过向<em class="mk"> useState </em>钩子传递一个值来设置初始状态。</p><pre class="md me mf mg gt mq mr ms mt aw mu bi"><span id="02e3" class="mv lb it mr b gy mw mx l my mz">const [state, setState] = useState(initialState);</span></pre><p id="d810" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们继续在containers文件夹中创建一个函数组件<strong class="kd iu"> Login.tsx </strong>，我们将在其中管理<em class="mk">用户名</em>、<em class="mk">密码</em>和<em class="mk">加载</em>(用于提交登录表单时)的状态值，如下所示:</p><pre class="md me mf mg gt mq mr ms mt aw mu bi"><span id="317e" class="mv lb it mr b gy mw mx l my mz">import * as React from "react";<br/>import { Button, Form, FormGroup, Input } from "reactstrap";</span><span id="3e04" class="mv lb it mr b gy na mx l my mz">/** Utils */<br/>import { Header } from "../components/Styles";</span><span id="e65f" class="mv lb it mr b gy na mx l my mz">function Login() {<br/>  const [userEmail, setUserEmail] = React.useState("");<br/>  const [userPassword, setUserPassword] = React.useState("");<br/>  const [loading, setLoading] = React.useState(false);</span><span id="dd7b" class="mv lb it mr b gy na mx l my mz">return (<br/>    &lt;Form<br/>      onSubmit={e =&gt; {<br/>        e.preventDefault();<br/>        // Auth handler<br/>      }}<br/>    &gt;<br/>      &lt;Header&gt;Sign in&lt;/Header&gt;<br/>      &lt;br /&gt;<br/>      &lt;FormGroup&gt;<br/>        &lt;Input<br/>          type="email"<br/>          name="email"<br/>          value={userEmail}<br/>          placeholder="<a class="ae kz" href="mailto:john@mail.com" rel="noopener ugc nofollow" target="_blank">john@mail.com</a>"<br/>          onChange={e =&gt; setUserEmail(e.target.value)}<br/>        /&gt;<br/>      &lt;/FormGroup&gt;<br/>      &lt;FormGroup&gt;<br/>        &lt;Input<br/>          type="password"<br/>          name="password"<br/>          value={userPassword}<br/>          placeholder="Password"<br/>          onChange={e =&gt; setUserPassword(e.target.value)}<br/>        /&gt;<br/>      &lt;/FormGroup&gt;<br/>      &lt;Button type="submit" disabled={loading} block={true}&gt;<br/>        {loading ? "Loading..." : "Sign In"}<br/>      &lt;/Button&gt;<br/>    &lt;/Form&gt;<br/>  );<br/>}</span><span id="6ff3" class="mv lb it mr b gy na mx l my mz">export default Login;</span></pre><p id="17aa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们已经有了我们的登录表单、我们需要的两个输入字段以及每次在输入字段中检测到变化时更新的状态值。</p><p id="3805" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，如果我们遇到错误(例如，有人试图用无效的用户名或密码提交表单)，会发生什么？当然，我们应该有一些处理这个问题的逻辑，以及向用户显示反馈的消息。在我们开始在这个组件中实现那个逻辑之前，错误处理，就像在大多数应用程序中一样，是我们可能在不止一个地方做的事情。那么为什么不创造一些可重复使用的东西呢？这是我们探索定制钩子的完美继续。</p><h1 id="db0d" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated"><strong class="ak">使用自定义挂钩(使用…) </strong></h1><p id="96b1" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">自定义挂钩允许我们轻松地跨组件共享逻辑，我认为这是许多开发人员将会爱上❤️的东西，我当然有。</p><p id="7765" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你可能想知道为什么我选择在接触其他核心钩子之前直接跳到定制钩子。首先，你不需要担心陡峭的学习曲线或任何主要的语法差异。其次，这是我们正在构建的应用程序的下一个逻辑步骤。第三，它让我们有机会创建一个定制钩子，利用我们刚刚学习的第一个core React钩子，<em class="mk"> useState </em>。</p><p id="188b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">定制钩子只是处理特定逻辑的简单函数，以减少复杂性和重复。这些函数允许我们利用核心React钩子并提取组件逻辑。</p><p id="c4cf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">需要记住的重要一点是，React挂钩的规则仍然适用于它们。</p><p id="507c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，让我们创建我们的第一个自定义钩子，它将在我们的应用程序中处理错误。在<strong class="kd iu"> utils </strong>文件夹中，创建另一个名为<strong class="kd iu"> custom-hooks </strong>的文件夹，我们将在其中添加<strong class="kd iu"> ErrorHandler.tsx </strong>。</p><pre class="md me mf mg gt mq mr ms mt aw mu bi"><span id="1ef1" class="mv lb it mr b gy mw mx l my mz">import * as React from "react";</span><span id="fe62" class="mv lb it mr b gy na mx l my mz">const useErrorHandler = (initialState: string | null) =&gt; {<br/>  const [error, setError] = React.useState(initialState);<br/>  const showError = (errorMessage: string | null) =&gt; {<br/>    setError(errorMessage);<br/>    window.setTimeout(() =&gt; {<br/>      setError(null);<br/>    }, 3000);<br/>  };<br/>  return { error, showError };<br/>};</span><span id="5398" class="mv lb it mr b gy na mx l my mz">export default useErrorHandler;</span></pre><p id="ebc9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里发生了什么事🤔？</p><p id="2f67" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，我们利用<em class="mk"> useState </em>钩子来获得一个错误的状态值和一个更新该值的函数。接下来，我们有一个名为<em class="mk"> showError </em>的函数，它接收一个<em class="mk"> errorMessage </em>参数，通过利用<em class="mk"> setError </em>更新函数来更新错误状态值。在设置错误值以便用户可以看到后，它利用<em class="mk"> setTimeout </em>函数在3秒后将错误值重置回null。您可以随意更改错误信息显示的持续时间。</p><p id="bf61" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们希望从这个自定义钩子中得到的只是错误消息的值和处理错误消息设置和重置的函数，因此我们只导出<em class="mk"> error </em>和<em class="mk"> showError </em>。</p><p id="433b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当我们将它导入到我们的<strong class="kd iu"> Login.tsx </strong>容器中时，会是什么样子呢？</p><pre class="md me mf mg gt mq mr ms mt aw mu bi"><span id="fab7" class="mv lb it mr b gy mw mx l my mz">const { error, showError } = useErrorHandler(null);</span></pre><p id="afbe" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我们将所有这些放在一起之前，让我们添加一个演示组件，在components文件夹中显示我们的错误消息。可以命名为<strong class="kd iu"> ErrorMessage.tsx </strong>(好原创)。该组件将包含以下内容:</p><pre class="md me mf mg gt mq mr ms mt aw mu bi"><span id="2c62" class="mv lb it mr b gy mw mx l my mz">import * as React from "react";<br/>import styled from "styled-components";</span><span id="ab62" class="mv lb it mr b gy na mx l my mz">const ErrorMessage = styled.p`<br/>  text-align: center;<br/>  margin-top: 10px;<br/>  color: #ff0000;<br/>`;</span><span id="106e" class="mv lb it mr b gy na mx l my mz">const ErrorMessageContainer: React.FC&lt;{ errorMessage: string | null }&gt; = ({<br/>  errorMessage<br/>}) =&gt; {<br/>  return &lt;ErrorMessage&gt;{errorMessage}&lt;/ErrorMessage&gt;;<br/>};</span><span id="8a28" class="mv lb it mr b gy na mx l my mz">export default ErrorMessageContainer;</span></pre><p id="4787" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们还想添加验证用户在登录表单上提交的用户名(电子邮件)和密码的功能，所以让我们在名为<em class="mk"> validateLoginForm </em>的<strong class="kd iu"> Helpers.ts </strong>文件中包含另一个函数。</p><pre class="md me mf mg gt mq mr ms mt aw mu bi"><span id="7b7b" class="mv lb it mr b gy mw mx l my mz">import * as validator from "validator";</span><span id="0e5e" class="mv lb it mr b gy na mx l my mz">/** Handle form validation for the login form<br/> * <a class="ae kz" href="http://twitter.com/param" rel="noopener ugc nofollow" target="_blank">@param</a> email - user's auth email<br/> * <a class="ae kz" href="http://twitter.com/param" rel="noopener ugc nofollow" target="_blank">@param</a> password - user's auth password<br/> * <a class="ae kz" href="http://twitter.com/param" rel="noopener ugc nofollow" target="_blank">@param</a> setError - function that handles updating error state value<br/> */<br/>export const validateLoginForm = (<br/>  email: string,<br/>  password: string,<br/>  setError: (error: string | null) =&gt; void<br/>): boolean =&gt; {<br/>  // Check for undefined or empty input fields<br/>  if (!email || !password) {<br/>    setError("Please enter a valid email and password.");<br/>    return false;<br/>  }</span><span id="8e72" class="mv lb it mr b gy na mx l my mz">// Validate email<br/>  if (!validator.isEmail(email)) {<br/>    setError("Please enter a valid email address.");<br/>    return false;<br/>  }</span><span id="90f1" class="mv lb it mr b gy na mx l my mz">return true;<br/>};</span></pre><p id="7e9b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们没有后端来检查用户是否存在于任何真实的数据库中，所以我们只是在每次用户点击登录时向一个假的REST API发送一个带有用户名和密码的POST请求。我们将在本例中使用的假REST API是<a class="ae kz" href="https://jsonplaceholder.typicode.com/" rel="noopener ugc nofollow" target="_blank"> JSONPlaceholder </a>。</p><p id="767e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在让我们一起来…</p><pre class="md me mf mg gt mq mr ms mt aw mu bi"><span id="50ea" class="mv lb it mr b gy mw mx l my mz">import * as React from "react";<br/>import { Button, Form, FormGroup, Input } from "reactstrap";</span><span id="36ed" class="mv lb it mr b gy na mx l my mz">/** Presentation */<br/>import ErrorMessage from "../components/ErrorMessage";</span><span id="71f1" class="mv lb it mr b gy na mx l my mz">/** Custom Hooks */<br/>import useErrorHandler from "../utils/custom-hooks/ErrorHandler";</span><span id="4758" class="mv lb it mr b gy na mx l my mz">/** Utils */<br/>import { apiRequest, validateLoginForm } from "../utils/Helpers";<br/>import { Header } from "../components/Styles";</span><span id="b0e6" class="mv lb it mr b gy na mx l my mz">function Login() {<br/>  const [userEmail, setUserEmail] = React.useState("");<br/>  const [userPassword, setUserPassword] = React.useState("");<br/>  const [loading, setLoading] = React.useState(false);<br/>  const { error, showError } = useErrorHandler(null);</span><span id="6a94" class="mv lb it mr b gy na mx l my mz">const authHandler = async () =&gt; {<br/>    try {<br/>      setLoading(true);<br/>      const userData = await apiRequest(<br/>        "<a class="ae kz" href="https://jsonplaceholder.typicode.com/users" rel="noopener ugc nofollow" target="_blank">https://jsonplaceholder.typicode.com/users</a>",<br/>        "post",<br/>        { email: userEmail, password: userPassword }<br/>      );<br/>      const { id, email } = userData;<br/>    } catch (err) {<br/>      setLoading(false);<br/>      showError(err.message);<br/>    }<br/>  };</span><span id="fd25" class="mv lb it mr b gy na mx l my mz">return (<br/>    &lt;Form<br/>      onSubmit={e =&gt; {<br/>        e.preventDefault();<br/>        if (validateLoginForm(userEmail, userPassword, showError)) {<br/>          authHandler();<br/>        }<br/>      }}<br/>    &gt;<br/>      &lt;Header&gt;Sign in&lt;/Header&gt;<br/>      &lt;br /&gt;<br/>      &lt;FormGroup&gt;<br/>        &lt;Input<br/>          type="email"<br/>          name="email"<br/>          value={userEmail}<br/>          placeholder="<a class="ae kz" href="mailto:john@mail.com" rel="noopener ugc nofollow" target="_blank">john@mail.com</a>"<br/>          onChange={e =&gt; setUserEmail(e.target.value)}<br/>        /&gt;<br/>      &lt;/FormGroup&gt;<br/>      &lt;FormGroup&gt;<br/>        &lt;Input<br/>          type="password"<br/>          name="password"<br/>          value={userPassword}<br/>          placeholder="Password"<br/>          onChange={e =&gt; setUserPassword(e.target.value)}<br/>        /&gt;<br/>      &lt;/FormGroup&gt;<br/>      &lt;Button type="submit" disabled={loading} block={true}&gt;<br/>        {loading ? "Loading..." : "Sign In"}<br/>      &lt;/Button&gt;<br/>      &lt;br /&gt;<br/>      {error &amp;&amp; &lt;ErrorMessage errorMessage={error} /&gt;}<br/>    &lt;/Form&gt;<br/>  );<br/>}</span><span id="c201" class="mv lb it mr b gy na mx l my mz">export default Login;</span></pre><figure class="md me mf mg gt ju gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/c0f0f1780dce7285ab8e24984dfe1524.png" data-original-src="https://miro.medium.com/v2/resize:fit:972/format:webp/1*pl75nh7QJQSGzZCBmBGGRQ.png"/></div></figure><p id="8693" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们已经被“认证”了，我们如何处理我们的假REST API返回的id和email呢？此外，我们如何使这个认证状态对我们的应用程序的其余部分可用？是时候进入<em class="mk"> useContext </em>钩子了。</p><h1 id="066f" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated"><strong class="ak">使用上下文挂钩(useContext) </strong></h1><p id="bda7" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">上下文API允许我们围绕组件树传递和访问全局状态，而不必一直作为道具传递下去。嵌套在上下文提供程序中的任何组件都可以进入上下文并检索状态值，以及对可以作用于状态的函数的引用。</p><p id="e57a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以调用<em class="mk"> useContext </em>钩子来访问上下文。然而，正如你可能知道的，我们的应用程序中可以有不同的上下文，所以我们需要一种方法来识别我们想要利用的上下文。为此，导入上下文并将其作为参数传递给useContext函数，如下所示:</p><pre class="md me mf mg gt mq mr ms mt aw mu bi"><span id="e949" class="mv lb it mr b gy mw mx l my mz">import { authContext } from "../contexts/AuthContext";</span><span id="cef1" class="mv lb it mr b gy na mx l my mz">const auth = React.useContext(authContext);</span></pre><p id="8b22" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于我们的应用程序，我将把我的上下文设置为一个JavaScript对象，它保存当前的身份验证状态，还保存对使我们能够更改身份验证状态的函数的引用。</p><p id="1148" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，我将为用户认证状态创建一个静态类型，并将该类型放在<strong class="kd iu">自定义类型</strong>文件夹中的<strong class="kd iu"> index.ts </strong>文件中。<em class="mk"> UserAuth </em>类型将为登录的用户提供一个id和email属性。</p><pre class="md me mf mg gt mq mr ms mt aw mu bi"><span id="18b2" class="mv lb it mr b gy mw mx l my mz">export type UserAuth = {<br/>  id: number;<br/>  email: string;<br/>};</span></pre><p id="285c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我还想为未经验证的用户设置一个默认状态，它将位于<strong class="kd iu"> utils </strong>文件夹的<strong class="kd iu"> Consts.ts </strong>文件中。</p><pre class="md me mf mg gt mq mr ms mt aw mu bi"><span id="c062" class="mv lb it mr b gy mw mx l my mz">export const DEFAULT_USER_AUTH = { id: 0, email: "" };</span></pre><p id="9d5e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我们开始应用<em class="mk"> useContext </em>之前，我们将创建另一个定制钩子，它将包含设置和重置认证状态的逻辑。我将调用这个文件<strong class="kd iu"> AuthHandler.tsx </strong>并将其保存在<strong class="kd iu"> custom-hooks </strong>文件夹中。</p><pre class="md me mf mg gt mq mr ms mt aw mu bi"><span id="581d" class="mv lb it mr b gy mw mx l my mz">import * as React from "react";</span><span id="28db" class="mv lb it mr b gy na mx l my mz">/** Custom types */<br/>import { UserAuth } from "../../custom-types";</span><span id="fd03" class="mv lb it mr b gy na mx l my mz">/** Utils */<br/>import { DEFAULT_USER_AUTH } from "../Consts";</span><span id="9a5f" class="mv lb it mr b gy na mx l my mz">const useAuthHandler = (initialState: UserAuth) =&gt; {<br/>  const [auth, setAuth] = React.useState(initialState);</span><span id="0d91" class="mv lb it mr b gy na mx l my mz">const setAuthStatus = (userAuth: UserAuth) =&gt; {<br/>    window.localStorage.setItem("UserAuth", JSON.stringify(userAuth));<br/>    setAuth(userAuth);<br/>  };</span><span id="6612" class="mv lb it mr b gy na mx l my mz">const setUnauthStatus = () =&gt; {<br/>    window.localStorage.clear();<br/>    setAuth(DEFAULT_USER_AUTH);<br/>  };</span><span id="ce8c" class="mv lb it mr b gy na mx l my mz">return {<br/>    auth,<br/>    setAuthStatus,<br/>    setUnauthStatus<br/>  };<br/>};</span><span id="8a79" class="mv lb it mr b gy na mx l my mz">export default useAuthHandler;</span></pre><p id="f8fa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您可能已经注意到，我们不仅在应用程序的state中更新auth status的值，而且在我们的<a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage" rel="noopener ugc nofollow" target="_blank">本地存储</a>中也是如此。原因是，如果你还没有猜到，我们不想在浏览器刷新时丢失我们的auth状态的值。因此，我将继续创建另一个助手函数来添加到<strong class="kd iu"> Helpers.ts </strong>文件中，该文件从本地存储中检索用户的auth值。</p><pre class="md me mf mg gt mq mr ms mt aw mu bi"><span id="e771" class="mv lb it mr b gy mw mx l my mz">/** Return user auth from local storage value */<br/>export const getStoredUserAuth = (): UserAuth =&gt; {<br/>  const auth = window.localStorage.getItem("UserAuth");<br/>  if (auth) {<br/>    return JSON.parse(auth);<br/>  }<br/>  return DEFAULT_USER_AUTH;<br/>};</span></pre><p id="939d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们已经解决了这个问题，让我们创建我们的auth上下文并导出它的提供者！您可以在<strong class="kd iu">上下文</strong>文件夹中添加<strong class="kd iu"> AuthContext.tsx </strong>文件。</p><pre class="md me mf mg gt mq mr ms mt aw mu bi"><span id="56d0" class="mv lb it mr b gy mw mx l my mz">import * as React from "react";</span><span id="d76e" class="mv lb it mr b gy na mx l my mz">/** Custom types */<br/>import { UserAuth } from "../custom-types";<br/>/** Custom Hooks */<br/>import useAuthHandler from "../utils/custom-hooks/AuthHandler";<br/>/** Utils */<br/>import { DEFAULT_USER_AUTH } from "../utils/Consts";<br/>import { getStoredUserAuth } from "../utils/Helpers";</span><span id="8904" class="mv lb it mr b gy na mx l my mz">interface IAuthContextInterface {<br/>  auth: UserAuth;<br/>  setAuthStatus: (userAuth: UserAuth) =&gt; void;<br/>  setUnauthStatus: () =&gt; void;<br/>}</span><span id="a6cc" class="mv lb it mr b gy na mx l my mz">export const authContext = React.createContext&lt;IAuthContextInterface&gt;({<br/>  auth: DEFAULT_USER_AUTH,<br/>  setAuthStatus: () =&gt; {},<br/>  setUnauthStatus: () =&gt; {}<br/>});</span><span id="de4d" class="mv lb it mr b gy na mx l my mz">const { Provider } = authContext;</span><span id="b867" class="mv lb it mr b gy na mx l my mz">const AuthProvider: React.FC&lt;{ children: React.ReactNode }&gt; = ({<br/>  children<br/>}) =&gt; {<br/>  const { auth, setAuthStatus, setUnauthStatus } = useAuthHandler(<br/>    getStoredUserAuth()<br/>  );</span><span id="3728" class="mv lb it mr b gy na mx l my mz">return (<br/>    &lt;Provider value={{ auth, setAuthStatus, setUnauthStatus }}&gt;<br/>      {children}<br/>    &lt;/Provider&gt;<br/>  );<br/>};</span><span id="14e8" class="mv lb it mr b gy na mx l my mz">export default AuthProvider;</span></pre><p id="5158" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">完成后，我们需要做两件事:</p><ol class=""><li id="dfb5" class="nd ne it kd b ke kf ki kj km nf kq ng ku nh ky ni nj nk nl bi translated">从我们的auth上下文将我们的应用程序组件包装在AuthProvider中。</li><li id="651a" class="nd ne it kd b ke nm ki nn km no kq np ku nq ky ni nj nk nl bi translated">一旦用户登录，进入身份验证上下文并在登录组件中设置用户的身份验证状态。</li></ol><p id="5820" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> App.tsx </strong></p><pre class="md me mf mg gt mq mr ms mt aw mu bi"><span id="4888" class="mv lb it mr b gy mw mx l my mz">import * as React from "react";</span><span id="e934" class="mv lb it mr b gy na mx l my mz">import RootContainer from "./containers/RootContainer";</span><span id="776c" class="mv lb it mr b gy na mx l my mz">/** Context API */<br/>import AuthContextProvider from "./contexts/AuthContext";</span><span id="100a" class="mv lb it mr b gy na mx l my mz">function App() {<br/>  return (<br/>    &lt;AuthContextProvider&gt;<br/>      &lt;RootContainer /&gt;<br/>    &lt;/AuthContextProvider&gt;<br/>  );<br/>}</span><span id="12e0" class="mv lb it mr b gy na mx l my mz">export default App;</span></pre><p id="f9f1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> Login.tsx </strong></p><pre class="md me mf mg gt mq mr ms mt aw mu bi"><span id="61b6" class="mv lb it mr b gy mw mx l my mz">import * as React from "react";<br/>import { Button, Form, FormGroup, Input } from "reactstrap";</span><span id="b354" class="mv lb it mr b gy na mx l my mz">/** Presentation */<br/>import ErrorMessage from "../components/ErrorMessage";</span><span id="769e" class="mv lb it mr b gy na mx l my mz">/** Custom Hooks */<br/>import useErrorHandler from "../utils/custom-hooks/ErrorHandler";</span><span id="66f6" class="mv lb it mr b gy na mx l my mz">/** Context */<br/>import { authContext } from "../contexts/AuthContext";</span><span id="8a07" class="mv lb it mr b gy na mx l my mz">/** Utils */<br/>import { apiRequest, validateLoginForm } from "../utils/Helpers";<br/>import { Header } from "../components/Styles";</span><span id="e748" class="mv lb it mr b gy na mx l my mz">function Login() {<br/>  const [userEmail, setUserEmail] = React.useState("");<br/>  const [userPassword, setUserPassword] = React.useState("");<br/>  const [loading, setLoading] = React.useState(false);<br/>  const auth = React.useContext(authContext);<br/>  const { error, showError } = useErrorHandler(null);</span><span id="e7bc" class="mv lb it mr b gy na mx l my mz">const authHandler = async () =&gt; {<br/>    try {<br/>      setLoading(true);<br/>      const userData = await apiRequest(<br/>        "<a class="ae kz" href="https://jsonplaceholder.typicode.com/users" rel="noopener ugc nofollow" target="_blank">https://jsonplaceholder.typicode.com/users</a>",<br/>        "post",<br/>        { email: userEmail, password: userPassword }<br/>      );<br/>      const { id, email } = userData;<br/>      auth.setAuthStatus({ id, email });<br/>    } catch (err) {<br/>      setLoading(false);<br/>      showError(err.message);<br/>    }<br/>  };</span><span id="cc2e" class="mv lb it mr b gy na mx l my mz">return (<br/>    &lt;Form<br/>      onSubmit={e =&gt; {<br/>        e.preventDefault();<br/>        if (validateLoginForm(userEmail, userPassword, showError)) {<br/>          authHandler();<br/>        }<br/>      }}<br/>    &gt;<br/>      &lt;Header&gt;Sign in&lt;/Header&gt;<br/>      &lt;br /&gt;<br/>      &lt;FormGroup&gt;<br/>        &lt;Input<br/>          type="email"<br/>          name="email"<br/>          value={userEmail}<br/>          placeholder="<a class="ae kz" href="mailto:john@mail.com" rel="noopener ugc nofollow" target="_blank">john@mail.com</a>"<br/>          onChange={e =&gt; setUserEmail(e.target.value)}<br/>        /&gt;<br/>      &lt;/FormGroup&gt;<br/>      &lt;FormGroup&gt;<br/>        &lt;Input<br/>          type="password"<br/>          name="password"<br/>          value={userPassword}<br/>          placeholder="Password"<br/>          onChange={e =&gt; setUserPassword(e.target.value)}<br/>        /&gt;<br/>      &lt;/FormGroup&gt;<br/>      &lt;Button type="submit" disabled={loading} block={true}&gt;<br/>        {loading ? "Loading..." : "Sign In"}<br/>      &lt;/Button&gt;<br/>      &lt;br /&gt;<br/>      {error &amp;&amp; &lt;ErrorMessage errorMessage={error} /&gt;}<br/>    &lt;/Form&gt;<br/>  );<br/>}</span><span id="bde3" class="mv lb it mr b gy na mx l my mz">export default Login;</span></pre></div><div class="ab cl nr ns hx nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="im in io ip iq"><p id="b5c1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你再看一下我们的待办事项应用的界面截图，你会注意到恰克·诺里斯的一个笑话就在标题“我的待办事项列表”下面。我们希望在写下要做的事情之前，确保我们的一天从微笑开始，所以让我们确保一个随机的笑话出现在我们的表单上方。为了构建这个，我们将使用<em class="mk"> useEffect </em>钩子。</p><h1 id="a9c2" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated"><strong class="ak">使用效果挂钩(useEffect) </strong></h1><p id="fbbe" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated"><em class="mk"> useEffect </em>钩子有两个参数，第一个是在每次渲染后执行(或被调用)的函数。该函数将在组件挂载和更新时运行。此外，如果您想要与<a class="ae kz" href="https://reactjs.org/docs/react-component.html#componentwillunmount" rel="noopener ugc nofollow" target="_blank"><em class="mk">component will unmount</em></a>给我们相同的组件清理功能，您可以从<em class="mk"> useEffect </em>钩子内部返回一个函数，它将使用该函数进行清理。</p><p id="cc3f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">第二个论点呢？您可以选择提供一个输入数组。如果是这样，该效果将只在那些输入已经改变的渲染之后运行。需要注意的是，如果不提供第二个参数，第一个参数中的函数(或效果)将在组件每次渲染后运行。第二个参数的另一个选项是提供一个空数组，这意味着只在挂载和卸载时运行。</p><pre class="md me mf mg gt mq mr ms mt aw mu bi"><span id="dd99" class="mv lb it mr b gy mw mx l my mz">const [todos, updateTodos] = useState([])</span><span id="2eee" class="mv lb it mr b gy na mx l my mz">// Only execute on mount<br/>useEffect(() =&gt; {<br/>  window.localStorage.setItem(‘todos’, JSON.stringify(todos))<br/>}, [])</span><span id="52db" class="mv lb it mr b gy na mx l my mz">// Execute when there’s been a change in our todos list (componentDidUpdate):<br/>useEffect(() =&gt; {<br/>  window.localStorage.setItem(‘todos’, JSON.stringify(todos))<br/>}, [todos])</span><span id="a8ee" class="mv lb it mr b gy na mx l my mz">// Execute clean up function on unmount<br/>useEffect(() =&gt; {<br/>  return () =&gt; { console.log(‘Clean up function’) }<br/>}, [])</span></pre><p id="0825" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">好了，让我们在<strong class="kd iu">容器</strong>文件夹中创建一个名为<strong class="kd iu"> RandomJoke.tsx </strong>的组件，并从<a class="ae kz" href="https://github.com/sameerkumar18/geek-joke-api" rel="noopener ugc nofollow" target="_blank">随机极客笑话REST API </a>中调用一个随机笑话，它将显示在我们的待办事项列表上方。我们只希望在组件挂载时发出一次请求，所以我们将为第二个参数传递一个空数组，用于我们的<em class="mk"> useEffect </em>钩子。</p><pre class="md me mf mg gt mq mr ms mt aw mu bi"><span id="7c4b" class="mv lb it mr b gy mw mx l my mz">import * as React from "react";</span><span id="f082" class="mv lb it mr b gy na mx l my mz">/** Presentation/UI */<br/>import { JokeContainer } from "../components/Styles";<br/>/** Utils */<br/>import { apiRequest } from "../utils/Helpers";</span><span id="0f23" class="mv lb it mr b gy na mx l my mz">const RandomJoke: React.FC&lt;{}&gt; = () =&gt; {<br/>  const [joke, setJoke] = React.useState("");<br/>  const [loading, setLoading] = React.useState(false);</span><span id="27b3" class="mv lb it mr b gy na mx l my mz">React.useEffect(() =&gt; {<br/>    const getRandomJoke = async () =&gt; {<br/>      setLoading(true);<br/>      const joke = await apiRequest(<br/>        "<a class="ae kz" href="https://geek-jokes.sameerkumar.website/api" rel="noopener ugc nofollow" target="_blank">https://geek-jokes.sameerkumar.website/api</a>",<br/>        "get"<br/>      );<br/>      setLoading(false);<br/>      setJoke(joke);<br/>    };<br/>    getRandomJoke();<br/>  }, []);</span><span id="76f1" class="mv lb it mr b gy na mx l my mz">return (<br/>    &lt;JokeContainer&gt;<br/>      {loading ? "Why so serious, let's put a smile on your face :)" : joke}<br/>    &lt;/JokeContainer&gt;<br/>  );<br/>};</span><span id="a7ef" class="mv lb it mr b gy na mx l my mz">export default RandomJoke;</span></pre><p id="4022" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这应该会让我们大笑，但可能不会像这个人那样努力…</p><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="ny mi l"/></div></figure><p id="76bc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们继续创建用于填充待办事项列表的表单。对于下一部分，我们将使用<em class="mk"> useRef </em>钩子。</p><h1 id="9276" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated"><strong class="ak">使用Ref钩子(useRef) </strong></h1><p id="6fd0" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">当我们使用基于类的组件时，我们可以使用引用与页面上的DOM元素进行交互。在钩子出现之前，这是我们不能在函数组件中做的事情，因为它们没有可以用来存储引用的属性。</p><p id="e665" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">继续在名为<strong class="kd iu"> AddToDo.tsx </strong>的文件中创建一个函数组件。我们将创建一个引用，将其存储在一个名为<em class="mk"> textInput </em>的常量中。您可以选择为这个引用设置一个初始值，我将把它设置为<em class="mk"> null </em>。一旦我们将<em class="mk"> textInput </em>添加到输入JSX元素的ref属性中，对输入字段的引用就存储在常量中。</p><pre class="md me mf mg gt mq mr ms mt aw mu bi"><span id="a84b" class="mv lb it mr b gy mw mx l my mz">const textInput = React.useRef&lt;HTMLInputElement&gt;(null);</span></pre><p id="0665" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将使用input元素的内部状态管理，并在需要时使用ref提取其当前值。</p><p id="6c57" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">要获得input元素的值，可以使用<em class="mk"> textInput </em>，它返回一个对象，该对象的属性引用相关的HTML元素。像这样:</p><pre class="md me mf mg gt mq mr ms mt aw mu bi"><span id="1c8d" class="mv lb it mr b gy mw mx l my mz">const toDo = textInput.current.value;</span></pre><p id="f152" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当前属性保存实际的HTML元素引用。在<em class="mk"> current </em>上，您可以访问value，因为它指向input元素，并且JavaScript中的input元素有一个value字段，这是它们的当前值。</p><p id="d0af" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们添加一个新的“待办事项”项的组件将如下所示:</p><pre class="md me mf mg gt mq mr ms mt aw mu bi"><span id="0f30" class="mv lb it mr b gy mw mx l my mz">import * as React from "react";<br/>import { Button, Form } from "reactstrap";</span><span id="bb4a" class="mv lb it mr b gy na mx l my mz">/** Presentation */<br/>import ErrorMessage from "../components/ErrorMessage";<br/>import { Input } from "../components/Styles";<br/>/** Custom Hooks */<br/>import useErrorHandler from "../utils/custom-hooks/ErrorHandler";</span><span id="c406" class="mv lb it mr b gy na mx l my mz">const AddToDo: React.FC&lt;{}&gt; = () =&gt; {<br/>  const { error, showError } = useErrorHandler(null);<br/>  const textInput = React.useRef&lt;HTMLInputElement&gt;(null);</span><span id="92f3" class="mv lb it mr b gy na mx l my mz">const addNewToDoItem = () =&gt; {<br/>    if (textInput.current) {<br/>      const toDo = textInput.current.value;<br/>      console.log('Today I want to:', toDo);<br/>    } else {<br/>      showError("Please type an item before clicking add.");<br/>    }<br/>  };</span><span id="2053" class="mv lb it mr b gy na mx l my mz">return (<br/>    &lt;Form<br/>      onSubmit={e =&gt; {<br/>        e.preventDefault();<br/>        addNewToDoItem();<br/>      }}<br/>    &gt;<br/>      &lt;Input type="text" ref={textInput} placeholder="Add to do item" /&gt;<br/>      &lt;Button type="submit" block={true}&gt;<br/>        Add<br/>      &lt;/Button&gt;<br/>      &lt;br /&gt;<br/>      {error &amp;&amp; &lt;ErrorMessage errorMessage={error} /&gt;}<br/>    &lt;/Form&gt;<br/>  );<br/>};</span><span id="9261" class="mv lb it mr b gy na mx l my mz">export default AddToDo;</span></pre></div><div class="ab cl nr ns hx nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="im in io ip iq"><p id="ef0f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们已经完成了，我们希望能够存储、获取和更新待办事项列表中每个项目的状态，而不仅仅是在浏览器控制台中单独记录它们。为了实现这一点，我们将使用一个新的上下文和<em class="mk"> useReducer </em>钩子。</p><h1 id="4ad7" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated"><strong class="ak">使用减速钩(useReducer) </strong></h1><p id="0de4" class="pw-post-body-paragraph kb kc it kd b ke ly kg kh ki lz kk kl km ma ko kp kq mb ks kt ku mc kw kx ky im bi translated">如果你熟悉<a class="ae kz" href="https://medium.com/@outlier.developer/what-on-earth-is-redux-why-should-i-consider-it-for-my-react-app-1f68a76ed79b" rel="noopener"> Redux </a>，那么你大概知道什么是减速器。如果这是你第一次听说减速器，不用担心。</p><p id="756d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">缩减器是一个帮助我们管理应用程序状态的功能。它是一个纯粹的函数，在这个意义上，给定某个输入，它总是返回相同的输出。在reducer函数的情况下，它有两个参数，当前状态和一个动作。</p><pre class="md me mf mg gt mq mr ms mt aw mu bi"><span id="d7c8" class="mv lb it mr b gy mw mx l my mz">(state, action) =&gt; newState</span></pre><p id="ab8f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">动作是具有类型属性的对象，并且基于动作类型，缩减器执行特定的状态转换:</p><pre class="md me mf mg gt mq mr ms mt aw mu bi"><span id="111d" class="mv lb it mr b gy mw mx l my mz">const counterReducer = (count, action) =&gt; {<br/>  if (action.type === 'INCREASE') {<br/>    return count + 1;<br/>  }</span><span id="2bff" class="mv lb it mr b gy na mx l my mz">  if (action.type === 'DECREASE') {<br/>    return count - 1;<br/>  }</span><span id="f3df" class="mv lb it mr b gy na mx l my mz">  return count;<br/>};</span></pre><p id="f840" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在我们创建了我们的reducer之后，我们需要注册它并正确地使用它。为此，我们将其作为参数传递给<em class="mk"> useReducer </em>钩子。我们可以向useReducer钩子传递第二个参数，这将是我们的初始状态。然后我们使用与<em class="mk">使用状态</em>相同的析构语法。</p><pre class="md me mf mg gt mq mr ms mt aw mu bi"><span id="f32c" class="mv lb it mr b gy mw mx l my mz">const [count, dispatch] = useReducer(counterReducer, [])</span></pre><p id="4e62" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">是时候在我们的应用中实现它了。</p><p id="d9b7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们在<strong class="kd iu">自定义类型</strong>文件夹中的<strong class="kd iu"> index.ts </strong>文件中创建一些静态类型。</p><pre class="md me mf mg gt mq mr ms mt aw mu bi"><span id="9cb8" class="mv lb it mr b gy mw mx l my mz">export type ToDoItemType = { id: string; toDo?: string; complete?: boolean };</span><span id="c55f" class="mv lb it mr b gy na mx l my mz">export enum ActionType {<br/>  add = "ADD",<br/>  delete = "DELETE",<br/>  updateStatus = "UPDATE"<br/>}</span></pre><p id="a7b4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，让我们在<strong class="kd iu">上下文</strong>文件夹中创建一个名为<strong class="kd iu"> ToDoContext.tsx </strong>的待办上下文。这个文件将包含我们的reducer，它处理管理待办事项列表状态的操作，以及允许我们访问状态值的上下文和对更新应用程序状态的函数的引用。</p><p id="3359" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们的reducer将处理向我们的待办事项列表数组添加项目:</p><pre class="md me mf mg gt mq mr ms mt aw mu bi"><span id="33b6" class="mv lb it mr b gy mw mx l my mz">case ActionType.add:<br/>  return {<br/>     toDoList: [...state.toDoList, action.payload]<br/>  };</span></pre><p id="06a0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">它将处理更新待办列表数组中项目的完成状态:</p><pre class="md me mf mg gt mq mr ms mt aw mu bi"><span id="8873" class="mv lb it mr b gy mw mx l my mz">case ActionType.updateStatus:<br/>  return {<br/>    toDoList: state.toDoList.map(toDo =&gt; {<br/>      if (toDo.id === action.payload.id) {<br/>        return { ...toDo, complete: !toDo.complete };<br/>      }<br/>      return toDo;<br/>    })<br/>  };</span></pre><p id="f4d9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后，它将处理从待办事项列表数组中删除一个项目:</p><pre class="md me mf mg gt mq mr ms mt aw mu bi"><span id="1e97" class="mv lb it mr b gy mw mx l my mz">case ActionType.delete:<br/>  return {<br/>     toDoList: state.toDoList.filter(toDo =&gt; toDo.id !== action.payload.id)<br/>  };</span></pre><p id="398b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> ToDoContext.tsx </strong></p><pre class="md me mf mg gt mq mr ms mt aw mu bi"><span id="088c" class="mv lb it mr b gy mw mx l my mz">import * as React from "react";</span><span id="7935" class="mv lb it mr b gy na mx l my mz">/** Custom types */<br/>import { ActionType } from "../custom-types";</span><span id="e1d3" class="mv lb it mr b gy na mx l my mz">interface IState {<br/>  toDoList: Array&lt;{ id: string; toDo?: string; complete?: boolean }&gt;;<br/>}</span><span id="a4ad" class="mv lb it mr b gy na mx l my mz">interface IAction {<br/>  type: ActionType;<br/>  payload: {<br/>    id: string;<br/>    toDo?: string;<br/>    complete?: boolean;<br/>  };<br/>}</span><span id="801b" class="mv lb it mr b gy na mx l my mz">interface ItoDoContextInterface {<br/>  state: {<br/>    toDoList: Array&lt;{ id: string; toDo?: string; complete?: boolean }&gt;;<br/>  };<br/>  updateToDoList: React.Dispatch&lt;IAction&gt;;<br/>}</span><span id="ca5e" class="mv lb it mr b gy na mx l my mz">const initialState: IState = { toDoList: [] };</span><span id="6ec6" class="mv lb it mr b gy na mx l my mz">const reducer: React.Reducer&lt;IState, IAction&gt; = (state, action) =&gt; {<br/>  switch (action.type) {<br/>    case ActionType.add:<br/>      return {<br/>        toDoList: [...state.toDoList, action.payload]<br/>      };<br/>    case ActionType.updateStatus:<br/>      return {<br/>        toDoList: state.toDoList.map(toDo =&gt; {<br/>          if (toDo.id === action.payload.id) {<br/>            return { ...toDo, complete: !toDo.complete };<br/>          }<br/>          return toDo;<br/>        })<br/>      };<br/>    case ActionType.delete:<br/>      return {<br/>        toDoList: state.toDoList.filter(toDo =&gt; toDo.id !== action.payload.id)<br/>      };<br/>    default:<br/>      throw new Error();<br/>  }<br/>};</span><span id="a5c4" class="mv lb it mr b gy na mx l my mz">export const toDoContext = React.createContext&lt;ItoDoContextInterface&gt;({<br/>  state: {<br/>    toDoList: []<br/>  },<br/>  updateToDoList: () =&gt; {}<br/>});</span><span id="0587" class="mv lb it mr b gy na mx l my mz">const { Provider } = toDoContext;</span><span id="df5f" class="mv lb it mr b gy na mx l my mz">const ToDoProvider: React.FC&lt;{ children: React.ReactNode }&gt; = ({<br/>  children<br/>}) =&gt; {<br/>  const [toDoList, updateToDoList] = React.useReducer(reducer, initialState);</span><span id="d8da" class="mv lb it mr b gy na mx l my mz">return (<br/>    &lt;Provider value={{ state: toDoList, updateToDoList }}&gt;<br/>      {children}<br/>    &lt;/Provider&gt;<br/>  );<br/>};</span><span id="1544" class="mv lb it mr b gy na mx l my mz">export default ToDoProvider;</span></pre><p id="6813" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你坐着感觉有点超负荷，不要紧张，因为最困难的部分已经过去了💪，我们快完成了。</p><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="nz mi l"/></div></figure><p id="8540" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们更新我们的AddToDo ( <strong class="kd iu"> AddToDo.tsx </strong>)组件，以便它接入我们刚刚创建的<strong class="kd iu"> toDoContext </strong>。</p><pre class="md me mf mg gt mq mr ms mt aw mu bi"><span id="0be2" class="mv lb it mr b gy mw mx l my mz">import * as React from "react";<br/>import { Button, Form } from "reactstrap";<br/>import uuid from "uuid";</span><span id="d5f9" class="mv lb it mr b gy na mx l my mz">/** Context */<br/>import { toDoContext } from "../contexts/ToDoContext";<br/>/** Presentation */<br/>import ErrorMessage from "../components/ErrorMessage";<br/>import { Input } from "../components/Styles";<br/>/** Custom Hooks */<br/>import useErrorHandler from "../utils/custom-hooks/ErrorHandler";<br/>/** Utils */<br/>import { ActionType } from "../custom-types";</span><span id="667c" class="mv lb it mr b gy na mx l my mz">const AddToDo: React.FC&lt;{}&gt; = () =&gt; {<br/>  const { updateToDoList } = React.useContext(toDoContext);<br/>  const { error, showError } = useErrorHandler(null);<br/>  const textInput = React.useRef&lt;HTMLInputElement&gt;(null);</span><span id="518d" class="mv lb it mr b gy na mx l my mz">const addNewToDoItem = () =&gt; {<br/>    if (textInput.current) {<br/>      const toDo = textInput.current.value;<br/>      updateToDoList({ type: ActionType.add, payload: { id: uuid(), toDo } });<br/>      textInput.current.value = "";<br/>    } else {<br/>      showError("Please type an item before clicking add.");<br/>    }<br/>  };</span><span id="6cb3" class="mv lb it mr b gy na mx l my mz">return (<br/>    &lt;Form<br/>      onSubmit={e =&gt; {<br/>        e.preventDefault();<br/>        addNewToDoItem();<br/>      }}<br/>    &gt;<br/>      &lt;Input type="text" ref={textInput} placeholder="Add to do item" /&gt;<br/>      &lt;Button type="submit" block={true}&gt;<br/>        Add<br/>      &lt;/Button&gt;<br/>      &lt;br /&gt;<br/>      {error &amp;&amp; &lt;ErrorMessage errorMessage={error} /&gt;}<br/>    &lt;/Form&gt;<br/>  );<br/>};</span><span id="6900" class="mv lb it mr b gy na mx l my mz">export default AddToDo;</span></pre><p id="db12" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">正如我之前提到的，我们不想简单地记录我们的待办事项列表中的项目，所以让我们在containers文件夹中创建一个组件，它将循环显示我们的项目，并允许我们分别单击它们来切换它们的完成状态。</p><p id="bafd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> ToDoList.tsx </strong></p><pre class="md me mf mg gt mq mr ms mt aw mu bi"><span id="8f93" class="mv lb it mr b gy mw mx l my mz">import * as React from "react";</span><span id="ac94" class="mv lb it mr b gy na mx l my mz">/** Context */<br/>import { toDoContext } from "../contexts/ToDoContext";<br/>/** Styles */<br/>import { ToDoItem } from "../components/Styles";<br/>/** Utils */<br/>import { ActionType, ToDoItemType } from "../custom-types";</span><span id="cc45" class="mv lb it mr b gy na mx l my mz">const ToDoList: React.FC&lt;{}&gt; = () =&gt; {<br/>  const { state, updateToDoList } = React.useContext(toDoContext);</span><span id="db4f" class="mv lb it mr b gy na mx l my mz">return (<br/>    &lt;React.Fragment&gt;<br/>      {state.toDoList.map(({ id, toDo, complete }: ToDoItemType, i: number) =&gt; {<br/>        return (<br/>          &lt;ToDoItem<br/>            key={id}<br/>            onClick={() =&gt;<br/>              updateToDoList({<br/>                type: ActionType.updateStatus,<br/>                payload: { id }<br/>              })<br/>            }<br/>            complete={complete}<br/>          &gt;<br/>            {i + 1}. {toDo}<br/>          &lt;/ToDoItem&gt;<br/>        );<br/>      })}<br/>    &lt;/React.Fragment&gt;<br/>  );<br/>};</span><span id="a46f" class="mv lb it mr b gy na mx l my mz">export default ToDoList;</span></pre><p id="09fc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们需要一个组件将以下组件包装成子组件:<strong class="kd iu"> RandomJoke.tsx </strong>、<strong class="kd iu"> AddToDo.tsx </strong>和<strong class="kd iu"> ToDoList.tsx </strong>。我们将创建一个函数组件，并将这个父组件称为<strong class="kd iu"> ToDo.tsx </strong>。</p><pre class="md me mf mg gt mq mr ms mt aw mu bi"><span id="1d28" class="mv lb it mr b gy mw mx l my mz">import * as React from "react";</span><span id="e01d" class="mv lb it mr b gy na mx l my mz">/** Styles */<br/>import { Header } from "../components/Styles";</span><span id="345e" class="mv lb it mr b gy na mx l my mz">/** Components */<br/>import AddToDo from "./AddToDo";<br/>import RandomJoke from "./RandomJoke";<br/>import ToDoList from "./ToDoList";<br/>/** Presentation/UI */<br/>import { ToDoContainer } from "../components/Styles";</span><span id="83a1" class="mv lb it mr b gy na mx l my mz">function ToDo() {<br/>  return (<br/>    &lt;ToDoContainer&gt;<br/>      &lt;Header&gt;My to do list&lt;/Header&gt;<br/>      &lt;RandomJoke /&gt;<br/>      &lt;AddToDo /&gt;<br/>      &lt;ToDoList /&gt;<br/>    &lt;/ToDoContainer&gt;<br/>  );<br/>}</span><span id="ca81" class="mv lb it mr b gy na mx l my mz">export default ToDo;</span></pre><p id="bbb4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后，我们希望我们的<strong class="kd iu"> RootContainer.tsx </strong>组件<strong class="kd iu"> </strong>接入auth上下文，以便当用户通过身份验证时，我们的应用程序将呈现待办事项列表(<strong class="kd iu"> ToDo.tsx </strong>)，如果本地存储被清空，用户将被注销，登录(<strong class="kd iu"> Login.tsx </strong>)将呈现在屏幕上。</p><pre class="md me mf mg gt mq mr ms mt aw mu bi"><span id="589c" class="mv lb it mr b gy mw mx l my mz">import * as React from "react";</span><span id="c027" class="mv lb it mr b gy na mx l my mz">/** Context */<br/>import { authContext } from "../contexts/AuthContext";<br/>/** Presentation */<br/>import { Wrapper } from "../components/Styles";</span><span id="0062" class="mv lb it mr b gy na mx l my mz">import Login from "./Login";<br/>import ToDo from "./ToDo";</span><span id="35fc" class="mv lb it mr b gy na mx l my mz">function RootContainer() {<br/>  const { auth } = React.useContext(authContext);<br/>  return (<br/>    &lt;Wrapper&gt;<br/>      {auth.id ? &lt;ToDo /&gt; : null}<br/>      {!auth.id &amp;&amp; &lt;Login /&gt;}<br/>    &lt;/Wrapper&gt;<br/>  );<br/>}</span><span id="6ea6" class="mv lb it mr b gy na mx l my mz">export default RootContainer;</span></pre></div><div class="ab cl nr ns hx nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="im in io ip iq"><p id="9bb9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在是你等待和编码的时刻了🙌</p><p id="71d0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">继续运行<code class="fe oa ob oc mr b">npm start</code></p><p id="a778" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">还有几个React钩子我们在本教程中没有看，分别是<a class="ae kz" href="https://reactjs.org/docs/hooks-reference.html#usecallback" rel="noopener ugc nofollow" target="_blank"> <em class="mk"> useCallback </em> </a>，<a class="ae kz" href="https://reactjs.org/docs/hooks-reference.html#usememo" rel="noopener ugc nofollow" target="_blank"> <em class="mk"> useMemo </em> </a>，<a class="ae kz" href="https://reactjs.org/docs/hooks-reference.html#useimperativehandle" rel="noopener ugc nofollow" target="_blank"><em class="mk">useImperativeHandle</em></a>，<a class="ae kz" href="https://reactjs.org/docs/hooks-reference.html#uselayouteffect" rel="noopener ugc nofollow" target="_blank"><em class="mk">useLayoutEffect</em></a>和<a class="ae kz" href="https://reactjs.org/docs/hooks-reference.html#usedebugvalue" rel="noopener ugc nofollow" target="_blank"><em class="mk">useDebugValue</em></a>。继续探索它们，看看如何在React应用程序中利用它们。</p><p id="6a97" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="mk">你可以在这里</em>  <em class="mk">找到这个应用</em> <a class="ae kz" href="https://github.com/LukeMwila/react-hooks-by-example" rel="noopener ugc nofollow" target="_blank"> <em class="mk">的源代码。</em></a></p></div></div>    
</body>
</html>