<html>
<head>
<title>Write Your Own Brainfuck Interpreter</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">写你自己的脑残解释器</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/write-your-own-brainfuck-interpreter-98e828c72854?source=collection_archive---------0-----------------------#2016-01-24">https://levelup.gitconnected.com/write-your-own-brainfuck-interpreter-98e828c72854?source=collection_archive---------0-----------------------#2016-01-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/df1e2b3511ed285c3b79ced18d59a430.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Dr86-eQ-2PI7MNKO"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Bret Kavanaugh 在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="ed19" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个短语与<a class="ae kc" href="http://helloworldcollection.de/" rel="noopener ugc nofollow" target="_blank">同义，它是你用一种你以前没用过的编程语言编写的第一个程序</a>。但是如果这是你写的语言的第一个输出呢？</p><p id="4e5e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你从来没有停下来思考你最喜欢的语言的复杂语法最终是如何满足你的要求的，也许现在是时候了。这可能比你想象的要简单。几乎任何语言都有相同的工具包，并且可以在小得多的范围内为各种其他东西创建简单的语法。</p><p id="474a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们从把你搞糊涂开始，然后从那里往回查…</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="3cbc" class="lk ll iq lg b gy lm ln l lo lp">++++++++[&gt;++++[&gt;++&gt;+++&gt;+++&gt;+&lt;&lt;&lt;&lt;-]&gt;+&gt;+&gt;-&gt;&gt;+[&lt;]&lt;-]&gt;&gt;.&gt; — -.+++++++..+++.&gt;&gt;.&lt;-.&lt;.+++. — — — . — — — — .&gt;&gt;+.&gt;++.</span></pre><h1 id="b37f" class="lq ll iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated"><strong class="ak">脑残</strong></h1><p id="db26" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">是的，<a class="ae kc" href="https://en.wikipedia.org/wiki/Brainfuck" rel="noopener ugc nofollow" target="_blank">这是一种真正的语言</a>，它从1993年就存在了。最初由Urban Müller创建，它并不意味着用于实际目的，人们认为他的初衷是为编程语言创建尽可能最小的编译器。很多编译器都写的小于200字节，至少有一个编译器小于100字节！</p><p id="9a21" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Brainfuck的工作原理是修改和遍历内存中的字节。它可以使用任何数量的字节，足以满足你运行程序的需要。Is仅由8个符号组成，每个符号都是一个字符:</p><ul class=""><li id="05f2" class="ms mt iq kf b kg kh kk kl ko mu ks mv kw mw la mx my mz na bi translated"><code class="fe nb nc nd lg b">&lt;</code>和<code class="fe nb nc nd lg b">&gt;</code>分别向左和向右移动当前字节的位置。</li><li id="379f" class="ms mt iq kf b kg ne kk nf ko ng ks nh kw ni la mx my mz na bi translated"><code class="fe nb nc nd lg b">+</code>和<code class="fe nb nc nd lg b">-</code>增加和减少当前字节的值。</li><li id="b9ff" class="ms mt iq kf b kg ne kk nf ko ng ks nh kw ni la mx my mz na bi translated"><code class="fe nb nc nd lg b">.</code>将打印当前字节(作为字符)</li><li id="3391" class="ms mt iq kf b kg ne kk nf ko ng ks nh kw ni la mx my mz na bi translated"><code class="fe nb nc nd lg b">,</code>将允许输入一个字节到当前位置。我们不会在示例中实现这一点，但是修改源代码来实现这一点是非常容易的。</li><li id="c784" class="ms mt iq kf b kg ne kk nf ko ng ks nh kw ni la mx my mz na bi translated"><code class="fe nb nc nd lg b">[</code>和<code class="fe nb nc nd lg b">]</code>用作循环。当前字节为0时，循环退出。循环可以嵌套，这使得稍后演示AST树非常完美。</li></ul><h1 id="010d" class="lq ll iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated"><strong class="ak">即将发生的事情</strong></h1><p id="7188" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">事实证明，这种看似有趣的语言其实还有另一种很酷的用法；演示如何创建一个端到端的语言解释器。即使对于最复杂的语言来说，它们也可以分为4个阶段，我将在本文中一一介绍。</p><ol class=""><li id="c45c" class="ms mt iq kf b kg kh kk kl ko mu ks mv kw mw la nj my mz na bi translated"><strong class="kf ir"> lexer </strong>将源代码分割成一串不可分割的片段，称为<em class="nk">令牌</em>。</li><li id="b87f" class="ms mt iq kf b kg ne kk nf ko ng ks nh kw ni la nj my mz na bi translated">令牌通过一个<strong class="kf ir">解析器</strong>运行，该解析器概述了令牌的预期顺序规则，并生成一个<em class="nk"> AST </em>。</li><li id="a048" class="ms mt iq kf b kg ne kk nf ko ng ks nh kw ni la nj my mz na bi translated">AST是现在可以被遍历的源代码的物理(通常是层次化的)表示。</li><li id="585a" class="ms mt iq kf b kg ne kk nf ko ng ks nh kw ni la nj my mz na bi translated">遍历由<strong class="kf ir">编译器</strong>完成以生成最终产品，或者由<strong class="kf ir">解释器</strong>立即运行，就像这种情况。</li></ol><p id="a106" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">无论您使用哪种宿主语言(这是您编写解析器生成器的语言)，这4个步骤都将保持不变，甚至大部分复杂性也将保持不变。我将使用Python，因为它非常容易阅读和理解。</p><p id="dadf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">语言解析器有不同的算法，每种算法都有各自的优点、缺点和性能问题。在这篇文章中，我不会深入探讨这个问题的细节。我将使用<a class="ae kc" href="http://www.dabeaz.com/ply/" rel="noopener ugc nofollow" target="_blank"> PLY </a>，它是一个<a class="ae kc" href="https://en.wikipedia.org/wiki/LR_parser" rel="noopener ugc nofollow" target="_blank"> LR解析器</a>。就本文的目的而言，您不需要知道更多。</p><h1 id="2d69" class="lq ll iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated"><strong class="ak"> 1。莱克斯</strong></h1><p id="0a64" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">这是最容易的阶段，也是最不可能随时间改变的阶段。简而言之，lexer使用正则表达式将源代码分成<em class="nk">个标记</em>。以下是一些标记及其各自的正则表达式:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="89db" class="lk ll iq lg b gy lm ln l lo lp">KEYWORD_VAR = "var"<br/>INTEGER = "\-?[0-9]+"<br/>IDENTIFIER = "[a-zA-Z0-9]+"<br/>OP_PLUS = "\+"<br/>OP_COLON = ";"<br/>OP_ASSIGN = "="</span></pre><p id="e1c0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用上述标记解析以下JavaScript:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="b63a" class="lk ll iq lg b gy lm ln l lo lp">var a = 3 + 2;</span></pre><p id="0393" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">会生成令牌:</p><p id="c33e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe nb nc nd lg b">KEYWORD_VAR</code><code class="fe nb nc nd lg b">IDENTIFIER</code><code class="fe nb nc nd lg b">OP_ASSIGN</code><code class="fe nb nc nd lg b">INTEGER</code><code class="fe nb nc nd lg b">OP_PLUS</code><code class="fe nb nc nd lg b">INTEGER</code>T6】</p><p id="e577" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们不仅需要令牌类型，还需要原始令牌的值。因此INTEGERtoken还必须包含匹配的字符。比如3。您将使用的解析器生成器将会为您处理这个问题。</p><p id="8100" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以下是我们所有令牌的定义:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="382a" class="lk ll iq lg b gy lm ln l lo lp">tokens = (<br/>    'INCREMENT',<br/>    'DECREMENT',<br/>    'SHIFT_LEFT',<br/>    'SHIFT_RIGHT',<br/>    'OUTPUT',<br/>    'INPUT',<br/>    'OPEN_LOOP',<br/>    'CLOSE_LOOP',<br/>)</span><span id="a9cf" class="lk ll iq lg b gy nl ln l lo lp">t_INCREMENT   = r'\+'<br/>t_DECREMENT   = r'-'<br/>t_SHIFT_LEFT  = r'&lt;'<br/>t_SHIFT_RIGHT = r'&gt;'<br/>t_OUTPUT      = r'\.'<br/>t_INPUT       = r','<br/>t_OPEN_LOOP   = r'\['<br/>t_CLOSE_LOOP  = r'\]'</span></pre><p id="29f7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是一个纯粹意义上的词法分析器，如果你选择在词法分析时翻译标记或它们的值，规则会变得更复杂，但这通常是为了处理正则表达式可能相互冲突或你需要翻译内部标记类型的边缘情况。</p><p id="724f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">具有附加逻辑的令牌的一个例子是换行符。这允许您在发生错误时报告行号。PLY定义了一个函数，其中第一行表示正则表达式，随后是任何自定义代码，这样就可以很容易地将令牌与任意代码连接起来:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="55be" class="lk ll iq lg b gy lm ln l lo lp">def t_newline(t):<br/>    r'\n+'<br/>    t.lexer.lineno += len(t.value)</span></pre><p id="b951" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">lexer会期望每个字符都完美地符合一个连续的正则表达式字符串。如果没有出现这种情况，将会抛出一个错误，包括空格。在每个标记中加入空格是很痛苦的，所以我们可以使用t _ ignoreto来指定任何将被忽略的字符。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="ba90" class="lk ll iq lg b gy lm ln l lo lp">t_ignore = ‘ \t’</span></pre><p id="2db9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Brainfuck真的应该忽略任何不是上面指定的8个字符之一的字符，但为了演示，我将忽略空格。注意不要忽略换行符，因为t_newlinetoken需要使用它。</p><p id="feb8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，如果所有这些都失败了，我们需要一个错误处理器:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="ca3e" class="lk ll iq lg b gy lm ln l lo lp">def t_error(t):<br/>    print("Illegal character '%s'" % t.value[0])<br/>    t.lexer.skip(1)</span></pre><h1 id="6e1d" class="lq ll iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated"><strong class="ak"> 2。解析器</strong></h1><p id="fab2" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">解析器是我们定义语言实际语法的地方。我们使用lexer中指定的标记以下列形式概述每个规则的顺序:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="96e7" class="lk ll iq lg b gy lm ln l lo lp">rule_name : token1 token2 ...</span></pre><p id="789e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，要在JavaScript中定义变量，您可以使用:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="ba1c" class="lk ll iq lg b gy lm ln l lo lp">define_variable : KEYWORD_VAR IDENTIFIER COLON</span></pre><p id="8696" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意，标记是大写的，但是解析器规则是小写的。一些解析器再生器强制这样做(如PLY ),而一些解析器再生器不这样做。但不管怎样，这是个好主意，因为在更复杂的语言中，当你混合记号和其他规则时，阅读起来会更清晰。</p><p id="35c3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你也可以说JavaScript中的变量可以用默认值定义(让我们暂时假设JavaScript只有整数):</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="1317" class="lk ll iq lg b gy lm ln l lo lp">define_variable : KEYWORD_VAR IDENTIFIER OP_ASSIGN INTEGER COLON</span></pre><p id="bb71" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们实际上对同一规则的不同版本进行了分类，因此可以通过使用<code class="fe nb nc nd lg b">|</code>操作符来表示and或，从而将其折叠在一起:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="c059" class="lk ll iq lg b gy lm ln l lo lp">define_variable : KEYWORD_VAR IDENTIFIER COLON<br/>                | KEYWORD_VAR IDENTIFIER OP_ASSIGN INTEGER COLON</span></pre><p id="06ee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">大多数解析器都非常简单，所以你不能把|当作逻辑操作符。它只是允许单独的线性记号序列匹配相同的解析器规则。</p><p id="86d5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所有解析器规则都是在解析器开始运行之前定义的。就像自定义标记如何表示为函数一样，解析器规则也是如此。一旦规则匹配，它将调用该规则的函数。第一个参数包含匹配规则的令牌数组。如果您使用<code class="fe nb nc nd lg b">|</code>来知道哪个规则实际匹配，这一点尤其重要。</p><p id="f0e3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一个<code class="fe nb nc nd lg b">command</code>将代表一个动作，它不仅仅是一个单字符命令，也是一个循环。因此<code class="fe nb nc nd lg b">+[&lt;&gt;]-</code>将是三个命令，因为整个<code class="fe nb nc nd lg b">[&lt;&gt;]</code>将被循环规则接收:</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="8ae4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在处理层次语法时，保持状态(实际上是返回)极其重要。我们使用索引为0的标记作为返回值，而不是直接从函数返回。例如，对于以下规则:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="281f" class="lk ll iq lg b gy lm ln l lo lp">define_variable : KEYWORD_VAR IDENTIFIER COLON</span></pre><p id="4a6e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe nb nc nd lg b">token[0]</code>为空，<code class="fe nb nc nd lg b">token[1]</code>为<code class="fe nb nc nd lg b">KEYWORD_VAR</code>，<code class="fe nb nc nd lg b">token[2]</code>为<code class="fe nb nc nd lg b">IDENTIFIER</code>，以此类推。令牌总数包括第0个令牌，因此即使规则由3个令牌组成，但<code class="fe nb nc nd lg b">len(p)</code>是4。</p><p id="939e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">循环规则看起来像:</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="6f22" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe nb nc nd lg b">commands</code>规则(不要与<code class="fe nb nc nd lg b">command</code>规则混淆)匹配一个或多个命令。因为所有的规则都是线性的记号序列，所以它们不能重复。这是表示一次或多次命令列表的一种方式。最初它是令人困惑的，用一个例子来解释是最容易的。假设我们有以下令牌:</p><p id="3ab9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe nb nc nd lg b">+</code> <code class="fe nb nc nd lg b">+</code> <code class="fe nb nc nd lg b">&gt;</code> <code class="fe nb nc nd lg b">-</code></p><p id="cef4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">减少了:</p><ol class=""><li id="02f8" class="ms mt iq kf b kg kh kk kl ko mu ks mv kw mw la nj my mz na bi translated"><code class="fe nb nc nd lg b">commands</code><code class="fe nb nc nd lg b">command</code>-&gt;(<code class="fe nb nc nd lg b">+</code><code class="fe nb nc nd lg b">+</code><code class="fe nb nc nd lg b">&gt;</code>)<code class="fe nb nc nd lg b"> -</code></li><li id="2941" class="ms mt iq kf b kg ne kk nf ko ng ks nh kw ni la nj my mz na bi translated">(<code class="fe nb nc nd lg b">commands</code><code class="fe nb nc nd lg b">command</code>)<code class="fe nb nc nd lg b">command</code>-&gt;(<code class="fe nb nc nd lg b">+</code><code class="fe nb nc nd lg b">+</code>)<code class="fe nb nc nd lg b">&gt;</code>)<code class="fe nb nc nd lg b">-</code></li><li id="62ce" class="ms mt iq kf b kg ne kk nf ko ng ks nh kw ni la nj my mz na bi translated">((<code class="fe nb nc nd lg b">command</code><code class="fe nb nc nd lg b">command</code>)<code class="fe nb nc nd lg b">command</code>)<code class="fe nb nc nd lg b">command</code>-&gt;((<code class="fe nb nc nd lg b">+</code>)<code class="fe nb nc nd lg b">+</code>)<code class="fe nb nc nd lg b">&gt;</code>)<code class="fe nb nc nd lg b">-</code></li></ol><p id="e381" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种类型的解析对于操作符优先级特别有用……这超出了本文的范围。</p><p id="abb3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这似乎与直觉相反，但解析器实际上是自下而上工作的(首先是大多数嵌套元素，这意味着它从上面的第三条规则开始)，所以我们使用<code class="fe nb nc nd lg b">len(p) == 2</code>来检查匹配的规则是否是命令(因为len(p)将比令牌的实际数量大1)，并创建基本实例命令并添加第一条命令。进一步的规则将能够把命令附加到原始的Commandsinstance，并继续通过<code class="fe nb nc nd lg b">p[0]</code>传递该实例，以供下一层拾取。</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="c6ce" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就像lexer一样，如果解析器遇到一系列与任何规则都不匹配的标记，它会有一个默认的错误处理程序。由您决定解析器是应该尝试恢复还是简单地用一条消息中止:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="5e50" class="lk ll iq lg b gy lm ln l lo lp">def p_error(p):<br/>    print("Syntax error in input!")</span></pre><h1 id="83a6" class="lq ll iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated"><strong class="ak"> 3。AST </strong></h1><p id="13da" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">抽象语法树是源代码(程序)结构的代码表示。也就是说，如果你在JavaScript中有如下表达式:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="b8e4" class="lk ll iq lg b gy lm ln l lo lp">2 * 3 + 4 * 5</span></pre><p id="283e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用正确的运算符优先级将生成嵌套实例的组合，如下所示:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="1f23" class="lk ll iq lg b gy lm ln l lo lp">new Add(new Multiply(2, 3), new Mutliply(4, 5))</span></pre><p id="b223" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于Brainfuck，我们只需要3个类来表示应用程序的结构:</p><ol class=""><li id="5cf8" class="ms mt iq kf b kg kh kk kl ko mu ks mv kw mw la nj my mz na bi translated"><code class="fe nb nc nd lg b">Commands</code>保存一个<code class="fe nb nc nd lg b">Command</code>的数组。</li><li id="60c7" class="ms mt iq kf b kg ne kk nf ko ng ks nh kw ni la nj my mz na bi translated"><code class="fe nb nc nd lg b">Command</code>是单个角色动作，或者是<code class="fe nb nc nd lg b">Loop</code>实例。</li><li id="98f4" class="ms mt iq kf b kg ne kk nf ko ng ks nh kw ni la nj my mz na bi translated">一个<code class="fe nb nc nd lg b">Loop</code>保存一个对包含在循环中的动作的<code class="fe nb nc nd lg b">Commands</code>的引用。</li></ol><p id="aa9c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为<code class="fe nb nc nd lg b">Loop</code>包含了对<code class="fe nb nc nd lg b">Commands</code>的引用，所以生成的AST可以根据每个嵌套循环的需要进行深度嵌套。</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="f492" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可能会注意到，AST类非常类似于它们的解析器规则。这很常见，尽管单个解析器规则可以输出或改变任何类型的对象。</p><p id="f987" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每个AST类都包含一个<code class="fe nb nc nd lg b">__str__</code>方法，这意味着您可以将整个程序还原为一个连续的字符串。如果空格和其他字符被忽略，它们将不会出现在输出中。</p><h1 id="6b27" class="lq ll iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated"><strong class="ak"> 4。编译器或解释器</strong></h1><p id="55b2" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">解释器现在可以任意遍历AST实例，当然这取决于您的应用程序逻辑。在进行到这个阶段之前，尝试并充分利用解析器是一个好主意，比如涵盖错误条件、边缘情况和特殊语法。</p><p id="0254" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在更复杂的解析器中，AST类只是表示源代码，而不包含其他逻辑。在这个例子中，我使用了相同的类来实际运行它们自己，因为所有的命令只是改变了应用程序的内存字节。</p></div><div class="ab cl no np hu nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="ij ik il im in"><p id="bcf0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后一个类通过lexer和解析器运行源代码，创建模拟RAM(全部20个字节)，将起始位置设置为0(第一个字节)，并最终调用AST实例本身上的动作链，从而将所有内容组合在一起:</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="e035" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们可以调用运行程序:</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="c307" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用本要点中的<a class="ae kc" href="https://gist.github.com/elliotchance/820a20821a1b5ee09ae6" rel="noopener ugc nofollow" target="_blank">完整程序，您现在可以运行它了！</a></p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="8baa" class="lk ll iq lg b gy lm ln l lo lp">$ python brainfuck.py<br/>Hello World!</span></pre></div><div class="ab cl no np hu nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="ij ik il im in"><p id="71f1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="nk">原载于2016年1月24日</em><a class="ae kc" href="http://elliot.land/post/write-your-own-brainfuck-interpreter" rel="noopener ugc nofollow" target="_blank"><em class="nk">http://Elliot . land</em></a><em class="nk">。</em></p></div></div>    
</body>
</html>