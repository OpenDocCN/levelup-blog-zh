<html>
<head>
<title>6 Best Practices for Java Developers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java开发人员的6个最佳实践</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/7-best-practices-for-java-developers-afa4d56a3954?source=collection_archive---------6-----------------------#2022-03-24">https://levelup.gitconnected.com/7-best-practices-for-java-developers-afa4d56a3954?source=collection_archive---------6-----------------------#2022-03-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b716" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">编写更好的Java代码的建议</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c3f2ae2dbd12a8c13c5da6f11a5fd78e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p22EffRB57wGPdxdn7JEtg.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">约翰·施诺布里奇在<a class="ae ky" href="https://unsplash.com/?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="6f1c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">成为Java开发人员是一种特权。在Java世界中，已经做了很多工作，但是仍然有很多工作要做。一群专家随时准备帮助你学习。所以，与其从自己的经验中学习，不如向专家学习更明智。在这里，我提出了一些专家建议，它们将提高Java代码的效率。</p><h1 id="bac4" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">1.小心使用字符串</h1><p id="e371" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">如果在一个<code class="fe ms mt mu mv b">for</code>循环中使用<code class="fe ms mt mu mv b">+</code>操作符连接两个字符串，那么每次都会创建一个新的String对象。这会浪费内存并增加执行时间。此外，在实例化一个字符串对象时应该避免构造函数，实例化应该直接发生。下面是一些代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><h1 id="29ac" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">2.避免不必要的对象创建</h1><p id="3cc4" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">Java最昂贵的操作之一(就内存利用率而言)是对象创建。因此，建议只在必要时才创建或初始化对象。以下代码给出了一个示例:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><h1 id="de93" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">3.返回空集合而不是Null</h1><p id="4fca" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">如果程序返回一个没有任何值的集合，请确保返回一个空集合，而不是空元素。这将节省大量检查空元素的<code class="fe ms mt mu mv b">if-else </code>。下面的代码将帮助您:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><h1 id="1a55" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">4.避免内存泄漏</h1><p id="6537" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">内存泄漏通常会导致软件性能下降。由于Java自动管理内存，开发人员没有多少控制权。但是仍然有一些标准的实践可以用来保护您的应用程序免受内存泄漏的影响。</p><ul class=""><li id="5952" class="my mz it lb b lc ld lf lg li na lm nb lq nc lu nd ne nf ng bi translated">当查询完成时，总是释放数据库连接。</li><li id="e9b3" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated">尽可能多地使用<code class="fe ms mt mu mv b">Finally</code>块。</li><li id="4afc" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated">发布存储在静态表中的实例。</li></ul><h1 id="cc88" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">5.如有必要，使用手动操作</h1><p id="956f" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">对于计算能力，Java提供了两个选项:</p><p id="9504" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> 1。乘法:</strong></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="21b1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> 2。Math.pow(双基数，双指数):</strong></p><p id="ab95" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ms mt mu mv b">pow</code>方法用于计算乘法不可行的地方(base^exponent).</p><p id="b14d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ms mt mu mv b">double cube = Math.pow(base, exponent);</code></p><p id="4986" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe ms mt mu mv b">Math.pow()</code>仅在必要时使用。例如，如果指数是一个小数值。<code class="fe ms mt mu mv b">Math.pow()</code>方法通常比乘法慢300-600倍。</p><h1 id="6fc7" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">6.尽量不要使用带有索引的For循环</h1><p id="3ad3" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">如果可以用增强的<code class="fe ms mt mu mv b">for</code>循环或<code class="fe ms mt mu mv b">forEach</code>代替，尽量避免使用带有索引变量的<code class="fe ms mt mu mv b">for</code>循环。通常，索引变量是容易出错的，因为我们可能会在循环体中意外地改变它，或者我们可能会从1而不是0开始索引。</p><p id="2ad0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们看看下面这个迭代字符串数组的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="1e91" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个<code class="fe ms mt mu mv b">for</code>循环中的索引变量<code class="fe ms mt mu mv b">i</code>可能会被意外更改，这可能会导致意想不到的结果。我们可以通过使用如下增强的<code class="fe ms mt mu mv b">for</code>循环来解决这个问题:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="2d23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这不仅消除了潜在的问题，而且使代码更干净、更简洁。</p><h1 id="c7e0" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">结论</h1><p id="7ed8" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">始终尝试遵循最佳实践；这会节省你的时间和精力。</p><p id="9457" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">编码快乐！:)</p></div></div>    
</body>
</html>