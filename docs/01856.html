<html>
<head>
<title>The stack data structure — What is it and how is it used in JavaScript?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">堆栈数据结构——它是什么，在JavaScript中是如何使用的？</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/the-stack-data-structure-what-is-it-and-how-is-it-used-in-javascript-23562fb8a590?source=collection_archive---------4-----------------------#2020-02-03">https://levelup.gitconnected.com/the-stack-data-structure-what-is-it-and-how-is-it-used-in-javascript-23562fb8a590?source=collection_archive---------4-----------------------#2020-02-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="cfab" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本文中，我们将探讨编程中一个非常常见的数据结构——堆栈。我们将研究它是什么以及它的一些常见应用。然后，我将继续提供一些在JavaScript运行时如何使用它的上下文。</p><h1 id="96cc" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">数据堆栈结构</h1><p id="4783" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">堆栈是一种线性数据结构，元素堆叠在一起。只能访问最后添加的元素，即堆栈顶部的元素。也就是说，堆栈是一种后进先出(LIFO)结构。这与先进先出(FIFO)队列相反。稍后我们将看到JavaScript运行时使用了这两者。</p><p id="510c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">数据栈的一个常见类比是一堆(或栈！)的餐盘；盘子叠放在一起。一位顾客从顶部拿走一个盘子。如果出于某种原因，他们想接近第二个板，他们必须先移除上面的那个。</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi lr"><img src="../Images/980337fe8aa66709950032aca53a5eee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*68CWQ5tPqgabIQgKoy1w_A.jpeg"/></div></div><figcaption class="md me gj gh gi mf mg bd b be z dk translated">数据堆栈结构的可视化</figcaption></figure><p id="3f30" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">数据堆栈以同样的方式工作。他们有三项主要业务:</p><ul class=""><li id="e477" class="mh mi it js b jt ju jx jy kb mj kf mk kj ml kn mm mn mo mp bi translated">Push() —一个新元素被添加到堆栈的顶部</li><li id="c262" class="mh mi it js b jt mq jx mr kb ms kf mt kj mu kn mm mn mo mp bi translated">Pop() —移除并返回堆栈顶部的元素</li><li id="a10e" class="mh mi it js b jt mq jx mr kb ms kf mt kj mu kn mm mn mo mp bi translated">Top()/peek() —查看堆栈并返回推入堆栈的最后一个元素。此操作不会改变堆栈。</li></ul><p id="8224" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">堆栈将有一个最大大小；当超过此限制时，称为<strong class="js iu">“堆栈溢出”</strong>。这通常是在调用递归函数而没有正确定义基本或终止用例时造成的。</p><h2 id="7c5f" class="mv kp it bd kq mw mx dn ku my mz dp ky kb na nb lc kf nc nd lg kj ne nf lk ng bi translated">履行</h2><ol class=""><li id="46b1" class="mh mi it js b jt lm jx ln kb nh kf ni kj nj kn nk mn mo mp bi translated">排列</li><li id="41fa" class="mh mi it js b jt mq jx mr kb ms kf mt kj mu kn nk mn mo mp bi translated">链表</li></ol><h2 id="b0e7" class="mv kp it bd kq mw mx dn ku my mz dp ky kb na nb lc kf nc nd lg kj ne nf lk ng bi translated">应用程序</h2><p id="b0aa" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">当动作的顺序很重要时，堆栈数据结构很有用。它们确保系统在完成之前的动作之前不会进入新的动作。下面是一些使用堆栈的常见示例:</p><ul class=""><li id="98a8" class="mh mi it js b jt ju jx jy kb mj kf mk kj ml kn mm mn mo mp bi translated"><strong class="js iu">反转— </strong>默认情况下，无论输入什么，数据堆栈都会反转。例如，如果我们想反转字符串“Hello World”。我们将把每个字符压入堆栈，然后弹出每个字符。</li><li id="c6fb" class="mh mi it js b jt mq jx mr kb ms kf mt kj mu kn mm mn mo mp bi translated"><strong class="js iu">撤销/重做— </strong>这种方法可以在编辑器中实现撤销和重做功能。每次发生变化时，程序的状态可以被压入堆栈。为了撤消，使用pop()删除最后的更改。</li><li id="a2d8" class="mh mi it js b jt mq jx mr kb ms kf mt kj mu kn mm mn mo mp bi translated"><strong class="js iu">回溯— </strong>这可以在编写算法来解决选择路径的问题时使用，例如迷宫。选择一条路径，如果它导致一个死胡同，则必须移除该路径中的这个最新分支(pop())并选择另一条路由。每次选择一个路径，它就被推送到堆栈中。</li><li id="1cf1" class="mh mi it js b jt mq jx mr kb ms kf mt kj mu kn mm mn mo mp bi translated"><strong class="js iu">调用堆栈— </strong>编程语言使用数据堆栈来执行代码。当一个函数被调用时，它被添加到调用栈中，并在完成后被删除。</li></ul><p id="8a1d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">本文的其余部分将更深入地研究调用堆栈示例。</p><h1 id="f54f" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">JavaScript &amp;调用栈</h1><blockquote class="nl nm nn"><p id="a487" class="jq jr no js b jt ju jv jw jx jy jz ka np kc kd ke nq kg kh ki nr kk kl km kn im bi translated">一个<strong class="js iu">调用栈</strong>是一个解释器(就像网页浏览器中的<strong class="js iu"> JavaScript </strong>解释器)的机制，用来跟踪它在<strong class="js iu">调用</strong>多个函数的脚本中的位置。</p></blockquote><p id="4776" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">JavaScript是单线程语言，这意味着它一次只能做一件事，因此它只有一个调用栈。该过程如下所示:</p><ol class=""><li id="954b" class="mh mi it js b jt ju jx jy kb mj kf mk kj ml kn nk mn mo mp bi translated">脚本调用一个函数</li><li id="920f" class="mh mi it js b jt mq jx mr kb ms kf mt kj mu kn nk mn mo mp bi translated">将函数添加到调用堆栈中，并执行函数</li><li id="382b" class="mh mi it js b jt mq jx mr kb ms kf mt kj mu kn nk mn mo mp bi translated">如果在中调用了另一个函数，它将被添加到调用堆栈的顶部，并一直执行到完成。</li><li id="8027" class="mh mi it js b jt mq jx mr kb ms kf mt kj mu kn nk mn mo mp bi translated">一旦完成，当前函数从堆栈中取出，原始函数继续执行。</li></ol><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi ns"><img src="../Images/3f0cf4f54d2cf1fc1f8e49aeba01a713.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-SwqpkK6FnDGEzz76WKemQ.png"/></div></div><figcaption class="md me gj gh gi mf mg bd b be z dk translated">运行时不同部分的调用堆栈的可视化表示</figcaption></figure><p id="2275" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从上图中我们可以看到，调用栈记录了你在程序中的任何一点。如果代码中有错误，我们会得到堆栈跟踪作为错误消息的一部分。错误消息“thirdFunc中的错误”下面的行显示了错误发生时调用堆栈的当前状态。理解这一点对于调试和更好地理解代码是如何执行的非常有用。</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi nt"><img src="../Images/0119f5338177d334a4fc318088d4fe4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l7_pv1Yy7HsylpqvhkFMFQ.png"/></div></div></figure></div><div class="ab cl nu nv hx nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="im in io ip iq"><h2 id="2c52" class="mv kp it bd kq mw mx dn ku my mz dp ky kb na nb lc kf nc nd lg kj ne nf lk ng bi translated">执行上下文</h2><p id="3847" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">我们现在要深入一点，当一个函数被添加到堆栈中时，实际上会发生什么。为了理解这一点，我们需要了解“执行上下文”。执行上下文是调用堆栈上的每个元素。</p><p id="1a51" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当代码在JavaScript中运行时，它可以在以下三种环境之一中执行:</p><ol class=""><li id="3d1f" class="mh mi it js b jt ju jx jy kb mj kf mk kj ml kn nk mn mo mp bi translated">全局上下文—这是程序开始时执行代码的默认环境</li><li id="04d5" class="mh mi it js b jt mq jx mr kb ms kf mt kj mu kn nk mn mo mp bi translated">函数上下文—当解释器进入函数体时</li><li id="2f19" class="mh mi it js b jt mq jx mr kb ms kf mt kj mu kn nk mn mo mp bi translated">Eval上下文—在内部eval函数中执行的文本(不常用)</li></ol><p id="4c41" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">总是只有一个全局上下文，但是可以有任意数量的函数/求值上下文。正如我们在上面看到的，每个函数调用都创建一个新的函数上下文(甚至是对自身的调用)。</p><p id="6e09" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">创建新的执行上下文有两个阶段:</p><ol class=""><li id="592c" class="mh mi it js b jt ju jx jy kb mj kf mk kj ml kn nk mn mo mp bi translated"><strong class="js iu">创建— </strong>创建一个<em class="no">执行上下文对象</em>。它包含三个键:</li></ol><ul class=""><li id="5cec" class="mh mi it js b jt ju jx jy kb mj kf mk kj ml kn mm mn mo mp bi translated"><em class="no">变量对象</em> —创建变量、函数和自变量。变量被声明并初始化为undefined(在这个阶段没有给它们赋值)。函数声明按名字存储，名字在内存中有一个指向函数的引用指针。**</li><li id="31bd" class="mh mi it js b jt mq jx mr kb ms kf mt kj mu kn mm mn mo mp bi translated"><em class="no">作用域链</em> —当前上下文的变量对象及其所有父级词法变量对象的集合。这就是函数访问其父变量的方式。</li><li id="f05b" class="mh mi it js b jt mq jx mr kb ms kf mt kj mu kn mm mn mo mp bi translated"><em class="no"> This </em> —确定上下文中“This”的值</li></ul><p id="f180" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">2.<strong class="js iu">执行</strong></p><ul class=""><li id="e0dd" class="mh mi it js b jt ju jx jy kb mj kf mk kj ml kn mm mn mo mp bi translated">给变量赋值</li><li id="5b65" class="mh mi it js b jt mq jx mr kb ms kf mt kj mu kn mm mn mo mp bi translated">解释和执行代码</li></ul><p id="9597" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">* *这就是函数声明可以被“提升”的原因。它是在创建阶段分配的，而函数表达式直到执行阶段才被赋值。</p><p id="ee5c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了帮助解释这一点，请遵循下面的代码示例，我们将查看以下代码的每个阶段的执行上下文对象:</p><figure class="ls lt lu lv gt lw"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="3756" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">创建阶段的执行上下文对象:</p><figure class="ls lt lu lv gt lw"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="a398" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">执行阶段的执行上下文对象:</p><figure class="ls lt lu lv gt lw"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="cb9f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当每个执行上下文被添加到JavaScript中的调用堆栈时，希望这能提供对该过程的更深入理解。</p></div><div class="ab cl nu nv hx nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="im in io ip iq"><p id="36d1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">单线程进程的一个问题是，如果一个特定的函数需要很长时间，那么在它完成之前，没有其他代码可以执行。这被称为“<strong class="js iu">阻塞</strong>”。在浏览器中使用时，这可能会导致页面无响应。</p><p id="8ec2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">JavaScript中对此的一个解决方案是使用异步回调，它本质上是在异步过程完成后，将要运行的代码块放在一边，但同时继续运行其余的代码。但是这是如何与调用堆栈一起工作的呢？</p><h2 id="3150" class="mv kp it bd kq mw mx dn ku my mz dp ky kb na nb lc kf nc nd lg kj ne nf lk ng bi translated">事件循环</h2><blockquote class="nl nm nn"><p id="a942" class="jq jr no js b jt ju jv jw jx jy jz ka np kc kd ke nq kg kh ki nr kk kl km kn im bi translated">事件循环负责执行代码，收集和处理事件，以及执行排队的子任务。</p></blockquote><p id="70bc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一旦异步流程完成，JavaScript运行时使用一个<strong class="js iu"> <em class="no">消息队列</em> </strong>来排列包含回调函数的“消息”。这个进程是FIFO(先进先出)，所以如果有多个异步操作，最快的将在队列中第一个被调用。</p><p id="a724" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当一个异步进程进入堆栈时，它被移动到<strong class="js iu"> <em class="no">事件表</em> </strong>，所有其他同步函数都通过堆栈处理。当异步流程完成时，它被移动到消息队列中。一旦堆栈为空，事件循环就开始处理队列中的消息；它接受第一个函数并调用回调函数。这将在堆栈上创建一个帧。该函数完成并从堆栈中移除。堆栈现在又是空的，因此事件循环检查消息队列中的下一项。这个过程一直持续到堆栈和消息队列为空。</p><p id="9ee3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">事件循环优先考虑调用堆栈，它处理它在调用堆栈中找到的所有东西，一旦为空，它就进入消息队列获取任何消息。</p><p id="4530" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面的动画展示了前一个示例，该示例现在包括一个异步流程:</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="gh gi od"><img src="../Images/9207c1dd7d2a314129c3683d32daaccc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*QbEk21UatVQzxOUbYti5VQ.gif"/></div></div><figcaption class="md me gj gh gi mf mg bd b be z dk translated">事件循环事件序列</figcaption></figure><h1 id="90cb" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">结论</h1><p id="952d" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">希望这篇文章能帮助你更好地理解JavaScript的内部工作原理以及你的代码实际上是如何运行的。要了解更多信息，请看下面的一些资源。</p><h2 id="5f1a" class="mv kp it bd kq mw mx dn ku my mz dp ky kb na nb lc kf nc nd lg kj ne nf lk ng bi translated">关键要点:</h2><ul class=""><li id="8995" class="mh mi it js b jt lm jx ln kb nh kf ni kj nj kn mm mn mo mp bi translated">堆栈是先进后出的数据结构</li><li id="e41c" class="mh mi it js b jt mq jx mr kb ms kf mt kj mu kn mm mn mo mp bi translated">元素只能从顶部推入和弹出</li><li id="9803" class="mh mi it js b jt mq jx mr kb ms kf mt kj mu kn mm mn mo mp bi translated">数据堆栈的一个主要用途是让JavaScript解释器跟踪函数调用——这是一个调用堆栈</li><li id="c5d7" class="mh mi it js b jt mq jx mr kb ms kf mt kj mu kn mm mn mo mp bi translated">调用堆栈上的每个元素都是一个执行上下文(全局、函数、eval)。只能有一个全局上下文，但可以有多个函数上下文。</li><li id="31a7" class="mh mi it js b jt mq jx mr kb ms kf mt kj mu kn mm mn mo mp bi translated">JavaScript只有一个调用栈，但是使用消息队列和事件循环优化了异步操作。</li></ul><h2 id="0248" class="mv kp it bd kq mw mx dn ku my mz dp ky kb na nb lc kf nc nd lg kj ne nf lk ng bi translated">资源:</h2><div class="oe of gp gr og oh"><a href="https://www.studytonight.com/data-structures/stack-data-structure" rel="noopener  ugc nofollow" target="_blank"><div class="oi ab fo"><div class="oj ab ok cl cj ol"><h2 class="bd iu gy z fp om fr fs on fu fw is bi translated">堆栈数据结构| Studytonight</h2><div class="oo l"><h3 class="bd b gy z fp om fr fs on fu fw dk translated">堆栈是一种抽象数据类型，具有有限的(预定义的)容量。这是一个简单的数据结构，允许添加…</h3></div><div class="op l"><p class="bd b dl z fp om fr fs on fu fw dk translated">www.studytonight.com</p></div></div><div class="oq l"><div class="or l os ot ou oq ov mb oh"/></div></div></a></div><div class="oe of gp gr og oh"><a href="https://en.wikibooks.org/wiki/Data_Structures/Stacks_and_Queues" rel="noopener  ugc nofollow" target="_blank"><div class="oi ab fo"><div class="oj ab ok cl cj ol"><h2 class="bd iu gy z fp om fr fs on fu fw is bi translated">数据结构/堆栈和队列</h2><div class="oo l"><h3 class="bd b gy z fp om fr fs on fu fw dk translated">待办事项:队列实现为数组:循环和固定大小堆栈是一个基本的数据结构，可以在逻辑上…</h3></div><div class="op l"><p class="bd b dl z fp om fr fs on fu fw dk translated">en.wikibooks.or</p></div></div><div class="oq l"><div class="ow l os ot ou oq ov mb oh"/></div></div></a></div><div class="oe of gp gr og oh"><a href="http://davidshariff.com/blog/what-is-the-execution-context-in-javascript/" rel="noopener  ugc nofollow" target="_blank"><div class="oi ab fo"><div class="oj ab ok cl cj ol"><h2 class="bd iu gy z fp om fr fs on fu fw is bi translated">JavaScript中的执行上下文&amp;栈是什么？</h2><div class="oo l"><h3 class="bd b gy z fp om fr fs on fu fw dk translated">JavaScript中的执行上下文&amp;栈是什么？-在这篇文章中，我将深入探讨一个最…</h3></div><div class="op l"><p class="bd b dl z fp om fr fs on fu fw dk translated">davidshariff.com</p></div></div><div class="oq l"><div class="ox l os ot ou oq ov mb oh"/></div></div></a></div><figure class="ls lt lu lv gt lw"><div class="bz fp l di"><div class="oy oc l"/></div></figure></div></div>    
</body>
</html>