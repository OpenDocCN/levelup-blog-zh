<html>
<head>
<title>How to Add Hooks to Node.js’ Require Function?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何给Node.js' Require函数添加钩子？</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-add-hooks-to-node-js-require-function-dee7acd12698?source=collection_archive---------5-----------------------#2022-08-30">https://levelup.gitconnected.com/how-to-add-hooks-to-node-js-require-function-dee7acd12698?source=collection_archive---------5-----------------------#2022-08-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/cf7ae2b4a8432494a724dd06bc221d80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gjPNGvoocx25SErg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@johnathanmphoto?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">张克帆·马塞多</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="8b28" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Node.js是一个基于Chrome V8引擎的JavaScript运行时环境。早期的Node.js采用了<strong class="ki iu"> CommonJS </strong>模块规范，<strong class="ki iu"> ECMAScript模块</strong>功能从Node v13.2.0开始就得到官方支持，直到v15.3.0，ECMAScript模块功能才稳定下来，并与NPM生态系统兼容。</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi le"><img src="../Images/bf410864f55a695172270badfb276a20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B6OyPVj8L9pAFAKaiYuUlQ.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片经由<a class="ae kf" href="https://nodejs.org/api/esm.html" rel="noopener ugc nofollow" target="_blank">https://nodejs.org/api/esm.html</a></figcaption></figure><p id="4bba" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">本文将介绍Node.js中<code class="fe lj lk ll lm b">require</code>函数的工作流程，如何让Node.js直接执行<strong class="ki iu"> ts </strong>文件，如何正确劫持Node.js的<code class="fe lj lk ll lm b">require</code>函数实现hook函数。接下来，我们先介绍一下<code class="fe lj lk ll lm b">require</code>功能。</p><h1 id="b4d9" class="ln lo it bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">需要功能</h1><p id="3508" class="pw-post-body-paragraph kg kh it ki b kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">Node.js应用程序由模块组成，每个文件都是一个模块。对于CommonJS模块规范，我们通过<code class="fe lj lk ll lm b">require</code>函数导入模块。那么当我们使用<code class="fe lj lk ll lm b">require</code>函数导入一个模块时，函数内部会发生什么呢？这里我们通过调用堆栈来看看<code class="fe lj lk ll lm b">require</code>的过程:</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mq"><img src="../Images/64466c96b812d2603b5e1ea3a38946ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yC7aI3llgMdQabpACxfA2w.png"/></div></div></figure><p id="aefc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从上图可以看出，使用<code class="fe lj lk ll lm b">require</code>函数导入模块时，会调用模块对象的<code class="fe lj lk ll lm b">load</code>方法来加载模块。该方法的实现如下:</p><pre class="lf lg lh li gt mr lm ms mt aw mu bi"><span id="5415" class="mv lo it lm b gy mw mx l my mz">// lib/internal/modules/cjs/loader.js<br/>Module.prototype.load = function(filename) {<br/>  this.filename = filename;<br/>  this.paths = Module._nodeModulePaths(path.dirname(filename));</span><span id="d0d4" class="mv lo it lm b gy na mx l my mz">const extension = findLongestRegisteredExtension(filename);</span><span id="5c92" class="mv lo it lm b gy na mx l my mz">Module._extensions[extension](this, filename);<br/>  this.loaded = true;<br/>  // omit part of the code<br/>};</span></pre><blockquote class="nb nc nd"><p id="259f" class="kg kh ne ki b kj kk kl km kn ko kp kq nf ks kt ku ng kw kx ky nh la lb lc ld im bi translated">注意:本文引用的Node.js源代码版本是v16.13.1</p></blockquote><p id="d56d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，两个重要的步骤是:</p><ul class=""><li id="e8ba" class="ni nj it ki b kj kk kn ko kr nk kv nl kz nm ld nn no np nq bi translated">第一步:根据文件名找到扩展名；</li><li id="d09d" class="ni nj it ki b kj nr kn ns kr nt kv nu kz nv ld nn no np nq bi translated">第二步:在<strong class="ki iu">模块中找到匹配的加载器。_extensions </strong>对象。</li></ul><p id="0ace" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Node.js内置了3个不同的加载器，用于加载<code class="fe lj lk ll lm b">node</code>、<code class="fe lj lk ll lm b">json</code>和<code class="fe lj lk ll lm b">js</code>文件。</p><p id="45a5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">节点文件加载器</strong></p><pre class="lf lg lh li gt mr lm ms mt aw mu bi"><span id="06ca" class="mv lo it lm b gy mw mx l my mz">// lib/internal/modules/cjs/loader.js<br/>Module._extensions['.node'] = function(module, filename) {<br/>  return process.dlopen(module, path.toNamespacedPath(filename));<br/>};</span></pre><p id="11df" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu"> json文件加载器</strong></p><pre class="lf lg lh li gt mr lm ms mt aw mu bi"><span id="ca5c" class="mv lo it lm b gy mw mx l my mz">// lib/internal/modules/cjs/loader.js<br/>Module._extensions['.json'] = function(module, filename) {<br/> const content = fs.readFileSync(filename, 'utf8');<br/> try {<br/>    module.exports = JSONParse(stripBOM(content));<br/> } catch (err) {<br/>   err.message = filename + ': ' + err.message;<br/>   throw err;<br/> }<br/>};</span></pre><p id="88b9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu"> js文件加载器</strong></p><pre class="lf lg lh li gt mr lm ms mt aw mu bi"><span id="829a" class="mv lo it lm b gy mw mx l my mz">// lib/internal/modules/cjs/loader.js<br/>Module._extensions['.js'] = function(module, filename) {<br/>  // If already analyzed the source, then it will be cached.<br/>  const cached = cjsParseCache.get(module);<br/>  let content;<br/>  if (cached?.source) {<br/>    content = cached.source;<br/>    cached.source = undefined;<br/>  } else {<br/>    content = fs.readFileSync(filename, 'utf8');<br/>  }<br/>  // omit part of the code<br/>  module._compile(content, filename);<br/>};</span></pre><p id="618c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们来分析一下更重要的js文件加载器。通过阅读上面的代码，我们可以知道js loader的核心处理流程也可以分为两步:</p><ul class=""><li id="b8dc" class="ni nj it ki b kj kk kn ko kr nk kv nl kz nm ld nn no np nq bi translated">第一步:使用<code class="fe lj lk ll lm b">fs.readFileSync</code>方法加载js文件的内容；</li><li id="3955" class="ni nj it ki b kj nr kn ns kr nt kv nu kz nv ld nn no np nq bi translated">第二步:使用<code class="fe lj lk ll lm b">module._compile</code>方法编译加载的js代码。</li></ul><p id="d863" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么知道了以上知识对我们有什么用呢？其实在了解了<code class="fe lj lk ll lm b">require</code>函数的工作流程之后，我们就可以扩展Node.js loader了。比如启用Node.js运行<strong class="ki iu"> ts </strong>文件。</p><pre class="lf lg lh li gt mr lm ms mt aw mu bi"><span id="a1ad" class="mv lo it lm b gy mw mx l my mz">// register.js<br/>const fs = require("fs");<br/>const Module = require("module");<br/>const { transformSync } = require("esbuild");</span><span id="0bb6" class="mv lo it lm b gy na mx l my mz">Module._extensions[".ts"] = function (module, filename) {<br/>  const content = fs.readFileSync(filename, "utf8");<br/>  const { code } = transformSync(content, {<br/>    sourcefile: filename,<br/>    sourcemap: "both",<br/>    loader: "ts",<br/>    format: "cjs",<br/>  });<br/>  module._compile(code, filename);<br/>};</span></pre><p id="e728" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们导入内置的<code class="fe lj lk ll lm b">module</code>模块，然后使用<code class="fe lj lk ll lm b">Module._extensions</code>对象注册我们的自定义ts文件加载器。其实加载器的本质就是一个函数。在这个函数内部，我们使用<code class="fe lj lk ll lm b">esbuild</code>模块提供的<code class="fe lj lk ll lm b">transformSync</code> API来实现<strong class="ki iu"> ts - &gt; js </strong>代码的转换。当代码转换完成后，将调用<code class="fe lj lk ll lm b">module._compile</code>方法来编译代码。</p><p id="9f54" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们来看看如何让自定义ts加载器生效。为了使Node.js能够执行ts代码，我们需要在执行ts代码之前完成定制ts加载器的注册。幸运的是，Node.js为我们提供了模块预加载机制:</p><pre class="lf lg lh li gt mr lm ms mt aw mu bi"><span id="7258" class="mv lo it lm b gy mw mx l my mz">$ node --help | grep preload<br/>   -r, --require=... module to preload (option can be repeated)</span></pre><p id="ca7e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用-r，— require命令行配置选项，我们可以预加载指定的模块。解决了这个问题，让我们测试一下我们的定制ts加载器。首先创建一个index.ts文件，并输入以下代码:</p><p id="a3de" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu">索引. ts </strong></p><pre class="lf lg lh li gt mr lm ms mt aw mu bi"><span id="d42b" class="mv lo it lm b gy mw mx l my mz">// index.ts<br/>const add = (a: number, b: number) =&gt; a + b;</span><span id="f381" class="mv lo it lm b gy na mx l my mz">console.log("add(a, b) = ", add(3, 5));</span></pre><p id="ab3b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后在命令行输入以下命令:</p><pre class="lf lg lh li gt mr lm ms mt aw mu bi"><span id="cbba" class="mv lo it lm b gy mw mx l my mz">$ node -r ./register.js index.ts</span></pre><p id="b358" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当上述命令成功运行时，控制台将输出以下结果:</p><pre class="lf lg lh li gt mr lm ms mt aw mu bi"><span id="0616" class="mv lo it lm b gy mw mx l my mz">add(a, b) =  8</span></pre><p id="3797" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">显然我们自定义的ts文件加载器已经生效了，这个扩展机制还是很值得学习的。另外需要注意的是，在<code class="fe lj lk ll lm b">load</code>方法中，<code class="fe lj lk ll lm b">findLongestRegisteredExtension</code>函数会判断文件的扩展名是否已经在<code class="fe lj lk ll lm b">Module._extensions</code>对象中注册。如果没有，则返回<strong class="ki iu">”。</strong>默认js。</p><pre class="lf lg lh li gt mr lm ms mt aw mu bi"><span id="86db" class="mv lo it lm b gy mw mx l my mz">// lib/internal/modules/cjs/loader.js<br/>Module.prototype.load = function(filename) {<br/>  this.filename = filename;<br/>  this.paths = Module._nodeModulePaths(path.dirname(filename));</span><span id="07f8" class="mv lo it lm b gy na mx l my mz">const extension = findLongestRegisteredExtension(filename);</span><span id="44b2" class="mv lo it lm b gy na mx l my mz">Module._extensions[extension](this, filename);<br/>  this.loaded = true;<br/>  // omit part of the code<br/>};</span></pre><p id="550d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这意味着只要文件包含有效的js代码，require函数就会正常加载它。例如下面的<strong class="ki iu"> a.txt </strong>文件:</p><pre class="lf lg lh li gt mr lm ms mt aw mu bi"><span id="8e45" class="mv lo it lm b gy mw mx l my mz">module.exports = "Hello Bytefer";</span></pre><p id="d8b3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">至此，相信你已经了解了<code class="fe lj lk ll lm b">require</code>函数如何加载模块，如何自定义Node.js文件加载器。那么，Node.js有没有更优雅更简单的方案来支持加载其他类型的文件比如<code class="fe lj lk ll lm b">ts</code>、<code class="fe lj lk ll lm b">png</code>或者<code class="fe lj lk ll lm b">css</code>？答案是肯定的，我们可以使用第三方库<a class="ae kf" href="https://github.com/danez/pirates" rel="noopener ugc nofollow" target="_blank"> <strong class="ki iu">盗版</strong> </a>。</p><h1 id="f942" class="ln lo it bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">什么是海盗</h1><p id="4780" class="pw-post-body-paragraph kg kh it ki b kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated"><a class="ae kf" href="https://github.com/danez/pirates" rel="noopener ugc nofollow" target="_blank"> <strong class="ki iu"> pirates </strong> </a>是一个允许我们适当劫持Node.js的<code class="fe lj lk ll lm b">require</code>函数的库。使用这个库，我们可以很容易地扩展Node.js加载器的功能。</p><h2 id="540f" class="mv lo it bd lp nw nx dn lt ny nz dp lx kr oa ob mb kv oc od mf kz oe of mj og bi translated">盗版的使用</h2><p id="c3a7" class="pw-post-body-paragraph kg kh it ki b kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">您可以使用npm来安装盗版:</p><pre class="lf lg lh li gt mr lm ms mt aw mu bi"><span id="db92" class="mv lo it lm b gy mw mx l my mz">$ npm install --save pirates</span></pre><p id="2d6a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">成功安装<a class="ae kf" href="https://github.com/danez/pirates" rel="noopener ugc nofollow" target="_blank"> <strong class="ki iu">盗版</strong> </a>库后，可以使用模块提供的<code class="fe lj lk ll lm b">addHook</code>函数添加钩子。</p><p id="ae4d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu"> register.js </strong></p><pre class="lf lg lh li gt mr lm ms mt aw mu bi"><span id="06ea" class="mv lo it lm b gy mw mx l my mz">// register.js<br/>const addHook = require("pirates").addHook;</span><span id="6c81" class="mv lo it lm b gy na mx l my mz">const revert = addHook(<br/>  (code, filename) =&gt; code.replace("@@foo", "console.log('foo');"),<br/>  { exts: [".js"] }<br/>);</span></pre><p id="9388" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">需要注意的是，调用<code class="fe lj lk ll lm b">addHook</code>后，会返回一个revert函数，取消对<code class="fe lj lk ll lm b">require</code>函数的劫持。同样，让我们验证一下pirates库是否正常工作，首先创建一个新的index.js文件，并输入以下代码:</p><p id="6531" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu"> index.js </strong></p><pre class="lf lg lh li gt mr lm ms mt aw mu bi"><span id="5cf4" class="mv lo it lm b gy mw mx l my mz">// index.js<br/>console.log("@@foo")</span></pre><p id="a86d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后在命令行输入以下命令:</p><pre class="lf lg lh li gt mr lm ms mt aw mu bi"><span id="fd47" class="mv lo it lm b gy mw mx l my mz">$ node -r ./register.js index.js</span></pre><p id="dc66" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当上述命令成功运行时，控制台将输出以下结果:</p><pre class="lf lg lh li gt mr lm ms mt aw mu bi"><span id="98c5" class="mv lo it lm b gy mw mx l my mz">console.log('foo');</span></pre><p id="e4f5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从上面的结果可以看出，我们通过<code class="fe lj lk ll lm b">addHook</code>函数添加的钩子生效了。你不觉得很神奇吗，我们来分析一下海盗是怎么运作的。</p><h2 id="01d9" class="mv lo it bd lp nw nx dn lt ny nz dp lx kr oa ob mb kv oc od mf kz oe of mj og bi translated">海盗是如何运作的</h2><p id="b04b" class="pw-post-body-paragraph kg kh it ki b kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">在内部，pirates使用Node.js内置的<code class="fe lj lk ll lm b">module</code>模块提供的扩展机制来实现Hook函数。我们已经介绍过，使用<code class="fe lj lk ll lm b">require</code>函数加载模块时，<strong class="ki iu"> Node.js会根据文件扩展名</strong>匹配对应的加载器。<br/>其实海贼的源代码并不复杂。让我们重点分析一下<code class="fe lj lk ll lm b">addHook</code>函数的核心处理逻辑:</p><pre class="lf lg lh li gt mr lm ms mt aw mu bi"><span id="25d7" class="mv lo it lm b gy mw mx l my mz">// src/index.js<br/>export function addHook(hook, opts = {}) {<br/>  let reverted = false;<br/>  const loaders = []; <br/>  const oldLoaders = []; <br/>  let exts;</span><span id="954b" class="mv lo it lm b gy na mx l my mz">const originalJSLoader = Module._extensions['.js']; </span><span id="d8d0" class="mv lo it lm b gy na mx l my mz">const matcher = opts.matcher || null;<br/>  const ignoreNodeModules = opts.ignoreNodeModules !== false;<br/>  exts = opts.extensions || opts.exts || opts.extension || opts.ext <br/>    || ['.js'];<br/>  if (!Array.isArray(exts)) {<br/>    exts = [exts];<br/>  }<br/>  exts.forEach((ext) { <br/>    // ... <br/>  }<br/>}</span></pre><p id="d8d2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了提高执行效率，<code class="fe lj lk ll lm b">addHook</code>函数提供了<strong class="ki iu">匹配器</strong>和<strong class="ki iu"> ignoreNodeModules </strong>配置项来实现文件过滤操作。在获得exts扩展列表后，新的加载程序将替换现有的加载程序。</p><pre class="lf lg lh li gt mr lm ms mt aw mu bi"><span id="6294" class="mv lo it lm b gy mw mx l my mz">exts.forEach((ext) =&gt; {<br/>    if (typeof ext !== 'string') {<br/>      throw new TypeError(`Invalid Extension: ${ext}`);<br/>    }<br/>    // Get the registered loader, if not found, <br/>    // use JS Loader by default<br/>    const oldLoader = Module._extensions[ext] || originalJSLoader;<br/>    oldLoaders[ext] = Module._extensions[ext];</span><span id="5b42" class="mv lo it lm b gy na mx l my mz">loaders[ext] = Module._extensions[ext] = function newLoader(<br/>   mod, filename) {<br/>      let compile;<br/>      if (!reverted) {<br/>        if (shouldCompile(filename, exts, matcher,   <br/>        ignoreNodeModules)) {<br/>          compile = mod._compile;<br/>          mod._compile = function _compile(code) {<br/>     // Here you need to restore the original _compile function, <br/>     // otherwise there will be an infinite loop<br/>            mod._compile = compile;<br/>     // Execute the user-defined hook function before compiling<br/>            const newCode = hook(code, filename);<br/>            if (typeof newCode !== 'string') {<br/>              throw new Error(HOOK_RETURNED_NOTHING_ERROR_MESSAGE);<br/>            }</span><span id="94ba" class="mv lo it lm b gy na mx l my mz">            return mod._compile(newCode, filename);<br/>          };<br/>        }<br/>      }</span><span id="ba07" class="mv lo it lm b gy na mx l my mz">    oldLoader(mod, filename);<br/>    };<br/>});</span></pre><p id="674c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从上面的代码可以看出，钩子函数是通过替换<code class="fe lj lk ll lm b">addHook</code>函数内部的<code class="fe lj lk ll lm b">mode._compile</code>方法实现的。即在调用原来的<code class="fe lj lk ll lm b">mode._compile</code>方法进行编译之前，会先调用<code class="fe lj lk ll lm b">hook(code, filename)</code>函数来执行用户自定义的钩子函数来处理代码。</p><p id="4f28" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在实践中，如果希望Node.js直接执行ts文件，可以使用<a class="ae kf" href="https://github.com/TypeStrong/ts-node" rel="noopener ugc nofollow" target="_blank"> <strong class="ki iu"> ts-node </strong> </a>或者<a class="ae kf" href="https://github.com/egoist/esbuild-register" rel="noopener ugc nofollow" target="_blank"> <strong class="ki iu"> esbuild-register </strong> </a>库。<a class="ae kf" href="https://github.com/egoist/esbuild-register" rel="noopener ugc nofollow" target="_blank"><strong class="ki iu">es build-register</strong></a>库使用<a class="ae kf" href="https://github.com/danez/pirates" rel="noopener ugc nofollow" target="_blank"> <strong class="ki iu"> pirates </strong> </a>提供的钩子机制来实现相应的功能。</p></div><div class="ab cl oh oi hx oj" role="separator"><span class="ok bw bk ol om on"/><span class="ok bw bk ol om on"/><span class="ok bw bk ol om"/></div><div class="im in io ip iq"><p id="19a4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你想学习打字，那么就不要错过<strong class="ki iu">掌握打字</strong>系列。</p><ul class=""><li id="1df0" class="ni nj it ki b kj kk kn ko kr nk kv nl kz nm ld nn no np nq bi translated"><a class="ae kf" href="https://medium.com/frontend-canteen/what-are-k-t-and-v-in-typescript-generics-9fabe1d0f0f3" rel="noopener"><strong class="ki iu">TypeScript泛型中的K、T、V是什么？</strong> </a></li><li id="257c" class="ni nj it ki b kj nr kn ns kr nt kv nu kz nv ld nn no np nq bi translated"><a class="ae kf" href="https://javascript.plainenglish.io/using-typescript-mapped-types-like-a-pro-be10aef5511a" rel="noopener ugc nofollow" target="_blank"> <strong class="ki iu">使用TypeScript像Pro一样映射类型</strong> </a></li><li id="3b5a" class="ni nj it ki b kj nr kn ns kr nt kv nu kz nv ld nn no np nq bi translated"><a class="ae kf" href="https://javascript.plainenglish.io/use-typescript-conditional-types-like-a-pro-7baea0ad05c5" rel="noopener ugc nofollow" target="_blank"> <strong class="ki iu">使用TypeScript条件类型像亲</strong> </a></li><li id="5fd2" class="ni nj it ki b kj nr kn ns kr nt kv nu kz nv ld nn no np nq bi translated"><a class="ae kf" href="https://javascript.plainenglish.io/using-typescript-intersection-types-like-a-pro-a55da6a6a5f7" rel="noopener ugc nofollow" target="_blank"> <strong class="ki iu">使用TypeScript交集类型像亲</strong> </a></li><li id="5d29" class="ni nj it ki b kj nr kn ns kr nt kv nu kz nv ld nn no np nq bi translated"><a class="ae kf" rel="noopener ugc nofollow" target="_blank" href="/using-typescript-infer-like-a-pro-f30ab8ab41c7"> <strong class="ki iu">使用打字稿推断像亲</strong> </a></li><li id="d056" class="ni nj it ki b kj nr kn ns kr nt kv nu kz nv ld nn no np nq bi translated"><a class="ae kf" href="https://medium.com/javascript-in-plain-english/how-to-use-typescript-template-literal-types-like-a-pro-2e02a7db0bac" rel="noopener"> <strong class="ki iu">使用TypeScript模板字面类型像亲</strong> </a></li><li id="f23a" class="ni nj it ki b kj nr kn ns kr nt kv nu kz nv ld nn no np nq bi translated"><a class="ae kf" href="https://javascript.plainenglish.io/15-utility-types-that-every-typescript-developer-should-know-6cf121d4047c" rel="noopener ugc nofollow" target="_blank"> <strong class="ki iu">打字稿可视化:15种最常用的实用类型</strong> </a></li><li id="847f" class="ni nj it ki b kj nr kn ns kr nt kv nu kz nv ld nn no np nq bi translated"><a class="ae kf" rel="noopener ugc nofollow" target="_blank" href="/10-things-you-need-to-know-about-typescript-classes-f58c57869266"> <strong class="ki iu">关于类型脚本类你需要知道的10件事</strong> </a></li><li id="54ed" class="ni nj it ki b kj nr kn ns kr nt kv nu kz nv ld nn no np nq bi translated"><a class="ae kf" href="https://javascript.plainenglish.io/purpose-of-declare-keyword-in-typescript-8431d9db2b10" rel="noopener ugc nofollow" target="_blank"><strong class="ki iu"/></a>中‘声明’关键字的用途</li><li id="d2cc" class="ni nj it ki b kj nr kn ns kr nt kv nu kz nv ld nn no np nq bi translated"><a class="ae kf" href="https://javascript.plainenglish.io/no-more-confusion-about-typescripts-any-and-unknown-98c4b53f8924" rel="noopener ugc nofollow" target="_blank"><strong class="ki iu"/></a></li></ul><div class="oo op gp gr oq"><div role="button" tabindex="0" class="ab bv gv cb fp or os bn ot jz ex"><div class="ou l"><div class="ab q"><div class="l di"><img alt="Bytefer" class="l de bw ov ow fe" src="../Images/238cf2afd3c689b50719951ba2fd880d.png" width="20" height="20" loading="lazy" data-original-src="https://miro.medium.com/v2/resize:fill:40:40/1*krjVh9VFhDEcMUif4Ewt-A.png"/><div class="fb bw l ov ow fc n aw fd"/></div><div class="hh l fo"><p class="bd b dl z fp fq fr fs ft fu fv fw dk translated"><a class="ae af ag ah ai aj ak al am an ao ap aq ar as" href="https://medium.com/@bytefer?source=post_page-----dee7acd12698--------------------------------" rel="noopener follow" target="_top">拜特弗</a></p></div></div><div class="oz pa gw l"><h2 class="bd iu ui ni fp uj fr fs uk fu fw is bi translated">掌握打字稿系列</h2></div><div class="ab q"><div class="l fo"><a class="bd b be z bi ul au um un uo qy up an eh ei uq ur us el em eo de bk ep" href="https://medium.com/@bytefer/list/mastering-typescript-series-688ee7c12807?source=post_page-----dee7acd12698--------------------------------" rel="noopener follow" target="_top">View list</a></div><div class="ut l fo"><span class="bd b dl z dk">46 stories</span></div></div></div><div class="pm dh pn fp ab po fo di"><div class="di pe bv pf pg"><div class="dh l"><img alt="" class="dh" src="../Images/373c978fed504a3c38f0fdb5b617fedb.png" width="194" height="194" loading="lazy" role="presentation" data-original-src="https://miro.medium.com/v2/resize:fill:388:388/0*94uN4q2Of_fg3WaQ"/></div></div><div class="di pe bv ph pi pj"><div class="dh l"><img alt="" class="dh" src="../Images/a8ea3e3ecad1c2d2697107f3ce466e42.png" width="194" height="194" loading="lazy" role="presentation" data-original-src="https://miro.medium.com/v2/resize:fill:388:388/0*tGza_iE2o--HjQwD"/></div></div><div class="di bv pk pl pj"><div class="dh l"><img alt="" class="dh" src="../Images/3bcc671d9b1ca5776fec258eed5450d4.png" width="194" height="194" loading="lazy" role="presentation" data-original-src="https://miro.medium.com/v2/resize:fill:388:388/0*_U9uNpcZaTLX4u4B"/></div></div></div></div></div><p id="479f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<a class="ae kf" href="https://medium.com/@bytefer" rel="noopener"> Medium </a>或<a class="ae kf" href="https://twitter.com/Tbytefer" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上关注我，阅读更多关于TS和JS的内容！</p></div><div class="ab cl oh oi hx oj" role="separator"><span class="ok bw bk ol om on"/><span class="ok bw bk ol om on"/><span class="ok bw bk ol om"/></div><div class="im in io ip iq"><h1 id="721d" class="ln lo it bd lp lq ps ls lt lu pt lw lx ly pu ma mb mc pv me mf mg pw mi mj mk bi translated">分级编码</h1><p id="f50f" class="pw-post-body-paragraph kg kh it ki b kj ml kl km kn mm kp kq kr mn kt ku kv mo kx ky kz mp lb lc ld im bi translated">感谢您成为我们社区的一员！在你离开之前:</p><ul class=""><li id="cf89" class="ni nj it ki b kj kk kn ko kr nk kv nl kz nm ld nn no np nq bi translated">👏为故事鼓掌，跟着作者走👉</li><li id="5b76" class="ni nj it ki b kj nr kn ns kr nt kv nu kz nv ld nn no np nq bi translated">📰查看<a class="ae kf" href="https://levelup.gitconnected.com/?utm_source=pub&amp;utm_medium=post" rel="noopener ugc nofollow" target="_blank">升级编码出版物</a>中的更多内容</li><li id="9607" class="ni nj it ki b kj nr kn ns kr nt kv nu kz nv ld nn no np nq bi translated">🔔关注我们:<a class="ae kf" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">Twitter</a>|<a class="ae kf" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>|<a class="ae kf" href="https://newsletter.levelup.dev" rel="noopener ugc nofollow" target="_blank">时事通讯</a></li></ul><p id="a931" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">🚀👉<a class="ae kf" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="ki iu">加入人才集体，找到一份令人惊喜的工作</strong> </a></p></div></div>    
</body>
</html>