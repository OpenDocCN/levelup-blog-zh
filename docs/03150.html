<html>
<head>
<title>Deploying Serverless Backends to AWS with Gitlab CI/CD</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Gitlab CI/CD将无服务器后端部署到AWS</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/deploying-serverless-backends-to-aws-with-gitlab-ci-cd-f81106b43709?source=collection_archive---------4-----------------------#2020-04-22">https://levelup.gitconnected.com/deploying-serverless-backends-to-aws-with-gitlab-ci-cd-f81106b43709?source=collection_archive---------4-----------------------#2020-04-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/8a04816169e1b66b45536da81e235067.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BwlJPyWNZq8hCEUR7DBsfg.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">Gitlab CI/CD管道</figcaption></figure><p id="63b7" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><a class="ae ld" href="https://serverless.com/" rel="noopener ugc nofollow" target="_blank">无服务器框架</a>是一个了不起的工具，我非常看好无服务器开发的未来。对于所有关于无服务器的精彩内容，没有太多关于如何为无服务器项目构建CI/CD管道的内容——所以我们开始吧。</p><p id="34aa" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在本教程中，我们将使用Gitlab管道，因为我是Gitlab的超级粉丝。同一个模板可以用于通过Bitbucket、Azure或任何其他提供者来引导管道。我将假设几乎没有关于设置CI/CD的知识，所以希望任何人都可以跟随。Gitlab文档也是了解更多关于CI/CD的极好资源—【https://docs.gitlab.com/ee/ci/introduction/ T2】</p><h1 id="a16c" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">构建基础Docker映像</h1><p id="a0b5" class="pw-post-body-paragraph kf kg it kh b ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky mg la lb lc im bi translated">您管道中的每个<em class="mh">作业</em>都在docker容器中运行。您可以使用一个通用的基础映像来支撑您的管道(例如node12 ),然后在其上安装您的所有依赖项，或者您可以构建一个包含依赖项的定制映像。</p><p id="9510" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我的偏好是构建一个自定义图像，并使用Gitlab容器注册表来存储这些图像。我构建无服务器应用程序的偏好是使用node/typescript，所以我的基本映像看起来像这样</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="1a56" class="mr lf it mn b gy ms mt l mu mv"><em class="mh">FROM </em>node:12<br/><br/><em class="mh">WORKDIR /</em>app<br/><br/><em class="mh"># install JRE for dynamo-offline (required for tests)<br/>RUN </em>apt-get update \<br/>    <em class="mh">&amp;&amp; </em>apt-get install <em class="mh">-</em>y default-jre \<br/>    <em class="mh">&amp;&amp; </em>apt-get clean \<br/>    <em class="mh">&amp;&amp; </em>rm <em class="mh">-</em>rf <em class="mh">/</em>var<em class="mh">/</em>lib<em class="mh">/</em>apt<em class="mh">/</em>lists<em class="mh">/*<br/><br/># Install serverless globally<br/>RUN </em>npm i <em class="mh">-</em>g serverless</span></pre><p id="ef88" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">注意:</strong> <em class="mh">我还将这些图像命名为Dockerfile.pipeline，以避免与项目中的其他图像混淆。你可以把它命名为管道。在您的实例中，Dockerfile或其他命名约定可能是首选。</em></p><p id="3c30" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们将在这里施展一些魔法，在我们的管道中重建我们的docker映像，<strong class="kh iu">，但是只有当docker文件发生变化时</strong>。我们能做到这一点要感谢一个叫做<em class="mh"> changes </em>的小标签，它在文件中寻找变化。</p><p id="cefb" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">下面是代码的输出示例。</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="d6ff" class="mr lf it mn b gy ms mt l mu mv">image: docker:latest</span><span id="e4e2" class="mr lf it mn b gy mw mt l mu mv">stages:<br/>  - build</span><span id="5a84" class="mr lf it mn b gy mw mt l mu mv">build-docker-image:<br/>  stage: build<br/>  image: docker:latest<br/>  services:<br/>    - docker:dind<br/>  script:<br/>    - docker login -u "$CI_REGISTRY_USER" -p "$CI_REGISTRY_PASSWORD" $CI_REGISTRY<br/>    - docker build --pull -t "$CI_REGISTRY_IMAGE" -f Dockerfile.pipeline .<br/>    - docker push "$CI_REGISTRY_IMAGE"<br/>  only:<br/>    changes:<br/>      - Dockerfile.pipeline</span></pre><p id="06c3" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">服务——docker:dind允许我们在docker中使用docker，在运行脚本的基本docker映像中构建一个新的docker映像。然后，我们构建新的映像，并将其推送到项目的Gitlab中的容器注册表中。现在，在管道的后续步骤中，我们可以引用此图像</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="86d8" class="mr lf it mn b gy ms mt l mu mv">image: $CI_REGISTRY_IMAGE:latest</span></pre><p id="1480" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如果我们不接触Dockerfile.pipeline，那么这个构建阶段就永远不会运行。</p><h1 id="12d1" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">配置我们的管道阶段</h1><p id="dfab" class="pw-post-body-paragraph kf kg it kh b ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky mg la lb lc im bi translated">您要在配置中做的下一件事是定义<em class="mh">阶段。</em>基本管道结构简单。您可以定义多个<em class="mh">阶段</em>，其中可以包含一个或多个<em class="mh">作业</em>。Stage中的所有作业都是并行运行的，但每个阶段都是并发运行的，一个阶段仅在前一个阶段完成后运行。</p><p id="9d43" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">一个常见的模式是有一个验证/测试阶段，然后是部署阶段。这种结构背后的理由是，您让尽可能多的任务并行运行，同时防止部署在您的测试和检查全部通过之前发生。</p><p id="883b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我的偏好是为无服务器添加一个额外的阶段。对于小项目来说，这稍微减慢了流水线的速度，但是对于大项目来说，这实际上会更有效。</p><p id="1b08" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我喜欢定义的阶段是:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="25b0" class="mr lf it mn b gy ms mt l mu mv">stages:<br/>  - build<br/>  - precheck<br/>  - test<br/>  - deploy</span></pre><p id="5d12" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我背后的理由是，如果我的任何<em class="mh"> precheck </em>作业失败，管道可以退出，而不需要运行(可能很慢的)测试套件。</p><p id="3ab5" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们还可以通过添加以下cache关键字来缓存构建过程的各个部分，以便在后续步骤和管道中重用</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="e99e" class="mr lf it mn b gy ms mt l mu mv">cache:<br/>  paths:<br/>    - node_modules/</span></pre><p id="fdff" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这里我们缓存node_modules目录，这样我们就不需要在每个作业中等待完整的节点安装。</p><h2 id="763d" class="mr lf it bd lg mx my dn lk mz na dp lo kq nb nc ls ku nd ne lw ky nf ng ma nh bi translated">预检阶段</h2><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="252e" class="mr lf it mn b gy ms mt l mu mv">has_lock_files:<br/>  stage: precheck<br/>  image: $CI_REGISTRY_IMAGE:latest<br/>  script:<br/>    - "if [[ -e 'package.json' &amp;&amp;  ! -e 'package-lock.json' ]]; then echo 'No lock file found. Please add a package-lock.json'; false; fi"<br/><br/>security_checker:<br/>  stage: precheck<br/>  image: $CI_REGISTRY_IMAGE:latest<br/>  script:<br/>    - npm audit --audit-level=moderate<br/><br/>eslint:<br/>  stage: precheck<br/>  image: $CI_REGISTRY_IMAGE:latest<br/>  script:<br/>    - npm i -D<br/>    - eslint . --ext .js,.jsx,.ts,.tsx<br/>    - tsc --noEmit</span></pre><p id="712e" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们在这里做的是</p><ol class=""><li id="c5fc" class="ni nj it kh b ki kj km kn kq nk ku nl ky nm lc nn no np nq bi translated"><strong class="kh iu"> has_lock_files: </strong>检查我们有package.json和package-lock.json来确保确定性的构建。如果这些文件中的任何一个丢失了，我们将立即退出。这运行得非常快，如果失败，就没有必要运行其他作业/阶段</li><li id="daae" class="ni nj it kh b ki nr km ns kq nt ku nu ky nv lc nn no np nq bi translated"><strong class="kh iu"> security_checker: </strong>我们对依赖项运行npm审计，检查任何已知的漏洞。我们将拒绝任何中等或更高水平的产品。</li><li id="4c61" class="ni nj it kh b ki nr km ns kq nt ku nu ky nv lc nn no np nq bi translated">在项目中实施林挺规则。如果你不执行林挺规则，制定这些规则是没有用的。失败任何有林挺错误的构建，你的生活会好得多。我们在这里做的另一件事就是检查typescript是否可以编译而没有任何错误(仅限于typescript项目)。最好在这里找到，而不是等着在后面的阶段发现你的代码甚至不能编译</li></ol><h2 id="a11d" class="mr lf it bd lg mx my dn lk mz na dp lo kq nb nc ls ku nd ne lw ky nf ng ma nh bi translated">测试阶段</h2><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="6361" class="mr lf it mn b gy ms mt l mu mv">tests:<br/>  stage: test<br/>  image: $CI_REGISTRY_IMAGE:latest<br/>  script:<br/>    - npm i -D<br/>    - NODE_ENV=test ./node_modules/.bin/jest --ci --verbose</span></pre><p id="beb7" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这个很简单。我们运行我们的测试套件，如果有任何测试失败，就会使管道失败。</p><h2 id="4c38" class="mr lf it bd lg mx my dn lk mz na dp lo kq nb nc ls ku nd ne lw ky nf ng ma nh bi translated">部署阶段</h2><p id="a9aa" class="pw-post-body-paragraph kf kg it kh b ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky mg la lb lc im bi translated">这就是神奇的地方，我们可以自动部署我们的代码😍</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="c288" class="mr lf it mn b gy ms mt l mu mv">staging_deploy:<br/>  stage: deploy<br/>  image: $CI_REGISTRY_IMAGE:latest<br/>  only:<br/>    - develop<br/>  script:<br/>    - npm ci<br/>    - cd / &amp;&amp; serverless config credentials --provider aws --key $AWS_ACCESS_KEY_ID_STAGING --secret $AWS_SECRET_ACCESS_KEY_STAGING &amp;&amp; cd -<br/>    - SLS_DEBUG=* serverless --stage stage<br/>    - for r in $DEPLOY_REGIONS; do SLS_DEBUG=* serverless deploy --verbose --force --stage stage --region $r; done<br/><br/><br/>production_deploy:<br/>  stage: deploy<br/>  image: $CI_REGISTRY_IMAGE:latest<br/>  only:<br/>    - master<br/>  script:<br/>    - npm ci<br/>    - cd / &amp;&amp; serverless config credentials --provider aws --key $AWS_ACCESS_KEY_ID_PRODUCTION --secret $AWS_SECRET_ACCESS_KEY_PRODUCTION &amp;&amp; cd -<br/>    - SLS_DEBUG=* serverless --stage prod<br/>    - for r in $DEPLOY_REGIONS; do SLS_DEBUG=* serverless deploy --verbose --force --stage prod --region $r; done</span></pre><p id="3ab2" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这里有一些操作，但本质上我们有相同的逻辑，只是设置了一个暂存环境和一个生产环境。为了简洁起见，我们将介绍一下试运行版本，但是要知道生产版本是完全一样的，它只是部署到不同的环境中，并且运行在master而不是develop上。如果你没有使用Git Flow。如果你正在使用<a class="ae ld" href="https://about.gitlab.com/blog/2020/03/05/what-is-gitlab-flow/" rel="noopener ugc nofollow" target="_blank"> Gitlab Flow </a>(或者其他一些分支模型，比如主干流)，你将需要做一些小的调整(当我走出阶段的时候，希望这是显而易见的)。</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="3fd8" class="mr lf it mn b gy ms mt l mu mv">only:<br/>    - develop</span></pre><p id="9393" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这里要注意的第一件事是我们已经为我们的作业添加了一个新属性。这只是告诉Gitlab只在成功合并到develop分支时运行这个作业。参见<a class="ae ld" href="https://docs.gitlab.com/ee/ci/yaml/#onlyexcept-basic" rel="noopener ugc nofollow" target="_blank">https://docs.gitlab.com/ee/ci/yaml/#onlyexcept-basic</a></p><p id="b604" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">你还会注意到我在这里选择使用<strong class="kh iu"> <em class="mh"> npm ci </em> </strong>而不是传统的npm安装。如果你不熟悉npm ci，我建议你在这里<a class="ae ld" href="https://docs.npmjs.com/cli/ci.html" rel="noopener ugc nofollow" target="_blank">探索一下</a>。</p><p id="efef" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">接下来，我们需要<strong class="kh iu">定义我们的凭证</strong>，以便通过无服务器CLI进行部署。</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="1ceb" class="mr lf it mn b gy ms mt l mu mv">- cd / &amp;&amp; serverless config credentials --provider aws --key $AWS_ACCESS_KEY_ID_STAGING --secret $AWS_SECRET_ACCESS_KEY_STAGING &amp;&amp; cd -</span></pre><p id="af0e" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这将设置我们的AWS访问密钥和密码。我们需要在Gitlab帐户中将这些定义为全局变量，这样才能工作。这些都是在gitlab.com/{group}/~/settings/ci-cd配置的</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nw"><img src="../Images/79e2c5da7c67bc5226945710fb3b5074.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jnsi1WiEF34N9KUXJa65sA.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">Gitlab全局环境变量</figcaption></figure><p id="0257" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我更喜欢全局定义它们，因为它们将在我的所有服务中重用。让每个服务使用相同的部署密钥意味着我可以毫不费力地频繁轮换它们。</p><p id="43de" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">您可能会注意到这里有些独特之处，我有一个名为<strong class="kh iu"> DEPLOYMENT_REGIONS </strong>的环境变量。关于无服务器，我最喜欢的一点是，您可以进行多区域复制和故障转移，基本上不需要额外的成本(按使用付费)。如果我们想要跨多个区域部署我们的所有服务，我们可以在这里定义多个AWS区域(用空格分隔的字符串),我们的管道将部署到所有这些区域。对此负责的管道配置部分是</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="ca8e" class="mr lf it mn b gy ms mt l mu mv">for r in $DEPLOY_REGIONS; do SLS_DEBUG=* serverless deploy --verbose --force --stage prod --region $r; done</span></pre><p id="0f6c" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这只是对这些部署区域的一个简单循环，运行无服务器框架部署实用程序来打包和部署代码。显然，如果你不使用AWS而选择Azure/GCP，这就不适用，但我相信他们有类似的概念。</p><h1 id="2294" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">完整代码示例</h1><p id="6b75" class="pw-post-body-paragraph kf kg it kh b ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky mg la lb lc im bi translated">Dockerfile文件</p><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="nx ny l"/></div></figure><p id="1b4b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">。gitlab-ci.yml</p><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="nx ny l"/></div></figure></div></div>    
</body>
</html>