<html>
<head>
<title>JavaScript and the Web — Focus Events and Timers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript和Web —焦点事件和计时器</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-and-the-web-focus-events-and-timers-6c93d1643f35?source=collection_archive---------12-----------------------#2020-06-24">https://levelup.gitconnected.com/javascript-and-the-web-focus-events-and-timers-6c93d1643f35?source=collection_archive---------12-----------------------#2020-06-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/13bfd9772167963e063e30ae70778737.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RN4ec2TdGbLEHRHZ"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@henry_be?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Henry Be </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="a329" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">JavaScript是世界上最流行的编程语言之一。为了有效地使用它，我们必须了解它的基本知识。</p><p id="c189" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将看看如何处理焦点事件和计时器。</p><h1 id="7158" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">焦点事件</h1><p id="cc16" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">当一个元素获得焦点时，<code class="fe mh mi mj mk b">focus</code>事件被触发。当它失去焦点时，就会触发<code class="fe mh mi mj mk b">blur</code>事件。这两个事件不会传播。</p><p id="56c0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当子进程获得或失去焦点时，父进程上的处理程序不会得到通知。</p><p id="9e63" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有一个按钮:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="554b" class="mt lf it mk b gy mu mv l mw mx">&lt;button&gt;<br/>  button<br/>&lt;/button&gt;</span></pre><p id="638f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们可以通过写来听这两个事件:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="f801" class="mt lf it mk b gy mu mv l mw mx">const button = document.querySelector('button');</span><span id="21a7" class="mt lf it mk b gy my mv l mw mx">button.addEventListener('focus', () =&gt; {<br/>  console.log('focus');<br/>})</span><span id="bc0b" class="mt lf it mk b gy my mv l mw mx">button.addEventListener('blur', () =&gt; {<br/>  console.log('blur');<br/>})</span></pre><p id="f9a5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们只需要叫<code class="fe mh mi mj mk b">addEventListener</code>去听他们的。</p><h1 id="1ad0" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">加载事件</h1><p id="a9e7" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">当窗口和文档体对象加载时，触发<code class="fe mh mi mj mk b">load</code>事件。</p><p id="9d0d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当遇到标签时，脚本标签立即运行，如果我们想运行操作页面的代码，这可能太快了。我们可能想在加载东西后听这个来运行代码。</p><p id="de7f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">像图像或脚本这样的元素可以有自己的load事件，当加载元素时会触发该事件。当一个页面被关闭或导航离开时，就会触发<code class="fe mh mi mj mk b">beforeunload</code>事件。它是用来防止我们因为关闭文档而意外丢失的。</p><p id="d9c1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们阻止该事件的默认行为，并将对象的<code class="fe mh mi mj mk b">returnVlue</code>属性设置为一个字符串。浏览器会显示一个对话框，询问我们是否真的要离开这个页面。</p><p id="6492" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它可能包括我们的字符串，但是恶意地试图使用这些对话框来迷惑人们停留在他们的页面上，所以浏览器不再显示<code class="fe mh mi mj mk b">returnValue</code>文本。</p><h1 id="6c6c" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">事件和事件循环</h1><p id="3645" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">事件循环对要运行的操作进行排队，直到它们准备好运行。只有在没有其他操作运行时，才会处理这些操作。如果一个事件循环与其他工作捆绑在一起，那么页面上的任何交互都将被延迟，直到有时间处理它。</p><p id="9554" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，如果我们正在做一些非常耗时的事情，那么它必须在后台完成。否则，它会冻结页面。</p><p id="0397" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要在后台运行，我们可以使用Web Workers。</p><p id="d19b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="5fcf" class="mt lf it mk b gy mu mv l mw mx">const worker = new Worker("code/cubeworker.js");<br/>worker.addEventListener("message", event =&gt; {<br/>  console.log(event.data);<br/>});<br/>worker.postMessage(10);<br/>worker.postMessage(24);</span></pre><p id="73c0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们编写一个<code class="fe mh mi mj mk b">cubeworker</code>来在后台进行计算，我们可以向它发送消息来发送计算数据。</p><p id="3063" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后一旦完成，<code class="fe mh mi mj mk b">message</code>事件监听器获取结果。</p><h1 id="e5b5" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">定时器</h1><p id="5a31" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mh mi mj mk b">setTimeout</code>函数让我们安排代码稍后运行。延迟代码的时间以毫秒为单位。</p><p id="c154" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="ef34" class="mt lf it mk b gy mu mv l mw mx">const fooTimer = setTimeout(() =&gt; {<br/>  console.log("foo");<br/>}, 500);</span></pre><p id="9859" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的代码将回调中的代码延迟了500毫秒。</p><p id="84b9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以使用<code class="fe mh mi mj mk b">clearTimeout</code>移除计时器:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="4952" class="mt lf it mk b gy mu mv l mw mx">if (Math.random() &lt; 0.5) {<br/>  console.log("stopped.");<br/>  clearTimeout(fooTimer);<br/>}</span></pre><p id="dd03" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，如果<code class="fe mh mi mj mk b">Math.random</code>返回小于0.5的值，计时器将不会运行，因为我们在它运行之前调用了<code class="fe mh mi mj mk b">clearTimeout</code>。</p><p id="2c33" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，还有定期运行代码的<code class="fe mh mi mj mk b">setInterval</code>函数。</p><p id="840e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">周期也以毫秒为单位。</p><p id="e3c3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="12fc" class="mt lf it mk b gy mu mv l mw mx">let ticks = 0;<br/>let clock = setInterval(() =&gt; {<br/>  console.log(ticks++);<br/>  if (ticks === 10) {<br/>    clearInterval(clock);<br/>    console.log("stopped");<br/>  }<br/>}, 200);</span></pre><p id="ed30" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们看到记录了0到9，然后记录了<code class="fe mh mi mj mk b">'stopped'</code>，因为我们每隔200毫秒运行一次回调来记录<code class="fe mh mi mj mk b">ticks</code>的值。</p><p id="546d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，当<code class="fe mh mi mj mk b">ticks</code>达到10时，我们通过运行<code class="fe mh mi mj mk b">clearIterval</code>来停止计时器。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/5ecb64d1a24875c6b0a6ae065d6101d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*n4nV7Lu2ofyYdwE5"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@gavla?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Gavin Allanwood </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="8663" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">去抖动</h1><p id="abfd" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">去抖意味着我们延迟一些事件处理程序代码，这样它们就不会运行得太频繁。</p><p id="c9ef" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以用<code class="fe mh mi mj mk b">setTimeout</code>来做到这一点。</p><p id="39c2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有一个输入:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="ac3e" class="mt lf it mk b gy mu mv l mw mx">&lt;input /&gt;</span></pre><p id="32c6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以通过写入以下内容来延迟值的记录:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="c671" class="mt lf it mk b gy mu mv l mw mx">let input = document.querySelector("input");<br/>let timeout;<br/>input.addEventListener("input", () =&gt; {<br/>  clearTimeout(timeout);<br/>  timeout = setTimeout(() =&gt; console.log(input.value),  500);<br/>});</span></pre><p id="43a4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">侦听器清除旧的计时器，然后创建一个新的计时器，在500毫秒后记录该值。</p><h1 id="806d" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="ac9f" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">焦点事件不会传播，所以它们局限于触发它的对象。</p><p id="fd28" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还可以添加计时器来定期运行或在设定的延迟间隔后运行一次。</p><p id="8a5e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以公开声明侦听器代码，这样它们就不会太频繁地运行。</p></div></div>    
</body>
</html>