<html>
<head>
<title>React Hooks and the Evolution of State Management</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React Hooks和状态管理的发展</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/react-hooks-and-the-evolution-of-state-management-825adc1cc927?source=collection_archive---------9-----------------------#2020-06-10">https://levelup.gitconnected.com/react-hooks-and-the-evolution-of-state-management-825adc1cc927?source=collection_archive---------9-----------------------#2020-06-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/756450676bdccc5b3b9f583830df5c00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N45T1kFJVmlq1wjW6ux-zg.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">德国巴伐利亚州teufelstättkopf-2019年12月</figcaption></figure><p id="248a" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在这篇文章中，我想分享ReactJS的简史和它对国家管理的解决方案。你可能已经知道了这些，但是我认为对于那些刚接触这个框架的人来说，它会让你一瞥React是如何发展的，或者如果你是一个老手，它会让你快速更新。</p><h1 id="c998" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">组件的两个阵营</h1><p id="9f4e" class="pw-post-body-paragraph kf kg it kh b ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky mf la lb lc im bi translated">React有两种类型的组件——基于类的和功能性的。顾名思义，类组件继承了<code class="fe mg mh mi mj b">React.Component</code>并实现了诸如<code class="fe mg mh mi mj b">constructor</code>和<code class="fe mg mh mi mj b">render</code>之类的方法用于React调用，而函数组件则是字面上的“函数”,它接受一些输入“道具”并返回要呈现的组件。</p><p id="07fe" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在<a class="ae mk" href="https://reactjs.org/blog/2018/12/19/react-v-16-7.html" rel="noopener ugc nofollow" target="_blank"> React v16.8 </a>之前，只有<strong class="kh iu">类组件</strong>可以维护状态并公开一个处理程序来更新状态。此外，在整个组件生命周期的不同时间点，有一整套方法来执行状态管理、副作用和计算。类组件可以完成渲染单页面应用程序所需的一切工作，甚至可以通过<code class="fe mg mh mi mj b">PureComponent</code>进行性能优化，这也是完成这些工作的唯一方法。</p><p id="50f0" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">功能组件</strong>则是不能有状态和副作用的纯功能，只是渲染。我们可以称它们为“哑组件”，与包含更多业务逻辑、副作用、状态操作和子组件控制的“智能组件”相对应。</p><h1 id="39c0" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">为什么我们不能用类组件来解决？</h1><p id="93d6" class="pw-post-body-paragraph kf kg it kh b ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky mf la lb lc im bi translated">因此，类组件似乎足够强大，可以解决我们的日常问题，构建我们需要的各种应用程序。然而，使用类组件有各种缺点:</p><ul class=""><li id="3ceb" class="ml mm it kh b ki kj km kn kq mn ku mo ky mp lc mq mr ms mt bi translated">在<code class="fe mg mh mi mj b">constructor</code>中调用<code class="fe mg mh mi mj b">super(props)</code>的样板文件</li><li id="0016" class="ml mm it kh b ki mu km mv kq mw ku mx ky my lc mq mr ms mt bi translated">与<code class="fe mg mh mi mj b">this</code>关键字的绑定问题(即声明类方法时必须在<code class="fe mg mh mi mj b">constructor</code>中执行<code class="fe mg mh mi mj b">this.someMethod = this.someMethod.bind(this)</code>，除非用数组函数语法将其声明为类字段，这需要babel插件进行编译)</li><li id="6822" class="ml mm it kh b ki mu km mv kq mw ku mx ky my lc mq mr ms mt bi translated">跨多个生命周期方法传播业务逻辑和数据操作</li><li id="8285" class="ml mm it kh b ki mu km mv kq mw ku mx ky my lc mq mr ms mt bi translated">有状态逻辑的可重用性——像<code class="fe mg mh mi mj b">this.state</code>和<code class="fe mg mh mi mj b">this.setState</code>这样的状态管理方法附加在类组件上，很难与具有类似需求的其他组件共享</li><li id="2b1f" class="ml mm it kh b ki mu km mv kq mw ku mx ky my lc mq mr ms mt bi translated">命令式与声明式——函数式和声明式代码更适合具有更高可读性和可测试性的UI表示</li></ul></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><p id="4ef4" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">因此，React社区倾向于函数组件，它本质上只是类组件的<code class="fe mg mh mi mj b">render</code>方法，放弃了其他生命周期方法。然后其他工具和模式进来，为功能组件“修补”缺失的状态管理特性，比如Redux带来了全局存储和缩减器，recompose给了我们<code class="fe mg mh mi mj b">withState</code>和<code class="fe mg mh mi mj b">withHandlers</code>等。</p><p id="820e" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这些库中的大多数使用高阶组件(HOC)模式，这种模式包含函数组合，这是函数式编程中非常核心的模式。这可能会使我们避免类组件的缺点，并充分发挥函数组件的能力，但包装器地狱问题是HOC的致命弱点，它使虚拟dom树非常复杂，并损害了渲染性能。</p><h1 id="e00b" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">功能组件的官方“扩展”</h1><p id="52d7" class="pw-post-body-paragraph kf kg it kh b ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky mf la lb lc im bi translated">在开源社区的所有这些尝试之后，React团队最终<a class="ae mk" href="https://www.youtube.com/watch?v=V-QO-KO90iQ" rel="noopener ugc nofollow" target="_blank">提出了</a>2018年的官方解决方案React hooks。钩子试图用不同的模式解决同样的问题，功能组件中的状态管理。<a class="ae mk" href="https://reactjs.org/docs/hooks-intro.html#classes-confuse-both-people-and-machines" rel="noopener ugc nofollow" target="_blank">钩子提案中提到的</a>:</p><blockquote class="ng"><p id="5357" class="nh ni it bd nj nk nl nm nn no np lc dk translated">钩子让你不用类就可以使用更多的React特性。</p></blockquote><p id="95d2" class="pw-post-body-paragraph kf kg it kh b ki nq kk kl km nr ko kp kq ns ks kt ku nt kw kx ky nu la lb lc im bi translated">带有钩子的函数组件结束了类组件的时代，以及所有用于状态管理的第三方库。</p><p id="f2a8" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如果像<code class="fe mg mh mi mj b">recompose</code>和<code class="fe mg mh mi mj b">redux</code>这样的第三方包用HOC杀死了类组件，那么很可能hooks和其他React 16+新API杀死了那些第三方，把那些特性带回了“官方React”。</p><ul class=""><li id="c615" class="ml mm it kh b ki kj km kn kq mn ku mo ky mp lc mq mr ms mt bi translated"><code class="fe mg mh mi mj b">useState</code>可以代替<code class="fe mg mh mi mj b">withState</code></li><li id="0ef9" class="ml mm it kh b ki mu km mv kq mw ku mx ky my lc mq mr ms mt bi translated"><code class="fe mg mh mi mj b">useEffect</code>可以代替<code class="fe mg mh mi mj b">lifecycle</code></li><li id="33a1" class="ml mm it kh b ki mu km mv kq mw ku mx ky my lc mq mr ms mt bi translated"><code class="fe mg mh mi mj b">useMemo</code>和内联函数可以代替<code class="fe mg mh mi mj b"> withHandlers</code></li><li id="73b9" class="ml mm it kh b ki mu km mv kq mw ku mx ky my lc mq mr ms mt bi translated"><code class="fe mg mh mi mj b">useReducer</code>可以替换<code class="fe mg mh mi mj b">redux</code>中的减速器</li><li id="ec93" class="ml mm it kh b ki mu km mv kq mw ku mx ky my lc mq mr ms mt bi translated">React上下文API可以替换<code class="fe mg mh mi mj b">redux</code>中的全局存储</li><li id="0b8a" class="ml mm it kh b ki mu km mv kq mw ku mx ky my lc mq mr ms mt bi translated"><code class="fe mg mh mi mj b">React.memo</code>可以代替<code class="fe mg mh mi mj b">recompose</code>中的<code class="fe mg mh mi mj b">PureComponent</code>或<code class="fe mg mh mi mj b">pure</code></li></ul><p id="10f3" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在大规模应用中，仍然有有效的用例使用<code class="fe mg mh mi mj b">redux</code>和<code class="fe mg mh mi mj b">redux-saga</code>，但是<code class="fe mg mh mi mj b">recompose</code>已经完全被钩子<a class="ae mk" href="https://github.com/acdlite/recompose/tree/3db12ce7121a050b533476958ff3d66ded1c4bb8#a-note-from-the-author-acdlite-oct-25-2018" rel="noopener ugc nofollow" target="_blank">取代了</a>。</p><figure class="nv nw nx ny gt ju"><div class="bz fp l di"><div class="nz oa l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">展示从类组件到钩子的转换的动画</figcaption></figure></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><p id="112e" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">对我来说，hooks的机制太强大了，它带来了新的概念，我怀疑是否在我的项目中采用它。例如，我花了一些时间去理解<code class="fe mg mh mi mj b">useEffect</code>钩子和它的依赖数组。我还觉得在渲染函数中声明副作用有点奇怪。</p><p id="bafd" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在小规模项目的一些新组件上进行试验后，我发现在功能组件中进行状态管理既简单又清晰。我不再需要追踪道具从哪里来，在生命周期方法和多层HOC之间跳来跳去寻找业务逻辑，深入研究HOC以找出注入了哪些道具。开发和调试体验大大改善，更不用说渲染性能的提升。</p><h1 id="ccaa" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">这都是关于取舍的</h1><p id="8408" class="pw-post-body-paragraph kf kg it kh b ki mb kk kl km mc ko kp kq md ks kt ku me kw kx ky mf la lb lc im bi translated">当然，我并不是说类组件消失了，我们应该将所有组件迁移到函数式风格。事实上，React团队没有计划弃用类组件，也不建议进行大分解来重写所有现有的组件。</p><p id="f00f" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">毕竟，凡事都有取舍，选择解决正确问题的正确模式是一个品味问题。</p><p id="a377" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我希望您现在对状态管理的发展有了更多的了解，并找到适合您的用例的最佳模式。</p></div></div>    
</body>
</html>