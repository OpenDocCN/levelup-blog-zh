<html>
<head>
<title>Using RxJS Join Creation Operators to Combine Observer Data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用RxJS连接创建运算符合并观察点数据</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/using-rxjs-join-creation-operators-to-combine-observer-data-4b02fa94e95a?source=collection_archive---------0-----------------------#2020-02-08">https://levelup.gitconnected.com/using-rxjs-join-creation-operators-to-combine-observer-data-4b02fa94e95a?source=collection_archive---------0-----------------------#2020-02-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/de731558e105865a3d24852c6eec8a69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LoEg_3N1vqc_jgZi"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由✍拍摄🏻| Iphone 6摄影 on <a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></figcaption></figure><p id="5e24" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">RxJS是一个反应式编程的库。创建操作符对于从各种数据源生成供观察者订阅的数据非常有用。</p><p id="95f9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将研究一些连接创建操作符，将来自多个可观察对象的数据组合成一个可观察对象。我们将看看<code class="fe le lf lg lh b">combineLatest</code>、<code class="fe le lf lg lh b">concat</code>和<code class="fe le lf lg lh b">forkJoin</code>操作符。</p><h1 id="fa40" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">组合测试</h1><p id="5a7e" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">我们可以使用<code class="fe le lf lg lh b">combineLatest</code>将多个观察值合并为一个，其值是根据每个输入观察值的最新值计算出来的。</p><p id="5c10" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它接受两个或更多的可观察值作为自变量，或者一个可观察值数组作为自变量。它返回一个发出值的可观察对象，这些值是传入的所有可观察对象的值的数组。</p><p id="5460" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">combineLatest</code>还采用了一个可选的<code class="fe le lf lg lh b">project</code>函数，该函数采用通常由结果可观察对象发出的所有值的参数，然后我们可以返回我们想要的给定函数中的值。</p><p id="6e51" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">combineLatest</code>按顺序订阅每个Observable ke，每当一个Observable发出时，将发出的数据收集到每个Observable的最新值的数组中。然后由返回的可观察对象发出值数组。</p><p id="beaf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了确保输出数组总是有相同的长度，<code class="fe le lf lg lh b">combineLastest</code>在开始输出结果之前，等待所有的输入观测值至少发出一次。如果一些可观察对象在其他对象之前发出值，那么这些值将会丢失。</p><p id="7cc8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果一些Observable没有在完成时发出，那么返回的Observable将完成而不发出任何东西，因为那个Observable没有发出任何值。</p><p id="4c28" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果至少有一个可观察对象被传入<code class="fe le lf lg lh b">combineLatest</code>并且它们都发出了一些东西，那么当所有组合流完成时，返回的可观察对象也将完成。在这种情况下，该值将始终是先前完成的观察值的最后一个发出的值。</p><p id="50ed" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以如下使用它:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="c520" class="mt lj it lh b gy mu mv l mw mx">import { combineLatest, of } from "rxjs";</span><span id="8839" class="mt lj it lh b gy my mv l mw mx">const observable1 = of(1, 2, 3);<br/>const observable2 = of(4, 5, 6);<br/>const combined = combineLatest(observable1, observable2);<br/>combined.subscribe(value =&gt; console.log(value));</span></pre><p id="4254" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们得到:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="6c07" class="mt lj it lh b gy mu mv l mw mx">[3, 4]<br/>[3, 5]<br/>[3, 6]</span></pre><p id="e605" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为<code class="fe le lf lg lh b">observable1</code>在<code class="fe le lf lg lh b">observable2</code>之前发出了它的所有值。</p><p id="f0f0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还可以使用可选的第二个参数来进行一些计算:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="d19d" class="mt lj it lh b gy mu mv l mw mx">import { combineLatest, of } from "rxjs";<br/>import { map } from "rxjs/operators";</span><span id="9dcd" class="mt lj it lh b gy my mv l mw mx">const observable1 = of(1, 2, 3);<br/>const observable2 = of(4, 5, 6);<br/>const combined = combineLatest(observable1, observable2).pipe(<br/>  map(([a, b]) =&gt; a + b)<br/>);<br/>combined.subscribe(value =&gt; console.log(value));</span></pre><p id="a806" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们得到了这些值的总和。然后我们得到:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="903d" class="mt lj it lh b gy mu mv l mw mx">7<br/>8<br/>9</span></pre><p id="5ad4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这些是我们之前所有条目的总和。</p><h1 id="1764" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">串联</h1><p id="cb65" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">我们可以使用<code class="fe le lf lg lh b">concat</code>操作符来获取多个可观察值，并返回一个新的可观察值，这个新的可观察值顺序地从传入的每个可观察值中发出值。</p><p id="febe" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它的工作方式是一次订阅一个，并将结果合并到可观察的输出中。我们可以传入一组观察值，或者直接将它们作为参数。传入一个空数组将导致一个立即完成的可观察对象。</p><p id="d3b3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">concat</code>不会以任何方式影响可观测量。当一个Observable完成时，它将订阅下一个Observable并发出它的值。这一过程将一直重复，直到操作员看不到任何东西。</p><p id="e0d2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">merge</code>算子会同时输出可观测量的值。</p><p id="7503" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果一些输入的可观察值永远不会完成，<code class="fe le lf lg lh b">concat</code>也永远不会完成，它们后面的可观察值永远不会被订阅。如果某个可观察对象完成时没有发出任何值，那么它对<code class="fe le lf lg lh b">concat</code>来说将是不可见的。</p><p id="2998" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果链中的任何可观察对象发出错误，那么该错误将立即出错。在错误永远不会被订阅的可观察值之后被订阅的可观察值。</p><p id="7250" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以在同一个可观察的订阅中反复传递同一个。</p><p id="b0e3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以如下使用它:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="acbb" class="mt lj it lh b gy mu mv l mw mx">import { concat, of } from "rxjs";</span><span id="aa17" class="mt lj it lh b gy my mv l mw mx">const observable1 = of(1, 2, 3);<br/>const observable2 = of(4, 5, 6);<br/>const concatted = concat(observable1, observable2);<br/>concatted.subscribe(value =&gt; console.log(value));</span></pre><p id="1012" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们得到:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="199b" class="mt lj it lh b gy mu mv l mw mx">1<br/>2<br/>3<br/>4<br/>5<br/>6</span></pre><p id="2e41" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我们所料。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/6529a9657a927afb3e3c6384f5858c9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*j-t31YtlSSN5Ddvv"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">Dilyara Garifullina 在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="6859" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">叉连接</h1><p id="8edb" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated"><code class="fe le lf lg lh b">forkJoin</code>接受一个Observables数组，并发出一个与传递的数组顺序完全相同的值数组或一个与传递的字典形状相同的值字典。</p><p id="fc33" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">返回的可观察对象将发出每个可观察对象发出的最后一个值。例如，我们可以写:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="99cf" class="mt lj it lh b gy mu mv l mw mx">import { forkJoin, of } from "rxjs";</span><span id="7fd6" class="mt lj it lh b gy my mv l mw mx">const observable1 = of(1, 2, 3);<br/>const observable2 = of(4, 5, 6);<br/>const joined = forkJoin(observable1, observable2);<br/>joined.subscribe(value =&gt; console.log(value));</span></pre><p id="471b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们得到<code class="fe le lf lg lh b">[3, 6]</code>。</p><p id="4e43" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还可以传入一个具有可观察属性的对象:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="20d6" class="mt lj it lh b gy mu mv l mw mx">import { forkJoin, of } from "rxjs";</span><span id="2b97" class="mt lj it lh b gy my mv l mw mx">const observable1 = of(1, 2, 3);<br/>const observable2 = of(4, 5, 6);<br/>const joined = forkJoin({ observable1, observable2 });<br/>joined.subscribe(value =&gt; console.log(value));</span></pre><p id="4fc6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们得到:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="bd76" class="mt lj it lh b gy mu mv l mw mx">{observable1: 3, observable2: 6}</span></pre><h1 id="fdd9" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">结论</h1><p id="56d6" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated"><code class="fe le lf lg lh b">combineLatest</code>、<code class="fe le lf lg lh b">concat</code>和<code class="fe le lf lg lh b">forkJoin</code>操作符对于组合来自多个观测值的发射数据非常有用。</p><p id="3ffc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用<code class="fe le lf lg lh b">combineLatest</code>，我们可以组合来自多个可观察对象的发射数据，并获得由我们传入的每个可观察对象发射的最新值组成的值数组。</p><p id="780d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">concat</code>操作符订阅我们顺序传入的每个可观察对象，并返回一个从每个可观察对象顺序发出值的可观察对象。如果一个错误发生在任何一个可观察对象上，那么返回的可观察对象就会发出一个错误。</p><p id="c799" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，<code class="fe le lf lg lh b">forkJoin</code>操作符返回一个可观察对象，它从每个可观察对象中获取最新的值，并根据您传入的是可观察对象的字典还是可观察对象的数组，将值作为对象或数组发出。</p></div></div>    
</body>
</html>