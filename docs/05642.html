<html>
<head>
<title>Day/Night Colour Switching Using CSS3 Variables and Minimal Vanilla JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用CSS3变量和最少的普通JavaScript进行日夜颜色切换</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/day-night-colour-switching-using-css3-variables-and-minimal-vanilla-javascript-a54fa36c550f?source=collection_archive---------6-----------------------#2020-09-17">https://levelup.gitconnected.com/day-night-colour-switching-using-css3-variables-and-minimal-vanilla-javascript-a54fa36c550f?source=collection_archive---------6-----------------------#2020-09-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/f092bd633700c66c07850613d8ae85ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hSXWRsGQc5vd0sRoEfSYtw.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">日日夜夜，在我的皮肤下…</figcaption></figure><p id="dfb4" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">界面设计的一个最新趋势是能够在亮主题和暗主题之间进行选择。这提高了许多用户的可用性和可访问性，特别是那些晚上在黑暗的房间里浏览网站的用户。给用户选择总是一个好主意。</p><p id="2ad8" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我已经看到许多实现跨越了一些…有趣的障碍。我有更强烈的词来形容它，但我们姑且称之为“有趣”。JS中的CSS，动态加载一个完全独立的样式表，服务器端处理…但是事实证明，有了新的CSS3伪状态，比如:checked和:target，人们用JavaScript做的很多事情甚至不再是JavaScript的工作了。<a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/modal-dialog-driven-websites-without-javascript-16e858615780">模态对话框</a>、<a class="ae le" rel="noopener ugc nofollow" target="_blank" href="/tabbed-interfaces-without-javascript-661bab1eaec8">选项卡子部分</a>，甚至颜色切换几乎都可以完全由CSS处理，只需要很少的JavaScript。</p><p id="cfa5" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在颜色切换的情况下，我们真正需要JavaScript的唯一事情是记住/存储/恢复页面加载的状态。我们剩下的所有繁重工作都可以基于一个<code class="fe lf lg lh li b">INPUT</code>标签的状态在样式表中完成！</p><h1 id="cae0" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">加价</h1><p id="9607" class="pw-post-body-paragraph kf kg it kh b ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky ml la lb lc im bi translated">在HTML方面，我们所需要的是一个“人造主体”——<code class="fe lf lg lh li b">DIV</code>，因为输入不能在<code class="fe lf lg lh li b">BODY</code>之前——以及一个隐藏的<code class="fe lf lg lh li b">INPUT</code>标签。“人造体”只是一个容器，我们把它当作体来对待，它通常是在模态驱动的布局中完成的，这样你就不会同时出现两个滚动条。在我们的情况下，它可以为页面的颜色和风格提供双重功能。</p><p id="cbe0" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们的<code class="fe lf lg lh li b">INPUT</code>和<code class="fe lf lg lh li b">DIV</code>:</p><pre class="mm mn mo mp gt mq li mr ms aw mt bi"><span id="91a8" class="mu lk it li b gy mv mw l mx my">&lt;input<br/>  type="checkbox"<br/>  id="toggle_nightAndDay"<br/>  class="toggle rememberState"<br/>  hidden<br/>  aria-hidden="true"<br/>&gt;</span><span id="8b1c" class="mu lk it li b gy mz mw l mx my">&lt;div id="fauxBody"&gt;<br/>  &lt;!-- put your page content here --&gt;<br/>&lt;!-- #fauxBody --&gt;&lt;/div&gt;</span></pre><p id="a424" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">都相对简单。这是一个复选框，ID是一个<code class="fe lf lg lh li b">LABEL</code>指向所需要的，类“toggle”对于页面上所有隐藏的切换复选框是通用的，因为我们可能有其他的复选框，并且简单地将它们恢复为在我们的屏幕媒体样式表中可见。hidden属性应该防止所有用户代理(浏览器是一个UA，但UA并不总是浏览器)看到输入或与输入交互，但有些用户代理也需要aria-hidden属性来防止这种情况。我们可以通过将它们设置为display:block，然后通过将其滑动到屏幕之外来隐藏它们，从而使它们在屏幕媒体样式表中再次可交互。</p><p id="2f30" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">从那里，在我们的标记中的任何地方——比如说在主菜单中——我们可以创建一个元素，用一个<code class="fe lf lg lh li b">LABEL</code>来显示我们的实际切换状态。</p><pre class="mm mn mo mp gt mq li mr ms aw mt bi"><span id="fac2" class="mu lk it li b gy mv mw l mx my">&lt;label for="toggle_nightAndDay"&gt;&lt;/label&gt; </span></pre><p id="2da9" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">HTML最神奇的地方之一是，点击一个<code class="fe lf lg lh li b">LABEL</code>，即<code class="fe lf lg lh li b">FOR </code>、<code class="fe lf lg lh li b">SELECT</code>或<code class="fe lf lg lh li b">TEXTAREA</code>的<code class="fe lf lg lh li b">ID</code>，在功能上与点击那个元素是一样的。因此，你可以把那个<code class="fe lf lg lh li b">LABEL</code>放在你的标记中的任何地方，点击它将选中/取消选中我们的复选框！</p><h2 id="1034" class="mu lk it bd ll na nb dn lp nc nd dp lt kq ne nf lx ku ng nh mb ky ni nj mf nk bi translated">关于屏幕媒体的一个注记</h2><p id="2b24" class="pw-post-body-paragraph kf kg it kh b ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky ml la lb lc im bi translated">你会看到我说了很多“屏幕媒体”，我指的是在你的样式表<code class="fe lf lg lh li b">LINK</code>上使用<code class="fe lf lg lh li b">media="screen"</code>，或者如果你是个白痴<code class="fe lf lg lh li b">STYLE</code>。例如:</p><pre class="mm mn mo mp gt mq li mr ms aw mt bi"><span id="68d3" class="mu lk it li b gy mv mw l mx my">&lt;link<br/>  rel="stylesheet"<br/>  href="screen.css"<br/>  media="screen,projection,tv"<br/>&gt;</span></pre><p id="ab34" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如果你链接或使用的内联CSS只是为了你页面上的屏幕媒体而没有<code class="fe lf lg lh li b">media</code>属性，或者你发送的是<code class="fe lf lg lh li b">media="all"</code>，你就没有理解CSS的目的以及为什么它与HTML是分开的。你应该<strong class="kh iu">而不是</strong>将你的屏幕布局发送给印刷、听觉或其他任何东西。</p><p id="39af" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">较老的<code class="fe lf lg lh li b">projection</code>和<code class="fe lf lg lh li b">tv</code>媒体类型仍然被许多流通中的设备使用，以告诉它们我们知道我们在做什么，并且包含它们没有害处。在大多数情况下——比如在Wii或DS浏览器<em class="ld">(仍然基于Opera 12)</em>或许多公共亭上——它对他们的行为非常类似于viewport <code class="fe lf lg lh li b">META</code>告诉mobile " <em class="ld">我们知道我们在做什么，用你愚蠢的专有废话把它剪掉！</em></p><p id="bfea" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">是的，它们在大约一年前的HTML 5中是“无效”的…这只是<em class="ld">如此可爱</em>在文档中没有版本控制，并且在那之前一直是有效的HTML 5。有点像几乎同时交换TBODY和TFOOT，同时使TFOOT优先的旧方法无效的心理困难。由于“活文档”的愚蠢，这是一个任意的、无意义的改变，没有跟踪它的方法。<em class="ld">以防你猜不出，不是粉丝。</em></p><p id="f8d9" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这只是让你的文档满足现代HTML 5验证毫无意义的众多因素之一。当“无效”的东西仅仅在一两年前在相同的doctype下是有效的，并且许多用户代理仍然需要它来正常工作时，他们可以去吮吸所说的验证警告、错误等等。</p><p id="e837" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">无论如何，如果你使用没有媒体属性的<code class="fe lf lg lh li b">LINK</code>或<code class="fe lf lg lh li b">STYLE</code>或者设置为“all ”,你就做错了。就像你100%的时间在标记中看到<code class="fe lf lg lh li b">&lt;style&gt;</code>，99%的时间看到<code class="fe lf lg lh li b">style=””</code>，你看到的是web开发中那些讨厌的“3i”:无知、无能和不称职。</p><h1 id="b90d" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">CSS:</h1><p id="4372" class="pw-post-body-paragraph kf kg it kh b ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky ml la lb lc im bi translated">当你可以在样式表中搜索/替换时，CSS变量总是让我觉得毫无意义。在以前的实现中，使用了大量浪费时间的无知垃圾，它们是CSS的“预处理器”，提供了很少甚至没有合法的好处。坦率地说，如果它们真的服务于一个目的，那就是要么让没有资格使用CSS的人尝试和修改值，要么纵容那些似乎使用了两倍到十倍所需CSS的人，因为他们从未掌握分组选择器。</p><p id="50f9" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">更糟糕的是，在预处理器中，它们甚至不是变量，而是声明。更类似于常量或define，tou不能在JavaScript或样式表中动态改变它们。</p><p id="87e0" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">原生CSS变量改变了这一切。当您通过使用JS添加更多CSS或者在基于选择器的现有样式表中更改它们时，整个布局都会发生变化……您可以通过伪类、伪状态和其他类似的选择器、组合符和方法来分配它们；例如:输入的checked属性！</p><p id="92ac" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在大多数关于原生CSS变量的教程和讨论中，你会看到很多人说你应该把它赋给<code class="fe lf lg lh li b">:root</code>伪元素。许多人甚至说，它应该只分配给所说的元素，这是一个赤裸裸的谎言。您可以将变量分配给任何选择器，它们将只应用于选择器内部。使用<code class="fe lf lg lh li b">:root</code>的原因是<code class="fe lf lg lh li b">&lt;html&gt;</code>是现代浏览器中<code class="fe lf lg lh li b">&lt;body&gt;</code>下面的一个渲染元素，你可能想给这些变量分配一个更高的级别。因为我们需要使用一个人造身体，所以没有理由这样做，所以我们可以在身体级别分配它们，然后用选择器/组合器将它们分配给我们的<code class="fe lf lg lh li b">div#fauxBody</code></p><p id="3fbd" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">因此，对于我们正常的风格变量:</p><pre class="mm mn mo mp gt mq li mr ms aw mt bi"><span id="d450" class="mu lk it li b gy mv mw l mx my">body {</span><span id="2d2a" class="mu lk it li b gy mz mw l mx my">  --hue:220;<br/> <br/>  --body-background:hsl(var(--hue), 100%, 95%);<br/>  --body-color:hsl(var(--hue), 100%, 10%);<br/> <br/>  --header-background:hsl(var(--hue), 100%, 90%);<br/>  --header-border-color:#0007;<br/> <br/>  --footer-background:var(--header-background);<br/>  --footer-border-color:var(--header-border-color);<br/>  --footer-a-color:hsla(var(--hue), 100%,  15%, 0.8);<br/>  --footer-a-hover-color:#000E;<br/>  <br/>  /* etc, etc, etc */</span><span id="67db" class="mu lk it li b gy mz mw l mx my">}</span></pre><p id="3b4b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们分配给身体，然后我们可以使用这个选择器来分配我们的“暗”皮肤，当复选框被…选中时。</p><pre class="mm mn mo mp gt mq li mr ms aw mt bi"><span id="118b" class="mu lk it li b gy mv mw l mx my">#toggle_nightAndDay:checked ~ * {</span><span id="d0d1" class="mu lk it li b gy mz mw l mx my">  --hue:240;<br/> <br/>  --body-background:hsl(var(--hue), 100%, 5%);<br/>  --body-color:hsl(var(--hue), 100%, 90%);<br/> <br/>  --header-background:hsl(var(--hue), 100%, 20%);<br/>  --header-border-color:#FFF4;<br/> <br/>  --footer-background:var(--header-background);<br/>  --footer-border-color:var(--header-border-color);<br/>  --footer-a-color:hsla(var(--hue), 100%,  90%, 0.8);<br/>  --footer-a-hover-color:#FFFE;</span><span id="6376" class="mu lk it li b gy mz mw l mx my">  /* etc, etc, etc */</span><span id="d0a6" class="mu lk it li b gy mz mw l mx my">}</span></pre><p id="789a" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">通用兄弟组合符“~”和所有元素选择器“*”的使用不仅影响到我们的<code class="fe lf lg lh li b">#fauxBody</code>，还影响到它的任何兄弟，如<code class="fe lf lg lh li b">.modal</code>。</p><p id="107c" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><em class="ld">很多人说你应该“永远不要”使用“所有元素选择器”,因为它莫名其妙地“慢”了。结合一般的兄弟姐妹，我们限制它的应用，消除这种担忧。</em></p><p id="3f76" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我接受了把所有事情都说成是“坏”的想法，但最近对我的重新评估越来越显示这种说法是赤裸裸的谎言。我可能会在某个时候写一篇文章来测试这个问题 <a class="ae le" href="https://medium.com/me/stats/post/827ff7d15203" rel="noopener"> <em class="ld">，就像我对虚构的和无意义的类与选择器和组合子的“渲染时间”争论所做的那样。说真的，这个行业似乎充斥着人们编造一些事情来证明他们自己的个人喜好的做事方式。</em></a></p><p id="072e" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">还要注意我是如何分配<code class="fe lf lg lh li b">--hue</code>的。这样，我们可以快速轻松地改变整个布局的颜色，而不需要使用其他值。为了展示这一点，我将“白天”版本设置为“青色-蓝色”，但在“夜晚”，我选择了“真正的蓝色”。当创建布局时，其他人会重新着色，使用HSL和变量可以使生活变得容易得多。你想要红色的吗？设定<code class="fe lf lg lh li b">--hue=0;</code>你要绿色？<code class="fe lf lg lh li b">--hue=120;</code></p><p id="6fa1" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">当需要在页面中分配这些颜色时，我们就像处理任何CSS变量一样，例如:</p><pre class="mm mn mo mp gt mq li mr ms aw mt bi"><span id="fd6e" class="mu lk it li b gy mv mw l mx my">.modal,<br/>#fauxBody {<br/> background:var(--body-background);<br/> color:var(--body-color);<br/>}</span></pre><p id="2ab3" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">对于<code class="fe lf lg lh li b">LABEL</code>,如果它在比如说，我们的<code class="fe lf lg lh li b">#mainMenu</code>在一个<code class="fe lf lg lh li b">LI.nightAndDay</code>里面，我们可以把它隔离出来，让生成的内容说“白天”或“晚上”,这样:</p><pre class="mm mn mo mp gt mq li mr ms aw mt bi"><span id="c3ce" class="mu lk it li b gy mv mw l mx my">#mainMenu .nightAndDay label:before {<br/>  content:"Day Mode";<br/>}</span><span id="5cea" class="mu lk it li b gy mz mw l mx my">#toggle_nightAndDay:checked ~ #fauxBody #mainMenu .nightAndDay label:before {<br/>  content:"Night Mode";<br/>}</span></pre><p id="8964" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">你可以把生成的内容换成任何你能想到的CSS能做到的效果和内容。因为我们通过生成的内容来输入文本，所以它对于非屏幕媒体设备来说是不存在的，只是进一步隔离了可能混淆或负面影响语音、盲文、印刷、搜索引擎等的内容。</p><p id="aeec" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">让白天和黑夜的过渡看起来更好的最后一个调整:</p><pre class="mm mn mo mp gt mq li mr ms aw mt bi"><span id="4cdb" class="mu lk it li b gy mv mw l mx my">*,<br/>*:after,<br/>*:before {<br/>  transition:all 0.3s;<br/>}</span></pre><p id="4766" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">它也使用“全部”选择器。哦好吧。我发现一个小的——也是违反直觉的——怪癖是“*”并不针对生成的内容。哪一个…不是“全部”是吗？因此有了:after和:before。请注意，由于嵌套问题，Blink<em class="ld">(chrome-like)</em>中的一些元素会以奇怪的级联方式过渡。仍然比两个极端之间的刺目的“闪光”更好看。</p><p id="c23c" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这是我们90%以上的功能，只剩下…</p><h1 id="f965" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">JavaScript</h1><p id="1f1b" class="pw-post-body-paragraph kf kg it kh b ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky ml la lb lc im bi translated">在脚本方面，我们需要做的就是存储输入的状态。这就是为什么我在<code class="fe lf lg lh li b">INPUT</code>中添加了“rememberState”类，因为它让我们可以轻松地在页面上挂接任何这样的元素。我们所要做的就是用querySelectorAll获取所有这样的输入，遍历它们以添加一个onchange事件侦听器来存储更改时的状态，并检查状态是否已存储。</p><pre class="mm mn mo mp gt mq li mr ms aw mt bi"><span id="f0b5" class="mu lk it li b gy mv mw l mx my">(function() {</span><span id="1bd2" class="mu lk it li b gy mz mw l mx my">  for (var input of document.querySelectorAll("input.rememberState")) {<br/>    input.addEventListener("change", inputRemember, false);<br/>    if (input.id) input.checked = localStorage.getItem(<br/>      "remember_" + input.id<br/>    ) ? "selected" : "";<br/>  }<br/>  <br/>  function inputRemember(e) { <br/>    localStorage.setItem("remember_" + e.currentTarget.id, (<br/>      e.currentTarget.checked ? "selected" : ""<br/>    ));<br/>  } // inputRemember<br/>  <br/>})();</span></pre><p id="5b16" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我选择“本地存储”而不是cookies，因为它不会增加文件传输的开销。如果需要，您可以使用cookie，然后让您的服务器端代码检测cookie是否已设置，如果是，则提供已经选中的复选框。这将删除代码的<code class="fe lf lg lh li b">if (input.id)</code>部分。尽管如此，这是一个不错的解决方案。</p><p id="cc0b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">…因为我们按标签定位，所以此代码可以自动用于记住任何带有“rememberState”的复选框或单选按钮，而不仅仅是此代码库中的那个。</p><p id="c802" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我把它放在一个隔离作用域的生命中，因为模块是“危险的”,并且不在脚本中应该声明它的地方提供隔离。我不喜欢违反关注点分离的事情。</p><h1 id="74a3" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">Internet Explorer怎么样？</h1><p id="bf3b" class="pw-post-body-paragraph kf kg it kh b ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky ml la lb lc im bi translated">什么？！？哦，那个。😫</p><p id="93e9" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我最近转换到让网页“优雅地降级”到IE浏览器，只是简单地阻止了我在该浏览器中的所有CSS和脚本。他们得到的是没有样式的普通语义标记。我再也无法证明竭尽全力让已经过时十年的浏览器“正常运行”是有道理的。如果我们使用正确的语义，对于屏幕阅读器、盲文阅读器和搜索引擎来说足够好的东西对于没有人应该再使用的浏览器来说也足够好<em class="ld"/><strong class="kh iu"/>！</p><p id="277c" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">可爱的把戏？X-UA。将其设置为IE9，条件注释又神奇地起作用了。</p><pre class="mm mn mo mp gt mq li mr ms aw mt bi"><span id="7360" class="mu lk it li b gy mv mw l mx my">&lt;!-- don't even bother sending CSS to legacy IE --&gt;<br/>&lt;meta<br/> http-equiv="X-UA-Compatible"<br/> content="IE=9"<br/>&gt;<br/>&lt;!--[if !IE]&gt;--&gt;<br/> &lt;link<br/>  rel="stylesheet"<br/>  href="screen.css"<br/>  media="screen,projection,tv"<br/> &gt;<br/> &lt;link<br/>  rel="stylesheet"<br/>  href="print.css"<br/>  media="print"<br/> &gt;<br/>&lt;!--&lt;![endif]--&gt;</span></pre><p id="573f" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">嘣，你不再向IE的任何版本发送你的样式表了。我还建议加一条警告信息。</p><pre class="mm mn mo mp gt mq li mr ms aw mt bi"><span id="13c7" class="mu lk it li b gy mv mw l mx my">&lt;!--[if IE]&gt;<br/>  &lt;h2 style="color:red; display:block;" hidden aria-hidden="true"&gt;<br/>    Error, Outdated Browser Detected<br/>  &lt;/h2&gt;<br/>  &lt;p&gt;<br/>    &lt;strong style="color:red; display:block;" hidden aria-hidden="true"&gt;<br/>      You are recieving a vanilla version of this page because your browser is a decade or more out of date. For full / proper appearance, please revisit in a modern browser.<br/>    &lt;/strong&gt;<br/>  &lt;/p&gt;<br/>&lt;![endif]--&gt;</span></pre><p id="47d1" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">通知IE用户正在发生的事情。在一个评论中，由于有了<code class="fe lf lg lh li b">display:block;</code>，非可视UA将忽略这个消息(对IE中的JAWS用户来说很好),同时仍然显示在屏幕上</p><p id="f97e" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">知道我是怎么说的吗，99%以上的时候你看到的<code class="fe lf lg lh li b">style=”something”</code>都是垃圾代码？向那1%问好。</p><p id="0b36" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">对我们的JavaScript也可以这样做。</p><pre class="mm mn mo mp gt mq li mr ms aw mt bi"><span id="4fea" class="mu lk it li b gy mv mw l mx my">&lt;!--[if !IE]&gt;--&gt;<br/>  &lt;script src="nightAndDay.js"&gt;&lt;/script&gt;<br/>&lt;!--&lt;![endif]--&gt;</span></pre><p id="ee7a" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">标记中有额外的代码很糟糕，但总的来说还不到1k，所以有什么坏处呢？只是不要做得太过火。</p><h1 id="6d2b" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">所以让我们来看看它的行动吧！</h1><p id="317d" class="pw-post-body-paragraph kf kg it kh b ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky ml la lb lc im bi translated">我把我的模态对话框驱动的网站演示，并把它变成了这个演示。你可以在这里看到现场直播:</p><div class="nl nm gp gr nn no"><a href="https://cutcodedown.com/for_others/medium_articles/nightAndDay/nightAndDay.html" rel="noopener  ugc nofollow" target="_blank"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd iu gy z fp nt fr fs nu fu fw is bi translated">日日夜夜</h2><div class="nv l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">cutcodedown.com</p></div></div></div></a></div><p id="4245" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">您可以通过点击主菜单右上角的“白天模式”或“夜晚模式”在两种模式之间切换。一定要检查一下子菜单、搜索和登录的虚拟模态对话框，它们也有自己的颜色设置……就像小屏幕菜单的“汉堡包”版本一样。</p><p id="44fb" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">和我所有的例子一样，这个目录:<br/><a class="ae le" href="https://cutcodedown.com/for_others/medium_articles/nightAndDay/nightAndDay.html" rel="noopener ugc nofollow" target="_blank">https://cut code down . com/for _ others/medium _ articles/night and day/</a><br/>是完全开放的，可以很容易地访问到这些有趣的内容。</p><p id="58ac" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我还为你们<a class="ae le" href="https://cutcodedown.com/for_others/medium_articles/nightAndDay/nightAndDay.rar" rel="noopener ugc nofollow" target="_blank">放了一个整个项目</a>的. rar文件，还有一个<a class="ae le" href="https://cutcodedown.com/for_others/medium_articles/nightAndDay/nightAndDay.html.txt" rel="noopener ugc nofollow" target="_blank">。对于那些害怕“查看源代码”的人来说。</a></p><p id="0a8f" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我将<a class="ae le" href="https://cutcodedown.com/for_others/medium_articles/nightAndDay/nightAndDay.vars.screen.css" rel="noopener ugc nofollow" target="_blank">变量CSS </a>与<a class="ae le" href="https://cutcodedown.com/for_others/medium_articles/nightAndDay/nightAndDay.layout.screen.css" rel="noopener ugc nofollow" target="_blank">布局样式表</a>分开，这样你们更容易理解。在实际部署中，我会将这些合并到一个文件中，以节省一次握手，降低传输开销，而无需使用HTTP2“推送”。</p><h1 id="9dae" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">利弊</h1><p id="bb0a" class="pw-post-body-paragraph kf kg it kh b ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky ml la lb lc im bi translated">按照传统，我将首先讨论这种方法的问题。</p><h2 id="3b91" class="mu lk it bd ll na nb dn lp nc nd dp lt kq ne nf lx ku ng nh mb ky ni nj mf nk bi translated">不足之处</h2><ol class=""><li id="70fc" class="nw nx it kh b ki mh km mi kq ny ku nz ky oa lc ob oc od oe bi translated">在任何版本的IE都不行。相应地计划。有一个不使用CSS变量的变体，可以在IE9/更高版本中使用，但它涉及到为每个有颜色的元素做复杂的“通用兄弟”声明。实施起来很麻烦。</li><li id="6eb3" class="nw nx it kh b ki of km og kq oh ku oi ky oj lc ob oc od oe bi translated">当设置了黑暗模式的localstorage值时，在缓存清空加载时，灯光主题会有短暂的闪烁，因为脚本偶尔会在FCP之后加载/运行——“第一次上下文绘制”。如果这对您来说是一个担忧或问题，我建议使用cookie而不是localstorage，这样服务器可以提前将<code class="fe lf lg lh li b">INPUT</code>设置为“checked”。</li><li id="96b4" class="nw nx it kh b ki of km og kq oh ku oi ky oj lc ob oc od oe bi translated">你不能设计真正的页面<code class="fe lf lg lh li b">BODY</code>，取而代之的是必须依赖一个“人造体”<code class="fe lf lg lh li b">DIV</code>元素。这意味着一些试图跟踪窗口滚动的现成脚本不起作用，必须重写来跟踪<code class="fe lf lg lh li b">#fauxBody</code>的滚动位置。</li><li id="af7c" class="nw nx it kh b ki of km og kq oh ku oi ky oj lc ob oc od oe bi translated">标记中额外的DIV和代码，尤其是在添加IE回退时，会给DOM和带宽增加一些不必要的开销。实际超额加价仍低于1000英镑，这些担忧很容易被忽视。特别是如果您首先利用语义标记、选择器和组合子来保持HTML的小。</li></ol><h2 id="fe83" class="mu lk it bd ll na nb dn lp nc nd dp lt kq ne nf lx ku ng nh mb ky ni nj mf nk bi translated">优势</h2><ol class=""><li id="98f2" class="nw nx it kh b ki mh km mi kq ny ku nz ky oa lc ob oc od oe bi translated">CSS完成了几乎所有的工作，使得过渡和加载更加平滑，并且更容易改变颜色。</li><li id="ab4f" class="nw nx it kh b ki of km og kq oh ku oi ky oj lc ob oc od oe bi translated">这个只有431字节的脚本几乎没有增加额外的开销，并且可以重复用于您希望它记住的其他复选框或单选按钮。它还可以很容易地扩展，以记住其他表单元素的实际值。</li><li id="dcd1" class="nw nx it kh b ki of km og kq oh ku oi ky oj lc ob oc od oe bi translated">因为它将一个<code class="fe lf lg lh li b">#fauxBody</code>作为我们<code class="fe lf lg lh li b">INPUT</code>的兄弟，所以它与<code class="fe lf lg lh li b">:target</code>驱动的模态对话框兼容。</li><li id="b8b8" class="nw nx it kh b ki of km og kq oh ku oi ky oj lc ob oc od oe bi translated">通过使用<code class="fe lf lg lh li b">hidden</code>属性和<code class="fe lf lg lh li b">aria-hidden="true"</code>，我们能够使我们的控制元素对非视觉和/或非屏幕媒体用户界面的导航或页面阅读没有任何影响。它们对那些设备和用户来说根本不存在，因为它们实际上是不相关的。</li><li id="4615" class="nw nx it kh b ki of km og kq oh ku oi ky oj lc ob oc od oe bi translated">由于<code class="fe lf lg lh li b">label</code>内部的状态可以像我们的变量一样被控制，我们可以在上面设置任何种类或样式的生成内容。这可能是一个“太阳”和“月亮”的图形，动画，或者任何你能用CSS做的事情。</li><li id="676d" class="nw nx it kh b ki of km og kq oh ku oi ky oj lc ob oc od oe bi translated">因为使用<code class="fe lf lg lh li b">FOR</code>属性指向我们的<code class="fe lf lg lh li b">INPUT</code>的任何<strong class="kh iu"/><code class="fe lf lg lh li b">LABEL</code>都可以用来切换它，所以您实际上可以将标签放在您想要的代码中的任何地方。在菜单中，分开在页眉、页脚、内容中间。你甚至可以实现多个触发器元素！</li></ol><h1 id="bdb8" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">更多可能性</h1><p id="aab0" class="pw-post-body-paragraph kf kg it kh b ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky ml la lb lc im bi translated">使用复选框或单选按钮<code class="fe lf lg lh li b">INPUT</code>来控制布局不仅可以用于颜色。你可以让用户选择一个字体集，改变填充甚至布局，等等。越想越觉得它是一种极其强大和有用的技术。</p><p id="b309" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">所有这一切都不会损害可访问性或可用性，也不必编写千字节(甚至兆字节)的无意义的JavaScript，这些JavaScript通常与这种功能相关联。</p><h1 id="3bb0" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">结论</h1><p id="d8d4" class="pw-post-body-paragraph kf kg it kh b ki mh kk kl km mi ko kp kq mj ks kt ku mk kw kx ky ml la lb lc im bi translated">随着CSS的不断改进和强大，许多人们倾向于使用JavaScript作为终极解决方案的事情越来越与JavaScript无关。对于大多数视觉和布局效果来说，JS最好应该作为一种增强和权宜之计，用于CSS本身不能做的事情，而不是每一点功能的首选工具。</p><p id="3d46" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这进一步增强了我们保持关注点分离的能力，特别是内容(HTML)、表示(CSS)和行为(JS)。许多人会认为这是一种行为，但他说“行为”是一个风格控制的问题，在理想世界中，风格和布局与JavaScript无关。太多时候，人们沉迷于JavaScript而没有考虑“如果脚本被阻止，或者与UA无关，会发生什么？”。</p><p id="5d17" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">同样，许多人应用他们的类、id和CSS，丝毫不关心非屏幕媒体用户。有一些技术——比如这个——可以给你所有视觉上的视觉控制，而不牺牲那些坐在那里使用屏幕媒体设备的人的可访问性需求。</p><p id="698d" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这种技术功能强大，相对容易实现，最终给CSS变量提供了有用的东西。</p></div></div>    
</body>
</html>