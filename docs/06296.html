<html>
<head>
<title>VueJS, the Composition API &amp; Firebase Authentication</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">VueJS，组合API &amp; Firebase认证</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/vuejs-the-composition-api-firebase-authentication-a5b9f5823e31?source=collection_archive---------6-----------------------#2020-11-12">https://levelup.gitconnected.com/vuejs-the-composition-api-firebase-authentication-a5b9f5823e31?source=collection_archive---------6-----------------------#2020-11-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/4cac64cce48db82e1ed5c7cb93fae99e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*a2hy_4Zm0bjKsEzE"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@christianw?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">克里斯蒂安·威迪格</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="e90f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">作为web应用程序的创建者，您可能最终需要某种形式的身份验证。</p><p id="4480" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">开发一个成熟的认证系统，包括电子邮件验证和忘记密码系统，很难做好，更难证明其安全性。</p><p id="ba71" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一种选择是选择“现成的”身份提供商，虽然他们可以提供您开箱所需的一切，但很快就会变得昂贵，因此对于较小的项目来说不可行。</p><p id="9588" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">谷歌的Firebase认证是一个例外。</p><p id="b315" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae kc" href="https://firebase.google.com/products/auth" rel="noopener ugc nofollow" target="_blank"> Firebase Auth </a>允许你连接到社交提供商以及电子邮件/密码验证，并且默认带有电子邮件验证和忘记密码流。不仅如此，它还可以免费使用！(当然在一定程度上)。</p><p id="a8c9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我应该指出，其他身份提供商，如Auth0和Okta，提供免费的定价。然而，我发现Firebase身份验证要快得多，也更容易上手。更不用说它与Firestore DB的集成有多好，允许我利用一个提供商进行身份验证和数据库，而且全部免费！</p><p id="52f9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以没有任何进一步的序言。让我们看看如何将它与VueJS集成在一起。</p><p id="ef51" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将使用Vue3、复合API和Vue路由器，所以我假设你知道它们，并且已经有一个从Vue CLI搭建的应用程序。</p><p id="fa06" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你不熟悉组合API，请随意阅读我的文章。</p><h1 id="7e29" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">添加Firebase SDK</h1><p id="2c9d" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">从一个简单的开始…</p><p id="7fc5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">yarn add firebase</code></p><p id="2983" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，在<code class="fe me mf mg mh b">src/components</code>中新建一个名为“auth”的文件夹。在这里，我们将存储所有与身份验证相关的文件和组件。</p><h1 id="a121" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">初始化组合API数据</h1><p id="1f87" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在新的“auth”文件夹的根目录下创建<code class="fe me mf mg mh b">index.js</code>:</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="1d87" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们首先从<code class="fe me mf mg mh b">firebase/app</code>和<code class="fe me mf mg mh b">firebase/auth</code>进口火碱。我们可以只调用<code class="fe me mf mg mh b">import firebase from "firebase"</code>，但是，这会导致导入整个<em class="mo">firebase SDK。更好的方法是捆绑size来导入核心(从“firebase/auth”)然后通过导入单独的模块添加到firebase“名称空间”中。</em></p><p id="77dd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们分配firebase配置(这里是从环境变量)。值得注意的是，firebase配置不是一个“秘密”。任何访问该网站的人都可以找到您的配置信息。也就是说，为了多种环境(本地、生产等),保留环境变量仍然是值得的。).</p><p id="4b33" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们创建一个用户ref，在这里我们将存储我们登录的用户，并为<code class="fe me mf mg mh b">onAuthStateChanged</code>设置一个监听器，以便当有人登录或退出时，我们可以将它分配给用户ref。</p><h1 id="d625" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">与Vue组件集成</h1><p id="7cd9" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">有了所有的功能，我们现在需要组件来使用它们。</p><h2 id="20e1" class="mp lc iq bd ld mq mr dn lh ms mt dp ll ko mu mv lp ks mw mx lt kw my mz lx na bi translated">注册组件</h2><p id="da75" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">将以下内容添加到合成API文件中:</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="802e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个函数初始化数据，我们需要一个注册表格(电子邮件和密码)和一个功能，我们可以在提交时执行。所有这些都封装在一个<code class="fe me mf mg mh b">useSignup</code>函数中，这样数据在每次使用时都会被初始化。这防止了使用在应用程序的整个生命周期中不必要地初始化的“全局”状态。</p><p id="0633" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们将创建注册组件:</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="4f5d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里，我们设置了一个基本表单，其中有几个电子邮件和密码输入。</p><p id="f5e4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于组合API的强大，我们可以直接从<code class="fe me mf mg mh b">useSignup</code>调用中传递引用值，以及注册方法本身。这将组件本身的功能保持在最低限度，组件只负责处理注册后重定向。</p><p id="0a7e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还从复合文件中返回“google”函数，允许一个按钮启动弹出认证流。</p><h2 id="8c49" class="mp lc iq bd ld mq mr dn lh ms mt dp ll ko mu mv lp ks mw mx lt kw my mz lx na bi translated">登录组件</h2><p id="0168" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">接下来，是登录组件的时候了。</p><p id="5dc6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将以下内容添加到合成API文件中:</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="bd4b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用与注册相同的方式设置登录功能:表单的数据引用和通过该数据登录的功能。</p><p id="fba7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们创建组件本身:</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="af73" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意这个组件和注册组件是多么的相似。我们导入所有需要的内容，并将<code class="fe me mf mg mh b">useLogin</code>的元素传递到模板中，以便在组件上使用。</p><h1 id="be37" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">保护应用程序</h1><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nb"><img src="../Images/73ba9652d73e930f29f0ec3c5ec66bda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8rmwQWV0I17vgfDK"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@nihal_1312?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">尼哈尔·沙阿</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="1fc1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们需要确保任何受保护的路由在未登录时都是不可访问的。</p><p id="4f80" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设路由文件类似于:</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="46ce" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们需要的是一个每当我们开始导航到一条路线时执行的功能，检查用户，然后根据需要指引他们。</p><p id="d6ee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为此，我们使用“beforeEach”路由保护:</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="9e67" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">简单地说，这个函数检查用户引用是否有值，如果没有，就引导用户登录。</p><p id="2f86" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意到瑕疵了吗？我们将进入一个无限循环，不断尝试登录路径！为了避免这种情况，我们可以使用路由元数据来避免“公共”路由。</p><p id="6ba5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为此，请按如下方式更改路由器文件:</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="e0fe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">关于如何工作的更多信息，请查看<a class="ae kc" href="https://router.vuejs.org/guide/advanced/meta.html" rel="noopener ugc nofollow" target="_blank"> Vue路由器</a>文档。你会注意到他们颠倒了逻辑，使用<code class="fe me mf mg mh b">requiresAuth</code>而不是<code class="fe me mf mg mh b">public</code>。然而，我更喜欢默认锁定路线，并打开我想要的路线。</p><p id="44f2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">向右排序？不对！我们还有最后一个问题:在身份验证初始化之前导航到路由。</p><p id="1de8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们第一次点击一条路线，<code class="fe me mf mg mh b">user.value</code>将<em class="mo">总是</em>为空，因为Firebase还没有机会完全初始化。这意味着用户将总是被重定向登录，即使他们已经过完全身份验证。</p><p id="1635" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了解决这个问题，我们必须等待Firebase API初始化。</p><p id="4c26" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们通过两次编辑来实现这一点，一次是对身份验证组合API文件的编辑，另一次是对route guard的编辑。</p><p id="3d90" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我们更新合成API文件:</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="c1e4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们导出一个名为<code class="fe me mf mg mh b">initialised</code>的新引用，它最初被设置为false。然后，当我们得到一个auth状态更改时，我们将其设置为true。一旦API被初始化，Firebase总是会触发一个<code class="fe me mf mg mh b">onAuthStateChanged</code>事件。如果用户未经身份验证，则使用一个<code class="fe me mf mg mh b">null</code>参数，如果用户经过身份验证，则使用一个用户对象。</p><p id="45c9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们需要在route guard中监视这个值:</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="a07f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这看起来有点复杂，但是它做的很简单。</p><p id="52d4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，它检查验证是否已经初始化。如果是，那么我们继续进行其余的身份验证检查。</p><p id="8c26" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果不是…我们在初始化时设置一个监视器，等待它变成真的。一旦它是，我们继续像以前一样。</p><h1 id="2334" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">最后</h1><p id="421a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">因此，在这一切之后，我们有了一个有效的认证流程，由Google免费处理。我们有公开可访问的路由，可以防止用户访问应用程序，直到认证服务初始化。</p><p id="66e9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">值得注意的是，有很多东西我还没有涉及到；例如错误处理(用户存在，密码不匹配的复杂性等。)、加载栏和一般UX改进，您应该100%地为全功能身份验证流程实现这些功能。但这能让你继续前进。</p><p id="00dd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您还可以在<a class="ae kc" href="https://github.com/mlawd/blog-demos/tree/main/vuejs-firebase" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>中查看完整的工作源代码。</p></div></div>    
</body>
</html>