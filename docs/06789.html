<html>
<head>
<title>Rethinking Structured Programming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">重新思考结构化编程</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/rethinking-structured-programming-7c0ae2f73b90?source=collection_archive---------7-----------------------#2020-12-31">https://levelup.gitconnected.com/rethinking-structured-programming-7c0ae2f73b90?source=collection_archive---------7-----------------------#2020-12-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4939" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">编程的演变</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0080148c8e99d814feeabb8bc4630317.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1rXVXiSbVNSKjmq3u_FRkA.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图片来自<a class="ae ky" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=692959" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae ky" href="https://pixabay.com/users/jstarj-884623/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=692959" rel="noopener ugc nofollow" target="_blank">强尼·香农</a></figcaption></figure><p id="4cbf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我最近的文章中，<a class="ae ky" href="https://medium.com/swlh/all-loops-are-a-code-smell-6416ac4865d6" rel="noopener">所有的循环都是一种代码味道</a>，我断言循环的正常形式，<code class="fe lv lw lx ly b">for</code>，<code class="fe lv lw lx ly b">while</code>等等，是应该避免的低级编码构造。虽然对这篇文章的总体反应是好的，但也有一些明显不买账的人大声反对。所以我想我应该多花点时间复习一下我的推理。</p><p id="fe54" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我从结构化编程的概念开始。关于结构化编程的早期想法始于20世纪50年代末。<a class="ae ky" href="https://en.wikipedia.org/wiki/Edsger_W._Dijkstra" rel="noopener ugc nofollow" target="_blank"> Edsger W. Dijkstra </a>在1968年写了一封公开信“<a class="ae ky" href="https://en.wikipedia.org/wiki/Go_To_Statement_Considered_Harmful" rel="noopener ugc nofollow" target="_blank">转到被认为有害的语句</a>”，在信中他恳求程序员放弃<code class="fe lv lw lx ly b">goto</code>语句，转而支持更加可控的应用程序路由，例如<code class="fe lv lw lx ly b">if</code>和<code class="fe lv lw lx ly b">while</code>语句以及独立的子例程。Donald Knuth在1974年写了一篇反驳文章《使用go to语句的结构化编程》。但它主要是关于优化每个CPU周期和保持“可证明性”，高级程序员应该推迟优化，直到显示需要。当然,<code class="fe lv lw lx ly b">goto</code>语句今天仍然作为编码出口存在，但是通常被认为是一种代码味道。</p><p id="7f10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我在1989年第一次开始专业编程时(我记得是因为那年我儿子出生了)，仍然有人认为<code class="fe lv lw lx ly b">goto</code>是一种合适的编码形式。结构化编程的早期采用者P. J. Plauger说:</p><blockquote class="lz ma mb"><p id="dce6" class="kz la mc lb b lc ld ju le lf lg jx lh md lj lk ll me ln lo lp mf lr ls lt lu im bi translated"><em class="it">我们这些皈依者在顽固不化的汇编语言程序员的眼皮底下挥舞着这条有趣的新闻，这些程序员不停地炫耀扭曲的逻辑，并说，“我打赌你不能构建这个。”无论是bhm和Jacopini的证明，还是我们在编写结构化代码方面的多次成功，都没有比他们准备好说服自己的时间早一天让他们改变主意。</em></p></blockquote><p id="2a35" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因此，我一直在思考结构化编程的概念，以及哪些部分现在可能被认为是可以隐藏在某个库中的低级抽象。goto语句从未消失，它仍然在机器代码级别使用。但是我们大多数人都没有达到那个水平。也许高阶函数可以使结构化编程的一些构造像goto语句一样不必要，只在极少数情况下使用。</p><p id="1df0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">子例程，今天也称为方法和函数，仍然是日常编程的一部分，并且很可能仍然是应用程序分解的基石。事实上，有人可能会说它们是函数式编程不可或缺的一部分。</p><p id="38ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">if</code>语句更复杂，但是仍然有很多情况下我们可以去掉它。以Java等语言中的空检查为例。可以很容易地用Java可选类型替换它:</p><pre class="kj kk kl km gt mg ly mh mi aw mj bi"><span id="1bde" class="mk ml it ly b gy mm mn l mo mp">// ancient system calls returns the evil null<br/>  String env = System.getenv("SOME_UNDEFINDED_ENV"); <br/>  if(env != null) {<br/>    env = env.toUpperCase();<br/>    System.out.println("using if env = " + env);<br/>  } else {<br/>    System.out.println("using if env = null");<br/>  }<br/>        <br/>  System.out.println("using Optional 1 env = "<br/>     + Optional.ofNullable(System.getenv("SOME_UNDEFINDED_ENV"))<br/>   .map(e -&gt; e.toUpperCase())<br/>   .orElse("null"));</span></pre><p id="d5e5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Optional是一个非常方便的对象，尽管它可能会被误用。使用<code class="fe lv lw lx ly b">map</code>高阶函数可能会让一些人感到困惑。考虑可选的方式是作为0或1个对象的列表。在许多函数式语言中，它有几乎和列表一样的方法集。我们可以通过将Java的Optional转换成一个流来解决高阶方法的缺乏:</p><pre class="kj kk kl km gt mg ly mh mi aw mj bi"><span id="d161" class="mk ml it ly b gy mm mn l mo mp">Optional.ofNullable(System.getenv("SOME_UNDEFINDED_ENV"))<br/>                .stream()<br/>                .map(e -&gt; e.toUpperCase())<br/>                .forEach(e -&gt; System.out.println("env = " + e));</span></pre><p id="bd85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是如果你这样做了，如果选项是空的，你就失去了做不同事情的能力。</p><p id="89d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在Java中，你可以使用<a class="ae ky" href="https://projectreactor.io/" rel="noopener ugc nofollow" target="_blank"> projectreactor.io </a>提供的Mono类型。单声道类型是可选的，但是有非常丰富的方法:</p><pre class="kj kk kl km gt mg ly mh mi aw mj bi"><span id="b091" class="mk ml it ly b gy mm mn l mo mp">Mono.justOrEmpty(System.getenv("SOME_UNDEFINDED_ENV"))<br/>  .map(e -&gt; e.toUpperCase())<br/>  .defaultIfEmpty("null")<br/>  .subscribe(e -&gt; System.out.println("using Mono env = " + e));</span></pre><p id="9317" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有关projectreactor.io的更多信息，请参见我的文章<a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/non-blocking-java-beyond-the-hype-dfdc405848d7">非阻塞Java——超越宣传</a>。</p><p id="b01e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe lv lw lx ly b">null</code>检查是一个特例，因为它可能经常发生，如果错过，可能会导致可怕的空指针异常。但是其他形式的<code class="fe lv lw lx ly b">if</code>语句就不那么容易捕捉了。</p><p id="244d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">loop语句的一种形式是输出为输入的循环，这种形式的循环不会被引入到高阶函数中。以计算平方根的巴比伦方法为例。它接受一个种子值，然后迭代对输入的操作，直到输出与输入相同(近似)。</p><p id="e07d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为什么我如此渴望看到循环和条件句消失？首先，对于每个崇拜代码覆盖的人来说，如果没有循环或条件，那么只有一条代码路径需要覆盖。代码覆盖率已解决。第二，这是一些反对我的第一篇文章的人提出的，我们所做的就是把循环推到一个库中。没错。为什么要写那些在库中为你编写的代码，并且希望有合适的测试覆盖率。我最喜欢的一句话是“如果你95%的代码在某个库中，而那个库有100%的代码覆盖率，那么你的应用程序有95%的代码覆盖率。”只要确保当你使用一个库时，它有足够的代码覆盖率。这是我几乎不再浪费时间为我的应用程序代码编写单元测试的原因之一。但那是另一篇文章了。</p><p id="1f89" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">提及的文章:</p><div class="mq mr gp gr ms mt"><a href="https://medium.com/swlh/all-loops-are-a-code-smell-6416ac4865d6" rel="noopener follow" target="_blank"><div class="mu ab fo"><div class="mv ab mw cl cj mx"><h2 class="bd iu gy z fp my fr fs mz fu fw is bi translated">所有的循环都是代码味道</h2><div class="na l"><h3 class="bd b gy z fp my fr fs mz fu fw dk translated">for、while及其同类之死。</h3></div><div class="nb l"><p class="bd b dl z fp my fr fs mz fu fw dk translated">medium.com</p></div></div><div class="nc l"><div class="nd l ne nf ng nc nh ks mt"/></div></div></a></div><div class="mq mr gp gr ms mt"><a href="https://medium.com/better-programming/functional-programming-from-an-object-oriented-perspective-9b47100b488a" rel="noopener follow" target="_blank"><div class="mu ab fo"><div class="mv ab mw cl cj mx"><h2 class="bd iu gy z fp my fr fs mz fu fw is bi translated">从面向对象的角度看函数式编程</h2><div class="na l"><h3 class="bd b gy z fp my fr fs mz fu fw dk translated">为什么我正在慢慢抛弃面向对象的过去</h3></div><div class="nb l"><p class="bd b dl z fp my fr fs mz fu fw dk translated">medium.com</p></div></div><div class="nc l"><div class="ni l ne nf ng nc nh ks mt"/></div></div></a></div><div class="mq mr gp gr ms mt"><a rel="noopener  ugc nofollow" target="_blank" href="/non-blocking-java-beyond-the-hype-dfdc405848d7"><div class="mu ab fo"><div class="mv ab mw cl cj mx"><h2 class="bd iu gy z fp my fr fs mz fu fw is bi translated">非阻塞Java——超越宣传</h2><div class="na l"><h3 class="bd b gy z fp my fr fs mz fu fw dk translated">集装箱化世界中阻塞与非阻塞的比较</h3></div><div class="nb l"><p class="bd b dl z fp my fr fs mz fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="nc l"><div class="nj l ne nf ng nc nh ks mt"/></div></div></a></div></div></div>    
</body>
</html>