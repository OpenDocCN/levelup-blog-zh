<html>
<head>
<title>Help Popup with Angular Material CDK Overlay</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">帮助弹出有角度的材料CDK覆盖</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/help-popup-with-angular-material-cdk-overlay-babc2ab127a?source=collection_archive---------2-----------------------#2020-09-02">https://levelup.gitconnected.com/help-popup-with-angular-material-cdk-overlay-babc2ab127a?source=collection_archive---------2-----------------------#2020-09-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/a6468dd4d3c6be96d79e95291ba72b27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7IpvXRXAIgwg_DE7ruOM0g.jpeg"/></div></div></figure><p id="d052" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">像Material Design这样的设计语言为开发人员提供了构建模块，帮助我们创建好看且直观的设计。您可以找到任何类型的组件，从简单的按钮和卡片到日期选择器和复杂的数据表。它涵盖了一个开发人员的大部分需求，但是我最近面对一个UX需求，我找不到任何合适的组件，即使有一点定制。</p><p id="71b5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当用户点击“信息”图标时，我想在卡片上显示一些额外的信息:</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi kz"><img src="../Images/d45707b5947deddd4d32b44fd5dd6940.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-z5hkQN5uoSBIkQg7AKDsw.png"/></div></div></figure><p id="82d5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果用户在其外部单击，该面板应该关闭，并保持相对于其标签的位置，即使用户向下滚动。我们还希望能够在弹出窗口中嵌入组件，而不仅仅是显示文本。一个解决方案可以使用CDK的<code class="fe le lf lg lh b">overlay</code>包来构建。</p><p id="4d55" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你只需要最终的解决方案，你可以检查这个<a class="ae li" href="https://github.com/Dornhoth/info-popup.git" rel="noopener ugc nofollow" target="_blank">回购</a>。在本文中，我们将深入探讨实现的要点。</p><h1 id="e7d5" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">设置</h1><p id="c2cf" class="pw-post-body-paragraph kb kc it kd b ke mh kg kh ki mi kk kl km mj ko kp kq mk ks kt ku ml kw kx ky im bi translated">如果您已经在项目中使用了角度材质，则可以跳过这一部分。如果没有，您有两个选择:</p><ul class=""><li id="75ef" class="mm mn it kd b ke kf ki kj km mo kq mp ku mq ky mr ms mt mu bi translated">仅安装和设置角形材料CDK</li><li id="7832" class="mm mn it kd b ke mv ki mw km mx kq my ku mz ky mr ms mt mu bi translated">安装和设置角形材料(推荐我们的例子)</li></ul><h2 id="293c" class="na lk it bd ll nb nc dn lp nd ne dp lt km nf ng lx kq nh ni mb ku nj nk mf nl bi translated">安装和设置角材料CDK</h2><p id="9151" class="pw-post-body-paragraph kb kc it kd b ke mh kg kh ki mi kk kl km mj ko kp kq mk ks kt ku ml kw kx ky im bi translated">使用<code class="fe le lf lg lh b">overlay</code>包不必安装完整的Angular Material包。然而，对于这个例子的信息弹出窗口，我们需要来自角状材料的<code class="fe le lf lg lh b">MatIcon</code>和<code class="fe le lf lg lh b">MatCard</code>组件。但是从技术上讲，您可以用另一个图标和自制的卡分别替换这些组件，这样您就可以自行安装CDK了:</p><pre class="la lb lc ld gt nm lh nn no aw np bi"><span id="7bca" class="na lk it lh b gy nq nr l ns nt">npm i @angular/cdk --save</span></pre><p id="32a2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">并在全局样式中导入以下代码行:</p><pre class="la lb lc ld gt nm lh nn no aw np bi"><span id="2b60" class="na lk it lh b gy nq nr l ns nt">@import '~@angular/cdk/overlay-prebuilt.css';</span></pre><h2 id="8e67" class="na lk it bd ll nb nc dn lp nd ne dp lt km nf ng lx kq nh ni mb ku nj nk mf nl bi translated">安装和设置角形材料</h2><p id="9033" class="pw-post-body-paragraph kb kc it kd b ke mh kg kh ki mi kk kl km mj ko kp kq mk ks kt ku ml kw kx ky im bi translated">因为我们将在示例中使用<code class="fe le lf lg lh b">MatCard</code>和<code class="fe le lf lg lh b">MatIcon</code>，如果你想跟着编码，这是推荐的选项。您可以在这里找到完整的指南<a class="ae li" href="https://material.angular.io/guide/getting-started" rel="noopener ugc nofollow" target="_blank">，但是要快速设置，只需运行:</a></p><pre class="la lb lc ld gt nm lh nn no aw np bi"><span id="856d" class="na lk it lh b gy nq nr l ns nt">ng add @angular/material</span></pre><p id="84c5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">并确保<code class="fe le lf lg lh b">BrowserAnimationsModule</code>被导入到您的<code class="fe le lf lg lh b">app.module.ts</code>中。</p><p id="1662" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="nu">注意:如前所述，我们将需要</em> <code class="fe le lf lg lh b"><em class="nu">MatCardModule</em></code> <em class="nu">和</em> <code class="fe le lf lg lh b"><em class="nu">MatIconModule</em></code> <em class="nu">。由于你在你的</em> <code class="fe le lf lg lh b"><em class="nu">app.module.ts</em></code> <em class="nu">中，你现在已经可以导入它们了。</em></p><h1 id="3866" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">指示的</h1><p id="db85" class="pw-post-body-paragraph kb kc it kd b ke mh kg kh ki mi kk kl km mj ko kp kq mk ks kt ku ml kw kx ky im bi translated">我们首先创建一个指令:</p><figure class="la lb lc ld gt ju"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="35be" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们希望能够轻松地将此弹出窗口添加到任何标签/按钮组合中。这里有不同的策略使其可重用和可配置。我们可以在标签上使用一个结构指令来自动添加图标，但是这将使得按钮的选择及其位置更难配置。我们决定手动添加按钮，并在按钮上设置弹出窗口的行为。</p><figure class="la lb lc ld gt ju"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="5d73" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe le lf lg lh b">app-info-button</code>组件是一个简单的图标按钮:</p><figure class="la lb lc ld gt ju"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="ccea" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">它是有样式的，单击时会发出一个事件，但不会影响弹出窗口的行为。</p><p id="eefa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们在标签旁边添加了一个按钮，并附上了一个指令<code class="fe le lf lg lh b">appInfoPopup</code>。该指令将一个模板作为输入，该模板包含我们想要在弹出卡中显示的信息。该指令还带有一个额外的参数，<code class="fe le lf lg lh b">label</code>，这是弹出窗口将实际附加到的元素。在本文开头的例子中，您可以看到弹出窗口是相对于“某个标签”定位的，而不是图标。</p><p id="2549" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们的弹出窗口是完全可配置的:我们可以选择它链接到什么元素，完全自由地显示什么，并可以决定哪个按钮打开/关闭它。</p><h1 id="436f" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">覆盖物</h1><p id="a119" class="pw-post-body-paragraph kb kc it kd b ke mh kg kh ki mi kk kl km mj ko kp kq mk ks kt ku ml kw kx ky im bi translated">我们现在必须将逻辑添加到我们的指令中。该指令首先必须用<code class="fe le lf lg lh b">overlay.create()</code>函数创建覆盖元素。这个函数返回一个<code class="fe le lf lg lh b">OverlayRef</code>实例，我们将能够<em class="nu">附加</em>和<em class="nu">分离</em>。</p><p id="095d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以将一些选项传递给<code class="fe le lf lg lh b">create</code>函数。您可以在<a class="ae li" href="https://material.angular.io/cdk/overlay/api#OverlayConfig" rel="noopener ugc nofollow" target="_blank"> API文档</a>中找到选项的完整列表，但是对于我们的用例，我们将只使用其中的几个。</p><p id="52f3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以定义覆盖行为的两个重要部分:它是如何定位的，以及当用户滚动页面时会发生什么。</p><h2 id="dd18" class="na lk it bd ll nb nc dn lp nd ne dp lt km nf ng lx kq nh ni mb ku nj nk mf nl bi translated">位置策略</h2><p id="8ec8" class="pw-post-body-paragraph kb kc it kd b ke mh kg kh ki mi kk kl km mj ko kp kq mk ks kt ku ml kw kx ky im bi translated">有两种方法定位您的覆盖:它们可以在视窗中全局定位，或者它们可以连接到一个元素。我们希望使用第二种策略:我们的弹出窗口应该相对于<code class="fe le lf lg lh b">label</code>元素定位。</p><pre class="la lb lc ld gt nm lh nn no aw np bi"><span id="f4ad" class="na lk it lh b gy nq nr l ns nt">const positionStrategy = this.overlay<br/>  .position()<br/>  .flexibleConnectedTo(this.label);</span></pre><p id="4999" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们仍然可以指定我们想要的确切位置:顶部、左侧、右侧…但是可能并不总是有足够的位置来像我们指定的那样放置弹出窗口，这就是为什么我们可以传递一个首选位置的<em class="nu">列表</em>，从最首选位置到最不首选位置:</p><pre class="la lb lc ld gt nm lh nn no aw np bi"><span id="94b1" class="na lk it lh b gy nq nr l ns nt">const positionStrategy = this.overlay<br/>  .position()<br/>  .flexibleConnectedTo(this.label)<br/>  .withPositions([<br/>     new ConnectionPositionPair(<br/>       { originX: 'start', originY: 'bottom' },<br/>       { overlayX: 'start', overlayY: 'top' },<br/>     ),<br/>     new ConnectionPositionPair(<br/>       { originX: 'start', originY: 'top' },<br/>       { overlayX: 'start', overlayY: 'bottom' },<br/>     ),<br/>  ])<br/>  .withPush(false);</span></pre><p id="a218" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe le lf lg lh b">ConnectionPositionPair</code>的语法可能看起来有点复杂，但是让我们来解密第一个:它告诉覆盖图的哪个点和<code class="fe le lf lg lh b">origin</code>的哪个点，也就是<code class="fe le lf lg lh b">label</code>，应该是公共的。线条<code class="fe le lf lg lh b">{ originX: 'start', originY: 'bottom' }</code>表示覆盖将相对于标签的左下角定位。使用<code class="fe le lf lg lh b">{ overlayX: 'start', overlayY: 'top' }</code>线，我们更具体地说，覆盖图的左上角应该与<code class="fe le lf lg lh b">origin</code>的参考点对齐。这种配置将导致文章开头的图像中的位置。如果标签下缺少位置，我们需要一个后备。这是第二个<code class="fe le lf lg lh b">ConnectionPositionPair</code>物体。如果必须使用这个，覆盖的左下角将与标签的左上角对齐。</p><p id="7267" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您可能已经注意到了最后一个选项<code class="fe le lf lg lh b">withPush</code>。如果设置为<code class="fe le lf lg lh b">true</code>，这意味着如果没有合适的首选位置，CDK可以强制推动屏幕上的覆盖。在我们的例子中，我们可以将其设置为<code class="fe le lf lg lh b">false</code>。</p><h2 id="b4cb" class="na lk it bd ll nb nc dn lp nd ne dp lt km nf ng lx kq nh ni mb ku nj nk mf nl bi translated">滚动策略</h2><p id="0862" class="pw-post-body-paragraph kb kc it kd b ke mh kg kh ki mi kk kl km mj ko kp kq mk ks kt ku ml kw kx ky im bi translated">我们还可以定义覆盖如何与滚动交互。有四个选项:</p><ul class=""><li id="4499" class="mm mn it kd b ke kf ki kj km mo kq mp ku mq ky mr ms mt mu bi translated"><code class="fe le lf lg lh b">noop</code>:当用户滚动时什么都不会发生，覆盖图停留在原来的位置。我们不希望这样，因为标签的位置可能会受到滚动的影响，我们希望覆盖图跟随它。</li><li id="61cf" class="mm mn it kd b ke mv ki mw km mx kq my ku mz ky mr ms mt mu bi translated"><code class="fe le lf lg lh b">block</code>:完全阻止用户滚动。当您的覆盖图是屏幕中间的重要信息时，这很有用。</li><li id="b3ed" class="mm mn it kd b ke mv ki mw km mx kq my ku mz ky mr ms mt mu bi translated"><code class="fe le lf lg lh b">close</code>:我们可以让覆盖图在用户滚动时自动关闭。</li><li id="e34a" class="mm mn it kd b ke mv ki mw km mx kq my ku mz ky mr ms mt mu bi translated">这是我们想要的行为。用户可以滚动，覆盖层将相对于标签重新定位。</li></ul><pre class="la lb lc ld gt nm lh nn no aw np bi"><span id="a228" class="na lk it lh b gy nq nr l ns nt">const scrollStrategy = this.overlay.scrollStrategies.reposition();</span></pre><h2 id="364f" class="na lk it bd ll nb nc dn lp nd ne dp lt km nf ng lx kq nh ni mb ku nj nk mf nl bi translated">叠加的创建</h2><p id="e2e9" class="pw-post-body-paragraph kb kc it kd b ke mh kg kh ki mi kk kl km mj ko kp kq mk ks kt ku ml kw kx ky im bi translated">现在我们已经定义了位置和滚动策略，我们可以创建覆盖图:</p><pre class="la lb lc ld gt nm lh nn no aw np bi"><span id="2c27" class="na lk it lh b gy nq nr l ns nt">this.overlayRef = this.overlay.create({<br/>  positionStrategy,<br/>  scrollStrategy,<br/>  hasBackdrop: true,<br/>  backdropClass: 'cdk-overlay-transparent-backdrop',<br/>});</span></pre><p id="5793" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后两个选项也很重要。当<code class="fe le lf lg lh b">hasBackdrop</code>为<code class="fe le lf lg lh b">true</code>时，覆盖图有一个背景元素，它是一个渲染在覆盖图下的元素，覆盖整个视口。我们以后会明白为什么我们需要它。最后一个选项告诉背景应该是透明的，因为默认情况下，背景是透明的灰色，使背景看起来是禁用的。</p><figure class="la lb lc ld gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nx"><img src="../Images/2266555afd63241e8a2635a2dbe0ed4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3HO6Nlsy7zHpQO-0lrgq1Q.png"/></div></div></figure><h2 id="83b6" class="na lk it bd ll nb nc dn lp nd ne dp lt km nf ng lx kq nh ni mb ku nj nk mf nl bi translated">附着/分离覆盖</h2><p id="4bcc" class="pw-post-body-paragraph kb kc it kd b ke mh kg kh ki mi kk kl km mj ko kp kq mk ks kt ku ml kw kx ky im bi translated">现在叠加已创建，但还看不到任何东西。我们希望当用户单击按钮时，显示一个弹出窗口，其中包含我们指定为指令参数的内容。在<code class="fe le lf lg lh b">afterViewInit</code>生命周期钩子中，我们听点击按钮</p><pre class="la lb lc ld gt nm lh nn no aw np bi"><span id="ad39" class="na lk it lh b gy nq nr l ns nt">ngAfterViewInit(): void {          <br/>  this.infoButton.infoButtonClicked<br/>    .asObservable()<br/>    .subscribe(() =&gt; {<br/>       this.attachOverlay();<br/>    });<br/> }</span><span id="edd9" class="na lk it lh b gy ny nr l ns nt">private attachOverlay(): void {<br/>  if (!this.overlayRef.hasAttached()) {<br/>  const periodSelectorPortal = new TemplatePortal(<br/>    this.appInfoPopup,<br/>    this.vcr,<br/>  );<br/>  this.overlayRef.attach(periodSelectorPortal);<br/>}</span></pre><p id="3fc2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当用户点击按钮时，我们从信息模板创建一个门户，并将其附加到<code class="fe le lf lg lh b">overlayRef</code>。此时，弹出窗口可见。</p><p id="f173" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后，当用户点击它的外部时，我们必须让它消失。这就是我们需要背景的原因。我们可以直接听到背景点击并关闭覆盖:</p><pre class="la lb lc ld gt nm lh nn no aw np bi"><span id="e7e3" class="na lk it lh b gy nq nr l ns nt">this.overlayRef<br/>  .backdropClick()<br/>  .pipe(takeUntil(this.unsubscribe))<br/>  .subscribe(() =&gt; {<br/>    this.detachOverlay();<br/>  });</span><span id="1656" class="na lk it lh b gy ny nr l ns nt">private detachOverlay(): void {<br/>  if (this.overlayRef.hasAttached()) {<br/>    this.overlayRef.detach();<br/>  }<br/>}</span></pre><p id="928a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">以下是完整的指令:</p><figure class="la lb lc ld gt ju"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="67f3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如前所述，你可以在<a class="ae li" href="https://github.com/Dornhoth/info-popup" rel="noopener ugc nofollow" target="_blank">这个资源库</a>中找到完整的代码。我希望通过创建和显示弹出窗口的步骤让您更好地理解了CDK叠加包。请在此处或存储库中随意提问。</p></div></div>    
</body>
</html>