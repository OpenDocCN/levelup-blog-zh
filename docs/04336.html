<html>
<head>
<title>JavaScript Best Practices — Arrays and Arrow Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript最佳实践—数组和箭头函数</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-best-practices-arrays-and-arrow-functions-1893a49d12d8?source=collection_archive---------16-----------------------#2020-06-21">https://levelup.gitconnected.com/javascript-best-practices-arrays-and-arrow-functions-1893a49d12d8?source=collection_archive---------16-----------------------#2020-06-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/b1311496b3d176e039829e8d72d22091.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Uo5WvftanzoeUOhV"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@dnunis?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">达伦·努尼斯</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="3b15" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">像任何类型的应用程序一样，JavaScript应用程序也必须写得很好。否则，我们以后会遇到各种各样的问题。</p><p id="0a6b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将研究一些使用数组和箭头函数的最佳实践。</p><h1 id="9bf2" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">使用映射来映射项目</h1><p id="0cae" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mh mi mj mk b">map</code>方法非常适合将数组条目从原始的映射到其他东西。</p><p id="113c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这样，我们就不需要使用循环来完成。</p><p id="e38b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以与其写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="4bbb" class="mt lf it mk b gy mu mv l mw mx">for (const a of arr) {<br/>  cubed.push(a ** 3);<br/>}</span></pre><p id="3c21" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们写道:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="383d" class="mt lf it mk b gy mu mv l mw mx">const cubed = arr.map(a =&gt; a ** 3);</span></pre><p id="2d25" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个更短更干净。</p><h1 id="0e80" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">这个论点没有用</h1><p id="015d" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">不需要做就不要引用<code class="fe mh mi mj mk b">thsis</code>。例如，当它被用作回调函数时，我们不应该在箭头函数中引用它。</p><p id="3893" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们应该这样写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="61f6" class="mt lf it mk b gy mu mv l mw mx">const cubed = arr.map(a =&gt; a ** 3);</span></pre><p id="a074" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">而不是:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="0aee" class="mt lf it mk b gy mu mv l mw mx">const cubed = arr.map(a =&gt; a ** 3, this);</span></pre><p id="91f8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">或者:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="6769" class="mt lf it mk b gy mu mv l mw mx">const containsE = array.some((char) =&gt; char === 'e', this);</span></pre><h1 id="4e29" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">避免倒车</h1><p id="a251" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">如果我们不使用<code class="fe mh mi mj mk b">reverse</code>来反转数组，我们应该避免使用它。</p><p id="48b7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们只是试图从数组的末尾向左组合结果，我们可以使用<code class="fe mh mi mj mk b">reduceRight</code>来代替。</p><p id="dd5f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，不要写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="7a6d" class="mt lf it mk b gy mu mv l mw mx">const sum = array.reverse().reduce((total, c) =&gt; total + c, 0);</span></pre><p id="dbb7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们应该写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="2214" class="mt lf it mk b gy mu mv l mw mx">const reverseSum = array.reduceRight((total, c) =&gt; total + c, 0);</span></pre><p id="f546" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们跳过了反向操作，做了同样的事情。</p><p id="2eef" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这意味着我们编写的代码更少，代码更快，因为我们跳过了一个操作。</p><h1 id="4691" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">使用平面地图</h1><p id="3ed1" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">最新版本的JavaScript有一个<code class="fe mh mi mj mk b">flatMap</code>方法来映射数组项，并将数组的嵌套减少1级。这比一起使用<code class="fe mh mi mj mk b">map</code>和<code class="fe mh mi mj mk b">flat</code>要好。</p><p id="320d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，不要写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="d862" class="mt lf it mk b gy mu mv l mw mx">const flattenedAndMapped = array.map((a) =&gt; a).flat();</span></pre><p id="2a2c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="c676" class="mt lf it mk b gy mu mv l mw mx">const oneAction = array.flatMap((b) =&gt; b);</span></pre><p id="59df" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果不需要贴图，也可以用<code class="fe mh mi mj mk b">flat</code>:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="9174" class="mt lf it mk b gy mu mv l mw mx">const flattened = array.flat();</span></pre><h1 id="607a" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">使用平板</h1><p id="fef6" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">要展平数组，我们不再需要使用<code class="fe mh mi mj mk b">reduce</code>或<code class="fe mh mi mj mk b">concat</code>。这是因为数组实例现在有了<code class="fe mh mi mj mk b">flat</code>方法来减少嵌套。</p><p id="e66d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，不写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="c952" class="mt lf it mk b gy mu mv l mw mx">const concatFlattened = [].concat(...array);</span></pre><p id="8542" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">或者:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="9c04" class="mt lf it mk b gy mu mv l mw mx">const reduceFlattened = array.reduce((p, n) =&gt; p.concat(n), []);</span></pre><p id="872f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们写道:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="f469" class="mt lf it mk b gy mu mv l mw mx">const flattened = array.flat();</span></pre><h1 id="abf1" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">没有未使用的参数</h1><p id="b182" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">在我们的箭头函数中不应该有未使用的参数。</p><p id="38b9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为它们没有被使用，我们应该把它们移除。</p><p id="22df" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们写道:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="a767" class="mt lf it mk b gy mu mv l mw mx">const fn = (data, user) =&gt; request(user.id, data);</span></pre><p id="b58f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">而不是写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="3adb" class="mt lf it mk b gy mu mv l mw mx">const fn = (data, user) =&gt; request(user.id);</span></pre><p id="3440" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">data</code>在上面的例子中没有用到，所以我们应该把它去掉。</p><h1 id="f276" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">参数数量</h1><p id="baff" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们不应该有太多的参数。我们拥有的参数越多，就越难跟踪它们。</p><p id="5aa8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可能在错误的地方传递参数，也很容易传递错误类型的数据。</p><p id="e2ae" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">理想情况下，我们的函数中有3个或更少的参数。</p><p id="b2d7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，好的函数是:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="ba73" class="mt lf it mk b gy mu mv l mw mx">const fn0 = () =&gt; "";</span></pre><p id="00ef" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">或者:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="a7f7" class="mt lf it mk b gy mu mv l mw mx">const fn3 = (one, two, three) =&gt; one * two * three;</span></pre><p id="cd92" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是下面的就不好了:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="da64" class="mt lf it mk b gy mu mv l mw mx">const fn3 = (a, b, c, d) =&gt; a * b * c * d;</span></pre><p id="477a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们需要更多，那么我们可以传入一个对象或者使用rest操作符。</p><p id="19d2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="17cb" class="mt lf it mk b gy mu mv l mw mx">const fn = ({ a, b, c, d }) =&gt; a * b * c * d;</span></pre><p id="f05a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们使用析构语法来析构对象中的属性。</p><p id="137e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们可以在一个对象中传递任意多的属性。</p><p id="5bbd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，我们可以使用rest运算符，如下所示:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="8dfa" class="mt lf it mk b gy mu mv l mw mx">const fn = (a, b, c, ...d) =&gt; a * b * c * d[0];</span></pre><p id="3e0b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">d</code>是一个参数，它的第四个位置的参数存储在数组中。</p><h1 id="96fa" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">命名功能</h1><p id="d9e9" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">如果我们需要在多个地方使用箭头函数，那么我们应该通过将它们赋给一个变量来命名它们。</p><p id="332e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="ae27" class="mt lf it mk b gy mu mv l mw mx">cosnt fn = (a, b) =&gt; a ** b;</span></pre><p id="98eb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们可以通过写<code class="fe mh mi mj mk b">fn(1, 2)</code>来调用它。</p><p id="17cc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们也可以把它们变成一个物体:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="6baa" class="mt lf it mk b gy mu mv l mw mx">const obj = {<br/>  fn: (a, b) =&gt; a ** b;<br/>}</span></pre><p id="908b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么我们可以写成<code class="fe mh mi mj mk b">obj.fn(1, 2)</code>来称呼它；</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi my"><img src="../Images/a757b2dbf269d64f1251b0ada1ec7bb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0Y8yAkMZyT8vlkT7"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@yerlinmatu?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">叶尔林·马图</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="4886" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="47c1" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">数组实例中有许多方法可以用来操作它们。</p><p id="1690" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，还有更好的方法来定义和使用箭头函数。</p></div></div>    
</body>
</html>