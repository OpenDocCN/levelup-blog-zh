<html>
<head>
<title>Building “Related Post” Engine Using MongoDB Aggregation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用MongoDB聚合构建“相关帖子”引擎</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/building-related-post-engine-using-mongodb-aggregation-9d7186500dfb?source=collection_archive---------4-----------------------#2019-10-23">https://levelup.gitconnected.com/building-related-post-engine-using-mongodb-aggregation-9d7186500dfb?source=collection_archive---------4-----------------------#2019-10-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="b5b6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从WordPress迁移到自定义Node.js堆栈会带来很多挑战。其中之一是构建一些特性，比如处理与<strong class="jp ir">相关的post </strong>插件的功能。在WordPress中这么做很容易，只需添加一个插件，你就差不多完成了。</p><blockquote class="kl km kn"><p id="6d73" class="jn jo ko jp b jq jr js jt ju jv jw jx kp jz ka kb kq kd ke kf kr kh ki kj kk ij bi translated">另请阅读:<a class="ae ks" href="https://codeforgeek.com/migrating-wordpress-content-to-mongodb/" rel="noopener ugc nofollow" target="_blank">将WordPress内容迁移到MongoDB </a></p></blockquote><p id="b094" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我不得不为<strong class="jp ir">“相关帖子”</strong>部分和本文定制代码，我将解释我是如何实现的。</p><p id="eeb4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么什么是相关帖子呢？在每篇文章的底部，您应该会看到:</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi kt"><img src="../Images/e9a5fc5595fae0be04671db0a466adb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*JA42bnHrTJS7Nqeq.png"/></div></div></figure><p id="534b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这说明读者刚看完的那个相关的帖子比较多。它不完全准确，但它是有效的，我使用以下步骤生成它:</p><h1 id="2edf" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">步骤1:标记数据</h1><p id="a850" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">为了根据读者当前查看的内容生成帖子，我们需要关于帖子的信息，例如，这是什么类型的帖子？是基于Node.js还是数据库还是两者都是？</p><p id="73a8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了找到这些信息，我们需要对每篇文章进行相对标记。幸运的是，WordPress已经有了类别和标签作为每篇文章的元数据。</p><p id="25b7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以我的MongoDB数据库中的每篇文章看起来都是这样的:</p><pre class="ku kv kw kx gt mi mj mk ml aw mm bi"><span id="109c" class="mn lg iq mj b gy mo mp l mq mr">&gt; db.posts.findOne();<br/>{<br/>    "_id" : ObjectId("5d246ef5f45b115cde3009bc"),<br/>    "id" : 6354,<br/>    "title" : "5 Free Python Programming Courses for Beginners",<br/>    "date" : "2019-07-08T17:29:49",<br/>    "url" : "https://codeforgeek.com/free-python-programming-courses-for-beginners/",<br/>    "slug" : "free-python-programming-courses-for-beginners",<br/>    "status" : "publish",<br/>    "type" : "post",<br/>    "excerpt" : "-----------------",<br/>    "content" : "-----------------",<br/>    "author" : 1,<br/>    "categories" : [<br/>        {<br/>            "name" : "Python",<br/>            "slug" : "python"<br/>        }<br/>    ],<br/>    "tags" : [<br/>        {<br/>            "name" : "python",<br/>            "slug" : "python"<br/>        },<br/>        {<br/>            "name" : "Tips",<br/>            "slug" : "tips"<br/>        }<br/>    ],<br/>    "featured_image" : "-------------------",<br/>    "pageviews" : 197<br/>}</span></pre><p id="2a45" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意类别和标签——我们也将类别和标签存储在单独的集合中。</p><h1 id="e73d" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">步骤2:运行聚合查询</h1><p id="c290" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">MongoDB聚合是一个数据处理管道，其中文档进入管道的各个阶段，并将其自身转换为聚合结果。为了为我们的站点生成<strong class="jp ir">“Related Post”</strong>结果，我们还需要在集合中查找具有一个或多个匹配类别和标签的匹配帖子。</p><p id="2ba8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以这个过程是这样的:</p><ul class=""><li id="ad7e" class="ms mt iq jp b jq jr ju jv jy mu kc mv kg mw kk mx my mz na bi translated">在帖子中查找，并将其与类别相匹配。</li><li id="1895" class="ms mt iq jp b jq nb ju nc jy nd kc ne kg nf kk mx my mz na bi translated">将匹配的数据传递到下一阶段，并与标签进行匹配。</li><li id="c73f" class="ms mt iq jp b jq nb ju nc jy nd kc ne kg nf kk mx my mz na bi translated">从最多四个记录中抽取结果样本。</li></ul><p id="70ce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是我们网站目前正在使用的一个MongoDB查询:</p><pre class="ku kv kw kx gt mi mj mk ml aw mm bi"><span id="407d" class="mn lg iq mj b gy mo mp l mq mr">function getRelatedArticle(data, callback) {<br/>    dbo.collection('posts').aggregate([{<br/>            $match: {<br/>                "categories.slug": {<br/>                    $in: data.categories<br/>                }<br/>            }<br/>        },<br/>        {<br/>            $match: {<br/>                "tags.slug": {<br/>                    $in: data.tags<br/>                }<br/>            }<br/>        },<br/>        {<br/>            $sample: {<br/>                size: 4<br/>            }<br/>        }<br/>    ]).toArray((err, records) =&gt; {<br/>        if (err) {<br/>            return callback(true, 'error retrieving related records');<br/>        }<br/>        callback(false, records);<br/>    });<br/>}</span></pre><p id="3aee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">数据变量包含用户正在阅读的当前文章的标签和类别。我们使用这些标签和类别在集合中查找相关的文章。这当然是不准确的，但它现在起作用了。</p><p id="6fc5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，我们<a class="ae ks" href="https://codeforgeek.com/caching-a-mongodb-database-with-redis/" rel="noopener ugc nofollow" target="_blank">在Redis </a>中缓存返回的结果，这样我们就不会在每次用户请求页面时都运行聚合查询。</p><p id="23fc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我也在考虑增加一些参数，以获得更准确的结果，如过滤网页浏览等。</p><h1 id="2918" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">结论</h1><p id="ba43" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">MongoDB aggregation是一个强大的工具，通过将查询分解到不同的管道中，并在最后将它们组合在一起产生结果，从而获得复杂的结果。我们用这个来生成这个特性，你也可以用同样的任何你认为合适的目的。</p></div><div class="ab cl ng nh hu ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ij ik il im in"><p id="4f86" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="ko">最初发表于</em><a class="ae ks" href="https://codeforgeek.com/building-related-post-engine-using-mongodb-aggregation/" rel="noopener ugc nofollow" target="_blank"><em class="ko">【https://codeforgeek.com】</em></a><em class="ko">。</em></p></div></div>    
</body>
</html>