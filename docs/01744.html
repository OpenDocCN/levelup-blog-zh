<html>
<head>
<title>Refactoring Redux into React Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将Redux重构为React挂钩</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/refactoring-redux-into-react-hooks-6273647f9378?source=collection_archive---------2-----------------------#2020-01-27">https://levelup.gitconnected.com/refactoring-redux-into-react-hooks-6273647f9378?source=collection_archive---------2-----------------------#2020-01-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="bf1a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Redux很棒，你仍然可以使用它。但是你的所有特性都需要它吗？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/1d26e6a387e9a6169ebbba0fb63fa560.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BuZPEPD609Oqn1Tr"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">布鲁克·安德森在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="30e9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您是否为想要从后端获取的每一小部分数据编写了一个缩减器、3-5个动作创建器和异步动作？如果您认为这是一堆臃肿的文件，其中的“业务”代码在常量、reducers、connect/dispatch/getState中丢失了——那么您就对了，我将向您展示如何使用pure React在更具内聚性的代码中获得同样的好处。</p><p id="756d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">本文是一个重构会议。我假设读者对Redux和React钩子都有很好的理解。</p><h1 id="0bfb" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">出发点</h1><p id="ac8e" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">假设您正在使用react-redux构建一个常规的web应用程序。您可能想要的功能之一是以Redux状态维护会话信息，并在您的应用程序中使用它。这是一个典型的国家消费的例子:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">Hello.js</figcaption></figure><p id="6e01" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果使用细粒度选择器或mapDispatchToProps，可能会有更多。</p><h1 id="85cb" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">使用钩子</h1><p id="f799" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated"><code class="fe mu mv mw mx b">react-redux</code>提供了hooks API，同样的代码可以写成这样:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="73d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们没做什么特别的事。我们只是使用了React Hooks API，而不是同一个库中的HOC API(<code class="fe mu mv mw mx b">connect</code>是一个高阶组件)。它消除了一些与Redux状态消耗相关的样板文件。只要给<code class="fe mu mv mw mx b">useSelector</code>打个电话就完事了。</p><h1 id="7bfd" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">组件不应该知道数据来自哪里</h1><p id="f383" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在第一步之后，我们最终使用了从<code class="fe mu mv mw mx b">react-redux</code>引入的<code class="fe mu mv mw mx b">useSelector</code>函数。如果你只是消耗redux状态，并且不想要任何副作用，这是相当好的。但是你真正想要的是——<code class="fe mu mv mw mx b">session</code>特性的状态。Redux只是一个实现细节，我们可以将这个实现细节隐藏到特性模块中。不仅仅是“更干净的代码”(我不喜欢在真空中清洁代码的想法)。这是重要的一步，给了我们一些重构和移动的空间。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="9e30" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此时，我们的视图组件(Hello.js)不再知道会话是如何加载的。它只是使用了一个由<code class="fe mu mv mw mx b">session.js</code>提供的自定义钩子。但是会话模块本身仍然依赖于redux动作、reducer和其他一些样板文件。还记得你不得不写<code class="fe mu mv mw mx b">componentDidMount</code>来调度fetch动作给redux的情况吗？我总是希望redux能够神奇地理解我正在消耗状态的这一特定部分并获取它。我不会在这里写这段代码，反正我们是要把它扔掉的。</p><h1 id="2c5c" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">你不需要Redux</h1><p id="36f9" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">组件只能通过<code class="fe mu mv mw mx b">useSession</code>钩子使用会话。如果你用别的东西代替redux，组件不在乎。所以让我们开始吧。<code class="fe mu mv mw mx b">Hello</code>组件保持不变，不会再改变，所以我只发布对<code class="fe mu mv mw mx b">session</code>模块的更改。我从一个简单的模块实现开始，有一些空白，并在接下来的重构迭代中改进它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="c4b3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你不需要更多的东西来使它工作，就是这样。此外，它还解决了常见的redux问题——何时启动数据提取，谁负责这个问题？使用定制钩子方法，钩子本身负责，没有额外的样板文件。</p><h1 id="3d9c" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">不要重新计算你已经知道的东西</h1><p id="11e9" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">上面的代码片段有两个缺点:</p><ul class=""><li id="b7ce" class="my mz it lb b lc ld lf lg li na lm nb lq nc lu nd ne nf ng bi translated">每当您在新组件中使用session时，它都会调用<code class="fe mu mv mw mx b">fetchSession</code>函数，这可能计算起来很昂贵，也就是说，它可能会执行网络请求。</li><li id="bdf3" class="my mz it lb b lc nh lf ni li nj lm nk lq nl lu nd ne nf ng bi translated">第一次渲染新组件时，它会以“正在加载”状态(会话的初始状态)进行渲染。</li></ul><p id="ebdb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们解决这个问题！有关解释，请参见代码中的注释</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="b04f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这段代码看起来有点粗糙，但无论如何，它解决了问题。该会话最多被提取一次，并且在提取会话之后不会发生额外的重新呈现。此外，代码现在高度内聚——整个会话管理只有一个文件。</p><h1 id="5e83" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">但是等等，这不是一个过于简单化的案例吗？</h1><p id="669b" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">嗯，确实是。一个更复杂的例子是，如果您使用<code class="fe mu mv mw mx b">session</code>特性来跟踪登录/注销，而不仅仅是查找当前状态。在redux应用程序中，您可能希望为此分派动作，并使用某种中间件来处理异步请求(通常是redux-saga或redux-thunk)。</p><p id="68ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们编写一个使用登录/注销功能而没有redux的组件。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="4129" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们现在可以使用组件代码来理解我们希望<code class="fe mu mv mw mx b">session</code>公开什么API。它应该有一个钩子<code class="fe mu mv mw mx b">useSession</code>——和之前的钩子一样，但是除此之外，它应该公开<code class="fe mu mv mw mx b">login</code>和<code class="fe mu mv mw mx b">logout</code>函数，这是return的承诺。如果成功调用这两者中的任何一个，<code class="fe mu mv mw mx b">useSession</code>将触发其消费者的重新招标。您可能希望使用React上下文来实现这一点，但是让我们首先尝试模拟上下文功能:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="e405" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如您所见，您可以创建一个命令式API，并使用React钩子来消耗这个API的副作用。不需要Redux或React上下文。登录期间的错误由初始调用者处理，并且会话在出错的情况下不会改变。</p><h1 id="1467" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">使用上下文将一个变更交付给多个消费者</h1><p id="578f" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在前一个例子中，我们使用了一组消费者。它可以工作，但是React在这里不能进行太多的优化，并且您可能在一个卸载的组件上有不可预测的状态变化。想象一下，一个组件的状态变化将导致其他组件的卸载。在前面的例子中，我们没有处理这种情况，但是React Context可以开箱即用地处理这种情况。</p><p id="4706" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">默认的React上下文行为的一个缺点是，提供者的安装和评估是独立于它是否被任何组件实际使用的。为了克服这一点，我们可以推迟数据获取，直到我们的自定义钩子被调用。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="ec00" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe mu mv mw mx b">useSession</code> hook调用Provider传来的<code class="fe mu mv mw mx b">setHasConsumer</code>回调，这是Provider获取数据的信号。</p><h1 id="6691" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">摘要</h1><p id="6b55" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我希望我帮助你不要因为众多的小特性而用Redux样板膨胀你的应用。你的应用程序中可能有很多上下文——每个独立的特性有不同的上下文。</p><p id="69d2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在这里没有涉及更多的主题——当一个服务依赖于另一个服务时，如何组织服务。如果您不太关心性能，这很容易——只需在另一个服务的提供者内部使用一个服务导出的钩子。但是你会失去通过<code class="fe mu mv mw mx b">setHasConsumer</code>优化获得的性能。依赖服务总是有一个消费者。如何克服这个问题是另一篇文章的主题。</p><p id="a1d1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> UPD: </strong></p><p id="6872" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是故事的第二部分，我们为状态管理构建了可重用的库，并修复了上面概述的缺点——使用React Hooks进行全局状态管理。</p></div></div>    
</body>
</html>