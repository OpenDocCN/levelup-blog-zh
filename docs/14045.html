<html>
<head>
<title>The Whale Optimization Algorithm (WOA) in C++</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C++中的鲸鱼优化算法(WOA)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/the-whale-optimization-algorithm-woa-in-c-5cd6d0044956?source=collection_archive---------5-----------------------#2022-10-27">https://levelup.gitconnected.com/the-whale-optimization-algorithm-woa-in-c-5cd6d0044956?source=collection_archive---------5-----------------------#2022-10-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><h1 id="937c" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">算法源</h1><p id="37cc" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">米尔贾利利、塞耶达利和安德鲁·刘易斯。"鲸鱼优化算法。"<em class="ln">工程软件进展</em>，第95卷，2015年1月14日，第51–67页。，https://doi.org/10.1155/2817.访问2022年9月20日。</p><p id="87a5" class="pw-post-body-paragraph ko kp it kq b kr lo kt ku kv lp kx ky kz lq lb lc ld lr lf lg lh ls lj lk ll im bi translated">虽然鲸鱼可以单独生活，也可以群居，但人们最常观察到的是成群结队的鲸鱼。一些种类的鲸鱼，如虎鲸，将终生生活在一个家庭中。对于座头鲸来说，这些群体动态导致了它们在狩猎或觅食时的有趣行为，包括在海洋表面附近包围大群磷虾的几种策略。鲸鱼优化算法(WOA)利用这些生物行为来解决复杂的多维优化问题。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi lt"><img src="../Images/421c443c06384d2da50e8485d7cc5ba4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NmCSyBOvyj_TlXVO"/></div></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">照片由<a class="ae lm" href="https://unsplash.com/@toddcravens?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">托德·克雷文</a>在<a class="ae lm" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="b1ce" class="pw-post-body-paragraph ko kp it kq b kr lo kt ku kv lp kx ky kz lq lb lc ld lr lf lg lh ls lj lk ll im bi translated">在这篇文章中，我们介绍并简要讨论了WOA。该算法用C++实现，并通过优化Rastrigin和Sphere函数给出了演示用法。该算法快速有效地优化这些函数，提供其实际最小值的优秀近似值。</p><h1 id="a5cb" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">鲸鱼优化算法</h1><p id="b62a" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">如上所述，鲸鱼优化算法是一种生物启发的算法，它利用了座头鲸的狩猎行为。在海面附近捕食磷虾(或其他小鱼群)时，座头鲸采用两种基本策略:</p><ol class=""><li id="0bdc" class="mj mk it kq b kr lo kv lp kz ml ld mm lh mn ll mo mp mq mr bi translated"><strong class="kq iu">向上螺旋</strong>鲸鱼向下俯冲，在猎物周围形成一个气泡螺旋形状，同时游回水面</li><li id="6ee6" class="mj mk it kq b kr ms kv mt kz mu ld mv lh mw ll mo mp mq mr bi translated"><strong class="kq iu">双循环</strong>包括三个独立的子阶段:I)围捕循环——围捕猎物的向上螺旋，ii)长尾——有点像海面上的鲸鱼尾巴(也称为锚爪), iii)捕获循环——第二次向上突进捕获被围捕的猎物。</li></ol><p id="d6b5" class="pw-post-body-paragraph ko kp it kq b kr lo kt ku kv lp kx ky kz lq lb lc ld lr lf lg lh ls lj lk ll im bi translated">这些操作的数学定义如下。</p><h2 id="de84" class="mx jr it bd js my mz dn jw na nb dp ka kz nc nd ke ld ne nf ki lh ng nh km ni bi translated">包围猎物</h2><p id="0818" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">首先，我们将考虑<em class="ln">包围猎物</em> ( <strong class="kq iu">螺旋上升</strong> ) <em class="ln">。</em>对于那些熟悉学习算法基础的人来说，包围猎物是一种<em class="ln">剥削</em>行为。座头鲸会识别成群的猎物并包围它们，对于我们的“鲸鱼”群体来说，鱼群(优化对象)的位置是未知的，因为这是最优解。因此，我们的座头鲸会使用最接近猎物的鲸的位置，即最小化或最大化目标函数的鲸。这迫使算法群体向最优值移动。</p><p id="291b" class="pw-post-body-paragraph ko kp it kq b kr lo kt ku kv lp kx ky kz lq lb lc ld lr lf lg lh ls lj lk ll im bi translated">从数学上讲，这是通过以下一组等式实现的:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/8354e499665e32a4b4167d4b81fea189.png" data-original-src="https://miro.medium.com/v2/resize:fit:550/format:webp/1*jGDhoDrrl_nJvYnLJoAL9Q.png"/></div></figure><p id="c919" class="pw-post-body-paragraph ko kp it kq b kr lo kt ku kv lp kx ky kz lq lb lc ld lr lf lg lh ls lj lk ll im bi translated">这里，<strong class="kq iu"> A </strong>和<strong class="kq iu"> C </strong>是系数向量(下面计算)，<strong class="kq iu"> X* </strong>是目前为止得到的最佳解(最佳鲸鱼)的位置向量，<strong class="kq iu"> X </strong>是正在更新的鲸鱼的位置向量，周期算子<strong class="kq iu">。</strong>是元素式乘法。</p><p id="f4ac" class="pw-post-body-paragraph ko kp it kq b kr lo kt ku kv lp kx ky kz lq lb lc ld lr lf lg lh ls lj lk ll im bi translated">系数向量A和C计算如下</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/3cfda7f897116f9659da59d00b74fa94.png" data-original-src="https://miro.medium.com/v2/resize:fit:336/format:webp/1*eTzK9iOLfz3h-Pi05-RUXA.png"/></div></figure><p id="3d45" class="pw-post-body-paragraph ko kp it kq b kr lo kt ku kv lp kx ky kz lq lb lc ld lr lf lg lh ls lj lk ll im bi translated">其中<strong class="kq iu"> a </strong>在迭代过程中从2线性减少到0，并且<strong class="kq iu"> r </strong>是[0，1]中的随机向量。</p><h2 id="b7e6" class="mx jr it bd js my mz dn jw na nb dp ka kz nc nd ke ld ne nf ki lh ng nh km ni bi translated">泡沫网攻击方法</h2><p id="b178" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">泡网攻击是利用阶段的延伸。由于座头鲸沿着一条收缩的螺旋形路径在猎物周围游动，因此需要两种方法来模拟这种类型的攻击:收缩环绕和螺旋更新。</p><p id="69f5" class="pw-post-body-paragraph ko kp it kq b kr lo kt ku kv lp kx ky kz lq lb lc ld lr lf lg lh ls lj lk ll im bi translated">为了模拟前者，向量<strong class="kq iu"> a </strong>(如上定义)在每次迭代中减少。由于<strong class="kq iu"> A </strong>依赖于<strong class="kq iu"> a </strong>，向量<strong class="kq iu"> A </strong>也在每次迭代中减少。将<strong class="kq iu"> A </strong>的值设置为[-1，1]中的值意味着代理的新位置可以在鲸鱼和最佳鲸鱼的当前位置之间的任何位置。</p><p id="fd8a" class="pw-post-body-paragraph ko kp it kq b kr lo kt ku kv lp kx ky kz lq lb lc ld lr lf lg lh ls lj lk ll im bi translated">为了模拟螺旋更新，计算鲸鱼(X，Y)和猎物(X*，Y*)之间的距离。下面的螺旋方程是在鲸鱼的位置和猎物的位置之间建立的，以模仿座头鲸的螺旋运动</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/4559ce3b77b593482c9eba2217ec501a.png" data-original-src="https://miro.medium.com/v2/resize:fit:686/format:webp/1*L18wjwHyoD_Bit1Ieypjfw.png"/></div></figure><p id="51f7" class="pw-post-body-paragraph ko kp it kq b kr lo kt ku kv lp kx ky kz lq lb lc ld lr lf lg lh ls lj lk ll im bi translated">其中<strong class="kq iu"> b </strong>是定义螺旋形状的常数(算法参数)，而<strong class="kq iu"> l </strong>是[-1，1]中的随机数。</p><p id="e813" class="pw-post-body-paragraph ko kp it kq b kr lo kt ku kv lp kx ky kz lq lb lc ld lr lf lg lh ls lj lk ll im bi translated">在自然界中，这两种行为同时发生，这在模拟中是做不到的。相反，每个单独的操作，螺旋更新和收缩环绕，在算法中以50%的概率发生。也就是说，</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/403050ca87b89b761ac4aea2415e4d1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:928/format:webp/1*0UJehoMxRjGqrGPLz0ufVg.png"/></div></figure><p id="68c9" class="pw-post-body-paragraph ko kp it kq b kr lo kt ku kv lp kx ky kz lq lb lc ld lr lf lg lh ls lj lk ll im bi translated">其中<strong class="kq iu"> p </strong>是[0，1]中的随机值。</p><h2 id="a60c" class="mx jr it bd js my mz dn jw na nb dp ka kz nc nd ke ld ne nf ki lh ng nh km ni bi translated">寻找猎物</h2><p id="d25b" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">接下来，WOA需要处理典型的学习算法的<em class="ln">探索阶段</em>。这是通过搜索猎物模拟完成的。该算法的这一阶段与开发阶段非常相似，在开发阶段，鲸鱼(随机地)向当前的最佳解决方案靠近。不同之处在于选择当前代理将更接近的鲸鱼。在<em class="ln">寻找猎物</em>探索阶段，当前鲸鱼将随机选择一只参考鲸鱼，并向其位置靠近。下面的等式描述了这种行为，并且几乎与环绕猎物阶段的等式相同。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/ebee975742192d86904460b1ad4a8252.png" data-original-src="https://miro.medium.com/v2/resize:fit:518/format:webp/1*gPKI09sSLeFeBKpxqtaGQQ.png"/></div></figure><p id="3965" class="pw-post-body-paragraph ko kp it kq b kr lo kt ku kv lp kx ky kz lq lb lc ld lr lf lg lh ls lj lk ll im bi translated">这里，X_rand是随机选择的代理，其他变量和操作如上定义。</p><h2 id="2ab2" class="mx jr it bd js my mz dn jw na nb dp ka kz nc nd ke ld ne nf ki lh ng nh km ni bi translated">该算法</h2><p id="bccf" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在此背景下，WOA定义如下。</p><pre class="lu lv lw lx gt no np nq nr aw ns bi"><span id="c358" class="mx jr it np b gy nt nu l nv nw">1. Initialize the whale population<br/>2. Calculate fitness of each whale and find X_best (the best agent)</span><span id="aecc" class="mx jr it np b gy nx nu l nv nw">while( t &lt; maximum number of iterations )<br/>    for each search agent:<br/>        Update a, A, C, l, and p<br/>        if(p &lt; 0.5):<br/>            if(|A|&lt;1):<br/>                Update current agent via Encircling Prey<br/>            else:<br/>                Select a random agent (X_rand)<br/>                Update current agent via Search for Prey<br/>        else:<br/>            update search agent via Bubble-net Attacking<br/>    endfor</span><span id="96f0" class="mx jr it np b gy nx nu l nv nw">    Amend the position of whales that are outside the search space            <br/>    Calculate the fitness of each search agent<br/>    Determing new X_best (if need be)<br/>             <br/>    t = t+1<br/>endwhile</span><span id="bfe9" class="mx jr it np b gy nx nu l nv nw">return X_best</span></pre><p id="1f6b" class="pw-post-body-paragraph ko kp it kq b kr lo kt ku kv lp kx ky kz lq lb lc ld lr lf lg lh ls lj lk ll im bi translated">源文件为WOA提供了上述算法。在下面的实现中，添加了另一个特性，如果我们在运行时早期找到了一个最优解(或者如果我们陷入了一个低谷)，就可以缩短计算时间。该算法的参数之一是一个<em class="ln">不变ITERS </em>值。如果最佳鲸鱼(X_best)的适应度在这个迭代次数中没有改变，则算法被短路，并且返回当前的最佳鲸鱼。</p><h1 id="51a1" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">履行</h1><p id="64c9" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">C++实现分为两个主要部分:一个存储鲸鱼群体成员数据的鲸鱼类，以及包含一些帮助函数和优化算法逻辑的WOA文件。</p><h2 id="5ce3" class="mx jr it bd js my mz dn jw na nb dp ka kz nc nd ke ld ne nf ki lh ng nh km ni bi translated">鲸鱼类</h2><p id="50d8" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">首先，我们需要一些地方来存储与我们群体中的某个个体相关的信息，例如鲸鱼。这是通过下面的代码用Whale类完成的</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="b2f1" class="pw-post-body-paragraph ko kp it kq b kr lo kt ku kv lp kx ky kz lq lb lc ld lr lf lg lh ls lj lk ll im bi translated">如上面的代码所示，Whale对象非常简单。本质上，我们从鲸鱼那里需要的只是一种计算、更新和存储个体位置和适合度的方法(<em class="ln">update _ position</em>，<em class="ln"> set_fitness，get_fitness，get_position </em>)，将鲸鱼保持在问题域内的功能(<em class="ln"> amend_bounds </em>)，以及准确地说，一种告诉鲸鱼当前在哪里以及它离猎物有多近(最优解)的方法(<em class="ln"> print </em>)。上面提供了这些方法及其实现。</p><p id="4bec" class="pw-post-body-paragraph ko kp it kq b kr lo kt ku kv lp kx ky kz lq lb lc ld lr lf lg lh ls lj lk ll im bi translated">重要的一点是，whale将存储一个<em class="ln"> n- </em>维<em class="ln">位置，</em>其中<em class="ln"> n </em>取决于手头的问题，以及一个让算法(有时还有其他whale)知道它离最优解有多近的适应值。最初，鲸鱼的位置被设置为我们领域中的某个随机位置，这就是初始种群是如何创建的。一旦选择了随机位置，就计算初始适应值。这一切都发生在<em class="ln"> Whale::initialize </em>函数中，并为种群中的所有鲸鱼完成。</p><h2 id="17e4" class="mx jr it bd js my mz dn jw na nb dp ka kz nc nd ke ld ne nf ki lh ng nh km ni bi translated">该算法</h2><p id="5d1d" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">接下来，用C++实现上面定义的优化算法。此外，贯穿整个实现的是对matplotlibcpp功能的引用。我在<a class="ae lm" rel="noopener ugc nofollow" target="_blank" href="/plotting-data-in-c-84960b63ce92">之前的博客文章</a>中写了更多。对于那些对绘制数据不感兴趣的人(这主要是为了这篇博文)，可以从下面的逻辑中删除对“matplotlibcpp”和“plt::”的引用，以消除这种依赖性。</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="ny nz l"/></div></figure><p id="edd4" class="pw-post-body-paragraph ko kp it kq b kr lo kt ku kv lp kx ky kz lq lb lc ld lr lf lg lh ls lj lk ll im bi translated">如上所示，WOA接受一组可以在代码中更新的参数，以改变算法的行为方式。</p><ol class=""><li id="562a" class="mj mk it kq b kr lo kv lp kz ml ld mm lh mn ll mo mp mq mr bi translated"><strong class="kq iu"> POPULATION_SIZE </strong>:算法中使用的鲸鱼(代理)数量</li><li id="5c6d" class="mj mk it kq b kr ms kv mt kz mu ld mv lh mw ll mo mp mq mr bi translated"><strong class="kq iu">维度</strong>:自由变量的数量(即适应度函数的输入)。</li><li id="bc2c" class="mj mk it kq b kr ms kv mt kz mu ld mv lh mw ll mo mp mq mr bi translated"><strong class="kq iu"> MAX_ITERS </strong>:算法停止之前的最大迭代次数</li><li id="2dde" class="mj mk it kq b kr ms kv mt kz mu ld mv lh mw ll mo mp mq mr bi translated"><strong class="kq iu"> UNCHANGED_ITERS </strong>:算法“停留”在特定最佳解上的迭代次数。经过这么多次迭代后，算法将会短路。</li><li id="3c02" class="mj mk it kq b kr ms kv mt kz mu ld mv lh mw ll mo mp mq mr bi translated"><strong class="kq iu">最大位置</strong>:定义搜索空间的边界</li><li id="7005" class="mj mk it kq b kr ms kv mt kz mu ld mv lh mw ll mo mp mq mr bi translated"><strong class="kq iu"> MINPOS </strong>:定义搜索空间的边界。</li><li id="4c9f" class="mj mk it kq b kr ms kv mt kz mu ld mv lh mw ll mo mp mq mr bi translated"><strong class="kq iu"> B </strong>:螺旋系数</li><li id="2bd7" class="mj mk it kq b kr ms kv mt kz mu ld mv lh mw ll mo mp mq mr bi translated"><strong class="kq iu"> A_DEGRADE </strong>:迭代过程中<strong class="kq iu"> a </strong>变量的退化</li></ol><h1 id="2eb3" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">优化函数和最优解</h1><p id="3614" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">有两种算法被用来测试WOA:Rastrigin和sphere函数。Rastrigin函数在数学上定义为</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/670ff954b305c954055dbebd2846a223.png" data-original-src="https://miro.medium.com/v2/resize:fit:796/format:webp/1*18jnBeX7_UrKpZCDZufwdw.png"/></div></figure><p id="f554" class="pw-post-body-paragraph ko kp it kq b kr lo kt ku kv lp kx ky kz lq lb lc ld lr lf lg lh ls lj lk ll im bi translated">并且当所有x_i都是0时具有最小值，即当</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi ob"><img src="../Images/3171d958d976a7f66e7d629d31d753ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:282/format:webp/1*OPrD26IGZ3r5SN40U3aqCQ.png"/></div></div></figure><p id="bb25" class="pw-post-body-paragraph ko kp it kq b kr lo kt ku kv lp kx ky kz lq lb lc ld lr lf lg lh ls lj lk ll im bi translated">这个函数的表面如下所示。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/15ce5c1ab22180ceda3f4c02afc081db.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*3Ciqh8za1NFiFsuxR6mALg.png"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated"><a class="ae lm" href="https://www.geeksforgeeks.org/implementation-of-whale-optimization-algorithm/?ref=rp" rel="noopener ugc nofollow" target="_blank">https://www . geeks forgeeks . org/implementation-of-whale-optimization-algorithm/？ref=rp </a></figcaption></figure><p id="52fd" class="pw-post-body-paragraph ko kp it kq b kr lo kt ku kv lp kx ky kz lq lb lc ld lr lf lg lh ls lj lk ll im bi translated">如此处所示，Rastrigin函数包含许多峰值和谷值，这为优化函数在次优最小值和最大值处停滞提供了充足的机会，使其成为优化算法的良好测试。</p><p id="be17" class="pw-post-body-paragraph ko kp it kq b kr lo kt ku kv lp kx ky kz lq lb lc ld lr lf lg lh ls lj lk ll im bi translated">用于测试算法的第二个函数是球面函数，数学定义为</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi od"><img src="../Images/b4a92cf4164a6db0e6c6bb3026f83b88.png" data-original-src="https://miro.medium.com/v2/resize:fit:376/format:webp/1*XyLByv2ee09aB_FNCHHlcA.png"/></div></figure><p id="607f" class="pw-post-body-paragraph ko kp it kq b kr lo kt ku kv lp kx ky kz lq lb lc ld lr lf lg lh ls lj lk ll im bi translated">并且当所有x_i = 0时也具有最小值，或者</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi ob"><img src="../Images/3171d958d976a7f66e7d629d31d753ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:282/format:webp/1*OPrD26IGZ3r5SN40U3aqCQ.png"/></div></div></figure><p id="9179" class="pw-post-body-paragraph ko kp it kq b kr lo kt ku kv lp kx ky kz lq lb lc ld lr lf lg lh ls lj lk ll im bi translated">如下图所示，该函数的图形与Rastrigin函数的图形非常相似，最大的区别是没有“凹凸不平”的表面，而是平滑的。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi oe"><img src="../Images/36e639c33695b5d4013ed6d099c967df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8J7acbAnP6schCF6jZEv2g.png"/></div></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated"><a class="ae lm" href="https://www.geeksforgeeks.org/implementation-of-whale-optimization-algorithm/?ref=rp" rel="noopener ugc nofollow" target="_blank">https://www . geeks forgeeks . org/implementation-of-whale-optimization-algorithm/？ref=rp </a></figcaption></figure><p id="6c2b" class="pw-post-body-paragraph ko kp it kq b kr lo kt ku kv lp kx ky kz lq lb lc ld lr lf lg lh ls lj lk ll im bi translated">这些函数的实现可以在<em class="ln"> woa.cpp </em>中包含的lambda函数中看到。</p><h1 id="878d" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">结果</h1><p id="0494" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">如上面的代码所示，适应度函数在C++代码中存储为lambda函数，以便在它们之间轻松切换。代码重复如下。</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="ny nz l"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">球体适应度函数。</figcaption></figure><p id="6591" class="pw-post-body-paragraph ko kp it kq b kr lo kt ku kv lp kx ky kz lq lb lc ld lr lf lg lh ls lj lk ll im bi translated">使用球体适应度函数运行上面的代码可以快速找到(0，0，0)处的最小值，如下图所示。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi of"><img src="../Images/ac43fdd1ff922e65f66982f175780600.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*k44wfE8t3cpjS62aS9ZO_A.png"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">显示最佳鲸鱼的当前迭代和适应度函数值的图形。</figcaption></figure><p id="a16f" class="pw-post-body-paragraph ko kp it kq b kr lo kt ku kv lp kx ky kz lq lb lc ld lr lf lg lh ls lj lk ll im bi translated">该图显示了最佳鲸鱼的迭代次数(x轴)和适应度函数值。球函数的最小值在点(0，0，0)处为0。WOA发现这个值非常快，大约。25次迭代，并且该算法在大约175次迭代后短路(它被设置为最多运行500次迭代)。在下面的GIF图中，我们可以看到鲸群正在寻找最优解。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi of"><img src="../Images/11a7ba16cf287ac94f19cdac19876e0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*IThrAjXQDMIsM2UnFm4kDw.gif"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">最佳鲸鱼的X和Y坐标。</figcaption></figure><p id="e058" class="pw-post-body-paragraph ko kp it kq b kr lo kt ku kv lp kx ky kz lq lb lc ld lr lf lg lh ls lj lk ll im bi translated">这张GIF显示了随着算法的进行，最佳鲸鱼的X和Y值(最佳鲸鱼的位置)。正如这里看到的，鲸鱼很快接近最优解。(X，Z)和(Z，Y)坐标的图形非常相似。</p><p id="87e4" class="pw-post-body-paragraph ko kp it kq b kr lo kt ku kv lp kx ky kz lq lb lc ld lr lf lg lh ls lj lk ll im bi translated">接下来，我们将在Rastrigin适应度函数上测试该算法。</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="ny nz l"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">拉斯特里金适应度函数。</figcaption></figure><p id="02bf" class="pw-post-body-paragraph ko kp it kq b kr lo kt ku kv lp kx ky kz lq lb lc ld lr lf lg lh ls lj lk ll im bi translated">该函数的结果看起来非常类似于球体适应度函数的结果。下图显示，WOA需要更长的时间来找到函数的最小值，但在大约。150次迭代。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi of"><img src="../Images/938ae39dd17b62ac7a2fabbf09cc20f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*tsGbfJBOtmXtgCdLuqOdog.png"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">显示最佳鲸鱼的当前迭代和适应度函数值。</figcaption></figure><p id="1b0b" class="pw-post-body-paragraph ko kp it kq b kr lo kt ku kv lp kx ky kz lq lb lc ld lr lf lg lh ls lj lk ll im bi translated">再次绘制最佳鲸鱼位置随时间变化的二维切片显示，鲸鱼种群很快就找到了最优解。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi of"><img src="../Images/38c10848cbe08c4d6adef052e6e85eb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*69oak5G_UKastP23EunDHg.gif"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">最佳鲸鱼的X和Y坐标。</figcaption></figure><h1 id="1673" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">结论</h1><p id="c90e" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在这篇文章中，介绍了鲸优化算法(WOA ),并对运算进行了数学定义。解释了该算法，并用C++提供了一个实现。描述了两个选择适应度函数，sphere和Rastrigin，并使用WOA来确定这两个函数的最优解。如结果部分所示，WOA可以快速找到这两个函数的最优解。观察WOA在其他更复杂的适应度函数上的表现将是有趣的，以确定该算法是否是其他优化算法的可行替代。</p></div><div class="ab cl og oh hx oi" role="separator"><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol"/></div><div class="im in io ip iq"><p id="9983" class="pw-post-body-paragraph ko kp it kq b kr lo kt ku kv lp kx ky kz lq lb lc ld lr lf lg lh ls lj lk ll im bi translated">通过成为<a class="ae lm" href="https://anthony-a-morast.medium.com/membership" rel="noopener">中级会员</a>或者在亚马逊上购物来支持我的内容<a class="ae lm" href="https://amzn.to/3UNfRCw" rel="noopener ugc nofollow" target="_blank">成为更好的C++程序员</a>或者<a class="ae lm" href="https://amzn.to/3UJgBbQ" rel="noopener ugc nofollow" target="_blank">学习更多关于优化算法的知识</a>。</p></div></div>    
</body>
</html>