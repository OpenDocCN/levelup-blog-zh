<html>
<head>
<title>Understanding React Render Props by Example</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过示例了解React渲染道具</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/understanding-react-render-props-by-example-71f2162fd0f2?source=collection_archive---------0-----------------------#2018-03-26">https://levelup.gitconnected.com/understanding-react-render-props-by-example-71f2162fd0f2?source=collection_archive---------0-----------------------#2018-03-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5ada" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用render props逐步构建React组件，以了解如何实现该模式</h2></div><p id="a064" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本教程中，我们将涵盖使用渲染道具构建自己的组件所需的概念。我们将使用render props实现一个组件来将React状态保存到<code class="fe le lf lg lh b">localStorage</code>，称为<code class="fe le lf lg lh b">&lt;Storage/&gt;</code>，这将允许您将功能注入到组件中，而无需在整个应用程序中复制逻辑。</p><div class="li lj gp gr lk ll"><a href="https://gitconnected.com/learn/react" rel="noopener  ugc nofollow" target="_blank"><div class="lm ab fo"><div class="ln ab lo cl cj lp"><h2 class="bd iu gy z fp lq fr fs lr fu fw is bi translated">学习React -最佳React教程(2019) | gitconnected</h2><div class="ls l"><h3 class="bd b gy z fp lq fr fs lr fu fw dk translated">React的前48门课程。教程由开发者提交并投票，让你找到最好的反应…</h3></div><div class="lt l"><p class="bd b dl z fp lq fr fs lr fu fw dk translated">gitconnected.com</p></div></div><div class="lu l"><div class="lv l lw lx ly lu lz ma ll"/></div></div></a></div><blockquote class="mb mc md"><p id="bfc5" class="ki kj me kk b kl km ju kn ko kp jx kq mf ks kt ku mg kw kx ky mh la lb lc ld im bi translated">如果您有兴趣查看高阶元件的相同示例，请查看本文<a class="ae mi" href="https://medium.com/gitconnected/understanding-react-higher-order-components-by-example-95e8c47c8006" rel="noopener"/></p></blockquote><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi mj"><img src="../Images/ce831295771fbb4c34676b7f048cbaec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V1YzyqnTgx0hkLWSIdw1VA.jpeg"/></div></div></figure><h1 id="1274" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">渲染道具简介</h1><p id="6b62" class="pw-post-body-paragraph ki kj it kk b kl nm ju kn ko nn jx kq kr no kt ku kv np kx ky kz nq lb lc ld im bi translated">render props模式是一种在组件之间共享功能而无需重复代码的方式。官方的React文件将其定义为—</p><blockquote class="nr"><p id="553a" class="ns nt it bd nu nv nw nx ny nz oa ld dk translated">术语“渲染道具”指的是一种简单的技术，使用一个值为函数的道具在React组件之间共享代码。</p></blockquote><pre class="ob oc od oe of og lh oh oi aw oj bi"><span id="82d1" class="ok mv it lh b gy ol om l on oo">&lt;DataProvider render={data =&gt; (<br/>  &lt;h1&gt;Hello {data.target}&lt;/h1&gt;<br/>)}/&gt;</span></pre><p id="da23" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过使用prop来定义呈现的内容，组件只是注入功能，而不需要知道它是如何应用到UI的。让我们看一个例子来理解这实际上意味着什么。</p><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi op"><img src="../Images/aced8a676f6e35c5f7a618a71ff5fd7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TLAWV1AQAnbMj9Ravbgq7A.png"/></div></div></figure><div class="li lj gp gr lk ll"><a href="https://gitconnected.com/portfolio-api" rel="noopener  ugc nofollow" target="_blank"><div class="lm ab fo"><div class="ln ab lo cl cj lp"><h2 class="bd iu gy z fp lq fr fs lr fu fw is bi translated">组合API —轻松发展您的编码事业| gitconnected</h2><div class="ls l"><h3 class="bd b gy z fp lq fr fs lr fu fw dk translated">消除在每个单独位置手动更新您的详细信息的痛苦。只需在您的中更改一次数据…</h3></div><div class="lt l"><p class="bd b dl z fp lq fr fs lr fu fw dk translated">gitconnected.com</p></div></div><div class="lu l"><div class="oq l lw lx ly lu lz ma ll"/></div></div></a></div><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi op"><img src="../Images/aced8a676f6e35c5f7a618a71ff5fd7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TLAWV1AQAnbMj9Ravbgq7A.png"/></div></div></figure><h1 id="d371" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">渲染道具模式</h1><p id="3038" class="pw-post-body-paragraph ki kj it kk b kl nm ju kn ko nn jx kq kr no kt ku kv np kx ky kz nq lb lc ld im bi translated">Render props意味着传递一个由单独组件的props定义的Render函数来指示共享组件应该返回什么。在根级别，它必须采用以下形式:</p><figure class="mk ml mm mn gt mo"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="bea2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">this.props.render()</code>是由另一个组件传入的函数。这个函数本身应该返回一个React组件。我们上面创建的简单渲染道具只是将元素包装在一个<code class="fe le lf lg lh b">&lt;div&gt;</code>中。为了利用<code class="fe le lf lg lh b">&lt;SharedComponent /&gt;</code>,我们要做以下事情:</p><figure class="mk ml mm mn gt mo"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="6ce0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">还有一点值得注意的是，道具的名字不需要一定是<code class="fe le lf lg lh b">render</code>。重要的是它返回一个React元素。例如，我们可以将上面的道具重命名为<code class="fe le lf lg lh b">wrapThisThingInADiv</code>，它的功能仍然完全相同。</p><figure class="mk ml mm mn gt mo"><div class="bz fp l di"><div class="or os l"/></div></figure><h1 id="0fc9" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">一个简单的渲染道具组件示例</h1><p id="b654" class="pw-post-body-paragraph ki kj it kk b kl nm ju kn ko nn jx kq kr no kt ku kv np kx ky kz nq lb lc ld im bi translated">现在我们已经建立了render prop模式，让我们利用它在组件之间实际共享一些功能。我们将创建一个组件，通过render prop函数在被渲染的组件中注入数据。</p><p id="a18c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们的团队已经算出了<code class="fe le lf lg lh b">secretToLife</code>，结果是数字<code class="fe le lf lg lh b">42</code>。我们的一些组件需要共享这些信息，我们可以创建一个名为<code class="fe le lf lg lh b">ShareSecretToLife</code>的渲染道具组件来传递给我们的组件。</p><figure class="mk ml mm mn gt mo"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="e583" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里我们将<code class="fe le lf lg lh b">secretToLife</code>作为参数传递给我们的<code class="fe le lf lg lh b">render</code>属性函数。这也允许我们使用返回的React组件中的值——在本例中，在<code class="fe le lf lg lh b">&lt;h1&gt;</code>中显示粗体42。</p><h1 id="6a7e" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">一个实用渲染道具组件实例</h1><p id="7c84" class="pw-post-body-paragraph ki kj it kk b kl nm ju kn ko nn jx kq kr no kt ku kv np kx ky kz nq lb lc ld im bi translated">既然我们已经了解了如何使用渲染道具共享数据和功能，我们就可以构建一个具有实际意义的渲染道具了。由于render prop组件仅仅是一个组件，因此我们可以访问整个React API，例如生命周期方法和组件状态。</p><p id="df9d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们的<code class="fe le lf lg lh b">&lt;Storage /&gt;</code>组件的功能是用<code class="fe le lf lg lh b">localStorage</code>保存/加载组件的状态，允许我们在页面加载时快速访问和呈现它。然后，它将通过渲染道具共享此功能。这使它具有以下形式:</p><figure class="mk ml mm mn gt mo"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="34bb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<code class="fe le lf lg lh b">&lt;Storage /&gt;</code>的顶部，我们在组件的状态中有一个单独的项目，它跟踪<code class="fe le lf lg lh b">localStorage</code>在给定的浏览器中是否可用。我们使用<code class="fe le lf lg lh b">componentDidMount</code>生命周期钩子，它将通过<code class="fe le lf lg lh b">checkLocalStorageExists</code>函数检查<code class="fe le lf lg lh b">localStorage</code>是否存在。在这里，它将测试保存一个项目，如果成功，将状态设置为true。</p><p id="171d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还向组件添加了三个函数— <code class="fe le lf lg lh b">load</code>、<code class="fe le lf lg lh b">save</code>和<code class="fe le lf lg lh b">remove</code>。这些用于直接访问可用的<code class="fe le lf lg lh b">localStorage</code> API。我们在组件上的三个函数被传递来呈现prop函数。</p><p id="86b4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，我们将创建一个新的<code class="fe le lf lg lh b">render</code>组件，在我们的共享<code class="fe le lf lg lh b">&lt;Storage /&gt;</code>组件中使用，这允许它获得存储功能。它将用于显示用户的用户名和最喜欢的电影。然而，获取这些信息的API调用需要很长时间。我们也可以假设这些值一旦设定就永远不会改变。</p><p id="591e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了确保我们有很好的用户体验，我们将只在值没有保存到<code class="fe le lf lg lh b">localStorage</code>时调用这个API。然后每次用户返回页面时，他们可以立即访问数据，而不是等待我们的API返回。</p><figure class="mk ml mm mn gt mo"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="f85c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们共享的<code class="fe le lf lg lh b">&lt;Storage /&gt;</code>注入<code class="fe le lf lg lh b">&lt;ComponentNeedingStorage /&gt;</code>使用的<code class="fe le lf lg lh b">save</code>和<code class="fe le lf lg lh b">load</code>。首先，我们通过尝试从存储器或组件状态加载来检查<code class="fe le lf lg lh b">username</code>和<code class="fe le lf lg lh b">favoriteMovie</code>是否存在。如果它们不存在，我们将使我们的<code class="fe le lf lg lh b">reallyLongApiCall</code>被称为内部<code class="fe le lf lg lh b">fetchData</code>。我们想确保我们只调用这个函数一次，所以我们也管理一个<code class="fe le lf lg lh b">isFetching</code>变量。一旦数据从<code class="fe le lf lg lh b">localStorage</code>加载或者从API调用返回，我们就向用户显示它们。</p><h1 id="ac26" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">包裹</h1><p id="8f83" class="pw-post-body-paragraph ki kj it kk b kl nm ju kn ko nn jx kq kr no kt ku kv np kx ky kz nq lb lc ld im bi translated">Render props是一种强大的模式，允许开发人员在组件之间共享功能。它使我们能够保持代码干燥，并将方法提取到一个公共位置</p><p id="183c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">渲染道具通常被比作高阶组件，因为它们的用途相似。如果您有兴趣了解更多关于高阶组件的知识，请查看我的另一篇文章<a class="ae mi" rel="noopener ugc nofollow" target="_blank" href="/understanding-react-higher-order-components-by-example-95e8c47c8006?source=user_profile---------1----------------">中我构建了相同的存储功能。</a></p><p id="a515" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由开发者决定他们在渲染props和HOC中更喜欢哪种方法。我个人认为渲染道具非常适合只读操作，比如跟踪屏幕上的滚动位置或鼠标位置。我相信，对于更复杂的操作，比如我们的<code class="fe le lf lg lh b">localStorage</code>功能，HOC往往更好。</p><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi op"><img src="../Images/aced8a676f6e35c5f7a618a71ff5fd7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TLAWV1AQAnbMj9Ravbgq7A.png"/></div></div></figure><div class="li lj gp gr lk ll"><a href="https://gitconnected.com/portfolio-api" rel="noopener  ugc nofollow" target="_blank"><div class="lm ab fo"><div class="ln ab lo cl cj lp"><h2 class="bd iu gy z fp lq fr fs lr fu fw is bi translated">组合API —轻松发展您的编码事业| gitconnected</h2><div class="ls l"><h3 class="bd b gy z fp lq fr fs lr fu fw dk translated">消除在每个单独位置手动更新您的详细信息的痛苦。只需在您的中更改一次数据…</h3></div><div class="lt l"><p class="bd b dl z fp lq fr fs lr fu fw dk translated">gitconnected.com</p></div></div><div class="lu l"><div class="oq l lw lx ly lu lz ma ll"/></div></div></a></div><figure class="mk ml mm mn gt mo gh gi paragraph-image"><div role="button" tabindex="0" class="mp mq di mr bf ms"><div class="gh gi op"><img src="../Images/aced8a676f6e35c5f7a618a71ff5fd7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TLAWV1AQAnbMj9Ravbgq7A.png"/></div></div></figure></div><div class="ab cl ot ou hx ov" role="separator"><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy"/></div><div class="im in io ip iq"><p id="7dd6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="me">如果您觉得本文有帮助，请点击👏。</em> <a class="ae mi" href="https://medium.com/@treyhuffine" rel="noopener"> <em class="me">关注我</em> </a> <em class="me">获取更多关于区块链、React、JavaScript和开源软件的文章！你也可以在</em><a class="ae mi" href="https://twitter.com/treyhuffine" rel="noopener ugc nofollow" target="_blank"><em class="me">Twitter</em></a><em class="me">或者</em><a class="ae mi" href="https://gitconnected.com/treyhuffine" rel="noopener ugc nofollow" target="_blank"><em class="me">git connected</em></a><em class="me">上找到我。</em></p></div></div>    
</body>
</html>