<html>
<head>
<title>Learning Python: Classes and Methods</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习Python:类和方法</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/learning-python-classes-and-methods-ad67f8273ad0?source=collection_archive---------15-----------------------#2020-12-02">https://levelup.gitconnected.com/learning-python-classes-and-methods-ad67f8273ad0?source=collection_archive---------15-----------------------#2020-12-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/cc36ff161d2a9c2af4a7e8b7389b1364.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HSGoOibvzN2VYrwX"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@cdr6934?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">克里斯里德</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="d29f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我的上一篇文章中，我通过演示如何创建类对象介绍了Python类。我展示了如何在对象实例化后向对象添加属性，但是我没有演示如何在类定义中嵌入函数(在类中定义时称为方法)。在本文中，我将演示如何定义和使用类对象的方法。</p><p id="f679" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我描述如何创建Python类方法之前，让我花一点时间来谈谈为什么类方法很重要。类的方法组成了类的接口，这是程序与类交互的方式。通过为一个类定义一组方法，你决定了一个类如何被使用，因为让一个对象做任何事情的唯一方法是通过你定义的方法。</p><p id="89b3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您应该仔细定义一个类接口，只包含那些正确使用该类所必需的方法。类方法也可以作为类属性的入口。通过定义访问类属性的方法，可以控制外部代码如何影响属性。</p><p id="4c74" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我之前用过的例子是一个人的年龄。大多数人活不到85岁左右。然而，存储Python数字的变量可以保存比这个数字大得多和小得多的值(想想负值)。一个好的类接口设计应该包括一些检查方法，以确保为类属性输入了有效的数据。</p><h1 id="74f3" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">定义类方法</h1><p id="6342" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">首先，我们需要定义一个类。让我们使用日期对象。下面是一个<code class="fe mh mi mj mk b">Date</code>对象定义的开始:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="cb12" class="mt lf it mk b gy mu mv l mw mx">class Date:<br/>"""Date object"""</span><span id="219a" class="mt lf it mk b gy my mv l mw mx">d1 = Date()<br/>d1.month = 11<br/>d1.day = 16<br/>d1.year = 2020</span></pre><p id="700a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们想打印日期，我们可以编写一个函数，它接受一个<code class="fe mh mi mj mk b">Date</code>对象并显示存储在该对象中的日期:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="7cd4" class="mt lf it mk b gy mu mv l mw mx">def printDate(dt):<br/>  print("%2d/%2d/%4d" % (dt.month, dt.day, dt.year))</span></pre><p id="8491" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们在上面的程序末尾调用这个函数:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="a3ff" class="mt lf it mk b gy mu mv l mw mx">printDate(d1)</span></pre><p id="3908" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">输出是:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="31cd" class="mt lf it mk b gy mu mv l mw mx">11/16/2020</span></pre><p id="8ed1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">像这样定义函数的问题是我们违反了面向对象编程的原则之一— <em class="mz">封装</em>。封装指的是将数据与对该数据进行操作的功能(方法)捆绑在一起。</p><p id="9b86" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们封装数据和方法时，我们帮助确保从一个对象调用的方法将以正确的方式与该对象的数据一起工作。我们还可以使用类方法来确保我们分配给对象的数据是合法有效的。</p><p id="f63e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里举个例子会有帮助。假设我们有一个人对象。一个人有一个年龄。现在大多数人至少活到70或80岁，但是很少有人活到100岁以上。然而，当年龄被分配给一个人对象时，它可以是任何合法的Python数字。这意味着我们可以指定一个很大的数字作为年龄，比如1，582，483，或者我们可以指定一个很小的数字作为年龄，比如-212。</p><p id="ac98" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，当我们定义一种为一个人分配年龄的方法时，我们可以控制为年龄属性分配什么值。我将很快演示它如何处理日期对象。</p><p id="046b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在回到通过创建一个类方法来打印日期。要创建一个类方法，只需将定义放在类定义中，就像这样:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="4dde" class="mt lf it mk b gy mu mv l mw mx">class Date:</span><span id="9b34" class="mt lf it mk b gy my mv l mw mx">  def printDate(self):<br/>    print("%2d/%2d/%4d" % self.month, self.day, self.year))</span></pre><p id="8b78" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们可以使用点操作符直接从一个<code class="fe mh mi mj mk b"> Date</code>对象调用该方法。下面是一个演示如何做到这一点的程序(我再次包含了类定义):</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="2ccf" class="mt lf it mk b gy mu mv l mw mx">class Date:</span><span id="c80b" class="mt lf it mk b gy my mv l mw mx">  def printDate():<br/>    print("%2d/%2d/%4d" % (self.month, self.day, self.year))</span><span id="393a" class="mt lf it mk b gy my mv l mw mx">tomorrow = Date()<br/>tomorrow.month = 11<br/>tomorrow.day = 17<br/>tomorrow.year = 2020<br/>tomorrow.printDate()</span></pre><p id="63c9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个程序的输出是:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="69c1" class="mt lf it mk b gy mu mv l mw mx">11/17/2020</span></pre><p id="f9d2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">显然，我需要解释关键字<code class="fe mh mi mj mk b">self</code>在这个定义中的作用。类定义需要一种方法来引用代码正在处理的当前对象。你甚至可以说程序的焦点是当前的对象。<code class="fe mh mi mj mk b">self</code>关键字提供了这种参考。</p><p id="7cbe" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如您所见，每当我们编写一个使用当前对象数据的方法时，<code class="fe mh mi mj mk b">self</code>就变成了参数，因为我们需要一种使用点运算符来检索数据的方法。</p><h1 id="5f77" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">其他类方法</h1><p id="756c" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">打印对象属性值的方法很重要，但是一个类可能还需要许多其他方法。例如，<code class="fe mh mi mj mk b">Date</code>类可能需要一个方法，让你将日期增加一天或其他单位。</p><p id="e87a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个新的<code class="fe mh mi mj mk b">Date</code>类定义，它包括一个<code class="fe mh mi mj mk b">increment</code>方法，以及一个测试该方法的程序:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="de6f" class="mt lf it mk b gy mu mv l mw mx">class Date:</span><span id="804b" class="mt lf it mk b gy my mv l mw mx">  def printDate(self):<br/>    print("%2d/%2d/%4d" % (self.month, self.day, self.year))<br/>  <br/>  def increment(self, unit):<br/>    """increment the date by a day or more"""<br/>    self.day = self.day + unit</span><span id="9b79" class="mt lf it mk b gy my mv l mw mx">d1 = Date()<br/>d1.month = 11<br/>d1.day = 16<br/>d1.year = 2020<br/>d1.printDate()<br/>d1.increment(1)<br/>d1.printDate()<br/>d1.increment(3)<br/>d1.printDate()</span></pre><p id="1fc5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个程序的输出是:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="37ca" class="mt lf it mk b gy mu mv l mw mx">11/16/2020<br/>11/17/2020<br/>11/20/2020</span></pre><p id="9af8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所有面向对象的编程语言都包含一个特殊的方法，用于在实例化一个新对象时初始化它。这个方法被称为<em class="mz">构造函数</em>。在大多数语言中，构造函数方法与类同名，但是在Python中，构造函数方法被命名为:<code class="fe mh mi mj mk b"> __init__</code>。</p><p id="6bbd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">方法用来初始化一个类的属性。许多编程语言的构造函数允许您为多个构造函数编写定义，以便可以用不同的方式初始化属性。例如，<code class="fe mh mi mj mk b">Date</code>对象可以用月、日和年来初始化，但也可以只用月和年来初始化，甚至只用月和日来初始化。一个<code class="fe mh mi mj mk b">Date</code>也可以不用数据初始化，参数的默认值被赋给属性。</p><p id="614c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是，在Python中，您用默认参数定义了<code class="fe mh mi mj mk b">__init__</code>方法。下面是我们的<code class="fe mh mi mj mk b">Date</code>类的<code class="fe mh mi mj mk b">__init__</code>方法定义:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="ec2f" class="mt lf it mk b gy mu mv l mw mx">class Date:<br/>  <br/>  def __init__(self, month=0,day=0,year=0):<br/>    self.month = month<br/>    self.day = day<br/>    self.year = year</span><span id="b181" class="mt lf it mk b gy my mv l mw mx">  # rest of Date definition</span></pre><p id="232b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一些用我们新的<code class="fe mh mi mj mk b">__init__</code>方法实例化不同的<code class="fe mh mi mj mk b">Date</code>对象的例子:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="605a" class="mt lf it mk b gy mu mv l mw mx">d1 = Date(11,17,2020)<br/>d1.printDate()<br/>d2 = Date(11,17)<br/>d2.printDate()<br/>d3 = Date()<br/>d3.printDate()</span></pre><p id="e544" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这段代码的输出是:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="f2d1" class="mt lf it mk b gy mu mv l mw mx">11/17/2020<br/>11/17/2020<br/>0/ 0/2020</span></pre><h1 id="3c6a" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">使用__str__显示对象状态</h1><p id="1bc4" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">在面向对象编程中，引用一个对象的<em class="mz">状态</em>就是引用在任何给定时间存储在该对象所有属性中的值。很多时候你都想看到一个对象的状态，尤其是在调试期间。Python提供了显示状态的特殊对象方法:<code class="fe mh mi mj mk b">__str__</code>方法。对于熟悉Java的人来说，<code class="fe mh mi mj mk b">__str__</code>类似于<code class="fe mh mi mj mk b">to_strin</code> g Java方法。</p><p id="b9e1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个<code class="fe mh mi mj mk b">_str__</code>方法如何寻找<code class="fe mh mi mj mk b">Date</code>类:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="ac1f" class="mt lf it mk b gy mu mv l mw mx">def __str__(self):<br/>  return "%2d/%2d/%4d" % (self.month, self.day, self.year)</span></pre><p id="6e41" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">__str__</code>定义类似于<code class="fe mh mi mj mk b">printDate</code>方法，但是它没有调用<code class="fe mh mi mj mk b">print</code>函数，而是以与<code class="fe mh mi mj mk b">printDat</code> e方法相同的格式返回当前日期。</p><p id="1d20" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">__str__</code>的一个很好的特性是，您可以通过简单地引用对象来调用它，而不必直接调用方法。我的意思是:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="531a" class="mt lf it mk b gy mu mv l mw mx">d1 = Date(11,17,2020)<br/>print(d1)</span></pre><p id="5d72" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">哪些输出:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="d10d" class="mt lf it mk b gy mu mv l mw mx">11/17/2020</span></pre><p id="626a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我前面提到的，大多数情况下__str__方法都是用于调试。您应该编写一个单独的方法来显示可调用的对象属性。</p><h1 id="1192" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">Python中的重载运算符</h1><p id="95fb" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">当你重新定义一个操作符的工作方式时，这被称为<em class="mz">操作符重载</em>。Python允许重载它的许多操作符。您可以在<a class="ae kf" href="https://docs.python.org/3/reference/datamodel.html#emulating-numeric-types" rel="noopener ugc nofollow" target="_blank">这里</a>找到您可以重载的操作符的完整列表。文档称之为仿真而不是重载。</p><p id="0a8b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">运算符重载很重要，因为在处理类对象时使用标准Python运算符比调用方法更好。例如，假设我正在处理一个计数的类，我有两个对象想加在一起。下面两行哪一行看起来比较好用？</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="faa7" class="mt lf it mk b gy mu mv l mw mx">totalCounters = counter1 + counter2<br/>totalCounters = counter1.add(counter2)</span></pre><p id="6b1f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第一行更直观。</p><p id="dd35" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们看看如何通过实现我刚刚描述的<code class="fe mh mi mj mk b">Counter</code>类来重载+运算符。下面是该类的代码以及一个简单的测试程序:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="ba13" class="mt lf it mk b gy mu mv l mw mx">class Counter:<br/>  def __init__(self):<br/>    self.count = 0</span><span id="5729" class="mt lf it mk b gy my mv l mw mx">  def increment(self):<br/>    self.count = self.count + 1</span><span id="e49e" class="mt lf it mk b gy my mv l mw mx">  def __str__(self):<br/>    return str(self.count)</span><span id="2fa0" class="mt lf it mk b gy my mv l mw mx">laps = Counter()<br/>for i in range(1,6):<br/>  laps.increment()<br/>print("Laps run by laps:",laps)<br/>moreLaps = Counter()<br/>for i in range(1,4):<br/>  moreLaps.increment()<br/>print("Laps run by moreLaps:",moreLaps)</span></pre><p id="7426" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个程序的输出是:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="8850" class="mt lf it mk b gy mu mv l mw mx">Laps run: 5<br/>Laps run by moreLaps: 3</span></pre><p id="1041" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在让我们看看如何重载<code class="fe mh mi mj mk b">+</code>操作符。为此，我们在<code class="fe mh mi mj mk b">Counter</code>类定义中为<code class="fe mh mi mj mk b"> __add__</code>编写了一个新的定义，告诉Python当两个<code class="fe mh mi mj mk b">Counter</code>对象与<code class="fe mh mi mj mk b">+</code>操作符组合在一起时该做什么。下面是放置在类定义中的<code class="fe mh mi mj mk b">__add__</code>的代码:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="4f37" class="mt lf it mk b gy mu mv l mw mx">def __add__(self, cntr):<br/>  return self.count + cntr.count</span></pre><p id="6181" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">self</code>参数用于操作符左侧的<code class="fe mh mi mj mk b">Counter</code>对象，cntr参数用于操作符右侧的<code class="fe mh mi mj mk b">Counter</code>对象。为两个参数调用<code class="fe mh mi mj mk b">count</code>属性，将它们相加，并返回结果。</p><p id="97bd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个测试程序和输出:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="e7fd" class="mt lf it mk b gy mu mv l mw mx">laps = Counter()<br/>for i in range(1,6):<br/>  laps.increment()<br/>print("Laps run by laps:",laps)<br/>moreLaps = Counter()<br/>for i in range(1,4):<br/>  moreLaps.increment()<br/>print("Laps run by moreLaps:",moreLaps)<br/>totalLaps = laps + moreLaps<br/>print("Total laps run:", totalLaps)</span><span id="131e" class="mt lf it mk b gy my mv l mw mx">Laps run by laps: 5<br/>Laps run by moreLaps: 3<br/>Total laps run: 8</span></pre><p id="532d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们再重载一个操作符:操作符<code class="fe mh mi mj mk b">==</code>。重载该操作符的代码包括使用<code class="fe mh mi mj mk b">==</code>操作符来测试存储在两个对象的<code class="fe mh mi mj mk b">count</code>属性中的值。下面是位于<code class="fe mh mi mj mk b">Counter</code>类定义中的代码:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="a244" class="mt lf it mk b gy mu mv l mw mx">def __eq__(self, cntr):<br/>  return self.count == cntr.count</span></pre><p id="dea5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个测试我们重载的<code class="fe mh mi mj mk b">==</code>操作符的程序:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="b201" class="mt lf it mk b gy mu mv l mw mx">laps = Counter()<br/>for i in range(1,6):<br/>  laps.increment()<br/>print("Laps run by laps:",laps)<br/>moreLaps = Counter()<br/>for i in range(1,6):<br/>  moreLaps.increment()<br/>print("Laps run by moreLaps:",moreLaps)<br/>if (laps == moreLaps):<br/>  print("Laps and moreLaps have the same number of laps.")<br/>else:<br/>moreLaps.increment()<br/>print("Laps run by laps:",laps)<br/>print("Laps run by moreLaps:",moreLaps)<br/>if (laps == moreLaps):<br/>  print("Laps and moreLaps have the same number of laps.")<br/>else:<br/>  print("Laps and moreLaps have a different number of laps.")</span></pre><p id="5edf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是输出:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="25b1" class="mt lf it mk b gy mu mv l mw mx">Laps run by laps: 5<br/>Laps run by moreLaps: 5<br/>Laps and moreLaps have the same number of laps.<br/>Laps run by laps: 5<br/>Laps run by moreLaps: 6<br/>Laps and moreLaps have a different number of laps.</span></pre><p id="d9f5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这就结束了我对用Python创建类的讨论。在我的下一篇文章中，我将讨论如何在Python中执行继承和多态，这极大地增强了面向对象编程的能力和实用性。</p><p id="d420" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢您的阅读，请发电子邮件至<a class="ae kf" href="mailto:mmmcmillan1@att.net" rel="noopener ugc nofollow" target="_blank">mmmcmillan1@att.net</a>告诉我您的意见和建议，或者在下面留下您的回复。</p></div></div>    
</body>
</html>