<html>
<head>
<title>Using RocksDB with Rust and Actix-Web</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Rust和Actix-Web上使用RocksDB</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/using-rocksdb-with-rust-and-actix-web-98507c9db267?source=collection_archive---------8-----------------------#2020-04-19">https://levelup.gitconnected.com/using-rocksdb-with-rust-and-actix-web-98507c9db267?source=collection_archive---------8-----------------------#2020-04-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/b83720a511045c9ac2dce7522d21bf54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8OQeNhpbozNyLRkH"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@joeriromer?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">游里·罗默</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="6c92" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了帮助我学习Rust，我决定在Rust中实现<a class="ae kc" href="https://medium.com/@ukchukx/99cb1c43a834" rel="noopener"> Java RocksDB示例</a>,因为它很简单。</p><p id="9c7d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于Rust严格的借用和生命周期概念——几乎每个人迟早都会犯错——事情没有我希望的那么简单。本来想直接存储用<a class="ae kc" href="https://crates.io/crates/bincode" rel="noopener ugc nofollow" target="_blank"> bincode </a>序列化的<code class="fe lb lc ld le b">json::value::JsonValue</code>enum。我遇到的主要错误是:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="bf62" class="ln lo iq le b gy lp lq l lr ls">the trait `serde::ser::Serialize` is not implemented for `json::value::JsonValue`<br/>...<br/>the trait `serde::de::Deserialize&lt;'_&gt;` is not implemented for `json::value::JsonValue`</span></pre><p id="768f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我确信，如果我努力的话，我本可以实现那个枚举的特征，但是鉴于这应该是一个简单的一次性例子，它很快变得超出了我的预期。我决定在存储库层处理字符串，把解序列化留给用户，因为我很懒。\_(ツ)_/</p><p id="1a2c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们只需要json、actix-web、bytes(读取POST主体)和rocksdb作为依赖项:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="f2fe" class="ln lo iq le b gy lp lq l lr ls">[dependencies]<br/>actix-rt = "1.0"<br/>actix-web = "2.0"<br/>bytes = "0.5.2"<br/>env_logger = "0.7.1"<br/>json = "0.12"<br/>rocksdb = "0.13.0"</span></pre><p id="04d7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们创建我们的存储库模块<code class="fe lb lc ld le b">src/kv.rs</code>:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="a2d5" class="ln lo iq le b gy lp lq l lr ls">// src/kv.rs<br/>use rocksdb::DB;<br/>use std::sync::Arc;</span><span id="1eb9" class="ln lo iq le b gy lt lq l lr ls">pub trait KVStore {<br/>    fn init(file_path: &amp;str) -&gt; Self;<br/>    fn save(&amp;self, k: &amp;str, v: &amp;str) -&gt; bool;<br/>    fn find(&amp;self, k: &amp;str) -&gt; Option&lt;String&gt;;<br/>    fn delete(&amp;self, k: &amp;str) -&gt; bool;<br/>}</span><span id="4571" class="ln lo iq le b gy lt lq l lr ls">#[derive(Clone)]<br/>pub struct RocksDB {<br/>    db: Arc&lt;DB&gt;,<br/>}<br/></span><span id="ed73" class="ln lo iq le b gy lt lq l lr ls">impl KVStore for RocksDB {<br/>    fn init(file_path: &amp;str) -&gt; Self {<br/>        RocksDB { db: Arc::new(DB::open_default(file_path).unwrap()) }<br/>    }</span><span id="f168" class="ln lo iq le b gy lt lq l lr ls">    fn save(&amp;self, k: &amp;str, v: &amp;str) -&gt; bool {<br/>        self.db.put(k.as_bytes(), v.as_bytes()).is_ok()<br/>    }</span><span id="446d" class="ln lo iq le b gy lt lq l lr ls">    fn find(&amp;self, k: &amp;str) -&gt; Option&lt;String&gt; {<br/>        match self.db.get(k.as_bytes()) {<br/>            Ok(Some(v)) =&gt; {<br/>                let result = String::from_utf8(v).unwrap();<br/>                println!("Finding '{}' returns '{}'", k, result);<br/>                Some(result)<br/>            },<br/>            Ok(None) =&gt; {<br/>                println!("Finding '{}' returns None", k);<br/>                None<br/>            },<br/>            Err(e) =&gt; {<br/>                println!("Error retrieving value for {}: {}", k, e);<br/>                None<br/>            }<br/>        }<br/>    }</span><span id="e610" class="ln lo iq le b gy lt lq l lr ls">    fn delete(&amp;self, k: &amp;str) -&gt; bool {<br/>        self.db.delete(k.as_bytes()).is_ok()<br/>    }<br/>}</span></pre><p id="f23e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们声明我们的键值存储库接口(或者Rust中的特征)<code class="fe lb lc ld le b">KVStore</code>。<code class="fe lb lc ld le b">RocksDB</code>结构用于保存我们将要使用的打开的数据库。我们将<code class="fe lb lc ld le b">DB</code>包装在<code class="fe lb lc ld le b">Arc</code>中，这样它就可以跨线程安全地共享。我们希望Actix-web在路由处理程序被调用时将我们的数据库句柄传递给它们，但是<code class="fe lb lc ld le b">DB</code>没有实现<code class="fe lb lc ld le b">Clone</code>，所以必须包装在<code class="fe lb lc ld le b">Arc</code>中才能工作。</p><p id="0fd9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们继续为RocksDB实现我们的trait(或接口)。RocksDB只处理字节，所以我们必须将字符串键和值转换为字节。</p><p id="bda3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们将编写我们的路由处理器模块<code class="fe lb lc ld le b">src/kv_handler.rs</code>:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="1f2c" class="ln lo iq le b gy lp lq l lr ls">// src/kv_handler.rs<br/>use actix_web::{web::{Data, Path}, HttpResponse};<br/>use bytes::Bytes;<br/>use json::parse;</span><span id="c508" class="ln lo iq le b gy lt lq l lr ls">use crate::kv::{KVStore, RocksDB};</span><span id="5873" class="ln lo iq le b gy lt lq l lr ls">// curl -i -X GET -H "Content-Type: application/json" http://localhost:8080/api/foo<br/>pub async fn get(key: Path&lt;String&gt;, db: Data&lt;RocksDB&gt;) -&gt; HttpResponse {<br/>    match &amp;db.find(&amp;key.into_inner()) {<br/>        Some(v) =&gt; {<br/>            parse(v)<br/>                .map(|obj| HttpResponse::Ok().content_type("application/json").body(obj.dump()))<br/>                .unwrap_or(HttpResponse::InternalServerError().content_type("application/json").finish())<br/>        }<br/>        None    =&gt; HttpResponse::NotFound().content_type("application/json").finish()<br/>    }<br/>}</span><span id="f503" class="ln lo iq le b gy lt lq l lr ls">// curl -i -X POST -H "Content-Type: application/json" -d '{"bar":"baz"}' http://localhost:8080/api/foo<br/>pub async fn post(key:  Path&lt;String&gt;,<br/>                  db:   Data&lt;RocksDB&gt;,<br/>                  body: Bytes) -&gt; HttpResponse {<br/>    match String::from_utf8(body.to_vec()) {<br/>        Ok(body) =&gt; match &amp;db.save(&amp;key.into_inner(), &amp;body) {<br/>            true  =&gt; {<br/>                parse(&amp;body)<br/>                    .map(|obj| HttpResponse::Ok().content_type("application/json").body(obj.dump()))<br/>                    .unwrap_or(HttpResponse::InternalServerError().content_type("application/json").finish())<br/>            }<br/>            false =&gt; HttpResponse::InternalServerError().content_type("application/json").finish()<br/>        }<br/>        Err(_) =&gt; HttpResponse::InternalServerError().content_type("application/json").finish(),<br/>    }<br/>}</span><span id="daf7" class="ln lo iq le b gy lt lq l lr ls">// curl -i -X DELETE -H "Content-Type: application/json" http://localhost:8080/api/foo<br/>pub async fn delete(key: Path&lt;String&gt;, db: Data&lt;RocksDB&gt;) -&gt; HttpResponse {<br/>    match &amp;db.delete(&amp;key.into_inner()) {<br/>        true  =&gt; HttpResponse::NoContent().content_type("application/json").finish(),<br/>        false =&gt; HttpResponse::InternalServerError().content_type("application/json").finish()<br/>    }<br/>}</span></pre><p id="35e9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每条路由都带有<code class="fe lb lc ld le b">key</code>路径参数和我们之前打开的数据库句柄的句柄。</p><p id="e4fe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们收到GET请求时，我们用提供的<code class="fe lb lc ld le b">key</code>查询RocksDB。如果返回一个值，我们将其解析为JSON并返回。如果一无所获，我们返回404。</p><p id="4794" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们收到POST请求时，我们将提供的主体转换为字符串并存储在RocksDB中。然后，我们将主体解析为JSON，并作为响应发送回来。</p><p id="6a80" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于删除请求，如果能够删除键值对，我们返回204，否则返回500。</p><p id="9815" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">剩下的工作就是初始化我们的数据库并注册我们的路由处理程序。让我们在<code class="fe lb lc ld le b">src/main.rs</code>中处理它:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="4bed" class="ln lo iq le b gy lp lq l lr ls">// src/main.rs<br/>mod kv;<br/>mod kv_handler;<br/></span><span id="d47c" class="ln lo iq le b gy lt lq l lr ls">#[actix_rt::main]<br/>async fn main() -&gt; std::io::Result&lt;()&gt; {<br/>    use actix_web::{<br/>        middleware::Logger,<br/>        web::{scope, resource, get, post, delete},<br/>        App,<br/>        HttpServer<br/>    };</span><span id="dba9" class="ln lo iq le b gy lt lq l lr ls">    let db: kv::RocksDB = kv::KVStore::init("/tmp/rocks/actix-db");</span><span id="5917" class="ln lo iq le b gy lt lq l lr ls">    std::env::set_var("RUST_LOG", "actix_web=info,actix_server=info");<br/>    env_logger::init();</span><span id="a513" class="ln lo iq le b gy lt lq l lr ls">    HttpServer::new(move || {<br/>        App::new()<br/>            .data(db.clone())<br/>            .wrap(Logger::default())<br/>            .service(<br/>                scope("/api")<br/>                .service(<br/>                    resource("/{key}")<br/>                        .route(get().to(kv_handler::get))<br/>                        .route(post().to(kv_handler::post))<br/>                        .route(delete().to(kv_handler::delete)),<br/>                ),<br/>            )<br/>    })<br/>    .bind("0.0.0.0:8080")?<br/>    .run()<br/>    .await<br/>}</span></pre><p id="8416" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">源代码可以在<a class="ae kc" href="https://github.com/ukchukx/rocksdb-rust" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p></div></div>    
</body>
</html>