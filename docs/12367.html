<html>
<head>
<title>Design Patterns in Python: Adapter Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的设计模式:适配器模式</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/design-patterns-in-python-adapter-pattern-a5e53ed2c85d?source=collection_archive---------8-----------------------#2022-06-05">https://levelup.gitconnected.com/design-patterns-in-python-adapter-pattern-a5e53ed2c85d?source=collection_archive---------8-----------------------#2022-06-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="44cf" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">适配器设计模式在Python中的实现</h2></div><p id="cae2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它是一种结构设计模式，相当于其名称的电子等价物。在这方面，它有一个成功的命名，其目的是可以理解的(也叫<em class="lb"> wrapper </em>)。如果你还记得的话，结构设计模式与不同的类一起工作有关。适配器设计模式还确保不兼容的接口可以互操作。它将一个类的接口转换为另一个类期望的接口。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi lc"><img src="../Images/271d2578b84425ba3cd2e3ac481afd4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QR5qpgHazuUrfiZv5yN4rA.jpeg"/></div></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk translated">照片由<a class="ae ls" href="https://unsplash.com/@callmefred?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">在<a class="ae ls" href="https://unsplash.com/s/photos/adapter?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上叫我弗雷德</a></figcaption></figure><p id="6310" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">《越狱》前情提要:</p><div class="lt lu gp gr lv lw"><a href="https://medium.com/@okanyenigun/design-patterns-in-python-flyweight-pattern-ec3d321a86af" rel="noopener follow" target="_blank"><div class="lx ab fo"><div class="ly ab lz cl cj ma"><h2 class="bd ir gy z fp mb fr fs mc fu fw ip bi translated">Python中的设计模式:Flyweight模式</h2><div class="md l"><h3 class="bd b gy z fp mb fr fs mc fu fw dk translated">Flyweight设计模式在Python中的实现</h3></div><div class="me l"><p class="bd b dl z fp mb fr fs mc fu fw dk translated">medium.com</p></div></div><div class="mf l"><div class="mg l mh mi mj mf mk lm lw"/></div></div></a></div><p id="ee54" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">先说经典的例子。我们在一家国际公司做销售。我们的工作需要我们经常出差。许多国家使用不同类型的插座。因此，在我们去的国家，我们可能很难将电子设备插入插座。我们能做的是:</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi ml"><img src="../Images/a092f99343e566179dc289ba3fffa461.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YRNU1vCT_KmP0q5WhqK2EQ.png"/></div></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk translated">插头类型:来源:<a class="ae ls" href="https://www.flypgs.com/blog/ulkelere-gore-fis-ve-priz-rehberi/" rel="noopener ugc nofollow" target="_blank">飞马</a></figcaption></figure><p id="5248" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第一种选择可能是把所有的类型都带上。这里的结构是系统中的if-else条件语句。我们根据目的地国家选择必要的一个。这里的问题是，这种结构违背了开闭原则(OCP)。每个新的国家都需要一个新的条件。</p><div class="lt lu gp gr lv lw"><a href="https://towardsdev.com/solid-principles-explained-635ad3608b20" rel="noopener  ugc nofollow" target="_blank"><div class="lx ab fo"><div class="ly ab lz cl cj ma"><h2 class="bd ir gy z fp mb fr fs mc fu fw ip bi translated">解释了坚实的原则</h2><div class="md l"><h3 class="bd b gy z fp mb fr fs mc fu fw dk translated">用Python语言举例说明坚实的原理</h3></div><div class="me l"><p class="bd b dl z fp mb fr fs mc fu fw dk translated">towardsdev.com</p></div></div><div class="mf l"><div class="mm l mh mi mj mf mk lm lw"/></div></div></a></div><p id="32a5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">作为另一种解决方案，我们为每种类型的套接字对象创建子类，并覆盖它的方法。在这种情况下，子类的数量呈爆炸式增长。实际上，在这样的解决方案中，适配器嵌入在对象内部。除了自己的功能之外，对象还必须承担适配器的任务。这违反了单一责任原则。这仍然比第一个解决方案好，但不是理想的解决方案。</p><p id="22ce" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">根据SRP，我们必须在别处定义适配器任务。这是一项单独的责任。我们将有一个单独的类来解决兼容性问题。这个类将使一个不兼容的对象与另一个不兼容的接口互操作。</p><p id="0c88" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于适配器设计模式，不兼容的对象获得了一个新的接口，适配器成为不兼容对象的包装器。也可以设计适配器来适应所有接口。但是在这种情况下，适配器对象本身将变得非常复杂。因此，在实践中，如果每个适配器都解决一个兼容性问题(双向的)会更好。</p><h1 id="ad92" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">履行</h1><p id="1ede" class="pw-post-body-paragraph kf kg iq kh b ki nf jr kk kl ng ju kn ko nh kq kr ks ni ku kv kw nj ky kz la ij bi translated">在这个模式结构中，我们有4个组件。</p><ul class=""><li id="9687" class="nk nl iq kh b ki kj kl km ko nm ks nn kw no la np nq nr ns bi translated"><strong class="kh ir">目标</strong>:客户端请求的特定于域的接口。</li><li id="5236" class="nk nl iq kh b ki nt kl nu ko nv ks nw kw nx la np nq nr ns bi translated"><strong class="kh ir">客户端</strong>:应用业务逻辑，与目标协作。</li><li id="43d4" class="nk nl iq kh b ki nt kl nu ko nv ks nw kw nx la np nq nr ns bi translated"><strong class="kh ir">适配器</strong>:与目标不兼容的接口。需要适配器。</li><li id="c686" class="nk nl iq kh b ki nt kl nu ko nv ks nw kw nx la np nq nr ns bi translated"><strong class="kh ir">适配器</strong>:适配器与目标之间的兼容对象。</li></ul><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi ny"><img src="../Images/53b420f30b63a5873f3eb1c7bd4ba931.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VSgxMlX8-oXp6J_APSlN0w.jpeg"/></div></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk translated">来源:<a class="ae ls" href="https://www.geeksforgeeks.org/adapter-pattern/" rel="noopener ugc nofollow" target="_blank"> geeksforgeeks </a></figcaption></figure><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/d3f50be71f8f0c64a8536a44ca2cf5aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1026/format:webp/1*kOL3RbLaU03-Za99cKjEPw.png"/></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk translated">UML类图的例子。图片由作者提供。</figcaption></figure><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="oa ob l"/></div></figure><pre class="ld le lf lg gt oc od oe of aw og bi"><span id="6bca" class="oh mo iq od b gy oi oj l ok ol">my_plug = UkPlug()<br/>my_plug.electricity_220v()</span><span id="b563" class="oh mo iq od b gy om oj l ok ol">#220 Volt</span><span id="e3af" class="oh mo iq od b gy om oj l ok ol">my_plug = UktoUsAdapter()<br/>my_plug.electricity_220v()</span><span id="2b11" class="oh mo iq od b gy om oj l ok ol">#110 Volt</span></pre><p id="41c5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们通过使用适配器设计模式应用了SRP和OCP原则。我们的插座和插头对象有一个更简单的结构，因为他们只是忙于自己的工作。同样，适配器也完成了它的工作。我们让不同的界面协同工作。</p><p id="3326" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">感谢阅读。如果您有任何问题或意见，请随时写信给我！</p><h1 id="4bfa" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">下一章</h1><div class="lt lu gp gr lv lw"><a href="https://medium.com/@okanyenigun/design-patterns-in-python-composite-pattern-2fa89a026564" rel="noopener follow" target="_blank"><div class="lx ab fo"><div class="ly ab lz cl cj ma"><h2 class="bd ir gy z fp mb fr fs mc fu fw ip bi translated">Python中的设计模式:复合模式</h2><div class="md l"><h3 class="bd b gy z fp mb fr fs mc fu fw dk translated">Python语言中复合设计模式的实现</h3></div><div class="me l"><p class="bd b dl z fp mb fr fs mc fu fw dk translated">medium.com</p></div></div><div class="mf l"><div class="on l mh mi mj mf mk lm lw"/></div></div></a></div><h1 id="970f" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">阅读更多内容…</h1><div class="lt lu gp gr lv lw"><a href="https://python.plainenglish.io/data-classes-abstraction-interfaces-in-python-ea107d235d3e" rel="noopener  ugc nofollow" target="_blank"><div class="lx ab fo"><div class="ly ab lz cl cj ma"><h2 class="bd ir gy z fp mb fr fs mc fu fw ip bi translated">Python中的数据类、抽象和接口</h2><div class="md l"><h3 class="bd b gy z fp mb fr fs mc fu fw dk translated">Python中的抽象、接口和其他类概念</h3></div><div class="me l"><p class="bd b dl z fp mb fr fs mc fu fw dk translated">python .平原英语. io</p></div></div><div class="mf l"><div class="oo l mh mi mj mf mk lm lw"/></div></div></a></div><h1 id="55bd" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">参考</h1><p id="8002" class="pw-post-body-paragraph kf kg iq kh b ki nf jr kk kl ng ju kn ko nh kq kr ks ni ku kv kw nj ky kz la ij bi translated"><a class="ae ls" href="https://www.geeksforgeeks.org/adapter-method-python-design-patterns/" rel="noopener ugc nofollow" target="_blank">https://www . geeks forgeeks . org/adapter-method-python-design-patterns/</a></p></div></div>    
</body>
</html>