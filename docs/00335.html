<html>
<head>
<title>Functional and Reactive Programming in Python with Cyclotron</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用回旋加速器在Python中进行函数式和反应式编程</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/functional-and-reactive-programming-in-python-with-cyclotron-1b57fff4c643?source=collection_archive---------2-----------------------#2019-01-14">https://levelup.gitconnected.com/functional-and-reactive-programming-in-python-with-cyclotron-1b57fff4c643?source=collection_archive---------2-----------------------#2019-01-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/85b254e3432686d230dede1c42157b29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S9FlI1V4uVtUPrDhY1M6wg.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://unsplash.com/@spacexuan?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">郭锦恩</a>在<a class="ae kc" href="https://unsplash.com/@spacexuan?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><p id="8f8e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">反应式编程对于编写事件驱动的应用程序、数据驱动的应用程序和异步应用程序非常有用。然而，很难找到一种好的方法来组织代码。对JavaScript开发者来说幸运的是，有<a class="ae kc" href="https://cycle.js.org" rel="noopener ugc nofollow" target="_blank"> CycleJs </a>。于是我为Python和<a class="ae kc" href="https://github.com/reactivex/rxpy" rel="noopener ugc nofollow" target="_blank"> RxPY </a> : <a class="ae kc" href="https://github.com/mainro/cyclotron-py" rel="noopener ugc nofollow" target="_blank">回旋</a>开发了一个类似的框架。</p><p id="d5d6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">编辑2020/10:更新了RxPY v3和回旋加速器驱动器列表的示例。</em></p><p id="98aa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">回旋加速器是一个功能和反应框架。它允许以函数的方式构建反应式代码。更具体地说，功能意味着以下内容:</p><ul class=""><li id="46bd" class="lc ld iq kf b kg kh kk kl ko le ks lf kw lg la lh li lj lk bi translated">纯代码和副作用是明确分开的</li><li id="b426" class="lc ld iq kf b kg ll kk lm ko ln ks lo kw lp la lh li lj lk bi translated">所有代码都是通过函数实现的(没有类)</li></ul><p id="6002" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，它专门用于编写反应式代码:</p><ul class=""><li id="5f63" class="lc ld iq kf b kg kh kk kl ko le ks lf kw lg la lh li lj lk bi translated">所有组件都通过观察器进行通信</li><li id="2083" class="lc ld iq kf b kg ll kk lm ko ln ks lo kw lp la lh li lj lk bi translated">可观察到的循环是自然处理的</li></ul><p id="8b52" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下图显示了回旋加速器应用的结构:</p><figure class="lr ls lt lu gt jr gh gi paragraph-image"><div class="gh gi lq"><img src="../Images/577419beee90263985af8a4b71e8828f.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*Ko1eMUasJiqXKsmcKYfCeg.png"/></div></figure><p id="3e41" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">回旋加速器的应用有两部分:纯数据流和副作用。纯数据流由纯函数组成。纯函数是行为具有确定性的函数。这意味着它们的输出只取决于它们的输入参数。纯数据流部分是实现应用程序逻辑的地方。</p><p id="38dc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">副作用是任何不是纯函数的函数。例如，一个不接受参数作为输入并返回当前日期的函数就是一个副作用。此外，任何作用于IO的函数都是副作用，因为它的结果依赖于底层IO。</p><p id="a06e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">纯数据流和副作用通过可观察的方式相互交流。按照惯例，纯数据流的输出(也是副作用的输入)被称为汇。纯数据流订阅的输入可观测值(也是副作用的输出)被称为源。</p><p id="0957" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意纯数据流和副作用是如何形成有向循环图的:它们相互依赖。管理这种可观察到的周期并不总是容易的。回旋加速器自然地处理纯数据流和副作用之间的这种循环:一个自举函数循环连接纯入口点和副作用。</p><p id="b47e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们看一个示例应用程序。一个hello world，由一个异步http服务器组成，它发送回在“/echo”URL上接收到的内容。这个echo服务器使用AsyncIO来异步管理IO操作。该应用的设计如以下反应性图所示:</p><figure class="lr ls lt lu gt jr gh gi paragraph-image"><div class="gh gi lq"><img src="../Images/d99dca5b0a41593b1b383cf12ea8cdd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*4FBEVOdixnmUM12axu7kjg.png"/></div></figure><p id="bd3a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">反应图使用UML活动图的表示，但是有不同的含义。活动图代表一个代码流，每个链接代表一个对函数或方法的调用。反应图代表一个数据流，每个链接代表一个可观察量。所以被描述的每一个动作都被可观察物所发出的每一个项目所调用。</p><p id="631d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个例子中，http服务器是一个副作用，用右上角弯曲的矩形表示。运算符或操作表示为圆角矩形。在这个例子中，从http服务器接收的每个请求都被映射到一个响应。粗水平线表示合并操作符。注意，这个非常简单的例子已经包含了一个可观察到的循环。不，让我们看看实现。</p><p id="a04f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们首先需要一些进口品:</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="c528" class="ma mb iq lw b gy mc md l me mf">from collections import namedtuple                                               from cyclotron import Component                       <br/>from cyclotron.asyncio.runner import run                       import cyclotron_aiohttp.httpd as httpd<br/>import rx<br/>import rx.operators as ops</span></pre><p id="b441" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">回旋加速器大量使用命名的双联管。使用命名元组有几个好处:</p><ul class=""><li id="2a73" class="lc ld iq kf b kg kh kk kl ko le ks lf kw lg la lh li lj lk bi translated">它们的字段可以从它们的名称直接访问。所以这个语法没有使用字典那么冗长:一个<em class="lb"> foo </em>字段被访问为<em class="lb"> a.foo </em>而不是<em class="lb"> a['foo'] </em>。</li><li id="0d7f" class="lc ld iq kf b kg ll kk lm ko ln ks lo kw lp la lh li lj lk bi translated">命名元组和元组一样，是不可变的。不变性是函数式编程的基础之一。这里的想法是通过namedtuple尽可能地拥抱不变性。</li></ul><p id="1fc0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后使用几个回旋加速器进口，以及来自RxPY的可观测定义。</p><p id="104a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下一步是定义应用程序使用的源、接收器和驱动程序:</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="e650" class="ma mb iq lw b gy mc md l me mf">EchoSource = namedtuple('EchoSource', ['httpd'])<br/>EchoSink = namedtuple('EchoSink', ['httpd'])<br/>EchoDrivers = namedtuple('EchoDrivers', ['httpd'])</span></pre><p id="cd16" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为这个应用程序非常简单，所以只使用了一个源、一个接收器和一个驱动程序。HTTP驱动程序需要一个源和一个接收器。有些驱动程序可能只是源(它们只发出项目)，有些驱动程序可能只是接收器(它们只消耗项目)。</p><p id="3873" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后是入口点和驱动程序的主函数和引导:</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="c495" class="ma mb iq lw b gy mc md l me mf">def main():<br/>    run(Component(call=echo_server, input=EchoSource),<br/>        EchoDrivers(httpd=httpd.make_driver()))<br/><br/><br/>if __name__ == '__main__':<br/>    main()</span></pre><p id="6b2b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">run函数将应用程序的入口点(<em class="lb"> echo_server </em>函数)与<em class="lb"> httpd </em>驱动程序连接起来。最后，这是应用程序的纯数据流:</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="88be" class="ma mb iq lw b gy mc md l me mf">def echo_server(source):<br/>    init = rx.from_([<br/>        httpd.Initialize(),<br/>        httpd.AddRoute(methods=['GET'], <br/>                       path='/echo/{what}',<br/>                       id='echo'),<br/>        httpd.StartServer(host='localhost', port=8080),<br/>    ])<br/><br/>    echo = source.httpd.route.pipe(<br/>        ops.flat_map(lambda i: i.request)<br/>        ops.map(lambda i: httpd.Response(<br/>                context=i.context,<br/>                data=i.match_info['what'].encode('utf-8'))))<br/>    )<br/>    control = rx.merge(init, echo)<br/>    return EchoSink(httpd=httpd.Sink(control=control))</span></pre><p id="36de" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb"> echo_server </em>函数将源作为输入并返回接收器。这些都是可以观察到的物体。<em class="lb"> init </em> Observable包含三项，用于初始化http服务器。这里定义了一个<em class="lb"> /echo </em>路由，服务器监听<em class="lb">本地主机</em>，端口<em class="lb"> 8080 </em></p><p id="5c12" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">被观察的<em class="lb">回声</em>是<em class="lb">回声</em>路线的处理者。它监听http服务器的来源，并订阅可观察的<em class="lb"> echo </em>路由。然后，对于这个可观察对象上接收到的每个项目，基于请求的路径创建一个响应。</p><p id="cc6a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">之后，<em class="lb"> init </em>和<em class="lb"> echo </em>可观察对象被合并，这样它们就可以作为一个接收器提供给http驱动程序。全部代码可在<a class="ae kc" href="https://github.com/MainRo/cyclotron-aiohttp/blob/master/example/http_echo_server.py" rel="noopener ugc nofollow" target="_blank">回旋加速器aiohttp </a>的GitHub库中获得。</p><p id="ccc1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以在控制台中启动服务器:</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="4195" class="ma mb iq lw b gy mc md l me mf">python3 http_echo_server.py</span></pre><p id="17a8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后从另一个控制台测试它:</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="f798" class="ma mb iq lw b gy mc md l me mf">$ curl <a class="ae kc" href="http://localhost:8080/echo/hello" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/echo/hello</a><br/>    hello<br/>$ curl <a class="ae kc" href="http://localhost:8080/echo/foo" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/echo/foo</a><br/>    foo</span></pre><p id="8a87" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">回旋加速器是一个小项目，已经稳定并用于生产，所以可以在自己的项目中随意尝试。目前，回旋加速器由几个组件组成:</p><ul class=""><li id="039d" class="lc ld iq kf b kg kh kk kl ko le ks lf kw lg la lh li lj lk bi translated">回旋加速器，项目的核心部分</li><li id="e245" class="lc ld iq kf b kg ll kk lm ko ln ks lo kw lp la lh li lj lk bi translated">回旋加速器标准，包含python标准库的驱动程序和适配器</li><li id="ef93" class="lc ld iq kf b kg ll kk lm ko ln ks lo kw lp la lh li lj lk bi translated">回旋加速器-aiohttp、回旋加速器-aiokafka和回旋加速器-consul包含不同协议和技术的驱动程序。</li></ul><p id="37e9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们可以从pypi获得。文档的来源和链接可在<a class="ae kc" href="https://github.com/MainRo/cyclotron-py" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><p id="9541" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">原载于2019年1月14日</em><a class="ae kc" href="https://blog.oakbits.com/farp-on-python-with-cyclotron.html" rel="noopener ugc nofollow" target="_blank"><em class="lb">https://blog.oakbits.com</em></a><em class="lb">。</em></p></div></div>    
</body>
</html>