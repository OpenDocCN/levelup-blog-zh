<html>
<head>
<title>Enhance your SwiftUI app by understanding data Source of Truth</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过了解真实数据来源来增强您的SwiftUI应用程序</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/drastically-improve-your-swiftui-app-by-understanding-data-source-of-truth-1a9253549f84?source=collection_archive---------16-----------------------#2020-08-06">https://levelup.gitconnected.com/drastically-improve-your-swiftui-app-by-understanding-data-source-of-truth-1a9253549f84?source=collection_archive---------16-----------------------#2020-08-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="ded7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在苹果全球开发者大会上发布的视频“SwiftUI 中的<a class="ae ko" href="https://developer.apple.com/videos/play/wwdc2020/10040/" rel="noopener ugc nofollow" target="_blank">数据要点”中，短语“真相的来源”被提及多达31次。那么这意味着什么呢？思考这个原则如何帮助你编写更好的SwiftUI应用程序？</a></p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/2944fd0aa97be613f54c342eb457d02f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NM-N4LS0F1EIklS3Qa3UTQ.png"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">像用户详细信息这样的数据，我们的真实来源在哪里？</figcaption></figure></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><h1 id="c152" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">真理的来源是什么？</h1><p id="6873" class="pw-post-body-paragraph jq jr it js b jt mk jv jw jx ml jz ka kb mm kd ke kf mn kh ki kj mo kl km kn im bi translated">真实的来源是SwiftUI中的一个关键概念，如果你看苹果的全球开发者大会视频，你会听到他们一遍又一遍地重申这个概念。他们本质上是说，你需要决定在一个地方存储一段数据，并让其他地方读取同一段数据——因此是真实的单一来源。</p><p id="b881" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您不应该试图保持两个值同步，或者在一个值改变时手动更新另一个值。SwiftUI的整体思想是它是一种声明性语言，这意味着给定状态为X，视图将始终看起来像y。如果您给它状态X，它应该调用函数A来更新状态B，您正在强制性地编写代码。这可能是编写UIKit应用程序、Kotlin中的Android应用程序或中的Web APIs的方式。NET，但它不是SwiftUI的做事方式。</p><p id="5940" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们看看如何显示一个项目列表，我们可以用三种方式排序，例如:按最后更新时间、按字母顺序或随机。</p><p id="49e8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">进行这种排序的声明性方式是通过保存某种状态来指示我们当前排序的三种方式中的哪一种。然后，视图获取要排序的项目列表，以及指示它们应该如何排序的状态，并显示按照用户指示的方式排序的项目列表。当用户点击一个按钮来改变列表的排序方式时，它所做的只是设置这个排序状态的值，视图将重新计算(或重新计算、重新呈现等)。)按新的排序方法显示数据。</p><p id="bc91" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这与命令式的方法相反，当你点击一个按钮时，会直接调用一个排序方法。使用这种方法，无法知道我们当前使用的是哪种排序方法。相反，我们依靠用户采取的行动来排序列表。如果我们还想显示一个代表我们排序方式的图标，我们需要更新当用户改变排序方式时调用的动作，以更新图标。</p><p id="5b07" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们来看一个我为了演示而编造的例子:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="fff6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">每种方法都会更新视图。即使我们只调用每个方法一次，许多不同的排列也会产生不同的视图。看一看:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi mv"><img src="../Images/c71675f30379bc5ffaa163e5727a1107.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zOCVWTub8ia4iiG_fCtYTQ.png"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">相同三个方法的不同排列只调用一次</figcaption></figure><p id="b223" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在想象一下，如果我们只添加一个方法，或者重复这些方法，那么更新视图的可能方式有多种。确定我们的视图应该是什么样子变得非常复杂。再加上屏幕旋转、网络活动或应用生命周期等事件，你的用户界面就变得非常复杂。难怪UI这么硬。</p><p id="6cf1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">相反，让我们来看看用SwiftUI编写的视图:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="0081" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当然，这个视图不允许用户采取任何行动——但是屏幕上显示的内容完全来自于它的状态。我们只需要理解两种状态——条目和计数器，而不是有无限多的组合可以影响视图的外观。是的，这个视图可以有一个更复杂的状态，但是重点是我们不需要担心直接操纵视图的一系列事件，以及它们的顺序。相反，我们告诉视图世界的状态是什么，它决定如何显示我们的数据。世界的状态是什么？嗯，这是我们的数据，我们的<strong class="js iu">真相来源</strong>。</p><p id="35ad" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">而现在，我们的数据直接驱动了我们的UI。给定相同的数据，我们的UI看起来总是一样的。我们不再需要以正确的顺序调用事件来更新我们的UI，我们只需要更新数据，让视图响应数据。</p><h1 id="b068" class="lm ln it bd lo lp mw lr ls lt mx lv lw lx my lz ma mb mz md me mf na mh mi mj bi translated">我们的真理之源在哪里？</h1><p id="5765" class="pw-post-body-paragraph jq jr it js b jt mk jv jw jx ml jz ka kb mm kd ke kf mn kh ki kj mo kl km kn im bi translated">因此，我们知道我们的真实来源是什么——驱动我们应用程序的数据——下一个合乎逻辑的问题是我们将它存储在哪里？首先，我喜欢将所有<strong class="js iu">重要的</strong>数据存储在<a class="ae ko" rel="noopener ugc nofollow" target="_blank" href="/state-vs-stateobject-vs-observedobject-vs-environmentobject-in-swiftui-81e2913d63f9">可观察对象</a>中。我的意思是，在符合ObservableObject的结构中存储任何非简单UI状态的数据(例如，开关)。这超出了本文的范围，但是要了解关于ObservableObjects的更多信息，请查看我的另一个故事。</p><p id="63e2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们的真理之源应该永远放在最高的父母身上。也就是说，该视图包含可能需要该数据的所有其他视图。换句话说，最接近需要数据的<code class="fe mp mq mr ms b">ContentView</code>的第一个视图。</p><p id="0a6c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以现在的问题是，我们在哪里实例化我们的ObservableObject？让我们使用两个我们可能希望在应用程序中访问的真实数据示例:</p><ol class=""><li id="4640" class="nb nc it js b jt ju jx jy kb nd kf ne kj nf kn ng nh ni nj bi translated">电影列表，以及用户是否看过这些电影</li><li id="3ddf" class="nb nc it js b jt nk jx nl kb nm kf nn kj no kn ng nh ni nj bi translated">用户是否登录，以及他们的姓名</li></ol><p id="3c41" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第一个例子是两个例子中比较简单的一个。我们可以将电影列表的数据包含到两种类型的视图中。一个是电影本身的列表，另一个是每部电影单独的列表。请看一些示例代码:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="25da" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如你所见，电影的使用仅限于这两种观点。它不需要在我的应用程序的任何其他地方访问，至少在我的应用程序的当前实现中。</p><p id="17dd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，我们的<code class="fe mp mq mr ms b">Movies</code>对象是在<code class="fe mp mq mr ms b">MoviesListView</code>中创建的，正如您在第2 行的<strong class="js iu">中看到的。这是最上层的父视图，因为它是包含<code class="fe mp mq mr ms b">MovieView</code>的视图，也需要访问相同的数据。我们不会在<code class="fe mp mq mr ms b">MovieView</code>中创建<code class="fe mp mq mr ms b">Movies</code>，因为我们无法从<code class="fe mp mq mr ms b">MoviesListView</code>访问它，我们也不想为每一部电影都重新创建它。</strong></p><p id="6c0f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另一个例子是存储用户是否登录，以及他们的名字是什么。我再一次提到我之前说过的话。我们应该在最上面的父类中实例化这些数据。然而，对于用户详细信息，这可能会在我们的应用程序中使用——在任何视图中。</p><p id="b516" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">考虑到这一点，让我们继续把它放在应用程序的最上层——我们的应用程序本身。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="b340" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正如我们在这里看到的，我已经在应用程序的顶部实例化了我们的<code class="fe mp mq mr ms b">UserDetails</code> ObservableObject，然后将其作为环境对象添加到<code class="fe mp mq mr ms b">ContentView</code>上，这样我们的整个应用程序就可以访问来自<code class="fe mp mq mr ms b">UserDetails</code>的任何属性。这意味着我们应用程序中的任何视图都可以知道用户是否登录，以及用户的用户名是什么。</p><p id="9d1c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果用户登录了，我们可以用它来显示内容；如果用户没有登录，我们可以用一个简单的条件语句将他们指向登录屏幕。我们没有触发类似于<code class="fe mp mq mr ms b">login()</code>的事件，而是通过类似于<code class="fe mp mq mr ms b">if userDetails.isLoggedIn { ContentView() } else { LoginView() }</code>的东西来决定是否向他们显示登录屏幕。这使得理解你的应用程序的用户界面的不同行为方式变得更加容易。</p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><p id="4bc5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这就是你要做的——快速进入声明式用户界面和事实来源的世界。希望这个故事能给你一些启发，让你知道你的真实来源是什么，然后在你的应用程序中把它存储在哪里。因为在SwiftUI中，UI直接与您的应用程序的生命周期相关联，所以这些决策对于确保您的数据在您需要时可用非常重要。通过了解您的真实来源以及它在应用程序中的位置，您将能够更好地决定在哪里实例化您的对象，这将使您的代码更容易理解和遵循。</p><p id="cd7d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你喜欢这个故事，请鼓掌，并留下你的任何问题，我会尽我所能来回答他们！</p></div></div>    
</body>
</html>