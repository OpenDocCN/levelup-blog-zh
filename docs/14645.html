<html>
<head>
<title>Introduction to GoogleTest (gtest)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GoogleTest (gtest)简介</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/introduction-to-googletest-gtest-1ece21f55d0e?source=collection_archive---------13-----------------------#2022-12-14">https://levelup.gitconnected.com/introduction-to-googletest-gtest-1ece21f55d0e?source=collection_archive---------13-----------------------#2022-12-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="087a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">用C++进行良好的单元测试(第一部分)</h2></div><p id="e2cc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">单元测试对于任何好的软件项目都是必不可少的。在这篇文章中，我不想激发或介绍单元测试本身，而是希望读者熟悉基础。相反，这篇文章重点介绍了<a class="ae lb" href="http://google.github.io/googletest/" rel="noopener ugc nofollow" target="_blank"> GoogleTest (gtest) </a>框架——这是许多人用C++编写单元测试的首选框架。我发现它类似于<a class="ae lb" href="https://medium.com/@hrmnmichaels/unit-testing-with-pytest-5c59cdf89529" rel="noopener"> Python的pytest </a>:易于使用，但功能强大。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi lc"><img src="../Images/d295b23ad687f810c230c34b0f2ebbb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qgog5ZrmqFhEVRpqCS1HLg.jpeg"/></div></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk translated"><a class="ae lb" href="https://www.freepik.com/free-vector/bug-fixing-software-testing-computer-virus-searching-tool-devops-web-optimization-antivirus-app-magnifier-cogwheel-monitor-design-element_12083098.htm#query=software%20testing&amp;position=2&amp;from_view=keyword" rel="noopener ugc nofollow" target="_blank">Freepik上的vectorjuice </a>图片</figcaption></figure><p id="643b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这里，我们将通过一些实际的例子来介绍gtest，并深入其中:我们使用<a class="ae lb" href="https://bazel.build/" rel="noopener ugc nofollow" target="_blank"> Bazel </a>作为我们项目的构建系统，但是我想鼓励读者使用他们熟悉的任何东西。因此，我们的项目包含4个文件:</p><ul class=""><li id="fca8" class="ls lt iq kh b ki kj kl km ko lu ks lv kw lw la lx ly lz ma bi translated">构建(bazel构建文件)</li><li id="54d5" class="ls lt iq kh b ki mb kl mc ko md ks me kw mf la lx ly lz ma bi translated">gtest_example.h /。cc(样本类的头文件/正文文件)</li><li id="58cd" class="ls lt iq kh b ki mb kl mc ko md ks me kw mf la lx ly lz ma bi translated">gt est _ example _ test . cc(gt est测试文件)</li></ul><p id="41c5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们从实现一个简单的加法函数开始，为上面提到的文件生成以下文件内容，测试文件将在后面填充:</p><p id="825f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">构建</strong></p><pre class="ld le lf lg gt mg mh mi bn mj mk bi"><span id="f01b" class="ml mm iq mh b be mn mo l mp mq">cc_library(<br/>    name = "gtest_example",<br/>    srcs = ["gtest_example.cc"],<br/>    hdrs = ["gtest_example.h"],<br/>    visibility = ["//visibility:public"],<br/>    deps = [<br/>    ],<br/>)<br/><br/>cc_test(<br/>    name = "gtest_example_test",<br/>    srcs = ["gtest_example_test.cc"],<br/>    deps = [<br/>        ":gtest_example",<br/>        "@com_google_googletest//:gtest_main",<br/>    ],<br/>)</span></pre><p id="734a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> gtest_example.h </strong></p><pre class="ld le lf lg gt mg mh mi bn mj mk bi"><span id="99f3" class="ml mm iq mh b be mn mo l mp mq">#pragma once<br/><br/>class ExampleClass {<br/> public:<br/>  int sum(int summand1, int summand2);<br/>};</span></pre><p id="3b69" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> gtest_example.cc </strong></p><pre class="ld le lf lg gt mg mh mi bn mj mk bi"><span id="9075" class="ml mm iq mh b be mn mo l mp mq">#include "gtest_samples/gtest_example.h"<br/><br/>int ExampleClass::sum(int summand1, int summand2) { return a + b; }</span></pre><p id="bdf7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们的单元测试文件中，我们只需要包含正确的gtest头文件，并且可以用<code class="fe mr ms mt mh b">EXPECT_EQ</code>检查两个值是否相等，从而测试正确的加法结果:</p><pre class="ld le lf lg gt mg mh mi bn mj mk bi"><span id="765d" class="ml mm iq mh b be mn mo l mp mq">#include "gtest_samples/gtest_example.h"<br/><br/>#include &lt;gtest/gtest.h&gt;<br/><br/>TEST(ExampleClassTest, TestSum) {<br/>  ExampleClass example = ExampleClass();<br/>  EXPECT_EQ(example.sum(1, 2), 3);<br/>}</span></pre><p id="bd05" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mr ms mt mh b">TEST</code>的第一个参数是测试套件的名称(描述多个测试集合的通用名称)，第二个参数是这个测试用例中具体测试运行的名称。</p><p id="6dd3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过<code class="fe mr ms mt mh b">bazel test gtest_samples:gtest_example_test</code>来运行这个测试</p><h2 id="ebb6" class="mu mm iq bd mv mw mx dn my mz na dp nb ko nc nd ne ks nf ng nh kw ni nj nk nl bi translated">固定装置</h2><p id="1959" class="pw-post-body-paragraph kf kg iq kh b ki nm jr kk kl nn ju kn ko no kq kr ks np ku kv kw nq ky kz la ij bi translated">如果我们像上面一样编写多个测试，我们会发现自己需要重新输入几行代码——在本例中是<code class="fe mr ms mt mh b">example</code>的声明和实例化。在这里，夹具来拯救:它们允许定义基本测试类，为所有实现的测试用例共享<code class="fe mr ms mt mh b">SetUp()</code>和<code class="fe mr ms mt mh b">TearDown()</code>代码。公平地说，我们的一行类声明/实例化可能还不能证明fixtures是正确的——但是我希望这个原则变得清晰。</p><p id="6343" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们引入一个除法函数，用这样的fixture重写上面的测试。我们给<code class="fe mr ms mt mh b">ExampleClass</code>增加如下除法功能:</p><pre class="ld le lf lg gt mg mh mi bn mj mk bi"><span id="3471" class="ml mm iq mh b be mn mo l mp mq">float ExampleClass::divide(float dividend, float divisor) {<br/>  CHECK_NE(divisor, 0) &lt;&lt; "Can't divide by 0!";<br/>  return dividend / divisor;<br/>}</span></pre><p id="96a7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意，<code class="fe mr ms mt mh b">CHECK_NE</code>是Google日志模块的一部分，因此需要<code class="fe mr ms mt mh b">#include &lt;glog/logging.h&gt;</code>，以及构建文件中的依赖关系<code class="fe mr ms mt mh b">@com_github_google_glog//:glog</code>。</p><p id="8bd7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们修改测试文件如下:</p><pre class="ld le lf lg gt mg mh mi bn mj mk bi"><span id="efa4" class="ml mm iq mh b be mn mo l mp mq">#include "gtest_samples/gtest_example.h"<br/><br/>#include &lt;gtest/gtest.h&gt;<br/><br/>class GTestExampleTest : public ::testing::Test {<br/> protected:<br/>  void SetUp() override { example_ = ExampleClass(); }<br/>  void TearDown() override {}<br/><br/>  ExampleClass example_;<br/>};<br/><br/>TEST_F(GTestExampleTest, TestSum) { EXPECT_EQ(example_.sum(1, 2), 3); }<br/>TEST_F(GTestExampleTest, TestDivision) {<br/>  EXPECT_EQ(example_.divide(1, 2), 0.5);<br/>}</span></pre><p id="680c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们注意到，使用fixture的测试是用关键字<code class="fe mr ms mt mh b">TEST_F</code>定义的，第一个参数是测试的基类的名称。在我们的示例中，我们在<code class="fe mr ms mt mh b">SetUp()</code>步骤中实例化了一个示例类，但是将<code class="fe mr ms mt mh b">TearDown()</code>留空。在这里，我们可以添加每次测试后运行的代码，比如清理磁盘上的文件。</p><h2 id="47c9" class="mu mm iq bd mv mw mx dn my mz na dp nb ko nc nd ne ks nf ng nh kw ni nj nk nl bi translated">检查终止</h2><p id="e718" class="pw-post-body-paragraph kf kg iq kh b ki nm jr kk kl nn ju kn ko no kq kr ks np ku kv kw nq ky kz la ij bi translated">聪明的是，我们添加了一个检查来防止除数为0。但是我们如何在单元测试中验证正确的行为呢？为此，我们可以使用<code class="fe mr ms mt mh b">EXPECT_DEATH</code> —该函数验证流程是否如预期的那样终止，并产生预期的错误消息:</p><pre class="ld le lf lg gt mg mh mi bn mj mk bi"><span id="d2d8" class="ml mm iq mh b be mn mo l mp mq">TEST_F(GTestExampleTest, TestDivision) {<br/>  EXPECT_EQ(example_.divide(1, 2), 0.5);<br/>  EXPECT_DEATH(example_.divide(1, 0), "Can't divide by 0!");<br/>}</span></pre><h2 id="accc" class="mu mm iq bd mv mw mx dn my mz na dp nb ko nc nd ne ks nf ng nh kw ni nj nk nl bi translated">自定义比较运算符</h2><p id="4a70" class="pw-post-body-paragraph kf kg iq kh b ki nm jr kk kl nn ju kn ko no kq kr ks np ku kv kw nq ky kz la ij bi translated">让我们定义一个自定义结构，一个返回它的函数，以及一个检查返回的结构是否正确的单元测试:</p><p id="be77" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> gtest_example.h </strong></p><pre class="ld le lf lg gt mg mh mi bn mj mk bi"><span id="84b6" class="ml mm iq mh b be mn mo l mp mq">#pragma once<br/><br/>struct CustomStruct {<br/>  int value;<br/>};<br/><br/>class ExampleClass {<br/> public:<br/>  int sum(int summand1, int summand2);<br/>  float divide(float dividend, float divisor);<br/>  CustomStruct custom_op(int x);<br/>};</span></pre><p id="08f5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> gtest_example.cc </strong></p><pre class="ld le lf lg gt mg mh mi bn mj mk bi"><span id="0eaf" class="ml mm iq mh b be mn mo l mp mq">CustomStruct ExampleClass::custom_op(int x) { return CustomStruct{.value = x}; }</span></pre><p id="bc09" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> gtest_example_test.cc </strong></p><pre class="ld le lf lg gt mg mh mi bn mj mk bi"><span id="1f6a" class="ml mm iq mh b be mn mo l mp mq">bool operator==(const CustomStruct&amp; lhs, const CustomStruct&amp; rhs) {<br/>  return lhs.value == rhs.value;<br/>}<br/><br/>TEST_F(GTestExampleTest, TestCustomOp) {<br/>  EXPECT_EQ(example_.custom_op(10), CustomStruct{.value = 10});<br/>}</span></pre><p id="d77e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意为<code class="fe mr ms mt mh b">CustomStruct</code>实现一个定制的<code class="fe mr ms mt mh b">==</code>操作符的必要性，否则gtest不能检查相等性。</p><p id="12fa" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就完成了对gtest的基本介绍。我希望你已经发现这是有用的。感谢您的阅读。</p><p id="490c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在下一篇文章中，我们将探讨更高级的话题，比如嘲讽。</p></div></div>    
</body>
</html>