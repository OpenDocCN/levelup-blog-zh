<html>
<head>
<title>TypeScript Antipatterns to Avoid</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">要避免的类型脚本反模式</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/typescript-antipatterns-to-avoid-f091d4b6100b?source=collection_archive---------5-----------------------#2020-04-16">https://levelup.gitconnected.com/typescript-antipatterns-to-avoid-f091d4b6100b?source=collection_archive---------5-----------------------#2020-04-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/324e57ea16d232478b4d45bf3f14fdac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*go6pqwS76mn2C30f"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@pooya_ramezani?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> pooya ramezani </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="99ab" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">TypeScript是一种通过向JavaScript代码添加类型注释来扩展JavaScript功能的语言。这让我们避免了意外数据类型的错误。</p><p id="dbc0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将研究一些在编写TypeScript代码时要避免的反模式。</p><h1 id="ebf9" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">过度使用any类型</h1><p id="bc9b" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">使用TypeScript的目的是在变量和函数中拥有类型。所以我们应该尽可能地使用它们。</p><p id="4f3e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我们不应该在大部分代码中使用<code class="fe mh mi mj mk b">any</code>类型。</p><h1 id="048b" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">过度使用类</h1><p id="7c3a" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">如果我们的TypeScript类没有很多方法，那么我们不需要定义一个类来使用它对变量和函数进行类型化。</p><p id="cf1f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另外，如果我们只有一个实例，那么将逻辑包装在一个类中是没有意义的。</p><p id="23ae" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">实例化类引入了复杂性，并且在缩小代码时很难优化。</p><p id="3a26" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">相反，我们可以定义对象文字，并使用接口或<code class="fe mh mi mj mk b">typeof</code>操作符来获取对象的类型。</p><p id="4256" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，为对象编写以下接口:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="4f74" class="mt lf it mk b gy mu mv l mw mx">interface Person {<br/>    firstName: string;<br/>    lastName: string;<br/>}</span><span id="a79b" class="mt lf it mk b gy my mv l mw mx">const person: Person = {<br/>    firstName: 'Jane',<br/>    lastName: 'Smith'<br/>}</span></pre><p id="c801" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们可以像上面的<code class="fe mh mi mj mk b">person</code>一样使用它们。</p><p id="7164" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，如果我们不知道对象的确切结构，我们可以使用<code class="fe mh mi mj mk b">typeof</code>操作符，如下所示:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="4acf" class="mt lf it mk b gy mu mv l mw mx">const person = {<br/>    firstName: 'Jane',<br/>    lastName: 'Smith'<br/>}</span><span id="2e5f" class="mt lf it mk b gy my mv l mw mx">const person2: typeof person = {<br/>    firstName: 'Joe',<br/>    lastName: 'Smith'<br/>}</span></pre><p id="11bb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用<code class="fe mh mi mj mk b">typeof</code>是定义类型的一种便捷方式，无需编写大量代码。</p><p id="9aeb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们的对象有方法，我们可以做和上面一样的事情:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="d3c7" class="mt lf it mk b gy mu mv l mw mx">interface Person {<br/>    firstName: string;<br/>    lastName: string;<br/>    fullName: (firstName: string, lastName: string) =&gt; string<br/>}</span><span id="f468" class="mt lf it mk b gy my mv l mw mx">const person: Person = {<br/>    firstName: 'Jane',<br/>    lastName: 'Smith',<br/>    fullName(firstName: string, lastName: string) {<br/>        return `${firstName} ${lastName}`;<br/>    }<br/>}</span></pre><p id="3acf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">TypeScript会用<code class="fe mh mi mj mk b">typeof</code>做类型推断:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="5182" class="mt lf it mk b gy mu mv l mw mx">const person = {<br/>    firstName: 'Jane',<br/>    lastName: 'Smith',<br/>    fullName(firstName: string, lastName: string) {<br/>        return `${firstName} ${lastName}`;<br/>    }<br/>}<br/>const person2: typeof person = {<br/>    firstName: 'Joe',<br/>    lastName: 'Smith',<br/>    fullName(firstName, lastName) {<br/>        return `${firstName} ${lastName}`;<br/>    }<br/>}</span></pre><p id="e43f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果<code class="fe mh mi mj mk b">person2</code>缺少的话，它会强迫我们将<code class="fe mh mi mj mk b">fullName</code>方法添加到<code class="fe mh mi mj mk b">person2</code>中，并且会强迫我们添加参数并返回一个字符串。</p><p id="c0da" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">否则，我们会得到编译错误。</p><h1 id="660f" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">使用函数类型</h1><p id="62b4" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mh mi mj mk b">Function</code>类型是函数的通用类型。就像<code class="fe mh mi mj mk b">any</code>对于变量。我们应该在函数中指定参数的数据类型和返回类型。</p><p id="e458" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">相反，我们应该向参数添加类型并返回类型，如下所示:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="bf83" class="mt lf it mk b gy mu mv l mw mx">type ArithmeticFn = (a: number, b: number) =&gt; number<br/>const add: ArithmeticFn = (a: number, b: number): number =&gt; a + b;</span></pre><p id="79b5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们有类型别名<code class="fe mh mi mj mk b">ArithmeticFn</code>和<code class="fe mh mi mj mk b">add</code>中的类型。代码中的类型注释已经足够了。</p><p id="1a62" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，我们可以再次使用<code class="fe mh mi mj mk b">typeof</code>进行类型推断:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="8237" class="mt lf it mk b gy mu mv l mw mx">const add = (a: number, b: number): number =&gt; a + b;<br/>const subtract: typeof add = (a, b) =&gt; a-b</span></pre><p id="373c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么<code class="fe mh mi mj mk b">subtract</code>也具有与<code class="fe mh mi mj mk b">add</code>相同的参数和返回类型。</p><h1 id="444d" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">扰乱类型推理</h1><p id="f978" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们不应该把无用的类型注释与类型推断放在一起就行了。</p><p id="c390" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，在以下示例中:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="b5a5" class="mt lf it mk b gy mu mv l mw mx">const courses = [{<br/>    name: 'Intro to TypeScript'<br/>}]<br/>const [course] = courses;<br/>const newCourse: any = {...course};<br/>newCourse.description = 'Great intro to TypeScript';<br/>courses[0] = newCourse;</span></pre><p id="5eb9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们有一个不应该有的额外的<code class="fe mh mi mj mk b">any</code>注释。</p><p id="c9dc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">相反，如果我们想在复制后给对象添加一个新的属性，我们可以编写如下代码:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="c049" class="mt lf it mk b gy mu mv l mw mx">const courses = [{<br/>    name: 'Intro to TypeScript'<br/>}]<br/>const [course] = courses;<br/>const newCourse = {...course, description: 'Great intro to TypeScript'};<br/>courses[0] = newCourse;</span></pre><p id="9d6b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么TypeScript编译器不会抛出错误，我们仍然可以从TypeScript编译器得到类型推断，因为我们没有使用<code class="fe mh mi mj mk b">any</code>类型。</p><h1 id="a198" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">复制和粘贴分部类型定义</h1><p id="825e" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">另一件我们不应该做的事情是将其他地方的分部类型定义复制并粘贴到我们自己的代码中。</p><p id="85fb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们想得到一个未知类型的对象的类型，我们可以使用<code class="fe mh mi mj mk b">typeof</code>操作符。</p><p id="372e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="3a1d" class="mt lf it mk b gy mu mv l mw mx">const person = {<br/>    firstName: 'Joe',<br/>    lastName: 'Smith', <br/>    age: 20<br/>}</span><span id="2daf" class="mt lf it mk b gy my mv l mw mx">const person2: typeof person = {<br/>    firstName: 'Jane',<br/>    lastName: 'Smith', <br/>    age: 20<br/>}</span></pre><p id="c11f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">TypeScript编译器将自动识别<code class="fe mh mi mj mk b">person</code>的类型，并在我们定义<code class="fe mh mi mj mk b">person2</code>时进行检查，以检查是否一切都在那里。</p><h2 id="8cc9" class="mt lf it bd lg mz na dn lk nb nc dp lo kr nd ne ls kv nf ng lw kz nh ni ma nj bi translated">查找类型</h2><p id="7b5f" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们也可以使用对象的一个属性作为它自己的类型。这称为查找类型。</p><p id="8512" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="9203" class="mt lf it mk b gy mu mv l mw mx">const person = {<br/>    firstName: 'Joe',<br/>    lastName: 'Smith', <br/>    age: 20<br/>}</span><span id="6b0a" class="mt lf it mk b gy my mv l mw mx">const foo: typeof person.firstName = 'foo';</span></pre><p id="6c94" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，TypeScript识别出<code class="fe mh mi mj mk b">person.firstName</code>的类型是一个字符串，所以<code class="fe mh mi mj mk b">typeof person.firstName</code>应该是一个字符串。</p><h2 id="6877" class="mt lf it bd lg mz na dn lk nb nc dp lo kr nd ne ls kv nf ng lw kz nh ni ma nj bi translated">映射类型</h2><p id="ef14" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以创建映射类型，将一个类型的所有属性映射到其他类型。</p><p id="339f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以通过编写以下内容使类型的所有属性都是可选的:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="41b0" class="mt lf it mk b gy mu mv l mw mx">interface Person{<br/>    firstName: string;<br/>    lastName: string;<br/>}</span><span id="8263" class="mt lf it mk b gy my mv l mw mx">type Optional&lt;T&gt; = {<br/>    [P in keyof T]?: T[P];<br/>};</span><span id="8854" class="mt lf it mk b gy my mv l mw mx">const partialPerson: Optional&lt;Person&gt; = {};</span></pre><p id="99a6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的代码可以编译和运行，因为我们从<code class="fe mh mi mj mk b">Person</code>创建了一个新的类型，其中所有的属性都是可选的。</p><h2 id="986b" class="mt lf it bd lg mz na dn lk nb nc dp lo kr nd ne ls kv nf ng lw kz nh ni ma nj bi translated">获取函数的返回类型</h2><p id="8ea8" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以得到带有<code class="fe mh mi mj mk b">ReturnType</code>泛型的返回类型函数来传入函数的类型。然后我们会得到这个函数的返回类型。</p><p id="e266" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="ef5a" class="mt lf it mk b gy mu mv l mw mx">const add = (a: number, b: number) =&gt; a + b;<br/>const num: ReturnType&lt;typeof add&gt; = 1;</span></pre><p id="181b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么<code class="fe mh mi mj mk b">ReturnType&lt;typeof add&gt;</code>就会是<code class="fe mh mi mj mk b">number</code>，所以我们要给它赋一个数。</p><p id="2852" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">TypeScript的类型推断在这里也起作用。从TypeScript 2.8开始，<code class="fe mh mi mj mk b">ReturnType</code>泛型就可用了</p><h1 id="73ce" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="60aa" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">在许多情况下，我们可以使用<code class="fe mh mi mj mk b">typeof</code>操作符、查找类型或映射类型来灵活地注释类型，而不会失去类型检查功能。</p><p id="101e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这意味着我们应该尽可能不使用<code class="fe mh mi mj mk b">any</code>。</p><p id="a917" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，我们不需要仅仅为一些对象添加类型的类。</p></div></div>    
</body>
</html>