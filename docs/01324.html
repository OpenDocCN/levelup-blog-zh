<html>
<head>
<title>Avoiding the pitfalls of async Node.js functions in AWS Lambda</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">避免AWS Lambda中async Node.js函数的缺陷</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/avoiding-the-pitfalls-of-async-node-js-functions-in-aws-lambda-941220582e7a?source=collection_archive---------0-----------------------#2019-12-14">https://levelup.gitconnected.com/avoiding-the-pitfalls-of-async-node-js-functions-in-aws-lambda-941220582e7a?source=collection_archive---------0-----------------------#2019-12-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/52d1e022f23008cdd13b77532edce1e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gUqCWAXd3G0s_2shLhy6QQ.png"/></div></div></figure><p id="64b0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">自从<a class="ae kw" href="https://aws.amazon.com/blogs/compute/node-js-8-10-runtime-now-available-in-aws-lambda/" rel="noopener ugc nofollow" target="_blank">在AWS Lambda </a>中引入Node.js 8.10运行时以来，我们已经能够享受使用<em class="kx"> async/await </em>语法的好处，并编写优雅、易于维护的干净代码。</p><p id="a841" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以编写一个简单的异步函数处理程序:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="d328" class="lh li iq ld b gy lj lk l ll lm">export const handler = async (event, context) =&gt; { <br/>  const response = await someAsyncFunc();<br/>  return response;<br/>}</span></pre><p id="3adb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这实际上与仅仅返回承诺是一样的，因为<a class="ae kw" href="https://docs.aws.amazon.com/lambda/latest/dg/nodejs-prog-model-handler.html" rel="noopener ugc nofollow" target="_blank"> AWS Lambda将自动等待异步处理程序</a>中的承诺:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="21ea" class="lh li iq ld b gy lj lk l ll lm">export const handler = async (event, context) =&gt; { <br/>  return someAsyncFunc();<br/>}</span></pre><p id="4384" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是为了清楚起见，我们将使用更详细的版本。<br/>现在让我们在函数处理程序中添加一个异步副作用——比如一个DB计数器，它必须在Lambda:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="4f08" class="lh li iq ld b gy lj lk l ll lm">export const handler = async (event, context) =&gt; {<strong class="ld ir"><br/></strong>  const response = await someAsyncFunc();<br/>  <strong class="ld ir">asyncIncrementDBCounter();<br/></strong>  return response;<br/>}</span></pre><p id="6539" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们不等待它，因为我们不关心返回值。我们只知道它最终会执行。因此，如果在Lambda被调用之前，计数器的值是<strong class="ka ir"> 0 </strong>，那么在执行结束时，值会是什么呢？</p><p id="a615" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">结果答案并非如此微不足道——它可能会增加到<strong class="ka ir"> 1 </strong>，它可能会保持<strong class="ka ir"> 0 </strong>，或者它可能会在未来某个不可预测的时间增加。<br/> <br/>等等，什么？为了理解这种行为，我们需要理解Node.js如何处理异步任务。</p><h1 id="aeb7" class="ln li iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">Node.js事件循环的简要概述</h1><p id="a5de" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated"><a class="ae kw" href="https://nodejs.org/de/docs/guides/event-loop-timers-and-nexttick/" rel="noopener ugc nofollow" target="_blank">事件循环</a>允许Node.js执行非阻塞I/O操作，尽管JavaScript是单线程的。</p><p id="b953" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Node.js使用事件循环将异步任务卸载到系统内核(它是多线程的)，系统内核在任务完成时通知Node.js。这就是Node.js如此伟大和无阻塞的原因。</p><p id="8cc9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises" rel="noopener ugc nofollow" target="_blank">承诺本质上是异步操作</a>，所以使用事件循环将它们卸载到内核，当它们被解析时，内核会将结果传回Node.js。</p><h2 id="0af8" class="lh li iq bd lo mp mq dn ls mr ms dp lw kj mt mu ma kn mv mw me kr mx my mi mz bi translated">回到我们的λ</h2><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="8a54" class="lh li iq ld b gy lj lk l ll lm">export const handler = async (event, context) =&gt; { <br/>  const response = await someAsyncFunc();<br/>  asyncIncrementDBCounter();<br/>  return response;<br/>}</span></pre><p id="329a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们的例子中，对<strong class="ka ir"><em class="kx">someAsyncFunc()</em></strong>的调用是<em class="kx"> await </em> ed。被卸载后，它下面的代码只有在承诺被解析时才会被处理，就像一个好的ol '回调一样。</p><p id="d95d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当<strong class="ka ir"><em class="kx">asyncIncrementDBCounter()</em></strong>被调用时，它也被卸载，但是由于它不是<em class="kx">wait</em>ed，所以执行继续并将响应返回给lambda调用者。</p><p id="ead5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在返回响应时，增量任务仍然可以在事件循环队列<strong class="ka ir"> <em class="kx">、</em>、</strong>中，这取决于它在返回时是否完成了它的处理。</p><p id="6472" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了理解接下来会发生什么，我们需要理解Lambdas是如何执行代码的。</p><h1 id="5c07" class="ln li iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">到Lambda执行上下文中</h1><p id="719a" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">每当一个Lambda函数被调用时，一个临时的运行时环境被调用，该环境具有根据其配置运行该函数所需的资源。这被称为<strong class="ka ir">执行上下文</strong>。</p><p id="0a4a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于这个引导过程需要时间，AWS Lambda试图为Lambda的后续调用重用相同的执行上下文，以最小化“冷启动”开销——例如连接到数据库。</p><p id="7845" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Lambda执行完毕后，上下文将被冻结以备后用。官方文件中写道:</p><blockquote class="na nb nc"><p id="7e3f" class="jy jz kx ka b kb kc kd ke kf kg kh ki nd kk kl km ne ko kp kq nf ks kt ku kv ij bi translated">如果AWS Lambda选择重用执行上下文，则由Lambda函数发起的后台进程或回调(在函数结束时未完成)将恢复<strong class="ka ir">。</strong></p></blockquote><p id="c720" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们可以理解我们的选择了。</p><h2 id="0b19" class="lh li iq bd lo mp mq dn ls mr ms dp lw kj mt mu ma kn mv mw me kr mx my mi mz bi translated">那么柜台会怎么样呢？</h2><p id="7db3" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">如果<strong class="ka ir"><em class="kx">asyncIncrementDBCounter()</em></strong>在初始调用期间执行完毕，计数器将递增到<strong class="ka ir"> 1 </strong>。简单。</p><p id="980e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是如果它没有完成，处理就被“冻结”在之前的Lambda执行上下文中，它只能在下一次Lambda调用<strong class="ka ir">时恢复——并且只有在相同的执行上下文被重用的情况下。</strong></p><p id="a0da" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这基本上意味着增量可以在稍后的某个时间点发生，或者根本不发生，保持计数器在<strong class="ka ir"> 0 </strong>。它很容易导致错误和无法解释的行为。<br/>(好吧，至少对没看这个帖子的人来说是这样；) )</p><h1 id="5728" class="ln li iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">结论</h1><p id="9872" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">在AWS Lambdas异步处理程序上，总是等待您的异步函数。</p><p id="74ff" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们变得习惯于只在我们需要结果的承诺上<em class="kx">等待</em>，或者当我们想要在调用者中使用<em class="kx"> try/catch </em>子句来处理错误时。但是在AWS Lambdas的情况下，我们应该改变我们的心态。</p><p id="4a90" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">官方文件强化了这一观念:</p><blockquote class="na nb nc"><p id="7237" class="jy jz kx ka b kb kc kd ke kf kg kh ki nd kk kl km ne ko kp kq nf ks kt ku kv ij bi translated">您应该确保代码中的任何后台进程或回调在代码退出之前都已完成。</p></blockquote><p id="aa2e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">回到代码。天真的解决方案将会奏效:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="b1fe" class="lh li iq ld b gy lj lk l ll lm">export const handler = async (event, context) =&gt; { <br/>  const response = await someAsyncFunc();<br/><strong class="ld ir">  await </strong>asyncIncrementDBCounter();<br/>  return response;<br/>}</span></pre><p id="cc58" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是既然这两个函数互不依赖，不如用<a class="ae kw" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all" rel="noopener ugc nofollow" target="_blank"><em class="kx">promise . all</em></a><em class="kx"/>并行运行异步函数，<em class="kx">一起等待</em>它们的结果:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="2d8d" class="lh li iq ld b gy lj lk l ll lm">export const handler = async (event, context) =&gt; { <br/>  const [response, dbResult] = <br/>    await Promise.all([<br/>      someAsyncFunc(), <br/>      asyncIncrementDBCounter()<br/>    ];  <br/>          <br/>   return response;<br/>}</span></pre><p id="6b34" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意:如果某个函数失败，<em class="kx"> Promise.all </em>的快速失效机制将阻止其他承诺的解析。这超出了本文的范围，但是这里有一些缓解措施<a class="ae kw" href="https://stackoverflow.com/questions/35612428/call-async-await-functions-in-parallel" rel="noopener ugc nofollow" target="_blank"/>。</p></div><div class="ab cl ng nh hu ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ij ik il im in"><p id="73cb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">感谢阅读！这是一个令人着迷的研究主题，也是一个令人紧张的调试主题:)如果我遗漏了什么或者犯了一个错误，请在评论中告诉我。</p></div></div>    
</body>
</html>