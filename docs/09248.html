<html>
<head>
<title>Git and workflow with GitFlow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Git和使用GitFlow的工作流</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/git-and-workflow-with-gitflow-5f9f76530835?source=collection_archive---------10-----------------------#2021-07-20">https://levelup.gitconnected.com/git-and-workflow-with-gitflow-5f9f76530835?source=collection_archive---------10-----------------------#2021-07-20</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><figure class="gm go jp jq jr js gi gj paragraph-image"><div role="button" tabindex="0" class="jt ju di jv bf jw"><div class="gi gj jo"><img src="../Images/25c4aa1a7ea4a71536afd2d035d51d32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*oM0J7PTuXFSD4SPm.jpg"/></div></div><figcaption class="jz ka gk gi gj kb kc bd b be z dk translated">照片由<a class="ae kd" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae kd" href="https://unsplash.com/@kodozani?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Onur K </a>拍摄</figcaption></figure><figure class="kf kg kh ki gu js gi gj paragraph-image"><a href="https://raulferrer.dev"><div class="gi gj ke"><img src="../Images/4559de80fb63bfa9a7c3d7a9ceaa962f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JG2ALPF7dH51wuAxTnReEQ.png"/></div></a></figure><p id="6ca9" class="pw-post-body-paragraph kj kk ir kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ik bi translated">当开发软件时，我们发现自己需要管理代码中的变更，并且当作为一个团队工作时，所有团队成员总是有一份该代码的副本，他们可以在其中工作，然后集成这些变更。为了促进这项工作，我们有版本控制系统，它允许我们跟踪和管理代码随时间发生的变化:为此，我们将看到<strong class="kl is"> GitFlow </strong>的使用和工作流程。</p></div><div class="ab cl lh li hv lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ik il im in io"><p id="740e" class="pw-post-body-paragraph kj kk ir kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ik bi translated"><strong class="kl is"> Git </strong>是Linus Torvarlds(Linux的创造者)开发的一个版本控制软件，为了和他的合作者协调工作。</p><p id="21e4" class="pw-post-body-paragraph kj kk ir kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ik bi translated">请记住,<strong class="kl is"> Git </strong>有一个分布式架构，因此当开发人员制作该代码的工作副本时，它会生成一个存储库，其中包含该代码中所做更改的完整历史，而不是代码位于一个单独的位置。</p><h1 id="2928" class="lo lp ir bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">存储库、修订、提交…一些词汇</h1><p id="ca1a" class="pw-post-body-paragraph kj kk ir kl b km mm ko kp kq mn ks kt ku mo kw kx ky mp la lb lc mq le lf lg ik bi translated">当使用<strong class="kl is"> Git </strong>和版本控制时，我们会遇到一系列术语，为了知道正在做什么，有必要了解这些术语:</p><ul class=""><li id="9a94" class="mr ms ir kl b km kn kq kr ku mt ky mu lc mv lg mw mx my mz bi translated"><strong class="kl is">分支。</strong>分支是代码中某一点上的分叉，它允许你在不影响其他分支的情况下开发代码。例如，我们可以创建一个分支，向代码中添加新功能。</li><li id="63be" class="mr ms ir kl b km na kq nb ku nc ky nd lc ne lg mw mx my mz bi translated"><strong class="kl is">结账。</strong>在<strong class="kl is"> Git </strong>中，这个命令允许我们创建分支并在它们之间移动。</li><li id="e7eb" class="mr ms ir kl b km na kq nb ku nc ky nd lc ne lg mw mx my mz bi translated"><strong class="kl is">克隆。</strong>它允许我们在本地获得存储库的副本，以便能够使用它。</li><li id="fc63" class="mr ms ir kl b km na kq nb ku nc ky nd lc ne lg mw mx my mz bi translated">提交。这是对代码所做的一组变更的提交。该确认包含这些更改以及一条描述性消息和一些附加信息(作者、日期……)。</li><li id="a02b" class="mr ms ir kl b km na kq nb ku nc ky nd lc ne lg mw mx my mz bi translated"><strong class="kl is">冲突。</strong>这是一个集成更改的问题，来自不同来源的更改需要在同一个文档中进行，而系统无法解决这个问题。在这种情况下，必须解决冲突的是开发商自己。</li><li id="2941" class="mr ms ir kl b km na kq nb ku nc ky nd lc ne lg mw mx my mz bi translated"><strong class="kl is">差异(变化)。</strong>变化或差异对应于代码的特定变化。版本控制是通过跟踪文件版本之间的差异来完成的。</li><li id="0b31" class="mr ms ir kl b km na kq nb ku nc ky nd lc ne lg mw mx my mz bi translated"><strong class="kl is">头。</strong> Head指的是存储库一直处于的提交(通常与工作分支中的最后一次提交一致)。</li><li id="13dc" class="mr ms ir kl b km na kq nb ku nc ky nd lc ne lg mw mx my mz bi translated"><strong class="kl is">合并。</strong> Merge是两个分支的合并，也就是当我们想把一个分支的代码中所做的更改整合到另一个分支的时候。例如，集成一个分支的变更，在这个分支中，我们向主分支添加了新的功能。</li><li id="c1b3" class="mr ms ir kl b km na kq nb ku nc ky nd lc ne lg mw mx my mz bi translated"><strong class="kl is">拉。</strong>这是推送的反向过程，所实现的是将代码从中央存储库下载到本地存储库进行更新。</li><li id="17d6" class="mr ms ir kl b km na kq nb ku nc ky nd lc ne lg mw mx my mz bi translated"><strong class="kl is">拉请求。</strong>这是向代码所有者提出的请求，要求用我们的更改更新代码。</li><li id="294e" class="mr ms ir kl b km na kq nb ku nc ky nd lc ne lg mw mx my mz bi translated"><strong class="kl is">推。</strong>它允许我们将本地存储库中的代码更改上传到中央存储库进行更新，以便其他开发人员可以下载。</li><li id="3111" class="mr ms ir kl b km na kq nb ku nc ky nd lc ne lg mw mx my mz bi translated"><strong class="kl is">储存库。这是存储代码和已做更改历史的地方。</strong></li><li id="03aa" class="mr ms ir kl b km na kq nb ku nc ky nd lc ne lg mw mx my mz bi translated"><strong class="kl is">标记(标签)。</strong>顾名思义，它允许我们标记一个项目的不同版本，以便能够更容易地识别它们(例如，它们经常用于发布到生产的项目版本)。</li></ul><h1 id="543f" class="lo lp ir bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">让我们开始吧</h1><p id="dd04" class="pw-post-body-paragraph kj kk ir kl b km mm ko kp kq mn ks kt ku mo kw kx ky mp la lb lc mq le lf lg ik bi translated">了解了一些词汇之后，让我们看看如何开始以一种基本的方式在我们的项目中使用git。</p><p id="9955" class="pw-post-body-paragraph kj kk ir kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ik bi translated">首先，我们为项目创建一个目录:</p><pre class="kf kg kh ki gu nf ng nh ni aw nj bi"><span id="45d7" class="nk lp ir ng b gz nl nm l nn no">$ mkdir gitexample<br/>$ cd gitexample</span></pre><p id="7606" class="pw-post-body-paragraph kj kk ir kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ik bi translated">接下来，我们用<strong class="kl is"> <em class="np"> git init </em> </strong>初始化存储库:</p><pre class="kf kg kh ki gu nf ng nh ni aw nj bi"><span id="8b3e" class="nk lp ir ng b gz nl nm l nn no">$ git init<br/>Initialized empty Git repository in /home/username/gitexample/.git/</span></pre><p id="3555" class="pw-post-body-paragraph kj kk ir kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ik bi translated">现在我们将创建一个文件，并使用<strong class="kl is"> <em class="np"> git add </em> </strong>将其添加到存储库中:</p><pre class="kf kg kh ki gu nf ng nh ni aw nj bi"><span id="3be6" class="nk lp ir ng b gz nl nm l nn no">$ touch readme.md<br/>$ git add readme.md</span></pre><p id="dce2" class="pw-post-body-paragraph kj kk ir kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ik bi translated"><strong class="kl is"> <em class="np"> git add </em> </strong>让我们能够准备变更以便能够在以后确认它们。使用最多的选项有<em class="np">{文件} </em>、<em class="np">{目录} </em>，或者<strong class="kl is"> <em class="np"> git add。</em> </strong>，即添加所有文件。</p><p id="d1cd" class="pw-post-body-paragraph kj kk ir kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ik bi translated">我们现在要做的是使用git commit来修复所做的修改:</p><pre class="kf kg kh ki gu nf ng nh ni aw nj bi"><span id="6ede" class="nk lp ir ng b gz nl nm l nn no">$ git commit -m “Added readme.md”<br/>[master (root-commit) cdd097f] Added readme.md<br/>1 file changed, 0 insertions(+), 0 deletions(-)<br/>create mode 100644 readme.md</span></pre><p id="3170" class="pw-post-body-paragraph kj kk ir kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ik bi translated"><strong class="kl is"> <em class="np"> -m </em></strong></p><p id="e0fb" class="pw-post-body-paragraph kj kk ir kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ik bi translated">现在，我们已经对我们的存储库做了一些更改。要知道它处于什么状态，我们使用<strong class="kl is"> <em class="np"> git status </em> </strong>:</p><pre class="kf kg kh ki gu nf ng nh ni aw nj bi"><span id="05ca" class="nk lp ir ng b gz nl nm l nn no">$ git status<br/>On branch master<br/>nothing to commit, working tree clean</span></pre><p id="bb91" class="pw-post-body-paragraph kj kk ir kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ik bi translated">这告诉我们，我们在<strong class="kl is"> <em class="np">主</em> </strong>分支(这是主分支，也是在存储库启动时创建的分支)中，并且所有的更改都被验证了。</p><p id="137e" class="pw-post-body-paragraph kj kk ir kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ik bi translated">现在，我们将了解如何创建一个分支并在其中定位。例如，让我们创建<strong class="kl is"> <em class="np">开发</em> </strong>分支:</p><pre class="kf kg kh ki gu nf ng nh ni aw nj bi"><span id="e5c7" class="nk lp ir ng b gz nl nm l nn no">$ git branch develop<br/>$ git checkout develop</span></pre><p id="24d7" class="pw-post-body-paragraph kj kk ir kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ik bi translated">这样我们就创建了<strong class="kl is"> <em class="np">开发</em> </strong>分支并移动到它上面。所有这些都可以通过以下命令在一个步骤中完成:</p><pre class="kf kg kh ki gu nf ng nh ni aw nj bi"><span id="a319" class="nk lp ir ng b gz nl nm l nn no">$ git checkout -b develop<br/>Switched to a new branch 'develop'</span></pre><p id="a110" class="pw-post-body-paragraph kj kk ir kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ik bi translated">现在我们假设我们在<em class="np"> readme.md </em>文件中做了一个改变。</p><p id="d33b" class="pw-post-body-paragraph kj kk ir kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ik bi translated">如果我们现在做<strong class="kl is"> <em class="np"> git status </em> </strong>，它返回如下信息:</p><pre class="kf kg kh ki gu nf ng nh ni aw nj bi"><span id="9eb0" class="nk lp ir ng b gz nl nm l nn no">$ git status<br/>On branch develop<br/>Changes not staged for commit:<br/>(use "git add &lt;file&gt;..." to update what will be committed)<br/>(use "git restore &lt;file&gt;..." to discard changes in working directory)<br/>modified:   readme.md<br/>no changes added to commit (use "git add" and/or "git commit -a")</span></pre><p id="57d6" class="pw-post-body-paragraph kj kk ir kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ik bi translated">也就是说，我们在<strong class="kl is"> <em class="np">开发</em> </strong>分支中，并且我们有未验证的变更(并且我们必须这样做)。</p><p id="416d" class="pw-post-body-paragraph kj kk ir kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ik bi translated">因此，我们:</p><pre class="kf kg kh ki gu nf ng nh ni aw nj bi"><span id="1d5f" class="nk lp ir ng b gz nl nm l nn no">$ git add readme.md<br/>$ git commit -m "Updated readme.md"<br/>[develop 94feba9] Updated readme.md<br/> 1 file changed, 1 insertion(+)</span></pre><p id="20db" class="pw-post-body-paragraph kj kk ir kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ik bi translated">好了，现在我们有了包含新的、经过验证的代码的分支，我们希望它也在分支中。我们要做的是转到分支并合并分支:</p><pre class="kf kg kh ki gu nf ng nh ni aw nj bi"><span id="5870" class="nk lp ir ng b gz nl nm l nn no">$ git checkout master<br/>$ git merge --no-ff develop</span></pre><p id="adda" class="pw-post-body-paragraph kj kk ir kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ik bi translated">当我们这样做时，文本编辑器出现，要求我们向<strong class="kl is">合并</strong>添加一条消息。</p><p id="e226" class="pw-post-body-paragraph kj kk ir kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ik bi translated">一旦消息被添加，我们就进入屏幕:</p><pre class="kf kg kh ki gu nf ng nh ni aw nj bi"><span id="8077" class="nk lp ir ng b gz nl nm l nn no">Merge made by the 'recursive' strategy.<br/>readme.md | 1 +<br/>1 file changed, 1 insertion(+)</span></pre><p id="8e3f" class="pw-post-body-paragraph kj kk ir kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ik bi translated">通过使用标志<strong class="kl is">-<em class="np">no-ff</em></strong><em class="np"/>(非快进)，我们将<strong class="kl is"> <em class="np"> develop </em> </strong>合并为<strong class="kl is"><em class="np">master</em></strong>keeping<strong class="kl is"><em class="np">develop</em></strong>。</p><h1 id="e6a7" class="lo lp ir bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">GitFlow:组织您的存储库</h1><p id="0124" class="pw-post-body-paragraph kj kk ir kl b km mm ko kp kq mn ks kt ku mo kw kx ky mp la lb lc mq le lf lg ik bi translated">当我们在一个项目上工作时，尤其是如果我们与更多的开发人员一起工作，有必要建立一个版本控制库的组织系统，它允许我们以敏捷的方式创建新的功能，纠正出现的错误，并集成所有这些以将代码投入生产。</p><p id="d747" class="pw-post-body-paragraph kj kk ir kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ik bi translated">为此，我们将使用由<a class="ae kd" href="https://nvie.com/posts/a-successful-git-branching-model/" rel="noopener ugc nofollow" target="_blank"> Vincent Driessen </a>开发的分支和工作系统，我们从<strong class="kl is"> GitFlow </strong>中了解到该系统。根据这个制度，我们应该有几个主要分支和其他次要或支持分支。</p><figure class="kf kg kh ki gu js gi gj paragraph-image"><div class="gi gj nq"><img src="../Images/5382cab0fa56fe67b5b28ea3f855d8d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*invWp1K4wlEVX9qqUMSxlw.png"/></div><figcaption class="jz ka gk gi gj kb kc bd b be z dk translated"><a class="ae kd" href="https://nvie.com/posts/a-successful-git-branching-model/" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure><h2 id="d80c" class="nk lp ir bd lq nr ns dn lu nt nu dp ly ku nv nw mc ky nx ny mg lc nz oa mk ob bi translated">主(主要)</h2><p id="44eb" class="pw-post-body-paragraph kj kk ir kl b km mm ko kp kq mn ks kt ku mo kw kx ky mp la lb lc mq le lf lg ik bi translated">这个分支包含已经上传到生产环境的每个版本的代码。此外，上传到这个分支的任何代码都必须准备好发布到产品中。</p><h2 id="15d2" class="nk lp ir bd lq nr ns dn lu nt nu dp ly ku nv nw mc ky nx ny mg lc nz oa mk ob bi translated">开发(主)</h2><p id="17df" class="pw-post-body-paragraph kj kk ir kl b km mm ko kp kq mn ks kt ku mo kw kx ky mp la lb lc mq le lf lg ik bi translated">这个分支包括项目的下一个迭代或版本的代码，并且它集成了为该版本开发的新功能。</p><figure class="kf kg kh ki gu js gi gj paragraph-image"><div class="gi gj nq"><img src="../Images/9c6e65da403651cde924054bde76ddc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*gw-OLmUnNgzUzVuP_BPQhA.png"/></div><figcaption class="jz ka gk gi gj kb kc bd b be z dk translated"><a class="ae kd" href="https://nvie.com/posts/a-successful-git-branching-model/" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure><h2 id="234f" class="nk lp ir bd lq nr ns dn lu nt nu dp ly ku nv nw mc ky nx ny mg lc nz oa mk ob bi translated">释放(次要)</h2><p id="eeaf" class="pw-post-body-paragraph kj kk ir kl b km mm ko kp kq mn ks kt ku mo kw kx ky mp la lb lc mq le lf lg ik bi translated">该分支从<strong class="kl is"> develop </strong>派生而来，包含即将发布到生产的版本的代码。在这个分支中，您还可以在发布之前更正任何错误。发布版本后，该分支需要集成到<strong class="kl is">开发</strong>和<strong class="kl is">主</strong>中。</p><p id="3637" class="pw-post-body-paragraph kj kk ir kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ik bi translated">给这个分支命名，常用以下约定:<strong class="kl is">【发布- </strong> <em class="np">【版本号】</em>。例如，要从develop为版本2.3.5创建一个发布分支，我们将执行以下操作:</p><pre class="kf kg kh ki gu nf ng nh ni aw nj bi"><span id="3732" class="nk lp ir ng b gz nl nm l nn no">$ git checkout develop<br/>$ git checkout -b release-2.3.5<br/><br/>Or with a single command:<br/><br/>$ git checkout -b release-2.3.5 develop</span></pre><h2 id="b5b8" class="nk lp ir bd lq nr ns dn lu nt nu dp ly ku nv nw mc ky nx ny mg lc nz oa mk ob bi translated">功能(次要)</h2><p id="845b" class="pw-post-body-paragraph kj kk ir kl b km mm ko kp kq mn ks kt ku mo kw kx ky mp la lb lc mq le lf lg ik bi translated">这些分支，像<strong class="kl is">发布</strong>分支一样，衍生自<strong class="kl is">开发</strong>分支，包含与新功能相对应的代码。它们通常是只存在于每个开发人员的本地存储库中的分支。每当一个特性被最终确定和批准，它的分支就被整合到<strong class="kl is">开发</strong>中。</p><figure class="kf kg kh ki gu js gi gj paragraph-image"><div class="gi gj oc"><img src="../Images/f0f8ff2b5939560c3d3b3f004bd42ec3.png" data-original-src="https://miro.medium.com/v2/resize:fit:500/format:webp/1*tJXuBdJ7BAl_8kQpNLuZTQ.png"/></div><figcaption class="jz ka gk gi gj kb kc bd b be z dk translated"><a class="ae kd" href="https://nvie.com/posts/a-successful-git-branching-model/" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure><p id="3236" class="pw-post-body-paragraph kj kk ir kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ik bi translated">按照惯例，这类分支被命名为<strong class="kl is">feature/</strong>{<em class="np">feature name }</em>。例如，要创建包含同步用户信息功能的分支，我们可以执行以下操作:</p><pre class="kf kg kh ki gu nf ng nh ni aw nj bi"><span id="cdc9" class="nk lp ir ng b gz nl nm l nn no">$ git checkout develop<br/>$ git checkout -b feature/userinfosync<br/><br/>Or with a single command:<br/><br/>$ git checkout -b feature/userinfosync develop</span></pre><h2 id="c45b" class="nk lp ir bd lq nr ns dn lu nt nu dp ly ku nv nw mc ky nx ny mg lc nz oa mk ob bi translated">修补程序(辅助)</h2><p id="b107" class="pw-post-body-paragraph kj kk ir kl b km mm ko kp kq mn ks kt ku mo kw kx ky mp la lb lc mq le lf lg ik bi translated">创建一个<strong class="kl is">热修复</strong>分支是为了纠正生产代码中一个急需修复的bug。这就是为什么它来自于<strong class="kl is">主</strong>分支，并且一旦被纠正，就被集成到<strong class="kl is">主</strong>分支和开发<strong class="kl is">分支</strong>中。</p><figure class="kf kg kh ki gu js gi gj paragraph-image"><div class="gi gj nq"><img src="../Images/5f8d408ad4fc9ef7fa2d1944da1495ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*9JMw4wqJPfXUqXnHLozLlw.png"/></div><figcaption class="jz ka gk gi gj kb kc bd b be z dk translated"><a class="ae kd" href="https://nvie.com/posts/a-successful-git-branching-model/" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure><p id="0646" class="pw-post-body-paragraph kj kk ir kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ik bi translated">这些分支的命名遵循与<strong class="kl is">版本</strong>分支相似的模式:<strong class="kl is">热修复- </strong> <em class="np">【新版本号】</em>。因此，如果我们必须在2.3版本中制作一个修补程序，我们将以如下方式创建<strong class="kl is">修补程序</strong>分支:</p><p id="775e" class="pw-post-body-paragraph kj kk ir kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ik bi translated">也就是说，从<strong class="kl is">主</strong>我们创建一个<strong class="kl is">热修复</strong>分支，其值为将被上传到生产环境的新版本的值(旧版本为2.3，修正后的版本为2.3.1)。</p><pre class="kf kg kh ki gu nf ng nh ni aw nj bi"><span id="a5cd" class="nk lp ir ng b gz nl nm l nn no">$ git checkout master<br/>$ git checkout -b hotfix-2.3.1<br/><br/>Or with a single command:<br/><br/>$ git checkout -b hotfix-2.3.1 master</span></pre><h1 id="94d7" class="lo lp ir bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">标记主分支</h1><p id="2d8c" class="pw-post-body-paragraph kj kk ir kl b km mm ko kp kq mn ks kt ku mo kw kx ky mp la lb lc mq le lf lg ik bi translated">每当我们将一个版本发布到生产环境中，并在主分支中集成代码时，强烈建议对该集成进行标记，以便我们可以识别每个版本的最终代码。</p><p id="eff3" class="pw-post-body-paragraph kj kk ir kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ik bi translated">为此我们将使用<strong class="kl is"> <em class="np"> git tag </em> </strong>命令。例如，如果我们想要在master中标记版本2.3.1代码，我们将执行以下操作:</p><pre class="kf kg kh ki gu nf ng nh ni aw nj bi"><span id="bbb6" class="nk lp ir ng b gz nl nm l nn no">$ git tag -a 2.3.1 -m "Version 2.3.1"</span></pre><p id="c5c5" class="pw-post-body-paragraph kj kk ir kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ik bi translated">我们用<strong class="kl is"> -a </strong>标记了版本，用<strong class="kl is"> -m </strong>添加了信息。</p><h1 id="b231" class="lo lp ir bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">GitFlow实现的Git扩展</h1><p id="ea05" class="pw-post-body-paragraph kj kk ir kl b km mm ko kp kq mn ks kt ku mo kw kx ky mp la lb lc mq le lf lg ik bi translated">我们刚刚看到了一系列允许我们管理代码库的命令:创建分支，在它们之间移动，集成它们……但是多亏了一系列的<strong class="kl is"> git </strong>扩展，我们可以用一种更简单的方式来完成所有这些。为此，我们只需在我们的计算机上安装。</p><p id="8245" class="pw-post-body-paragraph kj kk ir kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ik bi translated">git-flow文档解释了如何在不同的环境中安装这些扩展。在<em class="np"> macOS </em>的情况下，我们可以用:</p><pre class="kf kg kh ki gu nf ng nh ni aw nj bi"><span id="c19a" class="nk lp ir ng b gz nl nm l nn no">$ brew install git-flow</span></pre><p id="4e94" class="pw-post-body-paragraph kj kk ir kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ik bi translated">安装完成后，我们可以使用以下命令初始化一个具有基本分支结构的存储库:</p><pre class="kf kg kh ki gu nf ng nh ni aw nj bi"><span id="c0b3" class="nk lp ir ng b gz nl nm l nn no">$ git flow init</span></pre><p id="e6f0" class="pw-post-body-paragraph kj kk ir kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ik bi translated">并回答向我们提出的问题:</p><pre class="kf kg kh ki gu nf ng nh ni aw nj bi"><span id="141b" class="nk lp ir ng b gz nl nm l nn no">Which branch should be used for bringing forth production releases?<br/>   - devel<br/>   - master<br/>Branch name for production releases: [master]<br/><br/>Which branch should be used for integration of the "next release"?<br/>   - devel<br/>Branch name for "next release" development: [master] devel<br/><br/>How to name your supporting branch prefixes?<br/>Feature branches? [feature/]<br/>Release branches? [release/]<br/>Hotfix branches? [hotfix/]<br/>Support branches? [support/]<br/>Version tag prefix? []</span></pre><h1 id="a9cb" class="lo lp ir bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">用git-flow管理不同的分支</h1><h1 id="5a3e" class="lo lp ir bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">特征</h1><pre class="kf kg kh ki gu nf ng nh ni aw nj bi"><span id="d673" class="nk lp ir ng b gz nl nm l nn no">$ git flow feature</span></pre><p id="6dd1" class="pw-post-body-paragraph kj kk ir kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ik bi translated">它向我们显示了所有<strong class="kl is">特征</strong>类型分支的列表。</p><pre class="kf kg kh ki gu nf ng nh ni aw nj bi"><span id="48ba" class="nk lp ir ng b gz nl nm l nn no">$ git flow feature</span></pre><p id="a33e" class="pw-post-body-paragraph kj kk ir kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ik bi translated">使用该指令，我们创建一个名为<em class="np">{功能名称} </em>的新分支，该分支从该分支中派生并定位我们。</p><pre class="kf kg kh ki gu nf ng nh ni aw nj bi"><span id="afa4" class="nk lp ir ng b gz nl nm l nn no">$ git flow feature finish {feature_name}</span></pre><p id="8062" class="pw-post-body-paragraph kj kk ir kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ik bi translated">该命令<strong class="kl is">将</strong><em class="np">{ feature _ name }</em>分支合并到分支中，将我们定位在分支中，并删除<em class="np"> {feature_name </em> }分支。</p><pre class="kf kg kh ki gu nf ng nh ni aw nj bi"><span id="482f" class="nk lp ir ng b gz nl nm l nn no">$ git flow feature publish {feature_name}</span></pre><p id="2586" class="pw-post-body-paragraph kj kk ir kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ik bi translated">该命令用于将<em class="np"> {feature_name} </em>分支发布到远程存储库。</p><pre class="kf kg kh ki gu nf ng nh ni aw nj bi"><span id="5349" class="nk lp ir ng b gz nl nm l nn no">$ git flow feature publish {feature_name}</span></pre><p id="dd6e" class="pw-post-body-paragraph kj kk ir kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ik bi translated">使用此命令，我们从远程存储库下载分支<em class="np"> {feature_name} </em>。</p><h1 id="34f3" class="lo lp ir bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">释放；排放；发布</h1><pre class="kf kg kh ki gu nf ng nh ni aw nj bi"><span id="c102" class="nk lp ir ng b gz nl nm l nn no">$ git flow release</span></pre><p id="8656" class="pw-post-body-paragraph kj kk ir kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ik bi translated">它向我们显示了所有<strong class="kl is">版本</strong>类型分支的列表。</p><pre class="kf kg kh ki gu nf ng nh ni aw nj bi"><span id="1660" class="nk lp ir ng b gz nl nm l nn no">$ git flow release start {release_name} [BASE]</span></pre><p id="09de" class="pw-post-body-paragraph kj kk ir kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ik bi translated">使用此指令，我们创建一个名为<em class="np"> {release_name} </em>的新分支，它从该分支中派生并定位我们。<em class="np">【BASE】</em>是一个可选值，对应于我们希望从其派生该分支的集成(<strong class="kl is">提交</strong>)的<em class="np"> sha1散列</em>。</p><pre class="kf kg kh ki gu nf ng nh ni aw nj bi"><span id="837f" class="nk lp ir ng b gz nl nm l nn no">$ git flow release publish {release_name}</span></pre><p id="d2f2" class="pw-post-body-paragraph kj kk ir kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ik bi translated">这个命令执行不同的任务:它用<em class="np"> {release_name} </em>标记分支，将<em class="np"> {release_name} </em>分支合并到分支和分支中，最后删除分支(记得用git push origin — tags发布标签)。</p><p id="7b8f" class="pw-post-body-paragraph kj kk ir kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ik bi translated">该命令用于将分支<em class="np"> {release_name} </em>发布到远程存储库。</p><h1 id="570e" class="lo lp ir bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">修补程序</h1><pre class="kf kg kh ki gu nf ng nh ni aw nj bi"><span id="5bcd" class="nk lp ir ng b gz nl nm l nn no">$ git flow hotfix</span></pre><p id="02da" class="pw-post-body-paragraph kj kk ir kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ik bi translated">它向我们显示了所有<strong class="kl is">热修复</strong>类型分支的列表。</p><pre class="kf kg kh ki gu nf ng nh ni aw nj bi"><span id="f290" class="nk lp ir ng b gz nl nm l nn no">$ git flow hotfix start {version} [BASE]</span></pre><p id="c53a" class="pw-post-body-paragraph kj kk ir kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ik bi translated">使用该指令，我们创建一个名为<em class="np"> {version} </em>的新分支，该分支从<strong class="kl is">主</strong>派生，并将我们放置在该分支中。</p><pre class="kf kg kh ki gu nf ng nh ni aw nj bi"><span id="4366" class="nk lp ir ng b gz nl nm l nn no">$ git flow hotfix finish {version}</span></pre><p id="dff3" class="pw-post-body-paragraph kj kk ir kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg ik bi translated">该命令执行不同的任务:用<em class="np">{ version }</em><strong class="kl is">标记分支，将</strong><em class="np">{ version }</em>分支合并到<strong class="kl is">开发</strong>分支和<strong class="kl is">主</strong>分支中。它还用<strong class="kl is">热修复</strong>版本标记<strong class="kl is">主</strong>分支。</p></div></div>    
</body>
</html>