<html>
<head>
<title>JavaScript Refactoring — Objects and Values</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript重构—对象和值</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-refactoring-objects-and-values-ea1aa7371360?source=collection_archive---------24-----------------------#2020-05-24">https://levelup.gitconnected.com/javascript-refactoring-objects-and-values-ea1aa7371360?source=collection_archive---------24-----------------------#2020-05-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/6e351cdfb023ed4e5c71806d976c14a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*t6-QZ6Jezx8T5zCT"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@dncerullo?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">丹妮尔·塞鲁洛</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="73c4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以清理我们的JavaScript代码，这样我们可以更容易地使用它们。</p><p id="8fa5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将研究一些与清理JavaScript类和对象相关的重构思想。</p><h1 id="f3c4" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">用符号常数替换幻数</h1><p id="0f84" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">如果我们有许多重复的值，它们有相同的含义，但没有明确地说明，那么我们应该把它们变成一个常数，这样每个人都知道它们的含义，如果需要改变，我们只需要改变一个地方。</p><p id="96e6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，不写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="d63a" class="mq lf it mm b gy mr ms l mt mu">const getWeight = (mass) =&gt; mass * 9.81</span><span id="5c19" class="mq lf it mm b gy mv ms l mt mu">const potentialEnergy = (mass, height) =&gt; mass * height * 9.81</span></pre><p id="83a5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们写道:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="4b8c" class="mq lf it mm b gy mr ms l mt mu">const GRAVITATIONAL_CONSTANT = 9.81;</span><span id="f92c" class="mq lf it mm b gy mv ms l mt mu">const getWeight = (mass) =&gt; mass * GRAVITATIONAL_CONSTANT</span><span id="3e9c" class="mq lf it mm b gy mv ms l mt mu">const potentialEnergy = (mass, height) =&gt; mass * height * GRAVITATIONAL_CONSTANT</span></pre><p id="6373" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们知道9.81其实就是<code class="fe mw mx my mm b">GRAVITATIONAL_CONSTANT</code>的意思，不用赘述。</p><h1 id="acfc" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">封装字段</h1><p id="4a7d" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以向字段添加getters和setters来访问类字段，而不是直接操作它。</p><p id="0bff" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，不写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="3f3e" class="mq lf it mm b gy mr ms l mt mu">class Person {<br/>  constructor(name) {<br/>    this.name = name;<br/>  }<br/>}</span></pre><p id="daae" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们写道:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="0ea9" class="mq lf it mm b gy mr ms l mt mu">class Person {<br/>  constructor(name) {<br/>    this._name = _name;<br/>  }</span><span id="75bf" class="mq lf it mm b gy mv ms l mt mu">  get name() {<br/>    return this._name;<br/>  }</span><span id="d4ea" class="mq lf it mm b gy mv ms l mt mu">  set name(name) {<br/>    this._name = name;<br/>  }<br/>}</span></pre><p id="f8b5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这样，我们可以控制如何设置值，因为我们可以在setter中放置代码来设置<code class="fe mw mx my mm b">name</code>。</p><p id="a3c4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还可以控制谁可以获得名称，因为它是在getter中返回的。</p><h1 id="ab72" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">封装集合</h1><p id="ef6e" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们还可以封装作为类实例一部分的数组。</p><p id="142e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，不写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="57cd" class="mq lf it mm b gy mr ms l mt mu">class Person {<br/>  constructor(friends) {<br/>    this._friends = _friends;<br/>  }</span><span id="5635" class="mq lf it mm b gy mv ms l mt mu">  get friends() {<br/>    return this._friends;<br/>  }</span><span id="06b7" class="mq lf it mm b gy mv ms l mt mu">  set friends(friends) {<br/>    this._friends = friends;<br/>  }<br/>}</span><span id="0862" class="mq lf it mm b gy mv ms l mt mu">const person = new Person(['joe', 'jane'])</span></pre><p id="372a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们有一个数组，而不是上面的另一种类型的对象。</p><p id="4fb8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但想法是一样的。</p><h1 id="b6f1" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">用数据类替换记录</h1><p id="8219" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以用一个字段自己的数据类来替换它，这样我们在记录数据时就可以有更大的灵活性。</p><p id="9e22" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，不写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="f6e3" class="mq lf it mm b gy mr ms l mt mu">class Person {<br/>  constructor(name, bloodGroup) {<br/>    this.name = name;<br/>    this.bloodGroup = bloodGroup;<br/>  }<br/>}</span><span id="13c9" class="mq lf it mm b gy mv ms l mt mu">const person = new Person('joe', 'a')</span></pre><p id="3594" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们写道:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="7e19" class="mq lf it mm b gy mr ms l mt mu">class BloodGroup {<br/>  constructor(name) {<br/>    this.bloodGroup = name;<br/>  }<br/>}</span><span id="2b6f" class="mq lf it mm b gy mv ms l mt mu">class Person {<br/>  constructor(name, bloodGroup) {<br/>    this.name = name;<br/>    this.bloodGroup = bloodGroup;<br/>  }<br/>}</span><span id="39e3" class="mq lf it mm b gy mv ms l mt mu">const bloodGroup = new BloodGroup('a');<br/>const person = new Person('joe', bloodGroup)</span></pre><p id="82c9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这样，我们可以在<code class="fe mw mx my mm b">bloodGroup</code>字段中存储更多种类的数据。</p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/2daf999773c796b5c2a57869d74739d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*R9Gc2YSOR7R94dTM"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@neonbrand?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> NeONBRAND </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="b5d2" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">用状态/策略替换类型代码</h1><p id="bdc3" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们根据对象的类型创建子类，而不是在类中有一个类型字段。</p><p id="d053" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这样，我们可以拥有更多两个类在自己的子类中不共享的成员。</p><p id="a9f6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，不写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="66d3" class="mq lf it mm b gy mr ms l mt mu">class Animal {<br/>  constructor(type) {<br/>    this.type = type;<br/>  }<br/>}</span><span id="058f" class="mq lf it mm b gy mv ms l mt mu">const cat = new Animal('cat');<br/>const dog = new Animal('dog');</span></pre><p id="e383" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们写道:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="7395" class="mq lf it mm b gy mr ms l mt mu">class Animal {<br/>  //...<br/>}</span><span id="2bbc" class="mq lf it mm b gy mv ms l mt mu">class Cat extends Animal {<br/>  //...<br/>}</span><span id="a720" class="mq lf it mm b gy mv ms l mt mu">class Dog extends Animal {<br/>  //...<br/>}</span><span id="9e28" class="mq lf it mm b gy mv ms l mt mu">const cat = new Cat();<br/>const dog = new Dog();</span></pre><p id="94f2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的例子中，我们没有写一个<code class="fe mw mx my mm b">Animal</code>类，而是写了<code class="fe mw mx my mm b">Cat</code>和<code class="fe mw mx my mm b">Dog</code>类，它们是<code class="fe mw mx my mm b">Animal</code>类的子类。</p><p id="147b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过这种方式，我们可以拥有他们自己的类中没有共享的成员，而他们共享的成员仍然在<code class="fe mw mx my mm b">Animal</code>类中。</p><h1 id="e8eb" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">分解条件</h1><p id="f5dc" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以把长的条件表达式分解成更小的条件表达式，命名为。</p><p id="2bb4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，不写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="5226" class="mq lf it mm b gy mr ms l mt mu">let ieIEMac = navigator.userAgent.toLowerCase().includes("mac") &amp;&amp; navigator.userAgent.toLowerCase().includes("ie")</span></pre><p id="f3c9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们写道:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="ba33" class="mq lf it mm b gy mr ms l mt mu">let userAgent = navigator.userAgent.toLowerCase();<br/>let isMac = userAgent.includes("mac");<br/>let isIE = userAgent.toLowerCase().includes("ie");<br/>let isMacIE = isMac &amp;&amp; isIE;</span></pre><p id="9490" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们打破了条件表达式，将更小的表达式分配到它们自己的变量中，然后将它们组合起来，使一切更容易阅读。</p><h1 id="9494" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="cbda" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">如果我们有幻数，我们应该用命名的常数来代替它们。</p><p id="2217" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们应该为类字段添加getter和setter方法，这样我们就可以控制如何返回或设置它们。</p><p id="472c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们有<code class="fe mw mx my mm b">type</code>字段，我们可以用它们自己的子类替换它们。</p><p id="4fca" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我们可以把长的条件表达式分解成更小的表达式，这样更容易阅读和理解。</p></div></div>    
</body>
</html>