<html>
<head>
<title>JavaScript Basics — Regex</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript基础—正则表达式</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-basics-regexes-d544cfb99fc7?source=collection_archive---------10-----------------------#2020-06-13">https://levelup.gitconnected.com/javascript-basics-regexes-d544cfb99fc7?source=collection_archive---------10-----------------------#2020-06-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/669f959bf4d0ca953ff49ffdaac92b7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IyjOKOzsooZFStXA"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">安德斯·吉尔登在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="d5b1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">JavaScript是世界上最流行的编程语言之一。为了有效地使用它，我们必须了解它的基本知识。</p><p id="c189" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将看看如何定义和使用正则表达式。</p><h1 id="c01a" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">分组子表达式</h1><p id="60b4" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以用括号将子表达式分组。</p><p id="c5e9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="15bc" class="mq lf it mm b gy mr ms l mt mu">/foo+(bar)+/i.test('foobar')</span></pre><p id="efea" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mv mw mx mm b">+</code>适用于任何带括号或括号前的字符。</p><p id="46f0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<code class="fe mv mw mx mm b">o</code>的情况下，<code class="fe mv mw mx mm b">+</code>应用于<code class="fe mv mw mx mm b">o</code>。</p><p id="60b3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第二个<code class="fe mv mw mx mm b">+</code>是<code class="fe mv mw mx mm b">bar</code>。</p><p id="9160" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为<code class="fe mv mw mx mm b">'bar'</code>和<code class="fe mv mw mx mm b">'o'</code>是字符串的一部分，所以模式匹配，所以表达式返回<code class="fe mv mw mx mm b">true</code>。</p><h1 id="3503" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">匹配和分组</h1><p id="62a6" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以使用<code class="fe mv mw mx mm b">exec</code>方法从字符串中返回匹配项。</p><p id="fec1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="7ff8" class="mq lf it mm b gy mr ms l mt mu">/\d+/.exec("200 100");</span></pre><p id="abe9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们得到作为匹配返回的<code class="fe mv mw mx mm b">['200']</code>。</p><p id="b81b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它还有一个<code class="fe mv mw mx mm b">index</code>属性，返回匹配的字符串索引。</p><p id="b919" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="a152" class="mq lf it mm b gy mr ms l mt mu">const match = /\d+/.exec("200 100");<br/>console.log(match.index);</span></pre><p id="a97e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们在控制台日志中得到0，因为这是匹配的第一个索引。</p><p id="20d0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">字符串有一个做同样事情的<code class="fe mv mw mx mm b">match</code>方法。</p><p id="3f4e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="22c9" class="mq lf it mm b gy mr ms l mt mu">"200 100".match(/\d+/)</span></pre><p id="4a3e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们得到了同样的结果。</p><p id="965e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们有一个没有匹配的模式，那么索引将是<code class="fe mv mw mx mm b">undefined</code>。</p><p id="4dbe" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="62e2" class="mq lf it mm b gy mr ms l mt mu">/correct(ly)?/.exec("correct")</span></pre><p id="3aa1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们得到:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="c3db" class="mq lf it mm b gy mr ms l mt mu">['correct', undefined]</span></pre><h1 id="5d95" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">日期</h1><p id="7361" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">JavaScript的标准库有代表时间点的<code class="fe mv mw mx mm b">Date</code>类。</p><p id="36d2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要获得当前日期和时间，我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="a4cd" class="mq lf it mm b gy mr ms l mt mu">new Date()</span></pre><p id="10d1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还可以传入参数来创建一个特定的日期。</p><p id="a6dc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="51f9" class="mq lf it mm b gy mr ms l mt mu">new Date(2020, 0, 2)</span></pre><p id="10fe" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这将返回:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="04ae" class="mq lf it mm b gy mr ms l mt mu">Thu Jan 02 2020 00:00:00 GMT-0800 (Pacific Standard Time)</span></pre><p id="0d0b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第二个参数是月份。0表示一月。十二月份一直到11点。</p><p id="ddb7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以为小时、分钟、秒和毫秒再传入4个参数。</p><p id="0fbf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="6145" class="mq lf it mm b gy mr ms l mt mu">new Date(2020, 0, 2, 1, 1, 1, 500)</span></pre><p id="165f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们得到:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="79d6" class="mq lf it mm b gy mr ms l mt mu">Thu Jan 02 2020 01:01:01 GMT-0800 (Pacific Standard Time)</span></pre><p id="898b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以使用<code class="fe mv mw mx mm b">getTime</code>方法返回UTC 1970年1月1日以来的毫秒数，也就是UNIX时间。</p><p id="4506" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以通过书写来使用它:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="ac2e" class="mq lf it mm b gy mr ms l mt mu">new Date(2020, 0, 2).getTime()</span></pre><p id="cf68" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">并获得1577952000000。</p><p id="d58e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">其他有用的方法还有<code class="fe mv mw mx mm b">getFullYear</code>、<code class="fe mv mw mx mm b">getMonth</code>、<code class="fe mv mw mx mm b">getDate</code>、<code class="fe mv mw mx mm b">getHours</code>、<code class="fe mv mw mx mm b">getMinutes</code>、<code class="fe mv mw mx mm b">getSeconds</code>来得到他们的零件。</p><p id="702e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以使用单词边界来提取精确的单词。</p><p id="e88e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="6471" class="mq lf it mm b gy mr ms l mt mu">/\bcat\b/.test("bobcat")</span></pre><p id="0fea" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它返回<code class="fe mv mw mx mm b">false</code>。</p><p id="01ad" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mv mw mx mm b">\b</code>是字界图案。</p><p id="40be" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是反对:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="6c86" class="mq lf it mm b gy mr ms l mt mu">/cat/.test("bobcat")</span></pre><p id="5f91" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">返回<code class="fe mv mw mx mm b">true</code>。</p><h1 id="a1dd" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">选择模式</h1><p id="0da5" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以使用<code class="fe mv mw mx mm b">|</code>符号来表示它所分隔的选项之间的匹配。</p><p id="964a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="cf93" class="mq lf it mm b gy mr ms l mt mu">/dog|cat/.test('dog cat');</span></pre><p id="2345" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们得到<code class="fe mv mw mx mm b">true</code>。</p><h1 id="48b5" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">替换方法</h1><p id="b9f8" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">字符串有一个<code class="fe mv mw mx mm b">replace</code>方法，让我们在字符串中搜索模式并替换它们。</p><p id="0a3f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="71f6" class="mq lf it mm b gy mr ms l mt mu">'foobar'.replace(/[foo]/g, 'a')</span></pre><p id="64aa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们得到:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="d0e5" class="mq lf it mm b gy mr ms l mt mu">"aaabar"</span></pre><p id="ce95" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它用<code class="fe mv mw mx mm b">a</code>替换了<code class="fe mv mw mx mm b">foo</code>实例。</p><p id="14f2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们也可以使用它和特殊字符来放置匹配的字符串。</p><p id="4327" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="2824" class="mq lf it mm b gy mr ms l mt mu">'12 456'.replace(/(\d{2}) (\d{3})/g, '$1')</span></pre><p id="a5ad" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们得到<code class="fe mv mw mx mm b">'12'</code>，因为我们只取了第一个组，并把它放入带有<code class="fe mv mw mx mm b">$1</code>的替换字符串中。</p><h1 id="b3ce" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">贪婪</h1><p id="0e44" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们从一个字符串中串出所有匹配的条目。</p><p id="9d2d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以删除字符串中的所有数字:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="e5fb" class="mq lf it mm b gy mr ms l mt mu">'123 abc'.replace(/\d+/g, '')</span></pre><p id="4f9b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们得到返回的<code class="fe mv mw mx mm b">' abc'</code>。</p><h1 id="da03" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">动态创建RegExp对象</h1><p id="dc16" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以使用<code class="fe mv mw mx mm b">RegExp</code>构造函数来动态创建正则表达式。</p><p id="6003" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以通过书写来使用它:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="7491" class="mq lf it mm b gy mr ms l mt mu">const re = new RegExp('/\\d+/', 'g');</span></pre><p id="c12f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们有一个regex对象来全局搜索数字。</p><p id="cb8f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第一个参数是regex字符串，第二个是可选标志。</p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi my"><img src="../Images/3a006d1f18fb8b78d5d2e205e879e369.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*R4JfVU_fYS-735si"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">约瑟夫·冈萨雷斯在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="5fa8" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">搜索方法</h1><p id="71e7" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以使用<code class="fe mv mw mx mm b">search</code>方法来搜索模式。</p><p id="2253" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="0332" class="mq lf it mm b gy mr ms l mt mu">'abc 123'.search(/\d+/g)</span></pre><p id="6055" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们返回4。</p><p id="261d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">无法从0以外的索引开始搜索。</p><h1 id="55e0" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">lastIndexOf</h1><p id="b62d" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以使用<code class="fe mv mw mx mm b">exec</code>方法获得某个模式出现的最后一个索引。</p><p id="43f9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="857c" class="mq lf it mm b gy mr ms l mt mu">const re = /(\d+)/g<br/>re.exec('123 456');<br/>console.log(re.lastIndex)</span></pre><p id="21b2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们首先创建了一个正则表达式，然后对它运行<code class="fe mv mw mx mm b">exec</code>来获得第一个匹配。</p><p id="e160" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们得到3，因为数字的第二个实例从索引3开始。</p><h1 id="0876" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="bf07" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">使用regex对象，我们可以以多种方式搜索项目。</p><p id="b14f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还可以通过使用regex对象进行搜索来替换字符串中的项目。</p></div></div>    
</body>
</html>