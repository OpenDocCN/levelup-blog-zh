# 基于事件的异步编程

> 原文：<https://levelup.gitconnected.com/asynchronous-programming-with-events-ed347e7fa32a>

在本系列的最后两篇文章中，我们研究了各种减少线程阻塞的[多反应器模式](https://medium.com/swlh/overcoming-io-overhead-in-micro-services-47d8f986268b#_reactor_and_multi_reactor)通过运行多个事件循环线程提供了一种解决方法(根据经验，线程数量通常是 CPU 内核数量的两倍)。通过充分利用所有内核，这为系统增加了大量容量，因此阻塞代码和中断数量不再是问题。

# 不是所有东西都可以无阻塞

基于事件的编程范例的前提是，API 不会阻塞线程来完成 IO 操作。通常，这些地方是对远程 API 的网络调用、数据库查询、文件读/写等。实际上，很少可能让我们所有的代码都是非阻塞的。数据库，尤其是 RDBMS，通常对 NIO 的支持很差(主要是因为事务支持的实现方式)。应用程序容器也需要支持异步程序。如果我的 REST 服务返回一个未来的<response>，应用服务器(例如 Tomcat)应该能够理解这一点，并拥有自己相应的事件驱动代码来处理客户端请求。不幸的是，这并没有被广泛采用。</response>

因此，我们不可能总是拥有一个完全基于事件的系统。为了解决这个问题，我们经常在大多数应用程序中看到 NIO(在 API 允许的情况下)、线程池(将阻塞代码转换为异步模式)和普通的旧阻塞代码的组合。

# 我们真的改变了什么吗？

您可能已经注意到，epoll 仍然需要运行一个线程来轮询所有的套接字，这实际上是一个阻塞操作。那么，从某种意义上来说，难道不是还在使用线程池(只有一个线程的线程池)吗？

这是正确的，但事实是我们(即应用程序)不再这样做了。该应用程序完全由事件驱动，操作系统在处理套接字轮询等低级操作方面效率极高。当然，这限制了我们可以执行的操作数量(就像前面提到的数据复制问题一样)，但总体而言，基于事件的风格使应用程序比每个请求一个线程的应用程序更具可伸缩性，并且比线程池风格的应用程序设计得更好。

*如果你喜欢这篇文章，你可以订阅* [*我的邮件列表*](https://www.kislayverma.com/) *来获得最新消息。*