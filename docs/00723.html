<html>
<head>
<title>How to use background script to fetch data in a Chrome extension</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用后台脚本获取Chrome扩展中的数据</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-use-background-script-to-fetch-data-in-chrome-extension-ef9d7f69625d?source=collection_archive---------0-----------------------#2019-07-08">https://levelup.gitconnected.com/how-to-use-background-script-to-fetch-data-in-chrome-extension-ef9d7f69625d?source=collection_archive---------0-----------------------#2019-07-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/06e6dc4a91951db9cba57d9d6197eee6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E3_Npitn4Hi9qedCf5aA5w.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">黑客标签:Chrome扩展，在新标签上查看GitHub趋势项目📈</figcaption></figure><p id="af43" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果你不确定如何编写一个chrome扩展，可以先看看我之前的故事<a class="ae la" rel="noopener ugc nofollow" target="_blank" href="/how-to-use-react-js-to-create-chrome-extension-in-5-minutes-2ddb11899815"> <strong class="ke ir">如何用React.js在5分钟内创建一个跨浏览器扩展</strong> </a>。它教你如何使用create-react-app为新标签页构建一个浏览器扩展。</p><p id="2369" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们构建的扩展很好，但是每次用户打开一个新标签，我们将从API重新加载最新的趋势库，这可能需要几秒钟。即使只需要一秒钟，对于一个新的标签页打开来说仍然很慢。</p><blockquote class="lb"><p id="514e" class="lc ld iq bd le lf lg lh li lj lk kz dk translated">如果我们定期在后台获取数据，将数据保存在localStorage中，并在打开一个新标签时读取它，会怎么样？</p></blockquote><p id="fa82" class="pw-post-body-paragraph kc kd iq ke b kf ll kh ki kj lm kl km kn ln kp kq kr lo kt ku kv lp kx ky kz ij bi translated">我花了几天时间研究它，发现它是完全可行的。在这篇文章中，我将与你分享我在这个过程中所学到的东西。</p><h1 id="6b83" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">1.向manifest.json添加后台脚本</h1><p id="3370" class="pw-post-body-paragraph kc kd iq ke b kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz ij bi translated">后台脚本可以对浏览器事件做出反应并执行某些操作，后台页面在需要时加载，空闲时卸载。要使用背景文件，在<code class="fe mt mu mv mw b">manifest.json</code>文件中声明如下:</p><figure class="my mz na nb gt jr gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/8a08611448a567da108275736e8e7463.png" data-original-src="https://miro.medium.com/v2/resize:fit:1336/format:webp/1*MFhgQocI8gTPcWm3BG1IUw.png"/></div></figure><p id="97e6" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">你会注意到<code class="fe mt mu mv mw b">persistent</code>参数，在扩展的生命周期中存在一个持久的背景页面，并且只有一个实例在Chrome浏览器的背景中运行，等待用户与扩展交互。</p><p id="5323" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">根据<a class="ae la" href="https://developer.chrome.com/extensions/background_migration" rel="noopener ugc nofollow" target="_blank">谷歌开发者文档</a>，更推荐使用非持久模式，它可以帮助降低你的扩展的资源成本。非持久后台脚本是完全基于事件的，它保持休眠状态，直到它们监听的事件触发，对指定的指令做出反应，然后卸载。事件的一些例子包括:</p><ul class=""><li id="86f1" class="nc nd iq ke b kf kg kj kk kn ne kr nf kv ng kz nh ni nj nk bi translated">该扩展首先被安装或更新到新版本，或者浏览器被重新启动。</li><li id="e522" class="nc nd iq ke b kf nl kj nm kn nn kr no kv np kz nh ni nj nk bi translated">背景页正在侦听一个事件，该事件已被调度。(例如，我们将创建<code class="fe mt mu mv mw b"><a class="ae la" href="https://developers.chrome.com/extensions/alarms" rel="noopener ugc nofollow" target="_blank">alarm</a></code>来定期调度事件)</li><li id="3f12" class="nc nd iq ke b kf nl kj nm kn nn kr no kv np kz nh ni nj nk bi translated">内容脚本或其他扩展<a class="ae la" href="https://developer.chrome.com/extensions/messaging" rel="noopener ugc nofollow" target="_blank">发送消息。</a></li><li id="7d3a" class="nc nd iq ke b kf nl kj nm kn nn kr no kv np kz nh ni nj nk bi translated">扩展中的另一个视图，比如弹出窗口，调用<code class="fe mt mu mv mw b"><a class="ae la" href="https://developer.chrome.com/extensions/runtime#method-getBackgroundPage" rel="noopener ugc nofollow" target="_blank">runtime.getBackgroundPage</a></code>。</li></ul><h1 id="33ec" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">2.添加警报以定期触发操作</h1><p id="7cd0" class="pw-post-body-paragraph kc kd iq ke b kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz ij bi translated">您可能熟悉以下定期运行的代码:</p><pre class="my mz na nb gt nq mw nr ns aw nt bi"><span id="0e06" class="nu lr iq mw b gy nv nw l nx ny">window.setInterval(function() {<br/>  console.log('Hello, world!'); <br/>}, 1000 * 60 * 3);</span></pre><p id="fd4c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">上面印着“你好，世界！”每3分钟。为了将其更改为基于事件的警报，我们将使用<a class="ae la" href="https://developer.chrome.com/extensions/alarms" rel="noopener ugc nofollow" target="_blank">警报API </a>来代替。</p><pre class="my mz na nb gt nq mw nr ns aw nt bi"><span id="c8e0" class="nu lr iq mw b gy nv nw l nx ny">chrome.alarms.create('refresh', { periodInMinutes: 3 });</span></pre><p id="4fd1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然后添加一个监听器。</p><pre class="my mz na nb gt nq mw nr ns aw nt bi"><span id="c31f" class="nu lr iq mw b gy nv nw l nx ny">chrome.alarms.onAlarm.addListener((alarm) =&gt; {<br/>  alert("Hello, world!");<br/>});</span></pre><p id="0bb3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们将需要在安装扩展时创建一个警报，以便每3分钟在后台触发一次警报，这是我们到目前为止的<code class="fe mt mu mv mw b">background.js</code>。</p><figure class="my mz na nb gt jr"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="b2d2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">要使用警报，您还需要在<code class="fe mt mu mv mw b">manifest.json</code>中添加<code class="fe mt mu mv mw b">alarms</code>权限</p><figure class="my mz na nb gt jr"><div class="bz fp l di"><div class="nz oa l"/></div></figure><h1 id="d9b4" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">3.调试后台脚本</h1><p id="2def" class="pw-post-body-paragraph kc kd iq ke b kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz ij bi translated">为了测试上述脚本是否能按预期运行，我们需要在本地测试它。这和<a class="ae la" rel="noopener ugc nofollow" target="_blank" href="/how-to-use-react-js-to-create-chrome-extension-in-5-minutes-2ddb11899815">上一个故事</a>中的步骤非常相似。</p><ol class=""><li id="d0fc" class="nc nd iq ke b kf kg kj kk kn ne kr nf kv ng kz ob ni nj nk bi translated">确保开发者模式打开，如上图所示。</li><li id="97b9" class="nc nd iq ke b kf nl kj nm kn nn kr no kv np kz ob ni nj nk bi translated">点击“Load unpacked”，目标文件夹包含您的<code class="fe mt mu mv mw b">manifest.json</code>。</li><li id="b7ee" class="nc nd iq ke b kf nl kj nm kn nn kr no kv np kz ob ni nj nk bi translated">你应该点击<code class="fe mt mu mv mw b">background page</code>,而不是在新标签页上检查，因为背景页正在一个单独的进程中运行。</li><li id="0ec2" class="nc nd iq ke b kf nl kj nm kn nn kr no kv np kz ob ni nj nk bi translated">如果您在本地更改了代码，则需要单击reload。</li></ol><figure class="my mz na nb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oc"><img src="../Images/b7357091cc85b3b6b7dac6a523d2383c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZZGyikrW8ch4wb5RpJrzWg.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">本地测试扩展</figcaption></figure><p id="7ec4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">从下图可以看出，警报每3分钟运行一次。</p><figure class="my mz na nb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi od"><img src="../Images/62c9b8a9122ac95fde9a270d0514312b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bWmCzyGWk-6Hgo96hhGPyw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">检查后台脚本</figcaption></figure><p id="63cb" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">您也可以在这里检查<strong class="ke ir">网络</strong>、<strong class="ke ir">本地存储</strong>。如果您的扩展修改了新标签，本地存储将在您的扩展中共享，这就是我们在后台脚本和新标签扩展之间传递数据的方式。</p><h1 id="b62d" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">4.提取数据并保存到本地存储</h1><p id="5ad4" class="pw-post-body-paragraph kc kd iq ke b kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz ij bi translated">现在我们有一个基本的警报工作，让我们获取数据并保存到本地存储。后来在我们的React扩展中，我们可以在加载时直接从本地存储读取，而不是从API获取。</p><ol class=""><li id="0a09" class="nc nd iq ke b kf kg kj kk kn ne kr nf kv ng kz ob ni nj nk bi translated">我们将创建一个“<strong class="ke ir">刷新</strong>”警报，以便在首次安装或升级扩展时每30分钟获取并保存数据。</li><li id="1fbe" class="nc nd iq ke b kf nl kj nm kn nn kr no kv np kz ob ni nj nk bi translated">我们将在chrome重启时获取数据，以便用户获得最新数据。</li><li id="ff10" class="nc nd iq ke b kf nl kj nm kn nn kr no kv np kz ob ni nj nk bi translated">我们还将每5分钟创建另一个“<strong class="ke ir">看门狗</strong>”警报，以检查刷新警报是否仍然可用，如果不可用，我们将创建它。(这里可能不需要)</li></ol><figure class="my mz na nb gt jr"><div class="bz fp l di"><div class="nz oa l"/></div></figure><h1 id="61b0" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">5.重用逻辑并转换到ES5</h1><p id="9b92" class="pw-post-body-paragraph kc kd iq ke b kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz ij bi translated">上面的代码有两个问题，我们现在需要解决它们:</p><ol class=""><li id="1f17" class="nc nd iq ke b kf kg kj kk kn ne kr nf kv ng kz ob ni nj nk bi translated">请注意，我们没有为<code class="fe mt mu mv mw b">fetchRepositories</code>和<code class="fe mt mu mv mw b">saveToLocalStorage</code>编写实现，它们很可能已经存在于您的React应用程序中，将实现复制到<code class="fe mt mu mv mw b">background.js</code>是很好的，但如果我们能够重用这些函数以保持代码干燥，那会更好。</li><li id="b9a6" class="nc nd iq ke b kf nl kj nm kn nn kr no kv np kz ob ni nj nk bi translated">我们已经使用ES6语法编写了<code class="fe mt mu mv mw b">background.js</code>，比如<code class="fe mt mu mv mw b"><strong class="ke ir">=&gt;</strong></code>和<code class="fe mt mu mv mw b"><strong class="ke ir">async await</strong></code>，旧的浏览器可能无法运行它。</li></ol><p id="041c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这里我们将使用<code class="fe mt mu mv mw b">webpack</code>来帮助将代码捆绑和传输到ES5。</p><h2 id="f00f" class="nu lr iq bd ls oe of dn lw og oh dp ma kn oi oj me kr ok ol mi kv om on mm oo bi translated">5.1安装依赖项</h2><pre class="my mz na nb gt nq mw nr ns aw nt bi"><span id="dbc3" class="nu lr iq mw b gy nv nw l nx ny">yarn add --dev webpack-cli npm-run-all rimraf</span></pre><p id="6de5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">注意，我们不应该安装<code class="fe mt mu mv mw b">webpack.</code> ( <code class="fe mt mu mv mw b">react-scripts</code>已经依赖于它，它会抱怨<code class="fe mt mu mv mw b">webpack</code>的另一个实例)。如果您没有使用<code class="fe mt mu mv mw b">create-react-app</code>，请随意安装它。</p><h2 id="7622" class="nu lr iq bd ls oe of dn lw og oh dp ma kn oi oj me kr ok ol mi kv om on mm oo bi translated">5.2更改构建脚本</h2><p id="aeaa" class="pw-post-body-paragraph kc kd iq ke b kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz ij bi translated">现在更改您的<code class="fe mt mu mv mw b">build</code>脚本来构建您的应用程序和后台脚本:</p><pre class="my mz na nb gt nq mw nr ns aw nt bi"><span id="ac77" class="nu lr iq mw b gy nv nw l nx ny">"prebuild": "rimraf build",<br/>"build": "npm-run-all build:*",<br/>"build:app": "INLINE_RUNTIME_CHUNK=false react-scripts build",<br/>"build:bg": "webpack --mode production ./src/background.js --output ./build/background.js",</span></pre><p id="3766" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们已经在<a class="ae la" rel="noopener ugc nofollow" target="_blank" href="/how-to-use-react-js-to-create-chrome-extension-in-5-minutes-2ddb11899815">之前的教程</a>中介绍过<code class="fe mt mu mv mw b">INLINE_RUNTIME_CHUNK=false</code>。更改后，如果您运行<code class="fe mt mu mv mw b">npm run build</code>，它将执行</p><ul class=""><li id="bafb" class="nc nd iq ke b kf kg kj kk kn ne kr nf kv ng kz nh ni nj nk bi translated">清洁<code class="fe mt mu mv mw b">build</code>文件夹</li><li id="a61a" class="nc nd iq ke b kf nl kj nm kn nn kr no kv np kz nh ni nj nk bi translated">使用<code class="fe mt mu mv mw b">react-script</code>捆绑React扩展</li><li id="ba6e" class="nc nd iq ke b kf nl kj nm kn nn kr no kv np kz nh ni nj nk bi translated">使用webpack捆绑<code class="fe mt mu mv mw b">src/background.js</code>并导出到<code class="fe mt mu mv mw b">build/background.js</code></li></ul><h2 id="7135" class="nu lr iq bd ls oe of dn lw og oh dp ma kn oi oj me kr ok ol mi kv om on mm oo bi translated">5.3重构。/src/背景. js</h2><p id="a3a3" class="pw-post-body-paragraph kc kd iq ke b kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz ij bi translated">在您的<code class="fe mt mu mv mw b">src/background.js</code>中，您可以自由导入任何外部库，如<code class="fe mt mu mv mw b">lodash</code>或从其他文件导入常量/函数，如:</p><pre class="my mz na nb gt nq mw nr ns aw nt bi"><span id="da23" class="nu lr iq mw b gy nv nw l nx ny">import { <br/>  fetchRepositories, <br/>  saveToLocalStorage<br/>} from './lib/helpers';</span><span id="aee1" class="nu lr iq mw b gy op nw l nx ny">chrome.runtime.onInstalled.addListener(() =&gt; {<br/>...</span></pre><p id="03b2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">你的代码现在更干净了。</p><h2 id="9a64" class="nu lr iq bd ls oe of dn lw og oh dp ma kn oi oj me kr ok ol mi kv om on mm oo bi translated">5.4更新ESlint配置</h2><p id="138c" class="pw-post-body-paragraph kc kd iq ke b kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz ij bi translated">如果你在你的编辑器中使用ESLint，它可能会抱怨在你的<code class="fe mt mu mv mw b">./src/background.js</code>中没有定义<code class="fe mt mu mv mw b">chrome</code>。这是因为<code class="fe mt mu mv mw b">chrome</code> API只在扩展中可用，我们需要告诉ESLint我们正在开发扩展，请忽略这些。</p><p id="0722" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在您的<code class="fe mt mu mv mw b">package.json</code>中添加/更新以下行。</p><pre class="my mz na nb gt nq mw nr ns aw nt bi"><span id="b4a1" class="nu lr iq mw b gy nv nw l nx ny">"eslintConfig": {<br/>  "extends": "react-app",<br/>  "env": {<br/>    "browser": true,<br/>    "webextensions": true<br/>  }<br/>}</span></pre><p id="e885" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">把<code class="fe mt mu mv mw b">webextensions</code>加到<code class="fe mt mu mv mw b">env</code>后，编辑就不再抱怨了。</p><h2 id="e99b" class="nu lr iq bd ls oe of dn lw og oh dp ma kn oi oj me kr ok ol mi kv om on mm oo bi translated">5.5添加。巴伯尔克</h2><p id="84f9" class="pw-post-body-paragraph kc kd iq ke b kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz ij bi translated">Webpack将需要一个<code class="fe mt mu mv mw b">.babelrc</code>文件来编译，我们需要手动添加它。因为<code class="fe mt mu mv mw b">react-scripts</code>已经安装了<code class="fe mt mu mv mw b">babel-presets-react-app</code>，我们只需要使用它。</p><pre class="my mz na nb gt nq mw nr ns aw nt bi"><span id="2623" class="nu lr iq mw b gy nv nw l nx ny">{<br/>  "presets": ["react-app"]<br/>}</span></pre><p id="13cd" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在运行<code class="fe mt mu mv mw b">npm run build</code>将会在你的<code class="fe mt mu mv mw b">build</code>文件夹中有你完整的扩展和编译好的后台脚本。</p><h1 id="ba6a" class="lq lr iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">就是这样！</h1><p id="d9ee" class="pw-post-body-paragraph kc kd iq ke b kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ms kx ky kz ij bi translated">如果你好奇的话，你可以在GitHub上查看我的扩展的提交中所有被修改的文件<a class="ae la" href="https://github.com/huchenme/hacker-tab-extension/commit/ff765829f2d96ea5e53265b11d4a27cec4133b5d" rel="noopener ugc nofollow" target="_blank">。</a></p></div><div class="ab cl oq or hu os" role="separator"><span class="ot bw bk ou ov ow"/><span class="ot bw bk ou ov ow"/><span class="ot bw bk ou ov"/></div><div class="ij ik il im in"><p id="227d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">谢谢你读到这里。你可以在<a class="ae la" href="https://github.com/huchenme/hacker-tab-extension" rel="noopener ugc nofollow" target="_blank"> Github </a>中查看源代码，或者在<a class="ae la" href="https://chrome.google.com/webstore/detail/hacker-tab/ibomigipadcieapbemkegkmadbbanbgm" rel="noopener ugc nofollow" target="_blank"> Chrome网络商店</a>和<a class="ae la" href="https://addons.mozilla.org/en-US/firefox/addon/hacker-tab/" rel="noopener ugc nofollow" target="_blank"> Firefox附加组件中心</a>下载扩展，祝你黑客愉快，让我知道你构建了什么！</p></div></div>    
</body>
</html>