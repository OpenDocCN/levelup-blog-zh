<html>
<head>
<title>Swipe Gallery using Vue.js &amp; Tailwind — WotW</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Vue.js和Tailwind推送图库— WotW</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/swipe-gallery-using-vue-js-tailwind-wotw-7819f8a1e4fb?source=collection_archive---------2-----------------------#2019-05-15">https://levelup.gitconnected.com/swipe-gallery-using-vue-js-tailwind-wotw-7819f8a1e4fb?source=collection_archive---------2-----------------------#2019-05-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/e78dc4a8a695a0f6798b354aed24e546.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pnz8Spvbgb4SJe8JhgW80Q.png"/></div></div></figure><p id="09b9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">欢迎来到“每周小部件”系列，在这里我拍摄了令人敬畏的UI/UX组件的gif或视频，并用代码将它们赋予生命。</p><p id="4f4c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">今天，我们将创建一个滑动画廊，既可以使用触摸控制，也可以使用鼠标控制。灵感来自<a class="ae kw" href="https://dribbble.com/CHEN-RONGYU" rel="noopener ugc nofollow" target="_blank">荣宇</a>创作的<a class="ae kw" href="https://dribbble.com/shots/5911272-UI-design" rel="noopener ugc nofollow" target="_blank">投稿</a>，看起来是这样的:</p><p id="0f33" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">本教程面向希望提升技能的前端开发人员。建议你先有一些HTML，CSS，JS的知识。我将使用<a class="ae kw" href="https://vuejs.org/" rel="noopener ugc nofollow" target="_blank"> Vue.js </a>来制作这个小部件，如果你不熟悉这个框架，这些精彩的帖子可以帮助你快速上手:</p><p id="cc8f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于今天的小部件，我们将使用<a class="ae kw" href="https://vuejs.org/" rel="noopener ugc nofollow" target="_blank"> Vue.js </a>，对于一些动画，我们将使用<a class="ae kw" href="https://greensock.com/tweenmax" rel="noopener ugc nofollow" target="_blank"> TweenMax </a>。另外，我将使用新发布的<a class="ae kw" href="https://tailwindcss.com/" rel="noopener ugc nofollow" target="_blank"> TailwindCSS v1.0.1 </a>。如果你想继续，你可以派生这个已经有依赖关系的<a class="ae kw" href="https://codepen.io/ederdiaz/pen/gJgrxB" rel="noopener ugc nofollow" target="_blank"> codepen模板</a>。</p><p id="b440" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，我想做的是约束我们的小部件容器的区域，以匹配移动设备的大小。为此，我将首先编写一些CSS规则:</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><blockquote class="ld le lf"><p id="8da9" class="jy jz lg ka b kb kc kd ke kf kg kh ki lh kk kl km li ko kp kq lj ks kt ku kv ij bi translated">这将是我们整个小部件需要的唯一CSS类…没错，剩下的样式将使用TailwindCSS来完成。</p></blockquote><p id="6530" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，要看到它的工作，我们需要添加一些标记到我们的小部件，让我们开始制作我们的应用程序容器:</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="64dc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这些是一堆TailwindCSS类，如果你习惯于编写CSS规则，它们中的大多数都是不言自明的。从左到右，它们匹配以下CSS规则:</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="bdf4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如你所看到的，我们写了更少的代码，而且我们能够做任何改变，而不必在CSS文件和HTML文件之间跳转。</p><blockquote class="ld le lf"><p id="b7f6" class="jy jz lg ka b kb kc kd ke kf kg kh ki lh kk kl km li ko kp kq lj ks kt ku kv ij bi translated">在本教程的剩余部分，我不会“翻译”每个TailwindCSS类，但我肯定会强调最重要的那些。其余的你可以访问 <a class="ae kw" href="https://tailwindcss.com/" rel="noopener ugc nofollow" target="_blank"> <em class="iq"> TailwindCSS文档</em> </a> <em class="iq">。</em></p></blockquote><p id="4d77" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们利用我们创建的<code class="fe lk ll lm ln b">.mobile-container</code>类:</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="ca88" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们正在使容器<code class="fe lk ll lm ln b">relative</code>能够相对于它移动图库图像，并且<code class="fe lk ll lm ln b">overflow-hidden</code>应该帮助我们隐藏容器框外的任何内容。</p><p id="5650" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们应该有这样的东西:</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lo"><img src="../Images/cefc4b4303dea213ea1432ee1e253917.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*oklCAHg-uAa8XzEe"/></div></div></figure><p id="113d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要开始制作我们的图库，我们需要几张图片，你可以使用我为这个小部件托管的下列图片:</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="c01f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">和本系列中的往常一样，我们需要设置Vue.js来将我们的<code class="fe lk ll lm ln b">js</code>数据绑定到HTML模板，并使我们的小部件具有交互性:</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="8f7a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在没发生什么事情，我只是在我的数据对象中声明了一个属性，它保存了图库中当前项目的索引。</p><p id="35d1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在继续之前，我需要给你看几张图，这应该有助于解释画廊的真实行为。</p><p id="3629" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的图库应该遍历数组中的所有图像，但我们只需要同时拥有3张图像，而不是创建所有的图像:<code class="fe lk ll lm ln b">Previous</code>、<code class="fe lk ll lm ln b">Current</code>和<code class="fe lk ll lm ln b">Next</code></p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lp"><img src="../Images/e074f65d66aa7823bb116780f38e7e8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*aKqB1q3VE-mKitAR"/></div></div></figure><p id="82a7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">每当我们浏览图片时，我们最多只能看到这三张图片，所以我们将对它们做一些“魔术”，让它们看起来像是无限的。</p><p id="3021" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当滑动时有两种结果，您向右拖动当前图像并显示前一个<code class="fe lk ll lm ln b">or</code>拖动下一个图像到当前图像之上:</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lq"><img src="../Images/56e92318edf057f1b336869f5fbfb1a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kIqZTQZS1o2X9XWz"/></div></div></figure><p id="bd93" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将拖动的图像释放到任一侧后，我们需要决定图像是停留在中心，还是离开视口:</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div class="gh gi lr"><img src="../Images/753685c0e9543d669a31d9cbfa87789c.png" data-original-src="https://miro.medium.com/v2/resize:fit:836/0*P59S787E_ExZb-pC"/></div></figure><p id="0cae" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为此，我们将采取图像位置，如果它的一半以上是在视口内，它停留，如果不是，它离开。此外，为了继续使用相同的三个图像，我们应该相应地交换它们。</p><p id="0f73" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们现在知道将要渲染三个图像，我们已经有了<code class="fe lk ll lm ln b">currentImageIndex</code>，但是我们还需要前一个和下一个。此外，如果图像URL可以存储在一个变量中，或者更好地存储在计算属性中，那就太棒了:</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><blockquote class="ld le lf"><p id="0dc7" class="jy jz lg ka b kb kc kd ke kf kg kh ki lh kk kl km li ko kp kq lj ks kt ku kv ij bi translated"><em class="iq">计算属性不是使用方法，而是帮助我们简化组件并提高其性能，</em> <a class="ae kw" href="https://vuejs.org/v2/guide/computed.html" rel="noopener ugc nofollow" target="_blank"> <em class="iq">计算属性基于它们的反应依赖关系进行缓存</em> </a> <em class="iq">。</em></p></blockquote><p id="0bee" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们已经有了开始渲染图像的一切，所以让我们回到HTML部分:</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="a38a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所有三个图像都需要堆叠在前一个之上，这就是为什么我们使用<code class="fe lk ll lm ln b">z-0</code>、<code class="fe lk ll lm ln b">z-10</code>、<code class="fe lk ll lm ln b">z-20</code>和<code class="fe lk ll lm ln b">absolute</code>位置。<code class="fe lk ll lm ln b">h-full</code>类确保图像垂直填充容器的空间。</p><p id="8511" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们有一个小问题，第一张图中所示的<code class="fe lk ll lm ln b">nextImage</code>应该在视口之外(右侧)。我们最终还将制作动画，所以我将把样式属性绑定到一个名为<code class="fe lk ll lm ln b">nextImageStyle</code>的计算属性。</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="6ccd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后我们需要创建那个计算的属性，但是它需要一个引用设备宽度的常量:</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><blockquote class="ld le lf"><p id="ce4f" class="jy jz lg ka b kb kc kd ke kf kg kh ki lh kk kl km li ko kp kq lj ks kt ku kv ij bi translated"><em class="iq">对于这个小部件来说，它是一个硬编码的常量，但是在现实场景中，我们应该能够获得设备宽度并相应地设置这个常量。</em></p></blockquote><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="cfc0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们为样式创建了几个计算属性，这看起来有点夸张，但是它们在制作图像动画时会很有用。在这之后，你应该会看到第一个图像，瀑布，而不是一些绿叶。</p><p id="0b48" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">用户将通过触摸或点击当前图像与我们的图库进行交互，然后它将开始移动光标或手指，之后，他们应该会释放图像。</p><p id="ad8a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是我们需要倾听的三个事件:</p><p id="bc33" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">start事件总是由当前图像触发，但是其他两个事件可以发生在图像内部或图库容器外部。下一步是监听这些事件，并使其能够在移动和桌面设备上工作，我们不仅需要监听触摸事件，还需要监听鼠标事件:</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><blockquote class="ld le lf"><p id="9954" class="jy jz lg ka b kb kc kd ke kf kg kh ki lh kk kl km li ko kp kq lj ks kt ku kv ij bi translated">注意 <code class="fe lk ll lm ln b"><em class="iq">prevent</em></code> <em class="iq">修饰符，这有助于防止浏览器添加到图像中的常规拖放行为。</em></p></blockquote><p id="d430" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们有三个不同的方法需要在Vue实例中声明，但是首先，让我们创建一个助手函数来提取鼠标或手指触摸屏幕的位置:</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="ac4d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们应该能够使用这个函数来相应地更新光标移动，但我们还需要跟踪初始的点击位置，如果用户当前正在拖动图像:</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="0b56" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要查看所有这些是否正常工作，您可以添加这个小部件来查看属性是如何变化的:</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="9c20" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有趣的部分来了，在接下来的步骤中，我们将首先声明一些我们将使用的常数:</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><blockquote class="ld le lf"><p id="318f" class="jy jz lg ka b kb kc kd ke kf kg kh ki lh kk kl km li ko kp kq lj ks kt ku kv ij bi translated"><em class="iq">完成后，您可以使用这些值来观察事情的变化。</em></p></blockquote><p id="6ddb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">就像我上面提到的，拖动图像有两种情况，要么是向左拖动，要么是向右拖动。让我们为此创建几个计算道具:</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><blockquote class="ld le lf"><p id="3c6a" class="jy jz lg ka b kb kc kd ke kf kg kh ki lh kk kl km li ko kp kq lj ks kt ku kv ij bi translated"><em class="iq">基本上，我们正在获取用户开始拖动的位置和光标当前位置之间的差异。如果差值大于</em> <code class="fe lk ll lm ln b"><em class="iq">0</em></code> <em class="iq">则意味着用户向左拖动图像。</em></p></blockquote><p id="73b4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在深入移动图像之前，我将创建另一个助手函数，它可以帮助我们将图像保存在容器中</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="6ba3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们可以用这个新的道具替换<code class="fe lk ll lm ln b">nextImagePosition</code>计算道具:</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="02b7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">试试吧！</p><p id="53af" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">按下并向左拖动时，<code class="fe lk ll lm ln b">nextImage</code>应该会出来。</p><p id="923b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">每当用户没有拖动或者用户向右滑动时，我们希望下一个图像在视窗外的同一个位置。在另一种情况下，根据拖动速度，图像应该更靠近容器的中心。</p><p id="9fc0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">同样的，我们可以对<code class="fe lk ll lm ln b">currentImage</code>做类似的事情，当用户向右滑动时，首先绑定样式属性:</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="d044" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后为其创建计算方法:</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="a9e3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在参考中，当当前图像被下一个图像覆盖时，它会逐渐模糊，从而产生一种被发送到底部的效果。让我们创建最后一个助手函数:</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><blockquote class="ld le lf"><p id="cde3" class="jy jz lg ka b kb kc kd ke kf kg kh ki lh kk kl km li ko kp kq lj ks kt ku kv ij bi translated"><em class="iq">根据图像的位置，该函数应该给出一个介于0和</em> <code class="fe lk ll lm ln b"><em class="iq">MAX_BLUR</em></code> <em class="iq">之间的值。当图像越靠近视口外部，模糊越少，当图像越靠近中心时，模糊值越大。</em></p></blockquote><p id="1d81" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们之前的图像也需要一个样式属性:</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="8a3d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe lk ll lm ln b">previousImage</code>模糊取决于<code class="fe lk ll lm ln b">currentImage</code>位置，而<code class="fe lk ll lm ln b">currentImage</code>模糊取决于<code class="fe lk ll lm ln b">nextImage</code>位置:</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="2179" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">到目前为止，一切顺利。图像会相应地移动和模糊，但在我们发布之后，它们又会恢复原状。我们需要一种方法让他们在我们刷卡后去我们想去的地方。</p><p id="6007" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">就像我们之前说过的，根据图像的一半是显示还是隐藏，我们将使其动画化。</p><p id="29a5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们添加一些我们将为此需要的数据道具:</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="5f6e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">属性会让我们知道什么时候移动图像，并阻止任何其他动作。<code class="fe lk ll lm ln b">currentImageAnimatedX</code>和<code class="fe lk ll lm ln b">nextImageAnimatedX</code>将保持相应图像动画时的位置。</p><p id="4b88" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了使这两个属性正确工作，我们需要更新两个图像定位计算属性:</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="d484" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后我们需要改变<code class="fe lk ll lm ln b">stopDrag</code>方法来触发动画:</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><blockquote class="ld le lf"><p id="c821" class="jy jz lg ka b kb kc kd ke kf kg kh ki lh kk kl km li ko kp kq lj ks kt ku kv ij bi translated"><em class="iq">我们使用</em> <code class="fe lk ll lm ln b"><em class="iq">TweenLite</em></code> <em class="iq">来补间Vue实例数据，这将反应性地更新图像样式计算属性。</em></p></blockquote><p id="8d64" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可能已经注意到，我们需要定义<code class="fe lk ll lm ln b">createReleaseAnimation</code>，这是一个方法，它将保持逻辑以知道图像在发布后应该去哪里。这是某种决策树，所以我将通过行内注释来解释它:</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div></figure><p id="42d6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们正在定义四种情况中的每一种:</p><ul class=""><li id="753c" class="ls lt iq ka b kb kc kf kg kj lu kn lv kr lw kv lx ly lz ma bi translated">向左滑动，但图像应该回到屏幕外</li><li id="1791" class="ls lt iq ka b kb mb kf mc kj md kn me kr mf kv lx ly lz ma bi translated">向左滑动，图像应该到达容器的中心</li><li id="cbe3" class="ls lt iq ka b kb mb kf mc kj md kn me kr mf kv lx ly lz ma bi translated">向右滑动，图像应该回到中间</li><li id="8e42" class="ls lt iq ka b kb mb kf mc kj md kn me kr mf kv lx ly lz ma bi translated">向右滑动，先前的图像应该成为新的当前图像</li></ul><p id="280b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于每一种情况，我们都定义了一个对象，TweenLite将使用该对象将相应的<code class="fe lk ll lm ln b">animatedX</code>属性更改为目标。</p><p id="b72a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">而现在最后的结果！</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="mg lc l"/></div></figure><p id="1f02" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我留下了一个<code class="fe lk ll lm ln b">&lt;pre&gt;</code>标签，显示所有更新的属性，但如果您只是想查看没有它的图库，请随意移除它。</p><p id="6507" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就是本周的<strong class="ka ir">小部件。</strong></p><p id="f623" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你想知道更多，你可以去看看其他的WotW:</p><ul class=""><li id="2601" class="ls lt iq ka b kb kc kf kg kj lu kn lv kr lw kv lx ly lz ma bi translated"><a class="ae kw" rel="noopener ugc nofollow" target="_blank" href="/minimalistic-nav-menu-wit-vue-js-and-gsap-wotw-5cf9833bbdb5">极简导航菜单</a></li><li id="1457" class="ls lt iq ka b kb mb kf mc kj md kn me kr mf kv lx ly lz ma bi translated"><a class="ae kw" rel="noopener ugc nofollow" target="_blank" href="/making-an-interactive-password-validator-wotw-77b677548b75">密码验证器</a></li><li id="5b6d" class="ls lt iq ka b kb mb kf mc kj md kn me kr mf kv lx ly lz ma bi translated"><a class="ae kw" rel="noopener ugc nofollow" target="_blank" href="/making-an-animated-slider-wotw-a98f71438b33">动画滑块</a></li></ul></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><p id="9ef3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="lg">最初发布于</em><a class="ae kw" href="https://ederdiaz.dev" rel="noopener ugc nofollow" target="_blank"><em class="lg">ederdiaz . dev</em></a><em class="lg">。</em></p></div></div>    
</body>
</html>