<html>
<head>
<title>Building a GraphQL API with Node JS and React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用节点JS和React构建GraphQL API</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/using-graphql-api-with-node-js-and-react-forms-8b13f4b26361?source=collection_archive---------0-----------------------#2017-11-21">https://levelup.gitconnected.com/using-graphql-api-with-node-js-and-react-forms-8b13f4b26361?source=collection_archive---------0-----------------------#2017-11-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="241d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">关于在客户端使用React JS在Express JS上构建GraphQL API的实践教程。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/d18ff83c45b709bee1d8defd91468406.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BRbi2bxkmtZNcrnmaSFqUw.jpeg"/></div></div></figure><h2 id="513d" class="ky kz iq bd la lb lc dn ld le lf dp lg jy lh li lj kc lk ll lm kg ln lo lp lq bi translated">介绍</h2><p id="be3d" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">今年我参观了<a class="ae lw" href="https://pyconie17.python.ie/" rel="noopener ugc nofollow" target="_blank"> PyCon Ireland 2017 </a>，在那里我看到了一个关于<a class="ae lw" href="http://graphql.org/learn/" rel="noopener ugc nofollow" target="_blank"> GraphQL </a> API的非常有趣的演示。GraphQL是一种新的用于构建API的查询语言，由脸书推出。在某些情况下，它比REST API更方便，在某些领域应该会取代REST。GraphQL方法的主要优点是只需要一个由POST方法驱动的端点，而不是REST中的几个端点和HTTP方法。例如，假设您有一个用户列表，每个用户包含名、姓、电子邮件和其他信息，如国家、工作部门等。假设您在一种情况下只需要获得用户的主要信息(id、名字、姓氏)，在另一种情况下需要获得完整的信息。休息的时候你会做什么？创建两个端点？</p><p id="dbb5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">或者假设您也有一个分配给每个用户的“todo”任务列表，并且您需要检索带有todo列表的用户。使用GraphQL，您可以直接告诉服务器“给我只包含id、名字和姓氏的用户列表”，如下所示:</p><pre class="kn ko kp kq gt lx ly lz ma aw mb bi"><span id="c1f5" class="ky kz iq ly b gy mc md l me mf">{<br/>  users {<br/>    id<br/>    first_name<br/>    last_name<br/>  }<br/>}</span></pre><p id="0264" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">或者“给我全部信息”:</p><pre class="kn ko kp kq gt lx ly lz ma aw mb bi"><span id="63f5" class="ky kz iq ly b gy mc md l me mf">{<br/>  users {<br/>    id<br/>    first_name<br/>    last_name<br/>    email<br/>    gender<br/>    country<br/>    department<br/>  }<br/>}</span></pre><p id="09d7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">或者“给我分配了待办事项的用户列表。”或者我们甚至可以定义计数和汇总字段——这将在后面描述，还有许多其他的<a class="ae lw" href="http://graphql.org/learn/schema/#the-query-and-mutation-types" rel="noopener ugc nofollow" target="_blank">操作</a>:</p><pre class="kn ko kp kq gt lx ly lz ma aw mb bi"><span id="6353" class="ky kz iq ly b gy mc md l me mf">{<br/>  users {<br/>    id<br/>    first_name<br/>    last_name<br/>    todo_count</span><span id="7029" class="ky kz iq ly b gy mg md l me mf">    todos {<br/>      id<br/>      title<br/>    }<br/>  }<br/>}</span></pre><p id="2bb4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您还可以定义参数来实现任何类型的数据搜索或过滤。就像这样:</p><pre class="kn ko kp kq gt lx ly lz ma aw mb bi"><span id="2503" class="ky kz iq ly b gy mc md l me mf">{<br/>  users(country:"Ireland") {<br/>    id<br/>    first_name<br/>    last_name<br/>  }<br/>}</span></pre><p id="563f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此时，我开始考虑在服务器端使用GraphQL，在客户端使用React JS。React props和state concept可以很好地与任何类型的JSON API一起工作，因此必须与GraphQL一起工作。React还有受控的<a class="ae lw" href="https://reactjs.org/docs/forms.html" rel="noopener ugc nofollow" target="_blank">表单</a>概念，允许将表单输入映射到React状态，而无需任何额外的序列化。在使用新API查询语言构建单页面应用程序(SPA)时，使用React JS的不同特性是一个很好的实践。在本教程中，我们将使用:</p><ul class=""><li id="4a7a" class="mh mi iq jp b jq jr ju jv jy mj kc mk kg ml kk mm mn mo mp bi translated"><a class="ae lw" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank"> Node.js </a></li><li id="3385" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated"><a class="ae lw" href="https://github.com/expressjs" rel="noopener ugc nofollow" target="_blank">用服务器端的<a class="ae lw" href="https://github.com/graphql/express-graphql" rel="noopener ugc nofollow" target="_blank"> GraphQL包</a>表示</a></li><li id="40f4" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated"><a class="ae lw" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank">客户端反应JS </a></li><li id="0f9f" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated"><a class="ae lw" href="https://reacttraining.com/react-router/" rel="noopener ugc nofollow" target="_blank"> React-Router </a>用于路由我们的应用程序</li><li id="4af3" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated">一些<a class="ae lw" href="https://github.com/KilroggD/GraphQL-react/blob/master/client/src/styles/style.css" rel="noopener ugc nofollow" target="_blank"> CSS </a>和<a class="ae lw" href="https://css-tricks.com/snippets/css/a-guide-to-flexbox/" rel="noopener ugc nofollow" target="_blank"> flexbox </a>使其可读</li></ul><p id="6f58" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个例子有一个<strong class="jp ir">用户列表</strong>，他们位于不同的国家，在某个组织的不同部门工作。他们每个人都有自己的<strong class="jp ir"> Todo </strong>清单，上面列有已完成和未完成的任务。我们将创建一个包含两个主要部分的<strong class="jp ir"> SPA </strong>:</p><ul class=""><li id="a318" class="mh mi iq jp b jq jr ju jv jy mj kc mk kg ml kk mm mn mo mp bi translated">用于搜索和显示所有用户列表的搜索表单，按名字、姓氏、部门、国家/地区进行筛选。</li><li id="85c4" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated">通过用户列表中的“查看待办事项(x)”链接可以访问与所选用户Id相关的待办事项任务列表</li></ul><p id="5f5d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以在这里找到工作代码<a class="ae lw" href="https://github.com/KilroggD/GraphQL-react" rel="noopener ugc nofollow" target="_blank">https://github.com/KilroggD/GraphQL-react</a>。要启动它，只需在客户端和服务器文件夹中安装npm，然后您可以使用<strong class="jp ir"> npm start </strong>来启动服务器或客户端或两者。</p><p id="d5bb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">作为数据源，我们将使用带有数组的<a class="ae lw" href="https://github.com/KilroggD/GraphQL-react/tree/master/graphsrv/src/data" rel="noopener ugc nofollow" target="_blank"> js文件</a>，但是您也可以使用一些数据库引擎或其他数据源。</p><p id="0950" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本教程中，我将一步一步地描述这个SAP的创建。</p><p id="1529" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们从服务器端应用程序开始。</p></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><h2 id="ffd7" class="ky kz iq bd la lb lc dn ld le lf dp lg jy lh li lj kc lk ll lm kg ln lo lp lq bi translated">服务器端实现</h2><p id="e05d" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">服务器端代码位于此处<a class="ae lw" href="https://github.com/KilroggD/GraphQL-react/tree/master/graphsrv" rel="noopener ugc nofollow" target="_blank">https://github . com/KilroggD/GraphQL-react/tree/master/graphsrv</a></p><p id="1d47" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们开始创建我们的服务器端应用程序之前，我们需要安装几个npm包——你可以在资源库中找到<em class="kl"> package.json </em>:</p><pre class="kn ko kp kq gt lx ly lz ma aw mb bi"><span id="9060" class="ky kz iq ly b gy mc md l me mf">"dependencies": {<br/>    "express": "^4.16.2",<br/>    "express-graphql": "^0.6.11",<br/>    "graphql": "^0.11.7",<br/>    "lodash": "^4.17.4",<br/>    "babel-cli": "^6.24.1",<br/>    "babel-preset-node6": "^11.0.0",<br/>    "babel-register": "^6.24.1",<br/>    "nodemon": "^1.11.0"<br/>  }</span></pre><p id="e541" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这里，我们可以看到<em class="kl"> express </em>框架、<em class="kl"> graphql </em>扩展、<a class="ae lw" href="https://lodash.com/" rel="noopener ugc nofollow" target="_blank"> lodash </a>库——对JS数组中的过滤和搜索非常有用——以及一些额外的包来运行我们的服务器，并让它理解复杂的ES6语法。</p><p id="3208" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的入口点是我们的<strong class="jp ir"> server.js </strong>文件。首先，我们导入所有必要的模块，并定义服务器监听的端口，然后创建我们的express应用程序。我们还导入GraphQL <strong class="jp ir">模式</strong>文件，这将在后面描述。</p><pre class="kn ko kp kq gt lx ly lz ma aw mb bi"><span id="445b" class="ky kz iq ly b gy mc md l me mf">import express from 'express';<br/>import schema from './schema';<br/>import graphqlHTTP from 'express-graphql';<br/>const port = 3001;<br/>const app = express();</span></pre><p id="3e1e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">之后，我们需要描述我们的应用程序将要做什么。首先，我们假设我们的API可能是公共的，或者我们的前端开发服务器可以在不同的端口上运行，所以我们需要允许<a class="ae lw" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS" rel="noopener ugc nofollow" target="_blank">跨源</a>请求。</p><pre class="kn ko kp kq gt lx ly lz ma aw mb bi"><span id="9d37" class="ky kz iq ly b gy mc md l me mf">app.use('/graphql', (req, res, next) =&gt; {<br/>    res.header('Access-Control-Allow-Origin', '*');<br/>    res.header('Access-Control-Allow-Headers', 'Content-Type,  Authorization, Content-Length, X-Requested-With');<br/>    if (req.method === 'OPTIONS') {<br/>        res.sendStatus(200);<br/>    } else {<br/>        next();<br/>    }<br/>});</span></pre><p id="43a0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后我们编写四行神奇的代码来完成GraphQL的工作:</p><pre class="kn ko kp kq gt lx ly lz ma aw mb bi"><span id="c86d" class="ky kz iq ly b gy mc md l me mf">app.use('/graphql', graphqlHTTP({<br/>    schema,<br/>    graphiql: true<br/>}));</span></pre><p id="0247" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae lw" href="https://github.com/graphql/graphiql" rel="noopener ugc nofollow" target="_blank"> Graphiql </a>是一个强大的开发工具，它允许你在没有任何前端或客户端应用程序的情况下开发测试你的API。换句话说，这段代码是我们唯一需要的端点。它将处理通过我们的graphql模式发送到<a class="ae lw" href="http://localhost:3001/graphql" rel="noopener ugc nofollow" target="_blank">http://localhost:3001/graph QL</a>的所有POST请求。</p><p id="90e9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，启动服务器本身的代码:</p><pre class="kn ko kp kq gt lx ly lz ma aw mb bi"><span id="0f3b" class="ky kz iq ly b gy mc md l me mf">const server = app.listen(port, () =&gt; {<br/>    console.log(<br/>        `\n\nExpress listen at <a class="ae lw" href="http://localhost:${port" rel="noopener ugc nofollow" target="_blank">http://localhost:${port</a>} \n`<br/>    );<br/>});</span></pre><p id="1baa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们定义服务器端应用程序的主要部分——<em class="kl">模式</em>。它定义了关于如何验证请求、如何从数据源获取结果、不同实体之间的关系等所有规则。因此，它基本上像我们的应用程序的数据模型一样工作。</p><p id="05d9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们将导入我们的数据源文件和有用的<em class="kl"> lodash </em>方法来过滤和聚合数据。不要为了你要使用的几个函数而导入整个<em class="kl"> lodash </em>库(不要从lodash导入！)</p><pre class="kn ko kp kq gt lx ly lz ma aw mb bi"><span id="5315" class="ky kz iq ly b gy mc md l me mf">import Users from './data/users';<br/>import Todos from './data/todos';<br/>import find from 'lodash/find';<br/>import filter from 'lodash/filter';<br/>import sumBy from 'lodash/sumBy';</span></pre><p id="5de0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">之后，我们导入一些GraphQL类用于类型验证和创建模式对象</p><pre class="kn ko kp kq gt lx ly lz ma aw mb bi"><span id="2ac5" class="ky kz iq ly b gy mc md l me mf">import {<br/>    GraphQLInt,<br/>    GraphQLBoolean,<br/>    GraphQLString,<br/>    GraphQLList,<br/>    GraphQLObjectType,<br/>    GraphQLNonNull,<br/>    GraphQLSchema,<br/>} from 'graphql';</span></pre><p id="ff6d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后我们可以为我们需要的实体定义实际的数据结构。在本例中，我们有两个实体—一个用于用户，一个用于待办事项:</p><pre class="kn ko kp kq gt lx ly lz ma aw mb bi"><span id="ff1a" class="ky kz iq ly b gy mc md l me mf">const UserType = new GraphQLObjectType({<br/>    name: 'User',<br/>    description: 'Users in company',<br/>    fields: () =&gt; ({<br/>            id: {type: new GraphQLNonNull(GraphQLInt)},<br/>            first_name: {type: new GraphQLNonNull(GraphQLString)},<br/>            last_name: {type: new GraphQLNonNull(GraphQLString)},<br/>            email: {type: GraphQLString},<br/>            gender: {type: GraphQLString},<br/>            department: {type: new GraphQLNonNull(GraphQLString)},<br/>            country: {type: new GraphQLNonNull(GraphQLString)},<br/>            todo_count: {<br/>                type: GraphQLInt,<br/>                resolve: (user) =&gt; {<br/>                    return sumBy(<br/>                       Todos, todo =&gt; todo.userId === user.id ? 1:0<br/>                    );<br/>                }<br/>            },<br/>            todos: {<br/>                type: new GraphQLList(TodoType),<br/>                resolve: (user, args) =&gt; {<br/>                    return filter(<br/>                        Todos, todo =&gt; todo.userId === user.id<br/>                    );<br/>                }<br/>            }<br/>        })<br/>});</span></pre><p id="61be" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里，对于除了<em class="kl"> todo_count </em>和<em class="kl"> todos </em>之外的所有字段，我们只定义了类型(<em class="kl"> Int，String </em>等)。).对于与另一个实体(todo)相关的这两种类型，我们定义了一个resolve函数，在第一种情况下，它将聚合todo的数量，在第二种情况下，它只获取与用户相关的所有todo。然后，我们为todos定义了与任务分配给的用户相关的类似功能。</p><pre class="kn ko kp kq gt lx ly lz ma aw mb bi"><span id="0885" class="ky kz iq ly b gy mc md l me mf">const TodoType = new GraphQLObjectType({<br/>    name: 'Todo',<br/>    description: 'Task for user',<br/>    fields: () =&gt; ({<br/>            id: {type: new GraphQLNonNull(GraphQLInt)},<br/>            title: {type: GraphQLString},<br/>            completed: {type: new GraphQLNonNull(GraphQLBoolean)},<br/>            user: {<br/>                type: UserType,<br/>                resolve: (todo, args) =&gt; {<br/>                    return find(Users, user =&gt; user.id === todo.userId);<br/>                }<br/>            }<br/>        })<br/>});</span></pre><p id="1124" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在定义了所有数据类型之后，我们可以为我们的应用程序创建一个根查询。GraphQL中有不同类型的查询<a class="ae lw" href="http://graphql.org/learn/schema/#the-query-and-mutation-types" rel="noopener ugc nofollow" target="_blank">但是对于这个例子，我们只关注一个非常简单的从数据源获取数据的查询。对于用户，我们还将实现过滤参数，对于todos，我们将只获取与给定的userId相关的所有项目。下面是我们主要查询的代码:</a></p><pre class="kn ko kp kq gt lx ly lz ma aw mb bi"><span id="be99" class="ky kz iq ly b gy mc md l me mf">const TodoQueryRootType = new GraphQLObjectType({<br/>    name: 'TodoAppSchema',<br/>    description: 'Root Todo App Schema',<br/>    fields: () =&gt; ({<br/>            users: {<br/>                args: {<br/>                    first_name: {type: GraphQLString},<br/>                    last_name: {type: GraphQLString},<br/>                    department: {type: GraphQLString},<br/>                    country: {type: GraphQLString},<br/>                },<br/>                type: new GraphQLList(UserType),<br/>                description: 'List of Users',<br/>                resolve: (parent, args) =&gt; {<br/>                    if (Object.keys(args).length) {<br/>                        return filter(Users, args);<br/>                    }<br/>                    return Users;<br/>                }<br/>            },<br/>            todos: {<br/>                args: {<br/>                    userId: {type: GraphQLInt},<br/>                    completed: {type: GraphQLBoolean},<br/>                },<br/>                type: new GraphQLList(TodoType),<br/>                description: 'List of Todos',<br/>                resolve: (parent, args) =&gt; {<br/>                    if (Object.keys(args).length) {<br/>                        return filter(Todos, args);<br/>                    }<br/>                    return Todos;<br/>                }<br/>            }<br/>        })<br/>});</span></pre><p id="1255" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里描述了我们的主要应用程序<strong class="jp ir">模式</strong>。它有两个字段——<em class="kl">用户</em>和<em class="kl">待办事项</em>，分别带有<strong class="jp ir">用户类型</strong>和<strong class="jp ir">待办事项类型</strong>。我们可以通过在<strong class="jp ir"> args </strong>中定义的四个可能的参数来过滤<strong class="jp ir">用户</strong>列表。过滤器本身在<strong class="jp ir"> resolve </strong>函数中实现(在这种情况下只是一个简单的lodash过滤器)。</p><p id="85c1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">同样的道理也适用于<strong class="jp ir">待办事项</strong>列表:我们可以通过<em class="kl">用户Id </em>和完成状态对其进行过滤。</p><p id="3026" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我们创建并导出我们的模式对象:</p><pre class="kn ko kp kq gt lx ly lz ma aw mb bi"><span id="12a2" class="ky kz iq ly b gy mc md l me mf">const schema = new GraphQLSchema({<br/>    query: TodoQueryRootType,<br/>});</span><span id="cf50" class="ky kz iq ly b gy mg md l me mf">export default schema;</span></pre><p id="3cce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此时，您已经可以启动您的服务器，并通过调试工具对其进行测试。</p><p id="277d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">只需在你的Chrome浏览器中打开<a class="ae lw" href="http://localhost:3001/graphql" rel="noopener ugc nofollow" target="_blank">http://localhost:3001/graph QL</a>,并尝试本文前面提到的一些查询。</p><p id="0693" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">至此，服务器端已经完成，我们可以从客户端开始了。</p></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><p id="9ef9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">客户端实现</strong></p><p id="d9f8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了简化React JS应用程序的创建，我使用了脸书提供的工具。我还安装了react路由器:</p><pre class="kn ko kp kq gt lx ly lz ma aw mb bi"><span id="f434" class="ky kz iq ly b gy mc md l me mf">npm install --save react-router</span></pre><p id="c224" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">工作代码和package.json文件在<a class="ae lw" href="https://github.com/KilroggD/GraphQL-react/tree/master/client" rel="noopener ugc nofollow" target="_blank">客户端文件夹</a>的存储库中。</p><p id="f33c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以首先启动服务器，然后转到客户端文件夹并运行:</p><pre class="kn ko kp kq gt lx ly lz ma aw mb bi"><span id="d996" class="ky kz iq ly b gy mc md l me mf">npm start</span></pre><p id="4d02" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我不会在这里描述所有的源代码，只描述其中最相关的部分。</p><p id="955f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">React JS中有不同的方法来处理异步数据获取、ajax请求和不同的API。这篇文章很好地描述了ajax的最佳实践。</p><p id="a84d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了不使示例过于复杂，当我们有处理异步调用的容器组件和无状态的显示UI的表示组件时，我们将使用容器方法。在开始之前，我们将创建一个简单的类似服务的类，它将获取GraphQL数据，以避免组件中的AJAX调用。</p><p id="550d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> ApiService.js: </strong></p><pre class="kn ko kp kq gt lx ly lz ma aw mb bi"><span id="87a0" class="ky kz iq ly b gy mc md l me mf">class ApiService {</span><span id="e717" class="ky kz iq ly b gy mg md l me mf">   /**<br/>     * define base url and field schemas here<br/>     * <a class="ae lw" href="http://twitter.com/returns" rel="noopener ugc nofollow" target="_blank">@returns</a> {ApiService}<br/>     */<br/>    constructor() {<br/>        this.apiUrl = '<a class="ae lw" href="http://localhost:3001/graphql'" rel="noopener ugc nofollow" target="_blank">http://localhost:3001/graphql'</a>;<br/>        this.userFields = `{id, first_name, last_name, email,                                    department, country, todo_count}`;<br/>        this.todoFields = `{id title completed user {first_name, last_name}}`;<br/>    }</span><span id="4a06" class="ky kz iq ly b gy mg md l me mf">   /**<br/>     * Generic function to fetch data from server<br/>     * <a class="ae lw" href="http://twitter.com/param" rel="noopener ugc nofollow" target="_blank">@param</a> {string} query<br/>     * <a class="ae lw" href="http://twitter.com/returns" rel="noopener ugc nofollow" target="_blank">@returns</a> {unresolved}<br/>     */<br/>    async getGraphQlData(resource, params, fields) {<br/>        const query = `{${resource} ${this.paramsToString(params)} ${fields}}`;<br/>        const res = await fetch(this.apiUrl, {<br/>            method: 'POST',<br/>            mode: 'cors',<br/>            headers: new Headers({<br/>                'Content-Type': 'application/json',<br/>                'Accept': 'application/json',<br/>            }),<br/>            body: JSON.stringify({query}),<br/>        });<br/>        if (res.ok) {<br/>            const body = await res.json();<br/>            return body.data;<br/>        } else {<br/>            throw new Error(res.status);<br/>        }<br/>    }</span><span id="5354" class="ky kz iq ly b gy mg md l me mf">   /**<br/>     * <br/>     * <a class="ae lw" href="http://twitter.com/param" rel="noopener ugc nofollow" target="_blank">@param</a> {object} params<br/>     * <a class="ae lw" href="http://twitter.com/returns" rel="noopener ugc nofollow" target="_blank">@returns</a> {array} users list or empty list<br/>     */<br/>    async getUsers(params = {}) {<br/>        const data = await this.getGraphQlData(<br/>            'users', params, this.userFields<br/>        );<br/>        //return users list<br/>        return data.users;<br/>    }</span><span id="5603" class="ky kz iq ly b gy mg md l me mf">   /**<br/>     * <br/>     * <a class="ae lw" href="http://twitter.com/param" rel="noopener ugc nofollow" target="_blank">@param</a> {object} params<br/>     * <a class="ae lw" href="http://twitter.com/returns" rel="noopener ugc nofollow" target="_blank">@returns</a> {array} users list or empty list<br/>     */<br/>    async getTodos(params = {}) {<br/>        const data = await this.getGraphQlData(<br/>           'todos', params, this.todoFields<br/>        );<br/>        //return todos list<br/>        return data.todos;<br/>    }</span><span id="6b1a" class="ky kz iq ly b gy mg md l me mf">   /**<br/>     * <br/>     * <a class="ae lw" href="http://twitter.com/param" rel="noopener ugc nofollow" target="_blank">@param</a> {object} params<br/>     * <a class="ae lw" href="http://twitter.com/returns" rel="noopener ugc nofollow" target="_blank">@returns</a> {String} params<br/>      converted to string for usage in graphQL<br/>     */<br/>    paramsToString(params) {<br/>        let paramString = '';<br/>        if (params.constructor === Object &amp;&amp; Object.keys(params).length) {<br/>            let tmp = [];<br/>            for (let key in params) {<br/>                let paramStr = params[key];<br/>                if(paramStr !== '') {<br/>                    if (typeof params[key] === 'string') {<br/>                        paramStr = `"${paramStr}"`;<br/>                    }<br/>                    tmp.push(`${key}:${paramStr}`);<br/>                }<br/>            }<br/>            if (tmp.length) {<br/>                paramString = `(${tmp.join()})`;<br/>            }<br/>        }<br/>        return paramString;<br/>    }</span><span id="3953" class="ky kz iq ly b gy mg md l me mf">}</span><span id="c550" class="ky kz iq ly b gy mg md l me mf">export default new ApiService();</span></pre><p id="0ef5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在构造函数中，我们定义了主Url和需要为每个实体获取的字段。主函数<strong class="jp ir">async getGraphQlData(resource，params，fields) </strong>从给定的<em class="kl">资源</em> (users或todos)中获取数据，通过给定的<em class="kl">参数、</em>进行过滤，并受到给定的<em class="kl">字段</em>的限制。<strong class="jp ir"> paramsToString </strong>是一个帮助器函数，用于将对象转换成参数字符串({userId: 1} - &gt; '(userId:1)')。</p><p id="e962" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，我们使用<strong class="jp ir"> getUsers </strong>和<strong class="jp ir"> getTodos </strong>作为代理函数，以获得更好的可读性、准确性(<em class="kl"> getUsers </em>获取用户，<em class="kl"> getTodos </em>获取Todos)和语法优势。这两个函数都将返回从服务器检索到的对象数组，或者在请求不成功时抛出一个错误。这里使用了javascript <a class="ae lw" href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch" rel="noopener ugc nofollow" target="_blank">获取API </a>。</p><p id="d558" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们将主应用程序声明为处理路由的主容器:</p><pre class="kn ko kp kq gt lx ly lz ma aw mb bi"><span id="a80e" class="ky kz iq ly b gy mc md l me mf">const App = () =&gt; {<br/>    return &lt;Switch&gt;<br/>        &lt;Route exact path='/' component={UserListContainer}/&gt;<br/>        &lt;Route path='/todos/:userId' component={TodoListContainer}/&gt;<br/>    &lt;/Switch&gt;<br/>};</span><span id="f391" class="ky kz iq ly b gy mg md l me mf">export default App;</span></pre><p id="2423" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以在Medium上的这里找到一篇关于react路由器<a class="ae lw" href="https://medium.com/@pshrmn/a-simple-react-router-v4-tutorial-7f23ff27adf" rel="noopener">的精彩文章。</a></p><p id="61d5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">根据浏览器Url，我们的应用程序将呈现<strong class="jp ir"> UserListContainer </strong>或<strong class="jp ir"> TodoListContainer </strong>。它们都是异步组件，处理AJAX请求并将处理后的数据传递给它们的子组件。让我们关注一下<strong class="jp ir">用户列表容器</strong>。默认情况下，它会呈现两个子表单——用于搜索用户的用户表单和带有结果列表的用户列表。</p><pre class="kn ko kp kq gt lx ly lz ma aw mb bi"><span id="ee27" class="ky kz iq ly b gy mc md l me mf">render() {<br/>        return &lt;div className="user"&gt;<br/>            &lt;UserForm submitHandler={this.search} /&gt;<br/>            &lt;UserList users={this.state.users} /&gt;<br/>        &lt;/div&gt;;<br/>    }</span></pre><p id="b0f8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它还将一个搜索函数作为处理程序传递给我们的表单。这个异步函数从GraphQL api获取数据，并将结果存储在状态中:</p><pre class="kn ko kp kq gt lx ly lz ma aw mb bi"><span id="e31a" class="ky kz iq ly b gy mc md l me mf">async search(params) {<br/>        try {<br/>            const users = await ApiService.getUsers(params);<br/>            this.setState({users});<br/>        } catch (e) {<br/>            console.error(`An error ${e.message} occured while searching users`);<br/>        }<br/>    }</span></pre><p id="6d6f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">用户表单</strong>是一个<a class="ae lw" href="https://reactjs.org/docs/forms.html" rel="noopener ugc nofollow" target="_blank">控制的表单</a>，它将输入值映射到表单的状态。所以我们需要做的就是将这个状态传递给处理函数:</p><pre class="kn ko kp kq gt lx ly lz ma aw mb bi"><span id="61ad" class="ky kz iq ly b gy mc md l me mf">handleSubmit(event) {<br/>        event.preventDefault();<br/>        return this.props.submitHandler(this.state);<br/>}</span></pre><p id="f575" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们提交表单后，我们的搜索函数获取数据并将其传递到UserList，它显示结果:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nc"><img src="../Images/621f3650b6f9ae44fdc643882cc0de1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*2b04T7Gz7hat6eh0.png"/></div></div></figure><p id="e978" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以在Chrome开发工具中看到请求负载和收到的响应:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nd"><img src="../Images/e618b19390334b7487f11aceeccc73de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*87A98-HrD7b9Y-Jy.png"/></div></div></figure><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi ne"><img src="../Images/dfb9bccc90770ad48d9fe5c2785e2eed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5vweqYr44SibR_ys.png"/></div></div></figure><p id="ad9c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每个用户列表项包含一个带有Todos计数的链接，该链接链接到带有与该用户相关的任务的页面<a class="ae lw" href="http://localhost:3000/todos/1" rel="noopener ugc nofollow" target="_blank"/></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nf"><img src="../Images/459f8919cafac0d5594254ff360d4284.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-b9Gbfu24m5CAwTA.png"/></div></div></figure><p id="d21d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该页面直接将<strong class="jp ir">呈现给使用异步呈现的TodoListContainer </strong>，无需等待提交任何表单。除了容器和<strong class="jp ir">用户表单</strong>之外的所有组件都是用于表示目的的无状态功能组件。</p><pre class="kn ko kp kq gt lx ly lz ma aw mb bi"><span id="4151" class="ky kz iq ly b gy mc md l me mf">async componentDidMount() {<br/>        const userId = parseInt(this.props.match.params.userId, 10);<br/>        try {<br/>            const todos = await ApiService.getTodos({userId});<br/>            this.setState({todos});<br/>        } catch (e) {<br/>            console.error(`An error ${e.message} occured while loading tasks for user ${userId}`);<br/>        }<br/>    }</span></pre><p id="b3ac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该页面还包含返回用户搜索页面的链接。请注意，在我们返回之后，搜索表单是干净的，因为在我们更改了路由及其子路由之后，<strong class="jp ir"> UserListContainer </strong>被卸载了。为了保持表单状态，我们可以实现一些<a class="ae lw" href="https://github.com/reactjs/redux" rel="noopener ugc nofollow" target="_blank"> Redux </a>或<a class="ae lw" href="https://medium.com/front-end-hacking/react-and-reflux-usage-in-real-time-applications-based-on-websockets-part-1-introduction-12fcc7cc3590" rel="noopener"> Reflux </a>或自定义存储方法，或者将状态存储在根应用程序组件中(对于小应用程序是可行的，但在大项目中可能会造成混乱)。我会建议使用商店，但这是另一个不同的故事了。GraphQL的变化以及这种构建API的方法的许多其他特性和好处也是如此。</p><p id="ee1b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">感谢阅读，希望你觉得有点帮助和有用。=)</p></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><h1 id="e26f" class="ng kz iq bd la nh ni nj ld nk nl nm lg nn no np lj nq nr ns lm nt nu nv lp nw bi translated"><a class="ae lw" href="https://gitconnected.com" rel="noopener ugc nofollow" target="_blank">检出git connected&gt;T11】</a></h1><p id="1c31" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated"><em class="kl">开发者和软件工程师社区</em></p></div></div>    
</body>
</html>