<html>
<head>
<title>Encapsulating the Thread Logic in Stopwatch (Part 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将线程逻辑封装在秒表中(第2部分)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/encapsulating-the-thread-logic-in-stopwatch-part-2-746d2e051abd?source=collection_archive---------11-----------------------#2021-03-21">https://levelup.gitconnected.com/encapsulating-the-thread-logic-in-stopwatch-part-2-746d2e051abd?source=collection_archive---------11-----------------------#2021-03-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jn jo jp jq gh gi paragraph-image"><div class="ab gu cl jr"><img src="../Images/f56304e6a017e72d558bcf5f3e3cd1fe.png" data-original-src="https://miro.medium.com/v2/format:webp/0*55eLFcyH1xpMZ5Mf.png"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">礼貌:timeanddate.com</figcaption></figure><p id="7302" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">欢迎来到本系列的第二部分“强大的设计模式来创建一个惊人的秒表应用程序”。到目前为止，我们已经弄清楚了核心秒表类的工作原理。但问题是，我们必须显式调用秒表类的getTime()方法来获取特定时刻的时间。但这并不令我们满意。我们希望看到秒表运行，这就是原因，从客户端来看，我们做了一个不同的线程，只是为了看秒表运行，不断更新时间。但是客户端代码变得越来越重，让客户端做这么多事情只是为了使用秒表是不好的。我们应该总是考虑让客户端代码越来越小。现在真正的问题出现了:我们能用更少的代码给客户同样的功能吗？我们还能做些什么？</p><h1 id="ebda" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">之前的教程</h1><p id="7c2b" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">如果您是第一次阅读这一部分，那么您一定要看看本系列的第1部分。</p><ul class=""><li id="e587" class="lz ma iq ka b kb kc kf kg kj mb kn mc kr md kv me mf mg mh bi translated"><a class="ae mi" href="https://github.com/rajtilakls2510/Stopwatch/tree/S1_Making_the_core_stopwatch" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">代号</strong> </a>直到现在。</li><li id="8714" class="lz ma iq ka b kb mj kf mk kj ml kn mm kr mn kv me mf mg mh bi translated"><a class="ae mi" href="https://rajtilakls2510.medium.com/powerful-design-patterns-to-create-an-amazing-stopwatch-app-part-1-b408addedc79" rel="noopener">第一部分。</a></li></ul></div><div class="ab cl mo mp hu mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ij ik il im in"><p id="1e3e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们能做些什么来使客户端代码越来越小呢？我们可以做一件事。我们可以将所有与线程相关的逻辑封装到我们的核心秒表类中，这样用户甚至不必考虑自己创建线程。用户只需点击start()和stop()方法，就能看到秒表马上开始运行，甚至不需要进入任何线程事务。</p><p id="f2a8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">逻辑看起来是这样的。</p><ul class=""><li id="970c" class="lz ma iq ka b kb kc kf kg kj mb kn mc kr md kv me mf mg mh bi translated">当秒表的客户端点击start()时，秒表本身将创建一个新线程，它将立即启动。这个线程将连续打印秒表时间。</li><li id="e9bb" class="lz ma iq ka b kb mj kf mk kj ml kn mm kr mn kv me mf mg mh bi translated">当客户端点击stop()时，该线程将被销毁，不再打印时间，让用户确认秒表已经暂停。</li></ul><p id="810d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">看起来很简单，对吗？这很简单。本教程将会很短，因为接下来我们将实现观察者设计模式，我想给它一个单独的教程。别再多嘴了。让我们开始吧。</p><p id="b12c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就是现在Stopwatch.java班的样子。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="11f2" class="ne kx iq na b gy nf ng l nh ni">public class Stopwatch<br/>{<br/>    private long offset, currentStart;<br/>    private boolean isStopped;<br/><br/>    public Stopwatch()<br/>    {<br/>        offset = 0L;<br/>        currentStart = System.<em class="nj">currentTimeMillis</em>();<br/>        isStopped = true;<br/>    }<br/><br/>    public void start()<br/>    {<br/>        if(isStopped)<br/>        {<br/>            currentStart = System.<em class="nj">currentTimeMillis</em>() - offset;<br/>        }<br/><br/>        isStopped = false;<br/>    }<br/><br/>    public void stop()<br/>    {<br/>        if(!isStopped)<br/>        {<br/>            offset = System.<em class="nj">currentTimeMillis</em>() - currentStart;<br/>        }<br/>        isStopped = true;<br/>    }<br/><br/>    public long getTime()<br/>    {<br/>        if(!isStopped)<br/>            return System.<em class="nj">currentTimeMillis</em>() - currentStart;<br/>        else<br/>            return offset;<br/>    }<br/>}</span></pre><p id="268c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的StopwatchTest.java看起来像</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="32b2" class="ne kx iq na b gy nf ng l nh ni">public class StopwatchTest {<br/>    public static void main(String[] args) {<br/>        Stopwatch sw = new Stopwatch();<br/><br/>        Thread observerThread = new Thread(new Runnable() {<br/>            @Override<br/>            public void run() {<br/>                while (true)<br/>                {<br/>                    System.<em class="nj">out</em>.print("\rTime: "+ sw.getTime());<br/>                    <em class="nj">sleep</em>(10);<br/>                }<br/><br/>            }<br/>        });<br/>        observerThread.start();<br/><br/><br/>        System.<em class="nj">out</em>.println("\nStarting Stopwatch: ");<br/>        sw.start();<br/>        <em class="nj">sleep</em>(2000);<br/>        sw.stop();<br/>        System.<em class="nj">out</em>.println("\nStopwatch Stopped. ");<br/><br/>        <em class="nj">sleep</em>(2000);<br/><br/>        System.<em class="nj">out</em>.println("\nStarting Stopwatch: ");<br/>        sw.start();<br/>        <em class="nj">sleep</em>(2000);<br/>        sw.stop();<br/>        System.<em class="nj">out</em>.println("\nStopwatch Stopped. ");<br/><br/>    }<br/><br/>    public static void sleep(int time)<br/>    {<br/>        try {<br/>            Thread.<em class="nj">sleep</em>(time);<br/>        } catch (InterruptedException e) {<br/>            e.printStackTrace();<br/>        }<br/>    }<br/>}</span></pre><p id="05cf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在困扰我们的是从客户端创建线程。我们必须将传递给线程的Runnable的run()方法中的逻辑放入秒表类中。</p><p id="426f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们要做的第一件事是让Stopwatch类实现Runnable接口。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="a612" class="ne kx iq na b gy nf ng l nh ni">public class Stopwatch implements Runnable<br/>{<br/>....</span><span id="7ca1" class="ne kx iq na b gy nk ng l nh ni">}</span></pre><p id="28b2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们将覆盖Runnable接口希望我们覆盖的run()方法，并在其中复制打印逻辑。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="6c7c" class="ne kx iq na b gy nf ng l nh ni">public class Stopwatch implements Runnable<br/>{<br/>  ...<br/><br/>    @Override<br/>    public void run() {<br/>        while(true)<br/>        {<br/>            System.<em class="nj">out</em>.print("\rTime: "+ getTime());<br/>            try {<br/>                Thread.<em class="nj">sleep</em>(10);<br/>            } catch (InterruptedException e) {<br/>                e.printStackTrace();<br/>            }<br/>        }<br/>    }<br/>}</span></pre><p id="5262" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意，我们使用的是getTime()方法。因为Thread.sleep()抛出了InterruptedException，所以我们用try-catch块将它包围起来。一个问题仍然存在。没有停止逻辑来阻止线程打印时间。print方法处于无限循环中。之前我们别无选择，只能运行一个无限循环。但是现在我们有了一个可以帮助我们的变量。还记得《欲罢不能》吗？现在是时候使用它了。当秒表停止时，我们将停止打印时间。现在，循环条件变为:</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="9924" class="ne kx iq na b gy nf ng l nh ni">public void run() {<br/>    while(!isStopped)<br/>    {<br/>        System.<em class="nj">out</em>.print("\rTime: "+ getTime());<br/>        ...<br/>    }<br/>}</span></pre><p id="32a8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们将创建一个存储当前执行线程的类变量。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="957f" class="ne kx iq na b gy nf ng l nh ni">public class Stopwatch implements Runnable<br/>{<br/>    private long offset, currentStart;<br/>    private boolean isStopped;<br/>    private Thread th;  // Thread that prints the time of the stopwatch<br/>    ...</span><span id="b6c7" class="ne kx iq na b gy nk ng l nh ni">}</span></pre><p id="2d39" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，当客户端调用start()方法时，我们只需要创建一个新线程并启动它。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="03d6" class="ne kx iq na b gy nf ng l nh ni">public void start()<br/>{<br/>    if(isStopped)<br/>    {<br/>        th = new Thread(this);<br/>        th.start();<br/>        currentStart = System.<em class="nj">currentTimeMillis</em>() - offset;<br/>    }<br/><br/>    isStopped = false;<br/>}</span></pre><p id="e047" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当客户端调用stop()方法时，我们需要销毁线程。因为Java没有给我们任何东西来破坏一个线程，所以我们只是通过将thread变量设置为“null”来取消对它的引用，并依靠垃圾收集器来清理它。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="d124" class="ne kx iq na b gy nf ng l nh ni">public void stop()<br/>{<br/>    if(!isStopped)<br/>    {<br/>        th =null;<br/>        offset = System.<em class="nj">currentTimeMillis</em>() - currentStart;<br/>    }<br/>    isStopped = true;<br/>}</span></pre><p id="8e65" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意:当客户机点击stop()方法时，线程将停止打印，因为“isStopped”布尔值为真，这使得线程的while循环条件为假，从而完成线程执行。</p><p id="c288" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就是我们对秒表类所做的一切。是时候清理客户端代码并享受封装了。</p><p id="a52c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们去StopwatchTest.java吧。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="bd05" class="ne kx iq na b gy nf ng l nh ni">Stopwatch sw = new Stopwatch();<br/><br/><em class="nj">//        Thread observerThread = new Thread(new Runnable() {<br/>//            @Override<br/>//            public void run() {<br/>//                while (true)<br/>//                {<br/>//                    System.out.print("\rTime: "+ sw.getTime());<br/>//                    sleep(10);<br/>//                }<br/>//<br/>//            }<br/>//        });<br/>//        observerThread.start();<br/><br/><br/>        </em>System.<em class="nj">out</em>.println("\nStarting Stopwatch: ");<br/>        sw.start();<br/>        <em class="nj">sleep</em>(2000);<br/>        sw.stop();<br/>        System.<em class="nj">out</em>.println("\nStopwatch Stopped. ");<br/><br/>        <em class="nj">sleep</em>(2000);<br/><br/>        System.<em class="nj">out</em>.println("\nStarting Stopwatch: ");<br/>        sw.start();<br/>        <em class="nj">sleep</em>(2000);<br/>        sw.stop();<br/>        System.<em class="nj">out</em>.println("\nStopwatch Stopped. ");<br/><br/>    }</span></pre><p id="7782" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">唯一需要删除的是评论的部分。一旦你删除它，你会发现客户端代码清理器。</p><p id="8646" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们来测试一下。</p><figure class="mv mw mx my gt jq gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/0713e682b49db8a40ea8f7e09935cad2.png" data-original-src="https://miro.medium.com/v2/resize:fit:884/format:webp/1*kRZz028zwAaUHbTUyG17sg.png"/></div></figure><p id="6045" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">像以前一样工作，但是这一次客户端不需要考虑创建线程，向它传递一个runnable，以及所有那些废话。</p><p id="63ac" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我发现了整件事的一个问题。看看我们在做什么。我们只是打印秒表运行的时间(在不同的线程上)。在大多数实际应用中，不需要打印时间。需要做的事情是将时间从秒表异步发送到客户端，客户端可以计算出如何处理时间。幸运的是，有一种设计模式可以帮助我们，你已经听过很多次了:观察者。在下一篇博客中，我们将看看这种模式是什么，以及我们如何修改代码来实现这种模式。下一集再见。</p><h1 id="b3d4" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">下一个教程:</h1><p id="d058" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated"><a class="ae mi" href="https://rajtilakls2510.medium.com/applying-the-observer-pattern-part-3-e46ce30c2d32" rel="noopener">应用观察者模式</a></p><h1 id="7eac" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">完整代码</h1><p id="d187" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated"><a class="ae mi" href="https://github.com/rajtilakls2510/Stopwatch/tree/S2_Encapsulating_Thread_logic_in_stopwatch" rel="noopener ugc nofollow" target="_blank">完整的代码在这里。</a></p><p id="a622" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Stopwatch.java</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="5160" class="ne kx iq na b gy nf ng l nh ni">public class Stopwatch implements Runnable<br/>{<br/>    private long offset, currentStart;<br/>    private boolean isStopped;<br/>    Thread th;<br/><br/>    public Stopwatch()<br/>    {<br/>        offset = 0L;<br/>        currentStart = System.<em class="nj">currentTimeMillis</em>();<br/>        isStopped = true;<br/>    }<br/><br/>    public void start()<br/>    {<br/>        if(isStopped)<br/>        {<br/>            th = new Thread(this);<br/>            th.start();<br/>            currentStart = System.<em class="nj">currentTimeMillis</em>() - offset;<br/>        }<br/><br/>        isStopped = false;<br/>    }<br/><br/>    public void stop()<br/>    {<br/>        if(!isStopped)<br/>        {<br/>            th =null;<br/>            offset = System.<em class="nj">currentTimeMillis</em>() - currentStart;<br/>        }<br/>        isStopped = true;<br/>    }<br/><br/>    public long getTime()<br/>    {<br/>        if(!isStopped)<br/>            return System.<em class="nj">currentTimeMillis</em>() - currentStart;<br/>        else<br/>            return offset;<br/>    }<br/><br/>    @Override<br/>    public void run() {<br/>        while(!isStopped)<br/>        {<br/>            System.<em class="nj">out</em>.print("\rTime: "+ getTime());<br/>            try {<br/>                Thread.<em class="nj">sleep</em>(10);<br/>            } catch (InterruptedException e) {<br/>                e.printStackTrace();<br/>            }<br/>        }<br/>    }<br/>}</span></pre><p id="fb9c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">StopwatchTest.java</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="d61d" class="ne kx iq na b gy nf ng l nh ni">public class StopwatchTest {<br/>    public static void main(String[] args) {<br/>        Stopwatch sw = new Stopwatch();<br/><br/><br/><br/>        System.<em class="nj">out</em>.println("\nStarting Stopwatch: ");<br/>        sw.start();<br/>        <em class="nj">sleep</em>(2000);<br/>        sw.stop();<br/>        System.<em class="nj">out</em>.println("\nStopwatch Stopped. ");<br/><br/>        <em class="nj">sleep</em>(2000);<br/><br/>        System.<em class="nj">out</em>.println("\nStarting Stopwatch: ");<br/>        sw.start();<br/>        <em class="nj">sleep</em>(2000);<br/>        sw.stop();<br/>        System.<em class="nj">out</em>.println("\nStopwatch Stopped. ");<br/><br/>    }<br/><br/>    public static void sleep(int time)<br/>    {<br/>        try {<br/>            Thread.<em class="nj">sleep</em>(time);<br/>        } catch (InterruptedException e) {<br/>            e.printStackTrace();<br/>        }<br/>    }<br/>}</span></pre><h1 id="ffad" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">参考资料:</h1><ul class=""><li id="9f89" class="lz ma iq ka b kb lu kf lv kj nm kn nn kr no kv me mf mg mh bi translated">书籍:<a class="ae mi" href="https://www.oreilly.com/library/view/head-first-design/0596007124/" rel="noopener ugc nofollow" target="_blank"> Head First设计模式</a>，作者埃里克·弗里曼、伊丽莎白·罗布森、伯特·贝茨、凯西·塞拉。</li></ul></div></div>    
</body>
</html>