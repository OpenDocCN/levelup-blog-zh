<html>
<head>
<title>Fluttering Dart: Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">飞舞的飞镖:功能</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/fluttering-dart-b37110f4d1bf?source=collection_archive---------0-----------------------#2019-11-15">https://levelup.gitconnected.com/fluttering-dart-b37110f4d1bf?source=collection_archive---------0-----------------------#2019-11-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="6431" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph"><a class="ae ep" rel="noopener ugc nofollow" target="_blank" href="https://levelup.gitconnected.com/fluttering-dart/home">飘动的飞镖</a></h2><div class=""/><div class=""><h2 id="5b70" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">如何在Dart中编写、使用和滥用函数</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/552f768c8669a0423ce6470521a34ed2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*88Gz2J-Hje09d7geYn752A.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><a class="ae lh" href="https://unsplash.com/@the_roaming_platypus?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> timJ </a>在<a class="ae lh" href="https://unsplash.com/s/photos/function?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="b414" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><a class="ae lh" href="https://flutter.dev" rel="noopener ugc nofollow" target="_blank"> Flutter </a>项目可以使用特定平台和跨平台代码。后者是用<a class="ae lh" href="https://dart.dev" rel="noopener ugc nofollow" target="_blank"> Dart </a>写的，而且，构建Flutter apps，需要一些Dart的基础知识。</p><p id="5779" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><a class="ae lh" href="https://medium.com/tag/fluttering-dart/archive" rel="noopener"/></p><p id="5647" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在本系列的第一部分中，我们介绍了Dart <a class="ae lh" href="https://medium.com/@constanting/fluttering-dart-9a3e74b0d9c5" rel="noopener"> <strong class="lk jd">内置数据类型</strong> </a>。</p><p id="5ec5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在第二部分，我们将发现函数。</p><p id="ce44" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">可以使用<a class="ae lh" href="https://dartpad.dev" rel="noopener ugc nofollow" target="_blank"><strong class="lk jd"/></a>对一些代码示例进行试验和测试。</p><h2 id="ff22" class="me mf it bd mg mh mi dn mj mk ml dp mm lr mn mo mp lv mq mr ms lz mt mu mv iz bi translated">功能</h2><p id="d3ce" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">一个<strong class="lk jd">函数</strong>(在一个对象的上下文中也可能被称为<strong class="lk jd">方法</strong>)是一个算法的子集，它在逻辑上是分离的并且是可重用的。它可以不返回任何东西(<strong class="lk jd"> void </strong>)或者返回一个<a class="ae lh" href="https://medium.com/@constanting/fluttering-dart-9a3e74b0d9c5" rel="noopener">内置数据类型</a>或者一个自定义数据类型。它也可以没有参数或有任意数量的参数。</p><p id="7d6d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在Dart这种真正面向对象的编程语言中，函数也是对象，它们的类型是，你猜对了，<strong class="lk jd"> Function </strong>。</p><p id="9960" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这意味着:我们可以将函数赋给变量，或者将它们作为参数传递给其他函数。</p><p id="951f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">名为<strong class="lk jd"> toggle </strong>的简单函数示例如下所示:</p><pre class="ks kt ku kv gt nb nc nd ne aw nf bi"><span id="82c5" class="me mf it nc b gy ng nh l ni nj">bool toggle(bool value) {<br/>  // returns the opposite <br/>  return !value;<br/>}</span></pre><p id="1fbc" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们可以省略类型，函数也一样工作(尽管建议使用类型注释):</p><pre class="ks kt ku kv gt nb nc nd ne aw nf bi"><span id="bfb4" class="me mf it nc b gy ng nh l ni nj">toggle(value) {<br/>  // also returns the opposite<br/>  return !value;<br/>}</span></pre><p id="f88a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">对于只包含一个表达式的函数，我们可以使用一个简写语法(也称为<strong class="lk jd">箭头语法</strong>):</p><pre class="ks kt ku kv gt nb nc nd ne aw nf bi"><span id="8614" class="me mf it nc b gy ng nh l ni nj">toggle(value) =&gt; !value;</span></pre><p id="92e6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">函数可以有两种类型的参数:<strong class="lk jd">必需的</strong>和<strong class="lk jd">可选的</strong>。必需的参数在第一行，后面是可选的参数。</p><h2 id="581b" class="me mf it bd mg mh mi dn mj mk ml dp mm lr mn mo mp lv mq mr ms lz mt mu mv iz bi translated">可选参数</h2><p id="ea2f" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">这些可以是<strong class="lk jd"/><strong class="lk jd">命名的</strong>或<strong class="lk jd">位置的</strong>:</p><ul class=""><li id="4e6e" class="nk nl it lk b ll lm lo lp lr nm lv nn lz no md np nq nr ns bi translated"><strong class="lk jd">命名为</strong>参数</li></ul><p id="7679" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">调用函数时，我们可以使用<code class="fe nt nu nv nc b"><em class="nw">paramName</em>: <em class="nw">value</em></code>指定命名参数。例如:</p><pre class="ks kt ku kv gt nb nc nd ne aw nf bi"><span id="f368" class="me mf it nc b gy ng nh l ni nj">toggleSound(to: true, notifyUser:false);</span></pre><p id="fd6f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">定义函数时，使用<code class="fe nt nu nv nc b">{<em class="nw">param1</em>, <em class="nw">param2</em>, ...}</code>指定命名参数:</p><pre class="ks kt ku kv gt nb nc nd ne aw nf bi"><span id="1579" class="me mf it nc b gy ng nh l ni nj">void toggleSound({bool to, bool notifyUser}) {<br/>  // code that (optionally) toggles the sound<br/>  // and (optionally) notifies the user<br/>}</span></pre><p id="1a0e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">默认情况下，命名参数是可选的。为了使它们具有强制性，我们必须用<code class="fe nt nu nv nc b">@required</code>来注释它们(这在DartPad中不起作用):</strong></p><pre class="ks kt ku kv gt nb nc nd ne aw nf bi"><span id="f81e" class="me mf it nc b gy ng nh l ni nj">import 'package:meta/meta.dart';</span><span id="d81d" class="me mf it nc b gy nx nh l ni nj">void toggleSound({<strong class="nc jd">@required</strong> bool to, bool notifyUser}) {<br/>  // code that toggles the sound<br/>  // and (optionally) notifies the user<br/>}</span></pre><ul class=""><li id="a867" class="nk nl it lk b ll lm lo lp lr nm lv nn lz no md np nq nr ns bi translated"><strong class="lk jd">位置</strong>参数</li></ul><p id="1ccf" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果我们在<code class="fe nt nu nv nc b">[]</code>中包装一组函数参数，我们将它们标记为可选的位置参数。上面的例子变成了:</p><pre class="ks kt ku kv gt nb nc nd ne aw nf bi"><span id="28f4" class="me mf it nc b gy ng nh l ni nj">void toggleSound(bool to, <strong class="nc jd">[</strong>bool notifyUser<strong class="nc jd">]</strong>) {<br/>  // code that toggles the sound<br/>  // and (optionally) notifies the user<br/>}</span></pre><p id="007d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们可以将编译时常量设置为命名参数或位置参数的默认值。如果没有提供值，那么参数将为空。</p><p id="0d74" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">假设我们想将上面例子中的<strong class="lk jd"> notifyUser </strong>的默认值设置为<strong class="lk jd"> false </strong>。这将看起来像:</p><pre class="ks kt ku kv gt nb nc nd ne aw nf bi"><span id="3fc8" class="me mf it nc b gy ng nh l ni nj">void toggleSound({bool to, bool notifyUser<strong class="nc jd">=false</strong>}) {<br/>  // code that (optionally) toggles the sound<br/>  // and (by default) doesn't notify the user<br/>}</span></pre><p id="ffad" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们应该注意，只有可选参数可以有默认值。</p><h2 id="bdaa" class="me mf it bd mg mh mi dn mj mk ml dp mm lr mn mo mp lv mq mr ms lz mt mu mv iz bi translated">主()</h2><p id="9942" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">我们构建的每个应用程序都必须有一个入口点，这个角色由强制的顶级<code class="fe nt nu nv nc b">main()</code>函数来担当。该函数返回<code class="fe nt nu nv nc b">void</code>，并有一个可选的<code class="fe nt nu nv nc b">List&lt;String&gt;</code>参数作为参数，如下所示:</p><pre class="ks kt ku kv gt nb nc nd ne aw nf bi"><span id="52a3" class="me mf it nc b gy ng nh l ni nj">// a web app<br/>void <strong class="nc jd">main</strong>() {<br/>  // web app code goes here<br/>}</span></pre><p id="c2f1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">或者</p><pre class="ks kt ku kv gt nb nc nd ne aw nf bi"><span id="ed91" class="me mf it nc b gy ng nh l ni nj">// a command line app<br/>void <strong class="nc jd">main</strong>(List&lt;String&gt; arguments) {<br/>  print(arguments);<br/>}</span></pre><h2 id="a0ec" class="me mf it bd mg mh mi dn mj mk ml dp mm lr mn mo mp lv mq mr ms lz mt mu mv iz bi translated">一等品</h2><p id="fad8" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">如开头所述，我们可以将函数作为参数传递给其他函数，也可以将它们赋给变量:</p><pre class="ks kt ku kv gt nb nc nd ne aw nf bi"><span id="4a17" class="me mf it nc b gy ng nh l ni nj">Function <strong class="nc jd">_toggleSound</strong> = (SoundSource source, [bool to=false, bool notifyUser=false]) {<br/>  // code that toggles the sound of a SoundSource object<br/>  // by default mutes it without notification<br/>}</span><span id="cdf8" class="me mf it nc b gy nx nh l ni nj">List&lt;SoundSource&gt; soundSources = &lt;SoundSource&gt;[source1, source2, source3];</span><span id="0ec3" class="me mf it nc b gy nx nh l ni nj">// we're passing the _toggleSound Function variable as<br/>// parameter to the forEach method of the soundSources List object<br/>soundSources.forEach(_toggleSound);</span></pre><h2 id="de96" class="me mf it bd mg mh mi dn mj mk ml dp mm lr mn mo mp lv mq mr ms lz mt mu mv iz bi translated">匿名函数</h2><p id="2590" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">尽管我们将要创建的大多数函数都是并且应该被命名的，但是我们可以选择创建无名函数。这些函数被称为<strong class="lk jd">匿名</strong>、<strong class="lk jd">λ</strong>或<strong class="lk jd">闭包</strong>函数。</p><p id="2f19" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在前面的代码示例中，我们已经定义了这样的函数，并将其赋给了函数变量<strong class="lk jd"> _toggleSound </strong>。</p><h2 id="5311" class="me mf it bd mg mh mi dn mj mk ml dp mm lr mn mo mp lv mq mr ms lz mt mu mv iz bi translated">词法范围和闭包</h2><p id="9247" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">Dart是一种词汇作用域语言，这意味着变量的作用域是静态确定的，只是由代码的布局决定。我们可以“沿着花括号向外”来查看变量是否在范围内。</p><p id="a4d2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在下面的<strong class="lk jd">游戏</strong>示例中，<strong class="lk jd">敌人</strong>字符串变量对于所有嵌套函数都是可用的，或者在作用域内，除非我们决定通过声明一个同名的变量来覆盖该值(新变量将只在该作用域级别上可用)。我们在第一级函数<strong class="lk jd">中做了这个。作用域结束后，该变量将不再存在，并且上层声明的变量将再次可用。</strong></p><pre class="ks kt ku kv gt nb nc nd ne aw nf bi"><span id="b6f1" class="me mf it nc b gy ng nh l ni nj">void main() {<br/>  String enemy = '';<br/>  void <strong class="nc jd">game</strong>() {<br/>    void <strong class="nc jd">init</strong>() {<br/>      enemy = 'boss';<br/>    }<br/>    void <strong class="nc jd">firstLevel</strong>() {<br/>      String enemy = 'miniboss';<br/>      print(enemy);<br/>    }<br/>    void <strong class="nc jd">endGame</strong>() {<br/>      print(enemy);<br/>    }<br/>    init();<br/>    firstLevel();<br/>    endGame();<br/>  }<br/>  game();<br/>}</span></pre><p id="de42" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><strong class="lk jd">闭包</strong>是可以访问其作用域内变量的函数对象，即使是在它们的初始作用域之外使用。</p><p id="0eea" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">函数可以封闭周围作用域中定义的变量。在下面的例子中，<strong class="lk jd">customize regement</strong>捕获变量<strong class="lk jd"> greeting </strong>。无论返回的函数走到哪里，它都会记住<strong class="lk jd">问候</strong>。</p><pre class="ks kt ku kv gt nb nc nd ne aw nf bi"><span id="cdb9" class="me mf it nc b gy ng nh l ni nj">Function <strong class="nc jd">customiseGreeting</strong>(String greeting) {<br/>  return (String name) =&gt; '$greeting, $name,';<br/>}</span><span id="dc2d" class="me mf it nc b gy nx nh l ni nj">void main() {<br/>  var goodMorning = customiseGreeting('Good morning');<br/>  var goodEvening = customiseGreeting('Good evening');</span><span id="aeb2" class="me mf it nc b gy nx nh l ni nj">  print(goodMorning('Monica'));<br/>  print(goodEvening('Monica'));<br/>}</span></pre><h2 id="4ba9" class="me mf it bd mg mh mi dn mj mk ml dp mm lr mn mo mp lv mq mr ms lz mt mu mv iz bi translated">Typedefs</h2><p id="1547" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">在Dart中，函数是对象(Function类型的实例)。实际类型实际上是其签名的结果:参数类型+返回类型。</p><p id="d9ae" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当函数用作参数或返回值时，重要的是实际的函数类型。Dart中的<strong class="lk jd"> typedef </strong>允许我们创建一个函数类型的别名。类型别名可以像其他类型一样使用。</p><pre class="ks kt ku kv gt nb nc nd ne aw nf bi"><span id="e2fe" class="me mf it nc b gy ng nh l ni nj"><strong class="nc jd">typedef</strong> Processor&lt;T&gt; = T Function(T value);<br/><strong class="nc jd">typedef</strong> Printer&lt;T&gt; = void Function(T value);</span><span id="21f9" class="me mf it nc b gy nx nh l ni nj">Function customiseGreeting(String greeting) {<br/>  return (String name) =&gt; '$greeting, $name,';<br/>}</span><span id="2a10" class="me mf it nc b gy nx nh l ni nj">void <strong class="nc jd">greet</strong>&lt;T&gt;(List&lt;T&gt; list, Processor&lt;T&gt; processor, Printer&lt;T&gt; printer) {<br/>  list.forEach((item) {<br/>    printer(processor(item));<br/>  });<br/>}</span><span id="f004" class="me mf it nc b gy nx nh l ni nj">void main() {<br/>  Function goodMorning = customiseGreeting('Good morning'); <br/>  greet(['Monica', 'cats', 'Collin'], goodMorning, print);<br/>}</span></pre><p id="d9fd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在上面的例子中，我们有<strong class="lk jd"> greet </strong>函数，它获取一个名字列表并问候列表中的每个人。它使用处理器和打印机打印。处理器是我们在前面的例子中使用的函数<strong class="lk jd">customize regering</strong>。打印机是实际的<strong class="lk jd">打印</strong>功能。</p><h2 id="adc5" class="me mf it bd mg mh mi dn mj mk ml dp mm lr mn mo mp lv mq mr ms lz mt mu mv iz bi translated">例外</h2><p id="0cfb" class="pw-post-body-paragraph li lj it lk b ll mw kd ln lo mx kg lq lr my lt lu lv mz lx ly lz na mb mc md im bi translated">我们经常在其他函数内部调用函数，有时，这些函数会失败。</p><p id="0b37" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">Dart有一个类似于Java的异常机制，不同之处在于Dart中的所有异常都是未检查的(函数不会声明它们可能抛出的异常)。这意味着我们可以跳过捕捉异常。这种自由会损害应用程序的整体性能和可靠性，健壮的应用程序应该能够正确处理故障。</p><p id="c136" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了<strong class="lk jd">报告失败</strong>我们应该使用<code class="fe nt nu nv nc b">throw</code>关键字。虽然所有非空对象都可以被<strong class="lk jd">抛出</strong> n，但是建议我们只抛出<strong class="lk jd">错误</strong>和<strong class="lk jd">异常</strong>类型的对象。</p><p id="39b3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">一个<strong class="lk jd">错误</strong>对象代表了我们代码中的一个错误。错误是不应该被捕获的，通常它们会导致程序终止。</p><p id="88cd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">一个<strong class="lk jd">异常</strong>对象代表代码中一个不成功的事件转折。与错误相比，它们应该被捕捉和处理。它们通常携带有用的信息。我们应该创建自定义数据类型，从异常扩展到封装有用的数据。</p><p id="9cbb" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">抛出异常后，我们可以<strong class="lk jd">捕捉</strong>并阻止它传播。主要目标是处理它(我们不应该只是为了好玩而捕捉异常)。</p><p id="cbcd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">使用<code class="fe nt nu nv nc b">try</code>、<code class="fe nt nu nv nc b">on</code>和<code class="fe nt nu nv nc b">catch</code>关键字捕获异常。<code class="fe nt nu nv nc b">catch</code>在我们想要访问异常对象和堆栈跟踪时使用，而<code class="fe nt nu nv nc b">on</code>在我们不关心这些时使用。</p><p id="1bc3" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">要重新抛出一个异常，我们应该使用<code class="fe nt nu nv nc b">rethrow</code>关键字。当我们想要部分地处理一个异常(不是一个好的实践)或者需要它在堆栈中更高的位置时，这可以派上用场。</p><p id="59f1" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">最后，我们有<code class="fe nt nu nv nc b">finally</code>关键字，它允许我们在最后运行代码，不管我们在运行过程中遇到了什么异常。</p><p id="89a0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">将所有这些应用到前面的例子中，并确保我们引起了一个异常，我们会得到:</p><pre class="ks kt ku kv gt nb nc nd ne aw nf bi"><span id="5e57" class="me mf it nc b gy ng nh l ni nj">void main() {<br/>  Function goodMorning;<br/>  <strong class="nc jd">try</strong> {<br/>    goodMorning('test');<br/>  } <strong class="nc jd">on</strong> NoSuchMethodError <strong class="nc jd">catch</strong>(e) {<br/>    print('our attempt to greet failed: ${e.runtimeType}'); <br/>    goodMorning = customiseGreeting('Good morning'); <br/>  } <strong class="nc jd">finally</strong> {<br/>    greet(['Monica', 'cats', 'Collin'], goodMorning, print);<br/>  }<br/>}</span></pre></div><div class="ab cl ny nz hx oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="im in io ip iq"><p id="03e7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">Dart函数灵活且非常强大。</p><p id="b1bd" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">你可以看看这个使用顶级函数的好例子:</p><div class="of og gp gr oh oi"><a href="https://medium.com/@constanting/your-explosive-energy-aaab2e9d94c4" rel="noopener follow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd jd gy z fp on fr fs oo fu fw jc bi translated">你的爆发力</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">发现它使用颤振或飞镖</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">medium.com</p></div></div><div class="or l"><div class="os l ot ou ov or ow lb oi"/></div></div></a></div><p id="642c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我们刚刚讨论了函数的基础知识。要掌握所有相关的东西，需要一些时间和练习。</p><p id="b008" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在<a class="ae lh" href="https://medium.com/tag/fluttering-dart/archive" rel="noopener"> <strong class="lk jd">颤动飞镖</strong> </a>系列的下一部分中，我们将深入研究<a class="ae lh" href="https://medium.com/@constanting/fluttering-dart-ee493f4b0440" rel="noopener">操作符</a>，这是构建健壮颤动应用程序所需的另一个飞镖基础。</p><div class="of og gp gr oh oi"><a href="https://medium.com/@constanting/fluttering-dart-ee493f4b0440" rel="noopener follow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd jd gy z fp on fr fs oo fu fw jc bi translated">飞舞的飞镖:操作符</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">Dart的操作员…一个接一个</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">medium.com</p></div></div><div class="or l"><div class="ox l ot ou ov or ow lb oi"/></div></div></a></div><p id="70e0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">就这些！</p></div></div>    
</body>
</html>