<html>
<head>
<title>The Simplest Way to Achieve Heapify</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">达到健康的最简单方法</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/a-better-way-to-understand-heap-data-structure-3c60b74295e8?source=collection_archive---------6-----------------------#2020-11-30">https://levelup.gitconnected.com/a-better-way-to-understand-heap-data-structure-3c60b74295e8?source=collection_archive---------6-----------------------#2020-11-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="497b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">具有升/降档功能</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/06a61115d2354ea9ec2a70f4e6ccaee8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dVT5Lc_GCr1eIoVa"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">杰斯温·托马斯在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="42d0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">谈到堆，有些人可能会想到二叉树结构，其中父节点总是比子节点大或小。</p><p id="8ff6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">实际上，堆是由一个数组来表示的。它只是有一个特殊的方案来操纵项目，以降低时间复杂度。</p><p id="05a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">堆有它的基本操作，如add()、delete()、size()等。在本文中，我们介绍了一种理解堆及其上移和下移功能的新方法。</p><h1 id="08e5" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">插入新项目并上移</h1><p id="8a36" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">假设我们有一个最大堆，我们需要添加一个新的项目。如果堆是一个数组，我们把它附加到末尾。之后，我们必须执行升档功能。</p><p id="3d42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">形成下图，主要步骤是</p><blockquote class="ms mt mu"><p id="7d8b" class="kz la mv lb b lc ld ju le lf lg jx lh mw lj lk ll mx ln lo lp my lr ls lt lu im bi translated">比较子项目和它的父项目，如果子项目大于父项目，我们交换它们。</p></blockquote><p id="26b2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">由于堆是一个树状结构，我们可以很容易地找到父项，即<strong class="lb iu"> int(k/2) </strong>，其中<strong class="lb iu"> k </strong>是当前的子项。其余的可以用同样的方式完成。</p><p id="7139" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">时间共谋:O (logn)</p><p id="50e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个提示:不要忘记检查<strong class="lb iu"> k </strong>是否入站。</p><div class="kj kk kl km gt ab cb"><figure class="mz kn na nb nc nd ne paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/986403d2d690d1224dfcb124a9631552.png" data-original-src="https://miro.medium.com/v2/resize:fit:1008/format:webp/1*WPFYrICk4_7rJ6c9XLy0Rg.png"/></div></figure><figure class="mz kn nf nb nc nd ne paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/962fa7f76622666cc4b243bde0e91d98.png" data-original-src="https://miro.medium.com/v2/resize:fit:994/format:webp/1*hZoKqILZNsExI0xeLEY20g.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk ng di nh ni translated">来源:<a class="ae ky" href="https://coding.imooc.com/" rel="noopener ugc nofollow" target="_blank">coding.imooc.com</a></figcaption></figure></div><div class="ab cb"><figure class="mz kn nj nb nc nd ne paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/1624152b432963a5990b5b790f9065ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:988/format:webp/1*fPOXMKnxF2VYVXrDp0SAkg.png"/></div></figure><figure class="mz kn nk nb nc nd ne paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/aff90512af511a39899fae8ff66dd9a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1014/format:webp/1*4GKJC1WWD64pRduNvdI85Q.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk nl di nm ni translated">来源:<a class="ae ky" href="https://coding.imooc.com/" rel="noopener ugc nofollow" target="_blank">coding.imooc.com</a></figcaption></figure></div><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><h1 id="975c" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">删除项目并下移</h1><p id="9c7d" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">当需要下移时，heap有它特殊的方法来删除条目。我们不能删除任何我们想要的项目。正如图片所提到的，</p><blockquote class="ms mt mu"><p id="9c98" class="kz la mv lb b lc ld ju le lf lg jx lh mw lj lk ll mx ln lo lp my lr ls lt lu im bi translated">我们用最下面的一项替换第一项，然后下移</p></blockquote><p id="91a2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们向下移动时，我们可以找到它的子节点，即<strong class="lb iu"> 2k(左)</strong>和<strong class="lb iu"> 2k + 1(右)。</strong>然后，我们将父项与左右项进行比较，以找到要交换的最大项。如果父项是最大值，我们保持不变。</p><p id="ac86" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">时间共谋:O (logn)</p><p id="be5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">提示:不要忘记确保k是入站的。</p><div class="kj kk kl km gt ab cb"><figure class="mz kn np nb nc nd ne paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/9e6cac9be45daaf067ce3e62bb1db1ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:992/format:webp/1*Nb3NWZoPXx2bB-RtiypUvg.png"/></div></figure><figure class="mz kn nq nb nc nd ne paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/0798645ef4c6ca59eefd0fffbf14473f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1010/format:webp/1*4c-b2iWkPRfidxGbZnp1wQ.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk nr di ns ni translated">来源:<a class="ae ky" href="https://coding.imooc.com/" rel="noopener ugc nofollow" target="_blank">coding.imooc.com</a></figcaption></figure></div><div class="ab cb"><figure class="mz kn nt nb nc nd ne paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/39899d6a9eb7a050c0c3a4df1148517d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/1*Eg4Yxoblp69OrwgB28p6kg.png"/></div></figure><figure class="mz kn nu nb nc nd ne paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><img src="../Images/388664dec30c13a350e43298a81fe722.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*Z_Ans3tZLhDy2zhmkI9eNQ.png"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk nv di nw ni translated">来源:<a class="ae ky" href="https://coding.imooc.com/" rel="noopener ugc nofollow" target="_blank">coding.imooc.com</a></figcaption></figure></div><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><h1 id="3e61" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">摘要和完整代码:</h1><p id="744b" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">在这个堆构造中，上移和下移是最核心的部分。我们可以很容易地移动它们，因为很容易找到父项和子项。</p><p id="2a74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你以前学过heap，那么Heapify是一个比较流行的概念。我们可以找到一个非常复杂的heapify函数，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="fe1c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们通过定位第一个非叶节点(k/2)并反向调用shiftDown()来简化堆。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/e6f394a5602b71fbd05fe5562cba38ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:696/format:webp/1*OI31KSGu_bkeHEZ_C5FxeA.png"/></div></figure><p id="3b74" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里我附上了<a class="ae ky" href="https://gist.github.com/lee197/7a248462eadc9a5a7dcd0c20f1826cf7" rel="noopener ugc nofollow" target="_blank">的完整代码</a>。希望你能从这篇文章中学到一些东西。如果你有兴趣阅读我的其他文章，欢迎查看我的个人资料。祝你的编码面试成功！</p></div></div>    
</body>
</html>