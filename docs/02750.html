<html>
<head>
<title>How to Create a Production-Ready Webpack 4 Config From Scratch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何从头开始创建生产就绪的Webpack 4配置</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-create-a-production-ready-webpack-4-config-from-scratch-ba1862e1607c?source=collection_archive---------11-----------------------#2020-04-02">https://levelup.gitconnected.com/how-to-create-a-production-ready-webpack-4-config-from-scratch-ba1862e1607c?source=collection_archive---------11-----------------------#2020-04-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/fdd01ddd1d3e92c674359c839b3e3484.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_StgGlYw8ORbvNv1"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">由<a class="ae kf" href="https://unsplash.com/@max_duz?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Max Duzij </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="b1ba" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Webpack是一个强大的捆绑器和依赖管理器，被许多企业级公司用作前端代码的工具。</p><p id="073a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通常，webpack是在项目第一次建立时配置的，然后根据需要不时地对配置文件进行小的调整。正因为如此，许多开发人员没有很多使用webpack的经验。</p><p id="7e27" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本实践教程中，我们将介绍使用webpack 4设置您自己的生产就绪webpack配置的基础知识。我们将讨论输出管理、资产管理、开发和生产配置、通天塔、缩小、缓存破坏等等。</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div class="gh gi le"><img src="../Images/f2eb619ffde5b9fdf223097fb26ad2b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*APZBl8Vso6tzcnZI.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">Webpack捆绑您的代码</figcaption></figure><p id="dc36" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们开始吧！</p></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h1 id="8fa9" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">演示应用程序</h1><p id="2e92" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">出于本演示的目的，我们将使用webpack 4从头开始设置webpack配置。我们的应用程序将只使用普通的JavaScript，这样我们就不会陷入任何特定于框架的细节中。实际的应用程序代码将非常小，这样我们就可以更多地关注webpack。</p><p id="f1a9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您想继续学习，本文中的所有代码都可以在GitHub中找到。<a class="ae kf" href="https://github.com/thawkin3/webpack-training-1/tree/demo/start" rel="noopener ugc nofollow" target="_blank">起点在这里</a>，完成结果在这里<a class="ae kf" href="https://github.com/thawkin3/webpack-training-1" rel="noopener ugc nofollow" target="_blank">。</a></p></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h1 id="d745" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">出发点</h1><p id="06a8" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">首先，我们将从项目目录中的几个文件开始。目录结构如下所示:</p><pre class="lf lg lh li gt mt mu mv mw aw mx bi"><span id="5539" class="my lr it mu b gy mz na l nb nc">webpack-demo<br/> |_ src<br/>    |_ index.js<br/> |_ .gitignore<br/> |_ index.html<br/> |_ package.json<br/> |_ README.md<br/> |_ yarn.lock</span></pre><p id="5c0e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe nd ne nf mu b">index.html</code>文件漂亮而简单，只有一个页面标题和一个<code class="fe nd ne nf mu b">script</code>标签:</p><pre class="lf lg lh li gt mt mu mv mw aw mx bi"><span id="ea22" class="my lr it mu b gy mz na l nb nc">&lt;!doctype html&gt;<br/>&lt;html&gt;<br/>  &lt;head&gt;<br/>    &lt;title&gt;Webpack Training 1&lt;/title&gt;<br/>  &lt;/head&gt;<br/>  &lt;body&gt;<br/>    &lt;h1&gt;Webpack Training 1&lt;/h1&gt;<br/>    &lt;script src="./src/index.js"&gt;&lt;/script&gt;<br/>  &lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="7416" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe nd ne nf mu b">script</code>标签引用了我们的<code class="fe nd ne nf mu b">./src/index.js</code>文件，其中只有几行JavaScript输出文本“Hello from webpack！”：</p><pre class="lf lg lh li gt mt mu mv mw aw mx bi"><span id="0062" class="my lr it mu b gy mz na l nb nc">const p = document.createElement('p')<br/>p.textContent = 'Hello from webpack!'<br/>document.body.append(p)</span></pre><p id="9b1a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你把<code class="fe nd ne nf mu b">index.html</code>文件拖到你的浏览器中，你应该能看到我们简单的网页:</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/be7b69f62c6370d1ce63250c0bfa685b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1184/format:webp/0*jAm3nbfuJnHBOE6I.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">演示应用程序输出1 —来自webpack的hello</figcaption></figure></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h1 id="e2fb" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">安装依赖项</h1><p id="518b" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">我已经将<code class="fe nd ne nf mu b">webpack</code>和<code class="fe nd ne nf mu b">webpack-cli</code>作为<code class="fe nd ne nf mu b">devDependencies</code>包含在<code class="fe nd ne nf mu b">package.json</code>文件中。</p><p id="bb83" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要安装它们，请运行:</p><pre class="lf lg lh li gt mt mu mv mw aw mx bi"><span id="1d66" class="my lr it mu b gy mz na l nb nc">yarn install</span></pre></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h1 id="d741" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">Webpack测试运行</h1><p id="c85a" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">Webpack 4被设置为“零配置”工具，这意味着您可以在不做任何初始配置的情况下立即运行它。现在，对于任何真正的项目，你<em class="nh">将</em>需要做一些配置，但是很好的是，你至少可以做一个快速的健全性检查，以确保webpack能够运行，而不必经历一堆初始配置步骤。</p><p id="c198" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以，我们来看看吧。运行:</p><pre class="lf lg lh li gt mt mu mv mw aw mx bi"><span id="4ae5" class="my lr it mu b gy mz na l nb nc">yarn webpack</span></pre><p id="368d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，您应该看到在您的项目目录中创建了一个<code class="fe nd ne nf mu b">dist</code>目录。在它里面你应该会看到一个<code class="fe nd ne nf mu b">main.js</code>文件，这是我们的简化代码。</p><p id="dfce" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">太好了！Webpack似乎正在工作。</p></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h1 id="47ec" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">引用输出代码</h1><p id="f1d9" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">好了，现在我们在<code class="fe nd ne nf mu b">dist</code>目录中有了JavaScript代码，让我们的<code class="fe nd ne nf mu b">index.html</code>文件引用它。而不是像这样的<code class="fe nd ne nf mu b">script</code>标签:</p><pre class="lf lg lh li gt mt mu mv mw aw mx bi"><span id="de29" class="my lr it mu b gy mz na l nb nc">&lt;script src="./src/index.js"&gt;&lt;/script&gt;</span></pre><p id="00a3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们把它改成这样:</p><pre class="lf lg lh li gt mt mu mv mw aw mx bi"><span id="e598" class="my lr it mu b gy mz na l nb nc">&lt;script src="./dist/main.js"&gt;&lt;/script&gt;</span></pre><p id="5829" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，在浏览器中刷新页面，您仍然应该看到完全相同的输出，只是这次是“来自webpack的Hello！”文本现在由<code class="fe nd ne nf mu b">./dist/main.js</code>文件生成。</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/fbe04b160ab45892958ef60e63e17fa5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1184/format:webp/0*eS_yavw0Txd_LA79.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">演示应用程序输出2 —无变化</figcaption></figure></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h1 id="b1d6" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">创建Webpack配置文件</h1><p id="2919" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">好了，现在我们已经安装了webpack并完成了快速的健全性检查，让我们创建一个实际的webpack配置文件。我们将创建一个名为<code class="fe nd ne nf mu b">webpack.config.js</code>的文件，并将以下代码放入其中:</p><pre class="lf lg lh li gt mt mu mv mw aw mx bi"><span id="7e22" class="my lr it mu b gy mz na l nb nc">const path = require('path')<br/><br/>module.exports = {<br/>  entry: './src/index.js',<br/>  output: {<br/>    filename: 'main.js',<br/>    path: path.resolve(__dirname, 'dist')<br/>  }<br/>}</span></pre><p id="9617" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">属性告诉webpack我们的源代码在哪里。它是我们应用程序的“入口”。</p><p id="2fc0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">属性告诉webpack如何调用输出文件以及将它放在哪个目录中。</p><p id="c498" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">很简单，对吧？</p><p id="9a76" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在让我们在<code class="fe nd ne nf mu b">package.json</code>文件中创建一个npm脚本:</p><pre class="lf lg lh li gt mt mu mv mw aw mx bi"><span id="a83a" class="my lr it mu b gy mz na l nb nc">"scripts": {<br/>  "build": "webpack --config=webpack.config.js"<br/>}</span></pre><p id="5a38" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们可以用命令<code class="fe nd ne nf mu b">yarn build</code>运行我们的构建过程。继续运行该命令，验证您已经正确设置了所有内容。您甚至可以在运行<code class="fe nd ne nf mu b">yarn build</code>命令之前删除您的<code class="fe nd ne nf mu b">dist</code>目录，以验证目录正在生成。</p></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h1 id="91ff" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">更改输出文件名</h1><p id="d806" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">现在，为了好玩，让我们更改输出文件名。要做到这一点，我们将打开我们的<code class="fe nd ne nf mu b">webpack.config.js</code>文件，并从下面更改<code class="fe nd ne nf mu b">output</code>属性:</p><pre class="lf lg lh li gt mt mu mv mw aw mx bi"><span id="a8c6" class="my lr it mu b gy mz na l nb nc">output: {<br/>  filename: 'main.js',<br/>  path: path.resolve(__dirname, 'dist')<br/>}</span></pre><p id="6614" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对此:</p><pre class="lf lg lh li gt mt mu mv mw aw mx bi"><span id="b0ea" class="my lr it mu b gy mz na l nb nc">output: {<br/>  filename: 'tacos.js',<br/>  path: path.resolve(__dirname, 'dist')<br/>}</span></pre><p id="158c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在再次运行<code class="fe nd ne nf mu b">yarn build</code>生成输出。现在您应该会在您的<code class="fe nd ne nf mu b">dist</code>目录中看到一个<code class="fe nd ne nf mu b">tacos.js</code>文件。</p><p id="fb32" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是等等！我们还可以在我们的<code class="fe nd ne nf mu b">dist</code>目录中看到旧的<code class="fe nd ne nf mu b">main.js</code>文件！如果webpack可以在我们每次进行新的构建时删除旧的不需要的输出，这不是很好吗？</p><p id="28cf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">肯定有一个插件可以做到这一点。</p></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h1 id="dcfe" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">Webpack插件</h1><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ni"><img src="../Images/5f42b856ad9dfb56a257e78292bc3e6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Cu1lnu9RzZWt_Skx"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@feelfarbig?utm_source=ghost&amp;utm_medium=referral&amp;utm_campaign=api-credit" rel="noopener ugc nofollow" target="_blank"> Feelfarbig杂志</a> / <a class="ae kf" href="https://unsplash.com/?utm_source=ghost&amp;utm_medium=referral&amp;utm_campaign=api-credit" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="866f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Webpack有一个丰富的模块生态系统，称为“<a class="ae kf" href="https://webpack.js.org/concepts/#plugins" rel="noopener ugc nofollow" target="_blank">插件</a>”，这些插件是可以修改和增强webpack构建过程的库。在本文的其余部分，我们将继续改进我们的webpack配置，并探索一些有用的插件。</p></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h1 id="8c93" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">CleanWebpackPlugin</h1><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ni"><img src="../Images/4562d1060443e961432f86b53bf76499.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bmo285NYopWLF4gL"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@honest?utm_source=ghost&amp;utm_medium=referral&amp;utm_campaign=api-credit" rel="noopener ugc nofollow" target="_blank">诚信公司</a> / <a class="ae kf" href="https://unsplash.com/?utm_source=ghost&amp;utm_medium=referral&amp;utm_campaign=api-credit" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="4a0b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">好，回到我们的问题。如果我们能在每次新构建之前清理掉<code class="fe nd ne nf mu b">dist</code>目录就好了。有一个插件可以做到这一点！</p><p id="f56a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以使用<a class="ae kf" href="https://github.com/johnagan/clean-webpack-plugin" rel="noopener ugc nofollow" target="_blank"> CleanWebpackPlugin </a>来帮助我们。首先，我们需要在我们的项目中安装它:</p><pre class="lf lg lh li gt mt mu mv mw aw mx bi"><span id="a99f" class="my lr it mu b gy mz na l nb nc">yarn add --dev clean-webpack-plugin</span></pre><p id="3b40" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要使用它，我们只需在我们的<code class="fe nd ne nf mu b">webpack.config.js</code>文件中添加<code class="fe nd ne nf mu b">require</code>插件，然后将它包含在我们的配置设置中的<code class="fe nd ne nf mu b">plugins</code>数组中:</p><pre class="lf lg lh li gt mt mu mv mw aw mx bi"><span id="d522" class="my lr it mu b gy mz na l nb nc">const path = require('path')<br/>const { CleanWebpackPlugin } = require('clean-webpack-plugin')<br/><br/>module.exports = {<br/>  entry: './src/index.js',<br/>  output: {<br/>    filename: 'main.js',<br/>    path: path.resolve(__dirname, 'dist')<br/>  },<br/>  plugins: [<br/>    new CleanWebpackPlugin()<br/>  ]<br/>}</span></pre><p id="cfcd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在再次运行<code class="fe nd ne nf mu b">yarn build</code>，您应该在<code class="fe nd ne nf mu b">dist</code>目录中只看到一个输出文件。问题解决了！</p></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h1 id="a40e" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">HTMLWebpackPlugin</h1><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ni"><img src="../Images/532e0869b83d002d0af87bfd4c3f58c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hR8LjKZK-2-ZLYae"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">弗洛里安·奥利沃 / <a class="ae kf" href="https://unsplash.com/?utm_source=ghost&amp;utm_medium=referral&amp;utm_campaign=api-credit" rel="noopener ugc nofollow" target="_blank">昂斯普什</a>拍摄的照片</figcaption></figure><p id="46e0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一件让我们的设置有点烦人的事情是，每当我们改变<code class="fe nd ne nf mu b">webpack.config.js</code>文件中的<code class="fe nd ne nf mu b">output</code>文件名时，我们也必须改变我们在<code class="fe nd ne nf mu b">index.html</code>文件中的<code class="fe nd ne nf mu b">script</code>标签中引用的文件名。如果webpack能帮我们做到这一点，那不是很好吗？</p><p id="ffee" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有一个插件可以做到这一点！我们可以使用HTMLWebpackPlugin来帮助我们管理HTML文件。现在让我们将它安装到我们的项目中:</p><pre class="lf lg lh li gt mt mu mv mw aw mx bi"><span id="4234" class="my lr it mu b gy mz na l nb nc">yarn add --dev html-webpack-plugin</span></pre><p id="40bb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">好了，现在让我们把我们的<code class="fe nd ne nf mu b">index.html</code>文件移到我们的<code class="fe nd ne nf mu b">src</code>目录中，这样它就是<code class="fe nd ne nf mu b">index.js</code>文件的兄弟。</p><pre class="lf lg lh li gt mt mu mv mw aw mx bi"><span id="efff" class="my lr it mu b gy mz na l nb nc">webpack-demo<br/> |_ src<br/>    |_ index.html<br/>    |_ index.js<br/> |_ .gitignore<br/> |_ package.json<br/> |_ README.md<br/> |_ yarn.lock</span></pre><p id="0fda" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还可以删除<code class="fe nd ne nf mu b">index.html</code>文件中的<code class="fe nd ne nf mu b">script</code>标签，因为我们将让webpack句柄为我们插入适当的<code class="fe nd ne nf mu b">script</code>标签。删除那一行，使您的<code class="fe nd ne nf mu b">index.html</code>文件看起来像这样:</p><pre class="lf lg lh li gt mt mu mv mw aw mx bi"><span id="c656" class="my lr it mu b gy mz na l nb nc">&lt;!doctype html&gt;<br/>&lt;html&gt;<br/>  &lt;head&gt;<br/>    &lt;title&gt;Webpack Training 1&lt;/title&gt;<br/>  &lt;/head&gt;<br/>  &lt;body&gt;<br/>    &lt;h1&gt;Webpack Training 1&lt;/h1&gt;<br/>  &lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="50e7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在让我们在<code class="fe nd ne nf mu b">webpack.config.js</code>文件中<code class="fe nd ne nf mu b">require</code>这个插件，然后在配置设置中将它包含在<code class="fe nd ne nf mu b">plugins</code>数组中，就像我们对第一个插件所做的那样:</p><pre class="lf lg lh li gt mt mu mv mw aw mx bi"><span id="c07a" class="my lr it mu b gy mz na l nb nc">const path = require('path')<br/>const { CleanWebpackPlugin } = require('clean-webpack-plugin')<br/>const HtmlWebpackPlugin = require('html-webpack-plugin')<br/><br/>module.exports = {<br/>  entry: './src/index.js',<br/>  output: {<br/>    filename: 'main.js',<br/>    path: path.resolve(__dirname, 'dist')<br/>  },<br/>  plugins: [<br/>    new CleanWebpackPlugin(),<br/>    new HtmlWebpackPlugin({<br/>      filename: 'index.html',<br/>      inject: true,<br/>      template: path.resolve(__dirname, 'src', 'index.html'),<br/>    }),<br/>  ]<br/>}</span></pre><p id="d3a5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在那些用于<code class="fe nd ne nf mu b">HtmlWebpackPlugin</code>的选项中，我们指定<code class="fe nd ne nf mu b">filename</code>作为我们希望输出文件被调用的名称。</p><p id="bd59" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们通过将值设置为<code class="fe nd ne nf mu b">true</code>来为<code class="fe nd ne nf mu b">inject</code>指定我们希望将JavaScript文件注入到<code class="fe nd ne nf mu b">body</code>标签中。</p><p id="ed2e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，对于<code class="fe nd ne nf mu b">template</code>，我们提供了<code class="fe nd ne nf mu b">index.html</code>文件在<code class="fe nd ne nf mu b">src</code>目录中的位置。</p></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h1 id="bf6b" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">健全性检查</h1><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ni"><img src="../Images/bbfe945730270f25f4a5837456c16db1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*q0VRuOXlkHMRObJN"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由格伦·卡斯滕斯-彼得斯 / <a class="ae kf" href="https://unsplash.com/?utm_source=ghost&amp;utm_medium=referral&amp;utm_campaign=api-credit" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="de5e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">好的，让我们确保一切仍然正常工作。运行<code class="fe nd ne nf mu b">yarn build</code>，并确认您在<code class="fe nd ne nf mu b">dist</code>目录中看到两个文件:<code class="fe nd ne nf mu b">index.html</code>和<code class="fe nd ne nf mu b">main.js</code>。</p><p id="568c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您仔细查看您的<code class="fe nd ne nf mu b">index.html</code>文件，您会看到引用的<code class="fe nd ne nf mu b">main.js</code>文件。</p><p id="766d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，在你的浏览器中打开<code class="fe nd ne nf mu b">./dist/index.html</code>文件，验证你的页面加载正确。如果您正确地遵循了这些步骤，您的页面应该仍然可以工作:</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/688832249c68f048b9078c4a07857c8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1184/format:webp/0*3oMdY9lh1VZY9RAK.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">演示应用程序输出3 —无变化</figcaption></figure></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h1 id="98c2" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">创建开发服务器</h1><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ni"><img src="../Images/39da5b28f20fd14baa3c79ca16c25565.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ihnsHSXFH-bLw1-x"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">泰勒·维克 / <a class="ae kf" href="https://unsplash.com/?utm_source=ghost&amp;utm_medium=referral&amp;utm_campaign=api-credit" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="b871" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">到目前为止，我们已经使用<code class="fe nd ne nf mu b">CleanWebpackPlugin</code>和<code class="fe nd ne nf mu b">HtmlWebpackPlugin</code>做了一些很好的改进。由于我们已经做了这些更改，我们每次都必须手动运行<code class="fe nd ne nf mu b">yarn build</code>命令，以查看我们的应用程序中的新变化。我们也只是在浏览器中查看文件，而不是查看从本地运行的服务器提供的内容。让我们通过创建一个开发服务器来改进我们的流程。</p><p id="3ae6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为此，我们将使用<code class="fe nd ne nf mu b">webpack-dev-server</code>。首先，我们需要安装它:</p><pre class="lf lg lh li gt mt mu mv mw aw mx bi"><span id="e829" class="my lr it mu b gy mz na l nb nc">yarn add --dev webpack-dev-server</span></pre><p id="7884" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，让我们将单个<code class="fe nd ne nf mu b">webpack.config.js</code>文件分成两个独立的配置文件，一个用于生产，一个用于开发。我们将生产文件称为<code class="fe nd ne nf mu b">webpack.config.prod.js</code>，开发文件称为<code class="fe nd ne nf mu b">webpack.config.dev.js</code>。</p></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h1 id="b568" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">开发Webpack配置</h1><p id="bc44" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">这是我们的开发配置文件:</p><pre class="lf lg lh li gt mt mu mv mw aw mx bi"><span id="72d0" class="my lr it mu b gy mz na l nb nc">const path = require('path')<br/>const { CleanWebpackPlugin } = require('clean-webpack-plugin')<br/>const HtmlWebpackPlugin = require('html-webpack-plugin')<br/><br/>module.exports = {<br/>  mode: 'development',<br/>  devtool: 'inline-source-map',<br/>  devServer: {<br/>    contentBase: './dist',<br/>  },<br/>  entry: './src/index.js',<br/>  output: {<br/>    filename: 'main.js',<br/>    path: path.resolve(__dirname, 'dist')<br/>  },<br/>  plugins: [<br/>    new CleanWebpackPlugin(),<br/>    new HtmlWebpackPlugin({<br/>      filename: 'index.html',<br/>      inject: true,<br/>      template: path.resolve(__dirname, 'src', 'index.html'),<br/>    }),<br/>  ]<br/>}</span></pre><p id="745e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意，我们现在已经将<code class="fe nd ne nf mu b">mode</code>指定为<code class="fe nd ne nf mu b">development</code>，并且我们已经指定我们的JavaScript文件需要一个<code class="fe nd ne nf mu b">inline-source-map</code>，这意味着每个JavaScript文件的末尾都包含一个源映射。对于我们的开发服务器，我们已经指定我们的内容将在<code class="fe nd ne nf mu b">dist</code>目录中找到。</p><p id="8b4f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所有其余的开发配置保持不变。</p></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h1 id="9d59" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">生产Webpack配置</h1><p id="84f3" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">现在，这是我们的生产配置文件:</p><pre class="lf lg lh li gt mt mu mv mw aw mx bi"><span id="223e" class="my lr it mu b gy mz na l nb nc">const path = require('path')<br/>const { CleanWebpackPlugin } = require('clean-webpack-plugin')<br/>const HtmlWebpackPlugin = require('html-webpack-plugin')<br/><br/>module.exports = {<br/>  mode: 'production',<br/>  devtool: 'source-map',<br/>  entry: './src/index.js',<br/>  output: {<br/>    filename: 'main.js',<br/>    path: path.resolve(__dirname, 'dist')<br/>  },<br/>  plugins: [<br/>    new CleanWebpackPlugin(),<br/>    new HtmlWebpackPlugin({<br/>      filename: 'index.html',<br/>      inject: true,<br/>      template: path.resolve(__dirname, 'src', 'index.html'),<br/>    }),<br/>  ]<br/>}</span></pre><p id="5579" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个文件看起来也非常类似于我们的原始配置文件。这里我们已经指定了<code class="fe nd ne nf mu b">mode</code>是<code class="fe nd ne nf mu b">production</code>并且我们想要为源映射提供<code class="fe nd ne nf mu b">source-map</code>选项，它为精简的代码提供单独的源映射文件。</p></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h1 id="7643" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">生产和开发NPM脚本</h1><p id="aa9d" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">最后，让我们在<code class="fe nd ne nf mu b">package.json</code>文件中再添加几个npm脚本，这样我们就可以使用我们的开发和生产webpack配置了:</p><pre class="lf lg lh li gt mt mu mv mw aw mx bi"><span id="41ed" class="my lr it mu b gy mz na l nb nc">"scripts": {<br/>  "build": "webpack --config=webpack.config.prod.js",<br/>  "build-dev": "webpack --config=webpack.config.dev.js",<br/>  "start": "webpack-dev-server --config=webpack.config.dev.js --open"<br/>}</span></pre><p id="cf9d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，让我们尝试一下这些脚本。</p><p id="750f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">运行<code class="fe nd ne nf mu b">yarn build</code>查看生产构建输出。您应该看到您的<code class="fe nd ne nf mu b">dist</code>目录中的<code class="fe nd ne nf mu b">main.js</code>文件被缩小了，并且它有一个附带的<code class="fe nd ne nf mu b">main.js.map</code>源文件。</p><p id="ff28" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在运行<code class="fe nd ne nf mu b">yarn build-dev</code>来查看开发构建输出。你应该在你的<code class="fe nd ne nf mu b">dist</code>目录中看到<code class="fe nd ne nf mu b">main.js</code>文件，但是现在注意到它是<strong class="ki iu">而不是</strong>缩小的。</p><p id="583e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，运行<code class="fe nd ne nf mu b">yarn start</code>来启动开发服务器。这将打开<code class="fe nd ne nf mu b"><a class="ae kf" href="http://localhost:8080/" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/</a></code>上的应用程序。不再需要直接查看文件，只需将它们拖入浏览器即可！我们现在有了一个真正的实时开发服务器！</p><p id="fa41" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您看到的输出看起来应该和往常一样:</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/a3ae1fc8e03bf5ec64ecd18f42fade0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1184/format:webp/0*FwXPKMTI7jbnTMmb.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">演示应用程序输出4 —无变化</figcaption></figure></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h1 id="053a" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">在开发过程中进行更改</h1><p id="9818" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">现在我们有了一个工作的开发服务器，让我们尝试对我们的<code class="fe nd ne nf mu b">./src/index.js</code>文件做一些简单的修改。而不是输出“你好，来自webpack！”，让我们把它改成“你好，来自开发服务器！”。</p><p id="ce8f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">保存文件，然后看到您的开发服务器上的页面自动为您重新加载和更新！这将大大提高开发人员的工作效率。</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/c27c6865e2ff3bb654f7ab001cd5f6ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1164/format:webp/0*uY80zJHiYaH6zD42.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">演示应用程序输出5 —来自开发服务器的问候</figcaption></figure></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h1 id="f810" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">不要重复自己(干)</h1><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nk"><img src="../Images/08cb815aeac417edf2bc601cd24e9df2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bxa2Vt4lCyEHKebN"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">Tobias Jelskov 在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="eb57" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们有了两个独立的webpack配置文件，一个用于开发，一个用于生产，您可能已经注意到我们在两个文件之间有许多重复的代码。</p><p id="dd0a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从第一天开始，每个开发人员都有一个枯燥的原则:不要重复自己。如果您发现自己在多个地方编写相同的代码，那么将这些代码转换成可以在一个地方编写，然后在多个地方使用的共享代码可能是一个好主意。这样，当您需要进行更改时，您只需在一个地方实施这些更改。</p><p id="c69f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么，我们如何清除webpack配置文件中的重复呢？有一个插件可以做到这一点！</p></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h1 id="15d6" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">WebpackMerge</h1><figure class="lf lg lh li gt ju gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/7eae43c1eaa354fc9023ff0cf4910361.png" data-original-src="https://miro.medium.com/v2/resize:fit:450/format:webp/1*m8jh7Y8sIOl8lfDeyYBQ6Q.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">合并</figcaption></figure><p id="e5b2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以使用<a class="ae kf" href="https://github.com/survivejs/webpack-merge" rel="noopener ugc nofollow" target="_blank"> webpack-merge </a>插件来管理多个配置文件依赖的共享代码。为此，我们将首先安装软件包:</p><pre class="lf lg lh li gt mt mu mv mw aw mx bi"><span id="a4ea" class="my lr it mu b gy mz na l nb nc">yarn add --dev webpack-merge</span></pre><p id="9634" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们将创建第三个名为<code class="fe nd ne nf mu b">webpack.config.common.js</code>的webpack配置文件。这是我们保存共享代码的地方。现在，我们的开发和生产配置文件共享相同的入口点、输出和插件。这两个文件的不同之处在于模式、源映射和开发服务器。</p><p id="70be" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我们的<code class="fe nd ne nf mu b">webpack.config.common.js</code>文件的内容将是:</p><pre class="lf lg lh li gt mt mu mv mw aw mx bi"><span id="b064" class="my lr it mu b gy mz na l nb nc">const path = require('path')<br/>const { CleanWebpackPlugin } = require('clean-webpack-plugin')<br/>const HtmlWebpackPlugin = require('html-webpack-plugin')<br/><br/>module.exports = {<br/>  entry: './src/index.js',<br/>  output: {<br/>    filename: 'main.js',<br/>    path: path.resolve(__dirname, 'dist')<br/>  },<br/>  plugins: [<br/>    new CleanWebpackPlugin(),<br/>    new HtmlWebpackPlugin({<br/>      filename: 'index.html',<br/>      inject: true,<br/>      template: path.resolve(__dirname, 'src', 'index.html'),<br/>    }),<br/>  ]<br/>}</span></pre><p id="9aee" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，我们可以将这个共享配置对象合并到我们的开发配置中，如下所示:</p><pre class="lf lg lh li gt mt mu mv mw aw mx bi"><span id="fcd8" class="my lr it mu b gy mz na l nb nc">const merge = require('webpack-merge')<br/>const commonConfig = require('./webpack.config.common')<br/><br/>module.exports = merge(commonConfig, {<br/>  mode: 'development',<br/>  devtool: 'inline-source-map',<br/>  devServer: {<br/>    contentBase: './dist',<br/>  },<br/>})</span></pre><p id="e3ba" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以将共享配置对象合并到我们的生产配置中，如下所示:</p><pre class="lf lg lh li gt mt mu mv mw aw mx bi"><span id="8f36" class="my lr it mu b gy mz na l nb nc">const merge = require('webpack-merge')<br/>const commonConfig = require('./webpack.config.common')<br/><br/>module.exports = merge(commonConfig, {<br/>  mode: 'production',<br/>  devtool: 'source-map',<br/>})</span></pre><p id="b7a0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">看看这两个文件看起来有多短多干净！漂亮！</p></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h1 id="3ecd" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">设计我们的应用</h1><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nm"><img src="../Images/fd6ca9a20096a4af6c887d6ee92d82dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wZFydYWuGnMh9ext"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">由<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae kf" href="https://unsplash.com/@madebyvadim?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Vadim Sherbakov </a>拍摄的照片</figcaption></figure><p id="6741" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">到目前为止，我们的webpack配置看起来相当不错。我们有一个工作的开发服务器，我们已经将代码分成开发、生产和共享配置文件。</p><p id="e384" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在让我们开始编写实际的应用程序代码。普通的黑白页面看起来有点无聊。让我们打扮一下吧！</p><p id="7d7a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们的<code class="fe nd ne nf mu b">src</code>目录中，让我们创建一个<code class="fe nd ne nf mu b">index.css</code>文件，并将下面几行CSS放入其中:</p><pre class="lf lg lh li gt mt mu mv mw aw mx bi"><span id="e123" class="my lr it mu b gy mz na l nb nc">body {<br/>  background: deeppink;<br/>  color: white;<br/>}</span></pre><p id="53cc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，在我们的<code class="fe nd ne nf mu b">./src/index.js</code>文件中，让我们导入CSS文件:</p><pre class="lf lg lh li gt mt mu mv mw aw mx bi"><span id="4e2b" class="my lr it mu b gy mz na l nb nc">import './index.css'</span></pre><p id="6593" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，运行<code class="fe nd ne nf mu b">yarn start</code>让我们的开发服务器再次运行。</p><p id="d508" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">哦不！我们得到一个错误！</p><pre class="lf lg lh li gt mt mu mv mw aw mx bi"><span id="74bb" class="my lr it mu b gy mz na l nb nc">ERROR in ./src/index.css 1:5<br/>Module parse failed: Unexpected token (1:5)<br/>You may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders<br/>&gt; body {<br/>|   background: deeppink;<br/>|   color: white;<br/> @ ./src/index.js 1:0-20</span></pre><p id="c241" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它所说的这些“装载机”是什么？</p></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h1 id="7534" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">Webpack加载器</h1><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ni"><img src="../Images/2bf056b6edc9b62e03b9ada4b8dbe256.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*feIljvwClBiMFgnr"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">凯文·布茨 / <a class="ae kf" href="https://unsplash.com/?utm_source=ghost&amp;utm_medium=referral&amp;utm_campaign=api-credit" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>摄影</figcaption></figure><p id="537c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">前面，我们讨论了webpack插件，它允许您扩展webpack构建过程。还有一个webpack " <a class="ae kf" href="https://webpack.js.org/loaders/" rel="noopener ugc nofollow" target="_blank"> loaders </a>"的生态系统，帮助webpack知道如何理解和加载不同的文件类型。开箱即用，webpack理解如何处理我们的JavaScript文件，但它还不知道如何处理CSS文件。让我们解决这个问题。</p></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h1 id="a9b6" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">StyleLoader和CSSLoader</h1><p id="dc88" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">这里有两个特别有用的加载器:<a class="ae kf" href="https://webpack.js.org/loaders/style-loader/" rel="noopener ugc nofollow" target="_blank">样式加载器</a>和<a class="ae kf" href="https://webpack.js.org/loaders/css-loader/" rel="noopener ugc nofollow" target="_blank"> css加载器</a>。让我们把它们包含在我们的项目中，然后讨论它们是如何工作的。</p><p id="693a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，和往常一样，我们需要安装这两个依赖项:</p><pre class="lf lg lh li gt mt mu mv mw aw mx bi"><span id="eb9e" class="my lr it mu b gy mz na l nb nc">yarn add --dev style-loader css-loader</span></pre><p id="39f1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们可以将它们添加到底部模块规则部分的<code class="fe nd ne nf mu b">webpack.config.common.js</code>文件中:</p><pre class="lf lg lh li gt mt mu mv mw aw mx bi"><span id="3dd3" class="my lr it mu b gy mz na l nb nc">const path = require('path')<br/>const { CleanWebpackPlugin } = require('clean-webpack-plugin')<br/>const HtmlWebpackPlugin = require('html-webpack-plugin')</span><span id="932d" class="my lr it mu b gy nn na l nb nc">module.exports = {<br/>  entry: './src/index.js',<br/>  output: {<br/>    filename: 'main.js',<br/>    path: path.resolve(__dirname, 'dist')<br/>  },<br/>  plugins: [<br/>    new CleanWebpackPlugin(),<br/>    new HtmlWebpackPlugin({<br/>      filename: 'index.html',<br/>      inject: true,<br/>      template: path.resolve(__dirname, 'src', 'index.html'),<br/>    }),<br/>  ],<br/>  module: {<br/>    rules: [<br/>      {<br/>        test: /\.css$/,<br/>        use: ['style-loader', 'css-loader']<br/>      }<br/>    ]<br/>  }<br/>}</span></pre><p id="7563" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">本节为webpack设置规则，以便它知道如何处理遇到的每个文件。<code class="fe nd ne nf mu b">test</code>属性是webpack根据文件名检查的正则表达式。在这种情况下，我们希望处理扩展名为<code class="fe nd ne nf mu b">.css</code>的文件。</p><p id="5e63" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，<code class="fe nd ne nf mu b">use</code>属性告诉webpack使用哪个或哪些加载器来处理符合标准的文件。注意这里的顺序很重要！</p><p id="7f3f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Webpack加载程序从右向左读取。因此，首先将应用<code class="fe nd ne nf mu b">css-loader</code>，然后应用<code class="fe nd ne nf mu b">style-loader</code>。</p><p id="82cf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，这些装载机实际上为我们做了什么？</p><p id="ad1a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe nd ne nf mu b">css-loader</code>解释并解析您在JavaScript中引用的导入CSS文件。所以在这种情况下，<code class="fe nd ne nf mu b">css-loader</code>有助于使这一行工作:</p><pre class="lf lg lh li gt mt mu mv mw aw mx bi"><span id="e601" class="my lr it mu b gy mz na l nb nc">import './index.css'</span></pre><p id="2721" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，<code class="fe nd ne nf mu b">style-loader</code>将CSS注入DOM。默认情况下，<code class="fe nd ne nf mu b">style-loader</code>获取它遇到的CSS并将它添加到DOM中的一个<code class="fe nd ne nf mu b">style</code>标签中。</p><p id="d1ce" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们通过终止当前进程(如果您仍然让它运行)来重启我们的开发服务器，然后用<code class="fe nd ne nf mu b">yarn start</code>再次启动它。现在，在网络浏览器中，您应该会在<code class="fe nd ne nf mu b"><a class="ae kf" href="https://localhost:8080/" rel="noopener ugc nofollow" target="_blank">https://localhost:8080/</a></code>上看到:</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div class="gh gi no"><img src="../Images/12578a961aba6267ce49414f998ccd26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1216/format:webp/0*AOcw1_YwoCjhmAlR.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">演示应用程序输出6 —添加粉色和白色</figcaption></figure><p id="8e61" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">哦，如此丰富多彩！</p></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h1 id="ae2f" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">关于其他Webpack加载器的说明</h1><p id="e44f" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">在本文中，我们不会讨论其他文件类型的加载器，但是请注意，有一个加载器可以加载任何可以想象的东西！您可以使用<a class="ae kf" href="https://webpack.js.org/loaders/file-loader/" rel="noopener ugc nofollow" target="_blank">文件加载器</a>或<a class="ae kf" href="https://webpack.js.org/loaders/url-loader/" rel="noopener ugc nofollow" target="_blank"> url加载器</a>来加载图像和其他资产。您可以使用<a class="ae kf" href="https://webpack.js.org/loaders/sass-loader/" rel="noopener ugc nofollow" target="_blank"> sass-loader </a>来处理将Sass/SCSS文件转换为CSS，然后将该输出传送到<code class="fe nd ne nf mu b">css-loader</code>和<code class="fe nd ne nf mu b">style-loader</code>。如果你喜欢的话，Webpack也可以用<a class="ae kf" href="https://webpack.js.org/loaders/less-loader/" rel="noopener ugc nofollow" target="_blank"> less-loader </a>处理更少的文件。</p><p id="6a71" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个故事的寓意是:对于任何给定的文件类型，都有一个加载器可以处理它。</p></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h1 id="0609" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">BabelLoader</h1><p id="15ca" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">好了，回到我们的演示应用程序。到目前为止，我们只写了几行JavaScript。如果我们可以使用目前还不是每个浏览器都支持的新特性来编写JavaScript，那就太好了。<a class="ae kf" href="https://babeljs.io/" rel="noopener ugc nofollow" target="_blank"> Babel </a>是一个JavaScript编译器，可以把ES6+代码变成ES5代码。</p><p id="b9c4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">而且(你猜对了)，有一个加载器:<a class="ae kf" href="https://babeljs.io/setup#installation" rel="noopener ugc nofollow" target="_blank">通天塔加载器</a>。</p><p id="3578" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要设置<code class="fe nd ne nf mu b">babel-loader</code>，我们将遵循上面链接的安装指南中的说明。</p><p id="a6a4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，我们将安装我们的依赖项:</p><pre class="lf lg lh li gt mt mu mv mw aw mx bi"><span id="efa2" class="my lr it mu b gy mz na l nb nc">yarn add --dev babel-loader @babel/core</span></pre><p id="3ec7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，我们将向我们的<code class="fe nd ne nf mu b">webpack.config.common.js</code>文件中的模块规则数组添加一个新规则:</p><pre class="lf lg lh li gt mt mu mv mw aw mx bi"><span id="1aa6" class="my lr it mu b gy mz na l nb nc">const path = require('path')<br/>const { CleanWebpackPlugin } = require('clean-webpack-plugin')<br/>const HtmlWebpackPlugin = require('html-webpack-plugin')</span><span id="eb1f" class="my lr it mu b gy nn na l nb nc">module.exports = {<br/>  entry: './src/index.js',<br/>  output: {<br/>    filename: 'main.js',<br/>    path: path.resolve(__dirname, 'dist')<br/>  },<br/>  plugins: [<br/>    new CleanWebpackPlugin(),<br/>    new HtmlWebpackPlugin({<br/>      filename: 'index.html',<br/>      inject: true,<br/>      template: path.resolve(__dirname, 'src', 'index.html'),<br/>    }),<br/>  ],<br/>  module: {<br/>    rules: [<br/>      {<br/>        test: /\.css$/,<br/>        use: ['style-loader', 'css-loader']<br/>      },<br/>      {<br/>        test: /\.(js|jsx)$/,<br/>        exclude: /[\\/]node_modules[\\/]/,<br/>        use: {<br/>          loader: 'babel-loader',<br/>        },<br/>      },<br/>    ]<br/>  }<br/>}</span></pre><p id="c165" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这将告诉webpack，当它遇到<code class="fe nd ne nf mu b">.js</code>或<code class="fe nd ne nf mu b">.jsx</code>文件时使用Babel来转换代码。我们使用<code class="fe nd ne nf mu b">exclude</code>属性来确保Babel不会试图转换我们的<code class="fe nd ne nf mu b">node_modules</code>目录中的JavaScript文件。那些是第三方依赖，它们的创建者应该已经处理好了。</p><p id="e152" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，我们将为Babel预设添加一个附加项:</p><pre class="lf lg lh li gt mt mu mv mw aw mx bi"><span id="96b4" class="my lr it mu b gy mz na l nb nc">yarn add --dev @babel/preset-env</span></pre><p id="8833" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们将创建一个<code class="fe nd ne nf mu b">.babelrc</code>文件，在这里我们可以根据需要进行其他的Babel配置。我们将保持我们的文件非常简单，只指定我们想要使用的巴别塔预设:</p><pre class="lf lg lh li gt mt mu mv mw aw mx bi"><span id="7ba0" class="my lr it mu b gy mz na l nb nc">{<br/>  "presets": ["@babel/preset-env"]<br/>}</span></pre><p id="b425" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，让我们在<code class="fe nd ne nf mu b">./src/index.js</code>文件中编写一些ES6代码:</p><pre class="lf lg lh li gt mt mu mv mw aw mx bi"><span id="7eb0" class="my lr it mu b gy mz na l nb nc">import './index.css'</span><span id="0cef" class="my lr it mu b gy nn na l nb nc">const p = document.createElement('p')<br/>p.textContent = 'Hello from webpack!'<br/>document.body.appendChild(p)</span><span id="56ba" class="my lr it mu b gy nn na l nb nc">const p2 = document.createElement('p')<br/>const numbers1 = [1, 2, 3, 4, 5, 6]<br/>const numbers2 = [7, 8, 9, 10]<br/>const numbers3 = [...numbers1, ...numbers2]<br/>p2.textContent = numbers3.join(' ')<br/>document.body.appendChild(p2)</span></pre><p id="e586" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是一个非常简单的例子，但是我们在这里使用了<a class="ae kf" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax" rel="noopener ugc nofollow" target="_blank">扩展操作符</a>来连接两个数组。</p><p id="77a6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，如果我们终止正在运行的进程并再次运行<code class="fe nd ne nf mu b">yarn start</code>，我们应该会在浏览器中看到:</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div class="gh gi np"><img src="../Images/bf6878903a2da9966b1a1d000e1ff4ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1156/format:webp/0*tX0HWt3nULzUAdGX.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">演示应用程序输出7 —添加数字</figcaption></figure><p id="fb9c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">太好了！一切都很好。</p></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h1 id="1951" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">暂时缺失的样式</h1><p id="8d0d" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">如果您禁用浏览器中的缓存，并为我们的演示应用程序重新加载页面，您可能会注意到一个轻微的问题，页面只显示未设置样式的HTML，然后随着样式的应用，页面背景变成粉红色，文本变成白色。</p><p id="d5dd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这种行为源于<code class="fe nd ne nf mu b">style-loader</code>的工作方式。如上所述，<code class="fe nd ne nf mu b">style-loader</code>获取CSS并将其放在HTML的<code class="fe nd ne nf mu b">style</code>标签中。因此，有一小段时间<code class="fe nd ne nf mu b">style</code>标签还没有被添加！</p><p id="e205" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，这对于开发环境是可以的，但是我们绝对不希望这种行为发生在生产环境中。让我们解决这个问题。</p></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h1 id="cb39" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">MiniCssExtractPlugin</h1><p id="b0a5" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">我们可以使用<a class="ae kf" href="https://webpack.js.org/plugins/mini-css-extract-plugin/" rel="noopener ugc nofollow" target="_blank">minicsextractplugin</a>为我们生成单独的CSS文件，而不是将CSS作为<code class="fe nd ne nf mu b">style</code>标签注入到我们的HTML中。我们将在生产配置中使用它，而在开发配置中仍然只使用<code class="fe nd ne nf mu b">style-loader</code>。</p><p id="9a85" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，让我们在项目中安装依赖项:</p><pre class="lf lg lh li gt mt mu mv mw aw mx bi"><span id="d450" class="my lr it mu b gy mz na l nb nc">yarn add --dev mini-css-extract-plugin</span></pre><p id="6da3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，在我们的<code class="fe nd ne nf mu b">webpack.config.common.js</code>文件中，让我们删除CSS规则，因为我们将在开发和生产中以不同的方式处理它。我们的共享配置中只剩下这个:</p><pre class="lf lg lh li gt mt mu mv mw aw mx bi"><span id="ccbf" class="my lr it mu b gy mz na l nb nc">const path = require('path')<br/>const { CleanWebpackPlugin } = require('clean-webpack-plugin')<br/>const HtmlWebpackPlugin = require('html-webpack-plugin')</span><span id="b9f6" class="my lr it mu b gy nn na l nb nc">module.exports = {<br/>  entry: './src/index.js',<br/>  output: {<br/>    filename: 'main.js',<br/>    path: path.resolve(__dirname, 'dist')<br/>  },<br/>  plugins: [<br/>    new CleanWebpackPlugin(),<br/>    new HtmlWebpackPlugin({<br/>      filename: 'index.html',<br/>      inject: true,<br/>      template: path.resolve(__dirname, 'src', 'index.html'),<br/>    }),<br/>  ],<br/>  module: {<br/>    rules: [<br/>      {<br/>        test: /\.(js|jsx)$/,<br/>        exclude: /[\\/]node_modules[\\/]/,<br/>        use: {<br/>          loader: 'babel-loader',<br/>        },<br/>      },<br/>    ]<br/>  }<br/>}</span></pre><p id="3558" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，在我们的<code class="fe nd ne nf mu b">webpack.config.dev.js</code>文件中，让我们将刚刚从共享配置中删除的<code class="fe nd ne nf mu b">style-loader</code>和<code class="fe nd ne nf mu b">css-loader</code>添加回来:</p><pre class="lf lg lh li gt mt mu mv mw aw mx bi"><span id="d453" class="my lr it mu b gy mz na l nb nc">const merge = require('webpack-merge')<br/>const commonConfig = require('./webpack.config.common')</span><span id="ae4c" class="my lr it mu b gy nn na l nb nc">module.exports = merge(commonConfig, {<br/>  mode: 'development',<br/>  devtool: 'inline-source-map',<br/>  devServer: {<br/>    contentBase: './dist',<br/>  },<br/>  module: {<br/>    rules: [<br/>      {<br/>        test: /\.css$/,<br/>        use: ['style-loader', 'css-loader']<br/>      },<br/>    ]<br/>  }<br/>})</span></pre><p id="2738" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，在我们的<code class="fe nd ne nf mu b">webpack.config.prod.js</code>文件中，让我们添加新的<code class="fe nd ne nf mu b">mini-css-extract-plugin</code>:</p><pre class="lf lg lh li gt mt mu mv mw aw mx bi"><span id="8f08" class="my lr it mu b gy mz na l nb nc">const merge = require('webpack-merge')<br/>const MiniCssExtractPlugin = require('mini-css-extract-plugin');<br/>const commonConfig = require('./webpack.config.common')</span><span id="5e53" class="my lr it mu b gy nn na l nb nc">module.exports = merge(commonConfig, {<br/>  mode: 'production',<br/>  devtool: 'source-map',<br/>  module: {<br/>    rules: [<br/>      {<br/>        test: /\.css$/,<br/>        use: [<br/>          MiniCssExtractPlugin.loader,<br/>          'css-loader',<br/>        ],<br/>      },<br/>    ],<br/>  },<br/>  plugins: [<br/>    new MiniCssExtractPlugin({<br/>      filename: '[name].[contenthash].css',<br/>    }),<br/>  ]<br/>})</span></pre><p id="e1f9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个有点不同，因为它实际上既是插件<em class="nh">又是加载器</em>，所以它在模块规则和插件部分。</p><p id="c86b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">还要注意，我们在文件名中使用方括号来动态地将<code class="fe nd ne nf mu b">name</code>设置为原始源文件的名称，并且还包含了<code class="fe nd ne nf mu b">contenthash</code>，这是一个表示文件内容的散列(一个字母数字字符串)。</p><p id="88c4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，如果您这次运行<code class="fe nd ne nf mu b">yarn build</code>来生成生产版本，您应该在终端中得到如下所示的输出:</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nq"><img src="../Images/3bd2b796c057d7476759e85bcddf97be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*hbWQZFCfeQyDyL3u.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">Webpack生产构建输出</figcaption></figure><p id="d6f4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意，它现在实际上生成了一个CSS文件，内容哈希包含在文件名中。</p><p id="cd6b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">好了，问题解决了！由于我们将样式作为一个<code class="fe nd ne nf mu b">link</code>标签包含到一个实际的CSS文件中，所以当页面在生产中加载时不会再出现问题。</p></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h1 id="7490" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">缓存破坏</h1><p id="cbf1" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">由于我们已经在生成的CSS文件中包含了内容散列，现在是讨论缓存破坏的好时机。您可能会问，为什么我们希望在文件名中包含内容散列？帮助浏览器理解文件何时发生了变化！</p><p id="2485" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你的浏览器试图通过缓存以前看过的文件来提供帮助。例如，如果您访问了一个网站，并且您的浏览器必须下载JavaScript、CSS或图像文件等资源，您的浏览器可能会缓存这些文件，这样它就不必再次向服务器请求它们。</p><p id="ad49" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这意味着，如果您再次访问该网站，您的浏览器可以使用缓存的文件，而不是再次请求它们，因此您可以获得更快的页面加载时间和更好的体验。</p><p id="f40d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么，这里的问题是什么？想象一下，如果我们的应用程序中使用了一个名为<code class="fe nd ne nf mu b">main.js</code>的文件。然后，用户访问你的应用程序，他们的浏览器缓存了<code class="fe nd ne nf mu b">main.js</code>文件。</p><p id="661e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，在以后的某个时间点，你已经为你的应用程序发布了新的代码。<code class="fe nd ne nf mu b">main.js</code>文件的内容已经改变。但是，当这个用户再次访问你的应用程序时，浏览器发现它需要一个<code class="fe nd ne nf mu b">main.js</code>文件，注意到它有一个缓存的<code class="fe nd ne nf mu b">main.js</code>文件，并且只使用缓存的版本。用户没有得到你的新代码！</p><p id="8771" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了解决这个问题，通常的做法是在每个文件名中包含内容哈希。如前所述，内容散列是文件内容的字符串表示。如果文件的内容没有改变，内容哈希也不会改变。但是，如果文件的内容<em class="nh">确实</em>改变了，那么内容散列<em class="nh">也会</em>改变。</p><p id="0b32" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为文件名现在会随着代码的改变而改变，所以浏览器会下载新文件，因为它的缓存中没有那个特定的文件名。</p></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h1 id="8e7e" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">包括内容散列</h1><p id="adda" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">为了在JavaScript文件名中包含内容散列，我们将只修改<code class="fe nd ne nf mu b">webpack.config.common.js</code>文件中的一行代码。这一行:</p><pre class="lf lg lh li gt mt mu mv mw aw mx bi"><span id="dcb1" class="my lr it mu b gy mz na l nb nc">filename: 'main.js'</span></pre><p id="c550" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">将改为这一行:</p><pre class="lf lg lh li gt mt mu mv mw aw mx bi"><span id="f98a" class="my lr it mu b gy mz na l nb nc">filename: '[name].[contenthash].js'</span></pre><p id="b486" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此整个文件看起来像这样:</p><pre class="lf lg lh li gt mt mu mv mw aw mx bi"><span id="adc7" class="my lr it mu b gy mz na l nb nc">const path = require('path')<br/>const { CleanWebpackPlugin } = require('clean-webpack-plugin')<br/>const HtmlWebpackPlugin = require('html-webpack-plugin')</span><span id="7c6f" class="my lr it mu b gy nn na l nb nc">module.exports = {<br/>  entry: './src/index.js',<br/>  output: {<br/>    filename: '[name].[contenthash].js', // this line is the only difference<br/>    path: path.resolve(__dirname, 'dist')<br/>  },<br/>  plugins: [<br/>    new CleanWebpackPlugin(),<br/>    new HtmlWebpackPlugin({<br/>      filename: 'index.html',<br/>      inject: true,<br/>      template: path.resolve(__dirname, 'src', 'index.html'),<br/>    }),<br/>  ],<br/>  module: {<br/>    rules: [<br/>      {<br/>        test: /\.(js|jsx)$/,<br/>        exclude: /[\\/]node_modules[\\/]/,<br/>        use: {<br/>          loader: 'babel-loader',<br/>        },<br/>      },<br/>    ]<br/>  }<br/>}</span></pre><p id="42ce" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在如果你运行<code class="fe nd ne nf mu b">yarn build</code>，你会看到你的JavaScript和CSS都包含了内容散列:</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nr"><img src="../Images/04df46ce96f905db9acfc77810085308.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*tMEK9CcavSEkoJpy.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">包含内容哈希的Webpack生产构建输出</figcaption></figure><p id="9464" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您再次运行<code class="fe nd ne nf mu b">yarn build</code>并将您的新输出与旧输出进行比较，您会注意到两次的内容散列完全相同。</p><p id="41de" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是，如果您以任何方式编辑您的<code class="fe nd ne nf mu b">./src/index.js</code>文件，然后再次运行<code class="fe nd ne nf mu b">yarn build</code>，您将获得一个新的内容散列，因为内容已经改变了！试试看！</p></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h1 id="621f" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">缩小CSS</h1><p id="be94" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">最后但同样重要的是，我们可能想要缩小我们的CSS。我们已经为生产版本缩小了JavaScript，但是我们还没有缩小CSS。就这么办吧。</p><p id="6734" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以通过使用<a class="ae kf" href="https://github.com/NMFR/optimize-css-assets-webpack-plugin" rel="noopener ugc nofollow" target="_blank">optimize-CSS-assets-web pack-plugin</a>来最小化我们的CSS。现在让我们安装依赖项:</p><pre class="lf lg lh li gt mt mu mv mw aw mx bi"><span id="d135" class="my lr it mu b gy mz na l nb nc">yarn add --dev optimize-css-assets-webpack-plugin</span></pre><p id="8ee6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们可以将它添加到我们的<code class="fe nd ne nf mu b">webpack.config.prod.js</code>文件的优化部分:</p><pre class="lf lg lh li gt mt mu mv mw aw mx bi"><span id="2bd7" class="my lr it mu b gy mz na l nb nc">const merge = require('webpack-merge')<br/>const MiniCssExtractPlugin = require('mini-css-extract-plugin')<br/>const OptimizeCssAssetsPlugin = require('optimize-css-assets-webpack-plugin')<br/>const commonConfig = require('./webpack.config.common')</span><span id="ef62" class="my lr it mu b gy nn na l nb nc">module.exports = merge(commonConfig, {<br/>  mode: 'production',<br/>  devtool: 'source-map',<br/>  module: {<br/>    rules: [<br/>      {<br/>        test: /\.css$/,<br/>        use: [<br/>          MiniCssExtractPlugin.loader,<br/>          'css-loader',<br/>        ],<br/>      },<br/>    ],<br/>  },<br/>  plugins: [<br/>    new MiniCssExtractPlugin({<br/>      filename: '[name].[contenthash].css',<br/>    }),<br/>  ],<br/>  optimization: {<br/>    minimizer: [<br/>      new OptimizeCssAssetsPlugin({<br/>        cssProcessorOptions: {<br/>          map: {<br/>            inline: false,<br/>            annotation: true,<br/>          },<br/>        },<br/>      }),<br/>    ],<br/>  },<br/>})</span></pre><p id="596a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，如果我们运行<code class="fe nd ne nf mu b">yarn build</code>，然后检查我们的<code class="fe nd ne nf mu b">dist</code>目录的内容，我们可以看到产生的CSS被缩小了。不错！</p><pre class="lf lg lh li gt mt mu mv mw aw mx bi"><span id="29f6" class="my lr it mu b gy mz na l nb nc">body{background:#ff1493;color:#fff}<br/>/*# sourceMappingURL=main.66e0d6aeae6f3c6fb895.css.map */</span></pre><p id="f2eb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是等等！如果我们看看我们生成的JavaScript文件，它没有缩小！嗯。之前<em class="nh">被</em>缩小了，那么这里发生了什么？</p><p id="17b4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">问题是我们现在手动配置我们的webpack配置的优化最小化部分。当该部分不在webpack配置文件中时，webpack默认使用自己的minimizer首选项，其中包括当<code class="fe nd ne nf mu b">mode</code>设置为<code class="fe nd ne nf mu b">production</code>时缩小JavaScript。</p><p id="9a0d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为我们现在通过添加缩小CSS资产的首选项来覆盖这些默认设置，所以我们还需要明确地包含我们希望webpack如何缩小JavaScript资产的说明。</p></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h1 id="7c3b" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">TerserWebpackPlugin</h1><p id="bff6" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">我们可以使用<a class="ae kf" href="https://webpack.js.org/plugins/terser-webpack-plugin/" rel="noopener ugc nofollow" target="_blank"> TerserWebpackPlugin </a>来缩小我们的JavaScript文件。让我们从安装依赖项开始:</p><pre class="lf lg lh li gt mt mu mv mw aw mx bi"><span id="58e0" class="my lr it mu b gy mz na l nb nc">yarn add --dev terser-webpack-plugin</span></pre><p id="c49c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，在我们的<code class="fe nd ne nf mu b">webpack.config.prod.js</code>文件中，让我们将<code class="fe nd ne nf mu b">terser-webpack-plugin</code>添加到文件底部的优化最小化设置中:</p><pre class="lf lg lh li gt mt mu mv mw aw mx bi"><span id="9af4" class="my lr it mu b gy mz na l nb nc">const merge = require('webpack-merge')<br/>const MiniCssExtractPlugin = require('mini-css-extract-plugin')<br/>const OptimizeCssAssetsPlugin = require('optimize-css-assets-webpack-plugin')<br/>const TerserPlugin = require('terser-webpack-plugin')<br/>const commonConfig = require('./webpack.config.common')</span><span id="a7fd" class="my lr it mu b gy nn na l nb nc">module.exports = merge(commonConfig, {<br/>  mode: 'production',<br/>  devtool: 'source-map',<br/>  module: {<br/>    rules: [<br/>      {<br/>        test: /\.css$/,<br/>        use: [<br/>          MiniCssExtractPlugin.loader,<br/>          'css-loader',<br/>        ],<br/>      },<br/>    ],<br/>  },<br/>  plugins: [<br/>    new MiniCssExtractPlugin({<br/>      filename: '[name].[contenthash].css',<br/>    }),<br/>  ],<br/>  optimization: {<br/>    minimizer: [<br/>      new OptimizeCssAssetsPlugin({<br/>        cssProcessorOptions: {<br/>          map: {<br/>            inline: false,<br/>            annotation: true,<br/>          },<br/>        },<br/>      }),<br/>      new TerserPlugin({<br/>        // Use multi-process parallel running to improve the build speed<br/>        // Default number of concurrent runs: os.cpus().length - 1<br/>        parallel: true,<br/>        // Enable file caching<br/>        cache: true,<br/>        sourceMap: true,<br/>      }),<br/>    ],<br/>  },<br/>})</span></pre><p id="199b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，如果我们运行<code class="fe nd ne nf mu b">yarn build</code>并查看<code class="fe nd ne nf mu b">dist</code>目录中的输出，我们应该看到我们的CSS文件和JavaScript文件都被缩小了。我们走吧！</p></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h1 id="a8f1" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">包扎</h1><p id="3b8f" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">如果你已经走了这么远，我推荐你！</p><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ni"><img src="../Images/088f599891c8038448855845235c838d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fhVa6WB9orVT-PTG"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@katya?utm_source=ghost&amp;utm_medium=referral&amp;utm_campaign=api-credit" rel="noopener ugc nofollow" target="_blank">Katya Austin</a>/<a class="ae kf" href="https://unsplash.com/?utm_source=ghost&amp;utm_medium=referral&amp;utm_campaign=api-credit" rel="noopener ugc nofollow" target="_blank">Unsplash</a>拍摄</figcaption></figure><p id="2727" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们回顾一下到目前为止我们所学的内容:</p><ul class=""><li id="8cd9" class="ns nt it ki b kj kk kn ko kr nu kv nv kz nw ld nx ny nz oa bi translated">Webpack是一个用于资产捆绑和依赖性管理的构建工具。</li><li id="e2ee" class="ns nt it ki b kj ob kn oc kr od kv oe kz of ld nx ny nz oa bi translated">Webpack可以通过配置文件进行配置。</li><li id="d06e" class="ns nt it ki b kj ob kn oc kr od kv oe kz of ld nx ny nz oa bi translated">插件修改和扩展了webpack的构建过程。</li><li id="498f" class="ns nt it ki b kj ob kn oc kr od kv oe kz of ld nx ny nz oa bi translated">加载器指导webpack如何处理不同的文件类型。</li><li id="1ef4" class="ns nt it ki b kj ob kn oc kr od kv oe kz of ld nx ny nz oa bi translated"><code class="fe nd ne nf mu b">clean-webpack-plugin</code>可以用来从<code class="fe nd ne nf mu b">dist</code>目录中移除旧的构建工件。</li><li id="54f3" class="ns nt it ki b kj ob kn oc kr od kv oe kz of ld nx ny nz oa bi translated"><code class="fe nd ne nf mu b">html-webpack-plugin</code>帮助管理HTML文件，包括通过<code class="fe nd ne nf mu b">script</code>标签将JavaScript注入文件。</li><li id="9ada" class="ns nt it ki b kj ob kn oc kr od kv oe kz of ld nx ny nz oa bi translated"><code class="fe nd ne nf mu b">webpack-dev-server</code>创建一个开发服务器，使本地开发更容易。</li><li id="d8dd" class="ns nt it ki b kj ob kn oc kr od kv oe kz of ld nx ny nz oa bi translated">为开发和生产提供单独的webpack配置很有帮助。您可以使用<code class="fe nd ne nf mu b">webpack-merge</code>插件共享和合并配置文件。</li><li id="f68e" class="ns nt it ki b kj ob kn oc kr od kv oe kz of ld nx ny nz oa bi translated">我们可以通过包含像<code class="fe nd ne nf mu b">css-loader</code>、<code class="fe nd ne nf mu b">style-loader</code>、<code class="fe nd ne nf mu b">sass-loader</code>、<code class="fe nd ne nf mu b">less-loader</code>和<code class="fe nd ne nf mu b">mini-css-extract-plugin</code>(既作为插件又作为加载器)这样的加载器来处理应用程序的样式。</li><li id="6648" class="ns nt it ki b kj ob kn oc kr od kv oe kz of ld nx ny nz oa bi translated">我们可以通过使用Babel和<code class="fe nd ne nf mu b">babel-loader</code>来包含新的JavaScript语法和特性。</li><li id="1578" class="ns nt it ki b kj ob kn oc kr od kv oe kz of ld nx ny nz oa bi translated">我们可以在文件名中包含内容散列，以帮助缓存破坏和管理我们发布的代码的新版本。</li><li id="ed02" class="ns nt it ki b kj ob kn oc kr od kv oe kz of ld nx ny nz oa bi translated">我们可以用<code class="fe nd ne nf mu b">optimize-css-assets-webpack-plugin</code>来缩小我们的CSS。</li><li id="15a5" class="ns nt it ki b kj ob kn oc kr od kv oe kz of ld nx ny nz oa bi translated">我们可以用<code class="fe nd ne nf mu b">terser-webpack-plugin</code>来缩小我们的JavaScript。</li></ul></div><div class="ab cl lj lk hx ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="im in io ip iq"><h1 id="8492" class="lq lr it bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">下一步是什么？</h1><figure class="lf lg lh li gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ni"><img src="../Images/f61655f25d21409dab390db9051c6cb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FJC8EZ9-8WPeAVaw"/></div></div></figure><p id="606e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们已经创建了一个相当不错的webpack配置。我们讨论的所有这些技术都是行业标准，在企业级项目中普遍使用。</p><p id="7b11" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是还有更多！其他高级webpack主题包括<a class="ae kf" href="https://webpack.js.org/guides/code-splitting/" rel="noopener ugc nofollow" target="_blank">代码拆分</a>、<a class="ae kf" href="https://webpack.js.org/guides/lazy-loading/" rel="noopener ugc nofollow" target="_blank">懒加载</a>、<a class="ae kf" href="https://webpack.js.org/guides/tree-shaking/" rel="noopener ugc nofollow" target="_blank">树抖动</a>等等！</p><p id="08b1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你有兴趣自己探索webpack，我强烈推荐你阅读官方的webpack指南。</p><p id="3498" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，我们在本教程中学习的所有代码都可以在GitHub中找到。<a class="ae kf" href="https://github.com/thawkin3/webpack-training-1/tree/demo/start" rel="noopener ugc nofollow" target="_blank">起点在此处</a>，完成结果在此处。</p><p id="12da" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢您的阅读，祝您编码愉快！</p></div></div>    
</body>
</html>