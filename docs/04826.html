<html>
<head>
<title>Why We Should Build Our Own Tools: The Story of Tortuga</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么我们应该建立自己的工具:托尔图加的故事</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/why-we-should-build-our-own-tools-the-story-of-tortuga-3b7d5c09f5dc?source=collection_archive---------7-----------------------#2020-07-17">https://levelup.gitconnected.com/why-we-should-build-our-own-tools-the-story-of-tortuga-3b7d5c09f5dc?source=collection_archive---------7-----------------------#2020-07-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a9f1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Git助手的想法如何成为我公司的无价工具</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/eb5bec79fc804d74643b403cb27f9c0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Eh-Mh9i9XkIRyVFc-a66Sw.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@tchompalov?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">弗拉德·乔姆帕洛夫</a>在<a class="ae ky" href="https://unsplash.com/s/photos/ants?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="64e8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我非常支持开发我们自己的工具。作为开发人员，我们执行许多大大小小的重复性任务。使用适当的工具可能会使这些任务变得更容易。</p><p id="ef80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们经常过于专注于解决更重要的问题。但是有时候，一个工具的价值并不一定是一个真正的问题。我们必须找到工作流程中的最佳点。</p><blockquote class="lw"><p id="0d75" class="lx ly it bd lz ma mb mc md me mf lu dk translated">最好的投资是自己行业的工具</p></blockquote><p id="a22e" class="pw-post-body-paragraph kz la it lb b lc mh ju le lf mi jx lh li mj lk ll lm mk lo lp lq ml ls lt lu im bi translated">这是我为什么以及如何构建一个多库Git CLI助手工具Tortuga的故事，以及我在做这件事时学到了什么。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/c88ce7fda92e3cc68dfeab2ea95b2deb.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*aN4wRR3k3Pa0K2hg45770A.png"/></div></figure></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="252b" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">找到你的最佳点</h1><p id="4397" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">在我的公司，我们每天都要处理大量的Git仓库。我们的主要产品由一个核心项目和多达3个特定于客户的子项目组成——每个子项目都在自己的存储库中。</p><p id="9807" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">目前，我的<code class="fe nr ns nt nu b">code</code>文件夹中有20个存储库需要定期获取、推送和重新存储。我使用的大多数Git工具都专注于一次处理一个存储库。有时你会错过一些东西，你可能会在rebase/merge地狱中结束。</p><p id="b7a1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们需要一个工具来更新我们所有的存储库，尽可能减少摩擦。在看到我的同事和我自己每天都在为这个琐碎的任务而奋斗之后，我决定让它自动化。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="1c9c" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">规划托尔图加</h1><p id="e956" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">尽管它只是一个内部工具，我还是把它当作一个真正的项目。我本来可以事先不做太多计划就编写一个小的shell脚本，然后就完成了。但是，如果一个工具必须处理一定数量的复杂性和边缘情况，我们应该<em class="lv">做好</em>。</p><p id="58b8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">构建工具会消耗时间和精力，我们需要明智地使用它们。定义需求、用例、风险、长期维护等。，将极大地有助于实现最好的结果。</p><h2 id="d930" class="nv mv it bd mw nw nx dn na ny nz dp ne li oa ob ng lm oc od ni lq oe of nk og bi translated">定义需求</h2><p id="6bee" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">思考我们的工具，这些是浮现在脑海中的基本要求:</p><ul class=""><li id="c688" class="oh oi it lb b lc ld lf lg li oj lm ok lq ol lu om on oo op bi translated">获取、推送和重置多个存储库</li><li id="d718" class="oh oi it lb b lc oq lf or li os lm ot lq ou lu om on oo op bi translated">并行，不是串行</li><li id="2fbe" class="oh oi it lb b lc oq lf or li os lm ot lq ou lu om on oo op bi translated">易于分发</li><li id="2448" class="oh oi it lb b lc oq lf or li os lm ot lq ou lu om on oo op bi translated">适用于所有开发机器(Linux、macOS和Windows)</li></ul><p id="fd77" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">似乎很简单。但是再深入一点，更软的需求和“拥有更好”的需求出现了:</p><ul class=""><li id="79b2" class="oh oi it lb b lc ld lf lg li oj lm ok lq ol lu om on oo op bi translated">优雅地处理未提交的更改</li><li id="7bb2" class="oh oi it lb b lc oq lf or li os lm ot lq ou lu om on oo op bi translated">一次处理多个存储库(多线程)</li><li id="e373" class="oh oi it lb b lc oq lf or li os lm ot lq ou lu om on oo op bi translated">显示变化/试运行</li><li id="814c" class="oh oi it lb b lc oq lf or li os lm ot lq ou lu om on oo op bi translated">CI/CD注意事项</li><li id="b78f" class="oh oi it lb b lc oq lf or li os lm ot lq ou lu om on oo op bi translated">开源发行版</li></ul><h2 id="f42f" class="nv mv it bd mw nw nx dn na ny nz dp ne li oa ob ng lm oc od ni lq oe of nk og bi translated">使用案例</h2><p id="186c" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">不要只考虑你会如何使用这个工具。询问您的同事该工具的用途对他们意味着什么，以及他们打算如何使用它。只有这样，作为工具的开发者，每一个可能的用例对我们来说都是可见的。并且我们可以从早期开始最小化工具的错误和误用。</p><p id="614c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在与我的同事交谈后，发现了一个额外的“用例”:“单目录”使用。如果我们在一个已经是Git存储库的目录中调用这个工具会怎么样？如果我们只是检查存储库的子文件夹，该工具不会做任何事情。但是为什么我们不能更新单个目录呢？该工具将多个Git命令压缩到一个调用中，因此在单个存储库中使用时也可以节省一些时间。</p><h2 id="7ac1" class="nv mv it bd mw nw nx dn na ny nz dp ne li oa ob ng lm oc od ni lq oe of nk og bi translated">风险评估</h2><p id="5329" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">我们的工具也应该尽可能安全。但是绝对安全是一个不可能的目标。</p><p id="42ea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的小Git工具中，安全性很简单。我们需要保存未提交的更改，方法是在获取后隐藏并重新应用它们。而不使用<code class="fe nr ns nt nu b">git push --force</code>。即使出了问题，我们还是会去仓库。</p><h2 id="b1d4" class="nv mv it bd mw nw nx dn na ny nz dp ne li oa ob ng lm oc od ni lq oe of nk og bi translated">长期支持</h2><p id="abe8" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">我们的工作在我们的作品首次发布后并没有结束。如果这个工具是好的和有帮助的，它可能会被使用很长一段时间，并成为某些工作流的必要组成部分。</p><p id="f4c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果由于操作系统更新而出现故障，该怎么办？如果开发人员已经不在公司了，并且由于缺少文档或者所使用的编程语言，没有人能够接手，该怎么办？</p><p id="8f39" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可维护性应该影响我们对最终选择的构建部分的考虑。这并不意味着我们必须使用我们一直使用的语言和框架。但是找到与你的开发伙伴的共同点将会有很长的路要走。</p><p id="3e29" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">文档通常是事后才想到的。但是即使在小的或个人的项目中，它也能拯救我们。仅仅因为我们现在知道每一个细节的“为什么”和“如何”，并不意味着我们在6个月后就知道了。</p><p id="33e3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它不必是一个拥有自己的wiki的完整项目文档。但是记录我们的设计决策，尤其是那些不明显的，是必不可少的。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="0093" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">使用什么语言</h1><p id="954d" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">为托尔图加岛选择正确的语言并不容易。我编写的大多数CLI工具都是从一个简单的shell脚本开始的，并且很可能一直如此。但是其中一个要求是“并行”以提高性能。</p><p id="ad70" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在某种形式下，使用shell脚本可以实现多线程。但在我看来，这种复杂性不值得。尤其是在有其他选择的情况下。</p><p id="b231" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可能从我的其他文章中知道，Java是我的<em class="lv">日常驱动程序</em>。它也是我公司使用最多的语言。似乎是天生的一对。</p><p id="31f1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以用Java/GraalVM 等构建<a class="ae ky" href="https://www.infoq.com/articles/java-native-cli-graalvm-picocli/" rel="noopener ugc nofollow" target="_blank">单个本机可执行文件。甚至还有Git </a><a class="ae ky" href="https://www.eclipse.org/jgit/" rel="noopener ugc nofollow" target="_blank">的纯Java实现。但是如果我想到“CLI”，我通常不会想到<em class="lv"> Java </em>。</a></p><p id="eda6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">就像选择语言一样，我们必须考虑工具链的复杂性。因此，尽管Java和GraalVM 令人印象深刻，但它们并没有入选。</p><p id="5edd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最近，两种语言被越来越多地用于构建CLI工具:<a class="ae ky" href="https://golang.org/" rel="noopener ugc nofollow" target="_blank"> <em class="lv"> Go </em> </a>和<a class="ae ky" href="https://www.rust-lang.org/" rel="noopener ugc nofollow" target="_blank"> <em class="lv"> Rust </em> </a>。</p><p id="08c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我还没有充分利用<em class="lv"> Go </em>或<em class="lv"> Rust </em>来做出明智的决定。两者都是很棒的语言，能够构建很棒的CLI工具。那么选哪个呢？</p><h2 id="dbae" class="nv mv it bd mw nw nx dn na ny nz dp ne li oa ob ng lm oc od ni lq oe of nk og bi translated">戈朗</h2><p id="b744" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">Go 宣称自己简单、可靠、高效。在我看来，这是真的。有些人可能会说，这种简单性是以失去功能和固执己见为代价的。但这也是为什么Go如此成功，是一门如此伟大的语言的首要原因。这很容易理解，即使你没有记住。一个简单的跨平台工具链可以构建本机的、无依赖性的、单一的可执行文件。</p><p id="771b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它勾选了很多满足托尔图加岛要求所需的选项。但是我也想给铁锈一个机会。</p><h2 id="b25f" class="nv mv it bd mw nw nx dn na ny nz dp ne li oa ob ng lm oc od ni lq oe of nk og bi translated">锈</h2><p id="6aec" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">Rust宣称自己是可靠和高效的。如果你知道<em class="lv">锈</em>，你就知道“简单”这个词的缺失是有原因的。这种语言是为绝对的可靠性、正确性和性能而设计的。这就是为什么学习曲线比<em class="lv"> Go </em>更陡的原因。</p><p id="e218" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它在正确性上很严谨，使用了一个“<a class="ae ky" href="https://doc.rust-lang.org/1.8.0/book/references-and-borrowing.html" rel="noopener ugc nofollow" target="_blank">借位检查器</a>”，保证内存安全。我们将在开始时与它“斗争”,甚至让我们的代码只是编译。</p><p id="e596" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，除了简单的盒子之外，它也为托尔图加做了很多选择。</p><h2 id="9f8c" class="nv mv it bd mw nw nx dn na ny nz dp ne li oa ob ng lm oc od ni lq oe of nk og bi translated">哪一个？</h2><p id="8d40" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">为了更好地理解我的选择的含义，我决定用两种语言构建一个小型原型。开始一个小项目并使用两种语言的工具让我意识到一些事情:Tortuga不会是一个低风险的关键任务工具。</p><p id="3ad2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Rust的正确性和有保证的内存安全所需要的额外的精神负担不值得去努力，至少对我来说是这样。这并不意味着我不相信Rust对于CLI工具来说不是一种优秀的语言，恰恰相反。</p><p id="e01d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管我喜欢<em class="lv"> Rust的</em>想法和概念，但为了降低入门和可维护性，我选择了<em class="lv"> Go </em>。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="8603" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">实施Tortuga</h1><p id="862e" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">构建工具本身并不难，除了一件事:<em class="lv">实际上</em>使用Git。</p><p id="68e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Tortuga需要能够执行以下Git操作:</p><ul class=""><li id="2fe3" class="oh oi it lb b lc ld lf lg li oj lm ok lq ol lu om on oo op bi translated">获取本地分支名称(<code class="fe nr ns nt nu b"><a class="ae ky" href="https://git-scm.com/docs/git-rev-parse" rel="noopener ugc nofollow" target="_blank">rev-parse</a></code>)</li><li id="7ff9" class="oh oi it lb b lc oq lf or li os lm ot lq ou lu om on oo op bi translated">获取上游分行名称(<code class="fe nr ns nt nu b"><a class="ae ky" href="https://git-scm.com/docs/git-rev-parse" rel="noopener ugc nofollow" target="_blank">rev-parse</a></code></li><li id="7a67" class="oh oi it lb b lc oq lf or li os lm ot lq ou lu om on oo op bi translated">计数提交(<code class="fe nr ns nt nu b"><a class="ae ky" href="https://git-scm.com/docs/git-rev-list" rel="noopener ugc nofollow" target="_blank">rev-list</a></code>)</li><li id="071b" class="oh oi it lb b lc oq lf or li os lm ot lq ou lu om on oo op bi translated">抓取遥控器(<code class="fe nr ns nt nu b"><a class="ae ky" href="https://git-scm.com/docs/git-fetch" rel="noopener ugc nofollow" target="_blank">fetch</a></code></li><li id="0416" class="oh oi it lb b lc oq lf or li os lm ot lq ou lu om on oo op bi translated">获取当前状态(<code class="fe nr ns nt nu b"><a class="ae ky" href="https://git-scm.com/docs/git-status" rel="noopener ugc nofollow" target="_blank">status</a></code>)</li><li id="f0a9" class="oh oi it lb b lc oq lf or li os lm ot lq ou lu om on oo op bi translated">重定基数(<code class="fe nr ns nt nu b"><a class="ae ky" href="https://git-scm.com/docs/git-rebase" rel="noopener ugc nofollow" target="_blank">rebase</a></code>)</li><li id="1f92" class="oh oi it lb b lc oq lf or li os lm ot lq ou lu om on oo op bi translated">按下遥控器(<code class="fe nr ns nt nu b"><a class="ae ky" href="https://git-scm.com/docs/git-push" rel="noopener ugc nofollow" target="_blank">push</a></code>)</li><li id="a1eb" class="oh oi it lb b lc oq lf or li os lm ot lq ou lu om on oo op bi translated">保留未提交的更改(<code class="fe nr ns nt nu b"><a class="ae ky" href="https://git-scm.com/docs/git-stash" rel="noopener ugc nofollow" target="_blank">stash</a></code>)</li></ul><p id="a208" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最初，我计划使用一个基于<em class="lv"> Go </em>的Git实现来避免任何依赖。但是我发现的库，比如<code class="fe nr ns nt nu b"><a class="ae ky" href="https://github.com/src-d/go-git" rel="noopener ugc nofollow" target="_blank">go-git</a></code>，并不支持所有需要的特性。</p><p id="4d02" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一个选择是通过<code class="fe nr ns nt nu b"><a class="ae ky" href="https://github.com/libgit2/git2go" rel="noopener ugc nofollow" target="_blank">git2go</a></code>使用C库<code class="fe nr ns nt nu b"><a class="ae ky" href="https://libgit2.org/" rel="noopener ugc nofollow" target="_blank">libgit2</a></code>。但是在<em class="lv"> Go </em>中使用C代码带来了我不想要的复杂性。包括实现凭证处理、Git配置文件等。，全靠自己。</p><p id="520c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我通过<code class="fe nr ns nt nu b">os/exec</code>直接使用本地安装的Git，并解析输出。</p><p id="a1fc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">起初，我不太喜欢依赖启动一个进程和处理它的输出。但这是使用Git最简单的方式，它的行为就像用户直接使用Git一样。此外，<a class="ae ky" href="https://github.com/cli/cli/blob/master/git/git.go#L51" rel="noopener ugc nofollow" target="_blank"> GitHub CLI </a>也是以同样的方式构建的，所以不会有那么大的错误，不是吗？</p><h2 id="dea4" class="nv mv it bd mw nw nx dn na ny nz dp ne li oa ob ng lm oc od ni lq oe of nk og bi translated">开源</h2><p id="6183" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">开发从托管在我们内部BitBucket服务器上的项目存储库开始。我本可以将最新版本放在我们的NAS上，并告诉我的同事在哪里可以找到它，然后就可以收工了。但是更新和错误修复呢？当我接近第一个可发布的版本时，我决定带着标签版本转移到<a class="ae ky" href="https://github.com/benweidig/tortuga" rel="noopener ugc nofollow" target="_blank"> GitHub </a>。尽管我的公司是Tortuga的唯一用户(据我所知)，我强烈认为我们应该共享我们的工具。</p><p id="81c5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">转移到GitHub也允许使用<a class="ae ky" href="https://travis-ci.org/" rel="noopener ugc nofollow" target="_blank"> Travis CI </a>。仅用YAML的3行代码，这个项目就免费获得了自动构建和测试。</p><p id="03ba" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，一个单独的<code class="fe nr ns nt nu b">make release</code>将构建代码，运行测试，并为所有支持的平台创建一个新版本:Linux。deb-file)、macOS (.tar.gz二进制)和Windows(zip。exe-file)，适用于32位和64位。</p><p id="3463" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">macOS用户也可以使用我的私有<a class="ae ky" href="https://github.com/benweidig/homebrew-tap" rel="noopener ugc nofollow" target="_blank">家酿tap </a>始终获得最新版本。总有一天，我需要为Linux版本创建一个PPA…</p><p id="39d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">开源这样一个内部使用的小工具似乎很愚蠢。但是，如果它与我们的具体项目没有太紧密的联系，或者没有透露任何秘密，为什么不呢？也许有人会以类似的方式使用它，或者可以为自己的工具使用一些代码。</p></div><div class="ab cl mn mo hx mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="im in io ip iq"><h1 id="a5ed" class="mu mv it bd mw mx my mz na nb nc nd ne jz nf ka ng kc nh kd ni kf nj kg nk nl bi translated">结论</h1><p id="3820" class="pw-post-body-paragraph kz la it lb b lc nm ju le lf nn jx lh li no lk ll lm np lo lp lq nq ls lt lu im bi translated">构建工具可能很有趣，有时也会令人沮丧。尤其是当我们决定使用新技术或未知语言的时候。这不是我写过的最好的代码。但是我学到了很多关于Git、<em class="lv"> Go </em>和在GitHub上发布东西的知识。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ov"><img src="../Images/d03142524bc0d108dd4fbe86df679809.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*apGpHqkVe6JtTAWXznZt6w.gif"/></div></div></figure><div class="ow ox gp gr oy oz"><a href="https://github.com/benweidig/tortuga" rel="noopener  ugc nofollow" target="_blank"><div class="pa ab fo"><div class="pb ab pc cl cj pd"><h2 class="bd iu gy z fp pe fr fs pf fu fw is bi translated">本威迪格/托尔图加</h2><div class="pg l"><h3 class="bd b gy z fp pe fr fs pf fu fw dk translated">CLI工具，用于一次获取/推送/重置多个git存储库。</h3></div><div class="ph l"><p class="bd b dl z fp pe fr fs pf fu fw dk translated">github.com</p></div></div><div class="pi l"><div class="pj l pk pl pm pi pn ks oz"/></div></div></a></div><div class="ow ox gp gr oy oz"><a href="https://github.com/benweidig/homebrew-tap/" rel="noopener  ugc nofollow" target="_blank"><div class="pa ab fo"><div class="pb ab pc cl cj pd"><h2 class="bd iu gy z fp pe fr fs pf fu fw is bi translated">benwei dig/家酿水龙头</h2><div class="pg l"><h3 class="bd b gy z fp pe fr fs pf fu fw dk translated">我的私人自制水龙头。</h3></div><div class="ph l"><p class="bd b dl z fp pe fr fs pf fu fw dk translated">github.com</p></div></div><div class="pi l"><div class="po l pk pl pm pi pn ks oz"/></div></div></a></div></div></div>    
</body>
</html>