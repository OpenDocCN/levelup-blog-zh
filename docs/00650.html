<html>
<head>
<title>Building a scheduled news crawler with Puppeteer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用木偶师构建一个预定的新闻爬虫</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/building-a-scheduled-news-crawler-with-puppeteer-d02a7919bdbe?source=collection_archive---------2-----------------------#2019-06-18">https://levelup.gitconnected.com/building-a-scheduled-news-crawler-with-puppeteer-d02a7919bdbe?source=collection_archive---------2-----------------------#2019-06-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="f3fa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这个项目中，我将一步一步地展示如何构建自己的新闻爬虫，访问多个网站并收集所有必要的信息。</p><h1 id="5c73" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">我们在建造什么？</h1><p id="a6f3" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">在这个项目中，我们将建立一个NodeJS服务器，它运行一个预定的Puppeteer crawler并从新闻站点收集所有信息。我所说的计划是指您可以设置任何时间的数据/小时/分钟，爬虫将通过再次爬行新闻站点来刷新它的数据。</p><h1 id="2e41" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated"><strong class="ak">木偶师背景资料</strong></h1><p id="e95e" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">木偶师的官方文件记载:</p><blockquote class="lr ls lt"><p id="1ddb" class="jq jr lu js b jt ju jv jw jx jy jz ka lv kc kd ke lw kg kh ki lx kk kl km kn im bi translated">Puppeteer是一个节点库，它提供了一个高级API来控制Chrome或通过<a class="ae ly" href="https://chromedevtools.github.io/devtools-protocol/" rel="noopener ugc nofollow" target="_blank"> DevTools协议</a>的Chrome。默认情况下，木偶师运行无头的<a class="ae ly" href="https://developers.google.com/web/updates/2017/04/headless-chrome" rel="noopener ugc nofollow" target="_blank">，但可以配置为运行全(无头)铬或铬。</a></p></blockquote><p id="d45d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这意味着几乎所有你能在网上做的事情，木偶师都能帮你做。这方面的一些例子是:<br/> -生成页面的截图和pdf<br/>-创建测试环境<br/> -抓取任何页面，不管它是SPA还是SSR页面。</p><h1 id="ab95" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated"><strong class="ak">入门</strong></h1><p id="8bbb" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">要开始，我们需要确保您已经安装了节点。这可以通过在终端中键入以下命令来检查。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="f650" class="mi kp it me b gy mj mk l ml mm">node -v</span></pre><p id="35ed" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这样做的结果应该类似于10.16.0。<br/>如果不是这样，您可以访问<a class="ae ly" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank">https://nodejs.org/en/</a>并按照安装指南进行手动安装。</p><p id="f39f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们都准备好了，我们可以开始用必要的文件创建一个文件夹，并开始编码。</p><h1 id="71bc" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated"><strong class="ak">设置</strong></h1><p id="5602" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">我们将在本节中设置项目并安装依赖项。首先，在终端中导航到您希望安装项目的位置。</p><p id="b6b7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">例如，我希望我的项目位于我的项目文件夹中，该文件夹位于我的文档文件夹中。我可以通过运行以下代码来实现这一点:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="bc0d" class="mi kp it me b gy mj mk l ml mm">cd ~/Documents/projecten</span></pre><p id="65d8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在此文件夹中，您可以运行以下代码来创建一个文件夹，项目将在其中生成。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="ef9b" class="mi kp it me b gy mj mk l ml mm">mkdir news-crawler</span><span id="865e" class="mi kp it me b gy mn mk l ml mm">// To navigate inside this folder you can run:<br/>cd news-crawler</span></pre><p id="29b7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下一步是建立项目文件。我们将创建的第一个东西是package.json，方法是在您的终端中运行以下代码(在项目文件夹中)。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="f9d1" class="mi kp it me b gy mj mk l ml mm">npm init --yes or yarn init --yes</span></pre><p id="f212" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上面的代码创建了一个package.json，其中包含一些关于您的基本信息。您可以运行“npm init”并手动添加所有信息，或者打开代码编辑器并编辑创建的文件。</p><p id="d26b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下一步是创建文件，我们的爬虫将被创建。在我的例子中，我将文件命名为crawler.js，但这可以是您喜欢的任何名称。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="c4a1" class="mi kp it me b gy mj mk l ml mm">touch crawler.js</span></pre><p id="5b90" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这就是我们项目的基础。让我们安装一些包并开始编码。</p><h1 id="ffdc" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated"><strong class="ak">安装必要的软件包</strong></h1><p id="9a41" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">我们要安装的第一个包是Puppeteer本身和nodemon。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="c387" class="mi kp it me b gy mj mk l ml mm">npm install puppeteer nodemon --save or yarn add puppeteer nodemon</span></pre><p id="604b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为我们将在我们的终端得到结果，所以我们还不需要添加任何像express这样的包。这将在我们的项目结束时出现。</p><p id="b909" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">关于我们刚刚安装的一些背景信息:</p><p id="39fa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Puppeteer是我们在本文前面提到的crawler，nodemon是node.js文件的监视器，监视更改并在每次更改时重新启动自己，因此您不必每次保存更改时都键入node crawler.js。</p><h1 id="766c" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">我们写点代码吧！</h1><p id="8ae2" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">我们要写的第一件事是一个老式的“hello world”消息，并在我们的package.json中构建一个start命令。</p><p id="53f6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">打开您最喜欢的代码编辑器，在crawler.js文件中，我们将创建一条简单的消息:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="eb0f" class="mi kp it me b gy mj mk l ml mm">console.log(‘hey globe’)</span></pre><p id="3bcd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将通过向我们的package.json添加一个脚本来访问它，我们可以在我们的终端中运行这个脚本。</p><p id="aeb4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">打开package.json并在依赖项下面，您可以编写以下内容:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="9d6b" class="mi kp it me b gy mj mk l ml mm">“scripts”: {“start”: “nodemon crawler.js”}</span></pre><p id="6ca8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在您的终端中，您现在可以运行“npm run start”或“yarn start ”,我们之前键入的console.log消息将显示在您的终端中。</p><h1 id="8db3" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated"><strong class="ak">开始操纵木偶</strong></h1><p id="ed08" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">我们将从展示一些可以用木偶师完成的魔术开始。我们将通过一个简单的例子来展示您可以期待什么。</p><p id="91ab" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我做了一个小的设置，用注解说明了每个函数的作用。最好是自己写，喜欢就抄。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="d0e7" class="mi kp it me b gy mj mk l ml mm">const puppeteer = require(“puppeteer”);</span><span id="f2b3" class="mi kp it me b gy mn mk l ml mm"><em class="lu">// Puppeteer is in this case a IIFE to make sure it directly starts gathering the dimension of the page.</em></span><span id="eed3" class="mi kp it me b gy mn mk l ml mm">(async () =&gt; {</span><span id="f793" class="mi kp it me b gy mn mk l ml mm"><em class="lu">// Puppeteer.launch() is the default function to launch a browser, in this case added an option called headless: false. This shows what actions puppeteer is currently doing.</em></span><span id="5029" class="mi kp it me b gy mn mk l ml mm">const browser = await puppeteer.launch({ headless: false });</span><span id="f608" class="mi kp it me b gy mn mk l ml mm">// Make sure the browser opens a new page</span><span id="d8c6" class="mi kp it me b gy mn mk l ml mm">const page = await browser.newPage();</span><span id="ba40" class="mi kp it me b gy mn mk l ml mm"><em class="lu">// Navigate to the desired website. WaintUntil is used to make sure there is a internet connection.</em></span><span id="6f35" class="mi kp it me b gy mn mk l ml mm">await page.goto(“https://news.ycombinator.com",{waitUntil:“networkidle2”});</span><span id="e090" class="mi kp it me b gy mn mk l ml mm"><em class="lu">// page.evaluate is the function that can gather information from the page. In thise case the dimensions.</em></span><span id="be89" class="mi kp it me b gy mn mk l ml mm">const dimensions = await page.evaluate(() =&gt; {<br/>  return {<br/>     width: document.documentElement.clientWidth<br/>   };<br/> });</span><span id="448f" class="mi kp it me b gy mn mk l ml mm"> console.log(“Dimension:”, dimensions);</span><span id="a594" class="mi kp it me b gy mn mk l ml mm">// The browser needs to be closed after the actions are completed.<br/> await browser.close();<br/>})();</span></pre><p id="81b5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你运行过这段代码，你已经看到网站ycombinator因为browser.close()的原因在之后直接被打开和关闭。这是page.evaluate()函数完成时的行为。结果会在你的终端里，因为我们记录了结果。</p><p id="fab0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这很有趣，但是让我们开始从新闻网站收集一些信息。</p><p id="25e0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">木偶师功能的设置如下所示:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="6388" class="mi kp it me b gy mj mk l ml mm">(async () =&gt; {</span><span id="9e35" class="mi kp it me b gy mn mk l ml mm">const browser = await puppeteer.launch({ headless: false });</span><span id="9362" class="mi kp it me b gy mn mk l ml mm">const page = await browser.newPage();</span><span id="7b8f" class="mi kp it me b gy mn mk l ml mm">const newsTitles = await getNewsTitles(page);</span><span id="fff7" class="mi kp it me b gy mn mk l ml mm">console.log(newsTitles);</span><span id="e43e" class="mi kp it me b gy mn mk l ml mm">await browser.close();</span><span id="8649" class="mi kp it me b gy mn mk l ml mm">})();</span></pre><p id="43a5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">' getNewsTitles(page)'将是我将为该页面编写逻辑的函数。请注意我是如何在函数中将' page '作为参数传递的。这对于让木偶师在函数中评估页面是必要的。</p><p id="13eb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这种情况下，我们的目标网站是《泰晤士报》。在编写任何逻辑之前，我们需要做的第一件事是手动评估页面，并寻找我们想要的有趣标题或文本。</p><p id="5e19" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我的目标是标题，重点是它显示的文本和链接。当我在我的终端里浏览网站时，我看了看那些非常常见的标题类。在这种情况下，大多数课程都非常简单。项目-标题”。</p><figure class="lz ma mb mc gt mp gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi mo"><img src="../Images/c52dd21532e2ae99368d4282bd4a98d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ec20iifi6yGpYyt3erPXkA.png"/></div></div></figure><p id="704b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在的诀窍是获取标题内部链接的信息。为此，我们需要使用木偶师评估页面，并尝试访问标题。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="ec0d" class="mi kp it me b gy mj mk l ml mm">async function getNewsTitles(<em class="lu">page</em>) {</span><span id="92b0" class="mi kp it me b gy mn mk l ml mm">  await page.goto("https://www.thetimes.co.uk/?region=global");</span><span id="3cf2" class="mi kp it me b gy mn mk l ml mm">  return (results = await page.evaluate(() =&gt; {</span><span id="3f71" class="mi kp it me b gy mn mk l ml mm">const allTitles = document.querySelectorAll(".Item-headline a", {waitUntil: 'networkidle2'});</span><span id="8720" class="mi kp it me b gy mn mk l ml mm">    return Array.from(allTitles)<br/>      .slice(0, 10)<br/>      .map(<em class="lu">title</em> =&gt; {<br/>        let res = {<br/>          title: title.textContent,<br/>          link: title["href"]<br/>        };<br/>  <br/>      return res;<br/>      <br/>      });</span><span id="0c31" class="mi kp it me b gy mn mk l ml mm">   }));<br/>}</span></pre><p id="4e60" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我上面所做的是创建一个异步函数，这是使木偶师正常工作所必需的。我们等待网站的加载，然后开始收集所有早期找到的带链接的类。</p><p id="edd8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们创建了一个所有链接的数组，为了可读性，我们将它拼接为10，然而，这可以是您喜欢的任何数字，如果您想要所有的结果，您可以删除拼接功能。我们现在可以映射所有项目并返回我们想要的信息。在这种情况下，我需要标题和链接。要访问HTML项目中的内容，您可以使用。textContent”。对于链接，我们可以针对“href”属性。</p><p id="21a6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上面代码的结果是一个包含我们想要的信息的对象数组。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="12e5" class="mi kp it me b gy mj mk l ml mm">[<br/>  { title:<br/>     'Reality or fantasy? Claims of Tory leadership rivals put to the test',<br/>    link:<br/>     '<a class="ae ly" href="https://www.thetimes.co.uk/edition/news/reality-or-fantasy-claims-of-tory-leadership-rivals-put-to-the-test-8gnb6x5vw'" rel="noopener ugc nofollow" target="_blank">https://www.thetimes.co.uk/edition/news/reality-or-fantasy-claims-of-tory-leadership-rivals-put-to-the-test-8gnb6x5vw'</a> <br/>  } <br/>]</span></pre><p id="1120" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">嗯，我们现在有了我们的标题，这可以用网站上的任何元素来完成。你只需要知道你需要瞄准哪些元素。</p><h1 id="518d" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">现在还剩下什么？</h1><p id="c4e9" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">嗯，我们在终端中获得了数据，但是如果我们能够将这些数据导出到一个JSON文件中，并根据时间表进行更新，那就更好了。这就是我们接下来要做的。</p><p id="5c15" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们需要做的第一件事是在我们的程序的顶部要求“fs”。因为我们想利用“fs.writeFile”功能。有了这个功能，您可以用动态数据编写自己类型的文件。非常适合这样的项目。</p><p id="aa7b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们在顶部的进口现在看起来像这样:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="31e1" class="mi kp it me b gy mj mk l ml mm">const puppeteer = require("puppeteer");<br/>const fs = require("fs");</span></pre><p id="d8e4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我们的代码中，我们只是记录了被收集的数据，但是这个常量也可以用来用数据写一个新文件。</p><blockquote class="lr ls lt"><p id="ad95" class="jq jr lu js b jt ju jv jw jx jy jz ka lv kc kd ke lw kg kh ki lx kk kl km kn im bi translated"><strong class="js iu">简短警告<br/> </strong>在添加下面的代码之前，关闭“npm start”进程，因为每次文件改变都会重新激活系统。</p></blockquote><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="d679" class="mi kp it me b gy mj mk l ml mm">fs.writeFile("newsitems.json", JSON.stringify(newsTitles), "utf8", (<em class="lu">err</em>, <em class="lu">data</em>) =&gt; {<br/>  if (err) {<br/>  console.error(err);<br/>} else {<br/>  console.log("created!");<br/>}});</span></pre><p id="215b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">写文件就这么简单。第一个参数是您要给文件起的名字。第二个参数是数据，如果它是一个数组，它必须是字符串形式的。第三种模式是Unicode标准，函数总是期待回调。在这种情况下，它让我们知道文件已经创建。</p><p id="e50e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们现在将有一个名为newsitems.json的新文件。</p><h1 id="5cbc" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">行程安排</h1><p id="5b3a" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">接下来我们要做的是创建一个在特定时间收集新闻的时间表。为此，我们将使用“<a class="ae ly" href="https://www.npmjs.com/package/node-schedule" rel="noopener ugc nofollow" target="_blank">节点计划</a>包。</p><p id="9280" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">运行下面的安装命令。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="3cdb" class="mi kp it me b gy mj mk l ml mm">npm install node-schedule --save or yarn add node-schedule</span></pre><p id="ff19" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">既然我们已经将包添加到我们的项目中，我们可以将它包含在我们的文件中。我们的进口现在看起来像:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="81f7" class="mi kp it me b gy mj mk l ml mm">const puppeteer = require("puppeteer");<br/>const fs = require("fs");<br/>const schedule = require('node-schedule');</span></pre><p id="a58d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是如何工作的一个基本例子:</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="da17" class="mi kp it me b gy mj mk l ml mm">schedule.scheduleJob('42 * * * *', function(){<br/>  console.log('The answer to life, the universe, and everything!');<br/>});</span></pre><p id="1586" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上面的代码将每42分钟触发一次日志。在我们的例子中，我们将这个值设置为30，这样每半小时就会收集一次新闻。</p><p id="5054" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您想将时间调整为每天一次，这里有一个图表，显示了您可以为scheduleJob提供的所有参数。</p><figure class="lz ma mb mc gt mp gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi mw"><img src="../Images/f088f80987838d2dec0c2ee6f4f345c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E5Oy_8fp-zFBhnn1LDrDAw.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">scheduleJob函数的所有参数选项。</figcaption></figure><p id="2db4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们开始在我们的项目中实现时间表。要做到这一点，我们需要把函数从一个生命中移除，变成一个我们可以随时调用的函数。在这种情况下，我们将函数绑定到一个常数。并在调度函数中调用它。</p><p id="7b22" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以这个函数现在看起来像这样:</p><figure class="lz ma mb mc gt mp gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi nb"><img src="../Images/63330d20d36587f90f02847039e3a913.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wR25HQPt5_xeUQA2ughCYQ.png"/></div></div></figure><p id="d3e1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将该函数绑定到gatherNewsItems，并在我们的schedule函数中调用它。我们可以在终端中再次启动“npm start”脚本，因为它不再是一个生命函数，每半个小时才会被调用一次。</p><pre class="lz ma mb mc gt md me mf mg aw mh bi"><span id="b658" class="mi kp it me b gy mj mk l ml mm">npm start or yarn start </span></pre><p id="2b4a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这就是我们的计划爬虫。</p><h1 id="62ca" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">然后</h1><p id="94d2" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">在下一篇文章中，我们将创建一个界面来显示和刷新我们的新闻条目。第二部分可以在<a class="ae ly" href="https://medium.com/@timruiterkamp/building-an-interface-for-our-scheduled-puppeteer-news-crawler-a93f9957f785" rel="noopener">https://medium . com/@ timruiterkamp/building-an-interface-for-our-scheduled-puppeter-news-crawler-a93f 9957 f 785</a>找到</p></div></div>    
</body>
</html>