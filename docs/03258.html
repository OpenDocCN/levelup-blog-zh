<html>
<head>
<title>Circuit Breaker Pattern with Cats Effect</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">具有猫效应的断路器图案</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/circuit-breaker-pattern-with-cats-effect-25947d0a4cba?source=collection_archive---------5-----------------------#2020-04-28">https://levelup.gitconnected.com/circuit-breaker-pattern-with-cats-effect-25947d0a4cba?source=collection_archive---------5-----------------------#2020-04-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/2fc3d0b1ad350f0b8b92a97a12c10e48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9Z8TUC3sIXa7DQUihADGPg.png"/></div></div></figure><p id="3f45" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最近，我对Scala中的函数库<a class="ae kz" href="https://typelevel.org/cats-effect/" rel="noopener ugc nofollow" target="_blank"> Cats Effect </a>很感兴趣。为了用Cats Effect提高我的编码技能，特别是并发状态管理，我用这个库实现了一个断路器。断路器是软件开发中的设计模式之一。在微服务的背景下，这种设计模式很流行。</p><p id="c724" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这篇文章中，我想解释一下断路器模式以及如何用猫效应来实现它。所有完整的代码都在我的Github仓库里。</p><div class="la lb gp gr lc ld"><a href="https://github.com/Hiroki6/SimpleCircuitBreaker" rel="noopener  ugc nofollow" target="_blank"><div class="le ab fo"><div class="lf ab lg cl cj lh"><h2 class="bd iu gy z fp li fr fs lj fu fw is bi translated">hiroki 6/简单断路器</h2><div class="lk l"><h3 class="bd b gy z fp li fr fs lj fu fw dk translated">在GitHub上创建一个帐户，为Hiroki6/SimpleCircuitBreaker的开发做出贡献。</h3></div><div class="ll l"><p class="bd b dl z fp li fr fs lj fu fw dk translated">github.com</p></div></div><div class="lm l"><div class="ln l lo lp lq lm lr jz ld"/></div></div></a></div></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="5f84" class="lz ma it bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">断路器模式</h1><p id="961d" class="pw-post-body-paragraph kb kc it kd b ke mx kg kh ki my kk kl km mz ko kp kq na ks kt ku nb kw kx ky im bi translated"><a class="ae kz" href="https://en.wikipedia.org/wiki/Circuit_breaker_design_pattern" rel="noopener ugc nofollow" target="_blank">断路器模式</a>是软件开发的一种设计模式。</p><p id="202e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在分布式系统中，每个服务都与另一个服务通信。然而，有时一个服务会一直向另一个服务发送请求，直到请求超时，即使该服务有问题并且没有响应。这种情况可能会导致线程耗尽，最终整个系统以及依赖于它的其他系统可能会停止。</p><p id="b05a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">断路器是这种情况下的解决方案。它充当服务之间的代理。这个代理监控请求，并根据最近的失败次数决定是否应该发送请求。因此，断路器是遵循这些状态的状态机:</p><ul class=""><li id="f941" class="nc nd it kd b ke kf ki kj km ne kq nf ku ng ky nh ni nj nk bi translated">关闭的</li></ul><p id="78db" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">请求被直接发送到服务。如果请求失败，断路器会累计失败次数。当数量达到定义的阈值时，断路器断开。</p><ul class=""><li id="e079" class="nc nd it kd b ke kf ki kj km ne kq nf ku ng ky nh ni nj nk bi translated">打开</li></ul><p id="7893" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">请求会立即返回错误。经过一段时间后，断路器变成半开。</p><ul class=""><li id="f568" class="nc nd it kd b ke kf ki kj km ne kq nf ku ng ky nh ni nj nk bi translated">半开的</li></ul><p id="0aab" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">请求被直接发送到服务。如果请求成功，断路器再次闭合。否则，断路器保持断开。</p><h1 id="a3b4" class="lz ma it bd mb mc nl me mf mg nm mi mj mk nn mm mn mo no mq mr ms np mu mv mw bi translated">具有Cats效果的实现</h1><p id="8109" class="pw-post-body-paragraph kb kc it kd b ke mx kg kh ki my kk kl km mz ko kp kq na ks kt ku nb kw kx ky im bi translated">正如我之前解释的，断路器有一个内部状态。就实现而言，这种状态必须得到适当的管理，即使请求是异步发送的。换句话说，断路器内部有一个可变的引用，这个引用必须是原子的。</p><p id="86bf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了达到这个要求，<a class="ae kz" href="https://typelevel.org/cats-effect/" rel="noopener ugc nofollow" target="_blank"> Cats Effect </a>在<a class="ae kz" href="https://typelevel.org/cats-effect/concurrency/" rel="noopener ugc nofollow" target="_blank"><em class="nq">Cats . Effect . concurrent</em></a><em class="nq"/>模块中提供了一些并发编程的好东西。在该模块中，<a class="ae kz" href="https://typelevel.org/cats-effect/concurrency/ref.html" rel="noopener ugc nofollow" target="_blank"> <em class="nq"> Ref </em> </a>适用于这种状态管理。它有一个纯函数性的、并发的、无锁的可变引用。这个可变引用被保存为AtomicReference。从下面的代码可以看出，它们的操作如<em class="nq"> get </em>、<em class="nq"> modify </em>都是原子执行的。</p><pre class="nr ns nt nu gt nv nw nx ny aw nz bi"><span id="e2ed" class="oa ma it nw b gy ob oc l od oe">final private class SyncRef[F[_], A](ar: AtomicReference[A])(implicit F: Sync[F]) extends Ref[F, A] {<br/>  def get: F[A] = F.delay(ar.get)</span><span id="9a17" class="oa ma it nw b gy of oc l od oe">def set(a: A): F[Unit] = F.delay(ar.set(a))</span><span id="2e30" class="oa ma it nw b gy of oc l od oe">def update(f: A =&gt; A): F[Unit] = modify { a =&gt;<br/>    (f(a), ())<br/>  }</span><span id="9fb4" class="oa ma it nw b gy of oc l od oe">def modify[B](f: A =&gt; (A, B)): F[B] = {<br/>    <a class="ae kz" href="http://twitter.com/tailrec" rel="noopener ugc nofollow" target="_blank">@tailrec</a><br/>    def spin: B = {<br/>      val c = ar.get<br/>      val (u, b) = f(c)<br/>      if (!ar.compareAndSet(c, u)) spin<br/>      else b<br/>    }<br/>    F.delay(spin)<br/>  }<br/>}</span></pre><p id="849f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，让我们一步步来看看这个实现。这个实现的灵感来自于这两个模块:<a class="ae kz" href="https://hackage.haskell.org/package/glue-core-0.6.3/docs/Glue-CircuitBreaker.html" rel="noopener ugc nofollow" target="_blank"> <em class="nq"> Glue。断路器</em> </a>，Haskell的一个模块，<a class="ae kz" href="https://github.com/YBogomolov/circuit-breaker-monad" rel="noopener ugc nofollow" target="_blank"> <em class="nq">断路器——单子</em> </a>，打字稿的一个模块。</p><h2 id="1bc5" class="oa ma it bd mb og oh dn mf oi oj dp mj km ok ol mn kq om on mr ku oo op mv oq bi translated">连接</h2><p id="a1e9" class="pw-post-body-paragraph kb kc it kd b ke mx kg kh ki my kk kl km mz ko kp kq na ks kt ku nb kw kx ky im bi translated"><em class="nq">断路器</em>特性有<em class="nq">运行</em>和<em class="nq">获取状态</em>方法<em class="nq">。</em></p><ul class=""><li id="1641" class="nc nd it kd b ke kf ki kj km ne kq nf ku ng ky nh ni nj nk bi translated"><em class="nq">运行</em></li></ul><p id="d91d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当使用断路器发送请求时，这是客户端使用的主要方法。参数是向另一个微服务发送请求的执行。在该方法中，根据断路器的状态来决定是否应该发送请求。当断路器打开时，该方法立即返回包含在<em class="nq"> IO中的错误。</em></p><ul class=""><li id="60c0" class="nc nd it kd b ke kf ki kj km ne kq nf ku ng ky nh ni nj nk bi translated"><em class="nq">获取状态</em></li></ul><p id="ab86" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">该方法自动返回内部状态。这种状态可以读取，但不能从外部更改。</p><figure class="nr ns nt nu gt ju"><div class="bz fp l di"><div class="or os l"/></div><figcaption class="ot ou gj gh gi ov ow bd b be z dk translated">断路接口</figcaption></figure><p id="f438" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">断路器对象可以由伴随对象<em class="nq">的<em class="nq"> create </em>方法创建。</em>在该方法中，状态被表示为【F，BreakerStatus】的<em class="nq"> Ref。</em><em class="nq">create</em>返回包装在类型构造函数<em class="nq"> F[_] </em>中的断路器对象，因为可变状态是内部创建的，这是一个效果<em class="nq">。</em>在下面的例子中，它被包裹在<em class="nq"> IO中。</em></p><p id="c28f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="nq">断路器</em>允许客户使用相同的断路器或分开的断路器。正如您在下面的例子中看到的，在通过调用<em class="nq">平面图</em>创建的上下文中，断路器是共享的。否则，将单独创建和共享每个状态。正是由于引用的透明性，<em class="nq">引用</em>才有<em class="nq">。</em>该规范使我们很容易理解断路器状态在哪里共享。在<a class="ae kz" href="https://vimeo.com/294736344" rel="noopener ugc nofollow" target="_blank"> Fabio的演示</a>中，详细解释了<em class="nq"> Ref </em>的这种引用透明性。</p><pre class="nr ns nt nu gt nv nw nx ny aw nz bi"><span id="422b" class="oa ma it nw b gy ob oc l od oe">val circuitBreaker: IO[CircuitBreaker[IO]] = <br/>  CircuitBreaker.<em class="nq">create</em>[IO](<em class="nq">breakerOptions</em>)<br/><br/>def toServiceA1(circuitBreaker: CircuitBreaker[IO]): IO[String] = <em class="nq">???<br/></em>def toServiceA2(circuitBreaker: CircuitBreaker[IO]): IO[String] = <em class="nq">???<br/></em>def toServiceB(circuitBreaker: CircuitBreaker[IO]): IO[String] = <em class="nq">???</em></span><span id="f16c" class="oa ma it nw b gy of oc l od oe">def separateBreaker = <br/>  circuitBreaker.flatMap(toServiceA1) &gt;&gt; circuitBreaker.flatMap(toServiceB)<br/><br/>def sameBreaker = circuitBreaker.flatMap { c =&gt;<br/>  toServiceA1(c) &gt;&gt; toServiceA2(c)<br/>}</span></pre><p id="f066" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">另一方面，这个<em class="nq">断路器</em>对象没有考虑多节点服务器的用例。这意味着断路器状态不会在服务器之间共享。为了满足这一要求，应该使用持久存储。</p><blockquote class="ox oy oz"><p id="856a" class="kb kc nq kd b ke kf kg kh ki kj kk kl pa kn ko kp pb kr ks kt pc kv kw kx ky im bi translated">在多节点(集群)服务器中，上游服务的状态需要反映在集群中的所有节点上。因此，实现可能需要使用持久存储层，例如网络缓存(如<a class="ae kz" href="https://en.wikipedia.org/wiki/Memcached" rel="noopener ugc nofollow" target="_blank"> Memcached </a>或<a class="ae kz" href="https://en.wikipedia.org/wiki/Redis" rel="noopener ugc nofollow" target="_blank"> Redis </a>)或本地缓存(基于磁盘或内存)来记录外部服务对应用程序的可用性。</p></blockquote><p id="59d5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">断路器闭合</strong></p><p id="cf4f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当断路器闭合时，<em class="nq">调用关闭的</em>方法执行客户端取的<em class="nq">体</em>。如果执行成功，则返回响应。如果执行失败，失败次数会随着更新状态并自动获得结果的<em class="nq">修改</em>而增加。当失败次数达到阈值时，断路器断开。</p><figure class="nr ns nt nu gt ju"><div class="bz fp l di"><div class="or os l"/></div><figcaption class="ot ou gj gh gi ov ow bd b be z dk translated">CallIfClosed</figcaption></figure><p id="0c16" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">刀闸打开</strong></p><p id="7f88" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当断路器打开时，<em class="nq"> callIfOpen </em>方法<em class="nq"> </em>检查断路器打开后是否经过了特定时间。经过一段特定时间后，表示断路器处于半开状态，并且<em class="nq">主体</em>处于<em class="nq">方式</em>和<em class="nq">方式</em>方式<em class="nq">。</em>否则<em class="nq">、</em>断路器将保持打开，并立即返回错误。</p><figure class="nr ns nt nu gt ju"><div class="bz fp l di"><div class="or os l"/></div><figcaption class="ot ou gj gh gi ov ow bd b be z dk translated">卡利福彭</figcaption></figure><p id="56de" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">断路器半开</strong></p><p id="066a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当断路器半开时，<em class="nq"> canaryCall </em>方法<em class="nq"> </em>试图执行<em class="nq">体。</em>如果执行成功，断路器将再次闭合。</p><figure class="nr ns nt nu gt ju"><div class="bz fp l di"><div class="or os l"/></div><figcaption class="ot ou gj gh gi ov ow bd b be z dk translated">CanaryCall</figcaption></figure><h2 id="513f" class="oa ma it bd mb og oh dn mf oi oj dp mj km ok ol mn kq om on mr ku oo op mv oq bi translated">运行断路器</h2><p id="adfa" class="pw-post-body-paragraph kb kc it kd b ke mx kg kh ki my kk kl km mz ko kp kq na ks kt ku nb kw kx ky im bi translated">下面这个例子展示了如何使用<em class="nq">断路器</em>和<em class="nq"/><a class="ae kz" href="https://github.com/http4s/http4s" rel="noopener ugc nofollow" target="_blank"><em class="nq">http4s</em></a><em class="nq">。http4s也依赖于Cats效果，所以使用这个库和<em class="nq"> CircuitBreaker很容易。</em>在下面的例子中，一个<em class="nq">断路器</em>对象被共享。你也可以在每个上下文中通过调用<em class="nq"> flatMap </em>来单独使用<em class="nq">一个断路器</em>对象，就像我之前解释的那样。</em></p><figure class="nr ns nt nu gt ju"><div class="bz fp l di"><div class="or os l"/></div><figcaption class="ot ou gj gh gi ov ow bd b be z dk translated">带http4s的断路器</figcaption></figure><p id="20ff" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">而且，你可以通过我实现的测试代码看到<em class="nq">断路器</em>对象的行为。这个测试代码是用<a class="ae kz" href="https://cb372.github.io/cats-retry/docs/" rel="noopener ugc nofollow" target="_blank"> cats-retry </a>实现的，实现了一个重试机制，这是一个用于重试可能失败的动作的库。我在之前的文章中已经写了关于这个库的内容。</p><p id="077e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面的代码是测试代码中的一个测试用例。证明执行失败一次后断路器打开，定义为<em class="nq"> maxBreakerFailures。</em></p><figure class="nr ns nt nu gt ju"><div class="bz fp l di"><div class="or os l"/></div><figcaption class="ot ou gj gh gi ov ow bd b be z dk translated">电路断路器测试</figcaption></figure></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><h1 id="1a7e" class="lz ma it bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">结论</h1><p id="7c0c" class="pw-post-body-paragraph kb kc it kd b ke mx kg kh ki my kk kl km mz ko kp kq na ks kt ku nb kw kx ky im bi translated">很多库比如doobie，http4s都在内部使用Cats效应。所以通过使用这些库，你可以用函数式编程实现整个系统。另外，在自己实现一个模块方面，这个库非常有用，因为它提供了并发编程、状态管理等强大的模块。</p><p id="9347" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我的代码有问题，或者你有另一种实现具有猫效应的断路器的方法，请通过<a class="ae kz" href="mailto:hirokifujino0108@gmai.com?subject=Circuit Breaker with Cats Effect Feedback" rel="noopener ugc nofollow" target="_blank">hirokifujino0108@gmail.com</a>告诉我。</p><p id="24f2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">感谢您的阅读！</p><h2 id="e505" class="oa ma it bd mb og oh dn mf oi oj dp mj km ok ol mn kq om on mr ku oo op mv oq bi translated"><strong class="ak">参考文献</strong></h2><ul class=""><li id="fbd4" class="nc nd it kd b ke mx ki my km pd kq pe ku pf ky nh ni nj nk bi translated"><a class="ae kz" href="https://vimeo.com/294736344" rel="noopener ugc nofollow" target="_blank">Scala Italy 2018—Fabio la Bella—纯FP中的共享状态:当一个状态单子不会做</a></li><li id="0950" class="nc nd it kd b ke pg ki ph km pi kq pj ku pk ky nh ni nj nk bi translated"><a class="ae kz" rel="noopener ugc nofollow" target="_blank" href="/circuit-breaker-in-a-functional-world-9c555c8e9527">功能世界中的断路器</a></li><li id="af45" class="nc nd it kd b ke pg ki ph km pi kq pj ku pk ky nh ni nj nk bi translated"><a class="ae kz" href="https://typelevel.org/blog/2018/06/07/shared-state-in-fp.html" rel="noopener ugc nofollow" target="_blank">功能编程中的共享状态</a></li></ul></div></div>    
</body>
</html>