# 对 Array.slice()函数的深入探究

> 原文：<https://levelup.gitconnected.com/an-in-depth-exploration-of-the-array-slice-function-e5b9b5e3583b>

## Javascript 数组方法完全指南

![](img/943d1dfdf27af0448ac30c8da0aaf559.png)

布莱克·康纳利在 [Unsplash](https://unsplash.com/s/photos/javascript-code?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上拍摄的照片

在过去的几年中，Javascript `Array`全局对象中增加了许多有用的函数，当开发人员编写使用数组的代码时，这些函数为他们提供了各种各样的选择。这些函数提供了许多优势，其中最值得一提的是，虽然过去开发人员必须实现自己的复杂逻辑来执行各种数组操作，但现在所有这些新函数都消除了对这种自主实现的需求。本文将探讨的有用函数之一是`[slice()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice)`函数。

# 功能概述

`slice()`函数提供了将一个数组中的一部分条目浅层复制到一个全新的数组中，并在函数完成时返回这个新数组的能力。因为这个函数产生了一个全新的数组，所以一旦这个函数完成了操作，原来的数组将保持不变。在开始操作之前，不需要采取进一步的预防措施来维护原始阵列的拷贝。

`slice()`函数最多带两个参数，都是从零开始的索引，都是*可选的*。如果这些参数中的任何一个有负值，它们将从数组的末尾开始计数，而不是从开始计数。这意味着参数值`-3`实际上会导致该参数值`3`小于数组长度(`Array.length + -3`)。

第一个参数是`begin`参数。该参数是数组项将被复制的起始索引，被复制的项 ***将*** 包括该索引处的项。因为这个参数是可选的，所以它有一个默认值`0`，如果没有指定这个参数，数组项将从数组的开头开始复制。第二个参数是`end`参数。该参数是数组项将被复制到的结束索引，被复制的项 ***将不包括该索引处的项。因为这个参数是可选的，它有一个数组长度的默认值(`Array.length`)，如果没有指定这个参数，数组项将被复制到数组的最后一个索引。***

# 没有参数

在讨论了一般的函数行为之后，让我们来看看`slice()`函数在实践中是如何工作的一些例子。以下示例演示了未指定参数值的情况:

```
var array1 = [**'abc', 'def', 'ghi', 'jkl', 'mno'**];
var array2 = array1.slice();
// array2: [**'abc', 'def', 'ghi', 'jkl', 'mno'**]
```

调用`slice()`函数时没有参数值。考虑到可选参数默认值，该函数调用与`slice(0, 5)`相同。这意味着从数组开头到结尾的所有数组项都被复制到新数组中。以这种方式使用`slice()`函数提供了制作整个原始数组的全新副本的能力，如果需要这样的功能的话。有许多不同的方法可以达到这样的结果，不带参数调用`slice()`函数只是其中一种可行的方法。

# 正开始

以下示例演示了仅指定正的`begin`参数值的情况:

```
var array1 = ['abc', 'def', **'ghi', 'jkl', 'mno'**];
var array2 = array1.slice(2);
// array2: [**'ghi', 'jkl', 'mno'**]
```

仅使用`2`的`begin`参数值调用`slice()`函数。考虑到可选参数默认值，该函数调用与`slice(2, 5)`相同。由于从索引`2`开始，数组中只剩下三个索引位置，因此只有数组中的最后三项被复制到新数组中。

# 负开始

以下示例演示了仅指定负`begin`参数值的情况:

```
var array1 = ['abc', 'def', 'ghi', **'jkl', 'mno'**];
var array2 = array1.slice(-2);
// array2: [**'jkl', 'mno'**]
```

仅使用`-2`的`begin`参数值调用`slice()`函数。考虑到可选参数默认值以及如何计算负参数值，该函数调用与`slice(3, 5)`相同。因为从索引`3`开始，数组中只剩下两个索引位置，所以只有数组中的最后两项被复制到新数组中。

# 积极的开始，积极的结束

以下示例演示了指定正`begin`和`end`参数值的情况:

```
var array1 = ['abc', **'def', 'ghi'**, 'jkl', 'mno'];
var array2 = array1.slice(1, 3);
// array2: [**'def', 'ghi'**]
```

使用参数值为`1`的`begin`和参数值为`3`的`end`调用`slice()`函数。由于要复制的数组项的边界从索引`1`开始，到索引`2`结束，所以只有两个数组项被复制到新数组中。当指定一个正的`end`参数值时要记住的一件重要事情是，如果该值大于数组的长度，那么`slice()`函数将忽略`end`参数值，而是将项目复制到数组的末尾。

# 正开始，负结束

以下示例演示了指定正`begin`参数值和负`end`参数值的情况:

```
var array1 = ['abc', 'def', 'ghi', 'jkl', 'mno'];
var array2 = array1.slice(2, -3);
// array2: []
```

使用`2`的`begin`参数值和`-3`的`end`参数值调用`slice()`函数。考虑到负参数值如何赋值，这个函数调用与`slice(2, 2)`相同。这个代码样本是我们在本文中看到的第一个例子，其中`begin`和`end`参数值是相同的。由于这两个参数值引用相同的索引，实际上没有数组项被复制到新数组中，导致函数完成时返回一个空数组。

当使用`slice()`函数时，返回空数组的相同行为将发生在以下任何情况下:`begin`和`end`参数引用相同的索引；`end`参数指数落在`begin`参数指数之前；`begin`参数值等于或大于数组长度；并且`end`参数值等于或小于`0`。

# 经验教训

从这篇关于`slice()`函数的文章中可以学到一些东西。要记住的第一件事是,`slice()`函数不会以任何方式改变原始数组，所以在使用该函数之前没有必要维护它的状态。唯一会被`slice()`函数改变的数组是该函数完成后返回的全新数组。

关于`slice()`函数要记住的第二件也是最重要的事情是它如何复制原始数组中包含的项目。对于像字符串、数字和布尔这样的原语数组项，`slice()`函数会将它们的值复制到新数组中。这意味着对原始数组或新数组中复制的字符串、数字或布尔值所做的任何更改都不会影响另一个数组。以下示例展示了这一功能的实际应用:

```
var array1 = ['abc', 'def', 'ghi'];
var array2 = array1.slice();// array1: ['abc', 'def', 'ghi']
// array2: ['abc', 'def', 'ghi']array2[2] = 'cba';
array2[1] = 'fed';
array2[0] = 'ihg';// array1: ['abc', 'def', 'ghi']
// array2: ['ihg', 'fed', 'cba']
```

对由`slice()`函数产生的新数组中的原始值进行改变不会导致对原始数组中的原始值进行任何改变。只有新数组将反映任何原始值的变化。

与处理原语的方式不同，`slice()`函数处理对象引用的方式不同。对于作为对象引用的数组项，`slice()`函数会将这些引用复制到新数组中。这意味着从原始数组复制到新数组的任何对象引用都将引用完全相同的对象。如果对被引用的对象进行了任何更改，这些更改将在原始数组和新数组中都可以看到。以下示例展示了这一功能的实际应用:

```
var objectRef = { abc: 123 };
var array1 = [ objectRef ];
var array2 = array1.slice();// array1: [{ abc: 123 }]
// array2: [{ abc: 123 }]objectRef.def = 456;// array1: [{ abc: 123, def: 456 }]
// array2: [{ abc: 123, def: 456 }]
```

对由`slice()`函数产生的新数组中引用的对象进行更改也会导致这些更改反映在原始数组中。原始数组和新数组都将反映所做的任何引用对象更改。

使用`slice()`函数时要记住的最后一件事是，由`slice()`函数产生的原始数组和新数组就它们包含的项目列表而言是真正完全独立的数组。这意味着在任一数组中添加或删除项不会影响另一数组。以下示例展示了这一功能的实际应用:

```
var array1 = ['abc', 'def', 'ghi'];
var array2 = array1.slice();// array1: ['abc', 'def', 'ghi']
// array2: ['abc', 'def', 'ghi']array2.shift();
array2.push('jkl')// array1: ['abc', 'def', 'ghi']
// array2: ['def', 'ghi', 'jkl']
```

由`slice()`函数产生的新数组首先被改变，这样数组中的第一项被删除，所有其他项使用`shift()`函数下移一个索引。第二，使用`push()`函数将一个新项目添加到新数组的末尾。原始数组保持不变，而新数组反映了这些变化。

# 结论

非常感谢您阅读这篇文章。我希望这次对 Javascript `Array`全局对象上的`slice()`函数的探索能够提供一些信息，并且我希望在获得一些关于它的知识之后，您能够在自己的代码中很好地使用它。如果您对它的工作方式还有任何疑问，我鼓励您参考下面的资源链接，以获得关于`slice()`函数的所有信息。请在将来停下来阅读更多关于 Javascript `Array`全局对象上有趣且有用的函数的文章。

# 资源

[Javascript Array.slice()函数](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice)