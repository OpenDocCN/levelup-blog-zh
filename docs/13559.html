<html>
<head>
<title>Improving React Testing Library Tests</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">改进React测试库测试</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/improving-react-testing-library-tests-35ea832178?source=collection_archive---------19-----------------------#2022-09-15">https://levelup.gitconnected.com/improving-react-testing-library-tests-35ea832178?source=collection_archive---------19-----------------------#2022-09-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/7f3437bc508d834e32629801c2387f32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*xFydiaOBdvAsqeB2.jpg"/></div></figure><p id="499c" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">React测试库 (RTL)成为测试React组件的事实上的标准。专注于从用户的角度进行测试，避免测试中的实现细节是其成功的主要原因。</p><p id="e615" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">正确编写的测试不仅可以帮助防止回归或错误代码，而且在RTL的情况下，还可以提高组件的可访问性和总体用户体验。在本帖中，我们将看到如何充分利用RTL测试。我将提供一个我认为的测试时的良好实践的集合，没有特定的重要性顺序。</p><h1 id="8284" class="kw kx it bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">编写烟雾测试</h1><p id="9722" class="pw-post-body-paragraph jx jy it jz b ka lu kc kd ke lv kg kh ki lw kk kl km lx ko kp kq ly ks kt ku im bi translated">有时，我们希望进行基本的健全性测试，以确保组件在渲染时不会损坏。假设我们有这个简单的组件:</p><figure class="lz ma mb mc gt ju"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="1b9e" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们可以通过这样的测试来检查它的渲染是否没有问题:</p><figure class="lz ma mb mc gt ju"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="53bd" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这对我们的目的很好，但是，我们没有充分利用RTL的力量。相反，我们可以这样做:</p><figure class="lz ma mb mc gt ju"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="ffd8" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">虽然这是一个非常简单的例子，但是有了这个微小的变化，我们不仅测试了组件在渲染过程中不会中断，而且测试了它有一个名为<code class="fe mf mg mh mi b">List of items</code>的header元素，可以被屏幕阅读器正确访问。</p><h1 id="f948" class="kw kx it bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">默认为<code class="fe mf mg mh mi b">*ByRole</code>查询</h1><p id="961e" class="pw-post-body-paragraph jx jy it jz b ka lu kc kd ke lv kg kh ki lw kk kl km lx ko kp kq ly ks kt ku im bi translated">RTL的强大优势之一是，通过正确的查询，我们不仅可以确保组件按预期工作，还可以确保它们是可访问的。那么，如何确定哪个查询是最好的呢？规则很简单——默认使用<code class="fe mf mg mh mi b">*ByRole</code>查询。像大多数规则一样，它也有例外，因为不是所有的HTML元素都有默认角色。HTML元素的默认角色列表可以在<a class="ae kv" href="https://www.w3.org/TR/html-aria/#docconformance" rel="noopener ugc nofollow" target="_blank">w3.org</a>找到。</p><p id="0593" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">让我们考虑以下表单组件，改编自<a class="ae kv" href="https://medium.com/p/3beb88eb467d" rel="noopener">之前的教程</a>:</p><figure class="lz ma mb mc gt ju"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="58f6" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们测试的方法是通过表单元素模拟输入数据，提交表单，然后验证<code class="fe mf mg mh mi b">saveData</code> prop是否收到了我们输入的数据。我们可以把它分成3个步骤:</p><ol class=""><li id="99d2" class="mj mk it jz b ka kb ke kf ki ml km mm kq mn ku mo mp mq mr bi translated">为我们要测试的字段输入文本(或单击复选框)</li><li id="638b" class="mj mk it jz b ka ms ke mt ki mu km mv kq mw ku mo mp mq mr bi translated">点击<code class="fe mf mg mh mi b">Sign up</code>按钮</li><li id="67bc" class="mj mk it jz b ka ms ke mt ki mu km mv kq mw ku mo mp mq mr bi translated">验证用我们输入的数据调用了<code class="fe mf mg mh mi b">saveData</code>。</li></ol><p id="89e0" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这个工作流正是用户与我们的表单交互的方式(除了他们可能不会以完全相同的方式检查保存的数据)。让我们从在第一个输入字段中输入姓名开始。我们看到它有一个<code class="fe mf mg mh mi b">Enter your name</code>占位符，为什么不使用它呢？</p><figure class="lz ma mb mc gt ju"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="7961" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这是可行的，但我们可以做得更好。首先，这可能会助长使用占位符文本作为标签的习惯，这不是它们的本意，也不被W3C WAI所鼓励。其次，我们在测试时并没有考虑到可访问性。相反，让我们尝试用<code class="fe mf mg mh mi b">getByRole</code>替换我们的查询。正如文档所说，我们可以通过<code class="fe mf mg mh mi b">textbox</code>角色匹配类型<code class="fe mf mg mh mi b">text</code>的输入，但是由于我们在表单中有多个文本框，我们需要比这更具体。幸运的是，查询接受了第二个参数，这是一个options对象，在这里我们可以使用<code class="fe mf mg mh mi b">name</code>属性缩小匹配范围。从<a class="ae kv" href="https://testing-library.com/docs/queries/byrole" rel="noopener ugc nofollow" target="_blank">文档</a>中我们可以看到，这里的<code class="fe mf mg mh mi b">name</code>并不是指输入的<code class="fe mf mg mh mi b">name</code>属性，而是它的<a class="ae kv" href="https://www.tpgi.com/what-is-an-accessible-name/" rel="noopener ugc nofollow" target="_blank">可访问名</a>。因此，对于输入，可访问名称通常是其标签的文本内容。在我们的表单中，名称输入有一个<code class="fe mf mg mh mi b">Name</code>标签，所以让我们使用它。</p><figure class="lz ma mb mc gt ju"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="21f7" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">运行测试时，我们得到一个错误:</p><pre class="lz ma mb mc gt mx mi my mz aw na bi"><span id="fe46" class="nb kx it mi b gy nc nd l ne nf">TestingLibraryElementError: Unable to find an accessible element with the role "textbox" and name "Name"</span></pre><p id="5697" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">下面的帮助文本显示我们的输入没有可访问的名称:</p><pre class="lz ma mb mc gt mx mi my mz aw na bi"><span id="3c25" class="nb kx it mi b gy nc nd l ne nf">Here are the accessible roles:</span><span id="2ffc" class="nb kx it mi b gy ng nd l ne nf">textbox: </span><span id="c853" class="nb kx it mi b gy ng nd l ne nf">Name "": <br/>&lt;input <br/>  id="name" <br/>  placeholder="Enter your name" <br/>/&gt;</span></pre><p id="df19" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们确实有一个输入的标签，那么为什么它不起作用呢？结果是标签需要与输入相关联。为此，标签应该有一个与相关输入的<code class="fe mf mg mh mi b">id</code>相匹配的<code class="fe mf mg mh mi b">for</code>属性。看起来我们的输入已经有了一个id，所以我们只需要给它添加<code class="fe mf mg mh mi b">for</code>(使用React时为<code class="fe mf mg mh mi b">htmlFor</code>)属性:</p><figure class="lz ma mb mc gt ju"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="e9d0" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">现在，输入与其标签正确关联，测试通过。这也为可访问性带来了重大改进。首先，当点击/轻敲标签时，焦点将被传递到相关联的输入。其次，也是最重要的，当输入被聚焦时，屏幕阅读器将读出标签，从而向用户提供一些关于输入的额外信息。这是一个很好的例子，通过切换到<code class="fe mf mg mh mi b">getByRole</code>，我们不仅提高了测试覆盖率，还为表单组件提供了有价值的可访问性改进。</p><p id="754f" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">如果我们再看一下测试，我们会看到<code class="fe mf mg mh mi b">getByText</code>查询被用于提交按钮。在我看来，<code class="fe mf mg mh mi b">*ByText</code>应该是最后一招(或者在<code class="fe mf mg mh mi b">*ByTestId</code>之前倒数第二招)，因为它们最容易坏掉。在我们的测试中，<code class="fe mf mg mh mi b">screen.getByText("Sign up")</code>会将元素与具有<code class="fe mf mg mh mi b">Sign up</code>文本内容的文本节点进行匹配。如果我们稍后决定在同一页面上添加一个带有文本“注册”的段落，该元素也将被匹配，测试将中断，因为现在我们有不止一个匹配的元素。当我们使用一般的正则表达式而不是字符串<code class="fe mf mg mh mi b">screen.getByText(/Sign up/i)</code>进行文本匹配时，情况会变得更糟。这将匹配任何出现的字符串“sign up ”,不管大小写，即使它是一个更长句子的一部分。当然，我们可以修改正则表达式以确保它只匹配这个特定的字符串，但是相反，我们可以使用一个更精确的查询，同时验证我们的表单在<code class="fe mf mg mh mi b">getByRole</code>查询的帮助下是可访问的。在这种情况下，查询将是<code class="fe mf mg mh mi b">screen.getByRole("button", { name: "Sign up" });</code>，这次可访问的名称是按钮的实际文本内容。注意，如果我们将<code class="fe mf mg mh mi b">aria-label</code>添加到按钮上，那么可访问的名称将会是那个<code class="fe mf mg mh mi b">aria-label</code>的文本内容。最终，更新后的测试如下所示:</p><figure class="lz ma mb mc gt ju"><div class="bz fp l di"><div class="md me l"/></div></figure><h1 id="dd9e" class="kw kx it bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">输入元素的<code class="fe mf mg mh mi b">*ByRole</code>与<code class="fe mf mg mh mi b">*ByLabelText</code></h1><p id="8137" class="pw-post-body-paragraph jx jy it jz b ka lu kc kd ke lv kg kh ki lw kk kl km lx ko kp kq ly ks kt ku im bi translated">对输入元素使用<code class="fe mf mg mh mi b">*ByRole</code>查询的目的是通过相关标签匹配输入。使用<code class="fe mf mg mh mi b">*ByLabelText</code>查询不是更容易吗，因为它们最终实现了相同的目标，而且语法更简单。我不认为使用一个查询和使用另一个查询有很大的区别，然而，在匹配元素时，<code class="fe mf mg mh mi b">*ByRole</code>比<a class="ae kv" href="https://testing-library.com/docs/queries/bylabeltext#name" rel="noopener ugc nofollow" target="_blank">更健壮</a>，如果你从<code class="fe mf mg mh mi b">&lt;label&gt;</code>切换到<code class="fe mf mg mh mi b">aria-label</code>，它仍然会工作。另一方面，并不是所有类型的输入元素都有默认角色，所以例如对于密码输入，我们将使用<code class="fe mf mg mh mi b">*ByLabelText</code>查询。</p><h1 id="81f2" class="kw kx it bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">使用<code class="fe mf mg mh mi b">userEvent</code>代替<code class="fe mf mg mh mi b">fireEvent</code></h1><p id="e2f7" class="pw-post-body-paragraph jx jy it jz b ka lu kc kd ke lv kg kh ki lw kk kl km lx ko kp kq ly ks kt ku im bi translated">在对<code class="fe mf mg mh mi b">Form</code>组件的测试中，我们使用内置的<code class="fe mf mg mh mi b">fireEvent</code>来调度DOM事件。虽然这在很多情况下都有效，<code class="fe mf mg mh mi b">fireEvent</code>只是一个在<code class="fe mf mg mh mi b">dispatchEvent</code> API之上的轻量级包装器，并不模拟完整的用户交互。另一方面，<code class="fe mf mg mh mi b">userEvent</code>像用户在浏览器中一样操作DOM，提供了更可靠的测试体验。它的工作方式也更符合RTL的哲学，而且语法更清晰。比较用<code class="fe mf mg mh mi b">userEvent</code>改写的<code class="fe mf mg mh mi b">Form</code>的测试:</p><figure class="lz ma mb mc gt ju"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="72a1" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">所有的方法都是异步的，所以我们需要稍微调整一下测试。此外，由于它是一个单独的包，需要通过<code class="fe mf mg mh mi b">npm i -D @testing-library/user-event</code>安装。请注意，在未来版本中，您将需要通过<code class="fe mf mg mh mi b">const user = userEvent.setup()</code>设置事件，并从<code class="fe mf mg mh mi b">user</code>调用它们。关于<code class="fe mf mg mh mi b">userEvent</code>更深入的介绍可以在<a class="ae kv" href="https://testing-library.com/docs/user-event/intro" rel="noopener ugc nofollow" target="_blank"> RTL文档</a>中找到。</p><h1 id="c1a7" class="kw kx it bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">使用<code class="fe mf mg mh mi b">find*</code>查询代替<code class="fe mf mg mh mi b">waitFor</code></h1><p id="acda" class="pw-post-body-paragraph jx jy it jz b ka lu kc kd ke lv kg kh ki lw kk kl km lx ko kp kq ly ks kt ku im bi translated">经常有这样的情况，当我们试图匹配的元素在初始渲染时不可用，例如，当我们首先从API获取项目，然后显示它们。在这种情况下，我们需要组件在查询之前完成所有的呈现周期。作为一个例子，让我们修改<code class="fe mf mg mh mi b">ListPage</code>组件来等待项目列表异步加载:</p><figure class="lz ma mb mc gt ju"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="ab38" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">该组件的当前测试版本将不再工作，因为当调用<code class="fe mf mg mh mi b">screen.getByRole</code>查询时，仅显示加载文本。为了等待组件完成加载，我们可以使用<code class="fe mf mg mh mi b">waitFor</code>助手:</p><figure class="lz ma mb mc gt ju"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="7741" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这是可行的，但是有一个内置异步行为的查询类型及其<code class="fe mf mg mh mi b">findBy*</code>查询，它是<code class="fe mf mg mh mi b">waitFor</code>之上的一个包装器。有了它，测试变得更具可读性:</p><figure class="lz ma mb mc gt ju"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="71f9" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">应该注意的是，每个测试块一个<code class="fe mf mg mh mi b">await</code>调用通常就足够了，因为那时所有的异步动作都已经解决了。所以在上面的例子中，如果我们想额外测试我们在<code class="fe mf mg mh mi b">ItemList</code>中有4个项目，我们不需要使用异步<code class="fe mf mg mh mi b">findBy*</code>，而是可以求助于<code class="fe mf mg mh mi b">getBy*</code>。</p><h1 id="c554" class="kw kx it bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">测试元素的消失</h1><p id="df02" class="pw-post-body-paragraph jx jy it jz b ka lu kc kd ke lv kg kh ki lw kk kl km lx ko kp kq ly ks kt ku im bi translated">这是一个非常极端的情况，但是有时我们想要测试一个元素，它之前存在，在一些异步操作之后已经从DOM中移除了。RTL有一个方便的助手。例如，在<code class="fe mf mg mh mi b">ListItem</code>组件中，我们可能希望等待<code class="fe mf mg mh mi b">Loading...</code>文本被移除，而不是列表标题出现:</p><figure class="lz ma mb mc gt ju"><div class="bz fp l di"><div class="md me l"/></div></figure><h1 id="3a6f" class="kw kx it bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">使用RTL游乐场</h1><p id="4574" class="pw-post-body-paragraph jx jy it jz b ka lu kc kd ke lv kg kh ki lw kk kl km lx ko kp kq ly ks kt ku im bi translated">如果你对某些元素的正确查询有困难，<a class="ae kv" href="https://testing-playground.com/" rel="noopener ugc nofollow" target="_blank"> RTL游乐场</a>会给你很大的帮助。只需粘贴正在测试的组件的HTML，它会提供方便的建议，告诉你哪些查询适合每个元素。这是非常有价值的，特别是对于复杂的组件，它可能并不总是很明显，哪个查询是最好的使用。</p></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><p id="1100" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><em class="no">原载于</em><a class="ae kv" href="https://claritydev.net/blog/improving-react-testing-library-tests/" rel="noopener ugc nofollow" target="_blank"><em class="no"/></a><em class="no">。</em></p></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><h1 id="f904" class="kw kx it bd ky kz np lb lc ld nq lf lg lh nr lj lk ll ns ln lo lp nt lr ls lt bi translated">分级编码</h1><p id="fc90" class="pw-post-body-paragraph jx jy it jz b ka lu kc kd ke lv kg kh ki lw kk kl km lx ko kp kq ly ks kt ku im bi translated">感谢您成为我们社区的一员！在你离开之前:</p><ul class=""><li id="16d7" class="mj mk it jz b ka kb ke kf ki ml km mm kq mn ku nu mp mq mr bi translated">👏为故事鼓掌，跟着作者走👉</li><li id="4f0e" class="mj mk it jz b ka ms ke mt ki mu km mv kq mw ku nu mp mq mr bi translated">📰查看<a class="ae kv" href="https://levelup.gitconnected.com/?utm_source=pub&amp;utm_medium=post" rel="noopener ugc nofollow" target="_blank">升级编码出版物</a>中的更多内容</li><li id="9501" class="mj mk it jz b ka ms ke mt ki mu km mv kq mw ku nu mp mq mr bi translated">🔔关注我们:<a class="ae kv" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">Twitter</a>|<a class="ae kv" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>|<a class="ae kv" href="https://newsletter.levelup.dev" rel="noopener ugc nofollow" target="_blank">时事通讯</a></li></ul><p id="5006" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">🚀👉<a class="ae kv" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="jz iu">加入升级人才集体，找到一份神奇的工作</strong> </a></p></div></div>    
</body>
</html>