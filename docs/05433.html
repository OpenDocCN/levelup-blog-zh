<html>
<head>
<title>Implementation of Thread-Safe Dictionary Data Structure in Golang</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">线程安全字典数据结构在Golang中的实现</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/implementation-of-thread-safe-dictionary-data-structure-in-golang-2bcb235fd9e4?source=collection_archive---------2-----------------------#2020-08-28">https://levelup.gitconnected.com/implementation-of-thread-safe-dictionary-data-structure-in-golang-2bcb235fd9e4?source=collection_archive---------2-----------------------#2020-08-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/></div><div class="ab cl jn jo hu jp" role="separator"><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js jt"/><span class="jq bw bk jr js"/></div><div class="ij ik il im in"><figure class="jv jw jx jy gt jz gh gi paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="gh gi ju"><img src="../Images/d45b2dc87181749b0a0338b43d3b8a7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ioaPo1x7Ztz1b2JOuqShgA.jpeg"/></div></div><figcaption class="kg kh gj gh gi ki kj bd b be z dk translated">图片来自<a class="ae kk" href="http://unsplash.com" rel="noopener ugc nofollow" target="_blank">unsplash.com</a></figcaption></figure><p id="13d7" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">上周，我在做一个需要处理Golang并发的作业。我正在处理一些被并发用户请求修改的内存数据。我需要控制这些内存数据的读写操作。</p><p id="c4b0" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这里我解释一下我是如何使用<strong class="kn ir"> RWMutex </strong>来处理这个问题的。我举了一个实现内存字典数据结构的例子来阐明这个概念。</p><p id="d85f" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><strong class="kn ir">注意:<em class="lj"> </em> </strong> <em class="lj">我希望你们对golang语法和原始类型有一个初级的理解，以理解源代码。</em></p><p id="d296" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">字典与一组关键字相关联，每个关键字都有一个相关联的值。当提供一个键时，字典将简单地返回相关的值。Go通过其内置的<strong class="kn ir"> <em class="lj">映射</em> </strong>类型提供了一个非常方便的字典实现。</p><figure class="jv jw jx jy gt jz gh gi paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="gh gi lk"><img src="../Images/a296e6ec812536b041321cb13a0af4bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2MxVuJWW9W3YCfXKkikQKA.png"/></div></div><figcaption class="kg kh gj gh gi ki kj bd b be z dk translated">字典结构</figcaption></figure><p id="160c" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我设计了以下结构来表示本文中所有代码片段的字典对象。</p><figure class="jv jw jx jy gt jz"><div class="bz fp l di"><div class="ll lm l"/></div><figcaption class="kg kh gj gh gi ki kj bd b be z dk translated">清单1.1</figcaption></figure><p id="fe99" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">它保存一个名为<strong class="kn ir"> <em class="lj">条目</em> </strong>的<em class="lj">映射</em>来保存所有的<strong class="kn ir">键值</strong>对数据。定义<em class="lj"> IKey </em>和<em class="lj"> IValue </em>类型的目的是使其通用。<strong class="kn ir"> <em class="lj">锁定<strong class="kn ir"> <em class="lj">类型的</em> </strong>同步。RWMutex </em> </strong>与<em class="lj"> struct </em>关联，控制字典上的读写操作。<strong class="kn ir"> <em class="lj"> RWMutex </em> </strong>公开了读者使用的两个方法(<em class="lj"> RLock </em>和<em class="lj"> RUnlock </em>)和两个专用编写器(<em class="lj"> Lock </em>和<em class="lj"> Unlock </em>)。</p><p id="57a0" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><strong class="kn ir"> Lock(): </strong>通过获取锁，一次只能有一个goroutine读/写。</p><p id="857a" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><strong class="kn ir"> RLock() </strong>:通过获取锁，多个goroutines可以一次读(不写)。</p><p id="685f" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">下面的操作说明了在字典数据结构上实现操作时这些方法的使用。</p><h2 id="6ebe" class="ln lo iq bd lp lq lr dn ls lt lu dp lv kw lw lx ly la lz ma mb le mc md me mf bi translated">向字典中添加一个键值对。</h2><figure class="jv jw jx jy gt jz"><div class="bz fp l di"><div class="ll lm l"/></div><figcaption class="kg kh gj gh gi ki kj bd b be z dk translated">清单1.2</figcaption></figure><p id="4b41" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在<strong class="kn ir">项目中插入新项目之前，字典对象使用<strong class="kn ir"><em class="lj">dict . lock . lock()</em></strong>获取其锁。</strong>避免脏读操作。成功插入<strong class="kn ir">项目</strong>后<em class="lj">锁</em>被释放。锁定释放是通过<strong class="kn ir"> <em class="lj"> defer dict.lock.Unlock()实现的。</em> </strong></p><p id="feaf" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">如果一个请求已经获得了<strong class="kn ir"><em class="lj"/></strong>，那么另一个请求想要获得<strong class="kn ir"> <em class="lj"> RLock() </em> </strong>就必须等到第一个请求释放lock (Unlock())</p><h2 id="8b57" class="ln lo iq bd lp lq lr dn ls lt lu dp lv kw lw lx ly la lz ma mb le mc md me mf bi translated"><strong class="ak">从字典中删除键值对</strong></h2><figure class="jv jw jx jy gt jz"><div class="bz fp l di"><div class="ll lm l"/></div><figcaption class="kg kh gj gh gi ki kj bd b be z dk translated">清单1.3</figcaption></figure><p id="d60d" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在从字典<strong class="kn ir">中删除一个条目之前，字典对象使用<strong class="kn ir"><em class="lj">dict . lock . lock()</em></strong>获取其锁。</strong>避免脏读操作。成功删除按键指定的项目后，<em class="lj">锁</em>被释放。解锁是通过<strong class="kn ir"> <em class="lj"> defer dict.lock.Unlock()实现的。</em> </strong></p><p id="b58e" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">从字典中删除一个条目被认为是写操作，因此用<strong class="kn ir"><em class="lj">Lock()</em>&amp;<em class="lj">Unlock()实现。</em> </strong></p><h2 id="e44e" class="ln lo iq bd lp lq lr dn ls lt lu dp lv kw lw lx ly la lz ma mb le mc md me mf bi translated">通过关键字从字典中获取一个条目。</h2><figure class="jv jw jx jy gt jz"><div class="bz fp l di"><div class="ll lm l"/></div><figcaption class="kg kh gj gh gi ki kj bd b be z dk translated">清单1.4</figcaption></figure><p id="df6b" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">需要强调的是，如果您同时做的唯一事情是读取共享数据，那么数据竞争就不是问题。为了获得用于写入的<strong class="kn ir"> <em class="lj">锁()</em> </strong>，必须等到<strong class="kn ir"> <em class="lj">运行锁()。</em> </strong></p><h2 id="e82b" class="ln lo iq bd lp lq lr dn ls lt lu dp lv kw lw lx ly la lz ma mb le mc md me mf bi translated">检查字典中是否有关键字。</h2><figure class="jv jw jx jy gt jz"><div class="bz fp l di"><div class="ll lm l"/></div><figcaption class="kg kh gj gh gi ki kj bd b be z dk translated">清单1.5</figcaption></figure><p id="37b4" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">检查该项是否存在于字典中被认为是读取操作，因此用<strong class="kn ir"> <em class="lj"> RLock() &amp; RUnlock()实现。</em> </strong></p><h2 id="3019" class="ln lo iq bd lp lq lr dn ls lt lu dp lv kw lw lx ly la lz ma mb le mc md me mf bi translated"><strong class="ak">从字典中删除所有元素。</strong></h2><figure class="jv jw jx jy gt jz"><div class="bz fp l di"><div class="ll lm l"/></div><figcaption class="kg kh gj gh gi ki kj bd b be z dk translated">清单1.6</figcaption></figure><p id="633b" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">从字典中删除所有条目被认为是写操作，因此用<strong class="kn ir"><em class="lj">Lock()&amp;Unlock()</em></strong>实现</p><h2 id="d328" class="ln lo iq bd lp lq lr dn ls lt lu dp lv kw lw lx ly la lz ma mb le mc md me mf bi translated"><strong class="ak">获取字典的大小。</strong></h2><figure class="jv jw jx jy gt jz"><div class="bz fp l di"><div class="ll lm l"/></div><figcaption class="kg kh gj gh gi ki kj bd b be z dk translated">清单1.7</figcaption></figure><p id="47fe" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">获取字典的长度被认为是读取操作，因此用<strong class="kn ir"> <em class="lj"> RLock() &amp; RUnlock()实现。</em>T55】</strong></p><h2 id="3695" class="ln lo iq bd lp lq lr dn ls lt lu dp lv kw lw lx ly la lz ma mb le mc md me mf bi translated">获取字典中所有键的一部分。</h2><figure class="jv jw jx jy gt jz"><div class="bz fp l di"><div class="ll lm l"/></div><figcaption class="kg kh gj gh gi ki kj bd b be z dk translated">清单1.8</figcaption></figure><p id="d314" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">检索字典中存在的所有键的片段被认为是读取操作，因此用<strong class="kn ir"> <em class="lj"> RLock() &amp; RUnlock()实现。</em> </strong></p><h2 id="13a6" class="ln lo iq bd lp lq lr dn ls lt lu dp lv kw lw lx ly la lz ma mb le mc md me mf bi translated">获取字典中所有值的一部分。</h2><figure class="jv jw jx jy gt jz"><div class="bz fp l di"><div class="ll lm l"/></div><figcaption class="kg kh gj gh gi ki kj bd b be z dk translated">清单1.9</figcaption></figure><p id="8b63" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">检索字典中存在的所有值的片段被认为是读取操作，因此用<strong class="kn ir"> <em class="lj"> RLock() &amp; RUnlock()实现。</em> </strong></p><p id="80ad" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">点击<a class="ae kk" href="https://play.golang.org/p/MGaKZCLGLv7" rel="noopener ugc nofollow" target="_blank"> <strong class="kn ir">此处</strong> </a>复习&amp;在golang操场上运行以上代码。</p><h2 id="c239" class="ln lo iq bd lp lq lr dn ls lt lu dp lv kw lw lx ly la lz ma mb le mc md me mf bi translated"><strong class="ak">结论</strong></h2><ul class=""><li id="81f5" class="mg mh iq kn b ko mi ks mj kw mk la ml le mm li mn mo mp mq bi translated">字典与一组关键字相关联，每个关键字都有一个相关联的值。当提供一个键时，字典将简单地返回相关的值。</li><li id="b467" class="mg mh iq kn b ko mr ks ms kw mt la mu le mv li mn mo mp mq bi translated">Go通过其内置的<em class="lj"> map </em>类型提供了一个非常方便的字典实现。默认情况下，映射不是线程安全的。</li><li id="cc95" class="mg mh iq kn b ko mr ks ms kw mt la mu le mv li mn mo mp mq bi translated">使用<em class="lj">映射</em>可以轻松实现字典数据结构，使用<strong class="kn ir"> RWMutex </strong>可以实现同步。</li></ul><p id="a295" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这都是为了现在…感谢您的阅读…..</p><p id="7712" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">@快乐编码……:)</p></div></div>    
</body>
</html>