<html>
<head>
<title>Flutter — Navigate with GoRouter</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">颤动-使用GoRouter导航</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/flutter-navigate-with-gorouter-691f58ee46bf?source=collection_archive---------0-----------------------#2022-11-18">https://levelup.gitconnected.com/flutter-navigate-with-gorouter-691f58ee46bf?source=collection_archive---------0-----------------------#2022-11-18</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><figure class="it iu gq gs iv iw gi gj paragraph-image"><div role="button" tabindex="0" class="ix iy di iz bf ja"><div class="gi gj is"><img src="../Images/180746250bc8cf809d37a3931066e4d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yl3oDkalUHEU5x0KWUk-JA.png"/></div></div><figcaption class="jd je gk gi gj jf jg bd b be z dk translated"><a class="ae jh" href="/@simbu/membership" rel="noopener ugc nofollow" target="_blank">加入媒体</a>查看我所有的<a class="ae jh" href="https://medium.com/@simbu/simbus-articles-d9b999b115a7" rel="noopener">文章</a>。</figcaption></figure><div class=""/><p id="a178" class="pw-post-body-paragraph kh ki jk kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">当我意识到我需要在没有被认证时自动重新路由到登录屏幕时，我已经完成了添加认证的工作。</p><p id="1ac0" class="pw-post-body-paragraph kh ki jk kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">在几次使用服务/事件添加这种功能的尝试失败后，我转向了路由和GoRouter，因为它可以基于应用程序状态处理重定向。</p><p id="ea06" class="pw-post-body-paragraph kh ki jk kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">它是最灵活、功能最丰富的路由选项，具有许多关键功能:</p><ul class=""><li id="9f29" class="lf lg jk kj b kk kl ko kp ks lh kw li la lj le lk ll lm ln bi translated">Web查询参数访问，与浏览器历史API集成</li><li id="4b47" class="lf lg jk kj b kk lo ko lp ks lq kw lr la ls le lk ll lm ln bi translated">深度链接—在iOS和Android上通过URL显示屏幕</li><li id="380d" class="lf lg jk kj b kk lo ko lp ks lq kw lr la ls le lk ll lm ln bi translated">过渡动画</li><li id="d2db" class="lf lg jk kj b kk lo ko lp ks lq kw lr la ls le lk ll lm ln bi translated">重定向—状态更改的链接路由</li><li id="c626" class="lf lg jk kj b kk lo ko lp ks lq kw lr la ls le lk ll lm ln bi translated">命名路线</li><li id="48eb" class="lf lg jk kj b kk lo ko lp ks lq kw lr la ls le lk ll lm ln bi translated">错误处理MaterialApp &amp; CupertinoApp的默认屏幕</li></ul><h2 id="02f8" class="lt lu jk bd lv lw lx dn ly lz ma dp mb ks mc md me kw mf mg mh la mi mj mk ml bi translated">哒哒</h2><p id="34ce" class="pw-post-body-paragraph kh ki jk kj b kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la mq lc ld le in bi translated">我现在在应用程序启动时注册路线:</p><pre class="mr ms mt mu gu mv mw mx my aw mz bi"><span id="fc1a" class="lt lu jk mw b gz na nb l nc nd">var routeRegistry = ref.read(routeRegistryProvider);<br/><br/>routeRegistry.add(ARoute("Home", "Landing Page", "/", const LayoutSelector()));<br/><br/>routeRegistry.add(ARoute("Login", "Login Screen", "/login", const Login()));</span></pre><figure class="mr ms mt mu gu iw gi gj paragraph-image"><div class="ab gv cl ne"><img src="../Images/6c8c809036c84a2d1988a4a0ffb19c86.png" data-original-src="https://miro.medium.com/v2/format:webp/1*0nVbdDYUcT9RJ6ex81IR6w.png"/></div><figcaption class="jd je gk gi gj jf jg bd b be z dk translated">RouteRegistry单元测试</figcaption></figure><p id="717c" class="pw-post-body-paragraph kh ki jk kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">并用新的适配器routes或RouterAdapter将它们连接起来:</p><pre class="mr ms mt mu gu mv mw mx my aw mz bi"><span id="a302" class="lt lu jk mw b gz na nb l nc nd">CupertinoApp cupertinoApp(BuildContext context) {<br/>  var routeModels = ref.watch(routeRegistryProvider).routeList;<br/>  return CupertinoApp.router(<br/>    title: "Prologue",<br/>    theme: ref.watch(themeProvider).cupertinoThemeData,<br/>    routerConfig: RoutesToGoRouterAdapter(routeModels, "/", redirect: routeRedirectPolicy).goRouter,<br/>  );<br/>}</span></pre><figure class="mr ms mt mu gu iw gi gj paragraph-image"><div class="ab gv cl ne"><img src="../Images/92e003f48155a43aface2fc94ad4de76.png" data-original-src="https://miro.medium.com/v2/format:webp/1*8vp4iftN2lLWhpWsqVVfgQ.png"/></div><figcaption class="jd je gk gi gj jf jg bd b be z dk translated">RoutesToGoRouterAdapter单元测试</figcaption></figure><p id="73f5" class="pw-post-body-paragraph kh ki jk kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">重定向配置为对IsAuthenticated标志中的状态更改做出反应，并在未通过身份验证时重定向到登录屏幕:</p><pre class="mr ms mt mu gu mv mw mx my aw mz bi"><span id="2e78" class="lt lu jk mw b gz na nb l nc nd">FutureOr&lt;String?&gt; routeRedirectPolicy(context, state) {<br/>  if (ref.watch(authenticationProvider).isAuthenticated)<br/>  {<br/>    return null;<br/>  }<br/>  var loginRoutePath = "/login";<br/>  ref.watch(eventStoreProvider).bus.fire(Navigated(loginRoutePath));<br/>  return loginRoutePath;<br/>}</span></pre><h2 id="7662" class="lt lu jk bd lv lw lx dn ly lz ma dp mb ks mc md me kw mf mg mh la mi mj mk ml bi translated">经验值</h2><h2 id="48c2" class="lt lu jk bd lv lw lx dn ly lz ma dp mb ks mc md me kw mf mg mh la mi mj mk ml bi translated">goro outer</h2><p id="6456" class="pw-post-body-paragraph kh ki jk kj b kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la mq lc ld le in bi translated">我在BuildContext中添加了一些助手扩展作为语法糖:</p><pre class="mr ms mt mu gu mv mw mx my aw mz bi"><span id="a886" class="lt lu jk mw b gz na nb l nc nd">// Usage<br/>// context.navPush("/login")   Go Fwd (Add to stack)<br/>// context.navGo("/login").    Replace stack<br/>// context.pop()               Go back (Remove from stack)<br/>extension GoRouterExtension on BuildContext {<br/>  void navPush(String routeName){<br/>    GoRouter.of(this).push(routeName);<br/>  }<br/><br/>  void navGo(String routeName){<br/>    GoRouter.of(this).go(routeName);<br/>  }<br/><br/>  void navPop(){<br/>    GoRouter.of(this).pop();<br/>  }<br/>}</span></pre><p id="0e50" class="pw-post-body-paragraph kh ki jk kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">小部件中的路由需要在响应UI动作(如按钮点击)时发生，而不是在为显示而构建小部件时发生。</p><p id="0b49" class="pw-post-body-paragraph kh ki jk kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">在第一次尝试重定向到登录屏幕时，我将代码添加到小部件构建方法中:</p><pre class="mr ms mt mu gu mv mw mx my aw mz bi"><span id="c572" class="lt lu jk mw b gz na nb l nc nd">@override<br/>  Widget build(BuildContext context, WidgetRef ref) {<br/>    <br/>    if (!ref.watch(authenticationProvider).isAuthenticated){<br/>      context.navPush("/login");<br/>    }</span></pre><p id="d6ac" class="pw-post-body-paragraph kh ki jk kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">我得到了这个错误:</p><figure class="mr ms mt mu gu iw gi gj paragraph-image"><div class="ab gv cl ne"><img src="../Images/8dd0bd58d24dbd7ee393506db37207d8.png" data-original-src="https://miro.medium.com/v2/format:webp/1*4Omd44s5iRXTsIi7cmohGQ.png"/></div></figure><p id="4ff9" class="pw-post-body-paragraph kh ki jk kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">这是有意义的，除非无效的UI被构建，否则状态不会改变，否则我们会冒循环的风险。</p><p id="e5d0" class="pw-post-body-paragraph kh ki jk kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">然后我发现了这个方法，这个方法有效，但并不理想:</p><pre class="mr ms mt mu gu mv mw mx my aw mz bi"><span id="18ff" class="lt lu jk mw b gz na nb l nc nd">WidgetsBinding.instance.addPostFrameCallback((_) {<br/>      if (!ref.watch(authenticationProvider).isAuthenticated) {<br/>        context.navPush("/login");<br/>      }<br/>    });</span></pre><p id="c82a" class="pw-post-body-paragraph kh ki jk kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">我发现处理它的最好方法是使用内置的GoRouter重定向:</p><pre class="mr ms mt mu gu mv mw mx my aw mz bi"><span id="6b6f" class="lt lu jk mw b gz na nb l nc nd">redirect: routeRedirectPolicy</span></pre><p id="40ff" class="pw-post-body-paragraph kh ki jk kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">其中，routeRedirectPolicy是一个函数，可以访问上下文、导航状态和Riverpod ref，如果不需要重定向，则返回重定向路由或null:</p><pre class="mr ms mt mu gu mv mw mx my aw mz bi"><span id="d135" class="lt lu jk mw b gz na nb l nc nd">FutureOr&lt;String?&gt; routeRedirectPolicy(context, state) {<br/>  if (ref.watch(authenticationProvider).isAuthenticated)<br/>  {<br/>    return null;<br/>  }<br/>  var loginRoutePath = "/login";<br/>  ref.watch(eventStoreProvider).bus.fire(Navigated(loginRoutePath));<br/>  return loginRoutePath;<br/>}</span></pre><p id="b8a3" class="pw-post-body-paragraph kh ki jk kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">通过可配置的路由重定向和错误处理，我现在完成了身份验证和数据访问，这样做的好处是减少了耦合，减少了小部件中的应用程序逻辑代码，并且避免了访问构建外部的上下文和导航的需要()。</p><h2 id="e860" class="lt lu jk bd lv lw lx dn ly lz ma dp mb ks mc md me kw mf mg mh la mi mj mk ml bi translated">链接</h2><ul class=""><li id="4458" class="lf lg jk kj b kk mm ko mn ks nf kw ng la nh le lk ll lm ln bi translated"><a class="ae jh" href="https://docs.flutter.dev/development/ui/navigation" rel="noopener ugc nofollow" target="_blank">颤振导航和路由</a></li><li id="4010" class="lf lg jk kj b kk lo ko lp ks lq kw lr la ls le lk ll lm ln bi translated"><a class="ae jh" href="https://blog.ishangavidusha.com/flutter-authentication-flow-with-go-router-and-provider" rel="noopener ugc nofollow" target="_blank">与Go路由器和提供商的颤振认证流程</a></li></ul></div></div>    
</body>
</html>