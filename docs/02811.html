<html>
<head>
<title>Implementing Base64 in Rust</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Rust中实现Base64</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/implementing-base64-in-rust-34ef6db1e73a?source=collection_archive---------16-----------------------#2020-04-05">https://levelup.gitconnected.com/implementing-base64-in-rust-34ef6db1e73a?source=collection_archive---------16-----------------------#2020-04-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/6a480a835320ca9dcb222d6b5e50551b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XYf4v-UAyphmPDYS"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">迈克·冯在<a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><div class=""/><p id="bbc1" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">几乎每个开发人员都以这样或那样的方式使用base64，但是这个算法实际上是如何工作的呢？对我来说，真正理解一个算法最简单的方法就是实现它。让我们开始吧。</p><p id="9352" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">base64算法本身是在RFC <a class="ae jg" href="https://tools.ietf.org/html/rfc4648" rel="noopener ugc nofollow" target="_blank"> 4648 </a>中定义的。它的想法非常简单:任何输入都可以被视为一个比特流。通常，这些位被分成字节，因此分成8个一组。Base64做同样的事情，除了它把比特分成6个一组。然后使用预定义的表格将每个值翻译成字符<code class="fe le lf lg lh b">a-z</code>、<code class="fe le lf lg lh b">A-Z</code>、<code class="fe le lf lg lh b">0-9</code>和<code class="fe le lf lg lh b">+</code>、<code class="fe le lf lg lh b">/</code>。另外，<code class="fe le lf lg lh b">=</code>用作填充。但是我们不要想太多。</p><figure class="lj lk ll lm gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi li"><img src="../Images/055c09dfef27db38f5c8b87441160a16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xPnMZalKxJGhV0IJLU2NIg.png"/></div></div></figure></div><div class="ab cl ln lo hx lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="im in io ip iq"><p id="5ea2" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们从定义用于编码和编写第一个测试的base64函数接口开始。我将只为字符串实现base64，而不是为字节流。</p><p id="d734" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是第一个测试。我们的编码函数接受一个<code class="fe le lf lg lh b">&amp;str</code>并对字符串进行编码。</p><figure class="lj lk ll lm gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi lu"><img src="../Images/742bb5bf5b01831ebe1b41071519566c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bXqp3jP3RNseswN6JsUcqQ.png"/></div></div></figure><h1 id="4aab" class="lv lw jj bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">将比特分成6个一组</h1><p id="e24a" class="pw-post-body-paragraph kg kh jj ki b kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz mx lb lc ld im bi translated">第一步是将我们的字节重组为6位组。我们从3个ascii字符开始，因为它们在utf8 (Rust的编码)中有24位，我们可以将它们重组为4个base64字符。首先，让我们把字符转换成字节。</p><figure class="lj lk ll lm gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi lu"><img src="../Images/89247fbcb2603b93d0de5b6a7f6d8e3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KBn9P6OIp56VjiB2WsNU3A.png"/></div></div></figure><p id="98ce" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了得到我们的4 base64字符，我们需要应用位掩码来删除不需要的信息，并将字符移动到正确的位置。</p><p id="5722" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于第一组6位，我们只删除最后两位，并将所有内容向右移动2位。(实际上，只需将所有内容右移两位就可以完成这项工作……但我在编写代码时没有想到这一点。)</p><figure class="lj lk ll lm gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi lu"><img src="../Images/5a16a01972fafc79de0e4a96f3b6a7aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0kMzpC638yZookPD10Pkzg.png"/></div></div></figure><p id="292b" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第二组由第一个ascii字符的后两位和第二个ascii字符的前4位组成。因此，我们删除第一个ascii字符的前6位，并将它们左移4位。然后，我们删除第二个ascii字符的最后4位，将它们向右移动4位，并将它们二进制化在一起。</p><figure class="lj lk ll lm gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi lu"><img src="../Images/7d5f0aeda9d2ef86c2bd9e83154268ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YPSsD-iik_ErQr9PbWUrZA.png"/></div></div></figure><p id="0104" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第三组需要第二个ascii字符的后4位和第三个ascii字符的前两位。就像上面一样，我们删除多余的位，并将相关信息合并在一起。</p><figure class="lj lk ll lm gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi lu"><img src="../Images/32b035bf22f642843b3884c5f1328b9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QdSceFnMVCccWjDU_ekvAQ.png"/></div></div></figure><p id="6f41" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，第三个ascii字符的最后6位是最后一个base64字符。因为您已经看到了前三个base64字符的代码，并且代码非常简单，所以我不会在这里添加代码。</p><h1 id="2590" class="lv lw jj bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">将base64字符转换为实际的base64字符串</h1><p id="d764" class="pw-post-body-paragraph kg kh jj ki b kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz mx lb lc ld im bi translated">base64字符现在必须转换成base64输出字符串。这里<code class="fe le lf lg lh b">BASE64_ALPHABET</code>是一个片段，它对文章开头显示的base64字母表进行了编码。</p><figure class="lj lk ll lm gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi lu"><img src="../Images/b30e52ea64158971ce4d57e982bc53e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zY8jt4-NQ1YgYwRihPKriw.png"/></div></div></figure><p id="cacc" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们返回<code class="fe le lf lg lh b">base64_output</code>，我们应该有我们的第一个工作测试。🎉</p><p id="eba4" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们添加第二个测试，允许字符串长于3个字符。</p><figure class="lj lk ll lm gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi lu"><img src="../Images/bcff84038480b71700ed8b54d759aba1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MFeq5MqyWo8ktrTFW1mwzQ.png"/></div></div></figure><p id="b3ad" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了实现这一点，我们需要在我们的字符串中循环3个字符的组，并将它们转换为base64。</p><figure class="lj lk ll lm gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi lu"><img src="../Images/2ba14f43dd95972829949a8021a5ba7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ijkY-Hi9nYhZameZZQxAnQ.png"/></div></div></figure><p id="a684" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">每次迭代后，我们将索引向前移动编码字节的长度，所以是3。</p><figure class="lj lk ll lm gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi lu"><img src="../Images/517edeb25f29799dc58f60ca89bfefe3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0t67YIE7cIKhUnrWhbCh7Q.png"/></div></div></figure><h1 id="b56d" class="lv lw jj bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">对少于3个字节的字符串进行编码</h1><p id="6b9d" class="pw-post-body-paragraph kg kh jj ki b kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz mx lb lc ld im bi translated">到目前为止，我们只编码了3字节倍数的字符串。我们如何对2个甚至1个字节进行编码？如果我们用零填充丢失的字符，解码器将无法知道最后一个字节是否丢失，或者它们实际上只是<code class="fe le lf lg lh b">0</code>。(请记住，base64实际上适用于任何类型的字节流，而不仅仅是字符串。)</p><p id="6f35" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有一个巧妙的解决办法。如果我们只编码2个字节，我们需要3个base64字符来包含所有的位信息。因此，如果我们添加一个<code class="fe le lf lg lh b">=</code>作为填充，解码器可以知道只有2个字节被编码，而不是3个。让我们为此添加一个测试。</p><figure class="lj lk ll lm gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi lu"><img src="../Images/633ea739acec89dee42961a036521443.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eopr1pQUlIK_1_UbE-hSYg.png"/></div></div></figure><p id="2c0c" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我们可以提取3个base64字符并添加填充。</p><figure class="lj lk ll lm gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi lu"><img src="../Images/e5609e877dc55145b2027cff6df0453f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F4_05AZCuBQIFvBW1L7DKw.png"/></div></div></figure><p id="72b0" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">相同的系统适用于编码1个字节。需要2个base64字符来携带该字节，我们可以用<code class="fe le lf lg lh b">==</code>填充base64字符串，从而告诉解码器如何正确解码该字符串。</p><figure class="lj lk ll lm gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi lu"><img src="../Images/b92fcce16991d84b5bcf1e482577e16e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2YhJvOjcHmuzfcLoQN6XTA.png"/></div></div></figure></div><div class="ab cl ln lo hx lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="im in io ip iq"><h1 id="d4cb" class="lv lw jj bd lx ly my ma mb mc mz me mf mg na mi mj mk nb mm mn mo nc mq mr ms bi translated">摘要</h1><p id="dbb2" class="pw-post-body-paragraph kg kh jj ki b kj mt kl km kn mu kp kq kr mv kt ku kv mw kx ky kz mx lb lc ld im bi translated">总而言之，base64的简单思想是将比特流分成6比特组，并使用固定的字符表对这些值进行编码。这很容易实现，但我通过实现学到了很多东西。这不仅是我第一次使用它的规范实现算法，也是我第一次实际使用位屏蔽。</p><p id="e21d" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，在这篇博文中，我只实现了编码。现在轮到你实现解码了。或者，你可以在我的GitHub <a class="ae jg" href="https://github.com/niklasbuechner/experiments/blob/bbdb3136293bb2833529a47edcc5d9fa2dc5d405/base64/src/encode.rs" rel="noopener ugc nofollow" target="_blank"> repo </a>中查看。</p><p id="661b" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">完整代码可以在GitHub上找到:<a class="ae jg" href="https://github.com/niklasbuechner/experiments/blob/bbdb3136293bb2833529a47edcc5d9fa2dc5d405/base64/src/encode.rs" rel="noopener ugc nofollow" target="_blank">https://GitHub . com/niklasbuechner/experiments/blob/bbdb 3136293 bb 2833529 a 47 edcc 5d 9 fa 2 DC 5d 405/base64/src/encode . RS</a></p></div></div>    
</body>
</html>