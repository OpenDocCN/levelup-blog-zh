<html>
<head>
<title>Learn how to deploy Elixir apps on Heroku</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解如何在Heroku上部署Elixir应用程序</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/learn-how-to-deploy-elixir-apps-on-heroku-f238d718b893?source=collection_archive---------16-----------------------#2021-03-02">https://levelup.gitconnected.com/learn-how-to-deploy-elixir-apps-on-heroku-f238d718b893?source=collection_archive---------16-----------------------#2021-03-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/0c5039ea331edef356144425e24da3d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*Hri6IukGsdhSY26H9vOv2A.png"/></div></figure><p id="8837" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">对于我们决定向世界推出的每一款应用，到时候都有一个重要的决定要做:在哪里部署它最好？</p><p id="2ae2" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">简短的回答是:“视情况而定”。</p><p id="c2a0" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">然而，长的答案将取决于你的需求是什么，你的预算，你当前应用程序的设置，公司的限制等等。</p><p id="13e8" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">特别是，我认为一个真正便捷的方法是使用平台即服务(PaaS)选项，如<a class="ae kv" href="https://www.heroku.com/" rel="noopener ugc nofollow" target="_blank"> Heroku </a>。</p><p id="254e" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">Heroku是一个平台，可以让你从部署和维护应用程序的所有复杂性中抽象出来，并将精力集中在你想要构建的应用程序上。这里有一个来自Heroku的Greg Nokes的<a class="ae kv" href="https://www.youtube.com/watch?v=_N8Zf_nPZkQ&amp;feature=emb_logo&amp;ab_channel=Heroku" rel="noopener ugc nofollow" target="_blank">视频</a>解释了他们平台背后的概念。</p><p id="10d1" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">Heroku有这个<a class="ae kv" href="https://devcenter.heroku.com/articles/buildpacks" rel="noopener ugc nofollow" target="_blank">构建包</a>的想法，它将你的代码转换成一个可以在他们的平台上运行的slug，并抽象出所有的复杂性。</p><p id="b8f6" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">它们使用这些构建包支持小范围的流行编程语言，但是Elixir不在其中。</p><p id="62c8" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">但是并不是所有的希望都落空了，我们有能力使用定制的构建包来支持它。阿卡什·马诺哈尔和他的贡献者为我们建造的<a class="ae kv" href="https://github.com/HashNuke/heroku-buildpack-elixir" rel="noopener ugc nofollow" target="_blank">已经可用</a>。</p><p id="153c" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">如果这一切对你来说都是新的，不要担心，我们将很快开始把这些碎片放在一起。</p><p id="d2d0" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">让我们使用Elixir构建一个非常小的应用程序，它查询一个开放的API并通过HTTP以JSON格式显示数据。</p><p id="2464" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在您开始之前，您需要一个Heroku帐户。你可以在<a class="ae kv" href="https://signup.heroku.com/" rel="noopener ugc nofollow" target="_blank">heroku.com</a>免费创建一个新的，并且有一个免费层可以用于我们的开发项目。</p><p id="ed1c" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">如果你对长生不老药不太熟悉，你可以查看我的<a class="ae kv" href="https://rarias.dev/hello-world-elixir/" rel="noopener ugc nofollow" target="_blank"> hello-world-elixir </a>文章给你一个概述。</p><p id="ecbe" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">本文将分为5个部分</p><ol class=""><li id="b270" class="kw kx it jz b ka kb ke kf ki ky km kz kq la ku lb lc ld le bi translated">创建您的Elixir应用程序框架。</li><li id="a3ee" class="kw kx it jz b ka lf ke lg ki lh km li kq lj ku lb lc ld le bi translated">编写基本功能。</li><li id="8191" class="kw kx it jz b ka lf ke lg ki lh km li kq lj ku lb lc ld le bi translated">测试它在本地工作。</li><li id="60ab" class="kw kx it jz b ka lf ke lg ki lh km li kq lj ku lb lc ld le bi translated">创建您的Heroku应用程序。</li><li id="2e95" class="kw kx it jz b ka lf ke lg ki lh km li kq lj ku lb lc ld le bi translated">部署和测试您的应用程序。</li></ol><h1 id="3104" class="lk ll it bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">1.创建您的Elixir应用程序框架</h1><p id="addc" class="pw-post-body-paragraph jx jy it jz b ka mi kc kd ke mj kg kh ki mk kk kl km ml ko kp kq mm ks kt ku im bi translated">创建Elixir应用程序有多种方法。例如，您可以使用一个可用的框架，或者您可以自己一个接一个地创建文件。在这个练习中，我们将使用方便的<a class="ae kv" href="https://hexdocs.pm/mix/Mix.Tasks.New.html" rel="noopener ugc nofollow" target="_blank"> mix new </a>助手，它将为我们创建大部分初始结构。</p><p id="697c" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">转到shell上的项目文件夹，然后键入<code class="fe mn mo mp mq b">mix new simple_app --sup</code></p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="9dd7" class="mz ll it mq b gy na nb l nc nd">❯ mix new simple_app --sup<br/>* creating README.md<br/>* creating .formatter.exs<br/>* creating .gitignore<br/>* creating mix.exs<br/>* creating lib<br/>* creating lib/simple_app.ex<br/>* creating lib/simple_app/application.ex<br/>* creating test<br/>* creating test/test_helper.exs<br/>* creating test/simple_app_test.exs</span><span id="71d3" class="mz ll it mq b gy ne nb l nc nd">Your Mix project was created successfully.<br/>You can use "mix" to compile it, test it, and more:</span><span id="d4a9" class="mz ll it mq b gy ne nb l nc nd">    cd simple_app<br/>    mix test</span><span id="065e" class="mz ll it mq b gy ne nb l nc nd">Run "mix help" for more commands.</span></pre><p id="0662" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这将为您的应用程序创建一个基本框架，包括一个名为<code class="fe mn mo mp mq b">SimpleApp</code>的模块和一个基本的主管。一定要检查你的灵药版本。不同版本的语法和结构可能略有不同。我在下面的练习中使用1.11.3。</p><p id="a9f8" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">让我们先编译我们的应用程序来测试hello方法。</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="9a26" class="mz ll it mq b gy na nb l nc nd">❯ cd simple_app<br/>❯ mix compile<br/>Compiling 2 files (.ex)<br/>Generated simple_app app</span></pre><p id="804b" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们可以使用交互控制台来手动测试或者仅仅使用<code class="fe mn mo mp mq b">mix test</code>来使用测试套件</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="6f04" class="mz ll it mq b gy na nb l nc nd">❯ iex -S mix<br/>Erlang/OTP 23 [erts-11.1.7]</span><span id="aaf0" class="mz ll it mq b gy ne nb l nc nd">Interactive Elixir (1.11.3) - press Ctrl+C to exit (type h() ENTER for help)<br/>iex(1)&gt; SimpleApp.hello()<br/>:world</span></pre><p id="4a09" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">通过键入<code class="fe mn mo mp mq b">SimpleApp.hello()</code>，我们调用了助手创建的<code class="fe mn mo mp mq b">hello</code>方法，如果一切设置正确，我们应该会得到一个符号<code class="fe mn mo mp mq b">:world</code>作为回报。</p><h1 id="6588" class="lk ll it bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">2.编写基本功能</h1><p id="3d46" class="pw-post-body-paragraph jx jy it jz b ka mi kc kd ke mj kg kh ki mk kk kl km ml ko kp kq mm ks kt ku im bi translated">对于这个应用程序，我们将使用Coindesk 的公共<a class="ae kv" href="https://www.coindesk.com/coindesk-api" rel="noopener ugc nofollow" target="_blank"> API来查询今天比特币的价格。如果你更喜欢使用不同的API，你可以在这个</a><a class="ae kv" href="https://github.com/public-apis/public-apis#cryptocurrency" rel="noopener ugc nofollow" target="_blank"> Github repo </a>上找到一个公共API列表。我们得到的数据对这个练习来说并不重要。</p><p id="f874" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">但是，在继续之前，您可能希望检查您选择的API是否可操作，并检查返回数据的格式。我想在我的shell中使用<code class="fe mn mo mp mq b">curl</code>,但是<code class="fe mn mo mp mq b">wget</code>、Postman或者任何其他UI客户端应该可以完成这个任务。</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="18df" class="mz ll it mq b gy na nb l nc nd">❯ curl https://api.coindesk.com/v1/bpi/currentprice.json</span></pre><p id="a334" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">为了通过Elixir集成API，让我们使用HTTP包装器<a class="ae kv" href="https://github.com/teamon/tesla" rel="noopener ugc nofollow" target="_blank"> Tesla </a>。那里有很多好的选择，比如古老的Httpoison。然而，特斯拉有一些额外的好处。我不会详细介绍，因为这不是本文的目的，但是值得一试。</p><p id="2991" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">要安装Tesla，我们需要首先将依赖项添加到我们的<code class="fe mn mo mp mq b">mix.exs</code>文件中</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="64b5" class="mz ll it mq b gy na nb l nc nd">defp deps do<br/>  [<br/>	{:tesla, "~&gt; 1.4.0"},<br/>	{:hackney, "~&gt; 1.16.0"},<br/>	{:jason, "&gt;= 1.0.0"}<br/>	...<br/>  ]<br/>end</span></pre><p id="011c" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">注意，我还包括了<code class="fe mn mo mp mq b">hackney</code>和<code class="fe mn mo mp mq b">jason</code>。我们将使用Hackey作为适配器来实际执行我们的http调用。Tesla使用<code class="fe mn mo mp mq b">httpc</code>作为默认适配器，但Hackney在许多方面要好得多。</p><p id="33ab" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们也需要<code class="fe mn mo mp mq b">jason</code>,因为它是我们的中间件所需的JSON解析器。它也比其他JSON解析器性能更好，所以无论如何都是好的。</p><p id="5a1f" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">回到您的shell并安装新添加的依赖项</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="a4df" class="mz ll it mq b gy na nb l nc nd">❯ mix deps.get</span></pre><p id="fbb5" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">你可能还没有在你的系统中安装<code class="fe mn mo mp mq b">hex</code>，所以如果你被提示这样做，只要说是。</p><p id="2bfd" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">Tesla设置的最后一部分是将适配器添加到我们的配置文件中。如果还没有创建文件，就放在<code class="fe mn mo mp mq b">config/config.exs</code>下。</p><p id="3f29" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">然后我们可以添加Hackney适配器，这样您的配置文件应该如下所示</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="e35a" class="mz ll it mq b gy na nb l nc nd">use Mix.Config</span><span id="0ae3" class="mz ll it mq b gy ne nb l nc nd">config :tesla, adapter: Tesla.Adapter.Hackney</span></pre><p id="0aa8" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">就这样，我们完成了配置。加入一个<code class="fe mn mo mp mq b">mix compile</code>来衡量，以确保我们仍然可以继续，我们没有犯任何错误。</p><h1 id="b65f" class="lk ll it bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">API调用类</h1><p id="ef52" class="pw-post-body-paragraph jx jy it jz b ka mi kc kd ke mj kg kh ki mk kk kl km ml ko kp kq mm ks kt ku im bi translated">为了通过Tesla查询比特币基地API，我们将创建一个模型。</p><p id="c155" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我喜欢将业务逻辑放在模型文件夹中，因为它可以帮助我在大型项目中保持条理。继续创建<code class="fe mn mo mp mq b">lib/models/coinbase.ex</code></p><p id="03fd" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在它里面，我们需要3样东西，我们的模块定义，我们的Tesla中间件配置和我们想要抽象的方法。</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="8461" class="mz ll it mq b gy na nb l nc nd">defmodule Coinbase do<br/>  @moduledoc """  <br/>  A module abstraction used to interact with the coinbase http API  <br/>  """<br/>  use Tesla</span><span id="2abd" class="mz ll it mq b gy ne nb l nc nd">  plug Tesla.Middleware.BaseUrl, "https://api.coindesk.com"<br/>  plug Tesla.Middleware.Headers, [{"Content-Type", "application/json"}]<br/>  plug Tesla.Middleware.JSON</span><span id="9e54" class="mz ll it mq b gy ne nb l nc nd">  @doc """  <br/>  Returns the Bitcoin Price Index from coinbase  <br/>  """<br/>  def bpi_current_price do<br/>    get("/v1/bpi/currentprice.json")<br/>  end<br/>end</span></pre><p id="c62b" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们可以马上在我们的<code class="fe mn mo mp mq b">iex</code>控制台中测试这一点</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="ce99" class="mz ll it mq b gy na nb l nc nd">❯ iex -S mix<br/>Erlang/OTP 23</span><span id="2248" class="mz ll it mq b gy ne nb l nc nd">Interactive Elixir (1.11.3) - press Ctrl+C to exit (type h() ENTER for help)<br/>iex(1)&gt; Coinbase.bpi_current_price<br/>{:ok,<br/> %Tesla.Env{<br/>   __client__: %Tesla.Client{adapter: nil, fun: nil, post: [], pre: []},<br/>   __module__: Coinbase,<br/>   body: ...,<br/>   headers: [<br/>     ...<br/>   ],<br/>   method: :get,<br/>   opts: [],<br/>   query: [],<br/>   status: 200,<br/>   url: "https://api.coindesk.com/v1/bpi/currentprice.json"<br/> }}</span></pre><h1 id="6e12" class="lk ll it bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">显示数据</h1><p id="ab65" class="pw-post-body-paragraph jx jy it jz b ka mi kc kd ke mj kg kh ki mk kk kl km ml ko kp kq mm ks kt ku im bi translated">我们的基本模型完成后，我们需要的最后一件事是以易于阅读的格式显示数据。</p><p id="26f9" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们将使用轻型http服务器<a class="ae kv" href="https://github.com/ninenines/cowboy" rel="noopener ugc nofollow" target="_blank"> Cowboy </a>和适配器<a class="ae kv" href="https://github.com/elixir-plug/plug" rel="noopener ugc nofollow" target="_blank"> Plug </a>来返回我们的数据。</p><p id="a587" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">探索不同的服务器选项和框架及其优缺点超出了本文的范围，因此我们将坚持使用最简单的解决方案。</p><p id="5b20" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">让我们回到我们的<code class="fe mn mo mp mq b">mix.exs</code>文件，将Plug and Cowboy添加到我们的依赖项中</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="c05e" class="mz ll it mq b gy na nb l nc nd">defp deps do<br/>  [<br/>	{:tesla, "~&gt; 1.4.0"},<br/>	{:hackney, "~&gt; 1.16.0"},<br/>	{:jason, "&gt;= 1.0.0"},<br/>	{:plug_cowboy, "~&gt; 2.0"} # NEW!<br/>	...<br/>  ]<br/>end</span></pre><p id="cf43" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">获得这些dep，编译项目，我们准备好继续前进</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="57f8" class="mz ll it mq b gy na nb l nc nd">❯ mix deps.get<br/>❯ mix compile</span></pre><p id="ef51" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">现在，不用太关心组织，让我们添加一个小的路由器文件，将我们的端点暴露给世界，并调用我们之前创建的API。</p><p id="a181" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">继续创建<code class="fe mn mo mp mq b">lib/router.ex</code>并定义一个基本的插头端点</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="a2d7" class="mz ll it mq b gy na nb l nc nd">defmodule SimpleAppRouter do<br/>  use Plug.Router</span><span id="ddfc" class="mz ll it mq b gy ne nb l nc nd">  plug :match<br/>  plug :dispatch</span><span id="1b34" class="mz ll it mq b gy ne nb l nc nd">  get "/bpi" do<br/>    send_resp(conn, 200, "BPI price coming soon...")<br/>  end</span><span id="ed9c" class="mz ll it mq b gy ne nb l nc nd">  match _ do<br/>    send_resp(conn, 404, "Wrong place mate")<br/>  end<br/>end</span></pre><p id="74a2" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">如果您不熟悉它，可以在他们的<a class="ae kv" href="https://github.com/elixir-plug/plug" rel="noopener ugc nofollow" target="_blank">文档</a>中查看Plug的内部工作方式。现在，我希望上面的代码是不言自明的。我们需要知道的是，我们正在使用<code class="fe mn mo mp mq b">Plug.Router</code>功能，并公开一个端点<code class="fe mn mo mp mq b">/bpi</code>，我们将使用它来检索我们的数据并显示它。</p><p id="bc7a" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们现在可以告诉我们的监督树，我们的路由器已经准备就绪。</p><p id="e3a3" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">转到<code class="fe mn mo mp mq b">lib/simple_app/application.ex</code>，在那里您将找到由<code class="fe mn mo mp mq b">mix new</code>助手创建的应用程序文件。这里，我们将要求我们的应用程序启动监督树下的路由器。</p><p id="1053" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">您生成的文件将如下所示</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="5a46" class="mz ll it mq b gy na nb l nc nd">defmodule SimpleApp.Application do<br/>  # See https://hexdocs.pm/elixir/Application.html<br/>  # for more information on OTP Applications<br/>  @moduledoc """<br/>  Application that starts the http router for `SimpleApp`.<br/>  """</span><span id="da7a" class="mz ll it mq b gy ne nb l nc nd">  use Application</span><span id="364c" class="mz ll it mq b gy ne nb l nc nd">  @impl true<br/>  def start(_type, _args) do<br/>    children = [<br/>      {Plug.Cowboy, scheme: :http, plug: SimpleAppRouter, options: [port: 8080]}<br/>    ]</span><span id="bb3c" class="mz ll it mq b gy ne nb l nc nd">    # See https://hexdocs.pm/elixir/Supervisor.html<br/>    # for other strategies and supported options<br/>    opts = [strategy: :one_for_one, name: SimpleApp.Supervisor]<br/>    Supervisor.start_link(children, opts)<br/>  end<br/>end</span></pre><p id="1167" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">您可以通过运行您的服务器来测试它是否工作正常</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="eed6" class="mz ll it mq b gy na nb l nc nd">❯ mix run --no-halt</span></pre><p id="210e" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">要显示比特币基地的数据，我们需要做的就是返回到我们的<code class="fe mn mo mp mq b">SimpleAppRouter</code>并添加比特币基地调用。您的路由器功能将如下所示</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="3545" class="mz ll it mq b gy na nb l nc nd">get "/bpi" do<br/>  send_resp(conn, 200, Coinbase.bpi_current_price)<br/>end</span></pre><p id="6589" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">如果您还记得<code class="fe mn mo mp mq b">bpi_current_price</code>函数响应的格式，您可能已经注意到它不仅包括响应的主体，还包括我们不需要显示的标题、进程状态等。所以要解决这个问题，回到<code class="fe mn mo mp mq b">lib/models/coinbase.ex</code>并修改函数，改为只返回响应体</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="6f17" class="mz ll it mq b gy na nb l nc nd">def bpi_current_price do<br/>    {:ok, response} = get("/v1/bpi/currentprice.json")<br/>    response.body<br/> end</span></pre><p id="b800" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">请记住，为了简单起见，我们不做任何类型的验证或错误考虑。</p><h1 id="8646" class="lk ll it bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">3.测试它在本地工作</h1><p id="8cc7" class="pw-post-body-paragraph jx jy it jz b ka mi kc kd ke mj kg kh ki mk kk kl km ml ko kp kq mm ks kt ku im bi translated">现在，应用程序终于准备好了，我们可以在我们的本地环境中测试它的工作。</p><p id="387b" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">继续运行您的服务器</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="5719" class="mz ll it mq b gy na nb l nc nd">❯ mix run --no-halt</span></pre><p id="bfa9" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">然后在您的浏览器或curl客户端中，您应该能够在<code class="fe mn mo mp mq b"><a class="ae kv" href="http://localhost:8080/bpi" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/bpi</a></code>获得结果</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="6285" class="mz ll it mq b gy na nb l nc nd">❯ curl http://localhost:8080/bpi<br/>HTTP/1.1 200 OK<br/>...<br/>server: Cowboy</span><span id="ebc2" class="mz ll it mq b gy ne nb l nc nd">{ ..."chartName":"Bitcoin","bpi":{"USD":{"code":"USD"... }</span></pre><h1 id="6c68" class="lk ll it bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">4.创建Heroku应用程序</h1><p id="5f4d" class="pw-post-body-paragraph jx jy it jz b ka mi kc kd ke mj kg kh ki mk kk kl km ml ko kp kq mm ks kt ku im bi translated">在我们完全进入Heroku应用程序创建之前，代码中还有最后一件事需要修改。</p><p id="f4c5" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">注意我们如何使用端口<code class="fe mn mo mp mq b">8080</code>作为默认端口，但是一旦在Heroku中，我们的应用程序端口将是动态的，并由它们决定。因此，我们需要从环境变量中读取端口。</p><p id="6d77" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">为此，使用从系统环境变量中获取的端口来更新应用程序文件中的端口8080。</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="9a75" class="mz ll it mq b gy na nb l nc nd">children = [<br/>  {Plug.Cowboy, <br/>		scheme: :http, <br/>		plug: SimpleAppRouter, <br/>		options: [port: (System.get_env("PORT") || "8080") |&gt; String.to_integer()]<br/>  }<br/>]</span></pre><p id="32ed" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">如果<code class="fe mn mo mp mq b">PORT</code>环境变量不存在，这有一个额外的好处，即默认为8080，这在本地使用时很方便。</p><p id="185b" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">为了创建我们的Heroku应用程序，我们将使用<a class="ae kv" href="https://devcenter.heroku.com/articles/heroku-cli" rel="noopener ugc nofollow" target="_blank"> heroku-cli </a>。然而，如果你觉得使用UI更舒服，你可以去你的<a class="ae kv" href="https://dashboard.heroku.com/apps" rel="noopener ugc nofollow" target="_blank"> Heroku仪表板</a>并且步骤非常简单。</p><p id="19d0" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">你首先需要一个Heroku账户，我假设你已经有了。如果你没有，就用你喜欢的电子邮件和密码在他们的网站上注册。</p><blockquote class="nf ng nh"><p id="5940" class="jx jy ni jz b ka kb kc kd ke kf kg kh nj kj kk kl nk kn ko kp nl kr ks kt ku im bi translated">提示:如果您碰巧有一个现有的Heroku帐户，并且不想在本练习中使用，您可以使用<a class="ae kv" href="https://github.com/heroku/heroku-accounts" rel="noopener ugc nofollow" target="_blank"> heroku-accounts </a>插件轻松管理多个帐户。</p></blockquote><p id="beb7" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">要使用cli创建一个新的Heroku应用程序，只需在shell中进入应用程序的根目录并键入</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="6907" class="mz ll it mq b gy na nb l nc nd">❯ heroku create simple-app-elixir<br/>Creating ⬢ simple-app-elixir... done<br/>https://simple-app-elixir.herokuapp.com/ | https://git.heroku.com/simple-app-elixir.git</span></pre><p id="31b2" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">其中,<code class="fe mn mo mp mq b">simple-app-elixir</code>是您希望为您的应用程序指定的唯一名称。</p><p id="deee" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">因为在撰写本文时Heroku没有任何针对Elixir的默认buildpack，所以我们需要将我们的应用程序的buildpack设置为HashNuke的版本。</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="bacc" class="mz ll it mq b gy na nb l nc nd">❯ heroku buildpacks:set \<br/>  https://github.com/HashNuke/heroku-buildpack-elixir.git -a simple-app-elixir</span></pre><p id="aae1" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">为了让这个buildpack在生产中工作，我们需要在Heroku应用程序上指定一个默认配置。在项目的根目录下，创建一个名为<code class="fe mn mo mp mq b">elixir_buildpack.config</code>的文件，并用您的OTP和Elixir版本填充它。</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="c6c7" class="mz ll it mq b gy na nb l nc nd">erlang_version=23.0<br/>elixir_version=1.11<br/>always_rebuild=false<br/>runtime_path=/app</span></pre><p id="44bd" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们需要做的最后一件事是告诉Heroku在部署应用程序时运行什么进程。为此我们可以使用一个<code class="fe mn mo mp mq b">Procfile</code>。在我们的Procfile中，我们将指定我们希望<code class="fe mn mo mp mq b">mix</code>运行我们的应用程序，该应用程序将依次运行Cowboy服务器。</p><p id="5214" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在项目的根目录下创建另一个名为<code class="fe mn mo mp mq b">Procfile</code>的文件(没有任何文件扩展名)，并在其中添加以下内容</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="dbf3" class="mz ll it mq b gy na nb l nc nd">web: mix run --no-halt</span></pre><p id="c262" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">请注意，这与我们在本地运行服务器时使用的命令相同。如果没有找到概要文件，buildpack实际上将使用这个相同的命令作为缺省命令，但是我们自己定义它是一个很好的实践。</p><h1 id="fd75" class="lk ll it bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">5.部署和测试您的应用</h1><p id="bc35" class="pw-post-body-paragraph jx jy it jz b ka mi kc kd ke mj kg kh ki mk kk kl km ml ko kp kq mm ks kt ku im bi translated">现在我们准备部署。Heroku有一个基于<code class="fe mn mo mp mq b">git</code>的部署系统，这真的很方便，因为我们需要做的就是<code class="fe mn mo mp mq b">git push</code>我们的代码来部署我们的应用程序。</p><p id="8dde" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在您的shell中，在项目的根目录下，继续将您的代码提交给Heroku，就好像它是另一个常规的git存储库一样。您可能需要使用自己的git URL添加Heroku remote</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="4a5c" class="mz ll it mq b gy na nb l nc nd">❯ git remote add heroku <a class="ae kv" href="https://git.heroku.com/simple-app-elixir.git" rel="noopener ugc nofollow" target="_blank">https://git.heroku.com/simple-app-elixir.git</a></span></pre><p id="75ae" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">您的是在创建应用程序时打印的，或者也可以在您的Heroku应用程序的设置中找到。</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="88d2" class="mz ll it mq b gy na nb l nc nd"># If you haven't initialised the repository yet<br/>❯ git init<br/>Initialized empty Git repository</span><span id="1ddb" class="mz ll it mq b gy ne nb l nc nd"># Commit your code<br/>❯ git add .<br/>❯ git commit -m "SimpleApp initial commit. Coinbase API"<br/>❯ git push heroku master</span></pre><p id="7a01" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">如果您的设置正确，设置了SSH密钥，并且没有任何其他配置问题，这应该已经部署了您的应用程序。</p><p id="0864" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">一旦你的代码被部署，Heroku会给你的应用分配一个子域，类似于</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="4a1f" class="mz ll it mq b gy na nb l nc nd">https://simple-app-elixir.herokuapp.com/</span></pre><p id="cf38" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">取决于你读这篇文章的时间，我的可能是活跃的，也可能不是。无论哪种方式，一旦你的部署，你应该能够检查出来。</p><p id="4ce8" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">您可以在浏览器中或者通过curl测试我们的<code class="fe mn mo mp mq b">/bpi</code>端点。</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="3ba8" class="mz ll it mq b gy na nb l nc nd">❯ curl https://simple-app-elixir.herokuapp.com/bpi</span></pre><p id="6e18" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这个端点应该返回一个带有比特币基地比特币汇率的json对象，这样您的部署就完成了。恭喜你。👏</p><h1 id="479b" class="lk ll it bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">结论</h1><p id="02c5" class="pw-post-body-paragraph jx jy it jz b ka mi kc kd ke mj kg kh ki mk kk kl km ml ko kp kq mm ks kt ku im bi translated">如您所见，在Heroku中部署Elixir应用程序相当简单。该平台允许按需扩展，能够很好地处理Elixir的性能需求。</p><p id="99da" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">Heroku的另一个优势是，您可以在同一个伞形平台下运行多种语言的应用程序，这使您可以拥有复杂的微服务架构来满足不同的需求，而无需任何额外的平台知识。</p><p id="6b17" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我在这个<a class="ae kv" href="https://github.com/ronald05arias/simple-app-elixir" rel="noopener ugc nofollow" target="_blank"> Github库</a>上放了一个完整的工作版本的代码，以防你想和它比较或者只是克隆它并测试它。</p><p id="12e8" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">编码快乐！</p></div></div>    
</body>
</html>