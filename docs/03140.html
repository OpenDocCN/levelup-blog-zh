<html>
<head>
<title>How to Test Code with Side Effects in a Pure Way Scala</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何以纯Scala的方式测试有副作用的代码</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-test-code-with-side-effects-in-a-pure-way-scala-2b98e8e67b9d?source=collection_archive---------14-----------------------#2020-04-21">https://levelup.gitconnected.com/how-to-test-code-with-side-effects-in-a-pure-way-scala-2b98e8e67b9d?source=collection_archive---------14-----------------------#2020-04-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/0313b79fcf33316cb092af3d208482ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*XbyibWlyLsNyB8A-.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><em class="kc">最初发表于</em><a class="ae kd" href="https://edward-huang.com/scala/functional-programming/cats/2020/04/19/how-to-test-code-with-side-effect-in-a-pure-way-in-scala/" rel="noopener ugc nofollow" target="_blank"><em class="kc">https://edward-huang.com</em></a></figcaption></figure><p id="0280" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">单元测试是我们创建应用程序时最基本的测试之一。它是将每个组件或功能作为一个单元来测试——给定一个输入，将输入插入到功能中，并断言输出。然而，在单元测试中，我们会遇到很多与复杂的IO或副作用有关的复杂性。</p><p id="28ef" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">一个好的经验法则是创建一个返回我们想要的值的副作用的模拟。然而，这样做的话，我们需要提取一个单独的组件到一个函数中来模拟这个操作。可能会很麻烦。</p><p id="15ea" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">在这篇博客中，我想分享一下如何通过对函数做一些小小的调整来测试异步代码——通过类型构造函数来抽象它。</p><p id="ab54" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">让我们深入一个例子来说明我的意思。</p><p id="c646" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">注意:我们在后面的代码中使用类别类型类和<code class="fe lc ld le lf b">cats</code>库。如果你不熟悉类别类型类<a class="ae kd" href="https://en.wikipedia.org/wiki/Type_class" rel="noopener ugc nofollow" target="_blank">，这里的</a>是对它的简要描述。</p><h1 id="5e1f" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">问题</h1><p id="1db4" class="pw-post-body-paragraph ke kf iq kg b kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx mi kz la lb ij bi translated">假设我们有一个<code class="fe lc ld le lf b">DBClient</code>，我们希望有一个<code class="fe lc ld le lf b">DBService</code>使用<code class="fe lc ld le lf b">DBClient</code>来做一些与数据库交互的操作。</p><p id="25a1" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">下面是<code class="fe lc ld le lf b">DBClient</code>的实现:</p><pre class="mj mk ml mm gt mn lf mo mp aw mq bi"><span id="ee4c" class="mr lh iq lf b gy ms mt l mu mv">trait DBClient {<br/>  def get(url:String):Future[Int]<br/>}</span></pre><p id="4bf2" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">下面是<code class="fe lc ld le lf b">DBService</code>的实现:</p><pre class="mj mk ml mm gt mn lf mo mp aw mq bi"><span id="96f6" class="mr lh iq lf b gy ms mt l mu mv">class DBService(dbClient:DBClient) {<br/>  def sumAllPrice(urls:List[String]): Future[Int] = Future.traverse(urls)(dbClient.get).map(_.sum)<br/>}</span></pre><p id="09af" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">现在，如果我们想测试<code class="fe lc ld le lf b">sumAllPrice</code>，我们可以创建一个<code class="fe lc ld le lf b">DBClient</code>的存根。</p><pre class="mj mk ml mm gt mn lf mo mp aw mq bi"><span id="837d" class="mr lh iq lf b gy ms mt l mu mv">class TestDBClient extends DBClient {<br/>  override def get(url:String): Future[Int] = Future.successful{1}<br/>}</span></pre><p id="1fb0" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">如何在单元测试中测试<code class="fe lc ld le lf b">sumAllPrice</code>？</p><p id="9be0" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">因为它是异步的，我们需要一个可以接收异步结果的测试用例。但是，如果有一种方法可以减轻这个问题，那就是让<code class="fe lc ld le lf b">DBClient</code>更通用，并将其抽象成一个类型构造函数。</p><h1 id="5e15" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">行动</h1><p id="fc53" class="pw-post-body-paragraph ke kf iq kg b kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx mi kz la lb ij bi translated">我们可以用几种方法来解决这个问题。第一种是将代码重构为类型构造函数。在第二个例子中，我想把代码改成类型类模式。</p><h1 id="2e26" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">对类型构造函数进行抽象</h1><p id="d890" class="pw-post-body-paragraph ke kf iq kg b kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx mi kz la lb ij bi translated">我们让<code class="fe lc ld le lf b">DBClient</code>接收一个类型构造函数<code class="fe lc ld le lf b">F[_]</code>类型。</p><pre class="mj mk ml mm gt mn lf mo mp aw mq bi"><span id="d467" class="mr lh iq lf b gy ms mt l mu mv">trait DBClient[F[_]] {<br/>  def get(url:String):F[Int]<br/>}</span></pre><p id="9f89" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">注意:您需要在您的应用程序中导入<a class="ae kd" href="https://stackoverflow.com/questions/6246719/what-is-a-higher-kinded-type-in-scala" rel="noopener ugc nofollow" target="_blank">更高级的类型</a>。</p><p id="9cb5" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">这意味着<code class="fe lc ld le lf b">get(url:String)</code>返回任何构造函数类型。可以是<code class="fe lc ld le lf b">Future[Int]</code>也可以是<code class="fe lc ld le lf b">List[Int]</code>。</p><p id="3b0b" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">我们使用<code class="fe lc ld le lf b">Cats</code> <a class="ae kd" href="https://typelevel.org/cats/typeclasses.html" rel="noopener ugc nofollow" target="_blank">库</a>为生产版本生成异步代码，为测试版本生成同步代码。</p><p id="5768" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated"><code class="fe lc ld le lf b">Cats</code>库有一个单子类型<code class="fe lc ld le lf b">id</code>，它允许类型包装到一个类型构造函数中而不改变它们的含义:</p><pre class="mj mk ml mm gt mn lf mo mp aw mq bi"><span id="c559" class="mr lh iq lf b gy ms mt l mu mv">package cats<br/><br/>type Id[A] = A</span></pre><p id="5a5d" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">我们有用于单元测试的<code class="fe lc ld le lf b">TestDBClient</code>特征，和用于主代码的<code class="fe lc ld le lf b">ProdDBClient</code>特征:</p><pre class="mj mk ml mm gt mn lf mo mp aw mq bi"><span id="f0a7" class="mr lh iq lf b gy ms mt l mu mv">import cats.Id<br/>trait TestDBClient extends DBClient[Id]<br/><br/>trait ProdDBClient extends DBClient[Future]</span></pre><p id="83f7" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">然后，我们也抽象了类型构造函数上的<code class="fe lc ld le lf b">DBService</code>。</p><pre class="mj mk ml mm gt mn lf mo mp aw mq bi"><span id="928b" class="mr lh iq lf b gy ms mt l mu mv">import cats.implicits._<br/><br/>class DBService[F[_]:Applicative](dbClient:DBClient[F]) {<br/>  def sumAllPrice(urls:List[String]): F[Int] = urls.traverse(dbClient.get).map(_.sum)<br/>}</span></pre><p id="c35e" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated"><code class="fe lc ld le lf b">F[_]: Applicative</code>是语法糖，是上下文相关的，因为它的<code class="fe lc ld le lf b">implicit</code>值为<code class="fe lc ld le lf b">ap: Applicative[F]</code>。</p><p id="d596" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">上述功能与<code class="fe lc ld le lf b">class DBService[F[_]](dbClient:DBClient[F])(implicit ap:Applicative[F])</code>相同</p><p id="f291" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">这里我们让类型构造函数成为一个可应用的，因为<code class="fe lc ld le lf b">traverse</code>只对有<code class="fe lc ld le lf b">Applicative</code>的值序列起作用。在<code class="fe lc ld le lf b">Future</code>的上下文中，它有一个<code class="fe lc ld le lf b">Applicative</code>，并产生<code class="fe lc ld le lf b">List[Future[Int]]</code>。然而，通过对类型构造函数<code class="fe lc ld le lf b">List[F[Int]]</code>进行抽象，我们需要向编译器证明该值在传入函数时有一个<code class="fe lc ld le lf b">Applicative</code>。</p><p id="99e6" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">在这种情况下，我们使<code class="fe lc ld le lf b">DBClient</code>中的类型构造函数不绑定到任何特定的上下文，以便它可以很容易地在其他服务中使用。但是，我们限制了<code class="fe lc ld le lf b">DBService</code>的上下文，因为它需要有<code class="fe lc ld le lf b">Applicative</code>来执行<code class="fe lc ld le lf b">traverse</code>操作。</p><p id="c114" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">第二种方法是抽象类型构造函数，但使用类型类模式。</p><h1 id="51a4" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">使用类型类</h1><p id="9b61" class="pw-post-body-paragraph ke kf iq kg b kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx mi kz la lb ij bi translated">要定义一个类型类，我们需要做三件事:</p><ol class=""><li id="a4b6" class="mw mx iq kg b kh ki kl km kp my kt mz kx na lb nb nc nd ne bi translated">类型类别</li><li id="66f0" class="mw mx iq kg b kh nf kl ng kp nh kt ni kx nj lb nb nc nd ne bi translated">类型实例</li><li id="2644" class="mw mx iq kg b kh nf kl ng kp nh kt ni kx nj lb nb nc nd ne bi translated">接口语法，接口对象</li></ol><p id="9027" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated"><a class="ae kd" href="https://edward-huang.com/functional-programming/2020/01/02/wtf-is-a-type-class/" rel="noopener ugc nofollow" target="_blank"> WTF是类型类？</a></p><p id="4dc2" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">我们将把<code class="fe lc ld le lf b">DBClient</code>定义为一个类型类:</p><pre class="mj mk ml mm gt mn lf mo mp aw mq bi"><span id="0884" class="mr lh iq lf b gy ms mt l mu mv">trait DBClient[F[_]] {<br/>  def get(url:String): F[Int]<br/>}</span></pre><p id="1c21" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">然后我们将定义实例。实例对象是我们放置<code class="fe lc ld le lf b">ProdDBClient</code>和<code class="fe lc ld le lf b">TestDBClient</code>的地方。</p><pre class="mj mk ml mm gt mn lf mo mp aw mq bi"><span id="1494" class="mr lh iq lf b gy ms mt l mu mv">object DBClientInstances {<br/>  implicit val getFutureInstance: DBClient[Future] = new DBClient[Future] {<br/>    override def get(url: String): Future[Int] = ???<br/>  }<br/><br/>  implicit val getIdInstance:DBClient[Id] = new DBClient[Id] {<br/>    override def get(url: String): Id[Int] = ???<br/>  }<br/>}</span></pre><p id="5392" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">最后，我们创建一个接口对象<code class="fe lc ld le lf b">DBService</code>，并在<code class="fe lc ld le lf b">sumAllPrice</code>中注入我们的实例:</p><pre class="mj mk ml mm gt mn lf mo mp aw mq bi"><span id="c888" class="mr lh iq lf b gy ms mt l mu mv">object DBService {<br/>  def sumAllPrice[F[_]:Applicative](urls:List[String])(implicit dbClient:DBClient[F]): F[Int] = urls.traverse(dbClient.get).map(_.sum)<br/>}</span></pre><p id="58ef" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">我们还限制我们的类型构造函数有一个<code class="fe lc ld le lf b">Applicative</code>来使用<code class="fe lc ld le lf b">traverse</code>。</p><p id="8fb4" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">为什么我们这里不用<code class="fe lc ld le lf b">Monad</code>而用<code class="fe lc ld le lf b">Applicative</code>来代替呢？这是因为<code class="fe lc ld le lf b">Monad</code>更受限制，是<code class="fe lc ld le lf b">Applicative</code>的子类型，在类型类层次结构中，并且对于当前函数<code class="fe lc ld le lf b">Applicative</code>来说可以完成这项工作。我们不需要将传入元素限制在<code class="fe lc ld le lf b">Monad</code>中，因为使用<code class="fe lc ld le lf b">Applicative</code>我们可以有更广泛的行为范围，以及更少的法律需要遵守(no <code class="fe lc ld le lf b">flatMap</code>)。因此，调用方在实现<code class="fe lc ld le lf b">DBService</code>时可以做出更大范围的行为。</p><h1 id="f1d4" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">外卖食品</h1><ul class=""><li id="f4ec" class="mw mx iq kg b kh me kl mf kp nk kt nl kx nm lb nn nc nd ne bi translated">我们可以通过用类型构造函数抽象我们的应用程序来测试异步代码。</li><li id="f556" class="mw mx iq kg b kh nf kl ng kp nh kt ni kx nj lb nn nc nd ne bi translated">当使用类型构造函数抽象您的应用程序时，让类型构造函数对当前实现所需的行为有一个最小的限制是一个很好的实践。例如，<code class="fe lc ld le lf b">DBClient</code>不限于拥有任何上下文，而<code class="fe lc ld le lf b">DBService</code>限于拥有<code class="fe lc ld le lf b">Applicative</code>，因为我们希望能够在类型构造函数中使用<code class="fe lc ld le lf b">traverse</code>。</li></ul><p id="51c3" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">本教程中的所有源代码都在<a class="ae kd" href="https://github.com/edwardGunawan/Blog-Tutorial/tree/master/ScalaTutorial/asynchronousTesting" rel="noopener ugc nofollow" target="_blank">这里</a>。</p></div><div class="ab cl no np hu nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="ij ik il im in"><p id="1702" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated"><strong class="kg ir">感谢阅读！如果你喜欢这篇文章，请随时订阅我的时事通讯，以便在我写新内容时得到通知。</strong></p><p id="5615" class="pw-post-body-paragraph ke kf iq kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ij bi translated">你也可以在<a class="ae kd" href="https://medium.com/@edwardgunawan880" rel="noopener">中</a>关注我更多类似的帖子。</p></div></div>    
</body>
</html>