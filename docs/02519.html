<html>
<head>
<title>Using SOPS and git hooks to share secrets — Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用sop和git挂钩共享秘密—第2部分</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/using-sops-and-git-hook-to-share-secrets-part-2-38518be67a14?source=collection_archive---------5-----------------------#2020-03-19">https://levelup.gitconnected.com/using-sops-and-git-hook-to-share-secrets-part-2-38518be67a14?source=collection_archive---------5-----------------------#2020-03-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/7a14682596bd7024fd8843d21441ed8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pw5cAgbobCw-vv-iE_MpWg.png"/></div></div></figure><h1 id="4138" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">我们到目前为止所做的</h1><p id="5c8e" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">在<a class="ae lx" href="https://medium.com/@richardfan1126/using-sops-and-git-hook-to-share-secrets-part-1-d1d4475a4b46?source=friends_link&amp;sk=f13fd5f8c7c9c98cd56483c03b97177a" rel="noopener">第1部分</a>中，我们已经建立了我们的库，使用<a class="ae lx" href="https://github.com/mozilla/sops" rel="noopener ugc nofollow" target="_blank"> Mozilla SOPS </a>在提交前加密秘密文件。但是加密/解密过程仍然依赖于人的交互，这在DevOps中不是一个好的做法。在第2部分中，我们将使用githooks来自动化这个过程。</p><h1 id="1a3f" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">什么是githooks</h1><p id="3cbd" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">githooks是一组shell文件，将在git操作的不同阶段运行，允许我们定制我们的开发工作流程。在这个环节中，我们将使用3个钩子:<code class="fe ly lz ma mb b">pre-commit</code> <strong class="lb iu">、</strong>、<code class="fe ly lz ma mb b">post-merge</code>和<code class="fe ly lz ma mb b">post-rewrite</code>。你可以在我的<a class="ae lx" href="https://github.com/richardfan1126/sops-githooks" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>中找到我的代码。</p><h1 id="9199" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">我们必须解决的问题</h1><h2 id="d174" class="mc kc it bd kd md me dn kh mf mg dp kl lk mh mi kp lo mj mk kt ls ml mm kx mn bi translated">问题1:无法跟踪文件是否更改</h2><p id="4404" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">SOPS使用<a class="ae lx" href="https://cloud.ibm.com/docs/key-protect?topic=key-protect-envelope-encryption#overview" rel="noopener ugc nofollow" target="_blank">信封加密</a>，我们的数据不是由我们提供的密钥(主密钥)直接加密的(在我们的例子中，它是KMS客户密钥)。相反，它们由随机生成的密钥(数据密钥)加密，然后主密钥加密数据密钥。然后，加密的数据密钥将作为元数据存储在加密文件中。因为数据密钥是随机的，如果我们加密同一个未修改的文件，每次得到的结果仍然不同。</p><figure class="mp mq mr ms gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mo"><img src="../Images/0cb68e4e8f2956f40384863e8ef27332.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yLZbhBO7qL1AyE0V4HYqKw.png"/></div></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">SOPS使用随机数据密钥加密文件</figcaption></figure><p id="5aba" class="pw-post-body-paragraph kz la it lb b lc mx le lf lg my li lj lk mz lm ln lo na lq lr ls nb lu lv lw im bi translated">如果我们在每次提交之前天真地加密每个文件，我们将每次都改变它，尽管我们实际上并没有。检测真正的文件更改是我们必须解决的第一个问题</p><h2 id="e0af" class="mc kc it bd kd md me dn kh mf mg dp kl lk mh mi kp lo mj mk kt ls ml mm kx mn bi translated">问题2:无法观察冲突</h2><p id="6df5" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">因为我们没有在存储库中存储明文文件，所以当发生冲突时，Git只能提供加密文件的diff视图。但是我们的大脑不是解密器，我们必须看到在明文版本中冲突是如何发生的。这是我们要解决的第二个问题。</p><h1 id="2141" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">如何使用挂钩</h1><p id="7b37" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">githooks是将在本地机器上运行的shell文件。出于安全原因，这些文件不能从远程存储库克隆。否则，黑客可以使用他们的存储库向计算机注入恶意代码。</p><p id="0613" class="pw-post-body-paragraph kz la it lb b lc mx le lf lg my li lj lk mz lm ln lo na lq lr ls nb lu lv lw im bi translated">要使用钩子，我们需要手动地将钩子文件复制到您克隆的存储库中的<code class="fe ly lz ma mb b">.git/hooks</code>文件夹下。</p><h1 id="a3c6" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">让我们深入研究代码</h1><h2 id="d7ed" class="mc kc it bd kd md me dn kh mf mg dp kl lk mh mi kp lo mj mk kt ls ml mm kx mn bi translated">1.秘密文件</h2><p id="ea74" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">为了让我的钩子知道我们的秘密文件在哪里，我在根级别创建了<code class="fe ly lz ma mb b"><a class="ae lx" href="https://github.com/richardfan1126/sops-githooks/blob/master/.secret_files" rel="noopener ugc nofollow" target="_blank">.secret_files</a></code>文件。这只是一个简单的文本文件，列出了我们想要加密的所有文件的相对路径。</p><h2 id="a6aa" class="mc kc it bd kd md me dn kh mf mg dp kl lk mh mi kp lo mj mk kt ls ml mm kx mn bi translated">2.预提交</h2><p id="c828" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated"><code class="fe ly lz ma mb b"><a class="ae lx" href="https://github.com/richardfan1126/sops-githooks/blob/master/hooks/pre-commit" rel="noopener ugc nofollow" target="_blank">pre-commit</a></code>是在提交实际发生之前触发的，我使用这个钩子来做数据加密。</p><figure class="mp mq mr ms gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nc"><img src="../Images/7dc3758c096d5b6354291df7a04557dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xDkw8kfljiBeCXkt12asiA.png"/></div></div></figure><p id="ed27" class="pw-post-body-paragraph kz la it lb b lc mx le lf lg my li lj lk mz lm ln lo na lq lr ls nb lu lv lw im bi translated">钩子首先获得秘密文件的列表。对于每个文件，它将为加密版本生成相应的文件名(在文件扩展名前添加<code class="fe ly lz ma mb b">.enc</code>)。</p><figure class="mp mq mr ms gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nd"><img src="../Images/03693385eaf503b798f16e3682d45788.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AtLpAwWAqz96Kagk_EfnaQ.png"/></div></div></figure><p id="aa50" class="pw-post-body-paragraph kz la it lb b lc mx le lf lg my li lj lk mz lm ln lo na lq lr ls nb lu lv lw im bi translated">然后，它将检查加密版本是否存在。如果没有，它会通过加密明文创建一个，我后面会讲到<code class="fe ly lz ma mb b">anyFileChanged</code>标志。</p><figure class="mp mq mr ms gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ne"><img src="../Images/a033277856f77d567d76a63d8500c6e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6brz11U0omJFrndy-VaYwg.png"/></div></div></figure><p id="1814" class="pw-post-body-paragraph kz la it lb b lc mx le lf lg my li lj lk mz lm ln lo na lq lr ls nb lu lv lw im bi translated">如果加密文件存在，它将继续比较明文和加密文件的上次更新时间。</p><p id="e1b4" class="pw-post-body-paragraph kz la it lb b lc mx le lf lg my li lj lk mz lm ln lo na lq lr ls nb lu lv lw im bi translated">我这样做是因为如果加密版本比明文版本更新，我可以假设加密版本是最新的。然后我可以跳过实际的内容比较来降低密钥的使用。(数据加密在成本和计算机资源方面都很昂贵)</p><p id="2c05" class="pw-post-body-paragraph kz la it lb b lc mx le lf lg my li lj lk mz lm ln lo na lq lr ls nb lu lv lw im bi translated">当然，如果用户直接编辑加密文件，可能就是问题所在。</p><figure class="mp mq mr ms gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nf"><img src="../Images/7e23042d46b07976c5344064c0f9009a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t9yy7WsKlTVXJ3WQNAaSZA.png"/></div></div></figure><p id="4c6f" class="pw-post-body-paragraph kz la it lb b lc mx le lf lg my li lj lk mz lm ln lo na lq lr ls nb lu lv lw im bi translated">如果明文版本在加密版本之后被更新，钩子将检查它们的内容是否实际上不同。我通过解密加密版本，并使用<code class="fe ly lz ma mb b">diff</code>来比较内容。</p><p id="b9e7" class="pw-post-body-paragraph kz la it lb b lc mx le lf lg my li lj lk mz lm ln lo na lq lr ls nb lu lv lw im bi translated">如果它们不同，它将加密明文版本并替换加密版本。请注意，我总是将明文版本视为真理，因为开发人员更了解明文而不是密码文本。</p><figure class="mp mq mr ms gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ng"><img src="../Images/861e1a913d4cc224724ec7c5dd8811e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xB1IlAYuVZ9KYgBLCjGyKA.png"/></div></div></figure><p id="72e2" class="pw-post-body-paragraph kz la it lb b lc mx le lf lg my li lj lk mz lm ln lo na lq lr ls nb lu lv lw im bi translated">如果内容实际上是相同的，它不会加密文件。它解决了我们的第一个问题。</p><p id="c95f" class="pw-post-body-paragraph kz la it lb b lc mx le lf lg my li lj lk mz lm ln lo na lq lr ls nb lu lv lw im bi translated">但是，钩子仍然修改加密文件的最后更新时间。这是为了防止钩子在以后的提交中反复比较未修改的文件。</p><figure class="mp mq mr ms gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nh"><img src="../Images/3bac6a854e98804d0e5b2f3050b355a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hj4gaxVhZfbQI42e1K4uSQ.png"/></div></div></figure><p id="efbb" class="pw-post-body-paragraph kz la it lb b lc mx le lf lg my li lj lk mz lm ln lo na lq lr ls nb lu lv lw im bi translated">最后是<code class="fe ly lz ma mb b">anyFileChanged</code>旗。如果有任何机密文件被更改，用户将会得到通知，提交将会被非零退出代码终止。</p><p id="bad0" class="pw-post-body-paragraph kz la it lb b lc mx le lf lg my li lj lk mz lm ln lo na lq lr ls nb lu lv lw im bi translated">用户现在可以暂存新加密的文件并再次提交。</p><h2 id="f441" class="mc kc it bd kd md me dn kh mf mg dp kl lk mh mi kp lo mj mk kt ls ml mm kx mn bi translated">3.后合并和后重写</h2><p id="2c1c" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">这两个钩子实际上在做同样的事情。两者的区别在于<code class="fe ly lz ma mb b"><a class="ae lx" href="https://github.com/richardfan1126/sops-githooks/blob/master/hooks/post-merge" rel="noopener ugc nofollow" target="_blank">post-merge</a></code>会在<code class="fe ly lz ma mb b">git merge</code>之后触发，而<code class="fe ly lz ma mb b"><a class="ae lx" href="https://github.com/richardfan1126/sops-githooks/blob/master/hooks/post-rewrite" rel="noopener ugc nofollow" target="_blank">post-rewrite</a></code>会在<code class="fe ly lz ma mb b">git rebase</code>之后触发。开发人员通常通过合并或重定基础来拉远程更新，所以我将解密过程包含在这两个钩子中。</p><p id="fc15" class="pw-post-body-paragraph kz la it lb b lc mx le lf lg my li lj lk mz lm ln lo na lq lr ls nb lu lv lw im bi translated">注意，这两个钩子是在动作之后触发的。所以远程文件已经更新到本地。</p><p id="e3b6" class="pw-post-body-paragraph kz la it lb b lc mx le lf lg my li lj lk mz lm ln lo na lq lr ls nb lu lv lw im bi translated"><code class="fe ly lz ma mb b">post-rewrite</code>实际上是调用<code class="fe ly lz ma mb b">post-merge</code>文件，所以我们可以简单地进入<code class="fe ly lz ma mb b">post-merge</code>。</p><p id="a050" class="pw-post-body-paragraph kz la it lb b lc mx le lf lg my li lj lk mz lm ln lo na lq lr ls nb lu lv lw im bi translated">像<code class="fe ly lz ma mb b">pre-commit</code>一样，钩子先在秘密文件列表上循环，并为加密版本生成相应的文件名。然后，它检查明文版本是否存在。如果没有，它会通过解密加密版本来创建一个。</p><figure class="mp mq mr ms gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ni"><img src="../Images/095b7cbd7a585b2dae72c51f43135c8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Icr2Pz7CdovtVstRFq9lQQ.png"/></div></div></figure><p id="ed4e" class="pw-post-body-paragraph kz la it lb b lc mx le lf lg my li lj lk mz lm ln lo na lq lr ls nb lu lv lw im bi translated">如果明文版本存在，钩子的主要部分就会发生。首先，钩子将检查当前pull中是否包含秘密文件。我通过在<code class="fe ly lz ma mb b">HEAD</code>(我们当前所在的提交)和<code class="fe ly lz ma mb b">ORIG_HEAD</code>(合并/重定基础之前的提交)上运行<code class="fe ly lz ma mb b">git diff-tree</code>来完成这个任务，并查看文件是否在这个diff中。</p><p id="54c9" class="pw-post-body-paragraph kz la it lb b lc mx le lf lg my li lj lk mz lm ln lo na lq lr ls nb lu lv lw im bi translated">如果文件已经被更改，钩子将对当前的明文版本和新更新的文件执行<code class="fe ly lz ma mb b">diff</code>，并将结果显示给用户。</p><p id="2684" class="pw-post-body-paragraph kz la it lb b lc mx le lf lg my li lj lk mz lm ln lo na lq lr ls nb lu lv lw im bi translated">我已经说过了，我一直把明文版本当做真理，所以钩子不会直接替换本地版本。它提示用户文件是如何被改变的，并让用户决定如何合并两个版本。</p><h1 id="abeb" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">限制</h1><h2 id="f0b6" class="mc kc it bd kd md me dn kh mf mg dp kl lk mh mi kp lo mj mk kt ls ml mm kx mn bi translated"><strong class="ak"> 1。仅适用于CLI </strong></h2><p id="cbba" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">正如你所看到的，钩子依靠<code class="fe ly lz ma mb b">echo</code>来提示用户文件的改变。虽然它在CLI上工作，但不能保证GUI git客户端会将这些<code class="fe ly lz ma mb b">echo</code>输出重定向到用户。</p><p id="270a" class="pw-post-body-paragraph kz la it lb b lc mx le lf lg my li lj lk mz lm ln lo na lq lr ls nb lu lv lw im bi translated">我在VS代码上测试过，它在<code class="fe ly lz ma mb b">pre-commit</code>钩子上工作。正确显示<strong class="lb iu">“$ origin file已修改，请重新提交”</strong>消息在警告框上，并停止提交。但是在<code class="fe ly lz ma mb b">post-merge</code> hook上，虽然我的秘密文件已经在远程树上被修改了，它还是默默地完成了拉的动作。</p><h2 id="dcbd" class="mc kc it bd kd md me dn kh mf mg dp kl lk mh mi kp lo mj mk kt ls ml mm kx mn bi translated">2.用户可以忽略冲突提示</h2><p id="bb1a" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">在<strong class="lb iu"> </strong> <code class="fe ly lz ma mb b">post-merge</code>钩子上，我提示用户解决冲突。然而，它并不像git那样强制执行，用户可能会忽略冲突，将他们自己的版本提交到远程树并覆盖他们队友的工作。</p><h2 id="1f08" class="mc kc it bd kd md me dn kh mf mg dp kl lk mh mi kp lo mj mk kt ls ml mm kx mn bi translated">3.Git操作很复杂</h2><p id="ada3" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">钩子可能在大多数情况下都有效。然而，Git有许多不同的特性，如<code class="fe ly lz ma mb b">stash</code>、<strong class="lb iu">、</strong>、<strong class="lb iu">、</strong>、<code class="fe ly lz ma mb b">squash</code>等。结合所有的动作，有许多组合，很难测试这些钩子在那些情况下如何动作。</p></div></div>    
</body>
</html>