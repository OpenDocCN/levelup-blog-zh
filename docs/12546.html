<html>
<head>
<title>Multi-Stage Docker Layer Caching using Kaniko + Cloud Build</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Kaniko +云构建的多级Docker层缓存</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/multi-stage-docker-layer-caching-using-kaniko-cloud-build-7e46395fb2c2?source=collection_archive---------8-----------------------#2022-06-19">https://levelup.gitconnected.com/multi-stage-docker-layer-caching-using-kaniko-cloud-build-7e46395fb2c2?source=collection_archive---------8-----------------------#2022-06-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="ac8c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">简要介绍如何在云构建中使用Kaniko，并验证多阶段Docker映像是否被正确缓存。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ko"><img src="../Images/bcd54b61c3d620c2bb399d3835054c73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1268/format:webp/1*wbo-bzU0yI21_o2FEH6wbw.png"/></div></figure><h1 id="94b4" class="kw kx it bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">GitHub知识库</h1><p id="f8e4" class="pw-post-body-paragraph jq jr it js b jt lu jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn im bi translated">要查看使用的代码，请查看我为本文创建的<a class="ae lz" href="https://github.com/mr-pascal/medium-cloud-build-kaniko" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>。</p><div class="ma mb gp gr mc md"><a href="https://github.com/mr-pascal/medium-cloud-build-kaniko" rel="noopener  ugc nofollow" target="_blank"><div class="me ab fo"><div class="mf ab mg cl cj mh"><h2 class="bd iu gy z fp mi fr fs mj fu fw is bi translated">GitHub-Mr-Pascal/medium-cloud-build-kaniko</h2><div class="mk l"><h3 class="bd b gy z fp mi fr fs mj fu fw dk translated">在GitHub上创建一个帐户，为Mr-Pascal/medium-cloud-build-kaniko开发做出贡献。</h3></div><div class="ml l"><p class="bd b dl z fp mi fr fs mj fu fw dk translated">github.com</p></div></div><div class="mm l"><div class="mn l mo mp mq mm mr ku md"/></div></div></a></div><h1 id="2b6f" class="kw kx it bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">设置</h1><p id="c2bb" class="pw-post-body-paragraph jq jr it js b jt lu jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn im bi translated">如果您想从头开始这个演示，您可以遵循下面的步骤，或者在签出存储库之后直接跳到下面的“构建并运行Docker映像”部分。</p><p id="f22c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们快速看一下一般的文件结构。对于每一种框架和编程语言，我们需要的通用文件结构看起来都是一样的。</p><pre class="kp kq kr ks gt ms mt mu mv aw mw bi"><span id="a097" class="mx kx it mt b gy my mz l na nb">|-kaniko-demo<br/>  |- ... // some other files (e.g. src) for the application<br/>  |- Dockerfile<br/>  |- .dockerignore<br/>  |- cloudbuild.yaml</span></pre><ul class=""><li id="9e64" class="nc nd it js b jt ju jx jy kb ne kf nf kj ng kn nh ni nj nk bi translated"><code class="fe nl nm nn mt b">kaniko-demo</code> —应用程序文件夹包含所有源文件、依赖关系定义等。</li><li id="6e01" class="nc nd it js b jt no jx np kb nq kf nr kj ns kn nh ni nj nk bi translated"><code class="fe nl nm nn mt b">Dockerfile</code>—Docker file Docker和Kaniko应该用来构建Docker容器</li><li id="ab01" class="nc nd it js b jt no jx np kb nq kf nr kj ns kn nh ni nj nk bi translated"><code class="fe nl nm nn mt b">.dockerignore</code> —该文件定义了在Docker构建上下文中要忽略的文件。如果不存在<code class="fe nl nm nn mt b">.gcloudignore</code>文件，Cloud Build也会使用该文件来忽略文件。</li><li id="26ed" class="nc nd it js b jt no jx np kb nq kf nr kj ns kn nh ni nj nk bi translated"><code class="fe nl nm nn mt b">cloudbuild.yaml</code> —用于定义云构建应该执行的步骤的YAML配置。</li></ul><p id="923d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们从头开始，使用<a class="ae lz" href="https://nestjs.com/" rel="noopener ugc nofollow" target="_blank"> Nest.js </a>创建一个新的简单web服务器。当然，你可以自由选择任何你想要的编程语言或框架。</p><pre class="kp kq kr ks gt ms mt mu mv aw mw bi"><span id="daa0" class="mx kx it mt b gy my mz l na nb">// Create new Nest.js app<br/>nest new kaniko-demo</span></pre><p id="fb7d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，通过<code class="fe nl nm nn mt b">npm run start:dev</code>运行应用程序，以验证它正在工作。它应该在端口3000启动一个web服务器，并且可以通过<code class="fe nl nm nn mt b">localhost:3000</code>访问。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="nu nv di nw bf nx"><div class="gh gi nt"><img src="../Images/f5db0f93f5a9bac56f8416038a8b6ef0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XxUMEiWOeJpjfe0A_YXvJQ.png"/></div></div><figcaption class="ny nz gj gh gi oa ob bd b be z dk translated">npm运行开始:开发</figcaption></figure><p id="15eb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">之后，在Nest.js <code class="fe nl nm nn mt b">kaniko-demo</code>文件夹中添加一个<code class="fe nl nm nn mt b">Dockerfile</code>和<code class="fe nl nm nn mt b">.dockerignore</code>文件。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="3807" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe nl nm nn mt b">Dockerfile</code>应该包含一个多阶段构建，以便稍后展示多阶段层缓存正在工作。如果不是使用Nest.js，必须自带多级Dockerfile。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="oc od l"/></div></figure><h2 id="01f2" class="mx kx it bd ky oe of dn lc og oh dp lg kb oi oj lk kf ok ol lo kj om on ls oo bi translated">构建并运行Docker映像</h2><p id="6ec4" class="pw-post-body-paragraph jq jr it js b jt lu jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn im bi translated">您可以使用以下命令在本地机器上构建并运行Docker映像。首先，确保您在docker文件所在的应用程序文件夹中。</p><pre class="kp kq kr ks gt ms mt mu mv aw mw bi"><span id="55b5" class="mx kx it mt b gy my mz l na nb"># Build "kaniko-demo" app on your local machine<br/>docker build -t kaniko-demo .</span><span id="d718" class="mx kx it mt b gy op mz l na nb"># Run local container in detached mode<br/>docker run -d -p 3000:3000 kaniko-demo</span></pre><p id="7b1b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，您可以在<code class="fe nl nm nn mt b">localhost:3000</code>打开您的浏览器，并验证您的服务器已经启动并正在运行，正在为请求提供服务。</p><h2 id="0553" class="mx kx it bd ky oe of dn lc og oh dp lg kb oi oj lk kf ok ol lo kj om on ls oo bi translated">转向云构建</h2><p id="cd04" class="pw-post-body-paragraph jq jr it js b jt lu jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn im bi translated">接下来，让我们在云构建上构建这个Docker映像。</p><p id="e3ae" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，您应该通过以下命令在您的计算机上设置默认的GCP项目:</p><pre class="kp kq kr ks gt ms mt mu mv aw mw bi"><span id="3261" class="mx kx it mt b gy my mz l na nb"># Set GCP project<br/>gcloud config set project &lt;project&gt;</span></pre><p id="fde6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">或者，您可以在实际的<code class="fe nl nm nn mt b">gcloud builds submit</code>命令上添加<code class="fe nl nm nn mt b">--project &lt;project&gt;</code>标志，为执行的命令显式地设置项目。</p><p id="2e37" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，让我们定义<code class="fe nl nm nn mt b">cloudbuild.yaml</code>，并将这个文件添加到应用程序文件夹，这样Cloud Build就知道它应该在哪个上下文中运行哪个命令。</p><p id="d00a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">值得注意的是，默认情况下，Kaniko会搜索一个用于构建映像的<code class="fe nl nm nn mt b">Dockerfile</code>文件。如果您的文件命名不同，您需要通过<code class="fe nl nm nn mt b">--dockerfile=Dockerfile</code>向Kaniko容器提供它应该使用的文件。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="8bb1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，让我们最后在云构建上运行构建步骤。接下来，您会看到命令的一般签名，以及一些预先填充的有效值。</p><pre class="kp kq kr ks gt ms mt mu mv aw mw bi"><span id="11a0" class="mx kx it mt b gy my mz l na nb">## Build "kaniko-demo" app on Cloud Build</span><span id="1902" class="mx kx it mt b gy op mz l na nb"># General signature<br/>gcloud builds submit --region &lt;region&gt; \<br/>  --config &lt;path_to_cloudbuild_yaml&gt; \<br/>  &lt;path_to_build_context&gt;</span><span id="74ff" class="mx kx it mt b gy op mz l na nb"># Build "kaniko-demo" app on Cloud Build<br/>gcloud builds submit --region europe-west2 \<br/>  --config cloudbuild.yaml \<br/>  .</span></pre><p id="201f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我执行了以下操作来验证多阶段是否按预期进行了缓存。</p><ol class=""><li id="dd7e" class="nc nd it js b jt ju jx jy kb ne kf nf kj ng kn oq ni nj nk bi translated">通过以下方式构建映像→请注意，这花费了大约1分34秒</li><li id="2a92" class="nc nd it js b jt no jx np kb nq kf nr kj ns kn oq ni nj nk bi translated">重建图像，不做任何改变→时间下降到37秒</li><li id="a1a3" class="nc nd it js b jt no jx np kb nq kf nr kj ns kn oq ni nj nk bi translated">在<code class="fe nl nm nn mt b">src/app.service.ts</code>文件中做了一个更改，保存了更改，并第三次构建了映像→注意，现在构建花了1m秒。</li></ol><p id="2f94" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在下面的两张图片中，您可以看到我刚刚提到的构建的持续时间；推送至GCR的Docker图像和Kaniko存储缓存图层的“缓存”文件夹。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="nu nv di nw bf nx"><div class="gh gi or"><img src="../Images/794d26c4e94f502ae5bb067b6f14722e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SUe-5n2O0jam9mKHW8447g.png"/></div></div><figcaption class="ny nz gj gh gi oa ob bd b be z dk translated">云构建构建时间</figcaption></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="nu nv di nw bf nx"><div class="gh gi os"><img src="../Images/fcf7acbc45c03dd5405a91aa378d0e9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HPAgYWgWKBGsriMhRyZr-Q.png"/></div></div><figcaption class="ny nz gj gh gi oa ob bd b be z dk translated">Google容器注册表——内置图像</figcaption></figure><p id="af73" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了验证云构建不仅仅是因为不同的CPU容量或其他原因而有一些快速和慢速的构建，让我们更深入地挖掘上一次构建的构建日志。</p><p id="fccb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我在构建日志中标记了两个重要部分，以显示多阶段缓存是可行的。</p><p id="22cb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第一个是<code class="fe nl nm nn mt b">Using caching version of cmd: RUN npm ci</code>和<code class="fe nl nm nn mt b">Found cached layer, extracting fo filesystem</code>。这些行表明Kaniko找到了一个用于安装NPM依赖项的缓存层并使用了它。</p><p id="9f5b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">类似，但是另一边也有日志<code class="fe nl nm nn mt b">No cached layer found for cmd RUN npm run build</code>，我们可以看到日志中执行了<code class="fe nl nm nn mt b">RUN npm run build</code>语句。</p><p id="9534" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上面提到的代码行验证了Kaniko缓存了我们的多阶段Docker映像的构建阶段。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/b5cdd934ccd8415b5883ce0717fdb39c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1038/format:webp/1*rPSc5jyw3gvVQzGZTsEjVw.png"/></div><figcaption class="ny nz gj gh gi oa ob bd b be z dk translated">云构建日志</figcaption></figure><h2 id="b207" class="mx kx it bd ky oe of dn lc og oh dp lg kb oi oj lk kf ok ol lo kj om on ls oo bi translated">你想联系吗？</h2><p id="6350" class="pw-post-body-paragraph jq jr it js b jt lu jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn im bi translated">如果你想联系我，请在LinkedIn上打电话给我。</p><p id="c598" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另外，请随意查看我的书籍推荐📚。</p></div><div class="ab cl ou ov hx ow" role="separator"><span class="ox bw bk oy oz pa"/><span class="ox bw bk oy oz pa"/><span class="ox bw bk oy oz"/></div><div class="im in io ip iq"><div class="kp kq kr ks gt md"><a href="https://mr-pascal.medium.com/my-book-recommendations-4b9f73bf961b" rel="noopener follow" target="_blank"><div class="me ab fo"><div class="mf ab mg cl cj mh"><h2 class="bd iu gy z fp mi fr fs mj fu fw is bi translated">我的书籍推荐</h2><div class="mk l"><h3 class="bd b gy z fp mi fr fs mj fu fw dk translated">在接下来的章节中，你可以找到我对所有日常生活话题的书籍推荐，它们对我帮助很大。</h3></div><div class="ml l"><p class="bd b dl z fp mi fr fs mj fu fw dk translated">mr-pascal.medium.com</p></div></div><div class="mm l"><div class="pb l mo mp mq mm mr ku md"/></div></div></a></div><div class="ma mb gp gr mc md"><a href="https://mr-pascal.medium.com/membership" rel="noopener follow" target="_blank"><div class="me ab fo"><div class="mf ab mg cl cj mh"><h2 class="bd iu gy z fp mi fr fs mj fu fw is bi translated">通过我的推荐链接加入Medium—Pascal Zwikirsch</h2><div class="mk l"><h3 class="bd b gy z fp mi fr fs mj fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="ml l"><p class="bd b dl z fp mi fr fs mj fu fw dk translated">mr-pascal.medium.com</p></div></div><div class="mm l"><div class="pc l mo mp mq mm mr ku md"/></div></div></a></div></div></div>    
</body>
</html>