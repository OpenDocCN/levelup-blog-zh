<html>
<head>
<title>XSRF Protection with Angular and Express</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带角度和快速的XSRF保护</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/xsrf-protection-with-angular-and-express-d084c6e57da5?source=collection_archive---------4-----------------------#2020-03-15">https://levelup.gitconnected.com/xsrf-protection-with-angular-and-express-d084c6e57da5?source=collection_archive---------4-----------------------#2020-03-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/219828ce2781b55206b4c1c9bf53ca36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9bHEJAbZeJd-daFQ_CyUGg.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@icons8?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Icons8团队</a>在<a class="ae kf" href="https://unsplash.com/s/photos/security-computer?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="1b7a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">作为一名web开发人员，保护应用程序的安全性是您工作的一部分。最常见的漏洞之一是XSS，但是XSRF也代表了一个您不应该低估的风险。幸运的是，如果您正在构建Angular/Express应用程序，保护您的用户是非常容易的。</p><h1 id="dc7b" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">XSRF是什么？</h1><p id="58da" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">XSRF(或CSRF，因此有时读作“<em class="mh">海上冲浪</em>”)代表跨站请求伪造。</p><p id="fc1f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设我想在社交媒体平台上查看我丈夫的聊天记录<a class="ae kf" href="http://www.unsafe.com." rel="noopener ugc nofollow" target="_blank"><em class="mh">www.unsafe.com</em></a><em class="mh">。</em>通过打开网络选项卡浏览网站，我注意到为了更改密码，<a class="ae kf" href="http://www.unsafe.com" rel="noopener ugc nofollow" target="_blank"><em class="mh">www.unsafe.com</em></a>向url发出一个GET请求<em class="mh">www.unsafe.com/changePassword?password=123456.</em>(发送一个GET请求很奇怪，但无论如何我们可以从技术上找到一种方法使它与另一种请求类型一起工作。)</p><p id="0747" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">突然发出这种请求通常是行不通的。后端应该会收到一些带有请求的cookies，用于识别。如果我丈夫登录了他的账户，如果我能让他点击链接<em class="mh">www.unsafe.com/changePassword?password=123456</em>(例如，通过给他发电子邮件向他保证这是一张滑稽的猫图片)，所有的cookies都会出现，服务器会接受请求。从服务器端来看，没有办法知道请求是否合法。它是由正确的客户端使用正确的cookies发出的。密码会被更改，我就能进入他的账户。</p><p id="a619" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这不是那么容易利用，因为你必须找到可复制的链接，真正的损害，你需要一点运气，因为受害者必须登录到目标网站。现在，如果你的目标是一个真正的主流社交媒体平台，或者如果你设法获得了一个给定网站的所有用户的电子邮件地址…大奖！</p><h1 id="66f5" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">如何保护自己的网站？</h1><p id="e861" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">您可能会发现的一个常见建议是只使用POST请求。虽然这使得它更难被利用，但仍然有可能诱骗受害者发出POST请求。</p><p id="058d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们必须找到一种方法，让服务器理解一个请求何时合法，何时不合法，即使它有所有正确的cookies和正确的来源。一种常见的机制，也是Angular HttpClient默认支持的机制，是使用X-XSRF-TOKEN。</p><p id="acfb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">想法很简单:服务器不能依赖会话cookie或令牌cookie，因为它们是由浏览器自动设置的。但是，如果前端使用JavaScript，它可以为每个请求设置一个<strong class="ki iu">头</strong>。</p><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="d0d5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您的JavaScript代码必须在浏览器选项卡中运行，请求从该选项卡发出，以便设置这个头。来自点击电子邮件链接的请求将没有正确的标题。如果您的服务器需要这个头并拒绝所有不提供它的请求，那么您就可以免受这种攻击。</p><p id="59d0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这个例子中，我的令牌是硬编码的<em class="mh">【令牌】</em>，这当然不是它的工作方式。当前端向服务器发送第一个请求时，服务器为其响应设置一个XSRF-TOKEN cookie。JavaScript代码截取该令牌并将其保存在某个地方。只有运行在同一原点的JavaScript才能访问这个令牌。这个令牌每次都会改变。当发送任何新请求时，JavaScript代码将在<strong class="ki iu">头</strong>中设置一个X-XSRF-TOKEN。如果头部丢失，服务器知道请求不是由它的客户机发送的，可能是不合法的。</p><h1 id="fc36" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">Express和Angular示例</h1><h2 id="8b9a" class="mo lf it bd lg mp mq dn lk mr ms dp lo kr mt mu ls kv mv mw lw kz mx my ma mz bi translated">服务器端:发送XSRF-令牌</h2><p id="72d7" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">保护机制的第一步发生在服务器上。在这个例子中，我使用了Express框架和TypeScript。</p><p id="1963" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">每个XSRF-TOKEN都必须是唯一且不可预测的。有一个很好的库为我们处理大部分工作:<a class="ae kf" href="https://www.npmjs.com/package/csurf" rel="noopener ugc nofollow" target="_blank"> csurf </a></p><p id="9cf9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以像安装任何npm软件包一样安装它</p><pre class="mi mj mk ml gt na nb nc nd aw ne bi"><span id="acee" class="mo lf it nb b gy nf ng l nh ni">npm i csurf — save</span></pre><p id="e668" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">并安装它的类型包，就像我们使用TypeScript一样(如果没有，请跳过它)。</p><pre class="mi mj mk ml gt na nb nc nd aw ne bi"><span id="1b88" class="mo lf it nb b gy nf ng l nh ni">npm i @types/csurf — save-dev</span></pre><p id="736f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">根据文档，我们还需要<a class="ae kf" href="https://www.npmjs.com/package/cookie-parser" rel="noopener ugc nofollow" target="_blank"> cookie-parser </a>，您可以用同样的方式安装。现在，我们可以在每个响应上设置XSRF-TOKEN cookie:</p><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="6fcf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们根据库文档启动XSRF令牌创建和验证中间件，有两个选项:</p><ul class=""><li id="0526" class="nj nk it ki b kj kk kn ko kr nl kv nm kz nn ld no np nq nr bi translated">cookie: true，将令牌秘密存储在cookie中(默认情况下，它存储在用户会话中，但在本例中我们没有会话)</li><li id="f8c4" class="nj nk it ki b kj ns kn nt kr nu kv nv kz nw ld no np nq nr bi translated">ignoreMethods: ['GET '，' HEAD '，' OPTIONS']。我们只需要检查令牌中可以改变数据的方法，在我们的例子中是POST、PUT和DELETE。如果您有可能改变数据的GET请求，比如我们前面的<em class="mh"> changePassword </em>请求，您不应该忽略GET。但是在这种情况下，您也应该考虑不使用GET。</li></ul><p id="e1e5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以看到，XSRF-TOKEN是作为cookie发送的。</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nx"><img src="../Images/f6dfeb62fadd90cc5a1ae31e1144fc03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*o-H7z56xatJUvWDv.png"/></div></div></figure><h2 id="192d" class="mo lf it bd lg mp mq dn lk mr ms dp lo kr mt mu ls kv mv mw lw kz mx my ma mz bi translated">客户端:拦截cookie并为每个请求设置令牌</h2><p id="358b" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">在客户端，我们需要获取该令牌，并将其添加到任何新请求的头中。</p><p id="3085" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这就是Angular的用武之地:它为我们做到了。如果您检查下一个请求的头，您将找到您的X-XSRF-TOKEN。</p><figure class="mi mj mk ml gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ny"><img src="../Images/f52517cba05c662cba7ac9b50ccdf96a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*jp-wJ6lqW-tIpyr5.png"/></div></div></figure><h1 id="d678" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">几个先决条件</h1><p id="470d" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">Angular为我们做了这项工作，但它的工作有几个先决条件:</p><ul class=""><li id="04af" class="nj nk it ki b kj kk kn ko kr nl kv nm kz nn ld no np nq nr bi translated">XSRF-TOKEN cookie必须是httpOnly: false。有道理，cookie需要由JavaScript访问。设置cookie时，您必须在后端设置此选项。</li><li id="200a" class="nj nk it ki b kj ns kn nt kr nu kv nv kz nw ld no np nq nr bi translated">前端和后端必须有相同的来源。如果您的前端和后端运行在不同的端口上，您可以使用代理将您的请求重定向到后端:</li><li id="5afc" class="nj nk it ki b kj ns kn nt kr nu kv nv kz nw ld no np nq nr bi translated">创建一个proxy.conf.json文件:</li></ul><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="mm mn l"/></div></figure><ul class=""><li id="766f" class="nj nk it ki b kj kk kn ko kr nl kv nm kz nn ld no np nq nr bi translated">在您的HTTP服务中，将路径<em class="mh"/><a class="ae kf" href="http://localhost:8080/api" rel="noopener ugc nofollow" target="_blank"><em class="mh">HTTP://localhost:8080/API</em></a>替换为<em class="mh"> /api。</em>代理将正确地重定向它们。</li><li id="b348" class="nj nk it ki b kj ns kn nt kr nu kv nv kz nw ld no np nq nr bi translated">在package.json中，将启动脚本更改为:</li></ul><pre class="mi mj mk ml gt na nb nc nd aw ne bi"><span id="c364" class="mo lf it nb b gy nf ng l nh ni">"start": "ng serve --proxy-config proxy.conf.json"</span></pre></div><div class="ab cl nz oa hx ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="im in io ip iq"><p id="efbe" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Angular我们负责设置头中的XSRF令牌，保护您的应用程序免受XSRF攻击，只需要您在后端实现令牌生成和请求验证部分。库，比如我们在例子中使用的库，使得使用Express变得非常容易，但是我假设所有类型的后端都有类似的库。</p><p id="c383" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我希望这篇文章对你有用。</p></div></div>    
</body>
</html>