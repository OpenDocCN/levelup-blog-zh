<html>
<head>
<title>The „D“ in SOLID Software Architecture — Dependency Inversion Principle</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">固体软件体系结构中的“D”——依赖倒置原则</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/the-d-in-solid-software-architecture-dependency-inversion-principle-80603f29ef77?source=collection_archive---------19-----------------------#2020-07-16">https://levelup.gitconnected.com/the-d-in-solid-software-architecture-dependency-inversion-principle-80603f29ef77?source=collection_archive---------19-----------------------#2020-07-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="475f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">“D”代表依赖倒置，提倡依赖抽象而非具体实现。</h2></div><p id="9614" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当开发新系统时，通常很容易注意到创建模块化结构和遵守<a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/the-s-in-solid-5a6e0d778cbc">单一责任原则</a>。因此，人们通常首先构建负责特定任务的模块，然后在业务逻辑中使用它们。</p><p id="5e0b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，这通常会带来一个缺点:这些系统通常是紧密耦合的，因为业务逻辑直接依赖于底层模块。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi lc"><img src="../Images/7fd46b8c17953281663535696a959a04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wYppwlqMQ5qQZfoA"/></div></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk translated">不要构建棘手的系统。(照片由<a class="ae lb" href="https://unsplash.com/@nzdoug16?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">道格拉斯·巴格</a>拍摄)</figcaption></figure><p id="77fa" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">依赖性倒置意味着改变(“倒置”)这种关系。与其直接引用底层模块，不如引用它的抽象。</p><p id="b8b7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们看一个类似于<a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/the-o-in-solid-software-architecture-open-closed-principle-ccdb25bbecd2">开闭原理</a>的例子。实际上，这种相似性并不奇怪，因为这两个原则通过消除代码中的紧密耦合而相互受益。</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="fec2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lv lw lx ly b">NotificationHandler</code>实例化<code class="fe lv lw lx ly b">EmailBroadcaster</code>(因此使其成为直接依赖项)并在以后调用它。这导致了以下问题:</p><ul class=""><li id="8cc3" class="lz ma iq kh b ki kj kl km ko mb ks mc kw md la me mf mg mh bi translated">处理程序不容易测试，因为无法模拟真实的<code class="fe lv lw lx ly b">EmailBroadcaster</code>——需要同时测试两者</li><li id="9b44" class="lz ma iq kh b ki mi kl mj ko mk ks ml kw mm la me mf mg mh bi translated">处理程序依赖于低级模块，这意味着它受该低级模块中的变化的影响</li></ul><p id="a144" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一个潜在的解决方案可能如下所示:</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="749c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这种情况下，<code class="fe lv lw lx ly b">NotificationHandler</code>不需要任何关于<code class="fe lv lw lx ly b">EmailBroadcaster</code>实现的知识。它需要知道的是，给定一个“广播者”,它可以发送通知。</p><p id="d2fc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过将<code class="fe lv lw lx ly b">Broadcaster</code>接口放在两个类之间并颠倒关系，我们去除了紧密耦合，现在可以享受<strong class="kh ir">简单测试</strong>和一个<strong class="kh ir">不太容易受到低级变化的连锁反应</strong>的系统。</p><p id="4e32" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可能已经注意到,“新”关键词并没有完全消失。它仅仅向上移动了一级，进入<code class="fe lv lw lx ly b">onAccountCreated</code>功能。理论上，这将导致与<code class="fe lv lw lx ly b">NotificationHandler</code>中类似的问题。</p><p id="5a2a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就是“控制容器倒置”(简称IoC容器)发挥作用的地方。通过管理模块之间的所有依赖关系，它们允许更高层次的抽象，例如通过将它们自动注入到类的构造函数中。</p><p id="3580" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">大多数现代框架都具备这种开箱即用的“自动连线”能力。在我们的例子中，<code class="fe lv lw lx ly b">onAccountCreated</code>函数很可能是模块的一部分，可以通过我们自己的或框架IoC容器连接起来。然后<code class="fe lv lw lx ly b">NotificationHandler</code>将通过容器被实例化，并直接提供给我们可以全局配置的广播器。</p></div><div class="ab cl mn mo hu mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ij ik il im in"><p id="34ce" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">依赖性反转是一个强大的概念，它允许构建更加模块化的系统，并且能够更快地适应不断变化的需求。该原则是五项坚实原则中的最后一项。</p></div><div class="ab cl mn mo hu mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ij ik il im in"><p id="2991" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我的博客上注册<a class="ae lb" href="http://blog.richartkeil.com" rel="noopener ugc nofollow" target="_blank">，就能收到关于新帖子的电子邮件通知。</a></p></div></div>    
</body>
</html>