<html>
<head>
<title>Redux Basics</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Redux基础</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/redux-basics-cebf8e921f3?source=collection_archive---------2-----------------------#2019-02-18">https://levelup.gitconnected.com/redux-basics-cebf8e921f3?source=collection_archive---------2-----------------------#2019-02-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/f90c35636c10bee5167aa38425b91218.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T_-NaFaHus_yTblauq3QWw.png"/></div></div></figure><p id="ebe3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在Redux的世界里有很多术语。动作、动作创建者、动作类型、归约者、根归约者……这些都是什么？在所有复杂的术语背后，有一些简单的代码极大地改进了我们组织和编写React应用程序的方式。在这篇文章中，我将尝试解释一些基本的Redux概念。我们还将了解一些与React和Redux一起使用的常用npm包。</p><p id="b301" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了说明和解释Redux基础知识，我们将使用一个超级简单的React应用程序。我们将构建一个组件，该组件返回一个按钮元素，用户可以单击该元素来切换和显示一些文本。就像我说的，超级简单！</p><p id="2423" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" href="https://github.com/catedm/super-basic-redux-example" rel="noopener ugc nofollow" target="_blank"> <em class="kx">在这里查看代码。</em> </a></p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="997e" class="lh li iq ld b gy lj lk l ll lm">redux-example<br/>  node_modules<br/>  public<br/>  src<br/>    actions<br/>      actions.js<br/>      types.js<br/>    components<br/>      Toggle.js<br/>    reducers<br/>      toggle.js<br/>    App.js<br/>    index.js<br/>    rootReducer.js<br/>    serviceWorker.js<br/>.gitignore<br/>package-json.lock<br/>package.json<br/>README.md<br/>yarn.lock</span></pre><p id="1c48" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们要仔细查看的文件是嵌套在<code class="fe ln lo lp ld b">src</code>文件夹下的所有文件，还有<code class="fe ln lo lp ld b">rootReducer.js</code>文件和<code class="fe ln lo lp ld b">App.js</code></p><p id="2322" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们从分解行动开始。</p><h1 id="e6c5" class="lq li iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">行动</h1><p id="8fd7" class="pw-post-body-paragraph jy jz iq ka b kb mn kd ke kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ij bi translated"><a class="ae kw" href="https://redux.js.org/basics/actions" rel="noopener ugc nofollow" target="_blank">Redux文档</a>将动作定义为“将数据从应用程序发送到商店的信息负载”(先不要担心商店是什么，我们稍后会将所有内容联系在一起)。Redux文档很好地定义了动作。动作并不复杂；事实上，一个动作只是一个普通的Javascript对象。看一下下面的例子:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="abc3" class="lh li iq ld b gy lj lk l ll lm">// We'll talk about this line of code a little later<br/>import { TOGGLE_MESSAGE_VISIBILITY } from './types';</span><span id="1dfb" class="lh li iq ld b gy ms lk l ll lm">// A basic Redux action (it's just a Javascript object)<br/>{ type: TOGGLE_MESSAGE_VISIBILITY }</span></pre><p id="5532" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面代码的第4行是有效的Redux操作。它只是一个Javascript对象！Redux中的动作必须有一个<code class="fe ln lo lp ld b">type</code>属性来指示正在执行的动作的类型。你可以随便叫他们什么，但他们应该试图解释正在执行的动作。除此之外，您可以自由地将对您的应用程序有意义的任何属性添加到您的特定操作中。但是第1行的import语句发生了什么呢？您经常会在React/Redux应用程序中看到这种模式。请注意，在我们项目的actions目录下，有一个名为<code class="fe ln lo lp ld b">types.js</code>的文件，如下所示:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="a4c3" class="lh li iq ld b gy lj lk l ll lm">export const TOGGLE_MESSAGE_VISIBILITY = 'TOGGLE_MESSAGE_VISIBILITY';</span></pre><p id="9023" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这些被称为<em class="kx">类型动作常量</em>，程序员喜欢使用它们的原因是为了代码组织(将我们所有的动作类型保存在一个文件中，然后根据具体情况将它们导入到其他文件中)以及防止在我们从reducers内部调用动作时出现错误。请记住这一点，稍后我会解释为什么这有助于防止减速器中的错误。</p><p id="0f1d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以我们的动作只是普通的Javascript对象。好的。太好了。现在怎么办？现在我们用我们的行动让<em class="kx">成为行动创造者。哦不，更多Redux行话</em>！不要被吓倒。动作创作者也非常简单。让我们来看一个动作创建器，它使用我们上面编写的动作:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="4dc9" class="lh li iq ld b gy lj lk l ll lm">import { TOGGLE_MESSAGE_VISIBILITY } from './types';</span><span id="3fb0" class="lh li iq ld b gy ms lk l ll lm">// this is our action creator. it's just a function that returns an object (our action!)<br/>export function toggleMe() {<br/>  return {<br/>    type: TOGGLE_MESSAGE_VISIBILITY,<br/>  }<br/>};</span></pre><p id="4abd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如您在上面看到的，我们的action creator只是一个返回我们的对象的plan javascript函数。它们是创建(返回)动作的函数！我们需要导出我们的动作创建器，因为我们最终将把它导入到我们的<code class="fe ln lo lp ld b">Toggle.js</code>组件文件中，以使用它来<em class="kx">分派</em>TOGGLE _ MESSAGE _ VISIBILITY动作。但是我们不要想太多！接下来让我们看看减速器。前进！</p><h1 id="99da" class="lq li iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">还原剂</h1><p id="0533" class="pw-post-body-paragraph jy jz iq ka b kb mn kd ke kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ij bi translated">在Redux应用程序中，应用程序状态存储为单个对象。当一个动作被发送到存储库时(我们将很快定义存储库)，reducers处理状态将如何响应该动作而改变。在应用程序的状态中，我们只跟踪一件事:我们的消息是否可见。让我们看看嵌套在reducers目录下的<code class="fe ln lo lp ld b">toggle.js</code>文件:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="5b76" class="lh li iq ld b gy lj lk l ll lm">// Now we will get to why this pattern prevents bugs<br/>import { TOGGLE_MESSAGE_VISIBILITY } from '../actions/types';</span><span id="2571" class="lh li iq ld b gy ms lk l ll lm">// Here we define the initial state of our application<br/>// Initially, our message is not visible<br/>const initialState = {<br/>  messageVisibility: false,<br/>}</span><span id="c703" class="lh li iq ld b gy ms lk l ll lm">// This is our REDUCER<br/>export default function (state = initialState, action) {<br/>  // here we pluck off action.type and store it in the const type<br/>  // using some es6 destructuring<br/>  const { type } = action;</span><span id="fb51" class="lh li iq ld b gy ms lk l ll lm">switch (type) {<br/>    case TOGGLE_MESSAGE_VISIBILITY: {<br/>      return {<br/>        ...state,<br/>        messageVisibility: !state.messageVisibility,<br/>      }<br/>    }<br/>    default: {<br/>      return state<br/>    }<br/>  }<br/>}</span></pre><p id="db21" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们从第一行开始。还记得我告诉过你使用<em class="kx">动作类型常量</em>将有助于防止我们代码中的错误吗？为了说明为什么会这样，我将在下面展示没有动作类型常量的代码。我将使用基本字符串，而不是使用我们传递给动作创建者和缩减者的动作类型常量。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="a607" class="lh li iq ld b gy lj lk l ll lm">// this is our actions &gt; actions.js file</span><span id="a80a" class="lh li iq ld b gy ms lk l ll lm">export function toggleMe() {<br/>  return {<br/>    type: "TOGGLE_MESSAGE_VISIBILITY",<br/>  }<br/>};</span><span id="5511" class="lh li iq ld b gy ms lk l ll lm">// this is our reducers &gt; toggle.js file</span><span id="342c" class="lh li iq ld b gy ms lk l ll lm">const initialState = {<br/>  messageVisibility: false,<br/>}</span><span id="434e" class="lh li iq ld b gy ms lk l ll lm">export default function (state = initialState, action) {<br/>  const { type } = action;<br/> <br/> // Notice the TYPO in "TOGLE_MESSAGE_VISIBILITY" instead of "TOGGLE_MESSAGE_VISIBILITY" below<br/>  switch (type) {<br/>    case "TOGLE_MESSAGE_VISIBILITY": {<br/>      return {<br/>        ...state,<br/>        messageVisibility: !state.messageVisibility,<br/>      }<br/>    }<br/>    default: {<br/>      return state<br/>    }<br/>  }<br/>}</span></pre><p id="4b85" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上面的例子中，我们没有使用动作类型常量来构建我们的动作创建器，而是使用了一个基本字符串。然后，在我们的reducer中，我们<em class="kx">拼错了</em>我们想要在switch语句中触发的动作(我们稍后将分解reducer语法)。上面代码的问题是，它不会做我们想要它做的事情，<strong class="ka ir"> <em class="kx">但是它不会产生错误</em> </strong>。代码仍然会运行，因为这是一个有效的字符串。然而，如果我们加载一个动作类型常量，然后拼错了<em class="kx">常量，</em> <strong class="ka ir">编译器将抛出一个错误，并告诉我们哪里出错了。</strong></p><p id="37bf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们理解了为什么我们使用动作类型常量，但是这个文件的其余部分是什么呢？我们从指定我们想要的初始状态开始。对我们来说，我们希望我们的信息最初是隐藏的:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="1215" class="lh li iq ld b gy lj lk l ll lm">const initialState = {<br/>  messageVisibility: false,<br/>}</span></pre><p id="c560" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">同样，这是一个非常简单的例子。在较大的应用程序中，初始状态下可能会有更多的属性。最后，让我们来分解实际的减速器:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="ff7a" class="lh li iq ld b gy lj lk l ll lm">export default function (state = initialState, action) {<br/>  const { type } = action;</span><span id="e402" class="lh li iq ld b gy ms lk l ll lm">switch (type) {<br/>    case TOGGLE_MESSAGE_VISIBILITY: {<br/>      return {<br/>        ...state,<br/>        messageVisibility: !state.messageVisibility,<br/>      }<br/>    }<br/>    default: {<br/>      return state<br/>    }<br/>  }<br/>}</span></pre><p id="8bcf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们从导出我们的减速器函数开始，因为<em class="kx">稍后我们将把我们所有的减速器加载到一个</em> <code class="fe ln lo lp ld b"><em class="kx">rootReducer.js</em></code> <em class="kx">文件中。我们很快就会谈到这一点。然后，我们将状态参数设置为上面编码的初始状态对象，然后传入我们的操作。在第2行，我们取出<code class="fe ln lo lp ld b">action.type</code>并使用ES6析构将其存储在常量<code class="fe ln lo lp ld b">type</code>中。</em></p><p id="7a82" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，我们开始讨论缩减器的真正内容:switch语句。我们的switch语句查看我们的动作类型，并根据我们希望该动作如何改变我们的状态来设置我们的状态。在我们这个简单的例子中，我们希望将<code class="fe ln lo lp ld b">messageVisibility</code>从<code class="fe ln lo lp ld b">false</code>切换到<code class="fe ln lo lp ld b">true</code>，反之亦然，以显示和隐藏我们的消息。</p><p id="4ba6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们仔细看看减速器的这一部分:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="ef98" class="lh li iq ld b gy lj lk l ll lm">case TOGGLE_MESSAGE_VISIBILITY: {<br/>  return {<br/>    ...state,<br/>    messageVisibility: !state.messageVisibility,<br/>  }<br/>}</span></pre><p id="53c5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ln lo lp ld b">…state</code>是干什么用的？记住，<em class="kx">我们永远不应该在React应用程序中直接改变我们的状态</em>。Javascript ES6中提供了上述语法。它的作用与下面的代码相同:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="9040" class="lh li iq ld b gy lj lk l ll lm">// This code does the same thing as the code above<br/>case TOGGLE_MESSAGE_VISIBILITY: {<br/>  return {<br/>      Object.assign({}, state, {<br/>          messageVisibility: !state.messageVisibility,<br/>      })<br/>  }<br/>}</span></pre><p id="0c13" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这将复制我们的状态，并更改我们想要更改的属性。在Redux中，我们不能改变我们的状态，而是必须返回它的一个副本。</p><p id="d48a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们已经设置好了我们的reducer，我们需要看看我们的<code class="fe ln lo lp ld b">rootReducer.js</code>文件和<code class="fe ln lo lp ld b">App.js</code>文件，以便将所有这些结合在一起。让我们来分解一下<code class="fe ln lo lp ld b">rootReducer.js</code>文件:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="a8eb" class="lh li iq ld b gy lj lk l ll lm">import { combineReducers } from 'redux';</span><span id="32d7" class="lh li iq ld b gy ms lk l ll lm">import toggle from './reducers/toggle';</span><span id="cb60" class="lh li iq ld b gy ms lk l ll lm">const rootReducer = combineReducers({<br/>  toggle<br/>});</span><span id="e3d8" class="lh li iq ld b gy ms lk l ll lm">export default rootReducer;</span></pre><p id="448f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们从从redux导入<code class="fe ln lo lp ld b">combineReducers</code>方法开始(这个例子有点做作，因为我们的<code class="fe ln lo lp ld b">combineReducers</code> <em class="kx"> </em>方法没有多个reducers，只是滚动了一下)。接下来，我们进口我们的<code class="fe ln lo lp ld b">toggle</code>减速器。然后我们调用<code class="fe ln lo lp ld b">combineReducers</code>方法，传入我们的<code class="fe ln lo lp ld b">toggle</code>缩减器，将结果保存到一个名为<code class="fe ln lo lp ld b">rootReducer</code>的常量中，我们在最后一行导出这个常量。</p><p id="ae79" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们已经将所有的reducers合并到一个const ( <code class="fe ln lo lp ld b">rootReducer</code>)中，供应用程序的其余部分使用。这很重要，因为<em class="kx">我们会用这个</em> <code class="fe ln lo lp ld b"><em class="kx">rootReducer</em></code> <em class="kx">来创建我们的</em> <code class="fe ln lo lp ld b"><em class="kx">store</em></code> <em class="kx">。</em>接下来说说店铺。</p><h1 id="b5c9" class="lq li iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">Redux商店</h1><p id="a8de" class="pw-post-body-paragraph jy jz iq ka b kb mn kd ke kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ij bi translated">当我们使用Redux时，存储是保存我们的应用程序状态的东西。每个Redux应用程序将只有一个单一的商店。Redux中的存储非常棒，因为它允许我们从应用程序中的任何组件访问应用程序的状态，这在只使用React构建应用程序时是不可能的。连接我们的Redux商店非常简单。让我们看看拿出来的<code class="fe ln lo lp ld b">App.js</code>文件:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="2178" class="lh li iq ld b gy lj lk l ll lm">import React, { Component } from 'react';</span><span id="182a" class="lh li iq ld b gy ms lk l ll lm">import { Provider } from 'react-redux';<br/>import { createStore } from 'redux';</span><span id="e68e" class="lh li iq ld b gy ms lk l ll lm">import Toggle from './components/Toggle';<br/>import rootReducer from './rootReducer';</span><span id="aa20" class="lh li iq ld b gy ms lk l ll lm">const store = createStore(<br/>  rootReducer<br/>);</span><span id="026a" class="lh li iq ld b gy ms lk l ll lm">class App extends Component {<br/>  render() {<br/>    return (<br/>      &lt;Provider store={store}&gt;<br/>        &lt;Toggle /&gt;<br/>      &lt;/Provider&gt;<br/>    );<br/>  }<br/>}</span><span id="39fc" class="lh li iq ld b gy ms lk l ll lm">export default App;</span></pre><p id="e00c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们从导入react和React中的组件开始。没什么新鲜的。接下来我们从react-redux导入<code class="fe ln lo lp ld b">Provider</code>。react-redux npm模块帮助我们连接redux以轻松做出反应。我们从redux导入<code class="fe ln lo lp ld b">createStore</code>函数，然后导入我们的<code class="fe ln lo lp ld b">Toggle</code>组件和我们在上一节刚刚创建的<code class="fe ln lo lp ld b">rootReducer</code>。</p><p id="de60" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">记住，我们的<code class="fe ln lo lp ld b">rootReducer</code>常量将我们应用中的所有减速器组合成一个减速器。我们使用之前导入的<code class="fe ln lo lp ld b">createStore</code>函数创建我们的商店，并传入我们的rootReducer。最后，在我们的<code class="fe ln lo lp ld b">render</code>函数的<code class="fe ln lo lp ld b">return</code>语句中，我们将我们的应用程序包装在<code class="fe ln lo lp ld b">Provider</code>中，并将我们的<code class="fe ln lo lp ld b">store</code>传递给它。</p><p id="e95e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">就是这样！对于一个非常小的应用程序来说，这是一个冗长的解释，但是我希望它能够帮助您理解Redux的一些基本概念。如果你愿意的话，请就如何让这篇文章更好发表评论，提出更正或建议。</p></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><figure class="ky kz la lb gt jr gh gi paragraph-image"><a href="https://levelup.gitconnected.com"><div class="gh gi na"><img src="../Images/9914c5dd23ac08b70eea6f4f9ba6fed2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E6CoI_MRyZ1JInNPsBSHtA.png"/></div></a></figure><div class="nb nc gp gr nd ne"><a href="https://gitconnected.com/learn/redux" rel="noopener  ugc nofollow" target="_blank"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd ir gy z fp nj fr fs nk fu fw ip bi translated">学习Redux -最佳Redux教程(2019) | gitconnected</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">8大Redux教程-免费学习Redux。课程由开发人员提交并投票，使您能够…</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">gitconnected.com</p></div></div><div class="nn l"><div class="no l np nq nr nn ns jw ne"/></div></div></a></div></div></div>    
</body>
</html>