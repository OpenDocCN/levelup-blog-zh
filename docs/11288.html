<html>
<head>
<title>Dynamic theming using Hive, Bloc and Flutter</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Hive、Bloc和Flutter的动态主题化</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/dynamic-theming-using-hive-and-flutter-feb90cb9728b?source=collection_archive---------3-----------------------#2022-03-05">https://levelup.gitconnected.com/dynamic-theming-using-hive-and-flutter-feb90cb9728b?source=collection_archive---------3-----------------------#2022-03-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="35a2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个应用程序的一个很好的特性是能够在亮主题和暗模式之间切换。黑暗模式对用户的眼睛来说更容易，随着数字福利的普及，我认为写一个关于使用Flutter在应用程序中实现明暗主题的教程是一个很好的主意。让我们直接开始吧！</p><p id="a391" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">演示</strong></p><p id="075d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本教程中，我们将构建一个应用程序，如下图所示:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi kl"><img src="../Images/7431174d6e672fbdec6eca102ad05b9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:804/1*dVz6I5sQZ6pMHRrdg36GbQ.gif"/></div></figure><p id="4d5d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">简介</strong></p><p id="c239" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设您已经基本掌握了Dart编程语言和系统上安装的Flutter SDK。如果您的系统上没有安装Flutter SDK，请访问<a class="ae kt" href="https://flutter.dev/" rel="noopener ugc nofollow" target="_blank"> flutter.dev </a>获取安装说明。</p><p id="fd01" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，您需要来自<a class="ae kt" href="https://pub.dev/" rel="noopener ugc nofollow" target="_blank"> pub.dev </a>的以下库:</p><ol class=""><li id="b9b5" class="ku kv iq jp b jq jr ju jv jy kw kc kx kg ky kk kz la lb lc bi translated">hive: Hive是一个安全的NoSql数据库库。对于我们的用例，它将用于存储一个布尔标志，该标志反过来将用于从保存的设置中确定应用程序的主题。</li><li id="1a55" class="ku kv iq jp b jq ld ju le jy lf kc lg kg lh kk kz la lb lc bi translated">hive_generator和build_runner:这个库是hive的扩展，是使用build_runner库自动生成支持文件所必需的。</li><li id="80f9" class="ku kv iq jp b jq ld ju le jy lf kc lg kg lh kk kz la lb lc bi translated">path_provider:这个库用于访问设备文件夹(在本例中，在应用程序的沙箱中),以初始化和存储本地数据库。</li><li id="d20d" class="ku kv iq jp b jq ld ju le jy lf kc lg kg lh kk kz la lb lc bi translated">bloc和flutter_bloc:这些库被用作状态管理解决方案。对于本教程来说，这可能有点过了，但是对于大型和更复杂的应用程序来说，这很有用。</li></ol><p id="5a77" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以按照<a class="ae kt" href="https://pub.dev" rel="noopener ugc nofollow" target="_blank"> pub.dev </a>网站上相应的说明来安装这些库。</p><p id="b6a5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">关于使用Hive库的优秀教程可以在<a class="ae kt" href="https://medium.com/flutter-community/storing-local-data-with-hive-and-provider-in-flutter-a49b6bdea75a" rel="noopener">这里</a>和<a class="ae kt" href="https://medium.flutterdevs.com/hive-database-with-typeadapter-in-flutter-7390d0e515fa" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="f2df" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">编写主题切换app </strong></p><p id="9165" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">步骤1:设置配置单元数据库</strong></p><p id="43d4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在项目的“lib”文件夹中，创建一个名为“theme_hive.dart”的文件。首先，像这样创建一个名为“ThemeDatabase”的模型类:</p><pre class="km kn ko kp gt li lj lk ll aw lm bi"><span id="2ee9" class="ln lo iq lj b gy lp lq l lr ls">import ‘package:hive/hive.dart’;<br/>part ‘theme_hive.g.dart’;</span><span id="4202" class="ln lo iq lj b gy lt lq l lr ls">@HiveType(typeId: 0)<br/>class ThemeDatabase {<br/>@HiveField(0)<br/>bool? themeSettings;</span><span id="4e07" class="ln lo iq lj b gy lt lq l lr ls">ThemeDatabase({required this.themeSettings});<br/>}</span></pre><p id="cbe2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个模型类中，我们唯一需要的字段是一个名为“themeSettings”的布尔值。该字段将用于确定应用程序应该使用亮模式还是暗模式。</p><p id="0e19" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，在终端中运行以下命令:</p><pre class="km kn ko kp gt li lj lk ll aw lm bi"><span id="7d77" class="ln lo iq lj b gy lp lq l lr ls">$ flutter packages pub run build_runner build</span></pre><p id="8bae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">执行上面一行自动生成配置单元数据库所需的类型适配器。生成的文件名为“theme_hive.g.dart”。</p><pre class="km kn ko kp gt li lj lk ll aw lm bi"><span id="3276" class="ln lo iq lj b gy lp lq l lr ls">// GENERATED CODE — DO NOT MODIFY BY HAND</span><span id="0033" class="ln lo iq lj b gy lt lq l lr ls">part of ‘theme_hive.dart’;</span><span id="621b" class="ln lo iq lj b gy lt lq l lr ls">// **************************************************************************</span><span id="19bd" class="ln lo iq lj b gy lt lq l lr ls">// TypeAdapterGenerator</span><span id="4d4d" class="ln lo iq lj b gy lt lq l lr ls">// **************************************************************************</span><span id="0ec9" class="ln lo iq lj b gy lt lq l lr ls">class ThemeDatabaseAdapter extends TypeAdapter&lt;ThemeDatabase&gt; {<br/>@override<br/>final int typeId = 0;</span><span id="bc82" class="ln lo iq lj b gy lt lq l lr ls">@override<br/>ThemeDatabase read(BinaryReader reader) {<br/>final numOfFields = reader.readByte();<br/>final fields = &lt;int, dynamic&gt;{</span><span id="2fa6" class="ln lo iq lj b gy lt lq l lr ls">for (int i = 0; i &lt; numOfFields; i++) reader.readByte(): reader.read(),<br/>};</span><span id="c9eb" class="ln lo iq lj b gy lt lq l lr ls">return ThemeDatabase(<br/>themeSettings: fields[0] as bool?,<br/>);</span><span id="59a4" class="ln lo iq lj b gy lt lq l lr ls">}</span><span id="5ed3" class="ln lo iq lj b gy lt lq l lr ls">@override<br/>void write(BinaryWriter writer, ThemeDatabase obj) {<br/>writer<br/>..writeByte(1)<br/>..writeByte(0)<br/>..write(obj.themeSettings);<br/>}</span><span id="8942" class="ln lo iq lj b gy lt lq l lr ls">@override<br/>int get hashCode =&gt; typeId.hashCode;</span><span id="7085" class="ln lo iq lj b gy lt lq l lr ls">@override<br/>bool operator ==(Object other) =&gt; <br/>identical(this, other) ||<br/>other is ThemeDatabaseAdapter &amp;&amp;<br/>runtimeType == other.runtimeType &amp;&amp;<br/>typeId == other.typeId;<br/>}</span></pre><p id="972d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">步骤2:设置数据库服务</strong></p><p id="336e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在项目的“lib”文件夹中，创建一个名为“theme_service.dart”的文件。</p><p id="3c19" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">添加以下行作为该文件的导入:</p><pre class="km kn ko kp gt li lj lk ll aw lm bi"><span id="7c0e" class="ln lo iq lj b gy lp lq l lr ls">import ‘dart:io’;<br/>import ‘package:hive/hive.dart’;<br/>import ‘package:path_provider/path_provider.dart’;<br/>import ‘theme_hive.dart’;</span></pre><p id="dd55" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">“ThemeDatabaseService”类由四个方法组成，第一个是未来的“checkDatabaseExists”。必须首先初始化数据库，如果数据库存在，必须将其打开。如果数据库不存在，必须使用“createDatabase”方法创建它。在这个方法中，必须初始化数据库，并且必须注册“主题数据库适配器”(在执行构建运行器命令时自动生成)。此外，数据库被打开，一个缺省的布尔值“true”被输入其中。注意，Hive数据库将对象存储为键值对。</p><p id="938a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，创建一个名为“putThemeSettings”的静态方法，将布尔值“themeFlag”的更新值写入数据库。可以使用“getThemeSettings”静态方法检索该标志的值。如果数据库不为空，此方法返回“bool”数据类型。如果数据库包含空值，则返回默认布尔值“true”。</p><p id="5378" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面给出了“主题数据库服务”类的代码:</p><pre class="km kn ko kp gt li lj lk ll aw lm bi"><span id="4970" class="ln lo iq lj b gy lp lq l lr ls">class ThemeDatabaseService {</span><span id="96c7" class="ln lo iq lj b gy lt lq l lr ls">//Create a global Singleton out of this class. All fields and methods used<br/>//in this class should be static to be accessible globally.</span><span id="a2bb" class="ln lo iq lj b gy lt lq l lr ls">ThemeDatabaseService._();</span><span id="47f5" class="ln lo iq lj b gy lt lq l lr ls">//This is the field variable for the Hive database</span><span id="a5a7" class="ln lo iq lj b gy lt lq l lr ls">static var <em class="lu">themeBox</em>;</span><span id="6c76" class="ln lo iq lj b gy lt lq l lr ls">//This method is used to check if the database exists</span><span id="0eb8" class="ln lo iq lj b gy lt lq l lr ls">static Future&lt;void&gt; <em class="lu">checkDatabaseExists</em>() async {<br/>Directory themeDatabaseDir = await getApplicationSupportDirectory();</span><span id="059a" class="ln lo iq lj b gy lt lq l lr ls">//Initialise the database<br/>Hive.init(themeDatabaseDir.path);</span><span id="09f7" class="ln lo iq lj b gy lt lq l lr ls">//If the database exists, open it. Else, call the createDatabase method<br/>if (await Hive.boxExists(“themeBox”)) {<br/><em class="lu">themeBox </em>= await Hive.openBox(“themeBox”);<br/>} else {<br/><em class="lu">createDatabase</em>();<br/>}<br/>}</span><span id="ec68" class="ln lo iq lj b gy lt lq l lr ls">//This method is used to create the database<br/>static Future&lt;void&gt; <em class="lu">createDatabase</em>() async {<br/>Directory themeDatabaseDir = await getApplicationSupportDirectory();</span><span id="f1d2" class="ln lo iq lj b gy lt lq l lr ls">//Initialise the database<br/>Hive.init(themeDatabaseDir.path);</span><span id="2e59" class="ln lo iq lj b gy lt lq l lr ls">//Register the Hive database Type Adapter<br/>Hive.registerAdapter(ThemeDatabaseAdapter());</span><span id="2bb6" class="ln lo iq lj b gy lt lq l lr ls">//Open the database<br/><em class="lu">themeBox </em>= await Hive.openBox(“themeBox”);</span><span id="7dbd" class="ln lo iq lj b gy lt lq l lr ls">//Objects in a Hive database are stored as a key-value pair<br/>//Store the default theme setting in the database as a boolean for the “themeSettings”<br/>//key. In this case, the flag is set to “true” for light mode</span><span id="996a" class="ln lo iq lj b gy lt lq l lr ls">await <em class="lu">themeBox</em>.put(“themeSettings”, true);<br/>}</span><span id="1ed3" class="ln lo iq lj b gy lt lq l lr ls">//This method is used to update the theme settings of the app.<br/>//The “themeFlag” parameter is passed to this method to update the boolean<br/>//value of the “themeSettings” key-value pair in the database</span><span id="1a53" class="ln lo iq lj b gy lt lq l lr ls">static <em class="lu">putThemeSettings</em>(bool? themeFlag) {<br/><em class="lu">themeBox</em>.put(“themeSettings”, themeFlag);<br/>}</span><span id="88d0" class="ln lo iq lj b gy lt lq l lr ls">//This method return a Boolean and is used to get the value of the “themeSettings”<br/>//key-value pair if the “themeBox” is not null. If it is null, then a default<br/>//value of “true” is returned</span><span id="dbb4" class="ln lo iq lj b gy lt lq l lr ls">static bool <em class="lu">getThemeSettings</em>() {<br/>bool themeValue = <em class="lu">themeBox</em>?.get(“themeSettings”)??true;<br/>return themeValue;<br/>}<br/>}</span></pre><p id="10a7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">步骤3:设置ThemeCubit类</strong></p><p id="b8b0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，在“lib”文件夹中创建一个名为“theme_state.dart”的新文件。在该文件中，创建ThemeState类，该类用于表示“isLightTheme”标志的当前状态。该标志对于亮模式为“真”,对于暗模式为“假”。该类的代码如下:</p><pre class="km kn ko kp gt li lj lk ll aw lm bi"><span id="5fe4" class="ln lo iq lj b gy lp lq l lr ls">part of ‘theme_cubit.dart’;</span><span id="700c" class="ln lo iq lj b gy lt lq l lr ls">class ThemeState {<br/>bool? isLightTheme;</span><span id="4671" class="ln lo iq lj b gy lt lq l lr ls">ThemeState({required this.isLightTheme});<br/>}</span></pre><p id="2b18" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，在“lib”文件夹中创建一个名为“theme_cubit.dart”的新文件。在该文件中，创建“ThemeCubit”类，该类扩展了“ThemeState”类。主题标志的布尔值从数据库中获得，并作为主题状态传递给主题Cubit。这是获取上次保存的主题设置所必需的。此外，“ThemeCubit”类包含两个名为“lightMode”和“darkMode”的方法，用于在亮模式和暗模式之间切换。</p><p id="3423" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，应用程序的主题状态是通过使用Bloc作为状态管理解决方案反映在整个应用程序中的。虽然状态是实时更新的，但只有在应用程序重新启动时，才会从数据库中检索主题标志的值。主题标志值的检索不会实时发生。但是，主题标志的值会实时保存到数据库中。</p><p id="33e6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面给出了“ThemeCubit”类的代码:</p><pre class="km kn ko kp gt li lj lk ll aw lm bi"><span id="9614" class="ln lo iq lj b gy lp lq l lr ls">import ‘package:bloc/bloc.dart’;<br/>import ‘package:flutter_bloc/flutter_bloc.dart’;<br/>import ‘theme_service.dart’;</span><span id="3a42" class="ln lo iq lj b gy lt lq l lr ls">part ‘theme_state.dart’;</span><span id="39e2" class="ln lo iq lj b gy lt lq l lr ls">//This class extends the ThemeState class, i.e., it inherits the properties of<br/>//the ThemeState class</span><span id="e1c4" class="ln lo iq lj b gy lt lq l lr ls">class ThemeCubit extends Cubit&lt;ThemeState&gt; {</span><span id="41e5" class="ln lo iq lj b gy lt lq l lr ls">//The boolean value of the theme flag is obtained from the database and passed<br/>//as the theme state to the ThemeCubit. This is necessary to obtain the last<br/>//saved theme setting</span><span id="8f5b" class="ln lo iq lj b gy lt lq l lr ls">ThemeCubit() : super(ThemeState(isLightTheme: ThemeDatabaseService.getThemeSettings(),));</span><span id="29b4" class="ln lo iq lj b gy lt lq l lr ls">//This method is used to switch the theme to light mode throughout the app</span><span id="9cf9" class="ln lo iq lj b gy lt lq l lr ls">void lightMode() =&gt; emit(ThemeState(isLightTheme: true,));</span><span id="74b7" class="ln lo iq lj b gy lt lq l lr ls">//This method is used to switch the theme to dark mode throughout the app</span><span id="a4b4" class="ln lo iq lj b gy lt lq l lr ls">void darkMode() =&gt; emit(ThemeState(isLightTheme: false,));<br/>}</span></pre><p id="c732" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">第四步:构建用户界面</strong></p><p id="d4f2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">UI构建在“main.dart”文件中。在“main”函数中，我们首先检查主题数据库是否存在。因为这是一个异步操作，所以“main”函数必须标记为“async”。此外，下面一行必须添加到“main”函数中:</p><pre class="km kn ko kp gt li lj lk ll aw lm bi"><span id="c29c" class="ln lo iq lj b gy lp lq l lr ls">WidgetsFlutterBinding.<em class="lu">ensureInitialized</em>();</span></pre><p id="d664" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还使用BlocProvider小部件为整个小部件树提供“ThemeCubit”。“主”功能的代码如下所示:</p><pre class="km kn ko kp gt li lj lk ll aw lm bi"><span id="11a5" class="ln lo iq lj b gy lp lq l lr ls">void main() async {</span><span id="f3b4" class="ln lo iq lj b gy lt lq l lr ls">WidgetsFlutterBinding.<em class="lu">ensureInitialized</em>();<br/>await ThemeDatabaseService.<em class="lu">checkDatabaseExists</em>();</span><span id="b2b0" class="ln lo iq lj b gy lt lq l lr ls">runApp(BlocProvider(create: (context) =&gt; ThemeCubit(),<br/>child: const MyApp(),),);<br/>}</span></pre><p id="b306" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从“main”函数中，“runApp”函数调用“MyApp”无状态小部件。在这个小部件中，“BlocBuilder”小部件用于处理主题Cubit的状态。如果cubit的状态为“真”，则执行亮模式，如果状态为“假”，则通过更改“亮度”属性来执行暗模式。在“MyApp”小部件的“home”属性中，我们将传递“MyHomePage”无状态小部件。这个小部件在其构造函数中将应用程序的标题作为一个字符串。在build方法中,“BlocBuilder”小部件用于处理主题Cubit的状态。根据主题Cubit的状态，相应的文本会显示在应用程序的主体中，同时还会显示浮动操作按钮的工具提示。</p><p id="b85f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">轻按浮动动作按钮可以在应用的亮暗主题之间切换，方法是在整个应用中更新主题Cubit的状态，同时将主题标志的值保存到数据库中。</p><p id="78cf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">“main.dart”文件的代码如下所示:</p><pre class="km kn ko kp gt li lj lk ll aw lm bi"><span id="12cd" class="ln lo iq lj b gy lp lq l lr ls">import ‘package:flutter/material.dart’;<br/>import ‘package:flutter_bloc/flutter_bloc.dart’;<br/>import ‘theme_cubit.dart’;<br/>import ‘theme_service.dart’;</span><span id="6ba8" class="ln lo iq lj b gy lt lq l lr ls">//The main function has to be marked as asynchronous as we are using an asynchronous<br/>//operation within it (to check if the database exists)</span><span id="8ca2" class="ln lo iq lj b gy lt lq l lr ls">void main() async {</span><span id="4bb6" class="ln lo iq lj b gy lt lq l lr ls">//Since the main function is asynchronous, add the below line<br/>WidgetsFlutterBinding.ensureInitialized();</span><span id="3108" class="ln lo iq lj b gy lt lq l lr ls">//Check if the database exists<br/>await ThemeDatabaseService.checkDatabaseExists();</span><span id="fc43" class="ln lo iq lj b gy lt lq l lr ls">//Provide the ThemeCubit to the entire widget tree using the BlocProvider widget<br/>runApp(BlocProvider(create: (context) =&gt; ThemeCubit(),<br/>child: const MyApp(),),);<br/>}</span><span id="7ae1" class="ln lo iq lj b gy lt lq l lr ls">class MyApp extends StatelessWidget {</span><span id="adce" class="ln lo iq lj b gy lt lq l lr ls">const MyApp({Key? key}) : super(key: key);</span><span id="4b20" class="ln lo iq lj b gy lt lq l lr ls">@override<br/>Widget build(BuildContext context) {</span><span id="46e9" class="ln lo iq lj b gy lt lq l lr ls">//Use BlocBuilder widget to handle the ThemeCubit states<br/>return BlocBuilder&lt;ThemeCubit, ThemeState&gt;(<br/>builder: (context, state) {<br/>return MaterialApp(<br/>title: ‘Flutter Demo’,<br/>theme: ThemeData(<br/>brightness: state.isLightTheme! ? Brightness.light : Brightness.dark),<br/>home: const MyHomePage(title: ‘Dynamic theming’),<br/>);<br/>},);}</span><span id="77ed" class="ln lo iq lj b gy lt lq l lr ls">}</span><span id="ecba" class="ln lo iq lj b gy lt lq l lr ls">class MyHomePage extends StatelessWidget {</span><span id="a1c3" class="ln lo iq lj b gy lt lq l lr ls">const MyHomePage({Key? key, required this.title}) : super(key: key);</span><span id="2e5c" class="ln lo iq lj b gy lt lq l lr ls">final String? title;</span><span id="6ee5" class="ln lo iq lj b gy lt lq l lr ls">@override<br/>Widget build(BuildContext context) {<br/>return BlocBuilder&lt;ThemeCubit, ThemeState&gt;(<br/>builder: (context, state) {<br/>return Scaffold(<br/>appBar: AppBar(<br/>title: Text(title!),),<br/>//Depending on the boolean state of the ThemeCubit, the appropriate<br/>//text is shown in the body of the app<br/>body: Center(<br/>child: Text(state.isLightTheme! ? ‘Light Mode’ : ‘Dark Mode’)),<br/>//Use a Floating Action Button to switch between themes by injecting the<br/>//value of the ThemeCubit in the widget tree and saving the settings in<br/>//the database<br/>floatingActionButton: FloatingActionButton(<br/>onPressed: () {<br/>if (state.isLightTheme!) {<br/>BlocProvider.of&lt;ThemeCubit&gt;(context).darkMode();<br/>ThemeDatabaseService.putThemeSettings(false);<br/>} else {<br/>BlocProvider.of&lt;ThemeCubit&gt;(context).lightMode();<br/>ThemeDatabaseService.putThemeSettings(true);<br/>}},</span><span id="f6c8" class="ln lo iq lj b gy lt lq l lr ls">//Depending on the boolean state of the ThemeCubit, the appropriate<br/>//tooltip is shown<br/>tooltip: state.isLightTheme! ? ‘Dark Mode’ : ‘Light Mode’,<br/>child: const Icon(Icons.switch_left_rounded),), <br/>);<br/>},);<br/>}<br/>}</span></pre><p id="72e0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就这样，我完成了我的第一个颤振教程。我希望你能像我喜欢写它一样喜欢从中学习。</p></div></div>    
</body>
</html>