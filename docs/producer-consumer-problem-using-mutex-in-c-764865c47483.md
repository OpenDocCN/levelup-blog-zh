# C++中使用互斥体的生产者-消费者问题

> 原文：<https://levelup.gitconnected.com/producer-consumer-problem-using-mutex-in-c-764865c47483>

生产者-消费者问题是并发程序设计中一个经典的多线程同步问题。今天，我们将尝试用 C++中的互斥体来解决这个问题。

![](img/122fc6d2f108b016d15a09fb9d5d4708.png)

本教程由三部分组成。首先，我们定义并分析测验的挑战部分。在第二部分，我们解释并学习在 C++中使用互斥体。最后，我们应用互斥来完成我们的解决方案。

# **问题陈述**

生产者-消费者问题是一组有许多变量的问题。在本教程中，我们关注最简单的版本:

1.  系统有一个生产者线程和一个消费者线程。
2.  生产者和消费者之间的缓冲区大小正好是 1。换句话说，生产者会等消费者消费完产品再生产下一个。

关键点是生产者和消费者都需要访问共享资源(缓冲区),而不知道对方在做什么。我们必须正确地处理同步，以便生产者提供的数据不会丢失(生产者在消费者接受之前生成下一个产品)或重复(生产者在消费者获得下一个产品之前无法更新)。为了实现这一目标，理想的解决方案应该保证:

1.  两个线程对数据的访问是互斥的。当一个正在访问数据时，另一个必须被阻止。
2.  生产者和消费者活动以“乒乓”模式交替进行。在高效的实现中，消费者在生产者完成后立即启动，反之亦然。

在解决这个问题之前，我们需要研究如何使用互斥体。

# **互斥**

在多线程编程中，必须小心处理线程间的资源共享，因为可能会发生数据竞争。我们需要一种机制来保证对共享资源的访问是 T4 互斥的。互斥体就是为此而设计的。下面展示了 C++中互斥体的常见用法。

std::mutex(来自 header <mutex>)被声明为全局变量，并在不同的线程间引用。每个线程可以触发 lock()和 unlock()来标记一个*临界段*的开始和结束。</mutex>

临界区包括需要保护和避免并发访问的操作。在生产者-消费者的例子中，生产(写入共享资源)和消费(读取共享资源)的代码必须受到保护。

在现代 C++中(从 C++11 开始)，对互斥体进行了增强。

## 将互斥与 std::unique_lock 一起使用

std::unique_lock 是 std::mutex 的一个 [RAII](https://stackoverflow.com/questions/2321511/what-is-meant-by-resource-acquisition-is-initialization-raii) 包装器。它获得了 RAII 的好处:在构造中自动锁定互斥体，在被析构时解锁，提供异常安全。开发人员也可以手动解锁/锁定它。下面是上面例子的重写版本，带有 std::unique_lock:

如果你不懂 RAII，不要担心，不影响本教程。现在只需记住，将 std::unique_lock 与 std::mutex 一起使用是对原始互斥体的改进。在本文的其余部分，我们将遵循这种做法。

我们现在有锤子了，现在让我们来解决这个问题吧！

# 带有互斥的生产者-消费者解决方案

这段代码片段演示了解决方案的核心逻辑:(它排除了读者不必关注的部分:主函数、启动线程等。)

该系统包含一个消费者函数和一个生产者函数，每个函数都执行一个无限循环来保持生成/接受数据。

在顶部，声明了三个全局变量以便于线程之间的通信:

1.  g_mutex 是互斥变量(第 1 行)。
2.  g_ready 是一个标志，用来通知另一个线程“我已经完成了我的工作”(第 2 行)。
3.  g_data 是用于存储数据的单一大小的缓冲区(第 3 行)。

在执行期间，生成器执行:

1.  锁定临界区(第 20 行)。
2.  产生数据(第 22 行)。
3.  将标志 g_ready 设置为真(第 23 行)。
4.  解锁临界区(第 24 行)，期望消费者接受它并更改标志。
5.  继续等待，直到 g_ready 为假(第 25 行)。

和消费者行为:

1.  等待 g_ready 为真(第 8 行),表示生产者完成了它的工作。
2.  锁定临界区(第 11 行)(超出范围时在第 14 行自动解锁)。
3.  消费数据。(第 12 行)。
4.  将标志 g_ready 设置为 false(第 13 行),通知其工作已完成。

注意到我们必须在两端引入 while 循环来等待另一个线程。这种策略被称为*【忙等待】*。忙等待是低效的，因为它花费处理器时间做无用的活动，应该避免。我们可以在每个循环中添加一个 sleep 命令，以减少检查全局状态 g_ready 的频率。

以下是带有“休眠等待”的完整版本代码:

这个程序每秒钟都会在生产者和消费者之间切换。

您可能会发现这还不够完美，因为我们无法知道一般情况下生成/使用数据需要多长时间，线程应该“休眠”。设置随机等待时间不是最佳选择。我们将在[这个教程](https://domiyanyue.medium.com/producer-consumer-problem-using-condition-variable-in-c-6c4d96efcbbc)中解决这个问题。

# 摘要

在本文中，我们了解到:

1.  生产者-消费者问题的挑战:线程间的同步/协调。
2.  在 C++中使用 std::mutex 和 std::unique_lock 来保护线程中的临界区。
3.  用互斥体解决生产者-消费者问题。

# 参考

1.  [生产者-消费者问题](https://en.wikipedia.org/wiki/Producer%E2%80%93consumer_problem)
2.  cppreference.com
3.  cppreference.comT4【STD::unique _ lock】
4.  [RAII](https://en.cppreference.com/w/cpp/language/raii)