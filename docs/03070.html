<html>
<head>
<title>Manipulation of JavaScript Strings</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript字符串的操作</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/manipulation-of-javascript-strings-a185299c5be5?source=collection_archive---------21-----------------------#2020-04-17">https://levelup.gitconnected.com/manipulation-of-javascript-strings-a185299c5be5?source=collection_archive---------21-----------------------#2020-04-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/64186ca9f3b3bd2fe06b4c8905f7006a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ve-MQCmz4eyvjCGJ"/></div></div></figure><p id="cef4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">JavaScript在处理字符串和所有其他数据类型时有一些非常好的功能。让我们来看看一些使用本机功能的基本JavaScript操作，好吗？</p><h1 id="ce7c" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">确定回文</h1><blockquote class="lu lv lw"><p id="df6a" class="jy jz lx ka b kb kc kd ke kf kg kh ki ly kk kl km lz ko kp kq ma ks kt ku kv ij bi translated">一个单词、短语或序列，向前和向后读起来一样，例如<em class="iq">夫人</em>或<em class="iq">护士管理</em>。—谷歌搜索牛津词典</p></blockquote><p id="30ad" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">回文是一个可以颠倒的单词，同时保留其最初的字符位置。比如‘赛车’反过来还是‘赛车’。所以，如果我们要写一个快速而肮脏的函数来检查一个单词是否是回文，我们会怎么做呢？也许类似于下面的内容。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="56af" class="mk kx iq mg b gy ml mm l mn mo">function <strong class="mg ir">isPalindromic(</strong>word<strong class="mg ir">) {<br/>  let </strong>palindrome = ''<br/>  <br/>  <strong class="mg ir">for (let</strong> i <strong class="mg ir">=</strong> word.<strong class="mg ir">length</strong>; i <strong class="mg ir">&gt;=</strong> 0<strong class="mg ir">; --</strong>i<strong class="mg ir">)</strong> <strong class="mg ir">{</strong><br/>    palindrome <strong class="mg ir">+=</strong> word.<strong class="mg ir">charAt(</strong>i<strong class="mg ir">)</strong><br/>  <strong class="mg ir">}</strong></span><span id="66c8" class="mk kx iq mg b gy mp mm l mn mo">  <strong class="mg ir">return </strong>palindrome <strong class="mg ir">===</strong> word<br/><strong class="mg ir">}</strong></span></pre><p id="883a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面的函数将非常简单地运行一个for循环，迭代给定单词的长度。它从最后一个字符开始，向后工作，在每次迭代中，它将获取该索引处的字符，并将其附加到<code class="fe mq mr ms mg b">palindrome</code> holder值。一旦for循环完成，我们可以简单地在原始单词和新的构造函数holder值之间进行比较。</p><p id="23c2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是等等…我之前提到的那些原生函数呢？让我们带他们出去兜一圈。下面的代码片段以类似的方式工作，但是更容易阅读，也更简洁。</p><p id="e733" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它本质上是将给定的单词拆分成一个字符数组，颠倒这些字符的顺序，然后将它们重新组合成一个字符串。该字符串可以立即与给定的单词进行比较！</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="b3b4" class="mk kx iq mg b gy ml mm l mn mo"><strong class="mg ir">function isPalindromic(</strong>word<strong class="mg ir">) {</strong><br/>  <strong class="mg ir">return</strong> word.<strong class="mg ir">split('')</strong><br/>    .<strong class="mg ir">reverse()</strong><br/>    .<strong class="mg ir">join('') === word</strong><br/>}</span></pre><h2 id="dba1" class="mk kx iq bd ky mt mu dn lc mv mw dp lg kj mx my lk kn mz na lo kr nb nc ls nd bi translated">这个表现如何？</h2><p id="a2e2" class="pw-post-body-paragraph jy jz iq ka b kb ne kd ke kf nf kh ki kj ng kl km kn nh kp kq kr ni kt ku kv ij bi translated">所以我决定运行一个定时测试，以满足我和你的好奇心，我了解到，平均来说，使用本机功能比它的笨拙的对应物for-loop快得可以忽略不计。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/21049d79247d85d6863b9350fe8633ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1164/format:webp/1*GG9Ix7etYQnwmA8LjNiVNw.png"/></div></figure><p id="f293" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用相同的单词作为基础，结果并不特别令人惊讶，但是平均来说，本机功能似乎稍微快一些。</p><p id="93c1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我倾向于使用本机功能而不是for循环，因为它更容易阅读和推理，更简洁和易于管理。它也将需要较少的调试，因为有更少的移动部件。</p></div><div class="ab cl nk nl hu nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ij ik il im in"><h1 id="f56b" class="kw kx iq bd ky kz nr lb lc ld ns lf lg lh nt lj lk ll nu ln lo lp nv lr ls lt bi translated">如果我们把单词变成大写字母会怎么样？</h1><p id="5016" class="pw-post-body-paragraph jy jz iq ka b kb ne kd ke kf nf kh ki kj ng kl km kn nh kp kq kr ni kt ku kv ij bi translated">大写是指给定句子中的每个单词都以大写字母开头。用一个词来做这件事是比较直截了当的。如下图所示。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="b0d0" class="mk kx iq mg b gy ml mm l mn mo"><strong class="mg ir">const capitalCaseWord =</strong> word <strong class="mg ir">=&gt;</strong> word<strong class="mg ir">.charAt(</strong>0<strong class="mg ir">)</strong><br/>    <strong class="mg ir">.toUpperCase()</strong><br/>    <strong class="mg ir">.concat(</strong>word<strong class="mg ir">.substring(</strong>1<strong class="mg ir">))</strong></span></pre><p id="e6a7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以我们在这里要做的就是把单词的第一个字母大写，然后把去掉第一个字母的单词和我们刚刚大写的字母连接起来。因此，我们现在有了一个以大写字母开头的单词。</p><p id="dfd2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们如何改变一个句子，使每个单词都以大写字母开头？我们可以从上面的函数开始。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="b480" class="mk kx iq mg b gy ml mm l mn mo"><strong class="mg ir">const capitalCaseSentence =</strong> sentence <strong class="mg ir">=&gt; </strong>sentence<strong class="mg ir">.split(</strong>' '<strong class="mg ir">)</strong><br/>    .<strong class="mg ir">map(</strong>capitalCaseWord<strong class="mg ir">)</strong><br/>    <strong class="mg ir">.join(</strong>' '<strong class="mg ir">)</strong></span></pre><p id="1e5f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上面的代码片段中，我们只是用空格分割字符串，从而将它转换成一个数组；我们使用数组原型上的原生<code class="fe mq mr ms mg b">.map</code>功能来生成一个新数组，通过运行上面已经定义的<code class="fe mq mr ms mg b">capitalCaseWord</code>函数来改变给定句子中的每个单词。最后，我们简单地再次加入空格。我们现在有两个函数来把句子变成大写字母！</p><h2 id="1fea" class="mk kx iq bd ky mt mu dn lc mv mw dp lg kj mx my lk kn mz na lo kr nb nc ls nd bi translated">这个表现如何？</h2><p id="49e5" class="pw-post-body-paragraph jy jz iq ka b kb ne kd ke kf nf kh ki kj ng kl km kn nh kp kq kr ni kt ku kv ij bi translated">然而，所有这些过程都非常快。这将取决于你的硬件，但即使如此，这些进程的速度仍然令人难以置信。显而易见，在单个单词上执行会在计算上更轻和更快。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nw"><img src="../Images/848d5c06eb645130dadc59e3ebdc759c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l7nwdfH7ivdGnU_IPsJpTQ.png"/></div></div></figure><p id="f380" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以这种方式使用函数是有益的。能够构建小粒度的代码块，在需要的地方插入它们，以完成任务。相当方便！</p></div><div class="ab cl nk nl hu nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ij ik il im in"><h1 id="01dd" class="kw kx iq bd ky kz nr lb lc ld ns lf lg lh nt lj lk ll nu ln lo lp nv lr ls lt bi translated">骆驼案呢？</h1><p id="5fdd" class="pw-post-body-paragraph jy jz iq ka b kb ne kd ke kf nf kh ki kj ng kl km kn nh kp kq kr ni kt ku kv ij bi translated">Camel case是一种普遍接受的变量/类/函数名格式。但是出于好奇，我们如何着手把一个句子改成<code class="fe mq mr ms mg b">camelCase</code>？</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="9b5e" class="mk kx iq mg b gy ml mm l mn mo"><strong class="mg ir">const capitalCaseWord =</strong> <strong class="mg ir">(</strong>word, index<strong class="mg ir">)</strong> <strong class="mg ir">=&gt; {<br/>  if (index === 0) {<br/>    return word<br/>  }</strong></span><span id="212f" class="mk kx iq mg b gy mp mm l mn mo"><strong class="mg ir">  return word.charAt(0)<br/>    .toUpperCase()<br/>    .concat(word.substring(1))<br/>}</strong></span><span id="2591" class="mk kx iq mg b gy mp mm l mn mo"><strong class="mg ir">const toCamelCase = </strong>sentence <strong class="mg ir">=&gt; </strong>sentence<strong class="mg ir">.split(</strong>' '<strong class="mg ir">)</strong><br/>    <strong class="mg ir">.map(</strong>capitalCaseWord<strong class="mg ir">)</strong><br/>    <strong class="mg ir">.join(</strong>''<strong class="mg ir">)</strong></span></pre><p id="dad9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以在上面的代码片段中，我们借用了上面例子中的代码，稍微修改了一下以适应我们的需要，现在无论你提供什么句子，都应该是<code class="fe mq mr ms mg b">returnedInCamelCase</code>！<code class="fe mq mr ms mg b">capitalCaseWord</code>函数现在接受索引，该索引表示迭代中的哪个单词被传递给它。我们不想大写第一个单词，所以我们简单地返回这个单词。否则，该功能将像以前一样工作。</p><p id="8830" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们看看运行这个函数的性能，好吗？</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/e9cf7e2c756fbdb09d0a712180477064.png" data-original-src="https://miro.medium.com/v2/resize:fit:1304/format:webp/1*qlMb0NPAuyKh3re9uTzUxg.png"/></div></figure><p id="54da" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">结果还不错。这真是太快了… JavaScript总是在不断优化，这些函数可能会比传统的for循环方法更好，如果不是更稳定的话。然而，这是假设他们的力量是用于好的方面。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ny"><img src="../Images/61db5ec1747ae4cd81ff28c280d7c9ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*72ykzT8tiB9Ivpco"/></div></div></figure><h1 id="2ec0" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">最后一个结论！</h1><p id="1b06" class="pw-post-body-paragraph jy jz iq ka b kb ne kd ke kf nf kh ki kj ng kl km kn nh kp kq kr ni kt ku kv ij bi translated">总之，使用JavaScript的原生字符串功能有很多好处。平均来说，执行时间可能会更快，代码更易读，更容易推理，而且相当简洁！</p><p id="d549" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里有一些参考资料，如果您想了解更多或者想开始在自己的代码库中实现这些原生函数(如果您还没有这样做的话),它们可能会激发您的兴趣！</p><p id="268d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae nz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String" rel="noopener ugc nofollow" target="_blank"> MDN字符串</a> <br/> <a class="ae nz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array" rel="noopener ugc nofollow" target="_blank"> MDN数组</a></p><p id="cc89" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">感谢你的阅读，我希望你喜欢并学到了一些东西。如果你碰巧有任何反馈、批评或贡献，请随意写在下面的评论区。</p><p id="246c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">再见韦德森。</p></div></div>    
</body>
</html>