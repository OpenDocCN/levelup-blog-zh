<html>
<head>
<title>How to run sequential tasks in TypeScript with fp-ts</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用fp-ts在TypeScript中运行顺序任务</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-run-sequential-tasks-in-fp-ts-8aa3be991f33?source=collection_archive---------1-----------------------#2021-11-21">https://levelup.gitconnected.com/how-to-run-sequential-tasks-in-fp-ts-8aa3be991f33?source=collection_archive---------1-----------------------#2021-11-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="4205" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">以打字打的文件</h2><div class=""/><p id="a702" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">将并行工作流转换为顺序工作流的简单方法</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi kx"><img src="../Images/a1555be88f0d414d99ec0446a52d1a19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pWpBL0yjXqJOuTgIKiDNUQ.jpeg"/></div></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk translated">来源:https://unsplash.com/</figcaption></figure><p id="795c" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">当处理异步编程时，您基本上可以在两种不同的工作流之间进行选择:作为一组并行任务运行和按顺序运行该组任务。虽然并行运行通常是最有效的选择，但有时也有顺序设置的原因。最容易忘记的是变量依赖，这意味着第二个任务依赖于第一个任务的输出。其他更微妙的情况是，例如，由于成本或许可问题，API不能并行处理多个请求，或者只允许顺序请求。</p><h1 id="e711" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">异步等待方法</h1><p id="e32d" class="pw-post-body-paragraph jz ka it kb b kc mm ke kf kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw im bi translated">让我们首先看看Typescript-native异步-await方法。这里，并行流非常简单，因为您可以使用内置的Promise功能:</p><pre class="ky kz la lb gt mr ms mt mu aw mv bi"><span id="51bc" class="mw lp it ms b gy mx my l mz na">const parallelResult = await Promise.all([task1(), task2()]);</span></pre><p id="3395" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">顺序流有点冗长，至少如果您想使用async-await的话。事实上，为此您需要一个专用的for循环:</p><pre class="ky kz la lb gt mr ms mt mu aw mv bi"><span id="2c73" class="mw lp it ms b gy mx my l mz na">const tasks: Array&lt;Promise&lt;string&gt;&gt; = [task1, task2];<br/>for (const task of tasks) {<br/>    await task();<br/>}</span></pre><h1 id="3214" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">fp-ts方法</h1><p id="a19a" class="pw-post-body-paragraph jz ka it kb b kc mm ke kf kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw im bi translated">如果您喜欢使用fp-ts进行函数式编程，并且希望编写函数而不是等待中间结果，那么您可能会处理以下两种结构:数组和任务。为了简单起见，我在这里不使用老大哥任务，但是您也可以将下面的方法应用于任务。</p><p id="6c37" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">与本机Typescript一样，并行流的fp-ts方法非常简单:</p><pre class="ky kz la lb gt mr ms mt mu aw mv bi"><span id="0475" class="mw lp it ms b gy mx my l mz na">import * as f from "fp-ts/function";<br/>import * as T from "fp-ts/Task";</span><span id="0ec7" class="mw lp it ms b gy nb my l mz na">const tasks: Array&lt;Task&lt;string&gt;&gt; = [task1, task2];</span><span id="a190" class="mw lp it ms b gy nb my l mz na">await f.pipe(tasks, T.sequenceArray)(); // Runs in parallel</span></pre><p id="70a8" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">我们将任务的数组转换成带有数组的单个任务，然后等待管道的并行执行。但是我们怎样才能顺序地运行这个任务呢？这里的关键是要理解“序列”不是任务的固有属性，而是数组的属性。因此，“T.sequenceArray”更像是一个辅助函数，也可以用等价的数组实例函数来表示:</p><pre class="ky kz la lb gt mr ms mt mu aw mv bi"><span id="0c45" class="mw lp it ms b gy mx my l mz na">import * as f from "fp-ts/function";<br/>import * as T from "fp-ts/Task";<br/>import * as Afrom "fp-ts/Array";</span><span id="d846" class="mw lp it ms b gy nb my l mz na">const tasks: Array&lt;Task&lt;string&gt;&gt; = [task1, task2];</span><span id="e99d" class="mw lp it ms b gy nb my l mz na">await f.pipe(tasks, A.sequence(T.ApplicativePar))(); // Runs in parallel</span></pre><p id="7ff3" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">你可能注意到了“A.sequence”的论点:我们需要在这里注入一个任务模块的应用实例，以使序列功能工作。令人欣慰的是，fp-ts为我们提供了并行执行所必需的应用程序:“T.ApplicativePar”。有了这些知识，最后一步就很容易了:我们不需要使用提供的Applicative进行并行执行，而是需要使用一个Applicative进行顺序执行:</p><pre class="ky kz la lb gt mr ms mt mu aw mv bi"><span id="4f34" class="mw lp it ms b gy mx my l mz na">import * as f from "fp-ts/function";<br/>import * as T from "fp-ts/Task";<br/>import * as Afrom "fp-ts/Array";</span><span id="e2cf" class="mw lp it ms b gy nb my l mz na">const tasks: Array&lt;Task&lt;string&gt;&gt; = [task1, task2];</span><span id="b9aa" class="mw lp it ms b gy nb my l mz na">await f.pipe(tasks, A.sequence(T.ApplicativeSeq))(); // Runs in sequence</span></pre><p id="335a" class="pw-post-body-paragraph jz ka it kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw im bi translated">这个简单的代码片段解决了整个谜团，代码看起来甚至比Promise for-loop中的代码还要干净。但是在图书馆里有更多额外的帮助来改善你的异步工作流程，只需在https://gcanti.github.io/fp-ts/modules/的<a class="ae ln" href="https://gcanti.github.io/fp-ts/modules/" rel="noopener ugc nofollow" target="_blank">查阅文档。</a></p></div></div>    
</body>
</html>