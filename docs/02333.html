<html>
<head>
<title>Building a scalable templatization engine using Amazon Web Services</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Amazon Web Services构建可伸缩的模板化引擎</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/building-a-scalable-templatization-engine-using-amazon-web-services-c44db96f05bd?source=collection_archive---------10-----------------------#2020-03-06">https://levelup.gitconnected.com/building-a-scalable-templatization-engine-using-amazon-web-services-c44db96f05bd?source=collection_archive---------10-----------------------#2020-03-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="dc32" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">可扩展架构</h2><div class=""/><div class=""><h2 id="6c76" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">关于设计可伸缩模板化引擎的综合文章</h2></div><p id="742f" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated"><em class="ln">免责声明:本文所表达的观点和意见均为作者个人观点和意见，不一定代表任何公司的官方政策或立场。</em></p></div><div class="ab cl lo lp hx lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="im in io ip iq"><p id="4532" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我一直对<a class="ae lv" href="https://aws.amazon.com/cloudformation/" rel="noopener ugc nofollow" target="_blank">亚马逊网络服务(AWS)的云形成</a>很着迷，因为它提供了一种从JSON/YAML模板中剥离出整个基础设施堆栈的方法。开发人员可以为他们的应用程序定义一个CloudFormation模板，并确保任何想要部署他们的应用程序的人都能够以系统和一致的方式这样做。</p><blockquote class="lw lx ly"><p id="100b" class="kr ks ln kt b ku kv kd kw kx ky kg kz lz lb lc ld ma lf lg lh mb lj lk ll lm im bi translated">AWS CloudFormation为您在云环境中建模和提供AWS和第三方应用资源提供了一种通用语言<br/>——亚马逊网络服务，2020</p></blockquote><p id="afd0" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">也就是说，我坚信<strong class="kt jd">能够基于一个定义好的JSON模板</strong>提供资源的概念可以应用于任何其他<strong class="kt jd">软件即服务(SaaS)应用</strong>。</p><p id="7502" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">大多数SaaS应用程序确实提供了RESTful APIs供用户使用，但通常情况下，它们不提供类似于CloudFormation的功能，开发者可以通过该功能声明一个JSON模板来提供SaaS应用程序中的所有资源。</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi mc"><img src="../Images/94db5176dbbbcb3157bd152d36be5b99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fScZzY8pB4A_2ACp0FVr0A.png"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">模板化引擎—高水平流量</figcaption></figure><p id="5060" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">因此，我决定为SaaS应用程序开发一个模板化引擎，能够实现CloudFormation为AWS所做的事情。这里需要注意的是，所选的SaaS应用程序必须具有为修改其资源而公开的API，即CRUD ( <strong class="kt jd"> C </strong> reate，<strong class="kt jd"> R </strong> ead，<strong class="kt jd"> U </strong> pdate，<strong class="kt jd"> D </strong> elete)。</p><h1 id="ea38" class="ms mt it bd mu mv mw mx my mz na nb nc ki nd kj ne kl nf km ng ko nh kp ni nj bi translated">1.挑战</h1><p id="e322" class="pw-post-body-paragraph kr ks it kt b ku nk kd kw kx nl kg kz la nm lc ld le nn lg lh li no lk ll lm im bi translated">为SaaS应用程序构建模板化引擎的主要挑战是:</p><ol class=""><li id="b58d" class="np nq it kt b ku kv kx ky la nr le ns li nt lm nu nv nw nx bi translated"><strong class="kt jd">模板的声明必须简单易懂</strong> —资源的规范必须符合SaaS应用程序的API模式</li><li id="815c" class="np nq it kt b ku ny kx nz la oa le ob li oc lm nu nv nw nx bi translated"><strong class="kt jd">快速、可靠</strong> —声明资源的处理必须快速(即，如果可能，声明资源的创建应该并行进行)</li><li id="94b0" class="np nq it kt b ku ny kx nz la oa le ob li oc lm nu nv nw nx bi translated"><strong class="kt jd">资源依赖管理</strong> —需要从另一个资源的创建结果中输入的资源必须被管理(即，资源#1需要资源#2的ID才能被创建)</li></ol><h1 id="a086" class="ms mt it bd mu mv mw mx my mz na nb nc ki nd kj ne kl nf km ng ko nh kp ni nj bi translated">2.架构设计考虑事项</h1><p id="4fac" class="pw-post-body-paragraph kr ks it kt b ku nk kd kw kx nl kg kz la nm lc ld le nn lg lh li no lk ll lm im bi translated">从一开始就获得正确的架构是很重要的，因为这是构建整个应用程序的基础。基于以下考虑，我决定构建模板化引擎:</p><ol class=""><li id="66a4" class="np nq it kt b ku kv kx ky la nr le ns li nt lm nu nv nw nx bi translated"><strong class="kt jd">云原生</strong> —利用云服务来构建和运行模板化引擎</li><li id="eafe" class="np nq it kt b ku ny kx nz la oa le ob li oc lm nu nv nw nx bi translated"><strong class="kt jd">水平可扩展性</strong> —允许计算资源的容量动态增加</li><li id="fa28" class="np nq it kt b ku ny kx nz la oa le ob li oc lm nu nv nw nx bi translated"><strong class="kt jd">事件驱动架构— </strong>摆脱传统的点对点集成</li><li id="9483" class="np nq it kt b ku ny kx nz la oa le ob li oc lm nu nv nw nx bi translated"><strong class="kt jd">无服务器架构</strong> —不为那些讨厌的服务器升级、打补丁、更新安全包</li><li id="d6e4" class="np nq it kt b ku ny kx nz la oa le ob li oc lm nu nv nw nx bi translated"><strong class="kt jd">微服务</strong> —基于功能“模块”的解耦处理逻辑，使得代码维护更加容易</li><li id="c917" class="np nq it kt b ku ny kx nz la oa le ob li oc lm nu nv nw nx bi translated"><strong class="kt jd">处理逻辑的执行速度</strong>—不需要任何依赖关系的资源应该并行处理</li></ol><h1 id="5e8d" class="ms mt it bd mu mv mw mx my mz na nb nc ki nd kj ne kl nf km ng ko nh kp ni nj bi translated">3.解决办法</h1><p id="608f" class="pw-post-body-paragraph kr ks it kt b ku nk kd kw kx nl kg kz la nm lc ld le nn lg lh li no lk ll lm im bi translated">模板化引擎完全建立在AWS之上，具有上面列出的所有架构设计考虑。</p><p id="fa27" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">解决方案组件:</p><ol class=""><li id="1268" class="np nq it kt b ku kv kx ky la nr le ns li nt lm nu nv nw nx bi translated"><a class="ae lv" href="#f670" rel="noopener ugc nofollow">基础设施即代码</a></li><li id="3c64" class="np nq it kt b ku ny kx nz la oa le ob li oc lm nu nv nw nx bi translated"><a class="ae lv" href="#4ea7" rel="noopener ugc nofollow"> RESTful API端点</a></li><li id="dd4b" class="np nq it kt b ku ny kx nz la oa le ob li oc lm nu nv nw nx bi translated"><a class="ae lv" href="#5df2" rel="noopener ugc nofollow">事件驱动架构</a></li><li id="5e3e" class="np nq it kt b ku ny kx nz la oa le ob li oc lm nu nv nw nx bi translated"><a class="ae lv" href="#b52a" rel="noopener ugc nofollow"> App模块——无服务器微服务</a></li><li id="7cc4" class="np nq it kt b ku ny kx nz la oa le ob li oc lm nu nv nw nx bi translated"><a class="ae lv" href="#29e1" rel="noopener ugc nofollow">依赖关系管理</a></li><li id="732c" class="np nq it kt b ku ny kx nz la oa le ob li oc lm nu nv nw nx bi translated"><a class="ae lv" href="#7c2b" rel="noopener ugc nofollow">轮询服务</a></li><li id="79bd" class="np nq it kt b ku ny kx nz la oa le ob li oc lm nu nv nw nx bi translated"><a class="ae lv" href="#b796" rel="noopener ugc nofollow">响应服务</a></li><li id="4b1d" class="np nq it kt b ku ny kx nz la oa le ob li oc lm nu nv nw nx bi translated"><a class="ae lv" href="#e560" rel="noopener ugc nofollow">样本模板格式</a></li></ol><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi od"><img src="../Images/83ce8e31675e45a559049d5bf3a9b363.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1ZvBn52u4bx6IuD5VrWefQ.png"/></div></div></figure><h2 id="f670" class="oe mt it bd mu of og dn my oh oi dp nc la oj ok ne le ol om ng li on oo ni iz bi translated">1.基础设施即代码</h2><p id="5193" class="pw-post-body-paragraph kr ks it kt b ku nk kd kw kx nl kg kz la nm lc ld le nn lg lh li no lk ll lm im bi translated">从一开始，模板化引擎的AWS资源的整个声明就在<a class="ae lv" href="https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/what-is-sam.html" rel="noopener ugc nofollow" target="_blank"> AWS SAM </a>上完成，这是CloudFormation的扩展。我强调<strong class="kt jd">而不是</strong>使用AWS控制台创建任何资源，以符合“基础设施即代码”策略。AWS SAM已被证明非常有用，因为它允许您将整个应用程序架构迁移到新的AWS帐户或部署新的开发环境(即s it，UAT)，只需两个简单的SAM CLI命令(<code class="fe op oq or os b">sam package</code> &amp; <code class="fe op oq or os b">sam deploy</code>)</p><p id="db21" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我采用的AWS SAM(或CloudFormation)策略之一是将模板分成两部分，以便在添加SaaS应用程序的附加模块/功能时具有更好的可伸缩性。</p><p id="359c" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">这两个部分是:</p><ol class=""><li id="4a29" class="np nq it kt b ku kv kx ky la nr le ns li nt lm nu nv nw nx bi translated">基础架构模板——提供模板化引擎运行所需的所有必要资源(除应用模块之外的所有资源)的根模板。这样的模板<strong class="kt jd">应该只有一个</strong>。</li><li id="bc10" class="np nq it kt b ku ny kx nz la oa le ob li oc lm nu nv nw nx bi translated">应用模块模板—每个应用模块模板将由1个SQS队列、1个SQS死信队列和1个Lambda函数组成。根据需要创建任意数量的应用模块模板。我通常按照功能来划分(即“用户”将被视为一个应用模块，“订单”将被视为另一个应用模块)。</li></ol><p id="2eec" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">利用CloudFormation的<a class="ae lv" href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/walkthrough-crossstackref.html" rel="noopener ugc nofollow" target="_blank">交叉堆栈引用</a> ( <code class="fe op oq or os b">Export</code> &amp; <code class="fe op oq or os b">Fn::ImportValue</code>)，应用模块模板将能够利用基础架构模板的输出。通过这样做，随着模板化引擎支持的功能数量的增加，我能够添加更多的应用模块模板，而无需实际编辑核心基础架构模板。</p><h2 id="4ea7" class="oe mt it bd mu of og dn my oh oi dp nc la oj ok ne le ol om ng li on oo ni iz bi translated">2.RESTful API端点</h2><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi ot"><img src="../Images/a430bb026a1f6052259dbd88d5c9f146.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OiPLBxcNj3oiwCUGbwi58Q.png"/></div></div></figure><p id="5f62" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">用户或应用程序与模板化引擎交互的主要方式是通过由Amazon API Gateway和Lambda函数支持的RESTful API接口。</p><p id="e0e9" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">API端点通过一个<code class="fe op oq or os b">POST</code>方法接受一个JSON模板(<code class="fe op oq or os b">Content-Type: application/json</code>)。</p><p id="70a6" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">除了作为调用Lambda函数的接口，Amazon API Gateway还可以执行API认证、API计划、API速率限制等。此外，一旦客户端应用程序的API流量达到某个阈值，模板化引擎就会提供一个<a class="ae lv" href="https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-websocket-api.html" rel="noopener ugc nofollow" target="_blank"> Web套接字连接</a>来实现更好的可伸缩性和可靠性。</p><p id="226c" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">一旦Amazon API网关调用了入站微服务Lambda，它就会执行以下操作:</p><ul class=""><li id="741d" class="np nq it kt b ku kv kx ky la nr le ns li nt lm ou nv nw nx bi translated">执行基本的语法验证，以确保传入的模板格式是有效的</li><li id="34ab" class="np nq it kt b ku ny kx nz la oa le ob li oc lm ou nv nw nx bi translated">基于<a class="ae lv" href="https://www.ietf.org/rfc/rfc4122.txt" rel="noopener ugc nofollow" target="_blank"> RFC 4122 </a>规范生成一个UUID(版本4)以标记到传入的模板化请求。该UUID将贯穿请求的整个生命周期。</li><li id="c026" class="np nq it kt b ku ny kx nz la oa le ob li oc lm ou nv nw nx bi translated">将传入的请求(附加了UUID)发布到简单通知服务(SNS)主题</li></ul><p id="9090" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">由于入站微服务是与外界交互的API端点，并且为了使该API具有最佳响应时间，需要始终保持Lambda函数温暖。Lambda的问题是Lambda调用有开销，这是为函数代码设置执行环境所花费的时间，并且完全由AWS控制。因此，我配置了一个CloudWatch的基于时间的规则，它每10分钟周期性地调用Lambda函数。或者，AWS有一个名为<a class="ae lv" href="https://aws.amazon.com/blogs/compute/new-for-aws-lambda-predictable-start-up-times-with-provisioned-concurrency/" rel="noopener ugc nofollow" target="_blank"> Provisioned Concurrency </a>的新特性，它旨在允许Lambda函数被初始化和超级就绪。</p><h2 id="5df2" class="oe mt it bd mu of og dn my oh oi dp nc la oj ok ne le ol om ng li on oo ni iz bi translated">3.事件驱动架构</h2><blockquote class="lw lx ly"><p id="4bf9" class="kr ks ln kt b ku kv kd kw kx ky kg kz lz lb lc ld ma lf lg lh mb lj lk ll lm im bi translated">事件驱动架构使用事件来触发解耦服务并在它们之间进行通信，这在使用微服务构建的现代应用程序中很常见。</p></blockquote><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi ov"><img src="../Images/452a5a750dc70771704811ea3dc88038.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9eQkIJWYn5_I4OcJZSvjcg.png"/></div></div></figure><p id="59f9" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">入站微服务会将每个模板化请求作为事件消息发布到SNS请求主题中。拥有SNS主题的目的是为了满足未来的需求，即消息可以一次发布到多个队列，以处理不同的功能用例(即安全审计、通知)。最重要的是，拥有一个发布-订阅架构可以在一个资源声明JSON模板中支持多个SaaS应用程序。</p><p id="f4fc" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">通过使用订阅SNS请求主题的SQS队列，我们能够将传入的请求与实际的模板化引擎分离。同样，模板化请求也可以保存在SQS队列中，以防止传输过程中任何意外的数据丢失。</p><p id="e2e5" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">App Request Parser Lambda充当模板化引擎的“请求路由器”。它负责接收、过滤事件并将事件推送给适当的消费者(即应用程序模块)。请求解析器Lambda未能处理的任何传入请求都将被扔进死信队列，以进行进一步的错误处理。这确保了在应用程序失败时不会丢失模板化请求。</p><p id="1390" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在应用程序级别，应用程序请求解析器Lambda负责:</p><ol class=""><li id="cad3" class="np nq it kt b ku kv kx ky la nr le ns li nt lm nu nv nw nx bi translated">确定JSON模板中是否声明了依赖关系。如果有依赖关系，调用依赖关系管理步骤功能(更多信息在<a class="ae lv" href="#29e1" rel="noopener ugc nofollow">依赖关系管理服务部分</a></li><li id="e724" class="np nq it kt b ku ny kx nz la oa le ob li oc lm nu nv nw nx bi translated">将模板化请求JSON模板分解成各自的App模块模板，同时发送给各自的SQS队列<strong class="kt jd"/>。这使我们能够减少总处理时间，因为不同的应用程序模块可以并行处理相同的模板化请求。</li></ol><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi ow"><img src="../Images/88c02f1d1c2e90649ce695c46b5933be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jxFrRQG2wBR5DPG0DbYYRw.png"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">将模板化请求JSON模板分解成更小的部分</figcaption></figure><p id="513c" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">3.出于记录保存的目的，将传入的请求持久化到DynamoDB中</p><h2 id="b52a" class="oe mt it bd mu of og dn my oh oi dp nc la oj ok ne le ol om ng li on oo ni iz bi translated">4.应用模块—无服务器微服务</h2><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi ox"><img src="../Images/ddd60d2216a9fee41f46439a58ac74da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*itzdMWwe64txGWl7VM2B-w.png"/></div></div></figure><p id="96fd" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">应用程序模块由SaaS应用程序提供的一组特定功能来定义。根据您尝试进行模板化的SaaS应用程序，您可以拥有任意多的应用程序模块。</p><p id="e290" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">通过使用不同的应用程序模块，我们能够将大的模板化请求JSON模板分解成较小的模板，然后<strong class="kt jd">并行处理它们</strong>，以获得最佳的总处理时间。</p><p id="8821" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">尽管我们对应用模块的“划分”越精细，模板化引擎的处理速度就越快，但我们需要能够在处理时间以及整个架构的成本和维护工作之间取得平衡。</p><p id="5f9b" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">让我们以SaaS应用程序的Shopify为例，看看如何定义应用程序模块。通过查看<a class="ae lv" href="https://shopify.dev/concepts/about-apis" rel="noopener ugc nofollow" target="_blank"> Shopify的开发者文档</a>，我实际上将它分成了3个不同的应用模块(<em class="ln"> AJAX和Liquid APIs与供应资源无关，因此将被忽略</em>)。</p><ol class=""><li id="ee1f" class="np nq it kt b ku kv kx ky la nr le ns li nt lm nu nv nw nx bi translated">应用模块#1:管理</li><li id="8ac0" class="np nq it kt b ku ny kx nz la oa le ob li oc lm nu nv nw nx bi translated">应用模块#2:店面</li><li id="41c4" class="np nq it kt b ku ny kx nz la oa le ob li oc lm nu nv nw nx bi translated">应用模块#3:分析</li></ol><p id="6fcb" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">每个应用模块都有自己的SQS队列、Lambda函数和SQS死信队列。通过拥有专用的SQS队列和死信队列，我们将能够配置与特定应用模块相关的单独设置(<code class="fe op oq or os b">VisibilityTimeout</code>、<code class="fe op oq or os b">ReceiveMessageWaitTimeSeconds</code>、<code class="fe op oq or os b">MessageRetentionPeriod</code>和<code class="fe op oq or os b">RedrivePolicy</code>，因为每个应用模块<em class="ln">可能有不同的要求。</em></p><p id="81f5" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">SQS队列将负责促进特定应用模块的传入请求，而Lambda将充当微服务来处理传入的JSON模板，并相应地提供适当的资源。一旦应用程序模块Microservice Lambda成功处理了请求，它就会将包含所供应资源的所有元数据的消息发布到响应队列中。</p><p id="a74b" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">由应用模块微服务Lambda函数抛出的任何故障将被自动放置在应用模块SQS死信队列中。</p><h2 id="29e1" class="oe mt it bd mu of og dn my oh oi dp nc la oj ok ne le ol om ng li on oo ni iz bi translated">5.依赖性管理服务</h2><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi oy"><img src="../Images/be4b7b0fb96ab3edee7d02e18de95db2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zGl7-BrSjU-y9zBC3feoMw.png"/></div></div></figure><p id="e8c9" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">依赖性管理是模板化引擎中最关键和最复杂的组件，因为该引擎需要知道已经声明的所有不同资源的创建顺序。</p><p id="7adc" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">依赖关系可以通过下面的例子来理解:</p><blockquote class="lw lx ly"><p id="2eae" class="kr ks ln kt b ku kv kd kw kx ky kg kz lz lb lc ld ma lf lg lh mb lj lk ll lm im bi translated">在资源A可以被供应之前，它需要被供应的资源b的输出(例如，ID)</p></blockquote><p id="fda5" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">我们试图通过依赖关系管理实现的是，我们希望同时拥有一个模板化请求JSON模板和<strong class="kt jd"/>，能够处理所有的依赖关系，以了解首先创建哪些资源，以及在获得所有所需数据之前延迟创建哪些资源。</p><p id="c64c" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">在模板化请求JSON模板中，用户需要为依赖关系管理定义2个属性:</p><ol class=""><li id="7bc3" class="np nq it kt b ku kv kx ky la nr le ns li nt lm nu nv nw nx bi translated">在那些您希望被引用的资源上提供一个唯一的<code class="fe op oq or os b">reference_id</code></li><li id="041f" class="np nq it kt b ku ny kx nz la oa le ob li oc lm nu nv nw nx bi translated">对于那些需要在创建之前从reference_id转换ID或键的对象，使用<code class="fe op oq or os b">{{unique-value-that-you-have-provided-in-the-reference-id}}</code></li></ol><p id="9324" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">通过进一步扩展上面的依赖关系示例，模板化请求JSON模板将如下所示:</p><pre class="md me mf mg gt oz os pa pb aw pc bi"><span id="39d1" class="oe mt it os b gy pd pe l pf pg">{<br/>   "authentication":{<br/>      "saas_account_id":"1717",<br/>      "username":"leroychan",<br/>      "api_token":"xxx"<br/>   },<br/>   "resource": [<br/>     {<br/>       "name": "A",<br/>       "foreign_key": "{{id-of-resource-B}}"<br/>     },<br/>     {<br/>       "name": "B",<br/>       "reference_id": "id-of-resource-B"<br/>     }<br/>  ]<br/>}</span></pre><p id="be96" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">书面上，上述样本模板将是:</p><blockquote class="lw lx ly"><p id="18c2" class="kr ks ln kt b ku kv kd kw kx ky kg kz lz lb lc ld ma lf lg lh mb lj lk ll lm im bi translated">请先创建资源B，并将创建的资源B的ID分配给<code class="fe op oq or os b">id-of-resource-B</code>。一旦创建了资源B，请创建资源A并让<code class="fe op oq or os b">foreign_key</code>属性值成为<code class="fe op oq or os b">id-of-resource-B</code>的输出。</p></blockquote><p id="3ddd" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">既然我们已经得到了依赖管理的语法声明，让我们把注意力集中在处理逻辑部分。</p><p id="a550" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">依赖微服务有两个功能组件:</p><ol class=""><li id="3dc4" class="np nq it kt b ku kv kx ky la nr le ns li nt lm nu nv nw nx bi translated">依存解析器</li><li id="f10f" class="np nq it kt b ku ny kx nz la oa le ob li oc lm nu nv nw nx bi translated">依赖性处理</li></ol><p id="4204" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">依赖解析器最终负责确定所声明的资源的创建顺序，这将由依赖类型决定。</p><p id="750c" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">这两种依赖类型是:</p><ol class=""><li id="2b74" class="np nq it kt b ku kv kx ky la nr le ns li nt lm nu nv nw nx bi translated"><code class="fe op oq or os b">dependency#reference</code>:可以立即创建并在创建后保留ID的资源。这适用于已经声明了<code class="fe op oq or os b">reference_id</code>并且在其模板中不包含任何<code class="fe op oq or os b">{{value}}</code>的资源</li><li id="d6cc" class="np nq it kt b ku ny kx nz la oa le ob li oc lm nu nv nw nx bi translated"><code class="fe op oq or os b">dependency#payload</code>:需要延迟创建的资源，直到模板中声明的所有<code class="fe op oq or os b">{{value}}</code>都被解析</li></ol><p id="9833" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">下面的流程图显示了确定依赖类型的逻辑情况:</p><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi ph"><img src="../Images/60d1b1ab8a547edd24f38f3b39c2b737.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kjS65VZtnGw_kXPuTdl9qg.png"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">依赖性分析器工作流</figcaption></figure><p id="d95f" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">至于依赖处理，本质上是按照AWS Steps函数定义的状态机运行的Lambda微服务。也就是说，依赖性微服务Lambda将一直运行，直到<strong class="kt jd">所需的所有</strong>依赖性都已被解决并且<strong class="kt jd">所有</strong>资源都已被提供。</p><h2 id="7c2b" class="oe mt it bd mu of og dn my oh oi dp nc la oj ok ne le ol om ng li on oo ni iz bi translated">6.轮询服务</h2><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi pi"><img src="../Images/06636cfbc1c489af44835762e79ee830.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2Qe7vTxFb1w-KlaH_dSTUQ.png"/></div></div></figure><p id="d687" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">SaaS应用程序的某些API实际上是异步的。这些API不会在创建后立即返回ID，而是为您提供一个<code class="fe op oq or os b">job_id</code>,要求您不断轮询以了解资源是否已成功创建。</p><p id="181f" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">通常，SaaS应用程序会将耗时且资源密集的任务视为异步作业。</p><p id="693a" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">例如:</p><ol class=""><li id="1eb7" class="np nq it kt b ku kv kx ky la nr le ns li nt lm nu nv nw nx bi translated">上传应用程序</li><li id="be43" class="np nq it kt b ku ny kx nz la oa le ob li oc lm nu nv nw nx bi translated">上传附件</li><li id="3d39" class="np nq it kt b ku ny kx nz la oa le ob li oc lm nu nv nw nx bi translated">创建分析报告</li></ol><p id="2125" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">轮询微服务就是为了做到这一点。每当资源创建实际上是SaaS应用程序端的异步作业时，它就会被App模块的微服务(通过AWS步骤函数)触发。轮询微服务将在设定的3秒间隔内保持运行，直到<code class="fe op oq or os b">job_id</code>返回成功(或失败)。</p><h2 id="b796" class="oe mt it bd mu of og dn my oh oi dp nc la oj ok ne le ol om ng li on oo ni iz bi translated">7.响应服务</h2><figure class="md me mf mg gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi ov"><img src="../Images/b76667d35efe19a7f0f4d406c71df057.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pd2uX9gCqW92ow8kUvZn-w.png"/></div></div></figure><p id="2bb0" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">所有的应用模块微服务将发送成功(状态代码:<code class="fe op oq or os b">2xx</code>)或失败消息(状态代码:任何不是<code class="fe op oq or os b">2xx</code>的消息)到正在创建的<strong class="kt jd">每个</strong>单独资源的SQS响应队列，以及所有相关的元数据，如ID和创建时间。</p><p id="b1ad" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">然后，响应微服务负责从队列中提取这些消息，并将其保存在DynamoDB上。</p><p id="6bfe" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">重要的是让所有单独提供的资源持久化，以便在声明的模板化请求JSON模板中的任何资源创建失败时便于回滚。</p><h2 id="e560" class="oe mt it bd mu of og dn my oh oi dp nc la oj ok ne le ol om ng li on oo ni iz bi translated">8.样本模板格式</h2><p id="3728" class="pw-post-body-paragraph kr ks it kt b ku nk kd kw kx nl kg kz la nm lc ld le nn lg lh li no lk ll lm im bi translated">以下是SaaS应用程序的模板化请求JSON模板示例:</p><pre class="md me mf mg gt oz os pa pb aw pc bi"><span id="771c" class="oe mt it os b gy pd pe l pf pg">{<br/>   "authentication":{<br/>      "saas_account_id":"1717",<br/>      "username":"leroychan",<br/>      "api_token":"xxx"<br/>   },<br/>   "users":[<br/>      {<br/>         "name":"John Tan",<br/>         "email":"<a class="ae lv" href="mailto:johntan@gmail.com" rel="noopener ugc nofollow" target="_blank">johntan@gmail.com</a>",<br/>         "reference_id":"user-john"<br/>      },<br/>      {<br/>         "name":"Amy Lim",<br/>         "email":"<a class="ae lv" href="mailto:amylim@gmail.com" rel="noopener ugc nofollow" target="_blank">amylim@gmail.com</a>",<br/>         "reference_id":"user-amy"<br/>      }<br/>   ],<br/>   "orders":[<br/>      {<br/>         "type":"new_order",<br/>         "ordered_by":"{{user-john}}",<br/>         "total_amount":"$144.50"<br/>      },<br/>      {<br/>         "type":"new_order",<br/>         "ordered_by":"{{user-amy}}",<br/>         "total_amount":"$87.20"<br/>      }<br/>   ]<br/>}</span></pre><p id="8437" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">如果我必须将示例模板翻译成句子格式，它将是:</p><blockquote class="pj"><p id="758d" class="pk pl it bd pm pn po pp pq pr ps lm dk translated">在SaaS应用程序中我现有的帐户(SaaS帐户ID: 1717)上，请帮我创建2个新用户(约翰和艾米)，一旦完成，创建2个订单。约翰一张，艾米一张，总金额分别为144.50美元和87.20美元。</p></blockquote><p id="22ce" class="pw-post-body-paragraph kr ks it kt b ku pt kd kw kx pu kg kz la pv lc ld le pw lg lh li px lk ll lm im bi translated">样本模板中声明了3个对象:</p><ol class=""><li id="8d13" class="np nq it kt b ku kv kx ky la nr le ns li nt lm nu nv nw nx bi translated"><code class="fe op oq or os b">authentication</code> —负责获取有关SaaS帐户信息的信息，以执行必要的资源供应</li><li id="26ab" class="np nq it kt b ku ny kx nz la oa le ob li oc lm nu nv nw nx bi translated"><code class="fe op oq or os b">users</code> —用户应用模块。数组中声明的每个对象属性都对应于SaaS应用程序提供的用户API的模式</li><li id="239a" class="np nq it kt b ku ny kx nz la oa le ob li oc lm nu nv nw nx bi translated"><code class="fe op oq or os b">orders</code> —订单应用模块。数组中声明的每个对象属性都对应于SaaS应用程序提供的订单API的模式</li></ol></div><div class="ab cl lo lp hx lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="im in io ip iq"><h1 id="fdd0" class="ms mt it bd mu mv py mx my mz pz nb nc ki qa kj ne kl qb km ng ko qc kp ni nj bi translated">摘要</h1><p id="a1f2" class="pw-post-body-paragraph kr ks it kt b ku nk kd kw kx nl kg kz la nm lc ld le nn lg lh li no lk ll lm im bi translated">模板化引擎的最终架构是<strong class="kt jd">解耦</strong>、<strong class="kt jd">高效</strong>、<strong class="kt jd">T5】和<strong class="kt jd">可扩展</strong>。如您所知，模板化引擎需要大量的服务和应用程序逻辑才能无缝运行。AWS提供了一系列服务，可以帮助减轻您的负担，让您能够专注于应用程序逻辑。</strong></p><p id="c42f" class="pw-post-body-paragraph kr ks it kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm im bi translated">也就是说，架构是应用程序的基础，从一开始就正确设计它是很重要的。</p></div></div>    
</body>
</html>