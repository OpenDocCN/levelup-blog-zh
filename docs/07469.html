<html>
<head>
<title>A Cheap &amp; Fast Hack To Improving Deployments With Feature Flags</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用特性标志改进部署的廉价而快速的方法</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/a-cheap-fast-hack-to-improving-deployments-with-feature-flags-5bdbf18362cc?source=collection_archive---------8-----------------------#2021-02-20">https://levelup.gitconnected.com/a-cheap-fast-hack-to-improving-deployments-with-feature-flags-5bdbf18362cc?source=collection_archive---------8-----------------------#2021-02-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/ad0b0c451bea7de1e927b8784b8377bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1304/format:webp/1*jIDIpdsXCXYrsgGDJtJdgA.jpeg"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">跌倒了，但爬得很快</figcaption></figure><p id="68c2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi kw translated">我们以前都去过那里，或者至少，你会很快到达那里；您已经在测试环境中测试了您的代码，一切看起来都很完美，事实上，团队中的每个人都感谢您在集成第三方服务提供商方面所做的出色工作。你很自豪，这是一个星期五的晚上，部署团队将在用户流量相对较低的晚上进行部署。</p><p id="fb13" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以你离😎“TGIF venue”(因为你计划在今晚的游戏之夜和一些朋友出去玩)，然后电话来了，“我们有一个问题”。是的，<a class="ae lf" href="https://en.wikipedia.org/wiki/Murphy%27s_law" rel="noopener ugc nofollow" target="_blank">墨菲定律</a>再次发挥作用。</p><p id="33cf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你感到震惊，但并不震惊，这不是你第一次在生产中搞砸事情，是吗？(不错..欢迎加入俱乐部🎉🎉🎉).</p><p id="db57" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">无论如何，你花了接下来的两个小时试图找出你的生活和测试环境之间出了什么问题，毕竟，它在测试中一切正常，QA甚至批准了这个推送。好吧，你最终发现了问题，解决了问题，好吧，每个人又都开心了，但是你只是厌倦了你的周五之夜被毁了。或者至少，用完了😥😥哦，是的，你们的人也已经结束了游戏之夜。</p></div><div class="ab cl lg lh hu li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="ij ik il im in"><p id="3c32" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi kw translated"><span class="l kx ky kz bm la lb lc ld le di"> T </span>这就是这篇文章的来源，已经有过几次这样的问题，我总是最终感觉自己像一个糟糕的工程师，总是不能第一次就让一些东西工作。我的意思是，我也有我的好时光，但我希望那是永远的(我也想成为10倍的工程师😂).</p><p id="2b75" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">无论如何，本文描述的是一种构建软件的方法，这种方法可以让您在部署现有应用程序的更新和修复时“高枕无忧”，尤其是那些不能承受任何停机时间的敏感应用程序。这种方法的总结就是确保当你对你的代码做了一个改变，而它在生产环境中失败了，你可以安全地立即<strong class="ka ir">“回退”</strong>，而不需要回滚或推出新的代码来修补失败。从而使你的应用具有所有好软件的品质:<a class="ae lf" href="https://searchdisasterrecovery.techtarget.com/definition/fault-tolerant" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">容错</strong> </a> <strong class="ka ir">。</strong></p></div><div class="ab cl lg lh hu li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="ij ik il im in"><p id="1227" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> <em class="ln">我这样做的软件的背景..</em> </strong></p><p id="ce64" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我从事金融服务软件的工作，大多数时候，客户需要获得对其交易状态的即时响应。例如，当用户试图在银行账户上进行跨行转账或购买通话时间时，我们无法承受停机时间，即使是5分钟，用户的体验也会被中断，有时甚至会被破坏。此外，我们不能只给用户失败的回应(由于失败的功能更新)，因为我们也会给我们的客户一个坏的品牌形象。</p><p id="959e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，考虑到这些限制，以及上面那个被毁掉的周五游戏之夜的故事，很明显我们需要一种方法来尽可能无缝地对我们的应用程序进行<strong class="ka ir">软件更新和功能添加</strong>。由于我们根本不能让我们的用户失败或延迟，所以<a class="ae lf" href="https://docs.microsoft.com/en-us/azure/devops/migrate/phase-features-with-feature-flags?view=azure-devops" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">特性标志</strong> </a> <strong class="ka ir">(以及【选择性路由】</strong>来救驾💪💪。</p><p id="ea05" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi kw translated">现在，功能标志已经存在了好几年了，然而下面的推文让我第一次知道(“发现”)了它们。LOL，如果你一直在用功能标志，不要笑我。我真的很惊讶地发现如此简单的东西如何能够解决我的部署问题，并大大提高我部署软件更新的信心。</p><figure class="lo lp lq lr gt jr"><div class="bz fp l di"><div class="ls lt l"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">让我了解功能标志的推文</figcaption></figure><p id="027a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> <em class="ln">让我们来看看到底发生了什么</em> </strong>:我们需要在目前使用的服务提供商之外添加一个新的第三方服务提供商。现有的供应商有稳定和工作的API，为我们提供了很好的服务，但是，我们需要开始与新的家伙做生意，并随后用旧的供应商取代他们。</p><blockquote class="lu lv lw"><p id="f2d6" class="jy jz ln ka b kb kc kd ke kf kg kh ki lx kk kl km ly ko kp kq lz ks kt ku kv ij bi translated"><strong class="ka ir">旧方法:</strong>通过删除旧供应商并为新供应商实现API来更新基于代码的方法，在部署时，如果有任何失败，我们会快速回滚到旧代码库并使用旧供应商，直到新供应商的问题得到解决。嗯，在两周前，这是我的标准😄，但再也不会了。</p><p id="0b28" class="jy jz ln ka b kb kc kd ke kf kg kh ki lx kk kl km ly ko kp kq lz ks kt ku kv ij bi translated"><strong class="ka ir">新方法:</strong>保留旧供应商的实现，并使用条件语句(if-else)来重新构建代码，这些条件语句可以动态配置，以确定您是希望将请求仅路由到<strong class="ka ir">旧供应商</strong>还是仅路由到<strong class="ka ir">新供应商</strong>，甚至在某些情况下，您可以执行部分或“百分比路由”，这样您只能将20%的流量路由到新供应商，在将100%的流量路由到新供应商之前监控成功情况。如果可能的话，提示一些原始的负载平衡器或<a class="ae lf" href="https://www.modernanalyst.com/Careers/InterviewQuestions/tabid/128/ID/5041/What-is-a-canary-release-and-what-are-some-of-the-benefits.aspx" rel="noopener ugc nofollow" target="_blank">金丝雀释放</a>。</p><p id="7f41" class="jy jz ln ka b kb kc kd ke kf kg kh ki lx kk kl km ly ko kp kq lz ks kt ku kv ij bi translated"><strong class="ka ir">全部不部署或回滚</strong></p><p id="6967" class="jy jz ln ka b kb kc kd ke kf kg kh ki lx kk kl km ly ko kp kq lz ks kt ku kv ij bi translated"><strong class="ka ir">您会同意，这是旧方法的一大改进，因为我们不再需要担心让所有客户失望或停机，因为我们确信，只有一小部分请求会发送到新供应商，如果新供应商完全失败，我们可以立即切换功能标志，将请求发送到旧供应商。</strong></p></blockquote><h1 id="95f2" class="ma mb iq bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">它到底是如何工作的？</h1><p id="27fb" class="pw-post-body-paragraph jy jz iq ka b kb my kd ke kf mz kh ki kj na kl km kn nb kp kq kr nc kt ku kv ij bi translated">因为这是我自己刚刚弄明白的事情，它可能不是那么“标准”，但是它肯定会引导你的思维，让你明白如何接近它。实际上，这一部分的目的是<strong class="ka ir">给你如何工作的指导，所以实现它完全取决于你，因为你的软件架构和需求可能与我的不同。</strong></p><p id="5061" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我这样说是因为在未来，我的方法很可能变得效率更低，然而，基本的思维过程(容错)将总是相关的。</p><blockquote class="lu lv lw"><p id="8baa" class="jy jz ln ka b kb kc kd ke kf kg kh ki lx kk kl km ly ko kp kq lz ks kt ku kv ij bi translated">现在，对于我自己的使用案例:我们希望在新供应商和旧供应商之间分割广播时间的处理，我们将20%的流量路由到新供应商，80%路由到旧供应商。如果新的供应商失败，所有的交易都被路由到旧的供应商，因此<strong class="ka ir">没有交易失败</strong>。</p></blockquote><p id="030e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在处理事务的“演示”类中，我初始化了一个名为“<strong class="ka ir"> RouteRate </strong>的变量和另一个“<strong class="ka ir"> RecordToProcess </strong>”的变量。</p><figure class="lo lp lq lr gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi nd"><img src="../Images/037637e7925e70b63e0c7c037369b14e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZvihQD2yhoJk9n0xjP4wjw.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated">演示代码截图(*这是用C#写的)</figcaption></figure><p id="6be1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> RouteRate (RR) </strong>是一个很容易配置的数字(最好是在一个可以很容易更改的配置文件中)，这个数字的作用只是确定通过新供应商处理的交易的百分比。例如，如果RR是1，它简单地意味着路由每一个<strong class="ka ir">1/1个</strong>记录(即100%)，如果RR是2，那么它意味着路由每一个<strong class="ka ir">1/2个</strong>记录(50%)；3表示3条记录中的路线1(33%)，而4表示每4笔交易中的路线1(25%)..以此类推，直到10 (10%)。</p><p id="daf2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另一个变量，<strong class="ka ir"> RecordToProcess。ID </strong>是一个唯一的递增数字，用于标识正在处理的记录，通常每个批处理作业都有这个唯一的ID。</p><p id="01dc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">决定使用哪家供应商的逻辑是图像中的第26行，这是一个简单的数学运算，称为“<a class="ae lf" href="https://en.wikipedia.org/wiki/Modulo_operation" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">【模运算】</strong> </a>”，模运算(用%<strong class="ka ir">符号表示)</strong>只是返回两个正数相除的余数。例如3 mod 2 = 1；4 mod 2 = 0；</p><p id="6d67" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以，既然RR是固定的，而<strong class="ka ir"> RecordToProcess。ID(待处理交易的编号标识符)</strong>总是在变化/增加，形成一种模式。例如，如果RR= 5，则在每5次交易后，模运算将仅等于0，这等于1/5，即20%的记录。如前所述，这意味着只有20%的交易将被路由到新的供应商..</p><p id="e5e0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，基于这一行，为每个事务执行的代码块由以下数学计算确定:</p><blockquote class="lu lv lw"><p id="6adc" class="jy jz ln ka b kb kc kd ke kf kg kh ki lx kk kl km ly ko kp kq lz ks kt ku kv ij bi translated"><strong class="ka ir">记录流程。ID % RouteRate！= 0 </strong></p></blockquote><p id="436d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">总之，如果评估值为零，它将路由到新供应商，否则，它将路由到旧供应商的代码块的逻辑路由。</p><p id="93cf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以再次参考上面的代码截图来理解这是如何工作的，以防有点混乱。</p><h1 id="e23f" class="ma mb iq bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">最后步骤:</h1><p id="c40e" class="pw-post-body-paragraph jy jz iq ka b kb my kd ke kf mz kh ki kj na kl km kn nb kp kq kr nc kt ku kv ij bi translated">在监控应用程序日志一段时间后，您现在将检查新供应商是否成功处理了发送给它的所有交易？如果是的话，那么您可以将<strong class="ka ir"> RouteRate的值编辑为1，这只是将100%的事务路由到新的供应商，否则，如果新的供应商失败，您可以将记录更新为一个非常大的随机数(例如123902300 ),这样新的供应商新代码块就不会将任何事务路由到它。</strong></p><p id="9f97" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">或者您实际上可以离开它，因为从我们的实现来看，当新供应商失败时，它会转到旧供应商来执行事务。因此，在你解决与新供应商相关的问题时，你可以不去管它。(不过，我不建议这样做🙃因为您将不必要地耗尽计算机资源)。</p><h1 id="e6c9" class="ma mb iq bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">赞成者:</h1><ul class=""><li id="a22b" class="ni nj iq ka b kb my kf mz kj nk kn nl kr nm kv nn no np nq bi translated">部署到生产环境后，无论何时出现问题，您都不必回滚，即更高的稳定性和更少的停机时间。</li><li id="9f5b" class="ni nj iq ka b kb nr kf ns kj nt kn nu kr nv kv nn no np nq bi translated">您节省了时间，并获得了某种“心灵的平静”，因为您知道即使当一个新的服务提供者失败时，您的代码也总能动态地将更多的事务路由到旧的服务提供者。</li><li id="4655" class="ni nj iq ka b kb nr kf ns kj nt kn nu kr nv kv nn no np nq bi translated">你现在是一个10倍的工程师，不会破坏生产😅</li></ul><h1 id="6e71" class="ma mb iq bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated"><strong class="ak">缺点:</strong></h1><ul class=""><li id="d899" class="ni nj iq ka b kb my kf mz kj nk kn nl kr nm kv nn no np nq bi translated">你要写更多的代码，这会花更多的时间。(注:在确定新供应商的稳定性后，您可以随时重组并删除旧供应商的代码🤞</li></ul><h1 id="6c64" class="ma mb iq bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated"><strong class="ak">总结</strong></h1><blockquote class="lu lv lw"><p id="3c79" class="jy jz ln ka b kb kc kd ke kf kg kh ki lx kk kl km ly ko kp kq lz ks kt ku kv ij bi translated">-“如果任何事情都可能出错，它肯定会出错”。</p><p id="a28c" class="jy jz ln ka b kb kc kd ke kf kg kh ki lx kk kl km ly ko kp kq lz ks kt ku kv ij bi translated">-你要为出错做好准备。</p><p id="35ad" class="jy jz ln ka b kb kc kd ke kf kg kh ki lx kk kl km ly ko kp kq lz ks kt ku kv ij bi translated">-构建代码以将部分流量路由到新更新是一种准备方式。</p><p id="2dea" class="jy jz ln ka b kb kc kd ke kf kg kh ki lx kk kl km ly ko kp kq lz ks kt ku kv ij bi translated">-这种实现不是一成不变的，它会随着您的架构而变化。有创造力</p></blockquote><p id="f6b6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我很想听听你们在应用程序中增加容错的其他方法。</p><p id="6b78" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">感谢阅读</p><p id="3efc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">标题图片来源:<a class="ae lf" href="https://cybersecurityglossary.com/fault-tolerance/" rel="noopener ugc nofollow" target="_blank">此处</a></p></div></div>    
</body>
</html>