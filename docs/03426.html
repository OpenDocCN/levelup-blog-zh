<html>
<head>
<title>Spring Cloud: Zuul API Gateway</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Spring Cloud: Zuul API网关</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/spring-cloud-zuul-api-gateway-dffa5933d570?source=collection_archive---------0-----------------------#2020-05-08">https://levelup.gitconnected.com/spring-cloud-zuul-api-gateway-dffa5933d570?source=collection_archive---------0-----------------------#2020-05-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/61e3b8b7efab422623713a59a368c37b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k9F7tcE3FdqaHvEFKyfc1w.jpeg"/></div></div></figure><h1 id="b113" class="kb kc it bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">为什么要使用API网关</h1><p id="d36a" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">微服务架构的本质是将整体分解成细粒度的服务。这些“微”服务中的每一个都可以独立部署和扩展。虽然这种模式有许多优点，但它也带来了许多挑战。这些挑战中最重要的一个是复杂性的增加，这反过来又导致了可维护性的缺乏。</p><p id="56cf" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">设想一个场景，您必须为一个复杂的CRM(客户关系管理)应用程序实现一个UI。为了填充这个UI的不同部分并执行不同的用户操作，您可能需要调用几十个微服务。此外，UI必须知道所有这些微服务的网络位置(主机和端口)。此外，如果微服务的网络位置发生变化(这在云中经常发生)，UI也必须更新。显而易见，这是一个非常糟糕的设计。</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mc"><img src="../Images/985591d54a0b85b50c8741fbe06442e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TlglqHyduO_ijMV30abuyA.png"/></div></div></figure><p id="38d0" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">此外，一个典型的web应用应该支持监控、认证、安全、CORS等。如果UI直接调用微服务，那么前面提到的横切关注点应该在每个微服务中单独实现。CORS策略或身份验证机制的简单更改会强制所有微服务进行更改，这不仅效率低下，而且容易出错。</p><p id="da66" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">为了有一个更强大的方法，我们必须为微服务的所有传入流量实施单点入口或网关。UI将始终向网关发送请求，然后网关将请求转发给相关的微服务。本质上，gateway充当UI和微服务之间的中间件。下图说明了这个概念。</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mh"><img src="../Images/12464ab2d3811ed64274a4fc8dde6ff0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*69xH8ffk9hFX5kWTDnWoJQ.png"/></div></div></figure><p id="7478" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">这种方法的两个主要优点如下。</p><ul class=""><li id="e4b9" class="mi mj it lb b lc lx lg ly lk mk lo ml ls mm lw mn mo mp mq bi translated">UI不需要知道单个微服务的网络位置。相反，UI只需要知道网关的网络位置。网关会将传入的请求路由到相关的后端服务。</li><li id="3e63" class="mi mj it lb b lc mr lg ms lk mt lo mu ls mv lw mn mo mp mq bi translated">认证、安全、监控、CORS等交叉问题将由网关处理。每当需要对这些方面进行更改时，可以在一个地方(网关)进行更改，以影响所有微服务。</li></ul></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><h1 id="32a1" class="kb kc it bd kd ke nd kg kh ki ne kk kl km nf ko kp kq ng ks kt ku nh kw kx ky bi translated">Zuul概念概述</h1><p id="c242" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">Zuul <strong class="lb iu"> </strong>是网飞开发的API网关或边缘服务器。它能够执行以下任务。</p><ul class=""><li id="a962" class="mi mj it lb b lc lx lg ly lk mk lo ml ls mm lw mn mo mp mq bi translated">身份验证和安全性—确定每个资源的身份验证要求，并拒绝不满足这些要求的请求。</li><li id="fa30" class="mi mj it lb b lc mr lg ms lk mt lo mu ls mv lw mn mo mp mq bi translated">洞察和监控——在边缘跟踪有意义的数据和统计数据，以便为我们提供准确的生产视图。</li><li id="b6e3" class="mi mj it lb b lc mr lg ms lk mt lo mu ls mv lw mn mo mp mq bi translated">动态路由—根据需要将请求动态路由到不同的后端集群。</li><li id="ab66" class="mi mj it lb b lc mr lg ms lk mt lo mu ls mv lw mn mo mp mq bi translated">压力测试—逐渐增加集群的流量，以评估性能。</li><li id="b8aa" class="mi mj it lb b lc mr lg ms lk mt lo mu ls mv lw mn mo mp mq bi translated">减载—为每种类型的请求分配容量，并丢弃超出限制的请求。</li><li id="2b77" class="mi mj it lb b lc mr lg ms lk mt lo mu ls mv lw mn mo mp mq bi translated">静态响应处理—直接在边缘构建一些响应，而不是将它们转发到内部集群。</li></ul><h2 id="c62d" class="ni kc it bd kd nj nk dn kh nl nm dp kl lk nn no kp lo np nq kt ls nr ns kx nt bi translated">过滤</h2><p id="49bd" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">过滤器是一种扩展Zuul默认功能和添加自定义特性的方式。在请求路由过程中，根据过滤器执行的阶段，可以将过滤器分为四种类型。</p><ul class=""><li id="f899" class="mi mj it lb b lc lx lg ly lk mk lo ml ls mm lw mn mo mp mq bi translated"><code class="fe nu nv nw nx b">pre</code> —过滤器在请求被路由之前运行。</li><li id="d7c0" class="mi mj it lb b lc mr lg ms lk mt lo mu ls mv lw mn mo mp mq bi translated"><code class="fe nu nv nw nx b">route</code> —过滤器可以处理请求的实际路由。</li><li id="fc9a" class="mi mj it lb b lc mr lg ms lk mt lo mu ls mv lw mn mo mp mq bi translated"><code class="fe nu nv nw nx b">post</code> —过滤器在请求被路由后运行。</li><li id="6163" class="mi mj it lb b lc mr lg ms lk mt lo mu ls mv lw mn mo mp mq bi translated"><code class="fe nu nv nw nx b">error</code> —如果在处理请求的过程中出现错误，则运行过滤器。</li></ul><h2 id="8e3f" class="ni kc it bd kd nj nk dn kh nl nm dp kl lk nn no kp lo np nq kt ls nr ns kx nt bi translated">与Eureka的集成</h2><p id="3a39" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">在现实世界的微服务生态系统中，Zuul与Eureka等服务发现工具携手合作。Zuul一般不会维护后端微服务的硬编码网络位置(主机名和端口号)。相反，它与服务注册表进行交互，并动态获取目标网络位置。下图展示了这一工作流程。</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mh"><img src="../Images/0247dd9694143438264f4037b6210edf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lRaKTEFZnjHNzwLV3uuOUg.png"/></div></div></figure></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><h1 id="faf4" class="kb kc it bd kd ke nd kg kh ki ne kk kl km nf ko kp kq ng ks kt ku nh kw kx ky bi translated">用Spring Cloud实现Zuul网关</h1><p id="f2d3" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">如上所述，Zuul最初是由网飞开发的。然而，Spring已经开发了一个围绕网飞·祖尔的包装器，所以它可以很容易地集成到基于Spring的应用程序中。这个包装器是Spring Cloud框架的一部分。在下面的例子中，我们将使用Spring Cloud版本的Zuul。</p><h2 id="6da0" class="ni kc it bd kd nj nk dn kh nl nm dp kl lk nn no kp lo np nq kt ls nr ns kx nt bi translated">项目概述</h2><p id="bf46" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">在这个例子中，我们将构建三个工件来演示Zuul的请求路由过程。你可以在<a class="ae ny" href="https://github.com/sarindufit/spring-cloud-zuul" rel="noopener ugc nofollow" target="_blank"> GitHub </a>中找到这个例子的完整源代码。</p><ul class=""><li id="d8d4" class="mi mj it lb b lc lx lg ly lk mk lo ml ls mm lw mn mo mp mq bi translated">课程微服务</li><li id="74c0" class="mi mj it lb b lc mr lg ms lk mt lo mu ls mv lw mn mo mp mq bi translated">Zuul API网关</li><li id="b499" class="mi mj it lb b lc mr lg ms lk mt lo mu ls mv lw mn mo mp mq bi translated">尤里卡服务注册中心</li></ul><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nz"><img src="../Images/3aa2b1fff3cbe63dd8bd73c8a13cace9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kI_OwNFXyNCYS4AIL5P7AQ.png"/></div></div></figure><h2 id="dd64" class="ni kc it bd kd nj nk dn kh nl nm dp kl lk nn no kp lo np nq kt ls nr ns kx nt bi translated">构建课程微服务</h2><p id="520c" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">该课程是一个简单的微服务，用Spring Boot编写，公开一个端点来检索课程列表。此外，课程微服务将被配置为发现客户端，以便可以通过Eureka发现其网络位置。</p><p id="6e59" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated"><strong class="lb iu">通过spring Initializr </strong>生成项目</p><p id="db46" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">您可以使用<a class="ae ny" href="https://start.spring.io/" rel="noopener ugc nofollow" target="_blank"> Spring Initializr </a>来生成初始的项目结构。</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oa"><img src="../Images/f7dd9c176ec4af2ec3abb2a18f5cdb83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O-Le1kQOWFyl4uVnNHkXbA.png"/></div></div></figure><p id="2b3c" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated"><strong class="lb iu"> Maven配置(pom.xml) </strong></p><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="30ca" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated"><strong class="lb iu">添加模型类(Course.java)</strong></p><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="3367" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated"><strong class="lb iu">添加休息控制器(CourseController.java)</strong></p><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="368c" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">特别说明:</p><ul class=""><li id="2e07" class="mi mj it lb b lc lx lg ly lk mk lo ml ls mm lw mn mo mp mq bi translated">如您所见，已经公开了一个端点(/courses)来检索课程列表。</li></ul><p id="4593" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated"><strong class="lb iu">添加主类(CourseApplication.java)</strong></p><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="623d" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">特别说明:</p><ul class=""><li id="22bc" class="mi mj it lb b lc lx lg ly lk mk lo ml ls mm lw mn mo mp mq bi translated">@EnableEurekaClient批注已用于使此服务成为Eureka客户端。</li></ul><p id="796f" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated"><strong class="lb iu">配置应用程序属性(application.properties) </strong></p><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="ob oc l"/></div></figure><h2 id="5216" class="ni kc it bd kd nj nk dn kh nl nm dp kl lk nn no kp lo np nq kt ls nr ns kx nt bi translated">实现Eureka服务器</h2><p id="d071" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">下一步，我们必须实现一个Eureka服务器。如果您不熟悉服务发现和Eureka的概念，您可以阅读<a class="ae ny" href="https://medium.com/swlh/spring-cloud-service-discovery-with-eureka-16f32068e5c7" rel="noopener">这篇文章</a>以获得基本的理解。</p><p id="f9b8" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated"><strong class="lb iu">通过spring Initializr生成项目</strong></p><p id="2eb9" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">您可以使用<a class="ae ny" href="https://start.spring.io/" rel="noopener ugc nofollow" target="_blank"> Spring Initializr </a>来生成初始项目结构。</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oa"><img src="../Images/1727d5f3c0a14a8a5e7c83b4c964af04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3otWtOeIS8dAKZIeVQm9Ow.png"/></div></div></figure><p id="7d6f" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated"><strong class="lb iu"> Maven配置(pom.xml) </strong></p><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="43e5" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated"><strong class="lb iu">添加主类(EurekaApplication.java)</strong></p><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="6d35" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">特别说明:</p><ul class=""><li id="e6c8" class="mi mj it lb b lc lx lg ly lk mk lo ml ls mm lw mn mo mp mq bi translated">@EnableEurekaServer注释神奇地将这个简单的应用程序转换成了Eureka服务器。</li></ul><p id="8d60" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated"><strong class="lb iu">配置应用程序属性(application.properties) </strong></p><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="d9d4" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">特别说明:</p><ul class=""><li id="a2e6" class="mi mj it lb b lc lx lg ly lk mk lo ml ls mm lw mn mo mp mq bi translated">默认情况下，Spring Boot应用程序在端口<code class="fe nu nv nw nx b">8080</code>上运行。我已经将其覆盖到<code class="fe nu nv nw nx b">8761</code>，这样Eureka服务器就不会与课程微服务端口冲突(课程微服务将在8080上运行)。</li><li id="e2d0" class="mi mj it lb b lc mr lg ms lk mt lo mu ls mv lw mn mo mp mq bi translated">当Eureka启动时，它会尝试将自己注册为客户端。为了方便起见，我使用了<code class="fe nu nv nw nx b">eureka.client.register-with-eureka = false</code>配置来防止Eureka服务器在启动时在服务器中注册自己。</li><li id="b34d" class="mi mj it lb b lc mr lg ms lk mt lo mu ls mv lw mn mo mp mq bi translated">在真实的场景中，我们可能有多个Eureka服务器节点一起充当对等注册中心。当Eureka服务器启动时，默认情况下它会搜索其他对等注册中心。为了防止在我们的本地设置中出现这种情况，我使用了<code class="fe nu nv nw nx b">eureka.client.fetch-registry = false</code>配置。</li><li id="f5a0" class="mi mj it lb b lc mr lg ms lk mt lo mu ls mv lw mn mo mp mq bi translated">我已经使用了<code class="fe nu nv nw nx b">logging.level.com.netflix.eureka = OFF</code>和<code class="fe nu nv nw nx b">logging.level.com.netflix.discovery = OFF</code>属性来关闭详细日志记录。</li></ul><h2 id="80b3" class="ni kc it bd kd nj nk dn kh nl nm dp kl lk nn no kp lo np nq kt ls nr ns kx nt bi translated">设置Zuul代理</h2><p id="b098" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">最后一步，我们必须实现Zuul代理服务器，将请求路由到课程微服务。</p><p id="2269" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated"><strong class="lb iu">通过spring Initializr生成项目</strong></p><p id="8fea" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">您可以使用<a class="ae ny" href="https://start.spring.io/" rel="noopener ugc nofollow" target="_blank"> Spring Initializr </a>来生成初始项目结构。</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oa"><img src="../Images/e0fb701012ae5251db83573a2265f762.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GeYXsoiWQEmVL-sn09_sfQ.png"/></div></div></figure><p id="1c89" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated"><strong class="lb iu">添加主类(ZuulApplication.java)</strong></p><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="3dde" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">特别说明:</p><ul class=""><li id="dd41" class="mi mj it lb b lc lx lg ly lk mk lo ml ls mm lw mn mo mp mq bi translated">@EnableZuulProxy添加了作为代理运行和将请求路由到后端API的功能。</li><li id="1dec" class="mi mj it lb b lc mr lg ms lk mt lo mu ls mv lw mn mo mp mq bi translated">@EnableEurekaClient使这个应用程序成为一个Eureka客户机，这样它就可以与服务注册中心交互并获得请求路由所需的信息(后端API的网络位置)。</li></ul><p id="a033" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated"><strong class="lb iu">配置应用程序属性(application.properties) </strong></p><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="6b68" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">特别说明:</p><ul class=""><li id="7db6" class="mi mj it lb b lc lx lg ly lk mk lo ml ls mm lw mn mo mp mq bi translated">以下属性将使Zuul代理在端口号<code class="fe nu nv nw nx b">8762</code>上运行。</li></ul><pre class="md me mf mg gt od nx oe of aw og bi"><span id="1307" class="ni kc it nx b gy oh oi l oj ok">server.port = 8762</span></pre><ul class=""><li id="d512" class="mi mj it lb b lc lx lg ly lk mk lo ml ls mm lw mn mo mp mq bi translated">Eureka服务器URL应该配置如下。</li></ul><pre class="md me mf mg gt od nx oe of aw og bi"><span id="a29b" class="ni kc it nx b gy oh oi l oj ok">eureka.client.serviceUrl.defaultZone = http://localhost:8761/eureka</span></pre><ul class=""><li id="0705" class="mi mj it lb b lc lx lg ly lk mk lo ml ls mm lw mn mo mp mq bi translated">为了检索/获取注册的服务细节，<strong class="lb iu"> Zuul代理</strong>不需要向Eureka服务器注册。应该使用以下属性来阻止Zuul在Eureka服务器上注册。</li></ul><pre class="md me mf mg gt od nx oe of aw og bi"><span id="d16b" class="ni kc it nx b gy oh oi l oj ok">eureka.client.registerWithEureka=false</span></pre><ul class=""><li id="7325" class="mi mj it lb b lc lx lg ly lk mk lo ml ls mm lw mn mo mp mq bi translated">尽管Zuul不需要在Eureka中注册，但它仍然需要获取注册表项来将请求路由到后端API。以下属性使Zuul能够与Eureka服务器交互并获取注册表项。</li></ul><pre class="md me mf mg gt od nx oe of aw og bi"><span id="ddb8" class="ni kc it nx b gy oh oi l oj ok">eureka.client.fetchRegistry=true</span></pre><ul class=""><li id="d075" class="mi mj it lb b lc lx lg ly lk mk lo ml ls mm lw mn mo mp mq bi translated">以下是使Zuul能够执行请求路由的两个最重要的属性。</li></ul><pre class="md me mf mg gt od nx oe of aw og bi"><span id="3656" class="ni kc it nx b gy oh oi l oj ok">zuul.routes.courseservice.path=/course-service/**</span><span id="e672" class="ni kc it nx b gy ol oi l oj ok">zuul.routes.courseservice.serviceId=course-service</span></pre><p id="1fbb" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">如果一个请求到达<strong class="lb iu"> </strong> <code class="fe nu nv nw nx b">/course-service/*</code> URL路径，该请求将被定向到用service-id <code class="fe nu nv nw nx b">course-service</code>注册的服务。在重定向时，Zuul将默认去除URL的<code class="fe nu nv nw nx b">/course-service/</code>部分。例如，如果请求发送到<code class="fe nu nv nw nx b">/course-service/courses</code> URL，Zuul会将该请求重定向到URL为<code class="fe nu nv nw nx b">/courses</code>的课程微服务。</p><h2 id="b707" class="ni kc it bd kd nj nk dn kh nl nm dp kl lk nn no kp lo np nq kt ls nr ns kx nt bi translated">测试应用程序</h2><p id="b53a" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">为了测试Zuul代理，您必须首先启动我们在上面小节中实现的以下服务。</p><ul class=""><li id="ff09" class="mi mj it lb b lc lx lg ly lk mk lo ml ls mm lw mn mo mp mq bi translated">课程微服务</li><li id="d726" class="mi mj it lb b lc mr lg ms lk mt lo mu ls mv lw mn mo mp mq bi translated">尤里卡服务器</li><li id="3bb3" class="mi mj it lb b lc mr lg ms lk mt lo mu ls mv lw mn mo mp mq bi translated">Zuul代理</li></ul><p id="2ea3" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">随后，可以使用Postman等REST客户端调用Zuul中配置的<code class="fe nu nv nw nx b">/course-service/</code>端点，检查课程列表是否返回成功。</p><figure class="md me mf mg gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi om"><img src="../Images/e61546dc203edff15353d8d8d8559c39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MskQfR_Mo9Fy1RgoMeMKcw.png"/></div></div></figure></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><h1 id="a5ac" class="kb kc it bd kd ke nd kg kh ki ne kk kl km nf ko kp kq ng ks kt ku nh kw kx ky bi translated">使用过滤器扩展Zuul的功能</h1><p id="2bf0" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">如前一节所述，过滤器是扩展Zuul默认功能和添加自定义特性的一种方式。有四种类型的过滤器，即<code class="fe nu nv nw nx b">pre</code>、<code class="fe nu nv nw nx b">post</code>、<code class="fe nu nv nw nx b">route</code>和<code class="fe nu nv nw nx b">error</code>。以下是每种过滤器类型的示例实现。</p><ul class=""><li id="f38d" class="mi mj it lb b lc lx lg ly lk mk lo ml ls mm lw mn mo mp mq bi translated">预过滤器</li></ul><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="ob oc l"/></div></figure><ul class=""><li id="b2a0" class="mi mj it lb b lc lx lg ly lk mk lo ml ls mm lw mn mo mp mq bi translated">后置过滤器</li></ul><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="ob oc l"/></div></figure><ul class=""><li id="2c11" class="mi mj it lb b lc lx lg ly lk mk lo ml ls mm lw mn mo mp mq bi translated">路由过滤器</li></ul><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="ob oc l"/></div></figure><ul class=""><li id="03af" class="mi mj it lb b lc lx lg ly lk mk lo ml ls mm lw mn mo mp mq bi translated">误差过滤器</li></ul><figure class="md me mf mg gt ju"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="3e57" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">过滤器类实现了四种方法:</p><ul class=""><li id="7727" class="mi mj it lb b lc lx lg ly lk mk lo ml ls mm lw mn mo mp mq bi translated"><code class="fe nu nv nw nx b">filterType()</code>:返回一个代表过滤器类型的<code class="fe nu nv nw nx b">String</code>，在本例中为<code class="fe nu nv nw nx b">pre</code>。(对于路由过滤器，应该是<code class="fe nu nv nw nx b">route</code>。)</li><li id="7be4" class="mi mj it lb b lc mr lg ms lk mt lo mu ls mv lw mn mo mp mq bi translated"><code class="fe nu nv nw nx b">filterOrder()</code>:给出该过滤器相对于其他过滤器的运行顺序。</li><li id="3ea6" class="mi mj it lb b lc mr lg ms lk mt lo mu ls mv lw mn mo mp mq bi translated"><code class="fe nu nv nw nx b">shouldFilter()</code>:包含决定何时运行该过滤器的逻辑(该特定过滤器始终运行)。</li><li id="f900" class="mi mj it lb b lc mr lg ms lk mt lo mu ls mv lw mn mo mp mq bi translated"><code class="fe nu nv nw nx b">run()</code>:包含过滤器的功能。</li></ul></div><div class="ab cl mw mx hx my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="im in io ip iq"><h1 id="5b18" class="kb kc it bd kd ke nd kg kh ki ne kk kl km nf ko kp kq ng ks kt ku nh kw kx ky bi translated">结论</h1><p id="2778" class="pw-post-body-paragraph kz la it lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw im bi translated">这篇文章旨在向您介绍通过网飞的Zuul请求路由。我们使用Spring Cloud对Zuul的包装，并构建了一个示例应用程序来观察请求路由过程。我希望这篇文章对你有用。</p><p id="3ac1" class="pw-post-body-paragraph kz la it lb b lc lx le lf lg ly li lj lk lz lm ln lo ma lq lr ls mb lu lv lw im bi translated">感谢阅读！</p></div></div>    
</body>
</html>