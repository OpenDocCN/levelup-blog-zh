<html>
<head>
<title>Understand the Pros and Cons of Tuples in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解Swift中元组的优缺点</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/swift-tuples-333970b03288?source=collection_archive---------10-----------------------#2020-01-21">https://levelup.gitconnected.com/swift-tuples-333970b03288?source=collection_archive---------10-----------------------#2020-01-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/5299b9a54f1282f306397680b6a62b20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lE6qQO4K-Or2ogz6svXEFA.jpeg"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">布雷特·乔丹在<a class="ae jg" href="https://unsplash.com/s/photos/iphone-box?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><div class=""/><div class=""><h2 id="e82c" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">Tuple在某种程度上是一些高级Swift开发人员忽略的数据类型。对于初学者，您可能希望了解它的优缺点，以便可以在应用程序中使用它。</h2></div><p id="0ef7" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Swift旨在取代Objective-C，用于苹果生态系统中的软件开发。作为一种更现代的语言，它有几个Objective-C中没有的特性，其中一个就是元组。本文是对Swift初学者的元组介绍，希望也能成为一些资深Swift开发者的复习资料。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="67a3" class="mb mc jj bd md me mf mg mh mi mj mk ml kp mm kq mn ks mo kt mp kv mq kw mr ms bi translated">什么是元组？</h1><h2 id="9e96" class="mt mc jj bd md mu mv dn mh mw mx dp ml lh my mz mn ll na nb mp lp nc nd mr ne bi translated">定义</h2><p id="28e2" class="pw-post-body-paragraph ky kz jj la b lb nf kk ld le ng kn lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">元组表示为单个复合值，是一组由逗号分隔的多个值。对于元组中使用的值的数量和值的类型没有限制，这为我们提供了使用各种数据类型(例如，整数和字符串)及其排列(例如，整数数组)创建任何长度的元组的<strong class="la jk">灵活性</strong>。这里有几个展示这种灵活性的例子。</p><figure class="nk nl nm nn gt iv"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="4d30" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">由于Swift支持类型推断，所以在后面使用这些元组的时候，你可以找出这些元组的具体类型，就像上面评论中提到的那样。有趣的是，一个元组可以包含在另一个元组中。</p><h2 id="2b72" class="mt mc jj bd md mu mv dn mh mw mx dp ml lh my mz mn ll na nb mp lp nc nd mr ne bi translated">访问元素</h2><p id="c1ff" class="pw-post-body-paragraph ky kz jj la b lb nf kk ld le ng kn lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">我们经常需要访问元组中的元素来执行一些额外的工作。为此，有三种常见的方法。</p><p id="f128" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">使用索引号。正如你所料，索引号从零开始。参考下面的例子来了解它的用法。</strong></p><figure class="nk nl nm nn gt iv"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="bc16" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">需要注意的一点是，您必须为感兴趣的元素使用正确的索引。如果您数错了，您将得到它的邻居，而不是想要的元素。</p><p id="c7e9" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">分解数值。</strong>这可以通过将元组中的元素分配给单独的变量来实现，如下例所示，这样就可以使用变量直接访问它们。</p><figure class="nk nl nm nn gt iv"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="e555" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果不需要使用元组中的所有元素，可以对不需要访问的元素使用下划线。左侧变量的总数应该与元组中元素的数量相匹配。否则，编译器会抱怨。然而，有一种特殊的情况，如果你在左边的括号中只使用一个变量，那么这个变量将被赋值为一个相同元素的元组，就像右边的一样。</p><p id="39b7" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">命名元素。这是通过在创建元组时给每个元素命名来实现的。当您访问元素时，您可以只使用点，后跟给定的名称，就像访问一个<code class="fe nq nr ns nt b">struct</code>或<code class="fe nq nr ns nt b">class</code>实例的属性一样。因为所有元素都是显式命名的，所以这种方法最不容易出现访问错误元素的错误。下面给出了一个使用示例。</strong></p><figure class="nk nl nm nn gt iv"><div class="bz fp l di"><div class="no np l"/></div></figure></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="4346" class="mb mc jj bd md me mf mg mh mi mj mk ml kp mm kq mn ks mo kt mp kv mq kw mr ms bi translated">使用元组的好处</h1><h2 id="815b" class="mt mc jj bd md mu mv dn mh mw mx dp ml lh my mz mn ll na nb mp lp nc nd mr ne bi translated">简单申报</h2><p id="6acf" class="pw-post-body-paragraph ky kz jj la b lb nf kk ld le ng kn lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">元组可以很容易地声明。不像<code class="fe nq nr ns nt b">struct</code>和<code class="fe nq nr ns nt b">class</code>，你不需要在声明一个元组之前写任何特别的东西。每当你需要使用它的时候，就在那里声明它。不需要额外的管理费用。</p><p id="c532" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">此外，有几种方便的方法来访问元组中的单个元素，这使得使用起来非常愉快。</p><h2 id="b8a3" class="mt mc jj bd md mu mv dn mh mw mx dp ml lh my mz mn ll na nb mp lp nc nd mr ne bi translated">元素的灵活性</h2><p id="4a2b" class="pw-post-body-paragraph ky kz jj la b lb nf kk ld le ng kn lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">元组的灵活性在其定义中讨论。对于给定的元组，可以定义任意多的元素。此外，它在元素的数据类型方面也非常灵活，比如整数、字符串、整数数组，甚至元组本身。</p><p id="9b34" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">由于元组是其元素的复合值，其灵活性使其成为理想的值容器，特别适合于本地使用(例如，在函数中)。</p><h2 id="c7d6" class="mt mc jj bd md mu mv dn mh mw mx dp ml lh my mz mn ll na nb mp lp nc nd mr ne bi translated">易变性</h2><p id="07af" class="pw-post-body-paragraph ky kz jj la b lb nf kk ld le ng kn lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">元组是值类型数据。因此，当它们被声明为变量(即，当值可以改变时)而不是常量(即，当值不能改变时)时，我们可以改变元组中的一些或所有元素，只要类型保持不变。下面的代码片段提供了一个简单的例子。</p><figure class="nk nl nm nn gt iv"><div class="bz fp l di"><div class="no np l"/></div></figure><h2 id="0c2a" class="mt mc jj bd md mu mv dn mh mw mx dp ml lh my mz mn ll na nb mp lp nc nd mr ne bi translated">广泛的适用性</h2><p id="c8ec" class="pw-post-body-paragraph ky kz jj la b lb nf kk ld le ng kn lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">由于其简单的声明及其元素的灵活性，Swift支持其在各种场景中的广泛使用。</p><p id="9c4d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如下面第一个函数所示，它可以用作函数中的参数。在第二个函数中，返回值是可选的元组。</p><figure class="nk nl nm nn gt iv"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="f4b7" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">除了用作函数参数和返回值之外，它还被用于标准库中。在下面的代码片段中有两个例子。</p><figure class="nk nl nm nn gt iv"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="9131" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在第一个例子中，当您迭代字典中的元素时，迭代器的默认项是一个命名的<code class="fe nq nr ns nt b">(key: String, value: Any)</code>元组，这样您可以使用它们各自的变量名(即键和值)方便地访问这两个元素。元素的类型是从<code class="fe nq nr ns nt b">Dictionary</code>的数据类型推断出来的。</p><p id="ecb8" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在第二个例子中，当您向集合中插入一个元素时，<code class="fe nq nr ns nt b">insert()</code>方法的返回值是一个已命名的<code class="fe nq nr ns nt b">(inserted: Bool, memberAfterInsert: Int)</code>元组。与前面的示例类似，类型是从集合的类型中推断出来的。</p><p id="0d6d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">与这些例子相关的一个小注意是，<code class="fe nq nr ns nt b">Dictionary</code>和<code class="fe nq nr ns nt b">Set</code>都是通用数据类型(参见我的<a class="ae jg" href="https://medium.com/swlh/implementing-generic-coding-in-your-swift-projects-776b25e4d52f" rel="noopener">上一篇文章</a>中关于通用编码的更多内容)，它们的具体实例需要特定于它们的元素类型，由此可以相应地推断出相关元组的类型。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="66a3" class="mb mc jj bd md me mf mg mh mi mj mk ml kp mm kq mn ks mo kt mp kv mq kw mr ms bi translated">使用元组的缺点</h1><h2 id="255a" class="mt mc jj bd md mu mv dn mh mw mx dp ml lh my mz mn ll na nb mp lp nc nd mr ne bi translated">有限的“可扩展性”</h2><p id="5c78" class="pw-post-body-paragraph ky kz jj la b lb nf kk ld le ng kn lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">元组本身并不是真正的标准数据类型。它们对于简单的相关值组非常有用。然而，根据设计，当涉及复杂的数据结构和函数时，它们不能被使用。</p><p id="6de7" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">相反，您应该认为元组是一个没有任何实现细节的<code class="fe nq nr ns nt b">struct</code>。它只是提供了一种方便的方法来将相关的值组合成一个变量，并在适用时单独访问它的元素。它实际上不允许您向元组添加函数，因此它的“可伸缩性”是有限的。</p><h2 id="4278" class="mt mc jj bd md mu mv dn mh mw mx dp ml lh my mz mn ll na nb mp lp nc nd mr ne bi translated">不符合可散列协议</h2><p id="8101" class="pw-post-body-paragraph ky kz jj la b lb nf kk ld le ng kn lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">元组的另一个主要缺点是它不符合<a class="ae jg" href="https://developer.apple.com/documentation/swift/hashable" rel="noopener ugc nofollow" target="_blank">散列</a>协议(在这里了解更多<a class="ae jg" href="https://medium.com/better-programming/what-is-hashable-in-swift-6a51627f904" rel="noopener"/>)。这意味着元组不能是字典中的键或集合中的元素，因为<code class="fe nq nr ns nt b">Dictionary</code>的键和<code class="fe nq nr ns nt b">Set</code>中的元素应该符合Hashable协议。下面的代码片段向您展示了相关信息。</p><figure class="nk nl nm nn gt iv"><div class="bz fp l di"><div class="no np l"/></div></figure></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="0c5b" class="mb mc jj bd md me mf mg mh mi mj mk ml kp mm kq mn ks mo kt mp kv mq kw mr ms bi translated">结论</h1><p id="3314" class="pw-post-body-paragraph ky kz jj la b lb nf kk ld le ng kn lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">元组作为包含一组相关值的紧凑变量非常有用。它可以提供比函数返回的单个值更多的信息。但是，在需要额外的数据结构和功能的情况下，它有一些局限性，限制了它们的使用。然而，它是一个方便的值容器，具有简单的构造、灵活性和可变性，因此在适用的地方鼓励使用它。</p></div></div>    
</body>
</html>