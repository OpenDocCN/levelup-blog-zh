<html>
<head>
<title>Faster than Pandas : Polars (part 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">比熊猫还快:极地(下)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/deep-dive-polars-part-2-alternatives-to-pandas-cc9efa881f72?source=collection_archive---------1-----------------------#2022-03-11">https://levelup.gitconnected.com/deep-dive-polars-part-2-alternatives-to-pandas-cc9efa881f72?source=collection_archive---------1-----------------------#2022-03-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/8a5168853dc236173038606c61cd0e65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hg1lcDccoCvW7u7b2d_hsQ.jpeg"/></div></div></figure><p id="db02" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在上一篇文章<a class="ae kz" href="https://medium.com/@thinkbot/deeper-dive-alternatives-to-our-beloved-pandas-polars-part-1-e34d31398006" rel="noopener">比熊猫还快:极地者(第一部分)</a>中我们注意到:</p><ul class=""><li id="8549" class="la lb it kd b ke kf ki kj km lc kq ld ku le ky lf lg lh li bi translated">Polars确实大大减少了将数据读入Polars数据帧的时间。</li><li id="9642" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated">Polars允许惰性操作，因此代码只有在被明确要求执行时才会被执行</li></ul><p id="5595" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在今天的实验中，我们将快速检查polars对象对内存消耗的影响。在文章的最后，我们将总结什么样的Polars数据帧方法消耗最少的内存，并且在功能上比默认方法更好或相当。</p><p id="b043" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所以，让我们开始陈述吧！</p></div><div class="ab cl lo lp hx lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="im in io ip iq"><p id="4f8c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们的设置和以前一样</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="454a" class="me mf it ma b gy mg mh l mi mj"><strong class="ma iu">!</strong> python <strong class="ma iu">--</strong>version<br/>Python 3.9.4</span></pre><h1 id="0a4c" class="mk mf it bd ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng bi translated">安装polars</h1><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="6718" class="me mf it ma b gy mg mh l mi mj"><strong class="ma iu">!</strong> pip install polars</span></pre><p id="250b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">导入库</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="f070" class="me mf it ma b gy mg mh l mi mj"><strong class="ma iu">import</strong> polars <strong class="ma iu">as</strong> pl</span></pre><h1 id="16f5" class="mk mf it bd ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng bi translated">获取数据</h1><p id="afe8" class="pw-post-body-paragraph kb kc it kd b ke nh kg kh ki ni kk kl km nj ko kp kq nk ks kt ku nl kw kx ky im bi translated">像往常一样，我们从使用熊猫读取2021年1月的纽约出租车数据开始。首先，我们从亚马逊S3链接下载数据到本地存储。</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="0cd3" class="me mf it ma b gy mg mh l mi mj"><strong class="ma iu">!</strong> wget "https://s3.amazonaws.com/nyc-tlc/trip+data/yellow_tripdata_2021-01.csv"</span><span id="69e9" class="me mf it ma b gy nm mh l mi mj"><strong class="ma iu">!</strong> wc <strong class="ma iu">-</strong>l yellow_tripdata_2021<strong class="ma iu">-</strong>01.csv</span><span id="1c11" class="me mf it ma b gy nm mh l mi mj">--2022-03-11 07:32:13--  <a class="ae kz" href="https://s3.amazonaws.com/nyc-tlc/trip+data/yellow_tripdata_2021-01.csv" rel="noopener ugc nofollow" target="_blank">https://s3.amazonaws.com/nyc-tlc/trip+data/yellow_tripdata_2021-01.csv</a><br/>Resolving s3.amazonaws.com (s3.amazonaws.com)... 3.5.0.130<br/>Connecting to s3.amazonaws.com (s3.amazonaws.com)|3.5.0.130|:443... connected.<br/>HTTP request sent, awaiting response... 200 OK<br/>Length: 125981363 (120M) [text/csv]<br/>Saving to: ‘yellow_tripdata_2021-01.csv.3’<br/><br/>yellow_tripdata_202 100%[===================&gt;] 120.14M  27.5MB/s    in 7.6s    <br/><br/>2022-03-11 07:32:21 (15.9 MB/s) - ‘yellow_tripdata_2021-01.csv.3’ saved [125981363/125981363]<br/><br/> 1369766 yellow_tripdata_2021-01.csv</span></pre><figure class="lv lw lx ly gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nn"><img src="../Images/dbbf95eec90d5587ff9e76ce4570053f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a2NrHs-eFkhiF0LTSgAGkQ.jpeg"/></div></div><figcaption class="no np gj gh gi nq nr bd b be z dk translated">鸣谢:锡德·巴拉钱德朗(unsplash)</figcaption></figure><h1 id="68e5" class="mk mf it bd ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng bi translated">让我们先按熊猫的方式做，然后得到基准</h1><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="dcfa" class="me mf it ma b gy mg mh l mi mj"><strong class="ma iu">import</strong> pandas <strong class="ma iu">as</strong> pd<br/><strong class="ma iu">import</strong> datetime</span></pre><p id="2997" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">%% time是jupyter notebook中的一个神奇动作，可以计算单元格内所有执行的时间。</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="235c" class="me mf it ma b gy mg mh l mi mj"><strong class="ma iu">%%</strong>time<br/>data <strong class="ma iu">=</strong> pd.read_csv("yellow_tripdata_2021-01.csv", low_memory<strong class="ma iu">=False</strong>)</span><span id="418b" class="me mf it ma b gy nm mh l mi mj">CPU times: user 1.63 s, sys: 195 ms, total: 1.83 s<br/>Wall time: 1.83 s</span></pre><p id="9267" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们编写一个函数来获取本地或全局环境中任何对象的大小(可读格式)</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="2ca0" class="me mf it ma b gy mg mh l mi mj"><strong class="ma iu">from</strong> sys <strong class="ma iu">import</strong> getsizeof<br/><strong class="ma iu">def</strong> whats_my_footprint(x):<br/>    <strong class="ma iu">if</strong> 'x' <strong class="ma iu">in</strong> locals() <strong class="ma iu">or</strong> 'x' <strong class="ma iu">in</strong> globals():<br/>        size <strong class="ma iu">=</strong> round(getsizeof(data) <strong class="ma iu">/</strong> 1024 <strong class="ma iu">/</strong> 1024,2)<br/>        print(f'{size} MB in the memory')<br/>    <strong class="ma iu">else</strong>:<br/>        print('are you sure the object exists?')</span></pre><p id="59e9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Pandas dataframe最终在内存中占用了将近430MB的数据，如下所示。</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="223d" class="me mf it ma b gy mg mh l mi mj">whats_my_footprint(data)<br/>428.64 MB in the memory</span></pre><p id="0143" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们来看看数据类型。</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="b1c6" class="me mf it ma b gy mg mh l mi mj">display(data.dtypes)</span><span id="b47d" class="me mf it ma b gy nm mh l mi mj">VendorID                 float64<br/>tpep_pickup_datetime      object<br/>tpep_dropoff_datetime     object<br/>passenger_count          float64<br/>trip_distance            float64<br/>RatecodeID               float64<br/>store_and_fwd_flag        object<br/>PULocationID               int64<br/>DOLocationID               int64<br/>payment_type             float64<br/>fare_amount              float64<br/>extra                    float64<br/>mta_tax                  float64<br/>tip_amount               float64<br/>tolls_amount             float64<br/>improvement_surcharge    float64<br/>total_amount             float64<br/>congestion_surcharge     float64<br/>dtype: object</span></pre><p id="56fa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到，数据中的日期不是被推断为日期，而是对象。对象是数据帧中最低效的内存。对象是“任何东西”,在这种情况下是字符串。我们需要将它们编码成底层的数字形式，以占用更少的空间，并允许将来更有效的计算。</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="9e52" class="me mf it ma b gy mg mh l mi mj"><strong class="ma iu">%%</strong>time<br/><em class="ns"># creating a date parser to reformat the dates in this data</em></span><span id="80ad" class="me mf it ma b gy nm mh l mi mj">mydateparser <strong class="ma iu">=</strong> <strong class="ma iu">lambda</strong> x: datetime.datetime.strptime(x, '%Y-%m-%d %H:%M:%S')</span><span id="c7a7" class="me mf it ma b gy nm mh l mi mj"># applying the date parser to the columns <br/>data <strong class="ma iu">=</strong> pd.read_csv("yellow_tripdata_2021-01.csv", parse_dates<strong class="ma iu">=</strong>['tpep_pickup_datetime','tpep_dropoff_datetime'], date_parser<strong class="ma iu">=</strong>mydateparser, low_memory<strong class="ma iu">=False</strong>)</span><span id="940d" class="me mf it ma b gy nm mh l mi mj">display(data.dtypes)</span><span id="7e36" class="me mf it ma b gy nm mh l mi mj">VendorID                        float64<br/>tpep_pickup_datetime     datetime64[ns]<br/>tpep_dropoff_datetime    datetime64[ns]<br/>passenger_count                 float64<br/>trip_distance                   float64<br/>RatecodeID                      float64<br/>store_and_fwd_flag               object<br/>PULocationID                      int64<br/>DOLocationID                      int64<br/>payment_type                    float64<br/>fare_amount                     float64<br/>extra                           float64<br/>mta_tax                         float64<br/>tip_amount                      float64<br/>tolls_amount                    float64<br/>improvement_surcharge           float64<br/>total_amount                    float64<br/>congestion_surcharge            float64<br/>dtype: object</span><span id="c6fd" class="me mf it ma b gy nm mh l mi mj">CPU times: user 15.7 s, sys: 287 ms, total: 16 s<br/>Wall time: 16 s</span><span id="7f35" class="me mf it ma b gy nm mh l mi mj">whats_my_footprint(data)<br/>250.99 MB in the memory</span></pre><p id="b7c6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">输入文件中的行数是1，369，766。从使用默认值读取csv到读取文件和解析日期的操作时间猛增了<strong class="kd iu"> 10x </strong>。文件大小从<strong class="kd iu">的430MB减少到了</strong>的251MB。通过分配正确的数据类型，内存占用减少了41%。</p></div><div class="ab cl lo lp hx lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="im in io ip iq"><p id="3dfa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们仍然将<strong class="kd iu">存储和转发标志</strong>作为对象。我们可以修复它并进一步优化它。让我们看看我们能做什么。</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="b8e5" class="me mf it ma b gy mg mh l mi mj"><strong class="ma iu">%%</strong>time<br/>display(data.store_and_fwd_flag.value_counts())</span><span id="4a98" class="me mf it ma b gy nm mh l mi mj">N    1252433<br/>Y      18980<br/>Name: store_and_fwd_flag, dtype: int64<br/></span><span id="1c9b" class="me mf it ma b gy nm mh l mi mj">#Change the data type of the store flag to categorical<br/>data.store_and_fwd_flag <strong class="ma iu">=</strong> data.store_and_fwd_flag.astype('category')</span><span id="ad26" class="me mf it ma b gy nm mh l mi mj">display(data.dtypes)<br/>display(whats_my_footprint(data))</span><span id="4995" class="me mf it ma b gy nm mh l mi mj">VendorID                        float64<br/>tpep_pickup_datetime     datetime64[ns]<br/>tpep_dropoff_datetime    datetime64[ns]<br/>passenger_count                 float64<br/>trip_distance                   float64<br/>RatecodeID                      float64<br/>store_and_fwd_flag             category<br/>PULocationID                      int64<br/>DOLocationID                      int64<br/>payment_type                    float64<br/>fare_amount                     float64<br/>extra                           float64<br/>mta_tax                         float64<br/>tip_amount                      float64<br/>tolls_amount                    float64<br/>improvement_surcharge           float64<br/>total_amount                    float64<br/>congestion_surcharge            float64<br/>dtype: object</span><span id="a700" class="me mf it ma b gy nm mh l mi mj">178.96 MB in the memory=</span><span id="c2c5" class="me mf it ma b gy nm mh l mi mj">CPU times: user 75.3 ms, sys: 3.92 ms, total: 79.3 ms<br/>Wall time: 78.4 ms</span></pre><p id="556b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此，我们又花了几秒钟来转换一个熊猫无法正确读取的明显的分类特征，将其转换为分类形式，并将内存占用从<strong class="kd iu"> 251 MB减少到179 MB </strong>。使我们的总占地面积<strong class="kd iu">比默认值</strong>减少58.3%！这是一个很大的内存浪费。</p></div><div class="ab cl lo lp hx lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="im in io ip iq"><p id="43b6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们看看Polars是怎么做的</p><figure class="lv lw lx ly gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nt"><img src="../Images/00bf40b5ac82c3edfd2feb43216dc5e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TSDULk_l0CZ2j5WWvWl3rA.jpeg"/></div></div><figcaption class="no np gj gh gi nq nr bd b be z dk translated">鸣谢:汉斯-于尔根·马格尔(unsplash)</figcaption></figure><h1 id="4606" class="mk mf it bd ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng bi translated">使用Polar读取数据</h1><p id="c4e7" class="pw-post-body-paragraph kb kc it kd b ke nh kg kh ki ni kk kl km nj ko kp kq nk ks kt ku nl kw kx ky im bi translated">有两种主要方法可以将数据读入Polar。</p><ol class=""><li id="efd9" class="la lb it kd b ke kf ki kj km lc kq ld ku le ky nu lg lh li bi translated">Polars.scan_</li><li id="4ce2" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky nu lg lh li bi translated">Polars.read_</li></ol><p id="38ba" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Polars可以处理csv、ipc、parquet、sql、json和avro，因此我们覆盖了99%的基础。因此，没有进一步的adue，让我们读入2021年1月纽约出租车数据的csv文件。</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="976f" class="me mf it ma b gy mg mh l mi mj">df <strong class="ma iu">=</strong> pl.read_csv("yellow_tripdata_2021-01.csv")</span><span id="e1a2" class="me mf it ma b gy nm mh l mi mj">display(df.head())</span><span id="75df" class="me mf it ma b gy nm mh l mi mj"><em class="ns"># selecting all columns<br/></em>data <strong class="ma iu">=</strong> df[[pl.col("*"),]]<br/>display(type(data))<br/>display(whats_my_footprint(data))</span><span id="4e53" class="me mf it ma b gy nm mh l mi mj">polars.internals.frame.DataFrame<br/>0.0 MB in the memory<br/></span><span id="cd39" class="me mf it ma b gy nm mh l mi mj"><em class="ns"># selecting all columns and converting it to arrow format<br/></em>data <strong class="ma iu">=</strong> df[[pl.col("*"),]].to_arrow()<br/>display(whats_my_footprint(data))<br/>display(type(data))</span><span id="4480" class="me mf it ma b gy nm mh l mi mj">239.78 MB in the memory<br/>pyarrow.lib.Table</span><span id="3662" class="me mf it ma b gy nm mh l mi mj">pyarrow.Table<br/>VendorID: int64<br/>tpep_pickup_datetime: <strong class="ma iu">large_string</strong><br/>tpep_dropoff_datetime: <strong class="ma iu">large_string</strong><br/>passenger_count: int64<br/>trip_distance: double<br/>RatecodeID: int64<br/>store_and_fwd_flag: <strong class="ma iu">large_string</strong><br/>PULocationID: int64<br/>DOLocationID: int64<br/>payment_type: int64<br/>fare_amount: double<br/>extra: double<br/>mta_tax: double<br/>tip_amount: double<br/>tolls_amount: double<br/>improvement_surcharge: double<br/>total_amount: double<br/>congestion_surcharge: double</span></pre><p id="ae64" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里需要注意的是Polars对象数据帧没有任何内存占用。这只是在原始框架上要完成的操作的映射。甚至使用“read_csv”(与产生lazyframe的“scan_csv”相比)；我们最终得到了一个大小为0 MB的polars . internals . frame . data frame。</p></div><div class="ab cl lo lp hx lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="im in io ip iq"><p id="5acb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们仍然有日期列，并且sotLets使用pyarrow.compute将store_and_forward_flag列转换为大字符串格式。让我们将它们转换成日期格式和分类格式</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="2051" class="me mf it ma b gy mg mh l mi mj"><strong class="ma iu">from</strong> pyarrow <strong class="ma iu">import</strong> compute <strong class="ma iu">as</strong> pc<br/><strong class="ma iu">from</strong> pyarrow <strong class="ma iu">import</strong> Table <strong class="ma iu">as</strong> pt</span><span id="2bbc" class="me mf it ma b gy nm mh l mi mj"><strong class="ma iu">def</strong> fix_datetime(x, column_name):<br/>    replacement <strong class="ma iu">=</strong> pc.strptime(x.column(column_name), format<strong class="ma iu">=</strong>'%Y-%m-%d %H:%M:%S', unit<strong class="ma iu">=</strong>'s')<br/>    position <strong class="ma iu">=</strong> x.column_names.index(column_name)<br/>    x <strong class="ma iu">=</strong> x.set_column(position, column_name, replacement)<br/>    <strong class="ma iu">return</strong> x</span><span id="0a67" class="me mf it ma b gy nm mh l mi mj">data <strong class="ma iu">=</strong> fix_datetime(data, 'tpep_pickup_datetime')<br/>data <strong class="ma iu">=</strong> fix_datetime(data, 'tpep_dropoff_datetime')</span><span id="c12c" class="me mf it ma b gy nm mh l mi mj">whats_my_footprint(data)<br/>184.03 MB in the memory</span><span id="68ba" class="me mf it ma b gy nm mh l mi mj">data.schema<br/>VendorID: int64<br/>tpep_pickup_datetime: timestamp[s]<br/>tpep_dropoff_datetime: timestamp[s]<br/>passenger_count: int64<br/>trip_distance: double<br/>RatecodeID: int64<br/>store_and_fwd_flag: <strong class="ma iu">large_string<br/></strong>PULocationID: int64<br/>DOLocationID: int64<br/>payment_type: int64<br/>fare_amount: double<br/>extra: double<br/>mta_tax: double<br/>tip_amount: double<br/>tolls_amount: double<br/>improvement_surcharge: double<br/>total_amount: double<br/>congestion_surcharge: double</span></pre><p id="3570" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">新的pyarrow模式看起来像是我们已经将large_String对象固定到了时间戳中。大小是184mb！伟大的</p><p id="cd9d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在让我们将large_String转换为分类特征。太好了！但它是否改变了内存占用。</p><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="657b" class="me mf it ma b gy mg mh l mi mj"><strong class="ma iu">def</strong> fix_categories(x, column_name):<br/>    replacement <strong class="ma iu">=</strong> x.column(column_name).dictionary_encode()<br/>    position <strong class="ma iu">=</strong> x.column_names.index(column_name)<br/>    x <strong class="ma iu">=</strong> x.set_column(position, column_name, replacement)<br/>    <strong class="ma iu">return</strong> x</span><span id="feb8" class="me mf it ma b gy nm mh l mi mj">data <strong class="ma iu">=</strong> fix_datetime(data, 'store_and_fwd_flag')</span><span id="e1a0" class="me mf it ma b gy nm mh l mi mj">whats_my_footprint(data)<br/>184.03 MB in the memory</span><span id="490c" class="me mf it ma b gy nm mh l mi mj">data.schema</span><span id="6a95" class="me mf it ma b gy nm mh l mi mj">VendorID: int64<br/>tpep_pickup_datetime: timestamp[s]<br/>tpep_dropoff_datetime: timestamp[s]<br/>passenger_count: int64<br/>trip_distance: double<br/>RatecodeID: int64<br/>store_and_fwd_flag: dictionary&lt;values=large_string, indices=int32, ordered=0&gt;<br/>PULocationID: int64<br/>DOLocationID: int64<br/>payment_type: int64<br/>fare_amount: double<br/>extra: double<br/>mta_tax: double<br/>tip_amount: double<br/>tolls_amount: double<br/>improvement_surcharge: double<br/>total_amount: double<br/>congestion_surcharge: double</span></pre><p id="d513" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们改变我们减少了多少内存。等待..它没有减少内存占用。在将大字符串列特性转换为分类特性时，Pandas从<strong class="kd iu"> 251 MB缩减到了179 MB </strong>。但是Polars/pyarrow没有。这意味着arrow中的large_string已经被索引了(不像Pandas，它存储为未索引的对象！！).</p><p id="5f06" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">好了，现在我们可以检查最后一次尝试，在读取Polars中的数据时指定数据类型是否会改变什么。(直到现在，我们都在看箭头数据帧)。</p><h1 id="66e2" class="mk mf it bd ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng bi translated">具有明确数据类型说明的极坐标</h1><pre class="lv lw lx ly gt lz ma mb mc aw md bi"><span id="2315" class="me mf it ma b gy mg mh l mi mj"><strong class="ma iu">%%</strong>time</span><span id="b9b9" class="me mf it ma b gy nm mh l mi mj">df <strong class="ma iu">=</strong> pl.scan_csv("yellow_tripdata_2021-01.csv")<br/>df <strong class="ma iu">=</strong> df.with_columns(<br/>[<br/>pl.col("tpep_pickup_datetime").str.strptime(pl.Datetime, '%Y-%m-%d %H:%M:%S'),<br/>pl.col("tpep_dropoff_datetime").str.strptime(pl.Datetime, '%Y-%m-%d %H:%M:%S')<br/>]).collect()<br/>display(df.schema)</span><span id="9ad5" class="me mf it ma b gy nm mh l mi mj">{'VendorID': polars.datatypes.Int64,<br/> 'tpep_pickup_datetime': polars.datatypes.Datetime,<br/> 'tpep_dropoff_datetime': polars.datatypes.Datetime,<br/> 'passenger_count': polars.datatypes.Int64,<br/> 'trip_distance': polars.datatypes.Float64,<br/> 'RatecodeID': polars.datatypes.Int64,<br/> 'store_and_fwd_flag': polars.datatypes.Utf8,<br/> 'PULocationID': polars.datatypes.Int64,<br/> 'DOLocationID': polars.datatypes.Int64,<br/> 'payment_type': polars.datatypes.Int64,<br/> 'fare_amount': polars.datatypes.Float64,<br/> 'extra': polars.datatypes.Float64,<br/> 'mta_tax': polars.datatypes.Float64,<br/> 'tip_amount': polars.datatypes.Float64,<br/> 'tolls_amount': polars.datatypes.Float64,<br/> 'improvement_surcharge': polars.datatypes.Float64,<br/> 'total_amount': polars.datatypes.Float64,<br/> 'congestion_surcharge': polars.datatypes.Float64}</span><span id="93d4" class="me mf it ma b gy nm mh l mi mj">CPU times: user 1.01 s, sys: 262 ms, total: 1.27 s<br/>Wall time: 536 ms</span><span id="584e" class="me mf it ma b gy nm mh l mi mj"><br/>whats_my_footprint(df)<br/><strong class="ma iu">184.03 MB in the memory</strong></span></pre><p id="3fef" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在你一定已经注意到北极星不占任何空间。然而，一旦转换为熊猫或箭头或任何其他实现的格式，它们将占用与任何其他工具相同的预期空间。主要的好处是速度和灵活性。</p><h1 id="eb41" class="mk mf it bd ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng bi translated">结论</h1><p id="c550" class="pw-post-body-paragraph kb kc it kd b ke nh kg kh ki ni kk kl km nj ko kp kq nk ks kt ku nl kw kx ky im bi translated">Polars仅仅是一个编排层，它做了许多智能的事情(查看文档，网址为<a class="ae kz" href="https://pola-rs.github.io/polars-book/user-guide/optimizations/lazy/intro.html" rel="noopener ugc nofollow" target="_blank">https://pola-RS . github . io/polars-book/user-guide/optimizations/lazy/intro . html</a>，了解谓词、projunction下推API和其他优化)。Polars对象就像实际执行的地图。除非有必要，否则它不会在内存中创建一个多余的对象，这最终会节省大量的时间。</p><p id="39aa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Polars的核心是一个基于Apache arrow的柱状框架。它智能地执行功能，以节省时间和内存。最终，您需要将Polars.dataframe转换为Pandas。Dataframe或任何您想要保存数据的对象，并“实现”Polars智能排序和编排的更改。</p><p id="c2d6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">快速注意:to_pandas() broken (fix) Polars安装不会将pyarrow安装为依赖项。我强烈建议使用pip install pyarrow将pyarrow作为一个单独的安装来安装。pyarrow之后，您需要重新安装/升级polars。这样，它将识别预先存在的pyarrow安装，并允许您做许多事情，如调用函数<em class="ns"> pl.dataframe.to_pandas() </em>。这种差异是因为polars内部使用pyarrow任务批处理(性能的一个原因)。</p><p id="5fbd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下一次，我们将更深入地研究在做一些我们通常最终会做的事情时，极地动物与熊猫相比效率如何。我们将计时并检查每一步的足迹(在处理过程中在内存中),以给出完整的图片。</p><p id="f0d8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在那之前，继续编码吧！</p><p id="cf41" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果这篇文章对你有帮助</p><p id="3db9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">请通过按下喜欢按钮来分享一些爱。</p><p id="12b2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">请<a class="ae kz" href="https://ithinkbot.com/membership" rel="noopener ugc nofollow" target="_blank"> <strong class="kd iu"> <em class="ns">成为会员</em> </strong> </a>和<em class="ns"> </em> <a class="ae kz" href="https://ithinkbot.com/subscribe" rel="noopener ugc nofollow" target="_blank"> <strong class="kd iu"> <em class="ns">订阅</em> </strong> </a>获取更简洁的教程。</p><figure class="lv lw lx ly gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nv"><img src="../Images/6a3a73d6912e28e6fd2e9c505ea88e2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y5tEi_xpKQL0hE7vkhoQ1A.jpeg"/></div></div><figcaption class="no np gj gh gi nq nr bd b be z dk translated">鸣谢:布雷特·乔丹(unsplash)</figcaption></figure></div></div>    
</body>
</html>