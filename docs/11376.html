<html>
<head>
<title>Follow these simple Kotlin rules to write unbreakable code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">遵循这些简单的Kotlin规则来编写牢不可破的代码</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/follow-these-simple-kotlin-rules-to-write-unbreakable-code-and-stay-99-crash-free-83752ad4fcc3?source=collection_archive---------1-----------------------#2022-03-12">https://levelup.gitconnected.com/follow-these-simple-kotlin-rules-to-write-unbreakable-code-and-stay-99-crash-free-83752ad4fcc3?source=collection_archive---------1-----------------------#2022-03-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/fd58019d65b34640f84d4bc391086473.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GyatlXoPFSHTRjLQ"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@polygonglider?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">迈克尔</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="af91" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当Kotlin被介绍给Android开发者时，它与通常的Java世界有些不同。可空性——多么好的主意！很多句法糖之类的。然而，经过多年的使用，我看到打破设计是多么容易。</p><p id="85dd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">如何避免拍腿，让自己的代码牢不可破？</strong></p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div></figure><p id="1798" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">答案很简单— <strong class="kf ir">以一种不可能(或很难)引入bug的方式设计代码</strong>。</p><p id="2cc9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们来看几件可以做的事情。</p><h1 id="e896" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">可空性</h1><p id="1ebb" class="pw-post-body-paragraph kd ke iq kf b kg mf ki kj kk mg km kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">在2009年的一次软件会议上，<a class="ae kc" href="https://en.wikipedia.org/wiki/Tony_Hoare" rel="noopener ugc nofollow" target="_blank">东尼·霍尔</a>为发明空引用道歉:“<em class="mk">我称之为我的十亿美元错误。</em></p><p id="f77d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">科特林修复了它，但是它也允许忽略这个设计。</p><h2 id="9469" class="ml li iq bd lj mm mn dn ln mo mp dp lr ko mq mr lv ks ms mt lz kw mu mv md mw bi translated">！！操作员</h2><p id="8330" class="pw-post-body-paragraph kd ke iq kf b kg mf ki kj kk mg km kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated"><code class="fe mx my mz na b">!!</code>操作员是最危险的东西之一。我敦促读者——写<code class="fe mx my mz na b">!!</code>——免费程序。即使你100%确定<em class="mk">这个引用</em>不可能为空——事实上它可以为空。不是现在，而是在不久的将来，当你的同事(或你)更改代码时。</p><p id="7f79" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">规则很简单。<strong class="kf ir">偏执。如果有什么东西会坏掉——它会的。</strong></p><p id="b109" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以永远不要在本机Kotlin代码中使用<code class="fe mx my mz na b">!!</code>操作符。</p><h2 id="45c2" class="ml li iq bd lj mm mn dn ln mo mp dp lr ko mq mr lv ks ms mt lz kw mu mv md mw bi translated">lateinit变量</h2><p id="b6b3" class="pw-post-body-paragraph kd ke iq kf b kg mf ki kj kk mg km kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">起初，Kotlin的这个特性看起来很方便，值得信赖。但现实是残酷的。</p><p id="77ef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我的第一个Kotlin项目中，我看到越来越多的<a class="ae kc" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-uninitialized-property-access-exception/" rel="noopener ugc nofollow" target="_blank">UninitializedPropertyAccessException</a>。当然，您可以检查属性是否已初始化。但是你可以忘记去做，对吗？或者不是你，你的低年级同事。</p><p id="01c6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">偏执。如果有什么东西会坏掉——它会的。</strong></p><p id="f199" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">用<code class="fe mx my mz na b">nullable var</code>代替。示例:</p><pre class="lb lc ld le gt nb na nc nd aw ne bi"><span id="af68" class="ml li iq na b gy nf ng l nh ni">var signData: SignData? = null</span><span id="60bd" class="ml li iq na b gy nj ng l nh ni">// ....</span><span id="f702" class="ml li iq na b gy nj ng l nh ni">signData.cost?.<em class="mk">let </em><strong class="na ir">{<br/>    </strong>updateViewState<em class="mk">(</em>DomainViewState.DataReady<em class="mk">(</em><strong class="na ir">it</strong>, domain<em class="mk">))<br/></em><strong class="na ir">} </strong>?: <em class="mk">run </em><strong class="na ir">{<br/>    </strong>Timber.e<em class="mk">(</em>Exception<em class="mk">(</em>"SignData.Cost is null but it is required"<em class="mk">))<br/>    </em>sendMessageEvent<em class="mk">(</em>R.string.<em class="mk">domain_error)<br/></em><strong class="na ir">}</strong></span></pre><p id="c759" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如你所看到的，这里你<em class="mk">必须</em>使用一个空检查— <code class="fe mx my mz na b">let</code>。作为奖励，您可以使用<code class="fe mx my mz na b">?:</code>操作符和<em class="mk">编写一些东西来处理</em>可能出现的情况，即<code class="fe mx my mz na b">signData.cost</code>将为空。即使你<em class="mk">从未</em>期望它为空，但通过设计，技术上<em class="mk">可以</em>为空。哦，永远不要。</p><h1 id="702b" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">施工时</h1><h2 id="cf59" class="ml li iq bd lj mm mn dn ln mo mp dp lr ko mq mr lv ks ms mt lz kw mu mv md mw bi translated">陈述还是表达？</h2><p id="8b80" class="pw-post-body-paragraph kd ke iq kf b kg mf ki kj kk mg km kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">是一个奇妙的建筑，让我们的生活一天比一天好。但是你应该知道在某些情况下<code class="fe mx my mz na b">when</code>是一个陈述，在某些情况下是一个表达式。</p><p id="5cce" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你需要使用<code class="fe mx my mz na b">when</code>构造的结果，这意味着它是一个表达式:</p><pre class="lb lc ld le gt nb na nc nd aw ne bi"><span id="0e85" class="ml li iq na b gy nf ng l nh ni">val result = when <em class="mk">(</em>event<em class="mk">) {<br/>    </em>is ViewEvent.One -&gt; onOne<em class="mk">()<br/>    </em>ViewEvent.Two -&gt; onTwo<em class="mk">()<br/>}</em></span></pre><p id="513d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果使用<code class="fe mx my mz na b">when</code>作为表达式，编译器会检查所有可能的分支。如果在上面的例子中<code class="fe mx my mz na b">event</code>是可空的，代码将不会被编译。您必须将其更改为:</p><pre class="lb lc ld le gt nb na nc nd aw ne bi"><span id="a0dc" class="ml li iq na b gy nf ng l nh ni">val result = when <em class="mk">(</em>event<em class="mk">) {<br/>    </em>is ViewEvent.One -&gt; onOne<em class="mk">()<br/>    </em>ViewEvent.Two -&gt; onTwo<em class="mk">()<br/></em>    null -&gt; { /* something */ }<br/><em class="mk">}</em></span></pre><p id="e699" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是如果你不使用结果，编译器不会强制处理所有可能的情况:</p><pre class="lb lc ld le gt nb na nc nd aw ne bi"><span id="9d73" class="ml li iq na b gy nf ng l nh ni">when <em class="mk">(</em>event<em class="mk">) {<br/>    </em>is ViewEvent.One -&gt; onOne<em class="mk">()<br/>    </em>ViewEvent.Two -&gt; onTwo<em class="mk">()<br/>}</em></span></pre><p id="d9d2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是一个声明，结果没有用上<strong class="kf ir">这就是</strong>的脆弱之处。</p><p id="a088" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设你使用<a class="ae kc" href="https://medium.com/@alexzaitsev/mvi-with-android-compose-on-a-real-example-f5d522707be5" rel="noopener"> MVI </a>作为一种表现模式。您的<code class="fe mx my mz na b">Composable</code>正在收听来自<code class="fe mx my mz na b">ViewModel</code>的<code class="fe mx my mz na b">ViewEvents</code>。</p><p id="381d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可以这样写:</p><pre class="lb lc ld le gt nb na nc nd aw ne bi"><span id="f59c" class="ml li iq na b gy nf ng l nh ni">@Composable<br/>private fun EventsProcessor<em class="mk">(<br/>    </em>viewModel: SplashViewModel,<br/>    onOpenDomainsList: <em class="mk">() </em>-&gt; Unit,<br/>    onStartWalletImport: <em class="mk">() </em>-&gt; Unit<br/><em class="mk">) {<br/>    </em>val event: SplashViewEvent? = viewModel.viewEvents.collectAsState<em class="mk">(</em>initial = null<em class="mk">)</em>.value<br/>    when <em class="mk">(</em>event<em class="mk">) {<br/>        </em>is SplashViewEvent.OpenDomainsList -&gt; onOpenDomainsList<em class="mk">()<br/>        </em>SplashViewEvent.StartWalletsImport -&gt; onStartWalletImport<em class="mk">()<br/>    }<br/>}</em></span></pre><p id="ee96" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你已经看到问题了吗？</p><p id="babe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果不是，请回答下一个问题:<em class="mk">如果将来您或您的同事添加了新的</em> <code class="fe mx my mz na b"><em class="mk">ViewEvent</em></code> <em class="mk">，会发生什么？</em></p><p id="9915" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正确答案是——代码作者将不得不手动控制它，并且不要忘记更改上面的<code class="fe mx my mz na b">when</code>。这意味着很可能在某个时候这个问题会被提出来。</p><p id="6217" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">又来了。<strong class="kf ir">偏执。如果有什么东西会坏掉——它会的。</strong></p><p id="70bd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">只需将语句转换为表达式，就可以轻松修复上述代码:</p><pre class="lb lc ld le gt nb na nc nd aw ne bi"><span id="6db5" class="ml li iq na b gy nf ng l nh ni">@Composable<br/>private fun EventsProcessor<em class="mk">(<br/>    </em>viewModel: SplashViewModel,<br/>    onOpenDomainsList: <em class="mk">() </em>-&gt; Unit,<br/>    onStartWalletImport: <em class="mk">() </em>-&gt; Unit<br/><em class="mk">) {<br/>    </em>val event: SplashViewEvent? = viewModel.viewEvents.collectAsState<em class="mk">(</em>initial = null<em class="mk">)</em>.value<br/>    return when <em class="mk">(</em>event<em class="mk">) {<br/>        </em>null -&gt; <em class="mk">{<br/>        }<br/>        </em>is SplashViewEvent.OpenDomainsList -&gt; onOpenDomainsList<em class="mk">()<br/>        </em>SplashViewEvent.StartWalletsImport -&gt; onStartWalletImport<em class="mk">()<br/>    }<br/>}</em></span></pre><p id="d7de" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你要加的就是<code class="fe mx my mz na b">return</code>。或将<code class="fe mx my mz na b">when</code>结果赋给一个变量。你不必使用它。唯一的目的是强制编译器检查。使用这种方法，你<em class="mk">永远不会忘记改变<code class="fe mx my mz na b">when</code>。</em></p><h2 id="bb36" class="ml li iq bd lj mm mn dn ln mo mp dp lr ko mq mr lv ks ms mt lz kw mu mv md mw bi translated">Else分支</h2><p id="b86c" class="pw-post-body-paragraph kd ke iq kf b kg mf ki kj kk mg km kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">另一种拍腿的方法是用<code class="fe mx my mz na b">else</code>分支换<code class="fe mx my mz na b">when</code>。<code class="fe mx my mz na b">Else</code>消耗其他分支中所有非手工处理的案例。</p><p id="bd13" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你看到了吗？同样，设想一种情况，将来有人更改了<code class="fe mx my mz na b">sealed class</code>，但是编译器不会提醒您处理新的情况。就因为有<code class="fe mx my mz na b">else</code>在那里。</p><p id="caad" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以，<strong class="kf ir">永远不要用<code class="fe mx my mz na b">else</code>分支代替<code class="fe mx my mz na b">when</code>。你会安全的。</strong></p><h1 id="06ac" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">结论</h1><p id="75bd" class="pw-post-body-paragraph kd ke iq kf b kg mf ki kj kk mg km kn ko mh kq kr ks mi ku kv kw mj ky kz la ij bi translated">谢谢你的阅读，我的朋友。</p><p id="fb15" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我想你已经明白了:写你的代码的任何一行都要问一个问题——如果一个新人来到这个项目并开始写代码，会安全吗？想象一下，你要去度假，而你不在的时候，一个初级同事必须解决紧急问题。</p><p id="9b83" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">记住。<strong class="kf ir">多疑。如果有什么东西会坏掉——它会的。</strong></p><p id="23f8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就是为什么通过设计写出牢不可破的代码<em class="mk">如此重要。<em class="mk">不依赖</em>你或别人记忆的代码。只是因为记忆是个不好依赖的东西。尤其是当系统在增长的时候。</em></p><p id="ed18" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">编码快乐！<strong class="kf ir">关注我</strong> <a class="ae kc" href="https://twitter.com/alexzaitsev_btc" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">推特</strong> </a> <strong class="kf ir">。</strong></p></div></div>    
</body>
</html>