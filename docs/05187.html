<html>
<head>
<title>Vue state management (Vuex) for React developers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向React开发人员的Vue状态管理(Vuex)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/vue-state-management-vuex-for-react-developers-4ae032d9c75e?source=collection_archive---------11-----------------------#2020-08-10">https://levelup.gitconnected.com/vue-state-management-vuex-for-react-developers-4ae032d9c75e?source=collection_archive---------11-----------------------#2020-08-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/d3134926e86fd65fde1827a4bd4c084b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k-bN_BxG3kPE7hbRGZtI0g.png"/></div></div></figure><div class=""/><p id="91e2" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这篇文章的目标读者是那些有兴趣了解更多关于Vue.js中状态管理的人，但是我相信那些没有接触过Vue如何处理状态的<a class="ae kw" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"> react </a>开发者也会特别感兴趣。</p><h1 id="b4b6" class="kx ky jb bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">写这篇文章的原因</h1><p id="685a" class="pw-post-body-paragraph jy jz jb ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">我为什么要写这篇文章？好吧，我在React中应用程序状态管理的所有体验都是负面的，说得好听点，我其实很喜欢使用Vuex。我想分享我认为更好的陈述方式。如果你很少或没有Vue的经验，并且来自React / Redux背景。我希望你会喜欢我给你看的东西，并带走一个积极的信息。</p><p id="8872" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我想让React开发人员看到Vue是如何处理组件和应用程序状态的，以及它是如何集成这两者的，我认为这是一种非常优雅的方式。</p><p id="df80" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">react中的组件状态是正常的，对于一个非常基本的SPA来说，可能需要比Vue稍少的代码。我仍然会讨论Vue的组件状态，因为它是如何将应用程序状态集成到组件中不可或缺的一部分。</p><p id="3015" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">React中的应用状态是事情变得混乱的地方，它是狂野的西部(冷静下来，爱，这只是我的观点)，但我不会为我的观点道歉。作为一名开发人员，你要靠自己。你得自己选择一个状态包，每个选择都有妥协。</p><p id="90ee" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">react中的应用程序状态管理有一些优点，但那是一篇让其他人去尝试和编写的文章。</p><h1 id="ebe3" class="kx ky jb bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">什么是Vuex</h1><p id="6f04" class="pw-post-body-paragraph jy jz jb ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated"><a class="ae kw" href="https://vuex.vuejs.org/" rel="noopener ugc nofollow" target="_blank"> Vuex </a>是用于Vue中应用状态管理的包。它是由维护Vue的同一个团队维护的，所以可以保证你的兼容性。Vuex与Vue紧密耦合，所以它被设计得尽可能简单，而且(我认为)使用起来很愉快。这种紧密的耦合并不妨碍你使用<a class="ae kw" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> redux </a>，如果你真的不想把那些针推进你的眼睛的话:-)。</p><h1 id="2de2" class="kx ky jb bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">我的例子将涵盖什么</h1><ul class=""><li id="e3b7" class="ma mb jb ka b kb lv kf lw kj mc kn md kr me kv mf mg mh mi bi translated">组件状态</li><li id="a28c" class="ma mb jb ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">应用状态</li><li id="d7d6" class="ma mb jb ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">将外部API集成到组件和应用程序状态中。(使用<a class="ae kw" href="https://swapi.dev/" rel="noopener ugc nofollow" target="_blank"> SWAPI </a> API)</li><li id="907b" class="ma mb jb ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">持续状态(浏览器刷新后状态持续)</li></ul><p id="b2fd" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">完整代码:</strong>本教程的完整代码可以在GitHub上获得，因此您可以快速克隆和实验。<a class="ae kw" href="https://github.com/simonjcarr/vue_state_for_react_developers" rel="noopener ugc nofollow" target="_blank">https://github . com/simonjcarr/vue _ state _ for _ react _ developers</a></p><h1 id="d07a" class="kx ky jb bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">组件状态</h1><p id="a168" class="pw-post-body-paragraph jy jz jb ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated"><strong class="ka jc">没有状态的组件</strong></p><p id="8399" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Vue中的组件可以像下面的代码一样简单，但是它没有状态。</p><figure class="mo mp mq mr gt is"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="27fa" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">数据方法</strong></p><p id="70be" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，要在组件级别启用状态，我们必须添加一个<code class="fe mu mv mw mx b">script</code>部分。在最简单的场景中，我们只需导出一个数据方法，该方法返回一个对象，该对象中的每个键都可以在模板部分中使用字符串插值来引用。</p><figure class="mo mp mq mr gt is"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="5d4e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">计算属性</strong></p><p id="446f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">向Vue添加计算属性就像导出另一个属性一样简单，令人惊讶的是，这个属性叫做<code class="fe mu mv mw mx b">computed</code></p><figure class="mo mp mq mr gt is"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="a05b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们再次使用字符串插值来调用计算属性<code class="fe mu mv mw mx b">addOne()</code>，它简单地返回值<code class="fe mu mv mw mx b">myNumber</code>并加1。</p><p id="1890" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">方法</strong></p><p id="700d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以做更复杂的事情，比如用方法访问远程数据源。下面的代码有点复杂，但我会带您浏览一下。</p><figure class="mo mp mq mr gt is"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="219b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们浏览代码之前，下面是结果。</p><figure class="mo mp mq mr gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi my"><img src="../Images/9a9601370d77b2a0259603469cc3516c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*8JyEX2K7Sw3c3dUI-DINPA.gif"/></div></div></figure><p id="dc5d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里发生了什么？</p><p id="348a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我将<code class="fe mu mv mw mx b">swPerson</code>添加到data()中，并将其初始化为<code class="fe mu mv mw mx b">null</code></p><p id="da58" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我在与<code class="fe mu mv mw mx b">data</code>和<code class="fe mu mv mw mx b">computed</code>相同的级别上创建了一个新的<code class="fe mu mv mw mx b">method</code>属性。在属性内部，我添加了一个接受一个属性<code class="fe mu mv mw mx b">id</code>的<code class="fe mu mv mw mx b">getPerson</code>方法。该方法使用<code class="fe mu mv mw mx b">fetch</code>通过传入的idi连接到swapi api，并获取一个星球大战角色。它将结果转换为JSON并存储在<code class="fe mu mv mw mx b">swPerson</code>中</p><figure class="mo mp mq mr gt is"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="96d1" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我创建了一个<code class="fe mu mv mw mx b">computed</code>属性<code class="fe mu mv mw mx b">personName</code>。它检查<code class="fe mu mv mw mx b">swPerson</code>是否为空。如果它是null，那么它简单地返回null，如果它不是null，它返回星球大战角色的名字。</p><figure class="mo mp mq mr gt is"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="34d1" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有了上面的内容，我就可以更新下面的<code class="fe mu mv mw mx b">template</code></p><figure class="mo mp mq mr gt is"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="1707" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mu mv mw mx b">{{ personName }}</code>是计算出的属性。如上所述，它将返回null或星球大战角色名。</p><p id="5b43" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我在按钮中再次使用了<code class="fe mu mv mw mx b">personName</code>，这次使用了一个叫做Vue指令的东西。在这种情况下是<code class="fe mu mv mw mx b">v-if</code>指令。<code class="fe mu mv mw mx b">v-if="!personName"</code>表示如果personName为空，则显示该元素，在本例中是一个按钮。如果不为空，按钮应该隐藏。按钮上还添加了一个<code class="fe mu mv mw mx b">@click</code>事件处理程序。这个处理程序调用<code class="fe mu mv mw mx b">getPerson(1)</code>方法，传入我们想要获取的字符的id。</p><p id="e4dd" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">总之，当点击按钮时，<code class="fe mu mv mw mx b">getPerson</code>从SWAPI api获取数据并更新<code class="fe mu mv mw mx b">swPerson</code>。这导致计算属性personName更新DOM。显示角色的名字，隐藏按钮。我希望你同意，这真的很优雅。</p><p id="3d91" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">组件中还有许多其他可用的属性，但是我不打算在这里介绍它们。如果你想要更多的细节，你可以看看Vue网站上的<a class="ae kw" href="https://vuejs.org/v2/guide/components.html" rel="noopener ugc nofollow" target="_blank"> Vue组件</a>。</p><h1 id="5ddb" class="kx ky jb bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">应用状态</h1><p id="d5e8" class="pw-post-body-paragraph jy jz jb ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">现在我们来看看Vuex，以及它是如何在应用层管理状态的。</p><p id="ae12" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这将加快我们在上面看到的简单组件状态的步伐，但是我希望你会同意，它仍然是相对简单的，并且使用起来很愉快。</p><p id="7e07" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">安装</strong></p><p id="d48d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当你用<code class="fe mu mv mw mx b">Vue create myapp</code>创建一个新的Vue应用时，你会被问一系列关于你想在应用中包含什么的问题，Vuex是其中一个选项。即使您在创建应用程序时没有安装Vuex，以后安装它也非常容易。</p><p id="e7d8" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">完整的安装说明可以在这里找到，但是很简单</p><pre class="mo mp mq mr gt mz mx na nb aw nc bi"><span id="1804" class="nd ky jb mx b gy ne nf l ng nh">npm install vuex</span></pre><p id="92ba" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最佳实践是在应用程序的根目录下创建一个名为<code class="fe mu mv mw mx b">store</code>的文件夹。对于简单的状态管理，我们只需要一个文件。随着你的应用程序越来越大，我们使用模块，每个模块在不同的文件中，因此最好把你的状态文件放在一个文件夹中。如果你在使用Vue创建新应用时选择了Vuex，这个文件夹已经存在，里面是一个文件<code class="fe mu mv mw mx b">index.js</code></p><figure class="mo mp mq mr gt is"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="ec4b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个文件将保存一个简单应用程序的所有状态配置。</p><p id="3af5" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您将看到Vue和Vuex被导入到文件的顶部。</p><p id="a618" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mu mv mw mx b">Vue.use()</code>是我们教Vue做新东西的说法。所以<code class="fe mu mv mw mx b">Vue.use(Vuex)</code>本质上是教Vue它需要知道的关于Vuex的一切。</p><p id="5616" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在文件的底部，创建并导出了一个新的<code class="fe mu mv mw mx b">Vuex.store</code>实例。当我们创建一个新的商店时，我们传递配置，它由<code class="fe mu mv mw mx b">state</code>、<code class="fe mu mv mw mx b">mutations</code>、<code class="fe mu mv mw mx b">actions</code>和<code class="fe mu mv mw mx b">modules</code>组成。如果你使用过redux，你会很清楚这些是如何工作的。</p><p id="9def" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当然，Vue不知道这个文件的存在，所以我们必须在<code class="fe mu mv mw mx b">main.js</code>中导入它，然后告诉我们的应用程序使用它。我在相关的两行中添加了注释。正如我上面所说的，如果你使用<code class="fe mu mv mw mx b">vue create xxxx</code>创建一个新的应用程序，所有这些都是为你创建的。</p><figure class="mo mp mq mr gt is"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="762d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">向Vuex添加一些状态</strong></p><p id="a73e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我将创建一个非常简单的todo应用程序，它将ToDo任务存储在Vuex中。</p><p id="de03" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们从创建一个新模块开始，以保持我们的应用程序在逻辑上的分离。</p><p id="79f6" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我将创建一个新文件<code class="fe mu mv mw mx b">/store/todo.js</code></p><figure class="mo mp mq mr gt is"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="0f2d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">并将其导入<code class="fe mu mv mw mx b">/store/index.js</code></p><figure class="mo mp mq mr gt is"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="0e60" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我已经注释了两行代码。就是这样！我们的新模块已经可以使用了。让我们创建一个任务对象并用第一个todo预加载它。</p><p id="c8ad" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<code class="fe mu mv mw mx b">/store/todo.js</code></p><figure class="mo mp mq mr gt is"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="b936" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我将添加一些突变，因为我们不应该直接改变状态。很快我将向您展示一个chrome dev tools插件，它为我们提供了所有更改和时间旅行功能的日志。</p><figure class="mo mp mq mr gt is"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="deb0" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我增加了3个突变。<code class="fe mu mv mw mx b">addTask</code>、<code class="fe mu mv mw mx b">setTaskStatus</code>、<code class="fe mu mv mw mx b">deleteTask</code></p><p id="1402" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里有几件值得注意的事情。</p><p id="cd6c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我导入了<code class="fe mu mv mw mx b">lodash</code>来帮助过滤任务，导入了<code class="fe mu mv mw mx b">uuid</code>来为每个任务创建一个ID。</p><p id="49d3" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们愿意，我们可以在这里停下来，直接从我们的组件中调用这些突变，但为了完整起见，我还将创建一些操作，这些操作将调用，反过来，它们将提交这些突变。</p><figure class="mo mp mq mr gt is"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="a6ea" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这种情况下，我们所做的就是调用变异，然而，当它们被用来调用外部api时，动作是非常强大的。稍后我们会看到更多的星球大战角色使用Vuex动作。</p><p id="ecd4" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">商店现在可以使用了。我现在将向您展示从一个组件与状态交互是多么容易。</p><p id="9cb1" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">待办事项组件</strong></p><p id="abc1" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在文件<code class="fe mu mv mw mx b">/views/Todo.vue</code>中，我将从下面的基本代码开始。</p><figure class="mo mp mq mr gt is"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="ce82" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我要做的第一件事是将Vuex状态绑定到组件。我们使用Vuex <code class="fe mu mv mw mx b">mapState</code>提供的助手来完成这项工作</p><p id="792c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们在计算属性中使用映射状态，如下所示</p><figure class="mo mp mq mr gt is"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="a234" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我导入了<code class="fe mu mv mw mx b">mapstate</code>，然后使用扩展操作符<code class="fe mu mv mw mx b">...</code>从<code class="fe mu mv mw mx b">Todo</code>模块映射<code class="fe mu mv mw mx b">tasks</code>的状态。如果我在那个模块中有不止一个状态，我也可以把它包含在数组中。如果我想映射另一个模块的状态，我可以添加另一个<code class="fe mu mv mw mx b">...mapState</code></p><p id="266f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们做一个类似的动作。</p><figure class="mo mp mq mr gt is"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="06e9" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你会发现这真的很简单，唯一的区别是我们映射的Vuex <code class="fe mu mv mw mx b">actions</code>被包含在<code class="fe mu mv mw mx b">methods</code>属性中。</p><p id="5f9f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">建筑出模板</strong></p><p id="f8c8" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在剩下要做的就是为组件模板部分编写HTML，并为添加任务表单添加一些本地状态。</p><p id="0ad1" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是不带表单的Todos，它允许我们使用一个硬编码的todo。我们可以删除它并改变它的状态。</p><figure class="mo mp mq mr gt is"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="6adb" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上面的代码中，我添加了一个删除任务的按钮。这将调用我们已经映射的<code class="fe mu mv mw mx b">deleteTask</code>方法，并传入<code class="fe mu mv mw mx b">task.id</code></p><p id="b354" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我创建了另一个按钮来改变任务的完成状态。当\@click事件触发到<code class="fe mu mv mw mx b">setTaskStatus</code>时，它发送一个包含我们想要分配给任务的<code class="fe mu mv mw mx b">id</code>和<code class="fe mu mv mw mx b">status</code>的对象。</p><pre class="mo mp mq mr gt mz mx na nb aw nc bi"><span id="1eab" class="nd ky jb mx b gy ne nf l ng nh">@click="setTaskStatus({ id: task.id, status: !task.complete })"</span></pre><p id="9de2" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我使用一个名为v-bind的Vue特性来映射动态类，并根据task.complete为按钮设置了正确的文本。</p><pre class="mo mp mq mr gt mz mx na nb aw nc bi"><span id="3aa5" class="nd ky jb mx b gy ne nf l ng nh">:class="{<br/>'bg-green-500 text-white': !task.complete, <br/>'bg-red-500 text-white': task.complete<br/>}"</span><span id="a318" class="nd ky jb mx b gy ni nf l ng nh">{{ task.complete ? "Mark not Complete" : "Mark Complete" }}</span></pre><p id="42e5" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我还根据task.complete为任务标题设置了一些文本样式</p><pre class="mo mp mq mr gt mz mx na nb aw nc bi"><span id="1b2d" class="nd ky jb mx b gy ne nf l ng nh">:class="{ 'text-red-500 line-through': task.complete }"</span></pre><p id="609a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">添加新的任务表单</strong></p><p id="4c11" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们添加一个表单。实际上，我将为表单创建另一个组件，但是为了让您完整地看到该组件，我将在该组件中执行所有操作。</p><figure class="mo mp mq mr gt is"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="cda2" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是完整的组件。我为data()设置了一个新属性<code class="fe mu mv mw mx b">newTask</code>,并使用<code class="fe mu mv mw mx b">v-bind</code>到<code class="fe mu mv mw mx b">newTask</code>绑定了表单输入</p><p id="d382" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你会注意到表单使用了一个\@submit.prevent，这个<code class="fe mu mv mw mx b">.prevent</code>被称为Vue修饰符，这样我们就不用手动获取表单对象和<code class="fe mu mv mw mx b">preventDefault</code>。无论如何，当提交表单时，会调用<code class="fe mu mv mw mx b">addTaskSubmit</code>方法。这是turn调用Vuex中的<code class="fe mu mv mw mx b">addTask</code>并传入<code class="fe mu mv mw mx b">newTask</code>的值</p><p id="8245" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Vuex一更新，我们的待办事项列表就会显示新任务。</p><figure class="mo mp mq mr gt is gh gi paragraph-image"><div class="gh gi my"><img src="../Images/2949d837900b2162f3967fe859921584.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*9Chlm2qKsF9Fmbj5m69SYw.gif"/></div></figure><h1 id="a293" class="kx ky jb bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">使用Vuex访问远程数据</h1><p id="6765" class="pw-post-body-paragraph jy jz jb ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">我们快到了，我要给你看一些没有意义但你可能会感兴趣的东西。</p><p id="f57f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我将为每个任务添加一个<code class="fe mu mv mw mx b">completedBy</code>属性，当任务被标记为完成时，将从SWAPI中获取一个随机的星球大战字符，并使用名称字段来更新completedBy。</p><p id="3d76" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们在组件中唯一需要改变的是将completedBy字段添加到Todo列表中。我会先做的</p><figure class="mo mp mq mr gt is"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="a5ef" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我将更新<code class="fe mu mv mw mx b">/store/todo.js</code></p><figure class="mo mp mq mr gt is"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="9a98" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您将看到我已经将新属性<code class="fe mu mv mw mx b">completedBy</code>添加到了<code class="fe mu mv mw mx b">tasks</code>中，并在创建新任务时包含了它。</p><p id="8c00" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当一个任务被更新时，我简单地调用SWAPI API上的fetch，这次传入一个1到10之间的随机数，并用角色名更新了<code class="fe mu mv mw mx b">compltedBy</code>字段。</p><figure class="mo mp mq mr gt is gh gi paragraph-image"><div class="gh gi my"><img src="../Images/ecffa91cce630a9df204d39a4f488c05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*xsLKQ21kICEuZAbNsHUTww.gif"/></div></figure><h1 id="b9f1" class="kx ky jb bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">Vuex持续状态</h1><p id="7400" class="pw-post-body-paragraph jy jz jb ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">我想与你分享的最后一件事是，我们如何能够非常容易地在浏览器刷新之间保持状态。</p><p id="0d82" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我将安装一个npm模块【https://www.npmjs.com/package/vuex-persistedstate T2】让它变得如此简单，简直是疯了。</p><p id="f3c4" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在主存储文件<code class="fe mu mv mw mx b">/store/index.js</code>中导入它</p><pre class="mo mp mq mr gt mz mx na nb aw nc bi"><span id="f6b1" class="nd ky jb mx b gy ne nf l ng nh"><em class="nj">import</em> createPersistedState <em class="nj">from</em> 'vuex-persistedstate'</span></pre><p id="fe75" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后添加一个新属性<code class="fe mu mv mw mx b">plugins</code>并告诉Vuex加载它。</p><figure class="mo mp mq mr gt is"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="4f55" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有了这两行代码，我们现在可以刷新浏览器，我们的状态得到了维护。</p><figure class="mo mp mq mr gt is gh gi paragraph-image"><div class="gh gi my"><img src="../Images/490f968c6deefa3880d97c173582ac9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*Uy2PLGAsT1uEI5uVPWbllA.gif"/></div></figure><h1 id="69be" class="kx ky jb bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">摘要</h1><p id="b865" class="pw-post-body-paragraph jy jz jb ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">我希望你喜欢这篇文章。它比我想象的要长得多，但是有相当多的东西需要解释。</p><p id="56ef" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这篇文章的目的是向React开发者展示Vue在状态管理方面提供了什么。我希望我做到了。不管你喜不喜欢这篇文章，请留下评论，让我知道你的想法。</p></div></div>    
</body>
</html>