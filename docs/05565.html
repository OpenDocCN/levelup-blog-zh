<html>
<head>
<title>Thought experiment: what if Java’s AWT was invented today?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">思想实验:如果Java的AWT是今天发明的会怎么样？</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/thought-experiment-what-if-javas-awt-was-invented-today-7644c96d7d94?source=collection_archive---------7-----------------------#2020-09-09">https://levelup.gitconnected.com/thought-experiment-what-if-javas-awt-was-invented-today-7644c96d7d94?source=collection_archive---------7-----------------------#2020-09-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/aea402e1a54eae298b02b58f567b0a77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XeBFvGeFSYty7EVo"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@ricanaypa?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Rica Naypa </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="edc2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Java已经存在了将近四分之一世纪。从一开始，Java就有抽象窗口工具包(AWT ),它提供了一种简洁而简单的方法来创建跨平台的图形用户界面。</p><p id="d474" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">AWT远非完美。使用AWT的Java程序从来不像是为运行它的特定操作系统编写的C++程序。在我看来，这是在多种操作系统上运行能力的一个可接受的折衷。</p><p id="a0b1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">即使考虑到这一点，AWT也有几个问题，其中一些在当时非常明显，而且，正如我稍后将解释的那样，由于我们对封装和不变性的偏好，其他问题在今天对我们来说比几年前更加明显。</p><p id="e10b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">AWT之后不久，Sun Microsystems推出了Swing和后来的JavaFX。即使在Oracle下，Java也保留了AWT、Swing和JavaFX(虽然JavaFX被移到了一个单独的模块中)。</p><p id="f616" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">长话短说，我不打算讨论整个AWT系统。我将集中讨论一个单独的类，来自<code class="fe le lf lg lh b">java.awt</code>包的<code class="fe le lf lg lh b">Point</code>类。</p><p id="b906" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">Point</code>类有几个问题，考虑到四分之一世纪前做出的糟糕的设计决策被JDK中的其他类所依赖，也许还被我们可能使用的第三方库所依赖，所有这些问题都可能被写在石头上。</p><p id="ef2b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以我们不会提议对官方考虑的<code class="fe le lf lg lh b">Point</code>等级做任何改变来改变JDK的规格。在任何情况下，AWT的所有问题都被标记为“无法修复”</p><p id="62c9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过阅读Javadoc online 我发现的<code class="fe le lf lg lh b">Point</code>的第一个问题是完全缺乏封装。一个<code class="fe le lf lg lh b">Point</code>实例的字段<code class="fe le lf lg lh b">x</code>和<code class="fe le lf lg lh b">y</code>可以被任何可以访问该实例的对象修改。</p><p id="8b30" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">可以认为封装是不必要的，因为任何32位有符号整数都是<code class="fe le lf lg lh b">x</code>或<code class="fe le lf lg lh b">y</code>的有效值。表示从2147483648到2147483647的任何整数。</p><p id="c9bf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是在普通消费者考虑购买8K显示器之前很久的事了；我认为<code class="fe le lf lg lh b">x</code>和<code class="fe le lf lg lh b">y</code>的范围还是太大了。</p><p id="5688" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">毕竟，<code class="fe le lf lg lh b">Point</code>的主要用途是描述屏幕上的点，比如在<code class="fe le lf lg lh b">PointerInfo</code>中，它指示用户点击鼠标的位置。但是也许<code class="fe le lf lg lh b">Point</code>不应该负责验证。</p><p id="8da4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">AWT的设计者认为，因此没有必要编写getters或setters。然而，由于一些奇怪的原因，<code class="fe le lf lg lh b">Point</code>有getters，但没有setters，即使类型是可变的。在我看来，<code class="fe le lf lg lh b">Point</code>的易变性是一个更大的问题。</p><p id="1a32" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如今，我们更喜欢不变性。对于那些需要快速复习的人来说，如果类型<code class="fe le lf lg lh b">T</code>是不可变的，这意味着<code class="fe le lf lg lh b">T</code>的一个实例只能通过构造一个新的实例来改变。</p><p id="f539" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">必要时，类型<code class="fe le lf lg lh b">T</code>的变量仍可更改。只是我们没有编写一个改变<code class="fe le lf lg lh b">T</code>实例的字段的过程，而是编写一个函数，用期望的字段给出一个新的<code class="fe le lf lg lh b">T</code>实例。</p><p id="e40c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用<code class="fe le lf lg lh b">Point</code>，可能会发生这样的情况:我们编写一个单元，向不是我们自己编写的东西发送一个<code class="fe le lf lg lh b">Point</code>实例。如果某些事情以我们没有预料到的方式改变了<code class="fe le lf lg lh b">Point</code>实例，并且我们的单元需要在调用后对<code class="fe le lf lg lh b">Point</code>实例做其他事情，那么，这可能会给我们带来问题，并且花费相当多的时间使用调试器。</p><p id="dd48" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">也许正是因为这个原因，<code class="fe le lf lg lh b">Point</code>提供了一个复制构造器，它创建了一个新的<code class="fe le lf lg lh b">Point</code>实例，与现有的<code class="fe le lf lg lh b">Point</code>实例具有相同的<code class="fe le lf lg lh b">x</code>和<code class="fe le lf lg lh b">y</code>。这样，如果我们在发送之后仍然需要原始的<code class="fe le lf lg lh b">Point</code>,我们将确保在可能改变它的调用之前复制它。</p><p id="a978" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是如果<code class="fe le lf lg lh b">Point</code>是不可变的，我们就不需要做所有这些。我们的程序可以将<code class="fe le lf lg lh b">Point</code>实例发送到第三方库，让它做它需要做的任何事情，当它完成时，我们仍然有我们原来的<code class="fe le lf lg lh b">Point</code>实例。</p><p id="0927" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">还要注意<code class="fe le lf lg lh b">Point</code>不是<code class="fe le lf lg lh b">Object</code>的直接子类。<code class="fe le lf lg lh b">Point</code>的直接超类是<code class="fe le lf lg lh b">Point2D</code>，来自“子包”<code class="fe le lf lg lh b">java.awt.geom</code>。</p><p id="ac42" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">而<code class="fe le lf lg lh b">Point2D</code>包含两个嵌套的静态类，<code class="fe le lf lg lh b">Point2D.Double</code>和<code class="fe le lf lg lh b">Point2D.Float</code>。这到底有什么意义？这听起来像是过度工程化了。</p><p id="f23d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们今天必须用我们今天所知道的来写AWT，那么AWT会是什么样子呢？<code class="fe le lf lg lh b">Point</code>会是什么样子？</p><p id="5f25" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于这个思考练习，让我们想象一下，我们可以按照我们认为最好的方式重写<code class="fe le lf lg lh b">Point</code>，并且我们有全权重构我们改进后的<code class="fe le lf lg lh b">Point</code>中断概念中的任何内容。</p><p id="978c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在您最喜欢的集成开发环境(IDE)的一个项目中，制作一个类似于<code class="fe le lf lg lh b">awtredux</code>的包。实际上，没有什么可以阻止你在你的项目中制作一个<code class="fe le lf lg lh b">java.awt</code>包，但是它可能会产生比你在一个思想实验中想要处理的更多的问题。</p><p id="3370" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<code class="fe le lf lg lh b">awtredux</code>包中，让你的IDE创建<code class="fe le lf lg lh b">Point</code>类，填充封装和不变性的最低要求。</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="c985" class="lq lr it lh b gy ls lt l lu lv">package awtredux;</span><span id="491c" class="lq lr it lh b gy lw lt l lu lv">public class Point {<br/>    <br/>    private final int coordX, coordY;<br/>    <br/>    // TODO: Write getters getX() and getY()<br/>    <br/>    public Point() {<br/>        this(0, 0);<br/>    }<br/>    <br/>    public Point(int x, int y) {<br/>        this.coordX = x;<br/>        this.coordY = y;<br/>    }<br/>    <br/>}</span></pre><p id="d315" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了强调封装，我决定私有字段应该有不太明显的标识符。额外的好处是，这使得构造函数更加清晰。</p><p id="853b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为此使用测试驱动开发(TDD)也是一个好主意，这有助于防止过度工程化。</p><p id="ea28" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Setters不适用于不可变类型。我们应该测试吸气剂吗？TDD教条主义者会说绝对不会，永远不会。鉴于这里的字段是原语，我倾向于同意。但是如果你想测试它们，那就去吧，不要在意你团队之外的任何教条主义者会怎么说。</p><p id="bb18" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">顺便说一下，<code class="fe le lf lg lh b">java.awt.Point</code>中的getters分别将<code class="fe le lf lg lh b">x</code>和<code class="fe le lf lg lh b">y</code>作为<code class="fe le lf lg lh b">double</code>返回，尽管这两个字段都是类型<code class="fe le lf lg lh b">int</code>。如果有一个好的理由，我还没有想出来。</p><p id="beea" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，我们需要覆盖<code class="fe le lf lg lh b">equals()</code>和<code class="fe le lf lg lh b">hashCode()</code>。您可以让您的IDE自动为您生成这些内容。但是那样的话，我们就错过了学习关于<code class="fe le lf lg lh b">java.awt.Point</code>的一些有趣的事情。因此，请在<code class="fe le lf lg lh b">awtredux.Point</code>中放入以下存根:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="36a5" class="lq lr it lh b gy ls lt l lu lv">    // STUB TO FAIL THE FIRST TEST<br/>    @Override<br/>    public boolean equals(Object obj) {<br/>        return false;<br/>    }<br/>    <br/>    // STUB TO FAIL THE FIRST TEST<br/>    @Override<br/>    public int hashCode() {<br/>        return 0;<br/>    }</span></pre><p id="5181" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我认为，下一步应该是参照平等测试。一个<code class="fe le lf lg lh b">Point</code>实例应该等于它自己。</p><p id="af1d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让你的IDE在测试包下的<code class="fe le lf lg lh b">awtredux</code>中创建<code class="fe le lf lg lh b">PointTest</code>。NetBeans可能会创建一些建议的测试。只要这些建议的测试都不会导致关于取消引用空指针的警告，您就可以暂时不去管它们。</p><p id="2cba" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">编写引用相等测试，看它是否失败，不管<code class="fe le lf lg lh b">obj</code>是什么，通过让<code class="fe le lf lg lh b">equals()</code>返回true来使它通过。</p><p id="4a86" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在继续进行<code class="fe le lf lg lh b">equals()</code>的其他测试之前，我将编写<code class="fe le lf lg lh b">toString()</code>的测试。不需要什么花哨的东西。它可以是类似于“(<em class="lx"> x </em>，<em class="lx"> y </em>)”的东西，其中<em class="lx"> x </em>和<em class="lx"> y </em>代表任意数字<code class="fe le lf lg lh b">coordX</code>和<code class="fe le lf lg lh b">coordY</code>。</p><p id="18c6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您希望我们的<code class="fe le lf lg lh b">Point.toString()</code>更像AWT中的那个，请相应地编辑下面的测试。</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="096c" class="lq lr it lh b gy ls lt l lu lv">    /**<br/>     * Test of toString(). Output may have spaces, they will be <br/>     * ignored for this test. <br/>     */<br/>    @Test<br/>    public void testToString() {<br/>        System.out.println("toString");<br/>        int x = 53;<br/>        int y = 229;<br/>        Point somePoint = new Point(x, y);<br/>        String expected = "(" + x + "," + y + ")";<br/>        String actual = somePoint.toString().replace(" ", "");<br/>        assertEquals(expected, actual);<br/>    }</span></pre><p id="fa72" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦<code class="fe le lf lg lh b">toString()</code>按照您想要的方式工作，编写一个测试，说明<code class="fe le lf lg lh b">Point</code>实例不应该被认为等于null。一定要用JUnit的<code class="fe le lf lg lh b">assertNotEquals()</code>，不要用<code class="fe le lf lg lh b">assertNotNull()</code>。</p><p id="18e8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您也可以使用调用<code class="fe le lf lg lh b">equals()</code>的普通Java断言，但是您的IDE可能会给你一个警告，这不值得得到一个警告，更不用说取消一个警告了。像“<code class="fe le lf lg lh b">assert somePoint != null</code>”这样简单的断言不会给我们想要的第一次失败。</p><p id="ef4a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">到目前为止，以下内容将足以通过<code class="fe le lf lg lh b">equals()</code>的测试，同时为我们接下来的几次测试保留第一次失败:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="0280" class="lq lr it lh b gy ls lt l lu lv">    @Override<br/>    public boolean equals(Object obj) {<br/>        return obj != null;<br/>    }</span></pre><p id="4fd9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下一个测试是确保一个<code class="fe le lf lg lh b">Point</code>实例不被认为等同于某个其他类的对象。我推荐用一些完全不相关的类，比如<code class="fe le lf lg lh b">SQLException</code>。我把写测试的任务交给你了。确保我们的<code class="fe le lf lg lh b">Point.equals()</code>被调用，而不是另一个类的<code class="fe le lf lg lh b">equals()</code>被调用。</p><p id="edd0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">测试当然会失败，因为<code class="fe le lf lg lh b">Point.equals()</code>只是检查<code class="fe le lf lg lh b">obj</code>不为空。我们需要更改它来检查<code class="fe le lf lg lh b">obj</code>的类型。</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="810b" class="lq lr it lh b gy ls lt l lu lv">    @Override<br/>    public boolean equals(Object obj) {<br/>        if (obj == null) {<br/>            return false;<br/>        }<br/>        return obj.getClass().equals(this.getClass());<br/>    }</span></pre><p id="0ef3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这给我们带来了关于<code class="fe le lf lg lh b">java.awt.Point</code>的一个有趣的点:它的<code class="fe le lf lg lh b">equals()</code>没有使用<code class="fe le lf lg lh b">getClass()</code>，据我所知，从JDK 1.0开始就已经有了。而是用<code class="fe le lf lg lh b">instanceof</code>。</p><p id="c6ee" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果<code class="fe le lf lg lh b">obj</code>不是<code class="fe le lf lg lh b">java.awt.Point</code>的实例，<code class="fe le lf lg lh b">Point2D.equals()</code>在<code class="fe le lf lg lh b">obj</code>上被调用。如果<code class="fe le lf lg lh b">obj</code>也不是<code class="fe le lf lg lh b">Point2D</code>的实例，则调用<code class="fe le lf lg lh b">Object.equals()</code>。它只是检查引用的相等性。</p><p id="63a4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我认为如果<code class="fe le lf lg lh b">obj</code>不是<code class="fe le lf lg lh b">Point2D</code>的实例，那么<code class="fe le lf lg lh b">Point2D.equals()</code>简单地返回false会更有意义。</p><p id="3496" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">回到我们的<code class="fe le lf lg lh b">awtredux.Point</code>，当<code class="fe le lf lg lh b">obj</code>是具有相同<em class="lx"> x </em>但不同<em class="lx"> y </em>的<code class="fe le lf lg lh b">Point</code>实例时，我们编写测试。你可以从这里接手。</p><p id="1f3c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">关于<code class="fe le lf lg lh b">java.awt.Point</code>的另一件奇怪的事情是它覆盖了<code class="fe le lf lg lh b">equals()</code>而不是<code class="fe le lf lg lh b">hashCode()</code>。<code class="fe le lf lg lh b">Point2D</code>中的<code class="fe le lf lg lh b">hashCode()</code>使用<code class="fe le lf lg lh b">Double.doubleToLongBits()</code>。但是因为嵌套类<code class="fe le lf lg lh b">Point2D.Double</code>，所以需要指定<code class="fe le lf lg lh b">java.lang.Double</code>。这有点荒谬。</p><p id="5b9c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">即便如此，我还是会在<code class="fe le lf lg lh b">Point2D.hashCode()</code>的<code class="fe le lf lg lh b">Point.hashCode()</code>中借鉴一两个想法。比如将<em class="lx"> x </em>的位乘以31，与<em class="lx"> y </em>的位异或。</p><p id="5840" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了确保我们的<code class="fe le lf lg lh b">Point.hashCode()</code>为不同的<code class="fe le lf lg lh b">Point</code>实例生成不同的哈希代码，我将编写一个测试，生成大约一百个随机的<code class="fe le lf lg lh b">Point</code>实例，将它们放在一个集合中，并将它们的哈希代码放在一个单独的集合中。这两个集合的大小应该相同。</p><p id="18e7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，<code class="fe le lf lg lh b">java.awt.Point</code>里的什么东西也应该在<code class="fe le lf lg lh b">awtredux.Point</code>里？由于后者的不变性，<code class="fe le lf lg lh b">setLocation()</code>程序是不必要的。除了它的<code class="fe le lf lg lh b">@Transient</code>注释外，<code class="fe le lf lg lh b">getLocation()</code>似乎是复制构造函数的一个不必要的替代。</p><p id="ef84" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">作为一个不可变类中的函数，<code class="fe le lf lg lh b">move()</code>沦为了无意义。不过，<code class="fe le lf lg lh b">translate()</code>可能会有用。下面是第一次测试失败的原因:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="0ee3" class="lq lr it lh b gy ls lt l lu lv">    // STUB TO FAIL THE FIRST TEST<br/>    public Point translate(int dx, int dy) {<br/>        return new Point();<br/>    }</span></pre><p id="16fa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第一个测试是:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="8cad" class="lq lr it lh b gy ls lt l lu lv">    @Test<br/>    public void testTranslate() {<br/>        int x = 522;<br/>        int y = -4309;<br/>        Point originalPoint = new Point(x, y);<br/>        int dx = -89;<br/>        int dy = 9417;<br/>        Point expected = new Point(x + dx, y + dy);<br/>        Point actual = originalPoint.translate(dx, dy);<br/>        assertEquals(expected, actual);<br/>    }</span></pre><p id="7b98" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你应该不难找到通过这次考试的方法。当然，假设你已经通过了<code class="fe le lf lg lh b">equals()</code>的所有测试。</p><p id="99ea" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我没有查看AWT中每个使用<code class="fe le lf lg lh b">Point</code>的类。我怀疑试图将我们对<code class="fe le lf lg lh b">Point</code>的更改集成到AWT中需要在IDE的指导下进行大量的重构。</p><p id="a4bf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我发表这篇文章之前，除了<code class="fe le lf lg lh b">Point</code>本身，我只看过<code class="fe le lf lg lh b">PointerInfo</code>。在Java 1.5中引入的<code class="fe le lf lg lh b">PointerInfo</code>看起来不需要任何<code class="fe le lf lg lh b">Point</code>突变能力。所以它不会受到我们的改变的影响。</p><p id="a8cd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我发表这篇文章后，看了一下<code class="fe le lf lg lh b">Component</code>。在那里，我发现了相当多的<code class="fe le lf lg lh b">Point</code>的用法，但是只有两次使用了通过直接字段访问变异的<code class="fe le lf lg lh b">Point</code>实例，没有一次使用了<code class="fe le lf lg lh b">move()</code>或<code class="fe le lf lg lh b">translate()</code>。</p><p id="8665" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这两种情况下，<code class="fe le lf lg lh b">Point</code>实例都是通过函数调用获得的，而不是作为调用者的参数。</p><p id="ef82" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，我发现了一个使用<code class="fe le lf lg lh b">setLocation()</code>的非常奇怪的例子，它接收一个<code class="fe le lf lg lh b">Point</code>实例作为参数。如果不为空，就对其进行变异并返回。显然这是为了避免堆分配，这是在<code class="fe le lf lg lh b">Component</code> Javadoc中经常提到的问题。</p><p id="878c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我重申，我们不会提议对JDK做任何改变。封装和不变性不会解决AWT的所有问题。但我确实认为这会有很大帮助。</p></div></div>    
</body>
</html>