<html>
<head>
<title>Making Piano Tiles with Unity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Unity制作钢琴瓦</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/making-piano-tiles-with-unity-5d4dc720889c?source=collection_archive---------9-----------------------#2022-01-12">https://levelup.gitconnected.com/making-piano-tiles-with-unity-5d4dc720889c?source=collection_archive---------9-----------------------#2022-01-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="bd1a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些类型的游戏非常受欢迎:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi kl"><img src="../Images/bc4278df2b691986b9f13cd6857645f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:776/1*ipv0N8df_QVTGT6qCPBt4w.gif"/></div></figure><p id="0ab6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">玩家点击从屏幕顶部出现的方块，如上面的GIF所示。每次点击都会播放特定歌曲的一小段，并增加分数。当一个音符被允许到达屏幕底部，或者在屏幕上某个不是音符的地方被点击时，播放器就会失败。</p><h1 id="9526" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">用于此项目的包</h1><ul class=""><li id="e7e4" class="lr ls iq jp b jq lt ju lu jy lv kc lw kg lx kk ly lz ma mb bi translated"><a class="ae mc" href="https://github.com/neuecc/UniRx" rel="noopener ugc nofollow" target="_blank"> UniRx </a> —用于反应式编程以及游戏数据模型和表示层之间的清晰分离。</li></ul><h1 id="b5c0" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">生成注释</h1><p id="45f2" class="pw-post-body-paragraph jn jo iq jp b jq lt js jt ju lu jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">我们用一个<code class="fe mg mh mi mj b">GameController</code>脚本在场景中创建了一个<code class="fe mg mh mi mj b">GameController</code>游戏对象(以实现singleton game manager模式)。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="0276" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<code class="fe mg mh mi mj b">SetDataForNoteGeneration()</code>方法中，我们用创建注释的数据初始化了一些变量。纸币的高度是屏幕高度的四分之一(宽度也是如此)。我们还计算了注释在最左边一列的垂直位置(<code class="fe mg mh mi mj b">noteSpawnStartPosX</code>)，因此我们可以操作这个值来为其他列创建注释。</p><p id="5758" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mg mh mi mj b">SpawnNotes()</code>方法是音符实际被创建的地方。我们创建一个变量(<code class="fe mg mh mi mj b">noteSpawnStartPosY</code>)，用来为新行中产生的注释设置垂直位置。<code class="fe mg mh mi mj b">lastSpawnedNote</code>是一个序列化字段，它被设置为我们在场景中创建的游戏对象。我们使用这个对象来直观地确定初始音符组的垂直位置。在<code class="fe mg mh mi mj b">GetRandomIndex()</code>方法中，我们生成一个随机数来为每个可见的衍生注释设置列。<code class="fe mg mh mi mj b">while</code>循环确保没有两个连续的音符在同一列。</p><p id="ae02" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如您在<code class="fe mg mh mi mj b">SpawnNotes()</code>的内部<code class="fe mg mh mi mj b">for</code>循环中看到的，我们实际上为每行生成了四个音符。一组中的四个音符的垂直位置是相同的，但是水平位置根据音符的列而改变。基于我们从<code class="fe mg mh mi mj b">GetRandomIndex()</code>获得的值，我们在每行中只显示一个音符。</p><p id="ee04" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们在编辑器中分配给<code class="fe mg mh mi mj b">notePrefab</code>的预设对象有一个附加的<code class="fe mg mh mi mj b">Note</code>组件脚本，所以我们创建的每个注释也有这个脚本。为了使每行中只有一个注释可见，我们设置了一个在这个脚本中创建的<code class="fe mg mh mi mj b">Visible</code>属性。我们来看看<code class="fe mg mh mi mj b">Note.cs</code>:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="3dc7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们在场景中创建了一个不可见的对象，并在将它放在摄像机上方之后，给它附加了一个<code class="fe mg mh mi mj b">SpawnNotesTrigger</code>脚本。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="430e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们一次产生一组20个音符。当最近产生的集合的第20个音符达到<code class="fe mg mh mi mj b">SpawnNotesTrigger</code>时，我们产生另一个集合。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi kl"><img src="../Images/731bd965d4b8dbe8c6a3522b8128020e.png" data-original-src="https://miro.medium.com/v2/resize:fit:776/1*fT_sop6burFApHLDt_oOVg.gif"/></div></figure><h1 id="5dc3" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">检测抽头</h1><p id="5dd3" class="pw-post-body-paragraph jn jo iq jp b jq lt js jt ju lu jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">我们在<code class="fe mg mh mi mj b">GameController.cs</code>使用2D射线检测笔记被敲击的时间。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="69b8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我们的玩家点击一个可见的音符时，我们播放一个彩色动画，以表明它已经被播放过了。如果纸条是看不见的，那么我们播放不同颜色的动画并结束游戏。游戏结束时音符停止移动。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mk ml l"/></div></figure><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi kl"><img src="../Images/385ffc410374f9297f3ee4ee47d19bd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:776/1*eXTclYfk97E4XN8v__tkJQ.gif"/></div></figure><h1 id="7671" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">检测未敲击的音符何时将要离开屏幕</h1><p id="ad48" class="pw-post-body-paragraph jn jo iq jp b jq lt js jt ju lu jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">当用户没有点击的笔记将要离开屏幕时，我们结束游戏:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi kl"><img src="../Images/63e4659a44356565458b5e7e8c9dbda2.png" data-original-src="https://miro.medium.com/v2/resize:fit:776/1*nVLUHolRY5ICm6LIy6Kfzg.gif"/></div></figure><p id="23e4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为此，我们在场景中创建了另一个不可见的游戏对象(<code class="fe mg mh mi mj b">OutOfScreenTrigger</code>)并放在摄像机的正下方，我们给它附加了一个脚本<code class="fe mg mh mi mj b">OutOfScreenTrigger.cs</code>。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mk ml l"/></div></figure><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="7bcf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个笔记只会在它即将离开屏幕时遇到这个对象，此时我们会检查它对玩家是否仍然可见，是否还没有被点击，如果是，我们就结束游戏。</p><h1 id="a6af" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">确保音符的拍子顺序</h1><p id="5e89" class="pw-post-body-paragraph jn jo iq jp b jq lt js jt ju lu jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">我们还需要确保一个可见的音符只有在它之前的所有音符都被演奏过之后才能被演奏。我们通过在<code class="fe mg mh mi mj b">GameController.cs</code>中根据演奏顺序给所有音符分配一个ID来实现这个目的。当一个音符被敲击时，我们使用ID的值来检查最近弹奏的音符是否出现在被敲击的音符之前。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mk ml l"/></div></figure><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mk ml l"/></div></figure><h1 id="fe93" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">播放音乐</h1><p id="e2ca" class="pw-post-body-paragraph jn jo iq jp b jq lt js jt ju lu jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">现在是时候让一首歌曲在一个音符被轻敲时播放了。为此，首先，我们在场景中创建一个新的游戏对象，并为其附加一个<code class="fe mg mh mi mj b">Audio Source</code>组件。我们将<code class="fe mg mh mi mj b">AudioClip</code>设置为我们想要在每个音符被敲击时分段播放的歌曲。在这个项目中，使用了托弗·莫尔和亚历克斯·埃莱娜的<em class="mm">小时数</em>——从YouTube音频库中获得。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="09b6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当一个音符被轻敲时，我们播放歌曲很短的时间(这里是0.8秒)，然后暂停播放，直到下一个音符被轻敲。</p><p id="8a79" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<code class="fe mg mh mi mj b">GameController.SpawnNotes()</code>中，我们使用当前的歌曲播放位置来决定接下来要产生多少音符。例如，如果歌曲长度为300秒，回放位置在295秒，那么我们将只有5秒的音符可以播放。</p><h1 id="b346" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">在GitHub上获得完整的源代码</h1><p id="507b" class="pw-post-body-paragraph jn jo iq jp b jq lt js jt ju lu jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">本文展示了这类游戏背后的核心逻辑。你可以在<a class="ae mc" href="https://github.com/tariibaba/Piano-Tiles" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得该项目的完整源代码。</p><p id="9c11" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对这篇文章有什么想法吗？请在下面的评论中留下您的反馈。</p></div></div>    
</body>
</html>