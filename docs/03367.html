<html>
<head>
<title>How to make your code run faster with data parallelism and std::async</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何利用数据并行和std::async让您的代码运行得更快</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-make-your-code-run-faster-with-data-parallelism-and-std-async-1f76e7befb50?source=collection_archive---------32-----------------------#2020-05-04">https://levelup.gitconnected.com/how-to-make-your-code-run-faster-with-data-parallelism-and-std-async-1f76e7befb50?source=collection_archive---------32-----------------------#2020-05-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/ec3878316a98982580dc2a2f898acc84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d7q0xJWSR2ETDn4FHab1tA.png"/></div></div></figure><p id="123f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本系列的第二部分，我们实现了一种生成给定张量的所有索引的方法。如果你还没看过《T2》第一部和《T4》第二部，那就看看吧。</p><p id="c238" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以前的方法是迭代输入张量，为每个元素生成完整的索引，并将这些索引逐维添加到输出缓冲区。这意味着在每次迭代中(对于每个输入张量的元素),输出缓冲区的所有行都被修改。有一种不同的方法来解决这个问题，但在深入研究之前，让我们看看我们正在研究的算法的一些简单输出，并尝试找出一些模式。</p><p id="01d9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们考虑一个带有<code class="fe kx ky kz la b">Shape{2,2,3,3}</code>的4D张量。对于这样一个张量，包含一个完整指标集的非零算子的输出是:</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lb"><img src="../Images/2ffbf2948c7f4db260b08c48e58cb656.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JqBFWNZ-zs1dwCn8AenUUA.png"/></div></div></figure><p id="2247" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第一列包含输入形状的维度，其余部分是实际输出。一些需要注意的事项:</p><ul class=""><li id="f5e7" class="lg lh iq ka b kb kc kf kg kj li kn lj kr lk kv ll lm ln lo bi translated">每行对应于输入形状的一个维度</li><li id="1851" class="lg lh iq ka b kb lp kf lq kj lr kn ls kr lt kv ll lm ln lo bi translated">如果给定维度的值是<strong class="ka ir"> <em class="lu"> N </em> </strong>，对应的输出行包含以下范围内的值:<code class="fe kx ky kz la b">0, 1, 2, ..., N-1</code> —姑且称之为<em class="lu">允许值</em></li><li id="a5d2" class="lg lh iq ka b kb lp kf lq kj lr kn ls kr lt kv ll lm ln lo bi translated">每行包含一个或多个子范围，跨越该行的所有允许值<em class="lu"/></li></ul><p id="10fa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">给定这3个观察值，我们可以尝试以逐行方式实现非零输出生成。换句话说，我们不会生成输出的垂直切片。相反，我们可以逐行生成它们，看看这对算法的性能是否有任何影响。</p><p id="2e75" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了做到这一点，我们应该再看一下示例输出，并弄清楚这些值是如何变化的。让我们看看每一行。</p><p id="3bc5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第一行只包含0和1，它们是维等于2的允许值。50%的行包含0，50%的行包含1，所有这些值形成一个子范围，其长度等于第一个输出行的长度。第二行也可以只包含0和1，但是这次有两个子范围，每个子范围跨越输出行的一半。第三行由4个子范围组成，每个包含0、1和2。最后一行类似，但它包含12个子范围。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lb"><img src="../Images/21f53f568172591306fc883eea7d7186.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6IqEuZyrEjHRBVDVrglCKg.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated">张量形状{2，2，3，3}的非零输出的子范围</figcaption></figure><p id="2560" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一句话中的行方式是:为给定的行生成子范围，然后重复它<em class="lu"> K </em>次，其中<em class="lu"> K =行长度/子范围长度</em>。但是我们可以用不同的方法计算K。对于第一个输出行，它总是1。对于所有其他行，它是与前面的行匹配的输入形状尺寸的乘积。STL中有一个理想的函数(C++17中添加的)我们可以用来计算它——<a class="ae kw" href="https://en.cppreference.com/w/cpp/algorithm/exclusive_scan" rel="noopener ugc nofollow" target="_blank">STD::exclusive _ scan</a>。在我们的示例中，输出行的<em class="lu"> K </em>的值将是:<code class="fe kx ky kz la b">1, 2, 4, 12</code>并且这些值匹配子范围在每行中重复的次数。有了这些数字，我们可以计算子区间的长度:<code class="fe kx ky kz la b">36, 18, 9, 3</code>。</p><p id="c374" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后要搞清楚的是子范围生成方案的方式。事实上，我们只需要为子范围创建一个vector，并为其添加值。附加值最初等于零，经过几次迭代后增加。多久一次？经过<code class="fe kx ky kz la b">row_length / (dimension * K)</code>的反复。</p><p id="9484" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">大部分代码与本系列的第2部分相同，所以我将向您展示使用新的<code class="fe kx ky kz la b">generate_rows()</code>方法的非零类的新实现:</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="lz ma l"/></div></figure><h1 id="1bc0" class="mb mc iq bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">测试</h1><p id="e504" class="pw-post-body-paragraph jy jz iq ka b kb mz kd ke kf na kh ki kj nb kl km kn nc kp kq kr nd kt ku kv ij bi translated">我还准备了一个脚本，可以自动化性能测量，运行测试1次以上，并计算平均值和标准偏差。它是用JavaScript编写的，所以您需要安装node.js才能使用它:</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="06fe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要对我们之前处理的7D形状执行10次“a.out”二进制:</p><pre class="lc ld le lf gt ne la nf ng aw nh bi"><span id="77f9" class="ni mc iq la b gy nj nk l nl nm">node tester.js a.out 10 "10 10 10 10 10 10 10"</span></pre><p id="cb6e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我首先对前一篇文章中的代码执行了它。对于最不理想的情况(没有预分配)，我得到:</p><pre class="lc ld le lf gt ne la nf ng aw nh bi"><span id="4ca7" class="ni mc iq la b gy nj nk l nl nm">Number of iterations: 10<br/>Average time: <strong class="la ir">764 ms</strong><br/>Standard dev: 6.04 ms</span></pre><p id="675a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用预分配:</p><pre class="lc ld le lf gt ne la nf ng aw nh bi"><span id="b685" class="ni mc iq la b gy nj nk l nl nm">Number of iterations: 10<br/>Average time: <strong class="la ir">325 ms</strong><br/>Standard dev: 6.21 ms</span></pre><p id="0a91" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，对于本文中描述的行方式:</p><pre class="lc ld le lf gt ne la nf ng aw nh bi"><span id="02d1" class="ni mc iq la b gy nj nk l nl nm">Number of iterations: 10<br/>Average time: <strong class="la ir">333 ms</strong><br/>Standard dev: 3.05 ms</span></pre><p id="1bb2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这其实是一个令人惊讶的结果。我希望逐行方法提供更多的缓存局部性，并且这个版本会更快。我决定使用另一种数据类型来表示维度(在两种实现中)并重复测试。我已经从<code class="fe kx ky kz la b">uint64_t</code>换到<code class="fe kx ky kz la b">uint32_t</code>了。预分配的旧方法给了我这个:</p><pre class="lc ld le lf gt ne la nf ng aw nh bi"><span id="7a2c" class="ni mc iq la b gy nj nk l nl nm">Number of iterations: 10<br/>Average time: <strong class="la ir">219 ms</strong><br/>Standard dev: 4.50 ms</span></pre><p id="ea87" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">行方式:</p><pre class="lc ld le lf gt ne la nf ng aw nh bi"><span id="01ea" class="ni mc iq la b gy nj nk l nl nm">Number of iterations: 10<br/>Average time: <strong class="la ir">207 ms</strong><br/>Standard dev: 1.36 ms</span></pre><p id="89c3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用这种数据类型，速度更快，但差别只有8%。我没有放弃，又进行了一次比较——多了一个等于10的维度。这为我们提供了10倍多的索引生成量:</p><pre class="lc ld le lf gt ne la nf ng aw nh bi"><span id="b2be" class="ni mc iq la b gy nj nk l nl nm">node tester.js a.out 10 "10 10 10 10 10 10 10 10"</span></pre><p id="9f7e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">旧方法:</p><pre class="lc ld le lf gt ne la nf ng aw nh bi"><span id="823e" class="ni mc iq la b gy nj nk l nl nm">Number of iterations: 10<br/>Average time: <strong class="la ir">2732 ms</strong><br/>Standard dev: 81.84 ms</span></pre><p id="ae6d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">行方式:</p><pre class="lc ld le lf gt ne la nf ng aw nh bi"><span id="4987" class="ni mc iq la b gy nj nk l nl nm">Number of iterations: 10<br/>Average time: <strong class="la ir">2209 ms</strong><br/>Standard dev: 5.60 ms</span></pre><p id="bde8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那就<strong class="ka ir">好19% </strong>了。两种方法之间的标准偏差也相差10倍。这意味着逐行算法在更均匀、更可预测的时间间隔内产生结果。</p><p id="667a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这让我想到，当输入张量的秩足够大时，我所考虑的缓存局部性可能会有所不同。这是因为在输出中有更多的输出行，因此在将结果添加到输出时从一行跳到另一行的前一种方法中有更多的缓存未命中。我做的最后一个测试是这样的:</p><pre class="lc ld le lf gt ne la nf ng aw nh bi"><span id="8c0c" class="ni mc iq la b gy nj nk l nl nm">node tester.js 10 a.out "5 2 5 2 5 2 5 2 5 2 5 2 5 2"</span></pre><p id="2fca" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这里，我测试了一个与之前的7D张量具有相同元素数量的14D输入张量:<code class="fe kx ky kz la b">Shape{10,10,10,10,10,10,10}</code> —元素的数量是张量形状中所有维度的乘积。传递给旧方法的14D输入的结果是:</p><pre class="lc ld le lf gt ne la nf ng aw nh bi"><span id="f983" class="ni mc iq la b gy nj nk l nl nm">Number of iterations: 10<br/>Average time: <strong class="la ir">19671 ms</strong><br/>Standard dev: 22.31 ms</span></pre><p id="72c0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这一次，行方式显示了它的优越性，产生了一个好80%的结果(换句话说，快了5倍):</p><pre class="lc ld le lf gt ne la nf ng aw nh bi"><span id="ab4b" class="ni mc iq la b gy nj nk l nl nm">Number of iterations: 10<br/>Average time: <strong class="la ir">3899 ms</strong><br/>Standard dev: 1.58 ms</span></pre><h1 id="f567" class="mb mc iq bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">数据并行性和标准::异步</h1><p id="0dcf" class="pw-post-body-paragraph jy jz iq ka b kb mz kd ke kf na kh ki kj nb kl km kn nc kp kq kr nd kt ku kv ij bi translated">我们还可以采取一个步骤来加速执行。给你一个提示，我将展示我的系统监视器在一次运行中记录的内容:</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nn"><img src="../Images/8ec130bfe6f7bb4a1147b220b87aa79b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WY_isjq7FfKqIuCzSQPecA.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated">单核非零指数生成</figcaption></figure><p id="9534" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这真是浪费资源。通过行方式，我们可以非常轻松地应用数据并行性概念。在这种新方法中，我们逐行生成非零输出。输出行是独立的，可以在没有任何重叠的情况下进行处理。这是数据并行性的完美应用——我们可以在可用的CPU之间分配工作(另外——没有任何同步)。</p><p id="cba7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里，我们还将在生成开始之前预分配内存。我们将计算生成给定行所需的所有必要数据，然后将其封装在lambda中，并简单地异步执行它。没有线程或线程池，没有互斥，没有任务系统。STL中的一个简单函数。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="083d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在循环之前，我们为<code class="fe kx ky kz la b">std::future</code>对象创建一个容器。这些表示将填充各个输出行的任务。<code class="fe kx ky kz la b">std::future</code>是由<code class="fe kx ky kz la b">std::async</code>返回的类型。它是一种句柄，允许我们监控异步操作的状态并访问值(当它可用时)。在这种情况下，我们不会返回任何东西，而是将缓冲区的句柄传递给异步操作，并直接填充它。这就是为什么期货被<code class="fe kx ky kz la b">void</code>参数化。</p><p id="625b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">lambda捕获列表现在包含了我们需要捕获的对象的副本。这是因为它们是只在for循环迭代结束之前存在的局部变量。最后一个元素通过引用捕获——这是属于非零类<code class="fe kx ky kz la b">_results</code>成员的输出行。</p><p id="4dd4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，在for循环之后，我们必须创建一个同步点，在那里我们等待所有任务完成。<code class="fe kx ky kz la b">std::future::wait()</code>方法正在阻塞，这将使代码“冻结”,直到整个异步生成完成。仅此而已。让我们运行7D测试:</p><pre class="lc ld le lf gt ne la nf ng aw nh bi"><span id="0750" class="ni mc iq la b gy nj nk l nl nm">Number of iterations: 10<br/>Average time: <strong class="la ir">109 ms</strong><br/>Standard dev: 2.36 ms</span></pre><h1 id="bbd7" class="mb mc iq bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">性能比较</h1><p id="8a3a" class="pw-post-body-paragraph jy jz iq ka b kb mz kd ke kf na kh ki kj nb kl km kn nc kp kq kr nd kt ku kv ij bi translated">这是我实验的最终结果。我已经收集了尺寸表示为<code class="fe kx ky kz la b">int32_t</code>的数字。首先是7D张量比较:</p><pre class="lc ld le lf gt ne la nf ng aw nh bi"><span id="30f1" class="ni mc iq la b gy nj nk l nl nm">$ node tester.js a.out 10 "10 10 10 10 10 10 10"</span><span id="d201" class="ni mc iq la b gy no nk l nl nm">// the old approach without pre-allocation<br/>Average time: <strong class="la ir">434 ms</strong><br/>// the old approach with pre-allocation<br/>Average time: <strong class="la ir">219 ms<br/></strong>// the row-wise approach<strong class="la ir"><br/></strong>Average time: <strong class="la ir">207 ms<br/></strong>// the row-wise approach + std::async<br/>Average time: <strong class="la ir">109 ms</strong></span></pre><p id="e009" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">8D张量:</p><pre class="lc ld le lf gt ne la nf ng aw nh bi"><span id="12b9" class="ni mc iq la b gy nj nk l nl nm">$ node tester.js a.out 10 "10 10 10 10 10 10 10 10"</span><span id="ad9e" class="ni mc iq la b gy no nk l nl nm">// the old approach without pre-allocation<br/>Average time: <strong class="la ir">4873 ms</strong><br/>// the old approach with pre-allocation<br/>Average time: <strong class="la ir">2805 ms<br/></strong>// the row-wise approach<strong class="la ir"><br/></strong>Average time: <strong class="la ir">2225 ms<br/></strong>// the row-wise approach + std::async<br/>Average time: <strong class="la ir">1087 ms</strong></span></pre><p id="2101" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">与7D示例具有相同元素计数的14D张量:</p><pre class="lc ld le lf gt ne la nf ng aw nh bi"><span id="6201" class="ni mc iq la b gy nj nk l nl nm">$ node tester.js a.out 10 "5 2 5 2 5 2 5 2 5 2 5 2 5 2 5 2"</span><span id="a7bb" class="ni mc iq la b gy no nk l nl nm">// the old approach without pre-allocation<br/>Average time: <strong class="la ir">23785 ms</strong><br/>// the old approach with pre-allocation<br/>Average time: <strong class="la ir">19671 ms<br/></strong>// the row-wise approach<strong class="la ir"><br/></strong>Average time: <strong class="la ir">3899 ms<br/></strong>// the row-wise approach + std::async<br/>Average time: <strong class="la ir">1412 ms</strong></span></pre><p id="dfde" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">1.4秒对19.7秒，快了14倍！另外，所有内核都很忙:</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi np"><img src="../Images/5e66b59d9c0edb277df58fbc441f3540.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I9H1ATRHIWd3fLbT6Aj-Zw.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated">标准::异步CPU利用率</figcaption></figure><h1 id="3742" class="mb mc iq bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">摘要</h1><p id="27ed" class="pw-post-body-paragraph jy jz iq ka b kb mz kd ke kf na kh ki kj nb kl km kn nc kp kq kr nd kt ku kv ij bi translated">看到那些结果后我得出了一个结论。有时候重新审视你对问题的解决方案是值得的。我认为从您考虑将要处理的数据的角度来考虑您的问题是一个好主意。要弄清楚的是元素之间是否有任何关系。如果没有，你就有机会实现数量级的加速。只是不要太兴奋，记住阿姆达尔定律。</p><p id="90af" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">非常感谢您的阅读！</p><h1 id="0f43" class="mb mc iq bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">资源</h1><p id="c1aa" class="pw-post-body-paragraph jy jz iq ka b kb mz kd ke kf na kh ki kj nb kl km kn nc kp kq kr nd kt ku kv ij bi translated">您可以在我的github gists中找到完整的代码:</p><div class="nq nr gp gr ns nt"><a href="https://gist.github.com/tomdol" rel="noopener  ugc nofollow" target="_blank"><div class="nu ab fo"><div class="nv ab nw cl cj nx"><h2 class="bd ir gy z fp ny fr fs nz fu fw ip bi translated">汤姆多尔的要点</h2><div class="oa l"><h3 class="bd b gy z fp ny fr fs nz fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="ob l"><p class="bd b dl z fp ny fr fs nz fu fw dk translated">gist.github.com</p></div></div><div class="oc l"><div class="od l oe of og oc oh jw nt"/></div></div></a></div></div></div>    
</body>
</html>