<html>
<head>
<title>Building Faster Apps with Vue</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Vue构建更快的应用</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/building-faster-apps-with-vue-3d9a4302061d?source=collection_archive---------2-----------------------#2020-01-31">https://levelup.gitconnected.com/building-faster-apps-with-vue-3d9a4302061d?source=collection_archive---------2-----------------------#2020-01-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6cf1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解组件通信、路由、Axios、优化和部署</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/21c61580c0cad7602bbedbb2c2570f28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uZYtAESM6J3bW3XS"/></div></div></figure><p id="7a56" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi lq translated">avaScript是现代web应用程序的灵魂。它是web应用前端开发的核心组件。市场上有各种各样的JavaScript框架。其中一个流行的框架是<strong class="kw iu"> Vue </strong>。</p><p id="5d51" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Vue是一个用于构建优秀用户界面的渐进式框架。核心库主要集中在视图层，根据需要很容易将不同的其他库集成到其中。此外，Vue能够实现复杂的单页面应用程序(SPA)以及现代工具和广泛可用的支持库</p><p id="ee70" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这篇文章中，我们将创建一个简单的应用程序来创建和管理任务。此外，我们还将了解Vue的一些强大功能，例如:<br/> 1。路由<br/> 2。组件基础知识<br/> 3。组件间通信<br/> 4。Axios库和后端连接配置<br/> 5。优化<br/> 6。对接和部署</p><p id="d37f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但是在开始上述所有主题之前，让我们首先按照下面给出的步骤创建和设置用于管理任务的基础项目</p><ol class=""><li id="3bc2" class="lz ma it kw b kx ky la lb ld mb lh mc ll md lp me mf mg mh bi translated">使用命令<code class="fe mi mj mk ml b">vue create notes-app</code>用Vue CLI 3创建一个项目</li><li id="08f8" class="lz ma it kw b kx mm la mn ld mo lh mp ll mq lp me mf mg mh bi translated">将依赖库添加到<strong class="kw iu"> package.json </strong>中，如下所示:</li></ol><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">package.json</figcaption></figure><p id="fa90" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">3.使用命令<code class="fe mi mj mk ml b">npm install</code>安装添加的依赖项</p><p id="92f9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一旦一切都设置好了，让我们进入下一步。</p><h2 id="a6ef" class="mx my it bd mz na nb dn nc nd ne dp nf ld ng nh ni lh nj nk nl ll nm nn no np bi translated">按指定路线发送</h2><p id="9be3" class="pw-post-body-paragraph ku kv it kw b kx nq ju kz la nr jx lc ld ns lf lg lh nt lj lk ll nu ln lo lp im bi translated">路由是Vue提供的重要功能之一。它可以通过安装<code class="fe mi mj mk ml b">vue-router</code>集成到一个Vue应用中。Vue-router是Vue的官方路由器。它为我们提供了一系列功能，例如:<br/> *嵌套路由/视图映射<br/> *模块化、基于组件的路由器配置<br/> *路由参数、查询、通配符<br/> *由Vue.js过渡系统支持的视图过渡效果<br/> *细粒度导航控制<br/> *具有自动活动CSS类的链接<br/> * HTML5历史模式或哈希模式，在IE9中具有自动回退功能<br/> *可定制的滚动行为</p><p id="8cfd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">要在我们的应用程序中实现路由，请在router文件夹中创建一个名为<strong class="kw iu"> index.js </strong>的文件，并向其中添加以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">Route: index.js</figcaption></figure><p id="9c01" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">观察routes对象，它包含我们的应用程序支持的所有路由，并以嵌套路由的方式实现。</p><p id="270d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe mi mj mk ml b">children</code>对象包含所有底层路线，这些路线将被加载到仪表板布局的顶部。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">DashboardLayout.vue</figcaption></figure><p id="7191" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">上面显示的<code class="fe mi mj mk ml b">router-view</code>标签是最重要的标签，因为它就像一个容器，所有与路线匹配的组件都将在其中呈现。</p><h2 id="3ff5" class="mx my it bd mz na nb dn nc nd ne dp nf ld ng nh ni lh nj nk nl ll nm nn no np bi translated">组件基础</h2><p id="497b" class="pw-post-body-paragraph ku kv it kw b kx nq ju kz la nr jx lc ld ns lf lg lh nt lj lk ll nu ln lo lp im bi translated">组件是Vue的核心特性，它为我们提供了模块化的方法，使用这种方法我们可以将DOM分成几个小组件，这些组件可以在整个应用程序中重用。</p><p id="8d87" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在设计一个组件的时候，我们应该考虑一些重要的事情，以使它具有可伸缩性和可重用性。识别可以作为组件分离的相关功能的单个单元。<br/> 2。不要用不相关的功能重载组件。<br/> 3。仅将内部使用的代码添加到组件中，例如，默认数据绑定，如年份、性别等。<br/> 4。不要将代码添加到实现发生变化的组件中，例如API调用等。</p><p id="ccf1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">组件的简单例子是<code class="fe mi mj mk ml b">NavBar</code>，它只包含与导航项目相关的DOM。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">导航条. vue</figcaption></figure><p id="2aef" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">DashboardLayout.vue中使用了上述组件，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">DashboardLayout.vue</figcaption></figure><h2 id="3df3" class="mx my it bd mz na nb dn nc nd ne dp nf ld ng nh ni lh nj nk nl ll nm nn no np bi translated">组件间通信</h2><p id="ca49" class="pw-post-body-paragraph ku kv it kw b kx nq ju kz la nr jx lc ld ns lf lg lh nt lj lk ll nu ln lo lp im bi translated">在任何web应用程序中，数据应该以正确的方式流动，以便可以有效地操作和管理，这一点非常重要。</p><p id="b5f4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在组件化方法中，当我们将DOM /代码分成几个小块时，<strong class="kw iu">我们如何传递和处理被不同组件使用的数据</strong>？这就是组件间通信的由来。</p><p id="1254" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">使用<br/> 1，可以通过三种方式实现Vue中的组件间通信。<strong class="kw iu">道具</strong>:当<strong class="kw iu">父</strong>子<br/> 2有通信流时使用。<strong class="kw iu"> $emit(): </strong>当<strong class="kw iu">子节点到</strong>父节点<br/> 3之间存在通信流时使用。<strong class="kw iu"> EventBus: </strong>主要用在组件之间有深层嵌套的时候，或者我们想在任何组件之间全局实现发布/订阅事件模型的时候。</p><p id="6940" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了理解组件间通信的概念，让我们添加两个组件</p><ul class=""><li id="3e6e" class="lz ma it kw b kx ky la lb ld mb lh mc ll md lp nv mf mg mh bi translated"><code class="fe mi mj mk ml b"><strong class="kw iu">Add</strong></code>:该组件将用于添加新任务以及编辑现有任务。</li><li id="5fee" class="lz ma it kw b kx mm la mn ld mo lh mp ll mq lp nv mf mg mh bi translated"><code class="fe mi mj mk ml b"><strong class="kw iu">NoteViewer</strong></code>:这个组件将用来显示一个单独的注释。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">Add.vue</figcaption></figure><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">NoteViewer.vue</figcaption></figure><p id="0fc8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，我们已经创建了组件，仔细观察两个组件的<code class="fe mi mj mk ml b"><strong class="kw iu">script</strong></code>部分。</p><p id="4606" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在<code class="fe mi mj mk ml b"><strong class="kw iu">props</strong></code>下，我们已经声明了一些对象及其类型。这些是我们将传递给这个组件的对象，当我们实际使用它进入某个页面时。</p><p id="5efc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">另外，观察<code class="fe mi mj mk ml b"><strong class="kw iu">$emit()</strong></code>函数，我们已经生成了一个事件来将数据传递回父组件。</p><p id="ae9c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们看看如何使用上面创建的组件。将数据传递给这些组件，并侦听来自这些组件的事件，以将数据返回到Home.vue中，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">Home.vue</figcaption></figure><p id="0c25" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，如果我们仔细看看，名为<code class="fe mi mj mk ml b"><strong class="kw iu">note-editor</strong></code>的Add.vue被重用了两次，一次是用于<strong class="kw iu">添加</strong>注释，另一次是用于<strong class="kw iu">更新</strong>注释。</p><p id="8756" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">此外，我们通过使用<code class="fe mi mj mk ml b">v-for</code>属性遍历从数据库中获取的一系列注释来扩展<code class="fe mi mj mk ml b"><strong class="kw iu">note-viewer</strong></code>组件。</p><p id="245a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">可以观察到的另一点是<code class="fe mi mj mk ml b"><strong class="kw iu">note-editor</strong></code>标签中的<code class="fe mi mj mk ml b"><a class="ae nw" href="http://twitter.com/cancel" rel="noopener ugc nofollow" target="_blank"><strong class="kw iu">@cancel</strong></a></code>事件，在重用同一组件时，对于添加操作和更新操作，该事件的处理是不同的。</p><pre class="kj kk kl km gt nx ml ny nz aw oa bi"><span id="b2d4" class="mx my it ml b gy ob oc l od oe">&lt;!-- Add Task --&gt;<br/>&lt;note-editor v-show="enableAddNote"<br/>:key="enableAddNote"<br/>@add="addNote"<br/><strong class="ml iu">@cancel="disableAdd"</strong> /&gt;</span><span id="ef35" class="mx my it ml b gy of oc l od oe">&lt;!-- Update Task --&gt;<br/>&lt;note-editor v-show="!note.viewMode"<br/>:add-mode="false"<br/>:note="note"<br/>@update="updateNote"<br/><strong class="ml iu">@cancel="cancelUpdate(note)"</strong> /&gt;</span></pre><p id="7ada" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这就是我们如何避免可伸缩性问题的方法，当有机会改变实现时，通过将事件暴露在组件之外。</p><p id="d5d4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们已经将数据动态地注入到两个组件中，例如<code class="fe mi mj mk ml b"><strong class="kw iu">note-viewer</strong></code>标签中的<code class="fe mi mj mk ml b"><strong class="kw iu">:note</strong></code>属性。</p><p id="c1ee" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">就是这样。现在我们的组件可以来回传递数据。</p><h2 id="bfac" class="mx my it bd mz na nb dn nc nd ne dp nf ld ng nh ni lh nj nk nl ll nm nn no np bi translated">Axios库和配置</h2><p id="11f2" class="pw-post-body-paragraph ku kv it kw b kx nq ju kz la nr jx lc ld ns lf lg lh nt lj lk ll nu ln lo lp im bi translated">Axios是一个基于Promise的库，用于调用API并向其发送/接收数据。</p><p id="fda3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">它是如此强大和安全，以至于它可以提供客户端支持来防止XSRF攻击、请求/响应拦截器、转换请求/响应数据、取消请求等。</p><p id="61d4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们将Axios创建并配置为一个库，这样我们就不需要在每次使用时都导入它。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">Axios: index.js</figcaption></figure><p id="e154" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在<strong class="kw iu"> main.js </strong>中，添加响应拦截器，以便在应用程序中使用之前从API响应中过滤数据和错误，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk translated">main.js中的Axios拦截器实现</figcaption></figure><p id="6b71" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，初始化<strong class="kw iu"> main.js </strong>中的全局变量<code class="fe mi mj mk ml b">$http</code>，如下所示，这样就可以通过vue实例在整个应用程序中访问它。</p><pre class="kj kk kl km gt nx ml ny nz aw oa bi"><span id="e06b" class="mx my it ml b gy ob oc l od oe">import HTTP from "./axios";<br/><strong class="ml iu">Vue.prototype.$http = HTTP;</strong></span></pre><p id="9985" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">就是这样。现在，我们已经准备好进行API调用，如下所示:</p><pre class="kj kk kl km gt nx ml ny nz aw oa bi"><span id="c4aa" class="mx my it ml b gy ob oc l od oe">const data = await this.$http.get("notes/getall");</span></pre><h2 id="30e6" class="mx my it bd mz na nb dn nc nd ne dp nf ld ng nh ni lh nj nk nl ll nm nn no np bi translated">最佳化</h2><p id="0045" class="pw-post-body-paragraph ku kv it kw b kx nq ju kz la nr jx lc ld ns lf lg lh nt lj lk ll nu ln lo lp im bi translated">让我们假设我们的应用程序已经有了数百个组件和视图。</p><p id="2333" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这将影响应用程序的加载时间，因为整个应用程序将以JavaScript的形式一次性下载到浏览器中。</p><p id="6ab7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这样的时候，<br/> 1。我们如何防止加载当前没有使用的组件和视图？<br/> 2。我们如何减少可下载单元的大小？<br/> 3。我们如何改善装载时间？</p><p id="f683" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">作为一个解决方案，我们可以一次性加载基础应用程序，并通过修改路由器按需加载组件和视图，如下所示</p><pre class="kj kk kl km gt nx ml ny nz aw oa bi"><span id="8a85" class="mx my it ml b gy ob oc l od oe">{<br/>path: "/notes",<br/>name: "Notes",<br/>component: () =&gt;<br/>import(<strong class="ml iu">/* webpackChunkName: "home" */</strong> "../views/Home.vue")<br/>}<br/>// <em class="og">Observe the /* webpackChunkName: "home" */</em></span></pre><p id="0102" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这将生成一个单独的块([view])。[哈希]。js ),当访问该路由时，该路由是延迟加载的。</p><h2 id="4cb9" class="mx my it bd mz na nb dn nc nd ne dp nf ld ng nh ni lh nj nk nl ll nm nn no np bi translated">对接和部署</h2><p id="bd21" class="pw-post-body-paragraph ku kv it kw b kx nq ju kz la nr jx lc ld ns lf lg lh nt lj lk ll nu ln lo lp im bi translated">由于我们的代码现在运行没有任何错误，是时候将它部署为一个容器了。因此，让我们将下面的docker文件添加到项目中</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="1be9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">对于生产场景，我们将在像<strong class="kw iu"> Nginx </strong>这样强大的http服务器后面公开我们的应用程序，以防止它被黑客攻击，并保护它免受恶意攻击。</p><p id="ba0d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">还记得我们在配置axios时声明的服务主机的环境变量吗？</p><pre class="kj kk kl km gt nx ml ny nz aw oa bi"><span id="0794" class="mx my it ml b gy ob oc l od oe"><strong class="ml iu">process.env.VUE_APP_API_HOST</strong></span></pre><p id="9d3a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">由于它是一个基于浏览器的应用程序，我们需要在构建时设置和传递这个环境变量。在docker映像构建时使用<code class="fe mi mj mk ml b"><strong class="kw iu">--build-arg</strong></code>很容易做到这一点，如下所示:</p><pre class="kj kk kl km gt nx ml ny nz aw oa bi"><span id="4c2f" class="mx my it ml b gy ob oc l od oe"><strong class="ml iu">sudo docker build --build-arg VUE_APP_API_HOST=&lt;Scheme&gt;://&lt;ServiceHost&gt;:&lt;ServicePort&gt;/ -f Dockerfile -t vue-app-image .</strong></span></pre><p id="7494" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">注意</strong>:请务必更换<strong class="kw iu"> <em class="og"> &lt;方案&gt; </em> </strong>，<strong class="kw iu"><em class="og">&lt;service host&gt;</em></strong>和<strong class="kw iu"><em class="og">&lt;service port&gt;</em></strong>。</p><p id="1c71" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">最后，使用以下命令运行应用程序:</p><pre class="kj kk kl km gt nx ml ny nz aw oa bi"><span id="53ca" class="mx my it ml b gy ob oc l od oe"><strong class="ml iu">sudo docker run -d -p 8080:80 — name vue-app vue-app-image</strong></span></pre><p id="b1f3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">恭喜您，您的vue应用程序已经启动并运行。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oh ms l"/></div></figure><p id="34ba" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您想了解完整的应用程序代码，请访问下面的链接:</p><ol class=""><li id="8efb" class="lz ma it kw b kx ky la lb ld mb lh mc ll md lp me mf mg mh bi translated">Vue <a class="ae nw" href="https://github.com/vivekcgi/sample-notes-app" rel="noopener ugc nofollow" target="_blank">前端</a></li><li id="63e4" class="lz ma it kw b kx mm la mn ld mo lh mp ll mq lp me mf mg mh bi translated">服务<a class="ae nw" href="https://github.com/vivekcgi/sample-notes-app-service" rel="noopener ugc nofollow" target="_blank">后端</a></li></ol><p id="ee25" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你有任何疑问，我非常乐意帮忙。你可以到vivek.khandekar91@gmail.com找我。</p></div></div>    
</body>
</html>