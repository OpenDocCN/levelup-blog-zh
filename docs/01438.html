<html>
<head>
<title>Difference Between Shallow And Deep Copy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">浅层拷贝和深层拷贝的区别</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/difference-between-shallow-and-deep-copy-c0a968e89c44?source=collection_archive---------3-----------------------#2019-12-31">https://levelup.gitconnected.com/difference-between-shallow-and-deep-copy-c0a968e89c44?source=collection_archive---------3-----------------------#2019-12-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="0735" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">面向对象编程指南</h2><div class=""/><div class=""><h2 id="e344" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">这种差异非常微妙，但却有着巨大的影响</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/c4288c01e7d488e00d14db528d036c67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Qw962JaOuxsG0UZ_"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">freestocks.org在<a class="ae lh" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上<a class="ae lh" href="https://unsplash.com/@freestocks?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">的照片</a></figcaption></figure><p id="597a" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在我以前的一些职位中，特别是在申请后端角色时，我经常被问及对象克隆。解释深层和浅层拷贝之间的区别常常是讨论的话题之一。我将解释两者的区别，以及何时应该使用一个而不是另一个，并提供Java示例代码。</p><p id="5454" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在Java中，对于一个可克隆的类，它必须实现<code class="fe me mf mg mh b"><strong class="lk jd">Cloneable</strong></code>接口，该接口只有一个返回对象的方法名克隆。因此，在克隆对象时，必须将其显式转换回适当的类型。让我们开始吧。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="1dfc" class="mp mq it bd mr ms mt mu mv mw mx my mz ki na kj nb kl nc km nd ko ne kp nf ng bi translated">浅拷贝</h1><blockquote class="nh"><p id="cfa3" class="ni nj it bd nk nl nm nn no np nq md dk translated">浅副本是通过复制所有基本类型值和所有相关引用对象类型的副本引用，从现有对象创建的对象。</p></blockquote><p id="b984" class="pw-post-body-paragraph li lj it lk b ll nr kd ln lo ns kg lq lr nt lt lu lv nu lx ly lz nv mb mc md im bi translated">这仅仅意味着，如果你的对象拥有所有的原始数据类型，那么所有的值都将被复制。然而，如果它有引用类型数据，那么你的新对象将指向与原始对象相同的引用。这意味着对原始对象的更改将反映在复制的对象中。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><p id="073d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">假设您有一个<strong class="lk jd"> <em class="nw"> Car </em> </strong>类，其属性包括年份、品牌、型号和装饰。它们都是基本类型，所以您的<strong class="lk jd"> <em class="nw">汽车</em> </strong>的克隆将复制所有赋值。但是，如果您的Car类有一个engine类型的Engine属性(这是一个类),那么只会复制对原始对象位置的引用。因此它被称为浅拷贝。对复制的引擎类属性所做的更改也会反映在原始属性中。让我们来看一个代码示例。</p><p id="d313" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">为了简洁起见，我们将只向Engine类添加两个属性。这是我们的引擎类代码片段。</p><pre class="ks kt ku kv gt nx mh ny nz aw oa bi"><span id="e359" class="ob mq it mh b gy oc od l oe of">public class Engine implements Cloneable {<br/>    //SN stand for Serial Number<br/>    String radiatorSN;<br/>    String oilPumpSN;<br/><br/>    public Engine(String radiatorSN, String oilPumpSN){<br/>        this.radiatorSN = radiatorSN;<br/>        this.oilPumpSN = oilPumpSN;<br/>    }<br/><br/>    @Override<br/>    protected Object clone() throws CloneNotSupportedException<br/>    {<br/>        return super.clone();<br/>    }<br/>}</span></pre><p id="1aa7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这是我们的汽车代码片段。</p><pre class="ks kt ku kv gt nx mh ny nz aw oa bi"><span id="4cee" class="ob mq it mh b gy oc od l oe of">public class Car implements Cloneable {<br/>    int year;<br/>    String make;<br/>    String model;<br/>    String trim;<br/>    Engine engine;</span><span id="f0dd" class="ob mq it mh b gy og od l oe of">    public Car(int year, String make, String model, String trim, <br/>           Engine engine){<br/>        this.year = year;<br/>        this.make = make;<br/>        this.model = model;<br/>        this.trim = trim;<br/>        this.engine = engine;<br/>    }</span><span id="c609" class="ob mq it mh b gy og od l oe of">    @Override<br/>    protected Object clone() throws CloneNotSupportedException<br/>    {<br/>        return super.clone();<br/>    }</span><span id="dfa2" class="ob mq it mh b gy og od l oe of">    @Override<br/>    public String toString() {<br/>        return "Year: " + year +<br/>                "\nMake: " + make +<br/>                "\nModel: " + model +<br/>                "\nTrim: " + trim +<br/>                "\nEngine.RadiatorSN: " + engine.radiatorSN +<br/>                "\nEngine.OilPumpSN: " + engine.oilPumpSN;<br/>    }<br/>}</span></pre><p id="558b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我已经覆盖了Car类的<code class="fe me mf mg mh b">toString</code>方法来打印所有属性。让我们使用我们的car类，展示一个浅拷贝的行为。下面是main方法的代码片段。</p><pre class="ks kt ku kv gt nx mh ny nz aw oa bi"><span id="8a7c" class="ob mq it mh b gy oc od l oe of">public static void main(String[] args) {<br/><br/>        Engine engine = new Engine("abc123","zyx987");<br/>        Car originalCar = new Car(2019,"BMW","328", "i", engine);<br/>        Car copiedCar = null;<br/><br/>        try{<br/><br/>            System.<em class="nw">out</em>.println("\n----printing originalCar ----");<br/>            System.<em class="nw">out</em>.println(originalCar);<br/><br/>            copiedCar = (Car)originalCar.clone();<br/>            copiedCar.engine.radiatorSN = "abc222";<br/><br/>            System.<em class="nw">out</em>.println("\n----printing copiedCar ----");<br/>            System.<em class="nw">out</em>.println(copiedCar);<br/><br/>            System.<em class="nw">out</em>.println("\n----printing originalCar ----");<br/>            System.<em class="nw">out</em>.println(originalCar);<br/>        }<br/>        catch (CloneNotSupportedException ex){<br/>            System.<em class="nw">out</em>.println(ex.getMessage());<br/>        }<br/>}</span></pre><p id="de18" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">运行main方法后的输出如下所示</p><pre class="ks kt ku kv gt nx mh ny nz aw oa bi"><span id="823f" class="ob mq it mh b gy oc od l oe of">----printing originalCar ----<br/>Year: 2019<br/>Make: BMW<br/>Model: 328<br/>Trim: i<br/>Engine.RadiatorSN: abc123<br/>Engine.OilPumpSN: zyx987</span><span id="dc0a" class="ob mq it mh b gy og od l oe of">----printing copiedCar ----<br/>Year: 2019<br/>Make: BMW<br/>Model: 328<br/>Trim: i<br/>Engine.RadiatorSN: abc222<br/>Engine.OilPumpSN: zyx987</span><span id="4362" class="ob mq it mh b gy og od l oe of">----printing originalCar ----<br/>Year: 2019<br/>Make: BMW<br/>Model: 328<br/>Trim: i<br/>Engine.RadiatorSN: abc222<br/>Engine.OilPumpSN: zyx987</span></pre><p id="cf64" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">请注意我们原始对象的<strong class="lk jd"> <em class="nw"> oilPumpSN </em> </strong>属性的值也被更改为“abc222 ”,尽管我们只是在复制的对象中更改了它。对于浅层复制，您总是可以预料到这样的行为，因为如前所述，两个对象都指向同一个引擎对象。</p><p id="157f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><em class="nw">在处理只包含只有原始数据类型的属性的类时，建议使用浅层拷贝。如果您的对象包含非原始数据类型，您将会遇到这种行为，并且如果两个对象都被使用，它可能会与您的程序流发生偏差。</em></p><p id="81f6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">另一件要注意的事情是，默认情况下，调用<code class="fe me mf mg mh b"><strong class="lk jd">super.clone()</strong></code>会产生现有对象的浅层副本。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><h1 id="ddc1" class="mp mq it bd mr ms mt mu mv mw mx my mz ki na kj nb kl nc km nd ko ne kp nf ng bi translated">深层拷贝</h1><blockquote class="nh"><p id="62cb" class="ni nj it bd nk nl nm nn no np nq md dk translated">深层副本是通过复制所有原始和非原始数据类型值从现有对象创建的对象。</p></blockquote><p id="06c8" class="pw-post-body-paragraph li lj it lk b ll nr kd ln lo ns kg lq lr nt lt lu lv nu lx ly lz nv mb mc md im bi translated">浅层拷贝的定义与深层拷贝非常相似，但有一点不同。对于非基本类型属性，实际值被复制，而不是仅仅指向它们的对象的原始引用。所有属性的复制都独立于原始对象。这意味着，与浅层复制不同，对复制对象的更改不会影响原始对象。这也是一个成本更高的操作，应该只相应地使用，这就引出了我的下一个观点。当您想要复制的对象不仅仅包含原始数据类型时，您应该使用它。</p><p id="7a17" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在前面的例子中，我们注意到我们得到了一个不希望的行为。你可能会问自己哪些不受欢迎的行为？嗯，我们只想为复制的对象设置引擎<strong class="lk jd"> <em class="nw">油泵</em> </strong>值，但是，因为它们都指向同一个对象，所以我们不能这样做。对复制对象中引擎属性的任何更改也会反映在原始对象中。这就是深层拷贝的必要性。</p></div><div class="ab cl mi mj hx mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="im in io ip iq"><p id="4698" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们修改上一个例子中使用的代码，当我们在Car类上调用clone方法时，进行深度复制而不是浅层复制。一切保持不变。我们唯一需要修改的地方是受保护的克隆方法。</p><p id="05f2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这是它以前的样子。</p><pre class="ks kt ku kv gt nx mh ny nz aw oa bi"><span id="fa1c" class="ob mq it mh b gy oc od l oe of">@Override<br/>protected Object clone() throws CloneNotSupportedException<br/>{<br/>    return super.clone();<br/>}</span></pre><p id="ff47" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这是我们做了深入复制的更改后的样子。</p><pre class="ks kt ku kv gt nx mh ny nz aw oa bi"><span id="e924" class="ob mq it mh b gy oc od l oe of">@Override<br/>protected Object clone() throws CloneNotSupportedException<br/>{<br/>    Car clonedCar = (Car)super.clone();<br/>    clonedCar.engine = (Engine)this.engine.clone();<br/>    return clonedCar;<br/>}</span></pre><p id="7e2e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这里的不同之处在于，我将引擎值显式地赋给了新克隆的对象。因此，复制的对象引擎属性将不会指向原始对象，而是指向其引擎对象。所以如果我们现在运行main方法，输出应该是这样的。</p><pre class="ks kt ku kv gt nx mh ny nz aw oa bi"><span id="7769" class="ob mq it mh b gy oc od l oe of">----printing originalCar ----<br/>Year: 2019<br/>Make: BMW<br/>Model: 328<br/>Trim: i<br/><strong class="mh jd">Engine.RadiatorSN: abc123</strong><br/>Engine.OilPumpSN: zyx987</span><span id="3e99" class="ob mq it mh b gy og od l oe of">----printing copiedCar ----<br/>Year: 2019<br/>Make: BMW<br/>Model: 328<br/>Trim: i<br/><strong class="mh jd">Engine.RadiatorSN: abc222</strong><br/>Engine.OilPumpSN: zyx987</span><span id="416d" class="ob mq it mh b gy og od l oe of">----printing originalCar ----<br/>Year: 2019<br/>Make: BMW<br/>Model: 328<br/>Trim: i<br/><strong class="mh jd">Engine.RadiatorSN: abc123</strong><br/>Engine.OilPumpSN: zyx987</span></pre><p id="8269" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">一旦我们的代码被更改为深层副本而不是浅层副本，我们就获得了想要的行为。因此，当您的类由原始和非原始数据类型组成时，应该使用深度复制。</p><p id="539d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">谢谢你坚持到最后。<strong class="lk jd"> <em class="nw">快乐编码</em> </strong>。</p></div></div>    
</body>
</html>