<html>
<head>
<title>Operating System — Threading</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">操作系统—线程</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/operating-system-threading-ae9697322efb?source=collection_archive---------1-----------------------#2021-07-11">https://levelup.gitconnected.com/operating-system-threading-ae9697322efb?source=collection_archive---------1-----------------------#2021-07-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f43b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">仅用4分钟了解线程</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/85cd534a1a7d65e66ed7d5b0911c5f84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vh0PcqmIZOhKuZ3F"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">约翰·安维克在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="afee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">线程</strong>是软件工程师最重要的概念之一。它允许一个程序同时运行多个任务。你一定经常听说过线程。但是你真的知道那是什么吗？流程呢？你知道<strong class="ky ir">螺纹</strong>和<strong class="ky ir">工艺</strong>的区别吗？你知道如何<strong class="ky ir">创建一个线程</strong>吗？</p><p id="5702" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您是高级开发人员或计算机科学专业的毕业生，请将本文作为复习资料。如果你是操作系统世界的新手，它是为你量身定做的。</p><h1 id="f432" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">什么是线程？</h1><p id="3f13" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">线程是CPU利用率的基本单位，它包括:</p><ul class=""><li id="1e5f" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated">threadID</li><li id="6b5d" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">程序计数器</li><li id="a63a" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">寄存器组</li><li id="2728" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">堆</li></ul><p id="a6ee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于属于同一进程的线程，它们共享:</p><ul class=""><li id="5eff" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated">代码部分</li><li id="a0b4" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">数据部分</li><li id="8366" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">其他操作系统资源(例如，打开的文件和信号)</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nd"><img src="../Images/617909b22ad5ec5fa3a165831be3a2c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O7-o4NZtjNMyfNEb_NgvZw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">单线程进程与多线程进程</figcaption></figure><h1 id="b178" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">进程与线程</h1><h2 id="d14a" class="ne lt iq bd lu nf ng dn ly nh ni dp mc lf nj nk me lj nl nm mg ln nn no mi np bi translated">流程:</h2><ol class=""><li id="161d" class="mp mq iq ky b kz mk lc ml lf nq lj nr ln ns lr nt mv mw mx bi translated">重量级</li><li id="d045" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr nt mv mw mx bi translated">创建成本高(需要更多内存)</li><li id="e47d" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr nt mv mw mx bi translated">无法访问其他进程的内存区域</li><li id="1780" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr nt mv mw mx bi translated">昂贵的过程转换</li><li id="64e9" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr nt mv mw mx bi translated">不同的过程意味着不同的程序</li></ol><h2 id="8112" class="ne lt iq bd lu nf ng dn ly nh ni dp mc lf nj nk me lj nl nm mg ln nn no mi np bi translated">线程:</h2><ol class=""><li id="1a67" class="mp mq iq ky b kz mk lc ml lf nq lj nr ln ns lr nt mv mw mx bi translated">轻量</li><li id="4a38" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr nt mv mw mx bi translated">廉价创建(需要更少的内存)</li><li id="be8d" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr nt mv mw mx bi translated">与其他线程共享相同的内存区域</li><li id="f0e7" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr nt mv mw mx bi translated">廉价的线程切换</li><li id="a589" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr nt mv mw mx bi translated">多线程意味着相同的代码段</li></ol><h1 id="c575" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">用户空间内存中的多线程</h1><p id="23cd" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">多线程的好处之一是易于数据共享。</p><p id="7a8b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">数据共享可以通过以下方式完成:</p><ul class=""><li id="25bd" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated">全局变量</li><li id="89e5" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">动态分配的内存。</li></ul><p id="e276" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所有线程共享全局变量区和堆，它们可以从这两个区域读取数据，也可以向这两个区域写入数据。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/62e94c3a68658d7dc13c60a3a740438c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1124/format:webp/1*0mk4lmSFr3k0DcuU8FCN0Q.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">多线程一起共享数据</figcaption></figure><p id="7e15" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，这导致了<strong class="ky ir">互斥</strong>和<strong class="ky ir">同步</strong>的问题。如果你想了解更多关于互斥的知识，可以查看我之前的文章。</p><div class="nv nw gp gr nx ny"><a rel="noopener  ugc nofollow" target="_blank" href="/operating-system-inter-process-communication-ipc-60a288b11d18"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd ir gy z fp od fr fs oe fu fw ip bi translated">操作系统—进程间通信(IPC)</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">仅用3分钟了解IPC</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="oh l"><div class="oi l oj ok ol oh om kp ny"/></div></div></a></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi on"><img src="../Images/291739c761c5d76fe75250fef9bb1311.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KQjqr_q9LonmYs65K6PPKQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">进程的用户空间内存</figcaption></figure><h2 id="cf8b" class="ne lt iq bd lu nf ng dn ly nh ni dp mc lf nj nk me lj nl nm mg ln nn no mi np bi translated">代码和线程功能</h2><p id="32b4" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">所有线程共享相同的代码，一个线程可以从一个特定的函数开始，这个函数就是线程函数。<br/> <br/>一个线程函数可以调用其他函数或系统调用。但是线程永远不会返回线程函数的调用者。</p><h2 id="6954" class="ne lt iq bd lu nf ng dn ly nh ni dp mc lf nj nk me lj nl nm mg ln nn no mi np bi translated">局部变量</h2><p id="b0f6" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">每个线程都有自己的局部变量堆栈。</p><h1 id="ef5b" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">如何创建线程？</h1><h2 id="e300" class="ne lt iq bd lu nf ng dn ly nh ni dp mc lf nj nk me lj nl nm mg ln nn no mi np bi translated">Pthread库</h2><p id="70d1" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">让我们来看看进程和线程的系统调用之间的区别。</p><p id="c638" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">系统调用流程</p><ul class=""><li id="43dc" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated">创作:<strong class="ky ir"> fork() </strong></li><li id="1c72" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">ID类型:<strong class="ky ir"> PID </strong>，为整数</li><li id="301b" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">获取身份:<strong class="ky ir"> getpid() </strong></li><li id="a81e" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">终止:<strong class="ky ir">退出()</strong></li><li id="fa63" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">等待子终止:<strong class="ky ir"> wait() </strong> <strong class="ky ir"> / waitpid() </strong></li><li id="a04a" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">Kill: <strong class="ky ir"> kill() </strong></li></ul><p id="2795" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">线程的系统调用</p><ul class=""><li id="6b54" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated">创建:<strong class="ky ir"> pthread_create() </strong></li><li id="6f35" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">id类型:<strong class="ky ir"> pthread_t </strong>，是一个结构</li><li id="ff73" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">获取身份:<strong class="ky ir"> pthread_self() </strong></li><li id="f297" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">终止:<strong class="ky ir"> pthread_exit() </strong></li><li id="24f4" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">等待子进程终止:<strong class="ky ir"> pthread_join() </strong></li><li id="1b5a" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">Kill: <strong class="ky ir"> pthread_kill() </strong></li></ul><h2 id="d7d7" class="ne lt iq bd lu nf ng dn ly nh ni dp mc lf nj nk me lj nl nm mg ln nn no mi np bi translated">使用pthread_create()创建线程的示例</h2><p id="fa49" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">线程功能:</p><pre class="kg kh ki kj gt oo op oq or aw os bi"><span id="04b9" class="ne lt iq op b gy ot ou l ov ow">void * hello( void *input ) {<br/>  printf(“%s\n”, (char *) input);<br/>  pthread_exit(NULL);<br/>}</span></pre><p id="0a0a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">主要功能:</p><pre class="kg kh ki kj gt oo op oq or aw os bi"><span id="f7a7" class="ne lt iq op b gy ot ou l ov ow">int main(void) {<br/>  pthread_t tid;<br/>  <strong class="op ir">pthread_create(&amp;tid, NULL, hello, “hello world”);</strong><br/>  pthread_join(tid, NULL);<br/>  return 0;<br/>}</span></pre><h1 id="0529" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">Pthread中的互斥</h1><p id="eae2" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">信号量可以用作锁，但是它很难编码和读取。</p><p id="122a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">POSIX线程提供了可以和POSIX信号量一起使用的<strong class="ky ir">互斥</strong>和<strong class="ky ir">条件变量</strong>。</p><h2 id="b3ef" class="ne lt iq bd lu nf ng dn ly nh ni dp mc lf nj nk me lj nl nm mg ln nn no mi np bi translated"><strong class="ak">互斥</strong></h2><p id="b51c" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><strong class="ky ir">初始化</strong></p><pre class="kg kh ki kj gt oo op oq or aw os bi"><span id="30e7" class="ne lt iq op b gy ot ou l ov ow">pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;</span></pre><p id="3003" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">锁定</strong></p><pre class="kg kh ki kj gt oo op oq or aw os bi"><span id="59f7" class="ne lt iq op b gy ot ou l ov ow">pthread_mutex_lock(&amp;mutex);</span></pre><ul class=""><li id="cbee" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated">如果互斥体没有被锁定，请锁定互斥体。</li><li id="8d7e" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">如果互斥被锁定，阻塞调用线程。</li></ul><p id="0b8f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">解锁</strong></p><pre class="kg kh ki kj gt oo op oq or aw os bi"><span id="9c04" class="ne lt iq op b gy ot ou l ov ow">pthread_mutex_unlock(&amp;mutex);</span></pre><p id="8db8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用互斥的线程函数示例:</p><pre class="kg kh ki kj gt oo op oq or aw os bi"><span id="8c7d" class="ne lt iq op b gy ot ou l ov ow">while(TRUE) {</span><span id="10e4" class="ne lt iq op b gy ox ou l ov ow">  <strong class="op ir">pthread_mutex_lock(&amp;mutex);</strong></span><span id="8755" class="ne lt iq op b gy ox ou l ov ow">  if(shared &lt; 100)<br/>    <strong class="op ir">shared++; // shared object</strong><br/>  else {<br/>    <strong class="op ir">pthread_mutex_unlock(&amp;mutex);</strong><br/>    break;<br/>  }</span><span id="55e9" class="ne lt iq op b gy ox ou l ov ow">  <strong class="op ir">pthread_mutex_unlock(&amp;mutex);</strong></span><span id="5f53" class="ne lt iq op b gy ox ou l ov ow">  sleep(rand() % 10);</span><span id="5652" class="ne lt iq op b gy ox ou l ov ow">}</span></pre><h2 id="f30c" class="ne lt iq bd lu nf ng dn ly nh ni dp mc lf nj nk me lj nl nm mg ln nn no mi np bi translated">pthread_mutex vs POSIX信号量</h2><p id="682c" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">POSIX信号量</p><ul class=""><li id="1c67" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated">由内核拥有</li><li id="06ac" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">可以跨进程/线程同步</li><li id="be13" class="mp mq iq ky b kz my lc mz lf na lj nb ln nc lr mu mv mw mx bi translated">任何线程/进程都可以对<br/>任何信号量执行<strong class="ky ir">SEM _ wait()</strong>&amp;<strong class="ky ir">SEM _ post()</strong></li></ul><p id="d0ed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">pthread _互斥</p><ul class=""><li id="05b3" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated"><strong class="ky ir">仅在同一进程的线程间同步</strong></li></ul><p id="629f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">pthread_mutex在使用和调试上肯定要容易得多。</p><h2 id="b902" class="ne lt iq bd lu nf ng dn ly nh ni dp mc lf nj nk me lj nl nm mg ln nn no mi np bi translated">条件变量</h2><p id="804b" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><strong class="ky ir">初始化</strong></p><pre class="kg kh ki kj gt oo op oq or aw os bi"><span id="0785" class="ne lt iq op b gy ot ou l ov ow">pthread_cond_t cond = PTHREAD_COND_INITIALIZER;</span></pre><p id="807b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">等待</strong></p><pre class="kg kh ki kj gt oo op oq or aw os bi"><span id="87a3" class="ne lt iq op b gy ot ou l ov ow">pthread_cond_wait(&amp;cond, &amp;mutex);</span></pre><p id="95bd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">唤醒1号</strong></p><pre class="kg kh ki kj gt oo op oq or aw os bi"><span id="f327" class="ne lt iq op b gy ot ou l ov ow">pthread_cond_signal(&amp;cond);</span></pre><p id="1b4a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此功能<strong class="ky ir">唤醒一个等待</strong>条件变量<strong class="ky ir">“cond”</strong>的线程。如果有多个线程在等待，那么这些线程中至少有一个会被唤醒。</p><p id="3a9f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">唤醒2号</strong></p><pre class="kg kh ki kj gt oo op oq or aw os bi"><span id="4c09" class="ne lt iq op b gy ot ou l ov ow">pthread_cond_broadcast(&amp;cond);</span></pre><p id="c598" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此功能<strong class="ky ir">唤醒所有等待条件变量“cond”的线程</strong>。</p></div><div class="ab cl oy oz hu pa" role="separator"><span class="pb bw bk pc pd pe"/><span class="pb bw bk pc pd pe"/><span class="pb bw bk pc pd"/></div><div class="ij ik il im in"><h2 id="f8d4" class="ne lt iq bd lu nf ng dn ly nh ni dp mc lf nj nk me lj nl nm mg ln nn no mi np bi translated">后续步骤</h2><p id="05be" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">如果你正在读这一行，恭喜你！！！你做到了。你已经学习了线程的基础知识以及如何创建线程。</p><p id="9d12" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请随意查看下面关于操作系统的其他文章:</p><div class="nv nw gp gr nx ny"><a href="https://mattchw.medium.com/overview-of-operating-system-cc3f6f6bb062" rel="noopener follow" target="_blank"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd ir gy z fp od fr fs oe fu fw ip bi translated">操作系统概述</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">操作系统一般是如何工作的？</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">mattchw.medium.com</p></div></div><div class="oh l"><div class="pf l oj ok ol oh om kp ny"/></div></div></a></div><p id="570a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要了解更多关于我的后端学习路径，请点击这里查看我的旅程:</p><div class="nv nw gp gr nx ny"><a href="https://mattchw.medium.com/my-backend-developer-learning-journey-%E6%88%91%E7%9A%84%E5%BE%8C%E7%AB%AF%E5%AD%B8%E7%BF%92%E4%B9%8B%E6%97%85-5315fe2fefc2" rel="noopener follow" target="_blank"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd ir gy z fp od fr fs oe fu fw ip bi">My Backend Developer Learning Journey 我的後端學習之旅</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">毕业一年多了。拥有2年以上的前端和后端工作经验…</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">mattchw.medium.com</p></div></div><div class="oh l"><div class="pg l oj ok ol oh om kp ny"/></div></div></a></div></div></div>    
</body>
</html>