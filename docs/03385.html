<html>
<head>
<title>Type Safety Galore! Apollo Tooling for your GraphQL Powered App</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">类型安全丰富！用于GraphQL驱动的应用程序的Apollo工具</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/type-safety-galore-apollo-tooling-for-your-graphql-powered-app-f363c8325061?source=collection_archive---------11-----------------------#2020-05-05">https://levelup.gitconnected.com/type-safety-galore-apollo-tooling-for-your-graphql-powered-app-f363c8325061?source=collection_archive---------11-----------------------#2020-05-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c9a3" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">生成静态类型以提高客户端类型安全性变得更加容易。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/0f51f9e9d15bc335ccf6210ef795810c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*sFXmUAMq_Kk8vD1P"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://unsplash.com/@thenikyv?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Niketh Vellanki </a>在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><blockquote class="kw kx ky"><p id="6f22" class="kz la lb lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">我不使用Apollo Graph Manager，我的模式托管在其他地方。这对我还有用吗？</p></blockquote><p id="8bcb" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">是啊！</p><blockquote class="kw kx ky"><p id="771d" class="kz la lb lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">这听起来工作量很大。</p></blockquote><p id="816e" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">它不是。</p><blockquote class="kw kx ky"><p id="9f3d" class="kz la lb lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">我不使用打字稿。<strong class="lc ir">丹阿布拉莫夫</strong> <a class="ae kv" href="https://twitter.com/dan_abramov/status/1082460320009015296?lang=en" rel="noopener ugc nofollow" target="_blank"> <strong class="lc ir">也没有</strong> </a> <strong class="lc ir">也没有。</strong></p></blockquote><ol class=""><li id="f113" class="lz ma iq lc b ld le lg lh lw mb lx mc ly md lv me mf mg mh bi translated">类型安全！== Typescript</li><li id="8b8e" class="lz ma iq lc b ld mi lg mj lw mk lx ml ly mm lv me mf mg mh bi translated">这篇文章将会回避TS和JS的争论🙏</li><li id="4538" class="lz ma iq lc b ld mi lg mj lw mk lx ml ly mm lv me mf mg mh bi translated">可以为其他目标生成代码，包括Scala、Swift、Flow和Typescript。我在一个Typescript + React原生项目中使用它。</li></ol><p id="ae69" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">如果您已经将GraphQL集成到您的客户端应用程序中，正在使用任何受支持的目标，并且对类型安全感到疑惑，那么这篇文章就是为您准备的。</p></div><div class="ab cl mn mo hu mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ij ik il im in"><h1 id="5ccd" class="mu mv iq bd mw mx my mz na nb nc nd ne jw nf jx ng jz nh ka ni kc nj kd nk nl bi translated">先决条件</h1><p id="9d1d" class="pw-post-body-paragraph kz la iq lc b ld nm jr lf lg nn ju li lw no ll lm lx np lp lq ly nq lt lu lv ij bi translated">本指南假设您已经基本掌握了GraphQL和Apollo Client，并不适合绝对的初学者。初学者可以通过完成由Apollo提供的这个优秀的全栈教程来开始他们的旅程，它涵盖了从创建一个图到构建一个React-powered客户端并使用该图的所有内容。</p><p id="016e" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">确保你有:</p><ol class=""><li id="8f11" class="lz ma iq lc b ld le lg lh lw mb lx mc ly md lv me mf mg mh bi translated">使用GraphQL和Apollo客户端设置您的应用程序。</li><li id="cca5" class="lz ma iq lc b ld mi lg mj lw mk lx ml ly mm lv me mf mg mh bi translated">如果你的服务器需要授权头，建立一个“dotenv”文件。我将在本指南中使用<a class="ae kv" href="https://github.com/motdotla/dotenv" rel="noopener ugc nofollow" target="_blank"> dotenv </a>。</li><li id="851a" class="lz ma iq lc b ld mi lg mj lw mk lx ml ly mm lv me mf mg mh bi translated">使您的GraphQL端点可通过<code class="fe nr ns nt nu b">localhost</code>或远程服务器(如Heroku)访问</li></ol><h1 id="810c" class="mu mv iq bd mw mx nv mz na nb nw nd ne jw nx jx ng jz ny ka ni kc nz kd nk nl bi translated">装置</h1><h2 id="bb6b" class="oa mv iq bd mw ob oc dn na od oe dp ne lw of og ng lx oh oi ni ly oj ok nk ol bi translated">安装软件包</h2><p id="9cae" class="pw-post-body-paragraph kz la iq lc b ld nm jr lf lg nn ju li lw no ll lm lx np lp lq ly nq lt lu lv ij bi translated">让我们从安装必要的包开始。</p><pre class="kg kh ki kj gt om nu on oo aw op bi"><span id="7fc7" class="oa mv iq nu b gy oq or l os ot"># Yarn<br/>yarn add -D apollo dotenv      <br/># npm   <br/>npm install --dev apollo dotenv</span></pre><h2 id="ee86" class="oa mv iq bd mw ob oc dn na od oe dp ne lw of og ng lx oh oi ni ly oj ok nk ol bi translated">配置阿波罗</h2><p id="eb1b" class="pw-post-body-paragraph kz la iq lc b ld nm jr lf lg nn ju li lw no ll lm lx np lp lq ly nq lt lu lv ij bi translated">配置Apollo的最快方法是在我们项目的根目录下使用一个配置文件。如果您还没有一个文件，可以选择创建一个<code class="fe nr ns nt nu b">dotenv</code>文件。</p><pre class="kg kh ki kj gt om nu on oo aw op bi"><span id="9315" class="oa mv iq nu b gy oq or l os ot"># make sure you are at the project root<br/>cd &lt;PROJECT_ROOT&gt; <br/>touch apollo.config.js<br/>touch .env</span></pre><p id="acae" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">在<code class="fe nr ns nt nu b">apollo.config.js</code>中粘贴以下内容。这使用环境变量配置了我们的端点和授权头。在你的<code class="fe nr ns nt nu b">.env</code>里加上<code class="fe nr ns nt nu b">GRAPHQL_ENDPOINT</code>和<code class="fe nr ns nt nu b">BEARER_TOKEN</code>。</p><pre class="kg kh ki kj gt om nu on oo aw op bi"><span id="7896" class="oa mv iq nu b gy oq or l os ot">require("dotenv").config()</span><span id="ae9a" class="oa mv iq nu b gy ou or l os ot">module.exports = {</span><span id="70c7" class="oa mv iq nu b gy ou or l os ot">  client: {</span><span id="4ac0" class="oa mv iq nu b gy ou or l os ot">    service: {</span><span id="a42b" class="oa mv iq nu b gy ou or l os ot">      url: process.env.GRAPHQL_ENDPOINT,</span><span id="f555" class="oa mv iq nu b gy ou or l os ot">      headers: {</span><span id="da72" class="oa mv iq nu b gy ou or l os ot">        "Authorization": "Bearer " + process.env.BEARER_TOKEN,</span><span id="2348" class="oa mv iq nu b gy ou or l os ot">      },</span><span id="58c3" class="oa mv iq nu b gy ou or l os ot">    },</span><span id="8624" class="oa mv iq nu b gy ou or l os ot">  },</span><span id="1920" class="oa mv iq nu b gy ou or l os ot">}</span></pre><p id="c752" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">我们差不多完成了。😉</p><p id="1124" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">不，说真的。我们现在需要做的就是配置一个<code class="fe nr ns nt nu b">package.json</code>脚本，这样我们就完成了。</p><h2 id="a266" class="oa mv iq bd mw ob oc dn na od oe dp ne lw of og ng lx oh oi ni ly oj ok nk ol bi translated">配置<code class="fe nr ns nt nu b">package.json</code></h2><p id="c8df" class="pw-post-body-paragraph kz la iq lc b ld nm jr lf lg nn ju li lw no ll lm lx np lp lq ly nq lt lu lv ij bi translated">将这一行添加到您的<code class="fe nr ns nt nu b">package.json</code>中的脚本部分:</p><pre class="kg kh ki kj gt om nu on oo aw op bi"><span id="cfdc" class="oa mv iq nu b gy oq or l os ot">"codegen": "apollo codegen:generate &lt;output_path&gt; --includes=&lt;files_to_include&gt; --target &lt;your_target&gt; --outputFlat"</span></pre><p id="0433" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">乍一看，似乎有很多东西需要消化，所以这里有一个细目分类:</p><p id="cf26" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated"><code class="fe nr ns nt nu b">&lt;output_path&gt;</code>:我们希望生成的类型出现在我们的项目结构中。</p><p id="2c5e" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated"><code class="fe nr ns nt nu b">&lt;files_to_include&gt;</code> : Glob模式，Apollo将使用它来查找GraphQL查询和片段，为其生成类型。</p><p id="6a7a" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated"><code class="fe nr ns nt nu b">&lt;your_target&gt;</code>:支持的目标类型<code class="fe nr ns nt nu b">(scala | flow | swift | typescript)</code>之一。</p><p id="0e2b" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated"><code class="fe nr ns nt nu b">— outputFlat</code>:将生成的文件放在输出目录下，而不是放在源文件旁边。<strong class="lc ir">完全可选</strong>，所以我们可以自由选择我们想要的目录结构。</p><p id="312d" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">下面是一个例子，以防您被众多的选项弄糊涂，想要调整现有的命令:</p><pre class="kg kh ki kj gt om nu on oo aw op bi"><span id="17b4" class="oa mv iq nu b gy oq or l os ot">"codegen": "apollo codegen:generate app/generated/types/ --includes='./app/**/*.ts?(x)' --target typescript --outputFlat"</span></pre><h2 id="6122" class="oa mv iq bd mw ob oc dn na od oe dp ne lw of og ng lx oh oi ni ly oj ok nk ol bi translated">就是这样！</h2><p id="7ded" class="pw-post-body-paragraph kz la iq lc b ld nm jr lf lg nn ju li lw no ll lm lx np lp lq ly nq lt lu lv ij bi translated">一个配置文件、一个package.json脚本和几个依赖项之后，代码生成就完成了。您可以轻松地提交生成的类型，并保持机密，如授权令牌和端点的安全。</p><p id="5d22" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">这是我们需要将类型生成集成到我们的应用程序中的配置的基本最小示例。接下来，让我们使用我们已经集成的东西，并快速了解Apollo Tooling在我们的GraphQL之旅中为我们提供了哪些好处。🚀</p></div><div class="ab cl mn mo hu mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ij ik il im in"><p id="728c" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">这个非常简单的例子使用了@apollo/react-hooks。我们的后端是一个托管在Heroku上的Hasura GraphQL实例。下面是React客户机中的基本查询设置。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ov"><img src="../Images/750f03b43ae3eba49607857cb1a09665.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9PtR4oDYWpI5G5hSvZECrQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">获取和渲染任务</figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ov"><img src="../Images/5631d8025a9a1853263bd1fe45d2de3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-xySyTSkjPOAtNIywMhcXQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">用于提取任务的查询</figcaption></figure><p id="790c" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">现在在项目根中运行<code class="fe nr ns nt nu b">yarn codegen</code>将自动检测<code class="fe nr ns nt nu b">app/components/active-tasks</code>目录中的查询并生成所需的类型。本例中生成的类型如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ov"><img src="../Images/a90048dc46944f7b3bbba017ae731d35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2MneM53leVYcb7_D5FZxNA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">任务查询的生成类型</figcaption></figure><p id="dc6b" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">现在，您可以将导出的接口作为"<em class="lb">类型参数"</em>传递给<code class="fe nr ns nt nu b">useQuery</code>，瞧！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ow"><img src="../Images/5819d6dc43108a1784e57b40f4e69451.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JiU2l1beGlV-652FeaYBSg.png"/></div></div></figure><p id="0c21" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">一个更有用的场景是当我们<code class="fe nr ns nt nu b">useMutation</code>时，期望执行变异的变量很容易出错或者完全忽略。类型检查帮助我们避免这些错误，并改善开发人员的体验。✔️</p></div><div class="ab cl mn mo hu mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ij ik il im in"><p id="f09b" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">感谢阅读！🥂</p></div></div>    
</body>
</html>