<html>
<head>
<title>An Intro to Git-Submodules</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Git子模块简介</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/an-intro-to-git-submodules-9f49523281fb?source=collection_archive---------7-----------------------#2022-01-24">https://levelup.gitconnected.com/an-intro-to-git-submodules-9f49523281fb?source=collection_archive---------7-----------------------#2022-01-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f3b0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何让多个存储库协同工作？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3d5565d0692b66b049919df7aad25231.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*g5jS5Mg9U_ifkI7H.jpg"/></div></div></figure><p id="d3df" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi lq translated">it子模块已经存在了十多年，然而许多开发人员从未使用过它们。感谢今天的包管理器和共享库的选项列表，git子模块并不意味着每个需要共享包或依赖项的场景都有git子模块。从源代码和消费者的角度来看，子模块主要是用来控制代码的变化。让我们详述一下那个想法。</p><p id="6cc1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先，<strong class="kw iu">git子模块只是对另一个库</strong>的引用。你可以有一个总体项目，比如说你自己的SDK(软件开发工具包)。该SDK可能依赖于子项目，如编译器、处理编译后二进制文件执行的运行时、代码样本等等。SDK将是您的主要项目存储库，编译器和运行时作为子模块(当然，在实际应用程序中，您需要的子模块项目不仅仅是这两个)。如果您需要立刻对SDK源代码<em class="lz">及其子项目</em>进行修改，git子模块可能是您的一个选择。</p><p id="9ff0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">本文将重点介绍git子模块的一些关键特征，包括如何创建它们、基本功能以及在最后总结它们的主要亮点。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="5543" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">向新项目添加Git子模块</h1><p id="b32e" class="pw-post-body-paragraph ku kv it kw b kx mz ju kz la na jx lc ld nb lf lg lh nc lj lk ll nd ln lo lp im bi translated">将子模块添加到现有的git存储库中很容易，但是需要注意一些事情。让我们从创建一个简单的项目<code class="fe ne nf ng nh b">sdk</code>开始，该项目包含单个文件<code class="fe ne nf ng nh b">README.md</code>以及git跟踪。</p><pre class="kj kk kl km gt ni nh nj nk aw nl bi"><span id="1fa3" class="nm mi it nh b gy nn no l np nq">$ mkdir sdk<br/>$ cd sdk<br/>$ touch README.md<br/>$ git init<br/>$ git add README.md<br/>$ git commit -m "initial commit"</span></pre><p id="4c4e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，假设我们在GitHub中有另一个已经有远程源的存储库。我们可以很容易地将子模块添加到我们的<code class="fe ne nf ng nh b">sdk</code> repo中，如下所示:</p><pre class="kj kk kl km gt ni nh nj nk aw nl bi"><span id="0a1d" class="nm mi it nh b gy nn no l np nq">$ git submodule add <a class="ae nr" href="https://github.com/Israel-Miles/PasswordManager.git" rel="noopener ugc nofollow" target="_blank">https://github.com/Some-User/compiler.git</a><br/>Cloning into 'path/to/sdk/compiler'...<br/>remote: Enumerating objects: 345, done.<br/>remote: Counting objects: 100% (345/345), done.<br/>.....</span></pre><p id="8e55" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们现在将在<code class="fe ne nf ng nh b">sdk</code>中拥有<code class="fe ne nf ng nh b">compiler</code>存储库和<code class="fe ne nf ng nh b">.gitmodules</code>文件。这个文件只有我们的子模块的基本信息，比如它们的名称、路径、url等等。在再次达到干净的git状态之前，您需要添加并提交这些新文件。检查子模块的状态很容易。</p><pre class="kj kk kl km gt ni nh nj nk aw nl bi"><span id="f5b0" class="nm mi it nh b gy nn no l np nq">$ git submodule status<br/>ab18d94ae63 compiler (heads/main)</span></pre><p id="a7c3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为<code class="fe ne nf ng nh b">compiler</code>列出的提交引用是<em class="lz">对该存储库的主要分支的最近提交。</em>这样，git子模块只是从一个存储库到下一个存储库的链接，增加的好处是每个存储库的源代码很容易访问和共享。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="9332" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">使用Git子模块</h1><p id="8b04" class="pw-post-body-paragraph ku kv it kw b kx mz ju kz la na jx lc ld nb lf lg lh nc lj lk ll nd ln lo lp im bi translated">默认情况下，任何基本的git命令都只针对您当前所在的存储库运行。因此，如果您在<code class="fe ne nf ng nh b">sdk</code>回购协议中(但在<code class="fe ne nf ng nh b">compiler</code>回购协议之外)进行了更改，那么git将只向您显示那些在<code class="fe ne nf ng nh b">sdk</code>中的差异。拉、推、提交等。都只针对您当前所在的回购执行。</p><p id="7eb6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您想在项目中的所有子模块上运行一个命令，比如<code class="fe ne nf ng nh b">git pull</code>，那么您应该从<code class="fe ne nf ng nh b">sdk</code>运行<code class="fe ne nf ng nh b">git pull --recurse-submodules</code>。这将提取对<code class="fe ne nf ng nh b">sdk</code>所做的任何更改，以及从每个子模块当前所在的分支提取新的更改。如果您的子模块有子模块，该过程将继续，直到所有子模块都被更新。要在运行<code class="fe ne nf ng nh b">git pull</code>时自动提取子模块，可以运行<code class="fe ne nf ng nh b">git config submodule.recurse true</code>。</p><p id="b253" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了跨子模块运行更多的通用命令，使用<code class="fe ne nf ng nh b">foreach</code>术语来遍历每个子模块。示例:</p><pre class="kj kk kl km gt ni nh nj nk aw nl bi"><span id="b0f5" class="nm mi it nh b gy nn no l np nq">$ git submodule foreach npm install</span></pre><h2 id="89c4" class="nm mi it bd mj ns nt dn mn nu nv dp mr ld nw nx mt lh ny nz mv ll oa ob mx oc bi translated">跟踪子模块提交引用</h2><p id="7955" class="pw-post-body-paragraph ku kv it kw b kx mz ju kz la na jx lc ld nb lf lg lh nc lj lk ll nd ln lo lp im bi translated">假设您对<code class="fe ne nf ng nh b">sdk</code>的一个子模块进行了修改。您添加并提交您的更改，然后返回到<code class="fe ne nf ng nh b">sdk</code>的根。如果您运行<code class="fe ne nf ng nh b">git status</code>，您将看到以下内容:</p><pre class="kj kk kl km gt ni nh nj nk aw nl bi"><span id="e700" class="nm mi it nh b gy nn no l np nq">$ git status<br/>On branch main<br/>Changes not staged for commit:<br/>  (use "git add &lt;file&gt;..." to update what will be committed)<br/>  (use "git restore &lt;file&gt;..." to discard changes in working directory)<br/>        modified:   compiler (new commits)</span></pre><p id="9fbd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Git现在告诉您，您的一个子模块中的当前提交与您之前的状态不同。您需要将更改的子模块添加到git跟踪中，然后提交更新，您的消息可能是“更新的子模块版本”。一个非常常见的错误是推送错误的子模块引用，因此跟踪您希望每个子模块指向的提交/分支非常重要。</p><h2 id="a431" class="nm mi it bd mj ns nt dn mn nu nv dp mr ld nw nx mt lh ny nz mv ll oa ob mx oc bi translated">克隆项目，包括其子模块</h2><p id="d492" class="pw-post-body-paragraph ku kv it kw b kx mz ju kz la na jx lc ld nb lf lg lh nc lj lk ll nd ln lo lp im bi translated">当您下载一个包含子模块的git存储库时，默认情况下您不会下载子模块。如果<code class="fe ne nf ng nh b">sdk</code>项目被公开托管在GitHub上，并且您将<code class="fe ne nf ng nh b">sdk</code>项目克隆到您自己的机器上，您将不会获得它的任何子项目。您将获得文件夹引用，但没有其他内容。</p><pre class="kj kk kl km gt ni nh nj nk aw nl bi"><span id="1784" class="nm mi it nh b gy nn no l np nq">$ git clone git@github.com:Some-User/sdk.git<br/>$ cd sdk/compiler<br/>$ ls<br/>$        # nothing here</span></pre><p id="fc93" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">要克隆包含其子模块的所有文件的项目，您可以使用<code class="fe ne nf ng nh b">--recurse-submodules</code>标志进行克隆，或者在克隆<code class="fe ne nf ng nh b">sdk</code>之后运行<code class="fe ne nf ng nh b">git submodule update --init</code>。两者都将完成拉下所有相关文件的任务。</p></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><h1 id="6ef8" class="mh mi it bd mj mk ml mm mn mo mp mq mr jz ms ka mt kc mu kd mv kf mw kg mx my bi translated">Git子模块突出显示</h1><p id="bb24" class="pw-post-body-paragraph ku kv it kw b kx mz ju kz la na jx lc ld nb lf lg lh nc lj lk ll nd ln lo lp im bi translated">正如您所看到的，git子模块不同于一般的包管理器。它们允许您链接到git存储库，但仍然将它们视为单独的项目。Git子模块实际上在过去已经收到了相当多的负面反馈，但是我认为最重要的是要客观地了解子模块提供了什么，以及它们是否适合您的下一个项目。</p><ul class=""><li id="6ff9" class="od oe it kw b kx ky la lb ld of lh og ll oh lp oi oj ok ol bi translated">允许链接git存储库以便于访问</li><li id="0d5e" class="od oe it kw b kx om la on ld oo lh op ll oq lp oi oj ok ol bi translated">命令可以一次跨多个存储库运行</li><li id="a1a0" class="od oe it kw b kx om la on ld oo lh op ll oq lp oi oj ok ol bi translated">可以高精度地维护存储库版本</li><li id="68c6" class="od oe it kw b kx om la on ld oo lh op ll oq lp oi oj ok ol bi translated">版本跟踪通常变得更具描述性</li><li id="820b" class="od oe it kw b kx om la on ld oo lh op ll oq lp oi oj ok ol bi translated">源代码可以在存储库之间共享</li><li id="a1fa" class="od oe it kw b kx om la on ld oo lh op ll oq lp oi oj ok ol bi translated">将许多存储库作为一个存储库分发</li></ul><h2 id="99b5" class="nm mi it bd mj ns nt dn mn nu nv dp mr ld nw nx mt lh ny nz mv ll oa ob mx oc bi translated">一些需要考虑的事情</h2><ul class=""><li id="61bb" class="od oe it kw b kx mz la na ld or lh os ll ot lp oi oj ok ol bi translated">额外的版本控制复杂性会增加错误</li><li id="fce9" class="od oe it kw b kx om la on ld oo lh op ll oq lp oi oj ok ol bi translated">子模块更新机制不会删除过时的子模块</li></ul></div><div class="ab cl ma mb hx mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="im in io ip iq"><p id="1d6d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果你对git子模块有自己喜欢/不喜欢的地方，或者如果你对本文的任何部分感兴趣，请在评论中分享你的想法！如果你想直接支持我的写作，你可以使用下面我的推荐链接注册。感谢阅读！</p><div class="ou ov gp gr ow ox"><a href="https://israel-miles.medium.com/membership" rel="noopener follow" target="_blank"><div class="oy ab fo"><div class="oz ab pa cl cj pb"><h2 class="bd iu gy z fp pc fr fs pd fu fw is bi translated">通过我的推荐链接加入Medium以色列万里行</h2><div class="pe l"><h3 class="bd b gy z fp pc fr fs pd fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="pf l"><p class="bd b dl z fp pc fr fs pd fu fw dk translated">israel-miles.medium.com</p></div></div><div class="pg l"><div class="ph l pi pj pk pg pl ks ox"/></div></div></a></div></div></div>    
</body>
</html>