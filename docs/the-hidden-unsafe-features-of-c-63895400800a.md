# C#隐藏的不安全特性

> 原文：<https://levelup.gitconnected.com/the-hidden-unsafe-features-of-c-63895400800a>

## 使用指针、破坏类型安全以及非托管世界中的各种乐趣

![](img/d651519bc4a4ff9ffbffcc9100db5945.png)

迪安·普在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上的照片

在过去的几年里，C#已经成为现代软件开发的主流语言之一。在 [Stack Overflow 的 2019 年开发者调查](https://insights.stackoverflow.com/survey/2019#technology)中，它在业余爱好者和专业程序员中排名第七。

随着 ASP.NET 核心和实体框架等突出技术在。NET 生态系统中，这种语言已经稍微转向了 web 和云本地开发。结合持续不断的对运行时的改进，C#已经牢固地确立了自己作为一种可靠的主流语言的地位，几乎可以用来编写任何应用程序。

你几乎会忘记，就在几年前，C#主要用于编写桌面或工作站应用程序，它与 Windows 平台紧密耦合，并且必须与其许多遗留的 Win32 组件互操作。

正因为如此，C#语言包含了一些大多数开发人员不再日常使用的构造，但是仍然非常强大。例如，你知道 C#支持*指针*吗？你知道你可以破坏类型安全吗？

在本文中，我们将深入探讨 C#和。NET 运行时。我们将做一些有趣的、不稳定的事情，比如破坏类型安全、处理指针、使用封送拆收器和不安全的强制转换将对象直接转换成字节数组。

值得注意的是，本文中解释的一些概念需要一些 C#知识，一些概念的背景知识(如垃圾收集、托管运行时)可能会有用。

# 托管和非托管

在我们深入研究这些特性之前，理解*托管*和*非托管*代码的概念是很重要的。根据定义，托管代码是作为公共语言运行时(CLR)的一部分运行的代码。CLR 为我们管理很多事情，比如垃圾收集、异常处理、内存管理等等。

托管代码是在 CLR 的“虚拟机”边界内运行的任何代码。这是一个有围墙的花园，里面一切都很整洁。东西一般不会坏，但一旦坏了，就优雅地坏了。这与可怕的、*非托管的*世界形成了鲜明的对比，在这个世界中，指针可能摇摆不定，异常可能无法处理，内存可能开始泄漏。

每当我们写 C#代码时，我们通常都呆在这个有围墙的花园里。我们不必为任何细节而烦恼，比如内存管理和清理我们身后的资源。我们已经处理好了。

然而，如前所述，因为 C#传统上必须与操作系统内的遗留的、非托管的组件进行交互，所以它确实提供了离开这个围墙花园的选项，并与外部世界进行交互。支持这一点的编译器标志被恰当地命名为`/unsafe`。

本文中几乎所有的代码都只能使用`/unsafe`编译器标志进行编译。今天我们将走出 CLR 的界限。

# 有指针

正如简介中提到的， [C#完全支持指针](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/unsafe-code-pointers/pointer-types)。您可以获取指向任何非托管类型(如基元类型)以及大多数不包含引用类型的结构的指针。

这意味着下面这段代码完全有效:

让我们一步一步来。我们首先像平常一样创建一个新的`Vector3`，通过引用将其传递给`Foo`，然后它对其成员进行一些添加，并写入控制台。

为了让 C#能够获得指向一个对象的指针，它需要通过引用来传递。在上面的例子中，这是通过`ref Vector3 vec`声明完成的。如果那个`ref`不在那里，它将简单地通过值传递。

`fixed`语句是 C#中很少使用的语句，它防止垃圾收集器重新定位变量，例如在垃圾收集器的压缩阶段。当我们获得一个指向向量的指针时，我们希望确保垃圾收集器在我们使用向量时不会改变它的位置——否则我们可能会冒着读取垃圾的风险。

当操作指针类型时，C#支持 C 风格的箭头符号`->`去引用和访问指针的成员。然后，您可以像平常一样使用或修改对象的成员。

## 这个什么时候有用？

在 C#中，指针有很多用处，尽管由于固定对象和缓冲区的内在要求，它并不总是像 C/C++中的指针那样高效。

使用指针实际上有用的一个例子是与`Marshal`结合使用。封送处理充当托管和非托管领域之间的看门人，有一系列非常有用的方法用于将托管类型转换为非托管类型、分配内存等。

假设我们想在一个非托管应用程序中使用我们之前创建的`Vector3`实例。我们需要某种方法将托管向量转换成非托管表示。JSON 等流行的序列化技术是一种选择，但是我们也可以简单地使用`Marshal`来创建一个表示我们的向量的字节数组:

封送器本质上做的是获取我们的托管 vector 实例，并将其序列化为非托管的`byte[]`。这相对较快，并且允许通过例如网络连接发送原始形式的矢量。

虽然这是一种将托管类型转换为非托管字节数组的非常有效且相对快速的方法，但也有一些限制。首先，封送处理要求它处理的每个类型都是[可直接复制到本机结构中的](https://en.wikipedia.org/wiki/Blittable_types)。这意味着该类型在托管和非托管环境中具有相同的字节表示形式。大多数原始类型都是可直接复制到本机结构中的，但是字符串和几乎所有复杂类型都不是。

这严重限制了封送处理的用途，并使 JSON 等常见的序列化技术在大多数用例中更加可行。但是对于那些只传输原语的情况，它可以非常快。

![](img/040626cba678e3b145891ea8bbbef2f1.png)

照片由 [Ariel Besagar](https://unsplash.com/@arielbeagar?utm_source=medium&utm_medium=referral) 在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄

# 堆栈分配

另一个很少使用的特性是`stackalloc`操作符。顾名思义，`stackalloc`在堆栈上分配一块内存。当方法返回时，该块被自动丢弃，并且不能被显式释放。

与常规的内存分配不同，堆栈分配的内存块不受垃圾收集的影响，出于同样的原因，它们不需要使用我们在上一节中讨论的`fixed`关键字来固定。

如果我们看一下上一节中的例子，在这个例子中，我们将`Vector3`转换成一个字节数组，我们用`new byte[]`初始化这个字节数组——它在堆上分配这个字节数组。

因为我们提前知道我们的向量不会特别大，我们可以通过使用`stackalloc`在堆栈上分配我们的缓冲区来放弃这种分配:

通过在堆栈上直接分配向量所需的 12 个字节，这为我们节省了堆分配。与堆分配相比，堆栈分配在性能方面要便宜得多。

对于眼尖的人来说，由于对`buffer.ToArray();`的调用，堆栈分配的缓冲区仍然被分配在堆上，这使得一开始就在堆栈上分配缓冲区变得毫无意义。理想情况下，您不会将缓冲区返回给调用者。相反，它将在方法本身中被消耗。

## 这个什么时候有用？

虽然堆栈分配比堆分配便宜得多，但在大多数应用程序中，它们通常不是您应该关心的事情。许多应用程序在运行时执行大量的堆分配，在大多数情况下，垃圾收集器可以很好地处理它。

当你分配大量相对较小的缓冲区时，使用`stackalloc`会大放异彩——例如当你处理底层网络代码时。在这种情况下，使用堆栈分配的缓冲区可以大大减少垃圾收集器的压力，因为它可以避免无数次生命周期非常短的小分配。

值得注意的是，从 C# 7.2 开始，`Span<T>` `Memory<T>`和`ReadOnlySpan<T>`类型使得访问连续内存块变得更加容易，并且它们是访问内存块的首选方法。

更多信息参见`[stackalloc](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/stackalloc)`[操作员文档](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/stackalloc)。

# 不安全的类型

当操作指针时，我们可以更进一步。像 C++这样的语言允许我们使用`reinterpret_cast<T>`将指针转换成任何类型，但在 C#中，我们受到语言类型安全的限制。

然而，这种限制在 C#编译成的中间语言(简称 IL)中并不存在。例如，在 IL 中，将指针转换为类型可以表示为:

这实际上是将`source`指针表示为`!!T`——本质上相当于 C++中的`reinterpret_cast<T>`。这开启了一个全新的可能性领域。

本节中的代码使用了`CompilerServices.Unsafe`包，它可以从 NuGet 获得，并且主要在 IL 中实现。使用`Unsafe`类型，我们可以用少得多的代码将向量与缓冲区相互转换:

但是这样做的话，我们无法保证我们所做的造型是有效的。然而，与我们之前讨论的`Marshal`相比，这种方法要快得多，因为它放弃了通常需要的所有类型检查。

为了进行演示，请考虑如果我们执行以下代码会发生什么:

```
int a = 1;bool b = (bool) a;
```

那不会编译，对吧？尽管在内存中，`bool`被表示为 1 或 0，但在 C#中，我们不能在没有编译器错误的情况下将`int`转换为`bool`，因为这会破坏类型安全。

然而，我们可以用`Unsafe`:

执行时，上面的代码会编译，它会输出`False`。

## 这个什么时候有用？

当您需要读写非托管缓冲区时，性能是您关心的唯一最重要的指标。您必须自己考虑运行时通常为您提供的所有类型安全，但是如果操作正确，这可能会产生一些非常好的优化代码。

它也比通过前面几节中概述的封送处理运行基元类型快得多。

# 结论

当您指定了`/unsafe`编译器标志时，您获得了很大的权力。直接使用指针、堆栈分配和固定对象的能力为优化开辟了一个全新的领域。

然而，这就是 C#世界中众所周知的龙*所在的地方。诚然，它们是相对温顺的龙，但你仍然可以用你通常不会用的方式搬起石头砸自己的脚。*

就我个人而言，我曾广泛使用 C#中的非托管资源，我看到代码的执行方式没有一点点`unsafe`魔力是不可能的。虽然类型系统通常是一个很好的安全网，但是在非常特殊的情况下能够避开它是一个非常强大的选择。在我看来，这是每个 C#程序员都应该知道的一个选项。

我希望这篇文章对你有帮助，如果你有任何问题或者喜欢这类内容，请告诉我。这篇文章只是我们的尝试，如果有足够的兴趣，还有很多很多东西可以写。

感谢您的阅读！