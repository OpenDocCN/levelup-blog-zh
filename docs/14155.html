<html>
<head>
<title>A case for Go code generation: testify</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go代码生成的一个例子:证明</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/a-case-for-go-code-generation-testify-73a4b0d46cb1?source=collection_archive---------5-----------------------#2022-11-06">https://levelup.gitconnected.com/a-case-for-go-code-generation-testify-73a4b0d46cb1?source=collection_archive---------5-----------------------#2022-11-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="4eb7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你使用Go已经有一段时间了，你可能对测试库<a class="ae kl" href="https://github.com/stretchr/testify" rel="noopener ugc nofollow" target="_blank">stretchr/evidence</a>很熟悉。它使编写测试变得容易，并提供了几个断言函数，如<code class="fe km kn ko kp b">Equal</code>、<code class="fe km kn ko kp b">Contains</code>、<code class="fe km kn ko kp b">Greater</code>和<a class="ae kl" href="https://pkg.go.dev/github.com/stretchr/testify/assert#pkg-functions" rel="noopener ugc nofollow" target="_blank">等等</a>。</p><p id="cd07" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">断言函数的行为因作用域而异。例如，当从<code class="fe km kn ko kp b">assert</code>或<code class="fe km kn ko kp b">require</code>包调用时。前者记录错误并继续，而后者立即停止测试。这两个包提供了相同的函数签名。断言也被称为来自封装了<code class="fe km kn ko kp b">*testing.T</code>指针的<code class="fe km kn ko kp b">suite</code>结构的方法。并且每个断言都有一个带有后缀<code class="fe km kn ko kp b">*f</code>和附加(<code class="fe km kn ko kp b">msg string, params ...interface{}</code>)参数的格式化副本。</p><p id="6c32" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这给我们留下了断言函数的三个维度:静态函数、套件方法和格式化。共有八种不同版本的<strong class="jp ir">每种功能</strong>:</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi kq"><img src="../Images/1f68b46558d50d2f0430da17fc6c64cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-p5oOYlfpbQL8JJ-kLSnQw.png"/></div></div><figcaption class="lc ld gj gh gi le lf bd b be z dk translated">的所有实现的示例。平等的</figcaption></figure><p id="fdbd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是一个有趣的代码生成案例。看起来我们可以将所有函数作为规范断言实现的包装器来实现。它主要是重复的或样板代码，否则手工编写会很乏味。不出所料，这正是该软件包的作用。</p><p id="e5d2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这篇文章的其余部分是一个大脑转储，因为我通过代码，试图理解如何作证内部工作，以及他们如何组织他们的代码使用代码生成。</p><h1 id="868f" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">例:<code class="fe km kn ko kp b">Equal</code>功能</h1><p id="22b3" class="pw-post-body-paragraph jn jo iq jp b jq me js jt ju mf jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">让我们先来看看<code class="fe km kn ko kp b">Equal</code>函数，以及<code class="fe km kn ko kp b">assert</code>和<code class="fe km kn ko kp b">require</code>的行为有何不同:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="5064" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe km kn ko kp b">.Equal</code>的底层实现是一样的。在<code class="fe km kn ko kp b">assert</code>或<code class="fe km kn ko kp b">require</code>实施中，比较两个值并提供文本输出不应改变。这里改变的是测试的流程。它要么停止，要么记录错误并继续前进。</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="861e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe km kn ko kp b">assert.Equal</code>函数是<code class="fe km kn ko kp b">Equal</code>的规范实现。</p><blockquote class="ml mm mn"><p id="163f" class="jn jo mo jp b jq jr js jt ju jv jw jx mp jz ka kb mq kd ke kf mr kh ki kj kk ij bi translated"><em class="iq">除了</em> <code class="fe km kn ko kp b"><em class="iq">ObjectsAreEqual</em></code> <em class="iq">函数之外，我将不再详述如何进行比较。让我们关注周围的代码，以及在代码库中的其他地方是如何调用它的。</em></p></blockquote><p id="7855" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里需要注意的重要一点是，<code class="fe km kn ko kp b">assert.*</code>函数返回一个<code class="fe km kn ko kp b">bool</code>。他们的对手<code class="fe km kn ko kp b">require.*</code>利用了这一点。</p><p id="734c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe km kn ko kp b">require.Equal</code>看起来和你想象的完全一样:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="0c6a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它包装<code class="fe km kn ko kp b">assert.Equal</code>函数，并在断言失败时调用<code class="fe km kn ko kp b">t.FailNow()</code>(返回<code class="fe km kn ko kp b">false</code>)。</p><p id="b5f0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每个断言函数都是如此。与其为每个断言编写样板函数签名，不如让我们看看他们如何使用模板来生成函数体。</p><h1 id="16a1" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">断言函数模板</h1><p id="ea64" class="pw-post-body-paragraph jn jo iq jp b jq me js jt ju mf jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated"><strong class="jp ir">要求打包</strong></p><p id="68a6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe km kn ko kp b">require</code>包中的每个函数都有相同的样板代码。它必须(1)调用<code class="fe km kn ko kp b">assert.*</code>函数；以及(2)如果断言返回假，则测试失败。</p><pre class="kr ks kt ku gt ms kp mt mu aw mv bi"><span id="5bc0" class="mw lh iq kp b gy mx my l mz na">{{.Comment}}<br/>func {{.DocInfo.Name}}(t TestingT, {{.Params}}) {<br/>	if h, ok := t.(tHelper); ok { h.Helper() }<br/>	if assert.{{.DocInfo.Name}}(t, {{.ForwardedParams}}) {<br/>                return<br/>        }<br/>        t.FailNow()<br/>}</span></pre><blockquote class="ml mm mn"><p id="5b1f" class="jn jo mo jp b jq jr js jt ju jv jw jx mp jz ka kb mq kd ke kf mr kh ki kj kk ij bi translated"><em class="iq">注意，这里还调用了一个</em> <code class="fe km kn ko kp b"><em class="iq">Helper()</em></code> <em class="iq">函数。它们用于内部测试，所以为了这篇博文的篇幅，我们可以忽略这一点。</em></p></blockquote><p id="c0f3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">套件方法</strong></p><p id="da8c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为这些断言是suite结构中的方法，所以它们需要一个接收者，这个接收者在<code class="fe km kn ko kp b">.Assert()</code>和<code class="fe km kn ko kp b">.Require()</code>结构上都是<code class="fe km kn ko kp b">*Assertion</code>类型。</p><pre class="kr ks kt ku gt ms kp mt mu aw mv bi"><span id="5309" class="mw lh iq kp b gy mx my l mz na">{{.CommentWithoutT "a"}}<br/>func (a *Assertions) {{.DocInfo.Name}}({{.Params}}) {<br/>	if h, ok := a.t.(tHelper); ok { h.Helper() }<br/>	{{.DocInfo.Name}}(a.t, {{.ForwardedParams}})<br/>}</span></pre><p id="0644" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">格式功能</strong></p><p id="cdff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">他们只对<code class="fe km kn ko kp b">assert</code>包使用格式函数模板。所有其他格式都是基于<code class="fe km kn ko kp b">assert</code>包函数生成<em class="mo">，包括带前缀的格式。这就是为什么你只能在<code class="fe km kn ko kp b">assert</code>包中找到一个格式化模板。</em></p><pre class="kr ks kt ku gt ms kp mt mu aw mv bi"><span id="8ef5" class="mw lh iq kp b gy mx my l mz na">{{.CommentFormat}}<br/>func {{.DocInfo.Name}}f(t TestingT, {{.ParamsFormat}}) bool {<br/>	if h, ok := t.(tHelper); ok { h.Helper() }<br/>	return {{.DocInfo.Name}}(t, {{.ForwardedParamsFormat}})<br/>}</span></pre><p id="fe84" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意函数名声明末尾的<code class="fe km kn ko kp b">f</code>后缀。</p><p id="7779" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">结合这三个模板，可以生成<code class="fe km kn ko kp b">testify</code>提供的所有功能布局:</p><ol class=""><li id="ae2f" class="nb nc iq jp b jq jr ju jv jy nd kc ne kg nf kk ng nh ni nj bi translated">使用<code class="fe km kn ko kp b">*f</code>模板生成基于规范<code class="fe km kn ko kp b">assert</code>实现的格式函数。</li><li id="d0a9" class="nb nc iq jp b jq nk ju nl jy nm kc nn kg no kk ng nh ni nj bi translated">使用<code class="fe km kn ko kp b">require</code>模板生成包装函数<code class="fe km kn ko kp b">assert</code>函数。</li><li id="8ad5" class="nb nc iq jp b jq nk ju nl jy nm kc nn kg no kk ng nh ni nj bi translated">使用suite方法模板生成带有<code class="fe km kn ko kp b">*Assertions</code>接收器的函数，该接收器包装对<code class="fe km kn ko kp b">assert.*</code>和<code class="fe km kn ko kp b">require.*</code>函数的调用。</li></ol><h1 id="68d7" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">编码发生器</h1><p id="b3d5" class="pw-post-body-paragraph jn jo iq jp b jq me js jt ju mf jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated"><code class="fe km kn ko kp b">_codegen</code>文件夹下有一个单独的生成器文件，所有的函数类型都使用这个文件。使用标志参数从每个包中调用它。例如，用来生成<code class="fe km kn ko kp b">require.*</code>函数的命令:</p><pre class="kr ks kt ku gt ms kp mt mu aw mv bi"><span id="5aca" class="mw lh iq kp b gy mx my l mz na">//go:generate sh -c "cd ../_codegen &amp;&amp; go build &amp;&amp; cd - &amp;&amp; ../_codegen/_codegen -output-package=require -template=require.go.tmpl -include-format-funcs"</span></pre><p id="c2b4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">代码生成脚本很少是简单的。它们通常需要你在头脑中有一个大的背景来思考它们。通过向生成器提供标志，他们抽象出了为每种格式提供特定生成的问题。每个模板接收相同的数据结构，以确定如何转发参数。这对于保持发电机不可知是很重要的。</p><p id="eff3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">关于代码生成脚本如何工作，还有更多内容，但是我认为在这里遍历这个逻辑是没有用的。理解他们的方法最重要的部分是看这个结构:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="009a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">解析<code class="fe km kn ko kp b">pkg</code>输入文件(默认指向<code class="fe km kn ko kp b">assert</code>)输出一片<code class="fe km kn ko kp b">testFunc</code>。这些元素中的每一个都用于生成一个基于模板的对应函数。该结构提供了一些帮助器函数来构建参数和形参:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="eed1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">根据名字，你可以很容易地猜出他们是做什么的。</p><p id="62e7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">代码生成很复杂，但这是一种隐藏的复杂性，不会蔓延到库代码的其他部分。一旦构建了解析代码，就不太可能需要修改。</p><h1 id="2185" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">另一种方法</h1><p id="bb44" class="pw-post-body-paragraph jn jo iq jp b jq me js jt ju mf jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">代码生成很有趣，但是当我问自己是否真的需要时，答案往往是否定的。但是它留下了一个复杂的生成器函数，通常未经测试，使用混乱的逻辑。</p><p id="bb65" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每当我觉得需要使用代码生成时，我会问自己，我试图解决的问题是不是人为的问题。如果是现实问题，可以用其他方式解决吗？让我们将这一推理应用于作证包:</p><p id="54b4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里使用代码生成有三个主要原因。相同的断言函数可以提供不同的风格:</p><ol class=""><li id="2bb2" class="nb nc iq jp b jq jr ju jv jy nd kc ne kg nf kk ng nh ni nj bi translated"><strong class="jp ir">静态函数vs方法:</strong>在包装<code class="fe km kn ko kp b">*testing.T</code>的struct上提供函数或方法是一个人为的问题。固执己见的方法是只提供方法。</li><li id="b955" class="nb nc iq jp b jq nk ju nl jy nm kc nn kg no kk ng nh ni nj bi translated"><strong class="jp ir">带格式和不带格式:</strong>这似乎是一个合理的问题，但是除了提供不同的函数后缀之外，还有其他的解决方案。</li><li id="4b38" class="nb nc iq jp b jq nk ju nl jy nm kc nn kg no kk ng nh ni nj bi translated"><strong class="jp ir"> Fail fast: </strong>也是一个合法的特性，但是可以用比提供不同的包作用域函数更简单的构造来解决。</li></ol><blockquote class="ml mm mn"><p id="ff62" class="jn jo mo jp b jq jr js jt ju jv jw jx mp jz ka kb mq kd ke kf mr kh ki kj kk ij bi translated">添加格式化函数(2)的原因似乎是源于在作证消息<a class="ae kl" href="https://github.com/stretchr/testify/issues/339" rel="noopener ugc nofollow" target="_blank">https://github.com/stretchr/testify/issues/339</a>中使用格式化参数的代码基中的<code class="fe km kn ko kp b">go vet</code>错误。</p></blockquote><p id="e409" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">作为一个思考练习，这里有一个不需要代码生成就可以构建的替代方案:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="3b91" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们接受(1)是一个人为的问题，并且只提供方法，那么您可以使用构建器模式来设计断言。断言属于一个<code class="fe km kn ko kp b">assertion</code>结构，该结构具有配置控制流行为的功能。</p><p id="e806" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是一个断言结构的原型，它符合该接口，并将格式和流属性作为测试上下文的一部分:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="mj mk l"/></div></figure><blockquote class="ml mm mn"><p id="200d" class="jn jo mo jp b jq jr js jt ju jv jw jx mp jz ka kb mq kd ke kf mr kh ki kj kk ij bi translated"><em class="iq">值得一提的是，这并不是一个严肃的实现，这更像是一个关于如何构建</em>的思考练习。这里缺少一些功能，比如提供对 <code class="fe km kn ko kp b"><em class="iq">*testing.B</em></code> <em class="iq">调用的支持，以及其他我现在看不到的用例。</em></p></blockquote><h1 id="ea59" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">权衡取舍</h1><p id="6f0e" class="pw-post-body-paragraph jn jo iq jp b jq me js jt ju mf jw jx jy mg ka kb kc mh ke kf kg mi ki kj kk ij bi translated">我认为这里最大的权衡是:复杂性从<code class="fe km kn ko kp b">testify</code>包转移到了客户端测试代码。使用evidence编写测试极其简单。在我写了几次测试之后，我很少打开他们的文档。与其他测试库相比，这是一种独特的体验。例如JavaScript的chai，我经常忘记我应该写断言的顺序和惯用方式。</p><p id="8586" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是作证的一大特点。好的库是那些你不需要考虑太多的库，它们就是工作。</p><p id="096c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">代码生成路径给库开发人员留下了维护负担，但它可能会简化包API，从而使采用更快。我认为<code class="fe km kn ko kp b">testify</code>开发人员可能做出了正确的决定，为用户简化了这一点，即使这冒着使他们工具的可维护性复杂化的风险。</p><p id="eb25" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">毕竟，在一个地方拥有所有的复杂性总比到处都有一点复杂性要好。</p></div></div>    
</body>
</html>