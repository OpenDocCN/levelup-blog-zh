<html>
<head>
<title>Using Rust to implement WebDav sync</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Rust实现WebDav同步</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/using-rust-to-implement-webdav-sync-502735b27cb0?source=collection_archive---------11-----------------------#2020-06-15">https://levelup.gitconnected.com/using-rust-to-implement-webdav-sync-502735b27cb0?source=collection_archive---------11-----------------------#2020-06-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/d8eb8494c8d4be2e0560482f8b862136.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8e_XZzoRgRbKR_dZ"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">由<a class="ae kc" href="https://unsplash.com/@ptrikutam?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">帕万·特里库塔姆</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="7fa7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这里，在Rust中找到一个简单而有效的应用程序，它将目录与WebDav服务器同步。</p><h2 id="1d8d" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">为什么生锈？</h2><p id="6fb2" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">去年我听说了Rust，并对它的承诺很感兴趣。作为一名前C++开发人员，我理解像C++这样的编译语言给你带来的好处。性能、快速启动时间、与其他语言相比较小的二进制文件。</p><p id="fad4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我也理解C++的缺点。与其他语言相比，处理内存管理、运行边界检查器、硬崩溃、复杂性。当然，它有智能指针，它们当然有帮助，但是保持头文件与源文件同步总是不愉快的。微软世界里也有一些像MFC、ATL这样过于复杂的库。</p><p id="a0ea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我第一次看到Java并开始用它编程时，我对它的简单性感到很满意。再也不用担心崩溃了(除非JVM真的耗尽了内存)。垃圾收集器可以在很大程度上保护你不搬起石头砸自己的脚。但是对于大型应用程序，您仍然需要担心GC周期何时运行，因为它可能会使您的应用程序停止。随着时间的推移，Java的一些优雅已经被Spring这样的畸形库所掩盖。</p><p id="eb16" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像Ruby(和Ruby on Rails)和Python这样的语言可以让事情变得非常简单。有机会在RoR编程一年多之后，我对其他一些较新的语言产生了兴趣，比如Rust。</p><p id="490c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我已经用Rust编写了一个简单的程序，它的性能给我留下了非常深刻的印象。我想尝试更多的功能。</p><h2 id="db00" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">WebDav和Rust通知</h2><p id="f0aa" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">WebDav是20世纪90年代对HTTP协议的扩展，可用于提供文件服务。添加的一些命令包括复制、重命名、移动和MKCOL(像<code class="fe lz ma mb mc b">mkdir</code>)。WebDav有一个Rust客户端库。</p><p id="17be" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Rust还有一个名为Notify的模块，它是一个基本的文件系统监视器。</p><p id="253a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我可以将Rust文件系统监视器与WebDav协议结合起来，并在两者之间同步文件，会怎么样？</p><h2 id="10b4" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">Rust库</h2><p id="5d8d" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">幸运的是，Rust似乎有一个很好的社区来提供支持。在他们的API文档、Rust " <a class="ae kc" href="https://doc.rust-lang.org/book/title-page.html" rel="noopener ugc nofollow" target="_blank"> book </a>"、stackoverflow.com以及一些幸运的谷歌搜索之间，你通常可以得到你需要的帮助。</p><p id="212e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Rust的WebDav客户端叫做<a class="ae kc" href="https://docs.rs/hyperdav/0.2.0/hyperdav/" rel="noopener ugc nofollow" target="_blank"> hyperdav </a>。文件系统观察器组件被称为<a class="ae kc" href="https://docs.rs/notify/4.0.15/notify/" rel="noopener ugc nofollow" target="_blank">通知</a>。</p><h2 id="8dfd" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">WebDav设置</h2><p id="81a3" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">对于WebDav，有来自不同供应商的多种实现。我想要免费的东西。我在T21的dockerhub上找到了一个。下面是启动它的示例命令(需要Docker)。这在内部使用Apache HTTP的webdav支持。</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="f6a2" class="lb lc iq mc b gy ml mm l mn mo">docker run --restart always -v /tmp/webdav:/var/lib/dav \<br/>    -e AUTH_TYPE=Basic -e USERNAME=YOUR_USERNAME \<br/>    -e PASSWORD=YOUR_PASSWORD \<br/>    --publish 80:80 -d bytemark/webdav</span></pre><p id="6124" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于上述内容，您最有可能改变的是:</p><ul class=""><li id="277d" class="mp mq iq kf b kg kh kk kl ko mr ks ms kw mt la mu mv mw mx bi translated">提供文件的本地路径。我用了<code class="fe lz ma mb mc b">/tmp/webdav</code></li><li id="b80c" class="mp mq iq kf b kg my kk mz ko na ks nb kw nc la mu mv mw mx bi translated">用户名(您的用户名)</li><li id="6eb6" class="mp mq iq kf b kg my kk mz ko na ks nb kw nc la mu mv mw mx bi translated">密码(您的_密码)</li></ul><p id="9991" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您的计算机上运行的是另一个HTTP服务器，您可能还想更改端口80。</p><p id="4abd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">启动后，请确保您可以从浏览器访问它，并且它会提示您输入凭据。也可以使用CyberDuck这样的客户端进行连接。您可以使用Docker“Dashboard”来查看日志，并对连接到WebDav的任何错误进行故障排除。</p><h1 id="38c4" class="nd lc iq bd ld ne nf ng lg nh ni nj lj nk nl nm lm nn no np lp nq nr ns ls nt bi translated">编写应用程序</h1><p id="3c51" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">第一件事是确保您可以在文件更改时接收事件。为了简单起见，从处理<code class="fe lz ma mb mc b">Create</code>和<code class="fe lz ma mb mc b">Write</code>事件开始。注意<code class="fe lz ma mb mc b">write_file</code>方法是调用WebDav的占位符。</p><figure class="md me mf mg gt jr"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="ed89" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">分解一下，现在的情况是:</p><ol class=""><li id="e696" class="mp mq iq kf b kg kh kk kl ko mr ks ms kw mt la nw mv mw mx bi translated">创建观察器，并通过<code class="fe lz ma mb mc b">watch</code>方法告诉它开始观察。</li><li id="b19b" class="mp mq iq kf b kg my kk mz ko na ks nb kw nc la nw mv mw mx bi translated">在接收通道上监听<code class="fe lz ma mb mc b">match</code>的任何输入事件。</li><li id="350c" class="mp mq iq kf b kg my kk mz ko na ks nb kw nc la nw mv mw mx bi translated">如果发生<code class="fe lz ma mb mc b">Create</code>或<code class="fe lz ma mb mc b">Write</code>事件，尝试<code class="fe lz ma mb mc b">write_file</code>。如果失败，打印一个错误。</li><li id="e5cc" class="mp mq iq kf b kg my kk mz ko na ks nb kw nc la nw mv mw mx bi translated">其他事件将被忽略，并转到默认的无操作情况。</li></ol><p id="9156" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还可以观看其他事件，包括<code class="fe lz ma mb mc b">Chmod</code>、<code class="fe lz ma mb mc b">Remove</code>和<code class="fe lz ma mb mc b">Rename</code>。</p><h2 id="27f3" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">写入WebDav</h2><p id="620f" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">这是大部分核心逻辑所在。</p><figure class="md me mf mg gt jr"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="b2e2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里的情况是:</p><ol class=""><li id="4492" class="mp mq iq kf b kg kh kk kl ko mr ks ms kw mt la nw mv mw mx bi translated">打开本地文件系统上的文件，我们将把它发送到WebDav并创建一个<code class="fe lz ma mb mc b">BufReader</code>。</li><li id="2b05" class="mp mq iq kf b kg my kk mz ko na ks nb kw nc la nw mv mw mx bi translated">构建一个<code class="fe lz ma mb mc b">Vec&lt;String&gt;</code>来保存我们将要创建的文件的路径部分(<code class="fe lz ma mb mc b">make_path_vec</code>)。</li><li id="05a0" class="mp mq iq kf b kg my kk mz ko na ks nb kw nc la nw mv mw mx bi translated">构建一个包含文件完整路径(包括文件名)的<code class="fe lz ma mb mc b">path_and_file_vec</code></li><li id="bc78" class="mp mq iq kf b kg my kk mz ko na ks nb kw nc la nw mv mw mx bi translated">用<code class="fe lz ma mb mc b">mkdir</code> (MKCOL)创建包含目录，然后在<code class="fe lz ma mb mc b">put_file</code>中调用<code class="fe lz ma mb mc b">PUT</code></li></ol><h2 id="e616" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">PUT和MKCOL方法</h2><p id="7f9d" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">这个<code class="fe lz ma mb mc b">PUT</code>调用非常简单。注意，路径部分需要一个<code class="fe lz ma mb mc b">Vec</code>。如果您试图传递类似于<code class="fe lz ma mb mc b">this/is/my/file.txt</code>的字符串，<code class="fe lz ma mb mc b">hyperdav</code>客户端将对路径进行URL编码，WebDav服务器将无法创建它，因此请确保您将路径部分分割成一个<code class="fe lz ma mb mc b">Vec</code>。</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="1a0f" class="lb lc iq mc b gy ml mm l mn mo">fn put_file(&amp;self, path_and_file_vec: Vec&lt;String&gt;, reader: BufReader&lt;File&gt;) {<br/>  match self.client.put(reader, path_and_file_vec) {<br/>    Err(err) =&gt; {<br/>      println!("problem writing file {}", err);<br/>    }<br/>    _ =&gt; (),<br/>  }<br/>}</span></pre><p id="c627" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lz ma mb mc b">MKCOL</code>调用稍微健壮一点，因为如果路径为空，它可以防止不必要的调用。</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="25b0" class="lb lc iq mc b gy ml mm l mn mo">fn mkdir(&amp;self, path_vec: Vec&lt;String&gt;) {<br/>  let pathstr = path_vec.join("/");<br/>  if pathstr.len() == 0 {<br/>    // nothing to do<br/>    return;<br/>  }<br/>  match self.client.mkcol(&amp;path_vec) {<br/>    Err(err) =&gt; {<br/>      println!("problem making directory '{}' {}", pathstr, err);<br/>    }<br/>    _ =&gt; (),<br/>  }<br/>}</span></pre><h2 id="4ada" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">主要入口点</h2><p id="86f5" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">主入口点确保用户通过使用<code class="fe lz ma mb mc b">clap</code>模块(用于命令行参数)传入有效变量，但也可选地支持<code class="fe lz ma mb mc b">stdin</code>。因为其中一个参数是密码，所以使用了另一个名为<code class="fe lz ma mb mc b">rpassword</code>的模块，用于在用户输入密码时隐藏密码。这个逻辑由一个通用的<code class="fe lz ma mb mc b">read_parameter</code>方法抽象。</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="22e4" class="lb lc iq mc b gy ml mm l mn mo">fn read_parameter(name: &amp;str, password: bool) -&gt; String {<br/>    let msg = format!("Enter {}: ", name);<br/>    if password {<br/>        rpassword::prompt_password_stdout(&amp;msg).unwrap()<br/>    } else {<br/>        println!("{}", msg);<br/>        let mut val = String::new();<br/>        match io::stdin().read_line(&amp;mut val) {<br/>            _ =&gt; String::from(val.trim_end()),<br/>        }<br/>    }<br/>}</span></pre><p id="502e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其他想法是通过Apple Keychain services存储和收集凭证信息(这是在Mac上完成的)，但将它保存到下一天。</p><h2 id="f1f1" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">技术性能分析</h2><p id="a2fe" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">可以通过检测代码来收集基本的性能指标。<code class="fe lz ma mb mc b">std::time</code>模块有一个<code class="fe lz ma mb mc b">Instant</code>结构，可用于收集持续时间以便计时。这显示了如何为<code class="fe lz ma mb mc b">PUT</code>操作打印出Kbps度量的示例。</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="af74" class="lb lc iq mc b gy ml mm l mn mo">let md = fs::metadata(pb)?;<br/>let size: u64 = md.len();<br/>let now = Instant::now();</span><span id="966c" class="lb lc iq mc b gy nx mm l mn mo">// make the PUT call<br/>self.put_file(path_and_file_vec, reader);</span><span id="64e5" class="lb lc iq mc b gy nx mm l mn mo">let duration = now.elapsed();<br/>let kbps = (size as u128 / duration.as_millis()) as f64 / 1000.0;<br/>println!(<br/>  "{:?} elapsed {} ms, {} Kbps, {} bytes",<br/>  thread::current().id(),<br/>  duration.as_millis(),<br/>  kbps,<br/>  size<br/>);</span></pre><h1 id="9f5e" class="nd lc iq bd ld ne nf ng lg nh ni nj lj nk nl nm lm nn no np lp nq nr ns ls nt bi translated">关于铁锈的思考</h1><p id="ef85" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">入门肯定很难。一些难倒我的事情:</p><ul class=""><li id="ad3d" class="mp mq iq kf b kg kh kk kl ko mr ks ms kw mt la mu mv mw mx bi translated">借支票。我发现自己一直在和借货员斗争。为了避免进一步的混淆，我尽可能地避免了有生之年。</li><li id="a730" class="mp mq iq kf b kg my kk mz ko na ks nb kw nc la mu mv mw mx bi translated">弦乐。字符串处理不是最佳的。我希望他们能隐藏<code class="fe lz ma mb mc b">String</code>和<code class="fe lz ma mb mc b">str</code>的区别，或者让它们可以互换。</li><li id="e33b" class="mp mq iq kf b kg my kk mz ko na ks nb kw nc la mu mv mw mx bi translated">伊努斯。我花了一段时间才“明白”一个枚举可能包含一个可以在<code class="fe lz ma mb mc b">matches</code>块中提取的值。</li><li id="123e" class="mp mq iq kf b kg my kk mz ko na ks nb kw nc la mu mv mw mx bi translated">错误消息。虽然它们很冗长，但你必须真正理解Rust及其习惯用法，才能正确地解释它们。</li><li id="133f" class="mp mq iq kf b kg my kk mz ko na ks nb kw nc la mu mv mw mx bi translated">成熟。似乎它还处于成熟周期的早期，以后的版本可能会使这些事情变得更容易。</li></ul><p id="1266" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">往好的方面想，有铁锈:</p><ul class=""><li id="739b" class="mp mq iq kf b kg kh kk kl ko mr ks ms kw mt la mu mv mw mx bi translated">写不好代码真的很难。</li><li id="1a67" class="mp mq iq kf b kg my kk mz ko na ks nb kw nc la mu mv mw mx bi translated">不用再处理头文件了。</li><li id="ddd8" class="mp mq iq kf b kg my kk mz ko na ks nb kw nc la mu mv mw mx bi translated">最终产品的速度是惊人的。</li><li id="aca4" class="mp mq iq kf b kg my kk mz ko na ks nb kw nc la mu mv mw mx bi translated">外面有一堆“板条箱”可能已经做了你想做的事情。</li></ul><p id="7d14" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我还没有尝试过Rust的任何并发功能(这是我的下一个列表)。Rust有一种非常活跃和令人兴奋的新语言的一般感觉。</p><h1 id="d097" class="nd lc iq bd ld ne nf ng lg nh ni nj lj nk nl nm lm nn no np lp nq nr ns ls nt bi translated">摘要</h1><p id="ebc4" class="pw-post-body-paragraph kd ke iq kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ij bi translated">已经演示了一个简单但有效的应用程序，它展示了如何观察文件系统事件并将这些更改同步到WebDav服务器。</p><p id="8c27" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">代码可以在GitHub上找到，网址是:</p><p id="4de1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae kc" href="https://github.com/tweissin/webdav-sync" rel="noopener ugc nofollow" target="_blank">https://github.com/tweissin/webdav-sync</a></p></div></div>    
</body>
</html>