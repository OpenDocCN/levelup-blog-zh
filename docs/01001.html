<html>
<head>
<title>Handle multiple API requests in Angular using mergeMap and forkJoin to avoid nested subscriptions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用mergeMap和forkJoin在Angular中处理多个API请求，以避免嵌套订阅</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/handle-multiple-api-requests-in-angular-using-mergemap-and-forkjoin-to-avoid-nested-subscriptions-a20fb5040d0c?source=collection_archive---------0-----------------------#2019-10-14">https://levelup.gitconnected.com/handle-multiple-api-requests-in-angular-using-mergemap-and-forkjoin-to-avoid-nested-subscriptions-a20fb5040d0c?source=collection_archive---------0-----------------------#2019-10-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="2c49" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">有角的</h2><div class=""/><div class=""><h2 id="762a" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">关于在调用多个API时如何使用<code class="fe kr ks kt ku b">mergeMap</code>和<code class="fe kr ks kt ku b">forkJoin</code>来避免嵌套订阅的指南</h2></div><figure class="kw kx ky kz gt la gh gi paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="gh gi kv"><img src="../Images/3a143e936f325223d9ae1e60ad0a42bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Suhz71aClBHN8-cRVH0zUA.jpeg"/></div></div><figcaption class="lh li gj gh gi lj lk bd b be z dk translated">照片由<a class="ae ll" href="https://unsplash.com/@yaanapi?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Yanapi Senaud </a>在<a class="ae ll" href="https://unsplash.com/s/photos/coffee?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="37ce" class="pw-post-body-paragraph lm ln it lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">在本文中，我将通过使用<a class="ae ll" href="https://www.learnrxjs.io/operators/transformation/mergemap.html" rel="noopener ugc nofollow" target="_blank"> mergeMap </a>和<a class="ae ll" href="https://www.learnrxjs.io/operators/combination/forkjoin.html" rel="noopener ugc nofollow" target="_blank"> forkJoin </a>来介绍两种在Angular中处理多个请求的技术。</p><p id="d74c" class="pw-post-body-paragraph lm ln it lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">内容:</p><ol class=""><li id="eb22" class="mi mj it lo b lp lq ls lt lv mk lz ml md mm mh mn mo mp mq bi translated">问题</li><li id="395f" class="mi mj it lo b lp mr ls ms lv mt lz mu md mv mh mn mo mp mq bi translated"><code class="fe kr ks kt ku b">subscribe</code></li><li id="81cd" class="mi mj it lo b lp mr ls ms lv mt lz mu md mv mh mn mo mp mq bi translated"><code class="fe kr ks kt ku b">mergeMap</code></li><li id="d1c9" class="mi mj it lo b lp mr ls ms lv mt lz mu md mv mh mn mo mp mq bi translated"><code class="fe kr ks kt ku b">forkJoin</code></li><li id="47ec" class="mi mj it lo b lp mr ls ms lv mt lz mu md mv mh mn mo mp mq bi translated">组合<code class="fe kr ks kt ku b">mergeMap</code>和<code class="fe kr ks kt ku b">forkJoin</code></li><li id="71fb" class="mi mj it lo b lp mr ls ms lv mt lz mu md mv mh mn mo mp mq bi translated"><code class="fe kr ks kt ku b">subscribe</code>与<code class="fe kr ks kt ku b">mergeMap</code>和<code class="fe kr ks kt ku b">forkJoin</code>的性能对比</li></ol><p id="7206" class="pw-post-body-paragraph lm ln it lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">更多类似的内容，请查看https://betterfullstack.com的</p><h1 id="5ca5" class="mx my it bd mz na nb nc nd ne nf ng nh ki ni kj nj kl nk km nl ko nm kp nn no bi translated">问题</h1><p id="dd1b" class="pw-post-body-paragraph lm ln it lo b lp np kd lr ls nq kg lu lv nr lx ly lz ns mb mc md nt mf mg mh im bi translated">在现实世界中，我们经常在web应用程序中调用不止一个API。当您进入一个页面时，您经常会发出多个请求来检索所有需要的数据，并且后续调用需要一些API请求的结果。</p><p id="4da0" class="pw-post-body-paragraph lm ln it lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">当我们发出多个请求时，有效地处理它们以保持用户的快速性能，同时编写良好的代码是非常重要的。</p><p id="bad4" class="pw-post-body-paragraph lm ln it lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">我将通过在<a class="ae ll" href="https://jsonplaceholder.typicode.com" rel="noopener ugc nofollow" target="_blank">https://jsonplaceholder.typicode.com</a>使用虚拟API演示一个简单的项目，该项目有3个要求:</p><ol class=""><li id="5d19" class="mi mj it lo b lp lq ls lt lv mk lz ml md mm mh mn mo mp mq bi translated">调用API来验证和检索用户信息</li><li id="7fb1" class="mi mj it lo b lp mr ls ms lv mt lz mu md mv mh mn mo mp mq bi translated">基于用户信息，我们调用一个API来获取用户创建的所有帖子。</li><li id="f619" class="mi mj it lo b lp mr ls ms lv mt lz mu md mv mh mn mo mp mq bi translated">基于用户信息，我们调用一个API来获取用户创建的所有相册。</li></ol><p id="b75e" class="pw-post-body-paragraph lm ln it lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated"><code class="fe kr ks kt ku b">subscribe</code>是Angular中处理请求的常用方式，但是还有更有效的方法。我们将首先使用<code class="fe kr ks kt ku b">subscribe</code>解决我们的问题，然后使用<code class="fe kr ks kt ku b">mergeMap</code>和<code class="fe kr ks kt ku b">forkJoin</code>对其进行改进</p><h1 id="9851" class="mx my it bd mz na nb nc nd ne nf ng nh ki ni kj nj kl nk km nl ko nm kp nn no bi translated">订阅</h1><p id="adf7" class="pw-post-body-paragraph lm ln it lo b lp np kd lr ls nq kg lu lv nr lx ly lz ns mb mc md nt mf mg mh im bi translated">使用这种技术非常简单。首先，我们调用一个API来获取用户信息，然后我们调用另外两个API。我们在嵌套订阅中这样做，这样我们就可以使用第一次API调用的结果。</p><figure class="kw kx ky kz gt la gh gi paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="gh gi nu"><img src="../Images/a6c3cf1d147c836ea9ad83de2ac9ada6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tPjpQwJ4qcB1E0FSGqpivw.png"/></div></div><figcaption class="lh li gj gh gi lj lk bd b be z dk translated">多重请求的嵌套订阅</figcaption></figure><p id="c024" class="pw-post-body-paragraph lm ln it lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">这种技术适用于2到3个请求，但是随着应用程序的增长，很难读取更多的请求。我们将被要求创建许多嵌套订阅。这就是为什么我们将使用RxJS来处理多个请求。</p><h1 id="cd45" class="mx my it bd mz na nb nc nd ne nf ng nh ki ni kj nj kl nk km nl ko nm kp nn no bi translated">合并地图</h1><p id="55f2" class="pw-post-body-paragraph lm ln it lo b lp np kd lr ls nq kg lu lv nr lx ly lz ns mb mc md nt mf mg mh im bi translated">当您希望展平内部可观察对象，但希望手动控制内部订阅的数量时，最好使用该运算符。</p><p id="5b4b" class="pw-post-body-paragraph lm ln it lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">那么我们什么时候应用<code class="fe kr ks kt ku b">mergeMap</code>？</p><p id="9780" class="pw-post-body-paragraph lm ln it lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">当我们需要来自第一个API请求的数据向第二个API发出请求时。</p><figure class="kw kx ky kz gt la gh gi paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="gh gi nv"><img src="../Images/553d198cbb7b3f4f99223e755b43bf61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LdHNPjNp_cmsxI4NrSx1Aw.png"/></div></div><figcaption class="lh li gj gh gi lj lk bd b be z dk translated">mergeMap案例研究</figcaption></figure><p id="28f3" class="pw-post-body-paragraph lm ln it lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">看看上面的源代码，我们可以看到第二个API需要第一个API的用户ID来获取数据。</p><p id="3852" class="pw-post-body-paragraph lm ln it lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">注意:</p><ol class=""><li id="e796" class="mi mj it lo b lp lq ls lt lv mk lz ml md mm mh mn mo mp mq bi translated"><code class="fe kr ks kt ku b">flatMap</code>是<code class="fe kr ks kt ku b">mergeMap</code>的别名。</li><li id="9b89" class="mi mj it lo b lp mr ls ms lv mt lz mu md mv mh mn mo mp mq bi translated"><code class="fe kr ks kt ku b">mergeMap</code>同时维护多个活动的内部订阅，因此有可能通过长期内部订阅造成内存泄漏。</li></ol><h1 id="18ef" class="mx my it bd mz na nb nc nd ne nf ng nh ki ni kj nj kl nk km nl ko nm kp nn no bi translated">叉连接</h1><p id="b89a" class="pw-post-body-paragraph lm ln it lo b lp np kd lr ls nq kg lu lv nr lx ly lz ns mb mc md nt mf mg mh im bi translated">当您有一组可观测量，并且只关心每个可观测量的最终发射值时，最好使用该运算符。这意味着<code class="fe kr ks kt ku b">forkJoin</code>允许我们将多个可观测值分组并并行执行，然后只返回一个可观测值。</p><p id="e7b0" class="pw-post-body-paragraph lm ln it lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">我们什么时候应用<code class="fe kr ks kt ku b">forkJoin</code>？</p><p id="d367" class="pw-post-body-paragraph lm ln it lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">当API请求独立时，我们使用它。这意味着它们不依赖于彼此来完成，并且可以并行执行。</p><figure class="kw kx ky kz gt la gh gi paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="gh gi nw"><img src="../Images/3e466741caf6853701adbe7e3369ee1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vdye24UXec5JszhtcTH3YA.png"/></div></div><figcaption class="lh li gj gh gi lj lk bd b be z dk translated">forkJoin案例研究</figcaption></figure><h1 id="ac0f" class="mx my it bd mz na nb nc nd ne nf ng nh ki ni kj nj kl nk km nl ko nm kp nn no bi translated">合并地图和叉连接</h1><p id="0535" class="pw-post-body-paragraph lm ln it lo b lp np kd lr ls nq kg lu lv nr lx ly lz ns mb mc md nt mf mg mh im bi translated">在现实世界中，有多个API请求依赖于另一个请求的结果。让我们看看如何使用<code class="fe kr ks kt ku b">mergeMap</code>和<code class="fe kr ks kt ku b">forkJoin</code>来处理这种情况。</p><p id="e1ae" class="pw-post-body-paragraph lm ln it lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">这里有一个例子可以解决我们的问题:</p><figure class="kw kx ky kz gt la gh gi paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="gh gi nx"><img src="../Images/5e062561c9041d6de48d8b2c627271a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k7Pn1gSBfdS6sGx2CWVVvg.png"/></div></div><figcaption class="lh li gj gh gi lj lk bd b be z dk translated">合并地图和叉连接</figcaption></figure><p id="aeda" class="pw-post-body-paragraph lm ln it lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">通过使用这些函数，我们避免了嵌套订阅，并且可以将代码分成许多小方法。</p><p id="da05" class="pw-post-body-paragraph lm ln it lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">你必须用从上面的<code class="fe kr ks kt ku b">map</code>返回的<code class="fe kr ks kt ku b">user</code>替换<code class="fe kr ks kt ku b">mergeMap</code>里面的<code class="fe kr ks kt ku b">userId</code>。</p><h1 id="8a32" class="mx my it bd mz na nb nc nd ne nf ng nh ki ni kj nj kl nk km nl ko nm kp nn no bi translated">subscribe与mergeMap和forkJoin的性能比较</h1><p id="abc8" class="pw-post-body-paragraph lm ln it lo b lp np kd lr ls nq kg lu lv nr lx ly lz ns mb mc md nt mf mg mh im bi translated">我注意到的唯一区别是解析HTML。</p><p id="5c47" class="pw-post-body-paragraph lm ln it lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">首先，看看使用嵌套订阅解析HTML的时间:</p><figure class="kw kx ky kz gt la gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/947ce5d9ecb78211ef12446e16484224.png" data-original-src="https://miro.medium.com/v2/resize:fit:982/format:webp/1*q18r2UuQhjaEik64s5cfOQ.png"/></div><figcaption class="lh li gj gh gi lj lk bd b be z dk translated">373.83毫秒解析HTML</figcaption></figure><p id="14ea" class="pw-post-body-paragraph lm ln it lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">然后，使用<code class="fe kr ks kt ku b">mergeMap</code>和<code class="fe kr ks kt ku b">forkJoin</code>查看解析HTML时间:</p><figure class="kw kx ky kz gt la gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/1cd02d2c07f34096e1ebd58efc326e80.png" data-original-src="https://miro.medium.com/v2/resize:fit:958/format:webp/1*sUjPj71uNgxgcKtwc2ldXw.png"/></div><figcaption class="lh li gj gh gi lj lk bd b be z dk translated">对HTML进行语法分析</figcaption></figure><p id="e512" class="pw-post-body-paragraph lm ln it lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">我多次尝试渲染页面来比较结果，我发现使用<code class="fe kr ks kt ku b">mergeMap</code>和<code class="fe kr ks kt ku b">forkJoin</code>时解析HTML的时间总是比使用嵌套订阅时快，但是差别非常小(大约100毫秒)。</p><p id="02ce" class="pw-post-body-paragraph lm ln it lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">重要的是知道如何使代码更具可读性和可维护性。</p><h1 id="7981" class="mx my it bd mz na nb nc nd ne nf ng nh ki ni kj nj kl nk km nl ko nm kp nn no bi translated">摘要</h1><p id="8b8c" class="pw-post-body-paragraph lm ln it lo b lp np kd lr ls nq kg lu lv nr lx ly lz ns mb mc md nt mf mg mh im bi translated">综上所述，我们可以用RxJS来处理Angular中的多个请求。这有助于我们编写可读性和可维护性更强的代码。作为一个额外的好处，我们还看到，与嵌套订阅相比，通过使用我们的RxJS函数，性能略有提高。</p><p id="490d" class="pw-post-body-paragraph lm ln it lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">我希望这篇文章对你有用！你可以跟着我上<a class="ae ll" href="https://medium.com/@transonhoang" rel="noopener">中型</a>。我也在<a class="ae ll" href="https://twitter.com/transonhoang" rel="noopener ugc nofollow" target="_blank">推特</a>上。欢迎在下面的评论中留下任何问题。我很乐意帮忙！</p><p id="7e27" class="pw-post-body-paragraph lm ln it lo b lp lq kd lr ls lt kg lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">点击此处查看源代码。</p><div class="oa ob gp gr oc od"><a href="https://stackblitz.com/edit/multiple-request-handling?embed=1&amp;file=src/app/app.component.ts" rel="noopener  ugc nofollow" target="_blank"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd jd gy z fp oi fr fs oj fu fw jc bi translated">多请求处理堆栈</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">导出到Angular CLI的Angular应用程序的启动项目</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">stackblitz.com</p></div></div><div class="om l"><div class="on l oo op oq om or lf od"/></div></div></a></div><div class="oa ob gp gr oc od"><a href="https://betterfullstack.com/stories/" rel="noopener  ugc nofollow" target="_blank"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd jd gy z fp oi fr fs oj fu fw jc bi translated">故事-更好的全栈</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">关于JavaScript、Python和Wordpress的有用文章，有助于开发人员减少开发时间并提高…</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">betterfullstack.com</p></div></div><div class="om l"><div class="os l oo op oq om or lf od"/></div></div></a></div></div><div class="ab cl ot ou hx ov" role="separator"><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy"/></div><div class="im in io ip iq"><div class="kw kx ky kz gt od"><a href="https://skilled.dev" rel="noopener  ugc nofollow" target="_blank"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd jd gy z fp oi fr fs oj fu fw jc bi translated">编写面试问题</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">一个完整的平台，在这里我会教你找到下一份工作所需的一切，以及…</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">技术开发</p></div></div><div class="om l"><div class="pa l oo op oq om or lf od"/></div></div></a></div></div></div>    
</body>
</html>