<html>
<head>
<title>Building a React Todo App with the Hasura GraphQL Engine</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Hasura GraphQL引擎构建React Todo应用程序</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/building-a-react-todo-app-with-hasura-graphql-engine-511b703a7ef?source=collection_archive---------0-----------------------#2018-10-05">https://levelup.gitconnected.com/building-a-react-todo-app-with-hasura-graphql-engine-511b703a7ef?source=collection_archive---------0-----------------------#2018-10-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/dd9336526b224a9a419ff353859f0255.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fx50YNJ28OhgUnOvgIN0LQ.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">哈苏拉和反应</figcaption></figure><p id="2d2c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果你正在读这篇文章，那么这意味着你可能对学习Hasura和<a class="ae la" href="https://gitconnected.com/learn/react" rel="noopener ugc nofollow" target="_blank"> React </a>感兴趣。如果是这样的话，那你就正好落在了一个完美的位置。你可能会有各种各样的问题，比如，“什么是<a class="ae la" href="https://gitconnected.com/learn/graphql" rel="noopener ugc nofollow" target="_blank"> GraphQL </a>？”，“哈苏拉是什么？”或者更重要的是，“我们为什么要用它？”。不用担心，当你读完这篇博客的时候，一切都会被清除。所以让我们开始吧！</p><p id="d765" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">本教程假设您对React框架有基本的了解。如果你是React的新手，我建议你先浏览React 的<a class="ae la" href="https://reactjs.org/docs/hello-world.html" rel="noopener ugc nofollow" target="_blank"> hello world应用，然后再继续。</a></p><p id="8234" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">本教程中的代码示例仅针对主要相关部分，但是如果您打算复制代码，请确保也导入相关的库和组件，并导出创建的组件。如果你想要完整的代码，你可以看看这个博客的<a class="ae la" href="https://github.com/Anupam-dagar/react-Hasura-todo" rel="noopener ugc nofollow" target="_blank">代码库</a>。</p><h1 id="fa69" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak">什么是哈苏拉？</strong></h1><p id="408e" class="pw-post-body-paragraph kc kd iq ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated"><a class="ae la" href="https://hasura.io/" rel="noopener ugc nofollow" target="_blank"> Hasura </a>是带有BaaS组件的<a class="ae la" href="https://en.wikipedia.org/wiki/Platform_as_a_service" rel="noopener ugc nofollow" target="_blank"> PaaS </a>。<a class="ae la" href="https://www.google.co.in/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;cad=rja&amp;uact=8&amp;ved=0ahUKEwi8ybHf4M3UAhUjTo8KHXc-CCkQFggnMAA&amp;url=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FPlatform_as_a_service&amp;usg=AFQjCNGEI5j7opaOUuYhR3mLFcXu9xqYpw&amp;sig2=MupuhZhI6n-GLERzsL6jGw" rel="noopener ugc nofollow" target="_blank"> PaaS </a>代表平台即服务。它允许开发人员、It专业人员和企业领导以安全、经济高效的方式在云中开发、测试和部署下一代应用程序，从而加快上市时间并增加竞争优势。</p><p id="fd69" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">BaaS代表后端即服务。它是一种模式，为web应用程序和移动应用程序开发人员提供一种方法，将他们的应用程序链接到后端云存储和后端应用程序公开的API，同时还提供用户管理、推送通知和与社交网络服务集成等功能。</p><h1 id="731b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">GraphQL，有什么大惊小怪的？</h1><p id="0355" class="pw-post-body-paragraph kc kd iq ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">GraphQL是一种API查询语言，也是一种用现有数据完成这些查询的运行时语言。GraphQL为API中的数据提供了完整且易于理解的描述，使客户能够准确地要求他们需要的东西，使API更容易随时间发展，并支持强大的开发工具。</p><h1 id="600a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak">哈苏拉的GraphQL引擎</strong></h1><p id="a942" class="pw-post-body-paragraph kc kd iq ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">Hasura GraphQL引擎是一个非常轻量级、高性能的产品，它可以在Postgres数据库上为您提供即时的实时GraphQL APIs。这可以用来在Postgres上快速构建新的应用程序，或者为Postgres上的现有应用程序快速迁移到GraphQL。</p><p id="af8e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">它附带了一个UI，允许您在数据库上创建和查看表，并使用嵌入式GraphQL接口进行graph QL查询。</p></div><div class="ab cl me mf hu mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="ij ik il im in"><h1 id="95a6" class="lb lc iq bd ld le ml lg lh li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly bi translated">我们将会建造什么</h1><p id="3472" class="pw-post-body-paragraph kc kd iq ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">我们将创建一个简单的todo应用程序，让用户注册或登录，然后通过(CRUD)创建它们来管理todo，将它们标记为完整，或根据需要删除它们。用户还可以看到他的所有待办事项。访问<a class="ae la" href="https://reacthasuratodo.herokuapp.com/" rel="noopener ugc nofollow" target="_blank">https://reacthasuratodo.herokuapp.com/</a>看我们将建设的演示。</p><h1 id="d8f2" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak">设置您的开发环境</strong></h1><ol class=""><li id="3d7d" class="mq mr iq ke b kf lz kj ma kn ms kr mt kv mu kz mv mw mx my bi translated">Hasura GraphQL服务器</li><li id="688c" class="mq mr iq ke b kf mz kj na kn nb kr nc kv nd kz mv mw mx my bi translated">结节</li><li id="1774" class="mq mr iq ke b kf mz kj na kn nb kr nc kv nd kz mv mw mx my bi translated">npm或纱线</li><li id="d3de" class="mq mr iq ke b kf mz kj na kn nb kr nc kv nd kz mv mw mx my bi translated">创建-反应-应用</li><li id="0420" class="mq mr iq ke b kf mz kj na kn nb kr nc kv nd kz mv mw mx my bi translated">将您的Hasura GraphQL引擎部署到一个服务器上，该服务器将被用作进行查询的端点。设置Hasura GraphQL最多需要1分钟。它可以通过一键部署到Heroku的方法轻松地部署到Heroku。<a class="ae la" href="https://heroku.com/deploy?template=https://github.com/hasura/graphql-engine-heroku" rel="noopener ugc nofollow" target="_blank">单击此处将您的Hasura GraphQL引擎部署到Heroku服务器</a>。给你的Heroku应用一个名字，然后点击部署应用。您的Hasura GraphQL用户界面将在appname.herokuapp.com现场直播</li></ol><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ne"><img src="../Images/2d00a7b039116afa62fa790b3ff7840a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4By1MEaHlUAZyi3iW_73Nw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Hasura一键部署到Heroku</figcaption></figure><p id="6897" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">为了保护您的Hasura graphql服务器，在Heroku上添加一个环境变量<code class="fe nj nk nl nm b">HASURA_GRAPHQL_ACCESS_KEY</code>,并保持它的值为您能记住的值。每当您尝试登录Hasura Graphql服务器时，都会询问这个访问密钥。</p><p id="63e7" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">2.在您的系统上安装节点和npm。</p><ul class=""><li id="76f7" class="mq mr iq ke b kf kg kj kk kn nn kr no kv np kz nq mw mx my bi translated">在基于Linux的操作系统上:</li></ul><blockquote class="nr ns nt"><p id="112d" class="kc kd nu ke b kf kg kh ki kj kk kl km nv ko kp kq nw ks kt ku nx kw kx ky kz ij bi translated">curl-sL<a class="ae la" href="https://deb.nodesource.com/setup_8.x" rel="noopener ugc nofollow" target="_blank">https://deb.nodesource.com/setup_8.x</a>| sudo bash-<br/>sudo安装节点</p></blockquote><p id="e558" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">以上命令会在您的系统中安装node和npm。</p><ul class=""><li id="517e" class="mq mr iq ke b kf kg kj kk kn nn kr no kv np kz nq mw mx my bi translated">在Windows上:<br/>在这里从<a class="ae la" href="https://nodejs.org/en/download/" rel="noopener ugc nofollow" target="_blank">下载相关包并安装。</a></li></ul><p id="844b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">3.安装create-react-app(我将用yarn代替npm)</p><ul class=""><li id="34d3" class="mq mr iq ke b kf kg kj kk kn nn kr no kv np kz nq mw mx my bi translated">create-react-app是一个由脸书开发的脚本，用来建立一个包含所有必要的目录结构和节点模块的react应用程序。</li><li id="4754" class="mq mr iq ke b kf mz kj na kn nb kr nc kv nd kz nq mw mx my bi translated">使用以下命令安装create-react-app。</li></ul><blockquote class="nr ns nt"><p id="9641" class="kc kd nu ke b kf kg kh ki kj kk kl km nv ko kp kq nw ks kt ku nx kw kx ky kz ij bi translated"><strong class="ke ir">纱线全局添加创建-反应-应用</strong></p></blockquote><p id="c144" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这将在您的系统上全局安装create-react-app。</p><h1 id="89d6" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak">创建react应用</strong></h1><p id="b7c4" class="pw-post-body-paragraph kc kd iq ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">使用<code class="fe nj nk nl nm b">create-react-app reacthasuratodo</code> <br/>创建一个新的react应用程序。成功完成该命令后，您将看到类似于图中的输出。现在，在刚刚创建的react应用程序目录中打开代码编辑器。</p><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ne"><img src="../Images/2e8cee2f224133b503846b1cbf7f4f70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zRFDjJF6_iPu1fj-FJUlwQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">设置React应用程序</figcaption></figure><p id="13de" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">把你的工作目录改成react app目录，运行<code class="fe nj nk nl nm b">yarn start</code>。服务器将启动，您应该能够在<a class="ae la" href="http://localhost:3000." rel="noopener ugc nofollow" target="_blank"> http://localhost:3000 </a>上看到欢迎反应屏幕。这意味着你的React应用运行良好。</p><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ne"><img src="../Images/66b0b0d554ba905971fc8964224ad13c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EN-R8yaaft52LJaYTV1hZQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Live React应用</figcaption></figure><p id="84c7" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我将使用<code class="fe nj nk nl nm b">react-bootstrap</code>包进行造型，所以使用<code class="fe nj nk nl nm b">yarn add react-bootstrap</code>安装包。确保在<code class="fe nj nk nl nm b">/public/index.html</code>中添加引导样式表。react-bootstrap包的完整文档可以在这里找到<a class="ae la" href="https://react-bootstrap.github.io/getting-started/introduction" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="f53d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak">使用auth0作为todo应用程序的身份验证</strong></h1><p id="5f2c" class="pw-post-body-paragraph kc kd iq ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">auth0是一个通用的认证和授权平台。</p><p id="4172" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">要将auth0添加到您的React应用程序，我们将执行以下步骤:<br/> 1。在<a class="ae la" href="https://auth0.com" rel="noopener ugc nofollow" target="_blank">https://auth0.com</a>上注册并创建一个新的应用程序。<br/> 2。在auth0控制台中添加回调URL。<br/> 3。创建一个验证类。创建历史. js <br/> 5。创建一个回调组件<br/> 6。创建路线<br/> 7。更改App.js以包含授权URL<br/>8。渲染路线而不是应用程序js</p><p id="b4d7" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在<a class="ae la" href="https://auth0.com" rel="noopener ugc nofollow" target="_blank">https://auth0.com</a>上注册，为你的react应用创建一个新的应用。为您的auth0应用程序提供一个相关的名称，然后转到settings选项卡，用react应用程序对其进行配置。</p><p id="d07c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在<code class="fe nj nk nl nm b">Allowed Callback Urls</code>下的设置中添加<code class="fe nj nk nl nm b">http://localhost:3000/callback</code>，因为它将在认证完成后成为开发环境上的回调URL。</p><p id="241d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在通过执行<code class="fe nj nk nl nm b">yarn add auth0-js</code>在react应用程序中安装auth0。<br/> auth0的网站上有一个很棒的<a class="ae la" href="https://auth0.com/docs/quickstart/spa/react/01-login" rel="noopener ugc nofollow" target="_blank"> react快速入门文档</a>，可以将auth0包含在react应用中。</p><p id="5063" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在<code class="fe nj nk nl nm b">src/Auth/</code>中创建一个新文件作为<code class="fe nj nk nl nm b">Auth.js</code>。我们将创建一个处理认证的<code class="fe nj nk nl nm b">Auth</code>类。</p><p id="e791" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">从您的auth0应用程序中复制您的auth0 <code class="fe nj nk nl nm b">clientID</code>并粘贴到<code class="fe nj nk nl nm b">Auth.js</code>中。如果您从auth0 docs开始，那么请确保在<code class="fe nj nk nl nm b">setSession()</code>函数中添加<code class="fe nj nk nl nm b">localStorage.setItem('sub', authResult.idTokenPayload.sub)</code>，在<code class="fe nj nk nl nm b">logout()</code>函数中添加<code class="fe nj nk nl nm b">localStorage.removeItem('sub', authResult.idTokenPayload.sub)</code>。这将在本地存储中存储用户id。</p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="ny nz l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">历史. js</figcaption></figure><p id="11f2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">创建一个文件<code class="fe nj nk nl nm b">history.js</code>,并将其内容制作成图像。同样修改<code class="fe nj nk nl nm b">App.js</code>以包含登录、注销和主页按钮。</p><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oa"><img src="../Images/aed9bfead156e284fbdae0fc05945d38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wI_nIy7mNGUbVU4bydVW6g.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Auth.js和App.js</figcaption></figure><p id="587a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">创建一个<code class="fe nj nk nl nm b">callback.js</code>组件，该组件将在授权完成时显示给用户。</p><p id="ec8b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">创建一个<code class="fe nj nk nl nm b">routes.js</code>,包括显示不同组件的不同路线和进行授权的路线。所有文件的内容可在<a class="ae la" href="https://auth0.com/docs/quickstart/spa/react/01-login" rel="noopener ugc nofollow" target="_blank"> auth0 react快速入门文档中找到。</a></p><h1 id="1702" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak">在GraphQL中编写查询</strong></h1><p id="2163" class="pw-post-body-paragraph kc kd iq ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">GraphQL中有3种不同类型的查询——查询、变异和订阅。GET请求由“查询”完成，而插入、删除和更新查询由“变异”完成。订阅监听事件中发生的任何变化，例如，如果一个新条目被添加到一个表中，那么通过订阅，它可以得到通知。这可以防止再次使用GET查询。</p><p id="9c88" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在Hasura API Explorer上创建一个名为<code class="fe nj nk nl nm b">todos</code>的新表。它将包含以下字段:<br/> 1 .todo_id: Integer(自动递增)<br/> 2。todo_text: Text <br/> 3。todo_mark: Boolean <br/> 4。todo_user: Text</p><ul class=""><li id="99b0" class="mq mr iq ke b kf kg kj kk kn nn kr no kv np kz nq mw mx my bi translated">todo_id将是todo编号，它将在每次新建时自动递增。</li><li id="d2eb" class="mq mr iq ke b kf mz kj na kn nb kr nc kv nd kz nq mw mx my bi translated">todo_text将存储todo的文本。</li><li id="d4f1" class="mq mr iq ke b kf mz kj na kn nb kr nc kv nd kz nq mw mx my bi translated">todo_mark是一个字段，如果todo已完成，则该字段为true如果todo尚未完成，则该字段为false。</li><li id="7da3" class="mq mr iq ke b kf mz kj na kn nb kr nc kv nd kz nq mw mx my bi translated">todo_user将存储登录用户的用户id。</li></ul><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ne"><img src="../Images/e1577d39267c96f249e44ca2e69f06f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W5Sz7JiAmHAYGYjZNuN2kg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">在Hasura上创建一个表</figcaption></figure><p id="6322" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">添加表权限，以便每个用户只能访问其数据。</p><ol class=""><li id="018d" class="mq mr iq ke b kf kg kj kk kn nn kr no kv np kz mv mw mx my bi translated">创建一个新的<code class="fe nj nk nl nm b">role</code>用户。</li><li id="3738" class="mq mr iq ke b kf mz kj na kn nb kr nc kv nd kz mv mw mx my bi translated">对于<code class="fe nj nk nl nm b">insert</code>选择了<code class="fe nj nk nl nm b">with custom checks<br/></code>选择<code class="fe nj nk nl nm b">todo_user</code>作为字段，使其<code class="fe nj nk nl nm b">_eq</code>变为<code class="fe nj nk nl nm b">X-HASURA-USER-ID</code></li><li id="c139" class="mq mr iq ke b kf mz kj na kn nb kr nc kv nd kz mv mw mx my bi translated">对于<code class="fe nj nk nl nm b">select</code>，选择<code class="fe nj nk nl nm b">with same checks as ----</code>并选择所有要访问的列。</li><li id="7386" class="mq mr iq ke b kf mz kj na kn nb kr nc kv nd kz mv mw mx my bi translated">对于<code class="fe nj nk nl nm b">update</code>选择了<code class="fe nj nk nl nm b">with same checks as ----</code>并且只允许访问<code class="fe nj nk nl nm b">todo_mark</code>列。</li><li id="b136" class="mq mr iq ke b kf mz kj na kn nb kr nc kv nd kz mv mw mx my bi translated">因为<code class="fe nj nk nl nm b">delete</code>选择了<code class="fe nj nk nl nm b">with same checks as ----</code>。</li></ol><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ne"><img src="../Images/edc02189b4580c9cd303a1320b3c7a47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*98HSDzrNrIFu55YjQIe9lQ.png"/></div></div></figure><h2 id="1d0c" class="ob lc iq bd ld oc od dn lh oe of dp ll kn og oh lp kr oi oj lt kv ok ol lx om bi translated">编写GET查询</h2><p id="3fc2" class="pw-post-body-paragraph kc kd iq ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">用GraphQL编写查询很容易。指定表名，然后指定要在响应中出现的字段。如果您想进行选择性搜索，那么可以在表名说明之后提供一个<code class="fe nj nk nl nm b">order_by</code>。</p><p id="babb" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">获取todos表中所有值的示例查询如下:</p><pre class="nf ng nh ni gt on nm oo op aw oq bi"><span id="f049" class="ob lc iq nm b gy or os l ot ou">query {<br/>    todos{<br/>       todo_id<br/>       todo_text<br/>       todo_mark<br/>       todo_user<br/>    }<br/>}</span></pre><p id="c058" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">查询的一般格式是:</p><pre class="nf ng nh ni gt on nm oo op aw oq bi"><span id="3e6f" class="ob lc iq nm b gy or os l ot ou">query query_name {<br/> table_name (where, orderby or pagination expression)]{<br/> table fields in response<br/> }<br/>}</span></pre><h2 id="c2b6" class="ob lc iq bd ld oc od dn lh oe of dp ll kn og oh lp kr oi oj lt kv ok ol lx om bi translated">写一个突变</h2><p id="2729" class="pw-post-body-paragraph kc kd iq ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">突变包括插入、更新和删除。编写变异查询的一般格式是:</p><pre class="nf ng nh ni gt on nm oo op aw oq bi"><span id="2093" class="ob lc iq nm b gy or os l ot ou">mutation mutation-name {<br/>  mutation-type_table-name (<br/>    expressions to identify row and changing data<br/>  )<br/>  affected_rows<br/>}</span></pre><p id="0528" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">对todos表的简单插入查询如下所示:</p><pre class="nf ng nh ni gt on nm oo op aw oq bi"><span id="d9b8" class="ob lc iq nm b gy or os l ot ou">mutation {<br/>    insert_todos(<br/>        objects: [<br/>            {<br/>              todo_text: "Complete react app",<br/>              todo_user: "auth0|20390123821398"<br/>            }<br/>        ]<br/>    ){<br/>       affected_rows<br/>     }<br/>}</span></pre><p id="679b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">对todos表的简单更新查询如下所示:</p><pre class="nf ng nh ni gt on nm oo op aw oq bi"><span id="8f9f" class="ob lc iq nm b gy or os l ot ou">mutation {<br/>    update_todos(<br/>        where: {todo_id: {_eq: 1}}<br/>        _set: {todo_mark: true}<br/>    ){<br/>       affected_rows<br/>     }<br/>}</span></pre><p id="debd" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">对todos表的简单删除查询如下所示:</p><pre class="nf ng nh ni gt on nm oo op aw oq bi"><span id="3b93" class="ob lc iq nm b gy or os l ot ou">mutation {<br/>    delete_todos(<br/>        where: {todo_id: {_eq:1}}<br/>    ){<br/>       affected_rows<br/>    }<br/>}</span></pre><p id="7d43" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在我们准备使用React创建前端，并查询数据库以创建和利用todos。</p><h2 id="d927" class="ob lc iq bd ld oc od dn lh oe of dp ll kn og oh lp kr oi oj lt kv ok ol lx om bi translated"><strong class="ak">使用React编码前端</strong></h2><p id="d8d5" class="pw-post-body-paragraph kc kd iq ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">我们将使用React Apollo客户端与GraphQL服务器交互并进行查询。使用<code class="fe nj nk nl nm b">npm install apollo-boost react-apollo graphql --save</code>或<code class="fe nj nk nl nm b">yarn add apollo-boost react-apollo graphql</code>安装apollo客户端。</p><p id="5784" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">会有以下几个主要成分:<br/> 1。一个父组件包装了apollo provider组件中的所有组件。<br/> 2。GetTodos组件向用户显示所有待定的待办事项。<br/> 3。添加待办事项的AddTodos组件。<br/> 4。MarkTodo组件将待办事项标记为已完成。<br/> 5。用于删除待办事项的DeleteTodo组件。<br/> 6。GetAllTodos组件获取到目前为止为用户创建的所有Todos。</p><ol class=""><li id="9111" class="mq mr iq ke b kf kg kj kk kn nn kr no kv np kz mv mw mx my bi translated"><code class="fe nj nk nl nm b">Home.js</code>父组件。<br/>该组件将作为所有其他组件的父组件，我们将把子组件包装在一个<code class="fe nj nk nl nm b">ApolloProvider</code>中，这将使我们能够使用apollo客户端在整个应用程序中进行GraphQL查询。ApolloProvider需要一个带有<code class="fe nj nk nl nm b">ApolloClient</code>对象的<code class="fe nj nk nl nm b">client</code>道具。这允许我们提出授权请求。从apollo-boost导入ApolloClient，从react-apollo导入ApolloProvider。创建一个ApolloClient对象，如下所示<br/>要使用用户身份验证，在头中传递用户访问令牌作为授权。这将让Hasura知道哪个用户正在向GraphQL服务器发送请求。需要部署一个单独的身份验证webhook来允许令牌身份验证。将webhook部署到Heroku或任何其他服务。使用Heroku一键部署很容易部署。之后，将Hasura服务器中的<code class="fe nj nk nl nm b">HASURA_GRAPHQL_AUTH_HOOK</code>环境变量配置为您部署的webhook URL。使用<code class="fe nj nk nl nm b">/auth0/webhook</code>进行auth0认证。</li></ol><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="ny nz l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">Home.js</figcaption></figure><p id="ceb9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">2.<code class="fe nj nk nl nm b">GetTodos</code>将从数据库中提取所有未完成的待办事项并显示给用户。这个组件需要使用React Apollo的查询组件。我们首先需要编写一个GraphQL查询来从todos表中获取所有未完成的todos。编写查询的方法与上面解释的一样。在react中，您需要将查询放在<code class="fe nj nk nl nm b">gql``</code>中。gql是从graphql-tag导入的，它让apollo客户机知道这个文本中包含的文本是一个graphql查询。为了保持代码的整洁，我们将创建一个<code class="fe nj nk nl nm b">queries.js</code>并在其中编写所有的GraphQL查询。</p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="ny nz l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">获取不完整的todos查询</figcaption></figure><p id="86a5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们将使用这个查询来获取所有未完成的待办事项。在GetTodos组件中，我们将使用Apollo的查询标签。创建一个Apollo查询，并将graphql查询作为一个<code class="fe nj nk nl nm b">query</code>属性传递给它。查询组件中的一个函数将检查查询的当前状态(加载)、错误(如果存在)以及完成时的数据。数据中会包含所有的待办事项，我们只需遍历数据并向用户显示相关内容。应该有一个选项将待办事项标记为已完成或删除待办事项，所以我们将创建这些组件，并与收到的数据一起呈现。最后，在所有的待办事项呈现后，我们将为用户提供一个添加新待办事项的选项，我们将为其创建一个AddTodo组件，并将其呈现在显示给用户的待办事项旁边。</p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="ny nz l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">GetTodos组件</figcaption></figure><p id="a39c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">3.AddTodo组件将用于向hasura graphql服务器发送插入请求，以便在数据库中添加新的Todo条目。这个组件将需要使用graphql的变异请求和Apollo的变异组件。</p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="ny nz l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">插入新待办事项的查询</figcaption></figure><p id="cf4e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这里我们将在变异查询中使用变量，变异查询将从Apollo的变异组件接收。该组件将由一个表单组成，该表单将接受来自用户的todo_text输入，并将其作为变量发送给变异查询。创建一个变异组件，并在变异属性中传递GraphQL查询的名称。在突变中有一个带有两个参数的函数，第一个参数是突变的类型，第二个参数是可选数据。插入类型的突变需要<code class="fe nj nk nl nm b">todo_text</code>和<code class="fe nj nk nl nm b">todo_user</code>作为变量。任何要随查询一起发送的额外数据都包含在字典中。</p><p id="8b49" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">所有的变量都包含在一个字典中，变量名作为关键字，变量值作为字典。这个变量字典被分配给附加数据字典中的一个变量键。突变改变了数据库的状态，这意味着如果我们向数据库添加新的待办事项，那么它应该在未完成待办事项列表中显示给用户。这是由<code class="fe nj nk nl nm b">refetchQueries</code>实现的。<code class="fe nj nk nl nm b">refetchQueries</code>是字典列表，每个字典包含变异完成时要执行的查询的名称。每当一个新的待办事项被添加到数据库时，我们将重新提取所有的待办事项。</p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="ny nz l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">AddTodos组件</figcaption></figure><p id="546d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">4.MarkTodo组件将用于向特定Todo的数据库发送更新请求，以将其todo_mark值从<code class="fe nj nk nl nm b">false</code>更改为<code class="fe nj nk nl nm b">true</code>。</p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="ny nz l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">用于将待办事项标记为已完成的变异查询</figcaption></figure><p id="95f3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在MarkTodo组件中，创建一个变异组件，并在变异属性中传递graphql查询的名称。MarkTodo组件类似于AddTodos，只是AddTodo插入一个新条目，而MarkTodo更新数据库中现有的条目。</p><p id="e891" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">将todo的id作为变量传递给update mutation，以便可以在数据库中更改todo_mark值。变异完成后重新提取所有todos。</p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="ny nz l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">MarkTodo组件</figcaption></figure><p id="240b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">5.与MarkTodo一样，我们将创建一个DeleteTodo组件。这将允许用户从数据库中完全删除待办事项。除了我们将使用delete_todos作为变异类型之外，一切都将与MarkTodo中的相同。</p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="ny nz l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">删除待办事项的查询</figcaption></figure><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="ny nz l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">DeleteTodo组件</figcaption></figure><p id="7626" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">6.最后，我们将创建一个GetAllTodos组件，向用户显示他到目前为止创建的所有Todos。它包括已完成和未完成的待办事项。该组件将对todos表使用GET查询，我们将首先根据最近创建的未完成的todos对todos进行排序。在react中使用条件渲染，我们可以对未完成的待办事项和完成的待办事项设置不同的样式。</p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="ny nz l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">GetAllTodos组件和查询</figcaption></figure><p id="536d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">使用<code class="fe nj nk nl nm b">yarn start</code>运行服务器。前往<a class="ae la" href="http://localhost:3000" rel="noopener ugc nofollow" target="_blank"> http://localhost:3000 </a>测试你的应用。</p><p id="a930" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">就是这样，用Hasura Graphql Engine创建一个React Todo应用程序是如此简单。您可以扩展它以包括更多的功能和更好的外观和感觉。将react应用程序部署到Heroku或任何其他托管服务上，这样互联网上的每个人都可以使用它。</p><p id="797a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">你可以在这里找到这个博客的源代码。</p><div class="ov ow gp gr ox oy"><a href="https://github.com/Anupam-dagar/react-Hasura-todo" rel="noopener  ugc nofollow" target="_blank"><div class="oz ab fo"><div class="pa ab pb cl cj pc"><h2 class="bd ir gy z fp pd fr fs pe fu fw ip bi translated">Anupam-dagar/react-Hasura-todo</h2><div class="pf l"><h3 class="bd b gy z fp pd fr fs pe fu fw dk translated">一个使用Hasura Graphql引擎的react todo应用程序。为Anupam-dagar/react-Hasura-todo开发做出贡献，创建一个…</h3></div><div class="pg l"><p class="bd b dl z fp pd fr fs pe fu fw dk translated">github.com</p></div></div><div class="ph l"><div class="pi l pj pk pl ph pm jw oy"/></div></div></a></div><p id="8f7a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">继续编码！！！</p><p id="41d4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">创建todo应用时使用的有用资源:<br/> 1。<a class="ae la" href="https://docs.hasura.io/1.0/graphql/manual/index.html" rel="noopener ugc nofollow" target="_blank"> Hasura GraphQL引擎文档</a> <br/> 2。<a class="ae la" href="https://www.apollographql.com/docs/react/" rel="noopener ugc nofollow" target="_blank"> React阿波罗GraphQL文档</a> <br/> 3。<a class="ae la" href="https://www.apollographql.com/docs/react/" rel="noopener ugc nofollow" target="_blank">auth 0 React quick start</a>T12】4。<a class="ae la" href="https://graphql.org/learn/" rel="noopener ugc nofollow" target="_blank">官方GraphQL文档</a></p></div><div class="ab cl me mf hu mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="ij ik il im in"><h1 id="e561" class="lb lc iq bd ld le ml lg lh li mm lk ll lm mn lo lp lq mo ls lt lu mp lw lx ly bi translated">关于我</h1><p id="1c65" class="pw-post-body-paragraph kc kd iq ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">我的名字是阿努帕姆·达加尔。我是阿拉哈巴德印度信息技术学院的一名本科生。我正在攻读信息技术的学士学位。</p><p id="c392" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">当我没有大学作业的时候，我喜欢创造和学习新事物。我喜欢用Python和T21编写代码。我是<strong class="ke ir">开源贡献者</strong>，目前是<strong class="ke ir"> GitHub校园专家</strong>在<strong class="ke ir">印度</strong>。</p><p id="8aef" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">你可以在<a class="ae la" href="https://www.linkedin.com/in/anupamdagar/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>、<a class="ae la" href="https://twitter.com/siriusdagar" rel="noopener ugc nofollow" target="_blank"> Twitter </a>和<a class="ae la" href="https://github.com/Anupam-dagar" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上关注我。</p></div></div>    
</body>
</html>