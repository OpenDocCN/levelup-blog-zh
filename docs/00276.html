<html>
<head>
<title>Vue PWA example</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Vue PWA示例</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/vue-pwa-example-298a8ea953c9?source=collection_archive---------0-----------------------#2018-12-05">https://levelup.gitconnected.com/vue-pwa-example-298a8ea953c9?source=collection_archive---------0-----------------------#2018-12-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="595b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你好。在过去的几天里，我一直在尝试使用优秀的<a class="ae kl" href="https://cli.vuejs.org/guide/" rel="noopener ugc nofollow" target="_blank"> Vue CLI </a>为我的公司运行PWA。我特别希望能够离线使用该应用程序，使其可以在桌面上安装，并在PWA有新内容可用时通知用户，并触发页面重新加载。</p><p id="7936" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">关于这些可能性的文档相当分散，很难收集，而且没有很多是专门用于Vue PWA的。你可以在下面找到我的发现。</p><p id="c114" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">回购可以在<a class="ae kl" href="https://gitlab.com/kobededecker/vue-pwa-example" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><h1 id="128b" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">默认服务人员</h1><p id="cd9e" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">让我们从将Vue/PWA插件添加到我们的Vue应用程序开始(要使用Vue CLI生成新的应用程序，请阅读<a class="ae kl" href="https://cli.vuejs.org/guide/creating-a-project.html#vue-create" rel="noopener ugc nofollow" target="_blank">这里</a>的文档)。</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="eb46" class="ly kn iq lu b gy lz ma l mb mc">vue add @vue/pwa</span></pre><p id="0978" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这将在<code class="fe md me mf lu b">/src</code>目录中给你一个额外的文件:<code class="fe md me mf lu b">registerServiceWorker.js</code>。该文件随后被导入<code class="fe md me mf lu b">main.js</code>。该文件注册了运行<code class="fe md me mf lu b">yarn build</code>生成的默认<code class="fe md me mf lu b">service-worker.js</code>文件。该文件由集成在Webpack配置中的Workbox插件生成。</p><p id="727d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个自动生成的<code class="fe md me mf lu b">service-worker.js</code>文件如下所示:</p><figure class="lp lq lr ls gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi mg"><img src="../Images/d72beb121affdd954e42c565ef2710f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2xO9s6vadfTSIRNDus8B4Q.png"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">自动生成的dist/service-worker.js</figcaption></figure><p id="7f91" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如您所见，加载了一个workbox CDN，然后加载了一个自动生成的<code class="fe md me mf lu b">precache-manifest</code>。这个清单文件仅仅列出了由<code class="fe md me mf lu b">vue build</code>进程产生的一些<code class="fe md me mf lu b">js</code>文件。下面3行实际上是预缓存这个文件列表的过程。</p><p id="7098" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe md me mf lu b">registerServiceWorker.js</code>文件如下所示:</p><figure class="lp lq lr ls gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi ms"><img src="../Images/2fa8994e1fcb5d63015b0002c11ac9d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZGjKoAiYyeJsWTQU7EWcnA.png"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">默认src/registerServiceWorker.js</figcaption></figure><p id="ade8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个文件从VueJS的人创建的<code class="fe md me mf lu b">register-service-module</code>中导入了<code class="fe md me mf lu b">register</code>函数，这使得注册服务人员和检测浏览器功能的过程更加容易。它给出了一些我们以后可以使用的事件注册。有些事件将注册对象作为第一个参数。</p><p id="e3ca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个默认设置会给你提供:</p><ul class=""><li id="4c34" class="mt mu iq jp b jq jr ju jv jy mv kc mw kg mx kk my mz na nb bi translated">所有构建文件的预缓存</li><li id="ae0a" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk my mz na nb bi translated">离线加载应用程序的能力(一旦被缓存，当然)</li><li id="8365" class="mt mu iq jp b jq nc ju nd jy ne kc nf kg ng kk my mz na nb bi translated">许多服务人员注册事件，您可以在应用程序中对这些事件做出反应</li></ul><p id="1b88" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于更复杂的设置，包括通知、推送消息、“新内容”弹出窗口，你需要一个定制服务人员。</p><p id="ef9c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在下面的小节中，我们将配置Vue构建过程来使用一个定制的服务工作者文件，并且我们将配置它来注入和预缓存在<code class="fe md me mf lu b">precache-manifest</code>中列出的构建文件。此外，我将向您展示一些您可以使用定制服务人员做的事情。</p></div><div class="ab cl nh ni hu nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ij ik il im in"><h1 id="79ed" class="km kn iq bd ko kp no kr ks kt np kv kw kx nq kz la lb nr ld le lf ns lh li lj bi translated">海关服务人员</h1><p id="d239" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">要创建我们自己的<code class="fe md me mf lu b">service-worker.js</code>文件，我们首先需要设置一些工具箱选项。这需要在<code class="fe md me mf lu b">vue.config.js</code>文件中完成，如果你一直使用默认配置，可能需要创建这个文件。在Vue项目的根目录下创建文件，并使用以下配置选项填充它。</p><figure class="lp lq lr ls gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi nt"><img src="../Images/13808ccb672d7efc623fb3789cbefe9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mGIV4CO6HfAQVR5Y7rV4UA.png"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">vue .配置. js</figcaption></figure><p id="7827" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如您所见，我们将默认的<code class="fe md me mf lu b">workboxPluginMode</code>从<code class="fe md me mf lu b">GenerateSw</code>覆盖到<code class="fe md me mf lu b">InjectManifest</code>。在<code class="fe md me mf lu b">workboxOptions</code>中，我们将<code class="fe md me mf lu b">swSrc </code>指向我们需要在<code class="fe md me mf lu b">src </code>文件夹中创建的文件:<code class="fe md me mf lu b">service-worker.js</code>。您也可以选择给服务工作者另一个名称，但是您需要在<code class="fe md me mf lu b">registerServiceWorker.js</code>文件中更改默认的sw注册名称。</p><p id="3268" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，创建一个空的<code class="fe md me mf lu b">src/service-worker.js</code>文件。尝试运行<code class="fe md me mf lu b">yarn build</code>，您将看到Vue构建过程将‘注入’清单文件，包括Workbox CDN。然而，此时清单中列出的构建文件将不会用于预缓存，我们只导入服务工作者中的名称:因此我们需要复制默认自动生成的<code class="fe md me mf lu b">service-worker.js</code>文件的底部3行，这是预缓存<code class="fe md me mf lu b">precache-manifest</code>文件中列出的构建文件所必需的。</p><p id="a43e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，我们现在拥有的是:我们有一个在构建阶段处理的自定义service-worker.js文件，我们最终得到一个dist/service-worker.js，它几乎类似于当我们使用GenerateSw工作箱模式时自动生成的默认service-worker.js文件。现在，我们可以继续为定制服务工作者添加一些功能。</p></div><div class="ab cl nh ni hu nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ij ik il im in"><h1 id="8a55" class="km kn iq bd ko kp no kr ks kt np kv kw kx nq kz la lb nr ld le lf ns lh li lj bi translated">新内容通知</h1><p id="4057" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">我们可以使用这个定制的服务工作器做的第一件事就是检测何时有新内容可用(当发现新的服务工作器时)，并向用户提供通知和刷新页面的选项。我们可以通过听一个事件来做到这一点，当一个新的服务工作器被找到并准备安装时，这个事件就会被触发。此时，服务工作人员将处于“等待”状态。如果您通读PWA在<a class="ae kl" href="https://developers.google.com/web/fundamentals/codelabs/your-first-pwapp/" rel="noopener ugc nofollow" target="_blank">上的解释https://developer . Google . com/web/foundation/codelabs/you-first-pwapp/</a>，您可以看到服务工作器实际上只是在用户关闭浏览器时才被刷新。您可以通过单击chrome devtools“应用程序面板”的“服务工作器”选项卡中的“skipWaiting”按钮，手动触发服务工作器的实际安装。</p><p id="e523" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们有了一个定制的服务工作器. js文件，我们可以做的是:在<code class="fe md me mf lu b">registerServiceWorker</code>(运行在浏览器窗口中)中，我们可以听到“更新”事件，并向<code class="fe md me mf lu b">service-worker.js</code>(运行在另一个线程中)发送一条消息，告诉服务工作器“跳过等待”，然后自己安装。最后一步是监听服务工作器注册中的变化，并触发页面重新加载。新的服务工作人员带来的新内容将被加载。</p><p id="d135" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以，请查看我们修改后的<code class="fe md me mf lu b">registerServiceWorker.js</code>文件如下:</p><figure class="lp lq lr ls gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi nu"><img src="../Images/444375df4b90accf901928b770f60b3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6cM2jN2T5IN8ybQYE3edYw.png"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">修改了src/registerServiceWorker.js</figcaption></figure><p id="1caa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们创建了一个函数<code class="fe md me mf lu b">notifyUserAboutUpdate</code>，它将把一个<code class="fe md me mf lu b">worker</code>对象作为参数。该功能将在服务人员更新时触发，如<code class="fe md me mf lu b">updated</code>事件所示。一个重要的方面是通过<code class="fe md me mf lu b">registration</code>对象的<code class="fe md me mf lu b">waiting</code>工人。我们的自定义函数将触发一个确认弹出窗口，通知用户PWA有新的内容可用(使用优秀的alertify.js库)。一旦用户确认，则<code class="fe md me mf lu b">registerServiceWorker.js</code>文件向<code class="fe md me mf lu b">service-worker.js</code>文件“等待”发送消息，通知其到<code class="fe md me mf lu b">skipWaiting</code>。</p><p id="1458" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，在<code class="fe md me mf lu b">service-worker.js</code>文件中，添加一个<code class="fe md me mf lu b">eventListener</code>监听“消息”事件。检查该动作是否调用了“skipWaiting”，然后触发该<code class="fe md me mf lu b">skipWaiting</code>功能。请在下面检查:</p><figure class="lp lq lr ls gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi nv"><img src="../Images/a5e93c130a234bd24156b4dbf2596d63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0S666QA7f1ZzgHowOT1SxQ.png"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">自定义src/service-worker.js</figcaption></figure><p id="02c8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以，概括一下:当<code class="fe md me mf lu b">registerServiceWorker.js</code>找到一个新的<code class="fe md me mf lu b">service-worker.js</code>文件时，它会做必要的注册工作，当准备安装时，调用<code class="fe md me mf lu b">updated</code>事件。这将要求用户确认重新加载新内容的应用程序，并将通知服务人员它可以跳过等待并自行安装。最后要做的一件事是:监听<code class="fe md me mf lu b">registerServiceWorker.js</code>文件中的<code class="fe md me mf lu b">controllerchange</code>事件，并触发页面重新加载(可以在上面显示的<code class="fe md me mf lu b">registerServiceWorker.js</code>文件的底部看到)。平心而论，我并不完全理解上面的<code class="fe md me mf lu b">refreshing</code>检查，但在这个<a class="ae kl" href="https://stackoverflow.com/questions/41891031/refresh-page-on-controllerchange-in-service-worker" rel="noopener ugc nofollow" target="_blank"> SO </a>线程中发现了它。</p></div><div class="ab cl nh ni hu nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ij ik il im in"><h1 id="91bf" class="km kn iq bd ko kp no kr ks kt np kv kw kx nq kz la lb nr ld le lf ns lh li lj bi translated">安装弹出窗口</h1><p id="cc95" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">我们可以用新的PWA做一件额外的事情，就是要求用户将应用程序安装到桌面上。我们真的不需要定制<code class="fe md me mf lu b">service-worker</code>，因为这可以通过默认的Vue/PWA设置来完成。</p><p id="92c3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">只需要添加一些东西，例如，主<code class="fe md me mf lu b">App.vue</code>文件。添加一个按钮，例如下面的引导导航栏，默认情况下是隐藏的(使用style=display:none)。该显示状态由反应数据属性决定，因此在Vue SPC的<code class="fe md me mf lu b">data</code>部分注册<code class="fe md me mf lu b">installBtn</code>。在<code class="fe md me mf lu b">created</code>事件中，你可以监听“beforeinstalprompt”事件，一旦chrome检测到你的PWA应用符合一些要求，它就会启动这个事件。然后我们可以捕获事件，通过将<code class="fe md me mf lu b">installBtn=none</code>状态修改为<code class="fe md me mf lu b">block</code>来可视化我们的按钮。然后我们在一个<code class="fe md me mf lu b">installer</code>函数中使用捕获的<code class="fe md me mf lu b">installPrompt</code>，这个函数在点击按钮时被调用(使用<code class="fe md me mf lu b">@click</code>处理程序)。该<code class="fe md me mf lu b">installer</code>方法也需要在SPC的<code class="fe md me mf lu b">data</code>部分进行初始化。用户点击我们的安装按钮，将得到默认的Chrome安装通知，我们的PWA将被安装到桌面上，准备离线使用。</p><figure class="lp lq lr ls gt mh gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi nw"><img src="../Images/56493b37f4033fddf587fe22992b058e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sMMoaYQgpwOubE3Mzih5Vw.png"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk translated">App.vue安装提示</figcaption></figure><p id="670d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://love2dev.com/blog/beforeinstallprompt/" rel="noopener ugc nofollow" target="_blank">这个</a>博客在构建Vue的安装设置时帮了我很多。</p></div><div class="ab cl nh ni hu nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ij ik il im in"><p id="7c27" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后一点:首先令人困惑的是，服务工作者只有在从“localhost”或启用https的URL接受服务时才注册。此外，只有当您通过应用程序的生产版本加载应用程序时，服务人员才会工作。开发起来稍微复杂一点，但是你需要运行<code class="fe md me mf lu b">yarn build</code>，然后使用一个小的服务器比如节点模块<code class="fe md me mf lu b">http-server</code>来服务这个应用。</p></div><div class="ab cl nh ni hu nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ij ik il im in"><p id="a92b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我希望这能帮助一些正在寻找正确信息的人，这些信息很难找到。</p><p id="80d2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你发现任何可以改进的元素，请在下面发表评论！</p></div><div class="ab cl nh ni hu nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ij ik il im in"><figure class="lp lq lr ls gt mh gh gi paragraph-image"><a href="https://levelup.gitconnected.com"><div class="gh gi nx"><img src="../Images/ff5028ba5a0041d2d76d2a155f00f05e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JaoZbi7tTKJ5vL7i2OAYMQ.png"/></div></a></figure><div class="ny nz gp gr oa ob"><a href="https://gitconnected.com/learn/vue-js" rel="noopener  ugc nofollow" target="_blank"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd ir gy z fp og fr fs oh fu fw ip bi translated">学习Vue.js -最佳Vue.js教程(2019) | gitconnected</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">27大Vue.js教程。课程由开发者提交并投票，让你找到最好的Vue.js…</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">gitconnected.com</p></div></div><div class="ok l"><div class="ol l om on oo ok op mm ob"/></div></div></a></div></div></div>    
</body>
</html>