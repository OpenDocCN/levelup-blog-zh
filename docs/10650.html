<html>
<head>
<title>Go Generics Applied</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">应用Go Generics</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/go-generics-applied-da8d136d6b95?source=collection_archive---------8-----------------------#2021-12-29">https://levelup.gitconnected.com/go-generics-applied-da8d136d6b95?source=collection_archive---------8-----------------------#2021-12-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/b0e15e17baba2d239f1edacbe2231b59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1066/format:webp/1*OYRwPKKAiaJ5Ih6XV88cWQ.png"/></div></figure><p id="4de0" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">Go 1.18测试版一出来，我就开始探索泛型。我最终得到的<a class="ae kv" href="https://github.com/nwillc/genfuncs/#func-values" rel="noopener ugc nofollow" target="_blank"> genfuncs </a>包，受<a class="ae kv" href="https://kotlinlang.org/" rel="noopener ugc nofollow" target="_blank"> Kotlin </a>的启发，包含了一系列关于切片、贴图和排序的有用操作。</p><h2 id="48e0" class="kw kx it bd ky kz la dn lb lc ld dp le ki lf lg lh km li lj lk kq ll lm ln lo bi translated">它们有用吗？</h2><p id="f022" class="pw-post-body-paragraph jx jy it jz b ka lp kc kd ke lq kg kh ki lr kk kl km ls ko kp kq lt ks kt ku im bi translated">自从我开始编写Go，我就觉得我写了太多的样板代码。Go码倾向于<a class="ae kv" href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself" rel="noopener ugc nofollow" target="_blank">湿</a>，即<a class="ae kv" href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself" rel="noopener ugc nofollow" target="_blank">干</a>的对立面。我觉得缺少泛型是问题的一个重要部分。所以，如果我相信Go是湿的，泛型会有帮助，我在Go中写了一个泛型包，让我们应用它看看。</p><h2 id="4eac" class="kw kx it bd ky kz la dn lb lc ld dp le ki lf lg lh km li lj lk kq ll lm ln lo bi translated">应用的泛型</h2><p id="9ab4" class="pw-post-body-paragraph jx jy it jz b ka lp kc kd ke lq kg kh ki lr kk kl km ls ko kp kq lt ks kt ku im bi translated">所以为了看看genfuncs是否有益，我选择了一个简单的围棋项目，<a class="ae kv" href="https://github.com/nwillc/gotimer" rel="noopener ugc nofollow" target="_blank"> gotimer </a>，看看应用genfuncs能做些什么。Gotimer是一个pomodoro time，它在内部接收ASCII“字体”表示的文件，并将其转换为可以显示的编码格式。有很多收集旅行，所以它似乎是一个合适的。</p><h2 id="7926" class="kw kx it bd ky kz la dn lb lc ld dp le ki lf lg lh km li lj lk kq ll lm ln lo bi translated">示例1</h2><p id="4af8" class="pw-post-body-paragraph jx jy it jz b ka lp kc kd ke lq kg kh ki lr kk kl km ls ko kp kq lt ks kt ku im bi translated">下面是处理一个代表单个字符的文件的代码:</p><figure class="lu lv lw lx gt ju"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="f4dd" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这不是我写过的最优雅的围棋，但也相当一般。使用genfuncs看起来是这样的:</p><figure class="lu lv lw lx gt ju"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="122a" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">好多了，一半长度，容易扫描，干代码多。它确实需要一些助手，这些助手是共享的:</p><figure class="lu lv lw lx gt ju"><div class="bz fp l di"><div class="ly lz l"/></div></figure><h2 id="dafa" class="kw kx it bd ky kz la dn lb lc ld dp le ki lf lg lh km li lj lk kq ll lm ln lo bi translated">示例2</h2><p id="f6ac" class="pw-post-body-paragraph jx jy it jz b ka lp kc kd ke lq kg kh ki lr kk kl km ls ko kp kq lt ks kt ku im bi translated">这里是读取单一字体的所有字符位图的地方:</p><figure class="lu lv lw lx gt ju"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="c385" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">使用genfuncs:</p><figure class="lu lv lw lx gt ju"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="ee88" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">同样，大约一半的代码，更清晰，更枯燥。</p><h2 id="cd8a" class="kw kx it bd ky kz la dn lb lc ld dp le ki lf lg lh km li lj lk kq ll lm ln lo bi translated">再来几杯</h2><p id="04bf" class="pw-post-body-paragraph jx jy it jz b ka lp kc kd ke lq kg kh ki lr kk kl km ls ko kp kq lt ks kt ku im bi translated">下面是几个用于获取可用颜色和字体列表的字符串描述的函数:</p><figure class="lu lv lw lx gt ju"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="adc1" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">使用genfuncs:</p><figure class="lu lv lw lx gt ju"><div class="bz fp l di"><div class="ly lz l"/></div></figure><p id="ea70" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这些字体很小，所以不会缩小很多，但是它们更清晰、更简洁，并且实际上改进了功能(更好的输出字符串和字体大小现在以正确的数字顺序排序)。</p><h2 id="7700" class="kw kx it bd ky kz la dn lb lc ld dp le ki lf lg lh km li lj lk kq ll lm ln lo bi translated">我对结果的看法</h2><p id="66e9" class="pw-post-body-paragraph jx jy it jz b ka lp kc kd ke lq kg kh ki lr kk kl km ls ko kp kq lt ks kt ku im bi translated">我认为应用Go的泛型实现了我所希望的:</p><ul class=""><li id="3fcb" class="ma mb it jz b ka kb ke kf ki mc km md kq me ku mf mg mh mi bi translated">较少代码</li><li id="82cb" class="ma mb it jz b ka mj ke mk ki ml km mm kq mn ku mf mg mh mi bi translated">更容易理解</li><li id="46c7" class="ma mb it jz b ka mj ke mk ki ml km mm kq mn ku mf mg mh mi bi translated">更干</li></ul><p id="324e" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我很高兴。现在如果我们能修复Go的错误处理…</p></div></div>    
</body>
</html>