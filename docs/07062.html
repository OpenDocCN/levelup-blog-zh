<html>
<head>
<title>Elegant animated line charts using react, react-spring, and SVG</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用react、react-spring和SVG的精美动画折线图</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/elegant-animated-line-charts-using-react-react-spring-and-svg-ae9a6051cf8e?source=collection_archive---------5-----------------------#2021-01-21">https://levelup.gitconnected.com/elegant-animated-line-charts-using-react-react-spring-and-svg-ae9a6051cf8e?source=collection_archive---------5-----------------------#2021-01-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/0558a48057e5afc22b08c53cb149e39e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rom2Ml3yRkKmqvXOns2gcQ.png"/></div></div></figure><p id="294d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我最近有机会在做一些承包工作的时候制作一个非常简洁的视觉效果。客户希望通过某种方式在登录页面上展示他们的成长。设计师想出了一种优雅的方式来显示这些信息，正如您在上面看到的，它以显示一些指标及其随时间增长的形式出现。我将此作为一个有趣的机会来深入研究SVG，并制作这些图表来帮助强调增长的显示。</p><p id="0ed8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我想分享一下我是如何完成这个实现的，这样你就可以了解如何以SVG为基础创建自己的简单图表视觉效果(因为为你的特定用例引入一个库可能没有意义)。我把这些图表移植到他们自己的存储库中，你可以<a class="ae kw" href="https://github.com/javery014/demo-animated-line-graphs" rel="noopener ugc nofollow" target="_blank">访问这里</a>。我将此演示分为以下几个步骤:</p><ol class=""><li id="bc9d" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated">静态呈现图表</li><li id="7e32" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">在线上添加动画和圆形提示</li></ol><p id="6ff3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本文中，为了简洁起见，我将更多地关注代码背后的重要概念，并偶尔从repo中提取代码来演示这个概念。在GitHub存储库中，每一步都有与之相关联的特定标记，因此您可以看到整个上下文。我认为这可能特别有帮助，例如，如果你想专注于阅读这条线最初是如何绘制的。我建议您查看第一个标签，这样与动画相关的逻辑就不会分散您的注意力。</p><h1 id="b483" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">为什么要react-spring和SVG？</h1><p id="c97f" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">首先，我喜欢保持轻依赖。我不想拉任何图表库，因为这可能是网站上唯一有图表的地方。我想通过深入研究SVG，我会了解到用相对较少的代码创建这些图表需要什么。</p><p id="731a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于动画，我已经选择在项目中使用react-spring，因为它的API为您提供了可以用于超级简单动画和更复杂过渡的spring。这是一把瑞士军刀。此外，他们的网站有一个例子，说明如何应用弹簧来动画数值增加，这正是我想要的。</p><p id="ec94" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，让我们深入研究一下。</p><h1 id="375c" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">静态呈现图表</h1><p id="2d22" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">首先，这里是这个部分的代码的<a class="ae kw" href="https://github.com/javery014/demo-animated-line-charts/tree/4.0.0" rel="noopener ugc nofollow" target="_blank">快照。正如我前面提到的，在这些步骤中，我将突出关键概念，并让您在GitHub repo的整个上下文中研究代码。</a></p><h2 id="99cc" class="mo lm iq bd ln mp mq dn lr mr ms dp lv kj mt mu lz kn mv mw md kr mx my mh mz bi translated">将数据点映射到SVG网格坐标</h2><p id="e6cd" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">要解决的第一个棘手问题是将数据点映射到能够在SVG中正确呈现的坐标。在映射这些数据时，我们需要考虑几个因素:</p><ol class=""><li id="613c" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated">笛卡尔坐标系的轴向右上方为正值。SVG坐标系的x轴表现相同，但是y轴实际上是正向下的。</li><li id="d92c" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">原始数据集需要缩放以适合SVG。原始数据点值可以是数千、数百万甚至更多。我的SVG元素只有255 x 88。因此，我想缩放这些数据点以适应。</li><li id="6216" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">图表的总体思路是将原始数据集的x值最低的数据点显示为起点(x=0)，x值最高的数据点(该指标的当前值)显示在图表的右上角。因此，我们需要将最终数据点的x和y坐标映射到各自轴的端点。</li></ol><p id="3345" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们看看<code class="fe na nb nc nd b">metric-chart-graph-helper.ts</code>中的<code class="fe na nb nc nd b">mapDataToSvgCoordinates</code>，这就是坐标转换发生的地方:</p><figure class="ne nf ng nh gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="c419" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此时，<code class="fe na nb nc nd b">dataPoints</code>是来自API的原始数据点的排序数组。第11–21行建立了我们的x和y轴相对于原始API数据的边界。对于每个轴，我们可以将SVG中的轴的长度除以这些原始的最小值和最大值，以获得一个比例因子，该比例因子可以乘以当前数据点的相应坐标。这为我们提供了可以在SVG中使用的映射数据点。关于y坐标的唯一额外步骤是，我们需要从最大y坐标中减去转换后的y坐标值，因为轴向下为正。</p><h2 id="5d89" class="mo lm iq bd ln mp mq dn lr mr ms dp lv kj mt mu lz kn mv mw md kr mx my mh mz bi translated">划清界限</h2><p id="1c9f" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">一旦我们有了SVG网格的映射数据点，画线就非常简单了。为此，我们将使用一个SVG <code class="fe na nb nc nd b">path</code>元素，并基于这些点以编程方式构建路径字符串。我们将使用两个路径命令:"<strong class="ka ir"> M </strong> ove to "和"<strong class="ka ir"> L </strong> ine "。让我们遍历映射的数据点，并将其缩减为一个表示路径的字符串。从第一个{x，y}坐标的<strong class="ka ir"> M- </strong> ing开始，然后在每次迭代中，给字符串添加一个<code class="fe na nb nc nd b">L {x} {y}</code>,画一条线到我们的下一个绝对点。这方面的代码如下:</p><figure class="ne nf ng nh gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><h2 id="f310" class="mo lm iq bd ln mp mq dn lr mr ms dp lv kj mt mu lz kn mv mw md kr mx my mh mz bi translated">平滑线条</h2><p id="9f73" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">在这一点上，如果我们要从这些数据点绘制一个线形图，它将看起来像这样:</p><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nk"><img src="../Images/18015f8fb3e650eb10e16db14fb36cf4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ci0_lqd4N1fZvKerxzV7TQ.png"/></div></div></figure><p id="882c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了视觉上的吸引力，我们想把它弄平滑。因此，我们不是用<strong class="ka ir"> L </strong> ine命令来构建我们的线，而是用<strong class="ka ir"> C </strong> ubic bezier命令来构建。减少每个点上的数组并将每个点的命令输出到结果路径字符串的过程是相同的，但是我们需要执行一些额外的逻辑来获得每个点的正确的<strong class="ka ir"> C </strong> ubic bezier命令。与其解释这个，我会给你看Franç ois Romain的一篇文章。我把这个逻辑改编成<code class="fe na nb nc nd b">smooth-curve.ts</code>:</p><figure class="ne nf ng nh gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="95f0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的<code class="fe na nb nc nd b">calculatePathSmooth</code>函数执行与我们的<code class="fe na nb nc nd b">calculatePath</code>函数相同的逻辑，但是现在为每个点添加了一个<strong class="ka ir"> C </strong>命令。现在我们很顺利:</p><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nl"><img src="../Images/92ffcead9eca2b5236381807bfb5f9e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E9I7IKoZfbDsOz4jQzlQZA.png"/></div></div></figure><h1 id="c3c2" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">动画线，并添加一个圆形提示</h1><p id="4002" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">首先，这是本节代码的<a class="ae kw" href="https://github.com/javery014/demo-animated-line-charts/tree/5.0.0" rel="noopener ugc nofollow" target="_blank">快照。</a></p><p id="dcc1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我在关于动画线条的部分中包含了圆的尖端，因为虽然我发现有许多方法可以将圆的尖端添加到静态线条，但是在动画线条的整个过程中，添加一个圆的尖端保持在线条的末端会更加困难。直到我最终弄清楚如何让圆和线同步，我一直在做这样的傻事:</p><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/86a7e060bd9bd1c6fd419bbc38b46f7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:440/1*yMdns-nbPRapZ3UguS9kbg.gif"/></div><figcaption class="nn no gj gh gi np nq bd b be z dk translated">圆提示不要在意</figcaption></figure><h2 id="7849" class="mo lm iq bd ln mp mq dn lr mr ms dp lv kj mt mu lz kn mv mw md kr mx my mh mz bi translated">实现这个动画的两个关键SVG属性</h2><p id="b13b" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">为了动画我们的线条，我们需要动画<code class="fe na nb nc nd b">&lt;path /&gt;</code>元素来“画”它自己。我们如何做到这一点？有一个巧妙的技巧来制作包含了<code class="fe na nb nc nd b">stroke-dasharray</code>和<code class="fe na nb nc nd b">stroke-dashoffset</code>属性的路径动画。简而言之，为<code class="fe na nb nc nd b">stroke-dasharray</code>设置一个单一的数值将导致路径具有长度为该定义值的破折号。设置<code class="fe na nb nc nd b">stroke-dashoffset</code>将根据指定的值移动这些虚线的起点。如果你设置<code class="fe na nb nc nd b">stroke-dasharray</code>等于路径的长度，那么路径将完全偏移，这样你“看到”的只是一个空白破折号。然后，你可以将<code class="fe na nb nc nd b">stroke-dashoffset</code>的动画降低到0，这将使线条自己进入视图，就像一个长破折号慢慢填满视觉路径一样。关于这项技术的更多信息可以在克里斯·科伊尔的文章中找到。</p><h2 id="1345" class="mo lm iq bd ln mp mq dn lr mr ms dp lv kj mt mu lz kn mv mw md kr mx my mh mz bi translated">我们如何得到路径的长度？</h2><p id="c0db" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">现在我们知道了动画路径背后的概念，我们需要找出一个关键变量来使<code class="fe na nb nc nd b">stroke-dashoffset</code>的动画有一个完美的起点和终点:路径的长度。我在这里采用的方法包括复制我们生成的路径。下面是来自<code class="fe na nb nc nd b">MetricChart.tsx</code>的一个片段，作为这两条路径之间关系的参考:</p><figure class="ne nf ng nh gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="7e4b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第1行的path元素是我们的“虚拟”ref。它是我们的SVG的非可视元素。我们像处理静态行一样渲染这个路径:立即将<code class="fe na nb nc nd b">d</code>属性设置为我们之前计算的SVG路径。你会看到我们在虚拟路径上有一个裁判。在一个<code class="fe na nb nc nd b">useEffect</code>钩子中，在初始渲染之后，我们将通过调用path ref元素上的<code class="fe na nb nc nd b">getTotalLength()</code>来获得路径的长度，并将其设置为一个<code class="fe na nb nc nd b">pathLength</code>状态变量。在下一次渲染时，我们将获得路径的长度，此时我们将把那个<code class="fe na nb nc nd b">pathLength</code>值作为道具传递给<code class="fe na nb nc nd b">MetricChartAnimatedLine</code>，后者将处理第二条路径的渲染，即实际的动画路径。</p><h2 id="0681" class="mo lm iq bd ln mp mq dn lr mr ms dp lv kj mt mu lz kn mv mw md kr mx my mh mz bi translated">用反应弹簧制作<code class="fe na nb nc nd b">stroke-dashoffset</code>动画</h2><p id="ea57" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">酷毙了。我们有了路径的长度，现在我们可以应用动画了。下面是来自<code class="fe na nb nc nd b">MetricChartAnimatedLine.tsx</code>的一个片段，它只包含显示我们创建的spring和<code class="fe na nb nc nd b">path</code>元素之间关系的代码:</p><figure class="ne nf ng nh gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="02e9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们使用react-spring提供的<code class="fe na nb nc nd b">useSpring</code>钩子来表示我们想要一个从路径的<code class="fe na nb nc nd b">length</code>下降到0的弹簧。然后我们使用同样从react-spring导出的<code class="fe na nb nc nd b">animated.path</code>组件来消耗<code class="fe na nb nc nd b">strokeDashoffset</code>属性上的spring值。正如我们前面提到的，另一个关键步骤是将<code class="fe na nb nc nd b">strokeDasharray</code>属性设置为路径的<code class="fe na nb nc nd b">length</code>值。现在我们有了一条动画线:</p><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/bae2463ba1d2a9b50a2f55f7c345177a.png" data-original-src="https://miro.medium.com/v2/resize:fit:888/1*CWp9qt6FnXHhsCH3-hY0pA.gif"/></div></figure><h2 id="57c9" class="mo lm iq bd ln mp mq dn lr mr ms dp lv kj mt mu lz kn mv mw md kr mx my mh mz bi translated">添加圆尖</h2><p id="0a14" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">现在，让我们添加一个在动画过程中停留在线尖的圆来结束它。我尝试了这么多不同的方法来画一个圆，并试图让它遵循动画路径和精确的时间。在SVG中没有办法给你的路径添加一个半径大于你的线宽度的点。您可以绕过路径的尖端，但这并不能完全解决我们的问题。</p><p id="7076" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我添加圆的解决方案是将圆写成另一个<code class="fe na nb nc nd b">&lt;path /&gt;</code>元素。作为参考，下面是圆的路径的样子(就像动画线的路径元素一样，我使用react-spring <code class="fe na nb nc nd b">animated.path</code>组件来制作动画…稍后将对此进行描述):</p><figure class="ne nf ng nh gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="25ba" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们给这个元素一个和动画线完全一样的路径。我们将遵循与制作线条动画相同的策略来制作圆圈动画。使用相同的弹簧并将其应用于两个元素可以保持动画同步。厉害！</p><p id="2138" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是是什么让这条路径看起来像一个圆呢？这里重点关注的属性有<code class="fe na nb nc nd b">strokeWidth</code>、<code class="fe na nb nc nd b">strokeLinecap</code>和<code class="fe na nb nc nd b">strokeDasharray</code>。我们首先设置<code class="fe na nb nc nd b">strokeWidth</code>为10，这将使我们的圆的直径达到10px。然后，我们将<code class="fe na nb nc nd b">strokeLinecap</code>设置为“圆形”，使路径的尖端变圆。如果我们只设置这些属性，路径看起来应该是这样的:</p><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/9c05320cf68996536400b2e0e858b602.png" data-original-src="https://miro.medium.com/v2/resize:fit:1148/format:webp/1*F9e6brjY1SNm2AUfHQwvJg.png"/></div></figure><p id="9363" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在是<code class="fe na nb nc nd b">strokeDasharray</code>，这是所有奇迹发生的地方。除了将单个数值设置为<code class="fe na nb nc nd b">strokeDasharray</code>之外，这将为您提供一个空格和破折号长度相等的路径，您还可以(如属性名所示)将该属性设置为一个数值数组。在这种情况下，我们将破折号长度设置为0，并将破折号之间的间距设置为路径的长度。使用零长度虚线和圆形线帽，路径将呈现为圆形。然后，当<code class="fe na nb nc nd b">strokeDashoffset</code>属性被激活时，您将看到圆圈沿着直线向右移动。</p><p id="9757" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">还有最后一点可以让这个完美。在这一点上，如果我们保持之前为直线路径定义的相同弹簧，并将其应用于圆形路径，我发现当动画结束时，圆形会跳回到直线的起点。所以，我对弹簧做的一个小调整是，不是将弹簧中的<code class="fe na nb nc nd b">value</code>动画降低到0，而是将其动画降低到1。这就像预期的那样，在图表的右上角留下了一个圆圈。</p><h1 id="f725" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">我们完了！</h1><p id="4427" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">成品看起来是这样的:</p><figure class="ne nf ng nh gt jr gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/d3335a8ada0338d7cf5403e135143079.png" data-original-src="https://miro.medium.com/v2/resize:fit:884/1*Ot4Mv5CmRBgNRStFRgI5MA.gif"/></div></figure><p id="e0d9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">相当酷！我从这个动画的各个部分学到了很多很酷的技术，我希望即使你不需要复制这个动画(你可能不需要)，这篇文章也是一个有用的资源，它汇集了一些对你可能正在做的类似任务有用的技术。</p><p id="9bbe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如我在开始时提到的，我更想讨论这个动画背后的主要概念，同时向您展示一些代码来帮助展示这些概念。您当然可以自己检查代码来查看动画中涉及的所有内容。最后，我将快速描述代码的一些方面，我不认为这些方面与本文的目标有太大关系，但是您可能会感兴趣:</p><ul class=""><li id="20cf" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv nu ld le lf bi translated">对于紫色框中的计数器，我也使用了react-spring。为了帮助动画与线条保持同步，我有一个名为<code class="fe na nb nc nd b">playAnimation</code>的状态变量，当设置为<code class="fe na nb nc nd b">true</code>时，它将同时启动数字和线条的动画。在最初渲染之后，<code class="fe na nb nc nd b">MetricChartAnimatedLine.tsx</code>中的<code class="fe na nb nc nd b">playAnimation</code>被设置为<code class="fe na nb nc nd b">true</code>，因为当该组件被渲染时，这意味着<code class="fe na nb nc nd b">pathLength</code>已经被计算，我们现在已经拥有了在下一次渲染时开始动画所需的一切。</li><li id="6eed" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv nu ld le lf bi translated">react-spring非常适合创建感觉更自然的动画，因为它基于spring物理学。你可能会注意到，我在弹簧上设置了一个特定的<code class="fe na nb nc nd b">duration</code>。这样做是为了确保所有的动画同时结束。否则，最终值以百万计的图表将永远无法完成动画制作。</li></ul></div></div>    
</body>
</html>