<html>
<head>
<title>The power of Swift + Web Assembly (Part 3)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift + Web Assembly的力量(第三部分)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/the-power-of-swift-web-assembly-part-3-e583c6ab8afe?source=collection_archive---------4-----------------------#2020-10-17">https://levelup.gitconnected.com/the-power-of-swift-web-assembly-part-3-e583c6ab8afe?source=collection_archive---------4-----------------------#2020-10-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="73da" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">导入的函数:从运行时应用程序调用函数</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/a5e1806554ea15b474e30c3a137a30ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*duPJW32aIIQ16riCr3eNnQ.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">图片来自<a class="ae kv" href="https://prog.hu/welcome/" rel="noopener ugc nofollow" target="_blank">https://prog.hu/welcome/</a></figcaption></figure><p id="cd47" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是<strong class="ky ir"><em class="ls">Swift+Web Assembly</em></strong>教程的第3部分，也是最后一部分，该教程更侧重于一个高级主题，即导入函数，其中二进制代码从Go应用程序调用函数。在过去的2部分中，我们看到了如何从Swift包中生成wasm二进制文件，并将其加载到Go应用程序中。此外，我们还学习了如何在Swift中定义可以从Go应用程序中调用的公共函数。在这一部分，我们学习如何让二进制调用Go应用程序的函数。如果您还没有阅读第1部分和第2部分，请从那里开始。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="6a93" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">导入的函数</h1><p id="4c37" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">想象一个场景，其中二进制文件需要从数据库中获取数据。在这种情况下，二进制文件必须能够从Go应用程序中调用一些函数，因为它不能访问主数据库。</p><h2 id="c86a" class="mx mb iq bd mc my mz dn mg na nb dp mk lf nc nd mm lj ne nf mo ln ng nh mq ni bi translated">生成模块地图</h2><p id="62a8" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">首先，我们需要添加<em class="ls"> c </em>头文件，并为Swift项目制作一个<em class="ls"> modulemap </em>。在<em class="ls">源</em>下添加以下目录</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/f4e5ca2b13f365da692e5ca017a324c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:816/format:webp/1*wbBETwPQM5bjnuDHyV6TTw.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">c_header和模块映射</figcaption></figure><p id="0123" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">打开头文件<em class="ls"> c_header.h </em>，如下定义导入的函数</p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="a321" class="mx mb iq nl b gy np nq l nr ns">#ifndef c_header_h<br/>#define c_header_h</span><span id="b23d" class="mx mb iq nl b gy nt nq l nr ns">#include &lt;stdlib.h&gt;<br/>#include &lt;stdint.h&gt;<br/>#if __wasm32__</span><span id="f859" class="mx mb iq nl b gy nt nq l nr ns">__attribute__((__import_name__("fetch_code")))<br/>extern int c_fetchCode(int input);</span><span id="09ec" class="mx mb iq nl b gy nt nq l nr ns">#endif<br/>#endif /* c_header_h */</span></pre><p id="f61b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<em class="ls"> c_header.c </em>中你只需要导入头文件</p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="3924" class="mx mb iq nl b gy np nq l nr ns">#include "c_header.h"<br/>#include &lt;stdlib.h&gt;</span></pre><p id="b032" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要使Swift文件中的标题可访问，您必须通过生成<em class="ls">模块映射</em>将其打包</p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="3482" class="mx mb iq nl b gy np nq l nr ns">module c_header {<br/>  header "include/c_header.h"<br/>  link "c_header"<br/>  export *<br/>}</span></pre><p id="8c96" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，您必须定义一个新的目标，并将其作为依赖项添加到主项目中。</p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="d4c8" class="mx mb iq nl b gy np nq l nr ns">import PackageDescription</span><span id="e539" class="mx mb iq nl b gy nt nq l nr ns">let package = Package(<br/>    name: "swiftwasm",<br/>    targets: [<br/>      .target(name: "c_header", dependencies: []),<br/>      .target(name: "swiftwasm", dependencies: ["c_header"]),<br/>    ]<br/>)</span></pre><h2 id="d497" class="mx mb iq bd mc my mz dn mg na nb dp mk lf nc nd mm lj ne nf mo ln ng nh mq ni bi translated">添加公共函数</h2><p id="1f83" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">如果你做的一切都是正确的，在<em class="ls"> main.swift </em>中导入<em class="ls"> c_header </em>应该不会出现错误</p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="f8fd" class="mx mb iq nl b gy np nq l nr ns">import c_header</span></pre><p id="9bf1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了能够测试我们在<em class="ls"> c_header.h中定义的<em class="ls"> "fetch_code" </em>函数，</em>创建一个公共函数并从Go调用它。(实际上，其他一些Swift函数可能会调用<em class="ls"> fetch_code </em>，但现在让我们简化一下)</p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="9c8c" class="mx mb iq nl b gy np nq l nr ns"><a class="ae kv" href="http://twitter.com/_cdecl" rel="noopener ugc nofollow" target="_blank">@_cdecl</a>("fetch")<br/>func fetchCodefromHost(input: Int32) -&gt; Int32 {<br/>  return c_fetchCode(input);<br/>}</span></pre><h2 id="bdc0" class="mx mb iq bd mc my mz dn mg na nb dp mk lf nc nd mm lj ne nf mo ln ng nh mq ni bi translated">更新Go应用程序</h2><p id="dd2b" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">目前，我们已经在<em class="ls"> c头</em>中定义了一个函数，并在Swift文件中调用它，但是函数<em class="ls"> c_fetchCode </em>还没有实现。重点是，作为一个导入的函数，实现应该由Go应用程序来完成。让我们看看怎么做。</p><p id="64ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">首先，</strong>从定义Go应用中的C函数签名开始。重点是，该函数必须具有与您已经在Swift项目<strong class="ky ir">的<em class="ls"> c_header </em>中定义的签名相同的签名，但是您必须始终将第一个参数定义为<em class="ls"> void* </em> </strong></p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="97f5" class="mx mb iq nl b gy np nq l nr ns">// #include &lt;stdlib.h&gt;<br/>//<br/>// extern int fetchCode(void *, int);<br/>import "C"</span></pre><p id="35bb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">第二个</strong>，在Go中实现该功能，并将其导出以匹配您在上面已经提供的名称</p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="d8df" class="mx mb iq nl b gy np nq l nr ns">//export fetchCode<br/>func fetchCode(context unsafe.Pointer, input C.int) C.int {<br/> return input * 2<br/>}</span></pre><p id="1483" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">第三个</strong>，创建一个新的<em class="ls">导入</em>，它将C定义绑定到Go实现，并在实例化二进制文件时将其添加到wasm导入对象中，完成后不要忘记关闭它。</p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="5123" class="mx mb iq nl b gy np nq l nr ns">import (<br/> "fmt"<br/> "unsafe"</span><span id="9fe6" class="mx mb iq nl b gy nt nq l nr ns"> "github.com/wasmerio/go-ext-wasm/wasmer"<br/>)</span><span id="130e" class="mx mb iq nl b gy nt nq l nr ns">func main() {<br/> ..........</span><span id="9956" class="mx mb iq nl b gy nt nq l nr ns"> // Make new C imports<br/> imports := wasmer.NewImports()<br/> imports, err = imports.AppendFunction("fetch_code", fetchCode, C.fetchCode)<br/> if err != nil {<br/>  panic(err)<br/> }</span><span id="8546" class="mx mb iq nl b gy nt nq l nr ns"> // Extend the import objects with C imports<br/> importObject.Extend(*imports)</span><span id="6584" class="mx mb iq nl b gy nt nq l nr ns"> // Instantiates the WebAssembly module using derived import objects.<br/> instance, err := module.InstantiateWithImportObject(importObject)<br/> if err != nil {<br/>  panic(err)<br/> }<br/> defer importObject.Close()<br/> defer imports.Close()<br/> defer instance.Close()</span><span id="1239" class="mx mb iq nl b gy nt nq l nr ns"> fmt.Println(fetchCodeOnBinary(&amp;instance, 2))<br/> fmt.Println(fetchCodeOnBinary(&amp;instance, 5))<br/>}</span></pre><p id="0baf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">最后，</strong>构建Swift项目并将wasm二进制复制到Go目录中，然后运行Go项目</p><pre class="kg kh ki kj gt nk nl nm nn aw no bi"><span id="9bf7" class="mx mb iq nl b gy np nq l nr ns">$ TOOLCHAIN_PATH=$(cd $(dirname "$(swiftenv which swiftc)") &amp;&amp; cd ../share &amp;&amp; pwd)<br/>$ swift build --triple wasm32-unknown-wasi -c release --toolchain $TOOLCHAIN_PATH -Xlinker --export=fetch -Xlinker --allow-undefined</span><span id="5ab9" class="mx mb iq nl b gy nt nq l nr ns">$ go run ./<br/>&gt; 4<br/>&gt; 10</span></pre></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="76a7" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">结束了</h1><p id="13a4" class="pw-post-body-paragraph kw kx iq ky b kz ms jr lb lc mt ju le lf mu lh li lj mv ll lm ln mw lp lq lr ij bi translated">如果您仔细地遵循了这3个部分，您就能够在Go应用程序中轻松地构建Swift wasm二进制文件、加载并与之通信。你可以在GitHub上找到Swift和Go项目</p></div></div>    
</body>
</html>