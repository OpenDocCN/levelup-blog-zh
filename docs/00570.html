<html>
<head>
<title>Closures, first-class functions and higher-order functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">闭包、一级函数和高阶函数</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/closures-first-class-and-higher-order-functions-2dc97dc89cd8?source=collection_archive---------1-----------------------#2019-05-12">https://levelup.gitconnected.com/closures-first-class-and-higher-order-functions-2dc97dc89cd8?source=collection_archive---------1-----------------------#2019-05-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/172b15c8d7633dae07dd0735009f66ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Hx580MCLXr-CTHZU"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@pankajpatel?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Pankaj Patel </a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="b898" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">程序员使用他们的行话，这很好，因为这使得交流不那么模糊。但是有些短语听起来可能比实际更复杂。当我第一次听说闭包、一级函数和高阶函数时，我认为它们是复杂的概念，如果我问它们是什么，我害怕看起来很愚蠢。事实证明，它们并不像我想象的那样复杂，我将用这篇文章来解释它们是什么。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="03a0" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">一级功能</h1><p id="fbb7" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">一级函数比你想象的要简单得多，JavaScript也有一级函数。这意味着函数和其他变量一样被对待。可以在其他函数中作为参数使用，函数可以返回函数，函数可以保存在变量中。</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="251d" class="mu lj iq mq b gy mv mw l mx my">// Saving a function in a variable<br/>const myFirstFunc = () =&gt; 10</span><span id="d3f7" class="mu lj iq mq b gy mz mw l mx my">// Passing a function as an argument<br/>const mySecondFunc = (funcParam) =&gt; { <br/>  return console.log(funcParam())<br/>}</span><span id="78e1" class="mu lj iq mq b gy mz mw l mx my">// Returning a function from a function<br/>const myThirdFunc = () =&gt; {<br/>  return () =&gt; console.log('Hello from returned function')<br/>}</span></pre><h1 id="f770" class="li lj iq bd lk ll na ln lo lp nb lr ls lt nc lv lw lx nd lz ma mb ne md me mf bi translated">高阶函数</h1><p id="4377" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">一旦你理解了一级函数，你就已经看到了一个高阶函数的例子。高阶函数是以函数为参数、返回函数或两者兼有的函数。</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="8b69" class="mu lj iq mq b gy mv mw l mx my">const myFirstHigherOrderFunc = () =&gt; {<br/><strong class="mq ir">  return () =&gt; {<br/>    const output = 'Returned from a higher order function'<br/>    console.log(output)<br/>  }</strong><br/>}</span><span id="b440" class="mu lj iq mq b gy mz mw l mx my">const mySecondHigherOrderFunc = (<strong class="mq ir">funcParam</strong>) =&gt; {<br/>  <strong class="mq ir">funcParam()</strong><br/>}</span></pre><h1 id="4c15" class="li lj iq bd lk ll na ln lo lp nb lr ls lt nc lv lw lx nd lz ma mb ne md me mf bi translated">什么时候用？</h1><p id="5573" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">高阶函数和一级函数都是常用的，只是我们没有考虑太多，因为它是JavaScript的基础。例如，当向HTML元素添加事件监听器时。</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="7d15" class="mu lj iq mq b gy mv mw l mx my">const <strong class="mq ir">clickHandler</strong> = (event) =&gt; { <br/>    console.log(`${event.target.id} is clicked`)<br/>}</span><span id="4a77" class="mu lj iq mq b gy mz mw l mx my">document.querySelector(‘#someId’)<br/>  .<strong class="mq ir">addEventListener(</strong>'click', <strong class="mq ir">clickHandler)</strong></span></pre><h1 id="93d5" class="li lj iq bd lk ll na ln lo lp nb lr ls lt nc lv lw lx nd lz ma mb ne md me mf bi translated">关闭</h1><p id="119d" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">闭包是我认为非常混乱的概念之一，主要是因为我不明白它为什么有用。如果你有同样的感觉，请稍等，我会试着解释一下。</p><p id="b1b2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">闭包<strong class="kf ir">将外部作用域保存在内部作用域</strong>中。现在可能没什么好说的，一个常用的例子是计数器。</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="2403" class="mu lj iq mq b gy mv mw l mx my">// Without closure<br/>const <strong class="mq ir">withoutClosure</strong> = () =&gt; {<br/>  let counter = 0 <br/>  return ++counter<br/>}</span><span id="f702" class="mu lj iq mq b gy mz mw l mx my">console.log(<strong class="mq ir">withoutClosure</strong>()) // Prints: 1<br/>console.log(<strong class="mq ir">withoutClosure</strong>()) // Prints: 1<br/>console.log(<strong class="mq ir">withoutClosure</strong>()) // Prints: 1</span></pre><p id="c9b0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">函数<code class="fe nf ng nh mq b">withoutClosure</code>是一个普通函数。每次执行函数时，变量counter将被声明并初始化为0，然后递增到1。变量只在函数执行期间存在，之后它将被垃圾收集并被移除。</p><p id="2bea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们看一个使用闭包的类似函数。</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="4fe0" class="mu lj iq mq b gy mv mw l mx my">// With closure<br/>const <strong class="mq ir">myClosure</strong> = () =&gt; {<br/>  let counter = 0<br/>  return () =&gt; ++counter<br/>}</span><span id="2224" class="mu lj iq mq b gy mz mw l mx my">const <strong class="mq ir">incrementCount</strong> = <strong class="mq ir">myClosure</strong>()<br/>console.log(<strong class="mq ir">incrementCount</strong>()) // Prints: 1<br/>console.log(<strong class="mq ir">incrementCount</strong>()) // Prints: 2<br/>console.log(<strong class="mq ir">incrementCount</strong>()) // Prints: 3</span></pre><p id="132a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，变量递增到下一个数字。发生了什么事？</p><p id="420b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我们声明一个名为<code class="fe nf ng nh mq b">myClosure</code>的函数，这个函数声明一个名为<code class="fe nf ng nh mq b">counter</code>的变量，并用值0初始化它。在<code class="fe nf ng nh mq b">myClosure</code>内部，我们还声明了一个匿名函数，然后从<code class="fe nf ng nh mq b">myClosure</code>返回。匿名函数在这里不被执行，只被返回。<code class="fe nf ng nh mq b">myClosure</code>是高阶函数。</p><p id="91cb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当<code class="fe nf ng nh mq b">myClosure</code>被执行时，返回值被保存在一个名为<code class="fe nf ng nh mq b">incrementCount</code>的变量中。如前所述，JavaScript中的函数是一级函数，所以我们可以很容易地将它们保存在变量中。现在，当我们执行保存在<code class="fe nf ng nh mq b">incrementCount</code>中的函数时，计数器按预期递增。这是一个奇怪而又非常有用的部分。</p><p id="8b02" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以让我们退一步讲基本功能。一个函数可以到达它周围范围内的变量。这里没什么奇怪的。我相信你见过这样的代码:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="e0fc" class="mu lj iq mq b gy mv mw l mx my">let name = ‘Foo’</span><span id="137d" class="mu lj iq mq b gy mz mw l mx my">const greeter = (name) =&gt;{<br/>  console.log(`Hello ${name}!`)<br/>}</span><span id="54ec" class="mu lj iq mq b gy mz mw l mx my">greeter(name) //Prints: Hello Foo</span></pre><p id="8bd7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这只是一个普通的函数到达它周围范围内的一个变量。</p><p id="5f2a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在闭包的情况下，我们返回的函数也可以到达在其周围作用域中声明的变量。当保存在<code class="fe nf ng nh mq b">incrementCount</code>中的函数被执行时，它到达声明时包围它的作用域。即使我们作为程序员不能到达在<code class="fe nf ng nh mq b">myClosure</code>中声明的变量<code class="fe nf ng nh mq b">counter</code>，但是返回的函数可以。</p><p id="9dad" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么这为什么有用呢？嗯，有多种用例，但最简单的一种是可以声明变量而不会混淆全局范围。该变量将只在需要的地方使用。这就是我们如何在JavaScript中创建类似私有变量的东西。</p><p id="7b11" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们看一下下面的代码</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="be9f" class="mu lj iq mq b gy mv mw l mx my">const <strong class="mq ir">closure</strong> = () =&gt; {<br/>  let name = ‘name not set’<br/>  return {<br/>    <strong class="mq ir">setName</strong>: (<em class="ni">value</em>) =&gt; {name = value},<br/>    <strong class="mq ir">getName</strong>: () =&gt; name<br/>  }<br/>}</span><span id="41a7" class="mu lj iq mq b gy mz mw l mx my">const objFromClosure = <strong class="mq ir">closure</strong>()</span><span id="b283" class="mu lj iq mq b gy mz mw l mx my">console.log(objFromClosure.name) //Prints: undefined<br/>console.log(objFromClosure.<strong class="mq ir">getName</strong>()) //Prints: name not set<br/>console.log(objFromClosure.<strong class="mq ir">setName</strong>(‘Foo’))<br/>console.log(objFromClosure.name) // Prints: undefined<br/>console.log(objFromClosure.<strong class="mq ir">getName</strong>()) // Prints: Foo</span></pre><ul class=""><li id="56a6" class="nj nk iq kf b kg kh kk kl ko nl ks nm kw nn la no np nq nr bi translated">闭包用于使<code class="fe nf ng nh mq b">let name</code>变量私有。</li><li id="095f" class="nj nk iq kf b kg ns kk nt ko nu ks nv kw nw la no np nq nr bi translated">第一个<code class="fe nf ng nh mq b">console.log</code>打印undefined，因为属性名不在范围内。</li><li id="3056" class="nj nk iq kf b kg ns kk nt ko nu ks nv kw nw la no np nq nr bi translated">第二个<code class="fe nf ng nh mq b">console.log</code>使用了一个叫做<code class="fe nf ng nh mq b">getName</code>的方法，所以我们得到了默认的字符串“name not set ”,它是在闭包的外部作用域中设置的值。</li><li id="5b22" class="nj nk iq kf b kg ns kk nt ko nu ks nv kw nw la no np nq nr bi translated">然后我们将名称设置为Foo。</li><li id="662e" class="nj nk iq kf b kg ns kk nt ko nu ks nv kw nw la no np nq nr bi translated">没有getters和setters，我们仍然无法获得属性名。</li><li id="2aec" class="nj nk iq kf b kg ns kk nt ko nu ks nv kw nw la no np nq nr bi translated">使用<code class="fe nf ng nh mq b">getName</code>方法，新名称被打印到控制台。</li></ul><h1 id="aa5a" class="li lj iq bd lk ll na ln lo lp nb lr ls lt nc lv lw lx nd lz ma mb ne md me mf bi translated">概括起来</h1><p id="db71" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">具有一级函数的语言将函数视为变量。高阶函数只是一个函数返回一个函数，或者以一个函数作为参数。</p><p id="a26a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">闭包用于将外部作用域保留在内部作用域中。这有助于避免全局范围内的变量变得杂乱，也有助于使变量看起来像是私有的。</p><p id="8be4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就是所有希望这篇文章给你一些东西。</p></div></div>    
</body>
</html>