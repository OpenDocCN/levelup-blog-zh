<html>
<head>
<title>Let’s “Go” and build Graphql API with gqlgen</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们开始用gqlgen构建Graphql API</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/lets-go-and-build-graphql-api-with-gqlgen-bfea2f346ea1?source=collection_archive---------5-----------------------#2021-07-27">https://levelup.gitconnected.com/lets-go-and-build-graphql-api-with-gqlgen-bfea2f346ea1?source=collection_archive---------5-----------------------#2021-07-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/1d683b0aff232157f83ac89d03411586.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ip3NcxCZAeOku5UjgbuJWA.png"/></div></div></figure><p id="c5ae" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Golang是过去十年中最受欢迎的编程语言之一，主要是因为它是一种快速、高性能、开源的统计类型编译编程语言。Go早在2009年就由google way开发，作为C++和Java的替代品，包括C++和Java的所有酷功能，为google的网络服务器和分布式系统创建可扩展的应用程序。</p><ul class=""><li id="b44e" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated"><em class="li">快速性能</em></li><li id="580b" class="kz la it kd b ke lj ki lk km ll kq lm ku ln ky le lf lg lh bi translated"><em class="li">简单易学</em></li><li id="68e3" class="kz la it kd b ke lj ki lk km ll kq lm ku ln ky le lf lg lh bi translated"><em class="li">轻松并发模型</em></li><li id="95c7" class="kz la it kd b ke lj ki lk km ll kq lm ku ln ky le lf lg lh bi translated"><em class="li">强大的标准库</em></li></ul><p id="d5c0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当Golang迅速流行起来的时候，API世界发生了一场范式变革。最受欢迎的REST架构被一个新的竞争对手Graphql继承了下来。与Graphql中的REST架构不同，一切都被视为一个图，这意味着它与定义的实体相关联。因此，您可以只请求获取所需的详细信息。Graphql有一个基于模式的API架构，带有一个<strong class="kd iu">健壮类型系统</strong>，它本质上告诉客户端如何访问数据。遵循这个模式的主要好处是前端和后端开发人员都知道数据结构，因此可以独立工作。</p><p id="3082" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如你所知，Grapghql和Go lang是两种卓越的技术。如果我们用Go lang构建一个Graphql API会怎么样？这将是一个非常有趣的组合，让我们来看看Graphql和Go lang相处得如何。在Go lang中实现Graphql API有各种各样的库。其中，以下是最著名的。</p><ul class=""><li id="d20f" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated"><a class="ae lo" href="https://github.com/99designs/gqlgen" rel="noopener ugc nofollow" target="_blank"> gqlgen </a></li><li id="4484" class="kz la it kd b ke lj ki lk km ll kq lm ku ln ky le lf lg lh bi translated"><a class="ae lo" href="https://github.com/graph-gophers/graphql-go" rel="noopener ugc nofollow" target="_blank">地鼠</a></li><li id="f1ee" class="kz la it kd b ke lj ki lk km ll kq lm ku ln ky le lf lg lh bi translated"><a class="ae lo" href="https://github.com/graphql-go/graphql" rel="noopener ugc nofollow" target="_blank">图表ql-go </a></li><li id="a836" class="kz la it kd b ke lj ki lk km ll kq lm ku ln ky le lf lg lh bi translated"><a class="ae lo" href="https://github.com/samsarahq/thunder" rel="noopener ugc nofollow" target="_blank">惊雷</a></li></ul><h1 id="7ac1" class="lp lq it bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">什么是<strong class="ak"> gqlgen </strong></h1><p id="73ae" class="pw-post-body-paragraph kb kc it kd b ke mn kg kh ki mo kk kl km mp ko kp kq mq ks kt ku mr kw kx ky im bi translated">gqlgen 是一个用于Go的类型安全GraphQL。gqlgen是由<a class="ae lo" href="https://99designs.com/" rel="noopener ugc nofollow" target="_blank"> 99Designs </a>通过权衡其他库如<a class="ae lo" href="https://github.com/graph-gophers/graphql-go" rel="noopener ugc nofollow" target="_blank"> gophers </a>和<a class="ae lo" href="https://github.com/graphql-go/graphql" rel="noopener ugc nofollow" target="_blank"> graphql-go </a>开发的。两者都缺乏通用特性，引入了样板代码和名称空间冲突，难以阅读。gqlgen的目标是提供</p><ul class=""><li id="ab0a" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated">键入不带样板代码的Safty</li><li id="8f60" class="kz la it kd b ke lj ki lk km ll kq lm ku ln ky le lf lg lh bi translated">良好的开发者体验</li><li id="569a" class="kz la it kd b ke lj ki lk km ll kq lm ku ln ky le lf lg lh bi translated">快速运行时间</li></ul><p id="1148" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所以gqlgen可以被认为是他们两个的接班人。</p><h1 id="a238" class="lp lq it bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">是什么让它独一无二</h1><ul class=""><li id="f371" class="kz la it kd b ke mn ki mo km ms kq mt ku mu ky le lf lg lh bi translated"><strong class="kd iu">模式优先</strong> —使用GraphQL <a class="ae lo" href="http://graphql.org/learn/schema/" rel="noopener ugc nofollow" target="_blank">模式定义语言</a>定义您的API。</li><li id="a837" class="kz la it kd b ke lj ki lk km ll kq lm ku ln ky le lf lg lh bi translated"><strong class="kd iu">类型安全</strong>——你永远不会在这里看到<code class="fe mv mw mx my b">map[string]interface{}</code>。</li><li id="3d66" class="kz la it kd b ke lj ki lk km ll kq lm ku ln ky le lf lg lh bi translated"><strong class="kd iu">Codegen</strong>——让我们生成枯燥的代码，这样你就可以快速构建你的应用。</li></ul><h1 id="28fe" class="lp lq it bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">gqlgen与gophers、graphql-go和thunder的比较</h1><p id="147b" class="pw-post-body-paragraph kb kc it kd b ke mn kg kh ki mo kk kl km mp ko kp kq mq ks kt ku mr kw kx ky im bi translated">下面是这四个库之间的一个很好的比较。</p><figure class="na nb nc nd gt ju gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/a92fd28bd0c8aaf8cad195c0dd16b9bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1284/format:webp/1*Z5GBxNRZv5V5LeoFAayOrg.png"/></div></figure><p id="b0a5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">从这个比较中，我们可以看出为什么与其他go-graphql客户端相比，gqlgen是一个更好的解决方案。所以让我们从创建一个graphql API开始。</p><h1 id="3482" class="lp lq it bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">gqlgen入门</h1><p id="1f7f" class="pw-post-body-paragraph kb kc it kd b ke mn kg kh ki mo kk kl km mp ko kp kq mq ks kt ku mr kw kx ky im bi translated">在本节中，让我们用Go和gqlgen创建一个口袋妖怪应用程序。</p><h2 id="cee5" class="ne lq it bd lr nf ng dn lv nh ni dp lz km nj nk md kq nl nm mh ku nn no ml np bi translated">01:初始化项目</h2><p id="2073" class="pw-post-body-paragraph kb kc it kd b ke mn kg kh ki mo kk kl km mp ko kp kq mq ks kt ku mr kw kx ky im bi translated">让我们初始化我们的gqlgen项目。让我们在项目根目录下的终端上运行以下命令。</p><pre class="na nb nc nd gt nq my nr ns aw nt bi"><span id="5112" class="ne lq it my b gy nu nv l nw nx">go mod init github.com/[username]/gqlgen-pokemon<br/>go run github.com/99designs/gqlgen init</span></pre><p id="1e0c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">上述命令将在您的项目根目录下生成一些文件和目录。</p><ul class=""><li id="f5ff" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated"><code class="fe mv mw mx my b">gqlgen.yml</code>—gqlgen配置文件，您可以在其中更改或添加GraphQL服务器的配置。该文件定义了解析器、模型和模式文件的位置。</li><li id="a282" class="kz la it kd b ke lj ki lk km ll kq lm ku ln ky le lf lg lh bi translated"><code class="fe mv mw mx my b">graph/generated/generated.go</code>—graph QL执行运行时，生成的大部分代码。您不需要对此进行编辑</li><li id="fa41" class="kz la it kd b ke lj ki lk km ll kq lm ku ln ky le lf lg lh bi translated"><code class="fe mv mw mx my b">graph/model/models_gen.go</code> —生成构建图形所需的模型。对<code class="fe mv mw mx my b">schema.graphqls</code>的更改将重新生成该文件。</li><li id="259b" class="kz la it kd b ke lj ki lk km ll kq lm ku ln ky le lf lg lh bi translated"><code class="fe mv mw mx my b">graph/schema.graphqls</code> —这是您将添加GraphQL模式的文件。</li><li id="6afa" class="kz la it kd b ke lj ki lk km ll kq lm ku ln ky le lf lg lh bi translated"><code class="fe mv mw mx my b">graph/resolvers.go</code> —这是gqlgen将生成Go结构的文件，它将模式绑定到我们的GraphQL服务器</li><li id="eb8a" class="kz la it kd b ke lj ki lk km ll kq lm ku ln ky le lf lg lh bi translated"><code class="fe mv mw mx my b">graph/schema.resolvers.go</code> —这是你的应用程序代码所在的地方。generated.go将调用这个来获取用户请求的数据。</li><li id="89df" class="kz la it kd b ke lj ki lk km ll kq lm ku ln ky le lf lg lh bi translated"><code class="fe mv mw mx my b">server.go</code>:这是我们为GraphQL playground定义端点的服务器文件。这个文件是您的服务器应用程序的起点</li></ul><p id="cc3d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，让我们为我们的应用程序定义模式。</p><h2 id="2035" class="ne lq it bd lr nf ng dn lv nh ni dp lz km nj nk md kq nl nm mh ku nn no ml np bi translated">02:定义我们的模式</h2><p id="1548" class="pw-post-body-paragraph kb kc it kd b ke mn kg kh ki mo kk kl km mp ko kp kq mq ks kt ku mr kw kx ky im bi translated">gqlgen是一个模式优先的库，它在编写任何严格的逻辑之前使用<a class="ae lo" href="https://graphql.org/learn/schema/" rel="noopener ugc nofollow" target="_blank"> GraphQL SDL </a>来定义模式。让我们将下面的代码添加到<code class="fe mv mw mx my b">schema.graphqls</code>文件中。</p><pre class="na nb nc nd gt nq my nr ns aw nt bi"><span id="f803" class="ne lq it my b gy nu nv l nw nx">type Pokemon {<br/>  id: ID!<br/>  name: String!<br/>  power: String<br/>  description: String<br/>}<br/><br/>type Battle {<br/>  id: ID!<br/>  pokemon_id: String!<br/>  opponent: String!<br/>  location: String<br/>  date: String<br/>}<br/><br/>input NewPokemon {<br/>  name: String!<br/>  Power: String<br/>  Description: String!<br/>  date:String!<br/>}<br/><br/>input NewBattle {<br/>  pokemon_id: ID!<br/>  opponent: String!<br/>  location: String!<br/>}</span><span id="ea0f" class="ne lq it my b gy ny nv l nw nx">type Query {<br/>  GetPokemon(id:ID!): Pokemon!<br/>  ListPokemon: [Pokemon!]!<br/>  GetBattle(id:ID!): Battle!<br/>  ListBattle:[Battle!]!<br/>}</span><span id="08b1" class="ne lq it my b gy ny nv l nw nx">type Mutation {<br/>  CreatePokemon(input:NewPokemon!): Pokemon!<br/>  DeletePokemon(id:ID!): Pokemon!<br/>  UpdatePokemon(input:NewPokemon!): Pokemon!<br/>  CreateBattle(input:NewBattle!): Battle!<br/>  DeleteBattle(id:ID!): Battle!<br/>  UpdateBattle(id:ID!): Battle!<br/>}</span></pre><h2 id="d45a" class="ne lq it bd lr nf ng dn lv nh ni dp lz km nj nk md kq nl nm mh ku nn no ml np bi translated">类型映射</h2><p id="7566" class="pw-post-body-paragraph kb kc it kd b ke mn kg kh ki mo kk kl km mp ko kp kq mq ks kt ku mr kw kx ky im bi translated">gqlgen通过遍历。您定义的模式。该命令将生成类型或结构<code class="fe mv mw mx my b"><em class="li">gqlgen generate</em></code> <strong class="kd iu"> <em class="li">，其中</em> </strong>将重新生成解析器、处理程序和类型/go结构。</p><figure class="na nb nc nd gt ju gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/8930ded7a86b1b53948541650f81dbfb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1122/format:webp/1*72rxYiYTOPc_Pj3tWMCKQQ.png"/></div><figcaption class="oa ob gj gh gi oc od bd b be z dk translated">gqlgen中的类型映射</figcaption></figure><p id="87f4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">默认情况下，gqlgen会在模型目录下为我们生成一个<code class="fe mv mw mx my b"><em class="li">models_gen.go</em></code>，你可以编辑它或者创建一个新的模型文件，并将其映射到<code class="fe mv mw mx my b"><em class="li">gqlgen.yaml</em></code> <strong class="kd iu"> <em class="li"> </em> </strong>文件中的配置</p><pre class="na nb nc nd gt nq my nr ns aw nt bi"><span id="44d6" class="ne lq it my b gy nu nv l nw nx">models:<br/>  filename: graph/model/models_gen.go<br/>  package: model</span></pre><p id="22f1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">编辑完<strong class="kd iu"><em class="li">schema . graph qls</em></strong>或对<strong class="kd iu"><em class="li">models _ gen . go</em></strong>文件进行更改后，请确保删除<strong class="kd iu"> <em class="li"> resolver.go、</em> </strong>文件，该文件包含使graphql服务器正常工作的解析器。当您运行命令<strong class="kd iu"> <em class="li"> gqlgen generate时，将重新生成该解析器。</em> </strong></p><h2 id="3fe6" class="ne lq it bd lr nf ng dn lv nh ni dp lz km nj nk md kq nl nm mh ku nn no ml np bi translated">03:使用Graphql playground中的解析函数</h2><p id="fa3d" class="pw-post-body-paragraph kb kc it kd b ke mn kg kh ki mo kk kl km mp ko kp kq mq ks kt ku mr kw kx ky im bi translated">在使用解析器函数之前，请先在我们的resolver.go文件中添加结构。</p><pre class="na nb nc nd gt nq my nr ns aw nt bi"><span id="e7ff" class="ne lq it my b gy nu nv l nw nx">type Resolver struct{<br/>   pokemon []*model.Pokemon<br/>   battle []*model.Battle<br/>}</span></pre><p id="0073" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">gqlgen生成一个名为schema.resolvers.go的文件，其中保存了使我们能够与GraphQL服务器通信的应用程序代码。模式解析器文件将如下所示。</p><pre class="na nb nc nd gt nq my nr ns aw nt bi"><span id="d66f" class="ne lq it my b gy nu nv l nw nx">func (r *mutationResolver) CreatePokemon(ctx context.Context, input model.NewPokemon) (*model.Pokemon, error) {<br/>   panic(fmt.Errorf("not implemented"))<br/>}<br/><br/>func (r *mutationResolver) DeletePokemon(ctx context.Context, id string) (*model.Pokemon, error) {<br/>   panic(fmt.Errorf("not implemented"))<br/>}<br/><br/>func (r *mutationResolver) UpdatePokemon(ctx context.Context, input model.NewPokemon) (*model.Pokemon, error) {<br/>   panic(fmt.Errorf("not implemented"))<br/>}</span></pre><p id="856b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">请注意，这些方法没有实现，您现在要做的是实现它们来处理数据。让我们尝试实现一个将数据保存在数组中的方法。</p><pre class="na nb nc nd gt nq my nr ns aw nt bi"><span id="471e" class="ne lq it my b gy nu nv l nw nx">var PokemonData []*model.Pokemon<br/>var BattleData []*model.Battle<br/><br/>func (r *mutationResolver) CreatePokemon(ctx context.Context, input model.NewPokemon) (*model.Pokemon, error) {<br/>   newPokemon := model.Pokemon{<br/>      Name: input.Name,<br/>      Power: input.Power,<br/>      Description: input.Description,<br/>   }<br/>   PokemonData = append(PokemonData, &amp;newPokemon)<br/>   return &amp;newPokemon, nil<br/>}</span><span id="6436" class="ne lq it my b gy ny nv l nw nx">func (r *queryResolver) ListPokemon(ctx context.Context) ([]*model.Pokemon, error) {<br/>   return PokemonData,nill<br/>}</span></pre><p id="437b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们通过graphql操场来使用这个解析器函数。现在，让我们从终端执行go server.go来启动我们的服务器，并在浏览器上打开http//:localhost:8080。</p><figure class="na nb nc nd gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi oe"><img src="../Images/d1fd0170c36fafac64b721d87110f135.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HSQiJwCfMRyhW5h7XwmZ8Q.png"/></div></div></figure><p id="e873" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这样，您就可以扩展将这些数据保存到数据库中的功能，使其成为一个完整的包。您可以使用一些优秀的工具，如<a class="ae lo" href="https://sqlc.dev/" rel="noopener ugc nofollow" target="_blank"> sqlc </a>来生成与数据库相关的函数，如gqlgen，这让开发人员的工作变得更加轻松。</p><h1 id="936c" class="lp lq it bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">结论</h1><p id="222d" class="pw-post-body-paragraph kb kc it kd b ke mn kg kh ki mo kk kl km mp ko kp kq mq ks kt ku mr kw kx ky im bi translated">总之，gqlgen是构建go GraphQL服务器的最佳库之一。像<strong class="kd iu">类型安全</strong>、<strong class="kd iu">代码生成</strong>这样的特性使得开发人员更容易使用Graphql。gqlgen还支持插件来扩展Graphql应用程序的特性。要了解更多信息，请务必通读gqlgen 的<a class="ae lo" href="https://gqlgen.com/" rel="noopener ugc nofollow" target="_blank">文档。最后，感谢您花时间阅读本文。我想看看你下面的问题和评论。</a></p><p id="4c22" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">干杯！</p><h1 id="2c0b" class="lp lq it bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">了解更多信息</h1><div class="of og gp gr oh oi"><a rel="noopener  ugc nofollow" target="_blank" href="/urql-the-highly-customizable-and-versatile-graphql-client-69e4e3406904"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd iu gy z fp on fr fs oo fu fw is bi translated">高度可定制和多功能的GraphQL客户端</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">在过去的十年里，REST架构已经成为web应用程序的行业标准，因为REST提供了一个…</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="or l"><div class="os l ot ou ov or ow jz oi"/></div></div></a></div><div class="of og gp gr oh oi"><a rel="noopener  ugc nofollow" target="_blank" href="/jotai-atom-based-state-management-for-react-1ce8fd380296"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd iu gy z fp on fr fs oo fu fw is bi translated">jotai:React的基于原子的状态管理</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">在过去的几年里，国家管理有了很大的发展。有很多库和方法可以让你…</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="or l"><div class="ox l ot ou ov or ow jz oi"/></div></div></a></div><div class="of og gp gr oh oi"><a rel="noopener  ugc nofollow" target="_blank" href="/build-your-own-self-hosted-ci-cd-workflow-with-github-actions-ec9ee1dcd800"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd iu gy z fp on fr fs oo fu fw is bi translated">使用GitHub操作构建您自己的自托管CI/CD工作流</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">GitHub引入了GitHub Actions，使开发人员能够直接从他们的GitHub库自动化工作流…</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="or l"><div class="oy l ot ou ov or ow jz oi"/></div></div></a></div><div class="of og gp gr oh oi"><a rel="noopener  ugc nofollow" target="_blank" href="/hookstate-the-simplest-state-management-tool-b02f7d3b01a4"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd iu gy z fp on fr fs oo fu fw is bi translated">最简单的状态管理工具</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">小型、最小、简洁、可扩展、基于钩子的状态管理库</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="or l"><div class="oz l ot ou ov or ow jz oi"/></div></div></a></div></div></div>    
</body>
</html>