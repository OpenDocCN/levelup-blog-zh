<html>
<head>
<title>Building a game with TypeScript. Game Loop 2/2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用TypeScript构建游戏。游戏循环2/2</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/gamedev-patterns-and-algorithms-in-action-with-typescript-game-loop-2-2-c0d57a8e5ec2?source=collection_archive---------0-----------------------#2020-08-01">https://levelup.gitconnected.com/gamedev-patterns-and-algorithms-in-action-with-typescript-game-loop-2-2-c0d57a8e5ec2?source=collection_archive---------0-----------------------#2020-08-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="67e2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">教程<a class="ae kl" href="https://medium.com/@gregsolo/gamedev-patterns-and-algorithms-in-action-with-typescript-d29b913858e" rel="noopener">系列</a>中的第二章讲述了如何用TypeScript和本地浏览器API从头开始构建游戏</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/52a95bf16126c4eb9796926bd75f374e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-s7P0yUfTys4g4zujsOSKg.jpeg"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated"><a class="ae kl" href="https://www.freepik.com/vectors/logo" rel="noopener ugc nofollow" target="_blank">free pik创建的Logo矢量</a></figcaption></figure><p id="d188" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">欢迎回来！这是我们讨论如何用TypeScript和本地浏览器API构建一个简单的回合制游戏的系列文章！第二章致力于为这个游戏建立一个游戏循环，其他章节可以在这里找到:</p><ul class=""><li id="e85b" class="lc ld iq jp b jq jr ju jv jy le kc lf kg lg kk lh li lj lk bi translated"><a class="ae kl" href="https://medium.com/@gregsolo/gamedev-patterns-and-algorithms-in-action-with-typescript-d29b913858e" rel="noopener">简介</a></li><li id="5b42" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated"><a class="ae kl" href="https://medium.com/@gregsolo/entity-component-system-in-action-with-typescript-f498ca82a08e" rel="noopener">第一章实体组件系统</a></li><li id="e4a7" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">第二章。游戏循环(<a class="ae kl" href="https://medium.com/@gregsolo/gamedev-patterns-and-algorithms-with-typescript-game-loop-part-1-2-699919bb9b71" rel="noopener">第一部分</a>，第二部分)</li><li id="bd05" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">第三章。绘制网格(<a class="ae kl" href="https://medium.com/@gregsolo/building-a-game-with-typescript-drawing-grid-1-5-aaf68797a0bb" rel="noopener">第1部分</a>、<a class="ae kl" href="https://medium.com/javascript-in-plain-english/building-a-game-with-typescript-drawing-grid-2-5-206555719490" rel="noopener">第2部分</a>、<a class="ae kl" href="https://medium.com/@gregsolo/building-a-game-with-typescript-drawing-grid-3-5-1fb94211c4aa" rel="noopener">第3部分</a>、<a class="ae kl" href="https://medium.com/@gregsolo/building-a-game-with-typescript-iii-drawing-grid-4-5-398af1dd638d" rel="noopener">第4部分</a>、<a class="ae kl" href="https://medium.com/@gregsolo/building-a-game-with-typescript-drawing-grid-5-5-49454917b3af" rel="noopener">第5部分</a>)</li><li id="4e65" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">第四章。舰船(<a class="ae kl" href="https://medium.com/@gregsolo/building-a-game-with-typescript-colors-and-layers-337b0e4d71f" rel="noopener">第一部分</a>、<a class="ae kl" href="https://medium.com/@gregsolo/building-a-game-with-typescript-team-and-fleet-f223d39e9248" rel="noopener">第二部分</a>、<a class="ae kl" href="https://medium.com/@gregsolo/building-a-game-with-typescript-drawing-ship-14e6c19caa38" rel="noopener">第三部分</a>、<a class="ae kl" href="https://gregsolo.medium.com/building-a-game-with-typescript-ship-and-locomotion-4f5969675993" rel="noopener">第四部分</a>)</li><li id="023d" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">第五章输入系统(<a class="ae kl" href="https://gregsolo.medium.com/building-a-game-with-typescript-input-system-1-3-46d0b3dd7662" rel="noopener">第一部分</a>、<a class="ae kl" href="https://gregsolo.medium.com/building-a-game-with-typescript-input-system-2-3-cd419e36027c" rel="noopener">第二部分</a>、<a class="ae kl" href="https://gregsolo.medium.com/building-a-game-with-typescript-input-system-3-3-8492552579f1" rel="noopener">第三部分</a>)</li><li id="39cc" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">第六章。寻路和移动(<a class="ae kl" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-17-introduction" rel="noopener ugc nofollow" target="_blank">第一部分</a>、<a class="ae kl" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-27-highlighting-locomotion-range" rel="noopener ugc nofollow" target="_blank">第二部分</a>、<a class="ae kl" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-37-graph-and-priority-queue" rel="noopener ugc nofollow" target="_blank">第三部分</a>、<a class="ae kl" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-47-pathfinder" rel="noopener ugc nofollow" target="_blank">第四部分</a>、<a class="ae kl" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-57-finding-the-path" rel="noopener ugc nofollow" target="_blank">第五部分</a>、<a class="ae kl" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-6-instant-locomotion" rel="noopener ugc nofollow" target="_blank">第六部分</a>、<a class="ae kl" href="https://blog.gregsolo.me/articles/pathfinding-and-movement-7-animated-locomotion" rel="noopener ugc nofollow" target="_blank">第七部分</a>)</li><li id="dd68" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">第七章。玛奇纳州</li><li id="0682" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">第八章。攻击系统:生命和伤害</li><li id="6aa5" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">第九章。比赛的输赢</li><li id="c1f2" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">第十章敌人AI</li></ul><p id="fa71" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://medium.com/@gregsolo/gamedev-patterns-and-algorithms-with-typescript-game-loop-part-1-2-699919bb9b71" rel="noopener">上次</a>我们以这样一个问题结束:我们如何在不使构造函数过于复杂的情况下开始游戏循环。我们可以采取的方法之一是让它“可唤醒”。</p><blockquote class="lq lr ls"><p id="1c49" class="jn jo lt jp b jq jr js jt ju jv jw jx lu jz ka kb lv kd ke kf lw kh ki kj kk ij bi translated">F <!-- -->鳗鱼可以自由切换到<a class="ae kl" href="https://github.com/soloschenko-grigoriy/gamedev-patterns-ts" rel="noopener ugc nofollow" target="_blank">仓库</a>的<code class="fe lx ly lz ma b">game-loop-1</code>分支。它包含了前几篇文章的工作成果，是这篇文章的一个很好的起点。</p></blockquote></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><h1 id="7d9b" class="mi mj iq bd mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf bi translated">目录</h1><ol class=""><li id="26ab" class="lc ld iq jp b jq ng ju nh jy ni kc nj kg nk kk nl li lj lk bi translated">到…里面</li><li id="b8dd" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk nl li lj lk bi translated">实体觉醒</li><li id="723f" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk nl li lj lk bi translated">开始循环</li><li id="c2f5" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk nl li lj lk bi translated">嵌套实体</li><li id="7dbe" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk nl li lj lk bi translated">测试游戏实体</li><li id="f385" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk nl li lj lk bi translated">结论</li></ol></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><h1 id="c69d" class="mi mj iq bd mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf bi translated">到…里面</h1><p id="29f6" class="pw-post-body-paragraph jn jo iq jp b jq ng js jt ju nh jw jx jy nm ka kb kc nn ke kf kg no ki kj kk ij bi translated">如果您还记得，我们在建立<code class="fe lx ly lz ma b">game</code>实体方面取得了重大进展。我们甚至准备了它的<code class="fe lx ly lz ma b">Update</code>方法，递归地更新<code class="fe lx ly lz ma b">Game</code>的所有组件。然而，这并没有太大的帮助，因为没有人进行初始调用来启动循环！</p><p id="7c9a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还建立了在构造函数的帮助下开始循环的可能性:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="e247" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">更好的方法是提供一个专用的初始化方法。该方法可以启动循环并进行许多其他设置，同时构造函数保持精简。我们可以随便叫这个方法，比如<code class="fe lx ly lz ma b">Init</code>或者<code class="fe lx ly lz ma b">Awake</code>。我将使用最新的来模仿<code class="fe lx ly lz ma b">Unity3d</code> API。</p><h1 id="de72" class="mi mj iq bd mk ml nr mn mo mp ns mr ms mt nt mv mw mx nu mz na nb nv nd ne nf bi translated">实体觉醒</h1><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nw"><img src="../Images/8ddc2079199aeda2d9e030adaf0f9c56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nttWbWIndwTi0On9X8UQNQ.jpeg"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated"><a class="ae kl" href="https://www.freepik.com/free-photos-vectors/background" rel="noopener ugc nofollow" target="_blank">free pik创建的背景矢量</a></figcaption></figure><p id="c3a3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所有实体和组件现在都将变成“<em class="lt">可唤醒</em>”。那就是:他们会有public <code class="fe lx ly lz ma b">Awake</code>方法。</p><blockquote class="lq lr ls"><p id="013a" class="jn jo lt jp b jq jr js jt ju jv jw jx lu jz ka kb lv kd ke kf lw kh ki kj kk ij bi translated">注意，这个生命周期方法与构造函数没有很强的关系。一个对象只能被构造一次，而它的<code class="fe lx ly lz ma b">Awake</code>在一个对象的生命周期内可能会被执行多次。它可以“睡着”，然后再次被唤醒。一个典型的例子是重用对象，以避免实例化对象的内存分配成本(<em class="iq">读作:执行构造函数</em>)。</p></blockquote><p id="daaf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">很容易简单地添加一个新方法来抽象<code class="fe lx ly lz ma b">Entity</code>和接口<code class="fe lx ly lz ma b">IComponent</code>。但正如<code class="fe lx ly lz ma b">Update</code>，<code class="fe lx ly lz ma b">Awake</code>可以是我们游戏其他元素的一部分，而不仅仅是ECS。更明智的做法是创建一个专用的<code class="fe lx ly lz ma b">IAwake</code>接口，然后实现它。</p><p id="e2b9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">界面简单得惊人。我们甚至不期望传递任何特定的数据:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="c4a4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">剩下的就是用<code class="fe lx ly lz ma b">IComponent</code>来实现它了:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="0bf4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">和<code class="fe lx ly lz ma b">Entity</code>:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="np nq l"/></div></figure><blockquote class="lq lr ls"><p id="a660" class="jn jo lt jp b jq jr js jt ju jv jw jx lu jz ka kb lv kd ke kf lw kh ki kj kk ij bi translated">请注意，该实体一旦唤醒自己，就会唤醒其所有组件。这是正确的，因为一个<code class="fe lx ly lz ma b">Update,</code>是一个<strong class="jp ir">默认的</strong>行为。必要时，特定实体可以自由扩展或更改它。</p></blockquote><p id="e36e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">还有，既然我们反正在这附近，就做点家务吧。我将在一个实用模块下加入Awake和Update，并称之为“生命周期”。如果我们需要更多这样的事件，我们可以在此添加:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="1bce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们可以删除过时的<code class="fe lx ly lz ma b">update.h.ts</code>和<code class="fe lx ly lz ma b">awake.h.ts</code>。此外，支持必要的桶文件，以正确地重新导出此模块:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="b618" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后更新这些接口的使用者:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="14fc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">啊！但是我们破坏了测试！那是因为我们没有履行承诺:“每个实体和组件都应该有<code class="fe lx ly lz ma b">Awake</code>方法”。而模仿者显然没有这种能力。让我们快速解决这个问题:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="0d69" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们绝对应该测试<code class="fe lx ly lz ma b">Awake</code>。我将使用我们在测试<code class="fe lx ly lz ma b">Update</code>时使用的相同方法:我首先监视各自的方法，将假组件添加到假实体，执行实体的Awake方法，并期望组件的方法也被调用:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="933f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您在此时运行<code class="fe lx ly lz ma b">npm start</code>，您的代码应该编译无误。如果您在<code class="fe lx ly lz ma b">npm t</code>之前运行测试，它们也应该会成功:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/8900c1a9eba9b0e7c7138d7fa63af3e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*sDGjWQ4inB62TVXYiIN6Eg.png"/></div></figure></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><h1 id="0a6e" class="mi mj iq bd mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf bi translated">开始循环</h1><p id="98d9" class="pw-post-body-paragraph jn jo iq jp b jq ng js jt ju nh jw jx jy nm ka kb kc nn ke kf kg no ki kj kk ij bi translated">有了这些，我们可以在游戏实体中利用新的生命周期方法:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="062f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">游戏及其所有组件一醒来，我们就开始游戏循环:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="42eb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个小小的改进:我想确保游戏循环不会在所有组件和子实体被唤醒之前开始。为此，我将更新延迟到下一帧:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="np nq l"/></div></figure><h1 id="d327" class="mi mj iq bd mk ml nr mn mo mp ns mr ms mt nt mv mw mx nu mz na nb nv nd ne nf bi translated">嵌套实体</h1><p id="4637" class="pw-post-body-paragraph jn jo iq jp b jq ng js jt ju nh jw jx jy nm ka kb kc nn ke kf kg no ki kj kk ij bi translated">我说的是"<strong class="jp ir">子实体</strong>吗？"。没错:游戏是根实体但不是唯一。这是一种非常保守的方式，让实体组织在层级中。其中，这允许我们在游戏中通过调用每个孩子的<code class="fe lx ly lz ma b">Update</code>来更新所有这些孩子。</p><p id="30e6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将在下一章开始添加子实体，但是现在，让我们只设置一个阶段，并确保它们将被更新。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi ny"><img src="../Images/981a940fb25497910b7c4ef16d96c07e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kKh8zrSqHtJWFymK_xnXyA.jpeg"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated"><a class="ae kl" href="https://www.freepik.com/free-photos-vectors/character" rel="noopener ugc nofollow" target="_blank">由brgfx创建的字符向量</a></figcaption></figure><p id="1afe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我添加了一个保存所有子实体数组的公共属性:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="77d0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过跟踪所有的子实体，我们可以轻松地调用它们的所有生命周期方法。而且，他们中的一些人(甚至全部！)可能有他们的孩子，并且也呼叫唤醒/更新他们。</p><p id="6988" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们应该唤醒所有孩子，并在开始循环之前这样做:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="3b92" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后在每次迭代中更新它们:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="795e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们终于有了一个全功能的游戏循环，它迭代每一帧并更新所有实体和所有组件。</p><p id="4e75" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后一点:让我们通过实例化和唤醒游戏本身来启动这个引擎:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="2fee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">厉害！如果您通过执行<code class="fe lx ly lz ma b">npm start</code>来运行您的代码，它应该可以顺利编译。</p><h1 id="aea1" class="mi mj iq bd mk ml nr mn mo mp ns mr ms mt nt mv mw mx nu mz na nb nv nd ne nf bi translated">测试游戏实体</h1><p id="70c5" class="pw-post-body-paragraph jn jo iq jp b jq ng js jt ju nh jw jx jy nm ka kb kc nn ke kf kg no ki kj kk ij bi translated">我们仍然没有视觉效果来证明我们的探索成功了，所以单元测试是唯一的希望。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/6f7ca236954bd46a67bd6b475299006b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uTv71g6fBuIspzrGrYsmJw.jpeg"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated"><a class="ae kl" href="https://www.freepik.com/free-photos-vectors/man" rel="noopener ugc nofollow" target="_blank">free pik创建的Man向量</a></figcaption></figure><p id="0493" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">幸运的是，此时测试游戏实体很简单。我们要测试五样东西:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="7ed9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为此，我们需要做一些准备。首先，让我们设置假的子组件和组件:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="0f7e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我创建并实例化了组件，正如我在前一章中对实体测试所做的那样。我还创建了空实体，实例化它们，并附加到游戏中。</p><p id="e05d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们在游戏中使用requestAnimationFrame。这是一个异步回调，我们必须适当地模拟它。一种方法是用<code class="fe lx ly lz ma b">jest.fn</code>替换它，并确保它立即调用回调:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="383a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这将允许我测试更新循环是否正常工作:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="76cc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这里，我只是监视<code class="fe lx ly lz ma b">game.Update</code>，唤醒游戏，并期待<code class="fe lx ly lz ma b">game.Update</code>真的被执行。</p><p id="afb5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">测试其他四个场景与我们在上一章中测试实体非常相似:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="np nq l"/></div></figure><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="np nq l"/></div></figure><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="np nq l"/></div></figure><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="0686" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我首先监视每个子/组件的<code class="fe lx ly lz ma b">Awake</code>或<code class="fe lx ly lz ma b">Update</code>，并期望它们分别在<code class="fe lx ly lz ma b">game.Awake</code>或<code class="fe lx ly lz ma b">game.Update</code>之后被调用。</p><blockquote class="lq lr ls"><p id="b700" class="jn jo lt jp b jq jr js jt ju jv jw jx lu jz ka kb lv kd ke kf lw kh ki kj kk ij bi translated">为什么我们要测试组件的唤醒/更新？我们已经在一个抽象实体上测试了同样的东西。为什么复读？</p><p id="15da" class="jn jo lt jp b jq jr js jt ju jv jw jx lu jz ka kb lv kd ke kf lw kh ki kj kk ij bi translated">原因是我们可以在游戏的唤醒/更新中覆盖这个功能。记住，抽象实体只提供默认行为，如果我们覆盖了这个方法(正如我们所做的)，那么我们应该确保我们没有丢失任何东西。</p></blockquote><p id="4315" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您使用<code class="fe lx ly lz ma b">npm t</code>运行测试，它们应该都会成功:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/8819da0fc4d08b60cfe07adedcd27bb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1154/format:webp/1*kA3oGgaF8xbnMhJFMbx-Xw.png"/></div></figure><blockquote class="lq lr ls"><p id="1b15" class="jn jo lt jp b jq jr js jt ju jv jw jx lu jz ka kb lv kd ke kf lw kh ki kj kk ij bi translated">Y <!-- -->你可以在<a class="ae kl" href="https://github.com/soloschenko-grigoriy/gamedev-patterns-ts" rel="noopener ugc nofollow" target="_blank">库</a>的<code class="fe lx ly lz ma b"><em class="iq">game-loop-2</em></code>分支中找到这篇文章的完整源代码。</p></blockquote></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><h1 id="7f89" class="mi mj iq bd mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf bi translated">结论</h1><p id="7b1f" class="pw-post-body-paragraph jn jo iq jp b jq ng js jt ju nh jw jx jy nm ka kb kc nn ke kf kg no ki kj kk ij bi translated">你应该为自己感到骄傲，你已经完成了很多<strong class="jp ir"/>:学习了游戏循环以及它如何在一个团队中使用实体和组件，如何在每一帧执行代码，发现了实体的生命周期方法以及如何在游戏循环中使用它们，当然，还构建了核心游戏实体并覆盖了测试！惊人的进步！</p><p id="0325" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://medium.com/@gregsolo/building-a-game-with-typescript-drawing-grid-1-5-aaf68797a0bb" rel="noopener">下一次</a>我们将最终在屏幕上绘制一些东西，并看到组件在运行中的美丽。</p><p id="e378" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您有任何意见、建议、问题或任何其他反馈，请不要犹豫，给我发私信或在下面留下评论！感谢您的阅读，我们下次再见！</p></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><p id="7883" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="lt">这是系列教程“</em> <strong class="jp ir"> <em class="lt">用打字稿</em> </strong> <em class="lt">构建游戏”中的第二章。其他章节可点击此处:</em></p><ul class=""><li id="3441" class="lc ld iq jp b jq jr ju jv jy le kc lf kg lg kk lh li lj lk bi translated"><a class="ae kl" href="https://medium.com/@gregsolo/gamedev-patterns-and-algorithms-in-action-with-typescript-d29b913858e" rel="noopener">简介</a></li><li id="7ae1" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated"><a class="ae kl" href="https://medium.com/@gregsolo/entity-component-system-in-action-with-typescript-f498ca82a08e" rel="noopener">第一章实体组件系统</a></li><li id="2b23" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">第二章。游戏循环(<a class="ae kl" href="https://medium.com/@gregsolo/gamedev-patterns-and-algorithms-with-typescript-game-loop-part-1-2-699919bb9b71" rel="noopener">第一部分</a>，第二部分)</li><li id="4ac9" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">第三章。绘制网格(<a class="ae kl" href="https://medium.com/@gregsolo/building-a-game-with-typescript-drawing-grid-1-5-aaf68797a0bb" rel="noopener">第一部分</a>、<a class="ae kl" href="https://medium.com/javascript-in-plain-english/building-a-game-with-typescript-drawing-grid-2-5-206555719490" rel="noopener">第二部分</a>、<a class="ae kl" href="https://medium.com/@gregsolo/building-a-game-with-typescript-drawing-grid-3-5-1fb94211c4aa" rel="noopener">第三部分</a>、<a class="ae kl" href="https://medium.com/@gregsolo/building-a-game-with-typescript-iii-drawing-grid-4-5-398af1dd638d" rel="noopener">第四部分</a>、<a class="ae kl" href="https://medium.com/@gregsolo/building-a-game-with-typescript-drawing-grid-5-5-49454917b3af" rel="noopener">第五部分</a>)</li><li id="563c" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">第四章。船舶(<a class="ae kl" href="https://medium.com/@gregsolo/building-a-game-with-typescript-colors-and-layers-337b0e4d71f" rel="noopener">第一部分</a>、<a class="ae kl" href="https://medium.com/@gregsolo/building-a-game-with-typescript-team-and-fleet-f223d39e9248" rel="noopener">第二部分</a>、<a class="ae kl" href="https://medium.com/@gregsolo/building-a-game-with-typescript-drawing-ship-14e6c19caa38" rel="noopener">第三部分</a>、<a class="ae kl" href="https://gregsolo.medium.com/building-a-game-with-typescript-ship-and-locomotion-4f5969675993" rel="noopener">第四部分</a>)</li><li id="c356" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">第五章输入系统(<a class="ae kl" href="https://gregsolo.medium.com/building-a-game-with-typescript-input-system-1-3-46d0b3dd7662" rel="noopener">第一部分</a>、<a class="ae kl" href="https://gregsolo.medium.com/building-a-game-with-typescript-input-system-2-3-cd419e36027c" rel="noopener">第二部分</a>、<a class="ae kl" href="https://gregsolo.medium.com/building-a-game-with-typescript-input-system-3-3-8492552579f1" rel="noopener">第三部分</a>)</li><li id="5e8c" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">第六章。寻路与移动(<a class="ae kl" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-17-introduction" rel="noopener ugc nofollow" target="_blank">第一部分</a>、<a class="ae kl" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-27-highlighting-locomotion-range" rel="noopener ugc nofollow" target="_blank">第二部分</a>、<a class="ae kl" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-37-graph-and-priority-queue" rel="noopener ugc nofollow" target="_blank">第三部分</a>、<a class="ae kl" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-47-pathfinder" rel="noopener ugc nofollow" target="_blank">第四部分</a>、<a class="ae kl" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-57-finding-the-path" rel="noopener ugc nofollow" target="_blank">第五部分</a>、<a class="ae kl" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-6-instant-locomotion" rel="noopener ugc nofollow" target="_blank">第六部分</a>、<a class="ae kl" href="https://blog.gregsolo.me/articles/pathfinding-and-movement-7-animated-locomotion" rel="noopener ugc nofollow" target="_blank">第七部分</a>)</li><li id="4d11" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">第七章。玛奇纳州</li><li id="825d" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">第八章。攻击系统:生命和伤害</li><li id="411e" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">第九章。比赛的输赢</li><li id="fe27" class="lc ld iq jp b jq ll ju lm jy ln kc lo kg lp kk lh li lj lk bi translated">第十章敌人AI</li></ul></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><h1 id="e28c" class="mi mj iq bd mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf bi translated">分级编码</h1><p id="01d3" class="pw-post-body-paragraph jn jo iq jp b jq ng js jt ju nh jw jx jy nm ka kb kc nn ke kf kg no ki kj kk ij bi translated">感谢您成为我们社区的一员！<a class="ae kl" href="https://www.youtube.com/channel/UC3v9kBR_ab4UHXXdknz8Fbg?sub_confirmation=1" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">订阅我们的YouTube频道</strong> </a>或者加入<a class="ae kl" href="https://skilled.dev/" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> Skilled.dev编码面试课程</strong> </a>。</p><div class="oa ob gp gr oc od"><a href="https://skilled.dev" rel="noopener  ugc nofollow" target="_blank"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd ir gy z fp oi fr fs oj fu fw ip bi translated">编写面试问题</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">掌握编码面试的过程</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">技术开发</p></div></div><div class="om l"><div class="on l oo op oq om or kw od"/></div></div></a></div></div></div>    
</body>
</html>