<html>
<head>
<title>API Authentication with Laravel + JWT</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Laravel + JWT进行API认证</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/api-authentication-with-laravel-jwt-7ee110649972?source=collection_archive---------2-----------------------#2022-04-06">https://levelup.gitconnected.com/api-authentication-with-laravel-jwt-7ee110649972?source=collection_archive---------2-----------------------#2022-04-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/43f45e617e20be182e40079e15e3bcda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*en4in23Ho3YQPavFBORLKw.jpeg"/></div></figure><h1 id="407e" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">介绍</h1><p id="e48a" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">认证是互联网上大多数服务的基本特征。我们希望能够限制谁可以访问什么，并尽可能以最方便、最安全的方式做到这一点。本文试图介绍使用Laravel PHP框架和JWT的API服务中的认证。本文假设您有一些用PHP编写面向对象代码的经验。</p><h2 id="f334" class="lq jv iq bd jw lr ls dn ka lt lu dp ke ld lv lw ki lh lx ly km ll lz ma kq mb bi translated">API认证？</h2><p id="8f88" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">是的，我们将使用Web服务API认证我们的用户，特别是RESTful API服务。本文假设我们希望将前端和后端服务分开，在本教程系列中，我们将构建一个客户端来与我们正在构建的API进行交互。如果我们没有使用REST API，我们将不得不使用会话来认证用户。这样，服务器为用户创建一个新的会话文件，并赋予它一个惟一的标识符，该标识符被发送给用户并作为cookie保存在用户处。这通常被称为有状态系统。</p><p id="85e5" class="pw-post-body-paragraph ks kt iq ku b kv mc kx ky kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp ij bi translated">对于我们的API服务(它是无状态的)，我们将使用令牌，令牌通常由服务器发出，并在每个请求期间由客户端携带。在这个系统中，没有用户活动的记忆——每个请求都被认为是第一个。<br/>对于这个应用程序，我们将使用jwt(JSON Web令牌)作为我们的令牌，由服务器进行发布和验证。JWT只携带编码的JSON数据，通常在API服务中用作授权令牌。(阅读更多关于jwt的内容—【https://auth0.com/docs/secure/tokens/json-web-tokens T2】)</p><h2 id="e1a9" class="lq jv iq bd jw lr ls dn ka lt lu dp ke ld lv lw ki lh lx ly km ll lz ma kq mb bi translated">JWTs vs圣所</h2><p id="8c68" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">如果您以前在Laravel中使用过API，那么您一定会发现Sanctum或Passport是对您的服务上的用户进行身份验证的有效方法。那为什么是JWTs呢？</p><p id="2df4" class="pw-post-body-paragraph ks kt iq ku b kv mc kx ky kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp ij bi translated">在遇到jwt之前，我在Sanctum工作了一段时间。我注意到的一件事是令牌存储在数据库中。因此，对于每个请求，都会执行一个数据库查询来验证令牌，然后执行另一个查询来获取用户信息。处理每个请求所增加的开销是巨大的。此外，除了作为查询数据库的随机生成的字符串之外，您很少或根本没有使用令牌。那会占用空间，但对你没什么用。在另一个实例中，如果您多次登录，您的数据库中会添加几个令牌，其中大部分是无用的，等待被删除。可以写一篇单独的文章来讨论这些限制以及它们如何影响您的生产。</p><p id="b1e3" class="pw-post-body-paragraph ks kt iq ku b kv mc kx ky kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp ij bi translated">相比之下，JWT令牌是独立的，主要由客户端负责。您的服务器只是生成一个令牌并发送给客户端，而不关心令牌会发生什么。这意味着您可以多次登录，这不会以任何方式影响服务器端。此外，您还可以操作令牌上的数据。您可以将用户信息存储在令牌中，从而不再需要额外的数据库查询。从某种意义上说，这是我们应用程序上下文中访问令牌的原始概念。</p><h1 id="1289" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">设置和配置</h1><p id="329d" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">首先，我们需要安装一个新的Laravel应用程序。在本教程中，我们将使用Laravel 8，以便每个人都能跟上，但请记住,<a class="ae mh" href="https://laravel.com/docs/9.x/releases" rel="noopener ugc nofollow" target="_blank"> Laravel 9 </a>是可用的，可以用于本教程。<br/>要安装Laravel 8，请使用以下命令:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="502c" class="lq jv iq mn b gy mr ms l mt mu">composer create-project laravel/laravel:^8.0 jwt-laravel</span><span id="cf14" class="lq jv iq mn b gy mv ms l mt mu">cd jwt-laravel</span></pre><p id="a3db" class="pw-post-body-paragraph ks kt iq ku b kv mc kx ky kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp ij bi translated">接下来，我们安装tymon/jwt-auth包:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="3134" class="lq jv iq mn b gy mr ms l mt mu">composer require tymon/jwt-auth:*</span></pre><p id="1855" class="pw-post-body-paragraph ks kt iq ku b kv mc kx ky kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp ij bi translated">我们使用*通配符是因为一些现有的包可能与jwt-auth的最新版本冲突，我们希望安装我们至少可以获得的版本。<br/> <br/>接下来，在config/app.php文件的providers数组中，在数组末尾添加JWT提供者:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="2d6f" class="lq jv iq mn b gy mr ms l mt mu">// […other providers],<br/>Tymon\JWTAuth\Providers\LaravelServiceProvider::class,</span></pre><p id="2c42" class="pw-post-body-paragraph ks kt iq ku b kv mc kx ky kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp ij bi translated">在同一文件中别名数组的末尾，添加以下值:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="486c" class="lq jv iq mn b gy mr ms l mt mu">‘JWTAuth’ =&gt; Tymon\JWTAuth\Facades\JWTAuth::class, <br/>‘JWTFactory’ =&gt; Tymon\JWTAuth\Facades\JWTFactory::class,</span></pre><p id="8d36" class="pw-post-body-paragraph ks kt iq ku b kv mc kx ky kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp ij bi translated">这个项目的GitHub资源库可以在:<a class="ae mh" href="https://github.com/joshuaetim/jwt-laravel-article" rel="noopener ugc nofollow" target="_blank">https://github.com/joshuaetim/jwt-laravel-article</a>看到</p><p id="aa42" class="pw-post-body-paragraph ks kt iq ku b kv mc kx ky kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp ij bi translated">运行以下命令发布配置文件:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="1dae" class="lq jv iq mn b gy mr ms l mt mu">php artisan vendor:publish –provider=”Tymon\JWTAuth\Providers\LaravelServiceProvider”</span></pre><p id="237e" class="pw-post-body-paragraph ks kt iq ku b kv mc kx ky kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp ij bi translated">生成密钥的命令:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="581d" class="lq jv iq mn b gy mr ms l mt mu">php artisan jwt:secret</span></pre><h1 id="938e" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">编辑您的模型</h1><p id="025a" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">在您的模型可以使用JWT进行身份验证之前，您需要为此进行设置。对于我们的用户模型，这意味着从我们刚刚安装的包中实现JWTSubject接口。要在PHP中成功实现一个接口，我们必须实现接口中定义的函数。</p><p id="1e6b" class="pw-post-body-paragraph ks kt iq ku b kv mc kx ky kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp ij bi translated">下面是我们的用户模型的样子:</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="68d5" class="pw-post-body-paragraph ks kt iq ku b kv mc kx ky kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp ij bi translated">接下来，使用以下命令设置数据库并运行迁移:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="31d1" class="lq jv iq mn b gy mr ms l mt mu">php artisan migrate</span></pre><h1 id="60eb" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">定义路线</h1><p id="f5ba" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">我们的routes表示URL到处理函数的映射。对于这一步，我们将拥有处理欢迎页面、注册、登录、仪表板和获取用户的路由。<br/>下面是out routes/api.php的样子:</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="bca7" class="pw-post-body-paragraph ks kt iq ku b kv mc kx ky kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp ij bi translated">仪表板路由受到'<em class="my"> jwt.verify </em>'中间件的保护，我们稍后将创建该中间件。</p><h1 id="3318" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">定义控制器</h1><p id="c42b" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">我们创建一个名为<em class="my"> AuthController </em>的新控制器来处理我们的认证需求:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="4e40" class="lq jv iq mn b gy mr ms l mt mu">php artisan make:controller AuthController</span></pre><p id="e240" class="pw-post-body-paragraph ks kt iq ku b kv mc kx ky kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp ij bi translated">AuthController的内容如下所示:</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="6f86" class="pw-post-body-paragraph ks kt iq ku b kv mc kx ky kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp ij bi translated">在该文件中，我们创建了一些函数来格式化我们的成功和错误响应，以减少重复。然后，我们设置注册、登录和获取当前用户的方法。</p><h1 id="bb60" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">定义中间件</h1><p id="7fbd" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">我们将使用一个中间件来保护某些路由，比如前面定义的仪表板路由，在处理请求之前将调用中间件。</p><p id="c9a5" class="pw-post-body-paragraph ks kt iq ku b kv mc kx ky kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp ij bi translated">要创建中间件，请运行以下命令:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="369f" class="lq jv iq mn b gy mr ms l mt mu">php artisan make:middleware JWTMiddleware</span></pre><p id="8c37" class="pw-post-body-paragraph ks kt iq ku b kv mc kx ky kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp ij bi translated">JWTMiddleware的内容如下所示。它基本上试图从请求头中获取当前经过身份验证的用户。如果找不到用户或令牌有问题，将返回错误响应。</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="53b0" class="pw-post-body-paragraph ks kt iq ku b kv mc kx ky kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp ij bi translated">要注册这个中间件，请转到<em class="my"> App/Http/Kernel.php </em>并在<strong class="ku ir"> $routeMiddleware </strong>数组的末尾添加这个值:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="6ffc" class="lq jv iq mn b gy mr ms l mt mu"> ‘jwt.verify’ =&gt; \App\Http\Middleware\JWTMiddleware::class,</span></pre><p id="661e" class="pw-post-body-paragraph ks kt iq ku b kv mc kx ky kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp ij bi translated">如果你注意到了，我们从未接触过由<a class="ae mh" href="https://laravel.com/docs/8.x/authentication" rel="noopener ugc nofollow" target="_blank"> Laravel </a>提供的原始auth()服务或中间件。这对我们来说很方便，因为我们可能需要扩展或实现主认证服务。如果您想使用主auth()服务，只需在<em class="my"> config/auth.php </em>中将api guard提供者更改为‘jwt’。更多信息可以在这里找到:<a class="ae mh" href="https://jwt-auth.readthedocs.io/en/develop/quick-start/" rel="noopener ugc nofollow" target="_blank">https://jwt-auth.readthedocs.io/en/develop/quick-start/</a></p><h1 id="90c9" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">即将推出</h1><p id="572d" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">在下一部分，我们将</p><ul class=""><li id="ee3f" class="mz na iq ku b kv mc kz md ld nb lh nc ll nd lp ne nf ng nh bi translated">实现定制的帮助器函数来帮助我们更好地进行身份验证，</li><li id="c846" class="mz na iq ku b kv ni kz nj ld nk lh nl ll nm lp ne nf ng nh bi translated">允许用户注销服务</li></ul><p id="ca06" class="pw-post-body-paragraph ks kt iq ku b kv mc kx ky kz md lb lc ld me lf lg lh mf lj lk ll mg ln lo lp ij bi translated">请继续关注，如果你对我有任何反馈，请告诉我。一定要鼓掌，这样其他人也能看到这个故事。</p></div></div>    
</body>
</html>