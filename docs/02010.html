<html>
<head>
<title>The Git Rerere Command — Automate Solutions to Fix Merge Conflicts</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Git Rerere命令—自动解决合并冲突</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/the-git-rerere-command-automate-solutions-to-fix-merge-conflicts-d501a9ab9007?source=collection_archive---------1-----------------------#2020-02-12">https://levelup.gitconnected.com/the-git-rerere-command-automate-solutions-to-fix-merge-conflicts-d501a9ab9007?source=collection_archive---------1-----------------------#2020-02-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div class="gh gi ir"><img src="../Images/779941316cd9e12ec3dbc7022ee8d886.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/format:webp/1*0UOE0WYKCYd-QkFFO2f31w.jpeg"/></div><figcaption class="iy iz gj gh gi ja jb bd b be z dk translated">来源<a class="ae jc" href="https://pt.slideshare.net/lethee/git-rerere/6?smtNoRedir=1" rel="noopener ugc nofollow" target="_blank">https://pt.slideshare.net/lethee/git-rerere/6?smtNoRedir=1</a></figcaption></figure><div class=""/><blockquote class="kc kd ke"><p id="7cf2" class="kf kg kh ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">关于<code class="fe le lf lg lh b">git rerere</code>命令你需要知道的一切</p></blockquote><p id="1ec1" class="pw-post-body-paragraph kf kg jf ki b kj kk kl km kn ko kp kq li ks kt ku lj kw kx ky lk la lb lc ld im bi translated">今天我们要讨论Git的一个隐藏特性:<code class="fe le lf lg lh b">git rerere</code>。我认为你应该意识到这一点，以使你解决冲突的生活更容易。</p><p id="09bc" class="pw-post-body-paragraph kf kg jf ki b kj kk kl km kn ko kp kq li ks kt ku lj kw kx ky lk la lb lc ld im bi translated"><code class="fe le lf lg lh b">rerere</code>代表<strong class="ki jg">“重复使用录制的分辨率”</strong>。</p><p id="480b" class="pw-post-body-paragraph kf kg jf ki b kj kk kl km kn ko kp kq li ks kt ku lj kw kx ky lk la lb lc ld im bi translated"><code class="fe le lf lg lh b">rerere</code>允许你请求Git记住你是如何解决一个大块冲突的，这样下次它看到同样的冲突时，Git可以自动为你解决它。这才是重点。</p><p id="5814" class="pw-post-body-paragraph kf kg jf ki b kj kk kl km kn ko kp kq li ks kt ku lj kw kx ky lk la lb lc ld im bi translated">在讨论细节之前，让我们先来看一些场景，在这些场景中，这个功能可能会非常方便。</p><h1 id="d3f6" class="ll lm jf bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">情节</h1><ol class=""><li id="4496" class="mj mk jf ki b kj ml kn mm li mn lj mo lk mp ld mq mr ms mt bi translated">如果您有一个主题分支，并且您不断地将主分支或开发分支合并到其中，以使它保持最新。但是您不想因为一堆中间合并提交而弄乱历史。使用<code class="fe le lf lg lh b">rerere</code>，您可以偶尔合并，解决冲突，然后中止合并。然后主题分支完成，您可以进行最后的合并，并且<code class="fe le lf lg lh b">rerere</code>可以自动为您解决所有问题。</li><li id="bd42" class="mj mk jf ki b kj mu kn mv li mw lj mx lk my ld mq mr ms mt bi translated">如果你将一个主题分支的一堆变更合并成一个可测试的(比如uni-test)分支。如果测试分支失败，您可以撤消合并，修复失败，并再次重新合并到测试分支，而不必再次重新解决冲突。</li></ol><p id="4bea" class="pw-post-body-paragraph kf kg jf ki b kj kk kl km kn ko kp kq li ks kt ku lj kw kx ky lk la lb lc ld im bi translated">现在你已经想好了你的场景，让我们开始吧。</p><h1 id="6db5" class="ll lm jf bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">它是如何工作的</h1><p id="1e08" class="pw-post-body-paragraph kf kg jf ki b kj ml kl km kn mm kp kq li mz kt ku lj na kx ky lk nb lb lc ld im bi translated">要启用<code class="fe le lf lg lh b">rerere</code>，运行以下命令:</p><pre class="nc nd ne nf gt ng lh nh ni aw nj bi"><span id="501e" class="nk lm jf lh b gy nl nm l nn no"><strong class="lh jg">$ </strong>git config --global rerere.enabled true</span></pre><p id="64dd" class="pw-post-body-paragraph kf kg jf ki b kj kk kl km kn ko kp kq li ks kt ku lj kw kx ky lk la lb lc ld im bi translated">假设我们有一个名为script.sh的文件，其内容如下:</p><pre class="nc nd ne nf gt ng lh nh ni aw nj bi"><span id="8834" class="nk lm jf lh b gy nl nm l nn no">#!/bin/bash<br/># My first script</span><span id="1a9a" class="nk lm jf lh b gy np nm l nn no">echo "Hello World!"</span></pre><p id="5453" class="pw-post-body-paragraph kf kg jf ki b kj kk kl km kn ko kp kq li ks kt ku lj kw kx ky lk la lb lc ld im bi translated">在<em class="kh">主</em>分支中，我们将单词“Hello”改为“Hola”，然后在<em class="kh">主题</em>分支中，我们将“World”改为“Git”</p><figure class="nc nd ne nf gt iv gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/390288d338e8c6059fe42e987f109836.png" data-original-src="https://miro.medium.com/v2/resize:fit:736/format:webp/1*RHkLFtdBDQiDzCbouv8E-Q.png"/></div></figure><p id="9ec6" class="pw-post-body-paragraph kf kg jf ki b kj kk kl km kn ko kp kq li ks kt ku lj kw kx ky lk la lb lc ld im bi translated">当我们将两个分支合并在一起时，我们会遇到合并冲突:</p><pre class="nc nd ne nf gt ng lh nh ni aw nj bi"><span id="73a4" class="nk lm jf lh b gy nl nm l nn no">$ <strong class="lh jg">git merge topic</strong><br/>Auto-merging script.sh<br/>CONFLICT (content): Merge conflict in script.sh<br/><strong class="lh jg">Recorded preimage for 'script.sh'</strong><br/>Automatic merge failed; fix conflicts and then commit the result.</span></pre><p id="5e6c" class="pw-post-body-paragraph kf kg jf ki b kj kk kl km kn ko kp kq li ks kt ku lj kw kx ky lk la lb lc ld im bi translated">这就像一个普通的合并冲突，但是有一个额外的声明<strong class="ki jg">“为‘script . sh’记录前像”</strong>。当你运行<code class="fe le lf lg lh b">git rerere status</code>而不是<code class="fe le lf lg lh b">git status</code>时，你会知道它记录了什么合并前的状态，或者说前像</p><pre class="nc nd ne nf gt ng lh nh ni aw nj bi"><span id="ebcb" class="nk lm jf lh b gy nl nm l nn no">$ <strong class="lh jg">git rerere status</strong><br/>script.sh</span></pre><p id="ab98" class="pw-post-body-paragraph kf kg jf ki b kj kk kl km kn ko kp kq li ks kt ku lj kw kx ky lk la lb lc ld im bi translated">这是<code class="fe le lf lg lh b">git rerere diff</code>将向你展示的，与<code class="fe le lf lg lh b">git diff</code>相比:</p><figure class="nc nd ne nf gt iv gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/5de585396b2fc444637eddec6809fb99.png" data-original-src="https://miro.medium.com/v2/resize:fit:862/format:webp/1*IkAkEZbKs5mHEMrncqcPcg.png"/></div></figure><p id="f077" class="pw-post-body-paragraph kf kg jf ki b kj kk kl km kn ko kp kq li ks kt ku lj kw kx ky lk la lb lc ld im bi translated">恢复将在文件夹中保存解决方案记录。git/rr-cache。如果您查看您的回购，您确实会找到原像文件:</p><pre class="nc nd ne nf gt ng lh nh ni aw nj bi"><span id="28a6" class="nk lm jf lh b gy nl nm l nn no">$ tree .git/rr-cache<br/>.git/rr-cache<br/>└── 54db390f1318184c7fb941c7c688546bdec9590a<br/>    └── preimage</span></pre><h2 id="c931" class="nk lm jf bd ln ns nt dn lr nu nv dp lv li nw nx lz lj ny nz md lk oa ob mh oc bi translated">通过解决冲突来记录修复</h2><p id="46e8" class="pw-post-body-paragraph kf kg jf ki b kj ml kl km kn mm kp kq li mz kt ku lj na kx ky lk nb lb lc ld im bi translated">我将通过合并<em class="kh"> master </em>分支中的单词“Hola”和<em class="kh"> topic </em>分支中的单词“Git”来解决这个冲突，最终结果将是“Hola Git”。再次运行<code class="fe le lf lg lh b">rerere diff</code>看看它会记住什么:</p><pre class="nc nd ne nf gt ng lh nh ni aw nj bi"><span id="3b6c" class="nk lm jf lh b gy nl nm l nn no">$ <strong class="lh jg">git rerere diff</strong><br/>--- a/script.sh<br/>+++ b/script.sh<br/>@@ -1,8 +1,4 @@<br/> #!/bin/bash<br/> # My first script</span><span id="cde3" class="nk lm jf lh b gy np nm l nn no">-&lt;&lt;&lt;&lt;&lt;&lt;&lt;<br/>-echo "Hello Git!"<br/>-=======<br/>-echo "Hola World!"<br/>-&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br/>+echo "Hola Git!"</span></pre><p id="c863" class="pw-post-body-paragraph kf kg jf ki b kj kk kl km kn ko kp kq li ks kt ku lj kw kx ky lk la lb lc ld im bi translated">看起来不错，对！然后，为了让<em class="kh">重新确保</em>有效地记住解决冲突，暂存文件并提交更改:</p><pre class="nc nd ne nf gt ng lh nh ni aw nj bi"><span id="45a4" class="nk lm jf lh b gy nl nm l nn no">$ git add script.sh</span><span id="7a2a" class="nk lm jf lh b gy np nm l nn no">$ git commit<br/><strong class="lh jg">Recorded resolution for 'script.sh'.</strong><br/>[master d0e6d1b] Merge branch 'topic'</span></pre><p id="90ee" class="pw-post-body-paragraph kf kg jf ki b kj kk kl km kn ko kp kq li ks kt ku lj kw kx ky lk la lb lc ld im bi translated">你可以看到<code class="fe le lf lg lh b">rerere</code>将<strong class="ki jg">记录为‘script . sh’，</strong>或postimage的分辨率。让我们想象下面的图表所显示的变化:</p><figure class="nc nd ne nf gt iv gh gi paragraph-image"><div class="gh gi od"><img src="../Images/bbfc7a22aacbc8694f25c0c51e1d835d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1256/format:webp/1*X0pDpRAHIUTOGNPhjsBzwA.png"/></div></figure><p id="b67f" class="pw-post-body-paragraph kf kg jf ki b kj kk kl km kn ko kp kq li ks kt ku lj kw kx ky lk la lb lc ld im bi translated">事实上，这个补丁现在已经在<em class="kh">发布了:</em></p><pre class="nc nd ne nf gt ng lh nh ni aw nj bi"><span id="24b9" class="nk lm jf lh b gy nl nm l nn no">tree .git/rr-cache<br/>.git/rr-cache<br/>└── 54db390f1318184c7fb941c7c688546bdec9590a<br/>    ├── postimage<br/>    └── preimage</span></pre><figure class="nc nd ne nf gt iv gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/d38b6efd4ee0d6eed34756fed46c5be7.png" data-original-src="https://miro.medium.com/v2/resize:fit:552/format:webp/1*Vp5YOfC-FslGyANxOoHXhw.png"/></div><figcaption class="iy iz gj gh gi ja jb bd b be z dk translated"><strong class="bd ln">前像</strong>和<strong class="bd ln">后像</strong>的内容</figcaption></figure><p id="c616" class="pw-post-body-paragraph kf kg jf ki b kj kk kl km kn ko kp kq li ks kt ku lj kw kx ky lk la lb lc ld im bi translated">恭喜你！！你刚刚用<code class="fe le lf lg lh b">git rerere</code>做出了你的第一个记录决议。</p><p id="6b03" class="pw-post-body-paragraph kf kg jf ki b kj kk kl km kn ko kp kq li ks kt ku lj kw kx ky lk la lb lc ld im bi translated">对于每个包含冲突的文件，git将创建一个带有哈希的新目录。在目录中，我们看到了<strong class="ki jg">【前图像】</strong><strong class="ki jg">【后图像】</strong>。</p><ul class=""><li id="f438" class="mj mk jf ki b kj kk kn ko li of lj og lk oh ld oi mr ms mt bi translated">当<code class="fe le lf lg lh b">rerere</code>看到冲突时，它会创建“前像”。preimage的内容与您运行<code class="fe le lf lg lh b">git diff</code>命令时的内容完全相同。</li><li id="80a9" class="mj mk jf ki b kj mu kn mv li mw lj mx lk my ld oi mr ms mt bi translated">不出所料，“postimage”是冲突解决后文件的外观。</li></ul><p id="d27c" class="pw-post-body-paragraph kf kg jf ki b kj kk kl km kn ko kp kq li ks kt ku lj kw kx ky lk la lb lc ld im bi translated">以下是<code class="fe le lf lg lh b">rerere</code>的工作原理:</p><blockquote class="oj"><p id="b050" class="ok ol jf bd om on oo op oq or os ld dk translated">当<code class="fe le lf lg lh b"><strong class="ak">rerere</strong></code>发现script.sh有冲突时，它会在相应的rr-cache目录中查找，找到与冲突匹配的“前映像”,并更改工作目录中的文件以匹配“后映像”</p></blockquote><h2 id="b1fe" class="nk lm jf bd ln ns ot dn lr nu ou dp lv li ov nx lz lj ow nz md lk ox ob mh oc bi translated">重现自动解决的冲突</h2><p id="a46d" class="pw-post-body-paragraph kf kg jf ki b kj ml kl km kn mm kp kq li mz kt ku lj na kx ky lk nb lb lc ld im bi translated">你怎么知道它会自动解决冲突。让我们撤销合并，然后使用命令<code class="fe le lf lg lh b">git reset -—hard HEAD^</code>在主分支之上重新构建主题分支</p><pre class="nc nd ne nf gt ng lh nh ni aw nj bi"><span id="4302" class="nk lm jf lh b gy nl nm l nn no">$ git reset --hard HEAD^<br/>HEAD is now at ca1bf2b Change Hello to Hola</span></pre><p id="8121" class="pw-post-body-paragraph kf kg jf ki b kj kk kl km kn ko kp kq li ks kt ku lj kw kx ky lk la lb lc ld im bi translated">然后检出主题分支，并对其重新排序</p><pre class="nc nd ne nf gt ng lh nh ni aw nj bi"><span id="5ac4" class="nk lm jf lh b gy nl nm l nn no">$ git checkout topic<br/>Switched to branch 'topic'</span><span id="2e0f" class="nk lm jf lh b gy np nm l nn no">$ git rebase master<br/>First, rewinding head to replay your work on top of it...<br/>Applying: Change World to Git<br/>Using index info to reconstruct a base tree...<br/>M script.sh<br/>Falling back to patching base and 3-way merge...<br/>Auto-merging script.sh<br/>CONFLICT (content): Merge conflict in script.sh<br/><strong class="lh jg">Resolved 'script.sh' using previous resolution.</strong><br/>error: Failed to merge in the changes.<br/>Patch failed at 0001 Change World to Git</span></pre><p id="d657" class="pw-post-body-paragraph kf kg jf ki b kj kk kl km kn ko kp kq li ks kt ku lj kw kx ky lk la lb lc ld im bi translated">我们有和以前一样的冲突，但是要注意行<strong class="ki jg">使用以前的解决方案解决了‘script . sh’。</strong>如果我们查看该文件，我们会发现它已经得到解决，其中没有合并冲突标记。</p><pre class="nc nd ne nf gt ng lh nh ni aw nj bi"><span id="0280" class="nk lm jf lh b gy nl nm l nn no">$ cat script.sh<br/>#!/bin/bash<br/># My first script</span><span id="8a67" class="nk lm jf lh b gy np nm l nn no">echo "Hola Git!"</span></pre><figure class="nc nd ne nf gt iv gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/b4db418f9392d7e80b48f1be61c90aac.png" data-original-src="https://miro.medium.com/v2/resize:fit:550/1*mgIabNcs-qtTnzsf72SO2Q.gif"/></div></figure><p id="fd57" class="pw-post-body-paragraph kf kg jf ki b kj kk kl km kn ko kp kq li ks kt ku lj kw kx ky lk la lb lc ld im bi translated">另外，<code class="fe le lf lg lh b">git diff</code>向您展示了它是如何被自动重新解析的</p><pre class="nc nd ne nf gt ng lh nh ni aw nj bi"><span id="a194" class="nk lm jf lh b gy nl nm l nn no">$ git diff<br/>diff --cc script.sh<br/>index 46e4937,3108049..0000000<br/>--- a/script.sh<br/>+++ b/script.sh<br/>@@@ -1,4 -1,4 +1,4 @@@<br/>  #!/bin/bash<br/>  # My first script</span><span id="ed3f" class="nk lm jf lh b gy np nm l nn no">- echo "Hola World!"<br/> -echo "Hello Git!"<br/>++echo "Hola Git!"</span></pre><figure class="nc nd ne nf gt iv gh gi paragraph-image"><div class="gh gi oz"><img src="../Images/ea0cab28da2dbc5e35ee8c78892729e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1316/format:webp/1*FmsUex5DtRcjda996GwnJg.png"/></div><figcaption class="iy iz gj gh gi ja jb bd b be z dk translated">说明重新确定基础的过程</figcaption></figure><p id="ded2" class="pw-post-body-paragraph kf kg jf ki b kj kk kl km kn ko kp kq li ks kt ku lj kw kx ky lk la lb lc ld im bi translated">现在我可以添加并继续rebase来完成它:</p><pre class="nc nd ne nf gt ng lh nh ni aw nj bi"><span id="a598" class="nk lm jf lh b gy nl nm l nn no">$ git add script.sh<br/>$ git rebase --continue<br/>Applying: Change World to Git</span></pre><h2 id="4e48" class="nk lm jf bd ln ns nt dn lr nu nv dp lv li nw nx lz lj ny nz md lk oa ob mh oc bi translated">再拧一下</h2><p id="5588" class="pw-post-body-paragraph kf kg jf ki b kj ml kl km kn mm kp kq li mz kt ku lj na kx ky lk nb lb lc ld im bi translated">虽然<code class="fe le lf lg lh b">rerere</code>自动为你解决冲突，但它仍然让你的自动修复文件处于未升级状态。这意味着你必须手动操作<code class="fe le lf lg lh b">git add &lt;file&gt;</code>，有时候真的很烦人。</p><p id="5151" class="pw-post-body-paragraph kf kg jf ki b kj kk kl km kn ko kp kq li ks kt ku lj kw kx ky lk la lb lc ld im bi translated">如果您更喜欢<code class="fe le lf lg lh b">rerere</code>自动升级它自动修复的文件，使用此命令:</p><pre class="nc nd ne nf gt ng lh nh ni aw nj bi"><span id="0156" class="nk lm jf lh b gy nl nm l nn no">$ git config --global rerere.autoupdate true</span></pre><p id="03c3" class="pw-post-body-paragraph kf kg jf ki b kj kk kl km kn ko kp kq li ks kt ku lj kw kx ky lk la lb lc ld im bi translated">从现在开始，<code class="fe le lf lg lh b">rerere</code>将为您自动修复和自动暂存您的文件。太棒了。</p><pre class="nc nd ne nf gt ng lh nh ni aw nj bi"><span id="53a0" class="nk lm jf lh b gy nl nm l nn no">git rebase master<br/>First, rewinding head to replay your work on top of it...<br/>Applying: Change text to Hello Git<br/>Using index info to reconstruct a base tree...<br/>M script.sh<br/>Falling back to patching base and 3-way merge...<br/>Auto-merging script.sh<br/>CONFLICT (content): Merge conflict in script.sh<br/><strong class="lh jg">Staged 'script.sh' using previous resolution.</strong><br/>error: Failed to merge in the changes.<br/>Patch failed at 0001 Change World to Git</span></pre><p id="0d91" class="pw-post-body-paragraph kf kg jf ki b kj kk kl km kn ko kp kq li ks kt ku lj kw kx ky lk la lb lc ld im bi translated">你所要做的就是继续重定基础来完成它:</p><pre class="nc nd ne nf gt ng lh nh ni aw nj bi"><span id="5c10" class="nk lm jf lh b gy nl nm l nn no">$ git rebase --continue<br/>Applying: Change World to Git</span></pre><h1 id="20a7" class="ll lm jf bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">结论</h1><p id="82d3" class="pw-post-body-paragraph kf kg jf ki b kj ml kl km kn mm kp kq li mz kt ku lj na kx ky lk nb lb lc ld im bi translated">如果你做了大量的重新合并，或者想在不进行大量合并的情况下保持主题分支与主分支保持同步，或者你经常改变基础，你可以打开<code class="fe le lf lg lh b">rerere</code>来帮助你摆脱困境。只需使用<code class="fe le lf lg lh b"><strong class="ki jg">git config --global rerere.enabled true</strong></code>打开它，让Git完成所有剩下的工作。</p><p id="4519" class="pw-post-body-paragraph kf kg jf ki b kj kk kl km kn ko kp kq li ks kt ku lj kw kx ky lk la lb lc ld im bi translated">祝你快乐！</p></div></div>    
</body>
</html>