<html>
<head>
<title>JavaScript Mistakes — null vs undefined, Constructors, and Scopes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript错误— null vs undefined、构造函数和作用域</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-mistakes-constructors-and-scopes-12e3eab8235a?source=collection_archive---------11-----------------------#2020-01-23">https://levelup.gitconnected.com/javascript-mistakes-constructors-and-scopes-12e3eab8235a?source=collection_archive---------11-----------------------#2020-01-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/a11193472828c58338c4238423bc4ae9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*eulLQjk3r3m14uBn"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">安德烈·瓦瑟伯格在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="78b1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">JavaScript是一种比世界上许多其他编程语言更友好的语言。然而，在编写JavaScript代码时，由于误解或忽略我们已经知道的东西，仍然很容易犯错误。通过避免下面的一些错误，我们可以通过防止代码中的错误和错别字来使我们的生活变得更容易，这些错误和错别字会使我们陷入意想不到的结果。在本文中，我们将看看<code class="fe le lf lg lh b">null</code>和<code class="fe le lf lg lh b">undefined</code>之间的混淆，异步代码的作用域问题，以及内建对象的作用域和使用对象文字与构造函数。</p><h1 id="e64c" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">混淆空和未定义</h1><p id="d24a" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">在JavaScript中，<code class="fe le lf lg lh b">null</code>和<code class="fe le lf lg lh b">undefined</code>都表示变量没有值。它们非常相似，但也有一些重要的区别。如果<code class="fe le lf lg lh b">null</code>的类型是<code class="fe le lf lg lh b">object</code>，那么当我们在<code class="fe le lf lg lh b">null</code>上使用<code class="fe le lf lg lh b">typeof</code>操作符时，如下所示:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="37c0" class="mt lj it lh b gy mu mv l mw mx">typeof null</span></pre><p id="3017" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们得到<code class="fe le lf lg lh b">'object'</code>。</p><p id="8183" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一方面，如果我们在<code class="fe le lf lg lh b">undefined</code>上使用<code class="fe le lf lg lh b">typeof</code>操作符，如下所示:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="f17a" class="mt lj it lh b gy mu mv l mw mx">typeof undefined</span></pre><p id="b8e4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们得到<code class="fe le lf lg lh b">'undefined'</code>。</p><p id="01d9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们将它们与<code class="fe le lf lg lh b">===</code>操作符进行比较，如下所示:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="d59e" class="mt lj it lh b gy mu mv l mw mx">undefined === null</span></pre><p id="b963" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们得到<code class="fe le lf lg lh b">false</code>，因为它们是两种不同的类型。然而，当我们将它们与<code class="fe le lf lg lh b">==</code>操作符进行比较时:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="6f5e" class="mt lj it lh b gy mu mv l mw mx">undefined == null</span></pre><p id="6f75" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们得到<code class="fe le lf lg lh b">true</code>，因为它们都是假的。因为它们是两种不同的类型，所以不应该混淆。</p><p id="5a6b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">需要注意的一点是，对于函数默认参数，只有当值为<code class="fe le lf lg lh b">undefined</code>而不是<code class="fe le lf lg lh b">null</code>时，它们才会被赋值。</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="4339" class="mt lj it lh b gy mu mv l mw mx">const hello = (name = 'World') =&gt; console.log(`Hello, ${name}!`)<br/>hello(null) // Hello, null!<br/>hello(undefined) // Hello, World!</span></pre><h1 id="717f" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">异步代码和范围</h1><p id="6e73" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">JavaScript的一个令人困惑的方面是变量的可见性仍然在父范围内。这意味着当一个循环运行时，我们希望在<code class="fe le lf lg lh b">setTimeout</code>函数的回调中访问一个循环变量，在<code class="fe le lf lg lh b">setTimeout</code>函数的回调被调用之前，索引变量已经被递增以满足结束条件。这意味着我们只能在循环结束后获得循环变量的最终值，该值被传递到<code class="fe le lf lg lh b">setTimeout</code>函数的回调中。</p><p id="67c4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有以下代码:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="9978" class="mt lj it lh b gy mu mv l mw mx">for (var i = 0; i &lt; 10; i++) {<br/>  setTimeout(() =&gt; {<br/>    console.log(i);<br/>  }, 100);<br/>}</span></pre><p id="4e5b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们得到10次记录。这是因为<code class="fe le lf lg lh b">setTimeout</code>的回调函数中的代码在循环结束后运行。<code class="fe le lf lg lh b">i</code>到时候早就更新到10了。如果我们想在每个<code class="fe le lf lg lh b">setTimeout</code>回调函数调用中保持循环变量的值。然后，我们必须通过将<code class="fe le lf lg lh b">setTimeout</code>包装在一个函数中，将<code class="fe le lf lg lh b">i</code>的值传递给回调函数。</p><p id="d753" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们希望看到0到9被记录，那么我们必须编写以下代码:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="b961" class="mt lj it lh b gy mu mv l mw mx">for (var i = 0; i &lt; 10; i++) {<br/>  ((i) =&gt; {<br/>    setTimeout(() =&gt; {<br/>      console.log(i);<br/>    }, 100);<br/>  })(i)<br/>}</span></pre><p id="4735" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的代码将<code class="fe le lf lg lh b">setTimeout</code>调用包装在匿名函数中，每次循环运行时我们都会调用该函数，并且我们在每次迭代中将<code class="fe le lf lg lh b">i</code>的值传递给该函数。然后在循环完成后，<code class="fe le lf lg lh b">i</code>的值将被传递到<code class="fe le lf lg lh b">console.log</code>而不是<code class="fe le lf lg lh b">i</code>的值。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi my"><img src="../Images/651a82f1a3208cb9b66957896e21ff34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fsGqWwoe72Rmir0M"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">弗朗切斯科·德·托马索在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="9509" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">在文本上使用构造函数</h1><p id="0b9c" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">在JavaScript中，构造函数对于创建新的对象实例并不总是有用的。对于像数组、数字和字符串这样的内置对象来说尤其如此。我们用<code class="fe le lf lg lh b">new</code>操作符构造对象的新实例，就像C#或Java等其他语言一样。然而，它并不总是如我们所愿。</p><p id="e9a6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以用<code class="fe le lf lg lh b">new</code>操作符创建一个新的<code class="fe le lf lg lh b">Array</code>对象。例如，我们可以写:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="38d2" class="mt lj it lh b gy mu mv l mw mx">let arr = new Array('a', 'b', 'c', 'd');</span></pre><p id="a5a7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们得到了我们期望的<code class="fe le lf lg lh b">[“a”, “b”, “c”, “d”]</code>。然而，当我们只向<code class="fe le lf lg lh b">Array</code>构造函数传递一个参数时，正如我们在下面的代码中所做的:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="28a8" class="mt lj it lh b gy mu mv l mw mx">let arr1 = new Array(23);</span></pre><p id="6c84" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们得到一个空数组，其属性设置为23。</p><p id="5629" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">原来有两个<code class="fe le lf lg lh b">Array</code>构造函数。一个接受一个参数，即数组的长度，另一个接受由逗号分隔的无限对象列表，即新数组的元素列表。</p><p id="90fd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是，如果唯一的参数不是一个数字，那么它会创建一个数组，并将该参数作为数组的唯一条目。例如，如果我们写:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="79f1" class="mt lj it lh b gy mu mv l mw mx">let arr = new Array('a');</span></pre><p id="bc24" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们得到<code class="fe le lf lg lh b">[“a”]</code>。</p><p id="bfce" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果唯一的参数是负数，它也无法创建新数组。我们得到错误消息<code class="fe le lf lg lh b">Uncaught RangeError: Invalid array length</code>。</p><p id="a910" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用数组构造函数令人困惑，因为有两个构造函数接受不同类型的参数。</p><p id="f175" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于数字和字符串，我们在使用构造函数创建这些对象时会遇到不同的问题。当我们使用<code class="fe le lf lg lh b">new</code>操作符创建一个数字或字符串对象时，当我们将它们与<code class="fe le lf lg lh b">===</code>操作符比较时，我们会遇到问题。例如，如果我们尝试比较两个具有相同内容的字符串，其中一个是字符串文字，另一个是用构造函数创建的，如下面的代码所示:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="0514" class="mt lj it lh b gy mu mv l mw mx">'abc' === new String('abc');</span></pre><p id="719e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们得到<code class="fe le lf lg lh b">false</code>，即使它们的内容完全相同。这是因为字符串文字<code class="fe le lf lg lh b">'abc'</code>属于string类型，但是用<code class="fe le lf lg lh b">new String(‘abc’)</code>创建的对象属于object类型。同样，这是令人困惑的。</p><p id="18a6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们必须在string对象上调用<code class="fe le lf lg lh b">valueOf</code>方法，使其成为string类型的对象。</p><p id="d745" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，如果我们有:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="503e" class="mt lj it lh b gy mu mv l mw mx">1 === new Number(1);</span></pre><p id="9459" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们也因为同样的原因得到<code class="fe le lf lg lh b">false</code>。<code class="fe le lf lg lh b">1</code>属于数字类型，而<code class="fe le lf lg lh b">new Number(1)</code>属于对象类型。同样，我们必须调用<code class="fe le lf lg lh b">valueOf</code>方法将<code class="fe le lf lg lh b">new Number(1)</code>转换回数字类型的对象。</p><p id="eb0d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所有这些问题的解决方案都可以通过使用文字符号来解决。JavaScript不需要预先知道数组的长度，因为它只是将<code class="fe le lf lg lh b">undefined</code>赋给没有赋值的位置。</p><h1 id="6517" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">结论</h1><p id="b0e0" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">在JavaScript中，<code class="fe le lf lg lh b">null</code>和<code class="fe le lf lg lh b">undefined</code>都意味着被赋予这些值的变量没有值。它们非常相似，但是有一些重要的。一个如果<code class="fe le lf lg lh b">null</code>是类型<code class="fe le lf lg lh b">object</code>，而<code class="fe le lf lg lh b">undefined</code>是类型<code class="fe le lf lg lh b">undefined</code>。这意味着<code class="fe le lf lg lh b">null === undefined</code>将被评估为<code class="fe le lf lg lh b">false</code>。</p><p id="afc1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">每当我们有异步代码，并且我们想要将某个变量的值传入一个由类似<code class="fe le lf lg lh b">setTimeout</code>的异步函数调用的回调函数时，我们必须将外部变量传入用函数包装异步代码的回调函数，然后将变量从外部传入回调函数。</p><p id="18af" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我们应该避免使用构造函数来创建内置对象，如数组、数字和字符串。对于数字和字符串，类型将不同于文字类型，文字类型将具有数字或字符串的实际基本类型。对于数组来说，这是因为有两个构造函数接受不同的参数，我们会得到意想不到的结果，这取决于我们传入的参数的数量。</p></div></div>    
</body>
</html>