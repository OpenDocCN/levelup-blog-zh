<html>
<head>
<title>10 Things You Need To Know About TypeScript Classes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于TypeScript类你需要知道的10件事</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/10-things-you-need-to-know-about-typescript-classes-f58c57869266?source=collection_archive---------3-----------------------#2022-08-26">https://levelup.gitconnected.com/10-things-you-need-to-know-about-typescript-classes-f58c57869266?source=collection_archive---------3-----------------------#2022-08-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/fcbe7fa85f65f36bb08fec14fb23687f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jqvNqAnEOpRNt4O011IAKg.jpeg"/></div></div></figure><p id="5599" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">欢迎来到<strong class="kd iu">掌握打字稿</strong>系列。本系列将以动画的形式介绍TypeScript的核心知识和技术。让我们一起学习吧！以前的文章如下:</p><ul class=""><li id="1de8" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated"><a class="ae li" href="https://medium.com/frontend-canteen/what-are-k-t-and-v-in-typescript-generics-9fabe1d0f0f3" rel="noopener"><strong class="kd iu">TypeScript泛型中的K、T、V是什么？</strong> </a></li><li id="257c" class="kz la it kd b ke lj ki lk km ll kq lm ku ln ky le lf lg lh bi translated"><a class="ae li" href="https://javascript.plainenglish.io/using-typescript-mapped-types-like-a-pro-be10aef5511a" rel="noopener ugc nofollow" target="_blank"> <strong class="kd iu">使用TypeScript像Pro一样映射类型</strong> </a></li><li id="3b5a" class="kz la it kd b ke lj ki lk km ll kq lm ku ln ky le lf lg lh bi translated"><a class="ae li" href="https://javascript.plainenglish.io/use-typescript-conditional-types-like-a-pro-7baea0ad05c5" rel="noopener ugc nofollow" target="_blank"> <strong class="kd iu">使用TypeScript条件类型像亲</strong> </a></li><li id="5fd2" class="kz la it kd b ke lj ki lk km ll kq lm ku ln ky le lf lg lh bi translated"><a class="ae li" href="https://javascript.plainenglish.io/using-typescript-intersection-types-like-a-pro-a55da6a6a5f7" rel="noopener ugc nofollow" target="_blank"> <strong class="kd iu">使用TypeScript交集类型像亲</strong> </a></li><li id="5d29" class="kz la it kd b ke lj ki lk km ll kq lm ku ln ky le lf lg lh bi translated"><a class="ae li" rel="noopener ugc nofollow" target="_blank" href="/using-typescript-infer-like-a-pro-f30ab8ab41c7"> <strong class="kd iu">利用打字稿像专家一样推断</strong> </a></li><li id="d056" class="kz la it kd b ke lj ki lk km ll kq lm ku ln ky le lf lg lh bi translated"><a class="ae li" href="https://medium.com/javascript-in-plain-english/how-to-use-typescript-template-literal-types-like-a-pro-2e02a7db0bac" rel="noopener"> <strong class="kd iu">使用TypeScript模板字面类型像亲</strong> </a></li><li id="f23a" class="kz la it kd b ke lj ki lk km ll kq lm ku ln ky le lf lg lh bi translated"><a class="ae li" href="https://javascript.plainenglish.io/15-utility-types-that-every-typescript-developer-should-know-6cf121d4047c" rel="noopener ugc nofollow" target="_blank"> <strong class="kd iu">可视化打字稿:15种最常用的实用类型</strong> </a></li><li id="847f" class="kz la it kd b ke lj ki lk km ll kq lm ku ln ky le lf lg lh bi translated"><a class="ae li" rel="noopener ugc nofollow" target="_blank" href="/10-things-you-need-to-know-about-typescript-classes-f58c57869266"> <strong class="kd iu">关于类型脚本类你需要知道的10件事</strong> </a></li><li id="54ed" class="kz la it kd b ke lj ki lk km ll kq lm ku ln ky le lf lg lh bi translated"><a class="ae li" href="https://javascript.plainenglish.io/purpose-of-declare-keyword-in-typescript-8431d9db2b10" rel="noopener ugc nofollow" target="_blank"><strong class="kd iu">TypeScript中‘declare’关键字的用途</strong> </a></li></ul><p id="7602" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在面向对象的语言中，类是创建对象的蓝图，描述所创建对象的公共属性和方法。在本文中，我将介绍关于TypeScript需要了解的10件事情。</p><h1 id="3761" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">1.类属性和方法</h1><h2 id="6a15" class="mm lp it bd lq mn mo dn lu mp mq dp ly km mr ms mc kq mt mu mg ku mv mw mk mx bi translated">1.1类成员属性和静态属性</h2><p id="6e78" class="pw-post-body-paragraph kb kc it kd b ke my kg kh ki mz kk kl km na ko kp kq nb ks kt ku nc kw kx ky im bi translated">在TypeScript中，我们可以用关键字<code class="fe nd ne nf ng b">class</code>定义一个类:</p><pre class="nh ni nj nk gt nl ng nm nn aw no bi"><span id="de0b" class="mm lp it ng b gy np nq l nr ns">class User {<br/>  name: string;</span><span id="3a16" class="mm lp it ng b gy nt nq l nr ns">  constructor(name: string) {<br/>    this.name = name;<br/>  }<br/>}</span></pre><p id="f0aa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在上面的代码中，我们使用class关键字定义了一个用户类，其成员属性名为<code class="fe nd ne nf ng b">name</code>。其实TypeScript中的类就是句法糖(<strong class="kd iu">句法糖就是在一个之前的语法基础上改变一种写法，实现同样的功能，只是写法不同，主要是让开发者在过程中使用。更方便，更容易理解。</strong>)，如果将编译目标设置为ES5，将会生成以下代码:</p><pre class="nh ni nj nk gt nl ng nm nn aw no bi"><span id="2adb" class="mm lp it ng b gy np nq l nr ns">"use strict";<br/>var User = /** <a class="ae li" href="http://twitter.com/class" rel="noopener ugc nofollow" target="_blank">@class</a> */ (function () {<br/>    function User(name) {<br/>        this.name = name;<br/>    }<br/>    return User;<br/>}());</span></pre><p id="d32e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">除了定义成员属性，类还可以通过<code class="fe nd ne nf ng b">static</code>关键字定义静态属性:</p><pre class="nh ni nj nk gt nl ng nm nn aw no bi"><span id="8233" class="mm lp it ng b gy np nq l nr ns">class User {<br/>  static cid: string = "eft";<br/>  name: string;</span><span id="1790" class="mm lp it ng b gy nt nq l nr ns">  constructor(name: string) {<br/>    this.name = name;<br/>  }<br/>}</span></pre><p id="0505" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">那么成员属性和静态属性的区别是什么呢？在回答这个问题之前，我们先来看看编译好的ES5代码:</p><pre class="nh ni nj nk gt nl ng nm nn aw no bi"><span id="4503" class="mm lp it ng b gy np nq l nr ns">"use strict";<br/>var User = /** <a class="ae li" href="http://twitter.com/class" rel="noopener ugc nofollow" target="_blank">@class</a> */ (function () {<br/>    function User(name) {<br/>        this.name = name;<br/>    }<br/>    User.cid = "eft";<br/>    return User;<br/>}());</span></pre><p id="2000" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">从上面的代码可以看出，成员属性是在类的实例上定义的，而静态属性是在构造函数上定义的。</p><h2 id="ec10" class="mm lp it bd lq mn mo dn lu mp mq dp ly km mr ms mc kq mt mu mg ku mv mw mk mx bi translated">1.2类成员方法和静态方法</h2><p id="d006" class="pw-post-body-paragraph kb kc it kd b ke my kg kh ki mz kk kl km na ko kp kq nb ks kt ku nc kw kx ky im bi translated">定义TypeScript类时，我们不仅可以定义成员属性和静态属性，还可以定义成员方法和静态方法，如下所示:</p><pre class="nh ni nj nk gt nl ng nm nn aw no bi"><span id="f1e8" class="mm lp it ng b gy np nq l nr ns">class User {<br/>  static cid: string = "eft";<br/>  name: string;</span><span id="4850" class="mm lp it ng b gy nt nq l nr ns">  constructor(name: string) {<br/>    this.name = name;<br/>  }</span><span id="35a5" class="mm lp it ng b gy nt nq l nr ns">  static printCid() {<br/>    console.log(User.cid);<br/>  }</span><span id="c681" class="mm lp it ng b gy nt nq l nr ns">  send(msg: string) {<br/>    console.log(`${this.name} send a message: ${msg}`);<br/>  }<br/>}</span></pre><p id="a641" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">那么成员方法和静态方法的区别是什么呢？同样，在回答这个问题之前，我们先来看看编译好的ES5代码:</p><pre class="nh ni nj nk gt nl ng nm nn aw no bi"><span id="b816" class="mm lp it ng b gy np nq l nr ns">"use strict";<br/>var User = /** <a class="ae li" href="http://twitter.com/class" rel="noopener ugc nofollow" target="_blank">@class</a> */ (function () {<br/>    function User(name) {<br/>        this.name = name;<br/>    }<br/>    User.printCid = function () {<br/>        console.log(User.cid);<br/>    };<br/>    User.prototype.send = function (msg) {<br/>        console.log("".concat(this.name, " send a message: ").concat(msg));<br/>    };<br/>    User.cid = "eft";<br/>    return User;<br/>}());</span></pre><p id="f6ca" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">从上面的代码可以看出，<strong class="kd iu">成员方法将被添加到构造函数的prototype对象中，静态方法将被添加到构造函数</strong>中。</p><h1 id="3474" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">2.类访问器</h1><p id="6410" class="pw-post-body-paragraph kb kc it kd b ke my kg kh ki mz kk kl km na ko kp kq nb ks kt ku nc kw kx ky im bi translated">类也可以有访问器<em class="nu">。</em>我们可以通过getter和setter方法实现数据封装和有效性验证，防止数据异常。</p><pre class="nh ni nj nk gt nl ng nm nn aw no bi"><span id="c402" class="mm lp it ng b gy np nq l nr ns">class User {<br/>  private _age: number = 0;</span><span id="e2b3" class="mm lp it ng b gy nt nq l nr ns">  get age(): number {<br/>    return this._age;<br/>  }</span><span id="7716" class="mm lp it ng b gy nt nq l nr ns">  set age(value: number) {<br/>    if (value &gt; 0 &amp;&amp; value &lt;= 120) {<br/>      this._age = value;<br/>    } else {<br/>      console.log("Error: The set age value is invalid!");<br/>    }<br/>  }<br/>}</span></pre><h1 id="3914" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">3.类继承</h1><p id="a8e9" class="pw-post-body-paragraph kb kc it kd b ke my kg kh ki mz kk kl km na ko kp kq nb ks kt ku nc kw kx ky im bi translated">继承是将类链接到类的层次模型。它指的是一个类继承另一个类的功能并添加自己的新功能的能力。继承是类与类或接口与接口之间最常见的关系。通过类继承，我们可以实现代码重用。</p><p id="29a2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在TypeScript中，我们可以通过<code class="fe nd ne nf ng b">extends</code>关键字实现类继承。类可能<code class="fe nd ne nf ng b">extend</code>来自基类。派生类具有其基类的所有属性和方法，并且还定义了其他成员。</p><h2 id="2b00" class="mm lp it bd lq mn mo dn lu mp mq dp ly km mr ms mc kq mt mu mg ku mv mw mk mx bi translated">3.1基本类别</h2><pre class="nh ni nj nk gt nl ng nm nn aw no bi"><span id="b3af" class="mm lp it ng b gy np nq l nr ns">class Person {<br/>  constructor(public name: string) {}<br/><br/>  public say(words: string) :void {<br/>    console.log(`${this.name} says：${words}`);  <br/>  }<br/>}</span></pre><h2 id="d848" class="mm lp it bd lq mn mo dn lu mp mq dp ly km mr ms mc kq mt mu mg ku mv mw mk mx bi translated">3.2派生类</h2><pre class="nh ni nj nk gt nl ng nm nn aw no bi"><span id="d200" class="mm lp it ng b gy np nq l nr ns">class Developer extends Person {<br/>  constructor(name: string) {<br/>    super(name);<br/>    this.say("Learn TypeScript")<br/>  }<br/>}</span><span id="7950" class="mm lp it ng b gy nt nq l nr ns">const p2 = new Developer("Bytefer"); <br/>// "Bytefer says：Learn TypeScript"</span></pre><p id="38a1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因为Developer类扩展了Person类，所以我们可以在Developer类的构造函数中调用<code class="fe nd ne nf ng b">say</code>方法。需要注意的是<strong class="kd iu">在TypeScript中使用扩展时，只能继承一个类:</strong></p><figure class="nh ni nj nk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/76315c364678f3fb442eac316cb4b1c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ML8Ot9tjyVYnhxFoK9sorg.jpeg"/></div></div></figure><p id="6245" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">虽然在TypeScript中只允许单一继承，但它允许我们实现多个接口。相应的例子如下:</p><pre class="nh ni nj nk gt nl ng nm nn aw no bi"><span id="2645" class="mm lp it ng b gy np nq l nr ns">interface CanSay {<br/>   say(words: string) :void <br/>}<br/><br/>interface CanWalk {<br/>  walk(): void;<br/>}<br/><br/>class Person implements CanSay, CanWalk {<br/>  constructor(public name: string) {}<br/><br/>  public say(words: string) :void {<br/>    console.log(`${this.name} says：${words}`);  <br/>  }<br/><br/>  public walk(): void {<br/>    console.log(`${this.name} walk with feet`);<br/>  }<br/>}</span></pre><p id="cb23" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">除了能够继承具体的类，在实现继承的时候，我们还可以继承抽象的类。</p><h1 id="899f" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">4.抽象类</h1><p id="b869" class="pw-post-body-paragraph kb kc it kd b ke my kg kh ki mz kk kl km na ko kp kq nb ks kt ku nc kw kx ky im bi translated">TypeScript中的类、方法和字段可能是抽象的。用<code class="fe nd ne nf ng b">abstract</code>关键字声明的类称为抽象类。<strong class="kd iu">抽象类无法实例化，因为它包含一个或多个抽象字段/方法。</strong></p><figure class="nh ni nj nk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/e3d2f15c4df3b9aab4f92bf4246caa95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8qnWdF2eXRoeKn_mIu2VLQ.jpeg"/></div></div></figure><p id="958a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">抽象类的作用是作为实现所有抽象成员的子类的基类。</p><pre class="nh ni nj nk gt nl ng nm nn aw no bi"><span id="864f" class="mm lp it ng b gy np nq l nr ns">class Developer extends Person {<br/>  constructor(name: string) {<br/>    super(name);<br/>  }<br/>  <br/>  say(words: string): void {<br/>    console.log(`${this.name} says ${words}`);<br/>  }<br/>}</span><span id="c414" class="mm lp it ng b gy nt nq l nr ns">const bytefer = new Developer("Bytefer");<br/>bytefer.say("I love ts!"); // Bytefer says I love ts!</span></pre><h1 id="b838" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">5.成员可见性</h1><p id="90ad" class="pw-post-body-paragraph kb kc it kd b ke my kg kh ki mz kk kl km na ko kp kq nb ks kt ku nc kw kx ky im bi translated">在TypeScript中，我们可以使用<code class="fe nd ne nf ng b">public</code>、<code class="fe nd ne nf ng b">protected</code>或<code class="fe nd ne nf ng b">private</code>来控制某些方法或属性对类外的代码是否可见。</p><h2 id="faf6" class="mm lp it bd lq mn mo dn lu mp mq dp ly km mr ms mc kq mt mu mg ku mv mw mk mx bi translated">5.1公共</h2><p id="29cf" class="pw-post-body-paragraph kb kc it kd b ke my kg kh ki mz kk kl km na ko kp kq nb ks kt ku nc kw kx ky im bi translated">类成员的默认可见性是<code class="fe nd ne nf ng b">public</code>。可以在任何地方访问<code class="fe nd ne nf ng b">public</code>成员:</p><pre class="nh ni nj nk gt nl ng nm nn aw no bi"><span id="124f" class="mm lp it ng b gy np nq l nr ns">class Person {<br/>  constructor(public name: string) {}</span><span id="998c" class="mm lp it ng b gy nt nq l nr ns">  public say(words: string) :void {<br/>    console.log(`${this.name} says：${words}`);  <br/>  }<br/>}</span></pre><h2 id="8dc1" class="mm lp it bd lq mn mo dn lu mp mq dp ly km mr ms mc kq mt mu mg ku mv mw mk mx bi translated">5.2受保护</h2><p id="b495" class="pw-post-body-paragraph kb kc it kd b ke my kg kh ki mz kk kl km na ko kp kq nb ks kt ku nc kw kx ky im bi translated">受保护的属性或方法是受保护的，它类似于private，只是受保护的成员仍然可以在派生类中访问。</p><figure class="nh ni nj nk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/e38e8eecfa1a3f51f2acf4da2b09ea4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sCvpThVoUfDs29tSmIW3zA.jpeg"/></div></div></figure><p id="ccdc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">从上面的错误消息可以看出，用protected修饰符修改的方法只能在当前类或其子类中使用。</p><pre class="nh ni nj nk gt nl ng nm nn aw no bi"><span id="7d51" class="mm lp it ng b gy np nq l nr ns">class Developer extends Person {<br/>  constructor(name: string) {<br/>    super(name);<br/>    console.log(`Base Class：${this.getClassName()}`);<br/>  }<br/>}</span><span id="aa01" class="mm lp it ng b gy nt nq l nr ns">const bytefer = new Developer("Bytefer"); // "Base Class：Person"</span></pre><h2 id="ad0b" class="mm lp it bd lq mn mo dn lu mp mq dp ly km mr ms mc kq mt mu mg ku mv mw mk mx bi translated">5.3私人</h2><p id="5b7c" class="pw-post-body-paragraph kb kc it kd b ke my kg kh ki mz kk kl km na ko kp kq nb ks kt ku nc kw kx ky im bi translated">private修改的属性或方法是私有的，只能在类中访问。</p><figure class="nh ni nj nk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/df760483ab3e962b28f8a709ea4aa8e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xuWNd_5JYIdPNiR46EzYBw.jpeg"/></div></div></figure><p id="25b6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">从上面的错误消息可以看出，用<code class="fe nd ne nf ng b">private</code>修饰符修改的属性只能在当前类中访问。但真的是这样吗？事实上，这只是来自TypeScript类型检查器的一个提示，即我们仍然可以在运行时访问Person实例的id属性。我们来看看编译好的<strong class="kd iu"> ES5 </strong>代码:</p><pre class="nh ni nj nk gt nl ng nm nn aw no bi"><span id="0abc" class="mm lp it ng b gy np nq l nr ns">"use strict";<br/>var Person = /** <a class="ae li" href="http://twitter.com/class" rel="noopener ugc nofollow" target="_blank">@class</a> */ (function () {<br/>    function Person(id, name) {<br/>        this.id = id;<br/>        this.name = name;<br/>    }<br/>    return Person;<br/>}());<br/>var p1 = new Person(28, "bytefer");</span></pre><h2 id="7c15" class="mm lp it bd lq mn mo dn lu mp mq dp ly km mr ms mc kq mt mu mg ku mv mw mk mx bi translated">5.4 ECMAScript私有字段</h2><p id="dbb1" class="pw-post-body-paragraph kb kc it kd b ke my kg kh ki mz kk kl km na ko kp kq nb ks kt ku nc kw kx ky im bi translated">为了应对private修饰符的问题，TypeScript团队在3.8中开始支持<strong class="kd iu"> ECMAScript私有字段</strong>。用法如下:</p><figure class="nh ni nj nk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/405378479b20fb0f8d4f6cc9afe2e270.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SAQxoZbl6NBK4dJmXhJYwA.jpeg"/></div></div></figure><p id="f278" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">那么与私有修饰符相比，ECMAScript私有字段有什么特别之处呢？这里我们来看看编译好的<strong class="kd iu"> ES2015 </strong>代码:</p><pre class="nh ni nj nk gt nl ng nm nn aw no bi"><span id="41b8" class="mm lp it ng b gy np nq l nr ns">"use strict";<br/>var __classPrivateFieldSet = // ignore related code;<br/>var _Person_name;<br/>class Person {<br/>    constructor(name) {<br/>        _Person_name.set(this, void 0);<br/>        __classPrivateFieldSet(this, _Person_name, name, "f");<br/>    }<br/>}<br/>_Person_name = new WeakMap();</span><span id="0088" class="mm lp it ng b gy nt nq l nr ns">let bytefer = new Person("Bytefer");</span></pre><p id="5aea" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">从以上结果可以看出，ES2015中新增的WeakMap数据类型在处理私有字段时使用。让我们总结一下私有字段与常规属性(甚至是那些用private修饰符声明的属性)的区别:</p><ul class=""><li id="cd3a" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated">私有字段以一个<code class="fe nd ne nf ng b">#</code>字符开始。有时候我们把这些私有的<em class="nu">名字叫做</em>。</li><li id="0181" class="kz la it kd b ke lj ki lk km ll kq lm ku ln ky le lf lg lh bi translated">每个私有字段名都唯一地限定在其包含的类的范围内。</li><li id="ff9d" class="kz la it kd b ke lj ki lk km ll kq lm ku ln ky le lf lg lh bi translated">像<code class="fe nd ne nf ng b">public</code>或<code class="fe nd ne nf ng b">private</code>这样的TypeScript可访问性修饰符不能用于私有字段。</li><li id="1415" class="kz la it kd b ke lj ki lk km ll kq lm ku ln ky le lf lg lh bi translated">私有字段不能在包含类之外被访问，甚至不能被检测到——即使是JS用户！有时我们称这种硬<em class="nu"> </em>为隐私。</li></ul><h1 id="3610" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">6.类别表达式</h1><p id="5d34" class="pw-post-body-paragraph kb kc it kd b ke my kg kh ki mz kk kl km na ko kp kq nb ks kt ku nc kw kx ky im bi translated">TypeScript 1.6增加了对ES6类表达式的支持。类表达式是用于定义类的语法。像函数表达式一样，类表达式可以是命名的或匿名的。在命名类表达式的情况下，名称只能在类体中访问。</p><p id="294f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">类表达式的语法如下([]括号是可选的):</p><pre class="nh ni nj nk gt nl ng nm nn aw no bi"><span id="c1e8" class="mm lp it ng b gy np nq l nr ns">const MyClass = class [className] [extends] {<br/>  // class body<br/>};</span></pre><p id="552e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">基于类表达式的语法，我们可以定义一个点类:</p><pre class="nh ni nj nk gt nl ng nm nn aw no bi"><span id="50e8" class="mm lp it ng b gy np nq l nr ns">let Point = class {<br/>  constructor(public x: number, public y: number) {}<br/>  public length() {<br/>    return Math.sqrt(this.x * this.x + this.y * this.y);<br/>  }<br/>}</span><span id="9fa6" class="mm lp it ng b gy nt nq l nr ns">let p = new Point(3, 4);<br/>console.log(p.length()); // 5</span></pre><p id="c5a0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">注意，当使用类表达式定义类时，我们也可以使用<code class="fe nd ne nf ng b">extends</code>关键字。</p><h1 id="6a60" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">7.通用类</h1><p id="7b53" class="pw-post-body-paragraph kb kc it kd b ke my kg kh ki mz kk kl km na ko kp kq nb ks kt ku nc kw kx ky im bi translated">在类中使用泛型也非常简单。我们只需要在类名后使用语法<strong class="kd iu"> &lt; T、… &gt; </strong>来定义任意数量的类型参数。具体例子如下:</p><pre class="nh ni nj nk gt nl ng nm nn aw no bi"><span id="ec5b" class="mm lp it ng b gy np nq l nr ns">class Person&lt;T&gt; {<br/>  constructor(<br/>    public cid: T, <br/>    public name: string<br/>  ) {}   <br/>}</span><span id="aa62" class="mm lp it ng b gy nt nq l nr ns">let p1 = new Person&lt;number&gt;(28, "Lolo");<br/>let p2 = new Person&lt;string&gt;("eft", "Bytefer");</span></pre><p id="eae7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">接下来，我们以实例化p1为例来分析其处理过程:</p><ul class=""><li id="567f" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated">在实例化Person对象时，我们传入数字类型和相应的构造参数；</li><li id="219f" class="kz la it kd b ke lj ki lk km ll kq lm ku ln ky le lf lg lh bi translated">然后在Person类中，类型参数T的值变成了number type</li><li id="34dd" class="kz la it kd b ke lj ki lk km ll kq lm ku ln ky le lf lg lh bi translated">最后，构造函数cid的参数类型也会变成数字类型。</li></ul><p id="e617" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">那么我们什么时候需要使用泛型呢？通常，在决定是否使用泛型时，我们有以下两个参考标准</p><ul class=""><li id="c47f" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated">当您的函数、接口或类将处理多种数据类型时；</li><li id="dc3b" class="kz la it kd b ke lj ki lk km ll kq lm ku ln ky le lf lg lh bi translated">当函数、接口或类在多个地方使用该数据类型时。</li></ul><p id="0f19" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你不理解类型参数，我建议你阅读下面的文章:</p><div class="nv nw gp gr nx ny"><a href="https://medium.com/frontend-canteen/what-are-k-t-and-v-in-typescript-generics-9fabe1d0f0f3" rel="noopener follow" target="_blank"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd iu gy z fp od fr fs oe fu fw is bi translated">TypeScript泛型中的K，T，V是什么？</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">用动画讲解，让你轻松掌握TypeScript泛型类型参数。</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">medium.com</p></div></div><div class="oh l"><div class="oi l oj ok ol oh om jz ny"/></div></div></a></div><h1 id="c3f4" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">8.构建签名</h1><p id="6a9a" class="pw-post-body-paragraph kb kc it kd b ke my kg kh ki mz kk kl km na ko kp kq nb ks kt ku nc kw kx ky im bi translated">定义TypeScript接口时，可以使用new关键字来描述构造函数:</p><pre class="nh ni nj nk gt nl ng nm nn aw no bi"><span id="1ee9" class="mm lp it ng b gy np nq l nr ns">interface Point {<br/>  new (x: number, y: number): Point;<br/>}</span></pre><p id="e13e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">上面接口中的<strong class="kd iu"> new (x: number，y: number) </strong>称为构造签名，其语法如下:</p><pre class="nh ni nj nk gt nl ng nm nn aw no bi"><span id="4939" class="mm lp it ng b gy np nq l nr ns">ConstructSignature: new TypeParametersopt ( ParameterListopt ) TypeAnnotationopt</span></pre><p id="f971" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在上述构造签名中，TypeParametersopt、ParameterListopt和TypeAnnotationopt分别表示可选类型参数、可选参数列表和可选类型注释。那么知道构造签名有什么用呢？这里我们举一个例子:</p><pre class="nh ni nj nk gt nl ng nm nn aw no bi"><span id="d8c6" class="mm lp it ng b gy np nq l nr ns">interface Point {<br/>  new (x: number, y: number): Point;<br/>  x: number;<br/>  y: number;<br/>}</span><span id="9436" class="mm lp it ng b gy nt nq l nr ns">class Point2D implements Point {<br/>  readonly x: number;<br/>  readonly y: number;</span><span id="fb9d" class="mm lp it ng b gy nt nq l nr ns">constructor(x: number, y: number) {<br/>    this.x = x;<br/>    this.y = y;<br/>  }<br/>}</span><span id="eb9e" class="mm lp it ng b gy nt nq l nr ns">const point: Point = new Point2D(1, 2); // Error</span></pre><p id="7ce2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于上述代码，TypeScript编译器将提示以下错误信息:</p><pre class="nh ni nj nk gt nl ng nm nn aw no bi"><span id="a023" class="mm lp it ng b gy np nq l nr ns">Type 'Point2D' is not assignable to type 'Point'.<br/> Type 'Point2D' provides no match for the signature 'new (x: number, y: number): Point'.ts(2322)</span></pre><p id="e06c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了解决这个问题，我们需要重构前面定义的点接口:</p><pre class="nh ni nj nk gt nl ng nm nn aw no bi"><span id="d1a8" class="mm lp it ng b gy np nq l nr ns">interface Point {<br/>  x: number;<br/>  y: number;<br/>}</span><span id="8c20" class="mm lp it ng b gy nt nq l nr ns">interface PointConstructor {<br/>  new (x: number, y: number): Point;<br/>}</span></pre><p id="35a0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">完成接口重构后，除了之前定义的Point2D类，我们还定义了一个<code class="fe nd ne nf ng b">newPoint</code>工厂函数，用来根据传入的<strong class="kd iu"> PointConstructor </strong>类型的构造函数创建对应的Point对象。</p><pre class="nh ni nj nk gt nl ng nm nn aw no bi"><span id="8b77" class="mm lp it ng b gy np nq l nr ns">class Point2D implements Point {<br/>  readonly x: number;<br/>  readonly y: number;</span><span id="133d" class="mm lp it ng b gy nt nq l nr ns">  constructor(x: number, y: number) {<br/>    this.x = x;<br/>    this.y = y;<br/>  }<br/>}</span><span id="0b32" class="mm lp it ng b gy nt nq l nr ns">function newPoint(<br/>  pointConstructor: PointConstructor,<br/>  x: number,<br/>  y: number<br/>): Point {<br/>  return new pointConstructor(x, y);<br/>}</span><span id="89d3" class="mm lp it ng b gy nt nq l nr ns">const point: Point = newPoint(Point2D, 3, 4);</span></pre><h1 id="2213" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">9.抽象构造签名</h1><p id="1899" class="pw-post-body-paragraph kb kc it kd b ke my kg kh ki mz kk kl km na ko kp kq nb ks kt ku nc kw kx ky im bi translated">TypeScript 4.2中引入了抽象构造签名来解决以下问题:</p><pre class="nh ni nj nk gt nl ng nm nn aw no bi"><span id="016b" class="mm lp it ng b gy np nq l nr ns">type Constructor = new (...args: any[]) =&gt; any;</span><span id="9a50" class="mm lp it ng b gy nt nq l nr ns">abstract class Shape {<br/>  abstract getArea(): number;<br/>}</span><span id="4e9f" class="mm lp it ng b gy nt nq l nr ns">let Ctor: Constructor = Shape; // Error<br/>// Type 'typeof Shape' is not assignable to type 'Constructor'.<br/>//  Cannot assign an abstract constructor type to a non-abstract <br/>// constructor type.ts(2322)</span></pre><p id="6764" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">从上面的错误消息中可以看出，我们不能将抽象构造函数类型赋给非抽象构造函数类型。要修复这个错误，我们需要使用抽象构造签名:</p><pre class="nh ni nj nk gt nl ng nm nn aw no bi"><span id="6cf8" class="mm lp it ng b gy np nq l nr ns">type AbstractConstructor = abstract new (...args: any[]) =&gt; any;</span><span id="82c1" class="mm lp it ng b gy nt nq l nr ns">abstract class Shape {<br/>  abstract getArea(): number;<br/>}</span><span id="5054" class="mm lp it ng b gy nt nq l nr ns">let Ctor: AbstractConstructor = Shape; // Ok</span></pre><p id="26c4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">之后，我们可以创建一个makeSubclassWithArea函数来创建Shape类的子类:</p><pre class="nh ni nj nk gt nl ng nm nn aw no bi"><span id="d850" class="mm lp it ng b gy np nq l nr ns">function makeSubclassWithArea(Ctor: AbstractConstructor) {<br/>  return class extends Ctor {<br/>    #sideLength: number;<br/>    constructor(sideLength: number) {<br/>      super();<br/>      this.#sideLength = sideLength;<br/>    }</span><span id="8f9c" class="mm lp it ng b gy nt nq l nr ns">    getArea() {<br/>      return this.#sideLength ** 2;<br/>    }<br/>  };<br/>}</span><span id="8b5a" class="mm lp it ng b gy nt nq l nr ns">let Square = makeSubclassWithArea(Shape);</span></pre><p id="e29f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果非抽象构造函数类型本来是可以赋值的，那么它们也可以赋值给抽象构造函数类型。</p><pre class="nh ni nj nk gt nl ng nm nn aw no bi"><span id="07f5" class="mm lp it ng b gy np nq l nr ns">abstract class Shape {<br/>  abstract getArea(): number;<br/>}</span><span id="1e47" class="mm lp it ng b gy nt nq l nr ns">class Square extends Shape {<br/>  #sideLength: number;</span><span id="1a9f" class="mm lp it ng b gy nt nq l nr ns">  constructor(sideLength: number) {<br/>    super();<br/>    this.#sideLength = sideLength;<br/>  }</span><span id="aeb1" class="mm lp it ng b gy nt nq l nr ns">  getArea() {<br/>    return this.#sideLength ** 2;<br/>  }<br/>}</span><span id="8bdf" class="mm lp it ng b gy nt nq l nr ns">let Ctor: AbstractConstructor = Shape; // Ok<br/>let Ctor1: AbstractConstructor = Square; // Ok</span></pre><p id="7615" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在介绍了抽象构造签名之后，让我们以简单介绍类类型和类类型的类型之间的区别来结束。</p><h1 id="ebb1" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">10.类类型和类类型的类型</h1><figure class="nh ni nj nk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/bae00e6cc5182556747a1ad4dbb29459.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WHbuIKF6CzN7o5g8Xy-i2g.jpeg"/></div></div></figure><p id="eacb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">基于以上结果，我们可以得出以下结论。</p><ul class=""><li id="3573" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated">当使用<code class="fe nd ne nf ng b">Person</code>类作为类型时，可以将变量的值约束为Person类的实例；</li><li id="f5b4" class="kz la it kd b ke lj ki lk km ll kq lm ku ln ky le lf lg lh bi translated">当使用<code class="fe nd ne nf ng b">typeof Person</code>作为类型时，您可以约束变量的值以包含类中的静态属性和方法。</li></ul><p id="693c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">另外需要注意的是，TypeScript使用的是结构化类型系统，与Java/C++使用的标称类型系统不同，所以下面的代码可以在TypeScript中正常工作:</p><pre class="nh ni nj nk gt nl ng nm nn aw no bi"><span id="1dd1" class="mm lp it ng b gy np nq l nr ns">class Person {<br/>  constructor(public name: string) {}  <br/>}<br/><br/>class SuperMan {<br/>  constructor(public name: string) {}  <br/>}<br/><br/>let s1: SuperMan = new Person("Bytefer"); <em class="nu">// Ok</em></span></pre><p id="d4ba" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">好了，这里介绍一下TypeScript类的比较常见的知识。如果遇到不清楚的内容，可以给我留言。</p><p id="ee49" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你喜欢学习动画形式的打字稿，可以在<a class="ae li" href="https://medium.com/@bytefer" rel="noopener">中</a>或者<a class="ae li" href="https://twitter.com/Tbytefer" rel="noopener ugc nofollow" target="_blank">推特</a>关注我，了解更多关于TS和JS的内容！</p><h1 id="d8cb" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">资源</h1><div class="nv nw gp gr nx"><div role="button" tabindex="0" class="ab bv gv cb fp on oo bn op jz ex"><div class="oq l"><div class="ab q"><div class="l di"><img alt="Bytefer" class="l de bw or os fe" src="../Images/238cf2afd3c689b50719951ba2fd880d.png" width="20" height="20" loading="lazy" data-original-src="https://miro.medium.com/v2/resize:fill:40:40/1*krjVh9VFhDEcMUif4Ewt-A.png"/><div class="fb bw l or os fc n aw fd"/></div><div class="hh l fo"><p class="bd b dl z fp fq fr fs ft fu fv fw dk translated"><a class="ae af ag ah ai aj ak al am an ao ap aq ar as" href="https://medium.com/@bytefer?source=post_page-----f58c57869266--------------------------------" rel="noopener follow" target="_top"> Bytefer </a></p></div></div><div class="ov ow gw l"><h2 class="bd iu uk kz fp ul fr fs oe fu fw is bi translated">掌握打字稿系列</h2></div><div class="ab q"><div class="l fo"><a class="bd b be z bi um au un uo up rb uq an eh ei ur us ut el em eo de bk ep" href="https://medium.com/@bytefer/list/mastering-typescript-series-688ee7c12807?source=post_page-----f58c57869266--------------------------------" rel="noopener follow" target="_top">View list</a></div><div class="uu l fo"><span class="bd b dl z dk">46 stories</span></div></div></div><div class="pi dh pj fp ab pk fo di"><div class="di pa bv pb pc"><div class="dh l"><img alt="" class="dh" src="../Images/373c978fed504a3c38f0fdb5b617fedb.png" width="194" height="194" loading="lazy" role="presentation" data-original-src="https://miro.medium.com/v2/resize:fill:388:388/0*94uN4q2Of_fg3WaQ"/></div></div><div class="di pa bv pd pe pf"><div class="dh l"><img alt="" class="dh" src="../Images/a8ea3e3ecad1c2d2697107f3ce466e42.png" width="194" height="194" loading="lazy" role="presentation" data-original-src="https://miro.medium.com/v2/resize:fill:388:388/0*tGza_iE2o--HjQwD"/></div></div><div class="di bv pg ph pf"><div class="dh l"><img alt="" class="dh" src="../Images/3bcc671d9b1ca5776fec258eed5450d4.png" width="194" height="194" loading="lazy" role="presentation" data-original-src="https://miro.medium.com/v2/resize:fill:388:388/0*_U9uNpcZaTLX4u4B"/></div></div></div></div></div><div class="nv nw gp gr nx ny"><a href="https://www.typescriptlang.org/docs/handbook/2/classes.html" rel="noopener  ugc nofollow" target="_blank"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd iu gy z fp od fr fs oe fu fw is bi translated">文档-类别</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">类如何在TypeScript中工作</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">www.typescriptlang.org</p></div></div><div class="oh l"><div class="po l oj ok ol oh om jz ny"/></div></div></a></div></div><div class="ab cl pp pq hx pr" role="separator"><span class="ps bw bk pt pu pv"/><span class="ps bw bk pt pu pv"/><span class="ps bw bk pt pu"/></div><div class="im in io ip iq"><h1 id="b8e5" class="lo lp it bd lq lr pw lt lu lv px lx ly lz py mb mc md pz mf mg mh qa mj mk ml bi translated">分级编码</h1><p id="7d06" class="pw-post-body-paragraph kb kc it kd b ke my kg kh ki mz kk kl km na ko kp kq nb ks kt ku nc kw kx ky im bi translated">感谢您成为我们社区的一员！在你离开之前:</p><ul class=""><li id="ed90" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated">👏为故事鼓掌，跟着作者走👉</li><li id="324c" class="kz la it kd b ke lj ki lk km ll kq lm ku ln ky le lf lg lh bi translated">📰查看<a class="ae li" href="https://levelup.gitconnected.com/?utm_source=pub&amp;utm_medium=post" rel="noopener ugc nofollow" target="_blank">升级编码出版物</a>中的更多内容</li><li id="86b9" class="kz la it kd b ke lj ki lk km ll kq lm ku ln ky le lf lg lh bi translated">🔔关注我们:<a class="ae li" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">Twitter</a>|<a class="ae li" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>|<a class="ae li" href="https://newsletter.levelup.dev" rel="noopener ugc nofollow" target="_blank">时事通讯</a></li></ul><p id="6fa4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">🚀👉<a class="ae li" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="kd iu">加入升级人才集体，找到一份神奇的工作</strong> </a></p></div></div>    
</body>
</html>