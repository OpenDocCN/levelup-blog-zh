<html>
<head>
<title>Why Iterators in Rust are Really Cool, and How You Can Use Them Better</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么Rust中的迭代器很酷，以及如何更好地使用它们</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/iterators-in-rust-what-does-lazy-really-mean-6e33e06cf0fb?source=collection_archive---------1-----------------------#2020-11-28">https://levelup.gitconnected.com/iterators-in-rust-what-does-lazy-really-mean-6e33e06cf0fb?source=collection_archive---------1-----------------------#2020-11-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/a37b7af30cec323fcba476c7aae30740.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*QPvvdKKhc8aBD1NUkXY37w.jpeg"/></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">元素链接上生锈的迭代器…懂了吗？</figcaption></figure><p id="3ac8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在普通JavaScript中，对列表执行过滤，然后记录每个元素需要<code class="fe kz la lb lc b">O(2n)</code>。在Rust中，需要<code class="fe kz la lb lc b">O(n)</code>。下面是原因，以及Rust迭代器的其他一些很酷的东西。</p></div><div class="ab cl ld le hx lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="im in io ip iq"><p id="d032" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们经常听说Rust迭代器很懒，但我从来没有真正明白这是什么意思，直到我不得不用Rust和JavaScript(技术上是TypeScript，但仍然是)过滤列表。</p><p id="1dc9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在JavaScript中，列表过滤器如下所示:</p><pre class="ll lm ln lo gt lp lc lq lr aw ls bi"><span id="6a0f" class="lt lu it lc b gy lv lw l lx ly">myList.filter((t) =&gt; t !== "Filter me out")</span></pre><p id="1b4e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后要记录每个元素，您应该像这样链接它:</p><pre class="ll lm ln lo gt lp lc lq lr aw ls bi"><span id="3b4a" class="lt lu it lc b gy lv lw l lx ly">myList.filter((t) =&gt; t !== "Filter me out").forEach(console.log)</span></pre><p id="54aa" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">幕后发生的是<code class="fe kz la lb lc b">filter</code>函数将遍历列表，返回每个不符合条件的元素。在这种情况下，它会过滤掉所有没有说“过滤掉我”的字符串。然后，它将通过一个<em class="lk">新的</em>列表重复并记录它们中的每一个。</p><p id="98b7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">修复它使其成为<code class="fe kz la lb lc b">O(n)</code>是很简单的:</p><pre class="ll lm ln lo gt lp lc lq lr aw ls bi"><span id="8061" class="lt lu it lc b gy lv lw l lx ly">myList.forEach((t) {if (t!== "Filter me out") console.log(t)})</span></pre><p id="b4f2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但那看起来不干净。</p><p id="fcb3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在Rust中，你已经使用类似于第一种方法将<code class="fe kz la lb lc b">O(n)</code>开箱。</p><pre class="ll lm ln lo gt lp lc lq lr aw ls bi"><span id="6038" class="lt lu it lc b gy lv lw l lx ly">myList<br/>.into_iter()<br/>.filter(|v| v != "Filter me out")<br/>.for_each(|v| println!("{}", v))</span></pre><p id="eba4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">那么，这里的魔力在哪里呢？</p><p id="bb8d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Rust迭代器是<em class="lk">懒惰的，</em>这意味着它们直到被告知才执行。这意味着您可以在迭代器上添加任何一系列操作，直到您使用它，它才会“运行”。这意味着当我们在迭代器上调用<code class="fe kz la lb lc b">for_each</code>时，它消耗迭代器，但只获得通过过滤器的元素。</p><p id="b69a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这很有用，因为现在，我们可以用迭代器以函数的方式做任何事情。</p><pre class="ll lm ln lo gt lp lc lq lr aw ls bi"><span id="06e8" class="lt lu it lc b gy lv lw l lx ly">myList<br/>.into_iter()<br/>.filter(..) //one filter<br/>.filter(..) // two filter<br/>.map(..) //map <br/>.filter(..) //filter because why not<br/>.map(..) //map again... who's writing this code???<br/>.cloned(..) //for the hell of it, we clone ever element</span></pre><p id="1391" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">上面的例子在现实世界中并不实用(因为你为什么需要映射x 2和过滤x 3？)，但它是有效的Rust代码…除此之外，它没有做任何事情。</p><p id="fb75" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你在末尾加上分号，那么你除了销毁<code class="fe kz la lb lc b">myList</code>之外什么也没做(因为我们用了<code class="fe kz la lb lc b">into_iter.</code>如果我们用了<code class="fe kz la lb lc b">iter</code>我们什么也没做，就这样。).我们需要消耗迭代器，用消耗迭代器的东西。</p><p id="87ad" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这种情况下，它可能是一个<code class="fe kz la lb lc b">for_each</code>，但是您可以做很多事情。也许你想要一个<code class="fe kz la lb lc b">.sum</code>，或者<code class="fe kz la lb lc b">.collect</code>把它转换成另一个向量，或者也许是<code class="fe kz la lb lc b">.sort</code>？这些都会消耗迭代器，一旦消耗完，就完成了。</p><p id="45ad" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个设计非常聪明，因为它让我们的代码更具可读性。我们不需要像在JS中那样将每个操作放在同一个闭包中，如果我们想的话，我们可以在执行之前通过存储迭代器来有条件地添加过滤器。</p><p id="5967" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里有一个操作列表，你<em class="lk">可以</em>在迭代器中使用这些操作，以使你的代码更具功能性和可读性:</p><ul class=""><li id="5225" class="lz ma it kd b ke kf ki kj km mb kq mc ku md ky me mf mg mh bi translated">将迭代器缩减到它的第一个<code class="fe kz la lb lc b">n</code>元素</li><li id="d035" class="lz ma it kd b ke mi ki mj km mk kq ml ku mm ky me mf mg mh bi translated"><code class="fe kz la lb lc b">.skip(n)</code>跳过第一个<code class="fe kz la lb lc b">n</code>元素</li><li id="ee0e" class="lz ma it kd b ke mi ki mj km mk kq ml ku mm ky me mf mg mh bi translated"><code class="fe kz la lb lc b">.cloned()</code>克隆迭代器中的每个元素</li><li id="1d71" class="lz ma it kd b ke mi ki mj km mk kq ml ku mm ky me mf mg mh bi translated"><code class="fe kz la lb lc b">.enumerate</code>将元素<code class="fe kz la lb lc b">t</code>上的迭代器转换为元素<code class="fe kz la lb lc b">(t, i)</code>上的迭代器，其中<code class="fe kz la lb lc b">i</code>是元素的索引。这个有用，我用的很多:)</li><li id="9859" class="lz ma it kd b ke mi ki mj km mk kq ml ku mm ky me mf mg mh bi translated"><code class="fe kz la lb lc b">.cycle</code>无限循环迭代器。</li><li id="5fdc" class="lz ma it kd b ke mi ki mj km mk kq ml ku mm ky me mf mg mh bi translated"><code class="fe kz la lb lc b">.rev</code>反转一个迭代器。</li></ul><p id="7960" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在文档中还有很多很多。我只挑选了6个最常用/最有用的，但是如果你曾经在<code class="fe kz la lb lc b">map</code>或<code class="fe kz la lb lc b">for_each</code>中写了太多的逻辑，你可能想在我开始迭代之前后退一步，想想什么可以被应用。</p></div></div>    
</body>
</html>