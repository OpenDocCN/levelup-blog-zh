<html>
<head>
<title>Look At This Photograph</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">看这张照片</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/look-at-this-photograph-9713d43f79ac?source=collection_archive---------14-----------------------#2020-04-06">https://levelup.gitconnected.com/look-at-this-photograph-9713d43f79ac?source=collection_archive---------14-----------------------#2020-04-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0e70" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Javascript图像处理入门</h2></div><p id="3b7e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本教程中，我将介绍在浏览器中显示图像。很简单，只需使用一个图像标签。</p><p id="9858" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">&lt;img src="https://source.unsplash.com/user/cizikas/HfVsqRXkUmc" alt=”A Giraffe"&gt;</code></p><p id="e999" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">教程结束…</p><p id="85df" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是等等。我们对这幅图像无能为力。我们不能应用自定义滤镜让Instagram嫉妒。我们也不能为了在照片上画假胡子而检测人脸。为了做到这些，我们需要访问组成图像的所有位和字节。我们将使用HTML画布和一个名为GPU.js的库在计算机的图形处理单元(通常称为GPU)上运行我们的算法。</p><h1 id="99ee" class="li lj it bd lk ll lm ln lo lp lq lr ls jz lt ka lu kc lv kd lw kf lx kg ly lz bi translated">为什么选择GPU？</h1><p id="e939" class="pw-post-body-paragraph ki kj it kk b kl ma ju kn ko mb jx kq kr mc kt ku kv md kx ky kz me lb lc ld im bi translated">图像是由像素组成的，而且通常是很多像素。许多图像处理算法将在每个像素上运行一些过程，以产生该像素的新值。我们当然可以一个接一个地在每个像素上运行这个过程，这对于小图像来说可以很好地工作，但是随着图像大小的增长，处理时间也会增长。如果我们需要实时处理，比如在视频流上，这可能会特别糟糕。</p><p id="9e8f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不是一次在一个像素上运行一个过程，而是在许多像素上同时运行该过程，也称为并行<em class="mf"/>。这就是构建GPU的目的。然而，Javascript并不是这样设计的。它一次只能做一件事。需要用另一种语言<a class="ae mg" href="https://en.wikipedia.org/wiki/OpenGL_Shading_Language" rel="noopener ugc nofollow" target="_blank"> GLSL </a>告诉GPU做什么。</p><p id="2996" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这就是GPU.js的用武之地。它允许我们编写常规的(几乎)javascript函数，并将它们编译成GLSL，而不是学习另一种编程语言。让我们看一个简单的例子。</p><figure class="mh mi mj mk gt ml"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="1d48" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们从导入和实例化GPU.js库开始。</p><p id="8c05" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">createKernel</code>方法采用一个将被编译以在GPU上运行的函数和一个选项对象。<code class="fe le lf lg lh b">output</code>选项决定了将运行多少个并行<em class="mf">线程</em>以及返回数组的大小。在这种情况下，我们有一个二维的5x4内核。<code class="fe le lf lg lh b">this.thread</code>属性用于确定函数在哪个线程上执行。我们稍后将使用它来访问图像的像素。这个内核的输出如下所示…</p><pre class="mh mi mj mk gt mo lh mp mq aw mr bi"><span id="8c8e" class="ms lj it lh b gy mt mu l mv mw">[[[0, 0], [0, 1], [0, 2], [0, 3], [0, 4]],<br/> [[1, 0], [1, 1], [1, 2], [1, 3], [1, 4]],<br/> [[2, 0], [2, 1], [2, 2], [2, 3], [2, 4]],<br/> [[3, 0], [3, 1], [3, 2], [3, 3], [3, 4]]]</span></pre><p id="c342" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意:使用<code class="fe le lf lg lh b">function() {}</code>语法而不是箭头语法很重要，因为我们需要访问内核的<code class="fe le lf lg lh b">this</code>上下文。</p><h1 id="76bd" class="li lj it bd lk ll lm ln lo lp lq lr ls jz lt ka lu kc lv kd lw kf lx kg ly lz bi translated">显示图像</h1><p id="b599" class="pw-post-body-paragraph ki kj it kk b kl ma ju kn ko mb jx kq kr mc kt ku kv md kx ky kz me lb lc ld im bi translated">现在，随着对如何在GPU上运行函数的理解，我们可以开始使用它来处理图像。GPU.js让这变得简单。HTMLImageElement的实例可以直接传递给内核，GPU.js将知道如何处理它，将其转换为二维像素数组。一个像素包含四个<em class="mf">通道</em>数据——红色、绿色、蓝色和alpha——每个通道用0到1之间的数字表示。值为0表示通道中没有任何颜色，值为1表示最大颜色量。alpha通道表示像素的透明度。使用x和y坐标，我们可以访问图像的像素。让我们加载一个图像并进行测试。</p><figure class="mh mi mj mk gt ml"><div class="bz fp l di"><div class="mm mn l"/></div></figure><pre class="mh mi mj mk gt mo lh mp mq aw mr bi"><span id="134e" class="ms lj it lh b gy mt mu l mv mw">const image = await loadImage('https://source.unsplash.com/random')</span></pre><p id="7a9d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还想创建一个画布来显示图像。</p><pre class="mh mi mj mk gt mo lh mp mq aw mr bi"><span id="6d4a" class="ms lj it lh b gy mt mu l mv mw">const canvas = document.createElement('canvas')<br/>canvas.width = image.width;<br/>canvas.height = image.height;<br/>canvas.style = 'max-width: 66vw; max-height: 66vh;'<br/>document.body.appendChild(canvas)</span></pre><p id="2827" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在创建一个新的GPU实例。我们将把刚刚创建的画布给它，这样它就知道在哪里渲染了。</p><figure class="mh mi mj mk gt ml"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="8ed2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">GPU需要知道它将绘制到画布上，而不仅仅是进行数值计算，所以我们将<code class="fe le lf lg lh b">graphical</code>选项设置为<code class="fe le lf lg lh b">true</code>。我们用内核的x和y坐标得到像素值。请注意，图像的第一个坐标是y轴，第二个是x轴。坐标<code class="fe le lf lg lh b">y=0, x=0</code>也在图像的左下方，而<code class="fe le lf lg lh b">y=height-1, x=width-1</code>在图像的右上方。根据您可能熟悉的其他绘图API，这可能看起来有些倒退。内核的<code class="fe le lf lg lh b">color</code>方法获取0到1范围内的红色、绿色、蓝色和可选的alpha通道，并将该像素设置在<code class="fe le lf lg lh b">this.thread.x, this.thread.y</code>位置。在这个内核中没有对像素数据进行任何更改——它们只是从图像中取出并绘制到画布上。</p><p id="63ba" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在运行内核，画布中应该有一个图像。</p><pre class="mh mi mj mk gt mo lh mp mq aw mr bi"><span id="4046" class="ms lj it lh b gy mt mu l mv mw">kernel(image)</span></pre><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi mx"><img src="../Images/cf98dc132dc5d01b2df762dd5fa70f59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*reX9IAQtrj4r8hxR"/></div></div><figcaption class="ne nf gj gh gi ng nh bd b be z dk translated">照片由<a class="ae mg" href="https://unsplash.com/@cizikas?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Aidas Ciziunas </a>在<a class="ae mg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="5086" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们的GPU出了一只长颈鹿。</p><h2 id="ed94" class="ms lj it bd lk ni nj dn lo nk nl dp ls kr nm nn lu kv no np lw kz nq nr ly ns bi translated">一个更有趣的例子</h2><p id="4ece" class="pw-post-body-paragraph ki kj it kk b kl ma ju kn ko mb jx kq kr mc kt ku kv md kx ky kz me lb lc ld im bi translated">当然，我们不会为了显示图像而在GPU上处理图像。这里是另一个例子，旨在显示通道如何组合产生原始颜色。下图有七个部分。左下角仅显示红色通道，左上角仅显示绿色通道，右栏仅显示蓝色通道。其他部分显示了相邻部分的重叠。举个例子，左中显示的是红色和绿色通道的组合。在中间，我们有所有三个通道，它们结合起来给我们图像的原始颜色。</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi nt"><img src="../Images/f5110aab4b0e6ed9baecd2e144d6576d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XNmDqfKz8eK0PBJ_KuJsvQ.png"/></div></div></figure><p id="6b79" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是生成上面图像的内核。</p><figure class="mh mi mj mk gt ml"><div class="bz fp l di"><div class="mm mn l"/></div></figure></div><div class="ab cl nu nv hx nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="im in io ip iq"><p id="a660" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在去实验一下，看看你能做出什么有趣的内核。</p><h2 id="5e98" class="ms lj it bd lk ni nj dn lo nk nl dp ls kr nm nn lu kv no np lw kz nq nr ly ns bi translated">更多关于Javascript中图像处理的文章</h2><p id="10df" class="pw-post-body-paragraph ki kj it kk b kl ma ju kn ko mb jx kq kr mc kt ku kv md kx ky kz me lb lc ld im bi translated"><a class="ae mg" href="https://medium.com/@srmullen13/notorious-rgb-756f19f3e462" rel="noopener">臭名昭著的RGB——Javascript中的颜色模型</a></p></div></div>    
</body>
</html>