# 按值传递与按引用传递|高级 JavaScript 系列

> 原文：<https://levelup.gitconnected.com/pass-by-value-vs-pass-by-reference-advance-javascript-series-f579ce75e7f8>

![](img/84dc0fabde8ee31147a4cacaa34614b9.png)

在这篇文章中，我们将看看 JavaScript 中通过值传递和通过引用传递的区别。

# 0.关于这个问题的个人观点

这些概念在 JavaScript 创建之前很久就被定义了，因此不能充分代表 JavaScript 的语义。但是，如果您仍然想将它们应用于 JavaScript，我将尝试从 JavaScript 的角度解释这些概念。

# 1.一些定义

**变量:**有多种含义的符号，指代内存中特定位置的值。在大多数情况下，当处理具体问题时，这个短语过于沉重，不能单独使用。

**值:**存储在内存中的特定位，由变量的符号引用。

**内存位置:**内存中保存变量值的地方。

**被调用者和调用者:**被调用者是被另一个函数调用过的函数，而调用者是调用另一个函数的函数(被调用者)。

**形参:**形参是函数被调用时收到的预置值。

**实际参数:**实际参数是函数调用中提供的值。

> **一些注意事项:**
> 
> 变量是值的指针。
> 
> 重新分配变量只会改变引用的值。
> 
> 因为每个变量都有自己的指针，重新分配一个变量对指向同一个对象的其他变量没有影响。

# 2.什么是按值传递？

术语“按值传递”是指创建实参数值的内存副本。例如，调用者和被调用者有两个值相同的独立变量。被调用方更改参数值的结果对于调用方来说并不明显。如果您没有理解定义，请不要担心，我会用一个代码示例来解释它。

# 3.什么是按引用传递？

术语“按引用传递”是指将调用函数中的参数引用传递给被调用函数的相应形参。使用中给出的引用，被调用的函数可以更改参数的值。同样，如果您没有理解定义，请不要担心，我将在本文稍后给出代码示例。

# 4.JavaScript 是按值传递还是按引用传递？

JavaScript 中有函数和参数，我们把它们输入到这些函数中。然而，JavaScript 如何处理您提交的数据并不总是显而易见的。在 JavaScript 中，对于任何变量都没有“通过引用传递”这样的东西。所有的变量和参数都有一个值，但是对象变量的值是一个引用。因此，如果您提供一个对象并在方法内部改变其成员，这些更改将保留在函数之外。这使得它看起来像是一个按引用传递的系统。像整数、字符串和布尔值这样的基元值是由值提供的，但是如前所述，对象和数组是通过引用传递的。

# 5.JavaScript 按值传递示例

假设您定义了 2 个整数(*原始数据类型*)变量。

```
var num1 = 1;
var num2 = 2;
```

那么，假设你定义了一个第三整数， ***num3，*** ，并给它赋值 ***num1*** 。然后做一个 ***console.log*** 的 ***num3*** 和 ***num1。*** 之后你做同样的事情通过分配 ***num2*** 到 ***num3。***

```
var num3 = num1;
console.log(num1); //outputs 1
console.log(num3); //also outputs 1num3 = num2;
console.log(num1); //outputs 2
console.log(num2); //also 2
```

因此，在这个代码示例中，*num 1 和 ***num2*** 没有任何变化，因为我们只是将它们赋给了另一个变量 ***num3*** ，换句话说，我们将它们的值传递给了 ***num3*** 和***num3*** num 3 现在在内存中有了新的指针值，这与 num 3【T4 让我们深入探讨一下。现在，我们将再次将 ***num1*** 赋值为 ***num3*** 并再次更改 ***num3*** 和 ***console.log*** 的值。*

```
*num3 = num1;
num3 = 3;
console.log(num1); //outputs 1
console.log(num3); //outputs 3*
```

*所以，这里我们看到的是 ***num1*** 和 ***num3*** 的值是不同的，而我们之前只给 num 3*到 ***num1*** 赋值。这表明两个变量都指向内存中不同的值，因此改变其中一个变量的值不会对另一个变量产生任何影响。**

# **6.JavaScript 通过引用传递示例**

**假设您定义了两个对象:**

```
**var obj1 = {name: "Vəndam"};
var obj2 = {name: "Tofiy"};**
```

**那么，假设你定义了第三个对象， ***obj3*** ，并给它赋值 ***obj1*** 。然后对 ***obj3*** 和 ***obj1 都做一个 ***console.log*** 。将 ***obj2*** 分配给 ***obj3，做同样的事情。********

```
*var obj3 = obj1;
console.log(obj1); //outputs {name: "Vəndam"}
console.log(obj3); //also outputs {name: "Vəndam"}obj3 = obj2;
console.log(obj2); //outputs {name: "Tofiy"}
console.log(obj3); //also outputs {name: "Tofiy"}*
```

*因此，在这个代码示例中， ***obj1*** 和 ***obj2*** 没有任何变化，因为我们只是将它们赋给了另一个变量 ***obj3*** ，换句话说，我们将它们在内存中的引用传递给了 ***obj3*** 。让我们深入探讨一下。现在，我们将再次将 ***obj1*** 赋值给 ***obj3*** 并再次更改 ***obj3*** 和 ***console.log*** 的对象参数。*

```
*obj3 = obj1;
obj3.name = "Mürşüd";
console.log(obj1); //outputs {name: "Mürşüd"}
console.log(obj3); //also outputs {name: "Mürşüd"}*
```

*所以，这里我们看到 ***obj1*** 和 ***obj3*** 对象参数值都改变了，而我们只改变了 ***obj3.name*** 的值。这表明两个对象都指向内存中的同一个引用，因此改变其中一个对象的参数会反映到另一个对象中。*

# *7.结论*

*总之，在 JavaScript 中，所有的变量和参数都有一个给定的值，这意味着它们是通过值传递的(原始数据类型)，但是对象变量的值是一个引用，因此 JavaScript 中的复合类型是通过引用传递的。*