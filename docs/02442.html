<html>
<head>
<title>Working with JSON in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Swift中使用JSON</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/working-with-json-in-swift-c5faea0b19a1?source=collection_archive---------6-----------------------#2020-03-13">https://levelup.gitconnected.com/working-with-json-in-swift-c5faea0b19a1?source=collection_archive---------6-----------------------#2020-03-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/9dc3a3e0736a87c0b6804d3646e69830.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/1*26ma6oTi3og7c_8V9ehD_A.png"/></div></figure><p id="aaec" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">免责声明:在这一系列的帖子中，你将学习与JSON一起工作，而不是与JASON，来自<em class="ks">13日星期五</em>系列的邪恶角色一起工作。此外，自从Swift 4以来，与JSON一起工作已经成为一种乐趣……而JASON一直很刻薄。所以，放下你的曲棍球面具，开始编码吧！</p><blockquote class="kt ku kv"><p id="29b0" class="ju jv ks jw b jx jy jz ka kb kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kr ij bi translated">这个帖子最初是我在<a class="ae kz" href="https://www.leandrofournier.com/" rel="noopener ugc nofollow" target="_blank">Swift Delivery</a>:<a class="ae kz" href="https://www.leandrofournier.com/working-with-json-part-1/" rel="noopener ugc nofollow" target="_blank">Part 1</a>写的:介绍Codable、JSONDecoder和一个简单的例子。<a class="ae kz" href="https://www.leandrofournier.com/working-with-json-part-2/" rel="noopener ugc nofollow" target="_blank">第二部分</a>:使用自定义键和自定义对象。<a class="ae kz" href="https://www.leandrofournier.com/working-with-json-part-3/" rel="noopener ugc nofollow" target="_blank">第3部分</a>:处理数组和顶级实体案例。</p></blockquote><h1 id="e018" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">基础</h1><p id="e851" class="pw-post-body-paragraph ju jv iq jw b jx ly jz ka kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr ij bi translated">让我们假设您有以下JSON:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="8f45" class="mm lb iq mi b gy mn mo l mp mq">{<br/>	"productId": 1423,<br/>	"name": "Hockey Mask",<br/>	"color": "white",<br/>	"price": 39.90<br/>}</span></pre><p id="4add" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">您可能从一个API请求收到这个json响应，或者您读取了一个文件内容，它是一个. JSON文件。无论哪种方式，通常的情况是你最终拥有一个<code class="fe mr ms mt mi b">Data</code>类型。</p><p id="99c9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">首先，让我们创建一个包含我们的数据结构的<code class="fe mr ms mt mi b">Struct</code>:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="fad5" class="mm lb iq mi b gy mn mo l mp mq">struct Product: Codable {<br/>    let productId: Int<br/>    let name: String<br/>    let color: String?<br/>    let price: Float<br/>}</span></pre><p id="b517" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这里的关键词是<code class="fe mr ms mt mi b">Codable</code>，这是一个协议。实际上，它是一个<em class="ks">协议组合类型</em>，因为它包含两个协议:<code class="fe mr ms mt mi b">Encodable</code>和<code class="fe mr ms mt mi b">Decodable</code>。基本上，<code class="fe mr ms mt mi b">Encodable</code>让您将类型转换回外部表示(即<code class="fe mr ms mt mi b">Data</code>)，而<code class="fe mr ms mt mi b">Decodable</code>做相反的事情。</p><p id="1def" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在这个例子中，我们想要从<code class="fe mr ms mt mi b">Data</code>转换到<code class="fe mr ms mt mi b">Product</code>，我们可以只使用<code class="fe mr ms mt mi b">Decodable</code>。但是稍后我们可能想要反过来做(例如，将一些东西发送回API，将数据存储在<code class="fe mr ms mt mi b">UserDefaults</code>中，等等)。所以还是保持为<code class="fe mr ms mt mi b">Codable</code>吧。</p><p id="6910" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在，让我们将<code class="fe mr ms mt mi b">Data</code>转换为<code class="fe mr ms mt mi b">Product</code>:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="2f38" class="mm lb iq mi b gy mn mo l mp mq">let decoder = JSONDecoder()<br/>if let product = try? decoder.decode(Product.self, from: jsonData) {<br/>    print(product)<br/>}</span></pre><ol class=""><li id="471f" class="mu mv iq jw b jx jy kb kc kf mw kj mx kn my kr mz na nb nc bi translated">我们实例化了<code class="fe mr ms mt mi b">JSONDecoder</code>，它“<a class="ae kz" href="https://developer.apple.com/documentation/foundation/jsondecoder" rel="noopener ugc nofollow" target="_blank">从JSON对象</a>中解码出一个数据类型的实例”。</li><li id="23a2" class="mu mv iq jw b jx nd kb ne kf nf kj ng kn nh kr mz na nb nc bi translated">我们使用选项绑定(而不是强制解包)来解包结果或优雅地失败。你可以选择使用<code class="fe mr ms mt mi b">try</code>和<code class="fe mr ms mt mi b">catch</code>解码器可能抛出的错误。</li><li id="8e4f" class="mu mv iq jw b jx nd kb ne kf nf kj ng kn nh kr mz na nb nc bi translated">输出结果。</li></ol><p id="4833" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">以下是我们得到的结果:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="f1f8" class="mm lb iq mi b gy mn mo l mp mq">Product(productId: 1423, name: "Hockey Mask", color: Optional("white"), price: 39.9)</span></pre><h1 id="3dd3" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">自定义键</h1><p id="14e4" class="pw-post-body-paragraph ju jv iq jw b jx ly jz ka kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr ij bi translated">API通常使用蛇形大小写约定来命名键(this_is_snake_case)…甚至是kebab大小写(this-is-kebab-case)。Snake case不是一个非常敏捷的东西，因为它不符合命名准则。斯威夫特爱骆驼案(thisIsCamelCase)。所以如果你得到这样的结果:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="c5bf" class="mm lb iq mi b gy mn mo l mp mq">{<br/>    "product_id": 1423,<br/>    "name": "Hockey Mask",<br/>    "color-name": "white",<br/>    "price-key-to-piss-the-developer-off": 39.90<br/>}</span></pre><p id="4e49" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">镜像这些名称并不是一个好的做法，因此您应该更好地创建自定义键。像这样:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="1fa5" class="mm lb iq mi b gy mn mo l mp mq">struct Product: Codable {<br/>    let productId: Int<br/>    let name: String<br/>    let colorName: String?<br/>    let price: Float<br/>    <br/>    enum CodingKeys: String, CodingKey {<br/>          case productId = "product_id"<br/>          case name<br/>          case colorName = "color-name"<br/>          case price = "price-key-to-piss-the-developer-off"<br/>    }<br/>}</span></pre><ul class=""><li id="76eb" class="mu mv iq jw b jx jy kb kc kf mw kj mx kn my kr ni na nb nc bi translated"><strong class="jw ir">第2行到第5行。我们设置我们的对象属性名，因为它们最适合我们的需要。</strong></li><li id="1681" class="mu mv iq jw b jx nd kb ne kf nf kj ng kn nh kr ni na nb nc bi translated"><strong class="jw ir">第七行。</strong>这里的关键字是<code class="fe mr ms mt mi b">CodingKeys</code>，是一个<code class="fe mr ms mt mi b">Coding Key</code>枚举。它将每个属性连接到编码格式的值。</li><li id="ef55" class="mu mv iq jw b jx nd kb ne kf nf kj ng kn nh kr ni na nb nc bi translated"><strong class="jw ir">第八行到第十一行。</strong>对于每个属性，我们定义在编码格式中使用哪个键。</li></ul><p id="d9d6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">以下是输出结果:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="c33f" class="mm lb iq mi b gy mn mo l mp mq">Product(productId: 1423, name: "Hockey Mask", colorName: Optional("white"), price: 39.9)</span></pre><h1 id="6110" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">自定义对象</h1><p id="998f" class="pw-post-body-paragraph ju jv iq jw b jx ly jz ka kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr ij bi translated">假设我们有这个JSON:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="7569" class="mm lb iq mi b gy mn mo l mp mq">{<br/>    "productId": 1423,<br/>    "name": "Hockey Mask",<br/>    "color": "white",<br/>    "price": {<br/>        "price": 39.90,<br/>        "currency": "USD",<br/>        "formatted": "39.90 USD"<br/>    }<br/>}</span></pre><p id="c635" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这是一个非常常见的场景，幸运的是，<code class="fe mr ms mt mi b">Codable</code>协议让我们的生活变得非常简单:我们只需要创建一个符合<code class="fe mr ms mt mi b">Codable</code>协议的对象<code class="fe mr ms mt mi b">Price</code>，然后使用它作为我们的“价格”属性的类型:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="5c43" class="mm lb iq mi b gy mn mo l mp mq">struct Price: Codable {<br/>    let price: Float<br/>    let currency: String<br/>    let formatted: String<br/>}   <br/><br/>struct Product: Codable {<br/>    let productId: Int<br/>    let name: String<br/>    let color: String?<br/>    let price: Price?<br/>}</span></pre><p id="3b97" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">以下是输出结果:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="3dd9" class="mm lb iq mi b gy mn mo l mp mq">Product(productId: 1423, name: "Hockey Mask", color: Optional("white"), price: Optional(__lldb_expr_3.Price(price: 39.9, currency: "USD", formatted: "39.90 USD")))</span></pre><p id="4aaf" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如上所述，您也可以在自定义对象中使用自定义键。</p><h1 id="eb39" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">数组</h1><p id="f37d" class="pw-post-body-paragraph ju jv iq jw b jx ly jz ka kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr ij bi translated">在JSON中使用数组很容易。让我们举这个例子:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="48c8" class="mm lb iq mi b gy mn mo l mp mq">{<br/>   "productId":1423,<br/>   "name":"Hockey Mask",<br/>   "availableColors":[<br/>      "white",<br/>      "brown",<br/>      "black"<br/>   ],<br/>   "price":39.90<br/>}</span></pre><p id="0125" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe mr ms mt mi b">Product</code>对象将如下所示:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="1930" class="mm lb iq mi b gy mn mo l mp mq">struct Product: Codable {<br/>    let productId: Int<br/>    let name: String<br/>    let availableColors: [String]<br/>    let price: Float<br/>}</span></pre><p id="1e96" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">正如您在第4行中看到的，我们将属性<code class="fe mr ms mt mi b">availableColors</code>设置为一组<code class="fe mr ms mt mi b">String</code>对象。</p><p id="21b3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们举一个更复杂的例子:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="51e6" class="mm lb iq mi b gy mn mo l mp mq">{<br/>   "productId":1423,<br/>   "name":"Hockey Mask",<br/>   "availableColors":[<br/>      "white",<br/>      "brown",<br/>      "black"<br/>   ],<br/>   "price":39.90,<br/>   "stores":[<br/>      {<br/>         "name":"Gerry Cosby &amp; Co., Inc.",<br/>         "address":"11 Pennsylvania Plaza, New York, NY 10001, United States",<br/>         "phone":"+1 877-563-6464"<br/>      },<br/>      {<br/>         "name":"National Hockey League",<br/>         "address":"1185 6th Ave, New York, NY 10036, United States",<br/>         "phone":"+1 212-789-2000"<br/>      },<br/>      {<br/>         "name":"Modell's Sporting Goods",<br/>         "address":"234 W 42nd St, New York, NY 10036, United States",<br/>         "phone":"+1 212-764-7030"<br/>      }<br/>   ]<br/>}</span></pre><p id="1b02" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">有一个新领域:“商店”。首先，我们为此创建一个<code class="fe mr ms mt mi b">struct</code>:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="9784" class="mm lb iq mi b gy mn mo l mp mq">struct Store: Codable {<br/>    let name: String<br/>    let address: String<br/>    let phone: String?<br/>}</span></pre><p id="3d3e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">请注意，我们将<code class="fe mr ms mt mi b">phone</code>设置为可选的，因为我们假设API文档说明该字段可能不会出现在所有条目的响应中。</p><p id="39d2" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在让我们使用它:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="6677" class="mm lb iq mi b gy mn mo l mp mq">struct Product: Codable {<br/>    let productId: Int<br/>    let name: String<br/>    let availableColors: [String]<br/>    let price: Float<br/>    let stores: [Store]<br/>}</span></pre><p id="0e0e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">就这么简单。请看第6行:我们将属性<code class="fe mr ms mt mi b">stores</code>声明为<code class="fe mr ms mt mi b">Store</code>的<code class="fe mr ms mt mi b">Array</code>。</p><h1 id="8bc3" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">顶级实体</h1><p id="8946" class="pw-post-body-paragraph ju jv iq jw b jx ly jz ka kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr ij bi translated">API倾向于使用包装器键，这样JSON的顶层实体就是一个对象。让我们假设我们正在请求可用的商店，我们得到这样的响应:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="e055" class="mm lb iq mi b gy mn mo l mp mq">{<br/>   "stores":[<br/>      {<br/>         "name":"Gerry Cosby &amp; Co., Inc.",<br/>         "address":"11 Pennsylvania Plaza, New York, NY 10001, United States",<br/>         "phone":"+1 877-563-6464"<br/>      },<br/>      {<br/>         "name":"National Hockey League",<br/>         "address":"1185 6th Ave, New York, NY 10036, United States",<br/>         "phone":"+1 212-789-2000"<br/>      },<br/>      {<br/>         "name":"Modell's Sporting Goods",<br/>         "address":"234 W 42nd St, New York, NY 10036, United States",<br/>         "phone":"+1 212-764-7030"<br/>      }<br/>   ]<br/>}</span></pre><p id="e8d2" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如您所见，顶级实体是字段<code class="fe mr ms mt mi b">stores</code>，它是<code class="fe mr ms mt mi b">Store</code>的<code class="fe mr ms mt mi b">Array</code>。这里没有什么新东西:我们刚刚在上一节中看到了。我们可以这样处理:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="e422" class="mm lb iq mi b gy mn mo l mp mq">struct StoresList: Codable {<br/>    let stores: [Store]<br/>}</span></pre><p id="307a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">就是这样。</p><p id="e4a0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">但是如果没有包装键呢？JSON可能看起来像这样:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="dc48" class="mm lb iq mi b gy mn mo l mp mq">[<br/>   {<br/>      "name":"Gerry Cosby &amp; Co., Inc.",<br/>      "address":"11 Pennsylvania Plaza, New York, NY 10001, United States",<br/>      "phone":"+1 877-563-6464"<br/>   },<br/>   {<br/>      "name":"National Hockey League",<br/>      "address":"1185 6th Ave, New York, NY 10036, United States",<br/>      "phone":"+1 212-789-2000"<br/>   },<br/>   {<br/>      "name":"Modell's Sporting Goods",<br/>      "address":"234 W 42nd St, New York, NY 10036, United States",<br/>      "phone":"+1 212-764-7030"<br/>   }<br/>]</span></pre><p id="0f28" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">注意，第1行不是花括号:它是一个括号，因此它是一个数组。我们如何解码？非常简单:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="832f" class="mm lb iq mi b gy mn mo l mp mq">let decoder = JSONDecoder()<br/>if let stores = try? decoder.decode([Store].self, from: jsonData) {<br/>    print(stores)<br/>}</span></pre><p id="dc33" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">看第2行:<code class="fe mr ms mt mi b">[Store].self</code>在告诉解码器顶层对象是<code class="fe mr ms mt mi b">Store</code>的一个<code class="fe mr ms mt mi b">Array</code>。很整洁，是吧？</p><p id="d37d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">还有一种可能的情况会让你毛骨悚然。看看这个:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="50de" class="mm lb iq mi b gy mn mo l mp mq">[<br/>   {<br/>      "Gerry Cosby &amp; Co., Inc.":{<br/>         "address":"11 Pennsylvania Plaza, New York, NY 10001, United States",<br/>         "phone":"+1 877-563-6464"<br/>      },<br/>      "National Hockey League":{<br/>         "address":"1185 6th Ave, New York, NY 10036, United States",<br/>         "phone":"+1 212-789-2000"<br/>      },<br/>      "Modell's Sporting Goods":{<br/>         "address":"234 W 42nd St, New York, NY 10036, United States",<br/>         "phone":"+1 212-764-7030"<br/>      }<br/>   }<br/>]</span></pre><p id="1c5b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">不要慌！我们稍微分析一下。从上面开始阅读:JSON是一个数组，包含用不同键包装的实体。所以“格里·考斯比…”包装了一个地址和一个电话，“国家曲棍球…”和“模特体育…”也是如此。用键包装的实体数组。</p><p id="cbb3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们首先创建实体:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="12f0" class="mm lb iq mi b gy mn mo l mp mq">struct Store: Codable {<br/>    let address: String<br/>    let phone: String?<br/>}</span></pre><p id="d034" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">每个商店实体都用一个密钥包装，这样看起来就像<code class="fe mr ms mt mi b">String: Store</code>，不是吗？</p><p id="30bd" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在，我们在一个数组中列出了所有的商店(请看第2行和第15行)。我们通过写<code class="fe mr ms mt mi b">[String: Store]</code>来表达。</p><p id="6409" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">但是看看第1行和第16行:顶级实体也是一个数组(在这种情况下只有一个条目——<code class="fe mr ms mt mi b">[String: Store]</code>——但它是一个数组)，这给了我们这个结构:<code class="fe mr ms mt mi b">[[String: Store]]</code>。</p><p id="e2dd" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们是这样解码的:</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="dd7b" class="mm lb iq mi b gy mn mo l mp mq">let decoder = JSONDecoder()<br/>if let stores = try? decoder.decode([[String:Store]].self, from: jsonData) {<br/>    print(stores)<br/>}</span></pre><p id="10cc" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们告诉解码器我们的顶级实体是类型<code class="fe mr ms mt mi b">[[String: Store]]</code>。</p><h1 id="706e" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">就这样吗？</h1><p id="2be9" class="pw-post-body-paragraph ju jv iq jw b jx ly jz ka kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr ij bi translated">不。还有很多。我们将在这里停下来，因为它涵盖了您可能遇到的大多数常见场景。但请继续关注，因为一个高级系列即将推出。</p><h1 id="1b6d" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">现在怎么办？</h1><p id="e39d" class="pw-post-body-paragraph ju jv iq jw b jx ly jz ka kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr ij bi translated">开始编码！你也可以将我的个人网站<a class="ae kz" href="https://www.leandrofournier.com/" rel="noopener ugc nofollow" target="_blank"> Swift Delivery </a>加入书签，阅读这篇文章和我写的其他文章。</p></div></div>    
</body>
</html>