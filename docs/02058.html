<html>
<head>
<title>Writing a small web service with Ruby, Rack, and functional programming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Ruby、Rack和函数式编程编写小型web服务</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/writing-a-small-web-service-with-ruby-rack-and-functional-programming-a16f802a19c0?source=collection_archive---------5-----------------------#2020-02-16">https://levelup.gitconnected.com/writing-a-small-web-service-with-ruby-rack-and-functional-programming-a16f802a19c0?source=collection_archive---------5-----------------------#2020-02-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/ed7dfcc9d785ece06cd92065a0f992cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*pfXPaOgLPb0zg5Ks5rZOdw.png"/></div></figure><p id="b2e5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir"> UPD。</strong>请阅读我的<a class="ae ks" href="https://nondv.wtf/blog/posts/writing-a-small-web-service-with-ruby-rack-and-fp.html" rel="noopener ugc nofollow" target="_blank">个人博客</a>上的帖子</p><p id="7f8c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我爱露比。我也喜欢面向对象编程。然而，现在函数式编程越来越受到重视。这并不奇怪，因为函数范式有很多优点。</p><p id="5c6e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">作为一种多范例语言，Ruby允许我们以函数式风格编写程序。让我们看看是否可以这样编写一个web应用程序。也许我们最终会发明一个网络框架；)</p><h1 id="57c7" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">基本规则</h1><p id="c534" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">让我们建立一些基本规则。</p><ol class=""><li id="ca2a" class="lw lx iq jw b jx jy kb kc kf ly kj lz kn ma kr mb mc md me bi translated">兰姆达斯。到处都是兰姆达斯</li><li id="e293" class="lw lx iq jw b jx mf kb mg kf mh kj mi kn mj kr mb mc md me bi translated">数组。我们可以使用数组和一些可枚举的方法，比如<code class="fe mk ml mm mn b">map, reduce, find, select, reject</code></li><li id="8256" class="lw lx iq jw b jx mf kb mg kf mh kj mi kn mj kr mb mc md me bi translated">哈希。我们可以通过<code class="fe mk ml mm mn b">[key]</code>访问值，并使用<code class="fe mk ml mm mn b">merge</code>来修改它们(没有突变！)</li><li id="af64" class="lw lx iq jw b jx mf kb mg kf mh kj mi kn mj kr mb mc md me bi translated">将外部依赖性(如机架实用功能)保持在最低限度。</li></ol><h1 id="f749" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">行李架</h1><blockquote class="mo mp mq"><p id="7098" class="ju jv mr jw b jx jy jz ka kb kc kd ke ms kg kh ki mt kk kl km mu ko kp kq kr ij bi translated">Rack为用Ruby开发web应用程序提供了一个最小的、模块化的、适应性强的接口。</p></blockquote><p id="6073" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Rails和Sinatra使用Rack。你可以在这里了解更多:<a class="ae ks" href="https://github.com/rack/rack" rel="noopener ugc nofollow" target="_blank">https://github.com/rack/rack</a></p><p id="1c9b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Rack期望应用程序是一个具有接受<code class="fe mk ml mm mn b">env</code>(包含关于请求的所有信息的散列)并返回3元素元组的<code class="fe mk ml mm mn b">call</code>方法的对象:</p><p id="61cc" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe mk ml mm mn b">[status_code, headers_hash, body_array]</code></p><p id="d364" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">(主体数组通常是字符串列表)</p><p id="fdcb" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这很棒，因为它使用了基本的数据结构，而<code class="fe mk ml mm mn b">call</code>方法表明我们可以将lambda/proc用作应用程序。</p><h1 id="98c3" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">设置</h1><p id="a890" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">我们先设置一个app。</p><h2 id="3958" class="mv ku iq bd kv mw mx dn kz my mz dp ld kf na nb lh kj nc nd ll kn ne nf lp ng bi translated">Gemfile</h2><p id="2e94" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">用<code class="fe mk ml mm mn b">bundle init</code>生成一个gem文件，并向其中添加Rack。</p><pre class="nh ni nj nk gt nl mn nm nn aw no bi"><span id="b2d3" class="mv ku iq mn b gy np nq l nr ns">source "<a class="ae ks" href="https://rubygems.org" rel="noopener ugc nofollow" target="_blank">https://rubygems.org</a>"<br/>git_source(:github) {|repo_name| "<a class="ae ks" href="https://github.com/#{repo_name" rel="noopener ugc nofollow" target="_blank">https://github.com/#{repo_name</a>}" }</span><span id="e796" class="mv ku iq mn b gy nt nq l nr ns">gem "rack"</span></pre><h2 id="d140" class="mv ku iq bd kv mw mx dn kz my mz dp ld kf na nb lh kj nc nd ll kn ne nf lp ng bi translated">配置. ru</h2><p id="f44a" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated"><code class="fe mk ml mm mn b">config.ru</code>是由Rack附带的<code class="fe mk ml mm mn b">rackup</code>程序运行并启动web服务器的脚本。</p><figure class="nh ni nj nk gt jr"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="0c8f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Rack reloader将重新加载我们的应用程序，无需重启服务器。</p><p id="3a34" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们还将假设我们的应用程序源代码将使用我们的应用程序lambda定义<code class="fe mk ml mm mn b">APP</code>常量。我们还需要将它包装到另一个lambda中，否则Rack不会拾取对常量的更改。</p><h2 id="e0ba" class="mv ku iq bd kv mw mx dn kz my mz dp ld kf na nb lh kj nc nd ll kn ne nf lp ng bi translated">app.rb</h2><figure class="nh ni nj nk gt jr"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="5b22" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在我们可以用<code class="fe mk ml mm mn b">bundle exec rackup</code>启动web服务器。它应该可以在<a class="ae ks" href="http://localhost:9292" rel="noopener ugc nofollow" target="_blank"> http://localhost:9292 </a>上找到</p><h1 id="c73f" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">按指定路线发送</h1><p id="d69a" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">让我们为<code class="fe mk ml mm mn b">/hello</code>添加一条显示“Hello world”消息的路线。还有，404页。</p><h2 id="6326" class="mv ku iq bd kv mw mx dn kz my mz dp ld kf na nb lh kj nc nd ll kn ne nf lp ng bi translated">经理人</h2><p id="fa9f" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">让我们把之前的lambda从APP移到一个handler变量。</p><figure class="nh ni nj nk gt jr"><div class="bz fp l di"><div class="nu nv l"/></div></figure><h2 id="ce25" class="mv ku iq bd kv mw mx dn kz my mz dp ld kf na nb lh kj nc nd ll kn ne nf lp ng bi translated">路线</h2><p id="eb42" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">让我们将路由定义为一组条件+处理程序对:</p><figure class="nh ni nj nk gt jr"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="c43b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们也可以从路线中创建一个数据类型。为此，我们应该创建一个函数<code class="fe mk ml mm mn b">route(matcher, handler)</code>和getter函数<code class="fe mk ml mm mn b">route_matcher(route)</code>和<code class="fe mk ml mm mn b">route_handler(route)</code>，而不是显式地将它们写成对。这样，代码变得更加灵活，因为它不太了解数据结构的实现。然而，让我们保持简单。</p><h2 id="f03b" class="mv ku iq bd kv mw mx dn kz my mz dp ld kf na nb lh kj nc nd ll kn ne nf lp ng bi translated">路由器</h2><p id="ef00" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">路由器是一个调度功能，它决定一个请求使用哪个处理器。</p><figure class="nh ni nj nk gt jr"><div class="bz fp l di"><div class="nu nv l"/></div></figure><h1 id="b21a" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">中间件</h1><p id="f31c" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">让我们让用户提供他们的名字来恰当地问候他们。</p><p id="0c34" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为此，我们需要一个<code class="fe mk ml mm mn b">params</code>散列。</p><h2 id="c5e9" class="mv ku iq bd kv mw mx dn kz my mz dp ld kf na nb lh kj nc nd ll kn ne nf lp ng bi translated">Params中间件</h2><p id="e897" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">中间件只是一个处理程序的包装器，用于修改<code class="fe mk ml mm mn b">env</code>或从其返回的结果。<br/>让我们创建一个中间件，在将env交给处理程序之前，将<code class="fe mk ml mm mn b">params</code> hash添加到env中。</p><figure class="nh ni nj nk gt jr"><div class="bz fp l di"><div class="nu nv l"/></div></figure><h2 id="a578" class="mv ku iq bd kv mw mx dn kz my mz dp ld kf na nb lh kj nc nd ll kn ne nf lp ng bi translated">负责人</h2><p id="c4c0" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">让我们在处理程序中使用新的参数。</p><figure class="nh ni nj nk gt jr"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="d6f9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在我们应该可以在这里看到一个问候语:</p><p id="2b8a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><a class="ae ks" href="http://localhost:9292/hello?name=John+Doe" rel="noopener ugc nofollow" target="_blank"> http://localhost:9292/hello？name=John+Doe </a></p><h2 id="01f0" class="mv ku iq bd kv mw mx dn kz my mz dp ld kf na nb lh kj nc nd ll kn ne nf lp ng bi translated">内容类型标题</h2><p id="8893" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">让我们也添加<code class="fe mk ml mm mn b">text/html</code>内容类型头。</p><figure class="nh ni nj nk gt jr"><div class="bz fp l di"><div class="nu nv l"/></div></figure><h2 id="c90e" class="mv ku iq bd kv mw mx dn kz my mz dp ld kf na nb lh kj nc nd ll kn ne nf lp ng bi translated">列表中间件</h2><p id="80ff" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">现在，我们正在添加一个中间件，方法是在一个处理程序上直接调用它。如果我们能把它们列出来，以后再申请，那就更好了。</p><figure class="nh ni nj nk gt jr"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="0a17" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">身份功能很棒。将它与另一个函数组合在一起没有任何效果，所以它是reducing的一个很好的初始值。</p><h1 id="e075" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">结论？</h1><p id="de14" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">我们已经实现了一个小型的web应用程序。虽然它没做多少。然而，有趣的是，仅仅使用lambdas、数组和散列，我们能走多远。</p><p id="3c33" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">数据库交互会给我们的代码带来副作用。作为一种想法，它们可以被放入方法中，这样就更容易将它们与纯lambdas区分开来。</p><p id="fc8f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们也可以通过把基本的东西移到散列中，并把它们赋给常量，来制作一个框架。举个例子，</p><figure class="nh ni nj nk gt jr"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="a629" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">你可以在这里找到完整的源代码<a class="ae ks" href="https://github.com/Nondv/ruby-experiments/tree/master/functional_rack" rel="noopener ugc nofollow" target="_blank">。</a></p></div></div>    
</body>
</html>