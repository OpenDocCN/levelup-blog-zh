<html>
<head>
<title>Improve iOS App Performance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">提高iOS应用程序性能</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/improve-ios-app-performance-64ead2b247d1?source=collection_archive---------3-----------------------#2020-10-29">https://levelup.gitconnected.com/improve-ios-app-performance-64ead2b247d1?source=collection_archive---------3-----------------------#2020-10-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/de43beecaccfb7f38ba2ade472715ae1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NJG3Xk4DaEm93Rg16p1sug.jpeg"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">Kolleen Gladden 在<a class="ae jd" href="https://unsplash.com/s/photos/performance?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><div class=""/><p id="761f" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">代码质量取决于几个因素，如可读性、准确性、性能等。如果你认为时间是世界上最重要的东西，那么性能就不能是一个被低估的因素。</p><p id="a0da" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当你创建你的第一个Hello World项目时，一切都非常顺利。当你的梦想项目越来越大时，你可能会遭受巨大的编译时间或应用程序性能。只需深入iOS生态系统架构。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h2 id="678f" class="li lj jg bd lk ll lm dn ln lo lp dp lq ko lr ls lt ks lu lv lw kw lx ly lz ma bi translated">使用面向协议的编程而不是面向对象的编程</h2><p id="f224" class="pw-post-body-paragraph kd ke jg kf b kg mb ki kj kk mc km kn ko md kq kr ks me ku kv kw mf ky kz la ij bi translated">如果您查看标准的Swift库代码，您会发现协议被频繁使用。如果你从零开始建立继承关系，苹果更喜欢面向协议的编程和使用它的建议。</p><blockquote class="mg mh mi"><p id="9a6f" class="kd ke mj kf b kg kh ki kj kk kl km kn mk kp kq kr ml kt ku kv mm kx ky kz la ij bi translated">点击<a class="ae jd" href="https://developer.apple.com/documentation/swift/choosing_between_structures_and_classes" rel="noopener ugc nofollow" target="_blank">链接阅读官方文件。</a></p></blockquote><figure class="mo mp mq mr gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mn"><img src="../Images/cc9d20eef5775c264ca59357cd0744c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6usT7n86RBUNed6STuaDMQ.png"/></div></div></figure><p id="0a5f" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">OOP范例通过使用继承和多态来解决应用程序中的复杂性问题，多态本身就是最有用的部分。当程序运行时，即运行时，它决定应该调用哪个参数或方法。这个决策过程称为动态调度。</p><p id="cc0e" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的截图是OOP的一个小例子。我们知道，类B有一个带有override关键字的echo方法，因为它已经在类a的超类中定义了。当我们调用类B中的echo方法时，触发的是类B中被覆盖的echo方法，而不是类a。</p><p id="40a8" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一切看起来都很棒，对吧？实际上不是，因为每个进程都是在运行时完成的，就像上面的例子一样，这会降低我们的执行时间。那么，解决办法是什么呢？</p><figure class="mo mp mq mr gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ms"><img src="../Images/05b81c65d86155e6d6f01b79ae52e7dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jXkB7yBj9NMqcOuGCtIwhA.png"/></div></div></figure><p id="be33" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">POP代表面向协议的编程。我们通过一个小的修改减少了运行时间的计算。POP的用法好熟悉啊，不是吗？它是苹果在UIKit中大量使用的委托模式。</p><h2 id="aa3e" class="li lj jg bd lk ll lm dn ln lo lp dp lq ko lr ls lt ks lu lv lw kw lx ly lz ma bi translated">使用静态调度</h2><p id="56bf" class="pw-post-body-paragraph kd ke jg kf b kg mb ki kj kk mc km kn ko md kq kr ks me ku kv kw mf ky kz la ij bi translated">在阅读关于Swift标准库的Apple文档时，您可以看到“使用结构而不是类”的阶段如此之多。除了结构是值类型，而类是引用类型之外，结构和类是非常相同的结构。看起来这只是一个很小的差别。其实没那么小！</p><p id="1ce7" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种差异的结果是，如果你从一个类创建一个对象，它是动态分配的，而struct对象是静态分配的。换一种方式解释，静态创建的对象在编译时在固定大小的堆栈中创建，而动态创建的对象在运行时在堆中创建。它们的大小在运行时被计算并分配给所需的内存。因此，从类对象调用的方法使用动态调度，而结构对象也使用静态调度。</p><p id="479b" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mj">结论</em>使用结构结合协议，而不是重类继承。</p><p id="39c0" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf jh">* *更新</strong></p><p id="0edc" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">非常感谢<a class="mt mu ep" href="https://medium.com/u/7adf7e533179?source=post_page-----64ead2b247d1--------------------------------" rel="noopener" target="_blank">范黄乐</a>的通知。我们说结构是静态分配的，而类是动态分配的。但是如果一个类包含一个结构类型的参数呢？struct参数仍然是静态分配并在堆栈上创建的吗？答案是否定的！尽管它是一个结构类型，但它的容器是一个类，所以参数是通过动态调度在堆中分配的。</p><h2 id="0044" class="li lj jg bd lk ll lm dn ln lo lp dp lq ko lr ls lt ks lu lv lw kw lx ly lz ma bi translated">检查您的访问级别</h2><p id="4674" class="pw-post-body-paragraph kd ke jg kf b kg mb ki kj kk mc km kn ko md kq kr ks me ku kv kw mf ky kz la ij bi translated">在程序运行之前，不会为从类创建的对象确定方法调用和参数访问。因此，当你点击Xcode中的run按钮时，编译器会编译你的代码，并确定内存分配以及方法和参数访问之间的关系，即多态性的使用。如果编译器发现某个方法或参数没有被外部访问，就将其标记为最终关键字。</p><p id="82e0" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您知道一个类不是任何类的基类，您应该将final关键字添加到类定义中。将最终定义添加到类中时，会将最终定义添加到类中的所有参数和方法中。</p><p id="70ad" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设您有一个应该被覆盖的类。因此，该类不能有final关键字。所以你可以给子类中不能访问的所有参数和方法添加私有限制。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><p id="94ed" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可以阅读苹果开发者文档来获得更多详细的官方信息。</p><div class="ip iq gp gr ir mv"><a href="https://developer.apple.com/swift/blog/?id=27" rel="noopener  ugc nofollow" target="_blank"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd jh gy z fp na fr fs nb fu fw jf bi translated">通过减少动态调度提高性能- Swift博客</h2><div class="nc l"><h3 class="bd b gy z fp na fr fs nb fu fw dk translated">像许多其他语言一样，Swift允许一个类覆盖在其超类中声明的方法和属性。这个…</h3></div><div class="nd l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">developer.apple.com</p></div></div><div class="ne l"><div class="nf l ng nh ni ne nj ix mv"/></div></div></a></div></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="58e7" class="nk lj jg bd lk nl nm nn ln no np nq lq nr ns nt lt nu nv nw lw nx ny nz lz oa bi translated">返回👨‍💻</h1></div></div>    
</body>
</html>