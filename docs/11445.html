<html>
<head>
<title>Merge Two Sorted Arrays in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Python中合并两个排序后的数组</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/merge-two-sorted-arrays-in-python-a6851f8ff2e2?source=collection_archive---------3-----------------------#2022-03-18">https://levelup.gitconnected.com/merge-two-sorted-arrays-in-python-a6851f8ff2e2?source=collection_archive---------3-----------------------#2022-03-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/33b80756907b8f15967746ca6f9548ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:688/format:webp/1*eF1cWMZK6Zf9ppw7U1Tnrg.png"/></div></figure><h1 id="c675" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">问题</h1><p id="c523" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">给定两个排序的数组，将它们合并成一个排序的数组。</p><h2 id="63de" class="lq jv iq bd jw lr ls dn ka lt lu dp ke ld lv lw ki lh lx ly km ll lz ma kq mb bi translated">例子</h2><ul class=""><li id="3153" class="mc md iq ku b kv kw kz la ld me lh mf ll mg lp mh mi mj mk bi translated">示例01</li></ul><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="a876" class="lq jv iq mq b gy mu mv l mw mx">Input: arr1 = [3, 5, 6, 10], arr2 = [1, 2, 7, 8, 11, 12]<br/>Output: arr3 = [1, 2, 3, 5, 6, 7, 8, 10, 11, 12]</span></pre><ul class=""><li id="08fb" class="mc md iq ku b kv my kz mz ld na lh nb ll nc lp mh mi mj mk bi translated">示例02</li></ul><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="4ec1" class="lq jv iq mq b gy mu mv l mw mx">Input: arr1 = [1, 3, 4, 5], arr2 = [2, 4, 6, 8]<br/>Output: arr3 = [1, 2, 3, 4, 4, 5, 6, 8]</span></pre><ul class=""><li id="9522" class="mc md iq ku b kv my kz mz ld na lh nb ll nc lp mh mi mj mk bi translated">示例03</li></ul><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="9324" class="lq jv iq mq b gy mu mv l mw mx">Input: arr1 = [5, 8, 9], arr2 = [4, 7, 8]<br/>Output: arr3 = [4, 5, 7, 8, 8, 9]</span></pre><h1 id="a1be" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">解决方案01</h1><h2 id="adce" class="lq jv iq bd jw lr ls dn ka lt lu dp ke ld lv lw ki lh lx ly km ll lz ma kq mb bi translated">伪代码</h2><ol class=""><li id="ac6a" class="mc md iq ku b kv kw kz la ld me lh mf ll mg lp nd mi mj mk bi translated">通过连接<code class="fe ne nf ng mq b">arr1</code>和<code class="fe ne nf ng mq b">arr2</code>创建一个数组<code class="fe ne nf ng mq b">arr3</code>。</li><li id="777a" class="mc md iq ku b kv nh kz ni ld nj lh nk ll nl lp nd mi mj mk bi translated">排序<code class="fe ne nf ng mq b">arr3</code>。</li></ol><h2 id="1658" class="lq jv iq bd jw lr ls dn ka lt lu dp ke ld lv lw ki lh lx ly km ll lz ma kq mb bi translated">源代码</h2><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="71c5" class="lq jv iq mq b gy mu mv l mw mx">def merge(num1, num2):<br/>    arr3 = num1+num2<br/>    arr3.sort()<br/>    return arr3<br/>    <br/>arr1 = [3, 5, 6, 10]<br/>arr2 = [1, 2, 7, 8, 11, 12]<br/>assert merge(arr1, arr2) == [1, 2, 3, 5, 6, 7, 8, 10, 11, 12]<br/>arr1 = [1, 3, 4, 5]<br/>arr2 = [2, 4, 6, 8]<br/>assert merge(arr1, arr2) == [1, 2, 3, 4, 4, 5, 6, 8]<br/>arr1 = [5, 8, 9]<br/>arr2 = [4, 7, 8]<br/>assert merge(arr1, arr2) == [4, 5, 7, 8, 8, 9]</span></pre><h2 id="b513" class="lq jv iq bd jw lr ls dn ka lt lu dp ke ld lv lw ki lh lx ly km ll lz ma kq mb bi translated">时间和空间复杂性</h2><ul class=""><li id="4591" class="mc md iq ku b kv kw kz la ld me lh mf ll mg lp mh mi mj mk bi translated"><strong class="ku ir">时间复杂度</strong> : O((N+M)log(N+M))。给定N是<code class="fe ne nf ng mq b">arr1</code>中的元素数，M是<code class="fe ne nf ng mq b">arr2</code>中的元素数。</li><li id="d2da" class="mc md iq ku b kv nh kz ni ld nj lh nk ll nl lp mh mi mj mk bi translated"><strong class="ku ir">空间复杂度</strong> : O(N+M)</li></ul><h1 id="06fd" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">解决方案02</h1><h2 id="4a00" class="lq jv iq bd jw lr ls dn ka lt lu dp ke ld lv lw ki lh lx ly km ll lz ma kq mb bi translated">伪代码</h2><figure class="ml mm mn mo gt jr gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/a1258c29e3c07b7c7d67ed95fdcf9b77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1084/format:webp/1*LLryzAD6n_-icUgOT4_eSA.png"/></div><figcaption class="nn no gj gh gi np nq bd b be z dk translated">致谢:GeeksForGeeks</figcaption></figure><ol class=""><li id="0376" class="mc md iq ku b kv my kz mz ld na lh nb ll nc lp nd mi mj mk bi translated">创建一个长度/大小为<code class="fe ne nf ng mq b">arr1</code> + <code class="fe ne nf ng mq b">arr2</code>的数组<code class="fe ne nf ng mq b">arr3</code>。</li><li id="1666" class="mc md iq ku b kv nh kz ni ld nj lh nk ll nl lp nd mi mj mk bi translated">同时移动<code class="fe ne nf ng mq b">arr1</code>和<code class="fe ne nf ng mq b">arr2</code>。</li></ol><ul class=""><li id="e35c" class="mc md iq ku b kv my kz mz ld na lh nb ll nc lp mh mi mj mk bi translated">在<code class="fe ne nf ng mq b">arr1</code>和<code class="fe ne nf ng mq b">arr2</code>中选取较小的当前元素，将这个较小的元素复制到<code class="fe ne nf ng mq b">arr3</code>中的下一个位置，并在<code class="fe ne nf ng mq b">arr3</code>和被选取元素的数组中向前移动。</li></ul><p id="cac8" class="pw-post-body-paragraph ks kt iq ku b kv my kx ky kz mz lb lc ld nr lf lg lh ns lj lk ll nt ln lo lp ij bi translated">3.如果<code class="fe ne nf ng mq b">arr1</code>或<code class="fe ne nf ng mq b">arr2</code>中有剩余元素，将其复制到<code class="fe ne nf ng mq b">arr3</code>中。</p><h2 id="40e2" class="lq jv iq bd jw lr ls dn ka lt lu dp ke ld lv lw ki lh lx ly km ll lz ma kq mb bi translated">源代码</h2><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="ca29" class="lq jv iq mq b gy mu mv l mw mx">def merge(num1, num2):<br/>    arr3 = [None]*(len(num1)+len(num2))<br/>    i, j, k = 0, 0, 0<br/>    <br/>    while i &lt; len(arr1) and j &lt; len(arr2):<br/>        if arr1[i] &lt; arr2[j]:<br/>            arr3[k] = arr1[i]<br/>            k += 1<br/>            i += 1<br/>        else:<br/>            arr3[k] = arr2[j]<br/>            k += 1<br/>            j += 1<br/>            <br/>    while i &lt; len(num1):<br/>        arr3[k] = arr1[i];<br/>        k += 1<br/>        i += 1<br/>        <br/>    while j &lt; len(num2):<br/>        arr3[k] = arr2[j];<br/>        k += 1<br/>        j += 1<br/>    <br/>    return arr3<br/>                <br/>arr1 = [3, 5, 6, 10]<br/>arr2 = [1, 2, 7, 8, 11, 12]<br/>assert merge(arr1, arr2) == [1, 2, 3, 5, 6, 7, 8, 10, 11, 12]<br/>arr1 = [1, 3, 4, 5]<br/>arr2 = [2, 4, 6, 8]<br/>assert merge(arr1, arr2) == [1, 2, 3, 4, 4, 5, 6, 8]<br/>arr1 = [5, 8, 9]<br/>arr2 = [4, 7, 8]<br/>assert merge(arr1, arr2) == [4, 5, 7, 8, 8, 9]</span></pre><h2 id="f5c5" class="lq jv iq bd jw lr ls dn ka lt lu dp ke ld lv lw ki lh lx ly km ll lz ma kq mb bi translated">时间和空间复杂性</h2><ul class=""><li id="eadc" class="mc md iq ku b kv kw kz la ld me lh mf ll mg lp mh mi mj mk bi translated"><strong class="ku ir">时间复杂度</strong> : O(N+M)。给定N是<code class="fe ne nf ng mq b">arr1</code>中的元素数，M是<code class="fe ne nf ng mq b">arr2</code>中的元素数。</li><li id="b793" class="mc md iq ku b kv nh kz ni ld nj lh nk ll nl lp mh mi mj mk bi translated"><strong class="ku ir">空间复杂度</strong> : O(N+M)</li></ul><h1 id="0631" class="ju jv iq bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">外卖食品</h1><p id="b2af" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">感谢您阅读这个简短的解题问题。如果有人知道更好或更快的时间复杂度来解决这个问题，请随意评论和反馈。和平！✌️</p></div></div>    
</body>
</html>