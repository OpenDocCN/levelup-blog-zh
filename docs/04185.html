<html>
<head>
<title>Property Shadowing and __proto__ In Javascript Objects.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Javascript对象中的属性隐藏和__proto__。</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/property-shadowing-and-proto-in-javascript-objects-d007fa062a63?source=collection_archive---------6-----------------------#2020-06-13">https://levelup.gitconnected.com/property-shadowing-and-proto-in-javascript-objects-d007fa062a63?source=collection_archive---------6-----------------------#2020-06-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="f51c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在谈论属性隐藏和解释它是如何工作的之前，我们首先要定义隐藏的一般含义。</p><p id="3110" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">根据维基百科:</p><blockquote class="ko kp kq"><p id="c619" class="jq jr kr js b jt ju jv jw jx jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kn im bi translated">在计算机编程中，当在某个<strong class="js iu">范围</strong>(决策块、方法或内部类)内声明的变量与在外部范围内声明的变量同名时，就会出现<strong class="js iu">变量隐藏</strong>。在标识符级别(名称，而不是变量)</p></blockquote><p id="810f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">考虑:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="77f5" class="le lf it la b gy lg lh l li lj">let a = 20</span><span id="9a63" class="le lf it la b gy lk lh l li lj">function myFunction() {</span><span id="1807" class="le lf it la b gy lk lh l li lj">  console.log(a)</span><span id="072c" class="le lf it la b gy lk lh l li lj">}</span><span id="92e6" class="le lf it la b gy lk lh l li lj">myFunction() // --&gt;20</span></pre><p id="8c6b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是一个简单的例子。“myFunction”可以访问变量“a”的值，因为它是在其外部作用域(本例中为全局作用域)中定义的。<br/>现在考虑这个例子:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="9a7a" class="le lf it la b gy lg lh l li lj">let a = 20</span><span id="d3a3" class="le lf it la b gy lk lh l li lj">function myFunction() {<br/>  let a = 10</span><span id="1065" class="le lf it la b gy lk lh l li lj">  console.log(a)</span><span id="6554" class="le lf it la b gy lk lh l li lj">}</span><span id="834d" class="le lf it la b gy lk lh l li lj">myFunction() // --&gt;10</span></pre><p id="95ef" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们定义了另一个变量，该变量与其外部作用域(a)中的变量同名。所以<em class="kr"> console.log </em>会打印新的值:10。我们说'<em class="kr"> myFunction </em> ' <strong class="js iu">中的<em class="kr"> 'a' </em>遮蔽了存在于其外部作用域的' a '。</strong>听起来合乎逻辑对吗？</p><p id="32e7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对象属性具有类似的机制，但稍微复杂一些。</p><p id="b209" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了理解对象中的隐藏是如何工作的，我们应该首先理解Javascript中的原型是如何工作的。</p><p id="a114" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当您创建一个新的Javascript对象时，一个名为<strong class="js iu"> __proto__ </strong>的新的隐藏内部属性(在大多数情况下)会在您的对象中自动创建，它只是作为对另一个现有对象的引用。</p><figure class="kv kw kx ky gt lm gh gi paragraph-image"><div class="gh gi ll"><img src="../Images/f2e6cde80f5cbcaa974089b4f64f250c.png" data-original-src="https://miro.medium.com/v2/resize:fit:764/format:webp/1*1PW2TpLKeD6WlAR275NrmA.png"/></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk translated">myObj有一个名为__proto__的新属性，它本身有许多属性</figcaption></figure><p id="c7c5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你使用<em class="kr">对象文字符号</em>，那么<strong class="js iu"> __proto__ </strong>属性将被设置为<em class="kr">内置</em> <strong class="js iu"> Object.prototype. </strong>你可以把它想象成一个对象，它包含了各种在Javascript对象上使用的通用工具。(注意，这不是创建__proto__是Object.prototype本身的对象的唯一方法):</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="0d58" class="le lf it la b gy lg lh l li lj">const myObj = {</span><span id="1e59" class="le lf it la b gy lk lh l li lj">  a: 20</span><span id="52c3" class="le lf it la b gy lk lh l li lj">}</span><span id="1bf2" class="le lf it la b gy lk lh l li lj">console.log(myObj.__proto__ === Object.prototype) // --&gt; true</span></pre><p id="c58f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过显式修改<strong class="js iu"> __proto__ </strong>值，您可以指定希望新创建的对象将哪个对象的<strong class="js iu"> __proto__ </strong>作为<em class="kr">引用</em>:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="3259" class="le lf it la b gy lg lh l li lj">const obj1 = {</span><span id="387f" class="le lf it la b gy lk lh l li lj">  b: 90</span><span id="6646" class="le lf it la b gy lk lh l li lj">}</span><span id="a6e5" class="le lf it la b gy lk lh l li lj">const obj2 = {}</span><span id="d05d" class="le lf it la b gy lk lh l li lj">obj2.__proto__ = obj1</span></pre><p id="bd3c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">或者使用Object.create方法:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="abf2" class="le lf it la b gy lg lh l li lj">const obj1 = {</span><span id="1b4d" class="le lf it la b gy lk lh l li lj">b: 90</span><span id="3dc6" class="le lf it la b gy lk lh l li lj">}</span><span id="0828" class="le lf it la b gy lk lh l li lj">const obj2 = Object.create(obj1)</span><span id="0f99" class="le lf it la b gy lk lh l li lj">console.log(obj2.__proto__ === obj1) // --&gt; true</span></pre><p id="8ac6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您现在可能会问自己:为什么Javascript要在我的对象中创建这个<em class="kr"> __proto__ </em>属性，为什么我还要修改它？<br/>这个问题的答案是:<strong class="js iu">原型链</strong>。</p><p id="a7b0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您想访问对象内部的属性，只需键入object.propertyName。但是如果该属性不存在呢？在这里，一个充满可能性的新世界打开了。</p><p id="3c1f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您试图访问一个您没有在对象中定义的属性，Javascript引擎将尝试在您的对象的<strong class="js iu"> __proto__ </strong>属性中查找它(正如我们前面解释的，它只是对另一个对象的引用)。如果它没有找到它，它将尝试在另一个对象的<strong class="js iu"> __proto__ </strong>中找到它，直到它到达<strong class="js iu"> Object.prototype </strong>，这是<em class="kr">链的末端。这就是为什么我们称它为</em> <strong class="js iu"> <em class="kr">原型链。</em> </strong></p><p id="567f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">考虑下面的例子:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="c1b3" class="le lf it la b gy lg lh l li lj">const obj1 = {</span><span id="3997" class="le lf it la b gy lk lh l li lj">  a: 90</span><span id="ad77" class="le lf it la b gy lk lh l li lj">}</span><span id="cd36" class="le lf it la b gy lk lh l li lj">const obj2 = {}</span><span id="3bec" class="le lf it la b gy lk lh l li lj">obj2.__proto__ = obj1</span><span id="f470" class="le lf it la b gy lk lh l li lj">console.log(obj2.a) // --&gt; 90</span></pre><p id="9e37" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="kr"> obj2 </em>没有属性a。我们已经能够通过我们自动创建的<em class="kr"> __proto__ </em>来访问它，它是对“<em class="kr"> obj1 </em>的引用。当<em class="kr">引擎</em>在“<em class="kr"> obj2 </em>”层没有找到“a”时，它继续检查<strong class="js iu"> __proto__ </strong>属性“a”是否存在，然后找到并打印它。</p><p id="9ce1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这就是<strong class="js iu">属性隐藏</strong>发挥作用的地方。如果我们在'<em class="kr"> obj2 </em>'中已经有了一个名为' a '的属性，那么它就会有<strong class="js iu">遮蔽'<strong class="js iu"> obj1 </strong>'中的' a ':</strong></p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="f1a1" class="le lf it la b gy lg lh l li lj">const obj1 = {</span><span id="9454" class="le lf it la b gy lk lh l li lj">  a: 90</span><span id="1e96" class="le lf it la b gy lk lh l li lj">}</span><span id="034f" class="le lf it la b gy lk lh l li lj">const obj2 = {</span><span id="5da0" class="le lf it la b gy lk lh l li lj">  a:20</span><span id="0f01" class="le lf it la b gy lk lh l li lj">}</span><span id="c2d3" class="le lf it la b gy lk lh l li lj">obj2.__proto__ = obj1</span><span id="c48e" class="le lf it la b gy lk lh l li lj">console.log(obj2.a) // --&gt; 20</span></pre><p id="87b9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在一切都开始有意义了，对吗？</p><p id="6fa0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">问题是，事情要比这稍微复杂一些。还有其他一些定义<strong class="js iu">属性隐藏的规则。</strong></p><p id="ebde" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="kr">第一法则:</em> </strong></p><p id="e573" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果在<strong class="js iu"> __proto__ </strong>链上找到您尝试创建/修改的属性，并且其<strong class="js iu">属性描述符</strong>的<strong class="js iu"> </strong> <em class="kr">【可写】</em>设置为<strong class="js iu">假，</strong>该属性将不会在您的新对象级别上创建/修改。</p><blockquote class="ko kp kq"><p id="7cba" class="jq jr kr js b jt ju jv jw jx jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kn im bi translated">一个<code class="fe lt lu lv la b"><strong class="js iu"><em class="it">PropertyDescriptor</em></strong></code> <strong class="js iu"> </strong>描述了一个<code class="fe lt lu lv la b"><a class="ae lw" href="https://www.javascripture.com/Object" rel="noopener ugc nofollow" target="_blank"><strong class="js iu"><em class="it">Object</em></strong></a></code>上的属性。任何JavaScript对象都可以用作<code class="fe lt lu lv la b"><strong class="js iu"><em class="it">PropertyDescriptor</em></strong></code> <strong class="js iu"> </strong>，其中未指定的属性将被视为<code class="fe lt lu lv la b"><strong class="js iu"><em class="it">undefined</em></strong></code> <strong class="js iu"> </strong>或<code class="fe lt lu lv la b"><strong class="js iu"><em class="it">false</em></strong></code>。</p><p id="8f72" class="jq jr kr js b jt ju jv jw jx jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kn im bi translated">https://www.javascripture.com/PropertyDescriptor</p></blockquote><p id="a2e2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">默认情况下'<em class="kr"> writable' </em>设置为true，但是我们可以使用<em class="kr"> Object.defineProperty </em>(或者Object.defineProperties用于同时定义多个属性)来更改它。</p><p id="9255" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个方法用于在对象内部定义一个新的属性，但是它允许我们指定它的<em class="kr">属性描述符</em>以及<em class="kr">。</em></p><p id="21de" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将只关注'<em class="kr"> writable '，因为其他属性超出了本文的范围。</em></p><p id="3d37" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">考虑:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="8e2e" class="le lf it la b gy lg lh l li lj">const obj = {}</span><span id="dbd4" class="le lf it la b gy lk lh l li lj">Object.defineProperty(obj, "a", {</span><span id="c429" class="le lf it la b gy lk lh l li lj">value: 20,</span><span id="eed3" class="le lf it la b gy lk lh l li lj">writable: false</span><span id="c696" class="le lf it la b gy lk lh l li lj">})</span><span id="b514" class="le lf it la b gy lk lh l li lj">obj.a = 100</span><span id="a3e7" class="le lf it la b gy lk lh l li lj">console.log(obj.a); // --&gt; 20</span></pre><p id="f542" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本例中，我们在对象'<em class="kr"> obj </em>'中定义了一个新属性，为其赋值20，并将其可写的<em class="kr">标记为<strong class="js iu"> false </strong>。</em></p><p id="86c5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这意味着‘a’的值不能被修改(除非我们将它的<em class="kr">可写值</em>改为true)。这使其成为一个只读变量。</p><p id="4e24" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这对所有创建的对象都有影响，这些对象引用了此对象的<strong class="js iu"> <em class="kr"> __proto__ </em> </strong>(其属性的writable为false)。他们将无法<strong class="js iu">跟踪</strong>该资产，甚至无法创建同名资产:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="eb6c" class="le lf it la b gy lg lh l li lj">const obj = {}</span><span id="51e1" class="le lf it la b gy lk lh l li lj">Object.defineProperty(obj, "a", {</span><span id="3247" class="le lf it la b gy lk lh l li lj">  value: 20,</span><span id="292f" class="le lf it la b gy lk lh l li lj">  writable: false</span><span id="840e" class="le lf it la b gy lk lh l li lj">})</span><span id="0950" class="le lf it la b gy lk lh l li lj">const obj2 = Object.create(obj)</span><span id="d35c" class="le lf it la b gy lk lh l li lj">obj2.a = 40</span><span id="8719" class="le lf it la b gy lk lh l li lj">console.log(obj2.a) // --&gt; 20</span><span id="6b1b" class="le lf it la b gy lk lh l li lj">console.log(obj2.hasOwnProperty('a')) // --&gt; false (Used to check whether a particular object has a specific property)</span></pre><p id="47a1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="kr">第二条规则:</em> </strong></p><p id="f353" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你试图<strong class="js iu">阴影</strong>的属性是一个<strong class="js iu"> <em class="kr"> Setter </em> </strong> ( <em class="kr">因此是一个</em> <strong class="js iu"> <em class="kr"> Getter，</em> </strong> <em class="kr">因为没有getter </em>就没有Setter)，那是行不通的！</p><blockquote class="ko kp kq"><p id="bce0" class="jq jr kr js b jt ju jv jw jx jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kn im bi translated"><strong class="js iu"> Getters </strong>是实际调用隐藏函数来获取值的属性。<strong class="js iu">设置器</strong>是实际调用隐藏函数来设置值的属性。</p><p id="47f0" class="jq jr kr js b jt ju jv jw jx jy jz ka ks kc kd ke kt kg kh ki ku kk kl km kn im bi translated">src:你不知道Js-凯尔·辛普森</p></blockquote><p id="7904" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">考虑:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="25ff" class="le lf it la b gy lg lh l li lj">const obj = {</span><span id="2e5c" class="le lf it la b gy lk lh l li lj">  get a() {</span><span id="fe47" class="le lf it la b gy lk lh l li lj">    return this._a</span><span id="e07a" class="le lf it la b gy lk lh l li lj">  },</span><span id="f03e" class="le lf it la b gy lk lh l li lj">  set a(value) {</span><span id="74e5" class="le lf it la b gy lk lh l li lj">    this._a = value + 10</span><span id="4e11" class="le lf it la b gy lk lh l li lj">  }</span><span id="bfb5" class="le lf it la b gy lk lh l li lj">}</span><span id="299a" class="le lf it la b gy lk lh l li lj">obj.a = 20</span><span id="67e6" class="le lf it la b gy lk lh l li lj">console.log(obj.a); // --&gt; 30</span></pre><p id="c637" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当我们试图将20赋给' a '属性时，<strong class="js iu"> setter </strong>方法被自动调用，并将10加到名为' _a '的属性的值上(这是一个任意的名称，您可以随意命名)。然后当我们想要检索它的值时，一个<strong class="js iu"> getter </strong>方法被自动调用并返回' _a + 10 '即30。</p><p id="8048" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当你试图在你的对象<strong class="js iu">、</strong>中添加一个属性时，如果在<strong class="js iu"> __proto__ </strong>链上找到它，但是使用<strong class="js iu"> Setter </strong>方法<strong class="js iu">、</strong>将调用<strong class="js iu"> Setter </strong>方法，而不是<strong class="js iu">隐藏</strong>属性:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="fb77" class="le lf it la b gy lg lh l li lj">const obj = {</span><span id="fb3d" class="le lf it la b gy lk lh l li lj">  get a() {</span><span id="bd40" class="le lf it la b gy lk lh l li lj">    return this._a</span><span id="6d5c" class="le lf it la b gy lk lh l li lj">  },</span><span id="56a6" class="le lf it la b gy lk lh l li lj">  set a(value) {</span><span id="cc15" class="le lf it la b gy lk lh l li lj">    this._a = value + 10</span><span id="233f" class="le lf it la b gy lk lh l li lj">  }</span><span id="351d" class="le lf it la b gy lk lh l li lj">}</span><span id="2392" class="le lf it la b gy lk lh l li lj">obj.a = 10</span><span id="9832" class="le lf it la b gy lk lh l li lj">const obj2 = Object.create(obj)</span><span id="0e9c" class="le lf it la b gy lk lh l li lj">obj2.a = 100</span><span id="7299" class="le lf it la b gy lk lh l li lj">console.log(obj2.a); // --&gt; 110</span><span id="bba2" class="le lf it la b gy lk lh l li lj">console.log(obj.a); // --&gt; 20</span></pre><h1 id="8c84" class="lx lf it bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">结论:</h1><p id="fc34" class="pw-post-body-paragraph jq jr it js b jt mu jv jw jx mv jz ka kb mw kd ke kf mx kh ki kj my kl km kn im bi translated">当你创建一个新对象时，一个名为<strong class="js iu"> __proto__ </strong>的新属性被定义在其中。此属性的行为相当于对另一个对象的引用，该对象默认为Object.prototype。</p><p id="c686" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当你在你的对象中创建一个新属性时，在<strong class="js iu"> __proto__链</strong>中具有相同名称的属性会被新属性自动<strong class="js iu">隐藏</strong>，仅当:</p><p id="7d46" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> 1- </strong>在<strong class="js iu">链</strong>上找到的属性没有将<em class="kr">可写</em>设置为<strong class="js iu">假。</strong></p><p id="7ba3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> 2- </strong>在<strong class="js iu">链</strong>上找到的较高属性没有<strong class="js iu"> setter </strong>方法。</p></div><div class="ab cl mz na hx nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="im in io ip iq"><div class="kv kw kx ky gt ng"><a href="https://skilled.dev" rel="noopener  ugc nofollow" target="_blank"><div class="nh ab fo"><div class="ni ab nj cl cj nk"><h2 class="bd iu gy z fp nl fr fs nm fu fw is bi translated">编写面试问题</h2><div class="nn l"><h3 class="bd b gy z fp nl fr fs nm fu fw dk translated">一个完整的平台，在这里我会教你找到下一份工作所需的一切，以及…</h3></div><div class="no l"><p class="bd b dl z fp nl fr fs nm fu fw dk translated">技术开发</p></div></div><div class="np l"><div class="nq l nr ns nt np nu ln ng"/></div></div></a></div></div></div>    
</body>
</html>