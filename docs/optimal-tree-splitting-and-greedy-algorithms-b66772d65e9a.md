# 最优树分裂和贪婪算法

> 原文：<https://levelup.gitconnected.com/optimal-tree-splitting-and-greedy-algorithms-b66772d65e9a>

![](img/7362184fefd3891c0f9f951ccbf155bf.png)

这篇文章将解决一个最优分割一棵树的问题(或者从树上移除边)，并且将讨论贪婪算法如何简单地解决这个问题。整个解决方案适合大约 40 行代码。

*随意阅读一篇* [*几篇老帖子*](https://cppcodingzen.com/?p=2450) *阅读更多关于贪婪算法的内容。*

# 问题:

给你一个偶数节点的树。将父节点和子节点之间的每个连接视为一条“边”。您可能希望删除其中的一些边，这样剩下的断开连接的子树每个都有偶数个节点。

例如，假设您的输入是下面的树:

```
 1 
 / \ 
2   3 
   / \ 
  4   5 
/ | \ 
6 7 8
```

在这种情况下，移除边(3，4)满足我们的要求。

编写一个函数，返回您可以移除的最大*边数，同时仍然满足此要求。*

# 解决方案:

像许多涉及树木的问题一样，解决方案包括局部思考

1.  寻找在给定节点*及其所有子节点上执行的公共操作。*
2.  以及组合对孩子的解决方案以形成问题的解决方案。

我们将使用整数的简单属性——特别是奇数整数和偶数整数来帮助我们开发这些局部解决方案。

1.  两个奇数之和是偶数。
2.  两个偶数之和是偶数
3.  奇数和偶数之和是奇数。

这三个基本属性将如何帮助我们？

再来看一下问题陈述:给你一棵节点数为偶数的树。树的*根*算作一个节点。因此，*树中剩余节点总数为奇数！并且通过使用上面的属性(3 ),至少存在一个具有奇数个节点的根的子树。这个属性非常重要，我们将在下面重点介绍:*

> 树中的节点数(根之外)是奇数。根的至少一个子树具有奇数个节点。

同样，这个属性如何帮助我们开发一个贪婪的算法？

再次考虑包含奇数个节点的子树——在我们的问题示例中，它是一个标记为“2”的单节点子树。我们能去掉连接这个子树和根的边吗？ ***号*** 因为那会导致两个不相连的子树，都是奇数个节点。无论我们进一步做什么，我们都不会再从它们那里得到*甚至*数量的节点了！

类似地，考虑包含*甚至*个节点的子树——在我们的问题示例中，它是一个以‘3’为根的六节点子树。我们能去掉连接这个子树和根的边吗？ ***是的！*** ，而事实上，这个方案是最优的！(我们可以通过一个矛盾来证明:假设最优解不包含这条边，然后证明我们总是可以进一步去掉这条边，从而得出一个更好的解！).

这两个局部属性为我们提供了一个简单的局部解决方案:

1.  迭代给定*节点的所有子节点。*持续*计数*要移除的边的总数。
2.  如果一个子树有奇数个节点，什么都不做。
3.  如果子子树有偶数个节点，则 count 增加 1。
4.  最后，在每个*子节点*上递归调用相同的函数，递归更新*计数。*

下面是算法的实现。让我们从一个简单的*节点的递归定义开始:*

用于表示树的节点的简单定义

让我们从一个简单的递归助手方法开始，该方法计算*大小、*或以一个节点为根的子树中的节点数。请注意，我们使用了*记忆*将之前计算的值保存在哈希表中，以便于查找，并避免重复计算。

查找给定节点的子树大小(即子树中的节点数)的辅助方法

我们现在准备开发递归方法，使用上面的递归函数和两个简单规则来计算给定节点的最大切割数:

1.  对于节点的每个*子节点*

*   递归计算孩子的最大切割数。姑且称之为 *max_cuts。*
*   如果以该子树为根的子树有一个*偶数大小*，则给 *max_cuts* 加 1。

1.  将所有子节点的所有 *max_cut* 值相加，计算出父节点的 *max_cut* 值。

当然，我们将使用内存化来存储先前为一个节点计算的 *max_cut* 。

基于记忆化的递归 max_cuts 实现

# 复杂性

因为记忆化，

1.  我们恰好访问树的每个节点一次。为该节点获得的所有结果计数都被插入到哈希表中，并在 O(1)时间内立即返回..
2.  对于每个节点，我们执行恒定量的工作。

结果，算法的总复杂度是 O(N ),其中 N 是树的节点总数。

# 测试

测试是这个问题中最有趣的部分之一。为了测试复杂的树结构，我们应该能够快速构建复杂的树。这里有一个使用节点大小的数组构建复杂树的简单方法。数组中的每个元素对应于树中的一个节点。数组中的元素表示该节点的子节点数。

例如，上面示例图中的根节点有两个子节点(分别标记为“2”和“3”)。因此，数组的第一个元素的值为 2。一旦我们耗尽了根，我们就按顺序进入它的子节点。第一个孩子没有孩子，第二个孩子有两个孩子(分别标记为“4”和“5”)。因此，数组接下来的两个元素分别是 0 和 2。完整的数组看起来像`[2, 0, 2, 3, 0, 0, 0, 0]`

这是一个类似 BFS 的函数，它使用一个数组来构造树。

简单的助手功能来建立树。

有了这个方便的助手函数，我们终于准备好使用 *GUnit 测试*来测试几个简单的树案例了。

测试 max_cuts 的单元测试

*原载于*[](https://cppcodingzen.com/?p=3001)**。**