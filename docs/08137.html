<html>
<head>
<title>Checking if a user owns a domain with JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用JavaScript检查用户是否拥有一个域</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/checking-if-a-user-owns-a-domain-with-javascript-e5a4e7a1b15a?source=collection_archive---------28-----------------------#2021-04-04">https://levelup.gitconnected.com/checking-if-a-user-owns-a-domain-with-javascript-e5a4e7a1b15a?source=collection_archive---------28-----------------------#2021-04-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/58a401244f7d4ba9df3ed3fda9f435a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UNk9CRHmNrIPFKUfZgjouw.png"/></div></div></figure><div class=""/><p id="6880" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们正在使用的技术是谷歌、微软和其他公司用来验证你在某个领域拥有某种权限的技术。因此，虽然这不是万无一失的，但至少我们有一个很好的公司！</p><p id="2442" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">本文中的代码是TypeScript，但是同样的方法也适用于大多数语言。</p><h2 id="3b7c" class="kz la je bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">概观</h2><p id="abc4" class="pw-post-body-paragraph kb kc je kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">我看到的所有验证方法都依赖于用户能够以某种方式修改网站——这是有意义的，因为你要检查他们是否对他们试图使用的网站有控制权。</p><p id="64bc" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">他们中的大多数人似乎已经决定使用某种形式的DNS条目——一种他们可以检查实际存在的特殊记录。</p><h2 id="4ff8" class="kz la je bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">快速DNS介绍</h2><p id="a9f1" class="pw-post-body-paragraph kb kc je kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">这是非常简短的；关于(稍微)更全面的DNS介绍，见<a class="ae lx" href="https://www.solarwinter.net/domains/" rel="noopener ugc nofollow" target="_blank">我的另一篇文章</a>。</p><p id="f4ca" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">域名系统由向访问互联网的计算机提供信息的记录组成。有相当多不同类型的记录。最基本的一个叫做A记录，A for地址。它实际上是说“这个文本—foobar.example.com—指向这个IP地址”。</p><p id="08d3" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有许多保留地址有特殊的含义。一个有用的地址是<code class="fe ly lz ma mb b">127.0.0.1</code>——它总是意味着“这台计算机”。它的符号名是<code class="fe ly lz ma mb b">localhost</code>。</p><h2 id="5736" class="kz la je bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">这个计划</h2><p id="1ee3" class="pw-post-body-paragraph kb kc je kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">我们希望检查用户是否可以修改该域的DNS条目，但不要有任何特别混乱或复杂的事情——我们把它做得越复杂，用户错误就越有可能出现。</p><p id="cbea" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最简单的方法——生成一个随机子域，让他们创建一个指向<code class="fe ly lz ma mb b">127.0.0.1</code>的A记录。</p><h2 id="3f90" class="kz la je bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">生成别名</h2><p id="2321" class="pw-post-body-paragraph kb kc je kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">有许多不同的方法可以做到这一点。我选择使用Node <a class="ae lx" href="https://www.npmjs.com/package/uuid" rel="noopener ugc nofollow" target="_blank"> uuid </a>模块，取前8个字符。选择8是因为它对于我们的目的来说足够随机，而且它是v4 UUID中的第一个“块”。</p><pre class="mc md me mf gt mg mb mh mi aw mj bi"><span id="6f84" class="kz la je mb b gy mk ml l mm mn">siteDetails["alias"] = uuid().substr(0, 8);</span></pre><h2 id="c60e" class="kz la je bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">检查别名</h2><p id="0316" class="pw-post-body-paragraph kb kc je kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">使用节点<a class="ae lx" href="https://nodejs.org/api/dns.html" rel="noopener ugc nofollow" target="_blank"> dns模块</a>我们可以解析我们创建的别名；我们在它后面追加用户的域，使<code class="fe ly lz ma mb b">alias</code>成为一个子域。</p><p id="3995" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">普通的<code class="fe ly lz ma mb b">dns</code>方法是基于回调的；它还提供了一组基于承诺的API。为了方便起见，我们将使用<a class="ae lx" href="https://nodejs.org/api/dns.html#dns_dnspromises_resolve_hostname_rrtype" rel="noopener ugc nofollow" target="_blank">解析方法</a>。</p><pre class="mc md me mf gt mg mb mh mi aw mj bi"><span id="3328" class="kz la je mb b gy mk ml l mm mn">import dns from "dns";<br/>const dnsPromises = dns.promises;<br/><br/>type Site = {<br/>  alias: string;        // Alias we'll be verifying<br/>  domain: string;       // Domain the user gave us<br/>  verified: boolean;    // Is it verified yet<br/>}<br/><br/>async function verifySite(site: Site) {<br/>  try {<br/>    const res = await dnsPromises.resolve(site.alias + "." + site.domain);<br/>    const valid = ((res.length == 1) &amp;&amp; (res[0] == "127.0.0.1"));<br/>    site.verified = valid;<br/>  } catch (err) {<br/>    console.error(`Error ${err} doing site ${site.id} verification`);<br/>  }<br/>}</span></pre><p id="6a07" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们期望查找的结果是一个单独的条目，<code class="fe ly lz ma mb b">127.0.0.1</code> -如果是的话，我们称之为已验证。最后，我们确保数据反映了我们刚刚发现的内容。</p><h2 id="f1c5" class="kz la je bd lb lc ld dn le lf lg dp lh km li lj lk kq ll lm ln ku lo lp lq lr bi translated">在后台运行检查</h2><p id="8322" class="pw-post-body-paragraph kb kc je kd b ke ls kg kh ki lt kk kl km lu ko kp kq lv ks kt ku lw kw kx ky im bi translated">我们现在有了一个可以用来验证域名的函数。最后一个阶段是让它在后台定期运行，而不是按需运行。</p><p id="14db" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我使用的实现如下。我没有包括实用函数(比如<code class="fe ly lz ma mb b">getAllSites</code>)，但是没有这些，代码应该还是可以理解的。</p><p id="1b8b" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe ly lz ma mb b">startBackground</code>使用环境中的<code class="fe ly lz ma mb b">DOMAIN_VERIFY_PERIOD_SECONDS</code>，如果它被定义了，或者如果它没有被定义，则使用300秒。然后它使用<code class="fe ly lz ma mb b">setInterval</code>来调度<code class="fe ly lz ma mb b">verifySites</code>。<code class="fe ly lz ma mb b">setInterval</code>以毫秒为自变量，所以我们先转换。</p><p id="484b" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe ly lz ma mb b">verifySites</code>简单地获取站点的当前列表，并在所有站点上运行<code class="fe ly lz ma mb b">verifySite</code>。</p><p id="9a0e" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后，<code class="fe ly lz ma mb b">stopBackground</code>将取消已经计划运行的间隔功能。</p><pre class="mc md me mf gt mg mb mh mi aw mj bi"><span id="af58" class="kz la je mb b gy mk ml l mm mn">import { getAllSites } from "./queries";<br/><br/>let domainCheckId: NodeJS.Timeout | null = null;<br/><br/>export async function verifySites() {<br/>  const sites: Site[] = await getAllSites();<br/>  sites.forEach(site =&gt; verifySite(site));<br/>}<br/><br/>export function startBackground(): void {<br/>  const SECOND = 1000;<br/>  const period: number = parseInt(process.env.DOMAIN_VERIFY_PERIOD_SECONDS || "300");<br/>  console.log(`Starting domainCheck, period ${period} seconds`);<br/><br/>  domainCheckId = setInterval(verifySites, SECOND * period);<br/>}<br/><br/>export function stopBackground(): void {<br/>  if (domainCheckId) {<br/>    clearInterval(domainCheckId);<br/>    domainCheckId = null;<br/>  }<br/>}</span></pre><p id="cd71" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">就这样—这些函数足以开始在后台验证域。如果你使用它，让我知道！</p></div></div>    
</body>
</html>