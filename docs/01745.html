<html>
<head>
<title>How to Build a DIY Web Scraper in Any Language</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用任何语言建立一个自己动手的网页抓取器</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-build-a-diy-web-scraper-in-any-language-1104ac0713cd?source=collection_archive---------3-----------------------#2020-01-27">https://levelup.gitconnected.com/how-to-build-a-diy-web-scraper-in-any-language-1104ac0713cd?source=collection_archive---------3-----------------------#2020-01-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/5727068ea1ee00b34630f460caee2980.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I1Oh4X6ij3Zg72BKUwGIsQ.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">图片来源:<a class="ae jd" href="https://www.shutterstock.com/g/franz12" rel="noopener ugc nofollow" target="_blank">Franz 12</a>/<a class="ae jd" href="http://shutterstock.com" rel="noopener ugc nofollow" target="_blank">shutterstock.com</a></figcaption></figure><div class=""/><p id="898a" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">制作自己的网页抓取器(或爬虫)出奇的简单。它也可能非常有用。让我告诉你为什么:</p><p id="6212" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我写的第一个scraper是大量下载我在播客时代之前曾经听过的一个老广播节目的存档片段。是的，我就是那么老。然后我就可以装上我的第一个mp3播放器(如下图),坐公交车去学校。</p><figure class="lc ld le lf gt is gh gi paragraph-image"><div class="gh gi lb"><img src="../Images/e5bec3a5d60c9f8164aad7cfeae5695d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*lP5reAIE-MEpMgT9Gl-SaA.jpeg"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk translated">图片来源:<a class="ae jd" href="https://en.wikipedia.org/wiki/User:Brendinooo" rel="noopener ugc nofollow" target="_blank"> Brendinooo </a>在<a class="ae jd" href="https://en.wikipedia.org/wiki/" rel="noopener ugc nofollow" target="_blank">英文维基百科</a></figcaption></figure><p id="8627" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我说过我老了吗？iPods当时还不存在。</p><p id="a7ca" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我写的第二个scraper是一个线程Python交易。给它一个网站列表和一个文件或目录列表，它会告诉你哪一个是后者的主机。这可以用于——咳咳——各种目的。</p><p id="4477" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最近，我的任务是开发一些基本的东西来抓取一个领域，并提供搜索引擎优化分析。我没有让我的工具硬适应这个问题，而是首先创建了一个易于扩展的通用基础。这个过程激发了这篇文章。</p><p id="c5e1" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我知道有很多现有的工具可以帮助你抓取和抓取网页。然而，自己编写一个允许你创建一些轻量级的东西，或者容易适应或者为你的特定用例定制。</p><p id="6f57" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">自己动手构建有助于提高您的开发技能和对技术工作原理的理解。另一种方法是必须通读文档，找出如何实现一个现有的解决方案，这个解决方案通常被嵌套菜单或配置标志弄得臃肿不堪。</p><p id="870a" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我选择了DIY方法。鉴于我对PHP + cURL技术的熟悉，我在最近的尝试中使用了PHP+cURL，但是我在这里分享的原理和(伪)代码是通用的，可以应用于任何语言。</p><h1 id="4dd3" class="lg lh jg bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">考虑以下情况</h1><p id="82b3" class="pw-post-body-paragraph kd ke jg kf b kg me ki kj kk mf km kn ko mg kq kr ks mh ku kv kw mi ky kz la ij bi translated">想想HTML中使用<code class="fe mj mk ml mm b">&lt;a&gt;</code>标签的不同方式。你很快就会列出你需要考虑的事情。以下是一些显而易见的例子:</p><ol class=""><li id="4984" class="mn mo jg kf b kg kh kk kl ko mp ks mq kw mr la ms mt mu mv bi translated">标签通常包含链接，但是它们也可以包含其他东西:锚、内联JavaScript、<code class="fe mj mk ml mm b">mailto:</code>地址、替代协议，或者它们可以是空白的。你的scraper需要排除这些情况，只关注超链接。</li><li id="c5ce" class="mn mo jg kf b kg mw kk mx ko my ks mz kw na la ms mt mu mv bi translated">超链接可以采用不同的格式。它们可以是绝对的，并以<code class="fe mj mk ml mm b"><a class="ae jd" rel="noopener ugc nofollow" target="_blank" href="/,">http://</a></code> <a class="ae jd" rel="noopener ugc nofollow" target="_blank" href="/,">、</a> <code class="fe mj mk ml mm b">https://</code>或<code class="fe mj mk ml mm b">//</code>开始(保持当前协议)。它们也可以是相对的。</li></ol><p id="cb66" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">既然您已经考虑了从<code class="fe mj mk ml mm b">&lt;a&gt;</code>标签中提取链接所涉及的内容，那么就花些时间考虑组成一个典型URL的不同部分。看一看:</p><p id="1478" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mj mk ml mm b">https://sub.domain.tld/folder/file.ext?param1=a&amp;param2=b#fragment</code></p><p id="6631" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">分解如下:</p><ol class=""><li id="17e0" class="mn mo jg kf b kg kh kk kl ko mp ks mq kw mr la ms mt mu mv bi translated"><strong class="kf jh">协议:</strong> https://</li><li id="63c2" class="mn mo jg kf b kg mw kk mx ko my ks mz kw na la ms mt mu mv bi translated"><strong class="kf jh">主机:</strong>子域. tld</li><li id="3ea3" class="mn mo jg kf b kg mw kk mx ko my ks mz kw na la ms mt mu mv bi translated"><strong class="kf jh">路径:</strong>/文件夹/文件. ext</li><li id="8221" class="mn mo jg kf b kg mw kk mx ko my ks mz kw na la ms mt mu mv bi translated"><strong class="kf jh">查询参数:</strong>？param1=a &amp; param2=b</li><li id="21d6" class="mn mo jg kf b kg mw kk mx ko my ks mz kw na la ms mt mu mv bi translated"><strong class="kf jh">片段:</strong>#片段</li></ol><p id="c1a4" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当你抓取相对链接时，你会想把它们转换成绝对链接，这意味着添加协议、主机和文件夹——它们被获取的路径的一部分。同时掉落片段:<code class="fe mj mk ml mm b">page.ext#heading1</code>和<code class="fe mj mk ml mm b">page.ext#heading2</code>是等价的，应该只访问一次。</p><p id="024a" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其他一些值得思考的警告:</p><ol class=""><li id="5b00" class="mn mo jg kf b kg kh kk kl ko mp ks mq kw mr la ms mt mu mv bi translated"><code class="fe mj mk ml mm b">/</code>和<code class="fe mj mk ml mm b">/index.ext</code>以及<code class="fe mj mk ml mm b">/path</code>和<code class="fe mj mk ml mm b">/path/</code>的区别</li><li id="4576" class="mn mo jg kf b kg mw kk mx ko my ks mz kw na la ms mt mu mv bi translated">您是否希望将<code class="fe mj mk ml mm b">/page.ext</code>和<code class="fe mj mk ml mm b">/page.ext?param=1</code>视为相同或不同的页面</li><li id="957a" class="mn mo jg kf b kg mw kk mx ko my ks mz kw na la ms mt mu mv bi translated">如果你想让你的刮刀停留在子域内或穿越子域</li><li id="ad61" class="mn mo jg kf b kg mw kk mx ko my ks mz kw na la ms mt mu mv bi translated">应该避免无限循环。不要重新访问同一个页面，因为它在多个地方被引用</li><li id="5be8" class="mn mo jg kf b kg mw kk mx ko my ks mz kw na la ms mt mu mv bi translated">构建一个参数来指定要抓取的最大页数——这可以防止事情失去控制，尤其是在开发和测试期间</li><li id="eb8c" class="mn mo jg kf b kg mw kk mx ko my ks mz kw na la ms mt mu mv bi translated">注意超时、HTTP状态码、重定向、你的scraper的用户代理和“referer”参数、cookies、认证信息等。</li></ol><p id="c983" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">考虑到所有这些，是时候开始开发了。</p><h1 id="fc63" class="lg lh jg bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">测试驱动开发</h1><p id="49b3" class="pw-post-body-paragraph kd ke jg kf b kg me ki kj kk mf km kn ko mg kq kr ks mh ku kv kw mi ky kz la ij bi translated">我喜欢TDD，你也应该喜欢。它非常适合这种类型的项目。不要重复访问web上的某个网站并引起怀疑(尤其是如果你陷入了一个无限循环)，而是在开发期间制作一组本地托管的测试页面来指导你的工作。</p><p id="a84b" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从广义上来说，您的测试页面应该涵盖我们在上一节中讨论的所有内容。您所需要的只是两个HTML页面，它们具有不同格式的指向内部和外部位置的链接。这让您可以确保成功地提取和抓取它们。还应该有一些包含锚之类的东西的标签，以确保它们不会绊倒你的刮刀。还包括你正在构建的任何特定内容的例子，比如媒体文件或从中提取数据的特定HTML标签。</p><p id="ebcb" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当你开发的时候，用你的刮刀刮这些页面。首先，让它从索引页面聚合和输出链接。然后让它爬行到第二页并停止，收集更多的信息。然后在执行增量测试的同时，继续将其构建到最终形式。标准开发流程，真的。</p><p id="93c0" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你不想自己建立这组页面，我已经为你做了<a class="ae jd" href="https://github.com/kld87/php-curl-scraper/tree/master/test" rel="noopener ugc nofollow" target="_blank">这里</a>。快速浏览每一页，了解其目的，并根据需要进行调整。</p><h1 id="1704" class="lg lh jg bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">准备3个文件</h1><p id="d7a2" class="pw-post-body-paragraph kd ke jg kf b kg me ki kj kk mf km kn ko mg kq kr ks mh ku kv kw mi ky kz la ij bi translated">因为这是一个与语言无关的教程，我将分享3个核心类的伪代码，你可以用它们作为基本结构和行为分段。简而言之，它们是:</p><ol class=""><li id="f7b3" class="mn mo jg kf b kg kh kk kl ko mp ks mq kw mr la ms mt mu mv bi translated">一个“<strong class="kf jh">页面</strong>”对象，解析并存储一个web请求的结果，该请求具有帮助提取数据的功能。</li><li id="0711" class="mn mo jg kf b kg mw kk mx ko my ks mz kw na la ms mt mu mv bi translated">一个"<strong class="kf jh"> Scraper </strong>"对象，它处理抓取操作的逻辑和从检索到的数据创建页面。</li><li id="286d" class="mn mo jg kf b kg mw kk mx ko my ks mz kw na la ms mt mu mv bi translated">一个"<strong class="kf jh">控制器</strong>"作为程序的入口点，该程序接收参数，实例化并调用一个scraper，并以您想要的格式输出它提取的数据。</li></ol><p id="745c" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">显然有很多方法可以解决这个问题，这将作为一个引导你思考的向导。适应您认为合适的用例、编码风格和语言选择。我还将进一步包含我实际实现这种方法的链接。</p><h2 id="a584" class="nb lh jg bd li nc nd dn lm ne nf dp lq ko ng nh lu ks ni nj ly kw nk nl mc nm bi translated">页面对象</h2><p id="66d2" class="pw-post-body-paragraph kd ke jg kf b kg me ki kj kk mf km kn ko mg kq kr ks mh ku kv kw mi ky kz la ij bi translated">编写一个简单的Page对象，程序的其余部分将使用它来存储和提取抓取的信息。它的构造函数应该接受对web请求的响应，包括HTML内容和相关的元数据。这个类应该有一些方便的函数，可以返回相关的信息，比如页面上的链接、元数据，比如状态代码、url和加载时间，以及您想要提取的任何附加信息——下面我将使用页面的<code class="fe mj mk ml mm b">&lt;title&gt;</code>标签的内容作为例子。</p><figure class="lc ld le lf gt is"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="7d3f" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf jh">注意:</strong> <em class="np">大多数语言都会有一些内置的调用来解析和处理XML/HTML之类的标记(我在这里称之为</em> <code class="fe mj mk ml mm b">MLPARSER</code> <em class="np">)。那些没有的将会有图书馆为你做它。找到适合你的给定语言的方法，而不是重新发明轮子，记住:</em> <a class="ae jd" href="https://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags" rel="noopener ugc nofollow" target="_blank"> <em class="np">你不能用正则表达式来解析HTML </em> </a> <em class="np">(看看这个问题和它的第一个回答就知道了)。</em></p><h2 id="f625" class="nb lh jg bd li nc nd dn lm ne nf dp lq ko ng nh lu ks ni nj ly kw nk nl mc nm bi translated">刮刀物体</h2><p id="fbc5" class="pw-post-body-paragraph kd ke jg kf b kg me ki kj kk mf km kn ko mg kq kr ks mh ku kv kw mi ky kz la ij bi translated">您的scraper对象应该使用一个参数来构造，以便从目标URL开始抓取。它应该有一个函数来控制给定数量的页面的抓取，存储抓取的页面，然后返回它们。它将需要记住哪些网页已经访问过，并有一个功能，以确定哪个网页应该访问下一步。它还需要一些辅助函数来排序和跟踪内部和外部URL，并将相对链接变成绝对链接。</p><p id="9182" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样写允许重复调用<code class="fe mj mk ml mm b">scrape()</code>函数而不会引起任何问题。您的控制器逻辑可以根据目前返回的内容选择是否继续抓取目标，而无需重新初始化或重新实例化任何内容。</p><figure class="lc ld le lf gt is"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="d833" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf jh">注1: </strong> <em class="np">我在这个文件中把URL分解成内部/外部类别，并使它们成为绝对的。这也可以在Page类中完成，这是一个偏好问题。因为在调试之后，我基本上放弃了聚集的URL，只使用它们来控制，所以我在这里做了。</em></p><p id="0be9" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf jh">注2: </strong> <em class="np">与标记解析器注一样，我们调用一个泛型</em> <code class="fe mj mk ml mm b">WEBLIBRARY</code> <em class="np">来代替您的语言或所选库发起并返回HTTP请求的结果，并将相对链接转换为绝对链接的能力。</em></p><h2 id="0890" class="nb lh jg bd li nc nd dn lm ne nf dp lq ko ng nh lu ks ni nj ly kw nk nl mc nm bi translated">控制器</h2><p id="3102" class="pw-post-body-paragraph kd ke jg kf b kg me ki kj kk mf km kn ko mg kq kr ks mh ku kv kw mi ky kz la ij bi translated">控制器文件应该相当简单明了，主要取决于语言和情况。首先解析用户输入的目标URL、抓取限制和您的用例的任何其他选项。然后实例化一个Scraper对象，调用它的<code class="fe mj mk ml mm b">scrape()</code>函数，然后根据需要格式化输出你的结果。</p><figure class="lc ld le lf gt is"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="326e" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf jh">注意:</strong> <em class="np">回复:上面的TDD部分，我已经在</em> <code class="fe mj mk ml mm b">scrapeTarget()</code> <em class="np">里面的最明智(对我来说)的地方输出了一些开发和调试期间的数据。</em></p><h2 id="7b50" class="nb lh jg bd li nc nd dn lm ne nf dp lq ko ng nh lu ks ni nj ly kw nk nl mc nm bi translated">其他文件</h2><p id="f896" class="pw-post-body-paragraph kd ke jg kf b kg me ki kj kk mf km kn ko mg kq kr ks mh ku kv kw mi ky kz la ij bi translated">根据你使用的语言和你想要达到的目标，你可能会得到一些core 3的补充文件。一个通用的工具文件可以帮助清理和组织一些代码和函数，这些代码和函数可以在你的scraper中共享。您可能还拥有一些外部库，用于处理HTML解析和执行web请求，以及您选择的语言进行引导所需的任何其他东西。</p><p id="f196" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于错误处理，我做得非常一般，基本上是让我的程序死亡，如果它的一个web请求失败，就抛出一个错误，因为我正在监督它的操作。您可以根据需要选择添加更健壮的错误处理。</p><h2 id="6ea6" class="nb lh jg bd li nc nd dn lm ne nf dp lq ko ng nh lu ks ni nj ly kw nk nl mc nm bi translated">我的实现</h2><p id="3b0f" class="pw-post-body-paragraph kd ke jg kf b kg me ki kj kk mf km kn ko mg kq kr ks mh ku kv kw mi ky kz la ij bi translated">如前所述，我是用PHP和cURL做的。你可以看看我的3个文件，分别是<a class="ae jd" href="https://github.com/kld87/php-curl-scraper/blob/master/Util/Page.php" rel="noopener ugc nofollow" target="_blank">页面</a>、<a class="ae jd" href="https://github.com/kld87/php-curl-scraper/blob/master/Util/Scraper.php" rel="noopener ugc nofollow" target="_blank">刮刀</a>和<a class="ae jd" href="https://github.com/kld87/php-curl-scraper/blob/master/Controllers/ScrapeController.php" rel="noopener ugc nofollow" target="_blank">控制器</a>——外加一个上面讨论过的<a class="ae jd" href="https://github.com/kld87/php-curl-scraper/blob/master/Util/CurlUtil.php" rel="noopener ugc nofollow" target="_blank">实用程序文件</a>。或者直接挖通<a class="ae jd" href="https://github.com/kld87/php-curl-scraper" rel="noopener ugc nofollow" target="_blank">完成回购</a>。</p><h1 id="0d0a" class="lg lh jg bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">前进并编码</h1><p id="d5fd" class="pw-post-body-paragraph kd ke jg kf b kg me ki kj kk mf km kn ko mg kq kr ks mh ku kv kw mi ky kz la ij bi translated">这应该给你一个在编写自己的scraper时需要考虑的事情的想法，以及如何完成这个壮举的大致想法。有许多不同的方法可以解决这个问题，但是我建议创建一个通用库，让您可以管理页面、处理抓取，然后控制程序的整体流程——可以在此基础上进行调整。</p><p id="0942" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">祝好运，请负责任地刮！</p></div></div>    
</body>
</html>