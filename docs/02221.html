<html>
<head>
<title>Custom Listeners In Android</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android中的自定义监听器</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/custom-listeners-in-android-89ebdefe3e99?source=collection_archive---------7-----------------------#2020-02-27">https://levelup.gitconnected.com/custom-listeners-in-android-89ebdefe3e99?source=collection_archive---------7-----------------------#2020-02-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/be7ed68f4487107806c03ae30b132939.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dUWkV54dAlAtSF3DOlxnPQ.png"/></div></div></figure><p id="2f84" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">监听器是Android开发的主要部分。它们是创建异步回调的一种非常流行的方式。侦听器通常用于实现事件发生时运行的代码。</p><p id="ffd6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你在Android开发方面有点经验，你可能会遇到监听器的一个常见用法是按钮的内置<code class="fe kz la lb lc b">onClickListener</code>。我们通常将<code class="fe kz la lb lc b">onClickListener</code>设置在一个按钮上，带有按钮被点击时应该运行的代码，在本例中是事件。在Java中，通常是这样的:</p><pre class="ld le lf lg gt lh lc li lj aw lk bi"><span id="6445" class="ll lm it lc b gy ln lo l lp lq">Button button = findViewById(R.id.example);<br/>button.setOnClickListener(new View.OnClickListener(){<br/>    @Override<br/>    public void onClick(View view) {<br/>        //Do some work here<br/>    }<br/>});</span></pre><p id="f060" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但是除了我上面所描述的，我们可以创建我们的自定义侦听器，回调附加到从我们代码的特定区域触发的事件。</p><p id="9bdf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">但是为什么呢？</strong></p><figure class="ld le lf lg gt ju gh gi paragraph-image"><div class="gh gi lr"><img src="../Images/6271f1c7a9a29f086e26b65c69a942ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:942/format:webp/1*RpZ1eKgJ5ZF1SJ7vtTyTvw.jpeg"/></div></figure><p id="8774" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">以下是一些我们可能需要创建自定义侦听器的情况:</p><ul class=""><li id="6b41" class="ls lt it kd b ke kf ki kj km lu kq lv ku lw ky lx ly lz ma bi translated">当我们需要从一个片段向一个活动发出一个事件时</li><li id="8651" class="ls lt it kd b ke mb ki mc km md kq me ku mf ky lx ly lz ma bi translated">当我们需要从适配器内部发出一个事件到一个活动或片段时</li></ul><p id="e265" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一般来说，当您有一个“子对象”和一个“父对象”或处理程序时，监听器是有用的，其中父对象是创建子对象的新实例的对象。并且我们有一些工作需要在父对象中完成，但也需要在子对象中发生某个事件时才完成。因此，我们必须找到一种方法，将正在讨论的事件已经在子对象中发生的事实传达给父对象。</p><p id="502a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">那么我们如何创建一个定制的监听器呢？</p><ol class=""><li id="a224" class="ls lt it kd b ke kf ki kj km lu kq lv ku lw ky mg ly lz ma bi translated">首先，在子对象中定义一个接口(适配器、片段、POJO)。然后定义将触发到父级的事件。这些事件由接口中的方法表示。Java中的一个例子是:</li></ol><pre class="ld le lf lg gt lh lc li lj aw lk bi"><span id="49f3" class="ll lm it lc b gy ln lo l lp lq">public interface CustomListener{</span><span id="8373" class="ll lm it lc b gy mh lo l lp lq">    void onDataReady(Data data);</span><span id="5a05" class="ll lm it lc b gy mh lo l lp lq">    void onSubmitForm();</span><span id="607f" class="ll lm it lc b gy mh lo l lp lq">}</span></pre><p id="57dd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在上面的例子中，<code class="fe kz la lb lc b">onDataReady(Data data)</code>和<code class="fe kz la lb lc b">onSubmitForm()</code>是表示可能发生在子对象中的事件的方法签名/回调。</p><p id="ddd7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">2.接下来，设置一个侦听器变量来存储接口中回调的特定实现。回调的实现将由父对象定义。因此，在子类中，您可以创建变量以及公共setter方法，该方法允许从父类定义侦听器回调，如下所示:</p><pre class="ld le lf lg gt lh lc li lj aw lk bi"><span id="d547" class="ll lm it lc b gy ln lo l lp lq">private CustomListener mListener;</span><span id="17c3" class="ll lm it lc b gy mh lo l lp lq">public void setCustomListener(CustomListener listener){<br/>    mListener = listener;<br/>}</span></pre><p id="cced" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您不必使用setter方法，因为有几种方法可以将侦听器回调实现传递给子对象，比如通过构造函数传递或者通过生命周期事件传递(比如在处理活动/片段通信时片段的<code class="fe kz la lb lc b">onAttach()</code>事件)。</p><p id="da7a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">3.现在我们已经创建了listener变量，我们可以在父类上实现接口，覆盖这些方法，并放入这些方法的实现，然后在子对象上设置listener实现(这是实现接口的父类)。</p><pre class="ld le lf lg gt lh lc li lj aw lk bi"><span id="f328" class="ll lm it lc b gy ln lo l lp lq">public class Parent implements Child.CustomListener{</span><span id="ce3c" class="ll lm it lc b gy mh lo l lp lq">//Some code</span><span id="8610" class="ll lm it lc b gy mh lo l lp lq">...</span><span id="47a8" class="ll lm it lc b gy mh lo l lp lq">@Override<br/>    public void onDataReady(Data data){<br/>        //some fancy implementation<br/>    }</span><span id="64e5" class="ll lm it lc b gy mh lo l lp lq">public void onSubmitForm(){<br/>       //code we want to run when this event occurs<br/>    }</span><span id="aecc" class="ll lm it lc b gy mh lo l lp lq">childObject.setCustomListener(this);</span><span id="6ba4" class="ll lm it lc b gy mh lo l lp lq">}</span></pre><p id="ff28" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">以上是在父类中创建监听器实现的一种非常常见的方式。另一种方法是在父类中创建自定义侦听器的实例(而不是让父类本身实现接口),并将该实现设置为子对象的自定义侦听器，如下所示:</p><pre class="ld le lf lg gt lh lc li lj aw lk bi"><span id="3c90" class="ll lm it lc b gy ln lo l lp lq">Child childObject = new Child();</span><span id="9c17" class="ll lm it lc b gy mh lo l lp lq">Child.CustomListener listener = new Child.CustomListener(){<br/>    @Override<br/>    public void onDataReady(Data data){<br/>        //some fancy implementation<br/>    }</span><span id="e1c1" class="ll lm it lc b gy mh lo l lp lq">    public void onSubmitForm(){<br/>       //code we want to run when this event occurs<br/>    }</span><span id="9ef5" class="ll lm it lc b gy mh lo l lp lq">}</span><span id="12ae" class="ll lm it lc b gy mh lo l lp lq">childObject.setCustomListener(listener);</span></pre><figure class="ld le lf lg gt ju gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/fee5a837889934b04813f74ab3cfca44.png" data-original-src="https://miro.medium.com/v2/resize:fit:840/format:webp/1*xzy7yJZuq97onrYS_YHUGw.png"/></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated">开个玩笑，差不多了。</figcaption></figure><p id="d643" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">4.现在，当事件发生时，子对象可以使用侦听器向父对象触发事件，并将数据(如果有)传递给父对象。例如，在子对象中，可能是这样的:</p><pre class="ld le lf lg gt lh lc li lj aw lk bi"><span id="a2fa" class="ll lm it lc b gy ln lo l lp lq">//The event "onDataReady" has occurred in the child object and we //fire up the event to the parent using the listener </span><span id="bfd7" class="ll lm it lc b gy mh lo l lp lq">public void OnSuccess(Response response){</span><span id="c54e" class="ll lm it lc b gy mh lo l lp lq">    Data data = response.getData;</span><span id="60c8" class="ll lm it lc b gy mh lo l lp lq">    listener.onDataReady(data);</span><span id="ad35" class="ll lm it lc b gy mh lo l lp lq">}</span></pre><p id="8073" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">就这样，我们完成了定制监听器的设置！如果您还没有这样做，我希望您能够开始制作和使用您的定制监听器。或者至少对它们有了更好的理解。</p></div></div>    
</body>
</html>