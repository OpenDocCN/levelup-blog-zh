# 使用 Redis 进行分析

> 原文：<https://levelup.gitconnected.com/towards-analytics-with-redis-f2bccb6db77c>

## 使用散列和二进制数据结构

![](img/4bf1e1bffa15d18ccee9425969e415f1.png)

图片作者。Redis 标识通过[https://redis.io/](https://redis.io/)。版权 Redis 有限公司

您可能想知道为什么有人会直接在 Redis 中进行任何类型的分析处理。为什么不坚持传统的 OLAP 风格的 SQL 呢？

很高兴你问了。Redis 已经存在了一段时间，是一个经过验证的高性能、低维护的数据库和优秀的多用途缓存。Redis 很特别，因为它实际上是一个**数据结构**存储，具有对复杂数据表示的高级随机访问能力:从 [**位图**](https://redis.io/commands#bitmap) 和 [**哈希**](https://redis.io/commands#hash) 集到实时 [**流**](https://redis.io/commands#stream) 类型，本质上是一个按照插入时间顺序排序的行的[排序集](https://redis.io/commands#sorted-set)，其中每一行都由一个类似哈希集的条目表示。

回到正题，Redis 支持传统分析处理数据库所不具备的访问模式，这意味着您可以灵活运用您的创造力来解决问题，否则您将需要支持多个替代数据库、流平台(Kafka/Pulsar)和 API 服务来实现*相同的结果。

接下来，我们将看看如何使用位图、散列和流数据类型来解决实际问题。

## 让 Redis 在 Docker 上运行

您可以使用 Docker 从您的终端(或最喜欢的 shell 程序)使用下面的命令启动一个单节点 Redis 集群。(*要求 [Docker 安装在您的机器上](https://www.docker.com/products/docker-desktop))。

```
docker network create --driver bridge analytics
docker run --network analytics -p 6379:6379 --name redis6 -e ALLOW_EMPTY_PASSWORD=yes -dP redis redis-server
```

该命令(您刚才运行的)将下载[最新的官方稳定 Redis 映像](https://hub.docker.com/_/redis)(在撰写本文时为 6.2.6)，除非您已经将 redis:latest 下载到 docker 映像缓存(您可以使用:`docker images redis`进行检查)，然后它将使用一个名为 *analytics* 的桥启动容器(运行)到您的主机(笔记本电脑/计算机)网络，作为一个分离的 d 进程。分离的进程只是意味着 stdout / stderr 容器日志不会通过管道传输到您的终端，如果需要，您可以稍后重新附加到容器。

接下来，我们将对 Redis 的运行做一个简单的健全性检查。在同一个终端窗口中，您可以使用 docker exec 命令来访问和执行 **redis-cli** (又名 redis shell)程序。

```
docker exec -it redis6 redis-cli
```

你会看到 *127.0.0.1:6379 >* 提示，这意味着你已经准备好摇滚我的朋友！

> **关于容器行为的说明:** *我们在前面的`docker run` *命令中创建了一个名为* ***redis6*** 的命名容器。这让我们可以使用 docker exec 命令，使用您提供的名称(redis6)而不是 docker 运行时给出的随机名称轻松访问容器。副作用是您将不得不停止并删除这个容器来修改容器配置。例如，如果您尝试再次运行该命令(从上面),您将看到以下错误消息:*
> 
> docker:来自守护程序的错误响应:冲突。容器名称“/redis6”已被容器“{长容器 uuid}”使用。您必须删除(或重命名)该容器才能重用该名称。
> 
> *您可以通过简单地执行以下命令来解决这个小问题:* `*docker stop redis6 && docker rm redis6.*`
> 
> ***最后一个关于数据持久性的小问题*** *。因为 Redis 数据库(存储为一个* rdb *文件)是在容器(redis6)内部创建和存储的，这更重要地意味着当您执行 stop &* remove *命令时，您也将删除存储在数据库中的任何数据。*
> 
> *这是因为*容器*被设计为对于特定标签和 sha256 对的生命周期是不可变的(不可更改的),而容器可以使用环境变量和卷装载来临时增加容器。实际的容器映像对您的修改没有任何记忆。这保证了在文件系统、操作系统等方面遵循严格的无意外规则的容器状态方面，您将拥有一个可靠且一致的运行时环境。*
> 
> *您可以使用* [*卷*](https://docs.docker.com/storage/volumes/) *来解决数据持久性问题，缺乏数据持久性——这些卷是附加到容器中特定路径的持久性磁盘(或内存)片。卷通常用于将机密和其他配置安装到公共基础容器映像。*

**创建和使用持久卷**现在在我们开始之前修改东西。如果您之前创建了 redis6 容器，您可以停止并删除它，然后继续使用以下命令创建 redis6 卷。

```
docker volume create redis6
```

现在您已经创建了一个持久卷，您可以将该卷挂载到 Redis 容器，然后您将有一种方法返回数据(除非您丢失了磁盘)。

> **注意**:主机上为 Docker 运行时分配的总磁盘空间将用于这个卷。您可以使用`docker volume ls`查看所有 docker 卷，使用`docker volume inspect redis6`查看 redis6 卷的特定信息。

## 使用持久卷和一致的 Redis 映像启动 Redis 备份

就像我在上面关于容器行为的说明中提到的，第一个快速启动命令创建了一个临时 Redis 容器，它会忘记在容器运行期间对它所做的任何更改。幸运的是，使用持久卷意味着您的数据将在停止/删除周期之间存在，因此您可以在最小的顾虑下更改容器配置等。

```
docker run \
 — name redis6 \
 — network analytics \
 -v redis6:/data \
 -p 6379:6379 \
 -e ALLOW_EMPTY_PASSWORD=yes \
 -dP \ redis:6.2.6@sha256:eaa2697033320e8b58b920f5f4aa0c56e8fa5eacf9094168504c7eeabbac8468 redis-server
```

现在让我们继续学习使用 Redis 散列存储每日和每周数据。

## 数据结构模式:存储每日和每周每小时的总数

很高兴你还在阅读。

**数据结构** : [哈希](https://redis.io/topics/data-types#hashes)
**密钥模式** : `{key-prefix}:{version}:{region}:{dataset}:{identifier_tag}:{date-pattern}` **示例密钥** : `acme:v1:us:carts:completed:2022:w:1`

在上面的示例关键字中，我们使用的是一年中的*数字周*。这样，没有人需要为日期计算而烦恼，我们可以让 Redis 有效地压缩全局 Redis 键空间中较短的键。日期模式的值是 2022 年第 1 周的{w:1}。**日期模式也可以简化为您自己的用例。只要确保您尝试了一些东西来看看什么是有效的，或者遵循其他最佳实践，比如使用 yyyy:MM:dd 样式的字符串模式。*

> 目标:存储一周 7 天中的小时数，以获得小时总数

与我们的键(**acme:v1:us:carts:completed:w:1**)相关联的 Redis 散列集存储一个星期几(0–6)和一天中的小时(0–23)指针的集合，例如[0–6]:[0–23]存储与一周中特定一天的某个小时的[已完成购物车总数]相关联的数值。

那么我们如何设置这个值呢？

## 使用 HSET 编写每小时购物车数据

使用 Redis cli，您可以将 Sunday @ 00:00:00–00:59:59 完成的购物车交易总数设置到散列中:将一个或多个键值对添加到公共散列的签名是`HSET key field value [field value...]`

```
127.0.0.1:6379> HSET acme:v1:us:carts:completed:w:1 0:0 100000
~~~
```

> T ip:现在，您不会期望有人手动输入所有这些数据，而是希望将这些分析数据作为管道作业或流聚合的副产品写入 Redis，以便从您的数据生态系统中的其他数据系统快速访问，从而实现以下目标:a)缓存数据以用于更复杂的用例，或者 b)保护对真实数据源的更昂贵的调用。

## 使用 HGETALL 获取购物车数据

要收集哈希映射中可用的所有键和已完成的购物车总数(如果我们对一周中的所有小时记录执行*0–6:0–23*，则总共有 168 个可能的键)，或者要收集一个子集或部分一周的数据，您可以使用 ***HGETALL*** 来获取与*键*相关联的 ***哈希*** 中的所有元组。

```
127.0.0.1:6379> HGETALL acme:v1:us:carts:completed:w:1
 1) "0:0"
 2) "100000"
 3) "0:1"
 4) "120000"
 5) "0:2"
 6) "150000"
 7) "0:3"
 8"250000"
 9) "0:4"
10) "290000"
11) "0:5"
12) "450000"
13) "0:6"
14) "450000"
15) "0:7"
16) "450000"
17) "0:8"
18) "450000"
19) "0:9"
20) "1200000"
21) "0:10"
22) "1800000"
23) "0:11"
24) "2300000"
25) "0:12"
26) "2900000"
27) "0:13"
28) "3600000"
29) "0:14"
30) "2600000"
31) "0:15"
32) "2200000"
33) "0:16"
34) "1200000"
35) "0:17"
36) "900000"
37) "0:18"
38) "1000000"
39) "0:19"
40) "1200000"
41) "0:20"
42) "1600000"
43) "0:21"
44) "1300000"
45) "0:22"
46) "600000"
47) "0:23"
48) "650000"
...
```

上面输出中显示的底层指标(购物车总数)都作为无符号整数有效地存储在内部，除非您添加负数*(除非您开始考虑退货，否则您不会希望添加负数，因为 0 销售是最小的数量——但这将在解释的这一点上使事情变得复杂)*。除了能够获取用于内部或外部客户的仪表板或其他 API 的分析数据之外，您还可以通过签名(day_of_week:hour_of_day)获取单个元组作为比较的基础，以通过简单地比较存储在简单 Redis 数据结构中的其他简单值来构成更高阶的分析(如放弃率，或每小时完成的与开始的购物车的百分比)。

如果我为周日生成一整天[0:0…0:23],并后退一步查看 Redis 中的开销。我可以使用 debug object 特性来获取前面的键所表示的数据结构的*编码*和 *serializedlength* 属性，只对键模式做了微小的修改(d 表示一天，而 w 表示一周——该模式允许您使用一年中的几天或几周——而不改变键的共享公共前缀( *acme:v1:us:carts:{…}* )。

```
127.0.0.1:6379> debug object acme:v1:us:carts:completed:d:1
Value at:0x7ff7c4866670 refcount:1 encoding:ziplist serializedlength:217 lru:8641926 lru_seconds_idle:30
```

调用 debug 对象的输出告诉我们，存储一整天的无符号整数每天只占用 217 个字节。此外，由于散列集的大小(24 个字符串/uint32 个元组), Redis 使用 [ziplist](https://redis.com/ebook/part-2-core-concepts/01chapter-9-reducing-memory-use/9-1-short-structures/9-1-1-the-ziplist-representation/) 编码对数据进行编码，最多默认 512 个条目。

现在，回到使用散列数据结构。

## 获取星期日下午 12 点(UTC)的小时总数

为了获取一个条目，我们只需要知道位置。星期日是 0(而星期六是 6)，第 12 个小时的小时偏移量是 11。为了清楚起见，您也可以将指针调整为从 1 开始。

```
127.0.0.1:6379> HGET acme:v1:us:carts:completed:w:1 0:12
"2300000"
```

> 提示:创建一个 RedisKey Builder 库或特定的高级 SDK 可以帮助解决使用 Redis 带来的复杂性，就像我在这里展示的那样。

```
val total = Carts({version:1,region:us,path:acme})
  .weekOf("2022-02-21")
  .completed()
  .getOrElse(...)
```

下一个。我们将看看如何使用位域存储布尔数据。

## 数据结构模式:存储日常用户活动

下一个模式将向您展示如何在 Redis 中使用位图有效地存储日常用户活动。

> **注意:**我们很多人都写过或者至少读过关于如何建立注册系统的文章。基于整数的标识符和 UUIDs 可能是一个热门话题。假设最大的整数值约为 21 亿，让我们假设您有一个分布式注册系统，确保系统中的每个客户(用户)都有自己的自动递增 id，您的规模小于 21.4 亿。如果我们使用整数来表示用户，那么我们会得到一个更小的密钥，这有助于减少密钥空间的开销，否则 UUID v4 可以，但会带来额外的开销。

**数据结构**:二进制字符串(带位操作的字节数组)
**密钥模式** : `{key-prefix}:{version}:{region}:{dataset}:{identifier_tag}:{date-pattern:yyyy:MM}` **示例密钥** : `acme:v1:us:users:active:0:2022-02`

上面的示例键对应于整数 id 为 0 的用户。如果使用 UUIDs，那么您可能会看到像`acme:v1:us:users:active:917dfa61–3c56–4e59-a595–37bb20c40a1d:2022–02`这样的键，由于键的长度，它会有一些额外的内存开销。

## 设置每日活动位

去掉繁文缛节(见上面的注释)。让我们从零号用户开始。我们将使用 SETBIT 为用户设置活动/非活动状态。

我们将从设置每月的前 3 天开始。[0–2]，在 2022 年 2 月 1 日和 3 日有效。我们将添加第一条记录，检查内存开销，然后添加另外两天。

```
127.0.0.1:6379> SETBIT acme:v1:us:users:active:2022–02 0 1
```

在这里检查内存开销。

```
127.0.0.1:6379> memory usage acme:v1:us:users:active:2022–02
(integer) 76
```

现在再加两天。

```
127.0.0.1:6379> SETBIT acme:v1:us:users:active:2022–02 1 0
127.0.0.1:6379> SETBIT acme:v1:us:users:active:2022–02 2 1
```

这个过程现在可能越来越乏味了。鉴于此，我们可以使用[位域](https://redis.io/commands/bitfield)命令给位图添加更多的值。让我们使用 Bitfield 命令将剩下的日子设置为二月的前 7 天。

```
BITFIELD acme:v1:us:users:active:2022–02 SET u1 3 1 SET u1 4 1 SET u1 5 0 SET u1 6 0
```

> BITFIELD 命令是*可变的，*意味着它可以接受零个或多个附加的 SET {encoding} {offset} {value}对。在这里，我们为用户设置第 3-6 天。有趣的是，因为我们在这里处理的是位，所以由于在初始字节数组上设置了< 8 值，我们没有改变存储这些信息所需的内存开销。1 字节是 8 位，我们也需要一些缓冲空间。我们可以通过调用`debug object acme:v1:us:users:active:2022–02.`来确认这一点，你会看到 serializedlength 仍然是 2 个字节。
> 
> 127.0.0.1:6379 >调试对象 acme:v1:us:users:active:2022–02
> 值 at:0xf55d8330 refcount:1 编码:raw serialized length:2 LRU:1578061 LRU _ seconds _ idle:46

假设每个位的默认值为 0，那么对于非活动日，我们实际上不需要做任何事情。我们只需要最终分配一个足够大的二进制字符串来保存未来几天的偏移量。Redis 位图只是二进制编码字符串上的访问方法。

让我们假设我们的用户在这个用例中(上面)去度假 7 天，然后开始断断续续地回来你提供的任何令人敬畏的服务。我们不需要做任何事情，直到下次用户激活时添加一个值。接下来让我们看看对“稀疏”字段的支持。

## 稀疏字段支持

今年二月有 28 天。我们的位偏移指数是 0–27 个值，以最终说明。我们已经填写了前 7 天的活动/不活动位[0–6]。由于用户正在度假，我们跳过接下来的 7 天[7–14]。他们在本月 16 日回来时又开始了服务。**是的，写这个和读这个一样令人困惑，但是我们不想浪费时间！*

以下内容设置了该月 16 日、19 日、24 日和 28 日的活动用户位。

```
BITFIELD acme:v1:us:users:active:2022–02 SET u1 15 1 SET u1 18 1 SET u1 23 1 SET u1 27 1
```

现在，我们可以看到 Redis 后台是如何分配内存的，这使得支持字节数组能够动态增长，因为我们的用户在二月的 28 天中的特定几天是活动的。

```
127.0.0.1:6379> memory usage acme:v1:us:users:active:2022–02
(integer) 84127.0.0.1:6379> debug object acme:v1:us:users:active:2022–02
Value at:0xf55d8330 refcount:1 encoding:raw serializedlength:5 lru:1579962 lru_seconds_idle:53
```

## 查找一个月的总活动天数

这里有趣的是，我们可以计算出用户是活动的还是非活动的(整个月)，因为在没有创建密钥的情况下，没有用户的记录。检查。有趣的是，我们还可以通过检查位图的 [**位计数**](https://redis.io/commands/bitcount) 来计算出用户已经活动了多少天(总共)。

```
127.0.0.1:6379> bitcount acme:v1:us:users:active:2022–02
(integer) 7
```

所以我们知道用户已经活跃了 7 天。bitcount 运算是 O(N ),但是由于它的大小很小，所以它的作用类似于 O(1)。我不知道常量时间分析的许多替代方法。考虑一下这样做的效率有多高(是的，这样做更困难，但是也不简单……)这种方法的替代方法需要查询用户活动，这可能是对存储在您的数据仓库或数据湖中的活动数据的计算开销很大的查询！

## 计算用户在一个月的某一天是否活跃

最后一个例子展示了如何使用 BITFIELD 命令通过偏移量获得一个特定的值，在我们的例子中是第一天的索引。我们将检查两天，我们显式地设置了该月 24 日的值，但从未为 22 日添加记录。

```
127.0.0.1:6379> BITFIELD acme:v1:us:users:active:2022–02 GET u1 21
1) (integer) 0127.0.0.1:6379> BITFIELD acme:v1:us:users:active:2022–02 GET u1 23
1) (integer) 1
```

我们得到一个整数响应数组。这是因为我们可以选择从位图返回多个值(就像 SET 功能是可变的一样，GET 也是可变的)。

```
127.0.0.1:6379> BITFIELD acme:v1:us:users:active:2022–02 GET u1 21 GET u1 23
1) (integer) 0
2) (integer) 1
```

## Redis 流

我将在 2022 年 4 月出版的一本名为《使用 Apache Spark 的现代数据工程》的书中介绍如何使用 Redis 流数据类型。它涵盖了比这篇博文更高级的用例，无论你的职业生涯走向何方，你都可以随身携带实践材料。

[](https://www.amazon.com/Modern-Engineering-Apache-Spark-Hands/dp/1484274512/) [## 使用 Apache Spark 的现代数据工程:构建关键任务流的实践指南…

### Amazon.com:使用 Apache Spark 的现代数据工程:构建关键任务流的实践指南…

www.amazon.com](https://www.amazon.com/Modern-Engineering-Apache-Spark-Hands/dp/1484274512/) 

## 结论

我希望这篇关于在 Docker 上使用 Redis 进行分析的介绍让你感到兴奋，或者至少是有趣的。Redis 是您的数据工程和工程工具箱中一把迷人的瑞士军刀。它也很可爱。我很幸运地在 2012 年“不得不”使用 Redis，十年后，我仍然热爱我的工作。

> *是的。我有意跳过关于 Redis 集群的局限性、内存成本与闪存成本与 ssd 成本与 hdd 成本、拥有数百万个关键字的海量数据存储的规模经济、OLAP 数据库(如[德鲁伊](https://druid.apache.org/) / [皮诺](https://pinot.apache.org/) / [ClickHouse](https://clickhouse.com/) )的利与弊的讨论，并以实际的事实来证实我上面关于使用 Redis 简化数据堆栈的论点。数据决策和技术选择是多方面的，这篇文章旨在向您介绍一种细微的数据服务方法。