<html>
<head>
<title>Explain Free Monad Like I am Five (Part 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">像我五岁一样解释自由单子(第一部分)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/explain-free-monad-like-i-am-five-part-1-5bee794074bd?source=collection_archive---------16-----------------------#2020-09-07">https://levelup.gitconnected.com/explain-free-monad-like-i-am-five-part-1-5bee794074bd?source=collection_archive---------16-----------------------#2020-09-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/e969974e873c29204528ed073dbf7a22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*U2e-xHXsS3cKcSos"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由Meagan Carsience拍摄</figcaption></figure><p id="45a5" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在Cats文档中:</p><blockquote class="ld le lf"><p id="870d" class="kf kg lg kh b ki kj kk kl km kn ko kp lh kr ks kt li kv kw kx lj kz la lb lc im bi translated">自由单子是一种允许你从任何函子中构建单子的结构。</p></blockquote><p id="492f" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">另一个定义说，从效果函数(可能不纯)转换到表示我们的领域逻辑的普通数据结构是一个想法。</p><p id="cc56" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">简单地说，它就像一个包装器，将任何ADT包装到一元结构DSL中，您可以用它来创建程序。它把你的程序DSL和它的解释器分开，这样你可以挑选不同的解释器。</p><p id="4919" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">本文将从一个简单的Todo应用程序(没有并发性等等)开始，从命令的角度出发，慢慢地将它转换成自由的monad风格。</p><h1 id="797b" class="lk ll it bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">创造代数</h1><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="ffb6" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">上面，我们用一个简单的CRUD创建了<code class="fe mo mp mq mr b">Todo</code> case类。</p><p id="db52" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">将DSL嵌入到其他编程语言中的最初方法是使用ADT将编程语言中的每个句子编码成ADT的一种形式。</p><h1 id="dc62" class="lk ll it bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">命令式程序</h1><p id="5d88" class="pw-post-body-paragraph kf kg it kh b ki ms kk kl km mt ko kp kq mu ks kt ku mv kw kx ky mw la lb lc im bi translated">我们会想做一系列的操作，如<code class="fe mo mp mq mr b">Create</code>一<code class="fe mo mp mq mr b">Todo</code>。然后，我们可以<code class="fe mo mp mq mr b">Find</code>这个id属于待办事项列表。<code class="fe mo mp mq mr b">Read</code>待办事项列表，显示我们所有待办事项的结果，并标记我们已经完成的待办事项。</p><p id="973b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">做这些事情的必要方法可以是像这样构造这些ADT的列表:</p><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="cb51" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">所以上面的程序只是一个<em class="lg">描述</em>。为了执行这个计划，我们需要一些执行解释器来运行它。</p><p id="db9f" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">让我们创建一个“执行”解释器:</p><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="bdde" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">当我们运行上面描述的程序时，我们使用模式匹配来做各种各样的动作。这是我们所有副作用和所有变异发生的地方。因此，我们将循环通过程序，并对每个描述运行<code class="fe mo mp mq mr b">execute</code>:</p><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="d65f" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">到目前为止，一切顺利。然而，我们上面描述的ADT不是很有用。例如，我们不能<code class="fe mo mp mq mr b">Find</code>一个id，并根据那个id标记待办事项。理想情况下，我们希望进行顺序操作，比如创建一个to do列表，读取所有Todo列表，并标记完成的列表。</p><p id="84a6" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们需要找到一种方法来获得前一个操作的值，并根据前一个操作的评估值进行一些其他的顺序处理。听起来像单子，对吧？</p><p id="f972" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">理想情况下，我们希望这样做:</p><pre class="mi mj mk ml gt mx mr my mz aw na bi"><span id="c487" class="nb ll it mr b gy nc nd l ne nf">val program = for {<br/>  todo &lt;- Create("Do Laundry")<br/>  listTodos &lt;- Read<br/>  idZero &lt;- Find(0L)<br/>  _ &lt;- Mark(todo.id)<br/>} yield ()</span></pre><p id="0c2f" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">现在的问题是，既然程序不再是一个列表，我们如何创建解释器？</p><p id="4a82" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">因为我们在程序上创建一个通用的数据结构，所以我们希望有某种“包装器”用一个单子绑定来包装这些数据结构，以构造一个单子类型的程序。</p><h1 id="3221" class="lk ll it bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">大改写</h1><p id="bc30" class="pw-post-body-paragraph kf kg it kh b ki ms kk kl km mt ko kp kq mu ks kt ku mv kw kx ky mw la lb lc im bi translated">我们需要返回我们的代数来“返回”一些值，以便在一元绑定中捕获它:</p><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="4b89" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">让我们写一个程序的包装器，这样它就可以有一元绑定函数。一元运算可以翻译成这样:</p><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="b66f" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们引入<code class="fe mo mp mq mr b">FlatMap</code>和<code class="fe mo mp mq mr b">Pure</code>将我们最初的代数类型绑定到单子:</p><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="6c3f" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">想象一下<code class="fe mo mp mq mr b">F[_]</code>像<code class="fe mo mp mq mr b">Todo</code>，但是它可以是任何类型的<code class="fe mo mp mq mr b">F[_]</code>。它没有任何约束，<code class="fe mo mp mq mr b">FlatMap</code>和<code class="fe mo mp mq mr b">Pure</code>类似于Monad中的<code class="fe mo mp mq mr b">flatMap</code>和<code class="fe mo mp mq mr b">pure</code>，它将上下文绑定到一个顺序操作中。</p><p id="3ab5" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">Free是一种递归数据结构，其中每个后续计算都可以访问前一个计算。这就是我们使用一个简单的数据结构来构建程序所需要的，这个数据结构对它的解释是自由的。</p><p id="c25e" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">根据以上理解，我们如何使上述<code class="fe mo mp mq mr b">Free</code> ADT起作用？</p><p id="90ff" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">理想情况下，我们希望得出这样的结论:</p><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="8df2" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">为此:</p><ol class=""><li id="26d1" class="ng nh it kh b ki kj km kn kq ni ku nj ky nk lc nl nm nn no bi translated">自由必须是单子。它需要一些<code class="fe mo mp mq mr b">flatMap</code>和<code class="fe mo mp mq mr b">map</code>以便scala可以检测和执行“理解”。</li><li id="f800" class="ng nh it kh b ki np km nq kq nr ku ns ky nt lc nl nm nn no bi translated">我们希望程序在<em class="lg">空闲时</em>执行<code class="fe mo mp mq mr b">flatMap</code>，而不是我们定义的“动作”ADT。这使得动作只是一个数据结构，我们可以稍后连接到我们的解释器。</li></ol><h1 id="7edc" class="lk ll it bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">以单子的形式创造自由</h1><p id="085a" class="pw-post-body-paragraph kf kg it kh b ki ms kk kl km mt ko kp kq mu ks kt ku mv kw kx ky mw la lb lc im bi translated">让我们构造一个自由函数，它需要有一个<code class="fe mo mp mq mr b">map</code>和一个<code class="fe mo mp mq mr b">flatMap</code>方法。</p><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="0cde" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">上面的代码<code class="fe mo mp mq mr b">flatMap</code>递归地执行flatMap，直到遇到<code class="fe mo mp mq mr b">Pure</code>，并将<code class="fe mo mp mq mr b">func</code>应用到<code class="fe mo mp mq mr b">a</code>。<code class="fe mo mp mq mr b">f andThen (a =&gt; a.flatMap(func))</code>表示首先将输入应用到<code class="fe mo mp mq mr b">f</code>来构成函数。<code class="fe mo mp mq mr b">f(a)</code>的返回值是一个<code class="fe mo mp mq mr b">Free[F[_], B]</code>。然后，返回值被应用于后续函数<code class="fe mo mp mq mr b">a =&gt; flatMap(func)</code>。如果还是不明白，就把上面的代码拍进IntelliJ，自己试着解一下类型。你对输入类型和返回类型看得越多，你就越知道如何创建上面的函数。</p><p id="b203" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">一旦我们准备好了<code class="fe mo mp mq mr b">map</code>和<code class="fe mo mp mq mr b">flatMap</code>函数，我们就可以开始构建我们的程序了。</p><p id="d83c" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">然而，我们如何建构自由呢？</p><h1 id="6610" class="lk ll it bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">举起免费的东西</h1><p id="2686" class="pw-post-body-paragraph kf kg it kh b ki ms kk kl km mt ko kp kq mu ks kt ku mv kw kx ky mw la lb lc im bi translated">我们想把<code class="fe mo mp mq mr b">Action</code>的<code class="fe mo mp mq mr b">lift</code>变成<code class="fe mo mp mq mr b">Free[F[_],A]</code>。</p><p id="614e" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">让我们创建一个<code class="fe mo mp mq mr b">lift</code>函数来完成这个任务:</p><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="cf5d" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">然后，我们可以创建这样的程序:</p><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="fce2" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们也可以创建一个DSL，通过创建一个隐式转换使它更可读:</p><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="mm mn l"/></div></figure><h1 id="89c2" class="lk ll it bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">解释者</h1><p id="a79b" class="pw-post-body-paragraph kf kg it kh b ki ms kk kl km mt ko kp kq mu ks kt ku mv kw kx ky mw la lb lc im bi translated">既然我们已经创建了自己的程序，我们还需要以某种方式将程序与解释器绑定起来。</p><p id="5f9c" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">让我们回头看看我们定义的第一个解释器:</p><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="b922" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">上面的代码看起来不错，但是我们如何将上面的解释器与我们的自由单子连接起来呢？</p><p id="7199" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们想这样做——给定下面的<code class="fe mo mp mq mr b">Free[F,A]</code>数据结构，我们想遍历<code class="fe mo mp mq mr b">Free</code>结构，评估每一步，并将结果线程化到下一个后续计算。我们要折叠程序描述的<code class="fe mo mp mq mr b">List</code>。</p><p id="f9d2" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">最终，我们将免费做同样的事情，为<code class="fe mo mp mq mr b">FlatMap</code>和<code class="fe mo mp mq mr b">Return</code>创建一个模式匹配:</p><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="46e9" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我在上面放了一个<code class="fe mo mp mq mr b">???</code>,因为我们无法访问自己创建的常规解释器。如果我们也提供解释器作为另一个参数来评估<code class="fe mo mp mq mr b">Action</code>:</p><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="decb" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们可以像这样用现有的解释器运行我们的程序:</p><pre class="mi mj mk ml gt mx mr my mz aw na bi"><span id="62d7" class="nb ll it mr b gy nc nd l ne nf">runProgram(program)</span></pre><h1 id="3e99" class="lk ll it bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">结论</h1><p id="2271" class="pw-post-body-paragraph kf kg it kh b ki ms kk kl km mt ko kp kq mu ks kt ku mv kw kx ky mw la lb lc im bi translated">通过首先介绍创建程序描述的传统命令式方法，我们已经走了很长的路。我们意识到，我们无法在一个常规的描述“列表”中访问先前计算的值，也无法进行我们想要的顺序计算。</p><p id="f7ce" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">然后，我们创建了一个<em class="lg"> Free </em>结构，使我们能够将现有的ADT包装成更为单一的东西。我们通过让<em class="lg">平面图</em>和<em class="lg">纯</em>引入<em class="lg">自由</em> ADT，这类似于<em class="lg">平面图</em>和<em class="lg">纯</em>的一元绑定。除此之外，我们还创造了一种将<code class="fe mo mp mq mr b">lift</code>类型转化为<code class="fe mo mp mq mr b">Free</code>类型的方法来理解它们。</p><p id="fc5c" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">最后，我们使用我们创建的现有解释器<code class="fe mo mp mq mr b">execute</code>，并执行<code class="fe mo mp mq mr b">Free</code>程序。</p><p id="599d" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在本系列的第2部分中，我想深入探讨我们如何能够一般化<code class="fe mo mp mq mr b">Free</code> ADT并创建一个<em class="lg"> free </em>结构，以便最终在任何程序中创建DSL。敬请期待！</p><p id="b61b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">完整的源代码在这里是<a class="ae nu" href="https://github.com/edwardGunawan/Blog-Tutorial/tree/master/ScalaTutorial/freeMonad/src/main/scala" rel="noopener ugc nofollow" target="_blank"/>。</p></div><div class="ab cl nv nw hx nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="im in io ip iq"><p id="f1e7" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">感谢阅读！如果你喜欢这篇文章，请随意订阅我的时事通讯中的</strong><a class="ae nu" href="https://edward-huang.com/subscribe/" rel="noopener ugc nofollow" target="_blank"><strong class="kh iu"/></a><strong class="kh iu">来获取关于科技职业的文章、有趣的链接和内容！</strong></p><p id="08c6" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">你可以关注我，也可以在<a class="ae nu" href="https://medium.com/@edwardgunawan880" rel="noopener">媒体</a>上关注我，以获得更多类似的帖子。</p><p id="bd0b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><em class="lg">原载于</em><a class="ae nu" href="https://edward-huang.com/functional-programming/scala/programming/monad/2020/09/06/explain-free-monad-like-i-am-five-part-1/" rel="noopener ugc nofollow" target="_blank"><em class="lg">https://edward-huang.com</em></a><em class="lg">。</em></p></div></div>    
</body>
</html>