# 阿布拉莫夫《使用效果完全指南》中的有趣观点

> 原文：<https://levelup.gitconnected.com/interesting-points-from-abramovs-a-complete-guide-to-useeffect-99ef9e136a19>

![](img/db936d8916b8acad39244c17252b1465.png)

酸橙不错:3 ( [Hoach Le Dinh](https://unsplash.com/photos/c8TWWQ5ZnUw?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) )

今年，在个人和生产项目中，我一直在使用钩子和 redux 钩子。这个 API 有点粗糙——但是他们通常不负众望。我已经能够相对无缝地重构应用程序，让所有组件都发挥作用真的非常困难。

[几个月前，丹·阿布拉莫夫](https://medium.com/u/a3a8af6addc1?source=post_page-----99ef9e136a19--------------------------------)以`useEffect`为主题写了一篇非常长且[有用的博文](https://overreacted.io/a-complete-guide-to-useeffect/)(我参加派对迟到了)。我在这里的重点不是 TL；DR(他有自己的总结)，甚至是我自己从文章中获得的，但我在文档或我读过的教程中没有获得的一些有趣的 hooks API 行为。在丹的文章中，它们有点像旁注，但鉴于这些想法对我来说是多么陌生，我认为它们至少值得发表在这样一篇小文章中。

# cleanupCallback！= componentDidUnmount

第一个是可选的清理函数，您可以从传递给`useEffect`的回调中返回。来自 react 官方文档:

> 【React 到底什么时候清理效果？当组件卸载时，React 执行清理**。然而，正如我们之前了解到的，效果会在每次渲染时运行，而不是只运行一次。**这也是为什么 React *和*会在下次运行效果之前清除之前渲染的效果**。**

我想当我读到当组件被卸载时，我的大脑忽略了这句话的其余部分。我已经被锁定在生命周期思维模式中，并且 classes == hooks，我没有承认`useEffect`的新特性，即在再次运行 useEffect 回调时运行它的清理*。每当`useEffect`回调运行时，在它可以再次运行之前，清理回调将被运行。它有一些有趣的含义，尽管老实说，目前还没有想到这种行为的实际应用😅。*

一个效果回调将在每次渲染后运行，除非我们指定一个 dep 数组。如果我们指定 dep，它将只在 dep 在渲染之间变化时运行。如果发生这种情况，清理回调也必须运行。这不仅仅发生在组件卸载的时候。但事实上，我们可能真的不应该认为我们的组件是用钩子组件“卸载”的，而是另一个渲染的结束，尽管是最终的。

你可以通过玩这个[例子](https://codesandbox.io/embed/distracted-bardeen-k5qz1)来看这个 irl。检查控制台，你会看到每按一次按钮，回调函数中的日志就被打印出来，清理函数中的日志也是如此。

# `dispatch`是个酷 hax

丹创造了一个利用两个状态变量的效果的例子。其中一个变量的计算值依赖于另一个，因此其他变量必须作为 dep 列出。你可以在他的例子[这里](https://codesandbox.io/s/zxn70rnkx)中看到这一细节，或者只看下面的片段

在上面的例子中，我们使用回调来改变`count`的值，这允许我们避免将它传递给我们的数组 deps。但是由于它的计算值依赖于`step`，我们必须将`step`传递到数组中。当`step`改变时，效果回调和清理函数都被调用。如果出于某种原因，你不希望效果和它的清理功能被调用，你可以随时召唤`dispatch`。

效果有点像远程访问和修改你的状态。`dispatch`从效果内部发送一个动作到相应的`reducer`，将效果从状态中分离出来，并允许您更好地控制效果何时运行。这里的可以找到一个例子[。](https://codesandbox.io/s/xzr480k0np)

这实际上是阿布拉莫夫试图传达的一个主要观点，但我把它包括在这里，因为从官方文件来看`dispatch`的这种行为并不明显。我也想包括它，因为它展示了`useReducer`的效用。在第一次查看关于这种方法的文档时，我有点不以为然。我认为它只是一个 redux 风格的全局 reducer 移动到一个组件状态。现在我可以看到它更有能力了。

虽然这些观点让我震惊，但在 Dan 的文章中还有很多其他非常有用的观点，尽管它很长，我还是鼓励所有人阅读它，至少是 TL；这篇文章的大部分内容鼓励为渲染阶段采用一种新的心智模型，尽管我不能说我 100%理解它，但我会说它对我帮助很大。

另一个更辣的收获是 hooks API 在进入黄金时段之前，尤其是在大约`useEffect`的时候，可能还需要一点点的润色和抽象。记忆功能，将静态功能提升到组件主体之外，创建冗长的异径管，增加了一些进入 imo 的障碍。或者也许我只是思想狭隘，看事情不正确。大家在评论里聊聊吧！

🐈