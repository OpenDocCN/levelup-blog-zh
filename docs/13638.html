<html>
<head>
<title>Java 19 Is Here: An Exciting Solution to Your Fear of Scaling Threads — Lightweight Virtual Threads!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java 19来了:这是一个令人兴奋的解决方案，它解决了您对扩展线程的恐惧——轻量级虚拟线程！</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/java-19-is-here-an-exciting-solution-to-your-fear-of-scaling-threads-lightweight-virtual-threads-994004032b92?source=collection_archive---------0-----------------------#2022-09-24">https://levelup.gitconnected.com/java-19-is-here-an-exciting-solution-to-your-fear-of-scaling-threads-lightweight-virtual-threads-994004032b92?source=collection_archive---------0-----------------------#2022-09-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><blockquote class="jn"><p id="d096" class="jo jp iq bd jq jr js jt ju jv jw jx dk translated">Java 19引入了令人兴奋的预览特性，虚拟线程！在这里，您将了解java线程的内部结构，以及为什么我们甚至需要虚拟线程，以及它们是如何工作的！</p></blockquote><div class="jy jz ka kb kc ab cb"><figure class="kd ke kf kg kh ki kj paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><img src="../Images/c5aa80d000b2e3defeb449d4590e806f.png" data-original-src="https://miro.medium.com/v2/resize:fit:938/0*mbg2pULXFebcJ1Hb"/></div></figure><figure class="kd ke kq kg kh ki kj paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><img src="../Images/b51f328ec52ff8c3f03c5a3ea8cbf472.png" data-original-src="https://miro.medium.com/v2/resize:fit:1064/0*cZ0O_gAHHuW_lEtN"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk kv di kw kx translated">JJ·英在Unsplash上的照片，<a class="ae ky" href="https://unsplash.com/@haughters?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">杰米·霍顿</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash上的照片</a></figcaption></figure></div><p id="f306" class="pw-post-body-paragraph kz la iq lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv jx ij bi translated">我稍后将回到那个猴子，让我们从理解现有的Java线程开始，好吗？</p><h1 id="9f77" class="lw lx iq bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">什么是Java线程？</h1><ol class=""><li id="2f6c" class="mu mv iq lb b lc mw lg mx lk my lo mz ls na jx nb nc nd ne bi translated">Java中的线程相当于操作系统线程(平台线程)</li><li id="0573" class="mu mv iq lb b lc nf lg ng lk nh lo ni ls nj jx nb nc nd ne bi translated">那是什么意思？我们先来了解一下线程。</li></ol><p id="4433" class="pw-post-body-paragraph kz la iq lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv jx ij bi translated">线程只是在CPU内核上执行的指令的T4序列，将指令的这个<em class="nk">序列分配给CPU内核是由调度程序完成的。所以一个线程可以被认为是一系列指令和一个调度器的组合。指令序列<em class="nk">是指令序列</em>的延续<em class="nk">。</em></em></p><blockquote class="nl nm nn"><p id="9424" class="kz la nk lb b lc ld le lf lg lh li lj no ll lm ln np lp lq lr nq lt lu lv jx ij bi translated">J <em class="iq"> VM使用底层操作系统提供的</em>延续<em class="iq">和</em>调度器<em class="iq">的实现，因此Java线程被视为等同于平台线程。</em></p></blockquote><h1 id="4e06" class="lw lx iq bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">平台线程有什么不好的地方？</h1><blockquote class="jn"><p id="70a6" class="jo jp iq bd jq jr nr ns nt nu nv jx dk translated">规模</p></blockquote><ol class=""><li id="f956" class="mu mv iq lb b lc nw lg nx lk ny lo nz ls oa jx nb nc nd ne bi translated">一个服务器可以处理一百万个并发用户请求，但是JVM使用操作系统的线程来实现Java线程，不能有效地处理几千个以上的请求。</li></ol><p id="2b8e" class="pw-post-body-paragraph kz la iq lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv jx ij bi translated">但是为什么我们不能扩展平台线程呢？</p><ol class=""><li id="2ab6" class="mu mv iq lb b lc ld lg lh lk ob lo oc ls od jx nb nc nd ne bi translated">创建和管理平台线程必须进行系统调用，这很慢(这就是我们使用线程池的原因)</li><li id="d101" class="mu mv iq lb b lc nf lg ng lk nh lo ni ls nj jx nb nc nd ne bi translated">操作系统只能管理有限数量的线程。</li><li id="a196" class="mu mv iq lb b lc nf lg ng lk nh lo ni ls nj jx nb nc nd ne bi translated">平台线程的存在会占用大量内存。</li><li id="f4b5" class="mu mv iq lb b lc nf lg ng lk nh lo ni ls nj jx nb nc nd ne bi translated">每当出现阻塞I/O(输入/输出)操作(如网络调用或存储读取)时，线程必须等待，直到它从网络或存储获得响应，此时线程不需要CPU核心，它们进入等待状态，直到接收到数据，这就是上下文切换。当您有大量I/O时，线程只是在等待数据，CPU没有得到充分利用。</li><li id="9e7e" class="mu mv iq lb b lc nf lg ng lk nh lo ni ls nj jx nb nc nd ne bi translated">将线程状态从<em class="nk">运行</em>更改为<em class="nk">等待</em>意味着将线程上下文(CPU寄存器+程序计数器+堆栈)从CPU内核中取出，存储该状态，并将另一个线程<em class="nk"> </em>分配给CPU(这就是上下文切换)<strong class="lb ir">需要大量时间和内存。</strong></li></ol><p id="6a6c" class="pw-post-body-paragraph kz la iq lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv jx ij bi translated">所以，</p><blockquote class="jn"><p id="5a09" class="jo jp iq bd jq jr nr ns nt nu nv jx dk translated">1.平台线程的上下文切换在资源方面是昂贵的。</p><p id="ecc0" class="jo jp iq bd jq jr nr ns nt nu nv jx dk translated">2.平台线程只是在那里等待数据，什么也不做，这些数据本可以用于其他CPU相关的操作。</p><p id="2fcf" class="jo jp iq bd jq jr nr ns nt nu nv jx dk translated">3.如果您有很多I/o，CPU就没有得到充分利用。</p></blockquote><h1 id="1793" class="lw lx iq bd ly lz ma mb mc md me mf mg mh oe mj mk ml of mn mo mp og mr ms mt bi translated">好吧，但是像Project Reactor这样的反应式框架难道不能解决这些问题吗？</h1><ol class=""><li id="d3aa" class="mu mv iq lb b lc mw lg mx lk my lo mz ls na jx nb nc nd ne bi translated">是也不是，反应式编程通过让正在运行的线程进行阻塞调用，然后立即执行程序的其余部分，而不等待来自存储或网络的数据，从而提供非阻塞I/O。</li></ol><p id="c953" class="pw-post-body-paragraph kz la iq lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv jx ij bi translated">但是那跳过的阻塞代码(网络调用或存储读取)怎么办？</p><ol class=""><li id="122f" class="mu mv iq lb b lc ld lg lh lk ob lo oc ls od jx nb nc nd ne bi translated">它保持一个事件循环，不断检查套接字是否从网络/存储接收到数据，一旦接收到数据，它将由另一个线程处理，因此运行的线程在这里不会被阻塞。</li><li id="274c" class="mu mv iq lb b lc nf lg ng lk nh lo ni ls nj jx nb nc nd ne bi translated"><strong class="lb ir">但是，但是，但是</strong>如果你从事过反应式代码的工作，你就会知道它很难阅读，很难调试，很难进行单元测试，编码风格不适合现有的同步代码风格，还需要来自数据源的反应式模型支持。</li></ol><h1 id="ec27" class="lw lx iq bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">那么，什么是虚拟线程呢？</h1><ol class=""><li id="ae89" class="mu mv iq lb b lc mw lg mx lk my lo mz ls na jx nb nc nd ne bi translated">它是由JVM调度程序管理的线程，不同于由OS调度程序管理的平台线程。它扩展了<em class="nk"> java.lang.Thread </em>类，但不受操作系统调度程序的管理。</li><li id="a75f" class="mu mv iq lb b lc nf lg ng lk nh lo ni ls nj jx nb nc nd ne bi translated">虚拟线程由JVM实现的<em class="nk">延续</em>和<em class="nk">调度器</em>组成。<em class="nk">延续</em>是由JVM调度器分配给<em class="nk">平台线程</em>的指令<em class="nk">序列。目前，JVM使用ForkJoinPool作为调度程序。</em></li><li id="bfa8" class="mu mv iq lb b lc nf lg ng lk nh lo ni ls nj jx nb nc nd ne bi translated">虚拟线程可以使用多个平台线程来完成工作。平台线程在Java文档中也被称为<strong class="lb ir">载体线程</strong>。</li></ol><blockquote class="jn"><p id="20a6" class="jo jp iq bd jq jr js jt ju jv jw jx dk translated">您将任务分配给虚拟线程→ Java scheduler将虚拟线程分配给平台线程→虚拟线程要求平台线程完成工作。</p></blockquote><p id="0f9a" class="pw-post-body-paragraph kz la iq lb b lc nw le lf lg nx li lj lk oh lm ln lo oi lq lr ls oj lu lv jx ij bi translated">3.<strong class="lb ir">关键点是</strong>，如果一个虚拟线程有阻塞I/O操作，它将从平台线程中分离出来，另一个虚拟线程将被分配给平台线程，使平台线程保持运行状态。虚拟线程的上下文将存储在堆本身，因此阻塞和恢复虚拟线程是廉价的。</p><p id="12b2" class="pw-post-body-paragraph kz la iq lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv jx ij bi translated">4.值得注意的是，这里阻塞的是虚拟线程，而不是平台线程。因为虚拟线程在应用程序上下文中，所以阻塞虚拟线程比阻塞平台线程便宜得多。</p><p id="7beb" class="pw-post-body-paragraph kz la iq lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv jx ij bi translated">5.因此，具有<strong class="lb ir">高并发请求</strong>和较少CPU操作的<strong class="lb ir">线程</strong> <strong class="lb ir">花费大量时间等待</strong>的应用程序将具有<strong class="lb ir">更高的吞吐量</strong>和<strong class="lb ir">虚拟线程。</strong>并发请求将由虚拟线程处理，它们将进入等待状态<strong class="lb ir">，无需</strong>繁重的上下文切换，同时平台线程将充分利用CPU。</p><p id="d879" class="pw-post-body-paragraph kz la iq lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv jx ij bi translated">6.仅阻塞调用的应用程序(比如说API，它只是结合了两个其他网络调用的结果)可以很好地扩展虚拟线程，因为虚拟线程将进入等待状态，直到它们接收到数据，而平台线程将继续使用CPU。</p><blockquote class="jn"><p id="c799" class="jo jp iq bd jq jr nr ns nt nu nv jx dk translated">因为创建、阻塞和恢复虚拟线程更便宜，所以它们是轻量级的！</p></blockquote><h2 id="2603" class="ok lx iq bd ly ol om dn mc on oo dp mg lk op oq mk lo or os mo ls ot ou ms ov bi translated">虚拟线程如何解除阻塞/暂停？</h2><ol class=""><li id="9e0d" class="mu mv iq lb b lc mw lg mx lk my lo mz ls na jx nb nc nd ne bi translated">当虚拟线程阻塞I/O时，会有一个JVM范围的Read-Poller(<em class="nk">sun . nio . ch . Poller</em>)线程，它会在被阻塞的虚拟线程和将接收数据的相应套接字之间创建一个映射。</li><li id="49b5" class="mu mv iq lb b lc nf lg ng lk nh lo ni ls nj jx nb nc nd ne bi translated">轮询器线程是一个连续的事件循环，它不断检查映射到特定线程的套接字是否接收到数据，如果是，它唤醒相应的虚拟线程，虚拟线程从最后停止的指令开始继续执行。</li><li id="b5af" class="mu mv iq lb b lc nf lg ng lk nh lo ni ls nj jx nb nc nd ne bi translated"><em class="nk">Java . internal . VM . continuation</em>是一个在虚拟线程中使用的公共低级API，它可以在任何需要的时候产生并继续。</li></ol><h2 id="ccc9" class="ok lx iq bd ly ol ow dn mc on ox dp mg lk oy oq mk lo oz os mo ls pa ou ms ov bi translated">如何创建虚拟线程？</h2><figure class="pb pc pd pe gt ke"><div class="bz fp l di"><div class="pf pg l"/></div></figure><p id="2c9e" class="pw-post-body-paragraph kz la iq lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv jx ij bi translated">用于测试的示例代码:</p><figure class="pb pc pd pe gt ke"><div class="bz fp l di"><div class="pf pg l"/></div></figure><h1 id="794f" class="lw lx iq bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">虚拟线程的优势是什么？</h1><ol class=""><li id="37ab" class="mu mv iq lb b lc mw lg mx lk my lo mz ls na jx nb nc nd ne bi translated">以简单的每请求线程风格编写的应用程序可以通过优化资源利用来扩展。您可以为每个传入的请求生成一个虚拟线程。</li><li id="4cfd" class="mu mv iq lb b lc nf lg ng lk nh lo ni ls nj jx nb nc nd ne bi translated">如果用<em class="nk"> java.lang.Thread </em>写现有代码，集成虚拟线程很容易。</li><li id="8f2b" class="mu mv iq lb b lc nf lg ng lk nh lo ni ls nj jx nb nc nd ne bi translated">您不需要为虚拟线程创建一个池，因为创建、暂停和恢复虚拟线程的成本很低。</li><li id="9970" class="mu mv iq lb b lc nf lg ng lk nh lo ni ls nj jx nb nc nd ne bi translated">使用现有的JDK工具，轻松对虚拟线程进行故障排除、调试和分析。</li><li id="ffee" class="mu mv iq lb b lc nf lg ng lk nh lo ni ls nj jx nb nc nd ne bi translated">您可以编写同步和阻塞代码，因为阻塞操作对于虚拟线程来说是廉价的。</li></ol><p id="382f" class="pw-post-body-paragraph kz la iq lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv jx ij bi translated"><strong class="lb ir">虚拟线程的当前限制:</strong></p><ol class=""><li id="828f" class="mu mv iq lb b lc ld lg lh lk ob lo oc ls od jx nb nc nd ne bi translated">当虚拟线程在<code class="fe ph pi pj pk b">synchronized</code>块或方法中时，它不能从相关的平台线程中分离，因为同步块在内部使用堆栈的地址，目前这是一个限制，但根据官方文件，这可能会被删除。使用可重入锁而不是同步块可以很容易地解决这个问题。</li></ol><p id="5707" class="pw-post-body-paragraph kz la iq lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv jx ij bi translated">它是作为一个预览功能推出的，所以请尝试一下，分享您的反馈，并报告错误，我很高兴看到它成为语言的一部分，请在评论中自由表达您的想法。</p><p id="cd9b" class="pw-post-body-paragraph kz la iq lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv jx ij bi translated"><em class="nk">就这样。感谢Project Loom多年来在虚拟线程方面的工作，感谢阅读！</em></p><p id="db13" class="pw-post-body-paragraph kz la iq lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv jx ij bi translated">如果您从这篇文章中学到了一些新东西，请点击关注和订阅按钮获取这些内容！</p><p id="e6be" class="pw-post-body-paragraph kz la iq lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv jx ij bi translated"><strong class="lb ir"> <em class="nk">还对那只猴子感兴趣？</em> </strong></p><blockquote class="nl nm nn"><p id="14a6" class="kz la nk lb b lc ld le lf lg lh li lj no ll lm ln np lp lq lr nq lt lu lv jx ij bi translated">在我最疯狂的想象中，我认为虚拟线程是骑着大象(沉重的平台线程)完成工作的猴子。它们可以从一只大象跳到另一只大象，当没有工作要做时(阻塞I/O)，就下来让其他大象骑，这样大象就永远不会坐着。</p></blockquote><p id="dd47" class="pw-post-body-paragraph kz la iq lb b lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv jx ij bi translated">查看我关于流式API的另一篇文章，</p><div class="pl pm gp gr pn po"><a rel="noopener  ugc nofollow" target="_blank" href="/8-years-of-java-stream-api-understand-streams-through-8-questions-bd9e5d9d8bc"><div class="pp ab fo"><div class="pq ab pr cl cj ps"><h2 class="bd ir gy z fp pt fr fs pu fu fw ip bi translated">8年Java Stream API，通过8个问题了解Streams！</h2><div class="pv l"><h3 class="bd b gy z fp pt fr fs pu fu fw dk translated">是的，自从Java SE 8发布流API、函数接口、时间API等等以来，已经有8年了…</h3></div><div class="pw l"><p class="bd b dl z fp pt fr fs pu fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="px l"><div class="py l pz qa qb px qc ko po"/></div></div></a></div></div></div>    
</body>
</html>