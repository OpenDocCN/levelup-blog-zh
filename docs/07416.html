<html>
<head>
<title>The Why and How of Microservice Messaging in Kubernetes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Kubernetes中微服务消息传递的原因和方式</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/the-why-and-how-of-microservice-messaging-in-kubernetes-1d54a4717bf1?source=collection_archive---------2-----------------------#2021-02-16">https://levelup.gitconnected.com/the-why-and-how-of-microservice-messaging-in-kubernetes-1d54a4717bf1?source=collection_archive---------2-----------------------#2021-02-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><h1 id="e1ae" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">介绍</h1><p id="4267" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在Kubernetes中努力连接和维护您的微服务？随着微服务数量的增长，维护分布式服务的难度和复杂性也呈指数级增长。消息传递可以为这个问题提供一个干净的解决方案，但是遗留消息队列也有自己的问题。</p><p id="c2f1" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">在本文中，我将分享Kubernetes中消息传递的好处以及遗留解决方案可能带来的困难。我还将简要介绍KubeMQ，它试图解决Kubernetes中消息传递的一些传统问题。</p><h1 id="a13c" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">为什么用Kubernetes发消息？</h1><p id="3a10" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">随着基于微服务的架构的发展，将这些分布式服务连接起来可能会很困难。对于每个点对点交互，必须解决安全性、可用性和延迟问题。此外，随着服务数量的增加，潜在连接的数量也在增加。例如，考虑一个只有三个服务的环境。这三个服务总共有三个潜在的连接:</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div class="gh gi lr"><img src="../Images/27e52c4ebc2989cec741e510101ab97b.png" data-original-src="https://miro.medium.com/v2/resize:fit:796/0*MnLbG8FpmHAHgqIh"/></div></figure><p id="c7e7" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">然而，当增加到比如说五个服务时，潜在连接的数量增加到10:</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="gh gi lz"><img src="../Images/a62c88f3a245cbb3b0cddb169bef8728.png" data-original-src="https://miro.medium.com/v2/resize:fit:988/0*toIa18YoswmvefdJ"/></div></div></figure><p id="47a6" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">对于20个服务，潜在的连接数是190！请参考下表:</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="gh gi me"><img src="../Images/c69d7835715091b9fd787711bd25c6e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YICTJvUjgWg2V1-8FHWrjA.png"/></div></div></figure><p id="975e" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">对于拥有大量服务组合的组织来说，这显然是不可持续的。然而，通过使用消息队列，我们可以集中这些连接。由于连接的数量等于服务的数量，这就产生了一个线性扩展的解决方案。见下文:</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="gh gi mf"><img src="../Images/a032d199bd228c426090560cfe8b0a37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0RiyaZI4dgiwTRAB"/></div></div></figure><p id="35e8" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">对于一个大型微服务群，这大大简化了安全性和可用性问题，因为每个微服务需要主要与消息队列通信。这就是在Kubernetes中运行大量微服务时，实现消息队列架构被认为是最佳实践的原因。因此，选择消息队列是一个至关重要的决策，因为整个体系结构将取决于该消息队列的可靠性和可伸缩性。</p><p id="b335" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">最后，在Kubernetes中部署消息队列可以避免平台锁定。主要的云提供商有许多特定于平台的消息传递解决方案，但是运行平台无关的解决方案可以让您保持微服务架构的一致性，而不管您的平台如何。Kubernetes是事实上的编排解决方案，得到了所有主要云提供商的支持。</p><p id="5a7e" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">既然我们已经确定了为什么信息传递是有帮助的，让我们再深入一点。这似乎是一个简单的解决方案，那么有什么难的呢？</p><h1 id="b5ff" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">Kubernetes中的消息传递有什么难的？</h1><p id="527d" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">当试图在Kubernetes中运行消息队列时，有许多棘手的问题。让我们考虑一下典型微服务和标准消息队列之间的区别。我在下表中总结了一些差异:</p><figure class="ls lt lu lv gt lw gh gi paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="gh gi mg"><img src="../Images/0e1d1800ff7f748bb96c6e43c980e2e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x8OmpOvNMcnLAexbDeQVxA.png"/></div></div></figure><p id="858a" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">首先，微服务被设计成资源轻型的。这在某种程度上是微服务的自然结果——每个服务执行一个单一的目的，因此可以更小、更灵活。相比之下，遗留消息队列是大型的资源密集型应用程序。在撰写本文时，IBM MQ的最新版本对硬件有很高的要求。比如&gt; 1.5 GB磁盘空间，3gb RAM。</p><p id="a2f5" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">此外，典型的微服务是无状态的，因为它本身不包含应用程序状态的任何部分。然而，许多传统的消息队列可以有效地用作数据库，并且需要持久存储。Kubernetes中的持久存储最好用<a class="ae mh" href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/" rel="noopener ugc nofollow" target="_blank">持久卷API </a>来处理，但这需要遗留解决方案的变通办法。</p><p id="6513" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">这些资源使用上的差异自然会引出下一点——微服务易于部署。微服务旨在作为集群的一部分快速部署。另一方面，由于它们的资源密集型性质，遗留消息队列具有复杂的部署指令，并且需要专门的团队来设置和维护。</p><p id="d971" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">其次，微服务被设计成可水平扩展的。水平扩展是通过部署额外的服务实例来完成的。这使得服务几乎可以无限扩展，具有高可用性，并且通常更便宜。相比之下，由于前面提到的资源需求和部署困难，遗留消息队列必须垂直扩展，换句话说，就是一台更大的机器。除了物理限制(单台机器只能有这么强大)，更大的机器价格昂贵。</p><p id="f0d1" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">这些问题通常需要大量的投资和时间来解决，从而降低了消息队列为整个体系结构提供的价值。然而，这些问题都不是消息传递所固有的；相反，它们是设计和构思主要消息队列时的产物。</p><p id="43c4" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">那么我们如何解决这些问题呢？让我们来看一个选项:使用Kubernetes-native消息队列，比如KubeMQ。</p><h1 id="5ec4" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">Kubernetes-native方法</h1><p id="0551" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><a class="ae mh" href="https://kubemq.io/" rel="noopener ugc nofollow" target="_blank"> KubeMQ </a>是一款试图解决Kubernetes相关消息问题的产品。让我们来看看它是如何做到这一点的。</p><p id="78d4" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">首先，它是<strong class="kq iu"> Kubernetes-native </strong>，这意味着它可以很好地与Kubernetes集成，并且很容易部署为Kubernetes集群。<a class="ae mh" href="https://operatorhub.io/operator/kubemq-operator" rel="noopener ugc nofollow" target="_blank">操作符</a>允许你自动化任务<em class="mi">超越【Kubernetes原生提供的功能，随产品一起提供生命周期管理。<a class="ae mh" href="https://docs.kubemq.io/learn/cluster-scale#cluster-persistency" rel="noopener ugc nofollow" target="_blank">集群持久性</a>通过本地卷和PVC得到支持。Kubernetes是本地的也意味着它是云不可知的，因此它也可以部署在本地或混合云环境中。</em></p><p id="f810" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">此外，它是<strong class="kq iu">轻量级的</strong>——Docker容器大约为30 MB，与传统解决方案所需的GB空间相差甚远。这使得它几乎可以部署在任何地方，并支持新的使用案例，如物联网设备支持的边缘部署。尽管它很小，但它支持多种消息模式。</p><p id="7e1d" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">最后是<strong class="kq iu">可扩展</strong>。通过使用<a class="ae mh" href="https://kubemq.io/kubemq-bridges/" rel="noopener ugc nofollow" target="_blank">桥</a>、<a class="ae mh" href="https://kubemq.io/kubemq-targets/" rel="noopener ugc nofollow" target="_blank">目标</a>和<a class="ae mh" href="https://kubemq.io/kubemq-sources/" rel="noopener ugc nofollow" target="_blank">源</a>，这些预建的连接器允许it连接到各种其他应用和服务，减少了定制集成的需求。桥允许KubeMQ集群在彼此之间传递消息，使KubeMQ能够连接各种云、内部和边缘环境。</p><p id="af29" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">由于KubeMQ很小，您可以自己尝试使用minikube 的<a class="ae mh" href="https://minikube.sigs.k8s.io/docs/start/" rel="noopener ugc nofollow" target="_blank">本地安装或访问任何其他Kubernetes集群。</a></p><ol class=""><li id="14cb" class="mj mk it kq b kr lm kv ln kz ml ld mm lh mn ll mo mp mq mr bi translated"><a class="ae mh" href="https://account.kubemq.io/login/register" rel="noopener ugc nofollow" target="_blank">注册</a>一个(免费)账户，获得一个许可证令牌。</li><li id="c00a" class="mj mk it kq b kr ms kv mt kz mu ld mv lh mw ll mo mp mq mr bi translated">运行kubectl apply-f<a class="ae mh" href="https://get.kubemq.io/deploy?token=" rel="noopener ugc nofollow" target="_blank">https://get.kubemq.io/deploy?token=</a>T28】your-license-token&gt;</li></ol><p id="641c" class="pw-post-body-paragraph ko kp it kq b kr lm kt ku kv ln kx ky kz lo lb lc ld lp lf lg lh lq lj lk ll im bi translated">您可以使用kubectl get kubemq clusters-n kube MQ来验证您的集群的状态。更多信息，请查看<a class="ae mh" href="https://docs.kubemq.io/getting-started/quick-start" rel="noopener ugc nofollow" target="_blank">官方文件</a>。</p><h1 id="0f1c" class="jq jr it bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated">摘要</h1><p id="9483" class="pw-post-body-paragraph ko kp it kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">在本文中，我回顾了消息队列的好处，研究了在Kubernetes中实现消息传递的困难，并快速浏览了一下<a class="ae mh" href="https://kubemq.io/" rel="noopener ugc nofollow" target="_blank">kube MQ</a>——一个轻量级的Kubernetes原生解决方案，它提供了优于遗留解决方案的几个优点。</p></div></div>    
</body>
</html>