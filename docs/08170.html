<html>
<head>
<title>Writing a Tiny Stack VM in Rust</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Rust中编写微型堆栈虚拟机</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/writing-a-tiny-stack-vm-in-rust-e043cb6dcd40?source=collection_archive---------17-----------------------#2021-04-06">https://levelup.gitconnected.com/writing-a-tiny-stack-vm-in-rust-e043cb6dcd40?source=collection_archive---------17-----------------------#2021-04-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/498e6dcb906495e53c21e16630a3e359.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*AxCEwLlAVvaLqzVQ.png"/></div></div></figure><p id="46fd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">几天前，我写了一个超级简单的后缀表达式计算器来演示如何使用堆栈。后来，我决定最终开始学习全栈虚拟机是如何工作的，所以我将其扩展为一个全栈虚拟机，理论上你可以为其编写一个编译器。结果是超级简洁，速度也蛮快的。</p><p id="fb36" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">本指南旨在补充阅读TinyVM:<a class="ae kw" href="https://github.com/mkhan45/tinyvm/blob/main/src/main.rs" rel="noopener ugc nofollow" target="_blank">https://github.com/mkhan45/tinyvm/blob/main/src/main.rs</a>的代码。如果你熟悉Rust，但对Stack VM一无所知，那么你应该能够通过阅读代码来理解Stack VM是如何工作的。否则，本指南可以解释一些设计决策，并对一些步骤进行更高层次的概述。为了了解这个虚拟机可以运行什么类型的程序，请查看测试文件<a class="ae kw" href="https://github.com/mkhan45/tinyvm/tree/main/test_files" rel="noopener ugc nofollow" target="_blank">。</a></p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><p id="44ae" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">堆栈虚拟机有两个主要组成部分:一列指令和一堆值。对于这个堆栈虚拟机，值只是带符号的64位整数，因此在Rust中,<code class="fe le lf lg lh b">Stack</code>看起来像这样:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="3c81" class="lq lr iq lh b gy ls lt l lu lv">struct Stack(Vec&lt;isize&gt;);<br/><br/>// Since this is just a learning project<br/>// there's no proper error handling.<br/>// These helper methods are just so that <br/>// it's easier to ignore errors.<br/>impl Stack {<br/>    fn push(&amp;mut self, v: isize) {<br/>        self.0.push(v);<br/>    }<br/><br/>    fn pop(&amp;mut self) -&gt; isize {<br/>        self.0.pop().expect("popped an empty stack")<br/>    }<br/><br/>    fn peek(&amp;mut self) -&gt; isize {<br/>        *self.0.last().expect("peeked an empty stack")<br/>    }<br/><br/>    fn peek_mut(&amp;mut self) -&gt; &amp;mut isize {<br/>        self.0.last_mut().expect("peeked an empty stack")<br/>    }<br/>}</span></pre><p id="cdfd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下一个重要的部分是指令列表。在Rust中，很容易用枚举来表示这些。首先，我们需要的是:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="5ee7" class="lq lr iq lh b gy ls lt l lu lv">enum Inst {<br/>    Push(isize),<br/>    Pop,<br/>    Add,<br/>    Sub,<br/>}</span></pre><p id="b752" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于非Rustaceans，这意味着一个<code class="fe le lf lg lh b">Inst</code>要么是一个带有整数有效载荷的标签<code class="fe le lf lg lh b">Push</code>，要么是一个<code class="fe le lf lg lh b">Pop</code>、<code class="fe le lf lg lh b">Add</code>或<code class="fe le lf lg lh b">Sub</code>。</p><p id="0a2f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我的VM中，我为列表<code class="fe le lf lg lh b">Inst</code>创建了一个类型别名program:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="f488" class="lq lr iq lh b gy ls lt l lu lv">type Program&lt;'a&gt; = &amp;'a [Inst];</span></pre><p id="bca4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您不知道生存期注释(<code class="fe le lf lg lh b">'a</code>)的含义，可以放心地忽略它们。</p><p id="98ee" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有了这个，我们就可以放心地<code class="fe le lf lg lh b">interpret()</code>一<code class="fe le lf lg lh b">Program</code>了。</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="1dba" class="lq lr iq lh b gy ls lt l lu lv">fn interpret&lt;'a&gt;(program: Program&lt;'a&gt;) -&gt; isize {<br/>    use Inst::*;<br/><br/>    // instantiate stack as an empty Vector<br/>    let mut stack = Stack(Vec::new());<br/><br/>    for instruction in program {<br/>        match instruction {<br/>            // pushes the data to the stack<br/>            Push(d) =&gt; stack.push(*d),<br/>            // Pops a value off the stack<br/>            Pop =&gt; stack.pop(),<br/>            // Adds the top two values on the stack:<br/>            // [3, 1, 1] -&gt; [3, 2]<br/>            Add =&gt; {<br/>                let (a, b) = (stack.pop(), stack.pop());<br/>                stack.push(a + b);<br/>            }<br/>            // Subtracts the top two values on the stack:<br/>            // [3, 3, 1] -&gt; [3, 2]<br/>            Add =&gt; {<br/>                let (a, b) = (stack.pop(), stack.pop());<br/>                stack.push(b - a);<br/>            }<br/>        }<br/>    }<br/><br/>    stack.pop()<br/>}</span></pre><p id="595f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">运行<code class="fe le lf lg lh b">interpret(vec![Push(9), Push(3), Push(1), Add, Sub].as_slice())</code>返回5。这是<code class="fe le lf lg lh b">(- (+ 1 3) 9)</code>，或者说<code class="fe le lf lg lh b">9 - (1 + 3)</code>的结果。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><p id="7b0f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这很酷，但显然不是堆栈虚拟机。它可以处理算术表达式，但仅此而已。幸运的是，它实际上离能够做更多的事情不远了。第一步是添加<code class="fe le lf lg lh b">Print</code>指令，它只在堆栈顶部打印值。这是一个重要的里程碑，因为它把程序从本质上一个有输入和输出的纯函数变成了一个有明显副作用的完整解释器。</p><p id="5898" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe le lf lg lh b">Print</code>超级容易实现。第一步是将变量添加到<code class="fe le lf lg lh b">Inst</code>枚举中:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="3c9b" class="lq lr iq lh b gy ls lt l lu lv">enum Inst {<br/>    Push(isize),<br/>    ...<br/>    Print,<br/>}</span></pre><p id="92b5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们告诉解释器如何处理它:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="3897" class="lq lr iq lh b gy ls lt l lu lv">fn interpret&lt;'a&gt;(program: Program&lt;'a&gt;) {<br/>    use Inst::*;<br/><br/>    // instantiate stack as an empty Vector<br/>    let mut stack = Stack(Vec::new());<br/><br/>    for instruction in program {<br/>        match instruction {<br/>            Push(d) =&gt; stack.push(*d),<br/>            ...<br/>            Print =&gt; println!("{}", stack.peek()),<br/>        }<br/>    }<br/>}</span></pre><p id="2491" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意，我还删除了返回，因为我们可以打印中间值。</p><p id="8c49" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们可以进行多次计算并打印结果:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="18bc" class="lq lr iq lh b gy ls lt l lu lv">interpret(vec![<br/>    Push(5),<br/>    Push(10),<br/>    Add,<br/>    Print,<br/>    Push(25),<br/>    Sub,<br/>    Print,<br/>    Push(10),<br/>    Add,<br/>    Print,<br/>].as_slice())</span></pre><p id="018b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它将打印:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="977f" class="lq lr iq lh b gy ls lt l lu lv">15<br/>-10<br/>0</span></pre></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><p id="f5fb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们现在可以打印东西了，但是程序复杂性的上限仍然很低。在下一节中，我们将通过两步从一个简单的表达式求值器到一个完整的解释器。</p><p id="175d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，我们需要跳转和条件跳转。跳转将我们从代码中的一点带到另一点，条件跳转只有在满足条件时才会跳转，否则它只会继续前进。</p><p id="f4d5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了增加这一点，我们需要能够在任何点访问指令表，而不仅仅是按顺序访问。在Rust中，只需添加当前指令指针作为可变变量，并将<code class="fe le lf lg lh b">for each</code>循环改为<code class="fe le lf lg lh b">while let</code>循环:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="4b27" class="lq lr iq lh b gy ls lt l lu lv">fn interpret&lt;'a&gt;(program: Program&lt;'a&gt;) {<br/>    use Inst::*;<br/><br/>    // instantiate stack as an empty Vector<br/>    let mut stack = Stack(Vec::new());<br/>    let mut pointer = 0;<br/><br/>    while let Some(instruction) = program.get(pointer) {<br/>        pointer += 1;<br/><br/>        match instruction {<br/>            ...<br/>        }<br/>    }<br/>}</span></pre><p id="202a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们添加<code class="fe le lf lg lh b">Jump</code>、<code class="fe le lf lg lh b">JE</code>和<code class="fe le lf lg lh b">JNE</code>指令。跳转无条件跳转，如果栈顶等于零，JE跳转，如果栈顶不等于零，JNE跳转。现在，我们将在指令列表中指定一个要跳转到的索引。</p><p id="cfd3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">新的<code class="fe le lf lg lh b">Inst</code>枚举看起来像:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="3fe2" class="lq lr iq lh b gy ls lt l lu lv">type Pointer = usize;<br/><br/>enum Inst {<br/>    Push(Pointer),<br/>    ...<br/>    Jump(Pointer),<br/>    JE(Pointer),<br/>    JNE(Pointer),<br/>}</span></pre><p id="9b36" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于<code class="fe le lf lg lh b">interpret</code>新指令，我们添加:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="56f2" class="lq lr iq lh b gy ls lt l lu lv">fn interpret&lt;'a&gt;(program: Program&lt;'a&gt;) {<br/>    use Inst::*;<br/><br/>    // instantiate stack as an empty Vector<br/>    let mut stack = Stack(Vec::new());<br/>    let mut pointer = 0;<br/><br/>    while let Some(instruction) = program.get(pointer) {<br/>        pointer += 1;<br/><br/>        match instruction {<br/>            ...<br/>            Jump(p) =&gt; pointer = *p;<br/>            JE(p) =&gt; {<br/>                if stack.peek() == 0 {<br/>                    pointer = *p;<br/>                }<br/>            }<br/>            JNE(p) =&gt; {<br/>                if stack.peek() != 0 {<br/>                    pointer = *p;<br/>                }<br/>            }<br/>        }<br/>    }<br/>}</span></pre><p id="05a7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这开启了一个充满可能性的世界。我们可以很容易地用JNE做循环:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="0a91" class="lq lr iq lh b gy ls lt l lu lv">interpret(vec![<br/>    Push(10),<br/>    Print,<br/>    Push(1),<br/>    Sub,<br/>    JNE(0),<br/>].as_slice());</span></pre><p id="e534" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这将打印从10到0的所有数字:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="fb28" class="lq lr iq lh b gy ls lt l lu lv">10<br/>9<br/>8<br/>7<br/>6<br/>5<br/>4<br/>3<br/>2<br/>1</span></pre><p id="6756" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下一步是使访问或更改任意堆栈值成为可能。在此之后，虚拟机将完成图灵。</p><p id="38ac" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以下是新的说明:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="e1f0" class="lq lr iq lh b gy ls lt l lu lv">enum Inst {<br/>    ...<br/>    Get(Pointer),<br/>    Set(Pointer),<br/>}</span></pre><p id="500f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe le lf lg lh b">Get(p)</code>只在n处索引栈，复制到栈顶。<code class="fe le lf lg lh b">Set(p)</code>获取堆栈顶部的值，并将其复制到堆栈的索引p处。</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="a426" class="lq lr iq lh b gy ls lt l lu lv">while let Some(instruction) = program.get(pointer) {<br/>    pointer += 1;<br/><br/>    match instruction {<br/>        ...<br/>        Get(p) =&gt; stack.push(*stack.0.get(*p).unwrap()),<br/>        Set(p) =&gt; {<br/>            let v = stack.pop();<br/>            *stack.0.get_mut(*p).unwrap() = v;<br/>        }<br/>    }<br/>}</span></pre><p id="c560" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此时，由于我们可以从堆栈中取出<code class="fe le lf lg lh b">Get</code>值，我们希望让我们的<code class="fe le lf lg lh b">JNE</code>和<code class="fe le lf lg lh b">JE</code>指令弹出比较值:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="9aea" class="lq lr iq lh b gy ls lt l lu lv">while let Some(instruction) = program.get(pointer) {<br/>    pointer += 1;<br/><br/>    match instruction {<br/>        ...<br/>        JE(p) =&gt; {<br/>            if stack.peek() == 0 {<br/>                stack.pop();<br/>                pointer = *p;<br/>            }<br/>        }<br/>        JNE(p) =&gt; {<br/>            if stack.peek() != 0 {<br/>                stack.pop();<br/>                pointer = *p;<br/>            }<br/>        }<br/>    }<br/>}</span></pre><p id="b886" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用这些新指令，我们可以编写一些稍微复杂一点的程序。下面是一个对前100个整数求和的程序:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="9d71" class="lq lr iq lh b gy ls lt l lu lv">interpret(vec![<br/>    // setup<br/>    Push(0), // the accumulator<br/>    Push(0), // the index<br/><br/>    // loop<br/>    // First, add the index to the accumulator<br/>    // stack: [accumulator, index]<br/>    Get(0),<br/>    Get(1),<br/>    // stack: [accumulator, index, accumulator, index]<br/>    Add,<br/>    // stack: [accumulator, index, accumulator + index]<br/>    Set(0),<br/>    Pop,<br/>    // stack: [accumulator + index, index]<br/><br/>    // next, increment the index<br/>    Push(1), // the increment<br/>    // stack: [accumulator, index, 1]<br/>    Add,<br/>    // stack: [accumulator, index + 1]<br/><br/>    // finally, compare the index with 100 and jump back to the start<br/>    // if they're not equal.<br/>    Get(1),<br/>    // stack: [accumulator, index, index]<br/>    Push(100),<br/>    Sub,<br/>    // stack: [accumulator, index, index - 100]<br/>    JNE(2),<br/><br/>    // if index - 100 == 0, print the accumulator<br/>    Get(0),<br/>    // stack: [accumulator, index, 0, accumulator]<br/>    Print<br/>].as_slice())</span></pre><p id="2ad4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">就这样，虚拟机图灵完成了！不过用起来超级别扭。我们可以跳转到代码的不同部分，但是因为我们是按照行号跳转的，所以每当我们改变代码时，我们必须更新每次跳转。稍后，我们将通过编写一个将文本标签解析为行号的超级简单的编译器来解决这个问题。</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="61d8" class="lq lr iq lh b gy ls lt l lu lv">// find_label takes a line split by spaces and the label it represents,<br/>// or None if it does not represent a label.<br/>fn find_label&lt;'a&gt;(i: Pointer, s: &amp;'a [&amp;'a str]) -&gt; Option&lt;Label&gt; {<br/>    if let ["label", l] = s {<br/>        Some((l, i))<br/>    } else {<br/>        None<br/>    }<br/>}<br/><br/>let input = ...; // a String<br/><br/>let line_splits = input<br/>        .split('\n')<br/>        .map(|s| s.split_whitespace().collect::&lt;Vec&lt;_&gt;&gt;())<br/>        .filter(|s| !matches!(s.as_slice(), [] | ["--", ..]))<br/>        .collect::&lt;Vec&lt;_&gt;&gt;();<br/><br/>let labels: HashMap&lt;&amp;str, usize&gt; = line_splits<br/>    .iter()<br/>    .enumerate()<br/>    .filter_map(|(i, s)| find_label(i, s.as_slice()))<br/>    .collect();</span></pre><p id="50cf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面的代码非常生疏，所以我不会详细解释，但本质上它在空间上分割每一行，遍历它们，并构造一个标签名称到行号的散列表。</p><p id="7ef5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们需要使用这些信息来编译指令。这也是相当生锈，但它非常简洁。</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="84c6" class="lq lr iq lh b gy ls lt l lu lv">fn parse_instruction(s: &amp;[&amp;str], labels: &amp;Labels) -&gt; Instruction {<br/>    use Instruction::*;<br/><br/>    match s {<br/>        ["Push", x] =&gt; Push(x.parse::&lt;isize&gt;().unwrap()),<br/>        ["Pop"] =&gt; Pop,<br/>        ["Add"] =&gt; Add,<br/>        ["Sub"] =&gt; Sub,<br/>        ["Mul"] =&gt; Mul,<br/>        ["Div"] =&gt; Div,<br/>        ["Jump", l] =&gt; Jump(*labels.get(l).unwrap()),<br/>        ["JE", l] =&gt; JE(*labels.get(l).unwrap()),<br/>        ["JNE", l] =&gt; JNE(*labels.get(l).unwrap()),<br/>        ["Get", p] =&gt; Get(p.parse::&lt;Pointer&gt;().unwrap()),<br/>        ["Set", p] =&gt; Set(p.parse::&lt;Pointer&gt;().unwrap()),<br/>        ["Print"] =&gt; Print,<br/>        ["label", ..] =&gt; Noop,<br/>        l =&gt; panic!("Invalid instruction: {:?}", l),<br/>    }<br/>}</span></pre><p id="87cd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可能会注意到，以label开头的行被编译成Noop。这只是为了便于跟踪行号；如果你把所有的错误一个一个的解决掉，你就可以不用它了。</p><p id="6630" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将这个函数映射到行列表上，实际上将文本“编译”成指令:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="6aed" class="lq lr iq lh b gy ls lt l lu lv">let instructions: Vec&lt;Instruction&gt; = line_splits<br/>    .iter()<br/>    .map(|s| parse_instruction(s.as_slice(), &amp;labels, &amp;procedures))<br/>    .collect();</span></pre><p id="62d3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们可以很容易地用<code class="fe le lf lg lh b">interpret(instructions.as_slice())</code>解释编译后的指令。利用这一点，我们可以很容易地重写之前的sum示例:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="d092" class="lq lr iq lh b gy ls lt l lu lv">Push 0<br/>Push 0<br/><br/>label loop<br/>    -- [accumulator, index]<br/>    Get 0<br/>    Get 1<br/>    -- [accumulator, index, accumulator, index]<br/>    Add<br/>    -- [accumulator, index, accumulator + index]<br/>    Set 0<br/>    Pop<br/>    -- [accumulator + index, index]<br/><br/>    -- [accumulator, index]<br/>    Push 1<br/>    Add<br/>    -- [accumulator, index + 1]<br/><br/>    -- [accumulator, index]<br/>    Get 1<br/>    Push 100<br/>    Sub<br/>    -- [accumulator, index, index - 100]<br/>    JNE loop<br/>Pop<br/><br/>Get 0<br/>Print</span></pre></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><p id="4807" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">标签很整洁。现在让我们添加程序。</p><p id="0259" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个VM中的过程基本上只是跳回到它们被调用点的标签。这使得逻辑推理变得更加容易。这也意味着我们必须实现一个调用栈。调用堆栈只是一个堆栈框架列表，最初我们的堆栈框架看起来就像这样:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="c751" class="lq lr iq lh b gy ls lt l lu lv">struct StackFrame {<br/>    pub ip: usize, // ip is a common acronym for instruction pointer<br/>}</span></pre><p id="25e8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为我们的调用堆栈只是一堆调用帧，所以它看起来像这样:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="bbd7" class="lq lr iq lh b gy ls lt l lu lv">type CallStack = Vec&lt;StackFrame&gt;;</span></pre><p id="d280" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第一步只是在解释函数开始时初始化我们的调用栈。</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="3615" class="lq lr iq lh b gy ls lt l lu lv">fn interpret&lt;'a&gt;(program: Program&lt;'a&gt;) {<br/>    ...<br/>    let mut stack = Stack(Vec::new());<br/>    let mut call_stack = CallStack::new();<br/>    ...<br/>}</span></pre><p id="c4c5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们将添加一些说明:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="45a0" class="lq lr iq lh b gy ls lt l lu lv">enum Instruction {<br/>    ...<br/>    Call(Pointer),<br/>    Ret,<br/>}</span></pre><p id="ac41" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Call是我们用来进入一个过程的指令。这基本上是一个跳转，但它也将调用位置推送到调用堆栈。Ret只是弹出调用堆栈，并返回到调用过程的位置。</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="3c49" class="lq lr iq lh b gy ls lt l lu lv">match instruction {<br/>    ...<br/>    Call(p) =&gt; {<br/>        call_stack.push(StackFrame {<br/>            ip: pointer<br/>        });<br/>        pointer = *p;<br/>    }<br/>    Ret =&gt; pointer = call_stack.pop.unwrap().ip,<br/>}</span></pre><p id="c3b4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可能已经注意到Call接受一个指针作为参数。不过，我们不想在代码中通过指针指定过程，所以我们将添加另一个编译步骤，就像我们对标签所做的那样。这有点复杂，因为我们需要知道一个过程的结束和开始的位置，否则当我们在代码中遇到这个过程而没有被调用时，我们将无法跳过它。</p><p id="a220" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有更好的方法可以做到这一点，但是在TinyVM过程中，声明被解析为跳转。我们使用结束标记来标记过程声明的结束。</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="81bd" class="lq lr iq lh b gy ls lt l lu lv">Proc proc_name // line n<br/>    ...   <br/>End // line n + l<br/><br/>...<br/><br/>Call proc_name</span></pre><p id="91b7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">得到解决</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="6d21" class="lq lr iq lh b gy ls lt l lu lv">Jump (n + 1)<br/>    // procedure contents<br/>    ...<br/>...<br/><br/>Call (n)</span></pre><p id="3bb8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这段代码也相当具体，所以我不会解释细节。</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="8d36" class="lq lr iq lh b gy ls lt l lu lv">type Procedures&lt;'a&gt; = BTreeMap&lt;&amp;'a str, (Pointer, Pointer)&gt;;<br/><br/>// find_procedures takes a list of lines split on space and<br/>// returns the procedures declared.<br/>fn find_procedures&lt;'a&gt;(lines: &amp;'a [Vec&lt;&amp;str&gt;]) -&gt; Procedures&lt;'a&gt; {<br/>    let mut ip = 0;<br/>    let mut res = Procedures::new();<br/><br/>    while ip &lt; lines.len() {<br/>        if let ["Proc", proc_name] = lines[ip].as_slice() {<br/>            let start_ip = ip;<br/>            while lines[ip] != &amp;["End"] {<br/>                ip += 1;<br/>            }<br/>            res.insert(proc_name, (start_ip, ip + 1));<br/>        } else {<br/>            ip += 1;<br/>        }<br/>    }<br/><br/>    res<br/>}</span></pre><p id="0653" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们使用这个地图，就像我们在<code class="fe le lf lg lh b">parse_instruction</code>函数中使用label one一样。</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="c01a" class="lq lr iq lh b gy ls lt l lu lv">fn parse_instruction(s: &amp;[&amp;str], labels: &amp;Labels, procedures: &amp;Procedures) -&gt; Instruction {<br/>    ...<br/><br/>    match s {<br/>        ...<br/>        ["Proc", proc] =&gt; Jump(procedures.get(proc).unwrap().1),<br/>        ["Call", proc] =&gt; Call(procedures.get(proc).unwrap().0 + 1),<br/>        ["Ret"] =&gt; Ret,<br/>        ["label", ..] | ["End"] =&gt; Noop,<br/><br/>    }<br/>}</span></pre><p id="0ec2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有了它，我们可以编写一些简单的程序</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="a1cc" class="lq lr iq lh b gy ls lt l lu lv">-- assumes [a, b, c] top of stack<br/>Proc addMul<br/>    Add<br/>    Mul<br/>    Ret<br/>End</span></pre><p id="19ce" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个程序取一个栈[…，a，b，c]并把它变成[…，a * b + c]。</p><p id="0b71" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里的问题是很难进行重要的计算，因为我们不知道在栈上的哪个索引处访问变量。例如，我们如何编写一个过程来计算栈顶值的平方？我们早就将<code class="fe le lf lg lh b">Get</code>顶值化了，但我们不知道它的指数。</p><p id="cc35" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在TinyVM中，这是通过向每个堆栈帧添加另一个参数来解决的；调用堆栈时的堆栈偏移量或堆栈长度。然后我们添加两条新指令；<code class="fe le lf lg lh b">GetArg</code>和<code class="fe le lf lg lh b">SetArg</code>。这两条指令在堆栈偏移量之前引用堆栈索引<em class="lw">。例如，在square过程中，我们将使用<code class="fe le lf lg lh b">GetArg 0</code>来访问在过程被调用之前位于堆栈顶部的值。我们还必须更新Get和Set，以便只访问堆栈偏移量</em>之后的索引<em class="lw">。</em></p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="ac3b" class="lq lr iq lh b gy ls lt l lu lv">Proc square<br/>    -- stack is [..., x]<br/>    GetArg 0<br/>    -- stack is [..., x, x]<br/>    Mul<br/>    -- stack is [..., x * x]<br/>    Ret<br/>End</span></pre><p id="0688" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们还可以写一些更有趣的程序。这是阶乘:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="3285" class="lq lr iq lh b gy ls lt l lu lv">Proc fibStep<br/>    GetArg 0<br/>    GetArg 1<br/>    -- [a, b, | b, a]<br/>    Add<br/>    -- [a, b, | b + a]<br/>    GetArg 0<br/>    -- [a, b, | b + a, b]<br/>    SetArg 1<br/>    Pop<br/>    -- [b, b, | b + a]<br/>    SetArg 0<br/>    Pop<br/>    -- [b, b + a | ]<br/>    Ret<br/>End</span></pre><p id="13b9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个过程将堆栈[…，a，b]变成[…，b，b + a]。它用于迭代计算第n个斐波那契数:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="feb0" class="lq lr iq lh b gy ls lt l lu lv">Push 0<br/>Push 1<br/>Push 1<br/><br/>-- [i, a, b]<br/>label loop<br/>    Call fibStep<br/>    -- [i, a, b]<br/>    Get 0<br/>    Push 1<br/>    -- [i, a, b, i, 1]<br/>    Add<br/>    -- [i, a, b, i + 1]<br/>    Set 0<br/>    Pop<br/>    -- [i + 1, a, b]<br/>    -- [i, a, b]<br/>    Get 0<br/>    Push 40<br/>    Sub<br/>    -- [i, a, b, i - 40]<br/>    JNE loop<br/>    Pop<br/>-- [i, a, b]<br/><br/>Print</span></pre><p id="ddb1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">实现这一点在逻辑上非常简单，但是有点容易出错。首先，我们只需更新StackFrame结构:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="ea65" class="lq lr iq lh b gy ls lt l lu lv">struct StackFrame {<br/>    pub stack_offset: Pointer,<br/>    pub ip: Pointer,<br/>}</span></pre><p id="4b2d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们更新Call、Get、Set、GetArg和SetArg函数。</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="d08a" class="lq lr iq lh b gy ls lt l lu lv">fn interpret&lt;'a&gt;(program: Program&lt;'a&gt;) {<br/>    ...<br/>    match instruction {<br/>        // the .map_or just makes sure that the stack offset is treated as zero <br/>        // when the stack is empty.<br/>        Get(i) =&gt; stack.push(*stack.get(*i + call_stack.last().map_or(0, |s| s.stack_offset))),<br/>        Set(i) =&gt; {<br/>            *stack<br/>                .0<br/>                .get_mut(*i + call_stack.last().map_or(0, |s| s.stack_offset))<br/>                .unwrap() = stack.peek()<br/>        }<br/>        GetArg(i) =&gt; stack.push(<br/>            *stack<br/>                .0<br/>                .get(call_stack.last().unwrap().stack_offset - 1 - *i)<br/>                .unwrap(),<br/>        ),<br/>        SetArg(i) =&gt; {<br/>            let offset_i = call_stack.last().unwrap().stack_offset - 1 - *i;<br/>            let new_val = stack.peek();<br/>            *stack.get_mut(offset_i) = new_val;<br/>        }<br/>        Call(p) =&gt; {<br/>            call_stack.push(StackFrame {<br/>                stack_offset: stack.0.len(),<br/>                ip: pointer,<br/>            });<br/>            pointer = *p;<br/>        }<br/>    }<br/>}</span></pre><p id="d789" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">就是这样！使用这个虚拟机，你可以编写几乎任何计算。作为练习，您可以实现用户输入来添加更多的功能。您也可以尝试为这个VM实现一个编译器。它运行得非常快，因为它只支持一种类型的值。</p><p id="56af" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最近我建了一个Twitter账户，在那里我发了很多关于我的项目的微博。考虑关注我<a class="ae kw" href="https://twitter.com/fiiissshh" rel="noopener ugc nofollow" target="_blank">@ fiissshh</a>。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><p id="a980" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="lw">原载于2021年4月6日</em><a class="ae kw" href="https://mkhan45.github.io/2021/04/06/Writing-a-Tiny-Stack-VM-in-Rust.html" rel="noopener ugc nofollow" target="_blank"><em class="lw">https://mkhan 45 . github . io</em></a><em class="lw">。</em></p></div></div>    
</body>
</html>