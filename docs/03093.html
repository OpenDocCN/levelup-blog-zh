<html>
<head>
<title>GraphQL is the New API Gateway</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GraphQL是新的API网关</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/graphql-is-the-new-api-gateway-383edeed4bcd?source=collection_archive---------3-----------------------#2020-04-19">https://levelup.gitconnected.com/graphql-is-the-new-api-gateway-383edeed4bcd?source=collection_archive---------3-----------------------#2020-04-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="b091" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">利用GraphQL保护您的外部API并减少攻击面</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6aa1f1d6ed5e699c39e41acd8c0505bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*sEPYceX2cO5RULW0.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">来源:https://www.forumsys.com/wp-content/uploads/APISM.png</figcaption></figure><p id="d5d8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我最近参与的许多项目之一就是从头开始设计一个新的应用程序。这是一个大型企业业务应用程序，将有许多前端用户。所需的逻辑和功能数量将在架构中的大约50个微服务中结束，一些部署到云，一些需要在OpenShift集群中本地托管，这将是我们与遗留数据系统的连接。</p><p id="b2ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这家公司以前从未构建过如此多的微服务，也没有在云中使用过。棘手的问题之一是如何协调服务网格，以确保前端的变化不会破坏应用程序，后端服务的变化也不会破坏前端。</p><blockquote class="lv lw lx"><p id="8f76" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">我推荐的解决方案是:利用GraphQL作为一个<strong class="lb iu">企业API网关</strong>。</p></blockquote></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h2 id="cc8a" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated"><strong class="ak">简化部署流程</strong></h2><p id="6ad3" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">所有这些API的一个问题是，对其中任何一个API的更改都可能会破坏另一个API。虽然“微服务”应该是独立的，但实际上这仍然意味着在响应中丢失数据。</p><p id="210b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们有两个部署了不同服务的平台时，这变得更加复杂。对于本地OpenShift和云原生lambda服务，将使用不同的CI/CD管道。</p><p id="8816" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">用GraphQL作为我们所有服务的前端简化了协调这些平台部署的需要。你怎么问？现在，我的前端应用程序将只与一个端点对话。这是一个用于查询和发布数据的无版本模式，所以我不需要对前端进行更改，因为后端的一些内容已经发生了变化。GraphQL端点保持不变，即使我的后端发生变化也能继续工作。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nh"><img src="../Images/338b0d79c9a7e08d8ac61e82d5bcc99b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*VNcIhiztbake81ex.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">Lambda的CI/CD管道示例(<a class="ae ky" href="https://blog.h4.nz/media/Serverless-my-micro/Lambda%20Pipeline%20Example.png" rel="noopener ugc nofollow" target="_blank">来源</a>)</figcaption></figure></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h2 id="b1df" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated">简化安全性</h2><p id="d80f" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">这个架构带来的另一个话题是如何保护我们所有的服务？我们是否构建了一个在访问其他服务之前必须被称为sure的安全令牌服务？我们是否为每个服务添加逻辑，以确保令牌在报头中，并且在任何地方都得到验证？</p><p id="c537" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">再说一次，我的答案是不！让API网关位于所有服务的前端，可以让您将安全检查/验证提升一个层次。这使得开发人员可以专注于开发具有商业价值的功能。它还减少了膨胀和到处重复的额外代码。</p><p id="86f6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以用GraphQL实现几件事来提高安全性:</p><p id="c375" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">深度限制</strong></p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="ff4c" class="mj mk it nj b gy nn no l np nq">import depthLimit from 'graphql-depth-limit'<br/>import express from 'express'<br/>import graphqlHTTP from 'express-graphql'<br/>import schema from './schema'<br/><br/>const app = express()<br/><br/>app.use('/graphql', graphqlHTTP((req, res) =&gt; ({<br/>  schema,<br/>  validationRules: [ depthLimit(10) ]<br/>})))</span></pre><p id="9ecc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">速率限制</strong></p><p id="3eb7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个<a class="ae ky" href="https://github.com/teamplanes/graphql-rate-limit" rel="noopener ugc nofollow" target="_blank"> GraphQL速率限制</a>插件允许你以三种不同的方式指定查询和变异的限制，自定义指令graphql-shield，或者使用基本速率限制器函数。</p><p id="9255" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">该插件允许您设置时间窗口和限制。对高度易受攻击的突变和查询(如登录)设置较大的时间窗口，对不太易受攻击的查询设置较短的限制，这将有助于您为合法用户保持良好的体验，同时也是攻击者的噩梦。</p><p id="89cf" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">查询费用限制</strong></p><pre class="kj kk kl km gt ni nj nk nl aw nm bi"><span id="dfc5" class="mj mk it nj b gy nn no l np nq">app.use(  <br/>  '/graphql',  <br/>  graphqlExpress(req =&gt; {    <br/>    return {      <br/>      schema,      <br/>      rootValue: null,      <br/>      validationRules: [        <br/>        costAnalysis({          <br/>          variables: req.body.variables,          <br/>          maximumCost: 1000,        <br/>        }),      <br/>       ],    <br/>     }  <br/>   })<br/>)</span></pre></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h2 id="a261" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated">新的部署选项</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/482a7247244712649cd1334834683369.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5u-BpJPx8Eywfd1W"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">来源:<a class="ae ky" href="https://docs.microsoft.com/en-us/azure/devops/migrate/media/phase-rollout-with-rings/phase-rollout-with-rings-pipeline.png?view=azure-devops" rel="noopener ugc nofollow" target="_blank">https://docs . Microsoft . com/en-us/azure/devo PS/migrate/media/phase-rollout-with-rings/phase-rollout-with-rings-pipeline . png？view=azure-devops </a></figcaption></figure><p id="2021" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果没有GraphQL，我将不得不非常小心地对API进行版本化和更新。我可以运行多个版本的API，如<code class="fe ns nt nu nj b">/v1</code>和<code class="fe ns nt nu nj b">/v2</code>，但我必须确保上游API和前端应用程序对<code class="fe ns nt nu nj b"> /v2 </code>进行更新，以便淘汰<code class="fe ns nt nu nj b">/v1</code>。此外，我将不得不在同一个代码库或容器中同时支持这两者，这使它变得更脆弱，更容易发生重大变化。有了充当代理的GraphQL服务，我可以推出一个T4容器，让两者并行运行。我可以修改GraphQL解析器来指向<code class="fe ns nt nu nj b">/v2</code>，而不需要修改前端代码。这使得部署新功能变得更加容易！</p><p id="3be3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我还可以为任何服务选择任何部署策略，例如:</p><ul class=""><li id="6aff" class="nv nw it lb b lc ld lf lg li nx lm ny lq nz lu oa ob oc od bi translated">蓝色/绿色</li><li id="6569" class="nv nw it lb b lc oe lf of li og lm oh lq oi lu oa ob oc od bi translated">金丝雀释放</li><li id="3eb6" class="nv nw it lb b lc oe lf of li og lm oh lq oi lu oa ob oc od bi translated">特征标记</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/9a53a33a219eb63a13aa3798a1e785ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*qAOsHqcjIz45iM6G.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">蓝/绿部署示例(<a class="ae ky" href="https://res.cloudinary.com/practicaldev/image/fetch/s--HW_8_gYS--/c_imagga_scale,f_auto,fl_progressive,h_500,q_auto,w_1000/https://thepracticaldev.s3.amazonaws.com/i/m664yyotixnqncprryf0.png" rel="noopener ugc nofollow" target="_blank">来源</a>)</figcaption></figure></div><div class="ab cl mc md hx me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="im in io ip iq"><h2 id="3871" class="mj mk it bd ml mm mn dn mo mp mq dp mr li ms mt mu lm mv mw mx lq my mz na nb bi translated">摘要</h2><p id="5f68" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">如今，开发新的应用程序架构的首选当然是查看微服务模式。所有这些小服务一起工作，并暴露在API网关之后，以便我的前端SPA应用程序可以使用它们向您的最终用户显示信息。</p><p id="7160" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">GraphQL减少了攻击面，简化了应用程序开发以及服务的实际部署。</p><h1 id="8a0a" class="ok mk it bd ml ol om on mo oo op oq mr jz or ka mu kc os kd mx kf ot kg na ou bi translated">顺便说一下，👏🏻*鼓掌*👏🏻如果你喜欢这篇文章，请举手(高达50倍)。它鼓励我继续写作，并帮助其他人找到它:)</h1><p id="0c29" class="pw-post-body-paragraph kz la it lb b lc nc ju le lf nd jx lh li ne lk ll lm nf lo lp lq ng ls lt lu im bi translated">请跟随👉<a class="ov ow ep" href="https://medium.com/u/97d099c3810d?source=post_page-----383edeed4bcd--------------------------------" rel="noopener" target="_blank"> Tj博客</a>了解更多精彩的DevOps故事！</p></div></div>    
</body>
</html>