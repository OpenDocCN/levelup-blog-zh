<html>
<head>
<title>What is Database Sharding and How is it Done</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是数据库分片，是如何实现的</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/what-is-database-sharding-and-how-is-it-done-f36b9cb653e8?source=collection_archive---------5-----------------------#2020-05-03">https://levelup.gitconnected.com/what-is-database-sharding-and-how-is-it-done-f36b9cb653e8?source=collection_archive---------5-----------------------#2020-05-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/560679fcdc36beba809996a18f92e218.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1BC4fUaZWqXXs_-Z"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">约书亚·索蒂诺在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="2ea2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">数据库分片是将大表分解成多个更小的表或称为分片的块，并将数据分布到多个机器或集群的过程。每个分片都有与原始表相同的模式和列，但是每个分片中存储的数据是唯一的，并且独立于其他分片。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lb"><img src="../Images/02dba44ffdd705e054e25cbe18cf6b74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-3CrSE3jsfH1AQd8BB2tcA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">数据库分片</figcaption></figure><p id="2845" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae kc" href="https://en.wikipedia.org/wiki/Database" rel="noopener ugc nofollow" target="_blank">数据库</a>分片非常类似于<a class="ae kc" href="https://nlogn.in/horizontal-scaling-and-vertical-scaling/" rel="noopener ugc nofollow" target="_blank">水平缩放</a>(横向扩展)。因此，它允许我们向现有集群添加更多的机器，以便分散负载，允许更多的流量和更快的处理。此外，分片有助于使我们的应用程序分布式，从而最大限度地减少单点故障。</p><h1 id="4dd0" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">数据库分片技术</h1><p id="b977" class="pw-post-body-paragraph kd ke iq kf b kg me ki kj kk mf km kn ko mg kq kr ks mh ku kv kw mi ky kz la ij bi translated">数据库分片需要以这样的方式完成，即将到来的数据应该插入到正确的分片中，不应该有任何数据丢失，结果查询不应该很慢。考虑到所有这些，让我们看看我们有哪些共享数据库的技术。</p><p id="a880" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> 1)基于哈希的分片</strong></p><p id="071c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在基于哈希的分片(也称为基于密钥的分片)中，我们从新插入的数据中获取一个密钥值(如客户id、客户IP地址或电子邮件Id等，基于我们已经确定的标准)，将它传递给哈希函数，并将数据插入到结果分片编号中。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/9dcb13d526f7b1a0f93e7f158de45119.png" data-original-src="https://miro.medium.com/v2/resize:fit:1154/format:webp/1*f1-f9PLWjMv0Vw6p_A8Nzg.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">基于哈希的分片</figcaption></figure><p id="7868" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是最简单的分片算法，可用于在分片之间均匀分布数据，并防止出现<strong class="kf ir">数据库热点</strong>的风险。当一个碎片比所有其他碎片被更多地访问时，数据库热点问题就出现了，因此，在这种情况下，对数据库进行碎片化的任何好处都被变慢和崩溃抵消了。</p><p id="15d1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种方法的主要问题是动态添加或删除数据库服务器非常困难。每当这种情况发生时，我们都需要重新划分数据库，这意味着我们需要更新哈希函数并重新平衡数据。此外，如果这种情况经常发生，也会导致数据丢失。</p><p id="340b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上述问题的一个解决方案是使用<a class="ae kc" href="https://nlogn.in/consistent-hashing-system-design/" rel="noopener ugc nofollow" target="_blank">一致散列</a>。一致散列提供了<a class="ae kc" href="https://en.wikipedia.org/wiki/Scalability" rel="noopener ugc nofollow" target="_blank">可伸缩性</a>，即使我们在许多服务器(数据库服务器)中拥有大量数据，并且可用服务器的数量不断变化(要么添加新服务器，要么删除服务器)。参见“<a class="ae kc" href="https://nlogn.in/consistent-hashing-system-design/" rel="noopener ugc nofollow" target="_blank">一贯哈希法</a>”以了解详情。</p><p id="323c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> 2)基于范围的分片</strong></p><p id="293f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在基于范围的分片中，分片是根据分片键的范围选择的。分片的范围是这样选择的，即分片密钥可能落入所有可能范围中的任何一个。</p><p id="06a3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设我们有一个推荐系统，它存储了用户的所有信息，并根据用户的年龄推荐他们的电影。因此，我们可以创建一些不同的碎片，并根据用户所处的年龄范围划分用户信息，如下所示:</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/fb5c2e37d30990e42baed8db4f94adfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1374/format:webp/1*sAwIpwIDA0XnkHOJgJCzQA.png"/></div></figure><p id="44e4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">基于范围的分片很容易实现，因为我们只需要检查当前数据所在的范围，并从对应于该分片的分片中插入/读取数据。此外，每个碎片保存不同的数据集，但是所有碎片的模式都与原始数据库的模式相同。</p><p id="d4f1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种技术的主要缺点是，如果我们的数据分布不均匀，它会再次导致数据库热点。</p><p id="f96c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> 3)基于目录的分片</strong></p><p id="c4b6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在基于目录的分片中有一个<strong class="kf ir">查找表</strong>也称为位置服务。它存储共享密钥来跟踪哪个碎片存储了什么条目。为了读取或写入数据，客户端引擎首先使用shard-key查询查找表以找到相应数据的碎片号，然后访问特定的碎片以执行进一步的操作。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/9023abcb291e171ff45b6f9890c3c4c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1366/format:webp/1*FLtu-yyQbCe7GJmMxknQ8Q.png"/></div></figure><p id="bf29" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这非常类似于基于范围的分片，除了不是确定分片键的数据属于哪个范围，而是每个键绑定到它自己的特定分片。</p><p id="8e8d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">与使用固定哈希函数的基于哈希的分片和需要我们预先指定范围的基于范围的分片不同，基于目录的分片允许您使用我们想要使用的任何系统或算法来将数据条目分配给分片，并且使用这种方法动态添加分片相对容易。</p><p id="0d02" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">基于目录的分片的主要问题是，我们需要在每次读写查询之前查阅查找表，因此它会影响应用程序的性能。此外，查找表容易出现单点故障。这个问题的一个解决方案可以是使用负载平衡器，但是频繁地更新每个服务器中的查找表副本将是开销。</p><p id="f566" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">查看FreshWork如何使用基于目录的分片"<a class="ae kc" href="https://freshdesk.com/product-updates/how-freshdesk-scaled-using-sharding-blog/" rel="noopener ugc nofollow" target="_blank">我们如何扩展Freshdesk </a>"。</p><p id="2add" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> 4)基于地理的分片</strong></p><p id="0266" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">基于地理的分片类似于基于范围的分片。在基于地理的分片中，数据由对应于用户区域或位置的分片来处理。Tinder使用基于地理的分片。tinders对地理分片进行了限制，限制范围为100英里，并确保地理分片的生产负载平衡。</p><h1 id="be85" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">分片的好处</h1><ol class=""><li id="50e6" class="mm mn iq kf b kg me kk mf ko mo ks mp kw mq la mr ms mt mu bi translated">数据库分片有助于我们实现水平扩展。因此，我们可以向现有的服务器添加更多的机器，并分配负载来扩展应用程序。</li><li id="5ce4" class="mm mn iq kf b kg mv kk mw ko mx ks my kw mz la mr ms mt mu bi translated">更快的查询响应时间。如果没有数据库分片，数据库需要将一个查询与每一行进行比较，这可能是一个巨大的挫折。但是使用分片而不是遍历所有行，我们只需要遍历几行。</li><li id="d6f4" class="mm mn iq kf b kg mv kk mw ko mx ks my kw mz la mr ms mt mu bi translated">分片使得维护变得更加容易。</li><li id="faba" class="mm mn iq kf b kg mv kk mw ko mx ks my kw mz la mr ms mt mu bi translated">数据库分片消除了单点故障的问题，并使我们的应用程序更加容错。</li><li id="0bd2" class="mm mn iq kf b kg mv kk mw ko mx ks my kw mz la mr ms mt mu bi translated">降低成本。向单个is机器添加更多的RAM和存储(垂直扩展)是昂贵的，而拥有几个计算能力较低的节点是便宜的。参见“<a class="ae kc" href="https://dba.stackexchange.com/questions/102179/why-is-vertical-scaling-expensive" rel="noopener ugc nofollow" target="_blank">为什么垂直伸缩很贵？</a>“多学习。</li></ol><h1 id="3778" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">分片的缺点</h1><ol class=""><li id="47d2" class="mm mn iq kf b kg me kk mf ko mo ks mp kw mq la mr ms mt mu bi translated">当涉及到实际实现时，数据库分片变得复杂。此外，如果操作不当，可能会导致数据丢失或损坏表。</li><li id="24d7" class="mm mn iq kf b kg mv kk mw ko mx ks my kw mz la mr ms mt mu bi translated">分片的另一个主要问题是分片是否变得不平衡。</li><li id="ee65" class="mm mn iq kf b kg mv kk mw ko mx ks my kw mz la mr ms mt mu bi translated">一旦数据库被分片，就很难返回到原始的未分片版本。</li><li id="10e1" class="mm mn iq kf b kg mv kk mw ko mx ks my kw mz la mr ms mt mu bi translated">并非所有数据库都支持分片。例如，PostgreSQL不支持自动分片特性，尽管可以手动分片，但这也会增加复杂性。</li></ol><p id="c37d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">进一步说明:</strong></p><ol class=""><li id="b4e8" class="mm mn iq kf b kg kh kk kl ko na ks nb kw nc la mr ms mt mu bi translated"><strong class="kf ir">分片与分区:</strong>分区是在同一台机器上跨表或数据库的数据分布。分片是一种特定类型的分区，称为水平分区。在分片中，我们将数据分布在多个不同的服务器上。</li><li id="44ed" class="mm mn iq kf b kg mv kk mw ko mx ks my kw mz la mr ms mt mu bi translated"><strong class="kf ir">我应该做分片吗？</strong>只有在绝对必要时才应进行分片，因为这会增加额外的操作复杂性。最常见的是当我们处理大量数据时。分片可能有所帮助的一些场景:</li></ol><ul class=""><li id="621d" class="mm mn iq kf b kg kh kk kl ko na ks nb kw nc la nd ms mt mu bi translated">当数据量超过我们服务器的能力，垂直扩展不可能或过于昂贵时。</li><li id="866f" class="mm mn iq kf b kg mv kk mw ko mx ks my kw mz la nd ms mt mu bi translated">如果读写请求的数量超过了单个节点的能力，并且通常是均匀分布的。</li><li id="8639" class="mm mn iq kf b kg mv kk mw ko mx ks my kw mz la nd ms mt mu bi translated">创建多个读取副本或负载平衡也被证明是没有帮助的。</li></ul><p id="0249" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">是不是，我们遗漏了什么，或者你想补充一些其他的要点？请评论</p></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><p id="ed1b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="nl">原载于2020年5月3日https://intmain.co</em><a class="ae kc" href="https://intmain.co/what-is-database-sharding-and-how-is-it-done/" rel="noopener ugc nofollow" target="_blank"><em class="nl"/></a><em class="nl">。</em></p></div></div>    
</body>
</html>