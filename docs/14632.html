<html>
<head>
<title>Stop Looping Through Pandas DataFrames &amp; Do This Instead</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">停止循环熊猫数据帧&amp;改为这样做</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/stop-looping-through-pandas-dataframes-do-this-instead-ddcb6009cbc1?source=collection_archive---------0-----------------------#2022-12-14">https://levelup.gitconnected.com/stop-looping-through-pandas-dataframes-do-this-instead-ddcb6009cbc1?source=collection_archive---------0-----------------------#2022-12-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="744e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi ko translated">处理Pandas数据帧可能是一项乏味且耗时的任务，尤其是在循环遍历它们的时候。如果您像大多数Python开发人员一样，您可能已经花了大量时间试图找出最有效的方法来遍历数据帧。但是如果有更简单的方法呢？在本文中，我们将向您展示不需要循环的处理Pandas数据帧的更好方法。我们将讨论这些方法的优点，并提供一些实际例子来帮助您开始。所以，如果你已经准备好停止遍历熊猫数据帧，去做一些更好的事情，请继续读下去！</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi kx"><img src="../Images/b06831242ebf17ff31a479ae226e816e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3yq0bbCT-PbXtVsr"/></div></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk translated">由<a class="ae ln" href="https://unsplash.com/@jodaarba?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">何塞·阿拉贡内塞斯</a>在<a class="ae ln" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h2 id="e243" class="lo lp it bd lq lr ls dn lt lu lv dp lw kb lx ly lz kf ma mb mc kj md me mf mg bi translated">目录:</h2><ol class=""><li id="45f2" class="mh mi it js b jt mj jx mk kb ml kf mm kj mn kn mo mp mq mr bi translated">为什么我们需要高效的编码？</li><li id="4f88" class="mh mi it js b jt ms jx mt kb mu kf mv kj mw kn mo mp mq mr bi translated">使用有效地循环。iterrows()</li><li id="4650" class="mh mi it js b jt ms jx mt kb mu kf mv kj mw kn mo mp mq mr bi translated">使用有效循环。应用()</li><li id="b6ef" class="mh mi it js b jt ms jx mt kb mu kf mv kj mw kn mo mp mq mr bi translated">使用矢量化有效循环</li><li id="44c4" class="mh mi it js b jt ms jx mt kb mu kf mv kj mw kn mo mp mq mr bi translated">最佳实践总结</li></ol><h2 id="7484" class="lo lp it bd lq lr ls dn lt lu lv dp lw kb lx ly lz kf ma mb mc kj md me mf mg bi translated">您可以在GitHub知识库中找到本文中使用的代码和数据集:</h2><div class="mx my gp gr mz na"><a href="https://github.com/youssefHosni/Efficient-Python-for-Data-Scientists" rel="noopener  ugc nofollow" target="_blank"><div class="nb ab fo"><div class="nc ab nd cl cj ne"><h2 class="bd iu gy z fp nf fr fs ng fu fw is bi translated">GitHub-youssefHosni/面向数据科学家的高效Python</h2><div class="nh l"><h3 class="bd b gy z fp nf fr fs ng fu fw dk translated">作为数据科学家学习如何编写高效的python代码如何编写Python干净的代码[文章]编写高效…</h3></div><div class="ni l"><p class="bd b dl z fp nf fr fs ng fu fw dk translated">github.com</p></div></div><div class="nj l"><div class="nk l nl nm nn nj no lh na"/></div></div></a></div></div><div class="ab cl np nq hx nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="im in io ip iq"><p id="70aa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">如果你想免费学习数据科学和机器学习，看看这些资源:</strong></p><ul class=""><li id="6d73" class="mh mi it js b jt ju jx jy kb nw kf nx kj ny kn nz mp mq mr bi translated">免费互动路线图，自学数据科学和机器学习。从这里开始:<a class="ae ln" href="https://aigents.co/learn/roadmaps/intro" rel="noopener ugc nofollow" target="_blank">https://aigents.co/learn/roadmaps/intro</a></li><li id="5ec4" class="mh mi it js b jt ms jx mt kb mu kf mv kj mw kn nz mp mq mr bi translated">数据科学学习资源搜索引擎(免费)。将你最喜欢的资源加入书签，将文章标记为完整，并添加学习笔记。<a class="ae ln" href="https://aigents.co/learn" rel="noopener ugc nofollow" target="_blank">https://aigents.co/learn</a></li><li id="d26e" class="mh mi it js b jt ms jx mt kb mu kf mv kj mw kn nz mp mq mr bi translated">想要在导师和学习社区的支持下从头开始学习数据科学吗？免费加入这个学习圈:<a class="ae ln" href="https://community.aigents.co/spaces/9010170/" rel="noopener ugc nofollow" target="_blank">https://community.aigents.co/spaces/9010170/</a></li></ul></div><div class="ab cl np nq hx nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="im in io ip iq"><p id="c01f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你想在数据科学&amp;人工智能领域开始职业生涯，但不知道如何开始。我提供数据科学指导课程和长期职业指导:</p><ul class=""><li id="922f" class="mh mi it js b jt ju jx jy kb nw kf nx kj ny kn nz mp mq mr bi translated">长期指导:<a class="ae ln" href="https://lnkd.in/dtdUYBrM" rel="noopener ugc nofollow" target="_blank">https://lnkd.in/dtdUYBrM</a></li><li id="c794" class="mh mi it js b jt ms jx mt kb mu kf mv kj mw kn nz mp mq mr bi translated">辅导课程:<a class="ae ln" href="https://lnkd.in/dXeg3KPW" rel="noopener ugc nofollow" target="_blank">https://lnkd.in/dXeg3KPW</a></li></ul><p id="d774" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="oa">加入</em> </strong> <a class="ae ln" href="https://youssefraafat57.medium.com/membership" rel="noopener"> <strong class="js iu"> <em class="oa">中等会员</em> </strong> </a> <strong class="js iu"> <em class="oa">计划继续无限制学习。如果你使用下面的链接，我会收到一小部分会员费，不需要你额外付费。</em>T13】</strong></p><div class="mx my gp gr mz na"><a href="https://youssefraafat57.medium.com/membership" rel="noopener follow" target="_blank"><div class="nb ab fo"><div class="nc ab nd cl cj ne"><h2 class="bd iu gy z fp nf fr fs ng fu fw is bi translated">加入我的介绍链接媒体-优素福胡斯尼</h2><div class="nh l"><h3 class="bd b gy z fp nf fr fs ng fu fw dk translated">阅读Youssef Hosni(以及媒体上成千上万的其他作家)的每一个故事。您的会员费直接支持…</h3></div><div class="ni l"><p class="bd b dl z fp nf fr fs ng fu fw dk translated">youssefraafat57.medium.com</p></div></div><div class="nj l"><div class="ob l nl nm nn nj no lh na"/></div></div></a></div></div><div class="ab cl np nq hx nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="im in io ip iq"><p id="df1c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">贯穿本文，我们将使用<a class="ae ln" href="https://github.com/youssefHosni/Advanced-Python-for-Data-Scientists/blob/main/Datasets/poker_hand.csv" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">扑克牌游戏数据集</strong> </a> <strong class="js iu">。</strong>首先，让我们加载并浏览数据:</p><pre class="ky kz la lb gt oc od oe bn of og bi"><span id="1d7e" class="oh lp it od b be oi oj l ok ol"><br/>poker_data = pd.read_csv('poker_hand.csv')<br/>poker_data.head()</span></pre><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi om"><img src="../Images/01c1c2f2306c95f4187c49809e2783f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*84X7UumdLxKXZvXY.png"/></div></div></figure><p id="0eca" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在每一轮扑克游戏中，每个玩家手里都有五张牌，每张牌都有其符号和等级，符号可以是红心、方块、梅花或黑桃，等级从1到13不等。该数据集由一个人可能拥有的五张卡的所有可能组合组成。</p><ul class=""><li id="3342" class="mh mi it js b jt ju jx jy kb nw kf nx kj ny kn nz mp mq mr bi translated">Sn:第n张牌的符号，其中:1(红心)，2(方块)，3(梅花)，4(黑桃)</li><li id="ab7b" class="mh mi it js b jt ms jx mt kb mu kf mv kj mw kn nz mp mq mr bi translated">Rn:第n张牌的等级，其中:1(王牌)，2–10，11(杰克)，12(王后)，13(国王)</li></ul></div><div class="ab cl np nq hx nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="im in io ip iq"><h1 id="c92f" class="on lp it bd lq oo op oq lt or os ot lw ou ov ow lz ox oy oz mc pa pb pc mf pd bi translated">1.为什么我们需要高效的编码？</h1><p id="7d08" class="pw-post-body-paragraph jq jr it js b jt mj jv jw jx mk jz ka kb pe kd ke kf pf kh ki kj pg kl km kn im bi translated">高效代码是指执行速度更快、计算内存更少的代码。在本文中，我们将使用<strong class="js iu"> time() </strong>函数来测量计算时间。这个函数测量当前时间，所以我们将在代码执行前和执行后把它赋给一个变量，然后计算差值，就知道代码的计算时间。下面的代码显示了一个简单的例子:</p><pre class="ky kz la lb gt oc od oe bn of og bi"><span id="5eb7" class="oh lp it od b be oi oj l ok ol">import time<br/># record time before execution<br/>start_time = time.time()<br/># execute operation<br/>result = 5 + 2<br/># record time after execution<br/>end_time = time.time()<br/>print("Result calculated in {} sec".format(end_time - start_time))</span></pre><p id="9947" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们看一些应用高效代码方法将如何提高代码运行时间和降低计算时间复杂性的例子:我们将计算从零到一百万的每个数字的平方。首先，我们将使用list comprehension来执行这个操作，然后使用for循环重复相同的过程。</p><p id="8008" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第一次使用列表理解:</p><pre class="ky kz la lb gt oc od oe bn of og bi"><span id="a490" class="oh lp it od b be oi oj l ok ol">#using List comprehension <br/><br/>list_comp_start_time = time.time()<br/>result = [i*i for i in range(0,1000000)]<br/>list_comp_end_time = time.time()<br/>print("Time using the list_comprehension: {} sec".format(list_comp_end_time -<br/>list_comp_start_time))</span></pre><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi ph"><img src="../Images/2f185e300f3ed73f968c51bd61338853.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Tnr3hQ4ylH9SVj7i.png"/></div></div></figure><p id="7cf2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们将使用for循环来执行相同的操作:</p><pre class="ky kz la lb gt oc od oe bn of og bi"><span id="0f18" class="oh lp it od b be oi oj l ok ol"># Using For loop<br/><br/>for_loop_start_time= time.time()<br/>result=[]<br/>for i in range(0,1000000):<br/>  result.append(i*i)<br/>for_loop_end_time= time.time()<br/>print("Time using the for loop: {} sec".format(for_loop_end_time - for_loop_start_time))</span></pre><figure class="ky kz la lb gt lc gh gi paragraph-image"><div class="gh gi pi"><img src="../Images/835471044a2f946a5f88102507285248.png" data-original-src="https://miro.medium.com/v2/resize:fit:1354/format:webp/0*_CvegEYCrwuKAGN0.png"/></div></figure><p id="672a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以看到它们之间有很大的差异，我们可以用百分比来计算它们之间的差异:</p><pre class="ky kz la lb gt oc od oe bn of og bi"><span id="5cfd" class="oh lp it od b be oi oj l ok ol">list_comp_time = list_comp_end_time - list_comp_start_time<br/>for_loop_time = for_loop_end_time - for_loop_start_time<br/>print("Difference in time: {} %".format((for_loop_time - list_comp_time)/<br/>list_comp_time*100))</span></pre><figure class="ky kz la lb gt lc gh gi paragraph-image"><div class="gh gi pj"><img src="../Images/516cc2c7468f6acd87c07ef4f0458287.png" data-original-src="https://miro.medium.com/v2/resize:fit:1036/format:webp/0*3lSS-C5pOoTPb8iO.png"/></div></figure><p id="2bc4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里有另一个例子来展示编写高效代码的效果。我们想计算从1到100万的所有连续数字的总和。有两种方法第一种是使用蛮力，我们将一个接一个地增加到一百万。</p><pre class="ky kz la lb gt oc od oe bn of og bi"><span id="52e4" class="oh lp it od b be oi oj l ok ol">def sum_brute_force(N):<br/>  res = 0<br/>  for i in range(1,N+1):<br/>    res+=i<br/>  return res<br/><br/># Using brute force<br/>bf_start_time = time.time()<br/>bf_result = sum_brute_force(1000000)<br/>bf_end_time = time.time()<br/><br/>print("Time using brute force: {} sec".format(bf_end_time - bf_start_time))</span></pre><figure class="ky kz la lb gt lc gh gi paragraph-image"><div class="gh gi pk"><img src="../Images/202c5549d365bc9e3d5223b7274bcc08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1182/format:webp/0*2_IkvnTcYBKWA8jQ.png"/></div></figure><p id="47a8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另一个更有效的方法是用公式来计算。当我们想计算从1到一个数的所有整数的和时，比如说N，我们可以把N乘以N+1，然后除以2，这样就会得到我们想要的结果。这个问题实际上在19世纪就交给了德国的一些学生，一个名叫卡尔-弗里德里希·高斯的聪明学生设计了这个公式来在几秒钟内解决这个问题。</p><pre class="ky kz la lb gt oc od oe bn of og bi"><span id="68cf" class="oh lp it od b be oi oj l ok ol">def sum_formula(N):<br/>  return N*(N+1)/2<br/>  <br/># Using the formula<br/>formula_start_time = time.time()<br/>formula_result = sum_formula(1000000)<br/>formula_end_time = time.time()<br/><br/>print("Time using the formula: {} sec".format(formula_end_time - formula_start_time))</span></pre><figure class="ky kz la lb gt lc gh gi paragraph-image"><div class="gh gi pl"><img src="../Images/9707e309e24e36c8ab6c9d86df44f90c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1194/format:webp/0*xUzBaA8qdNded9tg.png"/></div></figure><p id="ed9c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">运行这两种方法后，我们实现了超过160，000%的巨大改进，这清楚地表明了为什么我们需要高效和优化的代码，即使对于简单的任务也是如此。</p><p id="a1b1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">编写python代码的最低效的方法之一是在代码中有许多循环，尤其是当您有大量数据时。由于作为一名数据科学家，您将需要广泛地迭代您的数据框架，尤其是在数据准备和探索阶段，因此能够高效地完成这项工作非常重要，因为这将为您节省大量时间，并为更重要的工作留出空间。我们将通过三种方法让您的循环更快、更有效:</p><ul class=""><li id="c880" class="mh mi it js b jt ju jx jy kb nw kf nx kj ny kn nz mp mq mr bi translated">使用<strong class="js iu">循环。iterrows() </strong>函数</li><li id="9600" class="mh mi it js b jt ms jx mt kb mu kf mv kj mw kn nz mp mq mr bi translated">使用<strong class="js iu">循环。apply() </strong>函数</li><li id="44b9" class="mh mi it js b jt ms jx mt kb mu kf mv kj mw kn nz mp mq mr bi translated">…向量化…</li></ul></div><div class="ab cl np nq hx nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="im in io ip iq"><h1 id="85e2" class="on lp it bd lq oo op oq lt or os ot lw ou ov ow lz ox oy oz mc pa pb pc mf pd bi translated">2.使用有效循环。iterrows()</h1><p id="a9c8" class="pw-post-body-paragraph jq jr it js b jt mj jv jw jx mk jz ka kb pe kd ke kf pf kh ki kj pg kl km kn im bi translated">在我们谈论如何使用<strong class="js iu">之前。iterrows() </strong>函数为了改进循环过程，让我们刷新一下生成器函数的概念。</p><p id="8590" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">生成器是一个创建迭代器的简单工具。在生成器主体内部，您将发现只有<strong class="js iu"> yield() </strong>语句，而不是return语句。可以只有一个或几个<strong class="js iu"> yield() </strong>语句。这里，我们可以看到一个生成器，<strong class="js iu"> city_name_generator() </strong>，它生成四个城市名。为简单起见，我们将生成器分配给变量<strong class="js iu"> city_names </strong>。</p><pre class="ky kz la lb gt oc od oe bn of og bi"><span id="6e6c" class="oh lp it od b be oi oj l ok ol">def city_name_generator():<br/>  yield('New York')<br/>  yield('London')<br/>  yield('Tokyo')<br/>  yield('Sao Paolo')<br/><br/>city_names = city_name_generator()</span></pre><p id="68ba" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了访问生成器生成的元素，我们可以使用Python的<strong class="js iu"> next() </strong>函数。每次使用<strong class="js iu"> next() </strong>命令时，生成器将生成下一个要生成的值，直到不再有要生成的值。我们这里有4个城市。让我们运行下一个命令四次，看看它会返回什么:</p><pre class="ky kz la lb gt oc od oe bn of og bi"><span id="6aef" class="oh lp it od b be oi oj l ok ol">next(city_names)</span></pre><figure class="ky kz la lb gt lc gh gi paragraph-image"><div class="gh gi pm"><img src="../Images/50689efa4eeb6273acd1fea7accb3843.png" data-original-src="https://miro.medium.com/v2/resize:fit:1090/format:webp/0*slk3g2WYGOwMvdu8.png"/></div></figure><pre class="ky kz la lb gt oc od oe bn of og bi"><span id="cc4d" class="oh lp it od b be oi oj l ok ol">next(city_names)</span></pre><figure class="ky kz la lb gt lc gh gi paragraph-image"><div class="gh gi pn"><img src="../Images/1e2d2ca2b11d160785dbadb0990a4881.png" data-original-src="https://miro.medium.com/v2/resize:fit:666/format:webp/0*lIbxQXo57GuY7XY1.png"/></div></figure><pre class="ky kz la lb gt oc od oe bn of og bi"><span id="4aa4" class="oh lp it od b be oi oj l ok ol">next(city_names)</span></pre><figure class="ky kz la lb gt lc gh gi paragraph-image"><div class="gh gi po"><img src="../Images/6a729752602da0891943206f39fa8ef1.png" data-original-src="https://miro.medium.com/v2/resize:fit:552/format:webp/0*KlrwREtPHz89AFTJ.png"/></div></figure><p id="54fe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正如我们可以看到的，每次我们运行<strong class="js iu"> next() </strong>函数，它都会打印一个新的城市名。</p><p id="1299" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们回到。<strong class="js iu"> iterrows() </strong>函数。<strong class="js iu">。iterrows() </strong>函数是每个熊猫DataFrame的属性。当被调用时，它产生一个包含两个元素的列表。我们将使用这个生成器来遍历我们的<strong class="js iu">扑克</strong>数据帧的每一行。第一个元素是该行的索引，而第二个元素包含该行每个特征的熊猫系列:五张卡片中每张卡片的符号和等级。它非常类似于<strong class="js iu"> enumerate() </strong>函数的概念，当应用于列表时，返回每个元素及其索引。</p><p id="d4f5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">遍历Pandas数据帧最直观的方法是使用<strong class="js iu"> range() </strong>函数，这通常被称为粗循环。下面的代码显示了这一点:</p><pre class="ky kz la lb gt oc od oe bn of og bi"><span id="2b42" class="oh lp it od b be oi oj l ok ol">start_time = time.time()<br/>for index in range(poker_data.shape[0]):<br/>  next<br/>print("Time using range(): {} sec".format(time.time() - start_time))</span></pre><figure class="ky kz la lb gt lc gh gi paragraph-image"><div class="gh gi pp"><img src="../Images/bb0611cd857c87dda32475bcc9fd269c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1084/format:webp/0*6qtkdbuk38VUlYy2.png"/></div></figure><p id="ebf6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">迭代熊猫数据框架的一个更聪明的方法是使用<strong class="js iu">。iterrows() </strong>函数，该函数针对此任务进行了优化。我们简单地用两个迭代器定义了“<strong class="js iu"> for </strong>”循环，一个用于每行的编号，另一个用于所有的值。</p><p id="7298" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在循环内部，<strong class="js iu"> next() </strong>命令指示循环移动到迭代器的下一个值，而不实际做任何事情。</p><pre class="ky kz la lb gt oc od oe bn of og bi"><span id="921e" class="oh lp it od b be oi oj l ok ol">data_generator = poker_data.iterrows()<br/>start_time = time.time()<br/>for index, values in data_generator:<br/>  next<br/>print("Time using .iterrows(): {} sec".format(time.time() - start_time))</span></pre><figure class="ky kz la lb gt lc gh gi paragraph-image"><div class="gh gi pq"><img src="../Images/0a492cc4333477238a0f731bfd1a82e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1374/format:webp/0*7iooWRPPA0Mh6i54.png"/></div></figure><p id="c894" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">比较这两个计算时间我们还可以注意到<strong class="js iu">的使用。iterrows() </strong>没有提高遍历pandas数据帧的速度。当我们需要一种更简洁的方式来使用每一行的值时，它是非常有用的。</p></div><div class="ab cl np nq hx nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="im in io ip iq"><h1 id="61cb" class="on lp it bd lq oo op oq lt or os ot lw ou ov ow lz ox oy oz mc pa pb pc mf pd bi translated">3.使用有效循环。应用()</h1><p id="1311" class="pw-post-body-paragraph jq jr it js b jt mj jv jw jx mk jz ka kb pe kd ke kf pf kh ki kj pg kl km kn im bi translated">现在我们将使用<strong class="js iu">。apply() </strong>函数能够在遍历熊猫数据帧时执行特定的任务。<strong class="js iu">。apply() </strong>函数确实如它所说的那样；它对整个数据帧应用另一个函数。</p><p id="9799" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">的语法。apply() </strong>函数很简单:我们创建一个映射，在本例中使用lambda函数，然后声明我们想要应用于每个单元格的函数。这里，我们将平方根函数应用于数据帧的每个单元格。就速度而言，它与在整个数据帧上只使用NumPy <strong class="js iu"> sqrt() </strong>函数的速度相当。</p><pre class="ky kz la lb gt oc od oe bn of og bi"><span id="a62e" class="oh lp it od b be oi oj l ok ol">data_sqrt = poker_data.apply(lambda x: np.sqrt(x))<br/>data_sqrt.head()</span></pre><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi pr"><img src="../Images/69b0e09f5cb85956147ccbaf817adccc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3LHfFKWOSX8M5dZrDTq7fA.jpeg"/></div></div></figure><p id="8fbd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是一个简单的例子，因为我们想将这个函数应用于数据帧。</p><p id="7763" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是，当目标函数接受多个单元格作为输入时，会发生什么情况呢？例如，如果我们想计算每手牌中所有牌的排名之和，该怎么办？在这种情况下，我们将使用。apply()函数和我们之前做的一样，但是我们需要在行尾添加<strong class="js iu"> 'axis=1' </strong>来指定我们将函数应用到每一行。</p><pre class="ky kz la lb gt oc od oe bn of og bi"><span id="c708" class="oh lp it od b be oi oj l ok ol">apply_start_time = time.time()<br/>poker_data[['R1', 'R2', 'R3', 'R4', 'R5']].apply(lambda x: sum(x), axis=1)<br/>apply_end_time = time.time()<br/>apply_time = apply_end_time - apply_start_time<br/>print("Time using .apply(): {} sec".format(time.time() - apply_start_time))</span></pre><figure class="ky kz la lb gt lc gh gi paragraph-image"><div class="gh gi ps"><img src="../Images/4f7db2a1594c407a4687976f10a22241.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*aDfgrKdEhcKNbaxj.png"/></div></figure><p id="7edb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，我们将使用<strong class="js iu">。iterrows() </strong>函数我们以前见过，并比较它们的效率。</p><pre class="ky kz la lb gt oc od oe bn of og bi"><span id="4e5e" class="oh lp it od b be oi oj l ok ol">for_loop_start_time = time.time()<br/>for ind, value in poker_data.iterrows():<br/>  sum([value[1], value[3], value[5], value[7], value[9]])<br/>for_loop_end_time = time.time()<br/><br/>for_loop_time = for_loop_end_time - for_loop_start_time<br/>print("Time using .iterrows(): {} sec".format(for_loop_time))</span></pre><figure class="ky kz la lb gt lc gh gi paragraph-image"><div class="gh gi pt"><img src="../Images/d9eca39ed688fb03f0060067d17bc0f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/format:webp/0*Vz_WmptFRySl04kc.png"/></div></figure><p id="4556" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用<strong class="js iu">。apply() </strong>函数明显比<strong class="js iu">快。iterrows() </strong>函数，幅度约为400 %,这是一个巨大的改进！</p><pre class="ky kz la lb gt oc od oe bn of og bi"><span id="12c4" class="oh lp it od b be oi oj l ok ol">print('The differnce: {} %'.format((for_loop_time - apply_time) / apply_time * 100))</span></pre><figure class="ky kz la lb gt lc gh gi paragraph-image"><div class="gh gi pu"><img src="../Images/308e4b594568c42dd012f12dba4bbe51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1106/format:webp/0*oDlvy_Lt8nrR7Sjy.png"/></div></figure><p id="4abe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正如我们对行所做的那样，我们可以对列做完全相同的事情；对每列应用一个函数。通过将<strong class="js iu">轴=1 </strong>替换为<strong class="js iu">轴=0 </strong>，我们可以对每一列应用求和函数。</p><pre class="ky kz la lb gt oc od oe bn of og bi"><span id="ebfa" class="oh lp it od b be oi oj l ok ol">apply_start_time = time.time()<br/>poker_data[['R1', 'R2', 'R3', 'R4', 'R5']].apply(lambda x: sum(x), axis=0)<br/>apply_end_time = time.time()<br/>apply_time = apply_end_time - apply_start_time<br/>print("Time using .apply(): {} sec".format(apply_time))</span></pre><figure class="ky kz la lb gt lc gh gi paragraph-image"><div class="gh gi pv"><img src="../Images/f75cc594a0e51903fefb53b1bf7fb64c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1034/format:webp/0*qteu5HWSwdAJRG2C.png"/></div></figure><p id="24c4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过比较。<strong class="js iu"> apply() </strong>函数用原生熊猫的函数对多行求和，我们可以看到熊猫的原生<strong class="js iu">。sum() </strong>函数执行相同操作的速度更快。</p><pre class="ky kz la lb gt oc od oe bn of og bi"><span id="295c" class="oh lp it od b be oi oj l ok ol">pandas_start_time = time.time()<br/>poker_data[['R1', 'R1', 'R3', 'R4', 'R5']].sum(axis=0)<br/>pandas_end_time = time.time()<br/>pandas_time = pandas_end_time - pandas_start_time<br/>print("Time using pandas: {} sec".format(pandas_time))</span></pre><figure class="ky kz la lb gt lc gh gi paragraph-image"><div class="gh gi pw"><img src="../Images/26924d88cef2866ff4bb4d1a08567036.png" data-original-src="https://miro.medium.com/v2/resize:fit:1174/format:webp/0*DIymLp-I7Hr0dK94.png"/></div></figure><pre class="ky kz la lb gt oc od oe bn of og bi"><span id="b7e8" class="oh lp it od b be oi oj l ok ol">print('The differnce: {} %'.format((apply_time - pandas_time) / pandas_time * 100))</span></pre><figure class="ky kz la lb gt lc gh gi paragraph-image"><div class="gh gi px"><img src="../Images/c759fb359e4bcca32b13681730ad9ccb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/0*S3VpqEYO0uVP1t9d.png"/></div></figure><p id="bb1a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">总之，我们观察到。当我们想要遍历pandas数据帧的所有行时，apply()函数执行得更快，但是当我们通过一列执行相同的操作时，它执行得更慢。</strong></p></div><div class="ab cl np nq hx nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="im in io ip iq"><h1 id="1995" class="on lp it bd lq oo op oq lt or os ot lw ou ov ow lz ox oy oz mc pa pb pc mf pd bi translated">4.使用矢量化有效循环</h1><p id="8cb5" class="pw-post-body-paragraph jq jr it js b jt mj jv jw jx mk jz ka kb pe kd ke kf pf kh ki kj pg kl km kn im bi translated">为了理解如何减少函数执行的迭代次数，回想一下Pandas的基本单元DataFrames和Series都是基于数组的。当对整个数组执行操作时，Pandas的执行效率比对每个值单独或顺序执行更高。这可以通过<strong class="js iu">矢量化</strong>来实现。<strong class="js iu">矢量化</strong>是对整个数组执行操作的过程。</p><p id="8628" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在下面的代码中，我们要计算每手牌中所有牌的等级之和。为此，我们对扑克数据集进行切片，只保留包含每张牌的等级的列。然后，我们称之为内置<strong class="js iu">。DataFrame的sum() </strong>属性，使用参数axis = 1来表示我们需要每行的总和。最后，我们打印前五行数据的总和。</p><pre class="ky kz la lb gt oc od oe bn of og bi"><span id="f304" class="oh lp it od b be oi oj l ok ol">start_time_vectorization = time.time()<br/><br/>poker_data[['R1', 'R2', 'R3', 'R4', 'R5']].sum(axis=1)<br/>end_time_vectorization = time.time()<br/><br/>vectorization_time = end_time_vectorization  - start_time_vectorization<br/>print("Time using pandas vectorization: {} sec".format(vectorization_time))</span></pre><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="gh gi py"><img src="../Images/5de67790c45965fe50f92532cc4d0c0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*TU9KrUOQx-xHKcOl.png"/></div></div></figure><p id="3404" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们之前看到了各种方法，这些方法执行应用于数据帧的函数比简单地遍历数据帧的所有行要快。我们的目标是找到执行这项任务的最有效的方法。</p><ul class=""><li id="042b" class="mh mi it js b jt ju jx jy kb nw kf nx kj ny kn nz mp mq mr bi translated">使用<strong class="js iu">。iterrows() </strong>循环遍历数据帧:</li></ul><pre class="ky kz la lb gt oc od oe bn of og bi"><span id="9a4e" class="oh lp it od b be oi oj l ok ol">data_generator = poker_data.iterrows()<br/><br/>start_time_iterrows = time.time()<br/><br/>for index, value in data_generator:<br/>  sum([value[1], value[3], value[5], value[7]])<br/><br/>end_time_iterrows = time.time()<br/>iterrows_time = end_time_iterrows - start_time_iterrows<br/>print("Time using .iterrows() {} seconds " .format(iterrows_time))</span></pre><figure class="ky kz la lb gt lc gh gi paragraph-image"><div class="gh gi pz"><img src="../Images/f1d29cfba9afaae3c0fd78d3dcbede69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1302/format:webp/0*QOMwqyv_FyFsZGd1.png"/></div></figure><ul class=""><li id="7d6d" class="mh mi it js b jt ju jx jy kb nw kf nx kj ny kn nz mp mq mr bi translated">使用。apply()方法</li></ul><pre class="ky kz la lb gt oc od oe bn of og bi"><span id="f1e7" class="oh lp it od b be oi oj l ok ol">start_time_apply = time.time()<br/>poker_data[['R1', 'R2', 'R3', 'R4', 'R5']].apply(lambda x: sum(x),axis=1)<br/>end_time_apply = time.time()<br/><br/>apply_time = end_time_apply - start_time_apply<br/><br/>print("Time using apply() {} seconds"  .format(apply_time))</span></pre><figure class="ky kz la lb gt lc gh gi paragraph-image"><div class="gh gi qa"><img src="../Images/d684b143d93f976bd99239e70f256f76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1166/format:webp/0*T1MQAy0sJfhM20WR.png"/></div></figure><p id="bfcc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用<strong class="js iu">矢量化</strong>和<strong class="js iu">比较每手牌中所有牌的等级相加所需的时间。iterrows() </strong>函数，以及<strong class="js iu">。apply() </strong>函数，我们可以看到矢量化方法的性能要好得多。</p><p id="fbe8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们还可以使用另一种矢量化方法来有效地遍历数据帧，该方法使用Numpy数组对数据帧进行矢量化。</p><p id="bb90" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">NumPy库将自己定义为“Python中科学计算的基础包”，它在优化的预编译C代码中执行操作。与pandas处理数组类似，NumPy对名为<strong class="js iu"> ndarrays </strong>的数组进行操作。Series和ndarrays之间的一个主要区别是ndarrays省略了许多操作，如索引、数据类型检查等。因此，在NumPy阵列上的操作比在pandas系列上的操作要快得多。当pandas系列提供的附加功能不重要时，NumPy阵列可以用来代替pandas系列。</p><p id="79c9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于我们在本文中探索的问题，我们可以使用NumPy ndarrays来代替pandas系列。关键的问题是这是否会更有效率。</p><p id="3f52" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">同样，我们将计算每手牌中所有牌的等级总和。我们简单地通过使用<strong class="js iu">将我们的rank数组从pandas系列转换成NumPy数组。熊猫系列的values </strong>方法，该方法将熊猫系列作为NumPy <strong class="js iu"> ndarray </strong>返回。与对序列进行矢量化一样，将NumPy数组直接传递给函数将导致pandas将函数应用于整个矢量。</p><pre class="ky kz la lb gt oc od oe bn of og bi"><span id="705e" class="oh lp it od b be oi oj l ok ol">start_time = time.time()<br/><br/>poker_data[['R1', 'R2', 'R3', 'R4', 'R5']].values.sum(axis=1)<br/><br/>print("Time using NumPy vectorization: {} sec" .format(time.time() - start_time))</span></pre><figure class="ky kz la lb gt lc gh gi paragraph-image"><div class="gh gi qb"><img src="../Images/cf21c70a80887c482a30fcb9d5fab31b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1064/format:webp/0*vR2CXnr3O4gXvdlD.png"/></div></figure><pre class="ky kz la lb gt oc od oe bn of og bi"><span id="9bd4" class="oh lp it od b be oi oj l ok ol">start_time = time.time()<br/>poker_data[['R1', 'R2', 'R3', 'R4', 'R5']].sum(axis=1)<br/>print("Results from the above operation calculated in %s seconds" % (time.time() - start_time))</span></pre><figure class="ky kz la lb gt lc gh gi paragraph-image"><div class="gh gi qc"><img src="../Images/72ee74df8fa53147c60400320bfc9603.png" data-original-src="https://miro.medium.com/v2/resize:fit:906/format:webp/0*98Plp8c22uNXavfW.png"/></div></figure><p id="df6d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这一点上，我们可以看到对pandas系列的矢量化实现了日常计算的绝大多数优化需求。然而，如果速度是最重要的，我们可以通过<strong class="js iu"> NumPy </strong> Python库的形式来寻求帮助。与之前最先进的panda优化方法相比，我们仍然在运行时间上有所改进。</p></div><div class="ab cl np nq hx nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="im in io ip iq"><h1 id="cb97" class="on lp it bd lq oo op oq lt or os ot lw ou ov ow lz ox oy oz mc pa pb pc mf pd bi translated">5.最佳实践总结</h1><ul class=""><li id="7232" class="mh mi it js b jt mj jx mk kb ml kf mm kj mn kn nz mp mq mr bi translated">使用。<strong class="js iu"> iterrows() </strong>没有提高遍历数据帧的速度，但效率更高。</li><li id="c46d" class="mh mi it js b jt ms jx mt kb mu kf mv kj mw kn nz mp mq mr bi translated"><strong class="js iu">。当我们想要遍历熊猫数据帧的所有行时，apply() </strong>函数执行得更快，但是当我们通过一列执行相同的操作时，执行得更慢。</li><li id="178f" class="mh mi it js b jt ms jx mt kb mu kf mv kj mw kn nz mp mq mr bi translated">对pandas系列进行矢量化处理可以满足日常计算的绝大多数优化需求。然而，如果速度是最重要的，我们可以以<strong class="js iu"> NumPy </strong> Python库的形式调用增援。</li></ul></div><div class="ab cl np nq hx nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="im in io ip iq"><p id="0bde" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> <em class="oa">感谢阅读！如果你喜欢这篇文章，请务必:</em> </strong></p><ul class=""><li id="1885" class="mh mi it js b jt ju jx jy kb nw kf nx kj ny kn nz mp mq mr bi translated"><strong class="js iu">👏为这个故事鼓掌(50次)并跟我来👉</strong></li><li id="f786" class="mh mi it js b jt ms jx mt kb mu kf mv kj mw kn nz mp mq mr bi translated"><strong class="js iu">📰查看我的个人资料中的更多内容</strong></li><li id="488d" class="mh mi it js b jt ms jx mt kb mu kf mv kj mw kn nz mp mq mr bi translated"><strong class="js iu">🔔关注我:</strong><a class="ae ln" href="https://www.linkedin.com/in/youssef-hosni-b2960b135/" rel="noopener ugc nofollow" target="_blank"><strong class="js iu">LinkedIn</strong></a><strong class="js iu">|</strong><a class="ae ln" href="https://medium.com/@youssefraafat57" rel="noopener"><strong class="js iu">Medium</strong></a><strong class="js iu">|</strong><a class="ae ln" href="https://twitter.com/Youssef70125494" rel="noopener ugc nofollow" target="_blank"><strong class="js iu">Twitter</strong></a><strong class="js iu">|</strong><a class="ae ln" href="https://github.com/youssefHosni" rel="noopener ugc nofollow" target="_blank"><strong class="js iu">GitHub</strong></a></li><li id="be84" class="mh mi it js b jt ms jx mt kb mu kf mv kj mw kn nz mp mq mr bi translated"><em class="oa">🚀👉</em> <strong class="js iu"> <em class="oa">加入</em> </strong> <a class="ae ln" href="https://youssefraafat57.medium.com/membership" rel="noopener"> <strong class="js iu"> <em class="oa">中等会员</em> </strong> </a> <strong class="js iu"> <em class="oa">计划继续无限制学习。如果你使用下面的链接，我会收到一小部分会员费，不需要你额外付费。</em> </strong></li></ul><div class="mx my gp gr mz na"><a href="https://youssefraafat57.medium.com/membership" rel="noopener follow" target="_blank"><div class="nb ab fo"><div class="nc ab nd cl cj ne"><h2 class="bd iu gy z fp nf fr fs ng fu fw is bi translated">加入我的介绍链接媒体-优素福胡斯尼</h2><div class="nh l"><h3 class="bd b gy z fp nf fr fs ng fu fw dk translated">阅读Youssef Hosni(以及媒体上成千上万的其他作家)的每一个故事。您的会员费直接支持…</h3></div><div class="ni l"><p class="bd b dl z fp nf fr fs ng fu fw dk translated">youssefraafat57.medium.com</p></div></div><div class="nj l"><div class="qd l nl nm nn nj no lh na"/></div></div></a></div></div></div>    
</body>
</html>