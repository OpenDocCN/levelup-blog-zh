<html>
<head>
<title>10 Advanced Features of Tuples that Level Up Your Skills in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">元组的10个高级特性提升了您的Python技能</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/10-advanced-features-of-tuples-that-level-up-your-skills-in-python-5ea0345ace90?source=collection_archive---------6-----------------------#2022-01-31">https://levelup.gitconnected.com/10-advanced-features-of-tuples-that-level-up-your-skills-in-python-5ea0345ace90?source=collection_archive---------6-----------------------#2022-01-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="a002" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们探索隐藏的元组宝石，这将提高您的Python知识。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/144b131b8911448ab8760f48793273c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*EcvQa9G7vWoA-gHS"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">丹尼斯·帕夫洛维奇在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><p id="1712" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在编程中，为你的目的选择最佳的数据集合是一门艺术。Python有许多有用的内置数据集合，如列表、元组、集合等。我看到Python开发者倾向于使用列表作为数据容器，因为它很灵活。我决定写这篇文章来突出元组的高级特性。</p><p id="2d12" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">元组本质上是一个静态数组。换句话说，一旦创建了元组，就不能对其进行修改和调整大小。与元组相比，人们更喜欢列表，因为列表很容易操作，并且它们有许多有用的方法，这与元组相反。但是元组也有很大的特点！它们用于保护您不希望被更改的数据。此外，它们还经过优化以提高内存效率。</p><p id="aac4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们潜入元组的世界吧！</p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><h1 id="8f16" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">1元组是不可变的</h1><p id="214e" class="pw-post-body-paragraph jq jr it js b jt mk jv jw jx ml jz ka kb mm kd ke kf mn kh ki kj mo kl km kn im bi translated">一旦创建了元组，就不可能修改它的元素。</p><pre class="kp kq kr ks gt mp mq mr ms aw mt bi"><span id="cc07" class="mu ln it mq b gy mv mw l mx my">&gt;&gt;&gt; my_tuple = (1, 2, 3)</span><span id="9722" class="mu ln it mq b gy mz mw l mx my">&gt;&gt;&gt; my_tuple[0]<br/>1</span></pre><p id="36c3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">否则，<strong class="js iu">类型错误</strong>出现。</p><pre class="kp kq kr ks gt mp mq mr ms aw mt bi"><span id="9608" class="mu ln it mq b gy mv mw l mx my">&gt;&gt;&gt; my_tuple[0] = 'a'</span></pre><p id="36fb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">输出:</strong></p><pre class="kp kq kr ks gt mp mq mr ms aw mt bi"><span id="3148" class="mu ln it mq b gy mv mw l mx my">Traceback (most recent call last):<br/>  File "&lt;input&gt;", line 1, in &lt;module&gt;<br/>TypeError: 'tuple' object does not support item assignment</span></pre><p id="e10c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这就是为什么存储在元组中的数据被认为是安全的，不会被修改。如果其他开发人员试图改变你的程序中元组的内容，就会引发<strong class="js iu"> TypeError </strong>。</p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><h1 id="ab14" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">二元组不是完全不可变的</h1><p id="f988" class="pw-post-body-paragraph jq jr it js b jt mk jv jw jx ml jz ka kb mm kd ke kf mn kh ki kj mo kl km kn im bi translated">我说元组不能被修改并不完全正确。的确，有一个例外情况。如果一个元组的元素是可变的，那么你可以修改这个元素。请记住，Python中的列表是可变的，因此您可以更改它们的元素，添加或删除其中的项目。在下面的示例中，我们将向列表中添加一个项目:</p><pre class="kp kq kr ks gt mp mq mr ms aw mt bi"><span id="22b5" class="mu ln it mq b gy mv mw l mx my">&gt;&gt;&gt; my_tuple = (1, 2, ['a'])</span><span id="5213" class="mu ln it mq b gy mz mw l mx my">&gt;&gt;&gt; my_tuple[2]<br/>['a']</span><span id="157d" class="mu ln it mq b gy mz mw l mx my">&gt;&gt;&gt; my_tuple[2].append('b')<br/>&gt;&gt;&gt; my_tuple[2]<br/>['a', 'b']</span><span id="b016" class="mu ln it mq b gy mz mw l mx my">&gt;&gt;&gt; my_tuple<br/>(1, 2, ['a', 'b'])</span></pre><p id="49e2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是您只能修改该元素，而不能修改其他元素。其他元素仍然受到保护。</p><pre class="kp kq kr ks gt mp mq mr ms aw mt bi"><span id="1956" class="mu ln it mq b gy mv mw l mx my">&gt;&gt;&gt; my_tuple = (1, 2, ['a'])<br/>&gt;&gt;&gt; t[0] = 0</span></pre><p id="f3c5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">输出:</strong></p><pre class="kp kq kr ks gt mp mq mr ms aw mt bi"><span id="4026" class="mu ln it mq b gy mv mw l mx my">Traceback (most recent call last):<br/>  File "&lt;input&gt;", line 1, in &lt;module&gt;<br/>TypeError: 'tuple' object does not support item assignment</span></pre><p id="6cd4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以每当有人说你不能改变一个元组的任何元素，现在你知道真相了。下次解释这个功能，纠正他们的错误。</p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><h1 id="cba7" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">三元组由括号创建(并不总是如此)</h1><p id="32ba" class="pw-post-body-paragraph jq jr it js b jt mk jv jw jx ml jz ka kb mm kd ke kf mn kh ki kj mo kl km kn im bi translated">这里还有一个关于元组的误解。您可能已经知道元组是由括号创建的。</p><pre class="kp kq kr ks gt mp mq mr ms aw mt bi"><span id="c65d" class="mu ln it mq b gy mv mw l mx my">&gt;&gt;&gt; t = (1, 2, 3, 'c')</span></pre><p id="063e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这并不完全正确，因为您可以创建不带括号的元组。</p><pre class="kp kq kr ks gt mp mq mr ms aw mt bi"><span id="62ab" class="mu ln it mq b gy mv mw l mx my">&gt;&gt;&gt; t = 1, 2, 3, 'c'<br/>&gt;&gt;&gt; type(t)</span></pre><p id="51bd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">输出:</strong></p><pre class="kp kq kr ks gt mp mq mr ms aw mt bi"><span id="ec35" class="mu ln it mq b gy mv mw l mx my">&lt;class 'tuple'&gt;</span></pre><p id="05ec" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一个只有一个元素的元组呢？你仍然可以去掉括号:</p><pre class="kp kq kr ks gt mp mq mr ms aw mt bi"><span id="9d2d" class="mu ln it mq b gy mv mw l mx my">&gt;&gt;&gt; t = 1,<br/>&gt;&gt;&gt; type(t)</span></pre><p id="abe9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">输出:</strong></p><pre class="kp kq kr ks gt mp mq mr ms aw mt bi"><span id="313a" class="mu ln it mq b gy mv mw l mx my">&lt;class 'tuple'&gt;</span></pre><p id="7eee" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有时，此功能可能会导致不良结果。假设你想定义一个字符串。</p><pre class="kp kq kr ks gt mp mq mr ms aw mt bi"><span id="5342" class="mu ln it mq b gy mv mw l mx my">&gt;&gt;&gt; t = "Tuples are awesome"</span></pre><p id="271c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Upps，你的手滑了一下，无意中在结尾加了一个逗号:</p><pre class="kp kq kr ks gt mp mq mr ms aw mt bi"><span id="e328" class="mu ln it mq b gy mv mw l mx my">&gt;&gt;&gt; t = "Tuples are awesome",</span></pre><p id="d521" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在它不是一个字符串:</p><pre class="kp kq kr ks gt mp mq mr ms aw mt bi"><span id="3ac4" class="mu ln it mq b gy mv mw l mx my">&gt;&gt;&gt; t = "Tuples are awesome",<br/>&gt;&gt;&gt; type(t)</span></pre><p id="8b12" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">输出:</strong></p><pre class="kp kq kr ks gt mp mq mr ms aw mt bi"><span id="e765" class="mu ln it mq b gy mv mw l mx my">&lt;class 'tuple'&gt;</span></pre><p id="1457" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您刚刚创建了一个只有一个元素的元组。</p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><h1 id="d961" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">4-用单个元素创建一个元组</h1><p id="05fb" class="pw-post-body-paragraph jq jr it js b jt mk jv jw jx ml jz ka kb mm kd ke kf mn kh ki kj mo kl km kn im bi translated">存储数据序列不是必须的。您可能只想在一个元组中存储一个元素，但是要确保在该元素后面加一个逗号。</p><pre class="kp kq kr ks gt mp mq mr ms aw mt bi"><span id="525d" class="mu ln it mq b gy mv mw l mx my">&gt;&gt;&gt; t = (1,)<br/>&gt;&gt;&gt; type(t)</span></pre><p id="d15e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">输出:</strong></p><pre class="kp kq kr ks gt mp mq mr ms aw mt bi"><span id="096f" class="mu ln it mq b gy mv mw l mx my">&lt;class 'tuple'&gt;</span></pre><p id="466f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你忘了放逗号:</p><pre class="kp kq kr ks gt mp mq mr ms aw mt bi"><span id="5963" class="mu ln it mq b gy mv mw l mx my">&gt;&gt;&gt; t = (1)<br/>&gt;&gt;&gt; type(t)</span></pre><p id="c861" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你猜怎么着？</p><p id="ae74" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">输出:</strong></p><pre class="kp kq kr ks gt mp mq mr ms aw mt bi"><span id="28c6" class="mu ln it mq b gy mv mw l mx my">&lt;class 'int'&gt;</span></pre><p id="86b3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">没有逗号，变量不会变成元组。相反，它只是一个整数。在这种情况下，括号起到了数学运算的作用。在这里，它们指定了数学运算中的最高优先级。您可能会感到困惑，因为圆括号内只有一个数字。括号的功能与以下内容相同:</p><pre class="kp kq kr ks gt mp mq mr ms aw mt bi"><span id="dd37" class="mu ln it mq b gy mv mw l mx my">&gt;&gt;&gt; 2 + 3 * 5<br/>&gt;&gt;&gt; (2 + 3) * 5<br/>&gt;&gt;&gt; (5) * 5</span></pre><p id="1ee8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">输出:</strong></p><pre class="kp kq kr ks gt mp mq mr ms aw mt bi"><span id="5f8a" class="mu ln it mq b gy mv mw l mx my">15<br/>25<br/>25</span></pre></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><h1 id="3723" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">5-连接</h1><p id="2ad1" class="pw-post-body-paragraph jq jr it js b jt mk jv jw jx ml jz ka kb mm kd ke kf mn kh ki kj mo kl km kn im bi translated">可以用<code class="fe na nb nc mq b">+</code>运算符连接元组:</p><pre class="kp kq kr ks gt mp mq mr ms aw mt bi"><span id="dbb4" class="mu ln it mq b gy mv mw l mx my">&gt;&gt;&gt; ('blue', 'red') + ('yellow', 'green')<br/>('blue', 'red', 'yellow', 'green')</span></pre><p id="ae9e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">等等，我知道你在想什么。不可能将元素插入元组。但我没有那么做。我只是连接两个元组，最后创建一个新的。通过比较对象的身份，我们可以很容易地检查这个操作。记住我们用内置的<strong class="js iu"> id() </strong>函数来实现。</p><pre class="kp kq kr ks gt mp mq mr ms aw mt bi"><span id="6e1f" class="mu ln it mq b gy mv mw l mx my">&gt;&gt;&gt; colors1 = ('blue', 'red')<br/>&gt;&gt;&gt; colors2 = ('yellow', 'green')<br/>&gt;&gt;&gt; concat_colors = colors1 + colors2</span><span id="96f6" class="mu ln it mq b gy mz mw l mx my">&gt;&gt;&gt; id(colors1)<br/>4528667376</span><span id="223f" class="mu ln it mq b gy mz mw l mx my">&gt;&gt;&gt; id(colors2)<br/>4528656784</span><span id="cbbf" class="mu ln it mq b gy mz mw l mx my">&gt;&gt;&gt; id(concat_colors)<br/>4521705200</span></pre><p id="6a68" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您也可以连接两个以上的元组:</p><pre class="kp kq kr ks gt mp mq mr ms aw mt bi"><span id="6f5e" class="mu ln it mq b gy mv mw l mx my">&gt;&gt;&gt; extended_colors = concat_colors + ('black',)<br/>&gt;&gt;&gt; extended_colors</span></pre><p id="b334" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">输出:</strong></p><pre class="kp kq kr ks gt mp mq mr ms aw mt bi"><span id="3d9f" class="mu ln it mq b gy mv mw l mx my">('blue', 'red', 'yellow', 'green', 'black')</span></pre></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><h1 id="b946" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">6-创建空元组</h1><p id="54a9" class="pw-post-body-paragraph jq jr it js b jt mk jv jw jx ml jz ka kb mm kd ke kf mn kh ki kj mo kl km kn im bi translated">当您知道Python中存在一个空元组时，您可能会感到惊讶。</p><p id="4b3d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">语法:</strong></p><pre class="kp kq kr ks gt mp mq mr ms aw mt bi"><span id="098a" class="mu ln it mq b gy mv mw l mx my">()</span></pre><p id="62b9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这有点奇怪。对吗？</p><pre class="kp kq kr ks gt mp mq mr ms aw mt bi"><span id="ceac" class="mu ln it mq b gy mv mw l mx my">&gt;&gt;&gt; empty_tuple = ()<br/>&gt;&gt;&gt; type(empty_tuple)</span></pre><p id="3f52" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">输出:</strong></p><pre class="kp kq kr ks gt mp mq mr ms aw mt bi"><span id="d576" class="mu ln it mq b gy mv mw l mx my">&lt;class ‘tuple’&gt;</span></pre><p id="09b0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">乍一看，很难理解Python中为什么会有空元组，因为你不能在空元组中插入任何项。毕竟空元组也是不可变的。</p><p id="e380" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">那么拥有空元组的目的是什么呢？</p><p id="a567" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">举个例子，您打算用文件中的数据填充一个元组。因此，您将逐行读取文件，并将数据存储到一个元组中。你设计了一个Python程序，使得<code class="fe na nb nc mq b">data</code>变量是一个元组。如果<code class="fe na nb nc mq b">data</code>被初始化为<code class="fe na nb nc mq b">None</code>，那么在读取空文件的情况下<code class="fe na nb nc mq b">data</code>就不会是一个元组。这种情况下将<code class="fe na nb nc mq b">data</code>初始化为空元组更有意义。</p><p id="dfec" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">例子:</strong></p><pre class="kp kq kr ks gt mp mq mr ms aw mt bi"><span id="b40b" class="mu ln it mq b gy mv mw l mx my">with open("file.txt") as f:<br/>    data = ()<br/>    lines = f.readlines()<br/>    for line in files:<br/>        data = data + (line,)</span></pre><p id="d6db" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我说Python中只存在一个空元组呢？你会再次感到惊讶吗？</p><pre class="kp kq kr ks gt mp mq mr ms aw mt bi"><span id="2c09" class="mu ln it mq b gy mv mw l mx my">&gt;&gt;&gt; empty_tuple1 = ()<br/>&gt;&gt;&gt; empty_tuple2 = ()<br/>&gt;&gt;&gt; id(empty_tuple1)<br/>&gt;&gt;&gt; id(empty_tuple2)</span></pre><p id="ad23" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">输出:</strong></p><pre class="kp kq kr ks gt mp mq mr ms aw mt bi"><span id="de4e" class="mu ln it mq b gy mv mw l mx my">4502782032<br/>4502782032</span></pre><p id="6e3c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">他们的id是一样的。我希望你没有检查所有的数字是否相同，因为有一个简单的方法可以做到这一点:</p><pre class="kp kq kr ks gt mp mq mr ms aw mt bi"><span id="3437" class="mu ln it mq b gy mv mw l mx my">&gt;&gt;&gt; empty_tuple1 <strong class="mq iu">is</strong> empty_tuple2</span></pre><p id="d50b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">输出:</strong></p><pre class="kp kq kr ks gt mp mq mr ms aw mt bi"><span id="a07b" class="mu ln it mq b gy mv mw l mx my">True</span></pre></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><h1 id="4c2a" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">7-拆包</h1><p id="1d74" class="pw-post-body-paragraph jq jr it js b jt mk jv jw jx ml jz ka kb mm kd ke kf mn kh ki kj mo kl km kn im bi translated">元组解包是指将一个元组分配给多个变量。</p><pre class="kp kq kr ks gt mp mq mr ms aw mt bi"><span id="b809" class="mu ln it mq b gy mv mw l mx my">&gt;&gt;&gt; t = ('a', 'b', 'c')<br/>&gt;&gt;&gt; x, y, z = t</span><span id="8c5d" class="mu ln it mq b gy mz mw l mx my">&gt;&gt;&gt; x<br/>'a'</span><span id="2121" class="mu ln it mq b gy mz mw l mx my">&gt;&gt;&gt; y<br/>'b'</span><span id="a0ac" class="mu ln it mq b gy mz mw l mx my">&gt;&gt;&gt; z<br/>'c'</span></pre><p id="c0de" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您想深入了解元组解包的细节，我还有另一篇有趣的文章:</p><div class="nd ne gp gr nf ng"><a rel="noopener  ugc nofollow" target="_blank" href="/improve-your-python-coding-tuple-packing-and-unpacking-44bd92daab31"><div class="nh ab fo"><div class="ni ab nj cl cj nk"><h2 class="bd iu gy z fp nl fr fs nm fu fw is bi translated">改进您的Python编码:元组打包和解包</h2><div class="nn l"><h3 class="bd b gy z fp nl fr fs nm fu fw dk translated">打包和解包确实提高了代码的可读性。让我们复习一下，学习使用下划线和…</h3></div><div class="no l"><p class="bd b dl z fp nl fr fs nm fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="np l"><div class="nq l nr ns nt np nu ky ng"/></div></div></a></div></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><h1 id="21c2" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">8-使用星号' * '运算符扩展解包</h1><p id="046a" class="pw-post-body-paragraph jq jr it js b jt mk jv jw jx ml jz ka kb mm kd ke kf mn kh ki kj mo kl km kn im bi translated"><code class="fe na nb nc mq b">*</code>操作符用于扩展解包。</p><pre class="kp kq kr ks gt mp mq mr ms aw mt bi"><span id="c45b" class="mu ln it mq b gy mv mw l mx my">&gt;&gt;&gt; alphabet = ('a', 'b', 'c', 'd', 'e')<br/>&gt;&gt;&gt; first, *others = alphabet</span><span id="8265" class="mu ln it mq b gy mz mw l mx my">&gt;&gt;&gt; first<br/>'a'</span><span id="01e2" class="mu ln it mq b gy mz mw l mx my">&gt;&gt;&gt; others<br/>['b', 'c', 'd', 'e']</span></pre><p id="cf32" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意，当我们使用<code class="fe na nb nc mq b">*</code>操作符时，返回的是一个列表，而不是一个元组。</p><pre class="kp kq kr ks gt mp mq mr ms aw mt bi"><span id="3750" class="mu ln it mq b gy mv mw l mx my">&gt;&gt;&gt; first, *others, last = alphabet</span><span id="146d" class="mu ln it mq b gy mz mw l mx my">&gt;&gt;&gt; first<br/>'a'</span><span id="c7c7" class="mu ln it mq b gy mz mw l mx my">&gt;&gt;&gt; others<br/>['b', 'c', 'd']</span><span id="d276" class="mu ln it mq b gy mz mw l mx my">&gt;&gt;&gt; last<br/>'e'</span></pre><p id="f9de" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后一个拆包的例子是:</p><pre class="kp kq kr ks gt mp mq mr ms aw mt bi"><span id="17ee" class="mu ln it mq b gy mv mw l mx my">&gt;&gt;&gt; *others, last = alphabet</span><span id="42d9" class="mu ln it mq b gy mz mw l mx my">&gt;&gt;&gt; others<br/>['a', 'b', 'c', 'd']</span><span id="0c06" class="mu ln it mq b gy mz mw l mx my">&gt;&gt;&gt; last<br/>'e'</span></pre></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><h1 id="4a64" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">9-方法</h1><p id="d242" class="pw-post-body-paragraph jq jr it js b jt mk jv jw jx ml jz ka kb mm kd ke kf mn kh ki kj mo kl km kn im bi translated">使用元组的一个优点是保护数据序列，以便数据只支持只读操作。与列表不同，元组没有调整大小的方法:<strong class="js iu">。</strong> <strong class="js iu">【追加】。移除()</strong>，<strong class="js iu">。pop() </strong>等。那还剩下什么？</p><p id="c5e7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">元组有什么？</p><p id="2e1b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">可以肯定的是，<strong class="js iu">指数()</strong>和<strong class="js iu">计数()</strong>:</p><ul class=""><li id="0ed7" class="nv nw it js b jt ju jx jy kb nx kf ny kj nz kn oa ob oc od bi translated"><strong class="js iu"> index() </strong> — <em class="oe">返回一个元素第一次出现的索引</em></li><li id="8bcc" class="nv nw it js b jt of jx og kb oh kf oi kj oj kn oa ob oc od bi translated"><strong class="js iu"> count() </strong> — <em class="oe">返回某个值出现的次数</em></li></ul><pre class="kp kq kr ks gt mp mq mr ms aw mt bi"><span id="2444" class="mu ln it mq b gy mv mw l mx my">&gt;&gt;&gt; t = (1, 2, 3, 1, 1)</span><span id="f5fb" class="mu ln it mq b gy mz mw l mx my">&gt;&gt;&gt; t.index(1)<br/>0</span><span id="7333" class="mu ln it mq b gy mz mw l mx my">&gt;&gt;&gt; t.count(1)<br/>3</span></pre></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><h1 id="544a" class="lm ln it bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">10元组和字典</h1><ul class=""><li id="3529" class="nv nw it js b jt mk jx ml kb ok kf ol kj om kn oa ob oc od bi translated">元组作为键-值对来构建字典:</li></ul><p id="1ea7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在元组的帮助下，你可以很容易地建立一个字典。为此，您应该在集合中存储一个元组序列。这个集合可以是一个元组，甚至是一个列表。值得一提的是，这些元组的第一个元素应该是键，第二个元素应该是这样的值:</p><pre class="kp kq kr ks gt mp mq mr ms aw mt bi"><span id="7545" class="mu ln it mq b gy mv mw l mx my">((key1, value1), (key2, value2), (key3, value3))</span></pre><p id="97b5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">例子:</strong></p><pre class="kp kq kr ks gt mp mq mr ms aw mt bi"><span id="e8dc" class="mu ln it mq b gy mv mw l mx my">&gt;&gt;&gt; winter_list = [('jan', 1), ('feb', 2), ('dec', 12)]<br/>&gt;&gt;&gt; winter_tuple = (('jan', 1), ('feb', 2), ('dec', 12))</span><span id="72db" class="mu ln it mq b gy mz mw l mx my">&gt;&gt;&gt; winter = dict(winter_list)<br/>&gt;&gt;&gt; winter.get('jan')<br/>1</span><span id="b080" class="mu ln it mq b gy mz mw l mx my">&gt;&gt;&gt; winter = dict(winter_tuple)<br/>&gt;&gt;&gt; winter.get('dec')<br/>12</span><span id="4b00" class="mu ln it mq b gy mz mw l mx my">&gt;&gt;&gt; winter<br/>{'jan': 1, 'feb': 2, 'dec': 12}</span></pre><p id="3d5c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们再举一个元组用法的例子。假设我们在太空中有一个<em class="oe"> 2 x 2 </em>网格系统，想要存储一个航天器从点经过的次数。这里，我们将使用元组作为字典中的键。</p><p id="9c85" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">例2: </strong></p><pre class="kp kq kr ks gt mp mq mr ms aw mt bi"><span id="1c9a" class="mu ln it mq b gy mv mw l mx my">&gt;&gt;&gt; grid_data = {(0, 0): 100, (0, 1): 50, (1, 0): 75, (1, 1): 75}<br/>&gt;&gt;&gt; grid_data<br/>{(0, 0): 100, (0, 1): 50, (1, 0): 75, (1, 1): 75}</span><span id="8243" class="mu ln it mq b gy mz mw l mx my">&gt;&gt;&gt; grid_data.get((0, 0))<br/>100</span><span id="cf0a" class="mu ln it mq b gy mz mw l mx my">&gt;&gt;&gt; grid_data.get((1, 0))<br/>75</span></pre></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><p id="8660" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">结论</strong></p><p id="be86" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如您所见，元组提供了广泛的用途和特性。更好地使用元组会让你在程序中更加舒适和灵活。</p><p id="4071" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">不像元组，你的Python知识不应该是未经修改的！可以延长！</p></div><div class="ab cl lf lg hx lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="im in io ip iq"><p id="ffcc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">总是有新的东西要学。我希望你在阅读时喜欢我的文章。</p><p id="2823" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你愿意，你可以看看我发表的另一篇文章:</p><div class="nd ne gp gr nf ng"><a href="https://betterprogramming.pub/stop-using-or-to-check-multiple-conditions-in-python-404d31f2b569" rel="noopener  ugc nofollow" target="_blank"><div class="nh ab fo"><div class="ni ab nj cl cj nk"><h2 class="bd iu gy z fp nl fr fs nm fu fw is bi translated">在Python中停止使用“或”来检查多个条件</h2><div class="nn l"><h3 class="bd b gy z fp nl fr fs nm fu fw dk translated">还有更精密的解决方案！</h3></div><div class="no l"><p class="bd b dl z fp nl fr fs nm fu fw dk translated">better编程. pub</p></div></div><div class="np l"><div class="on l nr ns nt np nu ky ng"/></div></div></a></div></div></div>    
</body>
</html>