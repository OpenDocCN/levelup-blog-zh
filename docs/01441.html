<html>
<head>
<title>Git doesn’t have to be hard</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Git不一定很难</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/git-doesnt-have-to-be-hard-e1e115be6668?source=collection_archive---------0-----------------------#2020-01-01">https://levelup.gitconnected.com/git-doesnt-have-to-be-hard-e1e115be6668?source=collection_archive---------0-----------------------#2020-01-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/18617a02e552a05afa3aaa14d68bd2f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kAKxPywVjfwwgBRhXr2m7Q.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">这个人为什么难过？因为他不懂独角兽！</figcaption></figure><p id="2a9b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">多年来，每当我不得不在Git中工作时，我都会感到一丝恐惧。传统的源代码控制更有意义:我“签出”一个文件来处理它；源代码管理锁定中心副本，这样在我完成之前就没有人能篡改它。那样的话，真相只有一个版本。简单。</p><p id="63ce" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我记得一位工程师耐心地向我解释Git是如何工作的:有你的<em class="ld">工作树、</em>和你的<em class="ld">登台环境、</em>和一切真的只是一个指针，等等。我从来不明白这一点——所以每当我陷入困境时，我都不知道如何摆脱困境。</p><p id="0638" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">直到我明白。</p><h1 id="6d7b" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">没有勺子</h1><p id="d620" class="pw-post-body-paragraph kf kg it kh b ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky mg la lb lc im bi translated">放下对外界的依恋。忘了远程回购吧。忘记<code class="fe mh mi mj mk b">push</code>和<code class="fe mh mi mj mk b">pull</code>。想象一下，你有一个完整的源代码控制系统供你个人使用——类似于Perforce，但只为你一个人。您可以获得版本历史、回滚、分支、签入，所有这些。</p><p id="77d9" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如果没有人在编辑文件，你还需要锁定它们吗？大概不会。所以与其跟踪文件版本，为什么不直奔主题，跟踪你真正感兴趣的:<em class="ld">变更。当你编辑一个文件时，那就是一种改变。当你创建或删除一个文件，这是一个变化。</em></p><p id="1847" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如果没有其他人正在编辑您的项目，您是否需要单独查看文件的“真实”版本？您需要查看存储库树吗？大概不会。你只需要知道你所做的改变会被记录在某个地方。当您切换分支时，如果您的工作目录中的文件能够神奇地匹配您所在的分支，那就太好了。事实证明，这正是Git的工作方式。</p><h1 id="8fe3" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">一只手鼓掌</h1><p id="5e34" class="pw-post-body-paragraph kf kg it kh b ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky mg la lb lc im bi translated"><em class="ld">工作目录</em>是一个真实的地方:它是你找到你正在工作的项目文件的地方。但是<em class="ld">暂存区</em>和<em class="ld">存储库</em>只是概念。所以你也可以忘记这些——至少现在。</p><p id="9f5d" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">使用Git，您需要做的就是:</p><ol class=""><li id="82ef" class="ml mm it kh b ki kj km kn kq mn ku mo ky mp lc mq mr ms mt bi translated">更改</li><li id="b2ae" class="ml mm it kh b ki mu km mv kq mw ku mx ky my lc mq mr ms mt bi translated">告诉Git要跟踪哪些</li><li id="5873" class="ml mm it kh b ki mu km mv kq mw ku mx ky my lc mq mr ms mt bi translated">追踪他们</li></ol><p id="ce2b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">当人们谈论一个<em class="ld">准备区域时，</em>他们只是指你准备在Git中形式化的变更列表。<code class="fe mh mi mj mk b">add</code>命令真正的意思是:将这个变更添加到列表中。请记住:您跟踪的是更改，而不是文件。当您从Git中删除一个文件时，就会创建一个您必须添加的更改！扑朔迷离！</p><p id="34b2" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><code class="fe mh mi mj mk b">commit</code>命令获取您使用<code class="fe mh mi mj mk b">add</code>命令收集的大量变更，并将其记录在<em class="ld">存储库</em>中——记住，这是一个想法，而不是一个位置。<em class="ld">库</em>只是所有这些变更的列表(称为<em class="ld">提交</em>)。</p><p id="9b97" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">您不需要单独的文件树来保持项目的最新版本。如果您曾经向后或向前滚动到代码的不同版本，或者切换分支，那么您在Git中所做的一切都是指向一个特定的<em class="ld">提交</em>，它代表了当时该分支上的情况。Git会自动将所有这些更改应用到您的工作目录中。您的工作目录成为该版本文件的正确视图。神奇！</p><h1 id="9afc" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">打开分离舱舱门</h1><p id="5dfa" class="pw-post-body-paragraph kf kg it kh b ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky mg la lb lc im bi translated">在传统的源代码控制中，有一个中央真理库。任何处理该存储库中文件的人都必须签入和签出文件。目标是保持中央存储库干净。这造成了一个非常严格的瓶颈，因为两个人不能同时处理相同的文件。这也是一个单点故障:如果中央存储库发生问题，您最好希望有人保留了备份。</p><p id="0683" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">使用Git，每个参与项目的人都有自己的整个存储库的副本。所有的“源代码控制”都发生在每个人自己的计算机上。没有什么能阻止人们同时处理相同的文件。中央存储库实际上并不意味着是真实的单一来源，而是项目中每个人的同步点。如果中央存储库消失了，任何拥有最新副本的人都可以在几分钟内重新创建它。</p><p id="fe14" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">来自传统的源代码控制环境，我被一个简单的误解所迷惑:我认为<code class="fe mh mi mj mk b">push</code>和<code class="fe mh mi mj mk b">pull</code>就像签入和签出文件。正是意识到<code class="fe mh mi mj mk b">commit</code>实际上更像是签到，没有结账，帮助我最终理解了Git。</p><h1 id="0cae" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">让乐队重聚</h1><p id="169b" class="pw-post-body-paragraph kf kg it kh b ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky mg la lb lc im bi translated">大多数情况下，如果您的工作流如下所示，您应该不会有任何问题:</p><ol class=""><li id="5933" class="ml mm it kh b ki kj km kn kq mn ku mo ky mp lc mq mr ms mt bi translated">从右分支提取(修复任何合并冲突)。</li><li id="4905" class="ml mm it kh b ki mu km mv kq mw ku mx ky my lc mq mr ms mt bi translated">在正确的分支中处理您的文件。</li><li id="58e2" class="ml mm it kh b ki mu km mv kq mw ku mx ky my lc mq mr ms mt bi translated">每次到达一个好的检查点时，添加您的更改并提交。</li><li id="c712" class="ml mm it kh b ki mu km mv kq mw ku mx ky my lc mq mr ms mt bi translated">当其他人看到你的作品的时候，拉，合并，推到正确的分支。</li></ol><p id="b366" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如果你真的遇到了麻烦，那通常是因为你忘记了一个步骤。这里有几个例子。</p><p id="672b" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">在错误的分支中编辑了一个文件。你希望能够做的是撤销那些改变，切换分支，然后重新做。实际上，更好的方法是从错误的分支中取出这些变化，轻轻地放在你想要的分支上。幸运的是，Git提供了一个名为<code class="fe mh mi mj mk b"><a class="ae mz" href="https://git-scm.com/docs/git-stash" rel="noopener ugc nofollow" target="_blank">stash</a></code>的命令来做这件事。</p><p id="f479" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">误编辑了一个文件。你打开了一个文件来看，但是你的猫走过了键盘。您不确定添加或删除了什么。你只是想回到上次提交时的样子。为此，使用<code class="fe mh mi mj mk b"><a class="ae mz" href="https://git-scm.com/docs/git-checkout" rel="noopener ugc nofollow" target="_blank">checkout</a></code>。</strong></p><p id="b241" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">补充得太早。你以正确的方式编辑了正确的文件，但是你过于匆忙地将它添加到了暂存区。您不想撤销对文件的更改，但希望在下次提交时将其删除。这是<code class="fe mh mi mj mk b"><a class="ae mz" href="https://git-scm.com/docs/git-reset" rel="noopener ugc nofollow" target="_blank">reset</a></code>的用途之一。您还可以使用<code class="fe mh mi mj mk b">reset</code>进行更剧烈的回滚。如果需要，您可以撤消整个提交。</strong></p><h2 id="a053" class="na lf it bd lg nb nc dn lk nd ne dp lo kq nf ng ls ku nh ni lw ky nj nk ma nl bi translated">摆脱困境</h2><p id="5b21" class="pw-post-body-paragraph kf kg it kh b ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky mg la lb lc im bi translated">如果你想知道如何解决上述问题，你可以看看我的文章<a class="ae mz" rel="noopener ugc nofollow" target="_blank" href="/git-outta-trouble-56aba6672cb8">Git out Trouble</a>。</p><h1 id="726a" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">你动动脑子</h1><p id="be9b" class="pw-post-body-paragraph kf kg it kh b ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky mg la lb lc im bi translated">哦，是的，我还没有涉及合并冲突。只有一件事让我感到困惑:哪一部分是我试图添加的更改，哪一部分是我与之冲突的其他人的更改？答案是Git的一个核心概念:每当你看到单词<code class="fe mh mi mj mk b">HEAD</code>时，你应该把它想象成一个信号，表示:<em class="ld">你在这里。</em><code class="fe mh mi mj mk b">HEAD</code>是指向您工作位置的指针——当前分支上的活动提交。当您阅读像<code class="fe mh mi mj mk b">reset</code>这样的命令的语法参考时，这个概念很方便。</p><h1 id="1a9f" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">走开</h1><p id="3606" class="pw-post-body-paragraph kf kg it kh b ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky mg la lb lc im bi translated">您现在已经注意到，我没有提供如何使用任何命令的具体示例。有很多地方可以找到修复各种灾难的方法。如果没有很好地理解Git，这些指令可能会令人困惑，或者让您陷入更大的麻烦。但是现在您已经理解了Git是如何思考的，这些地方可能对您更有意义。我会先说<a class="ae mz" href="https://dangitgit.com/" rel="noopener ugc nofollow" target="_blank">该死，蠢货！</a></p><p id="01a6" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">更新:</strong>如果你想要更多的信息，我实际上写了一本书谈到这一点(和一些Markdown的东西):<a class="ae mz" href="https://www.amazon.com/Markdown-Dreams-How-things-Git-dp-B08JF5KLHL/dp/B08JF5KLHL/" rel="noopener ugc nofollow" target="_blank"> Markdown梦想:如何用Markdown和Git做事</a></p><p id="d716" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">更新到更新:</strong>我认为<em class="ld"> Git不一定很难</em>可能是一个足够有趣的主题，可以写一整本书。<a class="ae mz" href="https://www.amazon.com/dp/B095NPFJFR" rel="noopener ugc nofollow" target="_blank">于是我做了</a>:</p><figure class="nn no np nq gt ju gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/adc004599adec1ac477ab71b7b7d2dff.png" data-original-src="https://miro.medium.com/v2/resize:fit:670/format:webp/0*YU7RvV2be2vxb17m.jpg"/></div></figure><p id="1daf" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如果你没有时间读完一整本书，你可以看一个简短的视频:</p><figure class="nn no np nq gt ju"><div class="bz fp l di"><div class="nr ns l"/></div></figure></div></div>    
</body>
</html>