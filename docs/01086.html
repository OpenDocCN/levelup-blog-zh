<html>
<head>
<title>TypeScript Safe API Requests</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">类型脚本安全API请求</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/a-typescript-safe-api-82cc22c4f92d?source=collection_archive---------0-----------------------#2019-11-08">https://levelup.gitconnected.com/a-typescript-safe-api-82cc22c4f92d?source=collection_archive---------0-----------------------#2019-11-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="67dd" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何将TypeScript类型添加到客户端发出的API请求中，从而允许类型安全扩展到整个web应用程序。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/839766553c1fa1544309f40af87c8cda.png" data-original-src="https://miro.medium.com/v2/resize:fit:808/format:webp/1*0_h2e0JguY7m1pd3jopClA.png"/></div></div></figure><p id="ee65" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通过将TypeScript引入到您的项目中，您可以获得许多立竿见影的效果。当它们开始累积时，您的工程团队获得的信心水平本身就是值得的。</p><p id="7fe5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">提高应用程序的类型安全性的最快方法之一是使API调用类型安全。通过这样做，您将设置编排这些调用的代码是类型安全的，很快类型安全就会渗透到代码库的其余部分。</p><h1 id="deae" class="lq lr it bd ls lt lu lv lw lx ly lz ma jz mb ka mc kc md kd me kf mf kg mg mh bi translated">类型安全轴</h1><p id="3762" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">这里展示的例子是特定于<a class="ae mn" href="https://github.com/axios/axios" rel="noopener ugc nofollow" target="_blank"> axios </a>的，但是可以推广到任何其他具有TypeScript绑定的http客户端。</p><p id="fcaf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">虽然axios目前是用普通JS编写的，但是TS定义是直接存储在repo 中的<a class="ae mn" href="https://github.com/axios/axios/blob/v0.19.0/index.d.ts" rel="noopener ugc nofollow" target="_blank">。发布的axios npm包包含了这些定义，因此无论您在什么地方使用axios，都可以在<code class="fe mo mp mq mr b">.ts</code>文件中获得TS支持。</a></p><h2 id="f7e9" class="ms lr it bd ls mt mu dn lw mv mw dp ma ld mx my mc lh mz na me ll nb nc mg nd bi translated">创建客户端</h2><p id="ff54" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">现在来定义你的第一个类型安全的API函数。您将设置axios客户端。</p><pre class="kj kk kl km gt ne mr nf ng aw nh bi"><span id="88c1" class="ms lr it mr b gy ni nj l nk nl">const apiClient = axios.create({<br/>  baseURL: 'https://yoursite.com/api',<br/>  responseType: 'json',<br/>  headers: {<br/>    'Content-Type': 'application/json'<br/>  }<br/>});</span></pre><h2 id="fbdf" class="ms lr it bd ls mt mu dn lw mv mw dp ma ld mx my mc lh mz na me ll nb nc mg nd bi translated">创建一个API函数</h2><p id="f02b" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">然后为使用<code class="fe mo mp mq mr b">apiClient</code>的单个API调用创建一个方法。</p><pre class="kj kk kl km gt ne mr nf ng aw nh bi"><span id="38cb" class="ms lr it mr b gy ni nj l nk nl">const createUser = async (newUser: NewUser) =&gt; {<br/>  try {<br/>    const response = await apiClient.post&lt;User&gt;('/users', newUser);<br/>    const user = response.data;<br/>    return user;<br/>  } catch (err) {<br/>    if (err &amp;&amp; err.response) {<br/>      const axiosError = err as AxiosError&lt;ServerError&gt;<br/>      return axiosError.response.data;<br/>    }<br/>    <br/>    throw err;<br/>  }<br/>};</span></pre><p id="3473" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们剖析一下<code class="fe mo mp mq mr b">createUser</code>函数中发生了什么。首先，我们已经决定不直接将<code class="fe mo mp mq mr b">axiosClient</code>暴露给我们代码库中的任何模块。它的所有用法都将封装在为我们的应用程序进行的每个远程调用编写的函数中。这允许我们在这个位置只关心Axios特定的类型，而应用程序的其余部分将使用最终从这些函数返回的域特定的类型。它还具有在一个位置定义所有远程调用的额外好处。</p><h2 id="cf6b" class="ms lr it bd ls mt mu dn lw mv mw dp ma ld mx my mc lh mz na me ll nb nc mg nd bi translated">锁定请求参数</h2><pre class="kj kk kl km gt ne mr nf ng aw nh bi"><span id="fedc" class="ms lr it mr b gy ni nj l nk nl">const createUser = async (newUser: NewUser) =&gt; {</span></pre><p id="f25e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们的函数接受一个类型为<code class="fe mo mp mq mr b">NewUser</code>的<code class="fe mo mp mq mr b">newUser</code>参数。这为我们的API调用主体将采用的参数提供了类型安全。它最有可能定义一个带有几个字段的对象(例如<code class="fe mo mp mq mr b">type NewUser = { firstName: string, lastName: string }</code>)。</p><h2 id="6f88" class="ms lr it bd ls mt mu dn lw mv mw dp ma ld mx my mc lh mz na me ll nb nc mg nd bi translated">使用泛型来键入响应正文</h2><pre class="kj kk kl km gt ne mr nf ng aw nh bi"><span id="e085" class="ms lr it mr b gy ni nj l nk nl">const response = await apiClient.post&lt;User&gt;('/users', newUser);</span></pre><p id="98f8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这是我们与Axios类型的第一次交互。Axios通过利用<a class="ae mn" href="https://www.typescriptlang.org/docs/handbook/generics.html" rel="noopener ugc nofollow" target="_blank">泛型</a>使得它的<code class="fe mo mp mq mr b">post</code>方法可重用且类型友好。我们作为<code class="fe mo mp mq mr b">&lt;User&gt;</code>提供的通用参数是<a class="ae mn" href="https://github.com/axios/axios/blob/v0.19.0/index.d.ts#L136" rel="noopener ugc nofollow" target="_blank">什么Axios将使用</a>来键入成功的响应体。</p><h2 id="c949" class="ms lr it bd ls mt mu dn lw mv mw dp ma ld mx my mc lh mz na me ll nb nc mg nd bi translated">受益于隐式类型</h2><pre class="kj kk kl km gt ne mr nf ng aw nh bi"><span id="e9a5" class="ms lr it mr b gy ni nj l nk nl">const user = response.data;<br/>return user;</span></pre><p id="e980" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因为我们使用泛型向Axios提供响应主体类型，所以下一行静态地保证将<code class="fe mo mp mq mr b">const user</code>识别为类型<code class="fe mo mp mq mr b">User</code>。这很好，因为现在任何调用<code class="fe mo mp mq mr b">createUser</code>函数的代码都知道返回类型必须是<code class="fe mo mp mq mr b">User</code>。</p><h2 id="86ce" class="ms lr it bd ls mt mu dn lw mv mw dp ma ld mx my mc lh mz na me ll nb nc mg nd bi translated">处理错误响应</h2><pre class="kj kk kl km gt ne mr nf ng aw nh bi"><span id="0145" class="ms lr it mr b gy ni nj l nk nl">} catch (err) {<br/>  if (err &amp;&amp; err.response) {<br/>    ...<br/>  }<br/>    <br/>  throw err;<br/>}</span></pre><p id="1c49" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">好的，那么catch块呢？响应成功的快乐路径在try块中被捕获。当响应失败时，我们希望确保正确输入了路径。</p><p id="3076" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">Axios将任何非200级别的响应视为异常，这就是我们使用try/catch的原因。它<a class="ae mn" href="https://github.com/axios/axios/blob/v0.19.0/index.d.ts#L79" rel="noopener ugc nofollow" target="_blank">抛出的数据类型为</a> <code class="fe mo mp mq mr b">AxiosError&lt;TResponseBody&gt;</code>。一些基本的验证是通过检查它确实是一个<code class="fe mo mp mq mr b">AxiosError</code>，而不是通过验证<code class="fe mo mp mq mr b">err.response</code>存在而抛出的其他JS错误来完成的。如果它不是一个<code class="fe mo mp mq mr b">AxiosError</code>，那么将再次抛出错误，并需要由其他应用程序代码捕获。</p><pre class="kj kk kl km gt ne mr nf ng aw nh bi"><span id="36f7" class="ms lr it mr b gy ni nj l nk nl">const axiosError = err as AxiosError&lt;ServerError&gt;<br/>return axiosError.response.data;</span></pre><p id="5ca6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">至于当确定我们正在处理非200级响应时会发生什么，我们可以也应该在正常的申请流程下处理。为此，我们将catch块中的<code class="fe mo mp mq mr b">err</code>转换为所提供的<code class="fe mo mp mq mr b">AxiosError</code>类型。它还接受响应体的通用参数，与<code class="fe mo mp mq mr b">AxiosResponse</code>相同。<code class="fe mo mp mq mr b">ServerError</code>是一个自定义类型，您可以根据自己知道的API返回来定义(例如<code class="fe mo mp mq mr b">type ServerError = { code: string, description: string }</code>)。现在，我们可以像在200级快乐路径中那样返回响应体了。</p><p id="1888" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe mo mp mq mr b">createUser</code>函数现在有一个隐式返回值<code class="fe mo mp mq mr b">Promise&lt;User | ServerError&gt;</code>。</p></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><h1 id="4038" class="lq lr it bd ls lt nt lv lw lx nu lz ma jz nv ka mc kc nw kd me kf nx kg mg mh bi translated">有什么意义？</h1><p id="5b00" class="pw-post-body-paragraph ku kv it kw b kx mi ju kz la mj jx lc ld mk lf lg lh ml lj lk ll mm ln lo lp im bi translated">似乎写了很多额外的代码，目的是什么？现在，调用堆栈中位于该函数之下的任何其他代码都将受益于它提供的静态类型。它可能是Redux中的一个thunk，现在知道了返回类型，然后导致一个知道类型的动作创建者，然后是一个reducer，然后是存储状态，一直到您的UI库。类型将到处传播，使您的整个代码库更有弹性。您不仅可以在命令运行时得到类型验证，而且这些类型将开始成为您、您未来的自己以及您的合作者可以使用的一种通用语言。</p><p id="f7cd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通过在API级别提供静态类型安全，您可以从底层开始锁定您的TS代码。</p></div><div class="ab cl nm nn hx no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="im in io ip iq"><div class="kj kk kl km gt ny"><a href="https://skilled.dev" rel="noopener  ugc nofollow" target="_blank"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd iu gy z fp od fr fs oe fu fw is bi translated">编写面试问题</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">一个完整的平台，在这里我会教你找到下一份工作所需的一切，以及…</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">技术开发</p></div></div><div class="oh l"><div class="oi l oj ok ol oh om ks ny"/></div></div></a></div></div></div>    
</body>
</html>