<html>
<head>
<title>Decorators, Callables, and Function Metadata in Python — Handy Python Features (Part 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的Decorators、Callables和函数元数据——方便的Python特性(第2部分)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/handy-python-features-part-02-aac256da98a9?source=collection_archive---------3-----------------------#2019-07-11">https://levelup.gitconnected.com/handy-python-features-part-02-aac256da98a9?source=collection_archive---------3-----------------------#2019-07-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c92b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">__探索_更多_装饰者_ _。巴拉圭</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/6954805458f30ce7e141667e55c94a00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0-IW8J7zfRlvok1D"/></div></div></figure><p id="8e5f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">本系列的第1部分让你更好地理解了装饰者如何工作以及在哪里使用它们。在这次讨论中，我们准备使用元数据和可调用性来探索更多关于decorators的内容。</p><h1 id="23fb" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">函数元数据</h1><p id="6be6" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">在函数中维护元数据有几个目的。例如，当定义一个函数时，我们可以为文档做笔记。这些注释作为元数据存储在ide将使用的<code class="fe ml mm mn mo b">__doc__</code>字段中。我们可以用内置函数<code class="fe ml mm mn mo b">help(*args, **kwargs)</code> <strong class="kt ir"> </strong>来测试这个。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">元数据:为文档添加的注释</figcaption></figure><p id="8686" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这将使用<strong class="kt ir"> </strong> <code class="fe ml mm mn mo b">__doc__</code> <strong class="kt ir"> </strong>和<code class="fe ml mm mn mo b">__name__</code>元数据来呈现结果，如下所示。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/54bd16bfd1df8a5bcf290b8874e28639.png" data-original-src="https://miro.medium.com/v2/resize:fit:936/format:webp/1*d4WOX8a5ntvc6LOLk08Iag.jpeg"/></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">元数据:__doc__和__name__元数据正在使用中</figcaption></figure><h2 id="4e85" class="mw lp iq bd lq mx my dn lu mz na dp ly la nb nc ma le nd ne mc li nf ng me nh bi translated">装饰者对元数据的影响</h2><p id="417b" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">一旦函数被修饰，这些元数据就会丢失。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">元数据:修饰函数</figcaption></figure><p id="49a0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">结果不如预期。实际函数的元数据在此时丢失，如下所示。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/1de3cf6e4608159c1ec93f00dd43af46.png" data-original-src="https://miro.medium.com/v2/resize:fit:822/format:webp/1*u-ZTtBJBlJU5vu7pcl7y8g.jpeg"/></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">元数据:不是预期的结果</figcaption></figure><h2 id="3d28" class="mw lp iq bd lq mx my dn lu mz na dp ly la nb nc ma le nd ne mc li nf ng me nh bi translated">携带元数据</h2><p id="79a3" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">为了解决这个问题，我们需要将原始元数据传递给装饰者。一种方法是用原始属性重置装饰器属性。这是可能的，因为我们可以通过函数引用访问这些字段。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">元数据:在装饰器中重置元数据</figcaption></figure><p id="25e3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这将重置元数据，函数<code class="fe ml mm mn mo b">help(hello_world)</code>将像以前一样显示正确的注释。然而，有一种更好的方法。Python提供了一个名为<code class="fe ml mm mn mo b">functools</code>的模块，它有一个名为<code class="fe ml mm mn mo b">@wrap(function)</code>的装饰器，它将原始函数作为一个属性，并像我们上面所做的那样完成其余的工作。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">元数据:使用@functools.wrap(函数)</figcaption></figure><p id="09aa" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">到目前为止，我们已经看到了函数是如何被修饰的。这种装饰技巧不仅适用于函数，也适用于许多其他“可调用”的对象。在进一步探索之前，我们需要理解什么是可调用的。</p><h1 id="11b1" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">可召回商品</h1><p id="87a9" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">python中的可调用是任何可以被调用的东西。例如，函数是可调用的。类是可调用的。我们可以调用一个类来创建它的实例。还有什么是可调用的？</p><h2 id="277a" class="mw lp iq bd lq mx my dn lu mz na dp ly la nb nc ma le nd ne mc li nf ng me nh bi translated">如何检查</h2><p id="9b60" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">Python中有一个名为<code class="fe ml mm mn mo b">callable(object)</code>的内置函数，可以检查给定对象是否可调用。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">检查可调用:内置函数callable(object)</figcaption></figure><p id="2c1c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们将使用这种方法，并进一步探索哪些对象是可调用的，如下例所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">检查可调用项:进一步探索</figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/faa9af197c51061db92a4624b2d3f3c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1302/format:webp/1*s0qayYAX-KfipIRarBdd5w.jpeg"/></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">检查可调用内容:控制台输出</figcaption></figure><p id="fd97" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">结果表明函数<code class="fe ml mm mn mo b">hello_world()</code>是可调用的。除此之外，lamdas、类、类方法都是可调用的。然而，类、字符串、浮点数、布尔值的实例是不可调用的。</p><h2 id="e699" class="mw lp iq bd lq mx my dn lu mz na dp ly la nb nc ma le nd ne mc li nf ng me nh bi translated">使类实例可调用</h2><p id="6c9d" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">在Python中，类的实例可以被调用。一个类应该定义一个名为<code class="fe ml mm mn mo b">__call__(self, *args, **kwargs)</code> <strong class="kt ir"> </strong>的特殊方法，以使它的实例可调用。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">可调用实例:引入__call__(self)方法</figcaption></figure><p id="8c25" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">引入方法<code class="fe ml mm mn mo b">__call__(self, *args, **kwargs)</code>后，<code class="fe ml mm mn mo b">class Animal</code>的实例变得可调用。</p><h1 id="4e6a" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">可调用的装饰者</h1><p id="f75d" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">装饰者可以将任何可调用对象作为参数，并返回一个可调用对象。现在我们知道类和类实例是可调用的。这使我们能够在装饰者中使用它们。</p><h2 id="1700" class="mw lp iq bd lq mx my dn lu mz na dp ly la nb nc ma le nd ne mc li nf ng me nh bi translated">作为装饰者的类</h2><p id="46c1" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">我们将使用一个类作为装饰器来制作内存缓存。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">装饰者:作为装饰者的类</figcaption></figure><p id="d8a7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这个例子中，<code class="fe ml mm mn mo b">class Cache</code>被用作函数<code class="fe ml mm mn mo b">remote_call(url)</code>的装饰器。假设这个方法执行一个远程调用来获取一些结果。我们需要缓存这些结果，以防止进一步的远程调用，这可能很耗时。保存在<code class="fe ml mm mn mo b">class Cache</code>中的字典<code class="fe ml mm mn mo b">url_result_dict</code>用于存储结果。</p><p id="62ab" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">正如我们在上面发现的，类对象是可调用的。但是装饰者应该接受一个可调用的输入。它接受输入的唯一方式是通过构造函数，方法<code class="fe ml mm mn mo b">__init__(self, function)</code>。<strong class="kt ir"> </strong>很明显，现在将要创建一个类缓存<strong class="kt ir"> </strong>的实例。为了使实例可调用，我们需要像前面讨论的<strong class="kt ir">一样实现方法<code class="fe ml mm mn mo b">__call__(self, *args, **kwargs)</code>。其余的事情都清楚了。缓存工作正常。</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/19c6eb6792d2bb9e2c6d41d502412576.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/1*kEkbCGTPc85adSlD9z2sLQ.jpeg"/></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">缓存:远程调用的结果</figcaption></figure><p id="863f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ml mm mn mo b">endpoint-1</code>的结果第一次来自函数<code class="fe ml mm mn mo b">remote_call(url)</code>。缓存用于第二次响应。<code class="fe ml mm mn mo b">endpoint-2</code>的结果再次来自函数。最终结果来自缓存，因为<code class="fe ml mm mn mo b">endpoint-1</code>已提前取出。</p><h2 id="89e4" class="mw lp iq bd lq mx my dn lu mz na dp ly la nb nc ma le nd ne mc li nf ng me nh bi translated">作为装饰者的实例</h2><p id="d9bf" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">我们也可以使用一个类的实例作为装饰器。在上面的例子中，构造函数用于获取可调用的参数。但是这次用的是方法<code class="fe ml mm mn mo b">__call__(self, function)</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">装饰者:作为装饰者的实例</figcaption></figure><p id="a795" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里，对象<code class="fe ml mm mn mo b">logger</code>是可调用的，并充当装饰器。它返回能够基于布尔值<code class="fe ml mm mn mo b">enabled</code>进行日志记录的内部函数。结果如下。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/1e36b3798b750fb40635ebc6fe87bd48.png" data-original-src="https://miro.medium.com/v2/resize:fit:938/format:webp/1*40kPDGOUdJFjDqyzHa7x1A.jpeg"/></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">记录器:记录器实例已执行。</figcaption></figure><h2 id="3316" class="mw lp iq bd lq mx my dn lu mz na dp ly la nb nc ma le nd ne mc li nf ng me nh bi translated">链接装饰者</h2><p id="b73d" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">装饰器可以多次用于同一个可调用对象。在下面的例子中，我们将使用上述两种装饰器。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">装饰者:链接装饰者</figcaption></figure><p id="abf1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">装饰者<code class="fe ml mm mn mo b">logger</code> <strong class="kt ir"> </strong>返回一个可调用函数，并将其传递给装饰者<code class="fe ml mm mn mo b">Cache</code>。这种链接对于任何数量的装饰者都是可能的。结果如下。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/c98edf1015ba184a092e390bc080b0cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1194/format:webp/1*mWRV45WUruZWptaPdVsJ4w.jpeg"/></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">装饰者:来自两个装饰者的结果</figcaption></figure><h1 id="120d" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">一份申请</h1><p id="55c2" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">下面的例子展示了如何使用decorators实现单例模式。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">装饰者:使用装饰者的单一模式</figcaption></figure><p id="0275" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ml mm mn mo b">class Singleton</code> <strong class="kt ir"> </strong>保存着调用方法<code class="fe ml mm mn mo b">instance()</code>时创建的装饰类<code class="fe ml mm mn mo b">SingletonLogger</code> <strong class="kt ir"> </strong>的实例。使用方法<code class="fe ml mm mn mo b">__call__(self)</code>阻止使用构造函数创建实例。</p><p id="d050" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您可以在以下位置找到Git存储库。</p><div class="nn no gp gr np nq"><a href="https://github.com/vishwaefor/handy-python-features" rel="noopener  ugc nofollow" target="_blank"><div class="nr ab fo"><div class="ns ab nt cl cj nu"><h2 class="bd ir gy z fp nv fr fs nw fu fw ip bi translated">vishwaefor/handy-python-特性</h2><div class="nx l"><h3 class="bd b gy z fp nv fr fs nw fu fw dk translated">便捷的Python特性。通过在GitHub上创建帐户，为vishwaefor/handy-python-features开发做出贡献。</h3></div><div class="ny l"><p class="bd b dl z fp nv fr fs nw fu fw dk translated">github.com</p></div></div><div class="nz l"><div class="oa l ob oc od nz oe kp nq"/></div></div></a></div><h1 id="342d" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">延伸阅读…</h1><p id="1a37" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">装修工得心应手。我们需要确定在哪里使用它们，而不需要编写复杂的代码。我建议你多读一些关于这个话题的书。</p><p id="c904" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Python中有更多方便的特性。发电机就是其中之一。跟随本系列的<a class="ae ln" href="https://vzztalks.com/articles/python/handy-python-features-part-03/" rel="noopener ugc nofollow" target="_blank">第3部分</a>获得更多乐趣。</p></div></div>    
</body>
</html>