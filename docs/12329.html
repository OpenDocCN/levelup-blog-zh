<html>
<head>
<title>Why useEvent is not good enough (and here is a better solution)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么useEvent不够好(这里有一个更好的解决方案)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/why-useevent-is-bad-and-here-is-a-better-solution-c61ee507a82e?source=collection_archive---------1-----------------------#2022-06-01">https://levelup.gitconnected.com/why-useevent-is-bad-and-here-is-a-better-solution-c61ee507a82e?source=collection_archive---------1-----------------------#2022-06-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><blockquote class="jn jo jp"><p id="667d" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">我作为软件工程师在脸书工作，创建了拥有大约4000颗星星的repo。</p></blockquote><p id="f21a" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">这篇文章将使你相信<a class="ae kp" href="https://github.com/reactjs/rfcs/pull/220" rel="noopener ugc nofollow" target="_blank"> useEvent RFC </a>并不是功能组件中回调问题的完美解决方案。我将解释<code class="fe kt ku kv kw b">useEvent</code>的缺点和陷阱，并提供更好的解决方案。</p><h1 id="dd1b" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">使用事件RFC</h1><p id="d141" class="pw-post-body-paragraph jq jr iq jt b ju lv jw jx jy lw ka kb kq lx ke kf kr ly ki kj ks lz km kn ko ij bi translated"><a class="ae kp" href="https://github.com/reactjs/rfcs/blob/useevent/text/0000-useevent.md" rel="noopener ugc nofollow" target="_blank">这里是RFC </a>的链接。<br/>强烈建议在阅读本文之前先阅读RFC。</p><p id="8479" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">在RFC中，<code class="fe kt ku kv kw b">useEvent</code>旨在解决两个问题:</p><ol class=""><li id="cae9" class="ma mb iq jt b ju jv jy jz kq mc kr md ks me ko mf mg mh mi bi translated">提供<code class="fe kt ku kv kw b"><strong class="jt ir">stable identity callbacks</strong></code>，这样得到事件回调道具的组件就不会重新渲染了。</li><li id="738b" class="ma mb iq jt b ju mj jy mk kq ml kr mm ks mn ko mf mg mh mi bi translated">异步得到<code class="fe kt ku kv kw b"><strong class="jt ir">fresh values in callbacks</strong></code><strong class="jt ir"/><em class="js"/>。解决在闭包中捕获过时值的问题。</li></ol><p id="69c2" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">然而，<code class="fe kt ku kv kw b">useEvent</code>并没有很好地解决这两个问题。</p><h1 id="d0e0" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">稳定身份回调</h1><p id="4c2e" class="pw-post-body-paragraph jq jr iq jt b ju lv jw jx jy lw ka kb kq lx ke kf kr ly ki kj ks lz km kn ko ij bi translated"><code class="fe kt ku kv kw b">useEvent</code>可以提供稳定的身份回调。<br/> <a class="ae kp" href="https://github.com/reactjs/rfcs/blob/useevent/text/0000-useevent.md#basic-example" rel="noopener ugc nofollow" target="_blank">使用事件RFC的例子</a>:</p><figure class="mo mp mq mr gt ms"><div class="bz fp l di"><div class="mt mu l"/></div></figure><h1 id="bf42" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">更好的解决方案</h1><p id="e1c1" class="pw-post-body-paragraph jq jr iq jt b ju lv jw jx jy lw ka kb kq lx ke kf kr ly ki kj ks lz km kn ko ij bi translated">试试这个包<a class="ae kp" href="https://github.com/oney/react-with-stable" rel="noopener ugc nofollow" target="_blank">反应稳定</a></p><figure class="mo mp mq mr gt ms"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="a67f" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">用<code class="fe kt ku kv kw b"><strong class="jt ir">withStable</strong></code> HOC包装<code class="fe kt ku kv kw b">SendButton</code>，并明确声明<code class="fe kt ku kv kw b"><strong class="jt ir">onClick</strong></code>为稳定道具。就是这样！这些都是你要添加的代码。<br/> <strong class="jt ir">无需包装事件回调</strong>！！！！！！！！！！</p><p id="aa13" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">记住，即使你使用了<code class="fe kt ku kv kw b">useEvent</code>，你仍然必须使用<code class="fe kt ku kv kw b">React.memo</code>来包装组件，以消除不必要的重新渲染。</p><p id="ab0a" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">我们来比较一下:</p><figure class="mo mp mq mr gt ms"><div class="bz fp l di"><div class="mt mu l"/></div></figure><figure class="mo mp mq mr gt ms gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi mv"><img src="../Images/ce048b9ac367316d80e98d2e123583c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K9-xcLt2VfDTgFlMS60Akw.png"/></div></div></figure><p id="8406" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated"><code class="fe kt ku kv kw b">useEvent</code>的缺点和<code class="fe kt ku kv kw b">withStable</code>的优点是:</p><h2 id="3482" class="nc ky iq bd kz nd ne dn ld nf ng dp lh kq nh ni ll kr nj nk lp ks nl nm lt nn bi translated">🔴 1.[<code class="fe kt ku kv kw b">useEvent</code>]无法包装内联回调</h2><figure class="mo mp mq mr gt ms"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="f2ee" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">在一个循环中呈现组件列表是很常见的。我们利用闭包的好处在回调中传递<code class="fe kt ku kv kw b">item</code>。但是这里不可能使用<code class="fe kt ku kv kw b">useEvent</code>，因为任何钩子都不能在<strong class="jt ir">循环</strong>和<strong class="jt ir">条件</strong>中使用。</p><h2 id="0167" class="nc ky iq bd kz nd ne dn ld nf ng dp lh kq nh ni ll kr nj nk lp ks nl nm lt nn bi translated">✅ 1.[【T2]]适用于内嵌回调(例如循环)</h2><figure class="mo mp mq mr gt ms"><div class="bz fp l di"><div class="mt mu l"/></div></figure><h2 id="16df" class="nc ky iq bd kz nd ne dn ld nf ng dp lh kq nh ni ll kr nj nk lp ks nl nm lt nn bi translated">🔴 2.[ <code class="fe kt ku kv kw b">useEvent</code> ]每次都需要使用事件，并且容易忘记</h2><figure class="mo mp mq mr gt ms"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="f0a0" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">像<code class="fe kt ku kv kw b">useCallback</code>，为了优化，每次都要用<code class="fe kt ku kv kw b">useEvent</code>包裹。这在RFC的<a class="ae kp" href="https://github.com/reactjs/rfcs/blob/useevent/text/0000-useevent.md#drawbacks" rel="noopener ugc nofollow" target="_blank">缺点</a>部分有所说明:</p><blockquote class="jn jo jp"><p id="6bd1" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">与普通的事件处理程序相比，用<code class="fe kt ku kv kw b">useEvent</code>包装看起来更嘈杂。</p></blockquote><p id="b2bc" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">事实上，useEvent的计算和内存成本很便宜。它真正的成本是开发的成本(即<a class="ae kp" href="https://medium.com/swlh/what-is-dx-developer-experience-401a0e44a9d9" rel="noopener"> DX </a>)，需要开发人员记忆和编写代码。</p><h2 id="6d51" class="nc ky iq bd kz nd ne dn ld nf ng dp lh kq nh ni ll kr nj nk lp ks nl nm lt nn bi translated">✅ 2.[ <code class="fe kt ku kv kw b">withStable</code> ]一次包装，随处优化</h2><figure class="mo mp mq mr gt ms"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="6734" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">比方说在<code class="fe kt ku kv kw b">useEvent</code>发布之后，你有一个子组件要优化，有10个父组件在使用它，你必须重构来写<code class="fe kt ku kv kw b">useEvent</code> 10次！</p><p id="3c04" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">相比之下，你只需要用<code class="fe kt ku kv kw b">withStable</code>包装子组件一次，所有的父组件都会得到优化。</p><p id="f446" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">那就是我们所说的<a class="ae kp" href="https://medium.com/swlh/what-is-dx-developer-experience-401a0e44a9d9" rel="noopener"> DX </a>。</p><h2 id="da5f" class="nc ky iq bd kz nd ne dn ld nf ng dp lh kq nh ni ll kr nj nk lp ks nl nm lt nn bi translated">🔴 3.[<code class="fe kt ku kv kw b">useEvent</code>]对条件值没有帮助</h2><figure class="mo mp mq mr gt ms"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="d646" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">说<code class="fe kt ku kv kw b">onOdd</code>和<code class="fe kt ku kv kw b">onEven</code>是稳定的，但是条件<code class="fe kt ku kv kw b">text.length % 2</code>变化频繁，所以<code class="fe kt ku kv kw b">SendButton</code>无法得到导致重渲染的相同身份回调。这在RFC的<a class="ae kp" href="https://github.com/reactjs/rfcs/blob/useevent/text/0000-useevent.md#drawbacks" rel="noopener ugc nofollow" target="_blank">缺点</a>部分有所说明:</p><blockquote class="jn jo jp"><p id="35fe" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">类似<code class="fe kt ku kv kw b">onSomething={cond ? handler1 : handler2}</code>的“条件事件”案例</p></blockquote><p id="1e64" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">为了解决这个问题，我们必须定义一个由<code class="fe kt ku kv kw b">useEvent</code>包装的新回调，这是令人不快的。</p><h2 id="a250" class="nc ky iq bd kz nd ne dn ld nf ng dp lh kq nh ni ll kr nj nk lp ks nl nm lt nn bi translated">✅ 3.[ <code class="fe kt ku kv kw b">withStable</code> ]也适用于条件值</h2><figure class="mo mp mq mr gt ms"><div class="bz fp l di"><div class="mt mu l"/></div></figure><h2 id="ad38" class="nc ky iq bd kz nd ne dn ld nf ng dp lh kq nh ni ll kr nj nk lp ks nl nm lt nn bi translated">🔴 4.图书馆用户的负担</h2><figure class="mo mp mq mr gt ms"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="8555" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">库用户需要知道哪些回调属性是useEvent-safe(只在事件处理程序中使用，不在渲染中使用)。<br/>如果在渲染中使用了<code class="fe kt ku kv kw b">useEvent</code> -wrapped <code class="fe kt ku kv kw b">submit</code>，那么<a class="ae kp" href="https://github.com/reactjs/rfcs/blob/useevent/text/0000-useevent.md#functions-called-during-render-still-use-usecallback" rel="noopener ugc nofollow" target="_blank">会抛出</a>。</p><h2 id="1638" class="nc ky iq bd kz nd ne dn ld nf ng dp lh kq nh ni ll kr nj nk lp ks nl nm lt nn bi translated">✅ 4.【<code class="fe kt ku kv kw b">withStable</code>】库制作者做性能优化</h2><figure class="mo mp mq mr gt ms"><div class="bz fp l di"><div class="mt mu l"/></div></figure><h2 id="ba92" class="nc ky iq bd kz nd ne dn ld nf ng dp lh kq nh ni ll kr nj nk lp ks nl nm lt nn bi translated">简短的</h2><ol class=""><li id="2d99" class="ma mb iq jt b ju lv jy lw kq no kr np ks nq ko mf mg mh mi bi translated"><code class="fe kt ku kv kw b">useEvent</code>不能用于循环和条件中的内联回调。</li><li id="94a2" class="ma mb iq jt b ju mj jy mk kq ml kr mm ks mn ko mf mg mh mi bi translated">为什么不一次包装，随处优化？</li><li id="7e31" class="ma mb iq jt b ju mj jy mk kq ml kr mm ks mn ko mf mg mh mi bi translated">让组件维护者优化，组件用户免费获得。</li></ol><h2 id="a94c" class="nc ky iq bd kz nd ne dn ld nf ng dp lh kq nh ni ll kr nj nk lp ks nl nm lt nn bi translated">奖金</h2><p id="9775" class="pw-post-body-paragraph jq jr iq jt b ju lv jw jx jy lw ka kb kq lx ke kf kr ly ki kj ks lz km kn ko ij bi translated"><code class="fe kt ku kv kw b">withStable</code>也将有助于忽略依赖列表中的稳定回调。<a class="ae kp" href="https://github.com/reactjs/rfcs/blob/useevent/text/0000-useevent.md#linter-plugin" rel="noopener ugc nofollow" target="_blank">该问题</a>在RFC中有说明:</p><blockquote class="jn jo jp"><p id="2f8f" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">从父组件传递的<code class="fe kt ku kv kw b">useEvent</code>函数必须被声明为依赖项。</p></blockquote><p id="57c7" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">linter通过检查<code class="fe kt ku kv kw b">withStable(["onClick"]</code>就能搞清楚哪些道具是稳定的，所以<code class="fe kt ku kv kw b">handle*</code>或者<code class="fe kt ku kv kw b">on*</code>的命名约定就没必要了。<br/>linter还可以检查一个稳定的道具是否被传递给了一个子组件的非稳定道具。</p><h1 id="2dc0" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">在回调中获取新值</h1><p id="4a52" class="pw-post-body-paragraph jq jr iq jt b ju lv jw jx jy lw ka kb kq lx ke kf kr ly ki kj ks lz km kn ko ij bi translated"><code class="fe kt ku kv kw b">useEvent</code> RFC还想解决闭包中的<a class="ae kp" href="https://github.com/reactjs/rfcs/blob/useevent/text/0000-useevent.md#useeffect-shouldnt-re-fire-when-event-handlers-change" rel="noopener ugc nofollow" target="_blank">过时值问题，例如:</a></p><figure class="mo mp mq mr gt ms"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="41b3" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">需要注意的一点是，回调中的值只有在调用不同步时才可能过时，比如在<code class="fe kt ku kv kw b">await</code>之后或者回调被异步调用<em class="js">。</em></p><p id="b16e" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated"><code class="fe kt ku kv kw b">useEvent</code>获取新值的模式有一些陷阱和缺点:</p><h2 id="a1b4" class="nc ky iq bd kz nd ne dn ld nf ng dp lh kq nh ni ll kr nj nk lp ks nl nm lt nn bi translated">1.需要在效果之外定义新的回调</h2><figure class="mo mp mq mr gt ms"><div class="bz fp l di"><div class="mt mu l"/></div></figure><h2 id="7d72" class="nc ky iq bd kz nd ne dn ld nf ng dp lh kq nh ni ll kr nj nk lp ks nl nm lt nn bi translated">2.无法访问效果内部的值</h2><p id="1760" class="pw-post-body-paragraph jq jr iq jt b ju lv jw jx jy lw ka kb kq lx ke kf kr ly ki kj ks lz km kn ko ij bi translated">以这个丹的微博为例</p><figure class="mo mp mq mr gt ms"><div class="bz fp l di"><div class="nr mu l"/></div></figure><p id="c686" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">假设我们定义了一个新的变量<code class="fe kt ku kv kw b">count</code>，并希望在每一个节拍中增加它。</p><figure class="mo mp mq mr gt ms"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="39d1" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">这意味着如果我们想使用<code class="fe kt ku kv kw b">useEvent</code>，我们需要放弃JavaScript闭包的好处！<code class="fe kt ku kv kw b">useEvent</code>迫使我们跳出当前闭包，进入由<code class="fe kt ku kv kw b">useEvent</code>包装的组件级回调。</p><h2 id="3cb6" class="nc ky iq bd kz nd ne dn ld nf ng dp lh kq nh ni ll kr nj nk lp ks nl nm lt nn bi translated">3.总是不能得到新的值</h2><figure class="mo mp mq mr gt ms"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="0d59" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">这是一个非常严重的陷阱。在await或异步回调之后，很容易意识不到一些值不再新鲜。<br/>这在RFC的<a class="ae kp" href="https://github.com/reactjs/rfcs/blob/useevent/text/0000-useevent.md#drawbacks" rel="noopener ugc nofollow" target="_blank">缺点</a>部分有所说明:</p><blockquote class="jn jo jp"><p id="bc48" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">你不会得到真正“活”的绑定。</p></blockquote><p id="4270" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">定义一个新的回调<code class="fe kt ku kv kw b">onChecked</code>对我来说看起来更糟。</p><figure class="mo mp mq mr gt ms"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="345f" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">我个人不喜欢上面的代码。它失去了使用async/await语法的意义。</p><h1 id="4245" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">更好的解决方案</h1><p id="6c13" class="pw-post-body-paragraph jq jr iq jt b ju lv jw jx jy lw ka kb kq lx ke kf kr ly ki kj ks lz km kn ko ij bi translated">试试这个包<a class="ae kp" href="https://github.com/oney/react-better-effect" rel="noopener ugc nofollow" target="_blank">效果更好</a></p><figure class="mo mp mq mr gt ms"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="b35f" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">将<code class="fe kt ku kv kw b">{theme}</code>注入到<code class="fe kt ku kv kw b">react-better-effect</code>的<code class="fe kt ku kv kw b">useEffect</code>，然后通过效果中的<code class="fe kt ku kv kw b">$.theme</code>得到主题。</p><p id="01ad" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">优点:</p><h2 id="59b8" class="nc ky iq bd kz nd ne dn ld nf ng dp lh kq nh ni ll kr nj nk lp ks nl nm lt nn bi translated">1.不需要在效果之外定义新的回调</h2><figure class="mo mp mq mr gt ms"><div class="bz fp l di"><div class="mt mu l"/></div></figure><h2 id="3877" class="nc ky iq bd kz nd ne dn ld nf ng dp lh kq nh ni ll kr nj nk lp ks nl nm lt nn bi translated">2.可以通过停留在当前闭包中来访问值</h2><figure class="mo mp mq mr gt ms"><div class="bz fp l di"><div class="mt mu l"/></div></figure><h2 id="4551" class="nc ky iq bd kz nd ne dn ld nf ng dp lh kq nh ni ll kr nj nk lp ks nl nm lt nn bi translated">3.总是异步获取新值</h2><figure class="mo mp mq mr gt ms"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="771d" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">永远不要担心价值观过时。</p><h2 id="a370" class="nc ky iq bd kz nd ne dn ld nf ng dp lh kq nh ni ll kr nj nk lp ks nl nm lt nn bi translated">简短的</h2><p id="3e54" class="pw-post-body-paragraph jq jr iq jt b ju lv jw jx jy lw ka kb kq lx ke kf kr ly ki kj ks lz km kn ko ij bi translated">在我看来，使用<code class="fe kt ku kv kw b">useEvent</code>来确保新值有点<strong class="jt ir">反模式</strong>会导致太多问题。</p><h1 id="10d9" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">摘要</h1><p id="fbb1" class="pw-post-body-paragraph jq jr iq jt b ju lv jw jx jy lw ka kb kq lx ke kf kr ly ki kj ks lz km kn ko ij bi translated"><code class="fe kt ku kv kw b">useEvent</code>可以解决React中回调的部分问题，但仍有一些问题没有解决，会导致陷阱。我可以想象<code class="fe kt ku kv kw b">useEvent</code>会导致很多不必要的重构，比如将<code class="fe kt ku kv kw b">useEvent</code>的事件处理闭包和效果闭包移到组件级。它使代码更加丑陋，但仍然不能修复回调的所有问题。</p><p id="7c42" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated"><code class="fe kt ku kv kw b">withStable</code> HOC真的可以解决“<a class="ae kp" href="https://github.com/reactjs/rfcs/blob/useevent/text/0000-useevent.md#drawbacks" rel="noopener ugc nofollow" target="_blank">应该到处用</a> <code class="fe kt ku kv kw b"><a class="ae kp" href="https://github.com/reactjs/rfcs/blob/useevent/text/0000-useevent.md#drawbacks" rel="noopener ugc nofollow" target="_blank">useCallback</a></code> <a class="ae kp" href="https://github.com/reactjs/rfcs/blob/useevent/text/0000-useevent.md#drawbacks" rel="noopener ugc nofollow" target="_blank">吗？</a>“困惑。以我最粗略的估计，React应用中90%的回调都是事件回调。如果使用<code class="fe kt ku kv kw b">withStable</code>，我们可以减少90%的<code class="fe kt ku kv kw b">useEvent</code>甚至<code class="fe kt ku kv kw b">useCallback</code>的使用。</p><p id="3681" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">即使当<a class="ae kp" href="https://www.youtube.com/watch?v=lGEMwh32soc" rel="noopener ugc nofollow" target="_blank"> React Forget </a>退出并自动包装回调，但<strong class="jt ir">仍然无法区分</strong>回调是渲染回调还是事件回调。这意味着开发人员必须<strong class="jt ir">显式地注释</strong>一个关于渲染或事件的回调。</p><p id="2c07" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">我个人推荐React核心应该包括来自<a class="ae kp" href="https://github.com/oney/react-with-stable" rel="noopener ugc nofollow" target="_blank"> react-with-stable </a>的<code class="fe kt ku kv kw b">withStable</code> <em class="js"> </em> HOC(合并到<code class="fe kt ku kv kw b">React.memo</code>)和来自<a class="ae kp" href="https://github.com/oney/react-better-effect" rel="noopener ugc nofollow" target="_blank"> react-better-effect </a>的更好的<code class="fe kt ku kv kw b">useEffect</code>。它们更优雅、更有力地解决了回调问题。</p><p id="05ac" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi">— — — — — — — — — — — — — — — — — — — — — — — — —</p><h1 id="4d4c" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">附录</h1><p id="eb44" class="pw-post-body-paragraph jq jr iq jt b ju lv jw jx jy lw ka kb kq lx ke kf kr ly ki kj ks lz km kn ko ij bi translated"><a class="ae kp" href="https://github.com/oney/react-with-stable" rel="noopener ugc nofollow" target="_blank"> react-with-stable </a>和<a class="ae kp" href="https://github.com/oney/react-better-effect" rel="noopener ugc nofollow" target="_blank"> react-better-effect </a>的核心思想是:<br/>让回调<strong class="jt ir">用户/消费者/使用站点</strong>决定他们想要如何使用回调。</p><p id="decc" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">这个想法在RFC  : <code class="fe kt ku kv kw b">Wrapping events at the usage site</code>中也有<a class="ae kp" href="https://github.com/reactjs/rfcs/blob/useevent/text/0000-useevent.md#wrapping-events-at-the-usage-site" rel="noopener ugc nofollow" target="_blank">的介绍，但是<code class="fe kt ku kv kw b">useEvent</code>只能为<code class="fe kt ku kv kw b">useEffect</code>做，不能在传递回调道具给组件的时候做。</a></p><p id="55ea" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">举个例子，</p><figure class="mo mp mq mr gt ms"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="3689" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">对于<code class="fe kt ku kv kw b">useSyncTitle</code>，<code class="fe kt ku kv kw b">format</code>应根据效果而定。<br/>对于<code class="fe kt ku kv kw b">useShowRating</code>，<code class="fe kt ku kv kw b">format</code>应该不在效果之内。<br/>对于<code class="fe kt ku kv kw b">Movie</code>，<code class="fe kt ku kv kw b">format</code>应该不是稳定回调。<br/>为<code class="fe kt ku kv kw b">Like</code>，<code class="fe kt ku kv kw b">format</code>可以稳定回调。</p><p id="13dd" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">使用<a class="ae kp" href="https://github.com/oney/react-with-stable" rel="noopener ugc nofollow" target="_blank">稳效</a>和<a class="ae kp" href="https://github.com/oney/react-better-effect" rel="noopener ugc nofollow" target="_blank">稳效</a>:</p><figure class="mo mp mq mr gt ms"><div class="bz fp l di"><div class="mt mu l"/></div></figure><h1 id="2066" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">总是包装回调</h1><p id="91f6" class="pw-post-body-paragraph jq jr iq jt b ju lv jw jx jy lw ka kb kq lx ke kf kr ly ki kj ks lz km kn ko ij bi translated">我支持总是用<code class="fe kt ku kv kw b">useCallback</code>包装一个回调，不管它是事件处理程序还是渲染或特效的派生回调。</p><p id="d467" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated"><code class="fe kt ku kv kw b">useCallback</code>是<code class="fe kt ku kv kw b">useMemo</code>的快捷方式。<a class="ae kp" href="https://reactjs.org/docs/hooks-reference.html#usememo" rel="noopener ugc nofollow" target="_blank">文档</a>描述<code class="fe kt ku kv kw b">useMemo</code>为:</p><blockquote class="jn jo jp"><p id="ed98" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">这种优化有助于避免每次渲染时进行昂贵的计算。</p></blockquote><p id="b92a" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">但是<code class="fe kt ku kv kw b">useMemo</code>不仅仅是为了避免计算昂贵的值，也是为了记忆相同的<strong class="jt ir">非原语</strong>值(即JavaScript <code class="fe kt ku kv kw b">object</code>和<code class="fe kt ku kv kw b">function</code>)以避免<strong class="jt ir">不必要的重新渲染和效果重新触发</strong>。</p><p id="ac6d" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">这是因为如果我们不为<code class="fe kt ku kv kw b">object</code>或<code class="fe kt ku kv kw b">function</code>设置<code class="fe kt ku kv kw b">useMemo</code>或<code class="fe kt ku kv kw b">useCallback</code>，即使新旧值实际上没有区别，在比较时也会被认为是不同的(即<code class="fe kt ku kv kw b">Object.is</code>或<code class="fe kt ku kv kw b">===</code>)。</p><h1 id="e0da" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">归类回电</h1><p id="6f81" class="pw-post-body-paragraph jq jr iq jt b ju lv jw jx jy lw ka kb kq lx ke kf kr ly ki kj ks lz km kn ko ij bi translated">不要将回调分为<code class="fe kt ku kv kw b">event handlers</code>或<code class="fe kt ku kv kw b">non event handlers</code>。</p><p id="c447" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb kq kd ke kf kr kh ki kj ks kl km kn ko ij bi translated">将回调分为<code class="fe kt ku kv kw b">reactive</code>或<code class="fe kt ku kv kw b">unreactive</code>。</p><h2 id="b1d8" class="nc ky iq bd kz nd ne dn ld nf ng dp lh kq nh ni ll kr nj nk lp ks nl nm lt nn bi translated">对于接受回调属性的组件:</h2><ol class=""><li id="478f" class="ma mb iq jt b ju lv jy lw kq no kr np ks nq ko mf mg mh mi bi translated">如果回调在<strong class="jt ir">渲染</strong>中使用，组件希望它成为<strong class="jt ir">反应</strong>。</li><li id="ba88" class="ma mb iq jt b ju mj jy mk kq ml kr mm ks mn ko mf mg mh mi bi translated">如果它在<strong class="jt ir">事件处理程序</strong>中被使用，组件希望它成为<strong class="jt ir">无效</strong>。</li></ol><h2 id="6d2d" class="nc ky iq bd kz nd ne dn ld nf ng dp lh kq nh ni ll kr nj nk lp ks nl nm lt nn bi translated">使用效果:</h2><ol class=""><li id="e92f" class="ma mb iq jt b ju lv jy lw kq no kr np ks nq ko mf mg mh mi bi translated">如果回调应该触发效果，应该是<strong class="jt ir">反应式</strong>。</li><li id="624c" class="ma mb iq jt b ju mj jy mk kq ml kr mm ks mn ko mf mg mh mi bi translated">如果没有，应该是<strong class="jt ir">未反应</strong>。(异步获取新值是另一个需要解决的问题)</li></ol></div></div>    
</body>
</html>