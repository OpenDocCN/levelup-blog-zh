<html>
<head>
<title>Preserving the programmers ‘Intent’ in Unsafe Rust</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在不安全的Rust中保护程序员的“意图”</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/preserving-the-programmers-intent-in-unsafe-rust-beaa3266f43f?source=collection_archive---------8-----------------------#2020-11-25">https://levelup.gitconnected.com/preserving-the-programmers-intent-in-unsafe-rust-beaa3266f43f?source=collection_archive---------8-----------------------#2020-11-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="57f9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">几周前，我碰巧重访了我的一个“Rust”项目——一个准系统嵌入式引导加载程序，希望能够重用和扩展它。我选择‘rust-lang’(而不是C)来编写一个专注于安全的‘cortex-m’引导加载程序，这样我就可以利用rust的内存安全属性(其他考虑因素如大小和性能相同)。</p><p id="78e7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我对引导加载程序的要求如下——引导系统，与硬件信任根接口，使用ECC验证签名的引导映像，并执行“下载的软件升级”(或DSU)。</p><p id="4b07" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">乍一看，这似乎相对简单，因为我已经有了一个概念验证，但很快就意识到这里有很多出错的地方。举个例子，下面的代码片段，它是我最初的PoC的一小部分，当提供了应用程序的起始地址时，它控制从引导装载程序到应用程序映像的执行流。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/477f3aa4e9be607f2a8e7552b35ff2d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h1dJPUrzj4odd6BXPsIJZg.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">ARM Cortex-M系统的基本启动跳跃序列。</figcaption></figure><p id="d0b0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在测试的时候，我没有太注意它，但是这个实现<strong class="jp ir">可以</strong>做我不打算让它做的事情。</p><ol class=""><li id="6f9a" class="lb lc iq jp b jq jr ju jv jy ld kc le kg lf kk lg lh li lj bi translated">解引用2个原始指针，即<code class="fe lk ll lm ln b">stack_pointer </code>和<code class="fe lk ll lm ln b">reset_vector</code>可能导致未定义的行为(即解引用可能产生任何值)。</li><li id="35fa" class="lb lc iq jp b jq lo ju lp jy lq kc lr kg ls kk lg lh li lj bi translated">如果我们传入一个无效的值，那么32位整数到<code class="fe lk ll lm ln b">extern C fn() </code>类型的转换也是未定义的。</li><li id="0a68" class="lb lc iq jp b jq lo ju lp jy lq kc lr kg ls kk lg lh li lj bi translated">2寄存器写操作有明显的副作用<strong class="jp ir">如果你传入一个无效的、空的或者其他疯狂的值</strong>是未定义的。</li><li id="79a3" class="lb lc iq jp b jq lo ju lp jy lq kc lr kg ls kk lg lh li lj bi translated">以及一个变形的函数调用— <code class="fe lk ll lm ln b">jump_vector()</code>，它实际上是发散的(即从不返回)，但在其函数签名中没有明确这样说。</li></ol><p id="e8d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以上大部分可能看起来像是使用“不安全铁锈”的后果。这在一定程度上是正确的，但在大多数情况下，你无法避免这一点，因为没有办法让代码安全地改变硬件，也就是说，代码无法判断读/写等硬件操作实际上是否安全。</p><blockquote class="lt lu lv"><p id="7e96" class="jn jo lw jp b jq jr js jt ju jv jw jx lx jz ka kb ly kd ke kf lz kh ki kj kk ij bi translated">还需要注意的是——在Rust中，所有未定义的行为都被<a class="ae ma" href="https://doc.rust-lang.org/1.18.0/nomicon/meet-safe-and-unsafe.html" rel="noopener ugc nofollow" target="_blank">限制在范围内，并且可以被限制在“不安全的Rust”中</a>,这是一件好事。</p></blockquote><p id="7de4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，尽管上面的代码片段在一组测试运行中工作正常，但我实际上不能声称或提供关于实现的保证，因为它涉及到安全性。换句话说，这段代码可能适用于也可能不适用于每次引导调用。</p><blockquote class="mb"><p id="0703" class="mc md iq bd me mf mg mh mi mj mk kk dk translated">*我最初的(假设很简单)目标是扩展引导装载程序。</p></blockquote></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><p id="fc7c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么，我们如何确保我们不会在运行时出现未定义的行为。ARM Cortex-M有一个平面内存(即无虚拟寻址)模型，你必须通过一个<code class="fe lk ll lm ln b">memory.x </code>文件明确说明你的程序的内存布局。我们可以利用我们对ARM Cortex-M系统的内存布局的了解来<strong class="jp ir">定义一个规范</strong>，并让我们的实现遵守该规范。</p><p id="d1c8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，我们可以在每个2 derefs后面添加一些防御检查，比如assert语句，来检查边界，但是一个更好的解决方案(在我看来)是<strong class="jp ir">让你的类型来做‘检查’</strong>。</p><ul class=""><li id="81d1" class="lb lc iq jp b jq jr ju jv jy ld kc le kg lf kk ms lh li lj bi translated">对于堆栈指针——我们可以使用rust的<code class="fe lk ll lm ln b">const_generics</code>特性构建一个名为‘RefinedUsize’的类型，并在运行时应用边界检查。在某种程度上，这是一个精化类型的例子(即带有谓词的类型)。</li></ul><blockquote class="lt lu lv"><p id="eed1" class="jn jo lw jp b jq jr js jt ju jv jw jx lx jz ka kb ly kd ke kf lz kh ki kj kk ij bi translated">如果我们有办法在rust代码中访问链接器脚本值，这可能会更好，这意味着我们可以避免使用具体的界限或值。在撰写本文时，我还不知道这样做的选择。</p><p id="c7e7" class="jn jo lw jp b jq jr js jt ju jv jw jx lx jz ka kb ly kd ke kf lz kh ki kj kk ij bi translated">此外，在这个特定的例子中，我们假设RAM大小为256KB(零大小。数据，。bss部分+无堆),我们使用<a class="ae ma" href="https://github.com/knurling-rs/flip-link" rel="noopener ugc nofollow" target="_blank">翻转链接</a>来避免堆栈溢出。</p></blockquote><ul class=""><li id="7cec" class="lb lc iq jp b jq jr ju jv jy ld kc le kg lf kk ms lh li lj bi translated">对于重置向量RefinedUsize可以将u32细化为单值u32。</li><li id="9e1c" class="lb lc iq jp b jq lo ju lp jy lq kc lr kg ls kk ms lh li lj bi translated">将<code class="fe lk ll lm ln b">integer type </code>的可能输入限制为单个不可空值，并对其进行转化是安全的，即<code class="fe lk ll lm ln b">reset_vector</code>是一个u32，它只能有一个可能值。Rust的固有函数— <code class="fe lk ll lm ln b">transmute()</code>现在可以将一个不可空的、大小合适的、正确对齐的u32转换成一个函数指针。</li><li id="53ee" class="lb lc iq jp b jq lo ju lp jy lq kc lr kg ls kk ms lh li lj bi translated">在两次易失性(寄存器)写操作之前添加数据和指令同步屏障，以确保没有可能干扰我们寄存器写操作的未决存储器访问或指令。</li></ul><blockquote class="lt lu lv"><p id="d6f1" class="jn jo lw jp b jq jr js jt ju jv jw jx lx jz ka kb ly kd ke kf lz kh ki kj kk ij bi translated">注意——这仍然不意味着您的易失性写操作一定会成功。但是现在，我们可以说它不是未定义的行为，如果它没有成功的话。</p></blockquote><ul class=""><li id="b02d" class="lb lc iq jp b jq jr ju jv jy ld kc le kg lf kk ms lh li lj bi translated">最后，更改<code class="fe lk ll lm ln b">jump_vector()</code>和<code class="fe lk ll lm ln b">boot_from()</code>的类型签名以反映分歧，这意味着它决不能返回(但可能会由于一些硬件寄存器写错误而死机),如果它确实返回了，那么我们就知道出错了。(即未定义的行为)</li></ul><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mt"><img src="../Images/ef855466d911d37a2e9fa3972ed53a21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hws2IZZlKtXcOUNKsSxBlg.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">使用Rust的const_generics特性重构impl，使我们的类型更加精确。</figcaption></figure><p id="0474" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，这个<code class="fe lk ll lm ln b">implementation </code>比最初的PoC好得多，或者至少它给了我更高程度的信心，我的代码将坚持我的规范(以类型细化的形式提供)。</p><p id="06e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们仍然不能断言这种类型丰富的实现保证(或实际的数学证明)在上面的代码片段中没有未定义的行为。为了这种保证，我们需要以完全的功能正确性为目标，这只能通过“形式方法”来实现。</p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><p id="ec27" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">是一个巨大的领域。这实际上有点疯狂，所以<strong class="jp ir"> <em class="lw">这是从一个程序员的角度总结的图片</em> </strong>。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mu"><img src="../Images/4b4915dcefc4400fcfbe9dfc09da6ed9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E51JVklZl4zfkieqgjR0RA.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">从程序员的角度看形式方法世界的20k英尺视图。</figcaption></figure><h2 id="0ab6" class="mv mw iq bd mx my mz dn na nb nc dp nd jy ne nf ng kc nh ni nj kg nk nl nm nn bi translated"><strong class="ak">简而言之，正式方法允许你指定属性，并通过以下方式验证其一致性:</strong></h2><ul class=""><li id="2fcb" class="lb lc iq jp b jq no ju np jy nq kc nr kg ns kk ms lh li lj bi translated"><strong class="jp ir">丰富类型— </strong>例如，细化/约束传递给函数<strong class="jp ir"> </strong>和<strong class="jp ir"> </strong>的参数类型，让自动定理证明器解决所有约束——与我们上面所做的很相似，不同之处在于自动定理证明器生成的证明在所有可能的条件下(即前置、后置条件和所有不变量)都成立。</li><li id="fe85" class="lb lc iq jp b jq lo ju lp jy lq kc lr kg ls kk ms lh li lj bi translated"><strong class="jp ir">或者为你的函数写一个单独的证明(正式术语是引理)</strong>使用类似证明助手的工具，在那里你陈述属性并为它建立一个证明。</li></ul><p id="f72f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种属性的一个例子是—</p><p id="02f4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lk ll lm ln b"><strong class="jp ir">(append (append xs ys) zs == append xs (append ys zs))</strong></code></p><p id="6623" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">其中<code class="fe lk ll lm ln b">append</code>是一个附加2个列表的函数，<code class="fe lk ll lm ln b">xs, yz, sz</code>是任何类型的列表。该属性必须对所有列表始终有效(永久有效:)。这个属性的证明非常简单，但是有了证明助手，你可以利用更多奇特的类型，比如<em class="lw">依赖类型、高阶逻辑、归纳证明</em>等等。来解决更棘手的问题。</p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="9788" class="nt mw iq bd mx nu nv nw na nx ny nz nd oa ob oc ng od oe of nj og oh oi nm oj bi translated">愿望清单和结论:</h1><ul class=""><li id="b5b1" class="lb lc iq jp b jq no ju np jy nq kc nr kg ns kk ms lh li lj bi translated">我认为扩展Rust的类型系统，使之更容易用更好看的语法精炼原始类型(如int，char，bool)——就像<code class="fe lk ll lm ln b">x: int { x &gt; 0 } ,</code>而不是让开发者/库来做这项工作，将是const_generics稳定化后合乎逻辑的下一步。</li></ul><blockquote class="lt lu lv"><p id="2c48" class="jn jo lw jp b jq jr js jt ju jv jw jx lx jz ka kb ly kd ke kf lz kh ki kj kk ij bi translated">更棒的是rust-analyzer可以显示VSCode中的改进。</p></blockquote><ul class=""><li id="7980" class="lb lc iq jp b jq jr ju jv jy ld kc le kg lf kk ms lh li lj bi translated">一个支持<code class="fe lk ll lm ln b"><em class="lw">pre + post conditions, invariants and variants</em></code>的静态rust验证器将会是一个天赐之物，它可以安全和不安全的Rust一起工作。事实上，Rust可能已经在朝着这个目标前进了；我们有几个人正致力于将自动推理能力引入Rust。这里有两个。</li></ul><blockquote class="lt lu lv"><p id="cc11" class="jn jo lw jp b jq jr js jt ju jv jw jx lx jz ka kb ly kd ke kf lz kh ki kj kk ij bi translated"><a class="ae ma" href="https://crux.galois.com/" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">【Crux-mir</strong></a>:我们可以执行基于属性的测试，使用符号模拟对给定函数的所有可能输入进行详尽的测试。</p><p id="7cd3" class="jn jo lw jp b jq jr js jt ju jv jw jx lx jz ka kb ly kd ke kf lz kh ki kj kk ij bi translated">Haybale<a class="ae ma" href="https://github.com/PLSysSec/haybale" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir"/></a>:这在底层技术方面是相似的，但是它使用符号执行来帮助你推理Rust代码。</p></blockquote><ul class=""><li id="7c50" class="lb lc iq jp b jq jr ju jv jy ld kc le kg lf kk ms lh li lj bi translated">我计划在另一篇文章中探讨这两个问题。严格来说，这两者并不完全属于<code class="fe lk ll lm ln b">formal verification</code>的范畴。我们可以把它们看作是<code class="fe lk ll lm ln b">testing on steroids</code>的一种形式。它们可以用来彻底地探索一个程序的状态空间，也就是说，你可以彻底地测试你的代码是否有错误。然而，<code class="fe lk ll lm ln b"><em class="lw">“testing can only find bugs, not prove their absence”</em></code>、<em class="lw">、</em>这就是形式验证的用武之地；它提供了实际证据。</li></ul><p id="0c8e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">总之，就学习而言，整个练习是非常有益的，我学到了一些经验和技术，以帮助我在更深的层次上“推理代码”，并回答了关于如何保持我(即程序员)的“意图”的问题，这样它就不会被各种各样的实现级别的细节所削弱。例如，从最基本的问题开始总是好的—</p><blockquote class="lt lu lv"><p id="16c1" class="jn jo lw jp b jq jr js jt ju jv jw jx lx jz ka kb ly kd ke kf lz kh ki kj kk ij bi translated">我的代码到底有多安全？</p><p id="0622" class="jn jo lw jp b jq jr js jt ju jv jw jx lx jz ka kb ly kd ke kf lz kh ki kj kk ij bi translated">我可以或应该提出什么主张？</p><p id="e888" class="jn jo lw jp b jq jr js jt ju jv jw jx lx jz ka kb ly kd ke kf lz kh ki kj kk ij bi translated">我能提供什么保证？</p></blockquote><p id="ec8f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这将允许您清楚地陈述关于您的代码的简单属性，这些属性可以相对容易地被证明(使用自动证明程序)，然后通过组合的力量，您可以将所有这些属性(和证明)链接起来，从而使您能够做出不可辩驳的(即数学上可证明的)声明。</p><p id="fd18" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">也许，我可以在我的下一篇文章中展示一个更具体的例子，在那里我重写了一个AES crypto impl，以匹配在<a class="ae ma" href="https://cryptol.net/" rel="noopener ugc nofollow" target="_blank"> Cryptol </a>中实现的一个，Cryptol 是一种用于指定和验证加密算法的领域特定语言。</p></div></div>    
</body>
</html>