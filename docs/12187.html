<html>
<head>
<title>How to Test Chart.js in an Angular Component</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在角度组件中测试Chart.js</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-test-chart-js-in-an-angular-component-d21d41e24c07?source=collection_archive---------3-----------------------#2022-05-22">https://levelup.gitconnected.com/how-to-test-chart-js-in-an-angular-component-d21d41e24c07?source=collection_archive---------3-----------------------#2022-05-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="1927" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一步一步的指南。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/ed11b566652fa5363e67c3ec29a9f85b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xLgylovhFCjg1Z-JJanmYg.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">角度+ Chart.js</figcaption></figure><h1 id="f87d" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">有什么问题？</h1><p id="b247" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">当使用<a class="ae mh" href="https://www.npmjs.com/package/chart.js?activeTab=readme" rel="noopener ugc nofollow" target="_blank"> chart.js </a>时，我们需要实例化一个<code class="fe mi mj mk ml b">Chart</code>实例，就像这个<code class="fe mi mj mk ml b">this.chart = new Chart(ctx, options)</code>。我们不能测试它！</p><p id="b6af" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为什么？让我们看看组件是什么样子，并回顾一下哪些可以测试，哪些不可以:</p><h1 id="8607" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">组件(v1)</h1><p id="18bd" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">我们将使用的组件如下所示:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">实例化图表的组件</figcaption></figure><ul class=""><li id="1169" class="mo mp it js b jt ju jx jy kb mq kf mr kj ms kn mt mu mv mw bi translated">它通过一个<code class="fe mi mj mk ml b">@ViewChild</code>查询在一个<code class="fe mi mj mk ml b">ElementRef</code>中捕获一个<code class="fe mi mj mk ml b">Canvas</code>。</li><li id="f0ea" class="mo mp it js b jt mx jx my kb mz kf na kj nb kn mt mu mv mw bi translated">它需要并依赖于<code class="fe mi mj mk ml b">Router</code>的一个实例。</li><li id="6249" class="mo mp it js b jt mx jx my kb mz kf na kj nb kn mt mu mv mw bi translated">它使用<code class="fe mi mj mk ml b">canvas</code>和线形图的特定配置创建了一个<code class="fe mi mj mk ml b">Chart</code>。</li><li id="95e1" class="mo mp it js b jt mx jx my kb mz kf na kj nb kn mt mu mv mw bi translated">它通过导航到图表点的详细信息页面来处理该点上的<code class="fe mi mj mk ml b">click</code>事件。</li></ul><p id="62b1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">好吧，这行得通，但是我们能写什么样的测试来反对它呢？</p><p id="ef64" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可以检查<code class="fe mi mj mk ml b">chart</code>常量是否被实际填充，类型是否为<code class="fe mi mj mk ml b">Chart</code>。<strong class="js iu">那就是</strong>漂亮得多的<strong class="js iu">它</strong>。但是如果我们有一些相关的功能，比如当用户点击图表中的一个点时做一些有趣的事情，实际上我们可以测试的并不多:</p><ul class=""><li id="630e" class="mo mp it js b jt ju jx jy kb mq kf mr kj ms kn mt mu mv mw bi translated">我们无法验证<code class="fe mi mj mk ml b">ctx</code>和<code class="fe mi mj mk ml b">options</code>是否是我们期望的那样。</li><li id="e17f" class="mo mp it js b jt mx jx my kb mz kf na kj nb kn mt mu mv mw bi translated">我们无法验证图表事件的回调行为是否如我们所愿。</li></ul><h1 id="ec41" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">解决办法</h1><p id="ac70" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">我们看到，如果我们依赖代码中的构造函数，就不可能编写测试。我们需要的是一个中间的东西，它将为我们调用<code class="fe mi mj mk ml b">Chart.js</code>构造函数，并且我们可以为测试交换一个模拟版本。它看起来是这样的:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">提供(第12行)和输入(第21行)并使用(第25行)图表生成器的组件</figcaption></figure><p id="1607" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">顶部是我们的<code class="fe mi mj mk ml b">chartBuilder</code>,它将为我们构建图表:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="146d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它接受一个<code class="fe mi mj mk ml b">ChartItem</code>(例如一个<code class="fe mi mj mk ml b">canvas</code> HTML元素)和<code class="fe mi mj mk ml b">ChartConfiguration</code>，并返回一个<code class="fe mi mj mk ml b">Chart</code>的实例。</p><p id="ec1a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后我们有了我们的注入令牌，我们将把它交给Angular，让它知道我们想要这个<code class="fe mi mj mk ml b">chartBuilder</code>。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="d647" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">作为<code class="fe mi mj mk ml b">Component</code> -s提供者的一部分，我们“提供”构建者，基本上是说:“嘿，Angular，当我给你这个令牌<code class="fe mi mj mk ml b">ChartBuilderToken</code>的时候，给我这个函数<code class="fe mi mj mk ml b">chartBuilder</code>”:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="2f0e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，作为<code class="fe mi mj mk ml b">Component</code>构造者的一部分，我们要求<code class="fe mi mj mk ml b">ChartBuilderToken</code>，Angular愉快地答应并给了我们上面提供的东西:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="208d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里我们使用了<code class="fe mi mj mk ml b">typeof chartBuilder</code>来避免挖掘<code class="fe mi mj mk ml b">Chart.js</code>类型并定义它需要什么类型和返回什么类型。基本上，我们已经告诉<code class="fe mi mj mk ml b">TypeScript</code>——“你知道类型，这里是一样的，所以使用它！”。</p><p id="c38a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，在组件生命周期的适当时刻，当<code class="fe mi mj mk ml b">@ViewChild</code> <code class="fe mi mj mk ml b">this.canvas</code>将被填充时，我们调用图表构造函数，瞧，我们有了图表的实例:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mm mn l"/></div></figure><h1 id="27a5" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">测试:验证图表已构建</h1><p id="d195" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">当测试组件时，我们可以用一个<code class="fe mi mj mk ml b">chartBuilder spy</code>代替图表生成器，它的输入和输出可以被控制、检查或模拟。</p><p id="ebd6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们从简单的例子开始——验证图表是否存在</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="7875" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="nc">完整代码参见</em> <a class="ae mh" href="https://stackblitz.com/edit/test-chart-js-dependent-component-v1?file=src%2Fapp%2Fchart.component.spec.ts" rel="noopener ugc nofollow" target="_blank"> <em class="nc">图表js测试v1 </em> </a> <em class="nc">。</em></p><p id="73b6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是一个<code class="fe mi mj mk ml b">it</code>测试用例，是<a class="ae mh" href="https://jasmine.github.io" rel="noopener ugc nofollow" target="_blank">茉莉</a>、<a class="ae mh" href="https://jestjs.io" rel="noopener ugc nofollow" target="_blank"> Jest </a>和<a class="ae mh" href="https://mochajs.org" rel="noopener ugc nofollow" target="_blank">摩卡</a>测试跑步者的标准。具体部分是:</p><p id="f404" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">用<code class="fe mi mj mk ml b">mockRouter</code>函数模仿Angular的<code class="fe mi mj mk ml b">Router</code>实例:<code class="fe mi mj mk ml b">const r = mockRouter();</code></p><p id="938c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="nc">更多关于这是如何设置在文章的最后。</em></p><p id="d225" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过使用返回模拟函数的<code class="fe mi mj mk ml b">Jasmine</code> -s <code class="fe mi mj mk ml b">createSpy</code>函数来模拟图表生成器。我们可以控制它返回什么。在这种情况下，我们只是告诉它返回一个字符串值<code class="fe mi mj mk ml b">'the chart'</code>，因为对于这个特定的测试用例，我们并不真正需要更多:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mm mn l"/></div></figure><ul class=""><li id="7ed9" class="mo mp it js b jt ju jx jy kb mq kf mr kj ms kn mt mu mv mw bi translated">创造一个间谍</li><li id="a494" class="mo mp it js b jt mx jx my kb mz kf na kj nb kn mt mu mv mw bi translated">告诉它要返回什么</li><li id="4418" class="mo mp it js b jt mx jx my kb mz kf na kj nb kn mt mu mv mw bi translated">用<code class="fe mi mj mk ml b">builderSpy</code>(和模拟路由器<code class="fe mi mj mk ml b">r</code>)构建<code class="fe mi mj mk ml b">ChartComponent</code></li></ul><p id="c46e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过以下方式模仿一个<a class="ae mh" href="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API" rel="noopener ugc nofollow" target="_blank"> HTML画布</a>元素:</p><ul class=""><li id="3924" class="mo mp it js b jt ju jx jy kb mq kf mr kj ms kn mt mu mv mw bi translated"><code class="fe mi mj mk ml b">document.createElement('canvas');</code></li><li id="6334" class="mo mp it js b jt mx jx my kb mz kf na kj nb kn mt mu mv mw bi translated">这是由<code class="fe mi mj mk ml b">document</code>提供的<code class="fe mi mj mk ml b">Canvas</code>元素的普通实例，就像在real* app中一样。</li><li id="f44e" class="mo mp it js b jt mx jx my kb mz kf na kj nb kn mt mu mv mw bi translated"><em class="nc">*注意，一些框架(如</em><a class="ae mh" href="https://jestjs.io" rel="noopener ugc nofollow" target="_blank"><em class="nc">Jest</em></a><em class="nc">)嘲笑DOM和</em> <code class="fe mi mj mk ml b"><em class="nc">document</em></code> <em class="nc">对象是假的。</em></li></ul><p id="5085" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">向组件提供一个<code class="fe mi mj mk ml b">ElementRef</code>来填充<code class="fe mi mj mk ml b">@ViewChild('canvas') canvas: ElementRef;</code>。当应用程序运行时，Angular通过查询视图来提供，这是将模板应用于DOM的结果。</p><ul class=""><li id="d19b" class="mo mp it js b jt ju jx jy kb mq kf mr kj ms kn mt mu mv mw bi translated"><code class="fe mi mj mk ml b">c.canvas = new ElementRef(document.createElement('canvas'));</code></li><li id="621a" class="mo mp it js b jt mx jx my kb mz kf na kj nb kn mt mu mv mw bi translated">有了所有的安排，我们现在可以安全地运行<code class="fe mi mj mk ml b">ngAfterViewInit()</code>。</li></ul><p id="4a7e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为什么是<code class="fe mi mj mk ml b">ngAfterViewInit</code>而不是<code class="fe mi mj mk ml b">ngOnInit</code>或者另一个钩子？<code class="fe mi mj mk ml b">@ViewChild</code>参考在<code class="fe mi mj mk ml b">ngAfterViewInit</code>之前解析，在<code class="fe mi mj mk ml b">ngOnInit</code>之后。因此<code class="fe mi mj mk ml b">ngOnInit</code>会在<code class="fe mi mj mk ml b">this.canvas</code>中看到<code class="fe mi mj mk ml b">undefined</code>，而<code class="fe mi mj mk ml b">ngAfterViewInit</code>会看到<code class="fe mi mj mk ml b">ElementRef</code>被解决。更多信息见<a class="ae mh" href="https://angular.io/api/core/ViewChild#description" rel="noopener ugc nofollow" target="_blank">角度文件</a>。</p><p id="5d19" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，我们可以检查是否使用正确的参数调用了图表构造函数:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="ff63" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里有很多内容，所以让我们一步一步来看:</p><ul class=""><li id="a3b8" class="mo mp it js b jt ju jx jy kb mq kf mr kj ms kn mt mu mv mw bi translated"><code class="fe mi mj mk ml b">expect(ch).toHaveBeenCalledOnceWith(...)</code> -确保该spy被调用一次，并使用特定的参数集。</li><li id="6b36" class="mo mp it js b jt mx jx my kb mz kf na kj nb kn mt mu mv mw bi translated">第一个参数是mock Canvas HTML ( <code class="fe mi mj mk ml b">canvas</code>)元素，我们只是确保它是逐字传递给<code class="fe mi mj mk ml b">Chart</code>构造函数的内容。</li><li id="50eb" class="mo mp it js b jt mx jx my kb mz kf na kj nb kn mt mu mv mw bi translated">第二个参数是<code class="fe mi mj mk ml b">Chart</code>期望的<a class="ae mh" href="https://www.chartjs.org/docs/latest/configuration/" rel="noopener ugc nofollow" target="_blank">配置对象</a></li><li id="5043" class="mo mp it js b jt mx jx my kb mz kf na kj nb kn mt mu mv mw bi translated">最后，我们验证图表现在已定义:</li><li id="75de" class="mo mp it js b jt mx jx my kb mz kf na kj nb kn mt mu mv mw bi translated"><code class="fe mi mj mk ml b">expect(c.chart).toBeDefined();</code></li></ul><h1 id="5050" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">测试:验证<code class="fe mi mj mk ml b">onClick</code>事件处理程序</h1><p id="be2e" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">在构造选项中，我们添加了一个事件侦听器，当用户单击图表中的某个点并将用户带到不同的页面时，它将会触发。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="cd51" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里面有一些逻辑，我们想测试一下！测试看起来是这样的:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="17eb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="nc">完整代码参见</em> <a class="ae mh" href="https://stackblitz.com/edit/test-chart-js-dependent-component-v2?file=src%2Fapp%2Fchart.component.spec.ts" rel="noopener ugc nofollow" target="_blank"> <em class="nc">图表js测试v2 </em> </a> <em class="nc">。</em></p><p id="c5f1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">循序渐进:</p><p id="0199" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们为<code class="fe mi mj mk ml b">Router</code>和<code class="fe mi mj mk ml b">ChartBuilder</code>依赖项创建一些模拟:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="f3ea" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们创建一个点击回调模拟(用一个空函数初始化):</p><ul class=""><li id="e190" class="mo mp it js b jt ju jx jy kb mq kf mr kj ms kn mt mu mv mw bi translated"><code class="fe mi mj mk ml b">let onClickCallback: Function = () =&gt; {};</code></li></ul><p id="1595" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们需要引用组件逻辑的这一部分:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="27cb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，以之前创建的<code class="fe mi mj mk ml b">ch</code> chart builder spy为例，我们指示它在被调用时调用一个函数。该功能在<code class="fe mi mj mk ml b">callFake</code>参数中指定。这将用一个函数替换默认的图表生成器(它返回一个<code class="fe mi mj mk ml b">new Chart(element, options)</code>)，该函数接受两个参数<code class="fe mi mj mk ml b">element</code>和<code class="fe mi mj mk ml b">options</code>，并将<code class="fe mi mj mk ml b">options.onClick</code>存储在<code class="fe mi mj mk ml b">onClickCallback</code>中。在看起来像这样的测试中:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="653c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在此之后，通过<code class="fe mi mj mk ml b">ngAfterViewInit</code>，我们将获得存储在<code class="fe mi mj mk ml b">onClickCallback</code>中的<code class="fe mi mj mk ml b">onClick</code>回调，我们可以调用它并验证结果:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="e11d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这证明了当使用非<code class="fe mi mj mk ml b">null</code>的元素调用<code class="fe mi mj mk ml b">onClick</code>时，我们将用户导航到相应的页面(根据来自<code class="fe mi mj mk ml b">element</code>的索引从<code class="fe mi mj mk ml b">data</code>数组中获取)</p><h1 id="fa0c" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">测试:使用模拟图表方法</h1><p id="862a" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">假设我们想在导航到某个点的细节之前知道它是否可见。很抱歉这个人为的例子，重点是展示如何模仿<code class="fe mi mj mk ml b">Chart</code>实例方法。</p><p id="6bd5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">方法<code class="fe mi mj mk ml b">getDataVisibility</code>提供了我们所需要的东西(参考<a class="ae mh" href="https://www.chartjs.org/docs/latest/api/classes/Chart.html#getdatavisibility" rel="noopener ugc nofollow" target="_blank">文档</a>):</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="2197" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">仅在点可见时导航。让我们测试一下这个逻辑:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="75fa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="nc">完整代码见</em> <a class="ae mh" href="https://stackblitz.com/edit/test-chart-js-dependent-component-v4?file=src%2Fapp%2Fchart.component.ts,src%2Fapp%2Fchart.component.spec.ts" rel="noopener ugc nofollow" target="_blank"> <em class="nc">图js测试v3 </em> </a>。</p><p id="e458" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">细目如下所示:</p><p id="2836" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">模仿路由器— <code class="fe mi mj mk ml b">r</code>。</p><p id="32c5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">模拟图表生成器— <code class="fe mi mj mk ml b">ch</code>。</p><p id="4cf3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当模仿图表构建器响应时，我们提供一个包含模仿<code class="fe mi mj mk ml b">getDataVisibility</code>方法的对象，它只返回<code class="fe mi mj mk ml b">false</code>:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="c97f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">其余的设置是相同的:</p><ul class=""><li id="cc1f" class="mo mp it js b jt ju jx jy kb mq kf mr kj ms kn mt mu mv mw bi translated">实例化组件。</li><li id="94a5" class="mo mp it js b jt mx jx my kb mz kf na kj nb kn mt mu mv mw bi translated">给它一个<code class="fe mi mj mk ml b">ElementRef&lt;Canvas&gt;</code>。</li><li id="565f" class="mo mp it js b jt mx jx my kb mz kf na kj nb kn mt mu mv mw bi translated">调用<code class="fe mi mj mk ml b">ngOnAfterViewInit</code>让它通过图表生成器构造<code class="fe mi mj mk ml b">Chart</code>。</li><li id="f351" class="mo mp it js b jt mx jx my kb mz kf na kj nb kn mt mu mv mw bi translated">现在，我们调用<code class="fe mi mj mk ml b">onClickCallback</code>，期望导航不会发生:</li></ul><pre class="kp kq kr ks gt nd ml ne nf aw ng bi"><span id="9ce6" class="nh lf it ml b gy ni nj l nk nl">expect(r.navigate).not.toHaveBeenCalledWith([2]);</span></pre><p id="c300" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">至此，我们已经涵盖了该用例。</p><h1 id="0d1e" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">摘要</h1><p id="ea0a" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">这是我们讨论过的:</p><ul class=""><li id="c069" class="mo mp it js b jt ju jx jy kb mq kf mr kj ms kn mt mu mv mw bi translated">我们无法真正测试<code class="fe mi mj mk ml b">new Chart(...)</code>。</li><li id="0786" class="mo mp it js b jt mx jx my kb mz kf na kj nb kn mt mu mv mw bi translated">我们可以将它包装在一个函数中，这样我们就可以调用<code class="fe mi mj mk ml b">chartBuilder(...)</code>而不是<code class="fe mi mj mk ml b">new Chart</code>。</li><li id="16a0" class="mo mp it js b jt mx jx my kb mz kf na kj nb kn mt mu mv mw bi translated">这允许我们测试依赖于该实例的逻辑。</li></ul><h1 id="11c1" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">额外收获:嘲笑路由器</h1><p id="ee18" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">因为我们需要在那个浏览器实例中测试的只是<code class="fe mi mj mk ml b">navigate</code>，所以我们可以创建一个<code class="fe mi mj mk ml b">mock object</code>。这是一个JavaScript对象，它的<code class="fe mi mj mk ml b">navigate</code>方法是一个Jasmine <code class="fe mi mj mk ml b">spy</code>方法，我们可以查询并找出它被调用了多少次，使用了什么参数——这正是我们所需要的。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="a237" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe mi mj mk ml b">&lt;Router&gt;&lt;unknown&gt;</code>是安慰性的打字稿:“这是一个路由器，我知道得更清楚，所以冷静点，不要把你的错误扔给我”，作者是:</p><ul class=""><li id="11b9" class="mo mp it js b jt ju jx jy kb mq kf mr kj ms kn mt mu mv mw bi translated">首先，告诉它类型是<code class="fe mi mj mk ml b">unknown</code>，也就是说，不要自作聪明地猜测这是一个<code class="fe mi mj mk ml b">object</code>。</li><li id="318b" class="mo mp it js b jt mx jx my kb mz kf na kj nb kn mt mu mv mw bi translated">然后，告诉它这是一个<code class="fe mi mj mk ml b">&lt;Router&gt;</code>。</li></ul><p id="7e07" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在那之后，我们把结果传递给任何需要的人。</p><h1 id="e952" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">额外收获:it测试用例之外的设置</h1><p id="0a62" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">这些测试用例包括相当多的设置。这对最终结果很重要，但是细节使得测试用例功能难以阅读。</p><p id="df25" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果所有的设置逻辑都有一个<code class="fe mi mj mk ml b">setup</code>功能呢？这会使单独的测试用例可读性更好，并且仍然保留其意图吗？为什么，是的，它会！</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="fc94" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">好得难以置信？不完全是。让我们看看这个用例中的<code class="fe mi mj mk ml b">setup</code>可能是什么样子:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="686f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">循序渐进:</p><p id="7090" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是一个返回这个<code class="fe mi mj mk ml b">builder</code>对象的函数，我们可以链接它的设置方法，并在完成后调用<code class="fe mi mj mk ml b">build</code>:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="78ae" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可能需要一个特殊的案例。为此添加一个方法:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="439d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们想接触一些被嘲笑的东西！没问题:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="9886" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这就是<code class="fe mi mj mk ml b">setup</code>函数的工作方式</p><h2 id="6fd7" class="nh lf it bd lg nm nn dn lk no np dp lo kb nq nr ls kf ns nt lw kj nu nv ma nw bi translated">谢谢</h2><p id="78d7" class="pw-post-body-paragraph jq jr it js b jt mc jv jw jx md jz ka kb me kd ke kf mf kh ki kj mg kl km kn im bi translated">🙏🙏🙏感谢阅读！🙏🙏🙏</p><p id="4c8c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为你成功了，这是一只微笑的猫</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/4571e2845d4e54942caec553e4b09878.png" data-original-src="https://miro.medium.com/v2/resize:fit:612/format:webp/1*BgHoiJTOlh4lhp--o5Twig.jpeg"/></div></figure><p id="5243" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">给一些👏🏻👏🏻👏🏻如果你喜欢这篇文章。掌声帮助其他人找到它，并鼓励我写更多的帖子。</p><p id="7741" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<a class="ae mh" href="https://gparlakov.github.io" rel="noopener ugc nofollow" target="_blank">我的GitHub页面</a>查看我的项目。</p></div></div>    
</body>
</html>