<html>
<head>
<title>Performance and Reliability Best Practices for Express Apps — Code Changes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Express应用程序的性能和可靠性最佳实践—代码更改</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/performance-and-reliability-best-practices-for-express-apps-code-changes-21f44007c150?source=collection_archive---------12-----------------------#2020-03-04">https://levelup.gitconnected.com/performance-and-reliability-best-practices-for-express-apps-code-changes-21f44007c150?source=collection_archive---------12-----------------------#2020-03-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/21ad915943478a3f7b06401554f5fcd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*F1JgpHfhqxL6r-sl"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@sxy_selia?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">桑嘎日玛罗曼塞利亚</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="acd4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们将Express应用程序用于生产用途时，即由外部用户使用时，我们应该考虑性能。</p><p id="7b70" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将了解在生产环境中运行Express应用程序时的一些性能和可靠性最佳实践。</p><h1 id="a923" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">代码更改使我们的应用程序更快</h1><h2 id="abe4" class="mc lf it bd lg md me dn lk mf mg dp lo kr mh mi ls kv mj mk lw kz ml mm ma mn bi translated">使用Gzip压缩</h2><p id="95cb" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">我们可以使用Gzip压缩来压缩我们的响应数据，以使我们的用户下载更少的数据。</p><p id="8e1e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为此，我们可以使用<code class="fe mt mu mv mw b">compression</code>中间件来减小响应体的大小。</p><p id="e33d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以如下使用它:</p><pre class="mx my mz na gt nb mw nc nd aw ne bi"><span id="6ab5" class="mc lf it mw b gy nf ng l nh ni">const express = require('express');<br/>const bodyParser = require('body-parser');<br/>const compression = require('compression');<br/>const app = express();<br/>app.use(compression());<br/>app.use(bodyParser.json());<br/>app.use(bodyParser.urlencoded({ extended: true }));</span><span id="842f" class="mc lf it mw b gy nj ng l nh ni">app.get('/', (req, res) =&gt; {<br/>  res.send('foo');<br/>})</span><span id="0a1b" class="mc lf it mw b gy nj ng l nh ni">app.listen(3000);</span></pre><p id="5ad0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们只需要补充一点:</p><pre class="mx my mz na gt nb mw nc nd aw ne bi"><span id="daa7" class="mc lf it mw b gy nf ng l nh ni">app.use(compression());</span></pre><p id="2657" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">启用我们的响应数据的GZip压缩。</p><p id="bc04" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于高流量网站，我们应该在反向代理中进行压缩，这样我们就不必使用<code class="fe mt mu mv mw b">compression</code>中间件。</p><h2 id="6b5f" class="mc lf it bd lg md me dn lk mf mg dp lo kr mh mi ls kv mj mk lw kz ml mm ma mn bi translated">不要使用同步函数</h2><p id="fb77" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">同步函数会占用我们应用程序的执行过程，直到它们返回。一个同步调用可能只持续几毫秒或几微秒。但是如果我们做了很多，比如在一个生产应用程序中，它肯定会增加。</p><p id="384b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在Node.js 4.0+或io.js 2.10+中，我们可以使用<code class="fe mt mu mv mw b">--trace-sync-io</code>标志在调用同步代码时输出警告和堆栈跟踪。</p><p id="c2c8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在将我们的应用程序投入生产之前，我们可以用它来用异步代码替换同步代码。</p><h1 id="6e49" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">可靠性最佳实践</h1><h2 id="9320" class="mc lf it bd lg md me dn lk mf mg dp lo kr mh mi ls kv mj mk lw kz ml mm ma mn bi translated">正确记录</h2><p id="e464" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">出于调试的目的，我们可以使用类似于<code class="fe mt mu mv mw b">debug</code>模块的东西来记录日志。它还使我们能够使用DEBUG环境变量来控制向<code class="fe mt mu mv mw b">console.err</code>发送什么调试消息。</p><p id="9f10" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于记录应用活动，我们可以使用像<a class="ae kf" href="https://www.npmjs.com/package/winston" rel="noopener ugc nofollow" target="_blank"> Winston </a>或<a class="ae kf" href="https://www.npmjs.com/package/bunyan" rel="noopener ugc nofollow" target="_blank"> Bunyan </a>这样的记录库。</p><p id="e018" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它们非常相似，但是Winston的输出更加人性化。</p><figure class="mx my mz na gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nk"><img src="../Images/4c3f2954cdf1951bd0b603180b3ecf8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JgW7FD5RVM7kLw_W"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@larrozzi?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Yassine Laaroussi </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h2 id="802d" class="mc lf it bd lg md me dn lk mf mg dp lo kr mh mi ls kv mj mk lw kz ml mm ma mn bi translated">正确处理异常</h2><p id="f843" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">当节点应用程序遇到未捕获的异常时，它会崩溃，因此我们应该通过捕获这些异常来预防应用程序在生产中崩溃。</p><p id="3a6b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于同步代码和<code class="fe mt mu mv mw b">async</code>函数，我们可以使用<code class="fe mt mu mv mw b">try...catch</code>。为了从被拒绝的承诺中捕捉错误，我们可以用自己的回调函数调用<code class="fe mt mu mv mw b">catch</code>方法来处理错误。</p><p id="3149" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以捕获同步代码中的错误，并将错误发送到我们的错误处理程序，如下所示:</p><pre class="mx my mz na gt nb mw nc nd aw ne bi"><span id="5a11" class="mc lf it mw b gy nf ng l nh ni">const express = require('express');<br/>const bodyParser = require('body-parser');<br/>const app = express();<br/>app.use(bodyParser.json());<br/>app.use(bodyParser.urlencoded({ extended: true }));</span><span id="b5e5" class="mc lf it mw b gy nj ng l nh ni">app.get('/', (req, res, next) =&gt; {<br/>  try {<br/>    throw new Error('error');<br/>  }<br/>  catch (ex) {<br/>    next(ex);<br/>  }<br/>})</span><span id="b61e" class="mc lf it mw b gy nj ng l nh ni">app.use((err, req, res, next) =&gt; {<br/>  res.send('error occurred');<br/>})</span><span id="9a95" class="mc lf it mw b gy nj ng l nh ni">app.listen(3000);</span></pre><p id="5b7f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意，我们必须把:</p><pre class="mx my mz na gt nb mw nc nd aw ne bi"><span id="8a7d" class="mc lf it mw b gy nf ng l nh ni">app.use((err, req, res, next) =&gt; {<br/>  res.send('error occurred');<br/>})</span></pre><p id="28be" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以便在我们的路由中调用<code class="fe mt mu mv mw b">next</code>时，错误处理程序将被实际调用。调用<code class="fe mt mu mv mw b">next</code>调用添加的下一个中间件。</p><p id="d4fa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mt mu mv mw b">try...catch</code>也与<code class="fe mt mu mv mw b">async</code>功能一起工作:</p><pre class="mx my mz na gt nb mw nc nd aw ne bi"><span id="27db" class="mc lf it mw b gy nf ng l nh ni">const express = require('express');<br/>const bodyParser = require('body-parser');<br/>const app = express();<br/>app.use(bodyParser.json());<br/>app.use(bodyParser.urlencoded({ extended: true }));</span><span id="a2a0" class="mc lf it mw b gy nj ng l nh ni">app.get('/', async (req, res, next) =&gt; {<br/>  try {<br/>    await Promise.reject('error');<br/>  }<br/>  catch (ex) {<br/>    next(ex);<br/>  }<br/>})</span><span id="692f" class="mc lf it mw b gy nj ng l nh ni">app.use((err, req, res, next) =&gt; {<br/>  res.send('error occurred');<br/>})</span><span id="2923" class="mc lf it mw b gy nj ng l nh ni">app.listen(3000);</span></pre><p id="f91a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当一个承诺被拒绝时，我们可以<code class="fe mt mu mv mw b">catch</code>它并将其发送给我们的错误处理程序。</p><p id="c433" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于承诺，我们可以使用自己的回调函数调用<code class="fe mt mu mv mw b">catch</code>,如下所示:</p><pre class="mx my mz na gt nb mw nc nd aw ne bi"><span id="ba17" class="mc lf it mw b gy nf ng l nh ni">const express = require('express');<br/>const bodyParser = require('body-parser');<br/>const app = express();<br/>app.use(bodyParser.json());<br/>app.use(bodyParser.urlencoded({ extended: true }));</span><span id="ad2b" class="mc lf it mw b gy nj ng l nh ni">app.get('/', (req, res, next) =&gt; {<br/>  Promise<br/>    .reject('error')<br/>    .catch(ex =&gt; next(ex));<br/>})</span><span id="3b78" class="mc lf it mw b gy nj ng l nh ni">app.use((err, req, res, next) =&gt; {<br/>  res.send('error occurred');<br/>})</span><span id="3c02" class="mc lf it mw b gy nj ng l nh ni">app.listen(3000);</span></pre><p id="4af7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这将把我们拒绝的承诺错误发送给我们的错误处理程序。</p><p id="1f37" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们不应该听<code class="fe mt mu mv mw b">uncaughtException</code>事件。这将改变遇到异常的流程的默认行为。尽管有异常，这个过程还是会运行，这并不好，因为我们想在应用程序不崩溃的情况下知道错误。</p><p id="472f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">听<code class="fe mt mu mv mw b">uncaughtException</code>只是把错误扫在地毯下。崩溃并重新启动是从错误中恢复的更好方法。</p><p id="4831" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以如下处理事件发射器发出的错误:</p><pre class="mx my mz na gt nb mw nc nd aw ne bi"><span id="e089" class="mc lf it mw b gy nf ng l nh ni">const express = require('express');<br/>const bodyParser = require('body-parser');<br/>const EventEmitter = require('events');<br/>const app = express();</span><span id="737b" class="mc lf it mw b gy nj ng l nh ni">app.use(bodyParser.json());<br/>app.use(bodyParser.urlencoded({ extended: true }));</span><span id="a97b" class="mc lf it mw b gy nj ng l nh ni">const eventEmitter = new EventEmitter();</span><span id="d59e" class="mc lf it mw b gy nj ng l nh ni">app.get('/', (req, res, next) =&gt; {<br/>  eventEmitter.emit('error', new Error('error!'));<br/>  eventEmitter.on('error', next).pipe(res);<br/>})</span><span id="59e4" class="mc lf it mw b gy nj ng l nh ni">app.use((err, req, res, next) =&gt; {<br/>  res.send('error occurred');<br/>})</span><span id="f59d" class="mc lf it mw b gy nj ng l nh ni">app.listen(3000);</span></pre><p id="442b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们应该得到<code class="fe mt mu mv mw b">error occurred</code>，因为<code class="fe mt mu mv mw b">eventEmitter</code>的<code class="fe mt mu mv mw b">error</code>事件触发了对<code class="fe mt mu mv mw b">next</code>函数的调用。</p><p id="a268" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">像streams这样的Node中的许多东西都扩展了EventEmitter，所以这可以处理它们发出的错误。</p><h1 id="4ae1" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="7664" class="pw-post-body-paragraph kg kh it ki b kj mo kl km kn mp kp kq kr mq kt ku kv mr kx ky kz ms lb lc ld im bi translated">为了让我们的应用程序更快，我们可以压缩我们的响应，这样用户就不必下载那么多数据来获得我们的响应。</p><p id="cb38" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，我们不应该使用同步函数，因为它们会在主执行过程完成之前一直拖住它。</p><p id="bb8c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于伐木，我们应该考虑像<a class="ae kf" href="https://www.npmjs.com/package/winston" rel="noopener ugc nofollow" target="_blank">温斯顿</a>或<a class="ae kf" href="https://www.npmjs.com/package/bunyan" rel="noopener ugc nofollow" target="_blank">班扬</a>这样的替代品。</p><p id="a698" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了正确处理异常，我们可以使用<code class="fe mt mu mv mw b">try...catch</code>同步代码和<code class="fe mt mu mv mw b">async</code>函数。</p><p id="2975" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于承诺，我们可以使用<code class="fe mt mu mv mw b">catch</code>方法和我们自己传入的回调来处理错误。</p><p id="ed5b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于事件发射器错误，我们可以在发出<code class="fe mt mu mv mw b">error</code>事件时调用<code class="fe mt mu mv mw b">next</code>。</p><p id="9ec7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在每种情况下，我们都可以调用<code class="fe mt mu mv mw b">next</code>来调用我们自己的错误处理程序或Express的默认错误处理程序。</p></div></div>    
</body>
</html>