<html>
<head>
<title>Building an API with Rust using Tokio and Warp</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Tokio和Warp构建带Rust的API</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/building-an-api-using-warp-and-tokio-26a52173860a?source=collection_archive---------1-----------------------#2020-05-21">https://levelup.gitconnected.com/building-an-api-using-warp-and-tokio-26a52173860a?source=collection_archive---------1-----------------------#2020-05-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/84c229915a3a906adc76b685a088f313.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BWv4hVJ33aA-nfPXtHpcfQ.png"/></div></div></figure><p id="58ea" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一个使用Warp和Tokio构建简单异步API的示例项目。</p><p id="a201" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">本教程通过构建一个异步CRUD API来介绍Warp框架。我写这篇文章的目的如下:</p><ol class=""><li id="4702" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">熟悉Warp框架。</li><li id="c18a" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">更加熟悉在Rust中使用async/await</li><li id="47e2" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">更好地理解Rust中的API设计</li></ol><h1 id="8d6b" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">设计</h1><p id="3133" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">在进入任何编码之前，我将勾画出API的设计。这将有助于确定必要的端点、处理函数以及如何存储数据。</p><h2 id="63dd" class="mn ll iq bd lm mo mp dn lq mq mr dp lu kj ms mt ly kn mu mv mc kr mw mx mg my bi translated">路线</h2><p id="1ce0" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">对于这个API，我只需要两条路线。</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="cc12" class="mn ll iq ne b gy ni nj l nk nl">/customers <br/>    - GET -&gt; list all customers in data store - POST -&gt; create new customer and insert into data store <br/>/customers/{guid} <br/>    - GET -&gt; list info for a customer <br/>    - POST -&gt; update information for a customer <br/>    - DELETE -&gt; remove customer from data store</span></pre><h2 id="8f86" class="mn ll iq bd lm mo mp dn lq mq mr dp lu kj ms mt ly kn mu mv mc kr mw mx mg my bi translated">经理人</h2><p id="83c8" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">根据定义的路线，我需要以下处理程序:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="3cb0" class="mn ll iq ne b gy ni nj l nk nl">list_customers -&gt; return a list all customers in database create_customer -&gt; create a new customer and add it to the database get_customer -&gt; return the details of a single customer update_customer -&gt; update the details of a single customer delete_customer -&gt; delete a customer from the database</span></pre><h2 id="2de8" class="mn ll iq bd lm mo mp dn lq mq mr dp lu kj ms mt ly kn mu mv mc kr mw mx mg my bi translated">数据库ˌ资料库</h2><p id="5263" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">现在，我将只使用内存中的数据存储来跨路由处理程序共享。</p><p id="d17f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我使用<a class="ae nm" href="https://www.mockaroo.com/" rel="noopener ugc nofollow" target="_blank"> Mockaroo </a>生成客户数据的JSON数据集。数据是一个JSON数组，其中每个对象具有以下结构:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="bafe" class="mn ll iq ne b gy ni nj l nk nl">{<br/>    "guid": "String",<br/>    "first_name": "String",<br/>    "last_name": "String",<br/>    "email": "String",<br/>    "address": "String"<br/>}</span></pre><p id="68a5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此外，一旦服务器启动，数据库模块将需要能够初始化数据存储。</p><h1 id="9b9d" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">属国</h1><p id="49b8" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">截至目前，我知道我将需要以下依赖项:</p><ul class=""><li id="1281" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv nn lc ld le bi translated"><a class="ae nm" href="https://crates.io/crates/warp" rel="noopener ugc nofollow" target="_blank">Warp</a>—Rust的web服务器框架</li><li id="3771" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv nn lc ld le bi translated"><a class="ae nm" href="https://crates.io/crates/tokio" rel="noopener ugc nofollow" target="_blank">Tokio</a>—Rust的异步运行时间</li><li id="07b9" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv nn lc ld le bi translated"><a class="ae nm" href="https://crates.io/crates/serde" rel="noopener ugc nofollow" target="_blank"> Serde </a> —用于将JSON转换为类型化数据的de/serialization库，反之亦然。</li></ul><h1 id="7b89" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">履行</h1><h2 id="adfb" class="mn ll iq bd lm mo mp dn lq mq mr dp lu kj ms mt ly kn mu mv mc kr mw mx mg my bi translated">模型</h2><p id="7812" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">我想做的第一件事是定义我的客户模型，并开始向代码中添加一些结构。</p><p id="58df" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<code class="fe no np nq ne b">main.rs</code>中，定义一个名为<code class="fe no np nq ne b">models</code>的新模块，如下所示:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="bdad" class="mn ll iq ne b gy ni nj l nk nl">mod models;<br/><br/>fn main() {<br/>    // ...<br/>}</span></pre><p id="09c3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后创建一个名为<code class="fe no np nq ne b">models.rs</code>的新文件，并添加以下内容:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="cf22" class="mn ll iq ne b gy ni nj l nk nl">pub struct Customer {<br/>    pub guid: String,<br/>    pub first_name: String,<br/>    pub last_name: String,<br/>    pub email: String,<br/>    pub address: String,<br/>}</span></pre><p id="4bfe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于我正在设计一个API，这个数据结构需要能够在JSON之间转换。我还希望能够将结构复制到数据存储中或从数据存储中复制出来，而不必担心借用检查器。</p><p id="4bc4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了实现这一点，我将添加一个derive语句来使用Serde库中的几个宏和Rust中的几个宏。现在<code class="fe no np nq ne b">models.rs</code>看起来像这样:</p><figure class="mz na nb nc gt jr gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/39d7b1d2eb2b09ba137609da52c85057.png" data-original-src="https://miro.medium.com/v2/resize:fit:1130/format:webp/0*sue-KWrU-R1S1vwg.png"/></div></figure><h2 id="e295" class="mn ll iq bd lm mo mp dn lq mq mr dp lu kj ms mt ly kn mu mv mc kr mw mx mg my bi translated">数据库ˌ资料库</h2><p id="421a" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">这个示例API的数据库将是一个内存数据库，它是<code class="fe no np nq ne b">Customer</code>模型的一个向量。然而，数据存储将需要跨多个路由共享，因此我们可以使用Rust的一个智能指针和一个互斥锁来实现线程安全。</p><p id="ce96" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，用一个名为<code class="fe no np nq ne b">db</code>的新模块更新<code class="fe no np nq ne b">main.rs</code>:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="0b1f" class="mn ll iq ne b gy ni nj l nk nl">mod db;<br/>mod models;<br/><br/>fn main() {<br/>    // ...<br/>}</span></pre><p id="3354" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后创建一个名为<code class="fe no np nq ne b">db.rs</code>的新文件。</p><p id="fb4d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个文件中有几件事情要做，但是首先要做的是定义数据存储的外观。</p><p id="85b4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一个简单的数据存储只是一个<code class="fe no np nq ne b">Customer</code>结构的向量，但是它需要被包装在一个线程安全的引用中，以便能够在多个异步处理程序中使用数据存储的多个引用。</p><p id="c6ad" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将以下内容添加到<code class="fe no np nq ne b">db.rs</code>:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="5d72" class="mn ll iq ne b gy ni nj l nk nl">use std::sync::Arc;<br/>use tokio::sync::Mutex;<br/><br/>use crate::models::Customer;<br/><br/>pub type Db = Arc&lt;Mutex&lt;Vec&lt;Customer&gt;&gt;&gt;;</span></pre><p id="88d3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们已经定义了数据存储的结构，我们需要一种初始化数据存储的方法。初始化数据存储有两种结果，要么是空的数据存储，要么是加载了数据文件中的数据的数据存储。</p><p id="2fa8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一个空的商店是相当直接的。</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="762f" class="mn ll iq ne b gy ni nj l nk nl">pub fn init_db() -&gt; Db {<br/>    Arc::new(Mutex::new(Vec::new()))<br/>}</span></pre><p id="a260" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是为了从文件中加载数据，我们需要添加另一个依赖项:</p><ul class=""><li id="3846" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv nn lc ld le bi translated"><a class="ae nm" href="https://crates.io/crates/serde_json" rel="noopener ugc nofollow" target="_blank"> serde_json </a> —用于读取原始json</li></ul><p id="4bfd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将以下内容添加到<code class="fe no np nq ne b">Cargo.toml</code>文件中:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="8d0f" class="mn ll iq ne b gy ni nj l nk nl">serde_json = "1.0"</span></pre><p id="0ecb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们可以用下面的内容更新<code class="fe no np nq ne b">db.rs</code>:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="8a24" class="mn ll iq ne b gy ni nj l nk nl">use std::fs::File;<br/>use serde_json::from_reader;<br/><br/>pub fn init_db() -&gt; Db {<br/>    let file = File::open("./data/customers.json");<br/>    match file =&gt; {<br/>        Ok(json) =&gt; {<br/>            let customers = from_reader(json).unwrap();<br/>            Arc::new(Mutex::new(customers))<br/>        },<br/>        Err(_) =&gt; {<br/>            Arc::new(Mutex::new(Vec::new()))<br/>        }<br/>    }<br/>}</span></pre><p id="07e7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该函数试图读取位于<code class="fe no np nq ne b">./data/customers.json</code>的文件。如果成功，该函数返回一个装载了客户数据的数据存储，否则返回一个空向量。</p><p id="ed04" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe no np nq ne b">db.rs</code>现在应该是这样的:</p><figure class="mz na nb nc gt jr gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/e6ac8261ccccc825d99145ac2d056bf5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1256/format:webp/0*VkFMRfyUv7oWLHhL.png"/></div></figure><h2 id="bfd3" class="mn ll iq bd lm mo mp dn lq mq mr dp lu kj ms mt ly kn mu mv mc kr mw mx mg my bi translated">经理人</h2><p id="9d5e" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">至此，我们已经有了模型和数据库设置。现在我们需要一种方法将它们联系在一起。这就是负责人介入的地方。</p><p id="a6e7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先让我们在<code class="fe no np nq ne b">main.rs</code>中定义一个新模块，并创建一个名为<code class="fe no np nq ne b">handlers.rs</code>的新文件。</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="0484" class="mn ll iq ne b gy ni nj l nk nl">mod handlers;</span></pre><p id="9d8b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们还需要添加一些导入。在<code class="fe no np nq ne b">handlers.rs</code>文件中添加以下内容:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="228c" class="mn ll iq ne b gy ni nj l nk nl">use std::convert::Infallible;<br/>use warp;<br/><br/>use crate::models::Customer;<br/>use crate::db::Db;</span></pre><p id="ec67" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个代码片段使得我们在其他模块中定义的<code class="fe no np nq ne b">Customer</code>模型和<code class="fe no np nq ne b">Db</code>类型在<code class="fe no np nq ne b">handlers</code>模块中可用。它还导入根<code class="fe no np nq ne b">warp</code>模块和<code class="fe no np nq ne b"><a class="ae nm" href="https://doc.rust-lang.org/std/convert/enum.Infallible.html" rel="noopener ugc nofollow" target="_blank">Infallible</a></code>枚举，后者是永远不会发生的错误的错误类型。</p><p id="2e23" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在提醒一下，下面是我们想要实现的处理程序:</p><ul class=""><li id="9509" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv nn lc ld le bi translated">list_customers -&gt;返回数据库中所有客户的列表</li><li id="9dfb" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv nn lc ld le bi translated">create_customer -&gt;创建一个新客户，并将其添加到数据库中</li><li id="49e6" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv nn lc ld le bi translated">get_customer -&gt;返回单个客户的详细信息</li><li id="54ea" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv nn lc ld le bi translated">update_customer -&gt;更新单个客户的详细信息</li><li id="22e0" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv nn lc ld le bi translated">delete_customer -&gt;从数据库中删除客户</li></ul><h2 id="1526" class="mn ll iq bd lm mo mp dn lq mq mr dp lu kj ms mt ly kn mu mv mc kr mw mx mg my bi translated">列出客户</h2><p id="30a0" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated"><code class="fe no np nq ne b">list_customers</code>处理程序将引用数据存储作为参数，并返回一个包装JSON响应的<code class="fe no np nq ne b">Result</code>类型。</p><p id="5155" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">函数定义将如下所示:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="e110" class="mn ll iq ne b gy ni nj l nk nl">pub async fn list_customers(db: Db) -&gt; Result&lt;impl warp::Reply, Infallible&gt; {<br/>   // ... <br/>}</span></pre><p id="c53d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于函数体，我们需要从数据存储中获取客户列表，并将其作为JSON对象返回。为了方便起见，<code class="fe no np nq ne b">warp</code>提供了一个将vector转换成json对象的回复方法。</p><p id="46aa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">用以下内容更新函数:</p><figure class="mz na nb nc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nt"><img src="../Images/f03157deeadd096cc51a6d6b3dd995b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*uuRtqjJYa_2q87XG.png"/></div></div></figure><p id="a6cd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">行<code class="fe no np nq ne b">let customers = db.lock().await;</code>导致当前任务让步，直到可以获得锁并且可以安全地引用数据存储。</p><p id="f969" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">线条<code class="fe no np nq ne b">let customers: Vec&lt;Customer&gt; = customers.clone()</code>将内部向量从<code class="fe no np nq ne b">MutexGuard</code>中取出。</p><p id="3c57" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后一行<code class="fe no np nq ne b">Ok(warp::reply::json(&amp;customers))</code>将JSON回复封装在<code class="fe no np nq ne b">Result</code>类型的<code class="fe no np nq ne b">Ok</code>变量中。</p><h2 id="790d" class="mn ll iq bd lm mo mp dn lq mq mr dp lu kj ms mt ly kn mu mv mc kr mw mx mg my bi translated">创建客户</h2><p id="6daf" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated"><code class="fe no np nq ne b">create_customer</code>处理程序将把一个<code class="fe no np nq ne b">Customer</code>对象和一个对数据存储的引用作为参数，如果新客户被添加到客户列表中，则返回一个已创建的状态代码，如果客户已经存在，则返回一个错误的请求代码。</p><p id="12ba" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们使用这个函数之前，我们需要更新warp import语句以允许使用状态代码。</p><p id="3b13" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<code class="fe no np nq ne b">handlers.rs</code>中，将行<code class="fe no np nq ne b">use warp;</code>改为如下:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="710a" class="mn ll iq ne b gy ni nj l nk nl">use warp::{self, http::StatusCode};</span></pre><p id="5ec9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这将允许使用<code class="fe no np nq ne b">StatusCode</code>枚举作为响应。</p><p id="4a6d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">函数定义将类似于<code class="fe no np nq ne b">list_customers</code>处理程序，所以我们可以直接跳到完整的定义。</p><figure class="mz na nb nc gt jr gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/e7b5bc227a63607f39f3dcadd2e70d5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*bfnu_sZg4bXg1MgK.png"/></div></figure><h2 id="cad1" class="mn ll iq bd lm mo mp dn lq mq mr dp lu kj ms mt ly kn mu mv mc kr mw mx mg my bi translated">获取客户</h2><p id="9335" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated"><code class="fe no np nq ne b">get_customer</code>处理程序将一个guid和一个数据存储引用作为参数，如果找到客户，则返回客户的JSON对象，否则返回默认客户。</p><p id="8ff6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们编写这个实现之前，我们需要向<code class="fe no np nq ne b">Customer</code>结构添加一个宏。将<code class="fe no np nq ne b">models.rs</code>中的<code class="fe no np nq ne b">Customer</code>结构更新如下:</p><figure class="mz na nb nc gt jr gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/a3fe50219e13b72a8df2fafe45bb91c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1256/format:webp/0*tIwigBAmb-Hy3eAy.png"/></div></figure><p id="b60b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">函数定义如下所示:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="fa14" class="mn ll iq ne b gy ni nj l nk nl">pub async fn get_customer(guid: String, db: Db) -&gt; Result&lt;Box&lt;dyn warp::Reply&gt;, Infallible&gt; {<br/>    <br/>}</span></pre><p id="1843" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">返回类型与其他函数略有不同。原因是我们需要能够返回一个JSON对象或者一个表明未找到错误的状态代码。由于<code class="fe no np nq ne b">warp::reply::json()</code>和<code class="fe no np nq ne b">StatusCode</code>实现了<code class="fe no np nq ne b">warp::Reply</code>特征，我们可以使用<a class="ae nm" href="https://doc.rust-lang.org/1.8.0/book/trait-objects.html" rel="noopener ugc nofollow" target="_blank">动态分派</a>返回适当的类型。</p><p id="39cf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有了正确的返回类型，我们的函数体相当简单:</p><figure class="mz na nb nc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nv"><img src="../Images/456429bcad98f6ce9da41b9ed1216bda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*96M88fxKgbAMTsLz.png"/></div></div></figure><p id="e1d4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe no np nq ne b">update_customer</code>处理程序将一个客户和一个数据存储引用作为参数，如果找到并更新了客户，则返回一个状态代码OK，如果客户不在数据存储中，则返回NOT FOUND。</p><p id="42a5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该函数应该如下所示:</p><figure class="mz na nb nc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nw"><img src="../Images/9a1ad640985c7441ce49bc8d1d48958a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ROhNI2DEvwVwFpp6.png"/></div></div></figure><h2 id="eaf6" class="mn ll iq bd lm mo mp dn lq mq mr dp lu kj ms mt ly kn mu mv mc kr mw mx mg my bi translated">删除客户</h2><p id="7c5f" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated"><code class="fe no np nq ne b">delete_customer</code>处理程序将guid和对数据存储的引用作为参数。该函数将删除具有匹配guid的客户，并返回无内容状态代码。如果没有找到匹配，那么它将返回一个未找到的状态代码。</p><p id="17a3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该函数应该如下所示:</p><figure class="mz na nb nc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nx"><img src="../Images/d1963eb085498a1309f65dfa919d6dbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ngz_PG8k5CD6L2C8.png"/></div></div></figure><h1 id="18c9" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">路线</h1><p id="a19c" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">我们现在已经实现了所有的处理函数。接下来，我们需要将调用处理程序的路由组合在一起。</p><p id="c43e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<code class="fe no np nq ne b">main.rs</code>中，定义另一个模块:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="1228" class="mn ll iq ne b gy ni nj l nk nl">mod routes;</span></pre><p id="2aca" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，我们在<code class="fe no np nq ne b">src</code>目录中创建一个名为<code class="fe no np nq ne b">routes.rs</code>的文件，并添加以下内容:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="6bb5" class="mn ll iq ne b gy ni nj l nk nl">use std::convert::Infallible;<br/>use warp::{self, Filter};<br/><br/>use crate::db::Db;<br/>use crate::handlers;<br/>use crate::models::Customer;</span></pre><p id="eed1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，我们需要一个助手函数将数据存储的引用从路由传递到处理程序中。</p><p id="6b90" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将以下内容添加到<code class="fe no np nq ne b">routes.rs</code>:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="7ced" class="mn ll iq ne b gy ni nj l nk nl">fn with_db(db: Db) -&gt; impl Filter&lt;Extract = (Db,), Error = Infallible&gt; {<br/>    warp::any().map(move || db.clone())<br/>}</span></pre><p id="ff85" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该函数允许将数据存储注入到路由中，并传递给处理程序。<code class="fe no np nq ne b">Filter</code>是warp库中的一个特性。<code class="fe no np nq ne b">Filter</code>特征提供了组合路由的功能，这些路由是一个或多个<code class="fe no np nq ne b">Filter</code>方法的结果。这用一个例子会更有意义。</p><p id="bd71" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">提醒一下，以下是我们需要定义的路线:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="95ec" class="mn ll iq ne b gy ni nj l nk nl">/customers<br/>    - GET -&gt; list all customers in data store<br/>    - POST -&gt; create new customer and insert into data store<br/>/customers/{guid}<br/>    - GET -&gt; list info for a customer<br/>    - POST -&gt; update information for a customer<br/>    - DELETE -&gt; remove customer from data store</span></pre><h2 id="8ff9" class="mn ll iq bd lm mo mp dn lq mq mr dp lu kj ms mt ly kn mu mv mc kr mw mx mg my bi translated">获取/客户</h2><p id="5a7f" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">第一条路线将简单地获取数据存储中的所有客户。将以下内容添加到<code class="fe no np nq ne b">routes.rs</code>:</p><figure class="mz na nb nc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ny"><img src="../Images/bf8463619ba5133075730b92d2dde29a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*hFQoRobNfeG2eIvh.png"/></div></div></figure><p id="c930" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该函数返回一个实现<code class="fe no np nq ne b">Filter</code>特征的类型。当出现匹配时使用<code class="fe no np nq ne b">Extract</code>并返回<code class="fe no np nq ne b">Extract</code>的值。</p><p id="d766" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">基本上，当请求的路径是“/customers”并且是一个GET请求时，该函数定义一个匹配的路由。</p><p id="ed8a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此外，为了节省以后的工作，我将实现另一个函数，作为所有客户路线的包装器。当我们把所有的事情都联系在一起的时候，事情会变得容易些。</p><p id="f701" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此将以下内容添加到<code class="fe no np nq ne b">routes.rs</code>:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="097c" class="mn ll iq ne b gy ni nj l nk nl">pub fn customer_routes(db: Db) -&gt; impl Filter&lt;Extract = impl warp::Reply, Error = warp::Rejection&gt; + Clone {<br/>    customers_list(db.clone())<br/>}</span></pre><h2 id="29e3" class="mn ll iq bd lm mo mp dn lq mq mr dp lu kj ms mt ly kn mu mv mc kr mw mx mg my bi translated">邮政/客户</h2><p id="4c6c" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">如果不存在新客户，此路线会向数据存储中添加一个新客户。</p><p id="aa06" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们为路由添加函数之前，需要添加一个助手函数来从POST请求体中提取JSON。</p><p id="392a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将以下内容添加到<code class="fe no np nq ne b">routes.rs</code>:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="1a27" class="mn ll iq ne b gy ni nj l nk nl">fn json_body() -&gt; impl Filter&lt;Extract = (Customer,), Error = warp::Rejection&gt; + Clone {<br/>    warp::body::content_length_limit(1024 * 16)<br/>        .and(warp::body::json())<br/>}</span></pre><p id="aa71" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">除了处理器之外，该功能与<code class="fe no np nq ne b">customers_list</code>非常相似。将以下内容添加到<code class="fe no np nq ne b">routes.rs</code>:</p><figure class="mz na nb nc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ny"><img src="../Images/c32fc665c1e5bd1bef97eca66777dfca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*QO6bpjm4AvFUeDwa.png"/></div></div></figure><p id="3c6b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当路径为“/customers”并且是post请求时，此函数定义匹配的路由。然后从post请求和数据存储引用中提取JSON，并传递给处理程序。</p><h2 id="d4a8" class="mn ll iq bd lm mo mp dn lq mq mr dp lu kj ms mt ly kn mu mv mc kr mw mx mg my bi translated">GET /customers/{guid}</h2><p id="cb42" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">此路由将尝试从数据存储中检索单个客户。</p><p id="7a8e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该路由功能将从<code class="fe no np nq ne b">warp</code>引入<code class="fe no np nq ne b">path!</code>宏。这个宏使我们能够创建一个带有变量的路径。</p><p id="18ac" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<code class="fe no np nq ne b">routes.rs</code>中增加以下内容:</p><figure class="mz na nb nc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ny"><img src="../Images/a27f3d09b6945a3c7355fee68701985e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*R700W6kAAIAS_sHR.png"/></div></div></figure><p id="0aba" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这定义了一个将匹配“customers/{some string value}”和一个GET请求的路由。然后，它提取数据存储并将其传递给处理程序。</p><p id="7d48" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于路由，需要考虑的一件事是，应该首先检查最具体的路由，否则路由可能不匹配。</p><p id="511f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，如果路线的助手功能更新为:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="e2c0" class="mn ll iq ne b gy ni nj l nk nl">pub fn customer_routes(<br/>    db: Db,<br/>) -&gt; impl Filter&lt;Extract = impl warp::Reply, Error = warp::Rejection&gt; + Clone {<br/>    customers_list(db.clone())<br/>        .or(create_customer(db.clone()))<br/>        .or(get_customer(db.clone()))<br/>}</span></pre><p id="10b4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe no np nq ne b">get_customer</code>路由永远不会匹配，因为它们共享一个共同的根路径-“/customers”-这意味着客户列表路由将匹配“/customers”和“/customers/{guid}”。</p><p id="8055" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要解决不匹配问题，请安排路线，使最匹配的路线排在最前面。像这样:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="01dc" class="mn ll iq ne b gy ni nj l nk nl">pub fn customer_routes(<br/>    db: Db,<br/>) -&gt; impl Filter&lt;Extract = impl warp::Reply, Error = warp::Rejection&gt; + Clone {<br/>    get_customer(db.clone())<br/>        .or(customers_list(db.clone()))<br/>        .or(create_customer(db.clone()))<br/>}</span></pre><h2 id="d4a5" class="mn ll iq bd lm mo mp dn lq mq mr dp lu kj ms mt ly kn mu mv mc kr mw mx mg my bi translated">PUT /customers/{guid}</h2><p id="44c6" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">如果客户存在，此路由将尝试更新客户，并返回OK状态代码，否则返回NOT FOUND状态代码。</p><p id="aca8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该路线看起来类似于创建客户路线，但它将匹配不同的路径。在<code class="fe no np nq ne b">routes.rs</code>中增加以下内容:</p><figure class="mz na nb nc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ny"><img src="../Images/51bc9be73205c790cbc2e7b851dcd8bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*p4qZ4YEyFNYvPJqf.png"/></div></div></figure><p id="f85d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后更新客户路线包装:</p><pre class="mz na nb nc gt nd ne nf ng aw nh bi"><span id="8a62" class="mn ll iq ne b gy ni nj l nk nl">pub fn customer_routes(<br/>    db: Db,<br/>) -&gt; impl Filter&lt;Extract = impl warp::Reply, Error = warp::Rejection&gt; + Clone {<br/>    get_customer(db.clone())<br/>        .or(update_customer(db.clone()))<br/>        .or(create_customer(db.clone()))<br/>        .or(customers_list(db))<br/>}</span></pre><h2 id="4ce6" class="mn ll iq bd lm mo mp dn lq mq mr dp lu kj ms mt ly kn mu mv mc kr mw mx mg my bi translated">删除/customers/{guid}</h2><p id="7288" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">最后一个路由只是从数据存储中删除一个与给定guid匹配的客户，然后返回一个NO CONTENT状态代码，否则返回一个NOT FOUND状态代码。</p><p id="e895" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将以下内容添加到<code class="fe no np nq ne b">routes.rs</code>:</p><figure class="mz na nb nc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ny"><img src="../Images/27ec215b31fb82cd551b5aacf2859982.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ihEuT6hZ44IwlHAV.png"/></div></div></figure><p id="1a65" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后更新客户路由包装。添加完所有路由后，包装器应该如下所示:</p><figure class="mz na nb nc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ny"><img src="../Images/966a544335574d0fe7a4b6cd075ff95d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*26Lt7FDRsebMAWXP.png"/></div></div></figure><p id="b20e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这结束了所有的路线。现在，我们可以继续将所有内容联系在一起。</p><h1 id="e1b3" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">主要的</h1><p id="6e00" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated"><code class="fe no np nq ne b">main.rs</code>会把所有的碎片拉在一起。它将初始化数据存储，获取所有路由，并启动服务器。这也是一个相当短的文件，所以我只展示全部内容:</p><figure class="mz na nb nc gt jr gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/2d8dcacd421dcc79ca8f28703b873976.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/0*ll-s_yV799pUOgTA.png"/></div></figure><p id="7d2c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们已经看到了前几行，所以让我们看看主函数。</p><p id="8fad" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">函数属性<code class="fe no np nq ne b">#[tokio::main]</code>为<code class="fe no np nq ne b">tokio</code>运行时设置入口点。这允许我们将<code class="fe no np nq ne b">main</code>函数声明为<code class="fe no np nq ne b">async</code>。</p><p id="2b2d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe no np nq ne b">main</code>的前两行只是从我们的模块中调用函数。第一个初始化数据存储，第二个获取我们的客户路由包装器。</p><p id="8b9a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后一行使用<code class="fe no np nq ne b">warp::server</code>创建一个服务器，然后使用<code class="fe no np nq ne b">run</code>在提供的主机和端口上启动服务器。我们使用<code class="fe no np nq ne b">await</code>关键字让步，直到<code class="fe no np nq ne b">run</code>函数完成。</p><h1 id="3c64" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">回顾</h1><p id="8d04" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">这使用Rust和Warp框架完成了一个简单的API。代码库可以在<a class="ae nm" href="https://github.com/andrewleverette/rust_warp_api" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="ed1d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，还是有可以改进的地方。</p><p id="0200" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里有一些想法:</p><ul class=""><li id="8b83" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv nn lc ld le bi translated">可以添加测试来确认端点的行为符合预期</li><li id="f4f5" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv nn lc ld le bi translated">可以向<code class="fe no np nq ne b">db</code>模块添加功能，以允许通过覆盖JSON文件来保存数据存储。</li><li id="d106" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv nn lc ld le bi translated">简单的数据存储可以用PostgreSQL甚至MongoDB这样的实际数据库来代替。</li><li id="1db4" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv nn lc ld le bi translated">此外，当使用来自命令行的中断信号停止服务器时，会引发错误。这可以被重构以执行正常关机。</li></ul></div><div class="ab cl oa ob hu oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="ij ik il im in"><p id="01f0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="oh">原载于2020年5月21日</em><a class="ae nm" href="https://andrewleverette.github.io/warp-api/" rel="noopener ugc nofollow" target="_blank"><em class="oh">https://andrewleverette . github . io</em></a><em class="oh">。</em></p><figure class="mz na nb nc gt jr gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/2683b9f8b8766fdf390a456bcd63ab22.png" data-original-src="https://miro.medium.com/v2/resize:fit:970/format:webp/1*3N6R_9KQPVOHCiYG66Iytg.png"/></div></figure></div></div>    
</body>
</html>