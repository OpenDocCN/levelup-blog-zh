<html>
<head>
<title>Learning C++: The STL and the List Class</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习c++:STL和List类</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/learning-c-the-stl-and-the-list-class-8544e3c13387?source=collection_archive---------12-----------------------#2020-04-08">https://levelup.gitconnected.com/learning-c-the-stl-and-the-list-class-8544e3c13387?source=collection_archive---------12-----------------------#2020-04-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/730a5db744f0d711551cc45e04494020.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PX3x8bmOl5E4uydm"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@glenncarstenspeters?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">格伦·卡斯滕斯-彼得斯</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="a46a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">众所周知，分配了连续内存地址的顺序容器(如数组)在插入和删除数据时效率很低。如果需要在数组前面插入或删除一个数据元素，一个<em class="le"> n </em>大小的数组可能需要<em class="le"> n </em>个步骤。本文讨论了在可能发生多次插入和删除时使用的替代容器——<code class="fe lf lg lh li b">list</code>类。这个类实现了经典的<em class="le">链表</em>数据结构。</p><h1 id="a2c2" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">链表结构</h1><p id="fa14" class="pw-post-body-paragraph kg kh it ki b kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ml lb lc ld im bi translated">一个<em class="le">链表</em>是被链接在一起的被称为<em class="le">节点</em>的数据元素的独立集合。一个列表可以是单链接的，其中链接从列表的前面移动到列表的后面，或者一个列表可以是双T21链接的，其中既有前向链接也有后向链接。</p><p id="42a0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是单向和双向链表的图示:</p><figure class="mn mo mp mq gt ju gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/739d6c59ce24a9a80cee349d6201c814.png" data-original-src="https://miro.medium.com/v2/resize:fit:1230/format:webp/1*5wRMqVjLatOGX88VrZgacA.jpeg"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">图片由克里斯托弗·韦伯提供</figcaption></figure><p id="810d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">链表不允许随机访问，因为您只能通过节点的链接从一个数据元素移动到另一个数据元素。</p><h1 id="df91" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">链表的优点</h1><p id="54d2" class="pw-post-body-paragraph kg kh it ki b kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ml lb lc ld im bi translated">标准模板库(STL)的list类是一个提供高效插入和删除的链表。链表不是上下移动元素来执行插入或删除，而是简单地分配几个指针，使链接的元素指向正确的下一个或前一个元素。以下是链表插入的外观:</p><figure class="mn mo mp mq gt ju gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/2a2bd241055c7921124b7d077a8a48b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:540/format:webp/1*Wwz8N9rItaPxY2gshoXCOw.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">图片由engineering.purdue.edu提供</figcaption></figure><p id="fe95" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从链表中删除看起来像这样:</p><figure class="mn mo mp mq gt ju gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/8bfa844ac69db15b4c4f83058d0b64e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:608/format:webp/1*w2zA6NDWh1nVeUsQbibjmQ.jpeg"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">图片由tech-faq.com提供</figcaption></figure><p id="fe86" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当处理非常大的数据集时，通过对链表执行插入和删除而节省的步骤数量可能非常大。</p><h1 id="edca" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">创建列表</h1><p id="8ca7" class="pw-post-body-paragraph kg kh it ki b kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ml lb lc ld im bi translated"><code class="fe lf lg lh li b">list</code>类用于在C++中创建链表。像所有的STL容器一样，这个类是一个模板类，所以数据类型必须在<code class="fe lf lg lh li b"> list</code>关键字之后指定。下面是两条创建新的<code class="fe lf lg lh li b">list</code>对象的语句:</p><pre class="mn mo mp mq gt mt li mu mv aw mw bi"><span id="ba89" class="mx lk it li b gy my mz l na nb">list&lt;string&gt; names;<br/>list&lt;int&gt; numbers;</span></pre><p id="635d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">还可以通过在声明中添加size参数来指定列表中元素的初始数量:</p><pre class="mn mo mp mq gt mt li mu mv aw mw bi"><span id="ee98" class="mx lk it li b gy my mz l na nb">list&lt;string&gt; names(10);<br/>list&lt;int&gt; numbers(100);</span></pre><p id="85ec" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以提供一个初始化列表，在声明时将一些数据放入列表中:</p><pre class="mn mo mp mq gt mt li mu mv aw mw bi"><span id="9feb" class="mx lk it li b gy my mz l na nb">list&lt;string&gt; names{"Cynthia", "Jonathan", "Raymond",<br/>                   "Danny", "Mayo"};<br/>list&lt;int&gt; numbers{1,2,3,4,5};</span></pre><h1 id="a950" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">将数据放入列表</h1><p id="ba58" class="pw-post-body-paragraph kg kh it ki b kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ml lb lc ld im bi translated">在列表中存储数据有两种标准方法。要使用的功能有<code class="fe lf lg lh li b">push_back</code>和<code class="fe lf lg lh li b">push_front</code>。<code class="fe lf lg lh li b">push_back</code>函数将数据添加到列表的后面，而<code class="fe lf lg lh li b">push_front</code>函数将数据添加到列表的前面。下面是两个演示如何使用这些函数的例子(在这个例子之后，我将只展示代码片段，而不是完整的程序):</p><pre class="mn mo mp mq gt mt li mu mv aw mw bi"><span id="f57f" class="mx lk it li b gy my mz l na nb">#include &lt;iostream&gt;<br/>#include &lt;list&gt;|<br/>using namespace std;</span><span id="edd8" class="mx lk it li b gy nc mz l na nb">int main()<br/>{<br/>  list&lt;string&gt; names;<br/>  string name;<br/>  for (int i = 1; i &lt;= 5; i++) {<br/>    cout &lt;&lt; "Enter a name: ";<br/>    getline(cin, name);<br/>    names.push_back(name);<br/>  }<br/>  list&lt;int&gt; grades;<br/>  int grade;<br/>  for (int i = 1; i &lt;= 5; i++) {<br/>    cout &lt;&lt; "Enter a grade: ";<br/>    cin &gt;&gt; grade;<br/>    grades.push_front(grade);<br/>  }<br/>  return 0;<br/>}</span></pre><h1 id="fc9b" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">访问汇总列表数据</h1><p id="311f" class="pw-post-body-paragraph kg kh it ki b kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ml lb lc ld im bi translated">列表中的数据只能通过范围<code class="fe lf lg lh li b">for</code>循环或迭代器来访问。以下是这两种技术的示例:</p><pre class="mn mo mp mq gt mt li mu mv aw mw bi"><span id="8bd3" class="mx lk it li b gy my mz l na nb">int main()<br/>{<br/>  list&lt;string&gt; names {"John", "Paul", "George", "Ringo"};<br/>  list&lt;int&gt; grades{81, 77, 92, 100, 88};<br/>  cout &lt;&lt; "The names list:" &lt;&lt; endl &lt;&lt; endl;<br/>  for (string name : names) {<br/>    cout &lt;&lt; name &lt;&lt; " ";<br/>  }<br/>  cout &lt;&lt; endl &lt;&lt; endl &lt;&lt; "The grades list: " &lt;&lt; endl &lt;&lt; endl;<br/>  for (auto iter = grades.begin(); iter != grades.end();<br/>       iter++) {<br/>    cout &lt;&lt; *iter &lt;&lt; " ";<br/>  }<br/>  return 0;<br/>}</span></pre><p id="26cf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">没有办法随机访问列表元素或使用索引技术。这些技术违背了链表的整体思想，在链表中，对一个元素的访问导致通过链接对下一个元素的访问。</p><h1 id="3e91" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">访问列表的前面和后面</h1><p id="e299" class="pw-post-body-paragraph kg kh it ki b kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ml lb lc ld im bi translated"><code class="fe lf lg lh li b"> list</code>类具有访问列表前端和后端的特殊函数。令人惊讶的是，这些函数被称为<code class="fe lf lg lh li b">front</code>和<code class="fe lf lg lh li b">back</code>。下面是它们的使用方法:</p><pre class="mn mo mp mq gt mt li mu mv aw mw bi"><span id="d73c" class="mx lk it li b gy my mz l na nb">int main()<br/>{<br/>  list&lt;string&gt; names {"John", "Paul", "George", "Ringo"};<br/>  list&lt;int&gt; grades{81, 77, 92, 100, 88};<br/>  cout &lt;&lt; "The front of names is: " &lt;&lt; names.front() &lt;&lt; endl;<br/>  cout &lt;&lt; "The back of names is: " &lt;&lt; names.back()<br/>       &lt;&lt; endl &lt;&lt; endl;<br/>  cout &lt;&lt; "The front of grades is: " &lt;&lt; grades.front()<br/>       &lt;&lt; endl;<br/>  cout &lt;&lt; "The back of grades is: " &lt;&lt; grades.back() &lt;&lt; endl;<br/>return 0;</span><span id="d92b" class="mx lk it li b gy nc mz l na nb">}</span></pre><h1 id="7c41" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">对列表进行排序</h1><p id="ab09" class="pw-post-body-paragraph kg kh it ki b kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ml lb lc ld im bi translated">分类类对象的方式不同于其他容器，比如vectors。该类将sort函数作为成员函数，这意味着它是从一个<code class="fe lf lg lh li b">list</code>类实例中调用的，而不是使用容器迭代器作为一般sort函数的参数。</p><p id="0556" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是<code class="fe lf lg lh li b">sort</code>成员函数如何处理<code class="fe lf lg lh li b">list</code>对象:</p><pre class="mn mo mp mq gt mt li mu mv aw mw bi"><span id="2758" class="mx lk it li b gy my mz l na nb">int main()<br/>{<br/>  list&lt;string&gt; names {"John", "Paul", "George", "Ringo"};<br/>  list&lt;int&gt; grades{81, 77, 92, 100, 88};<br/>  names.sort();<br/>  for (string name : names) {<br/>    cout &lt;&lt; name &lt;&lt; " "; // displays George John Paul Ringo<br/>  }<br/>  cout &lt;&lt; endl &lt;&lt; endl;<br/>  grades.sort();<br/>  for (int grade : grades) {<br/>    cout &lt;&lt; grade &lt;&lt; " "; // displays 77 81 88 92 100<br/>  }<br/>  return 0;<br/>}</span></pre><h1 id="b831" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">从列表中删除数据</h1><p id="05a7" class="pw-post-body-paragraph kg kh it ki b kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ml lb lc ld im bi translated">有几种技术可以从列表实例中删除数据。两个常用的成员函数分别从列表的前面和后面移除元素，<code class="fe lf lg lh li b">pop_front</code>和<code class="fe lf lg lh li b">pop_back</code>。它们是这样工作的:</p><pre class="mn mo mp mq gt mt li mu mv aw mw bi"><span id="157b" class="mx lk it li b gy my mz l na nb">int main()<br/>{<br/>  list&lt;string&gt; names {"John", "Paul", "George", "Ringo"};<br/>  list&lt;int&gt; grades{81, 77, 92, 100, 88};<br/>  names.pop_front();<br/>  for (string name : names) {<br/>    cout &lt;&lt; name &lt;&lt; " "; // displays Paul George Ringo<br/>  }<br/>  cout &lt;&lt; endl &lt;&lt; endl;<br/>  grades.pop_back();<br/>  for (int grade : grades) {<br/>    cout &lt;&lt; grade &lt;&lt; " "; // displays 77 92 100 88<br/>  }<br/>  return 0;<br/>}</span></pre><p id="6290" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您也可以使用<code class="fe lf lg lh li b">remove</code>功能删除特定值。它是这样工作的:</p><pre class="mn mo mp mq gt mt li mu mv aw mw bi"><span id="7478" class="mx lk it li b gy my mz l na nb">int main()<br/>{<br/>  list&lt;int&gt; grades{81, 77, 92, 100, 88};<br/>  grades.remove(100);<br/>  for (int grade : grades) {<br/>    cout &lt;&lt; grade &lt;&lt; " "; // displays 81 77, 92 88<br/>  }<br/>  return 0;<br/>}</span></pre><p id="c6ac" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">请记住，当删除一个值时，内部数据结构只需要重新排列两三个链接，而不需要执行任何数据移位。</p><p id="266e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一种从列表中删除数据的方法是<code class="fe lf lg lh li b">erase</code>函数。这个函数将删除迭代器位置的元素。这个函数是这样工作的:</p><pre class="mn mo mp mq gt mt li mu mv aw mw bi"><span id="2d61" class="mx lk it li b gy my mz l na nb">int main()<br/>{<br/>  list&lt;string&gt; beatles {"John", "Paul", "George", "Pete", "Ringo"};<br/>  auto iter = beatles.begin();<br/>  while (*iter != "Pete") {<br/>    iter++;<br/>  }<br/>  beatles.erase(iter);<br/>  for (string name : beatles) {<br/>    cout &lt;&lt; name &lt;&lt; " ";<br/>  }<br/>  return 0;<br/>}</span></pre><p id="eb1c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">程序移动一个迭代器，直到找到想要移除的元素，然后调用<code class="fe lf lg lh li b">erase</code>函数移除它。</p><p id="4679" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一个从列表中移除元素的函数是<code class="fe lf lg lh li b">remove_if</code>。该函数将根据条件删除元素。下面是一个使用lambda函数剔除一些随机生成的数字的示例:</p><pre class="mn mo mp mq gt mt li mu mv aw mw bi"><span id="2d88" class="mx lk it li b gy my mz l na nb">#include &lt;iostream&gt;<br/>#include &lt;list&gt;<br/>#include &lt;cstdlib&gt;<br/>#include &lt;ctime&gt;<br/>using namespace std;</span><span id="ee87" class="mx lk it li b gy nc mz l na nb">int main()<br/>{<br/>  srand(time(0));<br/>  list&lt;int&gt; numbers;<br/>  for (int i = 1; i &lt;= 20; i++) {<br/>    numbers.push_back(rand() % 100 + 1);<br/>  }<br/>  for (int n : numbers) {<br/>    cout &lt;&lt; n &lt;&lt; " ";<br/>  }<br/>  numbers.remove_if([](int number) { return number &lt; 50;});<br/>  cout &lt;&lt; endl &lt;&lt; endl;<br/>  for (int n : numbers) {<br/>    cout &lt;&lt; n &lt;&lt; " ";<br/>  }<br/>  return 0;<br/>}</span></pre><p id="ea9b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个程序的输出是:</p><pre class="mn mo mp mq gt mt li mu mv aw mw bi"><span id="c0ad" class="mx lk it li b gy my mz l na nb">7 38 76 67 26 74 52 53 65 26 56 82 66 90 83 55 88 34 8 73</span><span id="3d56" class="mx lk it li b gy nc mz l na nb">76 67 74 52 53 65 56 82 66 90 83 55 88 73</span></pre><p id="af6e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以通过调用<code class="fe lf lg lh li b">clear </code>函数来删除列表中的所有元素。</p><h1 id="97bc" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">插入到列表中</h1><p id="196b" class="pw-post-body-paragraph kg kh it ki b kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ml lb lc ld im bi translated"><code class="fe lf lg lh li b">insert</code>功能允许您将数据插入列表。但是，您必须使用迭代器来指定插入点。这个函数有好几个版本，但我只演示最简单的版本，它在迭代器位置之前插入一个元素。下面是一个例子:</p><pre class="mn mo mp mq gt mt li mu mv aw mw bi"><span id="d182" class="mx lk it li b gy my mz l na nb">int main()<br/>{<br/>  list&lt;string&gt; beatles {"John", "Paul", "George", "Ringo"};<br/>  auto iter = beatles.begin();<br/>  while (*iter != "Ringo") {<br/>    iter++;<br/>  }<br/>  string fifthBeatle = "Pete";<br/>  beatles.insert(iter, fifthBeatle);<br/>  for (string name : beatles) {<br/>    cout &lt;&lt; name &lt;&lt; " ";<br/>    // displays John Paul George Pete Ringo<br/>  }<br/>  return 0;<br/>}</span></pre><h1 id="2588" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">使用列表作为集合</h1><p id="7ab5" class="pw-post-body-paragraph kg kh it ki b kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ml lb lc ld im bi translated">在这篇文章的最后，我将演示如何将一个列表作为一个集合来使用。函数<code class="fe lf lg lh li b">unique</code>从列表中移除所有重复的元素。有了这个功能，当你需要这个功能的时候，你可以把一个列表变成一个特殊情况下的集合。通常，当你需要一个集合时，你应该使用set类。</p><p id="1242" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个使用<code class="fe lf lg lh li b">unique</code>功能的例子:</p><pre class="mn mo mp mq gt mt li mu mv aw mw bi"><span id="e30e" class="mx lk it li b gy my mz l na nb">void printList(list&lt;int&gt; lst) {<br/>  for (int n : lst) {<br/>    cout &lt;&lt; n &lt;&lt; " ";<br/>  }<br/>}</span><span id="c4db" class="mx lk it li b gy nc mz l na nb">int main()<br/>{<br/>  list&lt;int&gt; numbers;<br/>  srand(time(0));<br/>  for (int i = 1; i &lt;= 50; i++) {<br/>    numbers.push_back(rand() % 100 + 1);<br/>  }<br/>  numbers.sort();<br/>  printList(numbers);<br/>  numbers.unique();<br/>  cout &lt;&lt; endl &lt;&lt; endl;<br/>  printList(numbers);<br/>  return 0;<br/>}</span></pre><h1 id="5af7" class="lj lk it bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">清单上的最后一个词</h1><p id="6517" class="pw-post-body-paragraph kg kh it ki b kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ml lb lc ld im bi translated">您不应该使用<code class="fe lf lg lh li b">list</code>类来满足正常的数据存储需求。向量和数组更适合一般用途。但是，如果您的应用程序需要大量的插入和删除，可以考虑使用<code class="fe lf lg lh li b">list</code>类，因为它比使用一个在连续内存中存储数据的容器更有效。</p><p id="f94c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢您阅读这篇文章，请给我发电子邮件，提出您的意见和建议。</p></div></div>    
</body>
</html>