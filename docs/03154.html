<html>
<head>
<title>Heap Sort Algorithm 101</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">堆排序算法101</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/heap-sort-algorithm-101-dec2aefb0b11?source=collection_archive---------8-----------------------#2020-04-22">https://levelup.gitconnected.com/heap-sort-algorithm-101-dec2aefb0b11?source=collection_archive---------8-----------------------#2020-04-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="463f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">欢迎来到我关于奇妙、神秘、神奇的<strong class="jp ir">堆排序算法(HSA) </strong>的教程，我们将使用JavaScript来构建它。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/4416c48e385db1282e02a91c8f8e7ea8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*UszbgX5KX8PdDxJf.jpg"/></div></div></figure><h1 id="82e4" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">介绍</h1><p id="741b" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">老实说，对于任何不熟悉二分搜索法树、最大/最小堆和其他相关概念的初级开发人员来说，这将是一个非常紧张的演练。我的建议是，每一步都要慢慢来，并且在阅读材料的时候，要确保对基础知识掌握得很扎实。正如塞缪尔·L·杰克逊雄辩地指出的那样…</p><blockquote class="ma mb mc"><p id="2a3e" class="jn jo md jp b jq jr js jt ju jv jw jx me jz ka kb mf kd ke kf mg kh ki kj kk ij bi translated"><strong class="jp ir"><em class="iq">抓紧自己的屁股。</em></strong>(侏罗纪公园，1993)</p></blockquote><h1 id="3bc5" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">回顾</h1><p id="da83" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">好了，首先，在我们能够正确定义什么是<strong class="jp ir"> <em class="md">堆排序算法</em> </strong>及其工作原理之前，我们将回顾以下概念和数据结构:</p><ul class=""><li id="b794" class="mh mi iq jp b jq jr ju jv jy mj kc mk kg ml kk mm mn mo mp bi translated"><strong class="jp ir">数组</strong></li><li id="3d5e" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated"><strong class="jp ir">二叉树</strong></li><li id="5c46" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated"><strong class="jp ir">堆</strong></li><li id="0933" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated"><strong class="jp ir">二进制堆</strong></li></ul><h2 id="6b0e" class="mv ky iq bd kz mw mx dn ld my mz dp lh jy na nb ll kc nc nd lp kg ne nf lt ng bi translated">数组</h2><p id="b476" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated"><strong class="jp ir"> <em class="md">数组</em> </strong>数据结构是地球上每一个Web开发人员都应该熟悉的一个基本概念。当数组在我们的<strong class="jp ir"><em class="md"/></strong>HSA中实现时，它们不仅会在实践中使用，还会起到某种<em class="md">概念上的</em>作用。</p><p id="6868" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通常，我们使用数组来存储信息(在我们的例子中是整数)。我们通常认为数组是内存中不同位置的数据列表，可以直接访问(使用索引)或使用循环和内置方法访问。</p><p id="bc55" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这种情况下，我们将正常地访问数组<strong class="jp ir"> <em class="md">中的信息，但是</em> </strong>我们将把它的值看作是<strong class="jp ir"> <em class="md">二叉树</em> </strong>中的元素。从概念的角度来看，我们将把每个值分配给树上的一个特定节点。</p><h2 id="f41e" class="mv ky iq bd kz mw mx dn ld my mz dp lh jy na nb ll kc nc nd lp kg ne nf lt ng bi translated">二叉树</h2><p id="d6b8" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">为了快速复习，我们将定义并解释什么是<strong class="jp ir"> <em class="md">二叉树</em> </strong>。</p><p id="85d1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="md">二叉树</em> </strong>:一种数据结构，从一个有值的根节点开始，有(最多)两个子节点，通常称为左右节点，它们有自己的值。</p><p id="5dad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">二叉树可以作为JavaScript中的对象初始化，如下所示:</p><pre class="km kn ko kp gt nh ni nj nk aw nl bi"><span id="491d" class="mv ky iq ni b gy nm nn l no np"><strong class="ni ir">let tree = {<br/>  val: 2, <br/>  left: {<br/>    val: 3,<br/>    left: { <br/>      val: 4,<br/>      left: { ...},<br/>      right: { ...}    <br/>    },<br/>    right: { <br/>      val: 5,<br/>      left: { ...},<br/>      right: { ...}<br/>    }<br/>  }, <br/>  right: {<br/>    val: 7,<br/>    left: { <br/>      val: 8,<br/>      left: { ...},<br/>      right: { ...}    <br/>    },<br/>    right: { <br/>      val: 9,<br/>      left: { ...},<br/>      right: { ...}<br/>    }<br/>  }<br/>};</strong></span><span id="37c9" class="mv ky iq ni b gy nq nn l no np">            <strong class="ni ir">// The resulting binary tree would like this</strong></span><span id="2648" class="mv ky iq ni b gy nq nn l no np"><strong class="ni ir">                                   2<br/>                                 /    \<br/>                                3      7<br/>                              /  \    /  \<br/>                             4    5  8    9</strong></span></pre><p id="8c78" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然这种形式很常见，并且您可以实现一个二分搜索法来遍历和操作它，但是我们将使用一个数组来保存二叉树的值，而不是一个对象。这里有一个说明性的例子来阐明<strong class="jp ir">在我们的实现中</strong>数组将如何表示一个二叉树。</p><pre class="km kn ko kp gt nh ni nj nk aw nl bi"><span id="8be9" class="mv ky iq ni b gy nm nn l no np">                      <strong class="ni ir">let array = [5,2,1,4,3];<br/>             <br/>         // What the array represents as a binary tree structure</strong></span><span id="ce15" class="mv ky iq ni b gy nq nn l no np"><strong class="ni ir">                    [5]           5<br/>                                 / \<br/>                   [2,1]        2   1<br/>                               / \<br/>                   [4,3]      4   3</strong></span></pre><p id="aaf1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">值得注意的是，树的每个水平层总是从<strong class="jp ir">顶部到底部</strong>和从<strong class="jp ir">左侧到右侧</strong>布置，并且包含从<strong class="jp ir">到每个<strong class="jp ir">父(或根)节点</strong>的两个子节点</strong>。</p><p id="c127" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用基于代码的方法，我们可以使用一些简单的公式来确定父节点和子节点在数组中的位置。我们可以从假设数组的开头(index 0，integer 5)是根节点开始。</p><pre class="km kn ko kp gt nh ni nj nk aw nl bi"><span id="596d" class="mv ky iq ni b gy nm nn l no np"><strong class="ni ir">let array = [5,2,1,4,3];<br/>indexes --&gt; [0,1,2,3,4]</strong></span><span id="8f31" class="mv ky iq ni b gy nq nn l no np"><strong class="ni ir">// parent node <br/>let p = (index - 1) / 2;<br/> <br/>// left child node<br/>let left = 2 * p + 1;</strong></span><span id="ca52" class="mv ky iq ni b gy nq nn l no np"><strong class="ni ir">// right child node<br/>let right = 2 * p + 2;</strong></span></pre><h2 id="99c6" class="mv ky iq bd kz mw mx dn ld my mz dp lh jy na nb ll kc nc nd lp kg ne nf lt ng bi translated">堆/二进制堆</h2><p id="2248" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">因此，我们已经确定了如何在我们的实现中使用和概念化数组。<strong class="jp ir"> <em class="md">但是什么是堆，和二叉树有什么关系？</em>T11】</strong></p><p id="51cf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="md">堆</em> </strong>是一种基于树的数据结构，满足以下两个定义之一的标准。并且<strong class="jp ir"> <em class="md">二进制堆</em> </strong>是采用如上定义的二叉树形式的堆。</p><p id="0145" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">最大堆二叉树</strong>:每个父节点的值都大于等于其子节点的值。</p><pre class="km kn ko kp gt nh ni nj nk aw nl bi"><span id="347c" class="mv ky iq ni b gy nm nn l no np"><strong class="ni ir">                                   15<br/>                                 /    \<br/>                               12      18<br/>                              /  \    /  \<br/>                             6    9  4    1</strong></span></pre><p id="4a0c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">最小堆二叉树</strong>:每个父节点的值小于等于其子节点的值。</p><pre class="km kn ko kp gt nh ni nj nk aw nl bi"><span id="6838" class="mv ky iq ni b gy nm nn l no np"><strong class="ni ir">                                   3<br/>                                 /    \<br/>                                8      5<br/>                              /  \    /  \<br/>                             10  18  12   15</strong></span></pre><p id="04ae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如您可能已经猜到的那样，<strong class="jp ir"> <em class="md">堆排序算法</em> </strong>的最终目标是使用<strong class="jp ir"> <em class="md"> Max或Min heap </em> </strong>对值列表进行排序。一个警告是，二进制堆可以包含值不按顺序排列的兄弟(子节点)(参见上面的例子)。我们的实现必须考虑到这一点，这样我们就不会得到一个满足二进制堆标准的数组<strong class="jp ir"> <em class="md">，但不满足升序列表标准的数组</em></strong><strong class="jp ir"><em class="md"/></strong>。</p></div><div class="ab cl nr ns hu nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="ij ik il im in"><h1 id="c6ec" class="kx ky iq bd kz la ny lc ld le nz lg lh li oa lk ll lm ob lo lp lq oc ls lt lu bi translated">履行</h1><p id="9bc9" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">好了，我们已经完成了回顾，希望您对与我们的实现相关的数据结构和概念有一个适当的理解。我们将概述实际的Max Heap函数的两个实现(<strong class="jp ir"> <em class="md">迭代和递归</em> </strong>)，并一步一步地浏览整个代码库。</p><h2 id="e951" class="mv ky iq bd kz mw mx dn ld my mz dp lh jy na nb ll kc nc nd lp kg ne nf lt ng bi translated">交换功能</h2><p id="9e22" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">我们将把我们的代码库分成几个不同的函数，以保持整洁和可读性。我们将定义一个<strong class="jp ir"> <em class="md">交换函数</em> </strong>，它将交换数组中的值(<strong class="jp ir"><em class="md"/></strong>)。我们将在整个实现中重用这个函数。</p><pre class="km kn ko kp gt nh ni nj nk aw nl bi"><span id="0a77" class="mv ky iq ni b gy nm nn l no np"><strong class="ni ir">const swap = (input, i, j) =&gt; {<br/>  const temp = input[i];<br/>  input[i] = input[j];<br/>  input[j] = temp;<br/>};</strong></span></pre><h2 id="6430" class="mv ky iq bd kz mw mx dn ld my mz dp lh jy na nb ll kc nc nd lp kg ne nf lt ng bi translated">迭代最大堆函数</h2><p id="8384" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">迭代方法几乎等同于递归实现。主要区别在于函数如何循环或重新初始化，直到执行一个基本用例。下面是迭代最大堆函数的快速分解:</p><ol class=""><li id="0506" class="mh mi iq jp b jq jr ju jv jy mj kc mk kg ml kk od mn mo mp bi translated">初始化一个while循环，该循环将无限期地继续，直到基本情况被触发</li><li id="1322" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk od mn mo mp bi translated">初始化两个子节点和一个跟踪父索引的max变量</li><li id="b02c" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk od mn mo mp bi translated">如果任一个子索引存在于数组的长度范围内，并且其中一个数组中的值大于父索引/最大索引中的值，则创建两个条件，将最大值重新分配到左侧或右侧</li><li id="3b68" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk od mn mo mp bi translated">创建一个基本用例，当父索引没有被重新分配给max变量时，该用例将退出函数</li><li id="09e0" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk od mn mo mp bi translated">用父索引和更新的最大索引调用交换函数</li><li id="89e1" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk od mn mo mp bi translated">将父索引(I)分配给更新的max变量。这有效地将父索引更新为(曾经是)其最大的子节点。</li></ol><pre class="km kn ko kp gt nh ni nj nk aw nl bi"><span id="628c" class="mv ky iq ni b gy nm nn l no np"><strong class="ni ir">const iterativeMaxHeap = (array, i, length) =&gt; {<br/>  while (true) {<br/>    const left = 2 * i + 1;<br/>    const right = 2 * i + 2;<br/>    let max = i;</strong></span><span id="568c" class="mv ky iq ni b gy nq nn l no np"><strong class="ni ir">    if (left &lt; length &amp;&amp; array[left] &gt; array[max]) {<br/>      max = left<br/>    }<br/>  <br/>    if (right &lt; length &amp;&amp; array[right] &gt; array[max]) {<br/>      max = right<br/>    }<br/> <br/>    // Once this condition is met, exit the loop<br/>    if (i === max) {<br/>      break;<br/>    }<br/>   <br/>    swap(array, i, max)<br/>    i = max;<br/>  }<br/>};</strong></span></pre><h2 id="3410" class="mv ky iq bd kz mw mx dn ld my mz dp lh jy na nb ll kc nc nd lp kg ne nf lt ng bi translated">递归最大堆函数</h2><p id="75e4" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">这是<strong class="jp ir">最大堆</strong>函数的递归版本。</p><ol class=""><li id="0c00" class="mh mi iq jp b jq jr ju jv jy mj kc mk kg ml kk od mn mo mp bi translated">初始化一个while循环，该循环将无限期地继续，直到基本情况被触发</li><li id="1a36" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk od mn mo mp bi translated">初始化两个子节点和一个跟踪父索引的max变量</li><li id="e6e7" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk od mn mo mp bi translated">如果任一个子索引存在于数组的长度范围内，并且其中一个数组中的值大于父索引/最大索引中的值，则创建两个条件，将最大值重新分配到左侧或右侧</li><li id="a5e8" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk od mn mo mp bi translated">如果max变量的值已经改变，用max(左或右)索引交换父索引，并再次递归调用<strong class="jp ir"> maxHeap </strong>函数。</li></ol><pre class="km kn ko kp gt nh ni nj nk aw nl bi"><span id="3ed9" class="mv ky iq ni b gy nm nn l no np"><strong class="ni ir">const recursiveMaxHeap = (array, i, length) =&gt; {<br/>    const left = 2 * i + 1;<br/>    const right = 2 * i + 2;<br/>    let max = i;</strong></span><span id="2d1e" class="mv ky iq ni b gy nq nn l no np"><strong class="ni ir">    if (left &lt; length &amp;&amp; array[left] &gt; array[max]) {<br/>      max = left<br/>    }<br/>  <br/>    if (right &lt; length &amp;&amp; array[right] &gt; array[max]) {<br/>      max = right<br/>    }<br/> <br/>    if (i !== max) {<br/>      swap(array, i, max)<br/>      recursiveMaxHeap(array, max, length)</strong><br/>    <strong class="ni ir">}<br/>};</strong></span></pre><h2 id="d106" class="mv ky iq bd kz mw mx dn ld my mz dp lh jy na nb ll kc nc nd lp kg ne nf lt ng bi translated">Heapify函数</h2><p id="2566" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">这个函数从输入数组中创建一个有效的堆。在本例中，我们在循环内部创建了一个<strong class="jp ir"> <em class="md"> Max </em> </strong>堆，但是如果我们愿意，我们也可以创建一个<strong class="jp ir"> <em class="md"> Min </em> </strong>堆。迭代和递归实现在形式上是相同的。下面是一个简单的演练:</p><ol class=""><li id="8639" class="mh mi iq jp b jq jr ju jv jy mj kc mk kg ml kk od mn mo mp bi translated">我们初始化一个从数组中间开始的循环，并准备将<strong class="jp ir"> <em class="md">向后</em> </strong>移动到数组的开始。我们从中间开始，因为<strong class="jp ir"><em class="md">max heap</em></strong><strong class="jp ir"><em class="md">函数</em> </strong>实际上是从第一个索引(或父节点)到最后一个索引(或子节点)创建一个堆。在每个循环之后，我们用任何更大的子节点有效地覆盖父节点，直到整个事情变成有效的<strong class="jp ir"> <em class="md"> Max </em> </strong>堆。</li><li id="a6b9" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk od mn mo mp bi translated">我们调用<strong class="jp ir"> <em class="md"> maxHeap函数</em> </strong>带数组，当前父索引和我们要堆的数组长度。</li></ol><pre class="km kn ko kp gt nh ni nj nk aw nl bi"><span id="4712" class="mv ky iq ni b gy nm nn l no np"><strong class="ni ir">const heapify = (array) =&gt; {<br/>  for (let i = Math.floor(array.length / 2); i &gt;= 0; i--) {<br/>    maxHeap(array, i, array.length)<br/>  }<br/>};</strong></span></pre><h2 id="3848" class="mv ky iq bd kz mw mx dn ld my mz dp lh jy na nb ll kc nc nd lp kg ne nf lt ng bi translated">堆排序函数</h2><p id="d538" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">这是驱动我们整个实现的主要功能。这个函数从输入数组创建一个堆，然后对数组重新排序(就地)以产生一个排序后的数组。</p><ol class=""><li id="37ce" class="mh mi iq jp b jq jr ju jv jy mj kc mk kg ml kk od mn mo mp bi translated">用输入数组的长度初始化<strong class="jp ir"> <em class="md"> len </em> </strong>变量。</li><li id="4793" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk od mn mo mp bi translated">如果数组没有长度，创建一个将退出函数的基本用例</li><li id="7e90" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk od mn mo mp bi translated">我们用数组调用<strong class="jp ir"><em class="md"/></strong>将其转化为<strong class="jp ir"> <em class="md"> Max堆</em> </strong></li><li id="79ff" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk od mn mo mp bi translated">我们向后遍历更新后的数组，并将数组末尾的整数与数组开头的整数进行交换。</li><li id="a7b7" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk od mn mo mp bi translated">将<strong class="jp ir"> <em class="md"> len </em> </strong>变量减1。在调用了<strong class="jp ir"> <em class="md"> swap </em> </strong>函数之后，我们减少这个变量，因为最后一个元素是数组中最大的整数，我们可以认为它已经排序了。在下一个循环中，它将被忽略，不包括在<strong class="jp ir"> <em class="md">交换</em> </strong>或<strong class="jp ir"> <em class="md"> maxHeap </em> </strong>调用中。</li><li id="f5d1" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk od mn mo mp bi translated">用缩短的<strong class="jp ir"><em class="md">【len】</em></strong>调用<strong class="jp ir"> <em class="md"> maxHeap </em> </strong>函数，在数组值<strong class="jp ir"> <em class="md">改变后，保持数组正确堆砌。</em> </strong></li></ol><pre class="km kn ko kp gt nh ni nj nk aw nl bi"><span id="9701" class="mv ky iq ni b gy nm nn l no np"><strong class="ni ir">const heapSort = (array) =&gt; {<br/>  let len = array.length;</strong></span><span id="33dd" class="mv ky iq ni b gy nq nn l no np">  <strong class="ni ir">// If the array doesn't have any values exit the function<br/>  if (!len) {<br/>    return;<br/>  }</strong></span><span id="4eb0" class="mv ky iq ni b gy nq nn l no np"><strong class="ni ir">  heapify(array);</strong></span><span id="60c0" class="mv ky iq ni b gy nq nn l no np"><strong class="ni ir">  for (let i = array.length - 1; i &gt; 0; i--) {<br/>    swap(array, 0, i)<br/>    len--<br/>    maxHeap(array, 0, len)<br/>  }<br/>};</strong></span></pre><p id="2631" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">嘭，我们成功了！这就是用2种略有不同的JavaScript实现的<strong class="jp ir"> <em class="md">堆排序算法</em> </strong>。您可能想知道为什么有人会使用这种排序算法来代替更简单的解决方案？和往常一样，<strong class="jp ir"> <em class="md">时间和空间复杂度</em> </strong>是选择一种算法而不是另一种算法时要考虑的重要因素。</p></div><div class="ab cl nr ns hu nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="ij ik il im in"><h1 id="6062" class="kx ky iq bd kz la ny lc ld le nz lg lh li oa lk ll lm ob lo lp lq oc ls lt lu bi translated">结论</h1><p id="8f7a" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated"><strong class="jp ir"> <em class="md"> HSA </em> </strong>就地改变一个数组<strong class="jp ir">，这意味着它不需要太多内存来完成事情。但是这也意味着它<strong class="jp ir"> <em class="md">改变了</em> </strong>你的输入数组，实际上并没有返回任何新的东西。每个函数都使用一个对内存中数组的<strong class="jp ir"> <em class="md">引用</em> </strong>来操作它的内容。因此，如果你想看到排序后的结果，你需要调用<strong class="jp ir"><em class="md"/></strong>函数后的<strong class="jp ir"><em class="md">console . log()</em></strong>数组，就像这样:</strong></p><pre class="km kn ko kp gt nh ni nj nk aw nl bi"><span id="4fdc" class="mv ky iq ni b gy nm nn l no np"><strong class="ni ir">let array = [2,3,4,2,5,6,3,10];</strong></span><span id="e446" class="mv ky iq ni b gy nq nn l no np"><strong class="ni ir">heapSort(array)</strong></span><span id="2378" class="mv ky iq ni b gy nq nn l no np"><strong class="ni ir">console.log(array) --&gt; [2,2,3,3,4,5,6,10];</strong></span></pre><p id="4d64" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的<strong class="jp ir"> <em class="md">堆排序</em> </strong>函数的这个特性也意味着它不像面向对象的方法那样适合函数式编程范例。因此，当您考虑使用哪种排序算法以及它如何适合您的应用程序时，请记住这一点。</p><p id="c8e2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="md"> HSA </em> </strong>在最好的情况下具有<strong class="jp ir"> O(n log n) </strong>的<strong class="jp ir"> <em class="md">时间复杂度</em> </strong>，在最坏的情况下具有<strong class="jp ir"> O(n) </strong>的时间复杂度。为了与其他时间复杂度进行比较，请看这张图表:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/0e7f14a2e30ad147e6a3556fc2ce892a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/format:webp/0*jRyn1gvJEDaGW8Yf.png"/></div></figure><p id="e333" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了完整地查看我们编写的代码和一堆测试用例，它们可能会帮助您完全理解<strong class="jp ir"> <em class="md">堆排序算法</em> </strong>请看下面的my <strong class="jp ir"> Github Repo </strong>:</p><div class="of og gp gr oh oi"><a href="https://github.com/twjsanderson/heapSort" rel="noopener  ugc nofollow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd ir gy z fp on fr fs oo fu fw ip bi translated">twjsanderson/heapSort</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">这个应用程序是为对堆排序实现的性能感兴趣的初级开发人员设计的…</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">github.com</p></div></div><div class="or l"><div class="os l ot ou ov or ow kv oi"/></div></div></a></div></div><div class="ab cl nr ns hu nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="ij ik il im in"><h1 id="8a78" class="kx ky iq bd kz la ny lc ld le nz lg lh li oa lk ll lm ob lo lp lq oc ls lt lu bi translated">以下是我用来了解堆排序的一些资料:</h1><p id="c39e" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated"><strong class="jp ir">维基百科的文章出人意料地有用— </strong></p><div class="of og gp gr oh oi"><a href="https://en.wikipedia.org/wiki/Heapsort" rel="noopener  ugc nofollow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd ir gy z fp on fr fs oo fu fw ip bi translated">堆排序</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">在计算机科学中，heapsort是一种基于比较的排序算法。Heapsort可以被认为是一种改进的…</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">en.wikipedia.org</p></div></div><div class="or l"><div class="ox l ot ou ov or ow kv oi"/></div></div></a></div><p id="df72" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">查看用其他语言实现的代码— </strong></p><div class="of og gp gr oh oi"><a href="https://www.geeksforgeeks.org/heap-sort/" rel="noopener  ugc nofollow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd ir gy z fp on fr fs oo fu fw ip bi translated">堆排序-极客论坛</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">堆排序是一种基于二进制堆数据结构的比较排序技术。它类似于选择排序…</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">www.geeksforgeeks.org</p></div></div><div class="or l"><div class="oy l ot ou ov or ow kv oi"/></div></div></a></div><p id="837b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">就是这样！感谢阅读。</strong></p></div></div>    
</body>
</html>