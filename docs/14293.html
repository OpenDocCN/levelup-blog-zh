<html>
<head>
<title>On Python’s .append() Time Complexity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Python上。append()时间复杂度</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/on-pythons-append-time-complexity-19dfbff1c87?source=collection_archive---------19-----------------------#2022-11-14">https://levelup.gitconnected.com/on-pythons-append-time-complexity-19dfbff1c87?source=collection_archive---------19-----------------------#2022-11-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5973" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">有这么简单吗？</h2></div><p id="86ed" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Python中最常用的函数之一是<a class="ae le" href="https://docs.python.org/3/tutorial/datastructures.html#more-on-lists" rel="noopener ugc nofollow" target="_blank">列表的追加函数</a>。它所做的非常简单，它会将指定的元素添加到列表的末尾。</p><pre class="lf lg lh li gt lj lk ll bn lm ln bi"><span id="52e3" class="lo lp it lk b be lq lr l ls lt">    &gt;&gt;&gt; a = [1,2,3]<br/>    &gt;&gt;&gt; a.append(4)<br/>    &gt;&gt;&gt; a<br/>    [1, 2, 3, 4]                                                                                                                                     &gt;&gt;&gt; a.append(4)                                                                                                                                                                      &gt;&gt;&gt; a                                                                                                                                                                                [1, 2, 3, 4]</span></pre><p id="13e8" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，我们真的知道它是如何工作的吗？在这里，我将尝试解释它，以及为什么这是一个比我们想象的更昂贵的操作。</p><figure class="lf lg lh li gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi lu"><img src="../Images/7561551280a544ef1fdd0563324e5c36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nEVEeyWRqbJmW_FzxMexnA.jpeg"/></div></div><figcaption class="mc md gj gh gi me mf bd b be z dk translated"><a class="ae le" href="https://pixabay.com/images/id-1544373/" rel="noopener ugc nofollow" target="_blank">图片来源</a></figcaption></figure><p id="ebcd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">尽管这对我们来说是透明的，python的列表有一个固定的分配长度，它总是2的幂。</p><p id="d317" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">每次我们追加一个新元素，如果它合适，这个操作只需要O(1)时间。毕竟，<a class="ae le" href="https://www.geeksforgeeks.org/internal-working-of-the-len-function-in-python/" rel="noopener ugc nofollow" target="_blank"> Python会跟踪列表</a>的长度，所以它不需要遍历列表来了解它的长度。这给我们带来的好处是，它只需要计算需要存储新值的内存地址，这需要恒定的时间。</p><p id="ca48" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">相反，如果我们达到容量，我们将需要加倍分配给列表的空间。这将意味着我们需要将列表的当前内容复制到新的内存空间中，这将花费O(n)时间。</p><p id="b158" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不过，这种操作只是偶尔发生(更具体地说，每次长度都是2的幂)，而且大多数时候。append()将花费O(1)时间，也就是说，这些O(n)操作被分摊到更常见的O(1)操作中。</p><p id="5fce" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用<a class="ae le" href="https://www.cs.cornell.edu/courses/cs3110/2011sp/Lectures/lec20-amortized/amortized.htm" rel="noopener ugc nofollow" target="_blank">聚集方法</a>，我们可以确定一个列表的摊余时间复杂度。append()运算是O(1)。对此的直觉可能如下:为了达到最坏的情况，即O(n)，我们需要执行n次操作(在这种情况下，n是2的幂):直到那时，每次操作花费O(1)时间。这意味着这n次操作大约需要O(2n)时间，也就是O(n)。最后我们可以确定每项操作的摊余成本为O(n) / n = O(1)。</p></div></div>    
</body>
</html>