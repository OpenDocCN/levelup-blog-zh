<html>
<head>
<title>Write Go like a senior engineer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">像高级工程师一样写围棋</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/write-go-like-a-senior-engineer-eee7f03a1883?source=collection_archive---------0-----------------------#2022-12-12">https://levelup.gitconnected.com/write-go-like-a-senior-engineer-eee7f03a1883?source=collection_archive---------0-----------------------#2022-12-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4ec8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">当我开始写围棋的时候，我希望我知道的是</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7efc7984e7883cdb5b45d6900f06c4d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_88b4dUUI3F_Yail.jpg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">Renee French，<a class="ae ky" href="https://creativecommons.org/licenses/by/3.0" rel="noopener ugc nofollow" target="_blank"> CC BY 3.0 </a>，通过维基共享</figcaption></figure><p id="150e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">2018年开始专业写围棋。以下是我开始时希望能告诉自己的话。</p><h1 id="ca6e" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">Go是按值传递的</h1><p id="0b19" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">Go完全是按值传递的。这意味着每个函数接收一个你传入的值的副本。没有例外。</p><p id="bf6a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">算是吧。</p><p id="22af" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您也可以传递指针(从技术上讲，您传递的是指针的值—地址)。通过Go的强类型，你可以对底层指针进行类型检查。</p><p id="eb63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这个例子中，我们通过值来传递<code class="fe mt mu mv mw b">rect</code>结构。该结构进入函数，所有操作都修改传入的值，但原始对象保持不变，因为它不是通过引用传递的。</p><pre class="kj kk kl km gt mx mw my bn mz na bi"><span id="346e" class="nb lw it mw b be nc nd l ne nf">// https://go.dev/play/p/TAiWwsOZ_n6<br/>package main<br/><br/>import "fmt"<br/><br/>type Rectangle struct {<br/>    Width  int<br/>    Height int<br/>}<br/><br/>func DoubleHeight(rect Rectangle) {<br/>    rect.Height = rect.Height * 2<br/>}<br/><br/>func main() {<br/>    rect := Rectangle{<br/>        Width:  10,<br/>        Height: 3,<br/>    }<br/><br/>    // this won't actually modify rect<br/>    DoubleHeight(rect)<br/><br/>    fmt.Println("Width", rect.Width)<br/>    fmt.Println("Height", rect.Height)<br/>}</span></pre><p id="6f82" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个函数没有做我们想要它做的事情。该对象未被更新。</p><p id="7bd7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是我们可以使用指向<code class="fe mt mu mv mw b">rect</code>的指针作为<code class="fe mt mu mv mw b">DoubleHeight</code>函数的参数，并通过引用有效地传递<code class="fe mt mu mv mw b">rect</code> <em class="ms">。</em></p><pre class="kj kk kl km gt mx mw my bn mz na bi"><span id="dc5f" class="nb lw it mw b be nc nd l ne nf">// https://go.dev/play/p/7L5QQtvzdDU<br/>package main<br/><br/>import "fmt"<br/><br/>type Rectangle struct {<br/>    Width  int<br/>    Height int<br/>}<br/><br/>func DoubleHeight(rect *Rectangle) {<br/>    rect.Height = rect.Height * 2<br/>}<br/><br/>func main() {<br/>    rect := Rectangle{<br/>        Width:  10,<br/>        Height: 3,<br/>    }<br/><br/>    // this modifies rect<br/>    DoubleHeight(&amp;rect)<br/><br/>    fmt.Println("Width", rect.Width)<br/>    fmt.Println("Height", rect.Height)<br/>}</span></pre><h1 id="20e2" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">使用(但不要滥用)指针</h1><p id="5787" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">与指针相关的操作符有两个:<code class="fe mt mu mv mw b">*</code>和<code class="fe mt mu mv mw b">&amp;</code>。</p><h2 id="ed91" class="ng lw it bd lx nh ni dn mb nj nk dp mf li nl nm mh lm nn no mj lq np nq ml nr bi translated"><code class="fe mt mu mv mw b">*</code>操作员</h2><p id="e967" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated"><code class="fe mt mu mv mw b">*</code>操作符被称为“指针”操作符。类型<code class="fe mt mu mv mw b">*Rectangle</code>是一个指向<code class="fe mt mu mv mw b">Rectangle</code>实例的指针。声明一个类型为<code class="fe mt mu mv mw b">*Rectangle</code>的参数意味着函数接受“一个指向矩形实例的指针”。</p><pre class="kj kk kl km gt mx mw my bn mz na bi"><span id="a7be" class="nb lw it mw b be nc nd l ne nf">var rect *Rectangle</span></pre><p id="cccc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">指针的零值是<code class="fe mt mu mv mw b">nil</code>。在很多情况下超级有用！但是当你试图在一个空指针上调用函数时，这通常会导致<code class="fe mt mu mv mw b">panic</code>被调用。调试起来很糟糕(稍后会详细介绍)。</p><h2 id="ee20" class="ng lw it bd lx nh ni dn mb nj nk dp mf li nl nm mh lm nn no mj lq np nq ml nr bi translated">&amp;运算符</h2><p id="8fd6" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated"><code class="fe mt mu mv mw b">&amp;</code>操作符(称为“地址”操作符)生成一个指向其操作数的指针。</p><pre class="kj kk kl km gt mx mw my bn mz na bi"><span id="8713" class="nb lw it mw b be nc nd l ne nf">rect := Rectangle{<br/>    Width:  10,<br/>    Height: 3,<br/>}<br/>pntr := &amp;rect</span></pre><p id="3a7a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">要获得指针的基础值，使用<code class="fe mt mu mv mw b">*</code>操作符。这被称为“取消指针引用”</p><pre class="kj kk kl km gt mx mw my bn mz na bi"><span id="f652" class="nb lw it mw b be nc nd l ne nf">// read rect through the pointer<br/>fmt.Println(*pntr)<br/><br/>// set rect through the pointer<br/>*pntr = Rectangle{<br/>    Width: 20,<br/>    Height: 4,<br/>}</span></pre><p id="3f85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你想知道“我应该在这里使用指针吗？”答案很可能是“是的。”如有疑问，请使用指针。</p><h2 id="4e68" class="ng lw it bd lx nh ni dn mb nj nk dp mf li nl nm mh lm nn no mj lq np nq ml nr bi translated">零指针取消引用错误</h2><p id="83d7" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我存在的祸根。</p><p id="fece" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有时当你使用指针时，你会得到这个<code class="fe mt mu mv mw b">panic</code>完全关闭你的程序:</p><pre class="kj kk kl km gt mx mw my bn mz na bi"><span id="245f" class="nb lw it mw b be nc nd l ne nf">panic: runtime error: invalid memory address or nil pointer dereference</span></pre><p id="1f24" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这是因为你试图取消引用一个指针<code class="fe mt mu mv mw b">nil</code>。</p><pre class="kj kk kl km gt mx mw my bn mz na bi"><span id="7640" class="nb lw it mw b be nc nd l ne nf">// https://go.dev/play/p/XjtkrEudRe9<br/>package main<br/><br/>import "fmt"<br/><br/>type Rectangle struct {<br/>    Width  int<br/>    Height int<br/>}<br/><br/>func (r *Rectangle) Area() int {<br/>    return r.Width * r.Height<br/>}<br/><br/>func main() {<br/>    var rect *Rectangle      // default value is nil<br/>    fmt.Println(rect.Area()) // this will panic<br/>}</span></pre><p id="a6d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">修复很容易。在对指针值调用方法之前，可以检查指针值。</p><pre class="kj kk kl km gt mx mw my bn mz na bi"><span id="7706" class="nb lw it mw b be nc nd l ne nf">// https://go.dev/play/p/VM0fdzZjiq_Y<br/>package main<br/><br/>import "fmt"<br/><br/>type Rectangle struct {<br/>    Width  int<br/>    Height int<br/>}<br/><br/>func (r *Rectangle) Area() int {<br/>    return r.Width * r.Height<br/>}<br/><br/>func main() {<br/>    var rect *Rectangle<br/><br/>    if rect != nil {<br/>        fmt.Println(rect.Area())<br/>    } else {<br/>        fmt.Println("rect is nil!")<br/>    }<br/>}</span></pre><p id="3317" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些错误通常很难排除，它们花费了我<em class="ms">小时</em>的时间来寻找bug。如果你决定使用指针，总是<em class="ms">总是</em>检查零值！</p><h1 id="51f7" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">在使用接口的地方声明接口</h1><p id="8a97" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">好的。指针在围棋中非常重要。它们并不是唯一的。但是当JS或Python工程师转换时，接口真的会把他们搞垮。</p><p id="3586" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Go中的接口就像一个约定，它指定了一组方法，类型<em class="ms">必须</em>实现这些方法才能完成约定。例如，如果你有一个名为<code class="fe mt mu mv mw b">Reader</code>的接口，它定义了一个<code class="fe mt mu mv mw b">Read()</code>方法，那么任何实现了<code class="fe mt mu mv mw b">Read()</code>方法的类型都被称为实现了<code class="fe mt mu mv mw b">Reader</code>接口，并且可以在任何需要<code class="fe mt mu mv mw b">Reader</code>的地方使用。</p><p id="2720" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Go中接口的一个很酷的地方是一个类型可以实现多个接口。例如，如果您有一个名为<code class="fe mt mu mv mw b">File</code>的类型，它实现了<code class="fe mt mu mv mw b">Reader</code>和<code class="fe mt mu mv mw b">Writer</code>接口，那么您可以在需要<code class="fe mt mu mv mw b">Reader</code>或<code class="fe mt mu mv mw b">Writer</code>的任何地方使用<code class="fe mt mu mv mw b">File</code>，或者甚至在需要实现这两个接口的任何地方使用。这使得编写灵活且可重用的代码变得容易。</p><p id="d3a6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Go中接口的另一个很酷的地方是，你可以用它们来定义通用的算法或函数来处理多种类型。例如，您可以编写一个排序函数，它将一个<code class="fe mt mu mv mw b">sort.Interface</code>作为输入，并且可以对实现所需方法的任何类型进行排序。</p><pre class="kj kk kl km gt mx mw my bn mz na bi"><span id="e0e8" class="nb lw it mw b be nc nd l ne nf">package sort<br/><br/>type Interface interface{<br/>    Len()           int<br/>    Less (i , j)    bool<br/>    Swap(i , j int)<br/>}</span></pre><p id="f596" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这使得编写高度灵活和可定制的代码变得容易。您可以创建一个自定义类型(如<code class="fe mt mu mv mw b">UserList</code>或<code class="fe mt mu mv mw b">PostFeed</code>)并定义这些方法，并将其用于标准库。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><h2 id="5a8c" class="ng lw it bd lx nh ni dn mb nj nk dp mf li nl nm mh lm nn no mj lq np nq ml nr bi translated">秘密武器</h2><p id="b6ed" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">我不知道为什么Go不能开箱即用。但是它有很多功能不是现成的(例如错误处理)。我只能假设这是有意的设计。</p><p id="e292" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">问题是这样的:</p><p id="1e1e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你如何保证一个结构符合一个接口的所有方法？</p><pre class="kj kk kl km gt mx mw my bn mz na bi"><span id="39e8" class="nb lw it mw b be nc nd l ne nf">type SomeInterface interface {<br/>    Method()<br/>}<br/><br/>type Implementation struct{}<br/><br/>func (*Implementation) Method() { fmt.Println("Hello, World!") }<br/><br/>var _ SomeInterface = (*Implementation)(nil) // ← this is the line</span></pre><p id="1aa0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这最后一行确保<code class="fe mt mu mv mw b">Implementation</code>满足<code class="fe mt mu mv mw b">SomeInterface</code>的所有方法，如果<code class="fe mt mu mv mw b">SomeInterface</code>添加了<code class="fe mt mu mv mw b">Implementation</code>不满足的方法，<em class="ms">将无法编译</em>。</p><p id="559b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae ky" href="https://go.dev/play/p/RTbbdlBitJE" rel="noopener ugc nofollow" target="_blank">我已经为这个概念创建了一个更完整的演示，你可以在go.dev → </a>上玩玩</p><h1 id="7381" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">更喜欢桌面测试，但不要过度</h1><p id="1403" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">当你测试一个函数时，你实际上只是改变了输入和期望输出。Go允许您使用表测试(或表驱动测试)以一种非常直接的方式来完成这项工作。</p><p id="bc68" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们从我们想要测试的代码开始。它有点乱，但它在我们的系统中运行着一个关键的功能，所以在不知道它确实如我们所愿的情况下，我们不想碰它。</p><pre class="kj kk kl km gt mx mw my bn mz na bi"><span id="80b9" class="nb lw it mw b be nc nd l ne nf">package main<br/><br/>import "strings"<br/><br/>func ToSnakeCase(str string) string {<br/>    // step 0: handle empty string<br/>    if str == "" {<br/>        return ""<br/>    }<br/><br/>    // step 1: CamelCase to snake_case<br/>    for i := 0; i &lt; len(str); i++ {<br/>        if str[i] &gt;= 'A' &amp;&amp; str[i] &lt;= 'Z' {<br/>            if i == 0 {<br/>                str = strings.ToLower(string(str[i])) + str[i+1:]<br/>            } else {<br/>                str = str[:i] + "_" + strings.ToLower(string(str[i])) + str[i+1:]<br/>            }<br/>        }<br/>    }<br/><br/>    // step 2: remove spaces<br/>    str = strings.ReplaceAll(str, " ", "")<br/><br/>    // step 3: remove double-underscores<br/>    str = strings.ReplaceAll(str, "__", "_")<br/><br/>    return str<br/>}</span></pre><p id="8d53" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可能希望测试大范围的输入，以确保得到正确的输出。不要为此编写单独的测试，而是使用表格测试来获得同样的结果，一个更清晰、更易于维护的结果。</p><pre class="kj kk kl km gt mx mw my bn mz na bi"><span id="bda9" class="nb lw it mw b be nc nd l ne nf"><br/>package main<br/><br/>import "testing"<br/><br/>func TestToSnakeCase(t *testing.T) {<br/>    type testCase struct {<br/>        description string<br/>        input       string<br/>        expected    string<br/>    }<br/><br/>    testCases := []testCase{<br/>        {<br/>            description: "empty string",<br/>            input:       "",<br/>            expected:    "",<br/>        },<br/>        {<br/>            description: "single word",<br/>            input:       "Hello",<br/>            expected:    "hello",<br/>        },<br/>        {<br/>            description: "two words (camel case)",<br/>            input:       "HelloWorld",<br/>            expected:    "hello_world",<br/>        },<br/>        {<br/>            description: "two words with space",<br/>            input:       "Hello World",<br/>            expected:    "hello_world",<br/>        },<br/>        {<br/>            description: "two words with space and underscore",<br/>            input:       "Hello_World",<br/>            expected:    "hello_world",<br/>        },<br/>    }<br/><br/>    for _, tc := range testCases {<br/>        t.Run(tc.description, func(t *testing.T) {<br/>            actual := ToSnakeCase(tc.input)<br/>            if actual != tc.expected {<br/>                t.Errorf("expected %s, got %s", tc.expected, actual)<br/>            }<br/>        })<br/>    }<br/>}</span></pre><p id="e93b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些测试用例真的很好读！</p><h2 id="ec15" class="ng lw it bd lx nh ni dn mb nj nk dp mf li nl nm mh lm nn no mj lq np nq ml nr bi translated">何时避免桌面测试</h2><p id="14c9" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">一个很好的试金石是:如果你在实际的测试调用中进行逻辑分支，你要么不应该使用表测试，要么你的函数太复杂，应该被分解。</p><p id="9f0f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个例子并不太难理解(尽管它不是很好的代码)，但是它仍然是一个代码味道，可能表明一个设计不良的函数。</p><pre class="kj kk kl km gt mx mw my bn mz na bi"><span id="7e1c" class="nb lw it mw b be nc nd l ne nf">// this is BAD<br/>for _, tc := range testCases {<br/>    t.Run(tc.description, func(t *testing.T) {<br/>        result, err := SomeOverlyComplexFunction(tc.input)<br/><br/>        if err == nil {<br/>            if tc.expectedResult != result {<br/>                t.Errorf("expected %v, got %v", tc.expectedResult, result)<br/>            }<br/>        } else {<br/>            if !strings.Contains(err.Error(), tc.expectedErr.Error()) {<br/>                t.Errorf("expected error to be %s, got %s", tc.expectedErr.Error(), err.Error())<br/>            }<br/>        }<br/>    })<br/>}</span></pre><h1 id="35e0" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">其他资源</h1><p id="69bc" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">有效的围棋是新围棋工程师的起点。即使在使用这门语言多年之后，它仍然是我的一个永恒的书签。</p><div class="nu nv gp gr nw nx"><a href="https://go.dev/doc/effective_go" rel="noopener  ugc nofollow" target="_blank"><div class="ny ab fo"><div class="nz ab oa cl cj ob"><h2 class="bd iu gy z fp oc fr fs od fu fw is bi translated">有效的Go-Go编程语言</h2><div class="oe l"><h3 class="bd b gy z fp oc fr fs od fu fw dk translated">围棋是一门新的语言。虽然它借鉴了现有语言的思想，但它有一些不寻常的属性，使它变得有效…</h3></div><div class="of l"><p class="bd b dl z fp oc fr fs od fu fw dk translated">go.dev</p></div></div><div class="og l"><div class="oh l oi oj ok og ol ks nx"/></div></div></a></div></div><div class="ab cl om on hx oo" role="separator"><span class="op bw bk oq or os"/><span class="op bw bk oq or os"/><span class="op bw bk oq or"/></div><div class="im in io ip iq"><h1 id="203c" class="lv lw it bd lx ly ot ma mb mc ou me mf jz ov ka mh kc ow kd mj kf ox kg ml mm bi translated">分级编码</h1><p id="113a" class="pw-post-body-paragraph kz la it lb b lc mn ju le lf mo jx lh li mp lk ll lm mq lo lp lq mr ls lt lu im bi translated">感谢您成为我们社区的一员！在你离开之前:</p><ul class=""><li id="6d3d" class="oy oz it lb b lc ld lf lg li pa lm pb lq pc lu pd pe pf pg bi translated">👏为故事鼓掌，跟着作者走👉</li><li id="0eed" class="oy oz it lb b lc ph lf pi li pj lm pk lq pl lu pd pe pf pg bi translated">📰更多内容请查看<a class="ae ky" href="https://levelup.gitconnected.com/?utm_source=pub&amp;utm_medium=post" rel="noopener ugc nofollow" target="_blank">升级编码刊物</a></li><li id="a8db" class="oy oz it lb b lc ph lf pi li pj lm pk lq pl lu pd pe pf pg bi translated">🔔关注我们:<a class="ae ky" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">推特</a> | <a class="ae ky" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a> | <a class="ae ky" href="https://newsletter.levelup.dev" rel="noopener ugc nofollow" target="_blank">时事通讯</a></li></ul><p id="6e31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">🚀👉<a class="ae ky" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">加入升级人才集体，找到一份神奇的工作</strong> </a></p></div></div>    
</body>
</html>