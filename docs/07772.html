<html>
<head>
<title>Storage Roadmap: Targeting Android 30</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">存储路线图:瞄准Android 30</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/storage-roadmap-targeting-android-30-73927be58804?source=collection_archive---------13-----------------------#2021-03-08">https://levelup.gitconnected.com/storage-roadmap-targeting-android-30-73927be58804?source=collection_archive---------13-----------------------#2021-03-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4ad0" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">献给所有拖延的Android开发人员，他们在瞄准SDK 30之前几乎没有时间迁移存储</h2></div><p id="ae7c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我一直觉得Android上众多的存储选项非常复杂。随着Android Q上getExternalStorageDir()的最新弃用，它只会变得更加混乱。这就是为什么我想从Android Q开始为Android开发者提供一个可视的存储位置概览。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/d328979c811cb87a2afbeec4be29b086.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JPQCoKfs985AMAvdbUSHCg.jpeg"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk translated">为你的应用选择合适的存储位置。<a class="ae lr" href="https://unsplash.com/@reskual?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">安德里亚·利昂</a>在<a class="ae lr" href="https://unsplash.com/s/photos/species?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><p id="ef93" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通常，存储数据有三种选择:</p><ul class=""><li id="6926" class="ls lt iq kh b ki kj kl km ko lu ks lv kw lw la lx ly lz ma bi translated">应用偏好</li><li id="81d1" class="ls lt iq kh b ki mb kl mc ko md ks me kw mf la lx ly lz ma bi translated">数据库(SQLite、房间、领域)</li><li id="9b9f" class="ls lt iq kh b ki mb kl mc ko md ks me kw mf la lx ly lz ma bi translated">储存；储备</li></ul><p id="afbc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后一个是我们最感兴趣的。可以从以下方面来看:</p><ol class=""><li id="bff8" class="ls lt iq kh b ki kj kl km ko lu ks lv kw lw la mg ly lz ma bi translated">内存储器</li><li id="883f" class="ls lt iq kh b ki mb kl mc ko md ks me kw mf la mg ly lz ma bi translated">主外部存储器</li><li id="2d94" class="ls lt iq kh b ki mb kl mc ko md ks me kw mf la mg ly lz ma bi translated">辅助外部存储器</li></ol><p id="44a1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">随着Android target SDK 30的临近，你必须决定你的应用程序的目的是什么，以及哪种存储最适合你的需求。<strong class="kh ir">下面的信息图将帮助你做出决定。</strong></p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi mh"><img src="../Images/fbf52079619b825222aa82026e725577.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GL_2-nbBRh5sfv6112Cnow.png"/></div></div></figure><p id="259c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">大多数不得不处理遗留代码的Android开发人员可能都遇到过<em class="mi">getexternalstreatirectory()</em>请求，这些请求需要直接访问外部设备存储。一旦你的应用程序开始针对Android SDK 30，修改后的用户隐私将不再允许这一点。如果您的目标是较低的SDK，您仍然可以在清单中使用<em class="mi">requestlegacyexternalstarge</em>标志，但随着Android 12将于夏末发布，这种解决方法很快就会到期。</p><p id="def3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，您必须决定:是否可以将所有内容都移到主外部存储，并用<em class="mi"> getExternalFilesDir()替换所有的<em class="mi">getexternalstrauredirectory()</em>调用。</em>也许是时候对您的存储给予更多考虑，并决定哪些文件和图像需要保留在用户的设备上，哪些可以缓存？或者，用户根本不需要访问你的应用程序的文件，你可以将所有内容存储在内部应用程序的存储中，而不被任何人看到？</p><p id="fb00" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">虽然所有这些都是可能的选择，如果选择正确，将使你的应用程序更可持续，但更合理的情况是，你仍然必须使用共享存储，以便数据在你的应用程序卸载后仍然存在，并且还可以被其他应用程序访问。然后你将需要使用更复杂的替代方案，比如<strong class="kh ir"> MediaStore、存储访问框架(SAF) </strong>或者，如果你对机器学习感兴趣的话——<strong class="kh ir">BlobStorageManager</strong>。这些选项将要求您处理比简单选项多一点的权限，但也会让您在处理数据时更加灵活。</p><p id="e879" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，记住所有这些信息，选择最适合您的目的的存储选项，并在为时已晚之前重构所有这些<em class="mi">getexternalstrauredirectory()</em>调用！</p></div></div>    
</body>
</html>