# 在 Java 中正确使用静态类

> 原文：<https://levelup.gitconnected.com/are-you-correctly-using-static-classes-in-java-51b1f8dff40f>

## 使用具有静态 Java 类功能的库似乎简单明了，除非…

![](img/72c3c107b8b976fc3588fb012d746c1e.png)

让我从一个事件开始

我们正在 Spring Boot 应用程序中进行支付集成，这里有一个示例代码

```
Stripe.apiKey = "sk_test_4eC39HqLyjWDarjtT1zdp7dc";

Map<String, Object> params = new HashMap<>();
params.put(
  "description",
  "My First Test Customer (created for API docs)"
);

Customer customer = Customer.create(params);
```

看起来像一个简单的代码块，除非你注意到发生在静态方法`Customer.create(params)`上的`create`

你可能会问，这有什么错？

首先，静态类的单元测试变得很困难。是的，你可以使用 PowerMock 类的工具，但是不推荐使用。我将在我的另一篇文章中进一步阐述这一点

其次，更新灾难。一个晴朗的日子条纹团队决定提供一个强制性的更新，由于一个安全修复和所有的支付使用以前的版本都失败了。

所以我们开始更新库并面对这些问题

1.  新的库不是向后兼容的，所以我们必须重写代码
2.  重写代码是另一件痛苦的事情，因为所有的静态调用都存在于整个应用程序中
3.  不仅仅是输入，处理、返回和处理数据的方式也发生了变化。这意味着我们必须在多个地方重新设计业务逻辑和数据处理逻辑
4.  整个过程花费了大约 1 个专门的 sprint，有 3 个开发人员从事迁移和回归测试。(附:既然一切都变了，权力嘲弄也失败了)

## 我们学到了什么？

1.  正如《T2》中的陈述所说，单身是个大麻烦
2.  它在代码上创建了紧密耦合，对代码进行任何更改都变得非常困难
3.  在库更新的情况下，回归测试会因为方法签名本身的改变而失败
4.  由于静态引用代码迁移的耗时性，许多团队或项目对执行升级犹豫不决
5.  如果我们想把我们的服务提供者从 Stripe 换成别的什么，那么我们会遇到更大的麻烦，因为我们的整个代码都是通过使用它们提供的静态类、异常和模型类与 Stripe 紧密耦合的

## 解决方法是什么？

解决方案简单明了，

1.  围绕第三方库的静态类编写一个包装器
2.  不要在应用程序中直接使用库提供的类
3.  永远不要传播库提供的异常
4.  围绕你的包装类或接口而不是库编写测试用例。也就是说，不要模仿 Stripe(静态类)的响应，而是模仿你定义为包装器的接口或类。这样，即使你改变了你的底层库，你的依赖代码也不会改变，因为你只是用其他库重写实现。

## 让我们看一个样本代码

然后在您的实际代码中，您使用了`PaymentRepository`而不是`StripePaymentRepositoryImpl`,并且您所有的代码更改都被限制在一个类中

它还简化了测试用例，因为现在你只需要验证或模拟你的接口的结果，当你。改变图书馆

此外，通过解耦异常和 DTO(或模型)类，您完全摆脱了代码其余部分对库的任何依赖，并且使任何迁移或更改变得更加容易

在我即将发表的文章中，我将详细讨论设计模式的知识如何能够简化我们的日常编码，而不会导致开发过程中的任何重大开销