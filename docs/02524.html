<html>
<head>
<title>JavaScript Function Construction</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript函数构造</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/function-construction-whats-your-function-5a282b81fc62?source=collection_archive---------10-----------------------#2020-03-19">https://levelup.gitconnected.com/function-construction-whats-your-function-5a282b81fc62?source=collection_archive---------10-----------------------#2020-03-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9ad1" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">构建基本函数构造函数</h2></div><p id="6658" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">第1部分</strong> | <strong class="kh ir"> </strong> <a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/function-construction-part-2-f6a711075b11">第2部分</a> <strong class="kh ir"> </strong> | <a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/javascript-function-construction-part-3-d673ff247541">第3部分</a> | <a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/javascript-function-construction-part-4-d532f0a5e4af">第4部分</a> | <a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/javascript-function-construction-part-5-90733a0e6369">第5部分</a> | <a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/javascript-function-construction-part-6-72cfd6b18a7c">第6部分</a> | <a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/javascript-function-construction-part-7-17c5661e6ea7">第7部分</a></p><p id="2773" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个旅程中，我们称之为JavaScript，它是我越来越多地使用的最有用的工具之一(如果你可以称之为工具的话),是函数构造器。</p><p id="2a8f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为什么我发现函数构造函数如此有用？因为它们允许我编写更少的代码，并且更有效地使用我正在编写的代码。函数构造器还允许我封装特定于我要执行的调用或操作的变量、属性或函数，并确保无论他们要做什么都不会开始搞乱我项目的其他部分。</p><p id="4cc4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">许多库(比如jQuery)大量使用函数构造函数，如果你想看看专业人士是如何做的，我强烈建议你看看jQuery的源代码。它是开源的和免费的，在他们的主页上有没有评论都可以得到。</p><p id="5087" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">函数构造函数对于划分变量、函数和上下文环境非常有用，我想在项目的不同部分使用它们。</p><p id="8a78" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设我在代码中的3或4个不同地方向服务器发出了相同的POST请求。对于每个请求，我要写3到4遍同样的15到20行。</p><p id="2be7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我可以在一个函数构造函数中编写一次请求，将该对象导入到我发出请求的地方，调用绑定到我导入的对象的函数，然后用一两行代码调用该函数，而不是每次我想从服务器中检索数据时都写出请求。</p><p id="a647" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我可能还是编程新手，我在这个我们称之为JavaScript的旅程中的道路才刚刚开始，但是我要做一个大胆的声明。一个声明可能会冒犯那些拥有知识的人，我可能有一天希望获得:</p><p id="52c0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">函数构造函数是闭包的精髓，是JavaScript中函数式编程的巅峰。</p><p id="6ae9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们开始吧。</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h2 id="b559" class="lj lk iq bd ll lm ln dn lo lp lq dp lr ko ls lt lu ks lv lw lx kw ly lz ma mb bi translated">于是它开始了</h2><p id="3083" class="pw-post-body-paragraph kf kg iq kh b ki mc jr kk kl md ju kn ko me kq kr ks mf ku kv kw mg ky kz la ij bi translated">撇开戏剧不谈，让我们言归正传，定义什么是函数构造函数。函数构造器是一个普通的老式函数，用于构造对象。这听起来并不特别，从表面上看，也不是。</p><p id="5245" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">只有当我们添加一个非常特殊、难以捉摸的关键词时，魔法才会开始</p><p id="c3da" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">“THIS”关键字在函数构造函数中使用时，是对创建它的对象的引用。它允许我们从我们正在编写的函数中为正在创建的对象分配属性。这也允许我们从对象本身内部变异或改变对象的属性。</p><p id="6b60" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为什么这很重要？</p><p id="ee18" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们看一个基本的例子:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="7efc" class="lj lk iq mm b gy mq mr l ms mt">function Person(firstname, lastname) {<br/> this.firstname = firstname<br/> this.lastname = lastname<br/>}</span></pre><p id="5235" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里我们有一个函数叫做Person。它接受两个参数，然后将这两个参数设置为函数中定义的属性值。但它也使用了“THIS”关键字。</p><p id="8e92" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">“THIS”所做的是将属性绑定到创建它的对象。如果我们console.log() 'THIS '并调用该函数，我们可以看看' THIS '在做什么:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="16e4" class="lj lk iq mm b gy mq mr l ms mt">function Person(firstname, lastname) {<br/> this.firstname = firstname<br/> this.lastname = lastname<br/>}</span><span id="0561" class="lj lk iq mm b gy mu mr l ms mt">console.log(this)</span><span id="5560" class="lj lk iq mm b gy mu mr l ms mt">Person()</span></pre><p id="45dd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">控制台将会显示所有这些内容:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="4f66" class="lj lk iq mm b gy mq mr l ms mt">&lt;ref *1&gt; Object [global] {<br/> global: [Circular *1],<br/> clearInterval: [Function: clearInterval],<br/> clearTimeout: [Function: clearTimeout],<br/> setInterval: [Function: setInterval],<br/> setTimeout: [Function: setTimeout] {<br/> [Symbol(util.promisify.custom)]: [Function (anonymous)]<br/> },<br/> queueMicrotask: [Function: queueMicrotask],<br/> clearImmediate: [Function: clearImmediate],<br/> setImmediate: [Function: setImmediate] {<br/> [Symbol(util.promisify.custom)]: [Function (anonymous)]<br/> },<br/> firstname: undefined,<br/> lastname: undefined<br/>}</span></pre><p id="a438" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么发生了什么？</p><p id="7e2c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们看到一个名为“global”的对象，其中充满了一大堆你可能以前见过的相当常见的函数。</p><p id="241c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你在网络浏览器中执行这个功能，你会看到更多的功能。</p><p id="e781" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们看到的是全局执行上下文。什么是全局执行上下文？</p><p id="4d51" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是我几周前写的一篇博客的摘录:</p><blockquote class="mv mw mx"><p id="1119" class="kf kg my kh b ki kj jr kk kl km ju kn mz kp kq kr na kt ku kv nb kx ky kz la ij bi translated">全球环境正是你所认为的那样。它是每次运行Javascript文件时创建的默认执行上下文。全局执行上下文执行重要的功能:它创建一个全局对象，其中包含一大堆方法和变量，并且它将执行上下文中的“this”关键字设置为该全局对象。在函数之外编写的任何东西都是在全局执行上下文中编写的，或者说是在全局上下文中。如果您曾经尝试在全局上下文中访问“this ”,然后尝试在一个对象中访问“this ”,您会注意到您会得到两个非常不同的结果。</p></blockquote><p id="96e9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为什么在函数中写“THIS”时，我们会看到全局执行上下文？</p><p id="b18b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">嗯，我们在全球范围内调用Person函数。如果在全局对象(窗口)调用一个函数，“THIS”指向全局执行上下文。</p><p id="0712" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还可以在底部看到我们的两个属性名和姓。</p><p id="392e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那很好。非常好。但这不是我们想要的。</p><p id="3fd7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们希望创建一个新对象，其中“名字”和“姓氏”作为键/值对出现。</p><p id="eb49" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以让我们解决这个问题。</p><p id="1e59" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以尝试使用关键字“new”创建一个具有该函数的新对象，并将其存储到变量中。然后我们可以console.log()变量' john '来看看它是否工作:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="bfe1" class="lj lk iq mm b gy mq mr l ms mt">function Person(firstname, lastname) {<br/> this.firstname = firstname<br/> this.lastname = lastname</span><span id="2d4b" class="lj lk iq mm b gy mu mr l ms mt"> console.log(‘inside the function:’, this)<br/>}</span><span id="cf66" class="lj lk iq mm b gy mu mr l ms mt">var john = new Person()</span><span id="0567" class="lj lk iq mm b gy mu mr l ms mt">console.log(‘outside the function:’, john)</span><span id="eada" class="lj lk iq mm b gy mu mr l ms mt">--------------------</span><span id="0359" class="lj lk iq mm b gy mu mr l ms mt">&gt;&gt; inside the function: Person { firstname: undefined, lastname: undefined }<br/>&gt;&gt; outside the function: Person { firstname: undefined, lastname: undefined }</span></pre><p id="7e58" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们现在看到，当我们从函数内部调用“THIS ”,并使用存储在变量中的“new”关键字创建一个对象时，执行上下文发生了变化，因为Person函数是在“NEW”关键字的上下文中调用的。</p><p id="5c7c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">“THIS”现在指向我们正在创建的对象，由于JavaScript在每次调用函数时都会创建一个新的执行上下文，所以执行上下文会将“THIS”变量指向正在创建的新的空对象，并自动返回该对象。</p><p id="e025" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它是一个构造对象的函数。</p><p id="b034" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一个函数构造器…你可能会说。</p><p id="5c7b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们对此进行一些扩展。</p><p id="508c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还可以向对象传递一些参数，这样我们就可以去掉那些“未定义”的值:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="c232" class="lj lk iq mm b gy mq mr l ms mt">function Person(firstname, lastname) {<br/> this.firstname = firstname<br/> this.lastname = lastname<br/>}</span><span id="8f1b" class="lj lk iq mm b gy mu mr l ms mt">var john = new Person(‘john’, ‘smith’)</span><span id="e7d6" class="lj lk iq mm b gy mu mr l ms mt">console.log(‘Object:’, john)</span><span id="09e8" class="lj lk iq mm b gy mu mr l ms mt">--------------------</span><span id="5d17" class="lj lk iq mm b gy mu mr l ms mt">&gt;&gt; Object: Person { firstname: ‘john’, lastname: ‘smith’ }</span></pre><p id="78d6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为所有函数都是JavaScript中的对象，所以我们也可以访问我们用成员访问操作符(或点符号)创建的“名字”和“姓氏”属性:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="9c17" class="lj lk iq mm b gy mq mr l ms mt">console.log(john.firstname)</span><span id="7a77" class="lj lk iq mm b gy mu mr l ms mt">--------------------</span><span id="3672" class="lj lk iq mm b gy mu mr l ms mt">&gt;&gt; john</span></pre><p id="a26a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="3862" class="lj lk iq mm b gy mq mr l ms mt">console.log(john.lastname)</span><span id="1ff0" class="lj lk iq mm b gy mu mr l ms mt">--------------------</span><span id="4076" class="lj lk iq mm b gy mu mr l ms mt">&gt;&gt; smith</span></pre><p id="52d0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还可以…这就是事情开始变得有趣的地方… <br/>向我们的函数构造函数添加一个函数:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="1402" class="lj lk iq mm b gy mq mr l ms mt">function Person(firstname, lastname) {<br/> this.firstname = firstname<br/> this.lastname = lastname<br/> this.hello = function() {<br/> return ‘Hello, ‘ + this.firstname + ‘ ‘ + this.lastname + ‘.’<br/> }<br/>}</span></pre><p id="52ef" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后访问并调用该函数:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="91dd" class="lj lk iq mm b gy mq mr l ms mt">console.log(john.hello())</span><span id="474a" class="lj lk iq mm b gy mu mr l ms mt">--------------------</span><span id="9f56" class="lj lk iq mm b gy mu mr l ms mt">&gt;&gt; Hello, john smith.</span></pre><p id="953b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们有一个函数，它创建一个对象，这个对象创建一个函数，这个函数也是一个对象…</p><p id="2a45" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">是的，没错。</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h2 id="f95e" class="lj lk iq bd ll lm ln dn lo lp lq dp lr ko ls lt lu ks lv lw lx kw ly lz ma mb bi translated">自定义时间函数构造</h2><p id="81dd" class="pw-post-body-paragraph kf kg iq kh b ki mc jr kk kl md ju kn ko me kq kr ks mf ku kv kw mg ky kz la ij bi translated">所以我一直不喜欢JavaScript的新Date()特性的工作方式。</p><p id="d5ea" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我总是发现自己不得不一次又一次地格式化和重新格式化，如果有一种简单的方法来获得当前时间的格式化字符串，那就太好了。</p><p id="30f4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以，让我们开始吧。</p><p id="005f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们修改上面的例子，并尝试让构造函数只输出新的Date()函数:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="eb80" class="lj lk iq mm b gy mq mr l ms mt">function getTime() {<br/>  const date = new Date()</span><span id="0ce0" class="lj lk iq mm b gy mu mr l ms mt">  this.now = function() {<br/>  return date<br/> }<br/>}</span><span id="3eac" class="lj lk iq mm b gy mu mr l ms mt">var time = new getTime()</span><span id="16f8" class="lj lk iq mm b gy mu mr l ms mt">console.log(time.now())</span><span id="1ffc" class="lj lk iq mm b gy mu mr l ms mt">--------------------</span><span id="dc0a" class="lj lk iq mm b gy mu mr l ms mt">&gt;&gt; 2020–03–19T00:33:46.820Z</span></pre><p id="4c47" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好极了。但是我们想把这个格式化。</p><p id="a97f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">没问题。我们正在编写的now()函数是一个普通的JavaScript函数，因此我们可以赋值变量、执行布尔比较、连接字符串等等……就像我们通常会做的那样</p><p id="dcc3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">目前，它只是作为JavaScript内置的新Date()函数的别名，所以让我们让它做得更多一点:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="2b30" class="lj lk iq mm b gy mq mr l ms mt">function getTime() {<br/> const date = new Date()</span><span id="440d" class="lj lk iq mm b gy mu mr l ms mt">this.now = function() {</span><span id="0426" class="lj lk iq mm b gy mu mr l ms mt"><em class="my">  // We can convert the built in getHours() method to conform to a 12 hour clock by taking the current time and finding it’s remainder when divided by 12 with the modulo operator<br/>  // Example: If it is 13:00 on a 24 hour clock, and 13 % 12 leaves a remainder of 1, then that means it is 1 o’clock</em></span><span id="0550" class="lj lk iq mm b gy mu mr l ms mt">  let hours = date.getHours() % 12</span><span id="304f" class="lj lk iq mm b gy mu mr l ms mt"><em class="my">  // If the current hour is less than or equal to 12, return AM, otherwise return PM</em></span><span id="5d26" class="lj lk iq mm b gy mu mr l ms mt">  let ampm = date.getHours() &lt;= 12 ? ‘AM’ : ‘PM’</span><span id="d50b" class="lj lk iq mm b gy mu mr l ms mt"><em class="my">  // Simple alias for the built in getMinutes() method</em></span><span id="9ae6" class="lj lk iq mm b gy mu mr l ms mt">  let minutes = date.getMinutes()</span><span id="8d36" class="lj lk iq mm b gy mu mr l ms mt"><em class="my">  // On a 24 hour clock, if it is midnight, it is 24:00. 24 % 12 is 0, which we don’t want.</em><br/> <em class="my"> // So we can use a ternary operator to check if it is midnight, and if it is, return 12</em></span><span id="52ed" class="lj lk iq mm b gy mu mr l ms mt">  hours = hours ? hours : 12</span><span id="f752" class="lj lk iq mm b gy mu mr l ms mt"><em class="my">  // Simple formatting that adds a zero before any minute of an hour that is less than 10.</em></span><span id="bc2a" class="lj lk iq mm b gy mu mr l ms mt">  minutes = minutes &lt; 10 ? ‘0’+ minutes : minutes</span><span id="291a" class="lj lk iq mm b gy mu mr l ms mt">  // Everything we just wrote rolled into one nice simple string</span><span id="a53a" class="lj lk iq mm b gy mu mr l ms mt">  let time = hours + ‘:’ + minutes + ‘ ‘ + ampm</span><span id="e115" class="lj lk iq mm b gy mu mr l ms mt">  return time<br/> }<br/>}</span><span id="023e" class="lj lk iq mm b gy mu mr l ms mt">var time = new getTime()</span><span id="2798" class="lj lk iq mm b gy mu mr l ms mt">console.log(time.now())</span></pre><p id="436f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">无论何时运行该脚本，它都将返回当前时间:</p><figure class="mh mi mj mk gt nd gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/e41d87387009df4e0a8a0a8a2beb52f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:738/format:webp/1*pUeo6J_v1_RRwjj5pB7W0w.jpeg"/></div></figure><p id="dd95" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">很好。</p><p id="6ab5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript使用你电脑的内部时钟来实现日期功能，所以你可以摆弄电脑上的时钟来测试它是否正常工作。</p><p id="b8ff" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也可以继续。我们可以对这个构造函数使用任意多的函数，而不用担心它会如何影响这个函数之外的代码。没有副作用:</p><p id="48fb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们添加当月的当前日期:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="8522" class="lj lk iq mm b gy mq mr l ms mt">this.day = function() {<br/> let day = date.getDate()</span><span id="9e5f" class="lj lk iq mm b gy mu mr l ms mt"> return day<br/>}</span></pre><p id="61e8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">月份:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="9a77" class="lj lk iq mm b gy mq mr l ms mt">this.month = function() {<br/> let month = date.getMonth()</span><span id="acb6" class="lj lk iq mm b gy mu mr l ms mt"><em class="my"> // We need to add 1 to the month number because in JavaScript, month numbers start at zero, not 1; just like the indices of an array</em><br/> return (month + 1)<br/>}</span></pre><p id="aba3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">和年份:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="9652" class="lj lk iq mm b gy mq mr l ms mt">this.year = function() {<br/>  let currentYear = date.getFullYear()</span><span id="e5cd" class="lj lk iq mm b gy mu mr l ms mt">  return currentYear<br/> }</span></pre><p id="d66a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些都很简单，但对接下来的事情很重要。</p><p id="d8db" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以再添加一个函数，引用我们在函数构造函数中编写的所有方法，并将所有这些方法组合成一个方法，为我们提供一个格式正确的日期字符串:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="a905" class="lj lk iq mm b gy mq mr l ms mt">this.formattedDate = function() {<br/> let time = this.now()<br/> let day = this.day()<br/> let month = this.month()<br/> let year = this.year()</span><span id="dead" class="lj lk iq mm b gy mu mr l ms mt"> const formattedDate = ‘(‘ + time + ‘)’ + ‘ ‘ + month + ‘/’ + day + ‘/’ + year</span><span id="c3c3" class="lj lk iq mm b gy mu mr l ms mt"> return formattedDate<br/>}</span></pre><p id="faef" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这将为我们提供一个很好的字符串，我们可以在任何想要显示当前时间的地方使用它:</p><figure class="mh mi mj mk gt nd gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/8f6e408cbb14edaf435bc7ab52fa11ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:978/format:webp/1*4OdW1dMJdxNUHwHF0bQO8Q.jpeg"/></div></figure><p id="6066" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过调用两行代码在任何地方重用这个构造函数:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="f12d" class="lj lk iq mm b gy mq mr l ms mt">var time = new getTime()</span><span id="cb6e" class="lj lk iq mm b gy mu mr l ms mt">console.log(time.formattedDate())</span></pre><p id="b727" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还可以通过调用我们构建的所有其他函数来获取日期的各个部分，这使得这个函数构造器非常方便，我们再也不用担心摸索新的date()了。</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h2 id="50ac" class="lj lk iq bd ll lm ln dn lo lp lq dp lr ko ls lt lu ks lv lw lx kw ly lz ma mb bi translated">任务完成</h2><p id="ba06" class="pw-post-body-paragraph kf kg iq kh b ki mc jr kk kl md ju kn ko me kq kr ks mf ku kv kw mg ky kz la ij bi translated">今天在这个博客上工作了大半天后，我意识到将我们新的getTime函数构造器的构造，以及如何在其他脚本或其他框架(如React)中导出/导入它分成两篇博文可能是个好主意。这个结果比我预期的要大得多，其他几个例子都不太好。我安装的用于React的Postgres模块引起了很多问题。</p><p id="017d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我写的下一篇博客中，我将详细介绍如何在普通JS中重用这个函数构造函数，以及React，并可能为构造函数本身添加更多的功能。我可能还有一两个其他的例子，我真的不知道。</p><p id="6bf2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我希望这篇博客是对函数构造器的一个很好的介绍，我期待着在我写的下一篇博客中扩展我在这里详述的一切。感谢您的阅读。</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h1 id="541e" class="nh lk iq bd ll ni nj nk lo nl nm nn lr jw no jx lu jz np ka lx kc nq kd ma nr bi translated">JavaScript函数构造</h1><p id="44d8" class="pw-post-body-paragraph kf kg iq kh b ki mc jr kk kl md ju kn ko me kq kr ks mf ku kv kw mg ky kz la ij bi translated"><strong class="kh ir">第1部分</strong> | <strong class="kh ir"> </strong> <a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/function-construction-part-2-f6a711075b11">第2部分</a> <strong class="kh ir"> </strong> | <a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/javascript-function-construction-part-3-d673ff247541">第3部分</a> | <a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/javascript-function-construction-part-4-d532f0a5e4af">第4部分</a> | <a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/javascript-function-construction-part-5-90733a0e6369">第5部分</a> | <a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/javascript-function-construction-part-6-72cfd6b18a7c">第6部分</a> | <a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/javascript-function-construction-part-7-17c5661e6ea7">第7部分</a></p></div></div>    
</body>
</html>