<html>
<head>
<title>Nested If-Else statements are the problem, not If-Else per se</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">嵌套的If-Else语句是问题所在，而不是If-Else本身</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/deeply-nested-if-else-statements-are-the-problem-not-if-else-per-se-e4f689eb07f1?source=collection_archive---------5-----------------------#2020-10-01">https://levelup.gitconnected.com/deeply-nested-if-else-statements-are-the-problem-not-if-else-per-se-e4f689eb07f1?source=collection_archive---------5-----------------------#2020-10-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/92a4a6c7fe874660a718ed4b45a48425.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Vta0-s6VyOaYUuU9"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">尼克·潘普基迪斯在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="b1d1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你是一个老练的程序员，那么你永远不要使用If-Else语句，否则你就是一个黑客。至少我一直是这么看的。也许这些文章确实有一定的道理，如果它们的措辞不那么极端，也许我不会读它们。</p><p id="5c05" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不可避免地，对这些文章的回应指出，任何值得在计算机上做的事情都涉及到决策。事实上，计算机做的任何事情都涉及决策。</p><p id="a466" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，假设你去当地的全球银行自动取款机，把你的银行卡放进去。如果你是当地的全球银行客户，你可以继续输入密码，否则自动取款机会询问你是否同意收取5美元的服务费。如果你同意，你继续输入密码，否则自动柜员机释放你的卡，你就可以继续你的快乐之路。</p><p id="4865" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您输入了正确的PIN，您可以继续交易选择，否则您还有一两次机会输入正确的PIN。如果你做了太多不正确的尝试，自动柜员机“捕获”你的卡。</p><p id="2294" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">顺便说一下，关于使用反向PIN向警察报警小偷的事情完全是一个神话；我从未听过银行员工建议客户不要为他们的pin选择回文。所以ATM软件要考虑的条件分支就少了一个。</p><p id="9450" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">假设您输入了正确的PIN，并选择从您的储蓄账户中提取80美元。如果您的储蓄账户余额为80美元或以上(如果收取服务费，则为85美元)，那么自动柜员机将会支付80美元，否则交易将因资金不足而被拒绝。</p><p id="2c9a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是，如果您选择从您的支票账户中提取80美元或85美元，并且如果余额不足，但是如果您有一个相关的用于透支转账的储蓄账户，可以弥补赤字，那么自动取款机将提取80美元，您的支票账户余额将被清零，并且您的储蓄账户余额将减少透支额。</p><p id="ca11" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在芯片级甚至像Java虚拟机(JVM)这样的虚拟机级，还需要做出更多、更小的决策。其中一个更小的决定可能是这样的:如果寄存器A等于0，那么转到第773行，否则转到下一行。</p><p id="816d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">实际上，在芯片级没有如果-否则。该指令实际上可能类似于“跳零”，其中如果寄存器保存0，则发生跳转。则指令指针被改变到指定的跳转目的地。否则，芯片只是照常递增指令指针。</p><p id="2ab6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">也许你听说过Goto语句不好。在更高级的编程语言中也是如此。对于虚拟机来说，它们是必不可少的。因此，举例来说，JVM指令集包括用于<code class="fe le lf lg lh b">goto</code>和<code class="fe le lf lg lh b">goto_w</code>的操作码。</p><p id="fd6e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Java也将<code class="fe le lf lg lh b">goto</code>作为保留关键字，但是没有指定含义或语义。这是因为Java有一些有用的抽象概念，对于人类程序员来说更容易理解，比如函数调用。</p><p id="17d8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们当然可以争论哪个Java流控制更好。可以肯定地说，<code class="fe le lf lg lh b">break</code>和<code class="fe le lf lg lh b">continue</code>并不比被抢占的Goto语句好多少。</p><p id="892c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当Martin Odersky创建Scala时，他采用了一些Java特性，而忽略了其他特性。Scala中检查异常的概念？消失了，除了一个为了与Java互操作的注释。开关盒故障？在Scala的Match-Case中找不到。</p><p id="de31" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于Scala中的循环？并没有完全消失，而是被Java程序员在使用之前可能需要学习的东西所取代。打破继续？存在，但以这种方式阻止他们的使用。</p><p id="e235" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Scala有If-Else，Odersky甚至扩展了它在Java中的用途。我认为If-Else本身并不是一件坏事。</p><p id="8c0a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">回到前面的ATM场景，假设我们试图将ATM软件实现为一个单独的<code class="fe le lf lg lh b">main()</code>过程。我们将对If-Else和Switch-Case进行一些深度缩进。</p><p id="8fbf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">即使没有Goto语句，漫长的<code class="fe le lf lg lh b">main()</code>过程也会感觉像意大利面条代码。圈复杂度(衡量有多少可能的执行路径)将会达到顶点。</p><p id="3c07" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我们利用结构化编程和面向对象编程将程序分解成可管理的单元。这些单元中的每一个都应该具有低圈复杂度。</p><p id="055b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">圈复杂度低的单元更容易理解，也更容易维护和更新。</p><p id="fa89" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，一个函数有一个If-Else后跟一个Return，它只有两个可能的执行路径。很好，圈复杂度很低。</p><p id="5e09" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一个只有一层If-Else嵌套的函数可能有足够高的圈复杂度，以至于linter会警告你。如果嵌套涉及过早返回和异常，就更有可能让你的队友甚至你感到困惑。</p><p id="ef56" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">整个程序需要具有完成工作所需的圈复杂度。但是单个的单元应该是简单的，因为这对于理解它们的目的是必要的。有时这意味着一个If-Else，有时有一个更好的方法，根本没有If-Else。</p><p id="5f82" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在银行场景中，我们肯定应该有<code class="fe le lf lg lh b">CheckingAccount</code>和<code class="fe le lf lg lh b">SavingsAccount</code>类。这些可能应该有一个抽象的<code class="fe le lf lg lh b">Account</code>超类，拥有所有子类共有的功能。</p><p id="bf80" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">Account</code>类可能应该有一个<code class="fe le lf lg lh b">processWithdrawal()</code>函数或过程，在帐户余额上有一个If-Else。如果余额对于取款请求对象足够，则取款通过，否则交易被拒绝，可能抛出<code class="fe le lf lg lh b">InsufficientBalanceException</code>。</p><p id="f18c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于透支保护，我们也许能够完全避免If-Else嵌套。我们用<code class="fe le lf lg lh b">CheckingAccount</code>覆盖<code class="fe le lf lg lh b">processWithdrawal()</code>来检查支票账户和相关储蓄账户的总余额。如果这足够了，取款就会成功，余额也会相应地更新。</p><p id="69e8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以至少，多亏了多态性，我们避免了写“<code class="fe le lf lg lh b">if (account instanceof CheckingAccount)</code>”也许我们可以想出一些聪明的方法来使用多态来避免在金额比较上的If-Else。但是……这值得吗？</p><p id="f46d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们被一种心理冲动冲昏头脑，不惜一切代价避免If-Else，我们可能会编写出一个和充满Goto语句的程序一样难以理解的程序。</p><p id="8cad" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">多态性并不是避免If-Else语句的唯一方法。有时候，一个If-Else语句放在合适的位置会帮你省去一堆If-Else语句。</p><p id="0a4a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">作为一个例子，我现在转向一些不那么世俗的东西，但希望仍然有用:分数，如1/2，7/3等。在Java中，我们是这样开始的:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="fa87" class="lq lr it lh b gy ls lt l lu lv">package fractions;</span><span id="2d71" class="lq lr it lh b gy lw lt l lu lv">public class Fraction {</span><span id="ea0b" class="lq lr it lh b gy lw lt l lu lv">    final long numerator, denominator;</span><span id="068b" class="lq lr it lh b gy lw lt l lu lv">    @Override<br/>    public String toString() {<br/>        return numerator + "/" + denominator;<br/>    }</span><span id="82a8" class="lq lr it lh b gy lw lt l lu lv">    public Fraction(long numer, long denom) {<br/>        this.numerator = numer;<br/>        this.denominator = denom;<br/>    }</span><span id="8eaf" class="lq lr it lh b gy lw lt l lu lv">}</span></pre><p id="2f6b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">很简单，对吧？也许<code class="fe le lf lg lh b">numerator</code>和<code class="fe le lf lg lh b">denominator</code>字段应该是私有的并有getters，但这是另一篇文章的讨论内容。这符合我在这里的目的。</p><p id="c64b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们希望能够比较<code class="fe le lf lg lh b">Fraction</code>实例。比如7/8 &lt;是8/7吗？是啊。<code class="fe le lf lg lh b">Fraction</code>类应该实现<code class="fe le lf lg lh b">Comparable&lt;Fraction&gt;</code>。但是在我们到达那一步之前，我们需要由<code class="fe le lf lg lh b">Object</code>授权的旧<code class="fe le lf lg lh b">equals()</code>正常工作。</p><p id="d298" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，让您最喜欢的Java集成开发环境生成<code class="fe le lf lg lh b">equals()</code>和<code class="fe le lf lg lh b">hashCode()</code>覆盖。</p><p id="6661" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你可能知道我要说什么。<code class="fe le lf lg lh b">equals()</code>覆盖将需要If语句。现在我不关心<code class="fe le lf lg lh b">hashCode()</code>(尽管我有<a class="ae kf" href="https://medium.com/@alonso.delarte/understanding-the-generated-hash-code-override-in-java-line-by-line-72b285f8cc74" rel="noopener">一篇关于它的长文</a>)。</p><p id="9157" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Eclipse、NetBeans和IntelliJ IDEA为<code class="fe le lf lg lh b">equals()</code>生成了几乎完全相同的东西，它们在<code class="fe le lf lg lh b">hashCode()</code>中有一点不同。<code class="fe le lf lg lh b">equals()</code>的IntelliJ默认值确实让我大吃一惊。</p><p id="3ca0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这就是IntelliJ生成的内容，除了对我的偏好和缩进调整进行了一些风格上的修改:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="2f0e" class="lq lr it lh b gy ls lt l lu lv">    @Override<br/>    public boolean equals(Object obj) {<br/>        if (this == obj) return true;<br/>        if <strong class="lh iu">(obj == null || this.getClass() != obj.getClass())</strong> <br/>                 return false;<br/>        Fraction other = (Fraction) obj;<br/>        if (this.numerator != other.numerator) return false;<br/>        return this.denominator == other.denominator;<br/>    }</span></pre><p id="d3f8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">提前回报使得Else变得没有必要。加粗的条件通常作为两个单独的If语句来处理(例如，NetBeans如何生成它)。我不认为这改变了圈复杂度的度量。</p><p id="6117" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">尽管如此，这个<code class="fe le lf lg lh b">equals()</code>覆盖有足够多的执行路径，如果不是因为它是从如此熟悉的模板中生成的，我会认为它需要被分解成更小的函数。</p><p id="41dd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">实际上，我们需要<em class="lx">添加</em>执行路径，测试将会显示。使用您喜欢的Java单元测试框架添加<code class="fe le lf lg lh b">FractionTest</code>。我将使用JUnit 5，所以如果使用JUnit 4，您可能需要添加public access修饰符。</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="d7a3" class="lq lr it lh b gy ls lt l lu lv">    @Test<br/>    void testNotLowestTerms() {<br/>        Fraction someFraction = new Fraction(3, 4);<br/>        Fraction sameFraction = new Fraction(6, 8);<br/>        assertEquals(someFraction, sameFraction);<br/>    }</span></pre><p id="f984" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这些是分数，不是音乐拍号，所以应该认为它们是相等的。然而，测试失败了。我们需要一个最大公约数(GCD)函数。叫它<code class="fe le lf lg lh b">gcd()</code>。我把它的实现留给你。</p><p id="fb88" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们重写<code class="fe le lf lg lh b">equals()</code>:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="5453" class="lq lr it lh b gy ls lt l lu lv">    @Override<br/>    public boolean equals(Object obj) {<br/>        // omitting referential equality, null, type checks<br/>        Fraction other = (Fraction) obj;<br/><strong class="lh iu">        long numerA = this.numerator;<br/>        long denomA = this.denominator;<br/>        long d = gcd(numerA, denomA);<br/>        if (d != 1) {<br/>            numerA /= d;<br/>            denomA /= d;<br/>        }<br/>        long numerB = other.numerator;<br/>        long denomB = other.denominator;<br/>        d = gcd(numerB, denomB);<br/>        if (d != 1) {<br/>            numerB /= d;<br/>            denomB /= d;<br/>        }<br/>        if (numerA != numerB) return false;<br/>        return denomA == denomB;<br/></strong>    }</span></pre><p id="c370" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这通过了测试，但是我们已经增加了圈复杂度，并且我们仍然没有覆盖我们需要覆盖的每一种情况。</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="ba73" class="lq lr it lh b gy ls lt l lu lv">    @Test<br/>    void testNegativeDenominator() {<br/>        Fraction someFraction = new Fraction(1, -3);<br/>        Fraction sameFraction = new Fraction(-1, 3);<br/>        assertEquals(someFraction, sameFraction);<br/>    }</span></pre><p id="feaa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">用浮点近似值来比较分数怎么样？</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="5100" class="lq lr it lh b gy ls lt l lu lv">    @Override<br/>    public boolean equals(Object obj) {<br/>        // omitting ref eq, null, type checks<br/>        Fraction other = (Fraction) obj;<br/>        <strong class="lh iu">double approxA = (double) this.numerator <br/>                / this.denominator;<br/>        double approxB = (double) other.numerator <br/>                / other.denominator;<br/>        return approxA == approxB;</strong><br/>    }</span></pre><p id="a5e5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是可行的，它消除了我们添加的If语句，但是它打开了一扇大门，7/0和7/0可能被视为不同的分数，当它们都应该被视为无效分数并且都应该被<code class="fe le lf lg lh b">Fraction</code>构造函数拒绝时。</p><p id="cb0e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">检查它接收的参数是否有效实际上是构造函数的工作。如果<code class="fe le lf lg lh b">denom</code>为0，构造函数应该抛出一个运行时异常，比如<code class="fe le lf lg lh b">ArithmeticException</code>(我有一篇关于在JUnit中测试预期异常的文章)。</p><p id="50e6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可能会问:“保留原始构造函数参数有什么好的理由吗？”我回答说，如果有的话，我想不出那会是什么。所以你建议构造函数应该确保分数是最低的，并且分母是正的。</p><p id="0c71" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在编写了必要的测试之后，下面是我们得出的结论:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="4a87" class="lq lr it lh b gy ls lt l lu lv">    public Fraction(long numer, long denom) {<br/>        <strong class="lh iu">if (denom == 0) {<br/>            String excMsg = "Denominator 0 is not allowed";<br/>            throw new ArithmeticException(excMsg);<br/>        }<br/>        long adjustment = gcd(numer, denom);<br/>        if (denom &lt; 0) {<br/>            adjustment *= -1;<br/>        }</strong><br/>        this.numerator = numer <strong class="lh iu">/ adjustment</strong>;<br/>        this.denominator = denom <strong class="lh iu">/ adjustment</strong>;<br/>    }</span></pre><p id="fe5f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">随着测试的通过，我们可以相信这两个分数都是最低的，所以我们可以将<code class="fe le lf lg lh b">equals()</code>重构回它的原始版本。再次运行所有测试以确保一切正常。</p><p id="ba1d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有一种方法可以去掉构造函数中的第二个If语句，通过使用适当的符号函数。</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="c18b" class="lq lr it lh b gy ls lt l lu lv">    public Fraction(long numer, long denom) {<br/>        // zero denominator check goes here<br/>        long adjustment = gcd(numer, denom) <strong class="lh iu">* Long.signum(denom)</strong>;<br/>        this.numerator = numer / adjustment;<br/>        this.denominator = denom / adjustment;<br/>    }</span></pre><p id="baff" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了消除分母不为零的检查，也许我们可以创建一个类，将一个<code class="fe le lf lg lh b">long</code>封装到一个状态机或其他一些有趣的东西中。这样做值得吗？在我看来，没有。你可以在评论中让我知道你的观点。</p></div></div>    
</body>
</html>