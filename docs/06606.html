<html>
<head>
<title>Integrating GraphQL, Apollo Server, Sequelize-Auto with SQL Server</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将GraphQL、Apollo Server、Sequelize-Auto与SQL Server集成</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/b-crud-operations-with-graphql-apollo-server-sequelize-auto-b-711da1803017?source=collection_archive---------0-----------------------#2020-12-11">https://levelup.gitconnected.com/b-crud-operations-with-graphql-apollo-server-sequelize-auto-b-711da1803017?source=collection_archive---------0-----------------------#2020-12-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="5efe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本教程演示了如何使用Apollo Server设置GraphQL，以及如何使用ORM Sequelize-auto将您的服务器与SQL Server数据库(SSMS)连接起来。</p><p id="256d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以使用Sequelize-auto映射数据库中的任何表。您只需要指定与数据库中的表相匹配的正确的表名。</p><p id="aaa7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您对GraphQL和Apollo-Server的具体功能有初步的了解，那么我们将从创建SQL Server DB开始。我们将使用一个简单的图书馆数据库，只有两个表，即作者和书籍。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi kl"><img src="../Images/e9d56f6e3a093ed47f0dbb2fc5e16022.png" data-original-src="https://miro.medium.com/v2/resize:fit:862/format:webp/1*AOx-jz-fRVChHZ7YHx6Mow.png"/></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">数据库模式(库)</figcaption></figure><p id="8ef7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这里，从我们上面的数据库图中我们不难发现，我们已经定义了两个<strong class="jp ir"><em class="kx"/><em class="kx"/></strong>(Authors表中的<strong class="jp ir"> BookID </strong>为FK _作者_书籍，Books表中的<strong class="jp ir"> AuthorID </strong>为FK _书籍_作者)</p><h1 id="8d73" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated"><strong class="ak">我们将从创建新项目到执行基本操作一步步开始。</strong></h1><p id="b39f" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated"><strong class="jp ir">让我们创建一个新项目。</strong></p><p id="78b5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你没有安装<strong class="jp ir">纱线</strong>，你也可以使用<strong class="jp ir"> npm </strong>。</p><ol class=""><li id="253e" class="mb mc iq jp b jq jr ju jv jy md kc me kg mf kk mg mh mi mj bi translated"><strong class="jp ir">创建新目录并启动项目。</strong></li></ol><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/ff3028f18316b451a81bb2f6b24ada0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1052/format:webp/1*231IMtO1GHQTfTgJJy8Lbg.png"/></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">用<strong class="bd la">纱线</strong>命令启动项目</figcaption></figure><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/beda4d8ce7145b4c18ad914258ec8777.png" data-original-src="https://miro.medium.com/v2/resize:fit:1114/format:webp/1*_bGtr9gFTnqLXQskce2fXA.png"/></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">在全局级别添加<strong class="bd la">创建-节点-项目</strong>依赖关系</figcaption></figure><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/21825f758ccdadd06f38fc8b8a98a0d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:992/format:webp/1*cRfDHfwIbZIdXQKcGKj-2A.png"/></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">用<strong class="bd la"> npm </strong>命令启动项目</figcaption></figure><p id="3f0d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以上两个命令都将生成package.json文件。</p><p id="0d15" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2.<strong class="jp ir">使用yarn添加所需的依赖关系</strong></p><ul class=""><li id="9931" class="mb mc iq jp b jq jr ju jv jy md kc me kg mf kk mn mh mi mj bi translated">纱线添加序列-自动序列-cli序列-g</li><li id="4804" class="mb mc iq jp b jq mo ju mp jy mq kc mr kg ms kk mn mh mi mj bi translated">纱线添加Apollo-服务器图表SQL MSSQL MSSQL 2-保存</li><li id="94a5" class="mb mc iq jp b jq mo ju mp jy mq kc mr kg ms kk mn mh mi mj bi translated">纱线添加节点-D</li></ul><p id="31b1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> 3。使用npm添加所需的依赖关系</strong></p><ul class=""><li id="1bd5" class="mb mc iq jp b jq jr ju jv jy md kc me kg mf kk mn mh mi mj bi translated">npm安装顺序-自动顺序-cli顺序-g</li><li id="e394" class="mb mc iq jp b jq mo ju mp jy mq kc mr kg ms kk mn mh mi mj bi translated">npm安装Apollo-服务器图表SQL MSSQL MSSQL 2-保存</li><li id="8725" class="mb mc iq jp b jq mo ju mp jy mq kc mr kg ms kk mn mh mi mj bi translated">npm安装节点mon -D</li></ul><p id="3647" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以上从属关系，</p><h1 id="6ad6" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">他们将如何帮助我们？</h1><p id="65f0" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">是一个基于promise的Node.js ORM，用于Postgres、MySQL、MariaDB、SQLite和Microsoft SQL Server。它具有可靠的事务支持、关系、急切加载和延迟加载、读取复制等特性。Sequelize遵循<a class="ae mt" href="http://semver.org/" rel="noopener ugc nofollow" target="_blank">语义版本</a>。阅读更多关于<a class="ae mt" href="https://www.npmjs.com/package/sequelize" rel="noopener ugc nofollow" target="_blank"><em class="kx">sequelize</em></a><em class="kx">。</em></p><p id="8584" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> Sequelize-cli </strong> —在安装这个包依赖项之前，请确保您已经成功地将<em class="kx"> sequelize安装到您的项目中。cli是Sequelize的命令行界面。</em></p><p id="b37a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> Sequelize-auto </strong> —通过命令行自动生成<a class="ae mt" href="https://github.com/sequelize/sequelize" rel="noopener ugc nofollow" target="_blank"> SequelizeJS </a>的模型。</p><p id="c38e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您将需要安装<code class="fe mu mv mw mx b">sequelize</code>；不再由<code class="fe mu mv mw mx b">sequelize-auto</code>安装。</p><p id="7ae8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在使用sequelize-auto之前，您需要安装正确的方言绑定。阅读更多关于<a class="ae mt" href="https://www.npmjs.com/package/sequelize-auto" rel="noopener ugc nofollow" target="_blank"> <em class="kx">序列自动</em> </a></p><p id="6208" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> mssql和MSSQL 2—</strong>Microsoft SQL Server client for node . js(必须安装)</p><p id="0979" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> nodemon — </strong> nodemon是一个帮助开发基于node.js的应用程序的工具，当检测到目录中的文件更改时，它会自动重新启动节点应用程序。</p><p id="4f8b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">nodemon】不要求<em class="kx">对你的代码或开发方法做任何</em>额外的改变。nodemon是<code class="fe mu mv mw mx b">node</code>的替代包装器。要使用<code class="fe mu mv mw mx b">nodemon</code>，在执行您的脚本时，在命令行中替换单词<code class="fe mu mv mw mx b">node</code>。</p><h1 id="86be" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">为我们的项目创建配置和模型文件夹。</h1><p id="c8c5" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">一旦以上依赖项成功安装，我们将使用数据库模式分别在config和models文件夹下创建配置文件和模型。</p><p id="2da1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为此，请在您的项目下运行以下命令。</p><ul class=""><li id="e609" class="mb mc iq jp b jq jr ju jv jy md kc me kg mf kk mn mh mi mj bi translated">顺序初始化:配置</li><li id="3964" class="mb mc iq jp b jq mo ju mp jy mq kc mr kg ms kk mn mh mi mj bi translated">初始化序列:模型</li></ul><ol class=""><li id="d2fe" class="mb mc iq jp b jq jr ju jv jy md kc me kg mf kk mg mh mi mj bi translated">第一个命令将创建一个连接到数据库的配置文件，我们将在其中指定所有与SQL Server (SSMS)相关的连接细节。</li></ol><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi my"><img src="../Images/12d41be54a69a5dfb39d2bbce59683d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1176/format:webp/1*CzGMd2bG4SDWgn42sVwTbg.png"/></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">配置. json</figcaption></figure><p id="2cc0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3.第二个命令将创建一个模型文件夹，我们将在其中存储与模型相关的数据库表，即从现有的数据库表中生成模型。为此，我们将使用<a class="ae mt" href="https://github.com/sequelize/sequelize-auto#readme" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">序列自动</strong> </a> <strong class="jp ir">。</strong></p><p id="1e24" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于我们已经在我们的项目目录中，我们将简单地点击下面的命令，但是在点击该命令之前，请确保您已经成功地将<a class="ae mt" href="https://github.com/sequelize/sequelize-auto#readme" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">Sequelize-Auto</strong></a><strong class="jp ir"/>包依赖项安装到项目目录中的节点模块文件夹[node_modules]中..</p><p id="63b6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">sequel ize-auto-h localhost-u<username>-x<password>-p 1433-d库-o "。/models "-e MSSQL-c config/config . JSON</password></username></p><p id="fff6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里，</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi mz"><img src="../Images/8156a804e09794d1ab942175b540de57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ew8M_Q4ReJNZ_SAt-b6oag.png"/></div></div></figure><p id="b173" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以下命令将自动生成一个模型文件，该文件将由数据库中的模型组成。在这个模型的文件夹中，我们将有<strong class="jp ir"> Authors.js </strong>、<strong class="jp ir"> Books.js </strong>、<strong class="jp ir"> index.js </strong>和<strong class="jp ir"> init-models.js </strong>(全部自动生成)文件，这些文件由数据库模型及其关系组成。</p><h1 id="f6e8" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">设置解析器和类型定义。</h1><p id="926b" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated"><strong class="jp ir">什么是解析器？</strong></p><p id="556f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Apollo Server需要知道如何为模式中的每个字段填充数据，以便能够响应对数据的请求。为此，它使用解析器。</p><p id="ab4c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">解析器是一个负责为模式中的单个字段填充数据的函数。</strong>它可以以您定义的任何方式填充数据，例如从后端数据库或第三方API获取数据。</p><p id="10fb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您<em class="kx">没有</em>为特定字段定义解析器，Apollo Server会自动为它定义一个<a class="ae mt" href="https://www.apollographql.com/docs/apollo-server/data/resolvers/#default-resolvers" rel="noopener ugc nofollow" target="_blank">默认解析器</a>。</p><p id="bb57" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">什么是Typedefs？</strong></p><p id="b59b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">GraphQL有自己的类型语言，用于编写GraphQL模式:模式定义语言<a class="ae mt" href="https://blog.graph.cool/graphql-sdl-schema-definition-language-6755bcb9ce51" rel="noopener ugc nofollow" target="_blank">(SDL)。最简单的形式是，GraphQL SDL可以用来定义如下所示的类型:</a></p><pre class="km kn ko kp gt ne mx nf ng aw nh bi"><span id="bc50" class="ni kz iq mx b gy nj nk l nl nm">type User {<br/>  id: ID!<br/>  name: String<br/>}</span></pre><p id="f9aa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们将在根目录下创建一个graphql文件夹，其中包含解析器和typedefs。</p><p id="36e0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将通过在/graphql文件夹中创建一个<strong class="jp ir"><em class="kx">typedef . graph QL</em></strong>文件来定义typedef。首先，我们将为作者定义。</p><p id="a529" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里我们从一个类型开始。我们将有一个作者类型，看起来像AuthorID，Abbrv，FirstName，LastName，DOB，DOD，BookID。</p><p id="394f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦我们定义了我们的类型，我们需要获取作者，这将通过查询对象来完成，查询对象将是一个作者数组。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/a0edf6b5c8e3cb4c7b29ee55a84fe446.png" data-original-src="https://miro.medium.com/v2/resize:fit:494/format:webp/1*0ME3IRle2kVFAr3bV0Yukw.png"/></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">typeDefs.graphql</figcaption></figure><p id="2d0d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里，getAuthorDetails是查询的名称。</p><p id="bf1b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们通过在graphql文件夹中创建一个<strong class="jp ir"> resolvers.js </strong>文件来实现我们到目前为止所定义的功能，这将是一个简单的JavaScript文件。</p><p id="d7d8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该文件将由查询解析器组成。这里我们将有一个Author的解析函数，它将返回authors的数组。</p><p id="d0b2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您的文件应该是这样的，</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi no"><img src="../Images/297c02df230ea0debf6fcbd749d93b6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:848/format:webp/1*dthYHwe7Z4iLKBiVHHgDcw.png"/></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">resolvers.js</figcaption></figure><p id="0d4f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">同样，你也可以对书籍这样做。</p><p id="9e0a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦我们完成了typedefs和解析器，我们就可以创建我们的<strong class="jp ir"> server.js </strong>文件了。在<strong class="jp ir"> server.js </strong>文件中，我们需要从<em class="kx"> apollo-server </em>包中导入<em class="kx"> Apollo Server和gql </em>。</p><p id="d8ab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们可以通过使用gql函数创建出typedefs。为了导入我们的typeDefs.graphql文件，我们将使用<em class="kx"> fs(文件系统)</em>模块。我们将使用fs.readFileSync()函数来读取我们的模式，我们将传递编码选项，并将其设置为“utf-8 ”,以确保它将文件作为字符串读取。</p><p id="1587" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们可以通过传递一个配置对象typedefs和revolvers来创建一个新的apollo服务器实例。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi np"><img src="../Images/974527ddcc0bc59abc0dbcb6ca31ceaa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mcllyqRf8f7Za4tImBwOKA.png"/></div></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">server.js</figcaption></figure><p id="6a96" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我们可以通过在命令提示符窗口中点击下面的命令来运行服务器。</p><p id="85e6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> nodemon服务器</strong></p><p id="af86" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">或者</p><p id="1e80" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> nodemon server.js </strong></p><p id="bb22" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们使用<strong class="jp ir"> nodemon </strong>的原因是，即使我们修改了任何项目文件，我们也可以继续运行我们的服务器。</p><p id="c20f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">或者你可以简单地跑，</p><p id="001e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">国家预防机制启动</strong></p><p id="a6b1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这将在<a class="ae mt" href="http://localhost:5000/" rel="noopener ugc nofollow" target="_blank"> http://localhost:5000 </a>上运行，我们将看到GraphQL Playground运行。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi nq"><img src="../Images/8199d2fee871f69fd421a99486404985.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*azMZ1ZfuivqPHmtIEi7Pmg.png"/></div></div></figure><p id="187a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以上只是数据库记录的示例输出。</p><p id="34a7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">到目前为止，我们已经从Authors表中获取了所有记录。我们还可以从Authors表中获取单个记录，如果我们想从多个表中获取author的数据呢？是的，我们可以这样做，因为我们已经定义了关系。现在我们只需要为author修改我们的模式，还需要为book添加一个新的类型。我们修改后的模式应该如下所示。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/634f761301b8aeb1b4a579647d0b0e8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:560/format:webp/1*R5WtuZXoPEwQV9nU1qlqqQ.png"/></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">修改的typeDefs.graphql</figcaption></figure><p id="4312" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，如果我们只需要分别来自Authors和Books表的单个记录，我们定义了一个新的查询getAuthor()和getBook()。</p><p id="9505" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面我们在作者类型中添加了图书字段，图书字段的类型为图书，以便从图书表中获取相关数据。此外，我们还添加了一个新的图书类型，以便从authors表中获取与Authors数据相关联的所有图书记录。</p><p id="4166" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了从多个表中获取相关数据，我们需要指定我们想要的字段。在本例中，假设我们只需要相关书籍的书名和总页数。然后我们将请求这些字段，这就是GraphQL的强大之处，它不会获取所有的细节，查询只会获取请求的字段。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/5ca8ad761e239c00aae39c52f55e0ed5.png" data-original-src="https://miro.medium.com/v2/resize:fit:928/format:webp/1*6BsCNK6jlOU_bKD4SgSodg.png"/></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">修改的resolver.js(1)</figcaption></figure><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/37a2ca086e0fc5cbc9cff419583bbd0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:928/format:webp/1*MieIXlXKtKDNOa93qw-1Og.png"/></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">修改后的resolver.js (2)</figcaption></figure><p id="9e7b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">修改了resolver.js (2)，所以我们说返回一本书，它的id与作者的BookID相同。</p><p id="6191" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里每个解析器函数接收一些参数，参数是父对象。在这种情况下，由于我们正在为作者解析图书，父对象是一个“auth ”,我们希望返回相关的图书并将其添加到导出的类型中。</p><p id="68d5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们运行相同的查询，并检查输出:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi nt"><img src="../Images/6b0a01633996592458344307f8dd4f5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Dp4kcihmEwLRhtYbJ85zlw.png"/></div></div></figure><p id="f707" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里我们只得到一个id为2的author对象，以及只包含必填字段的相关图书信息。</p><h1 id="92ca" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">如何执行插入、更新和删除操作？</h1><p id="3149" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">为此，我们对graphql进行了突变。</p><p id="844e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们的GraphQL模式中，我们只有查询，它都是关于返回现有数据的，没有任何东西修改数据。修改数据的操作被称为<strong class="jp ir">突变</strong>。它们必须与查询分开。我们需要增加一个单独的类型，叫做突变。突变是一个根类型，就像查询一样。在变异内部，我们可以找到像插入、更新和删除这样的操作。</p><p id="da7c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">大多数关于GraphQL的讨论都集中在数据获取上，但是任何完整的数据平台都需要一种修改服务器端数据的方法。</p><p id="0bc6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在REST中，任何请求最终都可能对服务器造成一些副作用，但是按照惯例，建议不要使用<code class="fe mu mv mw mx b">GET</code>请求来修改数据。GraphQL是类似的——从技术上讲，可以实现任何查询来导致数据写入。然而，建立一个约定是有用的，即任何导致写操作的操作都应该通过一个变异显式地发送。</p><p id="13ca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面我们有一个添加新作者的突变，为此我们需要传递添加作者的参数。如果你看作者类型，你有名字，姓氏，缩写，DOB，DOD。这里我们没有AuthorID字段，因为在数据库中我们已经将其设置为自动递增。即身份插入已设置为真。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/13952c3a21309f6dc7a2638678df30ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:610/format:webp/1*DIK8RInh5P0H_O57ODWP-A.png"/></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">修改的typeDefs.graphql</figcaption></figure><p id="09b2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">突变必须像查询一样返回结果。在我们的例子中，我们将返回一个字符串。</p><p id="7166" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在解析器中，我们需要匹配模式的结构，因此我们需要定义一个名为Mutation的新对象，并将其添加到导出的对象中。</p><div class="km kn ko kp gt ab cb"><figure class="nv kq nw nx ny nz oa paragraph-image"><img src="../Images/f2b504c4ff438b5e4f71f959a98fd656.png" data-original-src="https://miro.medium.com/v2/resize:fit:730/format:webp/1*T-9DKhRDXUrRDFU95dyHbQ.png"/></figure><figure class="nv kq ob nx ny nz oa paragraph-image"><img src="../Images/80983e4208f6053afcea8bfdaab95cd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:978/format:webp/1*0aBv5BsL3tL3HH0amm7hQA.png"/><figcaption class="kt ku gj gh gi kv kw bd b be z dk oc di od oe translated">修改后的resolvers.js</figcaption></figure></div><p id="3283" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不要忘记在最后导出变异对象。</p><p id="7780" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">module.exports = {查询，作者，图书，突变}</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi of"><img src="../Images/8feb0454b7402a81d8195579dc89eea3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*96pouuyfdZCw8QUKCc7Dzg.png"/></div></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">添加作者后的输出</figcaption></figure><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi og"><img src="../Images/f8c20c6163d9825a895252c2fd8e3c35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IGVj6lUlmtJdkN6Ihk1Sfw.png"/></div></div><figcaption class="kt ku gj gh gi kv kw bd b be z dk translated">更新作者详细信息后的输出</figcaption></figure><p id="775c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">同样，你可以添加、更新和删除这本书。</p><h1 id="e9ff" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">结论</h1><ol class=""><li id="c96c" class="mb mc iq jp b jq lw ju lx jy oh kc oi kg oj kk mg mh mi mj bi translated">我们看到了如何用Apollo Server在Node.js中创建一个GraphQL服务器。</li><li id="8a1e" class="mb mc iq jp b jq mo ju mp jy mq kc mr kg ms kk mg mh mi mj bi translated">我们看到了每个依赖项将如何帮助我们完成项目。</li><li id="083f" class="mb mc iq jp b jq mo ju mp jy mq kc mr kg ms kk mg mh mi mj bi translated">我们还看到了如何使用Sequelize将MSSQL(SQL Server)数据库与GraphQL服务器集成。</li><li id="35d6" class="mb mc iq jp b jq mo ju mp jy mq kc mr kg ms kk mg mh mi mj bi translated">我们已经使用GraphQL对数据库执行了基本操作。</li></ol><p id="3e7b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该项目也可以在GitHub <a class="ae mt" href="https://github.com/bagwanwasim01/GraphQL-MSSQL" rel="noopener ugc nofollow" target="_blank"> repo </a>上获得。</p></div></div>    
</body>
</html>