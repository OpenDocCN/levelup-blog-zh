<html>
<head>
<title>Data Structures and Algorithm Concepts: Time &amp; Space Complexity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据结构和算法概念:时间和空间复杂性</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/data-structures-algorithm-concepts-time-space-complexity-b1b5c5d6d87a?source=collection_archive---------2-----------------------#2020-11-01">https://levelup.gitconnected.com/data-structures-algorithm-concepts-time-space-complexity-b1b5c5d6d87a?source=collection_archive---------2-----------------------#2020-11-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="77e8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">什么是时间复杂度？什么是空间复杂性？它们为什么重要？我将尝试在这篇博客中揭开Big-O符号的神秘面纱。</em></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/484a33a41111181821ab3489798ac20f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*f_2t9nZgh-4ySjTU"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">照片由<a class="ae lc" href="https://unsplash.com/@neonbrand?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> NeONBRAND </a>拍摄</figcaption></figure><p id="834b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">用最简单的术语来说，时间复杂度就是算法运行的持续时间。类似地，空间复杂度是算法运行所需的空间量。当提到时间复杂性时，您通常会将其视为Big-O符号，如O(n)、O(log n)、O(n)等。<em class="kl"> n </em>代表输入，而<em class="kl"> O </em>代表最坏情况增长率函数。</p><p id="0554" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">时间和空间的复杂性是技术面试中经常出现的重要话题，原因有很多。第一个原因是，每个公司都很看重自己的资源，拥有占用时间和空间更少的高效算法，总会帮助公司节省资源。第二个原因是展示您对可伸缩性的了解。随着算法被用于越来越大的数据集，它们的运行时间和空间需求会发生怎样的变化？</p></div><div class="ab cl ld le hu lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="ij ik il im in"><p id="8ae7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你对算法性能的理解可以帮助公司节省大量资源。如果一个算法需要一个小时来计算，而另一个需要10分钟，那么这50分钟就非常有价值，可以用来处理其他任务。此外，如果我们将算法需要处理的数据量和输入量增加一倍，第一个算法的时间可能会增加到两个小时，而第二个算法可能只需要20分钟。正如你所看到的，意识到算法的时间复杂度可以节省很多时间！</p><p id="3026" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当涉及到更简单的面试问题，如字符串/整数反转，或检查回文时，运行这些算法所需的时间不一定会非常长。但是，想象一下传入一个100，000个字符长的字符串，而不是10个字符。现在所需的时间大大增加。因此，让我们稍微研究一下这个例子，并深入研究各种类型的运行时。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi lk"><img src="../Images/c54fd332a0ad76145e18d3f2662a9107.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IajxspwS-VRSGf5eAkNvIA.png"/></div></figure><p id="130a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">循环遍历一个字符串来反转字符将是<strong class="jp ir">线性运行时</strong>的经典例子，也称为<strong class="jp ir"> O(n) </strong>。这意味着对于字符串中的每个额外字符，循环中都有一个额外的步骤要处理。在输入和处理所需的时间量之间有直接的一对一的关系。当算法必须遍历集合中的每个数据点一次时，线性运行时间经常是这种情况。</p><p id="c82b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">线性运行时是可以接受的，但是有两个时间复杂度甚至更高，其中一个是理想的。这些是对数运行时间和常数运行时间。<strong class="jp ir">对数运行时间</strong>，或<strong class="jp ir"> O(log n) </strong>，通常是算法每次将工作分成两半的情况。一个经典的例子是在字典中搜索一个单词。当你第一次寻找一个单词时，你可能会随意打开字典，然后想想这个单词是在你翻到的左边还是右边。这本字典现在被分成两半。你继续这样做，直到你把搜索范围缩小到准确的单词。当输入量加倍并不总是使完成工作所需的时间加倍时，很可能是对数运行时间。许多搜索算法，如二分搜索法，都有这样的时间复杂度。</p><p id="bb0e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">运行时最好的情况是<strong class="jp ir">常量运行时</strong>，也就是<strong class="jp ir"> O(1) </strong>。之所以这是最好的情况，是因为不管O的增长率如何，运行它所需的时间将保持不变。例如，如果我实现了一个函数，它返回一个字符串中的第一个字符，即使这个字符串有10，000个字符长，它所花费的时间和我给出一个10个字符长的字符串所花费的时间是一样的。当然，并不是所有的一行程序都是常量运行时。观察它是如何实现的极其重要。虽然恒定的运行时间是最理想的场景，但它通常是最难实现的。</p><p id="28f9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们看看一些不太理想的运行时。这些运行时间是准线性、二次、多项式、指数和阶乘的。我不会讲太多细节，因为解释起来会很复杂，需要理解一些非常有趣的排序方法(合并排序、快速排序等)。)</p><p id="279d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">准线性/线性时间运行</strong>，或<strong class="jp ir"> O(n * log n) </strong>，与对数时间非常相似。它的性能比线性运行时稍差，但仍明显优于二次运行时。如果您对利用这个运行时的算法感兴趣，可以研究一下merge sort，但是为了简洁起见，我不会在这里深入研究。</p><p id="77e2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">二次运行时</strong>，或<strong class="jp ir"> O(n ) </strong>，意味着每增加一次输入，功的量就增加到二次方。当给定3个输入时，它进行9次运算。当给定5个输入时，它进行25次运算。使用此运行时的排序方法有冒泡排序、选择排序和插入排序。另一个例子是在同一个数组上迭代的两个嵌套循环。</p><p id="ec37" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果在这两个循环中有另一个嵌套循环，并且它也迭代相同数组中的每个值，那么我们有<strong class="jp ir">立方</strong> <strong class="jp ir">运行时</strong>，或者<strong class="jp ir"> O(n ) </strong>。随着循环次数的增加，功率也增加。这被称为<strong class="jp ir">多项式运行时</strong>，或者<strong class="jp ir">o(n^m</strong>。</p><p id="432c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来我们有<strong class="jp ir">指数运行时间</strong>，或<strong class="jp ir"> O(2 </strong> ^ <strong class="jp ir"> n) </strong>。一个很好的例子就是披萨店的配料。对于每一个额外的浇头，组合的数量呈指数增长。再比如握手问题。我们希望尽量避免这种情况，因为这些算法很容易开始花费大量的时间来处理。</p><p id="b0b2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我们有<strong class="jp ir">阶乘运行时</strong>，或<strong class="jp ir"> O(n！)</strong>。阶乘就是把所有小于给定数字的正整数相乘，所以4！等于1 * 2 * 3 * 4。有一个涉及阶乘运行时的解决方案可以解决<a class="ae lc" href="https://en.wikipedia.org/wiki/Travelling_salesman_problem" rel="noopener ugc nofollow" target="_blank">旅行推销员问题</a>，但这显然不理想。如果你有时间，这是一个有趣的阅读问题！</p><p id="fc10" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是阿德里安·梅希亚网站上的一张图表，它将所有的复杂性可视化了:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi ll"><img src="../Images/b38b449b177a1794c93ec69985b3f251.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tCbivj65Dc1De8DuhvftZg.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated"><a class="ae lc" href="https://adrianmejia.com/most-popular-algorithms-time-complexity-every-programmer-should-know-free-online-tutorial-course/#O-n-Factorial-time" rel="noopener ugc nofollow" target="_blank">阿德里安·梅希亚对时间复杂性的可视化</a>其中X是输入，Y是时间。</figcaption></figure></div><div class="ab cl ld le hu lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="ij ik il im in"><p id="e764" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">很难总是准确地识别算法的时间复杂度，但是这里有一些帮助:</p><p id="bb15" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当涉及到一次循环迭代时，不管数据集的大小，都将是线性运行时。使用单独的for循环遍历两个不同的数据集的时间复杂度为O(n + m)，但最终仍然是线性的。</p><p id="5585" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">用嵌套的for循环遍历相同的数据集是二次运行时。如果你迭代两个不同的集合，虽然类似于二次运行时，它将被写成O(n * m)，因为我们想区分不同的数据集。</p><p id="4e6c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一般来说，随着您对数据结构越来越熟悉，并利用更多的算法，您将会对这些运行时类型越来越熟悉。</p></div><div class="ab cl ld le hu lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="ij ik il im in"><p id="a985" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么空间复杂性呢？与运行时复杂性类似，空间复杂性只是指增加输入时需要多少内存或空间。所有这些运行时复杂性类型也直接适用于空间复杂性。</p><p id="2adf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当讨论空间复杂性时，它包括辅助空间，即算法执行时使用的临时或额外空间。由于算法的输入大小不同，空间复杂度取决于输入的大小。固定大小的输入将具有恒定的时间复杂度，即O(1)。</p></div><div class="ab cl ld le hu lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="ij ik il im in"><p id="cb72" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">时间和空间的复杂性对我来说是很难理解的概念，我仍然在学习更多关于它们的知识。即使在写这篇博客的时候，我也学到了很多关于时间和空间复杂性的知识。如果我犯了什么错误或者概念不清楚，一定要在LinkedIn上给我留言！我也非常乐意讨论复杂性——我想了解更多。</p><p id="a0ea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">希望在阅读这篇博客的过程中，你能像我一样对时间和空间的复杂性有所了解。下周，我将深入探讨一个名为“最大字符数”的问题。这个更难，但是如果你想试一试的话，这里有个问题！</p><p id="eb0f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="kl">给定一个字符串，返回该字符串中最常用的字符。例如，如果字符串是“apple”，函数将返回“p”。如果单词是“数据”，函数将返回“a”。</em> </strong></p></div></div>    
</body>
</html>