<html>
<head>
<title>Vanilla Web Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">普通Web组件</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/vanilla-web-components-caa1bd83ed86?source=collection_archive---------1-----------------------#2020-08-16">https://levelup.gitconnected.com/vanilla-web-components-caa1bd83ed86?source=collection_archive---------1-----------------------#2020-08-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/5152f5876e9a38ccb7ea9e530255b342.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7aiT75r5WlQMmSXp"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">维塔利·塔拉诺夫在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="21d4" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">什么是Web组件？</h1><p id="369c" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">web组件是自定义的、可重用的Web元素，通过使用普通的javascript/HTML/CSS以及本地Web APIs来封装功能、标记结构和样式。</p><blockquote class="lz"><p id="a5fe" class="ma mb iq bd mc md me mf mg mh mi ly dk translated"><strong class="ak">自定义元素教给浏览器新的技巧，同时保留HTML的优点</strong></p><p id="475e" class="ma mb iq bd mc md me mf mg mh mi ly dk translated"><strong class="ak"> — </strong> <a class="ae kc" href="https://developers.google.com/web/resources/contributors/ericbidelman" rel="noopener ugc nofollow" target="_blank">埃里克·比德尔曼</a></p></blockquote><p id="566d" class="pw-post-body-paragraph lb lc iq ld b le mj lg lh li mk lk ll lm ml lo lp lq mm ls lt lu mn lw lx ly ij bi translated">它们可以像普通的HTML元素一样在模板中使用(例如<code class="fe mo mp mq mr b">&lt;p&gt;</code>或<code class="fe mo mp mq mr b">&lt;span&gt;</code>)。</p><pre class="ms mt mu mv gt mw mr mx my aw mz bi"><span id="5ff2" class="na ke iq mr b gy nb nc l nd ne">&lt;body&gt;<br/>  &lt;p&gt;a simple paragraph&lt;/p&gt;</span><span id="3b28" class="na ke iq mr b gy nf nc l nd ne">  &lt;script type="module" src="my-custom-element.js"&gt;&lt;/script&gt;<br/>  &lt;my-custom-element&gt;&lt;/my-custom-element&gt;<br/>&lt;/body&gt;</span></pre><p id="1d46" class="pw-post-body-paragraph lb lc iq ld b le ng lg lh li nh lk ll lm ni lo lp lq nj ls lt lu nk lw lx ly ij bi translated">它们通过扩展<code class="fe mo mp mq mr b">HTMLElement </code>接口建立在ECMAScript 2015类语法的基础上，提供了<a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement" rel="noopener ugc nofollow" target="_blank">有用的API</a>来操作元素或响应事件。</p><pre class="ms mt mu mv gt mw mr mx my aw mz bi"><span id="1d51" class="na ke iq mr b gy nb nc l nd ne">class MyCustomElement extends HTMLElement {}</span></pre><p id="7fe7" class="pw-post-body-paragraph lb lc iq ld b le ng lg lh li nh lk ll lm ni lo lp lq nj ls lt lu nk lw lx ly ij bi translated">您还可以扩展现有的HTML元素，如<code class="fe mo mp mq mr b">HTMLInputElement</code>、<code class="fe mo mp mq mr b">HTMLButtonElement</code>或<code class="fe mo mp mq mr b">HTMLParagraphElement</code>，以继承它们的属性和方法。因此，您可以创建自己的通用HTML元素实现。</p></div><div class="ab cl nl nm hu nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ij ik il im in"><h2 id="2b92" class="na ke iq bd kf ns nt dn kj nu nv dp kn lm nw nx kr lq ny nz kv lu oa ob kz oc bi translated">生命周期挂钩</h2><p id="2014" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">有几个预定义的回调函数可用于对特定的生命周期事件做出反应，例如</p><ul class=""><li id="7740" class="od oe iq ld b le ng li nh lm of lq og lu oh ly oi oj ok ol bi translated"><code class="fe mo mp mq mr b">connectedCallback</code> —每当您的元素被插入到DOM中时，就会调用这个回调函数</li><li id="afa7" class="od oe iq ld b le om li on lm oo lq op lu oq ly oi oj ok ol bi translated"><code class="fe mo mp mq mr b">disconnectedCallback</code> —每当从DOM树中删除元素时调用</li></ul><p id="8042" class="pw-post-body-paragraph lb lc iq ld b le ng lg lh li nh lk ll lm ni lo lp lq nj ls lt lu nk lw lx ly ij bi translated">这些回调对于安全地获取/访问数据或运行一些清理代码非常有用。</p></div><div class="ab cl nl nm hu nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ij ik il im in"><h2 id="622d" class="na ke iq bd kf ns nt dn kj nu nv dp kn lm nw nx kr lq ny nz kv lu oa ob kz oc bi translated">阴影DOM</h2><p id="8d36" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">样式和标记结构的封装是通过将一个所谓的<strong class="ld ir">影子DOM </strong>附加到您的web组件来实现的，它会在您的定制HTML元素下创建一个隐藏的DOM树。</p><figure class="ms mt mu mv gt jr gh gi paragraph-image"><div class="gh gi or"><img src="../Images/b7d69f77533da548cd59c104ee014b60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1212/format:webp/1*GCo4XreZNE0SO3qysjWu7w.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">阴影DOM可视Chrome DevTools元素选项卡</figcaption></figure><p id="df57" class="pw-post-body-paragraph lb lc iq ld b le ng lg lh li nh lk ll lm ni lo lp lq nj ls lt lu nk lw lx ly ij bi translated">当组件标记和样式不受全局样式定义影响时，影子DOM很有用。</p></div><div class="ab cl nl nm hu nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ij ik il im in"><h2 id="efe6" class="na ke iq bd kf ns nt dn kj nu nv dp kn lm nw nx kr lq ny nz kv lu oa ob kz oc bi translated">浏览器支持</h2><p id="a210" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">所有现代浏览器都支持Web组件，如Chrome、Firefox和Opera(对于Edge、Safari和IE11，您可以使用<a class="ae kc" href="https://github.com/webcomponents/polyfills" rel="noopener ugc nofollow" target="_blank"> polyfills </a>)。</p><div class="os ot gp gr ou ov"><a href="https://github.com/webcomponents/polyfills" rel="noopener  ugc nofollow" target="_blank"><div class="ow ab fo"><div class="ox ab oy cl cj oz"><h2 class="bd ir gy z fp pa fr fs pb fu fw ip bi translated">web组件/聚合填充</h2><div class="pc l"><h3 class="bd b gy z fp pa fr fs pb fu fw dk translated">Web组件聚合填充。在GitHub上创建一个帐户，为webcomponents/polyfills的开发做出贡献。</h3></div><div class="pd l"><p class="bd b dl z fp pa fr fs pb fu fw dk translated">github.com</p></div></div><div class="pe l"><div class="pf l pg ph pi pe pj jw ov"/></div></div></a></div></div><div class="ab cl nl nm hu nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ij ik il im in"><h2 id="714d" class="na ke iq bd kf ns nt dn kj nu nv dp kn lm nw nx kr lq ny nz kv lu oa ob kz oc bi translated">结构</h2><p id="3432" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">有一些框架可以加速你的web组件开发，比如<a class="ae kc" href="https://www.polymer-project.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="ld ir">聚合物</strong> </a>或者<a class="ae kc" href="https://github.com/hybridsjs/hybrids" rel="noopener ugc nofollow" target="_blank"> <strong class="ld ir">混合</strong> </a>。在将您选择的框架添加到您的项目之前，请尝试评估您是否真的需要这个额外的依赖项。</p><p id="c535" class="pw-post-body-paragraph lb lc iq ld b le ng lg lh li nh lk ll lm ni lo lp lq nj ls lt lu nk lw lx ly ij bi translated">如果您只想创建几个简单的组件，而不是整个组件库，那么您应该选择无框架路径。</p></div><div class="ab cl nl nm hu nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ij ik il im in"><h1 id="55aa" class="kd ke iq bd kf kg pk ki kj kk pl km kn ko pm kq kr ks pn ku kv kw po ky kz la bi translated">实现Web组件</h1><p id="5c7e" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">澄清了所有必要的基础知识之后，让我们动手实现一个普通的web组件。目标是创建一个基本的web组件，它包含封装的样式/标记，并且可以很容易地扩展。</p><p id="9059" class="pw-post-body-paragraph lb lc iq ld b le ng lg lh li nh lk ll lm ni lo lp lq nj ls lt lu nk lw lx ly ij bi translated">在本文的结尾，您还可以找到一个链接，指向我的简单web组件模板库。</p></div><div class="ab cl nl nm hu nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ij ik il im in"><h2 id="ad3d" class="na ke iq bd kf ns nt dn kj nu nv dp kn lm nw nx kr lq ny nz kv lu oa ob kz oc bi translated">设置</h2><p id="87b5" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">出于演示的目的，我们将创建一个简单的web页面，其中将使用我们的自定义web元素。</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="pp pq l"/></div></figure><p id="a6c9" class="pw-post-body-paragraph lb lc iq ld b le ng lg lh li nh lk ll lm ni lo lp lq nj ls lt lu nk lw lx ly ij bi translated">为了检查我们的定制元素是否像预期的那样工作，我将使用工具<em class="pr"> serve </em>来托管我们的简单web页面。</p><div class="os ot gp gr ou ov"><a href="https://github.com/vercel/serve" rel="noopener  ugc nofollow" target="_blank"><div class="ow ab fo"><div class="ox ab oy cl cj oz"><h2 class="bd ir gy z fp pa fr fs pb fu fw ip bi translated">韦尔塞尔/发球</h2><div class="pc l"><h3 class="bd b gy z fp pa fr fs pb fu fw dk translated">假设你想提供一个静态网站，单页应用程序或只是一个静态文件(不管你的…</h3></div><div class="pd l"><p class="bd b dl z fp pa fr fs pb fu fw dk translated">github.com</p></div></div><div class="pe l"><div class="ps l pg ph pi pe pj jw ov"/></div></div></a></div><p id="345a" class="pw-post-body-paragraph lb lc iq ld b le ng lg lh li nh lk ll lm ni lo lp lq nj ls lt lu nk lw lx ly ij bi translated">有了<em class="pr"> serve </em>，你只需要在你的简单网页所在的目录下运行<code class="fe mo mp mq mr b">serve .</code>命令，就可以启动一个web服务器，它在<code class="fe mo mp mq mr b">localhost:5000</code>上托管。</p></div><div class="ab cl nl nm hu nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ij ik il im in"><h2 id="adc6" class="na ke iq bd kf ns nt dn kj nu nv dp kn lm nw nx kr lq ny nz kv lu oa ob kz oc bi translated">基金会</h2><p id="4256" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">首先，我们将扩展<code class="fe mo mp mq mr b">HMTMLElement</code>接口来获取所需的API，并将我们的类注册为一个自定义元素，这样我们就可以在示例HTML页面中使用它。</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="pp pq l"/></div></figure><p id="94a6" class="pw-post-body-paragraph lb lc iq ld b le ng lg lh li nh lk ll lm ni lo lp lq nj ls lt lu nk lw lx ly ij bi translated">现在，您已经可以通过导入javascript文件和插入html标记将它添加到web页面，我们已经在<code class="fe mo mp mq mr b">customElements.define()</code>调用中将它定义为第一个参数。</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="pp pq l"/></div></figure><p id="6db1" class="pw-post-body-paragraph lb lc iq ld b le ng lg lh li nh lk ll lm ni lo lp lq nj ls lt lu nk lw lx ly ij bi translated">不要忘记将javascript文件作为<code class="fe mo mp mq mr b">type="module"</code>导入，否则它不会被加载。</p><p id="6733" class="pw-post-body-paragraph lb lc iq ld b le ng lg lh li nh lk ll lm ni lo lp lq nj ls lt lu nk lw lx ly ij bi translated">现在我们已经完成了利用我们自己的web组件所需的步骤。当然，我们的自定义元素还没有任何内容，但是我们将在下一节中改变它。</p><p id="5f8a" class="pw-post-body-paragraph lb lc iq ld b le ng lg lh li nh lk ll lm ni lo lp lq nj ls lt lu nk lw lx ly ij bi translated">有了这个坚实的基础，我们将继续使用Shadow DOM APIs向我们的自定义元素添加封装的标记结构和样式。</p></div><div class="ab cl nl nm hu nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ij ik il im in"><h2 id="ef7f" class="na ke iq bd kf ns nt dn kj nu nv dp kn lm nw nx kr lq ny nz kv lu oa ob kz oc bi translated">使用阴影DOM</h2><p id="bebc" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">正如已经提到的，影子DOM是一个隐藏的DOM树，它附加到您的自定义元素上。这确保了自定义元素的样式不会受到全局或其他元素样式的影响。</p><p id="d02b" class="pw-post-body-paragraph lb lc iq ld b le ng lg lh li nh lk ll lm ni lo lp lq nj ls lt lu nk lw lx ly ij bi translated">让我们给自定义元素附加一个阴影DOM。我们将在<code class="fe mo mp mq mr b">constructor</code>中这样做，并选择<code class="fe mo mp mq mr b">open</code>作为我们想要的封装模式。</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="pp pq l"/></div></figure><p id="b723" class="pw-post-body-paragraph lb lc iq ld b le ng lg lh li nh lk ll lm ni lo lp lq nj ls lt lu nk lw lx ly ij bi translated">当将封装模式设置为<code class="fe mo mp mq mr b">open</code>时，我们确保可以通过javascript访问我们的影子DOM子元素。</p><p id="8799" class="pw-post-body-paragraph lb lc iq ld b le ng lg lh li nh lk ll lm ni lo lp lq nj ls lt lu nk lw lx ly ij bi translated">接下来，我们应该添加一个模板和一些样式到我们的自定义元素。</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="pp pq l"/></div></figure><p id="0545" class="pw-post-body-paragraph lb lc iq ld b le ng lg lh li nh lk ll lm ni lo lp lq nj ls lt lu nk lw lx ly ij bi translated">注意，我们的标记结构驻留在一个<code class="fe mo mp mq mr b">&lt;template&gt;</code> HTML元素中，它不会显示在呈现的web页面上。</p><p id="46c3" class="pw-post-body-paragraph lb lc iq ld b le ng lg lh li nh lk ll lm ni lo lp lq nj ls lt lu nk lw lx ly ij bi translated">网页现在应该显示自定义元素。</p><figure class="ms mt mu mv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pt"><img src="../Images/d35d33e76c95f5478c72dae52065a7d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JXcXlVl4bV-JYszmYLSSMg.png"/></div></div></figure></div><div class="ab cl nl nm hu nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ij ik il im in"><p id="435c" class="pw-post-body-paragraph lb lc iq ld b le ng lg lh li nh lk ll lm ni lo lp lq nj ls lt lu nk lw lx ly ij bi translated">现在，为了证明我们的自定义样式被封装并且不受全局样式的影响，我们向我们的<code class="fe mo mp mq mr b">index.html</code>文件添加了全局样式和一个简单的标题元素。</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="pp pq l"/></div></figure><p id="8941" class="pw-post-body-paragraph lb lc iq ld b le ng lg lh li nh lk ll lm ni lo lp lq nj ls lt lu nk lw lx ly ij bi translated">网页呈现两个标题，但样式不同。</p><figure class="ms mt mu mv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pu"><img src="../Images/ce58d2cff2e416a0aca49bc92fbb1c58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*85crgEubpqjLJjORrYgegQ.png"/></div></div></figure></div><div class="ab cl nl nm hu nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ij ik il im in"><p id="61c1" class="pw-post-body-paragraph lb lc iq ld b le ng lg lh li nh lk ll lm ni lo lp lq nj ls lt lu nk lw lx ly ij bi translated">您仅仅使用普通的javascript就创建了一个简单的、定制的、具有封装风格的web元素。以此为起点，根据您的喜好扩展它，创建您自己独特的web元素。</p><p id="9a5d" class="pw-post-body-paragraph lb lc iq ld b le ng lg lh li nh lk ll lm ni lo lp lq nj ls lt lu nk lw lx ly ij bi translated">你可以在这里找到完整的例子:</p><div class="os ot gp gr ou ov"><a href="https://github.com/j-sommer/web-component-starter" rel="noopener  ugc nofollow" target="_blank"><div class="ow ab fo"><div class="ox ab oy cl cj oz"><h2 class="bd ir gy z fp pa fr fs pb fu fw ip bi translated">j-sommer/web组件-starter</h2><div class="pc l"><h3 class="bd b gy z fp pa fr fs pb fu fw dk translated">通过在GitHub上创建一个帐户，为j-sommer/web-component-starter开发做出贡献。</h3></div><div class="pd l"><p class="bd b dl z fp pa fr fs pb fu fw dk translated">github.com</p></div></div><div class="pe l"><div class="pv l pg ph pi pe pj jw ov"/></div></div></a></div></div></div>    
</body>
</html>