<html>
<head>
<title>Custom encoding and decoding JSON in Swift</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Swift中的定制编码和解码JSON</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/custom-encoding-and-decoding-json-in-swift-a99c80b280e7?source=collection_archive---------3-----------------------#2020-04-23">https://levelup.gitconnected.com/custom-encoding-and-decoding-json-in-swift-a99c80b280e7?source=collection_archive---------3-----------------------#2020-04-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/0b4e512f4a0c725f91bb9657d501e6cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1302/format:webp/0*-t2P3atrbgHMKR6P.jpg"/></div></figure><blockquote class="ju jv jw"><p id="ed35" class="jx jy jz ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个帖子最初是我在<a class="ae kw" href="https://www.leandrofournier.com/custom-encoding-and-decoding-json/" rel="noopener ugc nofollow" target="_blank"> Swift Delivery </a>写的。</p></blockquote><p id="eab3" class="pw-post-body-paragraph jx jy iq ka b kb kc kd ke kf kg kh ki kx kk kl km ky ko kp kq kz ks kt ku kv ij bi translated">在Swift系列的上一期<a class="ae kw" rel="noopener ugc nofollow" target="_blank" href="/working-with-json-in-swift-c5faea0b19a1">与JSON的合作中，我们探索了各种项目:</a></p><ul class=""><li id="f5ea" class="la lb iq ka b kb kc kf kg kx lc ky ld kz le kv lf lg lh li bi translated"><code class="fe lj lk ll lm b">Codable</code>协议，包含另外两个协议:<code class="fe lj lk ll lm b">Encodable</code>和<code class="fe lj lk ll lm b">Decodable</code></li><li id="980c" class="la lb iq ka b kb ln kf lo kx lp ky lq kz lr kv lf lg lh li bi translated">如何将JSON数据对象解码成可读的Swift结构</li><li id="3ed8" class="la lb iq ka b kb ln kf lo kx lp ky lq kz lr kv lf lg lh li bi translated">自定义键的使用</li><li id="cb5e" class="la lb iq ka b kb ln kf lo kx lp ky lq kz lr kv lf lg lh li bi translated">自定义对象创建</li><li id="cf76" class="la lb iq ka b kb ln kf lo kx lp ky lq kz lr kv lf lg lh li bi translated">数组</li><li id="a9ac" class="la lb iq ka b kb ln kf lo kx lp ky lq kz lr kv lf lg lh li bi translated">不同的顶级实体</li></ul><p id="4ffb" class="pw-post-body-paragraph jx jy iq ka b kb kc kd ke kf kg kh ki kx kk kl km ky ko kp kq kz ks kt ku kv ij bi translated">对于Swift中JSON的基本用法来说，这就足够了，这将使我们能够读取JSON数据(解码)并创建一个新对象，该对象可以转换回JSON(编码)并将其发送到RESTFul API。</p><p id="ccf3" class="pw-post-body-paragraph jx jy iq ka b kb kc kd ke kf kg kh ki kx kk kl km ky ko kp kq kz ks kt ku kv ij bi translated">首先，让我们创建一个对象，并将其转换成JSON数据格式。</p><h1 id="e87b" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">编码</h1><h2 id="7ddc" class="mq lt iq bd lu mr ms dn ly mt mu dp mc kx mv mw mg ky mx my mk kz mz na mo nb bi translated">默认编码</h2><p id="28b0" class="pw-post-body-paragraph jx jy iq ka b kb nc kd ke kf nd kh ki kx ne kl km ky nf kp kq kz ng kt ku kv ij bi translated">让我们假设昆虫有以下<code class="fe lj lk ll lm b">struct</code>:</p><pre class="nh ni nj nk gt nl lm nm nn aw no bi"><span id="97e0" class="mq lt iq lm b gy np nq l nr ns">struct Insect: Codable {<br/>    let insectId: Int<br/>    let name: String<br/>    let isHelpful: Bool<br/>    <br/>    enum CodingKeys: String, CodingKey {<br/>        case insectId = "insect_id"<br/>        case name<br/>        case isHelpful = "is_helpful"<br/>    }<br/>}</span></pre><p id="c6f7" class="pw-post-body-paragraph jx jy iq ka b kb kc kd ke kf kg kh ki kx kk kl km ky ko kp kq kz ks kt ku kv ij bi translated">总结一下，我们有三个属性。<strong class="ka ir"> insectId </strong>为昆虫标识符，<strong class="ka ir"> name </strong>为其名称，<strong class="ka ir">为帮助性</strong>指定昆虫对我们的花园是否有帮助。其中两个属性使用自定义键(<strong class="ka ir">昆虫</strong>和<strong class="ka ir">是有用的</strong>)。</p><p id="2fbd" class="pw-post-body-paragraph jx jy iq ka b kb kc kd ke kf kg kh ki kx kk kl km ky ko kp kq kz ks kt ku kv ij bi translated">现在让我们创造一只昆虫:</p><pre class="nh ni nj nk gt nl lm nm nn aw no bi"><span id="9d84" class="mq lt iq lm b gy np nq l nr ns">let newInsect = Insect(insectId: 1006, name: "ants", isHelpful: true)</span></pre><p id="fc3f" class="pw-post-body-paragraph jx jy iq ka b kb kc kd ke kf kg kh ki kx kk kl km ky ko kp kq kz ks kt ku kv ij bi translated">我们的RESTful API期望收到一个带有新昆虫信息的JSON。然后我们必须对它进行编码:</p><pre class="nh ni nj nk gt nl lm nm nn aw no bi"><span id="8377" class="mq lt iq lm b gy np nq l nr ns">let encoder = JSONEncoder() <br/>let insectData: Data? = try? encoder.encode(newInsect)</span></pre><p id="825c" class="pw-post-body-paragraph jx jy iq ka b kb kc kd ke kf kg kh ki kx kk kl km ky ko kp kq kz ks kt ku kv ij bi translated">这很简单:现在<strong class="ka ir">昆虫数据</strong>是一个类型为<code class="fe lj lk ll lm b">Data?</code>的对象。我们可能想要检查编码是否实际工作(只是检查，您可能不会在您的代码中这样做)。让我们重写上面的代码，并使用一些可选的展开:</p><pre class="nh ni nj nk gt nl lm nm nn aw no bi"><span id="b29c" class="mq lt iq lm b gy np nq l nr ns">let encoder = JSONEncoder()<br/>if let insectData = try? encoder.encode(newInsect),<br/>    let jsonString = String(data: insectData, encoding: .utf8)<br/>    {<br/>    print(jsonString)<br/>}</span></pre><ol class=""><li id="5a7e" class="la lb iq ka b kb kc kf kg kx lc ky ld kz le kv nt lg lh li bi translated">创建编码器</li><li id="bac9" class="la lb iq ka b kb ln kf lo kx lp ky lq kz lr kv nt lg lh li bi translated">尝试对我们创建的对象进行编码</li><li id="794d" class="la lb iq ka b kb ln kf lo kx lp ky lq kz lr kv nt lg lh li bi translated">如果可能，将<code class="fe lj lk ll lm b">Data</code>对象转换成<code class="fe lj lk ll lm b">String</code></li></ol><p id="3d6e" class="pw-post-body-paragraph jx jy iq ka b kb kc kd ke kf kg kh ki kx kk kl km ky ko kp kq kz ks kt ku kv ij bi translated">然后我们打印出如下结果:</p><pre class="nh ni nj nk gt nl lm nm nn aw no bi"><span id="ad51" class="mq lt iq lm b gy np nq l nr ns">{"name":"ants","is_helpful":true,"insect_id":1006}</span></pre><blockquote class="ju jv jw"><p id="8f00" class="jx jy jz ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意，编码时使用的键不是自定义键(<strong class="ka ir">昆虫Id </strong>和<strong class="ka ir">有用</strong>)，而是预期键(<strong class="ka ir">昆虫id </strong>和<strong class="ka ir">有用</strong>)。不错！</p></blockquote><h2 id="10d0" class="mq lt iq bd lu mr ms dn ly mt mu dp mc kx mv mw mg ky mx my mk kz mz na mo nb bi translated">自定义编码</h2><p id="bd0d" class="pw-post-body-paragraph jx jy iq ka b kb nc kd ke kf nd kh ki kx ne kl km ky nf kp kq kz ng kt ku kv ij bi translated">假设我们的RESTful API期望接收大写的昆虫名称。我们需要创建自己的编码方法的实现，以确保昆虫的名称是大写的。我们必须在我们的<strong class="ka ir">昆虫</strong> <code class="fe lj lk ll lm b">struct</code>内部实现<code class="fe lj lk ll lm b">Encodable</code>协议的方法<code class="fe lj lk ll lm b"><strong class="ka ir">func</strong> encode(to encoder: Encoder) <strong class="ka ir">throws</strong></code>。</p><pre class="nh ni nj nk gt nl lm nm nn aw no bi"><span id="c8fe" class="mq lt iq lm b gy np nq l nr ns">struct Insect: Codable {<br/>    let insectId: Int<br/>    let name: String<br/>    let isHelpful: Bool<br/>    <br/>    enum CodingKeys: String, CodingKey {<br/>        case insectId = "insect_id"<br/>        case name<br/>        case isHelpful = "is_helpful"<br/>    }<br/>    <br/>    func encode(to encoder: Encoder) throws {<br/>        var container = encoder.container(keyedBy: CodingKeys.self)<br/>        try container.encode(insectId, forKey: .insectId)<br/>        try container.encode(name.uppercased(), forKey: .name)<br/>        try container.encode(isHelpful, forKey: .isHelpful)<br/>    }<br/>}</span></pre><p id="ea03" class="pw-post-body-paragraph jx jy iq ka b kb kc kd ke kf kg kh ki kx kk kl km ky ko kp kq kz ks kt ku kv ij bi translated">第13行是我们创建一个存储编码值的容器的地方。容器必须是一个<code class="fe lj lk ll lm b">var</code>，因为它是可变的，并且必须接收要使用的键。</p><p id="0c6e" class="pw-post-body-paragraph jx jy iq ka b kb kc kd ke kf kg kh ki kx kk kl km ky ko kp kq kz ks kt ku kv ij bi translated">第14到16行用于将值编码到容器中，这是使用<code class="fe lj lk ll lm b">try</code>完成的，因为其中任何一行都可能抛出错误。</p><p id="3f17" class="pw-post-body-paragraph jx jy iq ka b kb kc kd ke kf kg kh ki kx kk kl km ky ko kp kq kz ks kt ku kv ij bi translated">现在，看第15行:我们不仅仅是按原样输入值，而是将它大写，这是我们实现自定义编码的主要原因。</p><p id="f7dc" class="pw-post-body-paragraph jx jy iq ka b kb kc kd ke kf kg kh ki kx kk kl km ky ko kp kq kz ks kt ku kv ij bi translated">如果您运行上面的代码，在那里我们创建了<strong class="ka ir">昆虫</strong>“蚂蚁”，我们将会看到，在将生成的JSON <code class="fe lj lk ll lm b">Data</code>编码并转换为<code class="fe lj lk ll lm b">String</code>之后，我们会得到以下结果:</p><pre class="nh ni nj nk gt nl lm nm nn aw no bi"><span id="cc75" class="mq lt iq lm b gy np nq l nr ns">{"name":"ANTS","is_helpful":true,"insect_id":1006}</span></pre><p id="a50d" class="pw-post-body-paragraph jx jy iq ka b kb kc kd ke kf kg kh ki kx kk kl km ky ko kp kq kz ks kt ku kv ij bi translated">正如你可能已经看到的，昆虫的名字现在是大写的，尽管我们把它变成了小写的。多酷啊！</p><h1 id="2524" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">定制解码</h1><p id="2940" class="pw-post-body-paragraph jx jy iq ka b kb nc kd ke kf nd kh ki kx ne kl km ky nf kp kq kz ng kt ku kv ij bi translated">到目前为止，我们一直依赖于<code class="fe lj lk ll lm b">Decodable</code>协议的默认解码方法。但是让我们看看另一个场景。</p><pre class="nh ni nj nk gt nl lm nm nn aw no bi"><span id="cf3a" class="mq lt iq lm b gy np nq l nr ns">[<br/>   {<br/>      "insect_id":1001,<br/>      "name":"BEES",<br/>      "details":{<br/>         "is_helpful":true<br/>      }<br/>   },<br/>   {<br/>      "insect_id":1002,<br/>      "name":"LADYBUGS",<br/>      "details":{<br/>         "is_helpful":true<br/>      }<br/>   },<br/>   {<br/>      "insect_id":1003,<br/>      "name":"SPIDERS",<br/>      "details":{<br/>         "is_helpful":true<br/>      }<br/>   },<br/>   {<br/>      "insect_id":2001,<br/>      "name":"TOMATO HORN WORMS",<br/>      "details":{<br/>         "is_helpful":false<br/>      }<br/>   },<br/>   {<br/>      "insect_id":2002,<br/>      "name":"CABBAGE WORMS",<br/>      "details":{<br/>         "is_helpful":false<br/>      }<br/>   },<br/>   {<br/>      "insect_id":2003,<br/>      "name":"CABBAGE MOTHS",<br/>      "details":{<br/>         "is_helpful":false<br/>      }<br/>   }<br/>]</span></pre><p id="8742" class="pw-post-body-paragraph jx jy iq ka b kb kc kd ke kf kg kh ki kx kk kl km ky ko kp kq kz ks kt ku kv ij bi translated">API正在检索<strong class="ka ir"> details </strong>实体内的<strong class="ka ir">is _ helical</strong>属性。但是我们不想创建一个<strong class="ka ir">细节</strong>对象:我们只是想展平那个对象，这样我们就可以使用我们现有的<strong class="ka ir">昆虫</strong>对象。</p><p id="5d92" class="pw-post-body-paragraph jx jy iq ka b kb kc kd ke kf kg kh ki kx kk kl km ky ko kp kq kz ks kt ku kv ij bi translated">是时候使用我们自己实现的<code class="fe lj lk ll lm b">Decodable</code>协议的<code class="fe lj lk ll lm b"><strong class="ka ir">init</strong>(from decoder: Decoder) <strong class="ka ir">throws</strong></code>方法和一些额外的工作了。让我们开始吧。</p><p id="9e97" class="pw-post-body-paragraph jx jy iq ka b kb kc kd ke kf kg kh ki kx kk kl km ky ko kp kq kz ks kt ku kv ij bi translated">首先，编码键发生了变化，因为<strong class="ka ir">是有用的</strong>不是以前同一级别的键，有一个新的键叫做<strong class="ka ir">细节</strong>。要解决这个问题:</p><pre class="nh ni nj nk gt nl lm nm nn aw no bi"><span id="f125" class="mq lt iq lm b gy np nq l nr ns">enum CodingKeys: String, CodingKey {<br/>        case insectId = "insect_id"<br/>        case name<br/>        case details<br/>    }<br/>    <br/>    enum DetailsCodingKeys: String, CodingKey {<br/>        case isHelpful = "is_helpful"<br/>    }</span></pre><p id="7b61" class="pw-post-body-paragraph jx jy iq ka b kb kc kd ke kf kg kh ki kx kk kl km ky ko kp kq kz ks kt ku kv ij bi translated">在第4行中，我们用新的密钥替换现有的密钥，<strong class="ka ir">细节</strong>。</p><p id="4828" class="pw-post-body-paragraph jx jy iq ka b kb kc kd ke kf kg kh ki kx kk kl km ky ko kp kq kz ks kt ku kv ij bi translated">在第7行和第9行，我们创建了一组新的键，这些键存在于<strong class="ka ir">细节</strong>中，在本例中只有一个，<strong class="ka ir">是有用的</strong>。</p><blockquote class="ju jv jw"><p id="82e9" class="jx jy jz ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意，我们没有触及<strong class="ka ir">虫</strong>T10】的属性。</p></blockquote><p id="c144" class="pw-post-body-paragraph jx jy iq ka b kb kc kd ke kf kg kh ki kx kk kl km ky ko kp kq kz ks kt ku kv ij bi translated">现在让我们深入解码器初始化:</p><pre class="nh ni nj nk gt nl lm nm nn aw no bi"><span id="d615" class="mq lt iq lm b gy np nq l nr ns">init(from decoder: Decoder) throws {<br/>   let container = try decoder.container(keyedBy: CodingKeys.self)<br/>        <br/>   insectId = try container.decode(Int.self, forKey: .insectId)<br/>   name = try container.decode(String.self, forKey: .name)<br/>   let details = try container.nestedContainer(keyedBy: DetailsCodingKeys.self, forKey: .details)<br/>   isHelpful = try details.decode(Bool.self, forKey: .isHelpful)<br/>}</span></pre><p id="3b1f" class="pw-post-body-paragraph jx jy iq ka b kb kc kd ke kf kg kh ki kx kk kl km ky ko kp kq kz ks kt ku kv ij bi translated">在第2行中，我们创建了一个容器，它解码了整个JSON结构。</p><p id="dca5" class="pw-post-body-paragraph jx jy iq ka b kb kc kd ke kf kg kh ki kx kk kl km ky ko kp kq kz ks kt ku kv ij bi translated">在第4行和第5行中，我们只解码了<strong class="ka ir"> insectId </strong>属性的<code class="fe lj lk ll lm b">Int</code>值和<strong class="ka ir"> name </strong>属性的<code class="fe lj lk ll lm b">String</code>值。</p><p id="b00c" class="pw-post-body-paragraph jx jy iq ka b kb kc kd ke kf kg kh ki kx kk kl km ky ko kp kq kz ks kt ku kv ij bi translated">在第6行中，我们在由全新的<strong class="ka ir">details coding keys</strong>T2】键控的<strong class="ka ir"> details </strong>键下抓取嵌套容器。</p><p id="eeb9" class="pw-post-body-paragraph jx jy iq ka b kb kc kd ke kf kg kh ki kx kk kl km ky ko kp kq kz ks kt ku kv ij bi translated">在第7行中，我们只是解码了新的<strong class="ka ir">细节</strong>容器中<strong class="ka ir">is help</strong>属性的<code class="fe lj lk ll lm b">Bool</code>值。</p><p id="1359" class="pw-post-body-paragraph jx jy iq ka b kb kc kd ke kf kg kh ki kx kk kl km ky ko kp kq kz ks kt ku kv ij bi translated">但不是这样。由于我们的<strong class="ka ir"> CodingKeys </strong>已经通过添加<strong class="ka ir">细节</strong>案例而改变，我们的定制编码实现必须被修复。让我们开始吧:</p><pre class="nh ni nj nk gt nl lm nm nn aw no bi"><span id="bc12" class="mq lt iq lm b gy np nq l nr ns">func encode(to encoder: Encoder) throws {<br/>    var container = encoder.container(keyedBy: CodingKeys.self)<br/>    try container.encode(insectId, forKey: .insectId)<br/>    try container.encode(name.uppercased(), forKey: .name)<br/>    var details = container.nestedContainer(keyedBy: DetailsCodingKeys.self, forKey: .details)<br/>    try details.encode(isHelpful, forKey: .isHelpful)<br/>}</span></pre><p id="5c0e" class="pw-post-body-paragraph jx jy iq ka b kb kc kd ke kf kg kh ki kx kk kl km ky ko kp kq kz ks kt ku kv ij bi translated">我们只是改变了编码<strong class="ka ir">is help</strong>属性的方式。</p><p id="aa83" class="pw-post-body-paragraph jx jy iq ka b kb kc kd ke kf kg kh ki kx kk kl km ky ko kp kq kz ks kt ku kv ij bi translated">在第5行中，我们创建了一个新的嵌套容器，使用了JSON中的<strong class="ka ir">details coding keys</strong>T4】中的键，并在<strong class="ka ir"> details </strong>实体中使用。</p><p id="2dc8" class="pw-post-body-paragraph jx jy iq ka b kb kc kd ke kf kg kh ki kx kk kl km ky ko kp kq kz ks kt ku kv ij bi translated">在第6行，我们在全新的<strong class="ka ir">细节</strong>嵌套容器中编码<strong class="ka ir">是有用的</strong>。</p><p id="244e" class="pw-post-body-paragraph jx jy iq ka b kb kc kd ke kf kg kh ki kx kk kl km ky ko kp kq kz ks kt ku kv ij bi translated">所以，总结一下，我们的<strong class="ka ir">虫</strong>T5】长这样:</p><pre class="nh ni nj nk gt nl lm nm nn aw no bi"><span id="c248" class="mq lt iq lm b gy np nq l nr ns">struct Insect: Codable {<br/>    let insectId: Int<br/>    let name: String<br/>    let isHelpful: Bool<br/>    <br/>    enum CodingKeys: String, CodingKey {<br/>        case insectId = "insect_id"<br/>        case name<br/>        case details<br/>    }<br/>    <br/>    enum DetailsCodingKeys: String, CodingKey {<br/>        case isHelpful = "is_helpful"<br/>    }<br/>    <br/>    init(from decoder: Decoder) throws {<br/>        let container = try decoder.container(keyedBy: CodingKeys.self)<br/>        <br/>        insectId = try container.decode(Int.self, forKey: .insectId)<br/>        name = try container.decode(String.self, forKey: .name)<br/>        let details = try container.nestedContainer(keyedBy: DetailsCodingKeys.self, forKey: .details)<br/>        isHelpful = try details.decode(Bool.self, forKey: .isHelpful)<br/>        <br/>    }<br/>    <br/>    func encode(to encoder: Encoder) throws {<br/>        var container = encoder.container(keyedBy: CodingKeys.self)<br/>        try container.encode(insectId, forKey: .insectId)<br/>        try container.encode(name.uppercased(), forKey: .name)<br/>        var details = container.nestedContainer(keyedBy: DetailsCodingKeys.self, forKey: .details)<br/>        try details.encode(isHelpful, forKey: .isHelpful)<br/>    }<br/>}</span></pre><p id="ef34" class="pw-post-body-paragraph jx jy iq ka b kb kc kd ke kf kg kh ki kx kk kl km ky ko kp kq kz ks kt ku kv ij bi translated">如果我们解码它:</p><pre class="nh ni nj nk gt nl lm nm nn aw no bi"><span id="3c84" class="mq lt iq lm b gy np nq l nr ns">let decoder = JSONDecoder()<br/>if let insects = try? decoder.decode([Insect].self, from: jsonData!) {<br/>    print(insects)<br/>}</span></pre><p id="cb14" class="pw-post-body-paragraph jx jy iq ka b kb kc kd ke kf kg kh ki kx kk kl km ky ko kp kq kz ks kt ku kv ij bi translated">我们会得到这样的结果:</p><pre class="nh ni nj nk gt nl lm nm nn aw no bi"><span id="1584" class="mq lt iq lm b gy np nq l nr ns">[__lldb_expr_54.Insect(insectId: 1001, name: "BEES", isHelpful: true), __lldb_expr_54.Insect(insectId: 1002, name: "LADYBUGS", isHelpful: true), __lldb_expr_54.Insect(insectId: 1003, name: "SPIDERS", isHelpful: true), __lldb_expr_54.Insect(insectId: 2001, name: "TOMATO HORN WORMS", isHelpful: false), __lldb_expr_54.Insect(insectId: 2002, name: "CABBAGE WORMS", isHelpful: false), __lldb_expr_54.Insect(insectId: 2003, name: "CABBAGE MOTHS", isHelpful: false)]</span></pre><p id="470c" class="pw-post-body-paragraph jx jy iq ka b kb kc kd ke kf kg kh ki kx kk kl km ky ko kp kq kz ks kt ku kv ij bi translated">如您所见，没有<strong class="ka ir">细节</strong>实体:只有我们的<code class="fe lj lk ll lm b">struct</code>属性。</p><p id="3297" class="pw-post-body-paragraph jx jy iq ka b kb kc kd ke kf kg kh ki kx kk kl km ky ko kp kq kz ks kt ku kv ij bi translated">编码也会像预期的那样工作。</p><p id="0b61" class="pw-post-body-paragraph jx jy iq ka b kb kc kd ke kf kg kh ki kx kk kl km ky ko kp kq kz ks kt ku kv ij bi translated">这篇文章，加上之前的系列文章，总结了在Swift中使用JSON时可能遇到的最常见的场景。</p><h1 id="0f1d" class="ls lt iq bd lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp bi translated">需要更多信息？</h1><p id="787d" class="pw-post-body-paragraph jx jy iq ka b kb nc kd ke kf nd kh ki kx ne kl km ky nf kp kq kz ng kt ku kv ij bi translated">Ben Scheirman的<a class="ae kw" href="https://benscheirman.com/2017/06/swift-json/" rel="noopener ugc nofollow" target="_blank">Swift JSON解析终极指南</a>是我能找到的关于这个主题的最有用的资源。</p></div></div>    
</body>
</html>