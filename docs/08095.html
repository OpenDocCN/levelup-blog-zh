<html>
<head>
<title>Securing a Go Microservice with JWT</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">保护JWT的Go微服务</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/securing-a-go-microservice-with-jwt-184beca41989?source=collection_archive---------7-----------------------#2021-04-02">https://levelup.gitconnected.com/securing-a-go-microservice-with-jwt-184beca41989?source=collection_archive---------7-----------------------#2021-04-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/1d93e228862dbe59d376b9712fed36df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*rQl-xhhYTOhHjVaO.png"/></div></div></figure><h1 id="054e" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">保护JWT的Go微服务</h1><p id="76c7" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">JSON Web token(jwt)提供了一种机制，将一组声明或属性从客户端共享到服务器，服务器以加密的安全方式提供微服务。JWT保护服务到服务的通信，还可以跨微服务传递最终用户上下文。</p><p id="c938" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">JWT令牌可以用来携带调用微服务的身份，或者发起请求的客户端或系统的身份。它可用于在多个客户端和服务器之间传递授权和验证属性。使用这些属性可以保护微服务，并确保只有经过授权的访问才会发生。</p><p id="72c8" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">在本帖中，我们将探讨JWT在golang微服务部署示例中保护服务对服务通信方面所扮演的角色。在golang编程生态系统中，有一个开源的<code class="fe lz ma mb mc b">jwt-go</code>包使我们能够生成JWT令牌。</p><p id="8b61" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">首先，我们将使用这个包来生成JWT令牌，并创建一个服务于该令牌的端点API。您还可以使用诸如FusionAuth之类的认证系统来生成JWT，但是看看jwt是如何在较低的级别上创建的会有所启发。</p><p id="9dfd" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">然后，我们将创建微服务服务器。将有一个授权中间件，它将在允许访问golang微服务之前执行。该中间件将接受JWT令牌并对其进行验证，以确保对微服务的授权访问。</p><p id="acef" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">所以，让我们开始吧！</p><h1 id="7c1a" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">先决条件</h1><ul class=""><li id="6413" class="md me iq ky b kz la ld le lh mf ll mg lp mh lt mi mj mk ml bi translated">安装<a class="ae mm" href="https://golang.org/" rel="noopener ugc nofollow" target="_blank"> Golang 1.15.8 </a></li><li id="272c" class="md me iq ky b kz mn ld mo lh mp ll mq lp mr lt mi mj mk ml bi translated">基于JWT的认证的基础知识</li><li id="b041" class="md me iq ky b kz mn ld mo lh mp ll mq lp mr lt mi mj mk ml bi translated">golang编程的基础知识</li></ul><h1 id="31a7" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">用go模块实现JWT端点</h1><p id="b056" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在本节中，我们将创建一个端点，该端点生成一个JWT，然后将其返回给客户端。如果你想克隆它并跟随它，所有的代码都可以在Github 上找到。</p><p id="0fcf" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我们将使用HMAC算法来加密令牌。</p><p id="f94c" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">首先，我们将从创建一个端点来发布JWT开始。为此，我们将使用GitHub 的<a class="ae mm" href="https://github.com/dgrijalva/jwt-go" rel="noopener ugc nofollow" target="_blank"> jwt-go包。</a></p><p id="ba9a" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">在开始实现这个端点之前，我们需要首先创建一个go项目模块。让我们保持整洁，创建一个名为<code class="fe lz ma mb mc b">jwt_client</code>的文件夹:</p><pre class="ms mt mu mv gt mw mc mx my aw mz bi"><span id="8c47" class="na jz iq mc b gy nb nc l nd ne">mkdir jwt_client &amp;&amp; cd jwt_client</span></pre><p id="ab72" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">然后，创建go模块:</p><pre class="ms mt mu mv gt mw mc mx my aw mz bi"><span id="4bdf" class="na jz iq mc b gy nb nc l nd ne">go mod init jwt_client</span></pre><p id="89af" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">然后，我们需要创建一个名为<code class="fe lz ma mb mc b">main.go</code>的文件。在其中，我们可以开始导入必要的包，如下面的代码片段所示:</p><pre class="ms mt mu mv gt mw mc mx my aw mz bi"><span id="9136" class="na jz iq mc b gy nb nc l nd ne">package main</span><span id="cd6c" class="na jz iq mc b gy nf nc l nd ne">import (<br/>  "fmt"<br/>  "time"<br/>  jwt "github.com/dgrijalva/jwt-go"<br/>)</span></pre><h1 id="49c3" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">设置共享密钥</h1><p id="095e" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">接下来，我们定义一个签名密钥，如下所示。我们可以硬编码这个秘密:</p><pre class="ms mt mu mv gt mw mc mx my aw mz bi"><span id="3e61" class="na jz iq mc b gy nb nc l nd ne">var mySigningKey = []byte("unicorns")</span></pre><p id="835a" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">但是为了增加安全性和灵活性，我们可以使用环境变量来存储密钥，而不是将它硬编码在应用程序中:</p><pre class="ms mt mu mv gt mw mc mx my aw mz bi"><span id="e1a1" class="na jz iq mc b gy nb nc l nd ne">var mySigningKey = []byte(os.Getenv("SECRET_KEY"))</span></pre><p id="ea73" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我们可以通过在运行go程序的终端中执行以下命令来设置这个环境变量:</p><pre class="ms mt mu mv gt mw mc mx my aw mz bi"><span id="015e" class="na jz iq mc b gy nb nc l nd ne">set SECRET_KEY=unicorns // for windows<br/>export SECRET_KEY=unicorns // for linux or mac</span></pre><p id="cae0" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">每当您启动一个新的终端并希望运行这段代码时，您都需要设置这个值。您还可以将这个环境变量添加到shell启动脚本中，以避免这种麻烦。</p><h1 id="2969" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">生成JWT</h1><p id="823b" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">为了生成令牌，我们需要创建一个名为<code class="fe lz ma mb mc b">GetJWT</code>的函数。在函数中，我们首先使用jwt库提供的<code class="fe lz ma mb mc b">New</code>方法初始化一个新的<code class="fe lz ma mb mc b">JWT</code>实例。</p><p id="af49" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我们需要在初始化令牌时将签名方法算法配置为<code class="fe lz ma mb mc b">HS256</code>。支持多种不同的签名方法，但我们使用HMAC，一种对称签名算法，因为它最容易实现。</p><p id="c2f6" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">然后，我们在<code class="fe lz ma mb mc b">claims</code>地图中创建令牌有效负载；您可以按照自己的意愿进行定制，但是建议包括如图所示的标准声明<code class="fe lz ma mb mc b">aud</code>、<code class="fe lz ma mb mc b">iss</code>和<code class="fe lz ma mb mc b">exp</code>。我们将通过适当地设置<code class="fe lz ma mb mc b">exp</code>声明，将这个JWT设置为一分钟有效。</p><p id="c548" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">最后，我们用前面定义的<code class="fe lz ma mb mc b">mySigningKey</code>变量的值对令牌进行签名。之后，我们从函数中返回<code class="fe lz ma mb mc b">tokenString</code>。</p><p id="23cd" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">下面是<code class="fe lz ma mb mc b">GetJWT</code>函数的所有优点:</p><pre class="ms mt mu mv gt mw mc mx my aw mz bi"><span id="714b" class="na jz iq mc b gy nb nc l nd ne">// ...<br/>func GetJWT() (string, error) {<br/>  token := jwt.New(jwt.SigningMethodHS256)</span><span id="6aa0" class="na jz iq mc b gy nf nc l nd ne">  claims := token.Claims.(jwt.MapClaims)</span><span id="58b8" class="na jz iq mc b gy nf nc l nd ne">  claims["authorized"] = true<br/>  claims["client"] = "Krissanawat"<br/>  claims["aud"] = "billing.jwtgo.io"<br/>  claims["iss"] = "jwtgo.io"<br/>  claims["exp"] = time.Now().Add(time.Minute * 1).Unix()</span><span id="871c" class="na jz iq mc b gy nf nc l nd ne">  tokenString, err := token.SignedString(mySigningKey)</span><span id="c9bb" class="na jz iq mc b gy nf nc l nd ne">  if err != nil {<br/>    fmt.Errorf("Something Went Wrong: %s", err.Error())<br/>    return "", err<br/>  }</span><span id="124b" class="na jz iq mc b gy nf nc l nd ne">  return tokenString, nil<br/>}<br/>// ...</span></pre><h1 id="17de" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">建立golang流程为JWT服务</h1><p id="454d" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">现在，让我们实际上提供这个令牌。我们首先导入额外的包，如<code class="fe lz ma mb mc b">net/http</code>和<code class="fe lz ma mb mc b">log</code>来创建服务器:</p><pre class="ms mt mu mv gt mw mc mx my aw mz bi"><span id="9fe4" class="na jz iq mc b gy nb nc l nd ne">import (<br/>  "fmt"<br/>  "log"<br/>  "net/http"<br/>  "time"</span><span id="e058" class="na jz iq mc b gy nf nc l nd ne">  jwt "github.com/dgrijalva/jwt-go"<br/>)<br/>// ...</span></pre><p id="dbb0" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我们需要创建函数来处理对端口8080的HTTP请求，如下所示:</p><pre class="ms mt mu mv gt mw mc mx my aw mz bi"><span id="4c23" class="na jz iq mc b gy nb nc l nd ne">// ...<br/>func Index(w http.ResponseWriter, r *http.Request) {<br/>  validToken, err := GetJWT()<br/>  fmt.Println(validToken)<br/>  if err != nil {<br/>    fmt.Println("Failed to generate token")<br/>  }</span><span id="e212" class="na jz iq mc b gy nf nc l nd ne">  fmt.Fprintf(w, string(validToken))<br/>}</span><span id="b30b" class="na jz iq mc b gy nf nc l nd ne">func handleRequests() {<br/>  http.HandleFunc("/", Index)</span><span id="a659" class="na jz iq mc b gy nf nc l nd ne">  log.Fatal(http.ListenAndServe(":8080", nil))<br/>}</span><span id="e39d" class="na jz iq mc b gy nf nc l nd ne">func main() {<br/>    handleRequests()<br/>}</span></pre><p id="008e" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">整个JWT服务器如下所示:</p><pre class="ms mt mu mv gt mw mc mx my aw mz bi"><span id="c23e" class="na jz iq mc b gy nb nc l nd ne">package main</span><span id="f932" class="na jz iq mc b gy nf nc l nd ne">import (<br/>  "fmt"<br/>  "log"<br/>  "net/http"<br/>  "os"<br/>  "time"</span><span id="f332" class="na jz iq mc b gy nf nc l nd ne">  jwt "github.com/dgrijalva/jwt-go"<br/>)<br/>var mySigningKey = []byte(os.Getenv("SECRET_KEY"))</span><span id="f85a" class="na jz iq mc b gy nf nc l nd ne">func GetJWT() (string, error) {<br/>  token := jwt.New(jwt.SigningMethodHS256)</span><span id="536c" class="na jz iq mc b gy nf nc l nd ne">  claims := token.Claims.(jwt.MapClaims)</span><span id="a538" class="na jz iq mc b gy nf nc l nd ne">  claims["authorized"] = true<br/>  claims["client"] = "Krissanawat"<br/>  claims["aud"] = "billing.jwtgo.io"<br/>  claims["iss"] = "jwtgo.io"<br/>  claims["exp"] = time.Now().Add(time.Minute * 1).Unix()</span><span id="a23a" class="na jz iq mc b gy nf nc l nd ne">  tokenString, err := token.SignedString(mySigningKey)</span><span id="809d" class="na jz iq mc b gy nf nc l nd ne">  if err != nil {<br/>    fmt.Errorf("Something Went Wrong: %s", err.Error())<br/>    return "", err<br/>  }</span><span id="facf" class="na jz iq mc b gy nf nc l nd ne">  return tokenString, nil<br/>}</span><span id="dc6a" class="na jz iq mc b gy nf nc l nd ne">func Index(w http.ResponseWriter, r *http.Request) {<br/>  validToken, err := GetJWT()<br/>  fmt.Println(validToken)<br/>  if err != nil {<br/>    fmt.Println("Failed to generate token")<br/>  }</span><span id="3adb" class="na jz iq mc b gy nf nc l nd ne">  fmt.Fprintf(w, string(validToken))<br/>}</span><span id="aaa1" class="na jz iq mc b gy nf nc l nd ne">func handleRequests() {<br/>  http.HandleFunc("/", Index)</span><span id="ad32" class="na jz iq mc b gy nf nc l nd ne">  log.Fatal(http.ListenAndServe(":8080", nil))<br/>}</span><span id="2ac6" class="na jz iq mc b gy nf nc l nd ne">func main() {<br/>  handleRequests()<br/>}</span></pre><h1 id="9f90" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">启动go服务器</h1><p id="f852" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">现在，我们安装导入的软件包，并通过执行以下命令启动服务器:</p><pre class="ms mt mu mv gt mw mc mx my aw mz bi"><span id="ef2b" class="na jz iq mc b gy nb nc l nd ne">go get<br/>go run main.go</span></pre><p id="260d" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我们可以通过执行curl命令快速测试服务器是否返回令牌:</p><pre class="ms mt mu mv gt mw mc mx my aw mz bi"><span id="a8e6" class="na jz iq mc b gy nb nc l nd ne">curl <a class="ae mm" href="http://localhost:8080" rel="noopener ugc nofollow" target="_blank">http://localhost:8080</a></span></pre><p id="e77a" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">如果成功，我们将看到响应中的令牌字符串:</p><pre class="ms mt mu mv gt mw mc mx my aw mz bi"><span id="8c59" class="na jz iq mc b gy nb nc l nd ne">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOiJiaWxsaW5nLmp3dGdvLmlvIiwiYXV0aG9yaXplZCI6dHJ1ZSwiY2xpZW50IjoiS3Jpc3NhbmF3YXQiLCJleHAiOjE2MTM1MDk1MDcsImlzcyI6Imp3dGdvLmlvIn0.t7qdqrpLk3nBOZFLBL_UOdciZ_rWei0rJg3tgyJ7cTw</span></pre><p id="7c36" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">现在，在下一部分中，我们将这个令牌发送给微服务。</p><h1 id="559b" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">实现一个简单的API网关来验证JWT</h1><p id="b2fb" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在本节中，我们将验证JWT。发现令牌有效后，客户端可以与受保护的内部服务进行交互。该服务器将充当客户端的API网关。</p><p id="4895" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">这里，我们首先在根项目中创建一个名为<code class="fe lz ma mb mc b">api_gateway</code>的新文件夹。该文件夹将是<code class="fe lz ma mb mc b">jwt_client</code>的同级文件夹。如果您仍然在<code class="fe lz ma mb mc b">jwt_client</code>文件夹中，运行以下命令:</p><pre class="ms mt mu mv gt mw mc mx my aw mz bi"><span id="e3a4" class="na jz iq mc b gy nb nc l nd ne">mkdir ../api_gateway<br/>cd ../api_gateway</span></pre><p id="84dc" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">现在我们在<code class="fe lz ma mb mc b">api_gateway</code>文件夹中。我们需要像前面一样，通过执行以下命令来创建一个go项目模块:</p><pre class="ms mt mu mv gt mw mc mx my aw mz bi"><span id="5968" class="na jz iq mc b gy nb nc l nd ne">go mod init api_gateway</span></pre><p id="1319" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">然后，我们需要在文件夹中创建另一个<code class="fe lz ma mb mc b">main.go</code>文件。</p><p id="00ac" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">在这个新的<code class="fe lz ma mb mc b">main.go</code>文件中，我们需要像之前一样导入助手包:</p><pre class="ms mt mu mv gt mw mc mx my aw mz bi"><span id="7a7d" class="na jz iq mc b gy nb nc l nd ne">package main</span><span id="2b74" class="na jz iq mc b gy nf nc l nd ne">import (<br/>  "fmt"<br/>  "log"<br/>  "net/http"</span><span id="5559" class="na jz iq mc b gy nf nc l nd ne">  "github.com/dgrijalva/jwt-go"<br/>)</span></pre><h1 id="9471" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">设置签名密钥</h1><p id="940d" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我们还需要在这里访问我们的签名密钥:</p><pre class="ms mt mu mv gt mw mc mx my aw mz bi"><span id="1718" class="na jz iq mc b gy nb nc l nd ne">var MySigningKey = (byte[])os.Getenv("SECRET_KEY")</span></pre><p id="ba5c" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">该密钥将用于验证呈现给我们的微服务的JWT。</p><h1 id="1d16" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">创建中间件来拦截传入的请求并验证JWT</h1><p id="4fe0" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">分配密钥后，我们需要做的第一件事是创建一个中间件来拦截所有传入的请求。在允许请求进一步处理之前，它将检查是否提供了令牌。</p><p id="6a16" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">下面是这个函数的框架:</p><pre class="ms mt mu mv gt mw mc mx my aw mz bi"><span id="b02b" class="na jz iq mc b gy nb nc l nd ne">// ...<br/>func isAuthorized(endpoint func(http.ResponseWriter, *http.Request)) http.Handler {<br/>  return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {<br/>    if r.Header["Token"] != nil {<br/>      // TODO<br/>    } else {<br/>      fmt.Fprintf(w, "No Authorization Token provided")<br/>    }<br/>  })<br/>}<br/>// ...</span></pre><p id="e248" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">接下来我们将为<code class="fe lz ma mb mc b">//TODO</code>部分构建代码。</p><h1 id="a354" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">构建中间件JWT解析逻辑</h1><p id="4ad0" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我们需要解析令牌并检查凭证，以确定请求是否被授权。我们将验证令牌是否经过签名，签名方法是否正确，以及受众和发行者是否符合我们的预期。如果发生任何错误，我们将错误消息作为响应返回，而不是传递请求。</p><p id="94b7" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">然而，在快乐路径中，我们让客户机请求传递到下一个端点。</p><p id="d408" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">下面是<code class="fe lz ma mb mc b">//TODO</code>部分的代码:</p><pre class="ms mt mu mv gt mw mc mx my aw mz bi"><span id="0d75" class="na jz iq mc b gy nb nc l nd ne">token, err := jwt.Parse(r.Header["Token"][0], func(token *jwt.Token) (interface{}, error) {<br/>  if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {<br/>    return nil, fmt.Errorf(("Invalid Signing Method"))<br/>  }<br/>  if _, ok := token.Claims.(jwt.Claims); !ok &amp;&amp; !token.Valid {<br/>    return nil, fmt.Errorf(("Expired token"))<br/>  }<br/>  aud := "billing.jwtgo.io"<br/>  checkAudience := token.Claims.(jwt.MapClaims).VerifyAudience(aud, false)<br/>  if !checkAudience {<br/>    return nil, fmt.Errorf(("invalid aud"))<br/>  }<br/>  iss := "jwtgo.io"<br/>  checkIss := token.Claims.(jwt.MapClaims).VerifyIssuer(iss, false)<br/>  if !checkIss {<br/>    return nil, fmt.Errorf(("invalid iss"))<br/>  }</span><span id="58ef" class="na jz iq mc b gy nf nc l nd ne">  return MySigningKey, nil<br/>})<br/>if err != nil {<br/>  fmt.Fprintf(w, err.Error())<br/>}</span><span id="628c" class="na jz iq mc b gy nf nc l nd ne">if token.Valid {<br/>  endpoint(w, r)<br/>}</span></pre><h1 id="98db" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">添加微服务端点</h1><p id="194b" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">好的，那么<code class="fe lz ma mb mc b">isAuthorized</code>通过验证令牌来防止对端点的未授权访问。但是它在保护什么呢？一旦客户的请求被验证，我们需要创建一个端点来返回<em class="ng">一些东西</em>。就这么办吧。</p><pre class="ms mt mu mv gt mw mc mx my aw mz bi"><span id="d6c0" class="na jz iq mc b gy nb nc l nd ne">func index(w http.ResponseWriter, r *http.Request) {<br/>  fmt.Fprintf(w, "Super Secret Information")<br/>}</span></pre><p id="a87b" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">(您可以随意构建比上面更有用的东西，但是出于说明的目的，返回<code class="fe lz ma mb mc b">Super Secret Information</code>足以显示端点通过检查JWT而受到保护。)</p><p id="7fec" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">我们还需要在<code class="fe lz ma mb mc b">main.go</code>的顶部导入服务器包，如下面的代码片段所示:</p><pre class="ms mt mu mv gt mw mc mx my aw mz bi"><span id="4ac3" class="na jz iq mc b gy nb nc l nd ne">import (<br/>  "fmt"<br/>  "log"<br/>  "net/http"</span><span id="cbf5" class="na jz iq mc b gy nf nc l nd ne">  "github.com/dgrijalva/jwt-go"<br/>)<br/>// ...</span></pre><p id="89d2" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">然后，我们需要用jwt中间件包装我们的索引端点。我们也将在端口9001上监听。</p><pre class="ms mt mu mv gt mw mc mx my aw mz bi"><span id="1a13" class="na jz iq mc b gy nb nc l nd ne">// ...<br/>func handleRequests() {<br/>  http.Handle("/", isAuthorized(index))<br/>  log.Fatal(http.ListenAndServe(":9001", nil))<br/>}<br/>func main() {<br/>  fmt.Println("server")<br/>  handleRequests()<br/>}</span></pre><p id="6f7f" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">就这样，我们的受保护微服务已经准备就绪。<code class="fe lz ma mb mc b">main.go</code>全部如下:</p><pre class="ms mt mu mv gt mw mc mx my aw mz bi"><span id="66cc" class="na jz iq mc b gy nb nc l nd ne">package main</span><span id="e86c" class="na jz iq mc b gy nf nc l nd ne">import (<br/>  "fmt"<br/>  "log"<br/>  "net/http"<br/>  "os"</span><span id="7825" class="na jz iq mc b gy nf nc l nd ne">  "github.com/dgrijalva/jwt-go"<br/>)</span><span id="3de4" class="na jz iq mc b gy nf nc l nd ne">var MySigningKey = []byte(os.Getenv("SECRET_KEY"))</span><span id="0d57" class="na jz iq mc b gy nf nc l nd ne">func homePage(w http.ResponseWriter, r *http.Request) {<br/>  fmt.Fprintf(w, "Super Secret Information")<br/>}<br/>func isAuthorized(endpoint func(http.ResponseWriter, *http.Request)) http.Handler {<br/>  return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {<br/>    if r.Header["Token"] != nil {</span><span id="c468" class="na jz iq mc b gy nf nc l nd ne">      token, err := jwt.Parse(r.Header["Token"][0], func(token *jwt.Token) (interface{}, error) {<br/>        if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {<br/>          return nil, fmt.Errorf(("Invalid Signing Method"))<br/>        }<br/>        aud := "billing.jwtgo.io"<br/>        checkAudience := token.Claims.(jwt.MapClaims).VerifyAudience(aud, false)<br/>        if !checkAudience {<br/>          return nil, fmt.Errorf(("invalid aud"))<br/>        }<br/>        // verify iss claim<br/>        iss := "jwtgo.io"<br/>        checkIss := token.Claims.(jwt.MapClaims).VerifyIssuer(iss, false)<br/>        if !checkIss {<br/>          return nil, fmt.Errorf(("invalid iss"))<br/>        }</span><span id="b0ee" class="na jz iq mc b gy nf nc l nd ne">        return MySigningKey, nil<br/>      })<br/>      if err != nil {<br/>        fmt.Fprintf(w, err.Error())<br/>      }</span><span id="04ec" class="na jz iq mc b gy nf nc l nd ne">      if token.Valid {<br/>        endpoint(w, r)<br/>      }</span><span id="b928" class="na jz iq mc b gy nf nc l nd ne">    } else {<br/>      fmt.Fprintf(w, "No Authorization Token provided")<br/>    }<br/>  })<br/>}<br/>func handleRequests() {<br/>  http.Handle("/", isAuthorized(homePage))<br/>  log.Fatal(http.ListenAndServe(":9001", nil))<br/>}<br/>func main() {<br/>  fmt.Println("server")<br/>  handleRequests()<br/>}</span></pre><h1 id="601a" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">启动微服务</h1><p id="c742" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我们需要通过执行以下命令来启动中间件和微服务服务器:</p><pre class="ms mt mu mv gt mw mc mx my aw mz bi"><span id="228a" class="na jz iq mc b gy nb nc l nd ne">go run main.go</span></pre><p id="2af3" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">现在我们可以用curl测试端点。首先，尝试没有任何JWT:</p><pre class="ms mt mu mv gt mw mc mx my aw mz bi"><span id="74ba" class="na jz iq mc b gy nb nc l nd ne">curl <a class="ae mm" href="http://localhost:9001" rel="noopener ugc nofollow" target="_blank">http://localhost:9001</a></span></pre><p id="c998" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">您将收到一条错误消息:</p><pre class="ms mt mu mv gt mw mc mx my aw mz bi"><span id="2e9a" class="na jz iq mc b gy nb nc l nd ne">No Authorization Token provided</span></pre><p id="2964" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">接下来，生成一个令牌:</p><pre class="ms mt mu mv gt mw mc mx my aw mz bi"><span id="b3d7" class="na jz iq mc b gy nb nc l nd ne">curl <a class="ae mm" href="http://localhost:8080" rel="noopener ugc nofollow" target="_blank">http://localhost:8080</a></span></pre><p id="bd11" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">您会看到类似这样的内容:</p><pre class="ms mt mu mv gt mw mc mx my aw mz bi"><span id="0b0b" class="na jz iq mc b gy nb nc l nd ne">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOiJiaWxsaW5nLmp3dGdvLmlvIiwiYXV0aG9yaXplZCI6dHJ1ZSwiY2xpZW50IjoiS3Jpc3NhbmF3YXQiLCJleHAiOjE2MTM1MDk1MDcsImlzcyI6Imp3dGdvLmlvIn0.t7qdqrpLk3nBOZFLBL_UOdciZ_rWei0rJg3tgyJ7cTw</span></pre><p id="873e" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">现在我们可以构造curl命令，如下所示:</p><pre class="ms mt mu mv gt mw mc mx my aw mz bi"><span id="0d24" class="na jz iq mc b gy nb nc l nd ne">curl http://localhost:9001 --header 'Token: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOiJiaWxsaW5nLmp3dGdvLmlvIiwiYXV0aG9yaXplZCI6dHJ1ZSwiY2xpZW50IjoiS3Jpc3NhbmF3YXQiLCJleHAiOjE2MTM1MDk1MDcsImlzcyI6Imp3dGdvLmlvIn0.t7qdqrpLk3nBOZFLBL_UOdciZ_rWei0rJg3tgyJ7cTw'</span></pre><p id="efb6" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">如果您在创建令牌后的一分钟内执行此请求，您将获得以下奖励:</p><pre class="ms mt mu mv gt mw mc mx my aw mz bi"><span id="c13f" class="na jz iq mc b gy nb nc l nd ne">Super Secret Information</span></pre><p id="730d" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">如果时间太长，您会看到令牌过期警告。也没有超级机密信息。</p><h1 id="1733" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">结论</h1><p id="0d73" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">这篇文章展示了戈兰语中JWT的产生。它使用相同的令牌访问另一台服务器上运行的golang微服务。令牌生成使用了带有HS256签名方法的<code class="fe lz ma mb mc b">go-jwt</code>模块。请求终结点后，生成的令牌被返回给客户端。</p><p id="812b" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">然后，对于微服务服务器，中间件逻辑验证令牌。成功验证后，请求被发送到微服务端点。</p><p id="6a68" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">以这种方式使用令牌来保护微服务被广泛使用，因为它是一种安全且简单的机制。</p><h1 id="c1b8" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">更进一步</h1><p id="d4e2" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">所有代码都可以在<a class="ae mm" href="https://github.com/FusionAuth/fusionauth-example-go-jwt-microservices" rel="noopener ugc nofollow" target="_blank"> Github </a>上获得。如果您想尝试jwt和您在这里构建的golang微服务，您可以:</p><ul class=""><li id="ea24" class="md me iq ky b kz lu ld lv lh nh ll ni lp nj lt mi mj mk ml bi translated"><a class="ae mm" href="https://fusionauth.io/docs/v1/tech/5-minute-setup-guide/" rel="noopener ugc nofollow" target="_blank">在5分钟内设置fusion auth</a>并让它在用户登录时生成JWTs。</li><li id="e935" class="md me iq ky b kz mn ld mo lh mp ll mq lp mr lt mi mj mk ml bi translated">了解如何通过OAuth 保护golang应用程序。</li><li id="0b53" class="md me iq ky b kz mn ld mo lh mp ll mq lp mr lt mi mj mk ml bi translated">修改中间件和curl脚本，使用更标准的<code class="fe lz ma mb mc b">Authorization</code>头和<code class="fe lz ma mb mc b">Bearer</code>令牌前缀。</li><li id="b780" class="md me iq ky b kz mn ld mo lh mp ll mq lp mr lt mi mj mk ml bi translated">使用非对称签名算法(如RSA)来避免在两个程序之间共享秘密。</li><li id="b4e5" class="md me iq ky b kz mn ld mo lh mp ll mq lp mr lt mi mj mk ml bi translated">构建多个golang微服务，并通过JWT<code class="fe lz ma mb mc b">roles</code>声明的价值来控制服务访问。</li></ul><p id="5510" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated">编码快乐！</p></div><div class="ab cl nk nl hu nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ij ik il im in"><p id="7ac7" class="pw-post-body-paragraph kw kx iq ky b kz lu lb lc ld lv lf lg lh lw lj lk ll lx ln lo lp ly lr ls lt ij bi translated"><em class="ng">最初发布于</em><a class="ae mm" href="https://fusionauth.io/blog/2021/02/18/securing-golang-microservice/" rel="noopener ugc nofollow" target="_blank"><em class="ng">https://fusion auth . io</em></a><em class="ng">。</em></p></div></div>    
</body>
</html>