<html>
<head>
<title>Modern data storage on Android: Meet Jetpack DataStore — Part 2/2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android上的现代数据存储:了解Jetpack数据存储—第2部分</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/modern-data-storage-on-android-meet-jetpack-datastore-part-2-2-def77b1434bd?source=collection_archive---------12-----------------------#2021-12-14">https://levelup.gitconnected.com/modern-data-storage-on-android-meet-jetpack-datastore-part-2-2-def77b1434bd?source=collection_archive---------12-----------------------#2021-12-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="71b5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">了解Proto Datastores，面向Android的类型安全和异步数据存储解决方案。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/5dea252bd581dadb8ecb73e49cb6f968.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A_NxMWdzK9c8_WlIXabxJg.png"/></div></div></figure><p id="793d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个故事中，我将分享如何使用proto DataStore，如果你不知道什么是Jetpack DataStore或想学习如何使用Preferences DataStore，请查看我以前的故事。</p><div class="kx ky gp gr kz la"><a rel="noopener  ugc nofollow" target="_blank" href="/modern-data-storage-on-android-meet-jetpack-datastore-part-1-2-9f314c994fc8"><div class="lb ab fo"><div class="lc ab ld cl cj le"><h2 class="bd ir gy z fp lf fr fs lg fu fw ip bi translated">Android上的现代数据存储:了解Jetpack数据存储—第1/2部分</h2><div class="lh l"><h3 class="bd b gy z fp lf fr fs lg fu fw dk translated">谷歌最近发布了稳定版的Android新数据存储解决方案:数据存储。</h3></div><div class="li l"><p class="bd b dl z fp lf fr fs lg fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="lj l"><div class="lk l ll lm ln lj lo kv la"/></div></div></a></div><h1 id="4104" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">什么是原型数据存储？</h1><p id="14e6" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">Proto DataStores是Jetpack DataStore中的一个存储解决方案，与Preference Datastore相比，它的主要区别在于它是类型安全的，使用起来更方便，它需要一些额外的步骤来实现，但一旦完成，它就很容易维护。我真的推荐对更大的应用程序使用这个解决方案，因为它提供了更好的关注点分离。</p><h1 id="b505" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">履行</h1><p id="ce55" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">为了实现原型数据存储，我们将创建一个简单的设置数据存储，用户可以在其中选择应用程序主题(亮、暗或跟随系统主题)，并管理通知(尽管我们不会实现通知)。</p><h2 id="a38a" class="ms lq iq bd lr mt mu dn lv mv mw dp lz jy mx my md kc mz na mh kg nb nc ml nd bi translated">步骤1 —设置项目</h2><p id="a60b" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">让我们首先为我们的设置应用程序实现一个UI:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="4ace" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有了activity_main.xml，我们的应用程序应该如下所示:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/141b28b8935c9fb3d98a0dc057019a7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:814/format:webp/1*PP0C_dsLlOE94ulVbfXoEw.png"/></div></figure><h2 id="925b" class="ms lq iq bd lr mt mu dn lv mv mw dp lz jy mx my md kc mz na mh kg nb nc ml nd bi translated">步骤2——创建我们的原型数据文件</h2><p id="1aa9" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">proto和preferences数据存储之间的一个关键区别是，在proto中，我们为数据定义了一个方案，因此我们需要创建一个包含“消息”的. proto文件，这就是我们的数据和类的外观。</p><p id="fe90" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要定义一个原型文件，我们需要在Android Studio中通过选择左上角的项目视图来切换到项目视图。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nh"><img src="../Images/6b9c526158f421b910ddabef1188bf77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fqqmy5CcdWwqJJLvkhrcSA.png"/></div></div></figure><p id="c631" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后我们需要在app/src/main文件夹中创建一个名为proto的文件夹，所有的proto文件都需要在那里。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/74ecac4b2b075e36fe0813cef5a3cad1.png" data-original-src="https://miro.medium.com/v2/resize:fit:516/format:webp/1*XIk0UH4haLm1E_wllzDQXw.png"/></div></figure><p id="6404" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在proto文件夹中，创建一个user_settings.proto文件，在该文件中，我们将定义一条消息，其中包含我们希望保存到proto数据存储中的任何数据。协议缓冲区有一个非常简单的语法，你可以在这里阅读更多关于它们的内容。</p><p id="353d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们定义我们的原型文件:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ne nf l"/></div></figure><h2 id="969b" class="ms lq iq bd lr mt mu dn lv mv mw dp lz jy mx my md kc mz na mh kg nb nc ml nd bi translated">步骤3 —添加依赖关系</h2><p id="e482" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">现在我们需要向我们的项目添加依赖项，我们需要添加Google protobuf gradle插件、数据存储、javalite和一个“protobuf”块来设置protobuf插件应该如何生成我们的数据类，你可以查看它如何工作的更多细节<a class="ae nj" href="https://github.com/google/protobuf-gradle-plugin#customizing-protobuf-compilation" rel="noopener ugc nofollow" target="_blank">点击这里</a>。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="12d1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在构建项目，protobuf插件将为我们生成UserSettings类。</p><h2 id="b08d" class="ms lq iq bd lr mt mu dn lv mv mw dp lz jy mx my md kc mz na mh kg nb nc ml nd bi translated">步骤4 —设置我们的序列化程序</h2><p id="c2fe" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">我们有了自己的类，现在我们需要为它创建一个序列化程序，因此，创建一个目录datastores/settings，并在其中创建一个UserSettingsSerializer.kt:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="2b1e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不要太担心这个serializer类，它几乎是样板文件，每次你实现一个新的serializer时，你可以复制粘贴上面的代码并用你的类替换“UserSettings”。</p><h2 id="5bb0" class="ms lq iq bd lr mt mu dn lv mv mw dp lz jy mx my md kc mz na mh kg nb nc ml nd bi translated">步骤5 —设置我们的设置管理器</h2><p id="5acc" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">现在，我们开始实际实现我们的数据存储，管理器是整个应用程序中唯一可以直接访问数据存储的位置，与SharedPreferences相比，这似乎是一个限制，需要更多的工作，但实际上可以节省很多精力。查找与SharedPreferences相关的错误有点痛苦，可能会出错的地方很多，可能会键入错误的键，可能会编写错误的值类型，可能会用错误的上下文打开它，所有这些都可能发生在应用程序中的任何地方，而使用这个管理器，所有东西都打包到一个类中，如果出错，只需查看一个位置。</p><p id="4da5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们实现我们的管理器类:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="91cc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面代码的一些注释:</p><ul class=""><li id="c510" class="nk nl iq jp b jq jr ju jv jy nm kc nn kg no kk np nq nr ns bi translated">datastore.data是一个流<usersettings>，这意味着对保存到datastore中的UserSettings的每次更改都会触发流中的一个事件，我们可以通过调用。在流动中收集。</usersettings></li><li id="6911" class="nk nl iq jp b jq nt ju nu jy nv kc nw kg nx kk np nq nr ns bi translated">流是可以映射的，所以假设我只想监听UserSettings类中的一个变量，为此，您需要做的就是用。map函数，然后收集它，只有当这个变量发生变化时，才会触发事件。</li><li id="cccc" class="nk nl iq jp b jq nt ju nu jy nv kc nw kg nx kk np nq nr ns bi translated">数据存储连接到上下文，因此如果您想要将单个数据存储连接到多个活动，请从应用程序上下文中调用它(用<code class="fe ny nz oa ob b">private val datastore = context.applicationContext.settingsDataStore</code>替换第11行)。</li><li id="1554" class="nk nl iq jp b jq nt ju nu jy nv kc nw kg nx kk np nq nr ns bi translated">我为数据创建了setter(<code class="fe ny nz oa ob b">setTheme</code>和<code class="fe ny nz oa ob b">setNotifications</code>)，这样我可以更好地控制它们的更新方式(以防将来需要更改)，但是如果需要更多的灵活性，您可以从数据存储中公开更新方法。</li></ul><h2 id="4aef" class="ms lq iq bd lr mt mu dn lv mv mw dp lz jy mx my md kc mz na mh kg nb nc ml nd bi translated">步骤6 —添加功能</h2><p id="4d78" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">现在让我们在活动中使用数据存储，首先让我们在MainActivity中创建一个方法来实际更新应用程序的主题模式:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="2a9e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，我们需要使用<code class="fe ny nz oa ob b">collect</code>监听数据存储更新，并更新UI和主题以反映最新的数据:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="eae8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以读取数据，现在唯一缺少的是实际写入数据:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="d0ba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就这样，现在您就有了一个带有原型数据存储的全功能设置屏幕！除了设置radioGroup和switch侦听器中的值之外，您不需要做任何其他事情，因为一旦数据在数据存储中得到更新，就会调用collect回调。</p><p id="dc53" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这使我们能够做的一件很酷的事情是将代码解耦，在这个示例中，我们对同一活动做了所有事情，但数据存储的真正价值是保持应用程序的不同部分与数据连接和同步，而这些部分不需要相互了解，您可以在主活动中收集主题模式设置，同时在不同的片段中设置这些值，收集回调仍然会被触发！</p><p id="65a6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">检查下面完整的MainActivity代码:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ne nf l"/></div></figure><h1 id="01c6" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">结论</h1><p id="0b80" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">原型数据存储对于您的项目来说是一个非常好的可能性，它可能不能解决您所有的问题，并且仍然相对较新，所以像加密这样的一些特性还不可用，但它肯定是有前途的！它迫使您和您的团队在处理存储时保持良好的实践，同时为我们提供了一个出色的异步类型安全API。</p><p id="653c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">检查完整项目的GitHub repo:</p><div class="kx ky gp gr kz la"><a href="https://github.com/GB0307/android_datastore_settings_app/tree/main" rel="noopener  ugc nofollow" target="_blank"><div class="lb ab fo"><div class="lc ab ld cl cj le"><h2 class="bd ir gy z fp lf fr fs lg fu fw ip bi translated">GitHub-GB 0307/Android _ datastore _ settings _ app</h2><div class="lh l"><h3 class="bd b gy z fp lf fr fs lg fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="li l"><p class="bd b dl z fp lf fr fs lg fu fw dk translated">github.com</p></div></div><div class="lj l"><div class="oc l ll lm ln lj lo kv la"/></div></div></a></div></div></div>    
</body>
</html>