<html>
<head>
<title>Using UI-Router with React for better app routing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用UI-Router和React实现更好的应用程序路由</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/using-ui-router-with-react-for-better-app-routing-f801e4d6a404?source=collection_archive---------4-----------------------#2019-01-16">https://levelup.gitconnected.com/using-ui-router-with-react-for-better-app-routing-f801e4d6a404?source=collection_archive---------4-----------------------#2019-01-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="af1d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="kl">(这是我几个月前为早期版本的UI-Router写的帖子的修订版。概念是相同的；刚刚更新，以反映一些小的变化，在如何UI-路由器应实施。)</em> </strong></p><p id="0f77" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">React对其核心产品非常挑剔。这导致了一个更精简的库，并使它非常可扩展，允许开发人员选择和安装最适合他们项目的包。</p><p id="205c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">路由是构建单页web应用程序的主要部分。React没有现成的这种功能。框架没有内置的路由库，你必须安装自己的解决方案。这是React给开发人员足够多的自缚手脚的地方。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/fafdcc27de42ef68104400a15ae0ebda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JHMUJaqAAs9k7l0nn8gYWw.jpeg"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">照片由<a class="ae lc" href="https://unsplash.com/photos/XhzGiOXw8yE?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">杰米街</a>上的<a class="ae lc" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></figcaption></figure><p id="4829" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">向React应用程序添加路由的首选解决方案——可怕的(在我看来)<a class="ae lc" href="https://reacttraining.com/react-router/" rel="noopener ugc nofollow" target="_blank"> React Router </a>包。我知道我并不孤单。我经常和其他开发者讨论使用它有多令人沮丧。</p><p id="1c3b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将路由实现为组件是一件很麻烦的事情，而且看起来也不太美观。如果你有一个有很多路线的应用程序，这是一个很难管理的问题。我开发的应用程序有超过100条独特的路线。如果我们决定重建，React路由器并不是一个实用的解决方案。</p><p id="7c7a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我会选择的解决方案是<a class="ae lc" href="https://ui-router.github.io/react/" rel="noopener ugc nofollow" target="_blank"> UI路由器</a>。在我从事AngularJS项目的时候，我已经接触了很多UI-Router并取得了很大的成功。它是框架独立的。然而，它有一个专用的React包，所以将它添加到项目中是相当容易的。这是我在React项目中使用它的方式。</p><p id="c413" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae lc" href="https://github.com/carmichaelize/react-ui-router-demo" rel="noopener ugc nofollow" target="_blank">看看我放在Github上的这个演示，它是一个工作示例</a>。</p><h1 id="eb73" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">路由器设置</h1><p id="fae5" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated"><code class="fe mg mh mi mj b">UIView</code>组件允许将路线内容加载到应用程序包装组件的一个区域中。像应用程序的页眉和页脚这样的顶级组件可以添加到这里，这样它们就可以显示在每个页面上。</p><pre class="kn ko kp kq gt mk mj ml mm aw mn bi"><span id="d430" class="mo le iq mj b gy mp mq l mr ms">// App.jsx<br/>import React, { Component } from 'react';<br/>import { UIRouter, UIView } from '<a class="ae lc" href="http://twitter.com/uirouter/react" rel="noopener ugc nofollow" target="_blank">@uirouter/react</a>';<br/>import { router } from './router';</span><span id="8cad" class="mo le iq mj b gy mt mq l mr ms">class App extends Component {</span><span id="2218" class="mo le iq mj b gy mt mq l mr ms">render() {<br/>        return (<br/>            &lt;UIRouter router={router}&gt;<br/>                &lt;div&gt;<br/>                    &lt;UIView/&gt;<br/>                &lt;/div&gt;<br/>            &lt;/UIRouter&gt;<br/>        );<br/>    }</span><span id="0b43" class="mo le iq mj b gy mt mq l mr ms">}</span><span id="3677" class="mo le iq mj b gy mt mq l mr ms">export default App;</span></pre><p id="3230" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">路由器设置文件是配置和启动路由器实例的地方。路由器对象需要被传递到顶层<code class="fe mg mh mi mj b">UIRouter</code>(如上所示)。</p><pre class="kn ko kp kq gt mk mj ml mm aw mn bi"><span id="27fb" class="mo le iq mj b gy mp mq l mr ms">// router.jsx<br/>import { UIRouterReact, servicesPlugin, hashLocationPlugin } from '<a class="ae lc" href="http://twitter.com/uirouter/react" rel="noopener ugc nofollow" target="_blank">@uirouter/react</a>';</span><span id="5583" class="mo le iq mj b gy mt mq l mr ms">// Create router instance + setup<br/>export const router = new UIRouterReact();<br/>router.plugin(servicesPlugin);<br/>router.plugin(hashLocationPlugin);</span></pre><p id="8048" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">导出路由器对象对于使其在其他项目文件中可用非常重要。在此对象上可以访问路由器的大多数服务。</p><h1 id="7403" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">应用程序结构</h1><p id="b9ca" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">React本质上是模块化的，这也是将应用程序组织成路线的好方法。较小的独立模块有助于对相关文件进行分组和组织。模块通常包括一个组件文件以及其他资产文件(CSS、测试等)。).路由器的目的是将它们连接在一起。</p><p id="be7c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">模块使代码库更容易导航。这对可能有许多路线的大型应用程序来说是一个真正的好处。确保东西容易(且明显)找到。</p><p id="b5fb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">UI路由器是基于状态的，导航由状态机处理。这与React-Router不同，React-Router是由匹配的浏览器URL驱动的。UI-Router确实允许你在不声明URL的情况下构建应用。但是，这可能会造成混乱，并阻止您实现url深度链接。</p><p id="3e4e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">app里的每一条路线都可以用一个状态来形容。UI-路由器嵌入模块化应用程序结构。我在每个模块目录中包含了一个状态定义文件，以便于在项目中找到它。</p><h1 id="81e5" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">状态定义和注册</h1><p id="4b5e" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">状态定义文件概述了状态的关键属性和行为。这里声明了状态名、url和组件(要加载)。一个简单的状态定义文件如下所示。</p><pre class="kn ko kp kq gt mk mj ml mm aw mn bi"><span id="e6d9" class="mo le iq mj b gy mp mq l mr ms">import ContactsPage from ‘./contacts’;</span><span id="5d99" class="mo le iq mj b gy mt mq l mr ms">export default {<br/>    name: 'contacts',<br/>    url: '/contacts',<br/>    component: ContactsPage,<br/>}</span></pre><p id="3511" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要让应用程序找到州，必须首先使用州注册服务进行注册。路由器设置文件是放置它的理想位置。</p><pre class="kn ko kp kq gt mk mj ml mm aw mn bi"><span id="4437" class="mo le iq mj b gy mp mq l mr ms">// router.jsx<br/>import { UIRouterReact, servicesPlugin, hashLocationPlugin } from '<a class="ae lc" href="http://twitter.com/uirouter/react" rel="noopener ugc nofollow" target="_blank">@uirouter/react</a>';</span><span id="52ef" class="mo le iq mj b gy mt mq l mr ms">// Import states<br/>import contact from './modules/contact/state';<br/>import contacts from './modules/contacts/state';</span><span id="bef7" class="mo le iq mj b gy mt mq l mr ms">// Create router instance + setup<br/>export const router = new UIRouterReact();<br/>router.plugin(servicesPlugin);<br/>router.plugin(hashLocationPlugin);</span><span id="7cf3" class="mo le iq mj b gy mt mq l mr ms">// Register each state<br/>const states = [<br/>    contact,<br/>    contacts<br/>];<br/>states.forEach(state =&gt; router.stateRegistry.register(state));</span></pre><p id="1d9b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我喜欢这种方法，因为它使代码库易于导航。更高层次的设置集中在项目中。状态(特定)逻辑仍然是单个模块的一部分。</p><h1 id="8c3a" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">状态参数</h1><p id="53df" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">状态参数可以被声明为<em class="kl"> url </em>值的一部分。如果页面被重新加载或共享，这允许参数被保存在url中。</p><p id="507a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">状态参数在url中用冒号作为前缀或者用花括号括起来。下面的例子使用冒号语法来声明一个<em class="kl"> contactId </em>参数。</p><pre class="kn ko kp kq gt mk mj ml mm aw mn bi"><span id="098d" class="mo le iq mj b gy mp mq l mr ms">export default {<br/>    name: 'contact',<br/>    url: '/contacts/:contactId'<br/>}</span></pre><p id="c64a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">查询字符串也可以用来设置多个不太重要的参数。这种方法的优点是参数是可选的。这意味着无需声明每个参数就可以加载状态。这对于处理分页之类的事情很有用，并且有助于保持url的可读性。</p><pre class="kn ko kp kq gt mk mj ml mm aw mn bi"><span id="14c8" class="mo le iq mj b gy mp mq l mr ms">export default {<br/>    name: 'contacts',<br/>    url: '/contacts?{page}&amp;{perPage}'<br/>}</span></pre><p id="120d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">状态组件可以从路由器上的全局对象中访问作为键/值对的参数。这些键将映射在<em class="kl"> url </em>值中声明的参数。</p><h1 id="f5f8" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">过渡</h1><p id="3cb6" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">触发转变；使用的是州名，而不是URL。改变状态最简单的方法是使用<code class="fe mg mh mi mj b">UISref</code>组件，这是一个美化了的锚标记。这包装了一个html元素(或文本节点),并将其转换成一个UI-Router链接。</p><pre class="kn ko kp kq gt mk mj ml mm aw mn bi"><span id="bc51" class="mo le iq mj b gy mp mq l mr ms">&lt;UISref to={‘contact’} params={{contactId: 1}}&gt; <br/>    &lt;a&gt;Joe Bloggs&lt;/a&gt;<br/>&lt;/UISref&gt;</span></pre><p id="72c0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这也可以使用状态服务以编程方式处理。<em class="kl"> go </em>方法实现了与函数调用相同的功能。它需要两个参数；一个<code class="fe mg mh mi mj b">name</code>和一个<code class="fe mg mh mi mj b">params</code>物体。这对于从回调或另一个函数触发转换很有用。</p><pre class="kn ko kp kq gt mk mj ml mm aw mn bi"><span id="fc60" class="mo le iq mj b gy mp mq l mr ms">router.stateService.go('contact', {contactId: 1});</span></pre><p id="4706" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">关于当前状态的信息也可以从状态服务中访问。这包括州名等一般信息。当更新没有转换的状态参数时。我喜欢在使用go方法时动态设置name参数。这使得一个组件在被映射到多个状态时更加灵活。</p><pre class="kn ko kp kq gt mk mj ml mm aw mn bi"><span id="68a9" class="mo le iq mj b gy mp mq l mr ms">const stateName = router.stateService.$current.name;<br/>router.stateService.go(stateName, {page: 2});</span></pre><h1 id="d880" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">过渡挂钩</h1><p id="2055" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">UI-Router使得挂钩到一个转换的不同点变得非常容易。过渡服务有许多方法可以实现这一点。我常用的三个如下所示。</p><pre class="kn ko kp kq gt mk mj ml mm aw mn bi"><span id="637e" class="mo le iq mj b gy mp mq l mr ms">router.transitionService.onBefore(true, function(trans) {<br/>    // Start transition<br/>});</span><span id="f7a9" class="mo le iq mj b gy mt mq l mr ms">router.transitionService.onSuccess(true, function(trans) {<br/>   // End transition<br/>});</span><span id="ee38" class="mo le iq mj b gy mt mq l mr ms">router.transitionService.onError(true, function(err) {<br/>    // Transition errored<br/>});</span></pre><p id="df29" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这些方法相当强大。它们允许在转换期间的特定点运行回调。对转换的引用也被传递给回调，这意味着如果需要的话，可以截取它。这对于处理身份验证和锁定状态非常有用。</p><p id="a08b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我喜欢在转换开始和结束之间显示一个加载指示器。这给用户一些页面正在加载的视觉反馈。由于它们会在每次转换时触发，因此<code class="fe mg mh mi mj b">before</code>和<code class="fe mg mh mi mj b">success</code>挂钩非常适合这种情况。一定要整理好<code class="fe mg mh mi mj b">error</code>钩子里的动作。如果转换失败，错误应该被捕获、处理并指示给用户。</p><h1 id="9026" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">决心</h1><p id="4e39" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">解析是在转换到某个状态之前获取数据的一种很好的方式。在安装状态组件之前，可以加载关键数据并使其可用。下面的示例状态解析了一些静态JSON数据。</p><pre class="kn ko kp kq gt mk mj ml mm aw mn bi"><span id="7474" class="mo le iq mj b gy mp mq l mr ms">import ContactsPage from ‘./contacts’;</span><span id="77a7" class="mo le iq mj b gy mt mq l mr ms">export default {<br/>    name: 'contacts',<br/>    url: '/contacts',<br/>    component: ContactsPage,<br/>    resolve: [<br/>        {<br/>            token: 'contacts,<br/>            resolveFn: () =&gt; {<br/>                return [<br/>                    {   <br/>                        name: 'Joe Bloggs',<br/>                        age: 21,<br/>                        country: 'Scotland'<br/>                    },<br/>                    {   <br/>                        name: 'Jane Doe',<br/>                        age: 31,<br/>                        country: 'England'<br/>                    },<br/>                    {<br/>                        name: 'John Smith',<br/>                        age: 41,<br/>                        country: 'Wales'<br/>                    }<br/>                ];<br/>            }<br/>        }    <br/>    ]<br/>}</span></pre><p id="6e7b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mg mh mi mj b">resolves</code>属性是一个由单个resolve对象组成的数组。<code class="fe mg mh mi mj b">token</code>属性是解析的唯一键。<code class="fe mg mh mi mj b">resolveFn</code>属性必须是返回数据的函数。</p><p id="4c10" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面的例子使用了静态数据，并将立即可用。<code class="fe mg mh mi mj b">resolveFn</code>功能也支持返还承诺。这是一个强大的工具，用于处理对API的延迟http数据请求。UI-Router将在完成转换之前等待，直到承诺完成。</p><p id="2627" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果承诺失败，转换也将失败，错误挂钩将被触发。一定要设置一个<code class="fe mg mh mi mj b">error</code> <em class="kl"> </em>钩子(见上图)给用户反馈为什么过渡失败。</p><p id="9df9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当心过度使用解析。它会减慢完成过渡的时间。在挂载状态组件之前，选择需要的关键数据。延迟加载较少的数据。</p><p id="1e23" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是一个使用基于承诺的数据服务和url中声明的参数的示例。</p><pre class="kn ko kp kq gt mk mj ml mm aw mn bi"><span id="5628" class="mo le iq mj b gy mp mq l mr ms">import ContactPage from './contact';<br/>import contactsService from './contacts-service'</span><span id="4739" class="mo le iq mj b gy mt mq l mr ms">export default {<br/>    name: 'contact',<br/>    url: '/contacts/:contactId',<br/>    component: ContactPage,<br/>    resolve: [<br/>        {<br/>            token: 'contact',<br/>            deps: ['$transition$'],<br/>            resolveFn: (trans) =&gt; {<br/>                // Get contactId param<br/>                const contactId = trans.params().contactId;<br/>                // Fetch data<br/>                return new contactsService.get(contactId);<br/>            }<br/>        }<br/>    ]<br/>};</span></pre><p id="104e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">转换必须作为依赖项(<code class="fe mg mh mi mj b">deps</code>)包含在内，以访问<code class="fe mg mh mi mj b">resolveFn</code> <em class="kl">中的任何状态参数。</em>这可作为函数<em class="kl">的参数。</em>可通过props在状态组件中访问解析的数据(见下文)。</p><pre class="kn ko kp kq gt mk mj ml mm aw mn bi"><span id="00c5" class="mo le iq mj b gy mp mq l mr ms">import React, { Component } from 'react';</span><span id="a9f8" class="mo le iq mj b gy mt mq l mr ms">export class ContactPage extends Component {</span><span id="50bb" class="mo le iq mj b gy mt mq l mr ms">render() {<br/>        return (<br/>            &lt;h1&gt;<br/>                {this.props.contact.name}<br/>            &lt;/h1&gt;<br/>        );<br/>    }</span><span id="61ba" class="mo le iq mj b gy mt mq l mr ms">}</span><span id="8bf8" class="mo le iq mj b gy mt mq l mr ms">export default ContactPage;</span></pre><p id="02d7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我喜欢这种方法，因为它将数据加载逻辑移出了组件。通过将状态组件从数据服务中分离出来，这使得状态组件更易于测试。允许数据很容易地通过组件道具被模仿。</p><p id="b679" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">(安装组件后，注意状态参数或解析数据的变化。有时需要使用<code class="fe mg mh mi mj b">componentWillReceiveProps</code>方法来处理变化的状态参数。这通常发生在参数设置为on状态时)。</p><h1 id="2ef6" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">概括起来</h1><p id="c164" class="pw-post-body-paragraph jn jo iq jp b jq mb js jt ju mc jw jx jy md ka kb kc me ke kf kg mf ki kj kk ij bi translated">UI-Router有一个专用的React包，因此入门相当容易。除此之外，我发现它是用React构建web应用程序的理想路由器。</p><ul class=""><li id="5539" class="mu mv iq jp b jq jr ju jv jy mw kc mx kg my kk mz na nb nc bi translated">它非常适合模块化的应用程序结构。</li><li id="8dc3" class="mu mv iq jp b jq nd ju ne jy nf kc ng kg nh kk mz na nb nc bi translated">较高级别的路由配置与各个状态分开处理。</li><li id="b17a" class="mu mv iq jp b jq nd ju ne jy nf kc ng kg nh kk mz na nb nc bi translated">可以声明路由参数，允许动态页面和url深度链接。</li><li id="ff6b" class="mu mv iq jp b jq nd ju ne jy nf kc ng kg nh kk mz na nb nc bi translated">可以使用转换挂钩在转换的每个阶段触发自定义回调。</li><li id="a023" class="mu mv iq jp b jq nd ju ne jy nf kc ng kg nh kk mz na nb nc bi translated">解析允许在装载状态组件之前加载关键数据。</li></ul><p id="7601" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">检查我在Github上的工作演示。如果您对React Router或一般的路由感到沮丧，请尝试一下UI-Router。这是一个强大的工具包，新手也很容易上手。</p><p id="7907" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">(如果你正在寻找一个关于React-Router和UI-Router之间差异的好的概述，Marco Botto的这篇文章非常值得一读——<a class="ae lc" href="http://marcobotto.com/overview-of-ui-router-react-and-comparison-with-react-router/" rel="noopener ugc nofollow" target="_blank">http://Marco Botto . com/overview-of-UI-Router-React-and-comparison-with-React-Router/</a>。)</p></div><div class="ab cl ni nj hu nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="ij ik il im in"><figure class="kn ko kp kq gt kr gh gi paragraph-image"><a href="https://levelup.gitconnected.com"><div class="gh gi np"><img src="../Images/ff5028ba5a0041d2d76d2a155f00f05e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JaoZbi7tTKJ5vL7i2OAYMQ.png"/></div></a></figure><div class="nq nr gp gr ns nt"><a href="https://gitconnected.com/learn/react" rel="noopener  ugc nofollow" target="_blank"><div class="nu ab fo"><div class="nv ab nw cl cj nx"><h2 class="bd ir gy z fp ny fr fs nz fu fw ip bi translated">学习React -最佳React教程(2019) | gitconnected</h2><div class="oa l"><h3 class="bd b gy z fp ny fr fs nz fu fw dk translated">前48名React教程。课程由开发人员提交并投票，使您能够找到最佳反应…</h3></div><div class="ob l"><p class="bd b dl z fp ny fr fs nz fu fw dk translated">gitconnected.com</p></div></div><div class="oc l"><div class="od l oe of og oc oh kw nt"/></div></div></a></div></div></div>    
</body>
</html>