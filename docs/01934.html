<html>
<head>
<title>Overload Functions in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的重载函数</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/overload-functions-in-python-d045375cff04?source=collection_archive---------5-----------------------#2020-02-07">https://levelup.gitconnected.com/overload-functions-in-python-d045375cff04?source=collection_archive---------5-----------------------#2020-02-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="090a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">函数重载是拥有多个同名但签名/实现不同的函数的能力。当调用重载函数<code class="fe ko kp kq kr b">fn</code>时，运行时首先评估传递给函数调用的自变量/参数，并据此判断调用相应的实现。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="kx ky l"/></div></figure><p id="f218" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在上面的例子中(用C++写的)，函数<code class="fe ko kp kq kr b">area</code>重载了两个实现；一个接受两个参数(都是整数)来表示矩形的长度和宽度，并返回面积；而另一个函数接受圆的整数半径。当我们像<code class="fe ko kp kq kr b">area(7)</code>一样调用函数<code class="fe ko kp kq kr b">area</code>时，它调用第二个函数，而<code class="fe ko kp kq kr b">area(3, 4)</code>调用第一个函数。</p><h1 id="d033" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">为什么Python中没有函数重载？</h1><p id="59f9" class="pw-post-body-paragraph jq jr it js b jt lx jv jw jx ly jz ka kb lz kd ke kf ma kh ki kj mb kl km kn im bi translated">Python不支持函数重载。当我们用相同的名称定义多个函数时，后一个函数总是覆盖前一个函数，因此，在名称空间中，每个函数名总是有一个条目。我们通过调用函数<code class="fe ko kp kq kr b">locals()</code>和<code class="fe ko kp kq kr b">globals()</code>来查看Python名称空间中存在的内容，这两个函数分别返回本地和全局名称空间。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="kx ky l"/></div></figure><p id="0344" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在定义了一个函数之后调用函数<code class="fe ko kp kq kr b">locals()</code>，我们看到它返回了一个在本地名称空间中定义的所有变量的字典。字典的关键字是变量的名称，值是该变量的引用/值。当运行时遇到另一个同名函数时，它会更新本地命名空间中的条目，从而消除两个函数共存的可能性。因此python不支持函数重载。这是在创建语言时做出的设计决定，但这并不妨碍我们实现它，所以让我们重载一些函数。</p><h1 id="b76d" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">在Python中实现函数重载</h1><p id="d262" class="pw-post-body-paragraph jq jr it js b jt lx jv jw jx ly jz ka kb lz kd ke kf ma kh ki kj mb kl km kn im bi translated">我们知道Python如何管理名称空间，如果我们想要实现函数重载，我们需要</p><ul class=""><li id="ac12" class="mc md it js b jt ju jx jy kb me kf mf kj mg kn mh mi mj mk bi translated">在维护的虚拟名称空间中管理函数定义</li><li id="d8ba" class="mc md it js b jt ml jx mm kb mn kf mo kj mp kn mh mi mj mk bi translated">根据传递给它的参数，找到调用适当函数的方法</li></ul><p id="dacf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了简单起见，我们将实现函数重载，其中同名的函数通过它接受的参数数量来区分。</p><h1 id="1e68" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">包装函数</h1><p id="c12c" class="pw-post-body-paragraph jq jr it js b jt lx jv jw jx ly jz ka kb lz kd ke kf ma kh ki kj mb kl km kn im bi translated">我们创建了一个名为<code class="fe ko kp kq kr b">Function</code>的类，它包装了任何函数，并通过一个被覆盖的<code class="fe ko kp kq kr b">__call__</code>方法使其可调用，还公开了一个名为<code class="fe ko kp kq kr b">key</code>的方法，该方法返回一个元组，该元组使该函数在整个代码库中是唯一的。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="kx ky l"/></div></figure><p id="7eaf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在上面的代码片段中，<code class="fe ko kp kq kr b">key</code>函数返回一个元组，该元组唯一地标识代码库中的函数并保存</p><ul class=""><li id="83a4" class="mc md it js b jt ju jx jy kb me kf mf kj mg kn mh mi mj mk bi translated">函数的模块</li><li id="b921" class="mc md it js b jt ml jx mm kb mn kf mo kj mp kn mh mi mj mk bi translated">函数所属的类</li><li id="fb30" class="mc md it js b jt ml jx mm kb mn kf mo kj mp kn mh mi mj mk bi translated">函数的名称</li><li id="aef9" class="mc md it js b jt ml jx mm kb mn kf mo kj mp kn mh mi mj mk bi translated">函数接受的参数数量</li></ul><p id="0be0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">被覆盖的<code class="fe ko kp kq kr b">__call__</code>方法调用被包装的函数并返回计算出的值(现在这里没有什么特别的)。这使得实例就像函数一样可调用，并且它的行为就像包装的函数一样。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="kx ky l"/></div></figure><p id="44f2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在上面的例子中，函数<code class="fe ko kp kq kr b">area</code>被包装在<code class="fe ko kp kq kr b">Function</code>中，并在<code class="fe ko kp kq kr b">func</code>中实例化。<code class="fe ko kp kq kr b">key()</code>返回元组，第一个元素是模块名<code class="fe ko kp kq kr b">__main__</code>，第二个是类<code class="fe ko kp kq kr b">&lt;class 'function'&gt;</code>，第三个是函数名<code class="fe ko kp kq kr b">area</code>，第四个是函数<code class="fe ko kp kq kr b">area</code>接受的参数个数<code class="fe ko kp kq kr b">2</code>。</p><p id="dcb9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该示例还展示了我们如何调用实例<code class="fe ko kp kq kr b">func</code>，就像通常的<code class="fe ko kp kq kr b">area</code>函数一样，使用参数<code class="fe ko kp kq kr b">3</code>和<code class="fe ko kp kq kr b">4</code>并得到响应<code class="fe ko kp kq kr b">12</code>，这正是我们本来会调用<code class="fe ko kp kq kr b">area(3, 4)</code>得到的结果。这种行为在我们和装饰者一起玩的后期会派上用场。</p><h1 id="dc26" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">构建虚拟命名空间</h1><p id="59f3" class="pw-post-body-paragraph jq jr it js b jt lx jv jw jx ly jz ka kb lz kd ke kf ma kh ki kj mb kl km kn im bi translated">我们在这里构建的虚拟名称空间将存储我们在定义阶段收集的所有函数。因为只有一个名称空间/注册表，我们创建一个singleton类，它保存字典中的函数，它的键不仅仅是函数名，而是我们从<code class="fe ko kp kq kr b">key</code>函数中得到的元组，它包含在整个代码库中唯一标识函数的元素。通过这样做，我们将能够在注册表中保存函数，即使它们具有相同的名称(但不同的参数),从而促进函数重载。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="kx ky l"/></div></figure><p id="6380" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe ko kp kq kr b">Namespace</code>有一个方法<code class="fe ko kp kq kr b">register</code>，它将函数<code class="fe ko kp kq kr b">fn</code>作为一个参数，为它创建一个惟一的键，将它存储在字典中，并返回包装在<code class="fe ko kp kq kr b">Function</code>的一个实例中的<code class="fe ko kp kq kr b">fn</code>。这意味着来自<code class="fe ko kp kq kr b">register</code>函数的返回值也是可调用的，并且(到目前为止)它的行为与被包装的函数<code class="fe ko kp kq kr b">fn</code>完全相同。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="kx ky l"/></div></figure><h1 id="0d68" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">使用装饰者作为挂钩</h1><p id="b472" class="pw-post-body-paragraph jq jr it js b jt lx jv jw jx ly jz ka kb lz kd ke kf ma kh ki kj mb kl km kn im bi translated">既然我们已经定义了一个能够注册函数的虚拟名称空间，我们需要一个在函数定义期间被调用的钩子；这里使用Python装饰器。在Python中，装饰器包装一个函数，并允许我们在不修改其结构的情况下向现有函数添加新功能。装饰器接受包装的函数<code class="fe ko kp kq kr b">fn</code>作为参数，并返回另一个被调用的函数。该函数接受函数调用期间传递的<code class="fe ko kp kq kr b">args</code>和<code class="fe ko kp kq kr b">kwargs</code>，并返回值。</p><p id="ade5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面演示了一个计时函数执行的示例装饰器</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="kx ky l"/></div></figure><p id="4b20" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在上面的例子中，我们定义了一个名为<code class="fe ko kp kq kr b">my_decorator</code>的装饰器，它包装了函数<code class="fe ko kp kq kr b">area</code>，并在<code class="fe ko kp kq kr b">stdout</code>上打印出执行所花费的时间。</p><p id="2437" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">每次解释器遇到函数定义时，都会调用装饰函数<code class="fe ko kp kq kr b">my_decorator</code>(这样它就包装了被装饰的函数，并将这个新的包装函数存储在Python的本地或全局名称空间中),对于我们来说，这是一个理想的钩子，可以在我们的虚拟名称空间中注册函数。因此，我们创建了名为<code class="fe ko kp kq kr b">overload</code>的装饰器，它在虚拟名称空间中注册函数，并返回一个可调用的。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="kx ky l"/></div></figure><p id="2231" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe ko kp kq kr b">overload</code>装饰器返回<code class="fe ko kp kq kr b">Function</code>的一个实例，由<code class="fe ko kp kq kr b">.register()</code>命名空间的函数返回。现在，无论何时调用函数(由<code class="fe ko kp kq kr b">overload</code>修饰),它都会调用由<code class="fe ko kp kq kr b">.register()</code>函数返回的函数——一个<code class="fe ko kp kq kr b">Function</code>的实例，而<code class="fe ko kp kq kr b">__call__</code>方法会在调用过程中通过指定的<code class="fe ko kp kq kr b">args</code>和<code class="fe ko kp kq kr b">kwargs</code>来执行。现在剩下的就是在类<code class="fe ko kp kq kr b">Function</code>中实现<code class="fe ko kp kq kr b">__call__</code>方法，这样它就可以调用适当的函数，给出调用过程中传递的参数。</p><h1 id="9dc5" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">从名称空间中寻找正确的函数</h1><p id="d714" class="pw-post-body-paragraph jq jr it js b jt lx jv jw jx ly jz ka kb lz kd ke kf ma kh ki kj mb kl km kn im bi translated">除了通常的模块类和名称之外，消歧的范围是函数接受的参数数量，因此我们在虚拟命名空间中定义了一个名为<code class="fe ko kp kq kr b">get</code>的方法，该方法接受来自python命名空间的函数(将是同一名称的最后一个定义——因为我们没有改变Python命名空间的默认行为)和调用期间传递的参数(我们的消歧因子),并返回要调用的消歧函数。</p><p id="270f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个<code class="fe ko kp kq kr b">get</code>函数的作用是决定调用哪个函数的实现(如果重载的话)。获取适当函数的过程非常简单——从函数和参数使用<code class="fe ko kp kq kr b">key</code>函数创建惟一键(就像注册时一样),并查看它是否存在于函数注册表中；如果有，那么就获取针对它存储的实现。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="kx ky l"/></div></figure><p id="dc68" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe ko kp kq kr b">get</code>函数创建了<code class="fe ko kp kq kr b">Function</code>的一个实例，这样它就可以使用<code class="fe ko kp kq kr b">key</code>函数获得一个惟一的键，而不会复制逻辑。然后使用该键从函数注册表中获取适当的函数。</p><h1 id="d1c5" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">调用函数</h1><p id="4754" class="pw-post-body-paragraph jq jr it js b jt lx jv jw jx ly jz ka kb lz kd ke kf ma kh ki kj mb kl km kn im bi translated">如上所述，每次调用用<code class="fe ko kp kq kr b">overload</code>装饰器装饰的函数时，都会调用类<code class="fe ko kp kq kr b">Function</code>中的<code class="fe ko kp kq kr b">__call__</code>方法。我们使用这个函数通过名称空间的<code class="fe ko kp kq kr b">get</code>函数获取适当的函数，并调用重载函数所需的实现。<code class="fe ko kp kq kr b">__call__</code>方法实现如下</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="kx ky l"/></div></figure><p id="64ee" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该方法从虚拟名称空间中获取适当的函数，如果没有找到任何函数，它将引发一个<code class="fe ko kp kq kr b">Exception</code>，如果找到了，它将调用该函数并返回值。</p><h1 id="0036" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">作用中的函数重载</h1><p id="5eab" class="pw-post-body-paragraph jq jr it js b jt lx jv jw jx ly jz ka kb lz kd ke kf ma kh ki kj mb kl km kn im bi translated">一旦所有代码就绪，我们定义两个名为<code class="fe ko kp kq kr b">area</code>的函数:一个计算矩形的面积，另一个计算圆形的面积。这两个函数都在下面定义，并用一个<code class="fe ko kp kq kr b">overload</code>装饰器装饰。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="kx ky l"/></div></figure><p id="913b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当我们用一个参数调用<code class="fe ko kp kq kr b">area</code>时，它返回圆的面积，当我们传递两个参数时，它调用计算矩形面积的函数，从而重载函数<code class="fe ko kp kq kr b">area</code>。你可以在这里找到整个工作演示<a class="ae mq" href="https://repl.it/@arpitbbhayani/Python-Function-Overloading" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="2900" class="kz la it bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">结论</h1><p id="6e52" class="pw-post-body-paragraph jq jr it js b jt lx jv jw jx ly jz ka kb lz kd ke kf ma kh ki kj mb kl km kn im bi translated">Python不支持函数重载，但是通过使用公共语言结构，我们破解了一个解决方案。我们使用decorators和一个用户维护的名称空间来重载函数，并使用参数的数量作为消除歧义的因素。我们还可以使用参数的数据类型(在decorator中定义)来消除歧义——这允许具有相同数量参数但不同类型的函数重载。重载的粒度只受限于函数<code class="fe ko kp kq kr b">getfullargspec</code>和我们的想象力。一个更整洁、更干净和更有效的方法也可以用上面的构造来实现，所以你可以自由地实现一个并发推特给我<a class="ae mq" href="https://twitter.com/arpit_bhayani" rel="noopener ugc nofollow" target="_blank"> @arpit_bhayani </a>，我会很高兴知道你用它做了什么。</p></div><div class="ab cl mr ms hx mt" role="separator"><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw mx"/><span class="mu bw bk mv mw"/></div><div class="im in io ip iq"><p id="a1ed" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="my">如果你喜欢你读到的内容，订阅我的时事通讯，让邮件直接发送到你的收件箱，给我大声喊出来</em><a class="ae mq" href="https://twitter.com/arpit_bhayani" rel="noopener ugc nofollow" target="_blank"><em class="my">@ arpit _ bhaya ni</em></a><em class="my">。</em></p><p id="f0ec" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="my">我的简讯中的往事</em></p><ul class=""><li id="183a" class="mc md it js b jt ju jx jy kb me kf mf kj mg kn mh mi mj mk bi translated"><a class="ae mq" href="https://arpitbhayani.me/blogs/super-long-integers" rel="noopener ugc nofollow" target="_blank"><em class="my">python如何实现超长整数？</em> </a></li><li id="8ed1" class="mc md it js b jt ml jx mm kb mn kf mo kj mp kn mh mi mj mk bi translated"><a class="ae mq" href="https://arpitbhayani.me/blogs/isolation-forest" rel="noopener ugc nofollow" target="_blank"> <em class="my">隔离森林异常检测算法</em> </a></li><li id="0d2d" class="mc md it js b jt ml jx mm kb mn kf mo kj mp kn mh mi mj mk bi translated"><a class="ae mq" href="https://arpitbhayani.me/blogs/rule-30" rel="noopener ugc nofollow" target="_blank"> <em class="my">伪随机数使用规则30 </em> </a></li><li id="f973" class="mc md it js b jt ml jx mm kb mn kf mo kj mp kn mh mi mj mk bi translated"><a class="ae mq" href="https://arpitbhayani.me/blogs/image-steganography" rel="noopener ugc nofollow" target="_blank"> <em class="my">关于图像隐写术你需要知道的一切</em> </a></li></ul><p id="b2d1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="my">本文原载于我的</em> <a class="ae mq" href="https://arpitbhayani.me/blogs/function-overloading" rel="noopener ugc nofollow" target="_blank"> <em class="my">博客Python中的重载函数</em> </a> <em class="my">。</em></p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><a href="https://arpitbhayani.me/blogs/function-overloading"><div class="gh gi mz"><img src="../Images/be0338ec8dd04f0565fa3089860ce646.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4oukgs202u7FgCR_246lAA.png"/></div></a></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><a href="https://arpit.substack.com/"><div class="gh gi nc"><img src="../Images/804f478b77eee456747bdd3a983a1a1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6YdHGeZXHC4EgnzzV9fhDw.png"/></div></a></figure></div></div>    
</body>
</html>