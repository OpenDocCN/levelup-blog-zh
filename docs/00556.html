<html>
<head>
<title>Crafting Shields for Vikings with Vue Components and Canvas</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Vue组件和帆布为维京人制作盾牌</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/crafting-shields-for-vikings-with-vue-components-and-canvas-20b90875b628?source=collection_archive---------1-----------------------#2019-05-03">https://levelup.gitconnected.com/crafting-shields-for-vikings-with-vue-components-and-canvas-20b90875b628?source=collection_archive---------1-----------------------#2019-05-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="248f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">阿蒙·阿玛思最新发布<em class="kf">狂战士</em></h2></div><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi kg"><img src="../Images/a12f55fc95f32b58b132f5394bac910f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BKwVloCjt6WKWcww80xM8g.jpeg"/></div></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk translated">“勇敢是胜利的一半”——哈拉尔德·哈德拉达传奇</figcaption></figure><p id="5580" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我喜欢一个好的图像发生器，所以当<a class="ae ls" href="https://twitter.com/AmonAmarthBand" rel="noopener ugc nofollow" target="_blank">阿蒙·阿马斯</a>让我支持他们的最新发行版<a class="ae ls" href="https://amonamarth.lnk.to/berserker" rel="noopener ugc nofollow" target="_blank"> <em class="lt">狂战士</em> </a>时，我很激动，他们开发了一个基于令人难以置信的艺术的发生器。🛡的解决方案是一个简单的<a class="lu lv ep" href="https://medium.com/u/20f059d252cc?source=post_page-----20b90875b628--------------------------------" rel="noopener" target="_blank">nuxt . js</a>T12】应用程序托管在<a class="lu lv ep" href="https://medium.com/u/5250f9d9bd2f?source=post_page-----20b90875b628--------------------------------" rel="noopener" target="_blank"> Netlify </a>上，它接受四个名字，并把它们渲染成圆形盾牌上的维京符文。然后，根据各大社交平台的建议尺寸，在背景上组成这个盾牌。如果像阿蒙·阿玛特一样，你在你的发布的创意方向上花了很多精力，那么让粉丝们使用可伸缩的图像生成来个性化一些视觉效果是有意义的。<a class="ae ls" href="https://berserker.amonamarth.com" rel="noopener ugc nofollow" target="_blank">今天就创建你的盾牌</a>，继续阅读，了解发电机的一些技术解决方案。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi lw"><img src="../Images/5bf661ff7fe5c46e313945cab39b58e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*deWJrEFNo_TrqqfsH1HsRg.jpeg"/></div></div></figure><p id="03f8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我在我最近的摩城项目案例研究中提到了这一点，但是我已经开始使用Vue.js 组件和HTML5 canvas的组合来创建动态图像。我目前的基本设置看起来有点像这样。</p><pre class="kh ki kj kk gt lx ly lz ma aw mb bi"><span id="f0f1" class="mc md iq ly b gy me mf l mg mh">&lt;template&gt;<br/>  &lt;img :src="canvasImage" /&gt;<br/>&lt;/template&gt;</span><span id="4b62" class="mc md iq ly b gy mi mf l mg mh">&lt;script&gt;<br/>export default{<br/>  computed: {<br/>    canvasImage() {<br/>      let canvas = document.createElement('canvas')</span><span id="dc04" class="mc md iq ly b gy mi mf l mg mh">      canvas.height = 1080<br/>      canvas.width  = 1080</span><span id="fe55" class="mc md iq ly b gy mi mf l mg mh">      let context = canvas.getContext('2d')</span><span id="c25f" class="mc md iq ly b gy mi mf l mg mh">      context.fillStyle = 'red'<br/>      context.fillRect(0, 0, 1080, 1080)</span><span id="f790" class="mc md iq ly b gy mi mf l mg mh">      return canvas.toDataURL('image/jpeg')<br/>    }<br/>  }<br/>}<br/>&lt;/script&gt;</span></pre><p id="b93f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">HTML模板是一个带有动态源的图像标签，它引用一个名为<code class="fe mj mk ml ly b">canvasImage</code>的计算属性。在这个属性中，我利用一个离线画布来生成一个新的图像，比如本例中的1080x1080红色正方形。然后画布作为数据URL返回，这样它就可以被<code class="fe mj mk ml ly b">&lt;img&gt;</code>显示。然后，我可以将这个组件包含到我的一个视图中，并像放置任何其他图像一样放置它。</p><p id="7c5d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">盾牌本身由两层构成:名字和背景。因为名称是动态的，所以我们使用新的画布和自定义排版来动态生成这些名称。一旦布局完成，它就被放置在预先渲染的背景图像之上。这两层都有一个相似的问题，即它们都依赖于外部资产。为了使该组件在多种浏览器中正常运行，您必须首先预加载您的字体和图像。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi mm"><img src="../Images/18e195f80de24501bc2860ff249c5991.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yZ4BBQuOob8rf5I4B4hwog.jpeg"/></div></div></figure><p id="4f1f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于图像，我添加了一个新的名为<code class="fe mj mk ml ly b">loadImage</code>的<a class="ae ls" href="https://developers.google.com/web/fundamentals/primers/promises" rel="noopener ugc nofollow" target="_blank"> promise </a>方法，该方法获取图像的url，加载它，然后在完成时返回分辨率。</p><pre class="kh ki kj kk gt lx ly lz ma aw mb bi"><span id="e584" class="mc md iq ly b gy me mf l mg mh">loadImage(url) {<br/>  return new Promise((resolve, revoke) =&gt; {<br/>    let img = new Image()</span><span id="d331" class="mc md iq ly b gy mi mf l mg mh">    img.crossOrigin = 'Anonymous'</span><span id="e944" class="mc md iq ly b gy mi mf l mg mh">    img.onload = () =&gt; {<br/>      resolve(img)<br/>    }</span><span id="acce" class="mc md iq ly b gy mi mf l mg mh">    img.src = url<br/>  })<br/>}</span></pre><p id="fa04" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在画布上使用自定义字体可能非常棘手，但是<a class="lu lv ep" href="https://medium.com/u/fe478cb14d5a?source=post_page-----20b90875b628--------------------------------" rel="noopener" target="_blank"> Bram Stein </a>编写了优秀的<a class="ae ls" href="https://github.com/bramstein/fontfaceobserver" rel="noopener ugc nofollow" target="_blank">字体外观观察者</a>加载器来帮助识别自定义字体何时被加载。回到我们的CSS中，我们可能有一个类似这样的<code class="fe mj mk ml ly b">@font-face</code>声明。</p><pre class="kh ki kj kk gt lx ly lz ma aw mb bi"><span id="d2dd" class="mc md iq ly b gy me mf l mg mh">@font-face{<br/>  font-family: 'Runes';<br/>  src: url('/runes.woff2') format('woff2'),<br/>       url('/runes.woff') format('woff');<br/>  font-weight: normal;<br/>  font-style: normal;<br/>}</span></pre><p id="cc72" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">回到我们组件中，我们可以使用字体外观观察器来检查字体是否已经加载。</p><pre class="kh ki kj kk gt lx ly lz ma aw mb bi"><span id="9b4d" class="mc md iq ly b gy me mf l mg mh">let font = new FontFaceObserver('Runes')</span><span id="7dd7" class="mc md iq ly b gy mi mf l mg mh">font.load().then(() =&gt; {<br/>  console.log('loaded')<br/>})</span></pre><p id="7801" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如您从这个片段中看到的，Font Face Observer也返回了一个承诺，因此我们实际上可以将我们的图像和排版加载结合在一起，以确保在调用canvas之前所有资产都已准备就绪。</p><pre class="kh ki kj kk gt lx ly lz ma aw mb bi"><span id="3fbd" class="mc md iq ly b gy me mf l mg mh">let font = new FontFaceObserver('Runes')</span><span id="5e89" class="mc md iq ly b gy mi mf l mg mh">Promise.all([<br/>  loadImage('/background.jpg'),<br/>  font.load()<br/>]).then(data =&gt; {<br/>  let background = data[0]<br/>})</span></pre><p id="30a2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了生成名称，我只使用了一些canvas方法来将文本准确地放置在需要放置的位置。我将参考我在图9中的设计来找到准确的尺寸和位置。</p><pre class="kh ki kj kk gt lx ly lz ma aw mb bi"><span id="40eb" class="mc md iq ly b gy me mf l mg mh">context.textAlign    = 'center'<br/>context.textBaseline = 'middle'<br/>context.font         = '24px Runes'<br/>context.fillText('Lee', 540, 540)</span></pre><p id="cec5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个项目中，文本在一个单独的画布上生成，然后<em class="lt">将</em>放到另一个包含背景图像的画布上。这使得名字可以以非常精确的方式生成，然后调整大小并放在不同的背景图像上。您可以使用<code class="fe mj mk ml ly b">drawImage</code>方法将预加载的背景和动态名称放到一个新的画布上。</p><pre class="kh ki kj kk gt lx ly lz ma aw mb bi"><span id="3c21" class="mc md iq ly b gy me mf l mg mh">context.drawImage(background, 0, 0)<br/>context.drawImage(names, 135, 135, 810, 810)</span></pre><p id="2bb5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您最不想做的事情就是为您的用户提供适合他们当前环境的下载说明。在移动设备上，用户不能点击下载图像，所以说明应该是:“按住下载图像。”(我使用<a class="ae ls" href="https://github.com/serbanghita/Mobile-Detect" rel="noopener ugc nofollow" target="_blank"> mobile-detect </a>来查看用户是否来自移动设备。)在桌面上，我会用<a class="ae ls" href="https://github.com/rndme/download" rel="noopener ugc nofollow" target="_blank"> downloadjs </a>连接一键下载，以提供最佳体验。实际上，您可以传入相同的计算方法来实现这个函数。</p><pre class="kh ki kj kk gt lx ly lz ma aw mb bi"><span id="c905" class="mc md iq ly b gy me mf l mg mh">download(canvasImage)</span></pre></div><div class="ab cl mn mo hu mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ij ik il im in"><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi mu"><img src="../Images/be1357a3a8ffed6d68575db0e20d0274.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4h2eBsoSn3tij0lxV4BCjg.jpeg"/></div></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk translated">阿蒙·阿玛思</figcaption></figure><p id="31de" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢斯蒂芬·里德和<a class="ae ls" href="http://5bam.com" rel="noopener ugc nofollow" target="_blank"> 5bam </a>让我参与其中，也祝贺阿蒙·阿马斯发行了他们的新唱片<a class="ae ls" href="https://amonamarth.lnk.to/berserker" rel="noopener ugc nofollow" target="_blank"> <em class="lt">狂战士</em> </a> <em class="lt">。</em>今天在<a class="ae ls" href="https://open.spotify.com/album/4NxlBCBuzKXCwNVNMfRGUa" rel="noopener ugc nofollow" target="_blank"> Spotify </a>或<a class="ae ls" href="https://itunes.apple.com/us/album/berserker/1453761098?uo=4&amp;&amp;app=music&amp;at=1l3vpUI&amp;ct=LFV_be82cab1fffe7341a1c8113864ea3de6" rel="noopener ugc nofollow" target="_blank"> Apple Music </a>上播放。🤘🏻</p></div></div>    
</body>
</html>