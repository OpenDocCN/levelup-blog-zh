<html>
<head>
<title>Exploring Fibonacci Formula in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python探索斐波那契公式</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/an-exploration-of-fibonacci-in-python-ac4e7df40d55?source=collection_archive---------1-----------------------#2020-09-05">https://levelup.gitconnected.com/an-exploration-of-fibonacci-in-python-ac4e7df40d55?source=collection_archive---------1-----------------------#2020-09-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/61025bd0661663ba7d79a796e22a7357.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v6CtHnGgya6zmV_GNC5fkg.jpeg"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">螺旋楼梯的蠕虫眼景观<a class="ae jg" href="https://www.pexels.com/photo/worms-eye-view-of-spiral-stained-glass-decors-through-the-roof-161154/" rel="noopener ugc nofollow" target="_blank">https://www . pexels . com/photo/worms-Eye-View-of-Spiral-colored-glass-decors-through-the-roof-161154/</a></figcaption></figure><div class=""/><p id="92cb" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们探索使用Python计算斐波那契数列的许多不同方法和技术。</p><p id="260f" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">斐波那契数列<a class="ae jg" href="https://en.wikipedia.org/wiki/Fibonacci_number" rel="noopener ugc nofollow" target="_blank">是美丽的，迷人的，神秘的！数列的定义如下:每个数都是前面两个数的和。简单:</a></p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="1734" class="ln lo jj lj b gy lp lq l lr ls">0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, ...</span></pre><h2 id="01e7" class="ln lo jj bd lt lu lv dn lw lx ly dp lz kr ma mb mc kv md me mf kz mg mh mi mj bi translated">迭代计算斐波那契</h2><p id="5bd3" class="pw-post-body-paragraph kg kh jj ki b kj mk kl km kn ml kp kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">计算斐波那契数(n)最简单的方法就是从起点开始，向前迭代。该解决方案计算所有以前的值，使其运行时间呈指数增长—数字越大，计算时间越长。</p><figure class="le lf lg lh gt iv"><div class="bz fp l di"><div class="mp mq l"/></div></figure><h2 id="02db" class="ln lo jj bd lt lu lv dn lw lx ly dp lz kr ma mb mc kv md me mf kz mg mh mi mj bi translated">递归计算斐波那契</h2><p id="a2d6" class="pw-post-body-paragraph kg kh jj ki b kj mk kl km kn ml kp kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">寻找斐波那契数的递归方法有时被用作计算机科学课堂的教学辅助。您可以在这里看到该函数在第14行调用了自己——使其成为递归的。</p><p id="646e" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此方法从起始位置向后工作，直到到达1或0。否则，它会计算所有先前递归的总和。</p><figure class="le lf lg lh gt iv"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="f56d" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">递归之所以有效，是因为计算机会跟踪我们在哪里使用了一种叫做<em class="mr">堆栈内存</em>的内存结构。这是有限的！试图寻找大的斐波那契数会耗尽堆栈空间。</p><p id="6c69" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外:递归算法与迭代算法有着相同的时间复杂性问题——它必须计算所有的值。</p><h2 id="0068" class="ln lo jj bd lt lu lv dn lw lx ly dp lz kr ma mb mc kv md me mf kz mg mh mi mj bi translated">使用记忆化进行有效的递归</h2><p id="070d" class="pw-post-body-paragraph kg kh jj ki b kj mk kl km kn ml kp kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">对于<code class="fe ms mt mu lj b">i</code>的一些值，重复调用前面的递归函数。我们可以使用一种称为记忆化的技术，而不是重新计算这个值。</p><p id="bbbf" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">记忆就是简单地记下以前计算的输出值。然后我们返回备忘录，而不是重新计算价值。</p><p id="568c" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们使用装饰函数，Python可以很好地支持记忆化。装饰器包装算法，拦截所有调用和所有返回值。通过截取调用和返回值，我们可以将它们存储在本地缓存中，并在将来使用缓存的答案。</p><figure class="le lf lg lh gt iv"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="2c96" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们现在可以将<code class="fe ms mt mu lj b">memo</code>装饰器应用于函数fibonacci_wrapped，并看到速度有了很大的提高。不幸的是，递归限制仍然适用。</p><figure class="le lf lg lh gt iv"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="c81d" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Python有一个内置的内存化装饰器，最近最少使用的缓存<code class="fe ms mt mu lj b">lru_cache</code>:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="9621" class="ln lo jj lj b gy lp lq l lr ls">@functools.lru_cache(maxsize=None)</span></pre><p id="9465" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以省去自己编写代码的麻烦(低效！)memoization decorator，而不是使用<code class="fe ms mt mu lj b">@functools.lru_cache.</code>如果你想用这个的话，别忘了使用<code class="fe ms mt mu lj b">import functools</code>。</p><h2 id="26e2" class="ln lo jj bd lt lu lv dn lw lx ly dp lz kr ma mb mc kv md me mf kz mg mh mi mj bi translated">用矩阵乘法计算斐波那契数</h2><p id="2770" class="pw-post-body-paragraph kg kh jj ki b kj mk kl km kn ml kp kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">前面的例子都有同样的问题:序列中所有前面的值都需要计算。我们可以通过使用矩阵乘法来直接计算序列的值，而无需计算前一个值，从而避免这种低效率。</p><p id="c8b4" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你可以在这里阅读更多关于矩阵乘法的内容:</p><div class="is it gp gr iu mv"><a href="https://en.wikipedia.org/wiki/Matrix_multiplication" rel="noopener  ugc nofollow" target="_blank"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd jk gy z fp na fr fs nb fu fw ji bi translated">矩阵乘法</h2><div class="nc l"><h3 class="bd b gy z fp na fr fs nb fu fw dk translated">在数学中，更确切地说是线性代数中，矩阵乘法是一种二元运算，它产生一个矩阵…</h3></div><div class="nd l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">en.wikipedia.org</p></div></div><div class="ne l"><div class="nf l ng nh ni ne nj ja mv"/></div></div></a></div><p id="3212" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为斐波纳契数列是线性的和可预测的，所以可以使用线性代数有效地计算它。</p><figure class="le lf lg lh gt iv"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="3417" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该公式需要恒定的内存空间才能完成，并且随着n值的增加，所需的时间也呈线性增长。</p><h2 id="2ecf" class="ln lo jj bd lt lu lv dn lw lx ly dp lz kr ma mb mc kv md me mf kz mg mh mi mj bi translated">使用黄金分割率计算斐波纳契数</h2><p id="d2c8" class="pw-post-body-paragraph kg kh jj ki b kj mk kl km kn ml kp kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">包含此方法是为了完整起见！</p><div class="is it gp gr iu mv"><a href="https://en.wikipedia.org/wiki/Golden_ratio#/media/File:Golden_ratio_line.svg" rel="noopener  ugc nofollow" target="_blank"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd jk gy z fp na fr fs nb fu fw ji bi translated">黄金比例</h2><div class="nc l"><h3 class="bd b gy z fp na fr fs nb fu fw dk translated">在数学中，如果两个量的比值等于它们的和与它们的和的比值，那么这两个量就是黄金比例</h3></div><div class="nd l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">en.wikipedia.org</p></div></div><div class="ne l"><div class="nk l ng nh ni ne nj ja mv"/></div></div></a></div><p id="74cd" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">斐波那契数列完美地代表了黄金分割率，所以我们可以用比奈公式来计算它:</p><figure class="le lf lg lh gt iv"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="7652" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你可以看到我在这里作弊。如果我们要搜索的序列号大于71，这个函数就会悄悄地作弊，转而使用矩阵乘法。</p><p id="295f" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">比奈公式是精确的代数。然而，计算机必须使用浮点数的不精确表示。随着n值的增加，舍入误差也会累积。</p><h2 id="adb8" class="ln lo jj bd lt lu lv dn lw lx ly dp lz kr ma mb mc kv md me mf kz mg mh mi mj bi translated">用位运算计算斐波那契数列</h2><p id="a293" class="pw-post-body-paragraph kg kh jj ki b kj mk kl km kn ml kp kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">在以前的一篇文章中，我描述了一些对整数执行位运算的常用公式。我的长期订户可能一直想知道为什么，但现在一切都揭晓了！</p><p id="798f" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们探索以下计算斐波那契数的方法之前，理解二进制算术是很重要的。</p><div class="is it gp gr iu mv"><a rel="noopener  ugc nofollow" target="_blank" href="/6-pythonic-bit-manipulation-recipes-ebdbd630e5ef"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd jk gy z fp na fr fs nb fu fw ji bi translated">6种Pythonic比特操作方法</h2><div class="nc l"><h3 class="bd b gy z fp na fr fs nb fu fw dk translated">一些可重用的python方法，用于操作位来执行快速运算。</h3></div><div class="nd l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="ne l"><div class="nl l ng nh ni ne nj ja mv"/></div></div></a></div><h2 id="8364" class="ln lo jj bd lt lu lv dn lw lx ly dp lz kr ma mb mc kv md me mf kz mg mh mi mj bi translated">卢卡斯序列</h2><p id="c0a2" class="pw-post-body-paragraph kg kh jj ki b kj mk kl km kn ml kp kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">在处理斐波那契数列时，我还想展示卢卡斯数列。像斐波那契一样，卢卡斯数字是它们的两个前任的总和——它们只是从不同的地方开始:</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="3f7f" class="ln lo jj lj b gy lp lq l lr ls">2, 1, 3, 4, 7, 11, 18, 29, 47, 76, 123, 199, ....</span></pre><p id="14d2" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，卢卡斯数与斐波那契数非常接近:</p><figure class="le lf lg lh gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nm"><img src="../Images/9b041ef1f5378f61598e4d4317362639.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sXlySIlphqFpg2ESMpGBAQ.png"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">卢卡斯和斐波那契数是相关的</figcaption></figure><p id="08bd" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们用<code class="fe ms mt mu lj b">n=6</code>来解决这个问题。</p><pre class="le lf lg lh gt li lj lk ll aw lm bi"><span id="2d21" class="ln lo jj lj b gy lp lq l lr ls">F(n-1) = F(5) = 3<br/>F(n+1) = F(7) = 8<br/>F(n-1) + F(n+1) = (3 + 8) = <strong class="lj jk">11</strong></span><span id="5acd" class="ln lo jj lj b gy nn lq l lr ls">L(6) = <strong class="lj jk">11</strong></span></pre><h2 id="8dde" class="ln lo jj bd lt lu lv dn lw lx ly dp lz kr ma mb mc kv md me mf kz mg mh mi mj bi translated">用吉克斯特拉公式计算斐波那契数</h2><p id="5026" class="pw-post-body-paragraph kg kh jj ki b kj mk kl km kn ml kp kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">Edsgar Djikstra可能是现代史上最杰出的理论计算机科学。他提出了一种算法，利用卢卡斯数的幂来导出相关的斐波那契数。</p><p id="2f56" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">真的很棒。完整的算法如下:</p><figure class="le lf lg lh gt iv"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="74ce" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">函数<code class="fe ms mt mu lj b">fibonacci_djikstra</code>可识别地使用了我之前展示的卢卡斯数和斐波纳契数之间的关系:<code class="fe ms mt mu lj b">L(n) = F(n-1) + F(n+1)</code>。</p><p id="3d75" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它更进了一步，使用卢卡斯幂函数来利用比奈公式的一部分——看那里的整数5，你从黄金分割的讨论中认出来了吗？</p><p id="6bca" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">关于Djikstra算法的更深入的讨论，可以随意参考<a class="ae jg" href="https://www.cs.utexas.edu/users/EWD/ewd06xx/EWD654.PDF" rel="noopener ugc nofollow" target="_blank">这个信息</a>。</p><h2 id="f551" class="ln lo jj bd lt lu lv dn lw lx ly dp lz kr ma mb mc kv md me mf kz mg mh mi mj bi translated">Karatsuba快速乘法</h2><p id="d908" class="pw-post-body-paragraph kg kh jj ki b kj mk kl km kn ml kp kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">继我们对二进制算术的讨论之后，有一种非常有趣的方法来计算<strong class="ki jk">非常</strong>大的乘积——Karatsuba乘法。</p><figure class="le lf lg lh gt iv"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="a84e" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">根据<a class="ae jg" href="https://en.wikipedia.org/wiki/Karatsuba_algorithm" rel="noopener ugc nofollow" target="_blank">维基百科</a>的说法，Karatsuba算法是第一个渐近快于二次“小学”算法的乘法算法，对于足够大的值，它提供了17.75倍于传统二次公式的加速。</p><p id="4405" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将在下一个也是最后一个计算斐波那契数列的公式中使用这个算法！</p><h2 id="134d" class="ln lo jj bd lt lu lv dn lw lx ly dp lz kr ma mb mc kv md me mf kz mg mh mi mj bi translated">递归快速加倍计算斐波那契</h2><p id="f5d4" class="pw-post-body-paragraph kg kh jj ki b kj mk kl km kn ml kp kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">下面的快速加倍公式使用了前面解释的四种工具:递归、记忆、二进制算术和Karatsuba乘法。你应该能猜到我为什么选择把这个公式放在最后！</p><p id="afef" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个公式非常快。它在我的MacBook Pro上以微秒为单位计算斐波那契到80000位。</p><figure class="le lf lg lh gt iv"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="744c" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，我将使用迭代变体解释这是如何工作的。</p><h2 id="440d" class="ln lo jj bd lt lu lv dn lw lx ly dp lz kr ma mb mc kv md me mf kz mg mh mi mj bi translated">迭代快速加倍计算斐波那契</h2><p id="ee92" class="pw-post-body-paragraph kg kh jj ki b kj mk kl km kn ml kp kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">我们可以很容易地改变算法的形式:从递归到迭代或者从迭代到递归。看看下面的迭代版本与前面的有何不同:</p><figure class="le lf lg lh gt iv"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="8394" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它包含两个循环。第一个连续将我们要找的序列号减半。第二个在回来的路上连续加倍。迭代版本显然更慢，但避免了堆栈溢出。</p><p id="4547" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个算法使用了数论者确定的一个重要性质:“减半性质”。它还通过利用以下公式极大地简化了矩阵乘法方法:</p><figure class="le lf lg lh gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi no"><img src="../Images/a46e166d9792c5fa69269fa9e511b5dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9VIycV4SrLZ7IdnRp7h82Q.png"/></div></div></figure><p id="4e8c" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有很多平方在计算，这就是Karatsuba乘法有用的地方。</p><h2 id="edb4" class="ln lo jj bd lt lu lv dn lw lx ly dp lz kr ma mb mc kv md me mf kz mg mh mi mj bi translated">计时结果</h2><p id="9bdb" class="pw-post-body-paragraph kg kh jj ki b kj mk kl km kn ml kp kq kr mm kt ku kv mn kx ky kz mo lb lc ld im bi translated">我想你可能会对计时结果感兴趣。我决定比较矩阵乘法算法、快速加倍算法和Djikstra算法。很明显，黄金分割、简单的迭代和递归算法会慢一些。</p><p id="c8f5" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是收集计时数据的代码:</p><figure class="le lf lg lh gt iv"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="23e4" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是计时结果的图表:</p><figure class="le lf lg lh gt iv gh gi paragraph-image"><div class="gh gi np"><img src="../Images/d6b886eab69bb2e903ad3c6f63132ec1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*HKBZOMTwy7RM6W_OiF578A.png"/></div></figure><p id="9eba" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我希望你喜欢这篇文章！我想邀请您关注我，以便在我发布下一篇文章时通知您！</p></div></div>    
</body>
</html>