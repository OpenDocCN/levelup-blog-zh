<html>
<head>
<title>Solve N+1 query problem in GraphQL with Dataloader</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Dataloader解决GraphQL中的N+1查询问题</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/solve-n-1-query-problem-in-graphql-with-dataloaders-18e16ac17b21?source=collection_archive---------3-----------------------#2020-08-01">https://levelup.gitconnected.com/solve-n-1-query-problem-in-graphql-with-dataloaders-18e16ac17b21?source=collection_archive---------3-----------------------#2020-08-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/f707bfbfaa60a718cd83cfa31af184b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*mhMF50PSG7XY9YWqlp-Wuw.png"/></div></figure><p id="5dc7" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated"><em class="kv">这是我的</em> <a class="ae kw" rel="noopener ugc nofollow" target="_blank" href="/do-not-resolve-your-graphql-fields-like-a-rest-endpoint-ac43242f269"> <em class="kv">上一篇博客</em> </a> <em class="kv">的延续，我的博客解释了一种更好的方法来解析GraphQL查询的字段。该博客以一篇关于在解析字段时所面临的N+1查询问题的注释结束。</em></p><p id="9745" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">在这篇博文中，我们将看到如何使用<a class="ae kw" href="https://github.com/graphql/dataloader" rel="noopener ugc nofollow" target="_blank">数据加载器</a>解决N+1查询问题。</p><h1 id="a540" class="kx ky it bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">什么是数据加载器？</h1><p id="a022" class="pw-post-body-paragraph jx jy it jz b ka lv kc kd ke lw kg kh ki lx kk kl km ly ko kp kq lz ks kt ku im bi translated">Dataloader是一个库，它可以批量处理连续的请求，并在后台生成单个数据请求。这个请求可以发送到任何数据源，比如数据库或web服务。</p><blockquote class="ma"><p id="ea87" class="mb mc it bd md me mf mg mh mi mj ku dk translated">Dataloader接受一个数组作为参数，使用该参数处理数据并返回一个对象数组。</p></blockquote><p id="3c26" class="pw-post-body-paragraph jx jy it jz b ka mk kc kd ke ml kg kh ki mm kk kl km mn ko kp kq mo ks kt ku im bi translated">dataloader会将返回数组的第n个索引处的元素视为输入参数中第n个元素的数据。</p><p id="80db" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">现在让我们实现postsLoader。</p><figure class="mp mq mr ms gt ju"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="a6dd" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">我们现在将使用这个postsLoader来解析帖子。更新后的<code class="fe mv mw mx my b">resolvers</code>如下:</p><figure class="mp mq mr ms gt ju"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="097a" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">当客户端查询用户以及帖子字段时，那么对于在“用户”查询中解析的每个用户，将调用这个“帖子”解析器，其父参数等于用户对象。使用这个用户，我们可以找到文章。</p><p id="f7c9" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">正如您从“帖子”字段的解析器中看到的，我们仍然在使用数据加载器的“load”API查询单个帖子。</p><blockquote class="ma"><p id="85bb" class="mb mc it bd md me mf mg mh mi mj ku dk translated">将对多个postsLoader.load()调用进行批处理，然后只调用一次“postsLoader”。</p></blockquote><p id="7cb5" class="pw-post-body-paragraph jx jy it jz b ka mk kc kd ke ml kg kh ki mm kk kl km mn ko kp kq mo ks kt ku im bi translated">下面的屏幕截图显示了当客户端请求用户数据以及他们的帖子数据时，数据库查询的命中率。</p><figure class="mp mq mr ms gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="na nb di nc bf nd"><div class="gh gi mz"><img src="../Images/62b55bc90212e6c3f1e5286c3117b1fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m6l4runqUtMT6j1CzvHvXA.png"/></div></div><figcaption class="ne nf gj gh gi ng nh bd b be z dk translated">这确保了我们只访问数据库一次来获取数据，从而解决了我们的N+1查询问题。</figcaption></figure></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><h1 id="ecc6" class="kx ky it bd kz la np lc ld le nq lg lh li nr lk ll lm ns lo lp lq nt ls lt lu bi translated">不过，对于dataloader的这种实现，有一点需要注意。</h1><p id="8017" class="pw-post-body-paragraph jx jy it jz b ka lv kc kd ke lw kg kh ki lx kk kl km ly ko kp kq lz ks kt ku im bi translated">Dataloader不仅批处理请求，还缓存响应。它进行缓存以确保不会进行另一个查询来获取相同的数据。<br/> <br/>这种缓存的问题是，如果另一个请求的解析器也命中这个数据加载器(当第一个请求被处理时)，那么<strong class="jz iu">缓存的结果也将返回给第二个请求</strong>。如您所见，将缓存的数据返回给完全不同的请求是一个严重的问题。<br/> <br/> <strong class="jz iu"> <em class="kv">因此，数据加载器应始终根据请求进行定义。</em> </strong></p><p id="ee52" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">这样，不同的请求将使用不同的数据加载器实例。最好的方法是在GraphQL请求的上下文中定义它们。</p><p id="4786" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">因此，数据加载器的新实现如下所示:</p><figure class="mp mq mr ms gt ju"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="9a28" class="pw-post-body-paragraph jx jy it jz b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku im bi translated">希望这对你有帮助。看看这个<a class="ae kw" href="https://github.com/shrirambalakrishnan/blog-graphql-optimizations" rel="noopener ugc nofollow" target="_blank"> repo </a>，它使用Apollo GraphQL服务器实现了上述<code class="fe mv mw mx my b">users</code> resolver。</p></div></div>    
</body>
</html>