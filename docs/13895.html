<html>
<head>
<title>Managing types in React Typescript, the right way</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">以正确的方式管理React Typescript中的类型</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/managing-types-in-react-typescript-the-right-way-fa1ecc50a2bf?source=collection_archive---------0-----------------------#2022-10-15">https://levelup.gitconnected.com/managing-types-in-react-typescript-the-right-way-fa1ecc50a2bf?source=collection_archive---------0-----------------------#2022-10-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/25b67e330bd5fbef84355706fa7a996f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ea9o499FoDuykaXdTQchTg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">在React Typescript中管理类型</figcaption></figure><h1 id="0fa0" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">介绍</h1><p id="3b9c" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">作为开发人员，我们喜欢干净、可维护的代码。当使用Typescript编写React时，我们经常处理分布在多个文件中的类型。如果你痴迷于干净的代码，这就有很多不足之处。这里有几件事可以让你的React代码更干净、更易读。</p></div><div class="ab cl ly lz hu ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ij ik il im in"><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/29bf188d0a124046fc3f24569b9b7cac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FqqXfkYf0e8fe5U6LxGk_Q.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">反应类型基础</figcaption></figure><h1 id="cf13" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">基础知识</h1><p id="4372" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">编写代码时，扎实的基础很重要。以下是编写类型脚本代码时要记住的一些基本习惯。</p><h2 id="5f9b" class="mj kd iq bd ke mk ml dn ki mm mn dp km ll mo mp kq lp mq mr ku lt ms mt ky mu bi translated">命名规格</h2><p id="15b6" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">Typescript允许您忽略约定，按照自己的方式编写代码。使用惯例是因为它们有帮助，正如俗话所说“入乡随俗…”</p><p id="b654" class="pw-post-body-paragraph la lb iq lc b ld mv lf lg lh mw lj lk ll mx ln lo lp my lr ls lt mz lv lw lx ij bi translated">下面是编写干净易读的代码时应该遵循的一些约定:</p><ul class=""><li id="780a" class="na nb iq lc b ld mv lh mw ll nc lp nd lt ne lx nf ng nh ni bi translated">使用<strong class="lc ir"> PascalCase </strong>作为类型名。</li><li id="13da" class="na nb iq lc b ld nj lh nk ll nl lp nm lt nn lx nf ng nh ni bi translated">不要对接口使用<strong class="lc ir"> I </strong>前缀。(从静态类型语言中复制的东西)</li><li id="5863" class="na nb iq lc b ld nj lh nk ll nl lp nm lt nn lx nf ng nh ni bi translated">私有财产使用<strong class="lc ir"> _ </strong>前缀。</li><li id="044c" class="na nb iq lc b ld nj lh nk ll nl lp nm lt nn lx nf ng nh ni bi translated">对组件属性类型使用<strong class="lc ir">一致的命名</strong>(例如，type<strong class="lc ir">CustomComponentProps</strong>)</li></ul><h2 id="d2a1" class="mj kd iq bd ke mk ml dn ki mm mn dp km ll mo mp kq lp mq mr ku lt ms mt ky mu bi translated">组件和类型</h2><p id="8ad7" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">遵循React基于组件的编码风格，我们将组件分成多个不同的文件。使用typescript时，将道具类型与组件一起导出总是一个好主意。</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="no np l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">工具提示组件</figcaption></figure><p id="8c83" class="pw-post-body-paragraph la lb iq lc b ld mv lf lg lh mw lj lk ll mx ln lo lp my lr ls lt mz lv lw lx ij bi translated">在<strong class="lc ir"> tooltip.tsx </strong>文件中，您可以看到TooltipProps类型与组件一起被导出。当您的组件从父组件的状态中获取道具时，这尤其有用。</p><p id="6920" class="pw-post-body-paragraph la lb iq lc b ld mv lf lg lh mw lj lk ll mx ln lo lp my lr ls lt mz lv lw lx ij bi translated">另一个有用的习惯是用定制属性扩展你的基本HTML组件属性(使用<strong class="lc ir"> React)。ComponentPropsWithoutRef </strong>)。尤其是在创建基本HTML标签的风格化版本时。</p><h2 id="5fad" class="mj kd iq bd ke mk ml dn ki mm mn dp km ll mo mp kq lp mq mr ku lt ms mt ky mu bi translated">名称空间</h2><p id="ef59" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">随着项目规模的增加，类型的数量也会增加。很有可能会出现名称冲突。<a class="ae nq" href="https://www.typescriptlang.org/docs/handbook/namespaces.html" rel="noopener ugc nofollow" target="_blank">名称空间</a>就是这个问题的解决方案。命名空间不仅可以避免多重类型声明，还可以为你的项目提供一个组织结构。有效地使用名称空间可以使您的代码库变得干净。下面是一个名称空间<strong class="lc ir">验证</strong>的例子。</p><pre class="mf mg mh mi gt nr ns nt nu aw nv bi"><span id="0038" class="mj kd iq ns b gy nw nx l ny nz">namespace <strong class="ns ir">Validation</strong> {<br/>  export interface <strong class="ns ir">StringValidator</strong> {<br/>    isAcceptable(s: <strong class="ns ir">string</strong>): <strong class="ns ir">boolean</strong>;<br/>  }</span><span id="5acb" class="mj kd iq ns b gy oa nx l ny nz">const lettersRegexp = /^[A-Za-z]+$/;<br/>  const numberRegexp = /^[0-9]+$/;</span><span id="0f91" class="mj kd iq ns b gy oa nx l ny nz">export class <strong class="ns ir">LettersOnlyValidator</strong> implements <strong class="ns ir">StringValidator</strong> {<br/>    isAcceptable(s: <strong class="ns ir">string</strong>) {<br/>      return lettersRegexp.test(s);<br/>    }<br/>  }</span><span id="996e" class="mj kd iq ns b gy oa nx l ny nz">export class <strong class="ns ir">ZipCodeValidator</strong> implements <strong class="ns ir">StringValidator</strong> {<br/>    isAcceptable(s: <strong class="ns ir">string</strong>) {<br/>      return s.length === 5 &amp;&amp; numberRegexp.test(s);<br/>    }<br/>  }<br/>}</span></pre><h2 id="1a3e" class="mj kd iq bd ke mk ml dn ki mm mn dp km ll mo mp kq lp mq mr ku lt ms mt ky mu bi translated">关键字of，类型of</h2><p id="7c93" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">我们熟悉JavaScript中的<strong class="lc ir">类型的</strong>操作符。JavaScript中的typeof运算符有助于获取字符串格式的变量类型。但是typeof运算符不能给出对象的确切类型。例如:</p><pre class="mf mg mh mi gt nr ns nt nu aw nv bi"><span id="a6ff" class="mj kd iq ns b gy nw nx l ny nz">type <strong class="ns ir">X</strong> = {a: <strong class="ns ir">number</strong>; b: <strong class="ns ir">boolean</strong>;};<br/>const x: <strong class="ns ir">X</strong> = {a: 1, b: false};</span><span id="5851" class="mj kd iq ns b gy oa nx l ny nz">/* Here the <strong class="ns ir">typeof</strong> operator will only give the type of x as <strong class="ns ir">object</strong> instead of the type <strong class="ns ir">X</strong> */<br/>console.log(typeof x);</span></pre><p id="3269" class="pw-post-body-paragraph la lb iq lc b ld mv lf lg lh mw lj lk ll mx ln lo lp my lr ls lt mz lv lw lx ij bi translated">Typescript只是一个开发工具，它可以使用<strong class="lc ir"> typeof </strong>操作符来获得变量的确切类型定义。例如:</p><pre class="mf mg mh mi gt nr ns nt nu aw nv bi"><span id="b60b" class="mj kd iq ns b gy nw nx l ny nz">type <strong class="ns ir">X</strong> = {a: <strong class="ns ir">number</strong>; b: <strong class="ns ir">boolean</strong>;};<br/>const x: <strong class="ns ir">X</strong> = {a: 1, b: false};</span><span id="e6af" class="mj kd iq ns b gy oa nx l ny nz">// Here type <strong class="ns ir">Y</strong> will evaluate to type <strong class="ns ir">X</strong> = {a: <strong class="ns ir">number</strong>; b: <strong class="ns ir">boolean</strong>;}<br/>type <strong class="ns ir">Y</strong> = typeof x;</span></pre><p id="fb2e" class="pw-post-body-paragraph la lb iq lc b ld mv lf lg lh mw lj lk ll mx ln lo lp my lr ls lt mz lv lw lx ij bi translated">typeof运算符有助于直接从传递的值中推断类型。可以使用typeof来推断类型，而不是在需要时导入每个类型。</p><p id="55eb" class="pw-post-body-paragraph la lb iq lc b ld mv lf lg lh mw lj lk ll mx ln lo lp my lr ls lt mz lv lw lx ij bi translated">运算符的<strong class="lc ir">键由typescript引入。它以联合的形式给出对象类型的属性。例如:</strong></p><pre class="mf mg mh mi gt nr ns nt nu aw nv bi"><span id="1165" class="mj kd iq ns b gy nw nx l ny nz">type <strong class="ns ir">X</strong> = {a: <strong class="ns ir">number</strong>; b: <strong class="ns ir">boolean</strong>;};<br/>const x: <strong class="ns ir">X</strong> = {a: 1, b: false};</span><span id="5f86" class="mj kd iq ns b gy oa nx l ny nz">// <strong class="ns ir">Y</strong> = 'a' | 'b'<br/>type <strong class="ns ir">Y</strong> = keyof <strong class="ns ir">X</strong>;<br/>const y: <strong class="ns ir">Y</strong> = 'a';</span><span id="fe83" class="mj kd iq ns b gy oa nx l ny nz">/* Without explicitly specifying y as type <strong class="ns ir">Y</strong> TS will infer its type as <strong class="ns ir">string</strong> and will throw an error about indexing type <strong class="ns ir">X</strong> using <strong class="ns ir">string</strong> */<br/>console.log(x[y]);</span></pre><p id="61e5" class="pw-post-body-paragraph la lb iq lc b ld mv lf lg lh mw lj lk ll mx ln lo lp my lr ls lt mz lv lw lx ij bi translated">您将经常组合使用typeof和keyof运算符，typeof用于获取对象的类型，keyof用于对其进行索引。</p><h1 id="477b" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">项目范围类型<em class="ob">(@类型)</em></h1><p id="781e" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated"><a class="ae nq" href="https://www.typescriptlang.org/tsconfig#types" rel="noopener ugc nofollow" target="_blank"> <strong class="lc ir"> @types </strong> </a>是typescript中的一个特殊目录。声明文件(<strong class="lc ir"> *.d.ts </strong>文件，例如<strong class="lc ir"> index.d.ts </strong>)被项目的<strong class="lc ir"> tsconfig </strong>自动识别为根类型文件。这些文件中定义的类型可以用作项目中的全局类型。</p><p id="e3bf" class="pw-post-body-paragraph la lb iq lc b ld mv lf lg lh mw lj lk ll mx ln lo lp my lr ls lt mz lv lw lx ij bi translated">有时会经常需要某些类型定义。@types就是这个的答案。您可以使用@types来覆盖或扩展您的类型定义。下面是一个<strong class="lc ir"> @types/index.d.ts </strong>的例子:</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="no np l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">反应类型的<strong class="ak"> @types/index.d.ts </strong></figcaption></figure><p id="9da3" class="pw-post-body-paragraph la lb iq lc b ld mv lf lg lh mw lj lk ll mx ln lo lp my lr ls lt mz lv lw lx ij bi translated">在这个例子中，你可以看到类型<strong class="lc ir">可选</strong>被定义，以及一个新的<strong class="lc ir">命名空间Api </strong>被声明。<strong class="lc ir"> React名称空间</strong>中的类型也被扩展为包含<strong class="lc ir"> React。ClassicFunctionalComponent </strong>(或其简称<strong class="lc ir"> React。CFC </strong>)。</p><p id="ad11" class="pw-post-body-paragraph la lb iq lc b ld mv lf lg lh mw lj lk ll mx ln lo lp my lr ls lt mz lv lw lx ij bi translated"><strong class="lc ir">枚举是<strong class="lc ir">@类型</strong>的一个例外</strong>。typescript中定义的类型不是JavaScript包的一部分，但是枚举是编译的。在<strong class="lc ir"> @types </strong>中定义<strong class="lc ir">枚举</strong>将使它们在项目范围内全局可访问，但是它们可能会在构建中抛出错误。最好在<strong class="lc ir"> *中单独定义和导出枚举。ts/tsx </strong>文件。</p><h1 id="9cf1" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">实用程序类型</h1><p id="6e47" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">Typescript提供了几种实用工具类型，帮助您转换类型定义。我常用的一些实用程序类型有:</p><ul class=""><li id="ab78" class="na nb iq lc b ld mv lh mw ll nc lp nd lt ne lx nf ng nh ni bi translated"><strong class="lc ir">部分&lt;类型&gt; </strong>构造类型，该类型的所有属性都设置为可选。</li></ul><pre class="mf mg mh mi gt nr ns nt nu aw nv bi"><span id="6271" class="mj kd iq ns b gy nw nx l ny nz">type <strong class="ns ir">X</strong> = {a: <strong class="ns ir">number</strong>;}<br/>// <strong class="ns ir">Y</strong> = <strong class="ns ir">Partial&lt;X&gt;</strong> = {a?: <strong class="ns ir">number</strong>;} or {a: <strong class="ns ir">number</strong> | <strong class="ns ir">undefined</strong>;}<br/>type <strong class="ns ir">Y</strong> = <strong class="ns ir">Partial&lt;X&gt;</strong></span></pre><ul class=""><li id="75c0" class="na nb iq lc b ld mv lh mw ll nc lp nd lt ne lx nf ng nh ni bi translated"><strong class="lc ir">必需的&lt;类型&gt; </strong>构造类型，该类型的所有属性都设置为必需的。</li></ul><pre class="mf mg mh mi gt nr ns nt nu aw nv bi"><span id="bc6b" class="mj kd iq ns b gy nw nx l ny nz">type <strong class="ns ir">X</strong> = {a?: <strong class="ns ir">number</strong>;}<br/>// <strong class="ns ir">Y</strong> = <strong class="ns ir">Required&lt;X&gt;</strong> = {a: <strong class="ns ir">number</strong>;}<br/>type <strong class="ns ir">Y</strong> = <strong class="ns ir">Required&lt;X&gt;</strong></span></pre><ul class=""><li id="c196" class="na nb iq lc b ld mv lh mw ll nc lp nd lt ne lx nf ng nh ni bi translated"><strong class="lc ir">记录&lt;键，&gt;类型</strong>构造一个对象类型，其属性键为<strong class="lc ir">键</strong>类型，属性值为<strong class="lc ir">类型</strong>类型。</li></ul><pre class="mf mg mh mi gt nr ns nt nu aw nv bi"><span id="6e1a" class="mj kd iq ns b gy nw nx l ny nz">// <strong class="ns ir">X</strong> = {[key: <strong class="ns ir">string</strong>]: <strong class="ns ir">number</strong>;}<br/>type <strong class="ns ir">X</strong> = <strong class="ns ir">Record&lt;string, number&gt;</strong></span></pre><ul class=""><li id="3947" class="na nb iq lc b ld mv lh mw ll nc lp nd lt ne lx nf ng nh ni bi translated"><strong class="lc ir">省略&lt;类型，移除<strong class="lc ir">键</strong>后</strong>键&gt;从<strong class="lc ir">类型</strong>构造一个类型(字符串文字或字符串的并集)。</li></ul><pre class="mf mg mh mi gt nr ns nt nu aw nv bi"><span id="ed55" class="mj kd iq ns b gy nw nx l ny nz">type <strong class="ns ir">X</strong> = {a: <strong class="ns ir">number</strong>; b: <strong class="ns ir">boolean</strong>; c: <strong class="ns ir">string</strong>;}<br/>// <strong class="ns ir">Y</strong> = {b: <strong class="ns ir">boolean</strong>; c: <strong class="ns ir">string</strong>;}<br/>type <strong class="ns ir">Y</strong> = <strong class="ns ir">Omit&lt;X,</strong> 'a'<strong class="ns ir">&gt;</strong><br/>// <strong class="ns ir">Z</strong> = {c: <strong class="ns ir">string</strong>;}<br/>type <strong class="ns ir">Z</strong> = <strong class="ns ir">Omit&lt;X,</strong> 'a' | 'b'<strong class="ns ir">&gt;</strong></span></pre><p id="929e" class="pw-post-body-paragraph la lb iq lc b ld mv lf lg lh mw lj lk ll mx ln lo lp my lr ls lt mz lv lw lx ij bi translated">typescript中有更多的<a class="ae nq" href="https://www.typescriptlang.org/docs/handbook/utility-types.html" rel="noopener ugc nofollow" target="_blank"> <strong class="lc ir">实用程序类型</strong> </a>，这些将帮助您避免为每个单独的或可派生的类型重写类型定义。</p><p id="6998" class="pw-post-body-paragraph la lb iq lc b ld mv lf lg lh mw lj lk ll mx ln lo lp my lr ls lt mz lv lw lx ij bi translated">您还可以编写定制的实用程序类型，比如在<strong class="lc ir"> @types/index.d.ts </strong>文件中提供的可选类型。可选类型用于使类型中只有选定的属性是可选的。</p><h1 id="b5ac" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">无商标消费品</h1><p id="5671" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated"><a class="ae nq" href="https://www.typescriptlang.org/docs/handbook/2/generics.html" rel="noopener ugc nofollow" target="_blank"> <strong class="lc ir">泛型</strong> </a>允许开发者编写可重用的类型安全代码/组件。在像C#和Java这样的静态类型语言的世界里，泛型通常用于编写可重用的代码。Typescript从这些语言中吸取了许多东西，包括泛型。</p><p id="51b5" class="pw-post-body-paragraph la lb iq lc b ld mv lf lg lh mw lj lk ll mx ln lo lp my lr ls lt mz lv lw lx ij bi translated">泛型将类型作为输入，并使用它们来派生变量或函数的类型。其中一个例子是实用程序类型<strong class="lc ir"> Partial &lt; T &gt; </strong>，它以类型<strong class="lc ir"> T </strong>为输入，给出了一个新的类型。泛型可以接受多个类型作为输入，也可以有默认类型。下面是一个带有函数的泛型的例子。</p><pre class="mf mg mh mi gt nr ns nt nu aw nv bi"><span id="93ee" class="mj kd iq ns b gy nw nx l ny nz">/* <strong class="ns ir">Type</strong> is passed to the function either <strong class="ns ir">explicitly</strong> or <strong class="ns ir">implicitly */</strong><br/>function identity&lt;<strong class="ns ir">Type</strong>&gt;(arg: <strong class="ns ir">Type</strong>): <strong class="ns ir">Type</strong> {<br/>  return arg;<br/>}</span><span id="5455" class="mj kd iq ns b gy oa nx l ny nz">/* <strong class="ns ir">Explicitly</strong>: <strong class="ns ir">Type</strong> is assigned type <strong class="ns ir">string</strong> explicitly and the function takes <strong class="ns ir">string</strong> argument arg */<br/>identity&lt;<strong class="ns ir">string</strong>&gt;("Hello");</span><span id="8358" class="mj kd iq ns b gy oa nx l ny nz">/* <strong class="ns ir">Implicitly</strong>: <strong class="ns ir">Type</strong> implicitly takes type <strong class="ns ir">string</strong> based on the type of argument arg */<br/>identity("World")</span></pre><p id="53a5" class="pw-post-body-paragraph la lb iq lc b ld mv lf lg lh mw lj lk ll mx ln lo lp my lr ls lt mz lv lw lx ij bi translated">使用泛型使您的代码可重用，而无需编写多个类型定义。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/6611a9e66fddca2915fdf2cdfc18410e.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/1*DdLSB1TcfliV9AeIzKr39A.gif"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">包装它</figcaption></figure><h1 id="a7d7" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">包扎</h1><p id="1063" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">在开始时，将typescript与react一起使用似乎是额外的工作。在没有结构的情况下添加类型来反应JSX可能会使您的代码变脏。遵循前面提到的习惯、指导方针和惯例，我已经能够让我的代码更干净、更容易管理。希望你(读者)也能从中获得一些有用的提示。</p><h1 id="af66" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">参考✍️</h1><ul class=""><li id="c02e" class="na nb iq lc b ld le lh li ll od lp oe lt of lx nf ng nh ni bi translated"><strong class="lc ir">打字约定</strong><strong class="lc ir">——</strong><a class="ae nq" href="https://ts.dev/style/#identifiers" rel="noopener ugc nofollow" target="_blank">https://ts.dev/style/#identifiers</a></li><li id="6556" class="na nb iq lc b ld nj lh nk ll nl lp nm lt nn lx nf ng nh ni bi translated"><strong class="lc ir"> ESLint命名规则</strong><strong class="lc ir">—</strong><a class="ae nq" href="https://github.com/typescript-eslint/typescript-eslint/blob/main/packages/eslint-plugin/docs/rules/naming-convention.md" rel="noopener ugc nofollow" target="_blank">https://github . com/typescript-ESLint/typescript-ESLint/blob/main/packages/ESLint-plugin/docs/rules/naming-conventi on . MD</a></li><li id="f840" class="na nb iq lc b ld nj lh nk ll nl lp nm lt nn lx nf ng nh ni bi translated"><strong class="lc ir">名称空间—</strong><a class="ae nq" href="https://www.typescriptlang.org/docs/handbook/namespaces.html" rel="noopener ugc nofollow" target="_blank">https://www . typescriptlang . org/docs/handbook/Namespaces . html</a></li><li id="ab2b" class="na nb iq lc b ld nj lh nk ll nl lp nm lt nn lx nf ng nh ni bi translated"><strong class="lc ir">@ typescript中的类型—</strong><a class="ae nq" href="https://www.typescriptlang.org/tsconfig#types" rel="noopener ugc nofollow" target="_blank">https://www.typescriptlang.org/tsconfig#types</a></li><li id="5d51" class="na nb iq lc b ld nj lh nk ll nl lp nm lt nn lx nf ng nh ni bi translated"><strong class="lc ir">公用事业类型—</strong><a class="ae nq" href="https://www.typescriptlang.org/docs/handbook/utility-types.html" rel="noopener ugc nofollow" target="_blank">https://www . typescriptlang . org/docs/handbook/Utility-types . html</a></li><li id="5c29" class="na nb iq lc b ld nj lh nk ll nl lp nm lt nn lx nf ng nh ni bi translated"><strong class="lc ir">仿制药—</strong><a class="ae nq" href="https://www.typescriptlang.org/docs/handbook/2/generics.html" rel="noopener ugc nofollow" target="_blank">https://www . typescriptlang . org/docs/handbook/2/Generics . html</a></li><li id="c02d" class="na nb iq lc b ld nj lh nk ll nl lp nm lt nn lx nf ng nh ni bi translated"><strong class="lc ir">打字手册—</strong><a class="ae nq" href="https://www.typescriptlang.org/docs/handbook/intro.html" rel="noopener ugc nofollow" target="_blank">https://www.typescriptlang.org/docs/handbook/intro.html</a></li><li id="4597" class="na nb iq lc b ld nj lh nk ll nl lp nm lt nn lx nf ng nh ni bi translated"><strong class="lc ir">React typescript cheat sheet—</strong><a class="ae nq" href="https://react-typescript-cheatsheet.netlify.app/docs/advanced/patterns_by_usecase/" rel="noopener ugc nofollow" target="_blank">https://React-typescript-cheat sheet . net lify . app/docs/advanced/patterns _ by _ use case/</a></li></ul></div><div class="ab cl ly lz hu ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ij ik il im in"><blockquote class="og oh oi"><p id="5405" class="la lb oj lc b ld mv lf lg lh mw lj lk ok mx ln lo ol my lr ls om mz lv lw lx ij bi translated"><strong class="lc ir">附注</strong>这里提到的信息是我理解的<strong class="lc ir"/>可能不完全准确。如果你想要更多的细节，你可以检查<a class="ae nq" href="https://www.typescriptlang.org/docs/handbook/intro.html" rel="noopener ugc nofollow" target="_blank">打字稿文档</a>或者参考资料部分。</p></blockquote></div></div>    
</body>
</html>