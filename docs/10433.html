<html>
<head>
<title>8 Most Common Mistakes I’ve Seen New Angular Developers Doing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我见过的新开发人员犯的8个最常见的错误</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/angular-most-common-pitfalls-78a2baf860f5?source=collection_archive---------4-----------------------#2021-12-06">https://levelup.gitconnected.com/angular-most-common-pitfalls-78a2baf860f5?source=collection_archive---------4-----------------------#2021-12-06</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><h2 id="a528" class="is it iu bd b dl iv iw ix iy iz ja dk jb translated" aria-label="kicker paragraph"><a class="ae ep" href="https://rakiabensassi.medium.com/list/software-engineering-7a179a23ebfd" rel="noopener">有角度的</a></h2><div class=""/><div class=""><h2 id="88b1" class="pw-subtitle-paragraph ka jd iu bd b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dk translated">以及如何避免它们</h2></div><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gi gj ks"><img src="../Images/c5ed30c4810957ba445284e6722c0105.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ra_L2qGaaKGq9eXC"/></div></div><figcaption class="le lf gk gi gj lg lh bd b be z dk translated">照片由<a class="ae li" href="https://unsplash.com/@krakenimages?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> krakenimages </a>在<a class="ae li" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="880d" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">在我最近的一次技术访谈中，我被问及我从开发人员那里听到的关于Angular的常见问题，以及他们所面临的问题。事实上，我的采访者的目标是收集关于框架的反馈，并检查如何优化它以满足受众的需求，并提供良好的开发人员体验。</p><p id="cc0a" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">经过思考和提炼我的答案，我想在这篇文章中与你分享，并打破我见过的有棱角的新人最常见的不良做法——包括我以前的自我行为。</p><p id="8a6c" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">这些错误的原因通常是“没有意识到它们”，因为缺乏关于框架如何工作的培训和指导。</p><p id="0a1b" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">因此，我写这篇文章是为了帮助你构建更强大的Angular应用程序，并为你省去很多麻烦，比如体验性能下降。</p><p id="1b3c" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated"><em class="mf">如果你更喜欢看，这里有个视频:</em></p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="mg mh l"/></div></figure><h1 id="e9f5" class="mi mj iu bd mk ml mm mn mo mp mq mr ms kj mt kk mu km mv kn mw kp mx kq my mz bi translated">1.忘记退订了</h1><p id="3296" class="pw-post-body-paragraph lj lk iu ll b lm na ke lo lp nb kh lr ls nc lu lv lw nd ly lz ma ne mc md me in bi translated">当您订阅一个可观察对象时，将会产生一个订阅对象，如果处理不当，可能会在运行时导致内存泄漏。</p><p id="3d69" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">要在您的组件被Angular破坏时删除此订阅对象，您需要取消订阅。您可以按如下方式操作:</p><ul class=""><li id="eab5" class="nf ng iu ll b lm ln lp lq ls nh lw ni ma nj me nk nl nm nn bi translated">向组件添加主题变量:<code class="fe no np nq nr b">_unsubscribe: Subject&lt;any&gt; = new Subject()</code></li><li id="24f1" class="nf ng iu ll b lm ns lp nt ls nu lw nv ma nw me nk nl nm nn bi translated">从<code class="fe no np nq nr b">pipe()</code>方法内的<code class="fe no np nq nr b">rxjs/operators</code>库中调用<code class="fe no np nq nr b">takeUntil()</code>。</li><li id="86f0" class="nf ng iu ll b lm ns lp nt ls nu lw nv ma nw me nk nl nm nn bi translated">然后在组件的<code class="fe no np nq nr b">ngOnDestroy()</code>方法中调用<code class="fe no np nq nr b">_unsubscribe.next()</code>和<code class="fe no np nq nr b">_unsubscribe.complete()</code>。</li></ul><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="nx mh l"/></div><figcaption class="le lf gk gi gj lg lh bd b be z dk translated">角度:订阅和取消订阅可观察对象的示例</figcaption></figure><h1 id="907e" class="mi mj iu bd mk ml mm mn mo mp mq mr ms kj mt kk mu km mv kn mw kp mx kq my mz bi translated">2.不使用OnPush更改检测</h1><p id="a6a3" class="pw-post-body-paragraph lj lk iu ll b lm na ke lo lp nb kh lr ls nc lu lv lw nd ly lz ma ne mc md me in bi translated">为了保持HTML模板和内部模型状态同步，Angular提出了两种变化检测(CD)策略:Default和OnPush。</p><p id="7baf" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">与默认(或<code class="fe no np nq nr b">CheckAlways</code>)策略不同，OnPush(或<code class="fe no np nq nr b">CheckOnce</code>)策略不会自动检测变化，而是只在必要时检测。这大大减少了CD周期和计算量，从而提高了性能。</p><p id="11c6" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">在我第一次试用Angular时，我没有足够的关于OnPush方法的知识，也不知道为了正确使用它我应该做什么。只是在目睹了一些<a class="ae li" href="https://betterprogramming.pub/build-me-an-angular-app-with-memory-leaks-please-36302184e658" rel="noopener ugc nofollow" target="_blank">性能问题</a>并开始寻找补救措施后，我才更加意识到这一点。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="nx mh l"/></div><figcaption class="le lf gk gi gj lg lh bd b be z dk translated">使用ChangeDetectionStrategy的角度容器组件。OnPush</figcaption></figure><h1 id="008f" class="mi mj iu bd mk ml mm mn mo mp mq mr ms kj mt kk mu km mv kn mw kp mx kq my mz bi translated">3.在代码设计中没有考虑不变性</h1><p id="109e" class="pw-post-body-paragraph lj lk iu ll b lm na ke lo lp nb kh lr ls nc lu lv lw nd ly lz ma ne mc md me in bi translated">使用角度<code class="fe no np nq nr b">OnPush</code>变化检测策略至关重要。但更重要的是，在设计代码和组件之间的交互时，通过考虑不变性，让您的应用程序为此做好准备。</p><p id="f6f7" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">否则，当你在没有做好准备的情况下改变你的CD策略时，你的应用程序功能中的一些错误和倒退就会开始悄悄出现。</p><p id="62b1" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">您将在“<a class="ae li" href="https://betterprogramming.pub/angular-onpush-change-detection-f629cbce0bfa" rel="noopener ugc nofollow" target="_blank">Angular Performance:5 OnPush Change Detection Case Studies</a>”一文中找到答案，这是五个分析不同组件并通过考虑不变性来调整它们的数据结构的真实例子，以便平稳地迁移到OnPush，而不会使应用程序容易出错。</p><h1 id="9fff" class="mi mj iu bd mk ml mm mn mo mp mq mr ms kj mt kk mu km mv kn mw kp mx kq my mz bi translated">4.没有正确使用数据绑定</h1><p id="246c" class="pw-post-body-paragraph lj lk iu ll b lm na ke lo lp nb kh lr ls nc lu lv lw nd ly lz ma ne mc md me in bi translated">数据绑定允许我们定义DOM和组件之间的通信。它负责组件和模板之间数据的自动拉和推。</p><p id="d99e" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">Angular中有4种数据绑定类型:</p><ol class=""><li id="88d0" class="nf ng iu ll b lm ln lp lq ls nh lw ni ma nj me ny nl nm nn bi translated"><strong class="ll je">事件绑定</strong>:使用()</li><li id="6ee1" class="nf ng iu ll b lm ns lp nt ls nu lw nv ma nw me ny nl nm nn bi translated"><strong class="ll je">属性绑定</strong>:使用[]</li><li id="2ff1" class="nf ng iu ll b lm ns lp nt ls nu lw nv ma nw me ny nl nm nn bi translated"><strong class="ll je">字符串插值</strong>(或mustache语法):使用{{}}显示组件数据。</li><li id="761c" class="nf ng iu ll b lm ns lp nt ls nu lw nv ma nw me ny nl nm nn bi translated"><strong class="ll je">双向数据绑定</strong>:使用[()]确保数据模型在视图中自动同步。</li></ol><figure class="kt ku kv kw gu kx gi gj paragraph-image"><div class="ab gv cl nz"><img src="../Images/10ac3c43765102ff174670fe9fdf30b4.png" data-original-src="https://miro.medium.com/v2/format:webp/1*Q7hgPQrvB1SdHgFC4FJZ8w.png"/></div><figcaption class="le lf gk gi gj lg lh bd b be z dk translated"><a class="ae li" href="https://angular.io/guide/architecture-components" rel="noopener ugc nofollow" target="_blank">角度数据绑定</a></figcaption></figure><p id="3656" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">在开始使用Angular时，一些开发人员可能没有正确理解绑定语法，而是使用()而不是[]或者在不需要的地方使用[()]。</p><p id="d51d" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">你应该小心双向数据绑定<strong class="ll je"> </strong>，因为随着时间的推移，它可能会导致糟糕的web性能。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="nx mh l"/></div><figcaption class="le lf gk gi gj lg lh bd b be z dk translated">Angular 4数据绑定类型</figcaption></figure><h1 id="4422" class="mi mj iu bd mk ml mm mn mo mp mq mr ms kj mt kk mu km mv kn mw kp mx kq my mz bi translated">5.字符串插值中的调用方法</h1><p id="14ba" class="pw-post-body-paragraph lj lk iu ll b lm na ke lo lp nb kh lr ls nc lu lv lw nd ly lz ma ne mc md me in bi translated">字符串插值是一种特殊的语法，它允许我们在双花括号{{}}内编写一些JavaScript表达式，以便向网页添加动态内容。</p><p id="371b" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">如果数据必须在视图上显示之前进行转换，您需要小心，避免通过调用花括号内的方法进行转换，如下例所示，因为这将损害您的应用程序性能和用户体验:</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="nx mh l"/></div><figcaption class="le lf gk gi gj lg lh bd b be z dk translated">角度:在视图上显示数据之前转换数据的错误方式</figcaption></figure><p id="7617" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">在这种情况下，转换数据的更好方法是使用<a class="ae li" href="https://betterprogramming.pub/build-me-an-angular-app-with-memory-leaks-please-36302184e658#1bf1" rel="noopener ugc nofollow" target="_blank">角管道</a>。您可以定义一个自定义管道<code class="fe no np nq nr b">GetTotalPipe</code>，而不是在组件中定义<code class="fe no np nq nr b">getTotal()</code>方法，并在HTML页面中使用<code class="fe no np nq nr b">data</code>和<code class="fe no np nq nr b">col.key</code>作为参数来调用它:</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="nx mh l"/></div><figcaption class="le lf gk gi gj lg lh bd b be z dk translated">计算表格中一列总和的角形管道</figcaption></figure><p id="aa6d" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">并如下使用它:</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="nx mh l"/></div><figcaption class="le lf gk gi gj lg lh bd b be z dk translated">角度:在视图上显示数据之前转换数据的正确方式</figcaption></figure><h1 id="8b87" class="mi mj iu bd mk ml mm mn mo mp mq mr ms kj mt kk mu km mv kn mw kp mx kq my mz bi translated">6.混合组件和服务职责</h1><p id="84bc" class="pw-post-body-paragraph lj lk iu ll b lm na ke lo lp nb kh lr ls nc lu lv lw nd ly lz ma ne mc md me in bi translated">Angular框架为开发人员提供了定义组件和服务的可能性，这些组件和服务负责不同的逻辑。然而，一些开发人员通过在组件中注入<code class="fe no np nq nr b">HttpClient</code>来混合这种逻辑，而不是在HttpService中这样做，只是在组件中使用这个服务。</p><p id="67b6" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">这是一个混合责任和违反<a class="ae li" rel="noopener ugc nofollow" target="_blank" href="/clean-code-in-an-agile-team-79ed5fe3ed5d">干净代码</a>规则的简单场景，但是有更多的情况没有这个明显，例如在一个组件中实现一个特性，我们可以通过应用<a class="ae li" href="https://betterprogramming.pub/frontend-architecture-376e6323ef9b#f398" rel="noopener ugc nofollow" target="_blank">容器-呈现者模式</a>创建两个或更多具有不同角色的组件:</p><ul class=""><li id="b51f" class="nf ng iu ll b lm ln lp lq ls nh lw ni ma nj me nk nl nm nn bi translated"><strong class="ll je">容器组件:</strong>负责从服务获取数据，并使用输入和输出将其传递给其子组件(表示组件)。</li><li id="0682" class="nf ng iu ll b lm ns lp nt ls nu lw nv ma nw me nk nl nm nn bi translated"><strong class="ll je">表示组件:</strong>负责呈现UI并处理与用户的交互。它还可以注入一个服务，以减少组件树中在容器和其子节点之间传递数据的输入数量。</li></ul><p id="680b" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">拥有独立组件的相同概念也适用于服务。例如，在Angular应用程序中，您可以定义:</p><ul class=""><li id="860b" class="nf ng iu ll b lm ln lp lq ls nh lw ni ma nj me nk nl nm nn bi translated">一个<strong class="ll je"> HttpService </strong>与REST API通信:</li></ul><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="nx mh l"/></div><figcaption class="le lf gk gi gj lg lh bd b be z dk translated">Angular: BaseHttpService</figcaption></figure><ul class=""><li id="220f" class="nf ng iu ll b lm ln lp lq ls nh lw ni ma nj me nk nl nm nn bi translated">一个<a class="ae li" href="https://betterprogramming.pub/frontend-architecture-376e6323ef9b#2e84" rel="noopener ugc nofollow" target="_blank"> <strong class="ll je">可观察的数据服务</strong> </a>:它是一个基于<code class="fe no np nq nr b">BehaviorSubject</code>的服务，可以在你的应用程序中扮演一个商店的角色。它允许您通过避免集成NgRx和NgXs等第三方库来管理应用程序状态，从而降低代码复杂性。</li></ul><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="nx mh l"/></div><figcaption class="le lf gk gi gj lg lh bd b be z dk translated">Angular: BaseStoreService</figcaption></figure><ul class=""><li id="3ab1" class="nf ng iu ll b lm ln lp lq ls nh lw ni ma nj me nk nl nm nn bi translated">一个<strong class="ll je">表单服务</strong>，如果你的应用程序需要动态表单，这个服务非常有用。它可以负责所有表单字段的创建、它们的验证逻辑、用正确的值填充它们、添加它们的事件侦听器等等。</li></ul><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="nx mh l"/></div><figcaption class="le lf gk gi gj lg lh bd b be z dk translated">Angular: FormGroupService</figcaption></figure><h1 id="b30e" class="mi mj iu bd mk ml mm mn mo mp mq mr ms kj mt kk mu km mv kn mw kp mx kq my mz bi translated">7.生命周期挂钩的错误用法</h1><p id="a33d" class="pw-post-body-paragraph lj lk iu ll b lm na ke lo lp nb kh lr ls nc lu lv lw nd ly lz ma ne mc md me in bi translated">像<code class="fe no np nq nr b">ngOnInit()</code>、<code class="fe no np nq nr b">ngOnDestroy()</code>和<code class="fe no np nq nr b">ngOnAfterViewInit()</code>这样的方法在Angular中被称为生命周期挂钩，因为它们在一些特定的事件中被框架<strong class="ll je">自动</strong>调用:</p><ul class=""><li id="7082" class="nf ng iu ll b lm ln lp lq ls nh lw ni ma nj me nk nl nm nn bi translated">当组件被初始化时，</li><li id="8334" class="nf ng iu ll b lm ns lp nt ls nu lw nv ma nw me nk nl nm nn bi translated">视图显示在屏幕上，</li><li id="7ba7" class="nf ng iu ll b lm ns lp nt ls nu lw nv ma nw me nk nl nm nn bi translated">视图正在从屏幕上移除，</li><li id="5169" class="nf ng iu ll b lm ns lp nt ls nu lw nv ma nw me nk nl nm nn bi translated">诸如此类。</li></ul><p id="786a" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">这意味着您不需要像对自己定义的方法那样在代码中手动调用这些方法。</p><p id="d15c" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">关于生命周期挂钩，您需要记住的另一点是，为了使用它们，您的组件必须实现它们适当的接口，否则它们将是普通的方法，并且不会像预期的那样工作:</p><ul class=""><li id="4c87" class="nf ng iu ll b lm ln lp lq ls nh lw ni ma nj me nk nl nm nn bi translated"><code class="fe no np nq nr b">ngOnInit()</code>来自界面<code class="fe no np nq nr b">OnInit</code></li><li id="c847" class="nf ng iu ll b lm ns lp nt ls nu lw nv ma nw me nk nl nm nn bi translated"><code class="fe no np nq nr b">ngOnDestroy()</code>来自接口<code class="fe no np nq nr b">OnDestroy</code></li><li id="75c1" class="nf ng iu ll b lm ns lp nt ls nu lw nv ma nw me nk nl nm nn bi translated"><code class="fe no np nq nr b">ngOnChanges()</code>来自接口<code class="fe no np nq nr b">OnChanges</code></li><li id="98de" class="nf ng iu ll b lm ns lp nt ls nu lw nv ma nw me nk nl nm nn bi translated"><code class="fe no np nq nr b">ngOnAfterViewInit()</code>来自接口<code class="fe no np nq nr b">AfterViewInit</code></li></ul><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="nx mh l"/></div><figcaption class="le lf gk gi gj lg lh bd b be z dk translated">有角度的生命周期挂钩</figcaption></figure><h1 id="6126" class="mi mj iu bd mk ml mm mn mo mp mq mr ms kj mt kk mu km mv kn mw kp mx kq my mz bi translated">8.不是为生产而建</h1><p id="f26c" class="pw-post-body-paragraph lj lk iu ll b lm na ke lo lp nb kh lr ls nc lu lv lw nd ly lz ma ne mc md me in bi translated">尽管我们使用<code class="fe no np nq nr b">--prod</code>参数(或为生产而构建)来生成一个可以部署在服务器上的包，但是在本地机器上运行<code class="fe no np nq nr b">ng build --prod</code>可以让我们看到应用程序中的一些错误，而这些错误在我们仅仅使用<code class="fe no np nq nr b">ng build</code>构建时是看不到的。</p><p id="ac4b" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">也就是说，我和我的一些同事忘记用<code class="fe no np nq nr b">--prod</code>参数来构建我们的应用程序，以便定期检查它们。只有当我们在服务器上进行新的部署后面临令人不快的意外，并且我们试图在本地重现它时，我们才记得我们已经忘记了什么。</p><p id="47ee" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">我看到的另一个关于<code class="fe no np nq nr b">--prod</code>标志的问题是根本没有使用它，而是在服务器上部署了一个不是为生产而构建的包，它只是用<code class="fe no np nq nr b">ng build</code>生成的。当然，这阻碍了应用程序的一些性能优势。</p><h2 id="f22e" class="oa mj iu bd mk ob oc dn mo od oe dp ms ls of og mu lw oh oi mw ma oj ok my ja bi translated">注意</h2><p id="b9fe" class="pw-post-body-paragraph lj lk iu ll b lm na ke lo lp nb kh lr ls nc lu lv lw nd ly lz ma ne mc md me in bi translated">从Angular版本12开始，您不再需要在<code class="fe no np nq nr b">ng build</code>和<code class="fe no np nq nr b">yarn build</code>中指定<code class="fe no np nq nr b">--prod</code>标志，因为默认情况下会启用生产构建。</p><figure class="kt ku kv kw gu kx"><div class="bz fq l di"><div class="ol mh l"/></div><figcaption class="le lf gk gi gj lg lh bd b be z dk translated">默认情况下，Angular 12启用生产版本</figcaption></figure></div><div class="ab cl om on hy oo" role="separator"><span class="op bw bk oq or os"/><span class="op bw bk oq or os"/><span class="op bw bk oq or"/></div><div class="in io ip iq ir"><h1 id="0922" class="mi mj iu bd mk ml ot mn mo mp ou mr ms kj ov kk mu km ow kn mw kp ox kq my mz bi translated">最终想法</h1><p id="46f5" class="pw-post-body-paragraph lj lk iu ll b lm na ke lo lp nb kh lr ls nc lu lv lw nd ly lz ma ne mc md me in bi translated">希望这些技巧能够帮助您更好地理解Angular及其各种特性和功能。</p><p id="0010" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">如果你觉得他们激起了你学习更多关于框架的兴趣，或者让你想起了你所面临的其他陷阱或挑战，不要犹豫，点击回复按钮，告诉我们。我很想收到你的来信。</p></div><div class="ab cl om on hy oo" role="separator"><span class="op bw bk oq or os"/><span class="op bw bk oq or os"/><span class="op bw bk oq or"/></div><div class="in io ip iq ir"><h1 id="e2d1" class="mi mj iu bd mk ml ot mn mo mp ou mr ms kj ov kk mu km ow kn mw kp ox kq my mz bi translated">想要更多吗？</h1><p id="2805" class="pw-post-body-paragraph lj lk iu ll b lm na ke lo lp nb kh lr ls nc lu lv lw nd ly lz ma ne mc md me in bi translated">我为一群聪明、好奇的🧠人写关于工程、技术和领导力的文章💡。<a class="ae li" href="https://rakiabensassi.substack.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="ll je">加入我的电子邮件简讯，获得独家访问</strong> </a> <strong class="ll je"> </strong>或在此<a class="ae li" href="https://rakiabensassi.medium.com/membership" rel="noopener">注册Medium</a>(如果你还没有注册)。</p><p id="0f2f" class="pw-post-body-paragraph lj lk iu ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me in bi translated">你可以在Udemy上查看我的<strong class="ll je">视频课程</strong>:<a class="ae li" href="https://www.udemy.com/course/identify-and-fix-javascript-memory-leaks/" rel="noopener ugc nofollow" target="_blank">如何识别、诊断、修复Web应用中的内存泄漏</a>。</p><div class="oy oz gq gs pa pb"><a href="https://betterprogramming.pub/angular-13-features-ef528a9ae16f" rel="noopener  ugc nofollow" target="_blank"><div class="pc ab fp"><div class="pd ab pe cl cj pf"><h2 class="bd je gz z fq pg fs ft ph fv fx jd bi translated">Angular 13的新功能</h2><div class="pi l"><h3 class="bd b gz z fq pg fs ft ph fv fx dk translated">100% Ivy，更好的组件API，不支持IE11，等等</h3></div><div class="pj l"><p class="bd b dl z fq pg fs ft ph fv fx dk translated">better编程. pub</p></div></div><div class="pk l"><div class="pl l pm pn po pk pp lc pb"/></div></div></a></div><div class="oy oz gq gs pa pb"><a rel="noopener  ugc nofollow" target="_blank" href="/top-data-collection-tools-a18fe72c16f7"><div class="pc ab fp"><div class="pd ab pe cl cj pf"><h2 class="bd je gz z fq pg fs ft ph fv fx jd bi translated">2022年你不应错过的4种数据收集工具</h2><div class="pi l"><h3 class="bd b gz z fq pg fs ft ph fv fx dk translated">信息是生存和发展的关键。这里有一些市场上最好的工具来获得它。</h3></div><div class="pj l"><p class="bd b dl z fq pg fs ft ph fv fx dk translated">levelup.gitconnected.com</p></div></div><div class="pk l"><div class="pq l pm pn po pk pp lc pb"/></div></div></a></div></div></div>    
</body>
</html>