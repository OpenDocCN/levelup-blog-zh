<html>
<head>
<title>Linux Commands: ls and its option -l</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Linux命令:ls及其选项-l</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/linux-commands-ls-and-its-option-l-51d720769d6a?source=collection_archive---------15-----------------------#2020-04-16">https://levelup.gitconnected.com/linux-commands-ls-and-its-option-l-51d720769d6a?source=collection_archive---------15-----------------------#2020-04-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="6efd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当你在一个shell中输入<code class="fe ko kp kq kr b">ls -l</code>并点击<em class="ks">回车</em>是怎么回事？</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi kt"><img src="../Images/13f3c75dfcb90ed57221e68ad2c13c6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DE_Hx85hSx6Zuu5WFMPRLg.jpeg"/></div></div></figure><h1 id="d763" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">重要的事情先来</h1><p id="d064" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi mi translated"><span class="l mj mk ml bm mm mn mo mp mq di">在</span>这篇文章中，我们将讨论shell、Linux命令及其选项。因为我们非常希望您<strong class="js iu">理解并内化</strong>标题主题，所以记住一些将帮助您实现我们目标的概念总是有好处的。</p><p id="2e54" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以，我们开始吧！</p><ul class=""><li id="38a3" class="mr ms it js b jt ju jx jy kb mt kf mu kj mv kn mw mx my mz bi translated">什么是贝壳？</li></ul><p id="d6f2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">外壳是一个程序，它从用户的键盘获取命令，并将这些<strong class="js iu">指令</strong>发送给操作系统，以便操作系统能够<strong class="js iu">执行这些指令</strong>。它被命名为shell，因为它是操作系统的最外层(它使用一个<em class="ks">内核</em>)。</p><p id="02b9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">换句话说，shell提供了一个用户界面，允许用户通过命令行界面(CLI)访问操作系统。此外，操作系统使用外壳来控制使用外壳脚本的系统的执行。</p><p id="4759" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">用户需要熟悉命令及其调用系统，以及特定于shell的脚本语言，这样才能利用它的所有特性。</p><ul class=""><li id="a374" class="mr ms it js b jt ju jx jy kb mt kf mu kj mv kn mw mx my mz bi translated">你是说… <em class="ks">内核</em>吗？</li></ul><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div class="gh gi na"><img src="../Images/c161e64444a1c2516a7b55d985c2aa24.png" data-original-src="https://miro.medium.com/v2/resize:fit:572/format:webp/1*Iy_yoAshsWcjMpMb19VNbg.jpeg"/></div></figure><p id="6b59" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">是啊！内核是每个Linux发行版的共同点。其实Linux特指内核，1991年以创始人Linus Torvald命名(他想到的第一个名字:Freax，“免费+怪胎+ UNIX”)。</p><p id="94a3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi mi translated">每个操作系统都使用一个内核，当你与任何软件交互时，它会完成大部分工作，让你拥有一台可以工作的电脑！内核就像一座桥梁，连接你的计算机硬件和你想要使用的软件。</p><p id="cbcb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">资源管理是内核提供的另一个功能，因为它必须检查<strong class="js iu">是否有足够的可用内存</strong>来执行程序，并在内存中正确分配程序。当出现内存故障时，系统会停止正常工作，因为一个程序需要另一个程序当前正在使用的资源。</p><p id="74b2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请说重点！🤷‍♀️ </p><p id="effc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们快到了，别担心！正如我前面所说的，你需要知道一些基本的话题，这样你才能理解我们的目标。</p><ul class=""><li id="e0fc" class="mr ms it js b jt ju jx jy kb mt kf mu kj mv kn mw mx my mz bi translated">命令，听起来没那么难，对吧？</li></ul><p id="d95d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">命令是一个字符或一串字符，当写在shell中并按回车键时，它向内核发送一个“指令”(即<strong class="js iu">系统调用</strong>)，执行指定的功能。</p><p id="1815" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">命令很多，使用最多的有<em class="ks"> pwd </em>(打印工作目录)<em class="ks"> cd </em>(更改目录)<strong class="js iu"> <em class="ks"> ls </em>(列出文件和目录)</strong>。</p><p id="5da1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">大多数命令<strong class="js iu">允许选项和参数</strong>，它们是这样操作的:</p><pre class="ku kv kw kx gt nb kr nc nd aw ne bi"><span id="d157" class="nf lg it kr b gy ng nh l ni nj"><em class="ks">command -options arguments</em></span></pre><p id="51e3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">分解一下，<em class="ks"/><code class="fe ko kp kq kr b"><em class="ks">command</em></code>指的是命令的名称，<code class="fe ko kp kq kr b"><em class="ks">-options</em></code>是您想要对命令的行为进行的调整(选项是可选的)，而<code class="fe ko kp kq kr b"><em class="ks">arguments</em></code>是命令操作的“对象”。</p><ul class=""><li id="7ddf" class="mr ms it js b jt ju jx jy kb mt kf mu kj mv kn mw mx my mz bi translated">ls命令</li></ul><p id="b628" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">ls命令非常有用，因为CLI看不到文件夹或文件，就像您在日常计算机浏览器上看到的那样。为了让您知道您的目录中有什么内容，请在shell中键入ls命令。</p><p id="4cec" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">简而言之，从<em class="ks"> ls man </em>来看，该命令的作用是<strong class="js iu">列出关于文件的信息</strong>(默认为当前目录)，如果没有其他指示，则按字母顺序对条目进行排序。</p><p id="02a7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它的<strong class="js iu">语法</strong>如下所示:</p><pre class="ku kv kw kx gt nb kr nc nd aw ne bi"><span id="97c5" class="nf lg it kr b gy ng nh l ni nj">$ ls [<em class="ks">options</em>] [<em class="ks">file</em>|<em class="ks">dir</em>]</span></pre><p id="1c0c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">(哦，看到那个灰色的长方形里面有几个字吗？这是您在shell中实际键入的内容)</p><p id="4c2f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">命令<strong class="js iu">选项</strong>之前提到过，现在我们知道它们调整命令的行为方式。下面，你会看到<em class="ks">一些</em>的ls选项:</p><p id="ecda" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">ls <strong class="js iu"> -a </strong>，列出所有文件，包括以“.”开头的隐藏文件<br/> ls <strong class="js iu"> -d </strong>，用“*/”列出目录。<br/> ls <strong class="js iu"> -i </strong>，列出每个文件的索引号。<br/> ls <strong class="js iu"> -l </strong>，长格式列表—显示权限。<br/> ls <strong class="js iu"> -s </strong>，列表文件大小。<br/> ls <strong class="js iu"> -la </strong>，列出包含隐藏文件的长格式。<br/> s <strong class="js iu"> -ls </strong>，带文件大小的长格式列表。</p><p id="3224" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">(有没有注意到<strong class="js iu"> -la </strong>，<strong class="js iu"> -ls </strong>选项？要知道你可以一次使用不同的选项，这里的‘主’选项是<strong class="js iu"> l </strong>，它会用长格式列出，如果和<strong class="js iu"> a </strong>一起使用，长格式的列表也会列出文件大小，也可以单独使用)。</p><h2 id="132b" class="nf lg it bd lh nk nl dn ll nm nn dp lp kb no np lt kf nq nr lx kj ns nt mb nu bi translated"><strong class="ak">言归正传</strong></h2><p id="9ab8" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi mi translated">我知道使用命令看起来非常简单，每个人都可以毫无困难地使用它们。嗯，是的。但是，当你把指令发送到内核并让它工作时，会发生很多事情。</p><p id="ce7d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以，当你打开一个shell时，你会看到一个带有' $ '的<strong class="js iu">提示</strong>，那是你写下你想要或需要执行的命令或'动作'的提示，然后回车。当您使用<em class="ks"> ls </em>并按回车键时，它看起来像这样:</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi nv"><img src="../Images/5e19b788b4270ad1c5e4d31d5e2a461e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KFbNpLu6Xak7oPhCqZI5Cg.png"/></div></div><figcaption class="nw nx gj gh gi ny nz bd b be z dk translated">在这里，您可以看到我们的simple_shell项目中有哪些文件和目录，只是它们的名称。</figcaption></figure><p id="b3d5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是当你使用ls -l时你会看到的:</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi oa"><img src="../Images/01948256aae600d7ad61f488e4cfdf57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ECA60U3_9u2njY0MI-w1bg.png"/></div></div><figcaption class="nw nx gj gh gi ny nz bd b be z dk translated">现在，关于目录中的内容有了更多的信息:文件权限、所有者、组、大小(以字节为单位)、修改时间和文件名。</figcaption></figure><p id="1c1b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ks">一件重要的事情！</em>shell将您在命令行上写的单词或字符作为参数，从0到您想写的任何内容。要知道参数0 arg[0]意味着什么:它是一个命令，并且必须是<strong class="js iu">可执行的</strong>。</p><p id="7422" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，在提示符下写下<strong class="js iu"> ls -l </strong>之后，一按enter键，shell就会使用一个名为getline()的函数读取这些内容，并将命令行解析成将要发送给执行程序的参数。shell检查命令是否是别名，用它的值替换它，如果不是，检查命令arg[0]，看它是否是内置的<strong class="js iu"/>。</p><p id="c192" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">别名</strong>是引用命令的快捷方式，用于避免键入长命令。而<strong class="js iu">内置的</strong>命令是包含在外壳本身中的命令。)</p><p id="1140" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了执行(实际上是从shell启动的另一个程序), shell需要知道命令的位置以及它是否可执行。我们的命令在文件夹<strong class="js iu"> bin </strong>中，位于系统的<strong class="js iu">根目录</strong>下。您可以使用命令<em class="ks">检查任何命令的位置，该命令</em>:</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi ob"><img src="../Images/33b47bdc52a196e24f4a552a86868f37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZHUxwXm3bsG8wGucUZ1ioA.png"/></div></div><figcaption class="nw nx gj gh gi ny nz bd b be z dk translated">要获得更多关于哪个的信息，请参考哪个手册。</figcaption></figure><p id="63cf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">shell现在通过环境变量$PATH知道程序在它的环境中沿着路径(<strong class="js iu"> /bin/ls </strong>，'/'表示根目录)在哪里，这个环境变量包含一个目录列表，每次输入一个命令都会在这个目录中搜索这个命令。这个变量用“=”分隔，它包含的目录用“:”作为彗差进行解析。使用<em class="ks"> env </em>命令列出所有环境变量，并回显PATH以查看该变量的具体内容，如下所示:</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi oa"><img src="../Images/60d5993126324a37b210619928feb977.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-FBMujaP20P6ZlrVemSmOQ.png"/></div></div><figcaption class="nw nx gj gh gi ny nz bd b be z dk translated">env包含$PATH变量，因为我们只关心$PATH，所以我们使用命令echo来查看它包含了什么。</figcaption></figure><p id="0930" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请记住，shell只搜索在$PATH上找到的目录，它包含该目录的绝对路径<strong class="js iu">而不是当前工作目录。此外，您可以使用命令的绝对路径(/bin/ls)和命令选项，您将获得与<em class="ks"> ls </em>描述中所示相同的输出！：</strong></p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi nv"><img src="../Images/e752c30c10d8c575272f9ca366ae5130.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nPjI9pj-Jjy06_dAvO_pSw.png"/></div></div></figure><h1 id="569c" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><strong class="ak">越陷越深</strong></h1><p id="b1e2" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi mi translated"><span class="l mj mk ml bm mm mn mo mp mq di">此时</span>shell确切知道ls命令是可执行的，并且位于哪里。接下来，必须完成执行部分。为此，需要完成三个系统调用。</p><ul class=""><li id="865f" class="mr ms it js b jt ju jx jy kb mt kf mu kj mv kn mw mx my mz bi translated">叉子()</li></ul><p id="949a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">还记得运行一个命令是在另一个进程(Shell，parent)上启动一个进程(ls，child)吗？多亏了<em class="ks"> fork() </em>，它通过复制<strong class="js iu">父</strong>流程创建了一个<strong class="js iu">子</strong>流程。在系统调用之后，两个进程都将执行下面的指令。</p><p id="2c64" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">子进程和父进程在不同的内存空间中运行。shell上的所有进程都有自己的进程ID ( <em class="ks"> pid </em>)。<em class="ks"> fork() </em>的返回值有:</p><p id="e2f2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ks">负值</em>:如果子进程创建不成功。<br/> <em class="ks">归零</em>:返回已创建的子流程。<br/> <em class="ks">正值</em>:返回父进程。该值包含子进程ID。</p><p id="c27c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面是fork()的概要:</p><pre class="ku kv kw kx gt nb kr nc nd aw ne bi"><span id="83d4" class="nf lg it kr b gy ng nh l ni nj"><strong class="kr iu">#include &lt;sys/types.h&gt;</strong><br/><strong class="kr iu">#include &lt;unistd.h&gt;</strong><br/><br/>       <strong class="kr iu">pid_t fork(void);</strong></span></pre><ul class=""><li id="d675" class="mr ms it js b jt ju jx jy kb mt kf mu kj mv kn mw mx my mz bi translated">execve()</li></ul><p id="7a45" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们有了一个子流程，系统需要关注这个子流程。execve()系统调用通过停止父进程来执行路径名引用的程序，在本例中为<em class="ks"> ls，</em>，并用新程序替换它，包括新初始化的堆栈、堆和数据段。</p><p id="0163" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面是execve()的概要:</p><pre class="ku kv kw kx gt nb kr nc nd aw ne bi"><span id="6c9d" class="nf lg it kr b gy ng nh l ni nj"><strong class="kr iu">#include &lt;unistd.h&gt;</strong><br/><br/><strong class="kr iu">int execve(const char *</strong><em class="ks">pathname</em><strong class="kr iu">, char *const </strong><em class="ks">argv</em><strong class="kr iu">[],</strong><br/>           <strong class="kr iu">char *const </strong><em class="ks">envp</em><strong class="kr iu">[]);</strong></span></pre><p id="d281" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要执行的程序是<em class="ks"> pathname，argv </em>是作为命令行参数传递给新程序的字符串指针数组，<em class="ks"> envp </em>是作为新程序环境传递的字符串指针数组。envp 数组必须以空指针结束</p><ul class=""><li id="bda0" class="mr ms it js b jt ju jx jy kb mt kf mu kj mv kn mw mx my mz bi translated">等待()</li></ul><p id="d1f6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可能想知道在执行子进程时父进程发生了什么。嗯，系统调用wait()用于等待父进程的子进程的状态变化，并获取关于该子进程的信息。</p><blockquote class="oc od oe"><p id="123d" class="jq jr ks js b jt ju jv jw jx jy jz ka of kc kd ke og kg kh ki oh kk kl km kn im bi translated">状态改变被认为是:子终止；这个孩子被一个信号拦住了；或者孩子被一个信号恢复了。在终止孩子的情况下，执行等待允许系统释放与孩子相关联的资源；如果不执行等待，那么被终止的子进程将保持“僵死”状态。<br/><strong class="js iu">wait</strong>()系统调用挂起调用线程的执行，直到它的一个子线程终止。</p></blockquote><p id="18b1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面是wait()的概要:</p><pre class="ku kv kw kx gt nb kr nc nd aw ne bi"><span id="3195" class="nf lg it kr b gy ng nh l ni nj"><strong class="kr iu">#include &lt;sys/types.h&gt;</strong><br/><strong class="kr iu">#include &lt;sys/wait.h&gt;</strong><br/><br/>       <strong class="kr iu">pid_t wait(int *</strong><em class="ks">wstatus</em><strong class="kr iu">);</strong></span></pre><h2 id="58f2" class="nf lg it bd lh nk nl dn ll nm nn dp lp kb no np lt kf nq nr lx kj ns nt mb nu bi translated">所以…真正的问题是:当你在一个shell中键入<em class="oi"> ls -l </em>并点击<em class="oi"> Enter </em>会发生什么？</h2><p id="69f9" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi mi translated">好吧，当提示符需要一个命令' $ '时，你键入<em class="ks"> ls -l </em>，然后在$PATH环境变量中搜索程序。之后进行上面提到的系统调用:父进程，shell本身，被复制到一个子进程(<em class="ks"> fork() </em>)，我们要运行的程序。这个程序的执行是由<em class="ks"> execve() </em>完成的，而父进程等待它改变状态(<em class="ks"> wait() </em>)。</p><p id="9d4a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当程序被执行时(并且如果程序实际存在于环境中；如果没有，你将得到一个错误:命令没有找到)输出将被显示，使用的内存将被释放，提示符将再次等待下一个命令被执行。</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/9a7047c616dd72fa772787902732af0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:396/format:webp/1*jvYYKDJ5mA7q22nZUp1pDA.png"/></div></figure><h2 id="406a" class="nf lg it bd lh nk nl dn ll nm nn dp lp kb no np lt kf nq nr lx kj ns nt mb nu bi translated">太多了！</h2><p id="e4aa" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">是的，它是。然而，当您在shell上写了一个命令后按Enter键时，您会惊奇地发现正在发生什么。你越了解事物的运作方式，它们就越有趣！</p><h2 id="c585" class="nf lg it bd lh nk nl dn ll nm nn dp lp kb no np lt kf nq nr lx kj ns nt mb nu bi translated">贡献者:</h2><ul class=""><li id="7a81" class="mr ms it js b jt md jx me kb ok kf ol kj om kn mw mx my mz bi translated">圣地亚哥·门迭塔、马努埃尔·托雷斯和法比奥·古铁雷斯。</li></ul></div></div>    
</body>
</html>