<html>
<head>
<title>Code Review: How the AllenNLP Vocabulary indexes your text</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">代码审查:AllenNLP词汇如何索引你的文本</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/code-review-how-the-allennlp-vocabulary-indexes-your-text-167f5586789f?source=collection_archive---------14-----------------------#2022-06-12">https://levelup.gitconnected.com/code-review-how-the-allennlp-vocabulary-indexes-your-text-167f5586789f?source=collection_archive---------14-----------------------#2022-06-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/c09bcc3abd814fca55d07e558b947344.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*7rlpEZwtT8cQMFfn.jpg"/></div></div></figure><p id="a020" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">尽管AllenNLP为库中几乎所有的模块提供了很好的指南，但我仍然在许多方面对词汇表是如何构造的感到困惑。具体来说，我们回答以下问题/讨论。</p><ul class=""><li id="06d9" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">构造:token/id对如何添加到<code class="fe lf lg lh li b">Vocabulary</code>中？</li><li id="5bef" class="kw kx iq ka b kb lj kf lk kj ll kn lm kr ln kv lb lc ld le bi translated">用于文本字段:词汇是如何用于文本索引的？</li><li id="c233" class="kw kx iq ka b kb lj kf lk kj ll kn lm kr ln kv lb lc ld le bi translated"><code class="fe lf lg lh li b">Vocabulary</code>用于标签索引？</li><li id="be02" class="kw kx iq ka b kb lj kf lk kj ll kn lm kr ln kv lb lc ld le bi translated">有什么警告吗</li></ul></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h2 id="8591" class="lv lw iq bd lx ly lz dn ma mb mc dp md kj me mf mg kn mh mi mj kr mk ml mm mn bi translated">第1节:如何将令牌/id对添加到<code class="fe lf lg lh li b">Vocabulary</code>？</h2><p id="2311" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated"><strong class="ka ir"> From instances </strong>:正常情况下，<code class="fe lf lg lh li b">from_instance</code>方法可以构造一个<code class="fe lf lg lh li b">counter: Dict[<em class="mt">str</em>, Dict[<em class="mt">str</em>, <em class="mt">int</em>]]</code>,其中外部键是为每个名称空间保留的，内部字典存储token/id对。<code class="fe lf lg lh li b">counter</code>将被<code class="fe lf lg lh li b">_extend</code>方法进一步分解为<code class="fe lf lg lh li b">self._token_to_index</code>和<code class="fe lf lg lh li b">self._index_to_token</code>属性。<br/>具体来说，它调用每一个<code class="fe lf lg lh li b">Instance</code>对象的<code class="fe lf lg lh li b">count_vocab_items</code>，它又调用每一个<code class="fe lf lg lh li b">Field</code>对象的<code class="fe lf lg lh li b">count_vocab_items</code>，每一个<code class="fe lf lg lh li b">Field</code>对象又调用每一个<code class="fe lf lg lh li b">TokenIndexer</code>对象的<code class="fe lf lg lh li b">count_vocab_items</code>。因此，计数项目的功能代码确实在每个<code class="fe lf lg lh li b">TokenIndexer</code>对象中。<code class="fe lf lg lh li b">TokenIndexer</code>中的这个<code class="fe lf lg lh li b">count_vocab_items</code>将匹配名称空间和<code class="fe lf lg lh li b">counter</code>的外部键名，以扩展条目或增加条目数。下面是<code class="fe lf lg lh li b">SingleIdTokenIndexer</code>中的代码。</p><pre class="mu mv mw mx gt my li mz na aw nb bi"><span id="5b36" class="lv lw iq li b gy nc nd l ne nf">def count_vocab_items(self, token: Token, counter: Dict[str,   <br/>Dict[str, int]]):<br/>        if self.namespace is not None:<br/>            text = self._get_feature_value(token)<br/>            if self.lowercase_tokens:<br/>                text = text.lower()<br/>            counter[self.namespace][text] += 1</span></pre><h2 id="c308" class="lv lw iq bd lx ly lz dn ma mb mc dp md kj me mf mg kn mh mi mj kr mk ml mm mn bi translated">第2部分:如何为文本索引消耗词汇？</h2><p id="e1e2" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated"><code class="fe lf lg lh li b">Vocabulary</code>将与<code class="fe lf lg lh li b">TokenIndexer</code>协作来索引<code class="fe lf lg lh li b">Field</code>对象中的令牌。具体来说，<code class="fe lf lg lh li b">TokenIndexer.tokens_to_indices</code>方法将采用一个词汇对象作为参数来匹配名称空间和索引标记。</p><p id="d68d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如上，功能代码其实在<code class="fe lf lg lh li b">TokenIndexer</code>里。下面是<code class="fe lf lg lh li b">SingleIdTokenIndexer</code>中的代码。</p><pre class="mu mv mw mx gt my li mz na aw nb bi"><span id="32ef" class="lv lw iq li b gy nc nd l ne nf">def tokens_to_indices(<br/>        self, tokens: List[Token], vocabulary: Vocabulary<br/>    ) -&gt; Dict[str, List[int]]:<br/>        indices: List[int] = []<br/>    for token in itertools.chain(self._start_tokens, tokens, self._end_tokens):<br/>            text = self._get_feature_value(token)<br/>            if self.namespace is None:<br/>                indices.append(text)  # type: ignore<br/>            else:<br/>                if self.lowercase_tokens:<br/>                    text = text.lower()<br/>                indices.append(vocabulary.get_token_index(text,   self.namespace))</span><span id="815d" class="lv lw iq li b gy ng nd l ne nf">    return {"tokens": indices}</span></pre><p id="5e81" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe lf lg lh li b">tokens_to_indices</code>方法就是<code class="fe lf lg lh li b">Textfield.index</code>方法，如下所示。注意下一节讨论的<code class="fe lf lg lh li b">Textfield.index</code>和<code class="fe lf lg lh li b">LabelField.index</code>的区别。</p><pre class="mu mv mw mx gt my li mz na aw nb bi"><span id="76a7" class="lv lw iq li b gy nc nd l ne nf">def index(self, vocab: Vocabulary):<br/>        self._indexed_tokens = {}<br/>        for indexer_name, indexer in self.token_indexers.items():<br/>            self._indexed_tokens[indexer_name] = indexer.tokens_to_indices(self.tokens, vocab)</span></pre><h2 id="dd56" class="lv lw iq bd lx ly lz dn ma mb mc dp md kj me mf mg kn mh mi mj kr mk ml mm mn bi translated">第3节:标签索引词汇</h2><p id="dd52" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated">它在构造和使用上都不同于文本索引。</p><ul class=""><li id="e19d" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">构造期间没有为填充和未知令牌保留id</li><li id="2396" class="kw kx iq ka b kb lj kf lk kj ll kn lm kr ln kv lb lc ld le bi translated">没有<code class="fe lf lg lh li b">TokenIndexder</code>:<code class="fe lf lg lh li b">LabelField</code>本身包含名称空间(通常硬编码为“labels”)来从标记到索引字典(即<code class="fe lf lg lh li b">Vocabulary._token_to_index[“labels”]</code>)中提取标签索引，如下面的<code class="fe lf lg lh li b">LabelField</code>中的代码所示。</li></ul><pre class="mu mv mw mx gt my li mz na aw nb bi"><span id="3357" class="lv lw iq li b gy nc nd l ne nf">def index(self, vocab: Vocabulary):<br/>        if not self._skip_indexing:<br/>            self._label_id = vocab.get_token_index(<br/>                self.label, self._label_namespace  # type: ignore<br/>            )</span></pre><h2 id="8853" class="lv lw iq bd lx ly lz dn ma mb mc dp md kj me mf mg kn mh mi mj kr mk ml mm mn bi translated">第4部分:注意事项</h2><p id="ccae" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated"><strong class="ka ir">忘记将</strong> <code class="fe lf lg lh li b"><strong class="ka ir">TokenIndexer</strong></code> <strong class="ka ir">应用到</strong> <code class="fe lf lg lh li b"><strong class="ka ir">TextField</strong></code>:这是我们用AllenNLP处理数据时最常犯的错误之一，因为逻辑上词汇表中的token/id映射对于索引<code class="fe lf lg lh li b">TextField</code>中的token就足够了。但是，我们需要<code class="fe lf lg lh li b">TokenIndexer</code>的原因有很多。</p><ul class=""><li id="8095" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">一个常见的原因是添加特殊标记(开始或结束标记)</li><li id="4181" class="kw kx iq ka b kb lj kf lk kj ll kn lm kr ln kv lb lc ld le bi translated">另一个原因是<code class="fe lf lg lh li b">Textfield</code>中的token可能与词汇表中token/id映射的粒度不匹配。例如，我们将文本标记成单词，但是词汇表包含字符的标记/id映射。这听起来有些奇怪:如果我们想在字符级别上索引文本，为什么要将文本标记为单词而不是字符。据我所知，我猜想结合单词索引(使用<code class="fe lf lg lh li b">SingleIdTokenIndexer</code>)和字符索引(<code class="fe lf lg lh li b">TokenCharacterIndexer</code>)对我们有好处。</li></ul><p id="64b4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以，记得应用<code class="fe lf lg lh li b">TokenIndexer</code>。下面是在一个文本字段中同时使用单词索引和字符索引的代码。</p><pre class="mu mv mw mx gt my li mz na aw nb bi"><span id="a93b" class="lv lw iq li b gy nc nd l ne nf">text_field.token_indexers={<br/>"tokens":<br/>   SingleIdTokenIndexer(namespace="token_vocab"),</span><span id="7c46" class="lv lw iq li b gy ng nd l ne nf">"token_characters":<br/>   TokenCharactersIndexer(namespace="character_vocab"),</span><span id="43ea" class="lv lw iq li b gy ng nd l ne nf">}</span></pre></div></div>    
</body>
</html>