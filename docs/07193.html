<html>
<head>
<title>Three Use Cases of the Facade Design Pattern in Enterprise Applications</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">企业应用程序中外观设计模式的三个用例</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/3-main-use-cases-of-the-facade-design-pattern-in-enterprise-applications-aa9b290adac6?source=collection_archive---------5-----------------------#2021-01-31">https://levelup.gitconnected.com/3-main-use-cases-of-the-facade-design-pattern-in-enterprise-applications-aa9b290adac6?source=collection_archive---------5-----------------------#2021-01-31</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="fe01" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">优雅地处理代码复杂性</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f6b15c5d2cd3679b348ff98519114c57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*295X5hZFQKfMCRvw"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ky" href="https://unsplash.com/@matthaeus123?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> matthaeus </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="a283" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">facade设计模式通过单个接口公开一个或多个组件(类、模块、微服务)。</p><p id="de26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">门面设计模式最常用于企业应用程序，因为它确实有助于处理其复杂性，并且该模式易于实现。我在企业应用程序中见过facade模式的各种用例，并描述了三种最常见的用例。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f1b7" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">1.从库中分离应用程序代码</h1><p id="4242" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">第三方库是提供一些可重用功能的一组类。在将库包含在项目中之后，开发人员可以将这些类直接注入到应用程序代码中。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/8d241c70b735dfc4523dd4fb62d66d17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*9MM1k8UM1pJu4J7mqNuhYg.png"/></div></figure><p id="8293" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然而，直接引用库并不总是一个好的解决方案，因为应用程序代码与库紧密耦合，甚至与库的特定版本紧密耦合。一个应用程序越频繁地使用一个库，就越难用同一个库的另一个或更新的版本来替换它。这是因为开发人员需要在应用程序的许多地方小心地用新库替换旧库的用法。</p><p id="0bb0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了将应用程序代码与第三方库分离，开发人员可以在它们之间放置一个外观:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/371af8b68745b6a1b6f1acc2b6bdf761.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*WV2VyXho95s3reqLJki9Uw.png"/></div></figure><p id="cac4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个特定用例的外观实现将非常简单。facade对象只是库的包装器。包装类只是将应用程序的调用重定向到库代码。</p><p id="9e81" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当需要用新的库替换特定的库时，开发人员应该只专注于重写facade对象内部的代码。不需要像以前一样重构应用程序的许多部分。</p><p id="272e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">注意，即使有了facade，也有一种方法可以直接从应用程序代码中使用这个库:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/0b3bf2bcdc7fddc5661d926cbe3982bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*qGTzMtcsX7wwioABb19lKA.png"/></div></figure><p id="72df" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当开发人员开始使用“Facade over Library”模式时，限制应用程序代码直接使用库总是好的。幸运的是，这很容易实现:</p><ul class=""><li id="0c1f" class="na nb it lb b lc ld lf lg li nc lm nd lq ne lu nf ng nh ni bi translated">在您的应用程序中创建一个单独的项目，并将外观放入其中。</li><li id="d790" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">将带有立面的项目中的引用添加到第三方库中。</li><li id="dbac" class="na nb it lb b lc nj lf nk li nl lm nm lq nn lu nf ng nh ni bi translated">将应用程序中的引用添加到只有立面的项目中。</li></ul><p id="c3b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">facade的强大之处在于，开发人员可以在项目中为每个库或同一库的每个版本保留一个facade。如果需要经常在项目中的库之间切换，开发人员应该在IoC容器中注册新的facade实现。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="1536" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">2.在新应用中重用遗留代码</h1><p id="3000" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">遗留应用程序应该用新的特性来扩展，以反映业务需求。这些新特性可以直接在遗留代码中实现。然而，只有这些遗留代码的作者能够给出现实的估计，并且不会在每次修改后引入许多错误。</p><p id="1aaa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果团队是新的，他们可以从头开始重写遗留应用程序，然后开始实现新功能。然而，这对客户来说是相当昂贵的，他们可能不准备等几个月或几年来重写。</p><p id="97db" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个更合理的方法是在单独的模块中开始实现新特性，然后像这样重用遗留代码:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mz"><img src="../Images/3057ce5f15faec1f2ecff4330455a3dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*HmpX_La0LJSxLzLEsrz2cQ.png"/></div></div></figure><p id="e75f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">虽然这是一种可行的方法，但是系统的新部分将与遗留代码紧密耦合。</p><p id="fbbe" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了避免与遗留代码的紧密耦合，开发人员可以通过一组外观来公开遗留应用程序的功能。新系统不应该有任何对遗留代码的引用。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/7598f29fa521ee479964c23019a65153.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*ApmqKwu2iQmrj990j2fT6A.png"/></div></figure><p id="f37f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通常，外观封装了遗留应用程序组件之间的复杂交互，并简化了它们的接口。这意味着新代码不知道遗留代码的复杂性，因此更容易维护。</p><p id="6c26" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">请注意，立面可以是一个单独项目的一部分。新代码只能引用一个具有外观的项目，因此没有人会意外地直接使用遗留代码。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="91e9" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">3.修复接口分离原则冲突</h1><p id="4477" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">一些类或库可以封装复杂的功能，包括许多需要不同客户端(其他类)使用的方法和属性。然而，不同的客户有不同的目标。第一个客户端可能只需要5%的功能，第二个客户端需要大约50%。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/e7a61cb46354bd7041cd654a0f4e293a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*1fDl2Mb_9CwHCelq8bRc3g.png"/></div></figure><p id="e69a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">很明显，“复杂类”违反了接口分离原则，因此<strong class="lb iu">复杂类很难被正确使用，并且很容易被客户误用</strong>。</p><p id="d27c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">开发人员可能试图将一个复杂的类分成几个更小的类，但是当复杂的类是开发人员无权访问的单独库的一部分时，这是不可能的。</p><p id="30c2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">即使开发人员可以访问库代码，该库也可能已经被许多客户端主动使用(这意味着重构库代码将需要重构所有客户端)。</p><p id="9f58" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">即使复杂类是当前项目的一部分，它也可能是应用程序的遗留部分，因此重构会导致回归问题。</p><p id="db63" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">开发人员可以通过为每个客户端编写单独的外观来解决这个问题。第一个外观将只展示5%的功能，而第二个将展示50%的功能。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/c8835038b2c087d2b95f3a92fbe0a26b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*glh3KFrWdLhSJ3i145FSig.png"/></div></figure><p id="991f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">新客户可以简单地多次重用现有的外观，因此每个客户不必一遍又一遍地困惑如何正确使用复杂的类。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="546c" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">结论</h1><p id="5210" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">外观只是应用程序中一个额外的抽象层。抽象允许开发人员实现松散耦合，提高代码重用，简化复杂的接口，并对客户隐藏实现细节。另一方面，抽象增加了应用程序的复杂性，复杂的抽象甚至会降低性能。因此，像往常一样，尽管facade设计模式具有明显的优势并且易于实现，但开发人员应该在使用它之前分析利弊。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="566b" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">更多设计模式</h1><div class="no np gp gr nq nr"><a rel="noopener  ugc nofollow" target="_blank" href="/5-ways-to-implement-the-singleton-design-anti-pattern-in-c-68bb664c31f2"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd iu gy z fp nw fr fs nx fu fw is bi translated">在C#中实现单例设计反模式的5种方法</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">各有利弊</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="oa l"><div class="ob l oc od oe oa of ks nr"/></div></div></a></div><div class="no np gp gr nq nr"><a rel="noopener  ugc nofollow" target="_blank" href="/the-state-design-pattern-to-implement-likes-and-dislikes-958389b379ff"><div class="ns ab fo"><div class="nt ab nu cl cj nv"><h2 class="bd iu gy z fp nw fr fs nx fu fw is bi translated">实现好恶的状态设计模式</h2><div class="ny l"><h3 class="bd b gy z fp nw fr fs nx fu fw dk translated">从需求引出开始</h3></div><div class="nz l"><p class="bd b dl z fp nw fr fs nx fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="oa l"><div class="og l oc od oe oa of ks nr"/></div></div></a></div></div></div>    
</body>
</html>