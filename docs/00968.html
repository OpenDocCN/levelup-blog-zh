<html>
<head>
<title>Manage Child Goroutines Like a Boss With context.Context</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">像老板一样管理孩子的日常事务。语境</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-use-context-to-manage-your-goroutines-like-a-boss-ef1e478919e6?source=collection_archive---------0-----------------------#2019-10-03">https://levelup.gitconnected.com/how-to-use-context-to-manage-your-goroutines-like-a-boss-ef1e478919e6?source=collection_archive---------0-----------------------#2019-10-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/90a108bc93c82da65d52ac87ef9b5271.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CdjOgfolLt_GNJYBzI-1QQ.jpeg"/></div></div></figure><h2 id="c40f" class="iz ja jb bd b dl jc jd je jf jg jh dk ji translated" aria-label="kicker paragraph">牛逼围棋— #2</h2><div class=""/><p id="fd5f" class="pw-post-body-paragraph kh ki jb kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">如果你曾经使用过Go，你可能会意识到它内置的现代并发编程模型是Go最好的特性之一，并使它从其他编程语言中脱颖而出。在Go at glance中编写并发代码看起来非常容易，只需:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="2114" class="lo lp jb lk b gy lq lr l ls lt"><strong class="lk jl">go</strong> task1()<br/><strong class="lk jl">go</strong> task2()</span></pre><p id="03b6" class="pw-post-body-paragraph kh ki jb kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">然后你有你的主goroutine，<code class="fe lu lv lw lk b">task1</code>和<code class="fe lu lv lw lk b">task2</code>并发运行，你根本不用关心线程。Go将尽力为您有效利用资源。</p><p id="81ae" class="pw-post-body-paragraph kh ki jb kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">同步也很容易。使用通道编程模型，只需通过通道进行通信(交换消息)即可。您的goroutines将无缝同步，这被称为“<strong class="kj jl">不要让计算通过共享内存进行通信，让它们通过通道</strong>进行通信来共享内存”。</p><p id="26a8" class="pw-post-body-paragraph kh ki jb kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">然而，当涉及到管理多个goroutines时，Go不再支持开箱即用的一切。当您的主goroutine退出时，其他go routine会继续运行，您负责清理它们。Go内置了包<code class="fe lu lv lw lk b">context</code>和<code class="fe lu lv lw lk b">sync</code>来与管理goroutines的通道进行交互，但是要实现这样的用例，还需要一点研究和理解。</p></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><h1 id="9348" class="me lp jb bd mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na bi translated">语境。语境</h1><p id="7d10" class="pw-post-body-paragraph kh ki jb kj b kk nb km kn ko nc kq kr ks nd ku kv kw ne ky kz la nf lc ld le ij bi translated">正如官方Go文档中所描述的，<code class="fe lu lv lw lk b">context.Context</code>携带截止日期、取消信号和其他跨边界和跨进程的范围值。</p><h2 id="9f3c" class="lo lp jb bd mf ng nh dn mj ni nj dp mn ks nk nl mr kw nm nn mv la no np mz jh bi translated">基本用法</h2><p id="30f0" class="pw-post-body-paragraph kh ki jb kj b kk nb km kn ko nc kq kr ks nd ku kv kw ne ky kz la nf lc ld le ij bi translated">上下文表示附加goroutines的范围或生存期。当您看到如下所示的函数签名时:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="6fe7" class="lo lp jb lk b gy lq lr l ls lt"><em class="nq">// Task is a function that can be and should be run as goroutine,<br/>// it can be cancelled by cancelling the input context.</em><br/><strong class="lk jl">func</strong> Task(context.Context, ...args interface{})</span></pre><p id="7804" class="pw-post-body-paragraph kh ki jb kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">这意味着您可以使用如下功能:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="445f" class="lo lp jb lk b gy lq lr l ls lt"><strong class="lk jl">func</strong> main() {<br/>    <em class="nq">// Create a new context being cancelled in 5 seconds.</em><br/>    ctx, _ := context.WithTimeout(context.Background(), 5 * time.Second)</span><span id="f92d" class="lo lp jb lk b gy nr lr l ls lt">    <em class="nq">// Start a new goroutine whose lifetime's attached to ctx.</em><br/>    <strong class="lk jl">go</strong> task(ctx, args...)<br/>}</span></pre><p id="3845" class="pw-post-body-paragraph kh ki jb kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">上面的代码意味着如果<code class="fe lu lv lw lk b">task</code>功能持续超过5秒，它将被取消，这有助于避免泄漏goroutines。</p><p id="98ab" class="pw-post-body-paragraph kh ki jb kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">您应该按照上面显示的方式设计自己的API。当您有一些长期运行的函数时，可以考虑将它们的生存期附加到上下文中。</p><h2 id="61f8" class="lo lp jb bd mf ng nh dn mj ni nj dp mn ks nk nl mr kw nm nn mv la no np mz jh bi translated">创建和派生上下文</h2><p id="11a5" class="pw-post-body-paragraph kh ki jb kj b kk nb km kn ko nc kq kr ks nd ku kv kw ne ky kz la nf lc ld le ij bi translated">要创建新的空上下文，请使用:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="0d28" class="lo lp jb lk b gy lq lr l ls lt"><em class="nq">// Create a new, empty, and unexecuted context.</em><br/>context.Background()</span></pre><p id="bce7" class="pw-post-body-paragraph kh ki jb kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">可以导出上下文，一旦父上下文完成，子上下文也就完成了。</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="527f" class="lo lp jb lk b gy lq lr l ls lt"><strong class="lk jl">func</strong> main() {<em class="nq"><br/>    // Create a new context.</em><br/>    parent, cancelParent := context.WithCancel(context.Background())</span><span id="b074" class="lo lp jb lk b gy nr lr l ls lt"><em class="nq">    // Derive child contexts from parent.</em><br/>    childA, _ := context.WithTimeout(parent, 5 * time.Secound)<br/>    childB, _ := context.WithDeadline(parent, time.Now().Add(1 * time.Minute)</span><span id="da4b" class="lo lp jb lk b gy nr lr l ls lt">    <strong class="lk jl">go</strong> func() {<br/>        &lt;-childA.Done()<br/>        &lt;-childB.Done()<br/>        fmt.Println("All children are done")<br/>    }()</span><span id="c63d" class="lo lp jb lk b gy nr lr l ls lt"><em class="nq">    // Cancel parent make all children are cancelled.</em><br/>    cancelParent()<br/>}</span><span id="97cc" class="lo lp jb lk b gy nr lr l ls lt"><em class="nq">// -&gt; Result: All children are done</em></span></pre><ul class=""><li id="15a2" class="ns nt jb kj b kk kl ko kp ks nu kw nv la nw le nx ny nz oa bi translated"><code class="fe lu lv lw lk b">context.WithCancel(parentContext)</code>创建一个新的上下文，该上下文在调用返回的cancel函数时或父上下文结束时完成，以先发生的为准。</li><li id="799b" class="ns nt jb kj b kk ob ko oc ks od kw oe la of le nx ny nz oa bi translated"><code class="fe lu lv lw lk b">context.WithTimeout(contextContext, 5 * time.Second)</code>创建一个新的上下文，该上下文在调用返回的取消函数、超时或父上下文结束时结束，以先发生的为准。</li><li id="2f2a" class="ns nt jb kj b kk ob ko oc ks od kw oe la of le nx ny nz oa bi translated"><code class="fe lu lv lw lk b">context.WithDeadline(parentContext, time.Now().Add(1 * time.Minute)</code>创建一个新的上下文，该上下文在返回的取消函数截止时间到期时或父上下文完成时结束，以先发生者为准。</li></ul><p id="c402" class="pw-post-body-paragraph kh ki jb kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">还有其他一些方法来推导上下文。点击查看<a class="ae og" href="https://golang.org/pkg/context/#example_WithCancel" rel="noopener ugc nofollow" target="_blank">了解更多详情。</a></p></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><h1 id="a7cf" class="me lp jb bd mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na bi translated">管理子Goroutines</h1><p id="99c2" class="pw-post-body-paragraph kh ki jb kj b kk nb km kn ko nc kq kr ks nd ku kv kw ne ky kz la nf lc ld le ij bi translated">现在让我们用<code class="fe lu lv lw lk b">context.Context</code>解决一个现实世界中常见的问题。</p><p id="683b" class="pw-post-body-paragraph kh ki jb kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">以下是并发编程中一个非常常见的用例:</p><blockquote class="oh oi oj"><p id="d4ef" class="kh ki nq kj b kk kl km kn ko kp kq kr ok kt ku kv ol kx ky kz om lb lc ld le ij bi translated">“您有两个任务A和b。您的主goroutine分支N个goroutine(workers)运行任务A，M个go routine(workers)运行任务b。当您的主go routine完成时(例如，用户请求关闭应用程序)，您如何优雅地关闭所有子任务？”</p></blockquote><figure class="lf lg lh li gt is"><div class="bz fp l di"><div class="on oo l"/></div></figure></div></div>    
</body>
</html>