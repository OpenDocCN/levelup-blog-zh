<html>
<head>
<title>Write automated tests at three levels</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在三个层次上编写自动化测试</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/write-tests-at-three-levels-909561a9544b?source=collection_archive---------3-----------------------#2019-10-19">https://levelup.gitconnected.com/write-tests-at-three-levels-909561a9544b?source=collection_archive---------3-----------------------#2019-10-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/884eb5c41eb09f07f19b3c2c58aa9e18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oexwS7O_X6zT6UMxRPs6HA.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">图片来源:<a class="ae kf" href="http://pluspng.com/three-bears-png-9172.html" rel="noopener ugc nofollow" target="_blank">艾丽莎·斯科特</a></figcaption></figure><p id="cb6a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当然，测试的种类几乎和错误的分类一样多。然而，我发现在开发新功能时，特别关注三种类型是很有用的:</p><ul class=""><li id="568d" class="le lf it ki b kj kk kn ko kr lg kv lh kz li ld lj lk ll lm bi translated">单元测试</li><li id="3f09" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">组件测试</li><li id="21f4" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">验收测试</li></ul><p id="c987" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">考虑到IT世界的多样性和快节奏，这三个测试类别获得了许多同义词，每一个都有略微不同的侧重点，并且每个类别之间的界限通常很模糊。</p><p id="5bf0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是通过一个简单的介绍:</p><ul class=""><li id="eaec" class="le lf it ki b kj kk kn ko kr lg kv lh kz li ld lj lk ll lm bi translated">单元测试是由开发人员在编码时编写的。这些测试往往是非常细粒度的——一个测试覆盖一个单一的功能或者类，基本上是一个功能单元或者(换句话说)一个单一的职责。</li><li id="2c92" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">组件测试也是由开发人员在编码时编写的。这些测试比单元测试粒度更广——每个测试覆盖更多的代码，通常是一组密切相关的类。</li><li id="aa6a" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">验收测试由BAs指定，或者由与BAs直接接触的软件测试人员指定。这些是端到端的测试，覆盖了可能从系统的一端(例如REST端点)运行到另一端(可能是数据库查询)并返回的部分功能。</li></ul><p id="434f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，有三种类型的测试，每一种都在不同的水平或范围上运行。</p><p id="9057" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是为什么要特别测试这三个级别呢？你可能会问，它们之间是否有太多的交叉，也就是重复的工作？</p><p id="5d79" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">答案是它们各自提供了不同的好处，并且很好地相互补充。重复往往比你想象的要少得多，因为他们在测试不同的东西。</p><figure class="lt lu lv lw gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ls"><img src="../Images/89ee108136a2bc285050d483bf23d477.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jP8Y1j0ZYNfg0ym7"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@brisch27?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">布里吉塔·施奈特</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="13f2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">将单元测试想象成一根钓鱼竿——精确的，瞄准特定的水域，设计用来钓一条鱼。相比之下，验收测试就是一张拖网。它将捕获数百条鱼，包括一些可能意想不到的“奖品”，尽管许多较小的鱼会穿过网，甚至不会被注意到。组件测试是“中间”尺寸，可能就像毛伊岛渔民在海浪中撒下的手持网。这是有针对性的，但仍然会捕捉到相当数量的鱼，而且网足够小，可以捕捉到否则会蜿蜒而过的小鱼。</p><p id="81f8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是这个牵强的比喻已经说得够多了…让我们更深入地看看每一级别的测试是如何提供它自己的好处的。</p><h1 id="da61" class="lx ly it bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">为什么要编写单元测试？</h1><p id="1261" class="pw-post-body-paragraph kg kh it ki b kj mv kl km kn mw kp kq kr mx kt ku kv my kx ky kz mz lb lc ld im bi translated">以下是一些在“单元”级别编写测试的好理由:</p><ul class=""><li id="41fe" class="le lf it ki b kj kk kn ko kr lg kv lh kz li ld lj lk ll lm bi translated">为了防止被测试的单个单元中的错误</li><li id="e103" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">根据它的接口(即基于契约的测试)，显示你正在编写的函数/方法按预期工作</li><li id="5e2f" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">更好地理解设计，并在一定程度上推动设计</li><li id="3a26" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">质疑法典</li></ul><p id="0f32" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以，相当重要！然而，您会注意到，所有这三个好处都发生在您编写单元测试所针对的代码的时候。单元测试确实为设计提供了反馈——有了编码，你现在就在采煤工作面，发现什么是可能的，什么是不可能的。然而，一些单元测试的“效用窗口”很快就过去了，它们可以很快从资产变成负债。</p><p id="2e39" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">将单元测试作为一种总括形式的回归测试是很诱人的。然而(回想一下钓鱼竿的比喻)，这真的不是他们的强项:事实上，他们在回归测试方面有点糟糕。他们撒的网不够宽。他们真正测试的是一个函数已经以特定的方式实现了。它们作为一种临时的、原位的开发工具比回归测试更有效。</p><h1 id="ab46" class="lx ly it bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">为什么要编写组件测试？</h1><p id="8d9e" class="pw-post-body-paragraph kg kh it ki b kj mv kl km kn mw kp kq kr mx kt ku kv my kx ky kz mz lb lc ld im bi translated">以下是一些在“组件”级别编写测试的好理由:</p><ul class=""><li id="cf7a" class="le lf it ki b kj kk kn ko kr lg kv lh kz li ld lj lk ll lm bi translated">为了防止在被测试的组件中引入错误</li><li id="79f0" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">为了显示您正在编写的函数/方法如预期的那样工作，<em class="na">根据需求</em>(理想情况下，从用户故事中分解出快乐路径和不快乐路径的场景)</li><li id="46f4" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">更好地理解设计，并在一定程度上推动设计</li><li id="f719" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">验证设计</li><li id="ff1f" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">验证业务逻辑(例如，跨几个类运行的复杂状态机)是否按规定工作</li><li id="fb7e" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">提供一套测试，一个<em class="na">回归安全网</em>，可以定期重新运行，以便尽早发现新的错误</li></ul><p id="f36b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">单元测试有一些交叉，这并不奇怪，因为它们都是由开发人员在编程时编写的。但是也有很多好处是你无法从更细粒度的单元测试中真正得到的——或者至少，没有那么有效。</p><p id="9b3b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">顺便说一下，正如我前面提到的，组件测试的工作是验证一组功能——一组密切相关的功能、类或职责，它们共同完成系统行为的一个特定项目。但是如何确定单个组件的范围呢？如果你是域驱动设计(DDD)的粉丝，测试中的<em class="na">组件</em>通常匹配单个<a class="ae kf" href="https://medium.com/ingeniouslysimple/aggregates-in-domain-driven-design-5aab3ef9901d" rel="noopener">集合</a>，或者如果包含在单个微服务中，匹配一个<em class="na">有界上下文</em>。值得思考！</p><p id="32bf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">总的来说，我发现组件测试比单元测试更有效——更容易编写(比“白盒”更“黑盒”)；你不必写那么多，因为每一个都有更广的范围，所以涵盖了更多的代码。他们撒下了比单元测试更大的网。</p><p id="23a4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，只剩下三个层次中最广泛的测试…</p><h1 id="25a5" class="lx ly it bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">为什么要编写验收测试？</h1><p id="de54" class="pw-post-body-paragraph kg kh it ki b kj mv kl km kn mw kp kq kr mx kt ku kv my kx ky kz mz lb lc ld im bi translated">以下是一些编写验收测试的好理由:</p><ul class=""><li id="9535" class="le lf it ki b kj kk kn ko kr lg kv lh kz li ld lj lk ll lm bi translated">质疑需求的深度或广度</li><li id="ba6b" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">验证业务逻辑是否按指定方式工作</li><li id="60cd" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">确保错误情况得到处理，例如显示适当的错误消息，或者交易正确回滚，以保持数据完整性</li><li id="b48a" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">提供一套测试，一个可以定期重新运行的<em class="na">回归安全网</em></li></ul><p id="d335" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">与组件测试有一些重叠，但这实际上是组件测试真正有用的地方——就像验收测试一样，如果你从业务需求/故事场景而不是代码中驱动它们。</p><p id="b008" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是回到验收测试…</p><p id="9770" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了真正有效，验收测试场景应该由参与项目的主题专家——BAs，或者至少由与BAs直接接触的测试人员来指定。但是通常是开发人员需要将验收测试脚本转化为可运行的东西(例如，在BDD <a class="ae kf" href="https://cucumber.io/docs/gherkin/" rel="noopener ugc nofollow" target="_blank">小黄瓜场景</a>背后实现Java或Ruby代码)。</p><p id="d8a3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">验收测试是端到端的，撒下了最大的网；所以你会正确地认为它们是回归测试最有效的形式。缺点是它们通常比组件测试需要更长的运行时间，所以你要么少写一些，要么少运行一些。</p><h1 id="20b4" class="lx ly it bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">哪一个刚刚好？</h1><p id="3618" class="pw-post-body-paragraph kg kh it ki b kj mv kl km kn mw kp kq kr mx kt ku kv my kx ky kz mz lb lc ld im bi translated">正如你所看到的，当在三个不同的级别测试时，你可能在所有级别下测试相同的代码库，但是你在每个级别上实现不同的目标。</p><p id="8306" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">思考这些区别的一个好方法是，单元测试验证你写的代码是正确的，而验收测试验证代码在做正确的事情。组件测试占据了一个经常被忽略的重要的中间地带。事实上，虽然所有三个级别的测试都很重要，但我倾向于将更多的注意力放在组件级别的<a class="ae kf" href="https://codeburst.io/component-tests-vs-unit-tests-tdd-71b921d48907" rel="noopener" target="_blank">测试上，而不是其他两个……你也应该如此！</a></p><p id="b2a4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="na">有兴趣了解更多？查看我即将出版的书，</em><a class="ae kf" href="https://www.domainorientedtesting.com/" rel="noopener ugc nofollow" target="_blank"><em class="na"/></a><em class="na">(预计2020年某个时候出版)，加入LinkedIn上的DOT讨论组</em>  <em class="na">。</em></p></div><div class="ab cl nb nc hx nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="im in io ip iq"><p id="9377" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="na">顺便说一句，如果你是一名软件开发人员，并且你还没有</em> <a class="ae kf" href="https://bit.ly/UnitTestingSurvey" rel="noopener ugc nofollow" target="_blank"> <em class="na">参加这个单元测试调查</em> </a> <em class="na">，请参加——这应该不到一分钟，并且你将有助于形成整个行业的单元测试实践的更准确的图像…谢谢！</em></p></div></div>    
</body>
</html>