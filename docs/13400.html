<html>
<head>
<title>Merge Sort</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">合并排序</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/merge-sort-656f8ee59d83?source=collection_archive---------4-----------------------#2022-09-01">https://levelup.gitconnected.com/merge-sort-656f8ee59d83?source=collection_archive---------4-----------------------#2022-09-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5fa6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">归并排序是一种“分治”算法；它很省时，也是我的最爱。</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/a3129854a70639ddde7247d6578e0583.png" data-original-src="https://miro.medium.com/v2/resize:fit:740/format:webp/1*wj5YiSbqq-KNCBUGJixWoQ.png"/></div></figure><p id="ce41" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">它的工作方式是将数组分成两部分，递归调用自身，然后<strong class="ks iu">合并两个排序后的部分。</strong>这是一种高效的排序算法。</p><p id="7c05" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">对于这个排序算法，我们需要两个函数，<strong class="ks iu">一个用于拆分</strong>，而<strong class="ks iu">一个用于重新组合</strong>被拆分的部分；让我们深入研究一下。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lm ln l"/></div></figure><p id="8f18" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">第一个函数接收一个未排序的数组，将其分成两部分，对这两部分递归调用相同的方法，然后调用第二个函数重新组合/合并两个排序后的部分。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lm ln l"/></div></figure><p id="7382" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">第二个函数正好相反，接收两个数组，只返回1。因为两个数组是排序的，我们需要取两个数组中最小的(第1个元素)，迭代2个指针，填充一个新的排序后的数组，直到其中一个数组指针到达其数组的末尾；然后，我们只添加两个数组中剩余的内容(一个应该为空，另一个已经排序)。</p><p id="19a9" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated">合并排序算法的时间复杂度为O(n Log n) 的<strong class="ks iu">时间复杂度，并且是一个<strong class="ks iu">强烈推荐了解和使用的算法，但是使用额外的内存O(n) </strong>，但是如果您必须在没有额外内存的情况下“就地”执行，请避免使用。在下一篇文章中，我们将看到一个不使用额外空间的排序算法。</strong></p></div><div class="ab cl lo lp hx lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="im in io ip iq"><p id="7cdb" class="pw-post-body-paragraph kq kr it ks b kt ku ju kv kw kx jx ky kz la lb lc ld le lf lg lh li lj lk ll im bi translated"><a class="ae lv" href="https://medium.com/@jbstevenard/selection-sort-38f1196b36ae" rel="noopener"> &lt; &lt;选择排序</a> | <a class="ae lv" href="/@jbstevenard/learn-data-structures-and-algorithms-with-swift-5-6-d9f36a4027dd" rel="noopener ugc nofollow" target="_blank">图书</a> | <a class="ae lv" href="https://medium.com/@jbstevenard/quick-sort-217bf062ca65" rel="noopener">快速排序&gt; &gt; </a></p><div class="lw lx gp gr ly lz"><a href="https://medium.com/@jbstevenard/membership" rel="noopener follow" target="_blank"><div class="ma ab fo"><div class="mb ab mc cl cj md"><h2 class="bd iu gy z fp me fr fs mf fu fw is bi translated">通过我的推荐链接加入Medium—JB stevenard</h2><div class="mg l"><h3 class="bd b gy z fp me fr fs mf fu fw dk translated">阅读jb stevenard的每一个故事(以及媒体上成千上万的其他作家)。你的会员费直接支持jb…</h3></div><div class="mh l"><p class="bd b dl z fp me fr fs mf fu fw dk translated">medium.com</p></div></div><div class="mi l"><div class="mj l mk ml mm mi mn ko lz"/></div></div></a></div></div></div>    
</body>
</html>