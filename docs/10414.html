<html>
<head>
<title>Functional Programming in Python | Easy Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的函数式编程|简单易学</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/functional-programming-in-python-easy-learning-b20207b2dd4e?source=collection_archive---------4-----------------------#2021-12-02">https://levelup.gitconnected.com/functional-programming-in-python-easy-learning-b20207b2dd4e?source=collection_archive---------4-----------------------#2021-12-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/374e94595fbcdbc2e6ade4cea4100aba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HJlFP5GyUOWzo2CB"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">照片由<a class="ae jg" href="https://unsplash.com/@sigmund?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">西格蒙德</a>在<a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><div class=""/><p id="9278" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki jk">函数式编程(FP) </strong>是编程界最容易误导人的话题之一。你会发现很少有关于Python中FP的文章。在Python中学习和探索FP真的变得很难。在这篇文章中，我将尝试用例子来解释一些与FP相关的话题。</p><p id="6672" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">根据<a class="ae jg" href="https://en.wikipedia.org/wiki/Functional_programming" rel="noopener ugc nofollow" target="_blank">维基百科</a>，<strong class="ki jk">函数式编程</strong>是一种<a class="ae jg" href="https://en.wikipedia.org/wiki/Programming_paradigm" rel="noopener ugc nofollow" target="_blank">编程范式</a>，其中程序是通过<a class="ae jg" href="https://en.wikipedia.org/wiki/Function_application" rel="noopener ugc nofollow" target="_blank">应用</a>和<a class="ae jg" href="https://en.wikipedia.org/wiki/Function_composition_(computer_science)" rel="noopener ugc nofollow" target="_blank">组成</a> <a class="ae jg" href="https://en.wikipedia.org/wiki/Function_(computer_science)" rel="noopener ugc nofollow" target="_blank">函数</a>来构建的。简单来说，函数式编程允许开发人员将函数用作一等公民。您可以将函数存储为变量，并可以将它们传递给另一个函数来执行特定的操作。</p><p id="cf93" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意:这篇文章并不是要解释函数式编程的所有期望。为此，有一篇很好的文章叫做<a class="ae jg" href="https://realpython.com/python-functional-programming/" rel="noopener ugc nofollow" target="_blank">Python中的函数式编程:何时以及如何使用</a>。你可以去看看。本文将关注函数式编程的一个真实用例。</p><p id="08a9" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki jk">先决条件:</strong>你要有Python编程的基础知识(尤其是<strong class="ki jk"> list </strong>、<strong class="ki jk"> set </strong>、<strong class="ki jk"> iterator </strong>)。所有的例子都需要类型支持。因此示例将在<a class="ae jg" href="https://docs.python.org/3/library/typing.html" rel="noopener ugc nofollow" target="_blank"> Python3.5 </a> +上工作。</p><h2 id="128f" class="le lf jj bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">基本原则</h2><p id="b50a" class="pw-post-body-paragraph kg kh jj ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">在进一步学习之前，您应该了解下面描述的一些基本原则。</p><ol class=""><li id="4cd8" class="mc md jj ki b kj kk kn ko kr me kv mf kz mg ld mh mi mj mk bi translated">纯函数</li><li id="8baf" class="mc md jj ki b kj ml kn mm kr mn kv mo kz mp ld mh mi mj mk bi translated">确定性函数</li><li id="2031" class="mc md jj ki b kj ml kn mm kr mn kv mo kz mp ld mh mi mj mk bi translated">λ函数</li><li id="839b" class="mc md jj ki b kj ml kn mm kr mn kv mo kz mp ld mh mi mj mk bi translated">高阶函数</li><li id="406d" class="mc md jj ki b kj ml kn mm kr mn kv mo kz mp ld mh mi mj mk bi translated">不变</li><li id="dbdd" class="mc md jj ki b kj ml kn mm kr mn kv mo kz mp ld mh mi mj mk bi translated">Currying或部分功能</li><li id="4cd0" class="mc md jj ki b kj ml kn mm kr mn kv mo kz mp ld mh mi mj mk bi translated">功能组成</li></ol><h2 id="c636" class="le lf jj bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">1.纯函数</h2><p id="693b" class="pw-post-body-paragraph kg kh jj ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">纯函数是确定性函数，没有副作用<a class="ae jg" href="https://en.wikipedia.org/wiki/Side_effect_(computer_science)" rel="noopener ugc nofollow" target="_blank"><strong class="ki jk"/></a>，也就是说，对于相同的输入，输出总是相同的。同时，它不会消耗任何其他全局变量。</p><figure class="mr ms mt mu gt iv gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/32303043a833301d84758181b8123dbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1356/0*pLVGm9R8vTaoS-o6"/></div></figure><p id="2433" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki jk">纯函数示例:</strong></p><figure class="mr ms mt mu gt iv"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="d7ab" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这里，无论投入多少，产出都是一样的。</p><p id="5717" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">拥有一个纯函数的好处是，很容易理解和测试。然而，仅仅使用纯函数来构建一个完整的应用程序是非常困难的。我们也需要一些确定性函数。</p><h2 id="5af4" class="le lf jj bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">2.确定性函数</h2><p id="0728" class="pw-post-body-paragraph kg kh jj ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">确定性函数是指函数的输出总是确定的。这可能有副作用，但输出不应随时间而改变。同样的输入应该产生同样的输出</p><p id="bf67" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki jk">简单的例子:</strong></p><figure class="mr ms mt mu gt iv"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="122d" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki jk">另一个例子:</strong>确定性函数可能有副作用。也就是说，它可以访问全局变量。</p><figure class="mr ms mt mu gt iv"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="65c9" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki jk">非确定性函数的例子:</strong></p><figure class="mr ms mt mu gt iv"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="7e60" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的例子中，方法<code class="fe mx my mz na b">rand</code>使用<code class="fe mx my mz na b">random.random</code>生成一个随机数。这个API的输出将是不确定的。</p><p id="b3e2" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">确定性函数的好处是它在任何语言中都很常见。它很容易创建和理解。然而，有副作用。有的时候很难考。</p><h2 id="2c7a" class="le lf jj bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated"><strong class="ak"> 3。λ函数</strong></h2><p id="5d94" class="pw-post-body-paragraph kg kh jj ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated"><a class="ae jg" href="https://realpython.com/python-lambda/" rel="noopener ugc nofollow" target="_blank"> Lambda函数</a>是匿名函数，可以接受任意数量的参数，但只能有一个表达式。</p><p id="fae5" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">与上面lambda函数中的示例相同:</p><figure class="mr ms mt mu gt iv"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="3ffb" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Lambda函数是短期使用的匿名函数。它用于编写关键字较少的简洁代码。</p><h2 id="b3e6" class="le lf jj bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">4.霍夫高阶函数</h2><p id="75a5" class="pw-post-body-paragraph kg kh jj ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">HOF可以接受函数|s作为输入，并可以返回一个函数作为输出。</p><p id="e93a" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">示例:</p><figure class="mr ms mt mu gt iv"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="00e6" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki jk">注意:</strong>在上面的例子中，<strong class="ki jk"> splitBy </strong>是一个函数。它接受lambda函数作为参数。你可能也注意到了，我没有使用关键字<code class="fe mx my mz na b">def</code>来创建函数。我使用lambda作为一个函数，并将它赋给一个变量。这里可以阅读更多<a class="ae jg" href="https://realpython.com/python-lambda/" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="b4a6" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki jk"> reduce </strong>是一个将输入<code class="fe mx my mz na b">divider</code>作为函数，将<code class="fe mx my mz na b">arr</code>作为数组的函数。在计算完数组中的所有项后，它返回一个元组。</p><h2 id="89e3" class="le lf jj bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">5.不变</h2><p id="1676" class="pw-post-body-paragraph kg kh jj ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">不变性是指一旦数据/变量被创建，就不能在一段时间内改变。这个想法是为了避免交叉共享环境中的数据竞争，比如异步编程，副作用。</p><figure class="mr ms mt mu gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nb"><img src="../Images/c95bacd1640bbf8b16e7c1b06b9746a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*g8F1vNlTNIWiH0NY"/></div></div></figure><p id="285d" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Python有很少的不变性APIs类。让我们来看一些例子。</p><figure class="mr ms mt mu gt iv"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="7c51" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于Python是一种<a class="ae jg" href="https://en.wikipedia.org/wiki/Dynamic_programming_language" rel="noopener ugc nofollow" target="_blank"><strong class="ki jk"/></a>动态语言，即数据可以在运行时改变，这使得在Python中实现不变性很困难。同时，并不是所有的成员/对象都支持不变性。可以使用<a class="ae jg" href="https://github.com/immutable-js/immutable-js" rel="noopener ugc nofollow" target="_blank">不可变-js </a>。然而，我建议将不可变性作为一种实践，并且不要包含另一个库。</p><p id="f98f" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">实现不变性的简单方法——复制和扩展:</p><figure class="mr ms mt mu gt iv"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="cb5e" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你注意到了，你可以扩展任何迭代器。<strong class="ki jk">例如，</strong>一个列表可以用一个<strong class="ki jk">集合</strong>、<strong class="ki jk">字典</strong>和<strong class="ki jk">列表</strong>本身来扩展。</p><p id="3a12" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki jk">注意:</strong>在Python中使用<strong class="ki jk">字典(dict) </strong>非常繁琐。Python几乎没有用于字典的API。但是，您可以编写一些通用的util来提高代码质量。</p><figure class="mr ms mt mu gt iv"><div class="bz fp l di"><div class="mv mw l"/></div></figure><h2 id="e6f0" class="le lf jj bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">6.Currying或部分功能</h2><p id="9866" class="pw-post-body-paragraph kg kh jj ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">Currying是FP中的一种方法或技术，其中一个函数可以被组合成部分接受输入。也就是说，如果一个函数<code class="fe mx my mz na b">sum</code>接受输入<code class="fe mx my mz na b">a</code>和<code class="fe mx my mz na b">b</code>作为参数，那么currying这个函数可以让这个函数<code class="fe mx my mz na b">sum</code>接受一个参数<code class="fe mx my mz na b">a</code>并返回另一个函数。稍后，我们可以使用新创建的函数进行求和。</p><figure class="mr ms mt mu gt iv gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/0f359ed14b526d8154aae4dde8885a80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1152/0*KCxrFG9mISuMagh0"/></div></figure><p id="d19d" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki jk">让我们从例子来看:</strong></p><pre class="mr ms mt mu gt nd na ne nf aw ng bi"><span id="7a8b" class="le lf jj na b gy nh ni l nj nk">def split(token=" ", txt=""):<br/>    return txt.split(token)<br/>def splitByHash(txt):<br/>    return split("#", txt)<br/>print(splitByHash("This#is#awesome"))<br/>### ['This', 'is', 'awesome']</span></pre><p id="41bb" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的例子中，<code class="fe mx my mz na b">split</code>函数接受令牌和字符串数据进行拆分。我们已经创建了一个函数<code class="fe mx my mz na b">splitByHash</code>，其中已经定义了令牌。只需要一根绳子就能把它劈开。这里，<code class="fe mx my mz na b">splitByHash</code>是部分函数。</p><p id="31be" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki jk">注:</strong>上面的例子很好的演示了分部函数。然而，创建这样的部分函数对于超过2/3的参数是不可伸缩的。我们可以使用一些基本的工具来创建一个部分函数或定制函数。</p><figure class="mr ms mt mu gt iv"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="eb23" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你可以在这里阅读更多关于curry的内容，<a class="ae jg" href="https://python-course.eu/advanced-python/currying-in-python.php" rel="noopener ugc nofollow" target="_blank">高级python/currying-in-python </a></p><h2 id="8bea" class="le lf jj bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">7.功能组成</h2><p id="4cf4" class="pw-post-body-paragraph kg kh jj ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">函数合成是一个数学概念，其中一个运算取两个函数f和g，并产生一个函数h，使得h(x) = g(f(x))。为简单起见，(g f)(x) = g(f(x))</p><p id="8460" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki jk">举个例子来看:</strong></p><figure class="mr ms mt mu gt iv"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="ead0" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的例子中，<strong class="ki jk">获得贷款批准</strong>获得利息并生效。如果利息金额超过100，请求将被拒绝。如你所见，添加<strong class="ki jk"> compose </strong>使得合并功能和创建另一个功能变得容易。可以在以后重复使用。</p><h2 id="cbb4" class="le lf jj bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">一些现实生活中的问题</h2><p id="4c82" class="pw-post-body-paragraph kg kh jj ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">现在既然知道了FP的基础，那就来举例探究一下吧。</p><figure class="mr ms mt mu gt iv"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="1490" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的例子中，首先，我们使用rest API获取一些todos。之后，我们将根据todo的完成状态对其进行过滤。一旦我们都完成了todos，我们就收集id并获取所有用户。</p><p id="0b2c" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一切都好。然而，如果我们必须改变一个简单的行为，那就去找那些没有完成待办事项的用户。即使它只是不变，但会改变所有的编码声明。我们必须改变所有的变量名。这是一项乏味的工作。我们可以使用FP让这个程序更具声明性。为此，我们确实需要一些辅助方法:</p><p id="0c7d" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki jk">辅助方法:</strong></p><pre class="mr ms mt mu gt nd na ne nf aw ng bi"><span id="a50b" class="le lf jj na b gy nh ni l nj nk">def neg(fn):<br/>    def _neg(*arg):<br/>        return not fn(*arg)<br/>    return _neg<br/>prop = curry(lambda key, data: data[key])</span><span id="d4ae" class="le lf jj na b gy nl ni l nj nk">def isCompleted(todo): return todo["completed"]<br/>isNotCompleted = neg(isCompleted)<br/>getId = prop("id")</span></pre><p id="2c03" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在让我们重写同样的程序</p><figure class="mr ms mt mu gt iv"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="7baa" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki jk">注意:</strong>函数式编程还有其他一些方面。我还没有涵盖所有的内容。原因是:要么对于本文的范围来说太复杂，要么与JavaScript本身无关。</p><p id="ade7" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki jk">一些值得一提的概念:</strong></p><ol class=""><li id="9bee" class="mc md jj ki b kj kk kn ko kr me kv mf kz mg ld mh mi mj mk bi translated">功能数据结构</li><li id="47e5" class="mc md jj ki b kj ml kn mm kr mn kv mo kz mp ld mh mi mj mk bi translated">无例外地处理错误</li><li id="3863" class="mc md jj ki b kj ml kn mm kr mn kv mo kz mp ld mh mi mj mk bi translated">严与懒(懒评)</li><li id="e73d" class="mc md jj ki b kj ml kn mm kr mn kv mo kz mp ld mh mi mj mk bi translated">功能并行性(异步浮点)</li><li id="5ce1" class="mc md jj ki b kj ml kn mm kr mn kv mo kz mp ld mh mi mj mk bi translated">幺半群和函子</li><li id="690e" class="mc md jj ki b kj ml kn mm kr mn kv mo kz mp ld mh mi mj mk bi translated">副作用</li></ol><h2 id="33c8" class="le lf jj bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">从这里去哪里</h2><p id="6e0e" class="pw-post-body-paragraph kg kh jj ki b kj lx kl km kn ly kp kq kr lz kt ku kv ma kx ky kz mb lb lc ld im bi translated">正如我已经提到的，Python不是一种全功能语言。所以我们不能完全忽略杂质。我们必须混合搭配。以这种方式编写函数使您的代码更具声明性和可读性。然而，就核心概念而言，它确实增加了一点代码的复杂性。也就是说，如果你知道上面描述的基本概念，你就可以开始编写函数式程序了。网上有多篇文章。如果你真的想学函数，我在下面列出了一些。我还会推荐用像<a class="ae jg" href="https://www.scala-lang.org/" rel="noopener ugc nofollow" target="_blank"> Scala </a>、<a class="ae jg" href="https://clojure.org/" rel="noopener ugc nofollow" target="_blank"> Clojure </a>、<a class="ae jg" href="https://www.haskell.org/" rel="noopener ugc nofollow" target="_blank"> Haskell </a>这样的语言写一些代码。它将帮助你理解FP背后的核心概念和思想。</p><h2 id="deb9" class="le lf jj bd lg lh li dn lj lk ll dp lm kr ln lo lp kv lq lr ls kz lt lu lv lw bi translated">参考文章</h2><ol class=""><li id="72d3" class="mc md jj ki b kj lx kn ly kr nm kv nn kz no ld mh mi mj mk bi translated"><a class="ae jg" href="drive.google.com/drive/u/0/my-drive" rel="noopener ugc nofollow" target="_blank">Python中的函数式编程:何时以及如何使用</a></li><li id="6b7a" class="mc md jj ki b kj ml kn mm kr mn kv mo kz mp ld mh mi mj mk bi translated"><a class="ae jg" href="https://python-course.eu/advanced-python/" rel="noopener ugc nofollow" target="_blank">高级Python简介</a></li><li id="c4ed" class="mc md jj ki b kj ml kn mm kr mn kv mo kz mp ld mh mi mj mk bi translated"><a class="ae jg" href="https://www.programiz.com/python-programming/iterator" rel="noopener ugc nofollow" target="_blank"> Python高级话题</a></li></ol></div></div>    
</body>
</html>