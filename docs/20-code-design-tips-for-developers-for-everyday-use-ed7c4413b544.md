# 开发者日常使用的 20 个代码设计技巧

> 原文：<https://levelup.gitconnected.com/20-code-design-tips-for-developers-for-everyday-use-ed7c4413b544>

## 从实际的拉取请求中收集。

![](img/79d308926112760de4c524d43d5c914a.png)

照片由[努贝尔森·费尔南德斯](https://unsplash.com/@nublson?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 拍摄

当审查拉请求时，我会查看代码的各个方面，其中一个关键方面是所做的设计决策以及它们如何适应现有的代码库。我将根据最常见的问题列出一些代码设计技巧，这些问题是我多年的经验和数百个已审查的拉请求中收集到的。

1.  当设计一个新的类或者修改现有的类时，试着用一句话描述这个类做什么。如果一个句子中有多个“and”或“or”连词，那么这个类很可能违反了**单一责任原则**，需要重新设计或重构。
2.  当你用`new()`关键字实例化一个对象时，你也应该考虑其他方法:委托对象实例化给 DI-container，实现一个工厂，从对象池中检索预先创建的对象等等。`new()`是在类之间创建紧密耦合粘合剂。
3.  当通过改变现有对象的代码来扩展其行为时，考虑你是否违反了**开闭原则**。考虑通过实现装饰模式、扩展方法或面向方面的编程技术，将您想要添加的行为与现有对象分开。
4.  确保你实现的类不依赖于底层抽象。例如，一些负责实现业务用例的`IOrderService`不应该直接依赖`ISmtpServer`。在`IOrderService`和`ISmtpServer.`之间应该至少还有一个`IMailService`抽象
5.  类之间的紧密耦合会使它们的可重用性和系统的整体可维护性变得非常复杂。为了减轻这一点，使用接口、依赖注入、中介模式、发布/订阅机制和其他技术来实现组件之间的松散耦合。
6.  将同一组接口注入到许多不同的类中可能表明有一个**缺失的抽象问题**。例如，接口`IPdfReader`和`IPdfWriter`应该被分组到像`IPdfProvider`这样的更高层次的抽象之下，以使它们更易于客户使用。
7.  一个类的所有依赖都应该注入到它的构造函数中(**显式依赖**)。该类不应使用或应尽量减少使用隐式依赖项:直接在方法中实例化依赖项或调用静态类。
8.  当一个类中有很多重载的构造函数时，可以用**静态工厂方法**代替。主要的好处是静态工厂方法可以有一个惟一的、自我描述的名称，这与构造函数不同。
9.  考虑从提供**非确定性结果**，例如`DateTime`的依赖关系中抽象出你的代码，以使单元测试更容易，并且通常使方法/函数输出更可预测。
10.  考虑用值对象替换所有表示领域概念(如客户电子邮件)的原语类型(如字符串)，以避免**原语困扰**问题。值对象可以封装验证逻辑，使代码更具可读性。
11.  根据具体情况，考虑将 **if-else** 语句重构为[不同的模式](/treat-if-else-as-a-code-smell-until-proven-otherwise-3bd2c4c577bf):表驱动方法、策略模式、模板方法模式、状态模式、工厂模式等。
12.  只要有可能，使用**不可变数据类型**而不是可变数据类型，以最小化应用程序中的并发问题和副作用。
13.  使用纯函数(其输出仅取决于输入参数；它们不修改系统的外部状态)以获得可预测和可维护的代码。
14.  根据[**选择一个数据结构，渐近复杂**](https://www.bigocheatsheet.com/) 对其进行插入、更新、删除等操作，以及你的数据使用场景。
15.  如果输入参数的列表很长，如果它有很多行代码，或者如果你不能用一句没有连接词的话来描述函数做什么，那么考虑将**方法/函数**分成更小的几个。
16.  如果在应用程序的生命周期中，一个类必须只有一个实例，那么考虑在依赖注入容器中将该对象注册为 **singleton** ，而不是实现基于静态字段的 singleton 模式。
17.  当您需要实现逻辑来创建复杂对象图的**深度副本**时，可以考虑使用[序列化/反序列化](/5-ways-to-clone-an-object-in-c-d1374ec28efa)。其他方法，比如在克隆过程中涉及的每个类中实现一个克隆方法，可能是一个相当重复的任务。
18.  在你的应用中避免使用**单例有状态对象**，以避免由于多线程并发访问一个对象而导致的并发问题。如果在单例中需要状态，实现临界区或其他线程同步结构。
19.  不要将具有每个请求生存期的实例注入到单例中，以避免所谓的**强制依赖**的问题。
20.  在复制粘贴代码时，由于时间不够、业务压力等原因，实现一些快速的变通方法。，总是创建一个**科技债**票进入发行跟踪系统。

感谢阅读。如果你喜欢你所读到的，看看下面这个故事:

[](/50-software-engineering-best-practices-for-technical-leaders-and-seniors-cfcdf6a17e44) [## 面向技术领导者和资深人士的 50 个软件工程最佳实践

### 最佳工程师的最佳实践。

levelup.gitconnected.com](/50-software-engineering-best-practices-for-technical-leaders-and-seniors-cfcdf6a17e44) 

可以考虑订阅我的电报频道 [**软件开发日报**](https://t.me/sd_daily) 从我这里获取更多内容。

还有，考虑成为[中等会员](https://esashamathews.medium.com/membership)。

# 分级编码

感谢您成为我们社区的一员！在你离开之前:

*   👏为故事鼓掌，跟着作者走👉
*   📰查看[升级编码出版物](https://levelup.gitconnected.com/?utm_source=pub&utm_medium=post)中的更多内容
*   🔔关注我们:[Twitter](https://twitter.com/gitconnected)|[LinkedIn](https://www.linkedin.com/company/gitconnected)|[时事通讯](https://newsletter.levelup.dev)

🚀👉 [**加入人才集体，找到一份令人惊喜的工作**](https://jobs.levelup.dev/talent/welcome?referral=true)