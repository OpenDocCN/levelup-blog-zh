<html>
<head>
<title>Building Cross-Platform Mobile Applications with React Native</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用React Native构建跨平台移动应用</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/building-cross-platform-mobile-applications-with-react-native-1e3e120e4a29?source=collection_archive---------6-----------------------#2020-04-12">https://levelup.gitconnected.com/building-cross-platform-mobile-applications-with-react-native-1e3e120e4a29?source=collection_archive---------6-----------------------#2020-04-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="042e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">被劫持</p><p id="5960" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">脸书的React Native是一个跨平台的移动开发框架。有了它，我们可以为不同的设备以及不同版本的设备开发应用程序。使用React Native，我们编写JavaScript代码，这些JavaScript代码被编译成本机代码，分别用于每个运行它的操作系统。例如，View React原生UI组件将被编译成android视图中的ViewGroup组件，iOS中的UIView，并转换成web上的div。</p><p id="479e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然React Native作为一个框架允许我们为iOS和Android编写一致可用的代码，但我们经常希望或不得不为前者和后者设备分离代码，以构建所需的通用UI/逻辑。一种方法是使用React Native提供的平台模块。为了演示跨平台开发的导航，我构建了一个小型的React本机应用程序。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/a90df57d48cc3eaf7bddaece16f32438.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WqtXl_dfjBaIS3RISLxGdg.png"/></div></div></figure><p id="86b6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面是应用程序主容器的代码图像。出于这个例子的目的，我决定将样式表抽象出来，放在一个单独的文件中。如果我们查看应用程序功能组件的return语句，我们会看到视图原语中调用了两个组件:WelcomeByPlatform和Identity。WelcomeByPlatform传递一个名为version的prop，等于平台模块返回的版本。根据我们使用的设备，版本会有所不同。</p><p id="0091" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，我在版本为13.3的IOS模拟器上运行这个应用程序！如果我们在Expo Snack上作为Android运行这个应用程序(也就是在发表本文的时候)，我们可能会看到27版。在第26行上，WelcomeByPlatform被定义为Platform.select。通过这种方法，我们可以根据正在使用的操作系统有条件地呈现一个组件。在Platform.select中，我们将版本作为道具传递给两个组件。如果设备是iOS，我们会渲染IosWelcome如果没有，安卓欢迎。我们还可以将一个默认键传递给Platform.select，它将为不属于上述两者的设备呈现一个组件，比如web视图。在样式表中可以看到一个使用iOS、Android和default的例子，对于这个迷你项目，我将它单独放在一个文件中。在容器键中，我们使用Platform.select根据操作系统有条件地呈现下列backgroundColors之一。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi kx"><img src="../Images/3ac356cedf6de4baf78cc43ad4290bb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1316/format:webp/1*4ZVj__jqeEvdmTbPdocN9w.png"/></div></figure><h1 id="831d" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">欢迎组件</h1><p id="941f" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">在IosWelcome组件中，我们的state中有一个计数器，它最初被设置为0，还有一个表情符号被设置为戴墨镜的酷酷的人。按下我们的可触摸突出显示，我们的计数器增加，一个表情符号被附加到屏幕上。计数器的每一个增量都会产生相应数量的表情符号，根据计数器的大小，我们会呈现不同的表情符号。这种依赖性是在我们的useEffect中定义的，我们根据计数器的大小来更新表情符号的状态。</p><p id="76ef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还根据平台的版本有条件地呈现不同的按钮样式(*记住，版本是从我们的App/WelcomeByPlatform组件传递下来的)。如果iOS设备低于版本13，则在按钮中显示黑色文本；否则显示白色文本。虽然这是一个相当微薄的例子，当然我们可以想象如何平台。版本可以在现实生活中发挥巨大作用。例如，假设您已经在应用程序中内置了一些依赖于新的iOS功能的新功能。如果用户有较新的iOS，他们可以利用新功能，否则呈现没有新功能的旧组件。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mb"><img src="../Images/09db8ef60b892d560cf0a6e75d1d7517.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q0xAKo5qgLl8Kczjj6aeXw.png"/></div></div></figure><p id="9aa7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果没有Android上第三方的帮助，我们就无法获得同样的iOS表情符号体验，而我在日常生活中已经过于依赖这种体验了。因此，我决定在我们的AndroidWelcome组件中使用图标苹果表情符号的图像URL来执行相同的表情符号条件渲染。这些图像存储在一个名为imageData的对象中，并在useEffect中调用。你可能还注意到，在我们的Android版本中，我用TouchableNativeFeedback替换了TouchableHighlight一种只在Android上可用的可触摸的React原生原语。印刷时，它会产生动画涟漪效果！我们还必须改变相当多的逻辑，让表情符号显示出来，就像你会注意到的那样(可能也不是显示图像的最佳方式)。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mc"><img src="../Images/df92f77adee3271a83fd7bc724e43d5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TxWPEHVk3YXc9XPSFgWb6A.png"/></div></div></figure><p id="e865" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">React Native还让我们能够通过文件名系统来分离文件。如果我们的应用变得更加复杂，我们可能会决定不仅仅依赖平台模块，而是实际上将iOS和Android的组件分离到单独的文件中。例如，在我们的App组件中，我们有一个名为Identity的组件。我们的代码库中的这个组件实际上由两个不同的文件表示:Identity.ios.js和Identity.android.js。当我们运行我们的应用程序时，React Native能够根据它当前运行的操作系统来识别要运行这些文件中的哪个文件。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi md"><img src="../Images/19e6f1f8e4c5fbb7a9b32e49ba8754cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O-y_Hal0KyIldtdtg9OMaw.png"/></div></div></figure><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi me"><img src="../Images/98804601cc0486d925444ccb97543b40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t5xwexp6JGN0KCPXEYXzFQ.png"/></div></div></figure><p id="d5e8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用文件命名约定根据操作系统呈现组件，也反映了React Native编译本机代码的能力！！</p><p id="aca8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然在很大程度上，Native允许我们用JavaScript为iOS和Android编写代码，但由于基本的功能差异，某些方面仍然需要将代码分成不同的部分。键盘API就是这样一个例子，默认情况下，它在每个操作系统上的行为有很大不同。在iOS上，当用户关注输入字段时，默认情况下，键盘会与当前UI重叠，而在Android上，我们的UI主体会在TextInput焦点上调整大小。样式是跨平台程序需要一些逻辑的另一个领域。例如，假设您使用的字体在iOS上不可用，但在Android上可用，反之亦然。这是在样式表中使用三元组的最佳场景。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mf"><img src="../Images/0ed824ec462ea73ad71bd208561da30c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tgo4G_hJTq6dH4zhBFt_Xw.png"/></div></div></figure><p id="22bd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">瞧吧。成品！这绝对惊人的应用程序，显示使用iOS模拟器！</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/8420161ab8ff22d2af3ef0ab28b7c1fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*Ns6UEkszmviIAnitPOueqw.gif"/></div></figure></div></div>    
</body>
</html>