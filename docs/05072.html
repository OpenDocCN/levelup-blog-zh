<html>
<head>
<title>Property-based Testing with Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于属性的Python测试</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/unit-testing-in-python-property-based-testing-892a741fc119?source=collection_archive---------3-----------------------#2020-08-02">https://levelup.gitconnected.com/unit-testing-in-python-property-based-testing-892a741fc119?source=collection_archive---------3-----------------------#2020-08-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="64ed" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">类固醇的测试参数化</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/226046e261f2af38b0ee6821bf2d8b41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rJn7uPjGLzC6tIZ7QAOd9A.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图片作者:马丁·托马斯</figcaption></figure><p id="903c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当你编写单元测试时，很难找到正确的测试用例。你想确定你报道了所有有趣的案例，但是你可能不知道或者忘记了其中的一个。例如，如果您对一个接收整数的函数进行单元测试，您可能会考虑测试0、1和2。但是你想过负数吗？大数字呢？</p><p id="f8d5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们只是在考虑整数的测试策略。策略是数据的生成器。属性测试框架<code class="fe lu lv lw lx b">hypothesis</code>为<a class="ae ly" href="https://hypothesis.readthedocs.io/en/latest/data.html" rel="noopener ugc nofollow" target="_blank">提供了许多类型的策略</a>。可以用<code class="fe lu lv lw lx b">pip install hypothesis</code>安装。</p><p id="5ccc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们可以对这些输入——那些测试策略——做的一件事是检查运行时是否可接受，以及被测试的函数/方法是否不会崩溃。</p><p id="6dcb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我们将函数的输出与某些东西进行比较，效果会更好。检查等式是不可能的，所以我们需要知道函数的一个属性。一个我们一直期望保持的不变量。我们需要将我们的测试建立在函数的固有属性上。</p><p id="6c63" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了进一步激发您对基于属性的测试的兴趣:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lz ma l"/></div></figure><h1 id="0d1e" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">示例:整数因子分解</h1><p id="d5dc" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">我们有一个函数<code class="fe lu lv lw lx b">factorize(n : int) -&gt; List[int]</code>，它接受一个整数并返回质因数:</p><blockquote class="my mz na"><p id="c7fb" class="ky kz nb la b lb lc ju ld le lf jx lg nc li lj lk nd lm ln lo ne lq lr ls lt im bi translated">如果一个整数n是正数，并且能被1和n这两个数整除，则称它为素数。</p></blockquote><p id="e9fc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们希望返回的整数的乘积就是数字本身。这就是我们如何设计函数行为:</p><ul class=""><li id="1a96" class="nf ng it la b lb lc le lf lh nh ll ni lp nj lt nk nl nm nn bi translated">factorize(0) = [0] —一个异常也是合理的</li><li id="692e" class="nf ng it la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated">因式分解(1) = [1] —严格来说，1不是素数。</li><li id="5a79" class="nf ng it la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated">因式分解(-1) = [-1] — …两者都不是-1</li><li id="15ef" class="nf ng it la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated">因式分解(-n) = [-1] +因式分解(n)，n &gt; 1</li></ul><p id="6c39" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">实现可能如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt ma l"/></div></figure><p id="5387" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你可能会对这里的环境感到有点不安</p><pre class="kj kk kl km gt nu lx nv nw aw nx bi"><span id="1b20" class="ny mc it lx b gy nz oa l ob oc">while i &lt;= int(math.ceil(number ** 0.5)) + 1:</span></pre><p id="dd43" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，您编写一个测试来检查重要的情况:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt ma l"/></div></figure><p id="62d0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果不熟悉测试参数化，您可能希望<a class="ae ly" href="https://towardsdatascience.com/unit-testing-in-python-structure-57acd51da923" rel="noopener" target="_blank">阅读py test . mark . parameter ize</a>。这太棒了，这几行运行了8个测试:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi od"><img src="../Images/622b55c3872573104ac19a70baaa5a86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7wps5_1-qIQxHC8Qsa5Iaw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">正在运行pytest。马丁·托马斯截图。</figcaption></figure><p id="e66e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">对于<code class="fe lu lv lw lx b">factorize</code>，基于属性的测试会是什么样子？</p><p id="8fe8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">首先，我们需要考虑我们想要测试的属性。对于我们设计的<code class="fe lu lv lw lx b">factorize</code>,我们知道返回数字的乘积等于数字本身。我们可以放入任何整数，但是如果整数变得太大，运行时间就会太长。所以让我们把它们限制在+/-一百万的合理范围内:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt ma l"/></div></figure><p id="ff59" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在我们用<code class="fe lu lv lw lx b">pytest</code>运行测试:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/56939038a1797e8b9c3fb36d6fcd45ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5Vw4EcyoBpepwk-UtdRa-Q.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">假设发现一个问题！马丁·托马斯截图。</figcaption></figure><p id="ab97" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">正如你在上面的例子中看到的，<code class="fe lu lv lw lx b">hypothesis</code>发现<code class="fe lu lv lw lx b">factorize(5)</code>返回了一个空列表，它不会乘以5。然后我们可以很快发现，我们实际上对所有的素数都犯了一个错误——我们需要把素数相加。添加以下代码行后，测试运行正常:</p><pre class="kj kk kl km gt nu lx nv nw aw nx bi"><span id="9b1c" class="ny mc it lx b gy nz oa l ob oc">if number != 1:<br/>    factors.append(number)</span></pre><p id="5536" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在失败的例子中值得注意的一件奇怪的事情是，它失败的地方是最小的正整数。这不是巧合。属性测试框架试图找到一个导致测试失败的简单例子。这个过程叫做<a class="ae ly" href="https://hypothesis.readthedocs.io/en/latest/data.html#shrinking" rel="noopener ugc nofollow" target="_blank">收缩</a>。</p><h1 id="54a3" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">假设产生了什么？</h1><p id="c4b7" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">你可以看看这样的例子:</p><pre class="kj kk kl km gt nu lx nv nw aw nx bi"><span id="42b4" class="ny mc it lx b gy nz oa l ob oc">from hypothesis import strategies as st</span><span id="26ae" class="ny mc it lx b gy of oa l ob oc">st.lists(st.integers()).map(sorted).example()</span></pre><h1 id="debf" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">我可以在哪里应用基于属性的测试？</h1><p id="83d7" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">这种模式适用于一些验证成本较低的算法:</p><ul class=""><li id="c74f" class="nf ng it la b lb lc le lf lh nh ll ni lp nj lt nk nl nm nn bi translated"><a class="ae ly" href="https://en.wikipedia.org/wiki/Arg_max" rel="noopener ugc nofollow" target="_blank"> Arg max </a>:遍历列表，确保没有其他元素更大。</li><li id="5aa5" class="nf ng it la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated">解一组方程:验证这个解实际上是一个解。</li><li id="d245" class="nf ng it la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated"><a class="ae ly" href="https://en.wikipedia.org/wiki/Constraint_satisfaction" rel="noopener ugc nofollow" target="_blank">约束满足</a>:验证解决方案满足所有约束。</li><li id="1652" class="nf ng it la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated">所有<a class="ae ly" href="https://en.wikipedia.org/wiki/NP-completeness" rel="noopener ugc nofollow" target="_blank"> NP完全问题</a>:这是一组决策问题，很难找到答案，但很容易验证找到的答案。旅行推销员就是一个例子。给定一组推销员必须去的城市，有没有一个他能去的最长为L的旅行？鉴于这样的游览，很容易验证。不过，计算这样一次旅行可能很难。</li></ul><p id="c18c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">较弱但仍有帮助的检查是验证返回值是否在候选集合中:</p><ul class=""><li id="fa57" class="nf ng it la b lb lc le lf lh nh ll ni lp nj lt nk nl nm nn bi translated"><a class="ae ly" href="https://en.wikipedia.org/wiki/Greatest_common_divisor" rel="noopener ugc nofollow" target="_blank">最大公约数</a>:确保<strong class="la iu">实际上是</strong>除数。</li><li id="fc56" class="nf ng it la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated">最短路径:确保<strong class="la iu">是一条</strong>路径。</li><li id="2c56" class="nf ng it la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated">排序和排名:确保列表中的元素与之前的完全相同。也许你还可以测试排序/排名标准？</li><li id="75ce" class="nf ng it la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated">过滤:断言相关数据仍然存在/其他数据已被删除。</li></ul><h1 id="ee5a" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">生成到测试模式</h1><p id="498f" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">有时很容易生成一个样本来测试您感兴趣的函数。对于上面的因式分解的例子，你可能有一个已知素数的列表，你乘以它们的随机子集。如果你写一个函数来检查一个字符串是否是回文，你可以很容易地首先生成一个回文。如果您想检查文本是否包含给定的字符串，您可以在该字符串周围添加随机文本，然后进行检查。</p><h1 id="95c7" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">示例:测试数据结构</h1><p id="5e9b" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">我实现了一个区间数据结构，它有一个方法<code class="fe lu lv lw lx b">issubset</code></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt ma l"/></div></figure><h1 id="addf" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">字符串验证</h1><p id="e085" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated"><code class="fe lu lv lw lx b">hypothesis</code>可以生成一些特殊的字符串，例如电子邮件地址和IP地址。这意味着您可以轻松地检查函数的阳性情况，这些函数决定某个东西是IP地址还是电子邮件地址:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt ma l"/></div></figure><h1 id="5e4d" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">可逆函数</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi og"><img src="../Images/6f8ee6acfbcd8222ac560240c884a240.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*546uWAEm4fMyMP3Mn9dKxg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">函数及其反函数。图片由马丁·托马斯提供。</figcaption></figure><p id="8537" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您有一个函数和它的反函数，比如加密/解密或序列化/反序列化函数，您可以一起测试它们。测试策略应该只给出域内的值。</p><p id="35a8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，如果我们想要测试<code class="fe lu lv lw lx b">b64encode</code> / <code class="fe lu lv lw lx b">b64decode</code>，测试将会是:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt ma l"/></div></figure><p id="78ab" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个测试现在也证明了这两个函数属于同一类，并且应该按这个顺序使用。</p><h1 id="2b1c" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">神谕</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oh"><img src="../Images/e8fd401554cd3e5070681369fe801182.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HssehnPIAdNmStHv"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae ly" href="https://unsplash.com/@jentheodore?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">珍·西奥多</a>在<a class="ae ly" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="4d86" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在复杂性理论中，神谕是一个黑匣子，它能即时提供问题的解决方案。在这种情况下，这只是我们认为正确的第二个实现。如果你有一个复杂的算法问题，你可能首先要实现一个强力的解决方案，然后用这个更容易理解的解决方案来测试你更快的算法。蛮力算法就是神谕。</p><h1 id="9738" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">使用类型注释！</h1><p id="8701" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">我喜欢字体注释💓如果你没有使用它们，我强烈推荐你阅读关于<a class="ae ly" href="https://medium.com/analytics-vidhya/type-annotations-in-python-3-8-3b401384403d" rel="noopener">类型注释</a>和渐进打字的内容。</p><p id="190e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">类型注释与基于属性的测试相关，因为带注释的类可以用来生成该类的随机对象。作为一名研究机器学习主题的数据科学家，我通常希望在预处理/后处理步骤中使用这种方法，因为感兴趣的对象可能相当复杂。假设是如何支持和产生这些结果的:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nt ma l"/></div></figure><p id="0a3a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当您开发具有复杂业务逻辑的web应用程序时，它也会有所帮助。</p><h1 id="7648" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">最要紧的东西</h1><p id="8272" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">我见过同样的概念被称为<em class="nb">生成测试</em>和<em class="nb">数据驱动测试</em>。第一个还好；我们为测试生成样本数据。</p><p id="e4e0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，我不会称之为<em class="nb">数据驱动测试</em>。我们没有获得真实世界的数据来生成我们的测试用例。</p><p id="b360" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">反过来想也很有趣:如果我们现在测试属性，那么我们之前测试的是什么？安德里亚·莱奥帕尔迪称之为基于实例或基于表格的测试。</p><p id="b47e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">基于实例的测试有利于覆盖已知的极限情况，而基于属性的测试有利于发现未知的极限情况。</p><p id="fe17" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我还要说，基于属性的测试几乎和模糊化一样。<a class="oi oj ep" href="https://medium.com/u/92606ca29d25?source=post_page-----892a741fc119--------------------------------" rel="noopener" target="_blank"> @nelhage </a>对此有更详细的阐述:</p><div class="ok ol gp gr om on"><a href="https://blog.nelhage.com/post/property-testing-is-fuzzing/" rel="noopener  ugc nofollow" target="_blank"><div class="oo ab fo"><div class="op ab oq cl cj or"><h2 class="bd iu gy z fp os fr fs ot fu fw is bi translated">基于属性的测试越来越模糊</h2><div class="ou l"><h3 class="bd b gy z fp os fr fs ot fu fw dk translated">“基于属性的测试”指的是编写对代码真实的语句(“属性”)，以及…</h3></div><div class="ov l"><p class="bd b dl z fp os fr fs ot fu fw dk translated">blog.nelhage.com</p></div></div></div></a></div><h1 id="9c0f" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">摘要</h1><p id="d506" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">基于属性的测试不会取代基于实例的测试，而是对基于实例的测试的补充。它有时以非常简洁的形式记录属性，并有助于发现未知的边缘情况。执行基于属性的测试比执行基于示例的测试花费更多的时间。hypothesis是编写基于属性的测试的一个很好的Python框架。</p><h1 id="7cd0" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">下一步是什么？</h1><p id="5f91" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">在这个系列中，我们已经有了:</p><ul class=""><li id="d9d4" class="nf ng it la b lb lc le lf lh nh ll ni lp nj lt nk nl nm nn bi translated">第1部分:<a class="ae ly" href="https://medium.com/swlh/unit-testing-in-python-basics-21a9a57418a0" rel="noopener">Python中单元测试的基础知识</a></li><li id="3d83" class="nf ng it la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated">第2部分:<a class="ae ly" rel="noopener ugc nofollow" target="_blank" href="/unit-testing-in-python-mocking-patching-and-dependency-injection-301280db2fed">补丁、模拟和依赖注入</a></li><li id="2a61" class="nf ng it la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated">第3部分:<a class="ae ly" href="https://medium.com/analytics-vidhya/how-to-test-flask-applications-aef12ae5181c" rel="noopener">如何用数据库、模板和受保护的页面测试Flask应用程序</a></li><li id="846f" class="nf ng it la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated">第4部分:<a class="ae ly" href="https://medium.com/python-in-plain-english/unit-testing-in-python-tox-and-nox-833e4bbce729" rel="noopener"> tox和nox </a></li><li id="c009" class="nf ng it la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated">第5部分:<a class="ae ly" href="https://medium.com/python-in-plain-english/unit-testing-in-python-structure-57acd51da923" rel="noopener">结构化单元测试</a></li><li id="5816" class="nf ng it la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated">第6部分:<a class="ae ly" rel="noopener ugc nofollow" target="_blank" href="/ci-pipelines-for-python-projects-9ac2830d2e38">CI-管道</a></li><li id="e69d" class="nf ng it la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated">第7部分:<a class="ae ly" rel="noopener ugc nofollow" target="_blank" href="/unit-testing-in-python-property-based-testing-892a741fc119">基于属性的测试</a></li><li id="f1ac" class="nf ng it la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated">第八部分:<a class="ae ly" href="https://medium.com/analytics-vidhya/unit-testing-in-python-mutation-testing-7a70143180d8" rel="noopener">突变检测</a></li><li id="88cd" class="nf ng it la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated">第9部分:<a class="ae ly" href="https://towardsdatascience.com/static-code-analysis-for-python-bdce10b8d287" rel="noopener" target="_blank">静态代码分析</a> — Linters、类型检查和代码复杂性</li><li id="6beb" class="nf ng it la b lb no le np lh nq ll nr lp ns lt nk nl nm nn bi translated">第10部分:<a class="ae ly" href="https://towardsdatascience.com/pytest-plugins-to-love-%EF%B8%8F-9c71635fbe22" rel="noopener" target="_blank"> Pytest插件到爱</a></li></ul><p id="abed" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您对使用Python测试的其他主题感兴趣，请告诉我。</p></div></div>    
</body>
</html>