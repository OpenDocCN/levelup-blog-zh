<html>
<head>
<title>Continuous Deploys With Bazel + Github Actions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过Bazel + Github操作持续部署</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/continuous-deploys-with-bazel-github-actions-c508676678e8?source=collection_archive---------3-----------------------#2022-02-13">https://levelup.gitconnected.com/continuous-deploys-with-bazel-github-actions-c508676678e8?source=collection_archive---------3-----------------------#2022-02-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/5f807604b8229651fe07faf9d21c086f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KqZ0foonHNLKRqYsbhLcxw.jpeg"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">来源:<a class="ae jg" href="https://www.pexels.com/@pixabay" rel="noopener ugc nofollow" target="_blank"> <strong class="bd jh"> Pixabay </strong> </a></figcaption></figure><div class=""/><div class=""><h2 id="6e24" class="pw-subtitle-paragraph kh jj jk bd b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dk translated">直接来自您的回购协议的CI/CD</h2></div><p id="8b96" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">运输代码可能是一场噩梦。</p><p id="7583" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随着每一次代码推送，您都需要构建、测试并最终将您的工件上传到可以使用它们的地方。</p><p id="da23" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">随着Docker的兴起，我们有了掩饰构建和部署环境中微小差异的奢侈——但我们仍然需要在正确的时间拉、构建和推送正确的工件，在您合并新代码时做出响应，并提供运行器来执行所有这些工作。</p><p id="9125" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">像<a class="ae jg" href="https://circleci.com/product/#hosting-options" rel="noopener ugc nofollow" target="_blank"><strong class="lb jl">circle ci</strong></a><a class="ae jg" href="https://www.jetbrains.com/teamcity/" rel="noopener ugc nofollow" target="_blank"><strong class="lb jl">TeamCity</strong></a>和<a class="ae jg" href="https://www.jenkins.io/" rel="noopener ugc nofollow" target="_blank"><strong class="lb jl">Jenkins</strong></a><strong class="lb jl"/>这样的服务通过帮助我们解决这些问题而蓬勃发展，但是现在你可以直接从Github本身管理这个问题。</p><p id="adf1" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了向您展示如何操作，让我们来解决一个(相对)简单的问题:</p><blockquote class="lv lw lx"><p id="7976" class="kz la ly lb b lc ld kl le lf lg ko lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated">我们必须创建一个MediaWiki扩展(称为语义MediaWiki)的工作Docker安装，并将其部署到其他人可以下载并开始使用它的地方。</p></blockquote><p id="18e8" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在<a class="ae jg" href="https://github.com/NaimKabir/semantic-mediawiki" rel="noopener ugc nofollow" target="_blank"> <strong class="lb jl">这个回购</strong> </a>中这么做了，你可以用它作为你正在处理的问题/代码库的入门工具包:</p><blockquote class="mc"><p id="c0ee" class="md me jk bd mf mg mh mi mj mk ml lu dk translated"><a class="ae jg" href="https://github.com/NaimKabir/semantic-mediawiki" rel="noopener ugc nofollow" target="_blank"> <strong class="ak"> Github仓库:部署语义MediaWiki </strong> </a></p></blockquote><p id="73cb" class="pw-post-body-paragraph kz la jk lb b lc mm kl le lf mn ko lh li mo lk ll lm mp lo lp lq mq ls lt lu im bi translated">以下是一些额外的约束条件，以加强我们系统的安全性和效率:</p><ul class=""><li id="4084" class="mr ms jk lb b lc ld lf lg li mt lm mu lq mv lu mw mx my mz bi translated">每当我们更改关键路径代码时，我们都应该进行另一次部署</li><li id="ee8a" class="mr ms jk lb b lc na lf nb li nc lm nd lq ne lu mw mx my mz bi translated">我们应该在部署之前测试所有的更改</li><li id="ed28" class="mr ms jk lb b lc na lf nb li nc lm nd lq ne lu mw mx my mz bi translated">我们应该<em class="ly">只</em>测试+构建已经改变的东西，以节省时间和资源</li></ul><h1 id="a71b" class="nf ng jk bd jh nh ni nj nk nl nm nn no kq np kr nq kt nr ku ns kw nt kx nu nv bi translated">巴泽尔</h1><p id="42e8" class="pw-post-body-paragraph kz la jk lb b lc nw kl le lf nx ko lh li ny lk ll lm nz lo lp lq oa ls lt lu im bi translated">Bazel  是一个构建和测试框架，它明确地绘制出你的依赖关系。使用它的语言，您可以列出一组构建“目标”——您正在构建的可以相互依赖的工件——以及实际构建它们的“规则”。</p><p id="1371" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从<a class="ae jg" href="https://github.com/bazelbuild/rules_nodejs" rel="noopener ugc nofollow" target="_blank"> <strong class="lb jl"> JavaScript </strong> </a>到<a class="ae jg" href="https://github.com/bazelbuild/rules_go" rel="noopener ugc nofollow" target="_blank"> <strong class="lb jl"> Python </strong> </a>都有构建规则——但这里我们将重点关注用于构建、操作和部署Docker容器的规则:<a class="ae jg" href="https://github.com/bazelbuild/rules_docker" rel="noopener ugc nofollow" target="_blank"> <strong class="lb jl"> rules_docker </strong> </a>。</p><p id="bd41" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">使用这些预构建的规则(我们将其安装到我们的Bazel <a class="ae jg" href="https://github.com/NaimKabir/semantic-mediawiki/blob/2661cb71bea6357c790f8144dc911dd8684c94f0/WORKSPACE" rel="noopener ugc nofollow" target="_blank"> <strong class="lb jl">工作区</strong> </a>)，我们可以配置<a class="ae jg" href="https://github.com/NaimKabir/semantic-mediawiki/blob/2661cb71bea6357c790f8144dc911dd8684c94f0/container/BUILD.bazel" rel="noopener ugc nofollow" target="_blank"> <strong class="lb jl"> BUILD.bazel </strong> </a>文件来做类似于<a class="ae jg" href="https://github.com/NaimKabir/semantic-mediawiki/blob/2661cb71bea6357c790f8144dc911dd8684c94f0/WORKSPACE#L29-L38" rel="noopener ugc nofollow" target="_blank"> <strong class="lb jl">从Docker Hub(或从AWS ECS，或任何地方)拉一个容器</strong> </a> <strong class="lb jl"> </strong>的事情:</p><pre class="ob oc od oe gt of og oh oi aw oj bi"><span id="c9ff" class="ok ng jk og b gy ol om l on oo">container_pull(<br/>    name = "mediawiki-linux-amd64",<br/>    registry = "index.docker.io",<br/>    repository = "library/mediawiki",<br/>    digest = "sha256:996dd16efe204eaa7bfa1d104f549976d3becb7a3e96501fc9fdd6089f776e21" # mediawiki:1.35.3, linux/amd64<br/>)</span></pre><p id="a808" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们可以用 的各种操作<a class="ae jg" href="https://github.com/NaimKabir/semantic-mediawiki/blob/2661cb71bea6357c790f8144dc911dd8684c94f0/container/BUILD.bazel#L8-L25" rel="noopener ugc nofollow" target="_blank"> <strong class="lb jl">对其进行修改:</strong></a></p><pre class="ob oc od oe gt of og oh oi aw oj bi"><span id="11e8" class="ok ng jk og b gy ol om l on oo">container_run_and_commit(<br/>    name = "installs",<br/>    image = "<a class="ae jg" href="http://twitter.com/mediawiki" rel="noopener ugc nofollow" target="_blank">@mediawiki</a>-linux-amd64//image",<br/>    commands = [ <br/>      //commands here...<br/>    ],<br/>)</span></pre><p id="1aba" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">而且我们可以<a class="ae jg" href="https://github.com/NaimKabir/semantic-mediawiki/blob/2661cb71bea6357c790f8144dc911dd8684c94f0/container/BUILD.bazel#L71-L79" rel="noopener ugc nofollow" target="_blank"> <strong class="lb jl">把它推到一个注册表</strong> </a>。</p><pre class="ob oc od oe gt of og oh oi aw oj bi"><span id="046d" class="ok ng jk og b gy ol om l on oo">container_push(<br/>    name = "release", # the name of this target<br/>    image = ":release-container", # a docker target built beforehand<br/>    registry = "index.docker.io", # the dockerhub registry<br/>    repository = "{{INSERT YOUR DOCKER HUB REPO HERE}}",<br/>    tag = "3.2.3",<br/>    skip_unchanged_digest = True, # don't push if its the same<br/>    format = "Docker",<br/>)</span></pre><p id="c6c4" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">尽管在我们这样做之前，我们还可以<a class="ae jg" href="https://github.com/NaimKabir/semantic-mediawiki/blob/2661cb71bea6357c790f8144dc911dd8684c94f0/container/BUILD.bazel#L60-L67" rel="noopener ugc nofollow" target="_blank"> <strong class="lb jl">运行测试</strong> </a>！</p><pre class="ob oc od oe gt of og oh oi aw oj bi"><span id="2e95" class="ok ng jk og b gy ol om l on oo">container_test(<br/>    name = "test",<br/>    configs = [<br/>      // *.yaml files that describe tests<br/>    ],<br/>    image = ":test-container",<br/>)</span></pre><p id="2cd2" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这些测试在yaml中定义，并在容器中运行简单的shell命令来检查预期的输出。谷歌的<a class="ae jg" href="https://github.com/GoogleContainerTools/container-structure-test" rel="noopener ugc nofollow" target="_blank"> <strong class="lb jl">容器结构测试</strong> </a>项目在这里提供了最详细的内容，但他们的一个简单例子是:</p><pre class="ob oc od oe gt of og oh oi aw oj bi"><span id="d797" class="ok ng jk og b gy ol om l on oo">commandTests:<br/>  - name: "gunicorn flask"<br/>    setup: [["virtualenv", "/env"], ["pip", "install", "gunicorn", "flask"]]<br/>    command: "which"<br/>    args: ["gunicorn"]<br/>    expectedOutput: ["/env/bin/gunicorn"]</span></pre><p id="a2a7" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一切都很巧妙——但是Bazel的天才之处不在于你可以编排所有这些构建和测试步骤。</p><p id="82bb" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Bazel的天才之处在于它只会构建和测试自上次以来已经改变的东西<em class="ly">！您对文件所做的任何更改都会被检测到，并且只会传播到依赖它们的目标。</em></p><p id="7e13" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<a class="ae jg" href="https://github.com/NaimKabir/semantic-mediawiki" rel="noopener ugc nofollow" target="_blank"> <strong class="lb jl">范例库</strong> </a>中，在<a class="ae jg" href="https://docs.bazel.build/versions/main/install.html" rel="noopener ugc nofollow" target="_blank"> <strong class="lb jl">安装Bazel </strong> </a>之后，您可以运行以下代码，这将花费<em class="ly">很长的时间来构建一切并执行测试。</em></p><pre class="ob oc od oe gt of og oh oi aw oj bi"><span id="05a1" class="ok ng jk og b gy ol om l on oo"># Run 1: Executed in  179.11 secs<br/>&gt;&gt; bazel test //...</span></pre><p id="96a5" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是当你再做一次的时候，它会立刻发生。太美了。</p><pre class="ob oc od oe gt of og oh oi aw oj bi"><span id="7a09" class="ok ng jk og b gy ol om l on oo"># Run 2: Executed in  716.89 millis<br/>&gt;&gt; bazel test //...</span></pre><p id="dbae" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">所以:我们可以构建我们的工件，并从我们的本地机器部署它们。</p><p id="81a8" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但更酷的是，如果每次我们推送代码时，这种情况都会自动发生。</p><p id="90f4" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这让我们进入了真正的持续部署领域。</p><p id="9508" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">进入:<a class="ae jg" href="https://docs.github.com/en/actions/quickstart" rel="noopener ugc nofollow" target="_blank"> <strong class="lb jl"> Github动作</strong> </a>。</p><h1 id="13f3" class="nf ng jk bd jh nh ni nj nk nl nm nn no kq np kr nq kt nr ku ns kw nt kx nu nv bi translated">Github操作</h1><p id="012c" class="pw-post-body-paragraph kz la jk lb b lc nw kl le lf nx ko lh li ny lk ll lm nz lo lp lq oa ls lt lu im bi translated">Github基本上允许你在推送和合并代码时运行任意的作业(在其他<a class="ae jg" href="https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows" rel="noopener ugc nofollow" target="_blank"> <strong class="lb jl">事件</strong> </a>中)，所有这些都是通过设置一点yaml配置来实现的。</p><p id="014c" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我将向您展示这与我们的Bazel构建系统配合得有多好。您在repo中设置了一个<code class="fe op oq or og b">.github/workflows</code>目录，Github将读取这种粗略形式的yaml文件:</p><pre class="ob oc od oe gt of og oh oi aw oj bi"><span id="2643" class="ok ng jk og b gy ol om l on oo">name: {{ name of workflow }}<br/>on: <br/>  {{ event to trigger workflow}}<br/>jobs:<br/>  example-job:<br/>    runs-on: ubuntu-latest<br/>    steps:<br/>      - name: {{ step name }}<br/>        runs:<br/>          // commands</span></pre><p id="9d27" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我们的示例存储库中，我们有一个<a class="ae jg" href="https://github.com/NaimKabir/semantic-mediawiki/blob/7ce37c65b248e4e18c1a0eeb23288710dc287559/.github/workflows/deploy.yaml" rel="noopener ugc nofollow" target="_blank"> <strong class="lb jl"> deploy.yaml </strong> </a>工作流，它是这样开始的:</p><pre class="ob oc od oe gt of og oh oi aw oj bi"><span id="ffee" class="ok ng jk og b gy ol om l on oo">name: deploy <br/>on: <br/>  push:<br/>    branches:<br/>     - main<br/>jobs:<br/>  test-and-deploy:<br/>    runs-on: ubuntu-latest</span></pre><p id="6170" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这将创建一个“部署”工作流，在分支<code class="fe op oq or og b">main</code>上有<code class="fe op oq or og b">push</code>事件时触发。</p><p id="9699" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它只有一个任务<code class="fe op oq or og b">test-and-deploy</code>，运行在最新版本的Ubuntu操作系统上。</p><p id="cbcb" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">太好了，让我们来看看这项工作的一些细节。</p><p id="312a" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们从这一系列步骤开始:</p><pre class="ob oc od oe gt of og oh oi aw oj bi"><span id="3017" class="ok ng jk og b gy ol om l on oo">steps:<br/>      - name: Checkout<br/>        uses: actions/checkout@v2</span></pre><p id="c8f2" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这一步就像它听起来的那样:它对我们的存储库的代码做了一个<code class="fe op oq or og b">git checkout</code>,因此它在工作范围内。</p><p id="254d" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可能想知道<code class="fe op oq or og b">actions/checkout@v2</code>指的是什么，它是如何工作的——这是一个好问题。这是一个<a class="ae jg" href="https://docs.github.com/en/actions/learn-github-actions/understanding-github-actions#actions" rel="noopener ugc nofollow" target="_blank"> <strong class="lb jl">动作</strong> </a>！动作有点像软件交付工作流的应用程序，您可以将其插入到您的构建中并简化开发。有一整个<a class="ae jg" href="https://github.com/marketplace?type=actions" rel="noopener ugc nofollow" target="_blank"> <strong class="lb jl">市场</strong> </a>都是他们。</p><p id="406e" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们使用下面的另一个动作:</p><pre class="ob oc od oe gt of og oh oi aw oj bi"><span id="e99a" class="ok ng jk og b gy ol om l on oo">- name: Bazel cache<br/>        id: bazel-cache<br/>        uses: actions/cache@v2<br/>        env:<br/>          version: 4.2.1<br/>        with:<br/>          path: | <br/>            ~/.cache/bazel<br/>          key: ${{ runner.os }}-{{ env.version }}-bazel-cache</span></pre><p id="786a" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><a class="ae jg" href="https://github.com/actions/cache" rel="noopener ugc nofollow" target="_blank"><strong class="lb jl">actions/cache @ v2</strong></a>是一个出色的动作，它可以在每次运行之间保持状态，即使表面上每次推送代码和执行工作流时都提供了一个新的运行器。</p><p id="4b4b" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在这里，我们使用它来保存Bazel缓存——这就是Bazel如何知道之前已经构建了什么，以及为什么它可以给你<em class="ly">惊人的</em>快速构建/测试。它会缓存在之前的执行中已经做过的事情，并跳过它！</p><p id="5e44" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们有:</p><pre class="ob oc od oe gt of og oh oi aw oj bi"><span id="f4d2" class="ok ng jk og b gy ol om l on oo">- name: Login to Docker Hub<br/>        uses: docker/login-action@v1<br/>        with:<br/>          username: ${{ secrets.DOCKER_HUB_USERNAME }}<br/>          password: ${{ secrets.DOCKER_HUB_ACCESS_TOKEN }}</span></pre><p id="4df1" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你的前瞻性思维可能会想，以上帝的名义，我们如何让Github访问我们的Docker注册表，而不将秘密提交给回购——这将是一个巨大的安全禁忌。</p><p id="611c" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">嗯，Github让你从<a class="ae jg" href="https://docs.github.com/en/actions/security-guides/encrypted-secrets" rel="noopener ugc nofollow" target="_blank"> <strong class="lb jl">加密的秘密中读取</strong> </a>你可以在回购本身上设置，如果你进入回购设置。在左侧面板中，您可以导航到Secrets &gt; Actions，它允许您像这样设置键和值:</p><figure class="ob oc od oe gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi os"><img src="../Images/9eea02e7db9d1cea796b2f23ca2f218a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Gw7551iLF3myal19jQZJVA.png"/></div></div></figure><p id="6a9e" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">整洁！太方便了！</p><p id="41b8" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在<a class="ae jg" href="https://github.com/NaimKabir/semantic-mediawiki/blob/7ce37c65b248e4e18c1a0eeb23288710dc287559/.github/workflows/deploy.yaml" rel="noopener ugc nofollow" target="_blank"><strong class="lb jl">deploy . YAML</strong></a><strong class="lb jl"/>中的其余步骤是简单的Bazel安装，然后运行Bazel测试——最后推送到我们的注册中心:</p><pre class="ob oc od oe gt of og oh oi aw oj bi"><span id="b762" class="ok ng jk og b gy ol om l on oo">- name: Deploying current release        <br/>  run: bazel run //container:release</span></pre><p id="7f39" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">repo的“操作”选项卡中的每个工作流甚至都有一个创建状态徽章的小选项:</p><figure class="ob oc od oe gt iv gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/59ca5f2b0159dd9efec2e583a68bbf04.png" data-original-src="https://miro.medium.com/v2/resize:fit:740/format:webp/1*vg70k1AiMslkh16zKEhU8g.png"/></div></figure><p id="6592" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以在自述文件中呈现如下内容:</p><figure class="ob oc od oe gt iv gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/bc60dbd2749c1f7189270bde16ad2b0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:512/format:webp/1*yUSvWowia4tQZPKfBsV7Ig.png"/></div></figure><p id="2213" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">谈谈出色的端到端开发人员体验。</p><p id="6fdf" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">干得好，Github。</p><h1 id="213b" class="nf ng jk bd jh nh ni nj nk nl nm nn no kq np kr nq kt nr ku ns kw nt kx nu nv bi translated">摘要</h1><p id="eaab" class="pw-post-body-paragraph kz la jk lb b lc nw kl le lf nx ko lh li ny lk ll lm nz lo lp lq oa ls lt lu im bi translated">这是对一些非常丰富和富有表现力的构建和执行系统的一次旋风式的访问——但是如果您使用<a class="ae jg" href="https://github.com/NaimKabir/semantic-mediawiki" rel="noopener ugc nofollow" target="_blank"> <strong class="lb jl">示例库</strong> </a>并阅读文档，您很快就会成为一名专家。</p><p id="5134" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在，您已经有了运行一个健壮的持续部署管道所需的基本框架，以便在提交代码时立即交付更新。</p><p id="0a37" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">借助Bazel和Github的力量，即使是一个单独的开发人员也拥有硅谷最好的商店的CI/CD印章。</p><p id="d751" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">免费的。</p><p id="0d85" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">祝运输顺利！</p><p id="315e" class="pw-post-body-paragraph kz la jk lb b lc ld kl le lf lg ko lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb jl">🚢🚢🚢</strong></p><h2 id="6d2b" class="ok ng jk bd jh ov ow dn nk ox oy dp no li oz pa nq lm pb pc ns lq pd pe nu pf bi translated"><strong class="ak">资源:</strong></h2><ol class=""><li id="0237" class="mr ms jk lb b lc nw lf nx li pg lm ph lq pi lu pj mx my mz bi translated"><a class="ae jg" href="https://docs.bazel.build/versions/5.0.0/bazel-overview.html" rel="noopener ugc nofollow" target="_blank"> <strong class="lb jl">巴泽尔概述</strong> </a></li><li id="5346" class="mr ms jk lb b lc na lf nb li nc lm nd lq ne lu pj mx my mz bi translated"><a class="ae jg" href="https://docs.bazel.build/versions/main/install.html" rel="noopener ugc nofollow" target="_blank"> <strong class="lb jl"> Bazel安装</strong> </a></li><li id="a82d" class="mr ms jk lb b lc na lf nb li nc lm nd lq ne lu pj mx my mz bi translated"><a class="ae jg" href="https://github.com/NaimKabir/semantic-mediawiki" rel="noopener ugc nofollow" target="_blank"> <strong class="lb jl">范例知识库:</strong> </a>构建和部署语义MediaWiki</li><li id="87bd" class="mr ms jk lb b lc na lf nb li nc lm nd lq ne lu pj mx my mz bi translated"><a class="ae jg" href="https://github.com/bazelbuild/rules_docker" rel="noopener ugc nofollow" target="_blank"><strong class="lb jl">rules _ docker:</strong></a>通过Bazel操纵Docker集装箱</li><li id="6026" class="mr ms jk lb b lc na lf nb li nc lm nd lq ne lu pj mx my mz bi translated"><a class="ae jg" href="https://github.com/GoogleContainerTools/container-structure-test" rel="noopener ugc nofollow" target="_blank"> <strong class="lb jl">容器结构测试:</strong> </a>如何在Docker工件上做断言</li><li id="b7b0" class="mr ms jk lb b lc na lf nb li nc lm nd lq ne lu pj mx my mz bi translated"><a class="ae jg" href="https://docs.github.com/en/actions/quickstart" rel="noopener ugc nofollow" target="_blank"> <strong class="lb jl"> Github动作快速启动</strong> </a></li><li id="783e" class="mr ms jk lb b lc na lf nb li nc lm nd lq ne lu pj mx my mz bi translated"><a class="ae jg" href="https://docs.github.com/en/actions/learn-github-actions" rel="noopener ugc nofollow" target="_blank"> <strong class="lb jl">了解Github动作</strong> </a></li><li id="2268" class="mr ms jk lb b lc na lf nb li nc lm nd lq ne lu pj mx my mz bi translated"><a class="ae jg" href="https://github.com/marketplace?type=actions" rel="noopener ugc nofollow" target="_blank"> <strong class="lb jl">动作市场</strong> </a></li><li id="793f" class="mr ms jk lb b lc na lf nb li nc lm nd lq ne lu pj mx my mz bi translated"><a class="ae jg" href="https://github.com/actions/cache" rel="noopener ugc nofollow" target="_blank"> <strong class="lb jl">缓存动作</strong> </a>:如何在Github工作流运行之间缓存状态。超级有用。</li></ol></div></div>    
</body>
</html>