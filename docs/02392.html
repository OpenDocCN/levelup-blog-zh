<html>
<head>
<title>Ways to Clone an Object in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在JavaScript中克隆对象的方法</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/ways-to-clone-an-object-in-javascript-e1e5beaaf564?source=collection_archive---------13-----------------------#2020-03-10">https://levelup.gitconnected.com/ways-to-clone-an-object-in-javascript-e1e5beaaf564?source=collection_archive---------13-----------------------#2020-03-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="ff96" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">Java Script语言</h2><div class=""/><div class=""><h2 id="9de0" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">使用ES6、库、JSON.parse/stringify,和本机方法</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/4203e55694434c7b2eafb9b0ad6cc24b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*06kzSd-S5q7C0fC7PblpYA.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">照片由<a class="ae lh" href="https://unsplash.com/@thoughtcatalog?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">思想目录</a>在<a class="ae lh" href="https://unsplash.com/s/photos/coffee?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="d7e6" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在本文中，我将分享一些我所知道的用JavaScript克隆对象的解决方案。</p><ol class=""><li id="5f48" class="me mf it lk b ll lm lo lp lr mg lv mh lz mi md mj mk ml mm bi translated">ES6</li><li id="8b0b" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">使用库</li><li id="9cfe" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">JSON.parse和JSON.stringify</li><li id="7732" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md mj mk ml mm bi translated">本地方法</li></ol><p id="b4f0" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><em class="ms">更多类似内容，请查看</em><a class="ae lh" href="https://betterfullstack.com" rel="noopener ugc nofollow" target="_blank"><em class="ms">https://betterfullstack.com</em></a></p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="8c65" class="na nb it bd nc nd ne nf ng nh ni nj nk ki nl kj nm kl nn km no ko np kp nq nr bi translated">ES6解决方案</h1><p id="b255" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">ES6提供了两种浅层复制机制:</p><ul class=""><li id="6546" class="me mf it lk b ll lm lo lp lr mg lv mh lz mi md nx mk ml mm bi translated"><a class="ae lh" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign" rel="noopener ugc nofollow" target="_blank"> Object.assign() </a></li><li id="476d" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md nx mk ml mm bi translated"><a class="ae lh" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax" rel="noopener ugc nofollow" target="_blank">展开语法</a></li></ul><p id="7963" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">注意:<strong class="lk jd">浅拷贝</strong>是一个对象的逐位拷贝。创建一个新对象，该对象具有原始对象中值的精确副本。如果对象的任何字段是对其他对象的引用，则只复制引用地址。</p><p id="5e5d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">简单来说，你可以认为浅复制就像编程中的“引用调用”。</p><h2 id="a59b" class="ny nb it bd nc nz oa dn ng ob oc dp nk lr od oe nm lv of og no lz oh oi nq iz bi translated">对象.分配()</h2><p id="5032" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated"><code class="fe oj ok ol om b"><strong class="lk jd">Object.assign()</strong></code>方法将所有<a class="ae lh" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/propertyIsEnumerable" rel="noopener ugc nofollow" target="_blank">可枚举的</a> <a class="ae lh" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty" rel="noopener ugc nofollow" target="_blank">自身属性</a>从一个或多个<em class="ms">源对象</em>复制到一个<em class="ms">目标对象</em>。它返回目标对象。</p><p id="98ff" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我将有一个示例状态，目标对象是<code class="fe oj ok ol om b">{}</code>和两个源。然后，我把<strong class="lk jd">原始状态</strong>和<strong class="lk jd">新用户名</strong>合并在一起。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi on"><img src="../Images/846569e4a9fbba3ccab0c40761ee5178.png" data-original-src="https://miro.medium.com/v2/resize:fit:774/format:webp/1*wCmGJgvRiYjZeL3A6b8H5Q.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">使用Object.assign()克隆对象</figcaption></figure><p id="7c16" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">下面是在React项目(我的个人博客)中使用这种方法的真实例子</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oo op l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">使用Object.assign()更新用户名值</figcaption></figure><h2 id="fb5f" class="ny nb it bd nc nz oa dn ng ob oc dp nk lr od oe nm lv of og no lz oh oi nq iz bi translated">扩展语法</h2><p id="a019" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">当您使用状态管理时，尤其是在Angular或Redux中，您会经常看到这种语法。</p><p id="7e5d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">示例:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/76a22bf67a04d2b4d17c5cdb3a35247f.png" data-original-src="https://miro.medium.com/v2/resize:fit:670/format:webp/1*iHSpIIl7q8z_g2Uica0Zcg.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">使用扩展语法克隆对象</figcaption></figure><p id="892c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在现实生活中，我很少使用这种语法来克隆一个对象。但是，在国家管理中，我运用得很多。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oo op l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">使用spread语法从状态克隆对象的示例代码</figcaption></figure><p id="f879" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">在上面的例子中，<code class="fe oj ok ol om b">state.a</code>、<code class="fe oj ok ol om b">state.b</code>和<code class="fe oj ok ol om b">state.c</code>是一个对象。它包含了许多内部属性，在请求时，我需要将这些对象信息转换成不同的主体结构，以将请求发送到后端来执行特定的任务。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="0452" class="na nb it bd nc nd ne nf ng nh ni nj nk ki nl kj nm kl nn km no ko np kp nq nr bi translated">图书馆</h1><p id="1c43" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">就个人而言，我不喜欢在项目中大量使用库。但是，在某些情况下或旧项目中，他们使用jQuery、Lodash和下划线等库来实现不同的目的:</p><ul class=""><li id="30b9" class="me mf it lk b ll lm lo lp lr mg lv mh lz mi md nx mk ml mm bi translated">快速实施以满足最后期限</li><li id="5c1d" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md nx mk ml mm bi translated">也许10年前，唯一的选择就是<strong class="lk jd"> jQuery </strong></li><li id="6a48" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md nx mk ml mm bi translated">由于开发人员的技能。他们根据自己的知识应用东西，这不是最好的解决方案。</li><li id="da57" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md nx mk ml mm bi translated">公司工作流程也是一个原因。我在这里使用“工作流”,因为在一些公司有明确的需求库，可以在新老项目中使用。</li></ul><p id="efbc" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">现在让我们看看人们喜欢用什么库来克隆JavaScript中的对象。</p><h2 id="ec93" class="ny nb it bd nc nz oa dn ng ob oc dp nk lr od oe nm lv of og no lz oh oi nq iz bi translated"><a class="ae lh" href="https://api.jquery.com/" rel="noopener ugc nofollow" target="_blank"> jQuery </a></h2><p id="c46b" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated"><a class="ae lh" href="https://api.jquery.com/jquery.extend/#jQuery-extend-deep-target-object1-objectN" rel="noopener ugc nofollow" target="_blank"> jQuery.extend() </a>:将两个或多个对象的内容合并到第一个对象中。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi or"><img src="../Images/9d923c4cac86998c5bcae1c7df348030.png" data-original-src="https://miro.medium.com/v2/resize:fit:860/format:webp/1*1sCdh_tu-xKlq1xKQAz7Mw.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">使用Jquery extend克隆2对象</figcaption></figure><p id="3ca5" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">jQuery还有一个<code class="fe oj ok ol om b"><a class="ae lh" href="https://api.jquery.com/clone/" rel="noopener ugc nofollow" target="_blank">.clone()</a></code>方法用于元素的深层复制。</p><h2 id="1669" class="ny nb it bd nc nz oa dn ng ob oc dp nk lr od oe nm lv of og no lz oh oi nq iz bi translated"><a class="ae lh" href="https://lodash.com/" rel="noopener ugc nofollow" target="_blank">洛达什</a></h2><p id="7d6a" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">您可以使用lodash中的<code class="fe oj ok ol om b"><a class="ae lh" href="https://lodash.com/docs#clone" rel="noopener ugc nofollow" target="_blank">_.clone()</a></code>和<code class="fe oj ok ol om b"><a class="ae lh" href="https://lodash.com/docs#cloneDeep" rel="noopener ugc nofollow" target="_blank">_.cloneDeep()</a></code>进行浅层复制和深层复制。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi os"><img src="../Images/1d9182b31f10fae77d1a5d3642b61d9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:732/format:webp/1*C2xStTkomqDsUq9RS0tZjQ.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">使用lodash库克隆对象</figcaption></figure><h2 id="1355" class="ny nb it bd nc nz oa dn ng ob oc dp nk lr od oe nm lv of og no lz oh oi nq iz bi translated"><a class="ae lh" href="https://underscorejs.org/" rel="noopener ugc nofollow" target="_blank">下划线</a></h2><p id="2847" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">这个库以前很厉害。我记得我大三的时候，很多项目在5年前就使用它了。从jQuery换成Angular后，我再也很少在前端项目中看到这个库了。</p><p id="659c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">下划线很棒。它为你提供了许多功能上的帮助。包含了对象的<code class="fe oj ok ol om b"><a class="ae lh" href="https://underscorejs.org/#clone" rel="noopener ugc nofollow" target="_blank">_.clone()</a></code>方法。</p><p id="e92c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">此方法将创建所提供的普通对象的浅拷贝克隆。任何嵌套的对象或数组都将通过引用来复制，而不是复制。</p><h2 id="0771" class="ny nb it bd nc nz oa dn ng ob oc dp nk lr od oe nm lv of og no lz oh oi nq iz bi translated"><a class="ae lh" href="https://www.npmjs.com/package/clone" rel="noopener ugc nofollow" target="_blank">克隆</a></h2><p id="0905" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">您可以使用这个库来克隆对象和JavaScript中的一切，比如对象、数组、数字、字符串、映射、集合、承诺。</p><p id="8fd8" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">你可以从<a class="ae lh" href="https://github.com/pvorb/clone#readme" rel="noopener ugc nofollow" target="_blank">这里</a>阅读<code class="fe oj ok ol om b">README.md</code>来学习如何使用。安装和使用都很简单。</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="9040" class="na nb it bd nc nd ne nf ng nh ni nj nk ki nl kj nm kl nn km no ko np kp nq nr bi translated">JSON.parse和JSON.stringify</h1><p id="29ce" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated"><code class="fe oj ok ol om b"><a class="ae lh" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse" rel="noopener ugc nofollow" target="_blank">JSON.parse</a>()</code>方法解析JSON字符串，构造字符串描述的JavaScript值或对象。</p><p id="0a4c" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe oj ok ol om b"><a class="ae lh" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify" rel="noopener ugc nofollow" target="_blank">JSON.stringify()</a></code>方法将JavaScript对象或值转换成JSON字符串。</p><p id="cd9f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">但是，您可以使用这个语法<code class="fe oj ok ol om b">JSON.parse(JSON.stringify(object))</code>使用这个方法对一个对象进行深度克隆。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/f63b17125c27167516ef3a29d6b08cb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:832/format:webp/1*K99KwEvoxwRMryn78os4GQ.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">使用JSON.parse和JSON.stringify深度克隆对象</figcaption></figure><p id="cf6b" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">这种方法在幕后有一些限制。我建议您将它用于简单类型，或者仅用于字符串类型或JSON类型，原因如下:</p><ul class=""><li id="3254" class="me mf it lk b ll lm lo lp lr mg lv mh lz mi md nx mk ml mm bi translated">它不克隆函数(所有东西都必须序列化为JSON数据类型)</li><li id="0acf" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md nx mk ml mm bi translated">日期类型不适用<a class="ae lh" href="https://stackoverflow.com/questions/11491938/issues-with-date-when-using-json-stringify-and-json-parse" rel="noopener ugc nofollow" target="_blank">。<code class="fe oj ok ol om b">JSON.stringify(new Date())</code>以ISO格式返回日期的字符串表示，而<code class="fe oj ok ol om b">JSON.parse()</code>不会将其转换回date对象。</a></li><li id="9d29" class="me mf it lk b ll mn lo mo lr mp lv mq lz mr md nx mk ml mm bi translated">缓慢克隆一个具有复杂类型的对象，如<code class="fe oj ok ol om b">undefined</code>、<code class="fe oj ok ol om b">Infinity</code>、<strong class="lk jd">正则表达式</strong>、<strong class="lk jd">贴图</strong>、<strong class="lk jd">集合</strong>、<strong class="lk jd">斑点</strong>、<strong class="lk jd">文件列表</strong>、<strong class="lk jd">图像、数组</strong>。</li></ul></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="0209" class="na nb it bd nc nd ne nf ng nh ni nj nk ki nl kj nm kl nn km no ko np kp nq nr bi translated">本地方法</h1><p id="8a13" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated"><a class="ae lh" href="https://nodejs.org/api/all.html#v8_serialization_api" rel="noopener ugc nofollow" target="_blank">序列化API </a>提供了以与HTML结构化克隆算法兼容的方式序列化JavaScript值的方法。</p><p id="e9ee" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我从来不用这个解决方案在服务器端克隆对象。但是，我从同事和<a class="ae lh" href="https://stackoverflow.com/" rel="noopener ugc nofollow" target="_blank"> stackoverflow </a>身上注意到了这一点。</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="oo op l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">在Nodejs中克隆对象的本机方法</figcaption></figure></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><h1 id="531d" class="na nb it bd nc nd ne nf ng nh ni nj nk ki nl kj nm kl nn km no ko np kp nq nr bi translated">结论</h1><p id="7ac3" class="pw-post-body-paragraph li lj it lk b ll ns kd ln lo nt kg lq lr nu lt lu lv nv lx ly lz nw mb mc md im bi translated">在本文中，我将开发人员用来在JavaScript中克隆对象的所有常见情况进行了分组。</p><p id="ff86" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">作为一名JavaScript工程师，我认为我们会根据上下文的不同情况使用不同的方法。</p><p id="5c02" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">我希望这篇文章对你有用！你可以在<a class="ae lh" href="https://medium.com/@transonhoang?source=post_page---------------------------" rel="noopener">媒体</a>上关注我。我也在<a class="ae lh" href="https://twitter.com/transonhoang" rel="noopener ugc nofollow" target="_blank">推特</a>上。欢迎在下面的评论中留下任何问题。我很乐意帮忙！</p></div><div class="ab cl mt mu hx mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="im in io ip iq"><div class="ks kt ku kv gt ou"><a href="https://betterfullstack.com/stories/" rel="noopener  ugc nofollow" target="_blank"><div class="ov ab fo"><div class="ow ab ox cl cj oy"><h2 class="bd jd gy z fp oz fr fs pa fu fw jc bi translated">故事-更好的全栈</h2><div class="pb l"><h3 class="bd b gy z fp oz fr fs pa fu fw dk translated">关于JavaScript、Python和Wordpress的有用文章，有助于开发人员减少开发时间并提高…</h3></div><div class="pc l"><p class="bd b dl z fp oz fr fs pa fu fw dk translated">betterfullstack.com</p></div></div><div class="pd l"><div class="pe l pf pg ph pd pi lb ou"/></div></div></a></div></div></div>    
</body>
</html>