<html>
<head>
<title>React Hooks &amp; Why They Make (Coding) Life So Much Easier</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React Hooks &amp;为什么它们使(编码)生活变得如此容易</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/react-hooks-why-they-make-coding-life-so-much-easier-fe72f75b8e37?source=collection_archive---------7-----------------------#2020-04-18">https://levelup.gitconnected.com/react-hooks-why-they-make-coding-life-so-much-easier-fe72f75b8e37?source=collection_archive---------7-----------------------#2020-04-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/445a5c4ac6e4d839dbc7838e79ccb8f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4j-HxJN9DQLkHyuqCqEaGg.jpeg"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">来自<a class="ae jg" href="https://burst.shopify.com/api-home-furniture?utm_campaign=photo_credit&amp;utm_content=Browse+Free+HD+Images+of+Beautiful+Kitchen+Utensils+In+Bright+Wooden+Kitchen&amp;utm_medium=referral&amp;utm_source=credit" rel="noopener ugc nofollow" target="_blank">爆裂</a>的<a class="ae jg" href="https://burst.shopify.com/@sarahpflugphoto?utm_campaign=photo_credit&amp;utm_content=Browse+Free+HD+Images+of+Beautiful+Kitchen+Utensils+In+Bright+Wooden+Kitchen&amp;utm_medium=referral&amp;utm_source=credit" rel="noopener ugc nofollow" target="_blank">莎拉·普弗卢格</a>的照片</figcaption></figure><div class=""/><p id="4786" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">React最棒的一点是，它很好地完成了对应用程序中的事件做出反应的任务。它提供了完整的工具来管理生命周期事件，例如当组件安装或更新时，允许您管理应用程序的状态，同时自动对状态中的任何变化做出反应，等等。</p><p id="6a18" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">问题是，这些传统形式的工具只能在类组件中使用，而不是功能组件。假设，这应该没问题，对不对？如果需要访问状态和生命周期方法，只需使用类组件。这实际上被认为是React中的最佳实践，因为它很容易将无状态组件和有状态组件区分开来。</p><p id="70aa" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是，当您使用第三方集成时，比如支付表单或登录流程，并且第三方代码<em class="le">仅</em>在功能组件中工作，会发生什么呢？B.H .(在Hooks之前)，这可能很困难——当然，您可以通过创建不同的类和功能组件来解决它，然后导入并组织到一个更大的组件中，但这很快就会变得混乱，而且肯定不是最佳实践。</p><h1 id="4a55" class="lf lg jj bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">什么是React钩子？</h1><p id="6187" class="pw-post-body-paragraph kg kh jj ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">React挂钩在React 16.8.0和更高版本中得到支持，现在允许您在功能组件中使用状态、生命周期事件、上下文和其他React特性，这些特性以前只在类组件中可用。正如React文档所述:</p><blockquote class="mi mj mk"><p id="abd1" class="kg kh le ki b kj kk kl km kn ko kp kq ml ks kt ku mm kw kx ky mn la lb lc ld im bi translated">挂钩是让您从功能组件“挂钩”React状态和生命周期特性的功能。钩子在类内部不起作用——它们让你在没有类的情况下使用React。</p></blockquote><p id="71f8" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">三个主要挂钩是:</p><ol class=""><li id="c1d5" class="mo mp jj ki b kj kk kn ko kr mq kv mr kz ms ld mt mu mv mw bi translated">使用状态</li><li id="d36a" class="mo mp jj ki b kj mx kn my kr mz kv na kz nb ld mt mu mv mw bi translated">使用效果</li><li id="c9f7" class="mo mp jj ki b kj mx kn my kr mz kv na kz nb ld mt mu mv mw bi translated">使用上下文</li></ol><p id="1ace" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">还有其他的，比如<code class="fe nc nd ne nf b">useRef</code>和<code class="fe nc nd ne nf b">useCallback</code>，我们不会在这里深入讨论，但是可以在<a class="ae jg" href="https://reactjs.org/docs/hooks-reference.html" rel="noopener ugc nofollow" target="_blank"> React文档</a>中找到。</p><h1 id="c41f" class="lf lg jj bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">使用状态</h1><p id="2899" class="pw-post-body-paragraph kg kh jj ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">我们将从州钩开始，它实际上只是伪装的好州。<code class="fe nc nd ne nf b">useState</code>钩子允许你给一个功能组件添加本地状态。它在重新渲染之间保留本地状态，并且在设置状态时触发重新渲染。您不用在一个状态对象中管理所有状态并使用<code class="fe nc nd ne nf b">setState</code>函数来更新状态的任何部分，而是使用单独的<code class="fe nc nd ne nf b">setState</code>函数来定义单独的状态变量，这两个变量都可以像任何其他变量或函数一样被访问(即，不需要使用<code class="fe nc nd ne nf b">this.state.variable</code>)。首先，进口<code class="fe nc nd ne nf b">useState</code>同React:</p><figure class="nh ni nj nk gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ng"><img src="../Images/7ae7ce9d92be2a040013406022f4ef2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*droRoZD6PDwis8HVmxwmIg.png"/></div></div></figure><p id="0490" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe nc nd ne nf b">useState</code>用于定义状态变量和<code class="fe nc nd ne nf b">setState</code>函数，因为它基本上让应用程序知道这些变量应该被视为状态。以下面的例子为例，它将用于管理文章和作者的应用程序中:</p><figure class="nh ni nj nk gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nl"><img src="../Images/c8f8186976a804d73ce0e37f0fe8cc2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u27Nf2gzrh9I2yCfvqjnig.png"/></div></div></figure><p id="1610" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的代码相当于一个类组件:</p><figure class="nh ni nj nk gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nm"><img src="../Images/419df6c3c8fe04019f5de81743b14b3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YzJTvvq8BIya5hpWALu82Q.png"/></div></div></figure><p id="469a" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">唯一的区别是，在类组件中你会使用<code class="fe nc nd ne nf b">this.state.posts</code>和<code class="fe nc nd ne nf b">setState</code>，而在函数组件中你只使用<code class="fe nc nd ne nf b">posts</code>和<code class="fe nc nd ne nf b">setPosts</code>。</p><h1 id="c3b6" class="lf lg jj bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">使用效果</h1><p id="0458" class="pw-post-body-paragraph kg kh jj ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated"><code class="fe nc nd ne nf b">useEffect</code>将是你对功能组件中生命周期方法的回答。React文档说得好:</p><blockquote class="mi mj mk"><p id="2e23" class="kg kh le ki b kj kk kl km kn ko kp kq ml ks kt ku mm kw kx ky mn la lb lc ld im bi translated">如果你熟悉React类生命周期方法，你可以把<code class="fe nc nd ne nf b">useEffect</code>钩子看作是<code class="fe nc nd ne nf b">componentDidMount</code>、<code class="fe nc nd ne nf b">componentDidUpdate</code>和<code class="fe nc nd ne nf b">componentWillUnmount</code>的组合。</p></blockquote><p id="b7de" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">快速提示——我经常在<code class="fe nc nd ne nf b">useEffect</code>中调用其他函数，而不是直接在其中写太多代码，因为我更喜欢不能在<code class="fe nc nd ne nf b">useEffect</code>上直接使用的<code class="fe nc nd ne nf b">async/await</code>。</p><p id="d976" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果您想在安装该组件时获取帖子和作者的列表，您应该编写如下内容:</p><figure class="nh ni nj nk gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nn"><img src="../Images/4a8ce85f48cacf89f7d5e9e97dad64db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sA1Joun0TCazw0UF7lScLg.png"/></div></div></figure><p id="27ec" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这相当于:</p><figure class="nh ni nj nk gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi no"><img src="../Images/7b2842161256d71cbdd1edf8944acd4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1s5XpIZPzKf9ZQfm3opvLA.png"/></div></div></figure><p id="bde3" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不过需要注意的是，默认情况下，<code class="fe nc nd ne nf b">useEffect</code>会在每次渲染后运行<em class="le">。</em>换句话说，上面的例子实际上会让你陷入获取数据的无限循环中。那么，我们如何防止这种情况发生呢？</p><p id="d9fb" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe nc nd ne nf b">useEffect</code>可以接受第二个参数——状态变量数组。通过后，<code class="fe nc nd ne nf b">useEffect</code>将仅在检测到这些指定状态变量之一发生变化时<em class="le">才会运行。我喜欢把这个和状态中的<code class="fe nc nd ne nf b">loading</code>变量结合使用，就像这样:</em></p><figure class="nh ni nj nk gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi np"><img src="../Images/c8032953c4607657ec1094d4b0d13581.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m0qW9wJ5sgZZ721HI9HePw.png"/></div></div></figure><p id="d549" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这做了两件事。首先，它只在组件处于加载状态时运行<code class="fe nc nd ne nf b">fetchData</code>函数。由于在<code class="fe nc nd ne nf b">fetchData</code>结束时我们有<code class="fe nc nd ne nf b">setLoading(false)</code>，在这里设置状态后<code class="fe nc nd ne nf b">useEffect</code> <em class="le">将再次被调用</em>，但是由于加载现在为假，所以什么都不会运行，循环被打破。</p><p id="25b5" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第二，<code class="fe nc nd ne nf b">useEffect</code>只会在<code class="fe nc nd ne nf b">loading</code>状态对象被设置时运行。我们现在可以对我们状态中的文章和作者列表进行修改，而不需要再次运行<code class="fe nc nd ne nf b">useEffect</code>和获取数据。</p><h1 id="e489" class="lf lg jj bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">使用上下文</h1><p id="b47e" class="pw-post-body-paragraph kg kh jj ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">正如您可能已经猜到的，<code class="fe nc nd ne nf b">useContext</code>允许您在功能组件中使用上下文。如果不熟悉context，可以把它想成Redux的替代品。正如React文档所解释的:</p><blockquote class="mi mj mk"><p id="a827" class="kg kh le ki b kj kk kl km kn ko kp kq ml ks kt ku mm kw kx ky mn la lb lc ld im bi translated">接受一个上下文对象(从<code class="fe nc nd ne nf b">React.createContext</code>返回的值)并返回该上下文的当前上下文值。</p></blockquote><p id="a06e" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">实际上<code class="fe nc nd ne nf b">useContext</code>钩子看起来像这样，React上下文对象被导入，<em class="le">整个上下文对象</em>被传入<code class="fe nc nd ne nf b">useContext,</code> <em class="le">而不是</em>只有一个键。比如，你<em class="le">不要</em>直接把<code class="fe nc nd ne nf b">UserContext.username</code>传入<code class="fe nc nd ne nf b">useContext</code>。</p><figure class="nh ni nj nk gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nq"><img src="../Images/6ff0a2f6f23bdd54e8e0582c7805800d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tquAC_Rg81FncpG9_iGaSQ.png"/></div></div></figure><p id="8401" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的例子相当于:</p><figure class="nh ni nj nk gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi nr"><img src="../Images/1a7bea256c6f9cc25edbc7347b3a6e22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CYbMDOpx8ajS_N0Q4gmdjw.png"/></div></div></figure><h1 id="8f58" class="lf lg jj bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">深入React钩子</h1><p id="16b6" class="pw-post-body-paragraph kg kh jj ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">就像我之前提到的，这只是提供的三个主要挂钩。React提供了更多已经准备好并随时可以使用的钩子，以及一个非常酷的实际构建自己钩子的能力。您可以使用<a class="ae jg" href="https://reactjs.org/docs/hooks-overview.html" rel="noopener ugc nofollow" target="_blank"> React文档</a>更深入地研究这些主题。</p></div></div>    
</body>
</html>