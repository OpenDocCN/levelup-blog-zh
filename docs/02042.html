<html>
<head>
<title>Event Driven Programming in C#</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C#中的事件驱动编程</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/event-driven-programming-in-c-9264efb06c01?source=collection_archive---------1-----------------------#2020-02-15">https://levelup.gitconnected.com/event-driven-programming-in-c-9264efb06c01?source=collection_archive---------1-----------------------#2020-02-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/3ac89fc3d2226a1ab7eca65099896c9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*prbCRuGgy5Ibrlzb"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">卡罗尔·郑在<a class="ae kf" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="cd0e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从我作为一名系统管理员(用各种语言编写脚本——Bash、Python、PowerShell等)到现在作为一名开发人员/DevOps，我只真正地遵循过过程驱动编程。</p><p id="167c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我写软件的方法一直是:</p><ol class=""><li id="d4f5" class="le lf it ki b kj kk kn ko kr lg kv lh kz li ld lj lk ll lm bi translated">把一个问题分解成一系列更小的问题(步骤)</li><li id="1de4" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">写出解决每一步的方法(步骤)</li><li id="1cfa" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">按照正确的顺序调用这些过程，以解决原来的问题。</li></ol><p id="772b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以一个典型的程序应该是这样的:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="5bb2" class="mb mc it lx b gy md me l mf mg">public void DoSomething()<br/>{<br/>    DoStep1();<br/>    DoStep2();<br/>    if (SomeCondition())<br/>    {<br/>        DoStep3();<br/>    }<br/>}</span></pre><p id="a692" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我最近完成了一项编码挑战(工作面试的一部分),虽然我成功地满足了挑战指定的功能需求，但我收到的反馈是我未能展示我对事件驱动编程的理解。</p><p id="65be" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我承认，我一直认为事件驱动更适合前端(我主要在后端工作)。就像点击一个按钮…</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="878f" class="mb mc it lx b gy md me l mf mg">&lt;button onclick="myFunction()"&gt;Click me&lt;/button&gt;</span></pre><p id="9207" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以我开始研究如何用C#编写一个事件驱动的解决方案。</p><p id="6e8a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是我发现的。</p></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="91ac" class="mo mc it bd mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk bi translated">什么是事件驱动编程？</h1><p id="6a75" class="pw-post-body-paragraph kg kh it ki b kj nl kl km kn nm kp kq kr nn kt ku kv no kx ky kz np lb lc ld im bi translated">互联网上有大量的信息，所以我将简单地引用我认为最容易理解的定义:</p><blockquote class="nq nr ns"><p id="80ce" class="kg kh nt ki b kj kk kl km kn ko kp kq nu ks kt ku nv kw kx ky nw la lb lc ld im bi translated">基于事件的编程与旧形式的不同之处在于，以前，指令列表是以预先确定的固定顺序执行的，程序使用期间发生的下一件事是列表中的下一个点。此外，所有的程序都是由代理运行的，即计算机。<strong class="ki iu">在基于事件编程的条件下，对象(即用户)可以在程序中发起一些事件(“火灾事件”)，程序中接下来发生的事情由那些事件决定。</strong>因此，基于事件的编程促进了用户和计算机之间的动态交互。</p></blockquote><p id="3b50" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="nt">-“</em><a class="ae kf" href="https://www.rswebsols.com/tutorials/programming/event-driven-programming" rel="noopener ugc nofollow" target="_blank"><em class="nt">事件驱动编程:为什么现在流行了？</em> </a> <em class="nt">”，苏维克·班纳吉</em></p></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="0f9c" class="mo mc it bd mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk bi translated">在C#中实现发布者-订阅者模式</h1><p id="586e" class="pw-post-body-paragraph kg kh it ki b kj nl kl km kn nm kp kq kr nn kt ku kv no kx ky kz np lb lc ld im bi translated">发布者-订阅者(pub-sub)模式是实现事件驱动架构的一种形式。在这种模式中:</p><ul class=""><li id="a489" class="le lf it ki b kj kk kn ko kr lg kv lh kz li ld nx lk ll lm bi translated"><strong class="ki iu"> Publisher </strong>:公开事件的类；事件发射器。这是每个事件的起源。</li><li id="ef17" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld nx lk ll lm bi translated"><strong class="ki iu">订阅者</strong>:订阅你事件的类；事件处理程序。方法被定义来响应事件。</li></ul><p id="bbb1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在C#中，这个实现是通过使用<strong class="ki iu">事件处理程序</strong>和<strong class="ki iu">事件</strong>来完成的。我总结了以下4个步骤:</p><p id="f2c5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu"> #1 —定义事件。</strong></p><p id="2d4f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通常当一个事件发生时，我们需要传递一些关于它的信息。这是通过EventArgs完成的。</p><p id="ddd2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们的第一步是创建一个定制的EventArgs类，它包含我们想要的任何事件细节。</p><p id="9ea3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如:</p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="dfcc" class="mb mc it lx b gy md me l mf mg">public class SomeEventArgs : EventArgs<br/>{<br/>    public string Description{ get; set; }<br/>    public DateTime Date { get; set; }</span><span id="cebd" class="mb mc it lx b gy ny me l mf mg">public SomeEventArgs(string description, DateTime date)<br/>    {<br/>        Description = description;<br/>        Date = date;<br/>    }<br/>}</span></pre><p id="6160" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu"> #2 —定义发布者</strong></p><p id="ae69" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">发布者是<em class="nt">向</em>发送事件通知的类。这是通过使用<code class="fe nz oa ob lx b">event EventHandler</code>属性完成的，该属性充当<em class="nt">事件中枢</em>。</p><p id="3796" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">发布者可以向EventHandler发送事件通知。</p><p id="c485" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，其他对象可以订阅EventHandler，并在发送通知时响应事件。</p><ul class=""><li id="d553" class="le lf it ki b kj kk kn ko kr lg kv lh kz li ld nx lk ll lm bi translated">首先，添加一个公共eventhandler属性(使用步骤1中的eventArg类型)。</li><li id="8d3d" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld nx lk ll lm bi translated">就您要通知订阅者的操作发送事件通知。</li></ul><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="bf2a" class="mb mc it lx b gy md me l mf mg">public class Publisher<br/>{<br/>    // Add the public eventhandler<br/>    public event EventHandler&lt;SomeEventArgs&gt; OnSomeEvent;</span><span id="4682" class="mb mc it lx b gy ny me l mf mg">public void DoSomething()<br/>    {<br/>        // Do something here<br/>        RunSomeCode();</span><span id="f474" class="mb mc it lx b gy ny me l mf mg">        // Send a notification that an event has occurred<br/>        if (OnSomeEvent != null)<br/>        {<br/>            OnTransactionProcessed(this, new SomeEventArgs("something happened", DateTime.Now);<br/>        }<br/>    }<br/>}</span></pre><p id="0bbc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu"> #3 —定义用户</strong></p><p id="eaaa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">订户指的是对事件做出响应的类。</p><ul class=""><li id="50ab" class="le lf it ki b kj kk kn ko kr lg kv lh kz li ld nx lk ll lm bi translated">使用与发布者的eventhandler匹配的签名创建方法。这可以是一个私有方法。</li><li id="8771" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld nx lk ll lm bi translated">创建一个公共方法来订阅。</li></ul><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="05a4" class="mb mc it lx b gy md me l mf mg">public class Subscriber<br/>{<br/>    private void RespondToEvent(object sender, SomeEventArgs e)<br/>    {<br/>        DoStuff(e.Description, e.Date);<br/>    }</span><span id="262f" class="mb mc it lx b gy ny me l mf mg">public void Subscribe(Publisher publisher)<br/>    {<br/>        publisher.OnSomeEvent += RespondToEvent;<br/>    }<br/>}</span></pre><p id="5bdf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu"> #4 —记得订阅！</strong></p><pre class="ls lt lu lv gt lw lx ly lz aw ma bi"><span id="007c" class="mb mc it lx b gy md me l mf mg">public static void Main(string[] args)<br/>{<br/>    var pub = new Publisher();<br/>    var sub = new Subscriber();</span><span id="9579" class="mb mc it lx b gy ny me l mf mg">    sub.Subscribe(pub);<br/>    pub.DoSomething();<br/>}</span></pre></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="ea5d" class="mo mc it bd mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk bi translated">示例:审计服务</h1><p id="522c" class="pw-post-body-paragraph kg kh it ki b kj nl kl km kn nm kp kq kr nn kt ku kv no kx ky kz np lb lc ld im bi translated">在本例中，我编写了一个API来完成以下任务:</p><ul class=""><li id="2922" class="le lf it ki b kj kk kn ko kr lg kv lh kz li ld nx lk ll lm bi translated">处理交易(存款和取款)</li><li id="1c86" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld nx lk ll lm bi translated">处理的每个事务都需要写入审计日志</li></ul><p id="c845" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu"> <em class="nt">注意:</em> </strong> <em class="nt">本例中没有实现实际的处理和审计源，这更多地是为了演示过程驱动和事件驱动的方法。</em></p><h2 id="8402" class="mb mc it bd mp oc od dn mt oe of dp mx kr og oh nb kv oi oj nf kz ok ol nj om bi translated">程序范式</h2><p id="5490" class="pw-post-body-paragraph kg kh it ki b kj nl kl km kn nm kp kq kr nn kt ku kv no kx ky kz np lb lc ld im bi translated">这是我通常写这种东西的方式。</p><figure class="ls lt lu lv gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi on"><img src="../Images/20e14c3b688ec2a7183675b869d6f260.png" data-original-src="https://miro.medium.com/v2/resize:fit:556/format:webp/1*ZxGaQD3ULCww15-2K0gTSg.png"/></div></div></figure><figure class="ls lt lu lv gt ju gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/f2d7e6b42a309e9176a740e546064700.png" data-original-src="https://miro.medium.com/v2/resize:fit:956/format:webp/1*kLkA4Kdk0DR_-PZN8WEz5w.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">请求被路由到控制器类，控制器类将业务逻辑的执行交给服务类。在这个例子中，我已经创建了一个单独的审计服务，它必须在事务完成时由控制器显式调用。</figcaption></figure><figure class="ls lt lu lv gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi op"><img src="../Images/e1dbc23ae13b7f327d01e3afcf6a6a49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4c-E73ejSErP8DonWBRhcw.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><strong class="bd mp">交易控制器</strong>—ASP.Net核心控制器；接收HTTP请求并将值交给事务和审计服务进行处理</figcaption></figure><figure class="ls lt lu lv gt ju gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/ae2df5f0017305379d16eebf392fd5b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:918/format:webp/1*XOJNtP_fYcs7dGE0Y4xwEg.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><strong class="bd mp">事务服务</strong> —执行事务逻辑</figcaption></figure><figure class="ls lt lu lv gt ju gh gi paragraph-image"><div class="gh gi or"><img src="../Images/32b70de1f740baf86552c7c72283ebc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:848/format:webp/1*z10JCQ1AnBVL7JjKXi5gAA.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><strong class="bd mp">审计服务</strong> —执行审计逻辑</figcaption></figure><p id="9d85" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，这是我们在执行存款/取款时看到的情况:</p><figure class="ls lt lu lv gt ju gh gi paragraph-image"><div class="gh gi os"><img src="../Images/f9a354ee0217e3b6f31732cd787a70fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:870/format:webp/1*ryr3pcHM0tclTvewqM-z1A.png"/></div></figure></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h2 id="209e" class="mb mc it bd mp oc od dn mt oe of dp mx kr og oh nb kv oi oj nf kz ok ol nj om bi translated">事件驱动范式</h2><p id="efbd" class="pw-post-body-paragraph kg kh it ki b kj nl kl km kn nm kp kq kr nn kt ku kv no kx ky kz np lb lc ld im bi translated">使用前面的例子，我重构了代码，使用事件驱动的方法来编写审计日志。</p><p id="2b34" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是重构后的样子。</p><figure class="ls lt lu lv gt ju gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/99ddb096f959be15e18ba2f1b8e049ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:566/format:webp/1*eNa7fp0-4PA7RO4fdHyoMw.png"/></div></figure><p id="e476" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu"># 1——定义事件。</strong></p><p id="e38e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本例中，它是<em class="nt">事务处理事件</em>。</p><p id="cc98" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了应对这一事件，我需要知道两件事:</p><ol class=""><li id="2241" class="le lf it ki b kj kk kn ko kr lg kv lh kz li ld lj lk ll lm bi translated">交易类型—存款或取款</li><li id="cbf7" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">交易金额</li></ol><figure class="ls lt lu lv gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ou"><img src="../Images/8eb7175cfe0924933b4e75f310fe0b40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D6c9r8U8dMMFQ3uqoIsuNg.png"/></div></div></figure><p id="2d21" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu"> #2 —定义发布者</strong></p><p id="4010" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">记住，发布者是事件<em class="nt">产生</em>的地方。在这种情况下，它将是<em class="nt">事务服务</em>。</p><figure class="ls lt lu lv gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ov"><img src="../Images/818938ea90fd22323850dae2ef65a296.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9FCbFUBMzHHB72zrKEBC0g.png"/></div></div></figure><p id="2f7e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此处的主要变化:</p><ul class=""><li id="dfcd" class="le lf it ki b kj kk kn ko kr lg kv lh kz li ld nx lk ll lm bi translated">公开EventHandler属性以允许其他类订阅</li><li id="77bd" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld nx lk ll lm bi translated">在每个事务(MakeDeposit和MakeWithdrawl)之后，我们向OnTransactionProcessed eventhandler发送一个通知。</li></ul><p id="da56" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu"> #3 —定义用户</strong></p><p id="7e5b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">订户<em class="nt">对事件做出响应</em>。在本例中，它是<em class="nt">审计服务</em>。</p><figure class="ls lt lu lv gt ju gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/95f3e89b604b94a77cbf6a1692b4f095.png" data-original-src="https://miro.medium.com/v2/resize:fit:1390/format:webp/1*O7-KoCxXcG8ibP87zpfgjA.png"/></div></figure><p id="c343" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此处的主要变化:</p><ul class=""><li id="4cab" class="le lf it ki b kj kk kn ko kr lg kv lh kz li ld nx lk ll lm bi translated">新的Subscribe()方法允许AuditService订阅transaction service event handlers</li><li id="1ff3" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld nx lk ll lm bi translated">WriteAuditLog现在是订阅transaction processed eventhandler的方法。<br/>方法已更改为private，签名也已更改以适应eventhandler。</li></ul><p id="79c5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki iu"> #4 —更新控制器以管理发布订阅</strong></p><p id="6d9d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">控制器没有显式调用AuditService来写入审计日志，而是将AuditService设置为订阅事务服务中的TransactionProcessed事件。</p><figure class="ls lt lu lv gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ox"><img src="../Images/d4ff0393fc8a66ca9a56ed6e5a8fd722.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rHQw_Kpf663rVNAkSUIVmA.png"/></div></div></figure><p id="a076" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，当我们运行程序和执行一些事务时，我们仍然可以看到审计日志被写入。</p><figure class="ls lt lu lv gt ju gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/f135f30cad2247984356fad76922fda2.png" data-original-src="https://miro.medium.com/v2/resize:fit:868/format:webp/1*qZeMaR9O_D8d8HPISXw4EA.png"/></div></figure></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><h1 id="55e8" class="mo mc it bd mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk bi translated">参考</h1><ul class=""><li id="29ec" class="le lf it ki b kj nl kn nm kr oz kv pa kz pb ld nx lk ll lm bi translated"><a class="ae kf" href="https://codewithshadman.com/publish-subscribe-design-pattern-in-csharp/" rel="noopener ugc nofollow" target="_blank">https://codewithshadman . com/publish-subscribe-design-pattern-in-cs harp/</a></li><li id="50a1" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld nx lk ll lm bi translated"><a class="ae kf" href="https://docs.microsoft.com/en-us/dotnet/standard/events/" rel="noopener ugc nofollow" target="_blank">https://docs.microsoft.com/en-us/dotnet/standard/events/</a></li><li id="0abb" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld nx lk ll lm bi translated"><a class="ae kf" href="https://stackoverflow.com/questions/803242/understanding-events-and-event-handlers-in-c-sharp" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/803242/understanding-events-and-event-handlers-in-c-sharp</a></li><li id="f0fc" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld nx lk ll lm bi translated"><a class="ae kf" href="https://stackoverflow.com/questions/46824524/event-vs-eventhandler" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/46824524/event-vs-eventhandler</a></li></ul></div><div class="ab cl mh mi hx mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="im in io ip iq"><p id="2b70" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="nt">示例项目的代码可以在GitHub上找到:<br/></em><a class="ae kf" href="https://github.com/therealjordanlee/EventDrivenDemo" rel="noopener ugc nofollow" target="_blank">【https://github.com/therealjordanlee/EventDrivenDemo T21】</a></p><p id="e976" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您想了解从过程化方法到事件驱动方法的转变过程中发生了哪些变化，您可以查看git历史记录。</p><p id="af12" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="nt">如果你觉得这篇文章很有趣，你可能也想看看我写的关于使用观察者模式作为事件驱动编程的替代实现的后续文章:</em></p><div class="pc pd gp gr pe pf"><a rel="noopener  ugc nofollow" target="_blank" href="/event-driven-programming-in-c-observer-pattern-7a8d790bbdb2"><div class="pg ab fo"><div class="ph ab pi cl cj pj"><h2 class="bd iu gy z fp pk fr fs pl fu fw is bi translated">C#中的事件驱动编程——观察者模式</h2><div class="pm l"><h3 class="bd b gy z fp pk fr fs pl fu fw dk translated">在我之前的C#事件驱动编程文章中，我讲述了使用发布者-订阅者的基本知识…</h3></div><div class="pn l"><p class="bd b dl z fp pk fr fs pl fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="po l"><div class="pp l pq pr ps po pt jz pf"/></div></div></a></div><p id="cc5a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="nt">感谢阅读！</em></p></div></div>    
</body>
</html>