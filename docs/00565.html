<html>
<head>
<title>Deploying Go + React to Heroku using Docker, Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Docker将Go + React部署到Heroku，第1部分</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/deploying-go-react-to-heroku-using-docker-9844bf075228?source=collection_archive---------1-----------------------#2019-05-09">https://levelup.gitconnected.com/deploying-go-react-to-heroku-using-docker-9844bf075228?source=collection_archive---------1-----------------------#2019-05-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/e32a56e761e3e02073b5109ebcbc3ea2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zP188rnELzgULKPo"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">Guillaume Bolduc 在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="8ad9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有一堆如何做我将要写的大部分内容的指南和教程，但是没有一个能真正把我所有的东西整合在一起。我想要一些可以帮助我学习围棋的东西，但也有能力在某个地方推广它——Heroku是这样一个宠物项目的绝佳选择。这是3部分系列的第1部分:</p><ul class=""><li id="5b93" class="le lf it ki b kj kk kn ko kr lg kv lh kz li ld lj lk ll lm bi translated">第1部分—部署简单的服务器和客户机(本指南)</li><li id="30ce" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated"><a class="ae kf" href="https://medium.com/@deano.baker/deploying-go-react-to-heroku-using-docker-part-2-the-database-afaaaae66f81" rel="noopener">第二部分</a> —添加数据库</li><li id="0d67" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">第3部分—添加用户身份验证</li></ul><blockquote class="ls"><p id="af0a" class="lt lu it bd lv lw lx ly lz ma mb ld dk translated">你可以在这里看到完整的代码:<a class="ae kf" href="https://github.com/deandemo/react-go-heroku" rel="noopener ugc nofollow" target="_blank"> github </a></p></blockquote><h1 id="765a" class="mc md it bd me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz bi translated">你将建造什么</h1><p id="363f" class="pw-post-body-paragraph kg kh it ki b kj na kl km kn nb kp kq kr nc kt ku kv nd kx ky kz ne lb lc ld im bi translated">我们将在React.js中构建一个客户端，在Go中构建一个服务器，我们可以使用Docker将其部署到Heroku。我们还将有一个良好的当地发展环境。</p><h1 id="9b5d" class="mc md it bd me mf mg mh mi mj mk ml mm mn nf mp mq mr ng mt mu mv nh mx my mz bi translated">你需要什么</h1><p id="7c29" class="pw-post-body-paragraph kg kh it ki b kj na kl km kn nb kp kq kr nc kt ku kv nd kx ky kz ne lb lc ld im bi translated">您需要以下工具来开始:</p><ul class=""><li id="6415" class="le lf it ki b kj kk kn ko kr lg kv lh kz li ld lj lk ll lm bi translated">客户端节点(<a class="ae kf" href="https://nodejs.org/en/download/package-manager/#macos" rel="noopener ugc nofollow" target="_blank">安装</a>)</li><li id="eb7b" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">转到服务器(<a class="ae kf" href="https://golang.org/doc/install" rel="noopener ugc nofollow" target="_blank">安装</a>)</li><li id="59fc" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">码头工人部署东西(<a class="ae kf" href="https://docs.docker.com/get-started/" rel="noopener ugc nofollow" target="_blank">安装</a>)</li><li id="d90e" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">Heroku主持的东西(<a class="ae kf" href="https://signup.heroku.com/" rel="noopener ugc nofollow" target="_blank">免费账号</a>，<a class="ae kf" href="https://devcenter.heroku.com/articles/heroku-cli" rel="noopener ugc nofollow" target="_blank"> CLI工具</a>)</li><li id="826a" class="le lf it ki b kj ln kn lo kr lp kv lq kz lr ld lj lk ll lm bi translated">IDE(我使用了<a class="ae kf" href="https://code.visualstudio.com/" rel="noopener ugc nofollow" target="_blank"> VSCode </a>)</li></ul><h1 id="99b0" class="mc md it bd me mf mg mh mi mj mk ml mm mn nf mp mq mr ng mt mu mv nh mx my mz bi translated">入门指南</h1><p id="b1bb" class="pw-post-body-paragraph kg kh it ki b kj na kl km kn nb kp kq kr nc kt ku kv nd kx ky kz ne lb lc ld im bi translated">我们将创建一个根目录，它将保存单独的<strong class="ki iu">客户端</strong>和<strong class="ki iu">服务器</strong>目录，该根目录还将保存用于构建最终产品的<strong class="ki iu"> Dockerfile </strong>(这是一个文件，不是目录)。</p><pre class="ni nj nk nl gt nm nn no np aw nq bi"><span id="4c85" class="nr md it nn b gy ns nt l nu nv">project<br/>  |<br/>  |-client/<br/>  |-server/<br/>  |-Dockerfile</span></pre><h1 id="2c28" class="mc md it bd me mf mg mh mi mj mk ml mm mn nf mp mq mr ng mt mu mv nh mx my mz bi translated">Go服务器</h1><p id="2d4e" class="pw-post-body-paragraph kg kh it ki b kj na kl km kn nb kp kq kr nc kt ku kv nd kx ky kz ne lb lc ld im bi translated">首先，让我们创建一个API供前端使用。在您的服务器目录中创建一个新的Go模块，并创建一个初始的<strong class="ki iu"> main.go </strong>文件。</p><pre class="ni nj nk nl gt nm nn no np aw nq bi"><span id="6555" class="nr md it nn b gy ns nt l nu nv">$ <strong class="nn iu">go mod init github.com/deandemo/react-go-heroku</strong></span></pre><figure class="ni nj nk nl gt ju"><div class="bz fp l di"><div class="nw nx l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">创建main.go文件</figcaption></figure><p id="dcc2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里我们使用的是<a class="ae kf" href="https://github.com/gin-gonic/gin" rel="noopener ugc nofollow" target="_blank"> gin </a>，一个流行的网络框架来帮助路由，这个稍后会派上用场。</p><p id="9591" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您想了解应用程序的运行情况:</p><pre class="ni nj nk nl gt nm nn no np aw nq bi"><span id="d385" class="nr md it nn b gy ns nt l nu nv">$ <strong class="nn iu">go run main.go</strong></span><span id="6c72" class="nr md it nn b gy ny nt l nu nv"># You will have to run this in a new terminal<br/>$ <strong class="nn iu">curl localhost:8080/api/ping</strong></span></pre><h1 id="5001" class="mc md it bd me mf mg mh mi mj mk ml mm mn nf mp mq mr ng mt mu mv nh mx my mz bi translated">React入门</h1><blockquote class="nz oa ob"><p id="b8b7" class="kg kh oc ki b kj kk kl km kn ko kp kq od ks kt ku oe kw kx ky of la lb lc ld im bi translated">声明:这里生成的代码可能会随着React和<code class="fe og oh oi nn b">create-react-app</code>的发展而改变。</p></blockquote><p id="edb4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将利用facebook的<a class="ae kf" href="https://github.com/facebook/create-react-app" rel="noopener ugc nofollow" target="_blank"> <strong class="ki iu"> create-react-app </strong> </a>工具来快速搭建一个前端，所以跳到项目的<strong class="ki iu"> root </strong>目录并运行:</p><pre class="ni nj nk nl gt nm nn no np aw nq bi"><span id="0c6f" class="nr md it nn b gy ns nt l nu nv">$ <strong class="nn iu">npx create-react-app client</strong></span></pre><blockquote class="nz oa ob"><p id="de21" class="kg kh oc ki b kj kk kl km kn ko kp kq od ks kt ku oe kw kx ky of la lb lc ld im bi translated">因为我们正在创建一个mono-repo，所以请删除git存储库(<strong class="ki iu">)。git) </strong>在新创建的<strong class="ki iu"> /client </strong>目录下。</p></blockquote><h2 id="0982" class="nr md it bd me oj ok dn mi ol om dp mm kr on oo mq kv op oq mu kz or os my ot bi translated">PingComponent</h2><p id="2706" class="pw-post-body-paragraph kg kh it ki b kj na kl km kn nb kp kq kr nc kt ku kv nd kx ky kz ne lb lc ld im bi translated">让我们创建一个可以访问服务器的组件，在这种情况下，我们将使用<a class="ae kf" href="https://github.com/axios/axios" rel="noopener ugc nofollow" target="_blank"> axios </a>，一个流行的框架来帮助进行API调用。只需将以下文件放入react app的<strong class="ki iu"> src </strong>目录中，将该文件命名为<strong class="ki iu"> PingComponent.js </strong></p><p id="019e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在此代码生效之前，我们必须导入axios包:</p><pre class="ni nj nk nl gt nm nn no np aw nq bi"><span id="7672" class="nr md it nn b gy ns nt l nu nv"># From the /client/ directory run<br/>$ <strong class="nn iu">npm install axios --save</strong></span></pre><figure class="ni nj nk nl gt ju"><div class="bz fp l di"><div class="nw nx l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">PingComponent.js</figcaption></figure><p id="b6d2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意，在第13行，我们在<code class="fe og oh oi nn b">api/ping</code>调用一个端点，如果我们使用<strong class="ki iu"> npm start </strong>启动react应用程序，这将等同于点击<a class="ae kf" href="http://localhost:3000/api/ping" rel="noopener ugc nofollow" target="_blank"><strong class="ki iu">http://localhost:3000/API/ping</strong></a><strong class="ki iu"/>——稍后当我们连接我们的本地环境时，会有更多关于这方面的内容。</p><h2 id="f985" class="nr md it bd me oj ok dn mi ol om dp mm kr on oo mq kv op oq mu kz or os my ot bi translated">App.js</h2><p id="0039" class="pw-post-body-paragraph kg kh it ki b kj na kl km kn nb kp kq kr nc kt ku kv nd kx ky kz ne lb lc ld im bi translated">现在，我们可以用最简单的方式连接ping组件。在使用create-react-app工具创建的App.js文件中，添加以下内容:</p><figure class="ni nj nk nl gt ju"><div class="bz fp l di"><div class="nw nx l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">App.js</figcaption></figure><p id="b1e7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">注意第4行和第23行，这里我们导入并使用了我们的PingComponent。</p><h2 id="4c4c" class="nr md it bd me oj ok dn mi ol om dp mm kr on oo mq kv op oq mu kz or os my ot bi translated">地方发展代理人</h2><p id="2afa" class="pw-post-body-paragraph kg kh it ki b kj na kl km kn nb kp kq kr nc kt ku kv nd kx ky kz ne lb lc ld im bi translated">如果我们要启动我们的两个代码库，我们将在端口<strong class="ki iu"> 3000 </strong>上运行一个客户端，在端口<strong class="ki iu"> 8080 </strong>上运行一个服务器。这对于开发来说并不理想，所以我们可以通过添加一个<code class="fe og oh oi nn b">proxy</code>字段来修改我们的<strong class="ki iu"> package.json </strong>来配置客户端代理所有对API服务器的未知请求:</p><pre class="ni nj nk nl gt nm nn no np aw nq bi"><span id="cbe3" class="nr md it nn b gy ns nt l nu nv">"proxy": "<a class="ae kf" href="http://localhost:8080" rel="noopener ugc nofollow" target="_blank">http://localhost:8080</a>"</span></pre><h1 id="8cd9" class="mc md it bd me mf mg mh mi mj mk ml mm mn nf mp mq mr ng mt mu mv nh mx my mz bi translated">本地运行</h1><p id="20a8" class="pw-post-body-paragraph kg kh it ki b kj na kl km kn nb kp kq kr nc kt ku kv nd kx ky kz ne lb lc ld im bi translated">很好，现在我们有了一个服务器和一个能够代理请求的客户端。让我们试一试！</p><p id="0361" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">打开一个终端，首先启动服务器(如果它还没有运行)，然后使用<code class="fe og oh oi nn b">npm start</code>启动客户端。这应该会自动打开浏览器中的应用程序，你应该会看到成功！</p><pre class="ni nj nk nl gt nm nn no np aw nq bi"><span id="b025" class="nr md it nn b gy ns nt l nu nv"># From the /server directory<br/>$ <strong class="nn iu">go run main.go</strong></span><span id="f2d3" class="nr md it nn b gy ny nt l nu nv"># From the /client directory<br/>$ <strong class="nn iu">npm start</strong></span></pre><figure class="ni nj nk nl gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ou"><img src="../Images/07216e7368b22aa4a546b57b66f92477.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CDXgiMvijaQetXp-7-thwQ.png"/></div></div></figure><h1 id="362d" class="mc md it bd me mf mg mh mi mj mk ml mm mn nf mp mq mr ng mt mu mv nh mx my mz bi translated">码头工人</h1><p id="c0b3" class="pw-post-body-paragraph kg kh it ki b kj na kl km kn nb kp kq kr nc kt ku kv nd kx ky kz ne lb lc ld im bi translated">现在我们有了一个开发环境，让我们把这个东西“戳”出来。</p><h2 id="d9f0" class="nr md it bd me oj ok dn mi ol om dp mm kr on oo mq kv op oq mu kz or os my ot bi translated">Dockerfile文件</h2><p id="a3d1" class="pw-post-body-paragraph kg kh it ki b kj na kl km kn nb kp kq kr nc kt ku kv nd kx ky kz ne lb lc ld im bi translated">首先，我们将创建一个Docker容器来存放我们的生产代码。这将是可执行的Go程序，也是React应用程序的生产版本。为此，我们可以使用一个<a class="ae kf" href="https://docs.docker.com/develop/develop-images/multistage-build/" rel="noopener ugc nofollow" target="_blank">多阶段</a> docker构建，将该文本粘贴到位于我们项目根目录下的一个名为<code class="fe og oh oi nn b">Dockerfile</code>的文件中。</p><pre class="ni nj nk nl gt nm nn no np aw nq bi"><span id="d222" class="nr md it nn b gy ns nt l nu nv"># Build the Go API<br/>FROM golang:latest AS builder<br/>ADD . /app<br/>WORKDIR /app/server<br/>RUN go mod download<br/>RUN CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -ldflags "-w" -a -o /main .</span><span id="0ea8" class="nr md it nn b gy ny nt l nu nv"># Build the React application<br/>FROM node:alpine AS node_builder<br/>COPY --from=builder /app/client ./<br/>RUN npm install<br/>RUN npm run build</span><span id="2fd9" class="nr md it nn b gy ny nt l nu nv"># Final stage build, this will be the container<br/># that we will deploy to production<br/>FROM alpine:latest<br/>RUN apk --no-cache add ca-certificates<br/>COPY --from=builder /main ./<br/>COPY --from=node_builder /build ./web<br/>RUN chmod +x ./main<br/>EXPOSE 8080<br/>CMD ./main</span></pre><p id="1d5c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如您在这里看到的，我们实际上正在创建3个docker容器，第一个用于构建Go API，第二个用于React应用程序，第三个用于创建一个仅包含生产代码的轻量级容器——不需要提供依赖项和工具，只在构建时需要。</p><blockquote class="nz oa ob"><p id="ce66" class="kg kh oc ki b kj kk kl km kn ko kp kq od ks kt ku oe kw kx ky of la lb lc ld im bi translated">在我们开始之前，这里有一个小提示，创建一个<code class="fe og oh oi nn b">.dockerignore</code>文件，以确保我们不会将不必要的文件推到docker上下文中。在我们的例子中，这里的<code class="fe og oh oi nn b">client/node_modules</code>文件相当大。所以让我们把这个添加到<code class="fe og oh oi nn b">.dockerignore</code>文件中。</p></blockquote><pre class="ni nj nk nl gt nm nn no np aw nq bi"><span id="d559" class="nr md it nn b gy ns nt l nu nv">$ <strong class="nn iu">echo '**/node_modules' &gt; .dockerignore</strong></span></pre><h2 id="bc6a" class="nr md it bd me oj ok dn mi ol om dp mm kr on oo mq kv op oq mu kz or os my ot bi translated">运行docker容器</h2><pre class="ni nj nk nl gt nm nn no np aw nq bi"><span id="1675" class="nr md it nn b gy ns nt l nu nv">$ <strong class="nn iu">docker build -t golang-heroku .</strong><br/>$ <strong class="nn iu">docker run -p 3000:8080 -d golang-heroku</strong></span></pre><p id="7968" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe og oh oi nn b">docker build</code>将创建一个带有标签<code class="fe og oh oi nn b">golang-heroku</code>的图像，您现在可以使用run命令运行这个图像的一个实例。请注意，<code class="fe og oh oi nn b">docker run</code>命令正在转发我们的本地端口<code class="fe og oh oi nn b">3000</code>并将其转发到容器中的端口<code class="fe og oh oi nn b">8080</code>，这意味着我们现在可以在本地查看我们的工作。导航到<a class="ae kf" href="http://localhost:3000" rel="noopener ugc nofollow" target="_blank"> http://localhost:3000 </a>查看您的网站。</p><h1 id="ab8d" class="mc md it bd me mf mg mh mi mj mk ml mm mn nf mp mq mr ng mt mu mv nh mx my mz bi translated">赫罗库</h1><p id="b544" class="pw-post-body-paragraph kg kh it ki b kj na kl km kn nb kp kq kr nc kt ku kv nd kx ky kz ne lb lc ld im bi translated">我们现在有了一个我们希望Heroku服务的本地构建，这是一个简单的过程，每次我们将代码推送到Heroku远程，一个新的构建就会开始。Heroku将为我们负责docker的构建和部署！</p><p id="4b23" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我不会讲太多细节，但是让我们假设您已经创建了一个Heroku帐户，并且安装了CLI工具。请确保您已经登录:</p><pre class="ni nj nk nl gt nm nn no np aw nq bi"><span id="eae9" class="nr md it nn b gy ns nt l nu nv">$ <strong class="nn iu">heroku login</strong></span></pre><p id="204b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在项目的根目录下，添加一个名为<code class="fe og oh oi nn b">heroku.yml</code>的新文件——这将告诉Heroku如何部署我们的应用程序。</p><pre class="ni nj nk nl gt nm nn no np aw nq bi"><span id="f14f" class="nr md it nn b gy ns nt l nu nv">build:<br/>  docker:<br/>    web: Dockerfile<br/>    worker:<br/>       dockerfile: Dockerfile</span></pre><h2 id="a73e" class="nr md it bd me oj ok dn mi ol om dp mm kr on oo mq kv op oq mu kz or os my ot bi translated">饭桶</h2><p id="6e10" class="pw-post-body-paragraph kg kh it ki b kj na kl km kn nb kp kq kr nc kt ku kv nd kx ky kz ne lb lc ld im bi translated">如果您还没有，我们想在项目的根目录下创建一个git存储库。请确保您已经删除了<code class="fe og oh oi nn b">client/.git</code>目录，以避免git混乱。</p><pre class="ni nj nk nl gt nm nn no np aw nq bi"><span id="af96" class="nr md it nn b gy ns nt l nu nv">$ <strong class="nn iu">git init</strong><br/>$ <strong class="nn iu">git add .</strong><br/>$ <strong class="nn iu">git commit -m 'Initial Commit'</strong></span></pre><p id="1449" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这些命令应该通过一次提交创建一个初始存储库，其中包含我们所有的好工作。</p><p id="ab58" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在让我们创建一个新的Heroku应用程序:)</p><pre class="ni nj nk nl gt nm nn no np aw nq bi"><span id="aa26" class="nr md it nn b gy ns nt l nu nv">$ <strong class="nn iu">heroku create</strong><br/>Creating app... done, ⬢ hidden-chamber-90878<br/><a class="ae kf" href="https://hidden-chamber-90878.herokuapp.com/" rel="noopener ugc nofollow" target="_blank">https://hidden-chamber-90878.herokuapp.com/</a> | <a class="ae kf" href="https://git.heroku.com/hidden-chamber-90878.git" rel="noopener ugc nofollow" target="_blank">https://git.heroku.com/hidden-chamber-90878.git</a></span><span id="3a34" class="nr md it nn b gy ny nt l nu nv">$ <strong class="nn iu">heroku stack:set container</strong><br/>Stack set. Next release on ⬢ hidden-chamber-90878 will use container.<br/>Run git push heroku master to create a new release on ⬢ hidden-chamber-90878.</span></pre><p id="1620" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，我们创建了一个新的应用程序，您可以看到建议的URL和git remote(CLI工具已经为您的<code class="fe og oh oi nn b">.git/config</code>添加了一个Heroku remote)。然后，我们需要告诉Heroku，我们打算在这个堆栈中部署一个容器。完成后，我们可以继续部署。</p><pre class="ni nj nk nl gt nm nn no np aw nq bi"><span id="6336" class="nr md it nn b gy ns nt l nu nv">$ <strong class="nn iu">git add .<br/>$ git commit -m 'Initial commit'<br/>$ git push heroku master</strong></span><span id="f5e8" class="nr md it nn b gy ny nt l nu nv"># If you need to retrieve your prod url etc<br/>$ <strong class="nn iu">heroku apps:info</strong></span></pre><p id="f81b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这就是PAA真正神奇的地方！我修改了一点代码，也许是一些HTML，当我把它推到<code class="fe og oh oi nn b">heroku</code>遥控器上时，它就收起那个球，做了一大堆工作来创建一个新的不可变的容器来为我部署。</p><blockquote class="ls"><p id="04a4" class="lt lu it bd lv lw ov ow ox oy oz ld dk translated">通过网络推动小git提交(就像我在火车上的移动连接)并让Heroku为我构建和部署的想法非常令人兴奋！</p></blockquote><h1 id="7482" class="mc md it bd me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz bi translated">摘要</h1><p id="3699" class="pw-post-body-paragraph kg kh it ki b kj na kl km kn nb kp kq kr nc kt ku kv nd kx ky kz ne lb lc ld im bi translated">我认为这是一个很好的第一步，能够轻松地在本地工作，并随意将变更推向生产(让平台负责调配计算和部署)。</p><p id="2622" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是一个愚蠢的应用编程接口和客户就是不能切断它。在<a class="ae kf" href="https://medium.com/@deano.baker/deploying-go-react-to-heroku-using-docker-part-2-the-database-afaaaae66f81" rel="noopener">第2部分</a>中，我们将研究如何提供一个Heroku Postgres插件，让我们的本地开发从头开始，并确保我们可以在发布时使用Heroku在部署过程中的发布阶段推送和迁移数据库。</p></div></div>    
</body>
</html>