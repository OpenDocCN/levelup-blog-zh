<html>
<head>
<title>Doing AES/GCM in Android: adventures in the field</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Android中做AES/GCM:实地探险</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/doing-aes-gcm-in-android-adventures-in-the-field-72617401269d?source=collection_archive---------3-----------------------#2020-03-27">https://levelup.gitconnected.com/doing-aes-gcm-in-android-adventures-in-the-field-72617401269d?source=collection_archive---------3-----------------------#2020-03-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="0174" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Android开发生态系统还需要另一篇关于AES加密和解密的博客文章吗？可能不会，但就在本周，我被一系列让我措手不及的问题绊倒了，所以我决定分享我的经验，以防对别人有所帮助。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi km"><img src="../Images/8a844c5d894cb73b0569fea5b97f1c2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*-4OFZu0nsnWDKbN1EpOx5g.png"/></div></figure><blockquote class="ku kv kw"><p id="7b10" class="jn jo kl jp b jq jr js jt ju jv jw jx kx jz ka kb ky kd ke kf kz kh ki kj kk ij bi translated">TL；大卫:这是你怎么做的。如果您需要指定IV和AAD作为输入，<a class="ae la" href="https://gist.github.com/marcobrador/75b7164c7315e25db163bc04b9b9dfc2" rel="noopener ugc nofollow" target="_blank">这里有</a>一个变通办法(以及在<a class="ae la" href="https://gist.github.com/marcobrador/7fb741eb0c0c20840d59f4cc8164b29c" rel="noopener ugc nofollow" target="_blank">生成密钥</a>时需要的调整)——但是使用这种方法要非常小心！</p></blockquote><h1 id="5f8c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">问题是</h1><p id="c609" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">就在本周，我不得不设计一个加密API，它将允许我们使用预先存在的加密库和Android KeyStore API。这个想法是，在有硬件加密处理器的设备中，我们的软件将依靠它进行加密和解密；而在其余的设备中，它将退回到现有的库。这就需要一个通用的、抽象的API，允许软件的其他部分不需要知道使用的是哪种加密环境。加密和解密将在GCM模式下使用AES来完成。</p><p id="455f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">到目前为止，一切顺利。对吗？</p><h2 id="dd40" class="me lc iq bd ld mf mg dn lh mh mi dp ll jy mj mk lp kc ml mm lt kg mn mo lx mp bi translated">我在网上看到的</h2><p id="5a8b" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">因此，和其他开发人员一样，我上网搜索Android KeyStore API定义以及如何使用它的例子。简而言之，我的发现总结如下:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mq mr l"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">StackOverflow告诉我的</figcaption></figure><p id="992b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">看起来不错，不是吗？</p><p id="1f0f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">问题是输入和输出参数与我们先前存在的库使用的参数不匹配。根据我们现有的加密引擎:</p><ul class=""><li id="8703" class="mw mx iq jp b jq jr ju jv jy my kc mz kg na kk nb nc nd ne bi translated">加密例程还应该将一个<code class="fe nf ng nh ni b">iv</code>和<code class="fe nf ng nh ni b">aad</code>作为输入参数。</li><li id="8ed6" class="mw mx iq jp b jq nj ju nk jy nl kc nm kg nn kk nb nc nd ne bi translated">加密例程还应该返回一个<code class="fe nf ng nh ni b">tag</code>作为输出。</li><li id="3ffd" class="mw mx iq jp b jq nj ju nk jy nl kc nm kg nn kk nb nc nd ne bi translated">解密程序应该将<code class="fe nf ng nh ni b">aad</code>和<code class="fe nf ng nh ni b">tag</code>作为输入参数。</li></ul><p id="4c37" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">AES GCM不是标准<em class="kl">吗</em>？这些差异是如何产生的？</p><h1 id="8767" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak">一点理论</strong></h1><p id="2d63" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated"><em class="kl">如果你知道什么是</em><code class="fe nf ng nh ni b"><em class="kl">iv</em></code><em class="kl"/><code class="fe nf ng nh ni b"><em class="kl">aad</em></code><em class="kl"/><code class="fe nf ng nh ni b"><em class="kl">tag</em></code><em class="kl">就跳过这一节。如果你需要复习，你应该读一读。</em></p><p id="07a2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第一步是调查。我对这些参数并不陌生，但老实说，我不知道它们应该如何生成和使用。所以让我们后退一步，试着完全理解它们:</p><p id="7a2f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe nf ng nh ni b">iv</code>(<a class="ae la" href="https://en.wikipedia.org/wiki/Initialization_vector" rel="noopener ugc nofollow" target="_blank">初始化向量</a>的简称)是使用<a class="ae la" href="https://en.wikipedia.org/wiki/Block_cipher" rel="noopener ugc nofollow" target="_blank">分组密码</a>时的常用参数。它用于确保用相同的密钥对相同的数据加密两次会产生不同的输出，这就是为什么<code class="fe nf ng nh ni b">iv</code>永远不会被重用是非常重要的。</p><p id="dcab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另一方面，<code class="fe nf ng nh ni b">aad</code>和<code class="fe nf ng nh ni b">tag</code>仅用于<a class="ae la" href="https://en.wikipedia.org/wiki/Authenticated_encryption" rel="noopener ugc nofollow" target="_blank">认证加密</a>密码(有时也称为“AEAD”，是“带关联数据的认证加密”的简称)，如GCM模式下的AES:</p><ul class=""><li id="6f1d" class="mw mx iq jp b jq jr ju jv jy my kc mz kg na kk nb nc nd ne bi translated"><code class="fe nf ng nh ni b">tag</code>是加密程序的输出，然后被提供给解密程序以验证密文没有被篡改(也就是说:<em class="kl">验证</em>密文是用用于解密的相同密钥生成的)。</li><li id="e7a4" class="mw mx iq jp b jq nj ju nk jy nl kc nm kg nn kk nb nc nd ne bi translated"><code class="fe nf ng nh ni b">aad</code>代表“附加认证数据”，是用于计算<code class="fe nf ng nh ni b">tag</code>的加密和解密程序的输入。</li></ul><h1 id="e650" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">解决方案</h1><p id="9adf" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">不幸的是，对于我上面解释的所有差异，没有单一的解决方案。相反，对于每个参数，需要做不同的事情:</p><h2 id="3ed1" class="me lc iq bd ld mf mg dn lh mh mi dp ll jy mj mk lp kc ml mm lt kg mn mo lx mp bi translated">返回<code class="fe nf ng nh ni b">tag</code></h2><p id="fec7" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">让我们从简单的开始。经过一番寻找，我在<a class="ae la" href="https://docs.oracle.com/javase/7/docs/api/javax/crypto/Cipher.html#doFinal()" rel="noopener ugc nofollow" target="_blank"> Java文档</a>中找到了答案:</p><blockquote class="ku kv kw"><p id="cb99" class="jn jo kl jp b jq jr js jt ju jv jw jx kx jz ka kb ky kd ke kf kz kh ki kj kk ij bi translated">如果正在使用诸如GCM/CCM的AEAD模式，则在加密的情况下附加认证标签，或者在解密的情况下验证认证标签。</p></blockquote><p id="5dfc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">说白了:<code class="fe nf ng nh ni b">Cipher.doFinal()</code>方法(GCM模式下)加密时在密文末尾追加<code class="fe nf ng nh ni b">tag</code>，解密时验证(从密文末尾读取)。这意味着我现在可以写这样的东西:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mq mr l"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">标签现在可以作为单独的加密输出返回</figcaption></figure><h2 id="b123" class="me lc iq bd ld mf mg dn lh mh mi dp ll jy mj mk lp kc ml mm lt kg mn mo lx mp bi translated">那么aad呢？</h2><p id="cb2d" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">按照理论，加密和解密数据时也应该提供<code class="fe nf ng nh ni b">aad</code>，但是上面的代码片段中根本没有出现。答案还是在<a class="ae la" href="https://docs.oracle.com/javase/7/docs/api/javax/crypto/Cipher.html#updateAAD(byte[])" rel="noopener ugc nofollow" target="_blank"> Java文档</a>中，在那里我们可以找到方法<code class="fe nf ng nh ni b">Cipher.updateAAD(byte[] src)</code>。</p><p id="aa16" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">老实说，我不确定我是否理解了方法的描述。我能确定的是(因为我试过了)它确实影响到了所用的<code class="fe nf ng nh ni b">aad</code>:如果你试图在加密或解密中改变它，解密会以一个<code class="fe nf ng nh ni b">AEADBadTagException</code>失败，这意味着认证失败。</p><p id="0764" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们使用<code class="fe nf ng nh ni b">Cipher.updateAAD(byte[] src)</code>方法来定义<code class="fe nf ng nh ni b">aad</code>，我们的代码看起来会像这样:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mq mr l"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">推荐的方法</figcaption></figure><p id="60ea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意，我已经将<code class="fe nf ng nh ni b">aad</code>设置为加密例程的<em class="kl">输出</em>，而不是输入。这样做有一个原因，我稍后会解释。这里重要的是<strong class="jp ir">上面的代码展示了一种方法，我会推荐给任何寻找安全API来在Android中实现AES GCM加密和解密的人</strong>。</p><h2 id="7cd7" class="me lc iq bd ld mf mg dn lh mh mi dp ll jy mj mk lp kc ml mm lt kg mn mo lx mp bi translated">静脉注射</h2><p id="5945" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">但是我们还有一点不适合我们的另一个加密库:初始化向量应该是加密方法的输入，而不是输出。</p><p id="5ea1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">看起来使用<code class="fe nf ng nh ni b"><a class="ae la" href="https://docs.oracle.com/javase/7/docs/api/javax/crypto/spec/GCMParameterSpec.html" rel="noopener ugc nofollow" target="_blank">GCMParameterSpec</a></code>类我们可以做到:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mq mr l"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">提供IV和AAD作为加密方法的输入</figcaption></figure><p id="df09" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不幸的是，如果我们试图执行它，我们将会以一个异常结束:<code class="fe nf ng nh ni b">java.security.InvalidAlgorithmParameterException: Caller-provided IV not permitted</code>——我相信这是不言自明的:Android不允许我们指定和IV。句号。</p><p id="d76f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是，为什么呢？这是API 23中引入的一种行为，旨在确保调用者不会重用IVs，因为这可能会破坏分组密码的安全性(正如我之前解释的)。底线是:你不应该重复使用同一个密钥的IVs，为了确保Android在内部生成一个随机的。</p><p id="681d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">出于类似的原因，我认为最好在加密例程中生成<code class="fe nf ng nh ni b">aad</code>:以避免不知道自己在做什么的调用者提供固定值。通过在内部生成它，我们可以确保它是随机的。</p><p id="ec81" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是如果你<em class="kl">真的</em>需要(就像我需要的)提供<code class="fe nf ng nh ni b">iv</code>(和<code class="fe nf ng nh ni b">aad</code>)作为输入参数，你可以做一件事。创建AES密钥时，您可以使用<code class="fe nf ng nh ni b">setRandomizedEncryptionRequired()</code>方法明确请求Android允许您提供<code class="fe nf ng nh ni b">iv</code>作为输入。密钥生成方法将是:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mq mr l"/></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk translated">生成允许我们提供IV的AES密钥</figcaption></figure><p id="0aeb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不用说，<strong class="jp ir">只有当你真的知道自己在做什么的时候才这么做</strong>！特别是，如果你走这条路，确保你的<code class="fe nf ng nh ni b">iv</code>(和<code class="fe nf ng nh ni b">aad</code>)以一种适当的方式生成，并且对于你的用例足够随机。</p><h1 id="a213" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结束语</h1><p id="649d" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mb ka kb kc mc ke kf kg md ki kj kk ij bi translated">我认为公平地说，Java和Android APIs不容易实现与其他加密系统互操作的AES GCM。但是，为什么呢？这不应该是重点吗？</p><p id="d7b9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果有人感兴趣，这里是我对为什么这些API的设计者决定以这种方式实现它们的想法:</p><ul class=""><li id="19fb" class="mw mx iq jp b jq jr ju jv jy my kc mz kg na kk nb nc nd ne bi translated">关于<code class="fe nf ng nh ni b">tag</code>被包含在<code class="fe nf ng nh ni b">Cipher.doFinal()</code>的结果中，我认为很明显这里的要点是不要破坏JCE API。<code class="fe nf ng nh ni b">Cipher.doFinal()</code>多年来一直返回一个<code class="fe nf ng nh ni b">byte[]</code>，不管加密原语是什么，所以他们决定让它保持原样。</li><li id="e316" class="mw mx iq jp b jq nj ju nk jy nl kc nm kg nn kk nb nc nd ne bi translated">关于<code class="fe nf ng nh ni b">aad</code>，我相信如果它是<code class="fe nf ng nh ni b">GCMParameterSpec</code>构造函数的一部分会更好，但是我猜想在<code class="fe nf ng nh ni b">Cipher</code>类中将它作为一个方法是有原因的(我还不知道)。我<em class="kl">可以</em>说的是，文档远非清晰，更重要的是，它应该更具体地说明当调用者没有指定时使用哪个<code class="fe nf ng nh ni b">aad</code>值。</li><li id="e2c6" class="mw mx iq jp b jq nj ju nk jy nl kc nm kg nn kk nb nc nd ne bi translated">最后，IV:我喜欢Android(公平地说，还有iOS)为他们的加密API提供安全默认的方法。对于非密码专家来说，其他API(如JCE)提供的选择数量可能会令人望而生畏，因此最好默认提供最安全的选择。</li></ul></div></div>    
</body>
</html>