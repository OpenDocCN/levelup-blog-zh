<html>
<head>
<title>Amplify Bulk Data create, update &amp; migration</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">放大批量数据的创建、更新和迁移</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/amplify-bulk-data-create-update-migration-f178ab2a3e57?source=collection_archive---------11-----------------------#2022-02-27">https://levelup.gitconnected.com/amplify-bulk-data-create-update-migration-f178ab2a3e57?source=collection_archive---------11-----------------------#2022-02-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="f356" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看看如何填充或修改为Amplify GraphQL设置提供支持的数据。DynamoDB是GraphQL API或AppSync事实上的持久层。在Amplify中建立GraphQL模型是相当容易的，但是在高节奏的开发过程中修改模型是一件痛苦的事情。更有甚者，如果您的数据库已经填充了数据，那么您就需要自己将数据与新的模式模型进行协调。您需要考虑生产部署中的轻松过渡。</p><p id="aac8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以下部分将使用两种方法解决数据协调问题:</p><p id="6773" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> 1。使用GraphQL API。</strong></p><p id="a3bf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> 2。在DynamoDB后端直接操作数据。</strong></p><p id="cec2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们举一个例子。我正在React Native framework中开发一个移动应用程序。假设我已经用Amplify库设置了项目，下面是<em class="kl">‘schema . graph QL’</em>的一个片段</p><pre class="km kn ko kp gt kq kr ks kt aw ku bi"><span id="3fea" class="kv kw iq kr b gy kx ky l kz la">type Post @model @auth(rules: [{allow: public}]) {<br/>  id: ID!<br/>  title: String!<br/>  comments: [Comment] @hasMany(indexName: "byPost", fields: ["id"])<br/>  owner: String<br/>  content: String<br/>  status: String<br/>  tags:[Tag] @manyToMany(relationName:"taxonomy")<br/>  postTags: [PostTag] @hasMany(indexName: "byPost", fields: ["id"])<br/>  likes: [Like] @hasMany(indexName: "byPost", fields: ["id"])<br/>  stats: Stats @hasOne<br/>  ...<br/>}<br/><br/>type Tag @model @auth(rules: [{allow: public}]) {<br/>  id: ID!<br/>  name: String<br/>  postTags: [PostTag] @hasMany(indexName: "byTag", fields: ["id"])<br/>  count: Int<br/>  posts: [Post] @manyToMany(relationName:"taxonomy")<br/>  display: Boolean<br/>}<br/><br/>type Stats @model @auth(rules: [{allow: public}]) {<br/>  id: ID!<br/>  likes: Int<br/>  views: Int<br/>  responses: Int<br/>  postID: ID! @index(name: "byPost")<br/>  post: Post @hasOne(fields: ["postID"])<br/>}</span></pre><p id="1268" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">数据模型如下图所示:</p><figure class="km kn ko kp gt lb gh gi paragraph-image"><div class="ab gu cl lc"><img src="../Images/d1a6be3372634c8c173620ea572b3f56.png" data-original-src="https://miro.medium.com/v2/format:webp/1*s2Hks0eEfsPaIMzXeD1hyw.png"/></div><figcaption class="lf lg gj gh gi lh li bd b be z dk translated">Post、Tags和Stats的GraphQL模式数据模型</figcaption></figure><p id="012e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设我们需要添加数据，我们需要大致按照以下顺序填充后端</p><ol class=""><li id="5c4f" class="lj lk iq jp b jq jr ju jv jy ll kc lm kg ln kk lo lp lq lr bi translated">创建帖子</li><li id="9a4a" class="lj lk iq jp b jq ls ju lt jy lu kc lv kg lw kk lo lp lq lr bi translated">创建统计数据</li><li id="cf02" class="lj lk iq jp b jq ls ju lt jy lu kc lv kg lw kk lo lp lq lr bi translated">用Stats ID更新帖子(postStatsId字段)</li><li id="6a08" class="lj lk iq jp b jq ls ju lt jy lu kc lv kg lw kk lo lp lq lr bi translated">创建标签(如果不存在)</li><li id="6abd" class="lj lk iq jp b jq ls ju lt jy lu kc lv kg lw kk lo lp lq lr bi translated">填充分类模型(这是一个自动生成的模型)</li></ol><h2 id="d914" class="kv kw iq bd lx ly lz dn ma mb mc dp md jy me mf mg kc mh mi mj kg mk ml mm mn bi translated">1.使用GraphQL API。</h2><p id="a8b4" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">这是一个简单的例子。</p><ol class=""><li id="1a8e" class="lj lk iq jp b jq jr ju jv jy ll kc lm kg ln kk lo lp lq lr bi translated">使用Amplify CLI生成查询和变异</li><li id="1621" class="lj lk iq jp b jq ls ju lt jy lu kc lv kg lw kk lo lp lq lr bi translated">准备脚本文件(简单的NodeJS文件就足够了)</li><li id="d6fb" class="lj lk iq jp b jq ls ju lt jy lu kc lv kg lw kk lo lp lq lr bi translated">导入Amplify GraphQL API(当然，您将首先配置Amplify)</li><li id="d7a3" class="lj lk iq jp b jq ls ju lt jy lu kc lv kg lw kk lo lp lq lr bi translated">调用像<em class="kl"> createPost </em>和<em class="kl"> updateStats </em>这样的突变</li></ol><p id="fa7c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果修改相当简单，并且在更改模式模型之前已经提取了原始数据，那么使用GraphQL API方法是合适的。但是很快您将会手动编写大量GraphQL查询。您需要一种方法来读取提取的数据文件(CSV或TAB或EXCEL ),以迁移现有数据和新数据。</p><h2 id="17b9" class="kv kw iq bd lx ly lz dn ma mb mc dp md jy me mf mg kc mh mi mj kg mk ml mm mn bi translated">2.直接操作DynamoDB。</h2><p id="ff42" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">这是我发现的批量修改数据的最简单的方法。它还可以作为It组的一部分进行扩展，用于管理或数据管理。</p><p id="f165" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种方法的核心是使用一个名为<code class="fe mt mu mv kr b">dynamodb-toolbox</code>的包</p><p id="fd83" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将它安装在某个文件夹中，它可以在你的应用程序内，也可以在你的应用程序外。这真的取决于你的偏好:</p><pre class="km kn ko kp gt kq kr ks kt aw ku bi"><span id="3300" class="kv kw iq kr b gy kx ky l kz la">npm i dynamodb-toolbox</span></pre><p id="4a5e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从GitHub获得软件包的文档:<a class="ae mw" href="https://github.com/jeremydaly/dynamodb-toolbox" rel="noopener ugc nofollow" target="_blank">https://github.com/jeremydaly/dynamodb-toolbox</a></p><p id="cb1e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于每一个操作，您将大致执行以下操作:</p><ol class=""><li id="e46c" class="lj lk iq jp b jq jr ju jv jy ll kc lm kg ln kk lo lp lq lr bi translated">定义实体-您的模型</li><li id="2b9e" class="lj lk iq jp b jq ls ju lt jy lu kc lv kg lw kk lo lp lq lr bi translated">定义DynamoDB表—实际的DynamoDB表表示</li><li id="136e" class="lj lk iq jp b jq ls ju lt jy lu kc lv kg lw kk lo lp lq lr bi translated">调用实体上的方法来列出、创建、更新或删除数据上的操作</li></ol><p id="edcb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">定义它们最好的部分是相当容易的，我们不需要完全编码模型。编写我们需要的代码。例如，如果我只需要操作一列，那么只需要在表中定义该列，在实体中定义属性。</p><p id="d25b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用时区格式更新“createdAt”日期的脚本文件如下所示:</p><pre class="km kn ko kp gt kq kr ks kt aw ku bi"><span id="52d3" class="kv kw iq kr b gy kx ky l kz la">const { Table, Entity } = require("dynamodb-toolbox");<br/>const DynamoDB = require("aws-sdk/clients/dynamodb");<br/>const DocumentClient = new DynamoDB.DocumentClient({region:"us-east-1"});<br/><br/>// Instantiate a table<br/>const MyTable = new Table({<br/>  // Specify table name (used by DynamoDB)<br/>  name: "Post-xxxxxxxxxx-dev",<br/><br/>  // Define partition and sort keys<br/>  partitionKey: "id",<br/>  sortKey: "",<br/>  entityField: false,<br/><br/>  // Add the DocumentClient<br/>  DocumentClient,<br/>});<br/><br/>const Post = new Entity({<br/>  name: "Post",<br/>  timestamps: false,<br/><br/>  attributes: {<br/>    id: { partitionKey: true },<br/>    createdAt: {type: "string"},<br/><br/>  },<br/>  table: MyTable,<br/>})<br/><br/>let item = {<br/>  id: 32,<br/><br/>}<br/><br/>const updateTable = async () =&gt;{<br/>  let result = await MyTable.scan({<br/>    limit :150,//No need to paginate, get everything<br/>    execute: true,<br/>    parse: true<br/>  });<br/>  <br/>  result.Items.map( async (item) =&gt; {<br/>    let createdDate = item.createdAt;<br/>    createdDate = createdDate.replaceAll(" ","T");<br/>    if(createdDate.lastIndexOf("Z") &lt; 0 ) <br/>	createdDate = createdDate + ".001Z";<br/><br/>    const params = {<br/>      id: item.id,<br/>      createdAt: createdDate<br/>    }<br/>    <br/>    let updateResult = await Post.update(<br/>		params, <br/>		{execute: true, parse: true}<br/>	);<br/>    console.log("updateResult :", updateResult);<br/>  })<br/><br/>  return "Completed";<br/>} ;<br/><br/>updateTable().then(<br/>    (data)=&gt;console.log("Done", data),<br/>    (err)=&gt;console.log("err", err),<br/>);</span></pre><p id="eb02" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里需要注意几件事:</p><ol class=""><li id="cec9" class="lj lk iq jp b jq jr ju jv jy ll kc lm kg ln kk lo lp lq lr bi translated">确保在表格定义中设置了<code class="fe mt mu mv kr b">entityField: false,</code>。默认情况下，库添加类型名称列。我们不需要它，因为它已经由Amplify GraphQL生成。</li><li id="a8c9" class="lj lk iq jp b jq ls ju lt jy lu kc lv kg lw kk lo lp lq lr bi translated">在实体定义中设置<code class="fe mt mu mv kr b">timestamps: false,</code>。否则，库添加<em class="kl">创建的</em>和<em class="kl">修改的</em>时间戳。同样，这些信息已经被Amplify GraphQL库处理了。我们这里不需要他们。</li><li id="b1ad" class="lj lk iq jp b jq ls ju lt jy lu kc lv kg lw kk lo lp lq lr bi translated">dynamo-db的读取容量决定了您可以在“扫描”表中设置的限制。如果读取容量耗尽，请在查询中使用分页。<code class="fe mt mu mv kr b">dynamodb-toolbox </code>提供了一个简单的<code class="fe mt mu mv kr b">.next()</code>方法来处理分页。</li></ol><p id="e8c3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">回到我们的例子，我们可以在一个脚本中定义所有的实体和表，并在一个事务中快速添加它们。</p><h2 id="8be5" class="kv kw iq bd lx ly lz dn ma mb mc dp md jy me mf mg kc mh mi mj kg mk ml mm mn bi translated">结论</h2><p id="eb57" class="pw-post-body-paragraph jn jo iq jp b jq mo js jt ju mp jw jx jy mq ka kb kc mr ke kf kg ms ki kj kk ij bi translated">Amplify GraphQL API库最适合使用DynamoDB持久层启动移动应用后端。然而，我们需要使用额外的工具来管理数据。<code class="fe mt mu mv kr b">dynamodb-toolbox </code>将加速批量迁移和数据操作。</p><p id="9736" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">关注我@vadionline，了解更多使用由AWS Amplify支持的React Native、Flutter进行移动应用开发的发现。</p></div></div>    
</body>
</html>