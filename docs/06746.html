<html>
<head>
<title>CMake Variable Scope</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">CMake变量范围</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/cmake-variable-scope-f062833581b7?source=collection_archive---------0-----------------------#2020-12-27">https://levelup.gitconnected.com/cmake-variable-scope-f062833581b7?source=collection_archive---------0-----------------------#2020-12-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5029" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">CMake中的add _子目录vs include、函数vs宏</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/afc368ae37c2912c94837d79723e6a73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3eCQbhulKD6ibrWR2-k7LQ.png"/></div></div></figure><h1 id="854a" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">介绍</h1><p id="d4ea" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">您可能已经知道，CMake是一个流行的管理软件构建过程的开源工具。</p><p id="28fe" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">使用CMake，您可以定义变量以及一组指令和指示来描述您的项目过程(构建、测试、打包等)。您可以将CMake中的变量视为其他编程语言中的变量。现在，你一定在想，变量是编程中的一个基本概念，没有什么复杂的。然而，CMake变量的“作用域”的概念可能很难理解，如果您事先不知道，它可能会减慢您的日常开发。在这篇文章中，我将用简单的例子和图表解释CMake变量的范围。</p><h1 id="af7e" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">add_subdirectory()与include()</h1><p id="4e71" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">首先，让我们看看下面的简单示例CMake项目。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="fffd" class="ms kv it mo b gy mt mu l mv mw">cmake_variable_scope_tutorial<br/>├── child  // child could be a some library in practice.<br/>│   └── CMakeLists.txt  // child<br/>└── CMakeLists.txt     // parent</span></pre><p id="c889" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">它有一个父CMakeLists.txt文件，如下所示。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="b3b8" class="ms kv it mo b gy mt mu l mv mw"># parent CMakeLists.txt</span><span id="2041" class="ms kv it mo b gy mx mu l mv mw">cmake_minimum_required(VERSION 3.2)<br/>project(CMakeVariableScopeTutorial)</span><span id="aeb0" class="ms kv it mo b gy mx mu l mv mw">set(A "Parent")</span><span id="6b35" class="ms kv it mo b gy mx mu l mv mw"><strong class="mo iu">add_subdirectory(child)</strong></span><span id="0c77" class="ms kv it mo b gy mx mu l mv mw">message(STATUS ${A}) # <strong class="mo iu">Prints "Parent"</strong></span></pre><p id="80b1" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">它将变量<code class="fe my mz na mo b">A</code>设置为<code class="fe my mz na mo b">“Parent”</code>，然后调用<code class="fe my mz na mo b">add_subdirectory</code>将<code class="fe my mz na mo b">child</code>目录添加到构建中。CMakeLists.txt子文件如下所示。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="85a4" class="ms kv it mo b gy mt mu l mv mw"># child CMakeLists.txt</span><span id="67cc" class="ms kv it mo b gy mx mu l mv mw">set(A "Child")</span></pre><p id="44dc" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">如你所见，它只是将变量<code class="fe my mz na mo b">A</code>设置为<code class="fe my mz na mo b">“Child”</code>。乍一看，父CMakeLists.txt和子CMakeLists.txt文件似乎共享同一个变量<code class="fe my mz na mo b">A</code>。所以，你可能会猜测<code class="fe my mz na mo b">A</code>最终会更新为<code class="fe my mz na mo b">“Child”</code>，并且<code class="fe my mz na mo b">message</code>命令会打印出<code class="fe my mz na mo b">“Child”</code>。然而，有一个问题。事实证明，当执行cmake时，它打印出<strong class="lo iu"> </strong> <code class="fe my mz na mo b"><strong class="lo iu">“Parent”</strong></code>作为<code class="fe my mz na mo b">A</code>的值。</p><p id="0573" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">这是为什么呢？为了理解这个结果，我们必须看看<code class="fe my mz na mo b">add_subdirectory</code>的行为。实际上，当执行<code class="fe my mz na mo b">add_subdirectory</code>时，它会创建一个单独的作用域来处理子CMakeLists.txt，并为新创建的作用域创建一个<code class="fe my mz na mo b">A</code>的副本。下图解释了这种行为。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nb"><img src="../Images/3a6df9c0fe5fc67b5ba0292dfe02e2c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jGGvhYHJNEJxT7zD63icXA.png"/></div></div></figure><p id="deea" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">如您所见，它在子范围中创建了一个<code class="fe my mz na mo b">A</code> ( <code class="fe my mz na mo b">A’</code>)的副本。写入子CMakeLists.txt中的<code class="fe my mz na mo b">A</code>实际上是写入<code class="fe my mz na mo b"> A’</code>。所以，父作用域中原来的<code class="fe my mz na mo b">A</code>变量不受影响。</p><p id="03c3" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">接下来，让我们检查调用<code class="fe my mz na mo b">include</code>而不是<code class="fe my mz na mo b">add_subdirectory</code>的行为。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="882b" class="ms kv it mo b gy mt mu l mv mw"># parent CMakeLists.txt</span><span id="bd30" class="ms kv it mo b gy mx mu l mv mw">cmake_minimum_required(VERSION 3.2)<br/>project(CMakeVariableScopeTutorial)</span><span id="11b7" class="ms kv it mo b gy mx mu l mv mw">set(A "Parent")</span><span id="018f" class="ms kv it mo b gy mx mu l mv mw"><strong class="mo iu">include</strong>(child/CMakeLists.txt)</span><span id="d024" class="ms kv it mo b gy mx mu l mv mw">message(STATUS ${A}) # <strong class="mo iu">Prints "Child"</strong></span></pre><p id="9b00" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">在这种情况下，它打印<strong class="lo iu"> </strong> <code class="fe my mz na mo b"><strong class="lo iu">“Child”</strong></code>。这是因为，与<code class="fe my mz na mo b">add_subdirectory</code>相反，<code class="fe my mz na mo b">include</code>不会创建一个单独的作用域来处理包含的文件，而是共享同一个作用域。这也是为什么这次写入子CMakeLists.txt中的<code class="fe my mz na mo b">A</code>被反映到父作用域中的<code class="fe my mz na mo b">A</code>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nc"><img src="../Images/fd776d210eeb737c7b3fefd193fc2a13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0PRBYJVoj81eHQwkxj1ikA.png"/></div></div></figure><p id="d0d5" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">那么如果你正在使用<code class="fe my mz na mo b">add_subdirectory</code>并且需要更新子目录中的一个变量，你能做什么呢？解决办法很简单。你可以使用<code class="fe my mz na mo b"><strong class="lo iu">PARENT_SCOPE</strong></code>选项，当你设置一个值给子变量时。下面是例子。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="2a93" class="ms kv it mo b gy mt mu l mv mw"># child CMakeLists.txt</span><span id="eaea" class="ms kv it mo b gy mx mu l mv mw">set(A "Child" <strong class="mo iu">PARENT_SCOPE</strong>)</span></pre><p id="aac0" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">这告诉CMake更新父变量范围内的原始<code class="fe my mz na mo b">A</code>变量。父CMakeLists.txt和之前一样，只是这次的<code class="fe my mz na mo b">message</code>命令打印的是<code class="fe my mz na mo b">“Child”</code>。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="d38c" class="ms kv it mo b gy mt mu l mv mw"># parent CMakeLists.txt</span><span id="a0d1" class="ms kv it mo b gy mx mu l mv mw">cmake_minimum_required(VERSION 3.2)<br/>project(CMakeVariableScopeTutorial)</span><span id="28c5" class="ms kv it mo b gy mx mu l mv mw">set(A "Parent")</span><span id="3e3f" class="ms kv it mo b gy mx mu l mv mw"><strong class="mo iu">add_subdirectory</strong>(child)</span><span id="6191" class="ms kv it mo b gy mx mu l mv mw">message(STATUS ${A})  # <strong class="mo iu">Prints "Child"</strong></span></pre><p id="6404" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">下图描述了该行为。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nd"><img src="../Images/3741cefa16f6b48e1a72eab612cde77f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GDB14MRwLsZOWH6m0lcPBg.png"/></div></div></figure><p id="f2b9" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">同样，如果你在下面的童趣中打印<code class="fe my mz na mo b">A</code>变量的值，它打印的是<code class="fe my mz na mo b">“Parent”</code>，而不是<code class="fe my mz na mo b">“Child”</code>。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="7a3b" class="ms kv it mo b gy mt mu l mv mw"># child CMakeLists.txt</span><span id="0cce" class="ms kv it mo b gy mx mu l mv mw">set(A "Child" PARENT_SCOPE)</span><span id="6aae" class="ms kv it mo b gy mx mu l mv mw">message(STATUS ${A}) // <strong class="mo iu">Prints "Parent" (Read A')</strong></span></pre><p id="8f17" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">乍一看这可能令人惊讶，但这是因为如前所述，<code class="fe my mz na mo b">add_subdirectory</code>在子作用域中创建了<code class="fe my mz na mo b">A</code> ( <code class="fe my mz na mo b">A’</code>)的副本，并且<code class="fe my mz na mo b">message</code>函数中的<code class="fe my mz na mo b">A </code>变量指向<code class="fe my mz na mo b">A’</code>，而不是父作用域中的<code class="fe my mz na mo b">A</code>。同时，<code class="fe my mz na mo b">A’</code>保存一个最初从<code class="fe my mz na mo b">A</code>复制的值，该值为<code class="fe my mz na mo b">“Parent”</code>。</p><p id="a781" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">现在我们已经看到了变量作用域在<code class="fe my mz na mo b">add_subdirectory</code>和<code class="fe my mz na mo b">include</code>情况下的不同行为。接下来，我们将看看<code class="fe my mz na mo b">function</code>和<code class="fe my mz na mo b">macro</code>在变量范围方面的行为。幸运的是，我们到目前为止使用的相同推理和图表可以应用于<code class="fe my mz na mo b">function</code>和<code class="fe my mz na mo b">macro</code>。</p><h1 id="f9c9" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">函数与宏</h1><p id="a4dd" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">这一次，我们进一步简化了示例项目。现在它只有一个CMakeLists.txt。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="b34c" class="ms kv it mo b gy mt mu l mv mw">cmake_variable_scope_tutorial<br/>└── CMakeLists.txt</span></pre><p id="7a4c" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">CMakeLists.txt如下所示。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="02d6" class="ms kv it mo b gy mt mu l mv mw"># CMakeLists.txt</span><span id="0eea" class="ms kv it mo b gy mx mu l mv mw">cmake_minimum_required(VERSION 3.2)<br/>project(CMakeVariableScopeTutorial)</span><span id="0b4f" class="ms kv it mo b gy mx mu l mv mw"><strong class="mo iu">function(func)</strong><br/>    set(A "Child")<br/><strong class="mo iu">endfunction()</strong></span><span id="1a96" class="ms kv it mo b gy mx mu l mv mw">set(A "Parent")</span><span id="3f77" class="ms kv it mo b gy mx mu l mv mw"><strong class="mo iu">func()</strong></span><span id="5de0" class="ms kv it mo b gy mx mu l mv mw">message(STATUS ${A}) # <strong class="mo iu">Prints "Parent"</strong></span></pre><p id="9ef5" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">如您所见，它定义了一个名为<code class="fe my mz na mo b">func</code>的函数，将<code class="fe my mz na mo b">A</code>设置为<code class="fe my mz na mo b">“Child”</code>。并且在<code class="fe my mz na mo b">A</code>被设置为<code class="fe my mz na mo b">“Parent”</code>后调用<code class="fe my mz na mo b">func</code>。如果我们执行它，它会打印出<code class="fe my mz na mo b"><strong class="lo iu">“Parent”</strong></code>。</p><p id="c098" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">即使我们把<code class="fe my mz na mo b">A</code>作为<code class="fe my mz na mo b">func</code>的一个参数传递，结果还是和之前一样。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="98df" class="ms kv it mo b gy mt mu l mv mw"># CMakeLists.txt</span><span id="cdc8" class="ms kv it mo b gy mx mu l mv mw">cmake_minimum_required(VERSION 3.2)<br/>project(CMakeVariableScopeTutorial)</span><span id="e9ac" class="ms kv it mo b gy mx mu l mv mw">function(func <strong class="mo iu">param</strong>)<br/>    set(<strong class="mo iu">${param}</strong> "Child")<br/>endfunction()</span><span id="7275" class="ms kv it mo b gy mx mu l mv mw">set(A "Parent")</span><span id="acd4" class="ms kv it mo b gy mx mu l mv mw">func(<strong class="mo iu">A</strong>)</span><span id="a952" class="ms kv it mo b gy mx mu l mv mw">message(STATUS ${A}) # <strong class="mo iu">Prints "Parent"</strong></span></pre><p id="089d" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">这是为什么呢？这是因为<code class="fe my mz na mo b">function</code>创建了一个单独的新作用域，并从父作用域创建了变量的副本，就像我们调用<code class="fe my mz na mo b">add_subdirectory</code>时一样。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/4d40980aae66fdbc1be65a6328e38a15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5T8b5u0KVPEZZfxDPFFpAA.png"/></div></div></figure><p id="ec06" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">现在，让我们看看用<code class="fe my mz na mo b">macro</code>替换<code class="fe my mz na mo b">func</code>。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="a132" class="ms kv it mo b gy mt mu l mv mw"># CMakeLists.txt</span><span id="9ca6" class="ms kv it mo b gy mx mu l mv mw">cmake_minimum_required(VERSION 3.2)<br/>project(CMakeVariableScopeTutorial)</span><span id="25ad" class="ms kv it mo b gy mx mu l mv mw"><strong class="mo iu">macro(mac)</strong><br/>    set(A "Child")<br/><strong class="mo iu">endmacro()</strong></span><span id="5956" class="ms kv it mo b gy mx mu l mv mw">set(A "Parent")</span><span id="0dd0" class="ms kv it mo b gy mx mu l mv mw"><strong class="mo iu">mac(A)</strong></span><span id="fee6" class="ms kv it mo b gy mx mu l mv mw">message(STATUS ${A}) # <strong class="mo iu">Prints "Child"</strong></span></pre><p id="31cc" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">事实证明，它这次打印的是<strong class="lo iu"> </strong> <code class="fe my mz na mo b"><strong class="lo iu">“Child”</strong></code>。这是因为当我们调用<code class="fe my mz na mo b">include</code>时<code class="fe my mz na mo b">macro</code>与父节点共享范围。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nf"><img src="../Images/b30a8a4d7c4197cd60670e6331c67825.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TALyVZ80_Xq3S9CXwMhrZw.png"/></div></div></figure><p id="6004" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">同样，您可以使用<code class="fe my mz na mo b"><strong class="lo iu">PARENT_SCOPE</strong></code> <strong class="lo iu"> </strong>选项来改变<code class="fe my mz na mo b">function</code>的行为，就像我们对<code class="fe my mz na mo b">add_subdirectory</code>案例所做的那样。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="c55b" class="ms kv it mo b gy mt mu l mv mw"># CMakeLists.txt</span><span id="9570" class="ms kv it mo b gy mx mu l mv mw">cmake_minimum_required(VERSION 3.2)<br/>project(CMakeVariableScopeTutorial)</span><span id="0546" class="ms kv it mo b gy mx mu l mv mw">function(func)<br/>    set(A "Child" <strong class="mo iu">PARENT_SCOPE</strong>)<br/>endfunction()</span><span id="0198" class="ms kv it mo b gy mx mu l mv mw">set(A "Parent")</span><span id="0a7d" class="ms kv it mo b gy mx mu l mv mw">func()</span><span id="28c9" class="ms kv it mo b gy mx mu l mv mw">message(STATUS ${A}) #<strong class="mo iu"> Prints "Child"</strong></span></pre><p id="d728" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">这使得<code class="fe my mz na mo b">set</code>函数指向父作用域中的<code class="fe my mz na mo b">A</code>,并使得从<code class="fe my mz na mo b">function</code>内部更新它成为可能。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/c7b1b413223506508a1a20ec94de0385.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TAuUnbN0_Z1LC5A-HWcSmw.png"/></div></div></figure><p id="f63a" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">通常，你给<code class="fe my mz na mo b">A</code>作为<code class="fe my mz na mo b">function</code>的输出参数，这样任何看到<code class="fe my mz na mo b">function</code>的人都可以知道哪个变量将被<code class="fe my mz na mo b">function</code>覆盖，调用者也可以显式地传递这个变量。</p><pre class="kj kk kl km gt mn mo mp mq aw mr bi"><span id="d440" class="ms kv it mo b gy mt mu l mv mw"># CMakeLists.txt</span><span id="258a" class="ms kv it mo b gy mx mu l mv mw">cmake_minimum_required(VERSION 3.2)<br/>project(CMakeVariableScopeTutorial)</span><span id="c73a" class="ms kv it mo b gy mx mu l mv mw">function(func <strong class="mo iu">output</strong>)<br/>    set(${<strong class="mo iu">output</strong>} "Child" PARENT_SCOPE)<br/>endfunction()</span><span id="8618" class="ms kv it mo b gy mx mu l mv mw">set(A "Parent")</span><span id="e2f7" class="ms kv it mo b gy mx mu l mv mw">func(A)</span><span id="c852" class="ms kv it mo b gy mx mu l mv mw">message(STATUS ${A}) #<strong class="mo iu"> Prints "Child"</strong></span></pre><h1 id="2831" class="ku kv it bd kw kx ky kz la lb lc ld le jz lf ka lg kc lh kd li kf lj kg lk ll bi translated">结论</h1><p id="a41d" class="pw-post-body-paragraph lm ln it lo b lp lq ju lr ls lt jx lu lv lw lx ly lz ma mb mc md me mf mg mh im bi translated">CMake变量像其他编程语言中的变量一样有作用域的概念。一些CMake指令、命令如<code class="fe my mz na mo b">add_subdirectory</code>、<code class="fe my mz na mo b">include</code>、<code class="fe my mz na mo b">function</code>和<code class="fe my mz na mo b">macro</code> ⁴根据变量范围表现出不同的行为。</p><p id="1253" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">你可以记住<code class="fe my mz na mo b">add_subdirectory</code>和<code class="fe my mz na mo b">function</code>都创建了一个新的作用域和副本，但是<code class="fe my mz na mo b">include</code>和<code class="fe my mz na mo b">macro</code>只是与父对象(它们被调用的地方)共享作用域。</p><p id="6ca6" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">使用CMake时，在遇到问题之前了解两者的区别是很有帮助的。</p></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><p id="71b6" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">[1]:<a class="ae no" href="https://cmake.org/cmake/help/latest/command/add_subdirectory.html" rel="noopener ugc nofollow" target="_blank">https://cmake . org/cmake/help/latest/command/add _ subdirectory . html</a></p><p id="2fe1" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">【2】:【https://cmake.org/cmake/help/latest/command/include.html T2】</p><p id="a87a" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">【3】:【https://cmake.org/cmake/help/latest/command/function.html T4】</p><p id="8109" class="pw-post-body-paragraph lm ln it lo b lp mi ju lr ls mj jx lu lv mk lx ly lz ml mb mc md mm mf mg mh im bi translated">【4】:<a class="ae no" href="https://cmake.org/cmake/help/latest/command/macro.html" rel="noopener ugc nofollow" target="_blank">https://cmake.org/cmake/help/latest/command/macro.html</a></p></div></div>    
</body>
</html>