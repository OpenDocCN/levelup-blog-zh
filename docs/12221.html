<html>
<head>
<title>React Context — The Definitive Guide to Best Practices</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应环境—最佳实践的权威指南</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/react-context-the-definitive-guide-to-best-practices-fd095568be03?source=collection_archive---------4-----------------------#2022-05-24">https://levelup.gitconnected.com/react-context-the-definitive-guide-to-best-practices-fd095568be03?source=collection_archive---------4-----------------------#2022-05-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="fadc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我猜猜，你已经阅读了至少3篇关于如何使用上下文、为什么你不应该使用上下文、什么是上下文、将上下文比作状态管理库的文章，并且<em class="kl">列表继续下去。</em></p><p id="da73" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然有许多文章涵盖了非常基础的上下文，但是很少有文章会涵盖高级概念、性能优化和最佳实践。他们通常要么不讨论这类话题，要么更糟的是，在没有向读者提供完整故事的情况下，与野生图书馆进行比较。</p><blockquote class="km kn ko"><p id="2669" class="jn jo kl jp b jq jr js jt ju jv jw jx kp jz ka kb kq kd ke kf kr kh ki kj kk ij bi translated">告诉我，孩子——你不厌倦试图填补那个空白吗？</p></blockquote><p id="3aa4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个简单的事实是，就像React(或软件工程)中的任何其他东西一样，上下文也有其权衡，但只要你知道这些权衡以及如何减轻它们，上下文就可以填补你的空白，而不需要引入额外的库。</p><h1 id="2db7" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated"><strong class="ak">消费语境——勾起来！</strong></h1><blockquote class="km kn ko"><p id="5971" class="jn jo kl jp b jq jr js jt ju jv jw jx kp jz ka kb kq kd ke kf kr kh ki kj kk ij bi translated">钩子把你带回来，我不会骗你。钩子会把你带回来，你可以依靠它。</p></blockquote><p id="06da" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不，不是<em class="kl">那个</em>挂钩——一个<em class="kl">定制</em>挂钩。上下文总是通过一个定制的钩子来使用。在我们进入为什么之前，这里有一个基本的例子:</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="lv lw l"/></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk translated">给你的生活增添情趣！</figcaption></figure><p id="a3cf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为什么？很高兴你问了，主要原因:</p><ul class=""><li id="6ed1" class="mb mc iq jp b jq jr ju jv jy md kc me kg mf kk mg mh mi mj bi translated">保证在其提供者内上下文的正确访问(否则它将抛出)。</li><li id="6c0d" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">不需要导出上下文本身。</li></ul><p id="6378" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">其他非常固执己见的原因:</p><ul class=""><li id="6cc5" class="mb mc iq jp b jq jr ju jv jy md kc me kg mf kk mg mh mi mj bi translated">增加可读性——钩子名称告诉任何开发者它是什么。</li><li id="3c43" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">增加DX-谁不爱一个好的勾手？</li></ul><h1 id="141c" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">定制提供商—永不停止提供服务</h1><blockquote class="km kn ko"><p id="7ec2" class="jn jo kl jp b jq jr js jt ju jv jw jx kp jz ka kb kq kd ke kf kr kh ki kj kk ij bi translated">永远不会放弃你，永远不会让你失望。</p></blockquote><p id="e96e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">提供者是上下文的主力——这是一篇在街上仔细撰写的经过事实检验的文章，但也可能是文章中未经授权的评论部分。这就是定制提供者的魅力所在，也是为什么无论何时使用上下文，都应该使用定制提供者。他们可以在一个非常简单的api后面隐藏很多复杂性。</p><p id="25bd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看一个基本的例子:</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="480f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为什么？很高兴你问了，主要原因:</p><ul class=""><li id="ab7d" class="mb mc iq jp b jq jr ju jv jy md kc me kg mf kk mg mh mi mj bi translated">将(可能的)复杂逻辑封装到自己的组件中。</li></ul><p id="7e2b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种方法通过限制使用提供者的组件大小，并公开一个非常简单、易于理解的api来进行更改，从而提供了一个更清晰的代码库(更好的DX)。</p><p id="566f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可能注意到了提供程序中的api对象——这是定制提供程序支持的另一个最佳实践。始终提供一个api供消费者使用，这是一种“包含电池”的方法，它将限制人为错误，并通过简单地调用命名良好的api函数，而不必担心逻辑或可能的状态，使它立即可供任何没有上下文的人使用。旁注:我也是TypeScript的大力支持者，这将有助于上述所有内容，但那是另一篇文章。</p><h1 id="e539" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">性能优化—让我们的力量结合起来</h1><blockquote class="km kn ko"><p id="9e08" class="jn jo kl jp b jq jr js jt ju jv jw jx kp jz ka kb kq kd ke kf kr kh ki kj kk ij bi translated">"这有糟糕的性能，它将重新渲染这么多，粉碎你的应用程序，你是一个多么糟糕的开发人员！"</p></blockquote><p id="0a1d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我已经能听到巨魔，仇恨者，秃鹰，吸血鬼。不要担心杰出的读者，因为仇恨者会恨，恨，恨。在这种情况下，虽然巨魔是绝对正确的<strong class="jp ir">暂停震惊</strong>。</p><p id="0641" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">是的，下面讨论的改进可以从一开始就作为一种防御方法加入，但是如果你在你的应用程序中保持上下文范围狭窄并且尽可能低，那么很有可能不需要它们。说到这里，让我们讨论一下使用上下文最大的问题以及如何减轻它的影响。简单地说，直接从React文档:</p><blockquote class="km kn ko"><p id="3412" class="jn jo kl jp b jq jr js jt ju jv jw jx kp jz ka kb kq kd ke kf kr kh ki kj kk ij bi translated">每当提供者的<code class="fe mp mq mr ms b">value</code>属性改变时，作为提供者后代的所有消费者都将重新呈现。</p></blockquote><p id="67ae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们前面的例子中，这意味着<code class="fe mp mq mr ms b">&lt;SpiceButtons /&gt;</code>，尽管没有使用<code class="fe mp mq mr ms b">spice</code>值，将在值改变时重新渲染。通常情况下，你可能对此没有意见，但如果它造成了性能问题，防止重新渲染的最佳方式是使用多个上下文——更具体地说，是从api函数<em class="kl">中分离出变化的值(因为你总是在阅读完这篇文章后使用api函数，对吗？？)</em>。</p><p id="e8be" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看另一个例子，它建立在我们之前的例子之上:</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="lv lw l"/></div></figure><p id="d7bc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">额外的<code class="fe mp mq mr ms b">SpicyApiCtx</code>上下文与api的<code class="fe mp mq mr ms b">useMemo</code>相结合，使得api函数能够在呈现之间保持它们的引用身份稳定(当<code class="fe mp mq mr ms b">spicy</code>值改变时),并且不会使用<code class="fe mp mq mr ms b">useSpicyApi</code>钩子<em class="kl">在任何组件中触发重新呈现(因为您总是在阅读此权利后创建一个自定义钩子来消耗上下文？？)</em>。</p><p id="10d9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种方法(多上下文)可以呈指数增长——当然在某些时候你可能会考虑使用状态管理库，我只是说<em class="kl">这是可能的</em>。</p><p id="287f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们考虑最后一个例子——我最近读了一篇<a class="ae mt" href="https://medium.com/@viraj.vimu/react-context-api-vs-zustand-state-manager-98ca9ac76904" rel="noopener">文章</a>比较了context和<a class="ae mt" href="https://github.com/pmndrs/zustand" rel="noopener ugc nofollow" target="_blank"> zustand </a>的性能。<strong class="jp ir"> <em class="kl">文章</em> </strong>的TLDR是一个稍微复杂一点的典型反例。其中有两个“玩家”,你可以增加或减少他们的分数(计数),记分牌显示获胜者，同时在<code class="fe mp mq mr ms b">hightlight updates when components render</code>设置打开的情况下使用React Profiler扩展。正如您所想象的那样，上下文示例显示了当发生更改时所有内容的重新呈现，而zustand示例只显示了播放器递增或递减，以及当发生更改时记分板的重新呈现。</p><p id="c719" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从表面上看，这篇文章没有任何问题，它写得很好，有很好的视频示例，提供代码是为了让您有机会体验一下。我对这篇文章的主要担心是，这种比较没有包括上下文示例的任何性能优化，也没有提到这种优化的存在以及如何使上下文示例与zustand示例内联。这对于那些可能不知道去别处找更好的东西的新手来说有点误导。</p><p id="91b1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面，我重构了本文中提供的上下文示例，应用了本文中讨论的性能优化，并将其嵌入到zustand示例中。(此处代码<a class="ae mt" href="https://github.com/cdaz5/ctx-example" rel="noopener ugc nofollow" target="_blank">为</a>)</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi mu"><img src="../Images/6bed08195718d44e7ba8e960cb2a5809.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*CxPO3sZG2USzrCqlr-GMRA.gif"/></div></div></figure><p id="76be" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">需要澄清的是，我并不是说context比zustand更好——它们在React世界中都有权衡和用例。作为开发人员，我们的工作是从我们的工具包中挑选适合这项工作的工具，我只是指出这种重构在上下文中是可能的。在给定的情况下，这可能不是正确的选择，但是作为读者，您现在对上下文有了更好的了解，并且可以围绕在给定的情况下您可能使用的工具做出更明智的决定。</p><p id="8335" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你觉得这篇文章有帮助，请给它一个赞！</p><p id="842e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">附言:我是zustand的超级粉丝，下次你考虑州管理图书馆的时候一定要考虑它。</p></div></div>    
</body>
</html>