<html>
<head>
<title>Use the PATH Luke! How to test in bash</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">走小路路克！如何在bash中进行测试</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/use-the-path-luke-how-to-test-in-bash-7d9eb19ab092?source=collection_archive---------9-----------------------#2020-02-15">https://levelup.gitconnected.com/use-the-path-luke-how-to-test-in-bash-7d9eb19ab092?source=collection_archive---------9-----------------------#2020-02-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="751f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本文中，我将展示如何stub入bash，这是编写正确测试的关键。</p><h1 id="130e" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">为什么是巴什？</h1><p id="fab5" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">简而言之，因为它具有普遍性。如果您需要编写一个跨团队的脚本，那么bash是一个安全的选择。任何其他语言都会给不经常使用它的开发人员增加一些摩擦。Bash是稳定的，它总是在那里。</p><p id="955a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最好的例子是git挂钩。如果您希望团队中的所有开发人员都使用这个钩子，您将很难说服他们安装另一个工具链来执行它，除非您使用bash。</p><h1 id="a43c" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">为什么要测试？</h1><p id="ae92" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">根据我的经验，bash中的脚本往往非常脆弱。我没有一个明确的答案，但我认为主要原因是剧本非常间接。也就是说，他们现在在这个背景下解决了一个问题。但是没有检查当环境改变时会发生什么。这就是测试至关重要的地方。</p><blockquote class="lr ls lt"><p id="31d2" class="jq jr lu js b jt ju jv jw jx jy jz ka lv kc kd ke lw kg kh ki lx kk kl km kn im bi translated">在这种情况下，Bash脚本现在解决了一个问题。但是没有检查当环境改变时会发生什么。这就是测试至关重要的地方。</p></blockquote><p id="a39c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可能永远也不想在master中提交，但是知道在这种情况下git钩子将会运行是很重要的，为此，我们需要stub。</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi ly"><img src="../Images/9234376734a32a8e70fc07b57e855621.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*34YZCRV-LK6OC75GTXxFEA.jpeg"/></div></div></figure><h1 id="520e" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">如何存根</h1><p id="4aaf" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">存根实际上非常简单，我们只需要使用路径。</p><p id="64b9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">PATH变量只是一个用冒号分隔的路径列表:</p><pre class="lz ma mb mc gt mk ml mm mn aw mo bi"><span id="fd02" class="mp kp it ml b gy mq mr l ms mt">PATH=/usr/local/bin:/bin:...</span></pre><p id="fb44" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它告诉bash在哪里寻找可执行文件。列表中的位置越靠前，就越重要，正如我们在下一个示例中看到的:</p><pre class="lz ma mb mc gt mk ml mm mn aw mo bi"><span id="0d8d" class="mp kp it ml b gy mq mr l ms mt">PATH=$(pwd)/bar:$PATH<br/>PATH=$(pwd)/foo:$PATH<br/>mkdir bar<br/>mkdir foo<br/>echo 'echo 1' &gt; foo/a<br/>echo 'echo 2' &gt; bar/a<br/>chmod +x foo/a<br/>chmod +x bar/a<br/>a<br/>&gt; 1<br/>PATH=$(pwd)/bar:$PATH<br/>a<br/>&gt; 2</span></pre><h1 id="7c41" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">真实的例子</h1><p id="660e" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">让我们继续看一个实际的例子，将提交链接到票据。吉拉说，如果你和一个问题追踪者一起工作，你的票很可能会有一个类似GLEE-313的id，其中GLEE是团队的代码，313是票的号码。这些标签很可能有一个详细的描述，甚至可能包括图片，关于手边的特性或bug。</p><p id="d28e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您正在遵循类似于git flow的任何东西，那么很可能您有一个分支名称的约定，您首先写票id，然后是一个简短的描述，例如“GLEE-313-we-need-to-test-this”。然而，分支只是指针，真正持久的是提交，所以我们希望分支上的所有提交都引用标签。比如以“【GLEE-313】”开头。这显然是git挂钩的一个例子，您可以在每次编写提交消息时键入票据代码，但是该信息已经存在于分支名称中。</p><p id="a33a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">经过一番谷歌搜索，我们发现正确的钩子是“prepare-commit-msg ”,并且<code class="fe mu mv mw ml b">git rev-parse --abbrev-ref HEAD</code>返回分支名称。所以让我们写第一个版本:</p><pre class="lz ma mb mc gt mk ml mm mn aw mo bi"><span id="287e" class="mp kp it ml b gy mq mr l ms mt">#!/bin/bash<br/>BRANCH_NAME=$(git rev-parse --abbrev-ref HEAD)<br/>if [ -z "$BRANCH_NAME" ]; then<br/>    echo "Not a git repo"<br/>    exit 1<br/>fi</span><span id="1b12" class="mp kp it ml b gy mx mr l ms mt">## Get code from branch<br/>CODE=$(echo $BRANCH_NAME | sed -E "s/^([A-Z]+-[0-9]+).*/\1/")<br/>sed -i -e "1s/^/[$CODE] /" $1</span></pre><p id="1a4c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">请注意，我们没有收到提交的文本，而是收到了文件“$1”。Git将提交的初稿写到一个文件中，并将文件名处理给钩子。然后，我们只需在该文件上应用sed来预先计划我们的代码。</p><p id="b2b4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们可能会多次尝试这个脚本，并试图说我们已经完成了。我们甚至检查如果git不返回分支名称会发生什么！然而，我们确定这就是结局吗？</p><ul class=""><li id="f897" class="my mz it js b jt ju jx jy kb na kf nb kj nc kn nd ne nf ng bi translated">如果分行没有代码会怎样？我们可能会在提交消息中添加“[]”，但我们不希望这样。</li><li id="13a3" class="my mz it js b jt nh jx ni kb nj kf nk kj nl kn nd ne nf ng bi translated">如果提交已经有了代码，会发生什么？我们很可能会得到重复的身份证。修改或应用提交时会发生这种情况。</li><li id="45cf" class="my mz it js b jt nh jx ni kb nj kf nk kj nl kn nd ne nf ng bi translated">合并提交会发生什么？我们可能会留下来自git的自动消息，因为它已经包含了分支名称。此外，我们的git存储库或其他工具可能会假设合并消息遵循标准模式。</li></ul><p id="6ffd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我们试图解决这些问题之前，我们需要设置测试环境。</p><h1 id="0a8f" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">测试git挂钩</h1><p id="78b3" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">在前面的例子中，我们执行了几个命令:git、echo、sed、[ (yes [是命令，你甚至可以做<code class="fe mu mv mw ml b">man '['</code>)。</p><blockquote class="lr ls lt"><p id="1093" class="jq jr lu js b jt ju jv jw jx jy jz ka lv kc kd ke lw kg kh ki lx kk kl km kn im bi translated"><em class="it">你知道</em> <code class="fe mu mv mw ml b"><em class="it">[</em></code> <em class="it">是一个程序，别名为</em> <code class="fe mu mv mw ml b"><em class="it">test</em></code> <em class="it">？一个人甚至可以做</em><code class="fe mu mv mw ml b"><em class="it">man [</em></code><em class="it"/><code class="fe mu mv mw ml b"><em class="it">ll '/usr/bin/['</em></code><em class="it">。这就是为什么在“[”后面总是需要一个空格。另一方面，</em> <code class="fe mu mv mw ml b"><em class="it">[[</em></code> <em class="it">是bash中的语法标记。</em></p></blockquote><p id="b485" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从这些中，有一个明显的异常值:<code class="fe mu mv mw ml b">git</code>。Git给我们“上下文”,而其他人提供“逻辑”。如果我们想测试这个脚本，我们需要stub git，让它返回我们提到的不同情况。</p><p id="9cdc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我们继续测试之前，让我们后退一步，想想这是否是正确的方法。在一个合适的编程环境中，我们会将函数分成两个不同的部分。一个用于获取分支名称，另一个用于修复提交，它们将进入脚本的库文件夹。然后主文件将两个组件粘合在一起。然而，如果我们想在bash中像这样组织代码并对其进行测试，我们需要将脚本分割成多个文件，这又会在采用过程中产生摩擦。</p><p id="6ef3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">回到我们的测试，让我们首先考虑我们在存根中需要什么。因为我们知道git已经返回了分支名称，所以我们只需要创建一个简单的脚本来返回我们想要的分支名称。我们还需要能够在测试中修改git存根的行为。以下满足两个条件:</p><pre class="lz ma mb mc gt mk ml mm mn aw mo bi"><span id="1ac3" class="mp kp it ml b gy mq mr l ms mt">#!/bin/bash<br/>## File named git which contains our git mock</span><span id="cca6" class="mp kp it ml b gy mx mr l ms mt">## Read the fake branch name from a file, so that test code can change the output of git<br/>cat test/.test-branch</span></pre><p id="cb06" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">测试将由两部分组成，一个分支和一个提交消息。所以我们的测试跑步者看起来像:</p><pre class="lz ma mb mc gt mk ml mm mn aw mo bi"><span id="51dd" class="mp kp it ml b gy mq mr l ms mt">#!/bin/bash</span><span id="0e8c" class="mp kp it ml b gy mx mr l ms mt">## Make sure that our mock overrides git<br/>PATH=$(pwd)/test:$PATH</span><span id="cb2f" class="mp kp it ml b gy mx mr l ms mt">TOTAL_FAILURES=0</span><span id="9267" class="mp kp it ml b gy mx mr l ms mt"># $1 is the branch name<br/># $2 is the commit text<br/># $3 is the expected commit after modification<br/>function testCase () {<br/>    echo "$1" &gt; ./test/.test-branch<br/>    echo "$2" &gt; ./test/.test-commit<br/>    ./prepare-commit-msg-hook.sh ./test/.test-commit</span><span id="9977" class="mp kp it ml b gy mx mr l ms mt">    RESULT=$(cat ./test/.test-commit)<br/>    if [ "$RESULT" != "$3" ]; then<br/>        TOTAL_FAILURES=$(($TOTAL_FAILURES + 1))<br/>        echo "Expected $3 got $RESULT"<br/>    fi<br/>}</span><span id="32ee" class="mp kp it ml b gy mx mr l ms mt">## Yikes we are testing in bash!!<br/>testCase GLEE-313-my-first-branch "Such an awesome commit" "[GLEE-313] Such an awesome commit"</span><span id="3220" class="mp kp it ml b gy mx mr l ms mt">ANSI_RESET='\e[39m'<br/>ANSI_RED='\e[31m'<br/>ANSI_GREEN='\e[32m'</span><span id="1dd7" class="mp kp it ml b gy mx mr l ms mt">if [ "$TOTAL_FAILURES" -eq 0 ]; then<br/>    echo -e ${ANSI_GREEN}Success!!${ANSI_RESET}<br/>else<br/>    echo -e  ${ANSI_RED}Failure. $TOTAL_FAILURES tests failed.${ANSI_RESET}<br/>fi<br/>exit $TOTAL_FAILURES</span></pre><p id="f5cc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在前一个脚本中有两个关键行。将会用我们的模拟内部测试文件夹替换原来的git。<code class="fe mu mv mw ml b">echo "$1" &gt; ./test/.test-branch</code>修改我们存根的输出。</p><p id="a2c4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们执行测试，我们会看到它按预期工作:</p><pre class="lz ma mb mc gt mk ml mm mn aw mo bi"><span id="0c71" class="mp kp it ml b gy mq mr l ms mt">./test.sh<br/>&gt; Success!!</span></pre><p id="2eb7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们准备添加那些棘手的案例:</p><pre class="lz ma mb mc gt mk ml mm mn aw mo bi"><span id="9eba" class="mp kp it ml b gy mq mr l ms mt">testCase my-branch-has-no-code "Sad commit" "Sad commit"<br/>testCase GLEE-313-my-first-branch "[GLEE-313] Commit to be amended, so it already has code" "[GLEE-313] Commit to be amended, so it already has code"<br/>testCase GLEE-313-my-first-branch "Merge branch master into 'GLEE-313-my-first-branch'" "Merge branch master into 'GLEE-313-my-first-branch'"<br/>&gt; Expected Sad commit got [my-branch-has-no-code] Sad commit<br/>&gt; Expected [GLEE-313] Commit to be amended, so it already has code got [GLEE-313] [GLEE-313] Commit to be amended, so it already has code<br/>&gt; Expected Merge branch master into 'GLEE-313-my-first-branch' got [GLEE-313] Merge branch master into 'GLEE-313-my-first-branch'<br/>&gt; Failure. 3 tests failed.</span></pre><p id="989d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这可不好，三个案子都失败了。但是我们现在有测试，所以更容易修复。经过一番激烈的讨论，这是最终版本:</p><pre class="lz ma mb mc gt mk ml mm mn aw mo bi"><span id="506d" class="mp kp it ml b gy mq mr l ms mt">#!/bin/bash<br/>BRANCH_NAME=$(git rev-parse --abbrev-ref HEAD)<br/>if [ -z "$BRANCH_NAME" ]; then<br/>    echo "Not a git repo"<br/>    exit 1<br/>fi</span><span id="9329" class="mp kp it ml b gy mx mr l ms mt">if [[ ! "$BRANCH_NAME" =~ ^[A-Z]+-[0-9]+ ]]; then<br/>  ## Branch is not following team convention. This could happen for example in master. Nothing to be done<br/>  exit 0<br/>fi</span><span id="8ff1" class="mp kp it ml b gy mx mr l ms mt">COMMIT=$(cat $1)<br/>if [[ "$COMMIT" =~ ^\[[A-Z]+-[0-9]+\] ]]; then<br/>  ## There is already some code in the commit. For example from amending or applying. Nothing to be done.<br/>  exit 0<br/>fi</span><span id="9dcb" class="mp kp it ml b gy mx mr l ms mt">if [[ "$COMMIT" =~ ^Merge[[:space:]]branch[[:space:]] ]]; then<br/>  ## Let's not modify automated merge messages<br/> exit 0<br/>fi</span><span id="0ee1" class="mp kp it ml b gy mx mr l ms mt">## Get code from branch<br/>CODE=$(echo $BRANCH_NAME | sed -E "s/^([A-Z]+-[0-9]+).*/\1/")<br/>sed -i -e "1s/^/[$CODE] /" $1</span></pre><p id="3595" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">四项测试都通过了。</p><h1 id="2220" class="ko kp it bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll bi translated">总结</h1><p id="ba81" class="pw-post-body-paragraph jq jr it js b jt lm jv jw jx ln jz ka kb lo kd ke kf lp kh ki kj lq kl km kn im bi translated">如果我们修改PATH变量，我们可以让bash脚本使用所选程序的存根。这允许我们检查我们的程序在不同场景下的行为，这是编写健壮脚本的关键。</p><p id="1ae2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你想通过测试检查脚本的最终版本，你可以在<a class="ae nm" href="https://github.com/furstenheim/git-hooks" rel="noopener ugc nofollow" target="_blank"> github </a>中查看。</p></div></div>    
</body>
</html>