<html>
<head>
<title>Functioning Programming for Mortals — excerpts</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向凡人的功能编程—节选</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/functioning-programming-for-mortals-excerpts-41779d16dd5a?source=collection_archive---------5-----------------------#2020-09-13">https://levelup.gitconnected.com/functioning-programming-for-mortals-excerpts-41779d16dd5a?source=collection_archive---------5-----------------------#2020-09-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/babcf6111217a2cb20aaa69c5b4a7408.png" data-original-src="https://miro.medium.com/v2/resize:fit:1174/format:webp/1*iDiOomcCrcauqke8RE1qPQ.png"/></div></figure><p id="8368" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">阅读一本有见地的书总是好的，尤其是关于你最喜欢的编程语言的书。说到Scala，有很多很棒的书籍涵盖了高级概念，比如《Scala中的函数式编程》(又名《红皮书》)、《Scala with Cats》、《Type aultant ' s Guide to shapelless》，当然还有《面向凡人的函数式编程》。</p><p id="9335" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">不幸的是，许多这样的书隐含地要求至少对它们所描述的概念有一些基本的理解。对于初学者来说，这可能特别令人望而生畏，导致人们普遍认为Scala是一种“难懂的语言”。这启发我列出一些常见的概念，但不要涉及太多的细节，这样人们可以了解大致的想法，然后从其他资源中广泛地探索它们。</p><p id="3e69" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我选择“面向凡人的函数式编程”作为这个列表的基础，因为作为我读过的关于Scala的第一本书之一，它为我提供了函数式编程的所有关键概念，我随后能够深入研究这些概念。所有的名字和代码引用都来自使用<code class="fe ks kt ku kv b">scalaz</code>库的版本，尽管我会尽可能地提供来自<code class="fe ks kt ku kv b">cats</code>库的替代版本。列出的摘录并不是这本书的文字引用，但是如果你想更详细地研究这本书的各个主题，可以附上几页。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="db9f" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">第1章—简介</h1><p id="4d5f" class="pw-post-body-paragraph ju jv iq jw b jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr ij bi translated"><code class="fe ks kt ku kv b">Page 5.</code>对<strong class="jw ir"> <em class="mg">一元</em> </strong>类型的操作允许对顺序执行上下文进行抽象，这可以提供不同的错误处理、状态存储和审计能力。一些一元类型的基本例子包括Scala标准库中的<code class="fe ks kt ku kv b">Option</code>、<code class="fe ks kt ku kv b">List</code>和<code class="fe ks kt ku kv b">Either</code>。关于单子是什么的更多细节见第5.7节。</p><p id="412d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe ks kt ku kv b">Page 6.</code>功能编程主要操作<strong class="jw ir"> <em class="mg">纯功能</em> </strong>。它们是:</p><ul class=""><li id="44e5" class="mh mi iq jw b jx jy kb kc kf mj kj mk kn ml kr mm mn mo mp bi translated"><strong class="jw ir"> <em class="mg">总计</em> </strong> —为每个可能的输入返回值(异常不被视为返回值)。</li><li id="e818" class="mh mi iq jw b jx mq kb mr kf ms kj mt kn mu kr mm mn mo mp bi translated"><strong class="jw ir"> <em class="mg">确定性</em> </strong> <em class="mg"> — </em>对于相同的输入，返回值从不改变。</li><li id="fc03" class="mh mi iq jw b jx mq kb mr kf ms kj mt kn mu kr mm mn mo mp bi translated"><strong class="jw ir"> <em class="mg">局部作用域</em> </strong> <em class="mg"> </em> —它们不会改变调用者可见的状态。</li></ul><p id="9f5e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">纯函数允许构造<strong class="jw ir"> <em class="mg">引用透明的</em> </strong> <em class="mg"> </em>表达式，可以直接用它们的返回值替换，而不改变程序的行为。例如，<code class="fe ks kt ku kv b">(5 + 5)</code>可以在代码中的任何地方替换<code class="fe ks kt ku kv b">10</code>。</p><p id="bb9c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">引用透明性通过<strong class="jw ir"> <em class="mg">本地推理</em> </strong>提供了更好的代码理解，这意味着您不必在调用点考虑实现细节或副作用。这也意味着重用单独的代码部分要容易得多，因为它们没有到系统其他部分的隐式连接。</p><h1 id="a951" class="ld le iq bd lf lg mv li lj lk mw lm ln lo mx lq lr ls my lu lv lw mz ly lz ma bi translated">第3章—应用程序设计</h1><p id="914a" class="pw-post-body-paragraph ju jv iq jw b jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr ij bi translated"><code class="fe ks kt ku kv b">Page 25.</code><strong class="jw ir"><em class="mg">代数</em> </strong>定义了系统特定部分的一组(可能的)副作用交互。这个集合通常以特征的形式出现，该特征定义了具有更高级类型参数<code class="fe ks kt ku kv b">F[_]</code>的必要方法，该参数通常被称为<strong class="jw ir"> <em class="mg">效果</em> </strong> <em class="mg">，</em>所述交互发生的上下文<em class="mg">。</em></p><p id="2306" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe ks kt ku kv b">Page 27.</code>一个<strong class="jw ir"> <em class="mg">模块</em> </strong>是一个代数的实现，它在<code class="fe ks kt ku kv b">F[_]</code>上被抽象，只依赖于其他模块、代数和纯函数，通常在<code class="fe ks kt ku kv b">F[_]</code>上有许多类型类限制。绑定到特定<code class="fe ks kt ku kv b">F[_]</code>的代数实现被称为<strong class="jw ir">解释器</strong>。有关什么是类型类的详细信息，请参见第4.2部分。</p><p id="704c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe ks kt ku kv b">Page 36.</code>用于测试目的的测试解释器或<code class="fe ks kt ku kv b">F[_]</code>的特定实现允许安全地替换系统的副作用部分，从而产生更高的测试覆盖率。模块通常比解释器更难编写，但是在编写测试时提供了更大的灵活性。</p><h1 id="e06d" class="ld le iq bd lf lg mv li lj lk mw lm ln lo mx lq lr ls my lu lv lw mz ly lz ma bi translated">第4章—数据和功能</h1><h2 id="04cc" class="na le iq bd lf nb nc dn lj nd ne dp ln kf nf ng lr kj nh ni lv kn nj nk lz nl bi translated">4.1数据</h2><p id="0379" class="pw-post-body-paragraph ju jv iq jw b jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr ij bi translated"><code class="fe ks kt ku kv b">Page 38.</code>在函数式编程中数据通常由<strong class="jw ir"> <em class="mg">代数数据类型</em> </strong> <em class="mg"> </em> (ADTs)来表示，这是对以下数据的统称:</p><ul class=""><li id="121b" class="mh mi iq jw b jx jy kb kc kf mj kj mk kn ml kr mm mn mo mp bi translated">(最终)案例类，其字段为ADT。这些被称为<strong class="jw ir"> <em class="mg">产品</em> </strong> <em class="mg">。</em></li><li id="ff18" class="mh mi iq jw b jx mq kb mr kf ms kj mt kn mu kr mm mn mo mp bi translated">密封特征，其所有成员都是ADT。这些被称为<strong class="jw ir"><em class="mg"/></strong><em class="mg">。</em></li><li id="1868" class="mh mi iq jw b jx mq kb mr kf ms kj mt kn mu kr mm mn mo mp bi translated"><em class="mg">值，</em>由case对象、“原语”(如整数、字符串)、纯函数组成。</li></ul><p id="e4ca" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">从逻辑观点来看，乘积对应于逻辑合取(“具有特性A和特性B以及特性C”)，而余积代表析取(“是A型还是B型还是C型”)。</p><p id="a13c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">带类型参数的ADT称为<strong class="jw ir"> <em class="mg">广义代数数据类型</em></strong>(gadt)。ADT也可以是递归的<em class="mg"> </em>通过在它们的定义中引用它们自己。</p><p id="2b0d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">需要强调的是，当依赖于像<code class="fe ks kt ku kv b">equals</code>这样的方法或像<code class="fe ks kt ku kv b">Serializable</code>这样的接口时，包含函数的ADT可能无法很好地转换成Java虚拟机(JVM)。一个好的实践是让ADT定义尽可能干净，避免使用内置的JVM方法。</p><p id="0ef2" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">还要注意，在定义余积时,“密封”修饰符很重要。它不仅明确规定了数据类型不能在程序的其他部分任意扩展，还允许编译器执行额外的检查，甚至通过宏自动生成一些代码。</p><p id="f5f8" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe ks kt ku kv b">Page 42.</code>有时，在ADT中包含原始类型可以表示无效状态——一个常见的例子是对只允许正值的字段使用整数。这可以通过定义对原始值应用一组限制的值包装器来解决。这样的包装器俗称<strong class="jw ir"><em class="mg"/></strong><em class="mg"/>(参见<a class="ae nm" href="https://github.com/fthomas/refined" rel="noopener ugc nofollow" target="_blank"> <em class="mg">提炼</em> </a> <em class="mg"> </em>库的例子)。</p><p id="b024" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe ks kt ku kv b">Page 44.</code>ADT不应该像常规类或特征那样提供任何方法，它们只是数据的容器。</p><blockquote class="nn no np"><p id="04d6" class="ju jv mg jw b jx jy jz ka kb kc kd ke nq kg kh ki nr kk kl km ns ko kp kq kr ij bi translated">通过不提供任何功能，ADT可以有一个最小的依赖集，使它们易于发布并与其他开发人员共享。</p></blockquote><p id="e126" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">给定类型可以存在的值的个数称为其<em class="mg"> </em> <strong class="jw ir"> <em class="mg">复杂度</em> </strong> <em class="mg">。</em></p><p id="0c26" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe ks kt ku kv b">Page 45.</code>降低函数输入和输出的复杂性有助于支持总体性。保持输出的复杂性小于输入的复杂性是有益的。</p><p id="cefc" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在许多情况下，可以通过将乘积重写为余乘积来消除不期望的(无效的)状态，从而降低ADT的复杂性。</p><h2 id="4711" class="na le iq bd lf nb nc dn lj nd ne dp ln kf nf ng lr kj nh ni lv kn nj nk lz nl bi translated">4.2功能</h2><p id="6963" class="pw-post-body-paragraph ju jv iq jw b jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr ij bi translated"><code class="fe ks kt ku kv b">Page 49.</code>函数式编程通常依靠<strong class="jw ir"><em class="mg"/></strong><em class="mg">中的</em>顺序来提供多态功能，这与面向对象编程中的继承相反。类型类是这样的特征:</p><ul class=""><li id="9d8d" class="mh mi iq jw b jx jy kb kc kf mj kj mk kn ml kr mm mn mo mp bi translated">保持无状态。</li><li id="0508" class="mh mi iq jw b jx mq kb mr kf ms kj mt kn mu kr mm mn mo mp bi translated">包含类型参数—应为其提供typeclass的类型。这个型号可能是<a class="ae nm" href="https://typelevel.org/blog/2016/08/21/hkts-moving-forward.html" rel="noopener ugc nofollow" target="_blank">更高级的</a>。</li><li id="65ca" class="mh mi iq jw b jx mq kb mr kf ms kj mt kn mu kr mm mn mo mp bi translated">至少有一个抽象方法。</li></ul><p id="4a57" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">此外，typeclasses可以:</p><ul class=""><li id="92c8" class="mh mi iq jw b jx jy kb kc kf mj kj mk kn ml kr mm mn mo mp bi translated">包含具有默认实现的方法。</li><li id="bcc1" class="mh mi iq jw b jx mq kb mr kf ms kj mt kn mu kr mm mn mo mp bi translated">扩展其他typeclasses。</li></ul><p id="5a97" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">当需要typeclass的实例时，它通常由调用站点的隐式范围提供。理想情况下，不需要显式导入来提供typeclass的实例，但这并不总是可行的。更多细节参见<a class="ae nm" href="https://www.scala-lang.org/files/archive/spec/2.13/07-implicits.html#implicit-parameters" rel="noopener ugc nofollow" target="_blank">隐式参数文档</a>。</p><p id="f207" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在形式上，当使用typeclasses时，它们需要为每种类型拥有唯一的实例。如果同一个类型有多个实现“有意义”(例如<code class="fe ks kt ku kv b">Ordering</code>)，那么将各自的特征称为类型类是不正确的。</p><h1 id="7f3a" class="ld le iq bd lf lg mv li lj lk mw lm ln lo mx lq lr ls my lu lv lw mz ly lz ma bi translated">第5章— (Scalaz)类型类</h1><h2 id="75be" class="na le iq bd lf nb nc dn lj nd ne dp ln kf nf ng lr kj nh ni lv kn nj nk lz nl bi translated"><strong class="ak"> 5.2可追加的东西</strong></h2><p id="1e54" class="pw-post-body-paragraph ju jv iq jw b jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr ij bi translated"><code class="fe ks kt ku kv b">page 70.</code> <code class="fe ks kt ku kv b">Semigroup[A]</code> —定义给定类型的关联“组合”操作。例如，字符串有一个带串联操作的<code class="fe ks kt ku kv b">Semigroup</code>。</p><p id="1b0a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe ks kt ku kv b">Monoid[A]</code>—<code class="fe ks kt ku kv b">Semigroup</code>也有一个空元素的概念，当与其他元素组合时没有效果。对于空字符串。</p><p id="2de9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe ks kt ku kv b">page 71.</code> <code class="fe ks kt ku kv b">Band[A]</code> —带有<em class="mg">幂等</em>运算的<code class="fe ks kt ku kv b">Semigroup</code>，当组合两个相同的值时，必须返回其参数之一。虽然界面与<code class="fe ks kt ku kv b">Semigroup</code>没有任何不同，但需要表达意图。<code class="fe ks kt ku kv b">Band</code>的一个简单例子是对任何固定类型集合的“组合”操作。</p><h2 id="4bfa" class="na le iq bd lf nb nc dn lj nd ne dp ln kf nf ng lr kj nh ni lv kn nj nk lz nl bi translated">5.3客体</h2><p id="67a0" class="pw-post-body-paragraph ju jv iq jw b jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr ij bi translated"><code class="fe ks kt ku kv b">page 74.</code> <code class="fe ks kt ku kv b">Equal[A]</code> —定义给定类型成员之间的“相等”运算。必须是:</p><ul class=""><li id="db80" class="mh mi iq jw b jx jy kb kc kf mj kj mk kn ml kr mm mn mo mp bi translated">可交换的——↔。</li><li id="a9eb" class="mh mi iq jw b jx mq kb mr kf ms kj mt kn mu kr mm mn mo mp bi translated">反身的— <code class="fe ks kt ku kv b">a === a</code>。</li><li id="2d22" class="mh mi iq jw b jx mq kb mr kf ms kj mt kn mu kr mm mn mo mp bi translated">及物— <code class="fe ks kt ku kv b">a === b, b === c</code> → <code class="fe ks kt ku kv b">a === c</code>。</li></ul><p id="5ebd" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe ks kt ku kv b">page 75.</code> <code class="fe ks kt ku kv b">Order[A]</code> —用比较操作扩展<code class="fe ks kt ku kv b">Equal</code>，最著名的是<code class="fe ks kt ku kv b">&lt;=</code>。主要用于抽象排序逻辑。</p><p id="1a80" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe ks kt ku kv b">Enum</code>(<code class="fe ks kt ku kv b">cats-collections</code>中的<code class="fe ks kt ku kv b">Discrete</code>)—为每个元素指定“后续元素”和“前置元素”。对于任何整数<em class="mg"> i </em>，它的后继者和前趋者将分别是<em class="mg"> i+1 </em>和<em class="mg"> i-1 </em>。</p><p id="a35f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe ks kt ku kv b">page 76.</code> <code class="fe ks kt ku kv b">Show[A]</code> —为给定类型提供人类可读的表示。这本质上是对<code class="fe ks kt ku kv b">toString()</code>方法的替代，消除了覆盖它的需要。</p><h2 id="e412" class="na le iq bd lf nb nc dn lj nd ne dp ln kf nf ng lr kj nh ni lv kn nj nk lz nl bi translated">5.4可映射的事物</h2><p id="7314" class="pw-post-body-paragraph ju jv iq jw b jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr ij bi translated"><code class="fe ks kt ku kv b">page 77.</code> <code class="fe ks kt ku kv b">Functor[F]</code> —为更高级类型<code class="fe ks kt ku kv b">F[_]</code>定义，允许在<code class="fe ks kt ku kv b">F</code>内改变值，同时保持<code class="fe ks kt ku kv b">F</code>本身不变。这是通过<code class="fe ks kt ku kv b">map</code>操作实现的，给定一个函数<code class="fe ks kt ku kv b">f: A =&gt; B</code>将<code class="fe ks kt ku kv b">F[A]</code>转换为<code class="fe ks kt ku kv b">F[B]</code>。<code class="fe ks kt ku kv b">List</code>、<code class="fe ks kt ku kv b">Option</code>等。有函子。</p><p id="031d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">所有函子必须满足以下属性:</p><ul class=""><li id="dd00" class="mh mi iq jw b jx jy kb kc kf mj kj mk kn ml kr mm mn mo mp bi translated">构图:<code class="fe ks kt ku kv b">fa.map(f).map(g) === fa.map(f andThen g)</code>。</li><li id="fb66" class="mh mi iq jw b jx mq kb mr kf ms kj mt kn mu kr mm mn mo mp bi translated">身份保存:<code class="fe ks kt ku kv b">fa.map(identity) === fa</code>。</li></ul><p id="e808" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">破坏这些属性本质上会导致仿函数失去大部分价值，因为应用局部推理和降低程序复杂性变得更加困难。</p><p id="3591" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe ks kt ku kv b">page 80.</code> <code class="fe ks kt ku kv b">Foldable[F]</code> —允许将任何固定<code class="fe ks kt ku kv b">A</code>的<code class="fe ks kt ku kv b">F[A]</code>类型的值减少为<code class="fe ks kt ku kv b">A</code>类型的单个值。请注意，<code class="fe ks kt ku kv b">Foldable</code>使用<code class="fe ks kt ku kv b">foldRight</code>方法说明了潜在的无限结构，这是其实现中所必需的。</p><p id="b052" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe ks kt ku kv b">page 85.</code> <code class="fe ks kt ku kv b">Traverse[F]</code> —当<code class="fe ks kt ku kv b">G</code>有一个<code class="fe ks kt ku kv b">Applicative</code>的实例时，将任何一个<code class="fe ks kt ku kv b">F[A]</code>转换为给定函数<code class="fe ks kt ku kv b">f: A =&gt; G[B]</code>的<code class="fe ks kt ku kv b">G[F[B]]</code>。这也允许实现<code class="fe ks kt ku kv b">sequence</code>方法:<code class="fe ks kt ku kv b">F[G[A]] =&gt; G[F[A]]</code>。最常见的用例之一是将一个<code class="fe ks kt ku kv b">List[Future[A]]</code>转换为<code class="fe ks kt ku kv b">Future[List[A]]</code>，在标准库中使用一个专用的<code class="fe ks kt ku kv b">Future.sequence</code>方法。有关<code class="fe ks kt ku kv b">Applicative</code>的更多详情，请参见第5.7节。</p><p id="ae82" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe ks kt ku kv b">page 87.</code> <code class="fe ks kt ku kv b">Align[F]</code> — <code class="fe ks kt ku kv b">Functor</code>允许<code class="fe ks kt ku kv b">align</code>任何<code class="fe ks kt ku kv b">F[A]</code>和<code class="fe ks kt ku kv b">F[B]</code>到<code class="fe ks kt ku kv b">F[Ior[A, B]]</code>，其中<code class="fe ks kt ku kv b">Ior</code>是包含<code class="fe ks kt ku kv b">A</code>值、<code class="fe ks kt ku kv b">B</code>值或两者的结构。例如，对齐两个列表将产生一个新列表，其中每个索引处的元素或者是原始列表的“压缩”元素对(如果该索引同时出现在两个列表中),或者是单个元素(如果它只出现在其中一个列表中)。</p><h2 id="6080" class="na le iq bd lf nb nc dn lj nd ne dp ln kf nf ng lr kj nh ni lv kn nj nk lz nl bi translated">5.5差异</h2><p id="c88f" class="pw-post-body-paragraph ju jv iq jw b jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr ij bi translated"><code class="fe ks kt ku kv b">page 89.</code><code class="fe ks kt ku kv b">InvariantFunctor[F]</code>(<code class="fe ks kt ku kv b">cats</code>中的<code class="fe ks kt ku kv b">Invariant[F]</code>)与<code class="fe ks kt ku kv b">Functor[F]</code>颇为相似，但其<code class="fe ks kt ku kv b">xmap</code>方法也需要一个向后的变换<code class="fe ks kt ku kv b">g: B =&gt; A</code>。如果元素之间的双向映射可用，<code class="fe ks kt ku kv b">InvariantFunctor[Semigroup]</code>的实例将允许定义新的半群。</p><p id="b306" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe ks kt ku kv b">ContravariantFunctor[F]</code>(<code class="fe ks kt ku kv b">cats</code>中的<code class="fe ks kt ku kv b">Contravariant[F]</code>)—当提供<code class="fe ks kt ku kv b">f: B =&gt; A</code>时，将<code class="fe ks kt ku kv b">F[A]</code>转换为<code class="fe ks kt ku kv b">F[B]</code>。虽然不太直观，但逆变仿函数本质上是对函数参数进行操作的。例如，很容易用函数<code class="fe ks kt ku kv b">encode: A =&gt; String</code>为类型<code class="fe ks kt ku kv b">Encoder[A]</code>创建逆变仿函数。</p><p id="5b75" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">使用这个术语，<code class="fe ks kt ku kv b">Functor</code>应该被称为<code class="fe ks kt ku kv b">CovariantFunctor</code>，但是为了简单起见，第一个词通常被省略。</p><h2 id="6b04" class="na le iq bd lf nb nc dn lj nd ne dp ln kf nf ng lr kj nh ni lv kn nj nk lz nl bi translated">5.6应用和绑定</h2><p id="4c05" class="pw-post-body-paragraph ju jv iq jw b jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr ij bi translated"><code class="fe ks kt ku kv b">page 91.</code><code class="fe ks kt ku kv b">Apply[F]</code>——用<code class="fe ks kt ku kv b">ap: F[A =&gt; B] =&gt; F[A] =&gt; F[B]</code>延伸<code class="fe ks kt ku kv b">Functor</code>。这个函数的目的可能不会立即清楚，但它从根本上提供了并行执行的能力:由于<code class="fe ks kt ku kv b">F[A =&gt; B]</code>和<code class="fe ks kt ku kv b">F[A]</code>是完全独立的，只要它们最终组合在一起，它们的求值顺序并不重要。当然，<code class="fe ks kt ku kv b">ap</code>本身很少见到，但是从它派生的方法为并行计算提供了丰富的API。</p><p id="a8e9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe ks kt ku kv b">page 94.</code><code class="fe ks kt ku kv b">Bind[F]</code>(<code class="fe ks kt ku kv b">cats</code>中的<code class="fe ks kt ku kv b">FlatMap[F]</code>)—将<code class="fe ks kt ku kv b">bind: F[A] =&gt; (A =&gt; F[B]) =&gt; F[B]</code>方法(也称为<code class="fe ks kt ku kv b">flatMap</code>)添加到<code class="fe ks kt ku kv b">Apply</code>中，允许“展平”嵌套的<code class="fe ks kt ku kv b">F</code>结构。注意，与<code class="fe ks kt ku kv b">ap</code>不同的是，<code class="fe ks kt ku kv b">bind</code>与顺序执行相关，前者只需要支持顺序行为。</p><h2 id="497e" class="na le iq bd lf nb nc dn lj nd ne dp ln kf nf ng lr kj nh ni lv kn nj nk lz nl bi translated">5.7应用和单子</h2><p id="805f" class="pw-post-body-paragraph ju jv iq jw b jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr ij bi translated"><code class="fe ks kt ku kv b">page 97.</code> <code class="fe ks kt ku kv b">Applicative[F]</code> —为<code class="fe ks kt ku kv b">Apply</code>提供通过<code class="fe ks kt ku kv b">pure: A =&gt; F[A]</code>方法将任意值提升到<code class="fe ks kt ku kv b">F</code>上下文中的能力。<code class="fe ks kt ku kv b">Applicative</code>的主要法则是<em class="mg">恒等式</em>法则:<code class="fe ks kt ku kv b">pure(identity).ap(fa) === fa</code>，其中<code class="fe ks kt ku kv b">identity</code>是返回其参数的一元函数。这条定律意味着由<code class="fe ks kt ku kv b">pure</code>方法创建的值与其他<code class="fe ks kt ku kv b">F[_]</code>值没有任何不同，对它们没有任何影响。</p><p id="eb22" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe ks kt ku kv b">page 98.</code> <code class="fe ks kt ku kv b">Monad[F]</code>是<code class="fe ks kt ku kv b">Bind[F]</code> ( <code class="fe ks kt ku kv b">FlatMap[F]</code>)和<code class="fe ks kt ku kv b">Applicative[F]</code>的组合。它没有提供任何额外的方法，而是以下列3条定律的形式施加了额外的限制:</p><ul class=""><li id="8628" class="mh mi iq jw b jx jy kb kc kf mj kj mk kn ml kr mm mn mo mp bi translated">左身份— <code class="fe ks kt ku kv b">pure(a).bind(f) === f(a)</code>。</li><li id="a14c" class="mh mi iq jw b jx mq kb mr kf ms kj mt kn mu kr mm mn mo mp bi translated">权利认同— <code class="fe ks kt ku kv b">fa.bind(pure(_)) === fa</code>。</li><li id="d48e" class="mh mi iq jw b jx mq kb mr kf ms kj mt kn mu kr mm mn mo mp bi translated">关联性— <code class="fe ks kt ku kv b">fa.bind(f).bind(g) === fa.bind(a =&gt; f(a).bind(g))</code>。</li></ul><p id="05a2" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><em class="mg">作者备注:</em></p><ul class=""><li id="9ed7" class="mh mi iq jw b jx jy kb kc kf mj kj mk kn ml kr mm mn mo mp bi translated"><code class="fe ks kt ku kv b">Applicative</code>和<code class="fe ks kt ku kv b">Monad</code>的区别在于<code class="fe ks kt ku kv b">FlatMap</code>规定了顺序行为，所以有些类型不提供<code class="fe ks kt ku kv b">Monad</code>实例来支持并行执行(见<code class="fe ks kt ku kv b">cats.data.Validated</code>)。</li><li id="a710" class="mh mi iq jw b jx mq kb mr kf ms kj mt kn mu kr mm mn mo mp bi translated"><code class="fe ks kt ku kv b">Apply</code> / <code class="fe ks kt ku kv b">Applicative</code>和<code class="fe ks kt ku kv b">Bind</code> ( <code class="fe ks kt ku kv b">FlatMap</code> ) / <code class="fe ks kt ku kv b">Monad</code>之间存在区别，因为并非所有类型都能够提供<code class="fe ks kt ku kv b">pure</code>方法。例如，不可能为<code class="fe ks kt ku kv b">F[A] = Map[String, A]</code>创建合法的<code class="fe ks kt ku kv b">pure</code>方法。</li></ul><h2 id="193c" class="na le iq bd lf nb nc dn lj nd ne dp ln kf nf ng lr kj nh ni lv kn nj nk lz nl bi translated">5.8各个击破</h2><p id="d265" class="pw-post-body-paragraph ju jv iq jw b jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr ij bi translated"><code class="fe ks kt ku kv b">page 100.</code> <code class="fe ks kt ku kv b">Divide[F]</code> —方法<code class="fe ks kt ku kv b">divide: F[A] =&gt; F[B] =&gt; (C =&gt; (A, B)) =&gt; F[C]</code>的<code class="fe ks kt ku kv b">Apply</code>的逆变模拟。正如定义所暗示的那样，它旨在与逆变位置的类型一起使用(例如函数参数)。例如，<code class="fe ks kt ku kv b">Divide[Equal]</code>可以用来为产品创建<code class="fe ks kt ku kv b">Equal</code>的新实例，产品的元素已经有这样的实例。</p><p id="f41a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe ks kt ku kv b">page 101.</code> <code class="fe ks kt ku kv b">Divisible[F]</code> —一个<code class="fe ks kt ku kv b">Applicative</code>(扩展<code class="fe ks kt ku kv b">Divide</code>)的逆变模拟，允许用<code class="fe ks kt ku kv b">conquer[A]: F[A]</code>创建<code class="fe ks kt ku kv b">F</code>的通用量化(琐碎)实例。任何序列化器都可以有一个<code class="fe ks kt ku kv b">Divisible</code>的实例，其中<code class="fe ks kt ku kv b">conquer</code>将序列化器生成一个空结构。</p><h2 id="1f98" class="na le iq bd lf nb nc dn lj nd ne dp ln kf nf ng lr kj nh ni lv kn nj nk lz nl bi translated">5.9以上</h2><p id="85af" class="pw-post-body-paragraph ju jv iq jw b jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr ij bi translated"><code class="fe ks kt ku kv b">page 102.</code><code class="fe ks kt ku kv b">Plus[F]</code>(<code class="fe ks kt ku kv b">cats</code>中的<code class="fe ks kt ku kv b">SemigroupK[F]</code>)—一个通用的量化模拟<code class="fe ks kt ku kv b">Semigroup</code>，允许为任何类型<code class="fe ks kt ku kv b">A</code>添加两个<code class="fe ks kt ku kv b">F[A]</code>实例。例如，<code class="fe ks kt ku kv b">Plus[List]</code>允许连接任意两个列表。</p><p id="b72c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe ks kt ku kv b">PlusEmpty[F]</code>(<code class="fe ks kt ku kv b">cats</code>中的<code class="fe ks kt ku kv b">MonoidK[F]</code>)—扩展<code class="fe ks kt ku kv b">Plus</code> ( <code class="fe ks kt ku kv b">SemigroupK</code>)，能够为任何<code class="fe ks kt ku kv b">A</code>创建“空”值<code class="fe ks kt ku kv b">F[A]</code>。对于列表，相应的方法将创建一个空列表。</p><p id="11bb" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe ks kt ku kv b">page 104.</code><code class="fe ks kt ku kv b">ApplicativePlus[F]</code>(<code class="fe ks kt ku kv b">cats</code>中的<code class="fe ks kt ku kv b">Alternative[F]</code>)—扩展<code class="fe ks kt ku kv b">Applicative</code>和<code class="fe ks kt ku kv b">PlusEmpty</code> ( <code class="fe ks kt ku kv b">MonoidK</code>)，同时要求遵守几个附加法律。这个类本身不会增加太多，但是当需要具体的和通用的量化实现时，它非常方便。Cats文档中有一个很棒的<a class="ae nm" href="https://typelevel.org/cats/typeclasses/alternative.html" rel="noopener ugc nofollow" target="_blank">例子</a>。</p><p id="688d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe ks kt ku kv b">MonadPlus[F]</code> —扩展<code class="fe ks kt ku kv b">Monad</code>和<code class="fe ks kt ku kv b">ApplicativePlus</code>并提供两个额外的方法:</p><ul class=""><li id="d741" class="mh mi iq jw b jx jy kb kc kf mj kj mk kn ml kr mm mn mo mp bi translated"><code class="fe ks kt ku kv b">unite[T[_]: Foldable, A](ts: F[T[A]]): F[A]</code> —允许消除任意嵌套结构，如果它们有一个<code class="fe ks kt ku kv b">Foldable</code>的实例。</li><li id="089c" class="mh mi iq jw b jx mq kb mr kf ms kj mt kn mu kr mm mn mo mp bi translated"><code class="fe ks kt ku kv b">withFilter[A](fa: F[A])(f: A =&gt; Boolean): F[A]</code> —对<code class="fe ks kt ku kv b">F[A]</code>应用由函数<code class="fe ks kt ku kv b">f</code>描述的过滤器，可能以一种懒惰的方式。</li></ul><p id="8b85" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe ks kt ku kv b">cats</code>中没有<code class="fe ks kt ku kv b">MonadPlus</code>的直接类比，但是<code class="fe ks kt ku kv b">FunctorFilter[F]</code> ( <code class="fe ks kt ku kv b">withFilter</code>)和<code class="fe ks kt ku kv b">Alternative[F]</code> ( <code class="fe ks kt ku kv b">unite</code>需要一个<code class="fe ks kt ku kv b">Monad[F]</code>实例)提供了相同的一套方法。</p><h2 id="d3d6" class="na le iq bd lf nb nc dn lj nd ne dp ln kf nf ng lr kj nh ni lv kn nj nk lz nl bi translated">5.10孤狼</h2><p id="13dc" class="pw-post-body-paragraph ju jv iq jw b jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr ij bi translated"><code class="fe ks kt ku kv b">page 106.</code><code class="fe ks kt ku kv b">Zip[F]</code>(<code class="fe ks kt ku kv b">cats</code>中的<code class="fe ks kt ku kv b">Semigroupal[F]</code>)—<code class="fe ks kt ku kv b">Divide</code>的一个不太强大的模拟，它提供了将<code class="fe ks kt ku kv b">F</code>的两个实例合并为一个的<code class="fe ks kt ku kv b">zip[A](fa: F[A], fb: F[B]): F[(A, B)]</code>方法。<code class="fe ks kt ku kv b">zip</code>在<code class="fe ks kt ku kv b">cats</code>中被称为<code class="fe ks kt ku kv b">product</code>。</p><p id="0b42" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe ks kt ku kv b">Unzip[F]</code> —与<code class="fe ks kt ku kv b">Zip</code>相反的<code class="fe ks kt ku kv b">unzip[A](fab: F[(A, B)]): (F[A], F[B])</code>方法，允许分割嵌入到效果<code class="fe ks kt ku kv b">F</code>中的元组来分离效果。包含在<code class="fe ks kt ku kv b">cats</code>中的<code class="fe ks kt ku kv b">Functor</code>。</p><h2 id="31cc" class="na le iq bd lf nb nc dn lj nd ne dp ln kf nf ng lr kj nh ni lv kn nj nk lz nl bi translated">5.11共同事务</h2><p id="e391" class="pw-post-body-paragraph ju jv iq jw b jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr ij bi translated"><code class="fe ks kt ku kv b">page 109.</code><code class="fe ks kt ku kv b">Cobind[F]</code>(<code class="fe ks kt ku kv b">cats</code>中的<code class="fe ks kt ku kv b">CoflatMap[F]</code>)—一个带有附加<code class="fe ks kt ku kv b">cobind(fa: F[A])(f: F[A] =&gt; B): F[B]</code> ( <code class="fe ks kt ku kv b">coflatMap</code>)操作的<code class="fe ks kt ku kv b">Functor</code>。</p><p id="c0ca" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe ks kt ku kv b">page 110.</code> <code class="fe ks kt ku kv b">Comonad[F]</code> —用<code class="fe ks kt ku kv b">copoint(fa: F[A]): A</code> ( <code class="fe ks kt ku kv b">extract</code>)扩展<code class="fe ks kt ku kv b">Cobind</code> ( <code class="fe ks kt ku kv b">CoflatMap</code>)，基本上消除了任何值周围的结构。</p><p id="ad21" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">一个很好的说明<code class="fe ks kt ku kv b">Comonad</code>是细胞自动机，它根据细胞各自的环境<code class="fe ks kt ku kv b">F[A]</code>计算新一代<code class="fe ks kt ku kv b">F[B]</code>细胞，并允许提取每个细胞的值。</p><h1 id="0c0c" class="ld le iq bd lf lg mv li lj lk mw lm ln lo mx lq lr ls my lu lv lw mz ly lz ma bi translated">第6章— (Scalaz)数据类型</h1><p id="4153" class="pw-post-body-paragraph ju jv iq jw b jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr ij bi translated"><code class="fe ks kt ku kv b">page 117.</code> <strong class="jw ir">持久集合</strong>无论何时修改，都会保留原始集合的副本，因此允许重用这些副本进行数据访问。结构共享至关重要，因为任何修改都会导致整个集合的重建。</p><h2 id="3e2d" class="na le iq bd lf nb nc dn lj nd ne dp ln kf nf ng lr kj nh ni lv kn nj nk lz nl bi translated">6.4标签</h2><p id="fc2f" class="pw-post-body-paragraph ju jv iq jw b jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr ij bi translated"><code class="fe ks kt ku kv b">page 127.</code>不要与精致类型混淆。</p><h2 id="7512" class="na le iq bd lf nb nc dn lj nd ne dp ln kf nf ng lr kj nh ni lv kn nj nk lz nl bi translated">6.5自然转变</h2><p id="48fb" class="pw-post-body-paragraph ju jv iq jw b jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr ij bi translated"><code class="fe ks kt ku kv b">page 130.</code> <strong class="jw ir">自然转换</strong>是类型构造函数<code class="fe ks kt ku kv b">F[_]</code>和<code class="fe ks kt ku kv b">G[_]</code>上的函数，定义了一个通用的量化映射:<code class="fe ks kt ku kv b">F[A] =&gt; G[A]</code>用于所有可能的类型<code class="fe ks kt ku kv b">A</code>。自然转换的一个常见的真实例子是从数据库事务执行上下文<code class="fe ks kt ku kv b">F</code>到应用程序执行上下文<code class="fe ks kt ku kv b">G</code>。</p><h2 id="8173" class="na le iq bd lf nb nc dn lj nd ne dp ln kf nf ng lr kj nh ni lv kn nj nk lz nl bi translated">6.6同构</h2><p id="31f7" class="pw-post-body-paragraph ju jv iq jw b jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr ij bi translated"><code class="fe ks kt ku kv b">page 131.</code> <strong class="jw ir">同构</strong>定义了两个类型(或类型构造函数)<code class="fe ks kt ku kv b">A</code>和<code class="fe ks kt ku kv b">B</code>之间的相等关系，这意味着对于每个类型为<code class="fe ks kt ku kv b">A</code>的对象，有且只有一个类型为<code class="fe ks kt ku kv b">B</code>的相等对象，反之亦然。同构对于自动实例派生特别有用</p><h2 id="30b2" class="na le iq bd lf nb nc dn lj nd ne dp ln kf nf ng lr kj nh ni lv kn nj nk lz nl bi translated">6.7集装箱</h2><p id="25b8" class="pw-post-body-paragraph ju jv iq jw b jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr ij bi translated"><code class="fe ks kt ku kv b">page 138.</code><code class="fe ks kt ku kv b">Validation[E, A]</code>—<code class="fe ks kt ku kv b">Either[E, A]</code>的模拟，允许误差累积。这被称为<strong class="jw ir">应用行为</strong>，因为<code class="fe ks kt ku kv b">Validation</code>没有<code class="fe ks kt ku kv b">Monad</code>实例。当多个错误可能同时发生，并且所有错误都需要向上游传播，而不仅仅是一个错误时，<code class="fe ks kt ku kv b">Validation</code>非常有用(<code class="fe ks kt ku kv b">Either</code>行为)。</p><p id="d664" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe ks kt ku kv b">page 141.</code>历史上，在JVM上创建异常是相当慢的，因为构建stacktrace需要资源。有证据表明，对于失败案例，使用<code class="fe ks kt ku kv b">Either</code>或<code class="fe ks kt ku kv b">Validation</code>要比使用异常快上千倍。</p><p id="5fee" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe ks kt ku kv b">These[A, B]</code>(<code class="fe ks kt ku kv b">cats</code>中的<code class="fe ks kt ku kv b">Ior[A, B]</code>)表示具有<code class="fe ks kt ku kv b">A</code>、<code class="fe ks kt ku kv b">B</code>或两者值的类型，类似于包含逻辑or。偏向<code class="fe ks kt ku kv b">B</code>型，等同于<code class="fe ks kt ku kv b">Either</code>或<code class="fe ks kt ku kv b">Validation</code>，可用于累积部分错误或警告。</p><p id="ef7d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><em class="mg">作者备注:</em></p><p id="e342" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">有趣的是，stacktrace的生成非常消耗资源，以至于在某些情况下有一个特殊的优化选项可以省略它们。</p><p id="09f0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe ks kt ku kv b">page 145.</code> <code class="fe ks kt ku kv b">Const[A, B]</code> —具有类型<code class="fe ks kt ku kv b">A</code>的常数值的类型，充当<code class="fe ks kt ku kv b">B</code>的上下文。在通过<code class="fe ks kt ku kv b">F[_]</code>抽象的程序中，收集类型为<code class="fe ks kt ku kv b">A</code>的对象中的元数据或统计数据，并为任何具有<code class="fe ks kt ku kv b">Monoid</code>实例的<code class="fe ks kt ku kv b">A</code>提供可应用的行为是非常有用的。</p><h2 id="01ad" class="na le iq bd lf nb nc dn lj nd ne dp ln kf nf ng lr kj nh ni lv kn nj nk lz nl bi translated">6.8集合</h2><p id="a061" class="pw-post-body-paragraph ju jv iq jw b jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr ij bi translated"><code class="fe ks kt ku kv b">page 150.</code> <strong class="jw ir">共递归</strong>是从一个基本状态开始，确定性地生成一系列(可能是无限的)新状态，这与将有限的步骤序列折叠成一个基本状态的递归相反。当使用<code class="fe ks kt ku kv b">Comonad</code>时，这可能特别有用。</p><h1 id="5da5" class="ld le iq bd lf lg mv li lj lk mw lm ln lo mx lq lr ls my lu lv lw mz ly lz ma bi translated">第七章。高级单子</h1><h2 id="af1c" class="na le iq bd lf nb nc dn lj nd ne dp ln kf nf ng lr kj nh ni lv kn nj nk lz nl bi translated">7.1永远在运动的是未来</h2><p id="3dfe" class="pw-post-body-paragraph ju jv iq jw b jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr ij bi translated">Scala标准库中的<code class="fe ks kt ku kv b">page 173.</code> <code class="fe ks kt ku kv b">Future</code>是热切的，意味着一旦<code class="fe ks kt ku kv b">Future</code>的实例被创建，执行就开始。因为<code class="fe ks kt ku kv b">Future</code>结合了计算定义及其执行，所以调度和结合它们变得不方便。此外，这意味着<code class="fe ks kt ku kv b">Future</code>是不纯的，因为根据计算是否已经完成，它的实例可以有不同的值。</p><p id="b354" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe ks kt ku kv b">Future</code>还有几个性能缺陷:每次调用<code class="fe ks kt ku kv b">flatMap</code>时，计算的闭包被提交给执行器，潜在地切换线程和执行上下文。这可能会导致很大一部分CPU时间花费在调度上，并使顺序工作比使用<code class="fe ks kt ku kv b">Future</code>的并行工作更快。</p><h2 id="fac0" class="na le iq bd lf nb nc dn lj nd ne dp ln kf nf ng lr kj nh ni lv kn nj nk lz nl bi translated">7.2效果和副作用</h2><p id="bb0d" class="pw-post-body-paragraph ju jv iq jw b jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr ij bi translated"><code class="fe ks kt ku kv b">page 174.</code>由于函数式编程中的函数是纯函数，因此不允许有副作用，这就提出了在哪里以及如何执行它们的问题。FP对这个问题的传统回答是<strong class="jw ir">I/O</strong>T25】monads它会暂停计算，直到显式地运行它们。这样的单子使得副作用在返回类型中显而易见，因此通常只被称为<strong class="jw ir">效果</strong>。</p><p id="5861" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><em class="mg">作者笔记:</em></p><p id="3b9b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">具体来说，编写时最常用的I/O单子是<code class="fe ks kt ku kv b">cats.effect.IO</code>、<code class="fe ks kt ku kv b">monix.eval.Task</code>和<code class="fe ks kt ku kv b">zio.ZIO</code>。</p><h2 id="e761" class="na le iq bd lf nb nc dn lj nd ne dp ln kf nf ng lr kj nh ni lv kn nj nk lz nl bi translated">7.3烟囱安全</h2><p id="e738" class="pw-post-body-paragraph ju jv iq jw b jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr ij bi translated"><code class="fe ks kt ku kv b">page 175.</code> Scala编译器允许创建栈安全<strong class="jw ir">尾递归</strong>方法。<code class="fe ks kt ku kv b">scalaz</code>和<code class="fe ks kt ku kv b">cats</code>分别用<code class="fe ks kt ku kv b">BindRec</code>和<code class="fe ks kt ku kv b">StackSafeMonad</code>将这个上下文扩展到单子，<code class="fe ks kt ku kv b">bind</code>和<code class="fe ks kt ku kv b">flatMap</code>的调用必须只需要常量堆栈空间。</p><p id="b0f6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><em class="mg">作者备注:</em></p><p id="1645" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">通过要求提供<code class="fe ks kt ku kv b">tailRecM</code>方法的实现，堆栈安全被嵌入到<code class="fe ks kt ku kv b">cats</code>中的<code class="fe ks kt ku kv b">Monad</code>中。<code class="fe ks kt ku kv b">StackSafeMonad</code>为明确起见。</p><p id="8af7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe ks kt ku kv b">page 176.</code>代数数据类型可用于编码挂起的函数调用，其部分乘积对应于函数自变量。这就是所谓的<strong class="jw ir">教会编码</strong>。它允许为编码函数创建堆栈安全的解释器，代价是存储ADT对象需要额外的堆空间。这样的解释器通常基于一个叫做<code class="fe ks kt ku kv b">Free</code> (monad)的结构，它是<code class="fe ks kt ku kv b">Monad</code>接口的ADT表示。</p><p id="bdd8" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe ks kt ku kv b">page 179.</code>尽管<code class="fe ks kt ku kv b">Free</code>看起来比不使用对象来表示计算的同等解决方案的性能要差得多，但在现代架构和最新版本的JVM上，情况可能并非如此。建议是，在做出最终判断之前，一定要进行基准测试。</p><h2 id="bb43" class="na le iq bd lf nb nc dn lj nd ne dp ln kf nf ng lr kj nh ni lv kn nj nk lz nl bi translated">7.4 Monad变压器库</h2><p id="1111" class="pw-post-body-paragraph ju jv iq jw b jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr ij bi translated"><code class="fe ks kt ku kv b">page 180.</code> <strong class="jw ir">单子变形金刚</strong>在其他单子上面提供额外的效果。最重要的是，它们可以组合在一起产生复杂的效果。提供单子变压器的库通常被称为<em class="mg">单子变压器库</em> (MTL)。</p><p id="e947" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">一些较常见的变压器有:</p><ul class=""><li id="4383" class="mh mi iq jw b jx jy kb kc kf mj kj mk kn ml kr mm mn mo mp bi translated"><code class="fe ks kt ku kv b">OptionT[F[_], A]</code> —包装<code class="fe ks kt ku kv b">F[Option[A]]</code>。</li><li id="ecd4" class="mh mi iq jw b jx mq kb mr kf ms kj mt kn mu kr mm mn mo mp bi translated"><code class="fe ks kt ku kv b">EitherT[F[_], E, A]</code> —包装<code class="fe ks kt ku kv b">F[Either[E, A]]</code>。</li><li id="4ff5" class="mh mi iq jw b jx mq kb mr kf ms kj mt kn mu kr mm mn mo mp bi translated"><code class="fe ks kt ku kv b">ReaderT[F[_], A, B]</code> —包裹<code class="fe ks kt ku kv b">A =&gt; F[B]</code>(也称<code class="fe ks kt ku kv b">Kleisli</code>)。</li><li id="6e33" class="mh mi iq jw b jx mq kb mr kf ms kj mt kn mu kr mm mn mo mp bi translated"><code class="fe ks kt ku kv b">WriterT[F[_], W, A]</code> —包装<code class="fe ks kt ku kv b">F[(W, A)]</code>。</li><li id="b51b" class="mh mi iq jw b jx mq kb mr kf ms kj mt kn mu kr mm mn mo mp bi translated"><code class="fe ks kt ku kv b">StateT[F[_], S, A]</code> —缠绕<code class="fe ks kt ku kv b">S =&gt; F[(S, A)]</code>。</li></ul><p id="4ee7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><em class="mg">作者笔记:</em></p><p id="824f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在许多情况下，monad转换器提供的功能可以由一个类型类来表示。关键的区别在于，monad transformers允许合成并从本质上改变程序正在使用的效果，而type类通过附加功能丰富了基本效果。</p><p id="8c10" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">当用<code class="fe ks kt ku kv b">EitherT</code>或它的等价类型<code class="fe ks kt ku kv b">MonadError</code>处理错误时，人们对错误的类型有不同的看法。主要是，它是一个错误的ADT，<code class="fe ks kt ku kv b">String</code>，或<code class="fe ks kt ku kv b">Throwable</code>。建议使用灵活的结构化格式，如JSON，使错误可扩展，但不要太不透明。</p><p id="e72c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe ks kt ku kv b">page 192.</code>虽然<code class="fe ks kt ku kv b">WriterT</code>可以用来实现日志记录，但经常有人认为日志记录应该需要自己的代数，因为出于性能原因，它通常被不同地处理。</p><p id="ecd8" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe ks kt ku kv b">page 202.</code> <code class="fe ks kt ku kv b">ContT</code>允许使用延续来链接计算，也就是通常所说的“回调风格”。虽然链接本身并不特别有用，因为它也可以用单子来完成，<code class="fe ks kt ku kv b">ContT</code>允许重新排序控制流，使其变成非线性的，类似于一个图。</p><h2 id="6f36" class="na le iq bd lf nb nc dn lj nd ne dp ln kf nf ng lr kj nh ni lv kn nj nk lz nl bi translated">7.5免费午餐</h2><p id="759c" class="pw-post-body-paragraph ju jv iq jw b jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr ij bi translated"><code class="fe ks kt ku kv b">page 212.</code> JVM的JIT编译器允许简单函数具有与C/C++等价函数相当的性能，甚至可能消除垃圾收集的影响。然而，它的能力仍然局限于低级优化。</p><p id="92b1" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">根据元级别上的高级概念描述程序的数据结构将允许应用高级优化。这种构造通常被称为<code class="fe ks kt ku kv b">Free</code>结构，可以很容易地为程序的代数接口生成。</p><p id="2710" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe ks kt ku kv b">page 218.</code>排放指标和运行时分析是少数几个可能会产生直接副作用的案例之一。如果这种监视不影响程序本身，引用透明属性仍然有效。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="7727" class="ld le iq bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">结论</h1><p id="1143" class="pw-post-body-paragraph ju jv iq jw b jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn mf kp kq kr ij bi translated">虽然提供的摘录远未涵盖所有函数式编程基础的详尽列表，但它们应该是与现有Scala库交互和探索更高级概念的良好基础。</p><p id="b3f0" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我要感谢原书的作者Sam Halliday以及<code class="fe ks kt ku kv b">scalaz</code>、<code class="fe ks kt ku kv b">cats</code>和<code class="fe ks kt ku kv b">zio</code>库背后的所有人，他们为Scala的生态系统所做的一切，最终激发了我写这篇文章的灵感。</p></div></div>    
</body>
</html>