# 深入了解 JavaScript 中的面向对象编程

> 原文：<https://levelup.gitconnected.com/a-deeper-look-at-object-oriented-programming-in-javascript-6ab7761131a2>

![](img/b1d3033393fddf1a2491fcddd7cd75e3.png)

照片由[格雷格·拉科齐](https://unsplash.com/@grakozy?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)在 [Unsplash](https://unsplash.com/s/photos/javascript?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上拍摄

JavaScript 是一种无类编程语言。如你所知，在 Java 等其他语言中，类在 JavaScript 中是不存在的。

尽管 JavaScript 没有提供对类的支持，但是 JavaScript 中现有概念(构造函数和原型继承)的巧妙使用使得开发人员能够成功地模拟这种行为。因此，ES6 更新后，您可以在 JavaScript 中找到的关键字`class`是使用现有 JavaScript 概念模拟类所需步骤的语法抽象。在这篇文章中，我们将看到 class 关键字背后的基本概念。

但是首先，让我们看看创建对象的两种最简单的方法

# 对象构造函数和对象文字

JavaScript 允许您使用`Object()`构造函数创建对象。对象构造函数为给定值创建一个对象包装。如果值为 null，它将创建并返回一个空对象。

在上面的例子中，通过调用带有空参数的对象构造函数，我们初始化了一个空对象，并把它赋给了变量 dog。然后我们简单地在`dog`变量的帮助下添加对象属性

在 JavaScript 的最初几年后，对象文字成为创建对象的首选方式。我们可以将前面的例子改写为:

虽然使用`Object Constructor`和`Object literal`非常简单，但在创建对象时也有一些缺点。用同一个接口创建多个对象需要大量的代码复制。

# 创建对象

我们可以简单地使用`class`来创建对象，这是自从 ES6 引入类以来的首选方式。但是要理解 Javascript 中的 OOP 是如何工作的，我们必须理解被类取代的底层概念。所以我们应该看看用接口实现对象创建的一些方法。

## **函数构造器模式**

JavaScript 对象可以使用构造函数来创建。JavaScript 中有一些现成的本地构造函数，比如`Object`和`Array`。可以使用定义属性和方法的函数来定义自定义构造函数。所以让我们从创建一个名为`dog`的对象开始。

注意，使用`dog`函数作为构造函数来创建一个对象，我们在行号`10`中使用了`new`操作符。当执行第`10`行时，发生以下步骤:

1.  在内存中创建了一个新对象
2.  它将这个新对象的内部不可访问的`[[prototype]]`属性设置为构造函数的外部可访问的*原型*对象(每个函数对象自动具有一个*原型*属性)。
3.  `this`值被分配给新创建的对象。
4.  每当提到`this`时，它就使用新创建的对象执行构造函数。
5.  除非构造函数返回一个`non-null`对象引用，否则将返回新创建的对象。在这种情况下，将返回该对象引用。

构造函数和其他函数的唯一区别是它们被调用的方式。任何用`new`操作符调用的函数都充当构造函数。

在使用构造函数创建对象时，值得注意的一点是`tuffy`对象在`dog`构造函数中有自己的属性副本。即。更改与一个对象关联的属性不会影响构造函数的属性。让我们来看一个例子:

从上面的例子可以看出，改变`tuffy`对象中的玩具属性对`tyson`对象中的`toys`属性没有影响。因为`tuffy`和`tyson`都有自己的构造函数属性副本。

但是由于对象有自己的属性副本，我们可能会面临内存相关的问题。因为同一属性的多个副本会占用大量空间。这是函数构造模式的主要缺点。

## **原型图案**

每当你用 JavaScript 创建一个函数时，你会注意到在函数的定义中附加了一个对象名 prototype。在原型对象内部，我们可以添加结果对象应该继承的属性。使用原型的好处是得到的对象没有属性的副本，但是它仍然可以通过在原型对象中搜索属性和方法来访问它们。

让我们举个例子:

prototype 的工作方式是，当访问一个属性时，搜索开始查找该属性。搜索首先从对象开始，如果在对象中找到属性，则返回值。就像当我们试图调用第`12`行中的`dog.legs`时，它返回值 4，因为属性腿存在于对象中。并且当在对象中没有找到该属性时，搜索继续沿着原型向上。并且在原型中搜索该属性。如果在原型上找到该属性，则它将返回值。如果没有找到，则继续沿着原型链向上搜索，直到遇到该属性。就像当我们试图访问`boy`上的属性分支时，搜索移动到原型，因为对象男孩没有属性分支。因为对象 boy 的原型具有属性 legs，所以它返回值。

我们需要记住的一点是，原型是动态的。因此，原型在任何时候的任何变化都会反映在对象上。

甚至原型图案也不完美。第一个缺点是，你不能像我们在函数构造函数中那样传递参数。但老实说，这并不是一个很大的缺点，它很不方便，但开发者可以很容易地克服它。

但是引用属性带来了真正的问题。让我们举个例子来理解这个缺点:

你可以看到`dog1`和`dog2`都有相同的属性。这是因为在`line 6`中，push 函数实际上引用了返回原型中存在的`toys`属性的属性，并向`toys`数组添加了一个新值。因此，可引用的属性会导致这种不一致的行为。

原型的这种行为对一些人来说是可取的，但对另一些人来说可能是个问题。尽管通常希望对象具有它们自己的属性副本。因此很少单独使用原型模式。

# 遗产

JavaScript 中的继承主要是通过原型链接来完成的。首先，我们应该知道什么是原型链。

## **原型链接**

JavaScript 只有一个构造，那就是对象。正如我们已经看到的，每个对象都有一个称为原型的属性。原型是指向构造函数的属性和方法的对象。但是原型不一定是构造函数，它也可以是一个对象。这个对象也有自己的原型，它的原型也可能有自己的原型，这种模式将继续下去，形成一个原型链，称为原型链。

让我们看看原型链是如何实现的:

所以正如你所看到的，`human`通过将它的原型指针指向`animals`对象来继承`animals`。因此，当我们访问`Jon.canWalk`时，它在它的对象中搜索 canWalk 属性，然后在它的原型:`human`对象中搜索，然后搜索到达`animals`对象，最后返回它的值。

原型链接的问题和我们面对的原型问题是一样的。当我们使用包含引用值的属性时，这些属性在对象之间共享，这就是为什么属性是使用构造函数定义的。

> 属性通常在构造函数中定义，而不是使用原型。因为我们已经看到，具有参考值的属性可能会令人恼火。

## **古典传承**

经典继承或构造函数窃取或伪装都意味着同样的事情。经典继承背后的思想是在一个对象的构造函数内部调用另一个对象的构造函数。我们可以利用`apply()`和`call()`方法在新创建的对象上执行构造函数。让我们来看看这个例子。

通过使用`call()`或`apply()`方法，我们实际上是从形状中窃取了构造函数。在 square 构造函数中调用 shapes 构造函数时，它正在运行 shapes 构造函数的代码初始化，因此每个 square 类型的对象都有自己颜色的副本。

构造函数窃取(经典继承)带来了优于原型链接的好处。使用经典继承，我们能够传递参数，这在原型链中是不利的。

也就是说，经典继承有其自身的缺点。方法必须写在构造函数内部，所以没有函数重用。构造函数窃取不会自动创建原型，因此子类型对象不能使用超类型的原型。

## 组合遗传

组合继承(也称为伪经典继承)是原型链接和经典继承的组合。因此，我们可以从原型继承属性和方法，并使用经典继承来继承实例属性。

正如你所看到的，我们使用构造函数窃取(经典继承)来继承属性，使用原型链接来继承方法。所以我们创建了 object dog 的两个实例，它们有自己的属性副本，同时它们共享一个方法。

# 班级

到目前为止，我们已经深入了解了如何在 JavaScript 中模拟类。但是实现这些方法可能是一项单调乏味的任务，并且会增加在代码中产生 bug 的可能性。所以从 ES6 开始`class`被引入，它抽象了 JavaScript 中 OOPs 背后的逻辑。ES6 类似乎以规范的面向对象编程为特色，但是它们仍然使用原型和构造函数。

我们可以用两种方式编写类定义:类声明和类表达式

注意:默认情况下，class 方法中的所有内容都在严格模式下执行。

一个类可以由构造函数、get 方法、set 方法、方法和静态方法组成。

为了使用`class`创建一个对象，我们使用了`new`关键字。关键字`new`将遵循我们在前面章节中使用`function constructor`创建对象时看到的相同步骤。

在 JavaScript 中，类是一等公民。这意味着类可以做其他事物可以做的一切。可以像传递任何其他对象或函数引用一样传递类。类可以在函数的任何地方使用(例如在数组和函数参数中)。

下面是我们通常在类对象中看到的一些成员:

在一个类中，所有在构造函数中定义的成员和属性都不会共享给 prototype。每个实例在构造函数中都有一个所有属性和方法的副本。这些属性与我们在创建对象时使用函数构造函数时看到的属性相同。

在构造函数之外和类体的根中定义的所有东西都被附加到原型对象上。

注意:原始数据类型和对象不能添加到类的根。

静态方法是即使没有类的实例也可以使用的方法。正如我们在第`16`行看到的，方法`sayHello`没有创建类的实例就被使用了，因为它是一个静态方法。

# 遗产

ES6 更新的另一个特点是继承。语法是不同的，但是类继承仍然使用原型链接来实现继承。

关键字允许从任何具有属性和原型的事物中继承。这意味着它是向后兼容的，所以你可以从另一个类继承，也可以从函数构造函数继承。

在这个例子中，我们从`Animal`类继承了`Dog`类中的属性和方法。我们已经使用了`super()`方法来调用`Animal`类的构造函数。

JavaScript 中的 OOPs 模式到此结束。我们已经看到，没有任何正式的类概念，我们仍然可以在 JS 中实现类和继承。我们知道 JavaScript 到底是如何工作的是很重要的。原型和函数构造器在 JavaScript 中很重要，人们应该花时间去了解它们。

快乐编码:)