<html>
<head>
<title>RPG game with React / Redux / HTML5 — Part 1 —build a tile map with a moving character</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React / Redux / HTML5的RPG游戏——第1部分——使用移动的角色构建一个平铺地图</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/rpg-game-with-react-redux-html5-part-1-build-a-tile-map-9144fd867830?source=collection_archive---------3-----------------------#2020-10-12">https://levelup.gitconnected.com/rpg-game-with-react-redux-html5-part-1-build-a-tile-map-9144fd867830?source=collection_archive---------3-----------------------#2020-10-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><h1 id="581a" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">介绍</h1><p id="d223" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在我之前的<a class="ae lj" rel="noopener ugc nofollow" target="_blank" href="/writing-falling-dots-game-with-react-8b2884fa683d">教程</a>中，我用React + HTML / CSS stack写了一个关于点击落点得分的小游戏。在本文中，我们将浏览另一个使用React + Redux + HTML5技术堆栈的小游戏开发教程。此外，我们将仔细研究一个相对较新的工具集，名为<a class="ae lj" href="https://redux-toolkit.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux Toolkit </a>，它旨在使我们使用React / Redux的工作更加容易。完整的工作源代码位于<a class="ae lj" href="https://github.com/KilroggD/rpg-react-redux" rel="noopener ugc nofollow" target="_blank">库</a>中。</p><p id="bbd2" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">享受你的阅读和编码吧！:)</p></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h1 id="1064" class="jn jo iq bd jp jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk bi translated">从哪里开始</h1><p id="e4bc" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">对于一篇文章来说，编写一个全功能的RPG游戏是一项巨大的任务，所以本教程只介绍几个重要的特性。</p><ul class=""><li id="b9ea" class="mb mc iq kn b ko lk ks ll kw md la me le mf li mg mh mi mj bi translated">游戏领域表示为一个平铺地图，其中包含不同类型的地形和障碍，以及一个方形平铺的坐标网格</li><li id="564e" class="mb mc iq kn b ko mk ks ml kw mm la mn le mo li mg mh mi mj bi translated">能够在4个主要方向移动的角色模型</li><li id="ed16" class="mb mc iq kn b ko mk ks ml kw mm la mn le mo li mg mh mi mj bi translated">代表主角状态的简单UI。</li></ul><p id="2ca0" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">在这个教程中，我使用了一些从https://opengameart.org/网站下载的免费像素艺术收藏。</p><p id="bbb4" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">最终结果如下所示:</p><figure class="mq mr ms mt gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi mp"><img src="../Images/83c9bf6473879336e1a808402daa16c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ajmzkG_ub2fufg0WN4GwbQ.png"/></div></div></figure><p id="b32d" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">完整的源代码可以在<a class="ae lj" href="https://github.com/KilroggD/rpg-react-redux" rel="noopener ugc nofollow" target="_blank">库</a>中找到。要运行代码，只需克隆存储库，通过运行以下命令安装所有必需的软件包:</p><pre class="mq mr ms mt gt nb nc nd ne aw nf bi"><span id="e868" class="ng jo iq nc b gy nh ni l nj nk">npm install</span></pre><p id="3ef2" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">并通过运行以下命令在开发模式下启动代码:</p><pre class="mq mr ms mt gt nb nc nd ne aw nf bi"><span id="f8d9" class="ng jo iq nc b gy nh ni l nj nk">npm start</span></pre></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h1 id="2e9c" class="jn jo iq bd jp jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk bi translated">解释了技术堆栈</h1><ul class=""><li id="cb94" class="mb mc iq kn b ko kp ks kt kw nl la nm le nn li mg mh mi mj bi translated">React和Redux用于游戏状态和逻辑——几乎免费共享游戏状态和开箱即用的组件支持，轻松集成连接到共享状态的游戏UI元素。</li><li id="490e" class="mb mc iq kn b ko mk ks ml kw mm la mn le mo li mg mh mi mj bi translated">Redux工具包——让我们使用Redux的工作变得更加容易</li><li id="1cba" class="mb mc iq kn b ko mk ks ml kw mm la mn le mo li mg mh mi mj bi translated">HTML5 <a class="ae lj" href="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API" rel="noopener ugc nofollow" target="_blank"> Canvas API </a> —与在HTML/CSS中实现相同功能相比，代码更少，性能优化更好。</li><li id="12f3" class="mb mc iq kn b ko mk ks ml kw mm la mn le mo li mg mh mi mj bi translated">JavaScript<a class="ae lj" href="https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame" rel="noopener ugc nofollow" target="_blank">request animation frame</a>方法——为我们的HTML5游戏提供接近60 fps的性能优化。</li></ul><p id="103a" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">你可能知道React和Redux通常不用于游戏开发。在本文中，我们将使用React / Redux作为状态管理和组件化工具，在HTML5 Canvas上呈现大部分UI。React还将帮助我们呈现有用的UI元素。此外，本教程旨在展示如何结合HTML5 Canvas API使用React / Redux，并对React hooks和Redux进行更多练习。</p></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h1 id="5b9a" class="jn jo iq bd jp jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk bi translated">关于Redux工具包的一些话</h1><p id="ef7a" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">Redux工具包包旨在成为编写Redux逻辑的标准方式。最初，它的设计是为了使Redux的使用更容易，并减少创建React/Redux应用程序所需的样板文件的数量。此外，使用这个工具包将创建Redux应用程序所需的包的数量减少到一个包——工具包本身</p><pre class="mq mr ms mt gt nb nc nd ne aw nf bi"><span id="92fe" class="ng jo iq nc b gy nh ni l nj nk">npm install @reduxjs/toolkit</span></pre><p id="3acc" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">本教程的另一个目的是尝试Redux Toolkit的一些主要特性和概念，看看它是如何工作的。</p></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h1 id="8395" class="jn jo iq bd jp jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk bi translated">常量和设置</h1><p id="edea" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">最大的<a class="ae lj" href="https://github.com/KilroggD/rpg-react-redux/blob/master/src/tile-view/constants.js" rel="noopener ugc nofollow" target="_blank">常量文件</a>包含平铺地图的主要设置:</p><ul class=""><li id="8c5c" class="mb mc iq kn b ko lk ks ll kw md la me le mf li mg mh mi mj bi translated">以像素为单位的平铺尺寸</li><li id="5b2b" class="mb mc iq kn b ko mk ks ml kw mm la mn le mo li mg mh mi mj bi translated">映射维度(行和列)</li><li id="192e" class="mb mc iq kn b ko mk ks ml kw mm la mn le mo li mg mh mi mj bi translated">地图瓦片阵列(让我们现在做2层)</li><li id="f567" class="mb mc iq kn b ko mk ks ml kw mm la mn le mo li mg mh mi mj bi translated">平铺图像的哈希映射(将数组中的数字映射到实际图像)</li><li id="5a76" class="mb mc iq kn b ko mk ks ml kw mm la mn le mo li mg mh mi mj bi translated">可能的移动方向(让我们向上/向下、向左/向右移动)</li><li id="2334" class="mb mc iq kn b ko mk ks ml kw mm la mn le mo li mg mh mi mj bi translated">我们的英雄无法通过的“实心”瓷砖列表</li></ul><p id="6d59" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">所有这些常量都将用于构建我们的游戏。</p><p id="2ed7" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">还有一个更小的<a class="ae lj" href="https://github.com/KilroggD/rpg-react-redux/blob/master/src/constants.js" rel="noopener ugc nofollow" target="_blank">常量文件</a>，包含与我们的角色对象相关的参数(精灵、图像、大小等)。)</p></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h1 id="fdb0" class="jn jo iq bd jp jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk bi translated">国家结构</h1><p id="4940" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在设计React / Redux应用程序时，从应用程序的状态结构开始通常是有意义的。Redux toolkit有非常有用的工具用于状态结构设计和状态管理，称为<a class="ae lj" href="https://redux-toolkit.js.org/tutorials/basic-tutorial#introducing-createslice" rel="noopener ugc nofollow" target="_blank">切片</a>。它允许我们为一个对象提供reducer函数、自动生成的action类型字符串和基于我们列出的reducer名称的action creator函数。我们可以为切片定义初始状态对象。简而言之，我们可以把slice看作redux store的一部分，它有自己的初始状态和派生新状态的动作。<a class="ae lj" href="https://github.com/KilroggD/rpg-react-redux/blob/master/src/tile-view/slices/characterSlice.js" rel="noopener ugc nofollow" target="_blank">角色对象的切片</a>就是一个很好的例子:</p><pre class="mq mr ms mt gt nb nc nd ne aw nf bi"><span id="4659" class="ng jo iq nc b gy nh ni l nj nk">import {createSlice} from '<a class="ae lj" href="http://twitter.com/reduxjs/toolkit" rel="noopener ugc nofollow" target="_blank">@reduxjs/toolkit</a>';</span><span id="ba55" class="ng jo iq nc b gy no ni l nj nk">const characterSlice = createSlice({<br/>    name: 'character',<br/>    initialState: {<br/>        x: 6,<br/>        y: 6,        <br/>        heroClass: 'FLAME_SWORDSMAN',<br/>        heroImg: null,<br/>    },<br/>    reducers: {<br/>        move(state, action) {<br/>            const [x, y] = action.payload;       <br/>            state.x+=x;<br/>            state.y+=y;<br/>        },<br/>        bufferImage(state, action) {<br/>            state.heroImg = action.payload;<br/>        }<br/>    }<br/>});</span><span id="5299" class="ng jo iq nc b gy no ni l nj nk">export const { move, bufferImage } = characterSlice.actions;</span><span id="ad09" class="ng jo iq nc b gy no ni l nj nk">export default characterSlice.reducer;</span></pre><p id="28ec" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">它包含带有英雄参数和初始坐标的初始状态。还有两个动作——将英雄对象移动到新的坐标，并缓冲(加载)英雄的图像，将其放入我们的画布中。</p><p id="a7d3" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">其他2个切片代表游戏应用程序的<a class="ae lj" href="https://github.com/KilroggD/rpg-react-redux/blob/master/src/tile-view/slices/statusSlice.js" rel="noopener ugc nofollow" target="_blank">状态</a>和为我们的平铺地图加载的<a class="ae lj" href="https://github.com/KilroggD/rpg-react-redux/blob/master/src/tile-view/slices/mapImagesSlice.js" rel="noopener ugc nofollow" target="_blank">地图图像</a></p><p id="3322" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">像通常的Redux应用程序一样，我们在<a class="ae lj" href="https://github.com/KilroggD/rpg-react-redux/blob/master/src/reducers/index.js" rel="noopener ugc nofollow" target="_blank">索引</a>文件中组合我们需要的所有Redux。</p><pre class="mq mr ms mt gt nb nc nd ne aw nf bi"><span id="5c5c" class="ng jo iq nc b gy nh ni l nj nk">import {combineReducers} from 'redux';<br/>import characterReducer from '../tile-view/slices/characterSlice';<br/>import mapImagesReducer from '../tile-view/slices/mapImagesSlice';<br/>import statusReducer from '../tile-view/slices/statusSlice';</span><span id="32d8" class="ng jo iq nc b gy no ni l nj nk">export default combineReducers({<br/>    mapImagesLoaded: mapImagesReducer,<br/>    gameStatus: statusReducer,<br/>    character: characterReducer,<br/>});</span></pre><p id="698f" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">然后我们可以传递那些组合的reducers，存储在我们的根索引文件中。</p><pre class="mq mr ms mt gt nb nc nd ne aw nf bi"><span id="2437" class="ng jo iq nc b gy nh ni l nj nk">import rootReducer from './reducers'</span><span id="f222" class="ng jo iq nc b gy no ni l nj nk">const store = configureStore({<br/>  reducer: rootReducer,<br/>});</span><span id="8849" class="ng jo iq nc b gy no ni l nj nk">ReactDOM.render(<br/>  &lt;React.StrictMode&gt;<br/>    &lt;Provider store={store}&gt;<br/>      &lt;App /&gt;<br/>    &lt;/Provider&gt;<br/>  &lt;/React.StrictMode&gt;,<br/>  document.getElementById('root')<br/>);</span></pre></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h1 id="ddae" class="jn jo iq bd jp jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk bi translated">反应和画布—上下文API</h1><p id="7105" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">通常在React应用程序中，我们使用由应用程序当前状态驱动的虚拟DOM来呈现UI。在这种情况下，我们使用HTML <a class="ae lj" href="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API" rel="noopener ugc nofollow" target="_blank"> Canvas API </a>来渲染我们的游戏区域。因此，我们需要找到一种方法来将我们的应用程序状态映射到Canvas API，以便让HTML5由React应用程序状态驱动。为此，React <a class="ae lj" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank">上下文API </a>是一个很好的工具。上下文提供了一种在组件之间共享值的方式，而不必通过树的每一层显式地传递属性。因此，我们可以在React上下文值中保留对HTML5 canvas元素的引用，并使其在所有组件中可用。首先，我们定义我们的<a class="ae lj" href="https://github.com/KilroggD/rpg-react-redux/blob/master/src/tile-view/canvasContext.js" rel="noopener ugc nofollow" target="_blank"> canvasContext </a>对象</p><pre class="mq mr ms mt gt nb nc nd ne aw nf bi"><span id="61c1" class="ng jo iq nc b gy nh ni l nj nk">import React from 'react';</span><span id="d0d4" class="ng jo iq nc b gy no ni l nj nk">const CanvasContext = React.createContext(null);</span><span id="b1b4" class="ng jo iq nc b gy no ni l nj nk">export default CanvasContext;</span></pre><p id="f523" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">我们将在组件中使用React挂钩来修改HTML5 canvas，使用React上下文中保存的引用来访问它。</p><p id="9a32" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">然后，我们来看看主要的<a class="ae lj" href="https://github.com/KilroggD/rpg-react-redux/blob/master/src/tile-view/GameLoop.js" rel="noopener ugc nofollow" target="_blank">游戏循环</a>组件。这是我们的应用程序的一个非常重要的组件，将在本文的相关章节中进行描述。为了在我们的应用程序中集成Canvas API，我们首先创建一个对canvas HTML元素的引用，并初始化一个指向Canvas context的指针(默认为null)</p><pre class="mq mr ms mt gt nb nc nd ne aw nf bi"><span id="435f" class="ng jo iq nc b gy nh ni l nj nk">const canvasRef = useRef(null);<br/>const [ctx, setCtx] = useState(null);</span></pre><p id="bbd4" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">React hook用于在组件状态下保存对canvas的引用。</p><pre class="mq mr ms mt gt nb nc nd ne aw nf bi"><span id="511f" class="ng jo iq nc b gy nh ni l nj nk">useEffect(() =&gt; {<br/>    setCtx(canvasRef.current.getContext('2d'));<br/>}, [setCtx]);</span></pre><p id="2ff9" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">然后，我们呈现canvas元素和所有包装在上下文提供者组件中的后续子元素，传递一个指向HTML5 Canvas的指针。</p><pre class="mq mr ms mt gt nb nc nd ne aw nf bi"><span id="2d41" class="ng jo iq nc b gy nh ni l nj nk">return (<br/>    &lt;CanvasContext.Provider value={ctx}&gt;<br/>        &lt;canvas<br/>            ref={canvasRef} <br/>            width={width} <br/>            height={height}<br/>        /&gt;<br/>        {children}<br/>    &lt;/CanvasContext.Provider&gt;<br/>);</span></pre><p id="ce52" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">您可以在我们的顶级<a class="ae lj" href="https://github.com/KilroggD/rpg-react-redux/blob/master/src/App.js" rel="noopener ugc nofollow" target="_blank"> App.js </a>组件中看到，我们在GameLoop组件中包装了我们的磁贴视图。</p></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h1 id="23b1" class="jn jo iq bd jp jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk bi translated">让我们画一个网格</h1><figure class="mq mr ms mt gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi np"><img src="../Images/e5890d08f47e2a4ef8c22d0b3f6f62f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XDm1NfTKMmLCjkEw"/></div></div></figure><p id="ce9d" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated"><a class="ae lj" href="https://github.com/KilroggD/rpg-react-redux/blob/master/src/tile-view/Grid.js" rel="noopener ugc nofollow" target="_blank">网格</a>组件简单地用黑色实线在提供的任何子节点上画一个网格。我们使用常量文件中的设置来获得行数和行间距的大小。</p><pre class="mq mr ms mt gt nb nc nd ne aw nf bi"><span id="2d8d" class="ng jo iq nc b gy nh ni l nj nk">import {useContext, useEffect} from 'react';</span><span id="cd45" class="ng jo iq nc b gy no ni l nj nk">import CanvasContext from './canvasContext';<br/>import {TILE_SIZE} from './constants';</span><span id="dcc2" class="ng jo iq nc b gy no ni l nj nk">const Grid = ({width, height, children}) =&gt; {<br/>    const ctx = useContext(CanvasContext);<br/>    useEffect(() =&gt; {<br/>        for(let i = 0; i &lt; height; i++) {    <br/>            const y = i * TILE_SIZE;         <br/>            ctx.beginPath();<br/>            ctx.moveTo(0, y);<br/>            ctx.lineTo(width, y);<br/>            ctx.stroke();<br/>        }<br/>        for(let j = 0; j &lt; width; j++) {<br/>            const x = j * TILE_SIZE;<br/>            ctx.beginPath();<br/>            ctx.moveTo(x, 0);<br/>            ctx.lineTo(x, height);<br/>            ctx.stroke();<br/>        } <br/>    }, [ctx, height, width]);</span><span id="a269" class="ng jo iq nc b gy no ni l nj nk">    return children;<br/>}</span><span id="f834" class="ng jo iq nc b gy no ni l nj nk">export default Grid;</span></pre><p id="c10d" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">所有的逻辑都是通过两个钩子实现的——<em class="nq">使用Context </em>来连接CanvasContext,<em class="nq">使用Effect </em>来绘制组件的安装或更新。然后我们简单地返回包裹在网格中的孩子。</p></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h1 id="1e45" class="jn jo iq bd jp jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk bi translated">让我们画一张地图——图像缓冲</h1><p id="3097" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">当我们渲染由平铺图像组成的实际地图时，有些图像可能无法按时加载。这可能会导致一些不愉快的用户体验，而一些图像在我们的地图渲染时没有加载。为了避免这种情况，我们需要确保在实际的地图渲染之前加载所有的图像。我们可以称这个过程为图像的缓冲。角色的图标也应该被缓冲以防万一。为了保存缓冲的图像，我们创建了应用程序状态的一个特殊的<a class="ae lj" href="https://github.com/KilroggD/rpg-react-redux/blob/master/src/tile-view/slices/mapImagesSlice.js" rel="noopener ugc nofollow" target="_blank">片段</a>。它创建一个哈希映射，并在其中存储缓冲的图像路径。</p><pre class="mq mr ms mt gt nb nc nd ne aw nf bi"><span id="521f" class="ng jo iq nc b gy nh ni l nj nk">import {createSlice} from '<a class="ae lj" href="http://twitter.com/reduxjs/toolkit" rel="noopener ugc nofollow" target="_blank">@reduxjs/toolkit</a>';</span><span id="54a6" class="ng jo iq nc b gy no ni l nj nk">const mapImagesSlice = createSlice({<br/>    name: 'images',<br/>    initialState: {},<br/>    reducers: {<br/>        bufferImage(state, action) {<br/>            const path = action.payload;<br/>            if (path) {<br/>                state[path] = 1;<br/>            }            <br/>        },<br/>    }<br/>});</span><span id="c2a5" class="ng jo iq nc b gy no ni l nj nk">export const { bufferImage } = mapImagesSlice.actions;</span><span id="89c4" class="ng jo iq nc b gy no ni l nj nk">export default mapImagesSlice.reducer;</span></pre><p id="9110" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">然后，我们创建一个不可见的<a class="ae lj" href="https://github.com/KilroggD/rpg-react-redux/blob/master/src/tile-view/ImagesBuffer.js" rel="noopener ugc nofollow" target="_blank"> ImagesBuffer </a>组件，在将所有图像注入HTML5画布之前，将它们加载到页面上。我们将切片中的bufferImage动作连接到这个组件。</p><pre class="mq mr ms mt gt nb nc nd ne aw nf bi"><span id="1dcd" class="ng jo iq nc b gy nh ni l nj nk">import React from 'react';<br/>import { connect } from 'react-redux';</span><span id="3a48" class="ng jo iq nc b gy no ni l nj nk">import {MAP_TILE_IMAGES} from './constants';<br/>import {bufferImage} from './slices/mapImagesSlice';</span><span id="8b77" class="ng jo iq nc b gy no ni l nj nk">const mapDispatch = { bufferImage };</span><span id="2873" class="ng jo iq nc b gy no ni l nj nk">const ImagesBuffer = ({ bufferImage }) =&gt; {<br/>    return (<br/>        &lt;div className="images-buffer"&gt;<br/>        {<br/>            Object.keys(MAP_TILE_IMAGES).map(key =&gt; {<br/>                return (<br/>                    &lt;img<br/>                        key={`map-tile-img-${key}`} <br/>                        id={`map-tile-img-${key}`} <br/>                        src={`${MAP_TILE_IMAGES[key]}`}<br/>                        alt={`map-tile-${key}`}<br/>                        onLoad={() =&gt; {      <br/>                            bufferImage(MAP_TILE_IMAGES[key]);<br/>                        }}<br/>                    /&gt;<br/>                );<br/>            })<br/>        }<br/>        &lt;/div&gt;<br/>    )<br/>}</span><span id="8d1e" class="ng jo iq nc b gy no ni l nj nk">export default connect(null, mapDispatch)(ImagesBuffer);</span></pre><p id="e735" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">在我们的<a class="ae lj" href="https://github.com/KilroggD/rpg-react-redux/blob/master/src/App.css" rel="noopener ugc nofollow" target="_blank">样式表</a>中，我们隐藏了图片缓冲区。</p></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h1 id="1ea9" class="jn jo iq bd jp jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk bi translated">完成地图-切片和图层</h1><p id="9cec" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们的tile view应用程序的主要UI元素是地图本身。我们假设地图由两个<a class="ae lj" href="https://github.com/KilroggD/rpg-react-redux/blob/86c811b052ce92ef77e5a33df379e68eaa79eaf1/src/tile-view/constants.js#L17" rel="noopener ugc nofollow" target="_blank">层</a>组成——一个用于地图表面，一个用于其上的各种对象和表面(第二个列表中的非零元素)。标签列表中的每个数字代表<a class="ae lj" href="https://github.com/KilroggD/rpg-react-redux/blob/86c811b052ce92ef77e5a33df379e68eaa79eaf1/src/tile-view/constants.js#L9" rel="noopener ugc nofollow" target="_blank">图像散列图</a>中的一个图块图像。零元素是空瓷砖(没有物体或障碍物)。实心瓷砖是我们的角色无法通过的障碍物。</p><p id="20bd" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated"><a class="ae lj" href="https://github.com/KilroggD/rpg-react-redux/blob/master/src/tile-view/Map.js" rel="noopener ugc nofollow" target="_blank"> Map </a>是一个空渲染器，它使用来自我们的上下文和配置常量的指针在HTML 5画布上绘制地图块。</p><pre class="mq mr ms mt gt nb nc nd ne aw nf bi"><span id="79a7" class="ng jo iq nc b gy nh ni l nj nk">import {useContext, useEffect} from 'react';<br/>import { connect } from 'react-redux';</span><span id="7b7e" class="ng jo iq nc b gy no ni l nj nk">import {LAYERS, MAP_DIMENSIONS, TILE_SIZE} from './constants';<br/>import CanvasContext from './canvasContext';<br/>import {loadMap} from './slices/statusSlice';</span><span id="824a" class="ng jo iq nc b gy no ni l nj nk">const mapDispatch = { loadMap };</span><span id="3e50" class="ng jo iq nc b gy no ni l nj nk">const Map = ({ loadMap }) =&gt; {<br/>    const ctx = useContext(CanvasContext);<br/>    const {COLS, ROWS} = MAP_DIMENSIONS;</span><span id="08d2" class="ng jo iq nc b gy no ni l nj nk">    useEffect(() =&gt; {<br/>        const drawLayer = grid =&gt; {<br/>            for (let i = 0; i &lt; ROWS; i++) {<br/>                for (let j = 0; j &lt; COLS; j++) {<br/>                    const item = grid[i][j];<br/>                    if (!item) {<br/>                        // empty tile<br/>                        continue;<br/>                    }                <br/>                    const img = document.querySelector(<br/>                        `#map-tile-img-${item}`<br/>                    );<br/>                    const x = j * TILE_SIZE;<br/>                    const y = i * TILE_SIZE;<br/>                    ctx.drawImage(<br/>                        img,<br/>                        0,<br/>                        0,<br/>                        TILE_SIZE,<br/>                        TILE_SIZE,<br/>                        x,<br/>                        y,<br/>                        TILE_SIZE,<br/>                        TILE_SIZE,<br/>                    );<br/>                }<br/>            }<br/>        };</span><span id="ca7b" class="ng jo iq nc b gy no ni l nj nk">        drawLayer(LAYERS[0]);<br/>        drawLayer(LAYERS[1]);<br/>        loadMap(true);<br/>    }, [COLS, ROWS, ctx, loadMap]);</span><span id="ef34" class="ng jo iq nc b gy no ni l nj nk">    return null;<br/>};</span><span id="4213" class="ng jo iq nc b gy no ni l nj nk">export default connect(null, mapDispatch)(Map);</span></pre><p id="9377" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">请注意，这个组件不直接在DOM中呈现任何东西。它只是一个围绕canvas的包装器，在组件的每次安装/更新时绘制地图(用<code class="fe nr ns nt nc b">useEffect</code> React钩子实现)。绘制完成后，我们将加载标志设置为true。</p><figure class="mq mr ms mt gt mu gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/2fbb955cf0a64701dd96642bfbb39463.png" data-original-src="https://miro.medium.com/v2/resize:fit:1366/format:webp/1*RWZ2_9TC0oFosFMKtTI_XA.png"/></div></figure></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h1 id="13d6" class="jn jo iq bd jp jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk bi translated">我需要一个英雄！</h1><p id="9619" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">地图在这里所以我们需要一个英雄:)在地图周围移动。在特殊的<a class="ae lj" href="https://github.com/KilroggD/rpg-react-redux/blob/master/src/constants.js" rel="noopener ugc nofollow" target="_blank">常量</a>中，您可以找到与我们的英雄对象相关的配置参数(图像精灵、图像大小、关于英雄的信息)。上面已经描述了在地图上代表英雄状态的状态<a class="ae lj" href="https://github.com/KilroggD/rpg-react-redux/blob/master/src/tile-view/slices/characterSlice.js" rel="noopener ugc nofollow" target="_blank">片</a>。<a class="ae lj" href="https://github.com/KilroggD/rpg-react-redux/blob/master/src/tile-view/Character.js" rel="noopener ugc nofollow" target="_blank">人物</a> React组件与上一个非常相似。它加载并缓冲英雄的图像，将其保存在应用程序状态中，当图像被加载时，它在画布上绘制英雄的图标(useEffect再次提供帮助！).</p><pre class="mq mr ms mt gt nb nc nd ne aw nf bi"><span id="fcf8" class="ng jo iq nc b gy nh ni l nj nk">useEffect(() =&gt; {<br/>        if (heroImg) {<br/>            const {sx, sy} = HERO_CLASSES_MAP[heroClass].icon;<br/>            ctx.drawImage(<br/>                document.querySelector(heroImg),<br/>                sx,<br/>                sy,<br/>                HERO_IMAGE_SIZE - 5,<br/>                HERO_IMAGE_SIZE - 5,<br/>                x * TILE_SIZE,<br/>                y * TILE_SIZE,<br/>                HERO_IMAGE_SIZE,<br/>                HERO_IMAGE_SIZE,<br/>            );<br/>            loadCharacter(true);<br/>        };  <br/>}, [ctx, heroClass, heroImg, x, y, loadCharacter]);</span></pre><p id="27a4" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">我们使用英雄的X和Y坐标乘以TILE_SIZE来正确定位英雄图标在图块地图上的位置。</p><p id="6666" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">它呈现的唯一HTML是用于缓冲的隐形英雄的图像。</p><pre class="mq mr ms mt gt nb nc nd ne aw nf bi"><span id="d13b" class="ng jo iq nc b gy nh ni l nj nk">return (<br/>    &lt;img<br/>        id="character" <br/>        alt="character"<br/>        ref={imgRef} <br/>        onLoad={<br/>            () =&gt; bufferImage(`#${imgRef.current.id}`)<br/>        }<br/>        className="images-buffer"<br/>        src={HEROES_SPRITE}<br/>    /&gt;<br/>);</span></pre><figure class="mq mr ms mt gt mu gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/500581c093252fc25b066132380346cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1366/format:webp/1*LYKnLUxFnk9l1yPZJ2ep1Q.png"/></div></figure><p id="8d81" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">耶！我们的角色图标在这里，并准备好了一些行动:)</p></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h1 id="f557" class="jn jo iq bd jp jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk bi translated">重要！安装和绘制顺序</h1><p id="1bbd" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">也许你很好奇为什么我们要按照一定的顺序嵌套组件。TileView将网格作为子组件，网格包含地图。此外，我们确保角色仅在地图加载后才被渲染。如果您看到React JS如何处理嵌套组件挂载，原因就很简单了。</p><p id="68da" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">让我们将<code class="fe nr ns nt nc b">console.log('mapEffect')</code>放入地图组件<code class="fe nr ns nt nc b">useEffect</code>钩子中，将<code class="fe nr ns nt nc b">console.log('gridEffect')</code>放入网格的钩子中。</p><p id="4942" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">你会看到“地图效果”首先记录在控制台中。这是因为React JS方法在父组件的生命周期方法之前触发子组件的生命周期方法。但为什么这对我们的案子如此重要？</p><p id="943c" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">让我们交换地图组件中的2条线，在绘制第2层之前绘制第1层</p><pre class="mq mr ms mt gt nb nc nd ne aw nf bi"><span id="c3d2" class="ng jo iq nc b gy nh ni l nj nk">drawLayer(LAYERS[1]);<br/>drawLayer(LAYERS[0]);</span></pre><p id="e73c" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">你会看到这张不太好的照片。一层在另一层上面。</p><figure class="mq mr ms mt gt mu gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/e4174582dc1c6685f6ffaf7b1662656b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1356/format:webp/1*robFnw5-yOgSJ8KtJbU0tA.png"/></div></figure><p id="bc2b" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">因此，如果我们需要在HTML5画布上绘制多个图层，绘制的顺序很重要。所以我们需要先画出我们的地图，然后在上面画一个网格。并且我们只需要在地图加载后绘制一个角色。这就是为什么我们将地图组件作为<a class="ae lj" href="https://github.com/KilroggD/rpg-react-redux/blob/86c811b052ce92ef77e5a33df379e68eaa79eaf1/src/tile-view/TileView.js#L20" rel="noopener ugc nofollow" target="_blank">子组件传递给网格</a>——我们需要比网格更早调用绘制地图的useEffect钩子——这样网格就呈现在地图上方，而不是下方。</p><p id="25a1" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">对于角色，我们使用<a class="ae lj" href="https://github.com/KilroggD/rpg-react-redux/blob/86c811b052ce92ef77e5a33df379e68eaa79eaf1/src/tile-view/TileView.js#L24" rel="noopener ugc nofollow" target="_blank"> mapLoaded </a>状态标志来确保角色的图标不会落在地图瓦片之下。</p></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h1 id="2a90" class="jn jo iq bd jp jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk bi translated">让它移动—请求动画帧</h1><p id="d5cf" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">当谈到在HTML画布上移动东西时，最大的挑战是优化画布刷新，这样我们就不会在地图上看到移动对象的任何故障、闪烁或重复。Javascript有一个很好的原生函数来处理这个问题，叫做<a class="ae lj" href="https://developer.mozilla.org/ru/docs/DOM/window.requestAnimationFrame" rel="noopener ugc nofollow" target="_blank"> requestAnimationFrame </a>。它允许我们以接近60 fps的速度重新绘制画布。</p><p id="283d" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">本节主要关注负责主要游戏事件和60fps重绘循环的<a class="ae lj" href="https://github.com/KilroggD/rpg-react-redux/blob/master/src/tile-view/GameLoop.js" rel="noopener ugc nofollow" target="_blank">游戏循环</a>组件。</p><h2 id="1073" class="ng jo iq bd jp nw nx dn jt ny nz dp jx kw oa ob kb la oc od kf le oe of kj og bi translated">定义标志</h2><p id="6c77" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">有几个标志和变量对重新渲染我们的画布很有用</p><pre class="mq mr ms mt gt nb nc nd ne aw nf bi"><span id="c18e" class="ng jo iq nc b gy nh ni l nj nk">// used for re-rendering child components<br/>const [isVisible, setIsVisible] = useState(true);</span><span id="4cc3" class="ng jo iq nc b gy no ni l nj nk">// used to avoid unnecessary updates and re-draws<br/>const [isUpdateRequired, setIsUpdateRequired] = useState(false);</span><span id="eeac" class="ng jo iq nc b gy no ni l nj nk">// keeps the reference to the main rendering loop<br/>const loopRef = useRef();</span></pre><h2 id="69ef" class="ng jo iq bd jp nw nx dn jt ny nz dp jx kw oa ob kb la oc od kf le oe of kj og bi translated">检查地图边缘和障碍物</h2><p id="ef6f" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">移动我们的角色比仅仅改变地图上的X和Y坐标要复杂一些。我们还需要确保我们的英雄不能穿过墙壁和树木，从地图的边缘掉下来。一小部分<a class="ae lj" href="https://github.com/KilroggD/rpg-react-redux/blob/master/src/tile-view/utils.js" rel="noopener ugc nofollow" target="_blank">实用函数</a>用于它。</p><pre class="mq mr ms mt gt nb nc nd ne aw nf bi"><span id="0c9d" class="ng jo iq nc b gy nh ni l nj nk">import {LAYERS, MAP_DIMENSIONS, SOLID_TILES} from './constants';</span><span id="56c5" class="ng jo iq nc b gy no ni l nj nk">export const isSolidTile = (x, y) =&gt; {<br/>    for (let layer of LAYERS) {<br/>        if (SOLID_TILES.includes(layer[y][x])) {<br/>            return true;<br/>        }<br/>    }<br/>    return false;<br/>};</span><span id="089e" class="ng jo iq nc b gy no ni l nj nk">export const isMapEdge = (x, y) =&gt; {<br/>    const {ROWS, COLS} = MAP_DIMENSIONS;<br/>    return (x &lt; 0 || x &gt;= COLS || y &lt; 0 || y &gt;= ROWS)        <br/>};</span><span id="0ee6" class="ng jo iq nc b gy no ni l nj nk">export const checkMapCollision = (x, y) =&gt; {<br/>    return isMapEdge(x,y) || isSolidTile(x,y);<br/>};</span></pre><p id="c4ce" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">主<code class="fe nr ns nt nc b">checkMapCollision</code>函数检查主角是否真的可以移动到给定X和Y坐标的方块上</p><h2 id="1fcd" class="ng jo iq bd jp nw nx dn jt ny nz dp jx kw oa ob kb la oc od kf le oe of kj og bi translated">移动角色的图标</h2><p id="d8f2" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">移动角色函数只是检查目标图块是否可以继续移动，并使用我们的角色在地图{x，y}上的新坐标更新我们的应用程序状态的角色片段:</p><pre class="mq mr ms mt gt nb nc nd ne aw nf bi"><span id="733a" class="ng jo iq nc b gy nh ni l nj nk">const moveCharacter = useCallback((e) =&gt; {<br/>    const key = e.key;<br/>    if (MOVE_DIRECTIONS[key]) {<br/>        const [x,y] = MOVE_DIRECTIONS[key];<br/>        if (!checkMapCollision(character.x + x, character.y + y)) { <br/>           setIsUpdateRequired(true);<br/>           move([x, y]);<br/>        }<br/>    }<br/>}, [move, character.x, character.y]);</span></pre><p id="f856" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated"><a class="ae lj" href="https://github.com/KilroggD/rpg-react-redux/blob/86c811b052ce92ef77e5a33df379e68eaa79eaf1/src/tile-view/constants.js#L48" rel="noopener ugc nofollow" target="_blank">移动方向</a>映射到所有玩家熟悉的W/A/S/D键:)</p><pre class="mq mr ms mt gt nb nc nd ne aw nf bi"><span id="bbba" class="ng jo iq nc b gy nh ni l nj nk">export const MOVE_DIRECTIONS = {<br/>    w: [0, -1],<br/>    a: [-1, 0],<br/>    s: [0, 1],<br/>    d: [1, 0],<br/>};</span></pre><p id="8959" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">在角色被移动后，我们将<code class="fe nr ns nt nc b">isUpdateRequired</code>标志设置为true，以表明某些东西已经被改变，需要更新UI。</p><pre class="mq mr ms mt gt nb nc nd ne aw nf bi"><span id="02be" class="ng jo iq nc b gy nh ni l nj nk">useEffect(() =&gt; {<br/>    document.addEventListener('keypress', moveCharacter);<br/>    return () =&gt; {<br/>        document.removeEventListener('keypress', moveCharacter);<br/>    }<br/>}, [moveCharacter]);</span></pre><p id="65e6" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">我们将<code class="fe nr ns nt nc b">moveCharacter</code>回调绑定到<code class="fe nr ns nt nc b">keypress</code> DOM事件。</p><h2 id="00c3" class="ng jo iq bd jp nw nx dn jt ny nz dp jx kw oa ob kb la oc od kf le oe of kj og bi translated">清除并重新绘制画布</h2><p id="4ca0" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">构建重绘循环的一个重要要求是，当需要重绘来呈现下一个状态时，清除画布。在本教程中，我们已经成功地利用这个机会将与画布相关的操作放入React组件的生命周期挂钩中，以便在我们的地图上绘制一些东西。为什么不用同样的方法来清理画布呢？看看其中一个顶级子组件— <a class="ae lj" href="https://github.com/KilroggD/rpg-react-redux/blob/master/src/tile-view/TileView.js" rel="noopener ugc nofollow" target="_blank"> TileView </a>组件。</p><pre class="mq mr ms mt gt nb nc nd ne aw nf bi"><span id="8559" class="ng jo iq nc b gy nh ni l nj nk">useEffect(() =&gt; {<br/>   return () =&gt; {<br/>       return () =&gt; ctx &amp;&amp; ctx.clearRect(<br/>           0, 0, ctx.width, ctx.height<br/>       );<br/>   }<br/>}, [ctx])</span></pre><p id="9555" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">这里我们使用一个空的useEffect钩子，它有cleanup部分。这部分是最重要的，因为当我们卸载TileView组件时，它会清空画布。就像我们在GameLoop组件中做的那样:</p><pre class="mq mr ms mt gt nb nc nd ne aw nf bi"><span id="01eb" class="ng jo iq nc b gy nh ni l nj nk">return (<br/>    &lt;CanvasContext.Provider value={ctx}&gt;<br/>        &lt;canvas<br/>            ref={canvasRef} <br/>            width={width} <br/>            height={height}<br/>        /&gt;<br/>        {isVisible &amp;&amp; children}<br/>    &lt;/CanvasContext.Provider&gt;<br/>);</span></pre><p id="00bd" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">在我们的<a class="ae lj" href="https://github.com/KilroggD/rpg-react-redux/blob/master/src/App.js" rel="noopener ugc nofollow" target="_blank">应用</a>中，TileView作为子组件被传递到那里。因此，当<code class="fe nr ns nt nc b">isVisible</code>标志为假时，TileView组件被卸载，并且useEffect cleanup <a class="ae lj" href="https://github.com/KilroggD/rpg-react-redux/blob/23983851d0e15ff7101ba701d47c8ac55479d7bd/src/tile-view/TileView.js#L18" rel="noopener ugc nofollow" target="_blank">清除</a>画布和游戏区域。</p><p id="fe54" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">现在，让我们回到我们的主<a class="ae lj" href="https://github.com/KilroggD/rpg-react-redux/blob/master/src/tile-view/GameLoop.js" rel="noopener ugc nofollow" target="_blank">游戏循环</a>，仔细看看以下两个函数:</p><pre class="mq mr ms mt gt nb nc nd ne aw nf bi"><span id="088b" class="ng jo iq nc b gy nh ni l nj nk">const tick = useCallback(() =&gt; {<br/>    if (isUpdateRequired) {<br/>        setIsVisible(false);<br/>        setIsVisible(true);    <br/>        setIsUpdateRequired(false);<br/>    }     <br/>    loopRef.current = requestAnimationFrame(tick);<br/>}, [isUpdateRequired, setIsVisible, setIsUpdateRequired]);</span></pre><p id="7101" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">第一个是我们游戏循环中的单个“滴答”。它检查是否需要更新，然后通过切换可见性标志来触发子组件的重新呈现。则它将需要更新标志重置为假，并请求下一次更新。</p><pre class="mq mr ms mt gt nb nc nd ne aw nf bi"><span id="ff34" class="ng jo iq nc b gy nh ni l nj nk">useEffect(() =&gt; {   <br/>    loopRef.current = requestAnimationFrame(tick);<br/>    return () =&gt; {<br/>        loopRef.current &amp;&amp; cancelAnimationFrame(loopRef.current);<br/>    }<br/>}, [loopRef, tick])</span></pre><p id="be11" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">第二个函数是一个useEffect钩子。它保存对刷新循环的引用，并开始刷新过程。当组件卸载时，我们还添加了一个清理函数来cancelAnimationFrame。</p><h2 id="d01e" class="ng jo iq bd jp nw nx dn jt ny nz dp jx kw oa ob kb la oc od kf le oe of kj og bi translated">检查它移动！</h2><p id="b77e" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">看到字符图标在地图上移动，而不能通过墙壁，树木和地图的边缘:)</p><figure class="mq mr ms mt gt mu gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/ce69d9b011bd245e6efa0b2f42de0056.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*6tTG_4I0N56RAiHt.gif"/></div></figure></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h1 id="097a" class="jn jo iq bd jp jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk bi translated"><strong class="ak">增加一些游戏UI </strong></h1><p id="2e46" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">为了让我们的应用程序看起来更像一个游戏，还缺少一个小东西。我们需要一个简单的用户界面面板来显示角色的名字，头像和基本信息。</p><p id="db62" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">我们不必为这个面板使用canvas，因此它可以简单地由连接到角色状态部分的<a class="ae lj" href="https://github.com/KilroggD/rpg-react-redux/blob/master/src/game-ui/GameUI.js" rel="noopener ugc nofollow" target="_blank"> GameUI </a> React组件来呈现。在这个阶段，我们只从我们的状态中获取hero的类属性，并为其他参数使用常量。最终的照片是这样的:</p><figure class="mq mr ms mt gt mu gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi mp"><img src="../Images/83c9bf6473879336e1a808402daa16c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ajmzkG_ub2fufg0WN4GwbQ.png"/></div></div></figure></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h1 id="2751" class="jn jo iq bd jp jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk bi translated">后续步骤</h1><p id="7505" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我真的很喜欢写这个应用程序和这篇文章，我希望你有一个很好的乐趣阅读和启动应用程序。除了获得一些乐趣之外，它还帮助我了解了相对较新且相当强大的Redux-toolkit库的一些主要特性。此外，练习更多的React挂钩用法并以不寻常的方式使用它们来处理外部对象状态(HTML5 canvas)也很棒。由于我们的工具包(redux + hooks + context)给了我们高度的灵活性，这种方法到目前为止都是有效的。</p><p id="ae24" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">但是正如你可能注意到的，这个应用程序并不完美，缺少一些重要的功能。本教程的下一部分有一些想法:</p><ul class=""><li id="7aea" class="mb mc iq kn b ko lk ks ll kw md la me le mf li mg mh mi mj bi translated">制作一个可滚动的地图，这样我们的英雄就可以离开边缘，进入地图的下一个屏幕</li><li id="437b" class="mb mc iq kn b ko mk ks ml kw mm la mn le mo li mg mh mi mj bi translated">添加一些对象，如NPC，怪物或项目</li><li id="e214" class="mb mc iq kn b ko mk ks ml kw mm la mn le mo li mg mh mi mj bi translated">添加我们的英雄和那些物体之间的互动</li><li id="005a" class="mb mc iq kn b ko mk ks ml kw mm la mn le mo li mg mh mi mj bi translated">构建其他视图屏幕，如角色/库存视图、战斗视图等。</li><li id="7d6c" class="mb mc iq kn b ko mk ks ml kw mm la mn le mo li mg mh mi mj bi translated">创建一个可定制的设置，可以选择角色的名字，职业，图片等。</li></ul></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h1 id="2483" class="jn jo iq bd jp jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk bi translated">谢谢你的主意</h1><p id="5352" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">有一些有用的文档和文章启发了我，并帮助我创建了这个教程:</p><ul class=""><li id="f8fe" class="mb mc iq kn b ko lk ks ll kw md la me le mf li mg mh mi mj bi translated"><a class="ae lj" href="https://developer.mozilla.org/en-US/docs/Games/Techniques/Tilemaps" rel="noopener ugc nofollow" target="_blank"> MDN教程</a>普通JS平铺地图</li><li id="a216" class="mb mc iq kn b ko mk ks ml kw mm la mn le mo li mg mh mi mj bi translated"><a class="ae lj" href="https://dev.to/martyhimmel/moving-a-sprite-sheet-character-with-javascript-3adg" rel="noopener ugc nofollow" target="_blank">教程</a>关于在Javascript中移动sprite工作表字符</li><li id="6ac8" class="mb mc iq kn b ko mk ks ml kw mm la mn le mo li mg mh mi mj bi translated"><a class="ae lj" href="https://opengameart.org/" rel="noopener ugc nofollow" target="_blank">https://opengameart.org</a>—一些免费的像素艺术和许多灵感:)</li></ul></div></div>    
</body>
</html>