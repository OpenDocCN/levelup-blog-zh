<html>
<head>
<title>How We Have Automated Release Notes Generation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我们如何自动生成发行说明</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-we-have-automated-release-notes-generation-9365de451327?source=collection_archive---------3-----------------------#2021-09-12">https://levelup.gitconnected.com/how-we-have-automated-release-notes-generation-9365de451327?source=collection_archive---------3-----------------------#2021-09-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="26b4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这篇文章原本是用俄语写的。你可以通过 <a class="ae km" href="https://habr.com/ru/company/ru_mts/blog/572774/" rel="noopener ugc nofollow" target="_blank"> <em class="kl">这个链接</em> </a> <em class="kl">来查看出处。</em></p><p id="02ab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你好。我叫谢苗。我是大数据部门<a class="ae km" href="http://ir.mts.ru/about-mts/mts-at-a-glance/default.aspx" rel="noopener ugc nofollow" target="_blank"> MTS数字公司</a>的Java开发人员和Java团队负责人。在这篇文章中，我想谈谈发行说明。什么是发行说明？为什么不应该手动编写它们？如何自动化发行说明的生成？今天我来回答这些问题。此外，我将展示我们项目中发行说明自动化的真实例子。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div class="gh gi kn"><img src="../Images/861413ff117b6d534e9414f1fa28fe56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5H5RGvwvqi7Y_G4gNvUmUg.png"/></div></figure><h1 id="97cf" class="kv kw iq bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">这是什么？</h1><p id="fe70" class="pw-post-body-paragraph jn jo iq jp b jq lt js jt ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ij bi translated">发行说明描述了最新产品的增量。新的错误修复、功能等。它不仅对软件工程师有价值，对管理者也有价值。因为他们也想知道开发进度。如果你曾经在每周演示中展示过当前的产品状态，那么你就会知道记住最近完成的所有任务是很难的。</p><p id="b0a9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么，如何制作发行说明呢？最明显的方法是手动操作。</p><h1 id="26f9" class="kv kw iq bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">手操纵进场着陆</h1><p id="1c85" class="pw-post-body-paragraph jn jo iq jp b jq lt js jt ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ij bi translated">这种方式提供了显著的优势。它既不需要额外的技术知识，也不需要实施任何CI/CD流程更改。我们只需要雇用一个科技作家，并为他们委派工作。利润！但是有一些警告。</p><ol class=""><li id="a552" class="ly lz iq jp b jq jr ju jv jy ma kc mb kg mc kk md me mf mg bi translated">科技作家并不是完全了解产品的人。因此，他们无法自己实现新产品更新。必须有一个开发人员能够提供这些信息。这意味着这项工作做了两次。首先，开发人员向技术作者解释最新的产品更新。然后技术作家向其他人解释。</li><li id="018c" class="ly lz iq jp b jq mh ju mi jy mj kc mk kg ml kk md me mf mg bi translated"><strong class="jp ir">过程繁琐。</strong>有很多情况会影响手动发布说明的编写速度。你如何描述管理系统中的任务？引入变化贡献的过程是什么？你有技术文件吗？什么是产品架构？是自圆其说还是含糊其辞？</li><li id="1494" class="ly lz iq jp b jq mh ju mi jy mj kc mk kg ml kk md me mf mg bi translated"><strong class="jp ir">出错的概率很大。你可能会忘记一个重要的错误修复。相反，你可以提到一些还没有发布的东西。</strong></li></ol><p id="2d14" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如你所见，手工编写发布说明是不合理的。所以，我们需要自动化这个过程，对吗？确实是。但是也有一些问题需要解决。</p><ol class=""><li id="9057" class="ly lz iq jp b jq jr ju jv jy ma kc mb kg mc kk md me mf mg bi translated">如何跟踪变化？</li><li id="85da" class="ly lz iq jp b jq mh ju mi jy mj kc mk kg ml kk md me mf mg bi translated">如果我们设置一些有助于指出变化的规则，我们如何保证没有人违反它们？</li><li id="60ac" class="ly lz iq jp b jq mh ju mi jy mj kc mk kg ml kk md me mf mg bi translated">如果我们支持产品的多个版本会怎样？如何统一自动化流程？</li></ol><h1 id="97d4" class="kv kw iq bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">什么是“改变”？</h1><p id="103c" class="pw-post-body-paragraph jn jo iq jp b jq lt js jt ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ij bi translated">您可以用几种方法来度量项目更新。有<em class="kl">小步</em>和<em class="kl">大步</em>的方法。小的由存储库中的提交来描述。而大的是由管理系统中的任务决定的。可以是吉拉、特雷罗、GitHub/GitLab门票等。</p><p id="e80c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我会把这些策略称为面向技术的<em class="kl">和面向商业的<em class="kl"/>。对了，一个不排斥另一个。您可以同时应用它们。每一个都有优点和缺点。</em></p><h2 id="3197" class="mm kw iq bd kx mn mo dn lb mp mq dp lf jy mr ms lj kc mt mu ln kg mv mw lr mx bi translated">面向技术的发行说明</h2><p id="a42f" class="pw-post-body-paragraph jn jo iq jp b jq lt js jt ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ij bi translated">让我们从一个更简单的选项开始。假设我们使用经典的<a class="ae km" href="https://medium.com/@muneebsajjad/git-flow-explained-quick-and-simple-7a753313572f" rel="noopener"> Git流分支模型</a>。每夜构建从<em class="kl">开发</em>分支每天部署。而每次合并到主<em class="kl">分支</em>都会创建一个新的版本。我们需要发布说明。</p><p id="90f4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">很容易找到新版本中的所有提交。</p><pre class="ko kp kq kr gt my mz na nb aw nc bi"><span id="f29c" class="mm kw iq mz b gy nd ne l nf ng"><strong class="mz ir">git</strong> rev-list $PREV_HASH..HEAD</span></pre><p id="e58e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe nh ni nj mz b">$PREV_HASH</code>是前一版本的最后一次提交。当我们获得提交散列时，我们还可以检索相应的提交消息。然后只需将收集到的信息放入电子邮件并发送给订阅者。此外，许多CI系统可以自动生成类似的变更日志。</p><p id="5f1a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这听起来很诱人。但是也有陷阱。</p><ol class=""><li id="3cba" class="ly lz iq jp b jq jr ju jv jy ma kc mb kg mc kk md me mf mg bi translated">开发人员通常不注意编写有意义的提交消息。所以，你可能最终会得到一个<em class="kl">修复</em>、<em class="kl">添加</em>、<em class="kl">删除</em>、<em class="kl">删除</em>等等的卷轴。</li><li id="a137" class="ly lz iq jp b jq mh ju mi jy mj kc mk kg ml kk md me mf mg bi translated">如果您确实以这种方式自动化了发行说明，它也可能包含Git服务器日志消息(合并分支x到y，合并拉请求z到t)</li><li id="8201" class="ly lz iq jp b jq mh ju mi jy mj kc mk kg ml kk md me mf mg bi translated">有很多团队被<a class="ae km" href="https://www.git-tower.com/learn/git/faq/git-squash/" rel="noopener ugc nofollow" target="_blank">挤压</a>提交的每个拉请求合并。这种方法不适用于所描述的发行说明生成策略。因为您将丢失大部分发布信息。</li></ol><p id="bcef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，这并不是潜在问题的完整列表。事实是，提交本身对业务没有价值。即使你所有的提交都有一个详细和清晰的信息，在大多数情况下，产品所有者也不需要。因为很难将未分组的提交列表分割成具体的工作单元。</p><p id="aab2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<a class="ae km" href="https://keepachangelog.com/en/1.0.0/" rel="noopener ugc nofollow" target="_blank"> CHANGELOG.md </a>中有一个存储“业务日志”的选项。但是将文件保持在相关状态也是手工操作。没有自动化。反正有个好处。CHANGELOG.md作为其余代码存储在存储库中。因此，在合并之前，可以在代码审查阶段对其进行检查。</p><h2 id="40f4" class="mm kw iq bd kx mn mo dn lb mp mq dp lf jy mr ms lj kc mt mu ln kg mv mw lr mx bi translated">面向业务的发行说明</h2><blockquote class="nk nl nm"><p id="2eac" class="jn jo kl jp b jq jr js jt ju jv jw jx nn jz ka kb no kd ke kf np kh ki kj kk ij bi translated">如果你把任务的总结和描述放到发布说明中，那就更好了。</p><p id="92a9" class="jn jo kl jp b jq jr js jt ju jv jw jx nn jz ka kb no kd ke kf np kh ki kj kk ij bi translated">产品所有者。</p></blockquote><p id="8a13" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好吧，我们试试。</p><p id="d782" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在创建一个新版本时，我们能得到的唯一信息是提交列表。这意味着我们需要将管理系统中的提交和任务相互连接起来。解决方案相当简单。每个提交消息都应该包含任务ID。然后很容易解析它们，并通过REST API检索所需的任务信息。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="nr ns di nt bf nu"><div class="gh gi nq"><img src="../Images/9dae1ce87222fc25279e05c6de6032dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ngRxr2WEUKpUrGl2.png"/></div></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk translated">图一。发行说明自动化流程的基础架构</figcaption></figure><p id="b393" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种方法有助于我们将代码变更和特定的业务需求结合起来。此外，提交的元信息(散列、消息)可以作为附加的技术参考放入电子邮件中。</p><p id="7144" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这听起来很乐观。但是有一个问题。我们怎么知道开发人员会按照我们声明的方式编写提交消息呢？这个问题问得好。我们可以写一份长长的<a class="ae km" href="https://mozillascience.github.io/working-open-workshop/contributing/" rel="noopener ugc nofollow" target="_blank"> CONTRIBUTING.md </a>规则清单，希望每个人都能遵守。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="nr ns di nt bf nu"><div class="gh gi nz"><img src="../Images/4fdd004d8e1c6cc003606d3d0c8116b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IUhrInAwwXqeTIU5hD4CyA.png"/></div></div></figure><p id="7c89" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们能够自动检查<strong class="jp ir">是否阻止</strong>程序员贡献不适当的东西，那就太好了。谢天谢地，这个工具是存在的。</p><blockquote class="nk nl nm"><p id="b220" class="jn jo kl jp b jq jr js jt ju jv jw jx nn jz ka kb no kd ke kf np kh ki kj kk ij bi translated">还有另一个警告。如何才能知道管理体系中对任务的描述是否准确、牢固？其实这是个问题。有时开发人员在信使中或在会议中讨论一项任务。然后一个只是把一个简短的总结没有任何背景。遗憾的是，没有解决这种情况的灵丹妙药。唯一的办法就是融合文化。作为一名经理，你必须强调正确申报任务的重要性。例如，如果你在周五晚上提交了一份模糊的描述，你很可能记不起周一早上你需要做什么。</p></blockquote><h1 id="82c6" class="kv kw iq bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">Git挂钩</h1><p id="7b4a" class="pw-post-body-paragraph jn jo iq jp b jq lt js jt ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ij bi translated">当有人提到“Git hooks”时，会有很多人想到webhooks。它可以是拉请求触发器、注释通知、批准观察者等等。但是Git也支持本地钩子来监听机器上存储库中的事件。例如，您可以检查提交执行尝试。这就是<a class="ae km" href="https://git-scm.com/docs/githooks" rel="noopener ugc nofollow" target="_blank"> commit-msg </a>钩子的作用。听起来很有趣。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="nr ns di nt bf nu"><div class="gh gi oa"><img src="../Images/a2683f84f4ef0a310df9211f55ecebf4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*MzINLz9bN0llvhIY.png"/></div></div></figure><p id="4729" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">默认情况下，所有的钩子都应该放在<code class="fe nh ni nj mz b">.git/hooks</code>目录中。您需要创建一个具有所需名称的文件(在我们的例子中是<code class="fe nh ni nj mz b">commit-msg</code>)来使钩子开始工作。例如，下面是一个简单的Python钩子，它检查提交消息中是否存在任务ID。</p><figure class="ko kp kq kr gt ks"><div class="bz fp l di"><div class="ob oc l"/></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk translated">Python提交消息挂钩</figcaption></figure><p id="18b6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第一个命令行参数指向<code class="fe nh ni nj mz b">.git/COMMIT_EDITMSG</code>文件。它包含消息本身。通过读取文件，我们可以根据<a class="ae km" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions" rel="noopener ugc nofollow" target="_blank">正则表达式</a>轻松验证它。</p><p id="c0cd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">尽管有些细微差别你应该知道。</p><p id="08cb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">第一个细微差别。</strong> Git挂钩没有版本化，因为<code class="fe nh ni nj mz b">.git</code>目录没有索引。这意味着我们不能只是将新添加的钩子推到存储库中，并自动将它们应用到所有贡献者。</p><p id="ea5e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是有一个解决方案。例如，挂钩可以存储在由Git索引的单独目录中。然后，开发人员需要在自定义目录和<code class="fe nh ni nj mz b">.git/hooks</code>目录之间创建一个<a class="ae km" href="https://linuxize.com/post/how-to-create-symbolic-links-in-linux-using-the-ln-command/" rel="noopener ugc nofollow" target="_blank">符号链接</a>。更好的做法是编写一个脚本，以编程方式完成这些步骤。</p><p id="41b9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">第二个细微差别。很难让钩子兼容不同的操作系统。如果你在Linux上，并且<a class="ae km" href="https://en.wikipedia.org/wiki/Bash_(Unix_shell)" rel="noopener ugc nofollow" target="_blank"> Bash </a> hook在你的机器上运行良好，那么另一个在Windows或MacOS上的开发者可能会面临问题。这就是为什么钩子通常用高级编程语言编写的原因。相反，它要求所有贡献者在他们的机器上安装特定的语言(甚至版本可能是至关重要的)。不必要的依赖会导致额外的问题。</strong></p><p id="e483" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">幸运的是，许多包管理器和构建工具提供了插件和库来轻松实现跨平台Git挂钩。我个人最喜欢的是<a class="ae km" href="https://www.npmjs.com/package/husky" rel="noopener ugc nofollow" target="_blank">哈士奇npm包</a>。要创建一个定制的Git钩子，你只需要写几个配置文件。然后可以把钩子更新命令放到<a class="ae km" href="https://docs.npmjs.com/cli/v7/configuring-npm/package-json" rel="noopener ugc nofollow" target="_blank"> package.json </a>的“<a class="ae km" href="https://docs.npmjs.com/cli/v7/using-npm/scripts" rel="noopener ugc nofollow" target="_blank">预安装</a>”脚本中。现在，每次执行<code class="fe nh ni nj mz b">npm install</code>命令时，所有的钩子都会更新。</p><p id="e9b6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，<a class="ae km" href="https://pre-commit.com/" rel="noopener ugc nofollow" target="_blank">预提交</a>包也是一个很好的独立解决方案。</p><h1 id="d9f1" class="kv kw iq bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">语义发布</h1><p id="86c5" class="pw-post-body-paragraph jn jo iq jp b jq lt js jt ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ij bi translated">当我们遇到发行说明生成的自动化时，软件版本控制的问题就变得很重要。我们可以定义贡献规则列表。例如，您可以根据分支名称或提交消息内容增加版本号。或者你可以看看市场上的解决方案。也许有一个适合你的项目。</p><p id="516b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae km" href="https://github.com/semantic-release/semantic-release" rel="noopener ugc nofollow" target="_blank">语义发布</a>是npm包，它完全自动化了部署和发布版本增量的过程。</p><p id="44f5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本库遵循带下划线的概念。</p><ol class=""><li id="3e45" class="ly lz iq jp b jq jr ju jv jy ma kc mb kg mc kk md me mf mg bi translated">存储库中有一个主分支(例如，主分支)。其他的都是短命的。</li><li id="2ab7" class="ly lz iq jp b jq mh ju mi jy mj kc mk kg ml kk md me mf mg bi translated">新的拉取请求定义了新的发布。</li><li id="f93d" class="ly lz iq jp b jq mh ju mi jy mj kc mk kg ml kk md me mf mg bi translated">最初的产品版本是1.0.0。</li></ol><p id="bf20" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">默认情况下，语义发布针对<a class="ae km" href="https://github.com/angular/angular/blob/master/CONTRIBUTING.md#-commit-message-format" rel="noopener ugc nofollow" target="_blank">角度提交消息</a>指南进行了调整。虽然它可以被覆盖，这可能有助于克服我前面描述的提交消息传递文化的问题。</p><p id="b63e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每当一个新的拉请求被合并到主分支时，语义发布会扫描从最后一个发布标签到当前存储库状态的提交。<code class="fe nh ni nj mz b">fix</code>增加了<a class="ae km" href="https://en.wikipedia.org/wiki/Software_versioning#:~:text=Semantic%20versioning%20is%20a%20formal,application%20programming%20interface%20(API)." rel="noopener ugc nofollow" target="_blank">贴片部分</a>。<code class="fe nh ni nj mz b">feat</code>增加小的一个。并且<code class="fe nh ni nj mz b">!</code>符号增加了版本的主要部分(如果需要，您可以覆盖这个行为)。</p><pre class="ko kp kq kr gt my mz na nb aw nc bi"><span id="c8d1" class="mm kw iq mz b gy nd ne l nf ng">The previous version is <strong class="mz ir">1.0.1</strong> <br/>feat: … <br/>feat: … <br/>fix: … <br/>feat: … <br/>The new one is <strong class="mz ir">1.1.0</strong>  </span><span id="4a68" class="mm kw iq mz b gy od ne l nf ng">The previous version is <strong class="mz ir">2.0.3</strong> <br/>build: ... <br/>refactor: … <br/>fix: … <br/>The new one is <strong class="mz ir">2.0.4</strong>  </span><span id="52ce" class="mm kw iq mz b gy od ne l nf ng">The previous version is <strong class="mz ir">12.12.4</strong> <br/>docs: … <br/>feat!: … <br/>fix: … <br/>The new one is <strong class="mz ir">13.0.0</strong></span></pre><p id="4894" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">库在成功执行发布后创建新的标签。标记描述包含从接收到的提交中解析的格式化文档。</p><p id="ac8a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里有一个来自<a class="ae km" href="https://github.com/sindresorhus/eslint-plugin-unicorn/releases/tag/v34.0.0" rel="noopener ugc nofollow" target="_blank"> eslint-plugin-unicorn </a>仓库的发布说明的例子。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="nr ns di nt bf nu"><div class="gh gi oe"><img src="../Images/1fe2803c98ba870d0777ba73a9ddbea1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Tc9DWhWwLh96_Y8u.png"/></div></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk translated">图二。语义发布生成的发布说明示例</figcaption></figure><p id="4f26" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我想提一下，语义发布在Javascript/Typescript环境中是不封闭的。它提供了灵活的配置，帮助我们将这个库与许多其他构建工具和语言集成在一起。此外，还有一些现成的解决方案。比如<a class="ae km" href="https://github.com/conveyal/maven-semantic-release" rel="noopener ugc nofollow" target="_blank"> Maven </a>和<a class="ae km" href="https://github.com/tschulte/gradle-semantic-release-plugin" rel="noopener ugc nofollow" target="_blank"> Gradle </a>插件。</p><p id="836f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如你所注意到的，语义发布建议了面向技术的发布说明生成策略。在我看来，它非常适合库和框架开发(尤其是开源的)。尽管对于企业项目来说，这是一个有争议的解决方案。</p><p id="8b6a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，语义发布对于同时维护多个版本不是一个好的选择。嗯，这个功能是<a class="ae km" href="https://semantic-release.gitbook.io/semantic-release/usage/workflow-configuration" rel="noopener ugc nofollow" target="_blank">支持的</a>。但我认为，由于过于复杂的配置和需要应用棘手的贡献规则，最终的结果不值得。</p><p id="a5cd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">其次，发布通常绑定到<a class="ae km" href="https://www.wrike.com/project-management-guide/faq/what-is-a-milestone-in-project-management/" rel="noopener ugc nofollow" target="_blank">里程碑</a>和<a class="ae km" href="https://www.atlassian.com/agile/project-management/epics-stories-themes" rel="noopener ugc nofollow" target="_blank">故事</a>。这些工件是根据业务需求提交的，而不是您正在使用的提交消息格式。</p><p id="d40f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，在某些情况下，对每个拉请求合并启动一个发布过程是一个过度工程。</p><h1 id="85cd" class="kv kw iq bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">我们如何自动生成发行说明</h1><p id="70af" class="pw-post-body-paragraph jn jo iq jp b jq lt js jt ju lu jw jx jy lv ka kb kc lw ke kf kg lx ki kj kk ij bi translated">现在我们已经接近文章的主题了。我们是如何在公司中实现发行说明生成的。技术团队由GitLab、Jenkins、吉拉和SonarQube组成。图3描述了该过程的关键点。</p><figure class="ko kp kq kr gt ks gh gi paragraph-image"><div role="button" tabindex="0" class="nr ns di nt bf nu"><div class="gh gi of"><img src="../Images/767b007e7710d33e362a20574d9e9309.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Y43oRhZaHLFGceG5.png"/></div></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk translated">图三。部署阶段后自动生成发行说明的过程</figcaption></figure><p id="bfa8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">开发人员将提交推送到特性分支(文档、重构、错误修复等)。).然后，他们创建一个新的拉取请求。如果所有的检查都通过了(包括<a class="ae km" href="https://en.wikipedia.org/wiki/Code_review" rel="noopener ugc nofollow" target="_blank">代码审查</a>，变更被转移到<code class="fe nh ni nj mz b">develop</code>分支。每天在开发环境中部署一次<code class="fe nh ni nj mz b">develop</code>分支(每夜构建)。</p><p id="b97c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">部署结束后，立即解析接收到的提交，以检索在当前版本中关闭的吉拉任务。</p><pre class="ko kp kq kr gt my mz na nb aw nc bi"><span id="a4b2" class="mm kw iq mz b gy nd ne l nf ng">[MTS-2312] - PUT /rest/safe/rule/{ruleId} is accessed only by admin<br/>...<br/>[MTS-2326] - Add sort by 'stage' field</span></pre><p id="d7ff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本例中，我们得到了MTS-2312和MTS-2326任务的列表。</p><p id="5b5d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们可以通过<a class="ae km" href="https://developer.atlassian.com/cloud/jira/platform/rest/v3/intro/" rel="noopener ugc nofollow" target="_blank"> JIRA REST API </a>请求任务摘要和描述。</p><pre class="ko kp kq kr gt my mz na nb aw nc bi"><span id="599b" class="mm kw iq mz b gy nd ne l nf ng"><strong class="mz ir">GET</strong> /rest/api/2/issue/{issueIdOrKey}?fields=<strong class="mz ir">summary</strong>,description&amp;expand=renderedFields</span></pre><p id="5dd6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你应该注意<code class="fe nh ni nj mz b">expand=renderedFields</code>参数。默认情况下，任务信息以JIRA标记格式返回。这些文本在电子邮件中很难阅读和理解。该参数将相同的字段呈现在HTML中，这样更容易漂亮地表示。</p><p id="8e07" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，我们用部署的环境标签标记接触过的JIRA任务。<code class="fe nh ni nj mz b">dev</code>用于开发环境，<code class="fe nh ni nj mz b">staging</code>用于试运行环境。</p><pre class="ko kp kq kr gt my mz na nb aw nc bi"><span id="eb16" class="mm kw iq mz b gy nd ne l nf ng">PUT /rest/api/2/issue/{issueIdOrKey}</span><span id="f0a1" class="mm kw iq mz b gy od ne l nf ng">{ "update": { "labels": [ { "add": "staging" } ] } }</span></pre><p id="100d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，组合信息被放入电子邮件并发送给订户。</p><p id="5b19" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种方法的显著优点是易于扩展。例如，如果我们需要在产品中维护多个版本，那么为每个发布分支克隆流程是没有问题的。</p><p id="8407" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，我们实现了一个自动邮件系统，通知用户上一版本中完成的任务。更重要的是，这个过程不需要在编码过程中进行大的改变。开发人员只需要将任务ID放入他们编写的每个提交消息中。无论如何，如果你想让这个工作，你必须在你的团队中整合提交消息文化。你需要向程序员解释编码规则的本质。为什么它如此重要，它如何能极大地提高产品的质量。因为发行说明也是最终结果的一部分。</p><p id="8010" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我想这就是我想告诉你的关于发行说明一代的全部内容。请在评论区分享这些故事。如果你能告诉我们你们公司的流程是如何运作的，那就太好了。感谢阅读！</p></div></div>    
</body>
</html>