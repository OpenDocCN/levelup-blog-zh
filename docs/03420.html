<html>
<head>
<title>Introduction to Web Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Web组件简介</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/web-components-ca2b6727faad?source=collection_archive---------9-----------------------#2020-05-07">https://levelup.gitconnected.com/web-components-ca2b6727faad?source=collection_archive---------9-----------------------#2020-05-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn js jt ju jv gh gi paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="gh gi jr"><img src="../Images/2a5b1052fead23b57504c4a7f1db1163.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*b0D-lTPkY74Z8Q_9"/></div></div><figcaption class="kc kd gj gh gi ke kf bd b be z dk translated">照片由<a class="ae kg" href="https://unsplash.com/@www_erzetich_com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Blaz Erzetic </a>在<a class="ae kg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="7f4f" class="kh ki it bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated"><strong class="ak">什么是Web组件？</strong></h1><p id="a873" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">代码重用是开发的咒语。我们努力创建一个代码片段来封装它的功能，作为一个单一问题或用例的解决方案。在web开发中，我们可能希望创建一个自定义元素，它有自己的样式、脚本和标记。这个自定义元素应该可以在web上重用。即网站和网络应用。<br/> Web组件帮助我们实现这一切以及更多！它们是一组web平台API，帮助我们创建带有相关样式和脚本的定制HTML标签。它们可以跨浏览器工作，可以与任何支持HTML的JavaScript库或框架一起使用。</p><h1 id="b21e" class="kh ki it bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated"><strong class="ak">积木</strong></h1><p id="cb50" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">Web组件是使用三个主要构件定义的:</p><ol class=""><li id="d501" class="me mf it lh b li mg lm mh lq mi lu mj ly mk mc ml mm mn mo bi translated"><strong class="lh iu">定制元素</strong>:一组JavaScript APIs，帮助我们设计具有相关行为的定制DOM元素。</li><li id="6785" class="me mf it lh b li mp lm mq lq mr lu ms ly mt mc ml mm mn mo bi translated"><strong class="lh iu">影子DOM </strong>:一组JavaScript APIs，用于将封装的“影子”DOM树附加到元素上。该标记与主文档DOM分开呈现。这有助于将元素特性定义为私有特性，因此元素样式或脚本不会与主文档上的脚本和样式发生冲突。</li><li id="d908" class="me mf it lh b li mp lm mq lq mr lu ms ly mt mc ml mm mn mo bi translated"><strong class="lh iu"> HTML模板</strong>:帮助我们编写不显示在页面中的标记。该标记可用于定义自定义元素的结构。它是使用<code class="fe mu mv mw mx b">&lt;template&gt;</code>和<code class="fe mu mv mw mx b">&lt;slot&gt;</code>元素定义的。</li></ol><h1 id="1e20" class="kh ki it bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated"><strong class="ak">自定义元素</strong></h1><p id="0d09" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">自定义元素有两种类型:</p><ol class=""><li id="7cc0" class="me mf it lh b li mg lm mh lq mi lu mj ly mk mc ml mm mn mo bi translated"><strong class="lh iu">自主定制元素</strong>:它们是独立的元素，也就是说，它们<strong class="lh iu">不是</strong>从标准HTML元素继承而来。它们继承自泛型HTMLElement类。比如:<code class="fe mu mv mw mx b">&lt;word-count&gt;</code>或者<code class="fe mu mv mw mx b">document.createElement(‘word-count’)</code>。</li><li id="b6c6" class="me mf it lh b li mp lm mq lq mr lu ms ly mt mc ml mm mn mo bi translated">定制的内置元素:它们继承了基本的HTML元素。它们继承自特定元素类，如HTMLUListElement或HTMLImageElement。您可以通过指定自定义元素的名称来使用它们，因为<strong class="lh iu"> <em class="md">的值是</em> </strong>属性。比如:<code class="fe mu mv mw mx b">&lt;ul is=”styled-list”&gt;</code>或者<code class="fe mu mv mw mx b">document.createElement(‘ul’, {is: “styled-list” })</code>。</li></ol><h2 id="9166" class="my ki it bd kj mz na dn kn nb nc dp kr lq nd ne kv lu nf ng kz ly nh ni ld nj bi translated">生命周期回调</h2><p id="cc7e" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">有几个生命周期回调函数可以在定制元素生命周期的不同点触发。我们可以在定义定制元素时利用这些。一些可用的回调包括:</p><ol class=""><li id="895b" class="me mf it lh b li mg lm mh lq mi lu mj ly mk mc ml mm mn mo bi translated"><strong class="lh iu"><em class="md">connectedCallback</em></strong>:每次将自定义元素追加到文档连接元素中时调用。这将在每次移动节点时发生，并且可能在元素的内容被完全解析之前发生。</li><li id="21ec" class="me mf it lh b li mp lm mq lq mr lu ms ly mt mc ml mm mn mo bi translated"><strong class="lh iu"><em class="md">disconnected callback</em></strong>:每次自定义元素从文档的DOM断开时调用</li><li id="3702" class="me mf it lh b li mp lm mq lq mr lu ms ly mt mc ml mm mn mo bi translated"><strong class="lh iu"><em class="md">adopted callback</em></strong>:每次自定义元素移动到newdocument时调用。</li><li id="0ccb" class="me mf it lh b li mp lm mq lq mr lu ms ly mt mc ml mm mn mo bi translated"><strong class="lh iu"><em class="md">attributeChangedCallback</em></strong>:每次添加、删除或更改自定义元素的属性时调用。在静态get <em class="md"> observedAttributes </em>方法中指定了哪些属性需要注意变化。</li></ol><h1 id="216e" class="kh ki it bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated"><strong class="ak">暗影DOM </strong></h1><p id="0cbe" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">影子DOM允许将隐藏的DOM树附加到常规DOM树中的元素上。影子DOM树从一个影子根开始，在它下面可以附加任何想要的元素，就像普通DOM一样。</p><p id="19ad" class="pw-post-body-paragraph lf lg it lh b li mg lk ll lm mh lo lp lq nk ls lt lu nl lw lx ly nm ma mb mc im bi translated"><strong class="lh iu">术语</strong></p><ol class=""><li id="7c34" class="me mf it lh b li mg lm mh lq mi lu mj ly mk mc ml mm mn mo bi translated"><strong class="lh iu">影子主机</strong>:影子DOM附加的常规DOM节点。</li><li id="2b4b" class="me mf it lh b li mp lm mq lq mr lu ms ly mt mc ml mm mn mo bi translated"><strong class="lh iu">阴影树</strong>:阴影DOM里面的DOM树。</li><li id="2dcc" class="me mf it lh b li mp lm mq lq mr lu ms ly mt mc ml mm mn mo bi translated"><strong class="lh iu">阴影边界</strong>:阴影DOM结束的地方，常规DOM开始。</li><li id="6bf2" class="me mf it lh b li mp lm mq lq mr lu ms ly mt mc ml mm mn mo bi translated"><strong class="lh iu">阴影根</strong>:阴影树的根节点。</li></ol><p id="6c4a" class="pw-post-body-paragraph lf lg it lh b li mg lk ll lm mh lo lp lq nk ls lt lu nl lw lx ly nm ma mb mc im bi translated">使用<em class="md"> attachShadow </em>方法将阴影根连接到任何元素。</p><pre class="nn no np nq gt nr mx ns nt aw nu bi"><span id="7393" class="my ki it mx b gy nv nw l nx ny">const shadow = elementReference.attachShadow({mode: 'open'});<br/>      /* OR */<!-- --> <br/>const shadow = elementReference.attachShadow({mode: 'closed'});<!-- --> </span></pre><p id="13cc" class="pw-post-body-paragraph lf lg it lh b li mg lk ll lm mh lo lp lq nk ls lt lu nl lw lx ly nm ma mb mc im bi translated">这里，如果模式设置为<strong class="lh iu">打开</strong>，我们<strong class="lh iu"> </strong>可以使用主页面中编写的JavaScript访问影子DOM，否则不能。</p><h1 id="3349" class="kh ki it bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">HTML模板</h1><p id="0880" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">HTML模板帮助我们定义自定义元素的结构。</p><h1 id="77ae" class="kh ki it bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">例子</h1><p id="1060" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">让我们创建一个<em class="md">自治</em> <em class="md">自定义元素</em> <code class="fe mu mv mw mx b"><em class="md">&lt;code-snippet&gt;</em></code> <em class="md">。</em>这个元素将接受一个语言名称、功能描述和一个代码片段，并用一些预定义的样式来显示它。您可以在新项目的文档页面中使用它！<br/>这里将使用<code class="fe mu mv mw mx b">&lt;slot&gt;</code>元素。<code class="fe mu mv mw mx b">&lt;slot&gt;</code>帮助我们定义<code class="fe mu mv mw mx b">&lt;template&gt;</code>中的<em class="md">占位符</em>。当在文档中使用元素时，我们可以传递任何标记，用实际的标记替换<code class="fe mu mv mw mx b">&lt;slot&gt;</code>。我们需要给我们的标记的槽属性赋予我们想要在模板中替换的槽的<strong class="lh iu"> <em class="md">名称</em> </strong>。</p><pre class="nn no np nq gt nr mx ns nt aw nu bi"><span id="b007" class="my ki it mx b gy nv nw l nx ny">&lt;template id="code-snippet"&gt;<br/>  &lt;style&gt;<br/>   div {<br/>      border: 1px dotted #867f7f;<br/>      background-color: #efefef;<br/>      padding: 5px;<br/>      text-align: center;<br/>      margin-top: 10px;<br/>    }<br/>   p {<br/>      margin: 0;<br/>      padding: 0; <br/>    }<br/>   strong {<br/>    font-weight: bold;<br/>    color: blue;   <br/>   }<br/>   &lt;/style&gt;<br/>   &lt;div&gt;<br/>    &lt;p&gt;<br/>     &lt;strong&gt;&lt;slot name="language"&gt;language&lt;/slot&gt;&lt;/strong&gt;<br/>    &lt;/p&gt;<br/>    &lt;p&gt;<br/>     &lt;em&gt;&lt;slot name="description"&gt;function description&lt;/slot&gt;&lt;/em&gt;    <br/>    &lt;/p&gt;<br/>    &lt;p&gt;<br/>     &lt;code&gt;&lt;slot name="code"&gt;code snippet&lt;/slot&gt;&lt;/code&gt;<br/>    &lt;/p&gt;<br/>  &lt;/div&gt;<br/>&lt;/template&gt;</span></pre><p id="4786" class="pw-post-body-paragraph lf lg it lh b li mg lk ll lm mh lo lp lq nk ls lt lu nl lw lx ly nm ma mb mc im bi translated">在自定义元素定义中引用此模板。</p><pre class="nn no np nq gt nr mx ns nt aw nu bi"><span id="0f89" class="my ki it mx b gy nv nw l nx ny">/* code-snippet.js */</span><span id="8d39" class="my ki it mx b gy nz nw l nx ny">class CodeSnippet extends HTMLElement {<br/>  constructor() {<br/>    super();<br/>    var template = document.getElementById('code-snippet');<br/>    const shadowRoot = this.attachShadow({ mode: 'open' });<br/>    var templateContent = template.content;<br/>    shadowRoot.appendChild(templateContent.cloneNode(true));<br/>  }<br/>}</span><span id="7629" class="my ki it mx b gy nz nw l nx ny">/* register your element with the CustomElementRegistry using the define method. Pass the name to be used as tag (here code-snippet) and the class name(here CodeSnippet)*/</span><span id="16a4" class="my ki it mx b gy nz nw l nx ny">customElements.define('code-snippet', CodeSnippet);</span></pre><p id="f9c9" class="pw-post-body-paragraph lf lg it lh b li mg lk ll lm mh lo lp lq nk ls lt lu nl lw lx ly nm ma mb mc im bi translated">现在，您可以在HTML文档中使用自定义元素。</p><p id="c0dc" class="pw-post-body-paragraph lf lg it lh b li mg lk ll lm mh lo lp lq nk ls lt lu nl lw lx ly nm ma mb mc im bi translated"><strong class="lh iu">注意</strong>:注册定制元素的脚本必须在DOM解析后加载。因此，要么使用<strong class="lh iu">延迟</strong>来加载脚本，要么在html文档内的<code class="fe mu mv mw mx b">&lt;body&gt;</code>标签底部添加脚本标签。</p><pre class="nn no np nq gt nr mx ns nt aw nu bi"><span id="67f1" class="my ki it mx b gy nv nw l nx ny">/* index.html */<br/>&lt;head&gt;<br/> &lt;script src="code-snippet.js" defer&gt;&lt;/script&gt;<br/>&lt;/head&gt;<br/>&lt;body&gt;<br/>  &lt;h2&gt;Web Component - Code Snippet&lt;/h2&gt;<br/>  &lt;code-snippet&gt;<br/>   &lt;span slot="language"&gt;JavaScript&lt;/span&gt;<br/>   &lt;span slot="description"&gt;Date function&lt;/span&gt;<br/>   &lt;span slot="code"&gt;new Date()&lt;/span&gt;<br/>  &lt;/code-snippet&gt;<br/>  &lt;code-snippet&gt;<br/>   &lt;span slot="language"&gt;PHP&lt;/span&gt;<br/>   &lt;span slot="description"&gt;Date function&lt;/span&gt;<br/>   &lt;span slot="code"&gt;date("Y/m/d")&lt;/span&gt;<br/>  &lt;/code-snippet&gt;<br/> &lt;template id="code-snippet"&gt;<br/>    ...<br/> &lt;/template&gt;<br/>&lt;/body&gt;</span></pre><p id="3a0c" class="pw-post-body-paragraph lf lg it lh b li mg lk ll lm mh lo lp lq nk ls lt lu nl lw lx ly nm ma mb mc im bi translated">就是这样！我们已经创建了一个非常简单的web组件。</p><figure class="nn no np nq gt jv gh gi paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="gh gi oa"><img src="../Images/1d825e567f48d3969a8e061b0fe94bc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gbPwwYNqUm3Za6h3tMeI1A.png"/></div></div></figure><h1 id="f614" class="kh ki it bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">利益</h1><p id="13b1" class="pw-post-body-paragraph lf lg it lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc im bi translated">因为web组件是建立在Web标准之上的，所以它们有一些很大的好处。</p><ol class=""><li id="85c9" class="me mf it lh b li mg lm mh lq mi lu mj ly mk mc ml mm mn mo bi translated">互操作性:他们可以使用不同的技术栈处理多个项目。因为它们不依赖任何框架或库，所以可以使用各种技术栈。</li><li id="17a2" class="me mf it lh b li mp lm mq lq mr lu ms ly mt mc ml mm mn mo bi translated">寿命<strong class="lh iu"/>:因为它们是基于网络标准的，所以很少或者没有重写来适应更新的技术。因此寿命更长。</li><li id="a5ad" class="me mf it lh b li mp lm mq lq mr lu ms ly mt mc ml mm mn mo bi translated">生产力:迭代已经编写好的组件可以帮助我们节省时间和精力。您可以在它们的基础上更快地开发更多功能。</li><li id="3aa0" class="me mf it lh b li mp lm mq lq mr lu ms ly mt mc ml mm mn mo bi translated"><strong class="lh iu">品牌一致性</strong>:根据您的需求管理组件，并让它们在团队中使用，而不考虑技术堆栈，这有助于您在整个应用程序中保持一致的外观和感觉。</li><li id="7480" class="me mf it lh b li mp lm mq lq mr lu ms ly mt mc ml mm mn mo bi translated"><strong class="lh iu">代码共享</strong>:你可以在团队之间和不同的项目中共享相同的逻辑和一致的外观。</li></ol><p id="4754" class="pw-post-body-paragraph lf lg it lh b li mg lk ll lm mh lo lp lq nk ls lt lu nl lw lx ly nm ma mb mc im bi translated"><em class="md">简而言之，Web组件——WORA——编写一次就可以在任何地方运行。</em></p></div></div>    
</body>
</html>