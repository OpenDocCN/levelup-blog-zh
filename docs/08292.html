<html>
<head>
<title>A look at Kotlin’s delegation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">看一看科特林的代表团</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/a-look-at-kotlins-delegation-902bf11fea03?source=collection_archive---------16-----------------------#2021-04-18">https://levelup.gitconnected.com/a-look-at-kotlins-delegation-902bf11fea03?source=collection_archive---------16-----------------------#2021-04-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/18fb2658ab3158a7fd0e93a91d476244.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*hQUPdhCc1-bn9s3S.jpg"/></div></div></figure><p id="2582" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Kotlin提供了许多令人兴奋的功能。一般来说，开发人员倾向于引用空安全作为他们的最爱。对我来说，就是函数扩展。但是授权紧随其后。</p><h1 id="88aa" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">委托模式</h1><p id="f0f2" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">GoF一书中描述了委托模式:</p><blockquote class="lz ma mb"><p id="6218" class="jy jz mc ka b kb kc kd ke kf kg kh ki md kk kl km me ko kp kq mf ks kt ku kv ij bi translated"><strong class="ka ir"> <em class="iq">委托</em> </strong> <em class="iq">是一种让复合像继承一样强大的复用方式[Lie86，JZ91]。在委托中，</em>两个<em class="iq">对象参与处理一个请求:一个接收对象将操作委托给它的</em> <strong class="ka ir"> <em class="iq">委托</em> </strong> <em class="iq">。这类似于子类推迟对父类的请求。但是有了继承，一个继承的操作总是可以通过C++中的</em> <code class="fe mg mh mi mj b"><em class="iq">this</em></code> <em class="iq">成员变量和Smalltalk中的</em> <code class="fe mg mh mi mj b"><em class="iq">self</em></code> <em class="iq">引用接收对象。为了达到与委托相同的效果，接收者将自己传递给委托者，让委托的操作引用接收者。</em></p></blockquote><figure class="ml mm mn mo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mk"><img src="../Images/48bcbe56817365f16eff00092c166b64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TNeP7dWL-dQ9R0owvBK02g.png"/></div></div></figure><p id="82ae" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当人们选择<em class="mc">组合</em>而不是<em class="mc">继承</em>时，委托是至关重要的。</p><figure class="ml mm mn mo gt jr gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/7476fc2f782016067ffe96028ff19e21.png" data-original-src="https://miro.medium.com/v2/resize:fit:882/format:webp/1*KQV13QIaoKclYwG_SA5I_w.png"/></div></figure><h1 id="d71c" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">手动和本机委托</h1><p id="f5e8" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">在Java中，您需要手动编写委托代码。上面的示例转换成以下代码:</p><pre class="ml mm mn mo gt mq mj mr ms aw mt bi"><span id="2a2b" class="mu kx iq mj b gy mv mw l mx my">interface A {<br/>    void foo();<br/>}</span><span id="2be1" class="mu kx iq mj b gy mz mw l mx my">class B implements A {<br/>    @Override<br/>    public void foo() {<br/>    }<br/>}</span><span id="3e98" class="mu kx iq mj b gy mz mw l mx my">class Composition implements A {<br/>    private final B b;</span><span id="ed0c" class="mu kx iq mj b gy mz mw l mx my">    Composition(B b) {<br/>        this.b = b;<br/>    }</span><span id="3943" class="mu kx iq mj b gy mz mw l mx my">    @Override<br/>    public void foo() {<br/>        b.foo();<br/>    }<br/>}</span></pre><p id="8a98" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">科特林使用关键字<code class="fe mg mh mi mj b">by</code>直接处理委托。您可以用Kotlin编写相同的代码，如下所示:</p><pre class="ml mm mn mo gt mq mj mr ms aw mt bi"><span id="06ea" class="mu kx iq mj b gy mv mw l mx my">interface A {<br/>    fun foo()<br/>}<br/><br/>class B : A {<br/>    override fun foo() {}<br/>}<br/><br/>class Delegate(b: B) : A by b          // 1</span></pre><ol class=""><li id="8893" class="na nb iq ka b kb kc kf kg kj nc kn nd kr ne kv nf ng nh ni bi translated">有了这个，您可以在任何<code class="fe mg mh mi mj b">Delegate</code>实例上调用<code class="fe mg mh mi mj b">foo()</code></li></ol><p id="3b61" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如文件中所解释的:</p><blockquote class="lz ma mb"><p id="0946" class="jy jz mc ka b kb kc kd ke kf kg kh ki md kk kl km me ko kp kq mf ks kt ku kv ij bi translated"><em class="iq">超类型列表中</em> <code class="fe mg mh mi mj b"><em class="iq">Delegate</em></code> <em class="iq">的by子句表示</em> <code class="fe mg mh mi mj b"><em class="iq">b</em></code> <em class="iq">将被内部存储在</em> <code class="fe mg mh mi mj b"><em class="iq">Delegate</em></code> <em class="iq">的对象中，编译器将生成</em> <code class="fe mg mh mi mj b"><em class="iq">B</em></code> <em class="iq">的所有方法，并转发给</em> <code class="fe mg mh mi mj b"><em class="iq">b</em></code> <em class="iq">。</em></p><p id="af94" class="jy jz mc ka b kb kc kd ke kf kg kh ki md kk kl km me ko kp kq mf ks kt ku kv ij bi translated">— <a class="ae nj" href="https://kotlinlang.org/docs/reference/delegation.html" rel="noopener ugc nofollow" target="_blank">代表团</a></p></blockquote><h1 id="993e" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">委派属性</h1><p id="4573" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">Kotlin还提供了<strong class="ka ir">委托属性</strong>，这个属性将它的getter(如果是<code class="fe mg mh mi mj b">var</code>，还有它的setter)委托给“其他东西”。委托属性也使用<code class="fe mg mh mi mj b">by</code>关键字。</p><p id="9cbe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过标准库可以获得一些现成的委托。</p><p id="639b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">非空委托:</strong>非<code class="fe mg mh mi mj b">null</code>委托的行为方式与<code class="fe mg mh mi mj b">lateinit</code>关键字相同:如果在将变量初始化为非<code class="fe mg mh mi mj b">null</code>值之前使用该变量，它将抛出<code class="fe mg mh mi mj b">IllegalStateException</code>。</p><pre class="ml mm mn mo gt mq mj mr ms aw mt bi"><span id="7fe0" class="mu kx iq mj b gy mv mw l mx my">var notNull: String by Delegates.notNull()</span></pre><p id="8f95" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">惰性委托:</strong>惰性委托在第一次访问时计算值<em class="mc">，存储它，然后返回存储的值。顾名思义，当值的计算代价很高并且计算后不变时，就使用<code class="fe mg mh mi mj b">lazy</code>。</em></p><pre class="ml mm mn mo gt mq mj mr ms aw mt bi"><span id="4e57" class="mu kx iq mj b gy mv mw l mx my">val lazy: String by lazy { "An expensive computation" }</span></pre><p id="408c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">可观察的:</strong>当值被访问时，一个可观察的委托提供一个钩子，这样你就可以在之后执行代码<strong class="ka ir"/>。</p><pre class="ml mm mn mo gt mq mj mr ms aw mt bi"><span id="9c41" class="mu kx iq mj b gy mv mw l mx my">val observed = "Observed"<br/>val observable: String by Delegates.observable(observed) {<br/>    _, old, new -&gt; println("old: $old, new: $new")<br/>}</span></pre><p id="21b3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">可否决的:可否决的代表是可观察的对立面。它提供了一个在之前执行<strong class="ka ir">的钩子。如果这个钩子返回<code class="fe mg mh mi mj b">true</code>，值的设置按预期执行；如果它返回<code class="fe mg mh mi mj b">false</code>，设置不会发生。</strong></p><pre class="ml mm mn mo gt mq mj mr ms aw mt bi"><span id="96f8" class="mu kx iq mj b gy mv mw l mx my">val vetoable: String by Delegates.vetoable(observed) {<br/>    _, _, _ -&gt; Random.nextBoolean()<br/>}</span></pre><p id="c881" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这里，集合随机地失败了50%的时间。为你的同事调试没有帮助，但很有趣。</p><h1 id="1fa0" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">你自己的委托财产</h1><p id="610a" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">如果您想创建自己的委托属性，它需要指向一个类，该类具有:</p><ol class=""><li id="459c" class="na nb iq ka b kb kc kf kg kj nc kn nd kr ne kv nf ng nh ni bi translated">值不可变的字段的<code class="fe mg mh mi mj b">operator fun &lt;T, U&gt; getValue(thisRef: T, prop: KProperty&lt;*&gt;): U</code> <strong class="ka ir">运算符</strong>函数</li><li id="eabb" class="na nb iq ka b kb nk kf nl kj nm kn nn kr no kv nf ng nh ni bi translated">一个额外的<code class="fe mg mh mi mj b">operator fun &lt;T, U&gt; setValue(thisRef: T, prop: KProperty&lt;*&gt;, value: U)</code>如果它是可变的</li></ol><ul class=""><li id="bc2a" class="na nb iq ka b kb kc kf kg kj nc kn nd kr ne kv np ng nh ni bi translated"><code class="fe mg mh mi mj b">T</code>是类‘类型</li><li id="7d69" class="na nb iq ka b kb nk kf nl kj nm kn nn kr no kv np ng nh ni bi translated"><code class="fe mg mh mi mj b">U</code>物业的</li><li id="988d" class="na nb iq ka b kb nk kf nl kj nm kn nn kr no kv np ng nh ni bi translated"><code class="fe mg mh mi mj b">thisRef</code>是类实例</li><li id="73dd" class="na nb iq ka b kb nk kf nl kj nm kn nn kr no kv np ng nh ni bi translated"><code class="fe mg mh mi mj b">value</code>是新值</li><li id="5d4c" class="na nb iq ka b kb nk kf nl kj nm kn nn kr no kv np ng nh ni bi translated"><code class="fe mg mh mi mj b">prop</code>是财产本身</li></ul><p id="81ea" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">作为一个例子，让我们实现一个基于IMDG的分布式缓存委托属性。</p><pre class="ml mm mn mo gt mq mj mr ms aw mt bi"><span id="63a2" class="mu kx iq mj b gy mv mw l mx my">class HazelcastDelegate&lt;T&gt;(private val key: String) {</span><span id="bb5f" class="mu kx iq mj b gy mz mw l mx my">  private val map: IMap&lt;String, Any&gt; by lazy {                // 1          <br/>    val config = Config().apply {<br/>      instanceName = "Instance"<br/>    }<br/>    Hazelcast.getOrCreateHazelcastInstance(config).getMap("values")<br/>  }</span><span id="6340" class="mu kx iq mj b gy mz mw l mx my">  operator fun getValue(thisRef: T, prop: KProperty&lt;*&gt;) = map[key] //2     </span><span id="822e" class="mu kx iq mj b gy mz mw l mx my">  operator fun setValue(thisRef: T, prop: KProperty&lt;*&gt;, value: Any?) {<br/>      map[key] = value                                        // 3          <br/>  }<br/>}</span></pre><ol class=""><li id="8f02" class="na nb iq ka b kb kc kf kg kj nc kn nd kr ne kv nf ng nh ni bi translated">创建对Hazelcast的引用<code class="fe mg mh mi mj b">IMap</code></li><li id="a37f" class="na nb iq ka b kb nk kf nl kj nm kn nn kr no kv nf ng nh ni bi translated">从<code class="fe mg mh mi mj b">IMap</code>中获取数值</li><li id="69ba" class="na nb iq ka b kb nk kf nl kj nm kn nn kr no kv nf ng nh ni bi translated">在<code class="fe mg mh mi mj b">IMap</code>中设置数值</li></ol><p id="59c4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用上面的委托很简单:</p><pre class="ml mm mn mo gt mq mj mr ms aw mt bi"><span id="e2eb" class="mu kx iq mj b gy mv mw l mx my">class Foo {<br/>  var cached: Any? by HazelcastDelegate&lt;Foo&gt;("cached")<br/>}</span><span id="51f2" class="mu kx iq mj b gy mz mw l mx my">fun main() {<br/>  val foo = Foo()<br/>  foo.cached = "New value"<br/>  println(foo.cached)<br/>}</span></pre><h1 id="2cf2" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">结论</h1><p id="ba5e" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">委托模式在面向对象编程世界中无处不在。一些语言，比如Kotlin，提供了本地实现。</p><p id="5a62" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是授权并不停留在班级层面。Kotlin确实提供了属性级的委托。它提供了一些现成的委托，但是您可以轻松地创建自己的委托。</p><h1 id="0b2c" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">为了更进一步:</h1><ul class=""><li id="bbf2" class="na nb iq ka b kb lu kf lv kj nq kn nr kr ns kv np ng nh ni bi translated"><a class="ae nj" href="https://kotlinlang.org/docs/reference/delegation.html" rel="noopener ugc nofollow" target="_blank">代表团</a></li><li id="1076" class="na nb iq ka b kb nk kf nl kj nm kn nn kr no kv np ng nh ni bi translated"><a class="ae nj" href="https://kotlinlang.org/docs/reference/delegated-properties.html" rel="noopener ugc nofollow" target="_blank">委托属性</a></li></ul></div><div class="ab cl nt nu hu nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="ij ik il im in"><p id="dc67" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="mc">原载于2021年4月18日</em> <a class="ae nj" href="https://blog.frankel.ch/kotlin-delegation/" rel="noopener ugc nofollow" target="_blank"> <em class="mc">一个Java怪胎</em> </a> <em class="mc">。</em></p></div></div>    
</body>
</html>