<html>
<head>
<title>From Zero to MVP: 3 Tools I Use to Build Apps Fast</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从零到MVP:我用来快速构建应用的3个工具</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/from-zero-to-mvp-3-tools-i-use-to-build-apps-fast-f6438b575143?source=collection_archive---------1-----------------------#2021-06-26">https://levelup.gitconnected.com/from-zero-to-mvp-3-tools-i-use-to-build-apps-fast-f6438b575143?source=collection_archive---------1-----------------------#2021-06-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/94182bbbb44d3519445e2ad6a00a0049.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4_FKWQ1sTEHgY5svLruOoQ.png"/></div></div></figure><p id="e41d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">上市时间对MVP至关重要:如果你花了一个多月的时间来构建(40小时工作周)，它就不再是MVP，而是一个产品。有时候，早花一个小时，晚省十个小时是值得的。</p><p id="d51b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你想修改或添加什么，请不要犹豫，留下你的评论。我一直在寻求学习。</p><p id="92df" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面是我用来加快开发速度的3个工具。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h2 id="60dc" class="lg lh it bd li lj lk dn ll lm ln dp lo km lp lq lr kq ls lt lu ku lv lw lx ly bi translated">1.邮递员</h2><p id="8cff" class="pw-post-body-paragraph kb kc it kd b ke lz kg kh ki ma kk kl km mb ko kp kq mc ks kt ku md kw kx ky im bi translated">(我知道这个部分是对《邮差》的热情洋溢的评论——我没有得到赞助，这篇文章也没有。我只是觉得这是一个很棒的工具。)</p><p id="850d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Postman在开发者社区中无处不在。我不知道有多少开发人员在没有它的情况下编写服务器端代码。它出色的用户界面和易用性使它成为调用API的最快方式。每当我启动我的应用程序时，当应用程序运行时，我会确保在另一个窗口打开Postman，因为它会派上用场。</p><p id="1cf3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但是从我见过的所有使用Postman的开发者来看，几乎都只是使用了Postman的基本特性集。如果你只打开postman来发送HTTP请求，你就错过了它的一些最好的特性。</p><p id="1f1b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这不会是一个关于Postman的教程(如果你想要一个关于如何有效使用Postman的教程，请留下评论！)，但是我确实有一些特性，如果你想让自己成为一台MVP开发机器，你可能想看看。</p><p id="3773" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">服务器嘲讽</strong></p><p id="0ea1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我最近的应用程序让我在后端花一秒钟之前就构建好了整个前端。我发现前端第一，对我来说，是要走的路:它帮助我跟随YAGNI(你不会需要它)，因为我在后端建立的路线是<em class="me">唯一的</em>我需要的路线:我的模型有我需要的数据，没有额外的，并且创建的功能是精简的，只做我要求它做的事情。</p><p id="f763" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里有一些开销，但是我认为快速开发的关键是在开发前花10分钟来节省10个小时。</p><p id="1caf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">收藏</strong></p><p id="4ba9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">邮差收藏有两大好处。第一个是调用API的便利性。如果您将调用您的(real！)后端，您不必担心进入您的swagger文档或计算出您需要的确切参数。</p><p id="30a4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对我来说，我将我的身份验证路由添加到集合中，这为我节省了时间。我没有找到有效的JWT，也没有每次都记住用户名和密码，而是打开postman，点击集合中的路线，然后点击发送。嘣，有效通行令牌直接送到你手里。现在只需要将它保存为一个变量(至少在令牌过期之前)，现在您可以访问任何内容。</p><p id="d8cf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">另一个大好处是与队友分享——如果你想让另一个开发者加入你的应用，你可以把你的收藏发给他们，包括对每条路线的评论、对整个收藏的注释等。它可以成为一个令人敬畏的知识来源。</p><p id="4dc7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">环境</strong></p><p id="5dda" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在生产、测试、本地、QA等之间切换。环境从未如此简单。说够了。</p><h2 id="d58d" class="lg lh it bd li lj lk dn ll lm ln dp lo km lp lq lr kq ls lt lu ku lv lw lx ly bi translated">2.GraphQL(哈苏拉，阿波罗等。)</h2><p id="a4c8" class="pw-post-body-paragraph kb kc it kd b ke lz kg kh ki ma kk kl km mb ko kp kq mc ks kt ku md kw kx ky im bi translated">再说一次——我们希望加快开发速度，如果GraphQL不是专门为此开发的，我会被诅咒的。</p><p id="5a26" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">大多数应用都属于CRUD命名空间，即使没有(游戏、通讯)，你也可以保证在你的应用的某个地方有CRUD功能<em class="me">。节省您为每个模型编写PUT、GET、PATCH、POST、DELETE路径的时间。REST有一些主要的缺陷，即它的不灵活性。</em></p><p id="9e67" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">GraphQL使得消费API的愚蠢变得容易。我使用<a class="ae mf" href="https://pub.dev/packages/ferry" rel="noopener ugc nofollow" target="_blank"> Flutter Ferry </a>(显然是专门针对Flutter的，但Apollo是大多数其他应用类型的类似客户端)我高兴不起来。能够跳过我的整个服务层，将一个<code class="fe mg mh mi mj b">GqlConsumer</code>小部件直接添加到UI中，并且仍然保持一个干净的模式，这让我非常高兴。我节省了大量的时间和代码，因为我可以请求我想要的字段，而不必写出一个<code class="fe mg mh mi mj b">/api/changeName/</code>路由和定义输入、功能、认证等。</p><p id="2376" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用Ferry，我可以指定是否要进入缓存，或者是否要发出API请求。这很有帮助，因为我不需要本地缓存层——Ferry为我们构建了它。我曾经是SQLite本地缓存的拥护者，现在仍然是很多事情的拥护者，但是在完全理解了GraphQL本地缓存之后，我完全抛弃了它。GraphQL用一半的代码就完成了我用Moor做的所有事情。我不需要存储库层——我只需要用<code class="fe mg mh mi mj b">.cacheOnly</code>进行查询，而不必手动进行任何缓存。</p><p id="c304" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">GraphQL也有助于文档化:描述整个模式的单一路径有助于任何希望添加新开发人员或记住他们昨晚做了什么的人更加容易。</p><p id="3d65" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但是，如果您从头开始编写GraphQL后端，我可以看到这是一个巨大的麻烦。如果你打算走这条路，我推荐使用阿波罗或哈苏拉(我用的)——它会节省你几个小时。如果你想廉价地构建你的MVP，Hasura是开源的，你可以在Heroku上免费运行它。</p><h2 id="7268" class="lg lh it bd li lj lk dn ll lm ln dp lo km lp lq lr kq ls lt lu ku lv lw lx ly bi translated">3.单一报告</h2><p id="2b7e" class="pw-post-body-paragraph kb kc it kd b ke lz kg kh ki ma kk kl km mb ko kp kq mc ks kt ku md kw kx ky im bi translated">好吧，这与其说是一种工具，不如说是一种设计模式——但是请听我说。</p><p id="8331" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我把我所有的代码都放在一个mono repo里。我的回购看起来像这样:</p><pre class="mk ml mm mn gt mo mj mp mq aw mr bi"><span id="7637" class="lg lh it mj b gy ms mt l mu mv">App<br/> | - API gateway<br/> | - Lambdas (actually Cloudflare Workers but they are less known)<br/> | - Hasura<br/> | - Frontend</span></pre><p id="6eae" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我在每个子目录中都有一个Makefile，包含以下两个命令:</p><ul class=""><li id="a193" class="mw mx it kd b ke kf ki kj km my kq mz ku na ky nb nc nd ne bi translated">运行:在本地运行应用程序</li><li id="cfcc" class="mw mx it kd b ke nf ki ng km nh kq ni ku nj ky nb nc nd ne bi translated">进行测试:测试应用程序</li></ul><p id="4bf4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这有两大好处:</p><p id="cc33" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> App启动速度</strong></p><p id="3546" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在<code class="fe mg mh mi mj b">App</code>目录中，该Makefile使用npm <a class="ae mf" href="https://www.npmjs.com/package/concurrently" rel="noopener ugc nofollow" target="_blank">并发运行所有其他Makefile</a>。这是其中的一个片段:</p><figure class="mk ml mm mn gt ju gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/d32c8dd0429daf8f20350afc267afc88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/1*TbJtFI6kURq-UDZLwvYkSw.png"/></div></figure><p id="443b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您可以看到，我将每个进程放在它自己的颜色括号中(即<code class="fe mg mh mi mj b">[WORKER]</code>)(为了便于跟踪，我已经记住了这些颜色)，因此不难看出哪里发生了什么错误。</p><p id="796b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这样做的真正好处是启动应用程序的速度。我每次在根目录下做<code class="fe mg mh mi mj b">make run</code>都会起鸡皮疙瘩。现代应用是高度分布式的。不管你喜不喜欢，你至少在为你的应用运行<em class="me"/>一个s3木桶。您不必担心启动应用程序需要15分钟。如果你是一个斗志昂扬的MVP开发者，你一有机会就会开发——可能是在你在家休息的30分钟时间里。你不应该花一半的时间来启动你的应用。</p><p id="8f03" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"> CI/CD </strong></p><p id="7aea" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">用这个系统建立一个管道是非常简单的。如果您只对应用程序的一个部分进行更改，那么在每次推送时测试和部署应用程序的每个部分可能有点浪费，但是您可以获得一些高级Github动作脚本，该脚本只在某些文件夹发生更改时运行动作。对我来说，我让我的github操作运行我的<code class="fe mg mh mi mj b">make test</code>,然后在每次推送时部署。</p><p id="dbfc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我确实认为MVP需要测试和CI/CD。只需要几天时间就可以设置一些简单的东西。bug对MVP来说是致命的，如果他们看到一个致命的bug，就会拒绝用户——测试是必要的。对于无法通过测试发现的错误:你希望能够尽快部署更改，这样，如果用户在凌晨2点打电话给你，说有一个错误不允许他们使用应用程序，你可以在几分钟内做出更改并部署它，而不是几个小时。</p><p id="29c9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">组织利益</strong></p><p id="15ac" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我只需在VSCode中打开我的monorepo，然后开始破解。不需要打开许多窗口或项目——如果我想进行前端更改，我只需打开该文件夹并进行更改。如果我想进行后端更改，同样的过程适用。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><p id="3371" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">原来如此！我用来提高开发速度的3个工具。</p><p id="bc5a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">再说一次，我也很想听听你的建议。如果你认为我能做得更好，请告诉我！如果有我应该知道的流程或计划，请告诉我！</p><p id="3039" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">感谢阅读。</p></div></div>    
</body>
</html>