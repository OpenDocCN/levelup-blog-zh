<html>
<head>
<title>Channels inside channels pattern in Golang</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">古浪沟中沟模式</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/channels-inside-channels-pattern-in-golang-3d0e73a545cc?source=collection_archive---------13-----------------------#2020-02-04">https://levelup.gitconnected.com/channels-inside-channels-pattern-in-golang-3d0e73a545cc?source=collection_archive---------13-----------------------#2020-02-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/09618d6e5af3090fc356229395db7aad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JSpFTYjOuj07PBd9"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@chuttersnap?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> chuttersnap </a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="1fae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">作为IBM Cloud日常工作的一部分，有时我会用Golang编写代码。这篇文章是关于一个我发现很有用的技术。</p><p id="d473" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Golang的频道很棒。当涉及到流程内部的交流时，他们需要解决各种问题。有很多教程展示了基于渠道+go-routine+上下文的解决方案。模式包括扇入、扇出、流水线、速率限制器、负载平衡器等。然而，当我开始从零开始创建代码时，有时我会很纠结，尤其是在请求-响应的情况下。看起来我仍然应该使用互斥体，但是我不想这样做。这篇文章是关于如何不这样做，而是把通道放在通道里面。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="2497" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">问题是</h1><p id="717f" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">首先这听起来很奇怪，所以让我展示一个真实的例子。想象一下，你有一份数据，随时都在变化。您可以分配一个在go-routine中运行的所有者方法来进行更新。假设您的流程是一个网络服务，当客户端请求到来时，主题数据通过它的API提供。这意味着将会从相同的数据结构中读取数据，同时在它自己的go-routine中可能会发生变化。让我们来看一个虚拟的例子:</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="29bc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如您所见，<code class="fe mr ms mt mu b">Run()</code>函数每秒都在改变数据。相同结构的<code class="fe mr ms mt mu b">Get()</code>函数能够在被调用时读取数据。之后是一个没有任何断言的测试用例，但还是有用的。它产生了<code class="fe mr ms mt mu b">Run()</code>函数，休眠一秒钟并读取数据。Golang工具链中有一个非常有用的工具，它能够检测数据竞争。用这个命令试试:<code class="fe mr ms mt mu b">go test . -race</code>。结果是意料之中的，我们有一场严重的数据竞赛:</p><pre class="ml mm mn mo gt mv mu mw mx aw my bi"><span id="82a3" class="mz lj iq mu b gy na nb l nc nd">➜ go test . -race<br/>==================<br/>WARNING: DATA RACE<br/>Write at 0x00c00009e070 by goroutine 9:<br/>  github.com/libesz/datarace.(*Data).Run()<br/>      /Users/gergo/go/src/github.com/libesz/datarace/datarace_test.go:22 +0x213</span><span id="7f30" class="mz lj iq mu b gy ne nb l nc nd">Previous read at 0x00c00009e070 by goroutine 8:<br/>  github.com/libesz/datarace.TestConcurrent()<br/>      /Users/gergo/go/src/github.com/libesz/datarace/datarace_test.go:29 +0x96<br/>  testing.tRunner()<br/>      /usr/local/Cellar/go/1.13.4/libexec/src/testing/testing.go:909 +0x199</span><span id="8e9a" class="mz lj iq mu b gy ne nb l nc nd">Goroutine 9 (running) created at:<br/>  github.com/libesz/datarace.TestConcurrent()<br/>      /Users/gergo/go/src/github.com/libesz/datarace/datarace_test.go:34 +0x7a<br/>  testing.tRunner()<br/>      /usr/local/Cellar/go/1.13.4/libexec/src/testing/testing.go:909 +0x199</span><span id="a3c7" class="mz lj iq mu b gy ne nb l nc nd">Goroutine 8 (running) created at:<br/>  testing.(*T).Run()<br/>      /usr/local/Cellar/go/1.13.4/libexec/src/testing/testing.go:960 +0x651<br/>  testing.runTests.func1()<br/>      /usr/local/Cellar/go/1.13.4/libexec/src/testing/testing.go:1202 +0xa6<br/>  testing.tRunner()<br/>      /usr/local/Cellar/go/1.13.4/libexec/src/testing/testing.go:909 +0x199<br/>  testing.runTests()<br/>      /usr/local/Cellar/go/1.13.4/libexec/src/testing/testing.go:1200 +0x521<br/>  testing.(*M).Run()<br/>      /usr/local/Cellar/go/1.13.4/libexec/src/testing/testing.go:1117 +0x2ff<br/>  main.main()<br/>      _testmain.go:44 +0x223<br/>==================<br/>--- FAIL: TestConcurrent (1.00s)<br/>FAIL<br/>FAIL    github.com/libesz/datarace      1.325s<br/>FAIL</span></pre><p id="6b1f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它完美地报告了读取和写入可能同时发生，并可能导致数据损坏。问题实际上是，在您的应用程序中可能有多个并发任务想要访问相同的数据。你永远不知道在你的所有者go-routine中数据是如何写入的，而读操作将被调度到操作系统线程中。这是典型的多写多读用例，也是解决方案进入锁定算法的地方(如何使用读写互斥，等等)。).这里连Golang教程都在暗示互斥，而语言哲学是:<a class="ae kc" href="https://golang.org/doc/effective_go.html#sharing" rel="noopener ugc nofollow" target="_blank"> <em class="nf">不通过共享内存来交流；而是通过</em> </a> <em class="nf">通信共享内存。</em></p><h1 id="6c34" class="li lj iq bd lk ll ng ln lo lp nh lr ls lt ni lv lw lx nj lz ma mb nk md me mf bi translated">一些初步尝试</h1><p id="0f67" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">因此，我们希望在上述用例的代码中创建一个没有互斥或其他sync原语用法的通用模式。渠道应该总是有帮助的，对吧？:)</p><p id="e9c1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是为了通过信道发送任何东西，发送方和接收方都必须知道它的处理程序。它应该是<code class="fe mr ms mt mu b">Data</code>结构的一部分吗？假设我们在结构中有一个<code class="fe mr ms mt mu b">UpdateChan chan int</code>字段，所有者go-routine可以在其中宣布变更。我们立刻面临多重问题:</p><ul class=""><li id="3d13" class="nl nm iq kf b kg kh kk kl ko nn ks no kw np la nq nr ns nt bi translated">如果没有人真正对更新感兴趣，发送者部分将被阻止。如果我们创建一个缓冲通道，那么过时的更新将首先被使用。</li><li id="f937" class="nl nm iq kf b kg nu kk nv ko nw ks nx kw ny la nq nr ns nt bi translated">如果请求是特别的(即，当某人做一个API请求时)，信息推送到信道也应该按需完成。</li></ul><p id="cbd7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们能否使用一个通道来发送数据读取请求，然后在同一通道上发回数据？嗯，最好不要。频道是类型化的，这是Go的一大特色。这意味着数据应该有一个具体的数据类型，最好避免<code class="fe mr ms mt mu b">struct{}</code>加讨厌的强制转换。这也意味着发送者和接收者在任何时候都不应该被交换来进行双向通信。</p><p id="e1e0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">似乎我们需要两个通道来解决这个问题…一个通道发送读请求，另一个通道将数据发送回请求者的go-routine。大概是这样的:</p><pre class="ml mm mn mo gt mv mu mw mx aw my bi"><span id="4dc7" class="mz lj iq mu b gy na nb l nc nd">type Data struct {<br/> secretOfTheSecond int<br/> ReadRequest chan struct{}<br/> ReadResponse chan int<br/>}</span></pre><p id="f719" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们越来越近了。如果任何go-routine想要数据，它将任何东西发送到<code class="fe mr ms mt mu b">ReadRequest</code>通道，并开始监听<code class="fe mr ms mt mu b">ReadResponse</code>通道。<code class="fe mr ms mt mu b">Run()</code>等待任何推入<code class="fe mr ms mt mu b">ReadRequest</code>通道的数据，并将当前数据推入<code class="fe mr ms mt mu b">ReadResponse</code>通道。</p><p id="ce3e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是我们现在有了一个新问题…</p><p id="28b8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一个频道可以被多个go-routine同时自由收听。如果多个接收者对来自响应通道的更新感兴趣，则只有其中一个接收者能够读取更新。当然，如果有多个接收者，他们都应该发送数据请求，但是哪个响应是针对谁的，等等..我们认为，这不是防弹的。</p><p id="7c4c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">响应通道应归数据请求者所有，不得共享。</p><h1 id="4232" class="li lj iq bd lk ll ng ln lo lp nh lr ls lt ni lv lw lx nj lz ma mb nk md me mf bi translated">在渠道中发明渠道</h1><p id="c2bc" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">当然这不是我发明的。通道是一等公民，是围棋中的一种基本数据类型。作为声明的一部分，它们被赋予另一种任意的数据类型，以后可以传输。也就是说，一个通道可以保存任何数据类型，也可以是一个通道！优雅。</p><p id="559f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的新数据结构可以是这样的:</p><pre class="ml mm mn mo gt mv mu mw mx aw my bi"><span id="930c" class="mz lj iq mu b gy na nb l nc nd">type Data struct {<br/> secretOfTheSecond int<br/> readRequest chan chan int<br/>}</span></pre><p id="720e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们可以为该结构重新实现<code class="fe mr ms mt mu b">Get()</code>方法，以在读取器的上下文中创建一个独占通道(类型为<code class="fe mr ms mt mu b">int</code>),并将其发送到<code class="fe mr ms mt mu b">readRequest</code>通道中。数据所有者go-routine可以调度这个事件，并可以提取数据请求者创建的通道来发送响应。</p><p id="f3ed" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">完整的示例如下所示:</p><figure class="ml mm mn mo gt jr"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="8513" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如我们所见，我们不再有数据竞争:</p><pre class="ml mm mn mo gt mv mu mw mx aw my bi"><span id="c013" class="mz lj iq mu b gy na nb l nc nd">➜ go test . -race<br/>ok      github.com/libesz/datarace      2.200s</span></pre><p id="902c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">作为增强的一部分，我们开始将我们的<code class="fe mr ms mt mu b">Run()</code>方法改为一个小的事件循环(为了清晰起见，没有实现错误处理)。它将用数据更新序列化所有传入的请求。您可以通过添加多个不同的读(或写！)请求，它们各自的通道位于结构中的通道成员字段中。</p><p id="42d2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我发现这个图案非常干净优雅。您可以将它引入多个用例。当然，在底层，通道使用较低级别的同步原语，如互斥体和共享内存，但我们不一定要亲自动手处理这些东西:)。</p><p id="6d08" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您有一个对性能和时间非常敏感的应用程序，您可能想在应用上面的想法之前阅读另一篇文章。这是一个关于Golang信道性能的详细基准:<a class="ae kc" href="https://syslog.ravelin.com/so-just-how-fast-are-channels-anyway-4c156a407e45" rel="noopener ugc nofollow" target="_blank">https://syslog . ravelin . com/so-just-how-fast-are-channels-anyway-4c 156 a 407 e 45</a></p></div></div>    
</body>
</html>