<html>
<head>
<title>Building a secure single-page application (SPA) with React.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React.js构建安全的单页面应用程序(SPA)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/building-a-secure-single-page-application-spa-with-react-js-194f30a55cb2?source=collection_archive---------1-----------------------#2020-05-15">https://levelup.gitconnected.com/building-a-secure-single-page-application-spa-with-react-js-194f30a55cb2?source=collection_archive---------1-----------------------#2020-05-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="821c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用Node.js、Express、MongoDB和React.js的全栈应用程序</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8b6cf9f5525e2b7c182c39dd67a0d999.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*g4KUXYX4Z4oTzUup"/></div></div></figure><p id="fb8b" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这篇博客中，我构建了一个前端应用程序，它通过RESTful API与后端应用程序接口。在构建了前端之后，我添加了安全性，这样只有授权的用户才能访问特定的内容并向后端发出请求。</p><p id="6270" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">前端应用程序是用一组JavaScript库构建的:React.js、React Router和axios。后端应用程序是用Node.js、Express.js和MongoDB构建的，是我以前的博客中讨论的一个项目的结果，在我以前的博客中，我详细介绍了<a class="ae lq" rel="noopener ugc nofollow" target="_blank" href="/building-a-restful-api-with-node-js-831bff629e3b">如何使用Node.js、Express.js和MongoDB构建RESTful API</a>和<a class="ae lq" rel="noopener ugc nofollow" target="_blank" href="/securing-a-restful-api-built-with-node-js-f7feefc1efe1">如何保护用Node.js构建的RESTful API</a>。要跟进，您可以在我的GitHub上找到<a class="ae lq" href="https://github.com/ckraczkowsky91/rest-api-node-secure" rel="noopener ugc nofollow" target="_blank">源代码</a>。</p><h2 id="6d7f" class="lr ls it bd lt lu lv dn lw lx ly dp lz ld ma mb mc lh md me mf ll mg mh mi mj bi translated"><strong class="ak">为我们的前端设置一个React.js应用程序</strong></h2><p id="23b6" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">添加前端意味着我们现在将有两个应用程序在不同的位置运行，即在同一台机器上但在不同的端口上，或者在相距数百或数千英里的两台不同的机器上。因此，让我们从重组我之前的博客<a class="ae lq" rel="noopener ugc nofollow" target="_blank" href="/securing-a-restful-api-built-with-node-js-f7feefc1efe1">中的项目开始，确保用Node.js </a>构建RESTful API。</p><p id="dcae" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先，我们创建一个名为<code class="fe mp mq mr ms b">backend</code>的新目录，并将我们所有的后端代码迁移到其中。</p><pre class="kj kk kl km gt mt ms mu mv aw mw bi"><span id="bcd6" class="lr ls it ms b gy mx my l mz na">$ mkdir backend</span></pre><p id="2820" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们通过切换到新目录并启动应用程序来确保Node.js应用程序在迁移后仍然工作。</p><pre class="kj kk kl km gt mt ms mu mv aw mw bi"><span id="094c" class="lr ls it ms b gy mx my l mz na">$ cd backend/<br/>$ node ./index.js</span></pre><p id="cf5d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">回到我们项目的根目录，我们创建一个名为<code class="fe mp mq mr ms b">frontend</code>的新目录，在那里我们将添加所有的前端代码。</p><pre class="kj kk kl km gt mt ms mu mv aw mw bi"><span id="829d" class="lr ls it ms b gy mx my l mz na">$ mkdir frontend</span></pre><p id="7fb9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">回想一下我之前的博客<a class="ae lq" rel="noopener ugc nofollow" target="_blank" href="/building-a-restful-api-with-node-js-831bff629e3b">用Node.js构建RESTful API</a>，我们的Node.js应用程序的前端是非常基本的<code class="fe mp mq mr ms b">index.html</code>文件。在本节的后面，我们将增强这个文件，但是现在让我们把它从后端目录移到前端目录。</p><pre class="kj kk kl km gt mt ms mu mv aw mw bi"><span id="8a66" class="lr ls it ms b gy mx my l mz na">$ mv backend/index.html frontend/</span></pre><p id="8ad5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">让我们把它变成一个React.js应用程序！React.js应用程序的基础是<code class="fe mp mq mr ms b">index.html</code>文件和<code class="fe mp mq mr ms b">index.js</code>文件。我们已经有了一个<code class="fe mp mq mr ms b">index.html</code>文件，所以我们只需要创建<code class="fe mp mq mr ms b">index.js</code>文件。</p><pre class="kj kk kl km gt mt ms mu mv aw mw bi"><span id="d806" class="lr ls it ms b gy mx my l mz na">$ cd frontend/<br/>$ touch index.js</span></pre><p id="2d26" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将描述浏览器显示内容的代码从我们的<code class="fe mp mq mr ms b">index.html</code>文件移动到新的<code class="fe mp mq mr ms b">index.js</code>文件中。</p><pre class="kj kk kl km gt mt ms mu mv aw mw bi"><span id="8795" class="lr ls it ms b gy mx my l mz na">import React from ‘react’;<br/>import ReactDOM from ‘react-dom’;</span><span id="09b8" class="lr ls it ms b gy nb my l mz na">ReactDOM.render(<br/>  &lt;div&gt;<br/>    &lt;h1&gt;Hello World!&lt;/h1&gt;<br/>    &lt;h2&gt;Item List&lt;/h2&gt;<br/>    &lt;ul&gt;<br/>      &lt;li&gt;Item 1&lt;/li&gt;<br/>    &lt;/ul&gt;<br/>    &lt;h2&gt;Add Item&lt;/h2&gt;<br/>    &lt;form&gt;<br/>      &lt;label for=”item”&gt;Item: &lt;/label&gt;<br/>      &lt;input type=”text”&gt;&lt;/input&gt;<br/>      &lt;br&gt;&lt;/br&gt;<br/>      &lt;input type=”submit” value=”Submit”&gt;&lt;/input&gt;<br/>    &lt;/form&gt;<br/>    &lt;a href=”/content”&gt;Click here for content!&lt;/a&gt;<br/>  &lt;/div&gt;, document.getElementById(‘root’)<br/>);</span></pre><p id="9563" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">React.js的细节已经超出了这篇博客的范围，所以我将简单总结一下这段代码在做什么。我们加载了<code class="fe mp mq mr ms b">react</code>和<code class="fe mp mq mr ms b">react-dom</code>库，这两个库使我们能够访问JSX(JavaScript的语法扩展)和虚拟文档对象模型(VDOM)，后者是React组件的节点树，将动作与状态相匹配。<code class="fe mp mq mr ms b">ReactDOM.render()</code>创建了这个VDOM，在其中我们使用JSX来渲染一个React元素。我们将旧的<code class="fe mp mq mr ms b">index.html</code>文件中的HTML包装在一个<code class="fe mp mq mr ms b">div</code>元素中，因为React一次只能呈现一个元素。</p><p id="b583" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">正如您所看到的，这个文件加载了两个新的库，<code class="fe mp mq mr ms b">react</code>和<code class="fe mp mq mr ms b">react-dom</code>，所以我们需要安装它们各自的包，我们使用了一个熟悉的工具:节点包管理器(npm)。</p><p id="6b1c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe mp mq mr ms b">$ npm install react react-dom</code></p><p id="1d55" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，我们重构<code class="fe mp mq mr ms b">index.html</code>文件。</p><pre class="kj kk kl km gt mt ms mu mv aw mw bi"><span id="73db" class="lr ls it ms b gy mx my l mz na">&lt;!doctype html&gt;<br/>&lt;html&gt;<br/>  &lt;head&gt;<br/>  &lt;/head&gt;<br/>  &lt;body&gt;<br/>    &lt;div id=”root”&gt;<br/>  &lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="11b9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">回想一下<code class="fe mp mq mr ms b">index.js</code>文件，我们为<code class="fe mp mq mr ms b">ReactDOM.render()</code>提供了第二个参数。这个参数是我们想要呈现React元素的容器。我们将这个容器定义为<code class="fe mp mq mr ms b">document.getElementById(‘root’)</code>，它获取对DOM的引用，并要求它返回带有“root”的<code class="fe mp mq mr ms b">id</code>的元素。在<code class="fe mp mq mr ms b">index.html</code>文件中，我们提供了这个元素。事实上，这是我们将在<code class="fe mp mq mr ms b">index.html</code>文件中提供的唯一元素。所有其他元素都将呈现给该容器元素中的VDOM。这与早期的web开发非常不同，在早期的web开发中，网站是一系列链接在一起的HTML文档，每个文档都是它们自己的DOM对象。当我们构建React.js应用程序时，您会注意到我们在这个DOM对象中操作内容的表示。</p><h2 id="ccae" class="lr ls it bd lt lu lv dn lw lx ly dp lz ld ma mb mc lh md me mf ll mg mh mi mj bi translated"><strong class="ak">向React.js应用程序添加内容</strong></h2><p id="47fe" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">让我们通过向present添加一些内容来使React.js应用程序更有趣。React.js应用程序由React组件组成，这些组件类似于JavaScript函数。它们接受名为<code class="fe mp mq mr ms b">props</code>的各种输入，并返回描述屏幕上应该出现什么的React元素。组件只是JavaScript文件，所以让我们在项目中添加一个。</p><pre class="kj kk kl km gt mt ms mu mv aw mw bi"><span id="b621" class="lr ls it ms b gy mx my l mz na">$ touch PublicPage.js</span></pre><p id="28d6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后我们定义这个组件应该返回什么。</p><pre class="kj kk kl km gt mt ms mu mv aw mw bi"><span id="db54" class="lr ls it ms b gy mx my l mz na">import React from ‘react’;</span><span id="738e" class="lr ls it ms b gy nb my l mz na">export default class PublicPage extends React.Component{<br/>  render(){<br/>    return(<br/>      &lt;div&gt;<br/>        &lt;h1&gt;This is a public page, everyone has access to this page!  &lt;/h1&gt;<br/>      &lt;/div&gt;<br/>    );<br/>  };<br/>};</span></pre><p id="2b87" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">就像我们在<code class="fe mp mq mr ms b">index.js</code>文件中所做的一样，我们加载<code class="fe mp mq mr ms b">react</code>库来获取它的作用域，这样我们就可以访问在我们的组件中使用的JSX语法。然后，我们创建React提供的<code class="fe mp mq mr ms b">Component</code>类的一个实例，并将其命名为<code class="fe mp mq mr ms b">PublicPage</code>，在整个React.js应用程序中，我们将使用这个名称来引用这个组件。<code class="fe mp mq mr ms b">Component</code>类有许多生命周期方法，我们可以用它们来操作组件，从构造到渲染。在我们的<code class="fe mp mq mr ms b">PublicPage</code>组件中，我们使用<code class="fe mp mq mr ms b">render</code>方法来定义将呈现给DOM的内容。正如我们在<code class="fe mp mq mr ms b">index.js</code>文件中所做的，我们将想要呈现的元素包装成一个单独的<code class="fe mp mq mr ms b">div</code>元素，因为React一次只能呈现一个单独的元素。下面是呈现该组件时生成的文档。</p><pre class="kj kk kl km gt mt ms mu mv aw mw bi"><span id="5a3f" class="lr ls it ms b gy mx my l mz na">&lt;!doctype html&gt;<br/>&lt;html&gt;<br/>  &lt;head&gt;<br/>  &lt;/head&gt;<br/>  &lt;body&gt;<br/>    &lt;div id=”root”&gt;<br/>      &lt;div&gt;<br/>      &lt;h1&gt;This is a public page, everyone has access to this page!&lt;/h1&gt;<br/>      &lt;/div&gt;<br/>    &lt;/div&gt;<br/>  &lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="a964" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如您所见，React获取了我们的<code class="fe mp mq mr ms b">PublicPage</code>组件的内容，并将其注入到我们的<code class="fe mp mq mr ms b">index.html</code>文件的主体中。我们添加到React.js应用程序中的每个组件都将以这种方式呈现给浏览器。</p><h2 id="3db0" class="lr ls it bd lt lu lv dn lw lx ly dp lz ld ma mb mc lh md me mf ll mg mh mi mj bi translated"><strong class="ak">使用React路由器为我们的前端实现导航和路由</strong></h2><p id="b626" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">此时，我们的React.js应用程序的内容由一个包含主要内容的<code class="fe mp mq mr ms b">index.js</code>文件和一个包含组件的<code class="fe mp mq mr ms b">PublicPage.js</code>文件组成。眼前的挑战是建立一个机制，在这个内容和我们将来添加的任何内容之间进行转换。这个机制需要提供定义路由、维护路由列表、将路由上可用的内容返回给调用者、定位URL并将其与路由匹配，以及记住用户请求的路由的历史的方法。虽然我们可以自己构建这种机制，但是React路由器库已经可用，并且包含这种功能。该库根据正在构建的应用程序类型提供了几个包，但是我们安装了<code class="fe mp mq mr ms b">react-router-dom</code>包，因为我们正在构建一个web应用程序。</p><pre class="kj kk kl km gt mt ms mu mv aw mw bi"><span id="a156" class="lr ls it ms b gy mx my l mz na">$ npm install react-router-dom</span></pre><p id="a37e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">由于<code class="fe mp mq mr ms b">index.js</code>文件是我们应用程序的入口点，让我们重构这个文件以使用React Router。</p><pre class="kj kk kl km gt mt ms mu mv aw mw bi"><span id="4e6b" class="lr ls it ms b gy mx my l mz na">...<br/>import { BrowserRouter as Router, Switch, Route, Link } from “react-router-dom”;<br/>import PublicPage from ‘./Components/PublicPage’;</span><span id="3c84" class="lr ls it ms b gy nb my l mz na">ReactDOM.render(<br/>  &lt;BrowserRouter&gt;<br/>    &lt;div&gt;<br/>      &lt;ul&gt;<br/>        &lt;li&gt;<br/>          &lt;Link to=’/public’&gt;Public&lt;/Link&gt;<br/>        &lt;/li&gt;<br/>      &lt;/ul&gt;<br/>      &lt;Switch&gt;<br/>        &lt;Route path=’/public’&gt;<br/>          &lt;PublicPage /&gt;<br/>        &lt;/Route&gt;<br/>      &lt;/Switch&gt;<br/>    &lt;/div&gt;<br/>  &lt;/BrowserRouter&gt;, document.getElementById(‘root’)<br/>);</span></pre><p id="e16e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将<code class="fe mp mq mr ms b">div</code>元素包装在从<code class="fe mp mq mr ms b">react-router-dom</code>导入的<code class="fe mp mq mr ms b">BrowserRouter</code>组件中，该组件使用HTML5历史API来保持我们的UI与URL同步。在<code class="fe mp mq mr ms b">BrowserRouter</code>组件中，我们使用React Router提供的<code class="fe mp mq mr ms b">Link</code>组件来定义一个超链接，单击该超链接会导致我们的<code class="fe mp mq mr ms b">PublicPage</code>组件。<code class="fe mp mq mr ms b">Link</code>组件提供了大量内置的<code class="fe mp mq mr ms b">props</code>；关键的一个是<code class="fe mp mq mr ms b">to</code>，我们向它传递一个表示路径名的字符串，这个路径名是<code class="fe mp mq mr ms b">Link</code>应该期望找到的内容。</p><p id="a22d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当超链接被点击时，URL被请求，并且是<code class="fe mp mq mr ms b">Switch</code>组件告诉React Router根据路径名呈现哪个<code class="fe mp mq mr ms b">Route</code>组件。然后，<code class="fe mp mq mr ms b">Route</code>组件负责呈现适当的组件。在我们的例子中，我们将<code class="fe mp mq mr ms b">PublicPage</code>组件放在路径名“/public”处，这样任何对http://localhost:3000/public的请求都应该返回该组件。</p><h2 id="51e5" class="lr ls it bd lt lu lv dn lw lx ly dp lz ld ma mb mc lh md me mf ll mg mh mi mj bi translated"><strong class="ak">用React.js和axios构建登录组件</strong></h2><p id="9cfe" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">太好了！我们的React.js应用程序现在有了一些要显示的内容和在这些内容中导航的方法。但是目前我们的内容是任何人都可以访问的。正如我们在我之前的博客<a class="ae lq" rel="noopener ugc nofollow" target="_blank" href="/securing-a-restful-api-built-with-node-js-f7feefc1efe1">中讨论的，保护用Node.js </a>构建的RESTful API，有些情况下我们希望将对某些内容的访问限制在某个特定的个人组。在那篇博客中，我们为RESTful API构建了一些中间件和端点来执行这个访问控制逻辑。让我们为React.js应用程序的用户添加一个前端。我们首先构建一个允许最终用户登录的组件。</p><pre class="kj kk kl km gt mt ms mu mv aw mw bi"><span id="1eaa" class="lr ls it ms b gy mx my l mz na">$ touch LoginPage.js</span></pre><p id="6d70" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">该组件将提供一个接口，与我以前博客中的“/auth/login”端点进行通信。该接口将是一个反应组件。现在我们来定义这个组件。</p><pre class="kj kk kl km gt mt ms mu mv aw mw bi"><span id="c66c" class="lr ls it ms b gy mx my l mz na">import React, { useState } from ‘react’;<br/>import axios from ‘axios’;<br/>import {useHistory, useLocation} from ‘react-router-dom’;</span><span id="9c0e" class="lr ls it ms b gy nb my l mz na">export const LoginPage = (props) =&gt; {<br/>  const [email, setEmail] = useState(‘’);<br/>  const [password, setPassword] = useState(‘’);<br/>  let url = props.baseUrl + ‘/auth/login’;<br/>  let location = useLocation();<br/>  let history = useHistory();<br/>  let {from} = location.state || { from: { pathname: “/” } };</span><span id="6c69" class="lr ls it ms b gy nb my l mz na">  function handleSubmit(event){<br/>    event.preventDefault();<br/>    axios.post(url, {email, password})<br/>      .then((res) =&gt; {<br/>        document.cookie = ‘my-token=’+res.data.token+’; max-age=60;’;<br/>        history.push(from);})<br/>      .catch((error) =&gt; {<br/>        console.log(error);});<br/>  };<br/>  function handleOnChange(event){<br/>    if (event.target.name === ‘email’){<br/>      setEmail(event.target.value);<br/>    };<br/>    if (event.target.name === ‘password’){<br/>      setPassword(event.target.value);<br/>    };<br/>  };<br/>  return(<br/>    &lt;form onSubmit={handleSubmit}&gt;<br/>      &lt;h1&gt;Login to your account:&lt;/h1&gt;<br/>      &lt;label&gt;Email: &lt;/label&gt;<br/>      &lt;input onChange={handleOnChange} name=”email” placeholder=”freddie.mercury@gmail.com” size=”35" value={email}/&gt;<br/>      &lt;br/&gt;<br/>      &lt;label&gt;Password: &lt;/label&gt;<br/>      &lt;input onChange={handleOnChange} name=”password” placeholder=”queen_rox” size=”35" value={password}/&gt;<br/>      &lt;br/&gt;<br/>      &lt;input type=’submit’ value=’Submit’/&gt;<br/>    &lt;/form&gt;<br/>  );<br/>};</span></pre><p id="23b7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">从<code class="fe mp mq mr ms b">LoginPage</code>组件的定义中，您可以看出这个组件不同于我们在上面的<strong class="kw iu">向React.js应用程序</strong>添加内容一节中定义的<code class="fe mp mq mr ms b">PublicPage</code>组件。<code class="fe mp mq mr ms b">PublicPage</code>组件是“类组件”的一个例子，而<code class="fe mp mq mr ms b">LoginPage</code>组件是“功能组件”的一个例子。</p><p id="c40c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">虽然类组件是有状态的，并且React提供了许多方便的生命周期方法，但是函数组件只是一个JavaScript函数，这使得它是无状态的。从16.8版本开始，我们可以并且确实在组件定义的第一行中使<code class="fe mp mq mr ms b">LoginPage</code>组件有状态，在那里我们调用一个新的附加组件React，即<code class="fe mp mq mr ms b">useState</code>钩子。“挂钩”是一个特殊的函数，它让我们挂钩到React特性，例如,<code class="fe mp mq mr ms b">useState</code>让我们挂钩到state特性，这在以前是类组件独有的。</p><blockquote class="nc nd ne"><p id="94fd" class="ku kv nf kw b kx ky ju kz la lb jx lc ng le lf lg nh li lj lk ni lm ln lo lp im bi translated"><strong class="kw iu">注意:</strong>JavaScript语法中在赋值左边使用括号被称为“数组析构”。它为函数结果的分配提供了一个更简洁的语法，即赋值右边的函数的第一个结果填充左边数组的第一个变量，依此类推。</p><p id="f7b6" class="ku kv nf kw b kx ky ju kz la lb jx lc ng le lf lg nh li lj lk ni lm ln lo lp im bi translated">所以我们的准则是:</p><p id="de6c" class="ku kv nf kw b kx ky ju kz la lb jx lc ng le lf lg nh li lj lk ni lm ln lo lp im bi translated"><code class="fe mp mq mr ms b">const [email, setEmail] = useState(‘’);</code></p><p id="56fa" class="ku kv nf kw b kx ky ju kz la lb jx lc ng le lf lg nh li lj lk ni lm ln lo lp im bi translated">相当于以下代码:</p><p id="bc59" class="ku kv nf kw b kx ky ju kz la lb jx lc ng le lf lg nh li lj lk ni lm ln lo lp im bi translated"><code class="fe mp mq mr ms b">const stateArray = useState(‘state’);</code></p><p id="3f28" class="ku kv nf kw b kx ky ju kz la lb jx lc ng le lf lg nh li lj lk ni lm ln lo lp im bi translated"><code class="fe mp mq mr ms b">const email = stateArray[0];</code></p><p id="f9cd" class="ku kv nf kw b kx ky ju kz la lb jx lc ng le lf lg nh li lj lk ni lm ln lo lp im bi translated"><code class="fe mp mq mr ms b">const setEmail = stateArray[1];</code></p><p id="a87a" class="ku kv nf kw b kx ky ju kz la lb jx lc ng le lf lg nh li lj lk ni lm ln lo lp im bi translated">因为<code class="fe mp mq mr ms b">useState</code>钩子返回两个项目的数组，组件状态的当前值和我们用来更新它的函数，我们的数组只需要两个变量。这两个变量实现了与我们在类组件中使用的<code class="fe mp mq mr ms b">this.state.* </code>和<code class="fe mp mq mr ms b">this.setState()</code>相同的含义。</p></blockquote><p id="e009" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们在<code class="fe mp mq mr ms b">handleOnChange</code>函数中使用用<code class="fe mp mq mr ms b">useState</code>钩子创建的四个变量。该函数获取用户输入到表单的<code class="fe mp mq mr ms b">email</code>和<code class="fe mp mq mr ms b">password</code>字段中的输入，并将其添加到组件的状态中。这为我们提供了一种存储这些值的方法，这样我们就可以通过我们的<code class="fe mp mq mr ms b">handleSubmit</code>函数将它们提交给后端的“/auth/login”端点。</p><p id="cf1c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们的<code class="fe mp mq mr ms b">LoginPage</code>组件的<code class="fe mp mq mr ms b">handleSubmit</code>函数为我们的应用程序完成了繁重的工作。首先，它从组件的状态中获取电子邮件和密码值，并在POST请求中将它们发送到我们的Node.js后端。不幸的是，React.js应用程序不能本地发送HTTP请求，因此我们需要一种方法来实现这一点。我们可以选择使用大多数浏览器提供的<code class="fe mp mq mr ms b">XMLHttpRequest</code>对象自己构建这个功能，但是我们将使用axios库。axios库使我们能够发送更复杂的请求，并且更擅长使用承诺而不是使用事件和回调进行异步通信。要使用axios库，我们首先要安装它的软件包。</p><pre class="kj kk kl km gt mt ms mu mv aw mw bi"><span id="fda6" class="lr ls it ms b gy mx my l mz na">$ npm install axios</span></pre><p id="d6d9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们现在可以访问axios提供的用于发送POST请求的<code class="fe mp mq mr ms b">post</code>方法。如果请求无效，我们的<code class="fe mp mq mr ms b">handleSubmit</code>函数会捕捉并返回错误。但是，如果请求成功，它将获取包含JSON Web令牌的响应，该令牌验证用户是他们所声称的那个人，通知浏览器创建一个HTTP cookie(也称为web cookie或cookie)，并将该令牌存储在该cookie中。</p><h2 id="8df4" class="lr ls it bd lt lu lv dn lw lx ly dp lz ld ma mb mc lh md me mf ll mg mh mi mj bi translated"><strong class="ak">用JavaScript设置HTTP cookies在浏览器中存储数据</strong></h2><p id="c69f" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">在上面的<strong class="kw iu">使用React.js和axios构建登录组件</strong>小节中，我们将来自后端的响应存储在一个HTTP cookie中。但是饼干到底是什么？从概念上讲，cookies使我们的web开发人员能够通过模拟跨HTTP请求的用户意识，给无状态HTTP协议一种有状态的错觉。实际上，cookie是存储在浏览器中的一小段数据(大多数浏览器支持最大4096字节的cookie ),然后在随后的请求中发送到同一个服务器。默认情况下，cookie存在于整个会话中，仅在浏览器关闭时过期。为了控制cookie的生命周期，我们设置了一个持续时间，在此之后，cookie将从浏览器的存储中删除。可以通过使用<code class="fe mp mq mr ms b">Set-Cookie</code> HTTP头从服务器接收Cookies或者通过使用<code class="fe mp mq mr ms b">document.cookie</code>属性用JavaScript应用程序设置Cookies来创建Cookies。此属性接受单个字符串值，该值应采用“&lt;cookie-name&gt;=&lt;cookie-value&gt;的形式；&lt;指令名&gt; = &lt;指令值&gt;。例如，在我们的<code class="fe mp mq mr ms b">LoginPage</code>组件的<code class="fe mp mq mr ms b">handleSubmit</code>函数中，我们创建了一个名为<code class="fe mp mq mr ms b">my-token</code>的cookie，并从后端返回的响应中为它赋予JSON Web令牌的值。在这个cookie中，我们还将<code class="fe mp mq mr ms b">Max-Age</code>指令设置为60，这意味着我们的cookie的生命周期是60秒。</p><h2 id="b640" class="lr ls it bd lt lu lv dn lw lx ly dp lz ld ma mb mc lh md me mf ll mg mh mi mj bi translated"><strong class="ak">使用React路由器保护我们的路由</strong></h2><p id="e822" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">在上面的<strong class="kw iu">使用React.js和axios构建登录组件</strong>小节中，我们构建了一种机制来获取JSON Web令牌，该令牌是我们向后端的'/auth/login '端点发出请求的结果，并将令牌存储在浏览器中。在本节中，我们将使用该令牌授权用户访问React.js应用程序中的不同路由和组件。我们使用React路由器库提供的组件来实现这一点。我们从更新我们的<code class="fe mp mq mr ms b">index.js</code>文件开始，我们已经初始化了一个这样的组件，即<code class="fe mp mq mr ms b">BrowserRouter</code>组件，它是我们所有路线的父组件。</p><pre class="kj kk kl km gt mt ms mu mv aw mw bi"><span id="d0ca" class="lr ls it ms b gy mx my l mz na">...<br/>const BASE_URL = ‘http://localhost:4000';<br/>...<br/>ReactDOM.render(<br/>  &lt;BrowserRouter&gt;<br/>    &lt;div&gt;<br/>      &lt;ul&gt;<br/>        &lt;li&gt;<br/>          &lt;Link to=’/public’&gt;Public&lt;/Link&gt;<br/>        &lt;/li&gt;<br/>        &lt;li&gt;<br/>          &lt;Link to=’/private’&gt;Private&lt;/Link&gt;<br/>        &lt;/li&gt;<br/>      &lt;/ul&gt;<br/>      &lt;Switch&gt;<br/>        &lt;Route path=’/public’&gt;<br/>          &lt;PublicPage /&gt;<br/>        &lt;/Route&gt;<br/>        <strong class="ms iu">&lt;Route path=’/login’&gt;<br/>          &lt;LoginPage baseUrl={BASE_URL}/&gt;<br/>        &lt;/Route&gt;<br/>        &lt;PrivateRoute path=’/private’&gt;<br/>          &lt;PrivatePage /&gt;<br/>        &lt;/PrivateRoute&gt;<br/>      </strong>&lt;/Switch&gt;<br/>    &lt;/div&gt;<br/>  &lt;/BrowserRouter&gt;<br/>...</span></pre><p id="2bc9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在<code class="fe mp mq mr ms b">Switch</code>组件中，我们添加了一个新的<code class="fe mp mq mr ms b">Route</code>组件，当请求其路线时，它将显示我们的<code class="fe mp mq mr ms b">LoginPage</code>组件。接下来，我们添加一个新的定制<code class="fe mp mq mr ms b">PrivateRoute</code>组件，并定义它的路由。这是一个高阶组件(HOC ),我们将重用它来控制我们所有的私有内容。现在让我们来定义这个新组件。</p><pre class="kj kk kl km gt mt ms mu mv aw mw bi"><span id="1ea3" class="lr ls it ms b gy mx my l mz na">$ touch PrivateRoute.js</span></pre><p id="d414" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后我们定义它。</p><pre class="kj kk kl km gt mt ms mu mv aw mw bi"><span id="6784" class="lr ls it ms b gy mx my l mz na">import React from ‘react’;<br/>import { Route, Redirect } from ‘react-router-dom’;<br/>import isAuthenticated from ‘./isAuthenticated’;</span><span id="2c46" class="lr ls it ms b gy nb my l mz na">function PrivateRoute(props){<br/>  return(<br/>    &lt;Route render={() =&gt; {<br/>      if(isAuthenticated()) {<br/>        return(props.children);<br/>      } else {<br/>        return(<br/>          &lt;Redirect to={{pathname: ‘/login’, state: {from: props.location}}}/&gt;<br/>        );<br/>      }<br/>    }}/&gt;<br/>  );<br/>};</span><span id="c5a0" class="lr ls it ms b gy nb my l mz na">export default PrivateRoute;</span></pre><p id="4634" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">就像上面的<strong class="kw iu">用React.js和axios </strong>构建登录组件中的<code class="fe mp mq mr ms b">LoginPage</code>组件一样，我们的<code class="fe mp mq mr ms b">PrivateRoute</code>组件也将是一个只以<code class="fe mp mq mr ms b">props</code>作为参数的‘函数组件’。我们的<code class="fe mp mq mr ms b">PrivateRoute</code>组件除了是函数组件，还是高阶组件。在React.js术语中，高阶组件是一个将组件作为参数并返回新组件的函数，这正是我们的<code class="fe mp mq mr ms b">PrivateRoute</code>组件正在做的事情。在上面的<strong class="kw iu">使用React Router </strong>实现导航和路由小节中，我们只是将想要呈现的组件嵌套在了<code class="fe mp mq mr ms b">Route</code>组件中。然而，<code class="fe mp mq mr ms b">Route</code>组件也有一个名为<code class="fe mp mq mr ms b">render</code>的属性，它接受一个函数作为参数。我们使用这个函数来执行逻辑，以确定要呈现的组件:如果用户经过身份验证，则是包含我们私有内容的组件；如果用户未经身份验证，则是我们的登录组件。我们可以通过<code class="fe mp mq mr ms b">props</code>参数访问包含私有内容的组件。</p><p id="08df" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在<code class="fe mp mq mr ms b">props</code>中有一个名为<code class="fe mp mq mr ms b">children</code>的属性，它包含任何嵌套在组件中的React元素。回想一下本节前面的内容，我们在<code class="fe mp mq mr ms b">PrivateRoute</code>组件中嵌套了一个名为<code class="fe mp mq mr ms b">PrivatePage</code>的组件。</p><pre class="kj kk kl km gt mt ms mu mv aw mw bi"><span id="7507" class="lr ls it ms b gy mx my l mz na">...<br/>&lt;PrivateRoute path=’/private’&gt;<br/>  &lt;PrivatePage /&gt;<br/>&lt;/PrivateRoute&gt;<br/>...</span></pre><p id="5e55" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，在等待我们将在本节稍后定义的<code class="fe mp mq mr ms b">isAuthenticated</code>函数的结果时，我们在render中的逻辑告诉我们的高阶组件返回我们的<code class="fe mp mq mr ms b">PrivatePage</code>组件或<code class="fe mp mq mr ms b">Redirect</code>组件。</p><p id="d81a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe mp mq mr ms b">Redirect</code>组件由React路由器库提供，处理更复杂的导航。我们可以将一个对象传递给该组件的<code class="fe mp mq mr ms b">to</code>属性，以定义附加信息，如重定向到的路径名、我们希望作为参数包含在生成的URL中的任何查询字符串，以及从重定向组件传递到路径末端组件的状态。我们为<code class="fe mp mq mr ms b">pathname</code>属性提供了我们的<code class="fe mp mq mr ms b">LoginPage</code>组件的路径，我们在本节前面将其定义为“/login”。</p><p id="e258" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，我们提供一个对象的<code class="fe mp mq mr ms b">state</code>属性，其中我们定义一个<code class="fe mp mq mr ms b">from</code>属性作为指向<code class="fe mp mq mr ms b">props.location</code>对象的指针。除了一个<code class="fe mp mq mr ms b">children</code>属性，<code class="fe mp mq mr ms b">props</code>还有一个名为<code class="fe mp mq mr ms b">location</code>的属性，它是一个包含用户当前所在URL信息的对象。我们将该信息传递给<code class="fe mp mq mr ms b">Redirect</code>组件，后者将通过<code class="fe mp mq mr ms b">state</code>属性将其传递给路径末端的组件。在这种情况下，该组件是<code class="fe mp mq mr ms b">LoginPage</code>组件。</p><p id="82d0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">回想一下上面的<strong class="kw iu">用React.js和axios </strong>构建登录组件中的代码，我们在这里定义了<code class="fe mp mq mr ms b">LoginPage</code>组件。</p><pre class="kj kk kl km gt mt ms mu mv aw mw bi"><span id="25d9" class="lr ls it ms b gy mx my l mz na">...<br/>let location = useLocation();<br/>let history = useHistory();<br/>let {from} = location.state || { from: { pathname: “/” } };<br/>...<br/>history.push(from);<br/>...</span></pre><p id="0518" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这段代码决定了用户登录后从我们的<code class="fe mp mq mr ms b">LoginPage</code>组件被定向到哪里。为此，我们使用React Router提供的<code class="fe mp mq mr ms b">useLocation</code>钩子和<code class="fe mp mq mr ms b">useHistory</code>钩子。调用<code class="fe mp mq mr ms b">useLocation</code>钩子返回一个对象，该对象具有一个表示用户当前所在路径的<code class="fe mp mq mr ms b">pathname</code>属性和一个表示用户在当前URL之前所在路径的<code class="fe mp mq mr ms b">state</code>属性。</p><blockquote class="nc nd ne"><p id="cc3d" class="ku kv nf kw b kx ky ju kz la lb jx lc ng le lf lg nh li lj lk ni lm ln lo lp im bi translated"><strong class="kw iu">注意:</strong>JavaScript语法中在表达式左侧使用大括号被称为‘对象析构’。它为在对象内分配属性提供了更简洁的语法，即赋值左边大括号内的变量将等于等式右边同名对象的属性值。</p><p id="d98c" class="ku kv nf kw b kx ky ju kz la lb jx lc ng le lf lg nh li lj lk ni lm ln lo lp im bi translated">所以我们的准则是:</p><p id="ff1b" class="ku kv nf kw b kx ky ju kz la lb jx lc ng le lf lg nh li lj lk ni lm ln lo lp im bi translated"><code class="fe mp mq mr ms b">let {from} = location.state || { from: { pathname: “/” } };</code></p><p id="1d80" class="ku kv nf kw b kx ky ju kz la lb jx lc ng le lf lg nh li lj lk ni lm ln lo lp im bi translated">相当于以下代码:</p><p id="9288" class="ku kv nf kw b kx ky ju kz la lb jx lc ng le lf lg nh li lj lk ni lm ln lo lp im bi translated"><code class="fe mp mq mr ms b">let from = location.state.from || { from: { pathname: “/” } };</code></p><p id="cd05" class="ku kv nf kw b kx ky ju kz la lb jx lc ng le lf lg nh li lj lk ni lm ln lo lp im bi translated">这两段代码都会将变量间接赋给location对象的state属性中的值(如果该值为true ),或者直接赋给对象文字。</p></blockquote><p id="7b76" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以我们知道我们想把用户送到哪里，但是我们仍然需要一种方法把他们送到那里。我们用<code class="fe mp mq mr ms b">useHistory</code>钩子实现了这一点，当它被调用时，返回一个我们可以用来导航的<code class="fe mp mq mr ms b">history</code>对象。<code class="fe mp mq mr ms b">history</code>对象来自我们安装React路由器包时安装的历史包。这个包提供了许多在JavaScript中管理会话历史的属性和方法，包括<code class="fe mp mq mr ms b">push</code>方法。该方法获取一个表示新组件路径的字符串，将其作为一个新条目推入“历史堆栈”，然后加载新推入的URL。</p><blockquote class="nc nd ne"><p id="d04c" class="ku kv nf kw b kx ky ju kz la lb jx lc ng le lf lg nh li lj lk ni lm ln lo lp im bi translated"><strong class="kw iu">注意:</strong>历史堆栈是URL的堆栈。回想一下计算机科学时代，堆栈是一种数据结构，其中堆栈顶部的第一个数据是最后添加到堆栈中的数据。在历史堆栈的情况下，我们能够使用历史对象将新的URL推到堆栈的顶部，并弹出从堆栈顶部添加的最后一个URL。堆栈数据结构的这种实现使我们能够快速轻松地在web应用程序中构建导航。</p></blockquote><p id="7bf5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">通过结合React Router提供的<code class="fe mp mq mr ms b">useLocation</code>钩子和<code class="fe mp mq mr ms b">useHistory</code>钩子，我们现在知道用户从哪条路径到达了<code class="fe mp mq mr ms b">LoginPage</code>组件，并且一旦用户登录，就能够相应地指引用户。在这个场景中，<code class="fe mp mq mr ms b">Redirect</code>组件将为LoginPage组件填充<code class="fe mp mq mr ms b">state</code>属性，这样当我们的<code class="fe mp mq mr ms b">LoginPage</code>组件返回的登录表单被提交时，用户将被重定向到他们试图访问的路径，即“/private”路径。</p><p id="d09e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">那么我们的<code class="fe mp mq mr ms b">PrivateRoute</code>组件如何知道将用户指引到哪里呢？这是前面提到的<code class="fe mp mq mr ms b">isAuthenticated</code>函数的工作，我们现在将对其进行定义。首先，让我们创建一个文件，我们将从这个文件中导入这个函数。</p><pre class="kj kk kl km gt mt ms mu mv aw mw bi"><span id="5798" class="lr ls it ms b gy mx my l mz na">$ touch isAuthenticated.js</span></pre><p id="4136" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe mp mq mr ms b">isAuthenticated</code>功能确定用户是否有权访问他们请求的内容。</p><pre class="kj kk kl km gt mt ms mu mv aw mw bi"><span id="054e" class="lr ls it ms b gy mx my l mz na">import getCookie from ‘./getCookie’;</span><span id="1e9e" class="lr ls it ms b gy nb my l mz na">function isAuthenticated() {<br/>  var checkCookie = getCookie(‘my-token’);<br/>  if(checkCookie != null){<br/>    return true;<br/>  } else {<br/>    return false;<br/>  };<br/>};</span><span id="cf9d" class="lr ls it ms b gy nb my l mz na">export default isAuthenticated;</span></pre><p id="8d27" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们的<code class="fe mp mq mr ms b">isAuthenticated</code>函数非常简单。它使用一个名为<code class="fe mp mq mr ms b">getCookie</code>的函数扫描当前存储在浏览器中的HTTP cookies，寻找一个名为<code class="fe mp mq mr ms b">my-token</code>的cookie，我们将在下一节中定义这个函数。根据<code class="fe mp mq mr ms b">getCookie</code>函数的结果，我们的<code class="fe mp mq mr ms b">isAuthenticated</code>函数将返回<code class="fe mp mq mr ms b">true</code>或<code class="fe mp mq mr ms b">false</code>，我们的<code class="fe mp mq mr ms b">PrivateRoute</code>组件将选择并使用它们来确定返回哪个组件。</p><h2 id="342d" class="lr ls it bd lt lu lv dn lw lx ly dp lz ld ma mb mc lh md me mf ll mg mh mi mj bi translated"><strong class="ak">通过JavaScript获取HTTP cookies从浏览器中检索数据</strong></h2><p id="f930" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">在上面的<strong class="kw iu">使用React Router </strong>保护我们的路由中定义的<code class="fe mp mq mr ms b">isAuthenticated</code>函数依赖于<code class="fe mp mq mr ms b">getCookie</code>函数。在本节中，我们将定义该函数。首先，让我们创建一个文件，我们将从这个文件中导入这个函数。</p><pre class="kj kk kl km gt mt ms mu mv aw mw bi"><span id="a850" class="lr ls it ms b gy mx my l mz na">$ touch getCookie.js</span></pre><p id="dde5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe mp mq mr ms b">getCookie</code>函数扫描存储在浏览器中的HTTP cookies，以找到一个特定的名称。如果该cookie存在，该函数将返回与该名称的cookie相关联的值。如果该cookie不存在，该函数将返回一个空值。</p><pre class="kj kk kl km gt mt ms mu mv aw mw bi"><span id="bdcc" class="lr ls it ms b gy mx my l mz na">function getCookie(name){<br/>  var cookieArray = document.cookie.split(‘;’);<br/>  for(var i=0; i &lt; cookieArray.length; i++){<br/>    var cookieKeyValuePair = cookieArray[i].split(‘=’);<br/>    if(name === cookieKeyValuePair[0].trim()) {<br/>      return(cookieKeyValuePair[1]);<br/>    };<br/>  };<br/>  return(null);<br/>};</span><span id="9949" class="lr ls it ms b gy nb my l mz na">export default getCookie;</span></pre><p id="a8a8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">回想一下上面的<strong class="kw iu">通过用JavaScript设置HTTP cookies在浏览器中存储数据</strong>部分，JavaScript提供了<code class="fe mp mq mr ms b">document.cookie</code>属性。以前，我们使用这个属性来设置cookie，但是它也可以用于从浏览器获取cookie。这些cookie都作为一个单独的字符串返回，遵循模式'&lt;cookie-name&gt;=&lt;cookie-value&gt;；'我们可以编写一个正则表达式来解析这个字符串以找到我们的cookie，但幸运的是JavaScript提供了一个更简单的方法，即<code class="fe mp mq mr ms b">split</code>方法，根据提供的分隔符将一个字符串分割成一个子字符串数组，并返回该数组。我们将对该数组的引用存储为一个新的<code class="fe mp mq mr ms b">cookieArray</code>变量。</p><p id="2b37" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在的问题是遍历这个数组，找到我们要寻找的元素。为此，我们将<code class="fe mp mq mr ms b">cookieArray</code>分割成自己的数组，并将对新数组的引用存储为新的<code class="fe mp mq mr ms b">cookieKeyValuePair</code>变量。这个数组只有两个元素，由索引为0的'&lt; cookie-name &gt;和索引为1的'&lt; cookie-value &gt;'组成。然后，将索引为0的值与作为参数提供给<code class="fe mp mq mr ms b">getCookie</code>的名称进行比较，当发现匹配时，返回索引为1的值。观察<code class="fe mp mq mr ms b">trim</code>方法的使用，它也是由JavaScript提供的，我强烈推荐使用它，因为在“；”之间有隐藏的空格cookies之间的分隔符，必须对其进行修整才能找到匹配项。</p><blockquote class="nc nd ne"><p id="7492" class="ku kv nf kw b kx ky ju kz la lb jx lc ng le lf lg nh li lj lk ni lm ln lo lp im bi translated"><strong class="kw iu">注意:</strong>对于那些对‘大O符号’感兴趣的人来说，我用于这个函数的算法的运行时间是O(n)。这使得它成为一种“线性时间算法”，在最坏的情况下，它将随着数组中项目的数量而增长。</p></blockquote><p id="5b47" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了将所有这些放到React.js应用程序的上下文中，我们的<code class="fe mp mq mr ms b">isAuthenticated</code>函数调用我们的<code class="fe mp mq mr ms b">getCookie</code>函数并传递给它‘my-token ’,这是我们在上面的<strong class="kw iu">使用React.js和axios </strong>构建登录组件一节中命名的cookie。<code class="fe mp mq mr ms b">getCookie</code>函数检查这个cookie是否存在，并返回cookie的值，这是在我们的<code class="fe mp mq mr ms b">LoginPage</code>组件中设置的JSON Web令牌的值。我们的<code class="fe mp mq mr ms b">isAuthenticated</code>函数检查这个值，返回<code class="fe mp mq mr ms b">true</code>，用户被授权访问由我们的<code class="fe mp mq mr ms b">PrivateRoute</code>高阶组件保护的私有内容。</p><p id="a667" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了确保额外的路由，我们可以简单地将每个路径添加到<code class="fe mp mq mr ms b">Switch</code>作为新的<code class="fe mp mq mr ms b">PrivateRoute</code>高阶组件。</p><pre class="kj kk kl km gt mt ms mu mv aw mw bi"><span id="cb6a" class="lr ls it ms b gy mx my l mz na">...<br/>&lt;Switch&gt;<br/>...<br/>  &lt;PrivateRoute path=’/private’&gt;<br/>    &lt;PrivatePage /&gt;<br/>  &lt;/PrivateRoute&gt;<br/>  &lt;PrivateRoute path=’/superprivate’&gt;<br/>    &lt;SuperPrivatePage /&gt;<br/>  &lt;/PrivateRoute&gt;<br/>...<br/>&lt;/Switch&gt;<br/>...</span></pre><p id="9b48" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果用户没有登录，对这些路径的任何请求也会将用户重定向到我们的<code class="fe mp mq mr ms b">LoginPage</code>组件。</p><h2 id="8e6a" class="lr ls it bd lt lu lv dn lw lx ly dp lz ld ma mb mc lh md me mf ll mg mh mi mj bi translated"><strong class="ak">保护后端请求的安全</strong></h2><p id="fbf7" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">在我之前的博客<a class="ae lq" rel="noopener ugc nofollow" target="_blank" href="/securing-a-restful-api-built-with-node-js-f7feefc1efe1">中，保护用Node.js构建的RESTful API</a>，对应用程序内容的访问控制全部由我们的Node.js应用程序在后端处理。在这篇博客中，我们将这一职责转移到了前端的React.js应用程序上。我们使用React Router为提供我们的前端内容的组件定义路由，并通过将某些路由限制为授权用户来保护这些路由之间的导航和对这些组件的访问。这很好，但是我们仍然希望对Node.js后端应用程序公开的各种端点应用一些访问控制，以便只有拥有有效JSON Web令牌的用户才能成功提交请求。我们将通过向我们在<code class="fe mp mq mr ms b">PrivatePage</code>组件中调用的“/items”端点添加访问控制来做到这一点。现在让我们来定义这个新组件。</p><pre class="kj kk kl km gt mt ms mu mv aw mw bi"><span id="78e5" class="lr ls it ms b gy mx my l mz na">$ touch PrivatePage.js</span></pre><p id="d152" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后我们定义它。</p><pre class="kj kk kl km gt mt ms mu mv aw mw bi"><span id="1292" class="lr ls it ms b gy mx my l mz na">import React from ‘react’;<br/>import axios from ‘axios’;<br/>import getCookie from ‘./getCookie’;</span><span id="8407" class="lr ls it ms b gy nb my l mz na">export default class PrivatePage extends React.Component{<br/>  constructor(props){<br/>    super(props);<br/>    this.state = {<br/>      items: []<br/>    };<br/>  };<br/>  updateState = () =&gt; {<br/>    axios.get(‘http://localhost:4000/items')<br/>      .then((res) =&gt; {<br/>        this.setState({items: res.data});})<br/>      .catch((error) =&gt; {<br/>        console.log(error);<br/>    });<br/>  };<br/>  componentDidMount(){<br/>    this.updateState();<br/>  };<br/>  render(){<br/>    return(<br/>      &lt;div&gt;<br/>        &lt;h1&gt;You have successfully logged in. Now, you have access to this page!&lt;/h1&gt;<br/>        &lt;h2&gt;List of items:&lt;/h2&gt;<br/>        &lt;ul&gt;{this.state.items.map((item) =&gt; (<br/>          &lt;li key={item._id}&gt;{item.name}&lt;/li&gt;<br/>        ))}&lt;/ul&gt;<br/>      &lt;/div&gt;<br/>    );<br/>  };<br/>};</span></pre><p id="9131" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">该组件向我们在Node.js应用程序中定义的'/items '端点发送GET请求，以便获取数据来填充返回列表中的元素。来自Node.js应用程序的响应取决于我们的路由。</p><pre class="kj kk kl km gt mt ms mu mv aw mw bi"><span id="bf7d" class="lr ls it ms b gy mx my l mz na">...<br/>app.route(‘/items’)</span><span id="5d6c" class="lr ls it ms b gy nb my l mz na">.post(addItem)</span><span id="9dfb" class="lr ls it ms b gy nb my l mz na">.get(getItems);<br/>...</span></pre><p id="0686" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">按照这种方式编码，我们的后端将用状态码<code class="fe mp mq mr ms b">200 OK</code>和对该路由的任何请求的请求数据来响应。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nj"><img src="../Images/9a8f905285ec184763d4206455c86c34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hfhNj6dabDsgluLr"/></div></div></figure><p id="9fe9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">但这意味着任何可以发送HTTP请求的客户端都可以向我们的“/items”端点发送GET请求并接收这些数据。这就是为什么在<a class="ae lq" rel="noopener ugc nofollow" target="_blank" href="/building-a-restful-api-with-node-js-831bff629e3b">用Node.js </a>构建RESTful API的过程中，我们添加了<code class="fe mp mq mr ms b">verifyToken</code>中间件功能。</p><pre class="kj kk kl km gt mt ms mu mv aw mw bi"><span id="d450" class="lr ls it ms b gy mx my l mz na">...<br/>app.route(‘/items’)</span><span id="e052" class="lr ls it ms b gy nb my l mz na">.post(addItem)</span><span id="651b" class="lr ls it ms b gy nb my l mz na"><strong class="ms iu">.get(verifyToken, getItems);<br/>...</strong></span></pre><p id="5b5d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果我们的React.js应用程序没有任何变化，我们的后端现在会用一个状态代码<code class="fe mp mq mr ms b">403 Forbidden</code>和一个错误消息来响应我们对这个路由的请求。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/79fd01decec15c752f4faf3af27e934a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JEGzOzdMfMynvkTP"/></div></div></figure><p id="4cd8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">好消息是，这意味着我们的<code class="fe mp mq mr ms b">verifyToken</code>中间件功能正在工作，我们的后端现在期望提供一个JSON Web令牌。为了让它再次工作，我们需要将令牌添加到前端的代码段中，在那里我们向'/items '端点发送get请求。这个代码存在于我们的<code class="fe mp mq mr ms b">updateState</code>函数中。</p><pre class="kj kk kl km gt mt ms mu mv aw mw bi"><span id="70ba" class="lr ls it ms b gy mx my l mz na">...<br/>updateState = () =&gt; {<br/>  <strong class="ms iu">let token = getCookie(‘my-token’);<br/>  </strong>axios.get(‘http://localhost:4000/items', <strong class="ms iu">{headers: {‘x-json-web-token’: token}}</strong>)<br/>    .then((res) =&gt; {<br/>      this.setState({items: res.data});})<br/>    .catch((error) =&gt; {<br/>      console.log(error);<br/>    });<br/>};<br/>...</span></pre><p id="5890" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们使用上面的<strong class="kw iu">中定义的<code class="fe mp mq mr ms b">getCookie</code>函数，通过使用JavaScript </strong>获取HTTP cookies从浏览器中检索数据，以检索用户登录时存储在浏览器cookie中的令牌。然后，我们向axios库提供的<code class="fe mp mq mr ms b">post</code>方法传递一个新参数，该方法使用提供的名称和调用我们的<code class="fe mp mq mr ms b">getCookie</code>函数返回的令牌值向我们的请求插入一个新的HTTP头。我们提供了名为<code class="fe mp mq mr ms b">x-json-web-token</code>的新头部，因为这是我们告诉我们的<code class="fe mp mq mr ms b">verifyToken</code>中间件函数用来查找令牌的名称。现在，当我们的前端提交GET请求时，它会再次收到一个状态代码为<code class="fe mp mq mr ms b">200 OK</code>的响应和请求的数据！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nk"><img src="../Images/2d5f755fe966323d72a7b0f8d41f7a10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3WkLxddiL6xg6yoU"/></div></div></figure><p id="aaa9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">注意，Request Headers部分有一个新条目，带有我们的<code class="fe mp mq mr ms b">x-json-web-token</code>头和令牌值。</p><p id="7d2c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们可以在前端重用这种范式，用于将来对后端的请求，我们希望在后端使用令牌验证来保护请求。事实上，我们甚至可以重构React.js应用程序，为这种范式创建一个函数，我们可以从前端的任何地方导入和调用该函数，但这是另一篇博客的主题！</p><h2 id="6b82" class="lr ls it bd lt lu lv dn lw lx ly dp lz ld ma mb mc lh md me mf ll mg mh mi mj bi translated"><strong class="ak">在React.js前端和Node.js后端之间建立符合CORS的通信</strong></h2><p id="d2e4" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">如果我们启动React.js应用程序并尝试使用<code class="fe mp mq mr ms b">LoginPage</code>组件登录，我们的浏览器将会抛出一个错误。错误本身会因浏览器而异。</p><pre class="kj kk kl km gt mt ms mu mv aw mw bi"><span id="dbdf" class="lr ls it ms b gy mx my l mz na">//Google Chrome<br/>Access to XMLHttpRequest at ‘http://localhost:4000/auth/login' from origin ‘http://localhost:3000' has been blocked by CORS policy: Response to preflight request doesn’t pass access control check: No ‘Access-Control-Allow-Origin’ header is present on the requested resource.</span><span id="5087" class="lr ls it ms b gy nb my l mz na">//Mozilla Firefox<br/>Cross-Origin Request Blocked: The Same Origin Policy disallows reading the remote resource at <a class="ae lq" href="http://localhost:4000/auth/login." rel="noopener ugc nofollow" target="_blank">http://localhost:4000/auth/login.</a> (Reason: header ‘content-type’ is not allowed according to header ‘Access-Control-Allow-Headers’ from CORS preflight response).</span></pre><p id="6d60" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们看到这个错误是因为我们的React.js应用程序(其来源是<a class="ae lq" href="http://localhost:3000" rel="noopener ugc nofollow" target="_blank"> http://localhost:3000 </a>)试图请求从我们的Node.js应用程序(其来源是<a class="ae lq" href="http://localhost:4000" rel="noopener ugc nofollow" target="_blank"> http://localhost:4000 </a>)获取数据，因此请求必须跨越来源。这违反了跨源资源共享(CORS)标准，该标准仅允许在请求遵循CORS标准的情况下跨源发送请求。大多数现代浏览器都遵循CORS标准，所以我们也应该如此。我们需要做的是指示我们的后端允许跨源请求。我们通过在后端的<code class="fe mp mq mr ms b">index.js</code>文件中添加几行代码来做这个改变。</p><pre class="kj kk kl km gt mt ms mu mv aw mw bi"><span id="8a0b" class="lr ls it ms b gy mx my l mz na">...<br/>app.use(function(req, res, next) {<br/>  res.header(“Access-Control-Allow-Origin”, “*”);<br/>  res.header(“Access-Control-Allow-Headers”, “Content-Type”);<br/>  next();<br/>});<br/>...</span></pre><p id="0dce" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们传递一个函数作为中间件，在响应上设置两个头，使我们的后端能够与我们的前端共享资源。第一个头是<code class="fe mp mq mr ms b">Access-Control-Allow-Origin</code>头，它允许我们的后端指定如何与外部域共享它的资源。将这个头的值设置为<code class="fe mp mq mr ms b">*</code>意味着我们的后端可以与互联网上的任何域共享资源。第二个头是<code class="fe mp mq mr ms b">Access-Control-Allow-Headers</code>头，它允许我们的后端指定它将在请求中接受哪些HTTP头。当发送一个HTTP请求时，浏览器首先使用OPTIONS HTTP方法发送一个“preflight”请求，让后端服务器知道在实际请求中可能会发送哪些HTTP头。后端用预检响应来响应该预检请求。预检请求包含<code class="fe mp mq mr ms b">Access-Control-Request-Headers</code>报头，因此我们必须相应地在预检响应上设置<code class="fe mp mq mr ms b">Access-Control-Allow-Headers</code>报头。让我们看一下我们的飞行前请求。</p><pre class="kj kk kl km gt mt ms mu mv aw mw bi"><span id="bb9f" class="lr ls it ms b gy mx my l mz na">Host: localhost:4000<br/>User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.13; rv:76.0) Gecko/20100101 Firefox/76.0<br/>Accept: */*<br/>Accept-Language: en-US,en;q=0.5<br/>Accept-Encoding: gzip, deflate<br/>Access-Control-Request-Method: POST<br/><strong class="ms iu">Access-Control-Request-Headers: content-type<br/></strong>Referer: <a class="ae lq" href="http://localhost:3000/login" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/login</a><br/>Origin: <a class="ae lq" href="http://localhost:3000" rel="noopener ugc nofollow" target="_blank">http://localhost:3000</a><br/>Connection: keep-alive</span></pre><p id="1d8f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我们的<code class="fe mp mq mr ms b">index.j</code> s文件中添加这两个标题将会生成以下预检响应。</p><pre class="kj kk kl km gt mt ms mu mv aw mw bi"><span id="b26f" class="lr ls it ms b gy mx my l mz na">HTTP/1.1 200 OK<br/>X-Powered-By: Express<br/><strong class="ms iu">Access-Control-Allow-Origin: *<br/>Access-Control-Allow-Headers: Content-Type, x-json-web-token<br/></strong>Allow: POST<br/>Content-Type: text/html; charset=utf-8<br/>Content-Length: 4<br/>ETag: W/”4-Yf+Bwwqjx254r+pisuO9HfpJ6FQ”<br/>Connection: keep-alive</span></pre><p id="28d4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，如果我们启动React.js应用程序并尝试使用<code class="fe mp mq mr ms b">LoginPage</code>组件登录，请求将会成功，因为我们已经使我们的前端和后端CORS之间的连接兼容！</p><h2 id="80b1" class="lr ls it bd lt lu lv dn lw lx ly dp lz ld ma mb mc lh md me mf ll mg mh mi mj bi translated"><strong class="ak">运行我们的React.js应用程序</strong></h2><p id="651e" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">我们终于可以运行我们的前端和后端应用程序了！运行我们在这篇博客中构建的React.js应用程序将不同于运行我们在以前的博客中构建的Node.js应用程序。我们的Node.js应用程序运行在我们使用Express.js web框架构建的HTTP服务器上，因此我们的应用程序可以接受HTTP请求，找到请求的文档，并发送包含请求的文档的HTTP响应。我们的React.js应用程序将使用浏览器内置的JavaScript引擎直接在浏览器中运行，例如Google Chrome中的V8、Mozilla Firefox中的SpiderMonkey和Apple Safari中的JavaScriptCore。这意味着我们的React.js应用程序将需要1)优化以在web浏览器中运行，2)横向兼容多个浏览器供应商以及纵向兼容这些浏览器的各个版本，也就是说，我们不能期望我们的所有最终用户都使用最新版本的Google Chrome。</p><p id="a3aa" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们的React.js应用程序是一个单页面应用程序，由多个相互依赖的JavaScript文件组成。为了让这些文件能够在浏览器中有效地交互，我们使用模块捆绑器来解析我们的代码，在遇到依赖关系时将其映射出来，并以浏览器可以理解的方式将我们的应用程序捆绑在一起。一个这样的模块捆绑器叫做Webpack，我们可以通过<code class="fe mp mq mr ms b">webpack</code>包将它安装到我们的项目中。</p><p id="70b6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">当Webpack解析我们的应用程序时，它会遇到我们使用现代JavaScript语法的代码，该语法在ECMAScript的第六个版本(也称为ES2015或ES6)中可用。不幸的是，对ES6的支持在不同的浏览器和浏览器版本之间是不一致的，正如在本节前面提到的，我们希望我们的应用程序的最终用户有相同的体验，不管他们选择什么浏览器。为了确保我们的应用程序能够在不同的浏览器上一致流畅地运行，我们需要将我们的代码从ES6向下转换到一个跨浏览器广泛支持的JavaScript版本。执行这种转换的一个工具是Babel，我们可以通过<code class="fe mp mq mr ms b">babel</code>包将它安装到我们的项目中。</p><p id="58c5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，我们可以通过安装每个必要的工具来建立我们自己的构建环境，并构建一个脚本来将它们绑定在一起，或者我们可以只安装<code class="fe mp mq mr ms b">react-scripts</code>包来为我们完成所有这些工作，包括将<code class="fe mp mq mr ms b">babel</code>和<code class="fe mp mq mr ms b">webpack</code>作为依赖项进行安装。</p><pre class="kj kk kl km gt mt ms mu mv aw mw bi"><span id="ee1a" class="lr ls it ms b gy mx my l mz na">$ npm install react-scripts</span></pre><p id="646e" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe mp mq mr ms b">react-scripts</code>包包含一个<code class="fe mp mq mr ms b">start.js</code>文件，该文件在执行时将运行一个脚本来启动我们的React.js应用程序。我们想通过命令行界面运行这个脚本，但是JavaScript文件不能从命令行执行。相反，我们使用节点包管理器。在这个博客系列中，我们只使用了npm来安装我们希望在项目中使用的包，但是npm也提供了一个接口来使用它们。例如，npm start命令可用于运行我们项目中指定的脚本。唯一的问题是这个命令在一个名为<code class="fe mp mq mr ms b">package.json</code>的文件中查找这些脚本。让我们现在创建这个文件。</p><pre class="kj kk kl km gt mt ms mu mv aw mw bi"><span id="85a5" class="lr ls it ms b gy mx my l mz na">$ touch package.json</span></pre><p id="5b02" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们用相关信息填充这个新文件。</p><pre class="kj kk kl km gt mt ms mu mv aw mw bi"><span id="0b7b" class="lr ls it ms b gy mx my l mz na">{<br/>“name”: “rest-api-node-react”,<br/>“scripts”: {<br/>  “start”: “react-scripts start”<br/>},<br/>...</span></pre><p id="236f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe mp mq mr ms b">package.json</code>文件有许多用途，比如管理依赖关系，但是出于我们的目的，我们通过将文件的<code class="fe mp mq mr ms b">scripts</code>属性中的<code class="fe mp mq mr ms b">start</code>脚本设置为<code class="fe mp mq mr ms b">react-scripts start</code>来使用它与react-scripts包进行交互。<code class="fe mp mq mr ms b">scripts</code>属性是一个包含脚本命令的字典，这些命令在应用程序生命周期的不同时间运行。键是生命周期事件(如<code class="fe mp mq mr ms b">start</code>、<code class="fe mp mq mr ms b">build</code>和<code class="fe mp mq mr ms b">eject</code>)，值是在该点运行的命令(如<code class="fe mp mq mr ms b">react-scripts start</code>、<code class="fe mp mq mr ms b">react-scripts build</code>和<code class="fe mp mq mr ms b">react-scripts eject</code>)。这样做意味着当我们运行<code class="fe mp mq mr ms b">npm start</code>时，将会执行<code class="fe mp mq mr ms b">start.js</code>文件中的脚本。</p><p id="06d0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在让我们尝试运行我们的应用程序。</p><pre class="kj kk kl km gt mt ms mu mv aw mw bi"><span id="203e" class="lr ls it ms b gy mx my l mz na">$ npm start</span></pre><p id="9a38" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果一切正常，我们应该会看到一个错误。这是因为<code class="fe mp mq mr ms b">react-scripts</code>是一个固执己见的库，它期望我们的应用程序中的文件在特定的位置。具体来说，它期望在<code class="fe mp mq mr ms b">public/</code>目录中找到我们的<code class="fe mp mq mr ms b">index.html</code>文件，在<code class="fe mp mq mr ms b">src/</code>文件夹中找到我们的<code class="fe mp mq mr ms b">index.js</code>文件和相关组件。让我们创建这些目录。</p><pre class="kj kk kl km gt mt ms mu mv aw mw bi"><span id="bc44" class="lr ls it ms b gy mx my l mz na">$ mkdir public<br/>$ mkdir src</span></pre><p id="64d0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">一旦我们将文件移动到适当的目录中，让我们再次尝试运行我们的应用程序。</p><pre class="kj kk kl km gt mt ms mu mv aw mw bi"><span id="485c" class="lr ls it ms b gy mx my l mz na">$ npm start</span></pre><p id="b5e4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">有用！在幕后，<code class="fe mp mq mr ms b">start.js</code>脚本调用Webpack来解析应用程序。Webpack在<code class="fe mp mq mr ms b">src/index.js</code>开始解析，并加载任何导入的模块，直到它有一个完整的依赖图。当遇到ES6代码时，Webpack将这些文件传递给Babel，以将代码转换成跨浏览器一致的JavaScript版本。Webpack使用依赖图来生成一个由我们的应用程序源代码组成的JavaScript文件，通过一个脚本标签将该文件注入到<code class="fe mp mq mr ms b">public/index.html</code>中，并启动一个可从<a class="ae lq" href="http://localhost:3000" rel="noopener ugc nofollow" target="_blank"> http://localhost:3000 </a>获得的开发服务器。我们可以使用浏览器的开发工具在Sources部分看到这个注入的JavaScript文件。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nl"><img src="../Images/f0ae014941a1af28e353257274e6b16c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*o2LstGGGCkU_Gbh5"/></div></div></figure><p id="75bc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们现在有了一个用React.js库构建的前端，它保护我们的Node.js后端免受未经授权的请求！</p><p id="6466" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">因此，回顾我们在这篇博客中所做的工作，我们首先重组了我们在我以前的博客中一直在做的项目<a class="ae lq" href="https://medium.com/@ckraczkowsky/building-a-secure-admin-interface-with-flask-admin-and-flask-security-13ae81faa05" rel="noopener">构建一个RESTful API </a>和<a class="ae lq" rel="noopener ugc nofollow" target="_blank" href="/securing-a-restful-api-built-with-node-js-f7feefc1efe1">保护一个用Node.js构建的RESTful API</a>，以清晰地从我们的后端代码中描绘出我们的前端代码，并根据这个新的结构从那个博客中迁移了所有的前端代码。然后，我们从一个基本的React.js应用程序开始构建我们的前端，并添加组件来呈现可公开访问的内容。接下来，我们添加了新的组件来呈现只有授权用户才能访问的私有内容，并构建了一个登录组件来使用户能够授权自己。然后，我们使用React路由器库在我们的公共和私有内容之间添加导航，并通过将未授权用户重定向到我们的登录组件来保护私有内容的所有路由。最后，我们使用axios库实现了前端和后端之间的通信，并保护了对后端的请求，以便只有授权用户才能通过中间件访问我们后端中受保护的数据。</p><p id="9d5d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">为了获得使用React.js、React Router和axios构建单页面应用程序的实际经验，从我的GitHub中克隆我们在整个博客中构建的应用程序的<a class="ae lq" href="https://github.com/ckraczkowsky91/rest-api-node-secure" rel="noopener ugc nofollow" target="_blank">源代码</a>，并在您的本地机器上运行它。</p><h2 id="0214" class="lr ls it bd lt lu lv dn lw lx ly dp lz ld ma mb mc lh md me mf ll mg mh mi mj bi translated">关于作者</h2><p id="5808" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">Colin Kraczkowsky在探索了产品管理的技巧之后，最近回到了web开发领域。Colin的职业经历包括在企业和初创企业环境中工作，编写web和移动应用程序代码，推出新产品，构建模型和原型，分析指标，以及不断创新。</p><p id="7327" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">闲暇时，科林会去大苏尔看看最新的阿利特露营装备，计划下一次去柯克伍德·丹尼尔山，或者在网飞的恐怖区冲浪。科林目前居住在加利福尼亚州的旧金山。</p><p id="e44f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">与科林—<a class="ae lq" href="https://www.linkedin.com/in/colinkraczkowsky" rel="noopener ugc nofollow" target="_blank">https://www.linkedin.com/in/colinkraczkowsk</a>y联系</p></div></div>    
</body>
</html>