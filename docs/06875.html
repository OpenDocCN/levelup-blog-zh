<html>
<head>
<title>Rust and ownership</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">生锈和所有权</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/rust-and-its-ownership-model-effc41e3951?source=collection_archive---------4-----------------------#2021-01-10">https://levelup.gitconnected.com/rust-and-its-ownership-model-effc41e3951?source=collection_archive---------4-----------------------#2021-01-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/403088d0cb52443b63c609ab7d4bc350.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fnbmdlZ_AorSCfqR1JycXA.png"/></div></div></figure><p id="c4cc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在过去的几年里，Rust 有了很大的发展，以至于在2020年被选为<a class="ae kw" href="https://insights.stackoverflow.com/survey/2020#technology-most-loved-dreaded-and-wanted-languages-loved" rel="noopener ugc nofollow" target="_blank"> Stack overflow最受欢迎的语言</a>。比亚军打字稿多近20%。</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div class="gh gi kx"><img src="../Images/df5d899ba90c4aaf1911498b9854a56b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1370/format:webp/1*fMfHBnQEumqMr9QiDfVUvQ.png"/></div><figcaption class="lc ld gj gh gi le lf bd b be z dk translated">Stackoverflows 2020年最受喜爱编程语言调查结果截图。</figcaption></figure><p id="0160" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个由两部分组成的系列将对Rust的主要卖点之一进行高度概述；它缺少垃圾收集器和所有权机制。我们将在第一部分讨论堆、栈和变量所有权。第二部分将着眼于借鉴和参考。</p><h1 id="6105" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">背景和先决条件</h1><p id="e241" class="pw-post-body-paragraph jy jz iq ka b kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated">在进入Typescript世界之前，我有静态类型语言(主要是Java)的背景。我对Rust的世界相当陌生，只是在2020年末才开始接触它。</p><p id="3311" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们开始之前，我希望你对至少一种语言有很好的理解，并且理解一些概念，比如垃圾收集和内存利用。</p><h1 id="4155" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">堆栈和堆</h1><p id="dee3" class="pw-post-body-paragraph jy jz iq ka b kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated">在大多数高级语言中，你被抽象成不知道堆和栈。堆栈和堆是任务的临时存储。它们都有一些关键的区别，这些区别决定了何时应该使用它们。优点和缺点。</p><p id="26a5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">栈</strong>以一种类似栈的数据类型存储数据，它遵循后进先出(LIFO)的规则。将数据添加到堆栈中称为压入堆栈，移除数据称为弹出堆栈。存储在堆栈上的数据必须具有固定的大小，并且不会发生任何变化。</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/1d0ee6a8ff4430dd01550531f66ce2fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:690/format:webp/1*KZPbIYsSwkssEtySjbGgwg.png"/></div><figcaption class="lc ld gj gh gi le lf bd b be z dk translated">堆栈的可视化示例</figcaption></figure><p id="e368" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">未知大小或可修改的数据存储在<strong class="ka ir">堆</strong>中，而不是堆栈中。数据是动态存储在堆中的，rust进程会请求一些空间，内存分配器会在堆中为数据分配一个位置。然后，内存分配器将返回一个地址，这是数据的位置。</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/c9349d8cbe8a7e3d724bfe32f83509ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/1*CiI5fPA_hZxENA2pZeyjug.png"/></div><figcaption class="lc ld gj gh gi le lf bd b be z dk translated">铁锈堆的形象化</figcaption></figure><p id="6397" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">推入堆栈比处理内存分配器快得多，因为推入堆栈不需要为数据寻找空间，然后执行必要的簿记任务来准备任何后续分配。</p><p id="3831" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">弹出堆栈也比处理堆快得多。相反，当您想要访问堆时，您必须跟随一个指针到达您所请求的数据所在的位置。</p><p id="6f1e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为什么这在铁锈的世界里很重要？取决于数据是存储在堆中还是堆栈中，rust如何处理内存分配、释放和所有权。现在，我们应该记住动态数据存储在堆中，而硬编码数据存储在堆栈中。</p><h1 id="3097" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">所有权和范围</h1><p id="36e5" class="pw-post-body-paragraph jy jz iq ka b kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated">Rust中的每个值只能有一个所有者，当值的所有者超出范围时，该值将从内存中删除。范围通常由花括号定义，在Rust中，这与大多数其他语言没有什么不同。</p><pre class="ky kz la lb gt ml mm mn mo aw mp bi"><span id="7a48" class="mq lh iq mm b gy mr ms l mt mu">fn sayHello() {   <br/>    let msg = "hello";<br/>    // do stuff with msg<br/> }<br/> <br/> // msg now out of scope.</span></pre><p id="f2cb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通常，会发生两种情况中的一种。如果语言有一个垃圾收集器，那么这将释放内存。如果这种语言没有像C语言那样的垃圾收集器，你就必须告诉你的程序去释放内存，这是为了防止内存错误在你的程序中发生，比如内存泄漏。</p><p id="5187" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，锈从不同的角度接近它。Rust通过识别超出范围的变量，在编译时计算出何时释放内存。Rust还会发现内存错误，如泄漏或访问编译时超出范围的内存，并向您发出警告。</p><p id="9b07" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个概念很简单，当变量超出范围时，rust会释放内存。Rust编译器为您在代码中添加了解除分配功能。</p><pre class="ky kz la lb gt ml mm mn mo aw mp bi"><span id="bd54" class="mq lh iq mm b gy mr ms l mt mu">fn sayHello() {   <br/>    let msg = "hello";<br/>    // do stuff with msg<br/> }<br/> <br/> // msg now out of scope AND the memory has been freed in the heap</span></pre><p id="3869" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个概念看起来简单明了，事实也的确如此。然而，在某些情况下，在更复杂的情况下，代码的行为可能是意想不到的。</p><pre class="ky kz la lb gt ml mm mn mo aw mp bi"><span id="4081" class="mq lh iq mm b gy mr ms l mt mu">fn sayHello() {   <br/>    let msg = <!-- -->String::from(<!-- -->"hello");<br/>    let msg2 = msg;<br/>    // do stuff with msg2<br/> }<br/>// free msg memory<br/>// free msg2 memory??</span></pre><p id="6d7b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意:我们使用“String::from ”,它强制我们的代码将值存储在堆中。</p><p id="d576" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里我们将msg分配给msg2，然后我们可能会想，当它们超出作用域时，它们也应该从内存中释放？不完全是。两个变量都指向同一个数据位，因此当其中一个超出范围时，您可能希望数据被释放，而当第二个超出范围时，您可能希望出现错误。Rust很聪明，它通过在初始化第二个变量指针时使第一个变量指针“msg”无效来克服这个问题。</p><p id="a572" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们看另一个例子:</p><pre class="ky kz la lb gt ml mm mn mo aw mp bi"><span id="bc44" class="mq lh iq mm b gy mr ms l mt mu">let msg = String::from("Hello, world");<br/>let msg2 = msg;</span><span id="ec57" class="mq lh iq mm b gy mv ms l mt mu">println!("{}", msg);</span></pre><p id="9609" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这里，当我们试图打印消息时，我们得到一个错误，说“值已经移动”。这是因为Rust使msg失效，当它超出范围时，通过两次释放相同的数据来阻止您犯运行时内存错误。事实是这样的:</p><pre class="ky kz la lb gt ml mm mn mo aw mp bi"><span id="daa7" class="mq lh iq mm b gy mr ms l mt mu">fn sayHello() {   <br/>    let msg = "hello";<br/>    let msg2 = msg; // msg is now marked as invalid.<br/>    // do stuff with msg2<br/> }<br/>// msg is invalid<br/>// free msg2 memory</span></pre><figure class="ky kz la lb gt jr gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/015532d6122c524cbb7b88ff4061ec59.png" data-original-src="https://miro.medium.com/v2/resize:fit:742/format:webp/1*P6CSpWzGdT6VRXUPHsKDTw.png"/></div><figcaption class="lc ld gj gh gi le lf bd b be z dk translated">生锈使指针失效的直观例子</figcaption></figure><p id="c0cc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如您所见，msg和msg2从不同时指向相同的数据。相反，Rust会使旧的指针失效，只留下最新的，这解决了msg2抛出内存错误的问题。</p><p id="7860" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是如果你想复制/克隆一些数据呢？好吧，Rust有一个克隆特性就是用来做这个的。<a class="ae kw" href="https://doc.rust-lang.org/rust-by-example/trait.html" rel="noopener ugc nofollow" target="_blank">特质</a>不在本帖*击鼓*范围内。就把它们想象成可以为任何类型定义的方法。</p><pre class="ky kz la lb gt ml mm mn mo aw mp bi"><span id="29e8" class="mq lh iq mm b gy mr ms l mt mu">let s1 = String::from("Matt");     <br/>let s2 = s1.clone();</span></pre><p id="2b8f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">s2将指向与s1不同的数据值。</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/c90f316a528fd971106fc69ee2d010d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:722/format:webp/1*hWcPuQW3xSD0VBNfmR1WKA.png"/></div><figcaption class="lc ld gj gh gi le lf bd b be z dk translated">克隆功能的可视化示例</figcaption></figure><h1 id="4c05" class="lg lh iq bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">所有权和职能</h1><p id="78b7" class="pw-post-body-paragraph jy jz iq ka b kb me kd ke kf mf kh ki kj mg kl km kn mh kp kq kr mi kt ku kv ij bi translated">将变量传递给函数的功能类似于为值赋值的规则。例如:</p><pre class="ky kz la lb gt ml mm mn mo aw mp bi"><span id="b773" class="mq lh iq mm b gy mr ms l mt mu">fn main() {<br/>   let name = String::from("Matt"); // name comes into scope.<br/>   doSomething(name); // name moves into the functions scope.</span><span id="e39e" class="mq lh iq mm b gy mv ms l mt mu">   // if we try to use name it would throw an error.<br/>}</span><span id="e41f" class="mq lh iq mm b gy mv ms l mt mu">fn doSomething(myName: String) {<br/>    println("My name is {}", myName); <br/>    // myName comes into scope and is used.<br/>} // myName is now dropped, including the data.</span></pre><p id="3aa9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里，“name”被传递给函数doSomething，它现在是该值的主要作用域。当doSomething完成时，初始数据将从内存中释放，如果您来自Javascript世界，这可能是一个意外的行为。为了能够重用变量，您可能希望返回值，以便能够将变量的所有权转移回父作用域。所以你可以这样修改上面的代码。</p><pre class="ky kz la lb gt ml mm mn mo aw mp bi"><span id="0a69" class="mq lh iq mm b gy mr ms l mt mu">fn main() {<br/>   let name = String::from("Matt");<br/>   let name2 = doSomething(name);</span><span id="67eb" class="mq lh iq mm b gy mv ms l mt mu">}</span><span id="ccfc" class="mq lh iq mm b gy mv ms l mt mu">fn doSomething(myName: String) -&gt; String {<br/>    println("My name is {}", myName); <br/>    myName // myName is returned.<br/>}</span></pre><p id="412e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但这有点反直觉，也有点乱。相反，Rust有一个叫做References的特性。</p><p id="49a4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第二部分将讨论Rusts引用和借用！</p></div></div>    
</body>
</html>