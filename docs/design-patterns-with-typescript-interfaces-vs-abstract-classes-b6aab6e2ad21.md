# 使用类型脚本的设计模式:接口与抽象类

> 原文：<https://levelup.gitconnected.com/design-patterns-with-typescript-interfaces-vs-abstract-classes-b6aab6e2ad21>

![](img/285db18f33025554d6a59e47dcda7229.png)

由[罗布森·哈苏卡米·摩根](https://unsplash.com/@robsonhmorgan?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 拍摄的照片

在本文中，我们将回顾:

1.  为什么以及何时我们应该使用接口——它们给代码库带来了什么
2.  接口:函数的看门人，带语法使用示例
3.  抽象类:使用语法获得免费功能的契约使用示例
4.  差异和相似之处——何时使用接口和抽象类

在我们开始之前——如果您对 TypeScript 语法不熟悉，或者如果您需要关于设置类型的快速提示，请务必阅读文章[A Walk Through Setting the TypeScript:Annotations vs Inference](/a-walk-through-setting-the-types-in-typescript-annotations-vs-inference-1da62e7492ae)。

在任何代码库中，代码的可重用性总是受欢迎的。这已经用干原理和常识重复了很多次。然而，编写更抽象的代码并不像为手头的特定任务提出解决方案那样容易。

在 JavaScript 中，如果不看实现，我们永远无法确定函数需要什么参数，也无法确定调用函数时会用到什么参数。调用参数的方法，甚至访问嵌套的对象属性，都会导致脆弱的代码。为了避免这种限制，我们必须编写类似于`object && object.prop && object.prop.func()`的重复检查，尽管有快捷语法，但这很快就会失控。

为了解决这个问题，TypeScript 引入了允许我们描述一个对象或一组值的结构的接口。毫无疑问，它非常方便，但我认为我们可以更进一步。我们可以使用接口来实现普通 JavaScript 无法比拟的代码可重用性。

> 我喜欢把接口想象成一个函数的看门人。在一个接口的帮助下，函数可以执行契约“匹配这个结构，你就可以得到这个功能。”

## 在 TypeScript: BubbleSorter 类中使用接口

让我们假设我们想做一个 BubbleSorter 类，它可以对一个数字数组、一个字符串和一个链表进行排序。这听起来像是另一个 JavaScript 笑话的开始，因为这些是非常不同的数据结构:

*   数组有一个内置的排序方法，所以这个方法很简单
*   一个字符串是不可变的，不能被直接操作，但是我们可以用`.split()`和`.join()`把它转换成一个数组
*   链表——没那么容易。默认情况下，它不存在于 JavaScript/TypeScript 中，因此它将是一个自定义实现

如果您需要快速提醒，冒泡排序是 O(n2)排序算法，它有一个嵌套的`for`循环来遍历集合。冒泡排序有两个明显的特性可以帮助我们:

*   它*比较*两个相邻的值。索引 1 处的值带有索引 2 处的值，然后索引 2 带有 3，3 带有 4，依此类推
*   如果索引 1 处的值大于索引 2 处的值——冒泡排序*交换*它们，导致较大的值“冒泡”到集合的末尾

这意味着我们的 sorter 类可以对任何东西进行排序，只要它知道如何比较两个元素以及如何交换它们。这是一个界面的完美工作。看一下这段代码:

可以对不同的数据集合进行排序的通用 BubbleSorter

这个 BubbleSorter 类不知道它需要排序的集合的类型。在`Sortable`接口的帮助下，我们实现了一个“契约”说:
它可以是任何数据集合。只要您提供以下内容，BubbleSorter 就可以对其进行排序:
a)数据集合的长度
b)比较结构中两个元素的函数
c)交换两个元素的函数

现在，我不知道你个人的情况，但是我怀疑大多数工程师是否能够很容易地想出对链表进行排序的方法。我知道这可能需要我花很多时间去谷歌一下。然而，实现`compare`和`swap`功能没什么大不了的。有了这种类型的设置，我们可以重用排序本身的逻辑，并通过提供几个简单的函数来排序我们想要的任何东西。

BubbleSorter 类与其余代码完全解耦，可以在任何地方使用。

综上所述，TypeScript 中的接口有:

*   描述对象或一组值的结构的工具
*   函数和类的看门人
*   一种执行“契约”的方法:匹配结构—获得功能

## 抽象类:重构 BubbleSorter 类

到目前为止，我们的 BubbleSorter 运行良好；只剩下一个需要改进的地方了。这种交互有点奇怪，我们需要用我们的数据集合创建一个 BubbleSorter 类的实例，然后在每次需要排序时调用`.sort()`。这不是你所期望的工作方式。通常，如果某个类有一个内置的方法来排序自己，我们需要做的就是在它的一个实例上调用`.sort()`。

那么，我们如何将 BubbleSorter 重构为:

1.  重用排序逻辑，避免将它复制粘贴到我们想要排序的其他类中
2.  避免在每次我们想对集合进行排序时创建一个新的 BubbleSorter 实例

为了实现这一点，TypeScript 还有另一个普通 JavaScript 中现有的特性——抽象类。正如你可能已经猜到的，抽象类是一个永远不会被实例化的类。它的目的就是成为某个其他类的父类，并在类似的类之间共享功能。这最后一部分不是由 TypeScript 本身强制执行的，但是被认为是一个好的实践，因为使用抽象类*在类*之间引入了紧密耦合。

看一下下面的例子:

抽象类 BubbeSorter

在这次重构中，我们做了一些改动:

1.  向 BubbleSorter 类添加了`abstract`关键字。关键字将阻止创建此类的实例。
2.  在 BubbleSorter 类*中定义了三个*抽象*属性。*这确保了`extends BubbleSorter`必须实现所需功能和属性的任何类。
3.  集合类(NumbersCollection、CharCollection 和 LinkedList)现在是`extend BubbleSorter`类而不是`implements Sortable`接口。所以我们可以删除独立接口`Sortable`,因为我们不再在代码中使用它。
4.  为了对任何一个集合进行排序，我们可以在这个集合的实例中调用`.sort()`。集合类不需要知道排序是如何发生的，也不需要知道任何排序细节。

使用抽象类来引入由不同类的成员共享的功能是经典的类型脚本模式之一。抽象类在不同的类之间建立了一个契约，代价是它们之间的强耦合。这意味着如果没有 BubbleSorter 类，集合类将无法正常工作，并且 BubbleSorter 类不能独立实例化，没有集合类也没有多大意义。

## 差异和相似之处

接口和抽象类无疑是最强大的 TypeScript 特性列表的顶端。这两个特性都在 JavaScript 世界中引入了新的 OOP 风格的功能，并促进了编写抽象的、更通用的、更可重用的代码。

总而言之，我们应该总是首先使用接口，当我们想要将功能“注入”到类似的类中时，就求助于抽象类的使用。

**接口:**

*   促进松散耦合
*   在不同的类之间建立一个契约
*   充当某项职能的“看门人”
*   当我们想要一起工作的对象非常不同时，效果最好

**继承/抽象类:**

*   将类强耦合在一起
*   在不同的类之间建立一个契约
*   当我们试图建立一个对象的定义时，效果最好

我希望这能让 TypeScript 中的接口和抽象类的概念更加清晰。

完整实现请查看 [my GitHub](https://github.com/arstrel/sorting-anything) 。

在本文中，我们回顾了:

*   用接口和抽象类构建“排序任何东西”的 BubbleSorter 类的例子
*   两个概念的区别、相似之处和最佳用例

感谢您的阅读！

构建漂亮而有弹性的应用程序，用 TypeScript 编写可重用的代码，一如既往地快乐编码！