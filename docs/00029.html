<html>
<head>
<title>React Component Patterns</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应组件模式</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/react-component-patterns-ab1f09be2c82?source=collection_archive---------0-----------------------#2017-10-26">https://levelup.gitconnected.com/react-component-patterns-ab1f09be2c82?source=collection_archive---------0-----------------------#2017-10-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f5cc" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">有状态x无状态，容器x P <strong class="ak">表示</strong>，hoc，渲染回调等等</h2></div><p id="d511" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我已经有一段时间没有和<a class="ae lb" href="https://facebook.github.io/react/" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir"> React </strong> </a> — <em class="lc">脸书的一个库一起使用JavaScript — </em>构建用户界面了，有几个概念我希望在我刚开始的时候就知道。本文试图总结我在迄今为止的经历中所学到的一些模式——对于即将进入这个基于组件的世界的开发人员来说可能也是有用的。</p><figure class="le lf lg lh gt li gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi ld"><img src="../Images/1d20f466e21031bc125db7dd6944b1f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mPL5M-XhGpDuXLniVRCthw.png"/></div></div></figure><h1 id="bd68" class="lp lq iq bd lr ls lt lu lv lw lx ly lz jw ma jx mb jz mc ka md kc me kd mf mg bi translated">有状态x无状态组件</h1><p id="ce27" class="pw-post-body-paragraph kf kg iq kh b ki mh jr kk kl mi ju kn ko mj kq kr ks mk ku kv kw ml ky kz la ij bi translated">正如有状态和无状态的web服务一样，React组件也可以在应用程序使用期间保持和操作状态(<strong class="kh ir">有状态</strong> ) —或者只是一个简单的组件，它接受输入属性并返回要显示的内容(<strong class="kh ir">无状态</strong>)。</p><p id="65dc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一个简单的<strong class="kh ir">无状态</strong>按钮组件，仅依赖于道具:</p><figure class="le lf lg lh gt li gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi mm"><img src="../Images/1566f228b0a050b861a3c8d8a98b72e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s66RqkT-O7qBonbJSnbfbw.png"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">要点:<a class="ae lb" href="https://gist.github.com/gmatheus/88966b08a45eba7575a721f7dccdd606#file-01-stateless-js" rel="noopener ugc nofollow" target="_blank"> stateless.js </a></figcaption></figure><p id="0ae8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">和一个<strong class="kh ir">有状态</strong>计数器组件示例(使用<code class="fe mr ms mt mu b">Button</code>组件):</p><figure class="le lf lg lh gt li gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi mm"><img src="../Images/90b4176e96c1ffbd7ce55748985944d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gv0YJ8Z1QwkDlQPkraSUDw.png"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">要旨:<a class="ae lb" href="https://gist.github.com/gmatheus/88966b08a45eba7575a721f7dccdd606#file-02-stateful-js" rel="noopener ugc nofollow" target="_blank"> stateful.js </a></figcaption></figure><p id="1426" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如您所见，最后一个构造函数持有一个组件状态，而第一个是一个简单的组件，通过props呈现文本。这种关注点的分离看起来很简单，但是使得<code class="fe mr ms mt mu b">Button</code>组件高度可重用。</p><figure class="le lf lg lh gt li gh gi paragraph-image"><a href="https://gitconnected.com/?utm_source=publication&amp;utm_medium=cta-banner"><div class="gh gi mv"><img src="../Images/26797da0642875dc5a034a11d5991f56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vLqV3O21wXUs-3CpOK9n9Q.png"/></div></a></figure><h1 id="6c9b" class="lp lq iq bd lr ls lt lu lv lw lx ly lz jw ma jx mb jz mc ka md kc me kd mf mg bi translated">容器x表示组件</h1><p id="1225" class="pw-post-body-paragraph kf kg iq kh b ki mh jr kk kl mi ju kn ko mj kq kr ks mk ku kv kw ml ky kz la ij bi translated">当处理外部数据时，我们可以将组件分成这两个新的类别。<strong class="kh ir">容器</strong>负责到达位于React范围之外的数据，比如连接到<em class="lc"> Redux </em>或<em class="lc">Relay</em>——而<strong class="kh ir">表示层</strong>组件不依赖于应用程序的其余部分，只依赖于它自己的状态或收到的道具。让我们以一个用户列表作为<strong class="kh ir">表示性</strong>组件示例:</p><figure class="le lf lg lh gt li gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi mm"><img src="../Images/956ece6fcbb88c7da6e681e63e1ca6c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*awy0b6pZH0o13nodB6BEPg.png"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">要点:<a class="ae lb" href="https://gist.github.com/gmatheus/88966b08a45eba7575a721f7dccdd606#file-03-presentational-js" rel="noopener ugc nofollow" target="_blank"> presentational.js </a></figcaption></figure><p id="0a4a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个列表可以使用我们的<strong class="kh ir">容器</strong>组件进行更新:</p><figure class="le lf lg lh gt li gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi mm"><img src="../Images/fa9227d493d94745a789cc2855f55ef5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cGQaWg54rGFVRnNIMHSHdQ.png"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">要点:<a class="ae lb" href="https://gist.github.com/gmatheus/88966b08a45eba7575a721f7dccdd606#file-04-container-js" rel="noopener ugc nofollow" target="_blank"> container.js </a></figcaption></figure><p id="d906" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种方法将数据提取与渲染分开，并使<code class="fe mr ms mt mu b">UserList</code> <strong class="kh ir"> </strong>可重用。如果你想进一步了解这种模式，丹·阿布拉莫夫有一篇很棒的文章对其进行了精确的解释。</p><h1 id="2c39" class="lp lq iq bd lr ls lt lu lv lw lx ly lz jw ma jx mb jz mc ka md kc me kd mf mg bi translated">高阶组件</h1><p id="d8ab" class="pw-post-body-paragraph kf kg iq kh b ki mh jr kk kl mi ju kn ko mj kq kr ks mk ku kv kw ml ky kz la ij bi translated">当您想要重用一个组件逻辑时，高阶组件—或者仅仅是<strong class="kh ir"><em class="lc">hoc</em></strong><em class="lc">—</em>是有用的。它们是JavaScript函数，将一个组件作为参数，并返回一个新组件。</p><p id="5a11" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设您需要构建一个可扩展的菜单组件，当用户单击它时，它会显示一些子内容。因此，您可以简单地创建一个通用的<strong class="kh ir"> HOC </strong>来处理它，而不是控制其父组件的状态:</p><figure class="le lf lg lh gt li gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi mm"><img src="../Images/19c2e11ee6b140a55c0a04b76ba7d48c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V4anjW4im3wZVHJnbb6YIA.png"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">要点:<a class="ae lb" href="https://gist.github.com/gmatheus/88966b08a45eba7575a721f7dccdd606#file-05-hoc-js" rel="noopener ugc nofollow" target="_blank"> hoc.js </a></figcaption></figure><p id="3c8f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种方法允许我们使用JavaScript <em class="lc">装饰器</em>语法将我们的逻辑应用到我们的<code class="fe mr ms mt mu b">ToggleableMenu</code>组件:</p><figure class="le lf lg lh gt li gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi mm"><img src="../Images/1c67529af95648b0f40b80bb857e6947.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3ehN2asx5WscQstyt-GmUw.png"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">要点:<a class="ae lb" href="https://gist.github.com/gmatheus/88966b08a45eba7575a721f7dccdd606#file-06-hoc-usage-js" rel="noopener ugc nofollow" target="_blank"> hoc-usage.js </a></figcaption></figure><p id="bffe" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们可以把任何孩子传给<code class="fe mr ms mt mu b">ToggleableMenu</code>组件:</p><figure class="le lf lg lh gt li gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi mm"><img src="../Images/9f1ab55649ae1d496e992c7eb8e66ee3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*COcNSXHE9L5J2mOjCUHcWw.png"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">要点:<a class="ae lb" href="https://gist.github.com/gmatheus/88966b08a45eba7575a721f7dccdd606#file-07-hoc-menu-js" rel="noopener ugc nofollow" target="_blank"> hoc-menu.js </a></figcaption></figure><p id="570f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你熟悉<a class="ae lb" href="http://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux的</a> <code class="fe mr ms mt mu b">connect</code>或<a class="ae lb" href="https://github.com/ReactTraining/react-router" rel="noopener ugc nofollow" target="_blank"> React路由器的</a> <code class="fe mr ms mt mu b">withRouter</code>功能，你已经在使用<strong class="kh ir"> HOCs </strong>！</p><h1 id="0d86" class="lp lq iq bd lr ls lt lu lv lw lx ly lz jw ma jx mb jz mc ka md kc me kd mf mg bi translated">呈现回调</h1><p id="bf8d" class="pw-post-body-paragraph kf kg iq kh b ki mh jr kk kl mi ju kn ko mj kq kr ks mk ku kv kw ml ky kz la ij bi translated">使组件逻辑可重用的另一个好方法是将你的组件子组件变成一个函数——这就是为什么<strong class="kh ir">渲染回调</strong>也被称为子组件的<strong class="kh ir">函数。我们可以以可扩展菜单<strong class="kh ir"> HOC </strong>为例，使用<strong class="kh ir">渲染回调</strong>模式重写它:</strong></p><figure class="le lf lg lh gt li gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi mm"><img src="../Images/4d7ba2b8dbba3d51bd80745cecc1d998.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-IQyYKmBMjSXNpectQwPHg.png"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">要点:<a class="ae lb" href="https://gist.github.com/gmatheus/88966b08a45eba7575a721f7dccdd606#file-08-render-callback-js" rel="noopener ugc nofollow" target="_blank"> render-callback.js </a></figcaption></figure><p id="eb0f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们可以传递一个函数作为我们的<code class="fe mr ms mt mu b">Toggleable</code>组件的子组件:</p><figure class="le lf lg lh gt li gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi mm"><img src="../Images/a24928e24c54bfe0f23fff939aee9b38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y0XbgHvV_P8r7mR6V5dAJA.png"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">要点:<a class="ae lb" href="https://gist.github.com/gmatheus/88966b08a45eba7575a721f7dccdd606#file-09-render-callback-usage-js" rel="noopener ugc nofollow" target="_blank"> render-callback-usage.js </a></figcaption></figure><p id="5c9b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的代码已经使用了一个函数作为子函数，但是，如果我们想像在我们的<strong class="kh ir"> HOC </strong>示例(多个菜单)中一样重用它，我们可以简单地创建一个使用<code class="fe mr ms mt mu b">Toggleable</code>逻辑的新组件:</p><figure class="le lf lg lh gt li gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi mm"><img src="../Images/76496ffa93b6ecae5bac8b19fa7b3de4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*asLqfnylPaMZwD8tCrVdLA.png"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">gist:<a class="ae lb" href="https://gist.github.com/gmatheus/88966b08a45eba7575a721f7dccdd606#file-10-render-callback-usage-reusable-js" rel="noopener ugc nofollow" target="_blank">render-callback-usage-reusable . js</a></figcaption></figure><p id="1b1f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们全新的<code class="fe mr ms mt mu b">ToggleableMenu</code>组件已经可以使用了:</p><figure class="le lf lg lh gt li gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi mm"><img src="../Images/2e79265294c09334e9077e440b79703b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1k0msCBopEDoWFUoRam0xg.png"/></div></div><figcaption class="mn mo gj gh gi mp mq bd b be z dk translated">要点:<a class="ae lb" href="https://gist.github.com/gmatheus/88966b08a45eba7575a721f7dccdd606#file-11-render-callback-menu-js" rel="noopener ugc nofollow" target="_blank">render-callback-menu . js</a></figcaption></figure><p id="6ce5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的<code class="fe mr ms mt mu b">Menu</code>组件看起来与我们的<strong class="kh ir"> HOC </strong>示例完全一样！</p><p id="1857" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们想要改变呈现的内容本身而不管<strong class="kh ir">状态</strong>操作时，这种方法非常有用:正如你所看到的，我们已经将<strong class="kh ir">呈现</strong>逻辑移到了我们的<code class="fe mr ms mt mu b">ToggleableMenu</code>子函数中，但是将<strong class="kh ir">状态</strong>逻辑保留到了我们的<code class="fe mr ms mt mu b">Toggleable</code> <strong class="kh ir"> </strong>组件中！</p><h1 id="5c44" class="lp lq iq bd lr ls lt lu lv lw lx ly lz jw ma jx mb jz mc ka md kc me kd mf mg bi translated">进一步阅读</h1><p id="fa70" class="pw-post-body-paragraph kf kg iq kh b ki mh jr kk kl mi ju kn ko mj kq kr ks mk ku kv kw ml ky kz la ij bi translated">上面的例子只是你可以在你的<strong class="kh ir"> React </strong>代码中使用的一些模式的<em class="lc">基础</em>，如果你真的想更深入地了解这些主题，我建议你看一看这个伟大的东西:</p><ul class=""><li id="8d03" class="mw mx iq kh b ki kj kl km ko my ks mz kw na la nb nc nd ne bi translated"><a class="ae lb" href="https://www.youtube.com/watch?v=YaZg8wg39QQ" rel="noopener ugc nofollow" target="_blank">陈宸反应组分模式</a></li><li id="6c42" class="mw mx iq kh b ki nf kl ng ko nh ks ni kw nj la nb nc nd ne bi translated"><a class="ae lb" href="https://github.com/chantastic/reactpatterns.com" rel="noopener ugc nofollow" target="_blank">反应模式</a></li><li id="5095" class="mw mx iq kh b ki nf kl ng ko nh ks ni kw nj la nb nc nd ne bi translated"><a class="ae lb" href="https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0" rel="noopener">外观和容器组件</a></li><li id="aba2" class="mw mx iq kh b ki nf kl ng ko nh ks ni kw nj la nb nc nd ne bi translated"><a class="ae lb" href="https://medium.com/@franleplant/react-higher-order-components-in-depth-cf9032ee6c3e" rel="noopener">深度反应高阶组件</a></li><li id="5130" class="mw mx iq kh b ki nf kl ng ko nh ks ni kw nj la nb nc nd ne bi translated"><a class="ae lb" href="https://medium.com/merrickchristensen/function-as-child-components-5f3920a9ace9" rel="noopener">用作子组件</a></li><li id="08fa" class="mw mx iq kh b ki nf kl ng ko nh ks ni kw nj la nb nc nd ne bi translated"><a class="ae lb" href="https://github.com/acdlite/recompose" rel="noopener ugc nofollow" target="_blank">重组</a></li><li id="d16d" class="mw mx iq kh b ki nf kl ng ko nh ks ni kw nj la nb nc nd ne bi translated"><a class="ae lb" href="https://github.com/paypal/downshift" rel="noopener ugc nofollow" target="_blank">降档</a></li></ul><figure class="le lf lg lh gt li gh gi paragraph-image"><a href="https://levelup.gitconnected.com"><div class="gh gi mm"><img src="../Images/d9fe9ae1a34de6a28338eae427dd6438.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E8lHUzxrIT5VDhu7fUS6gg.png"/></div></a></figure><div class="nk nl gp gr nm nn"><a href="https://gitconnected.com/learn/react" rel="noopener  ugc nofollow" target="_blank"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd ir gy z fp ns fr fs nt fu fw ip bi translated">学习React -最佳React教程(2019) | gitconnected</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">前45名React教程。课程由开发人员提交并投票，使您能够找到最佳反应…</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">gitconnected.com</p></div></div><div class="nw l"><div class="nx l ny nz oa nw ob ln nn"/></div></div></a></div></div></div>    
</body>
</html>