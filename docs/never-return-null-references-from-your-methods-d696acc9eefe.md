# 永远不要从函数中返回空引用

> 原文：<https://levelup.gitconnected.com/never-return-null-references-from-your-methods-d696acc9eefe>

## 你总是有更好的选择。

![](img/3a92bf1d0dc28e396baeeccdda439750.png)

照片由[韦斯·希克斯](https://unsplash.com/@sickhews?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄

在 C#中，引用类型可以被赋予`null`值。这是开发人员在使用类来创建软件之前必须面对的问题。不幸的是，微软的人不能简单地禁止在编译时将`null`赋值给引用变量，因为那会破坏几乎每个项目的代码库。

# 返回 Null 是不好的做法

从方法中返回一个`null`引用实际上有什么问题？

让我们来看看这个简单的方法:

如果在数据库中没有找到订单，`FirstOrDefault`方法会自动返回`null`。

这里有几个问题:

*   `GetOrder`方法的调用方必须实现空引用检查，以避免在访问`Order`类成员时得到`NullReferenceException`。但是调用者应该如何知道如何正确地实现错误处理呢？如果调用者收到一个空引用或者返回一些错误代码，它应该抛出一个异常吗？
*   当每个调用者自己实现验证逻辑时，它将被复制，并且逻辑在所有调用者之间不一致的可能性很高。这是违反**干**原则的。
*   对于调用者来说，获取一个`null`值是不明确的，因为它没有说明返回 null 是因为 bug 还是因为在数据库中没有找到订单。返回`null`绝对不是**域驱动设计**的方法。
*   返回`null`经常违反**快速失败**编程原则。由于应用程序中的某些问题，可能会出现`null`。如果开发人员没有实现适当的异常处理，该问题甚至会进入生产环境，这有助于快速检测问题。

开发人员可以做一些事情来改善这种情况，比如使用可空的引用类型、抛出异常或者使用空对象设计模式。

# 使用可空的引用类型

如果开发人员真的需要从方法中返回一个`null`值(99%的情况下这是不必要的)，返回类型可以标记为可空引用类型(这个特性是在 C# 8.0 中引入的)。

将返回类型标记为可空有两个主要好处:

*   方法签名明确声明它可以返回空引用。这样，调用者通过查看方法签名就可以确定他们需要实现错误处理。
*   如果调用者没有首先检查`null`引用就访问`Order`类的成员，编译器将发出警告。

# 通过抛出异常快速失败

快速失效原则是软件工程中的一个重要原则。这个想法非常简单——只要应用程序检测到问题(空引用),它就应该抛出一个异常。

不正确的`orderId`可能由以下原因造成:

*   未正确配置自动映射库来映射`orderId`值。
*   一些代码在调用`GetOrder`方法之前，意外地将错误的值赋给了`orderId`变量。
*   前端不会将订单 id 传递给后端。

描述的每个原因都是应用程序中的一个 bug。因此，根据**快速失效**原理，一旦系统检测到`orderId`无效，它应该抛出异常。

对于未找到的订单，抛出异常的最简单方法是在实现中使用`First`方法，而不是`FirstOrDefault`。

但是我们有另一个问题:调用者会得到没有任何有价值信息的`InvalidOperationException`,因为这是一个常见的问题。净异常。解决方案是引入一个定制的异常类型，一旦在数据库中找不到订单，开发人员就应该抛出这个异常。

总结自定义异常方法的优点:

*   在部署生产环境之前发现和解决问题的几率要高得多。
*   呼叫者将获得有关问题的详细信息，这将简化故障排除过程。

# 使用空对象设计模式

另一种避免返回`null`的方法是使用空对象设计模式。

空对象是一个没有存根行为的对象，开发人员可以将它返回给调用者，而不是返回`null`值。

调用者不需要检查空值的顺序，因为返回了一个真实但空的`Order`对象。

空对象模式应该被仔细考虑作为抛出异常的一种替代方法。使用该模式与快速失效原则相反。

只有当调用者为了跳过对其成员的访问而检查对象的`null`时，才应该使用这种模式。

# 结论

结论很简单——永远不要从方法中返回空引用。