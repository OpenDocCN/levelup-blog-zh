<html>
<head>
<title>TypeScript Decorators in 6 Minutes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">6分钟内打字稿装饰工</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/typescript-decorators-in-6-minutes-daa9660f8286?source=collection_archive---------2-----------------------#2022-11-14">https://levelup.gitconnected.com/typescript-decorators-in-6-minutes-daa9660f8286?source=collection_archive---------2-----------------------#2022-11-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="22d6" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">原来TypeScript的装修工并不难，一篇文章让你掌握4类装修工！</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9e5c8dae425c26523f8f9efa47cd59c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Tf2Ijt7nTHt-ha62"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">克里斯托弗·高尔在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="054b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">欢迎来到<strong class="lb iu">掌握打字稿</strong>系列。本系列将以动画的形式介绍TypeScript的核心知识和技术。让我们一起学习吧！以前的文章如下:</p><ul class=""><li id="ccb0" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated"><a class="ae ky" href="https://javascript.plainenglish.io/no-more-confusion-about-typescripts-type-and-interface-63c39418ae35" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">不再混淆TypeScript的类型和接口</strong> </a></li><li id="257c" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://javascript.plainenglish.io/using-typescript-mapped-types-like-a-pro-be10aef5511a" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">使用TypeScript像Pro一样映射类型</strong> </a></li><li id="3b5a" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://javascript.plainenglish.io/use-typescript-conditional-types-like-a-pro-7baea0ad05c5" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">使用TypeScript条件类型像亲</strong> </a></li><li id="5fd2" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" href="https://javascript.plainenglish.io/using-typescript-intersection-types-like-a-pro-a55da6a6a5f7" rel="noopener ugc nofollow" target="_blank"> <strong class="lb iu">使用TypeScript交集类型像亲</strong> </a></li><li id="5d29" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated"><a class="ae ky" rel="noopener ugc nofollow" target="_blank" href="/using-typescript-infer-like-a-pro-f30ab8ab41c7"> <strong class="lb iu">使用打字稿推断像亲</strong> </a></li></ul><p id="0854" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你用过Angular或者Nest.js，应该对decorators比较熟悉。</p><pre class="kj kk kl km gt mj mk ml bn mm mn bi"><span id="fc73" class="mo mp it mk b be mq mr l ms mt">import { Controller, Get } from '@nestjs/common';<br/><br/>@Controller('cats')<br/>export class CatsController {<br/>  @Get()<br/>  findAll(): string {<br/>    return 'This action returns all cats';<br/>  }<br/>}</span></pre><p id="4b5a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中<code class="fe mu mv mw mk b">@XXX</code>是语法糖，要启用实验装饰器特性你必须在命令行或<code class="fe mu mv mw mk b">tsconfig.json</code>文件中启用<code class="fe mu mv mw mk b">experimentalDecorators</code>编译器选项。</p><pre class="kj kk kl km gt mj mk ml bn mm mn bi"><span id="f44c" class="mo mp it mk b be mq mr l ms mt">{<br/>  "compilerOptions": {<br/>     "target": "es2016",<br/>     "experimentalDecorators": true<br/>   }<br/>}</span></pre><p id="485b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有四种主要类型的装饰者:</p><ul class=""><li id="4478" class="lv lw it lb b lc ld lf lg li lx lm ly lq lz lu ma mb mc md bi translated">类装饰者</li><li id="b4d3" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">物业装饰</li><li id="7c4d" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">方法装饰者</li><li id="4970" class="lv lw it lb b lc me lf mf li mg lm mh lq mi lu ma mb mc md bi translated">参数装饰器</li></ul><p id="3b8c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来，我将分别介绍这4类装修工。</p><h1 id="b5b7" class="mx mp it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">类装饰者</h1><p id="84cf" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">类装饰者，顾名思义，习惯于装饰类。对应于类装饰器的类型在<code class="fe mu mv mw mk b">lib.es5.d.ts</code>文件中定义:</p><pre class="kj kk kl km gt mj mk ml bn mm mn bi"><span id="bbed" class="mo mp it mk b be mq mr l ms mt">// node_modules/typescript/lib/lib.es5.d.ts<br/>declare type ClassDecorator = &lt;TFunction extends Function&gt;<br/>  (target: TFunction) =&gt; TFunction | void;</span></pre><p id="f8a5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">从类装饰器的类型定义中可以看出，它接收一个表示要装饰的类的参数。根据类装饰器的定义，我们可以创建一个<code class="fe mu mv mw mk b">Greeter</code>装饰器来给装饰后的类添加一个<code class="fe mu mv mw mk b">greet</code>方法:</p><pre class="kj kk kl km gt mj mk ml bn mm mn bi"><span id="a5d0" class="mo mp it mk b be mq mr l ms mt">// user.ts<br/>function Greeter(target: Function): void {<br/>  target.prototype.greet = function (): void {<br/>    console.log("Hello Bytefer!");<br/>  };<br/>}<br/><br/>@Greeter<br/>class User {}<br/><br/>let bytefer = new User();<br/>(bytefer as any).greet();</span></pre><p id="a493" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您成功运行上述代码时，终端将输出结果— <code class="fe mu mv mw mk b">Hello Bytefer!</code>。类装饰器看起来很简单，但现在问题来了。如果想自定义<code class="fe mu mv mw mk b">greet</code>方法的输出，应该怎么做？为了满足这个功能，我们需要使用<strong class="lb iu">装饰工厂</strong>。</p><h1 id="58c7" class="mx mp it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">装饰工厂</h1><p id="4c08" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">所谓装饰工厂，就是在被调用后，返回装饰器。利用高阶函数的特性，让我们更新前面定义的<code class="fe mu mv mw mk b">Greeter</code>函数:</p><pre class="kj kk kl km gt mj mk ml bn mm mn bi"><span id="09d9" class="mo mp it mk b be mq mr l ms mt">function Greeter(msg: string) {<br/>   return (target: Function): void =&gt; {<br/>    target.prototype.greet = function (): void {<br/>        console.log(msg);<br/>    };<br/>   }<br/>}</span></pre><p id="c335" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">更新完<code class="fe mu mv mw mk b">Greeter</code>装饰工厂后，我们需要以如下方式使用它:</p><pre class="kj kk kl km gt mj mk ml bn mm mn bi"><span id="ebe6" class="mo mp it mk b be mq mr l ms mt">@Greeter("Hello TypeScript!")<br/>class User {}<br/><br/>let bytefer = new User();<br/>(bytefer as any).greet();</span></pre><p id="5e60" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您成功运行上述代码时，终端将输出结果— <code class="fe mu mv mw mk b">Hello TypeScript!</code>。<strong class="lb iu">需要注意的是，我们可以为同一个类使用多个类装饰器。</strong>例如，在下面的代码中，我添加了一个<code class="fe mu mv mw mk b">Log</code>类装饰器:</p><pre class="kj kk kl km gt mj mk ml bn mm mn bi"><span id="c7bd" class="mo mp it mk b be mq mr l ms mt">function Log(target: Function): void {<br/>  target.prototype.log = (msg: string) =&gt; {<br/>    console.log(`From ${target.name}: `, msg);<br/>  };<br/>}<br/><br/>@Log<br/>@Greeter("Hello TypeScript!")<br/>class User {}<br/><br/>let bytefer = new User();<br/>(bytefer as any).greet();<br/>(bytefer as any).log("Hello Kakuqo!");</span></pre><p id="93f8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，我们向<code class="fe mu mv mw mk b">User</code>类添加了2个装饰器，之后，我们可以调用<code class="fe mu mv mw mk b">User</code>实例上的<code class="fe mu mv mw mk b">greet</code>和<code class="fe mu mv mw mk b">log</code>方法。</p><pre class="kj kk kl km gt mj mk ml bn mm mn bi"><span id="62f4" class="mo mp it mk b be mq mr l ms mt">Hello TypeScript!<br/>From User:  Hello Kakuqo!</span></pre><h1 id="bff0" class="mx mp it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">物业装饰</h1><p id="14c5" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">属性装饰器习惯于装饰类的属性。其对应的类型声明如下:</p><pre class="kj kk kl km gt mj mk ml bn mm mn bi"><span id="c938" class="mo mp it mk b be mq mr l ms mt">// node_modules/typescript/lib/lib.es5.d.ts<br/>declare type PropertyDecorator = <br/> (target: Object, propertyKey: string | symbol) =&gt; void;</span></pre><p id="f5f5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">属性装饰函数有两个参数:<code class="fe mu mv mw mk b">target</code>和<code class="fe mu mv mw mk b">property</code>。根据property decorator的定义，让我们定义一个property decorator <code class="fe mu mv mw mk b">logProperty</code>来跟踪用户对一个属性的操作。</p><pre class="kj kk kl km gt mj mk ml bn mm mn bi"><span id="712c" class="mo mp it mk b be mq mr l ms mt">function logProperty(target: any, key: string) {<br/>  let value = target[key];<br/><br/>  const getter = function () {<br/>    console.log(`Getter for ${key} returned ${value}`);<br/>    return value;<br/>  };<br/><br/>  const setter = function (newVal: any) {<br/>    console.log(`Set ${key} to ${newVal}`);<br/>    value = newVal;<br/>  };<br/><br/>  // Replace the property<br/>  if (delete target[key]) {<br/>    Object.defineProperty(target, key, {<br/>      get: getter,<br/>      set: setter,<br/>      enumerable: true,<br/>      configurable: true,<br/>    });<br/>  }<br/>}</span></pre><p id="7d47" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦我们有了<code class="fe mu mv mw mk b">logProperty</code>属性装饰器，我们就可以将它应用到类的属性上。例如，我在<code class="fe mu mv mw mk b">User</code>类的<code class="fe mu mv mw mk b">name</code>属性上使用了<code class="fe mu mv mw mk b">logProperty</code>装饰器:</p><pre class="kj kk kl km gt mj mk ml bn mm mn bi"><span id="5279" class="mo mp it mk b be mq mr l ms mt">class User {<br/>  @logProperty<br/>  public name: string;<br/><br/>  constructor(name: string) {<br/>    this.name = name;<br/>  }<br/>}<br/><br/>const user = new User("Bytefer");<br/>user.name = "Kakuqo";<br/>console.log(user.name);</span></pre><p id="9110" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您成功运行上述代码时，终端将输出结果:</p><pre class="kj kk kl km gt mj mk ml bn mm mn bi"><span id="5e40" class="mo mp it mk b be mq mr l ms mt">Set name to Bytefer<br/>Set name to Kakuqo<br/>Getter for name returned Kakuqo<br/>Kakuqo</span></pre><p id="3557" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除了能够修饰类的属性，我们还可以修饰类的方法。</p><h1 id="1538" class="mx mp it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">方法装饰者</h1><p id="6850" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">方法装饰者习惯于装饰类的方法。其对应的类型声明如下:</p><pre class="kj kk kl km gt mj mk ml bn mm mn bi"><span id="ae6e" class="mo mp it mk b be mq mr l ms mt">// node_modules/typescript/lib/lib.es5.d.ts<br/>declare type MethodDecorator = &lt;T&gt;(<br/>  target: Object, <br/>  propertyKey: string | symbol, <br/>  descriptor: TypedPropertyDescriptor&lt;T&gt;<br/>) =&gt; TypedPropertyDescriptor&lt;T&gt; | void;</span></pre><p id="cdc5" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">与属性装饰器相比，方法装饰器多了一个描述符参数。参数的类型如下:</p><pre class="kj kk kl km gt mj mk ml bn mm mn bi"><span id="e5a7" class="mo mp it mk b be mq mr l ms mt">interface TypedPropertyDescriptor&lt;T&gt; {<br/>    enumerable?: boolean;<br/>    configurable?: boolean;<br/>    writable?: boolean;<br/>    value?: T;<br/>    get?: () =&gt; T;<br/>    set?: (value: T) =&gt; void;<br/>}</span></pre><p id="7c42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果不需要使用泛型，也可以使用<code class="fe mu mv mw mk b">PropertyDescriptor</code>接口:</p><pre class="kj kk kl km gt mj mk ml bn mm mn bi"><span id="cc52" class="mo mp it mk b be mq mr l ms mt">interface PropertyDescriptor {<br/>    configurable?: boolean;<br/>    enumerable?: boolean;<br/>    value?: any;<br/>    writable?: boolean;<br/>    get?(): any;<br/>    set?(v: any): void;<br/>}</span></pre><p id="e39e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据方法装饰器的定义，让我们定义一个方法装饰器<code class="fe mu mv mw mk b">logMethod</code>来跟踪类成员方法的调用。</p><pre class="kj kk kl km gt mj mk ml bn mm mn bi"><span id="cbbd" class="mo mp it mk b be mq mr l ms mt">function logMethod(<br/>  target: Object,<br/>  propertyKey: string,<br/>  descriptor: PropertyDescriptor<br/>) {<br/>  let originalMethod = descriptor.value;<br/>  descriptor.value = function (...args: any[]) {<br/>    console.log(`Before invoking method: ${propertyKey}`);<br/>    let result = originalMethod.apply(this, args);<br/>    console.log(`After invoking method: ${propertyKey}`);<br/>    return result;<br/>  };<br/>}</span></pre><p id="53b0" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一旦我们有了<code class="fe mu mv mw mk b">logMethod</code>方法装饰器，我们就可以将它应用到类的成员方法上。例如，我在<code class="fe mu mv mw mk b">User</code>类的<code class="fe mu mv mw mk b">greet</code>成员方法上使用了<code class="fe mu mv mw mk b">logMethod</code>装饰器:</p><pre class="kj kk kl km gt mj mk ml bn mm mn bi"><span id="88ed" class="mo mp it mk b be mq mr l ms mt">class User {<br/>  @logMethod<br/>  greet(msg: string): string {<br/>    return `Hello ${msg}!`;<br/>  }<br/>}<br/><br/>let user = new User();<br/>let msg = user.greet("Bytefer");<br/>console.log(msg);</span></pre><p id="c37c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您成功运行上述代码时，终端将输出结果:</p><pre class="kj kk kl km gt mj mk ml bn mm mn bi"><span id="dc5f" class="mo mp it mk b be mq mr l ms mt">Before invoking method: greet<br/>After invoking method: greet<br/>Hello Bytefer!</span></pre><p id="bf1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">掌握了方法装饰器之后，我们就可以定义一些有用的方法装饰器了。如<code class="fe mu mv mw mk b">delay</code>、<code class="fe mu mv mw mk b">throttle</code>等。</p><p id="6a45" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">延迟</strong></p><pre class="kj kk kl km gt mj mk ml bn mm mn bi"><span id="51d9" class="mo mp it mk b be mq mr l ms mt">function delay(milliseconds: number = 0): any {<br/>  return function(target: any, propertyKey: string, descriptor: PropertyDescriptor) {<br/>    const originalMethod = descriptor.value;<br/><br/>    descriptor.value = function(...args) {<br/>      setTimeout(() =&gt; {<br/>        originalMethod.apply(this, args);<br/>      }, milliseconds);<br/>    };<br/>    return descriptor;<br/>  };<br/>}</span></pre><p id="a266" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">油门</strong></p><pre class="kj kk kl km gt mj mk ml bn mm mn bi"><span id="bceb" class="mo mp it mk b be mq mr l ms mt">const throttleFn = require('lodash.throttle');<br/><br/>function throttle(milliseconds: number = 0, options = {}): any {<br/>  return function(target: any, propertyKey: string, descriptor: PropertyDescriptor) {<br/>    const originalMethod = descriptor.value;<br/>    descriptor.value = throttleFn(originalMethod, milliseconds, options);<br/>    return descriptor;<br/>  };<br/>}</span></pre><p id="8d42" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们来介绍一下参数装饰器。</p><h1 id="1fe5" class="mx mp it bd my mz na nb nc nd ne nf ng jz nh ka ni kc nj kd nk kf nl kg nm nn bi translated">参数装饰器</h1><p id="6116" class="pw-post-body-paragraph kz la it lb b lc no ju le lf np jx lh li nq lk ll lm nr lo lp lq ns ls lt lu im bi translated">参数装饰器习惯于在方法中装饰参数。其对应的类型声明如下:</p><pre class="kj kk kl km gt mj mk ml bn mm mn bi"><span id="056b" class="mo mp it mk b be mq mr l ms mt">// node_modules/typescript/lib/lib.es5.d.ts<br/>declare type ParameterDecorator = (<br/> target: Object, <br/> propertyKey: string | symbol, <br/> parameterIndex: number) =&gt; void;</span></pre><p id="d12a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">根据参数装饰器的定义，我们来定义一个方法装饰器<code class="fe mu mv mw mk b">logParameter</code>:</p><pre class="kj kk kl km gt mj mk ml bn mm mn bi"><span id="20fe" class="mo mp it mk b be mq mr l ms mt">function logParameter(target: Object, key: string, parameterIndex: number) {<br/>  console.log(`The parameter in position ${parameterIndex} at ${key} has been decorated`);<br/>}</span></pre><p id="904c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了<code class="fe mu mv mw mk b">logParameter</code>装饰器，我们将它应用于<code class="fe mu mv mw mk b">User</code>类中<code class="fe mu mv mw mk b">greet</code>方法的msg参数:</p><pre class="kj kk kl km gt mj mk ml bn mm mn bi"><span id="49ad" class="mo mp it mk b be mq mr l ms mt">class User {<br/>  greet(@logParameter msg: string): void {<br/>    console.log(msg);<br/>  }<br/>}<br/><br/>let user = new User();<br/>user.greet("Bytefer");</span></pre><p id="7721" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当您成功运行上述代码时，终端将输出结果:</p><pre class="kj kk kl km gt mj mk ml bn mm mn bi"><span id="42b4" class="mo mp it mk b be mq mr l ms mt">The parameter in position 0 at greet has been decorated<br/>Bytefer</span></pre><p id="094b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">现在已经介绍了4个decorator，如果想知道decorator是如何工作的，可以使用<a class="ae ky" href="https://www.typescriptlang.org/play?#code/GYVwdgxgLglg9mABAcQE4FN1XagFFAQ1QHMsAuRAMXGnjAEoKA3OGAE0QG8AoRRQklgB0AB1RwoEgJ4j0Q4hiyIAvIlCRYCRLkaIW7Lrz6IICAM5wANnMtxiuAEQAJdJduIAQlOzAcAQgd6AG4jAF8Q0O5uAAE0TGxUbghLAjMzRABVMxwuSO5rKEQAI290X1QVRDB0AHdM7Lxg7lwSnxzUxAIwKXp5RSgdIKA" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu">TypeScript Playground</strong></a>查看编译好的JavaScript代码。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nt"><img src="../Images/aa1e7f1a2a8cb35fb62aa6b62200e29d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CNPKdwj62pwFqypLb1E-lQ.png"/></div></div></figure><p id="e9f9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在开发decorators时，我们通常也会使用<a class="ae ky" href="https://github.com/rbuckton/reflect-metadata" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu">reflect-metadata</strong></a>库来处理元信息。比如开发一个<strong class="lb iu"> IoC </strong>容器或者扩展一个web框架的功能。如果你想了解更多关于decorator的知识，我推荐你连夜阅读<a class="ae ky" href="https://github.com/seanpmaxwell/overnight" rel="noopener ugc nofollow" target="_blank"><strong class="lb iu"/></a>项目的源代码(TypeScript decorator for the express js Server。)，比Nest.js框架更容易理解。</p><p id="caf2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你喜欢学习TypeScript，可以在<a class="ae ky" href="https://medium.com/@bytefer" rel="noopener"> Medium </a>或者<a class="ae ky" href="https://twitter.com/Tbytefer" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上关注我，阅读更多关于TS和JS的内容！</p><div class="nu nv gp gr nw"><div role="button" tabindex="0" class="ab bv gv cb fp nx ny bn nz ks ex"><div class="oa l"><div class="ab q"><div class="l di"><img alt="Bytefer" class="l de bw ob oc fe" src="../Images/238cf2afd3c689b50719951ba2fd880d.png" width="20" height="20" loading="lazy" data-original-src="https://miro.medium.com/v2/resize:fill:40:40/1*krjVh9VFhDEcMUif4Ewt-A.png"/><div class="fb bw l ob oc fc n aw fd"/></div><div class="hh l fo"><p class="bd b dl z fp fq fr fs ft fu fv fw dk translated"><a class="ae af ag ah ai aj ak al am an ao ap aq ar as" href="https://medium.com/@bytefer?source=post_page-----daa9660f8286--------------------------------" rel="noopener follow" target="_top"> Bytefer </a></p></div></div><div class="of og gw l"><h2 class="bd iu tr lv fp ts fr fs tt fu fw is bi translated">掌握打字稿系列</h2></div><div class="ab q"><div class="l fo"><a class="bd b be z bi tu au tv tw tx qa ty an eh ei tz ua ub el em eo de bk ep" href="https://medium.com/@bytefer/list/mastering-typescript-series-688ee7c12807?source=post_page-----daa9660f8286--------------------------------" rel="noopener follow" target="_top">View list</a></div><div class="uc l fo"><span class="bd b dl z dk">46 stories</span></div></div></div><div class="os dh ot fp ab ou fo di"><div class="di ok bv ol om"><div class="dh l"><img alt="" class="dh" src="../Images/373c978fed504a3c38f0fdb5b617fedb.png" width="194" height="194" loading="lazy" role="presentation" data-original-src="https://miro.medium.com/v2/resize:fill:388:388/0*94uN4q2Of_fg3WaQ"/></div></div><div class="di ok bv on oo op"><div class="dh l"><img alt="" class="dh" src="../Images/a8ea3e3ecad1c2d2697107f3ce466e42.png" width="194" height="194" loading="lazy" role="presentation" data-original-src="https://miro.medium.com/v2/resize:fill:388:388/0*tGza_iE2o--HjQwD"/></div></div><div class="di bv oq or op"><div class="dh l"><img alt="" class="dh" src="../Images/3bcc671d9b1ca5776fec258eed5450d4.png" width="194" height="194" loading="lazy" role="presentation" data-original-src="https://miro.medium.com/v2/resize:fill:388:388/0*_U9uNpcZaTLX4u4B"/></div></div></div></div></div></div></div>    
</body>
</html>