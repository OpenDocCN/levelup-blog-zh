<html>
<head>
<title>Handling User Input in Rich Browser Apps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在富浏览器应用中处理用户输入</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/handling-user-input-in-rich-browser-apps-a73a951d03f0?source=collection_archive---------4-----------------------#2020-11-21">https://levelup.gitconnected.com/handling-user-input-in-rich-browser-apps-a73a951d03f0?source=collection_archive---------4-----------------------#2020-11-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b83e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">处理鼠标和键盘事件的正确架构</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/132a6b3d257d4282d17d5ea7864ffc53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*80MfttA1frzH4q_DFPqBrw.jpeg"/></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk translated">混乱的事件处理</figcaption></figure><h1 id="26cb" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">简单应用</h1><p id="9549" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">浏览器(JavaScript)对于处理用户输入非常有帮助。例如:</p><blockquote class="mf mg mh"><p id="82f1" class="lj lk mi ll b lm mj jr lo lp mk ju lr ml mm lu lv mn mo ly lz mp mq mc md me ij bi translated">var done button = document . getelementbyid(" done ")<br/>done button . onclick = function(){ sendDataToServer()}</p></blockquote><p id="514b" class="pw-post-body-paragraph lj lk iq ll b lm mj jr lo lp mk ju lr ls mm lu lv lw mo ly lz ma mq mc md me ij bi translated">这是一个简单明了的代码，非常适合下面的上下文。</p><ol class=""><li id="6f59" class="mr ms iq ll b lm mj lp mk ls mt lw mu ma mv me mw mx my mz bi translated">用户花一分钟时间用他的数据填写表单。</li><li id="40b6" class="mr ms iq ll b lm na lp nb ls nc lw nd ma ne me mw mx my mz bi translated">用户点击“完成”按钮。</li><li id="0f20" class="mr ms iq ll b lm na lp nb ls nc lw nd ma ne me mw mx my mz bi translated">用户等待页面更新两秒钟，他认为这是可以接受的。</li></ol><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/a0f1cce0250cc08a5d5500d75bbf69f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/1*ez4nhS67DuZ1pU4ig7qAXA.png"/></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk translated">简单的程序</figcaption></figure><p id="5a5f" class="pw-post-body-paragraph lj lk iq ll b lm mj jr lo lp mk ju lr ls mm lu lv lw mo ly lz ma mq mc md me ij bi translated">让我们假设客户端不检查数据；客户机<strong class="ll ir">只需向服务器</strong>发送任何东西(甚至是空白表格)。因此，您只需要编写客户端代码来处理一个事件:单击按钮。</p><p id="eafa" class="pw-post-body-paragraph lj lk iq ll b lm mj jr lo lp mk ju lr ls mm lu lv lw mo ly lz ma mq mc md me ij bi translated">当然，每次用户输入一个字母，在字段中写下他的名字也是一个事件。但是您不必编写代码来处理这个事件，因为浏览器会自动处理。</p><p id="738d" class="pw-post-body-paragraph lj lk iq ll b lm mj jr lo lp mk ju lr ls mm lu lv lw mo ly lz ma mq mc md me ij bi translated">现在，用户可以做什么来破坏客户端？</p><ol class=""><li id="56d0" class="mr ms iq ll b lm mj lp mk ls mt lw mu ma mv me mw mx my mz bi translated">关闭页面？</li><li id="b849" class="mr ms iq ll b lm na lp nb ls nc lw nd ma ne me mw mx my mz bi translated">在输入他的名字时点击“完成”按钮？</li><li id="b9f1" class="mr ms iq ll b lm na lp nb ls nc lw nd ma ne me mw mx my mz bi translated">发空白表格？</li><li id="86df" class="mr ms iq ll b lm na lp nb ls nc lw nd ma ne me mw mx my mz bi translated">在应该只有数字的地方写信？</li></ol><p id="9ce4" class="pw-post-body-paragraph lj lk iq ll b lm mj jr lo lp mk ju lr ls mm lu lv lw mo ly lz ma mq mc md me ij bi translated">他们中没有一个会让客户崩溃，甚至他们的组合也不会。并且用户将知道他应该为任何失败负责。客户很好。该应用程序似乎是可靠的！</p></div><div class="ab cl ng nh hu ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ij ik il im in"><h1 id="8cad" class="kr ks iq bd kt ku nn kw kx ky no la lb jw np jx ld jz nq ka lf kc nr kd lh li bi translated">复杂应用</h1><p id="cfb3" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">让我们考虑一个基于浏览器的绘图/绘画工具作为我们的复杂应用程序。这与简单的线性应用程序有着重要的区别。</p><p id="0cdc" class="pw-post-body-paragraph lj lk iq ll b lm mj jr lo lp mk ju lr ls mm lu lv lw mo ly lz ma mq mc md me ij bi translated">首先，绘画工具必须绝对<strong class="ll ir">灵敏</strong>。用户在画布上拖动鼠标的同时，画布必须显示结果。代码必须真正<strong class="ll ir">高效</strong>。</p><p id="720d" class="pw-post-body-paragraph lj lk iq ll b lm mj jr lo lp mk ju lr ls mm lu lv lw mo ly lz ma mq mc md me ij bi translated">第二，应用程序必须绝对<strong class="ll ir">可靠</strong>。它永远不会崩溃或让用户丢失他的工作，即使当他受到责备(关闭浏览器标签)。在表单上填写管理数据只需两分钟，不需要任何灵感。但是失去那件独一无二的珍贵艺术品是一个戏剧性的事件！哪个艺人是<strong class="ll ir">不是</strong>容易发生<strong class="ll ir">再发生</strong>(拜拜app)。</p><p id="f299" class="pw-post-body-paragraph lj lk iq ll b lm mj jr lo lp mk ju lr ls mm lu lv lw mo ly lz ma mq mc md me ij bi translated">第三，基本上所有的事情都发生在canvas元素上，你必须处理每一个最小的输入。浏览器不会像创建文本框那样有用。</p><p id="f97f" class="pw-post-body-paragraph lj lk iq ll b lm mj jr lo lp mk ju lr ls mm lu lv lw mo ly lz ma mq mc md me ij bi translated">对于本文的目的来说，这3个关键区别就足够了。</p><h2 id="020f" class="ns ks iq bd kt nt nu dn kx nv nw dp lb ls nx ny ld lw nz oa lf ma ob oc lh od bi translated">指导原则</h2><p id="6d6c" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">考虑到上面的文字，我们得出了一条黄金法则，它将指导我们为复杂的应用程序编写代码:</p><blockquote class="mf mg mh"><p id="7640" class="lj lk mi ll b lm mj jr lo lp mk ju lr ml mm lu lv mn mo ly lz mp mq mc md me ij bi translated">在接收下一个 输入之前，应用程序必须<strong class="ll ir"> <em class="iq">完全处理任何输入。</em></strong></p></blockquote><p id="1107" class="pw-post-body-paragraph lj lk iq ll b lm mj jr lo lp mk ju lr ls mm lu lv lw mo ly lz ma mq mc md me ij bi translated">否则应用程序将无法响应。严重超载时根本不可靠。</p><h2 id="094d" class="ns ks iq bd kt nt nu dn kx nv nw dp lb ls nx ny ld lw nz oa lf ma ob oc lh od bi translated">小型会议</h2><p id="4b2d" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">本文中的<strong class="ll ir"> <em class="mi">画布</em> </strong>指的是HTMLCanvasElement。而<strong class="ll ir"> <em class="mi">层</em> </strong>是指在画布上绘制的虚拟绘画面。它们的大小可以完全不同。并且该层可以位于画布的任何部分。</p><h2 id="0a8f" class="ns ks iq bd kt nt nu dn kx nv nw dp lb ls nx ny ld lw nz oa lf ma ob oc lh od bi translated">像素信息</h2><p id="fe30" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">丰富的绘图/绘画工具的一个基本特性是在鼠标下给出层像素的反馈。用户只需将鼠标光标放在任何像素上，就可以检查其颜色和位置。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/f1ffbda0e803168c5d9d23925a2adc8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*EzolBt4QH9QADsh6dIx52Q.png"/></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk translated">伪代码</figcaption></figure><p id="d7ac" class="pw-post-body-paragraph lj lk iq ll b lm mj jr lo lp mk ju lr ls mm lu lv lw mo ly lz ma mq mc md me ij bi translated">上面代码中的一些备注说明了处理函数的成本。“智能”意味着这个函数有一个昂贵的部分，如果需要的话就运行，否则处理起来就很便宜。</p><p id="4277" class="pw-post-body-paragraph lj lk iq ll b lm mj jr lo lp mk ju lr ls mm lu lv lw mo ly lz ma mq mc md me ij bi translated">到目前为止，一切顺利！我们有一个干净简单的代码。而且它看起来很有效率。</p><h2 id="5d65" class="ns ks iq bd kt nt nu dn kx nv nw dp lb ls nx ny ld lw nz oa lf ma ob oc lh od bi translated">这并不容易</h2><p id="cd1a" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">上面的代码有重要的问题。抱歉。</p><ol class=""><li id="5728" class="mr ms iq ll b lm mj lp mk ls mt lw mu ma mv me mw mx my mz bi translated">假设用户想要将层旋转90度。他只是在键盘上输入“R”。而鼠标下的图层像素变成了另一个(坐标不同，颜色可能偶然相同)。但是，由于没有引发鼠标移动事件，因此不会调用函数<strong class="ll ir"><em class="mi">updatePixelInfo</em></strong>！我们的应用程序显示了关于鼠标下像素的错误值。不靠谱！</li><li id="5bd1" class="mr ms iq ll b lm na lp nb ls nc lw nd ma ne me mw mx my mz bi translated">假设用户在画布上快速移动鼠标。比方说，鼠标在30毫秒内超过600个像素。这意味着您有不到0.05毫秒的(*)时间来完全处理每个输入(不要忘记<strong class="ll ir">黄金法则</strong>)。我们不能阻止用户进行此操作。我们的代码在这方面不够高效。因此，应用程序将累积要处理的事件，变得没有响应(至少没有完全响应，因为它必须如此)。幸运的是，硬件、操作系统和/或浏览器跳过了许多这样的输入。所以我们将收到少于600个鼠标移动事件来处理。尽管如此，这个应用程序可能会打破<strong class="ll ir">黄金法则</strong>。</li></ol><blockquote class="mf mg mh"><p id="5051" class="lj lk mi ll b lm mj jr lo lp mk ju lr ml mm lu lv mn mo ly lz mp mq mc md me ij bi translated">(*)我们总是从理论上计算一个程序有多少时间。在的实践中，可用时间是理论时间的一半，通常是三分之一，因为操作系统和浏览器还有其他任务要运行。</p></blockquote><p id="5e45" class="pw-post-body-paragraph lj lk iq ll b lm mj jr lo lp mk ju lr ls mm lu lv lw mo ly lz ma mq mc md me ij bi translated">3.假设用户重复“2”中描述的快速鼠标移动，但这次他不只是移动鼠标。他正在拖动鼠标，希望画一条(连续的)线。现在，除了给出关于鼠标下像素的反馈，我们用一个更加密集/昂贵的任务来强调应用程序，绘制图层:</p><ul class=""><li id="413e" class="mr ms iq ll b lm mj lp mk ls mt lw mu ma mv me of mx my mz bi translated">改变图层像素(昂贵)</li><li id="e909" class="mr ms iq ll b lm na lp nb ls nc lw nd ma ne me of mx my mz bi translated">为撤销/重做记忆层(非常昂贵)</li><li id="fcc7" class="mr ms iq ll b lm na lp nb ls nc lw nd ma ne me of mx my mz bi translated">用改变的图层更新画布(非常昂贵)</li></ul><p id="025c" class="pw-post-body-paragraph lj lk iq ll b lm mj jr lo lp mk ju lr ls mm lu lv lw mo ly lz ma mq mc md me ij bi translated">这是不可能的。记得那部分“幸运的是，硬件…跳过这么多输入。”？当用户想要画线时，跳过鼠标移动(拖动)输入将会产生一条有巨大间隙的线。</p></div><div class="ab cl ng nh hu ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ij ik il im in"><p id="05f7" class="pw-post-body-paragraph lj lk iq ll b lm mj jr lo lp mk ju lr ls mm lu lv lw mo ly lz ma mq mc md me ij bi translated">注意:由于浏览器画布中没有鼠标拖动事件，我们必须重构鼠标移动事件处理程序(如果鼠标按钮被按下，那么…)。</p><h2 id="dbc6" class="ns ks iq bd kt nt nu dn kx nv nw dp lb ls nx ny ld lw nz oa lf ma ob oc lh od bi translated">一个注定要崩溃的建筑</h2><p id="845b" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">请注意我们的应用程序在执行3个非常<strong class="ll ir">基本</strong>动作中的<strong class="ll ir">个动作时是如何失败的:</strong></p><ul class=""><li id="0100" class="mr ms iq ll b lm mj lp mk ls mt lw mu ma mv me of mx my mz bi translated">通过键盘输入改变图层后给出像素反馈</li><li id="18ed" class="mr ms iq ll b lm na lp nb ls nc lw nd ma ne me of mx my mz bi translated">快速移动鼠标时提供像素反馈</li><li id="5b47" class="mr ms iq ll b lm na lp nb ls nc lw nd ma ne me of mx my mz bi translated">快速画线(不需要很快)</li></ul><p id="66db" class="pw-post-body-paragraph lj lk iq ll b lm mj jr lo lp mk ju lr ls mm lu lv lw mo ly lz ma mq mc md me ij bi translated">想象一个更复杂的应用，比如画一个椭圆，它需要处理一个不可见的覆盖层，在标准层上画之前调整它的形状和大小…</p></div><div class="ab cl ng nh hu ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ij ik il im in"><h2 id="fe51" class="ns ks iq bd kt nt nu dn kx nv nw dp lb ls nx ny ld lw nz oa lf ma ob oc lh od bi translated">事件处理程序的权力过大</h2><p id="4bf9" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">您无法控制该应用程序</p><p id="a084" class="pw-post-body-paragraph lj lk iq ll b lm mj jr lo lp mk ju lr ls mm lu lv lw mo ly lz ma mq mc md me ij bi translated">每次一个事件被引发，他的处理程序<strong class="ll ir">就会不假思索地启动函数</strong>(有些非常昂贵)<strong class="ll ir">！</strong></p><blockquote class="mf mg mh"><p id="9765" class="lj lk mi ll b lm mj jr lo lp mk ju lr ml mm lu lv mn mo ly lz mp mq mc md me ij bi translated">不是用户、浏览器和/或操作系统引发了要处理的“过多”事件。是我们的事件处理程序设计得不好。</p></blockquote><p id="594f" class="pw-post-body-paragraph lj lk iq ll b lm mj jr lo lp mk ju lr ls mm lu lv lw mo ly lz ma mq mc md me ij bi translated">我们需要找到一种方法来对事件进行分类:</p><ul class=""><li id="9baf" class="mr ms iq ll b lm mj lp mk ls mt lw mu ma mv me of mx my mz bi translated">哪些事件我们应该完全忽略</li><li id="2c68" class="mr ms iq ll b lm na lp nb ls nc lw nd ma ne me of mx my mz bi translated">哪些事件我们应该完全处理</li><li id="3cdc" class="mr ms iq ll b lm na lp nb ls nc lw nd ma ne me of mx my mz bi translated">我们将部分处理哪些事件</li></ul></div><div class="ab cl ng nh hu ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ij ik il im in"><p id="4727" class="pw-post-body-paragraph lj lk iq ll b lm mj jr lo lp mk ju lr ls mm lu lv lw mo ly lz ma mq mc md me ij bi translated">考虑在非常快速和长时间鼠标移动期间给出像素反馈的情况。我们只需要(并且应该)显示鼠标下当前像素的信息。为此，每一个旧的、未处理的鼠标事件都被定义为过时！我们必须忽略它们；没有完全处理它们。</p></div><div class="ab cl ng nh hu ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ij ik il im in"><p id="ebed" class="pw-post-body-paragraph lj lk iq ll b lm mj jr lo lp mk ju lr ls mm lu lv lw mo ly lz ma mq mc md me ij bi translated">考虑通过(非常)快速地移动鼠标来画线情况。我们需要创建一个表示鼠标路径的点列表。然后使用插值来填充路径中的间隙。当然，我们不打算在20毫秒内进行600次非常昂贵的全过程绘画，或者类似的事情。</p></div><div class="ab cl ng nh hu ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ij ik il im in"><h2 id="fe6e" class="ns ks iq bd kt nt nu dn kx nv nw dp lb ls nx ny ld lw nz oa lf ma ob oc lh od bi translated">函数的链接</h2><p id="0ade" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">你无法控制代码</p><p id="f842" class="pw-post-body-paragraph lj lk iq ll b lm mj jr lo lp mk ju lr ls mm lu lv lw mo ly lz ma mq mc md me ij bi translated">还记得那个好看的函数<strong class="ll ir"><em class="mi">updatePixelInfo</em></strong>吗？当我们阅读代码时，这看起来很好，但当运行应用程序时，这是一个悲剧。它的一个问题是，如果鼠标下的层像素在不移动鼠标(通过使用键盘旋转层)的情况下发生变化，它将不起作用。</p><blockquote class="mf mg mh"><p id="15be" class="lj lk mi ll b lm mj jr lo lp mk ju lr ml mm lu lv mn mo ly lz mp mq mc md me ij bi translated">一个<strong class="ll ir">线性</strong>架构，带有链式函数(A调用B，B调用C，C调用D…)注定<strong class="ll ir">在这个环境中</strong>会失败:一个事件机器。</p></blockquote><p id="a62c" class="pw-post-body-paragraph lj lk iq ll b lm mj jr lo lp mk ju lr ls mm lu lv lw mo ly lz ma mq mc md me ij bi translated">线性架构(在这个环境中)使得代码<strong class="ll ir">不可维护</strong>。</p></div><div class="ab cl ng nh hu ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ij ik il im in"><h1 id="c700" class="kr ks iq bd kt ku nn kw kx ky no la lb jw np jx ld jz nq ka lf kc nr kd lh li bi translated"><strong class="ak">万恶之源</strong></h1><p id="c2f9" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">(在复杂的应用程序中)</p><blockquote class="mf mg mh"><p id="c32a" class="lj lk mi ll b lm mj jr lo lp mk ju lr ml mm lu lv mn mo ly lz mp mq mc md me ij bi translated">所有<strong class="ll ir">邪恶</strong>的根源是<strong class="ll ir">调用</strong>一个函数的事件处理程序。</p></blockquote><p id="b102" class="pw-post-body-paragraph lj lk iq ll b lm mj jr lo lp mk ju lr ls mm lu lv lw mo ly lz ma mq mc md me ij bi translated">我所说的“功能”是指代码的其他重要部分。我说的不是像事件处理程序的子例程那样工作的小函数(帮助组织代码的片段)。</p><blockquote class="mf mg mh"><p id="b592" class="lj lk mi ll b lm mj jr lo lp mk ju lr ml mm lu lv mn mo ly lz mp mq mc md me ij bi translated">在一个复杂的应用程序中，一个事件处理器应该<strong class="ll ir">只向其他函数发送信号</strong>，<strong class="ll ir">不调用</strong>。</p></blockquote></div><div class="ab cl ng nh hu ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ij ik il im in"><h1 id="e2ea" class="kr ks iq bd kt ku nn kw kx ky no la lb jw np jx ld jz nq ka lf kc nr kd lh li bi translated">解决方案:事件驱动架构</h1><p id="2e3c" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">事件驱动架构是解决所有<strong class="ll ir">效率</strong>问题，让代码变得极具<strong class="ll ir">维护性</strong>的<strong class="ll ir">关键</strong>！</p><blockquote class="mf mg mh"><p id="506a" class="lj lk mi ll b lm mj jr lo lp mk ju lr ml mm lu lv mn mo ly lz mp mq mc md me ij bi translated">我们用松耦合的<strong class="ll ir">函数代替了<strong class="ll ir">链式</strong>函数！</strong></p></blockquote><p id="ae20" class="pw-post-body-paragraph lj lk iq ll b lm mj jr lo lp mk ju lr ls mm lu lv lw mo ly lz ma mq mc md me ij bi translated">同样，我指的是广义上的“功能”；具有特定角色的软件组件。</p><p id="af18" class="pw-post-body-paragraph lj lk iq ll b lm mj jr lo lp mk ju lr ls mm lu lv lw mo ly lz ma mq mc md me ij bi translated">一个函数不调用另一个函数。一个函数<strong class="ll ir"> <em class="mi">甚至不知道其他函数</em> </strong>的存在！它只是向系统提供它的产品，如此而已。</p><p id="9db0" class="pw-post-body-paragraph lj lk iq ll b lm mj jr lo lp mk ju lr ls mm lu lv lw mo ly lz ma mq mc md me ij bi translated">这是总的思路。当然，一定存在一些例外。</p></div><div class="ab cl ng nh hu ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ij ik il im in"><h2 id="68da" class="ns ks iq bd kt nt nu dn kx nv nw dp lb ls nx ny ld lw nz oa lf ma ob oc lh od bi translated">实施概念</h2><p id="2521" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">首先，我们如下所述定义模块。我所说的“模块”指的是用相关函数(一些是公共的，一些是私有的)编写的任何文件，这些函数执行一个<strong class="ll ir"> <em class="mi">独占/独立的角色</em> </strong>。</p><ul class=""><li id="61e9" class="mr ms iq ll b lm mj lp mk ls mt lw mu ma mv me of mx my mz bi translated">“main.js”是所有其他模块的<strong class="ll ir">管理器</strong></li><li id="3519" class="mr ms iq ll b lm na lp nb ls nc lw nd ma ne me of mx my mz bi translated">“mouse.js”处理所有鼠标事件</li><li id="58fc" class="mr ms iq ll b lm na lp nb ls nc lw nd ma ne me of mx my mz bi translated">“keyboard.js”处理<strong class="ll ir">所有键盘事件</strong></li><li id="8201" class="mr ms iq ll b lm na lp nb ls nc lw nd ma ne me of mx my mz bi translated">几十个有特定任务的模块；比如创建界面、更新界面、绘制、撤销/重做、保存/加载、旋转等..</li></ul><blockquote class="mf mg mh"><p id="c5f0" class="lj lk mi ll b lm mj jr lo lp mk ju lr ml mm lu lv mn mo ly lz mp mq mc md me ij bi translated">模块“main.js”是<strong class="ll ir"> <em class="iq">枢纽，命令所有其他模块</em> </strong>。基本上，这是唯一允许调用其他模块中函数的模块。</p><p id="85d3" class="lj lk mi ll b lm mj jr lo lp mk ju lr ml mm lu lv mn mo ly lz mp mq mc md me ij bi translated">所有其他模块<strong class="ll ir"> <em class="iq">只允许读取任何其他模块中的全局变量</em> </strong>。</p></blockquote><p id="a89c" class="pw-post-body-paragraph lj lk iq ll b lm mj jr lo lp mk ju lr ls mm lu lv lw mo ly lz ma mq mc md me ij bi translated">也许我们现在需要的是一点伪代码。就这样吧！</p><p id="5ed2" class="pw-post-body-paragraph lj lk iq ll b lm mj jr lo lp mk ju lr ls mm lu lv lw mo ly lz ma mq mc md me ij bi translated">警告:这个伪代码<strong class="ll ir">非常简单。</strong>它遗漏了很多本质特征，它的唯一目的是<strong class="ll ir"> <em class="mi">阐明</em> </strong>的概念。</p></div><div class="ab cl ng nh hu ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ij ik il im in"><h2 id="c32b" class="ns ks iq bd kt nt nu dn kx nv nw dp lb ls nx ny ld lw nz oa lf ma ob oc lh od bi translated"><strong class="ak">模块main.js </strong></h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/cdb5de391496b69e8722c996674d0b1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*PWUtUowVwD-IReK2HdFVAw.png"/></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk translated">模块main.js</figcaption></figure><p id="3c5e" class="pw-post-body-paragraph lj lk iq ll b lm mj jr lo lp mk ju lr ls mm lu lv lw mo ly lz ma mq mc md me ij bi translated">这是我们应用程序的大脑。在这里做出决定。<strong class="ll ir"> <em class="mi"> setTask </em> </strong>是功能模块“mouse.js”和“keyboard.js”处理输入事件后的调用。</p><p id="fb3c" class="pw-post-body-paragraph lj lk iq ll b lm mj jr lo lp mk ju lr ls mm lu lv lw mo ly lz ma mq mc md me ij bi translated">并且<strong class="ll ir"> <em class="mi"> setTask </em> </strong>可以接受或者拒绝任务。但是即使它接受任务，<strong class="ll ir"> <em class="mi"> setTask </em> </strong> <strong class="ll ir">也从不</strong>运行任务！！！它只是记忆任务，在下一次执行<strong class="ll ir"> <em class="mi"> runMainLoop时运行。</em> </strong></p><p id="dac3" class="pw-post-body-paragraph lj lk iq ll b lm mj jr lo lp mk ju lr ls mm lu lv lw mo ly lz ma mq mc md me ij bi translated">无论晴雨，这里都是(已处理的)输入事件的终点。</p><p id="7633" class="pw-post-body-paragraph lj lk iq ll b lm mj jr lo lp mk ju lr ls mm lu lv lw mo ly lz ma mq mc md me ij bi translated">用户/浏览器/系统可能每秒引发数千个输入事件。没问题。我们的应用程序每个循环只运行一个任务(16.666毫秒)。当然我们需要一个聪明的代码来避免，例如，一条画出来的线有任何空隙。</p><h2 id="5d06" class="ns ks iq bd kt nt nu dn kx nv nw dp lb ls nx ny ld lw nz oa lf ma ob oc lh od bi translated">模块mouse.js</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/0d0fad26504206a263f90f53aa9641bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*XSBKCLiGCnJB5NwIgUxhCQ.png"/></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk translated">模块mouse.js</figcaption></figure><p id="b009" class="pw-post-body-paragraph lj lk iq ll b lm mj jr lo lp mk ju lr ls mm lu lv lw mo ly lz ma mq mc md me ij bi translated">模块“mouse.js”的第一个职责是将鼠标位置的信息发布给任何想要的人(通过更新它的公共全局变量)。</p><p id="fd83" class="pw-post-body-paragraph lj lk iq ll b lm mj jr lo lp mk ju lr ls mm lu lv lw mo ly lz ma mq mc md me ij bi translated">该模块将<strong class="ll ir"> <em class="mi">画布</em> </strong> <em class="mi">坐标</em>处理成有用的<strong class="ll ir"> <em class="mi">图层</em> </strong> <em class="mi">坐标，</em>是其他模块要消耗的坐标。</p><p id="34f2" class="pw-post-body-paragraph lj lk iq ll b lm mj jr lo lp mk ju lr ls mm lu lv lw mo ly lz ma mq mc md me ij bi translated">它的第二个职责是，在适当的时候，调用“main.js”模块中的<strong class="ll ir"> <em class="mi"> setTask </em> </strong>:</p><blockquote class="mf mg mh"><p id="d83d" class="lj lk mi ll b lm mj jr lo lp mk ju lr ml mm lu lv mn mo ly lz mp mq mc md me ij bi translated">“嘿，用户希望执行这个任务(绘图)。现在就看你的了。祝你好运。我到此为止！”。</p></blockquote><p id="c58e" class="pw-post-body-paragraph lj lk iq ll b lm mj jr lo lp mk ju lr ls mm lu lv lw mo ly lz ma mq mc md me ij bi translated">注意:我认为处理输入事件不是一项职责。这是内在机制。它是模块如何履行其对“社区”的职责。</p><h2 id="bca5" class="ns ks iq bd kt nt nu dn kx nv nw dp lb ls nx ny ld lw nz oa lf ma ob oc lh od bi translated">模块keyboard.js</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/fd2b6933c05a5cc01757b65a793936bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*n83NINGpxkl2fhgagXtfVQ.png"/></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk translated">模块keyboard.js</figcaption></figure><p id="a783" class="pw-post-body-paragraph lj lk iq ll b lm mj jr lo lp mk ju lr ls mm lu lv lw mo ly lz ma mq mc md me ij bi translated">这是一个简单的模块。我们可以清楚地看到它作为接口的作用。在它调用<strong class="ll ir"> <em class="mi"> setTask </em> </strong>之后，程序不知道那个键被按下或者是否有任何事件被引发。它只知道要执行的任务(如果接受的话)。</p><p id="5ec0" class="pw-post-body-paragraph lj lk iq ll b lm mj jr lo lp mk ju lr ls mm lu lv lw mo ly lz ma mq mc md me ij bi translated">没有要处理/释放以供以后使用的数据。</p><p id="d0c1" class="pw-post-body-paragraph lj lk iq ll b lm mj jr lo lp mk ju lr ls mm lu lv lw mo ly lz ma mq mc md me ij bi translated">像“mouse.js”一样，它在调用<strong class="ll ir"> <em class="mi"> setTask </em> </strong>之前不检查task是否为空，因为这个决定不是由它决定的。决策不是它的<strong class="ll ir">角色</strong>！</p><h2 id="ffb8" class="ns ks iq bd kt nt nu dn kx nv nw dp lb ls nx ny ld lw nz oa lf ma ob oc lh od bi translated">模块接口. js</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/bb4ba70f0094e1da0fac51403d5c8e32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*ke4gcAmBDFdUfvSr6mTjzQ.png"/></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk translated">模块接口. js</figcaption></figure><p id="5d56" class="pw-post-body-paragraph lj lk iq ll b lm mj jr lo lp mk ju lr ls mm lu lv lw mo ly lz ma mq mc md me ij bi translated">还记得当层被键盘事件旋转时我们不得不更新像素信息的问题吗(因为<strong class="ll ir"><em class="mi">updatePixelInfo</em></strong>被绑定到鼠标事件)？解决了！</p><p id="df70" class="pw-post-body-paragraph lj lk iq ll b lm mj jr lo lp mk ju lr ls mm lu lv lw mo ly lz ma mq mc md me ij bi translated">我们可以随时调用<strong class="ll ir"><em class="mi">updateMousePositionLabel</em></strong>。不需要告知鼠标的坐标。模块“mouse.js”使它们始终可用。</p></div><div class="ab cl ng nh hu ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ij ik il im in"><h2 id="7ea5" class="ns ks iq bd kt nt nu dn kx nv nw dp lb ls nx ny ld lw nz oa lf ma ob oc lh od bi translated">生命的火花</h2><p id="fe68" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">有3个“火花”来源使我们的应用程序活跃(运行)。</p><p id="4ecb" class="pw-post-body-paragraph lj lk iq ll b lm mj jr lo lp mk ju lr ls mm lu lv lw mo ly lz ma mq mc md me ij bi translated">鼠标事件，键盘事件，以及定时器(<strong class="ll ir"><em class="mi">requestAnimationFrame</em></strong><em class="mi">)</em>。</p><p id="67c8" class="pw-post-body-paragraph lj lk iq ll b lm mj jr lo lp mk ju lr ls mm lu lv lw mo ly lz ma mq mc md me ij bi translated">我们的代码被设计来使用和协调这些火花。如果你写了一个像样的代码，你可以放心，一切都会运行良好。这些火花不是我们代码的发明。它们是由浏览器创建的。我们正在处理它们。</p><h2 id="15c6" class="ns ks iq bd kt nt nu dn kx nv nw dp lb ls nx ny ld lw nz oa lf ma ob oc lh od bi translated">最后</h2><p id="0092" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">希望对您有所帮助！</p></div></div>    
</body>
</html>