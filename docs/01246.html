<html>
<head>
<title>Deploy your NextJS Application on a different base path (i.e. not root)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将NextJS应用程序部署在不同的基路径上(即非根目录)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/deploy-your-nextjs-application-on-a-different-base-path-i-e-not-root-1c4d210cce8a?source=collection_archive---------0-----------------------#2019-12-05">https://levelup.gitconnected.com/deploy-your-nextjs-application-on-a-different-base-path-i-e-not-root-1c4d210cce8a?source=collection_archive---------0-----------------------#2019-12-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/9e1c18d4033a82dd37a647d038558501.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zAiDd5TnE8E1fBbd6HPD2g.jpeg"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://www.pexels.com/@skitterphoto?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">摄影师</a>从<a class="ae kf" href="https://www.pexels.com/photo/architectural-design-architecture-brick-wall-bricks-422844/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">像素</a>拍摄</figcaption></figure><p id="9b28" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">NextJS的一个默认假设是，我们将在域的根路径上部署我们的应用程序——这是<code class="fe le lf lg lh b">/</code>。NextJS路由将<code class="fe le lf lg lh b">pages</code>文件夹中的每个文件转换成匹配的路径。因此，如果我们有一个名为<code class="fe le lf lg lh b">./pages/index.js</code>的文件，它与<code class="fe le lf lg lh b">/</code>匹配，对于一个名为<code class="fe le lf lg lh b">./pages/about.js</code>的文件，它将在<code class="fe le lf lg lh b">/about</code>被访问。这是一个非常简单的方案，基本上就是超链接访问资源的方式。要链接两个页面，您只需:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="7e69" class="lq lr it lh b gy ls lt l lu lv">import Link from 'next/link'</span><span id="874e" class="lq lr it lh b gy lw lt l lu lv"><br/>const Index = () =&gt; (<br/>  &lt;div&gt;<br/>    ...<br/>    &lt;Link href='/about'&gt;&lt;a&gt;About Us&lt;/a&gt;&lt;/Link&gt;<br/>    ...<br/>  &lt;/div&gt;<br/>)</span><span id="d73d" class="lq lr it lh b gy lw lt l lu lv">export default Index</span></pre><p id="e31b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于大多数应用程序，这是开箱即用的。然而，一些应用程序需要在不同于<code class="fe le lf lg lh b">/</code>的基础路径下提供服务。通常:</p><ul class=""><li id="2c2e" class="lx ly it ki b kj kk kn ko kr lz kv ma kz mb ld mc md me mf bi translated">应用程序分段:几个团队可能负责应用程序的不同部分。例如，一个团队负责仪表板(在<code class="fe le lf lg lh b">/dashboard</code>提供服务)，而另一个团队负责销售流程(在<code class="fe le lf lg lh b">/sales</code>提供服务)</li><li id="3873" class="lx ly it ki b kj mg kn mh kr mi kv mj kz mk ld mc md me mf bi translated">国际化:应用程序的默认语言是英语，但是在进入新市场时，团队决定增加对西班牙语的支持。添加了翻译，西班牙语版本部署在<code class="fe le lf lg lh b">/es</code>基础路径下，所以现在说西班牙语的用户被重定向到<code class="fe le lf lg lh b">/es/dashboard</code>和<code class="fe le lf lg lh b">/es/sales</code></li></ul><p id="eb5c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下一个官方文档包括一个多区域(<a class="ae kf" href="https://nextjs.org/docs#multi-zones" rel="noopener ugc nofollow" target="_blank">https://nextjs.org/docs#multi-zones</a>)部分。这是一个允许在不同的基本路径下服务下一个应用程序的特性。该功能最重要的部分是使用<code class="fe le lf lg lh b">next.config.js</code>文件中的<code class="fe le lf lg lh b">assetPrefix</code>设置。</p><p id="71e8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">文档中列出的多区域示例都使用了Zeit的Now cloud(<a class="ae kf" href="https://zeit.co/home" rel="noopener ugc nofollow" target="_blank">https://zeit.co/home</a>)。但这并不是Now cloud独有的功能。(也许这在文档中并不清楚)</p><p id="e9d9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了在不同的基本路径下部署下一个应用程序，我们需要一个反向代理来创建从我们决定为应用程序提供服务的路径到正确URL的映射。当然，拥有一个本地发展的反向代理并不是最佳选择。尽管出于学术目的，我们将使用NGINX来实现我们上面描述的两个用例。</p><p id="52cc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">根据文档和示例，要在不同的基本路径上运行我们的应用程序，我们需要在链接的<code class="fe le lf lg lh b">as</code>参数上设置<code class="fe le lf lg lh b">assetPrefix</code>设置<strong class="ki iu">和</strong>使用相同的基本路径。因为我们不想为每个链接都重写相同的代码，所以让我们将该行为抽象为一个定制的<code class="fe le lf lg lh b">Link </code>组件:</p><figure class="li lj lk ll gt ju"><div class="bz fp l di"><div class="ml mm l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">我们的自定义链接组件(用Typescript编写)</figcaption></figure><p id="57e0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在应用程序的<code class="fe le lf lg lh b">next.config.js</code>文件中，添加以下内容:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="4ad6" class="lq lr it lh b gy ls lt l lu lv">module.<strong class="lh iu">exports </strong>= {<br/>  <strong class="lh iu">assetPrefix</strong>: <strong class="lh iu"><em class="mn">process</em></strong>.<strong class="lh iu">env</strong>.<strong class="lh iu">BASE_PATH </strong>|| <strong class="lh iu">''</strong>,<br/>  <strong class="lh iu">...</strong><br/>  <strong class="lh iu">publicRuntimeConfig</strong>: {<br/>    ...<br/>    <strong class="lh iu">basePath</strong>: <strong class="lh iu"><em class="mn">process</em></strong>.<strong class="lh iu">env</strong>.<strong class="lh iu">BASE_PATH || ''</strong>,<br/>    ...<br/>  },<br/>}</span></pre><p id="82de" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要在不同的基本路径上运行我们的应用程序，我们需要:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="e6ab" class="lq lr it lh b gy ls lt l lu lv">$ BASE_PATH=/sales yarn dev<br/>[ wait ]  starting the development server ...<br/>[ info ]  waiting on http://localhost:3000 ...<br/>...</span></pre><p id="9ffb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这也适用于静态导出或生产构建:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="ed27" class="lq lr it lh b gy ls lt l lu lv">$ yarn build</span><span id="3cab" class="lq lr it lh b gy lw lt l lu lv"># Production build (SSR)<br/>$ BASE_PATH=/sales yarn start</span><span id="8af1" class="lq lr it lh b gy lw lt l lu lv"># Static export<br/>$ BASE_PATH=/sales yarn export<br/>$ cd out<br/>$ ws -p 3000</span></pre><p id="bb9e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们在开发中这样做，并试图访问<a class="ae kf" href="http://localhost:3000" rel="noopener ugc nofollow" target="_blank"> http://localhost:3000 </a>，我们的应用程序将不会完全工作。</p><figure class="li lj lk ll gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mo"><img src="../Images/b144312d0d200fc6a27de52c39d3b177.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v7LH368-SZvrp0_icsxuZw.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">访问<a class="ae kf" href="http://localhost:3000" rel="noopener ugc nofollow" target="_blank"> http://localhost:3000 </a>时所有资源解析失败</figcaption></figure><p id="c306" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所有应用程序的资源(JS，CSS，Images)都将以<code class="fe le lf lg lh b">/sales</code>为前缀。如果没有一个反向代理来进行正确的映射，它就不会工作。</p><h2 id="c002" class="lq lr it bd mp mq mr dn ms mt mu dp mv kr mw mx my kv mz na nb kz nc nd ne nf bi translated">安装和配置本地NGINX反向代理</h2><p id="0032" class="pw-post-body-paragraph kg kh it ki b kj ng kl km kn nh kp kq kr ni kt ku kv nj kx ky kz nk lb lc ld im bi translated">有几种方法可以在本地安装和配置NGINX反向代理。我的首选方式是通过我放在一起的一个NPM包使用孔(<a class="ae kf" href="https://konghq.com/" rel="noopener ugc nofollow" target="_blank"/>)来从CLI管理它。<a class="ae kf" href="https://www.npmjs.com/package/dev-kong" rel="noopener ugc nofollow" target="_blank">https://www.npmjs.com/package/dev-kong</a>(唯一的依赖是在本地安装docker，因为这个包依赖它来运行docker化的kong实例)</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="6367" class="lq lr it lh b gy ls lt l lu lv">$ npm install -g dev-kong<br/>$ kong --version<br/>0.8.2</span><span id="373b" class="lq lr it lh b gy lw lt l lu lv">$ kong start<br/>Starting Kong<br/>Creating network "t_default" with the default driver</span><span id="5ec0" class="lq lr it lh b gy lw lt l lu lv">Creating t_kong-database_1 ...<br/>Creating t_kong-database_1 ... done</span><span id="9205" class="lq lr it lh b gy lw lt l lu lv">Creating t_kong_1          ...<br/>Creating t_kong_1          ... done</span></pre><p id="522f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦启动，我们就有了一个可以用CLI控制的本地NGINX反向代理。</p><p id="b339" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在浏览器上访问<code class="fe le lf lg lh b">localhost</code>，您将看到:</p><figure class="li lj lk ll gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nl"><img src="../Images/bbbb6c94c8075419f55a56ba8244576f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ii0Ck0M4M_wfl2pCrGaVUw.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">尚未配置任何内容。</figcaption></figure><p id="c74a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还需要一个假的或本地域来解析到<strong class="ki iu">环回IP </strong>地址(通常是127.0。0.1).最简单的方法是将域(我为测试选择的域:<code class="fe le lf lg lh b">outsrc.local</code>)添加到<code class="fe le lf lg lh b">/etc/hosts</code>文件中。</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="430f" class="lq lr it lh b gy ls lt l lu lv">$ sudo sh -c 'echo "127.0.0.1 outsrc.local" &gt;&gt; /etc/hosts'</span><span id="53ba" class="lq lr it lh b gy lw lt l lu lv"># Check it<br/>$ cat /etc/hosts<br/>...<br/>...<br/>...<br/>127.0.0.1 outsrc.local</span></pre><p id="22db" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后是NGINX上的映射:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="a6fe" class="lq lr it lh b gy ls lt l lu lv"># First get local network IP address (Mac OS only)<br/>$ <!-- -->ipconfig getifaddr en0<br/>172.20.10.2</span><span id="caad" class="lq lr it lh b gy lw lt l lu lv">$ kong add --stripuri sales outsrc.local http://172.20.10.2:3000 /sales<br/>┌──────────────────────────┬──────────────────────────────────────┐<br/>│ http_if_terminated       │ true                                 │<br/>├──────────────────────────┼──────────────────────────────────────┤<br/>│ id                       │ 775a9dc2-4b86-4258-82c8-4f2913f5a219 │<br/>├──────────────────────────┼──────────────────────────────────────┤<br/>│ retries                  │ 5                                    │<br/>├──────────────────────────┼──────────────────────────────────────┤<br/>│ preserve_host            │ false                                │<br/>├──────────────────────────┼──────────────────────────────────────┤<br/>│ created_at               │ 1575559214000                        │<br/>├──────────────────────────┼──────────────────────────────────────┤<br/>│ upstream_connect_timeout │ 60000                                │<br/>├──────────────────────────┼──────────────────────────────────────┤<br/>│ upstream_url             │ http://172.20.10.2:3000              │<br/>├──────────────────────────┼──────────────────────────────────────┤<br/>│ upstream_read_timeout    │ 60000                                │<br/>├──────────────────────────┼──────────────────────────────────────┤<br/>│ upstream_send_timeout    │ 60000                                │<br/>├──────────────────────────┼──────────────────────────────────────┤<br/>│ https_only               │ false                                │<br/>├──────────────────────────┼──────────────────────────────────────┤<br/>│ strip_uri                │ true                                 │<br/>├──────────────────────────┼──────────────────────────────────────┤<br/>│ uris                     │ /sales                               │<br/>├──────────────────────────┼──────────────────────────────────────┤<br/>│ name                     │ sales                                │<br/>├──────────────────────────┼──────────────────────────────────────┤<br/>│ hosts                    │ outsrc.local                         │<br/>└──────────────────────────┴──────────────────────────────────────┘</span></pre><p id="803e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">显示映射路径:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="9cfb" class="lq lr it lh b gy ls lt l lu lv">$ kong list</span></pre><figure class="li lj lk ll gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nm"><img src="../Images/5c0d04c0e9c8ed917a1044b41613b503.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rYZys9R5Y-Be6M_ZZJA4Lw.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">孔列表输出</figcaption></figure><p id="9232" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上表显示:当访问<code class="fe le lf lg lh b">outsrc.local/sales</code>时，一个名为<code class="fe le lf lg lh b">sales</code>的端点将其路由到<code class="fe le lf lg lh b"><a class="ae kf" href="http://172.20.10.2:3000" rel="noopener ugc nofollow" target="_blank">http://172.20.10.2:3000</a></code>，并且对于所有请求，移除前缀<code class="fe le lf lg lh b">/sales</code>。</p><p id="62ee" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="mn">(我们需要使用本地网络IP，因为我们的NGINX实例运行在docker容器中，我们的前端应用程序运行在主机上)</em></p><p id="a640" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">可以添加任意数量的路径映射。让我们为将在不同端口上运行的仪表板应用程序添加一个:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="67b5" class="lq lr it lh b gy ls lt l lu lv">$ BASE_PATH=/dashboard yarn dev --port 3010<br/>[ wait ]  starting the development server ...<br/>[ info ]  waiting on http://localhost:3010 ...<br/>...</span></pre><p id="df64" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">和映射:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="d87b" class="lq lr it lh b gy ls lt l lu lv">$ kong add --stripuri dashboard outsrc.local http://172.20.10.2:3010 /dashboard<br/>...</span></pre><p id="37e9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">再次奔跑<code class="fe le lf lg lh b">kong list</code>我们得到:</p><figure class="li lj lk ll gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nn"><img src="../Images/1e79a573b80353b7dc850804f2f1771d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RWvL_AKN_jsVsF_blRPyyA.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">在不同端口和不同基本路径上运行的销售和仪表板应用程序。</figcaption></figure><h2 id="0380" class="lq lr it bd mp mq mr dn ms mt mu dp mv kr mw mx my kv mz na nb kz nc nd ne nf bi translated">演示时间:具有不同基本路径的多个应用程序</h2><p id="099f" class="pw-post-body-paragraph kg kh it ki b kj ng kl km kn nh kp kq kr ni kt ku kv nj kx ky kz nk lb lc ld im bi translated">如果您按照前面的步骤操作，您已经有了一个指向127.0.0.1的本地域，并且安装并运行了NGINX。我们需要一份申请。</p><p id="e387" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们用一个(已经准备好的)应用程序克隆一个repo两次:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="802e" class="lq lr it lh b gy ls lt l lu lv">$ git clone --branch efg/custom-name git@github.com:outsrc/template-frontend.git dashboard-app</span><span id="ecd0" class="lq lr it lh b gy lw lt l lu lv">$ git clone --branch efg/custom-name git@github.com:outsrc/template-frontend.git sales-app</span></pre><p id="da09" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">安装依赖项<code class="fe le lf lg lh b">yarn install</code>并运行指定<code class="fe le lf lg lh b">APP_NAME</code>和<code class="fe le lf lg lh b">BASE_PATH</code>的每个应用程序</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="6e5c" class="lq lr it lh b gy ls lt l lu lv">$ APP_NAME=Dashboard BASE_PATH=/dashboard yarn dev --port 3010</span><span id="a6de" class="lq lr it lh b gy lw lt l lu lv">$ APP_NAME=Sales BASE_PATH=/sales yarn dev --port 3000</span></pre><p id="2888" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们的两个映射是相同的，所以我不会在这里重复它们。</p><p id="4597" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在浏览器上，我们会看到:</p><figure class="li lj lk ll gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nl"><img src="../Images/9a925a675a9a9b0e9d40d71646718cda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ozQzzQGeNbjgQvDwPZrSkA.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">/仪表板上的仪表板应用程序</figcaption></figure><figure class="li lj lk ll gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nl"><img src="../Images/69fb869773e4961bf7a8d9c4e1e80e78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3WYNJO9fZpACWOc7Q_ybnQ.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">销售应用于/销售</figcaption></figure><p id="5a3a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">搞定了。我们有两个NextJS应用程序并排运行在同一个域上，但具有不同的基路径。</p><h2 id="1a65" class="lq lr it bd mp mq mr dn ms mt mu dp mv kr mw mx my kv mz na nb kz nc nd ne nf bi translated">演示时间:相同的应用程序西班牙语翻译</h2><p id="1c1a" class="pw-post-body-paragraph kg kh it ki b kj ng kl km kn nh kp kq kr ni kt ku kv nj kx ky kz nk lb lc ld im bi translated">首先让我们清除NGINX上的当前路径映射</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="76c8" class="lq lr it lh b gy ls lt l lu lv">$ kong delete sales<br/>Deleted</span><span id="ea9d" class="lq lr it lh b gy lw lt l lu lv">$ kong delete dashboard<br/>Deleted</span></pre><p id="8f06" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">克隆带有国际化和西班牙语翻译的代码分支:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="5090" class="lq lr it lh b gy ls lt l lu lv">$ git clone --branch efg/with-intl git@github.com:outsrc/template-frontend.git spanish-app<br/>$ cd spanish-app<br/>$ yarn install<br/>...</span><span id="6a57" class="lq lr it lh b gy lw lt l lu lv">$ LOCALE=es BASE_PATH=/es yarn dev --port 3010</span></pre><p id="62da" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这将使用基本路径<code class="fe le lf lg lh b">/es</code>上的西班牙语本地化启动应用程序。</p><p id="34ec" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在NGINX上映射路径:</p><pre class="li lj lk ll gt lm lh ln lo aw lp bi"><span id="4dad" class="lq lr it lh b gy ls lt l lu lv">$ kong add --stripuri spanish outsrc.local http://172.20.10.2:3010 /es</span></pre><figure class="li lj lk ll gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi no"><img src="../Images/9edf3fa6dda39e54764f4079896e48be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GXwvK5nled3qhUU8OWbKAQ.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">映射到/es的西班牙语翻译</figcaption></figure><p id="7589" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们在浏览器上看到这个:</p><figure class="li lj lk ll gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi np"><img src="../Images/1c160775c83a23b32aa55226148f20c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pkfkR3pu2U6ZM_iEzorrqg.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">我们的西班牙语翻译申请于/es送达</figcaption></figure><p id="b444" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">就国际化而言，我有意省略了一些重要的部分，比如检测用户的浏览器偏好，以便我们可以将它们重定向到正确的路径。这只是为了展示我们如何为不同的地区支持改变基本路径。</p><h2 id="ab51" class="lq lr it bd mp mq mr dn ms mt mu dp mv kr mw mx my kv mz na nb kz nc nd ne nf bi translated">结论。</h2><ul class=""><li id="0dc5" class="lx ly it ki b kj ng kn nh kr nq kv nr kz ns ld mc md me mf bi translated">NextJS确实支持将应用程序部署在不同的基本路径上，而不是根基本路径。</li><li id="8eb1" class="lx ly it ki b kj mg kn mh kr mi kv mj kz mk ld mc md me mf bi translated"><code class="fe le lf lg lh b">assetPrefix</code>和链接<code class="fe le lf lg lh b">as</code>参数的组合。</li><li id="0b0b" class="lx ly it ki b kj mg kn mh kr mi kv mj kz mk ld mc md me mf bi translated">部署到不同的基本路径不是开发人员的任务，而是SRE的任务。也就是说，前端开发人员不应该太关注应用程序部署的位置(基本路径)，他们只需要准备好支持它。本地开发应该总是使用根路径。</li><li id="db34" class="lx ly it ki b kj mg kn mh kr mi kv mj kz mk ld mc md me mf bi translated">致力于静态导出。</li><li id="a2e1" class="lx ly it ki b kj mg kn mh kr mi kv mj kz mk ld mc md me mf bi translated">更喜欢使用运行时配置(<a class="ae kf" href="https://nextjs.org/docs#runtime-configuration" rel="noopener ugc nofollow" target="_blank">https://nextjs.org/docs#runtime-configuration</a>)而不是构建时配置(<a class="ae kf" href="https://nextjs.org/docs#build-time-configuration" rel="noopener ugc nofollow" target="_blank">https://nextjs.org/docs#build-time-configuration</a>)</li><li id="8c30" class="lx ly it ki b kj mg kn mh kr mi kv mj kz mk ld mc md me mf bi translated">如果你真的需要在本地使用NGINX，我推荐你使用Kong(通过dev-kong包)</li></ul></div></div>    
</body>
</html>