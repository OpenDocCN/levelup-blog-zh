<html>
<head>
<title>Seccomp — Secure Computing Mode | Kubernetes | Docker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Seccomp —安全计算模式| Kubernetes | Docker</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/seccomp-secure-computing-mode-kubernetes-docker-97130516662c?source=collection_archive---------5-----------------------#2022-11-16">https://levelup.gitconnected.com/seccomp-secure-computing-mode-kubernetes-docker-97130516662c?source=collection_archive---------5-----------------------#2022-11-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e4e7" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">docker和kubernetes的Seccomp</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/ecd59e1cdd43e862bcc440a27919fb94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kOGdhSQei_srJsB1"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">斯科特·韦伯在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="3984" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我们将讨论Seccomp。<strong class="ky ir"> Seccomp </strong>代表安全计算模式，从2.6.12版本开始就是Linux内核的一个特性。它可以用来保护一个进程的特权，限制它从用户空间到内核空间的调用。Kubernetes允许我们自动将加载到节点上的seccomp概要文件应用到pod和容器中。在进入seccomp之前，让我们讨论一下容器隔离、用户空间、内核空间和系统调用。</p><h2 id="3c89" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">容器隔离</h2><p id="922a" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">容器只不过是一个过程。通过使用<strong class="ky ir">名称空间</strong>和<strong class="ky ir"> cgroups </strong>，容器与主机操作系统和运行在主机上的其他进程相隔离。</p><p id="6ee0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">名称空间</strong>限制进程可以看到的内容，比如用户、文件系统和其他进程。例如，哪个流程可以看到哪个流程？</p><p id="d6ca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> cgroups </strong>限制进程的资源使用(CPU、RAM、磁盘)。例如，一个进程可以使用多少CPU？</p><h2 id="3457" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">用户空间和内核空间</h2><p id="9200" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">Linux将其内存分为两个不同的空间:</p><p id="ed35" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">用户空间</strong>是所有用户应用程序或软件运行的虚拟内存空间。</p><p id="302b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">内核空间</strong>是虚拟内存空间，操作系统的核心(内核)在这里运行。</p><p id="037c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为容器在用户空间中运行。<strong class="ky ir">容器如何与内核空间通信以挂载卷或从文件系统读取文件？</strong></p><p id="6b35" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">答案是通过使用<strong class="ky ir">系统调用。</strong></p><p id="c022" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当运行在Linux上的应用程序/进程想要使用由Linux内核管理的资源时，例如读取文件、创建进程等。应用程序进程对Linux内核进行系统调用，随后Linux内核执行必要的操作，然后将控制权交还给调用程序。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/7bb3672b3d7c809787c6dfddefbf57ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1358/format:webp/1*Q0n3uvlMbnUeli8FBPVe_w.png"/></div></figure><p id="5317" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">容器在它们自己和主机之间共享相同的内核空间。因此，容器有可能使用系统调用来删除文件系统，或者对需要特权的文件进行写操作。这使得容器不如虚拟机安全。因为每个虚拟机都有自己的内核。</p><p id="485e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以问题是我们如何限制来自容器的系统调用？为了限制来自容器的系统调用，我们可以使用Seccomp(安全计算模式)。使用Seccomp实用程序，我们可以限制进程/容器对Linux内核的系统调用。</p><p id="4fb7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">检查内核上是否启用了Seccomp:</p><pre class="kg kh ki kj gt mr ms mt bn mu mv bi"><span id="4c38" class="mw lt iq ms b be mx my l mz na">$ grep -i seccomp /boot/config-$(uname -r)<br/><br/>--------------------------------------------------------------------<br/>CONFIG_SECCOMP=y<br/>CONFIG_HAVE_ARCH_SECCOMP_FILTER=y<br/>CONFIG_SECCOMP_FILTER=y  #'y' Indicates that the Seccomp feature is enabled</span></pre><h2 id="7f4f" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">Seccomp配置文件</h2><p id="c526" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">在创建容器/pod的过程中，我们可以通过确定容器或pod可以进行哪种系统调用来传递一个<strong class="ky ir"> seccomp概要文件</strong>。</p><p id="0d50" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有一个JSON格式用于编写定制的seccomp概要文件:一个基本的seccomp概要文件有三个主要元素:<code class="fe nb nc nd ms b"><strong class="ky ir">defaultAction</strong></code> <strong class="ky ir">、</strong> <code class="fe nb nc nd ms b"><strong class="ky ir">architectures</strong></code> <strong class="ky ir"> </strong>和<strong class="ky ir"> </strong> <code class="fe nb nc nd ms b"><strong class="ky ir">syscalls</strong></code> <strong class="ky ir"> : </strong></p><pre class="kg kh ki kj gt mr ms mt bn mu mv bi"><span id="3f1a" class="mw lt iq ms b be mx my l mz na">{<br/>    "defaultAction": "",<br/>    "architectures": [],<br/>    "syscalls": [<br/>        {<br/>            "names": [],<br/>            "action": ""<br/>        }<br/>    ]<br/>}</span></pre><p id="76fe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe nb nc nd ms b"><strong class="ky ir">syscalls</strong></code>部分，我们将列出<code class="fe nb nc nd ms b"><strong class="ky ir"> "names"</strong></code>数组下的系统调用，根据设置为<code class="fe nb nc nd ms b"><strong class="ky ir">"action"</strong></code> <strong class="ky ir"> </strong>的内容，允许或阻止这些调用。</p><p id="ebf4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe nb nc nd ms b"><strong class="ky ir">architectures</strong></code>部分，我们必须定义我们的目标架构。这非常重要，因为seccomp过滤器将在内核级运行。此外，在过滤期间，将使用系统调用id，而不是我们在<code class="fe nb nc nd ms b"><strong class="ky ir">syscalls.names</strong></code> <strong class="ky ir"> </strong>部分定义的名称。</p><p id="d5e3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nb nc nd ms b"><strong class="ky ir">defaultAction</strong></code>定义了如果在<code class="fe nb nc nd ms b"><strong class="ky ir">syscalls</strong></code> <strong class="ky ir"> </strong>列表中没有找到匹配的系统调用将会发生什么。</p><p id="5086" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">创建<strong class="ky ir"> seccomp </strong>轮廓有几种模式。让我们简单讨论一下其中的一些:</p><h2 id="7d97" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">将系统调用列入白名单:</h2><p id="20c3" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">使用下面的模式，我们可以将那些我们希望允许来自某个进程的系统调用列入白名单。</p><pre class="kg kh ki kj gt mr ms mt bn mu mv bi"><span id="fef5" class="mw lt iq ms b be mx my l mz na">{<br/>    "defaultAction": "SCMP_ACT_ERRNO",<br/>    "architectures": [<br/>        "SCMP_ARCH_X86_64",<br/>        "SCMP_ARCH_X86",<br/>        "SCMP_ARCH_X32"<br/>    ],<br/>    "syscalls": [<br/>        {<br/>            "names": [<br/>                "pselect6",<br/>                "getsockname",<br/>                ..<br/>                ..<br/>                "execve",<br/>                "exit"<br/>            ],<br/>            "action": "SCMP_ACT_ALLOW"<br/>        }<br/>    ]<br/>}</span></pre><p id="0355" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的演示中:在<code class="fe nb nc nd ms b"><strong class="ky ir">syscalls.names</strong></code> <strong class="ky ir"> </strong>部分下<strong class="ky ir"> </strong>列出了几个系统调用，后面的<strong class="ky ir"> <em class="ne"> </em> </strong> <code class="fe nb nc nd ms b"><strong class="ky ir">syscalls.action</strong></code>被设置为<br/> <code class="fe nb nc nd ms b"> <strong class="ky ir">"SCMP_ACT_ALLOW"</strong></code> <strong class="ky ir"> </strong>，只允许执行列出的系统调用。</p><p id="0375" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是如果找不到匹配会怎么样呢？—由于<code class="fe nb nc nd ms b"><strong class="ky ir">"defaultAction"</strong></code>被设置为<code class="fe nb nc nd ms b"><strong class="ky ir">"SCMP_ACT_ERRNO"</strong></code>，这意味着如果在<code class="fe nb nc nd ms b"><strong class="ky ir">syscalls.names</strong></code>列表中没有找到匹配的系统调用，那么系统调用的执行将被阻止。</p><h2 id="1e50" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">将系统调用列入黑名单:</h2><p id="e39f" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">相反，如果我们编写一个类似于以下模式的seccomp配置文件，它将帮助我们将我们想要限制的系统调用列入黑名单，而所有其他调用将被允许。</p><pre class="kg kh ki kj gt mr ms mt bn mu mv bi"><span id="bf1e" class="mw lt iq ms b be mx my l mz na">{<br/>    "defaultAction": "SCMP_ACT_ALLOW",<br/>    "architectures": [<br/>        "SCMP_ARCH_X86_64",<br/>        "SCMP_ARCH_X86",<br/>        "SCMP_ARCH_X32"<br/>    ],<br/>    "syscalls": [<br/>        {<br/>            "names": [<br/>                "pselect6",<br/>                "getsockname",<br/>                ..<br/>                .. <br/>                ..<br/>                "execve",<br/>                "exit"<br/>            ],<br/>            "action": "SCMP_ACT_ERRNO" <br/>        }<br/>    ]<br/>}</span></pre><p id="ee40" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，<code class="fe nb nc nd ms b"> <strong class="ky ir">"defaultAction"</strong></code>被设置为<code class="fe nb nc nd ms b"><strong class="ky ir">"SCMP_ACT_ALLOW"</strong></code>，<code class="fe nb nc nd ms b"><strong class="ky ir">syscalls.action</strong></code> <strong class="ky ir"> </strong>被设置为<strong class="ky ir"> </strong> <code class="fe nb nc nd ms b"><strong class="ky ir">SCMP_ACT_ERRNO</strong></code>，这意味着<code class="fe nb nc nd ms b"><strong class="ky ir">syscalls</strong></code>内所有列出的系统调用都将被列入黑名单，其他的将被允许。</p><h2 id="7cca" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">审核系统调用</h2><p id="d108" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">为了审计系统调用，我们可以使用下面的seccomp配置文件:</p><pre class="kg kh ki kj gt mr ms mt bn mu mv bi"><span id="bc7b" class="mw lt iq ms b be mx my l mz na">{<br/>    "defaultAction": "SCMP_ACT_LOG"<br/>}</span></pre><p id="f14e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们使用上面定义的seccomp配置文件，那么seccomp过滤器将不会影响syscall调用，但是所有的syscall都将记录在hosts <code class="fe nb nc nd ms b"><strong class="ky ir">/var/log/syslog</strong></code> <strong class="ky ir"> </strong>文件中。</p><p id="b42e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是如果需要的话我们可以把<strong class="ky ir"/><code class="fe nb nc nd ms b"><strong class="ky ir">"SCMP_ACT_LOG</strong>"</code><code class="fe nb nc nd ms b"><strong class="ky ir">"SCMP_ACT_ALLOW"</strong></code><strong class="ky ir"/>和<strong class="ky ir"> </strong> <code class="fe nb nc nd ms b"><strong class="ky ir">SCMP_ACT_ERRNO</strong></code> <strong class="ky ir"> </strong>都用在一起。下面是允许某些系统调用，根据我们的需要限制某些系统调用，以及记录所有既不包括在允许列表中也不包括在限制列表中的系统调用的示例。</p><pre class="kg kh ki kj gt mr ms mt bn mu mv bi"><span id="f074" class="mw lt iq ms b be mx my l mz na">{<br/>    "defaultAction": "SCMP_ACT_LOG",<br/>    "architectures": [<br/>        "SCMP_ARCH_X86_64",<br/>        "SCMP_ARCH_X86",<br/>        "SCMP_ARCH_X32"<br/>    ],<br/>    "syscalls": [<br/>        {<br/>            "names": [<br/>                "mmap",<br/>                "gettid",<br/>                "tgkill",<br/>                "rt_sigaction"<br/>            ],<br/>            "action": "SCMP_ACT_ALLOW"<br/>        },<br/>        {<br/>            "names": [<br/>                "keyctl",<br/>                "ptrace"<br/>            ],<br/>            "action": "SCMP_ACT_ERRNO"<br/>        }<br/>    ]<br/>}</span></pre><h2 id="4c74" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">码头集装箱的Seccomp配置文件</h2><p id="cf74" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">默认情况下，docker容器以一个默认的概要文件运行，可以在这里找到<a class="ae kv" href="https://github.com/moby/moby/blob/master/profiles/seccomp/default.json" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="aeb7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是如果我们需要，我们可以在创建容器时使用<code class="fe nb nc nd ms b"><strong class="ky ir">--security-opt</strong></code>选项通过传递一个自定义概要文件来修改默认概要文件:</p><pre class="kg kh ki kj gt mr ms mt bn mu mv bi"><span id="7620" class="mw lt iq ms b be mx my l mz na">$ docker run --rm \<br/>             -it \<br/>             --security-opt seccomp=/path/to/seccomp/custom.json \<br/>             hello-world</span></pre><h2 id="a912" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">Kubernetes的Seccomp</h2><p id="c615" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">为了给一个pod分配一个seccomp配置文件，我们必须将seccomp配置文件JSON文件放在节点目录中，以便kubelet在将pod调度到相应的节点时可以方便地访问它。</p><p id="0264" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">根据<a class="ae kv" href="https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> v1.25 </strong> </a>文档版本，kubelet的默认根目录为:<code class="fe nb nc nd ms b"><strong class="ky ir">/var/lib/kubelet</strong></code></p><p id="b9f3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设我们想要将下面名为<strong class="ky ir"> custom.json </strong>的seccomp概要文件附加到即将发布的pods中。</p><pre class="kg kh ki kj gt mr ms mt bn mu mv bi"><span id="2bf9" class="mw lt iq ms b be mx my l mz na">{<br/>    "defaultAction": "SCMP_ACT_ERRNO",<br/>    "architectures": [<br/>        "SCMP_ARCH_X86_64",<br/>        "SCMP_ARCH_X86",<br/>        "SCMP_ARCH_X32"<br/>    ],<br/>    "syscalls": [<br/>        {<br/>            "names": [<br/>                "accept4",<br/>                "epoll_wait",<br/>                "pselect6",<br/>                "futex",<br/>                "madvise",<br/>                "epoll_ctl",<br/>                "getsockname",<br/>                "setsockopt",<br/>                "vfork",<br/>                "mmap",<br/>                "read",<br/>                "write",<br/>                "close",<br/>                "arch_prctl",<br/>                "sched_getaffinity",<br/>                "munmap",<br/>                "brk",<br/>                "rt_sigaction",<br/>                "rt_sigprocmask",<br/>                "sigaltstack",<br/>                "gettid",<br/>                "clone",<br/>                "bind",<br/>                "socket",<br/>                "openat",<br/>                "readlinkat",<br/>                "exit_group",<br/>                "epoll_create1",<br/>                "listen",<br/>                "rt_sigreturn",<br/>                "sched_yield",<br/>                "clock_gettime",<br/>                "connect",<br/>                "dup2",<br/>                "epoll_pwait",<br/>                "execve",<br/>                "exit",<br/>                "fcntl",<br/>                "getpid",<br/>                "getuid",<br/>                "ioctl",<br/>                "mprotect",<br/>                "nanosleep",<br/>                "open",<br/>                "poll",<br/>                "recvfrom",<br/>                "sendto",<br/>                "set_tid_address",<br/>                "setitimer",<br/>                "writev"<br/>            ],<br/>            "action": "SCMP_ACT_ALLOW"<br/>        }<br/>    ]<br/>}</span></pre><p id="7a81" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将<strong class="ky ir"> custom.json </strong>文件移动到kubelet根目录下。以便kubelet可以直接访问它。</p><pre class="kg kh ki kj gt mr ms mt bn mu mv bi"><span id="24d4" class="mw lt iq ms b be mx my l mz na"># create new directory under kubelet root directory<br/>$ mkdir -p /var/lib/kubelet/seccomp/profiles<br/><br/># move "custom.json"<br/>$ mv custom.json /var/lib/kubelet/seccomp/profiles/</span></pre><h2 id="2855" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">将<strong class="ak"> seccompProfile连接到pod </strong></h2><p id="8bc1" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">要将Seccomp配置文件设置为箱/集装箱，包括箱或集装箱清单的<strong class="ky ir"/><strong class="ky ir"/><code class="fe nb nc nd ms b"><strong class="ky ir">securityContext</strong></code><strong class="ky ir"/>部分的<strong class="ky ir"> </strong> <code class="fe nb nc nd ms b"><strong class="ky ir">seccompProfile</strong></code>字段。</p><p id="90c4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nb nc nd ms b"><strong class="ky ir">seccompProfile</strong></code> <strong class="ky ir"> : </strong>有很多种</p><p id="7976" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> Localhost </strong> —在将要调度pod的节点上的文件中定义的seccomp配置文件。<br/> <strong class="ky ir"> RuntimeDefault </strong> —应该使用容器运行时默认配置文件。<strong class="ky ir">无约束</strong> —不应应用任何轮廓。(如果没有定义配置文件，则为默认值)</p><h2 id="05b4" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">Seccomp配置文件— <strong class="ak">本地主机</strong></h2><pre class="kg kh ki kj gt mr ms mt bn mu mv bi"><span id="fd1d" class="mw lt iq ms b be mx my l mz na"># type "localhost"<br/><br/>securityContext:<br/>  seccompProfile:<br/>    type: Localhost<br/>    localhostProfile: my-profiles/profile-allow.json</span></pre><p id="09e9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nb nc nd ms b"><strong class="ky ir">seccompProfile.type</strong></code> <strong class="ky ir"> </strong>表示将应用哪种seccomp配置文件。<br/> <code class="fe nb nc nd ms b"><strong class="ky ir">seccompProfile.localhostProfile</strong></code>表示在pod将运行的节点上的文件中定义的seccomp配置文件。该配置文件必须在节点上预先配置才能工作。该路径必须相对于kubelet的根目录。仅当类型为"<strong class="ky ir"> Localhost </strong>"时才必须设置。</p><h2 id="b211" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated"><strong class="ak"> Seccomp配置文件—运行时间默认值</strong></h2><pre class="kg kh ki kj gt mr ms mt bn mu mv bi"><span id="97bb" class="mw lt iq ms b be mx my l mz na"># type "RuntimeDefault"<br/><br/>securityContext:<br/>  seccompProfile:<br/>    type: RuntimeDefault</span></pre><p id="b2fc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如我们所讨论的，默认情况下，容器使用默认的seccomp配置文件运行。如果我们将<code class="fe nb nc nd ms b"><strong class="ky ir">seccompProfile.type</strong></code> <strong class="ky ir"> </strong>设置为<strong class="ky ir"> RuntimeDefault </strong>，那么pod将使用容器的默认seccomp配置文件。</p><p id="3d5f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，通过将<strong class="ky ir"> custom.json </strong>文件作为<strong class="ky ir"> seccompProfile </strong>附加到pod的<strong class="ky ir"> securityContext </strong>部分下，创建一个名为<strong class="ky ir"> pod-1 </strong>的新pod。</p><pre class="kg kh ki kj gt mr ms mt bn mu mv bi"><span id="0043" class="mw lt iq ms b be mx my l mz na">apiVersion: v1<br/>kind: Pod<br/>metadata:<br/>  name: pod-1<br/>  labels:<br/>    app: pod-1<br/>spec:<br/>  securityContext:<br/>    seccompProfile:<br/>      type: Localhost<br/>      localhostProfile: profiles/custom.json<br/>  containers:<br/>  - name: test-container<br/>    image: hashicorp/http-echo:0.2.3<br/>    args:<br/>    - "-text=just made some syscalls!"<br/>    securityContext:<br/>      allowPrivilegeEscalation: false   </span></pre><p id="d7f9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了确保容器不会获得比pod更多的特权，我们必须将容器<strong class="ky ir">allowprivilegescalation</strong>设置为<strong class="ky ir"> false。</strong></p><p id="588a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，创建pod:</p><pre class="kg kh ki kj gt mr ms mt bn mu mv bi"><span id="6355" class="mw lt iq ms b be mx my l mz na">&gt;&gt; kubectl create -f pod-1.yaml<br/><br/># list the pod-1 <br/>&gt;&gt; kubectl get pods<br/>---------------------------------------------------------------------------<br/>NAME    READY   STATUS    RESTARTS      AGE<br/>pod-1   1/1     Running   5 (90s ago)   3m3s</span></pre><p id="4858" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以看到<strong class="ky ir"> pod-1 </strong>正在运行，没有任何问题。这表明<strong class="ky ir"> pod-1 </strong>允许的系统调用足以让pod运行。</p></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><p id="24e5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你觉得这篇文章有帮助，请<strong class="ky ir">不要忘记</strong>点击<strong class="ky ir">跟随</strong>👉<strong class="ky ir"> </strong>和<strong class="ky ir">拍手</strong>👏<strong class="ky ir"> </strong>按钮帮助我写更多这样的文章。<br/>谢谢🖤</p></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><h2 id="ca36" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">参考</h2><div class="nm nn gp gr no np"><a href="https://kubernetes.io/docs/tutorials/security/seccomp/" rel="noopener  ugc nofollow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd ir gy z fp nu fr fs nv fu fw ip bi translated">用seccomp限制容器的系统调用</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">特性状态:Kubernetes v1.19 [stable] Seccomp代表安全计算模式，是Linux的一个特性…</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">kubernetes.io</p></div></div><div class="ny l"><div class="nz l oa ob oc ny od kp np"/></div></div></a></div><div class="nm nn gp gr no np"><a href="https://itnext.io/seccomp-in-kubernetes-part-i-7-things-you-should-know-before-you-even-start-97502ad6b6d6" rel="noopener  ugc nofollow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd ir gy z fp nu fr fs nv fu fw ip bi translated">Kubernetes中的Seccomp第一部分:开始之前你应该知道的7件事！</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">这是一个系列的第一篇，讲述如何在不使用魔法或巫术的情况下以秘密的方式获得伟大的秘密档案…</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">itnext.io</p></div></div><div class="ny l"><div class="oe l oa ob oc ny od kp np"/></div></div></a></div></div></div>    
</body>
</html>