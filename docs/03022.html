<html>
<head>
<title>JavaScript Best Practices — Modern Syntax</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript最佳实践—现代语法</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-best-practices-modern-syntax-493ae277f67c?source=collection_archive---------9-----------------------#2020-04-15">https://levelup.gitconnected.com/javascript-best-practices-modern-syntax-493ae277f67c?source=collection_archive---------9-----------------------#2020-04-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/d7c16383f3bfbac726183f5f1cd390ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*iQ7hNcad-u-3QZnC"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@rodlong?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">杆长</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">未飞溅</a>上的照片</figcaption></figure><p id="25da" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有比其他方法更好的方法来编写JavaScript代码。</p><p id="1073" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将研究使用最新JavaScript语法特性的最佳实践。</p><h1 id="126f" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">句法糖</h1><p id="1eed" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">在JavaScript中，包含的语法糖通常是好的。</p><p id="a94b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它们让我们以更短、更清晰的方式编写代码，并使代码在编写过程中更具可读性。</p><p id="c6b6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这些语法糖是现有技术的替代物，所以我们应该使用它们。</p><h1 id="3ff3" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">常数不一致</h1><p id="e1f5" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mh mi mj mk b">const</code>是声明块范围常量的关键字。</p><p id="6f0b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">他们会把赋给它的原始值变成不可变的，因为我们不能在一个常量赋值后再给它赋值。</p><p id="778a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们声明一个值时，它必须被赋值。</p><p id="003b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，<code class="fe mh mi mj mk b">const</code>有点欺骗性，因为有些人可能不知道我们仍然可以通过改变属性来改变分配给<code class="fe mh mi mj mk b">const</code>的对象。</p><p id="39a7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，可以用像<code class="fe mh mi mj mk b">push</code>和<code class="fe mh mi mj mk b">unshift</code>这样的方法改变数组。</p><p id="36ca" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我们不应该假设分配给<code class="fe mh mi mj mk b">const</code>的对象是不可变的。</p><h1 id="62ae" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">限制函数的范围</h1><p id="4b63" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">用<code class="fe mh mi mj mk b">functionm</code>关键字定义的传统函数可以被调用来运行块中定义的语句，并可能返回值。</p><p id="4d0f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果写成函数声明，它们可以在任何地方运行。</p><p id="2199" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="3b1d" class="mt lf it mk b gy mu mv l mw mx">function foo() {<br/>  //...<br/>}</span></pre><p id="eca0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么<code class="fe mh mi mj mk b">foo</code>可以在它被定义之前或之后运行。</p><p id="2ba4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它还定义了自己的<code class="fe mh mi mj mk b">this</code>，可以作为构造函数与<code class="fe mh mi mj mk b">new</code>操作符一起使用。</p><p id="20bc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以，为了限制我们函数的能力，我们应该使用箭头函数。</p><p id="1f2d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们需要构造函数，那么我们应该使用类语法来定义它们，让每个人都清楚。</p><h1 id="ffdc" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">类语法</h1><p id="c0af" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">类语法对于定义构造函数非常有用。它与旧的构造函数语法做同样的事情。</p><p id="d536" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它看起来像Java等面向对象语言中的一个类，但它做的事情与JavaScript构造函数一样。</p><p id="7f1f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，原型继承模型仍然用于JavaScript类。</p><p id="b467" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以如下:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="e3ee" class="mt lf it mk b gy mu mv l mw mx">function Person(name) {<br/>  this.name = name;<br/>};</span><span id="f3cb" class="mt lf it mk b gy my mv l mw mx">Person.prototype.greet = function() {<br/>  console.log(`hi ${this.name}`);<br/>};</span></pre><p id="f03d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">与以下内容相同:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="ed3e" class="mt lf it mk b gy mu mv l mw mx">class Person {<br/>  constructor(name) {<br/>    this.name = name;<br/>  }</span><span id="0d26" class="mt lf it mk b gy my mv l mw mx">  greet() {<br/>    console.log(`hi ${this.name}`);<br/>  }<br/>}</span></pre><p id="5e80" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它们持有和做同样的事情，但是字段和方法的位置是不同的。</p><h1 id="882a" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">箭头功能</h1><p id="eeb3" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">箭头功能很棒。他们更矮。但在试镜中会更整洁。</p><p id="6552" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们在第一行返回，它可以在不添加<code class="fe mh mi mj mk b">return</code>关键字的情况下返回。</p><p id="35c8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它们封装了使它们更方便的品质。但是它们不是用<code class="fe mh mi mj mk b">function</code>关键字定义的传统函数的替代物。</p><p id="deae" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以通过调用<code class="fe mh mi mj mk b">bind</code>来改变函数内部的<code class="fe mh mi mj mk b">this</code>。</p><p id="8c11" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">还有，我们不能用它们调用<code class="fe mh mi mj mk b">call</code>和<code class="fe mh mi mj mk b">apply</code>来改变<code class="fe mh mi mj mk b">this</code>，也不能用它们调用带参数的函数。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/0d66623e29c15fa1a8236a55d9e121db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*G3TJMPESanNOpIJz"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">托马斯·凯利在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="f24e" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">走向异步</h1><p id="3a9c" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">由于JavaScript的单线程特性，用JavaScript实现异步有其自身的困难。</p><p id="b3bf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们必须编写代码来解除线程阻塞，这样在我们准备好运行程序之前，它们不会阻碍我们的程序。</p><p id="a9e8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这就是带有回调的异步代码的用武之地，它使得调用异步代码更加容易。</p><p id="6851" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以通过调用<code class="fe mh mi mj mk b">setTimeout</code>使我们的代码异步。此外，几乎所有HTTP客户端都以异步方式运行。</p><p id="0ba9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们有很多带有回调的异步代码，那么我们必须嵌套回调。</p><p id="4e5a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">事情变得很糟糕。</p><p id="0244" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们使用回调来链接异步代码，我们可能会得到如下代码:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="39aa" class="mt lf it mk b gy mu mv l mw mx">async1((err, res) =&gt; {<br/>  if (!err) {<br/>    async2(res, (err, res) =&gt; {<br/>      if (!err) {<br/>        async3(res, (err, res) =&gt; {<br/>          //...<br/>        });<br/>      }<br/>    });<br/>  }<br/>});</span></pre><p id="6964" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这很难看，而且不可维护。相反，我们用承诺。那么我们可以这样写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="7072" class="mt lf it mk b gy mu mv l mw mx">promise1<br/>  .then((res) =&gt; {<br/>    //...<br/>    return promise2<br/>  })<br/>  .then((res) =&gt; {<br/>    //...<br/>    return promise3<br/>  })<br/>  .then((res) =&gt; {<br/>    //...<br/>  })</span></pre><p id="6fb9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这比前一个例子中嵌套异步回调要干净得多。</p><p id="a9ff" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以把事情写得更短:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="c051" class="mt lf it mk b gy mu mv l mw mx">(async () =&gt; {<br/>  const val1 = await promise1;<br/>  //...<br/>  const val2 = await promise2;<br/>  //...<br/>  const val3 = await promise3;<br/>  //...<br/>})();</span></pre><p id="eb5a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如我们所见，代码要短得多，并且与我们之前的承诺链完全相同。</p><p id="ce71" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">唯一的区别是<code class="fe mh mi mj mk b">va11</code>、<code class="fe mh mi mj mk b">val2</code>和<code class="fe mh mi mj mk b">val3</code>保存承诺的解析值，而不是<code class="fe mh mi mj mk b">res</code>。</p><h1 id="f130" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="8f0f" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们了解了一些关于JavaScript的事情，比如<code class="fe mh mi mj mk b">const</code>并不总是不可变的，并用<code class="fe mh mi mj mk b">async </code>和<code class="fe mh mi mj mk b">await</code>清理异步代码。</p><p id="e358" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，箭头函数和类应该分别用于常规函数和构造函数。</p></div></div>    
</body>
</html>