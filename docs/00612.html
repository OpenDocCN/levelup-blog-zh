<html>
<head>
<title>Task Management Application Using Vue.js — Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Vue.js的任务管理应用程序—第1部分</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/task-management-application-using-vue-js-part-1-df607ca30f48?source=collection_archive---------0-----------------------#2019-06-03">https://levelup.gitconnected.com/task-management-application-using-vue-js-part-1-df607ca30f48?source=collection_archive---------0-----------------------#2019-06-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><h1 id="db29" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">介绍</h1><p id="3469" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在<a class="ae lj" href="https://medium.com/@_shirish/thinking-in-components-with-vue-js-a35b5af12df" rel="noopener">使用vue.js </a>思考组件中，我们了解了vue组件以及如何使用它们来创建web应用程序。在这篇文章中，我们将学习如何使用Vue.js构建一个类似于Trello <strong class="kn ir"> </strong>的<strong class="kn ir">任务管理应用</strong>。</p><p id="dc4d" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">这个应用程序允许你使用一个董事会直观地管理项目和任务。一个董事会代表一个项目。一个董事会包含一个或多个名单。每个列表代表任务的类别，如<code class="fe lp lq lr ls b">Todo</code>、<code class="fe lp lq lr ls b">Doing</code>和<code class="fe lp lq lr ls b">Done</code>。您可以通过拖放来更改列表的顺序以及列表中任务的顺序，还可以将任务从一个列表移动到另一个列表，以便在项目经过不同阶段时对其进行管理。</p><p id="38ad" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">请记住，这不是一个循序渐进的教程。本文的主要目标是帮助您了解设计复杂用户界面的幕后过程，并逐步学习一些高级主题，如拖放界面、使用Vuex的状态管理、Form Validation、Custom Vue.js Plugin、Bundle优化。</p><h2 id="bd74" class="lt jo iq bd jp lu lv dn jt lw lx dp jx kw ly lz kb la ma mb kf le mc md kj me bi translated">我们将建设什么？</h2><p id="6d69" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这是完整应用程序的屏幕截图。</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi mf"><img src="../Images/3eaa6e4de6f87689fa23b334575cff0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T9DPrAdP0Q6eyVsKyU2rCA.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">任务管理应用程序</figcaption></figure><p id="e76e" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated"><strong class="kn ir">应用演示:</strong></p><ul class=""><li id="b9ae" class="mv mw iq kn b ko lk ks ll kw mx la my le mz li na nb nc nd bi translated">关于浪涌。sh—<a class="ae lj" href="http://kanban-board-demo.surge.sh" rel="noopener ugc nofollow" target="_blank">http://看板-电路板-演示。浪涌。sh </a></li><li id="a917" class="mv mw iq kn b ko ne ks nf kw ng la nh le ni li na nb nc nd bi translated">关于netlify.com—<a class="ae lj" href="https://task-management-app.netlify.com/" rel="noopener ugc nofollow" target="_blank">https://task-management-app.netlify.com</a></li></ul><p id="8885" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated"><strong class="kn ir"> Github储备库:</strong><a class="ae lj" href="https://github.com/techlab23/task-management-app" rel="noopener ugc nofollow" target="_blank">https://github.com/techlab23/task-management-app</a></p><h2 id="6c0b" class="lt jo iq bd jp lu lv dn jt lw lx dp jx kw ly lz kb la ma mb kf le mc md kj me bi translated">应用特性</h2><p id="43ec" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这是一个多页应用程序，从一开始就实现了丰富的功能集。下面是此应用程序的功能列表。</p><p id="f35d" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated"><strong class="kn ir">董事会</strong></p><p id="0b23" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">允许用户，</p><ul class=""><li id="394c" class="mv mw iq kn b ko lk ks ll kw mx la my le mz li na nb nc nd bi translated">在控制面板中查看现有板</li><li id="e099" class="mv mw iq kn b ko ne ks nf kw ng la nh le ni li na nb nc nd bi translated">存档和恢复董事会</li><li id="ec4b" class="mv mw iq kn b ko ne ks nf kw ng la nh le ni li na nb nc nd bi translated">查看个别董事会内容</li><li id="749b" class="mv mw iq kn b ko ne ks nf kw ng la nh le ni li na nb nc nd bi translated">创建新董事会</li><li id="5dec" class="mv mw iq kn b ko ne ks nf kw ng la nh le ni li na nb nc nd bi translated">编辑现有董事会信息</li></ul><p id="a991" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated"><strong class="kn ir">列表</strong></p><p id="6f24" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">允许用户，</p><ul class=""><li id="e75a" class="mv mw iq kn b ko lk ks ll kw mx la my le mz li na nb nc nd bi translated">创建新列表</li><li id="c504" class="mv mw iq kn b ko ne ks nf kw ng la nh le ni li na nb nc nd bi translated">编辑列表名称</li><li id="4dcd" class="mv mw iq kn b ko ne ks nf kw ng la nh le ni li na nb nc nd bi translated">存档和还原列表</li><li id="dac0" class="mv mw iq kn b ko ne ks nf kw ng la nh le ni li na nb nc nd bi translated">使用拖放重新排列板中的列表</li></ul><p id="a3f2" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated"><strong class="kn ir">清单项目</strong></p><p id="2973" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">允许用户，</p><ul class=""><li id="c0ed" class="mv mw iq kn b ko lk ks ll kw mx la my le mz li na nb nc nd bi translated">在列表中创建新项目并更新现有项目</li><li id="85b9" class="mv mw iq kn b ko ne ks nf kw ng la nh le ni li na nb nc nd bi translated">通过拖放重新排列列表中的项目</li><li id="9187" class="mv mw iq kn b ko ne ks nf kw ng la nh le ni li na nb nc nd bi translated">使用拖放在列表之间移动任务</li></ul><h2 id="1e09" class="lt jo iq bd jp lu lv dn jt lw lx dp jx kw ly lz kb la ma mb kf le mc md kj me bi translated">你会在这篇文章里学到什么？</h2><ul class=""><li id="d5ef" class="mv mw iq kn b ko kp ks kt kw nj la nk le nl li na nb nc nd bi translated">如何将用户界面分解为更小的组件？(也称为组件思维)</li><li id="6589" class="mv mw iq kn b ko ne ks nf kw ng la nh le ni li na nb nc nd bi translated">如何构建可重用的组件？</li><li id="808b" class="mv mw iq kn b ko ne ks nf kw ng la nh le ni li na nb nc nd bi translated">如何使用事件总线进行组件通信？</li><li id="46d6" class="mv mw iq kn b ko ne ks nf kw ng la nh le ni li na nb nc nd bi translated">如何使用Vuex管理应用程序状态？</li></ul><h1 id="dba4" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">组件思维</h1><p id="6bff" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">构建更大更复杂的用户界面需要大量的前期思考和对底层框架的良好理解。</p><p id="5d05" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">在基于组件的设计中，有两种类型的组件，<code class="fe lp lq lr ls b">specialised</code>和<code class="fe lp lq lr ls b">generic</code>。专用组件是为一个特定的目的而构建的，而通用组件封装了通用的行为或功能。通用组件促进可重用性。请注意，如果需要，通用组件可以用于构建专用组件。</p><p id="265b" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">在软件开发方法论中，你可以使用<code class="fe lp lq lr ls b">Top-down</code>或者<code class="fe lp lq lr ls b">Bottom-up</code>方法来构建更大的用户界面。</p><p id="7e75" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">在<code class="fe lp lq lr ls b">Top-down</code>方法中，你首先构建高层组件，然后将它们分解成更小的专业或通用组件。使用这种方法，您可以渐进式地设计用户界面，并在单个组件上实现应用程序功能。这种方法通常更受精益敏捷团队的青睐。</p><p id="6b56" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">而在<code class="fe lp lq lr ls b">Bottom-up</code>方法中，首先构建一组通用组件，然后用它们构建专用组件，最后用特定组件构建整个用户界面。这种方法需要对底层技术有深入的理解，并且通常是有经验的开发团队的首选。</p><p id="8e1d" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">在构建这个应用程序时，我使用了自顶向下的方法，这样我就可以逐步构建应用程序，并逐个功能地实现。为了直观地向您展示，下面是应用程序中组件的组成。</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi nm"><img src="../Images/9f3e27c8e37a94f2a412cc19eb26232b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3glVtk0wvVWpgAsbdbAq4g.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">组件的组成</figcaption></figure><h2 id="a850" class="lt jo iq bd jp lu lv dn jt lw lx dp jx kw ly lz kb la ma mb kf le mc md kj me bi translated">采用自上而下的方法</h2><p id="5685" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在第一轮开发中，我开始构建专门的高级组件，如<code class="fe lp lq lr ls b">AppHeader</code>、<code class="fe lp lq lr ls b">Dashboard</code>和<code class="fe lp lq lr ls b">TaskBoard</code>、<code class="fe lp lq lr ls b">AppLoadingIndicator</code>组件。</p><p id="1862" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">除了这些组件，我还使用<code class="fe lp lq lr ls b">Vue-Router</code>配置了应用程序路由，将<code class="fe lp lq lr ls b">Dashboard</code>和<code class="fe lp lq lr ls b">TaskBoard</code>显示为页面。</p><p id="d16b" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">然后在第二轮，我重构了<code class="fe lp lq lr ls b">TaskBoard</code>组件，构建了<code class="fe lp lq lr ls b">TaskList</code>、<code class="fe lp lq lr ls b">TaskListItem</code>组件，并实现了&amp;拖放功能，以完成关键功能。</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi nm"><img src="../Images/a9e8bbd0228791eb3d22a39b731d29da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RHZOBHSI2c-e9s6tKmYX2g.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">组件层次结构</figcaption></figure><p id="3545" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">一旦完成了关键特性，那么在第三轮重构中，我开始通过设计剩余的专门组件来处理剩余的特性，例如<code class="fe lp lq lr ls b">TaskListRestore</code>、<code class="fe lp lq lr ls b">TaskListArchive</code>、<code class="fe lp lq lr ls b">TaskListEdit</code>、<code class="fe lp lq lr ls b">TaskBoardEdit</code>和<code class="fe lp lq lr ls b">TaskListActions</code>。</p><p id="ea22" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">在我完成了用户界面的第一稿后，我重新审视了组件，并开始寻找通用行为来提取和构建通用组件，以便我可以重用逻辑。</p><p id="120f" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">在这一轮的重构中，我把常见的行为提取出来，分离成一个通用的组件，可以在app的任何地方重用，比如Show Popup feature，被<code class="fe lp lq lr ls b">TaskListRestore</code>、<code class="fe lp lq lr ls b">TaskListArchive</code>、<code class="fe lp lq lr ls b">TaskListEdit</code>、<code class="fe lp lq lr ls b">TaskBoardEdit</code>、<code class="fe lp lq lr ls b">TaskListActions</code>使用。这个通用组件变成了<code class="fe lp lq lr ls b">DetailsPopup</code>和<code class="fe lp lq lr ls b">DetailsDropdown</code>组件。</p><p id="8aa7" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">现在我们已经了解了组件设计方法，让我们更深入地了解单个应用程序组件及其在应用程序中的用途。</p><h1 id="7a6d" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">应用程序组件及其用途</h1><p id="d8db" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">将整个用户界面分解成更小的组件不一定是一个复杂的过程，但是它需要在代码重构方面做一些额外的工作，但是它促进了代码的长期可维护性的模块化结构。</p><p id="5989" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">在分解应用程序用户界面时，最好定义或至少考虑组件的用途或职责。因为通常情况下，组件的责任会驱动其行为，如果行为过于复杂，那么这是进一步重构的良好迹象。</p><p id="a600" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">根据我的经验，大多数时候，组件的职责满足应用程序的特定特性。</p><p id="4d78" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">让我们简单看一下应用程序组件及其职责。</p><h2 id="0abe" class="lt jo iq bd jp lu lv dn jt lw lx dp jx kw ly lz kb la ma mb kf le mc md kj me bi translated">应用</h2><p id="d47e" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">App组件是Vue.js初始化时挂载在DOM上的最顶层组件。我们将使用<code class="fe lp lq lr ls b">Vue-Router</code>库来构建这个使用<code class="fe lp lq lr ls b">&lt;router-view&gt;</code>标签显示页面的多页面应用程序。</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi nn"><img src="../Images/c09bcbbf136f0500038fcaa4532a09da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B1DE2-hx9uxdw2DQ5Y-2LA.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">App.vue</figcaption></figure><p id="8ece" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">App组件负责托管顶层组件，如<code class="fe lp lq lr ls b">AppHeader</code>、<code class="fe lp lq lr ls b">RouterView</code>、<code class="fe lp lq lr ls b">AppLoadingIndicator</code>组件。此外，我们还将使用由Vue.js提供的<code class="fe lp lq lr ls b">transition</code>组件包装<code class="fe lp lq lr ls b">router-view</code>,以显示平滑的页面过渡。</p><h2 id="972b" class="lt jo iq bd jp lu lv dn jt lw lx dp jx kw ly lz kb la ma mb kf le mc md kj me bi translated">AppHeader</h2><p id="8379" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">组件负责显示基于页面的应用程序导航栏及相关操作。</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi no"><img src="../Images/44be1fd65d9d0d9028b52cb6f0ca1fcf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XtCLEWiecSsZfm65RB2Q5A.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">AppHeader.vue</figcaption></figure><p id="72a2" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">例如，当用户在<code class="fe lp lq lr ls b">Dashboard</code>页面时，<code class="fe lp lq lr ls b">AppHeader</code>将显示<code class="fe lp lq lr ls b">TaskBoardEdit</code>组件，允许用户创建新的或编辑现有的电路板。</p><p id="930d" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">或者，当用户在<code class="fe lp lq lr ls b">TaskBoard</code>页面上查看单个电路板时，将显示<code class="fe lp lq lr ls b">TaskListEdit</code>和<code class="fe lp lq lr ls b">TaskListRestore</code>组件。</p><p id="92f6" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">它们允许用户创建新列表或编辑现有列表以及恢复任何存档列表。如果用户想要存档任何单个列表，则<code class="fe lp lq lr ls b">TaskListArchive</code>将可见。</p><h2 id="d487" class="lt jo iq bd jp lu lv dn jt lw lx dp jx kw ly lz kb la ma mb kf le mc md kj me bi translated">应用指示器</h2><p id="4399" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">该组件负责显示SVG加载动画，这表明应用程序此刻正忙于获取信息。</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi np"><img src="../Images/4f778f82c6bd5d99f71391e624b73219.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YY8btgpWLVj1F7Ct7P5cSQ.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">apploadingdindicator . vue</figcaption></figure><p id="5284" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">如上面的代码片段所示，这个组件没有本地状态，而是使用<code class="fe lp lq lr ls b">isLoading</code> Vuex getter来显示和隐藏加载指示器动画。</p><p id="d1d9" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated"><strong class="kn ir">注:</strong> <a class="ae lj" href="https://samherbert.net/svg-loaders/" rel="noopener ugc nofollow" target="_blank">山姆·赫伯特</a>创作了优秀的<a class="ae lj" href="https://github.com/SamHerbert/SVG-Loaders" rel="noopener ugc nofollow" target="_blank"> SVG动画</a>并公之于众，我用它作为加载指标。</p><h2 id="d8ab" class="lt jo iq bd jp lu lv dn jt lw lx dp jx kw ly lz kb la ma mb kf le mc md kj me bi translated">仪表盘</h2><p id="2b65" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">该组件负责:</p><ul class=""><li id="6e1e" class="mv mw iq kn b ko lk ks ll kw mx la my le mz li na nb nc nd bi translated">显示活动和存档的公告板，</li><li id="f902" class="mv mw iq kn b ko ne ks nf kw ng la nh le ni li na nb nc nd bi translated">开始编辑公告板信息，并</li><li id="a4d0" class="mv mw iq kn b ko ne ks nf kw ng la nh le ni li na nb nc nd bi translated">允许用户存档、恢复和导航到单个电路板。</li></ul><h2 id="55d1" class="lt jo iq bd jp lu lv dn jt lw lx dp jx kw ly lz kb la ma mb kf le mc md kj me bi translated">任务板</h2><p id="ee73" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">该组件负责使用<code class="fe lp lq lr ls b">TaskList</code>组件显示各个电路板的内容，并允许用户使用拖放功能对列表进行重新排序。此外，该组件还使用<code class="fe lp lq lr ls b">setActiveBoard</code> Vuex动作将当前板卡设置为活动。</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi nq"><img src="../Images/6c44d214981d90f55fd480acee557f46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uDG8PMDxX4T6krOHheLxpw.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">TaskBoard.vue</figcaption></figure><p id="02ae" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">我们正在遍历列表，并使用<code class="fe lp lq lr ls b">TaskList</code>组件以列格式显示它们。为了实现列表的拖放重新排序，我们用<code class="fe lp lq lr ls b">draggable</code>组件包装了<code class="fe lp lq lr ls b">TaskList</code>组件。</p><h2 id="9a33" class="lt jo iq bd jp lu lv dn jt lw lx dp jx kw ly lz kb la ma mb kf le mc md kj me bi translated">任务列表</h2><p id="0ecc" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><code class="fe lp lq lr ls b">TaskList</code>组件的作用是使用<code class="fe lp lq lr ls b">TaskListItem</code>组件显示可拖动和可编辑的项目，并允许用户使用<code class="fe lp lq lr ls b">TaskListActions</code>组件编辑和归档列表。</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi nr"><img src="../Images/5cd88bde701e4cd15d1c76b5c28e02ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s_RqCkU9XZhJMVzCiZZgeg.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">TaskList.vue</figcaption></figure><p id="e429" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">可拖动组件<code class="fe lp lq lr ls b">TaskListItem</code>用可拖动组件包装。它将为列表中的每一项进行渲染。而<code class="fe lp lq lr ls b">TaskListItem</code>在可拖动组件之外，用于添加一个新的<code class="fe lp lq lr ls b">TaskListItem</code>。</p><h2 id="68e1" class="lt jo iq bd jp lu lv dn jt lw lx dp jx kw ly lz kb la ma mb kf le mc md kj me bi translated">任务列表项</h2><p id="8830" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><code class="fe lp lq lr ls b">TaskListItem</code>组件负责，</p><ul class=""><li id="b880" class="mv mw iq kn b ko lk ks ll kw mx la my le mz li na nb nc nd bi translated">显示个别项目的详细信息</li><li id="f467" class="mv mw iq kn b ko ne ks nf kw ng la nh le ni li na nb nc nd bi translated">添加新项目</li><li id="dc96" class="mv mw iq kn b ko ne ks nf kw ng la nh le ni li na nb nc nd bi translated">更新现有项目并</li><li id="2d1b" class="mv mw iq kn b ko ne ks nf kw ng la nh le ni li na nb nc nd bi translated">删除现有项目</li></ul><p id="67be" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">该组件可以在任何给定时间处于显示或编辑模式，并且<code class="fe lp lq lr ls b">isEditing</code>组件状态变量用于在显示和编辑模式之间切换组件。</p><p id="afc3" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">最初，对于显示模式，组件使用<code class="fe lp lq lr ls b">isNewItem</code>和<code class="fe lp lq lr ls b">displayText</code>计算属性来显示适当的文本，当用户单击一个项目时，然后<code class="fe lp lq lr ls b">isEditing</code>变量被设置为true，组件显示表单。</p><p id="1029" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">需要注意的是，就组件而言，添加和更新是非常相似的操作，决定是添加还是更新数据不是组件的工作。</p><p id="0705" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">因此，组件只会在单击保存按钮时验证数据，然后简单地用数据调用<code class="fe lp lq lr ls b">saveTaskListItem</code> Vuex动作。该动作使用<code class="fe lp lq lr ls b">SAVE_TASKLIST_ITEM</code> Vuex变异，它将决定是更新一个现有的项目还是在列表中添加一个新的项目。</p><h2 id="b510" class="lt jo iq bd jp lu lv dn jt lw lx dp jx kw ly lz kb la ma mb kf le mc md kj me bi translated">任务列表操作</h2><p id="6d25" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">组件<code class="fe lp lq lr ls b">TaskListActions</code>的职责是当用户点击列表标题中的“…”时显示编辑和存档动作。</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi ns"><img src="../Images/407e97f98269c5f1338d377517d92f8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0ffv_ne4gvHVKGe0f0GtSg.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">TaskListActions.vue</figcaption></figure><p id="3ff6" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">编辑动作允许用户编辑<code class="fe lp lq lr ls b">list</code>细节，存档动作允许用户存档<code class="fe lp lq lr ls b">list</code>。</p><h2 id="99ce" class="lt jo iq bd jp lu lv dn jt lw lx dp jx kw ly lz kb la ma mb kf le mc md kj me bi translated">任务列表存档</h2><p id="db09" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><code class="fe lp lq lr ls b">TaskListArchive</code>组件的作用是显示一个弹出窗口来确认列表存档动作。</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi nt"><img src="../Images/21ff0231e9f1c353a550b5f0eade4cb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HvDZrJNV89iB0SR55GetpA.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">TaskListArchive.vue</figcaption></figure><p id="b0f7" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">如果用户点击“Yes，please”按钮，则调用<code class="fe lp lq lr ls b">archiveTaskList</code> Vuex动作来存档列表。</p><h2 id="3ce0" class="lt jo iq bd jp lu lv dn jt lw lx dp jx kw ly lz kb la ma mb kf le mc md kj me bi translated">任务列表编辑</h2><p id="a3ca" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">该组件的职责是显示一个带有表单的弹出窗口，以更新列表名称。</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi nu"><img src="../Images/e2a174c13f5ddd22dc86f3eb69536626.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zYTKm2c6z0ayQt75h0lv2Q.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">TaskListEdit.vue</figcaption></figure><p id="ec65" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">当用户保存表单时，<code class="fe lp lq lr ls b">handleTaskListSave</code>方法验证表单，如果验证成功，则调用<code class="fe lp lq lr ls b">saveTaskList</code> Vuex动作保存列表细节。</p><p id="28a1" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">注意，<code class="fe lp lq lr ls b">TaskListEdit</code>组件也被用来创建一个新的任务列表。</p><h2 id="c705" class="lt jo iq bd jp lu lv dn jt lw lx dp jx kw ly lz kb la ma mb kf le mc md kj me bi translated">任务列表还原</h2><p id="e20e" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">该组件的职责是显示一个带有已存档任务列表的弹出窗口。该组件遍历<code class="fe lp lq lr ls b">archivedLists</code>数组，并用<code class="fe lp lq lr ls b">Restore</code>按钮显示任务列表。</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi nv"><img src="../Images/ab10f2dd93c8c12b785af9a66d6e7393.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4ZYBFYTp_1cR6BofQZyC0A.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">TaskListRestore.vue</figcaption></figure><p id="9067" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">当用户点击恢复按钮时，就会调用<code class="fe lp lq lr ls b">restoreTaskList</code> Vuex动作来恢复列表。</p><h2 id="c58d" class="lt jo iq bd jp lu lv dn jt lw lx dp jx kw ly lz kb la ma mb kf le mc md kj me bi translated">任务板编辑</h2><p id="f544" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">该组件的职责是显示一个带有表单的弹出窗口，以更新电路板<code class="fe lp lq lr ls b">name</code>和<code class="fe lp lq lr ls b">description</code>的详细信息。</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi nw"><img src="../Images/ff8059c462da72a343d7d0f274b6f708.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XIbJNdcTceg-aor0nLa2fA.png"/></div></div></figure><p id="2b5d" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">当用户保存表单时，然后<code class="fe lp lq lr ls b">handleSaveBoard</code>方法验证表单，如果验证成功，则调用<code class="fe lp lq lr ls b">saveTaskBoard</code> Vuex动作来保存板细节。</p><p id="e07f" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">注意，相同的组件用于处理新任务板的创建。</p><p id="253d" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">在本节中，我们已经了解了应用程序组件及其职责，现在让我们仔细看看拖放功能是如何工作的，因为它是该应用程序的关键功能。</p><h1 id="2ee6" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">实现拖放</h1><p id="e6cd" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">HTML5提供了本地事件来实现拖放功能，但是，当你需要用多个组件实现相同的事件时，你的用户界面组件就会变得非常复杂。</p><p id="e98b" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">因此，为了减少应用程序的样板代码，我使用了来自<code class="fe lp lq lr ls b">sortable.js</code>库的<code class="fe lp lq lr ls b">VueDraggable</code>组件。这使我能够用几行代码在任务列表和任务列表项上快速实现拖放。</p><p id="38f4" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">让我们看看如何使用<code class="fe lp lq lr ls b">VueDraggable</code>组件的简单例子。</p><figure class="mg mh mi mj gt mk"><div class="bz fp l di"><div class="nx ny l"/></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">拖放单个列表中的项目</figcaption></figure><p id="e8eb" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">在演示中，我们有一个带有<code class="fe lp lq lr ls b">items</code>数组的<code class="fe lp lq lr ls b">list</code>对象，如下所示</p><pre class="mg mh mi mj gt nz ls oa ob aw oc bi"><span id="e874" class="lt jo iq ls b gy od oe l of og">list: {<br/> id: "1",<br/> name: "todo",<br/> items: [<br/>  { <br/>   id: "1",<br/>   text: "Build the feature #1"<br/>  },<br/>  { <br/>   id: "2",<br/>   text:"Test the feature #1"<br/>  },<br/>  ...<br/>  ...<br/> ]<br/>}</span></pre><p id="b738" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">现在，为了在列表中的单个项目上实现拖放，我们创建了<code class="fe lp lq lr ls b">TaskList</code>和<code class="fe lp lq lr ls b">TaskListItem</code>组件。</p><p id="cd74" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated"><code class="fe lp lq lr ls b">TaskList</code>组件通过<code class="fe lp lq lr ls b">props</code>从父组件接收<code class="fe lp lq lr ls b">list</code>对象，然后迭代<code class="fe lp lq lr ls b">items</code>计算属性以显示单个<code class="fe lp lq lr ls b">TaskListItem</code>组件。</p><pre class="mg mh mi mj gt nz ls oa ob aw oc bi"><span id="8a61" class="lt jo iq ls b gy od oe l of og"><strong class="ls ir">// task-list-template </strong><br/>&lt;div class="col-3 list-column list-width"&gt;<br/>    &lt;div class="heading"&gt;<br/>      &lt;h4 class="heading-text text-center"&gt;<br/>        {{ list.name }}<br/>      &lt;/h4&gt;<br/>    &lt;/div&gt;<br/>  &lt;draggable <br/>    <strong class="ls ir">v-model="items"</strong> <br/>    <strong class="ls ir">v-bind="dragOptions"</strong>&gt;<br/>      &lt;TaskListItem<br/>        class="task-item" <br/>        v-for="(item,index) in items" <br/>        :key="index" <br/>        :item="item"&gt;<br/>      &lt;/TaskListItem&gt;<br/>  &lt;/draggable&gt;<br/>  &lt;/div&gt;</span></pre><p id="69fe" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">在上面的代码片段中，需要注意的一个关键点是，我们用<code class="fe lp lq lr ls b">draggable</code>组件包装了<code class="fe lp lq lr ls b">TaskListItem</code>,并使用带有<code class="fe lp lq lr ls b">v-model</code>指令的<code class="fe lp lq lr ls b">items</code>计算属性来让可拖动组件管理所提供数据中单个项目的索引。</p><p id="8767" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">此外，我们使用<code class="fe lp lq lr ls b">v-bind</code>指令将组件的各种选项与<code class="fe lp lq lr ls b">dragOptions</code>计算属性绑定在一起。</p><pre class="mg mh mi mj gt nz ls oa ob aw oc bi"><span id="1aad" class="lt jo iq ls b gy od oe l of og">computed: {<br/> dragOptions() {<br/>  return {<br/>   animation: "200",<br/>   ghostClass: "ghost",<br/>   <strong class="ls ir">group: "task-list-items"</strong><br/>  }<br/> }<br/>}</span></pre><p id="810f" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated"><code class="fe lp lq lr ls b">dragOptions</code> computed property将返回一个带有<code class="fe lp lq lr ls b">animation</code>、<code class="fe lp lq lr ls b">ghostClass</code>和<code class="fe lp lq lr ls b">group</code>属性的JavaScript对象。</p><p id="f115" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">在<code class="fe lp lq lr ls b">dragOptions</code>对象中，</p><ul class=""><li id="02fc" class="mv mw iq kn b ko lk ks ll kw mx la my le mz li na nb nc nd bi translated"><code class="fe lp lq lr ls b">animation</code>将控制动画拖放效果的持续时间</li><li id="9ea7" class="mv mw iq kn b ko ne ks nf kw ng la nh le ni li na nb nc nd bi translated"><code class="fe lp lq lr ls b">ghostClass</code>将在预期的拖放位置显示一个占位符，</li><li id="aa6e" class="mv mw iq kn b ko ne ks nf kw ng la nh le ni li na nb nc nd bi translated"><code class="fe lp lq lr ls b">group</code>属性非常重要，因为它是在用户界面中启用拖放并共同识别和分组可拖动元素的关键。</li></ul><p id="d2f1" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated"><strong class="kn ir">现在，让我们了解一下单个项目的指数是如何更新的。</strong></p><p id="702a" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">下面的代码片段显示了用<code class="fe lp lq lr ls b">get</code>和<code class="fe lp lq lr ls b">set</code>函数以详细格式编写的<code class="fe lp lq lr ls b">items</code>计算属性。</p><pre class="mg mh mi mj gt nz ls oa ob aw oc bi"><span id="7148" class="lt jo iq ls b gy od oe l of og"><strong class="ls ir">// TaskList component</strong> <br/>computed: {<br/> items: {<br/>  get(){<br/>   return this.list.items<br/>  },<br/>  set(value){<br/>   this.list.items=value<br/>  }<br/> }<br/>}</span></pre><p id="36af" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">由于<code class="fe lp lq lr ls b">draggable</code>组件使用带有<code class="fe lp lq lr ls b">v-model</code>指令的<code class="fe lp lq lr ls b">items</code> computed属性，因此每次拖放，它都会调用带有更新数据的<code class="fe lp lq lr ls b">set</code>函数。现在为了持久化，我们简单地用接收到的数据更新list对象的<code class="fe lp lq lr ls b">items</code>属性。</p><blockquote class="oh oi oj"><p id="1333" class="kl km ok kn b ko lk kq kr ks ll ku kv ol lm ky kz om ln lc ld on lo lg lh li ij bi translated"><strong class="kn ir"> <em class="iq">提示:</em> </strong> <em class="iq">如果您正在使用Vuex进行数据处理，那么，在</em> <code class="fe lp lq lr ls b"><em class="iq">set</em></code> <em class="iq">功能中，您可以使用Vuex动作/突变来更新Vuex存储器中的状态。事实上，我们在应用程序中使用带有可拖动组件的Vuex。</em></p></blockquote><p id="5c58" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">到目前为止，我们已经看到了如何使用<code class="fe lp lq lr ls b">draggable</code>组件来实现单个列表中的拖放项目。</p><p id="ebc9" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">现在让我们更上一层楼，</p><ul class=""><li id="1ef7" class="mv mw iq kn b ko lk ks ll kw mx la my le mz li na nb nc nd bi translated">拖放整个列表</li><li id="fb75" class="mv mw iq kn b ko ne ks nf kw ng la nh le ni li na nb nc nd bi translated">在列表中拖放项目</li></ul><p id="da62" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">看看下面的演示。</p><p id="91c7" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">我们显示多个列表而不是一个列表，允许整个列表重新排列，项目也可以在列表中移动。</p><figure class="mg mh mi mj gt mk"><div class="bz fp l di"><div class="nx ny l"/></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">任务板实施</figcaption></figure><p id="20b1" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">为了显示多个列表，我们更新了数据，将<code class="fe lp lq lr ls b">board</code>作为顶层对象，该对象使用<code class="fe lp lq lr ls b">lists</code>数组属性来表示多个列表，每个列表使用<code class="fe lp lq lr ls b">items</code>数组属性来表示单个列表项。</p><pre class="mg mh mi mj gt nz ls oa ob aw oc bi"><span id="a188" class="lt jo iq ls b gy od oe l of og"><strong class="ls ir">board</strong>: {<br/> id:"1",<br/> name:"Project Tracker",<br/> description: "A board to track a project",<br/> lists: [<br/>  {<br/>   id: "1",<br/>   name: "todo",<br/>   items: [ ... ]<br/>  },<br/>  {<br/>   id: "2",<br/>   name: "doing",<br/>   items: [ ... ]<br/>  },<br/>  {<br/>   id: "3",<br/>   name: "done",<br/>   items: [ ... ]<br/>  },<br/>  {<br/>   id: "4",<br/>   name: "deploy",<br/>   items: [ ... ]<br/>  }<br/> ]<br/>}</span></pre><p id="d12d" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">为了展示单板，我们构建了一个名为<code class="fe lp lq lr ls b">TaskBoard</code>的新组件。<code class="fe lp lq lr ls b">TaskBoard</code>组件用于显示多个列表和管理列表的重新排序。而列表中的单个项目由前面演示中看到的<code class="fe lp lq lr ls b">TaskList</code>组件管理。</p><p id="0e75" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">为了实现列表的重新排序，在<code class="fe lp lq lr ls b">TaskBoard</code>组件中，我们现在用<code class="fe lp lq lr ls b">draggable</code>组件包装<code class="fe lp lq lr ls b">TaskList</code>组件，并用<code class="fe lp lq lr ls b">v-model</code>指令使用<code class="fe lp lq lr ls b">lists</code>计算属性。它将管理所提供数据中各个列表的索引。</p><pre class="mg mh mi mj gt nz ls oa ob aw oc bi"><span id="590d" class="lt jo iq ls b gy od oe l of og">&lt;draggable <br/>  v-model="lists" <br/>  v-bind="dragOptions" <br/>  class="row flex-nowrap my-3"<br/> &gt;<br/>  &lt;TaskList <br/>    v-for="(listItem, index) in lists"<br/>    :key="index"<br/>    :list="listItem"&gt;<br/>  &lt;/TaskList&gt;<br/>&lt;/draggable&gt;</span></pre><p id="0d16" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">除此之外，我们通过使用带有<code class="fe lp lq lr ls b">v-bind</code>指令的<code class="fe lp lq lr ls b">dragOptions</code>计算属性来绑定<code class="fe lp lq lr ls b">draggable</code>组件的多个属性。</p><p id="9e6d" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated"><code class="fe lp lq lr ls b">dragOptions</code> computed属性将返回一个包含<code class="fe lp lq lr ls b">animation</code>、<code class="fe lp lq lr ls b">ghostClass</code>、<code class="fe lp lq lr ls b">handle</code>和<code class="fe lp lq lr ls b">group</code>属性的普通JavaScript对象。</p><pre class="mg mh mi mj gt nz ls oa ob aw oc bi"><span id="2c92" class="lt jo iq ls b gy od oe l of og">computed: {<br/> dragOptions() {<br/>  return {<br/>   animation: "200",<br/>   ghostClass: "ghost",<br/>   handle: ".heading",<br/>   <strong class="ls ir">group: "task-board-lists"</strong><br/>  }<br/> }<br/>}</span></pre><p id="4ea2" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">类似于先前讨论的<code class="fe lp lq lr ls b">dragOptions</code>物体，</p><ul class=""><li id="704c" class="mv mw iq kn b ko lk ks ll kw mx la my le mz li na nb nc nd bi translated"><code class="fe lp lq lr ls b">animation</code>将控制动画拖放效果的持续时间</li><li id="cc5b" class="mv mw iq kn b ko ne ks nf kw ng la nh le ni li na nb nc nd bi translated"><code class="fe lp lq lr ls b">ghostClass</code>将在预期的拖放位置显示一个占位符</li><li id="1b52" class="mv mw iq kn b ko ne ks nf kw ng la nh le ni li na nb nc nd bi translated"><code class="fe lp lq lr ls b">handle</code>将识别拖动手柄元素，并</li><li id="ba4a" class="mv mw iq kn b ko ne ks nf kw ng la nh le ni li na nb nc nd bi translated"><code class="fe lp lq lr ls b">group</code>将在用户界面中共同识别和分组可拖动的元素。</li></ul><p id="57fd" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">注意，列表元素组的名称<code class="fe lp lq lr ls b">task-board-lists</code>不同于项目组<code class="fe lp lq lr ls b">task-list-items</code>。这是为了帮助<code class="fe lp lq lr ls b">draggable</code>组件正确区分两组不同的可拖动元素。</p><p id="c8ee" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated"><code class="fe lp lq lr ls b">draggable</code>组件足够聪明，能够理解我们有多个属于不同组的列表和项目，它只允许在<strong class="kn ir">同一个</strong>组的元素之间拖放。</p><p id="190d" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">通过明确命名不同的拖放组，我们可以将一个项目从一个列表移动到另一个列表，而不会有任何戏剧性的变化，并且允许列表被重新排序。</p><p id="3cad" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">现在让我们看看重新排序的列表是如何持久化的。与前面的演示相似，我们也使用详细格式的<code class="fe lp lq lr ls b">lists</code>计算属性。</p><pre class="mg mh mi mj gt nz ls oa ob aw oc bi"><span id="956c" class="lt jo iq ls b gy od oe l of og">computed: {<br/> lists: {<br/>  get() {<br/>   return this.board.lists<br/>  },<br/>  set(value) {<br/>   this.board.lists = value<br/>  }<br/> }<br/> ...<br/>}</span></pre><p id="d296" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">当任务列表被重新排序后，<code class="fe lp lq lr ls b">draggable</code>组件将调用<code class="fe lp lq lr ls b">lists</code>计算属性的<code class="fe lp lq lr ls b">set</code>函数，用更新后的数组来反映列表的新位置。为了保持更改，我们只需用接收到的数据覆盖board对象中的列表数组。</p><p id="4225" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">如本节所演示的，使用<code class="fe lp lq lr ls b">draggable</code>组件，拖放的概念非常容易在多个层次上实现(重新排序整个列表和在列表间重新排序/移动项目)。</p><p id="5ec4" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">您甚至可以进一步发展这一概念，并从构建更复杂的拖放界面中获得乐趣，</p><ul class=""><li id="c949" class="mv mw iq kn b ko lk ks ll kw mx la my le mz li na nb nc nd bi translated">带有组件小部件的管理仪表板(例如Salesforce管理仪表板)</li><li id="8321" class="mv mw iq kn b ko ne ks nf kw ng la nh le ni li na nb nc nd bi translated">面向客户的网站/页面生成器(例如网站生成器、WordPress主题生成器)</li></ul><p id="9ccc" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">在下一节中，我们将深入挖掘并理解<code class="fe lp lq lr ls b">slots</code>的概念，以设计应用程序中使用的可重用组件。</p><h1 id="5f8b" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">构建可重用组件</h1><p id="90fa" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">有几种不同的框架特性和设计模式可以用来在Vue.js中创建可重用的组件，如混合、插槽、作用域插槽、功能组件和无渲染组件等。</p><p id="6ede" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">在开发这个应用程序时，我遇到了一些具有共同行为的组件，例如，内容需要在弹出窗口中显示，但内容具有不同的标记，并实现了不同的功能集。因此，我决定用<code class="fe lp lq lr ls b">slots</code>来设计一个通用的popup组件。</p><p id="b196" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">对于插槽，子组件通常在标记中有一个或多个<code class="fe lp lq lr ls b">&lt;slot&gt;&lt;/slot&gt;</code>标签，它们只是内容的占位符。当父组件使用子组件时，这个<code class="fe lp lq lr ls b">slot</code>将为内容提供一个空间，甚至可以在其中实现交互性。</p><p id="b5b1" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">为了用通俗的语言理解插槽，以一个带有空白页面的笔记本为例。横线页可以被认为是槽，因为它们将由购买该笔记本的人来填写。</p><p id="6f2d" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">现在，如果笔记本被一个学校的孩子买走，那么它将成为一个学校笔记本，并且可能包含课堂笔记。同样，如果是上班族买的，那么很可能里面会有会议纪要。</p><p id="2865" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">因此，我们可以看到这种模式，即同一台笔记本可以由不同的用户用于不同的目的。然而，notebook只提供空行页面，至于往里面放什么内容完全由用户决定。</p><p id="0674" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">让我们看一个带有演示的老虎机示例。我构建了一个<code class="fe lp lq lr ls b">DetailsPopup</code>组件，它使用html5 <code class="fe lp lq lr ls b">&lt;details&gt;</code>和<code class="fe lp lq lr ls b">&lt;summary&gt;</code>标签来构建一个可重用的弹出组件。</p><figure class="mg mh mi mj gt mk"><div class="bz fp l di"><div class="oo ny l"/></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">使用Vue.js插槽</figcaption></figure><p id="67ec" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">在summary标签中，我们使用一个名为<code class="fe lp lq lr ls b">handle</code>的<code class="fe lp lq lr ls b">slot</code>来显示打开弹出窗口的标记，在div标签中，我们使用一个名为<code class="fe lp lq lr ls b">content</code>的<code class="fe lp lq lr ls b">slot</code>来显示弹出窗口的内容。</p><p id="f4b6" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated"><code class="fe lp lq lr ls b">DetailsPopup</code>组件有额外的方法<code class="fe lp lq lr ls b">open</code>和<code class="fe lp lq lr ls b">close</code>，这将简单地添加和删除<code class="fe lp lq lr ls b">open</code>属性来显示和隐藏弹出窗口。除了这些方法之外，组件还发出带有弹出窗口当前状态的<code class="fe lp lq lr ls b">popup-toggled</code>自定义事件，以指示它当前是打开还是关闭。</p><p id="66a0" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">在应用程序中，我们有使用<code class="fe lp lq lr ls b">DetailsPopup</code>组件的<code class="fe lp lq lr ls b">TaskListRestore</code>、<code class="fe lp lq lr ls b">TaskListArchive</code>、<code class="fe lp lq lr ls b">TaskListEdit</code>、<code class="fe lp lq lr ls b">TaskBoardEdit</code>组件。</p><p id="3e8e" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">我们以<code class="fe lp lq lr ls b">TaskListEdit</code>组件为例。</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi op"><img src="../Images/35830f4947673312e1c4f700cbf79874.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dIad2xZ1_90pNv3OvmqXiQ.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">TaskListEdit.vue —使用DetailsPopup组件的专用包装组件</figcaption></figure><p id="c92d" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">在上面的代码片段中，<code class="fe lp lq lr ls b">TaskListEdit</code>组件使用<code class="fe lp lq lr ls b">DetailsPopup</code>作为子组件，并为名为<code class="fe lp lq lr ls b">handle</code>和<code class="fe lp lq lr ls b">content</code>的槽提供标记，还实现了验证和保存表单的功能。</p><p id="fdac" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">由于<code class="fe lp lq lr ls b">TaskListRestore</code>、<code class="fe lp lq lr ls b">TaskListArchive</code>、<code class="fe lp lq lr ls b">TaskListEdit</code>、<code class="fe lp lq lr ls b">TaskBoardEdit</code>被放置在<code class="fe lp lq lr ls b">AppHeader</code>组件中，由于组件不遵循<code class="fe lp lq lr ls b">parent→child</code>组件组合模型，这带来了另一个与组件通信相关的问题。我们不能简单地使用props向它们传递数据，因为它们被放在不同的组件中。</p><p id="082d" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">因此，在下一节中，我们将讨论组合环境中的组件通信。</p><h1 id="1e31" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">组件通信</h1><p id="4791" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在<code class="fe lp lq lr ls b">parent→child</code>关系这样的基本组件组合中，推荐的从父组件传递数据到子组件的方式是通过<code class="fe lp lq lr ls b">props</code>，子组件可以通过使用<code class="fe lp lq lr ls b">$emit</code>发出一个事件与父组件进行通信。</p><p id="fb87" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">当组件不适合传统的<code class="fe lp lq lr ls b">parent→child</code>组合时，情况变得复杂。在这种情况下，您可以使用<code class="fe lp lq lr ls b">EventBus</code>模式在组件之间进行通信，这些组件可以放置在用户界面的任何位置，并且仍然可以监听和响应定制事件。</p><p id="c227" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">在事件总线模式中，我们使用一个Vue实例来发出、监听和响应应用程序中的自定义事件。这是一个通用但强大的模式，Vuex动作也可以使用它来发出或监听定制事件。</p><p id="a377" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">只用两行代码就可以建立事件总线。</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi oq"><img src="../Images/b1c934bb0df6d0d99562be7a9de01395.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BpBuFNp11-qTlZbM9QNzPA.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">设置事件总线— utils/bus.js</figcaption></figure><p id="aeb0" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">然后可以使用<code class="fe lp lq lr ls b">Bus</code>来发出和监听自定义事件，如下所示。</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi or"><img src="../Images/70a980f23a6fed175369c7955b19ebea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9sIIsxBeAu-8dhJuSxzqEg.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">事件总线模式的使用</figcaption></figure><p id="e846" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">让我们以<code class="fe lp lq lr ls b">TaskList</code>、<code class="fe lp lq lr ls b">TaskListActions</code>和<code class="fe lp lq lr ls b">TaskListEdit</code>元件为例。</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi os"><img src="../Images/0fd965f288a4f97a8cd4fac16ef0f8a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ot_mwQQnFmmoQGuwhSqtkw.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">TaskList.vue</figcaption></figure><p id="f7ff" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated"><code class="fe lp lq lr ls b">TaskListActions</code>组件被用作<code class="fe lp lq lr ls b">TaskList</code>组件的子组件，我们将<code class="fe lp lq lr ls b">board</code>和<code class="fe lp lq lr ls b">list</code>信息作为道具传递给<code class="fe lp lq lr ls b">TaskListActions</code>组件。</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi ot"><img src="../Images/dd1904571a5614077869b91bfe7e4da9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vYpMLPS5ur1K35K1C127BQ.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">TaskListActions.vue</figcaption></figure><p id="7da5" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">在上面的<code class="fe lp lq lr ls b">TaskListActions</code>组件中，<code class="fe lp lq lr ls b">showListEditPopup</code>方法以<code class="fe lp lq lr ls b">tasklist-editing</code>事件和<code class="fe lp lq lr ls b">list</code>数据作为有效载荷发出，而<code class="fe lp lq lr ls b">showArchiveListPopup</code>方法以<code class="fe lp lq lr ls b">list</code>和<code class="fe lp lq lr ls b">board</code>数据作为有效载荷在事件总线上发出<code class="fe lp lq lr ls b">tasklist-archiving</code>事件。</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi ou"><img src="../Images/fbb6674e918b7613e0d2fc87aee7b57b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MM546d90ZN9F86Mmtx5Ipg.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">TaskListEdit.vue</figcaption></figure><p id="5c21" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">在接收端，在<code class="fe lp lq lr ls b">TaskListEdit</code>组件中，我们在<code class="fe lp lq lr ls b">mounted()</code>生命周期钩子中设置了一个事件监听器和事件处理器。</p><pre class="mg mh mi mj gt nz ls oa ob aw oc bi"><span id="42c2" class="lt jo iq ls b gy od oe l of og">Bus.$on("tasklist-editing", this.handleTaskListEditing)</span></pre><p id="0867" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">我们使用<code class="fe lp lq lr ls b">Bus</code>对象的<code class="fe lp lq lr ls b">$on</code>方法开始监听事件，并提供<code class="fe lp lq lr ls b">handleTaskListEditing</code>函数来处理事件。<code class="fe lp lq lr ls b">handleTaskListEditing</code>方法的职责是用接收到的数据更新<code class="fe lp lq lr ls b">listForm</code>变量，并显示用于编辑的弹出窗口。</p><p id="b7ca" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">实际上，事件总线模式与<code class="fe lp lq lr ls b">Vuex</code>密切相关，大多数时候接收组件使用<code class="fe lp lq lr ls b">Vuex actions</code>用新信息更新状态。</p><p id="1e13" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">让我们来看看使用Vuex的数据和状态管理。</p><h1 id="6254" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">数据和状态管理</h1><p id="82c0" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在这个应用程序中，我们以分层格式组织了我们的电路板数据。这意味着，我们有一个板的数组，其中每个板可以有多个列表，每个列表中可以有一个或多个项目。</p><p id="0479" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">这是应用程序中单个电路板的样本数据。</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi ov"><img src="../Images/b5f6d77904cf64c8f0e72181b9b18735.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8e1L48Spo64gcgQoyHts7A.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">单个电路板的数据格式</figcaption></figure><p id="0612" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">上面的片段显示了单个电路板的格式。每个棋盘都有<code class="fe lp lq lr ls b">id</code>、<code class="fe lp lq lr ls b">name</code>、<code class="fe lp lq lr ls b">description</code>、<code class="fe lp lq lr ls b">archived</code>、<code class="fe lp lq lr ls b">lists</code>字段。<code class="fe lp lq lr ls b">archived</code>是一个布尔型字段，表示电路板是否存档，而<code class="fe lp lq lr ls b">lists</code>字段是一个列表对象数组。</p><p id="9c68" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">每个列表包含<code class="fe lp lq lr ls b">id</code>、<code class="fe lp lq lr ls b">name</code>、<code class="fe lp lq lr ls b">headerColor</code>、<code class="fe lp lq lr ls b">archived</code>和<code class="fe lp lq lr ls b">items</code>字段。其中<code class="fe lp lq lr ls b">archived</code>字段表示列表是否存档，<code class="fe lp lq lr ls b">items</code>字段是包含<code class="fe lp lq lr ls b">id</code>和<code class="fe lp lq lr ls b">text</code>字段的项目对象数组。</p><p id="17a7" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">现在我们已经了解了数据的结构，让我们看看<code class="fe lp lq lr ls b">Vuex</code>是如何在应用程序中使用的。</p><h2 id="2908" class="lt jo iq bd jp lu lv dn jt lw lx dp jx kw ly lz kb la ma mb kf le mc md kj me bi translated">状态管理</h2><p id="680d" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">Vue应用程序中有两种状态，本地组件状态和全局应用程序状态。局部组件状态对于定义单个组件的行为很有用，而全局应用程序状态在多个组件共享某个数据时很有用。</p><p id="92c2" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">对于全局应用状态，我们使用由Vue.js团队开发和维护的<code class="fe lp lq lr ls b">Vuex</code>库。</p><p id="bec4" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">Vuex用作集中式状态管理解决方案，它通过动作和突变提供应用程序状态的受控更新。当我说受控更新时，这意味着你不能仅仅修改全局状态，对状态的任何更新都必须经历突变。</p><p id="56f3" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">以下是Vuex在应用环境中的快速入门。</p><h2 id="b69c" class="lt jo iq bd jp lu lv dn jt lw lx dp jx kw ly lz kb la ma mb kf le mc md kj me bi translated">Vuex商店</h2><p id="4bfb" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">Vuex store是一个封装应用<code class="fe lp lq lr ls b">state</code>、<code class="fe lp lq lr ls b">getters</code>、<code class="fe lp lq lr ls b">mutations</code>和<code class="fe lp lq lr ls b">actions</code>并使应用状态可反应的容器。当应用程序状态变量被更新时，任何使用该状态变量的用户界面组件将自动用新信息更新。</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi ow"><img src="../Images/d7ab75f88266fc97e6863c3f2cd13feb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M2kJUpwUIfNDk2wN6bAmSw.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">Vuex store — store/index.js</figcaption></figure><h2 id="971b" class="lt jo iq bd jp lu lv dn jt lw lx dp jx kw ly lz kb la ma mb kf le mc md kj me bi translated">Vuex状态</h2><p id="dde1" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">Vuex state是此应用程序使用的集中式共享数据。它是一个普通的老式javascript对象(POJO ),变量以键值对格式定义。</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi ox"><img src="../Images/60eecccc38b51d2f7b280c6177ee094c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NmZoUbjnopoTLbQsAG7mGg.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">Vuex state — store/state.js</figcaption></figure><p id="4c10" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">在上面的代码中，<code class="fe lp lq lr ls b">AppLoadingIndicator</code>组件使用<code class="fe lp lq lr ls b">isLoading</code>状态变量来显示Vuex动作获取数据并将其加载到状态时的加载指示器动画。</p><p id="b9b2" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated"><code class="fe lp lq lr ls b">activeBoard</code>变量保存用户当前打开的电路板的引用。<code class="fe lp lq lr ls b">boards</code>变量是一个数组，包含各个单板的信息。</p><h2 id="a456" class="lt jo iq bd jp lu lv dn jt lw lx dp jx kw ly lz kb la ma mb kf le mc md kj me bi translated">真空吸气剂</h2><p id="5fb8" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">Vuex getters是用来访问状态变量的函数，但是如果需要的话，你也可以用它们来返回转换后的数据。</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi oy"><img src="../Images/ec23ba14f2e9f634b333560ce7ab7c04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v9FTf8eRlztPtWwyTrEpAA.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">Vuex Getters — store/getters.js</figcaption></figure><p id="7540" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">例如，在上面的代码片段中，<code class="fe lp lq lr ls b">archivedBoards</code>过滤了<code class="fe lp lq lr ls b">boards </code>状态变量，并只返回存档的电路板。然而，<code class="fe lp lq lr ls b">archivedLists</code> getter检查是否设置了<code class="fe lp lq lr ls b">activeBoard</code>，然后只有它返回存档列表，否则返回一个空数组。</p><h2 id="780d" class="lt jo iq bd jp lu lv dn jt lw lx dp jx kw ly lz kb la ma mb kf le mc md kj me bi translated">Vuex突变</h2><p id="629a" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">Vuex突变是唯一可以用新数据更新状态变量的函数。变异函数接收<code class="fe lp lq lr ls b">state</code>对象作为第一个参数，后跟任何有效载荷参数。</p><pre class="mg mh mi mj gt nz ls oa ob aw oc bi"><span id="d914" class="lt jo iq ls b gy od oe l of og"><strong class="ls ir">// store/mutations.js<br/></strong>// Set Initial Boards Data</span><span id="237e" class="lt jo iq ls b gy oz oe l of og">SET_INITIAL_DATA(state, payload) {<br/>  state.boards = payload<br/>}</span></pre><p id="5e1a" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">上面的代码片段声明了一个<code class="fe lp lq lr ls b">SET_INITIAL_DATA</code>变异，它接收<code class="fe lp lq lr ls b">state</code>对象和有效负载作为参数。通过状态对象，我们可以访问<code class="fe lp lq lr ls b">boards</code>变量并用有效载荷更新它。</p><p id="c38d" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">通过使用Vuex的<code class="fe lp lq lr ls b">mapMutations</code>助手，可以在Vue组件中直接访问Vuex突变，但是随着应用程序的增长，您需要处理某些任务，例如，</p><ul class=""><li id="f162" class="mv mw iq kn b ko lk ks ll kw mx la my le mz li na nb nc nd bi translated">调用外部API获取或更新数据</li><li id="7896" class="mv mw iq kn b ko ne ks nf kw ng la nh le ni li na nb nc nd bi translated">显示toast通知</li><li id="b3d7" class="mv mw iq kn b ko ne ks nf kw ng la nh le ni li na nb nc nd bi translated">发送电子邮件通知</li><li id="8866" class="mv mw iq kn b ko ne ks nf kw ng la nh le ni li na nb nc nd bi translated">将用户路由到特定路由</li></ul><p id="a38a" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">使用上述实现，您的组件代码会变得不必要的复杂。</p><p id="1c4d" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">一种更好的组织代码的方式是通过<code class="fe lp lq lr ls b">Vuex actions</code>，因为它们提供了一个围绕<code class="fe lp lq lr ls b">Vuex mutations</code>的抽象层，而且由于它们本质上是异步的，它们更适合在调用<code class="fe lp lq lr ls b">Vuex mutations</code>之前或之后调用任何业务逻辑。</p><p id="f0bf" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">你可以在Vuex官方文档中阅读更多关于Vuex突变的信息。</p><p id="c146" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">下面的片段显示了该应用程序使用的所有Vuex突变。</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi pa"><img src="../Images/fbf1944274dec98efd08322a5ac60b25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0k2I84hHpel2byTOaS6s2w.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">Vuex突变— store/mutations.js</figcaption></figure><h2 id="d95d" class="lt jo iq bd jp lu lv dn jt lw lx dp jx kw ly lz kb la ma mb kf le mc md kj me bi translated">Vuex操作</h2><p id="9d39" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">Vuex动作使用突变来操作状态中的数据。突变和动作的关键区别在于，Vuex同步<strong class="kn ir">调用突变</strong>，而动作本质上是<strong class="kn ir">异步</strong>。因此，您可以在操作中使用业务逻辑，然后调用适当的变异来更新状态。</p><p id="12c7" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">你可以在Vuex官方文档中阅读更多关于Vuex动作的信息。</p><p id="2a2f" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">为了获取和加载数据，我将样本数据存储在一个<a class="ae lj" href="https://github.com/techlab23/data-repository" rel="noopener ugc nofollow" target="_blank"> github存储库</a>中，并在应用程序第一次启动时使用<code class="fe lp lq lr ls b"><a class="ae lj" href="https://github.com/axios/axios" rel="noopener ugc nofollow" target="_blank">axios</a></code>获取数据。</p><p id="8b07" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">我们举一个<code class="fe lp lq lr ls b">fetchData</code> Vuex动作的例子，这个动作用于获取和加载app使用的样本数据。因为所有的Vuex动作都接收一个<code class="fe lp lq lr ls b">context</code>对象作为第一个参数，所以我们只是简单地析构该对象并取出<code class="fe lp lq lr ls b">commit</code>方法来调用我们的突变。</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi pb"><img src="../Images/f9f89f44b869c941cc46470ea953e772.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SvH0eLD3Ya2S6NLbHdWbWQ.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">Vuex操作—提取数据</figcaption></figure><p id="fe01" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">在上面的代码片段中，我调用了<code class="fe lp lq lr ls b">SET_LOADING_STATE</code>突变来更新<code class="fe lp lq lr ls b">isLoading</code>状态变量，这将使<code class="fe lp lq lr ls b">AppLoadingIndicator</code>组件在axios从URL获取样本数据时显示加载指示器动画。</p><p id="5c2f" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">接收到数据后，我调用<code class="fe lp lq lr ls b">SET_INITIAL_DATA</code>突变用接收到的数据更新<code class="fe lp lq lr ls b">boards</code>状态变量，然后调用<code class="fe lp lq lr ls b">SET_LOADING_STATE</code>突变将<code class="fe lp lq lr ls b">isLoading</code>状态变量更新为false，这将使<code class="fe lp lq lr ls b">AppLoadingIndicator</code>组件隐藏加载指示器动画。</p><p id="92e0" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">下面的代码片段显示了应用程序中使用的所有Vuex操作。</p><figure class="mg mh mi mj gt mk gh gi paragraph-image"><div role="button" tabindex="0" class="ml mm di mn bf mo"><div class="gh gi pc"><img src="../Images/f12148ef0d0da07ec34c67c95bdf0c63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tkMnnl6hrO4wJAnbqvFdCg.png"/></div></div><figcaption class="mr ms gj gh gi mt mu bd b be z dk translated">Vuex操作— store/actions.js</figcaption></figure><p id="0a18" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">本地组件状态可帮助您在组件中实现特定行为，而Vuex提供可由多个组件使用的全局应用程序状态，由于它是反应性的，因此对特定状态数据的任何更新都会自动触发依赖于状态数据的组件的重新呈现。</p><p id="656f" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">Vuex通过动作和突变向应用程序提供结构化和受控的状态更新机制，这使得调试您的应用程序更加容易。</p><p id="1162" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">实现Vuex后，您可能会看到的一个好处是本地组件状态减少到最小或不存在，这是因为组件开始更多地依赖于通过<code class="fe lp lq lr ls b">Vuex getters</code>共享的状态，而不是本地组件状态。</p><h1 id="d3f6" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">下一步是什么？</h1><p id="ae34" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在本文中，我们讨论了使用通用和专用的Vue组件逐步构建用户界面的<code class="fe lp lq lr ls b">top-down</code>方法，并理解了如何在应用程序的上下文中应用该方法。</p><p id="fe77" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">我们还讨论了作为构建可重用组件的方法之一的<code class="fe lp lq lr ls b">slots</code>,并学习了当<code class="fe lp lq lr ls b">Parent→Child</code>的组件组合不能满足目的时，如何实现拖放以及应用<code class="fe lp lq lr ls b">Event Bus</code>模式在组件之间进行通信。</p><p id="819f" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">最后，我们讨论了应用程序的数据结构，并了解了如何使用<code class="fe lp lq lr ls b">Vuex</code>来管理使用<code class="fe lp lq lr ls b">store</code>、<code class="fe lp lq lr ls b">state</code>、<code class="fe lp lq lr ls b">getters</code>、<code class="fe lp lq lr ls b">mutations</code>和<code class="fe lp lq lr ls b">actions</code>的全局应用程序状态。</p><p id="3ab4" class="pw-post-body-paragraph kl km iq kn b ko lk kq kr ks ll ku kv kw lm ky kz la ln lc ld le lo lg lh li ij bi translated">我们将在本文的下一部分讨论表单验证、Vue.js插件、包优化和应用程序部署。</p><h2 id="df3e" class="lt jo iq bd jp lu lv dn jt lw lx dp jx kw ly lz kb la ma mb kf le mc md kj me bi translated"><strong class="ak">更新:</strong></h2><h2 id="dfec" class="lt jo iq bd jp lu lv dn jt lw lx dp jx kw ly lz kb la ma mb kf le mc md kj me bi translated">使用Vue.js的任务管理应用程序—第2部分</h2><p id="2695" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><a class="ae lj" rel="noopener ugc nofollow" target="_blank" href="/task-management-application-using-vue-js-part-2-d785a96acda6">https://level up . git connected . com/task-management-application-using-vue-js-part-2-d 785 a 96 acda 6</a></p></div></div>    
</body>
</html>