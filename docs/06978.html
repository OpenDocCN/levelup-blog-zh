<html>
<head>
<title>The 3 Applications of Hash Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">哈希函数的3个应用</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/the-3-applications-of-hash-functions-fab1a75f4d3d?source=collection_archive---------2-----------------------#2021-01-17">https://levelup.gitconnected.com/the-3-applications-of-hash-functions-fab1a75f4d3d?source=collection_archive---------2-----------------------#2021-01-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="dedc" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">它们是什么，有哪些选择，以及它们为什么重要</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6d6f408e3c5333f67367f783ef3312f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*61uolxM5HsroqBFaQxsGxQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图片作者:马丁·托马斯</figcaption></figure><p id="75b5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">哈希函数将任意多个字节作为输入，并产生一个固定长度的字符串作为输出。该字符串通常看起来完全随机，但是相同的输入总是生成相同的输出。对于不同的输入，它们通常会产生不同的输出，但稍后会详细介绍。</p><p id="7d00" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">读完这篇文章后，你会知道散列函数的三种不同的应用。所有这些对于现代软件开发都是至关重要的。我们走吧！</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="b902" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">平凡的散列函数</h1><p id="668c" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">假设我们想要一个散列函数，它接受任意长度的输入并生成一个128位的输出。</p><p id="5dca" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">计算散列的简单方法是查看128位数据块。如果输入不是128位的倍数，我们就用零填充它。然后我们对这些块进行异或运算:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="8352" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这只是哈希函数的一个非常简单的例子。它有两个很好的特性:执行速度非常快，非常简单。</p><p id="fc1d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">缺点也很明显:</p><ul class=""><li id="2feb" class="nb nc it la b lb lc le lf lh nd ll ne lp nf lt ng nh ni nj bi translated">通过更改输入来强制执行某个哈希值是很简单的事情</li><li id="0f16" class="nb nc it la b lb nk le nl lh nm ll nn lp no lt ng nh ni nj bi translated">如果您使用散列函数进行错误检查，您将无法在相同的位置以散列长度为模捕获偶数个错误。因此，如果您在第127位和第255位有错误，哈希将与没有错误时相同。</li><li id="2113" class="nb nc it la b lb nk le nl lh nm ll nn lp no lt ng nh ni nj bi translated">短输入的哈希值(低于哈希值的长度)就是填充的输入。可以直接看。</li></ul><h1 id="e46d" class="mb mc it bd md me np mg mh mi nq mk ml jz nr ka mn kc ns kd mp kf nt kg mr ms bi translated">应用1:密码</h1><p id="b06e" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">当你在网站注册时，你通常需要输入密码。但是网站可能会被黑，攻击者可能会得到你的密码。为了保护用户，密码不以明文形式存储。它们也没有加密。相反，它们被散列。这意味着我们对它们应用一个<strong class="la iu">单向函数</strong>。散列函数的一个典型例子是MD5。在Python中，您可以像这样应用它:</p><pre class="kj kk kl km gt nu nv nw nx aw ny bi"><span id="edd5" class="nz mc it nv b gy oa ob l oc od"># IMPORTANT: DO NOT USE MD5 FOR PASSWORDS!<br/>&gt;&gt;&gt; import hashlib<br/>&gt;&gt;&gt; hashlib.md5(b"unicorn").hexdigest()<br/>'1abcb33beeb811dca15f0ac3e47b88d9'<br/>&gt;&gt;&gt; hashlib.md5(b"unicorns").hexdigest()<br/>'02d8c4ac323c5df679077f020f170453'</span></pre><p id="1d35" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可以在这里看到两个关键属性:(1)输入的长度无关紧要；输出的长度是恒定的，并且(2)不同的输入映射到不同的输出。</p><p id="c4c3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您看不到的是哈希函数的单向特性:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/d4ede014f8fe27a9f60f2fef35463e37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QUPHWtW-lPEXWGEpb-YPtg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图片作者:马丁·托马斯</figcaption></figure><p id="1218" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">计算给定密码的哈希值相对较快且具有确定性。给定哈希值，不可能确切知道原始密码。出现这种情况的原因是冲突:密码可以任意长，但是哈希值的长度是固定的。这意味着一定有一些(不同的)密码具有相同的哈希值。对于好的散列函数来说，这是超级不可能的。</p><p id="4933" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通常，查找具有给定哈希值的密码的最佳选择是尝试每个可能的密码，直到看到相同的哈希值:</p><pre class="kj kk kl km gt nu nv nw nx aw ny bi"><span id="bfe6" class="nz mc it nv b gy oa ob l oc od">def inverse_hash(hashed_password):<br/>    for password in generate_new_password():<br/>        if hash(password) == hashed_password:<br/>            return password</span></pre><p id="2a64" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这比计算哈希值难多了。对于随机生成的密码，很可能您必须尝试数十亿个密码，直到您碰巧找到一个具有正确哈希的密码。</p><p id="27c5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu">密码哈希函数</strong>是哈希函数，但并不是所有的哈希函数都是密码哈希函数。加密哈希函数需要的其他属性有:</p><ul class=""><li id="44f8" class="nb nc it la b lb lc le lf lh nd ll ne lp nf lt ng nh ni nj bi translated"><strong class="la iu">预镜像抗攻击能力</strong>:给定<code class="fe of og oh nv b">hash(m1)</code>，找不到<code class="fe of og oh nv b">m1</code>。</li><li id="0bcb" class="nb nc it la b lb nk le nl lh nm ll nn lp no lt ng nh ni nj bi translated"><strong class="la iu">雪崩效应</strong>:如果你改变输入中的单个比特，输出中的每个比特都有50%的概率发生变化。这个属性是可取的，因为它表明您没有得到任何关于前映像的信息。</li><li id="9e8a" class="nb nc it la b lb nk le nl lh nm ll nn lp no lt ng nh ni nj bi translated"><strong class="la iu">抗碰撞攻击</strong>:找不到哈希值<code class="fe of og oh nv b">hash(m1) == hash(m2)</code>相同的<code class="fe of og oh nv b">m1</code>和<code class="fe of og oh nv b">m2</code>消息。</li><li id="93f6" class="nb nc it la b lb nk le nl lh nm ll nn lp no lt ng nh ni nj bi translated"><strong class="la iu">选择前缀抗攻击</strong>:这比碰撞抗攻击更一般。给定两个前缀<code class="fe of og oh nv b">p1</code>和<code class="fe of og oh nv b">p2</code>，找到两个消息<code class="fe of og oh nv b">m1</code>和<code class="fe of og oh nv b">m2</code>，使得它们的串联给出相同的散列:<br/> <code class="fe of og oh nv b">hash(p1+m1) == hash(p2+m2)</code> ( <a class="ae my" href="https://en.wikipedia.org/wiki/Collision_attack" rel="noopener ugc nofollow" target="_blank">源</a>)</li></ul><p id="7c8e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果攻击者想要应用上面给出的<code class="fe of og oh nv b">inverse_hash</code>,你应该让它成为一个超级耗时的操作。因此，通过应用哈希函数1000次，您可以将执行时间从大约100μs推到100ms。</p><p id="1dda" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要了解更多细节，请阅读我的关于密码哈希的文章:</p><div class="oi oj gp gr ok ol"><a rel="noopener  ugc nofollow" target="_blank" href="/password-hashing-eb3b97684636"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd iu gy z fp oq fr fs or fu fw is bi translated">密码哈希😇</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">准备好被黑吧</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="ou l"><div class="ov l ow ox oy ou oz ks ol"/></div></div></a></div></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="7f99" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">应用2:完整性检查</h1><p id="63ac" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">有时你只想知道两个文件是否可能完全相同。例如，您可能希望创建一个程序来扫描目录和所有子目录中的重复文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="011d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这个应用程序中，我们使用两个不同的哈希值通常意味着输入是不同的这一事实。哈希冲突很少发生。然后，您还可以比较<code class="fe of og oh nv b">duplicate_set</code>中的文件，以确保它们确实是重复的。</p><p id="875b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这种方法也可以用来确保文件的完整性。想想你下载的大文件。您可以通过计算已下载文件的校验和与在线文件的校验和来检查下载过程中是否出现了问题。</p><h1 id="8f4e" class="mb mc it bd md me np mg mh mi nq mk ml jz nr ka mn kc ns kd mp kf nt kg mr ms bi translated">应用3:区块链中的工作证明</h1><p id="9a9e" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">比特币和其他各种区块链使用一种叫做“工作证明”的概念。对于这些技术来说，能够证明你在一个问题上投入了一定的计算资源是很重要的。解决这个问题需要很难，但是容易产生问题实例。工作证明的一个常见选择是使用加密散列函数，并要求输入生成具有特定模式的散列值。例如:</p><blockquote class="pa pb pc"><p id="196d" class="ky kz pd la b lb lc ju ld le lf jx lg pe li lj lk pf lm ln lo pg lq lr ls lt im bi translated">找到一个字符串<code class="fe of og oh nv b">x</code>，使得<code class="fe of og oh nv b">y := sha256(x)</code>和<code class="fe of og oh nv b">y</code>以<code class="fe of og oh nv b">0000</code>开始</p></blockquote><p id="32a1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这种模式受到的限制越多，解决这个任务就越难。因此你必须投入更多的工作。</p><p id="3af6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面是一个解决此类任务的简短程序:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="bd90" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你想了解更多关于如何在区块链中使用工作证明的背景，可以看看我的介绍性文章:</p><div class="oi oj gp gr ok ol"><a href="https://medium.com/coinmonks/the-blockchain-473aac352e5" rel="noopener follow" target="_blank"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd iu gy z fp oq fr fs or fu fw is bi translated">区块链</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">₿区块链、比特币及相关概念介绍</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">medium.com</p></div></div><div class="ou l"><div class="ph l ow ox oy ou oz ks ol"/></div></div></a></div><h1 id="4a64" class="mb mc it bd md me np mg mh mi nq mk ml jz nr ka mn kc ns kd mp kf nt kg mr ms bi translated">额外收获:字典/地图/关联数组</h1><p id="43fb" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated"><strong class="la iu">哈希映射</strong>是一种数据结构，通常将字符串或数字映射到任何对象。它们在Python中称为字典，在PHP中称为关联数组，在Java中称为HashMap/HashTable，在C++中简称为Map。概念超级酷；看看<a class="ae my" href="https://en.wikipedia.org/wiki/Hash_table" rel="noopener ugc nofollow" target="_blank">维基百科的文章</a>。</p><p id="73c1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你对Python是如何做到的感兴趣，那么<a class="pi pj ep" href="https://medium.com/u/50a1e60db988?source=post_page-----fab1a75f4d3d--------------------------------" rel="noopener" target="_blank"> Praveen Gollakota </a>写了一个<a class="ae my" href="https://stackoverflow.com/a/9022835/562769" rel="noopener ugc nofollow" target="_blank">棒极了的StackOverflow答案</a>和<a class="pi pj ep" href="https://medium.com/u/e72f14e8b4ab?source=post_page-----fab1a75f4d3d--------------------------------" rel="noopener" target="_blank"> Ian Clelland </a>解释了<a class="ae my" href="https://stackoverflow.com/a/8998010/562769" rel="noopener ugc nofollow" target="_blank">默认使用哪些散列函数</a>。</p></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="c46f" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">碰撞有多常见？</h1><p id="8936" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">对于这个例子，我们只需要散列466，550个英语单词。一本相当全面的词典。</p><p id="af2c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们首先了解一下概况:</p><pre class="kj kk kl km gt nu nv nw nx aw ny bi"><span id="8a00" class="nz mc it nv b gy oa ob l oc od">Hash function        collisions      ns/value          bits<br/>-------------------------------------------------------------------<br/>sha512               0                1250.0 ns/value  512 bit<br/>sha256               0                1039.0 ns/value  256 bit<br/>sha1                 0                 884.0 ns/value  160 bit<br/>RIPEMD160            0               13892.7 ns/value  160 bit<br/>md5                  0                 857.8 ns/value  128 bit<br/>crc32                23                596.3 ns/value   32 bit<br/>adler32              227,149           660.9 ns/value   32 bit<br/>char_xor             466,422           993.9 ns/value    7 bit</span></pre><p id="ce7b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这里有几件事值得注意:</p><ul class=""><li id="2b51" class="nb nc it la b lb lc le lf lh nd ll ne lp nf lt ng nh ni nj bi translated">128位或更高的哈希没有任何冲突。<code class="fe of og oh nv b">char_xor</code>实际上只使用7位，因此最多只能编码128个不同的字。</li><li id="be6f" class="nb nc it la b lb nk le nl lh nm ll nn lp no lt ng nh ni nj bi translated">RIPEMD160比SHA哈希函数慢得多。很可能<a class="ae my" href="https://en.wikipedia.org/wiki/Intel_SHA_extensions" rel="noopener ugc nofollow" target="_blank">英特尔SHA扩展</a>，也就是直接硬件支持，是速度如此之快的原因。沙的知名度极高，流传甚广。出于这个原因，我希望实现非常高效。</li></ul><p id="29b4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你好奇的话，这是CRC32的23次碰撞:</p><pre class="kj kk kl km gt nu nv nw nx aw ny bi"><span id="4061" class="nz mc it nv b gy oa ob l oc od">('Audras', 'bermensch')<br/>('defeudalize', 'demobilisation')<br/>('dyn', 'gigmanism')<br/>('gigmaness', 'hyp')<br/>('Endamoebidae', 'Ilysa')<br/>('card-cutting', 'intertwinements')<br/>('eminency', 'Kelcie')<br/>('drift-netter', 'lattermath')<br/>('meny', 'menthols')<br/>('funerary', 'morenosite')<br/>('envoyship', 'platycarpous')<br/>('buckeroo', 'plumless')<br/>('fetishists', 'precedential')<br/>('penetration', 'prepituitary')<br/>('death-polluted', 'rabbitoh')<br/>('Bridget', 'slagging')<br/>('bimasty', 'superspecial')<br/>('droopingness', 'thalloid')<br/>('coach-box', 'tythed')<br/>('luminesce', 'twice-given')<br/>('casewood', 'uncontorted')<br/>('bronziest', 'unexigible')<br/>('pachadoms', 'wind-changing')</span></pre></div><div class="ab cl lu lv hx lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="im in io ip iq"><h1 id="8de5" class="mb mc it bd md me mf mg mh mi mj mk ml jz mm ka mn kc mo kd mp kf mq kg mr ms bi translated">下一步是什么？</h1><p id="5aae" class="pw-post-body-paragraph ky kz it la b lb mt ju ld le mu jx lg lh mv lj lk ll mw ln lo lp mx lr ls lt im bi translated">我想过写一个关于开发者基础的系列。我可以想象一篇关于浮动的文章，一篇关于日期/时间、架构、网络的文章。让我知道你对什么感兴趣！</p></div></div>    
</body>
</html>