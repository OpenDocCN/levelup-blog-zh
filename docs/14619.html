<html>
<head>
<title>3 Ways of Testing Randomness: Uncle Bob’s Solution Will Surprise You.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">3种检验随机性的方法:鲍勃大叔的解决方案会让你大吃一惊。</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/3-ways-of-testing-randomness-uncle-bobs-solution-will-surprise-you-ed9740181d6d?source=collection_archive---------13-----------------------#2022-12-12">https://levelup.gitconnected.com/3-ways-of-testing-randomness-uncle-bobs-solution-will-surprise-you-ed9740181d6d?source=collection_archive---------13-----------------------#2022-12-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="da56" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">用仿制品？用兰姆达斯？拥抱随机性？哪种方式更好？</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/7388c19182c94d00f5cf95eff4806b25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uDpNPktA_tYlnn4a"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">照片由<a class="ae le" href="https://unsplash.com/@_staticvoid?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Lucas Santos </a>在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h2 id="5704" class="lf lg it bd lh li lj dn lk ll lm dp ln kb lo lp lq kf lr ls lt kj lu lv lw lx bi translated">概观</h2><p id="0f23" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">在本文中，我们将探索三种不同的方法来测试使用随机生成的数字的代码。对于本文中的代码示例，我们将使用<em class="md">武器</em>类，并尝试测试<em class="md"> getDamege() </em>方法:</p><pre class="kp kq kr ks gt me mf mg bn mh mi bi"><span id="67f7" class="mj lg it mf b be mk ml l mm mn">class Weapon {<br/>    private final int baseDamage = 100;<br/>    private final int randomnessDelta = 5;<br/><br/>    public int getDamage() {<br/>        int min = baseDamage - randomnessDelta;<br/>        int max = baseDamage + randomnessDelta;<br/>        return ThreadLocalRandom.current().nextInt(min, max + 1);<br/>    }<br/>}</span></pre></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h2 id="45a8" class="lf lg it bd lh li lj dn lk ll lm dp ln kb lo lp lq kf lr ls lt kj lu lv lw lx bi translated">1.依赖性倒置和模仿</h2><p id="7fa0" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">首先，我们可以使用依赖倒置原则。这将允许我们打破<em class="md">武器</em>类和<em class="md">线程本地随机</em>类之间的直接依赖关系。</p><p id="d3d7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为此，我们需要用一个方法声明一个接口，该方法将接受上限和下限，并将返回它们之间的一个随机值—我们称之为<em class="md"> WeaponRandomGenerator </em>:</p><pre class="kp kq kr ks gt me mf mg bn mh mi bi"><span id="ee18" class="mj lg it mf b be mk ml l mm mn">class WeaponDi {<br/>    private final RandomGenerator random;<br/>    private final int baseDamage = 100;<br/>    private final int randomnessDelta = 5;<br/><br/>    public WeaponDi(RandomGenerator random) {<br/>        this.random = random;<br/>    }<br/><br/>    public int getDamage() {<br/>        int min = baseDamage - randomnessDelta;<br/>        int max = baseDamage + randomnessDelta;<br/>        return random.nextInt(min, max);<br/>    }<br/><br/>    interface WeaponRandomGenerator {<br/>        int nextInt(int min, int max);<br/>    }<br/>}</span></pre><p id="aa1c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，我们现在可以使用mocking库轻松测试武器类。例如，您可以通过Java的Mockito实现这一点:</p><pre class="kp kq kr ks gt me mf mg bn mh mi bi"><span id="c5f2" class="mj lg it mf b be mk ml l mm mn">@Test<br/>void whenMockingRandom_weaponShouldReturnMockedValue() {<br/>    var mockedRandom = Mockito.mock(WeaponDi.RandomGenerator.class);<br/>    Mockito.when(mockedRandom.nextInt(95, 105))<br/>        .thenReturn(102);<br/><br/>    WeaponDi weapon = new WeaponDi(mockedRandom);<br/><br/>    assertThat(weapon.getDamage())<br/>        .isEqualTo(102);<br/>}</span></pre><p id="b644" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果这个解决方案适合您，并且您想更深入地了解它，我推荐您阅读我的另一篇关于<a class="ae le" href="https://medium.com/codex/mvc-violation-ruined-his-tic-tac-toe-game-2a9c88c8f940" rel="noopener">依赖倒置、创建您自己的模拟对象和MVC </a>的文章。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h2 id="f5be" class="lf lg it bd lh li lj dn lk ll lm dp ln kb lo lp lq kf lr ls lt kj lu lv lw lx bi translated">2.使用Lambda表达式的依赖性反转</h2><p id="0b58" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">正如我们所看到的，上一个例子中的<em class="md">weaporandomgenerator</em>接口包含一个函数。</p><p id="2b2c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，我们可以用一个接受两个整数参数并返回一个整数结果的函数来代替接口的用法。如果我们是Java的话，可以简单的用<em class="md"> @FunctionalInterface </em>来注释接口，应该就够了。</p><p id="5f7c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当在<em class="md">生产中运行时，</em>我们将传递一个lambda，它基于<em class="md"> ThreadLocalRandom: </em>生成一个随机数</p><pre class="kp kq kr ks gt me mf mg bn mh mi bi"><span id="0dfa" class="mj lg it mf b be mk ml l mm mn">new WeaponDi((min, max) -&gt; ThreadLocalRandom.current().nextInt(min, max + 1));</span></pre><p id="bf5e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然而，在<em class="md">测试</em>中，我们将传递一个lambda表达式，该表达式始终返回相同的硬编码值:</p><pre class="kp kq kr ks gt me mf mg bn mh mi bi"><span id="4093" class="mj lg it mf b be mk ml l mm mn">@Test<br/>void whenPassingALambda_weaponShouldReturnHardcodedValue() {<br/>    WeaponDi weapon = new WeaponDi((min, max) -&gt; 102);<br/><br/>    assertThat(weapon.getDamage())<br/>        .isEqualTo(102);<br/>}</span></pre></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h2 id="fbe4" class="lf lg it bd lh li lj dn lk ll lm dp ln kb lo lp lq kf lr ls lt kj lu lv lw lx bi translated">3.拥抱随机性</h2><p id="1c23" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">不过，这两种解决方案都需要重构现有代码。可能会有我们无法改变它的情况——或者我们不想这样做。</p><p id="3502" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于这些场景，鲍伯·马丁叔叔提出了一个有趣的想法:他拥抱随机性，而是专注于测试结果的分布。</p><p id="d234" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这个简单的例子中，我们有11个可能的值:95到105。如果我们调用<em class="md"> getDamage() </em>方法11.000次，我们将期望得到每个值大约1.000次。</p><p id="3f0c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，我们可以简单地运行模拟11.000次，并期望11个值中的每一个都返回700到1.300次:</p><pre class="kp kq kr ks gt me mf mg bn mh mi bi"><span id="e239" class="mj lg it mf b be mk ml l mm mn">@Test<br/>void given11_000simulations_theRandomDistributionShouldBeBalanced() {<br/>    Weapon weapon = new Weapon();<br/>    Map&lt;Integer, Integer&gt; numberOfResultsByDamage = new HashMap&lt;&gt;();<br/><br/>    for (int i = 0; i &lt; 11_000; i++) {<br/>        int damage = weapon.getDamage();<br/>        var currentCount = numberOfResultsByDamage.getOrDefault(damage, 0);<br/>        numberOfResultsByDamage.put(damage, currentCount + 1);<br/>    }<br/><br/>    for(int value : numberOfResultsByDamage.values()) {<br/>        assertThat(value).isBetween(700, 1300);<br/>    }<br/>}</span></pre><p id="ab46" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这将是Java8+的等价形式:</p><pre class="kp kq kr ks gt me mf mg bn mh mi bi"><span id="c353" class="mj lg it mf b be mk ml l mm mn">@Test<br/>void given11_000simulations_theRandomDistributionShouldBeBalanced() {<br/>    Weapon weapon = new Weapon();<br/><br/>    Map&lt;Integer, Long&gt; countByDmg = IntStream.range(0, 11_000).boxed()<br/>        .map(x -&gt; weapon.getDamage())<br/>        .collect(Collectors.groupingBy(dmg -&gt; dmg, Collectors.counting()));<br/><br/>    countByDmg.values().stream()<br/>        .forEach(value -&gt; assertThat(value).isBetween(700L, 1300L));<br/>}</span></pre><p id="3359" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当然，测试失败的可能性很小，但这需要无数次的尝试。此外，是否有可能检查值的分布，计算标准偏差，然后提出一种更合适的断言方式，但您必须找出背后的数学原理。</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h2 id="1898" class="lf lg it bd lh li lj dn lk ll lm dp ln kb lo lp lq kf lr ls lt kj lu lv lw lx bi translated">结论</h2><p id="372b" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">在本文中，我们讨论了使用随机生成值的3种不同的代码测试方法。最初，我们使用了依赖倒置原则和一个mocking库。在那之后，我们开始使用lambda表达式，这使得我们可以不用模仿就能进行测试。</p><p id="5667" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，我们讨论了一种不同的方法，其中我们不再试图<em class="md">模仿</em>随机生成器。相反，我们着重于测试值的分布是否平衡。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mv"><img src="../Images/4a762db5e0472735cfe30bf69ef35087.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zy4GjPkWP77j2yPU"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">照片由<a class="ae le" href="https://unsplash.com/@nublson?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">努贝尔森·费尔南德斯</a>在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="582f" class="mw lg it bd lh mx my mz lk na nb nc ln nd ne nf lq ng nh ni lt nj nk nl lw nm bi translated">谢谢大家！</h1><p id="6efb" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">感谢你阅读这篇文章，请让我知道你的想法！欢迎任何反馈。</p><p id="fbd5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你想阅读更多关于干净的代码、设计、单元测试、函数式编程以及许多其他内容，请务必查看我的其他文章。你喜欢它的内容吗？考虑<a class="ae le" href="https://medium.com/@emanueltrandafir" rel="noopener">关注或订阅</a>电子邮件列表。</p><p id="63cd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，如果你考虑成为一个中等会员，支持我的博客，这里是我的<a class="ae le" href="https://medium.com/@emanueltrandafir/membership" rel="noopener">推荐人</a>。</p><p id="13aa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">编码快乐！</p></div><div class="ab cl mo mp hx mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="im in io ip iq"><h1 id="a635" class="mw lg it bd lh mx nn mz lk na no nc ln nd np nf lq ng nq ni lt nj nr nl lw nm bi translated">分级编码</h1><p id="47a3" class="pw-post-body-paragraph jq jr it js b jt ly jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj mc kl km kn im bi translated">感谢您成为我们社区的一员！在你离开之前:</p><ul class=""><li id="057e" class="ns nt it js b jt ju jx jy kb nu kf nv kj nw kn nx ny nz oa bi translated">👏为故事鼓掌，跟着作者走👉</li><li id="0fe5" class="ns nt it js b jt ob jx oc kb od kf oe kj of kn nx ny nz oa bi translated">📰查看<a class="ae le" href="https://levelup.gitconnected.com/?utm_source=pub&amp;utm_medium=post" rel="noopener ugc nofollow" target="_blank">升级编码出版物</a>中的更多内容</li><li id="a0f0" class="ns nt it js b jt ob jx oc kb od kf oe kj of kn nx ny nz oa bi translated">🔔关注我们:<a class="ae le" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">Twitter</a>|<a class="ae le" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>|<a class="ae le" href="https://newsletter.levelup.dev" rel="noopener ugc nofollow" target="_blank">时事通讯</a></li></ul><p id="3dff" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">🚀👉<a class="ae le" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="js iu">加入人才集体，找到一份令人惊喜的工作</strong> </a></p></div></div>    
</body>
</html>