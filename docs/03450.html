<html>
<head>
<title>Demystifying Closures, Futures, and async-await in Rust Part 2: Futures</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">揭开Rust中闭包、未来和异步等待的神秘面纱第2部分:未来</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/demystifying-closures-futures-and-async-await-in-rust-part-2-futures-abe95ab332a2?source=collection_archive---------2-----------------------#2020-05-10">https://levelup.gitconnected.com/demystifying-closures-futures-and-async-await-in-rust-part-2-futures-abe95ab332a2?source=collection_archive---------2-----------------------#2020-05-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="439a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这一系列文章中，我试图揭开神秘的面纱，带您从Rust闭包，到futures，最后到async-await。</p><p id="da3d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这继续了我们在<a class="ae kl" href="https://medium.com/@alistairisrael/demystifying-closures-futures-and-async-await-in-rust-part-1-closures-97e531e4dc50" rel="noopener"> <strong class="jp ir">第1部分:闭包</strong> </a>中离开的地方</p></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><h1 id="1226" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">东京漂移</h1><p id="418a" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">为什么在期货和<code class="fe lw lx ly lz b">async</code> / <code class="fe lw lx ly lz b">await</code>之前理解平仓如此重要？</p><p id="d454" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为在大多数情况下，无论是使用<code class="fe lw lx ly lz b">futures</code>机箱还是<code class="fe lw lx ly lz b">async</code>/<code class="fe lw lx ly lz b">await</code>,<code class="fe lw lx ly lz b">std::future::Future</code>特征的实现仅仅是包装闭包的另一个结构！</p><p id="2764" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，在我们继续之前，有必要注意一些事情。</p><p id="9392" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">其他支持异步编程的语言通常会在解释器或虚拟机中内置运行时。或者他们自动编译并链接运行时到最终的二进制文件中。</p><p id="2da2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为Rust的核心理念之一是“零成本抽象”，设计者决定<em class="ma">不</em>默认提供绿色线程或内置运行时。</p><p id="ab93" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">(关于Rust异步编程及其历史的精彩、深入的解释，请参见InfoQ的<a class="ae kl" href="https://www.infoq.com/presentations/rust-2019/" rel="noopener ugc nofollow" target="_blank"> Rust的异步/等待之旅</a>。)</p><p id="a1d2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">相反，要编写异步代码，我们需要另一个库或箱子来提供实际的运行时。<em class="ma">事实上的</em>运行时为Rust的是<strong class="jp ir">Tokio:</strong><a class="ae kl" href="https://tokio.rs/" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">https://Tokio . RS</strong></a></p><p id="c7c8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为我们将与期货打交道，我们还想使用<code class="fe lw lx ly lz b"><a class="ae kl" href="https://docs.rs/futures/0.3.5/futures/" rel="noopener ugc nofollow" target="_blank">futures</a></code> <a class="ae kl" href="https://docs.rs/futures/0.3.5/futures/" rel="noopener ugc nofollow" target="_blank">箱</a>中的一些方便的方法。不要求使用<code class="fe lw lx ly lz b">futures</code>板条箱，但是<em class="ma">通常很有帮助。</em></p><p id="7351" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">编辑<code class="fe lw lx ly lz b">Cargo.toml</code>并将<code class="fe lw lx ly lz b">futures</code>和<code class="fe lw lx ly lz b">tokio</code>添加到依赖关系部分:</p><pre class="mb mc md me gt mf lz mg mh aw mi bi"><span id="7d63" class="mj ku iq lz b gy mk ml l mm mn">[dependencies]<br/>futures = "0.3"<br/>tokio = { version = "0.2", features = ["full"] }</span></pre><p id="ca52" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">(<code class="fe lw lx ly lz b">"full"</code>功能标志告诉Tokio<a class="ae kl" href="https://docs.rs/tokio/0.2.20/tokio/#feature-flags" rel="noopener ugc nofollow" target="_blank">启用所有公共API</a>。)</p><p id="bc14" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们现在需要初始化Tokio运行时。我们可以简单地创建默认的Tokio运行时:</p><pre class="mb mc md me gt mf lz mg mh aw mi bi"><span id="2527" class="mj ku iq lz b gy mk ml l mm mn">let rt = tokio::runtime::Runtime::new().unwrap();</span></pre><h2 id="72a1" class="mj ku iq bd kv mo mp dn kz mq mr dp ld jy ms mt lh kc mu mv ll kg mw mx lp my bi translated">输入()</h2><p id="b20a" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">使用Tokio运行时的最快捷的方式是使用<code class="fe lw lx ly lz b"><a class="ae kl" href="https://docs.rs/tokio/0.2.20/tokio/runtime/struct.Runtime.html#method.enter" rel="noopener ugc nofollow" target="_blank">enter()</a></code>方法，该方法使用一个<code class="fe lw lx ly lz b">FnOnce</code>，一个闭包！</p><pre class="mb mc md me gt mf lz mg mh aw mi bi"><span id="6e29" class="mj ku iq lz b gy mk ml l mm mn">rt.enter(|| {<br/>    println!("in rt.enter()");<br/>});</span></pre><p id="dcfc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你运行这个，你应该在程序输出中看到<code class="fe lw lx ly lz b">in rt.enter()</code>。没什么太激动人心的，嗯？</p><p id="2c9d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们继续导入<code class="fe lw lx ly lz b">futures::future</code>:</p><pre class="mb mc md me gt mf lz mg mh aw mi bi"><span id="4ae9" class="mj ku iq lz b gy mk ml l mm mn">use futures::future;</span></pre><h2 id="b18c" class="mj ku iq bd kv mo mp dn kz mq mr dp ld jy ms mt lh kc mu mv ll kg mw mx lp my bi translated">产卵()</h2><p id="0219" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">在运行时闭包内，我们可以使用<code class="fe lw lx ly lz b">tokio::spawn()</code>来执行一个<code class="fe lw lx ly lz b">Future</code>(无需等待它完成或返回)。</p><p id="7bae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了创建一个合适的<code class="fe lw lx ly lz b">Future</code>,我们将使用<code class="fe lw lx ly lz b">futures::future::lazy</code>,它同样需要一个闭包，但这次只需要一个参数(一个上下文，我们现在忽略它):</p><pre class="mb mc md me gt mf lz mg mh aw mi bi"><span id="2a63" class="mj ku iq lz b gy mk ml l mm mn">rt.enter(|| {<br/>    println!("in rt.enter()");<br/>    tokio::spawn(future::lazy(|_| println!("in tokio::spawn")));<br/>});</span></pre><p id="efa1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们将<code class="fe lw lx ly lz b">tokio::spawn()</code>调用移到<code class="fe lw lx ly lz b">rt.enter()</code>闭包之外会发生什么？</p><pre class="mb mc md me gt mf lz mg mh aw mi bi"><span id="c457" class="mj ku iq lz b gy mk ml l mm mn">rt.enter(|| {<br/>    println!("in rt.enter()");<br/>});<br/>tokio::spawn(future::lazy(|_| println!("in tokio::spawn()")));</span></pre><p id="08e7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们得到一个运行时错误:</p><pre class="mb mc md me gt mf lz mg mh aw mi bi"><span id="f4f2" class="mj ku iq lz b gy mk ml l mm mn">thread 'main' panicked at 'must be called from the context of Tokio runtime configured with either `basic_scheduler` or `threaded_scheduler`',</span></pre><p id="62c4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">或者，我们可以在运行时本身调用<code class="fe lw lx ly lz b">.spawn()</code>:</p><pre class="mb mc md me gt mf lz mg mh aw mi bi"><span id="7442" class="mj ku iq lz b gy mk ml l mm mn">rt.spawn(future::lazy(|_| println!("in rt.spawn()")));</span></pre><h2 id="a8f6" class="mj ku iq bd kv mo mp dn kz mq mr dp ld jy ms mt lh kc mu mv ll kg mw mx lp my bi translated">block_on()</h2><p id="d653" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">最后我们可以调用<code class="fe lw lx ly lz b">rt.block_on()</code>。但在此之前，我们需要将变量<code class="fe lw lx ly lz b">rt</code>改为<code class="fe lw lx ly lz b">mut</code>(因为<code class="fe lw lx ly lz b"><em class="ma">block_on()</em></code> <em class="ma"> </em> <a class="ae kl" href="https://docs.rs/tokio/0.2.20/tokio/runtime/struct.Runtime.html#method.block_on" rel="noopener ugc nofollow" target="_blank"> <em class="ma">可能会提前运行时的状态</em> </a>):</p><pre class="mb mc md me gt mf lz mg mh aw mi bi"><span id="bf2a" class="mj ku iq lz b gy mk ml l mm mn">let mut rt = tokio::runtime::Runtime::new().unwrap();</span></pre><p id="d4ed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们可以写:</p><pre class="mb mc md me gt mf lz mg mh aw mi bi"><span id="a5fa" class="mj ku iq lz b gy mk ml l mm mn">rt.block_on(future::lazy(|_| println!("in rt.block_on()")));</span></pre><p id="b08e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最终得到的代码:</p><pre class="mb mc md me gt mf lz mg mh aw mi bi"><span id="6f8b" class="mj ku iq lz b gy mk ml l mm mn">let mut rt = tokio::runtime::Runtime::new().unwrap();<br/>rt.enter(|| {<br/>    println!("in rt.enter()");<br/>    tokio::spawn(future::lazy(|_| println!("in tokio::spawn()")));<br/>});<br/>rt.spawn(future::lazy(|_| println!("in rt.spawn()")));<br/>rt.block_on(future::lazy(|_| println!("in rt.block_on()")));</span></pre><p id="413a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你运行上面的代码，你可能会看到:</p><pre class="mb mc md me gt mf lz mg mh aw mi bi"><span id="84b1" class="mj ku iq lz b gy mk ml l mm mn">in rt.enter()<br/>in tokio::spawn()<br/>in rt.spawn()<br/>in rt.block_on()</span></pre><p id="0beb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我说你<em class="ma">可能会</em>看到上面的输出，因为有时候你可能会看到不同顺序的输出。或者，您可能只会看到<code class="fe lw lx ly lz b">in rt.enter()</code>后面跟着<code class="fe lw lx ly lz b">in rt.block_on()</code></p><p id="8cde" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了了解发生了什么，我们需要看看引擎盖下。</p></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><h1 id="3d6d" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">在后台</h1><p id="0188" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">让我们看看引擎盖下面。首先，我们将使用一些日志库，因此将以下内容添加到<code class="fe lw lx ly lz b">Cargo.toml</code>中的依赖项中:</p><pre class="mb mc md me gt mf lz mg mh aw mi bi"><span id="9a7f" class="mj ku iq lz b gy mk ml l mm mn">log = "0.4"<br/>simplelog = "0.7"</span></pre><p id="2d3c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，将以下导入添加到<code class="fe lw lx ly lz b">main.rs</code>的顶部:</p><pre class="mb mc md me gt mf lz mg mh aw mi bi"><span id="91c0" class="mj ku iq lz b gy mk ml l mm mn">use log::debug;<br/>use simplelog::{ConfigBuilder, LevelFilter, SimpleLogger};</span></pre><p id="0fdc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后在<code class="fe lw lx ly lz b">main()</code>开始初始化记录系统时:</p><pre class="mb mc md me gt mf lz mg mh aw mi bi"><span id="768a" class="mj ku iq lz b gy mk ml l mm mn">let config = ConfigBuilder::new()<br/>        .set_target_level(LevelFilter::Trace)<br/>        .build();<br/>let _ = SimpleLogger::init(LevelFilter::Debug, config);</span></pre><p id="8f37" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，用<code class="fe lw lx ly lz b">debug!()</code>替换所有的<code class="fe lw lx ly lz b">println!()</code>宏调用。例如，我们之前的代码现在应该是这样的:</p><pre class="mb mc md me gt mf lz mg mh aw mi bi"><span id="38f7" class="mj ku iq lz b gy mk ml l mm mn">rt.enter(|| {<br/>    debug!("in rt.enter()");<br/>    tokio::spawn(future::lazy(|_| debug!("in tokio::spawn()")));<br/>});<br/>rt.spawn(future::lazy(|_| debug!("in rt.spawn()")));<br/>rt.block_on(future::lazy(|_| debug!("in rt.block_on()")));</span></pre><p id="b4df" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在运行该程序时，输出应该类似于以下内容:</p><pre class="mb mc md me gt mf lz mg mh aw mi bi"><span id="7f81" class="mj ku iq lz b gy mk ml l mm mn">10:36:28 [DEBUG] (1) in rt.enter()<br/>10:36:28 [DEBUG] (1) in rt.block_on()<br/>10:36:28 [DEBUG] (13) in tokio::spawn()<br/>10:36:28 [DEBUG] (12) in rt.spawn()</span></pre><p id="f342" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">圆括号中的数字<code class="fe lw lx ly lz b">(1)</code>、<code class="fe lw lx ly lz b">(13)</code>、<code class="fe lw lx ly lz b">(12)</code>是记录系统识别的线程“id”。有时你会看到<code class="fe lw lx ly lz b">in tokio::spawn()</code>和<code class="fe lw lx ly lz b">in rt.spawn()</code>的其他线程id，但是你应该总是看到<code class="fe lw lx ly lz b">in rt.enter()</code>和<code class="fe lw lx ly lz b">in rt.block_on()</code>的<code class="fe lw lx ly lz b">(1)</code></p><p id="e47c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们甚至可以看到Tokio运行时是如何启动线程的。将<code class="fe lw lx ly lz b">let rt =</code>线更换为</p><pre class="mb mc md me gt mf lz mg mh aw mi bi"><span id="8df3" class="mj ku iq lz b gy mk ml l mm mn">let mut rt = tokio::runtime::Builder::new()<br/>        .threaded_scheduler()<br/>        .core_threads(4)<br/>        .on_thread_start(|| debug!("on_thread_start()"))<br/>        .build()<br/>        .unwrap();</span></pre><p id="a8cb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，当您<code class="fe lw lx ly lz b">cargo run</code>时，您应该看到5个线程正在启动，每个线程都有自己的线程id:</p><pre class="mb mc md me gt mf lz mg mh aw mi bi"><span id="babe" class="mj ku iq lz b gy mk ml l mm mn">10:43:57 [DEBUG] (3) on_thread_start()<br/>10:43:57 [DEBUG] (5) on_thread_start()<br/>10:43:57 [DEBUG] (4) on_thread_start()<br/>10:43:57 [DEBUG] (1) in rt.enter()<br/>10:43:57 [DEBUG] (2) on_thread_start()<br/>10:43:57 [DEBUG] (1) in rt.block_on()<br/>10:43:57 [DEBUG] (4) in tokio::spawn()<br/>10:43:57 [DEBUG] (5) in rt.spawn()</span></pre><h2 id="4a00" class="mj ku iq bd kv mo mp dn kz mq mr dp ld jy ms mt lh kc mu mv ll kg mw mx lp my bi translated">发生什么事了？</h2><p id="3f9f" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">当<code class="fe lw lx ly lz b">"rt-threaded"</code>特性启用时(通过<code class="fe lw lx ly lz b">features = ["full"]</code>启用)，默认的Tokio运行时使用线程调度器。</p><p id="c9fb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lw lx ly lz b">tokio::spawn()</code>和<code class="fe lw lx ly lz b">rt.spawn()</code>都可以在不同的线程上调度给定的<code class="fe lw lx ly lz b">Future</code>。</p><p id="8e54" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另一方面，<code class="fe lw lx ly lz b">rt.enter()</code>和<code class="fe lw lx ly lz b">rt.block_on()</code>都在<code class="fe lw lx ly lz b">main()</code>线程上运行(线程id <code class="fe lw lx ly lz b">(1)</code>)。</p><p id="0491" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，因为不同的线程异步并发执行，所以产生的任务可能以任何顺序运行，或者根本不运行。</p><p id="ffc4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，由于<code class="fe lw lx ly lz b">rt.enter()</code>和<code class="fe lw lx ly lz b">rt.block_on()</code>在同一个线程上执行，因此它们按顺序执行<em class="ma">。</em></p><p id="fc2a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，它们都执行给定的块或未来完成。也就是说，它们<em class="ma">等待</em>给定块的完成。</p></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><h1 id="74c4" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">回到未来</h1><p id="2baa" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">现在，精明的读者可能已经注意到了,<code class="fe lw lx ly lz b">futures::future::lazy</code>是一个简洁的小函数，它简单地返回一个包装了给定闭包的<code class="fe lw lx ly lz b">Future</code>!具体来说，它返回一个实现了<code class="fe lw lx ly lz b">Future</code>特征的<code class="fe lw lx ly lz b">Lazy</code>结构。</p><p id="9607" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们也可以使用<code class="fe lw lx ly lz b">futures::future::ready()</code>来创建一个<code class="fe lw lx ly lz b">Future</code>来立即返回给定值。</p><p id="b17b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们继续之前，让我们看看如果我们只是调用一个直接返回一个<code class="fe lw lx ly lz b">Future</code>的函数会发生什么。例如，如果我们在<code class="fe lw lx ly lz b">main()</code>的末尾添加以下几行:</p><pre class="mb mc md me gt mf lz mg mh aw mi bi"><span id="7397" class="mj ku iq lz b gy mk ml l mm mn">future::ready(42)</span></pre><p id="5441" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们得到一个编译器错误:</p><pre class="mb mc md me gt mf lz mg mh aw mi bi"><span id="e4b1" class="mj ku iq lz b gy mk ml l mm mn">error[E0308]: mismatched types<br/>   --&gt; src/main.rs:157:5<br/>    |<br/>157 |     future::ready(42)<br/>    |     ^^^^^^^^^^^^^^^^^ expected `()`, found struct `futures_util::future::ready::Ready`<br/>    |<br/>    = note: expected unit type `()`<br/>                  found struct `futures_util::future::ready::Ready&lt;{integer}&gt;`<br/>help: try adding a semicolon<br/>    |<br/>157 |     future::ready(42);<br/>    |                      ^</span></pre><p id="2a98" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们加上一个分号，就像它说的:</p><pre class="mb mc md me gt mf lz mg mh aw mi bi"><span id="6f53" class="mj ku iq lz b gy mk ml l mm mn">future::ready(42);</span></pre><p id="e7c1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">相反，我们得到一个编译器警告:</p><pre class="mb mc md me gt mf lz mg mh aw mi bi"><span id="28a9" class="mj ku iq lz b gy mk ml l mm mn">warning: unused `futures_util::future::ready::Ready` that must be used<br/>   --&gt; src/main.rs:157:5<br/>    |<br/>157 |     future::ready(42);<br/>    |     ^^^^^^^^^^^^^^^^^^<br/>    |<br/>    = note: `#[warn(unused_must_use)]` on by default<br/>    = note: futures do nothing unless you `.await` or poll them</span></pre><p id="c17d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们暂时就说到这里，你将不得不等到<a class="ae kl" href="https://medium.com/@alistairisrael/demystifying-closures-futures-and-async-await-in-rust-part-3-async-await-9ed20eede7a4" rel="noopener"> <strong class="jp ir">第三部分</strong> </a>我们将再次遇到这个问题。</p><p id="e7fd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们已经知道我们需要<code class="fe lw lx ly lz b">.spawn()</code>或者<code class="fe lw lx ly lz b">.block_on()</code>一个<code class="fe lw lx ly lz b">Future</code>，所以下面应该可以工作:</p><pre class="mb mc md me gt mf lz mg mh aw mi bi"><span id="9f9d" class="mj ku iq lz b gy mk ml l mm mn">    {<br/>        let result = rt.block_on(future::ready("Hello from rt.block_on()"));<br/>        debug!("{}", result);<br/>    }</span></pre><p id="3a46" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么我们应该会看到这样的内容:</p><pre class="mb mc md me gt mf lz mg mh aw mi bi"><span id="5563" class="mj ku iq lz b gy mk ml l mm mn">11:05:24 [DEBUG] (1) Hello from rt.block_on()</span></pre><h2 id="ed05" class="mj ku iq bd kv mo mp dn kz mq mr dp ld jy ms mt lh kc mu mv ll kg mw mx lp my bi translated">回归未来</h2><p id="2e0b" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">我们可以编写自己的函数来返回期货。</p><p id="c414" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们需要:</p><pre class="mb mc md me gt mf lz mg mh aw mi bi"><span id="c94b" class="mj ku iq lz b gy mk ml l mm mn">use std::future::Future;</span></pre><p id="b580" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要声明一个<code class="fe lw lx ly lz b">Future</code>返回类型，我们需要指定其关联的<code class="fe lw lx ly lz b">Output</code>类型。让我们尝试编写一个返回简单标量值的函数:</p><pre class="mb mc md me gt mf lz mg mh aw mi bi"><span id="c1e1" class="mj ku iq lz b gy mk ml l mm mn">fn returns_future_i32() -&gt; Future&lt;Output = i32&gt; {<br/>    future::ready(42)<br/>}</span></pre><p id="1b2e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们马上会遇到<code class="fe lw lx ly lz b">trait objects without an explicit `dyn` are deprecated</code>和<code class="fe lw lx ly lz b">error[E0746]: return type cannot have an unboxed trait object</code>。</p><h2 id="5b6e" class="mj ku iq bd kv mo mp dn kz mq mr dp ld jy ms mt lh kc mu mv ll kg mw mx lp my bi translated">impl未来</h2><p id="a3f4" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">要解决这个问题，我们可以根据需要做两件事。更深入的解释见<a class="ae kl" href="https://joshleeb.com/posts/rust-traits-and-trait-objects/#impl-trait" rel="noopener ugc nofollow" target="_blank">这篇文章</a>。</p><p id="aa75" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">简单的解决方案是，如果我们<em class="ma">绝对确定</em>我们的函数将只<em class="ma">曾经</em>返回与<code class="fe lw lx ly lz b">Future</code>实现的<em class="ma">完全相同的</em>类型(或者，在本例中，只有一种类型),我们可以简单地使用<code class="fe lw lx ly lz b">impl Future</code></p><pre class="mb mc md me gt mf lz mg mh aw mi bi"><span id="d617" class="mj ku iq lz b gy mk ml l mm mn">fn returns_future_i32() -&gt; impl Future&lt;Output = i32&gt;</span></pre><p id="a2d7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另一方面，如果我们调用其他函数，并且所有这些不同的函数可能返回<em class="ma">不同的</em> <code class="fe lw lx ly lz b">Future</code>实现，那么<code class="fe lw lx ly lz b">impl Future</code>将不起作用。</p><p id="7851" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了演示这一点，首先让我们在<code class="fe lw lx ly lz b">Cargo.toml</code>中添加一个随机数生成器库到我们的<code class="fe lw lx ly lz b">[dependencies]</code></p><pre class="mb mc md me gt mf lz mg mh aw mi bi"><span id="140f" class="mj ku iq lz b gy mk ml l mm mn">rand = "0.7.3"</span></pre><p id="02c8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，如果我们尝试将函数改为:</p><pre class="mb mc md me gt mf lz mg mh aw mi bi"><span id="36d7" class="mj ku iq lz b gy mk ml l mm mn">fn returns_impl_future_i32() -&gt; impl Future&lt;Output = i32&gt; {<br/>    if rand::random() {<br/>        return future::ready(42);<br/>    }<br/>    future::lazy(|_| 1337)<br/>}</span></pre><p id="c720" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个函数中，有50%的几率它会“短路”并返回一个<code class="fe lw lx ly lz b">future::Ready</code>。否则，它试图返回一个<code class="fe lw lx ly lz b">future::Lazy</code>。</p><p id="ba7f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Rust编译器给出了下面的错误(甚至告诉我们哪里做错了以及如何修复它):</p><pre class="mb mc md me gt mf lz mg mh aw mi bi"><span id="e88c" class="mj ku iq lz b gy mk ml l mm mn">error[E0308]: mismatched types<br/>  --&gt; src/main.rs:44:12<br/>   |<br/>39 | fn returns_impl_future_i32() -&gt; impl Future&lt;Output = i32&gt; {<br/>   |                                 ------------------------- expected because this return type...<br/>40 |     if rand::random() {<br/>41 |         return future::ready(42);<br/>   |                ----------------- ...is found to be `futures_util::future::ready::Ready&lt;i32&gt;` here<br/>...<br/>44 |     return future::lazy(|_| 1337);<br/>   |            ^^^^^^^^^^^^^^^^^^^^^^ expected struct `futures_util::future::ready::Ready`, found struct `futures_util::future::lazy::Lazy`<br/>   |<br/>   = note: expected type `futures_util::future::ready::Ready&lt;i32&gt;`<br/>            found struct `futures_util::future::lazy::Lazy&lt;[closure@src/main.rs:44:25: 44:33]&gt;`<br/>   = note: to return `impl Trait`, all returned values must be of the same type</span></pre><h2 id="a208" class="mj ku iq bd kv mo mp dn kz mq mr dp ld jy ms mt lh kc mu mv ll kg mw mx lp my bi translated">dyn未来</h2><p id="8a0c" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">在这种情况下，我们需要返回一个动态<code class="fe lw lx ly lz b">Future</code>。现在，如果我们简单地将函数改为:</p><pre class="mb mc md me gt mf lz mg mh aw mi bi"><span id="acbf" class="mj ku iq lz b gy mk ml l mm mn">fn returns_dyn_future_i32() -&gt; dyn Future&lt;Output = i32&gt;</span></pre><p id="7ac1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们又回到了<code class="fe lw lx ly lz b">error[E0746]: return type cannot have an unboxed trait object</code>。</p><h2 id="8aa4" class="mj ku iq bd kv mo mp dn kz mq mr dp ld jy ms mt lh kc mu mv ll kg mw mx lp my bi translated">方框<dyn future=""/></h2><p id="b1d0" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">直观的解决方案是。这意味着我们还必须<code class="fe lw lx ly lz b">Box::new()</code>我们的返回值:</p><pre class="mb mc md me gt mf lz mg mh aw mi bi"><span id="5f88" class="mj ku iq lz b gy mk ml l mm mn">fn returns_dyn_future_i32() -&gt; Box&lt;dyn Future&lt;Output = i32&gt;&gt; {<br/>    if rand::random() {<br/>        Box::new(future::ready(42))<br/>    } else {<br/>        Box::new(future::lazy(|_| 1337))<br/>    }<br/>}</span></pre><p id="83da" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们遇到了一个全新的错误，当我们:</p><pre class="mb mc md me gt mf lz mg mh aw mi bi"><span id="278d" class="mj ku iq lz b gy mk ml l mm mn">error[E0277]: `dyn core::future::future::Future&lt;Output = i32&gt;` cannot be unpinned<br/>  --&gt; src/main.rs:96:34<br/>   |<br/>96 |         let result = rt.block_on(returns_dyn_future_i32());<br/>   |                                  ^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::marker::Unpin` is not implemented for `dyn core::future::future::Future&lt;Output = i32&gt;`<br/>   |<br/>   = note: required because of the requirements on the impl of `core::future::future::Future` for `std::boxed::Box&lt;dyn core::future::future::Future&lt;Output = i32&gt;&gt;`</span></pre><h2 id="744c" class="mj ku iq bd kv mo mp dn kz mq mr dp ld jy ms mt lh kc mu mv ll kg mw mx lp my bi translated">插脚<box future="">&gt;</box></h2><p id="2c82" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">现在的解决办法是<strong class="jp ir">牵制</strong>。至于原因，我就不赘述了；关于这一点，请参考<a class="ae kl" href="https://rust-lang.github.io/async-book/04_pinning/01_chapter.html" rel="noopener ugc nofollow" target="_blank">这一章关于牵制和为什么，具体来说，期货需要他们</a>。</p><p id="df02" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">简而言之，我们需要返回一个<code class="fe lw lx ly lz b">Pin&lt;Box&lt;dyn Future&gt;&gt;</code>，而不仅仅是<code class="fe lw lx ly lz b">Box&lt;dyn Future&gt;</code>。首先确保:</p><pre class="mb mc md me gt mf lz mg mh aw mi bi"><span id="4cdf" class="mj ku iq lz b gy mk ml l mm mn">use std::pin::Pin</span></pre><p id="66fe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">幸运的是(但非直觉地)，我们不必<code class="fe lw lx ly lz b">Pin::new(Box::new(...))</code>。确切地说，我们只是<code class="fe lw lx ly lz b">Box::pin(...)</code>。我们的函数现在工作得非常好:</p><pre class="mb mc md me gt mf lz mg mh aw mi bi"><span id="bfa8" class="mj ku iq lz b gy mk ml l mm mn">fn returns_dyn_future_i32() -&gt; Pin&lt;Box&lt;dyn Future&lt;Output = i32&gt;&gt;&gt; {<br/>    if rand::random() {<br/>        Box::pin(future::ready(42))<br/>    } else {<br/>        Box::pin(future::lazy(|_| 1337))<br/>    }<br/>}</span></pre><p id="3cfd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">或者，正如另一位读者所指出的，你可以使用 <code class="fe lw lx ly lz b"><a class="ae kl" href="https://docs.rs/futures/0.3.5/futures/future/trait.FutureExt.html#method.boxed" rel="noopener ugc nofollow" target="_blank">futures::future::FutureExt</a></code>中的<code class="fe lw lx ly lz b"><a class="ae kl" href="https://docs.rs/futures/0.3.5/futures/future/trait.FutureExt.html#method.boxed" rel="noopener ugc nofollow" target="_blank">.boxed()</a></code> <a class="ae kl" href="https://docs.rs/futures/0.3.5/futures/future/trait.FutureExt.html#method.boxed" rel="noopener ugc nofollow" target="_blank">方法，就像这样:<code class="fe lw lx ly lz b">future::ready(42).boxed()</code>。</a></p></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><h1 id="2bfa" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">期货中的错误处理</h1><p id="2885" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">如果所有的东西都是独角兽和彩虹，我们写的所有代码将总是能够正常工作，我们根本不需要处理错误。</p><p id="6b4d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">可悲的是，除了人为的或琐碎的例子，我们需要处理错误，对于异步编程，我们也需要一种异步处理它们的方法。</p><p id="6601" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于<code class="fe lw lx ly lz b">Future</code>特征的关联<code class="fe lw lx ly lz b">Output</code>类型可以是任何类型，我们可以将其设置为<code class="fe lw lx ly lz b">Result</code>。</p><p id="a744" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">同样，首先我们需要几个新的导入:</p><pre class="mb mc md me gt mf lz mg mh aw mi bi"><span id="d1a2" class="mj ku iq lz b gy mk ml l mm mn">use std::error::Error;</span></pre><p id="57a1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，让我们尝试返回一个输出类型为<code class="fe lw lx ly lz b">Result</code>的<code class="fe lw lx ly lz b">Future</code>。这一次，我们不仅仅使用<code class="fe lw lx ly lz b">future::ready()</code>，而是使用<code class="fe lw lx ly lz b">future::ok()</code>。但是如果我们尝试</p><pre class="mb mc md me gt mf lz mg mh aw mi bi"><span id="8bb6" class="mj ku iq lz b gy mk ml l mm mn">fn returns_future_result() -&gt; impl Future&lt;Output = Result&lt;i32, Error&gt;&gt; {<br/>    future::ok(42)<br/>}</span></pre><p id="6a59" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们立即得到熟悉的<code class="fe lw lx ly lz b">warning: trait objects without an explicit `dyn` are deprecated</code>和<code class="fe lw lx ly lz b">error[E0277]: the size for values of type `dyn std::error::Error` cannot be known at compilation time</code></p><p id="5e8a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">既然我们知道错误不会发生，让我们试着去做。迎接我们的是一个全新的编译器错误:</p><pre class="mb mc md me gt mf lz mg mh aw mi bi"><span id="d24f" class="mj ku iq lz b gy mk ml l mm mn">error[E0720]: opaque type expands to a recursive type<br/>  --&gt; src/main.rs:47:64<br/>   |<br/>47 | fn returns_future_result() -&gt; impl Future&lt;Output = Result&lt;i32, impl Error&gt;&gt; {<br/>   |                                                                ^^^^^^^^^^ expands to a recursive type<br/>   |<br/>   = note: type resolves to itself</span></pre><p id="71e0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">注:</strong> <em class="ma">在写这篇文章的时候，我还在试图调查和理解为什么一个</em> <code class="fe lw lx ly lz b">impl Error</code> <em class="ma">不起作用，需要</em> <code class="fe lw lx ly lz b">Infallible</code> <em class="ma">。跟Rust不能从函数体决定具体实现类型应该是什么有关。一个MRE见这个</em> <a class="ae kl" href="https://play.rust-lang.org/?gist=298dd143aa93f824ae85bb2a97ea353b" rel="noopener ugc nofollow" target="_blank"> <em class="ma">游乐场例子</em> </a> <em class="ma">。</em></p><p id="ee14" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">相当“不透明”的解决方案(双关语)是使用<code class="fe lw lx ly lz b">std::convert::Infallible</code>，并将其作为通用类型参数提供给<code class="fe lw lx ly lz b">future::ok</code></p><pre class="mb mc md me gt mf lz mg mh aw mi bi"><span id="d0f8" class="mj ku iq lz b gy mk ml l mm mn">use std::convert::Infallible;</span><span id="692b" class="mj ku iq lz b gy mz ml l mm mn">fn returns_future_result() -&gt; impl Future&lt;Output = Result&lt;i32, impl Error&gt;&gt; {<br/>    future::ok::&lt;i32, Infallible&gt;(42)<br/>}</span></pre><p id="5722" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">或者，我们可以让Rust简单地推断出<code class="fe lw lx ly lz b">Result</code>的成功类型:</p><pre class="mb mc md me gt mf lz mg mh aw mi bi"><span id="0045" class="mj ku iq lz b gy mk ml l mm mn">future::ok::&lt;_, Infallible&gt;(42)</span></pre><p id="6484" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您正在调用另一个函数，并且不想拼出成功类型，这很有用。</p><p id="9103" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">或者，我们可以再次使用<code class="fe lw lx ly lz b">Box&lt;dyn ...&gt;</code>:</p><pre class="mb mc md me gt mf lz mg mh aw mi bi"><span id="5f84" class="mj ku iq lz b gy mk ml l mm mn">fn returns_future_result() -&gt; impl Future&lt;Output = Result&lt;i32, Box&lt;dyn Error&gt;&gt;&gt; {<br/>    future::ok(42)<br/>}</span></pre></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><h1 id="9247" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">未来链接</h1><p id="1292" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">到目前为止，我们一直在重复调用<code class="fe lw lx ly lz b">rt.block_on()</code>,每次都检查结果。</p><p id="a3d6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，如果出于某种原因，我们希望有一个单独的<code class="fe lw lx ly lz b">rt.block_on()</code>，它可能调用一个返回一个未来的函数，但是却连续运行几个其他的未来，该怎么办？</p><p id="b127" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">也就是说，我们只想:</p><pre class="mb mc md me gt mf lz mg mh aw mi bi"><span id="92c7" class="mj ku iq lz b gy mk ml l mm mn">rt.block_on(returns_future_chain());</span></pre><p id="5c88" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">其中<code class="fe lw lx ly lz b">returns_future_chain()</code>返回一个<code class="fe lw lx ly lz b">Future</code>，它将连续运行我们以前的所有期货。由于我们不关心输出，我们可以只使用<code class="fe lw lx ly lz b">()</code>单元类型。</p><pre class="mb mc md me gt mf lz mg mh aw mi bi"><span id="b63c" class="mj ku iq lz b gy mk ml l mm mn">fn returns_future_chain() -&gt; impl Future&lt;Output = ()&gt;</span></pre><p id="b6cf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是现在我们没有对Tokio运行时的引用，所以不能调用<code class="fe lw lx ly lz b">rt.block_on()</code>(或者<code class="fe lw lx ly lz b">rt.spawn()</code>)。</p><p id="304d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是<code class="fe lw lx ly lz b">futures</code>箱派上用场的地方，它为我们提供了“未来组合子”,让我们可以相对轻松地构建未来。</p><p id="104f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">简而言之，下面是使用不同组合符的<code class="fe lw lx ly lz b">returns_future_chain()</code>的样子:</p><pre class="mb mc md me gt mf lz mg mh aw mi bi"><span id="dc06" class="mj ku iq lz b gy mk ml l mm mn">fn returns_future_chain() -&gt; impl Future&lt;Output = ()&gt; {<br/>    future::lazy(|_| debug!("in returns_future_chain()"))<br/>        .then(|_| {<br/>            debug!("in first then");<br/>            future::ready("Hello from rt.block_on()")<br/>        })<br/>        .inspect(|result| debug!("future::ready() -&gt; {}", result))<br/>        .then(|_| returns_impl_future_i32())<br/>        .inspect(|result| debug!("returns_impl_future_i32() -&gt; {}", result))<br/>        .then(|_| returns_dyn_future_i32())<br/>        .inspect(|result| debug!("returns_dyn_future_i32() -&gt; {}", result))<br/>        .then(|_| returns_future_result())<br/>        .map(|result| result.unwrap())<br/>        .inspect(|result| debug!("returns_future_result().unwrap() -&gt; {}", result))<br/>        .then(|_| {<br/>            debug!("in last then");<br/>            future::ready(())<br/>        })<br/>}</span></pre></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><h1 id="182a" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">延期期货</h1><p id="a20e" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">为了更好地衡量，让我们写一个函数，在返回之前等待一段时间。为此，我们将使用<code class="fe lw lx ly lz b">tokio::time::delay_for()</code>:</p><pre class="mb mc md me gt mf lz mg mh aw mi bi"><span id="2b62" class="mj ku iq lz b gy mk ml l mm mn">use std::time::Duration;<br/>use tokio::time::delay_for;</span><span id="20ef" class="mj ku iq lz b gy mz ml l mm mn">fn returns_delayed_future() -&gt; impl Future&lt;Output = i32&gt; {<br/>    delay_for(Duration::from_millis(500))<br/>    .then(|_| futures::future::ready(42))<br/>}</span></pre><p id="b2b8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是，如果我们试图通过将它传递给<code class="fe lw lx ly lz b">rt.block_on()</code>来直接使用它:</p><pre class="mb mc md me gt mf lz mg mh aw mi bi"><span id="ed86" class="mj ku iq lz b gy mk ml l mm mn">let result = rt.block_on(returns_delayed_future());<br/>debug!("{}", result);</span></pre><p id="cc48" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们遇到了一个常见的运行时错误:</p><pre class="mb mc md me gt mf lz mg mh aw mi bi"><span id="f46b" class="mj ku iq lz b gy mk ml l mm mn">thread 'main' panicked at 'there is no timer running, must be called from the context of Tokio runtime',</span></pre><p id="73a3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">原因是<code class="fe lw lx ly lz b">tokio::time::delay_for()</code>已经期望在Tokio运行时下运行。</p><p id="fdb2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是如果我们简单地在传递给<code class="fe lw lx ly lz b">rt.enter()</code>的块中调用它，我们会得到一个警告:</p><pre class="mb mc md me gt mf lz mg mh aw mi bi"><span id="feed" class="mj ku iq lz b gy mk ml l mm mn">warning: unused implementer of `core::future::future::Future` that must be used<br/>   --&gt; src/main.rs:118:9<br/>    |<br/>118 |         returns_delayed_future();<br/>    |         ^^^^^^^^^^^^^^^^^^^^^^^^^<br/>    |<br/>    = note: `#[warn(unused_must_use)]` on by default<br/>    = note: futures do nothing unless you `.await` or poll them</span></pre><p id="c8d4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，让我们将它添加到我们之前构建的期货链中:</p><pre class="mb mc md me gt mf lz mg mh aw mi bi"><span id="44a1" class="mj ku iq lz b gy mk ml l mm mn">        .then(|_| returns_delayed_future())<br/>        .inspect(|result| debug!("returns_delayed_future() -&gt; {}", result))</span></pre><h2 id="96b7" class="mj ku iq bd kv mo mp dn kz mq mr dp ld jy ms mt lh kc mu mv ll kg mw mx lp my bi translated">通过“奉承”来拖延未来</h2><p id="5190" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">回忆一下我们在第1部分中的<a class="ae kl" href="https://medium.com/@alistairisrael/demystifying-closures-futures-and-async-await-in-rust-part-1-closures-97e531e4dc50#406c" rel="noopener">奉承练习:闭包</a>。</p><p id="3080" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，有了我们所知道的一切，让我们试着实现一个在评估给定的未来之前等待一秒钟的函数:</p><pre class="mb mc md me gt mf lz mg mh aw mi bi"><span id="c244" class="mj ku iq lz b gy mk ml l mm mn">fn wait_a_sec&lt;F, O&gt;(f: F) -&gt; impl Future&lt;Output = O&gt;<br/>where<br/>    F: Future&lt;Output = O&gt;,<br/>{<br/>    let delay = Duration::from_millis(1000);<br/>    delay_for(delay).then(|_| f)<br/>}</span></pre><p id="25d4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们试一试:</p><pre class="mb mc md me gt mf lz mg mh aw mi bi"><span id="7955" class="mj ku iq lz b gy mk ml l mm mn">        .then(|_| wait_a_sec(future::ready(42)))<br/>        .inspect(|result| debug!("wait_a_sec(future::ready(42)) -&gt; {}", result))</span></pre><p id="5f99" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为我们阻塞了这个期货链的结果，所以我们结束了等待，在打印出<code class="fe lw lx ly lz b">wait_a_sec()</code>的结果之前应该有一秒钟的明显停顿。</p><p id="3fb3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们使用了<code class="fe lw lx ly lz b">.spawn()</code>,那么不能保证未来会运行完成(因为程序的其余部分可能已经退出了)。</p></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><p id="0f32" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我希望这一章(相当长)对铁锈期货有所帮助。</p><p id="7ee8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以在GitHub上查看附带的源代码:<a class="ae kl" href="https://github.com/aisrael/rust-closures-futures-async-await" rel="noopener ugc nofollow" target="_blank">https://GitHub . com/aisrael/rust-closures-futures-async-await</a></p><p id="1775" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<a class="ae kl" href="https://medium.com/@alistairisrael/demystifying-closures-futures-and-async-await-in-rust-part-3-async-await-9ed20eede7a4" rel="noopener"> <strong class="jp ir">第3部分:Async + Await </strong> </a>中，我们将结合到目前为止我们所学的关于闭包和未来的知识来更好地理解async-await。</p></div></div>    
</body>
</html>