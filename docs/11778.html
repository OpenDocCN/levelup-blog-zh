<html>
<head>
<title>What Sets an Exceptional Programmer Apart From an Ordinary Programmer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">是什么让一个杰出的程序员不同于普通的程序员</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/what-sets-an-exceptional-programmer-apart-from-an-ordinary-programmer-73d3fce24e21?source=collection_archive---------4-----------------------#2022-04-15">https://levelup.gitconnected.com/what-sets-an-exceptional-programmer-apart-from-an-ordinary-programmer-73d3fce24e21?source=collection_archive---------4-----------------------#2022-04-15</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><figure class="gm go js jt ju jv gi gj paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="gi gj jr"><img src="../Images/0f38dc2b6603f2e18569e8af596c81ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-nT1XaCshGBWNyBV"/></div></div><figcaption class="kc kd gk gi gj ke kf bd b be z dk translated">沃齐米日·贾沃斯基在<a class="ae kg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="2a19" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">编程是一门你可以随着时间掌握的学科。</p><p id="637b" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">一般来说，你花在代码上的时间(不一定是在显示器前)越多，你就会成为越好的程序员。</p><p id="e634" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">这就是我个人不喜欢<em class="lf">例外</em>和<em class="lf">普通</em>这样的标签的原因。</p><p id="1ac8" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">也就是说，这个问题总是困扰着面试官，因为他们被迫进行比较。面试候选人还会经历巨大的压力，如何比别人更好地展示自己，而不是仅仅表现得好——这才是工作真正需要的。</p><p id="fba9" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">杰出程序员与普通程序员的区别在于面试/互动过程中展现的一系列想法。这些想法在最伟大的编程书籍中有详细的描述。</p><p id="0b68" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">除了这些想法，杰出的程序员还表现出某些行为症状，这些症状是通过行业经验或良好的协作实践获得的。这些行为症状可以从他们的习惯中看出来，面试官希望在面试中看到它们。</p><p id="59e5" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">在这里，我们的目标是通过卓越的本质。我们开始吧。</p><h1 id="56ea" class="lg lh iu bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">#1:范围细化:</h1><p id="604e" class="pw-post-body-paragraph kh ki iu kj b kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la mi lc ld le in bi translated">一位智者曾经说过:问正确的问题是50%的解决方案。</p><p id="02c3" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">当遇到代码问题时，优秀的程序员会开始解决问题。杰出的程序员首先尝试定义它。</p><p id="6ac8" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">这是因为优秀的程序员觉得他们知道的已经够多了。他们禁不住诱惑，表现出"<em class="lf">我知道你想解决的那种问题。这就是为什么你应该雇用我。</em>“我在我的故事<a class="ae kg" href="https://betterprogramming.pub/the-most-underrated-technique-to-nail-senior-developer-interviews-f917025453b7" rel="noopener ugc nofollow" target="_blank">中描述了这种特质，这是最不被看好的高级开发人员面试技巧</a></p><p id="0dd5" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">另一方面，优秀的程序员开始展示这是如何做到的。</p><p id="10c8" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">他们开始保持安静，倾听。他们试图思考所面临挑战的整体背景。他们已经知道如何编码解决方案。但即使他们不知道，他们也知道如何隔离复杂的部分，并使其与整体解决方案相比显得微不足道。</p><p id="7b2e" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">它们隐含地表明编码是解决方案的唯一(通常是最后)部分。</p><blockquote class="mj"><p id="e357" class="mk ml iu bd mm mn mo mp mq mr ms le dk translated">通过细化范围，一个优秀的程序员会驱使面试官走向他/她想要的解决方案。</p></blockquote><p id="3c3b" class="pw-post-body-paragraph kh ki iu kj b kk mt km kn ko mu kq kr ks mv ku kv kw mw ky kz la mx lc ld le in bi translated">当面试官问"<em class="lf">给定一组城镇居民，如何计算选民的平均年龄？</em>”，一个好的程序员会很快写出下面的解决方案:</p><pre class="my mz na nb gu nc nd ne nf aw ng bi"><span id="f1a3" class="nh lh iu nd b gz ni nj l nk nl">function calculateAge(votersArray: [Citizen]) {<br/>   if (votersArray.count &lt; 1) { <br/>      return 0<br/>   }</span><span id="7b20" class="nh lh iu nd b gz nm nj l nk nl">   sum = 0<br/>   for person in votersArray {<br/>      sum =+ voter.age<br/>   }</span><span id="bcbf" class="nh lh iu nd b gz nm nj l nk nl">   average = sum / votersArray.count<br/>   return average<br/>}</span></pre><p id="4042" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">另一方面，一个杰出的程序员会问以下问题:</p><ul class=""><li id="9a0e" class="nn no iu kj b kk kl ko kp ks np kw nq la nr le ns nt nu nv bi translated">最低投票年龄是多少？(记住这是一个<strong class="kj iv">公民</strong>阵列，而不是现成的选民名单！)</li><li id="fcd7" class="nn no iu kj b kk nw ko nx ks ny kw nz la oa le ns nt nu nv bi translated">是否有一个数据项来表示一个选民是否是选举机构的注册选民？</li></ul><p id="fd38" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">在这一点上，大多数面试官都没有给出具体的答案。他们宁愿让候选人自由地以他们能做到的最好的方式去实现它。(尽管他们在心里为提问分配了一些分数，为正确的提问分配了更多分数)</p><p id="37d9" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">杰出的程序员会这样编写他/她的解决方案(该解决方案不遵循任何编程语言):</p><pre class="my mz na nb gu nc nd ne nf aw ng bi"><span id="588b" class="nh lh iu nd b gz ni nj l nk nl">class Citizen {<br/>    var age: Int<br/>    var isRegistered: Bool<br/>}</span><span id="d035" class="nh lh iu nd b gz nm nj l nk nl">function calculateAge(citizensArray: [Citizen], filterFunction: (Voter) -&gt; Bool) {<br/>   if (citizensArray.count &lt; 1) {<br/>     logMessage("Citizen list is empty!")    <br/>     return 0<br/>   }</span><span id="9c0c" class="nh lh iu nd b gz nm nj l nk nl">var votersCount = 0 //tracks only the eligible voters<br/>for citizen in citizensArray {<br/>      if (citizen.age &gt;= MINIMUM_VOTER_AGE &amp;&amp; citizen.isRegistered == true)<br/>        sum =+ sum + citizen.age <br/>        votersCount += 1<br/>      }   <br/>   }</span><span id="6ecd" class="nh lh iu nd b gz nm nj l nk nl">   average = votersCount &gt; 0 ? (sum / votersCount) : 0<br/>   return average<br/>}</span><span id="4e09" class="nh lh iu nd b gz nm nj l nk nl"><strong class="nd iv">// Usage:</strong></span><span id="388d" class="nh lh iu nd b gz nm nj l nk nl">citizen1 = Citizen(age: 38, isRegistered: true)<br/>citizen2 = Citizen(age: 30, isRegistered: true)<br/>citizen3 = Citizen(age: 28, isRegistered: false)</span><span id="032f" class="nh lh iu nd b gz nm nj l nk nl">citizens = [citizen1, citizen2, citizen3]</span><span id="7f10" class="nh lh iu nd b gz nm nj l nk nl">//finds average age of voters - returns 34<br/>let average = calculateAge(citizensArray: citizens)</span></pre><p id="87f5" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">注意到细化范围带来的不同了吗？通过这样做，杰出的程序员-</p><ul class=""><li id="a6df" class="nn no iu kj b kk kl ko kp ks np kw nq la nr le ns nt nu nv bi translated">展示他/她的对象设计技能，测试数据的抽象性和内聚性(公民年龄、注册等)。</li><li id="f40e" class="nn no iu kj b kk nw ko nx ks ny kw nz la oa le ns nt nu nv bi translated">不仅处理边界条件，而且有助于定义边界条件(15000名注册选民对89000名公民)。通过细化范围，他/她帮助(并有效地推动)面试者找到他/她想要的解决方案。</li><li id="149d" class="nn no iu kj b kk nw ko nx ks ny kw nz la oa le ns nt nu nv bi translated">报告错误。这里，通过日志记录来报告空的公民列表，但是异常也可以是报告它们的另一种方式。</li><li id="c7f0" class="nn no iu kj b kk nw ko nx ks ny kw nz la oa le ns nt nu nv bi translated">通过在“使用”部分包含客户电话示例，展示他/她的解决方案的优势。</li></ul><p id="6d6f" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">现在，如果你回顾一下优秀程序员的解决方案，你会发现它是对面试官讲述的问题的正确解决方案。</p><p id="fc23" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">但是它似乎植根于在线编码测试环境，在那里检查边界条件被认为是完美编程的最终目标。这导致人们限制了问题的范围。</p><p id="90d3" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">一个优秀的程序员将问题领域扩展到了编码之外，这样做的结果是创造出更多可用的代码，这些代码可以更容易地部署到生产中。</p><h1 id="de75" class="lg lh iu bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">#2:干净的代码:</h1><p id="7128" class="pw-post-body-paragraph kh ki iu kj b kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la mi lc ld le in bi translated">范围细化导致人们解决了50%的问题。干净的代码完成剩下的工作。</p><p id="d158" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">干净的代码不是一种特质，而是一种状态，是通过对同一段已经运行良好的代码进行数小时的工作而达到的。换句话说，它是无数小时重构的结果，是在对坚实的原则有清晰了解的情况下完成的。</p><blockquote class="mj"><p id="4927" class="mk ml iu bd mm mn mo mp mq mr ms le dk translated">干净的代码不是一种特质，而是一种通过数小时的重构才能达到的状态</p></blockquote><p id="20d6" class="pw-post-body-paragraph kh ki iu kj b kk mt km kn ko mu kq kr ks mv ku kv kw mw ky kz la mx lc ld le in bi translated">如果你是那种从StackOverflow复制解决方案并且不经过至少3次迭代就发布的人，你可能在这方面有很多工作要做。我知道，因为我就是其中之一，并且在我作为高级开发人员的职业生涯中为此付出了巨大的代价。</p><p id="ed41" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">我们用一个例子来理解这个。在一个典型的编码任务中，面试官会询问如何从API获取数据，并在UI中显示数据。</p><p id="0b48" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">这通常是通过将API数据(<strong class="kj iv"> <em class="lf"> api/restaurants </em> </strong>)转换成域对象(<strong class="kj iv"> Restaurant </strong>数组)，并编写依赖于该域对象的UI代码来完成的。</p><p id="8a5d" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">一个在从物联网到流媒体等领域工作过的优秀程序员仍然有可能编写出这样的代码:</p><pre class="my mz na nb gu nc nd ne nf aw ng bi"><span id="8246" class="nh lh iu nd b gz ni nj l nk nl">var restaurantArray = Array&lt;Restaurant&gt;()<br/>if JSONDeSerializer().decode(httpResponse) != Error {<br/>   restaurantArray = JSONDeSerializer().decode(httpResponse)<br/>} else if XMLDeSerializer().decode(httpResponse) != Error {<br/>   restaurantArray = XMLDeSerializer().decode(httpResponse)<br/>}</span></pre><p id="6f3a" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">问题？这段代码不仅对响应进行了两次解码(首先是在检查中，然后是在实际的转换中)，而且很快就可能变成意大利面条。如果除了XML和JSON之外还有更多的去序列化格式呢？</p><blockquote class="mj"><p id="9ef1" class="mk ml iu bd mm mn mo mp mq mr ms le dk translated">If-else是穷人的多态。</p></blockquote><p id="e5c7" class="pw-post-body-paragraph kh ki iu kj b kk mt km kn ko mu kq kr ks mv ku kv kw mw ky kz la mx lc ld le in bi translated">重申一下，问题不在于转换本身，而在于模式。如果您现在有一个处理检查4个字段的业务逻辑，如果您用上面显示的<strong class="kj iv"> if-else方法</strong>来编码，它将容纳10个以上字段的可能性有多大？</p><p id="6f54" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">有人把if-else恰当地称为穷人的多态性。</p><p id="ab50" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">杰出的程序员已经意识到了这一点，并设计了类似这样的解决方案:</p><pre class="my mz na nb gu nc nd ne nf aw ng bi"><span id="58e4" class="nh lh iu nd b gz ni nj l nk nl">class APIDownloader {<br/>   APIDownloader(deserializer: Deserializer) {<br/>      this.deserializer = deserializer<br/>   }</span><span id="edc1" class="nh lh iu nd b gz nm nj l nk nl">   function downloadData() {<br/>      //downloading logic<br/>      deserializer.decode(httpResponse)<br/>   }<br/>}</span></pre><p id="65ea" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">什么是<strong class="kj iv"> Deserialiser </strong>？它是定义<strong class="kj iv"> decode(HttpResponse) </strong>函数的接口/协议。它必须由<strong class="kj iv"> JSONDeSerializer </strong>和<strong class="kj iv"> XMLDeSerializer </strong>类实现/符合，这两个类提供了<strong class="kj iv"> decode </strong>()函数的具体实现(大部分是开源的)</p><p id="cb37" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">deserialiser从哪里来？从外部<strong class="kj iv"> APIDownloader </strong>。APIDownloader并不负责决定它所处理的HTTP响应格式。其他一些类创建了一个类型为<strong class="kj iv">反序列化器</strong>的对象(可能是类<strong class="kj iv"> JSONDeSerializer </strong>或<strong class="kj iv"> XMLDeSerializer </strong>的实例)，并将它传递给APIDownloader。</p><blockquote class="mj"><p id="f519" class="mk ml iu bd mm mn mo mp mq mr ms le dk translated">策略是将if/else推到您正在编码的类之外，最终用switch/case替换它</p></blockquote><p id="3058" class="pw-post-body-paragraph kh ki iu kj b kk mt km kn ko mu kq kr ks mv ku kv kw mw ky kz la mx lc ld le in bi translated">那个<em class="lf">其他类</em>可能是一个<strong class="kj iv"> APIClient </strong>类，它甚至在发出HTTP请求之前就知道HTTP响应将是哪种格式。或者，它可以是对<strong class="kj iv"> APIDownloader、</strong>的单元测试，这使得APIDownloader的任务非常明确:只需下载数据，并将XML/JSON域对象返回给我。</p><p id="c3c1" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">如果你再想一次，这整个练习的目的是把if-else推到你正在编码的类的范围之外。APIDownloader将if-else委托给<strong class="kj iv">API client</strong>/单元测试，以此类推<strong class="kj iv">。当绝对有必要使用它时，可以用<strong class="kj iv">开关盒</strong>代替它，这使得编译器的工作相当容易(当然，取决于编程语言)</strong></p><p id="c529" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">在编程术语中，这种技术被称为依赖注入，它是干净代码的基石之一。</p><p id="9a6b" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">之所以如此，是因为它自动实施了干净代码的基本原则:</p><ul class=""><li id="27b9" class="nn no iu kj b kk kl ko kp ks np kw nq la nr le ns nt nu nv bi translated">类设计和关注点分离(也称为实体中的S)</li><li id="6993" class="nn no iu kj b kk nw ko nx ks ny kw nz la oa le ns nt nu nv bi translated">单层抽象(APIDownloader只处理下载，不处理转换<strong class="kj iv"> ) </strong></li><li id="94fe" class="nn no iu kj b kk nw ko nx ks ny kw nz la oa le ns nt nu nv bi translated">多态(<strong class="kj iv">deserializer</strong>抽象接口<strong class="kj iv"> ) </strong></li><li id="0653" class="nn no iu kj b kk nw ko nx ks ny kw nz la oa le ns nt nu nv bi translated">测试驱动开发</li></ul><p id="09e1" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">如果你只知道如何使用依赖注入技术，你会更频繁地开始自我修正和重构你的代码。是的，它有它的局限性——特别是当你最终将N个参数注入到你的类中时，这时你应该简单地通过合并它们来设计一个单独的类。</p><p id="0940" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">但一般来说，当你开始使用DI时，它会很容易成为一种习惯。在你意识到之前，你会变成一个与众不同的你。</p><h1 id="a74c" class="lg lh iu bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">#3:构建功能，而不是特性:</h1><p id="a742" class="pw-post-body-paragraph kh ki iu kj b kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la mi lc ld le in bi translated">如果你重温我们在#1中看到的例子，你会发现杰出程序员的方法中有一个明显的缺点。在演示范围细化功能时，他/她最终向<strong class="kj iv"> Citizen </strong>类添加了两个字段(<strong class="kj iv"> isRegistered </strong>和<strong class="kj iv"> age </strong>)。</p><p id="5886" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">虽然这些是至关重要的细节，但它们使解决方案承载了一组额外的<em class="lf"> if </em>条件(<strong class="kj iv">citizen . AGE&gt;= MINIMUM _ VOTER _ AGE&amp;&amp;citizen . is registered = = true)。</strong></p><p id="593c" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">可以添加到<strong class="kj iv"> Citizen </strong>类中的属性有一个无穷无尽的列表。但是，就编码/展示解决方案所花费的时间而言，它能展示候选人的更多能力吗？一点也不。</p><p id="179a" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">面试官总是会发现这一点，尽管当他们拒绝这样的候选人时，他们只会说“<em class="lf">候选人最后做了超出范围的事情。</em></p><p id="bdd0" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">他们可能会忽略报告(虽然这是一个事实)是这个声明:</p><blockquote class="ob oc od"><p id="9049" class="kh ki lf kj b kk kl km kn ko kp kq kr oe kt ku kv of kx ky kz og lb lc ld le in bi translated">没有展示其他能力。</p></blockquote><p id="36cc" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">优秀的程序员可以实现没有bug的特性，就像需求中描述的那样。当他们多走了一英里，他们的<strong class="kj iv">复杂度与结果</strong>图是线性的。在实现更多的过程中，他们最终使代码变得更加复杂。</p><p id="74a9" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">优秀的程序员会实现有或没有错误的特性。但是这样做的话，他们会把代码留给有额外能力的继任者。这些能力确保了任何数量的属性或功能的增加都可以用最少的额外改动来处理。</p><p id="6478" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">优秀程序员的<strong class="kj iv">复杂度与结果的</strong>图会比线性图更好——可能是指数图。换句话说，他们将以更少的额外复杂性获得更好的结果。</p><p id="39c9" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">在范围细化过程中，一个优秀的程序员可能还会问:</p><blockquote class="ob oc od"><p id="56f8" class="kh ki lf kj b kk kl km kn ko kp kq kr oe kt ku kv of kx ky kz og lb lc ld le in bi translated">我们感兴趣的是整体平均年龄，还是某一特定选民群体的平均年龄(如右翼选民、女性选民、受过教育的选民等)。)</p></blockquote><p id="047e" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">同样，面试官不会提供任何具体的东西，但他们会观察到更进一步的热情。然而，更重要的是，他们将有兴趣看到候选人如何完成<strong class="kj iv"><em class="lf"/></strong>。</p><p id="8640" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">上句中粗体+斜体的<strong class="kj iv"> <em class="lf"> it </em> </strong>部分代表验证/评估任何数量的额外公民属性的能力，不会因不必要的if/else条件而增加代码，符合上面的#2。</p><pre class="my mz na nb gu nc nd ne nf aw ng bi"><span id="4b77" class="nh lh iu nd b gz ni nj l nk nl"><strong class="nd iv">type CitizenEvaluator =</strong> <strong class="nd iv">(Citizen) -&gt; Bool</strong></span><span id="fe58" class="nh lh iu nd b gz nm nj l nk nl">function calculateAge(citizensArray: [Citizen], <strong class="nd iv">filterFunction</strong>: <strong class="nd iv">CitizenEvaluator</strong>) {<br/>   if (citizensArray.count &lt; 1) {<br/>     logMessage("Citizen list is empty!")    <br/>     return 0<br/>   }</span><span id="68bf" class="nh lh iu nd b gz nm nj l nk nl">   var eligibleVotersCount = 0 //tracks only the eligible voters<br/>   for citizen in citizensArray {<br/>      if (fliterFunction(citizen) == true)<br/>        sum =+ sum + citizen.age<br/>        eligibleVotersCount += 1<br/>     }   <br/>   }</span><span id="281d" class="nh lh iu nd b gz nm nj l nk nl">   average = eligibleVotersCount &gt; 0 ? (sum / eligibleVotersCount) : 0<br/>   return average<br/>}</span><span id="f5d7" class="nh lh iu nd b gz nm nj l nk nl"><strong class="nd iv">// Usage:<br/></strong>ageEligibleFilterFunction = function(citizen) {<br/>   return citizen.age &gt;= MINIMUM_VOTER_AGE<br/>}</span><span id="4724" class="nh lh iu nd b gz nm nj l nk nl">registrationFilterFunction = function(citizen) { <br/>   return citizen.isRegistered == true<br/>}</span><span id="5b92" class="nh lh iu nd b gz nm nj l nk nl">function maleVoterFilterFunction = function(citizen) { <br/>    return ageEligibleFilterFunction(citizen) &amp;&amp; registrationFilterFunction(citizen) &amp;&amp; citizen.gender == MALE<br/>}</span><span id="0496" class="nh lh iu nd b gz nm nj l nk nl">femaleVoterGraduateFilterFunction = function(citizen) {<br/>    return ageEligibleFilterFunction(citizen) &amp;&amp; registrationFilterFunction(citizen) &amp;&amp; (citizen.gender == FEMALE &amp;&amp; citizen.education &gt; GRADUATE)<br/>}</span><span id="a55e" class="nh lh iu nd b gz nm nj l nk nl">citizen1 = Citizen(age: 34, isRegistered: true, gender: MALE, education: GRADUATE)<br/>citizen2 = Citizen(age: 23, isRegistered: true, gender: FEMALE, education: POSTGRADUATE)<br/>citizen3 = Citizen(age: 9, isRegistered: false, gender: FEMALE, education: STUDY)<br/>citizen4 = Citizen(age: 28, isRegistered: false, gender: FEMALE, education: GRADUATE)</span><span id="ffe9" class="nh lh iu nd b gz nm nj l nk nl">citizens = [citizen1, citizen2, citizen3, citizen4]</span><span id="b8d1" class="nh lh iu nd b gz nm nj l nk nl">//finds the average age of male voters<br/>let maleAverage = calculateAge(citizensArray: citizens, filterFunction: <strong class="nd iv">maleFilterFunction</strong>)</span><span id="e3a4" class="nh lh iu nd b gz nm nj l nk nl">//finds the average age of female, post-graduate voters<br/>let femalePGAverage = calculateAge(citizensArray: citizens, filterFunction: <strong class="nd iv">femaleGraduateFilterFunction</strong>)</span></pre><p id="1b2f" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">注意<strong class="kj iv"> CitizenEvaluator类型，</strong>，它是一个函数的类型别名，该函数接受Citizen参数，并基于Citizen对象的各种属性返回布尔值。它作为一个参数被添加到<strong class="kj iv"> calculateAge() </strong>函数中，从而强制其所有客户端自己提供合适的if条件，从而使<strong class="kj iv"> calculateAge() </strong>摆脱任何<strong class="kj iv"> if-else </strong>的疯狂。</p><p id="06bb" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated"><strong class="kj iv">ageEligibleFilterFunction</strong>和<strong class="kj iv"> registrationFilterFunction都属于</strong>公民评估者类型<strong class="kj iv">。</strong><strong class="kj iv">maleVoterFilterFunction</strong>和<strong class="kj iv">femaleVoterFilterFunction</strong>也是citizen evaluator<strong class="kj iv"/><strong class="kj iv">、</strong>类型，但它们另外依赖ageEligibleFilterFunction和registrationFilterFunction——与对象组合设计模式不同，其中一个对象可以包含其他嵌套对象。</p><p id="d28e" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">如您所见，使用上面显示的功能块方法，可以在彼此之上构建高度定制的强大功能链。</p><p id="4007" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">使用这种方法，优秀的开发人员可以展示几个特点:</p><ul class=""><li id="97b3" class="nn no iu kj b kk kl ko kp ks np kw nq la nr le ns nt nu nv bi translated"><strong class="kj iv">交流中的抽象:</strong>在提问时，优秀的程序员不会讨论预期解决方案的技术方面(例如，<em class="lf">我应该使用函数式编程吗？</em>)。他/她只是要求使用与功能相关的术语。只有当他/她要讨论代码问题/质量时，才有必要在代码级别上交谈。这种能力被称为在正确的抽象层次上工作，它在真正的程序员生活中是非常必要的。</li><li id="3f82" class="nn no iu kj b kk nw ko nx ks ny kw nz la oa le ns nt nu nv bi translated"><strong class="kj iv">功能理解</strong>:该解决方案不仅显示了使用最少的行可以实现多少功能，还显示了一个简单的统计平均值可以揭示多少关于数据集合的细节(选民教育、选民性别等)。).</li><li id="87df" class="nn no iu kj b kk nw ko nx ks ny kw nz la oa le ns nt nu nv bi translated">简单性:普通程序员可以以线性方式添加细节，但不会增加优秀程序员开发的功能的复杂性。在某种程度上，优秀的程序员能够为产品添加无限多的特性，而不需要他/她自己去添加。即使是一般的程序员也可以使用这些代码来构建具有增量特性集的产品。</li><li id="7d64" class="nn no iu kj b kk nw ko nx ks ny kw nz la oa le ns nt nu nv bi translated"><strong class="kj iv">简洁:</strong>公民属性列表可以是无穷无尽的，但两项(性别和教育)足以证明他/她可以在正确的背景下处理问题，甚至在试图解决问题之前。</li></ul><p id="69a8" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">当面试官遇到如此优秀的候选人时，他们甚至不太可能考虑其他候选人，除非他们担心自己会被更好的替代者抹杀。</p><h1 id="7c3f" class="lg lh iu bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">结论:</h1><p id="e414" class="pw-post-body-paragraph kh ki iu kj b kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la mi lc ld le in bi translated">实现功能是面试中的首要要求。这一结论在很大程度上受到了编码面试学校的启发，这些学校通过分离和分类他们应该解决的问题来训练候选人改善他们的陈述，以安慰面试官。</p><p id="36e7" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">虽然这是一个可以接受的真相，但它不是完全的真相。在招聘技术含量高的职位时，面试官在寻找他们提问范围之外的东西。他们希望有人能补充他们的想法，从而指导解决过程。</p><p id="8d48" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">有人可以成为达芬奇不朽名言的活纪念碑:</p><blockquote class="ob oc od"><p id="e7c6" class="kh ki lf kj b kk kl km kn ko kp kq kr oe kt ku kv of kx ky kz og lb lc ld le in bi translated">简单是最复杂的。</p></blockquote><p id="a926" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated">掌握这三个强大的属性使一个人成为杰出的程序员，而不仅仅是杰出的候选人。那么，面试中的成功就成了副产品，而不是人生的目标。</p></div><div class="ab cl oh oi hy oj" role="separator"><span class="ok bw bk ol om on"/><span class="ok bw bk ol om on"/><span class="ok bw bk ol om"/></div><div class="in io ip iq ir"><p id="23ce" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated"><a class="ae kg" href="https://tipsnguts.medium.com/" rel="noopener"> <strong class="kj iv">笔磁铁</strong> </a>是广受欢迎的高级开发人员面试电子书的作者，该书解决了亚马逊明星面试格式的问题:</p><p id="1c46" class="pw-post-body-paragraph kh ki iu kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le in bi translated"><a class="ae kg" href="https://tipsnguts.gumroad.com/l/crrzat/zp1vks8" rel="noopener ugc nofollow" target="_blank"> <strong class="kj iv">高级开发人员面试综合方法(40+例题)</strong> </a> <strong class="kj iv"> </strong>(对于第<strong class="kj iv"> 100名中等读者，</strong>折扣为<strong class="kj iv"> 50% </strong>)</p></div></div>    
</body>
</html>