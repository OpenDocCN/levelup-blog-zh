<html>
<head>
<title>Building an Animated Slider — WotW</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">建立一个动画滑块-WotW</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/making-an-animated-slider-wotw-a98f71438b33?source=collection_archive---------0-----------------------#2018-07-12">https://levelup.gitconnected.com/making-an-animated-slider-wotw-a98f71438b33?source=collection_archive---------0-----------------------#2018-07-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/14d032e7b344790099e3c7b9ada61115.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*JprtGSVvToVFR9WH.jpg"/></div></div></figure><p id="4b40" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">欢迎来到“每周小部件”系列，在这里我拍摄了令人敬畏的UI/UX组件的gif或视频，并用代码将它们赋予生命。</p><blockquote class="kw"><p id="aba6" class="kx ky iq bd kz la lb lc ld le lf kv dk translated">查看本周文章中的所有<a class="ae lg" rel="noopener ugc nofollow" target="_blank" href="https://levelup.gitconnected.com/wotw/home">小部件，并关注gitconnected，确保您不会错过任何即将到来的JavaScript和CSS教程</a></p></blockquote><p id="e21b" class="pw-post-body-paragraph jy jz iq ka b kb lh kd ke kf li kh ki kj lj kl km kn lk kp kq kr ll kt ku kv ij bi translated">这一次我们将创建一个温度滑块，虽然它可以用于任何事情。灵感来自于这个由<a class="ae lg" href="https://uimovement.com/user/10/ramykhuffash/" rel="noopener ugc nofollow" target="_blank">ramykhufash</a>创作的<a class="ae lg" href="https://uimovement.com/ui/5774/smart-home/" rel="noopener ugc nofollow" target="_blank">投稿</a>，看起来是这样的:</p><figure class="ln lo lp lq gt jr gh gi paragraph-image"><div class="gh gi lm"><img src="../Images/c203c55eeca784aae91be32d54d0c0b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:888/0*xzWiX_Dn2C97DGu2.gif"/></div></figure><h2 id="4f46" class="lr ls iq bd lt lu lv dn lw lx ly dp lz kj ma mb mc kn md me mf kr mg mh mi mj bi translated">准备</h2><p id="4c7f" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">对于今天的小部件，我们将使用<a class="ae lg" href="https://vuejs.org/" rel="noopener ugc nofollow" target="_blank"> Vue.js </a>，对于一些动画，我们将使用<a class="ae lg" href="https://greensock.com/tweenmax" rel="noopener ugc nofollow" target="_blank"> TweenMax </a>。我们还需要一个温度图标，所以我们将使用从<a class="ae lg" href="https://fontawesome.com/" rel="noopener ugc nofollow" target="_blank">字体真棒</a>的一个。</p><p id="4067" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你想继续，你可以派生这个已经有依赖关系的<a class="ae lg" href="https://codepen.io/ederdiaz/pen/gzyxWv" rel="noopener ugc nofollow" target="_blank"> codepen模板</a>。</p><h2 id="62f6" class="lr ls iq bd lt lu lv dn lw lx ly dp lz kj ma mb mc kn md me mf kr mg mh mi mj bi translated">匹配设计</h2><p id="7b24" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">这个小部件的HTML标记比通常的要复杂一些，所以这一次我将使用HTML + CSS把它分成几个部分，直到我们符合最初的设计。</p><p id="9635" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们从设置上下两部分开始——上部分包含数字，下部分包含滑块控件。</p><pre class="ln lo lp lq gt mp mq mr ms aw mt bi"><span id="596d" class="lr ls iq mq b gy mu mv l mw mx">&lt;div id="app" class="main-container"&gt;<br/>  &lt;div class="upper-container"&gt;<br/>    <br/>  &lt;/div&gt;<br/>  &lt;div class="lower-container"&gt;<br/>    <br/>  &lt;/div&gt;<br/>&lt;/div&gt;</span></pre><p id="6245" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在对它们进行样式化之前，我们需要在<code class="fe my mz na mq b">body</code>中添加几个主要的CSS属性。</p><pre class="ln lo lp lq gt mp mq mr ms aw mt bi"><span id="8742" class="lr ls iq mq b gy mu mv l mw mx">body {<br/>  margin: 0;<br/>  color: white;<br/>  font-family: Arial, Helvetica, sans-serif;<br/>}</span></pre><p id="dd49" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将边距设置为<code class="fe my mz na mq b">0</code>，以避免<code class="fe my mz na mq b">main-container</code>周围出现空白。这里还设置了<code class="fe my mz na mq b">color</code>和<code class="fe my mz na mq b">font-family</code>，以避免在其他元素中重复出现。</p><p id="74eb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们将使用<code class="fe my mz na mq b">CSS grid</code>属性将屏幕分成两部分。上半部分需要取垂直高度的<code class="fe my mz na mq b">3/4</code>，我们可以用<code class="fe my mz na mq b">fr</code>来实现。</p><pre class="ln lo lp lq gt mp mq mr ms aw mt bi"><span id="16ef" class="lr ls iq mq b gy mu mv l mw mx">.main-container {<br/>  display: grid;<br/>  grid-template-columns: 1fr;<br/>  grid-template-rows: 3fr 1fr;<br/>  height: 100vh;<br/>}</span></pre><p id="be79" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意<code class="fe my mz na mq b">height</code>属性中的<code class="fe my mz na mq b">100vh</code>值，它允许我们垂直填充屏幕，即使我们的div没有任何内容。</p><p id="0564" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在只需要给这些部分添加一个背景色。对于上面一个，我们将使用梯度:</p><pre class="ln lo lp lq gt mp mq mr ms aw mt bi"><span id="031e" class="lr ls iq mq b gy mu mv l mw mx">.upper-container {<br/>  position: relative;<br/>  background: linear-gradient(to bottom right, #5564C2, #3A2E8D);<br/>}<br/>.lower-container {<br/>  background-color: #12132C;<br/>}</span></pre><p id="16b3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<code class="fe my mz na mq b">upper-container</code>中设置的<code class="fe my mz na mq b">position: relative</code>属性将在我们托盘定位其内部元素时使用。</p><figure class="ln lo lp lq gt jr gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/c63bb127051e994869c93d6d7ea34edf.png" data-original-src="https://miro.medium.com/v2/resize:fit:802/format:webp/0*xk23CVlVuX6BrrhE.png"/></div></figure><p id="3ecb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们才刚开始热身。</p><p id="5736" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上半部分的数字似乎是合乎逻辑的下一步。</p><pre class="ln lo lp lq gt mp mq mr ms aw mt bi"><span id="c81f" class="lr ls iq mq b gy mu mv l mw mx">&lt;!-- inside .upper-container --&gt;<br/>    &lt;h2 class="temperature-text"&gt;10&lt;/h2&gt;</span></pre><p id="b503" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这将是显示当前温度的大数字，让我们使用一些CSS来更好地定位它:</p><pre class="ln lo lp lq gt mp mq mr ms aw mt bi"><span id="bf4a" class="lr ls iq mq b gy mu mv l mw mx">.temperature-text {<br/>  position: absolute;<br/>  bottom: 150px;<br/>  font-size: 100px;<br/>  width: 100%;<br/>  text-align: center;<br/>  user-select: none;<br/>}</span></pre><p id="3817" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe my mz na mq b">user-select: none</code>属性应该帮助我们避免在与滑块交互时选择文本。</p><p id="3fc0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在添加下面显示的数字之前，让我们用一些数据启动Vue实例，以帮助我们避免重复不必要的标记元素:</p><pre class="ln lo lp lq gt mp mq mr ms aw mt bi"><span id="bedd" class="lr ls iq mq b gy mu mv l mw mx">new Vue({<br/>  el: '#app',<br/>  data: {<br/>    temperatureGrades: [10, 15, 20, 25, 30]<br/>  }<br/>})</span></pre><p id="41df" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们可以使用<code class="fe my mz na mq b">temperatureGrades</code>数组来显示设计中的元素:</p><pre class="ln lo lp lq gt mp mq mr ms aw mt bi"><span id="a229" class="lr ls iq mq b gy mu mv l mw mx">&lt;!-- just after .temperature-text --&gt;<br/>    &lt;div class="temperature-graduation"&gt;<br/>      &lt;div class="temperature-element" <br/>           v-for="el in temperatureGrades" <br/>           :key="el"&gt;<br/>        &lt;span class="temperature-element-number"&gt;{{el}}&lt;/span&gt;&lt;br&gt;<br/>        &lt;span class="temperature-element-line"&gt;|&lt;/span&gt;<br/>      &lt;/div&gt;<br/>    &lt;/div&gt;</span></pre><p id="a4ac" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请注意，我们使用一个<code class="fe my mz na mq b">|</code>字符来渲染每个数字，我们可以用它来使它们看起来像一个“尺子”。</p><p id="ba9c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于我们需要居中文本的数字和行，我们将在<code class="fe my mz na mq b">temperature-element</code>规则内这样做。我们还将使元素成为<code class="fe my mz na mq b">inline-blocks</code>，这样它们就可以彼此相邻。最后，<code class="fe my mz na mq b">|</code>字符需要变小，<code class="fe my mz na mq b">font-size</code>会处理好这一点:</p><pre class="ln lo lp lq gt mp mq mr ms aw mt bi"><span id="fdc3" class="lr ls iq mq b gy mu mv l mw mx">.temperature-element {<br/>  text-align: center;<br/>  display: inline-block;<br/>  width: 40px;<br/>  margin: 0 10px 0 10px;<br/>  opacity: 0.7;<br/>}<br/>.temperature-element-line {<br/>  font-size: 7px;<br/>}</span></pre><p id="15eb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">检查<code class="fe my mz na mq b">.temperature-graduation</code>元素，我们可以看到它的宽度是300像素。为了使其居中，我们可以通过以下方式使用计算值:</p><pre class="ln lo lp lq gt mp mq mr ms aw mt bi"><span id="9e6d" class="lr ls iq mq b gy mu mv l mw mx">.temperature-graduation {<br/>  position: absolute;<br/>  left: calc(50% - 150px); // subtracting half the width to center<br/>  bottom: 25px;<br/>  user-select: none;<br/>}</span></pre><p id="e8b8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们还设置了<code class="fe my mz na mq b">bottom</code>属性，使其显示在下半部分的正上方。</p><figure class="ln lo lp lq gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nc"><img src="../Images/3eab1bd3db231a34e3bc2336739ed72e.png" data-original-src="https://miro.medium.com/v2/resize:fit:726/format:webp/0*XmkD6WDcRXN4joNb.png"/></div></div></figure><h2 id="d296" class="lr ls iq bd lt lu lv dn lw lx ly dp lz kj ma mb mc kn md me mf kr mg mh mi mj bi translated">滑块</h2><p id="b095" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">上半部分准备好了，现在我们将添加滑块控件。这个按钮很简单，我们只需要一个带有图标的div:</p><pre class="ln lo lp lq gt mp mq mr ms aw mt bi"><span id="5452" class="lr ls iq mq b gy mu mv l mw mx">&lt;!-- inside .lower-container --&gt;<br/>    &lt;div class="slider-container"&gt;<br/>      &lt;div class="slider-button"&gt;<br/>        &lt;i class="fas fa-thermometer-empty slider-icon"&gt;&lt;/i&gt;<br/>      &lt;/div&gt;<br/>    &lt;/div&gt;</span></pre><p id="7c51" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们来设计按钮的样式，下面的CSS代码大部分都是手工“调整”的值，以便能够将元素放置在所需的位置。</p><pre class="ln lo lp lq gt mp mq mr ms aw mt bi"><span id="0c35" class="lr ls iq mq b gy mu mv l mw mx">.slider-container {<br/>  width: 150px;<br/>  height: 80px;<br/>  margin-top: -30px;<br/>  margin-left: calc(50% - 187px);<br/>  position: relative;<br/>}<br/>.slider-button {<br/>  position: absolute;<br/>  left: 42px;<br/>  top: 5px;<br/>  width: 50px;<br/>  height: 50px;<br/>  border-radius: 50%;<br/>  background-color: #2724A2;<br/>  <br/>  cursor: grab;<br/>  cursor: -webkit-grab; <br/>  cursor: -moz-grab;<br/>}<br/><br/>.slider-icon {<br/>  margin-top: 16px;  <br/>  margin-left: 21px;  <br/>  color: white;<br/>}</span></pre><p id="9f47" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">按钮内的<code class="fe my mz na mq b">grab</code>值会在光标悬停时将光标变成一只手。</p><p id="2258" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">滑块现在只是缺少了一个“波浪”形状，起初我试图通过使用<code class="fe my mz na mq b">border-radius</code>值和旋转<code class="fe my mz na mq b">div</code>来实现，但遗憾的是它与设计不匹配。我最后做的是一个<code class="fe my mz na mq b">SVG</code>图形，看起来像这样:</p><figure class="ln lo lp lq gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nd"><img src="../Images/c73eb9402c7d7cc0c96972afeae7e428.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-kbSYh6kbyyiU11v.png"/></div></div><figcaption class="ne nf gj gh gi ng nh bd b be z dk translated">绝对不是蛇里面的大象</figcaption></figure><p id="613d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个形状的代码是:</p><pre class="ln lo lp lq gt mp mq mr ms aw mt bi"><span id="a8b7" class="lr ls iq mq b gy mu mv l mw mx">&lt;!-- inside .slider-container --&gt;<br/>&lt;svg width="150" height="30" viewBox="0 0 150 30" fill="none" ae lg" href="http://www.w3.org/2000/svg" rel="noopener ugc nofollow" target="_blank"&gt;http://www.w3.org/2000/svg"&gt;<br/>&lt;path d="M74.3132 0C47.0043 2.44032e-05 50.175 30 7.9179 30H144.27C99.4571 30 101.622 -2.44032e-05 74.3132 0Z" transform="translate(-7.38794 0.5)" fill="#12132C"/&gt;<br/>&lt;/svg&gt;</span></pre><figure class="ln lo lp lq gt jr gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/f6e80a89aeda7a9c1e277ab3e470c98b.png" data-original-src="https://miro.medium.com/v2/resize:fit:736/format:webp/0*umQ22yKJCgQ81cnM.png"/></div></figure><p id="3407" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有点困难，但我们已经准备好了设计。</p><h2 id="5175" class="lr ls iq bd lt lu lv dn lw lx ly dp lz kj ma mb mc kn md me mf kr mg mh mi mj bi translated">互动</h2><p id="6918" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">到目前为止，这个小部件的交互中最引人注目的是拖放滑块。我们以前在制作<a class="ae lg" href="http://ederdiaz.com/blog/2018/04/18/animated-card-slider-with-vue-gsap/" rel="noopener ugc nofollow" target="_blank">卡片滑块</a>时已经这样做过了，所以我将遵循类似的方法:</p><pre class="ln lo lp lq gt mp mq mr ms aw mt bi"><span id="36e8" class="lr ls iq mq b gy mu mv l mw mx">// inside data<br/>    dragging: false,<br/>    initialMouseX: 0,<br/>    sliderX: 0,<br/>    initialSliderX: 0</span></pre><p id="f344" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这些数据属性将帮助我们跟踪用户何时开始/停止拖动、鼠标和滑块位置。</p><p id="e071" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当用户交互时，以下方法将初始化这些变量:</p><pre class="ln lo lp lq gt mp mq mr ms aw mt bi"><span id="15ce" class="lr ls iq mq b gy mu mv l mw mx">// after data<br/>  methods: {<br/>    startDrag (e) {<br/>      this.dragging = true<br/>      this.initialMouseX = e.pageX<br/>      this.initialSliderX = this.sliderX<br/>    },<br/>    stopDrag () {<br/>      this.dragging = false<br/>    },<br/>    mouseMoving (e) {<br/>      if(this.dragging) {<br/>        // TODO move the slider        <br/>      }<br/>    }<br/>  }</span></pre><p id="5c28" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们将它们绑定到模板上</p><pre class="ln lo lp lq gt mp mq mr ms aw mt bi"><span id="0938" class="lr ls iq mq b gy mu mv l mw mx">&lt;div id="app" class="main-container"<br/>    @mousemove="mouseMoving"<br/>    @mouseUp="stopDrag"&gt;<br/>      &lt;!-- ... inside .slider-container<br/>        &lt;div class="slider-button" <br/>             @mouseDown="startDrag"&gt;</span></pre><p id="d9ac" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可能已经注意到<code class="fe my mz na mq b">@mouseDown</code>动作被设置在滑块按钮中，但是<code class="fe my mz na mq b">@mouseMove</code>和<code class="fe my mz na mq b">@mouseUp</code>在主div的层次上。</p><p id="c6bc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这背后的原因是，用户将通过按下滑块按钮开始，但当移动光标时，他们通常会在滑块轨道之外，如果他们在按钮之外放开鼠标，它将不会被跟踪，并将导致按钮跟随你，直到你再次单击它。</p><p id="7224" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们用一个算法来填充<code class="fe my mz na mq b">mouseMoving</code>方法，该算法将把<code class="fe my mz na mq b">sliderX</code>属性设置到期望的位置。我们需要为滑块声明一些约束来匹配我们之前做的标尺。</p><pre class="ln lo lp lq gt mp mq mr ms aw mt bi"><span id="82fd" class="lr ls iq mq b gy mu mv l mw mx">// before the Vue instance<br/>const sliderMinX = 0<br/>const sliderMaxX = 240<br/><br/>  // inside mouseMoving method<br/>    // replace the "TODO" line with this:<br/>    const dragAmount = e.pageX - this.initialMouseX<br/>    const targetX = this.initialSliderX + dragAmount<br/>            <br/>    // keep slider inside limits<br/>    this.sliderX = Math.max(Math.min(targetX, sliderMaxX), sliderMinX)<br/><br/>  // after methods<br/>  computed: {<br/>    sliderStyle () {<br/>      return `transform: translate3d(${this.sliderX}px,0,0)`<br/>    }<br/>  }</span></pre><p id="fff3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如您可能已经猜到的，计算属性<code class="fe my mz na mq b">sliderStyle</code>存储了滑块的位置，我们只需要将它绑定到<code class="fe my mz na mq b">.slider-container</code>:</p><pre class="ln lo lp lq gt mp mq mr ms aw mt bi"><span id="d5cb" class="lr ls iq mq b gy mu mv l mw mx">&lt;div class="slider-container" :style="sliderStyle"&gt;</span></pre><p id="ac53" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们几乎有一个工作的滑块控件，但它缺少一个重要的东西，跟踪滑块值。这听起来可能很复杂，但是我们可以用一个计算属性来计算这个值，因为我们已经知道了<code class="fe my mz na mq b">sliderX</code>的位置:</p><pre class="ln lo lp lq gt mp mq mr ms aw mt bi"><span id="2c6f" class="lr ls iq mq b gy mu mv l mw mx">// inside computed    <br/>    currentTemperature () {<br/>      const tempRangeStart = 10<br/>      const tempRange = 20 // from 10 - 30<br/>      return (this.sliderX / sliderMaxX * tempRange ) + tempRangeStart<br/>    }</span></pre><p id="cb4a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以通过在<code class="fe my mz na mq b">.temperature-text</code>元素中呈现它来判断它是否工作:</p><pre class="ln lo lp lq gt mp mq mr ms aw mt bi"><span id="5523" class="lr ls iq mq b gy mu mv l mw mx">&lt;h2 class="temperature-text"&gt;{{currentTemperature}}&lt;/h2&gt;</span></pre><figure class="ln lo lp lq gt jr gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/ba49b692ee6640ac69cc39809af63f6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:708/format:webp/0*7zUymE_xmFgePiMn.png"/></div></figure><p id="c363" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在的问题是它呈现的是浮点数。我们可以使用过滤器来避免这种情况:</p><pre class="ln lo lp lq gt mp mq mr ms aw mt bi"><span id="302e" class="lr ls iq mq b gy mu mv l mw mx">// after data<br/>  filters: {<br/>    round (num) {<br/>      return Math.round(num)<br/>    }<br/>  },</span></pre><p id="4413" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们可以像这样使用过滤器:</p><pre class="ln lo lp lq gt mp mq mr ms aw mt bi"><span id="f2f4" class="lr ls iq mq b gy mu mv l mw mx">&lt;h2 class="temperature-text"&gt;{{currentTemperature | round}}&lt;/h2&gt;</span></pre><h2 id="1fcd" class="lr ls iq bd lt lu lv dn lw lx ly dp lz kj ma mb mc kn md me mf kr mg mh mi mj bi translated">最后的润色</h2><p id="2507" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">我们可以就此收工，让小部件像这样，但它仍然缺少一些细节。当温度超过25度时，背景应该改变颜色，标尺的数字也应该像波浪一样移动。</p><p id="5d3f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">作为背景，我们将在顶部声明几个常数和一些新的数据属性:</p><pre class="ln lo lp lq gt mp mq mr ms aw mt bi"><span id="08ea" class="lr ls iq mq b gy mu mv l mw mx">const coldGradient = {start: '#5564C2', end: '#3A2E8D'}<br/>const hotGradient = {start:'#F0AE4B', end: '#9B4D1B'}<br/><br/>// inside Vue<br/>    // inside data<br/>      gradientStart: coldGradient.start,<br/>      gradientEnd: coldGradient.end<br/><br/>    //inside computed<br/>      bgStyle () {<br/>        return `background: linear-gradient(to bottom right, ${this.gradientStart}, ${this.gradientEnd});`<br/>      }</span></pre><p id="d618" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它们将保存渐变背景所需的颜色。每次<code class="fe my mz na mq b">gradientStart</code>和<code class="fe my mz na mq b">gradientEnd</code>改变时，<code class="fe my mz na mq b">bgStyle</code>计算属性将生成背景。让我们将它绑定到相应的HTML元素:</p><pre class="ln lo lp lq gt mp mq mr ms aw mt bi"><span id="72ac" class="lr ls iq mq b gy mu mv l mw mx">&lt;div class="upper-container" :style="bgStyle"&gt;</span></pre><p id="f220" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在它看起来应该是一样的，但是当我们在<code class="fe my mz na mq b">mouseMoving</code>方法中添加动画规则时，情况会发生变化:</p><pre class="ln lo lp lq gt mp mq mr ms aw mt bi"><span id="ee37" class="lr ls iq mq b gy mu mv l mw mx">// set bg color<br/>    let targetGradient = coldGradient<br/>    if (this.currentTemperature &gt;= 25) {<br/>      targetGradient = hotGradient<br/>    }<br/>        <br/>    if(this.gradientStart !== targetGradient.start) {<br/>      // gradient changed<br/>      TweenLite.to(this, 0.7, {<br/>        'gradientStart': targetGradient.start,<br/>        'gradientEnd': targetGradient.end<br/>      }) <br/>    }</span></pre><p id="5ef0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们正在做的是，当温度变化到25度或更高时，从冷到热改变梯度值。过渡是用TweenLite而不是CSS过渡来完成的，因为它们只适用于纯色。</p><p id="520b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，如果滑块靠近标尺元素，我们需要改变它们的<code class="fe my mz na mq b">Y</code>位置。</p><pre class="ln lo lp lq gt mp mq mr ms aw mt bi"><span id="c79d" class="lr ls iq mq b gy mu mv l mw mx">&lt;div class="temperature-element" v-for="el in temperatureGrades"<br/>           :style="tempElementStyle(el)"<br/>           :key="el"&gt;</span></pre><p id="1f25" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">类似于上面的部分，我们将通过一个方法绑定要改变的样式，这个方法将接收每个标尺的值。现在只需要做一些数学运算来计算距离并生成一些CSS变换道具:</p><pre class="ln lo lp lq gt mp mq mr ms aw mt bi"><span id="bac4" class="lr ls iq mq b gy mu mv l mw mx">// inside methods<br/>    tempElementStyle (tempNumber) {<br/>      const nearDistance = 3<br/>      const liftDistance = 12<br/>      <br/>      // lifts up the element when the current temperature is near it<br/>      const diff = Math.abs(this.currentTemperature - tempNumber)<br/>      const distY = (diff/nearDistance) - 1<br/>      <br/>      // constrain the distance so that the element doesn't go to the bottom<br/>      const elementY = Math.min(distY*liftDistance, 0)<br/>      return `transform: translate3d(0, ${elementY}px, 0)`<br/>    }</span></pre><p id="4faf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">而现在最后的结果！</p><figure class="ln lo lp lq gt jr"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="9d9a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就是本周的<strong class="ka ir">小部件。下周见，关注<a class="ae lg" href="https://levelup.gitconnected.com" rel="noopener ugc nofollow" target="_blank"> gitconnected </a>获取每周小工具！</strong></p><p id="46e6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你渴望更多，你可以查看其他WotW: <br/> — <a class="ae lg" rel="noopener ugc nofollow" target="_blank" href="/making-a-3d-facing-widget-8ab51a9eb573"> 3D面对小工具</a> <br/> — <a class="ae lg" rel="noopener ugc nofollow" target="_blank" href="/cards-hover-animation-wotw-7d1304f16ec6">卡片悬停动画</a> <br/> — <a class="ae lg" rel="noopener ugc nofollow" target="_blank" href="/making-a-scrolling-card-list-wotw-bcd5e31fbcc5">滚动卡片列表</a></p><p id="9b04" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另外，如果你想看下周的某个小部件，可以在评论区发表。</p></div><div class="ab cl nm nn hu no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="ij ik il im in"><p id="a573" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="nt">最初发表于</em><a class="ae lg" href="http://ederdiaz.com/blog/2018/07/11/making-an-animated-slider-wotw/" rel="noopener ugc nofollow" target="_blank"><em class="nt">Eder díaz</em></a><em class="nt">。</em></p><figure class="ln lo lp lq gt jr gh gi paragraph-image"><a href="https://levelup.gitconnected.com/"><div class="gh gi nu"><img src="../Images/439094b9a664ef0239afbc4565c6ca49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S9uYu-fFL3hIQLGVu0o-EQ.png"/></div></a></figure></div></div>    
</body>
</html>