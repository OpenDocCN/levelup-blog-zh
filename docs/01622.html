<html>
<head>
<title>Useful DOM Traversal Methods</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">有用的DOM遍历方法</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/useful-dom-traversal-methods-d2b55cf8e25c?source=collection_archive---------7-----------------------#2020-01-16">https://levelup.gitconnected.com/useful-dom-traversal-methods-d2b55cf8e25c?source=collection_archive---------7-----------------------#2020-01-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/03c35276d727d903e23e68d6239cc7fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*B0jTETBWev3qkrJp"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@leonardvonbibra?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">伦纳德·冯·比布拉</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="1c1f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">客户端JavaScript的主要用途是动态操作网页。我们可以用DOM节点对象可用的DOM遍历方法和属性来做到这一点。</p><p id="4ac8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于任何给定的节点，添加或更改子元素和兄弟元素都很容易，因为DOM节点对象中内置了执行这些操作的属性。下面是DOM Node对象获取父节点、子节点和兄弟节点或元素的方法。</p><h1 id="6aea" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">appendChild</h1><p id="b5bd" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mh mi mj mk b">appendChild</code>方法让我们将一个子节点附加到一个给定的HTML元素上，作为当前节点的最后一个子节点。如果参数引用了DOM树上的现有节点，那么该节点将从其当前位置分离并附加到其新位置。</p><p id="81a0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它接受一个参数，这是一个DOM节点对象。</p><p id="8d04" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，给定以下HTML中的两个现有节点:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="9fd2" class="mt lf it mk b gy mu mv l mw mx">&lt;div id='foo'&gt;<br/>  foo<br/>&lt;/div&gt;<br/>&lt;div id='bar'&gt;<br/>  bar<br/>&lt;/div&gt;</span></pre><p id="75bd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以将带有ID栏的元素作为子元素附加到带有ID栏的元素，如下所示:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="edb4" class="mt lf it mk b gy mu mv l mw mx">const foo = document.querySelector('#foo');<br/>const bar = document.querySelector('#bar');</span><span id="59ca" class="mt lf it mk b gy my mv l mw mx">foo.appendChild(bar);</span></pre><p id="01bd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦我们运行它，我们应该得到如下结构:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="acbb" class="mt lf it mk b gy mu mv l mw mx">&lt;div id="foo"&gt;<br/>  foo<br/>  &lt;div id="bar"&gt;<br/>    bar<br/>  &lt;/div&gt;<br/>&lt;/div&gt;</span></pre><p id="14f8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还可以用它来创建一个动态创建的元素。例如，如果我们有以下HTML:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="feb7" class="mt lf it mk b gy mu mv l mw mx">&lt;div id='foo'&gt;<br/>  foo<br/>&lt;/div&gt;</span></pre><p id="1b8b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们可以编写以下代码，将一个新的<code class="fe mh mi mj mk b">p</code>元素附加到ID为foo的div:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="981e" class="mt lf it mk b gy mu mv l mw mx">const foo = document.querySelector('#foo');<br/>const bar = document.createElement('p');<br/>bar.textContent = 'bar';</span><span id="1685" class="mt lf it mk b gy my mv l mw mx">foo.appendChild(bar);</span></pre><p id="668b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们使用了<code class="fe mh mi mj mk b">createElement</code>来创建一个新的<code class="fe mh mi mj mk b">p</code>元素。然后我们设置<code class="fe mh mi mj mk b">textContent</code>属性，在<code class="fe mh mi mj mk b">p</code>元素中添加文本。最后，我们可以用<code class="fe mh mi mj mk b">bar</code>作为参数在<code class="fe mh mi mj mk b">foo</code>上<code class="fe mh mi mj mk b">appendChild</code>附加<code class="fe mh mi mj mk b">bar</code>作为<code class="fe mh mi mj mk b">foo</code>的子节点。</p><h1 id="19bc" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">克隆节点</h1><p id="81f9" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mh mi mj mk b">cloneNode</code>方法克隆一个节点对象，也可以克隆它的所有内容。默认情况下，它不会克隆节点的所有内容。</p><p id="7dc0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它有一个参数，这是一个可选参数，表示它是否是一个深度克隆，这意味着所有东西都将被克隆。<code class="fe mh mi mj mk b">true</code>表示进行深度克隆，否则为<code class="fe mh mi mj mk b">false</code>。</p><p id="0f36" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，给定以下HTML:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="c94d" class="mt lf it mk b gy mu mv l mw mx">&lt;div&gt;<br/>  foo<br/>&lt;/div&gt;</span></pre><p id="ba07" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以编写以下JavaScript代码来克隆div，然后将其作为最后一个子元素附加到<code class="fe mh mi mj mk b">body</code>元素:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="a0c9" class="mt lf it mk b gy mu mv l mw mx">const fooDiv = document.querySelector('div');<br/>const fooClone = fooDiv.cloneNode(true);<br/>document.body.appendChild(fooClone);</span></pre><p id="f5bb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将<code class="fe mh mi mj mk b">true</code>传递给<code class="fe mh mi mj mk b">cloneNode</code>方法来克隆一切。然后我们调用<code class="fe mh mi mj mk b">document.body</code>上的<code class="fe mh mi mj mk b">appendChild</code>,将克隆的对象作为参数传入，将其添加为<code class="fe mh mi mj mk b">body</code>的子对象。</p><h1 id="3bc6" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">比较文档位置</h1><p id="eb32" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mh mi mj mk b">compareDocumentPosition</code>方法比较任意文档中给定节点与另一个节点的位置。它接受一个DOM节点对象作为它的参数。</p><p id="8310" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它返回具有下列可能值的位掩码</p><ul class=""><li id="ef13" class="mz na it ki b kj kk kn ko kr nb kv nc kz nd ld ne nf ng nh bi translated"><code class="fe mh mi mj mk b">DOCUMENT_POSITION_DISCONNECTED </code> — 1</li><li id="a474" class="mz na it ki b kj ni kn nj kr nk kv nl kz nm ld ne nf ng nh bi translated"><code class="fe mh mi mj mk b">DOCUMENT_POSITION_PRECEDING</code> — 2</li><li id="2669" class="mz na it ki b kj ni kn nj kr nk kv nl kz nm ld ne nf ng nh bi translated"><code class="fe mh mi mj mk b">DOCUMENT_POSITION_FOLLOWING</code> — 4</li><li id="4d83" class="mz na it ki b kj ni kn nj kr nk kv nl kz nm ld ne nf ng nh bi translated"><code class="fe mh mi mj mk b">DOCUMENT_POSITION_CONTAINS</code> — 8</li><li id="e28a" class="mz na it ki b kj ni kn nj kr nk kv nl kz nm ld ne nf ng nh bi translated"><code class="fe mh mi mj mk b">DOCUMENT_POSITION_CONTAINED_BY</code> — 16</li><li id="e69c" class="mz na it ki b kj ni kn nj kr nk kv nl kz nm ld ne nf ng nh bi translated"><code class="fe mh mi mj mk b">DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC</code> — 32</li></ul><p id="1f4d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，给定以下HTML:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="5095" class="mt lf it mk b gy mu mv l mw mx">&lt;div id='foo'&gt;<br/>  foo<br/>&lt;/div&gt;<br/>&lt;div id='bar'&gt;<br/>  bar<br/>&lt;/div&gt;</span></pre><p id="a9a3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以编写以下JavaScript来比较ID为foo的div和ID为bar的div的位置:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="8cd0" class="mt lf it mk b gy mu mv l mw mx">const foo = document.querySelector('#foo');<br/>const bar = document.querySelector('#bar');</span><span id="b5e0" class="mt lf it mk b gy my mv l mw mx">const relativePos = foo.compareDocumentPosition(bar);<br/>console.log(relativePos);</span></pre><p id="cccd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的代码应该为<code class="fe mh mi mj mk b">relativePos</code>获得us 4，这意味着ID为bar的元素跟随ID为foo的元素。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nn"><img src="../Images/0a79f9172faddcb1944888d6f1d69b27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Ozx8aga0AmFFOAQS"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">由<a class="ae kf" href="https://unsplash.com/@hannahtasker?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">汉娜·塔斯克</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="95d0" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">包含</h1><p id="a273" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">方法检查一个DOM节点是否在给定的节点中。它有一个参数，这是一个节点对象，我们要检查它是否在调用这个方法的对象中。</p><p id="6ea7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果参数中的节点在被调用的节点内，则返回<code class="fe mh mi mj mk b">true</code>，否则返回<code class="fe mh mi mj mk b">false</code>。</p><p id="8a35" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，给定以下HTML:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="feb0" class="mt lf it mk b gy mu mv l mw mx">&lt;div id='foo'&gt;<br/>  foo<br/>&lt;/div&gt;<br/>&lt;div id='bar'&gt;<br/>  bar<br/>&lt;/div&gt;</span></pre><p id="0914" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们可以编写下面的JavaScript来检查ID为bar的div是否在ID为foo的div内部:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="30eb" class="mt lf it mk b gy mu mv l mw mx">const foo = document.querySelector('#foo');<br/>const bar = document.querySelector('#bar');</span><span id="4f59" class="mt lf it mk b gy my mv l mw mx">const fooContainsBar = foo.contains(bar);<br/>console.log(fooContainsBar);</span></pre><p id="9344" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当然，<code class="fe mh mi mj mk b">fooContainsBar</code>应该是<code class="fe mh mi mj mk b">false</code>，因为ID为foo的div不在ID为bar的div内。</p><p id="77b3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一方面，如果我们用下面的HTML代替:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="fc34" class="mt lf it mk b gy mu mv l mw mx">&lt;div id='foo'&gt;<br/>  foo<br/>  &lt;div id='bar'&gt;<br/>    bar<br/>  &lt;/div&gt;</span><span id="6e53" class="mt lf it mk b gy my mv l mw mx">&lt;/div&gt;</span></pre><p id="944a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后使用与第一个例子相同的JavaScript代码，<code class="fe mh mi mj mk b">fooContainsBar</code>应该是<code class="fe mh mi mj mk b">true</code>，因为ID为foo的div在ID为bar的div内部。</p><h1 id="7322" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">getRootNode</h1><p id="d33c" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mh mi mj mk b">getRootNode</code>方法返回节点对象的根，如果影子根可用的话，还可以包含影子根。</p><p id="cacf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它为具有以下属性的对象提供一个可选参数:</p><ul class=""><li id="468d" class="mz na it ki b kj kk kn ko kr nb kv nc kz nd ld ne nf ng nh bi translated"><code class="fe mh mi mj mk b">composed</code> —一个布尔值，表示应该包括阴影根。默认为<code class="fe mh mi mj mk b">false</code></li></ul><p id="e067" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它返回的节点要么返回给定节点的根元素，要么返回影子DOM中元素的影子根。</p><p id="8220" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有以下HTML:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="564f" class="mt lf it mk b gy mu mv l mw mx">&lt;div id='foo'&gt;<br/>  foo<br/>&lt;/div&gt;</span></pre><p id="fdb4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么我们可以如下调用<code class="fe mh mi mj mk b">getRootNode</code>方法:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="3e2f" class="mt lf it mk b gy mu mv l mw mx">const foo = document.querySelector('#foo');</span><span id="3d3f" class="mt lf it mk b gy my mv l mw mx">const root = foo.getRootNode();<br/>console.log(root);</span></pre><p id="f421" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们应该将HTML文档作为根节点，因为它不在影子DOM中。</p><p id="1edd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">该根将是Web组件的影子根。例如，如果我们有以下web组件:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="a283" class="mt lf it mk b gy mu mv l mw mx">customElements.define('custom-p',<br/>  class extends HTMLElement {<br/>    constructor() {<br/>      super();</span><span id="25ff" class="mt lf it mk b gy my mv l mw mx">      const pElem = document.createElement('p');<br/>      pElem.id = 'p-element';<br/>      pElem.textContent = 'shadow p'</span><span id="c9f6" class="mt lf it mk b gy my mv l mw mx">      const shadowRoot = this.attachShadow({<br/>        mode: 'open'<br/>      });<br/>      shadowRoot.appendChild(pElem);<br/>    }<br/>  }<br/>);</span></pre><p id="e7b1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们在HTML代码中添加了Web组件:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="18b3" class="mt lf it mk b gy mu mv l mw mx">&lt;custom-p&gt;&lt;/custom-p&gt;</span></pre><p id="56d8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们可以通过编写以下代码获得ID为<code class="fe mh mi mj mk b">p-element</code>的元素的根节点:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="8337" class="mt lf it mk b gy mu mv l mw mx">const pElement = document.querySelector('custom-p').shadowRoot.querySelector('#p-element');<br/>const rootNode = pElement.getRootNode();<br/>console.log(rootNode);</span></pre><p id="0603" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">首先，我们获得自定义元素，然后我们获得<code class="fe mh mi mj mk b">shadowRoot</code>属性，该属性允许我们访问我们的<code class="fe mh mi mj mk b">custom-p</code> web组件的影子DOM。然后我们就可以得到ID为<code class="fe mh mi mj mk b">p-element</code>的<code class="fe mh mi mj mk b">p</code>元素，带有阴影根。</p><p id="597c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">之后，我们通过调用代表ID为<code class="fe mh mi mj mk b">p-element</code>的<code class="fe mh mi mj mk b">p</code>元素的<code class="fe mh mi mj mk b">pElement</code>上的<code class="fe mh mi mj mk b">getRootNode</code>来获得它的根节点。</p><p id="a2c5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">console.log</code>应该能让我们得到Web组件的影子根。</p><h1 id="8676" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="5c50" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">使用这些DOM遍历方法，我们可以在简单的情况下随意设置节点。此外，还有一些方法来检查一个元素是否是另一个元素的子元素，以及获取给定元素的根节点。</p></div></div>    
</body>
</html>