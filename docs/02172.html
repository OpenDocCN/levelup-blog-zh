<html>
<head>
<title>Getting Started With Node.js and WebSockets</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js和WebSockets入门</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/getting-started-with-node-js-and-websockets-f22dd0452105?source=collection_archive---------3-----------------------#2020-02-24">https://levelup.gitconnected.com/getting-started-with-node-js-and-websockets-f22dd0452105?source=collection_archive---------3-----------------------#2020-02-24</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0e4a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">让我们做一个聊天游乐场</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/242cf833ec35f80ecc8b262fa6327791.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QT7AUtS7ybyezoFFT3UeGw.png"/></div></div></figure><p id="b244" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">WebSockets是http的弟弟妹妹。它们让你保持一个<em class="lq">打开的</em>连接，以便实时更新。让我们创建一个简单的聊天室，只显示来自用户的消息。长话短说，除了实现之外，我就不多说了，所以如果你需要背景信息<a class="ae lr" href="https://pusher.com/websockets" rel="noopener ugc nofollow" target="_blank">看看这个解释</a>。</p><h1 id="1bcc" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">概观</h1><p id="3498" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">我们打算做一个游乐场，让2+标签在一个小聊天室相互交谈。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mp"><img src="../Images/fa39c87371f760a58d407b9a91222222.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X22MoxSviKY43_ylfyB7hQ.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk translated">我们的两个标签实时地相互交流</figcaption></figure><p id="14b3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将使用两个主文件:<code class="fe mu mv mw mx b">server.js</code>和<code class="fe mu mv mw mx b">index.html</code>。我们将使用一个Express服务器来提供我们的<code class="fe mu mv mw mx b">index.html</code>文件，并且我们将使用<code class="fe mu mv mw mx b">w<a class="ae lr" href="https://www.npmjs.com/package/ws" rel="noopener ugc nofollow" target="_blank">s</a></code> <a class="ae lr" href="https://www.npmjs.com/package/ws" rel="noopener ugc nofollow" target="_blank">库</a>作为我们的第二个WebSocket服务器。此外，我们将在前端使用普通的JS，因为WebSockets在现代浏览器中可用；React之类的框架与之无关。</p><h2 id="2c65" class="my lt it bd lu mz na dn ly nb nc dp mc ld nd ne me lh nf ng mg ll nh ni mi nj bi translated">装置</h2><p id="b4d0" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">在终端中，运行:</p><pre class="kj kk kl km gt nk mx nl nm aw nn bi"><span id="d5c0" class="my lt it mx b gy no np l nq nr">mk websockets<br/>cd websockets<br/>&gt; server.js <br/>&gt; index.html<br/>npm init -y<br/>npm i express ws nodemon</span></pre><p id="37a9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后将<code class="fe mu mv mw mx b"> “start”: “nodemon server.js”</code>添加到您的<code class="fe mu mv mw mx b">package.json</code>脚本中。</p><h1 id="31d2" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">创建我们的主服务器</h1><p id="6b54" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">它所做的只是主持我们的<code class="fe mu mv mw mx b">index.html</code>:</p><pre class="kj kk kl km gt nk mx nl nm aw nn bi"><span id="b078" class="my lt it mx b gy no np l nq nr"><em class="lq">const</em> <strong class="mx iu">express</strong> = require('<em class="lq">express</em>');<br/><em class="lq">const</em> <strong class="mx iu">path</strong> = require('<em class="lq">path</em>');<br/><em class="lq">const</em> <strong class="mx iu">app</strong> = <strong class="mx iu">express</strong>();</span><span id="4457" class="my lt it mx b gy ns np l nq nr"><strong class="mx iu">app</strong>.get('/', (<strong class="mx iu">req</strong>, <strong class="mx iu">res</strong>) =&gt; {<br/>  <strong class="mx iu">res</strong>.sendFile(<strong class="mx iu">path</strong>.join(<strong class="mx iu">__dirname</strong>, '<em class="lq">index.html</em>'));<br/>});</span><span id="151a" class="my lt it mx b gy ns np l nq nr"><em class="lq">const</em> <strong class="mx iu">port</strong> = 8765;<br/><strong class="mx iu">app</strong>.listen(<strong class="mx iu">port</strong>, () =&gt; {<br/> <strong class="mx iu"> console</strong>.log(`<em class="lq">listening </em><a class="ae lr" href="http://localhost:${port}`)" rel="noopener ugc nofollow" target="_blank"><em class="lq">http://localhost:</em>${<strong class="mx iu">port</strong>}</a><a class="ae lr" href="http://localhost:${port}`)" rel="noopener ugc nofollow" target="_blank">`)</a>;<br/>});</span></pre><p id="21be" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">请记住，我们最终的WebSockets服务器将与我们的主要服务器<em class="lq">不同</em>。如果这是一个真实的项目，我们的API、路线和资产都将放在这个服务器中。我们将很快到达套接字服务器，但是让我们开始我们的<code class="fe mu mv mw mx b">index.html</code>文件:</p><pre class="kj kk kl km gt nk mx nl nm aw nn bi"><span id="1716" class="my lt it mx b gy no np l nq nr">&lt;!DOCTYPE <strong class="mx iu">html</strong>&gt;<br/>&lt;<strong class="mx iu">html</strong> lang="<em class="lq">en</em>"&gt;<br/>  &lt;<strong class="mx iu">title</strong>&gt;Websocket Practice&lt;/<strong class="mx iu">title</strong>&gt;<br/>&lt;/<strong class="mx iu">head</strong>&gt;<br/>&lt;<strong class="mx iu">body</strong>&gt;<br/>  &lt;<strong class="mx iu">input</strong> id="<em class="lq">name</em>"/&gt;<br/>  &lt;<strong class="mx iu">textarea</strong> id="<em class="lq">message</em>" &gt;&lt;/<strong class="mx iu">textarea</strong>&gt;<br/>  &lt;<strong class="mx iu">button</strong>&gt;Send&lt;/<strong class="mx iu">button</strong>&gt;<br/>  &lt;<strong class="mx iu">div</strong> id='<em class="lq">messages</em>'&gt;&lt;/<strong class="mx iu">div</strong>&gt;<br/>&lt;/<strong class="mx iu">body</strong>&gt;<br/>&lt;/<strong class="mx iu">html</strong>&gt;</span></pre><p id="3963" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">稍后我们将添加一个<code class="fe mu mv mw mx b">&lt;script&gt;</code>标签，但是现在我们可以做<code class="fe mu mv mw mx b">npm start</code>并看到我们的页面已经启动并运行了。</p><h1 id="2de0" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">创建WebSocket服务器</h1><p id="bece" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">首先，让我们处理我们的前端客户端建立连接。回到我们的<code class="fe mu mv mw mx b">server.js</code>文件，把这个扔进去:</p><pre class="kj kk kl km gt nk mx nl nm aw nn bi"><span id="a001" class="my lt it mx b gy no np l nq nr"><em class="lq">const</em> <strong class="mx iu">express</strong> = <strong class="mx iu">require</strong>('<em class="lq">express</em>');<br/><em class="lq">const</em> <strong class="mx iu">path</strong> = require('<em class="lq">path</em>');<br/><em class="lq">const</em> <strong class="mx iu">WebSocket</strong> = <strong class="mx iu">require</strong>('<em class="lq">ws</em>'); // new<br/><em class="lq">const</em> <strong class="mx iu">app</strong> = <strong class="mx iu">express</strong>();</span><span id="9e85" class="my lt it mx b gy ns np l nq nr"><strong class="mx iu"><em class="lq">// express code</em></strong><em class="lq"> </em></span><span id="e322" class="my lt it mx b gy ns np l nq nr"><em class="lq">const</em> <strong class="mx iu">socketServer</strong> = <em class="lq">new</em> <strong class="mx iu">WebSocket</strong>.Server({port: 3030});</span><span id="85e0" class="my lt it mx b gy ns np l nq nr"><strong class="mx iu">socketServer</strong>.on('connection', (<strong class="mx iu">socketClient</strong>) =&gt; {<br/>  <strong class="mx iu">console</strong>.log('<em class="lq">connected</em>');<br/>  <strong class="mx iu">console</strong>.log('<em class="lq">client Set length: </em>', <strong class="mx iu">socketServer</strong>.clients.size);</span><span id="fa94" class="my lt it mx b gy ns np l nq nr"><strong class="mx iu">  socketClient</strong>.on('<em class="lq">close</em>', (<strong class="mx iu">socketClient</strong>) =&gt; {<br/>    <strong class="mx iu">console</strong>.log('<em class="lq">closed</em>');<br/>    <strong class="mx iu">console</strong>.log('<em class="lq">Number of clients:</em> ', <strong class="mx iu">socketServer</strong>.clients.size);<br/>  });<br/>});</span></pre><p id="f15d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们正在做的是在端口<code class="fe mu mv mw mx b">3030</code>上设置我们的<em class="lq"> </em> WebSocket <em class="lq"> </em>服务器。当一个前端客户端访问这个服务器并打开一个稳定的连接时，触发<code class="fe mu mv mw mx b">connection</code>事件。目前，我们的WebSocket服务器所做的只是记录“连接”，然后告诉我们当前有多少客户端对象连接到它。另外，注意，<code class="fe mu mv mw mx b">clients</code>属性是一个<a class="ae lr" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set" rel="noopener ugc nofollow" target="_blank">集合</a>，<em class="lq">不是</em>数组。</p><h2 id="39f4" class="my lt it bd lu mz na dn ly nb nc dp mc ld nd ne me lh nf ng mg ll nh ni mi nj bi translated">关闭连接</h2><p id="8717" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">我们还将在每次客户端连接关闭时记录日志。这通常发生在浏览器关闭或刷新时。这里需要注意的重要一点是，客户机方法嵌套在初始服务器连接事件的内部。WebSockets是开放的连接，因此处理客户端的方法(即连接)应该是嵌套的。</p><h1 id="1d9a" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">从客户端连接</h1><p id="c9e0" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">设置好套接字服务器后，我们需要构建我们的客户机。由于这个项目非常简单，我将把JS放在我们的<code class="fe mu mv mw mx b">index.html</code>文件的脚本标签中:</p><pre class="kj kk kl km gt nk mx nl nm aw nn bi"><span id="f25c" class="my lt it mx b gy no np l nq nr">...<br/>&lt;<strong class="mx iu">div</strong> id='<em class="lq">messages</em>'&gt;&lt;/<strong class="mx iu">div</strong>&gt;<br/>&lt;<strong class="mx iu">script</strong>&gt;</span><span id="0176" class="my lt it mx b gy ns np l nq nr"><em class="lq">const</em> <strong class="mx iu">ws</strong> = <em class="lq">new</em> <strong class="mx iu">WebSocket</strong>('<em class="lq">ws://localhost:3030</em>');<br/><strong class="mx iu">ws</strong>.onopen = () =&gt; { <br/>  <strong class="mx iu">console</strong>.log('<em class="lq">Now connected</em>'); <br/>};</span><span id="ce11" class="my lt it mx b gy ns np l nq nr">&lt;/<strong class="mx iu">script</strong>&gt;<br/>&lt;/<strong class="mx iu">body</strong>&gt;<br/>...</span></pre><p id="4f21" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe mu mv mw mx b">new WebSocket(url)</code>部分正在启动与我们的socket服务器的连接。最需要注意的是，我们的url使用的是<code class="fe mu mv mw mx b">ws</code>协议，而不是<code class="fe mu mv mw mx b">http</code>(在现实世界中，总是使用<a class="ae lr" href="https://www.freecodecamp.org/news/how-to-secure-your-websocket-connections-d0be0996c556/" rel="noopener ugc nofollow" target="_blank">安全的</a> <code class="fe mu mv mw mx b"><a class="ae lr" href="https://www.freecodecamp.org/news/how-to-secure-your-websocket-connections-d0be0996c556/" rel="noopener ugc nofollow" target="_blank">wss</a></code>)。通过这个连接，我们将一个方法分配给它的<code class="fe mu mv mw mx b">onopen</code>方法，当一个连接成功打开时，这个方法被触发。</p><h2 id="0f67" class="my lt it bd lu mz na dn ly nb nc dp mc ld nd ne me lh nf ng mg ll nh ni mi nj bi translated">测试它</h2><p id="44c0" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">让我们运行<code class="fe mu mv mw mx b">npm start</code>并在两个选项卡中打开<a class="ae lr" href="http://localhost:8765/" rel="noopener ugc nofollow" target="_blank"> http://localhost:8765 </a>。在我们的节点控制台中，我们会看到它将客户端数量记录为<code class="fe mu mv mw mx b">2</code>。尝试刷新选项卡。客户端将被关闭并重新打开，但不会再添加任何内容。添加更多客户端的唯一方法是在更多选项卡中访问url。</p><h1 id="2355" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">从服务器获取和发送消息</h1><p id="89a1" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">这里的想法是，每个前端客户端将它们的消息发送到服务器，然后服务器将消息发送回所有客户端。把它想象成一个中继系统。我们还将把这些消息“保存”到一个数组中，这样任何新连接的客户端都可以看到以前发送的消息。</p><p id="a2d4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><strong class="kw iu">我们只发送连接事件的整个消息数组，否则我们只发送单个消息:</strong></p><pre class="kj kk kl km gt nk mx nl nm aw nn bi"><span id="51da" class="my lt it mx b gy no np l nq nr">// ...<br/><em class="lq">const</em> <strong class="mx iu">socketServer</strong> = <em class="lq">new</em> <strong class="mx iu">WebSocket</strong>.Server({port: 3030});</span><span id="9857" class="my lt it mx b gy ns np l nq nr">const <strong class="mx iu">messages</strong> = ['Start Chatting!'];</span><span id="00a5" class="my lt it mx b gy ns np l nq nr"><strong class="mx iu">socketServer</strong>.on('connection', (<strong class="mx iu">socketClient</strong>) =&gt; {<br/> <strong class="mx iu"> console</strong>.log('<em class="lq">connected</em>');<br/><strong class="mx iu">  console</strong>.log('<em class="lq">Number of clients: </em>', <strong class="mx iu">socketServer</strong>.clients.size);<br/><strong class="mx iu">  socketClient</strong>.send(<strong class="mx iu">JSON</strong>.stringify(<strong class="mx iu">messages</strong>));<br/>  <br/><strong class="mx iu">  socketClient</strong>.on('<em class="lq">message</em>', (<strong class="mx iu">message</strong>) =&gt; {<br/><strong class="mx iu">    messages</strong>.push(<strong class="mx iu">message</strong>);<br/><strong class="mx iu">    socketServer</strong>.clients.forEach((<strong class="mx iu">client</strong>) =&gt; {<br/>      <em class="lq">if</em> (<strong class="mx iu">client</strong>.readyState === <strong class="mx iu">WebSocket</strong>.OPEN) {<br/>        <strong class="mx iu">client</strong>.send(<strong class="mx iu">JSON.</strong>stringify([<strong class="mx iu">message</strong>]));<br/>      }<br/>    });<br/>  });</span><span id="6bb4" class="my lt it mx b gy ns np l nq nr"><strong class="mx iu">  socketClient</strong>.on('<em class="lq">close</em>', (<strong class="mx iu">socketClient</strong>) =&gt; {<br/>// ...</span></pre><p id="3629" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这里的主要内容是我们在<code class="fe mu mv mw mx b">socketClient</code>上收听的新事件<code class="fe mu mv mw mx b">message</code>。每当服务器<em class="lq">收到来自客户端的消息</em>时，该事件就会被触发。如前所述，我们希望从一个客户端到达服务器的每条消息都被发送到所有客户端。这就是为什么我们要遍历<code class="fe mu mv mw mx b">socketServer.clients</code>集合，并使用<code class="fe mu mv mw mx b">send</code>方法向每个集合发送消息。我们还确保连接也是开放的。</p><h1 id="9edc" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">从客户端获取和发送消息</h1><p id="6a8e" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">用这个编辑<code class="fe mu mv mw mx b">index.html</code>:</p><pre class="kj kk kl km gt nk mx nl nm aw nn bi"><span id="1ccc" class="my lt it mx b gy no np l nq nr">...<br/>&lt;<strong class="mx iu">button</strong> onClick="fire()"&gt;Send&lt;/<strong class="mx iu">button</strong>&gt;<br/>&lt;<strong class="mx iu">div</strong> id="<em class="lq">messages"</em>&gt;&lt;/<strong class="mx iu">div</strong>&gt;</span><span id="b171" class="my lt it mx b gy ns np l nq nr">&lt;<strong class="mx iu">script</strong>&gt;<br/><em class="lq">const</em> <strong class="mx iu">getElement</strong> = (<strong class="mx iu">id</strong>) =&gt; <strong class="mx iu">document</strong>.getElementById(<strong class="mx iu">id</strong>);</span><span id="48f4" class="my lt it mx b gy ns np l nq nr"><em class="lq">const</em> <strong class="mx iu">addMessage</strong> = (<strong class="mx iu">message</strong>) =&gt; {<br/>  const <strong class="mx iu">pTag</strong> = <strong class="mx iu">document</strong>.createElement('<em class="lq">p</em>');<br/>  <strong class="mx iu">pTag.</strong>appendChild(<strong class="mx iu">document</strong>.createTextNode(<strong class="mx iu">message</strong>));<br/>  <strong class="mx iu">getElement</strong>('<em class="lq">messages</em>').appendChild(<strong class="mx iu">pTag</strong>);<br/>};</span><span id="adc5" class="my lt it mx b gy ns np l nq nr">const <strong class="mx iu">ws</strong> = new <strong class="mx iu">WebSocket</strong>('<em class="lq">ws://localhost:3030</em>');</span><span id="0e2b" class="my lt it mx b gy ns np l nq nr"><strong class="mx iu">ws</strong>.onopen = () =&gt; { <br/>  <strong class="mx iu">console</strong>.log(<em class="lq">'Now connected</em>'); <br/>};</span><span id="483e" class="my lt it mx b gy ns np l nq nr"><strong class="mx iu">ws</strong>.onmessage = (<strong class="mx iu">event</strong>) =&gt; {<br/>  <em class="lq">const</em> <strong class="mx iu">messages</strong> = <strong class="mx iu">JSON</strong>.parse(<strong class="mx iu">event</strong>.data);<br/>  <strong class="mx iu">messages</strong>.forEach(<strong class="mx iu">addMessage</strong>);<br/>};</span><span id="7f21" class="my lt it mx b gy ns np l nq nr">const <strong class="mx iu">fire</strong> = () =&gt; {<br/>  const <strong class="mx iu">username</strong> = <strong class="mx iu">getElement</strong>('name').value || '<em class="lq">???</em>'<br/> <strong class="mx iu"> ws</strong>.send(`${<strong class="mx iu">username</strong>}: ${<strong class="mx iu">getElement</strong>('message').value}`);<br/>  <strong class="mx iu">getElement</strong>('message').value = '';<br/>};</span><span id="7e5b" class="my lt it mx b gy ns np l nq nr">&lt;/<strong class="mx iu">script</strong>&gt;</span></pre><p id="d3a8" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">前两个新方法是帮助器:<code class="fe mu mv mw mx b">getElement</code>是document.getElementById的别名，<code class="fe mu mv mw mx b">addMessage</code>处理向<code class="fe mu mv mw mx b">&lt;p&gt;</code>标签添加消息。关键的方法是<code class="fe mu mv mw mx b">onmessage</code>和<code class="fe mu mv mw mx b">fire</code>。</p><h2 id="71e5" class="my lt it bd lu mz na dn ly nb nc dp mc ld nd ne me lh nf ng mg ll nh ni mi nj bi translated">onmessage</h2><p id="8545" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">这是WebSocket函数，当我们的客户端<em class="lq">从服务器接收到</em>一条新消息时就会触发这个函数。<strong class="kw iu">这就是我们的页面自动更新的方式</strong>，它是我们的监听器。我们所做的就是深入到<code class="fe mu mv mw mx b">event</code>对象和JSON解析数据。现在，在我们的例子中，我们在一个数组中发送数据，这就是我们使用<code class="fe mu mv mw mx b">forEach</code>的原因，但是你不必像那样发送数据。</p><h2 id="9619" class="my lt it bd lu mz na dn ly nb nc dp mc ld nd ne me lh nf ng mg ll nh ni mi nj bi translated">火</h2><p id="1698" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">神奇之处在第二行，<code class="fe mu mv mw mx b">ws.send(string)</code>，这是将我们的字符串数据发送到服务器的套接字方法。其他部分只是从表单中获取值并清理我们的输入(别忘了给按钮添加这个方法)。</p><h1 id="c976" class="ls lt it bd lu lv lw lx ly lz ma mb mc jz md ka me kc mf kd mg kf mh kg mi mj bi translated">开始玩吧！</h1><p id="e1f7" class="pw-post-body-paragraph ku kv it kw b kx mk ju kz la ml jx lc ld mm lf lg lh mn lj lk ll mo ln lo lp im bi translated">你完了！你已经有足够的代码来真正开始学习了。添加日志，玩参数，<a class="ae lr" href="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API" rel="noopener ugc nofollow" target="_blank">读一些文档</a>。开始探索，玩得开心！</p><p id="2cdf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">大家编码快乐，</p><p id="98f0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">麦克风</p></div></div>    
</body>
</html>