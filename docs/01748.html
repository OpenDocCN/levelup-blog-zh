<html>
<head>
<title>Merging Declarations in TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在TypeScript中合并声明</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/merging-declarations-in-typescript-58e6839cbed?source=collection_archive---------6-----------------------#2020-01-27">https://levelup.gitconnected.com/merging-declarations-in-typescript-58e6839cbed?source=collection_archive---------6-----------------------#2020-01-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/584e7147f5cad73f322c5aa9b1867988.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*77xXnTgibHePnO-M"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">米哈伊尔·瓦西里耶夫在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="e9cf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用TypeScript，我们可以声明许多普通JavaScript中不存在的实体，如接口、枚举和类型别名。有时，这些类型必须合并成一个，就像当我们试图从多个类或接口派生一个新类时。这意味着有将它们合并在一起的规则。声明合并的过程是来自不同来源的多个成员的合并，这些成员具有重叠的成员名称或类型。</p><h1 id="fbb5" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">合并接口的基本规则</h1><p id="a228" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">合并接口是声明合并最简单也是最常见的操作类型。最基本的情况是2个接口没有重叠的成员。在这种情况下，它们只是机械地融合在一起。例如，如果我们有2个<code class="fe mh mi mj mk b">Person</code>接口，如下面的代码所示:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="6bd1" class="mt lf it mk b gy mu mv l mw mx">interface Person {<br/>  name: string;<br/>}</span><span id="bfc5" class="mt lf it mk b gy my mv l mw mx">interface Person {<br/>  age: number;<br/>}</span></pre><p id="65a3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后当我们声明一个类型为<code class="fe mh mi mj mk b">Person</code>的变量时，它们将会合并成一个。例如，我们可以这样写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="cf45" class="mt lf it mk b gy mu mv l mw mx">let person: Person = {<br/>  name: 'Jane',<br/>  age: 20<br/>}</span></pre><p id="9c19" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，TypeScript将接受这些代码，并编译和运行这些代码。</p><p id="ba4e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果有任何非函数成员的重叠，那么它们必须是唯一的。否则，它们必须具有相同的类型。例如，如果我们有:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="7841" class="mt lf it mk b gy mu mv l mw mx">interface Person {<br/>  name: string;<br/>  age: string;<br/>}</span><span id="604c" class="mt lf it mk b gy my mv l mw mx">interface Person {<br/>  age: number;<br/>}</span></pre><p id="4688" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们得到以下错误:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="5204" class="mt lf it mk b gy mu mv l mw mx">Subsequent property declarations must have the same type.  Property 'age' must be of type 'string', but here has type 'number'.(2717)</span><span id="2a93" class="mt lf it mk b gy my mv l mw mx">input.ts(3, 5): 'age' was also declared here.</span></pre><p id="297a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，当两个接口合并时，如果第一个接口与第二个接口有重叠的成员，则第二个接口中的任何内容都将覆盖第一个接口的成员。对于函数成员，它们只是作为同一个函数的重载组合在一起。例如，如果我们有以下接口声明:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="896e" class="mt lf it mk b gy mu mv l mw mx">interface Animal { };<br/>interface Sheep { };<br/>interface Dog { };<br/>interface Cat { };</span><span id="552e" class="mt lf it mk b gy my mv l mw mx">interface Eater {<br/>  eat(animal: Animal): Animal;<br/>}</span><span id="12ae" class="mt lf it mk b gy my mv l mw mx">interface Eater {<br/>  eat(animal: Sheep): Sheep;<br/>}</span><span id="7dfd" class="mt lf it mk b gy my mv l mw mx">interface Eater {<br/>  eat(animal: Dog): Dog;<br/>  eat(animal: Cat): Cat;<br/>}</span></pre><p id="a3ae" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么我们得到的<code class="fe mh mi mj mk b">Eater</code>界面，就会是:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="71b6" class="mt lf it mk b gy mu mv l mw mx">interface Eater {  <br/>  eat(animal: Dog): Dog;<br/>  eat(animal: Cat): Cat;<br/>  eat(animal: Sheep): Sheep;<br/>  eat(animal: Animal): Animal;<br/>}</span></pre><p id="20e5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">每个组的元素保持相同的顺序，但是在合并的接口中，在后面的接口中的功能组首先排序。唯一的例外是，当函数成员的签名由单个字符串组成时，它将被移到顶部。例如，如果我们有:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="fafa" class="mt lf it mk b gy mu mv l mw mx">interface Animal { };<br/>interface Sheep { };<br/>interface Dog { };<br/>interface Cat { };</span><span id="b3f6" class="mt lf it mk b gy my mv l mw mx">interface Eater {<br/>  eat(animal: 'Animal'): Animal;<br/>}</span><span id="fa39" class="mt lf it mk b gy my mv l mw mx">interface Eater {<br/>  eat(animal: Sheep): Sheep;<br/>}</span><span id="b5ec" class="mt lf it mk b gy my mv l mw mx">interface Eater {<br/>  eat(animal: Dog): Dog;<br/>  eat(animal: Cat): Cat;<br/>}</span></pre><p id="47ed" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么合并后的<code class="fe mh mi mj mk b">Eater</code>接口将是:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="49de" class="mt lf it mk b gy mu mv l mw mx">interface Eater {  <br/>  eat(animal: 'Animal'): Animal;<br/>  eat(animal: Dog): Dog;<br/>  eat(animal: Cat): Cat;<br/>  eat(animal: Sheep): Sheep;<br/>}</span></pre><h1 id="4f07" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">名称空间</h1><p id="a61b" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">相同名称的命名空间会将它们的成员合并在一起。所有导出的接口和类都合并到一个名称空间中。例如，如果我们有以下名称空间:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="1afa" class="mt lf it mk b gy mu mv l mw mx">namespace Animals {<br/>  export class Cat { }<br/>}</span><span id="1a69" class="mt lf it mk b gy my mv l mw mx">namespace Animals {<br/>  export interface Mammal {<br/>      name: string;        <br/>  }<br/>  export class Dog { }<br/>}</span></pre><p id="fbe8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么合并后的名称空间将是:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="2f7d" class="mt lf it mk b gy mu mv l mw mx">namespace Animals {<br/>  export interface Mammal {<br/>      name: string;        <br/>  }</span><span id="c1af" class="mt lf it mk b gy my mv l mw mx">  export class Cat { }<br/>  export class Dog { }<br/>}</span></pre><p id="cbe2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一方面，非导出成员只在它们自己的未合并命名空间中可见。例如，如果我们有:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="fb55" class="mt lf it mk b gy mu mv l mw mx">namespace Animal {<br/>  export class Cat { }<br/>  export const getAnimal = () =&gt; {<br/>    return animal;<br/>  }<br/>}</span><span id="730e" class="mt lf it mk b gy my mv l mw mx">namespace Animal {<br/>  let animal = {};<br/>  export interface Mammal {<br/>    name: string;        <br/>  }<br/>  export class Dog { }<br/>}</span></pre><p id="68ad" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们得到以下错误消息:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="cc80" class="mt lf it mk b gy mu mv l mw mx">Cannot find name 'animal'. Did you mean 'Animal'?(2552)</span></pre><p id="c11c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为<code class="fe mh mi mj mk b">animal</code>变量没有被导出。</p><p id="3075" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们不能有两个同名的命名空间成员，因为我们会有重复的声明，这是不允许的。例如，如果我们有:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="7f60" class="mt lf it mk b gy mu mv l mw mx">namespace Animal {<br/>    export class Cat { }<br/>    export let animal = {};<br/>    export const getAnimal = () =&gt; {<br/>        return animal;<br/>    }<br/>}</span><span id="0c61" class="mt lf it mk b gy my mv l mw mx">namespace Animal {<br/>    export let animal = {};<br/>    export interface Mammal {<br/>      name: string;        <br/>    }<br/>    export class Dog { }<br/>}</span></pre><p id="68ec" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们得到错误:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="312c" class="mt lf it mk b gy mu mv l mw mx">Cannot redeclare block-scoped variable 'animal'.(2451)</span></pre><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/fdfdbd02c66ac8b07630947938f12e77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2M-6ZwW_0MtStQIi"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@neonbrand?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> NeONBRAND </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="915d" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">将命名空间与类合并</h1><p id="2800" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">将名称空间与类合并的规则与合并任何其他名称空间成员的规则相同。它们必须被导出，以便我们进行合并。我们可以编写如下代码，通过从外部类引用命名空间内的类来定义内部类:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="f4d5" class="mt lf it mk b gy mu mv l mw mx">class Person {<br/>    label: Person.PersonName;    <br/>}</span><span id="f753" class="mt lf it mk b gy my mv l mw mx">namespace Person {<br/>    export class PersonName { }<br/>}</span></pre><p id="4cd6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们也可以从与名称空间同名的函数中引用名称空间中的成员。例如，我们可以编写以下代码:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="8b82" class="mt lf it mk b gy mu mv l mw mx">function buildName(middleName: string): string {<br/>    return `${buildName.firstName} ${middleName} ${buildName.lastName}`;<br/>}</span><span id="cb9c" class="mt lf it mk b gy my mv l mw mx">namespace buildName {<br/>    export let firstName = "Jane";<br/>    export let lastName = "Smith";<br/>}</span><span id="bf0f" class="mt lf it mk b gy my mv l mw mx">buildName('Mary');</span></pre><p id="2249" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">只要导出成员，我们就可以在<code class="fe mh mi mj mk b">buildName</code>函数中访问<code class="fe mh mi mj mk b">buildName</code>名称空间的成员。同样，我们可以从与枚举同名的名称空间中引用枚举成员。例如，我们可以这样写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="4fe5" class="mt lf it mk b gy mu mv l mw mx">enum Fruit {<br/>  Orange = 1,<br/>  Apple = 2,<br/>  Banana = 4<br/>}</span><span id="8379" class="mt lf it mk b gy my mv l mw mx">namespace Fruit {<br/>  export const mixFruit = (fruit: string) =&gt; {<br/>    if (fruit == "Orange and Apple") {<br/>      return Fruit.Orange + Fruit.Apple;<br/>    }<br/>    else if (fruit == "Apple and Banana") {<br/>      return Fruit.Apple + Fruit.Banana<br/>    }<br/>    return 0;<br/>  }<br/>}</span></pre><p id="d598" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我们所见，我们可以在<code class="fe mh mi mj mk b">mixFruit</code>函数内的<code class="fe mh mi mj mk b">Fruit</code>名称空间中访问<code class="fe mh mi mj mk b">Fruit</code>枚举的成员。</p><h1 id="32ee" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">不允许的合并</h1><p id="b1d9" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">目前，我们可以将类与其他类或变量合并。</p><h1 id="1cdd" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">模块扩充</h1><p id="3885" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以使用<code class="fe mh mi mj mk b">declare</code>关键字来声明一个模块的成员具有TypeScript编译器不知道的属性。例如，我们可以这样写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="5651" class="mt lf it mk b gy mu mv l mw mx">// fruit.ts<br/>export class Fruit&lt;T&gt; {<br/>  // ...<br/>}</span><span id="63d2" class="mt lf it mk b gy my mv l mw mx">// setColor.ts</span><span id="3024" class="mt lf it mk b gy my mv l mw mx">import { Fruit } from "./fruit";<br/>declare module "./fruit" {<br/>  interface Fruit&lt;T&gt; {<br/>    setColor(f: (x: string) =&gt; string): Fruit;<br/>  }<br/>}<br/>Fruit.prototype.setColor = function (f) {<br/>  // ...<br/>}</span></pre><p id="b360" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们使用了<code class="fe mh mi mj mk b">declare module</code>关键字来声明<code class="fe mh mi mj mk b">Fruit</code>类中TypeScript编译器看不到的项目。它让我们操作那些已定义但TypeScript编译器不能发现的东西。</p><p id="795c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以使用上面的方法来修补现有的声明。它不适用于新的顶级声明。此外，默认导出不能增加，因为它没有名称。</p><h1 id="67e3" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">全球扩增</h1><p id="aa16" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们也可以在模块内部的全局范围内添加声明。例如，我们可以编写类似下面的代码:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="4a0e" class="mt lf it mk b gy mu mv l mw mx">// fruit.ts<br/>export class Fruit {<br/> <br/>}</span><span id="078d" class="mt lf it mk b gy my mv l mw mx">declare global {<br/>  interface Array&lt;T&gt; {<br/>    toFruitArray(): Fruit[];<br/>  }<br/>}</span><span id="2859" class="mt lf it mk b gy my mv l mw mx">Array.prototype.toFruitArray = function () {<br/>  return this.map(a =&gt; &lt;Fruit&gt;{ ... });<br/>}</span></pre><p id="68ba" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们让TypeScript编译器知道全局<code class="fe mh mi mj mk b">Array</code>对象，然后向其原型添加一个<code class="fe mh mi mj mk b">toFruitArray</code>。如果没有<code class="fe mh mi mj mk b">declare</code>子句，我们会得到一个错误，因为TypeScript编译器不知道<code class="fe mh mi mj mk b">toFruitArray</code>方法存在于<code class="fe mh mi mj mk b">Array</code>全局对象中。</p><p id="2496" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在TypeScript中，许多东西可以合并在一起。合并接口是声明合并中最简单也是最常见的操作类型。最基本的情况是2个接口没有重叠的成员。在这种情况下，它们只是机械地融合在一起。此外，当两个接口合并时，如果第一个接口与第二个接口有重叠的成员，则第二个接口中的任何内容都将覆盖第一个接口的成员。对于函数成员，它们只是作为同一个函数的重载组合在一起。相同名称的命名空间会将它们的成员合并在一起。所有导出的接口和类都合并到一个名称空间中。</p><p id="c418" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以使用<code class="fe mh mi mj mk b">declare</code>关键字来声明一个模块的成员具有TypeScript编译器不知道的属性。我们还可以通过全局模块扩充在模块内部的全局范围内添加声明。类和变量目前不能合并在一起。</p></div></div>    
</body>
</html>