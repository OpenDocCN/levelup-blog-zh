<html>
<head>
<title>How Carbon, Google’s New Language, Can Perform Better Than C++</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">谷歌的新语言Carbon如何能比C++表现得更好</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-carbon-googles-new-language-can-perform-better-than-c-1e77963bceaf?source=collection_archive---------1-----------------------#2022-07-28">https://levelup.gitconnected.com/how-carbon-googles-new-language-can-perform-better-than-c-1e77963bceaf?source=collection_archive---------1-----------------------#2022-07-28</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="9ac3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我提出了C++的两个关注点，Carbon可以操作这两个点以获得早期成功</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/7b69cb6a2184818cb6018a900633746e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iqB7S3k3YpVGoveg939w3Q.jpeg"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">来自Unsplash的Tim Gouw</figcaption></figure><p id="db0a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我在职业生涯的早期就开始了软件工程之旅，这条路几乎与我现在做的事情完全无关。C++是你开始为之做准备的地方，正如我和许多人一样，无论是你在大学之前如何进入学术界，还是为了参加几次面试而进行的在线学习。我在之前的工作中已经了解了Java，并希望避开这一领域，我不想使用Objective-C进行开发，因为竞争非常激烈，很难被击败。</p><p id="3894" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了理解Carbon，它的潜力、优点、缺点，以及未来几年将会被写出来和被打乱的所有东西，<strong class="js iu">我建议对Ruby的意图有一个高层次的认识(在C++的环境中)。</strong></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi lf"><img src="../Images/bc87f30861432fc1d7a8644ed31f25b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A6BHqzQOgmz5O23OOOzFig.jpeg"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">由来自Unsplash的<a class="ae le" href="https://unsplash.com/@floschmaezz" rel="noopener ugc nofollow" target="_blank">弗洛里安·施梅兹</a></figcaption></figure><p id="60b6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Ruby本应在我们经历的所有C++挑战的交叉点上取得重大进步。也就是说，它的垃圾收集机制将释放不使用的内存，C++社区将不再需要求助于一些商业解决方案。对于C++社区来说，现在已经不太需要为这个挑战而设计的用于对象管理的<em class="lg"> unique_ptr </em>智能指针了。</p><p id="d544" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">并且Ruby以一种重塑的方式处理变量声明。或者说Ruby是如何支持多重继承的。</p><p id="837c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">即使有了Python，对其光明未来的渴望也会被说成是它的终点是取代像C++这样的语言。对于Python，最大的争议是基于它的简单性和速度。</p><p id="f538" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果Carbon要管理生命周期的编程元素，它必须能够通过低级编程实现经验结果。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi lh"><img src="../Images/b4189fcc4677f8904ae52e0aa36a9630.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EIQfoN9RusCHKilEcfTL3A.jpeg"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">来自Unsplash的维多利亚博物馆</figcaption></figure><p id="da29" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Python不适合低级编程。Ruby也不是。不管所有的评论，即使是今天关于Python和Ruby(以及现在的Carbon)，我认为可访问性和可用性归结为在低水平上可实现的东西，不管实验将显示Carbon有多快或多简单。</p><p id="cfe1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">尽管这些语言简单、优雅、快速，但软件工程在其最分解的功能上实现了一个主要目标:<strong class="js iu">直接与操作系统或硬件交互。</strong>多年来，我发现自己迫切需要跨越性能优化用例来解决问题，或者使用C++直接控制硬件的特性。我会执行高阶的内存映射过程，以设计虚拟表示物理内存地址的克隆(由于当时在访问管理控制方面的许多挑战和不完整的安全框架——我们谈论的是许多、许多年前)。</p><p id="db1d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">低级编程<em class="lg">需要</em>来实现跨多个不同平台的编译，因为操作系统不驻留在单个实体中。如果你包括程序员为显式用例构建的操作系统，我会说今天有成千上万的操作系统。显而易见的我们都知道。为了让碳穿过终点线，它归结为在操作系统底层设计中挑选用例，并揭示它如何优化这些任务(用一个明显的C++比较器)。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi li"><img src="../Images/4a7e3695cccb8d9b9c2678f815172993.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lX0acnhsU7D3t-UKlTVH-g.jpeg"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">由来自Unsplash的<a class="ae le" href="https://unsplash.com/@joshgmit" rel="noopener ugc nofollow" target="_blank">约书亚·戈尔德</a></figcaption></figure><p id="5ce5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">硬件是为软件打造的。软件支持硬件解决方案。如果Carbon要取得成功，它必须在许多不同的平台上实现编译能力。要做到这一点，它必须是可移植的，易于导入、迁移和集成，就像跨第三方集成一样(3P集成)。金钱可以买到的性能最佳的高度优化的硬件可能会因为未优化的软件而停滞不前。你们都经历过台式机/笔记本电脑的挑战。我认为这更像是一个软件问题，而不是硬件问题。低级编程的成功将展示碳的可能性艺术。</strong></p><p id="9e81" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第二个更直接，我打赌99%的C++社区会支持我:我们需要直接访问内存地址，让程序员对程序如何运行有更多的控制。分支预测和缓存利用是两个方面，在这两个方面稍加调整就可以对优化的Carbon编码产生重大影响。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi lj"><img src="../Images/db26956529fd614aa3f30843a3a3adf9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EKAZEdTXZzjWVx3IiuRizA.jpeg"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">来自Unsplash的Braden Collum</figcaption></figure><p id="94eb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">读到这里的C++人可能会说，现在用C++编写程序是可能的，甚至不需要显式释放任何内存，比如使用智能指针或其他RAII(资源获取即初始化)技术。这不是让垃圾收集成为稻草人的争论。无论智能指向路径在程序上和外科手术上多么有效，您在硬件上用来进行编译的线程仍然会在速度和整体性能上受到影响。</p><p id="75b1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">垃圾收集很快就会成为一个转移注意力的话题。端到端的自动垃圾收集会带来很大的性能开销，这在C++中是不可取的。使用手动内存管理，程序员不仅可以在释放内存时获得更多的控制，而且主要是如何实现(我前面已经解释过)软件性能的优化。有些类型的对象无论如何都很难自动收集，即使是在自带垃圾收集过程的C#实例中，不管Carbon在这个问题范围内实现得有多好。</p><p id="6608" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">C++的语法并不混乱，我也不觉得使用起来很麻烦。我看到了一些温和的主题和围绕着Carbon将如何简化代码可读性的主题的共同点。以下面的C++代码为例，它的碳当量代码如下:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi lk"><img src="../Images/600bb3a9810391aa2386265cb811b415.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kEsAKkHpp5dLZOh5c53LEQ.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">GitHub上的碳[1]</figcaption></figure><p id="f9b3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我发现Python在这方面实现了许多其他语言的跨越，几乎让人认为代码可读性现在是必须的。我在Carbon上看到了一些简单的语法，很明显Google在刻意思考简单性。</p><h2 id="936a" class="ll lm it bd ln lo lp dn lq lr ls dp lt kb lu lv lw kf lx ly lz kj ma mb mc md bi translated"><strong class="ak">离别的思念</strong></h2><p id="80f4" class="pw-post-body-paragraph jq jr it js b jt me jv jw jx mf jz ka kb mg kd ke kf mh kh ki kj mi kl km kn im bi translated">在考虑Carbon可能取代低级编程的C++的背景下，我讨论了垃圾收集管理和内存管理过程如何成为急需的早期成功的两个领域。跳到GitHub空间，探索更多关于碳的知识。</p><p id="e1f0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您有任何编辑/修改建议或关于进一步扩展此主题的建议，请考虑与我分享您的想法。</p><h1 id="7855" class="mj lm it bd ln mk ml mm lq mn mo mp lt mq mr ms lw mt mu mv lz mw mx my mc mz bi translated"><strong class="ak">另外，请考虑订阅我的每周简讯:</strong></h1><div class="na nb gp gr nc nd"><a href="https://pventures.substack.com/" rel="noopener  ugc nofollow" target="_blank"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd iu gy z fp ni fr fs nj fu fw is bi translated">周日报告#1</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">设计思维与AI的共生关系设计思维能向AI揭示什么，AI又能如何拥抱…</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">pventures.substack.com</p></div></div><div class="nm l"><div class="nn l no np nq nm nr ky nd"/></div></div></a></div></div><div class="ab cl ns nt hx nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="im in io ip iq"><p id="02e0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">参考:</p><ol class=""><li id="ba38" class="nz oa it js b jt ju jx jy kb ob kf oc kj od kn oe of og oh bi translated">碳语言。(未注明)。<em class="lg">GitHub—Carbon-lang/Carbon-lang:Carbon Language的主要知识库:文档、设计、实现和相关工具。(注:碳语是实验性的；</em>参见自述。GitHub。于2022年7月24日从<a class="ae le" href="https://github.com/carbon-language/carbon-lang" rel="noopener ugc nofollow" target="_blank">https://github.com/carbon-language/carbon-lang</a>检索</li></ol></div></div>    
</body>
</html>