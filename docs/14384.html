<html>
<head>
<title>Maximum Nesting Depth of the Parentheses — Leetcode 1614</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">括号的最大嵌套深度— Leetcode 1614</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/maximum-nesting-depth-of-the-parentheses-leetcode-1614-4dbabe23b39?source=collection_archive---------8-----------------------#2022-11-21">https://levelup.gitconnected.com/maximum-nesting-depth-of-the-parentheses-leetcode-1614-4dbabe23b39?source=collection_archive---------8-----------------------#2022-11-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5821" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">Leetcode 1614的Java解决方案</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e9756a191ed71a59584e6d16a8cdf424.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kHYQO9Fram5g_95VeVrqRg.png"/></div></div></figure><h2 id="f789" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">介绍</h2><ul class=""><li id="2612" class="lq lr it ls b lt lu lv lw ld lx lh ly ll lz ma mb mc md me bi translated">在本文中，我们将解决Leetcode 1614，它将主要帮助我们理解如何使用堆栈数据结构。</li><li id="a13b" class="lq lr it ls b lt mf lv mg ld mh lh mi ll mj ma mb mc md me bi translated">我们还将看到如何在没有堆栈数据结构的情况下解决这个问题。</li></ul><h2 id="5fa8" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">问题陈述</h2><ul class=""><li id="67ed" class="lq lr it ls b lt lu lv lw ld lx lh ly ll lz ma mb mc md me bi translated">我们已经得到了一个<strong class="ls iu">有效的括号字符串(VPS) </strong>，需要返回嵌套深度。</li><li id="32d7" class="lq lr it ls b lt mf lv mg ld mh lh mi ll mj ma mb mc md me bi translated">VPS定义为<br/>&gt;&gt;“-&gt;空字符串<br/> &gt; &gt;写为AB，其中A和B都是有效的VPS <br/> &gt; &gt; (A) - &gt;其中A是VPS</li></ul><h2 id="e155" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">例子</h2><ul class=""><li id="cf20" class="lq lr it ls b lt lu lv lw ld lx lh ly ll lz ma mb mc md me bi translated">在下面的示例中，括号的深度是3，因为数字8嵌套在3个括号内。</li><li id="89af" class="lq lr it ls b lt mf lv mg ld mh lh mi ll mj ma mb mc md me bi translated">同样，在第二个示例中，嵌套深度是3，其中3是嵌套括号。</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/14b3b271fd94b6dcdbd10ae50867593f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1296/format:webp/1*cSGHF0J8U0ZUpZ5o41uPGg.png"/></div></figure><h2 id="7942" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">解决方法</h2><p id="f11f" class="pw-post-body-paragraph ml mm it ls b lt lu ju mn lv lw jx mo ld mp mq mr lh ms mt mu ll mv mw mx ma im bi translated">直觉是我们遍历字符串中的每个字符，如果这个字符恰好是左括号，我们就把它添加到堆栈中。<br/> -当我们向堆栈添加左括号时，我们还会检查当前堆栈大小是否大于最大值。堆栈大小基本上描述了深度。<br/> -如果字符恰好是右括号，那么我们可以弹出我们添加的最后一个左括号，因为它完成了我们的括号。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi my"><img src="../Images/d1395649f80b60d586ad0b24fe58ed72.png" data-original-src="https://miro.medium.com/v2/resize:fit:938/format:webp/1*0SM-tLA-KW5fzDuSFnU2Og.png"/></div></figure><h2 id="12e7" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">密码</h2><ul class=""><li id="a678" class="lq lr it ls b lt lu lv lw ld lx lh ly ll lz ma mb mc md me bi translated">这是整个逻辑。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><ul class=""><li id="d1cf" class="lq lr it ls b lt nb lv nc ld nd lh ne ll nf ma mb mc md me bi translated">我们可以避免使用stack，因为我们要处理的唯一字符是左括号和右括号。</li><li id="bb9e" class="lq lr it ls b lt mf lv mg ld mh lh mi ll mj ma mb mc md me bi translated">相反，我们可以保持开括号，遇到开括号时递增，遇到闭括号时递减。</li></ul><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mz na l"/></div></figure><h2 id="3cc4" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">结果</h2><ul class=""><li id="d47c" class="lq lr it ls b lt lu lv lw ld lx lh ly ll lz ma mb mc md me bi translated">我们的解决方案被leetcode接受</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/9454cdfc3b18ea498e8effefc33f298c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oxbuAXqJAj8oWJMRZxL6xw.png"/></div></div></figure><h2 id="bbce" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">复杂性</h2><p id="f6a5" class="pw-post-body-paragraph ml mm it ls b lt lu ju mn lv lw jx mo ld mp mq mr lh ms mt mu ll mv mw mx ma im bi translated"><strong class="ls iu">带栈<br/> </strong> - &gt;时间复杂度:O(N) <br/> - &gt;空间复杂度:O(N)</p><p id="cb67" class="pw-post-body-paragraph ml mm it ls b lt nb ju mn lv nc jx mo ld nh mq mr lh ni mt mu ll nj mw mx ma im bi translated"><strong class="ls iu">无栈<br/> </strong> - &gt;时间复杂度:O(N) <br/> - &gt;空间复杂度:O(1)</p><h2 id="3abd" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">结论</h2><ul class=""><li id="4bbb" class="lq lr it ls b lt lu lv lw ld lx lh ly ll lz ma mb mc md me bi translated">在本文中，我们使用堆栈来解决括号问题。这个问题很适合从堆栈数据结构开始。</li><li id="26f4" class="lq lr it ls b lt mf lv mg ld mh lh mi ll mj ma mb mc md me bi translated">我们还看到，如果存储在堆栈中的数据没有变化，我们如何使堆栈冗余。</li></ul><h2 id="4503" class="ku kv it bd kw kx ky dn kz la lb dp lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">奖金</h2><ul class=""><li id="46b3" class="lq lr it ls b lt lu lv lw ld lx lh ly ll lz ma mb mc md me bi translated">如果你想升级你的编码面试游戏，你绝对可以看看这个畅销课程<a class="ae nk" href="https://click.linksynergy.com/link?id=FAaRt1BJn8w&amp;offerid=1060092.1419186&amp;type=2&amp;murl=https%3A%2F%2Fwww.udemy.com%2Fcourse%2Fdata-structures-and-algorithms-deep-dive-using-java%2F" rel="noopener ugc nofollow" target="_blank"><strong class="ls iu"><em class="nl">(这是Java的)</em></strong></a></li></ul></div></div>    
</body>
</html>