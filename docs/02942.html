<html>
<head>
<title>How to refactor GildedRose-Refactoring-Kata with Simple Factory Pattern and Strategy Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用简单工厂模式和策略模式重构GildedRose-Refactoring-Kata</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-refactor-gildedrose-refactoring-kata-with-simple-factory-pattern-and-strategy-pattern-c6b4d6c04d96?source=collection_archive---------10-----------------------#2020-04-11">https://levelup.gitconnected.com/how-to-refactor-gildedrose-refactoring-kata-with-simple-factory-pattern-and-strategy-pattern-c6b4d6c04d96?source=collection_archive---------10-----------------------#2020-04-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/89087dac330964687115e9b09f1cddae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z6LK7ZzeWXOlpSHxHgxCHA.png"/></div></div></figure><p id="3b49" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我在GitHub上发现了一个有趣的项目——<a class="ae kw" href="https://github.com/emilybache/GildedRose-Refactoring-Kata" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir">GildedRose-Refactoring-Kata</strong></a>。它为一系列编程语言中的重构练习提供了一个起始代码。原则是我们应该创建足够的单元测试来覆盖所有情况(尤其是边缘情况)，然后开始重构代码。让我们试着做一些练习。</p><p id="8122" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最初的项目有一个庞大的方法，其中包含许多用于更新项目属性的<code class="fe kx ky kz la b">if else</code>块。关于重构，有一个基于需求的限制——“不要改变<code class="fe kx ky kz la b">Item</code>类或项目属性”。这是一种陷阱，因为我首先想到的是使用简单工厂模式，这意味着我们需要将<code class="fe kx ky kz la b">Item</code>类修改为抽象类，然后为不同的项目分别创建派生类。无论如何，让我们看看如果允许我们修改<code class="fe kx ky kz la b">Item</code>类，我们能做些什么。</p><h1 id="a282" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">简单工厂模式</h1><p id="1ea9" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">简单工厂模式可能是使用最广泛的模式之一。有一个用于创建其他对象的<code class="fe kx ky kz la b">factory</code>对象，所以我们不需要使用<code class="fe kx ky kz la b">new</code>关键字在代码中频繁地创建不同的对象。工厂创建的对象应该有相同的父类，但是它们根据类型执行不同的任务。它易于使用，适用于许多场景。“最简单”并不意味着它不够好。我们可以在交货和时间成本之间找到平衡点。</p><p id="a6a6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于这种情况，<code class="fe kx ky kz la b">Item</code>类将是基类。我可以添加一个抽象方法来计算<code class="fe kx ky kz la b">SellIn</code>和<code class="fe kx ky kz la b">Quality</code>:</p><pre class="me mf mg mh gt mi la mj mk aw ml bi"><span id="e0db" class="mm lc iq la b gy mn mo l mp mq">public abstract class Item<br/>{<br/>    public string Name { get; set; }<br/>    public int SellIn { get; set; }<br/>    public int Quality { get; set; }<br/>​<br/>    protected Item(string name, int sellIn, int quality)<br/>    {<br/>        Name = name;<br/>        SellIn = sellIn;<br/>        Quality = quality;<br/>    }<br/>    public abstract void Update();<br/>}</span></pre><p id="fcdc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kx ky kz la b">Item</code>类现在是<code class="fe kx ky kz la b">abstract</code>，所以它不能被直接实例化。现在我们可以创建派生类来更新不同类型的这些属性。为简单起见，我将创建一个<strong class="ka ir"> StandardItem </strong>类型和一个<strong class="ka ir"> AgedBrie </strong>类型作为示例，如下所示:</p><pre class="me mf mg mh gt mi la mj mk aw ml bi"><span id="7360" class="mm lc iq la b gy mn mo l mp mq">public class StandardItem : Item<br/>{<br/>    public StandardItem(string name, int sellIn, int quality) <br/>        : base(name, sellIn, quality) { }<br/>    public override void Update()<br/>    {<br/>        SellIn = SellIn - 1;<br/>        Quality = Quality - 2;<br/>        if (Quality &lt; 0)<br/>        {<br/>            Quality = 0;<br/>        }<br/>        else if(Quality &gt; 50)<br/>        {<br/>            Quality = 50;<br/>        }<br/>    }<br/>}<br/>​<br/>public class AgedBrie : Item<br/>{<br/>    public AgedBrie(string name, int sellIn, int quality) <br/>        : base(name, sellIn, quality)<br/>    {<br/>    }<br/>​<br/>    public override void Update()<br/>    {<br/>        SellIn = SellIn - 1;<br/>        Quality = Quality + 1;<br/>        if (Quality &lt; 0)<br/>        {<br/>            Quality = 0;<br/>        }<br/>        else if (Quality &gt; 50)<br/>        {<br/>            Quality = 50;<br/>        }<br/>        //The above validation can be refactored as well<br/>    }<br/>}</span></pre><p id="d4a5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是在这里我们仍然可以看到在检索<code class="fe kx ky kz la b">Quality</code>的值时出现了一些重复的代码。所以更好的方法是将这些验证转移到基类<code class="fe kx ky kz la b">Item</code>中<code class="fe kx ky kz la b">Quality</code>属性的<code class="fe kx ky kz la b">getter</code>方法中，或者我们可以在基类中有一个默认的实现。</p><p id="6dd3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过创建这些派生类，我们可以将逻辑从大的<code class="fe kx ky kz la b">GildedRose</code>类提取到派生类中。接下来，我们需要一个工厂来生产它们。</p><pre class="me mf mg mh gt mi la mj mk aw ml bi"><span id="e1c5" class="mm lc iq la b gy mn mo l mp mq">public class ItemFactory<br/>{<br/>    public static Item CreateItem(string name, int sellIn, int quality)<br/>    {<br/>        switch (name)<br/>        {<br/>            case "Aged Brie":<br/>                return new AgedBrie(name, sellIn, quality);<br/>            ...<br/>            default:<br/>                return new StandardItem(name, sellIn, quality);<br/>        }<br/>    }<br/>}</span></pre><p id="7ac5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下一步是更新<code class="fe kx ky kz la b">Program</code>类中的<code class="fe kx ky kz la b">Main</code>方法:</p><pre class="me mf mg mh gt mi la mj mk aw ml bi"><span id="ff9c" class="mm lc iq la b gy mn mo l mp mq">IList&lt;Item&gt; Items = new List&lt;Item&gt;{<br/>    //Call the factory to create the derived classes:<br/>    ItemFactory.CreateItem("+5 Dexterity Vest", 10, 20),<br/>...</span></pre><p id="48ec" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们使用工厂来生产产品。现在更新<code class="fe kx ky kz la b">GildedRose</code>类中的<code class="fe kx ky kz la b">UpdateQuality</code>方法:</p><pre class="me mf mg mh gt mi la mj mk aw ml bi"><span id="cab1" class="mm lc iq la b gy mn mo l mp mq">public void UpdateQuality()<br/>{<br/>    foreach (var item in Items)<br/>    {<br/>        item.Update();<br/>    }<br/>}</span></pre><p id="30b0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为每个派生项都有自己的方法来更新属性，所以我们可以得到正确的值。</p><p id="056e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是，如果我们不能修改<code class="fe kx ky kz la b">Item</code>类呢？</p><p id="ff4a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一种变化是使用接口来扩展类的行为。我们不需要在<code class="fe kx ky kz la b">Item</code>类中添加<code class="fe kx ky kz la b">Update</code>方法。相反，我们可以创建一个提供<code class="fe kx ky kz la b">Update</code>方法的新接口。所以派生类可以实现这个接口来更新它的属性:</p><pre class="me mf mg mh gt mi la mj mk aw ml bi"><span id="74d3" class="mm lc iq la b gy mn mo l mp mq">public interface IUpdate<br/>{<br/>    void UpdateSellIn();<br/>    void UpdateQuality();<br/>}<br/>​<br/>public class AgedBrie : Item, IUpdate<br/>{<br/>    ...<br/>}</span></pre><p id="0f79" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">派生类也应该实现<code class="fe kx ky kz la b">IUpdate</code>接口。所以基本逻辑没有太大变化，只需要分别改变<code class="fe kx ky kz la b">UpdateQuality</code>方法:</p><pre class="me mf mg mh gt mi la mj mk aw ml bi"><span id="8fa6" class="mm lc iq la b gy mn mo l mp mq">public void UpdateQuality()<br/>{<br/>    foreach (var item in Items)<br/>    {<br/>        ((IUpdate)item).UpdateSellIn();<br/>        ((IUpdate)item).UpdateQuality();<br/>    }<br/>}</span></pre><p id="f565" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于一些C#面试，一个常见的问题是“抽象类和接口的区别”。基本上，典型的答案可能是:</p><ul class=""><li id="62a2" class="mr ms iq ka b kb kc kf kg kj mt kn mu kr mv kv mw mx my mz bi translated">抽象类可以有函数的访问说明符，但接口不能。换句话说，您可以使用<code class="fe kx ky kz la b">private</code>、<code class="fe kx ky kz la b">public</code>等用于内部函数，但是在界面中，默认情况下所有函数都是公共的。</li><li id="3490" class="mr ms iq ka b kb na kf nb kj nc kn nd kr ne kv mw mx my mz bi translated">抽象类可以有默认实现，但接口不能。</li><li id="a3f7" class="mr ms iq ka b kb na kf nb kj nc kn nd kr ne kv mw mx my mz bi translated">抽象类可以有字段和常量，但接口不能有字段。</li><li id="2323" class="mr ms iq ka b kb na kf nb kj nc kn nd kr ne kv mw mx my mz bi translated">抽象类可以有非抽象方法，但接口不能。</li><li id="cf14" class="mr ms iq ka b kb na kf nb kj nc kn nd kr ne kv mw mx my mz bi translated">抽象类可以有构造函数，但接口不能。</li><li id="de16" class="mr ms iq ka b kb na kf nb kj nc kn nd kr ne kv mw mx my mz bi translated">一个类只能从一个抽象类派生，但是它可以实现多个接口。</li><li id="6153" class="mr ms iq ka b kb na kf nb kj nc kn nd kr ne kv mw mx my mz bi translated">两者都不能实例化。</li><li id="003d" class="mr ms iq ka b kb na kf nb kj nc kn nd kr ne kv mw mx my mz bi">…</li></ul><blockquote class="nf ng nh"><p id="8d31" class="jy jz ni ka b kb kc kd ke kf kg kh ki nj kk kl km nk ko kp kq nl ks kt ku kv ij bi translated"><em class="iq">注意:请记住</em> <strong class="ka ir"> <em class="iq">“接口不能有实现”在今天是不正确的，因为接口支持C# 8.0的默认实现！</em> </strong> <em class="iq">还有，从C# 8.0开始对接口有了更多的改变:C# 8.0中的接口可以有</em> <code class="fe kx ky kz la b"><em class="iq">private</em></code> <em class="iq">、</em> <code class="fe kx ky kz la b"><em class="iq">static</em></code> <em class="iq">、</em> <code class="fe kx ky kz la b"><em class="iq">protected</em></code> <em class="iq">、</em> <code class="fe kx ky kz la b"><em class="iq">virtual</em></code> <em class="iq">成员。也许这个面试问题可以更新。仅供参考:</em> <a class="ae kw" href="https://devblogs.microsoft.com/dotnet/default-implementations-in-interfaces/" rel="noopener ugc nofollow" target="_blank"> <em class="iq">接口</em></a><em class="iq"/><a class="ae kw" href="https://docs.microsoft.com/zh-cn/dotnet/csharp/tutorials/default-interface-methods-versions" rel="noopener ugc nofollow" target="_blank"><em class="iq">中的默认实现教程:用C# 8.0 </em> </a> <em class="iq">中的默认接口方法更新接口。</em></p></blockquote><p id="325f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那么我们什么时候应该使用抽象类或者接口呢？从我的理解来说，答案是“看情况”。抽象类用于定义具有逻辑继承关系的对象的实际身份，但接口更可能用于扩展对象的行为。在依赖注入模式中，我们主要使用接口。</p><p id="e239" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这有点跑题了。让我们回到重构。老实说，工厂模式的变化不够好——因为它混淆了<strong class="ka ir">对象</strong>和<strong class="ka ir">行为</strong>。实际上，我们应该对用于计算属性的方法进行抽象。但是物品本身应该是一样的。让我们继续前进。</p><h1 id="bd93" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">战略模式</h1><p id="48b7" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">设计模式有多种类别:</p><ul class=""><li id="b6ba" class="mr ms iq ka b kb kc kf kg kj mt kn mu kr mv kv mw mx my mz bi translated">创造模式——创造各种各样的对象</li><li id="2f9d" class="mr ms iq ka b kb na kf nb kj nc kn nd kr ne kv mw mx my mz bi translated">结构模式—将对象组装成更大的结构</li><li id="f838" class="mr ms iq ka b kb na kf nb kj nc kn nd kr ne kv mw mx my mz bi translated">行为模式——更加关注算法和对象之间的责任分配。</li></ul><p id="3df7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于这个实践，我们可以使用行为模式之一——策略模式来分离计算逻辑和对象。这种模式允许我们在不改变原来的<code class="fe kx ky kz la b">Item</code>类的情况下拥有多种算法。</p><p id="7c67" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，我们需要定义一个接口来声明执行策略的方法:</p><pre class="me mf mg mh gt mi la mj mk aw ml bi"><span id="f5ab" class="mm lc iq la b gy mn mo l mp mq">public interface IStrategy<br/>{<br/>    (int sellIn, int quality) Update(Item item)<br/>}</span></pre><p id="e7a7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们使用C# 8.0，我们可以在这里使用默认实现，例如重置<code class="fe kx ky kz la b">SellIn</code>的值并验证<code class="fe kx ky kz la b">Quality</code>的值。</p><p id="6efc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后我们将定义具体的策略:</p><pre class="me mf mg mh gt mi la mj mk aw ml bi"><span id="7192" class="mm lc iq la b gy mn mo l mp mq">public class StandardStrategy : IStrategy<br/>{<br/>    public (int sellIn, int quality) Update(Item item)<br/>    {<br/>        var quality = item.Quality - 2;<br/>        ...<br/>        return (item.SellIn - 1, quality);<br/>    }<br/>}<br/>​<br/>​<br/>public class AgedBrieStrategy : IStrategy<br/>{<br/>    public (int sellIn, int quality) Update(Item item)<br/>    {<br/>        var quality = item.Quality + 1;<br/>        ...<br/>        return (item.SellIn - 1, quality);<br/>    }<br/>}</span></pre><p id="59d2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后我们需要创建一个<code class="fe kx ky kz la b">Context</code>类来定义客户感兴趣的接口:</p><pre class="me mf mg mh gt mi la mj mk aw ml bi"><span id="52e3" class="mm lc iq la b gy mn mo l mp mq">public class StrategyContext<br/>{<br/>    private readonly IStrategy _strategy = null;<br/>​<br/>    public StrategyContext(string name)<br/>    {<br/>        switch (name)<br/>        {<br/>            case "Aged Brie":<br/>                _strategy = new AgedBrieStrategy();<br/>                break;<br/>            ...<br/>            default:<br/>                _strategy = new StandardStrategy();<br/>                break;<br/>        }<br/>    }<br/>​<br/>    public (int sellIn, int quality) Update(Item item)<br/>    {<br/>        return _strategy.Update(item);<br/>    }<br/>}</span></pre><p id="d773" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来我们可以在<code class="fe kx ky kz la b">GildedRose</code>类中应用<code class="fe kx ky kz la b">UpdateQuality</code>方法中的策略:</p><pre class="me mf mg mh gt mi la mj mk aw ml bi"><span id="08d9" class="mm lc iq la b gy mn mo l mp mq">public void UpdateQuality()<br/>{<br/>    foreach (var item in Items)<br/>    {<br/>        var context = new StrategyContext(item.Name);<br/>        var result = context.Update(item);<br/>        item.SellIn = result.sellIn;<br/>        item.Quality = result.quality;<br/>    }<br/>}</span></pre><p id="91f1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这次我们没有改变<code class="fe kx ky kz la b">Program</code>类中的<code class="fe kx ky kz la b">Item</code>类和<code class="fe kx ky kz la b">Main</code>方法。如果你觉得这里的<code class="fe kx ky kz la b">new</code>关键字不漂亮，可以继续使用工厂模式，将用于创建正确策略的逻辑解耦到另一部分。但是现在我们已经将计算行为从对象本身解耦到另一个类。</p><h1 id="50d6" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">摘要</h1><p id="756d" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">我的回购可以在这里找到:<a class="ae kw" href="https://github.com/yanxiaodi/GildedRose-Refactoring-Kata-Solutions" rel="noopener ugc nofollow" target="_blank">https://github . com/yanxiaodi/GildedRose-Refactoring-Kata-Solutions</a>。因为我没有创建足够的单元测试，所以不能保证结果。演示是为了展示如何应用这些设计模式，而不是具体的实现。当我们开始重构代码时，最重要的事情是创建足够多的单元测试，以确保重构不会破坏当前的功能。原始项目已经有一个单元测试样本，所以我们可以添加更多的测试来覆盖那些**边缘案例* *。要做到100%覆盖并不容易，但值得去做。</p><p id="59ba" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">显然，我不认为有人会像最初的项目那样编写代码。我一直在想的一件事是，当我们有一个新的需求时，我们应该如何通过使用一些复杂的设计模式或者仅仅是<code class="fe kx ky kz la b">if else</code>来设计它？换句话说，有时客户可能只是因为预算限制而要求您尽快实现该功能，而不关心您的底层实现。假设我们有两个选择:</p><ul class=""><li id="8c6d" class="mr ms iq ka b kb kc kf kg kj mt kn mu kr mv kv mw mx my mz bi translated">开发者A是个新手，只用<code class="fe kx ky kz la b">if else</code>就能在2小时内完成功能。然而，它确实像预期的那样工作。</li><li id="0404" class="mr ms iq ka b kb na kf nb kj nc kn nd kr ne kv mw mx my mz bi translated">开发人员B更有经验，但需要更多的时间来设计模式，所以时间成本将是4小时。但是将来增加更多的功能是很容易的。</li></ul><p id="e47f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你会怎么选择？</p></div></div>    
</body>
</html>