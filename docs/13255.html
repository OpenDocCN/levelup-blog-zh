<html>
<head>
<title>How To Read a File Line by Line in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在JavaScript中逐行读取文件</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-read-a-file-line-by-line-in-javascript-48d9a688fe49?source=collection_archive---------0-----------------------#2022-08-21">https://levelup.gitconnected.com/how-to-read-a-file-line-by-line-in-javascript-48d9a688fe49?source=collection_archive---------0-----------------------#2022-08-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d579" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">哪种方式更好？</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/6f4d880453e609501fca1d96298146bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*S_17XIFPCwIKyhEc"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@thoughtcatalog?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">思想目录</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="1f41" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有些情况下，我们需要在JavaScript中逐行读取文件，这可能是分析一些日志，或者提取部分信息。简而言之，我们不需要将文件的全部内容加载到内存中，因为一次读取一个大文件会使进程内存密集，你有更好的办法，那么你该怎么办？</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="814f" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">一次读完</h1><p id="9dee" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">你可以准备一个大于50MB的文件，然后用下面的代码一次性读取它的全部内容，然后计算这个程序使用的内存和消耗的时间:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="69f7" class="ne md it na b gy nf ng l nh ni">console.time('Time');</span><span id="7663" class="ne md it na b gy nj ng l nh ni">const fs = require('fs');<br/>const allContents = fs.readFileSync('test.json', 'utf-8');</span><span id="5b88" class="ne md it na b gy nj ng l nh ni">allContents.split(/\r?\n/).forEach((line) =&gt; {<br/>  // console.log('line: ', line);<br/>});</span><span id="fb4b" class="ne md it na b gy nj ng l nh ni">console.log(`Used ${process.memoryUsage().heapUsed / 1024 / 1024} MB`);</span><span id="7827" class="ne md it na b gy nj ng l nh ni">console.timeEnd('Time');</span></pre><p id="1414" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我在这里准备了一个65MB左右的<code class="fe nk nl nm na b">test.json</code>文件，运行程序的最终结果是:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="cf13" class="ne md it na b gy nf ng l nh ni">Used 261.44498443603516 MB<br/>Time: 841.644ms</span></pre><p id="f3aa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你可以看到它需要大约<code class="fe nk nl nm na b">261MB</code>的内存，如果你有1.4 GB以上的文件，不推荐这种方法。因为Node.js默认可以使用的最大内存空间是1.4G左右(为了保证V8的内存回收效率)。</p><h1 id="0b7a" class="mc md it bd me mf nn mh mi mj no ml mm jz np ka mo kc nq kd mq kf nr kg ms mt bi translated">使用读取线</h1><p id="c373" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我们可以使用Node.js提供的Readline API，通过从任何可读流中一次读取一行，可以使用它来逐行读取文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="fc6c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">之后我们得到:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="69b9" class="ne md it na b gy nf ng l nh ni">Used 4.973365783691406 MB<br/>Time: 672.116ms</span></pre><p id="00cc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以看出它使用的内存减少了好几倍。为了解释上面的代码:首先，我们使用<code class="fe nk nl nm na b">readline.createInterface</code>创建一个接口，其中输入是使用<code class="fe nk nl nm na b">fs.createReadStream('test.json')</code>创建的可读流。在接口选项中，我们还传递了<code class="fe nk nl nm na b">crlfDelay</code>，它表示如果<code class="fe nk nl nm na b">\r</code>和<code class="fe nk nl nm na b">\n</code>之间的延迟超过<code class="fe nk nl nm na b">crlfDelay</code>毫秒，那么<code class="fe nk nl nm na b">\r</code>和<code class="fe nk nl nm na b">\n</code>都将被视为单独的行尾输入。<code class="fe nk nl nm na b">crlfDelay</code>将被强制为不小于<code class="fe nk nl nm na b">100</code>的数。它可以被设置为<code class="fe nk nl nm na b">Infinity</code>，在这种情况下<code class="fe nk nl nm na b">\r</code>后跟<code class="fe nk nl nm na b">\n</code>将总是被认为是一个单独的换行符(这对于<a class="ae ky" href="https://nodejs.org/api/readline.html#example-read-file-stream-line-by-line" rel="noopener ugc nofollow" target="_blank">读取带有<code class="fe nk nl nm na b">\r\n</code>行分隔符的文件</a>可能是合理的)。</p><p id="6f73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">接下来绑定<code class="fe nk nl nm na b">line</code>事件，这是每一行的数据，我们可以分析。最后我们监听了<code class="fe nk nl nm na b">close</code>事件，并把它做成一个承诺，也就是说整个文件都读完了。</p><h1 id="6c55" class="mc md it bd me mf nn mh mi mj no ml mm jz np ka mo kc nq kd mq kf nr kg ms mt bi translated">使用npm模块</h1><p id="6a63" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">最后，我们可以选择NPM上的一些第三方库来实现类似的功能。我在这里做了简单的搜索，找到了<code class="fe nk nl nm na b"><a class="ae ky" href="https://www.npmjs.com/package/n-readlines" rel="noopener ugc nofollow" target="_blank">n-readlines</a></code>、<code class="fe nk nl nm na b"><a class="ae ky" href="https://www.npmjs.com/package/line-reader" rel="noopener ugc nofollow" target="_blank">line-reader</a></code>、<code class="fe nk nl nm na b"><a class="ae ky" href="https://www.npmjs.com/package/readlines-ng" rel="noopener ugc nofollow" target="_blank">readlines-ng</a></code>等。按更新和下载排序，最终选择了<code class="fe nk nl nm na b"><a class="ae ky" href="https://github.com/nacholibre/node-readlines" rel="noopener ugc nofollow" target="_blank">n-readlines</a></code>。</p><p id="5b9e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">它的源代码比较简单，不到160行。它不使用流，而是使用缓冲区和<code class="fe nk nl nm na b">fs</code>模块来读取<a class="ae ky" href="https://github.com/nacholibre/node-readlines/blob/master/readlines.js#L84" rel="noopener ugc nofollow" target="_blank">块</a>中的文件内容，这也意味着它不会将整个文件加载到内存中。以下是使用案例:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="3c93" class="ne md it na b gy nf ng l nh ni">console.time('Time');</span><span id="5103" class="ne md it na b gy nj ng l nh ni">const ReadLines = require('n-readlines');<br/>const readLines = new ReadLines('test.json');</span><span id="1547" class="ne md it na b gy nj ng l nh ni">let line;<br/>while ((line = readLines.next())) {<br/>  // console.log(line.toString('ascii'));<br/>}</span><span id="a2cf" class="ne md it na b gy nj ng l nh ni">console.log(`Used ${process.memoryUsage().heapUsed / 1024 / 1024} MB`);<br/>console.timeEnd('Time');</span></pre><p id="8e04" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">之后我们得到:</p><pre class="kj kk kl km gt mz na nb nc aw nd bi"><span id="ded7" class="ne md it na b gy nf ng l nh ni">Used 6.603157043457031 MB<br/>Time: 2.015s</span></pre><p id="f172" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">可以看出，它使用的内存也更少，但消耗的时间更多。</p><h1 id="d984" class="mc md it bd me mf nn mh mi mj no ml mm jz np ka mo kc nq kd mq kf nr kg ms mt bi translated">结论</h1><p id="267c" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">我在看<code class="fe nk nl nm na b"><a class="ae ky" href="https://www.npmjs.com/package/tsc-watch" rel="noopener ugc nofollow" target="_blank">tsc-watch</a></code>的源码，发现它用<code class="fe nk nl nm na b">readline</code>分析<code class="fe nk nl nm na b">tsc</code>的输出，然后做它的逻辑。我也推荐使用<code class="fe nk nl nm na b"><a class="ae ky" href="https://github.com/gilamran/tsc-watch/blob/master/lib/tsc-watch.js#L93" rel="noopener ugc nofollow" target="_blank">readline</a></code>逐行读取文件，如果有高级需求，第三方库也是不错的选择。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="d006" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><em class="nu">感谢阅读。如果你喜欢这样的故事，想支持我，请考虑成为</em> <a class="ae ky" href="https://medium.com/@islizeqiang/membership" rel="noopener"> <em class="nu">中会员</em> </a> <em class="nu">。每月5美元，你可以无限制地访问媒体内容。如果你通过</em> <a class="ae ky" href="https://medium.com/@islizeqiang/membership" rel="noopener"> <em class="nu">我的链接</em> </a> <em class="nu">报名，我会得到一点佣金。</em></p><p id="4d7a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">你的支持对我来说很重要——谢谢。</p></div></div>    
</body>
</html>