<html>
<head>
<title>Synchronous vs. Asynchronous data sources</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">同步与异步数据源</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/synchronous-vs-asynchronous-data-sources-f78e40f998c1?source=collection_archive---------11-----------------------#2020-02-27">https://levelup.gitconnected.com/synchronous-vs-asynchronous-data-sources-f78e40f998c1?source=collection_archive---------11-----------------------#2020-02-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0401" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在Javascript应用程序中</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/9500bb59c4d5596e73206a9241e679a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VZk5KFn0CkhatZQC"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">格伦·卡斯滕斯-彼得斯在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="6faa" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">一个常见的误解是将同步数据源视为异步，尤其是在测试反应流时。在这篇文章中，我将尝试探索同步和异步数据源之间的差异，以及<code class="fe lv lw lx ly b">RxJS</code>中相应的例子。</p><h2 id="9d76" class="lz ma it bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated">同步数据源</h2><p id="c95f" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">每个反应库都提供了从不同类型的数据创建流的可能性。对于这个例子，我们将考虑一个简单的数组[2，12，35]，它将被包装成一个可观察的:</p><pre class="kj kk kl km gt mx ly my mz aw na bi"><span id="07df" class="lz ma it ly b gy nb nc l nd ne">const sourceA = from([2, 12, 35]);<br/>sourceA.subscribe(console.log);</span><span id="ecb0" class="lz ma it ly b gy nf nc l nd ne"><strong class="ly iu">Output: <br/></strong>2 <br/>12<br/>35</span></pre><p id="4a43" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个例子表明，当可观察对象被订阅时，数组的值被一个接一个地发出，直到数组用完为止，给出上面概述的输出。包装的数据也可以是字符串、映射或集合。<em class="ng">在将数据项处理到订阅回调中时，每个后续项都必须等待当前项完成处理</em>。</p><p id="dd08" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">除此之外，代码还可以包装单个值，而不是数组。下面的示例说明了如何从一个角色创建一个可观察对象，并在用户连接后发出该值:</p><pre class="kj kk kl km gt mx ly my mz aw na bi"><span id="d0e3" class="lz ma it ly b gy nb nc l nd ne">const sourceB = from('a');<br/>sourceB.subscribe(console.log);</span><span id="e867" class="lz ma it ly b gy nf nc l nd ne"><strong class="ly iu">Output</strong>:<br/>a</span></pre><h2 id="7d2a" class="lz ma it bd mb mc md dn me mf mg dp mh li mi mj mk lm ml mm mn lq mo mp mq mr bi translated"><strong class="ak">异步数据源</strong></h2><p id="d286" class="pw-post-body-paragraph kz la it lb b lc ms ju le lf mt jx lh li mu lk ll lm mv lo lp lq mw ls lt lu im bi translated">在异步数据源的情况下，情况有所不同。在之前的一篇文章中，<code class="fe lv lw lx ly b">Promises</code>对<code class="fe lv lw lx ly b">RxJS</code>中的<code class="fe lv lw lx ly b">Observables</code>，我解释了一个异步操作，比如一个<code class="fe lv lw lx ly b">HTTP</code>请求将被包装在一个承诺中，它将成功解析并调用一个成功回调或抛出一个错误(拒绝)——就是这样，它最终发出一个<strong class="lb iu">单个</strong>值。下面的示例演示如何创建在2秒钟后解析的异步事件。只有在承诺解析后，才会调用订户的回调。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nh ni l"/></div></figure><pre class="kj kk kl km gt mx ly my mz aw na bi"><span id="97a2" class="lz ma it ly b gy nb nc l nd ne"><strong class="ly iu">Output:<br/></strong>‘wait for success promise’<br/>&lt;&lt;AFTER 2 seconds&gt;&gt;<br/>‘success’</span></pre><p id="2822" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">另一方面，处理不可预测的<code class="fe lv lw lx ly b">DOM</code>事件，比如鼠标移动，会阻止我们处理承诺，因为它们被限制在一个值内。<code class="fe lv lw lx ly b">RxJS</code>提供了从<code class="fe lv lw lx ly b">DOM</code>元素上连接的事件中创建可观察对象的可能性。下面的例子说明了一个<strong class="lb iu"> mousemove </strong>事件发射器到一个可观察事件的转换。请在文档正文周围移动鼠标，并检查控制台中记录的异步事件。</p><pre class="kj kk kl km gt mx ly my mz aw na bi"><span id="272d" class="lz ma it ly b gy nb nc l nd ne">let eventSource = fromEvent(document, 'mousemove', {passive: true});</span><span id="d756" class="lz ma it ly b gy nf nc l nd ne">eventSource.subscribe(val =&gt; console.log(val as MouseEvent));</span></pre><p id="86e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我想快速讨论一下我在测试异步数据源时目睹的一个常见错误。</p><p id="0710" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">假设我们有一个异步数据源，比如一个<code class="fe lv lw lx ly b">DOM</code>事件发射器，像上面的例子一样被包装在一个可观察对象中，我们想要测试它。我见过一些开发人员用同步数据流测试它的用例，首先从一组测试值中创建一个<code class="fe lv lw lx ly b">Observable</code>并订阅它。</p><p id="278c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在我看来，这是错误的方法，尽管它可以提供容易验证的结果，但由于异步事件是不可预测的，所以它们可能并不总是正确的。</p><p id="72ef" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">进行这种测试的正确方法是使用<code class="fe lv lw lx ly b">Marble Testing</code>。我将在以后的文章中详细讨论大理石测试。</p><p id="6991" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当心</p></div><div class="ab cl nj nk hx nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="im in io ip iq"><p id="6ba4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">参考资料:</p><div class="nq nr gp gr ns nt"><a href="https://www.manning.com/books/rxjs-in-action" rel="noopener  ugc nofollow" target="_blank"><div class="nu ab fo"><div class="nv ab nw cl cj nx"><h2 class="bd iu gy z fp ny fr fs nz fu fw is bi translated">RxJS在行动</h2><div class="oa l"><h3 class="bd b gy z fp ny fr fs nz fu fw dk translated">1.1.1.阻塞代码1.1.2的问题。具有回调函数的非阻塞代码。理解时间和空间…</h3></div><div class="ob l"><p class="bd b dl z fp ny fr fs nz fu fw dk translated">www.manning.com</p></div></div><div class="oc l"><div class="od l oe of og oc oh ks nt"/></div></div></a></div></div></div>    
</body>
</html>