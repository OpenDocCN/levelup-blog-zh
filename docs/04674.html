<html>
<head>
<title>Graphs everywhere — Finding the minimum swaps required to sort an array</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">无处不在的图形—查找对阵列排序所需的最少交换</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/graphs-everywhere-finding-the-minimum-swaps-required-to-sort-an-array-b8dea0a3af52?source=collection_archive---------3-----------------------#2020-07-09">https://levelup.gitconnected.com/graphs-everywhere-finding-the-minimum-swaps-required-to-sort-an-array-b8dea0a3af52?source=collection_archive---------3-----------------------#2020-07-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/8d91588f7051edc2954f7ddaefc6a65d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-0bJnBYpK1nkwVdupGdVjg.jpeg"/></div></div></figure><div class=""/><p id="15d8" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">图是计算机科学中最基本的概念之一。他们完美地扮演了解决大量问题的角色。在这篇文章中，我们将揭示一个算法问题，乍看之下，人们甚至不会认为图对解决这个问题有任何用处。但首先，让我们看看我们今天的旅程。请注意，在本文中，我们不会深入探讨图的概念，而是简单介绍一下，然后重点讨论它在解决数组算法问题中的应用。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="a9e2" class="le lf jb bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated"><strong class="ak">路线图</strong></h1><ol class=""><li id="2cfd" class="mc md jb ka b kb me kf mf kj mg kn mh kr mi kv mj mk ml mm bi translated"><em class="kw">图的快速介绍——结构、路径和循环</em></li><li id="d9f9" class="mc md jb ka b kb mn kf mo kj mp kn mq kr mr kv mj mk ml mm bi translated"><em class="kw">要解决的问题——找到排序数组所需的最少交换数</em></li><li id="c1ac" class="mc md jb ka b kb mn kf mo kj mp kn mq kr mr kv mj mk ml mm bi translated"><em class="kw">编码时间</em></li><li id="20d8" class="mc md jb ka b kb mn kf mo kj mp kn mq kr mr kv mj mk ml mm bi translated"><em class="kw">总是对你的算法进行单元测试</em></li></ol></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="53a5" class="le lf jb bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated"><strong class="ak">图表介绍</strong></h1><ol class=""><li id="48a7" class="mc md jb ka b kb me kf mf kj mg kn mh kr mi kv mj mk ml mm bi translated"><strong class="ka jc">图的结构</strong></li></ol><p id="c685" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">图是一种数据结构，其最紧凑的形式由单个顶点(也称为节点)组成。下面是它的一个简单表示:</p><figure class="mt mu mv mw gt is gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/959c23407e217dc8d79f3df53e32686b.png" data-original-src="https://miro.medium.com/v2/resize:fit:442/format:webp/1*Wp1C9rEBm4r74dvFbJV9Kg.png"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">图1 —单节点图</figcaption></figure><p id="a606" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">显然，我们可以通过添加更多的属性来扩展这个图。例如，与此连接的另一个节点，其中节点之间的方向并不重要，如下所示:</p><figure class="mt mu mv mw gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nb"><img src="../Images/04aa371d8eaccafd67d0b9e5230f96ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lS1iOJ1kyW18mW2njijBBQ.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">图2 —无向图(方向无关紧要)</figcaption></figure><p id="9d24" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，如果我们简单地给上面两个节点之间的边添加一个方向，我们就可以把它变成一个有向图，这对我们马上要解决的问题也很重要。它看起来是这样的:</p><figure class="mt mu mv mw gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nc"><img src="../Images/936e6173a695778e806df128e321561f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HEu0tYpQoxEtsjJxbkrrGA.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">图2 —有向图(方向很重要)</figcaption></figure><p id="e45d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">到目前为止，这听起来真的很简单，然而，我们需要覆盖图的路径和循环，所以我们准备好背包来解决我们的算法问题。</p><p id="24fb" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">②<em class="kw">。</em>路径</strong></p><p id="66a5" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了从理论上理解路径，我们需要首先接触一下图中的行走。让我们看看那是什么:</p><p id="0d74" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc"> 2.1。行走<em class="kw"> — </em> </strong> <em class="kw"> </em>行走基本上是一系列的边，除了第一条边之外，每条边都从前一条边结束的节点(顶点)开始<em class="kw">。</em>例如，下图演示了一次行走:</p><figure class="mt mu mv mw gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nd"><img src="../Images/1726fb5ae664a58f3b19c6ef9c961eb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BRHsngzRrzA4wDbxQ4X73A.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">图3——图上的行走</figcaption></figure><p id="59d5" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这里，如果我们穿越A &gt; B &gt; C，那将会给我们一次步行——如果我们穿越A &gt; B &gt; C &gt; D，或者甚至A &gt; B &gt;<strong class="ka jc">C</strong>T32】D&gt;T30】C也是一样。</p><p id="ef6b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里需要记住的重要一点是，一个行走可以有重复的边，这不会对行走的定义产生任何干扰。</p><p id="8a59" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc"> 2.2。路径— </strong>路径就是一条你永远不会超过一次的路。因此，所有的边和顶点都是不同的。回到前面的例子，A &gt; B &gt; C会给我们一条路径，但<br/> A &gt; B &gt; C &gt; D &gt; C不会</p><p id="a037" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc"> 2.3。循环— </strong>当路径上的第一个节点<em class="kw">和最后一个<em class="kw">节点</em>相同时，可以检测到循环。这将给出不同的边，但不是不同的节点，从而导致循环。下图为我们展示了一个<br/> A &gt; B &gt; C &gt; D &gt; A的循环。</em></p><figure class="mt mu mv mw gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ne"><img src="../Images/63f36074c6c47279bbb4f2d4c1a5b4d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dt8q0l_32VKf0Kv1HSmT2A.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">图4-表示A &gt; B &gt; C &gt; D &gt; A的循环</figcaption></figure><p id="3364" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">到目前为止，我们已经涵盖了我们需要知道的所有内容，因此我们可以处理我们的算法问题。因此，没有任何进一步的细节，让我们继续阅读，找到更多关于这个问题。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="b9c5" class="le lf jb bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">要解决的问题—寻找最小交换来排序数组</h1><ol class=""><li id="628e" class="mc md jb ka b kb me kf mf kj mg kn mh kr mi kv mj mk ml mm bi translated"><strong class="ka jc">问题陈述</strong></li></ol><p id="cda2" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们得到了一个由<em class="kw">个不同的</em>个整数组成的数组，这些整数<em class="kw">没有</em>排序。我们被允许交换数组的两个项目中的任何一个，最终使它按照<em class="kw">升序</em>排序。我们的任务是编写一段算法，计算出按预期排序数组所需的最少交换次数。</p><blockquote class="nf ng nh"><p id="7203" class="jy jz kw ka b kb kc kd ke kf kg kh ki ni kk kl km nj ko kp kq nk ks kt ku kv ij bi translated">当我第一次面对这个问题时，我想不出像图表这样的东西会有什么帮助，所以我可以用它来构建解决方案的框架。但是，当我开始自己解决这个问题，并在一张纸上想象它时，我开始意识到这一点，这就是我们在文章的其余部分想要经历的。</p></blockquote><p id="9972" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc"> 2。问题演练</strong></p><p id="c94d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们从整数数组作为程序输入开始。这是:</p><figure class="mt mu mv mw gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nl"><img src="../Images/179d229d00d91fdd9084f96777626b65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xd07paXmNz8lsxu3XXUWBA.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">图5 —作为程序输入的整数数组</figcaption></figure><p id="4f08" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">很明显我们的数字没有放在正确的位置上。所以，让我们来看看最后一个数组——排序后的数组。</p><figure class="mt mu mv mw gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nm"><img src="../Images/d0e3b3178464ee94827fe0fadee6b9fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*siH7_ryUJ0J11fJx354Fig.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">图6 —预期的最终结果—排序后的数组</figcaption></figure><figure class="mt mu mv mw gt is gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/4d1081c58d1dc20ee8c5f9a605db5add.png" data-original-src="https://miro.medium.com/v2/resize:fit:478/format:webp/1*Xqf_QnZ9Em0s-e56xnX0WA.jpeg"/></div></figure><p id="8862" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们需要给我们一些时间，盯着这个数字，并尝试展示一些创造力，以便我们可以找到数字和它们的位置之间的关系。</p><p id="407e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc"> <em class="kw"> 2.1。找到每个数字</em> </strong>的正确(最终)位置</p><p id="21be" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你观察上图中的每个单元格，排序为的单元格，你会发现每个单元格的值等于它的最终单元格索引，如果，它减1。例如，第一个单元格保存数字1；如果我们将它减去1，将得到0，表示1所属的正确索引(或正确位置)。同样的规则也适用于数组中的其他单元格。</p><p id="021e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">注意</strong>，重要的是对预期结果做到以上几点。因为我们在这里的主要意图是两件事:</p><p id="4988" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">1)找出数组<br/>中每个数字的正确(最终)位置2)将该发现应用于程序的输入，即未排序的数组，这样我们就可以设计一个算法来将项目移动到它们正确的位置。</p><p id="a3b6" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请看下图，它形象地展示了我们刚刚取得的成果。</p><figure class="mt mu mv mw gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi no"><img src="../Images/dcbc6432d20715dd4ec8237f29d5e2c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yxu1BCvmRwoilz1rIwdFYg.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">图7 —找出数组中每个数字的正确位置(最终位置)</figcaption></figure><p id="ceb2" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc"> <em class="kw"> 2.2。考虑未排序(输入)数组</em> </strong>上的最终位置</p><p id="9473" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">既然我们知道谁应该在哪里；让我们再看一次我们的输入数组，看看我们如何应用我们的发现。</p><figure class="mt mu mv mw gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nl"><img src="../Images/179d229d00d91fdd9084f96777626b65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xd07paXmNz8lsxu3XXUWBA.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">图8 —输入阵列</figcaption></figure><p id="f4c6" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">实际上越来越有趣了——看看第一个数字:2。它必须放在索引或单元格1处。应用前面章节中的图形知识，我们可以表示从索引0到索引1的路径；换句话说，编号为2的索引0的值必须放在索引1中，因此，0 &gt; 1是路径。如果需要的话，给它一些时间来考虑，并确保你对这一点有信心。</p><p id="2f67" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这应该会给我们一些灵感来画出对我们的阵列的路径。下图显示了这些路径，直到它们到达一个循环。</p><figure class="mt mu mv mw gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi np"><img src="../Images/25276b462b11c9a0e26a473d91667a33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AD24rif7aphoHZc5GrT5WQ.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">图9 —解决方案表示；从图形的角度查看阵列并检测其中的循环</figcaption></figure><p id="9746" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个数字是问题的实际解决方案。考虑第一个周期:<br/> 0 &gt; 1 &gt; 0。也就是说，索引0处的元素必须放在索引1处，索引1处的元素必须放在索引0处，因此，交换元素将使它们按升序排序。本周期所需的总互换量为1。这个逻辑也适用于第二个周期，<br/> 2 &gt; 4 &gt; 3 &gt; 2，对于第二个周期，总交换数3将使其排序。因此，我们可以得出结论，<em class="kw"> f(掉期)=数量(节点)-1 </em>。如果我们简单地对每个周期的交换进行求和，我们将最终得到使数组按升序排序所需的最少交换。</p><p id="07a9" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">呜！做得好——如果你觉得有帮助，在烧代码之前，自己再做一次可能是值得的。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="bd98" class="le lf jb bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">编码时间— C#</h1><p id="fc72" class="pw-post-body-paragraph jy jz jb ka b kb me kd ke kf mf kh ki kj nq kl km kn nr kp kq kr ns kt ku kv ij bi translated">我们想要实现我们的解决方案，图9，以一种我们可以一个单元一个单元测试的方式。因此，我们将我们的解决方案分为两个不同的主要部分:</p><ol class=""><li id="5067" class="mc md jb ka b kb kc kf kg kj nt kn nu kr nv kv mj mk ml mm bi translated">负责生成循环的方法</li><li id="6294" class="mc md jb ka b kb mn kf mo kj mp kn mq kr mr kv mj mk ml mm bi translated">一个针对输入数组的循环，这样对于每一项我们都会考虑循环</li></ol><p id="d872" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们还希望跟踪我们访问过的节点，这样我们就可以避免一遍又一遍地计算相同的子问题，从而优化性能。关于这方面的更多信息，请阅读<a class="ae nw" rel="noopener ugc nofollow" target="_blank" href="/understanding-dynamic-programming-in-theory-and-practice-7835610ca485">我的关于动态编程的文章</a>。让我们看看魔术是什么样子的。</p><figure class="mt mu mv mw gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nx"><img src="../Images/1a2fb9c4da1b17c013d4f11c556aad01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3RjB4gCLYOy7hnTBzVDJ6Q.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">图10——负责检测循环并返回每个循环路径的方法</figcaption></figure><p id="599a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kw"> FindCyclesPaths </em>方法做了一件我们可以轻松编写单元测试来证明其正确性的事情。不用说，一旦我们到达一个循环，即第一个节点等于目的节点时，<em class="kw"> while </em>循环就会中断。例如，在图9中，第一个索引的目标是数组的第二个单元格。这个函数返回一个表示循环路径的节点列表，如图9所示。交换的计算不在此方法的范围内，因此，构建可测试的代码库。</p><p id="04a8" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们需要设置我们的main方法，该方法遍历输入数组，为每个未访问的节点调用<em class="kw"> FindCyclesPaths </em>。</p><figure class="mt mu mv mw gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ny"><img src="../Images/e064dcf6c448b607f337cc08513a51df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zbGY3MeoUPjwbv8i75Ckrw.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">图11——寻找最小所需互换的实际方法</figcaption></figure><p id="7d91" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如前所述，我们希望引入一种数据结构来存储被访问的节点。我们为此使用了一个布尔数组，它的长度与输入数组的长度相同，这里命名为numbers。默认情况下，C#将为每个索引填充<em class="kw"> false </em>值，因此无需手动操作。接下来，我们遍历我们的项目，并为我们访问的每个循环路径计算<em class="kw">交换</em>。最后，交换变量作为过程的结果返回。</p><p id="12f9" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">干得好！我们已经实现了这一点，而且<a class="ae nw" href="https://www.hackerrank.com/challenges/minimum-swaps-2/problem?h_r=internal-search" rel="noopener ugc nofollow" target="_blank"> HackerRank </a>也很喜欢它，因为它给这个解决方案打了满分。现在，让我们使用单元测试来确认代码的正确性。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h1 id="3f05" class="le lf jb bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">总是对你的算法进行单元测试</h1><p id="762e" class="pw-post-body-paragraph jy jz jb ka b kb me kd ke kf mf kh ki kj nq kl km kn nr kp kq kr ns kt ku kv ij bi translated">在这一步，我们将编写几个测试用例来证明基本的场景，我想把边缘用例留给读者来深入探讨。这是我们对周期检测函数的第一个单元测试，验证了图9中检测到的两个周期。</p><figure class="mt mu mv mw gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nz"><img src="../Images/5bb7877602d5f88846fb8fc6e25da0e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m8wANMvF0JLHbpkl0H_Mzg.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">图FindCyclesPath方法的单元测试</figcaption></figure><p id="4676" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后一个是我们的主要功能:</p><figure class="mt mu mv mw gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oa"><img src="../Images/2bbd9e44f872ae49bf93207dd0d98c3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AN5fS5dbx18JjOk9I4rC9Q.png"/></div></div><figcaption class="mx my gj gh gi mz na bd b be z dk translated">图FindMinSwaptoSortArray方法的单元测试</figcaption></figure></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><p id="c8f7" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就是全部——我们已经涉及了图论的一些概念，我们经历了一个中级算法问题，从图的角度看了一个数组排序问题，快速接触了<a class="ae nw" rel="noopener ugc nofollow" target="_blank" href="/understanding-dynamic-programming-in-theory-and-practice-7835610ca485"> DP编程</a>，并最终通过一些单元测试证明了其正确性。</p><p id="765b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">感谢你通读这篇文章，祝你编码愉快！🐱‍🏍</p></div></div>    
</body>
</html>