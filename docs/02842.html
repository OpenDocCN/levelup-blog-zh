<html>
<head>
<title>React and Web Workers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React和Web工作人员</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/react-and-web-workers-c9b60b4b6ae8?source=collection_archive---------3-----------------------#2020-04-07">https://levelup.gitconnected.com/react-and-web-workers-c9b60b4b6ae8?source=collection_archive---------3-----------------------#2020-04-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9621" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">如何在React应用程序中与Web工作者交互</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d7e9743ae8f265d7f6a65134d0d39cdc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zuX14URmAiO36mikljilOg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">托拜厄斯·图利乌斯在<a class="ae ky" href="https://unsplash.com/s/photos/free?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="1ed1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我每天分享<a class="ae ky" href="https://medium.com/@david.dalbusco/one-trick-a-day-d-34-469a0336a07e" rel="noopener">一个窍门</a>直到(可能不是)2020年4月19日新冠肺炎隔离期结束。离希望中的好日子还有12天。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="2355" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我最近发布了<a class="ae ky" href="https://tietracker.app.link" rel="noopener ugc nofollow" target="_blank">领带追踪器</a>，这是一款简单、开源的免费时间追踪应用⏱。</p><p id="b0ed" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在它的特性中，完全离线模式的开发尤其有趣。从架构的角度来看，我必须找到一个解决方案，在不阻塞用户界面的情况下，为了统计或导出的目的，计算用户可能记录的许多条目。</p><p id="7ba9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这就是为什么我想借助<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers" rel="noopener ugc nofollow" target="_blank"> Web Workers API </a>来解决我的问题。</p><p id="85fb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这个应用程序是用<a class="ae ky" href="https://ionicframework.com" rel="noopener ugc nofollow" target="_blank"> Ionic </a> + <a class="ae ky" href="https://reactjs.org" rel="noopener ugc nofollow" target="_blank"> React </a>开发的，所以让我跟你分享一下我的配方😉。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9fbc" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">模拟阻塞的用户界面</h1><p id="2be6" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">在试用Web Workers之前，让我们首先尝试开发一个小应用程序，它包含一个实际上阻塞用户界面的动作。</p><p id="69a8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下面的组件中，我们处理两种状态，两个计数器。其中一个在每次按钮点击时递增，而另一个调用函数<code class="fe mz na nb nc b">incApple()</code>，该函数循环一段时间，因此阻止用户交互。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="adbe" class="nh md it nc b gy ni nj l nk nl">import {<br/>    IonContent,<br/>    IonPage,<br/>    IonLabel,<br/>    IonButton<strong class="nc iu"><em class="nm"><br/></em></strong>} from '@ionic/react';<br/>import React, {useState} from 'react';<br/>import {RouteComponentProps} from 'react-router';<br/><br/>import './Page.css';<br/><br/>const Page: React.FC&lt;RouteComponentProps&lt;{ name: string; }&gt;&gt; = ({match}) =&gt; {<br/><br/>    const [countTomato, setCountTomato] = useState&lt;number&gt;(0);<br/>    const [countApple, setCountApple] = useState&lt;number&gt;(0);<br/><br/>    function incApple() {<br/>        const start = Date.now();<br/>        while (Date.now() &lt; start + 5000) {<br/>        }<br/>        setCountApple(countApple + 1);<br/>    }<br/><br/>    return (<br/>        &lt;IonPage&gt;<br/>            &lt;IonContent className="ion-padding"&gt;<br/>                &lt;IonLabel&gt;Tomato: {countTomato} | Apple: {countApple}&lt;/IonLabel&gt;<br/><br/>                &lt;div className="ion-padding-top"&gt;<br/>                    &lt;IonButton <br/>                     onClick={() =&gt; setCountTomato(countTomato + 1)}<br/>                     color="primary"&gt;Tomato&lt;/IonButton&gt;<br/>                    <br/>                    &lt;IonButton <br/>                     onClick={() =&gt; incApple()} <br/>                     color="secondary"&gt;Apple&lt;/IonButton&gt;<br/>                &lt;/div&gt;<br/>            &lt;/IonContent&gt;<br/>        &lt;/IonPage&gt;<br/>    );<br/>};<br/><br/>export default Page;</span></pre><p id="998a" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">正如您在下面的动画Gif中所注意到的，当我启动“苹果计数器”时，“番茄计数器”上的用户交互不再有任何效果，不会触发任何新的组件渲染，因为该函数当前正在阻塞JavaScript线程。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/9978ace6eb4c8a20c40f9ce7d4b3dc6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*UFSpBIR1gR1etkBkLdXRaA.gif"/></div></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="209a" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">推迟网络工作者的工作</h1><p id="a109" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">记住上面的例子，让我们尝试一下Web Workers，以便推迟我们的“苹果计数器”功能。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="d53d" class="nh md it bd me no np dn mi nq nr dp mm li ns nt mo lm nu nv mq lq nw nx ms ny bi translated">网络工作者</h2><p id="8b56" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">将Web Worker添加到您的应用程序的最简单的方法是将其作为资产发布。在我的Ionic React应用程序中，这些在目录<code class="fe mz na nb nc b">public</code>中找到位置，这是我们创建的一个新文件<code class="fe mz na nb nc b">./public/workers/apple.js</code>。</p><p id="b522" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在解释以下代码的流程之前，有两件事<strong class="lb iu">需要注意:</strong></p><ol class=""><li id="3db7" class="nz oa it lb b lc ld lf lg li ob lm oc lq od lu oe of og oh bi translated">应用程序和网络工作者是两回事。它们不共享状态，不共享库，它们是独立的，只能通过消息进行通信。</li><li id="ea4e" class="nz oa it lb b lc oi lf oj li ok lm ol lq om lu oe of og oh bi translated">网络工作者无法访问GUI、<code class="fe mz na nb nc b">document</code>和<code class="fe mz na nb nc b">window</code>。</li></ol><p id="e66c" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果你熟悉Firebase，在某种程度上，你可以把Web Worker理解为你自己的私有功能，不是云，而是本地功能。</p><p id="818d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们的web worker的入口点是<code class="fe mz na nb nc b">onmessage</code>,它基本上是一个从我们的应用程序触发的调用监听器。在我们正在注册的函数中，我们检查是否提供了相应的<code class="fe mz na nb nc b">msg</code>，这让我们可以将web worker用于多种用途，并且在运行与之前相同的函数<code class="fe mz na nb nc b">incApple()</code>之前，我们还修改了当前的计数器值。最后，我们不是直接更新状态，而是通过一个<code class="fe mz na nb nc b">postMessage</code>将值返回给应用程序。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="794a" class="nh md it nc b gy ni nj l nk nl">self.onmessage = async ($event) =&gt; {<br/>    if ($event &amp;&amp; $event.data &amp;&amp; $event.data.msg === 'incApple') {<br/>        const newCounter = incApple($event.data.countApple);<br/>        self.postMessage(newCounter);<br/>    }<br/>};<br/><br/>function incApple(countApple) {<br/>    const start = Date.now();<br/>    while (Date.now() &lt; start + 5000) {<br/>    }<br/>    return countApple + 1;<br/>}</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h2 id="d820" class="nh md it bd me no np dn mi nq nr dp mm li ns nt mo lm nu nv mq lq nw nx ms ny bi translated">与网络工作者互动</h2><p id="08dc" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">为了与web worker交互，我们首先需要向组件添加一个引用点。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="2eb6" class="nh md it nc b gy ni nj l nk nl">const appleWorker: Worker = new Worker('./workers/apple.js');</span></pre><p id="5931" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">因为我们使用消息进行通信，所以我们应该注册一个侦听器，当web worker发出一个结果时，它会负责更新计数器状态。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="1e57" class="nh md it nc b gy ni nj l nk nl">useEffect(() =&gt; {<br/>    appleWorker.onmessage = ($event: MessageEvent) =&gt; {<br/>        if ($event &amp;&amp; $event.data) {<br/>            setCountApple($event.data);<br/>        }<br/>    };<br/>}, [appleWorker]);</span></pre><p id="7542" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">最后，我们更新函数<code class="fe mz na nb nc b">incApple()</code>来调用web worker。</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="c488" class="nh md it nc b gy ni nj l nk nl">function incApple() {<br/>    appleWorker<br/>         .postMessage({msg: 'incApple', countApple: countApple});<br/>}</span></pre><p id="441f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Tada，就这样🎉。现在，即使“拦截器代码正在运行”，您也应该能够与GUI交互了。正如您在下面的动画Gif中所注意到的，即使阻塞循环是由web worker执行的，我仍然能够递增我的番茄计数器。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/f45fed8abb8e7a425e3fc289327a0d9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*ckzRpU3hVOmPyHw-of1u2w.gif"/></div></figure><p id="56c8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">组件，以备不时之需:</p><pre class="kj kk kl km gt nd nc ne nf aw ng bi"><span id="c178" class="nh md it nc b gy ni nj l nk nl">import {<br/>    IonContent,<br/>    IonPage,<br/>    IonLabel,<br/>    IonButton<br/>} from '@ionic/react';<br/>import React, {useEffect, useState} from 'react';<br/>import {RouteComponentProps} from 'react-router';<br/><br/>import './Page.css';<br/><br/>const Page: React.FC&lt;RouteComponentProps&lt;{ name: string; }&gt;&gt; = ({match}) =&gt; {<br/><br/>    const [countTomato, setCountTomato] = useState&lt;number&gt;(0);<br/>    const [countApple, setCountApple] = useState&lt;number&gt;(0);<br/><br/>    const appleWorker: Worker = new Worker('./workers/apple.js');<br/><br/>    useEffect(() =&gt; {<br/>        appleWorker.onmessage = ($event: MessageEvent) =&gt; {<br/>            if ($event &amp;&amp; $event.data) {<br/>                setCountApple($event.data);<br/>            }<br/>        };<br/>    }, [appleWorker]);<br/><br/>    function incApple() {<br/>        appleWorker<br/>            .postMessage({msg: 'incApple', countApple: countApple});<br/>    }<br/><br/>    return (<br/>        &lt;IonPage&gt;<br/>            &lt;IonContent className="ion-padding"&gt;<br/>                &lt;IonLabel&gt;Tomato: {countTomato} | Apple: {countApple}&lt;/IonLabel&gt;<br/><br/>                &lt;div className="ion-padding-top"&gt;<br/>                    &lt;IonButton <br/>                     onClick={() =&gt; setCountTomato(countTomato + 1)}<br/>                     color="primary"&gt;Tomato&lt;/IonButton&gt;<br/>                    <br/>                    &lt;IonButton <br/>                     onClick={() =&gt; incApple()} <br/>                     color="secondary"&gt;Apple&lt;/IonButton&gt;<br/>                &lt;/div&gt;<br/>            &lt;/IonContent&gt;<br/>        &lt;/IonPage&gt;<br/>    );<br/>};<br/><br/>export default Page;</span></pre></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="be11" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">摘要</h1><p id="d4a8" class="pw-post-body-paragraph kz la it lb b lc mu ju le lf mv jx lh li mw lk ll lm mx lo lp lq my ls lt lu im bi translated">Web Workers确实是一个有趣的概念。让我试验一下，我肯定会在未来的项目中再次使用它们。它的代码是开源的，可以在<a class="ae ky" href="https://github.com/peterpeterparker/tietracker" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得。如果你有任何反馈，甚至更好，有兴趣作出贡献，给我你最好的拉请求，这将是真棒😎。</p><p id="ad73" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">呆在家里，注意安全！</p><p id="4c77" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">大卫</p></div></div>    
</body>
</html>