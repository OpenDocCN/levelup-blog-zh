<html>
<head>
<title>The DOM and DOM Manipulation in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的DOM和DOM操作</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/the-dom-and-dom-manipulation-in-javascript-44a2f2aae316?source=collection_archive---------10-----------------------#2020-05-13">https://levelup.gitconnected.com/the-dom-and-dom-manipulation-in-javascript-44a2f2aae316?source=collection_archive---------10-----------------------#2020-05-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/51407c0ac9afa4edde3aaa1f829a92ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VFIcAw6Q26MOWbcCG_LdEA.png"/></div></div></figure><p id="b002" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">JavaScript的主要目的之一是与HTML元素交互。这就是为什么知道如何随心所欲地访问和操作这些元素是很重要的。</p><p id="bc55" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">JavaScript是一种基于对象的语言，绝大多数内置特性都是对象，HTML元素也不例外。<strong class="kd iu">文档对象模型</strong>或DOM是页面上当前可用的HTML元素的对象表示。</p><p id="2956" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在前端开发中，语言本身的所有东西都是全局对象<code class="fe kz la lb lc b">window</code>的属性，所以你可以通过<code class="fe kz la lb lc b">window.document</code>或者简单的<code class="fe kz la lb lc b">document</code>来访问DOM对象。</p><h1 id="aa52" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">那这个<code class="fe kz la lb lc b">document,</code>是什么？</h1><p id="db1d" class="pw-post-body-paragraph kb kc it kd b ke mb kg kh ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky im bi translated"><code class="fe kz la lb lc b">document</code>是<code class="fe kz la lb lc b">Node</code>类的实例，或者更准确地说是<code class="fe kz la lb lc b">Document</code>类的实例:你可以把DOM想象成一棵树，每个元素是一个节点，而<code class="fe kz la lb lc b">document</code>是根。</p><p id="a506" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe kz la lb lc b">Node</code>类提供HTML元素的属性和方法。您将能够访问元素的内容，并在它们的父元素和子元素之间移动。</p><p id="75c9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">注意<code class="fe kz la lb lc b">Node</code>类是很多其他类的超类，其中有<code class="fe kz la lb lc b">Document</code>和<code class="fe kz la lb lc b">Element</code>。这些允许您访问——在某些情况下修改HTML元素的属性，比如类、id和属性。此外，每个HTML标签都有自己的专门类，继承自<code class="fe kz la lb lc b">Element</code>，具有特定的方法和属性。</p><p id="611b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一个简单的例子:不是所有的元素都有一个<code class="fe kz la lb lc b">href</code>属性，这是锚标记的典型属性。锚点是<code class="fe kz la lb lc b">HTMLAnchorElement</code>的实例，包括<code class="fe kz la lb lc b">href</code>属性，而div是<code class="fe kz la lb lc b">HTMLDivElement</code>的实例，不包括<code class="fe kz la lb lc b">href</code>属性。因此，您将能够访问一个<code class="fe kz la lb lc b">a</code>元素的<code class="fe kz la lb lc b">href</code>属性，但是不能访问一个<code class="fe kz la lb lc b">div</code>元素的属性。</p><p id="3201" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后，<code class="fe kz la lb lc b">NodeList</code>是一个类似数组的结构，表示一列<code class="fe kz la lb lc b">Node</code>元素。尽管它<strong class="kd iu">不是一个真正的数组</strong> <em class="mg">，</em>它与它们有一些相似之处。事实上，用<code class="fe kz la lb lc b">for</code>循环或者使用<code class="fe kz la lb lc b">forEach</code>方法来迭代<code class="fe kz la lb lc b">NodeList</code>是可能的——只是要注意<a class="ae mh" href="https://developer.mozilla.org/en-US/docs/Web/API/NodeList#Browser_compatibility" rel="noopener ugc nofollow" target="_blank">浏览器兼容性问题</a>。</p><h1 id="4002" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">jQuery和普通JS</h1><p id="c734" class="pw-post-body-paragraph kb kc it kd b ke mb kg kh ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky im bi translated">使用原生特性操作DOM有时仍然不常见的原因是，不久前它们还很难使用，简单的算法可能需要许多行代码。</p><p id="851c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这就是jQuery迅速传播并被确认为最流行的DOM操纵JavaScript库的原因。</p><p id="47f0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如今，JavaScript对开发人员更加友好，并且弥补了过去的不足。虽然了解jQuery基础知识可能在工作环境中仍然有用，但软件公司正在迅速切换回普通的JS。这在性能方面也是一个优势，众所周知jQuery比原生JavaScript慢。</p><p id="0235" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们做一个快速简单的测试。假设我们有一个带有两个锚标记的HTML页面，我们想用和不用jQuery来检索它们。</p><pre class="mi mj mk ml gt mm lc mn mo aw mp bi"><span id="9728" class="mq le it lc b gy mr ms l mt mu">function getAnchorsWithJQuery() {<br/>  return $('a');<br/>}</span><span id="2c53" class="mq le it lc b gy mv ms l mt mu">function getAnchorsWithoutJQuery() {<br/>  return document.querySelectorAll('a');<br/>}</span><span id="9967" class="mq le it lc b gy mv ms l mt mu">console.time('jQuery');<br/>getAnchorsWithJQuery();<br/>console.timeEnd('jQuery');</span><span id="49ad" class="mq le it lc b gy mv ms l mt mu">console.time('Native');<br/>getAnchorsWithoutJQuery();<br/>console.timeEnd('Native');</span></pre><p id="c65a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我使用了<code class="fe kz la lb lc b">console.time</code>和<code class="fe kz la lb lc b">console.timeEnd</code>方法来实现一个简单的秒表，看看这两个函数执行起来需要多少时间。我做了几次测试，结果如下:</p><figure class="mi mj mk ml gt ju"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="b403" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">尽管如此少的执行不足以进行真正的分析，但是您可以看到本机代码通常执行得更好。在这个特定的例子中，它比jQuery快16倍。</p><h1 id="ed7e" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">JavaScript的复仇</h1><p id="6242" class="pw-post-body-paragraph kb kc it kd b ke mb kg kh ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky im bi translated">使用原生JavaScript特性，您需要做的一切都是可能的，如果它们不会给您的编码体验或最终结果带来实际好处，您就不需要任何库。</p><p id="4ce5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你是一个新手前端，这些是你绝对需要知道的几个<code class="fe kz la lb lc b">document</code>和<code class="fe kz la lb lc b">Element</code>方法。</p><h2 id="d88a" class="mq le it bd lf my mz dn lj na nb dp ln km nc nd lr kq ne nf lv ku ng nh lz ni bi translated">如何获取节点子元素</h2><p id="79f0" class="pw-post-body-paragraph kb kc it kd b ke mb kg kh ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky im bi translated"><code class="fe kz la lb lc b">querySelector</code>和<code class="fe kz la lb lc b">querySelectorAll</code>用于检索与给定的<em class="mg">选择器</em>匹配的节点的所有子元素。这非常方便，因为选择器就是CSS选择器:可以通过标签名、类、ID和属性来匹配元素，就像在级联样式表中一样。就这么简单！</p><pre class="mi mj mk ml gt mm lc mn mo aw mp bi"><span id="1d51" class="mq le it lc b gy mr ms l mt mu">// Retrieving the element by its ID<br/>const main = document.querySelector('#main');</span><span id="22c4" class="mq le it lc b gy mv ms l mt mu">// Retrieveng all paragraphs with the 'hidden' class inside the #main element<br/>const hiddenParagraphs = main.querySelectorAll('p.hidden');</span></pre><p id="fc3b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">请注意:</p><ul class=""><li id="6d34" class="nj nk it kd b ke kf ki kj km nl kq nm ku nn ky no np nq nr bi translated"><code class="fe kz la lb lc b">querySelector</code>总是返回子节点中第一个匹配的<code class="fe kz la lb lc b">Element</code>，或者<code class="fe kz la lb lc b">null</code>没有找到</li><li id="b2eb" class="nj nk it kd b ke ns ki nt km nu kq nv ku nw ky no np nq nr bi translated"><code class="fe kz la lb lc b">querySelectorAll</code>总是返回一个<code class="fe kz la lb lc b">NodeList</code>，如果没有找到匹配的元素，它的长度为<code class="fe kz la lb lc b">0</code></li><li id="3a0b" class="nj nk it kd b ke ns ki nt km nu kq nv ku nw ky no np nq nr bi translated">在这个例子中，<code class="fe kz la lb lc b">main</code>的值是<code class="fe kz la lb lc b">Element</code>类的一个实例，因此可以使用<code class="fe kz la lb lc b">querySelector</code>和<code class="fe kz la lb lc b">querySelectorAll</code>来检索它的子节点</li></ul><h2 id="7574" class="mq le it bd lf my mz dn lj na nb dp ln km nc nd lr kq ne nf lv ku ng nh lz ni bi translated">如何通过标签名、类或ID获取节点</h2><p id="60f2" class="pw-post-body-paragraph kb kc it kd b ke mb kg kh ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky im bi translated">您还可以通过元素的标记名、类或ID来检索元素。</p><pre class="mi mj mk ml gt mm lc mn mo aw mp bi"><span id="9657" class="mq le it lc b gy mr ms l mt mu">const main = document.getElementById('main');<br/>const hiddenParagraphs = main.getElementsByClassName('hidden');<br/>const paragraphs = main.getElementsByTagName('p');</span></pre><ul class=""><li id="4a3a" class="nj nk it kd b ke kf ki kj km nl kq nm ku nn ky no np nq nr bi translated"><code class="fe kz la lb lc b">getElementById</code>只能在<code class="fe kz la lb lc b">document</code>上使用，因为HTML页面中的ID必须是唯一的——它总是返回与给定ID匹配的<code class="fe kz la lb lc b">Element</code>,如果没有找到，则返回<code class="fe kz la lb lc b">null</code></li><li id="0739" class="nj nk it kd b ke ns ki nt km nu kq nv ku nw ky no np nq nr bi translated"><code class="fe kz la lb lc b">getElementsByClassName</code>总是返回一个<code class="fe kz la lb lc b">HTMLCollection</code>，一个类似数组的结构，包含所有匹配给定类的节点——注意<code class="fe kz la lb lc b">HTMLCollection</code>类似于<code class="fe kz la lb lc b">NodeList</code>，但是当DOM发生变化时，它的行为会有所不同(更多信息请阅读<a class="ae mh" href="https://developer.mozilla.org/docs/Web/API/HTMLCollection" rel="noopener ugc nofollow" target="_blank"> MDN文档</a></li><li id="7c55" class="nj nk it kd b ke ns ki nt km nu kq nv ku nw ky no np nq nr bi translated"><code class="fe kz la lb lc b">getElementsByTagName</code>总是返回一个包含所有匹配给定标签名的节点的<code class="fe kz la lb lc b">HTMLCollection</code></li></ul><h2 id="e6ef" class="mq le it bd lf my mz dn lj na nb dp ln km nc nd lr kq ne nf lv ku ng nh lz ni bi translated">如何创建元素并将其插入页面</h2><p id="8d59" class="pw-post-body-paragraph kb kc it kd b ke mb kg kh ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky im bi translated">最后，<code class="fe kz la lb lc b">document.createElement</code>方法允许您以编程方式创建元素。注意，用<code class="fe kz la lb lc b">createElement</code>创建的元素不会自动插入到DOM中:在您处理好它们的位置之前，它们不能通过前面的方法访问。看一看:</p><pre class="mi mj mk ml gt mm lc mn mo aw mp bi"><span id="56da" class="mq le it lc b gy mr ms l mt mu">const shoppingList = document.createElement('ul');<br/>const milkItem = document.createElement('li');<br/>const cerealsItem = document.createElement('li');</span><span id="c2eb" class="mq le it lc b gy mv ms l mt mu">milkItem.innerText = 'Milk';<br/>cerealsItem.innerText = 'Cereals';</span><span id="ba86" class="mq le it lc b gy mv ms l mt mu">document.body.appendChild(shoppingList);<br/>shoppingList.appendChild(cerealsItem);<br/>shoppingList.insertBefore(milkItem, cerealsItem);</span></pre><p id="2cd2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这个代码片段中，我创建了两个商品的购物清单:牛奶和谷物。我使用<code class="fe kz la lb lc b">createElement</code>初始化所有需要的HTML标签，然后在列表项中写一些有意义的文本，最后将它们放入页面:</p><ul class=""><li id="2882" class="nj nk it kd b ke kf ki kj km nl kq nm ku nn ky no np nq nr bi translated">通过<code class="fe kz la lb lc b">Node.appendChild</code>方法在页面<code class="fe kz la lb lc b">body</code>中添加<code class="fe kz la lb lc b">ul</code>标签</li><li id="8d14" class="nj nk it kd b ke ns ki nt km nu kq nv ku nw ky no np nq nr bi translated">第一项小时候的<code class="fe kz la lb lc b">ul</code></li><li id="1608" class="nj nk it kd b ke ns ki nt km nu kq nv ku nw ky no np nq nr bi translated">第二个项目作为<code class="fe kz la lb lc b">ul</code>的子项目，但是在前一个项目之前，通过<code class="fe kz la lb lc b">Node.insertBefore</code>方法</li></ul><p id="7010" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当然，你也可以删除元素。<code class="fe kz la lb lc b">Node.removeChild</code>方法用于从父节点中移除一个节点，如下所示:</p><pre class="mi mj mk ml gt mm lc mn mo aw mp bi"><span id="1d3b" class="mq le it lc b gy mr ms l mt mu">shoppingList.removeChild(milkItem);</span></pre><p id="ab3e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用纯JavaScript操作DOM变得比以前更加简单和容易。开发者社区意识到了这一点，现在他们正改变方向回到根本。</p><p id="0ff9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">不过，jQuery仍然被广泛使用，所以知道如何使用它仍然很重要。我个人的观点是，我们都应该尽可能使用JavaScript原生特性。您的项目将会执行得更好，并且您将会对这种美妙的编程语言有更好的了解。</p></div><div class="ab cl nx ny hx nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="im in io ip iq"><p id="3da3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">树是一种特殊的数据结构，你可以把它想象成一棵真正的树:第一个元素或<em class="mg">节点</em>是<em class="mg">根</em>，其他元素相互连接形成<em class="mg">分支</em>和<em class="mg">叶— </em> <a class="ae mh" href="https://en.wikipedia.org/wiki/Tree_(data_structure)" rel="noopener ugc nofollow" target="_blank">在维基百科上阅读更多信息</a></p><p id="e784" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在树形数据结构中，每个元素被称为一个节点，第一个元素，所有其他节点的祖先，被称为根节点</p><p id="7b48" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">超类是其他类继承属性和方法的类，在JavaScript中，<code class="fe kz la lb lc b">extend</code>关键字用于定义类之间的继承</p></div></div>    
</body>
</html>