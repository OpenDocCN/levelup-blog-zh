<html>
<head>
<title>Nuxt.js | How to retain Scroll Position when returning to page without Navigation History</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Nuxt.js |返回没有导航历史的页面时如何保留滚动位置</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/nuxt-js-how-to-retain-scroll-position-when-returning-to-page-without-navigation-history-7f0250886d27?source=collection_archive---------3-----------------------#2021-12-31">https://levelup.gitconnected.com/nuxt-js-how-to-retain-scroll-position-when-returning-to-page-without-navigation-history-7f0250886d27?source=collection_archive---------3-----------------------#2021-12-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="7a4e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Nuxt框架已经提供了一个特性，当用户点击浏览器的back按钮时，可以在返回到页面<strong class="jp ir">时保留滚动位置(或者我们使用<code class="fe kl km kn ko b">$router.go(n)</code>来触发相同的事件:<strong class="jp ir"> popstate navigation </strong>)。</strong></p><p id="0f7b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我当时面临的情况是，需要返回一个带有<code class="fe kl km kn ko b">$router.replace</code>而不是<code class="fe kl km kn ko b">$router.go(-1)</code>的页面(我在下面解释了这种需要的原因)。这个需求给我出了个问题:<code class="fe kl km kn ko b">$router.replace</code> <strong class="jp ir">不触发popstate事件</strong>，所以<strong class="jp ir">保持滚动位置</strong>不起作用，页面<strong class="jp ir">总是加载到顶部</strong>。</p><p id="c4b7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本文中，我将详细介绍这个解决方案。激励我写这篇文章的是我没有在谷歌上找到它，我希望它能帮助到某人。</p></div><div class="ab cl kp kq hu kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="ij ik il im in"><h1 id="bf20" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated"><strong class="ak">问题</strong></h1><p id="65d4" class="pw-post-body-paragraph jn jo iq jp b jq lu js jt ju lv jw jx jy lw ka kb kc lx ke kf kg ly ki kj kk ij bi translated">我来详细说说这个问题。我有一个页面，上面有很多卡片和一个登录按钮，这样用户就可以访问这些卡片的详细信息。假设你正在浏览，想登录。登录后，您希望返回您所在的位置。但是看看Nuxt的默认行为:</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi lz"><img src="../Images/4d26c1f423b6d71986f5dd75f4334af4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*ZJGkWJKBlKlXPKPe6EtKTA.gif"/></div></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">登录后，用户被重定向到顶部的上一页</figcaption></figure><p id="d430" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">认证</strong>后，用户返回到上一页，但是<strong class="jp ir">不再处于他在</strong>的位置。这种行为扰乱了用户体验。</p><p id="0be5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如我在本文开头所说，这个问题的发生是因为在我的<code class="fe kl km kn ko b">login.vue</code>中，我使用<code class="fe kl km kn ko b">$router.replace</code>而不是<code class="fe kl km kn ko b">$router.go(-1)</code>在登录后返回源页面。你可能想知道，为什么不使用<code class="fe kl km kn ko b">$router.go(-1)</code>来解决你的问题呢？使用<code class="fe kl km kn ko b">$router.replace</code>是必要的，这样<strong class="jp ir">用户就不能使用浏览器的后退按钮</strong>返回登录屏幕。<code class="fe kl km kn ko b">$router.go(-1)</code>允许这样。</p><h1 id="fa8f" class="kw kx iq bd ky kz mp lb lc ld mq lf lg lh mr lj lk ll ms ln lo lp mt lr ls lt bi translated"><strong class="ak">解决方案</strong></h1><p id="2b2c" class="pw-post-body-paragraph jn jo iq jp b jq lu js jt ju lv jw jx jy lw ka kb kc lx ke kf kg ly ki kj kk ij bi translated">我们将创建一个<strong class="jp ir">路由器中间件</strong>来<strong class="jp ir">存储</strong>具有<strong class="jp ir"> scrollPos元属性</strong>的页面的滚动位置(我们也将创建这个)。然后将Nuxt的<strong class="jp ir"> scrollBehavior </strong>更改为当scrollPos对象存在于route的meta属性中时，<strong class="jp ir">在对象中存储的位置</strong>加载页面。</p><h1 id="79f3" class="kw kx iq bd ky kz mp lb lc ld mq lf lg lh mr lj lk ll ms ln lo lp mt lr ls lt bi translated">1)在Nuxt路由器中添加元</h1><p id="09fb" class="pw-post-body-paragraph jn jo iq jp b jq lu js jt ju lv jw jx jy lw ka kb kc lx ke kf kg ly ki kj kk ij bi translated">在我们想要保留滚动位置的页面上，我们必须用以下对象创建<strong class="jp ir">元属性</strong>:</p><p id="26e5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mu">(在我的例子中，是有不同卡片的页面，我称之为</em> <code class="fe kl km kn ko b"><em class="mu">search.vue</em></code> <em class="mu"> ) </em></p><pre class="ma mb mc md gt mv ko mw mx aw my bi"><span id="d49c" class="mz kx iq ko b gy na nb l nc nd">//<strong class="ko ir">search.vue</strong></span><span id="8c5f" class="mz kx iq ko b gy ne nb l nc nd">export default {<br/> //...<br/><strong class="ko ir"> meta: {<br/>  scrollPos: {<br/>    x: 0,<br/>    y: 0<br/>  }<br/> }</strong><br/>}</span></pre><p id="aa73" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">逻辑如下，<strong class="jp ir">每一个有这个<strong class="jp ir"> scrollPos元属性</strong>的页面</strong>，我们将<strong class="jp ir">在这个对象中存储滚动位置</strong>。</p><h1 id="9f6b" class="kw kx iq bd ky kz mp lb lc ld mq lf lg lh mr lj lk ll ms ln lo lp mt lr ls lt bi translated">2)创建路由器中间件</h1><p id="816d" class="pw-post-body-paragraph jn jo iq jp b jq lu js jt ju lv jw jx jy lw ka kb kc lx ke kf kg ly ki kj kk ij bi translated">我们将创建一个路由器中间件来检查route是否有scollPos元属性，如果有，当离开页面时，滚动位置将存储在这个对象上。</p><p id="f165" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在您的Nuxt项目中，在文件<code class="fe kl km kn ko b"><strong class="jp ir">adjustScroll.js</strong></code>中创建一个名为<code class="fe kl km kn ko b"><strong class="jp ir">middleware</strong></code>的文件夹:</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/76072d6201d7ef75656b9da7896ee70c.png" data-original-src="https://miro.medium.com/v2/resize:fit:706/format:webp/1*o1GjkNrdvi_UeYF_zppFDg.png"/></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">中间件文件夹</figcaption></figure><p id="000b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将这段代码粘贴到<code class="fe kl km kn ko b"><strong class="jp ir">adjustScroll.js</strong></code>中:</p><pre class="ma mb mc md gt mv ko mw mx aw my bi"><span id="71d0" class="mz kx iq ko b gy na nb l nc nd">export default function({ from }) { <br/>  const scrollPos = from?.meta[0].scrollPos<br/>  if (scrollPos &amp;&amp; Object.keys(scrollPos).length &gt; 0) {<br/>    scrollPos.y = window.scrollY || 0<br/>    scrollPos.x = window.scrollX || 0<br/>  }<br/>}</span></pre><p id="3cce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们明白…这个功能会在我们每次在页面间导航时执行。它检查<strong class="jp ir"> scrollPos对象是否存在于<strong class="jp ir">元属性的数组</strong>中。如果是，它存储滚动位置。</strong></p><p id="cc19" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将该中间件包含在您的Nuxt设置中(<code class="fe kl km kn ko b"><strong class="jp ir">nuxt.config.js</strong></code>):</p><pre class="ma mb mc md gt mv ko mw mx aw my bi"><span id="80ee" class="mz kx iq ko b gy na nb l nc nd">//<strong class="ko ir">nuxt.config.js</strong></span><span id="dcf5" class="mz kx iq ko b gy ne nb l nc nd">export default {<br/>  //...<br/>  <strong class="ko ir">router: {<br/>    middleware: ['adjustScroll']<br/>  },</strong><br/>}</span></pre><p id="0fe1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好了，我们存储了滚动位置，现在当我们返回页面时，如何滚动呢？下一个话题再看。</p><h1 id="e775" class="kw kx iq bd ky kz mp lb lc ld mq lf lg lh mr lj lk ll ms ln lo lp mt lr ls lt bi translated">3)页面加载后的自定义滚动行为</h1><p id="d08b" class="pw-post-body-paragraph jn jo iq jp b jq lu js jt ju lv jw jx jy lw ka kb kc lx ke kf kg ly ki kj kk ij bi translated">Nuxt允许我们自定义页面加载后的滚动行为。这就是我们在这里要做的，当meta属性中有scrollPos对象时，我们将<strong class="jp ir">将页面</strong>滚动到该对象中存储的值<strong class="jp ir">。</strong></p><p id="b26f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在您的Nuxt项目中，创建一个名为<code class="fe kl km kn ko b"><strong class="jp ir">app</strong></code> <strong class="jp ir"> </strong>的文件夹，并放在文件<code class="fe kl km kn ko b"><strong class="jp ir">router.scrollBehavior.js</strong></code>中:</p><figure class="ma mb mc md gt me gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/fae4848e3652e2e4943f78aa564c8710.png" data-original-src="https://miro.medium.com/v2/resize:fit:688/format:webp/1*Isetaxohj49MFLfOAS94yw.png"/></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">应用程序文件夹</figcaption></figure><p id="863c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个文件允许我们<strong class="jp ir">改变</strong>Nuxt的<strong class="jp ir">默认滚动行为。由于<strong class="jp ir">不允许我们扩展</strong>，因此<a class="ae nh" href="https://nuxtjs.org/docs/configuration-glossary/configuration-router/#scrollbehavior" rel="noopener ugc nofollow" target="_blank">文档</a>建议在处更改<a class="ae nh" href="https://github.com/nuxt/nuxt.js/blob/dev/packages/vue-app/template/router.scrollBehavior.js" rel="noopener ugc nofollow" target="_blank">中的默认Nuxt代码。</a></strong></p><p id="764f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我对这段代码做了一些补充，以适应我们的需要，并改变了nuxt变量声明的位置。将以下代码复制并粘贴到文件(<code class="fe kl km kn ko b"><strong class="jp ir">router.scrollBehavior.js</strong></code>)中:</p><blockquote class="ni nj nk"><p id="87c0" class="jn jo mu jp b jq jr js jt ju jv jw jx nl jz ka kb nm kd ke kf nn kh ki kj kk ij bi translated">你的<strong class="jp ir"> linter </strong>会<strong class="jp ir">抱怨</strong>一些<strong class="jp ir"> Nuxt自己的内部模板语法</strong>，你可以忽略这些。</p></blockquote><pre class="ma mb mc md gt mv ko mw mx aw my bi"><span id="a700" class="mz kx iq ko b gy na nb l nc nd">//<strong class="ko ir">router.scrollBehavior.js</strong></span><span id="d7ea" class="mz kx iq ko b gy ne nb l nc nd">&lt;% if (router.scrollBehavior) { %&gt;<br/>&lt;%= isTest ? '/* eslint-disable quotes, semi, indent, comma-spacing, key-spacing, object-curly-spacing, space-before-function-paren  */' : '' %&gt;<br/>export default &lt;%= serializeFunction(router.scrollBehavior) %&gt;<br/>&lt;%= isTest ? '/* eslint-enable quotes, semi, indent, comma-spacing, key-spacing, object-curly-spacing, space-before-function-paren  */' : '' %&gt;<br/>&lt;% } else { %&gt;import { getMatchedComponents, setScrollRestoration } from './utils'</span><span id="8a02" class="mz kx iq ko b gy ne nb l nc nd">if (process.client) {<br/>  if ('scrollRestoration' in window.history) {<br/>    setScrollRestoration('manual')</span><span id="d26e" class="mz kx iq ko b gy ne nb l nc nd">// reset scrollRestoration to auto when leaving page, allowing page reload<br/>    // and back-navigation from other pages to use the browser to restore the<br/>    // scrolling position.<br/>    window.addEventListener('beforeunload', () =&gt; {<br/>      setScrollRestoration('auto')<br/>    })</span><span id="c36b" class="mz kx iq ko b gy ne nb l nc nd">// Setting scrollRestoration to manual again when returning to this page.<br/>    window.addEventListener('load', () =&gt; {<br/>      setScrollRestoration('manual')<br/>    })<br/>  }<br/>}</span><span id="60e3" class="mz kx iq ko b gy ne nb l nc nd">function shouldScrollToTop(route) {<br/>   const Pages = getMatchedComponents(route)<br/>   if (Pages.length === 1) {<br/>     const { options = {} } = Pages[0]<br/>     return options.scrollToTop !== false<br/>   }<br/>   return Pages.some(({ options }) =&gt; options &amp;&amp; options.scrollToTop)<br/>}</span><span id="1bc8" class="mz kx iq ko b gy ne nb l nc nd">export default function (to, from, savedPosition) {<br/>  // If the returned position is falsy or an empty object, will retain current scroll position<br/>  let position = false<br/>  const isRouteChanged = to !== from</span><span id="a624" class="mz kx iq ko b gy ne nb l nc nd">const nuxt = window.&lt;%= globals.nuxt %&gt;</span><span id="7dc0" class="mz kx iq ko b gy ne nb l nc nd">// savedPosition is only available for popstate navigations (back button)<br/>  const metaScrollPos = nuxt.context.route.meta[0]?.scrollPos <br/>  if (savedPosition || metaScrollPos) {<br/>    position = savedPosition || metaScrollPos<br/>  } else if (isRouteChanged &amp;&amp; shouldScrollToTop(to)) {<br/>    position = { x: 0, y: 0 }<br/>  }</span><span id="20f3" class="mz kx iq ko b gy ne nb l nc nd">if (<br/>    // Initial load (vuejs/vue-router#3199)<br/>    !isRouteChanged ||<br/>    // Route hash changes<br/>    (to.path === from.path &amp;&amp; to.hash !== from.hash)<br/>  ) {<br/>    nuxt.$nextTick(() =&gt; nuxt.$emit('triggerScroll'))<br/>  }</span><span id="fb79" class="mz kx iq ko b gy ne nb l nc nd">return new Promise((resolve) =&gt; {<br/>    // wait for the out transition to complete (if necessary)<br/>    nuxt.$once('triggerScroll', () =&gt; {<br/>      // coords will be used if no selector is provided,<br/>      // or if the selector didn't match any element.<br/>      if (to.hash) {<br/>        let hash = to.hash<br/>        // CSS.escape() is not supported with IE and Edge.<br/>        if (typeof window.CSS !== 'undefined' &amp;&amp; typeof window.CSS.escape !== 'undefined') {<br/>          hash = '#' + window.CSS.escape(hash.substr(1))<br/>        }<br/>        try {<br/>          const el = document.querySelector(hash)<br/>          if (el) {<br/>            // scroll to anchor by returning the selector<br/>            position = { selector: hash }<br/>            // Respect any scroll-margin-top set in CSS when scrolling to anchor<br/>            const y = Number(getComputedStyle(el)['scroll-margin-top']?.replace('px', ''))<br/>            if (y) {<br/>              position.offset = { y }<br/>            }<br/>          }<br/>        } catch (e) {<br/>          &lt;%= isTest ? '// eslint-disable-next-line no-console' : '' %&gt;<br/>          console.warn('Failed to save scroll position. Please add CSS.escape() polyfill (<a class="ae nh" href="https://github.com/mathiasbynens/CSS.escape).'" rel="noopener ugc nofollow" target="_blank">https://github.com/mathiasbynens/CSS.escape).'</a>)<br/>        }<br/>      }<br/>      resolve(position)<br/>    })<br/>  })<br/>}<br/>&lt;% } %&gt;</span></pre><p id="2b64" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面我突出显示了默认模板中我修改了的部分<strong class="jp ir">。我们来了解一下。</strong></p><p id="cc5d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我改变了nuxt变量声明的<strong class="jp ir">位置(在默认模板中，它出现在这个条件下面)。这个变量存储了<strong class="jp ir"> Nuxt上下文</strong>，因为我们需要在下面的条件中访问它，所以我改变了声明的位置。</strong></p><p id="d7dc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第二个变化是在条件句中。我们检查在路由的元属性中是否有一个scrollPos对象。如果是这样，我们将存储的值传递给位置变量(它决定滚动)。</p><pre class="ma mb mc md gt mv ko mw mx aw my bi"><span id="c4da" class="mz kx iq ko b gy na nb l nc nd">//..</span><span id="2845" class="mz kx iq ko b gy ne nb l nc nd"><strong class="ko ir">const nuxt = window.&lt;%= globals.nuxt %&gt;</strong></span><span id="7376" class="mz kx iq ko b gy ne nb l nc nd">// savedPosition is only available for popstate navigations (back button)<br/><strong class="ko ir">  const metaScrollPos = nuxt.context.route.meta[0]?.scrollPos <br/>  if (savedPosition || metaScrollPos) {<br/>    position = savedPosition || metaScrollPos<br/>  } else if (isRouteChanged &amp;&amp; shouldScrollToTop(to)) {<br/>    position = { x: 0, y: 0 }<br/>  }</strong></span><span id="a583" class="mz kx iq ko b gy ne nb l nc nd">//...</span></pre><p id="6fe2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的解决方案是完整的。<strong class="jp ir">在元属性</strong>中有<strong class="jp ir"> scrollPos对象的每个页面</strong>将<strong class="jp ir">存储滚动位置</strong>以备我们返回时使用。如果在某个时候你想让这个页面<strong class="jp ir">加载到顶部</strong>，只需通过编程将scrollPos对象更改为{ x: 0，y: 0}</p><h1 id="78f0" class="kw kx iq bd ky kz mp lb lc ld mq lf lg lh mr lj lk ll ms ln lo lp mt lr ls lt bi translated">最后，我们的中间件运行了</h1><figure class="ma mb mc md gt me gh gi paragraph-image"><div role="button" tabindex="0" class="mf mg di mh bf mi"><div class="gh gi lz"><img src="../Images/af99f8ee0fff3869e1d3822ccab6b181.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Pu2EnGW5DF1jSBSK63RMeQ.gif"/></div></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk translated">在没有导航历史记录页面之间导航时保留滚动位置</figcaption></figure><p id="aa36" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在登录后的用户返回到他最初的滚动位置:)</p></div></div>    
</body>
</html>