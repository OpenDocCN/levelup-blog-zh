<html>
<head>
<title>Svelte — Flexible Data Handling</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">苗条——灵活的数据处理</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/svelte-flexible-data-handling-c0010cc14e5b?source=collection_archive---------6-----------------------#2021-09-28">https://levelup.gitconnected.com/svelte-flexible-data-handling-c0010cc14e5b?source=collection_archive---------6-----------------------#2021-09-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="10a7" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Svelte及其处理异步数据的技术介绍</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/9738f4405eea706588997b47f95a83e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Fs6c9FqtEx02rusL"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">费伦茨·阿尔马西在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><h1 id="cc86" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">内容</h1><ul class=""><li id="a465" class="lo lp iq lq b lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated"><a class="ae kv" href="#8c1b" rel="noopener ugc nofollow">简介</a></li><li id="6a5e" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated"><a class="ae kv" href="#1c4e" rel="noopener ugc nofollow">先决条件</a></li><li id="de45" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated"><a class="ae kv" href="#2bb0" rel="noopener ugc nofollow">什么是苗条</a></li><li id="a343" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated"><a class="ae kv" href="#e01a" rel="noopener ugc nofollow">处理&lt;脚本&gt; </a>中的异步数据</li><li id="7065" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated"><a class="ae kv" href="#1e05" rel="noopener ugc nofollow">处理标记中的异步数据</a></li></ul></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><p id="8c1b" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">Svelte相对较新，但组件框架越来越受欢迎，因为它提供了超越Angular、React和Vue等其他框架的独特优势。本文介绍了Svelte及其处理异步数据的技术。</p><h1 id="1c4e" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">先决条件</h1><p id="13bd" class="pw-post-body-paragraph ms mt iq lq b lr ls jr mv lt lu ju mx lv nh mz na lx ni nc nd lz nj nf ng mb ij bi translated">请注意这篇文章:</p><ul class=""><li id="44b6" class="lo lp iq lq b lr mu lt mw lv nk lx nl lz nm mb mc md me mf bi translated">需要HTML和JavaScript概念的基础知识。</li><li id="c746" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated">不包括建立一个苗条的项目。同样参考<a class="ae kv" href="https://svelte.dev/blog/the-easiest-way-to-get-started" rel="noopener ugc nofollow" target="_blank">本</a>资源。</li></ul><h1 id="2bb0" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">什么是苗条</h1><p id="faac" class="pw-post-body-paragraph ms mt iq lq b lr ls jr mv lt lu ju mx lv nh mz na lx ni nc nd lz nj nf ng mb ij bi translated">Svelte是一个组件框架——像React或Vue——但有一个重要的区别。React和Vue等传统框架在应用运行时在用户浏览器中完成大部分工作。Svelte将这项工作转变为编译步骤，在构建应用程序时进行。因此，Svelte产生了高度优化的普通JavaScript。</p><p id="b317" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">Svelte的主要卖点是:</p><ul class=""><li id="42b0" class="lo lp iq lq b lr mu lt mw lv nk lx nl lz nm mb mc md me mf bi translated"><strong class="lq ir">性能提升</strong> —在构建时运行，不使用<a class="ae kv" href="https://reactjs.org/docs/reconciliation.html" rel="noopener ugc nofollow" target="_blank">虚拟DOM diffing </a>。</li><li id="7f28" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated"><strong class="lq ir">没有样板代码</strong> — Svelte使你能够编写没有样板的组件。</li><li id="90a7" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated"><strong class="lq ir">简化的状态管理</strong> — Svelte不需要外部状态管理库。</li></ul><p id="4b0f" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">像任何框架一样，Svelte也有它的怪癖。然而，Svelte也与其他框架有许多相似之处。下面的列表并不详尽，但对于本文来说已经足够了:</p><ul class=""><li id="306e" class="lo lp iq lq b lr mu lt mw lv nk lx nl lz nm mb mc md me mf bi translated">一个苗条的文件可以有两个部分。<strong class="lq ir"> &lt;脚本&gt; </strong> — JavaScript代码<br/> 2。<strong class="lq ir">标记</strong> —要显示的HTML(标记中的花括号可以包含任何<br/> JavaScript代码)</li></ul><pre class="kg kh ki kj gt nn no np nq aw nr bi"><span id="437b" class="ns kx iq no b gy nt nu l nv nw">&lt;script&gt;<br/>  let name = ‘world’;<br/>&lt;/script&gt;</span><span id="fab8" class="ns kx iq no b gy nx nu l nv nw">&lt;h1&gt;Hello {name}!&lt;/h1&gt;</span><span id="bfca" class="ns kx iq no b gy nx nu l nv nw"><strong class="no ir">Output</strong>:<br/>Hello world!</span></pre><ul class=""><li id="eb2e" class="lo lp iq lq b lr mu lt mw lv nk lx nl lz nm mb mc md me mf bi translated">您可以使用props将数据传递给子组件。例如，<code class="fe ny nz oa no b">Users</code>组件可以通过属性<code class="fe ny nz oa no b">users</code>将数据传递给其子组件<code class="fe ny nz oa no b">UserList</code>。</li></ul><p id="1290" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated"><code class="fe ny nz oa no b">&lt;UserList users={users} /&gt;</code></p><ul class=""><li id="532f" class="lo lp iq lq b lr mu lt mw lv nk lx nl lz nm mb mc md me mf bi translated">另外，Svelte需要你在<code class="fe ny nz oa no b">UserList</code>中声明道具用户。</li></ul><pre class="kg kh ki kj gt nn no np nq aw nr bi"><span id="d17a" class="ns kx iq no b gy nt nu l nv nw">&lt;script&gt;<br/>  export let users;<br/>&lt;/script&gt;</span></pre><ul class=""><li id="7bce" class="lo lp iq lq b lr mu lt mw lv nk lx nl lz nm mb mc md me mf bi translated">Svelte有<strong class="lq ir">生命周期方法</strong>来管理代码执行，有<strong class="lq ir">逻辑块</strong>来表达标记中的逻辑。在接下来的章节中会有更多的介绍。</li></ul></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><p id="ef60" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">在以下部分中:</p><ul class=""><li id="ae10" class="lo lp iq lq b lr mu lt mw lv nk lx nl lz nm mb mc md me mf bi translated"><code class="fe ny nz oa no b">Users</code>是获取和发送数据的父组件。</li><li id="43cb" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated"><code class="fe ny nz oa no b">UserList</code>是接收数据的子组件。</li></ul><h1 id="e01a" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">在<script>中处理异步数据&lt;/root&gt;</script></h1><p id="7b70" class="pw-post-body-paragraph ms mt iq lq b lr ls jr mv lt lu ju mx lv nh mz na lx ni nc nd lz nj nf ng mb ij bi translated"><strong class="lq ir"> &lt;脚本&gt; </strong>中处理数据的代码与其他框架类似。在将父组件中的异步数据传递给子组件之前，需要对其进行T4。</p><p id="8a46" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">因此，父组件<code class="fe ny nz oa no b">Users</code>看起来是这样的:</p><pre class="kg kh ki kj gt nn no np nq aw nr bi"><span id="5878" class="ns kx iq no b gy nt nu l nv nw">&lt;script&gt;<br/>  import UserList from ‘./UserList.svelte’;<br/>  import { onMount } from ‘svelte’;</span><span id="e774" class="ns kx iq no b gy nx nu l nv nw">  let users = [];</span><span id="3c39" class="ns kx iq no b gy nx nu l nv nw">  onMount(async () =&gt; {<br/>    const res = await fetch(`<a class="ae kv" href="https://api.github.com/users`" rel="noopener ugc nofollow" target="_blank">https://api.github.com/users`</a>);<br/>    users = await res.json();<br/>  });<br/>&lt;/script&gt;</span><span id="67d9" class="ns kx iq no b gy nx nu l nv nw">&lt;UserList {users} /&gt; // users = {users} can be shortened to {users}</span></pre><p id="efef" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">上面的代码使用了<code class="fe ny nz oa no b">onMount</code>生命周期方法。用Svelte编码的时候，你会用的最多的是<code class="fe ny nz oa no b">onMount</code>。<code class="fe ny nz oa no b">onMount</code>中的代码在组件第一次呈现到DOM后运行。</p><p id="388f" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated"><strong class="lq ir">注意</strong> — Svelte建议将<code class="fe ny nz oa no b">fetch</code>放在<code class="fe ny nz oa no b">onMount</code>而不是<strong class="lq ir"> &lt;脚本&gt; </strong>的顶层，以确保<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/Performance/Lazy_loading" rel="noopener ugc nofollow" target="_blank">延迟加载</a>。</p><p id="dd7a" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">除了<code class="fe ny nz oa no b">onMount</code>，Svelte还有以下生命周期方法来管理代码执行:</p><ul class=""><li id="60c7" class="lo lp iq lq b lr mu lt mw lv nk lx nl lz nm mb mc md me mf bi translated"><strong class="lq ir"> onDestroy </strong> —当组件被破坏时运行</li><li id="7879" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated"><strong class="lq ir">更新前</strong> —在DOM更新前立即运行</li><li id="4b6b" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated"><strong class="lq ir"> afterUpdate </strong> —在DOM与您的数据同步后运行</li></ul><p id="166f" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">子组件<code class="fe ny nz oa no b">UserList</code>:</p><pre class="kg kh ki kj gt nn no np nq aw nr bi"><span id="66ca" class="ns kx iq no b gy nt nu l nv nw">&lt;script&gt;<br/>  export let users;<br/>&lt;/script&gt;</span><span id="9080" class="ns kx iq no b gy nx nu l nv nw">{#each users as { login, repos_url }}<br/>  &lt;h4&gt;{login}&lt;/h4&gt;<br/>  &lt;p&gt;{repos_url}&lt;/p&gt;<br/>{/each}</span></pre><p id="71da" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">上面的代码使用<code class="fe ny nz oa no b">each</code>逻辑块遍历数据列表。</p><h1 id="1e05" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">处理标记中的异步数据</h1><p id="4455" class="pw-post-body-paragraph ms mt iq lq b lr ls jr mv lt lu ju mx lv nh mz na lx ni nc nd lz nj nf ng mb ij bi translated">当您构建稍微复杂到复杂的应用程序时，您可能会遇到这样的情况:</p><ul class=""><li id="bbac" class="lo lp iq lq b lr mu lt mw lv nk lx nl lz nm mb mc md me mf bi translated">当组件挂载时，不需要处理异步数据。</li><li id="3c0e" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated">需要用户操作来确定要提取的数据。</li><li id="6b41" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated">需要在等待异步操作完成时显示其他数据。</li></ul><p id="1a96" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">你可以在<strong class="lq ir"> &lt;脚本&gt; </strong>部分处理上述(以及其他熟悉的场景)。然而，使用Svelte，您可以用最少的代码和扩展来处理<strong class="lq ir">标记</strong>部分中的异步数据。</p><p id="3509" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">坚持本文中的场景，考虑一个函数<code class="fe ny nz oa no b">getUsers </code>——包含获取数据的逻辑——分配给父组件中的prop变量。</p><p id="fd5f" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">父组件<code class="fe ny nz oa no b">Users</code>:</p><pre class="kg kh ki kj gt nn no np nq aw nr bi"><span id="202c" class="ns kx iq no b gy nt nu l nv nw">&lt;script&gt;<br/>  import UserList from ‘./UserList.svelte’;</span><span id="173c" class="ns kx iq no b gy nx nu l nv nw">  const getUsers = async () =&gt; {<br/>    const res = await fetch(`<a class="ae kv" href="https://api.github.com/users`" rel="noopener ugc nofollow" target="_blank">https://api.github.com/users`</a>);<br/>    return await res.json();<br/>  };</span><span id="0123" class="ns kx iq no b gy nx nu l nv nw">  const users = getUsers();<br/>&lt;/script&gt;</span><span id="37aa" class="ns kx iq no b gy nx nu l nv nw">&lt;UserList {users} /&gt;</span></pre><p id="9320" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">在子组件<code class="fe ny nz oa no b">UserList</code>中，您只需要将<code class="fe ny nz oa no b">each</code>块包装在<code class="fe ny nz oa no b">await</code>块中来处理异步数据:</p><pre class="kg kh ki kj gt nn no np nq aw nr bi"><span id="d745" class="ns kx iq no b gy nt nu l nv nw">&lt;script&gt;<br/>  export let users;<br/>&lt;/script&gt;</span><span id="a16f" class="ns kx iq no b gy nx nu l nv nw">{#await users}<br/>  &lt;p&gt;loading…&lt;/p&gt;<br/>{:then users}<br/>  {#each users as { login, repos_url }}<br/>    &lt;h4&gt;{login}&lt;/h4&gt;<br/>    &lt;p&gt;{repos_url}&lt;/p&gt;<br/>  {/each}<br/>{:catch error}<br/>  &lt;p&gt;{error.message}&lt;/p&gt;<br/>{/await}</span></pre><p id="b359" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">此外，<code class="fe ny nz oa no b">then</code>和<code class="fe ny nz oa no b">catch</code>块可以和<code class="fe ny nz oa no b">await</code>一起使用来复制JavaScript代码流。</p><p id="1b07" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">除了<code class="fe ny nz oa no b">await</code>和<code class="fe ny nz oa no b">each</code>之外，Svelte还有以下逻辑块来处理条件:</p><ul class=""><li id="1091" class="lo lp iq lq b lr mu lt mw lv nk lx nl lz nm mb mc md me mf bi translated"><strong class="lq ir">如果</strong></li><li id="a368" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated"><strong class="lq ir">否则</strong></li><li id="4915" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated"><strong class="lq ir">否则-如果</strong></li></ul><p id="4e9c" class="pw-post-body-paragraph ms mt iq lq b lr mu jr mv lt mw ju mx lv my mz na lx nb nc nd lz ne nf ng mb ij bi translated">这就是了。您现在知道了什么是Svelte，以及如何在Svelte中处理异步数据。</p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="0eec" class="kw kx iq bd ky kz ob lb lc ld oc lf lg jw od jx li jz oe ka lk kc of kd lm ln bi translated">来源</h1><ul class=""><li id="299b" class="lo lp iq lq b lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated"><em class="og">苗条的</em>。<a class="ae kv" href="https://svelte.dev" rel="noopener ugc nofollow" target="_blank"> https://svelte.dev </a></li><li id="fb84" class="lo lp iq lq b lr mg lt mh lv mi lx mj lz mk mb mc md me mf bi translated"><em class="og">苗条3:反思反应性</em>。【https://svelte.dev/blog/svelte-3-rethinking-reactivity】</li></ul></div></div>    
</body>
</html>