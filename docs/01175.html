<html>
<head>
<title>Limit concurrency with RxJS and Promises</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用RxJS和Promises限制并发</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/limit-concurrency-with-rxjs-and-promises-78590d2c85d0?source=collection_archive---------4-----------------------#2019-11-22">https://levelup.gitconnected.com/limit-concurrency-with-rxjs-and-promises-78590d2c85d0?source=collection_archive---------4-----------------------#2019-11-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="4801" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最近，我需要抑制对一个内部API的调用。用例是我们接收一个<code class="fe ko kp kq kr b">ids</code>列表，并需要为这些id中的每一个调用一个API。因为我们使用承诺，我们最终会用大量并行API调用淹没API。</p><p id="4f72" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有很多文章都在谈论如何使用<code class="fe ko kp kq kr b">debounce</code>和它的朋友来<em class="ks">限制</em>你的通话。虽然对于某些用例来说这是一个选项，但我真的想要一个解决方案，通过总是并行发送X个请求来允许我们最大化并发性。</p><h1 id="8354" class="kt ku it bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">我们的设置</h1><p id="8c0f" class="pw-post-body-paragraph jq jr it js b jt lr jv jw jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn im bi translated">我们的环境是带有TypeScript的NodeJS。我们使用<code class="fe ko kp kq kr b"><a class="ae lw" href="https://github.com/request/request-promise-native" rel="noopener ugc nofollow" target="_blank">request-promise-native</a></code>作为<code class="fe ko kp kq kr b"><a class="ae lw" href="https://github.com/request/request" rel="noopener ugc nofollow" target="_blank">request</a></code>的一个很好的承诺支持包装器。</p><p id="bf45" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你不熟悉<code class="fe ko kp kq kr b">request</code>(更准确地说是<code class="fe ko kp kq kr b">request-promise</code>)，一个简单的API调用看起来像这样:</p><figure class="lx ly lz ma gt mb"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="6e3b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了获得更真实的体验，我们将调用<code class="fe ko kp kq kr b">httpbin.org</code>并取回我们的查询参数。这将让我们看到请求实际上是何时发起的，以及它的结果是何时返回的。<code class="fe ko kp kq kr b">getData()</code>方法看起来像这样:</p><figure class="lx ly lz ma gt mb"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="9893" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们的id列表是使用StackOverflow上的<a class="ae lw" href="https://twitter.com/BenMcDonald___" rel="noopener ugc nofollow" target="_blank"> Ben McDonald </a>的这个<a class="ae lw" href="https://stackoverflow.com/a/10050831/80280" rel="noopener ugc nofollow" target="_blank">巧妙技巧</a>生成的:</p><pre class="lx ly lz ma gt me kr mf mg aw mh bi"><span id="bce6" class="mi ku it kr b gy mj mk l ml mm">const ids = [...Array(20).keys()];</span></pre><h1 id="e5cd" class="kt ku it bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">问题是</h1><p id="2cd5" class="pw-post-body-paragraph jq jr it js b jt lr jv jw jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn im bi translated">如果你采用通用的方法，通过<code class="fe ko kp kq kr b">Promise.all()</code>并行地为每个<code class="fe ko kp kq kr b">id</code>执行<code class="fe ko kp kq kr b">getData()</code>，你最终会得到所有同时开始<em class="ks">的请求</em>。</p><pre class="lx ly lz ma gt me kr mf mg aw mh bi"><span id="909c" class="mi ku it kr b gy mj mk l ml mm">const results = await Promise.all(ids.map(x =&gt; getData(x)));</span></pre><h1 id="f117" class="kt ku it bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">RxJS</h1><p id="a676" class="pw-post-body-paragraph jq jr it js b jt lr jv jw jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn im bi translated"><code class="fe ko kp kq kr b">RxJs</code>有一个名为<code class="fe ko kp kq kr b"><a class="ae lw" href="https://rxjs-dev.firebaseapp.com/api/operators/mergeAll" rel="noopener ugc nofollow" target="_blank">mergeAll</a></code>的非常有用的操作符，它使用一个<code class="fe ko kp kq kr b">concurrent</code>参数来限制被订阅的内部可观察对象的数量。<br/> 这正是我们想要的。因此，您只需获取<code class="fe ko kp kq kr b"><a class="ae lw" href="https://rxjs-dev.firebaseapp.com/api/index/function/from" rel="noopener ugc nofollow" target="_blank">from</a></code>创建者并生成一个RxJs版本。</p><figure class="lx ly lz ma gt mb"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="c164" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在那里，我们告诉RxJs一次只订阅5个observables。然而，如果您运行它，您会看到我们仍然是一次发出所有20个请求。<br/>这是一个使用<a class="ae lw" href="https://www.charlesproxy.com/" rel="noopener ugc nofollow" target="_blank"> Charles代理</a>的网络截图</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi mn"><img src="../Images/9c404e2e9e91c6fb45d01e44ee517ea9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_68UCZrzfoTlZ1QGRtAmcQ.png"/></div></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk translated">即时网络呼叫</figcaption></figure><h1 id="6433" class="kt ku it bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">推迟</h1><p id="a609" class="pw-post-body-paragraph jq jr it js b jt lr jv jw jx ls jz ka kb lt kd ke kf lu kh ki kj lv kl km kn im bi translated">最后一步是使用<code class="fe ko kp kq kr b"><a class="ae lw" href="https://rxjs-dev.firebaseapp.com/api/index/function/defer" rel="noopener ugc nofollow" target="_blank">defer</a></code>而不是<code class="fe ko kp kq kr b">from</code>来生成我们的<em class="ks">可观测量</em>。这是因为<code class="fe ko kp kq kr b">from</code>会将现有的承诺转化为可观察的承诺，而<code class="fe ko kp kq kr b">defer</code>则使用工厂来产生承诺。只有当它被订阅时，它才会执行工厂。</p><p id="70b3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们简单地调整我们的可观测量的产生，我们使它工作。</p><figure class="lx ly lz ma gt mb"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="40f3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">就是这样。您现在可以看到，我们正在尽可能快地执行所有20个请求，但同时执行的只有5个。</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi my"><img src="../Images/1103c3d9d04aa37ac844d320c4959269.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LrThtC2icOxUY2Ze2y2log.png"/></div></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk translated">延迟的网络呼叫</figcaption></figure></div></div>    
</body>
</html>