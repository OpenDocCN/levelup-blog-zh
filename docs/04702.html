<html>
<head>
<title>GPU Memory Aliasing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GPU内存别名</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/gpu-memory-aliasing-45933681a15e?source=collection_archive---------6-----------------------#2020-07-10">https://levelup.gitconnected.com/gpu-memory-aliasing-45933681a15e?source=collection_archive---------6-----------------------#2020-07-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="52c4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">DirectX 12或Vulkan等现代图形API能够将分配的GPU资源放入手动创建的堆中用户定义的内存位置。它允许我们创建纹理和缓冲区，它们的内存部分甚至完全重叠。</p><h2 id="58ab" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">那什么时候有用？</h2><p id="ba86" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">渲染引擎通常被称为管道是有原因的。它们通常被组织为具有多个渲染工作阶段的传送带，其中每个阶段都消耗和产生GPU资源。</p><p id="2ece" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以一个游戏引擎中的典型帧为例:栅格化一些几何图形，执行着色，可能计算一些体积，然后运行一系列后处理阶段。这里的每个阶段将通过写入纹理和/或缓冲区来产生其输出，这些输出将由帧中稍后的某个其他阶段读取。</p><p id="2ce4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里的观察是，某个阶段产生的资源可能只被少数其他阶段使用。后期处理渲染过程是一个很好的例子:bloom过程可以产生其输出，该输出仅由下一阶段使用，即色调映射，而不需要在帧中的任何其他地方使用。我们可以看到，一个资源可以有一个很短的有效寿命，但最有可能是事先分配的，并在整个帧中占用其内存。一个大的管道可以有许多生产的资源，这些资源将全部位于它们永久占用的内存区域中，并消耗大量的VRAM。除非我们做点什么。</p><p id="3d39" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">起初，我们可能会认为，如果资源在短时间内被使用，我们可能会在第一次使用时当场分配它，并在不需要时取消分配，而不是预先分配，以减少整体VRAM消耗。当然，这有助于节省内存，但是频繁的内存重新分配带来的性能损失将超过任何潜在的好处，所以这不是一个可行的解决方案。</p><p id="9491" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">解决这个问题的一个常见方法是使用具有兼容属性的资源池:在需要时取出一个未使用的资源，并在工作完成后将其放回，以供其他人使用，并通过这样做跳过分配。这适用于后期处理阶段，例如，因为它们通常被实现为全屏渲染过程，所有这些过程都读写具有相同属性的纹理。我们基本上只能为整个后处理流水线分配两个纹理。本质上，这是一种高级内存混淆。但是高级别名不是很灵活，它可能很适合后处理，但是在引擎的其他部分不太有用，因为我们必须考虑不能放在同一个池中的各种不兼容的资源，这使得内存重用没有它应有的效率。</p><p id="f0e8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是通过图形API本身实现的低级别名开始有意义的地方。当我们使用API来别名内存时，我们不再关心资源类型，而只关心它们的大小和内存地址。我们仍然可以预先分配一次资源，以避免性能受到影响，但是我们也可以将它们打包到内存中，这比在池示例中更有效，方法是将在不相交的时间段中使用的资源放置在同一内存区域中的彼此“顶部”,而不管资源类型如何，因为在低级别上，它们只是VRAM中的一串字节。</p><h2 id="68c7" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">算法</h2><p id="18e5" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">所以我们认为别名是有用的，但是我们如何实现它来有效地压缩内存呢？</p><p id="bd5f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们不要一开始就给自己增加太多负担，考虑一个连续执行工作的渲染管道，不要考虑异步工作执行或类似的事情。</p><p id="eabc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">随机举一个串行执行的渲染过程的例子，它读取各种大小的资源。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi lj"><img src="../Images/ece8d8d821a27e0c65c53c8549f1bd5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4EpKvrrfKIHeVjeU5RVHBQ.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated">任意渲染管道</figcaption></figure><p id="4bb9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们需要做的第一件事是确定每个资源的有效生存期(EL ),因为只有当它们在时间上不相交时，我们才能给它们起别名，否则我们会遇到内存崩溃。由于渲染过程是连续执行的，我们可以为每个渲染过程分配一个执行索引，并使用这些索引来构建生命周期。</p><p id="d78d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于每个资源，我们取第一次使用资源的渲染过程的索引，并将其视为EL范围的开始，最后一次使用资源的索引成为该范围的结束。</p><p id="053b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是我们给每个资源分配一个EL后得到的结果:</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi lz"><img src="../Images/487d235ad3bf19034f83dc8453fd5cd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*blLK22XH4rHKaKZyFsrNjw.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated">资源有效寿命</figcaption></figure><p id="93e9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在回到记忆包装。我们想要尽可能少的内存占用，但是我们能做到多低呢？如果我们看一下示例资源，我们会看到最大的一个是大小为15 MB的D，因此即使我们将每个资源放置在彼此之上而不考虑生存期，我们也会使用15mb的内存，这意味着在最好的情况下，内存总量至少是最大资源所需的量。</p><p id="ba63" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这给了我们一个提示，重叠内存的一个好方法是从最大的资源开始，然后像一个嵌套的洋娃娃一样在那个内存区域中打包较小的资源。</p><p id="6fce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这将引导我们进入算法的下一步:按照大小降序排列资源。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi ma"><img src="../Images/ac2532ca404c71ca233ec2879c1659b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kB4uTQlYhncmTykuy9VTYA.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated">分类资源</figcaption></figure><p id="7c63" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们浏览这个有序列表，并实际尝试紧密安排没有EL冲突的资源的内存。</p><p id="5fe3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们取列表中的第一个资源，也是最大的(D)，并把它放在一个新的内存桶中。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi mb"><img src="../Images/e11b385bcb8ca8fef3c8f70046c449f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rh9xTnpXOgnEeoU9XIoWvQ.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated">从15 MB大小的最大资源创建的内存桶</figcaption></figure><p id="11d8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第一个资源总是被接受到一个存储桶中，因为它只是第一个，但是后面的资源更棘手。</p><p id="2bef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以第二个资源(A)为例，看看我们是否可以通过检查EL冲突将其放在与(D)相同的桶中。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi mc"><img src="../Images/922ad190152e03021c504bae2931abee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_s-MsUIrvzeJaHKiQKvfmw.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated">A和D的有效寿命不重叠</figcaption></figure><p id="ce93" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为生命周期彼此不冲突(即不重叠)，所以我们将(A)放入同一个桶中。</p><p id="46fb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是等一下，(A)的大小只有10 MB，所以它可以放在15 MB桶内的许多不同的地址。我们应该把它放在哪里？地址0似乎是一个自然的选择，所以我们就把(A)放在那里吧。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi md"><img src="../Images/be917a572b99aecb2a3e3be045ddd782.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i8uRPJ6OQd-sIRgbkuZAIA.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated">a和D在同一个内存桶中有别名</figcaption></figure><p id="63f4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下一个资源是(J ),但是现在我们在一个桶中有两个别名资源，那么我们应该如何继续呢？我们现在必须取(J ),看看它的EL如何适合桶中已有的其他资源。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi me"><img src="../Images/091cb07747267fac0129fe4948272423.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qHwundPR9QvU45or873gsA.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated">j和D寿命相互冲突</figcaption></figure><p id="24f7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们看到，尽管(J)与(A)没有生命周期冲突，但它与(D)冲突，不幸的是，在这个桶中没有地方可以放置(J)而不与(D)在内存方面重叠，所以我们跳过将(J)添加到桶中。</p><p id="b209" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后我们取(K ),但是它也有与(D)冲突的问题，所以它也被跳过了。</p><p id="e1d6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下一个是(E ),更有趣一点。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi me"><img src="../Images/042e9accd720722b99cf6cc1ed0871d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qJrdObNjPQ1u6jrR7vt9EQ.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated">e与A冲突</figcaption></figure><p id="ef01" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们在(A)和(E)之间有一个不同的冲突，它是不同的，因为(A)没有完全占据桶，只有2/3，这意味着我们还有5 MB的内存。我们应该尝试将(E)放在10 MB的偏移量处(在(A)结束的地方)，但是由于E的大小是8 MB，桶中没有足够的可用空间，因此(E)也必须被跳过。</p><p id="e700" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可能已经猜到我们要去哪里了，但是让我们去列表的末尾。</p><p id="5f7a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">(I)、(L)、(B)、(H)因与(D)冲突而被跳过。</p><p id="2a85" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来是与(D)不冲突但与(A)冲突的(F)，但它的大小也足够小(3 MB)以适合(A)之后的桶。在(F)的情况下，我们可以放置它的唯一内存区域是10到15 MB之间的范围，这就是我们要放置它的地方。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi md"><img src="../Images/add503fdae94c42252983a691a0cafaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OoYL8tsT2PIfX60ZeOFRlw.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated">f与A冲突，但仍然可以放入桶中</figcaption></figure><p id="46ae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Next)与(D)冲突，所以跳过。</p><p id="4dd2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后我们有(G ),用它我们可以看到一个歧义。因为在所有别名资源中(G)只与(F)冲突，并且具有足够小的大小(2 MB)，所以它能够适合多个内存区域。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi mb"><img src="../Images/8baecca0972bc14c21b2eb9d4e87d52d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ICrOWfL3GY1ilEIqoNqTWA.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated">可以放入多个存储区域G</figcaption></figure><p id="6fbc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">(G)适合0–10和13–15范围，那么哪一个更好呢？我们应该选择一个更小的区域，因为如果我们把(G)放在更大的区域中，我们可以减少这个桶中仍然有别名的资源的潜在数量。</p><p id="031b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后一个资源是(C ),由于与帧中的几乎所有内容都有冲突，所以被跳过。</p><p id="45aa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，我们最终混淆了四个资源:D，A，F和g。不多，但肯定比没有好。我们如何处理被跳过的其余部分？我们使用剩余的最大资源创建一个新的存储桶，并重复该算法。重复此操作，直到所有资源都被分派到内存桶。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi mf"><img src="../Images/1bbea5f847e509573645654a43415d6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f5Okj7J7acsZUAYOMg65GQ.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated">所有资源都有别名</figcaption></figure><p id="2201" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在对上述示例中的所有资源进行别名化后，我们可以看到，如果不进行别名化，所需的总内存是52 MB，而不是82 MB，因此我们减少了大约37%。这当然是一个抽象的例子，每个真实的渲染管道将实现不同的压缩量。</p><p id="011e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，到现在为止，我们已经有了将资源放入桶中的直觉。现在是我们概括和形式化这个过程的时候了。</p><p id="a9e3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一般来说，当我们试图向桶中添加资源时，我们需要找到这样的内存区域，如果我们将新资源放入其中的任何一个，它都不会与桶中已经存在的任何资源发生有效的生命周期冲突。</p><p id="eae2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们首先通过遍历桶中所有已经别名化的资源并检查生存期是否相交来收集所有与新资源冲突的区域，从而找到这样的空闲区域。如果他们这样做，一个内存区域变得不可混叠。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi mg"><img src="../Images/f9e96347d2cd8ac743e1625b33b95e5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CkLA-BgIpjhoARKnZYRbzQ.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated">一个资源的抽象例子，一个新的资源与它发生了生命周期冲突，只剩下几个可容纳新资源的内存区域。</figcaption></figure><p id="5122" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看另一个抽象的例子，这次是不可混淆的内存区域。我们可以知道自由区域在哪里，但是实际上是什么泄露了它们，模式是什么？</p><p id="e8ee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了定位空闲区域，我们应该将不可分配的内存偏移量视为两种类型的点序列:起点和终点。</p><p id="8193" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从上面的示例中收集偏移量，分配开始/结束标记，按升序排序，然后在列表的开头插入带有“结束”标记的桶开始地址，在列表的结尾插入带有“开始”标记的桶结束地址(需要排序，因为资源不一定按照它们在内存中的顺序列出)。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi mh"><img src="../Images/afb72de580113263812e7cb187300084.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TER1ReWJCPBNblZ9U7L36A.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated">有序和标记的内存区域偏移量</figcaption></figure><p id="cc5b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们现在可以定义一个自由区域。它位于两个相邻的终点和起点之间，例如0–2或10–11。但是，有一个问题:由于重叠(如6–7示例中的重叠),并不是所有的结束-开始对都代表空闲内存补丁，因为6–7对被范围5–8中的资源重叠。</p><p id="8238" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以完整的定义如下:</p><p id="1c60" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个空闲的可分配内存区域是两个相邻的末端-起始偏移量之间的空间，它不被任何起始-末端对重叠。</p><p id="505b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们如何检测重叠？我们引入一个<em class="mi">重叠计数器</em>，当遇到起点时增加，当遇到终点时减少。这样，当我们到达一个可能指示可用内存区域的结束-开始对时，我们将检查计数器值，如果它为零，则没有重叠。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi mj"><img src="../Images/35b3ada95c442d3b5bf44cc89559a2e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*-RDh_g9tD_ffpoW_mcp1dQ.gif"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated">重叠计数器帮助检测自由可分区域:0–2，10–11，14–15，18–20</figcaption></figure><p id="bd5b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，最后一步是挑选最小的合适的空闲区域，并在其中放置新的资源。</p><p id="1b41" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们总结一下。</p><blockquote class="mk ml mm"><p id="21a8" class="jn jo mi jp b jq jr js jt ju jv jw jx mn jz ka kb mo kd ke kf mp kh ki kj kk ij bi translated">要为资源设置别名，请按照资源大小的降序对其进行排序。取第一个也是最大的资源，并将其放入一个相同大小的新内存桶中。遍历列表的其余部分，通过检查有效的生存期冲突，为每个资源构建一个不可混淆的内存区域的有序列表。通过遍历不可分配的内存列表，确定可以容纳该资源的最小空闲可分配内存区域。如果它不存在，则跳过向存储桶添加资源。</p><p id="add6" class="jn jo mi jp b jq jr js jt ju jv jw jx mn jz ka kb mo kd ke kf mp kh ki kj kk ij bi translated">如果所有资源都不能放入一个桶中，则从原始列表中移除别名资源，并重复该算法，直到所有资源都被别名化到N个桶中，其中N ≤ TotalResourceCount。</p></blockquote><h2 id="1750" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">复杂性</h2><p id="86c8" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">这种算法占用的内存很紧，但是它很贪婪。我们应该检查它的时间复杂度，以理解它对真实世界渲染管道的适用性。</p><p id="eea6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们有N个在循环中迭代的资源(外部循环)。在每一次外部循环迭代中，我们可能会在一个已经别名化的资源列表中进行线性搜索，以找到不可别名化的区域偏移量，然后进行排序，然后进行另一次线性搜索，以找到最佳的空闲区域。</p><p id="7c90" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">内环在时间上最坏的情况是什么？当所有资源都放在单个内存桶中时，这实际上是内存方面的最佳情况。在内部循环中，我们可以操作的最大资源量是多少？它是<strong class="jp ir"> <em class="mi"> i </em> </strong> —当前的外循环迭代索引，因为我们无法在内循环中处理比在外循环中已经处理的更多的资源。</p><p id="d4d1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，如果我们只考虑在外循环中迭代资源，并在内循环中搜索不可混淆的区域，我们会得到以下最坏情况的复杂性:</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/a94c90788d8bb3a766f6e31a60d88709.png" data-original-src="https://miro.medium.com/v2/resize:fit:332/format:webp/1*G1yAjPvt-uMZGtIjQ_JXjw.png"/></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated">搜索复杂性</figcaption></figure><p id="72a5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为对于每个迭代的资源<strong class="jp ir"> <em class="mi"> i </em> </strong>我们最多只能有<strong class="jp ir"> <em class="mi"> i-1 </em> </strong>资源已经存在于桶中，所以我们的总复杂度看起来像一个序列:<strong class="jp ir"> 1 + 2 + 3 + 4 + 5 + … + N </strong>。</p><p id="a720" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们现在添加偏移排序。假设我们使用某种日志时间排序算法。复杂性公式增长了一点:</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/4abe00787c26c10836b42fb45eda7117.png" data-original-src="https://miro.medium.com/v2/resize:fit:788/format:webp/1*Ck6JrxdrKAKgv-_HddSzwA.png"/></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated">搜索和排序复杂性</figcaption></figure><p id="e1c7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">添加自由区域搜索，公式变为:</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/3fbfd2155e203b23de4597770154ce4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1104/format:webp/1*qXgUpCU1i0msE9gaPz5hUQ.png"/></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated">不断的工作，搜索，排序和另一个搜索的复杂性</figcaption></figure><p id="3f45" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为偏移量是已经别名化的资源数量的两倍，所以我们添加了<strong class="jp ir"> 2i </strong>。然后我们加上2来说明桶的开始和结束偏移。</p><p id="3ad5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还应该在这里添加初始资源排序，以及在每次外部循环迭代中执行的恒定工作:</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi mt"><img src="../Images/750920964c73d2e86a59b4ff112725b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7UPByMuUE_8Z7s9Zcl2uiQ.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated">总复杂性</figcaption></figure><p id="fe61" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们现在可以通过抛弃除了随着n增加增长最快的部分之外的所有东西来估计渐近复杂度。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi mu"><img src="../Images/31450c81f8f81a38cae7fb9553c6e6af.png" data-original-src="https://miro.medium.com/v2/resize:fit:658/format:webp/1*FSK3uTUlfvoSr1g9Ee4uuQ.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated">渐近复杂性</figcaption></figure><p id="6a5b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这比二次复杂度差一点，但差不了太多。</p><p id="fcfa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么我们能在产品渲染器中使用它吗？</p><p id="32d8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们考虑输入数据的大小，答案是<em class="mi">是的</em>。一个现代的渲染流水线真正分配了多少GPU资源？几十个，几百个？即使是100或200，结合资源分配(以及别名)在初始化阶段或当用户请求资源属性更改时很少发生的事实，以及由于无法将所有资源放在同一个桶中，平均起来会更快，我们可以得出结论，这是完全可行的。</p><h2 id="3c91" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">并行工作执行</h2><p id="9f64" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">有一件事我们留到以后再做:在图形API公开的并发队列上执行渲染工作。</p><p id="37e0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可能会遇到这样一种情况:资源可以被多个并发执行的渲染过程读取。考虑到并行作业具有不同的执行索引，并且我们无法知道哪一个将最后完成，我们如何正确地为资源分配有效的生命周期范围？</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div role="button" tabindex="0" class="lp lq di lr bf ls"><div class="gh gi mv"><img src="../Images/858db9374dd857114f23313f5c285284.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pHF4gz-Z6tykkpIjH8H5aQ.png"/></div></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated">跨队列资源读取</figcaption></figure><p id="19ad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了解决这个问题，我们应该以更低的粒度分配生存期范围:不使用渲染过程执行索引，而是使用过程依赖级别索引。参见<a class="ae mw" href="https://medium.com/@pavlo.muratov/organizing-gpu-work-with-directed-acyclic-graphs-f3fd5f2c2af3" rel="noopener">用有向无环图组织GPU工作</a>。</p><h2 id="75f4" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">密码</h2><p id="5d38" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">完整实现见<a class="ae mw" href="https://github.com/man-in-black382/PathFinder" rel="noopener ugc nofollow" target="_blank">探路者</a>。</p><figure class="lk ll lm ln gt lo"><div class="bz fp l di"><div class="mx my l"/></div><figcaption class="lv lw gj gh gi lx ly bd b be z dk translated">完整实现摘录</figcaption></figure></div></div>    
</body>
</html>