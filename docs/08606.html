<html>
<head>
<title>Introduction to Parallel Computing in Big Data Analysis (Part 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">大数据分析中的并行计算简介(第1部分)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/introduction-to-parallel-computing-in-big-data-analysis-part-1-959024183b73?source=collection_archive---------10-----------------------#2021-05-16">https://levelup.gitconnected.com/introduction-to-parallel-computing-in-big-data-analysis-part-1-959024183b73?source=collection_archive---------10-----------------------#2021-05-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="f98a" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用Dask运行并行和分布式人工智能任务</h2></div><p id="6b68" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">人工智能(AI)任务通常涉及来自多个输入源的大量数据。这些数据集通常太大、太多样化，以至于单台机器无法正确有效地处理。因此，通常通过并行化和批处理这些任务来寻求机器集群。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi le"><img src="../Images/59e74dd96d03837b3aeb98221c2fe869.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AJHnZVUQf6H9hiFB"/></div></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">莫里茨·金德勒在<a class="ae lu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="2cb9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，这篇文章将向您介绍使用Dask的并行计算。此外，我们将使用一个气候科学的例子来说明本文中讨论的一些要点。事不宜迟，我们开始吧！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="0df3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">注</strong>:这是我致力于探索大数据分析中的并行计算，尤其是新兴领域地理信息的两部分系列文章的第<strong class="kk iu">篇</strong>篇。第二部马上就要来了，一定要跟着来获取最新的更新！</p><h1 id="fd25" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">目录:</h1><ol class=""><li id="c19a" class="mu mv it kk b kl mw ko mx kr my kv mz kz na ld nb nc nd ne bi translated">并行计算简介</li><li id="e9a2" class="mu mv it kk b kl nf ko ng kr nh kv ni kz nj ld nb nc nd ne bi translated">Dask是什么？</li><li id="948f" class="mu mv it kk b kl nf ko ng kr nh kv ni kz nj ld nb nc nd ne bi translated">正在创建集群</li><li id="8f72" class="mu mv it kk b kl nf ko ng kr nh kv ni kz nj ld nb nc nd ne bi translated">Dask数据帧</li><li id="6a35" class="mu mv it kk b kl nf ko ng kr nh kv ni kz nj ld nb nc nd ne bi translated">Dask中的并行</li></ol></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="3438" class="mc md it bd me mf nk mh mi mj nl ml mm jz nm ka mo kc nn kd mq kf no kg ms mt bi translated">并行计算简介</h1><p id="8f26" class="pw-post-body-paragraph ki kj it kk b kl mw ju kn ko mx jx kq kr np kt ku kv nq kx ky kz nr lb lc ld im bi translated"><strong class="kk iu"> <em class="ns">并行</em> </strong> <strong class="kk iu"> <em class="ns">计算</em> </strong>允许将任务拆分成可并行执行的批次，以最大限度地利用资源，如您的CPU、GPU或ram。</p><p id="605d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，在大多数情况下，人们倾向于将术语<strong class="kk iu">并行</strong>与<strong class="kk iu">并发</strong>混淆，尽管它们有所不同。我们不会讨论这两者之间的区别，但是如果你想知道更多，你可以看看这个<a class="ae lu" href="https://medium.com/mineiros/how-to-use-multithreading-and-multiprocessing-a-beginners-guide-to-parallel-and-concurrent-a69b9dd21e9d" rel="noopener">帖子</a>。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi nt"><img src="../Images/c9ef51b79c790eb14bbf36ec94473e9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*pwkPWe4rm11bSPxU.png"/></div></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">并行计算批处理较大的任务</figcaption></figure><p id="92e6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">本质上，并发和并行在概念上是相同的。但是关键的区别在于这样一个事实，即<strong class="kk iu">并发</strong>线程和/或进程不一定必须同时<strong class="kk iu">并行</strong>运行<em class="ns">。</em>由此可见，所有的并行编程都是并发的，但不是所有的并发编程都是并行的。</p><p id="63ab" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们已经正式定义了什么是并行计算，让我们介绍一下我们的并行计算库Dask。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="f0dc" class="mc md it bd me mf nk mh mi mj nl ml mm jz nm ka mo kc nn kd mq kf no kg ms mt bi translated">Dask是什么？</h1><p id="2912" class="pw-post-body-paragraph ki kj it kk b kl mw ju kn ko mx jx kq kr np kt ku kv nq kx ky kz nr lb lc ld im bi translated">Dask是一个灵活的并行计算库，它提供了一种动态并行任务调度方法。它能够处理一些更流行的大数据格式集合，比如<code class="fe nu nv nw nx b">dask.array</code>和<code class="fe nu nv nw nx b">dask.dataframe</code>。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi ny"><img src="../Images/0a39286bc3924ab62de02557d834f9d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EvmRHsaR2rcNhOI0OReT4w.png"/></div></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">Dask设计范例(来源:【Dask.org】T2)</figcaption></figure><p id="a755" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如上图所示，您可以创建和定制自己的任务图，在任务图中您可以定义并行化进程的外观。Dask还相对容易地将并行进程从一台笔记本电脑扩展到数百台机器。</p><p id="2acb" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们已经对Dask及其设计概念有了一些了解，让我们开始看看这些想法是如何付诸实践的。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="6016" class="mc md it bd me mf nk mh mi mj nl ml mm jz nm ka mo kc nn kd mq kf no kg ms mt bi translated">正在创建集群</h1><p id="7f61" class="pw-post-body-paragraph ki kj it kk b kl mw ju kn ko mx jx kq kr np kt ku kv nq kx ky kz nr lb lc ld im bi translated">首先，我们必须将Dask安装到我们的机器中。我建议您使用conda虚拟环境来防止弄乱您机器的Python发行版。</p><pre class="lf lg lh li gt nz nx oa ob aw oc bi"><span id="18f7" class="od md it nx b gy oe of l og oh">conda install dask</span></pre><p id="ef0c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您想使用pip，您可以运行以下命令。</p><pre class="lf lg lh li gt nz nx oa ob aw oc bi"><span id="1e0d" class="od md it nx b gy oe of l og oh">python -m pip install "dask[complete]"</span></pre><p id="c281" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，我们需要安装本教程所需的一些其他依赖项。</p><pre class="lf lg lh li gt nz nx oa ob aw oc bi"><span id="46c0" class="od md it nx b gy oe of l og oh">conda install aiohttp<br/>conda install graphviz<br/>pip install graphviz #System-wide installation of graphviz</span></pre><p id="8944" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，我们可以开始创建集群了。</p><p id="e2cd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">但是，什么是集群呢？</strong>集群是一组协同工作的计算机，因此它们可以被视为一个系统。</p><blockquote class="oi oj ok"><p id="8590" class="ki kj ns kk b kl km ju kn ko kp jx kq ol ks kt ku om kw kx ky on la lb lc ld im bi translated">在Dask中，有不同类型的集群。例如，<a class="ae lu" href="https://distributed.dask.org/en/latest/local-cluster.html" rel="noopener ugc nofollow" target="_blank"> LocalCluster </a>有时可以指您自己的笔记本电脑或台式电脑，<a class="ae lu" href="http://jobqueue.dask.org/" rel="noopener ugc nofollow" target="_blank"> PBSCluster </a>指您的高性能计算机(HPC)，或者<a class="ae lu" href="http://kubernetes.dask.org/" rel="noopener ugc nofollow" target="_blank"> Kubernetes Cluster </a>指在云上运行和托管的机器。</p></blockquote><p id="19ab" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">每个集群都有一定数量的计算资源，称为“工作线程”，它们将被分配一定数量的CPU、RAM或GPU计算。集群由Dask调度系统的单一接口控制，无论您使用哪种类型的集群，它的实现语法都非常相似！</p><p id="6c5c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们首先初始化我们自己的LocalCluster，并将其连接到客户机。</p><pre class="lf lg lh li gt nz nx oa ob aw oc bi"><span id="e6e5" class="od md it nx b gy oe of l og oh">from dask.distributed import Client, LocalCluster</span><span id="159b" class="od md it nx b gy oo of l og oh">cluster = LocalCluster()<br/>client = Client(cluster)</span><span id="d605" class="od md it nx b gy oo of l og oh">client</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi op"><img src="../Images/ca8282811c83e3c901005fe54e6e4dce.png" data-original-src="https://miro.medium.com/v2/resize:fit:784/format:webp/1*uefC89wkEunZnJbaTZUc3g.png"/></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">您的本地集群</figcaption></figure><p id="41c4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您将能够看到新初始化的本地集群总共有4个工作线程、16个CPU内核和16GB RAM为您服务！</p><p id="9c42" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">做得好！如果您想在自己的机器之外初始化一个更大的集群，可以使用类似的语法。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="476c" class="mc md it bd me mf nk mh mi mj nl ml mm jz nm ka mo kc nn kd mq kf no kg ms mt bi translated">Dask数据帧</h1><p id="a438" class="pw-post-body-paragraph ki kj it kk b kl mw ju kn ko mx jx kq kr np kt ku kv nq kx ky kz nr lb lc ld im bi translated">如果您熟悉Pandas，那么您也应该熟悉它的原生数据类型Dataframe。Dataframe通常用于处理大数据分析，包括我们将要展示的这个。</p><blockquote class="oi oj ok"><p id="dd78" class="ki kj ns kk b kl km ju kn ko kp jx kq ol ks kt ku om kw kx ky on la lb lc ld im bi translated">我们将使用的数据集描述了世界各地的历史火山活动事件。</p></blockquote><p id="a6b2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们导入<code class="fe nu nv nw nx b">dask.dataframe</code>(类似于<code class="fe nu nv nw nx b">pandas.dataframe</code>)并定义我们将要用来下载CSV文件的服务器和查询字符串。</p><pre class="lf lg lh li gt nz nx oa ob aw oc bi"><span id="e6be" class="od md it nx b gy oe of l og oh">import dask.dataframe as dd</span><span id="c4bf" class="od md it nx b gy oo of l og oh">server = '<a class="ae lu" href="https://webservices.volcano.si.edu/geoserver/GVP-VOTW/ows?'" rel="noopener ugc nofollow" target="_blank">https://webservices.volcano.si.edu/geoserver/GVP-VOTW/ows?'</a><br/>query = 'service=WFS&amp;version=2.0.0&amp;request=GetFeature&amp;typeName=GVP-VOTW:Smithsonian_VOTW_Holocene_Volcanoes&amp;outputFormat=csv'</span></pre><p id="1086" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来，我们将把CSV加载到我们的<code class="fe nu nv nw nx b">dask.dataframe</code>对象中，如下所示。</p><pre class="lf lg lh li gt nz nx oa ob aw oc bi"><span id="0702" class="od md it nx b gy oe of l og oh">df = dd.read_csv(server+query, blocksize=None)</span><span id="d0b6" class="od md it nx b gy oo of l og oh">df</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi oq"><img src="../Images/d7755affa70137a7d12f3e468a4d5297.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5vcFXeqEuJSkKuO1idlM9g.png"/></div></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">Dask数据帧结构</figcaption></figure><p id="b63a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这里，您只能查看元数据。在执行特定查询之前，不会显示实际记录。</p><p id="7c36" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，让我们尝试将数据帧分成4个部分，这样我们就可以将它们加载到本地集群的16个CPU核心中的4个。</p><pre class="lf lg lh li gt nz nx oa ob aw oc bi"><span id="220a" class="od md it nx b gy oe of l og oh">df = df.repartition(npartitions=4)</span><span id="b737" class="od md it nx b gy oo of l og oh">df</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div class="gh gi or"><img src="../Images/541b0b788bbb6a98da3e5d90d9ce884c.png" data-original-src="https://miro.medium.com/v2/resize:fit:522/format:webp/1*dIBkCVV2bU3uoVMeJ7M6FQ.png"/></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">在划分数据帧后</figcaption></figure><p id="2a9c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您现在会注意到分区的数量从1增加到了4！我们已经成功完成了第一轮并行化。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="609a" class="mc md it bd me mf nk mh mi mj nl ml mm jz nm ka mo kc nn kd mq kf no kg ms mt bi translated">Dask中的并行</h1><p id="54a8" class="pw-post-body-paragraph ki kj it kk b kl mw ju kn ko mx jx kq kr np kt ku kv nq kx ky kz nr lb lc ld im bi translated">现在，让我们执行一个简单的任务，使用下面的调用找出最后一次喷发事件的最小年份。</p><pre class="lf lg lh li gt nz nx oa ob aw oc bi"><span id="2877" class="od md it nx b gy oe of l og oh">last_eruption_year_min = df.Last_Eruption_Year.min()</span></pre><p id="643d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是，在检索实际的年份值之前，让我们先想象一下并行性是如何与之前分区的数据帧(npartitions=4)一起工作的</p><pre class="lf lg lh li gt nz nx oa ob aw oc bi"><span id="e547" class="od md it nx b gy oe of l og oh">last_eruption_year_min.visualize(format='png')</span></pre><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi os"><img src="../Images/4bea442b4acef6043d88f46d0e7d28e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*93ZMCqU9kQAleQw4AIEQxQ.png"/></div></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">我们的并行性是如何工作的</figcaption></figure><p id="0d53" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上图显示了我们的并行系统(自下而上):</p><ol class=""><li id="d74c" class="mu mv it kk b kl km ko kp kr ot kv ou kz ov ld nb nc nd ne bi translated">读取CSV并将其加载到数据帧中，</li><li id="a829" class="mu mv it kk b kl nf ko ng kr nh kv ni kz nj ld nb nc nd ne bi translated">将我们的数据帧分成4个独立的分区，</li><li id="1e02" class="mu mv it kk b kl nf ko ng kr nh kv ni kz nj ld nb nc nd ne bi translated">对于4个分区中的每一个，执行min()操作，</li><li id="6241" class="mu mv it kk b kl nf ko ng kr nh kv ni kz nj ld nb nc nd ne bi translated">结合结果，</li><li id="0b23" class="mu mv it kk b kl nf ko ng kr nh kv ni kz nj ld nb nc nd ne bi translated">执行最后的min()运算，并</li><li id="348e" class="mu mv it kk b kl nf ko ng kr nh kv ni kz nj ld nb nc nd ne bi translated">输出值</li></ol></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="9152" class="mc md it bd me mf nk mh mi mj nl ml mm jz nm ka mo kc nn kd mq kf no kg ms mt bi translated">结论</h1><p id="e3bc" class="pw-post-body-paragraph ki kj it kk b kl mw ju kn ko mx jx kq kr np kt ku kv nq kx ky kz nr lb lc ld im bi translated">这篇文章展示了如何在大数据分析中执行并行计算，尤其是在地理任务中。我将继续这个系列，展示一些使用Dask的更具挑战性的并行概念，包括如何并行化函数；所以一定要关注以获取最新通知！</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><p id="50ee" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> <em class="ns">做订阅我的邮件简讯:</em></strong><a class="ae lu" href="https://tinyurl.com/2npw2fnz" rel="noopener ugc nofollow" target="_blank"><em class="ns">【https://tinyurl.com/2npw2fnz】</em></a><em class="ns"/><strong class="kk iu"><em class="ns">在这里我定期用通俗易懂的语言和漂亮的可视化总结AI研究论文。</em> </strong></p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="016e" class="mc md it bd me mf nk mh mi mj nl ml mm jz nm ka mo kc nn kd mq kf no kg ms mt bi translated">进一步阅读</h1><div class="ow ox gp gr oy oz"><a href="https://towardsdatascience.com/geopandas-hands-on-building-geospatial-machine-learning-pipeline-9ea8ae276a15" rel="noopener follow" target="_blank"><div class="pa ab fo"><div class="pb ab pc cl cj pd"><h2 class="bd iu gy z fp pe fr fs pf fu fw is bi translated">Geopandas实践:构建地理空间机器学习管道</h2><div class="pg l"><p class="bd b dl z fp pe fr fs pf fu fw dk translated">towardsdatascience.com</p></div></div><div class="ph l"><div class="pi l pj pk pl ph pm lo oz"/></div></div></a></div><div class="ow ox gp gr oy oz"><a href="https://towardsdatascience.com/interactive-geospatial-ai-visualization-in-jupyter-notebook-f3223f534327" rel="noopener follow" target="_blank"><div class="pa ab fo"><div class="pb ab pc cl cj pd"><h2 class="bd iu gy z fp pe fr fs pf fu fw is bi translated">Jupyter笔记本中的交互式地理空间人工智能可视化</h2><div class="pg l"><p class="bd b dl z fp pe fr fs pf fu fw dk translated">towardsdatascience.com</p></div></div><div class="ph l"><div class="pn l pj pk pl ph pm lo oz"/></div></div></a></div><div class="ow ox gp gr oy oz"><a href="http://gallery.pangeo.io/repos/TomAugspurger/pangeo-dask-gateway/index.html" rel="noopener  ugc nofollow" target="_blank"><div class="pa ab fo"><div class="pb ab pc cl cj pd"><h2 class="bd iu gy z fp pe fr fs pf fu fw is bi translated">Pangeo &amp; Dask网关。— Pangeo画廊文件</h2><div class="po l"><h3 class="bd b gy z fp pe fr fs pf fu fw dk translated">如何在Pangeo Hubs和Binders上使用Dask Gateway进行可扩展计算。</h3></div><div class="pg l"><p class="bd b dl z fp pe fr fs pf fu fw dk translated">gallery.pangeo.io</p></div></div><div class="ph l"><div class="pp l pj pk pl ph pm lo oz"/></div></div></a></div></div></div>    
</body>
</html>