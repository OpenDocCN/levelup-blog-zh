<html>
<head>
<title>Dancing with Docker images in Azure DevOps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Azure DevOps中与Docker图像共舞</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/dancing-with-docker-images-in-azure-devops-86da86e828d1?source=collection_archive---------3-----------------------#2021-02-01">https://levelup.gitconnected.com/dancing-with-docker-images-in-azure-devops-86da86e828d1?source=collection_archive---------3-----------------------#2021-02-01</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="9447" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">通过触发器动态翻转Azure管道中的docker基本图像</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ac48796bd6ef452fb625199fe0d96feb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dU2TYk19RND751hgdC3irQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">在Azure DevOps中与Docker图像共舞</figcaption></figure><p id="3c0c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">由于集装箱的兴起，建造集装箱的过程也发生了变化。构建容器映像的安全性和效率方面也是如此。</p><p id="2227" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在许多方面，较小的容器映像更有效；即更少的存储空间、更快的拉速率、减少攻击面等。但同时，人们可能需要构建相同图像和功能的稍微不同的变体。也许因为你需要不同的工具或驱动程序。</p><p id="98d1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这种场景的一个更好的例子是容器化一个应用程序，并部署它的多个实例，这些实例执行相同的功能，但与不同的数据库对话。因此，将所有的驱动程序预安装在映像中，并且只对每个实例的特定数据库使用它，将会导致容器中有太多过载和未使用的驱动程序。这将违反我们简单讨论过的较小图像尺寸策略。</p><p id="cb1a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是从代码功能的角度来看，用相同的功能代码和映像构建逻辑创建太多的存储库也会导致太多的维护开销。因为如果功能发生变化，所有复制的存储库中的代码也需要改变。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lu"><img src="../Images/6c43b53c8e93bd48e0ab2b6ba1eb72a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*osBvCrpFHej1xUU2Rpdz6g.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">需要将功能代码的更改推送到所有重复的回购中</figcaption></figure><p id="9847" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">相反，如果有一个构建通用应用程序的基本默认模板，并根据触发器翻转基本图像以产生变体，那就太好了。这将对代码的功能给予更多的控制，并且还允许开发者容易地引入对驱动程序的任何改变或升级，而不打扰功能代码报告，反之亦然。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lu"><img src="../Images/5e80755a1f14e29b68bf8bd1b80acaa8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1MjX_0haiYonqhYWtLsFeg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">对功能代码的更改只需推送到基础，所有映像变体都是通过管道触发器构建的</figcaption></figure><h1 id="9413" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">如何实现这一点？</h1><p id="47f8" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">这就是我们要用docker文件中的基本图像跳舞的地方。我的意思是，我们将在Dockerfile文件中定义一个基本的默认图像，并根据来自各个存储库的触发器翻转该基本图像，并在Azure DevOps管道中相应地标记它们。</p><p id="99e2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我们的场景中，我们正在创建一个nodeJS应用程序，它连接不同的数据库，即、Oracle、Sybase、MSSQL、PostgreSQL等。为了使nodeJS与oracle连接，它需要将这里定义的Oracle驱动程序<a class="ae ms" href="https://github.com/oracle/node-oracledb" rel="noopener ugc nofollow" target="_blank">预安装在平台中。同样，对于sybase nodeJS驱动程序，npm包</a><a class="ae ms" href="https://www.npmjs.com/package/sybase" rel="noopener ugc nofollow" target="_blank"> node-sybase </a>需要预装java运行时。其余的数据库如MSSQL、PostgreSQL没有任何特殊的平台依赖性。这意味着我们需要使用一个基础图像</p><ul class=""><li id="0062" class="mt mu it la b lb lc le lf lh mv ll mw lp mx lt my mz na nb bi translated">通用数据库，如mssql、postgresql等。,</li><li id="5872" class="mt mu it la b lb nc le nd lh ne ll nf lp ng lt my mz na nb bi translated">为oracle应用程序安装的oracledb相关性，</li><li id="839f" class="mt mu it la b lb nc le nd lh ne ll nf lp ng lt my mz na nb bi translated">为sybase应用程序添加了sybase依赖项。</li></ul><p id="2574" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将要处理的存储库命名如下，以消除混淆，并作为本文的参考。</p><ul class=""><li id="303b" class="mt mu it la b lb lc le lf lh mv ll mw lp mx lt my mz na nb bi translated"><strong class="la iu"> <em class="nh"> ci_templates: </em> </strong>保存模板以备重用</li><li id="6cd4" class="mt mu it la b lb nc le nd lh ne ll nf lp ng lt my mz na nb bi translated"><strong class="la iu"> <em class="nh"> generic-app: </em> </strong>在generic基础之上构建应用，并带有功能代码</li><li id="beb0" class="mt mu it la b lb nc le nd lh ne ll nf lp ng lt my mz na nb bi translated"><strong class="la iu"> <em class="nh"> oracle客户端:</em> </strong>仅构建包含oracle客户端特定库的基础映像</li><li id="db3a" class="mt mu it la b lb nc le nd lh ne ll nf lp ng lt my mz na nb bi translated"><strong class="la iu"><em class="nh">sybase-client:</em></strong>仅构建包含Sybase特定依赖项的基本映像。</li></ul><h1 id="ced5" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">配置项模板</h1><p id="510e" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">在构建通用应用程序映像之前，我们将创建一个docker构建和docker推送模板。这将是同样的事情，我们要做的是建立有味道的基础形象。</p><p id="03d5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Azure Pipelines提供了一种重用其资源的方式。据Azure报道，</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ni"><img src="../Images/0c42a1dff65ad94bd757a5c42130d12f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z-1b5ZjU_Ezo9ViXKysVrQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">资源定义— Azure</figcaption></figure><p id="fec6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们将利用<a class="ae ms" href="https://docs.microsoft.com/en-us/azure/devops/pipelines/process/resources?view=azure-devops&amp;tabs=schema#resources-repositories" rel="noopener ugc nofollow" target="_blank">存储库资源</a>。我们将创建一个名为<code class="fe nj nk nl nm b"><em class="nh">ci_templates</em></code>的公共模板库，并为docker构建存储模板。docker构建和推送模板如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">ci_templates repo中的docker构建和推送模板</figcaption></figure><p id="feb5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在让我们用上面的模板构建通用的应用程序。稍后我们将再次访问模板库，以进一步添加模板。目前,<code class="fe nj nk nl nm b">ci_templates</code>存储库的结构如下所示。</p><pre class="kj kk kl km gt np nm nq nr aw ns bi"><span id="8896" class="nt lw it nm b gy nu nv l nw nx">|_ docker.yml</span></pre><h1 id="c831" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">通用应用程序</h1><p id="c7b0" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">应用程序的docker文件如下所示。这是在<code class="fe nj nk nl nm b">generic-app</code>库下创建的。</p><pre class="kj kk kl km gt np nm nq nr aw ns bi"><span id="1c82" class="nt lw it nm b gy nu nv l nw nx">ARG BASE_IMAGE=node:alpine3.12<br/>FROM $BASE_IMAGE</span><span id="4e4f" class="nt lw it nm b gy ny nv l nw nx">RUN mkdir -p /usr/src/app<br/>WORKDIR /usr/src/app<br/>COPY . /usr/src/app<br/>RUN npm install<br/>RUN npm run build</span><span id="204b" class="nt lw it nm b gy ny nv l nw nx">CMD ["npm", "start"]</span></pre><p id="59eb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上面的Dockerfile文件显示，如果没有构建参数传递给<code class="fe nj nk nl nm b"><em class="nh">docker build</em></code>命令，默认的基本映像将是<code class="fe nj nk nl nm b"><em class="nh">node:alpine3.12</em></code>。使用这个<em class="nh"> Dockerfile </em>构建映像并在Oracle或Sybase上运行是行不通的。因为它们需要平台级的依赖性。</p><p id="6148" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nj nk nl nm b">generic-app</code>存储库结构将如下所示。</p><pre class="kj kk kl km gt np nm nq nr aw ns bi"><span id="7617" class="nt lw it nm b gy nu nv l nw nx">|_ Dockerfile<br/>|_ package.json<br/>|_ &lt;nodeJS application logic folders/files&gt;<br/>|_ azure-pipelines.yml</span></pre><p id="4ded" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">默认docker文件的<code class="fe nj nk nl nm b"><em class="nh">azure-pipelines.yml</em></code>文件如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">azure-pipelines.yml，用于通用应用程序报告中的通用映像构建</figcaption></figure><p id="f680" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">假设为运行作业正确定义了<code class="fe nj nk nl nm b"><em class="nh">trigger</em></code>和<code class="fe nj nk nl nm b"><em class="nh">pool</em></code>，上面的管道将执行以下操作。</p><p id="22be" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> <em class="nh">第一步:</em> </strong>导入<code class="fe nj nk nl nm b"><em class="nh">MyProject</em></code> <em class="nh">下名为<code class="fe nj nk nl nm b"><em class="nh">ci_templates</em></code>的库，</em>将其称为<code class="fe nj nk nl nm b"><em class="nh">templates</em></code> <em class="nh">。</em></p><p id="4766" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> <em class="nh">第二步:</em> </strong>导入变量组<code class="fe nj nk nl nm b"><em class="nh">Admin Variables</em></code>和<code class="fe nj nk nl nm b"><em class="nh">Platform Variables</em></code>下的变量。我们在<code class="fe nj nk nl nm b"><em class="nh">Admin Variable</em></code>组下保存了一个PAT。<code class="fe nj nk nl nm b"><em class="nh">Platform Variables</em></code>用于存储我们正在使用的存储库的最新标签。</p><p id="638a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> <em class="nh">第三步:</em> </strong>流水线会确定<code class="fe nj nk nl nm b"><em class="nh">isMain</em></code>和<code class="fe nj nk nl nm b"><em class="nh">isTag</em></code>变量的值。这用于通过执行条件检查来运行管道定义中的正确阶段。</p><p id="1bd2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> <em class="nh">步骤4: </em> </strong>根据是<code class="fe nj nk nl nm b"><em class="nh">main</em></code>分支构建还是<code class="fe nj nk nl nm b"><em class="nh">tag</em></code>删除的条件，通过从称为<code class="fe nj nk nl nm b"><em class="nh">templates</em></code>的库中导入docker模板来执行相应的阶段。</p><p id="8440" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> <em class="nh">步骤6: </em> </strong>如果管道被标记丢弃触发，标记值的更新将发生在上述样本文件中第29行的<code class="fe nj nk nl nm b"><em class="nh">updateVariable</em></code>阶段。</p><p id="4a89" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这个阶段，我们将作业作为<em class="nh">容器化的</em>作业运行，并为其使用<code class="fe nj nk nl nm b"><em class="nh">gkarthics/ci-swiss-knife</em></code>映像。我们使用以下命令登录Azure DevOps</p><pre class="kj kk kl km gt np nm nq nr aw ns bi"><span id="9b27" class="nt lw it nm b gy nu nv l nw nx">echo ${AZURE_DEVOPS_CLI_PAT} | az devops login</span></pre><p id="1c62" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">其中<code class="fe nj nk nl nm b"><em class="nh">AZURE_DEVOPS_CLI_PAT</em></code>是存储在<code class="fe nj nk nl nm b"><em class="nh">Admin Variables</em></code>变量组中的PAT令牌。</p><p id="ee0e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">之后，我们使用命令设置默认的<em class="nh"> Azure组织</em>和<em class="nh">项目</em>，</p><pre class="kj kk kl km gt np nm nq nr aw ns bi"><span id="698b" class="nt lw it nm b gy nu nv l nw nx"><em class="nh">az devops configure --defaults organization=</em><a class="ae ms" href="https://azure.com/MyORG" rel="noopener ugc nofollow" target="_blank"><em class="nh">https://azure.com/MyORG</em></a><em class="nh"> project=$PROJECT_NAME --use-git-aliases true</em></span></pre><p id="83fc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">登录并设置默认值后，标签值需要在<em class="nh">库组变量</em>中更新。为此，请在管道中使用以下命令。</p><pre class="kj kk kl km gt np nm nq nr aw ns bi"><span id="8e6b" class="nt lw it nm b gy nu nv l nw nx"><em class="nh">az pipelines variable-group variable update --group-id &lt;GROUP_ID_VALUE&gt; --name &lt;VARIABLE_NAME&gt; --value $TAG</em></span></pre><p id="8079" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这将更新该值，并将其存储在指定的变量组下，以供将来参考。这将看起来像下面的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/f95a4c31f820f2766200202b03eb9130.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZUB1AhjzFXCk3nzHD_jH4Q.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">更新了库变量组中的STABLE_VERSION值</figcaption></figure><h1 id="358a" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">Oracle基本变体</h1><p id="4a10" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">既然已经使用默认的基本映像构建了通用应用程序，并且最新的标记存储在变量中，那么让我们使用ansible构建一个包含Oracle库的映像。Dockerfile和Ansible将如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">要求. yml</figcaption></figure><p id="40bd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Ansible中的<code class="fe nj nk nl nm b"><em class="nh">requirements.yml</em></code>文件用于定义需要安装的集合。在上面的文件中，我们已经定义了使用<code class="fe nj nk nl nm b">gkarthiks.ansible_oracledb_client.</code>这也可以在<a class="ae ms" href="https://galaxy.ansible.com/gkarthiks/ansible_oracledb_client" rel="noopener ugc nofollow" target="_blank"> Ansible Galaxy </a>中查看。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">playbook.yml</figcaption></figure><p id="e2d9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nj nk nl nm b"><em class="nh">playbook.yml</em></code>将记录并执行配置。在我们的<code class="fe nj nk nl nm b">playbook.yml</code>文件中，我们添加了<em class="nh"> oracledb-client </em>作为要执行的角色，它是在上面的requirements.yml文件中定义的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">Dockerfile文件</figcaption></figure><p id="0386" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在构建在<code class="fe nj nk nl nm b"><em class="nh">Dockerfile</em>.</code>中定义的映像时会用到这些，现在让我们为Azure管道定义<code class="fe nj nk nl nm b"><em class="nh">azure-pipelines.yml</em></code>。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">OracleDB客户机的基本映像构建管道</figcaption></figure><p id="0858" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">与前面的docker映像构建类似，上面的管道将按照<em class="nh"> ansible-playbook </em>中的说明，安装<em class="nh"> oracledb-client </em>来构建容器映像。一旦标签被丢弃，标签也将被存储在名为<em class="nh">平台变量的<em class="nh">库组变量</em>中。</em></p><h1 id="e2c6" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">管道触发器</h1><p id="483b" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">既然已经构建了映像，我们需要触发主存储库的管道。以便具有Oracle依赖性的新基础映像将与功能代码一起使用。</p><p id="3a74" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Azure DevOps提供了一种方法，可以轻松地将一个存储库的管道作为资源包含到另一个存储库中。更多细节请点击<a class="ae ms" href="https://docs.microsoft.com/en-us/azure/devops/pipelines/process/resources?view=azure-devops&amp;tabs=schema#resources-pipelines" rel="noopener ugc nofollow" target="_blank">这里</a>。这将让存储库的管道在包含的管道完成时自动触发。</p><p id="3fae" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们稍微改变一下原始的基本映像存储库管道，以适应上面的逻辑。将下面的代码包含到基本通用应用程序库管道中的<code class="fe nj nk nl nm b">resources</code>部分。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">将管道资源添加到通用应用程序报告中</figcaption></figure><p id="1147" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上面定义了<code class="fe nj nk nl nm b">generic-app</code>仓库中的管道将在<code class="fe nj nk nl nm b">oracle-lient</code> repo中的阶段<code class="fe nj nk nl nm b">updateVariable</code>成功完成后不久被触发。</p><p id="42de" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这将触发<code class="fe nj nk nl nm b">generic-app</code>存储库中的管道，但也会有点混乱，因为它将触发默认分支。我们需要为oracledb-client基本映像定义特定的触发条件，以便可以传递自定义映像名称和自定义标记。让我们稍微改变一下管道的定义，来定义具体的工作。</p><p id="f0f8" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要做到这一点，我们需要确定触发源。预定义的环境变量<code class="fe nj nk nl nm b">resources.triggeringAlias</code>将给出触发管道的名称。在这种情况下，我们需要根据字符串<code class="fe nj nk nl nm b">oracleclient</code>进行验证，因为这是我们在参考资料中定义的名称。这将看起来像下面的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oa"><img src="../Images/a4748b58fb53e86d77dcda880d26a9a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DKSht_1fO4IMTGojMdwwyA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">通用应用程序报告管道中触发器名称的变量解析</figcaption></figure><p id="78b3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，这被添加到同一个<em class="nh"> azure-pipelines.yml </em>文件中的其他变量列表中。下一步是在其余作业中排除该触发器的运行，并定义特定的作业。排除条件将如下所示。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/69eb588ce0ce8588a37dde3ff47046f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iwLahKFyJrYzpQHH8S7rvw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">排除管道触发器的主生成中的条件</figcaption></figure><p id="05f3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在定义管道触发器作业之前，让我们为构建创建一个公共模板。因为这在以后的sybase映像中也是一样的。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">ci_templates repo中的上游docker构建和推送模板</figcaption></figure><p id="4c27" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在<code class="fe nj nk nl nm b">ci_templates</code>存储库结构将有一个附加文件，如下所示。</p><pre class="kj kk kl km gt np nm nq nr aw ns bi"><span id="f4b9" class="nt lw it nm b gy nu nv l nw nx">|_ docker.yml<br/>|_ upstream-docker.yml</span></pre><p id="0f77" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在让我们使用来自<code class="fe nj nk nl nm b">ci_templates</code>仓库的模板为触发器定义作业。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">通用应用程序报告中的oracle客户端触发器作业定义</figcaption></figure><p id="b9b6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">只有当<code class="fe nj nk nl nm b">orcale-client</code>流水线成功执行<code class="fe nj nk nl nm b">updateVariabvle</code>阶段时，上面定义的作业才会被触发。传递给这个具有oracle依赖关系的应用程序的自定义映像名称是<code class="fe nj nk nl nm b">query-engine-oracle-client.</code>，它也用自定义标记值标记为&lt;generic-app-tag _ Oracle-client-tag&gt;。</p><p id="ecdc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">仔细查看参数，一个<code class="fe nj nk nl nm b">buildArgs</code>正在被传递给构建命令。这用于传递在<code class="fe nj nk nl nm b">generic-app</code>存储库中的Dockerfile中定义的参数<code class="fe nj nk nl nm b">BASE_IMAGE</code>的值。执行该命令时，该参数的值将被解析为由<code class="fe nj nk nl nm b">oracle-client</code> repo构建的图像<code class="fe nj nk nl nm b">oracle-client:0.1.0</code>。因此，该作业的docker文件将如下所示。</p><pre class="kj kk kl km gt np nm nq nr aw ns bi"><span id="6bdb" class="nt lw it nm b gy nu nv l nw nx">FROM <!-- -->oracle-client:0.1.0</span><span id="b071" class="nt lw it nm b gy ny nv l nw nx">RUN mkdir -p /usr/src/app<br/>WORKDIR /usr/src/app<br/>COPY . /usr/src/app<br/>RUN npm install<br/>RUN npm run build</span><span id="591d" class="nt lw it nm b gy ny nv l nw nx">CMD ["npm", "start"]</span></pre><p id="166b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，用它构建的映像可以在Oracle数据库上运行，不会出现任何问题。</p><h1 id="3353" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">构建Sybase变体</h1><p id="0ba3" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">既然我们已经为<code class="fe nj nk nl nm b">oracle-client</code>定义了一个逻辑及其相应的助手模板，那么对于<code class="fe nj nk nl nm b">sybase-client</code>来说也是一样的。</p><p id="c804" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">安装Sybase依赖项的<code class="fe nj nk nl nm b">playbook.yml</code>文件如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">为Sybase安装JRE的行动手册</figcaption></figure><p id="911b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe nj nk nl nm b">sybase-client</code>存储库对应的Dockerfile看起来将会像这样</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">sybase-client repo中的Dockerfile</figcaption></figure><p id="610a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">sybase-client存储库的<code class="fe nj nk nl nm b">azure-pipelines.yml</code>文件将看起来像这样</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">sybase-client repo中Sybase客户端的基本映像构建管道</figcaption></figure><p id="f59e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，与<code class="fe nj nk nl nm b">oracle-client</code>类似，我们必须对<code class="fe nj nk nl nm b">generic-app</code>存储库的管道做一些改变。编辑后的管道将如下所示。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nn no l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">在通用应用程序报告中完成azure-pipelines.yml</figcaption></figure><p id="7510" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注意，您必须在主分支构建中排除<code class="fe nj nk nl nm b">sybaseTrigger</code>和<code class="fe nj nk nl nm b">oracleTrigger</code>。</p><p id="7a17" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是一种方式。现在，如果<code class="fe nj nk nl nm b">sybase-client</code>或<code class="fe nj nk nl nm b">oracle-client</code>存储库中有变化，那么<code class="fe nj nk nl nm b">generic-app</code>存储库将被触发，并且将构建一个新的应用程序映像。当功能代码发生变化时，为了达到同样的目的，在<code class="fe nj nk nl nm b">oracle-client</code>和<code class="fe nj nk nl nm b">sybase-client</code>库中添加触发器和相应的条件。</p><p id="0b84" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最终的变量组将如下所示，所有的<code class="fe nj nk nl nm b">STABLE_VERSION</code>、<code class="fe nj nk nl nm b">ORACLE_CLIENT_VERSION</code>和<code class="fe nj nk nl nm b">SYBASE_CLIENT_VERSION</code>的值都已更新。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi lu"><img src="../Images/5b52852693fa6268a3c6f995a338174f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yOGeB3ZHCcaLu_mB7hPZ1Q.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">具有所有标签值的库变量组根据标签删除进行更新</figcaption></figure><p id="5dcc" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这就是我们如何在Azure devo PS Pipelines<strong class="la iu"><em class="nh">中与Docker图像共舞💃</em> </strong>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/32656582d80b975f06c568a40a5ca4d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eTiIfL4VzB6zby5AFhAnXQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">该图显示了我们在文章中讨论过的单向管道触发器</figcaption></figure><p id="93b9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你喜欢这篇文章，请通过拍手帮助其他人找到它，并在这里和Twitter上关注我以获取更多更新。</p></div><div class="ab cl od oe hx of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="im in io ip iq"><h1 id="3dc4" class="lv lw it bd lx ly ok ma mb mc ol me mf jz om ka mh kc on kd mj kf oo kg ml mm bi translated">参考</h1><ul class=""><li id="54b3" class="mt mu it la b lb mn le mo lh op ll oq lp or lt my mz na nb bi translated"><a class="ae ms" href="https://docs.microsoft.com/en-us/azure/devops/pipelines/get-started/what-is-azure-pipelines?view=azure-devops" rel="noopener ugc nofollow" target="_blank">天蓝色管道</a></li><li id="2571" class="mt mu it la b lb nc le nd lh ne ll nf lp ng lt my mz na nb bi translated"><a class="ae ms" href="https://docs.microsoft.com/en-us/azure/devops/pipelines/build/variables?view=azure-devops&amp;tabs=yaml" rel="noopener ugc nofollow" target="_blank"> Azure管道预定义变量</a></li><li id="71c4" class="mt mu it la b lb nc le nd lh ne ll nf lp ng lt my mz na nb bi translated"><a class="ae ms" href="https://docs.docker.com/engine/reference/builder/#understand-how-arg-and-from-interact" rel="noopener ugc nofollow" target="_blank"> Dockerfile参数ARG </a></li><li id="cb0a" class="mt mu it la b lb nc le nd lh ne ll nf lp ng lt my mz na nb bi translated"><a class="ae ms" href="https://docs.microsoft.com/en-us/azure/devops/pipelines/process/about-resources?view=azure-devops" rel="noopener ugc nofollow" target="_blank">蔚蓝管道资源</a></li><li id="b847" class="mt mu it la b lb nc le nd lh ne ll nf lp ng lt my mz na nb bi translated"><a class="ae ms" href="https://galaxy.ansible.com/gkarthiks/ansible_oracledb_client" rel="noopener ugc nofollow" target="_blank"> Ansible OracleDB客户端</a></li><li id="cc0f" class="mt mu it la b lb nc le nd lh ne ll nf lp ng lt my mz na nb bi translated"><a class="ae ms" href="https://hub.docker.com/repository/docker/gkarthics/ci-swiss-knife" rel="noopener ugc nofollow" target="_blank"> CI瑞士刀容器图像</a></li><li id="637a" class="mt mu it la b lb nc le nd lh ne ll nf lp ng lt my mz na nb bi translated"><a class="ae ms" href="https://www.npmjs.com/package/sybase" rel="noopener ugc nofollow" target="_blank"> nodeJS Sybase驱动</a></li><li id="9cd6" class="mt mu it la b lb nc le nd lh ne ll nf lp ng lt my mz na nb bi translated"><a class="ae ms" href="https://oracle.github.io/node-oracledb/" rel="noopener ugc nofollow" target="_blank">节点-OracleDB驱动程序</a></li></ul></div></div>    
</body>
</html>