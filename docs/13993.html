<html>
<head>
<title>Why Optional&lt;&gt; is a Monad and Why the f() Should I Care?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么Optional &lt;&gt;是一个单子，为什么f()我应该关心？</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/why-optional-is-a-monad-and-why-the-f-should-i-care-dc5ba9b3d9e1?source=collection_archive---------5-----------------------#2022-10-23">https://levelup.gitconnected.com/why-optional-is-a-monad-and-why-the-f-should-i-care-dc5ba9b3d9e1?source=collection_archive---------5-----------------------#2022-10-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="6dfc" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">请按预期方式使用可选的&lt;&gt;！</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/82ac509d3eb512e830a8dfadce212504.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UFR24o0hU9dymMQB"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">请按预期方式使用可选的&lt;&gt;！—照片由<a class="ae ky" href="https://unsplash.com/@zacharykadolph?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">扎克里·卡道夫</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h2 id="713d" class="lg lh it bd li lj lk dn ll lm ln dp lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">1.概观</h2><p id="f088" class="pw-post-body-paragraph mc md it me b mf mg ju mh mi mj jx mk lp ml mm mn lt mo mp mq lx mr ms mt mu im bi translated">首先，让我们看看对可选的<em class="mv">和</em>(以及一般的<em class="mv">单子</em>)的需求来自哪里。为此，我们先打个比方，想想做面包的过程。</p><ul class=""><li id="0048" class="mw mx it me b mf my mi mz lp na lt nb lx nc mu nd ne nf ng bi translated">首先，我们将通过碾磨小麦来制造面粉；</li><li id="4faa" class="mw mx it me b mf nh mi ni lp nj lt nk lx nl mu nd ne nf ng bi translated">之后，我们会用上一步的面粉做面包；</li></ul><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nm"><img src="../Images/8e550b760743fa23b61e28e798cc4489.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NhEmY42Yan47IYtYJFiNHA.png"/></div></div></figure><p id="ebe1" class="pw-post-body-paragraph mc md it me b mf my ju mh mi mz jx mk lp nn mm mn lt no mp mq lx np ms mt mu im bi translated">我们可以使用函数用编程或数学术语来表达这一点:</p><pre class="kj kk kl km gt nq nr ns nt aw nu bi"><span id="666a" class="lg lh it nr b gy nv nw l nx ny">flour = mill( wheat )<br/>bread = bake( flour )</span></pre><p id="9885" class="pw-post-body-paragraph mc md it me b mf my ju mh mi mz jx mk lp nn mm mn lt no mp mq lx np ms mt mu im bi translated">或者，我们可以像这样简单地组合这两个函数:</p><pre class="kj kk kl km gt nq nr ns nt aw nu bi"><span id="db3d" class="lg lh it nr b gy nv nw l nx ny">bread = bake( mill(wheat) )</span></pre></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h2 id="0739" class="lg lh it bd li lj lk dn ll lm ln dp lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">2.角落里的箱子</h2><p id="b2bd" class="pw-post-body-paragraph mc md it me b mf mg ju mh mi mj jx mk lp ml mm mn lt mo mp mq lx mr ms mt mu im bi translated">不幸的是，处理的每一步都可能由于各种原因而失败。像这样编写函数时，错误处理可能会很麻烦。</p><p id="0562" class="pw-post-body-paragraph mc md it me b mf my ju mh mi mz jx mk lp nn mm mn lt no mp mq lx np ms mt mu im bi translated">例如，也许<em class="mv">小麦</em>并不总能成功加工成<em class="mv">面粉</em>，而<em class="mv">面粉</em>也不总能正确烘焙。</p><p id="6849" class="pw-post-body-paragraph mc md it me b mf my ju mh mi mz jx mk lp nn mm mn lt no mp mq lx np ms mt mu im bi translated">根据我们使用的编程语言和上下文，这可能会产生不同的效果——例如，可能会抛出异常，可能会返回null..等等。</p><p id="f5a8" class="pw-post-body-paragraph mc md it me b mf my ju mh mi mz jx mk lp nn mm mn lt no mp mq lx np ms mt mu im bi translated">让我们假设，在我们的例子中，如果其中一个流程出了问题，<em class="mv"> null </em>被返回。</p><pre class="kj kk kl km gt nq nr ns nt aw nu bi"><span id="8e6a" class="lg lh it nr b gy nv nw l nx ny">flour = mill( wheat )<br/>if( flour != null ) {<br/>   bread = bake( flour )<br/>   if( bread != null ) {<br/>     // .... do something()<br/>   }<br/>}</span></pre><p id="7ecb" class="pw-post-body-paragraph mc md it me b mf my ju mh mi mz jx mk lp nn mm mn lt no mp mq lx np ms mt mu im bi translated">此时，由于空检查，我们不能再组合这些方法。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h2 id="590b" class="lg lh it bd li lj lk dn ll lm ln dp lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">3.介绍单子</h2><p id="1e91" class="pw-post-body-paragraph mc md it me b mf mg ju mh mi mj jx mk lp ml mm mn lt mo mp mq lx mr ms mt mu im bi translated">为了解决这个问题，我们可以将前面函数的结果包装到一个对象中，如果数据存在，该对象将继续处理，如果数据丢失，该对象将不做任何事情。这个包装器对象将是一个“<strong class="me iu"> <em class="mv">单子</em> </strong>”。</p><p id="eac2" class="pw-post-body-paragraph mc md it me b mf my ju mh mi mz jx mk lp nn mm mn lt no mp mq lx np ms mt mu im bi translated">例如，我们可以想到一个<em class="mv">列表。</em>如果里面有元素，就按照下一步处理。另一方面，如果列表为空，则什么都不会发生。一个<em class="mv">列表</em>是单子。</p><p id="47ff" class="pw-post-body-paragraph mc md it me b mf my ju mh mi mz jx mk lp nn mm mn lt no mp mq lx np ms mt mu im bi translated">不过，在这里使用一个<em class="mv">列表</em>并没有多大意义，因为我们希望一次只传递一个对象。</p><p id="6f7a" class="pw-post-body-paragraph mc md it me b mf my ju mh mi mz jx mk lp nn mm mn lt no mp mq lx np ms mt mu im bi translated">因此，我们可以构造自己的monad对象或使用现有的对象之一。有许多<em class="mv">单子</em>定义在具有函数特性的编程语言中。根据语言的不同，我们需要的单子可能被称为类似于<em class="mv">的东西，可能是&lt; &gt; </em>，<em class="mv">或者是&lt; &gt; </em>，或者是<em class="mv">可选的&lt; &gt; </em>。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nz"><img src="../Images/edcf842ada6fb807446cbd84498d7fe2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YGx_CG-I6o5h2Rat"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><em class="oa">可选单子的表现</em> — Java8 (2014)，彩色—照片由<a class="ae ky" href="https://unsplash.com/es/@emilymorter?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">艾米丽·莫特</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h2 id="780c" class="lg lh it bd li lj lk dn ll lm ln dp lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">4.<em class="oa">贴图</em> () <em class="oa"> </em>和平面贴图()</h2><p id="e1fe" class="pw-post-body-paragraph mc md it me b mf mg ju mh mi mj jx mk lp ml mm mn lt mo mp mq lx mr ms mt mu im bi translated">让我们将我们的函数返回类型包装到<em class="mv">可选的&lt; &gt; </em>中，并尝试返回函数组合:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ob"><img src="../Images/ed2395bcd6151e8173c1fdba3743075d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uuJx1TEFNBPmhNoj-SCsOw.png"/></div></div></figure><p id="b034" class="pw-post-body-paragraph mc md it me b mf my ju mh mi mz jx mk lp nn mm mn lt no mp mq lx np ms mt mu im bi translated">我们现在将有一个新的问题:要组合或链接函数，每个函数都必须接收前一个函数的结果作为参数。</p><p id="8e86" class="pw-post-body-paragraph mc md it me b mf my ju mh mi mz jx mk lp nn mm mn lt no mp mq lx np ms mt mu im bi translated">因此，<em class="mv"> bake() </em>函数必须接收一个<em class="mv">可选&lt;面粉&gt; </em>而不是原料类型<em class="mv">面粉。</em></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oc"><img src="../Images/4744cc67d6689f58d42d452e0c0c8e06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TWPqLaOO2SrNbbZqmRHNNg.png"/></div></div></figure><p id="fc2b" class="pw-post-body-paragraph mc md it me b mf my ju mh mi mz jx mk lp nn mm mn lt no mp mq lx np ms mt mu im bi translated">但是，因为<em class="mv">烘焙</em>函数将结果包装成一个<em class="mv">可选&lt; &gt; </em>，第二步的结果将被包装两次，第三步的结果将被包装三次..诸如此类。</p><p id="4aab" class="pw-post-body-paragraph mc md it me b mf my ju mh mi mz jx mk lp nn mm mn lt no mp mq lx np ms mt mu im bi translated">解决这个问题的方法是<strong class="me iu"> <em class="mv"> flatMap() </em> </strong>函数。<em class="mv"/><em class="mv">flat map()</em>的目的是在从一种类型转换到另一种类型时保持结构平整。</p><p id="e7f3" class="pw-post-body-paragraph mc md it me b mf my ju mh mi mz jx mk lp nn mm mn lt no mp mq lx np ms mt mu im bi translated">换句话说，我们可以在<em class="mv">单子</em>上使用以下约定:</p><ul class=""><li id="a9b1" class="mw mx it me b mf my mi mz lp na lt nb lx nc mu nd ne nf ng bi translated"><strong class="me iu">压平</strong> : <em class="mv"> </em>单子&lt;单子&lt;单子【A】单子&gt; &gt; <strong class="me iu"> → </strong>单子&lt; A &gt;</li><li id="6983" class="mw mx it me b mf nh mi ni lp nj lt nk lx nl mu nd ne nf ng bi translated"><strong class="me iu">贴图:</strong>单子&lt;A&gt;T40】→单子&lt; B &gt;</li><li id="88c5" class="mw mx it me b mf nh mi ni lp nj lt nk lx nl mu nd ne nf ng bi translated"><strong class="me iu">平面图:</strong>单子&lt; A &gt; <strong class="me iu"> → </strong>单子&lt;单子&lt; B &gt; &gt; <strong class="me iu"> → </strong>单子&lt; B &gt;</li></ul></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h2 id="0c81" class="lg lh it bd li lj lk dn ll lm ln dp lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">5.函数式编程与面向对象编程</h2><blockquote class="od oe of"><p id="d789" class="mc md mv me b mf my ju mh mi mz jx mk og nn mm mn oh no mp mq oi np ms mt mu im bi translated">组合函数与链接方法</p></blockquote><p id="c6d2" class="pw-post-body-paragraph mc md it me b mf my ju mh mi mz jx mk lp nn mm mn lt no mp mq lx np ms mt mu im bi translated">我们现在已经将每一步的返回类型包装到一个单子中，这允许我们总是将结果传递给下一步。</p><p id="2691" class="pw-post-body-paragraph mc md it me b mf my ju mh mi mz jx mk lp nn mm mn lt no mp mq lx np ms mt mu im bi translated">但是应该怎么做呢？对此，我们有两种可能的解决方案。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><p id="2596" class="pw-post-body-paragraph mc md it me b mf my ju mh mi mz jx mk lp nn mm mn lt no mp mq lx np ms mt mu im bi translated"><strong class="me iu">5.1<em class="mv">。</em></strong>f . p .方式(排版功能)</p><p id="a298" class="pw-post-body-paragraph mc md it me b mf my ju mh mi mz jx mk lp nn mm mn lt no mp mq lx np ms mt mu im bi translated">首先，我们可以让函数接收并返回单子:</p><pre class="kj kk kl km gt nq nr ns nt aw nu bi"><span id="149b" class="lg lh it nr b gy nv nw l nx ny">public Optional&lt;Flour&gt; mill(Optional&lt;Wheat&gt; wheat) {<br/>   // ...<br/>}<br/><br/>public Optional&lt;Bread&gt; bake(Optional&lt;Flour&gt; flour) {<br/>   // ...<br/>}</span></pre><p id="c218" class="pw-post-body-paragraph mc md it me b mf my ju mh mi mz jx mk lp nn mm mn lt no mp mq lx np ms mt mu im bi translated">这将允许我们以函数式编程风格来组合函数:</p><pre class="kj kk kl km gt nq nr ns nt aw nu bi"><span id="2a16" class="lg lh it nr b gy nv nw l nx ny">Optional&lt;Bread&gt; fpBread = bake( mill( harvest() ) );</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oj"><img src="../Images/aedcaf113d94aff06e89d3df0987029e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9lE2PPT3mg0uz-KI"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">O.O.P .开发人员如何看待函数式程序员——照片由<a class="ae ky" href="https://unsplash.com/@devintavery?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Devin Avery </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><p id="8cdb" class="pw-post-body-paragraph mc md it me b mf my ju mh mi mz jx mk lp nn mm mn lt no mp mq lx np ms mt mu im bi translated"><strong class="me iu">5.2<em class="mv">。</em></strong>o . o . p .方式(链接方式)</p><p id="b3f9" class="pw-post-body-paragraph mc md it me b mf my ju mh mi mz jx mk lp nn mm mn lt no mp mq lx np ms mt mu im bi translated">Java是一种O.O.P .语言，<em class="mv">可选的</em>对象本身公开了<em class="mv">映射</em>和<em class="mv">平面映射</em>方法<em class="mv">。</em>这意味着不需要将一个<em class="mv">可选的</em>对象作为参数传递——事实上，这被认为是一种代码味道和反模式<em class="mv">(下一节将详细介绍)</em>。</p><p id="ccc6" class="pw-post-body-paragraph mc md it me b mf my ju mh mi mz jx mk lp nn mm mn lt no mp mq lx np ms mt mu im bi translated">因此，我们应该使用原始类型作为方法参数:</p><pre class="kj kk kl km gt nq nr ns nt aw nu bi"><span id="f138" class="lg lh it nr b gy nv nw l nx ny">public Optional&lt;Flour&gt; mill(Wheat wheat) {<br/>   // ...<br/>}<br/><br/>public Optional&lt;Bread&gt; bake(Flour flour) {<br/>   // ...<br/>}</span></pre><p id="3771" class="pw-post-body-paragraph mc md it me b mf my ju mh mi mz jx mk lp nn mm mn lt no mp mq lx np ms mt mu im bi translated">并且链方法调用而不是组合函数，使用<em class="mv">可选</em>的<em class="mv"> map() </em>和<em class="mv"> flatMap() </em>:</p><pre class="kj kk kl km gt nq nr ns nt aw nu bi"><span id="73bb" class="lg lh it nr b gy nv nw l nx ny">Optional&lt;Bread&gt; oopBread = harvest()<br/>      .flatMap(wheat -&gt; mill(wheat))<br/>      .flatMap(flour -&gt; bake(flour));</span></pre><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ok"><img src="../Images/eabb3692809e529166cb52a180048651.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tiidNQxTSLE679h9"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">F.P .开发人员如何看待面向对象编程——图片由<a class="ae ky" href="https://unsplash.com/@vladsargu?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">弗拉德·萨尔古</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h2 id="7365" class="lg lh it bd li lj lk dn ll lm ln dp lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">6.结论——哪种面包更好？</h2><p id="a00f" class="pw-post-body-paragraph mc md it me b mf mg ju mh mi mj jx mk lp ml mm mn lt mo mp mq lx mr ms mt mu im bi translated">当F.P .特性被添加到像Java这样的O.O.P .语言中时，它们中的一些没有按照预期的方式使用，这导致了代码味道和反模式。</p><p id="338a" class="pw-post-body-paragraph mc md it me b mf my ju mh mi mz jx mk lp nn mm mn lt no mp mq lx np ms mt mu im bi translated">以Java为例，一些开发人员和团队完全反对使用<em class="mv">可选的&lt; &gt; </em>单子。比如这篇叫做<a class="ae ky" href="https://homes.cs.washington.edu/~mernst/advice/nothing-is-better-than-optional.html" rel="noopener ugc nofollow" target="_blank"> <em class="mv">的热门文章，没有什么比可选的</em> </a> <em class="mv">更好的了。</em></p><p id="67f7" class="pw-post-body-paragraph mc md it me b mf my ju mh mi mz jx mk lp nn mm mn lt no mp mq lx np ms mt mu im bi translated">但是，如果我们阅读这篇文章并检查代码片段，我们可以看到大多数问题都是由于以一种意想不到的方式使用了可选的。</p><p id="cb1a" class="pw-post-body-paragraph mc md it me b mf my ju mh mi mz jx mk lp nn mm mn lt no mp mq lx np ms mt mu im bi translated">在我看来，<em class="mv"> Optional </em>应该作为F.P. monad使用，而不是作为空检查的Java实用类。因此，我觉得将它和空值检查进行比较有点不太合适。</p><p id="98d7" class="pw-post-body-paragraph mc md it me b mf my ju mh mi mz jx mk lp nn mm mn lt no mp mq lx np ms mt mu im bi translated">我相信<em class="mv">可选的&lt; &gt; </em>特性是对语言的一个很好的补充，但是它需要训练和对<em class="mv">单子</em>概念的一些理解。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ol"><img src="../Images/f381d062a5a6b9728a3590665c401959.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7ynHl_azU_Mvft18"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Stop fighting and use the best of both worlds :)— Photo by <a class="ae ky" href="https://unsplash.com/@awmleer?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">卡晨</a> on <a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="d08d" class="pw-post-body-paragraph mc md it me b mf my ju mh mi mz jx mk lp nn mm mn lt no mp mq lx np ms mt mu im bi translated">这篇文章的灵感来自于塞萨尔·创·洛扎伊在德沃克斯的演讲。我强烈推荐你查看一下，以获得更深入的解释:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="om on l"/></div></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h1 id="345f" class="oo lh it bd li op oq or ll os ot ou lo jz ov ka ls kc ow kd lw kf ox kg ma oy bi translated">谢谢大家！</h1><p id="f184" class="pw-post-body-paragraph mc md it me b mf mg ju mh mi mj jx mk lp ml mm mn lt mo mp mq lx mr ms mt mu im bi translated">感谢你阅读这篇文章，请让我知道你的想法！欢迎任何反馈。</p><p id="aba9" class="pw-post-body-paragraph mc md it me b mf my ju mh mi mz jx mk lp nn mm mn lt no mp mq lx np ms mt mu im bi translated">如果你想阅读更多关于干净的代码、设计、单元测试、函数式编程以及许多其他内容，请务必查看我的其他文章。</p><p id="7af5" class="pw-post-body-paragraph mc md it me b mf my ju mh mi mz jx mk lp nn mm mn lt no mp mq lx np ms mt mu im bi translated">如果你喜欢我的内容，可以考虑<a class="ae ky" href="https://medium.com/@emanueltrandafir" rel="noopener">关注或者订阅</a>邮件列表。</p><p id="4519" class="pw-post-body-paragraph mc md it me b mf my ju mh mi mz jx mk lp nn mm mn lt no mp mq lx np ms mt mu im bi translated">最后，如果你考虑成为一名中等会员并支持我的博客，这里是我的<a class="ae ky" href="https://medium.com/@emanueltrandafir/membership" rel="noopener">推荐人</a>。</p><p id="826e" class="pw-post-body-paragraph mc md it me b mf my ju mh mi mz jx mk lp nn mm mn lt no mp mq lx np ms mt mu im bi translated">编码快乐！</p></div></div>    
</body>
</html>