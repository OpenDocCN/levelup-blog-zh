<html>
<head>
<title>JavaScript Best Practices — Functions and Mutations</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript最佳实践—函数和变异</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-best-practices-functions-and-mutations-43d76e280cfe?source=collection_archive---------20-----------------------#2020-06-23">https://levelup.gitconnected.com/javascript-best-practices-functions-and-mutations-43d76e280cfe?source=collection_archive---------20-----------------------#2020-06-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/8b7bc3610201f5b446b9f4d9a8faf3ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hs8EZW4pdOYE3hz2"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">Ashim D'Silva 在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="feaf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">像任何类型的应用程序一样，JavaScript应用程序也必须写得很好。否则，我们以后会遇到各种各样的问题。</p><p id="0a6b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将研究一些使用箭头函数的最佳实践。此外，我们看看为什么和如何避免突变。</p><h1 id="54b7" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">不要使用Getters和Setters</h1><p id="1376" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">因为getters和setters会带来副作用，所以如果我们想创建易于使用的函数，就不应该使用它们。</p><p id="07d3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们不应该写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="c902" class="mq lf it mm b gy mr ms l mt mu">const person = {<br/>  name: 'james',<br/>  get age() {<br/>    return this._age;<br/>  },<br/>  set age(n) {<br/>    if (n &lt; 0) {<br/>      this._age = 0;<br/>    } else if (n &gt; 200) {<br/>      this._age = 200;<br/>    } else {<br/>      this._age = n;<br/>    }<br/>  }<br/>};</span></pre><p id="dcdd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">还有，我们应该叫<code class="fe mv mw mx mm b">__defineGetter__</code>或者<code class="fe mv mw mx mm b">__defineSetter__</code>:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="1662" class="mq lf it mm b gy mr ms l mt mu">person.__defineGetter__('name', () =&gt; {<br/>  return this.name || 'james';<br/>});</span></pre><p id="f885" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">或者:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="90f8" class="mq lf it mm b gy mr ms l mt mu">person.__defineSetter__('name', (name) =&gt; {<br/>  this.name = name.trim();<br/>});</span></pre><p id="bbfe" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">相反，我们创建纯函数:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="627b" class="mq lf it mm b gy mr ms l mt mu">const restrictAge = (n, min, max) =&gt; {<br/>  if (n &lt;= min) {<br/>    return min;<br/>  }<br/>  if (n &gt;= max) {<br/>    return max;<br/>  }<br/>  return n;<br/>}</span><span id="8e9a" class="mq lf it mm b gy my ms l mt mu">const setAge = (age, person) =&gt; {<br/>  return Object.assign({}, person, { age: restrictAge(age, 0, 120 )});<br/>}</span></pre><p id="da2e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这样，我们就有了所有的纯函数，并且它比我们的setter实现更加通用，因为我们可以改变<code class="fe mv mw mx mm b">min</code>和<code class="fe mv mw mx mm b">max</code>。</p><h1 id="b36f" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">减少循环的使用</h1><p id="8a2f" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">JavaScript代码中的大多数循环都可以用数组方法重写。</p><p id="b87b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是因为已经有很多像<code class="fe mv mw mx mm b">map</code>、<code class="fe mv mw mx mm b">filter</code>和<code class="fe mv mw mx mm b">reduce</code>这样的方法可以让我们以更短的方式处理数组。</p><p id="80fe" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，与其写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="3438" class="mq lf it mm b gy mr ms l mt mu">for (const a of arr) {<br/>  result.push(a * 10);<br/>}</span></pre><p id="fc05" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="43f5" class="mq lf it mm b gy mr ms l mt mu">const result = arr.map(a =&gt; a  * 10);</span></pre><p id="775d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用<code class="fe mv mw mx mm b">map</code>比for-of循环容易得多。</p><h1 id="e71d" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">不要将变量作为第一个参数使用Object.assign</h1><p id="ac82" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mv mw mx mm b">Object.assign</code>对第一个参数进行变异。</p><p id="fd56" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，为了在不改变现有数据的情况下使用它，我们应该传入一个空对象作为第一个参数。</p><p id="0ee0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">而不是写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="6572" class="mq lf it mm b gy mr ms l mt mu">const a = { foo: 1, bar: 2 };<br/>const b = { baz: 3 };</span><span id="6022" class="mq lf it mm b gy my ms l mt mu">Object.assign(a, b);</span></pre><p id="e38b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们写道:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="ee07" class="mq lf it mm b gy mr ms l mt mu">const c = Object.assign({}, a, b);</span></pre><h1 id="d692" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">减少变异数组方法的使用</h1><p id="cec9" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">因为我们有spread操作符和可选的数组方法，所以我们可以避免在代码中使用变异的数组方法。</p><p id="81e7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，不要写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="96f6" class="mq lf it mm b gy mr ms l mt mu">arr.pop();</span></pre><p id="7d6a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="2c05" class="mq lf it mm b gy mr ms l mt mu">const arr = arr.slice(0, arr.length - 1);</span></pre><p id="bf4a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">唯一比较难替换的是<code class="fe mv mw mx mm b">sort</code>。在这种情况下，我们可以用spread操作符复制它，然后在该数组上调用<code class="fe mv mw mx mm b">sort</code>。</p><p id="2257" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="2bbc" class="mq lf it mm b gy mr ms l mt mu">const copy = [...arr];<br/>copy.sort();</span></pre><p id="30a5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以考虑使用<code class="fe mv mw mx mm b">filter</code>或<code class="fe mv mw mx mm b">slice</code>来代替<code class="fe mv mw mx mm b">splice</code>。</p><p id="3df9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们想用给定的索引删除一个元素，我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="4a50" class="mq lf it mm b gy mr ms l mt mu">const removed = arr.filter((a, i) =&gt; i !== index);</span></pre><p id="e41c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们移除索引<code class="fe mv mw mx mm b">index</code>处的项，并将其赋给一个新变量。</p><h1 id="8ca8" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">减少变异运算符的使用</h1><p id="13ce" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">很容易不小心变异数据。</p><p id="7360" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以我们可能希望避免使用变异操作符。</p><p id="6b2c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可能希望避免使用<code class="fe mv mw mx mm b">+=</code>、<code class="fe mv mw mx mm b">/=</code>、<code class="fe mv mw mx mm b">-=</code>、<code class="fe mv mw mx mm b">%=</code>或<code class="fe mv mw mx mm b">*=</code>操作符。</p><p id="5c2b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">相反，我们可以使用非变异数组方法或者给一个新变量赋值。</p><p id="9ee1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="f0c2" class="mq lf it mm b gy mr ms l mt mu">const b = a + 10;</span></pre><p id="1613" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">而不是:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="5e89" class="mq lf it mm b gy mr ms l mt mu">a += 10;</span></pre><p id="6376" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们必须通过重复添加来更新变量，我们可以使用<code class="fe mv mw mx mm b">reduce</code>:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="3c28" class="mq lf it mm b gy mr ms l mt mu">const total = arr.reduce((total, a) =&gt; total + a, 0);</span></pre><h1 id="92ce" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">在小心null或undefined之前</h1><p id="5276" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们应该始终小心使用<code class="fe mv mw mx mm b">null</code>或<code class="fe mv mw mx mm b">undefined</code>值，因为它们是许多误差的来源。</p><p id="7c6a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，在使用它们之前，我们应该确保变量或属性不是<code class="fe mv mw mx mm b">null</code>或<code class="fe mv mw mx mm b">undefined</code>。</p><p id="6f4b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了检查两者，我们可以写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="c199" class="mq lf it mm b gy mr ms l mt mu">if (val === null || val === undefined){<br/>  //...<br/>}</span></pre><p id="5b50" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">或者:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="585a" class="mq lf it mm b gy mr ms l mt mu">if (val === null || typeof val === 'undefined'){<br/>  //...<br/>}</span></pre><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/1f2908103d6ca2d6edd9af1c6aff41d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CRlVjXJAVRAv1gd1"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@amarnathtade?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">阿玛纳斯·塔德</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="0551" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="34ca" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们应该避免改变数据，这样我们就不会不小心改变它们。</p><p id="48b7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">测试不改变数据的函数也更容易。</p><p id="963c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">还有，要小心<code class="fe mv mw mx mm b">null</code>或者<code class="fe mv mw mx mm b">undefined</code>。</p></div></div>    
</body>
</html>