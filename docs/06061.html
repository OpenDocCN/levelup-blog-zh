<html>
<head>
<title>Java: How to run component tests with code coverage, using Gradle and Docker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java:如何使用Gradle和Docker运行代码覆盖的组件测试</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/java-how-to-run-component-tests-with-code-coverage-using-gradle-and-docker-47fc023969a4?source=collection_archive---------2-----------------------#2020-10-22">https://levelup.gitconnected.com/java-how-to-run-component-tests-with-code-coverage-using-gradle-and-docker-47fc023969a4?source=collection_archive---------2-----------------------#2020-10-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><blockquote class="jn jo jp"><p id="4afb" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">技术栈:Java 14，Spring，Docker，Gradle</p></blockquote><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/c12ab1b4207f07f86c66d7a751843043.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-3s3T5OV6WvD48zoX-uQow.png"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">图1:指南完成的解决方案。从单元测试业务功能开始，收集代码覆盖率。之后，在docker中启动应用程序，并启用Jacoco报告。运行组件测试，从应用程序中收集代码覆盖率。一旦测试通过，提取覆盖率报告。这意味着我们现在可以获得组件测试的所有好处，同时保持覆盖率和报告单元测试的提供。</figcaption></figure><p id="5662" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">当谈到现代基于微服务的架构的测试方法时，我经常感觉脱离了常规。在大多数项目中，我发现大量的单元测试方法被采用，产生了类似于图2的测试金字塔。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi li"><img src="../Images/c6d91b0b0b76bfa2a04b5b3760f3ad57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/format:webp/1*A7cqoaLV5Ll7ALrJXk1Ghw.png"/></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">图2:一个测试金字塔显示了单元测试是如何形成最常见的测试基础的，接下来是组件测试，然后是集成和端到端测试。</figcaption></figure><p id="5e4f" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">这确实有它的好处，单元测试可以:</p><ul class=""><li id="1f1e" class="lj lk iq jt b ju jv jy jz lf ll lg lm lh ln ko lo lp lq lr bi translated">对变更引起的错误或问题提供快速反馈。</li><li id="f691" class="lj lk iq jt b ju ls jy lt lf lu lg lv lh lw ko lo lp lq lr bi translated">提供一个结构来帮助你编写可维护和可测试的代码。例如，你可以孤立地测试一个类的事实意味着它的依赖关系是清晰的和分离的。</li><li id="dd9f" class="lj lk iq jt b ju ls jy lt lf lu lg lv lh lw ko lo lp lq lr bi translated">提供易于监控的代码覆盖度量，允许您识别您在测试中遗漏的边缘案例。</li></ul><p id="34cd" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">然而，当我们转向基于微服务的架构时，这些好处有多现实呢？</p><p id="aa37" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">微服务允许交付隔离良好的功能的独立部分，提供一个众所周知的公共契约来与它们交互(想想REST和OpenAPI、gRPC和Protobuf等)。使用这种方法，我们希望每个服务包含最少的业务逻辑，许多服务只是在一些数据存储上提供一个清晰的抽象。这意味着大多数微服务要么花时间:</p><ul class=""><li id="07a4" class="lj lk iq jt b ju jv jy jz lf ll lg lm lh ln ko lo lp lq lr bi translated">组合对其他服务的请求/响应，以便将一组服务组合在一起，形成完整的业务流程。</li><li id="bc04" class="lj lk iq jt b ju ls jy lt lf lu lg lv lh lw ko lo lp lq lr bi translated">将数据存储到某个数据层，例如在数据库上提供CRUD抽象。</li></ul><p id="2685" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">在参与了许多基于微服务的项目之后，我经常观察到大多数bug都发生在集成和存储方面，而不是业务功能的单个部分。让我举几个我发现的最常见问题的例子:</p><ul class=""><li id="559e" class="lj lk iq jt b ju jv jy jz lf ll lg lm lh ln ko lo lp lq lr bi translated">将服务组合在一起时，会发送错误的请求结构。即缺少必填字段。</li><li id="966c" class="lj lk iq jt b ju ls jy lt lf lu lg lv lh lw ko lo lp lq lr bi translated">服务给出一个调用服务不知道如何处理的响应。也就是说，我们忽略了下游服务可以返回400的事实，并且没有考虑这种情况。</li><li id="06c0" class="lj lk iq jt b ju ls jy lt lf lu lg lv lh lw ko lo lp lq lr bi translated">该服务在数据库中存储了错误的内容。我知道这听起来很武断，而且不一定是微服务独有的，当你在一个只存储数据的服务上工作时，它会变得更加普遍。</li><li id="f0e7" class="lj lk iq jt b ju ls jy lt lf lu lg lv lh lw ko lo lp lq lr bi translated">该服务未正确配置，无法与下游服务或数据库进行实际对话。例如，缺少连接字符串，没有正确配置库(即JPA存储库)，导致服务在启动时失败。</li></ul><p id="ecb1" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">考虑到这一点，让我们想想为什么单元测试可能无法正确地解决这些问题。单元测试通常在类级别测试，模拟依赖类。当你把大部分时间花在业务流程上时，这通常没什么问题，因为没什么好嘲笑的。然而，我们的大多数问题都是在这个新的微服务世界中的集成点上。因此，我们不再获得相同级别的价值，因为我们的测试花费更多的时间来模拟事物，而不是断言产品代码行为正确。</p><p id="86a8" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">例如，一个单元测试断言我们称之为一个模拟的“保存到数据库函数”,与将数据实际存储到一个真实的数据库中，并断言我们可以检索它相比，它几乎没有任何价值。模拟测试不会捕捉到任何与连接细节、库设置或假设有关的错误，或者我们调用的方法是否做了我们想要它做的事情！</p><p id="773d" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">那么，我们怎样才能从测试中获得最好的价值，同时还能保持单元测试的好处呢？</p><h2 id="a16e" class="lx ly iq bd lz ma mb dn mc md me dp mf lf mg mh mi lg mj mk ml lh mm mn mo mp bi translated">组件测试。</h2><p id="bb7c" class="pw-post-body-paragraph jq jr iq jt b ju mq jw jx jy mr ka kb lf ms ke kf lg mt ki kj lh mu km kn ko ij bi translated">就本指南而言，组件测试将被定义为:</p><blockquote class="jn jo jp"><p id="bf54" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">针对服务的公共API的外部测试。如果需要，应该使用真实的数据层。对下游应用程序的调用应该被发送到外部服务，这些服务可以通过测试来控制，从而为特定的用例提供正确的响应。</p></blockquote><p id="6fbb" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">使用这种方法，组件测试允许服务以类似生产的模式运行，使我们的测试套件能够针对服务的公共API提供最准确的保证级别。这带来了一些很大的好处:</p><ul class=""><li id="ac57" class="lj lk iq jt b ju jv jy jz lf ll lg lm lh ln ko lo lp lq lr bi translated">您的测试证明您的服务的库、依赖项、配置和部署是正确且可重复的。</li><li id="7e96" class="lj lk iq jt b ju ls jy lt lf lu lg lv lh lw ko lo lp lq lr bi translated">您的测试有助于指导您的消费者如何调用您的服务，以及对每个请求/响应的期望，因为测试的行为与任何其他消费者一样。</li><li id="a57a" class="lj lk iq jt b ju ls jy lt lf lu lg lv lh lw ko lo lp lq lr bi translated">如果在集成过程中发现了一个bug，您可以在请求中添加一个组件测试，并断言预期的响应。然后，在您开始查看代码库以确定问题可能出在哪里之前，您就可以证明您所做的任何修复，就像bug的报告者所做的那样。</li><li id="d241" class="lj lk iq jt b ju ls jy lt lf lu lg lv lh lw ko lo lp lq lr bi translated">自动化服务的配置和运行成为每个人的工作，因为现在每次运行组件测试时都需要这样做。</li><li id="ff6f" class="lj lk iq jt b ju ls jy lt lf lu lg lv lh lw ko lo lp lq lr bi translated">假设不改变公共API，您可以轻松地在服务中重构代码，而无需重写所有测试。我已经记不清有多少次我改变了一个类，却发现它包含在数百个单元测试的测试设置中，现在甚至无法编译。使用组件测试，您是从一个外部点来验证行为。因此，用来满足该行为的类变得无关紧要。</li><li id="7bc8" class="lj lk iq jt b ju ls jy lt lf lu lg lv lh lw ko lo lp lq lr bi translated">如果您确实重构了某个东西，并且一个组件测试失败了，您知道您已经破坏了您的消费者当前所依赖的一个假设。这意味着您可以准确地查看更改的效果，以及是否需要在更改到达部署环境之前通知消费者。</li></ul><p id="6d68" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">组件测试听起来确实解决了很多问题，那么为什么我们传统上做的比单元测试少呢？</p><p id="4ff4" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">嗯，这又回到了单元测试的好处。直到最近，以一种可靠的方式启动一个服务和它的数据库还是很困难的，而且通常很慢。你不想依赖一个测试包，它需要10分钟才能启动，只在一些人的机器上工作，而且测试不可靠。然而，随着容器的引入，我们现在可以在本地以可控和可靠的方式一起部署多个服务。不仅如此，Docker还提供网络和流程编排，这意味着我们可以控制整个服务环境。这有助于使组件测试更容易、更快地实现。考虑到这些好处，我个人现在认为，本指南开头所示的原始测试金字塔应该进行自我改造，如图3所示。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi li"><img src="../Images/8c9db0e52d308a153e7536bfc6f70e43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/format:webp/1*VnM6Zgi5LlUSsWNM1_OeGQ.png"/></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">图3:显示了变更后的测试金字塔。组件测试现在形成了测试方法的基础。然而，当需要确保纯粹的业务功能时，我们仍然会退回到单元测试。</figcaption></figure><p id="5def" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">正如你所看到的，我们极大地减少了单元测试的数量，但是我们并没有完全删除它们。单元测试仍然非常有价值，但是只用于测试服务的业务流程元素，而不是服务所做的一切。例如，您可能会发现有一些核心计算非常适合进行单元测试，但是结果存储在数据库中，在组件级别进行测试会更好。</p><p id="b41c" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">有了这种想要更多地关注组件测试的驱动力，我们需要找到一种可靠地实现和执行组件测试以及单元测试的方法。</p><p id="d1e4" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">本指南的其余部分将使用Gradle、Docker和Spring展示一个简单rest服务的组件测试的实现。</p><h1 id="fd88" class="mv ly iq bd lz mw mx my mc mz na nb mf nc nd ne mi nf ng nh ml ni nj nk mo nl bi translated">所需的技术</h1><p id="ba40" class="pw-post-body-paragraph jq jr iq jt b ju mq jw jx jy mr ka kb lf ms ke kf lg mt ki kj lh mu km kn ko ij bi translated">为了运行项目，需要在您的计算机上安装以下软件:</p><ul class=""><li id="fe64" class="lj lk iq jt b ju jv jy jz lf ll lg lm lh ln ko lo lp lq lr bi translated"><strong class="jt ir"> Java 14 </strong>:撰写本文时最新最好的Java版本(尽管您可以根据应用程序的需要调整Java的版本)。</li><li id="0fa5" class="lj lk iq jt b ju ls jy lt lf lu lg lv lh lw ko lo lp lq lr bi translated"><a class="ae nm" href="https://gradle.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="jt ir"> Gradle </strong> </a>:项目需要使用Gradle包装器。</li><li id="a08e" class="lj lk iq jt b ju ls jy lt lf lu lg lv lh lw ko lo lp lq lr bi translated"><strong class="jt ir"> Docker </strong>:运行服务需要最新版本的Docker和docker-compose。</li></ul><p id="6dbe" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">这篇文章扩展了下面的<a class="ae nm" href="https://medium.com/@JoeHonour/java-developing-a-spring-service-using-an-openapi-contract-first-approach-37dfd6422a9c" rel="noopener">指南</a>关于构建一个契约的第一个Spring服务。说明书将会期望这个项目的设置，但是你也可以很高兴地将代码片段添加到你自己的Gradle项目中，在需要的地方填充之前<a class="ae nm" href="https://medium.com/@JoeHonour/java-developing-a-spring-service-using-an-openapi-contract-first-approach-37dfd6422a9c" rel="noopener">指南</a>中的任何空白。如果你想跳到完成的代码示例，你可以在这里找到它<a class="ae nm" href="https://github.com/Guardian-Development/contract-first-service" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="7a3f" class="mv ly iq bd lz mw mx my mc mz na nb mf nc nd ne mi nf ng nh ml ni nj nk mo nl bi translated">1.添加组件测试</h1><p id="5d2a" class="pw-post-body-paragraph jq jr iq jt b ju mq jw jx jy mr ka kb lf ms ke kf lg mt ki kj lh mu km kn ko ij bi translated">让组件测试在服务上运行的第一步是为它们提供一个存储位置。我们最终得到的项目结构是:</p><ul class=""><li id="da65" class="lj lk iq jt b ju jv jy jz lf ll lg lm lh ln ko lo lp lq lr bi translated"><strong class="jt ir"> src/main </strong>:生产源代码</li><li id="1067" class="lj lk iq jt b ju ls jy lt lf lu lg lv lh lw ko lo lp lq lr bi translated"><strong class="jt ir"> src/test </strong>:单元测试</li><li id="cb08" class="lj lk iq jt b ju ls jy lt lf lu lg lv lh lw ko lo lp lq lr bi translated"><strong class="jt ir"> src/componentTest </strong>:组件测试。</li></ul><h2 id="6b42" class="lx ly iq bd lz ma mb dn mc md me dp mf lf mg mh mi lg mj mk ml lh mm mn mo mp bi translated">步骤1:添加初始组件测试</h2><p id="f848" class="pw-post-body-paragraph jq jr iq jt b ju mq jw jx jy mr ka kb lf ms ke kf lg mt ki kj lh mu km kn ko ij bi translated">如果您有上一篇指南中的代码库，我们将有一个返回Hello World字符串的GET端点。为了测试这一点，添加以下类:</p><p id="bb2b" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated"><strong class="jt ir">/src/component test/Java/hello world component test . Java</strong></p><p id="5dc0" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">本课程内容应包含以下内容:</p><pre class="kq kr ks kt gt nn no np nq aw nr bi"><span id="8eda" class="lx ly iq no b gy ns nt l nu nv">import org.junit.jupiter.api.Test;<br/><br/>import java.io.IOException;<br/>import java.net.URI;<br/>import java.net.http.HttpClient;<br/>import java.net.http.HttpRequest;<br/>import java.net.http.HttpResponse;<br/><br/>import static org.junit.jupiter.api.Assertions.<em class="js">assertTrue</em>;<br/><br/>public class HelloWorldComponentTest {<br/>    <br/>    @Test<br/>    public void shouldReturnHelloWorld() {<br/>        // Arrange<br/><br/>        // Act<br/>        var result = makeGetRequest("http://localhost:4000/hello");<br/><br/>        // Assert<br/>        <em class="js">assertTrue</em>(result.contains("Hello World!"));<br/>    }<br/><br/>    private String makeGetRequest(String uri) {<br/>        HttpClient client = HttpClient.<em class="js">newHttpClient</em>();<br/>        HttpRequest request = HttpRequest.<em class="js">newBuilder</em>()<br/>                .uri(URI.<em class="js">create</em>(uri))<br/>                .build();<br/><br/>        try {<br/>            return client<br/>                    .send(request, HttpResponse.BodyHandlers.<em class="js">ofString</em>())<br/>                    .body();<br/>        } catch (IOException | InterruptedException e) {<br/>            e.printStackTrace();<br/>            throw new RuntimeException(e);<br/>        }<br/>    }<br/></span></pre><p id="4c20" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">该测试发送一个GET请求，期望服务正在运行，将响应解析为一个字符串，然后断言响应包含“Hello World”。</p><p id="f39c" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">您会注意到，如果您使用的是IntelliJ或另一个IDE，这个文件就不能被正确拾取或运行。这是因为我们没有将<strong class="jt ir">/src/component test/Java</strong>目录添加到项目中。为此，我们需要将以下内容添加到<strong class="jt ir"> build.gradle </strong>文件中:</p><pre class="kq kr ks kt gt nn no np nq aw nr bi"><span id="ea6f" class="lx ly iq no b gy ns nt l nu nv">sourceSets <strong class="no ir">{<br/>   </strong>componentTest <strong class="no ir">{<br/>      </strong>java.srcDir "$projectDir/src/componentTest/java"<br/>      resources.srcDir "$projectDir/src/componentTest/resources"<br/>      compileClasspath += main.output + test.output<br/>      runtimeClasspath += main.output + test.output<br/>   <strong class="no ir">}<br/>}</strong></span></pre><p id="5757" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">componentTest源集指定了Gradle在构建过程中要包含的目录。您可以看到，我们将其配置到新创建的<strong class="jt ir"> src/componentTest/java </strong>目录。由于目录现在是项目源代码的一部分，我们需要确保它可以访问它需要的任何依赖项:</p><pre class="kq kr ks kt gt nn no np nq aw nr bi"><span id="7d8b" class="lx ly iq no b gy ns nt l nu nv">configurations {<strong class="no ir"><br/>   </strong>componentTestImplementation.extendsFrom testImplementation<br/>   componentTestRuntime.extendsFrom testRuntime<br/><strong class="no ir">}</strong></span></pre><p id="eafe" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">这允许组件测试执行目标扩展等价的测试目标，给予它们与单元测试相同的依赖关系。现在我们可以构建组件测试了。最后要添加的是运行测试的任务本身:</p><pre class="kq kr ks kt gt nn no np nq aw nr bi"><span id="42f2" class="lx ly iq no b gy ns nt l nu nv">// run the componentTest/** tests<br/>task componentTest(type: Test) <strong class="no ir">{<br/>   </strong>description = 'Runs component tests'<br/>   group = 'verification'<br/>   testClassesDirs = sourceSets.componentTest.output.classesDirs<br/>   classpath = sourceSets.componentTest.runtimeClasspath<br/>   outputs.upToDateWhen <strong class="no ir">{ </strong>false <strong class="no ir">}<br/>}<br/><br/></strong>// print tests out to console as they run<br/>def testLogging = <strong class="no ir">{<br/>   </strong>afterTest <strong class="no ir">{ </strong>desc, result <strong class="no ir">-&gt;<br/>      </strong>logger.quiet "Test $<strong class="no ir">{</strong>desc.name<strong class="no ir">}</strong> [$<strong class="no ir">{</strong>desc.className<strong class="no ir">}</strong>] with result: $<strong class="no ir">{</strong>result.resultType<strong class="no ir">}</strong>"<br/>   <strong class="no ir">}<br/>}<br/><br/></strong>test <strong class="no ir">{<br/>   </strong>configure testLogging<br/>   useJUnitPlatform()<br/><strong class="no ir">}<br/><br/></strong>componentTest <strong class="no ir">{<br/>   </strong>configure testLogging<br/>   useJUnitPlatform()<br/><strong class="no ir">}</strong></span></pre><p id="e3e3" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">这增加了一个<strong class="jt ir"> componentTest </strong>任务，它在搜索测试时使用组件测试源集。作为一个额外的补充，我还为两个测试目标添加了一些日志记录，以帮助调试任何失败的测试。</p><p id="0a09" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">有了这些对<strong class="jt ir"> build.gradle </strong>文件的补充，如果你刷新你的IntelliJ配置，或者运行:</p><pre class="kq kr ks kt gt nn no np nq aw nr bi"><span id="fc76" class="lx ly iq no b gy ns nt l nu nv">./gradlew clean build</span></pre><p id="6807" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">现在您将看到componentTest目录被正确导入并且可用。</p><h2 id="56ce" class="lx ly iq bd lz ma mb dn mc md me dp mf lf mg mh mi lg mj mk ml lh mm mn mo mp bi translated">步骤2:运行测试</h2><p id="003e" class="pw-post-body-paragraph jq jr iq jt b ju mq jw jx jy mr ka kb lf ms ke kf lg mt ki kj lh mu km kn ko ij bi translated">为了运行组件测试，我们需要启动应用程序。为此，从命令行运行以下命令:</p><pre class="kq kr ks kt gt nn no np nq aw nr bi"><span id="45e1" class="lx ly iq no b gy ns nt l nu nv">./gradlew bootRun</span></pre><p id="5af9" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">您应该看到Spring开始记录到stdout，服务现在将在端口4000上监听。</p><p id="63c3" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">在服务运行的情况下，从另一个命令提示符运行:</p><pre class="kq kr ks kt gt nn no np nq aw nr bi"><span id="3f89" class="lx ly iq no b gy ns nt l nu nv">./gradlew componentTest</span></pre><p id="7263" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">这将执行我们添加的组件测试任务，在日志中，您应该会看到类似于以下内容的消息:</p><pre class="kq kr ks kt gt nn no np nq aw nr bi"><span id="2942" class="lx ly iq no b gy ns nt l nu nv">Test shouldReturnHelloWorld() [org.guardiandev.helloservice.HelloWorldComponentTest] with result: SUCCESS</span></pre><p id="a6a4" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">在这一点上，我们有办法通过Gradle运行组件测试。然而，我们不希望每次运行服务时都自己手动启动和停止它们。在理想的情况下，我们希望组件测试的执行也包含任何需要的设置和拆卸。为了实现这一点，我们将把Docker集成到构建中。</p><h2 id="e821" class="lx ly iq bd lz ma mb dn mc md me dp mf lf mg mh mi lg mj mk ml lh mm mn mo mp bi translated">2.使用Gradle在Docker中运行服务</h2><p id="c041" class="pw-post-body-paragraph jq jr iq jt b ju mq jw jx jy mr ka kb lf ms ke kf lg mt ki kj lh mu km kn ko ij bi translated">为了给应用程序提供docker支持，我们需要将以下文件添加到项目的根目录中:</p><ul class=""><li id="8626" class="lj lk iq jt b ju jv jy jz lf ll lg lm lh ln ko lo lp lq lr bi translated"><strong class="jt ir"> Dockerfile </strong>:包含Docker构建指令</li><li id="9ba6" class="lj lk iq jt b ju ls jy lt lf lu lg lv lh lw ko lo lp lq lr bi translated"><strong class="jt ir">。env </strong>:包含我们可以在docker合成文件中使用的环境变量。</li><li id="8511" class="lj lk iq jt b ju ls jy lt lf lu lg lv lh lw ko lo lp lq lr bi translated">docker-compose.yml :将包含应用程序需要的任何依赖项，例如数据库。</li><li id="46b1" class="lj lk iq jt b ju ls jy lt lf lu lg lv lh lw ko lo lp lq lr bi translated"><strong class="jt ir">docker-compose . override . yml</strong>:将包含运行服务的配置。</li></ul><p id="73f1" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">我们将服务放在覆盖文件中，而不是全部放在<strong class="jt ir"> docker-compose.yml </strong>文件中的原因是，我们可以在不打开服务的情况下启动依赖项。这意味着如果需要，我们可以在IntelliJ中运行/调试服务，同时仍然使用docker来运行服务所依赖的任何外部内容。</p><p id="8007" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">由于应用程序目前不需要任何外部依赖关系，<strong class="jt ir"> docker-compose.yml </strong>文件只需要包含:</p><pre class="kq kr ks kt gt nn no np nq aw nr bi"><span id="8571" class="lx ly iq no b gy ns nt l nu nv">version: '3.7'<br/><br/>networks:<br/>  default:<br/>    name: contract-first-service</span></pre><p id="5b50" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">这将简单地命名默认网络，如果我们需要调试任何Docker编写问题，可以更容易地识别这个服务。</p><p id="a282" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">实现了初始docker-compose文件后，让我们添加<strong class="jt ir">docker-compose . override . yml</strong>文件，我们用它来启动应用程序。</p><pre class="kq kr ks kt gt nn no np nq aw nr bi"><span id="7c19" class="lx ly iq no b gy ns nt l nu nv">version: '3.7'<br/><br/>services:<br/>  contract-first-service:<br/>    image: ${SERVICE_GROUP}/${SERVICE_NAME}:${SERVICE_TAG}<br/>    ports:<br/>      - 4000:4000<br/>    environment:<br/>      - SPRING_PROFILE=${SPRING_PROFILE}</span></pre><p id="ad34" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">运行docker-compose up时默认选择的这个覆盖文件引用环境变量来获取docker图像名称、标记和配置文件。这意味着下面的<strong class="jt ir">。env </strong>文件是必需的:</p><pre class="kq kr ks kt gt nn no np nq aw nr bi"><span id="95de" class="lx ly iq no b gy ns nt l nu nv">SERVICE_TAG=latest<br/>SERVICE_GROUP=com.guardiandev<br/>SERVICE_NAME=helloservice<br/>SPRING_PROFILE=default</span></pre><p id="5765" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">您可以看到，我们目前有想要在docker-compose中引用的变量的默认值。但是，我们即将添加Gradle任务来与Docker交互，这些变量将被替换。</p><p id="0de7" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">为了支持用Docker高效地构建东西，我们需要一种方法来下载应用程序需要的所有依赖项。首先，将以下配置添加到您的<strong class="jt ir"> build.gradle </strong>文件中:</p><blockquote class="jn jo jp"><p id="6ebd" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">注意:对于像configurations块这样的东西，您应该将代码片段的内容添加到现有的配置中(不要定义配置两次)。我只是向您展示当前任务所需的一些配置，而不是每次都展示整个配置。</p></blockquote><pre class="kq kr ks kt gt nn no np nq aw nr bi"><span id="805a" class="lx ly iq no b gy ns nt l nu nv">configurations <strong class="no ir">{<br/>   </strong>downloadDependenciesConfig.extendsFrom implementation, testImplementation, testRuntime<br/><strong class="no ir">}<br/><br/></strong>// pull dependencies needed by the application<br/>task downloadDependencies (type: Exec) <strong class="no ir">{<br/>   </strong>configurations.downloadDependenciesConfig.files<br/>   commandLine 'echo', 'Downloaded all dependencies'<br/><strong class="no ir">}</strong></span></pre><p id="acab" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">这为我们提供了一个名为<strong class="jt ir"> downloadDependencies </strong>的任务，当我们执行它时，将强制解析实现、测试实现和测试运行时依赖。</p><p id="6f87" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">下一步是在Docker中添加一个任务来构建服务:</p><pre class="kq kr ks kt gt nn no np nq aw nr bi"><span id="5f62" class="lx ly iq no b gy ns nt l nu nv">task buildDockerimage(type: Exec) <strong class="no ir">{<br/>   </strong>workingDir "$projectDir"<br/>   commandLine 'docker', 'build', '.', '-t', "$serviceGroupId/$serviceApplicationName:$serviceVersion"<br/><strong class="no ir">}</strong></span></pre><p id="facb" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">这将获取Dockerfile(我将在本指南的下一部分向您展示)并构建应用程序映像。我们用与JAR相同的groupId、名称和版本来标记图像，这样很容易确定容器中运行的代码版本。</p><p id="6256" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">下一步是添加对向上和向下组合应用程序及其依赖项的支持:</p><pre class="kq kr ks kt gt nn no np nq aw nr bi"><span id="60f1" class="lx ly iq no b gy ns nt l nu nv">task composeUp(type: Exec) <strong class="no ir">{<br/>   </strong>dependsOn buildDockerimage<br/>   workingDir "$projectDir"<br/>   environment &lt;&lt; [ SERVICE_TAG: "$serviceVersion", SERVICE_GROUP: "$serviceGroupId", SERVICE_NAME: "$serviceApplicationName", SPRING_PROFILE: "docker" ]<br/>   commandLine 'docker-compose', 'up', '-d'<br/><strong class="no ir">}</strong></span><span id="9775" class="lx ly iq no b gy nw nt l nu nv">task composeDependenciesUp(type: Exec) <strong class="no ir">{<br/>   </strong>workingDir "$projectDir"<br/>   commandLine 'docker-compose', '-f', 'docker-compose.yml', 'up', '-d'<br/><strong class="no ir">}</strong></span><span id="7f6b" class="lx ly iq no b gy nw nt l nu nv">task composeDown(type: Exec) <strong class="no ir">{<br/>   </strong>workingDir "$projectDir"<br/>   commandLine 'docker-compose', 'down', '-t', '60', '-v'<br/><strong class="no ir">}</strong></span></pre><p id="9cdf" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">这3个任务使用我们在项目根目录中的docker-compose文件来:</p><ul class=""><li id="280b" class="lj lk iq jt b ju jv jy jz lf ll lg lm lh ln ko lo lp lq lr bi translated"><strong class="jt ir"> composeUp </strong>:打开服务，确保我们已经首先构建了它，以及它的依赖项。</li><li id="9eab" class="lj lk iq jt b ju ls jy lt lf lu lg lv lh lw ko lo lp lq lr bi translated"><strong class="jt ir"> composeDependenciesUp </strong>:仅打开服务运行所需的依赖项。</li><li id="ffb7" class="lj lk iq jt b ju ls jy lt lf lu lg lv lh lw ko lo lp lq lr bi translated"><strong class="jt ir"> composeDown </strong>:关闭docker compose中当前运行的所有资源。</li></ul><p id="f54e" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">这样，我们现在可以使用Gradle来协调服务的开启和关闭。我们需要做的最后一步，是将它与组件测试任务挂钩，这样我们就可以:</p><ul class=""><li id="f13f" class="lj lk iq jt b ju jv jy jz lf ll lg lm lh ln ko lo lp lq lr bi translated">启动服务及其依赖项</li><li id="2cd3" class="lj lk iq jt b ju ls jy lt lf lu lg lv lh lw ko lo lp lq lr bi translated">等待服务准备就绪</li><li id="84c7" class="lj lk iq jt b ju ls jy lt lf lu lg lv lh lw ko lo lp lq lr bi translated">运行组件测试</li><li id="fafa" class="lj lk iq jt b ju ls jy lt lf lu lg lv lh lw ko lo lp lq lr bi translated">清理我们启动的任何资源</li></ul><p id="fa1a" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">为此，我们添加了最后一项配置:</p><pre class="kq kr ks kt gt nn no np nq aw nr bi"><span id="f07e" class="lx ly iq no b gy ns nt l nu nv">task waitForService <strong class="no ir">{<br/>   </strong>doLast <strong class="no ir">{<br/>      </strong>def responseCode = null<br/><br/>      while(responseCode != 200) {<br/>         <em class="js">sleep </em>1000<br/>         try {<br/>            def req = "http://localhost:4000/actuator/health".toURL().openConnection()<br/>            responseCode = req.getResponseCode()<br/>            logger.log(LogLevel.<em class="js">INFO</em>, "Response returned from service $responseCode")<br/>         }<br/>         catch(Exception) {<br/>            logger.log(LogLevel.<em class="js">INFO</em>, "Failed to connect to service")<br/>         }<br/>      }<br/>   <strong class="no ir">}<br/>}</strong></span><span id="ed17" class="lx ly iq no b gy nw nt l nu nv">task componentTestDocker <strong class="no ir">{<br/>   </strong>dependsOn componentTestClasses, composeUp, waitForService<br/>   doLast <strong class="no ir">{<br/>      </strong>componentTest.executeTests()<br/>   <strong class="no ir">}<br/>   </strong>finalizedBy composeDown<br/><strong class="no ir">}</strong></span></pre><p id="5a6d" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">在这个代码片段中，我们添加了一个继续轮询服务的任务，等待来自健康端点的200响应。然后，我们将所有任务连接到一个<strong class="jt ir"> componentTestDocker </strong>任务中，该任务:</p><ul class=""><li id="f67b" class="lj lk iq jt b ju jv jy jz lf ll lg lm lh ln ko lo lp lq lr bi translated">编译组件测试</li><li id="43c6" class="lj lk iq jt b ju ls jy lt lf lu lg lv lh lw ko lo lp lq lr bi translated">调用<strong class="jt ir"> composeUp </strong>来打开服务和依赖项</li><li id="faf7" class="lj lk iq jt b ju ls jy lt lf lu lg lv lh lw ko lo lp lq lr bi translated">调用<strong class="jt ir"> waitForService </strong>来确保我们不会在服务启动之前执行测试</li><li id="23e1" class="lj lk iq jt b ju ls jy lt lf lu lg lv lh lw ko lo lp lq lr bi translated">执行组件测试</li><li id="2b53" class="lj lk iq jt b ju ls jy lt lf lu lg lv lh lw ko lo lp lq lr bi translated">一旦测试完成，通过调用<strong class="jt ir"> composeDown </strong>进行整理</li></ul><p id="9abe" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">这些都是我们需要添加到<strong class="jt ir"> build.gradle </strong>文件中的更改，以便使用docker。</p><p id="ee11" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">我们剩下要做的最后一步是实现如下所示的<strong class="jt ir"> Dockerfile </strong>:</p><pre class="kq kr ks kt gt nn no np nq aw nr bi"><span id="ccd9" class="lx ly iq no b gy ns nt l nu nv"><em class="js"># build custom JRE<br/></em>FROM openjdk:14-alpine AS jre-build<br/>WORKDIR /app<br/><br/>RUN jlink --verbose \<br/>--compress 2 \<br/>--strip-java-debug-attributes \<br/>--no-header-files \<br/>--no-man-pages \<br/>--output jre \<br/>--add-modules java.base\<br/>,java.logging\<br/>,java.xml\<br/>,jdk.unsupported\<br/>,java.sql\<br/>,java.naming\<br/>,java.desktop\<br/>,java.management\<br/>,java.security.jgss\<br/>,java.instrument<br/><br/><em class="js"># start from gradle build image<br/></em>FROM jre-build AS build<br/>WORKDIR /app<br/><br/><em class="js"># copy gradle only files over<br/></em>COPY gradlew gradlew<br/>COPY gradle/ gradle/<br/>RUN ./gradlew --version<br/><br/><em class="js"># copy project build files over<br/></em>COPY build.gradle build.gradle<br/>COPY settings.gradle settings.gradle<br/>COPY gradle.properties gradle.properties<br/><br/><em class="js"># download dependencies only<br/></em>RUN ./gradlew downloadDependencies<br/><br/><em class="js"># copy full solution and build<br/></em>COPY . .<br/>RUN ./gradlew build<br/><br/><em class="js"># take a smaller runtime image for the final output<br/></em>FROM alpine:latest<br/><br/>COPY --from=jre-build /app/jre /jre<br/>COPY --from=build /app/build/libs/helloservice-0.0.1.jar /app.jar<br/><br/>ENV SPRING_PROFILE=default<br/>ENV JAVA_TOOL_OPTIONS=<br/><br/>EXPOSE 4000<br/>ENTRYPOINT /jre/bin/java -Dspring.profiles.active=$SPRING_PROFILE -jar app.jar</span></pre><p id="f782" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">docker构建的工作方式如下:</p><ol class=""><li id="9f3c" class="lj lk iq jt b ju jv jy jz lf ll lg lm lh ln ko nx lp lq lr bi translated"><strong class="jt ir"> jre-build </strong>使用新的java模块特性来构建一个更小的jre，只包含运行Spring应用程序所需的部分。</li><li id="67d1" class="lj lk iq jt b ju ls jy lt lf lu lg lv lh lw ko nx lp lq lr bi translated">下一步是在运行<strong class="jt ir"> downloadDependencies </strong>任务之前，将Gradle配置文件复制到映像中。这将在映像中创建一个可以缓存的层，并下载所有的依赖项。因此，如果我们不编辑Gradle文件，我们就不必在重建映像时下载任何包。</li><li id="2639" class="lj lk iq jt b ju ls jy lt lf lu lg lv lh lw ko nx lp lq lr bi translated">下载完依赖项后，下一步将复制解决方案中的所有文件，并构建JAR。</li><li id="6123" class="lj lk iq jt b ju ls jy lt lf lu lg lv lh lw ko nx lp lq lr bi translated">最后，我们采用alpine运行时环境(创建尽可能小的运行时映像)，复制JRE和应用程序JAR，并设置启动时运行应用程序的入口点。</li></ol><p id="5ee0" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">实现了这些之后，您现在应该能够运行下面的任务来运行组件测试了:</p><pre class="kq kr ks kt gt nn no np nq aw nr bi"><span id="aee5" class="lx ly iq no b gy ns nt l nu nv">./gradlew componentTestDocker</span></pre><p id="1a9f" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">如果你在这里遇到了什么困难，请参考参考<a class="ae nm" href="https://github.com/Guardian-Development/contract-first-service" rel="noopener ugc nofollow" target="_blank">实现</a>，因为我知道我刚刚概述了很多配置:)</p><p id="bcdc" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">鉴于你有这个工作，你现在有:</p><ul class=""><li id="27cf" class="lj lk iq jt b ju jv jy jz lf ll lg lm lh ln ko lo lp lq lr bi translated">一种既能运行单元测试又能运行组件测试的测试方法</li><li id="424c" class="lj lk iq jt b ju ls jy lt lf lu lg lv lh lw ko lo lp lq lr bi translated">在docker中运行的应用程序，docker-compose用于编排本地开发和测试的依赖关系。</li><li id="c981" class="lj lk iq jt b ju ls jy lt lf lu lg lv lh lw ko lo lp lq lr bi translated">Gradle被用作控制整个服务构建过程的工具，将config保存在一个地方。</li></ul><p id="ae66" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">当交付REST base微服务时，这是一个很好的点，如果您就此打住，我不会责怪您。然而，为了真正为服务提供最佳的测试方法，我们还可以做最后一件事:向组件和单元测试添加代码覆盖报告。</p><h1 id="7a9a" class="mv ly iq bd lz mw mx my mc mz na nb mf nc nd ne mi nf ng nh ml ni nj nk mo nl bi translated">3.用Jacoco收集代码覆盖率</h1><p id="2c73" class="pw-post-body-paragraph jq jr iq jt b ju mq jw jx jy mr ka kb lf ms ke kf lg mt ki kj lh mu km kn ko ij bi translated">Jacoco是一个插件，我们可以用它来捕获正在运行的JVM的代码覆盖率，然后生成一个报告。为了收集Jacoco的代码覆盖率，我们需要收集单元测试和组件测试的覆盖率报告。单元测试非常简单，当我们添加Jacoco插件时，我们将免费得到它。然而，当我们运行组件测试时，从docker映像中获取代码覆盖率会稍微棘手一些。</p><p id="fe34" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">在我们陷入实现之前，让我给你一个Jacoco如何工作以及我们将如何利用它的快速概述。</p><p id="0d7a" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">Jacoco分为两部分:</p><ol class=""><li id="b0ff" class="lj lk iq jt b ju jv jy jz lf ll lg lm lh ln ko nx lp lq lr bi translated">Jacoco提供了一个Java代理，它附加到正在运行的应用程序的JVM上，并记录所有执行的类/行。一旦JVM终止，代理将生成一个exec文件，该文件包含JVM生命周期中执行的所有内容的覆盖率报告。</li><li id="627e" class="lj lk iq jt b ju ls jy lt lf lu lg lv lh lw ko nx lp lq lr bi translated">Jacoco插件获取覆盖报告并生成一个人类可读的报告，使用过滤器排除任何库或依赖项。</li></ol><p id="95f5" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">因此，为了从运行的应用程序中收集覆盖率，当我们执行组件测试时，我们将:</p><ul class=""><li id="2e8f" class="lj lk iq jt b ju jv jy jz lf ll lg lm lh ln ko lo lp lq lr bi translated">提供一个Gradle任务，将Jacoco代理下载到一个已知的位置，这样我们就可以将它挂载到docker容器中。</li><li id="2319" class="lj lk iq jt b ju ls jy lt lf lu lg lv lh lw ko lo lp lq lr bi translated">提供一个新的<strong class="jt ir">docker-compose . jacoco . override . yml</strong>文件，以便启动附加了Jacoco代理的应用程序。这意味着当我们运行容器时，Jacoco代理将收集所有执行的代码。</li><li id="1c1c" class="lj lk iq jt b ju ls jy lt lf lu lg lv lh lw ko lo lp lq lr bi translated">使用新的docker compose override文件，添加Gradle任务以在此覆盖模式下运行服务。随着服务的运行，我们将执行组件测试。一旦它们完成，我们将通过阅读Jacoco覆盖报告生成一个报告。</li></ul><p id="3677" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">那么……有了Jacoco如何工作的知识，让我们开始吧。首先，让我们将新的<strong class="jt ir">docker-compose . ja coco . override . yml</strong>文件添加到项目的根目录:</p><pre class="kq kr ks kt gt nn no np nq aw nr bi"><span id="32b1" class="lx ly iq no b gy ns nt l nu nv">version: '3.7'<br/><br/>services:<br/>  contract-first-service:<br/>    image: ${SERVICE_GROUP}/${SERVICE_NAME}:${SERVICE_TAG}<br/>    ports:<br/>      - 4000:4000<br/>    volumes:<br/>      - type: bind<br/>        source: ./build/jacoco<br/>        target: /jacoco<br/>    environment:<br/>      - JAVA_TOOL_OPTIONS=-javaagent:/jacoco/org.jacoco.agent-runtime.jar=destfile=/jacoco/componentTest.exec<br/>      - SPRING_PROFILE=${SPRING_PROFILE}</span></pre><p id="fe48" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">这个覆盖文件打开了服务，和以前一样。但是，您可以看到我们做了两件新的事情:</p><ol class=""><li id="faf2" class="lj lk iq jt b ju jv jy jz lf ll lg lm lh ln ko nx lp lq lr bi translated">我们将<strong class="jt ir">构建/jacoco </strong>文件夹绑定到容器中的<strong class="jt ir"> /jacoco </strong>位置。这意味着，如果我们将Jacoco代理放在<strong class="jt ir"> build/jacoco </strong>位置，我们可以在启动应用程序时访问它。此外，如果我们将覆盖报告写到这个位置，我们将可以在容器外部访问它。</li><li id="597f" class="lj lk iq jt b ju ls jy lt lf lu lg lv lh lw ko nx lp lq lr bi translated">我们覆盖<strong class="jt ir"> JAVA_TOOL_OPTIONS </strong>来将Jacoco代理附加到应用程序JVM，并将覆盖报告输出到<strong class="jt ir">/Jacoco/component test . exec</strong>。这意味着当测试停止时，由于步骤1中的卷绑定，覆盖率报告将在<strong class="jt ir"> build/jacoco </strong>中结束。</li></ol><p id="442e" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">现在我们有了一个在启用Jacoco的情况下运行服务的方法，让我们看看我们需要向<strong class="jt ir"> build.gradle </strong>文件添加什么来启用它。</p><p id="5ece" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">首先，我们需要一种下载Jacoco代理的方法。</p><pre class="kq kr ks kt gt nn no np nq aw nr bi"><span id="fa29" class="lx ly iq no b gy ns nt l nu nv">configurations {<br/>   downloadJacoco<br/><strong class="no ir">}</strong></span><span id="72ba" class="lx ly iq no b gy nw nt l nu nv">dependencies {<strong class="no ir"><br/>    </strong>downloadJacoco "org.jacoco:org.jacoco.agent:0.8.5:runtime"<br/><strong class="no ir">}</strong></span><span id="8638" class="lx ly iq no b gy nw nt l nu nv">task copyJacocoAgent(type: Copy) <strong class="no ir">{<br/>   </strong>from configurations.downloadJacoco<br/>   into "$buildDir/jacoco"<br/><br/>   // strip version number out of agent jar<br/>   configurations.downloadJacoco.allDependencies.each <strong class="no ir">{<br/>      </strong>rename "-$<strong class="no ir">{</strong>it.version<strong class="no ir">}</strong>", ""<br/>   <strong class="no ir">}<br/>}</strong></span></pre><p id="df1f" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">从上面的代码片段中可以看到，我们添加了一个名为<strong class="jt ir">downloadjaco</strong>的新配置。然后，我们将Jacoco代理注册为这个配置的依赖项。当执行时，<strong class="jt ir"> copyJacocoAgent </strong>任务简单地从Maven下载并复制代理JAR到<strong class="jt ir"> build/jacoco </strong>目录，同时去掉其名称中的任何版本号。</p><p id="c9f3" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">有了下载Jacoco代理的能力，接下来我们需要做的是用docker启动服务，但是使用覆盖覆盖配置。</p><pre class="kq kr ks kt gt nn no np nq aw nr bi"><span id="3ab9" class="lx ly iq no b gy ns nt l nu nv">task composeUpJacoco(type: Exec) <strong class="no ir">{<br/>   </strong>dependsOn buildDockerimage, copyJacocoAgent<br/>   workingDir "$projectDir"<br/>   environment &lt;&lt; [ SERVICE_TAG: "$serviceVersion", SERVICE_GROUP: "$serviceGroupId", SERVICE_NAME: "$serviceApplicationName", SPRING_PROFILE: "docker" ]<br/>   commandLine 'docker-compose', '-f', 'docker-compose.yml', '-f', 'docker-compose.jacoco.override.yml', 'up', '-d'<br/><strong class="no ir">}</strong></span><span id="7153" class="lx ly iq no b gy nw nt l nu nv">task componentTestCoverageDocker <strong class="no ir">{<br/>   </strong>dependsOn componentTestClasses, composeUpJacoco, waitForService<br/>   doLast <strong class="no ir">{<br/>      </strong>componentTest.executeTests()<br/>   <strong class="no ir">}<br/>   </strong>finalizedBy composeDown<br/><strong class="no ir">}</strong></span></pre><p id="1a06" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">使用上面的配置，<strong class="jt ir"> composeUpJacoco </strong>下载Jacoco代理，如果您还记得的话，我们在docker compose override文件中挂载了这个代理。然后，<strong class="jt ir">componentestcoverageDocker</strong>任务使用这个docker配置来打开服务，对容器运行组件测试，然后清理环境。</p><blockquote class="jn jo jp"><p id="7a47" class="jq jr js jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ij bi translated">注意:由于Jacoco只生成关于JVM正常关闭的完整报告，所以在编写关闭调用时需要留出时间。这就是为什么，如果您查看composeDown任务，我们会提供1分钟的超时。</p></blockquote><p id="2e67" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">在运行了<strong class="jt ir">componentestcoveragedocker</strong>之后，您应该会在<strong class="jt ir"> build/jacoco </strong>目录中看到一个<strong class="jt ir"> componentTest.exec </strong>报告，其中包含了所有组件测试运行之后服务的覆盖率统计数据。</p><p id="f530" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">最后一步是现在获取这个报告，将它与单元测试报告相结合，并生成一个人类可读的输出，让我们完全看到服务的代码覆盖率。</p><pre class="kq kr ks kt gt nn no np nq aw nr bi"><span id="ac55" class="lx ly iq no b gy ns nt l nu nv">// adding jacoco test reporting<br/>jacoco <strong class="no ir">{<br/>   </strong>toolVersion = "$jacocoToolVersion"<br/><strong class="no ir">}<br/></strong><br/>task fullCoverageReport(type: JacocoReport) <strong class="no ir">{<br/>   </strong>dependsOn test, componentTestCoverageDocker<br/>   executionData tasks.withType(Test)<br/>   sourceSets sourceSets.main<br/>   reports <strong class="no ir">{<br/>      </strong>html.enabled = true<br/>      html.destination file("$buildDir/jacoco-reports")<br/>   <strong class="no ir">}<br/>}</strong></span></pre><p id="2da5" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">上面的片段是拼图的最后一块。它添加了一个运行单元测试和组件测试的任务。然后，该任务查找两个测试任务的executionData(生成的exec文件)。最后，它过滤报告，只包含主源集中的类，并生成html格式的输出(图4)。</p><pre class="kq kr ks kt gt nn no np nq aw nr bi"><span id="089d" class="lx ly iq no b gy ns nt l nu nv">./gradlew fullCoverageReport</span></pre><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi ny"><img src="../Images/6ca736ec2df77ac5764208b94958778d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uFDX1p-LKfVK8mf8qXDnkw.png"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk translated">图4:由Jacoco生成的全覆盖报告。这结合了单元测试和组件测试的覆盖率。您可以点击任何一个类来查看精确的逐行覆盖范围。</figcaption></figure><p id="1c57" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">该报告位于:<strong class="jt ir">build/jacoco-reports/index . html .</strong></p><p id="3531" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">如果你想看一个工作的，完全实现的例子，你可以去我的<a class="ae nm" href="https://github.com/Guardian-Development/contract-first-service" rel="noopener ugc nofollow" target="_blank"> github </a>。</p><h1 id="5589" class="mv ly iq bd lz mw mx my mc mz na nb mf nc nd ne mi nf ng nh ml ni nj nk mo nl bi translated">结论</h1><p id="27e7" class="pw-post-body-paragraph jq jr iq jt b ju mq jw jx jy mr ka kb lf ms ke kf lg mt ki kj lh mu km kn ko ij bi translated">在本指南结束时，假设一切顺利，我们现在有能力:</p><ul class=""><li id="53a0" class="lj lk iq jt b ju jv jy jz lf ll lg lm lh ln ko lo lp lq lr bi translated">可靠地对服务进行单元测试。</li><li id="6c7e" class="lj lk iq jt b ju ls jy lt lf lu lg lv lh lw ko lo lp lq lr bi translated">可靠地对服务进行组件测试，使用docker来编排应用程序及其依赖项的运行。</li><li id="2536" class="lj lk iq jt b ju ls jy lt lf lu lg lv lh lw ko lo lp lq lr bi translated">从单元和组件测试中收集代码覆盖率，生成一个统一的报告。</li></ul><p id="23f9" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">我希望你可以看到在基于微服务的环境中优先考虑组件测试的好处，并且，通过少量的前期工作，你可以使它们像单元测试一样快速有效地工作。</p><p id="2192" class="pw-post-body-paragraph jq jr iq jt b ju jv jw jx jy jz ka kb lf kd ke kf lg kh ki kj lh kl km kn ko ij bi translated">如果您对这种方法有任何疑问，请随时联系我。</p><div class="nz oa gp gr ob oc"><a href="https://www.linkedin.com/in/joe-honour-8693029a/" rel="noopener  ugc nofollow" target="_blank"><div class="od ab fo"><div class="oe ab of cl cj og"><h2 class="bd ir gy z fp oh fr fs oi fu fw ip bi translated">Joe Honour -高级软件工程师-和数字| LinkedIn</h2><div class="oj l"><h3 class="bd b gy z fp oh fr fs oi fu fw dk translated">查看Joe Honour在全球最大的职业社区LinkedIn上的个人资料。乔有6份工作列在他们的…</h3></div><div class="ok l"><p class="bd b dl z fp oh fr fs oi fu fw dk translated">www.linkedin.com</p></div></div><div class="ol l"><div class="om l on oo op ol oq kz oc"/></div></div></a></div></div></div>    
</body>
</html>