<html>
<head>
<title>Sharing State with the React Context API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">与React上下文API共享状态</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/sharing-state-with-the-react-context-api-f24fcb9c7ce2?source=collection_archive---------2-----------------------#2020-03-20">https://levelup.gitconnected.com/sharing-state-with-the-react-context-api-f24fcb9c7ce2?source=collection_archive---------2-----------------------#2020-03-20</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/59c3cbdd197b9249a1eba49505c44785.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZVFBOUB9wAGtFoVv"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@priscilladupreez?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">普里西拉·杜·普里兹</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="6ee7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">React是一个用于创建前端视图的库。它有一个庞大的图书馆生态系统与之合作。此外，我们可以用它来增强现有的应用程序。</p><p id="02b5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">React组件只能通过props将数据从父组件传递到子组件。通过允许具有其他关系的组件共享数据，上下文API对此进行了补充。</p><p id="b8a4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将研究如何使用它在组件之间共享数据。</p><h1 id="024e" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">何时使用上下文</h1><p id="d639" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们应该使用上下文在React组件之间共享数据。但是，应该谨慎使用它，因为它会在组件之间产生紧密耦合。</p><p id="4e82" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要在一个简单的应用程序中使用它，我们可以编写以下代码:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="dc34" class="mq lf it mm b gy mr ms l mt mu">const ColorContext = React.createContext("green");</span><span id="0941" class="mq lf it mm b gy mv ms l mt mu">class Button extends React.Component {<br/>  render() {<br/>    return (<br/>      &lt;div&gt;<br/>        &lt;ColorContext.Consumer&gt;<br/>          {value =&gt; (<br/>            &lt;button style={{ color: value }}&gt;{this.props.children}&lt;/button&gt;<br/>          )}<br/>        &lt;/ColorContext.Consumer&gt;<br/>      &lt;/div&gt;<br/>    );<br/>  }<br/>}</span><span id="ec70" class="mq lf it mm b gy mv ms l mt mu">class App extends React.Component {<br/>  render() {<br/>    return (<br/>      &lt;div&gt;<br/>        &lt;ColorContext.Provider value="blue"&gt;<br/>          &lt;Button&gt;Click Me&lt;/Button&gt;<br/>        &lt;/ColorContext.Provider&gt;<br/>      &lt;/div&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="3505" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们通过编写以下内容创建了一个共享数据的上下文:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="5cc7" class="mq lf it mm b gy mr ms l mt mu">const ColorContext = React.createContext("green");</span></pre><p id="b28e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mw mx my mm b">createContext</code>接受一个默认值作为参数，这里我们传入了<code class="fe mw mx my mm b">'green'</code>。</p><p id="20a5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后在<code class="fe mw mx my mm b">App</code>组件中，我们将<code class="fe mw mx my mm b">ColorContext.Provider</code>组件的<code class="fe mw mx my mm b">value</code>属性设置为我们想要共享的值。</p><p id="8d70" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的例子中，它将是<code class="fe mw mx my mm b">'blue'</code>。我们将它包装在我们想要共享数据的组件周围，以便我们可以从该组件访问值。</p><p id="7f9c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本例中，我们创建了一个新的<code class="fe mw mx my mm b">Button</code>组件，它包含了<code class="fe mw mx my mm b">ColorContext.Consumer</code>组件。在其中，我们可以从插入到<code class="fe mw mx my mm b">ColorContext.Consumer</code>组件中的函数的<code class="fe mw mx my mm b">value</code>参数中获得上下文提供者共享的值。</p><p id="3b25" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mw mx my mm b">value</code>应该设置为<code class="fe mw mx my mm b">'blue'</code>，因为这是我们设置为<code class="fe mw mx my mm b">value</code>属性的值。</p><p id="7ab2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我们传递给消费者的函数中，我们返回了一个带有style prop的<code class="fe mw mx my mm b">buttom</code>元素，并将<code class="fe mw mx my mm b">color</code>样式设置为<code class="fe mw mx my mm b">value</code>，也就是<code class="fe mw mx my mm b">'blue'</code>。</p><h1 id="57e8" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">语境的替代</h1><p id="655b" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">如果我们想将数据传递到一个深度嵌套的组件中，我们可以将整个组件传递到我们想要的位置。这样，我们就不必担心将道具传递到多个级别来传递一些只有深度嵌套的组件才需要的东西。</p><p id="3986" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们想将颜色属性传递给<code class="fe mw mx my mm b">Button</code>组件，它包含在一个<code class="fe mw mx my mm b">ButtonBar</code>中。我们可以这样做:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="793f" class="mq lf it mm b gy mr ms l mt mu">class Button extends React.Component {<br/>  render() {<br/>    return (<br/>      &lt;button style={{ color: this.props.color }}&gt;{this.props.children}&lt;/button&gt;<br/>    );<br/>  }<br/>}</span><span id="2c0b" class="mq lf it mm b gy mv ms l mt mu">class ButtonBar extends React.Component {<br/>  render() {<br/>    return this.props.buttons;<br/>  }<br/>}</span><span id="d29a" class="mq lf it mm b gy mv ms l mt mu">class App extends React.Component {<br/>  render() {<br/>    const buttons = [<br/>      &lt;Button color="blue"&gt;Click Me&lt;/Button&gt;,<br/>      &lt;Button color="green"&gt;Click Me 2&lt;/Button&gt;<br/>    ];<br/>    return &lt;ButtonBar buttons={buttons} /&gt;;<br/>  }<br/>}</span></pre><p id="a906" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<code class="fe mw mx my mm b">App</code>组件中，我们有<code class="fe mw mx my mm b">buttons</code>数组中的<code class="fe mw mx my mm b">Button</code>组件。然后我们将整个数组直接传递给<code class="fe mw mx my mm b">ButtonBar</code>组件。</p><p id="31af" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后<code class="fe mw mx my mm b">ButtonBar</code>只是返回我们传入的，也就是<code class="fe mw mx my mm b">this.props.buttons</code>。</p><p id="8660" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这也意味着高阶元件更加复杂，因此它可能并不适用于所有情况。</p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/eca12dd182d1776dbb0eb4e3be299df1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*firnfmfJ5Tai0oA2"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@mimithian?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">米米·蒂安</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="1f0e" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">从嵌套组件更新上下文</h1><p id="77ba" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以将函数传递给传入<code class="fe mw mx my mm b">createContext</code>的对象，这样我们就可以在拥有上下文消费者组件的组件内部调用它们。</p><p id="8b8e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以这样写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="4a70" class="mq lf it mm b gy mr ms l mt mu">const colorObj = {<br/>  color: "green",<br/>  toggleColor: () =&gt; {}<br/>};</span><span id="f490" class="mq lf it mm b gy mv ms l mt mu">const ColorContext = React.createContext(colorObj);<br/>class Button extends React.Component {<br/>  render() {<br/>    return (<br/>      &lt;div&gt;<br/>        &lt;ColorContext.Consumer&gt;<br/>          {({ color, toggleColor }) =&gt; (<br/>            &lt;button onClick={toggleColor} style={{ color }}&gt;<br/>              {this.props.children}<br/>            &lt;/button&gt;<br/>          )}<br/>        &lt;/ColorContext.Consumer&gt;<br/>      &lt;/div&gt;<br/>    );<br/>  }<br/>}</span><span id="0a18" class="mq lf it mm b gy mv ms l mt mu">class App extends React.Component {<br/>  constructor(props) {<br/>    super(props);<br/>    this.state = {<br/>      color: "blue",<br/>      toggleColor: () =&gt; {<br/>        this.setState(state =&gt; ({<br/>          color: state.color === "green" ? "blue" : "green"<br/>        }));<br/>      }<br/>    };<br/>  }</span><span id="dc4f" class="mq lf it mm b gy mv ms l mt mu">  render() {<br/>    return (<br/>      &lt;div&gt;<br/>        &lt;ColorContext.Provider value={this.state}&gt;<br/>          &lt;Button&gt;Click Me&lt;/Button&gt;<br/>        &lt;/ColorContext.Provider&gt;<br/>      &lt;/div&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="3002" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">上面的代码从定义<code class="fe mw mx my mm b">colorObj</code>对象开始，该对象作为<code class="fe mw mx my mm b">ColorContext</code>的默认值传递给<code class="fe mw mx my mm b">createContext</code>。</p><p id="fafe" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后在<code class="fe mw mx my mm b">App</code>组件中，我们通过使用<code class="fe mw mx my mm b">toggleColor</code>函数将<code class="fe mw mx my mm b">this.state</code>设置为一个对象，并将<code class="fe mw mx my mm b">color</code>属性设置为<code class="fe mw mx my mm b">'blue'</code>来初始化<code class="fe mw mx my mm b">this.state</code>。</p><p id="7420" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将<code class="fe mw mx my mm b">this.state</code>作为<code class="fe mw mx my mm b">ColorContext.Provider</code>的<code class="fe mw mx my mm b">value</code>道具的值传递。</p><p id="cafd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们在<code class="fe mw mx my mm b">Button</code>组件中访问<code class="fe mw mx my mm b">ColorContext.Consumer</code>组件中的整个对象。</p><p id="3a93" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在那里，我们从从<code class="fe mw mx my mm b">ColorContext.Provider</code>传入的<code class="fe mw mx my mm b">this.state</code>中获得<code class="fe mw mx my mm b">color</code>和<code class="fe mw mx my mm b">toggleColor</code>属性。然后我们将<code class="fe mw mx my mm b">toggleColor</code>传递给<code class="fe mw mx my mm b">onClick</code>道具，将<code class="fe mw mx my mm b">color</code>传递给我们传递给<code class="fe mw mx my mm b">style</code>道具的对象。</p><p id="db07" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，当我们单击“单击我”按钮时，文本颜色将在蓝色和绿色之间切换。</p><h1 id="315c" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">消费多个上下文</h1><p id="394a" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以通过嵌套使用多个上下文。例如，我们可以这样做:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="1a84" class="mq lf it mm b gy mr ms l mt mu">const ColorContext = React.createContext("green");<br/>const BorderContext = React.createContext("");</span><span id="b0cf" class="mq lf it mm b gy mv ms l mt mu">class Button extends React.Component {<br/>  render() {<br/>    return (<br/>      &lt;div&gt;<br/>        &lt;ColorContext.Consumer&gt;<br/>          {color =&gt; (<br/>            &lt;BorderContext.Consumer&gt;<br/>              {border =&gt; (<br/>                &lt;button style={{ color, border }}&gt;{this.props.children}&lt;/button&gt;<br/>              )}<br/>            &lt;/BorderContext.Consumer&gt;<br/>          )}<br/>        &lt;/ColorContext.Consumer&gt;<br/>      &lt;/div&gt;<br/>    );<br/>  }<br/>}</span><span id="a3b7" class="mq lf it mm b gy mv ms l mt mu">class App extends React.Component {<br/>  render() {<br/>    return (<br/>      &lt;div&gt;<br/>        &lt;ColorContext.Provider value="blue"&gt;<br/>          &lt;BorderContext.Provider value="3px solid green"&gt;<br/>            &lt;Button&gt;Click Me&lt;/Button&gt;<br/>          &lt;/BorderContext.Provider&gt;<br/>        &lt;/ColorContext.Provider&gt;<br/>      &lt;/div&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="b62d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们创建了两个上下文，<code class="fe mw mx my mm b">ColorContext</code>和<code class="fe mw mx my mm b">BorderContext</code>，并将值传递给两者的<code class="fe mw mx my mm b">value</code>属性。我们在<code class="fe mw mx my mm b">App</code>组件中嵌套了提供者，这意味着两个上下文都可以被内部的<code class="fe mw mx my mm b">Button</code>组件使用。</p><p id="85f0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后在<code class="fe mw mx my mm b">Button</code>组件中，我们让两个上下文的消费者相互嵌套。然后我们可以获得从提供者传入的两个值。</p><p id="31e8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们使用这两个值来设置<code class="fe mw mx my mm b">button</code>的样式。</p><p id="700b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我们有一个蓝色文本和绿色边框的按钮。</p><h1 id="9a35" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="e98f" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以使用React上下文API在组件之间共享数据。</p><p id="8975" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它通过用<code class="fe mw mx my mm b">React.createContext</code>创建一个上下文对象来工作。然后，我们将上下文提供者组件包装在我们想要从中消费上下文的组件之外。</p><p id="bedb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，在我们放在提供者内部的组件中，我们将上下文消费者组件包装在我们想要应用上下文值的组件之外。</p><p id="9522" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，我们可以获得在上下文消费者内部传递的函数内部的值。</p></div></div>    
</body>
</html>