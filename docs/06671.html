<html>
<head>
<title>How to Handle Click Events Not Bubbling Up to Document</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何处理没有冒泡到文档的点击事件</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/when-your-click-listener-on-document-just-doesnt-get-the-message-e010072a4cc3?source=collection_archive---------7-----------------------#2020-12-18">https://levelup.gitconnected.com/when-your-click-listener-on-document-just-doesnt-get-the-message-e010072a4cc3?source=collection_archive---------7-----------------------#2020-12-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="58ad" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">用Angular &amp; RxJS中的自定义事件流替换文档上的事件侦听器，以实现更好的控制</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e52fe62e8f11dce02fe9be7b8179dc97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GEOm4tJ-DLYm4rPXZooJHw.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">照片由<a class="ae kv" href="https://www.shutterstock.com/g/mattiaath" rel="noopener ugc nofollow" target="_blank"> MattiaATH </a>在<a class="ae kv" href="https://www.shutterstock.com/image-photo/bottlenose-dolphin-tursiops-truncatus-blowing-bubbles-430202206" rel="noopener ugc nofollow" target="_blank"> Shutterstock </a>上拍摄</figcaption></figure><h1 id="1fa2" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">最初快乐的场景</h1><p id="7124" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我最近遇到的一个有趣的场景是一个条目列表，每个条目包含一个下拉列表，如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/b1ecbd6e055a28b971a365d68859a67c.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/1*nttZYdrKMolzRH9YSMYC1Q.gif"/></div></figure><p id="bf03" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">每个列表项都是一个名为<code class="fe mq mr ms mt b">ListItemComponent</code>的组件的实例。</p><p id="c485" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">dropdown是一个<a class="ae kv" href="https://www.primefaces.org/primeng/showcase/#/dropdown" rel="noopener ugc nofollow" target="_blank"> PrimeNG Dropdown </a>，和所有好心的组件开发者一样，PrimeNG确保在下拉菜单外点击会触发它关闭。</p><p id="a90c" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">他们通过<a class="ae kv" href="https://github.com/primefaces/primeng/blob/master/src/app/components/dropdown/dropdown.ts#L1088" rel="noopener ugc nofollow" target="_blank">在<code class="fe mq mr ms mt b">document</code>上附加一个点击事件监听器</a>来实现这一点，当点击菜单外时，监听器会关闭菜单。</p><p id="f943" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">这一切都很好，直到情况发生了微小的变化。</p><h1 id="f65c" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">麻烦制造者的场景</h1><p id="e6e5" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">当列表项被扩展以允许可扩展/可折叠的细节行时，我们的快乐场景变成了一个麻烦制造者，如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/bfe68e318adb8430e8a3637e7e52967a.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/1*iIrMtDulZnImAaV0dYZPAQ.gif"/></div></figure><p id="8b06" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">你会问，为什么是麻烦制造者？很棒的问题！原因如下:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/2176d8173570dcf70e98f5210d67c623.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/1*rEBDc__6Xtq_bbzHzxPDsg.gif"/></div></figure><p id="927d" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">单击下拉气泡直至列表项摘要行，并触发详细信息行的展开/折叠。</p><p id="2c1e" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">用户体验非常差。非常非常非常糟糕。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/82d3a066f6446388063d004ef025e327.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*U0D-plmkp6dfPs4vDMQtDQ.gif"/></div></figure><h1 id="9c75" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">寻找解决办法</h1><p id="474a" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">最显而易见的解决方法是点击下拉菜单中的<code class="fe mq mr ms mt b">stopPropagation</code>,以防止冒泡。</p><p id="aeb7" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">这给了我们:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/dc996ed9feb9b936ab727fffbea365c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/1*-O69tH8Yt8umGg6tT1E0nA.gif"/></div></figure><p id="7675" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">这修复了不必要的细节行的展开/折叠，但是引入了一个新的问题:多个下拉菜单现在可以同时打开了！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/a72800620563343d38db9a8b1893626e.png" data-original-src="https://miro.medium.com/v2/resize:fit:500/1*k8SLtgdHaTKRBnjeMJdynw.gif"/></div></figure><p id="38dc" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">当我们停止下拉菜单上的点击传播时，<code class="fe mq mr ms mt b">document</code>上的点击监听器永远不会收到点击事件，因此不会关闭它们相关的下拉菜单。</p><h1 id="b6e6" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">不同的方法</h1><p id="62a0" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">为了解决这个问题，我们需要建立一个更可靠的事件通知系统，不能被一个无辜插入的<code class="fe mq mr ms mt b">stopPropagation</code>所阻挠。</p><p id="9456" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">因为我们需要在可能不属于同一父子树结构的组件之间进行通信，所以我们需要寻找一个角度服务。</p><h1 id="bd96" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">角服务&amp; RxJS来救援！</h1><p id="0bb2" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我们可以轻松地构建一个服务，作为与该接口相关的所有事件的通信中心。</p><p id="d253" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">下拉菜单上的点击事件可以报告给服务，服务可以通过Observables通知订阅者这些点击事件。</p><p id="e81e" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">该服务的简单版本如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="21a0" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">兴趣点:</p><ul class=""><li id="f1eb" class="my mz iq lq b lr ml lu mm lx na mb nb mf nc mj nd ne nf ng bi translated">该服务公开了一个名为<code class="fe mq mr ms mt b">events$</code>的可观察对象，每当调用该服务的<code class="fe mq mr ms mt b">notify</code>方法时，该可观察对象就会发出一个<code class="fe mq mr ms mt b">EventNotification</code>对象。</li><li id="007a" class="my mz iq lq b lr nh lu ni lx nj mb nk mf nl mj nd ne nf ng bi translated">我们在服务内部使用Subject(<code class="fe mq mr ms mt b">_events$</code>)来发出事件，但我们并不直接公开它，我们保留它<code class="fe mq mr ms mt b">private</code>并公开它的可观察形式，因为一般来说，订阅者不应该访问原始Subject，除非他们也将从它发出事件，但这里的情况不是这样。</li><li id="954a" class="my mz iq lq b lr nh lu ni lx nj mb nk mf nl mj nd ne nf ng bi translated">我们创建了一个名为<code class="fe mq mr ms mt b">EventType</code>的枚举，它目前只有一个成员事件<code class="fe mq mr ms mt b">ListItemDropdownOpened</code>，但是当我们添加其他事件时，它将有助于保持组织有序。</li><li id="62b6" class="my mz iq lq b lr nh lu ni lx nj mb nk mf nl mj nd ne nf ng bi translated">我们创建了一个名为<code class="fe mq mr ms mt b">EventNotification</code>的类型，它有一个用于<code class="fe mq mr ms mt b">EventType</code>的<code class="fe mq mr ms mt b">type</code>属性和一个可选的<code class="fe mq mr ms mt b">details</code>属性。</li><li id="b4c7" class="my mz iq lq b lr nh lu ni lx nj mb nk mf nl mj nd ne nf ng bi translated">可选的<code class="fe mq mr ms mt b">details</code>属性属于<code class="fe mq mr ms mt b">EventDetails</code>类型，它目前有一个可选属性<code class="fe mq mr ms mt b">componentInstance</code>，该属性将指示事件中涉及了哪个<code class="fe mq mr ms mt b">ListItemComponent</code>实例。订阅者将需要这些信息，以便他们知道他们是否收到了关于他们自己或关于不同的<code class="fe mq mr ms mt b">ListItemComponent</code>实例的通知。</li></ul><h1 id="7866" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">订阅事件</h1><p id="b5cd" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">下面是我们的<code class="fe mq mr ms mt b">ListItemComponent</code>如何订阅我们新服务的<code class="fe mq mr ms mt b">events$</code>可观察内容并做出相应反应:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="c314" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">兴趣点:</p><ul class=""><li id="09a0" class="my mz iq lq b lr ml lu mm lx na mb nb mf nc mj nd ne nf ng bi translated">我们创建了一个名为<code class="fe mq mr ms mt b">otherDropdownOpened$</code>的可观察对象，它过滤服务的事件流中与<code class="fe mq mr ms mt b">ListItemComponent</code> <em class="nm">实例相关联的<code class="fe mq mr ms mt b">ListItemDropdownOpened</code>类型的事件，而不是</em>这个实例。</li><li id="1af6" class="my mz iq lq b lr nh lu ni lx nj mb nk mf nl mj nd ne nf ng bi translated">在接收到一个被过滤的事件时，我们通过调用<code class="fe mq mr ms mt b">this.dropdown.hide()</code>来关闭下拉菜单。(这恰好是PrimeNG的API，用于以编程方式关闭下拉菜单，当然，其他API可能会有所不同。)</li></ul><h1 id="d8cc" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">触发事件</h1><p id="00ec" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在前面的<code class="fe mq mr ms mt b">ListItemComponent</code>代码示例中，您可能注意到我在剧透中泄露了文章的这一部分:一个名为<code class="fe mq mr ms mt b">onShowDropdown</code>的方法调用了<code class="fe mq mr ms mt b">EventNotificationService</code>的<code class="fe mq mr ms mt b">notify</code>方法。</p><p id="4e0a" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">这是:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="42b4" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated"><code class="fe mq mr ms mt b">notify</code>方法接受一个<code class="fe mq mr ms mt b">EventNotification</code>对象。在那个对象上，我们将<code class="fe mq mr ms mt b">type</code>设置为<code class="fe mq mr ms mt b">ListItemDropdownOpened</code>(使用<code class="fe mq mr ms mt b">EventType</code>枚举)，在<code class="fe mq mr ms mt b">details</code>中，我们将<code class="fe mq mr ms mt b">componentInstance</code>设置为<code class="fe mq mr ms mt b">this</code>，这是对<code class="fe mq mr ms mt b">ListItemComponent</code>实例的引用。</p><p id="24e9" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">当组件的下拉菜单打开时，调用<code class="fe mq mr ms mt b">onShowDropdown</code>方法。在我们的场景中，它是一个原始的下拉列表，所以我们的组件的模板看起来像这样，挂钩到下拉列表的<code class="fe mq mr ms mt b">onShow</code>事件:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="a0f6" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">但是基本的想法是，你的组件将有某种方式知道它的下拉列表何时被打开，这样它就可以通知服务。</p><h1 id="cc4a" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">扩展服务</h1><p id="a7f6" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">当您用更多的事件类型扩展服务时，您可以通过创建有用的预定义事件包来增强它，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="b7be" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">如果某些组件(如下拉菜单)需要对任何类型的组件打开本身做出反应，那么<code class="fe mq mr ms mt b">allComponentOpenedEvents$</code>可观察性将对它们有用。</p><p id="87f6" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">然后，如果有一天您添加了一个同样“打开”的新组件，您可以简单地将它的<code class="fe mq mr ms mt b">EventType</code>添加到过滤器中，而不必查找和更新每个侦听组件“打开”事件的订阅者。</p><h1 id="50e3" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">结论</h1><p id="fed0" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">下面是一个带有工作代码的StackBlitz:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nn mx l"/></div></figure><p id="778f" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">我希望这能提供一些有用的信息和想法。</p><p id="e8d8" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">勇往直前吧！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/3cecc598af56cad709600017b023811e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wjuX1s7HVV8vlGIwKm719Q.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">罗伯特·博德纳尔T 在<a class="ae kv" href="https://www.shutterstock.com/image-photo/dog-stream-woods-704947561" rel="noopener ugc nofollow" target="_blank"> Shutterstock </a>上拍摄的照片</figcaption></figure></div></div>    
</body>
</html>