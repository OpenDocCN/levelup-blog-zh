<html>
<head>
<title>ASP.NET Core default project structure explained (part 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ASP.NET核心默认项目结构解释(第二部分)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/asp-net-core-default-project-structure-explained-part-2-e68360b2a227?source=collection_archive---------6-----------------------#2021-04-14">https://levelup.gitconnected.com/asp-net-core-default-project-structure-explained-part-2-e68360b2a227?source=collection_archive---------6-----------------------#2021-04-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/939193675dfcf94a1df30dece22bb998.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*8OIKIO91M7K49nET.jpg"/></div></div></figure><h1 id="9c2d" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">启动类</h1><p id="1dc4" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">正如我们在第一篇文章中提到的，启动类是应用程序中所有初始化代码的入口点。长话短说，初创公司定义了你的应用程序将做什么，以及它将如何工作。</p><p id="f6ad" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">默认情况下，ASP.NET核心应用程序中的任何启动类都包括三个主要部分:</p><ul class=""><li id="b509" class="ma mb iq ky b kz lv ld lw lh mc ll md lp me lt mf mg mh mi bi translated"><strong class="ky ir">构造函数</strong>，在这里你可以定义一些内部变量，设置一些配置设置，或者执行应用程序范围的初始化。例如，我们建议用户在这里为我们的EasyQuery库设置他们的许可证密钥。</li><li id="4038" class="ma mb iq ky b kz mj ld mk lh ml ll mm lp mn lt mf mg mh mi bi translated"><strong class="ky ir">配置服务</strong>方法。这里，我们在DI(依赖注入)容器中注册所有必要的服务，并为其中一些服务定义配置设置。如果你不知道什么是依赖注入，这里有一篇我们博客上的文章，用简单的语言解释了这个概念。</li><li id="e65f" class="ma mb iq ky b kz mj ld mk lh ml ll mm lp mn lt mf mg mh mi bi translated"><strong class="ky ir">配置</strong>方法。这是为项目设置中间件管道的阶段。</li></ul><p id="28a6" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">当应用程序启动时，<code class="fe mo mp mq mr b">ConfigureServices</code>和<code class="fe mo mp mq mr b">Configure</code>方法都被自动调用。你只需要相应地定义服务和中间件。</p><p id="92cc" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">现在，让我们更详细地看一下每一部分。</p><h1 id="24e1" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">启动类构造函数</h1><p id="61d2" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">默认的ASP.NET核心项目模板在构造函数中仅包含以下一行代码:</p><pre class="ms mt mu mv gt mw mr mx my aw mz bi"><span id="57d3" class="na jz iq mr b gy nb nc l nd ne">public Startup(IConfiguration configuration) <br/>{ <br/>    Configuration = configuration; <br/>}</span></pre><p id="82df" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">它只是将DI容器传递到这里的配置对象<a class="ae lu" href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/configuration/?view=aspnetcore-3.1" rel="noopener ugc nofollow" target="_blank">保存在class属性中，所以我们可以在其他方法中使用它。在</a><a class="ae lu" rel="noopener ugc nofollow" target="_blank" href="/asp-net-core-default-project-structure-explained-part-1-cfaffba94762">第一篇文章</a>中，我们已经考虑了ASP.NET核心应用中使用的配置机制。</p><h1 id="fd03" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">ConfigureServices方法</h1><p id="58d8" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">如前所述，<code class="fe mo mp mq mr b">ConfigureServices</code>方法包含在DI容器中注册不同应用服务的函数调用。这些可以是认证/授权服务、MVC或Razor Pages引擎、用于使用DB的类或任何其他可能的服务。</p><p id="1650" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated"><code class="fe mo mp mq mr b">ConfigureServices</code>方法的唯一参数具有代表一列<code class="fe mo mp mq mr b">ServiceDescriptor</code>项的<code class="fe mo mp mq mr b">IServiceCollection</code>类型。这些项目中的每一个都将某种类型(通常是一个接口)映射到这种类型的特定实现。</p><p id="1b31" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">根据界面，我们只能使用常用的<code class="fe mo mp mq mr b">IList</code>或<code class="fe mo mp mq mr b">ICollection</code>功能，如<code class="fe mo mp mq mr b">Add</code>、<code class="fe mo mp mq mr b">AddRange</code>、<code class="fe mo mp mq mr b">Remove</code>等方法。然而，正如您已经注意到的，<code class="fe mo mp mq mr b">ConfigureServices</code>包含了诸如<code class="fe mo mp mq mr b">services.AddDbContext</code>、<code class="fe mo mp mq mr b">services.AddRazorPages</code>以及类似的调用。你可能会问，“怎么可能？”答案是<strong class="ky ir">扩展方法</strong>。我们项目中使用的每个子系统(如实体框架核心或MVC引擎)都为<code class="fe mo mp mq mr b">IServiceCollection</code>接口定义了一个扩展方法(有时甚至是几个),以简化DI中的注册和子系统中可用服务的配置。</p><p id="269c" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated"><strong class="ky ir"> NB </strong>:请注意，您在<code class="fe mo mp mq mr b">ConfigureServices</code>方法中注册的服务的顺序并不重要。这个方法只在应用程序启动时执行一次。</p><p id="0c93" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">因此，让我们仔细看看默认的ConfigureServices的内容。</p><pre class="ms mt mu mv gt mw mr mx my aw mz bi"><span id="ef90" class="na jz iq mr b gy nb nc l nd ne">public void ConfigureServices(IServiceCollection services) <br/>{ <br/>    services.AddDbContext&lt;ApplicationDbContext&gt;(options =&gt;     options.UseSqlServer( Configuration.GetConnectionString("DefaultConnection"))); </span><span id="ad2b" class="na jz iq mr b gy nf nc l nd ne">    services.AddDefaultIdentity&lt;IdentityUser&gt;(options =&gt; options.SignIn.RequireConfirmedAccount = true)<br/>        .AddEntityFrameworkStores&lt;ApplicationDbContext&gt;(); <br/>    services.AddRazorPages(); <br/>}</span></pre><p id="76b4" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">所以，那里只有三个调用:<code class="fe mo mp mq mr b">AddDbContext</code>、<code class="fe mo mp mq mr b">AddDefaultIdentity</code>和<code class="fe mo mp mq mr b">AddRazorPages</code>。让我们分别检查它们。</p><h2 id="eaba" class="na jz iq bd ka ng nh dn ke ni nj dp ki lh nk nl km ll nm nn kq lp no np ku nq bi translated">AddDbContext</h2><p id="9331" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">该方法由<a class="ae lu" href="https://docs.microsoft.com/en-us/ef/core/" rel="noopener ugc nofollow" target="_blank">实体框架核心</a>框架提供。它注册并配置我们的数据库上下文。参数中传递的<code class="fe mo mp mq mr b">Action</code>委托允许我们定义这个DbContext的参数。例如，通过<code class="fe mo mp mq mr b">UseSqlServer</code>调用，我们告诉DbContext使用带有特定连接字符串的特定类型的连接(<code class="fe mo mp mq mr b">SqlConnection</code>)。连接字符串本身取自配置，因此可以在开发或生产环境中轻松更改。您可以在<code class="fe mo mp mq mr b">appsettings.json</code>配置文件中找到默认的连接字符串，我们已经在<a class="ae lu" rel="noopener ugc nofollow" target="_blank" href="/asp-net-core-default-project-structure-explained-part-1-cfaffba94762">第一篇文章</a>中分析过了。</p><p id="4e42" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">关于“构建器”模式的一些话。</p><p id="ae52" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">您可能已经注意到传递DbContext设置的一种有趣方式。我们不发送带有选项的对象，而是使用带有DbContextOptionsBuilder类型的单参数选项的过程(Action)。</p><p id="0848" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">这是因为，为了正确地构造DbContext设置，实体框架核心使用了<strong class="ky ir">构建器模式</strong>。当您需要执行几个步骤来构造一些复杂的对象，而仅仅定义一个类或结构是不够的时候，这种模式非常有用。例如，当您需要根据配置中的设置调用一些方法时。就像我们遇到的<code class="fe mo mp mq mr b">UseSqlServer()</code>一样。</p><p id="b68f" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">我们使用委托(函数)而不是普通对象还有一个原因。可能有一种情况，你根本不需要那个服务(DbContext)。例如，您的web应用程序有一些不需要数据库访问的操作。永远不会为这样的请求创建DbContext对象，因此，我们不需要设置它的选项。委托的好处在于，当您需要构造必要的对象时，可以准确地调用它。</p><p id="370c" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">我非常关注这个模式，因为它经常被使用，尤其是在DI中注册服务的过程中(我们也将在下一个函数调用中使用它)。</p><h2 id="6ce3" class="na jz iq bd ka ng nh dn ke ni nj dp ki lh nk nl km ll nm nn kq lp no np ku nq bi translated">AddDefaultIdentity</h2><p id="1201" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">这里添加了<code class="fe mo mp mq mr b">ConfigureServices</code>中的第二个函数调用，因为我们在创建项目时打开了认证选项。它注册了一堆用于认证和授权任务的服务，比如<code class="fe mo mp mq mr b">IUserStore</code>、<code class="fe mo mp mq mr b">IRoleStore</code>、<code class="fe mo mp mq mr b">IPasswordHasher</code>、<code class="fe mo mp mq mr b">UserManager</code>、<code class="fe mo mp mq mr b">SignInManager</code>等等。它们都是ASP.NET核心身份子系统的一部分。</p><p id="e9cf" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">这个方法也使用构建器模式，但是方式略有不同。该函数返回IdentityBuilder对象，而不是在委托的参数中传递builder，因此您可以通过简单的链接调用其他函数。</p><p id="b581" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">那里唯一调用的函数是<code class="fe mo mp mq mr b">AddEntityFrameworkStores</code>。它告诉ASP.NET身份在哪里存储授权任务所需的所有实体(用户、角色、声明等)。).顾名思义，我们将使用我们的实体框架服务来完成这些任务。该方法中的参数类型(在<code class="fe mo mp mq mr b">&lt; .. &gt;</code>之间)定义了用于存储所有auth对象的<code class="fe mo mp mq mr b">DbContext</code>类。</p><h1 id="d044" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">添加RazorPages</h1><p id="d18b" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated"><code class="fe mo mp mq mr b">ConfigureServices</code>中的最后一个函数调用添加了Razor Pages引擎所需的服务。它出现在这里是因为我们一开始选择的模板。如果我们当时选择了一个模型-视图-控制器方法的模板，我们在这里就会有类似于<code class="fe mo mp mq mr b">services.AddMvc()</code>的东西。</p><h1 id="234c" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">配置方法</h1><p id="d16a" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">Startup类中的最后一个方法定义了ASP.NET核心程序的中间件管道。<br/>如果您不知道什么是中间件管道，您可能想了解更多，因为它决定了您的web应用程序如何处理HTTP请求。</p><figure class="ms mt mu mv gt jr gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/928a28b7a0e51fa0b2fe3f4370311042.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/0*GrjdpNlVVsQ_4utH.png"/></div></figure><p id="ac8b" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">与在<code class="fe mo mp mq mr b">ConfigureServices</code>中注册的服务不同(记住，它们的顺序并不重要)，在<code class="fe mo mp mq mr b">Configure</code>中定义的中间件的顺序具有至关重要的意义。从上图可以看出，每个请求都会调用第一个定义的中间件，而管道中的下一个中间件只处理那些没有被之前定义的中间件处理的请求。</p><p id="8f27" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">因此，在管道的开始，我们需要放置辅助任务(如日志或身份验证)所必需的中间件，这些中间件不会消耗大量内存和处理时间。</p><p id="3be5" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">让我们来看看这个方法对于所选项目模板的默认实现:</p><pre class="ms mt mu mv gt mw mr mx my aw mz bi"><span id="b4ea" class="na jz iq mr b gy nb nc l nd ne">public void Configure(IApplicationBuilder app, IWebHostEnvironment env)<br/>{<br/>    if (env.IsDevelopment()) {<br/>        app.UseDeveloperExceptionPage();<br/>        app.UseDatabaseErrorPage();<br/>    }<br/>    else {<br/>        app.UseExceptionHandler("/Error");<br/>        app.UseHsts();<br/>    }</span><span id="bb70" class="na jz iq mr b gy nf nc l nd ne">    app.UseHttpsRedirection();<br/>    app.UseStaticFiles();</span><span id="e560" class="na jz iq mr b gy nf nc l nd ne">    app.UseRouting();</span><span id="5c79" class="na jz iq mr b gy nf nc l nd ne">    app.UseAuthentication();<br/>    app.UseAuthorization();</span><span id="2189" class="na jz iq mr b gy nf nc l nd ne">    app.UseEndpoints(endpoints =&gt; {<br/>        endpoints.MapRazorPages();<br/>    });<br/>}</span></pre><p id="b036" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">所以，让我们一个一个的过一遍这里定义的中间件。</p><h2 id="5f52" class="na jz iq bd ka ng nh dn ke ni nj dp ki lh nk nl km ll nm nn kq lp no np ku nq bi translated">异常处理和安全传输</h2><p id="6e5c" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">第一行为开发和生产模式定义了不同的中间件。如果我们处于开发模式，我们定义中间件来捕捉管道中的所有异常，并显示一个特殊页面，其中包含关于错误的额外信息(异常消息、堆栈跟踪等)。).</p><p id="be97" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">这样做是可能的，因为(正如您从上图中看到的)请求的处理在被发送回客户端之前被返回到管道中的第一个中间件。</p><p id="5701" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">在生产模式中，我们还捕获所有异常，然后用指定的路径(在我们的例子中是/Error)重新执行请求。</p><p id="8c53" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">仅在生产中执行的第二个调用是<code class="fe mo mp mq mr b">UseHsts</code>。它增加了一个实现HTTP严格传输安全协议的中间件。</p><p id="c941" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">下一个正在酝酿中的是HTTPS重定向中间件(<code class="fe mo mp mq mr b">app.UseHttpsRedirection</code>)。这个名字不言自明。它只是将所有HTTP请求重定向到HTTPS请求。添加这两个中间件(<code class="fe mo mp mq mr b">app.UseHsts</code>和<code class="fe mo mp mq mr b">app.UseHttpsRedirection</code>调用)是因为我们在项目创建期间打开了<strong class="ky ir">为HTTPS配置</strong>选项(实际上，它是默认打开的)。</p><h2 id="146c" class="na jz iq bd ka ng nh dn ke ni nj dp ki lh nk nl km ll nm nn kq lp no np ku nq bi translated">处理静态文件(使用静态文件)</h2><p id="70b2" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">下一个中间件(由<code class="fe mo mp mq mr b">app.UseStaticFiles()</code>调用添加)负责所有静态文件。简而言之，如果应用程序收到一些。js，。css或图像文件(。png，。jpg等。)，这个中间件在<code class="fe mo mp mq mr b">wwwroot</code>文件夹中查找具有所请求名称的文件，并返回它作为响应(如果找到了该文件)。如果没有，它会发回一个带有404状态代码(“未找到”)的响应。</p><p id="8901" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">有<code class="fe mo mp mq mr b">UseStaticFiles</code>函数的重载，允许我们为静态文件定义另一个根文件夹，并设置一些其他选项。</p><h2 id="ba6a" class="na jz iq bd ka ng nh dn ke ni nj dp ki lh nk nl km ll nm nn kq lp no np ku nq bi translated">路由(用户路由和用户端点)</h2><p id="4a8e" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">下一对中间件可能是管道中最重要的，因为它们定义了web应用程序中所有其他端点的路由。</p><p id="2377" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">简而言之，它们将特定的请求匹配到特定的端点，即处理请求的一段可执行代码。</p><p id="26fe" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">那么，它到底是如何工作的呢？</p><p id="c759" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">在<code class="fe mo mp mq mr b">Configure</code>方法中，我们调用<code class="fe mo mp mq mr b">app.UseRouting()</code>将<code class="fe mo mp mq mr b">EndpointRoutingMiddleware</code>添加到我们的管道中。</p><p id="3d32" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">之后，我们调用<code class="fe mo mp mq mr b">app.UseEndpoints()</code>将<code class="fe mo mp mq mr b">EndpointMiddleware</code>添加到管道中并定义端点。每个端点都是一个对象，包含(如上所述)一个实际处理请求的委托(也就是一段代码)，以及一些元数据(比如授权策略)。</p><p id="eda6" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">我们可以使用诸如<code class="fe mo mp mq mr b">MapGet</code>、<code class="fe mo mp mq mr b">MapPost</code>等扩展方法来添加与特定请求路径或路径模板匹配的端点。例如，以下模式<code class="fe mo mp mq mr b">/something/{path*}</code>，将与所有以<code class="fe mo mp mq mr b">/something/</code>开始的请求相匹配。</p><p id="ea16" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">此外，其他服务可以定义自己的扩展功能，用于创建必要的端点。例如，您可以将<code class="fe mo mp mq mr b">MapRazorPages</code>功能用于Razor页面，或将<code class="fe mo mp mq mr b">MapHub</code>功能用于SingleR页面。在我们的<a class="ae lu" href="https://github.com/KorzhCom/EasyData" rel="noopener ugc nofollow" target="_blank"> EasyData库</a>中，我们定义了<code class="fe mo mp mq mr b">MapEasyData</code>函数，它为处理所有CRUD操作的API添加了一个端点。</p><p id="2502" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">当我们的web应用程序收到一个新的请求时(它没有被任何在<code class="fe mo mp mq mr b">UseRouting</code>之前定义的中间件处理过)，<code class="fe mo mp mq mr b">EndpointRoutingMiddleware</code>将它匹配到某个端点。因此，在应用程序启动时定义的所有端点中，有一个端点在那一刻被选中。</p><p id="16ac" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">然后<code class="fe mo mp mq mr b">EndpointMiddleware</code>实际调用端点的委托来处理请求。在<code class="fe mo mp mq mr b">app.UseRouting()</code>之后但在<code class="fe mo mp mq mr b">app.UseEnpoints()</code>之前添加的其他中间件可以“看到”哪个端点被选择，并且可以在<code class="fe mo mp mq mr b">EndpointMiddleware</code>分派到所选择的端点之前改变某些东西(例如，应用授权策略)。</p><h2 id="4b77" class="na jz iq bd ka ng nh dn ke ni nj dp ki lh nk nl km ll nm nn kq lp no np ku nq bi translated">认证/授权(使用认证，使用授权)</h2><p id="6744" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">这两个中间件被添加到<code class="fe mo mp mq mr b">Configure</code>中，因为我们在创建项目时打开了身份验证选项。如上所述，他们已经知道选择了哪个端点，因此可以向请求的上下文添加一些额外的与身份相关的信息(如填充其<code class="fe mo mp mq mr b">User</code>属性),或者如果没有附加身份验证信息，但所选端点需要授权，则将请求重定向到“登录/注册”页面。</p><h1 id="9f45" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">包扎</h1><p id="4286" class="pw-post-body-paragraph kw kx iq ky b kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">因此，在本文中，我试图涵盖最常用的ASP.NET核心应用程序模板的所有部分，并弄清楚为什么使用它们以及它们是如何工作的(从一个非常一般的角度)。</p><p id="a717" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">我希望这些信息能够帮助您更好地理解ASP.NET核心框架的内部机制，并使您的代码更加清晰高效。</p><p id="2fcb" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated">感谢你的阅读，保重！</p></div><div class="ab cl ns nt hu nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ij ik il im in"><p id="2865" class="pw-post-body-paragraph kw kx iq ky b kz lv lb lc ld lw lf lg lh lx lj lk ll ly ln lo lp lz lr ls lt ij bi translated"><em class="nz">最初发表于</em><a class="ae lu" href="https://korzh.com/blog/asp-net-core-project-structure-explained-part2" rel="noopener ugc nofollow" target="_blank">T5【https://korzh.com】</a><em class="nz">。</em></p></div></div>    
</body>
</html>