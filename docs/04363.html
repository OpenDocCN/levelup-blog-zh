<html>
<head>
<title>Little endian vs Big endian</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">小端对大端</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/little-endian-vs-big-endian-eb2a2c3a9135?source=collection_archive---------4-----------------------#2020-06-23">https://levelup.gitconnected.com/little-endian-vs-big-endian-eb2a2c3a9135?source=collection_archive---------4-----------------------#2020-06-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="5f74" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">关于编程中的字节序要知道的事情</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/830ff3f82505f2938de72b3fa8b535a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8UmiFjVjrNBylf0Q"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">马库斯·斯皮斯克在<a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="ffd9" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">字节序</h1><p id="5646" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">术语端序和端序指的是当处理器将字数据从其寄存器存储到存储器或者相反，将字数据从存储器加载到其寄存器时，决定字节顺序的约定。字数据只不过是与特定处理器架构相关联的常规数据单元(一堆位)。这种关联有点模糊，因为一些处理器为设计的不同方面(指令集大小、处理器和存储器之间的总线大小、寄存器宽度等)使用不同的数据单元，但它通常与处理器的通用寄存器的宽度有关。今天你看到的最常见的字长是8、16、32和64位，但其他字长也是可能的。在这篇文章的其余部分，我将假设世界大小为32位(4字节)。</p><h1 id="b656" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">大端和小端</h1><p id="75ad" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">当在寄存器和存储器之间传输字数据时，字符顺序惯例包括两种不同的方式来决定字节的顺序。</p><p id="f914" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第一种叫做大端序，第二种叫做小端序。Intel x86处理器是小端的，所以大多数个人电脑都是小端的。</p><p id="4a01" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们用一个例子来看看区别。下面的两个图描述了存储字数据“0A 0B 0C 0D”(一组使用从左到右的位置十六进制表示法写出的4个字节)时，字节在大端和小端的顺序。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/099b6e04b0275be891935cdc3098edfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1262/format:webp/1*lYhlPj4s2H2JoFpvKdjxbw.png"/></div></figure><p id="4467" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">需要注意的重要一点是，字节是计算系统中最小的可寻址信息单位。主存储器可以被认为是一个线性的字节串，每个字节都有一个唯一的地址。这意味着它不能单独寻址每个位，也不能在每个地址改变字节数据中位的顺序。因此，字节序只涉及多字节数据(例如，一个字数据，uint32_t)来决定每个字节的顺序(而不是单独的位级)。</p><p id="6be6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如上图所示，big-endian将最重要的字节存储在最小的地址中。</p><p id="0c9a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们来看看小尾序。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/469984aba941d8482fad6fff31ec0455.png" data-original-src="https://miro.medium.com/v2/resize:fit:1386/format:webp/1*DHeD_BKY61AW8jqBX5vVmA.png"/></div></figure><p id="68de" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如您所见，与大端相反，小端将最低有效字节存储在最小的地址中。</p><p id="2b95" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另一方面，当处理器将数据从内存加载到寄存器时(反过来)，在大端和小端两种情况下，字节都被移回存储位置(因此，每个箭头的方向只改变为相反的方向)。因此，寄存器中的值在存储到内存之前和之后表示相同的值，只要它是在使用相同端序的机器上存储和读取的。这就是为什么只要您的程序范围在一台机器内结束，您就不需要担心字节顺序。</p><p id="4503" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们来看一个真实的程序例子。</p><h1 id="1241" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">c程序示例</h1><p id="ccc0" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">下面是一个示例程序，它在运行时检查运行它的处理器的字节序。可以看到，首先，它将值1赋给字长类型为(uint32_t，4字节)的<em class="mk">数据</em>变量。然后，它将<em class="mk">数据</em>的地址转换为指向<em class="mk"> uint8_t (cptr)的指针。</em>这样做是为了以后访问该值的最小地址的字节。</p><p id="1a84" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">由于值1在十六进制记数法中表示为“00 00 00 01”，如果它是big-endian，它将在内存中存储为“00 00 00 01”。如果它是小端的，它将被存储为“01 00 00 00”。程序通过解引用<em class="mk"> cptr </em>指针来检查第一个字节。如果等于0，表示处理器是大端的("<strong class="js iu"> 00 </strong> 00 00 01 ")，如果等于1，表示处理器是小端的("<strong class="js iu"> 01 </strong> 00 00 00 ")。</p><pre class="kp kq kr ks gt ml mm mn mo aw mp bi"><span id="0ee4" class="mq lg it mm b gy mr ms l mt mu">#include &lt;stdio.h&gt;<br/>#include &lt;inttypes.h&gt;</span><span id="3421" class="mq lg it mm b gy mv ms l mt mu">int main(<strong class="mm iu">void</strong>) {</span><span id="2572" class="mq lg it mm b gy mv ms l mt mu">uint32_t data;<br/>uint8_t *cptr;</span><span id="7f51" class="mq lg it mm b gy mv ms l mt mu">data = 1; //Assign data</span><span id="c4b7" class="mq lg it mm b gy mv ms l mt mu">cptr = (uint8_t *)&amp;data; //Type cast</span><span id="2bb8" class="mq lg it mm b gy mv ms l mt mu"><strong class="mm iu">if</strong> (*cptr == 1) {</span><span id="2691" class="mq lg it mm b gy mv ms l mt mu">  printf("little-endiann");</span><span id="1b36" class="mq lg it mm b gy mv ms l mt mu">} <strong class="mm iu">else</strong> <strong class="mm iu">if</strong> (*cptr == 0) {</span><span id="5b05" class="mq lg it mm b gy mv ms l mt mu">  printf("big-endiann");</span><span id="8b7c" class="mq lg it mm b gy mv ms l mt mu">}</span><span id="fd4d" class="mq lg it mm b gy mv ms l mt mu"><strong class="mm iu">return</strong> 0;<br/>}</span></pre><h1 id="9b85" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">当字节序很重要时</h1><p id="db55" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">在编写代码时，通常不需要担心字符顺序。然而，你需要记住这一点，因为如果你不知道的话，这将是一个棘手的问题。</p><p id="522b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">基本上，当你在系统的边界时，字节序很重要。如果您的程序处理在使用不同字节序的不同处理器的系统之间传输原始数据，这就很重要了。特别是，当</p><ul class=""><li id="2c1c" class="mw mx it js b jt ju jx jy kb my kf mz kj na kn nb nc nd ne bi translated">将数据字节写入一个处理器中的文件，然后将它发送到使用不同端序处理器的系统。</li><li id="ce16" class="mw mx it js b jt nf jx ng kb nh kf ni kj nj kn nb nc nd ne bi translated">通过网络将数据字节作为串行数据流从一个端序处理器系统发送到另一个端序处理器系统。</li></ul><p id="a5e1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">实际上，在网络通信的情况下，传输控制协议和互联网协议(TCP/IP)套件中的所有协议层都被定义为big-endian。这就是为什么big-endian有时被称为网络字节顺序。</p><h1 id="8b40" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">公用事业</h1><p id="cd03" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">如果你需要检测和转换字节的顺序，比如当你使用带有小字节序处理器的机器时，你必须通过网络用大字节序发送数据，幸运的是，除了编写一个如上所述的简单程序之外，我们还可以使用一些实用程序。第一种叫做<a class="ae le" href="https://linux.die.net/man/3/ntohl" rel="noopener ugc nofollow" target="_blank"> htonl，htons，ntohl，ntohs。</a>它可以用来转换数据的字节顺序。同样，如果你有一个带有C++20特性的编译器，你可以使用<code class="fe nk nl nm mm b"><a class="ae le" href="https://en.cppreference.com/w/cpp/types/endian" rel="noopener ugc nofollow" target="_blank">std::endian</a></code></p><pre class="kp kq kr ks gt ml mm mn mo aw mp bi"><span id="1ef9" class="mq lg it mm b gy mr ms l mt mu">#include &lt;bit&gt;<br/><br/>if constexpr (std::endian::native == std::endian::big)<br/>{<br/>    // Big endian system<br/>}<br/>else if constexpr (std::endian::native == std::endian::little)<br/>{<br/>    // Little endian system<br/>}<br/>else<br/>{<br/>    // Something else<br/>}</span></pre><h1 id="a2ea" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">结论</h1><p id="38c5" class="pw-post-body-paragraph jq jr it js b jt md jv jw jx me jz ka kb mf kd ke kf mg kh ki kj mh kl km kn im bi translated">正如我提到的，您不太可能需要担心字节序，除非您通过文件或网络在具有不同字节序的不同机器之间传输原始流数据，但是了解这一点很重要，这样您就不会在将来遇到意外。如果我们需要处理字节序，有一些方法可以在运行时检测和处理字节序的差异，使用一个简单的程序逻辑或提供的实用程序，如<a class="ae le" href="https://linux.die.net/man/3/ntohl" rel="noopener ugc nofollow" target="_blank"> htonl、htons、ntohl、ntohs </a>或std::endian。</p></div></div>    
</body>
</html>