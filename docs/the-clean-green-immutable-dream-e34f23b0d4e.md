# 干净、绿色、永恒的梦

> 原文：<https://levelup.gitconnected.com/the-clean-green-immutable-dream-e34f23b0d4e>

我们消费了大量的数字信息，但是以什么为环境代价呢？有没有更高效的方式分享人类的数据？

![](img/e33aafbfe1f24cea606fdce8c87189f0.png)

照片由 [Giammarco](https://unsplash.com/@giamboscaro?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 在 [Unsplash](https://unsplash.com/s/photos/library-old-history?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上拍摄

# 重复，重复，重复

我们到了吗？

*没有。我们刚刚离开。*

我们到了吗？

*没有！我说要一个小时左右，现在已经过了 5 分钟了。*

我们到了吗？

*不！到了那里我会告诉你的。*

我们到了吗？

*给我力量……*

任何有孩子的人都会理解这一点。他们很少或根本不了解时间或距离。你不能解释一件事要花多长时间或者什么时候能做好。他们只是缺乏知识和经验的工具来自己解决问题。然而，儿童在这里并不孤单，这是一个贯穿我们一生的主题，复杂性无时无刻不在起作用。

到那里需要多长时间？

*大约 3 个小时。*

我们还剩多少时间？

*交通不好，所以还是 2 个小时。*

有多远？

大约 70 英里。

已经超过两个小时了，为什么我们还没到？

我们迷路了，但我们知道现在该去哪里。

我们到了吗？

没错！

啊，是的，好多了！我们现在对问题空间有了一些理解！基于对我们可能行驶的速度、剩余的距离以及交通和位置的变化莫测的理解，有一种知识的交流。尽管如此，仍然有许多问题需要回答。

到那里需要多长时间？

*大约 3 个小时。*

我们到了吗？

问你的兄弟。

我们还剩多少时间？

*交通不好，所以还是 2 个小时。*

我们到了吗？

我刚刚告诉你哥哥了！

有多远？

大约 70 英里。

我们到了吗？

*不，我们在大约 70 英里以外！*

已经超过两个小时了，为什么我们还没到？

我们迷路了，但我们知道现在该去哪里。

我们到了吗？

这里有回音吗？不要！

我们到了吗？

没错！

我们到了吗？

是的，我的小宝贝——抱抱我！

重复，重复，重复。他们说那是你学习的方式，但是我的天啊，那是非常痛苦的！一遍又一遍地对不同的人说同样的话，让人精疲力尽。它浪费时间和精力。咬断自己的胳膊有时似乎更有吸引力(尽管我们确实喜欢厚脸皮的猴子！).

![](img/ac466ca803cba903b174a37582201bac.png)

德米特里·维乔科在 [Unsplash](https://unsplash.com/s/photos/scream?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上拍摄的照片

这些与清洁或绿色能源有什么关系呢？我同意，到目前为止看起来很脆弱。这不是关于自动驾驶汽车，虽然这将是一些怜悯！也不是关于 Alexa 回答下属的问题。不，这是关于如何处理对相同数据的重复请求。我打赌你没想到会这样！

# **要有缓存！**

对于被反复询问的相同问题，一个常见的解决方案是获得某物(或某人！)为你复述一遍。它节省了你想出一个答案并说出来的精力。也许我真的需要把 Alexa 弄进我的车里…

缓存很棒。他们通常会返回一个复杂问题的结论，而不必一遍又一遍地思考所说的复杂性。然而，它们有其局限性，通常取决于问题何时提出，答案多久会改变一次。

问我们是否在那里，每次都会有不同的答案。甚至问我们离地球有多远或者剩余的距离是多少都会随着时间而改变。这需要完成一个计算，以便返回一个有效的答案。过一会儿再问同样的问题时，答案通常会保持不变，这就是缓存的高明之处。缓存喜欢重复。缓存喜欢重复。缓存喜欢重复。好吧，我不说了。

# **让有不可变的数据！**

如果我们知道答案是不变的，那么缓存是很好的，这就引出了一个问题——如果我们能保证答案是不变的，我们能永远缓存它吗？是的，我们可以！假设我们知道所有的输入，并且使用相同的算法，我们就知道输出是什么。它是可预测和可重用的。

我们知道，在某一天，当汽车以相似的速度行驶，交通也相似，并且我们已经行驶了一定的时间，答案将是相同的(不，我们还没有到达那里！).对于计算机系统，什么是“相似的”*什么是*可以被定义和约束以适应。有时输入无论如何都是精确的。关键是，我们知道问题的答案，*因为之前有人问过。*

# **但是事情变了！**

变化是会发生的，但是如果我们知道输入和算法，我们就知道输出会是什么。在应用程序中，我们可以做到这一点。我们知道我们可以缓存什么以及缓存多长时间。我们将此建立在事物变化的频繁程度以及给出正确答案的重要性的基础上。这有时会影响内部应用程序的设计，但通常用于通知其他下游应用程序如何在数据变得陈旧或无效之前使用数据。这通常以 TTL(生存时间)的形式出现。

TTL 的概念很容易掌握。如果某些数据不会频繁变化，可以使用长 TTL。想象一下字典对单词的定义——它们很少改变，TTL 可以在几个月或几年内安全地测量出来。在另一个极端，你最喜欢的新闻提要会经常改变，需要一个很短的 TTL，可能是几分钟或几秒钟。两个方向都有更多极端的例子，中间也有很多。TTL 的选择对性能、可扩展性和可用性至关重要。

但是什么是改变呢？就数据而言，我们经常认为它是清除旧的并用新的替换它。这是我们在物理世界中观察到的。当我们把一面墙从红色重新漆成蓝色时，剩下的只有一面蓝色的墙。红墙已经不在了。它已经被替换了。我们很容易想象这一点，当与存储稀缺相结合时，这也是应对变化的最有效方式。但是，这是处理数据变更的最佳方式吗？

![](img/4883e33b54a7d80b5830149246f382cf.png)

照片由 [russn_fckr](https://unsplash.com/@russn_fckr?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 在 [Unsplash](https://unsplash.com/collections/1281590/evolve?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上拍摄

# **变化可以是不可变的**

存储便宜。真的很便宜。因此，保留一个记录的所有迭代也很便宜。对于复杂的数据集，这个规则也有例外，但是对于大多数数据类型——尤其是文本脚本和标记——存储迭代的成本很小，尤其是在迭代相对不频繁的情况下。对于不太适合的数据类型，比如图像和视频，迭代也可能更少(我很想看到这方面的一些统计数据！).

成本也是相对的。带宽比存储更贵。计算比存储更昂贵(否则你为什么不重新计算呢？).看似小的节省，从大的方面来看可能是一笔大的开销。节省几千字节的磁盘空间来*替换*可变数据，最终可能会花费更多的成本来传输或重新计算过时的数据。

给定不可变数据可以有一个无限的 TTL，有明显的好处。每个更改都可以根据需要进行缓存。如果使用某种 LFRU(最近最少使用的)缓存，旧的和未使用的内容将从缓存中删除，为新的和流行的内容让路。

有了足够大的缓存，甚至可以实现离线操作。当你能保证某件事不会改变时，你上周读的那篇文章肯定也是一样的。你昨天开始的那本书还是一样的。您在阅读本文之前观看的视频将会在您的缓存中再次观看，保持不变。或者存储在向其请求数据的主机的缓存中，或者存储在两者之间的代理中。

如果一篇文章在你最后一次阅读后发生了变化，该怎么办？如果原始文件是不可变的，它应该仍然可用。这打开了自存档应用程序和网站的大门，消费者可以回到过去阅读原文。想想这对审查制度会有什么影响。想象一下，我们可以多么容易地保存今天的信息，以便将来从中学习？

# **混合可变和不可变**

在协议层，WWW 不保证响应是不可变的。虽然有非标准的缓存控制头来表明某些东西应该被认为是不可变的，但它不能使它成为真的。假设你被路由到一个可以随意改变底层数据的主机，*怎么能*做到呢？有一些机制让客户端应用程序检查它是否*已经*改变，但是它不保证它*不会*改变。

我们所能做的是散列数据来为数据项生成唯一的指纹。也可以使用这种方法来寻址数据并确认它没有改变。更进一步，我们可以防止主机一致操纵这些数据。我以前写过关于安全网络的文章，这正是它试图提供的。对不可变数据的访问保证没有改变，因此可以永久缓存*。*

*通过将数据项分成不可变的块，由它们唯一的指纹来寻址，每个块可以根据需要被缓存。此外，存储具有公共块的数据项将允许块被重用。它们已经过重复数据消除。因为已知它们是相同的，所以没有必要存储它们。如果客户端已经缓存了不同数据项的块，那么他们也已经拥有了它。这节省了存储、带宽和计算时间。*

*![](img/4d7ae39a2b9364081f55c75e24a88cf2.png)*

*由 [Kate McLean](https://unsplash.com/@justkate__?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 在 [Unsplash](https://unsplash.com/s/photos/weave-knit?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上拍摄的照片*

*当然，需要有一种方法将这些不可变的块组合在一起。网站和新闻提要会发生变化。如果这些应用程序只提供不可变的数据，那么这些数据就会被冻结，没有什么用处。应用程序设计需要能够以可变的方式将不可变的数据放在一起。通过可变索引，我们可以做到这一点。*

# *如何设计应用程序？*

*实用的设计会是什么样子？对于像博客或新闻提要这样的东西，我会设想一个指向不可变索引和不可变数据项的可变指针。当请求 blog 或 feed 时，会返回最新索引的地址，并且可以检索数据项。当新数据作为不可变项被添加时，索引被新的不可变索引替换，并且可变指针被更新以指向它。*

*假设可变指针是一个小数据项，那么检索它就很简单。网络所能提供的将是微不足道的。一旦检索到，索引和数据项都是不可变的，并且将根据需要被缓存。您还可以指定以前版本的索引来查看旧的快照，您可能已经下载并缓存了该快照，并且可能处于脱机状态。*

*在这种应用程序中，很小一部分是可变的，只存在于指向所需的不可变数据。考虑到许多人可能会访问博客或新闻提要，通过网络和在单个客户端上进行缓存将会分散负载并最大限度地减少重复工作。*

# ***一颗干净、绿色、银色的子弹？***

*虽然不可变数据仍然需要能量来存储和检索，但是能够永久缓存数据带来了巨大的好处。在许多方面，它提供了与广播类似的收益，但消费者可以灵活选择何时接收。它还可以降低复杂性，减少移动部件，减少时间问题，提高一致性。*

*它是否有助于减少重复重复事情所浪费的能量？它是否有助于减少重复重复事情所浪费的能量？抱歉，我忍不住…但我相信答案可能是*是的*。*

*常见的网站和应用可以更新使用不可变的 web 应用架构吗？我们是否需要一个更基本的交换机来拥有一个类似于安全网络所寻求实现的公共数据层？或者动态服务器驱动的应用程序是不可避免的，伴随着它们所需要的相关的重复性和复杂性？我很想听听你的想法。*

*[1]Cache-Control HTTP Headers
[https://developer . Mozilla . org/en-US/docs/Web/HTTP/Headers/Cache-Control](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control)*

*[2]安全网
[https://safenetwork.tech/](https://safenetwork.tech/)*

*[3]不可变的网络应用
[https://immutablewebapps.org/](https://immutablewebapps.org/)*