<html>
<head>
<title>Creating a Modular SPA with Vue.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Vue.js创建模块化SPA</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/creating-a-modular-spa-with-vue-js-e11e200634d2?source=collection_archive---------6-----------------------#2021-11-02">https://levelup.gitconnected.com/creating-a-modular-spa-with-vue-js-e11e200634d2?source=collection_archive---------6-----------------------#2021-11-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="4ff0" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">动态扩展你的应用程序是可能的。学习如何。</h2></div><p id="a220" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">SPA上的开发工作流程相当标准。您将文件添加到代码库中，构建它们，然后在某个地方发布静态输出。这非常简单，但是非常单一(您可以在同一个应用程序中拥有多个模块，但是您基本上是将它们都放在一个不可变的工件中)。</p><p id="a5f3" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">无论如何，如果你想到我们在微前端方面的重大变革，像这样的应用程序很难维护(对于这个概念的新手来说，只要想想在前端应用后端的微服务会发生什么)。许多微前端框架仍然从编译嵌入到单个容器中的多个SPA开始，或者以混合所有单个组件然后将它们构建在一起的方式开始。</p><p id="a1a5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我将展示另一种方法。我将使用动态组件在运行时包含特性，不需要编译步骤。当然，这种方式不能提供完全编译的一些特性(例如输出优化)，但是在一些非性能关键的应用程序中是一个很好的解决方案。</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi le"><img src="../Images/aa1d8009879975a660b623b055581da8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cEmcWQzqGABDSq_k"/></div></div><figcaption class="lq lr gj gh gi ls lt bd b be z dk translated">由<a class="ae lu" href="https://unsplash.com/@greysonjoralemon?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">格雷森·乔拉蒙</a>在<a class="ae lu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="c631" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">建筑</h1><p id="6a9b" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">这个应用程序的架构非常简单。我希望有一个分成模块的应用程序，其中每个模块都可以通过一个HTTP URL使用(也在不同于主应用程序的服务器中)。每个模块可以包含多个组件，这些组件可以相互交互，发送消息。这些需求可以转化为下一个架构:</p><figure class="lf lg lh li gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi mz"><img src="../Images/9eb5ff5f7984ba09a199f491d0f77b7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wmRn_25jCldHwQc8TUPADA.png"/></div></div></figure><p id="9eec" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">主应用程序有一个包，用于托管所有服务并将它们分发到所有模块。同样，它保存模块中定义的所有组件和路由规则。因此，预期的行为是很容易的。应用程序启动，激活模块目录中定义的所有模块，然后从模块中获取所有服务定义，将服务注入到模块中。最后，它加载所有组件和路由定义，以便主应用程序可以将所有特性混合在一起。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="4d0d" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">动态组件</h1><p id="72ae" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">app engine的核心部分是从文件中动态加载Vue组件。我期望的最终结果是能够调用类似于</p><pre class="lf lg lh li gt na nb nc nd aw ne bi"><span id="d0ea" class="nf md it nb b gy ng nh l ni nj">export default  extend("login",{<br/>//..component definition<br/>template: "/path/to/template"</span><span id="3164" class="nf md it nb b gy nk nh l ni nj">})</span></pre><p id="f2fe" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在前面的代码片段中，我有机会指定一个定制的模板路径或者简单地使用一个基于规则的命名约定(template应该在<code class="fe nl nm nn nb b">/templates/&lt;name of the component&gt;.vue</code>中)。</p><p id="5729" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下一个代码片段包含了<code class="fe nl nm nn nb b">extend</code>方法的实现。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="11df" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">既然我们能够激活动态组件，我们只需创建一个模块系统和一个引导机制。让我们在下一节看到它。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="7b29" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">模块定义</h1><p id="ac56" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">javascript的模块定义是为我们的动态系统创建模块的良好起点。唯一的问题是每个模块都必须动态加载，即使是通过HTTP资源。这可以通过使用关键字<code class="fe nl nm nn nb b">import</code>作为函数来完成，因此调用类似于<code class="fe nl nm nn nb b">let modulet=await import('path to file')</code>的东西。这很容易，如果我们给模块一些约定，我们可以调用一些特殊的方法来与模块交互。我说的是注入服务、获取服务定义或者简单地获取模块的路径。下一个代码片段展示了模块原型。</p><figure class="lf lg lh li gt lj"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="8043" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">模块引导只不过是URL集合和一系列方法调用上的for-each循环。请看下一个片段。</p><pre class="lf lg lh li gt na nb nc nd aw ne bi"><span id="42e9" class="nf md it nb b gy ng nh l ni nj">loadModules =async() =&gt;    {           <br/>  for (const [key, value] of Object.entries(this.config.modules)){<br/>  let module=await import(value);<br/>  this.modules[key]=module.default;         <br/>  }    <br/>};</span></pre><p id="8d22" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么很容易想象模块原型上的每个API都会有一个调用。在下一个片段中，有一个服务注入的例子。</p><pre class="lf lg lh li gt na nb nc nd aw ne bi"><span id="e7d7" class="nf md it nb b gy ng nh l ni nj">registerServices= async ()=&gt;   {<br/>  for (const [key, value] of Object.entries(this.modules) ){<br/>     if (typeof value.registerServices !== "undefined") {<br/>      await value.registerServices(this.services,this);<br/>     }<br/>  };<br/>};</span></pre><p id="8003" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">总结模块步骤，我们可以创建任意多的模块，我们可以将它们部署在不同的服务器上，然后，主应用程序将动态地加载它们，而不需要重新编译任何东西。这将允许您的用户在浏览器上点击CTRL+F5，并立即获得网站的更新版本。由于模块加载是完全动态的，您还可以为每个用户或配置文件定制一个应用程序版本。</p></div><div class="ab cl lv lw hx lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="im in io ip iq"><h1 id="a822" class="mc md it bd me mf mg mh mi mj mk ml mm jz mn ka mo kc mp kd mq kf mr kg ms mt bi translated">带什么回家</h1><p id="7c01" class="pw-post-body-paragraph ki kj it kk b kl mu ju kn ko mv jx kq kr mw kt ku kv mx kx ky kz my lb lc ld im bi translated">制作一个模块化的应用程序在很多方面都是可能的。这个手工解决方案加上Vue.js和几行代码就是我用来构建<a class="ae lu" href="https://github.com/zeppaman/api-farm" rel="noopener ugc nofollow" target="_blank"> Api Farm </a>的，这个无头的低代码平台。</p><p id="521a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如您在本教程中了解到的，由于Vue.js的灵活性，我们可以在运行时集成模块，并根据功能轻松扩展我们的应用程序。</p></div></div>    
</body>
</html>