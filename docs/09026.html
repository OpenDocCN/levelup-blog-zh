<html>
<head>
<title>Synchronising Video Streaming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">同步视频流</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/tired-of-making-to-do-list-applications-acce875fe617?source=collection_archive---------11-----------------------#2021-06-29">https://levelup.gitconnected.com/tired-of-making-to-do-list-applications-acce875fe617?source=collection_archive---------11-----------------------#2021-06-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="345a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">你的第一个web开发项目的新东西</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f79f3629e6ae0b84fe8de1d6bc1588b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*CXvBeDoWtguE01XU31jddA.gif"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">演示:在Chrome中打开四个标签页的视频同步器。GIF作者，视频来源:<a class="ae kv" href="https://www.youtube.com/watch?v=aqz-KE-bpKQ&amp;t=60s" rel="noopener ugc nofollow" target="_blank">大巴克兔</a></figcaption></figure><p id="32a0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我将讨论如何创建我的第一个同步视频流的web应用程序。像<a class="ae kv" href="https://twoseven.xyz/" rel="noopener ugc nofollow" target="_blank"> twoseven </a>和<a class="ae kv" href="https://www.netflixparty.com/" rel="noopener ugc nofollow" target="_blank"> Teleparty </a>这样的服务使用户能够在网飞等热门平台上观看电影和电视节目，同时与朋友保持同步。作为一名普通用户，我对它们是如何工作的非常着迷和好奇。我为YouTube视频流创建了自己的版本。我解释了我在不同算法、技术和技巧上的发现，我用这些算法、技术和技巧来实现多个远程用户的同步播放。我还回顾了我在寻找解决方案时遇到的令人讨厌的错误。(这是Git回购</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/1b9be64ca8d93bd3978661868f876362.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*3lb8nG8nhaLAvhQRJdztUw.gif"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">演示:界面和功能。GIF作者，视频来源:<a class="ae kv" href="https://www.youtube.com/watch?v=aqz-KE-bpKQ&amp;t=60s" rel="noopener ugc nofollow" target="_blank">大巴克兔</a></figcaption></figure><p id="77d0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我有机器学习和竞技编程背景。当我开始这个项目时，我不知道web应用程序的后端和前端之间的区别。如果你和我一样是新手，我已经在<a class="ae kv" href="#87ba" rel="noopener ugc nofollow">中加入了一些有用的视频和文章链接</a>来帮助你入门。关于技术栈，我用Vanilla JS创建了前端，用Python创建了Flask后端。讨论的大部分内容与提到的技术堆栈无关。最好的跟进方式是花时间阅读不熟悉的概念；请自行搜索或浏览提供的链接。每一部分可能都与你无关，不按顺序阅读甚至跳过几部分也没关系。让我们直接跳进来吧！😃</p><ol class=""><li id="f7f9" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><a class="ae kv" href="#9d7c" rel="noopener ugc nofollow">概述</a></li><li id="ed64" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" href="#4267" rel="noopener ugc nofollow">通信</a></li><li id="594d" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" href="#5d58" rel="noopener ugc nofollow">状态管理</a></li><li id="c44f" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" href="#37d9" rel="noopener ugc nofollow">时钟同步</a></li><li id="e77c" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" href="#00ec" rel="noopener ugc nofollow">异步JS </a></li><li id="f296" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" href="#b10d" rel="noopener ugc nofollow">并行计算</a></li><li id="c500" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" href="#7e88" rel="noopener ugc nofollow">我发现的有趣的bug</a></li><li id="75f6" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" href="#f408" rel="noopener ugc nofollow">免责声明</a></li><li id="ac7c" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" href="#6c4a" rel="noopener ugc nofollow">进一步</a></li><li id="da1b" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" href="#87ba" rel="noopener ugc nofollow">资源</a></li></ol><h1 id="9d7c" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated"><strong class="ak">概述</strong></h1><p id="c262" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">每当用户改变状态时——播放、暂停或搜索视频，我们都希望每个人都能实时看到准确的变化。为此，我们需要有人在用户中协调这些更新。服务器负责这种状态管理和协调。每当用户进行任何更改时，更新后的状态都会被发送到服务器，服务器会将这个新状态传播到其余的客户端，使每个人都保持同步。</p><h1 id="4267" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">沟通</h1><p id="23ff" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">只要用户(您)通过简单的HTTP POST请求做出任何更改，客户机(浏览器)就可以通知服务器。然而，服务器如何将更新后的状态传播给其他用户并不简单。<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview" rel="noopener ugc nofollow" target="_blank"> HTTP </a>是一种请求-响应协议，意思是请求由客户端发起，由服务器响应。服务器不能随心所欲地向客户机发送信息。那么我们如何解决这个问题呢？</p><p id="84bd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">短轮询</strong></p><p id="6591" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">规避这一限制的一种方法是短轮询。这个想法是，客户端将在固定的时间间隔重复向服务器发出请求。因此，举例来说，在我们的应用程序中，客户端可以每两秒钟询问服务器是否有其他人进行了更改。</p><p id="d8d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于我们的用例来说，这种方法有两个主要问题—</p><ol class=""><li id="14ec" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">在最糟糕的情况下，一个更改会晚两秒钟到达另一个用户，破坏用户的浏览体验。</li><li id="180f" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">看起来我们可以任意缩短这个时间段，以便更快地在网络中传播变化，但是我们增加轮询频率是有限度的。频率越高，消耗的网络和计算资源越多。即使状态没有改变，所有的客户机仍然向服务器发出不必要的、浪费的请求，这是不希望的。</li></ol><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/ccd1c5a4b54a56f344d29cb2904a81b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*lP8L6m6pQMETxiXDczpNdg.gif"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">演示:延迟与轮询同步(轮询时间为5s)。GIF作者，视频来源:<a class="ae kv" href="https://www.youtube.com/watch?v=aqz-KE-bpKQ&amp;t=60s" rel="noopener ugc nofollow" target="_blank">大巴克兔</a></figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/2828dcfb562dae569aa35e41dbd23236.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*4c1ubV9ayrWWqFoMtm9hNw.gif"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">演示:中间状态因轮询而丢失(轮询时间段为5s)。GIF作者，视频来源:<a class="ae kv" href="https://www.youtube.com/watch?v=aqz-KE-bpKQ&amp;t=60s" rel="noopener ugc nofollow" target="_blank">大巴克兔</a></figcaption></figure><p id="1e9c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的两个演示中，您可以看到由于轮询而产生的延迟。在第一种情况下，到达另一个客户端的状态更新会有明显的延迟。在第二个演示中，由于客户端每5秒轮询一次，因此它将只获得最新的状态，而不知道中间是否发生了多次更改(这不是一个缺点，只是一个观察)。</p><p id="30b4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://en.wikipedia.org/wiki/Push_technology#Long_polling" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">长轮询</strong> </a></p><p id="8187" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">只有当请求的资源已经从上次发送的版本更新时，服务器才响应客户端请求。它保持请求开放，并在发生更改时立即响应。这样，客户端可能要等待服务器很长时间，因此得名。客户端一收到响应，通常会立即创建另一个请求，通过这种方式，长轮询会模拟一个<a class="ae kv" href="https://en.wikipedia.org/wiki/Push_technology" rel="noopener ugc nofollow" target="_blank">服务器推送</a>。</p><p id="7894" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://en.wikipedia.org/wiki/WebSocket" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> WebSocket </strong> </a></p><p id="a96f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">来自官方IETF(互联网工程任务组)RFC(征求意见稿)，<a class="ae kv" href="https://datatracker.ietf.org/doc/html/rfc6455" rel="noopener ugc nofollow" target="_blank"> RFC 6455 </a>，</p><blockquote class="nd ne nf"><p id="79e5" class="kw kx ng ky b kz la jr lb lc ld ju le nh lg lh li ni lk ll lm nj lo lp lq lr ij bi translated">WebSocket协议旨在取代使用HTTP作为传输层的现有双向通信技术，以受益于现有的基础设施(代理、过滤、身份验证)。这样的技术被实现为效率和可靠性之间的折衷，因为HTTP最初并不打算用于双向通信。</p></blockquote><p id="77b9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个协议让客户机-服务器建立一个全双工通道，这意味着一旦连接建立，任何一方都可以随时发送消息。服务器不需要来自客户端的打开请求来发送信息，这与长轮询的情况不同。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/ca5a4b7686b583a11a945e0b8843eea1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Sj8YTpHGgDI4XyUKdFeAkA.gif"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">演示:WebSockets的实时变化。GIF作者，视频来源:<a class="ae kv" href="https://www.youtube.com/watch?v=aqz-KE-bpKQ&amp;t=60s" rel="noopener ugc nofollow" target="_blank">大巴克兔</a></figcaption></figure><p id="709e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://en.wikipedia.org/wiki/Server-sent_events" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> SSE(服务器发送的事件)</strong> </a></p><p id="6449" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">来自维基百科，</p><blockquote class="nd ne nf"><p id="c3c7" class="kw kx ng ky b kz la jr lb lc ld ju le nh lg lh li ni lk ll lm nj lo lp lq lr ij bi translated">服务器发送事件是一种服务器推送技术，使客户端能够通过HTTP连接从服务器接收自动更新，并描述一旦建立了初始客户端连接，<strong class="ky ir">服务器如何能够</strong> <strong class="ky ir">向客户端发起</strong>数据传输。</p></blockquote><p id="ae27" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对SSE的支持内置在最新的HTTP版本中，并且比使用WebSockets(一种单独的专用协议)简单得多。一个问题是服务器不能使用SSE向客户机发送二进制数据。另外，注意SSE只是从服务器到客户端。客户端仍然以同样的方式发出请求，使用普通HTTP。</p><p id="d4f3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">对比</strong></p><div class="kg kh ki kj gt ab cb"><figure class="nk kk nl nm nn no np paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/6294342b8a595a6d4f923f32dd536006.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*YnmubCy-SbXU2UFmtCSuKw.png"/></div></figure><figure class="nk kk nl nm nn no np paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/e3d14298c7a18873bc0a6ff95db1f1bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*yh5lymD1Jz6sD7JWcuemFQ.png"/></div></figure><figure class="nk kk nl nm nn no np paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/6747dc48c5d91158e096e45287fa452a.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*OmgG0MWf5yZr7RlT9OWWmQ.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk nq di nr ns translated">说明:短轮询、长轮询和WebSockets如何在相同的情况下工作。作者提供的图片</figcaption></figure></div><p id="c68e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在选择要使用的协议时，需要考虑许多错综复杂的实际问题，例如最大连接数、可扩展性等。因为这不是本文的目的，所以我没有讨论这些。如果你感兴趣的话，我链接了一些栈溢出的答案和博客帖子。我最终使用了WebSocket协议，因为我发现它最容易用于实时同步(使用<a class="ae kv" href="https://socket.io/" rel="noopener ugc nofollow" target="_blank">套接字)。客户端的IO库</a>和服务器端的<a class="ae kv" href="https://flask-socketio.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank">烧瓶插槽</a>。</p><h1 id="5d58" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">状态管理</h1><p id="a334" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">现在，假设所有机器的时钟都是同步的(稍后会有更多<a class="ae kv" href="#37d9" rel="noopener ugc nofollow">)。我们需要存储两件显而易见的事情:当前的视频时间戳和视频是否正在播放。需要存储的两个不太明显的东西是最后一次更改的全局时间戳和记录视频时间戳的全局时间戳。这两者分别对于处理无序数据包和解决网络延迟都是必不可少的。</a></p><p id="a373" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于这里讨论的所有例子，假设客户机1和客户机2在全局时间戳t_0之前已经同步。在t_0，用户1暂停视频(可能是任何变化)，不久之后，在t_1，用户2寻找视频。由于user2的更改发生的时间较晚，所以这应该是最终状态，但是这些消息可能会因为几个原因而无序地到达服务器。如您所见，如果我们不记录在用户端实际发生更改的时间，服务器不会忽略过时的更新。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/6927d94f16d2bd83b7fc984e4ef17565.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QK3qFgFsKFEbSNMidpzw2Q.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">插图1:无序消息。作者图片</figcaption></figure><p id="d178" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">只要记录了视频的当前时间戳，就必须记录全球时间。例如，考虑用户从最初同步的暂停状态播放视频的情况。由于网络延迟，该消息将在一些延迟之后到达其他用户，并且他们将总是在做出改变的人的后面。如下图所示。请注意，如果从运行状态更改为暂停状态，将不会有任何问题。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nu"><img src="../Images/3759073cce41c06ecee79c99a921f62e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ObSYYq3QU0tFJiacjFOiXw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">插图2:需要记录全局时间戳和相对视频时间戳。作者图片</figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/8909763307022fcb624e6fd3f33cd18e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*98vXElmPQoUP1ulGFBV7GQ.gif"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">演示:不记录全球时间时网络延迟的影响(在服务器端引入了500毫秒的人为延迟)。GIF作者，视频来源:<a class="ae kv" href="https://www.youtube.com/watch?v=aqz-KE-bpKQ&amp;t=60s" rel="noopener ugc nofollow" target="_blank">大巴克兔</a></figcaption></figure><p id="294d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上述问题导致客户端不同步。这与我们在投票的例子中看到的不同。如果轮询是用全局时间戳完成的，那么同步将被延迟，但是当它开始时，它将是正确的。</p><h1 id="37d9" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">🕑时钟同步🕔</h1><p id="a3b8" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">我花了很长时间才发现这个错误。在所有的状态管理讨论中，我们假设网络上的每个系统都可以访问对每个人都相同的全局时间。实际上，任何编程语言中的所有时间库都使用系统时间来计算全局时间。这个时间是由计算机系统中的实际硬件计时器来维护的。当然，两台机器上的时间不同步有很多原因——时钟可能在很长一段时间里偏离了几秒钟，或者有人故意更改了它。关键是我们需要在开始前同步所有的时钟；否则，我们根本不能指望视频同步器工作。</p><p id="cc04" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于每个客户端都与服务器对话，因此似乎每个人同步时间的最佳方式是在建立连接后独立地与服务器同步他们的全球时间。</p><p id="548d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，你可能已经意识到还有另一个根本问题。为了与服务器同步，首先，你要询问它的全球时间。然后，一旦您得到响应，您将把它与您当前的全球时间进行比较，并查看差异，随后您将使用差异来校正您的时间估计。问题是，从服务器测量时间到您实际收到时间并测量您的时间，已经过去了一段时间。这种网络滞后会一直存在。因此，我们永远不可能有完美的同步，除非你把你的机器放在服务器旁边，并设置好两个时间(或者使用其他一些预同步时钟进行协调)。那么我们能做的最好的是什么？</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/7ef7d92db781e675760c5fcdcba8b976.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6B0ia6Dhi7wyYetOEiuQCA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">插图3 —时钟同步。作者图片</figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/0993ef643c547f65944af0852d462c93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I9Lj-ipSPBTd3jYwuCFStA.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">算法说明，<a class="ae kv" href="https://drive.google.com/file/d/1jIkYK5FDB5TN1VXIDIGJ94w1VxvVfAKV/view?usp=sharing" rel="noopener ugc nofollow" target="_blank">点击此处</a>查看更高分辨率。图片作者。</figcaption></figure><p id="fc12" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种寻找时间校正的方法是受这里描述的<a class="ae kv" href="https://en.wikipedia.org/wiki/Clock_synchronization" rel="noopener ugc nofollow" target="_blank"/>时钟同步算法的启发。在不同的机器上用服务器和客户机测试我的方法时，我发现修正估计值相差不到100毫秒。当我在同一台机器上运行服务器和客户机时，真正的修正应该是0，因为它们使用相同的时钟。在这种情况下，我的估计是大约2毫秒。</p><h1 id="00ec" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">异步JavaScript</h1><p id="3405" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">在我的整个大学生活中，我都在使用同步代码，我的第一个主要概念错误是将我的JS代码视为同步的。即使在看了关于回调和承诺的视频后，我也只是复制了用于HTTP请求的“fetch”和“dot then”语法，而没有完全理解承诺在JS中的真正含义。我发现<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous" rel="noopener ugc nofollow" target="_blank"> MDN文档</a>非常有助于消除我的大部分误解和疑虑。</p><p id="a8be" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们用JS中的“fetch”发出HTTP请求时，它会立即返回一个承诺。我们不需要等回应回来；我们可以继续我们自己的处理。通过指定回调函数，我们可以告诉它在结果返回时做什么。相反，如果fetch调用被阻塞，除了浪费宝贵的时间等待调用返回之外，web界面还会冻结，不能注册用户点击，等等。注意，承诺和异步的概念并不局限于网络调用。我强烈建议在继续本节之前，先看一下<a class="ae kv" href="https://www.youtube.com/watch?v=8aGhZQkoFbQ&amp;ab_channel=JSConf" rel="noopener ugc nofollow" target="_blank"> Philip Robert对JS </a>中事件循环的水晶般清晰的解释(看完视频后你应该能回答下面的问题)。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nx ny l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">试着猜测一下<a class="ae kv" href="https://gist.github.com/jayantjain100/3af75eb44554760dc678b177ca4f13fc" rel="noopener ugc nofollow" target="_blank"> JS片段</a>的输出。</figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/6cd96ad727b05cc2cecb895e9c7b1bc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:652/format:webp/1*cSvJYU4FcbxLB5FwVwBo9Q.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">代码片段的输出。图片作者。</figcaption></figure><h1 id="b10d" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated"><strong class="ak">并行计算</strong></h1><p id="2ec6" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">类似于JS需要异步，服务器不能只运行一个进程或线程。如果是这样的话，那么它一次只能处理一个客户端的请求，其他的请求将会排队等待，或者更糟，被拒绝。</p><p id="d9db" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">目前，我在python脚本中使用全局变量进行状态管理。然而，这不是线程安全的，因为我可能有两个线程同时覆盖状态，导致意外的行为。此外，如果运行多个进程，每个进程都有自己的状态变量副本。理想的解决方案是使用一些数据库管理软件，它将为我们处理所有这些，但这似乎有点大材小用，因为我有一个非常小的状态，它不特定于任何用户。一个简单的解决方案是将状态写入文件，并在写入该文件时使用锁定机制。我相信这可以在多线程/进程中正常工作，尽管这可能不是最有效的方式。到目前为止，我只使用了Flask提供的内置开发服务器，它用单线程运行一个进程。这就是为什么这个重大问题没有回来咬我。我计划在这个项目的<a class="ae kv" href="#6c4a" rel="noopener ugc nofollow">下一个版本中修复这个问题，如果有的话。</a></p><p id="00c0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，默认情况下，内置的开发服务器在参数“host”设置为“127.0.0.1”的情况下运行，这意味着只有您能够访问该应用程序。来自<a class="ae kv" href="https://flask.palletsprojects.com/en/1.1.x/quickstart/" rel="noopener ugc nofollow" target="_blank">烧瓶的文件</a></p><blockquote class="nd ne nf"><p id="657c" class="kw kx ng ky b kz la jr lb lc ld ju le nh lg lh li ni lk ll lm nj lo lp lq lr ij bi translated">如果您运行服务器，您会注意到服务器只能从您自己的计算机访问，而不能从网络中的任何其他计算机访问。这是默认设置，因为在调试模式下，应用程序的用户可以在您的计算机上执行任意Python代码。</p></blockquote><p id="d7cd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，如果您禁用了调试器，或者信任网络上的用户，则可以通过将“host”参数设置为“0.0.0.0”来使服务器公开可用。</p><h1 id="7e88" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">我发现了有趣的虫子🐛</h1><p id="e8da" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">我将讨论一个具体的实现(也许？)的问题，直到最后我也无法妥善解决。我使用HTML5视频播放器来显示视频，并让用户播放/暂停/搜索视频。这个元素有对应于这些用户动作的<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video#events" rel="noopener ugc nofollow" target="_blank">事件</a>，我为每个事件编写了一个事件处理程序(每当事件触发时调用的函数)。每当用户进行更改时，相应的事件处理程序就会被触发，并通知服务器有关更改的信息，通知其他所有连接的人。听起来不错，对吧？问题是我找不到任何可靠的方法来区分用户引起的事件和脚本引起的事件。这意味着每当客户端从服务器接收到状态更新时，它将在本地进行更改，这将触发事件处理程序，事件处理程序将再次通知服务器这些更改，从而导致无限循环。除此之外，当你试图寻找一个已经播放的视频时，它会引发3个事件；首先，它暂停，然后寻找，然后播放，导致3个请求发送到服务器，而我们只需要发送最后一个。我想到的解决办法是，一旦服务器收到请求，它会在一段时间内(比如1秒)忽略来自所有其他客户端的请求。期望是，在这个时间框架内，新的状态将到达每个人；每个客户端将实现这些更改，并尝试将其新状态发送回服务器，但服务器会忽略这些更改，从而结束冗余传播。这不是一个完美的解决方案。这里的一个主要问题是，如果某个实际的用户在这段时间内进行了真正的更改，那也会被忽略。</p><p id="3c2f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一种解决方案是创建自己的播放/暂停/搜索控件。这将使您能够更好地控制何时触发视频播放器事件，以及何时调用服务器的状态更新。在当前的方法中，这两者纠缠在一起，导致了几个问题。如果您要创建自己的控件，另一件有趣的事情可能会发生。目前，如果您在自己的终端播放视频，并且此状态更新消息在0.5秒后到达您朋友的系统，那么他们的视频将从比暂停时间晚0.5秒的时间戳开始播放(最初同步)。这种时间上的跳跃确保了同步，但也让他们错过了视频的一小部分。对于这个问题，我的朋友提出了一个有趣的解决方案。当用户点击播放按钮，而不是立即播放他们的视频，消息将发送到服务器，并为每个人决定一个全球时间开始播放。这个全球时间会延迟足够长的时间，让每个人都能接收到服务器的消息，并做好准备，但希望足够短，不会打扰到实际播放视频的用户😅。</p><h1 id="f408" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">放弃</h1><p id="2e28" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">所以…这个项目使用了python库<a class="ae kv" href="https://pypi.org/project/pafy/" rel="noopener ugc nofollow" target="_blank"> Pafy </a>，它在后台使用<a class="ae kv" href="https://github.com/ytdl-org/youtube-dl" rel="noopener ugc nofollow" target="_blank"> youtube-dl </a>库将youtube URL转换为直接的流链接。使用该应用程序传输媒体可能违反Youtube的服务条款，使用这个库或我的网络应用程序从youtube下载受版权保护的内容绝对是非法的❌.这个项目是为了学习📚，如果没有人滥用它，我会非常感激。谢谢！</p><h1 id="6c4a" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated"><strong class="ak">进一步</strong></h1><p id="b8ef" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">我将提到我对这个项目下一个版本的一些想法。截至目前，当用户的视频开始缓冲时，web应用程序不会处理这种情况。应该为每个人暂停视频，还是应该让视频被缓冲的用户跳到其他人所在的位置？在状态更新之后，来自其他用户的更改会在短时间内被忽略，这可以通过<a class="ae kv" href="#3c2f" rel="noopener ugc nofollow">实现我自己的控件</a>来避免。可以添加对上传个人视频的支持。可以添加独立房间的功能，以便不同的人群可以同时使用该服务，而不会相互干扰。与twoseven类似，可以添加一个聊天框和连接每个用户的网络摄像头视频的功能。通过类似于Teleparty的chrome插件来实现这种同步功能，而不是有一个单独的应用程序，这将是一种探索。接下来的步骤肯定包括将web应用程序部署到像AWS这样的云平台，并从开发服务器转移到生产服务器。我们将不得不使用合适的数据库管理系统来使我们的状态管理在保持效率的同时是线程安全和进程安全的。此外，我想研究并写一篇文章，介绍Teleparty和twoseven是如何工作的，以及可能实现相同功能的其他技术。</p><h1 id="87ba" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated"><strong class="ak">资源</strong></h1><ol class=""><li id="414e" class="ls lt iq ky b kz my lc mz lf oa lj ob ln oc lr lx ly lz ma bi translated"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Learn/Getting_started_with_the_web/How_the_Web_works" rel="noopener ugc nofollow" target="_blank">网络如何工作——MDN</a></li><li id="f784" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" href="https://www.youtube.com/watch?v=eCUeoPp-5do" rel="noopener ugc nofollow" target="_blank">前端和后端解释</a></li><li id="dd3b" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Learn/Getting_started_with_the_web/JavaScript_basics" rel="noopener ugc nofollow" target="_blank">Javascript介绍— MDN </a>(也可参见HTML和CSS介绍)</li><li id="f580" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" href="https://www.youtube.com/playlist?list=PLzMcBGfZo4-n4vJJybUVV3Un_NFS5EOgX" rel="noopener ugc nofollow" target="_blank">使用Flask在Python中构建Web应用程序— Youtube播放列表</a></li><li id="ada9" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" href="https://stackoverflow.com/a/28197906" rel="noopener ugc nofollow" target="_blank">短轮询vs长轮询vs WebSockets概述—堆栈溢出</a></li><li id="5eb6" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" href="https://ably.com/blog/websockets-vs-long-polling" rel="noopener ugc nofollow" target="_blank">深度WebSockets vs长时间投票——博文</a></li><li id="51a9" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" href="https://www.youtube.com/watch?v=71hId_-Iwqc" rel="noopener ugc nofollow" target="_blank">什么是服务器发送的事件—会议对话</a></li><li id="f657" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" href="https://www.youtube.com/watch?v=8aGhZQkoFbQ&amp;ab_channel=JSConf" rel="noopener ugc nofollow" target="_blank">JS</a>中事件循环的清晰解释</li><li id="583f" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" href="http://latentflip.com/loupe/?code=JC5vbignYnV0dG9uJywgJ2NsaWNrJywgZnVuY3Rpb24gb25DbGljaygpIHsKICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gdGltZXIoKSB7CiAgICAgICAgY29uc29sZS5sb2coJ1lvdSBjbGlja2VkIHRoZSBidXR0b24hJyk7ICAgIAogICAgfSwgMjAwMCk7Cn0pOwoKY29uc29sZS5sb2coIkhpISIpOwoKc2V0VGltZW91dChmdW5jdGlvbiB0aW1lb3V0KCkgewogICAgY29uc29sZS5sb2coIkNsaWNrIHRoZSBidXR0b24hIik7Cn0sIDUwMDApOwoKY29uc29sZS5sb2coIldlbGNvbWUgdG8gbG91cGUuIik7!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4%3D" rel="noopener ugc nofollow" target="_blank">“放大镜”工具，用于观察调用堆栈</a></li><li id="920b" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" href="https://stackoverflow.com/a/32825482" rel="noopener ugc nofollow" target="_blank">为什么全局变量在Flask中不是线程安全的</a></li><li id="5d35" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video#events" rel="noopener ugc nofollow" target="_blank"> HTML5视频播放器事件</a></li><li id="ce7a" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" href="https://github.com/jayantjain100/video-synchronisation" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> GitHub资源库</strong> </a></li></ol></div></div>    
</body>
</html>