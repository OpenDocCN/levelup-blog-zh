<html>
<head>
<title>Functional Programming tricks for simplifying and improving code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">简化和改进代码的函数式编程技巧</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/functional-programming-tricks-for-simplifying-and-improving-code-ea2fe5f89529?source=collection_archive---------6-----------------------#2020-03-24">https://levelup.gitconnected.com/functional-programming-tricks-for-simplifying-and-improving-code-ea2fe5f89529?source=collection_archive---------6-----------------------#2020-03-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/13790cdaf9c5173fa4ebe75bf1bd816c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tlJHE_qelKMWRjCgWRLKmA.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">约尔格·安格利在<a class="ae kc" href="https://unsplash.com/s/photos/ski-trick?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="ad6a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">函数式编程可以让你的代码更简单。简单性意味着代码易于阅读和理解、可测试和可维护。</p><p id="f7dd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我描述了一些函数式编程(FP)技巧，您可以通过简化代码来提高代码质量。</p><h1 id="2496" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">去掉临时变量</h1><p id="1e1f" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">函数式编程支持不变性。这个不变性原则意味着在你初始化变量之后，你不能改变它们的值。同样，在创建了对象或字符串之后，也不能改变它们。</p><p id="414c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你用JavaScript编程，你所有的变量定义都应该使用<code class="fe me mf mg mh b">const</code>。对于任何阅读您代码的人来说，常量定义让他们安心:它保证了变量永远不会被重新赋值。因为重新分配是不可能的，所以读者的大脑没有从代码中跟踪和识别重新分配的负担。</p><p id="573c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当你<em class="mi">需要</em>改变你的价值观的时候呢？首先，你可以有一个数组:</p><pre class="mj mk ml mm gt mn mh mo mp aw mq bi"><span id="a80d" class="mr lc iq mh b gy ms mt l mu mv">const fruits = ['apple', 'orange', 'banana']</span></pre><p id="8d35" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当你想把一种新的水果加入这个列表时，你会怎么做？解决方案是用新的或更新的值初始化新的常量变量。我们可以使用spread运算符复制现有的<code class="fe me mf mg mh b">fruits</code>值:</p><pre class="mj mk ml mm gt mn mh mo mp aw mq bi"><span id="8878" class="mr lc iq mh b gy ms mt l mu mv">const allFruits = [...fruits, 'pineapple']</span></pre><p id="0fb3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你应该在你的代码中处处遵循<strong class="kf ir">不变性原则</strong>。因为如果你这样做，你的代码会变得更干净。</p><p id="6d9a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您知道您的<code class="fe me mf mg mh b">fruits</code>变量的值永远不会改变，并且您在第一次看到变量的声明时就知道这个事实。初始化之后，无论你在哪里看到<code class="fe me mf mg mh b">fruits</code>变量，你都知道它仍然有相同的三个果实。</p><h1 id="9f41" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">摆脱循环</h1><p id="d20c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">功能代码告诉<strong class="kf ir">什么</strong>发生，而不是指示<strong class="kf ir">它应该如何发生。</strong></p><p id="bfa4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">循环是不起作用的，我们应该摆脱它们。</p><p id="9e70" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">考虑以下循环:</p><pre class="mj mk ml mm gt mn mh mo mp aw mq bi"><span id="bcbb" class="mr lc iq mh b gy ms mt l mu mv">var list = [];<br/>var i = 0;<br/>while (i &lt; rows.length) {<br/>    var row = rows[i];<br/>    var message = {<br/>        childAddress: row[1],<br/>        action: 'switchToBackupNode2',<br/>        role: 'edge'<br/>    };<br/>    list.push(message);<br/>    i += 1;<br/>}</span></pre><p id="0085" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">功能</strong>替代摆脱了<em class="mi">而</em>循环，并使用<em class="mi">映射</em>将行处理成一个列表。</p><pre class="mj mk ml mm gt mn mh mo mp aw mq bi"><span id="25de" class="mr lc iq mh b gy ms mt l mu mv">const list = rows.map(r =&gt; ({ <br/>    childAddress: r[1],<br/>    action: 'switchToBackupNode2',<br/>    role: 'edge'<br/> }))</span></pre><p id="5624" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">除了去掉循环，这段代码还删除了临时变量<code class="fe me mf mg mh b">row</code>和<code class="fe me mf mg mh b">message</code>以及循环变量<code class="fe me mf mg mh b">i</code>。</p><p id="c15a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">结果更具可读性。</p><p id="9d24" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">非常清楚。</p><p id="c0e4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可以<em class="mi">相信</em>只要看一看这段代码就能工作。公平地说，要获得这种程度的信任，您需要首先理解<strong class="kf ir"> map </strong>函数。在函数式编程中，map函数无处不在，因此学习它是过渡到FP的必要步骤。</p><p id="68d3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mi"> map </em>是程序员用于列表处理的函数之一。处理列表中的数据是FP的一大部分，您还应该学习其他的列表处理函数:最重要的是<code class="fe me mf mg mh b">reduce</code>和<code class="fe me mf mg mh b">filter</code>函数。</p><h1 id="7b50" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">移除ifs</h1><p id="6ea9" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">删除ifs是简化代码的一个有用策略。有几种策略可以用来从代码中移除<code class="fe me mf mg mh b">if</code>语句，应用其中任何一种通常都会产生更清晰、更容易理解的结构。</p><p id="f916" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们来看看去除<code class="fe me mf mg mh b">if</code>语句的一些策略。</p><h1 id="002c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">三元运算符</h1><p id="fe2f" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">三元运算符是我从变量赋值中去掉if语句的主要工具。</p><p id="5f39" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">考虑以下情况:</p><pre class="mj mk ml mm gt mn mh mo mp aw mq bi"><span id="c7c8" class="mr lc iq mh b gy ms mt l mu mv">let message;<br/>if (person !== null) {<br/>  message = `hello, ${person}!`<br/>} else {<br/>  message = 'hey there!'<br/>}</span></pre><p id="8a2d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的代码中有两个问题:</p><ol class=""><li id="606a" class="mw mx iq kf b kg kh kk kl ko my ks mz kw na la nb nc nd ne bi translated">我必须使用非常数变量<code class="fe me mf mg mh b">message</code>，因为使用<code class="fe me mf mg mh b">if</code>-结构，我无法在变量声明中立即给消息赋值。</li><li id="d73c" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated">考虑到它只完成声明一个变量并有条件地给它赋值的简单任务，这段代码相当冗长和复杂。</li></ol><p id="9410" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用三元运算符<code class="fe me mf mg mh b">?</code>可以在一行中完成相同的工作:</p><pre class="mj mk ml mm gt mn mh mo mp aw mq bi"><span id="ee7c" class="mr lc iq mh b gy ms mt l mu mv">const message = person !== null ? `hello, ${person}!` : 'hey there!'</span></pre><h1 id="9b20" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">布尔运算符&amp;&amp;和||</h1><p id="403e" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">布尔运算符<code class="fe me mf mg mh b">&amp;&amp;</code>和<code class="fe me mf mg mh b">||</code>为if语句提供了有效的替代方法。</p><p id="543e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">与其这样做，</p><pre class="mj mk ml mm gt mn mh mo mp aw mq bi"><span id="0bf5" class="mr lc iq mh b gy ms mt l mu mv">if (value) {<br/>  doStuff(value)<br/>} else {<br/>  doStuff(1)<br/>}</span></pre><p id="bfab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以这样做:</p><pre class="mj mk ml mm gt mn mh mo mp aw mq bi"><span id="2eff" class="mr lc iq mh b gy ms mt l mu mv">doStuff(value || 1)</span></pre><p id="aabd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里的逻辑OR操作符<code class="fe me mf mg mh b">||</code>提供了一种向函数传递默认值的快速方法。每当您不知道或者不保证变量有值时，您可以使用相同的技巧:通过在前面加上<code class="fe me mf mg mh b">|| &lt;default&gt;</code>来提供默认值。</p><p id="08e1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以下是如何使用AND运算符<code class="fe me mf mg mh b">&amp;&amp;</code>的示例。一、使用<code class="fe me mf mg mh b">if</code>的版本:</p><pre class="mj mk ml mm gt mn mh mo mp aw mq bi"><span id="b2e1" class="mr lc iq mh b gy ms mt l mu mv">if (data) {<br/>  sendData(data.value);<br/>}</span></pre><p id="0b98" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们使用<code class="fe me mf mg mh b">&amp;&amp;</code>移除if:</p><pre class="mj mk ml mm gt mn mh mo mp aw mq bi"><span id="3765" class="mr lc iq mh b gy ms mt l mu mv">data &amp;&amp; sendData(data.value)</span></pre><p id="afa8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里，我们使用<code class="fe me mf mg mh b">&amp;&amp;</code>首先检查数据变量是否有值。如果没有这种检查，当没有值时(换句话说，值是<code class="fe me mf mg mh b">null</code>或<code class="fe me mf mg mh b">undefined</code>)，代码会崩溃。</p><p id="bb32" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这里使用这些操作符时，我们依靠布尔表达式的<em class="mi">短路评估</em>。使用<code class="fe me mf mg mh b">&amp;&amp;</code>和<code class="fe me mf mg mh b">||</code>操作符，当表达式的第一部分为falsy时，JavaScript不会计算表达式的后一部分。你可以在这篇文章中阅读更多关于<a class="ae kc" href="https://codeburst.io/javascript-short-circuit-conditionals-bbc13ac3e9eb" rel="noopener" target="_blank">短路的内容。</a></p><h1 id="d6f1" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">映射和查找</h1><p id="c7d1" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">使用映射作为查找表是替换一系列if语句的有效方法。请考虑以下情况:</p><pre class="mj mk ml mm gt mn mh mo mp aw mq bi"><span id="7b95" class="mr lc iq mh b gy ms mt l mu mv">let language;<br/>if (country === 'FI') {<br/>	language = 'Finnish'<br/>} else if (country === 'SE') {<br/>	language = 'Swedish'<br/>} else if (country === 'USA') {<br/>  language = 'English (American)'<br/>} else if (country === 'UK') {<br/>  language = 'English (UK)'<br/>} // etc...</span></pre><p id="0a4a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">更干净的方法是使用国家/语言对的地图。</p><pre class="mj mk ml mm gt mn mh mo mp aw mq bi"><span id="4e76" class="mr lc iq mh b gy ms mt l mu mv">const languages = Map([<br/>  ['FI', 'Finnish'],<br/>  ['SE', 'Swedish'],<br/>  ['USA', 'English (American)'],<br/>  ['UK', 'English (UK)'],<br/>])</span><span id="9dc3" class="mr lc iq mh b gy nk mt l mu mv">const language = languages.get(country)</span></pre><p id="f389" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二个实现要简单得多。代码立刻揭示了它的意图。作为奖励，它将<code class="fe me mf mg mh b">language</code>变量转换成使用<code class="fe me mf mg mh b">const</code></p><h1 id="72bb" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">小功能</h1><p id="0286" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">函数式编程都是关于函数的。写很多小函数比写少量长函数好。将代码分解成更小的模块的主要原因是更小(更短)的部分更容易孤立地理解。较小的部分也更容易测试和维护。</p><p id="5959" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用我在这里展示的技巧，您的代码可以更加紧凑。这是一个重要的目标，也是学习这些技巧的绝佳理由，更重要的是，学习函数式编程。</p><p id="0d95" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像这样的招数和策略还多着呢。如果你想让我再写一篇关于其他类似策略的文章，请告诉我。</p></div><div class="ab cl nl nm hu nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ij ik il im in"><p id="2282" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mi">原载于2020年3月24日https://anssipiirainen.com</em><em class="mi">的</em> <a class="ae kc" href="https://anssipiirainen.com/" rel="noopener ugc nofollow" target="_blank"> <em class="mi">。</em></a></p></div></div>    
</body>
</html>