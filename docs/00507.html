<html>
<head>
<title>Improve Code Reusability With React’s Render Prop Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React渲染模式提高代码的可重用性</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/improve-code-reusability-with-reacts-render-prop-pattern-1928beaee1a4?source=collection_archive---------3-----------------------#2019-04-02">https://levelup.gitconnected.com/improve-code-reusability-with-reacts-render-prop-pattern-1928beaee1a4?source=collection_archive---------3-----------------------#2019-04-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/ea98b9f23cb75312bc0e180d68897fa3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UWK3dTK7hAMXo4Sp"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae kc" href="https://unsplash.com/@emilep?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">émile Perron</a>拍摄</figcaption></figure><p id="561b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您是一名React开发人员，并且每天都使用新的和/或以前构建的组件，您可能已经开始注意到代码中重复逻辑的模式。这可以简单到在一个组件中创建多个函数来改变不同的状态键，也可以是创建几个组件，它们是同一事物的稍微不同的版本。本文将重点解决后者，并通过遵循render prop模式将函数作为子组件来重构一个可重用的toggle组件。</p><h1 id="7d3c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">原始组件</h1><p id="009d" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">这个组件只是一个常规的React组件，它保持状态，并在单击按钮时切换布尔保持状态。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div class="gh gi me"><img src="../Images/6ce3122197f33e1f3ab2cef0f577a488.png" data-original-src="https://miro.medium.com/v2/resize:fit:1032/1*k_0HBp7iGoiC0awzzR3nhg.gif"/></div></figure><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mj mk l"/></div></figure><h1 id="61bc" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">违反单一责任原则</h1><p id="bdbb" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">因此，上面的组件做了我们希望它做的事情，但是它不灵活或不可重用，因为它不遵循单一责任原则。你问的是什么？</p><blockquote class="ml"><p id="456d" class="mm mn iq bd mo mp mq mr ms mt mu la dk translated">“单一责任原则(SRP)是五个所谓的可靠原则之一，由Robert C. Martin开发并推广，旨在帮助开发人员生成灵活且可维护的代码。简而言之，SRP认为一个给定的模块或类应该负责程序功能的一个元素，因此只有一个改变的理由。— <a class="ae kc" href="https://medium.com/@severinperez/writing-flexible-code-with-the-single-responsibility-principle-b71c4f3f883f" rel="noopener">塞弗林·佩雷斯</a></p></blockquote><p id="b4fd" class="pw-post-body-paragraph kd ke iq kf b kg mv ki kj kk mw km kn ko mx kq kr ks my ku kv kw mz ky kz la ij bi translated">如果你想了解更多关于单一责任原则的知识，请查阅Severin Perez的文章(链接见上面的引文和本文末尾的参考文献)。)</p><p id="5e2e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当查看我们的原始组件时，我们可以看到它负责几个不同的逻辑位:</p><ol class=""><li id="70be" class="na nb iq kf b kg kh kk kl ko nc ks nd kw ne la nf ng nh ni bi translated">呈现带有标题的包装元素。</li><li id="7595" class="na nb iq kf b kg nj kk nk ko nl ks nm kw nn la nf ng nh ni bi translated">管理开关的状态。</li><li id="cb53" class="na nb iq kf b kg nj kk nk ko nl ks nm kw nn la nf ng nh ni bi translated">用一个<code class="fe no np nq nr b">button</code>和条件文本呈现一个<code class="fe no np nq nr b">div</code>。</li></ol><p id="531c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们试图通过修改重用这个组件时，或者我们可能注意到在其他地方复制相同逻辑的模式时，这将开始产生问题，这两种迹象都表明我需要重新检查我的代码并分离它的关注点。</p><h1 id="49f7" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">重构#1</h1><p id="0b7b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">让我们进行第一次重构，尝试将我们的原始组件拆分开来，这样它就有了一个负责管理状态的父组件，然后呈现一个负责按钮和条件文本的功能组件，从而将关注点3从1和2中分离出来。</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="5861" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的功能组件<code class="fe no np nq nr b">ToggleWindow</code>处理关注点3，接受函数<code class="fe no np nq nr b">toggle</code>和值<code class="fe no np nq nr b">isToggled</code>的支持，并使用给定的信息呈现它需要的元素。<code class="fe no np nq nr b">Toggler</code>现在只负责关注点1 &amp; 2。</p><p id="ae26" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">虽然这样更简洁，但是当我们想要重用<code class="fe no np nq nr b">Toggler</code>逻辑，但是呈现不同的按钮和条件文本，或者更好的是呈现不同的父容器时，会发生什么呢</p><p id="c64a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过使用render prop模式并通过函数调用向<code class="fe no np nq nr b">Toggler</code>的子节点传递它需要的额外参数来解决这个问题。</p><p id="03f6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不过首先…</p><h1 id="af77" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">什么是渲染道具？</h1><p id="a076" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">根据React的文档:</p><blockquote class="ns nt nu"><p id="7455" class="kd ke nv kf b kg kh ki kj kk kl km kn nw kp kq kr nx kt ku kv ny kx ky kz la ij bi translated">术语<a class="ae kc" href="https://cdb.reacttraining.com/use-a-render-prop-50de598f11ce" rel="noopener ugc nofollow" target="_blank">“渲染道具”</a>指的是使用一个其值为函数的道具在React组件之间共享代码的技术。</p><p id="058c" class="kd ke nv kf b kg kh ki kj kk kl km kn nw kp kq kr nx kt ku kv ny kx ky kz la ij bi translated">具有呈现属性的组件采用返回React元素并调用它的函数，而不是实现自己的呈现逻辑。</p></blockquote><p id="3499" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，这意味着我们可以将一个<code class="fe no np nq nr b">Toggler</code>组件的子组件定义为一个函数，我们可以给它附加参数，以实现我们的切换逻辑。</p><h1 id="36e4" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">重构#2</h1><p id="d594" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果我们将切换逻辑保留在它自己的组件中，那么当我想在后续用例中使用它时，我可以只定义两个功能组件。这也将充分区分和分离我们之前谈到的关注点。</p><p id="8082" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您有点困惑，不要担心，代码可以更好地解释它。我在下面创建了一个例子，其中有两个独立的组件，它们对于父元素和子元素有不同的样式和内容规范。两者都将<code class="fe no np nq nr b">Toggler</code>逻辑组件“添加”到其中，但不需要重新定义它。看一看:</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/9dca3a4750853bf624c3e0295834023b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1028/1*kAaKQ1dfEgRWWyyuyoV9Lg.gif"/></div></figure><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="f36f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们现在已经坚持了单一责任原则，这使得我们的代码更加松散耦合、可重用和可维护。我们已经将我们的3个主要关注点分成不同的定义，允许它们独立存在，并且当它们需要在将来被编辑、更改或重用时，相关的代码是一个点，很容易找到并且适应性强。</p><p id="64e1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于两种不同的实现，切换逻辑以相同的方式被重用。我创建了两个使用Toggler的功能/表示组件的用例，但是在两个用例中都重用了Toggler，没有重新定义或改变它。</p><p id="5f0f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">虽然这是一个非常小的基本示例，但是想象一下如何将这种模式扩展到更大、更复杂的逻辑模式，比如数据获取或更大的状态管理任务。如果在您的代码库中应用，这将变得更加有用。</p><p id="6446" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请继续关注我的下一篇关于React Context API的博文，它利用这种模式将预定义的逻辑和值添加到特定的组件中。</p></div><div class="ab cl oa ob hu oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="ij ik il im in"><p id="8fd0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">资源:</p><div class="oh oi gp gr oj ok"><a href="https://reactjs.org/docs/render-props.html" rel="noopener  ugc nofollow" target="_blank"><div class="ol ab fo"><div class="om ab on cl cj oo"><h2 class="bd ir gy z fp op fr fs oq fu fw ip bi translated">渲染道具-反应</h2><div class="or l"><h3 class="bd b gy z fp op fr fs oq fu fw dk translated">术语“渲染道具”指的是一种使用道具在React组件之间共享代码的技术，该道具的值是…</h3></div><div class="os l"><p class="bd b dl z fp op fr fs oq fu fw dk translated">reactjs.org</p></div></div><div class="ot l"><div class="ou l ov ow ox ot oy jw ok"/></div></div></a></div><div class="oh oi gp gr oj ok"><a href="https://medium.com/@severinperez/writing-flexible-code-with-the-single-responsibility-principle-b71c4f3f883f" rel="noopener follow" target="_blank"><div class="ol ab fo"><div class="om ab on cl cj oo"><h2 class="bd ir gy z fp op fr fs oq fu fw ip bi translated">用单一责任原则编写灵活的代码</h2><div class="or l"><h3 class="bd b gy z fp op fr fs oq fu fw dk translated">坚实的原则和可维护的代码</h3></div><div class="os l"><p class="bd b dl z fp op fr fs oq fu fw dk translated">medium.com</p></div></div><div class="ot l"><div class="oz l ov ow ox ot oy jw ok"/></div></div></a></div></div><div class="ab cl oa ob hu oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="ij ik il im in"><div class="mf mg mh mi gt ok"><a href="https://gitconnected.com/learn/react" rel="noopener  ugc nofollow" target="_blank"><div class="ol ab fo"><div class="om ab on cl cj oo"><h2 class="bd ir gy z fp op fr fs oq fu fw ip bi translated">学习React -最佳React教程(2019) | gitconnected</h2><div class="or l"><h3 class="bd b gy z fp op fr fs oq fu fw dk translated">排名前49的React教程-免费学习React。课程由开发人员提交并投票，使您能够…</h3></div><div class="os l"><p class="bd b dl z fp op fr fs oq fu fw dk translated">gitconnected.com</p></div></div><div class="ot l"><div class="pa l ov ow ox ot oy jw ok"/></div></div></a></div></div></div>    
</body>
</html>