<html>
<head>
<title>Faster Code with Python Caching</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python缓存加快代码速度</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/faster-code-with-python-caching-8da6e8a92ae9?source=collection_archive---------0-----------------------#2020-01-18">https://levelup.gitconnected.com/faster-code-with-python-caching-8da6e8a92ae9?source=collection_archive---------0-----------------------#2020-01-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/e4bc5fb0f7bbaa5ed00e6ab6ada49462.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vA_6MuTFraxr-tErup3Y8A.jpeg"/></div></div></figure><p id="d2f2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">大家好！在本文中，我将讨论python中的缓存。我将主要谈论来自<code class="fe kz la lb lc b">functools</code>标准图书馆的<code class="fe kz la lb lc b">cached_property</code>和<code class="fe kz la lb lc b">lru_cache</code>装饰者。</p><h2 id="7ac2" class="ld le it bd lf lg lh dn li lj lk dp ll km lm ln lo kq lp lq lr ku ls lt lu lv bi translated">什么是缓存？</h2><p id="1239" class="pw-post-body-paragraph kb kc it kd b ke lw kg kh ki lx kk kl km ly ko kp kq lz ks kt ku ma kw kx ky im bi translated">缓存是将一些结果/数据存储到内存(非易失性:硬盘驱动器和SSD，或易失性:ram和CPU缓存)中的操作，以便在下次需要时快速检索它们(不需要重新计算结果)。</p><h2 id="1c81" class="ld le it bd lf lg lh dn li lj lk dp ll km lm ln lo kq lp lq lr ku ls lt lu lv bi translated">如何在python中使用？</h2><p id="a08e" class="pw-post-body-paragraph kb kc it kd b ke lw kg kh ki lx kk kl km ly ko kp kq lz ks kt ku ma kw kx ky im bi translated">假设您有下面这个简单的类，它包含了一个列表，并增加了对它执行总求和的能力:</p><pre class="mb mc md me gt mf lc mg mh aw mi bi"><span id="5a6b" class="ld le it lc b gy mj mk l ml mm">class advanced_list:<br/>    def __init__(self, vals_list):<br/>        self.values = vals_list</span><span id="7a44" class="ld le it lc b gy mn mk l ml mm">    def sum(self):<br/>        return sum(self.values)</span></pre><p id="d004" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以这样使用它:</p><pre class="mb mc md me gt mf lc mg mh aw mi bi"><span id="4701" class="ld le it lc b gy mj mk l ml mm">my_list = advanced_list([1] * 10000000) # a list of 10 million ones</span><span id="b129" class="ld le it lc b gy mn mk l ml mm">my_list.sum() # outputs: 10000000</span></pre><p id="f1ad" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">每次我们调用<code class="fe kz la lb lc b">my_list.sum()</code>，它都会遍历列表并计算总和。如果列表保持不变，这可能会很耗时，而且没有必要。</p><p id="699e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以这样解决它:</p><pre class="mb mc md me gt mf lc mg mh aw mi bi"><span id="e92d" class="ld le it lc b gy mj mk l ml mm">class advanced_list:<br/>    def __init__(self, vals_list):<br/>        self.values = vals_list<br/>        self._sum = None<br/>    <br/>    def sum(self):<br/>        if self._sum is None:<br/>            self._sum = sum(self.values)<br/>        <br/>        return self._sum</span></pre><p id="9248" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这样更好更快。我们只计算一次总和，存储，然后立即返回存储的值。然而，如果你有很多相似的方法(例如，均值、标准差、方差等等)，这将会很难维护。</p><p id="440a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">简单地说，我们可以使用<code class="fe kz la lb lc b">cached_property</code>装饰器来包装我们的方法，并确保与上面相同的功能，但是代码要干净得多。</p><p id="d545" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在python 3.8中，<code class="fe kz la lb lc b">cached_property</code>是<code class="fe kz la lb lc b">functools</code>标准库的一部分。但是，对于python 3以前的版本，您需要<code class="fe kz la lb lc b">pip install cached_property</code>。</p><p id="c610" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">下面是我们新代码的样子:</p><pre class="mb mc md me gt mf lc mg mh aw mi bi"><span id="6d65" class="ld le it lc b gy mj mk l ml mm">from functools import cached_property</span><span id="b68d" class="ld le it lc b gy mn mk l ml mm">class advanced_list:<br/>    def __init__(self, vals_list):<br/>        self.values = vals_list</span><span id="9146" class="ld le it lc b gy mn mk l ml mm">    @cached_property<br/>    def sum(self):<br/>        return sum(self.values)</span></pre><p id="52d7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这种情况下，我们保持了最初的实现，并且我们只在每个方法的顶部添加了装饰器。这里唯一的区别是调用方法。它变成了一个属性，这意味着您将它作为对象的典型属性来引用。</p><pre class="mb mc md me gt mf lc mg mh aw mi bi"><span id="f336" class="ld le it lc b gy mj mk l ml mm">my_list.sum   # instead of my_list.sum()</span></pre><p id="2ba3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，在我们结束之前，让我们做一些基本的基准测试:</p><pre class="mb mc md me gt mf lc mg mh aw mi bi"><span id="52f4" class="ld le it lc b gy mj mk l ml mm">from time import time</span><span id="971f" class="ld le it lc b gy mn mk l ml mm">my_list = advanced_list([1] * 10000000)<br/># First time<br/>start = time()<br/>my_list.sum<br/>end = time()<br/>print(f"{(end - start):.5f} second") # 0.03787 second</span><span id="b9bf" class="ld le it lc b gy mn mk l ml mm"># Second time<br/>start = time()<br/>my_list.sum<br/>end = time()<br/>print(f"{(end - start):.5f} second") # 0.00004 second</span></pre><p id="67b6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以看到，对于这样一个愚蠢的计算，我们能够节省大量的时间。这在测试和生产中都很有价值。在这种情况下，唯一的缺点是列表不能更改(至少不能显式更改)，如果发生这种情况，我们将不得不使该属性的缓存无效(清除它)(以便它重新计算总和)。简单地说，您可以像这样使它无效/清除它:</p><pre class="mb mc md me gt mf lc mg mh aw mi bi"><span id="9a74" class="ld le it lc b gy mj mk l ml mm">del my_list.sum</span></pre><p id="3381" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所以，现在我们有了一个想法，如何缓存这样简单的方法，并将其转换为属性(~attributes)。但是如果这个方法需要参数呢？</p><p id="8652" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">别担心，<code class="fe kz la lb lc b">functools</code>还有我们呢！我们可以从那里导入<code class="fe kz la lb lc b">lru_cache</code>装饰器，并在它们上面使用。让我们开始吧。</p><p id="1942" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">假设我们正在执行一项昂贵的计算(数据库读取、复杂的数学计算)，需要一段时间才能得到结果:</p><pre class="mb mc md me gt mf lc mg mh aw mi bi"><span id="cf85" class="ld le it lc b gy mj mk l ml mm">from time import sleep<br/>def get_value_from_db(row_id, table_name):<br/>    sleep(2) # pause for 2 seconds<br/>    return something</span><span id="b1da" class="ld le it lc b gy mn mk l ml mm">my_row = get_value_from_db(111, 'my_table')</span></pre><p id="c8a6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里，我们假设<code class="fe kz la lb lc b">sleep</code>使用行的id和表的名称从数据库(或API调用)中检索一行，这需要2秒钟。让我们也假设我们的数据库不经常改变。每次我们调用这个函数，至少需要2秒钟返回结果。这对于一个调用来说是没问题的，但是如果我们执行多个具有相同参数的调用，那么这将会非常缓慢和低效。</p><p id="8b92" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了缓解这一问题，我们采取了以下措施:</p><pre class="mb mc md me gt mf lc mg mh aw mi bi"><span id="d539" class="ld le it lc b gy mj mk l ml mm">from time import sleep<br/>from functools import lru_cache</span><span id="2fd9" class="ld le it lc b gy mn mk l ml mm">@lru_cache(max_size=100)<br/>def get_value_from_db(row_id, table_name):<br/>    sleep(2) # pause for 2 seconds<br/>    return something</span><span id="e8da" class="ld le it lc b gy mn mk l ml mm">my_row = get_value_from_db(111,'my_table')<br/>.<br/>.<br/>.<br/>my_row = get_value_from_db(111,'my_table') #this is going to be fast</span></pre><p id="e8f4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这种情况下，<code class="fe kz la lb lc b">lru_cache</code>所做的是存储多达100组不同的参数(例如，(111，' my_table ')，(222，' your_table ')，…)，并缓存它们的结果(假设它们总是返回相同的结果)。<code class="fe kz la lb lc b">lru</code>指“最近最少使用”的缓存替换策略。这意味着只要缓存满了，就删除最近最少使用的结果(或参数)。</p><p id="458c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">此外，我们可以通过以下调用来检查缓存:</p><pre class="mb mc md me gt mf lc mg mh aw mi bi"><span id="bf72" class="ld le it lc b gy mj mk l ml mm">get_value_from_db.cache_info()<br/>#output: CacheInfo(hits=3, misses=8, maxsize=100, currsize=8)</span></pre><p id="d894" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">A <strong class="kd iu"> hit </strong>是我们调用函数，在缓存中找到结果，a <strong class="kd iu"> miss </strong>则相反(我们在缓存中没有找到)，而<strong class="kd iu"> currsize </strong>是缓存结果的个数。</p><p id="38cd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">最后，如果我们想使缓存无效(清除它)，我们可以做<code class="fe kz la lb lc b">get_value_from_db.cache_clear()</code>，它释放缓存并重置计数器。</p><h2 id="c148" class="ld le it bd lf lg lh dn li lj lk dp ll km lm ln lo kq lp lq lr ku ls lt lu lv bi translated">重要注意事项:</h2><ul class=""><li id="feaf" class="mo mp it kd b ke lw ki lx km mq kq mr ku ms ky mt mu mv mw bi translated">在多线程中使用它们时，您需要更加小心。</li><li id="e188" class="mo mp it kd b ke mx ki my km mz kq na ku nb ky mt mu mv mw bi translated">使用的缓存介质是内存，而不是存储设备。</li><li id="4b4c" class="mo mp it kd b ke mx ki my km mz kq na ku nb ky mt mu mv mw bi translated">在使用它之前，确保你缓存的操作需要更多的时间来完成；否则开销不值得。</li><li id="81e7" class="mo mp it kd b ke mx ki my km mz kq na ku nb ky mt mu mv mw bi translated">此外，确保缓存结果没有坏处。如果你正在调用一个根据时间给出不同结果的API，不要缓存，或者确保在需要的时候使你的缓存失效。</li><li id="e48f" class="mo mp it kd b ke mx ki my km mz kq na ku nb ky mt mu mv mw bi translated">使用<code class="fe kz la lb lc b">lru_cache</code>，函数的参数应该是可散列的(例如，元组是可散列的，列表不是)。</li></ul><h2 id="4d9c" class="ld le it bd lf lg lh dn li lj lk dp ll km lm ln lo kq lp lq lr ku ls lt lu lv bi translated">进一步阅读</h2><ul class=""><li id="c00a" class="mo mp it kd b ke lw ki lx km mq kq mr ku ms ky mt mu mv mw bi translated"><a class="ae nc" href="https://en.wikipedia.org/wiki/Cache_(computing)" rel="noopener ugc nofollow" target="_blank">https://en . Wikipedia . org/wiki/Cache _(计算)</a></li><li id="3047" class="mo mp it kd b ke mx ki my km mz kq na ku nb ky mt mu mv mw bi translated"><a class="ae nc" href="https://docs.python.org/3/library/functools.html#functools.lru_cache" rel="noopener ugc nofollow" target="_blank">https://docs . python . org/3/library/func tools . html # func tools . LRU _ cache</a></li><li id="dc0f" class="mo mp it kd b ke mx ki my km mz kq na ku nb ky mt mu mv mw bi translated"><a class="ae nc" href="https://docs.python.org/dev/library/functools.html?highlight=s#functools.cached_property" rel="noopener ugc nofollow" target="_blank">https://docs.python.org/dev/library/functools.html?highlight = s # func tools . cached _ property</a></li><li id="d1ae" class="mo mp it kd b ke mx ki my km mz kq na ku nb ky mt mu mv mw bi translated"><a class="ae nc" href="https://github.com/pydanny/cached-property" rel="noopener ugc nofollow" target="_blank">https://github.com/pydanny/cached-property</a></li></ul></div></div>    
</body>
</html>