<html>
<head>
<title>gRPC: How to Make Effective Unary Calls</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">gRPC:如何进行有效的一元调用</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/grpc-how-to-make-effective-unary-calls-4c9fa68cd9d5?source=collection_archive---------9-----------------------#2021-01-19">https://levelup.gitconnected.com/grpc-how-to-make-effective-unary-calls-4c9fa68cd9d5?source=collection_archive---------9-----------------------#2021-01-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/fd07d9e71a8724fc939933ccb67a5005.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e14pZNXhdoxzpfEE2DpF-w.png"/></div></div></figure><p id="c3b2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在本文中，我将解释如何进行一元gRPC调用——实现客户机和服务器Go应用程序。</p><p id="b3d0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是该系列的第一篇文章:</p><ol class=""><li id="fd1f" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated">如何进行有效的一元调用</li><li id="b71f" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated"><a class="ae ln" rel="noopener ugc nofollow" target="_blank" href="/grpc-how-to-make-client-streaming-calls-5c731197585">如何进行客户端流媒体通话</a></li><li id="07d9" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated"><a class="ae ln" rel="noopener ugc nofollow" target="_blank" href="/grpc-how-to-make-server-streaming-calls-763b42895481">如何进行服务器流调用</a></li><li id="233c" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated"><a class="ae ln" rel="noopener ugc nofollow" target="_blank" href="/grpc-how-to-make-bi-directional-streaming-calls-70b4a0569b5b">如何进行双向流媒体通话</a></li></ol><p id="c709" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">首先，在开始实现之前，让我们定义一些核心概念。</p><h2 id="db81" class="lo lp it bd lq lr ls dn lt lu lv dp lw km lx ly lz kq ma mb mc ku md me mf mg bi translated">gRPC</h2><blockquote class="mh"><p id="69ec" class="mi mj it bd mk ml mm mn mo mp mq ky dk translated">代表<strong class="ak">远程过程调用，</strong>它是一个开源框架，由Google开发，旨在创建一个更快、更有效的协议来通过网络发送和接收数据。</p></blockquote><p id="656c" class="pw-post-body-paragraph kb kc it kd b ke mr kg kh ki ms kk kl km mt ko kp kq mu ks kt ku mv kw kx ky im bi translated">这是一个建立在HTTP/2之上的协议，它有一些方便的特性。这些包括从客户端和服务器端进行流调用的能力，或者双向流。它使用协议缓冲区序列化和反序列化数据，还通过gRPC编译器为当前11种不同的语言提供代码生成。</p><p id="5ff2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">gRPC 正变得越来越流行，因为它比REST有更多的优势。</p><h2 id="7620" class="lo lp it bd lq lr ls dn lt lu lv dp lw km lx ly lz kq ma mb mc ku md me mf mg bi translated">协议缓冲区</h2><blockquote class="mh"><p id="665c" class="mi mj it bd mk ml mm mn mo mp mq ky dk translated">这是一种序列化数据的方法，可以通过网络传输或存储在文件中。</p></blockquote><p id="4450" class="pw-post-body-paragraph kb kc it kd b ke mr kg kh ki ms kk kl km mt ko kp kq mu ks kt ku mv kw kx ky im bi translated">协议缓冲区使数据的序列化和反序列化比JSON格式更快。<a class="ae ln" href="https://developers.google.com/protocol-buffers/docs/overview" rel="noopener ugc nofollow" target="_blank">协议缓冲区</a>比JSON更快的原因是它专注于将数据转换为二进制格式并压缩，允许使用更少的空间和CPU内存传输数据。它使用。原型文件来编写每个消息和服务请求的定义。使用协议缓冲区序列化数据的缺点是它不是人类可读的。</p><h2 id="e649" class="lo lp it bd lq lr ls dn lt lu lv dp lw km lx ly lz kq ma mb mc ku md me mf mg bi translated">一元gRPC调用</h2><p id="b8ae" class="pw-post-body-paragraph kb kc it kd b ke mw kg kh ki mx kk kl km my ko kp kq mz ks kt ku na kw kx ky im bi translated">在一元rpc调用中，客户端发送一个请求，服务器用一条消息响应。</p><figure class="nc nd ne nf gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nb"><img src="../Images/f92bcd1ebf8c73a7083ce757243f532b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1_-UZ0WlVd5-LSZzD02IpA.png"/></div></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">一元请求</figcaption></figure><h2 id="b6a8" class="lo lp it bd lq lr ls dn lt lu lv dp lw km lx ly lz kq ma mb mc ku md me mf mg bi translated">项目描述</h2><p id="45e9" class="pw-post-body-paragraph kb kc it kd b ke mw kg kh ki mx kk kl km my ko kp kq mz ks kt ku na kw kx ky im bi translated">对于这个例子，客户机将发送一个请求来获取所有用户。rpc调用将允许客户端在请求消息中发送一个过滤器，根据用户的当前状态检索用户。</p><p id="5a44" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们首先创建一个新文件夹，并将其命名为grpc_calls。在整个系列中，我们将在这个文件夹下工作。</p><p id="1c67" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这个文件夹中创建以下结构。</p><figure class="nc nd ne nf gt ju gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/53c78d8ca4e97594262db3931529ce32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1372/format:webp/1*cMYsp952nF-mGwVSpuYyfQ.png"/></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">gRPC一元文件夹结构</figcaption></figure><p id="02f7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">users.proto文件的定义如下:</p><figure class="nc nd ne nf gt ju"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="9dd2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这个文件中，我为这个请求定义了服务用户、端点和相应的消息。</p><p id="c2cd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">正如您所看到的，端点允许客户端在请求消息中发送状态，这样它就可以过滤结果。我还为状态使用了一个enum，只接受特定的用户状态。如果没有设置，或者客户端发送了一个无效的，那么它将被默认设置为unknown。</p><p id="fa82" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在我们可以为这个原型文件生成go代码了。</p><p id="5cff" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">要从这个文件生成代码，你必须安装protoc compiler，如果你还没有安装它，查看这个<a class="ae ln" href="https://developers.google.com/protocol-buffers/docs/reference/go-generated" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><p id="1c6e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在proto文件夹中运行以下命令:</p><pre class="nc nd ne nf gt nn no np nq aw nr bi"><span id="78ed" class="lo lp it no b gy ns nt l nu nv">protoc --go_out=. --go_opt=paths=source_relative --go-grpc_out=. --go-grpc_opt=paths=source_relative users.proto</span></pre><p id="dbf6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个命令将在proto文件夹中创建两个文件。这些文件包含我们实现服务器和客户端所需的go代码。不要编辑这些文件，否则您的代码无法按预期运行。</p><p id="9889" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们继续实现服务器。</p><p id="c1e1" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">以下是server go应用程序的代码:</p><figure class="nc nd ne nf gt ju"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="85ee" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于服务器文件，我们首先创建一个新的grpc服务器，它将监听端口3000，然后我们注册用户服务并开始监听连接。</p><p id="0b62" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，如你所见，我正在导入一元包。因为有本地进口的Go会投诉。</p><p id="c576" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">要解决这个问题，您可以执行以下操作:</strong></p><ol class=""><li id="cd45" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated">将proto文件夹的内容推送到github，然后从那里导入。</li><li id="653d" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">将proto文件夹的内容放在<strong class="kd iu">包/src </strong>文件夹中，作为go版本路径。在我的情况下，这是路径:</li></ol><pre class="nc nd ne nf gt nn no np nq aw nr bi"><span id="696f" class="lo lp it no b gy ns nt l nu nv">golang/1.15.5/packages/src</span></pre><p id="939c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这个文件夹中，我创建了一个proto_unary文件夹，并粘贴了包含生成的代码和users.proto文件的proto文件夹中的文件。</p><p id="2955" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这样我就可以导入这个包，而不用把它推到Github。采取你认为更方便的方法。</p><p id="e8de" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在GetUsers函数中，我们根据在请求消息中获得的状态来过滤用户。除此之外，我们使用两个额外的函数getUserList来加载一些虚拟数据，因为我们没有使用真正的数据库，以及filterBy来过滤用户列表。</p><p id="2c4c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这是进行一元rpc调用的所有必要逻辑。服务器只是接收请求，处理一些数据，并向客户端返回一个响应消息。</p><p id="fdff" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们实现客户端代码。</p><figure class="nc nd ne nf gt ju"><div class="bz fp l di"><div class="nl nm l"/></div></figure><p id="01b7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对于客户机代码，我们在端口3000上创建一个新的客户机服务器，使用用户包提供的<strong class="kd iu"> NewUsersClient </strong>方法。然后getUsers函数向服务器发送一个请求，在请求消息中提供用户状态。最后，我们从服务器打印结果。</p><p id="2d17" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这就是我们用服务器和客户端go应用程序建立一元gRPC调用所要做的全部工作。如您所见，一元调用的语法非常简单。我们只需在users.proto文件中声明一个rpc端点，然后生成代码并从服务器端和客户端实现该方法。</p><p id="3b69" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我们进入控制台，在服务器文件夹中，我们可以运行以下命令来启动服务器。</p><pre class="nc nd ne nf gt nn no np nq aw nr bi"><span id="edc8" class="lo lp it no b gy ns nt l nu nv">go run .</span></pre><figure class="nc nd ne nf gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nw"><img src="../Images/b2bc6b16154b65117f05c8e2b1fcf509.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5EtWb1S-JzdORiewITXWmw.png"/></div></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">服务器Go应用程序日志</figcaption></figure><p id="ab2e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">然后使用相同的命令启动客户端，但是在客户端文件夹下，如果一切设置正确，您应该会看到预期的结果。</p><figure class="nc nd ne nf gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nx"><img src="../Images/9a99035460cb5df3790a4b658f0e9f46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bSx7DTnVRkNdjU0nQvl6Eg.png"/></div></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated">客户端Go应用程序日志</figcaption></figure><p id="3ada" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">希望你觉得有用，学到新东西。如果你有任何问题或想法，请在下面留下评论。在下一篇文章中，我们将处理带有客户端流请求的gRPC调用。</p><p id="2c1f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">感谢您的阅读！！</p><h2 id="3fb7" class="lo lp it bd lq lr ls dn lt lu lv dp lw km lx ly lz kq ma mb mc ku md me mf mg bi translated">参考</h2><div class="ny nz gp gr oa ob"><a href="https://grpc.io/" rel="noopener  ugc nofollow" target="_blank"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd iu gy z fp og fr fs oh fu fw is bi translated">gRPC</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">gRPC是一个现代的开源高性能RPC框架，可以在任何环境中运行。它可以高效地连接…</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">grpc.io</p></div></div><div class="ok l"><div class="ol l om on oo ok op jz ob"/></div></div></a></div><div class="ny nz gp gr oa ob"><a href="https://developers.google.com/protocol-buffers/docs/overview" rel="noopener  ugc nofollow" target="_blank"><div class="oc ab fo"><div class="od ab oe cl cj of"><h2 class="bd iu gy z fp og fr fs oh fu fw is bi translated">语言指南|协议缓冲区| Google开发者</h2><div class="oi l"><h3 class="bd b gy z fp og fr fs oh fu fw dk translated">本指南描述了如何使用协议缓冲区语言来构建您的协议缓冲区数据，包括。原型…</h3></div><div class="oj l"><p class="bd b dl z fp og fr fs oh fu fw dk translated">developers.google.com</p></div></div><div class="ok l"><div class="oq l om on oo ok op jz ob"/></div></div></a></div></div></div>    
</body>
</html>