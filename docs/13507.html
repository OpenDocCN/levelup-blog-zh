<html>
<head>
<title>Consistent Hashing in Action</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">行动中的一致散列</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/consistent-hashing-in-action-e9637114f0d1?source=collection_archive---------0-----------------------#2022-09-11">https://levelup.gitconnected.com/consistent-hashing-in-action-e9637114f0d1?source=collection_archive---------0-----------------------#2022-09-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/8bb9758c2b9700e5a1daaf220b6c1a84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AT6kyQpqAyOV5-txCiVmAQ.jpeg"/></div></div></figure><p id="71e1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在分布式系统中使用一致散列来保持散列表独立于可用服务器的数量，以在规模发生变化时最小化键的重新定位。</p><p id="a57c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">本文解释了一致散列，它是什么，以及为什么它是可伸缩分布式系统中的一个重要工具。</p><h1 id="e098" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">哈希是什么？</h1><p id="8ebe" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">哈希是将一段数据(任意大小的对象)映射到另一段固定大小的数据(整数)的过程，称为<em class="lz">哈希代码</em>或简称为<em class="lz">哈希</em>。用于将对象映射到哈希代码的函数被称为<em class="lz">哈希函数</em>。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div class="gh gi ma"><img src="../Images/a7c9ef744e1b12370dfc4e7c6f6099ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1222/format:webp/1*weEWGo72a-zjyZz2m7a7Xg.png"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">散列的例子</figcaption></figure><h1 id="6be8" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">分布式系统中的散列</h1><p id="fd81" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">在各种程序、计算机或用户从多个服务器节点请求资源的场景中，我们需要一种机制来将请求均匀地映射到可用的服务器节点，从而确保负载平衡以获得一致的性能。</p><p id="4c11" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">假设三台服务器分别是A、B和C，每台服务器都有相同数量的密钥。如果我们需要存储一个新的密钥，我们可以做同样的事情，根据<strong class="ka ir"> <em class="lz"> server = f(x)% 3 </em> </strong>的输出，将它存储在其中一个服务器中。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mj"><img src="../Images/471aac26e431996e3e1b5d3794b0057f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TJC3rGITCwrj5M8VbmsCqA.png"/></div></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">将对象分发到3个可用的服务器</figcaption></figure><h1 id="89de" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">重散列</h1><p id="7532" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">集群的规模不断扩大和缩小是很常见的，而且在分布式系统中总是会出现意想不到的故障。我们不能保证服务器节点的数量保持不变。如果其中一个失败了呢？使用简单的散列方法，我们需要重新散列每个键，因为新的映射依赖于节点和内存位置的数量。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mk"><img src="../Images/18483934a7b3cd0c88430da976918359.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CUYvEyK5FTtqt9FBejV7YQ.png"/></div></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">重新散列以匹配可用的服务器会影响所有的键。</figcaption></figure><p id="fef4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">具有简单再散列的分布式系统中的问题是状态存储在每个节点上。</p><blockquote class="ml mm mn"><p id="2f19" class="jy jz lz ka b kb kc kd ke kf kg kh ki mo kk kl km mp ko kp kq mq ks kt ku kv ij bi translated"><strong class="ka ir"> <em class="iq">簇大小的微小变化可能导致簇中所有数据的重新排列</em> </strong>。随着集群大小的增长，这变得不可持续，因为每次散列变化所需的工作量随着集群大小线性增长。</p></blockquote><p id="ccc2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就是<strong class="ka ir"> <em class="lz">一致散列</em> </strong>概念的由来。</p><h1 id="ea08" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">什么是一致性哈希？</h1><p id="3367" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">一致散列是一种分布式散列方案，通过在抽象圆或<strong class="ka ir"> <em class="lz">散列环</em> </strong>上给它们分配一个位置，独立于分布式散列表中的服务器或对象的数量进行操作。这允许服务器和对象在不影响整个系统的情况下进行扩展。</p><p id="90d8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">假设我们将哈希代码范围映射到一个圆的边缘。这意味着最小可能的散列码将对应于零度角，最大可能的散列码将对应于2𝝅弧度角(或360度)，并且所有其他散列值将线性地适合于两者之间的某个位置。所以，我们可以用一个键，计算它的散列，找出它在圆边上的位置。</p><p id="3739" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，我们可以在3台服务器之间映射上述数据，如下所示:</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mr"><img src="../Images/b657f03cde2b6516857cc3627ec74f54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3Wg4HdsAaxKAgyCIXWgr4g.png"/></div></div></figure><h1 id="1aa1" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">添加或删除服务器时会发生什么？</h1><p id="0ab3" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">一致散列的主要好处是可以动态地添加或删除任何服务器，并且只需要移动最小的对象集。</p><p id="30af" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">平均来说，它只需要移动<strong class="ka ir"> <em class="lz"> k/n </em> </strong>个对象，其中<em class="lz"> k </em>是键的总数，<em class="lz"> n </em>是节点的总数。</p><blockquote class="ml mm mn"><p id="f223" class="jy jz lz ka b kb kc kd ke kf kg kh ki mo kk kl km mp ko kp kq mq ks kt ku kv ij bi translated">这个属性被称为<strong class="ka ir"> <em class="iq">单调性</em> </strong>:当增加一个服务器时，对象只从旧服务器移动到新服务器；旧服务器之间没有不必要的移动<em class="iq">。</em></p></blockquote><ul class=""><li id="5dba" class="ms mt iq ka b kb kc kf kg kj mu kn mv kr mw kv mx my mz na bi translated"><strong class="ka ir">扩展过程:</strong>当一个新的服务器被添加到集群中时，服务器散列被计算并被放置在散列环上。键被重新分配以重新分配负载，但是正如我们所看到的，只有最小数量的键被重新分配:</li></ul><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nb"><img src="../Images/af62e65f19ec3a7a339c3e5193918d90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F6qftiUOMbB1WQ-cKWb-0w.png"/></div></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">Mike和Lucy现在从服务器C移动到新的服务器D</figcaption></figure><p id="b3ec" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面的gif描述了在集群扩大的情况下密钥移动的过程:</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/00f65f66b19439e2d2f5f2f2cae87cb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:896/1*erbf8hCC8LvecTAExBb32Q.gif"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">当集群向上扩展时，一些密钥被重新分配给新的服务器。</figcaption></figure><ul class=""><li id="eb5a" class="ms mt iq ka b kb kc kf kg kj mu kn mv kr mw kv mx my mz na bi translated"><strong class="ka ir">规模缩小或节点故障:</strong>当服务器/节点发生故障时，只有属于该节点的密钥将被重新分配到哈希环上最近的可用服务器，而不会影响其他密钥/对象:</li></ul><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nd"><img src="../Images/959cd5b610f3f1bb02f87d774bec35f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cEmeDWKBDcM19d-zmBrDjw.png"/></div></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">由于服务器D被移除，Mike和Lucy现在被重新分配到服务器c。</figcaption></figure><p id="45d2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面的gif描述了在集群缩小的情况下键移动的过程:</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/56ec8bd3d84ab1164ad6c42ce2da562e.png" data-original-src="https://miro.medium.com/v2/resize:fit:880/1*AYIyQDLuGU0ZFV6TptKH7A.gif"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">当一个节点关闭时，密钥被重新分配给最近的可用服务器。</figcaption></figure><h1 id="39ed" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated"><strong class="ak">在服务器间平均分配密钥</strong></h1><p id="92b1" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">在理想情况下，当有<strong class="ka ir"> <em class="lz"> k </em> </strong>个密钥和<strong class="ka ir"> n </strong>个服务器时，每个服务器必须有接近<strong class="ka ir"> <em class="lz"> k/n </em> </strong>个密钥。因此，添加或删除一个节点最多可以影响系统中的<strong class="ka ir"> <em class="lz"> k/n </em> </strong>个键。为了确保接近理想分布，我们在系统中引入了<strong class="ka ir"> <em class="lz">虚拟节点</em> </strong>。每个物理节点在哈希环上都有多个虚拟节点。</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/ac9efec2d5a3dfcaa8d3b29a7ca261eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:870/format:webp/1*EmHg3hqhXLZ_JXVVVFzklQ.png"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk translated">每个服务器有多个虚拟节点，以便在可用的服务器之间平均分配密钥。</figcaption></figure><h1 id="b400" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">结论</h1><p id="3a20" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">一致散列有几个广泛的应用。它用于分片、负载平衡等。它支持横向可伸缩性。它最大限度地减少了动态环境中的中断。</p><p id="632c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它在Amazon的Dynamo DB中用作分区组件。此外，Apache Cassandra和Voldermort等开源应用程序使用它进行数据分区。</p><h1 id="1c1d" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">参考</h1><ul class=""><li id="f072" class="ms mt iq ka b kb lu kf lv kj ng kn nh kr ni kv mx my mz na bi translated"><a class="ae nj" href="https://github.com/papers-we-love/papers-we-love/blob/master/distributed_systems/consistent-hashing-and-random-trees.pdf" rel="noopener ugc nofollow" target="_blank">一致散列和随机树白皮书</a></li><li id="38ce" class="ms mt iq ka b kb nk kf nl kj nm kn nn kr no kv mx my mz na bi translated"><a class="ae nj" href="https://www.toptal.com/big-data/consistent-hashing" rel="noopener ugc nofollow" target="_blank">一致性哈希指南</a></li><li id="7cce" class="ms mt iq ka b kb nk kf nl kj nm kn nn kr no kv mx my mz na bi translated"><a class="ae nj" href="https://ably.com/blog/implementing-efficient-consistent-hashing" rel="noopener ugc nofollow" target="_blank">一致的哈希解释</a></li></ul></div></div>    
</body>
</html>