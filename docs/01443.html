<html>
<head>
<title>Using Angular @ViewChild to implement multiple visualizations of data sets</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Angular @ViewChild实现数据集的多种可视化</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/using-angular-viewchild-to-implement-multiple-visualizations-of-data-sets-b626689938f7?source=collection_archive---------0-----------------------#2020-01-02">https://levelup.gitconnected.com/using-angular-viewchild-to-implement-multiple-visualizations-of-data-sets-b626689938f7?source=collection_archive---------0-----------------------#2020-01-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="6a62" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有时，数据的单一表示是不够的。</p><p id="c337" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果我们以一个音乐库应用程序为例，人们会希望以列表形式或专辑封面图片的漂亮列表来查看音乐收藏，同时保持UI的其余部分不变。两者都使用相同的底层数据集，理想情况下，表示方式的改变不需要每次都从服务器重新加载数据。</p><p id="becd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在Angular中，<code class="fe ko kp kq kr b">@ViewChild</code>可以用来实现这个场景，在这篇文章中，我们将开发一个例子，用户可以在数据的多种不同表示之间切换，就像这样:</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi ks"><img src="../Images/d4fc39bb924d0966b6389cb39c7966fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t0wKn-3WCBqIduQo9kGP8Q.jpeg"/></div></div><figcaption class="le lf gj gh gi lg lh bd b be z dk translated">显示相同数据集的两种选择。</figcaption></figure><h1 id="3acc" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">整体角形建筑</h1><p id="bc56" class="pw-post-body-paragraph jq jr it js b jt mg jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn im bi translated">为了保持整洁，我们将在<code class="fe ko kp kq kr b">AlbumListComponent</code>的文件夹<code class="fe ko kp kq kr b">album-list</code>下的目录中组织不同列表表示的组件和视图。这是最终文件夹结构的图像，显示了我们将在此示例中创建和使用的所有文件:</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/74be21df8ebb0d68af6c05e6c3e43c70.png" data-original-src="https://miro.medium.com/v2/resize:fit:826/format:webp/1*jRsouxD2TFddjuAdlQmj2w.png"/></div><figcaption class="le lf gj gh gi lg lh bd b be z dk translated">此实现中使用的文件夹结构。</figcaption></figure><p id="83bf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">代码结构已经设置好，因此<code class="fe ko kp kq kr b">AlbumListComponent</code>将负责加载数据，并为页面和UI提供入口点，除了这里没有呈现的实际列表。</p><p id="36be" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">视图切换的逻辑将由<code class="fe ko kp kq kr b">BaseListComponent</code>完成，它将完成用户选择的视图之间的渲染和切换，并将任何数据传递给它们。</p><p id="f2df" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用两个独立的组件巧妙地将页面在<code class="fe ko kp kq kr b">AlbumListComponent</code>中的表示与位于<code class="fe ko kp kq kr b">BaseListComponent</code>中管理不同的、选定的视图的呈现的业务逻辑分开。接下来，我们将在专门的列表呈现组件中创建列表呈现的实际实现，如下图所示的<code class="fe ko kp kq kr b">NumberedListComponent</code>和<code class="fe ko kp kq kr b">CoverListComponent</code>。</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi mm"><img src="../Images/dacc8a3ae3b3921f7a4bb0287151e7b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7-VX0w5FwyXBSsje12aTsA.jpeg"/></div></div><figcaption class="le lf gj gh gi lg lh bd b be z dk translated">前面屏幕截图中显示的各个组件之间的关系。</figcaption></figure><p id="1b4f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们从最外面的<code class="fe ko kp kq kr b">album-list.component.html</code>模板开始。</p><h1 id="e4e4" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">步骤1:数据检索和UI设置</h1><p id="8098" class="pw-post-body-paragraph jq jr it js b jt mg jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn im bi translated">下面是我们在相册列表页面上使用的HTML，允许用户在相册列表的不同表示之间切换。</p><pre class="kt ku kv kw gt mn kr mo mp aw mq bi"><span id="de90" class="mr lj it kr b gy ms mt l mu mv">&lt;div class="albumlist-container"&gt;<br/>  &lt;div class="format-selector"&gt;<br/>    &lt;button type="button"<br/>       (click)="onChangeAlbumDisplayClick('list')"&gt;List&lt;/button&gt;<br/>    &lt;button type="button"<br/>       (click)="onChangeAlbumDisplayClick('covers')"&gt;Covers&lt;/button&gt;<br/>  &lt;/div&gt;<br/>&lt;/div&gt;</span></pre><p id="3274" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这里，我们使用组件的<code class="fe ko kp kq kr b">onChangeAlbumDisplayClick()</code>函数，它将改变对象属性，决定哪个列表视图将被呈现。组件对应的Typescript代码看起来是这样的(不包括<code class="fe ko kp kq kr b">@Component</code>装饰器):</p><pre class="kt ku kv kw gt mn kr mo mp aw mq bi"><span id="4b27" class="mr lj it kr b gy ms mt l mu mv">export class AlbumListComponent {</span><span id="1166" class="mr lj it kr b gy mw mt l mu mv">  public currentStyle = 'covers';<br/>  public albumList: Album[] = [];</span><span id="d835" class="mr lj it kr b gy mw mt l mu mv">  public onChangeAlbumDisplayClick($event) {<br/>    this.currentStyle = $event;<br/>  }<br/>}</span></pre><p id="3a3a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正如我们所看到的，该组件有两个属性，<code class="fe ko kp kq kr b">currentStyle</code>和<code class="fe ko kp kq kr b">albumList</code>，用于存储相册列表和显示它们的风格。两者都将传递给一个孩子<code class="fe ko kp kq kr b">BaseListComponent</code>我们很快将开发。</p><p id="5123" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">基本的UI已经准备好了，所以我们可以将<code class="fe ko kp kq kr b">BaseListComponent</code>嵌入到模板中，并传递两个数据属性，这样逻辑就可以对任何变化做出反应。有了这个添加，<code class="fe ko kp kq kr b">album-list.component.html</code>看起来像这样:</p><pre class="kt ku kv kw gt mn kr mo mp aw mq bi"><span id="ac8a" class="mr lj it kr b gy ms mt l mu mv">&lt;div class="albumlist-container"&gt;<br/>  &lt;div class="format-selector"&gt;<br/>    &lt;button type="button"<br/>      (click)="onChangeAlbumDisplayClick('list')"&gt;List&lt;/button&gt;<br/>    &lt;button type="button"<br/>      (click)="onChangeAlbumDisplayClick('covers')"&gt;Covers&lt;/button&gt;<br/>    &lt;/div&gt;<br/>    &lt;div&gt;<br/>        &lt;base-list [showContentStyle]="currentStyle" <br/>                   [albumList]="albumList"&gt;&lt;/base-list&gt;<br/>    &lt;/div&gt;<br/>&lt;/div&gt;</span></pre><p id="e94a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们看到，在模板中，我们为<code class="fe ko kp kq kr b">BaseListComponent</code>添加了一个标签<code class="fe ko kp kq kr b">&lt;base-list/&gt;</code>。该组件将编排列表的实际显示组件的呈现，并包含动态交换数据的视图组件的代码。</p><p id="6ad5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">下面是<code class="fe ko kp kq kr b">AlbumListComponent</code>类的代码(同样没有<code class="fe ko kp kq kr b">@Component</code>装饰器)</p><pre class="kt ku kv kw gt mn kr mo mp aw mq bi"><span id="fae2" class="mr lj it kr b gy ms mt l mu mv">export class AlbumListComponent implements OnInit {</span><span id="0043" class="mr lj it kr b gy mw mt l mu mv">  // The two properties, which are passed to BaseListComponent via property binding <br/>  public currentStyle = 'covers';<br/>  public albumList: Album[] = [];</span><span id="15c9" class="mr lj it kr b gy mw mt l mu mv">  constructor(private albumService: AlbumService) { }</span><span id="5a65" class="mr lj it kr b gy mw mt l mu mv">  // Loading the album data from the server<br/>  ngOnInit() {<br/>    this.albumService.getAllAlbums()<br/>      .subscribe(<br/>        (albumList: Album[]) =&gt; this.albumList = albumList;<br/>      );<br/>  }</span><span id="7221" class="mr lj it kr b gy mw mt l mu mv">  public onChangeAlbumDisplayClick($event) {<br/>    this.currentStyle = $event;<br/>  }<br/>}</span></pre><p id="a9af" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所添加的只是通过<code class="fe ko kp kq kr b">AlbumService</code>对服务器的调用以及将检索到的数据存储在<code class="fe ko kp kq kr b">albumList</code>属性中。出于这个例子的目的，我将跳过API调用中的错误处理。</p><h1 id="01f7" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">步骤2:列出组件和视图切换</h1><p id="01b6" class="pw-post-body-paragraph jq jr it js b jt mg jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn im bi translated">到目前为止，我们所做的工作就是创建一个UI，允许用户加载和选择如何显示数据。在我们开始创建以不同方式呈现数据的组件之前，我们将看一下<code class="fe ko kp kq kr b">BaseListComponent</code>,它将使所选视图组件的动态呈现发生。</p><p id="cd29" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，让我们创建组件，并将其与从<code class="fe ko kp kq kr b">AlbumListComponent</code>接收的输入连接起来:</p><pre class="kt ku kv kw gt mn kr mo mp aw mq bi"><span id="59b2" class="mr lj it kr b gy ms mt l mu mv">@Component({<br/>  selector: 'base-list',<br/>  templateUrl: './base-list.component.html',<br/>})<br/>export class BaseListComponent implements OnInit {</span><span id="3a7b" class="mr lj it kr b gy mw mt l mu mv">  @Input() showContentStyle: string;<br/>  @Input() albumList: Album[] = [];</span><span id="45dd" class="mr lj it kr b gy mw mt l mu mv">  private contentStyles = {<br/>    list: NumberedListComponent,<br/>    covers: CoverListComponent,<br/>  };</span><span id="c37b" class="mr lj it kr b gy mw mt l mu mv">  ngOnInit() {<br/>    this.showContentStyle = 'covers';<br/>    this.instantiateViewComponent(this.showContentStyle);<br/>  }</span><span id="ef40" class="mr lj it kr b gy mw mt l mu mv">  private instantiateViewComponent(componentName: string) {}<br/>}</span></pre><p id="e965" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们看到开头的两行<code class="fe ko kp kq kr b">@Input()</code>允许组件接受<code class="fe ko kp kq kr b">AlbumListComponent</code>的属性绑定。在<code class="fe ko kp kq kr b">@Input()</code>之后，我们定义<code class="fe ko kp kq kr b">contentStyles</code>，从标识组件的字符串(“list”或“covers”)到稍后呈现的相应组件类的映射。</p><p id="24a8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个设置之后是<code class="fe ko kp kq kr b">ngOnInit()</code>函数，它设置默认视图并调用一个方法，该方法将呈现所选组件并将其插入到<code class="fe ko kp kq kr b">BaseListComponent</code>的模板中。该组件的模板非常简短，只包含一个带有标识符的<code class="fe ko kp kq kr b">&lt;div /&gt;</code>元素，稍后我们将使用该标识符在模板的该位置插入呈现的组件(<code class="fe ko kp kq kr b">#albumListStyle</code>):</p><pre class="kt ku kv kw gt mn kr mo mp aw mq bi"><span id="c690" class="mr lj it kr b gy ms mt l mu mv">&lt;div&gt;<br/>  &lt;div #albumListStyle&gt;&lt;/div&gt;<br/>&lt;/div&gt;</span></pre><p id="9971" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有了这个基本的设置，我们就可以处理实现的核心了，即<code class="fe ko kp kq kr b">instantiateViewComponent()</code>方法接收标识要实例化的组件的字符串。该方法需要完成以下任务:</p><ol class=""><li id="f5f5" class="mx my it js b jt ju jx jy kb mz kf na kj nb kn nc nd ne nf bi translated">识别对应于给定字符串标识符的正确组件类。</li><li id="95af" class="mx my it js b jt ng jx nh kb ni kf nj kj nk kn nc nd ne nf bi translated">创建该组件的实例。</li><li id="0b4b" class="mx my it js b jt ng jx nh kb ni kf nj kj nk kn nc nd ne nf bi translated">将呈现所需的任何数据传递到新实例化的组件中。</li><li id="c807" class="mx my it js b jt ng jx nh kb ni kf nj kj nk kn nc nd ne nf bi translated">将渲染的组件放入父模板中。</li></ol><p id="15cd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以下代码完成这些任务:</p><pre class="kt ku kv kw gt mn kr mo mp aw mq bi"><span id="97ee" class="mr lj it kr b gy ms mt l mu mv">@ViewChild('albumListStyle', {read: ViewContainerRef, static: true})<br/>  albumListContainer: ViewContainerRef;</span><span id="78ee" class="mr lj it kr b gy mw mt l mu mv">  constructor(<br/>    private factoryResolver: ComponentFactoryResolver,<br/>  ) { }</span><span id="6448" class="mr lj it kr b gy mw mt l mu mv">  private componentReference: ComponentRef&lt;{}&gt;;</span><span id="1deb" class="mr lj it kr b gy mw mt l mu mv">  private instantiateViewComponent(componentName: string) {<br/>    const componentType = this.provideListComponent(componentName);<br/>    const factoryInstance =<br/>        this.factoryResolver.resolveComponentFactory(componentType);<br/>    this.componentReference =<br/>        this.albumListContainer.createComponent(factoryInstance);</span><span id="f2c2" class="mr lj it kr b gy mw mt l mu mv">    const inst = this.componentReference.instance as AbstractList;<br/>    inst.albumListToRender = this.albumList;<br/>  }</span><span id="4538" class="mr lj it kr b gy mw mt l mu mv">  private provideListComponent(componentStyle: string) {<br/>    return this.contentStyles[componentStyle] ||<br/>           this.contentStyles.list;<br/>  }<br/>}</span></pre><p id="51ce" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在前两行中，<code class="fe ko kp kq kr b">@ViewChild</code> decorator使用<code class="fe ko kp kq kr b">#albumListStyle</code>注释创建了对该组件模板中HTML元素的引用，并将该引用存储在<code class="fe ko kp kq kr b">albumListContainer</code>属性中。</p><p id="1012" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在第11行中，<code class="fe ko kp kq kr b">provideListComponent()</code>方法用于标识并返回对与所提供的字符串标识符<code class="fe ko kp kq kr b">componentName</code>相关联的组件类的引用，或者返回默认值。第12行和第13行检索所选组件的工厂，并从中实例化组件。注意在第9行，我们如何通过<code class="fe ko kp kq kr b">albumListContainer</code>属性引用ViewChild来创建和注入组件。对新实例化组件的引用保存在<code class="fe ko kp kq kr b">componentReference</code>对象属性中，这样我们可以做两件事:</p><ol class=""><li id="6607" class="mx my it js b jt ju jx jy kb mz kf na kj nb kn nc nd ne nf bi translated">将数据传递到组件中进行呈现</li><li id="89fa" class="mx my it js b jt ng jx nh kb ni kf nj kj nk kn nc nd ne nf bi translated">稍后，当用户选择另一个数据视图进行显示时，销毁该组件。如果我们不破坏组件实例，我们将在视图的每个“开关”上添加一个新的对象实例。</li></ol><p id="43a0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了将任何数据传递给子组件，我们获取对类实例的引用，并将加载的数据提供给呈现组件，如第11行和第12行所示。我们还没有看到组件进行实际的渲染，但是我们可以从这段代码中做出有根据的猜测，它们拥有一个<code class="fe ko kp kq kr b">albumListToRender</code>属性。在我们进入组件进行实际渲染之前，让我们再次看看我们的概览图，看看我们到目前为止已经完成了什么:</p><ol class=""><li id="7b26" class="mx my it js b jt ju jx jy kb mz kf na kj nb kn nc nd ne nf bi translated">我们已经建立了一个组件，它构成了我们实现的基础，即<code class="fe ko kp kq kr b">AlbumListComponent</code>。它的主要任务是设置页面，从服务器加载数据，并提供UI来更改整个页面的数据视图和样式。</li><li id="2cf3" class="mx my it js b jt ng jx nh kb ni kf nj kj nk kn nc nd ne nf bi translated">作为其子组件，我们实现了<code class="fe ko kp kq kr b">BaseListComponent</code>，它通过实例化子组件并将数据传递给子组件来处理信息的选定视图的切换。</li></ol><h1 id="ee9c" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">步骤3:实现列表视图</h1><p id="4fd3" class="pw-post-body-paragraph jq jr it js b jt mg jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn im bi translated">在上一节中我们看到，我们将数据传递给负责列表呈现的组件。在最后一个清单的第15行，您可能已经注意到了对一个<code class="fe ko kp kq kr b">AbstractList</code>的引用。这个(抽象)类是所有负责呈现列表的组件的基础。它提供了一个通用的数据参考，如下所示:</p><pre class="kt ku kv kw gt mn kr mo mp aw mq bi"><span id="d8be" class="mr lj it kr b gy ms mt l mu mv">export abstract class AbstractList {<br/>  public albumListToRender: Album[];<br/>}</span></pre><p id="3828" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">对于一个列表的实际实现，我们看一下以带有专辑封面、艺术家和专辑名称的卡片网格形式呈现专辑的组件。Typescript类非常简单:</p><pre class="kt ku kv kw gt mn kr mo mp aw mq bi"><span id="d49c" class="mr lj it kr b gy ms mt l mu mv">@Component({<br/>  selector: 'app-cover-list',<br/>  templateUrl: './cover-list.component.html',<br/>  styleUrls: ['./cover-list.component.css']<br/>})<br/>export class CoverListComponent extends AbstractList {<br/>  constructor() {<br/>    super();<br/>  }<br/>}</span></pre><p id="9c23" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它在其构造函数方法中扩展并实例化了<code class="fe ko kp kq kr b">AbstractList</code>类，从而获得了对<code class="fe ko kp kq kr b">albumListToRender</code>属性的访问。相应的模板是直接的角度模板:</p><pre class="kt ku kv kw gt mn kr mo mp aw mq bi"><span id="1452" class="mr lj it kr b gy ms mt l mu mv">&lt;div&gt;<br/>  &lt;div *ngFor="let album of albumListToRender" <br/>       class="albumcard-container"&gt;<br/>    &lt;div class="albumcard-cover"&gt;&lt;!-- image tag here--&gt;&lt;/div&gt;<br/>    &lt;div class="albumcard-data"&gt;<br/>      &lt;h3&gt;{{ album.albumName }}&lt;/h3&gt;<br/>      &lt;h4&gt;{{ album.artist }}&lt;/h4&gt;<br/>    &lt;/div&gt;<br/>  &lt;/div&gt;<br/>&lt;/div&gt;</span></pre><p id="cd43" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">渲染视图的每个组件都有非常相似的设置:</p><ol class=""><li id="df4c" class="mx my it js b jt ju jx jy kb mz kf na kj nb kn nc nd ne nf bi translated">实际的组件代码只包含一个构造函数，它调用<code class="fe ko kp kq kr b">super()</code>方法来访问<code class="fe ko kp kq kr b">AbstractList</code>变量<code class="fe ko kp kq kr b">albumListToRender</code></li><li id="b2da" class="mx my it js b jt ng jx nh kb ni kf nj kj nk kn nc nd ne nf bi translated">视图模板使用<code class="fe ko kp kq kr b">albumToRender</code>属性以不同格式显示相同的数据。</li></ol><p id="e543" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有了这些知识，设置新视图只需要创建一个新组件并实现HTML以所需的输出格式呈现相册数据。然后，将新组件添加到<code class="fe ko kp kq kr b">BaseListComponent</code>中的<code class="fe ko kp kq kr b">contentStyles</code>属性。</p><h1 id="26d5" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">步骤4:清理和处理视图更改</h1><p id="7bea" class="pw-post-body-paragraph jq jr it js b jt mg jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn im bi translated">到目前为止，这个实现几乎是可行的。显示列表的组件的呈现仍然存在问题，并且当应该改变视图时，现有组件没有被移除。为了解决这两个问题，我们将使用<code class="fe ko kp kq kr b">BaseListComponent</code>中的<code class="fe ko kp kq kr b">ngOnChange</code>和<code class="fe ko kp kq kr b">ngOnDestroy</code>方法:</p><pre class="kt ku kv kw gt mn kr mo mp aw mq bi"><span id="4688" class="mr lj it kr b gy ms mt l mu mv">export class BaseListComponent implements OnInit, OnDestroy, OnChanges {</span><span id="f74a" class="mr lj it kr b gy mw mt l mu mv">  ...</span><span id="fe84" class="mr lj it kr b gy mw mt l mu mv">  ngOnDestroy() {<br/>    this.destroyChildComponent();<br/>  }</span><span id="e5ab" class="mr lj it kr b gy mw mt l mu mv">  ngOnChanges() {<br/>    this.destroyChildComponent();<br/>    this.instantiateViewComponent(this.showContentStyle);<br/>  }</span><span id="57a2" class="mr lj it kr b gy mw mt l mu mv">  private destroyChildComponent() {<br/>    if (this.componentReference) {<br/>      this.componentReference.destroy();<br/>      this.componentReference = null;<br/>    }<br/>  }<br/>}</span></pre><p id="9e12" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe ko kp kq kr b">ngOnDestroy()</code>方法卸载(销毁)动态呈现的组件，以避免该实现的内存泄漏。在每次改变<code class="fe ko kp kq kr b">showContentStyle</code>属性时，都会调用<code class="fe ko kp kq kr b">ngOnChanges()</code>方法，这表明用户请求了不同的视图。这个方法负责销毁已经存在的视图组件并呈现新的视图。</p><h1 id="affe" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">摘要</h1><p id="bae3" class="pw-post-body-paragraph jq jr it js b jt mg jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn im bi translated">在本文中，我们探讨了如何在Angular中改变数据集的可视化表示，而无需为显示样式的每次改变重新加载数据。这种实现是通过Angular的<code class="fe ko kp kq kr b">@ViewChild</code>特性实现的，该特性允许TypeScript主机组件实例动态替换呈现的模板，并将其数据传递给子组件。</p><p id="1124" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该功能背后的原理可以用于许多其他方面，例如呈现具有共同属性但根据数据类型而有不同细节的实体。例如，显示图书馆项目详细信息的页面需要显示常见数据，如标题、作者/艺术家和杜威索引，但根据项目是书籍、杂志、音乐录音还是DVD，会有不同的详细信息(例如页数、书籍版本与CD播放时间和曲目列表)。在这种情况下，不是用户点击按钮来改变显示，而是系统本身将基于要呈现的数据对象中的参数值来选择和实例化正确的子模板。</p></div></div>    
</body>
</html>