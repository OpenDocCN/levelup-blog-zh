# Git 不一定很难

> 原文：<https://levelup.gitconnected.com/git-doesnt-have-to-be-hard-e1e115be6668>

![](img/18617a02e552a05afa3aaa14d68bd2f3.png)

这个人为什么难过？因为他不懂独角兽！

多年来，每当我不得不在 Git 中工作时，我都会感到一丝恐惧。传统的源代码控制更有意义:我“签出”一个文件来处理它；源代码管理锁定中心副本，这样在我完成之前就没有人能篡改它。那样的话，真相只有一个版本。简单。

我记得一位工程师耐心地向我解释 Git 是如何工作的:有你的*工作树、*和你的*登台环境、*和一切真的只是一个指针，等等。我从来不明白这一点——所以每当我陷入困境时，我都不知道如何摆脱困境。

直到我明白。

# 没有勺子

放下对外界的依恋。忘了远程回购吧。忘记`push`和`pull`。想象一下，你有一个完整的源代码控制系统供你个人使用——类似于 Perforce，但只为你一个人。您可以获得版本历史、回滚、分支、签入，所有这些。

如果没有人在编辑文件，你还需要锁定它们吗？大概不会。所以与其跟踪文件版本，为什么不直奔主题，跟踪你真正感兴趣的:*变更。当你编辑一个文件时，那就是一种改变。当你创建或删除一个文件，这是一个变化。*

如果没有其他人正在编辑您的项目，您是否需要单独查看文件的“真实”版本？您需要查看存储库树吗？大概不会。你只需要知道你所做的改变会被记录在某个地方。当您切换分支时，如果您的工作目录中的文件能够神奇地匹配您所在的分支，那就太好了。事实证明，这正是 Git 的工作方式。

# 一只手鼓掌

*工作目录*是一个真实的地方:它是你找到你正在工作的项目文件的地方。但是*暂存区*和*存储库*只是概念。所以你也可以忘记这些——至少现在。

使用 Git，您需要做的就是:

1.  更改
2.  告诉 Git 要跟踪哪些
3.  追踪他们

当人们谈论一个*准备区域时，*他们只是指你准备在 Git 中形式化的变更列表。`add`命令真正的意思是:将这个变更添加到列表中。请记住:您跟踪的是更改，而不是文件。当您从 Git 中删除一个文件时，就会创建一个您必须添加的更改！扑朔迷离！

`commit`命令获取您使用`add`命令收集的大量变更，并将其记录在*存储库*中——记住，这是一个想法，而不是一个位置。*库*只是所有这些变更的列表(称为*提交*)。

您不需要单独的文件树来保持项目的最新版本。如果您曾经向后或向前滚动到代码的不同版本，或者切换分支，那么您在 Git 中所做的一切都是指向一个特定的*提交*，它代表了当时该分支上的情况。Git 会自动将所有这些更改应用到您的工作目录中。您的工作目录成为该版本文件的正确视图。神奇！

# 打开分离舱舱门

在传统的源代码控制中，有一个中央真理库。任何处理该存储库中文件的人都必须签入和签出文件。目标是保持中央存储库干净。这造成了一个非常严格的瓶颈，因为两个人不能同时处理相同的文件。这也是一个单点故障:如果中央存储库发生问题，您最好希望有人保留了备份。

使用 Git，每个参与项目的人都有自己的整个存储库的副本。所有的“源代码控制”都发生在每个人自己的计算机上。没有什么能阻止人们同时处理相同的文件。中央存储库实际上并不意味着是真实的单一来源，而是项目中每个人的同步点。如果中央存储库消失了，任何拥有最新副本的人都可以在几分钟内重新创建它。

来自传统的源代码控制环境，我被一个简单的误解所迷惑:我认为`push`和`pull`就像签入和签出文件。正是意识到`commit`实际上更像是签到，没有结账，帮助我最终理解了 Git。

# 让乐队重聚

大多数情况下，如果您的工作流如下所示，您应该不会有任何问题:

1.  从右分支提取(修复任何合并冲突)。
2.  在正确的分支中处理您的文件。
3.  每次到达一个好的检查点时，添加您的更改并提交。
4.  当其他人看到你的作品的时候，拉，合并，推到正确的分支。

如果你真的遇到了麻烦，那通常是因为你忘记了一个步骤。这里有几个例子。

在错误的分支中编辑了一个文件。你希望能够做的是撤销那些改变，切换分支，然后重新做。实际上，更好的方法是从错误的分支中取出这些变化，轻轻地放在你想要的分支上。幸运的是，Git 提供了一个名为`[stash](https://git-scm.com/docs/git-stash)`的命令来做这件事。

**误编辑了一个文件。你打开了一个文件来看，但是你的猫走过了键盘。您不确定添加或删除了什么。你只是想回到上次提交时的样子。为此，使用`[checkout](https://git-scm.com/docs/git-checkout)`。**

**补充得太早。你以正确的方式编辑了正确的文件，但是你过于匆忙地将它添加到了暂存区。您不想撤销对文件的更改，但希望在下次提交时将其删除。这是`[reset](https://git-scm.com/docs/git-reset)`的用途之一。您还可以使用`reset`进行更剧烈的回滚。如果需要，您可以撤消整个提交。**

## 摆脱困境

如果你想知道如何解决上述问题，你可以看看我的文章[Git out Trouble](/git-outta-trouble-56aba6672cb8)。

# 你动动脑子

哦，是的，我还没有涉及合并冲突。只有一件事让我感到困惑:哪一部分是我试图添加的更改，哪一部分是我与之冲突的其他人的更改？答案是 Git 的一个核心概念:每当你看到单词`HEAD`时，你应该把它想象成一个信号，表示:*你在这里。*`HEAD`是指向您工作位置的指针——当前分支上的活动提交。当您阅读像`reset`这样的命令的语法参考时，这个概念很方便。

# 走开

您现在已经注意到，我没有提供如何使用任何命令的具体示例。有很多地方可以找到修复各种灾难的方法。如果没有很好地理解 Git，这些指令可能会令人困惑，或者让您陷入更大的麻烦。但是现在您已经理解了 Git 是如何思考的，这些地方可能对您更有意义。我会先说[该死，蠢货！](https://dangitgit.com/)

**更新:**如果你想要更多的信息，我实际上写了一本书谈到这一点(和一些 Markdown 的东西): [Markdown 梦想:如何用 Markdown 和 Git 做事](https://www.amazon.com/Markdown-Dreams-How-things-Git-dp-B08JF5KLHL/dp/B08JF5KLHL/)

**更新到更新:**我认为 *Git 不一定很难*可能是一个足够有趣的主题，可以写一整本书。[于是我做了](https://www.amazon.com/dp/B095NPFJFR):

![](img/adc004599adec1ac477ab71b7b7d2dff.png)

如果你没有时间读完一整本书，你可以看一个简短的视频: