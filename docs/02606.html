<html>
<head>
<title>Laying the Rails from AWS API Gateway to ECS Fargate | Part I</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">铺设从AWS API Gateway到ECS Fargate的轨道|第一部分</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/laying-the-rails-from-aws-api-gateway-to-ecs-fargate-part-i-debf754d6a8b?source=collection_archive---------1-----------------------#2020-03-25">https://levelup.gitconnected.com/laying-the-rails-from-aws-api-gateway-to-ecs-fargate-part-i-debf754d6a8b?source=collection_archive---------1-----------------------#2020-03-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a71e" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">在两个不协调的产品之间建立网络路径的指南(使用Terraform)</h2></div><h2 id="ebc9" class="ki kj it bd kk kl km dn kn ko kp dp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">废弃通知</h2><p id="abc8" class="pw-post-body-paragraph le lf it lg b lh li ju lj lk ll jx lm kr ln lo lp kv lq lr ls kz lt lu lv lw im bi translated">3月12日，亚马逊发布了“<a class="ae lx" href="https://aws.amazon.com/blogs/compute/building-better-apis-http-apis-now-generally-available/" rel="noopener ugc nofollow" target="_blank">构建更快、更低成本、更好的API——HTTP API现已普遍可用</a>”因此，我建议希望将API Gateway与ALB集成的读者忽略本文中涉及NLB和目标更新程序函数的说明。相反，VPC链路应该直接路由到ALB。</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi ly"><img src="../Images/b5d02ee679be06352199bf39e4da8376.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CSruvb9Fm65k6QO5G-pirg.png"/></div></div></figure><h1 id="691c" class="mk kj it bd kk ml mm mn kn mo mp mq kq jz mr ka ku kc ms kd ky kf mt kg lc mu bi translated">介绍</h1><p id="dc3c" class="pw-post-body-paragraph le lf it lg b lh li ju lj lk ll jx lm kr ln lo lp kv lq lr ls kz lt lu lv lw im bi translated">在以安全和开发友好的方式部署和服务应用程序时，Amazon提供了非凡的灵活性。这有许多好处，其中之一是它提供了绘制代码图的独特机会，如上所述。另一方面，有时产品的广度会造成两个看似兼容的东西，比如API网关和后端API，很难组合在一起。我很乐意接受这种权衡，而不是必须处理一个不灵活的、规范的平台，但是这些集成的一些微妙细节仍然很神秘，直到您真正深入了解。</p><p id="5a16" class="pw-post-body-paragraph le lf it lg b lh mv ju lj lk mw jx lm kr mx lo lp kv my lr ls kz mz lu lv lw im bi translated">本系列文章将指导读者实现从API Gateway到ECS Fargate的完整集成路径，包括前端(网关)的AWS Cognito客户端认证、与VPC的私有集成、负载平衡和安全HTTP。HCL for Terraform将是我显示配置细节的主要手段，因此我假设您熟悉该工具以及所涉及的云资源的一般功能。我将从网关开始，向后(或者向前，如果您是后端开发人员)。</p><p id="c737" class="pw-post-body-paragraph le lf it lg b lh mv ju lj lk mw jx lm kr mx lo lp kv my lr ls kz mz lu lv lw im bi translated">本文是两篇文章的第一部分。第一篇文章将以对VPC环节的讨论结束，第二篇文章将从这一环节继续。</p><h2 id="8766" class="ki kj it bd kk kl km dn kn ko kp dp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">关于代码示例的注释</h2><p id="9d3c" class="pw-post-body-paragraph le lf it lg b lh li ju lj lk ll jx lm kr ln lo lp kv lq lr ls kz lt lu lv lw im bi translated">当我从博客或堆栈溢出答案中找到一个代码示例时，我总是想知道它可能存在于我的应用程序生态系统中的什么地方。对于这个例子，让我们假设我们有很多后端服务，我们希望通过网关公开它们。一些地形配置将需要进入基础设施的共享项目(以下简称<em class="na">以下简称</em>)，该项目提供由许多组件共享的资源。其他配置将进入一个单一的、示范性服务的项目，我将称之为<em class="na"> ice-station-zebra </em>作为对目前电视上最好的节目的敬意，<em class="na">最好叫索尔</em> (AMC，周一)。因此，对于每个代码示例，我将尝试提供实现这一效果的上下文。</p><h2 id="a0af" class="ki kj it bd kk kl km dn kn ko kp dp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">特别感谢</h2><p id="06f5" class="pw-post-body-paragraph le lf it lg b lh li ju lj lk ll jx lm kr ln lo lp kv lq lr ls kz lt lu lv lw im bi translated">这里的一些实现借用了文章<a class="ae lx" href="https://www.bluematador.com/blog/static-ips-for-aws-application-load-balancer" rel="noopener ugc nofollow" target="_blank"> <em class="na">如何为AWS应用负载平衡器</em> </a>使用静态IPs。</p><h1 id="7de7" class="mk kj it bd kk ml mm mn kn mo mp mq kq jz mr ka ku kc ms kd ky kf mt kg lc mu bi translated">认知</h1><p id="daef" class="pw-post-body-paragraph le lf it lg b lh li ju lj lk ll jx lm kr ln lo lp kv lq lr ls kz lt lu lv lw im bi translated">在设置API网关之前，我们应该先解决这个先决条件。我们将在我们的<em class="na"> infra </em>项目中定义一个用户池和一个<a class="ae lx" href="https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-pools-assign-domain.html" rel="noopener ugc nofollow" target="_blank">用户池域</a>。如果您的设置在不同阶段(开发、生产等)有不同的帐户。)在您的开发管道中，这可能应该在每个环境(每个AWS帐户)的基础上应用，因为应用程序用户是特定于阶段的实体。</p><pre class="lz ma mb mc gt nb nc nd ne aw nf bi"><span id="0875" class="ki kj it nc b gy ng nh l ni nj">resource "aws_cognito_user_pool" "users" {<br/>  name = "users"<br/>}</span><span id="1c37" class="ki kj it nc b gy nk nh l ni nj">resource "aws_cognito_user_pool_domain" "users" {<br/>  domain = "${var.stage}-users"<br/>  user_pool_id = aws_cognito_user_pool.users.id<br/>}</span></pre><p id="5689" class="pw-post-body-paragraph le lf it lg b lh mv ju lj lk mw jx lm kr mx lo lp kv my lr ls kz mz lu lv lw im bi translated">在我们的<em class="na"> ice-station-zebra </em>项目中，对于每个阶段，我们都可以获取用户池的ID，并使用<a class="ae lx" href="https://aws.amazon.com/blogs/mobile/understanding-amazon-cognito-user-pool-oauth-2-0-grants/" rel="noopener ugc nofollow" target="_blank">客户端凭证流</a>设置Cognito认证的基础，这是典型的机器对机器认证。为了简单起见，我在这里只配置了<em class="na">认证</em>，而没有配置<em class="na">授权</em>机制——这是另一个话题——所以<em class="na">资源服务器</em>主要是一个占位符。<code class="fe nl nm nn nc b">aws_cognito_user_pool_client</code>是App客户端。属性<code class="fe nl nm nn nc b">aws_cognito_user_pool_client.this.id</code>为<code class="fe nl nm nn nc b">client_credentials</code>认证提供了“用户名”。</p><pre class="lz ma mb mc gt nb nc nd ne aw nf bi"><span id="f980" class="ki kj it nc b gy ng nh l ni nj">data "aws_cognito_user_pools" "users" {<br/>  name = "users"<br/>}</span><span id="620a" class="ki kj it nc b gy nk nh l ni nj">locals {<br/>  user_pool_id = tolist(data.aws_cognito_user_pools.users.ids)[0]<br/>  cognito_idp_name = "cognito-idp.${data.aws_region.current.name}.amazonaws.com/${local.user_pool_id}"<br/>}<br/><br/>resource "aws_cognito_resource_server" "this" {<br/>  identifier = "ice-station-zebra"<br/>  name = "ice-station-zebra"<br/>  user_pool_id = local.user_pool_id<br/>  scope {<br/>    scope_name = "read"<br/>    scope_description = "Read"<br/>  }<br/>  scope {<br/>    scope_name = "edit"<br/>    scope_description = "Edit"<br/>  }<br/>}<br/><br/>resource "aws_cognito_user_pool_client" "this" {<br/>  name = var.name<br/>  user_pool_id = local.user_pool_id<br/>  supported_identity_providers = ["COGNITO"]<br/>  generate_secret = true<br/>  allowed_oauth_flows_user_pool_client = true<br/>  allowed_oauth_flows = ["client_credentials"]<br/>  allowed_oauth_scopes = aws_cognito_resource_server.this.scope_identifiers<br/>}</span><span id="5371" class="ki kj it nc b gy nk nh l ni nj">output "cognito_client_secret" {<br/>  sensitive = true<br/>  value = aws_cognito_user_pool_client.this.client_secret<br/>}</span></pre><p id="b5ed" class="pw-post-body-paragraph le lf it lg b lh mv ju lj lk mw jx lm kr mx lo lp kv my lr ls kz mz lu lv lw im bi translated">我继续添加了客户端密码的输出。请记住，Terraform以纯文本的形式存储其状态中的一些敏感值，因此要保护状态文件并谨慎运行<code class="fe nl nm nn nc b">terraform output</code>。</p><h1 id="cad3" class="mk kj it bd kk ml mm mn kn mo mp mq kq jz mr ka ku kc ms kd ky kf mt kg lc mu bi translated">API网关</h1><h2 id="5cfb" class="ki kj it bd kk kl km dn kn ko kp dp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">基础设施</h2><p id="cf21" class="pw-post-body-paragraph le lf it lg b lh li ju lj lk ll jx lm kr ln lo lp kv lq lr ls kz lt lu lv lw im bi translated">让我们继续在<em class="na"> infra </em>项目中设置API网关。如Cognito部分所述，这可以在每个环境中定义一次。或者，它可以包含在“共享”配置中，这样每个API网关“阶段”指向不同的AWS环境帐户。这似乎是他们对stage特性的想法，但是您是否有效地利用它取决于您如何从字面上理解特定于一个阶段的资源应该与另一个阶段的资源分离的概念。对于用于多个阶段的单个网关，CI/CD系统可能必须在部署期间在网关上执行特定的操作，尤其是在需要金丝雀类型的部署时，而这种方法将它视为任何其他资源。</p><pre class="lz ma mb mc gt nb nc nd ne aw nf bi"><span id="c83a" class="ki kj it nc b gy ng nh l ni nj">resource "aws_api_gateway_account" "this" {<br/>  cloudwatch_role_arn = aws_iam_role.api_gateway_cloudwatch.arn<br/>}</span></pre><p id="c28b" class="pw-post-body-paragraph le lf it lg b lh mv ju lj lk mw jx lm kr mx lo lp kv my lr ls kz mz lu lv lw im bi translated">这是一个IAM角色，附带一个AWS管理的策略，允许API Gateway将日志推送到CloudWatch。</p><pre class="lz ma mb mc gt nb nc nd ne aw nf bi"><span id="bbea" class="ki kj it nc b gy ng nh l ni nj">data "aws_iam_policy_document" "api_gateway_assume_role" {<br/>  statement {<br/>    actions = ["sts:AssumeRole"]<br/>    principals {<br/>      type = "Service"<br/>      identifiers = ["apigateway.amazonaws.com"]<br/>    }<br/>  }<br/>}</span><span id="bc5c" class="ki kj it nc b gy nk nh l ni nj">resource "aws_iam_role" "api_gateway_cloudwatch" {<br/>  name = "api-gateway-cloudwatch"<br/>  assume_role_policy = data.aws_iam_policy_document.api_gateway_assume_role.json<br/>}</span><span id="6d59" class="ki kj it nc b gy nk nh l ni nj">data "aws_iam_policy" "api_gateway_cloudwatch" {<br/>  arn = "arn:aws:iam::aws:policy/service-role/AmazonAPIGatewayPushToCloudWatchLogs"<br/>}</span><span id="6dce" class="ki kj it nc b gy nk nh l ni nj">resource "aws_iam_role_policy_attachment" "api_gateway_cloudwatch" {<br/>  role = aws_iam_role.api_gateway_cloudwatch.id<br/>  policy_arn = data.aws_iam_policy.api_gateway_cloudwatch.arn<br/>}</span></pre><p id="2c29" class="pw-post-body-paragraph le lf it lg b lh mv ju lj lk mw jx lm kr mx lo lp kv my lr ls kz mz lu lv lw im bi translated">现在，作为API开发者，我们需要弄清楚我们的消费者将为<em class="na"> ice-station-zebra </em> API使用哪个URL。默认情况下，REST API提供了一个难看的URL，<code class="fe nl nm nn nc b">https://<em class="na">{restapi-id}</em>.execute-api.<em class="na">{region}</em>.amazonaws.com/<em class="na">{stage}</em></code>。该URL可用于与AWS Lambda的集成，但要将其用于与ECS任务的集成，需要在集成路径上的不同点拥有该子域的TLS证书，并且除了杰夫·贝索斯之外，任何人都无法获得该证书。所以，让我们假设我们拥有一个域名，<em class="na">abq.com</em>，并且我们有一个它所有子域名的TLS证书(<em class="na"> *.abq.com </em> ) <em class="na">。</em>我希望服务的REST API在基本路径“https://API . abq . com/ice-station-zebra”及其所有子路径中都可用。这是为了提供一个完整的例子，如果你看到<em class="na"> ice-station-zebra </em>代表一个单一的后端，你可能希望有一个像“https://ice-station-zebra.com”一样简单的URL基路径。</p><p id="442e" class="pw-post-body-paragraph le lf it lg b lh mv ju lj lk mw jx lm kr mx lo lp kv my lr ls kz mz lu lv lw im bi translated">值得注意的是，API Gateway还支持“HTTP APIs”在撰写本文时，<a class="ae lx" href="https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-vs-rest.html" rel="noopener ugc nofollow" target="_blank"> REST API是一个更加通用的选项</a>；我会保守一点，在这个例子中使用REST API。</p><p id="ea43" class="pw-post-body-paragraph le lf it lg b lh mv ju lj lk mw jx lm kr mx lo lp kv my lr ls kz mz lu lv lw im bi translated">建立该URL的第一步是<a class="ae lx" href="https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-custom-domains.html" rel="noopener ugc nofollow" target="_blank">为包含<em class="na"> ice-station-zebra </em>的一组服务建立一个<em class="na">自定义域名</em> </a>。这个配置由多个后端API共享，并进入下面的<em class="na">配置。我选择创建一个<a class="ae lx" href="https://docs.aws.amazon.com/apigateway/latest/developerguide/create-regional-api.html" rel="noopener ugc nofollow" target="_blank">“区域”API </a>，它提供了对地理分布的更大控制；默认的端点类型是<code class="fe nl nm nn nc b">EDGE</code>。我已经在ACM中导入了一个TLS证书，但是如果您使用ACM作为您的证书颁发机构，您可以使用一个<code class="fe nl nm nn nc b"><a class="ae lx" href="https://www.terraform.io/docs/providers/aws/r/acm_certificate.html" rel="noopener ugc nofollow" target="_blank">resource</a></code>来代替<code class="fe nl nm nn nc b">data</code>源。</em></p><pre class="lz ma mb mc gt nb nc nd ne aw nf bi"><span id="d6b0" class="ki kj it nc b gy ng nh l ni nj">data "aws_acm_certificate" "star_dot_abq_dot_com" {<br/>  domain = "*.abq.com"<br/>}</span><span id="be45" class="ki kj it nc b gy nk nh l ni nj">resource "aws_api_gateway_domain_name" "com_abq_api" {<br/>  domain_name = "api.abq.com"<br/>  endpoint_configuration {<br/>    types = ["REGIONAL"]<br/>  }<br/>  regional_certificate_arn = data.aws_acm_certificate.star_dot_abq_dot_com.arn<br/>  security_policy = "TLS_1_2"<br/>}</span></pre><h2 id="a7a7" class="ki kj it bd kk kl km dn kn ko kp dp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">服务</h2><p id="1324" class="pw-post-body-paragraph le lf it lg b lh li ju lj lk ll jx lm kr ln lo lp kv lq lr ls kz lt lu lv lw im bi translated">在我们建立“/ice-station-zebra”路径之前，我们需要在我们的<em class="na"> i-s-z </em>项目中对我们的特定于服务的REST API进行平台化。我们还可以设置<em class="na">授权器</em>，它为整个REST API设置Cognito认证。现在，所有对REST资源的请求都必须包含一个“Authorization”头。头值将是Base-64编码的JSON Web令牌(奇怪的是，前缀必须是“Bearer”，而不是“T8”)。</p><pre class="lz ma mb mc gt nb nc nd ne aw nf bi"><span id="7efe" class="ki kj it nc b gy ng nh l ni nj">resource "aws_api_gateway_rest_api" "this" {<br/>  name = "ISZAPIv1"<br/>  endpoint_configuration {<br/>    types = ["REGIONAL"]<br/>  }<br/>}</span><span id="da6b" class="ki kj it nc b gy nk nh l ni nj">resource "aws_api_gateway_authorizer" "cognito" {<br/>  name = "${aws_api_gateway_rest_api.this.name}CognitoUserPoolAuthorizer"<br/>  type = "COGNITO_USER_POOLS"<br/>  rest_api_id = aws_api_gateway_rest_api.this.id<br/>  provider_arns = data.aws_cognito_user_pools.users.arns<br/>  identity_source = "method.request.header.Authorization"<br/>}</span></pre><p id="21fc" class="pw-post-body-paragraph le lf it lg b lh mv ju lj lk mw jx lm kr mx lo lp kv my lr ls kz mz lu lv lw im bi translated">网关的一个基本特性是允许您使用一些标准规范(如OpenAPI)定义REST资源，并将它们与各自的后端端点集成在一起。这种实践在<a class="ae lx" href="https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-method-settings.html" rel="noopener ugc nofollow" target="_blank">中有很好的记录</a>，所以这里我们将适当地偷懒并利用API网关<a class="ae lx" href="https://docs.aws.amazon.com/apigateway/latest/developerguide/setup-http-integrations.html" rel="noopener ugc nofollow" target="_blank"> HTTP代理</a>特性。这实际上是集成第三方/黑盒类型的服务的一个很好的选择，这种服务由您自己托管，并且具有自定义的API。</p><p id="b738" class="pw-post-body-paragraph le lf it lg b lh mv ju lj lk mw jx lm kr mx lo lp kv my lr ls kz mz lu lv lw im bi translated">我们将为代理资源定义一个带有子路径“{proxy+}”的<em class="na">资源</em>以及一个<em class="na">方法</em>。该方法对“代理”请求参数的引用确保了被代理的路径片段将在<em class="na">集成</em>中可用。然后，集成能够将路径片段传递给集成组件，不管它是什么。</p><pre class="lz ma mb mc gt nb nc nd ne aw nf bi"><span id="13de" class="ki kj it nc b gy ng nh l ni nj">resource "aws_api_gateway_resource" "proxy" {<br/>  rest_api_id = aws_api_gateway_rest_api.this.id<br/>  parent_id = aws_api_gateway_rest_api.this.root_resource_id<br/>  path_part = "{proxy+}"<br/>}</span><span id="c3dd" class="ki kj it nc b gy nk nh l ni nj">resource "aws_api_gateway_method" "proxy" {<br/>  rest_api_id = aws_api_gateway_rest_api.this.id<br/>  resource_id = aws_api_gateway_resource.proxy.id<br/>  http_method = "ANY"<br/>  authorization = "COGNITO_USER_POOLS"<br/>  authorizer_id = aws_api_gateway_authorizer.cognito.id<br/>  request_parameters = {<br/>    "method.request.path.proxy" = true<br/>  }<br/>  authorization_scopes = aws_cognito_resource_server.this.scope_identifiers<br/>}</span><span id="2970" class="ki kj it nc b gy nk nh l ni nj">resource "aws_api_gateway_integration" "this" {<br/>  rest_api_id = aws_api_gateway_rest_api.this.id<br/>  resource_id = aws_api_gateway_resource.proxy.id<br/>  http_method = aws_api_gateway_method.proxy.http_method<br/>  integration_http_method = "ANY"<br/>  type = "HTTP_PROXY"<br/>  uri = "https://api.abq.com/ice-station-zebra/{proxy}"<br/>  connection_type = "VPC_LINK"<br/>  connection_id = "$${stageVariables.vpcLinkId}"<br/>  request_parameters = {<br/>    "integration.request.path.proxy" = "method.request.path.proxy"<br/>  }<br/>}</span></pre><p id="fc0e" class="pw-post-body-paragraph le lf it lg b lh mv ju lj lk mw jx lm kr mx lo lp kv my lr ls kz mz lu lv lw im bi translated">另外，除了代理API，我可能不会使用<code class="fe nl nm nn nc b">aws_api_gateway_resource</code>和相关资源来定义REST API。<code class="fe nl nm nn nc b">aws_api_gateway_rest_api</code>采用<code class="fe nl nm nn nc b">body</code>参数，允许你<a class="ae lx" href="https://docs.aws.amazon.com/apigateway/latest/developerguide/create-api-using-swagger.html" rel="noopener ugc nofollow" target="_blank">用OpenAPI/Swagger规范</a>定义一切。导入的规范需要为API Gateway定义一些特殊的属性，但是对于一个拥有大量资源的API来说，似乎更容易维护。与在资源上定义“描述”属性相比，资源<code class="fe nl nm nn nc b">aws_api_gateway_documentation_part</code>似乎有些笨拙。这是我的直觉，你的里程可能会有所不同。</p><p id="443a" class="pw-post-body-paragraph le lf it lg b lh mv ju lj lk mw jx lm kr mx lo lp kv my lr ls kz mz lu lv lw im bi translated">进一步，我们需要<a class="ae lx" href="https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-deploy-api.html" rel="noopener ugc nofollow" target="_blank">一个<em class="na">部署</em>和一个<em class="na">阶段</em> </a>。这部分很乱，原因有几个。如果不做一些调整，Terraform无法管理API网关阶段的状态。例如，AWS Terraform提供者周围的社区似乎倾向于在部署中使用<code class="fe nl nm nn nc b">create_before_destroy</code>,这样stage就不会因为无效的部署id而挂起。我发现偶尔有必要在部署资源上运行<code class="fe nl nm nn nc b">terraform taint</code>,以强制对要部署的其他资源进行更改。这些资源存在未解决的问题，因此请谨慎使用。此外，在测试中，我发现部署REST API需要一段时间，之前的部署会停留一两分钟。如果你期望立即得到反馈，这种滞后会令人困惑。</p><p id="7811" class="pw-post-body-paragraph le lf it lg b lh mv ju lj lk mw jx lm kr mx lo lp kv my lr ls kz mz lu lv lw im bi translated"><code class="fe nl nm nn nc b">vpc_link</code>的东西将在下一节解释。</p><pre class="lz ma mb mc gt nb nc nd ne aw nf bi"><span id="4c1f" class="ki kj it nc b gy ng nh l ni nj">resource "aws_api_gateway_deployment" "this" {<br/>  rest_api_id = aws_api_gateway_rest_api.this.id<br/>  stage_name = var.stage<br/>  depends_on = [aws_api_gateway_integration.this]<br/><br/>  variables = {<br/>    // just to trigger redeploy on resource changes<br/>    resources = join(", ", [aws_api_gateway_resource.proxy.id])<br/><br/>    // note: redeployment might be required with other gateway changes.<br/>    // when necessary run `terraform taint &lt;this resource's address&gt;`<br/>  }<br/><br/>  lifecycle {<br/>    create_before_destroy = true<br/>  }<br/>}</span><span id="fad5" class="ki kj it nc b gy nk nh l ni nj">data "aws_api_gateway_vpc_link" "env" {<br/>  name = var.stage<br/>}</span><span id="c26e" class="ki kj it nc b gy nk nh l ni nj">resource "aws_api_gateway_stage" "this" {<br/>  deployment_id = aws_api_gateway_deployment.this.id<br/>  rest_api_id = aws_api_gateway_rest_api.this.id<br/>  stage_name = aws_api_gateway_deployment.this.stage_name<br/>  access_log_settings {<br/>    destination_arn = aws_cloudwatch_log_group.api_gateway.arn<br/>    // Common Log Format<br/>    format = "$context.identity.sourceIp $context.identity.caller $context.identity.user [$context.requestTime] \"$context.httpMethod $context.resourcePath $context.protocol\" $context.status $context.responseLength $context.requestId"<br/>  }<br/>  variables = {<br/>    vpcLinkId = data.aws_api_gateway_vpc_link.env.id<br/>  }<br/>}</span></pre><p id="d959" class="pw-post-body-paragraph le lf it lg b lh mv ju lj lk mw jx lm kr mx lo lp kv my lr ls kz mz lu lv lw im bi translated">我们还需要将REST API映射到一个<em class="na">基本路径</em>以添加到我们的域中。在代理路径和整合URI方面取得成功是令人困惑的——如果我有一个<a class="ae lx" href="https://medium.com/swlh/a-tale-of-two-aws-iam-roles-in-springfield-d19a4f9ffd91?source=friends_link&amp;sk=b6a97091062d1013cac2b36ac01181cd" rel="noopener">辛普森一家的类比</a>就好了！基本上，在请求方法的“{proxy}”占位符中代理的路径部分将位于基本路径映射的末尾，该URL成为网关对API集成发出的请求。最终结果是<a class="ae lx" href="https://en.wikipedia.org/wiki/The_Myth_of_Sisyphus" rel="noopener ugc nofollow" target="_blank">进来的URL和出去的URL是同一个。</a></p><pre class="lz ma mb mc gt nb nc nd ne aw nf bi"><span id="bc08" class="ki kj it nc b gy ng nh l ni nj">resource "aws_api_gateway_base_path_mapping" "this" {<br/>  domain_name = "api.abq.com"<br/>  api_id = aws_api_gateway_rest_api.this.id<br/>  stage_name = aws_api_gateway_stage.this.stage_name<br/>  base_path = "ice-station-zebra"<br/>}</span></pre><p id="1f56" class="pw-post-body-paragraph le lf it lg b lh mv ju lj lk mw jx lm kr mx lo lp kv my lr ls kz mz lu lv lw im bi translated">集成URI主机名在技术上不必与自定义域名相同，但出于几个原因，这是一个实用的选择。在下一节中，我将说明API网关和VPC之间的私有链接要求您拥有一个能够修改公共DNS记录的域名。您也可以在内部重用该属性。</p><p id="1a26" class="pw-post-body-paragraph le lf it lg b lh mv ju lj lk mw jx lm kr mx lo lp kv my lr ls kz mz lu lv lw im bi translated">最后，让我们创建一个CloudWatch日志组，其名称采用API Gateway将识别的特定格式<a class="ae lx" href="https://docs.aws.amazon.com/apigateway/latest/developerguide/set-up-logging.html" rel="noopener ugc nofollow" target="_blank">。</a></p><pre class="lz ma mb mc gt nb nc nd ne aw nf bi"><span id="ca8a" class="ki kj it nc b gy ng nh l ni nj">resource "aws_cloudwatch_log_group" "api_gateway" {<br/>  name = "API-Gateway-Execution-Logs_${aws_api_gateway_rest_api.this.id}/${aws_api_gateway_deployment.this.stage_name}"<br/>  retention_in_days = 7<br/>}</span></pre><h1 id="ba06" class="mk kj it bd kk ml mm mn kn mo mp mq kq jz mr ka ku kc ms kd ky kf mt kg lc mu bi translated">VPC链接</h1><p id="859f" class="pw-post-body-paragraph le lf it lg b lh li ju lj lk ll jx lm kr ln lo lp kv lq lr ls kz lt lu lv lw im bi translated">将API网关与VPC中的资源集成在一起始于到网络负载平衡器的<a class="ae lx" href="https://docs.aws.amazon.com/apigateway/latest/developerguide/set-up-private-integration.html" rel="noopener ugc nofollow" target="_blank"> VPC链路</a>。我将在后面的部分中介绍NLB，但这是VPC链接的先决条件。这一资源以及从现在开始的大多数其他资源都属于<em class="na">基础设施的范畴。</em></p><pre class="lz ma mb mc gt nb nc nd ne aw nf bi"><span id="647f" class="ki kj it nc b gy ng nh l ni nj">resource "aws_api_gateway_vpc_link" "this" {<br/>  name = var.stage<br/>  target_arns = [aws_lb.network.arn]<br/>}</span></pre><p id="78d3" class="pw-post-body-paragraph le lf it lg b lh mv ju lj lk mw jx lm kr mx lo lp kv my lr ls kz mz lu lv lw im bi translated">VPC链接是一个<a class="ae lx" href="https://docs.aws.amazon.com/vpc/latest/userguide/endpoint-service.html" rel="noopener ugc nofollow" target="_blank"> VPC端点服务</a>，在其“白名单主体”列表中有一个条目:为配置区域提供API网关的AWS管理的帐户的<code class="fe nl nm nn nc b">root</code>(有一个列表)。</p><p id="f43c" class="pw-post-body-paragraph le lf it lg b lh mv ju lj lk mw jx lm kr mx lo lp kv my lr ls kz mz lu lv lw im bi translated">如果您将本文作为教程来阅读，这里有一个基本的网络负载平衡器。</p><pre class="lz ma mb mc gt nb nc nd ne aw nf bi"><span id="02a3" class="ki kj it nc b gy ng nh l ni nj">resource "aws_lb" "network" {<br/>  name = "nlb"<br/>  load_balancer_type = "network"<br/>  enable_cross_zone_load_balancing = true<br/>  internal = false<br/>  subnets = var.private_subnet_ids<br/>}</span></pre><h2 id="b25f" class="ki kj it bd kk kl km dn kn ko kp dp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">私有DNS</h2><p id="5698" class="pw-post-body-paragraph le lf it lg b lh li ju lj lk ll jx lm kr ln lo lp kv lq lr ls kz lt lu lv lw im bi translated">用Terraform创建<code class="fe nl nm nn nc b">vpc_link</code>资源只是一个开始，还需要一些手工操作。VPC链路开始时缺少其专用DNS名称。如果没有它，网关将返回神秘的500错误，因为它试图击中一个VPC端点URI不匹配插值积分URI。我们用<code class="fe nl nm nn nc b">uri = "https://api.abq.com/ice-station-zebra/{proxy}"</code>配置了整合资源；在我们将其定义为私有DNS名称之前，该端点并不存在。这个<a class="ae lx" href="https://docs.aws.amazon.com/apigateway/latest/developerguide/getting-started-with-private-integration.html" rel="noopener ugc nofollow" target="_blank">在文档</a>中并没有真正解释。这张截图显示了我们想要的最终结果。</p><figure class="lz ma mb mc gt md gh gi paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="gh gi no"><img src="../Images/c6efb5a70fd125243a2e2c77ba4723ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C8R8ECSWhpni3oUXNKKoQw.png"/></div></div></figure><p id="b079" class="pw-post-body-paragraph le lf it lg b lh mv ju lj lk mw jx lm kr mx lo lp kv my lr ls kz mz lu lv lw im bi translated">专用DNS名称需要经过“验证”才能被访问。我是这样做的:</p><ol class=""><li id="76ed" class="np nq it lg b lh mv lk mw kr nr kv ns kz nt lw nu nv nw nx bi translated">在AWS控制台中，设置专用DNS名称(例如，“api.abq.com”)。</li><li id="4086" class="np nq it lg b lh ny lk nz kr oa kv ob kz oc lw nu nv nw nx bi translated">“域验证状态”现在应该是“待定”获取“域验证名”和“域验证值”</li><li id="8fd2" class="np nq it lg b lh ny lk nz kr oa kv ob kz oc lw nu nv nw nx bi translated">向您的DNS提供商注册一个值为<code class="fe nl nm nn nc b"><em class="na">{domain verification name}</em>=<em class="na">{domain verification value}</em></code>的域名TXT记录。(两者之间只是一个等号。)</li><li id="6e9c" class="np nq it lg b lh ny lk nz kr oa kv ob kz oc lw nu nv nw nx bi translated">在AWS控制台中，点击按钮验证DNS名称。</li><li id="42b0" class="np nq it lg b lh ny lk nz kr oa kv ob kz oc lw nu nv nw nx bi translated">等10分钟吧。</li></ol><p id="94c6" class="pw-post-body-paragraph le lf it lg b lh mv ju lj lk mw jx lm kr mx lo lp kv my lr ls kz mz lu lv lw im bi translated">在<code class="fe nl nm nn nc b">aws_api_gateway_stage</code>中，我们在<code class="fe nl nm nn nc b">variables</code>下引用了这个VPC链接的ID。这允许我们使用“${stageVariables.vpcLinkId}”来引用它。Amazon建议这样做，而不是直接定义ID，这样“您可以通过更改stage变量值轻松切换到API的不同VPC链接。”如果不切换阶段，这种间接方式可能没有用。</p><h1 id="8a91" class="mk kj it bd kk ml mm mn kn mo mp mq kq jz mr ka ku kc ms kd ky kf mt kg lc mu bi translated">摘要</h1><p id="7940" class="pw-post-body-paragraph le lf it lg b lh li ju lj lk ll jx lm kr ln lo lp kv lq lr ls kz lt lu lv lw im bi translated">在这个由两部分组成的系列文章的第一部分中，我演示了如何集成AWS API Gateway、Cognito和VPC服务端点。我很想听听你的反馈。我会在本周的某个时候发布第二部分。感谢阅读。</p><h2 id="f978" class="ki kj it bd kk kl km dn kn ko kp dp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">后续行动</h2><p id="bc74" class="pw-post-body-paragraph le lf it lg b lh li ju lj lk ll jx lm kr ln lo lp kv lq lr ls kz lt lu lv lw im bi translated">第二部分:</p><div class="od oe gp gr of og"><a href="https://medium.com/@lucjross/laying-the-rails-from-aws-api-gateway-to-ecs-fargate-part-ii-7b9294ead2e4" rel="noopener follow" target="_blank"><div class="oh ab fo"><div class="oi ab oj cl cj ok"><h2 class="bd iu gy z fp ol fr fs om fu fw is bi translated">铺设从AWS API网关到ECS Fargate的轨道|第二部分</h2><div class="on l"><h3 class="bd b gy z fp ol fr fs om fu fw dk translated">《急诊室的故事》前情提要中，我描述了从API网关到VPC链接的集成线路。这第二部分将涵盖…</h3></div><div class="oo l"><p class="bd b dl z fp ol fr fs om fu fw dk translated">medium.com</p></div></div><div class="op l"><div class="oq l or os ot op ou mi og"/></div></div></a></div></div></div>    
</body>
</html>