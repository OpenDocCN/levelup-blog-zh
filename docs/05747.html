<html>
<head>
<title>Collapsible Sections With or Without JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">有或没有JavaScript的可折叠部分</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/collapsible-sections-with-or-without-javascript-3fd871955a9d?source=collection_archive---------0-----------------------#2020-09-27">https://levelup.gitconnected.com/collapsible-sections-with-or-without-javascript-3fd871955a9d?source=collection_archive---------0-----------------------#2020-09-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/a54333e6b56bd42120db901c6d91d2c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yxrJOskt_a62opKa9ctLJA.png"/></div></div></figure><p id="42f8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">虽然HTML 5确实为可折叠部分提供了<details>和<summary>标签，但从语义的角度来看，这通常是错误的代码。例如，如果你只想在用户点击一个部分之前显示列表的一部分，你就必须把列表分成两个独立的部分，这是语法/结构上的乱码。</summary></details></p><p id="42e7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当制作这些类型的代码段时，人们通常依赖JavaScript来完成。大多数脚本依赖于臃肿的库，并被硬编码到特定的元素。在<a class="ae kz" href="https://medium.com/swlh/writing-a-front-end-component-with-vanilla-js-8a8fbff56299" rel="noopener">他关于折叠部分的好文章</a> — <em class="la">中，这篇文章的灵感</em> — <a class="lb lc ep" href="https://medium.com/u/ee1620854db4?source=post_page-----3fd871955a9d--------------------------------" rel="noopener" target="_blank">亚历克斯·济托-沃尔夫</a>落入了传统方法的许多陷阱。</p><h1 id="79db" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">用JavaScript做这个有什么问题？</h1><p id="a83c" class="pw-post-body-paragraph kb kc it kd b ke mb kg kh ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky im bi translated">第一个问题是优雅的退化。为了达到可访问性规范的精英中的精英，您应该为JavaScript不存在时会发生什么做好准备。<a class="ae kz" href="https://codepen.io/azitowolf/pen/KKzrEVY" rel="noopener ugc nofollow" target="_blank">他原来的</a>中的问题包括:</p><ul class=""><li id="2002" class="mg mh it kd b ke kf ki kj km mi kq mj ku mk ky ml mm mn mo bi translated">禁用/阻止脚本不起作用。这对可访问性和可用性是不利的。更糟糕的是，当脚本擅离职守时，元素被隐藏并且<strong class="kd iu">不能</strong>被打开。</li><li id="798c" class="mg mh it kd b ke mp ki mq km mr kq ms ku mt ky ml mm mn mo bi translated">当脚本被关闭/阻止/禁用时，标记中的静态链接什么也不做。他们的文本内容会非常混乱，因为对于非视觉用户。</li><li id="6fe7" class="mg mh it kd b ke mp ki mq km mr kq ms ku mt ky ml mm mn mo bi translated">默认状态下使用<code class="fe mu mv mw mx b">display:none</code>意味着搜索引擎不会看到隐藏的内容。<strong class="kd iu">有史以来！</strong>这也可能会影响一些非视觉UA，之所以这样做是因为十多年前，我们有一个被称为“内容伪装”的低级把戏，黑帽SEO垃圾曾用它来滥用系统。在那之前，搜索引擎甚至都懒得看你的风格。<em class="la">而且除了找虐和移动兼容，真的还是不在乎！</em></li><li id="dd9e" class="mg mh it kd b ke mp ki mq km mr kq ms ku mt ky ml mm mn mo bi translated">只处理列表是很难编码的。</li><li id="5b0c" class="mg mh it kd b ke mp ki mq km mr kq ms ku mt ky ml mm mn mo bi translated">您还必须在脚本中硬编码对他的功能的调用。它不是简单地为你“自动挂钩”东西。</li></ul><p id="a8a3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我没有把那放在他身上，他只是做大多数人做的和大多数教程教的。人们通常是这样编写JavaScript的，因为他们从来没有学习过可访问性、渐进增强、优雅退化，甚至是HTML实际上是什么的最基本的概念；更不用说它的实际用途了。</p><p id="1944" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你被bootcrap、tailwind、jquery、react、angular、vue等各种垃圾框架所迷惑，那就更是如此了。说火车失事灾难如何不使用HTML，CSS，或JavaScript充斥着不良做法，告诉用户有访问需要去犁自己。</p><p id="978a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="la">相信我，我的日常工作是作为一名无障碍和效率顾问的自由职业者。我看到所说的“框架”和破损的方法论导致开发者在几乎每个合同上都走向失败。</em></p><p id="369c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但问题是，JavaScript本身并不是这里的问题。事实上，如果做得更好，我们几乎可以消除所有这些问题！</p><h1 id="029a" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">那么我们如何做得更好呢？</h1><p id="2fa6" class="pw-post-body-paragraph kb kc it kd b ke mb kg kh ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky im bi translated">依我看，有两种好的处理方式，各有利弊:</p><ol class=""><li id="7fac" class="mg mh it kd b ke kf ki kj km mi kq mj ku mk ky my mm mn mo bi translated">使用JavaScript，但实现了一个优雅的降级计划。我们的最终目标是当脚本被禁用时，我们的语义标记行为正常。</li><li id="e9ef" class="mg mh it kd b ke mp ki mq km mr kq ms ku mt ky my mm mn mo bi translated">通过:checked属性“滥用”一个<code class="fe mu mv mw mx b">&lt;input type=”checkbox”&gt;</code>作为CSS的开关。这种方式不需要JavaScript就能运行。</li></ol><p id="e068" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这两种技术都可以利用“任意兄弟组合子”来显示/隐藏后面的元素。同样，它们都以父元素为目标，因此相邻的兄弟组合符可以用于更改打开/关闭按钮中的文本。</p><h1 id="d01b" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">照本宣科的方式</h1><p id="f814" class="pw-post-body-paragraph kb kc it kd b ke mb kg kh ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky im bi translated">当使用JavaScript时，最好的方法之一是使用一个类来说明你希望哪个元素默认显示为最后一个元素，隐藏其后的所有内容。只使用一个类，我们就可以“遍历DOM”来获得它的父类。</p><h2 id="fc36" class="mz le it bd lf na nb dn lj nc nd dp ln km ne nf lr kq ng nh lv ku ni nj lz nk bi translated">利润</h2><pre class="nl nm nn no gt np mx nq nr aw ns bi"><span id="d58a" class="mz le it mx b gy nt nu l nv nw">&lt;h1&gt;Collapsible Section Demo&lt;/h1&gt;</span><span id="e939" class="mz le it mx b gy nx nu l nv nw">&lt;h2&gt;Fruits&lt;/h2&gt;<br/>&lt;ul&gt;<br/> &lt;li&gt;Tomato 🍅&lt;/li&gt;<br/> &lt;li class="collapseAfter"&gt;Grapes 🍇&lt;/li&gt;<br/> &lt;li&gt;Watermelon 🍉&lt;/li&gt;<br/> &lt;li&gt;Mango 🥭&lt;/li&gt;<br/> &lt;li&gt;Peach 🍑&lt;/li&gt;<br/>&lt;/ul&gt;</span><span id="166d" class="mz le it mx b gy nx nu l nv nw">&lt;h2&gt;Vegetables&lt;/h2&gt;<br/>&lt;ul&gt;<br/> &lt;li&gt;Broccoli 🥦&lt;/li&gt;<br/> &lt;li class="collapseAfter"&gt;Corn 🌽&lt;/li&gt;<br/> &lt;li&gt;Carrot 🥕&lt;/li&gt;<br/> &lt;li&gt;Eggplant 🍆&lt;/li&gt;<br/>&lt;/ul&gt;</span><span id="0479" class="mz le it mx b gy nx nu l nv nw">&lt;h2&gt;Test Section&lt;/h2&gt;<br/>&lt;div&gt;<br/>  &lt;p class="collapseAfter"&gt;<br/>    The first paragraph will show all the time, however later paragraphs will not. This method works on ANY markup so long as there's a common parent wrapper, such as a &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;<br/>  &lt;/p&gt;&lt;p&gt;<br/>    Lorem ipsum dolor sit amet, consectetur adipiscing elit. Vivamus vel nibh et dolor dignissim tempor vel vel ante. Fusce vehicula vitae elit eu commodo. Vivamus consectetur diam vitae ligula gravida, sit amet dignissim libero ultricies. Sed at efficitur dolor, ut eleifend arcu. Ut porta volutpat lobortis. Nullam sit amet est ac mauris sollicitudin ultricies. Donec maximus, velit vel lacinia faucibus, odio urna suscipit sem, at tincidunt tortor leo id orci. Nam iaculis tristique ligula. Vivamus urna ligula, iaculis a tellus sed, feugiat venenatis tellus. Maecenas ullamcorper neque at vestibulum cursus. Ut urna sapien, tempus ut ornare eget, ultrices vitae nisl.<br/>  &lt;p&gt;&lt;p&gt;<br/>    Interdum et malesuada fames ac ante ipsum primis in faucibus. Duis commodo dui lectus, id elementum lectus condimentum a. Maecenas feugiat ornare lorem, ac tincidunt purus ultricies eget. Ut fringilla pharetra mi sed sodales. Cras accumsan eleifend massa, et ullamcorper ante tempus ut. Nam dolor diam, finibus a felis et, lacinia viverra dui. Donec magna leo, vestibulum id urna sit amet, dapibus pharetra orci. Sed sodales et erat sed egestas. Phasellus condimentum tempus urna, id facilisis ligula maximus vel.<br/>  &lt;/p&gt;<br/>&lt;/div&gt;</span></pre><p id="2361" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如您所见，唯一“与众不同”的是段落周围的额外的<code class="fe mu mv mw mx b">&lt;div&gt;</code>父类和额外的类。我们这样做的方法是，你需要将show hide部分中的所有“兄弟”封装在一个容器中。对于/LI，这很简单，对于TBODY/TR或任何其他有组织的语义结构也是如此。对于段落或其他标签，我们需要添加一些东西。</p><h2 id="4c65" class="mz le it bd lf na nb dn lj nc nd dp ln km ne nf lr kq ng nh lv ku ni nj lz nk bi translated">Java Script语言</h2><pre class="nl nm nn no gt np mx nq nr aw ns bi"><span id="f561" class="mz le it mx b gy nt nu l nv nw">(function() {</span><span id="bdc0" class="mz le it mx b gy nx nu l nv nw">  var collapseHooks = document.getElementsByClassName('collapseAfter');</span><span id="6ae4" class="mz le it mx b gy nx nu l nv nw">  for (var hook of collapseHooks) {<br/>    <br/>    var<br/>      wrap = hook.parentNode,<br/>      a = wrap.parentNode.insertBefore(<br/>        document.createElement('a'),<br/>        wrap.nextSibling<br/>      );<br/>    a.addEventListener('click', toggleCollapse, false);<br/>    a.className = 'collapseAnchor';<br/>    a.href="#"; /* without this it's not keyboard focusable */<br/>    wrap.classList.add('closed', 'collapseWrap');<br/>    <br/>  } // for hook</span><span id="208b" class="mz le it mx b gy nx nu l nv nw">  function toggleCollapse(e) {<br/>    e.preventDefault();<br/>    e.currentTarget.previousElementSibling.classList.toggle('closed');<br/>  } // toggleCollapse</span><span id="a471" class="mz le it mx b gy nx nu l nv nw">})();</span></pre><p id="8378" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我把它放入生活中，这样范围就被隔离了。我们获取所有的元素。折叠后，依次穿过这些钩子。对于每一个，我们获取parentNode包装器，在包装器的之后创建一个锚<strong class="kd iu">，分配我们需要这个锚拥有的所有属性，然后向父节点添加类，以表明我们的脚本正在工作——<code class="fe mu mv mw mx b">.collapseWrap </code>——并且它是<code class="fe mu mv mw mx b">.closed</code>。我们的CSS只有在<code class="fe mu mv mw mx b">.collapseWrap</code>存在的情况下才适用，所以编写它的脚本就像打开/关闭不存在一样。</strong></p><p id="00f5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">请注意，如果我们不在锚点上放置href，它在大多数浏览器中都不会点击，键盘导航会跳过它。同样，我们也没有将任何内容放入锚中，因为我们可以让CSS使用生成的内容来控制/更改其中的文本。</p><p id="f406" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当我们的锚被点击时调用的<code class="fe mu mv mw mx b">toggleCollapse</code>函数简单地阻止了事件，然后切换发起事件的锚的<code class="fe mu mv mw mx b">previousElementSibling</code>上的<code class="fe mu mv mw mx b">.closed</code>类，我们知道这是我们对可以折叠的区域的包装。</p><p id="2534" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">因此，我们的事件处理程序小而快，这就是为什么我真的提倡“遍历DOM”而不是每次都试图获取/查询元素。如果你的HTML结构是一致的，你可以简单地在<code class="fe mu mv mw mx b">event.currentTarget</code>的事件处理程序中找到你想要的兄弟/父/子。</p><h2 id="fe32" class="mz le it bd lf na nb dn lj nc nd dp ln km ne nf lr kq ng nh lv ku ni nj lz nk bi translated">CSS——奇迹发生的地方</h2><pre class="nl nm nn no gt np mx nq nr aw ns bi"><span id="b8b8" class="mz le it mx b gy nt nu l nv nw">.collapseAnchor {<br/>  text-decoration:none;<br/>  color:blue;<br/>}</span><span id="921a" class="mz le it mx b gy nx nu l nv nw">.collapseAnchor:before {<br/>  content:"See Less";<br/>}</span><span id="88c7" class="mz le it mx b gy nx nu l nv nw">.collapseWrap.closed + .collapseAnchor:before {<br/>  content:"See More";<br/>}</span><span id="20e4" class="mz le it mx b gy nx nu l nv nw">.collapseAnchor:after {<br/>  content:"\25B2";<br/>  display:inline-block;<br/>  padding:0.4em 0 0 0.3em;<br/>  vertical-align:top;<br/>  font-size:0.625em;<br/>}</span><span id="aa1f" class="mz le it mx b gy nx nu l nv nw">.collapseWrap.closed + .collapseAnchor:after {<br/>  content:"\25BC";<br/>}</span><span id="61bc" class="mz le it mx b gy nx nu l nv nw">.collapseWrap.closed &gt; .collapseAfter ~ * {<br/>  position:absolute;<br/>  top:-999em;<br/>  left:-999em;<br/>}</span></pre><p id="6391" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">锚点中的文本首先生成为打开状态，然后使用相邻的兄弟组合符:"+"生成为关闭状态。这很容易让我们为每个状态设置文本。</p><p id="19a5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个小小的UTF-8三角形通常很难在浏览器中正确对齐，但是通过将它设置为内联块并添加一些填充，我们可以看到它应该在的地方，并用边距推动它。当前一个元素关闭时，将其更改为向下箭头。</p><p id="b487" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">真正的诀窍是最后一部分。当包装器有了<code class="fe mu mv mw mx b">.closed</code>类时，我们发现<code class="fe mu mv mw mx b">.collapseAfter</code>是它的子类，并隐藏它后面的任何同级标签。有些人会说“永远不要使用*选择器”,因为开销问题，但在这种情况下，这是100%的bullcookies。它的应用范围受到它前面的组合子的限制，从而将应用/渲染开销减少到零。</p><p id="4529" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">隐藏是通过绝对定位来处理的</p><h2 id="7cc3" class="mz le it bd lf na nb dn lj nc nd dp ln km ne nf lr kq ng nh lv ku ni nj lz nk bi translated">现场演示</h2><p id="4ee5" class="pw-post-body-paragraph kb kc it kd b ke mb kg kh ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky im bi translated">这是给你们的笔</p><figure class="nl nm nn no gt ju"><div class="bz fp l di"><div class="ny nz l"/></div></figure><h2 id="d1f6" class="mz le it bd lf na nb dn lj nc nd dp ln km ne nf lr kq ng nh lv ku ni nj lz nk bi translated">脚本方法的利与弊</h2><p id="3e56" class="pw-post-body-paragraph kb kc it kd b ke mb kg kh ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky im bi translated">像往常一样，让我们从问题开始。</p><p id="356c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">缺点</strong></p><ul class=""><li id="3227" class="mg mh it kd b ke kf ki kj km mi kq mj ku mk ky ml mm mn mo bi translated">依赖于JavaScript</li><li id="68b6" class="mg mh it kd b ke mp ki mq km mr kq ms ku mt ky ml mm mn mo bi translated">操作DOM的方式可能会让一些不太熟练的开发人员感到困惑</li><li id="1ba2" class="mg mh it kd b ke mp ki mq km mr kq ms ku mt ky ml mm mn mo bi translated">如果标记在其他人以后编辑时不保持一致，DOM操作可能会中断。</li></ul><p id="db67" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">优点</strong></p><ul class=""><li id="037c" class="mg mh it kd b ke kf ki kj km mi kq mj ku mk ky ml mm mn mo bi translated">非脚本化或非可视化UA，内容只是正常显示或访问。这对可访问性和搜索都有好处。</li><li id="6308" class="mg mh it kd b ke mp ki mq km mr kq ms ku mt ky ml mm mn mo bi translated">我们只需要一个类挂钩来为任何包装好的兄弟元素块添加功能。</li><li id="c757" class="mg mh it kd b ke mp ki mq km mr kq ms ku mt ky ml mm mn mo bi translated">键盘导航锚</li><li id="0626" class="mg mh it kd b ke mp ki mq km mr kq ms ku mt ky ml mm mn mo bi translated">锚及其内容在标记中不是静态的。这样做通常会增加非视觉导航的难度。</li></ul><p id="d3ec" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">但是我们能做得更好吗？</p><h1 id="28e2" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">没有JavaScript的方式</h1><p id="22c3" class="pw-post-body-paragraph kb kc it kd b ke mb kg kh ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky im bi translated">要在没有JavaScript的情况下做到这一点，我们需要在标记中添加隐藏的输入和标签，作为切换的钩子。请记住，单击一个LABEL标签与单击它所包装的任何输入是一样的，或者它是为。后者正是我们这里所需要的。</p><p id="73a3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">利润</p><pre class="nl nm nn no gt np mx nq nr aw ns bi"><span id="ce78" class="mz le it mx b gy nt nu l nv nw">&lt;h2&gt;Fruits&lt;/h2&gt;<br/>&lt;input<br/>  type="checkbox"<br/>  id="toggle_fruits"<br/>  class="toggle_collapse"<br/>  hidden<br/>  aria-hidden="true"<br/>&gt;<br/>&lt;ul&gt;<br/> &lt;li&gt;Tomato 🍅&lt;/li&gt;<br/> &lt;li class="collapseAfter"&gt;Grapes 🍇&lt;/li&gt;<br/> &lt;li&gt;Watermelon 🍉&lt;/li&gt;<br/> &lt;li&gt;Mango 🥭&lt;/li&gt;<br/> &lt;li&gt;Peach 🍑&lt;/li&gt;<br/>&lt;/ul&gt;<br/>&lt;label for="toggle_fruits" hidden aria-hidden="true"&gt;&lt;/label&gt;</span><span id="157c" class="mz le it mx b gy nx nu l nv nw">&lt;h2&gt;Vegetables&lt;/h2&gt;<br/>&lt;input<br/>  type="checkbox"<br/>  id="toggle_vegetables"<br/>  class="toggle_collapse"<br/>  hidden<br/>  aria-hidden="true"<br/>&gt;<br/>&lt;ul&gt;<br/> &lt;li&gt;Broccoli 🥦&lt;/li&gt;<br/> &lt;li class="collapseAfter"&gt;Corn 🌽&lt;/li&gt;<br/> &lt;li&gt;Carrot 🥕&lt;/li&gt;<br/> &lt;li&gt;Eggplant 🍆&lt;/li&gt;<br/>&lt;/ul&gt;<br/>&lt;label for="toggle_vegetables" hidden aria-hidden="true"&gt;&lt;/label&gt;</span><span id="9918" class="mz le it mx b gy nx nu l nv nw">&lt;h2&gt;Test Section&lt;/h2&gt;<br/>&lt;input<br/>  type="checkbox"<br/>  id="toggle_testSection"<br/>  class="toggle_collapse"<br/>  hidden<br/>  aria-hidden="true"<br/>&gt;<br/>&lt;div&gt;<br/>  &lt;p class="collapseAfter"&gt;<br/>    The first paragraph will show all the time, however later paragraphs will not. This method works on ANY markup so long as there's a common parent wrapper, such as a &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;<br/>  &lt;/p&gt;&lt;p&gt;<br/>    Lorem ipsum dolor sit amet, consectetur adipiscing elit. Vivamus vel nibh et dolor dignissim tempor vel vel ante. Fusce vehicula vitae elit eu commodo. Vivamus consectetur diam vitae ligula gravida, sit amet dignissim libero ultricies. Sed at efficitur dolor, ut eleifend arcu. Ut porta volutpat lobortis. Nullam sit amet est ac mauris sollicitudin ultricies. Donec maximus, velit vel lacinia faucibus, odio urna suscipit sem, at tincidunt tortor leo id orci. Nam iaculis tristique ligula. Vivamus urna ligula, iaculis a tellus sed, feugiat venenatis tellus. Maecenas ullamcorper neque at vestibulum cursus. Ut urna sapien, tempus ut ornare eget, ultrices vitae nisl.<br/>  &lt;p&gt;&lt;p&gt;<br/>    Interdum et malesuada fames ac ante ipsum primis in faucibus. Duis commodo dui lectus, id elementum lectus condimentum a. Maecenas feugiat ornare lorem, ac tincidunt purus ultricies eget. Ut fringilla pharetra mi sed sodales. Cras accumsan eleifend massa, et ullamcorper ante tempus ut. Nam dolor diam, finibus a felis et, lacinia viverra dui. Donec magna leo, vestibulum id urna sit amet, dapibus pharetra orci. Sed sodales et erat sed egestas. Phasellus condimentum tempus urna, id facilisis ligula maximus vel.<br/>  &lt;/p&gt;<br/>&lt;/div&gt;<br/>&lt;label for="toggle_testSection" hidden aria-hidden="true"&gt;&lt;/label&gt;</span></pre><p id="5542" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用<code class="fe mu mv mw mx b">hidden</code>和<code class="fe mu mv mw mx b">aria-hidden=”true”</code>属性告诉所有用户代理忽略这些元素。为了使它们不被所有屏幕媒体忽略，我们需要在CSS中将它们设置为显示状态。</p><p id="fc9d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">记住，在产品中，你所有的CSS都应该通过<link/>和一个适合你目标设备的<code class="fe mu mv mw mx b">media=””</code>来包含。在我们的例子中是“屏幕”。如果你看到一个样式表<code class="fe mu mv mw mx b">&lt;link&gt;</code>或<code class="fe mu mv mw mx b">&lt;style&gt;</code>缺少media=" <em class="la"> something </em>"或设置为media="all "，你看到的是web开发中令人讨厌的3i:无知、无能和不称职。<em class="la">是的bootcrap，tailwind，还有其他的，</em> <strong class="kd iu"> <em class="la">我在跟你说话！</em> </strong></p><h2 id="317f" class="mz le it bd lf na nb dn lj nc nd dp ln km ne nf lr kq ng nh lv ku ni nj lz nk bi translated">CSS——更加神奇</h2><pre class="nl nm nn no gt np mx nq nr aw ns bi"><span id="6079" class="mz le it mx b gy nt nu l nv nw">.toggle_collapse {<br/>  /* make it show to work across all ua's */  <br/>  display:block; <br/>}</span><span id="c628" class="mz le it mx b gy nx nu l nv nw">.toggle_collapse, /* hide off screen */<br/>.toggle_collapse + * &gt; .collapseAfter ~ * {<br/> position:absolute;<br/> top:-999em;<br/> left:-999em;<br/>}</span><span id="55d1" class="mz le it mx b gy nx nu l nv nw">.toggle_collapse:checked + *  .collapseAfter ~ * {<br/>  position:static;<br/>}</span><span id="1c42" class="mz le it mx b gy nx nu l nv nw">.toggle_collapse + * + label {<br/>  display:inline-block; /* make visible for screen media */<br/>  color:blue;<br/>}</span><span id="ed0c" class="mz le it mx b gy nx nu l nv nw">.toggle_collapse + * + label:before {<br/> content:"See More";<br/>}</span><span id="fe47" class="mz le it mx b gy nx nu l nv nw">.toggle_collapse:checked + * + label:before {<br/> content:"See Less";<br/>}</span><span id="ee63" class="mz le it mx b gy nx nu l nv nw">.toggle_collapse + * + label:after {<br/> content:"\25BC";<br/> display:inline-block;<br/> padding:0.4em 0 0 0.3em;<br/> vertical-align:top;<br/> font-size:0.625em;<br/>}</span><span id="5cf5" class="mz le it mx b gy nx nu l nv nw">.toggle_collapse:checked + * + label:after {<br/> content:"\25B2";<br/>}</span></pre><p id="1dc7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">与我们的脚本版本惊人地相似。首先，我们必须让我们的“隐藏”元素显示出来，以便它们在屏幕媒体上可以正确地通过键盘导航，但是我们仍然希望它们隐藏起来，所以我们将它们移出屏幕。将它们隐藏在屏幕之外的代码与我们的隐藏状态共享，因为两者需要做同样的事情。</p><p id="46af" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">隐藏状态的选择器要复杂得多:</p><pre class="nl nm nn no gt np mx nq nr aw ns bi"><span id="24a7" class="mz le it mx b gy nt nu l nv nw">.toggle_collapse + * &gt; .collapseAfter ~ * {</span></pre><p id="2f0d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">基本上，无论什么标签紧跟在我们的<code class="fe mu mv mw mx b">INPUT.toggleCollapse </code>之后，我们都会寻找一个collapseAfter子标签，并隐藏它之后的所有兄弟标签。同样，有些人会因为使用any元素选择器而紧张，这样做只会显示出他们的无知。</p><p id="e6c4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">由于选中状态将是我们的关闭状态，我们最终不得不交换关闭/打开文本和箭头…但在大多数情况下，CSS的工作方式与脚本版本几乎相同。</p><p id="fb4f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">现场演示</strong></p><figure class="nl nm nn no gt ju"><div class="bz fp l di"><div class="ny nz l"/></div></figure><h2 id="b919" class="mz le it bd lf na nb dn lj nc nd dp ln km ne nf lr kq ng nh lv ku ni nj lz nk bi translated">非脚本版本的优缺点</h2><p id="acd6" class="pw-post-body-paragraph kb kc it kd b ke mb kg kh ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky im bi translated">你也必须权衡这样做的各种问题。</p><p id="6e36" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">缺点</strong></p><ul class=""><li id="ebdb" class="mg mh it kd b ke kf ki kj km mi kq mj ku mk ky ml mm mn mo bi translated">更多的标记</li><li id="9302" class="mg mh it kd b ke mp ki mq km mr kq ms ku mt ky ml mm mn mo bi translated">对于那些不熟悉以这种方式滥用隐藏输入的人来说，标记令人困惑</li><li id="6c4a" class="mg mh it kd b ke mp ki mq km mr kq ms ku mt ky ml mm mn mo bi translated">不知道“hidden”或“aria-hidden”的较老的UA在没有应用CSS时会被挂起，或者使用户对输入标签感到困惑。</li></ul><p id="fe0a" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">优点</strong></p><ul class=""><li id="9809" class="mg mh it kd b ke kf ki kj km mi kq mj ku mk ky ml mm mn mo bi translated">没有JavaScript，甚至适用于访问脚本被阻止/禁用/不可用的屏幕媒体用户！</li><li id="b436" class="mg mh it kd b ke mp ki mq km mr kq ms ku mt ky ml mm mn mo bi translated">在现代用户界面中，屏幕阅读器、盲文阅读器、搜索引擎或其他非视觉用户界面不存在令人不快的额外元素</li><li id="fdaf" class="mg mh it kd b ke mp ki mq km mr kq ms ku mt ky ml mm mn mo bi translated">输入的键盘导航<em class="la">(尽管可能会添加一些额外的CSS来使其更加明显)</em></li></ul><h1 id="ecd6" class="ld le it bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">结论</h1><p id="e217" class="pw-post-body-paragraph kb kc it kd b ke mb kg kh ki mc kk kl km md ko kp kq me ks kt ku mf kw kx ky im bi translated">这两种方法都有优点。脚本版本真的很好，因为你所要做的就是确保有一个通用的包装器，并在你希望中断/折叠发生的地方应用这个类。只要你在一个屏幕媒体设备上，非脚本化的就能工作。两者都优雅地退化为非视觉化和非脚本化的可用性和可访问性，因为每一个努力都被投入到点点滴滴和跨越I…<em class="la">或…嗯…什么的。</em></p><p id="ae1e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如今，CSS让我们做的事情确实令人惊讶，但仍然有很好的理由使用JavaScript，只要你“把它放在裤子里”，让CSS做大部分“真正的工作”。在这两种方法中，我实际上向知道自己在做什么的人推荐CSS方法，向初学者或喜欢只需要一个类就能应用它的便利的人推荐JavaScript方法。老实说，我会根据具体情况做出决定。</p></div></div>    
</body>
</html>