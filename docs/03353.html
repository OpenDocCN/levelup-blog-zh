<html>
<head>
<title>Dagger 2 — Leveraging Scopes and Subcomponents</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Dagger 2 —利用范围和子组件</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/dagger-2-leveraging-subcomponents-and-scopes-2aef78a291c9?source=collection_archive---------18-----------------------#2020-05-04">https://levelup.gitconnected.com/dagger-2-leveraging-subcomponents-and-scopes-2aef78a291c9?source=collection_archive---------18-----------------------#2020-05-04</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/c2ec7acf29dd2e06790273942fa94b08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ACswuFqE3XeqAHtT"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">克里斯·劳顿在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h2 id="31cd" class="kg kh it bd ki kj kk dn kl km kn dp ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated"><strong class="ak">范围是什么意思？</strong></h2><p id="fcb3" class="pw-post-body-paragraph lc ld it le b lf lg lh li lj lk ll lm kp ln lo lp kt lq lr ls kx lt lu lv lw im bi translated">范围是指对象的生存期。考虑一个简单类的例子。</p><figure class="lx ly lz ma gt ju"><div class="bz fp l di"><div class="mb mc l"/></div></figure><ul class=""><li id="145a" class="md me it le b lf mf lj mg kp mh kt mi kx mj lw mk ml mm mn bi translated"><code class="fe mo mp mq mr b">largeScope</code> —它的作用域与类的生存期相关联。可以在类中的任何地方访问它。</li><li id="e3ef" class="md me it le b lf ms lj mt kp mu kt mv kx mw lw mk ml mm mn bi translated"><code class="fe mo mp mq mr b">smallerScope</code> —其范围仅限于函数的生存期。它只能在<code class="fe mo mp mq mr b">myFunction</code>块中访问。在这个函数之外它是不被识别的。</li><li id="fc57" class="md me it le b lf ms lj mt kp mu kt mv kx mw lw mk ml mm mn bi translated">范围意味着定义对象的生存期。</li></ul><h2 id="b484" class="kg kh it bd ki kj kk dn kl km kn dp ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">为什么作用域很重要，它在Dagger中有什么用途？</h2><p id="ea34" class="pw-post-body-paragraph lc ld it le b lf lg lh li lj lk ll lm kp ln lo lp kt lq lr ls kx lt lu lv lw im bi translated">匕首里的瞄准镜没什么不同。考虑一个购物应用程序，您可以浏览不同的屏幕(👇)，将商品加入购物车，最后进行支付。</p><figure class="lx ly lz ma gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mx"><img src="../Images/7fb5ad705131470d2f3d030329a7623a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wH1noc3uePXB6kA1qoUWcw.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">浏览和支付屏幕</figcaption></figure><p id="92bc" class="pw-post-body-paragraph lc ld it le b lf mf lh li lj mg ll lm kp my lo lp kt mz lr ls kx na lu lv lw im bi translated">让我们看看这是如何实现的。</p><ol class=""><li id="36bb" class="md me it le b lf mf lj mg kp mh kt mi kx mj lw nb ml mm mn bi translated"><code class="fe mo mp mq mr b">HomePage</code>、<code class="fe mo mp mq mr b">CategoryPage</code>和<code class="fe mo mp mq mr b">BrandPage</code>是依赖于<code class="fe mo mp mq mr b">ProductRepository</code>的浏览画面。</li><li id="60d1" class="md me it le b lf ms lj mt kp mu kt mv kx mw lw nb ml mm mn bi translated"><code class="fe mo mp mq mr b">PaymentPage</code>依靠<code class="fe mo mp mq mr b">PaymentRepository</code>进行支付。</li></ol><p id="5e13" class="pw-post-body-paragraph lc ld it le b lf mf lh li lj mg ll lm kp my lo lp kt mz lr ls kx na lu lv lw im bi translated">一种常见的模式是在应用程序启动时立即创建两个存储库，将它们存储在Dagger图中，并提供给不同的屏幕。这是它看起来的样子。Appcomponent提供了这两种存储库。</p><figure class="lx ly lz ma gt ju"><div class="bz fp l di"><div class="mb mc l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">提供所有依赖关系的Appcomponent</figcaption></figure><p id="b033" class="pw-post-body-paragraph lc ld it le b lf mf lh li lj mg ll lm kp my lo lp kt mz lr ls kx na lu lv lw im bi translated">在主页和支付页面使用它进行注射。</p><figure class="lx ly lz ma gt ju"><div class="bz fp l di"><div class="mb mc l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">使用app组件进行注入</figcaption></figure><p id="af6a" class="pw-post-body-paragraph lc ld it le b lf mf lh li lj mg ll lm kp my lo lp kt mz lr ls kx na lu lv lw im bi translated">只要应用程序还活着，在应用程序级别创建的存储库就会一直存在。请求它们的屏幕将获得相同的存储库实例。</p><p id="2e2d" class="pw-post-body-paragraph lc ld it le b lf mf lh li lj mg ll lm kp my lo lp kt mz lr ls kx na lu lv lw im bi translated"><strong class="le iu">关注点</strong>:这完全没问题，因为存储库通常是无状态的，只作为一个助手类从API获取数据。但是当存储库做更多的事情时，问题就出现了。</p><p id="c294" class="pw-post-body-paragraph lc ld it le b lf mf lh li lj mg ll lm kp my lo lp kt mz lr ls kx na lu lv lw im bi translated">假设<code class="fe mo mp mq mr b">PaymentRepository</code>设置不同支付厂商的SDK，运行API服务以保持会话活跃，并定期发送位置更新。在这种情况下，存储库的创建和处理将是一件昂贵的事情。这将需要更多的时间来初始化，并张贴它不断消耗资源，如网络资源和电池，只要它还活着。</p><blockquote class="nc nd ne"><p id="d96b" class="lc ld nf le b lf mf lh li lj mg ll lm ng my lo lp nh mz lr ls ni na lu lv lw im bi translated">支付存储库问题=初始化+资源消耗</p></blockquote><p id="8e19" class="pw-post-body-paragraph lc ld it le b lf mf lh li lj mg ll lm kp my lo lp kt mz lr ls kx na lu lv lw im bi translated"><strong class="le iu">如何克服这一点？— </strong>每次打开应用程序，你最终都会进行购买，这种情况并不常见。所以更好的方法是，</p><ul class=""><li id="e714" class="md me it le b lf mf lj mg kp mh kt mi kx mj lw mk ml mm mn bi translated">仅在需要时创建[在<strong class="le iu"> T2 </strong>创建]</li><li id="6a3d" class="md me it le b lf ms lj mt kp mu kt mv kx mw lw mk ml mm mn bi translated">仅在支付会话有效时保留它[在<strong class="le iu"> T3 </strong>销毁它]。</li></ul><figure class="lx ly lz ma gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nj"><img src="../Images/27d6109da3720d5d386e1cd051233d4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4dcC1KVWg_bpHx9_lBW1eA.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">范围的图形表示</figcaption></figure></div><div class="ab cl nk nl hx nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="im in io ip iq"><h1 id="1981" class="nr kh it bd ki ns nt nu kl nv nw nx ko ny nz oa ks ob oc od kw oe of og la oh bi translated">履行</h1><h2 id="6242" class="kg kh it bd ki kj kk dn kl km kn dp ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">1.定义范围</h2><figure class="lx ly lz ma gt ju"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="5aba" class="pw-post-body-paragraph lc ld it le b lf mf lh li lj mg ll lm kp my lo lp kt mz lr ls kx na lu lv lw im bi translated"><code class="fe mo mp mq mr b">AppScope</code>和<code class="fe mo mp mq mr b">PaymentScope</code>是两个范围。AppScope指的是应用的生命周期，<code class="fe mo mp mq mr b">PaymentScope</code>指的是支付功能的生命周期。当它们与组件相关联时，范围就有了意义👇。</p><h2 id="ee91" class="kg kh it bd ki kj kk dn kl km kn dp ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated"><strong class="ak"> 2。正在创建AppComponent </strong></h2><figure class="lx ly lz ma gt ju"><div class="bz fp l di"><div class="mb mc l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">AppComponent.kt</figcaption></figure><p id="c128" class="pw-post-body-paragraph lc ld it le b lf mf lh li lj mg ll lm kp my lo lp kt mz lr ls kx na lu lv lw im bi translated"><code class="fe mo mp mq mr b">AppComponent</code>与AppScope相关联。它是在<code class="fe mo mp mq mr b">ShoppingApplication</code>类【应用层】中创建的。因为它是在应用程序级别创建的，所以它的图表只在应用程序启动时构建一次，并在应用程序被销毁之前一直使用。</p><p id="a3c3" class="pw-post-body-paragraph lc ld it le b lf mf lh li lj mg ll lm kp my lo lp kt mz lr ls kx na lu lv lw im bi translated">下面是使用AppComponent为主页注入依赖项的演示。对于类别和品牌页面也可以这样做。</p><figure class="lx ly lz ma gt ju"><div class="bz fp l di"><div class="mb mc l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">主页从AppComponent获取依赖关系。</figcaption></figure><h2 id="9510" class="kg kh it bd ki kj kk dn kl km kn dp ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">3.创建支付组件</h2><p id="da64" class="pw-post-body-paragraph lc ld it le b lf lg lh li lj lk ll lm kp ln lo lp kt lq lr ls kx lt lu lv lw im bi translated">与在应用程序级别创建的AppComponent不同，支付组件是在支付功能级别创建的。该组件可以有两种类型。</p><ul class=""><li id="b51f" class="md me it le b lf mf lj mg kp mh kt mi kx mj lw mk ml mm mn bi translated">首先，<code class="fe mo mp mq mr b">PaymentComponent</code>可以从另一个组件(<code class="fe mo mp mq mr b">AppComponent</code>)请求依赖关系。在这种情况下，PaymentComponent将是AppComponent的子组件。</li><li id="1cc6" class="md me it le b lf ms lj mt kp mu kt mv kx mw lw mk ml mm mn bi translated">第二，<code class="fe mo mp mq mr b">PaymentComponent</code>可以是一个独立的组件，并且自己满足所有的依赖关系。</li></ul><p id="f7ca" class="pw-post-body-paragraph lc ld it le b lf mf lh li lj mg ll lm kp my lo lp kt mz lr ls kx na lu lv lw im bi translated"><strong class="le iu"> 3.1 <em class="nf">当PaymentComponent依赖于app component</em>T23】</strong></p><p id="728f" class="pw-post-body-paragraph lc ld it le b lf mf lh li lj mg ll lm kp my lo lp kt mz lr ls kx na lu lv lw im bi translated"><code class="fe mo mp mq mr b">AppComponent</code>和<code class="fe mo mp mq mr b">PaymentSubcomponent</code>有父子关系。子节点所需的一些依赖项由父节点提供。在这种情况下，组件被定义为子组件。</p><figure class="lx ly lz ma gt ju"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="d9c4" class="pw-post-body-paragraph lc ld it le b lf mf lh li lj mg ll lm kp my lo lp kt mz lr ls kx na lu lv lw im bi translated"><code class="fe mo mp mq mr b">@Subcomponent</code>注释意味着它是一个子组件，要构建它，它需要一个父组件(AppComponent)。</p><p id="a4e4" class="pw-post-body-paragraph lc ld it le b lf mf lh li lj mg ll lm kp my lo lp kt mz lr ls kx na lu lv lw im bi translated"><code class="fe mo mp mq mr b">UserSession</code>PaymentSubcomponent需要的依赖关系应该由它的父AppComponent提供。</p><blockquote class="nc nd ne"><p id="53f1" class="lc ld nf le b lf mf lh li lj mg ll lm ng my lo lp nh mz lr ls ni na lu lv lw im bi translated">注意:子组件不知道它的父组件。父组件有责任包含子组件并提供必要的依赖关系。</p></blockquote><p id="783a" class="pw-post-body-paragraph lc ld it le b lf mf lh li lj mg ll lm kp my lo lp kt mz lr ls kx na lu lv lw im bi translated">相应地，<code class="fe mo mp mq mr b">AppComponent</code>应该声明它将满足PaymentSubcomponent的依赖关系。要使AppComponent充当父组件，需要进行以下更改。请注意，它提供了其子节点所需的<code class="fe mo mp mq mr b">UserSession</code>。</p><figure class="lx ly lz ma gt ju"><div class="bz fp l di"><div class="mb mc l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">PaymentSubcomponent.kt从另一个组件请求依赖关系</figcaption></figure><p id="59e1" class="pw-post-body-paragraph lc ld it le b lf mf lh li lj mg ll lm kp my lo lp kt mz lr ls kx na lu lv lw im bi translated">使用PaymentSubcomponent在PaymentPage中提供依赖关系👇🏻。</p><figure class="lx ly lz ma gt ju"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="e1f2" class="pw-post-body-paragraph lc ld it le b lf mf lh li lj mg ll lm kp my lo lp kt mz lr ls kx na lu lv lw im bi translated"><strong class="le iu"> 3.2 <em class="nf">支付组件独立时</em>T10】</strong></p><p id="c62e" class="pw-post-body-paragraph lc ld it le b lf mf lh li lj mg ll lm kp my lo lp kt mz lr ls kx na lu lv lw im bi translated">这很简单，因为它本身满足了所有的依赖关系。将其声明为普通组件，并在支付页面中构建。</p><figure class="lx ly lz ma gt ju"><div class="bz fp l di"><div class="mb mc l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">payment component . kt——满足其自身的依赖性</figcaption></figure><figure class="lx ly lz ma gt ju"><div class="bz fp l di"><div class="mb mc l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">使用PaymentComponent的支付页面</figcaption></figure><p id="f8dc" class="pw-post-body-paragraph lc ld it le b lf mf lh li lj mg ll lm kp my lo lp kt mz lr ls kx na lu lv lw im bi translated">在上述两种情况下，<code class="fe mo mp mq mr b">PaymentSubcomponent(3.1)</code> &amp; <code class="fe mo mp mq mr b">PaymentComponent(3.2)</code>都是在PaymentPage中创建的，它们一直存在，直到活动被销毁。这样，它的范围仅限于PaymentPage的生存期。</p><p id="f3d1" class="pw-post-body-paragraph lc ld it le b lf mf lh li lj mg ll lm kp my lo lp kt mz lr ls kx na lu lv lw im bi translated"><strong class="le iu">结论</strong></p><ul class=""><li id="a921" class="md me it le b lf mf lj mg kp mh kt mi kx mj lw mk ml mm mn bi translated">AppComponent是在应用程序级别创建的(在Application类中)。所以构建AppComponent的图形所花费的时间会影响应用程序的启动时间。为了获得更好的性能，考虑在开始时只初始化记录器、API客户端、崩溃逻辑、分析、用户会话等。</li><li id="f918" class="md me it le b lf ms lj mt kp mu kt mv kx mw lw mk ml mm mn bi translated">请注意，<code class="fe mo mp mq mr b">PaymentComponent</code>和<code class="fe mo mp mq mr b">PaymentSubcomponent</code>只有在应用程序导航到限制其生命周期的支付页面时才会构建。当<code class="fe mo mp mq mr b">PaymentPage</code>被摧毁时，它也被摧毁。</li><li id="b4f7" class="md me it le b lf ms lj mt kp mu kt mv kx mw lw mk ml mm mn bi translated">从今以后，最好将依赖项分离到不同的组件中，而不是将所有东西都集成到一个单独的AppComponent中。这样你就有能力控制他们的一生。</li></ul><p id="693e" class="pw-post-body-paragraph lc ld it le b lf mf lh li lj mg ll lm kp my lo lp kt mz lr ls kx na lu lv lw im bi translated">您还可以查看<strong class="le iu">依赖组件</strong>，它类似于子组件。但是相反，子组件知道父组件，而父组件不知道它的从属组件。这在使用动态特征模块时很有用。</p></div></div>    
</body>
</html>