<html>
<head>
<title>Using the Node.js OS Module (Part 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Node.js操作系统模块(第2部分)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/using-the-node-js-os-module-part-2-9d6a793cc302?source=collection_archive---------5-----------------------#2019-12-26">https://levelup.gitconnected.com/using-the-node-js-os-module-part-2-9d6a793cc302?source=collection_archive---------5-----------------------#2019-12-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/0a7db8fe761c3af747da0e16545f20d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*EOfgyjpVxSHpSp2j"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@brookecagle?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">布鲁克·卡吉尔</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="738d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Node.js OS模块有许多有用的实用函数，用于获取运行该OS模块程序的计算机系统的信息。它可以提供关于硬件的信息，如CPU、字节序、主目录、IP地址、主机名、程序运行的平台、系统正常运行时间、关于当前登录用户的信息等等。</p><p id="8377" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以通过在代码顶部写<code class="fe le lf lg lh b">const os = require('os');</code>来使用OS模块。OS模块中有许多有用的属性。以下是操作系统模块中更有用的属性:</p><h1 id="53f1" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">os.cpus</h1><p id="58c4" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated"><code class="fe le lf lg lh b">os.cpus()</code>函数返回一个对象数组，该数组包含关于主机CPU的每个逻辑核心的各种信息。每个条目都有一些属性。有一个<code class="fe le lf lg lh b">model</code>属性，它是一个表示计算机CPU型号的字符串。<code class="fe le lf lg lh b">speed</code>属性是一个以兆赫为单位的数字属性。<code class="fe le lf lg lh b">times</code>属性是一个具有以下属性的对象:</p><ul class=""><li id="4101" class="ml mm it ki b kj kk kn ko kr mn kv mo kz mp ld mq mr ms mt bi translated"><code class="fe le lf lg lh b">user</code> —一个数字属性，表示CPU在用户模式下花费的毫秒数。</li><li id="2cae" class="ml mm it ki b kj mu kn mv kr mw kv mx kz my ld mq mr ms mt bi translated"><code class="fe le lf lg lh b">nice</code> —一个数字属性，指示CPU在nice模式下花费的毫秒数。Nice模式是指CPU运行具有正nice值的进程，这意味着一个优先级较低的进程。</li><li id="546c" class="ml mm it ki b kj mu kn mv kr mw kv mx kz my ld mq mr ms mt bi translated"><code class="fe le lf lg lh b">sys</code> —一个数字属性，表示CPU在sys模式下花费的毫秒数。</li><li id="f43d" class="ml mm it ki b kj mu kn mv kr mw kv mx kz my ld mq mr ms mt bi translated"><code class="fe le lf lg lh b">idle</code> —一个数字属性，表示CPU处于空闲模式的毫秒数。当CPU不被任何程序使用时，它就是空闲的。</li><li id="5881" class="ml mm it ki b kj mu kn mv kr mw kv mx kz my ld mq mr ms mt bi translated"><code class="fe le lf lg lh b">irq</code> —一个数字属性，表示CPU在IRQ模式下花费的毫秒数。IRQ是一个硬件信号，它使CPU暂时停止一个正在运行的程序，而允许一个中断处理程序运行。</li></ul><p id="c100" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以像下面这样使用函数:</p><pre class="mz na nb nc gt nd lh ne nf aw ng bi"><span id="a645" class="nh lj it lh b gy ni nj l nk nl">console.log(os.cpus());</span></pre><p id="2ca1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以得到类似如下的输出:</p><pre class="mz na nb nc gt nd lh ne nf aw ng bi"><span id="6b5a" class="nh lj it lh b gy ni nj l nk nl">[ { model: 'Intel(R) Xeon(R) CPU @ 2.30GHz',<br/>    speed: 2300,<br/>    times:<br/>     { user: 3367100, nice: 0, sys: 757800, idle: 9833900, irq: 0 } },<br/>  { model: 'Intel(R) Xeon(R) CPU @ 2.30GHz',<br/>    speed: 2300,<br/>    times:<br/>     { user: 3387000, nice: 0, sys: 730100, idle: 10054300, irq: 0 } },<br/>  { model: 'Intel(R) Xeon(R) CPU @ 2.30GHz',<br/>    speed: 2300,<br/>    times:<br/>     { user: 3259600, nice: 0, sys: 748300, idle: 10168800, irq: 0 } },<br/>  { model: 'Intel(R) Xeon(R) CPU @ 2.30GHz',<br/>    speed: 2300,<br/>    times:<br/>     { user: 3229700, nice: 0, sys: 755800, idle: 10195600, irq: 0 } } ]</span></pre><h1 id="d464" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">操作系统端序</h1><p id="bcad" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated"><code class="fe le lf lg lh b">os.endianness()</code>函数返回一个字符串，标识编译Node.js运行时二进制文件的CPU的字节顺序。两个可能的值是:</p><ul class=""><li id="906a" class="ml mm it ki b kj kk kn ko kr mn kv mo kz mp ld mq mr ms mt bi translated"><code class="fe le lf lg lh b">'BE'</code> —大端。大端CPU顺序首先放置最高有效字节，最后放置最低有效字节。</li><li id="b5cd" class="ml mm it ki b kj mu kn mv kr mw kv mx kz my ld mq mr ms mt bi translated"><code class="fe le lf lg lh b">'LE'</code> —小端序，大端序的反义词。</li></ul><p id="df3a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们对<code class="fe le lf lg lh b">os.endianness()</code>的返回值运行<code class="fe le lf lg lh b">console.log</code>，我们可能会得到如下结果:</p><pre class="mz na nb nc gt nd lh ne nf aw ng bi"><span id="91cf" class="nh lj it lh b gy ni nj l nk nl">'LE'</span></pre><h1 id="f65e" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">os.freemem</h1><p id="4fec" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated"><code class="fe le lf lg lh b">os.freemem()</code>函数返回一个整数，以字节数表示空闲内存的数量。如果我们对<code class="fe le lf lg lh b">os.freemem()</code>的输出运行<code class="fe le lf lg lh b">console.log</code>，我们会得到如下结果:</p><pre class="mz na nb nc gt nd lh ne nf aw ng bi"><span id="8794" class="nh lj it lh b gy ni nj l nk nl">15338930176</span></pre><h1 id="6cad" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">os.getPriority</h1><p id="b0a5" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated"><code class="fe le lf lg lh b">os.getPriority</code>函数返回一个整数，表示PID指定的进程的调度优先级。它有一个参数，即作为整数传入的进程ID。如果没有提供PID或者PID为0，那么返回当前进程的优先级。例如，如果我们写:</p><pre class="mz na nb nc gt nd lh ne nf aw ng bi"><span id="dca8" class="nh lj it lh b gy ni nj l nk nl">os.getPriority()</span></pre><p id="3cf2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们得到一个数字。19表示最低的CPU优先级，而-20表示最高。Node.js中的处理器优先级由以下常量定义:</p><ul class=""><li id="908a" class="ml mm it ki b kj kk kn ko kr mn kv mo kz mp ld mq mr ms mt bi translated"><code class="fe le lf lg lh b">PRIORITY_LOW </code> —最低的进程调度优先级。这对应于Windows上的<code class="fe le lf lg lh b">IDLE_PRIORITY_CLASS</code>和所有其他平台上的19。</li><li id="01c2" class="ml mm it ki b kj mu kn mv kr mw kv mx kz my ld mq mr ms mt bi translated"><code class="fe le lf lg lh b">PRIORITY_BELOW_NORMAL</code> —这在Windows上对应于<code class="fe le lf lg lh b">BELOW_NORMAL_PRIORITY_CLASS</code>，在所有其他平台上对应于10。</li><li id="18cf" class="ml mm it ki b kj mu kn mv kr mw kv mx kz my ld mq mr ms mt bi translated"><code class="fe le lf lg lh b">PRIORITY_NORMAL</code> —默认进程调度优先级。这对应于Windows上的<code class="fe le lf lg lh b">NORMAL_PRIORITY_CLASS</code>和所有其他平台上的0值。</li><li id="e0aa" class="ml mm it ki b kj mu kn mv kr mw kv mx kz my ld mq mr ms mt bi translated"><code class="fe le lf lg lh b">PRIORITY_ABOVE_NORMAL</code> —这在Windows上对应于<code class="fe le lf lg lh b">ABOVE_NORMAL_PRIORITY_CLASS</code>，在所有其他平台上对应于-7。</li><li id="91b5" class="ml mm it ki b kj mu kn mv kr mw kv mx kz my ld mq mr ms mt bi translated"><code class="fe le lf lg lh b">PRIORITY_HIGH</code>——。这对应于Windows上的<code class="fe le lf lg lh b">HIGH_PRIORITY_CLASS</code>和所有其他平台上的-14。</li><li id="0653" class="ml mm it ki b kj mu kn mv kr mw kv mx kz my ld mq mr ms mt bi translated"><code class="fe le lf lg lh b">PRIORITY_HIGHEST</code> —最高的进程调度优先级。这对应于Windows上的<code class="fe le lf lg lh b">REALTIME_PRIORITY_CLASS</code>和所有其他平台上的-20。</li></ul><h1 id="f94e" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">os.homedir</h1><p id="4d8c" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated"><code class="fe le lf lg lh b">os.homedir</code>函数返回用户主目录的路径字符串。在Unix和Linux系统上，如果定义了<code class="fe le lf lg lh b">$HOME</code>变量，它将使用它。否则，它将通过有效的UID查找主目录路径，该UID是您当前假设的用户身份的用户ID。例如，如果您使用<code class="fe le lf lg lh b">sudo</code>作为根用户使用计算机，那么有效的用户ID将是根用户的用户ID。在Windows上，如果定义了<code class="fe le lf lg lh b">USERPROFILE</code>的值，就会使用它。否则，它将是当前用户的配置文件目录的路径。例如，如果我们对<code class="fe le lf lg lh b">os.homedir()</code>的输出运行<code class="fe le lf lg lh b">console.log</code>，那么我们可能会得到如下结果:</p><pre class="mz na nb nc gt nd lh ne nf aw ng bi"><span id="87ff" class="nh lj it lh b gy ni nj l nk nl">'/home/runner'</span></pre><p id="476b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你用的是Linux系统。</p><h1 id="8524" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">操作系统.主机名</h1><p id="7459" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated"><code class="fe le lf lg lh b">os.hostname</code>函数以字符串形式返回操作系统的主机名。例如，如果我们在<code class="fe le lf lg lh b">os.hostname()</code>的返回值上调用<code class="fe le lf lg lh b">console.log</code>，那么我们可能会得到类似于<code class="fe le lf lg lh b">‘5b84600c80eb’</code>的东西。</p><h1 id="0886" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">os.loadavg</h1><p id="904d" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated"><code class="fe le lf lg lh b">os.loadavg</code>函数返回一个包含1、5和15分钟平均负载的数字数组。平均负载衡量系统活动，由操作系统计算并以十进制数表示。理想的平均负载应该少于系统中逻辑CPU的数量。该功能仅在Unix和Linux系统上有效。在Windows上，它总是返回<code class="fe le lf lg lh b">[0,0,0]</code>。例如，如果我们在Linux系统上运行这个函数，如下面的代码所示:</p><pre class="mz na nb nc gt nd lh ne nf aw ng bi"><span id="9768" class="nh lj it lh b gy ni nj l nk nl">console.log(os.loadavg())</span></pre><p id="0f81" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可能会得到这样的结果:</p><pre class="mz na nb nc gt nd lh ne nf aw ng bi"><span id="7e5d" class="nh lj it lh b gy ni nj l nk nl">[ 12.60791015625, 13.3916015625, 9.8798828125 ]</span></pre><figure class="mz na nb nc gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nm"><img src="../Images/9198e6e78299893502e8588596af370e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fm0OZGJoP9qL1vpM"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">托马斯·詹森在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><h1 id="c7b3" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">操作系统.网络接口</h1><p id="8ec9" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated"><code class="fe le lf lg lh b">os.networkInterfaces</code>函数返回一个对象，该对象的网络接口已经被分配了一个网络地址。返回的对象上的关键字标识网络接口。密钥的相应值是描述分配的网络地址的对象数组。分配的网络地址对象的属性包括:</p><ul class=""><li id="836f" class="ml mm it ki b kj kk kn ko kr mn kv mo kz mp ld mq mr ms mt bi translated"><code class="fe le lf lg lh b">address</code> —具有分配的IPv4或IPv6地址的字符串</li><li id="57c8" class="ml mm it ki b kj mu kn mv kr mw kv mx kz my ld mq mr ms mt bi translated"><code class="fe le lf lg lh b">netmask </code> —具有IPv4或IPv6网络掩码的字符串</li><li id="89fe" class="ml mm it ki b kj mu kn mv kr mw kv mx kz my ld mq mr ms mt bi translated"><code class="fe le lf lg lh b">family</code> —有两个可能值的字符串:<code class="fe le lf lg lh b">IPv4</code>或<code class="fe le lf lg lh b">IPv6</code></li><li id="f7a2" class="ml mm it ki b kj mu kn mv kr mw kv mx kz my ld mq mr ms mt bi translated"><code class="fe le lf lg lh b">mac</code> —包含网络接口的MAC地址的字符串</li><li id="abc7" class="ml mm it ki b kj mu kn mv kr mw kv mx kz my ld mq mr ms mt bi translated"><code class="fe le lf lg lh b">internal</code> —一个布尔值，如果网络接口是回环或不可远程访问的类似接口，则该值为<code class="fe le lf lg lh b">true</code>。否则就是<code class="fe le lf lg lh b">false</code></li><li id="f6ce" class="ml mm it ki b kj mu kn mv kr mw kv mx kz my ld mq mr ms mt bi translated"><code class="fe le lf lg lh b">scopeid</code> —具有IPv6作用域ID的号码，仅当<code class="fe le lf lg lh b">family</code>为<code class="fe le lf lg lh b">IPv6</code>时适用</li><li id="57ca" class="ml mm it ki b kj mu kn mv kr mw kv mx kz my ld mq mr ms mt bi translated"><code class="fe le lf lg lh b">cidr</code> —具有分配的IPv4或IPv6地址的字符串，路由前缀采用CIDR表示法。CIDR符号有两组数字。首先是一组位，即网络地址。第一组后面跟着一个斜杠。第二组是被认为对网络路由很重要的位数。例如，如果我们有一个IP地址<code class="fe le lf lg lh b">192.168.0.15/24</code>，那么<code class="fe le lf lg lh b">192.168.0.15</code>是网络地址，而<code class="fe le lf lg lh b">24</code>是用于网络路由目的的有效位数。如果<code class="fe le lf lg lh b">netmask</code>无效，该属性设置为<code class="fe le lf lg lh b">null</code>。</li></ul><p id="1acf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们运行:</p><pre class="mz na nb nc gt nd lh ne nf aw ng bi"><span id="a7f8" class="nh lj it lh b gy ni nj l nk nl">console.log(os.networkInterfaces());</span></pre><p id="f58e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么我们可能会得到这样的结果:</p><pre class="mz na nb nc gt nd lh ne nf aw ng bi"><span id="4498" class="nh lj it lh b gy ni nj l nk nl">{ lo:<br/>   [ { address: '127.0.0.1',<br/>       netmask: '255.0.0.0',<br/>       family: 'IPv4',<br/>       mac: '00:00:00:00:00:00',<br/>       internal: true,<br/>       cidr: '127.0.0.1/8' } ],<br/>  eth0:<br/>   [ { address: '172.18.0.103',<br/>       netmask: '255.255.0.0',<br/>       family: 'IPv4',<br/>       mac: '02:42:ac:12:00:67',<br/>       internal: false,<br/>       cidr: '172.18.0.103/16' } ] }</span></pre><p id="3ecc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将<code class="fe le lf lg lh b">lo</code>用于环回地址，将<code class="fe le lf lg lh b">eth0</code>用于以太网接口。</p><h1 id="fedb" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">操作系统平台</h1><p id="ccbb" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated"><code class="fe le lf lg lh b">os.platform</code>函数返回一个字符串，标识编译Node.js二进制文件的计算机的操作系统平台。当前可能的值有<code class="fe le lf lg lh b">'aix'</code>、<code class="fe le lf lg lh b">'darwin'</code>、<code class="fe le lf lg lh b">'freebsd'</code>、<code class="fe le lf lg lh b">'linux', 'openbsd'</code>、<code class="fe le lf lg lh b">'sunos'</code>或<code class="fe le lf lg lh b">'win32'</code>。和<code class="fe le lf lg lh b">process.platform</code>属性一样。如果Node.js二进制文件构建在Android设备上，可能会返回值<code class="fe le lf lg lh b">'android'</code>。然而，Node.js中的Android支持仍处于试验阶段。例如，如果我们运行:</p><pre class="mz na nb nc gt nd lh ne nf aw ng bi"><span id="c107" class="nh lj it lh b gy ni nj l nk nl">console.log(os.platform());</span></pre><p id="aacf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么我们可能会得到这样的结果:</p><pre class="mz na nb nc gt nd lh ne nf aw ng bi"><span id="3158" class="nh lj it lh b gy ni nj l nk nl">'linux'</span></pre><p id="9d34" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Node.js OS模块有许多有用的实用函数，用于获取有关运行OS模块程序的计算机系统的信息。这些模块有更多的属性，包含有用的信息，如CPU、字节序、主目录、IP地址、主机名、程序运行的平台、系统正常运行时间、当前登录用户的信息等等。</p></div></div>    
</body>
</html>