<html>
<head>
<title>5 Ways to Implement the Singleton Design Anti-Pattern in C#</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在C#中实现单例设计反模式的5种方法</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/5-ways-to-implement-the-singleton-design-anti-pattern-in-c-68bb664c31f2?source=collection_archive---------2-----------------------#2021-01-23">https://levelup.gitconnected.com/5-ways-to-implement-the-singleton-design-anti-pattern-in-c-68bb664c31f2?source=collection_archive---------2-----------------------#2021-01-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/05d7b3403ef1b7e74a835821406ab269.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OGJvUrrdRNpt3l7w"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@balazscsaba2006?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Csaba Balazs </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="c63f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">单例设计模式有助于将一个类的实例化限制为一个对象。</em></p><p id="8921" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">关于单例设计模式的一些事实:</p><ul class=""><li id="ab39" class="lf lg it ki b kj kk kn ko kr lh kv li kz lj ld lk ll lm ln bi translated">最讨厌的设计模式之一。</li><li id="ea5e" class="lf lg it ki b kj lo kn lp kr lq kv lr kz ls ld lk ll lm ln bi translated">Erich Gamma会从“四人帮”的书中去掉单例模式。</li><li id="f9fb" class="lf lg it ki b kj lo kn lp kr lq kv lr kz ls ld lk ll lm ln bi translated">这种模式很容易被误用。</li></ul><p id="0038" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于最后一个事实，对我来说，singleton的经典实现更像是反模式的，而不是模式。</p><p id="0233" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们看看这个模式有什么问题，我们如何减少它的缺陷，以及<strong class="ki iu">我们能从不同的单例实现</strong>中学到什么。</p></div><div class="ab cl lt lu hx lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="im in io ip iq"><h1 id="18fb" class="ma mb it bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">基于静态属性的实现</h1><p id="9803" class="pw-post-body-paragraph kg kh it ki b kj my kl km kn mz kp kq kr na kt ku kv nb kx ky kz nc lb lc ld im bi translated">我们的第一个单例实现非常普通，只有几行代码，但是它只能在一定程度上工作。该实现确实允许创建单个实例，但并不像它应该的那样懒惰。</p><p id="6eae" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们看看代码:</p><figure class="nd ne nf ng gt ju"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="f0e0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里有两个可能的触发器可以实例化一个singleton对象。第一个是显而易见的，也是我们所期望的——对实例属性的访问。但是第二个触发器不太明显——它是对singleton类的任何其他静态属性的访问。NET framework在第一次访问类的任何静态成员之前调用类的静态构造函数。在我们的例子中，单例实例化发生在静态构造函数中，因为这一行:</p><pre class="nd ne nf ng gt nj nk nl nm aw nn bi"><span id="ebac" class="no mb it nk b gy np nq l nr ns">private static readonly Singleton _instance = new Singleton();</span></pre><p id="3345" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在幕后编译成这段代码:</p><pre class="nd ne nf ng gt nj nk nl nm aw nn bi"><span id="9a6b" class="no mb it nk b gy np nq l nr ns">static Singleton()<br/>{<br/>    _instance = new Singleton();<br/>}</span><span id="a636" class="no mb it nk b gy nt nq l nr ns">private static readonly Singleton _instance;</span></pre><p id="8eeb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以当前的实现在某种程度上是可行的。然而，如果单例的初始化尽可能的懒惰，你应该考虑使用懒惰类。</p><h2 id="f51d" class="no mb it bd mc nu nv dn mg nw nx dp mk kr ny nz mo kv oa ob ms kz oc od mw oe bi translated">优点:</h2><ul class=""><li id="01d7" class="lf lg it ki b kj my kn mz kr of kv og kz oh ld lk ll lm ln bi translated">线程安全。</li><li id="3c77" class="lf lg it ki b kj lo kn lp kr lq kv lr kz ls ld lk ll lm ln bi translated">易于实施。</li></ul><h2 id="c0b6" class="no mb it bd mc nu nv dn mg nw nx dp mk kr ny nz mo kv oa ob ms kz oc od mw oe bi translated">缺点:</h2><ul class=""><li id="a026" class="lf lg it ki b kj my kn mz kr of kv og kz oh ld lk ll lm ln bi translated">不懒。</li><li id="8858" class="lf lg it ki b kj lo kn lp kr lq kv lr kz ls ld lk ll lm ln bi translated">单一对象不能在运行时以多态的方式被另一种类型的对象替换。</li><li id="a8d4" class="lf lg it ki b kj lo kn lp kr lq kv lr kz ls ld lk ll lm ln bi translated">使用singleton的代码是不可单元测试的。</li><li id="e047" class="lf lg it ki b kj lo kn lp kr lq kv lr kz ls ld lk ll lm ln bi translated">该实现违反了单一责任原则，因为该类除了完成其主要工作之外，还负责创建自身。</li><li id="c8c6" class="lf lg it ki b kj lo kn lp kr lq kv lr kz ls ld lk ll lm ln bi translated">使用单例将会导致代码的其余部分存在隐式依赖。我已经在我的另一篇文章中描述了隐式依赖的问题:</li></ul><div class="oi oj gp gr ok ol"><a rel="noopener  ugc nofollow" target="_blank" href="/how-to-fix-bugs-and-not-introduce-new-ones-9f35e625673a"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd iu gy z fp oq fr fs or fu fw is bi translated">如何在不破坏应用程序的情况下修复Bug</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">更改源代码时更自信的步骤。</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="ou l"><div class="ov l ow ox oy ou oz jz ol"/></div></div></a></div><h1 id="75b6" class="ma mb it bd mc md pa mf mg mh pb mj mk ml pc mn mo mp pd mr ms mt pe mv mw mx bi translated">基于懒惰<t>类的实现</t></h1><p id="5fed" class="pw-post-body-paragraph kg kh it ki b kj my kl km kn mz kp kq kr na kt ku kv nb kx ky kz nc lb lc ld im bi translated">前面的代码示例可以通过一个微小的改变得到显著的改进— Lazy <t>类。只有在访问Instance属性时，singleton对象才会被实例化。</t></p><figure class="nd ne nf ng gt ju"><div class="bz fp l di"><div class="nh ni l"/></div></figure><h2 id="e31b" class="no mb it bd mc nu nv dn mg nw nx dp mk kr ny nz mo kv oa ob ms kz oc od mw oe bi translated">优点:</h2><ul class=""><li id="4266" class="lf lg it ki b kj my kn mz kr of kv og kz oh ld lk ll lm ln bi translated">线程安全。</li><li id="71f2" class="lf lg it ki b kj lo kn lp kr lq kv lr kz ls ld lk ll lm ln bi translated">百分百懒。</li><li id="5d47" class="lf lg it ki b kj lo kn lp kr lq kv lr kz ls ld lk ll lm ln bi translated">易于实施。</li></ul><h2 id="8269" class="no mb it bd mc nu nv dn mg nw nx dp mk kr ny nz mo kv oa ob ms kz oc od mw oe bi translated">缺点:</h2><ul class=""><li id="0a75" class="lf lg it ki b kj my kn mz kr of kv og kz oh ld lk ll lm ln bi translated">同样，在运行时没有可扩展性。</li><li id="3b7f" class="lf lg it ki b kj lo kn lp kr lq kv lr kz ls ld lk ll lm ln bi translated">同样，代码是不可测试的。</li><li id="73f5" class="lf lg it ki b kj lo kn lp kr lq kv lr kz ls ld lk ll lm ln bi translated">再次违反SRP。</li><li id="3297" class="lf lg it ki b kj lo kn lp kr lq kv lr kz ls ld lk ll lm ln bi translated">又是隐式依赖问题。</li></ul><h1 id="b3da" class="ma mb it bd mc md pa mf mg mh pb mj mk ml pc mn mo mp pd mr ms mt pe mv mw mx bi translated">双重检查锁定实现</h1><p id="90b5" class="pw-post-body-paragraph kg kh it ki b kj my kl km kn mz kp kq kr na kt ku kv nb kx ky kz nc lb lc ld im bi translated">我喜欢这种单例实现，只是因为与其他实现相比，它在技术上很复杂。以下代码示例完全等同于上一个示例。然而，从学习的角度来看，这要有趣得多，因为它展示了如何使用锁同步、volatile关键字和双重检查锁定技术。</p><figure class="nd ne nf ng gt ju"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="7953" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">锁定结构使得单例实现是线程安全的，同时需要双重检查锁定来提高性能。获取第17行的锁是一个开销很大的操作。如果已经创建了singleton，就没有必要获取一个锁，然后尝试创建它。在第15行添加额外的null检查有助于避免不必要的锁尝试，这对性能更好。</p><h2 id="c12f" class="no mb it bd mc nu nv dn mg nw nx dp mk kr ny nz mo kv oa ob ms kz oc od mw oe bi translated">优点:</h2><ul class=""><li id="cfe3" class="lf lg it ki b kj my kn mz kr of kv og kz oh ld lk ll lm ln bi translated">线程安全。</li><li id="a91f" class="lf lg it ki b kj lo kn lp kr lq kv lr kz ls ld lk ll lm ln bi translated">百分百懒。</li></ul><h2 id="2080" class="no mb it bd mc nu nv dn mg nw nx dp mk kr ny nz mo kv oa ob ms kz oc od mw oe bi translated">骗局</h2><ul class=""><li id="22bd" class="lf lg it ki b kj my kn mz kr of kv og kz oh ld lk ll lm ln bi translated">复杂的实现。</li><li id="8f94" class="lf lg it ki b kj lo kn lp kr lq kv lr kz ls ld lk ll lm ln bi translated">同样，在运行时没有可扩展性。</li><li id="a1a7" class="lf lg it ki b kj lo kn lp kr lq kv lr kz ls ld lk ll lm ln bi translated">同样，代码是不可测试的。</li><li id="1e38" class="lf lg it ki b kj lo kn lp kr lq kv lr kz ls ld lk ll lm ln bi translated">再次违反SRP。</li><li id="a3e7" class="lf lg it ki b kj lo kn lp kr lq kv lr kz ls ld lk ll lm ln bi translated">又是隐式依赖问题。</li></ul><h1 id="07a5" class="ma mb it bd mc md pa mf mg mh pb mj mk ml pc mn mo mp pd mr ms mt pe mv mw mx bi translated">周围环境</h1><p id="4781" class="pw-post-body-paragraph kg kh it ki b kj my kl km kn mz kp kq kr na kt ku kv nb kx ky kz nc lb lc ld im bi translated">singleton的一个主要缺点是在运行时缺乏灵活性。我们不能用ExtendedSingleton或SingletonMock替换singleton类。如果我们需要在运行时实现可扩展性，同时保持一个全局访问点，我们可以使用环境上下文模式。</p><figure class="nd ne nf ng gt ju"><div class="bz fp l di"><div class="nh ni l"/></div></figure><h2 id="b73c" class="no mb it bd mc nu nv dn mg nw nx dp mk kr ny nz mo kv oa ob ms kz oc od mw oe bi translated">优点:</h2><ul class=""><li id="286e" class="lf lg it ki b kj my kn mz kr of kv og kz oh ld lk ll lm ln bi translated">运行时的可扩展性。</li><li id="7c28" class="lf lg it ki b kj lo kn lp kr lq kv lr kz ls ld lk ll lm ln bi translated">单一责任原则现在受到尊重。</li></ul><h2 id="c2d7" class="no mb it bd mc nu nv dn mg nw nx dp mk kr ny nz mo kv oa ob ms kz oc od mw oe bi translated">缺点:</h2><ul class=""><li id="1555" class="lf lg it ki b kj my kn mz kr of kv og kz oh ld lk ll lm ln bi translated">这不再是单一模式了。可以创建单例类的许多实例。</li><li id="67e1" class="lf lg it ki b kj lo kn lp kr lq kv lr kz ls ld lk ll lm ln bi translated">隐式依赖问题仍然存在。</li></ul><h1 id="a2f3" class="ma mb it bd mc md pa mf mg mh pb mj mk ml pc mn mo mp pd mr ms mt pe mv mw mx bi translated">IoC容器中的单例</h1><p id="b1be" class="pw-post-body-paragraph kg kh it ki b kj my kl km kn mz kp kq kr na kt ku kv nb kx ky kz nc lb lc ld im bi translated">像Autofac这样的控制容器的反转控制一个注册对象的生存期。所有的IoC容器都有称为singleton或类似的生存期范围。任何对象都可以注册为单个实例，这样就可以实现单例模式的主要目标。</p><figure class="nd ne nf ng gt ju"><div class="bz fp l di"><div class="nh ni l"/></div></figure><h2 id="95bb" class="no mb it bd mc nu nv dn mg nw nx dp mk kr ny nz mo kv oa ob ms kz oc od mw oe bi translated">优点:</h2><ul class=""><li id="8412" class="lf lg it ki b kj my kn mz kr of kv og kz oh ld lk ll lm ln bi translated">易于实施。</li><li id="9801" class="lf lg it ki b kj lo kn lp kr lq kv lr kz ls ld lk ll lm ln bi translated">使用“singleton”的代码现在是单元可测试的了。</li><li id="d0b5" class="lf lg it ki b kj lo kn lp kr lq kv lr kz ls ld lk ll lm ln bi translated">没有违反SRP。现在，IoC容器负责创建单例，而不是单例类本身。</li><li id="215f" class="lf lg it ki b kj lo kn lp kr lq kv lr kz ls ld lk ll lm ln bi translated">singleton类将被注入到其他类的构造函数中，即显式使用。</li></ul><h2 id="5f36" class="no mb it bd mc nu nv dn mg nw nx dp mk kr ny nz mo kv oa ob ms kz oc od mw oe bi translated">缺点:</h2><ul class=""><li id="b8c2" class="lf lg it ki b kj my kn mz kr of kv og kz oh ld lk ll lm ln bi translated">可以用new关键字创建许多实例。</li></ul></div><div class="ab cl lt lu hx lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="im in io ip iq"><h1 id="fb12" class="ma mb it bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">结论</h1><p id="f411" class="pw-post-body-paragraph kg kh it ki b kj my kl km kn mz kp kq kr na kt ku kv nb kx ky kz nc lb lc ld im bi translated">我看不出使用经典的singleton反模式背后有什么真正的动机。在以下情况下，单例仍然可以是一种模式:</p><ul class=""><li id="0d64" class="lf lg it ki b kj kk kn ko kr lh kv li kz lj ld lk ll lm ln bi translated">它没有状态(改变应用程序一部分的状态会影响所有相关部分的行为)。</li><li id="aebb" class="lf lg it ki b kj lo kn lp kr lq kv lr kz ls ld lk ll lm ln bi translated">它是显式使用的(<em class="le">private Singleton _ Singleton = Singleton)。类构造函数中的实例</em>。singleton的使用并没有深藏在代码中)。</li><li id="a085" class="lf lg it ki b kj lo kn lp kr lq kv lr kz ls ld lk ll lm ln bi translated">在需要被单元测试覆盖的代码中没有使用它。</li><li id="09c6" class="lf lg it ki b kj lo kn lp kr lq kv lr kz ls ld lk ll lm ln bi translated">它的用途仅限于最小数量的模块。</li></ul><p id="1747" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对我来说有很多如果。</p></div><div class="ab cl lt lu hx lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="im in io ip iq"><h1 id="a1fd" class="ma mb it bd mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx bi translated">更多设计模式</h1><p id="9143" class="pw-post-body-paragraph kg kh it ki b kj my kl km kn mz kp kq kr na kt ku kv nb kx ky kz nc lb lc ld im bi translated">萨沙·马修斯·https://link.medium.com/VaQVf8Anvdb的《企业应用中外观设计模式的3个主要用例》</p><div class="oi oj gp gr ok ol"><a rel="noopener  ugc nofollow" target="_blank" href="/the-state-design-pattern-to-implement-likes-and-dislikes-958389b379ff"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd iu gy z fp oq fr fs or fu fw is bi translated">如何使用状态设计模式实现好恶</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">从需求引出开始</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="ou l"><div class="pf l ow ox oy ou oz jz ol"/></div></div></a></div><div class="oi oj gp gr ok ol"><a rel="noopener  ugc nofollow" target="_blank" href="/the-simplest-explanation-of-adapter-design-pattern-cd37f02bfecd"><div class="om ab fo"><div class="on ab oo cl cj op"><h2 class="bd iu gy z fp oq fr fs or fu fw is bi translated">适配器设计模式的最简单解释</h2><div class="os l"><h3 class="bd b gy z fp oq fr fs or fu fw dk translated">C#中的真实世界示例</h3></div><div class="ot l"><p class="bd b dl z fp oq fr fs or fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="ou l"><div class="pg l ow ox oy ou oz jz ol"/></div></div></a></div></div></div>    
</body>
</html>