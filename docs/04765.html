<html>
<head>
<title>Node.js Tips — XML, MySQL, HTTP Requests, and Deleting Files</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js提示— XML、MySQL、HTTP请求和删除文件</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/node-js-tips-xml-mysql-http-requests-and-deleting-files-13458cb2562a?source=collection_archive---------12-----------------------#2020-07-13">https://levelup.gitconnected.com/node-js-tips-xml-mysql-http-requests-and-deleting-files-13458cb2562a?source=collection_archive---------12-----------------------#2020-07-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/2dfc26f5928f59ac784ccde6ed07e81d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tia1pblABK7WfBqK"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@r3dmax?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Jonatan Pie </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="86c1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">像任何类型的应用程序一样，当我们编写节点应用程序时，有一些困难的问题需要解决。</p><p id="96a1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将研究一些编写节点应用程序时常见问题的解决方案。</p><h1 id="bfe2" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">节点。JS异步并行</h1><p id="3e61" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mh mi mj mk b">async</code>模块是让我们并行运行异步代码的<code class="fe mh mi mj mk b">parallel</code>方法。</p><p id="8bbf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="ee4b" class="mt lf it mk b gy mu mv l mw mx">async.parallel({<br/>  one(callback) {<br/>    callback(null, 'foo');<br/>  },<br/>  two(callback) {<br/>    callback(null, 'bar');<br/>  }<br/>}, (err, results) =&gt; {<br/>  //...<br/>});</span></pre><p id="6fde" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们有两个方法，在传递给<code class="fe mh mi mj mk b">async.parallel</code>的对象中接受回调。</p><p id="24f6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它们都用错误和结果对象作为参数来调用<code class="fe mh mi mj mk b">callback</code>。</p><p id="0455" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们在<code class="fe mh mi mj mk b">results</code>对象中得到两者。</p><p id="37ea" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">results</code>会是:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="ccc6" class="mt lf it mk b gy mu mv l mw mx">{ one: 'foo', two: 'bar' }</span></pre><p id="4adb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">方法名被用作结果的关键字。</p><h1 id="3014" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">正在读取Node.js中的XML文件</h1><p id="f801" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以用<code class="fe mh mi mj mk b">readFile</code>方法读取Node.js中的XML文件。</p><p id="2b48" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们可以用<code class="fe mh mi mj mk b">xml2json</code>库解析内容。</p><p id="0345" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="6972" class="mt lf it mk b gy mu mv l mw mx">fs = require('fs');<br/>const parser = require('xml2json');</span><span id="7e39" class="mt lf it mk b gy my mv l mw mx">fs.readFile('./data.xml', (err, data) =&gt; {<br/>  const json = parser.toJson(data);<br/>  console.log(json);<br/>});</span></pre><p id="7a36" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们用XML文件的路径调用<code class="fe mh mi mj mk b">readFile</code>。</p><p id="736b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们用<code class="fe mh mi mj mk b">data</code>得到XML文本。</p><p id="e967" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">接下来我们调用<code class="fe mh mi mj mk b">parser.toJson</code>来解析存储在<code class="fe mh mi mj mk b">data</code>中的XML字符串。</p><h1 id="921c" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">节点MySQL Escape LIKE语句</h1><p id="611e" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以这样写来转义<code class="fe mh mi mj mk b">LIKE</code>语句中的字符:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="e6af" class="mt lf it mk b gy mu mv l mw mx">mysql.format("SELECT * FROM persons WHERE name LIKE CONCAT('%', ?,  '%')", searchString)</span></pre><p id="15f7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们只是将<code class="fe mh mi mj mk b">%</code>和<code class="fe mh mi mj mk b">searchString</code>连接在一起。</p><h1 id="fd5b" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">删除超过一小时的文件</h1><p id="4a0c" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">要获取一个小时以前的所有文件并删除它们，我们可以使用<code class="fe mh mi mj mk b">readdir</code>来获取目录中的文件。</p><p id="b04e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们可以使用<code class="fe mh mi mj mk b">fs.stat</code>来获取时间，并使用它与当前时间进行比较，以查看自文件创建以来是否已经过去了一个小时。</p><p id="761a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当文件在一小时前或更早创建时，我们可以使用<code class="fe mh mi mj mk b">rimraf</code>删除它。</p><p id="d14b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="181f" class="mt lf it mk b gy mu mv l mw mx">const uploadsDir = path.join( __dirname, '/uploads');</span><span id="1329" class="mt lf it mk b gy my mv l mw mx">fs.readdir(uploadsDir, (err, files) =&gt; {<br/>  files.forEach((file, index) =&gt; {<br/>    fs.stat(path.join(uploadsDir, file), (err, stat) =&gt; {<br/>      let endTime, now;<br/>      if (err) {<br/>        return console.error(err);<br/>      }<br/>      now = new Date().getTime();<br/>      endTime = new Date(stat.ctime).getTime() + 3600000;<br/>      if (now &gt; endTime) {<br/>        return rimraf(path.join(uploadsDir, file), (err) =&gt; {<br/>          if (err) {<br/>            return console.error(err);<br/>          }<br/>          console.log('successfully deleted');<br/>        });<br/>      }<br/>    });<br/>  });<br/>});</span></pre><p id="a54c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们用<code class="fe mh mi mj mk b">readdir</code>读取文件夹。</p><p id="b7ff" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们循环回调中获得的<code class="fe mh mi mj mk b">files</code>。</p><p id="470c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们调用<code class="fe mh mi mj mk b">fs.stat</code>来获取文件信息。</p><p id="20d7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们使用<code class="fe mh mi mj mk b">ctime</code>属性来获取文件创建的时间。</p><p id="ece3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们用<code class="fe mh mi mj mk b">getTime</code>把它变成时间戳。</p><p id="3f52" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们加上3600000，这是以毫秒为单位的一个小时。</p><p id="b256" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么如果<code class="fe mh mi mj mk b">now &gt; endTime</code>是<code class="fe mh mi mj mk b">true</code>，我们就知道从文件创建到现在已经过去了一个多小时。</p><p id="fb57" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们可以使用<code class="fe mh mi mj mk b">rimraf</code>删除文件。</p><p id="fd32" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们使用完整路径。</p><h1 id="1e7e" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">使用Node.js调用Web服务</h1><p id="c149" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以像在客户端一样，通过发出HTTP请求来调用节点应用程序中的web服务器。</p><p id="7e96" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="7be0" class="mt lf it mk b gy mu mv l mw mx">const http = require('http');<br/>const data = JSON.stringify({<br/>  'id': '2'<br/>});</span><span id="af12" class="mt lf it mk b gy my mv l mw mx">const options = {<br/>  host: 'host.com',<br/>  port: '80',<br/>  path: '/some/url',<br/>  method: 'POST',<br/>  headers: {<br/>    'Content-Type': 'application/json;',<br/>    'Content-Length': data.length<br/>  }<br/>};</span><span id="c5b1" class="mt lf it mk b gy my mv l mw mx">const req = http.request(options, (res) =&gt; {<br/>  let msg = '';</span><span id="c3df" class="mt lf it mk b gy my mv l mw mx">  res.setEncoding('utf8');<br/>  res.on('data', (chunk) =&gt; {<br/>    msg += chunk;<br/>  });<br/>  res.on('end', () =&gt; {<br/>    console.log(JSON.parse(msg));<br/>  });<br/>});</span><span id="258e" class="mt lf it mk b gy my mv l mw mx">req.write(data);<br/>req.end();</span></pre><p id="193d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们使用<code class="fe mh mi mj mk b">http.request</code>方法来发出请求。</p><p id="c775" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们叫<code class="fe mh mi mj mk b">req.write</code>用身体发出请求</p><p id="8d3e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">options</code>对象有头、主机名和请求方法。</p><p id="c4f4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦请求完成，回调就被调用，并且<code class="fe mh mi mj mk b">res</code>拥有带有响应的流。</p><p id="29ea" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们监听<code class="fe mh mi mj mk b">data</code>事件来获取数据块并连接到<code class="fe mh mi mj mk b">msg</code>字符串。</p><p id="fe7b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们监听<code class="fe mh mi mj mk b">end</code>事件来解析检索到的块。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/c55ababcc57dc7853e56d27d2e209287.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nVt4KjVWCK8V7l4j"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@r3dmax?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Jonatan Pie </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="3d1d" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="4474" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mh mi mj mk b">async.parallel</code>可以并行运行回调。</p><p id="839c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以用rimraf删除文件。</p><p id="b04a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，我们可以用<code class="fe mh mi mj mk b">http</code>模块发出HTTP请求。</p><p id="3cd0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了将XML解析成JSON，我们可以使用<code class="fe mh mi mj mk b">xml2json</code>包。</p></div></div>    
</body>
</html>