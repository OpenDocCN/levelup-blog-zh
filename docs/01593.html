<html>
<head>
<title>Understanding Functional Programming in Javascript — A Complete Guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解Javascript中的函数式编程—完全指南</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/understanding-functional-programming-in-javascript-a-complete-guide-e85ed13b42c8?source=collection_archive---------0-----------------------#2020-01-15">https://levelup.gitconnected.com/understanding-functional-programming-in-javascript-a-complete-guide-e85ed13b42c8?source=collection_archive---------0-----------------------#2020-01-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/3c25a03e5a7bd945d441f1d3ba4a55ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f9jWwpWo-5A5p2RdyV0c-g.png"/></div></div></figure><p id="6689" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">面向对象编程(OOP)被广泛认为是最流行的编程范式。许多开发人员熟悉诸如Java和C++等OOP语言中的类和对象实例化等概念。其实不难找到能解释这些概念的开发者。</p><p id="54e7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">函数式编程比面向对象编程存在的时间要长得多。最好的例子是LISP，它的第一个规范写于1958年。然而，与OOP不同的是，要找到能够理解诸如纯度、Currying或函数组合等功能概念的开发人员并不容易。</p><p id="e89c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Javascript不是函数式编程语言，或者至少不是它的主要面向范例。这并不意味着我们不能通过使用Lodash、下划线、RambdaJS之类的库或者只使用普通的Javascript来以功能性的方式工作。</p><p id="536b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">今年我有机会读了费德里科·克里基的《掌握Javascript函数式编程》。这是我个人推荐给任何想要深入理解函数式编程概念及其使用Javascript的应用的人的一本书。在这篇文章中，我将解释我从Kereki的书中学到的东西。我的意图不是重复书中的所有内容——如果你想这样，那就去读这本书吧！而是提供一个总结和要点。</p><blockquote class="kx ky kz"><p id="d9ae" class="jy jz la ka b kb kc kd ke kf kg kh ki lb kk kl km lc ko kp kq ld ks kt ku kv ij bi translated"><strong class="ka ir">注意</strong>:本文面向中级/高级Javascript开发人员。</p></blockquote></div><div class="ab cl le lf hu lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ij ik il im in"><h1 id="4115" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">1.充当一级对象</h1><p id="f3f5" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">做函数式编程的时候，函数是一级对象。这意味着您可以像使用变量或常量一样使用函数。您可以将函数与其他函数合并，并在此过程中生成新函数。你可以把函数连接起来进行复杂的计算。总的来说，功能就是一切！</p><p id="e96a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在Javascript中，可以用几种方式定义函数。我发现总是使用箭头形式很方便——除非您想使用<code class="fe mo mp mq mr b">this</code>状态。示例:</p><pre class="ms mt mu mv gt mw mr mx bn my mz bi"><span id="6b65" class="na lm iq mr b be nb nc l nd ne">const add = (a, b) =&gt; a + b;</span></pre><p id="12aa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你是一个有经验的JS开发者，你很可能遇到过类似于<code class="fe mo mp mq mr b">setTimeout</code>和<code class="fe mo mp mq mr b">setInterval</code>使用的回调函数。这些是如何使用函数作为参数的完美例子。另一个例子:</p><pre class="ms mt mu mv gt mw mr mx bn my mz bi"><span id="e7b7" class="na lm iq mr b be nb nc l nd ne">var doSomething = function(status) {<br/>// Doing something<br/>};</span></pre><pre class="nf mw mr mx bn my mz bi"><span id="25b0" class="na lm iq mr b be nb nc l nd ne">var foo = function(data, func) { // Passing function as a parameter<br/>    func(data);<br/>}</span></pre><pre class="nf mw mr mx bn my mz bi"><span id="73ab" class="na lm iq mr b be nb nc l nd ne">foo("some data", doSomething);</span></pre><h1 id="98f0" class="ll lm iq bd ln lo ng lq lr ls nh lu lv lw ni ly lz ma nj mc md me nk mg mh mi bi translated">2.纯函数的重要性</h1><p id="d11c" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">为了以函数的方式工作，使用函数并不是你唯一需要做的事情。你还需要保持你的函数<strong class="ka ir">纯净</strong>。但这意味着什么呢？根据费德里科·克里基的理论，当满足以下条件时，你就有了一个纯函数:</p><blockquote class="kx ky kz"><p id="9472" class="jy jz la ka b kb kc kd ke kf kg kh ki lb kk kl km lc ko kp kq ld ks kt ku kv ij bi translated">-给定相同的参数，函数总是计算并返回相同的结果</p><p id="3a12" class="jy jz la ka b kb kc kd ke kf kg kh ki lb kk kl km lc ko kp kq ld ks kt ku kv ij bi translated">-在计算其结果时，函数不会引起任何可观察到的副作用，包括输出到I/O设备、对象的突变、函数外程序状态的改变等等。</p></blockquote><p id="917a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们看一个例子:</p><pre class="ms mt mu mv gt mw mr mx bn my mz bi"><span id="4c79" class="na lm iq mr b be nb nc l nd ne">const getRectangleArea = (sideA, sideB) =&gt; sideA * sideB;</span></pre><pre class="nf mw mr mx bn my mz bi"><span id="2f37" class="na lm iq mr b be nb nc l nd ne">console.log(getRectangleArea(2, 3)); // 6</span></pre><p id="b654" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个函数是纯函数，因为对于给定的参数“2”和“3”，它总是返回结果“6”。这个函数根本不影响它的外部环境。一切都发生在它的内部，它产生了一个新的结果，而没有改变(突变)它的论点。所以我们可以自信地说:<strong class="ka ir">它没有副作用，因此功能是纯的。</strong></p><p id="cfda" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">差不多就是这样。当你的功能没有副作用时，它就是纯粹的。如果它没有副作用，那么你的功能是纯粹的。简单对吗？<em class="la">但是副作用到底是什么？</em>这里列出了你可能会发现的副作用:</p><ul class=""><li id="7902" class="nl nm iq ka b kb kc kf kg kj nn kn no kr np kv nq nr ns nt bi translated">使用全局变量(除非它们是常量)。</li><li id="d5aa" class="nl nm iq ka b kb nu kf nv kj nw kn nx kr ny kv nq nr ns nt bi translated">变异作为参数接收的对象。</li><li id="2a9b" class="nl nm iq ka b kb nu kf nv kj nw kn nx kr ny kv nq nr ns nt bi translated">像做任何类型的I/O、使用、改变文件系统、更新数据库、调用外部API等操作。</li></ul><p id="1fdd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后但同样重要的是，使用一个不纯的函数。费德里科说不纯洁的功能是“传染的”。所以如果你的函数使用了会引起副作用的东西，你的函数就会变得不纯。</p><h1 id="29ff" class="ll lm iq bd ln lo ng lq lr ls nh lu lv lw ni ly lz ma nj mc md me nk mg mh mi bi translated">3.处理副作用</h1><p id="fe77" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">纯函数听起来不错，但是，除非您正在开发一个简单的计算器，否则您很可能需要使用异步操作，如访问数据库或调用外部API。像灭霸一样，副作用是不可避免的。</p><figure class="ms mt mu mv gt jr gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/1834ae4e5bb691ebf6a0ef27fa4827cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/1*41a6LTcAugmX39QQkPAZFg.gif"/></div></figure><p id="b43d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那么，我们如何在以函数方式工作的同时设法使用不纯的函数呢？首先，您需要接受这样一个事实，即在您的日常工作中不可能实现100%的纯函数式编程。然而，这也不应该是你的目标。正如费德里科在他的书中所说:</p><blockquote class="kx ky kz"><p id="e912" class="jy jz la ka b kb kc kd ke kf kg kh ki lb kk kl km lc ko kp kq ld ks kt ku kv ij bi translated">但是，不要陷入以FP为目标的陷阱！就像所有的软件工具一样，把FP仅仅看作是达到目的的一种手段。函数式代码不仅仅是因为函数性才是好的……用FP编写糟糕的代码就像用其他技术一样容易！</p></blockquote><p id="a23f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">费德里科给它起了个名字:“类似函数式编程”。一般来说，我们的目标应该是将代码中不纯的部分从纯的部分中分离出来。这里你可以找到一个例子:</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="oa ob l"/></div><figcaption class="oc od gj gh gi oe of bd b be z dk translated">实例:<a class="ae kw" href="https://repl.it/repls/InternationalCleanWebsphere" rel="noopener ugc nofollow" target="_blank">此处</a></figcaption></figure><p id="a2cb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个节点脚本正在读取一个文本文件，计算其字数，并将结果发送到一个外部API —嗯，不完全是“实际”的API，但让我们假设它是真实的—只有一个纯函数(计算字数)，其余的都是不纯的。这样，我们可以将代码中不纯的部分与纯的部分分开。</p><p id="2153" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">过去的策略效果很好。然而，函数调用是以<strong class="ka ir">命令式</strong>形式(顺序指令)进行的。一个更实用的替代方法是<strong class="ka ir">将不纯的函数注入到纯函数中。让我们看另一个例子来解释这一点。</strong></p><p id="d78b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">假设我们想要生成一个范围内的随机整数。使用Mozilla文档建议的解决方案，您可以做如下事情:</p><pre class="ms mt mu mv gt mw mr mx bn my mz bi"><span id="050a" class="na lm iq mr b be nb nc l nd ne">function getRandomInt(min, max) {<br/>  return Math.floor(Math.random() * (max - min)) + min;<br/>}</span></pre><p id="ffd9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个解决方案的问题是<code class="fe mo mp mq mr b">Math.random</code>方法的不纯。所以为了将这个方法从<code class="fe mo mp mq mr b">getRandomInt</code>函数中分离出来，我们可以这样做:</p><pre class="ms mt mu mv gt mw mr mx bn my mz bi"><span id="6f60" class="na lm iq mr b be nb nc l nd ne">function getRandomInt(min, max, <strong class="mr ir">random = Math.random</strong>) {<br/>  return Math.floor(<strong class="mr ir">random</strong>() * (max - min)) + min;<br/>}</span></pre><p id="62ce" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">就是这样。我们已经解耦了我们的<code class="fe mo mp mq mr b">getRandomInt</code>功能。注意我们是如何使用ES6默认参数的，这样我们就不必在每次调用时都传递<code class="fe mo mp mq mr b">Math.random</code>引用。然而，我知道你在想什么…</p><blockquote class="og"><p id="920b" class="oh oi iq bd oj ok ol om on oo op kv dk translated">你告诉我，如果一个纯函数使用了不纯的东西，这个也会变得不纯。</p></blockquote><p id="87e7" class="pw-post-body-paragraph jy jz iq ka b kb oq kd ke kf or kh ki kj os kl km kn ot kp kq kr ou kt ku kv ij bi translated">是的，你说得对。只要传递的函数是不纯的，这个函数就不会以纯的方式运行。然而，这在运行测试时给了我们很大的优势。让我们用Jest来看看这个例子:</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="oa ob l"/></div><figcaption class="oc od gj gh gi oe of bd b be z dk translated">使用<a class="ae kw" href="https://jestjs.io/" rel="noopener ugc nofollow" target="_blank"> Jest </a>运行此程序</figcaption></figure><p id="286f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上面的例子中，我们覆盖了默认函数，使用我们作为第三个参数传递的函数(一个只返回值的箭头函数)。通过这样做，我们使得随机函数<a class="ae kw" href="https://en.wikipedia.org/wiki/Deterministic_system" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">确定性</strong> </a>，因此<strong class="ka ir">纯净，</strong>这使得我们更容易做出测试断言。</p><h1 id="dfdc" class="ll lm iq bd ln lo ng lq lr ls nh lu lv lw ni ly lz ma nj mc md me nk mg mh mi bi translated">4.使用高阶函数</h1><p id="b770" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">如果您使用JS已经有一段时间了，那么您很可能会偶然发现map、filter、reduce等函数。这些是高阶函数的好例子。它们是以其他函数为参数的函数。它们既可以返回一个新函数，也可以基于传递给它的函数返回一个结果。</p><p id="b01e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我将在下一部分描述贴图、过滤器和其他内置的HOF。但是现在，我们将专注于创建我们自己的HOF实现。</p><h2 id="cb9b" class="ov lm iq bd ln ow ox dn lr oy oz dp lv kj pa pb lz kn pc pd md kr pe pf mh pg bi translated">测量时间</h2><p id="9a8c" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">假设您想要记录一个函数完成所花费的时间。您的第一个想法可能是这样做:</p><pre class="ms mt mu mv gt mw mr mx bn my mz bi"><span id="a48a" class="na lm iq mr b be nb nc l nd ne">const calculateRectangleArea = (sideA, sideB) =&gt; sideA * sideB;</span></pre><pre class="nf mw mr mx bn my mz bi"><span id="ece6" class="na lm iq mr b be nb nc l nd ne">(() =&gt; {<br/>  const <strong class="mr ir">startTime</strong> = Date.now();<br/>  const rectangleArea = calculateRectangleArea(2, 3);<br/>  <strong class="mr ir">const time = Date.now() - startTime;</strong><br/>  console.log(`Function calculateRectangleArea took ${<strong class="mr ir">time</strong>} to complete`);<br/>})();</span></pre><p id="8846" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个解决方案很好，但是如果我们想测量其他函数的时间呢？我们需要再重复一遍这段代码吗？<em class="la">没门！</em>所以让我们实现一个HOF，它将任何函数作为参数，并生成一个记录执行时间的新函数。我们打算称它为<code class="fe mo mp mq mr b">addTiming</code>。</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="oa ob l"/></div><figcaption class="oc od gj gh gi oe of bd b be z dk translated">活生生的例子:<a class="ae kw" href="https://repl.it/@Andrew4d3/addTiming" rel="noopener ugc nofollow" target="_blank">这里</a></figcaption></figure><p id="11d8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如你在上面看到的，我们实现了一个有三个参数的HOF，但是其中只有一个是强制的(第一个)。第二个是用来获取当前时间的函数，第三个是用来记录时间的函数。</p><p id="6324" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该函数将首先获取当前时间，然后调用带有相应参数的目标函数——我们使用spread运算符获取——之后，它将执行并记录目标函数完成所需的时间。最后，它将返回相应的结果。还有一些错误处理，以防函数没有按预期结束。</p><h2 id="aea4" class="ov lm iq bd ln ow ox dn lr oy oz dp lv kj pa pb lz kn pc pd md kr pe pf mh pg bi translated">记忆功能</h2><p id="36e4" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">记忆(或缓存结果)是HOF的另一个有趣的特性，但通常会被忽略。正如我们已经提到的，当使用<strong class="ka ir">纯函数</strong>时，我们可以确定对于任何给定的参数集，它将<strong class="ka ir">总是</strong>返回相同的特定结果。这意味着我们可以将这些结果保存在内存中，以便在以后的调用中使用。这种<strong class="ka ir">记忆</strong>技术在处理花费太多处理时间来完成的昂贵计算时尤其重要。</p><p id="f255" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们以下面的斐波那契函数为例:</p><pre class="ms mt mu mv gt mw mr mx bn my mz bi"><span id="b7c3" class="na lm iq mr b be nb nc l nd ne">const fib = n =&gt; {<br/>  if (n === 0) {<br/>    return 0;<br/>  } else if (n === 1) {<br/>    return 1;<br/>  } else {<br/>    return fib(n - 2) + fib(n - 1);<br/>  }<br/>};</span></pre><p id="28f1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个斐波那契函数使用递归，随着输入的增加，它的执行时间也会增加。我们可以使用我们最近创建的<code class="fe mo mp mq mr b">addTiming</code>函数来验证:</p><pre class="ms mt mu mv gt mw mr mx bn my mz bi"><span id="3696" class="na lm iq mr b be nb nc l nd ne">addTiming(fib)(10); <em class="la">// fib: Normal execution - 0<br/></em>addTiming(fib)(20); <em class="la">// fib: Normal execution - 1<br/></em>addTiming(fib)(30); <em class="la">// fib: Normal execution - 11<br/></em>addTiming(fib)(40); <em class="la">// fib: Normal execution - 1447<br/></em>addTiming(fib)(50); <em class="la">// fib: Normal execution - 181611</em></span></pre><p id="ef69" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面显示的时间可能与你在电脑上看到的不同，但除非你有一台量子计算机——我打赌你没有——否则运行这个输入为50的斐波那契函数将需要很长时间才能完成。</p><figure class="ms mt mu mv gt jr gh gi paragraph-image"><div class="gh gi ph"><img src="../Images/69eda384dfbd226348158e68a8e49438.png" data-original-src="https://miro.medium.com/v2/resize:fit:982/format:webp/0*QxIf4Ps5Bth_t0RA.jpg"/></div><figcaption class="oc od gj gh gi oe of bd b be z dk translated">等待斐波那契(50)函数完成就像…</figcaption></figure><p id="c458" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那么我们该如何对此进行优化呢？当然是通过记忆。但是我们将使用<a class="ae kw" href="https://lodash.com/docs/4.17.15#memoize" rel="noopener ugc nofollow" target="_blank"> Lodash </a>提供的HOF，而不是实现我们自己的记忆解决方案——并重新发明轮子。</p><blockquote class="kx ky kz"><p id="887d" class="jy jz la ka b kb kc kd ke kf kg kh ki lb kk kl km lc ko kp kq ld ks kt ku kv ij bi translated">注意:如果你从未使用过Lodash，你可以在这里查看它的文档<a class="ae kw" href="https://lodash.com/" rel="noopener ugc nofollow" target="_blank">。</a></p></blockquote><p id="02d4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是完整的解决方案和一个实例:</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="oa ob l"/></div><figcaption class="oc od gj gh gi oe of bd b be z dk translated">实例:<a class="ae kw" href="https://repl.it/@Andrew4d3/efficientFibonacci" rel="noopener ugc nofollow" target="_blank">此处</a></figcaption></figure><p id="91f4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如你所见，我们使用<code class="fe mo mp mq mr b">let</code>而不是<code class="fe mo mp mq mr b">const</code>来定义斐波纳契函数。我们这样做是因为我们需要原始的函数引用被记忆化的调用覆盖。否则无法正常工作。</p><p id="8cfb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们并排比较两个执行输出。我用<a class="ae kw" href="http://codesandbox.io" rel="noopener ugc nofollow" target="_blank"> CodeSandbox.io </a>运行了这些例子:</p><figure class="ms mt mu mv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pi"><img src="../Images/deb85b591538779138dcf9dafd7e2e66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GKmdCiPtfQx9UvNeMRhDvA.png"/></div></div><figcaption class="oc od gj gh gi oe of bd b be z dk translated">左:未改变的斐波那契输出。右图:记忆化的斐波那契输出</figcaption></figure><p id="d5ae" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如您所见，对于每个输入，memoized函数几乎不需要时间(不到1 ms)就能完成。而未改变的功能需要182，248毫秒(超过2分钟)。这确实是一个非常显著的差异。</p><h1 id="e6b5" class="ll lm iq bd ln lo ng lq lr ls nh lu lv lw ni ly lz ma nj mc md me nk mg mh mi bi translated">5.通过声明式工作来避免循环</h1><p id="6099" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">正如我在上一部分提到的，Javascript已经有了一系列内置的高阶函数(HOF)。这些函数大多用于处理数组或对象集合。</p><p id="4a76" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您正在阅读这篇文章，那么您可能已经是一名经验丰富的JS开发人员了。所以我不会花太多时间来详细解释它们每一个——那会非常无聊。</p><p id="979f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我将描述的功能有:</p><ul class=""><li id="8300" class="nl nm iq ka b kb kc kf kg kj nn kn no kr np kv nq nr ns nt bi translated">减少</li><li id="62f4" class="nl nm iq ka b kb nu kf nv kj nw kn nx kr ny kv nq nr ns nt bi translated">地图</li><li id="a667" class="nl nm iq ka b kb nu kf nv kj nw kn nx kr ny kv nq nr ns nt bi translated">为每一个</li><li id="33da" class="nl nm iq ka b kb nu kf nv kj nw kn nx kr ny kv nq nr ns nt bi translated">过滤器</li><li id="8ebb" class="nl nm iq ka b kb nu kf nv kj nw kn nx kr ny kv nq nr ns nt bi translated">发现</li><li id="d6bc" class="nl nm iq ka b kb nu kf nv kj nw kn nx kr ny kv nq nr ns nt bi translated">每个和一些</li></ul><blockquote class="kx ky kz"><p id="da72" class="jy jz la ka b kb kc kd ke kf kg kh ki lb kk kl km lc ko kp kq ld ks kt ku kv ij bi translated">注意:如果您已经知道所有这些方法是如何工作的，请跳到第6部分。</p></blockquote><h2 id="787f" class="ov lm iq bd ln ow ox dn lr oy oz dp lv kj pa pb lz kn pc pd md kr pe pf mh pg bi translated">用Reduce方法计算结果</h2><p id="c416" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">假设你有一个数组，你想计算它的平均值。实现这一点的最佳功能方法是使用内置的HOF <code class="fe mo mp mq mr b">reduce</code>。例如:</p><pre class="ms mt mu mv gt mw mr mx bn my mz bi"><span id="373c" class="na lm iq mr b be nb nc l nd ne">const getAverage = myArray =&gt;<br/>  myArray.<strong class="mr ir">reduce</strong>((sum, val, ind, arr) =&gt; {<br/>    sum += val;<br/>    return ind === arr.length - 1 ? sum / arr.length : sum;<br/>  }, 0);</span></pre><pre class="nf mw mr mx bn my mz bi"><span id="df57" class="na lm iq mr b be nb nc l nd ne">console.log("Average:", getAverage([22, 9, 60, 12, 4, 56])); <br/>// Average: 27.166666666666668</span></pre><blockquote class="kx ky kz"><p id="cec6" class="jy jz la ka b kb kc kd ke kf kg kh ki lb kk kl km lc ko kp kq ld ks kt ku kv ij bi translated"><code class="fe mo mp mq mr b"><strong class="ka ir"><em class="iq">reduce()</em></strong></code>方法对数组的每个元素执行一个<strong class="ka ir"> reducer </strong>函数(您提供的),产生一个输出值。(<a class="ae kw" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce" rel="noopener ugc nofollow" target="_blank"> Mozilla参考</a>)</p></blockquote><p id="8d4e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以在上面的例子中，我们实现了一个接收数字数组的函数。然后，我们继续对这个数组应用reduce方法，并传递(reduce)函数，该函数将对所有数组值求和。一旦到达最后一个，我们将使用数组长度返回除法(平均值)。</p><h2 id="a044" class="ov lm iq bd ln ow ox dn lr oy oz dp lv kj pa pb lz kn pc pd md kr pe pf mh pg bi translated">使用Map方法创建新数组</h2><p id="4613" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">假设您有以下包含几个国家的纬度和经度的对象数组。</p><pre class="ms mt mu mv gt mw mr mx bn my mz bi"><span id="7765" class="na lm iq mr b be nb nc l nd ne">const markers = [<br/>  { name: "UY", lat: -34.9, lon: -56.2 },<br/>  { name: "AR", lat: -34.6, lon: -58.4 },<br/>  { name: "BR", lat: -15.8, lon: -47.9 },<br/>  { name: "BO", lat: -16.5, lon: -68.1 }<br/>];</span></pre><p id="5eb2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在假设我们想要创建一个只有纬度值的数组。使用<code class="fe mo mp mq mr b">map</code>方法很容易做到这一点，如下所示:</p><pre class="ms mt mu mv gt mw mr mx bn my mz bi"><span id="4f4e" class="na lm iq mr b be nb nc l nd ne">console.log("Lat values:", markers.<strong class="mr ir">map</strong>(x =&gt; x.lat));<br/>// Lat values: [ -34.9, -34.6, -15.8, -16.5 ]</span></pre><blockquote class="kx ky kz"><p id="8e10" class="jy jz la ka b kb kc kd ke kf kg kh ki lb kk kl km lc ko kp kq ld ks kt ku kv ij bi translated"><code class="fe mo mp mq mr b"><strong class="ka ir"><em class="iq">map()</em></strong></code>方法<strong class="ka ir">创建一个新的数组</strong>,其中填充了调用数组中每个元素的函数的结果。(<a class="ae kw" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map" rel="noopener ugc nofollow" target="_blank"> Mozilla参考</a>)</p></blockquote><p id="1dd9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上面的例子中，提供的函数只返回纬度值。</p><h2 id="aba3" class="ov lm iq bd ln ow ox dn lr oy oz dp lv kj pa pb lz kn pc pd md kr pe pf mh pg bi translated">使用ForEach方法循环</h2><p id="bb9f" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">有时候，我们唯一想做的事情就是遍历一系列的值或对象。在这种情况下，我们可以使用<code class="fe mo mp mq mr b">forEach</code>。例如，假设我们想要记录所有标记数组数据:</p><pre class="ms mt mu mv gt mw mr mx bn my mz bi"><span id="d870" class="na lm iq mr b be nb nc l nd ne">const logMarkersData = markers =&gt; {<br/>  console.log("Data provided:");</span></pre><pre class="nf mw mr mx bn my mz bi"><span id="fbba" class="na lm iq mr b be nb nc l nd ne">markers.<strong class="mr ir">forEach</strong>(marker =&gt; console.log(`Country: ${marker.name} Latitude: ${marker.lat} Longitude: ${marker.lon}`));<br/>};</span></pre><pre class="nf mw mr mx bn my mz bi"><span id="915d" class="na lm iq mr b be nb nc l nd ne">logMarkersData(markers);<br/>/*<br/>Data provided:<br/>Country: UY Latitude: -34.9 Longitude: -56.2<br/>Country: AR Latitude: -34.6 Longitude: -58.4<br/>Country: BR Latitude: -15.8 Longitude: -47.9<br/>Country: BO Latitude: -16.5 Longitude: -68.1<br/>*/</span></pre><blockquote class="kx ky kz"><p id="22b9" class="jy jz la ka b kb kc kd ke kf kg kh ki lb kk kl km lc ko kp kq ld ks kt ku kv ij bi translated"><code class="fe mo mp mq mr b"><strong class="ka ir"><em class="iq">forEach()</em></strong></code>方法为每个数组元素执行一次提供的函数。(<a class="ae kw" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach" rel="noopener ugc nofollow" target="_blank"> Mozilla参考</a>)</p></blockquote><p id="a28a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个例子很容易理解。<code class="fe mo mp mq mr b">forEach</code>方法将遍历每个元素并记录访问的数据。</p><h2 id="62a2" class="ov lm iq bd ln ow ox dn lr oy oz dp lv kj pa pb lz kn pc pd md kr pe pf mh pg bi translated">用Filter方法过滤数组元素</h2><p id="3888" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">让我们继续使用我们之前使用的标记数组。假设我们要过滤首字母为“B”的国家的数据。<code class="fe mo mp mq mr b">filter</code>方法可以帮到你:</p><pre class="ms mt mu mv gt mw mr mx bn my mz bi"><span id="5321" class="na lm iq mr b be nb nc l nd ne">console.log(<br/>  "Data of countries starting with B:",<br/>  markers.<strong class="mr ir">filter</strong>(mark =&gt; mark.name.charAt(0) === "B")<br/>);</span></pre><pre class="nf mw mr mx bn my mz bi"><span id="7e19" class="na lm iq mr b be nb nc l nd ne">/*<br/>Data of countries starting with B: [ { name: 'BR', lat: -15.8, lon: -47.9 }, { name: 'BO', lat: -16.5, lon: -68.1 } ]<br/>*/</span></pre><blockquote class="kx ky kz"><p id="d14f" class="jy jz la ka b kb kc kd ke kf kg kh ki lb kk kl km lc ko kp kq ld ks kt ku kv ij bi translated"><code class="fe mo mp mq mr b"><strong class="ka ir"><em class="iq">filter()</em></strong></code>方法<strong class="ka ir">创建一个新的数组</strong>，其中所有通过测试的元素都由提供的函数实现。(<a class="ae kw" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter" rel="noopener ugc nofollow" target="_blank"> Mozilla参考</a>)</p></blockquote><h2 id="88be" class="ov lm iq bd ln ow ox dn lr oy oz dp lv kj pa pb lz kn pc pd md kr pe pf mh pg bi translated">使用Find和FindIndex方法查找特定元素</h2><p id="2acc" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">现在情况更具体了。我们只需要巴西的数据。所以我们使用<code class="fe mo mp mq mr b">find</code>方法:</p><pre class="ms mt mu mv gt mw mr mx bn my mz bi"><span id="6265" class="na lm iq mr b be nb nc l nd ne">console.log("Brazil Data:", markers.<strong class="mr ir">find</strong>(m =&gt; m.name === "BR"));</span></pre><pre class="nf mw mr mx bn my mz bi"><span id="39c3" class="na lm iq mr b be nb nc l nd ne">// Brazil Data: { name: 'BR', lat: -15.8, lon: -47.9 }</span></pre><blockquote class="kx ky kz"><p id="cc3a" class="jy jz la ka b kb kc kd ke kf kg kh ki lb kk kl km lc ko kp kq ld ks kt ku kv ij bi translated"><code class="fe mo mp mq mr b"><strong class="ka ir"><em class="iq">find()</em></strong></code>方法返回所提供数组中满足所提供测试函数的<strong class="ka ir">第一个元素</strong>的<strong class="ka ir">值</strong>。(<a class="ae kw" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find" rel="noopener ugc nofollow" target="_blank"> Mozilla参考</a>)</p></blockquote><p id="7de0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是如果你只想知道指数呢？我们将使用<code class="fe mo mp mq mr b">findIndex</code>方法来代替。</p><pre class="ms mt mu mv gt mw mr mx bn my mz bi"><span id="2ad4" class="na lm iq mr b be nb nc l nd ne">console.log("Brazil Data Index:", markers.<strong class="mr ir">findIndex</strong>(m =&gt; m.name === "BR"));</span></pre><pre class="nf mw mr mx bn my mz bi"><span id="1ecd" class="na lm iq mr b be nb nc l nd ne">// Brazil Data Index: 2</span></pre><blockquote class="kx ky kz"><p id="1d80" class="jy jz la ka b kb kc kd ke kf kg kh ki lb kk kl km lc ko kp kq ld ks kt ku kv ij bi translated"><code class="fe mo mp mq mr b"><strong class="ka ir"><em class="iq">findIndex()</em></strong></code>方法返回满足提供的测试函数的数组<strong class="ka ir">中第一个元素的<strong class="ka ir">索引</strong>。否则，它返回-1，表示没有元素通过测试。(<a class="ae kw" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex" rel="noopener ugc nofollow" target="_blank"> Mozilla参考</a>)</strong></p></blockquote><h2 id="0e84" class="ov lm iq bd ln ow ox dn lr oy oz dp lv kj pa pb lz kn pc pd md kr pe pf mh pg bi translated">用Every和Some方法链接逻辑运算</h2><figure class="ms mt mu mv gt jr gh gi paragraph-image"><div class="gh gi pj"><img src="../Images/077a9748bda32bb6f1e24f1f494fe3f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:952/format:webp/1*UmiGPU_sueXUKw7Z4k7qfQ.png"/></div><figcaption class="oc od gj gh gi oe of bd b be z dk translated">你还记得迷路吗？</figcaption></figure><p id="53ef" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我最近遇到了这两种方法。当您需要确定数组中的所有元素是否满足特定逻辑时，它们尤其有用。这相当于按顺序使用AND/OR运算符。所以与其做这样的事情:</p><pre class="ms mt mu mv gt mw mr mx bn my mz bi"><span id="028d" class="na lm iq mr b be nb nc l nd ne">if (arr[0] &gt; 0 &amp;&amp; arr[1] &gt; 0 ..... arr[n] &gt; 0) {...}</span></pre><p id="22aa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以这样做:</p><pre class="ms mt mu mv gt mw mr mx bn my mz bi"><span id="438b" class="na lm iq mr b be nb nc l nd ne">if (arr.every(item =&gt; item &gt; 0)) {...}</span></pre><p id="fc9d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这同样适用于OR运算符，但这次使用的是<code class="fe mo mp mq mr b">some</code>方法。</p><p id="230e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们通过一个例子来看看这一点。假设我们有一个数字序列(例如:4、8、15、16、23和42 ),我们想确定是否至少有一个<strong class="ka ir">甚至</strong>数字。对于这种情况，我们需要使用<code class="fe mo mp mq mr b">some</code>方法:</p><pre class="ms mt mu mv gt mw mr mx bn my mz bi"><span id="50d1" class="na lm iq mr b be nb nc l nd ne">const lostNumbers = [4, 8, 15, 16, 23, 42];</span></pre><pre class="nf mw mr mx bn my mz bi"><span id="14e0" class="na lm iq mr b be nb nc l nd ne">console.log(<br/>  "Does it contain even numbers?",<br/>  lostNumbers.<strong class="mr ir">some</strong>(n =&gt; n % 2 === 0)<br/>);</span></pre><pre class="nf mw mr mx bn my mz bi"><span id="1290" class="na lm iq mr b be nb nc l nd ne">// Does it contain even numbers? true</span></pre><blockquote class="kx ky kz"><p id="32fb" class="jy jz la ka b kb kc kd ke kf kg kh ki lb kk kl km lc ko kp kq ld ks kt ku kv ij bi translated"><code class="fe mo mp mq mr b"><strong class="ka ir"><em class="iq">some()</em></strong></code>方法测试数组中是否至少有一个元素通过了由提供的函数实现的测试。它返回一个布尔值。</p></blockquote><p id="13bb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另一方面，如果我们想确定所有的数组编号是否都是偶数，我们需要像这样使用<code class="fe mo mp mq mr b">every</code>方法:</p><pre class="ms mt mu mv gt mw mr mx bn my mz bi"><span id="f3da" class="na lm iq mr b be nb nc l nd ne">console.log("Are all even numbers?", lostNumbers.<strong class="mr ir">every</strong>(n =&gt; n % 2 === 0));</span></pre><pre class="nf mw mr mx bn my mz bi"><span id="75ba" class="na lm iq mr b be nb nc l nd ne">// Are all even numbers? false</span></pre><blockquote class="kx ky kz"><p id="a961" class="jy jz la ka b kb kc kd ke kf kg kh ki lb kk kl km lc ko kp kq ld ks kt ku kv ij bi translated"><code class="fe mo mp mq mr b"><strong class="ka ir"><em class="iq">every()</em></strong></code>方法测试数组中的所有元素是否都通过了由提供的函数实现的测试。它返回一个布尔值。</p></blockquote><h1 id="4253" class="ll lm iq bd ln lo ng lq lr ls nh lu lv lw ni ly lz ma nj mc md me nk mg mh mi bi translated">6.使用函数组合来组合函数</h1><p id="ef6e" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">理想情况下，我们的函数应该很小。他们应该能够只做一件事，并且做好。那么，我们如何将所有这些“小”功能结合起来共同工作呢？实现这一点的一种方法是通过<strong class="ka ir">函数组合</strong>。这听起来像是一个<em class="la">奇特的数学概念</em>，不知何故——的确如此。然而，这并没有那么难理解。<strong class="ka ir"> </strong>它包括<strong class="ka ir">使一个函数的结果成为下一个函数的参数</strong>。</p><p id="710d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">函数组合有两种风格:<strong class="ka ir">流水线和组合</strong>。他们非常相似，但是不同。一个从左向右工作，而另一个从相反的方向工作。</p><figure class="ms mt mu mv gt jr gh gi paragraph-image"><div class="gh gi pk"><img src="../Images/9aa7b71796e67c7e39eee82318886182.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/0*ACQCIfwdJE_4-__P.gif"/></div><figcaption class="oc od gj gh gi oe of bd b be z dk translated">简单地说，流水线和合成</figcaption></figure><h2 id="c92f" class="ov lm iq bd ln ow ox dn lr oy oz dp lv kj pa pb lz kn pc pd md kr pe pf mh pg bi translated">管道铺设</h2><blockquote class="kx ky kz"><p id="ebec" class="jy jz la ka b kb kc kd ke kf kg kh ki lb kk kl km lc ko kp kq ld ks kt ku kv ij bi translated">注意:在Federico Kereki的书中，他讲述了如何从头开始实现一个“管道”函数。但是这里我们将使用由<strong class="ka ir"> Lodash </strong>提供的解决方案。</p></blockquote><p id="b865" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于Lodash，我们有两种选择。第一个是通过使用标准API中的方法<code class="fe mo mp mq mr b">flow</code>，第二个是通过使用FP API中的方法<code class="fe mo mp mq mr b">pipe</code>。让我们从两个方面来探讨一个例子。</p><p id="85fd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">假设我们需要连接到仍然使用XML作为数据格式的遗留web服务(SOAP WS或类似的服务)。这个WS正在提供一些书籍信息，如下所示:</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="oa ob l"/></div><figcaption class="oc od gj gh gi oe of bd b be z dk translated">图书WS响应示例</figcaption></figure><p id="8ccf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的任务如下。接受上面的回答，然后:</p><ul class=""><li id="4530" class="nl nm iq ka b kb kc kf kg kj nn kn no kr np kv nq nr ns nt bi translated">按价格(升序)和…</li><li id="f84a" class="nl nm iq ka b kb nu kf nv kj nw kn nx kr ny kv nq nr ns nt bi translated">以JSON格式打印信息(使用<code class="fe mo mp mq mr b">console.log</code>)</li></ul><p id="0fae" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">原来(在JS中)处理XML格式的数据完全是a** 中的<em class="la">痛。幸运的是，有几个库可以用来将XML转换成方便的JS对象。在这个例子中，我们将使用其中一个叫做<a class="ae kw" href="https://www.npmjs.com/package/xml-js" rel="noopener ugc nofollow" target="_blank"> xml-js </a>的。</em></p><p id="8016" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，让我们从“web服务”中获取数据。不幸的是，我们手头没有。所以让我们假装一下:</p><pre class="ms mt mu mv gt mw mr mx bn my mz bi"><span id="f97e" class="na lm iq mr b be nb nc l nd ne"><em class="la">// Let's pretend this is a Webservice call<br/></em>const getingWsData = () =&gt;<br/>   Promise.resolve(fs.readFileSync(`${__dirname}/books.xml`, "utf8"));</span></pre><p id="11de" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，让我们从XML响应中提取所需的信息。我们将使用一个名为<code class="fe mo mp mq mr b">get</code>的实用Lodash函数，通过提供一个对象路径、<code class="fe mo mp mq mr b">map</code>方法(我们在上一部分已经描述过)和解析初始XML文本的<code class="fe mo mp mq mr b">xml2js</code>库方法来轻松获取值。</p><pre class="ms mt mu mv gt mw mr mx bn my mz bi"><span id="2417" class="na lm iq mr b be nb nc l nd ne">const transformToJsObject = xmlData =&gt;<br/>  _(<strong class="mr ir">xmlJs</strong>.<strong class="mr ir">xml2js</strong>(xmlData, { compact: true })) <em class="la">// Transforming to JS</em><br/>    .<strong class="mr ir">get</strong>("Library.Book") <em class="la">// Getting Books reference</em><br/>    .<strong class="mr ir">map</strong>(book =&gt; ({ <em class="la">// Interating books array to generate new one</em><br/>      author: book.Author._text,<br/>      title: book.Title._text,<br/>      year: Number(book.Year._text),<br/>      price: Number(book.Price._text)<br/>    }));</span></pre><blockquote class="kx ky kz"><p id="1685" class="jy jz la ka b kb kc kd ke kf kg kh ki lb kk kl km lc ko kp kq ld ks kt ku kv ij bi translated">注意:我不包括对XML数据的任何验证。所以让我们假设它是格式良好的，年份和价格值都是数字。但是对于生产应用程序，您可能需要仔细检查这一点。</p></blockquote><p id="0b24" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，我们按价格金额排序。这里，我们可以使用内置的<code class="fe mo mp mq mr b">sort</code>方法(参考<a class="ae kw" href="https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Objetos_globales/Array/sort" rel="noopener ugc nofollow" target="_blank">这里</a>)。但是它改变了目标数组，使得我们的函数<strong class="ka ir">不纯</strong>。所以我们最好使用洛达什当量<code class="fe mo mp mq mr b">sortBy</code>如下:</p><pre class="ms mt mu mv gt mw mr mx bn my mz bi"><span id="b4cc" class="na lm iq mr b be nb nc l nd ne">const sortByPrice = booksArray =&gt; _.<strong class="mr ir">sortBy</strong>(booksArray, "price");</span></pre><p id="8a55" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们已经定义了完成指定任务所需的所有功能。但是我们如何将它们联系在一起呢？你的第一个猜测可能是用众所周知的祈使句:</p><pre class="ms mt mu mv gt mw mr mx bn my mz bi"><span id="154c" class="na lm iq mr b be nb nc l nd ne">let <strong class="mr ir">booksArray</strong> = transformToJsObject(xmlData);<br/><strong class="mr ir">booksArray</strong> = sortByPrice(booksArray);<br/>const <strong class="mr ir">jsonData</strong> = JSON.stringify(booksArray);<br/>console.log(<strong class="mr ir">jsonData</strong>);</span></pre><p id="b739" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它工作得很好，但是需要太多的线路！此外，注意我们需要使用多少中间变量/常数。您可能会有这样的想法，通过在一行中做一些事情来简化所有事情，就像这样:</p><pre class="ms mt mu mv gt mw mr mx bn my mz bi"><span id="e39c" class="na lm iq mr b be nb nc l nd ne">console.log(JSON.stringify(sortByPrice(transformToJsObject(xmlData))));</span></pre><p id="84d6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是现在一切都变成了<em class="la">不可读的括号地狱</em>。所以让我们应用流水线技术。首先用标准Lodash <code class="fe mo mp mq mr b">flow</code>方法:</p><pre class="ms mt mu mv gt mw mr mx bn my mz bi"><span id="192c" class="na lm iq mr b be nb nc l nd ne">_.<strong class="mr ir">flow</strong>(<br/>   transformToJsObject,<br/>   sortByPrice,<br/>   JSON.stringify,<br/>   console.log<br/>)(xmlData);</span></pre><p id="c364" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在有了FP Lodash <code class="fe mo mp mq mr b">pipe</code>:</p><pre class="ms mt mu mv gt mw mr mx bn my mz bi"><span id="423a" class="na lm iq mr b be nb nc l nd ne">fp.<strong class="mr ir">pipe</strong>(<br/>   transformToJsObject,<br/>   sortByPrice,<br/>   JSON.stringify,<br/>   console.log<br/>)(xmlData);</span></pre><p id="6f81" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如你所见，两个高阶函数几乎完全相同。两者都以相同的顺序接收参数，即从左到右，最左边的函数将是最先被调用的函数。下面是完整的示例:</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="oa ob l"/></div><figcaption class="oc od gj gh gi oe of bd b be z dk translated">实例:<a class="ae kw" href="https://repl.it/@Andrew4d3/PipeliningExample" rel="noopener ugc nofollow" target="_blank">此处</a></figcaption></figure><h2 id="888f" class="ov lm iq bd ln ow ox dn lr oy oz dp lv kj pa pb lz kn pc pd md kr pe pf mh pg bi translated">组成</h2><p id="6e48" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">正如我之前提到的，作曲的工作方式与流水线非常相似。所以让我们看一下同一个例子，但是这次使用了<code class="fe mo mp mq mr b">compose</code>和<code class="fe mo mp mq mr b">flowRight</code>。</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="oa ob l"/></div><figcaption class="oc od gj gh gi oe of bd b be z dk translated">实例:<a class="ae kw" href="https://repl.it/@Andrew4d3/composingExample" rel="noopener ugc nofollow" target="_blank">此处</a></figcaption></figure><p id="5297" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如您所见，<code class="fe mo mp mq mr b">flowRight</code>和<code class="fe mo mp mq mr b">compose</code>方法的工作方式与<code class="fe mo mp mq mr b">flow</code>和<code class="fe mo mp mq mr b">pipe</code>相似。唯一的区别是参数的顺序现在颠倒了(从右到左)。但是输出结果和之前一模一样。</p><p id="af48" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">看到这里，你可能会想:<strong class="ka ir">我该用哪个？</strong>而答案是<em class="la">你更喜欢的那个！</em>就我个人而言，我更倾向于使用流水线技术，因为我们通常从左到右阅读，所以对我来说朝那个方向走更自然。但是其他人可能更喜欢使用组合，因为初始参数更接近接收它的函数。只要你明白自己在做什么，无论你使用哪种方法都没问题。</p><h1 id="ce19" class="ll lm iq bd ln lo ng lq lr ls nh lu lv lw ni ly lz ma nj mc md me nk mg mh mi bi translated">7.Currying的可重用性</h1><p id="dcd0" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">在上一部分中，我们看到了如何使用函数组合将函数组合在一起工作。现在让我问你一个关于它的问题:</p><blockquote class="og"><p id="148e" class="oh oi iq bd oj ok ol om on oo op kv dk translated">你注意到这些功能的一个特殊特征了吗？</p></blockquote><p id="02bf" class="pw-post-body-paragraph jy jz iq ka b kb oq kd ke kf or kh ki kj os kl km kn ot kp kq kr ou kt ku kv ij bi translated">我说的是管道和合成器中使用的函数。你注意到他们了吗？原来他们总是有一个单一的论点。因为前面的函数只能有一个返回值。因此，为了让我们的函数与管道或合成器一起工作，默认情况下，它们需要是<strong class="ka ir">一元</strong>(一个参数)。Currying是将非一元函数转换成一元形式的简单方法。</p><figure class="ms mt mu mv gt jr gh gi paragraph-image"><div class="gh gi pl"><img src="../Images/c0b32e30de6d03250acbc0613c4e06a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1282/format:webp/1*CPptuK2GuJNBQJDaQDfZ7w.png"/></div><figcaption class="oc od gj gh gi oe of bd b be z dk translated">只是澄清一下，我说的不是这种咖喱…</figcaption></figure><p id="c0d3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们通过一个例子来看看这一点。在这里，您可以看到一个将三个数字相加的函数，这并不新鲜:</p><pre class="ms mt mu mv gt mw mr mx bn my mz bi"><span id="f093" class="na lm iq mr b be nb nc l nd ne">const sum = (a, b, c) =&gt; a + b + c;</span></pre><p id="9e4e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个函数的<strong class="ka ir">版本应该是这样的:</strong></p><pre class="ms mt mu mv gt mw mr mx bn my mz bi"><span id="def3" class="na lm iq mr b be nb nc l nd ne">const sum = (a) =&gt; (b) =&gt; (c) =&gt; a + b + c;</span></pre><p id="602e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们有一个函数返回一个函数，这个函数返回另一个函数。为了将这种简化版称为“sum ”,您可以这样做:</p><pre class="ms mt mu mv gt mw mr mx bn my mz bi"><span id="0db8" class="na lm iq mr b be nb nc l nd ne">sum(1)(2)(3); // <em class="la">Result is 6</em></span></pre><p id="3c16" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我知道你在想什么… <em class="la">我们到底从中得到了什么？</em>答案很简单:<strong class="ka ir">如果函数的初始参数在多次调用中没有变化，你可以创建函数的定制版本</strong>。例如，假设您有一个计算给定百分比的折扣的函数。它看起来像这样:</p><pre class="ms mt mu mv gt mw mr mx bn my mz bi"><span id="28ff" class="na lm iq mr b be nb nc l nd ne">comesconst calculateDiscount = (discount, price) =&gt; price - (price * discount) / 100;</span></pre><pre class="nf mw mr mx bn my mz bi"><span id="4fa8" class="na lm iq mr b be nb nc l nd ne">console.log(calculateDiscount(10, 2000)); // 1800</span></pre><p id="cff1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，让我们设想一种情况，我们需要对不同的产品(不同的价格)应用相同的折扣。这意味着多次重复相同的第一个参数:</p><pre class="ms mt mu mv gt mw mr mx bn my mz bi"><span id="ce79" class="na lm iq mr b be nb nc l nd ne">console.log(calculateDiscount(10, 2000)); // 1800</span></pre><pre class="nf mw mr mx bn my mz bi"><span id="b2cd" class="na lm iq mr b be nb nc l nd ne">console.log(calculateDiscount(10, 500)); // 450</span></pre><pre class="nf mw mr mx bn my mz bi"><span id="26ed" class="na lm iq mr b be nb nc l nd ne">console.log(calculateDiscount(10, 750)); // 675</span></pre><pre class="nf mw mr mx bn my mz bi"><span id="2b40" class="na lm iq mr b be nb nc l nd ne">console.log(calculateDiscount(10, 900)); // 810</span></pre><p id="c503" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">也许多次重复一个参数没什么大不了的，但是想象一下重复参数的数量更多(2、4、5等)的情况，让我们对这个<code class="fe mo mp mq mr b">calculateDiscount</code>函数应用currying。为此，我们将使用Lodash的<code class="fe mo mp mq mr b">curry</code>方法:</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="oa ob l"/></div><figcaption class="oc od gj gh gi oe of bd b be z dk translated">实例:<a class="ae kw" href="https://repl.it/@Andrew4d3/curryExample" rel="noopener ugc nofollow" target="_blank">此处</a></figcaption></figure><p id="52f2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如你在上面看到的，我们将currying应用于<code class="fe mo mp mq mr b">calculateDiscount</code>函数，同时，我们将第一个参数(折扣百分比)传递给结果函数。现在我们有了一个新函数，它的唯一目的是计算任何给定价格的10%折扣。</p><p id="270e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当然，这不是唯一可以使用currying的实际情况。想想您必须为一个事件创建多个侦听器的情况。您可以对负责添加侦听器的函数应用curry，并在需要时使用该(curry)函数。像这样的，还有很多其他的例子。</p><h1 id="14ae" class="ll lm iq bd ln lo ng lq lr ls nh lu lv lw ni ly lz ma nj mc md me nk mg mh mi bi translated">8.部分应用的可重用性</h1><p id="bf08" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">当我们的常量参数按顺序排列时，curry是有用的。但有时情况并非如此，我们必须处理固定参数不遵循任何特定顺序的情况。这就是<strong class="ka ir">局部应用</strong>技术派上用场的地方。</p><p id="51e3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们检查一个新的例子，看看这是如何工作的。假设您有一个简单的Winston logger实例，如下所示:</p><pre class="ms mt mu mv gt mw mr mx bn my mz bi"><span id="5b45" class="na lm iq mr b be nb nc l nd ne">const logger = <strong class="mr ir">winston</strong>.createLogger({<br/>  transports: [new winston.transports.Console()]<br/>});</span></pre><blockquote class="kx ky kz"><p id="e4ba" class="jy jz la ka b kb kc kd ke kf kg kh ki lb kk kl km lc ko kp kq ld ks kt ku kv ij bi translated">注意:Winson是一个很容易管理NodeJS日志的库。如果你想了解更多，可以查看它的github回购<a class="ae kw" href="https://github.com/winstonjs/winston" rel="noopener ugc nofollow" target="_blank">这里</a>。</p></blockquote><p id="3072" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们假设我们正在开发一个有多个步骤的系统——就像一个流水线。我们希望记录与特定步骤相对应的消息，可能是因为我们希望为我们的系统提供一些“可跟踪性”。比如:<code class="fe mo mp mq mr b">step: "Order Preparation", message: "Assigning Carrier to order XXX"</code>。让我们定义一个这样的函数:</p><pre class="ms mt mu mv gt mw mr mx bn my mz bi"><span id="0a72" class="na lm iq mr b be nb nc l nd ne">const logMessage = (level, message, step, loggerFn = <strong class="mr ir">logger</strong>) =&gt;<br/>  loggerFn[level]({ message, step });</span></pre><p id="1cd0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如你所看到的，我们正在将logger实例注入到<code class="fe mo mp mq mr b">logMessage</code>函数中。现在，我们可以像这样调用这个函数来开始记录消息:</p><pre class="ms mt mu mv gt mw mr mx bn my mz bi"><span id="9114" class="na lm iq mr b be nb nc l nd ne">logMessage("info", "<!-- -->Assigning Carrier to order XXX", "Order Preparation")</span></pre><p id="7824" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这种方法的问题是，如果我们必须在相同的步骤和相同的(info)级别记录多个消息，我们将需要多次重复相同的两个参数<code class="fe mo mp mq mr b">"info"</code>和<code class="fe mo mp mq mr b">"Order Preparation"</code>。因此，让我们应用部分应用(使用Lodash)来修复这两个参数。</p><pre class="ms mt mu mv gt mw mr mx bn my mz bi"><span id="ec07" class="na lm iq mr b be nb nc l nd ne">const loggerStepInfo = _.partial(logMessage, "info", _, "Order Preparation");</span></pre><p id="7038" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Lodash使用<code class="fe mo mp mq mr b">_</code>来表示一个“占位符”参数，它(在本例中)是唯一可改变的参数。但是，如果需要的话，我们可以设置多个占位符参数。这是涂抹和部分涂抹的主要区别之一。<strong class="ka ir">结果函数不必是一元的。</strong></p><p id="0e9c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们用一些示例调用来测试我们的结果函数:</p><pre class="ms mt mu mv gt mw mr mx bn my mz bi"><span id="ffba" class="na lm iq mr b be nb nc l nd ne">loggerStepInfo("Doing something");<br/>loggerStepInfo("Doing another thing on same step");<br/>loggerStepInfo("Doing some last thing");</span></pre><p id="b8d1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">输出应该是这样的:</p><figure class="ms mt mu mv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pm"><img src="../Images/e56ef8a330465fcb7a391fa1aae8b24f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JKewPz_vjs32pWOPdEyi9w.png"/></div></div></figure><p id="eab4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里是完整的代码及其实例:</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="oa ob l"/></div><figcaption class="oc od gj gh gi oe of bd b be z dk translated">活生生的例子:<a class="ae kw" href="https://repl.it/@Andrew4d3/partialExample" rel="noopener ugc nofollow" target="_blank">这里</a></figcaption></figure></div><div class="ab cl le lf hu lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ij ik il im in"><h1 id="f42b" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">结论</h1><p id="ac7a" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">使用函数式编程并不是万能的。如果你的代码是用函数式风格编写的，它不会变得更好。所以你可以决定是否使用你在这里或其他地方看到的任何FP技巧。</p><p id="2295" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">依我拙见，当涉及到设计和实现不需要访问外部资源(文件、数据库、API)的复杂算法或执行复杂计算时，我喜欢用函数式和声明式的方式。因为我可以很容易地对一切进行单元测试和解耦。但是如果我必须集中处理外部资源，我会选择众所周知的命令式。<em class="la">再说一遍，这只是我！你可能会有不同的想法！</em></p><p id="3247" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我认为这里的关键因素，是将你的项目中不纯的部分与纯的部分分开。这样当你觉得方便的时候，你就可以轻松地解耦你的代码并应用FP技术。</p><p id="fa50" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这篇文章中，我没有提到其他与FP相关的概念，比如递归优化、单子、函子等等。我发现它们很难理解，而且几乎没有实际用例，所以我决定跳过它们。如果你仍然对它们感到好奇，我会建议你(再次)阅读费德里科·凯瑞基的书<a class="ae kw" href="https://www.amazon.com/Mastering-JavaScript-Functional-Programming-depth/dp/1787287440/ref=sr_1_2?crid=2F1F6HDZXSFQM&amp;keywords=federico+kereki&amp;qid=1578446774&amp;sprefix=federico+kere%2Caps%2C302&amp;sr=8-2" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">掌握JavaScript函数式编程</strong> </a> <strong class="ka ir">。</strong></p><p id="ae42" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="la">编码快乐！</em></p></div></div>    
</body>
</html>