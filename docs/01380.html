<html>
<head>
<title>How to Use Closures in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在JavaScript中使用闭包</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/using-closures-in-javascript-to-create-private-variables-c0b358757fe0?source=collection_archive---------7-----------------------#2019-12-19">https://levelup.gitconnected.com/using-closures-in-javascript-to-create-private-variables-c0b358757fe0?source=collection_archive---------7-----------------------#2019-12-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/da2bdce3daa0996f2918fd96d90c3e2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zwiq7r0qkPRde91J"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@dtopkin1?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">戴恩·托普金</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="1e36" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">问题陈述</h1><p id="6a0f" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">JavaScript对象只是属性的集合。使用object literal语法或构造函数，可以轻松地创建对象和添加属性。下面是一个代码示例:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="900c" class="ml kh it mh b gy mm mn l mo mp">//object literal syntax <br/>var person1 = { <br/>  firstName: 'alex', <br/>  lastName: 'ritzcovan' <br/>}</span><span id="eae2" class="ml kh it mh b gy mq mn l mo mp">//constructor syntax <br/>function Person(first, last) { <br/>  this.firstName = first; <br/>  this.lastName = last); <br/>}</span><span id="dd3d" class="ml kh it mh b gy mq mn l mo mp">//create a new person using our constructor <br/>var person2 = new Person('alex', 'ritzcovan');</span></pre><p id="8b96" class="pw-post-body-paragraph le lf it lg b lh mr lj lk ll ms ln lo lp mt lr ls lt mu lv lw lx mv lz ma mb im bi translated">这些方法中的每一种都给我们相同的结果。我们有一个新的对象，它有名字和姓氏属性。这很好，当然也很容易，但这种容易是有代价的。</p><p id="4fef" class="pw-post-body-paragraph le lf it lg b lh mr lj lk ll ms ln lo lp mt lr ls lt mu lv lw lx mv lz ma mb im bi translated">如果我做了以下事情会怎么样？</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="cd9b" class="ml kh it mh b gy mm mn l mo mp">delete person.firstName;</span></pre><p id="89fc" class="pw-post-body-paragraph le lf it lg b lh mr lj lk ll ms ln lo lp mt lr ls lt mu lv lw lx mv lz ma mb im bi translated">执行这段代码会做您可能会想到的事情。它从对象中删除firstName属性。虽然这在某些情况下可能很方便，但更多的时候，您希望在JavaScript对象上定义的属性是私有的。</p><p id="dea6" class="pw-post-body-paragraph le lf it lg b lh mr lj lk ll ms ln lo lp mt lr ls lt mu lv lw lx mv lz ma mb im bi translated"><em class="mw">外部世界的直接进入剥夺了你控制财产价值的能力。</em></p><p id="04ec" class="pw-post-body-paragraph le lf it lg b lh mr lj lk ll ms ln lo lp mt lr ls lt mu lv lw lx mv lz ma mb im bi translated">这就是为什么这么多流行的面向对象语言提供了<em class="mw"> private </em>关键字。一旦一个变量在这些语言中被声明为私有，程序员就创建<em class="mw"> get </em>和<em class="mw"> set </em>函数来获取和设置值。它让程序员可以控制被赋值的值，并允许其他特性，比如当值被获取或设置时进行日志记录。</p><p id="d813" class="pw-post-body-paragraph le lf it lg b lh mr lj lk ll ms ln lo lp mt lr ls lt mu lv lw lx mv lz ma mb im bi translated">不幸的是，JavaScript没有为我们提供任何模拟private关键字的语法特性。然而，它确实为我们提供了闭包。使用闭包，我们可以模拟私有属性。在我们看如何做到这一点之前，让我们确保理解了闭包。</p><h1 id="ae36" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">定义的闭包</h1><p id="d29c" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">MDN文档对闭包的定义如下:</p><blockquote class="mx my mz"><p id="06ff" class="le lf mw lg b lh mr lj lk ll ms ln lo na mt lr ls nb mu lv lw nc mv lz ma mb im bi translated"><em class="it">一个</em> <strong class="lg iu"> <em class="it">闭包</em> </strong> <em class="it">是用对其周围状态的引用捆绑在一起(括起来)的一个函数的组合(这个</em> <strong class="lg iu"> <em class="it">词法环境</em> </strong> <em class="it">)。换句话说，闭包允许您从内部函数访问外部函数的范围。在JavaScript中，闭包是在每次创建函数时创建的。</em></p><p id="ff22" class="le lf mw lg b lh mr lj lk ll ms ln lo na mt lr ls nb mu lv lw nc mv lz ma mb im bi translated">MDN</p></blockquote><p id="9666" class="pw-post-body-paragraph le lf it lg b lh mr lj lk ll ms ln lo lp mt lr ls lt mu lv lw lx mv lz ma mb im bi translated">我不知道你怎么想，但是当我学习闭包的时候，这个定义让我感觉有点像这样:</p><figure class="mc md me mf gt ju gh gi paragraph-image"><div class="ab gu cl nd"><img src="../Images/96200464dd3f7da50ea6ed4e01042bf2.png" data-original-src="https://miro.medium.com/v2/0*8Aa13fnFeY8sNVmE"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">迷失在酱汁中</figcaption></figure><p id="7b25" class="pw-post-body-paragraph le lf it lg b lh mr lj lk ll ms ln lo lp mt lr ls lt mu lv lw lx mv lz ma mb im bi translated">我喜欢这样想:</p><p id="97f4" class="pw-post-body-paragraph le lf it lg b lh mr lj lk ll ms ln lo lp mt lr ls lt mu lv lw lx mv lz ma mb im bi translated">每次调用函数时都会创建一个闭包。它包含函数定义以及周围的状态。代码中定义<em class="mw">功能的位置</em>决定了闭包中包含的内容。</p><p id="7b04" class="pw-post-body-paragraph le lf it lg b lh mr lj lk ll ms ln lo lp mt lr ls lt mu lv lw lx mv lz ma mb im bi translated">让我们看一些代码</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="37d3" class="ml kh it mh b gy mm mn l mo mp">//GLOBAL SCOPE var ten = 10;</span><span id="e935" class="ml kh it mh b gy mq mn l mo mp">function makeAdder(num) { <br/>  // OUTER SCOPE <br/>  function add(num2) {  <br/>    // INNER SCOPE <br/>    console.log(ten); //&lt;-- we can still see ten here <br/>    return num + num2; <br/>  } <br/>  return add; <br/>}</span><span id="5237" class="ml kh it mh b gy mq mn l mo mp">var adder1 = makeAdder(10); <br/>var adder2 = makeAdder(20); <br/>console.log(adder1(10)); <br/>console.log(adder2(500));</span></pre><p id="f7a5" class="pw-post-body-paragraph le lf it lg b lh mr lj lk ll ms ln lo lp mt lr ls lt mu lv lw lx mv lz ma mb im bi translated">让我们把这段代码拆开。</p><p id="d593" class="pw-post-body-paragraph le lf it lg b lh mr lj lk ll ms ln lo lp mt lr ls lt mu lv lw lx mv lz ma mb im bi translated">首先，我们在全局范围内声明一个名为ten的变量。</p><p id="fcb4" class="pw-post-body-paragraph le lf it lg b lh mr lj lk ll ms ln lo lp mt lr ls lt mu lv lw lx mv lz ma mb im bi translated">接下来，我们有makeAdder()函数，它接受一个数字作为参数。在makeAdder()中，我们定义了另一个名为add()的函数。</p><p id="6697" class="pw-post-body-paragraph le lf it lg b lh mr lj lk ll ms ln lo lp mt lr ls lt mu lv lw lx mv lz ma mb im bi translated">在add()中，我们只打印十的值(只是为了表明我们仍然可以看到它)，并返回简单加法的结果。</p><p id="3a67" class="pw-post-body-paragraph le lf it lg b lh mr lj lk ll ms ln lo lp mt lr ls lt mu lv lw lx mv lz ma mb im bi translated">在下一行，<em class="mw">我们返回add函数</em>，makeAdder()函数退出。</p><p id="a6ea" class="pw-post-body-paragraph le lf it lg b lh mr lj lk ll ms ln lo lp mt lr ls lt mu lv lw lx mv lz ma mb im bi translated">刚才我们说过<em class="mw">你可以通过查看定义它的地方来确定闭包里会有什么。嗯，通过查看add方法，我们可以看到我们将要访问:</em></p><ol class=""><li id="f840" class="ne nf it lg b lh mr ll ms lp ng lt nh lx ni mb nj nk nl nm bi translated">在全局范围内定义的全局变量ten</li><li id="7ce1" class="ne nf it lg b lh nn ll no lp np lt nq lx nr mb nj nk nl nm bi translated">即使在makeAdder()退出之后，num参数也被传递到makeAdder() — <em class="mw">中。在外部范围中定义</em></li></ol><p id="6f3a" class="pw-post-body-paragraph le lf it lg b lh mr lj lk ll ms ln lo lp mt lr ls lt mu lv lw lx mv lz ma mb im bi translated"><strong class="lg iu"> <em class="mw">这是一些神奇的闭包。在定义这些值的函数执行完毕后，您就可以访问这些值了。</em>T9】</strong></p><p id="2b3c" class="pw-post-body-paragraph le lf it lg b lh mr lj lk ll ms ln lo lp mt lr ls lt mu lv lw lx mv lz ma mb im bi translated">接下来，我们创建2个新的加法器，通过调用makeAdder(10)和makeAdder(20)传递我们希望保存在num参数中的值。</p><p id="0b68" class="pw-post-body-paragraph le lf it lg b lh mr lj lk ll ms ln lo lp mt lr ls lt mu lv lw lx mv lz ma mb im bi translated">返回的<em class="mw">函数分别保存到adder1和adder2 </em>变量中。接下来，我们<em class="mw">执行adder1和adder2 </em>(它们是对函数的引用)，传递我们想要添加的值。查看控制台，我们看到以下输出。</p><figure class="mc md me mf gt ju gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/7f96d7ac6ee5de10b86ece03fc2eb05b.png" data-original-src="https://miro.medium.com/v2/resize:fit:210/format:webp/0*RmKkXVXuQd6c1did.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">使用闭包的函数的输出</figcaption></figure><p id="4c23" class="pw-post-body-paragraph le lf it lg b lh mr lj lk ll ms ln lo lp mt lr ls lt mu lv lw lx mv lz ma mb im bi translated">首先，我们看到10。当add函数打印出<em class="mw">全局变量ten </em>的值时，就会打印出来。实际上你不会这么做。这只是为了表明我们仍然可以在闭包中访问它。</p><p id="4de3" class="pw-post-body-paragraph le lf it lg b lh mr lj lk ll ms ln lo lp mt lr ls lt mu lv lw lx mv lz ma mb im bi translated">然后我们看到通过adder1引用对add()的第一次调用。</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="a0a7" class="ml kh it mh b gy mm mn l mo mp">console.log(adder1(10));</span></pre><p id="98c2" class="pw-post-body-paragraph le lf it lg b lh mr lj lk ll ms ln lo lp mt lr ls lt mu lv lw lx mv lz ma mb im bi translated">闭包<em class="mw">记住了</em>作为num传递的值，我们在控制台中得到20。相当酷。对于adder2和520打印到控制台，同样的过程再次发生。</p><p id="4101" class="pw-post-body-paragraph le lf it lg b lh mr lj lk ll ms ln lo lp mt lr ls lt mu lv lw lx mv lz ma mb im bi translated">通过调用makeAdder()，我们已经有效地创建了一个私有变量<em class="mw"> num </em>。我们不能改变num中的值，但我们知道它在那里，因为我们的加法是正确的。我们可以用这些知识来模拟一个私有变量。</p><h1 id="34f6" class="kg kh it bd ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld bi translated">解决方案:创建我们的私有变量</h1><p id="fa83" class="pw-post-body-paragraph le lf it lg b lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">现在我们知道了什么是闭包以及它是如何工作的，让我们将它付诸实践。看一下这段代码:</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="e60c" class="ml kh it mh b gy mm mn l mo mp">let myTest = (function () { <br/>  let _name = ''; <br/>  getName = function () { <br/>    return _name; <br/>  } <br/>  setName = function (newName) { <br/>    newName === 'bob' ? <br/>      _name = 'robert' : <br/>      _name = newName; <br/>  } <br/>  return { <br/>    getName: getName, <br/>    setName: setName <br/>  } <br/>}()); //this function is invoked as soon as the page loads</span></pre><p id="0cd8" class="pw-post-body-paragraph le lf it lg b lh mr lj lk ll ms ln lo lp mt lr ls lt mu lv lw lx mv lz ma mb im bi translated">我们这里用的叫做<a class="ae kf" href="https://addyosmani.com/resources/essentialjsdesignpatterns/book/#revealingmodulepatternjavascript" rel="noopener ugc nofollow" target="_blank"> <em class="mw">揭示模块模式</em> </a>。它是流行的<a class="ae kf" href="https://addyosmani.com/resources/essentialjsdesignpatterns/book/#modulepatternjavascript" rel="noopener ugc nofollow" target="_blank"> <em class="mw">模块模式</em> </a>的略微修改版。</p><p id="0350" class="pw-post-body-paragraph le lf it lg b lh mr lj lk ll ms ln lo lp mt lr ls lt mu lv lw lx mv lz ma mb im bi translated">让我们分析一下发生了什么。</p><p id="1026" class="pw-post-body-paragraph le lf it lg b lh mr lj lk ll ms ln lo lp mt lr ls lt mu lv lw lx mv lz ma mb im bi translated">首先，我们定义我们希望我们的模块被称为什么。在这种情况下，我们称之为myTest。我们将myTest设置为等于立即调用的函数表达式或IIFE(读作if-e)的结果。在函数定义中，我们有private _name变量、getName函数和setName函数。最后，我们返回一个对象文字，它本质上包含指向我们函数的指针。</p><p id="22bc" class="pw-post-body-paragraph le lf it lg b lh mr lj lk ll ms ln lo lp mt lr ls lt mu lv lw lx mv lz ma mb im bi translated">您可能会问“我怎么知道_name是私有的？”我们知道它是私人的，因为它藏在我们用生命创造的封闭空间里。</p><p id="7eee" class="pw-post-body-paragraph le lf it lg b lh mr lj lk ll ms ln lo lp mt lr ls lt mu lv lw lx mv lz ma mb im bi translated">返回的对象文字本质上是面向公众的API。无论你在这里返回什么，都是外部可访问的。因为我们没有公开_name变量，所以我们可以确信它是私有的。让我们来测试一下！</p><pre class="mc md me mf gt mg mh mi mj aw mk bi"><span id="73d9" class="ml kh it mh b gy mm mn l mo mp">myTest.setName('alex'); <br/>console.log(myTest.getName());</span><span id="ccb3" class="ml kh it mh b gy mq mn l mo mp">console.log(myTest._name);</span><span id="b197" class="ml kh it mh b gy mq mn l mo mp">myTest.setName('bob'); <br/>console.log(myTest.getName());</span></pre><p id="c711" class="pw-post-body-paragraph le lf it lg b lh mr lj lk ll ms ln lo lp mt lr ls lt mu lv lw lx mv lz ma mb im bi translated">紧接着上面的代码，我们在myTest上调用setName。以下是我们在控制台中得到的结果:</p><figure class="mc md me mf gt ju gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/15dc3f9a738dd2d3ba1b34c5a906869e.png" data-original-src="https://miro.medium.com/v2/resize:fit:430/format:webp/0*18gp3NLkEEDEg0h-.png"/></div></figure><p id="4a50" class="pw-post-body-paragraph le lf it lg b lh mr lj lk ll ms ln lo lp mt lr ls lt mu lv lw lx mv lz ma mb im bi translated">您可以在输出中看到，我们成功地将名称设置为alex并检索了它。</p><p id="f93b" class="pw-post-body-paragraph le lf it lg b lh mr lj lk ll ms ln lo lp mt lr ls lt mu lv lw lx mv lz ma mb im bi translated">然后我们试图直接访问_name变量，结果没有定义。我们的私有变量起作用了！！</p><p id="fb36" class="pw-post-body-paragraph le lf it lg b lh mr lj lk ll ms ln lo lp mt lr ls lt mu lv lw lx mv lz ma mb im bi translated">然后，我们再次将名称设置为bob。在我们的setName函数中，我们检查该值，如果传递的值是bob，则将其更新为robert。如果您希望setter中有某种类型的值，您可以想象这样进行检查。</p><p id="f9f4" class="pw-post-body-paragraph le lf it lg b lh mr lj lk ll ms ln lo lp mt lr ls lt mu lv lw lx mv lz ma mb im bi translated">我们已经成功地使用closure模拟了一个私有变量。此外，我们引入全局空间的唯一变量是myTest。使用这种方法很容易避免全局空间中的命名冲突。</p><p id="9f3a" class="pw-post-body-paragraph le lf it lg b lh mr lj lk ll ms ln lo lp mt lr ls lt mu lv lw lx mv lz ma mb im bi translated">要阅读更多关于闭包、JavaScript模式和其他优秀JS的内容，请查看以下链接:</p><p id="21d0" class="pw-post-body-paragraph le lf it lg b lh mr lj lk ll ms ln lo lp mt lr ls lt mu lv lw lx mv lz ma mb im bi translated"><a class="ae kf" href="http://www.adequatelygood.com/JavaScript-Module-Pattern-In-Depth.html" rel="noopener ugc nofollow" target="_blank">足够好</a> —自由</p><p id="4d17" class="pw-post-body-paragraph le lf it lg b lh mr lj lk ll ms ln lo lp mt lr ls lt mu lv lw lx mv lz ma mb im bi translated"><a class="ae kf" href="https://addyosmani.com/resources/essentialjsdesignpatterns/book/" rel="noopener ugc nofollow" target="_blank">艾迪·奥斯马尼的伟大著作</a>-免费</p><p id="8827" class="pw-post-body-paragraph le lf it lg b lh mr lj lk ll ms ln lo lp mt lr ls lt mu lv lw lx mv lz ma mb im bi translated"><a class="ae kf" href="https://www.manning.com/books/functional-programming-in-javascript" rel="noopener ugc nofollow" target="_blank">JavaScript中的函数式编程</a> —付费</p><p id="49dc" class="pw-post-body-paragraph le lf it lg b lh mr lj lk ll ms ln lo lp mt lr ls lt mu lv lw lx mv lz ma mb im bi translated"><a class="ae kf" href="https://www.manning.com/books/secrets-of-the-javascript-ninja-second-edition" rel="noopener ugc nofollow" target="_blank">JavaScript忍者的秘密</a> —付费</p><p id="da1d" class="pw-post-body-paragraph le lf it lg b lh mr lj lk ll ms ln lo lp mt lr ls lt mu lv lw lx mv lz ma mb im bi translated">不久前，我还在youtube上做了一个视频，介绍了揭示性的模块模式。<a class="ae kf" href="https://youtu.be/1U9e5Eg_rfs" rel="noopener ugc nofollow" target="_blank">如果你感兴趣，请点击这里查看</a></p><p id="db3e" class="pw-post-body-paragraph le lf it lg b lh mr lj lk ll ms ln lo lp mt lr ls lt mu lv lw lx mv lz ma mb im bi translated">感谢阅读！</p></div><div class="ab cl nu nv hx nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="im in io ip iq"><p id="8bdc" class="pw-post-body-paragraph le lf it lg b lh mr lj lk ll ms ln lo lp mt lr ls lt mu lv lw lx mv lz ma mb im bi translated"><em class="mw">原载于</em><a class="ae kf" href="http://ritzcovan.com/index.php/2019/12/19/using-closure-in-javascript-to-create-private-variables/" rel="noopener ugc nofollow" target="_blank"><em class="mw">http://ritzcovan.com</em></a><em class="mw">。</em></p></div></div>    
</body>
</html>