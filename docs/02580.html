<html>
<head>
<title>Writing a Reusable Custom React Hook</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编写一个可重用的自定义React钩子</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/writing-a-reusable-custom-react-hook-edc58986775b?source=collection_archive---------12-----------------------#2020-03-23">https://levelup.gitconnected.com/writing-a-reusable-custom-react-hook-edc58986775b?source=collection_archive---------12-----------------------#2020-03-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="e172" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">重构系列的第3部分使用钩子。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/8f5ba2a88c798d427892b29720cc35ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bLFl6h80O4PQSsr8254SgQ.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">让我们开始吧！</figcaption></figure><p id="213e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">欢迎来到我的重构之旅的第3部分！<a class="ae le" href="https://medium.com/@damongself/managing-state-in-a-react-application-9a490bd44319" rel="noopener">上次</a>我看了一些关于状态管理的概念，以及状态应该存储在哪些组件中。这次我将编写一个可重用的fetch请求钩子，这样我就可以删除许多手工编写的fetch请求。</p><p id="fb3f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">首先，为了便于组织，我想将我的定制钩子存储在它们自己的目录中。这应该可以让我的组件和钩子保持分离，让任何看我源代码的人都容易识别。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi lf"><img src="../Images/60c121a7612df00f65650fcc83f72fc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:422/format:webp/1*D42PTMprMwSvB92S1gASZQ.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">我将hooks目录保存在我的src中</figcaption></figure><p id="790e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我有地方存放我的定制钩子了，我可以开始写我自己的了！在hooks目录中，我将创建一个名为<code class="fe lg lh li lj b">http.js</code>的文件，因为主要目的是发送http请求。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi lk"><img src="../Images/9f58831488f96789cd9bd04bc3dfdd98.png" data-original-src="https://miro.medium.com/v2/resize:fit:696/format:webp/1*xhjabZ6nTmyRsaKGusw4EA.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">我现在有一个自定义挂钩！</figcaption></figure><p id="6e08" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">关于上面我写的代码，需要注意的是我要导出的函数的名称。与所有其他挂钩一样，它以“使用”开头，后面跟着一个词来表达它的目的。这是一个React钩子惯例，你不需要使用，但绝对应该使用。在开头用“use”命名钩子向其他React开发者传达了你所写的是一个定制钩子。此外，它允许es-lint React hook插件检测您何时违反了钩子规则。如果钩子不是以“use”开头，它就不会被检测为钩子。</p><p id="e7ab" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为我正在编写一个可重用的http请求钩子，所以我需要访问被获取的url。因此，每当我调用我的<code class="fe lg lh li lj b">useHttp</code>钩子时，我都会期待一个<code class="fe lg lh li lj b">url</code>的参数。有了一个<code class="fe lg lh li lj b">url</code>参数，我可以像这样把它传递给我的获取请求:</p><pre class="kp kq kr ks gt lm lj ln lo aw lp bi"><span id="10be" class="lq lr it lj b gy ls lt l lu lv">fetch(url)<br/>  .then(do something)</span></pre><p id="28d4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为我所有的获取请求都期望得到某种被解析为json的响应，所以我可以像这样写出完整的获取请求:</p><pre class="kp kq kr ks gt lm lj ln lo aw lp bi"><span id="fe51" class="lq lr it lj b gy ls lt l lu lv">fetch(url)<br/>  .then(response =&gt; response.json())<br/>  .then(data =&gt; do something)</span></pre><p id="b3f7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正如你在上面看到的，我还没有写任何关于我们从获取请求中收到的数据的东西。目前，我只是用这段代码发送GET请求，但额外的可重用性将在以后出现。我目前面临的一个问题是如何处理我收到的数据。我手动写出的fetch请求使用了某些方法来更新数据的状态，但是，由于我使用了可重用的钩子，如果不将它们作为道具接收，我就无法访问这些方法。以下是我的解决方案:</p><p id="8d31" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我的钩子内部，我可以利用一个<code class="fe lg lh li lj b">useState</code>钩子来存储和返回我获取的任何数据。看一看:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi lw"><img src="../Images/b418126412466506e6bd9be863f59463.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/format:webp/1*9_kzZaz8-mXq-xp8RKIVpA.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">将我获取的任何数据返回给调用它的顶层函数</figcaption></figure><p id="8c8a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">酷！我有一个钩子，它接收一个url，并使用该URL发送一个可定制的获取请求，将接收到的任何数据作为响应存储在state中，然后返回该状态的值。然而，我还有更多工作要做，我将从我最直接的问题开始:我们大多数手工编写的获取请求都在<code class="fe lg lh li lj b">useEffect</code>钩子内。为什么这是一个问题？嗯，钩子，包括你自己定制的钩子，不能比最顶层的函数调用的更低。这是什么意思？这意味着我不能这么做。</p><pre class="kp kq kr ks gt lm lj ln lo aw lp bi"><span id="cf71" class="lq lr it lj b gy ls lt l lu lv">const someFunction = () =&gt; {<br/>  useEffect(() =&gt; {<br/>    useHttp(url)<br/>  }, [dependency]);</span><span id="6972" class="lq lr it lj b gy lx lt l lu lv">  // OR THIS</span><span id="bcb4" class="lq lr it lj b gy lx lt l lu lv">  if(some conditional) {<br/>    useHttp(url)<br/>  };<br/>};</span></pre><p id="5692" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">所以，我写了一个自定义的<code class="fe lg lh li lj b">useHttp</code>钩子，但是不能使用它，因为它现在已经实现了。幸运的是，我已经证明了我可以在我的自定义钩子中使用其他钩子！我正是要这样做来解决我们的<code class="fe lg lh li lj b">useEffect</code>问题。</p><p id="20df" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了在我的定制钩子中使用<code class="fe lg lh li lj b">useEffect</code>钩子，我需要像过去一样导入并调用它。然而，新的东西是我如何接受依赖。谢天谢地，我的解决方案很简单。与我将url作为参数传递给我们的<code class="fe lg lh li lj b">useHttp</code>钩子一样，我也可以传递任何我想要监控的依赖项。添加新内容后，代码现在看起来像这样:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ly"><img src="../Images/4a7949a6109907b2119463f378f872a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1124/format:webp/1*UQ7FtiBHAayf_qxP8r6d3Q.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">黄色警告表示它无法静态检查“dependencies”是否为数组。通过将它放在数组括号中来解决这个问题！</figcaption></figure><p id="3b23" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我想实现这个新的获取挂钩的第一个地方是在我的应用程序组件中，在那里我为我的应用程序获取所有的卡。因为我将实际的数据作为一个数组从钩子中返回，所以我可以用一个简单的<code class="fe lg lh li lj b">setAllCards(fetchedData)</code>代替fetch，使用数组析构，如下所示:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi lz"><img src="../Images/f1abe3b474b163a44a4004aa49f2b9a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BzLOlZBfmCiTePueAijgzA.png"/></div></div></figure><p id="8682" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">希望你在这里看到一些冗余。我基本上做的是进行一个fetch调用，并将数据存储在钩子内部的一个状态中，然后返回该数据，并通过数组析构来访问它。然后，我使用卡数据的数组，并将其设置为我的allCards状态的值。现在，我有两种访问相同数据的方式…似乎我打破了一些枯燥的规则。相反，我可以摆脱<code class="fe lg lh li lj b">allCards</code>状态，通过我们的析构<code class="fe lg lh li lj b">fetchedData</code>来访问所有的卡。尤其是因为我永远不会改变这些数据。删除该状态后，我们的代码如下所示:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ma"><img src="../Images/86b173f669163dc0d64eba78692555ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6BU0jAXdKSbsUGZa8sq_1A.png"/></div></div></figure><p id="1402" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">关于我以前实现定制钩子的方式，值得一提的是我的钩子触发了两次。分配移动窗口事件监听器的<code class="fe lg lh li lj b">useEffect</code>和<code class="fe lg lh li lj b">setAllCards(fetchedData)</code>都依赖于<code class="fe lg lh li lj b">fetchedData</code>,因为我需要<code class="fe lg lh li lj b">setAllCards</code>方法在数据加载后触发，但它是用初始空数组触发的。所以一旦<code class="fe lg lh li lj b">fetchedData</code>被真正加载，就需要再次调用它。因此，它将加载组件，将获取的数据设置为空数组，检查并查看<code class="fe lg lh li lj b">fetchedData</code>变量是否已更改，重新呈现组件，并再次调用钩子。之后它没有继续发射的唯一原因是因为存储的数据相当于当前状态。</p><p id="40f6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">老实说，在文章的前面，我提到了为多种类型的获取请求添加功能，但是我一直在努力做到这一点，我想我知道为什么。当然，在进入hooks时，我希望有一种方法来编写带有状态的功能组件。然而，到目前为止，我已经把钩子解释为只是被导入的普通函数。不幸的是，这不完全正确。为了编写一个动态运行的获取钩子，至少从我的尝试来看，我必须能够从条件函数或嵌套函数中调用我的钩子；这是不允许你做的。因为钩子是在组件渲染之后运行的，而不是在你想要有条件地调用它们的时候，所以当你点击一个按钮或者只有当某个条件被满足时，它们才被触发。我的意思是，你可以在你的钩子内部指定条件，但是越是针对我的应用程序，它的可重用性就越低。</p><p id="e862" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这可能只是我作为开发人员的经验不足，让我看不到更合适的解决方案和结论，但就目前情况而言，我只会实现我迄今为止编写的代码。所以，实际上，我的目标失败了，因为我最终只用一个钩子替换了一个fetch请求。但是我学到了很多关于React钩子如何工作和不工作的知识！此外，我学会了如何编写自己的钩子，现在，对于我的下一个特性或项目，我将记住我在尝试以这种方式使用钩子时学到的经验。</p><p id="f6f6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我想我的下一篇文章将会更侧重于为这个应用程序创造更好的用户体验。我在本系列中省略了我实际应用程序的图片，因为它对用户几乎没有任何帮助，看起来也不怎么样。所以，下一次，我将看看我为用户做的有多少，为什么那是不好的，以及我如何能修复它。感谢阅读！</p></div></div>    
</body>
</html>