<html>
<head>
<title>Implementing Fluent Validation in ASP .NET</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在ASP中实现流畅验证。网</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/implementing-fluent-validation-in-asp-net-c40369192f65?source=collection_archive---------1-----------------------#2022-02-21">https://levelup.gitconnected.com/implementing-fluent-validation-in-asp-net-c40369192f65?source=collection_archive---------1-----------------------#2022-02-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3e02" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">深入了解这个强大的工具，您应该将它用于您的。网络应用</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/4ad7df701fd7c0f092725172e7270b55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SwV9XjTVZwtx3d5gEe_3eg.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">Daria Nepriakhina 在<a class="ae ky" href="https://unsplash.com/photos/zoCDWPuiRuA" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><p id="0241" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">验证数据是开发软件时需要考虑的一个重要方面。然而，问题是验证会导致大量多余的代码，或者在整个应用程序中有相似的验证代码，这违反了DRY原则。</p><p id="259a" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">如果你不知道什么是干，我建议你看看下面的文章。</p><div class="mc md gp gr me mf"><a href="https://medium.com/codex/become-a-better-programmer-with-these-software-engineering-principles-204fa93e8094" rel="noopener follow" target="_blank"><div class="mg ab fo"><div class="mh ab mi cl cj mj"><h2 class="bd iu gy z fp mk fr fs ml fu fw is bi translated">用这些软件工程原则成为更好的程序员</h2><div class="mm l"><h3 class="bd b gy z fp mk fr fs ml fu fw dk translated">干，吻，YAGNI解释道</h3></div><div class="mn l"><p class="bd b dl z fp mk fr fs ml fu fw dk translated">medium.com</p></div></div><div class="mo l"><div class="mp l mq mr ms mo mt ks mf"/></div></div></a></div><p id="5293" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">在这篇文章中，我将实现<em class="mu"> FluentValidation，</em>这是一个免费的强大工具，它将帮助你轻松地创建验证，并且易于维护和阅读。说到这里，让我们开始吧。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h2 id="a104" class="mv mw it bd mx my mz dn na nb nc dp nd lp ne nf ng lt nh ni nj lx nk nl nm nn bi translated">装置</h2><p id="18a5" class="pw-post-body-paragraph lg lh it li b lj no ju ll lm np jx lo lp nq lr ls lt nr lv lw lx ns lz ma mb im bi translated">您可以在Visual Studio或您正在使用的IDE中直接找到该包，或者导航到IDE的文件夹并运行以下命令:</p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="54c3" class="mv mw it nu b gy ny nz l oa ob">Install-Package FluentValidation</span></pre><p id="cf45" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">或者使用。NET CLI</p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="4532" class="mv mw it nu b gy ny nz l oa ob">dotnet add package FluentValidation</span></pre></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h2 id="3d7b" class="mv mw it bd mx my mz dn na nb nc dp nd lp ne nf ng lt nh ni nj lx nk nl nm nn bi translated">它是如何工作的</h2><p id="9e6c" class="pw-post-body-paragraph lg lh it li b lj no ju ll lm np jx lo lp nq lr ls lt nr lv lw lx ns lz ma mb im bi translated">关于<em class="mu"> FluentValidation </em>最好的事情之一是它友好的语法，因为它使得编写验证器如此直观。</p><p id="7c8a" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">首先，我们需要一个我们想要验证的类，所以假设我们想要添加一个客户。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="d20a" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">为了使用<em class="mu"> FluentValidation </em>进行验证，我们可以编写以下代码:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="9705" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">这确实是基本的，但它突出了工具的直观性，显然，这些是通用值，但您可以将它们匹配起来以满足您的数据库字段的特征。</p><p id="40b1" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">我们会更深入一点，但在此之前，让我先向您展示如何向服务集合注册<em class="mu"> FluentValidation </em>，以便它实际工作。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h2 id="69f6" class="mv mw it bd mx my mz dn na nb nc dp nd lp ne nf ng lt nh ni nj lx nk nl nm nn bi translated">使用服务集合进行注册流验证</h2><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="12a1" class="mv mw it nu b gy ny nz l oa ob"><strong class="nu iu">public</strong> <strong class="nu iu">void</strong> ConfigureServices(IServiceCollection services) <br/>{<br/>    services.AddMvc(setup =&gt; <br/>    {<br/>      <em class="mu">//...mvc setup...</em><br/>    }).AddFluentValidation();<br/><br/>    services.AddTransient&lt;IValidator&lt;Person&gt;, PersonValidator&gt;();<br/>    <em class="mu">//etc</em><br/>}</span></pre><p id="987e" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">这是第一种方法，但是每次创建验证器时都需要添加一个新的验证器，这有点烦人，所以有一种更好的方法。</p><pre class="kj kk kl km gt nt nu nv nw aw nx bi"><span id="1bb5" class="mv mw it nu b gy ny nz l oa ob">.AddFluentValidation(fv =&gt;</span><span id="0925" class="mv mw it nu b gy oe nz l oa ob">{</span><span id="55bc" class="mv mw it nu b gy oe nz l oa ob">fv.RegisterValidatorsFromAssembly(Assembly.GetEntryAssembly());</span><span id="f439" class="mv mw it nu b gy oe nz l oa ob">fv.RegisterValidatorsFromAssembly(Assembly.GetExecutingAssembly());</span><span id="624d" class="mv mw it nu b gy oe nz l oa ob">fv.ImplicitlyValidateChildProperties = true;</span><span id="bee6" class="mv mw it nu b gy oe nz l oa ob">});</span></pre><p id="ba9b" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">这将自动注册从AbstractValidator派生的所有验证器。而<em class="mu">ImplicitlyValidateChildProperties</em>所做的是强制验证尝试自动为每个属性寻找验证器。这基本上意味着，如果所有属性都无效，请求就不会触及控制器。</p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h2 id="046f" class="mv mw it bd mx my mz dn na nb nc dp nd lp ne nf ng lt nh ni nj lx nk nl nm nn bi translated">在域中使用验证器</h2><p id="1b3b" class="pw-post-body-paragraph lg lh it li b lj no ju ll lm np jx lo lp nq lr ls lt nr lv lw lx ns lz ma mb im bi translated">使用验证器的一种方式是在控制器中，假设我们已经在启动时启用了<em class="mu">ImplicitlyValidateChildProperties</em>来停止所有无效的请求。然而，在我看来，控制器中的验证器应该更基本一些，就像我们在“它是如何工作的”副标题中看到的那样。</p><p id="92a7" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">在那里进行简单的验证会很快向我们的前端返回一个错误，这样用户就可以编辑他的字段并重新提交。然而，如果我们在点击控制器之前就使用复杂的验证，那么对于一些可能无效的东西，会导致性能下降。</p><p id="9a76" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">所以这就是为什么我们可以在我们的域逻辑中有第二个验证器来为我们做繁重的工作，这里的语法有点不同于仅仅写一个验证器类。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="58e5" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">在您的域中实现验证器应该是这样的，如果验证确实失败了，就返回错误。</p><p id="4694" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">现在，正如我所说的，我们可以将验证扩展得更复杂一些。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="ba80" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">我已经删除了验证的其余部分，这样看起来更整洁一些。我们在这里做的是将<em class="mu"> CustomerDomain </em>传递给我们的验证器，然后调用域中的方法来检查电子邮件是否在使用中以及邮政编码是否有效。</p><p id="ca42" class="pw-post-body-paragraph lg lh it li b lj lk ju ll lm ln jx lo lp lq lr ls lt lu lv lw lx ly lz ma mb im bi translated">你可以在文档 中找到一些方便的内置验证器<em class="mu">t</em><a class="ae ky" href="https://docs.fluentvalidation.net/en/latest/built-in-validators.html" rel="noopener ugc nofollow" target="_blank">T5】，我不得不说他们的文档非常好。</a></p></div><div class="ab cl kz la hx lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="im in io ip iq"><h2 id="2824" class="mv mw it bd mx my mz dn na nb nc dp nd lp ne nf ng lt nh ni nj lx nk nl nm nn bi translated">结论</h2><p id="4cc5" class="pw-post-body-paragraph lg lh it li b lj no ju ll lm np jx lo lp nq lr ls lt nr lv lw lx ns lz ma mb im bi translated">这就是<em class="mu"> FluentValidation、</em>的基础，不需要太深入地探讨这个话题，也不需要浪费你的时间。我想你会发现它真的很容易使用，而且非常直观，因为你可以用简单的英语阅读大多数验证，所以我建议你尝试一下，因为它需要验证你的数据到一个不同的水平，如果你付出更多的努力，你可以把前端的验证降到最低。</p></div></div>    
</body>
</html>