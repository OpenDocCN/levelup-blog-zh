<html>
<head>
<title>Type Inference in TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">类型脚本中的类型推理</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/yes-typescript-can-do-that-975dcc4ef72a?source=collection_archive---------13-----------------------#2020-06-07">https://levelup.gitconnected.com/yes-typescript-can-do-that-975dcc4ef72a?source=collection_archive---------13-----------------------#2020-06-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/d33f33b05a2c5c6b17265707d673109a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OWN2t_3sqN4Wz48BGz6uaw.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">T.L.D.R。)</figcaption></figure><p id="e459" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这篇文章是关于为一个查询对象写一个类型定义，这个查询对象在客户端从API获取数据。然而，在我开始之前，我想提一下这是高级的typescript概念，所以如果您是新手，您可能会觉得有点难以理解。</p><p id="eb16" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我不会谈论后端，但如果你一定要知道，这个查询对象将被转换为一个<code class="fe ld le lf lg b"><a class="ae lh" href="https://www.prisma.io" rel="noopener ugc nofollow" target="_blank">PrismaClient</a>.findMany</code>参数。有广泛的验证和逻辑检查，以确保安全和访问管理。</p><h1 id="a7bb" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">问题是</h1><p id="406c" class="pw-post-body-paragraph kf kg it kh b ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky mk la lb lc im bi translated">为了解释我将在这里使用的概念，我将使用两个简单的<code class="fe ld le lf lg b">User</code>和<code class="fe ld le lf lg b">Game</code>模型，它们有多对多的关系。不用说，这也可以用于任何其他关系。</p><figure class="ml mm mn mo gt ju"><div class="bz fp l di"><div class="mp mq l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">模型及其关系</figcaption></figure><p id="8619" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">假设我们要创建一个查询来获取所有游戏的列表，包括用户。大概是这样的:</p><pre class="ml mm mn mo gt mr lg ms mt aw mu bi"><span id="c457" class="mv lj it lg b gy mw mx l my mz">const query: Query = { ... };<br/>const games = await api.findMany(query);</span></pre><p id="14dd" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们的查询对象应该是这样的:</p><figure class="ml mm mn mo gt ju"><div class="bz fp l di"><div class="mp mq l"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">查询定义</figcaption></figure><p id="20c9" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这个定义不会给我们太多的代码完成，但是，它肯定比什么都没有好。让我们试着让它更有用。</p><h1 id="ace7" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">改进1:使用<code class="fe ld le lf lg b">keyof</code></h1><p id="1402" class="pw-post-body-paragraph kf kg it kh b ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky mk la lb lc im bi translated">如果我们将模型接口作为通用类型传递给我们的查询定义，我们可以使用<code class="fe ld le lf lg b">keyof</code>操作符来提取该模型的属性，并将它们用于<code class="fe ld le lf lg b">fields</code>、<code class="fe ld le lf lg b">includes</code>、<code class="fe ld le lf lg b">orderBy</code>:</p><figure class="ml mm mn mo gt ju"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="11bf" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">现在我们得到了更好的代码完成。而且如果你输入不正确的字段名，<code class="fe ld le lf lg b">tsc</code>会警告你:</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi na"><img src="../Images/2664bd01343b2f1ba55438d9832b1a8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VTwBtWzi2i-fFPKCEVZwlw.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">字段名的代码完成</figcaption></figure><h1 id="35b9" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">改进2:类型推断</h1><p id="afd4" class="pw-post-body-paragraph kf kg it kh b ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky mk la lb lc im bi translated"><code class="fe ld le lf lg b">include</code>属性只能用关系类型的字段名填充。并且<code class="fe ld le lf lg b">fields</code>属性应该只填充模型自己的字段。在本例中，<code class="fe ld le lf lg b">id</code>、<code class="fe ld le lf lg b">name</code>和<code class="fe ld le lf lg b">rate</code>是自己的字段，而<code class="fe ld le lf lg b">users</code>是关系。Own字段是主要类型，所以我们可以使用它。</p><figure class="ml mm mn mo gt ju"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="7b6a" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">为了解释<code class="fe ld le lf lg b">OwnFields</code>，我们来追溯一下代码。<code class="fe ld le lf lg b">Game</code>模型第5行的结果将是<code class="fe ld le lf lg b">{id: "id", name: "name", rate: "rate", users: never}</code>。当我们添加第6行时，这将产生字段的名称:<code class="fe ld le lf lg b">"id" | "name" | "rate"</code>。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi na"><img src="../Images/7ed3cb543735e71500a69e74b785fa2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PoDaPQFcluAs6I2q-qM6NQ.png"/></div></div></figure><p id="2675" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">对于关系来说，只是另一种方式。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi na"><img src="../Images/8d404137156eea65e1e105846465b092.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CcC_uQts2HH2jfTBqg0-9A.png"/></div></div></figure><h1 id="4c32" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">改进3:下兔子洞</h1><p id="bbef" class="pw-post-body-paragraph kf kg it kh b ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky mk la lb lc im bi translated">如果我们希望能够选择关系的领域呢？甚至是亲戚关系？</p><p id="db23" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们可以从关系的类型推断开始。但是当关系是多对多时，属性的类型将是关系模型的数组(<code class="fe ld le lf lg b">games: IGame[]</code>)。我们需要一种从数组推断类型的方法。我们可以通过以下方式实现这一目标:</p><pre class="ml mm mn mo gt mr lg ms mt aw mu bi"><span id="86d0" class="mv lj it lg b gy mw mx l my mz">type ExtractType&lt;T, K extends keyof T&gt; = T[K] extends any[]: T[K][number]: T[K];</span><span id="93e1" class="mv lj it lg b gy nb mx l my mz">// and from TypeScript v2.8:<br/>type ExtractType&lt;T, K extends keyof T&gt; = T[K] extends (infer R)[]: R: T[K];</span></pre><p id="a2de" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">上面的代码将从关系中提取数据类型。下一个问题来了。对于关系字段，类型为<code class="fe ld le lf lg b">number[] | IUser[]</code>。为了让这个工作，我们需要从TypeScript: <code class="fe ld le lf lg b">Extract&lt;someTypes, number&gt;</code>中使用<code class="fe ld le lf lg b">Extract</code>地图类型来移除<code class="fe ld le lf lg b">number</code>:</p><figure class="ml mm mn mo gt ju"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="356a" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">对于代码完成:</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi na"><img src="../Images/d3674aa393f484cebd50030732301e60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wYiE73Wj8RYzUWpQN6jYXQ.png"/></div></div></figure><p id="34fa" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">如你所见，现在我们得到了嵌套关系的正确代码完成，不管兔子洞有多深。</p><h1 id="b699" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">过滤器部分来了</h1><p id="3f1c" class="pw-post-body-paragraph kf kg it kh b ki mg kk kl km mh ko kp kq mi ks kt ku mj kw kx ky mk la lb lc im bi translated">过滤基本上是对自己的字段进行的。对于基于其类型的每个字段，可以有以下操作符或它们的子集:</p><pre class="ml mm mn mo gt mr lg ms mt aw mu bi"><span id="d013" class="mv lj it lg b gy mw mx l my mz">equals, not, lt, lte, gt, gte, in, notIn<br/>contains, startsWith, endsWith</span></pre><p id="9565" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">和以前一样，我们可以使用类型推断来为字段分配适当的过滤操作。还有像<code class="fe ld le lf lg b">AND</code>、<code class="fe ld le lf lg b">OR</code>、<code class="fe ld le lf lg b">NOT</code>这样的连接器来创建更复杂的过滤。</p><p id="89d6" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们可以为自己的字段创建三个过滤类别:<code class="fe ld le lf lg b">BooleanFilter</code>、<code class="fe ld le lf lg b">NumberFilter</code>、<code class="fe ld le lf lg b">StringFilter</code>。现在，我们可以为每个字段创建以下类型:</p><pre class="ml mm mn mo gt mr lg ms mt aw mu bi"><span id="9d09" class="mv lj it lg b gy mw mx l my mz">type FieldFilter&lt;T&gt; = {<br/>  [key in keyof OwnFields&lt;T&gt;]?: Type&lt;T, key&gt; extends boolean<br/>    ? BooleanFilter<br/>    : Type&lt;T, key&gt; extends string<br/>      ? StringFilter<br/>      : NumberFilter;<br/>};</span></pre><p id="111a" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">对于关系，当关系类型是多对多时，我们也可以给<code class="fe ld le lf lg b">SimpleQuery</code>对象添加过滤属性。这看起来很难，但是相信我，这只是另一种类型的推理。</p><p id="421f" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">现在我们只需创建另一种类型来使用连接器操作符连接<code class="fe ld le lf lg b">FieldFilter</code>:</p><figure class="ml mm mn mo gt ju"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="7533" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">厉害！现在看看代码完成情况:</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi na"><img src="../Images/9e31563732543c0a7e369134ee9e6adc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dmAg2IfbpEYCTM9XNb87Yg.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">字段和连接器的一级代码完成</figcaption></figure><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi na"><img src="../Images/4fe5231f9e614421224dce515ee64a3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7cgBs_04sDHb99duKBdKbQ.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">字符串字段的嵌套代码完成</figcaption></figure><p id="aa7c" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">有了这些定义，我们就获得了最终的IDE支持。该查询对象几乎可以覆盖<code class="fe ld le lf lg b">PrismaClien.findMany</code>中所有类型的参数类型。</p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><p id="2eef" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我没有过滤多对多关系。这可能是一个不错的挑战。如果你喜欢，写下你的答案作为评论！</p><p id="0957" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><em class="nj">如果我做错了什么，或者有更好的方法，请</em><strong class="kh iu"><em class="nj"/></strong><em class="nj">告诉我！</em></p></div><div class="ab cl nc nd hx ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="im in io ip iq"><div class="ml mm mn mo gt nk"><a href="https://skilled.dev" rel="noopener  ugc nofollow" target="_blank"><div class="nl ab fo"><div class="nm ab nn cl cj no"><h2 class="bd iu gy z fp np fr fs nq fu fw is bi translated">编写面试问题</h2><div class="nr l"><h3 class="bd b gy z fp np fr fs nq fu fw dk translated">掌握编码面试的过程</h3></div><div class="ns l"><p class="bd b dl z fp np fr fs nq fu fw dk translated">技术开发</p></div></div><div class="nt l"><div class="nu l nv nw nx nt ny jz nk"/></div></div></a></div></div></div>    
</body>
</html>