<html>
<head>
<title>Messing with JavaScript This with Call, Bind, and Apply</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用调用、绑定和应用搞乱JavaScript</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/messing-with-javascript-this-with-call-bind-and-apply-52f37bc1729e?source=collection_archive---------4-----------------------#2020-01-02">https://levelup.gitconnected.com/messing-with-javascript-this-with-call-bind-and-apply-52f37bc1729e?source=collection_archive---------4-----------------------#2020-01-02</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/362908c5b662724b9e63b5b457e795c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6_CDKk5kPegn6qqe"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">由<a class="ae kf" href="https://unsplash.com/@kellysikkema?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">凯利·西克玛</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="bde0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在JavaScript中，<code class="fe le lf lg lh b">this</code>对象在不同的上下文中有不同的含义。这主要取决于<code class="fe le lf lg lh b">this</code>关键字所在的位置。如果它在一个物体中，那么<code class="fe le lf lg lh b">this</code>就是这个物体。如果<code class="fe le lf lg lh b">this</code>在一个函数中，那么<code class="fe le lf lg lh b">this</code>就是这个函数。对于类，<code class="fe le lf lg lh b">this</code>将是类，因为它只是普通构造函数的语法糖。在JavaScript函数中，有一个<code class="fe le lf lg lh b">call</code>、<code class="fe le lf lg lh b">bind</code>和<code class="fe le lf lg lh b">apply</code>方法来改变函数中<code class="fe le lf lg lh b">this</code>的值。在本文中，我们将仔细研究它们，以及如何使用它们来更改<code class="fe le lf lg lh b">this</code>的值。这些方法仅适用于常规函数，不适用于箭头函数。</p><h1 id="5b23" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">呼叫</h1><p id="618f" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated"><code class="fe le lf lg lh b">call</code>方法让我们用给定的<code class="fe le lf lg lh b">this</code>对象调用一个函数，当我们调用这个函数时，我们把给定的对象和参数传递给函数。</p><p id="18da" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它需要多个参数。第一个参数是一个对象，我们希望将它设置为调用<code class="fe le lf lg lh b">call</code>方法的函数中<code class="fe le lf lg lh b">this</code>的值。这是一个可选参数。我们可以将其设置为一个对象，<code class="fe le lf lg lh b">null</code>或<code class="fe le lf lg lh b">undefined</code>。在非严格模式下，<code class="fe le lf lg lh b">null</code>和<code class="fe le lf lg lh b">undefined</code>将被替换为全局对象，原始值将被转换为对象。第二个和随后的参数是我们传递给函数的参数。</p><p id="a3af" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">call</code>方法的返回值是用指定的<code class="fe le lf lg lh b">this</code>值和参数调用的同一个函数。</p><p id="b615" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">call方法的目的是我们可以重用具有不同<code class="fe le lf lg lh b">this</code>值的同一个函数，而不用用我们想要的<code class="fe le lf lg lh b">this</code>值写一个新值。</p><p id="2b34" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以通过编写以下代码，用<code class="fe le lf lg lh b">call</code>方法更改函数中<code class="fe le lf lg lh b">this</code>的值:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="3c94" class="mt lj it lh b gy mu mv l mw mx">let obj = {<br/>  firstName: 'Joe',<br/>  lastName: 'Smith'<br/>}</span><span id="0d91" class="mt lj it lh b gy my mv l mw mx">let person  = {<br/>  firstName: 'Jane',<br/>  lastName: 'Smith',<br/>  getFullName()  {<br/>    return `${this.firstName} ${this.lastName}`<br/>  }<br/>}</span><span id="653b" class="mt lj it lh b gy my mv l mw mx">console.log(person.getFullName());<br/>console.log(person.getFullName.call(obj));</span></pre><p id="4f81" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，当我们调用<code class="fe le lf lg lh b">person.getFullName()</code>时，我们得到‘简·史密斯’,因为我们在<code class="fe le lf lg lh b">person</code>对象中将<code class="fe le lf lg lh b">firstName</code>设置为<code class="fe le lf lg lh b">'Jane'</code>,并且在同一个对象中将<code class="fe le lf lg lh b">lastName</code>设置为<code class="fe le lf lg lh b">'Smith'</code>。由于<code class="fe le lf lg lh b">this</code>是<code class="fe le lf lg lh b">getFullName</code>函数中的<code class="fe le lf lg lh b">person</code>对象，因此我们得到“简·史密斯”。</p><p id="8864" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们使用<code class="fe le lf lg lh b">call</code>方法通过调用<code class="fe le lf lg lh b">person.getFullName.call(obj))</code>将<code class="fe le lf lg lh b">getFullName</code>函数内的<code class="fe le lf lg lh b">this</code>对象更改为<code class="fe le lf lg lh b">obj</code>时，我们得到‘乔·史密斯’，因为我们将<code class="fe le lf lg lh b">this</code>更改为<code class="fe le lf lg lh b">obj</code>，而<code class="fe le lf lg lh b">obj</code>将<code class="fe le lf lg lh b">firstName</code>设置为<code class="fe le lf lg lh b">'Joe'</code>并将<code class="fe le lf lg lh b">lastName</code>设置为<code class="fe le lf lg lh b">‘Smith’</code>。</p><p id="3492" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们也可以对构造函数使用<code class="fe le lf lg lh b">call</code>方法。例如，如果我们有:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="9936" class="mt lj it lh b gy mu mv l mw mx">const Person = function(firstName, lastName) {<br/>  this.firstName = firstName;<br/>  this.lastName = lastName;<br/>}</span><span id="5bbc" class="mt lj it lh b gy my mv l mw mx">const Employee = function(firstName, lastName, employeeCode) {<br/>  this.employeeCode = employeeCode;<br/>  Person.call(this, firstName, lastName)<br/>}</span><span id="c1e1" class="mt lj it lh b gy my mv l mw mx">const employee = new Employee('Jane', 'Smith', '123');<br/>console.log(`${employee.firstName} ${employee.lastName}`, employee.employeeCode);</span></pre><p id="0b46" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后在<code class="fe le lf lg lh b">Employee</code>构造函数中，我们调用之前定义的<code class="fe le lf lg lh b">Person</code>构造函数。当我们创建一个新的<code class="fe le lf lg lh b">Employee</code>对象时，我们传入一个新的<code class="fe le lf lg lh b">firstName</code>和<code class="fe le lf lg lh b">lastName</code>，然后在<code class="fe le lf lg lh b">Employee</code>构造函数内部，我们使用<code class="fe le lf lg lh b">Person</code>函数的<code class="fe le lf lg lh b">call</code>方法将<code class="fe le lf lg lh b">firstName</code>和<code class="fe le lf lg lh b">lastName</code>传递给<code class="fe le lf lg lh b">Person</code>构造函数，从而设置<code class="fe le lf lg lh b">this</code>的<code class="fe le lf lg lh b">firstName</code>和<code class="fe le lf lg lh b">lastName</code>属性的值，而不用直接在<code class="fe le lf lg lh b">Employee</code>构造函数中设置它们。</p><p id="c06c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们在最后一行运行<code class="fe le lf lg lh b">console.log</code>时，我们得到<code class="fe le lf lg lh b">'Jane Smith'</code>和<code class="fe le lf lg lh b">'123'</code>。</p><p id="270c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">再比如我们可以把<code class="fe le lf lg lh b">call</code>和匿名函数一起使用。例如，我们可以编写以下函数来记录问候语:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="05a2" class="mt lj it lh b gy mu mv l mw mx">(function(greeting) {<br/>  console.log(`${greeting} ${this.firstName} ${this.lastName}`);<br/>}.call({<br/>  firstName: 'Joe',<br/>  lastName: 'Smith'<br/>}, 'Hello'));</span></pre><p id="4e8a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的函数调用中，我们将带有<code class="fe le lf lg lh b">firstName</code>和<code class="fe le lf lg lh b">lastName</code>属性的对象传递给匿名函数的<code class="fe le lf lg lh b">call</code>方法的第一个参数。然后我们在第二个实参中传入字符串<code class="fe le lf lg lh b">'Hello'</code>，它被传入匿名函数的第一个形参。这意味着<code class="fe le lf lg lh b">'Hello'</code>是<code class="fe le lf lg lh b">greeting</code>参数的值，<code class="fe le lf lg lh b">this.firstName</code>是<code class="fe le lf lg lh b">'Joe'</code>，<code class="fe le lf lg lh b">this.lastName</code>是<code class="fe le lf lg lh b">'Smith'</code>。</p><p id="4e7f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以，当我们运行上面的代码时，我们应该得到<code class="fe le lf lg lh b">'Hello Joe Smith’</code>。</p><h1 id="fd33" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">应用</h1><p id="7bb9" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated"><code class="fe le lf lg lh b">apply</code>方法与<code class="fe le lf lg lh b">call</code>方法几乎相同，除了我们为第二个参数传入一个数组作为函数调用的参数，而不是一个逗号分隔的对象列表。</p><p id="4dd3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这意味着我们可以通过做一些小的改动，用上面例子中的<code class="fe le lf lg lh b">apply</code>代替<code class="fe le lf lg lh b">call</code>。</p><p id="50a3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第一个例子是一样的，除了我们将<code class="fe le lf lg lh b">call</code>改为<code class="fe le lf lg lh b">apply</code>，因为我们没有传入第二个或后续的参数:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="c582" class="mt lj it lh b gy mu mv l mw mx">let obj = {<br/>  firstName: 'Joe',<br/>  lastName: 'Smith'<br/>}</span><span id="fcf3" class="mt lj it lh b gy my mv l mw mx">let person  = {<br/>  firstName: 'Jane',<br/>  lastName: 'Smith',<br/>  getFullName()  {<br/>    return `${this.firstName} ${this.lastName}`<br/>  }<br/>}</span><span id="e9df" class="mt lj it lh b gy my mv l mw mx">console.log(person.getFullName());<br/>console.log(person.getFullName.apply(obj));</span></pre><p id="1f7d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们用构造函数的<code class="fe le lf lg lh b">apply</code>方法链接构造函数，那么我们必须将<code class="fe le lf lg lh b">call</code>改为<code class="fe le lf lg lh b">apply</code>，并将参数列表改为数组。例如，如果我们有:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="f4c4" class="mt lj it lh b gy mu mv l mw mx">const Person = function(firstName, lastName) {<br/>  this.firstName = firstName;<br/>  this.lastName = lastName;<br/>}</span><span id="36e6" class="mt lj it lh b gy my mv l mw mx">const Employee = function(firstName, lastName, employeeCode) {<br/>  this.employeeCode = employeeCode;<br/>  Person.call(this, firstName, lastName)<br/>}</span><span id="9a15" class="mt lj it lh b gy my mv l mw mx">const employee = new Employee('Jane', 'Smith', '123');<br/>console.log(`${employee.firstName} ${employee.lastName}`, employee.employeeCode);</span></pre><p id="2d82" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">就像我们上面做的那样，然后我们只需要把它改成:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="f7fe" class="mt lj it lh b gy mu mv l mw mx">const Person = function(firstName, lastName) {<br/>  this.firstName = firstName;<br/>  this.lastName = lastName;<br/>}</span><span id="b095" class="mt lj it lh b gy my mv l mw mx">const Employee = function(firstName, lastName, employeeCode) {<br/>  this.employeeCode = employeeCode;<br/>  Person.apply(this, [firstName, lastName])<br/>}</span><span id="951a" class="mt lj it lh b gy my mv l mw mx">const employee = new Employee('Jane', 'Smith', '123');<br/>console.log(`${employee.firstName} ${employee.lastName}`, employee.employeeCode);</span></pre><p id="1dbc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们得到和上面一样的输出。</p><p id="1634" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，对于最后一个示例，我们可以将代码从:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="aa09" class="mt lj it lh b gy mu mv l mw mx">(function(greeting) {<br/>  console.log(`${greeting} ${this.firstName} ${this.lastName}`);<br/>}.call({<br/>  firstName: 'Joe',<br/>  lastName: 'Smith'<br/>}, 'Hello'));</span></pre><p id="e29e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">收件人:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="87ce" class="mt lj it lh b gy mu mv l mw mx">(function(greeting) {<br/>  console.log(`${greeting} ${this.firstName} ${this.lastName}`);<br/>}.apply({<br/>  firstName: 'Joe',<br/>  lastName: 'Smith'<br/>}, ['Hello']));</span></pre><p id="e95a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们得到和改变前一样的输出。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/90958f03984231b9f59c6efdc5e9a900.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2oz4VA-W2vxjuBM3"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">戴夫·威尔海特在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="d407" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">约束</h1><p id="4a18" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated"><code class="fe le lf lg lh b">bind</code>方法仅用于改变函数中<code class="fe le lf lg lh b">this</code>的值。像<code class="fe le lf lg lh b">call</code>和<code class="fe le lf lg lh b">apply</code>一样，它可以用来将参数发送到函数中。</p><p id="60d6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它需要多个参数。第一个参数是一个对象，我们希望将其设置为调用<code class="fe le lf lg lh b">bind</code>方法的函数中<code class="fe le lf lg lh b">this</code>的值。如果绑定函数是用<code class="fe le lf lg lh b">new</code>操作符构造的，这个参数将被忽略。当我们使用<code class="fe le lf lg lh b">bind</code>方法创建一个在<code class="fe le lf lg lh b">setTimeout</code>函数中作为回调提供的函数时，传递给第一个参数的任何原始值都被转换成一个对象。如果没有向<code class="fe le lf lg lh b">bind</code>提供参数，则执行范围的<code class="fe le lf lg lh b">this</code>值被视为新函数的值。</p><p id="a0da" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我们用<code class="fe le lf lg lh b">bind</code>调用函数时，第二个和随后的参数是要添加到参数列表中的参数。</p><p id="e31a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">bind</code>方法的返回值是用指定的<code class="fe le lf lg lh b">this</code>值和参数调用的同一个函数。</p><p id="1c4a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们像下面的代码那样不带参数地调用<code class="fe le lf lg lh b">bind</code>:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="e4b9" class="mt lj it lh b gy mu mv l mw mx">let person = {<br/>  firstName: 'Jane',<br/>  lastName: 'Smith',<br/>  getName(){<br/>    return `${this.firstName} ${this.lastName}`<br/>  }<br/>}</span><span id="ba5a" class="mt lj it lh b gy my mv l mw mx">console.log(person.getName.bind()());</span></pre><p id="8f33" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们得到<code class="fe le lf lg lh b">undefined undefined</code>，因为<code class="fe le lf lg lh b">this</code>将被设置为<code class="fe le lf lg lh b">window</code>对象，因为执行范围的<code class="fe le lf lg lh b">this</code>是一个<code class="fe le lf lg lh b">window</code>对象，因为它运行在顶层。</p><p id="9f7d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们用传入的对象调用<code class="fe le lf lg lh b">bind</code>，如下面的代码所示:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="01de" class="mt lj it lh b gy mu mv l mw mx">let person = {<br/>  firstName: 'Jane',<br/>  lastName: 'Smith',<br/>  getName() {<br/>    return `${this.firstName} ${this.lastName}`<br/>  }<br/>}</span><span id="6ea4" class="mt lj it lh b gy my mv l mw mx">const joe = {<br/>  firstName: 'Joe',<br/>  lastName: 'Smith'<br/>}</span><span id="bec6" class="mt lj it lh b gy my mv l mw mx">console.log(person.getName.bind(joe)());</span></pre><p id="32b9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们得到了<code class="fe le lf lg lh b">'Joe Smith'</code>,因为我们将<code class="fe le lf lg lh b">joe</code>对象传递给了<code class="fe le lf lg lh b">bind</code>方法的第一个参数，这将<code class="fe le lf lg lh b">getName</code>方法中的<code class="fe le lf lg lh b">this</code>对象设置为<code class="fe le lf lg lh b">joe</code>对象。</p><p id="6e93" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，我们可以用<code class="fe le lf lg lh b">bind</code>将参数传递给函数。例如，我们可以添加一个<code class="fe le lf lg lh b">greet</code>方法，该方法采用一个<code class="fe le lf lg lh b">greeting</code>和一个<code class="fe le lf lg lh b">age</code>参数，并返回一个新字符串，其中所有参数与现有字段组合在一起，如下面的代码所示:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="922c" class="mt lj it lh b gy mu mv l mw mx">let person = {<br/>  firstName: 'Jane',<br/>  lastName: 'Smith',<br/>  getName() {<br/>    return `${this.firstName} ${this.lastName}`<br/>  },<br/>  greet(greeting, age) {<br/>    return `${greeting} ${this.firstName} ${this.lastName}. You're ${age} years old`<br/>  }<br/>}</span><span id="b1d0" class="mt lj it lh b gy my mv l mw mx">const joe = {<br/>  firstName: 'Joe',<br/>  lastName: 'Smith'<br/>}</span><span id="78be" class="mt lj it lh b gy my mv l mw mx">console.log(person.greet.bind(joe, 'Hello', 20)());</span></pre><p id="e54c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们运行上面的代码，那么我们得到<code class="fe le lf lg lh b">'Hello Joe Smith. You’re 20 years old’</code>，因为我们通过将<code class="fe le lf lg lh b">joe</code>传递到<code class="fe le lf lg lh b">bind</code>方法的第一个参数中，将<code class="fe le lf lg lh b">this</code>设置为<code class="fe le lf lg lh b">joe</code>。然后，我们通过传入<code class="fe le lf lg lh b">'Hello'</code>将我们的参数传入<code class="fe le lf lg lh b">person.greet</code>方法，并将20作为<code class="fe le lf lg lh b">bind</code>方法的第二个和第三个参数，它被传入<code class="fe le lf lg lh b">greet</code>方法调用的第一个和第二个参数。</p><p id="415d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们也可以配合<code class="fe le lf lg lh b">setTimeout</code>功能使用。根据上面对<code class="fe le lf lg lh b">bind</code>的定义，如果我们将一个原始值传递给<code class="fe le lf lg lh b">setTimeout</code>函数的回调函数的第一个参数<code class="fe le lf lg lh b">bind</code>，那么它将被转换成一个对象。例如，如果我们有:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="0635" class="mt lj it lh b gy mu mv l mw mx">setTimeout(function(x, y) {<br/>  console.log(this, x, y);<br/>}.bind(1, 1, 1), 1)</span></pre><p id="f3bb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们从回调函数的<code class="fe le lf lg lh b">console.log</code>输出中得到<code class="fe le lf lg lh b">Number {1} 1 1</code>，因为我们将第一个参数中的原始值1转换成了一个对象，然后其他两个参数是回调函数被调用时传递给它的参数。</p><p id="25f0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在JavaScript函数中，有一个<code class="fe le lf lg lh b">call</code>、<code class="fe le lf lg lh b">bind</code>和<code class="fe le lf lg lh b">apply</code>方法来改变函数中<code class="fe le lf lg lh b">this</code>的值。在本文中，我们将仔细研究它们，以及如何使用它们来更改<code class="fe le lf lg lh b">this</code>的值。它们仅适用于常规函数，因为箭头函数不会改变<code class="fe le lf lg lh b">this</code>的值。所有3个都非常相似，因为它们都改变了<code class="fe le lf lg lh b">this</code>的值，并让我们向调用它们的函数传递参数。</p></div></div>    
</body>
</html>