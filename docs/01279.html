<html>
<head>
<title>Living within your means: Firestore’s Spark Plan</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">量入为出:Firestore的星火计划</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/living-within-your-means-firestores-spark-plan-d7e20cdac1ba?source=collection_archive---------13-----------------------#2019-12-10">https://levelup.gitconnected.com/living-within-your-means-firestores-spark-plan-d7e20cdac1ba?source=collection_archive---------13-----------------------#2019-12-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="3d6a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我最近开始了一个个人项目，我想在云中使用一个数据库。可供选择的有不少。我的主要标准是它要便宜或者免费。最终我决定选择<a class="ae ko" href="https://firebase.google.com/docs/firestore" rel="noopener ugc nofollow" target="_blank"> Firestore </a>，使用<a class="ae ko" href="https://firebase.google.com/pricing" rel="noopener ugc nofollow" target="_blank">星火计划</a>。这个计划给了我5Gb的存储空间，每天免费读取50K数据和写入20K数据，这在当时看来已经足够了。我很快了解到，稍有不慎就可能很快超过交易限额。</p><p id="3e19" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Firestore是一个NoSQL文档存储数据库。每个NoSQL数据库都是不同的，我的学习曲线比预期的要陡峭。如你所知，最好的老师是逆境，我很早就犯过错误。但是如果太多，我就会达到计划的读写极限，这有时会在一两个小时内发生。然后是收工的时候了。</p><p id="ab88" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在情况有所好转，所以我提供这些经验教训:</p><h1 id="a2bd" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">*从免费计划开始</h1><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi ln"><img src="../Images/ba5086e9b9470d72d198afa798c5a217.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FMmgrygXigiKszG-TvJZ_g.jpeg"/></div></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk translated">照片由<a class="ae ko" href="https://unsplash.com/@karim_manjra?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">卡里姆·曼吉拉</a>在<a class="ae ko" href="https://unsplash.com/s/photos/free-beer?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="3688" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">是的，超越计划的限制是很容易的，但是这些事情会迫使你学会有效地读写。您将变得更加注重以高效的方式对多个数据库操作进行排序。</p><h1 id="9c22" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">从一个小数据集开始</h1><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi md"><img src="../Images/b5150803059cd126ca653d39b7dc2ce2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0rhFthwFYv_OD1jWBXRCAQ.jpeg"/></div></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk translated">由<a class="ae ko" href="https://unsplash.com/@tchompalov?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Vlad Tchompalov </a>在<a class="ae ko" href="https://unsplash.com/s/photos/small?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="14ff" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这似乎是显而易见的，但是我说的“小”是指总共不到100个文档。在我的项目中，我首先用10K文档创建了一个集合。我后来意识到我加载的数据中有一个错误，修复了它，找到了另一个，去修复它，但是…TRANSACTION _ RESOURCE _ LIMIT _ exceed。好了，今天到此为止。</p><h1 id="508c" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">花时间设计您的数据模型</h1><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div class="gh gi me"><img src="../Images/bdf4e43697c5244964150d427c58ddca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1196/format:webp/1*1UKXULIiYAyUJ0jYdACiJQ.jpeg"/></div></figure><p id="4927" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">就像木匠的公理:“量两次，切一次。”，您不希望一点一点地调整JSON文档字段和结构。哦，你当然会，但是你可以通过实践一点远见来节省一些交易。首先写出文档、它们的字段以及它们的关系的示意图。<a class="ae ko" href="https://www.freecodecamp.org/news/inserting-uml-in-markdown-using-vscode/" rel="noopener ugc nofollow" target="_blank">想象是幸福的关键。</a></p><h1 id="7d13" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">测试和验证您的数据加载脚本</h1><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi ln"><img src="../Images/8ac49801d1069d1b7d26cd53ba5f24ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L0UbDLtAuq7w2CfjqUH1xw.jpeg"/></div></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk translated">JESHOOTS.COM在<a class="ae ko" href="https://unsplash.com/s/photos/test?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上<a class="ae ko" href="https://unsplash.com/@jeshoots?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">拍照</a></figcaption></figure><p id="548f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您将需要脚本从其他来源填充数据库。现在是时候:</p><ul class=""><li id="ccdb" class="mg mh it js b jt ju jx jy kb mi kf mj kj mk kn ml mm mn mo bi translated">验证您加载的是您所期望的</li><li id="63b8" class="mg mh it js b jt mp jx mq kb mr kf ms kj mt kn ml mm mn mo bi translated">正确处理字段的无数据情况</li></ul><p id="2886" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这两种情况下，我都犯了错误。首先，当我将一些字符串数据加载到文档字段中时，我没有立即注意到这些字符串已经有了引号，所以存储的字符串已经嵌入了引号。这似乎不是一个严重的问题，但后来在编写和测试该领域的搜索时，它成了一种痛苦。因为有很多文档，所以我花了每天写配额的很大一部分来清理它们。</p><p id="b56d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在第二种情况下，我发现Firestore没有机制来确定文档中属性的<a class="ae ko" href="https://stackoverflow.com/questions/46806860/how-to-query-cloud-firestore-for-non-existing-keys-of-documents" rel="noopener ugc nofollow" target="_blank">存在(没有<em class="mf">未定义的</em>检查)。有<em class="mf">有</em>有</a><a class="ae ko" href="https://firebase.google.com/docs/firestore/query-data/get-data#get_a_document" rel="noopener ugc nofollow" target="_blank">有<strong class="js iu">存在</strong>对单据</a>的测试，但对单据字段没有。最佳实践是用null填充缺失的数据字段，然后在where子句中进行null等价测试，以找到具有“缺失”属性的文档。</p><h1 id="3e09" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">一个小数据集教不了你什么</h1><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi mu"><img src="../Images/95d02fb71233d20928e5bae53c9abb00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lRAAu4ztCpoY0Iim9gJctg.jpeg"/></div></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk translated">本·怀特在<a class="ae ko" href="https://unsplash.com/s/photos/learning?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="cbe4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一旦你解决了小数据集的问题，是时候升级到更大的数据集了。随着要处理的文档越来越多，查询效率、分页和批量请求变得越来越重要。</p><h1 id="90f3" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">成块地读，成块地写</h1><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi mv"><img src="../Images/297ba00d5d7be2be7f11cc63bfdaa1a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NkwVKQ8AvxEz_w5fpwbjyQ.jpeg"/></div></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk translated">照片由<a class="ae ko" href="https://unsplash.com/@picoftasty?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">梅姆</a>在<a class="ae ko" href="https://unsplash.com/s/photos/chunks?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="5087" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae ko" href="https://firebase.google.com/docs/firestore/manage-data/transactions" rel="noopener ugc nofollow" target="_blank">批处理操作</a>允许在单个事务中对数据库进行多次读/写，这意味着如果任何写操作失败，那么所有写操作都会失败，并且数据库数据会保留其原始状态。批处理中的每个操作都计入总读/写配额，因此它对使用配额没有帮助。此外，当通过批处理操作编写时，要注意每批有500个操作的限制。</p><p id="9c07" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在关联两个文档时要小心(即，对于每个A文档，都有一个对B文档的引用关联)。不要先获取一个，然后遍历另一个。这是在调试时咀嚼事务配额的好方法。</p><p id="0662" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最好获取第一个集合的子集，然后逐个文档地遍历它。通过获取一个符合标准的<strong class="js iu">将这些文档与第二个集合中的文档相关联。继续这样做，直到获取了整个第一个集合。调试时，您可以验证一切看起来都正常工作，如果不正常，就在运行大量事务之前终止进程。</strong></p><h1 id="ee20" class="kp kq it bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">如何限制查询结果</h1><figure class="lo lp lq lr gt ls gh gi paragraph-image"><div role="button" tabindex="0" class="lt lu di lv bf lw"><div class="gh gi mu"><img src="../Images/1b9827dbce4e37d617531cc82789bdf2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k6hgH5yQEMd9ImNsYU0ZrA.jpeg"/></div></div><figcaption class="lz ma gj gh gi mb mc bd b be z dk translated">照片由<a class="ae ko" href="https://unsplash.com/@timothymuza?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">蒂莫西·穆扎</a>在<a class="ae ko" href="https://unsplash.com/s/photos/piece?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="191d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Firestore的查询语言不像SQL那样富于表现力，但仍然有许多方法来限制您的查询，使您不会过度提取数据。虽然从技术上讲，对后响应机构没有规模限制，但实际上是有。</p><p id="dcc3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一些限制查询结果的机制:</p><p id="098a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu"> where和compound where </strong></p><p id="ce6a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以将多个where子句链接在一起，类似于在SQL中将条件表达式添加到单个where子句中。</p><pre class="lo lp lq lr gt mw mx my mz aw na bi"><span id="6060" class="nb kq it mx b gy nc nd l ne nf">citiesRef.where('state', '==', 'CO').where('name', '==', 'Denver');</span></pre><p id="7536" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">极限和范围</strong></p><p id="f1aa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过在查询对象的末尾链接一个limit子句，可以限制查询返回的文档数。</p><pre class="lo lp lq lr gt mw mx my mz aw na bi"><span id="2080" class="nb kq it mx b gy nc nd l ne nf">let biggest = citiesRef.where('population', '&gt;', 2500000)<br/>  .orderBy('population').limit(2);</span></pre><p id="c774" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您还可以通过startAt/endAt或startBefore/endBefore约束指定要检索的记录范围，这允许您进行基于光标的分页。</p><pre class="lo lp lq lr gt mw mx my mz aw na bi"><span id="efa5" class="nb kq it mx b gy nc nd l ne nf">let docRef = db.collection('cities').doc('SF');</span><span id="7d7d" class="nb kq it mx b gy ng nd l ne nf">return docRef.get().then(snapshot =&gt; {<br/>  let startAtSnapshot = db.collection('cities')<br/>    .orderBy('population')<br/>    .startAt(snapshot);<br/>  return startAtSnapshot.limit(10).get();<br/>});</span></pre><p id="6cf4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">在数组中查询</strong></p><p id="3df5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以在数组中查找特定的匹配项。这对枚举值来说很好。</p><pre class="lo lp lq lr gt mw mx my mz aw na bi"><span id="30b9" class="nb kq it mx b gy nc nd l ne nf">const usaOrJapan = citiesRef.where('country', 'in', ['USA', 'Japan']);</span></pre></div><div class="ab cl nh ni hx nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="im in io ip iq"><p id="69fb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正如所展示的，随着你对Firestore的了解，在Spark计划的限制范围内工作是可能的。它是免费的，这总是一个好的开始。</p></div></div>    
</body>
</html>