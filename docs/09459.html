<html>
<head>
<title>Optimizing your BigQuery tables using clustering</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用聚类优化BigQuery表</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/optimizing-your-bigquery-tables-using-clustering-4d2b4255b461?source=collection_archive---------4-----------------------#2021-08-12">https://levelup.gitconnected.com/optimizing-your-bigquery-tables-using-clustering-4d2b4255b461?source=collection_archive---------4-----------------------#2021-08-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="5bf5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">除了通过表分区来提高BigQuery的性能和成本，还有另一种技术叫做<em class="ko">集群</em>。</p><p id="0128" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">提醒一下:</strong>集群和分区并不互相抢占。在大多数情况下，两者结合使用是有意义的。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi kp"><img src="../Images/50f1485a75d93ed14a608cbe77c939ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VNdhocvU2q5J41wf"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">照片由<a class="ae lb" href="https://unsplash.com/@casparrubin" rel="noopener ugc nofollow" target="_blank">卡斯帕·卡米尔·鲁宾</a>在<a class="ae lb" href="https://www.unsplash.com/" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="2a8d" class="lc ld it bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">什么是聚集表？</h1><p id="3530" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn im bi translated">使用聚集表，BigQuery根据一个或多个选定的列自动组织和存放相关数据。这里需要注意的是，为集群指定的列的顺序非常重要。但稍后会详细介绍。</p><p id="918d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">由于BigQuery几乎自动完成所有的事情——关于集群——您唯一要做的事情就是告诉BigQuery您希望BigQuery对哪些列以及以什么顺序对您的数据进行集群。</p><p id="0170" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后，BigQuery将数据存储在内部BigQuery存储的多个块中。将数据存储在预先排序的块中意味着BigQuery可以根据查询过滤子句使用这些块来防止扫描不必要的数据。</p><p id="befe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">根据官方文档，当扫描的表(或表分区)超过1 GB时，使用集群将显著提高性能。</p><p id="933c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">BigQuery提供了自动重新聚集，这意味着即使您向表中添加新数据，BigQuery也会自动将它们分类到现有的块中。</p><p id="781a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">集群表与非集群表的一个小例子</strong></p><p id="ad38" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在下图中，您可以在左侧看到一个带有随机插入数据的表，在右侧看到一个带有<em class="ko">名称</em>和<em class="ko">事件</em>列的聚集表。</p><p id="d0a1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如您所见，具有相同<em class="ko">名称</em>的行位于彼此正下方。并且在相同<em class="ko">名称的范围内，具有相同<em class="ko">事件</em>的</em>行也位于同一位置。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/8b179c5b5504452b513bec64405eb430.png" data-original-src="https://miro.medium.com/v2/resize:fit:754/format:webp/1*BfFfiB6War7N4ZrOLJxUaw.png"/></div></figure><p id="51d7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以这个例子为例，您已经可以想象在查询数据时可能的改进。作为一个例子，让我们假设您想要查询所有的值，其中<em class="ko">名称</em>等于<em class="ko">“1”</em>。</p><p id="8fe2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果没有集群，BigQuery将不得不扫描整个表，因为每一行都可能在其<em class="ko">名称</em>列中包含值<em class="ko"> "1" </em>。</p><p id="910a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用集群，BigQuery知道只有前三列符合这个过滤条件。这导致扫描的列减少了50%,因为所有可能的结果行都在彼此的正下方，BigQuery可以跳过另外50%。此外，减少50%的检查行也意味着减少50%的成本，因为BigQuery对读取的字节收费。尽管这可能不是100%准确，但正如我们将在后面看到的那样，它足够准确，可以对表中的数据进行聚类。</p><p id="dbaa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">扫描时跳过特定块的过程也称为<em class="ko">块修剪</em>。即使BigQuery不一定要为聚集列中的每个不同值创建一个块。BigQuery创建的块数很大程度上取决于存储的数据量。对于1 MB的数据，即使它在聚集列中可能包含100个不同的值，BigQuery也不会创建100个块，并在筛选一个特定值时节省99%的读取字节。但是表中可用的(不同的)数据越多；聚类将变得越有效。正如上面已经提到的，Google建议最小表大小为1 GB，这样使用集群就可以看到显著的改进。但是我们将在下一节看到，改进将更早开始。</p><h1 id="d758" class="lc ld it bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">亲自动手</h1><p id="7eef" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn im bi translated">现在是时候进行一些实际的动手编码并查看一些真实的例子了。我把动手部分分成了四个小部分。</p><ol class=""><li id="0dc7" class="mg mh it js b jt ju jx jy kb mi kf mj kj mk kn ml mm mn mo bi translated">简单的脚本来创建一些我们可以导入和查询的测试数据。</li><li id="4065" class="mg mh it js b jt mp jx mq kb mr kf ms kj mt kn ml mm mn mo bi translated">将测试数据作为普通表和聚集表导入BigQuery。</li><li id="864f" class="mg mh it js b jt mp jx mq kb mr kf ms kj mt kn ml mm mn mo bi translated">用相同的查询查询两个表并比较结果。</li><li id="34bc" class="mg mh it js b jt mp jx mq kb mr kf ms kj mt kn ml mm mn mo bi translated">基于一个真实的例子对Google的集群块大小做一个假设。</li></ol><p id="836f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">创建测试数据</strong></p><p id="6637" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们将根据本文中的第一张图来创建测试数据，其中我们展示了与普通表相比，BigQuery如何组织一个集群表。</p><p id="e554" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这意味着我们将有两列。一列代表一个<em class="ko">名字</em>，另一列代表一个<em class="ko">事件</em>。</p><div class="mu mv gp gr mw mx"><a rel="noopener  ugc nofollow" target="_blank" href="/optimizing-your-bigquery-tables-using-partitioning-time-unit-column-partitioned-tables-c93cfbf3828d"><div class="my ab fo"><div class="mz ab na cl cj nb"><h2 class="bd iu gy z fp nc fr fs nd fu fw is bi translated">使用分区优化BigQuery表:时间单位列分区表</h2><div class="ne l"><h3 class="bd b gy z fp nc fr fs nd fu fw dk translated">尤其是在处理大数据时，当数据开始变得不稳定时，成本会迅速激增，性能会迅速下降</h3></div><div class="nf l"><p class="bd b dl z fp nc fr fs nd fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="ng l"><div class="nh l ni nj nk ng nl kv mx"/></div></div></a></div><p id="f0fe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">与上一篇文章不同(<a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/optimizing-your-bigquery-tables-using-partitioning-time-unit-column-partitioned-tables-c93cfbf3828d">使用分区优化BigQuery表:时间单位列分区表</a>)，我们将通过JavaScript脚本动态创建数据，并将其写入CSV文件。我们需要最少量的数据—我们将创建5，000，000行，生成一个28 MB的CSV文件—这样我们就可以看到集群的一些效果。</p><p id="5c10" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，让我们来看看生成测试数据的实际代码。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="5321" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如你所见，我们使用<em class="ko"> csv-writer </em> NPM模块来编写csv文件。所以确保你通过<em class="ko"> npm i安装它——在运行脚本之前保存csv-writer </em>。</p><p id="fe43" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">剧本本身应该容易理解。首先，我们定义一些常量来确定行数、不同名称的数量以及脚本将随机生成的事件。为了简单起见，我使用简单的数字来表示名称。</p><p id="0dbd" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当您使用我的默认值时，该脚本将生成一个28 MB的CSV文件，其中正好包含5，000，000行数据—外加一个列标题—以及1，000个不同的名称和10个不同的事件。该脚本将名称定义为0到999之间的值，将事件定义为0到9之间的值。</p><p id="e56d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当然，每次运行时，生成的CSV文件都会包含一点点不同的数据。但是由于出现的次数很多，您可以预期每个名称会出现大约5.000次。</p><p id="1680" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">既然测试数据已经准备好了，是时候将它发送给BigQuery了。</p><p id="9991" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">通过CSV导入创建包含数据的新表格</strong></p><p id="f56e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您查看下面的代码片段，您会发现与上一篇文章的CSV导入脚本有许多相似之处(<a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/optimizing-your-bigquery-tables-using-partitioning-time-unit-column-partitioned-tables-c93cfbf3828d">使用分区优化您的BigQuery表:时间单位列分区表</a>)。的确，大部分都是相同的代码。主要区别是<em class="ko"> importCSV() </em>方法的第四个参数。在我们使用<em class="ko">时间分割之前，</em>我们现在使用<em class="ko">集群</em>来定义BigQuery应该集群的字段。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="5751" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在脚本中，我们将聚类字段定义为<em class="ko"> ["name "，" event"] </em>，这意味着BigQuery首先对<em class="ko">名称</em>进行聚类，然后对<em class="ko">事件</em>列进行聚类。</p><p id="28ec" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在您成功运行该脚本之后——将大约28 MB的CSV文件导入到BigQuery并等待集群完成可能需要一点时间——我们可以通过CLI验证BigQuery是否正确地添加了集群。</p><p id="749e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">bq show—format = pretty JSON</em></p><p id="2747" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><em class="ko">您的_ GCP _项目:您的_数据集_ID.my_clustered_table </em></p><p id="99ac" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这个命令将把BigQuery表的元数据打印到CLI。在那里，您应该会发现一些类似于下面的<em class="ko">集群</em>的条目:</p><pre class="kq kr ks kt gt no np nq nr aw ns bi"><span id="e640" class="nt ld it np b gy nu nv l nw nx"><em class="ko">“clustering”: {<br/>  “fields”: [<br/>    “name”,<br/>    “event”<br/>  ]<br/>},</em></span></pre><p id="34a0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您对<em class="ko"> non_clustered_table </em>运行相同的命令，您应该看不到<em class="ko">集群</em>的任何条目。</p><p id="3c14" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">对导入的数据进行查询</strong></p><p id="4a53" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，我们已经将所有数据导入到普通表和集群表中，并验证了BigQuery在集群表上正确地启用了集群，现在可以对它运行一些查询来比较它们的统计数据。</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="c7de" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">同样，我们使用了前一篇文章中的大量代码，因为大部分代码独立于任何集群或分区。</p><p id="c4c0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">与之前相比，我们向我们的<em class="ko"> runQuery </em>方法添加了一些<em class="ko"> printConfig </em>来定义它应该打印什么——查询结果或作业统计数据，或者两者都打印。</p><p id="1a45" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我们的标准搜索查询——<em class="ko">create query</em>——中，我们通过特定的<em class="ko">名称</em>和值<em class="ko"> "1" </em>来过滤行。理论上，这应该会影响大约5，000行，因为我们已经创建了5，000，000行，其中有1，000个不同的名称，每个名称大约有5，000个条目。</p><p id="1566" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们添加了一个额外的查询——<em class="ko">create count query</em>——我们将运行并打印它的结果。我们运行这个查询来验证我们的假设，即大约有5，000行会受到我们的文件管理器条件的影响。</p><p id="bffa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">查询结果</strong></p><p id="bf84" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当您运行上面的脚本时，您应该会得到与下面类似的结果:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="e00f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因为我们这里没有很多数据，所以两个查询中花费的<em class="ko">时间</em>是相似的。正如开始时所解释的，当表的大小接近1 GB或更大时，可以看到显著的性能改进。</p><p id="1f46" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是你可以看到，读取的<em class="ko">行和处理的<em class="ko">字节</em>——Google向你收费——显著减少了。</em></p><p id="c902" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">从5，000，000行读取和64，450，259字节处理，我们减少到384，853行读取和4，947，899字节处理。这在理论上节省了92.3%的成本！仅仅因为我们使用了聚类。</p><p id="8fad" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您也可以在下图中看到这种巨大的差异:</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/456d0f2a70632124541bfb5a2eddc5f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:824/format:webp/1*CkiswQ-Oh0FAjQ5rIGUgrw.png"/></div></figure><p id="9984" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">细心的观众还会注意到，计费的<em class="ko">字节并没有减少92.3%，尽管这是意料之中的。是的，完全正确。但这是因为谷歌对每个查询收取最低10 MB的费用，而不考虑实际处理的字节数。当</em>处理的<em class="ko">字节高于10 MB时，计费</em>的<em class="ko">字节几乎总是与</em>处理的<em class="ko">字节相同。</em></p><p id="d339" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">谷歌的聚类块大小，一个假设</strong></p><p id="f156" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">除此之外，您可能还会注意到，读取的<em class="ko">行的数量远远高于我们预计只为查询扫描的5000行。这是由于BigQuery的一些Google内部配置，其中存在一个集群范围的最小大小。尽管谷歌的“魔力”不仅仅在于协同定位数据的大小。</em></p><p id="834c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您可以假设，当您将数据量增加到某个点时，读取的<em class="ko">行应该与受影响的行具有相同的值。因为我们在上面看到，即使只有5，000行应该受到影响—查询读取了384，853行—我们可以认为在这个值附近的某个地方，可能有一些“神奇的数字”。</em></p><p id="4a41" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">举个小例子——我还不想深入这个话题——我将上面的测试数据集修改如下:</p><ul class=""><li id="4b3c" class="mg mh it js b jt ju jx jy kb mi kf mj kj mk kn nz mm mn mo bi translated">我把条目总数增加到1000万。</li><li id="617f" class="mg mh it js b jt mp jx mq kb mr kf ms kj mt kn nz mm mn mo bi translated">我把不同的名字减少到20个。</li></ul><p id="4189" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">理论上，这些变化会产生20个不同的名称，每个名称在表中大约出现500，000次。有了这个，我们的出现次数就比之前的查询读取的行数要多。</p><p id="10ae" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们来看看结果:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="f355" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">乍一看，结果可能看起来有些混乱。即使我们现在有500，000个条目符合我们的过滤标准，BigQuery只读取了将近400，000行？我们还用我们的<em class="ko"> createCountQuery </em>验证了大约有50万行符合我们的过滤器。</p><p id="5f86" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是等等！如果您还记得的话，我们在查询中使用了一个<em class="ko">限制1 </em>，因为我们对实际结果从不感兴趣，而只是查看了作业统计数据。</p><p id="567e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们将这个<em class="ko">限制1 </em>更改为<em class="ko">限制600000 </em>，这样我们将检索所有受影响的行，并再次查看我们脚本的结果:</p><figure class="kq kr ks kt gt ku"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="25db" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们现在可以清楚地看到，该作业总共读取了799，675。这几乎是<em class="ko">极限1 </em>情况下读取行数的两倍，即798，948。那里可能有一些东西…</p><p id="a5c9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">尽管我没有找到任何官方文档，但它可能会为您提供一些关于聚集表的可能块大小的提示。但到目前为止，这纯粹是我的调查，当然还涉及到其他因素。我想更进一步，但我认为这超出了本文的范围，因为它应该是对集群的一些介绍，而不是对其内部结构的深入探究。</p><h1 id="db71" class="lc ld it bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">需要注意的集群限制和常见陷阱</h1><p id="a47e" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn im bi translated"><strong class="js iu">聚集列的最大数量</strong> — BigQuery最多支持四列进行聚集。</p><p id="a79f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">字符串<em class="ko">类型</em>的聚类</strong> —当您使用<em class="ko">字符串</em>类型进行聚类时，必须注意BigQuery仅使用单元格值的前1024个字符进行聚类。BigQuery的聚类算法不会考虑超出该限制的所有内容，即使将更长的值写入单元格是有效的。</p><p id="2b20" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">聚集列的顺序</strong> —定义用于聚集的列的顺序对于良好的性能至关重要。如果希望从聚类机制中受益，有必要在筛选表达式中以从左到右的排序顺序使用所有的聚类列或它们的子集。如果您有集群列<em class="ko"> A </em>、<em class="ko"> B </em>和<em class="ko"> C </em>，您将必须对它们全部进行过滤，只过滤<em class="ko"> A，或者A </em>和<em class="ko"> B </em>。仅仅对<em class="ko"> B </em>和<em class="ko"> C </em>进行滤波不会产生预期的性能提升。作为最佳实践，您应该始终首先指定最频繁筛选或聚合的列。实际SQL过滤器表达式中的顺序不会影响性能。重要的是要过滤哪些列。</p><h2 id="6fef" class="nt ld it bd le oa ob dn li oc od dp lm kb oe of lq kf og oh lu kj oi oj ly ok bi translated">你想联系吗？</h2><p id="6350" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mc kd ke kf md kh ki kj me kl km kn im bi translated">如果你想联系我，请在LinkedIn上给我打电话。</p><p id="c598" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">另外，请随意查看我的书籍推荐📚。</p></div><div class="ab cl ol om hx on" role="separator"><span class="oo bw bk op oq or"/><span class="oo bw bk op oq or"/><span class="oo bw bk op oq"/></div><div class="im in io ip iq"><div class="kq kr ks kt gt mx"><a href="https://mr-pascal.medium.com/my-book-recommendations-4b9f73bf961b" rel="noopener follow" target="_blank"><div class="my ab fo"><div class="mz ab na cl cj nb"><h2 class="bd iu gy z fp nc fr fs nd fu fw is bi translated">我的书籍推荐</h2><div class="ne l"><h3 class="bd b gy z fp nc fr fs nd fu fw dk translated">在接下来的章节中，你可以找到我对所有日常生活话题的书籍推荐，它们对我帮助很大。</h3></div><div class="nf l"><p class="bd b dl z fp nc fr fs nd fu fw dk translated">mr-pascal.medium.com</p></div></div><div class="ng l"><div class="os l ni nj nk ng nl kv mx"/></div></div></a></div><div class="mu mv gp gr mw mx"><a href="https://mr-pascal.medium.com/membership" rel="noopener follow" target="_blank"><div class="my ab fo"><div class="mz ab na cl cj nb"><h2 class="bd iu gy z fp nc fr fs nd fu fw is bi translated">通过我的推荐链接加入Medium—Pascal Zwikirsch</h2><div class="ne l"><h3 class="bd b gy z fp nc fr fs nd fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="nf l"><p class="bd b dl z fp nc fr fs nd fu fw dk translated">mr-pascal.medium.com</p></div></div><div class="ng l"><div class="ot l ni nj nk ng nl kv mx"/></div></div></a></div></div></div>    
</body>
</html>