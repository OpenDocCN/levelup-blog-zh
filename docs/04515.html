<html>
<head>
<title>Nginx Load Balancing and using with Docker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Nginx负载平衡和与Docker一起使用</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/nginx-load-balancing-and-using-with-docker-7e16c49f5d9?source=collection_archive---------2-----------------------#2020-06-30">https://levelup.gitconnected.com/nginx-load-balancing-and-using-with-docker-7e16c49f5d9?source=collection_archive---------2-----------------------#2020-06-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/78dd3e2d0ab5cc7de7d7a79a96181ad8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*H3U0Gud5ztpVTmkuVTwPoA.jpeg"/></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">来源:<a class="ae kb" href="https://cheezburger.com/1639595264" rel="noopener ugc nofollow" target="_blank">芝士堡</a></figcaption></figure><p id="f9a2" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">所以这张照片说明了负载平衡不是什么。我们先简单说一下负载均衡。</p><p id="2b5c" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">多个应用程序的负载平衡是优化响应性、可用性和资源利用率的常用技术。负载平衡器管理服务器和客户端之间的流量。它们将流量分配给资源池中的不同服务器，以确保没有一台服务器超负荷工作。它们可以是硬件或软件解决方案。</p><figure class="lb lc ld le gt ju gh gi paragraph-image"><div class="gh gi la"><img src="../Images/1e1b12945b97dfb15581a7df3e1c06cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*GeWMDIt-w7BdDn_r.png"/></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">来源:<a class="ae kb" href="https://www.sempeak.com/blog/load-balancer-nedir" rel="noopener ugc nofollow" target="_blank">森皮克</a></figcaption></figure><p id="ef26" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">Nginx可以作为一个很好的负载平衡器，将传入的流量分配给服务器，并将响应从选定的服务器返回给客户端。Nginx比其他负载均衡器有一些优势；</p><ul class=""><li id="7b00" class="lf lg it ke b kf kg kj kk kn lh kr li kv lj kz lk ll lm ln bi translated">它支持多种平衡方法，适用于许多情况</li><li id="1712" class="lf lg it ke b kf lo kj lp kn lq kr lr kv ls kz lk ll lm ln bi translated">它支持静态和动态缓存</li><li id="c05c" class="lf lg it ke b kf lo kj lp kn lq kr lr kv ls kz lk ll lm ln bi translated">每个Nginx实例完全支持多个不同的应用程序</li><li id="1c8e" class="lf lg it ke b kf lo kj lp kn lq kr lr kv ls kz lk ll lm ln bi translated">它可以基于动态请求头、cookies、变量甚至查询参数来管理分发</li><li id="6002" class="lf lg it ke b kf lo kj lp kn lq kr lr kv ls kz lk ll lm ln bi translated">速率限制、加权和会话管理</li></ul><figure class="lb lc ld le gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi lt"><img src="../Images/5f05553ce6f113bcd676ea8fe7ddafa9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eaAaPaZB3cW3JUep6FFkFA.png"/></div></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">来源:<a class="ae kb" href="https://www.pngegg.com/" rel="noopener ugc nofollow" target="_blank"> pngegg </a></figcaption></figure><p id="2672" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">Nginx开源支持四种负载平衡方法，Nginx Plus支持另外两种方法。</p><ol class=""><li id="d668" class="lf lg it ke b kf kg kj kk kn lh kr li kv lj kz ly ll lm ln bi translated"><strong class="ke iu">循环法:</strong>如果您没有指定任何内容，这是默认方法。在这种方法中，请求将被平均分配给后端服务。或者您可以指定要在分配中使用的权重。</li><li id="f484" class="lf lg it ke b kf lo kj lp kn lq kr lr kv ls kz ly ll lm ln bi translated"><strong class="ke iu">最少连接数:</strong>在这种方法中，请求被发送到当时活动连接数最少的服务器。您也可以用这种方法指定权重。</li><li id="5d0b" class="lf lg it ke b kf lo kj lp kn lq kr lr kv ls kz ly ll lm ln bi translated"><strong class="ke iu"> IP Hash: </strong>在其他平衡方法中，来自客户端的每个请求都可以被发送到不同的服务器。如果您在应用程序中使用会话，则不能提供持久性。在这种情况下，你有两种选择:你可以在你的服务器之间使用共享会话，比如Redis，或者在Nginx上使用IP哈希方法。在这种方法中，Nginx使用客户端IP地址作为密钥，将来自相同IP的请求发送到相同的服务器。这确保了客户端总是被重定向到相同的服务器。</li><li id="075d" class="lf lg it ke b kf lo kj lp kn lq kr lr kv ls kz ly ll lm ln bi translated"><strong class="ke iu">通用散列:</strong>在这个方法中，你可以使用你自己的变量来指定请求将被发送到哪个服务器。这些变量可以是请求头、客户端IP或请求参数。</li></ol></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><p id="cc55" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">让我们用docker和一个简单的node.js API创建一个例子来测试这些方法，看看它们如何影响我们的请求。我将使用<a class="ae kb" href="https://k6.io/" rel="noopener ugc nofollow" target="_blank"> k6 </a>对端点进行负载测试。k6是开源的负载测试工具，也是API性能测试的云服务。</p><p id="9407" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">首先，我创建了一个简单的node.js API，带有一个默认的get端点。它将返回当前的主机名，因此我将能够检测哪些请求被重定向到哪个主机。它将监听dockerfile中定义的3003端口。</p><figure class="lb lc ld le gt ju"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="58ec" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">现在我们有了一个docker-compose文件，它将在docker上构建nginx和我们的API映像。</p><figure class="lb lc ld le gt ju"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="5eba" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">在nginx.dockerfile中，我将使用nginx映像，并将本地nginx.conf文件复制到主机上的nginx目录中。</p><figure class="lb lc ld le gt ju"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="96a2" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">在第一个测试中，我将把API作为一个实例进行测试。在nginx.conf文件中，它将监听5100端口，并将这些请求重定向到监听3003端口的API端点。</p><figure class="lb lc ld le gt ju"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="0dea" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">在k6测试脚本中，它将创建一个对localhost:5001的请求，并记录200个状态结果和响应，其中包括API主机名，我将使用这个日志来检查主机的请求计数。</p><figure class="lb lc ld le gt ju"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="8327" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">在运行测试时，我将使用相同的时间长度和相同的虚拟用户数来比较测试结果。它将是30秒长，有200个虚拟用户。</p><pre class="lb lc ld le gt mi mj mk ml aw mm bi"><span id="bf32" class="mn mo it mj b gy mp mq l mr ms">k6 run -u 200 -d 30s — summary-export=export.json — out json=my_test_result.json script.js</span></pre><figure class="lb lc ld le gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi mt"><img src="../Images/ac7650aa40a56f51f6cef61ab0b2092a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XMZLNmZZS2PidJBNlWZQzw.png"/></div></div></figure><p id="76c5" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">在单实例测试中，它总共进行了30426次测试，每秒1014个请求。现在，我将使用nginx负载平衡方法进行测试，并分享结果。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><ol class=""><li id="a9f8" class="lf lg it ke b kf kg kj kk kn lh kr li kv lj kz ly ll lm ln bi translated"><strong class="ke iu">循环赛</strong></li></ol><p id="afe5" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">对于这个测试，我将扩展3个API实例，nginx将传入的请求重定向到这些实例。</p><pre class="lb lc ld le gt mi mj mk ml aw mm bi"><span id="14ee" class="mn mo it mj b gy mp mq l mr ms">docker-compose up — scale api=3 -d</span></pre><figure class="lb lc ld le gt ju"><div class="bz fp l di"><div class="mg mh l"/></div></figure><figure class="lb lc ld le gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi mu"><img src="../Images/39d204d0c333ee255db097c9d127a38a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lEZ12lmCbwU4RMK0Oh-Yfw.png"/></div></div></figure><figure class="lb lc ld le gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi mv"><img src="../Images/9c35e8cb539493fa540f71aaba9a3496.png" data-original-src="https://miro.medium.com/v2/resize:fit:742/format:webp/1*XSkCigLWMw_bXexE25tx1w.png"/></div></div></figure><p id="52ee" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">正如您从k6结果中看到的，它创建了比单实例更多的请求，总共52545个请求，每秒1751个请求。nginx也将这些请求平均分配给API实例。</p><p id="336a" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">如果我们给nginx配置文件中的一个服务器一个权重，并再次尝试这个测试:</p><figure class="lb lc ld le gt ju"><div class="bz fp l di"><div class="mg mh l"/></div></figure><figure class="lb lc ld le gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi mw"><img src="../Images/3b67fe1b352eded9ac3b12a755b97c26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_aFZm4If6EC70oypUWkG6A.png"/></div></div></figure><figure class="lb lc ld le gt ju gh gi paragraph-image"><div class="gh gi mx"><img src="../Images/a06a89d824cfcc5d30875112dc28863f.png" data-original-src="https://miro.medium.com/v2/resize:fit:732/format:webp/1*d_d8_StYZDwAJ5TI0y6EsQ.png"/></div></figure><p id="198c" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">k6测试结果与前一个几乎相同，但是请求分布结果非常不同。因为我们的api_1的权重=2，所以它的请求数是其他api的两倍。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><p id="dcae" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">2.<strong class="ke iu">最少人脉</strong></p><p id="a03b" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">在此方法中，请求将被重定向到具有最少活动连接的服务器。因为我们同时提出请求，所以循环赛也会有同样的结果。</p><figure class="lb lc ld le gt ju"><div class="bz fp l di"><div class="mg mh l"/></div></figure><figure class="lb lc ld le gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi my"><img src="../Images/b34230260e1c4d81efad90a4780108ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bxv8EQjBvPhr2qOmaGSFBg.png"/></div></div></figure><figure class="lb lc ld le gt ju gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/d81a9465cb42c91b834888e3f1a9b822.png" data-original-src="https://miro.medium.com/v2/resize:fit:736/format:webp/1*56GYY4KJ3tLz7PER4BiD3Q.png"/></div></figure><p id="eff0" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">从结果可以看出，它与循环法的结果大致相同。总共49998个请求，每秒1666个请求。nginx也将这些请求平均分配给API实例。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><p id="2b21" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">3.<strong class="ke iu"> IP哈希</strong></p><p id="6c93" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">在这种方法中，nginx使用客户端ip地址向哪个实例发送请求。当我从localhost发出所有请求时，它将对所有请求使用相同的API实例。但是让我们看看测试结果。</p><figure class="lb lc ld le gt ju"><div class="bz fp l di"><div class="mg mh l"/></div></figure><figure class="lb lc ld le gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi na"><img src="../Images/c92725ed8e26455be2ee5fa9605f7f9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9-awntWjLrtASeeRxJYOnA.png"/></div></div></figure><figure class="lb lc ld le gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi nb"><img src="../Images/ed8c0bde787b88b59b87ca1aa0f94389.png" data-original-src="https://miro.medium.com/v2/resize:fit:734/format:webp/1*k215EZv4z5tKv8naoJWK8w.png"/></div></div></figure><p id="cd73" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">正如您从结果中看到的，虽然我有3个API服务器实例，nginx将所有传入请求重定向到第一个实例。和k6结果与单实例结果大致相同。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><p id="2e2f" class="pw-post-body-paragraph kc kd it ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz im bi translated">在这篇文章中，我试图告诉你nginx负载平衡如何与docker和简单测试一起工作。您可以在我的github repo上找到所有文件，如下所示。如果你还有其他问题，可以问我。</p><div class="nc nd gp gr ne nf"><a href="https://github.com/mrceylan/DockerNginxLoadBalancer" rel="noopener  ugc nofollow" target="_blank"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd iu gy z fp nk fr fs nl fu fw is bi translated">mrceylan/dockernginxloadbancer</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">在GitHub上创建一个帐户，为mrceylan/dockernginxloadbancer的开发做出贡献。</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">github.com</p></div></div><div class="no l"><div class="np l nq nr ns no nt jv nf"/></div></div></a></div></div></div>    
</body>
</html>