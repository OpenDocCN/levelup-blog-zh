<html>
<head>
<title>Use Docker with NodeJS Projects Like a Pro!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">像专业人士一样使用Docker和NodeJS项目！</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/use-docker-with-nodejs-projects-like-a-pro-a9e7504e1308?source=collection_archive---------0-----------------------#2022-08-18">https://levelup.gitconnected.com/use-docker-with-nodejs-projects-like-a-pro-a9e7504e1308?source=collection_archive---------0-----------------------#2022-08-18</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="a07e" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">在开发和生产中利用Docker的力量</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/f2e819d3303457da491ba3c219b6f167.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JIRNLjwWq-YbFfRp9JJsZA.jpeg"/></div></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated">由<a class="ae kz" href="https://unsplash.com/es/@chuklanov?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Avel Chuklanov </a>在<a class="ae kz" href="https://unsplash.com/s/photos/digital?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="20f6" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Docker是一项非常强大的技术，可以在许多方面让我们的生活变得更加轻松。</p><p id="fb3e" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">今天我们将对NodeJS(Express)应用程序进行Dockerize。我们将看到如何使用docker进行本地开发，这样您就不需要担心每个项目的nodejs版本。</p><p id="ea3d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们将假设已经有一个NodeJS应用程序启动并运行。如果您想了解我们是如何构建express应用程序的，请阅读下面的文章。</p><div class="lw lx gq gs ly lz"><a href="https://www.mohammadfaisal.dev/blog/create-express-typescript-boilerplate" rel="noopener  ugc nofollow" target="_blank"><div class="ma ab fp"><div class="mb ab mc cl cj md"><h2 class="bd iv gz z fq me fs ft mf fv fx it bi translated">创建-快递-打字稿-样板文章|穆罕默德·费萨尔</h2><div class="mg l"><h3 class="bd b gz z fq me fs ft mf fv fx dk translated">ExpressJS是NodeJS应用程序最流行的框架。它非常通用，没有任何限制。所以你…</h3></div><div class="mh l"><p class="bd b dl z fq me fs ft mf fv fx dk translated">www.mohammadfaisal.dev</p></div></div><div class="mi l"><div class="mj l mk ml mm mi mn kt lz"/></div></div></a></div><h2 id="e87b" class="mo mp iu bd mq mr ms dn mt mu mv dp mw lj mx my mz ln na nb nc lr nd ne nf ng bi translated">在我们开始之前…</h2><p id="3c5a" class="pw-post-body-paragraph la lb iu lc b ld nh jv lf lg ni jy li lj nj ll lm ln nk lp lq lr nl lt lu lv in bi translated">我用ExpressJS和Typescript 创建了一个<a class="ae kz" href="https://github.com/Mohammad-Faisal/professional-express-sequelize-docker-boilerplate" rel="noopener ugc nofollow" target="_blank">专业样板。本文是这个系列的一部分。你可以在下面找到所有的文章。</a></p><pre class="kk kl km kn gu nm nn no bn np nq bi"><span id="7fd0" class="nr mp iu nn b be ns nt l nu nv"><strong class="nn iv">* </strong><a class="ae kz" href="https://javascript.plainenglish.io/create-an-express-boilerplate-with-typescript-810eb6c29196" rel="noopener ugc nofollow" target="_blank"><strong class="nn iv">Creating a ExpressJS + Typescript Boilerplate</strong></a><strong class="nn iv"><br/><br/>* </strong><a class="ae kz" href="https://javascript.plainenglish.io/how-to-set-up-linter-formatter-for-node-js-d6b34c0c8be5" rel="noopener ugc nofollow" target="_blank"><strong class="nn iv">How to setup Linter and Formatter for NodeJS</strong></a><strong class="nn iv"><br/><br/>* </strong><a class="ae kz" href="https://blog.devgenius.io/how-to-handle-multiple-environments-in-nodejs-7391d2db2abe" rel="noopener ugc nofollow" target="_blank"><strong class="nn iv">How to handle multiple environments in NodeJS</strong></a><strong class="nn iv"><br/><br/>* </strong><a class="ae kz" href="https://javascript.plainenglish.io/error-handling-in-node-js-like-a-pro-ed210baa0600" rel="noopener ugc nofollow" target="_blank"><strong class="nn iv">Error Handling in NodeJS</strong></a><strong class="nn iv"><br/><br/>* </strong><a class="ae kz" href="https://medium.com/p/c69f2494cf18" rel="noopener"><strong class="nn iv">Request Validation in NodeJS</strong></a><strong class="nn iv"><br/><br/>* </strong><a class="ae kz" rel="noopener ugc nofollow" target="_blank" href="/use-docker-with-nodejs-projects-like-a-pro-a9e7504e1308"><strong class="nn iv">Using Docker Professionally with NodeJS</strong></a><strong class="nn iv"><br/><br/>* </strong><a class="ae kz" href="https://javascript.plainenglish.io/node-js-database-with-docker-for-local-development-285212c5162f" rel="noopener ugc nofollow" target="_blank"><strong class="nn iv">Using Docker for Local Development in NodeJS</strong></a><strong class="nn iv"><br/><br/>* </strong><a class="ae kz" href="https://javascript.plainenglish.io/node-js-logging-for-professionals-6be07c003e7f" rel="noopener ugc nofollow" target="_blank"><strong class="nn iv">Logging in NodeJS</strong></a><strong class="nn iv"><br/><br/>* </strong><a class="ae kz" rel="noopener ugc nofollow" target="_blank" href="/kubernetes-deployment-with-nodejs-made-easy-eaeec32b62e3"><strong class="nn iv">Kubernetes with NodeJS</strong></a></span></pre><p id="1d9f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们开始吧！</p><h1 id="84ee" class="nw mp iu bd mq nx ny nz mt oa ob oc mw ka od kb mz kd oe ke nc kg of kh nf og bi translated">获取NodeJS样板文件</h1><p id="b04e" class="pw-post-body-paragraph la lb iu lc b ld nh jv lf lg ni jy li lj nj ll lm ln nk lp lq lr nl lt lu lv in bi translated">首先，克隆<a class="ae kz" href="https://github.com/Mohammad-Faisal/express-typescript-skeleton" rel="noopener ugc nofollow" target="_blank"> express样板库</a>，在这里我们有一个已经设置了Typescript、EsLint和Prettier的express应用程序。</p><p id="9610" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们将在此基础上集成Docker。</p><pre class="kk kl km kn gu nm nn oh oi aw oj bi"><span id="db55" class="mo mp iu nn b gz ok ol l nu nv">git clone <a class="ae kz" href="https://github.com/Mohammad-Faisal/express-typescript-skeleton.git" rel="noopener ugc nofollow" target="_blank">https://github.com/Mohammad-Faisal/express-typescript-skeleton.git</a></span></pre><h1 id="bbf9" class="nw mp iu bd mq nx ny nz mt oa ob oc mw ka od kb mz kd oe ke nc kg of kh nf og bi translated">为什么是Docker？</h1><p id="3765" class="pw-post-body-paragraph la lb iu lc b ld nh jv lf lg ni jy li lj nj ll lm ln nk lp lq lr nl lt lu lv in bi translated">我很高兴你问了。Docker可以抽象出大多数与环境相关的错误，因为Docker可以确保您的应用程序在您的机器和世界上任何其他机器上都是相同的。</p><p id="f1e8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">假设您的机器安装了NodeJS 14。但是您得到了一个使用NodeJS 12的应用程序。那你是做什么的？安装Node的两个版本？是的，使用NVM等工具可以做到这一点。</p><p id="a316" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">但是如果你把你的应用程序dockerize，你不需要任何额外的负担在你的机器上。您可以在docker容器中运行任何版本的NodeJS。</p><p id="102b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我希望你能了解它的好处。让我们直接进入代码吧！</p><h1 id="0345" class="nw mp iu bd mq nx ny nz mt oa ob oc mw ka od kb mz kd oe ke nc kg of kh nf og bi translated">安装Docker</h1><p id="0a0d" class="pw-post-body-paragraph la lb iu lc b ld nh jv lf lg ni jy li lj nj ll lm ln nk lp lq lr nl lt lu lv in bi translated">如果您没有安装Docker，请转到<a class="ae kz" href="https://docs.docker.com/engine/install/" rel="noopener ugc nofollow" target="_blank">下面的链接</a>并遵循安装步骤。</p><p id="aff0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">然后在项目的根目录下创建Dockerfile。</p><pre class="kk kl km kn gu nm nn oh oi aw oj bi"><span id="1c0d" class="mo mp iu nn b gz ok ol l nu nv">touch Dockerfile</span></pre><h1 id="b41b" class="nw mp iu bd mq nx ny nz mt oa ob oc mw ka od kb mz kd oe ke nc kg of kh nf og bi translated">定义环境</h1><p id="5ef9" class="pw-post-body-paragraph la lb iu lc b ld nh jv lf lg ni jy li lj nj ll lm ln nk lp lq lr nl lt lu lv in bi translated">让我们打开<code class="fe om on oo nn b">Dockerfile</code>并开始为Docker构建配置。</p><p id="d061" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们需要做的第一件事是定义环境。对于我们的应用程序，我们将使用NodeJS 16。你可以在<a class="ae kz" href="https://hub.docker.com/_/node" rel="noopener ugc nofollow" target="_blank"> Docker Hub </a>上看到可用版本</p><pre class="kk kl km kn gu nm nn oh oi aw oj bi"><span id="9d64" class="mo mp iu nn b gz ok ol l nu nv">FROM node:16</span></pre><p id="2cba" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">但是大多数时候，我们并不需要整个NodeJS环境。我们可以使用轻量级的替代方案。</p><pre class="kk kl km kn gu nm nn oh oi aw oj bi"><span id="9035" class="mo mp iu nn b gz ok ol l nu nv">FROM node:lts-alpine</span></pre><p id="73b6" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">通常，alpine版本是轻量级的，但它为您的应用程序提供了足够的功能。</p><h1 id="74e6" class="nw mp iu bd mq nx ny nz mt oa ob oc mw ka od kb mz kd oe ke nc kg of kh nf og bi translated">创建工作目录</h1><p id="c496" class="pw-post-body-paragraph la lb iu lc b ld nh jv lf lg ni jy li lj nj ll lm ln nk lp lq lr nl lt lu lv in bi translated">docker映像将有一个单独的目录结构。所以我们需要在图像中的某个地方保存我们的应用程序代码。</p><p id="1850" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">让我们为我们的应用程序创建一个目录。</p><pre class="kk kl km kn gu nm nn oh oi aw oj bi"><span id="c5d4" class="mo mp iu nn b gz ok ol l nu nv">WORKDIR /usr/src/app</span></pre><h1 id="83ee" class="nw mp iu bd mq nx ny nz mt oa ob oc mw ka od kb mz kd oe ke nc kg of kh nf og bi translated">安装依赖项</h1><p id="3322" class="pw-post-body-paragraph la lb iu lc b ld nh jv lf lg ni jy li lj nj ll lm ln nk lp lq lr nl lt lu lv in bi translated">我们在顶部定义的映像已经安装了NodeJS和NPM，所以我们不必担心这个问题。接下来我们需要将我们的<code class="fe om on oo nn b">package.json</code>文件复制到我们刚刚在上面定义的工作目录中。</p><pre class="kk kl km kn gu nm nn oh oi aw oj bi"><span id="ac92" class="mo mp iu nn b gz ok ol l nu nv"># we are using a wildcard to ensure that both package.json and <br/># package-lock.json file into our work directory</span><span id="85c6" class="mo mp iu nn b gz op ol l nu nv">COPY package*.json ./</span></pre><p id="5291" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">然后安装依赖项。我们可以利用Docker的RUN命令。</p><pre class="kk kl km kn gu nm nn oh oi aw oj bi"><span id="1199" class="mo mp iu nn b gz ok ol l nu nv">RUN npm install</span></pre><p id="f6d9" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果你想为生产构建代码，我们可以使用下面的命令。<a class="ae kz" href="https://blog.npmjs.org/post/171556855892/introducing-npm-ci-for-faster-more-reliable" rel="noopener ugc nofollow" target="_blank">关于npm ci </a>命令的解释可以在这里找到。</p><pre class="kk kl km kn gu nm nn oh oi aw oj bi"><span id="f65d" class="mo mp iu nn b gz ok ol l nu nv">RUN npm ci --only=production</span></pre><h1 id="ae09" class="nw mp iu bd mq nx ny nz mt oa ob oc mw ka od kb mz kd oe ke nc kg of kh nf og bi translated">复制应用程序代码</h1><p id="8511" class="pw-post-body-paragraph la lb iu lc b ld nh jv lf lg ni jy li lj nj ll lm ln nk lp lq lr nl lt lu lv in bi translated">您可能想知道为什么我们没有在前面的步骤中将应用程序代码复制到工作目录中。这是因为Docker为每一层创建了一个中间图像。并且为每个命令创建一个层。</p><p id="1b38" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">由于我们在前面的步骤中不需要应用程序代码，这将是一种空间浪费，如果我们在前面的步骤中复制整个代码，这个过程的效率会更低。</p><p id="1c73" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果你有兴趣了解更多。<a class="ae kz" href="https://bitjudo.com/blog/2014/03/13/building-efficient-dockerfiles-node-dot-js/" rel="noopener ugc nofollow" target="_blank">去这里</a></p><p id="59a6" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们现在就去拿密码。</p><pre class="kk kl km kn gu nm nn oh oi aw oj bi"><span id="78f2" class="mo mp iu nn b gz ok ol l nu nv">COPY . .</span></pre><p id="4adf" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在让我们公开内部应用程序端口。因为默认情况下，出于安全原因，Docker映像不会暴露任何端口。</p><pre class="kk kl km kn gu nm nn oh oi aw oj bi"><span id="2718" class="mo mp iu nn b gz ok ol l nu nv">EXPOSE 3000</span></pre><h1 id="7b2d" class="nw mp iu bd mq nx ny nz mt oa ob oc mw ka od kb mz kd oe ke nc kg of kh nf og bi translated">运行应用程序</h1><p id="a9af" class="pw-post-body-paragraph la lb iu lc b ld nh jv lf lg ni jy li lj nj ll lm ln nk lp lq lr nl lt lu lv in bi translated">现在我们有了工作目录中的所有代码。现在让我们构建我们的应用程序。</p><pre class="kk kl km kn gu nm nn oh oi aw oj bi"><span id="8c5b" class="mo mp iu nn b gz ok ol l nu nv">RUN npm build</span></pre><p id="deff" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在我们将定义运行服务器的命令。</p><p id="14ae" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">当我们在dist文件夹(在tsconfig.json文件中定义)中构建包时，我们必须运行构建的映像。</p><pre class="kk kl km kn gu nm nn oh oi aw oj bi"><span id="664d" class="mo mp iu nn b gz ok ol l nu nv">CMD [ "node", "dist/index.js" ]</span></pre><p id="2f87" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">请注意，我们没有使用<code class="fe om on oo nn b">npm start</code>来运行应用程序，因为使用Node运行会提高效率。其次，它会导致退出信号(如SIGTERM和SIGINT)被Node.js进程接收，而不是被npm接收。</p><h1 id="42b1" class="nw mp iu bd mq nx ny nz mt oa ob oc mw ka od kb mz kd oe ke nc kg of kh nf og bi translated">最终文档文件</h1><p id="ae41" class="pw-post-body-paragraph la lb iu lc b ld nh jv lf lg ni jy li lj nj ll lm ln nk lp lq lr nl lt lu lv in bi translated">现在，您的docker文件应该如下所示:</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="oq or l"/></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated">Dockerfile文件</figcaption></figure><h1 id="16eb" class="nw mp iu bd mq nx ny nz mt oa ob oc mw ka od kb mz kd oe ke nc kg of kh nf og bi translated">创建一个dockerignore文件</h1><p id="e237" class="pw-post-body-paragraph la lb iu lc b ld nh jv lf lg ni jy li lj nj ll lm ln nk lp lq lr nl lt lu lv in bi translated">我们可以通过避免将一些资源复制到应用程序中来进一步优化Docker映像。创建一个<code class="fe om on oo nn b">.dockerignore</code>文件，并将下面的代码粘贴到那里</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="oq or l"/></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated">dockerignore</figcaption></figure><h1 id="bac2" class="nw mp iu bd mq nx ny nz mt oa ob oc mw ka od kb mz kd oe ke nc kg of kh nf og bi translated">建立我们的形象</h1><p id="7449" class="pw-post-body-paragraph la lb iu lc b ld nh jv lf lg ni jy li lj nj ll lm ln nk lp lq lr nl lt lu lv in bi translated">让我们通过运行以下命令来构建我们的映像。</p><pre class="kk kl km kn gu nm nn oh oi aw oj bi"><span id="5ce6" class="mo mp iu nn b gz ok ol l nu nv">docker build . -t express-typescript-docker</span></pre><p id="644d" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">注意命令中的<code class="fe om on oo nn b">.</code>。这不是偶然的。此外，我们通过传递<code class="fe om on oo nn b">-t</code>选项来标记我们的应用程序</p><p id="5bf8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">您可以通过运行以下命令来查看构建的映像。</p><pre class="kk kl km kn gu nm nn oh oi aw oj bi"><span id="2ef2" class="mo mp iu nn b gz ok ol l nu nv">docker images</span></pre><p id="5757" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这会给我们这样的输出</p><pre class="kk kl km kn gu nm nn oh oi aw oj bi"><span id="74b3" class="mo mp iu nn b gz ok ol l nu nv">REPOSITORY                TAG      IMAGE ID     CREATED    SIZE<br/>express-typescript-docker latest  11b3fd2ab6d4 29 seconds  262MB</span></pre><h1 id="514d" class="nw mp iu bd mq nx ny nz mt oa ob oc mw ka od kb mz kd oe ke nc kg of kh nf og bi translated">运行我们的图像</h1><p id="cff1" class="pw-post-body-paragraph la lb iu lc b ld nh jv lf lg ni jy li lj nj ll lm ln nk lp lq lr nl lt lu lv in bi translated">让我们通过运行以下命令在容器中运行我们的图像。</p><pre class="kk kl km kn gu nm nn oh oi aw oj bi"><span id="ca12" class="mo mp iu nn b gz ok ol l nu nv">docker run -p 3000:3000 -d express-typescript-docker:latest</span></pre><p id="6ed8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">注意<code class="fe om on oo nn b">-p</code>选项，它将暴露的docker端口映射到我们的本地机器端口。在我们的docker文件中，我们公开了端口3000。我们将同一个端口映射到我们的机器上。</p><p id="8587" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果我们想在本地机器的端口4000上运行我们的应用程序，我们可以这样做。<code class="fe om on oo nn b">-p 4000:3000</code></p><p id="93aa" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe om on oo nn b">You can also pass environment variables into the container by passing `-e "NODE_ENV=production"` into the command.</code></p><h1 id="b1fb" class="nw mp iu bd mq nx ny nz mt oa ob oc mw ka od kb mz kd oe ke nc kg of kh nf og bi translated">查看运行中的容器。</h1><p id="02eb" class="pw-post-body-paragraph la lb iu lc b ld nh jv lf lg ni jy li lj nj ll lm ln nk lp lq lr nl lt lu lv in bi translated">运行以下命令。</p><pre class="kk kl km kn gu nm nn oh oi aw oj bi"><span id="ddbc" class="mo mp iu nn b gz ok ol l nu nv"><br/>docker ps</span></pre><p id="6b44" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这将为您提供以下输出</p><pre class="kk kl km kn gu nm nn oh oi aw oj bi"><span id="d747" class="mo mp iu nn b gz ok ol l nu nv">CONTAINER ID   IMAGE  COMMAND  CREATED STATUS PORTS   NAMES<br/>  <br/>9be24fc778bb   <br/>express-typescript-docker:latest   <br/>"docker-entrypoint.s…"   <br/>8 seconds ago   <br/>Up 7 seconds   <br/>0.0.0.0:3000-&gt;3000/tcp, <br/>8080/tcp   <br/>eager_bardeen</span></pre><h1 id="01aa" class="nw mp iu bd mq nx ny nz mt oa ob oc mw ka od kb mz kd oe ke nc kg of kh nf og bi translated">测试端点</h1><p id="664c" class="pw-post-body-paragraph la lb iu lc b ld nh jv lf lg ni jy li lj nj ll lm ln nk lp lq lr nl lt lu lv in bi translated">现在进入你的浏览器或者像Postman这样的HTTP客户端，点击下面的URL。</p><pre class="kk kl km kn gu nm nn oh oi aw oj bi"><span id="8889" class="mo mp iu nn b gz ok ol l nu nv"><a class="ae kz" href="http://localhost:3000" rel="noopener ugc nofollow" target="_blank">http://localhost:3000</a></span></pre><p id="80cb" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">看看结果</p><pre class="kk kl km kn gu nm nn oh oi aw oj bi"><span id="1975" class="mo mp iu nn b gz ok ol l nu nv">{ "message": "Hello World!" }</span></pre><p id="4b1c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">此外，您可以通过运行以下命令来查看容器内部的日志。从我们之前运行的命令<code class="fe om on oo nn b">docker ps</code>中获取容器id。</p><pre class="kk kl km kn gu nm nn oh oi aw oj bi"><span id="2630" class="mo mp iu nn b gz ok ol l nu nv">docker logs container_id</span><span id="814a" class="mo mp iu nn b gz op ol l nu nv">Connected successfully on port 3000<br/>{ message: 'Hello World'}</span></pre><h1 id="3925" class="nw mp iu bd mq nx ny nz mt oa ob oc mw ka od kb mz kd oe ke nc kg of kh nf og bi translated">停下集装箱。</h1><p id="1763" class="pw-post-body-paragraph la lb iu lc b ld nh jv lf lg ni jy li lj nj ll lm ln nk lp lq lr nl lt lu lv in bi translated">您可以通过运行以下命令来停止正在运行的容器。</p><pre class="kk kl km kn gu nm nn oh oi aw oj bi"><span id="3492" class="mo mp iu nn b gz ok ol l nu nv">docker stop container_id</span></pre><p id="fd1b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">并检查<code class="fe om on oo nn b">docker ps</code>以查看该命令是否成功。</p><h1 id="1dfa" class="nw mp iu bd mq nx ny nz mt oa ob oc mw ka od kb mz kd oe ke nc kg of kh nf og bi translated">使用Docker的开发环境</h1><p id="6f85" class="pw-post-body-paragraph la lb iu lc b ld nh jv lf lg ni jy li lj nj ll lm ln nk lp lq lr nl lt lu lv in bi translated">以上配置可用于生产。但是在开发过程中，每当我们更改代码时，我们都不能构建映像。我们需要一些开发设置来即时反映我们的代码更改，以解决这个问题。</p><p id="dea6" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">为此，我们可以创建一个单独的<code class="fe om on oo nn b">Dockerfile.dev</code>并添加以下配置</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="oq or l"/></div></figure><p id="94a4" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">让我们在根目录下创建一个<code class="fe om on oo nn b">docker-compose.yml</code>文件来实现这一点。并在那里添加以下配置</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="oq or l"/></div></figure><p id="bb28" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">注意我们指向<code class="fe om on oo nn b">Dockerfile.dev</code>来告诉docker-compose需要使用的文件。</p><p id="4661" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">它将创建一个名为express-typescript-docker的图像，并在开发模式下运行它。</p><p id="8ae4" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">我们可以运行以下命令来查看它的运行情况:</p><pre class="kk kl km kn gu nm nn oh oi aw oj bi"><span id="7580" class="mo mp iu nn b gz ok ol l nu nv">docker-compose up</span></pre><p id="7de0" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在，您可以尝试更改任何代码并点击保存。您的代码将自动更新！</p><p id="9e51" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">您可以通过按CTRL+C或运行以下命令来停止容器。</p><pre class="kk kl km kn gu nm nn oh oi aw oj bi"><span id="e8fd" class="mo mp iu nn b gz ok ol l nu nv">docker-compose down</span></pre><h1 id="f30e" class="nw mp iu bd mq nx ny nz mt oa ob oc mw ka od kb mz kd oe ke nc kg of kh nf og bi translated">在生产中使用Docker排版</h1><p id="1d77" class="pw-post-body-paragraph la lb iu lc b ld nh jv lf lg ni jy li lj nj ll lm ln nk lp lq lr nl lt lu lv in bi translated">我们在生产中也可以使用<code class="fe om on oo nn b"><strong class="lc iv">docker-compose</strong></code> <strong class="lc iv"> </strong>。为此，让我们创建一个单独的<code class="fe om on oo nn b"><strong class="lc iv">Dockerfile.prod</strong></code></p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="oq or l"/></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated">Dockerfile.prod</figcaption></figure><p id="3b08" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">注意，这里我们不像以前那样需要<code class="fe om on oo nn b">EXPOSE</code>和<code class="fe om on oo nn b">CMD</code>命令，因为docker-compose会处理这些。</p><p id="f59c" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在让我们创建一个<code class="fe om on oo nn b">docker-compose.prod.yml</code>文件。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="oq or l"/></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated"><code class="fe om on oo nn b">docker-compose.prod.yml</code></figcaption></figure><p id="7c47" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这将从<code class="fe om on oo nn b">Dockerfile.prod</code>获取配置，并从那里运行命令节点dist/index.js。其余配置将取自默认的<code class="fe om on oo nn b">docker-compose.yml</code>文件。</p><p id="f2b2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">要在生产中启动容器，让我们运行以下命令。</p><pre class="kk kl km kn gu nm nn oh oi aw oj bi"><span id="ecd8" class="mo mp iu nn b gz ok ol l nu nv">docker-compose -f docker-compose.yml -f docker-compose.prod.yml up -d</span></pre><p id="572f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">注意<code class="fe om on oo nn b">-f</code>标志，它告诉<code class="fe om on oo nn b">docker-compose</code>哪些文件用于配置。</p><p id="8256" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">您可以通过运行以下命令来验证容器是否正在运行。</p><pre class="kk kl km kn gu nm nn oh oi aw oj bi"><span id="6f68" class="mo mp iu nn b gz ok ol l nu nv">docker ps</span></pre><p id="e948" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">或者点击<a class="ae kz" href="http://localhost:3000/" rel="noopener ugc nofollow" target="_blank"> http://localhost:3000 </a></p><h1 id="669a" class="nw mp iu bd mq nx ny nz mt oa ob oc mw ka od kb mz kd oe ke nc kg of kh nf og bi translated">丰富</h1><p id="2f71" class="pw-post-body-paragraph la lb iu lc b ld nh jv lf lg ni jy li lj nj ll lm ln nk lp lq lr nl lt lu lv in bi translated">键入所有这些命令可能会很耗时，所以让我们在项目的根目录下创建一个Makefile文件来简化我们的工作！</p><pre class="kk kl km kn gu nm nn oh oi aw oj bi"><span id="5fdf" class="mo mp iu nn b gz ok ol l nu nv">up:<br/>    docker-compose up -d</span><span id="e043" class="mo mp iu nn b gz op ol l nu nv">up-prod:<br/>    docker-compose -f docker-compose.yml -f docker-compose.prod.yml</span><span id="d2e7" class="mo mp iu nn b gz op ol l nu nv">down:<br/>    docker-compose down</span></pre><p id="54e1" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">现在我们可以运行<code class="fe om on oo nn b">make up</code>或<code class="fe om on oo nn b">make up-prod</code>来运行容器。</p><p id="9bb5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">你可以在这里找到这篇文章的所有代码。</p><h2 id="321f" class="mo mp iu bd mq mr ms dn mt mu mv dp mw lj mx my mz ln na nb nc lr nd ne nf ng bi translated">更进一步</h2><p id="b563" class="pw-post-body-paragraph la lb iu lc b ld nh jv lf lg ni jy li lj nj ll lm ln nk lp lq lr nl lt lu lv in bi translated">我们可以利用docker-compose的强大功能，在本地开发工作流中使用数据库，从而将这个设置提升到下一个级别。更多信息请见下面的文章。</p><div class="lw lx gq gs ly lz"><a href="https://javascript.plainenglish.io/node-js-database-with-docker-for-local-development-285212c5162f" rel="noopener  ugc nofollow" target="_blank"><div class="ma ab fp"><div class="mb ab mc cl cj md"><h2 class="bd iv gz z fq me fs ft mf fv fx it bi translated">Node.js +带有Docker的数据库，用于本地开发</h2><div class="mg l"><h3 class="bd b gz z fq me fs ft mf fv fx dk translated">各种数据库的一站式解决方案。</h3></div><div class="mh l"><p class="bd b dl z fq me fs ft mf fv fx dk translated">javascript.plainenglish.io</p></div></div><div class="mi l"><div class="os l mk ml mm mi mn kt lz"/></div></div></a></div><h2 id="defe" class="mo mp iu bd mq mr ms dn mt mu mv dp mw lj mx my mz ln na nb nc lr nd ne nf ng bi translated">视频版本:</h2><p id="ecb7" class="pw-post-body-paragraph la lb iu lc b ld nh jv lf lg ni jy li lj nj ll lm ln nk lp lq lr nl lt lu lv in bi translated"><a class="ae kz" href="https://www.youtube.com/watch?v=9yCk2R3injE&amp;t=362s" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=9yCk2R3injE&amp;t = 362s</a><br/><a class="ae kz" href="https://www.youtube.com/watch?v=nawJwaPW1yI&amp;t=14s" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=nawJwaPW1yI&amp;t = 14s</a></p><pre class="kk kl km kn gu nm nn oh oi aw oj bi"><span id="bf62" class="mo mp iu nn b gz ok ol l nu nv"><strong class="nn iv">Want to Connect?</strong></span><span id="e216" class="mo mp iu nn b gz op ol l nu nv">You can reach out to me via <a class="ae kz" href="https://www.linkedin.com/in/56faisal/" rel="noopener ugc nofollow" target="_blank"><strong class="nn iv">LinkedIN</strong></a> or my <a class="ae kz" href="https://www.mohammadfaisal.dev/blog" rel="noopener ugc nofollow" target="_blank"><strong class="nn iv">Personal Website</strong></a></span></pre><h1 id="9571" class="nw mp iu bd mq nx ny nz mt oa ob oc mw ka od kb mz kd oe ke nc kg of kh nf og bi translated">资源</h1><ul class=""><li id="2d62" class="ot ou iu lc b ld nh lg ni lj ov ln ow lr ox lv oy oz pa pb bi translated"><a class="ae kz" href="https://github.com/nodejs/docker-node/blob/main/docs/BestPractices.md" rel="noopener ugc nofollow" target="_blank"> Docker Nodejs最佳实践</a></li><li id="c182" class="ot ou iu lc b ld pc lg pd lj pe ln pf lr pg lv oy oz pa pb bi translated"><a class="ae kz" href="https://nodejs.org/en/docs/guides/nodejs-docker-webapp/" rel="noopener ugc nofollow" target="_blank">建立Docker的官方节点文档</a></li></ul></div><div class="ab cl ph pi hy pj" role="separator"><span class="pk bw bk pl pm pn"/><span class="pk bw bk pl pm pn"/><span class="pk bw bk pl pm"/></div><div class="in io ip iq ir"><h2 id="a227" class="mo mp iu bd mq mr ms dn mt mu mv dp mw lj mx my mz ln na nb nc lr nd ne nf ng bi translated">阅读更多NodeJS文章</h2><div class="lw lx gq gs ly lz"><a href="https://javascript.plainenglish.io/error-handling-in-node-js-like-a-pro-ed210baa0600" rel="noopener  ugc nofollow" target="_blank"><div class="ma ab fp"><div class="mb ab mc cl cj md"><h2 class="bd iv gz z fq me fs ft mf fv fx it bi translated">像专家一样处理Node.js中的错误</h2><div class="mg l"><h3 class="bd b gz z fq me fs ft mf fv fx dk translated">你需要知道的一切。</h3></div><div class="mh l"><p class="bd b dl z fq me fs ft mf fv fx dk translated">javascript.plainenglish.io</p></div></div><div class="mi l"><div class="po l mk ml mm mi mn kt lz"/></div></div></a></div><div class="lw lx gq gs ly lz"><a href="https://javascript.plainenglish.io/node-js-logging-for-professionals-6be07c003e7f" rel="noopener  ugc nofollow" target="_blank"><div class="ma ab fp"><div class="mb ab mc cl cj md"><h2 class="bd iv gz z fq me fs ft mf fv fx it bi translated">专业人员的Node.js日志记录</h2><div class="mg l"><h3 class="bd b gz z fq me fs ft mf fv fx dk translated">发挥温斯顿和摩根的全部潜力</h3></div><div class="mh l"><p class="bd b dl z fq me fs ft mf fv fx dk translated">javascript.plainenglish.io</p></div></div><div class="mi l"><div class="pp l mk ml mm mi mn kt lz"/></div></div></a></div><div class="lw lx gq gs ly lz"><a href="https://blog.devgenius.io/how-to-handle-multiple-environments-in-nodejs-7391d2db2abe" rel="noopener  ugc nofollow" target="_blank"><div class="ma ab fp"><div class="mb ab mc cl cj md"><h2 class="bd iv gz z fq me fs ft mf fv fx it bi translated">如何在NodeJS中处理多种环境</h2><div class="mg l"><h3 class="bd b gz z fq me fs ft mf fv fx dk translated">如何建立一个专业的节点工程</h3></div><div class="mh l"><p class="bd b dl z fq me fs ft mf fv fx dk translated">blog.devgenius.io</p></div></div><div class="mi l"><div class="pq l mk ml mm mi mn kt lz"/></div></div></a></div></div><div class="ab cl ph pi hy pj" role="separator"><span class="pk bw bk pl pm pn"/><span class="pk bw bk pl pm pn"/><span class="pk bw bk pl pm"/></div><div class="in io ip iq ir"><h1 id="1b35" class="nw mp iu bd mq nx pr nz mt oa ps oc mw ka pt kb mz kd pu ke nc kg pv kh nf og bi translated">分级编码</h1><p id="2714" class="pw-post-body-paragraph la lb iu lc b ld nh jv lf lg ni jy li lj nj ll lm ln nk lp lq lr nl lt lu lv in bi translated">感谢您成为我们社区的一员！在你离开之前:</p><ul class=""><li id="d1a2" class="ot ou iu lc b ld le lg lh lj pw ln px lr py lv oy oz pa pb bi translated">👏为故事鼓掌，跟着作者走👉</li><li id="6fb6" class="ot ou iu lc b ld pc lg pd lj pe ln pf lr pg lv oy oz pa pb bi translated">📰查看<a class="ae kz" href="https://levelup.gitconnected.com/?utm_source=pub&amp;utm_medium=post" rel="noopener ugc nofollow" target="_blank">级编码出版物</a>中的更多内容</li><li id="e05a" class="ot ou iu lc b ld pc lg pd lj pe ln pf lr pg lv oy oz pa pb bi translated">🔔关注我们:<a class="ae kz" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">推特</a> | <a class="ae kz" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a> | <a class="ae kz" href="https://newsletter.levelup.dev" rel="noopener ugc nofollow" target="_blank">时事通讯</a></li></ul><p id="cfaf" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">🚀👉<a class="ae kz" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="lc iv">加入升级人才集体，找到一份惊艳的工作</strong> </a></p></div></div>    
</body>
</html>