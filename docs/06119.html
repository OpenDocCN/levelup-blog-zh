<html>
<head>
<title>One-step AWS Cognito User Pool with Lambda Triggers using Serverless Framework</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用无服务器框架的Lambda触发器的一步式AWS认知用户池</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/one-step-aws-cognito-user-pool-with-lambda-triggers-using-serverless-framework-d3bdf07b62c1?source=collection_archive---------2-----------------------#2020-10-28">https://levelup.gitconnected.com/one-step-aws-cognito-user-pool-with-lambda-triggers-using-serverless-framework-d3bdf07b62c1?source=collection_archive---------2-----------------------#2020-10-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/926d92aa87abdf7ac32d6f9f35a7952b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SETw-dujbXhuwVZ-GJZDdA.jpeg"/></div></div></figure><div class=""/><div class=""><h2 id="34ad" class="pw-subtitle-paragraph jy ja jb bd b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp dk translated">在一个无服务器堆栈中部署您的Cognito用户池和自定义触发器，并在此过程中更好地理解无服务器</h2></div><p id="d090" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">无服务器框架使您能够创建一个Cognito用户池，对其进行全面配置，并向其添加自定义lambda触发器，所有这些都在一个部署步骤中完成。</p><h1 id="010f" class="lm ln jb bd lo lp lq lr ls lt lu lv lw kh lx ki ly kk lz kl ma kn mb ko mc md bi translated">创建用户池</h1><p id="05d7" class="pw-post-body-paragraph kq kr jb ks b kt me kc kv kw mf kf ky kz mg lb lc ld mh lf lg lh mi lj lk ll ij bi translated">让我们首先在无服务器堆栈的<strong class="ks jc">资源</strong>部分设置一个简单的Cognito用户池:</p><figure class="mj mk ml mm gt is"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="b86a" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">Serverless允许您在堆栈的<strong class="ks jc"> Resources </strong>部分使用CloudFormation模板，因此我在我的Cognito pool配置中拥有由<a class="ae mp" href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-cognito-userpool.html" rel="noopener ugc nofollow" target="_blank"> CloudFormation </a>提供的所有控制。在这里，我创建了一个名为<code class="fe mq mr ms mt b">mikes-example-pool</code> <em class="mu">的新池，</em>通过设置<code class="fe mq mr ms mt b">UserNameAttributes</code>指定我希望用户使用电子邮件地址注册该池，并配置Cognito使用<code class="fe mq mr ms mt b">AutoVerifiedAttributes</code>自动启动这些电子邮件地址的验证过程。我已经给用户池起了一个逻辑资源名<code class="fe mq mr ms mt b">CognitoUserPoolMikesExamplePool</code>。记住这一点——它以后会变得很重要！</p><h1 id="1923" class="lm ln jb bd lo lp lq lr ls lt lu lv lw kh lx ki ly kk lz kl ma kn mb ko mc md bi translated">添加自定义Lambda触发器</h1><p id="56fe" class="pw-post-body-paragraph kq kr jb ks b kt me kc kv kw mf kf ky kz mg lb lc ld mh lf lg lh mi lj lk ll ij bi translated">接下来，我想在我的堆栈中添加一个定制的Cognito Lambda触发器。</p><p id="7f6c" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">为了实现这一点，我可以向我的无服务器文件的<strong class="ks jc"> Functions </strong>部分添加一个lambda函数，并用类型为<strong class="ks jc"> cognitoUserPool的事件来配置它。</strong></p><figure class="mj mk ml mm gt is"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="a435" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在这里，我创建了一个名为<code class="fe mq mr ms mt b">cognitoCustomMessageLambda</code> <em class="mu"> </em>的lambda函数，它将触发<code class="fe mq mr ms mt b">CustomMessage</code> Cognito触发器。无服务器支持AWS 提供的<a class="ae mp" href="https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-identity-pools-working-with-aws-lambda-triggers.html" rel="noopener ugc nofollow" target="_blank">以及这些</a>键<a class="ae mp" href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cognito-userpool-lambdaconfig.html" rel="noopener ugc nofollow" target="_blank">引用的所有自定义触发器类型</a><a class="ae mp" href="https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-identity-pools-working-with-aws-lambda-triggers.html" rel="noopener ugc nofollow" target="_blank">，目前包括:CustomMessage、CreateAuthChallenge、DefineAuthChallenge、VerifyAuthChallengeResponse、PostAuthentication、PostConfirmation、PreAuthentication、PreSignUp、PreTokenGeneration和UserMigration。</a></p><h1 id="616d" class="lm ln jb bd lo lp lq lr ls lt lu lv lw kh lx ki ly kk lz kl ma kn mb ko mc md bi translated">连接池和Lambda触发器</h1><p id="9072" class="pw-post-body-paragraph kq kr jb ks b kt me kc kv kw mf kf ky kz mg lb lc ld mh lf lg lh mi lj lk ll ij bi translated">当我将<strong class="ks jc"> cognitoUserPool </strong>事件添加到我的无服务器文件中的lambda时，框架的默认行为是创建一个新的cognitoUserPool并将其添加到由无服务器生成的CloudFormation模板中。这个新池就是我们的自定义Lambda触发器所连接的。</p><p id="ca29" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">根据无服务器<a class="ae mp" href="https://www.serverless.com/framework/docs/providers/aws/guide/resources/#aws-cloudformation-resource-reference" rel="noopener ugc nofollow" target="_blank">命名约定</a>，当这个新池被添加到我们生成的CloudFormation模板中时，它将被赋予一个形式为<code class="fe mq mr ms mt b">CognitoUserPool<strong class="ks jc">{normalizedPoolId}</strong></code>的逻辑资源名称，其中{normalizedPoolId}是我在我的<strong class="ks jc"> cognitoUserPool </strong>事件中作为<code class="fe mq mr ms mt b">pool</code>的值提供的名称。在上面的例子中，我的池的normalizedPoolId是<code class="fe mq mr ms mt b">MikesExamplePool</code>。</p><p id="8851" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">因此，缺省情况下，Serverless将尝试向它生成的CloudFormation堆栈添加一个名为<code class="fe mq mr ms mt b">CognitoUserPoolMikesExamplePool</code>的新Cognito池，并将我的lambda触发器连接到这个池。</p><p id="383f" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">然而，这并不是我想要的；我希望我的触发器连接到我在<strong class="ks jc"> Resources中声明的池。</strong>为了实现这一点，我必须利用无服务器给你的能力<a class="ae mp" href="https://www.serverless.com/framework/docs/providers/aws/guide/resources/#override-aws-cloudformation-resource" rel="noopener ugc nofollow" target="_blank">覆盖云信息资源</a>。我可以通过在我的<strong class="ks jc"> Resources </strong>部分中声明我的Cognito池来做到这一点，使用无服务器想要为它将要生成的池使用的逻辑资源名；在这个例子中，这个名字将会是<code class="fe mq mr ms mt b">CognitoUserPoolMikesExamplePool</code> <strong class="ks jc">。</strong>使用这个逻辑资源名称会导致Serverless用我在<strong class="ks jc"> Resources中声明的模板覆盖它为该资源默认生成的CloudFormation。</strong>这确保了通过将<strong class="ks jc"> cognitoUserPool </strong>事件添加到我的lambda中而生成的默认池将被我已经声明的池所替换，并且我的触发器将被连接到这个池。</p><p id="74e6" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这允许我创建一个用户池，并在一个无服务器部署中向其中添加一个定制的lambda触发器。</p><h1 id="b9f8" class="lm ln jb bd lo lp lq lr ls lt lu lv lw kh lx ki ly kk lz kl ma kn mb ko mc md bi translated">解决纷争</h1><p id="39b7" class="pw-post-body-paragraph kq kr jb ks b kt me kc kv kw mf kf ky kz mg lb lc ld mh lf lg lh mi lj lk ll ij bi translated">似乎无法正确配置您的池和触发器？要更清楚地了解Serverless实际在做什么，一个好方法是查看框架为您生成和部署的CloudFormation模板。您可以在运行<code class="fe mq mr ms mt b">serverless package</code>或<code class="fe mq mr ms mt b">serverless deploy</code>时生成的<code class="fe mq mr ms mt b">.serverless</code>目录下的<code class="fe mq mr ms mt b">cloudformation-template-update-stack.json</code>文件中找到这个文件。</p><h1 id="001a" class="lm ln jb bd lo lp lq lr ls lt lu lv lw kh lx ki ly kk lz kl ma kn mb ko mc md bi translated">资源</h1><p id="f5f5" class="pw-post-body-paragraph kq kr jb ks b kt me kc kv kw mf kf ky kz mg lb lc ld mh lf lg lh mi lj lk ll ij bi translated">无服务器<a class="ae mp" href="https://www.serverless.com/framework/docs/providers/aws/guide/resources/#override-aws-cloudformation-resource" rel="noopener ugc nofollow" target="_blank">文档</a>描述了通用云构造覆盖方法<br/>无服务器<a class="ae mp" href="https://www.serverless.com/framework/docs/providers/aws/events/cognito-user-pool/#overriding-a-generated-user-pool" rel="noopener ugc nofollow" target="_blank">文档</a>描述了这种方法与cognitoUserPool lambda事件的使用<br/>无服务器<a class="ae mp" href="https://www.serverless.com/framework/docs/providers/aws/guide/resources/#aws-cloudformation-resource-reference" rel="noopener ugc nofollow" target="_blank">命名约定</a>用于云构造覆盖<br/>更多<a class="ae mp" href="https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-identity-pools-working-with-aws-lambda-triggers.html" rel="noopener ugc nofollow" target="_blank">关于实现特定Cognito lambda触发器的信息</a></p></div></div>    
</body>
</html>