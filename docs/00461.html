<html>
<head>
<title>Communicating sequential processes(CSP) for Go developer in a nutshell.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">简而言之，Go开发者的沟通顺序流程(CSP)。</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/communicating-sequential-processes-csp-for-go-developer-in-a-nutshell-866795eb879d?source=collection_archive---------1-----------------------#2019-03-14">https://levelup.gitconnected.com/communicating-sequential-processes-csp-for-go-developer-in-a-nutshell-866795eb879d?source=collection_archive---------1-----------------------#2019-03-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="65bb" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">简单扼要地介绍CSP、它的术语以及它的相似之处。</h2></div><p id="a8ad" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">通信顺序进程(CSP) </strong>简而言之，每当讨论Go并发以及它如何成为并发编程的灵丹妙药时，我们都会听到这个词。当我第一次听到这个术语时，我开始想，</p><blockquote class="lb lc ld"><p id="ce6e" class="kf kg le kh b ki kj jr kk kl km ju kn lf kp kq kr lg kt ku kv lh kx ky kz la ij bi translated">CSP是某种使编写并发代码如此简单的新技术或算法吗？</p></blockquote><p id="b44f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在阅读了CSP最初的<a class="ae li" href="https://dl.acm.org/citation.cfm?doid=359576.359585" rel="noopener ugc nofollow" target="_blank">论文</a>之后，结果并没有什么奇特之处——一个简单的概念(后来被公式化为<a class="ae li" href="https://en.wikipedia.org/wiki/Process_calculus" rel="noopener ugc nofollow" target="_blank">过程演算</a>来推理程序的正确性)通过两种编程原语解决并发性。</p><ol class=""><li id="fa76" class="lj lk iq kh b ki kj kl km ko ll ks lm kw ln la lo lp lq lr bi translated"><strong class="kh ir">输入。</strong></li><li id="4876" class="lj lk iq kh b ki ls kl lt ko lu ks lv kw lw la lo lp lq lr bi translated"><strong class="kh ir">输出。</strong></li></ol><p id="dfa1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本文将术语<em class="le">流程</em>缩写为任何需要输入才能运行并产生输出的独立逻辑。(你可以把这想象成<code class="fe lx ly lz ma b">Goroutine</code>)</p><figure class="mc md me mf gt mg gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/957e0e09ade466afd500a34165c441f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1038/format:webp/1*kXxztqXfD-HWG2v3aSSyeg.png"/></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated">CSP流程</figcaption></figure><p id="c4db" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">允许多个并发进程通过同步它们的I/O来彼此同步(<em class="le">通过指定的源和目的地</em>进行通信)。本文用命令对此进行了描述。</strong></p><blockquote class="mn"><p id="2595" class="mo mp iq bd mq mr ms mt mu mv mw la dk translated"><code class="fe lx ly lz ma b">!</code>用于向流程发送输入</p></blockquote><blockquote class="lb lc ld"><p id="807c" class="kf kg le kh b ki mx jr kk kl my ju kn lf mz kq kr lg na ku kv lh nb ky kz la ij bi translated"><code class="fe lx ly lz ma b">lineprinter!lineimage</code></p><p id="3520" class="kf kg le kh b ki kj jr kk kl km ju kn lf kp kq kr lg kt ku kv lh kx ky kz la ij bi translated">向<code class="fe lx ly lz ma b">lineprinter</code>发送<code class="fe lx ly lz ma b">lineimage</code>的值进行打印。</p></blockquote><blockquote class="mn"><p id="f181" class="mo mp iq bd mq mr nc nd ne nf ng la dk translated"><code class="fe lx ly lz ma b">?</code>用于读取过程的输出</p></blockquote><blockquote class="lb lc ld"><p id="2930" class="kf kg le kh b ki mx jr kk kl my ju kn lf mz kq kr lg na ku kv lh nb ky kz la ij bi translated"><code class="fe lx ly lz ma b">cardreader?cardimage</code></p><p id="e6ed" class="kf kg le kh b ki kj jr kk kl km ju kn lf kp kq kr lg kt ku kv lh kx ky kz la ij bi translated">从<code class="fe lx ly lz ma b">cardreader</code>读取一张卡片，并将其值(一个字符数组)赋给变量<code class="fe lx ly lz ma b">cardimage</code>。</p></blockquote><p id="8408" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">CSP描述的主要概念是同步和<a class="ae li" href="https://en.wikipedia.org/wiki/Guarded_Command_Language" rel="noopener ugc nofollow" target="_blank">保护命令</a>。</p><h2 id="9c9f" class="nh ni iq bd nj nk nl dn nm nn no dp np ko nq nr ns ks nt nu nv kw nw nx ny nz bi translated"><strong class="ak">同步</strong></h2><figure class="mc md me mf gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="ob oc di od bf oe"><div class="gh gi oa"><img src="../Images/c16c1d71285e00e98f4b6bfc7ecb3e16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o1kr3Y49GZjcyKAT2nEGJg.png"/></div></div><figcaption class="mj mk gj gh gi ml mm bd b be z dk translated">在CSP下通信的两个进程(同步的例子)。</figcaption></figure><p id="c138" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上述同步的例子中，</p><p id="4f26" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">1.过程<strong class="kh ir"> P1 </strong>通过输出命令(！)来处理<strong class="kh ir"> P2 </strong>。<br/> 2。过程<strong class="kh ir"> P2 </strong>通过输入命令从过程<strong class="kh ir"> P2 </strong>输入值(？)并赋给“x”。</p><h2 id="bb39" class="nh ni iq bd nj nk nl dn nm nn no dp np ko nq nr ns ks nt nu nv kw nw nx ny nz bi translated">保护命令→</h2><p id="7ea9" class="pw-post-body-paragraph kf kg iq kh b ki of jr kk kl og ju kn ko oh kq kr ks oi ku kv kw oj ky kz la ij bi translated">我们来看看维基百科上对它的定义。</p><p id="3eb2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">保护命令是G → S形式的<a class="ae li" href="https://en.wikipedia.org/wiki/Statement_(programming)" rel="noopener ugc nofollow" target="_blank">语句</a>，其中</p><ul class=""><li id="b00e" class="lj lk iq kh b ki kj kl km ko ll ks lm kw ln la ok lp lq lr bi translated">g是一个<a class="ae li" href="https://en.wikipedia.org/wiki/Proposition" rel="noopener ugc nofollow" target="_blank">命题</a>，叫做警卫</li><li id="293a" class="lj lk iq kh b ki ls kl lt ko lu ks lv kw lw la ok lp lq lr bi translated">s是一个陈述</li></ul><p id="6fd1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以简单地把左手(G)边作为条件，或者把<em class="le">守护</em>为右手(S)边。</p><p id="0963" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">结合保护命令和I/O命令，CSP论文举了一个例子如下。</p><blockquote class="lb lc ld"><p id="93f8" class="kf kg le kh b ki kj jr kk kl km ju kn lf kp kq kr lg kt ku kv lh kx ky kz la ij bi translated"><code class="fe lx ly lz ma b">*[c:character; west?c → east!c]</code></p><p id="1a3a" class="kf kg le kh b ki kj jr kk kl km ju kn lf kp kq kr lg kt ku kv lh kx ky kz la ij bi translated">读取<code class="fe lx ly lz ma b">west</code>输出的所有字符，并逐个输出到<code class="fe lx ly lz ma b">east</code>。当过程<code class="fe lx ly lz ma b">west</code>终止时，重复终止。</p></blockquote><p id="72de" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有没有发现和Go的频道有一些相似之处？显然，这是。虽然Go中的解决方案有点长，但是<strong class="kh ir">霍尔的I/O命令</strong>和<strong class="kh ir"> Dijkstra保护命令</strong>构成了Go通道的基石。</p><pre class="mc md me mf gt ol ma om on aw oo bi"><span id="bc05" class="nh ni iq ma b gy op oq l or os">ch &lt;- v    // Send v to channel ch.<br/>v := &lt;-ch  // Receive from ch, and<br/>           // assign value to v.</span></pre></div><div class="ab cl ot ou hu ov" role="separator"><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy"/></div><div class="ij ik il im in"><p id="5e31" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">看过下面这段话吗(<a class="ae li" href="https://blog.golang.org/share-memory-by-communicating" rel="noopener ugc nofollow" target="_blank">通过交流分享记忆</a>)</p><blockquote class="mn"><p id="e4e3" class="mo mp iq bd mq mr ms mt mu mv mw la dk translated"><em class="pa">不通过共享内存进行交流；相反，通过交流来分享记忆。</em></p></blockquote><p id="e961" class="pw-post-body-paragraph kf kg iq kh b ki mx jr kk kl my ju kn ko mz kq kr ks na ku kv kw nb ky kz la ij bi translated">想知道为什么？</p><p id="5053" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">再看看CSP，告诉我你看到了什么。一个复杂的世界通过交流与独立行为的部分互动。</p></div><div class="ab cl ot ou hu ov" role="separator"><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy"/></div><div class="ij ik il im in"><p id="240c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">学到了什么？拍拍手👏来帮助别人找到这篇文章。</strong></p></div><div class="ab cl ot ou hu ov" role="separator"><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy oz"/><span class="ow bw bk ox oy"/></div><div class="ij ik il im in"><div class="mc md me mf gt pb"><a href="https://gitconnected.com/learn/golang" rel="noopener  ugc nofollow" target="_blank"><div class="pc ab fo"><div class="pd ab pe cl cj pf"><h2 class="bd ir gy z fp pg fr fs ph fu fw ip bi translated">学习围棋-最佳围棋教程(2019) | gitconnected</h2><div class="pi l"><h3 class="bd b gy z fp pg fr fs ph fu fw dk translated">23大围棋教程-免费学习围棋。课程由开发者提交和投票，使您能够找到…</h3></div><div class="pj l"><p class="bd b dl z fp pg fr fs ph fu fw dk translated">gitconnected.com</p></div></div><div class="pk l"><div class="pl l pm pn po pk pp mh pb"/></div></div></a></div></div></div>    
</body>
</html>