<html>
<head>
<title>Working with schemas in a schemaless-ish world</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在无模式的世界中使用模式</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/working-with-schemas-in-a-schemaless-ish-world-d8e878d2ed94?source=collection_archive---------16-----------------------#2020-04-21">https://levelup.gitconnected.com/working-with-schemas-in-a-schemaless-ish-world-d8e878d2ed94?source=collection_archive---------16-----------------------#2020-04-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/661114438335a96f51fccf2eaaa51271.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*03dce1GaHPOVqfLntwAWmw.jpeg"/></div></div></figure><p id="5333" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu"><em class="kz">TL；博士</em> </strong> <em class="kz">:我写了一个JS库，当在不同的JSON结构之间转换和处理未记录的或不可靠的模式时，它让生活变得更容易。查看我的</em> <strong class="kd iu"> <em class="kz"> </em> </strong> <em class="kz">公司</em><strong class="kd iu"><em class="kz"/></strong><a class="ae la" href="https://github.com/intelligogroup/object-to-schema-mapper" rel="noopener ugc nofollow" target="_blank"><strong class="kd iu"><em class="kz">github</em></strong></a><strong class="kd iu"><em class="kz">。</em> </strong></p></div><div class="ab cl lb lc hx ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="im in io ip iq"><p id="ba62" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Web开发人员经常需要使用外部API。有时这些API没有很好的文档记录，而其他API则根据不同的请求输入以不断变化的结构来响应。</p><p id="5187" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当我们——后端开发人员——创建满足我们内部需求的客户端应用程序时，我们可以完全控制我们使用的模式，但是当我们走出去时，我们会遇到各种各样的野兽。</p><p id="b1d0" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我有幸从不同的API提供者那里收集数据，只是为了处理它们并将其转换成一个内部模式。有时，甚至将额外的API作为源代码添加到生产代码中正在使用的已经活动的模式中。</p></div><div class="ab cl lb lc hx ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="im in io ip iq"><ul class=""><li id="55c6" class="li lj it kd b ke kf ki kj km lk kq ll ku lm ky ln lo lp lq bi translated">当<strong class="kd iu">不</strong>担心第三方API甚至懒得记录它们的模式时，怎么可能在你的终端使用最终模式呢？</li><li id="f72e" class="li lj it kd b ke lr ki ls km lt kq lu ku lv ky ln lo lp lq bi translated">我如何从一个模式和另一个模式之间的硬编码和复杂转换中解脱出来？</li><li id="8fba" class="li lj it kd b ke lr ki ls km lt kq lu ku lv ky ln lo lp lq bi translated">我可以快速测试我对第三方API模式的假设吗？从API响应到我们内部模式的当前转换是否遗漏了什么？</li></ul></div><div class="ab cl lb lc hx ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="im in io ip iq"><p id="3c59" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这些不是理论问题。这是Intelligo-group(我工作的公司)的一个严重问题，我已经编写了一个JS库，试图解决上面提到的问题。</p><p id="ad28" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">本库分为三个主要部分:</strong></p><ol class=""><li id="8638" class="li lj it kd b ke kf ki kj km lk kq ll ku lm ky lw lo lp lq bi translated">根据第三方响应自动创建模式。</li><li id="26c0" class="li lj it kd b ke lr ki ls km lt kq lu ku lv ky lw lo lp lq bi translated">从一个JSON结构到另一个JSON结构的映射基于易于编写和人类可读的配置。</li><li id="92cd" class="li lj it kd b ke lr ki ls km lt kq lu ku lv ky lw lo lp lq bi translated">测试—从模式创建(1)中创建样本数据，并应用映射(2)来检查结果是否令人满意。</li></ol></div><div class="ab cl lb lc hx ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="im in io ip iq"><p id="3c76" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">以下部分是如何使用该库的示例:</strong></p><p id="ea16" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为了这个例子，让我们假设我是一个电影爱好者，我想收集关于一部电影的所有需要的信息。为此，我使用了一个假想网站的假想API，这是我搜索“复仇者联盟3：无限战争”得到的回应:</p><figure class="lx ly lz ma gt ju"><div class="bz fp l di"><div class="mb mc l"/></div><figcaption class="md me gj gh gi mf mg bd b be z dk translated">来自假想API的响应</figcaption></figure><p id="b346" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我想使用我的库并从响应中创建一个模式:</p><ol class=""><li id="8d37" class="li lj it kd b ke kf ki kj km lk kq ll ku lm ky lw lo lp lq bi translated">让我们安装库:<code class="fe mh mi mj mk b">npm i @intelligo.ai/object-to-schema</code></li></ol><p id="d50d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">2.并调用模式创建者:</p><pre class="lx ly lz ma gt ml mk mm mn aw mo bi"><span id="c79d" class="mp mq it mk b gy mr ms l mt mu">import response from './response.json';<br/>import { mapObjectToSchema } from '@intelligo.ai/object-to-schema';</span><span id="3e3e" class="mp mq it mk b gy mv ms l mt mu">const schema = mapObjectToSchema(response);<br/>console.log(JSON.stringify(schema, null, 2));</span></pre><p id="c399" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们将得到的输出是:</p><figure class="lx ly lz ma gt ju"><div class="bz fp l di"><div class="mb mc l"/></div><figcaption class="md me gj gh gi mf mg bd b be z dk translated">mapObjectToSchema函数的输出</figcaption></figure><p id="cdb7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里我们可以看到，对于每个键，库都分配了一个<code class="fe mh mi mj mk b">type</code>并增加了一个<code class="fe mh mi mj mk b">example</code>，这在后面会很有用。此外，我们可以看到函数是如何处理数组的——它遍历数组的所有元素，并将它们简化为一个模式元素。</p><p id="a636" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">注意:虽然这个例子涉及一个非常扁平的对象，但是这个库可以处理任何数量的嵌套。查看</strong> <a class="ae la" href="https://github.com/intelligogroup/object-to-schema-mapper" rel="noopener ugc nofollow" target="_blank"> <strong class="kd iu"> github资源库</strong> </a> <strong class="kd iu">了解更多信息。</strong></p><p id="66af" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">问题是，这个API不是我的主要数据来源，因为有几个来源，所以我有我正在使用的内部模式，看起来像这样:</p><figure class="lx ly lz ma gt ju"><div class="bz fp l di"><div class="mb mc l"/></div><figcaption class="md me gj gh gi mf mg bd b be z dk translated">内部模式</figcaption></figure><p id="e254" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">3.让我们为mapper函数编写一个配置文件，将响应转换为所需的模式。该配置被键入:</p><figure class="lx ly lz ma gt ju"><div class="bz fp l di"><div class="mb mc l"/></div><figcaption class="md me gj gh gi mf mg bd b be z dk translated">类型</figcaption></figure><p id="ec56" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们来分解一下配置:</p><p id="6547" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe mh mi mj mk b"><strong class="kd iu">source:</strong></code>你要变换的关键点的路径。</p><p id="d6ed" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe mh mi mj mk b"><strong class="kd iu">target</strong></code>:</p><ul class=""><li id="6762" class="li lj it kd b ke kf ki kj km lk kq ll ku lm ky ln lo lp lq bi translated"><code class="fe mh mi mj mk b"><strong class="kd iu">path</strong></code>:类似于<code class="fe mh mi mj mk b">source</code>参数，但是现在它表示映射器要创建的键的路径。</li><li id="9b8d" class="li lj it kd b ke lr ki ls km lt kq lu ku lv ky ln lo lp lq bi translated"><code class="fe mh mi mj mk b"><strong class="kd iu">defaultValue</strong></code>:如果源对象中没有值，将使用默认值。</li><li id="4ccf" class="li lj it kd b ke lr ki ls km lt kq lu ku lv ky ln lo lp lq bi translated"><code class="fe mh mi mj mk b"><strong class="kd iu">conditionalValue</strong></code> : <code class="fe mh mi mj mk b">targetPathCondition</code> <strong class="kd iu"> </strong>是目标对象中的路径，将检查它是否有值。如果该值存在，<code class="fe mh mi mj mk b">value</code>将被插入到指定的<code class="fe mh mi mj mk b"><strong class="kd iu">path</strong></code>中。</li><li id="1571" class="li lj it kd b ke lr ki ls km lt kq lu ku lv ky ln lo lp lq bi translated"><code class="fe mh mi mj mk b"><strong class="kd iu">priority</strong></code>:您可以将多个源映射到同一个目标路径。通过使用<code class="fe mh mi mj mk b"><strong class="kd iu">priority</strong></code> <strong class="kd iu"> </strong>来控制当多个映射从源对象中检索数据时使用什么数据。</li><li id="9ef8" class="li lj it kd b ke lr ki ls km lt kq lu ku lv ky ln lo lp lq bi translated"><code class="fe mh mi mj mk b"><strong class="kd iu">predefinedTransformations</strong></code>:允许您使用定义的函数以简单的方式转换数据。目前已有的函数:“toUpperCase”、“toLowerCase”、“titleCase”、“toDate”、“stringToArray”、“arrayToString”。arrayToString仅用于<code class="fe mh mi mj mk b">string[]</code>我们将在后面看到如何使用这些函数。</li></ul></div><div class="ab cl lb lc hx ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="im in io ip iq"><p id="4df3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">有了这些信息，我们可以在假想的API和内部模式之间构建自己的转换配置，并将函数<code class="fe mh mi mj mk b">mapObject</code>应用于API响应和转换。</p><p id="4dc3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd iu">注意:我添加了TypeScript类型，因为这样更容易验证配置。在我们公司，我们已经开发了一个web应用程序来轻松构建这样的配置。</strong></p><figure class="lx ly lz ma gt ju"><div class="bz fp l di"><div class="mb mc l"/></div><figcaption class="md me gj gh gi mf mg bd b be z dk translated">转换</figcaption></figure><ul class=""><li id="f2d6" class="li lj it kd b ke kf ki kj km lk kq ll ku lm ky ln lo lp lq bi translated">您可以看到，有些转换很简单，并不真的需要这样的库，例如<code class="fe mh mi mj mk b">title</code>转换只需要改变密钥。</li><li id="5ea8" class="li lj it kd b ke lr ki ls km lt kq lu ku lv ky ln lo lp lq bi translated">最强大的用例是面对嵌套在数组中的数据。最初写这个库是因为我在NPM的生态系统中找不到任何合适的工具来实现这样的壮举。我们可以在<code class="fe mh mi mj mk b">ratings</code>和<code class="fe mh mi mj mk b">date.release</code>转换中看到这个例子，其中库访问数组中的每个元素并将其映射到其专用的目标路径。请注意，当源路径嵌套在数组中时，像<code class="fe mh mi mj mk b">key[].key2[].key3[].key4</code>这意味着对象看起来像这样:</li></ul><pre class="lx ly lz ma gt ml mk mm mn aw mo bi"><span id="f4ca" class="mp mq it mk b gy mr ms l mt mu">{<br/>  "key": [<br/>    "key2": [<br/>      "key3": [</span><span id="be2b" class="mp mq it mk b gy mv ms l mt mu">        { "key4": &lt;&lt;primitive or object&gt;&gt; },<br/>        { "key4": &lt;&lt;primitive or object&gt;&gt; }, // and so on</span><span id="e396" class="mp mq it mk b gy mv ms l mt mu">      ]<br/>    ]<br/>  ]<br/>}</span></pre><p id="d032" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你想将<code class="fe mh mi mj mk b">key3</code>的每个元素映射到另一个<code class="fe mh mi mj mk b">target</code>路径，你必须寻址中间所有的嵌套数组。因此目标<strong class="kd iu">将有</strong>看起来像:<code class="fe mh mi mj mk b">otherKey[].otherKey2[].otherKey3[].otherKey4</code>。如果你考虑一下，你就会明白这些规则是必须遵守的，因为中间的每个数组都可以有多个元素，库需要迭代它们，所以目标结构必须保持不变。</p><ul class=""><li id="27c3" class="li lj it kd b ke kf ki kj km lk kq ll ku lm ky ln lo lp lq bi translated">您可以在<code class="fe mh mi mj mk b">isReleased</code>转换中看到条件值的例子。这里，我们没有<code class="fe mh mi mj mk b">source</code>路径，因为该值是通过查看其他映射值生成的。只有当映射的<code class="fe mh mi mj mk b">released</code>值存在时，我才将<code class="fe mh mi mj mk b">isReleased</code>值设置为<code class="fe mh mi mj mk b">true</code>。</li><li id="bda2" class="li lj it kd b ke lr ki ls km lt kq lu ku lv ky ln lo lp lq bi translated">需要知道的重要一点是，应用于对象的所有变换都是可选的。也就是说，如果一个源对象不满足一个或任何一个转换，就不会产生错误。这让我们能够处理可能返回部分信息的API。</li></ul><p id="7b3b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，让我们看看映射器函数的输出:</p><figure class="lx ly lz ma gt ju"><div class="bz fp l di"><div class="mb mc l"/></div><figcaption class="md me gj gh gi mf mg bd b be z dk translated">映射结果</figcaption></figure><p id="6e7b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如您所见，响应被成功地映射到我们的内部模式。</p><p id="e281" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">4.让我们回到模式创建后看到的那个<code class="fe mh mi mj mk b">example</code>键(2)。假设您已经从一个API的结果中提取了模式。现在，在创建/更新映射配置(转换)时，您所要做的就是检索使用这个库创建的API模式，并使用一个从模式中提取样本对象的函数。这样，您不必再次调用API来获取原始响应对象:</p><pre class="lx ly lz ma gt ml mk mm mn aw mo bi"><span id="c26f" class="mp mq it mk b gy mr ms l mt mu">import response from './response.json';<br/>import { mapObjectToSchema, extractExampleFromSchema, } from '@intelligo.ai/object-to-schema';</span><span id="8bfa" class="mp mq it mk b gy mv ms l mt mu">const schema = mapObjectToSchema(response); // or retrieve from DB<br/>const almostOriginalObject = extractExampleFromSchema(schema);</span><span id="8662" class="mp mq it mk b gy mv ms l mt mu">console.log(JSON.stringify(almostOriginalObject, null, 2));</span></pre><p id="a6d8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您可以看到输出:</p><figure class="lx ly lz ma gt ju"><div class="bz fp l di"><div class="mb mc l"/></div><figcaption class="md me gj gh gi mf mg bd b be z dk translated">反向提取伪响应</figcaption></figure><p id="bfe8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您仔细观察，您可以看到原始响应和反向提取的响应之间的差异。数组被简化为单元素数组。这些单元素数组包含多元素原始数组中所有可能的键。</p><p id="912d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">现在，您可以测试您在这个伪响应对象上的映射，并查看您的配置是否正确。</p><p id="e8a9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">5.使用这个库，您可以做更多的事情。例如，我们在<a class="ae la" href="https://www.linkedin.com/company/intelligo-group/" rel="noopener ugc nofollow" target="_blank"> Intelligo-Group </a>创建了一个端点来更新特定API的模式，我们实际上获取了数百到数千个保存在我们系统中的原始响应，并通过模式创建器函数将它们传送出去，该函数实际上可以接受两个参数。这是函数签名:</p><pre class="lx ly lz ma gt ml mk mm mn aw mo bi"><span id="6433" class="mp mq it mk b gy mr ms l mt mu">function mapObjectToSchema(obj: SomeObj, schema: SomeObj = {}): SomeObj</span></pre><p id="34b8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">第二个参数是一个已经存在的模式，它将被以第一个参数的形式接收的新的响应对象丰富。</p></div><div class="ab cl lb lc hx ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="im in io ip iq"><p id="6b2e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">此外，我们还创建了一个UI接口web-app(目前还不是一个开源应用程序),以便轻松地在响应模式和我们的内部模式之间进行映射。它所做的只是以上面提到的<code class="fe mh mi mj mk b">Transform[]</code>的格式输出配置。</p></div><div class="ab cl lb lc hx ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="im in io ip iq"><p id="28eb" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="kz">感谢阅读，我希望你会像我们在</em><a class="ae la" href="https://www.linkedin.com/company/intelligo-group/" rel="noopener ugc nofollow" target="_blank"><em class="kz">Intelligo-Group</em></a><em class="kz">一样喜欢这个图书馆。</em></p><p id="995d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="kz">NPM:</em><a class="ae la" href="https://www.npmjs.com/package/@intelligo.ai/object-to-schema" rel="noopener ugc nofollow" target="_blank">https://www . npmjs . com/package/@ intelligo . ai/object-to-schema</a></p><p id="76bd" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="kz">Github:</em><a class="ae la" href="https://github.com/intelligogroup/object-to-schema-mapper" rel="noopener ugc nofollow" target="_blank">https://github.com/intelligogroup/object-to-schema-mapper</a></p></div></div>    
</body>
</html>