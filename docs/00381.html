<html>
<head>
<title>Python Optimizations — Interning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python优化—实习</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/python-optimizations-216205001b83?source=collection_archive---------5-----------------------#2019-01-29">https://levelup.gitconnected.com/python-optimizations-216205001b83?source=collection_archive---------5-----------------------#2019-01-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/a4b0ff6619ae82205110251476a7e02d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UE6ApXjkjhViVDHHbjWavg.jpeg"/></div></div></figure></div><div class="ab cl kb kc hx kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="im in io ip iq"><p id="2e1d" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">你听说过Python中实习的概念吗？</p><p id="4fa6" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">实习是Python优化程序使用的内存的方式，通过引用与先前创建的变量具有相同数据的<em class="lg">数字</em>(有一些例外)<em class="lg"> </em>或<em class="lg">字符串</em>变量的内存中的相同空间。我们稍后会更深入地探讨。</p><h2 id="2554" class="lh li it bd lj lk ll dn lm ln lo dp lp kt lq lr ls kx lt lu lv lb lw lx ly lz bi translated">变量</h2><p id="7be0" class="pw-post-body-paragraph ki kj it kk b kl ma kn ko kp mb kr ks kt mc kv kw kx md kz la lb me ld le lf im bi translated">在我们开始深入探讨实习之前，我想先回顾一下什么是变量。</p><p id="4e75" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">变量只是一个指针，指向内存中存储某个对象的空间。例如，如果你声明一个变量并给它赋值一个整数，那么这个变量就只是一个指针，指向内存中保存这个整数的空间。</p><p id="dd29" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">当你声明一个变量<code class="fe mf mg mh mi b">x = 5</code>时，它实际上并不意味着<code class="fe mf mg mh mi b">x</code>就是字面上的<code class="fe mf mg mh mi b">5</code>，它所发生的是<code class="fe mf mg mh mi b">x</code>的值是某个存储数字<code class="fe mf mg mh mi b">5</code>的地址。</p><p id="437b" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">如果您编写以下代码:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="0008" class="lh li it mi b gy mr ms l mt mu">x, y = 5, 500</span><span id="9921" class="lh li it mi b gy mv ms l mt mu"><em class="lg"># hex(id(x)) - returns the memory address where the variable is pointing to in hexadecimal</em></span><span id="05b0" class="lh li it mi b gy mv ms l mt mu">print(<strong class="mi iu">"The id for x is: {}"</strong>.format(hex(id(x))))<br/>print(<strong class="mi iu">"The id for y is: {}"</strong>.format(hex(id(y))))</span></pre><p id="b564" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">在我的情况下，它打印:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="92e1" class="lh li it mi b gy mr ms l mt mu">The id for x is: 0x106d7d060<br/>The id for y is: 0x105897f90</span></pre><p id="eff4" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">如果你编译上面的代码，你会注意到变量<code class="fe mf mg mh mi b">x</code>在你的计算机中有相同的地址，但是变量<code class="fe mf mg mh mi b">y</code>没有。我将在下一节解释为什么会发生这种情况。</p><p id="13cd" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">现在我们知道了变量是指向内存地址的指针，我们可以更深入地了解实习以及Python如何处理它。</p><h2 id="bb7d" class="lh li it bd lj lk ll dn lm ln lo dp lp kt lq lr ls kx lt lu lv lb lw lx ly lz bi translated">整数内部化</h2><p id="bbdc" class="pw-post-body-paragraph ki kj it kk b kl ma kn ko kp mb kr ks kt mc kv kw kx md kz la lb me ld le lf im bi translated">基本上Python对<em class="lg">整数</em>所做的就是自动将最常见的<em class="lg">整数</em>保存在内存中，那些<em class="lg">整数</em>在<code class="fe mf mg mh mi b">[-5, 256]</code>之间。每当你声明一个在这个范围内的变量时，Python就会指向内存中预分配的空间，例如，如果你有这样的代码:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="846d" class="lh li it mi b gy mr ms l mt mu">a = 5<br/><br/>b = 5<br/><br/>c = a<br/><br/>d = b<br/><br/>print(<strong class="mi iu">"The id for a is: {}"</strong>.format(hex(id(a))))<br/>print(<strong class="mi iu">"The id for b is: {}"</strong>.format(hex(id(b))))<br/>print(<strong class="mi iu">"The id for c is: {}"</strong>.format(hex(id(c))))<br/>print(<strong class="mi iu">"The id for d is: {}"</strong>.format(hex(id(d))))</span></pre><p id="cf98" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">输出将是这样的:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="c603" class="lh li it mi b gy mr ms l mt mu">The id for a is: 0x105e13060<br/>The id for b is: 0x105e13060<br/>The id for c is: 0x105e13060<br/>The id for d is: 0x105e13060</span></pre><p id="4c6f" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">如您所见，所有4个变量都指向同一个地址，但如果您像这样更改其中一个变量的值，会发生什么情况:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="71c9" class="lh li it mi b gy mr ms l mt mu">a = 5<br/><br/>b = a<br/><br/>print(<strong class="mi iu">"The id for a is: {}"</strong>.format(hex(id(a))))<br/>print(<strong class="mi iu">"The id for b is: {}"</strong>.format(hex(id(b))))</span><span id="cf01" class="lh li it mi b gy mv ms l mt mu">b = 340</span><span id="3b5e" class="lh li it mi b gy mv ms l mt mu">print(<strong class="mi iu">"The id for b is: {}"</strong>.format(hex(id(b))))</span></pre><p id="f7a9" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">那么它将首先打印</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="9a54" class="lh li it mi b gy mr ms l mt mu">The id for a is: 0x105e13060<br/>The id for b is: 0x105e13060</span></pre><p id="de1a" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">然后它会在内存中分配空间来存储那个<code class="fe mf mg mh mi b">340</code>，并让变量指向那个地址。在我的例子中，输出如下:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="1736" class="lh li it mi b gy mr ms l mt mu">The id for b is: 0x105525fd0</span></pre><p id="530f" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">如果我们有另一个具有相同值<code class="fe mf mg mh mi b">340</code>的变量，那么Python会让这个新变量指向相同的地址，以重用内存中的空间。</p><h2 id="4faf" class="lh li it bd lj lk ll dn lm ln lo dp lp kt lq lr ls kx lt lu lv lb lw lx ly lz bi translated">字符串实习</h2><p id="cfbe" class="pw-post-body-paragraph ki kj it kk b kl ma kn ko kp mb kr ks kt mc kv kw kx md kz la lb me ld le lf im bi translated"><em class="lg">字符串</em> <em class="lg">内定</em>和<em class="lg">整数</em> <em class="lg">内定</em>几乎一样。Python所做的是，每次声明一个新变量时，如果该字符串是与前一个完全相同的<em class="lg">字符串</em>，那么它会将之前创建的<em class="lg">字符串</em>的地址分配给新变量。</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="3442" class="lh li it mi b gy mr ms l mt mu">a = <strong class="mi iu">'hello_world'<br/><br/></strong>b = <strong class="mi iu">'hello_world'<br/><br/></strong>c = <strong class="mi iu">'Hello_world'<br/><br/></strong>d = <strong class="mi iu">'hello world this is a long long string that python will intern to make the app work faster'<br/><br/></strong>e = <strong class="mi iu">'hello world this is a long long string that python will intern to make the app work faster'<br/><br/></strong>print(<strong class="mi iu">"The id for a is: {}"</strong>.format(hex(id(a))))<br/>print(<strong class="mi iu">"The id for b is: {}"</strong>.format(hex(id(b))))<br/>print(<strong class="mi iu">"The id for c is: {}"</strong>.format(hex(id(c))))<br/>print(<strong class="mi iu">"The id for d is: {}"</strong>.format(hex(id(d))))<br/>print(<strong class="mi iu">"The id for e is: {}"</strong>.format(hex(id(e))))</span></pre><p id="c644" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">在我的例子中，这产生了以下输出:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="ce7b" class="lh li it mi b gy mr ms l mt mu">The id for a is: 0x107702930<br/>The id for b is: 0x107702930<br/>The id for c is: 0x1077029f0<br/>The id for d is: 0x10764f930<br/>The id for e is: 0x10764f930</span></pre><p id="04f5" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">如你所见，如果字符串完全匹配，内存地址将是相同的。</p><p id="9e51" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">使用<em class="lg">字符串</em>的一个优点是，当比较两个<em class="lg">字符串</em>而不是用<code class="fe mf mg mh mi b">==</code>操作符比较它们时，你可以使用关键字<code class="fe mf mg mh mi b">is</code>。不同之处在于，<code class="fe mf mg mh mi b">==</code>将逐个字符进行比较，如果第一个字符串的每个字符都与第二个<em class="lg">字符串</em>的字符相匹配，那么它将返回<code class="fe mf mg mh mi b">true</code>，但是使用<code class="fe mf mg mh mi b">is</code>关键字，它将只比较内存地址，这要快得多。也许在小文本中你甚至不会注意到差别，但是如果你必须处理一个非常大的文本，那么你会开始看到很大的差别。</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="083f" class="lh li it mi b gy mr ms l mt mu"><strong class="mi iu">import </strong>time<br/><br/><strong class="mi iu">def </strong>compare_strings():<br/>    d = <strong class="mi iu">'hello world this is a long long string that python will intern to make the code work faster'</strong>*10000<br/>    e = <strong class="mi iu">'hello world this is a long long string that python will intern to make the code work faster'</strong>*10000<br/>    <strong class="mi iu">for </strong>i <strong class="mi iu">in </strong>range(100000):<br/>        <strong class="mi iu">if </strong>d == e:<br/>            <strong class="mi iu">pass<br/><br/></strong>start = time.perf_counter()<br/>compare_strings()<br/>end = time.perf_counter()<br/>print(<strong class="mi iu">"Elapsed time {}"</strong>.format(end-start))</span></pre><p id="c462" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">在前面的代码中，我们使用<code class="fe mf mg mh mi b">==</code>比较两个字符串，在我的电脑中用了4.73秒，但在这种情况下，知道字符串是相同的，并且知道python会对它们进行整型，我们可以使用<code class="fe mf mg mh mi b">is</code>关键字进行比较，如下所示:</p><pre class="mj mk ml mm gt mn mi mo mp aw mq bi"><span id="0cbe" class="lh li it mi b gy mr ms l mt mu"><strong class="mi iu">import </strong>time<br/><br/><strong class="mi iu">def </strong>compare_strings():<br/>    d = <strong class="mi iu">'hello world this is a long long string'</strong>*10000<br/>    e = <strong class="mi iu">'hello world this is a long long string'</strong>*10000<br/>    <strong class="mi iu">for </strong>i <strong class="mi iu">in </strong>range(100000):<br/>        <strong class="mi iu">if </strong>d <strong class="mi iu">is</strong> e:<br/>            <strong class="mi iu">pass<br/><br/></strong>start = time.perf_counter()<br/>compare_strings()<br/>end = time.perf_counter()<br/>print(<strong class="mi iu">"Elapsed time {}"</strong>.format(end-start))</span></pre><p id="e8c0" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">在这种情况下，我的计算机上的运行时间只有0.004秒，所以在比较真正长的<em class="lg">字符串</em>时，这确实有很大的不同。</p><h2 id="c9e3" class="lh li it bd lj lk ll dn lm ln lo dp lp kt lq lr ls kx lt lu lv lb lw lx ly lz bi translated">结论</h2><p id="d33d" class="pw-post-body-paragraph ki kj it kk b kl ma kn ko kp mb kr ks kt mc kv kw kx md kz la lb me ld le lf im bi translated"><em class="lg">实习</em>是一种通过引用相同的内存地址来优化程序的方法。特别是<em class="lg">string</em><em class="lg">interning</em>非常有用，因为你可以通过改变一个简单的语句来优化你的代码。</p><p id="8a6c" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">字符串实习的一个应用是自然语言处理，其中你必须对单词和短语进行大量评估。</p></div><div class="ab cl kb kc hx kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="im in io ip iq"><p id="1c52" class="pw-post-body-paragraph ki kj it kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf im bi translated">如果你对Python优化感兴趣，你可以看看我写的关于<a class="ae mw" href="https://medium.com/@gmotzespina/python-optimizations-a822db1f6bf5" rel="noopener"> Python优化(窥视孔)</a>的文章。</p></div></div>    
</body>
</html>