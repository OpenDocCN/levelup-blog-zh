<html>
<head>
<title>What is blockchain and how it is tamper proof ?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是区块链，它是如何防篡改的？</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/what-is-blockchain-and-how-it-is-tamper-proof-f86744cb7787?source=collection_archive---------4-----------------------#2020-05-18">https://levelup.gitconnected.com/what-is-blockchain-and-how-it-is-tamper-proof-f86744cb7787?source=collection_archive---------4-----------------------#2020-05-18</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/f451c521af25395eaaa508d9d68de308.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rcGAzmctkNH7W4ao"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated"><a class="ae jg" href="https://unsplash.com/@jjying?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">摄</a>在<a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></figcaption></figure><div class=""/><div class=""><h2 id="ed4b" class="pw-subtitle-paragraph kg ji jj bd b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dk translated">了解比特币和其他加密货币背后的技术</h2></div><p id="c3ce" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">每个人都还在试图理解加密货币以及它的未来。但是加密货币背后的技术非常有前途。加密货币最重要的组成部分之一是一个全球分类账，它基于区块链维护所有交易的记录。</p><p id="5cc1" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要理解区块链，我们必须首先理解几个基本概念</p><ul class=""><li id="4a1a" class="lu lv jj la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">混杂</li><li id="3a39" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">两颗北极指极星</li><li id="6a25" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">哈希指针</li><li id="ee8a" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">链表</li></ul><h2 id="ee14" class="mi mj jj bd mk ml mm dn mn mo mp dp mq lh mr ms mt ll mu mv mw lp mx my mz na bi translated">混杂</h2><p id="2666" class="pw-post-body-paragraph ky kz jj la b lb nb kk ld le nc kn lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">哈希是一个简单的函数，它对任何输入都给出固定长度的字符串输出，这样</p><ul class=""><li id="0baa" class="lu lv jj la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">我们无法从哈希中获得输入</li><li id="0915" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">利用我们可用的计算，我们不能找到两条具有相同散列的消息(实际上不能)</li></ul><p id="94fa" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一些常见的哈希示例有SHA256、SHA512、MD5等。</p><p id="1ef0" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">SHA256将给出一个256位的固定字符串，SHA512哈希将为512位长。</p><figure class="ng nh ni nj gt iv"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="2c58" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果我改变输入消息中的一个比特，散列将完全不同。</p><p id="c911" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因为没有两个输入会有相同的散列(至少理论上我们不会遇到这种情况)，我们可以使用散列来唯一地标识真正大的文件。下一次当我们看到这个文件时，我们只需将它的哈希与我们记忆的哈希进行比较，而无需存储和比较整个文件。</p><h2 id="6cbd" class="mi mj jj bd mk ml mm dn mn mo mp dp mq lh mr ms mt ll mu mv mw lp mx my mz na bi translated">指针</h2><p id="5793" class="pw-post-body-paragraph ky kz jj la b lb nb kk ld le nc kn lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">当我说<code class="fe nm nn no np b">P</code>是<code class="fe nm nn no np b">A</code>的指针时，这意味着<code class="fe nm nn no np b">P</code>存储了<code class="fe nm nn no np b">A</code>的位置。</p><p id="eade" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">假设我们有5个编号为1-5的盒子，我们将第3个盒子命名为<em class="nq"> A </em>。那么P，指针将存储A即3的地址。</p><figure class="ng nh ni nj gt iv gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/3e0cb36b15cf830c5454017a7d602851.png" data-original-src="https://miro.medium.com/v2/resize:fit:792/format:webp/1*Y0NsRCYzLl5Nm1247EBrhw.png"/></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">p指向A</figcaption></figure><p id="0a31" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当然，盒子P也会有一个数字地址，但这与此无关。</p><p id="593e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这些盒子是存储一些数据的内存位置，盒子号是内存中的地址，A，P是命名变量。</p><h2 id="9342" class="mi mj jj bd mk ml mm dn mn mo mp dp mq lh mr ms mt ll mu mv mw lp mx my mz na bi translated">哈希指针</h2><p id="24f5" class="pw-post-body-paragraph ky kz jj la b lb nb kk ld le nc kn lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">散列指针不仅存储变量的地址，还存储该地址上存储的数据的散列。</p><p id="4ab9" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用哈希指针，我们不仅可以检索数据，还可以验证数据是否已被更改。</p><figure class="ng nh ni nj gt iv gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/4cebca4d770327c0fe6be0f56929123d.png" data-original-src="https://miro.medium.com/v2/resize:fit:160/format:webp/1*zfHVUE8K0Aw6VioakB7AbA.png"/></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">散列指针符号</figcaption></figure><p id="4132" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">哈希指针用哈希函数表示，即<em class="nq"> H() </em>和箭头。</p><h2 id="f271" class="mi mj jj bd mk ml mm dn mn mo mp dp mq lh mr ms mt ll mu mv mw lp mx my mz na bi translated">链表</h2><p id="4da4" class="pw-post-body-paragraph ky kz jj la b lb nb kk ld le nc kn lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">链表是节点的集合，其中每个节点都有前一个节点和/或下一个节点的指针。因为每个节点都有指向前一个节点的指针，所以你只需要存储顶层节点的位置/指针。</p><p id="8885" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">人们可以简单地通过一个节点一个节点地移动存储在其相邻节点的每个节点中的位置来遍历整个列表。</p><figure class="ng nh ni nj gt iv gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/0494cb4a93f817adff910b2084ed642a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1042/format:webp/1*HFRmpgQHTDfyJ7PsPjk2fw.png"/></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">链表表示法</figcaption></figure><p id="bfdd" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，每当我们需要指向另一个节点时，我们将把头指针指向这个新节点，这个新节点将有一个指向前一个顶层节点的指针。</p></div><div class="ab cl nu nv hx nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="im in io ip iq"><h1 id="bb81" class="ob mj jj bd mk oc od oe mn of og oh mq kp oi kq mt ks oj kt mw kv ok kw mz ol bi translated">区块链</h1><p id="ea6d" class="pw-post-body-paragraph ky kz jj la b lb nb kk ld le nc kn lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">区块链是一个链表，使用哈希指针，而不是常规指针。这使区块链的每个节点不仅能够找到下一个节点，还能验证该节点中的数据是否已被更改。</p><p id="f663" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在区块链中，节点被称为一个块，因此我们将使用相同的约定。</p><p id="8fdc" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">头哈希指针将指向添加到区块链的最新块。</p><figure class="ng nh ni nj gt iv gh gi paragraph-image"><div class="gh gi om"><img src="../Images/108558ac234d1f53b0a9cc9c8f7fd796.png" data-original-src="https://miro.medium.com/v2/resize:fit:1066/format:webp/1*QdaR05isFq74RD561M46IA.png"/></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">区块链表示图</figcaption></figure><p id="9a83" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在此图中，我们展示了三个最新的模块。最新的区块(B3)可以使用Head定位。B2是在B3之前添加的，所以B3将存储一个指向它的指针，以及B2内容的散列。</p><p id="a31e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以区块链的每个区块都有</p><ul class=""><li id="d718" class="lu lv jj la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">指向添加在它之前的块(前一个块)的指针</li><li id="97b4" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">存储在前一个块上的所有内容的散列(就在它之前添加的那个)</li><li id="9fc8" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">需要存储的一些数据(在比特币多次交易的情况下)</li></ul><p id="1a9d" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">任何新的区块将被添加到B3旁边，并将存储指向B3的指针到这个区块链中。</p><h2 id="a9a5" class="mi mj jj bd mk ml mm dn mn mo mp dp mq lh mr ms mt ll mu mv mw lp mx my mz na bi translated"><strong class="ak">这是如何防篡改的？</strong></h2><p id="b7d4" class="pw-post-body-paragraph ky kz jj la b lb nb kk ld le nc kn lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">假设一些对手想要改变图中最左边的数据块中的数据。但是如果那个块中的数据发生变化，中间块的哈希指针就会失效。</p><figure class="ng nh ni nj gt iv gh gi paragraph-image"><div class="gh gi om"><img src="../Images/dee20f60c2a5239158dc1c078417821d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1066/format:webp/1*UH_4CHwfl114SDyc-fpjaA.png"/></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">区块链的块篡改表示</figcaption></figure><p id="cd92" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在为了使散列有效</p><ul class=""><li id="beae" class="lu lv jj la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">需要更新存储在B2的B1的散列</li><li id="2f77" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">但是由于它将改变使散列在B3无效</li><li id="fd7f" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">如果我们改变B3，这将使头哈希无效</li></ul><p id="ec1f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你需要记住的一件事是，当计算一个块<strong class="la jk">的散列时，它将包括该块</strong>的所有内容。例如，B3的哈希将是B2的所有哈希(即B2的哈希、指针以及数据)。</p><p id="1608" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">比方说，不改变数据，只是想删除B1。能做到吗？同样，如果不使下一个块的散列无效，它就不能被删除。</p><p id="d976" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">因此，只要我们安全地存储头哈希指针，区块链数据块中的任何更改都不会被忽略。</p><p id="0c2f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">许多其他基于指针的数据结构也可以被修改来创建防篡改的数据结构，只要其中没有循环。另一个非常著名的数据结构是<strong class="la jk"> Merkle tree </strong>，这是一个使用哈希指针而不是常规指针的二叉树。</p><h2 id="5c22" class="mi mj jj bd mk ml mm dn mn mo mp dp mq lh mr ms mt ll mu mv mw lp mx my mz na bi translated"><strong class="ak">区块链的用例</strong></h2><p id="dd4b" class="pw-post-body-paragraph ky kz jj la b lb nb kk ld le nc kn lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">区块链和其他基于散列指针的数据结构可以有很多应用。</p><p id="591f" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，once如何确保某些信息的持有者不会随意更改这些信息，这些信息在公共领域是不可用的。可以要求它们发布每天添加的节点的散列指针(即头指针)，这样信息就不会被暴露，但同时将保持可追究性。</p><p id="5284" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">区块链不变性的其他使用案例包括智能合同、<strong class="la jk"> </strong>资产管理、车辆历史、身份管理、法庭记录、大学学位记录、股票交易、数字投票等各种领域的记录保存。这使得伪造记录几乎不可能。</p></div><div class="ab cl nu nv hx nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="im in io ip iq"><h2 id="2871" class="mi mj jj bd mk ml mm dn mn mo mp dp mq lh mr ms mt ll mu mv mw lp mx my mz na bi translated"><strong class="ak">比特币中的区块链</strong></h2><p id="69b0" class="pw-post-body-paragraph ky kz jj la b lb nb kk ld le nc kn lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">在比特币中，全球分类账以区块链为基础进行维护。区块链每个区块将包含</p><ul class=""><li id="bb8d" class="lu lv jj la b lb lc le lf lh lw ll lx lp ly lt lz ma mb mc bi translated">多个交易，每个交易都由硬币的所有者(进行交易的人)签名</li><li id="9325" class="lu lv jj la b lb md le me lh mf ll mg lp mh lt lz ma mb mc bi translated">在它之前添加的块的位置和散列</li></ul><p id="79c2" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la jk">现在，既然没有中央信托方，谁来保存这个分类账，并验证所有的交易都是有效的？</strong></p><p id="0aa7" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有很多人在运行比特币软件，他们都有一份区块链的拷贝。每当要创建一个新的块时，它们都会为要添加的新块执行一个一致协议(<em class="nq">这是一个过于简化的过程，但详细解释超出了本文的范围</em>)。这样就不需要任何中央信任方。</p><p id="e21e" class="pw-post-body-paragraph ky kz jj la b lb lc kk ld le lf kn lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">虽然区块链是加密货币和智能合约的一个非常重要的部分，但在创建像比特币这样的去中心化账本时，涉及到了许多高超的工程和聪明的技术(<em class="nq">我必须说</em>)非常有趣。</p></div></div>    
</body>
</html>