<html>
<head>
<title>Create a custom modal in React with context, portals, and hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在React中创建一个定制的模型，与上下文、门户和挂钩进行交互</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/build-a-modal-using-react-context-portals-and-hooks-bd0c4e54537e?source=collection_archive---------1-----------------------#2019-07-16">https://levelup.gitconnected.com/build-a-modal-using-react-context-portals-and-hooks-bd0c4e54537e?source=collection_archive---------1-----------------------#2019-07-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/658ea49fd3ef0ffd0823cfd35fae6cbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wHosaWvsuxymNZLwT1CjZQ.png"/></div></div></figure><p id="1f82" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">模态是在应用程序顶部显示信息的好方法，通常用于通知、警告或独立对话框，如注册和登录表单。在开始构建自定义模型之前，我建议搜索任何现有的解决方案，看看它们是否符合您的需求(两个<a class="ae kw" href="https://ui.reach.tech/dialog/" rel="noopener ugc nofollow" target="_blank"> Reach UI的对话框</a>和<a class="ae kw" href="http://reactcommunity.org/react-modal/" rel="noopener ugc nofollow" target="_blank"> react-modal </a>都是流行的社区选择)。如果做不到这一点，让我们在React中创建一个定制的模态组件。</p><p id="0011" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们首先创建一个基本的模型，它根据一些本地状态有条件地呈现。单击应用程序根中的按钮应该会触发模式，单击模式中的按钮应该会关闭它。</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">示例一:基本模态实现</figcaption></figure><p id="408f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">只有当您需要从<code class="fe lh li lj lk b">&lt;App/&gt;</code>内部触发模态时，这才真正有用，但是如果您想要从嵌套组件中获得相同的功能，该怎么办呢？一种选择是将setState动作<code class="fe lh li lj lk b">setIsModalOpen</code>作为一个prop传递，并在嵌套组件中的按钮被单击时触发modal作为一个回调。</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">示例二:通过回调属性触发模态</figcaption></figure><p id="dfa0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这适用于单级嵌套，但可能无法很好地伸缩。我们可以继续通过组件向下传递回调，但这很快变得费力、难以维护，并产生大量多余的代码。进入<a class="ae kw" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank">反应上下文</a>。</p><p id="ac43" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">简而言之，React的上下文API允许您在一个<a class="ae kw" href="https://reactjs.org/docs/context.html#contextprovider" rel="noopener ugc nofollow" target="_blank">提供者</a>中存储一个值，可以通过一个<a class="ae kw" href="https://reactjs.org/docs/context.html#contextconsumer" rel="noopener ugc nofollow" target="_blank">消费者</a>从应用程序中的任何地方访问该值。每当声明一个消费者时，React将在组件树中搜索第一个匹配消费者上下文的提供者，返回其值，然后订阅任何进一步的更改。让我们用一个提供者来包装前面的例子，设置<code class="fe lh li lj lk b">setIsModalOpen</code>回调作为它的值，然后利用<code class="fe lh li lj lk b"><a class="ae kw" href="https://reactjs.org/docs/hooks-reference.html#usecontext" rel="noopener ugc nofollow" target="_blank">useContext()</a></code>钩子在一个嵌套组件中使用它。</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">示例三:通过React上下文触发模态</figcaption></figure><p id="2544" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们有了一个可以从应用程序的任何地方触发的模型，但目前只能呈现静态内容。为了让模型动态呈现，需要重构它来处理子模型。React的单向数据流意味着向上传递数据被认为是一种反模式，因此我们还需要一种可行的方法将数据从嵌套组件向上传递回根上的模型。</p><p id="e5bf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Jenna Smith 是一位才华横溢的前端开发人员，也是我的前同事。她提议用React的门户网站作为解决方案，因为它们被明确地设计成将子节点传递给一个存在于父组件层次结构之外的DOM节点。创建门户需要两个参数:任何可呈现的React元素(我们的动态内容)和一个将内容注入其中的DOM元素(模型的容器)。</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="lb lc l"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">例子四:<a class="ll lm ep" href="https://medium.com/u/21b2f9237313?source=post_page-----bd0c4e54537e--------------------------------" rel="noopener" target="_blank"> Jenna Smith </a>使用React的createPortal方法的解决方案</figcaption></figure><p id="156f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从沙箱中可以看出，她创建了两个功能组件来为模型提供动态内容。<code class="fe lh li lj lk b">&lt;ModalProvider /&gt;</code>组件包含一个附加了ref(<code class="fe lh li lj lk b">&lt;div ref={modalRef}/&gt;</code>)的DOM元素，以及一个包装整个应用程序并将ref的当前值分发给其中任何相关消费者的上下文提供者。第二个组成部分是模态本身。每当一个<code class="fe lh li lj lk b">&lt;Modal/&gt;</code>组件被渲染时，它将试图通过<code class="fe lh li lj lk b">useContext()</code>检索<code class="fe lh li lj lk b">modalRef</code>元素。如果存在一个ref，它将创建一个React Portal并将模态的子元素注入ref元素，而不是将组件安装在DOM树中的预期位置。💥</p><p id="9afe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，可以在ModalProvider中的任何地方使用模式组件，以便在应用程序上呈现动态内容。这种方法的一个小警告是，每当模态被装载时，主体将继续在iOS上滚动。我强烈推荐查看<a class="ll lm ep" href="https://medium.com/u/ec9acadcbea7?source=post_page-----bd0c4e54537e--------------------------------" rel="noopener" target="_blank"> Will Po </a>关于<a class="ae kw" href="https://medium.com/jsdownunder/locking-body-scroll-for-all-devices-22def9615177" rel="noopener">车身卷轴锁</a>的文章以获得一些解决方案。</p><p id="8063" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">喜欢这篇文章吗？<a class="ae kw" href="https://twitter.com/phunkren" rel="noopener ugc nofollow" target="_blank">在Twitter上关注我</a></p></div></div>    
</body>
</html>