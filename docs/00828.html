<html>
<head>
<title>Build A Finance “Velocity Limits” Real-time data process pipeline in Go with GCP Stacks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Go with GCP堆栈中构建财务“速度限制”实时数据处理管道</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/build-a-finance-velocity-limits-real-time-data-process-pipeline-in-go-with-gcp-stacks-558081f6ba8c?source=collection_archive---------2-----------------------#2019-08-14">https://levelup.gitconnected.com/build-a-finance-velocity-limits-real-time-data-process-pipeline-in-go-with-gcp-stacks-558081f6ba8c?source=collection_archive---------2-----------------------#2019-08-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="987d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">周末构建和学习—第3部分</p><p id="e3e6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在金融领域，账户有所谓的<strong class="js iu">“速度限制”是很常见的</strong>这个周末，我将编写一个数据处理管道，接受或拒绝交易，将资金实时加载到客户的账户中。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/1d4078db1c2f03014b2f57983ced2e30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aYHgX0j8bT622_ZD_5CbRg.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">数据流</figcaption></figure></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="c647" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated"><strong class="ak">简单用例&amp;规格:</strong></h1><ol class=""><li id="269e" class="mj mk it js b jt ml jx mm kb mn kf mo kj mp kn mq mr ms mt bi translated">每个传入的数据都是一个简单的JSON有效负载，如下所示:</li></ol><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mu"><img src="../Images/233200f532a2202d4f4af05d6f7cc6a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DJ_EhgTUAJuCZKsYUrxytA.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">JSON有效负载—传入</figcaption></figure><p id="9b6b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">2.每个客户都有三个限制:</p><ul class=""><li id="9fcf" class="mj mk it js b jt ju jx jy kb mv kf mw kj mx kn my mr ms mt bi translated">每天最多可装载2000美元</li><li id="8359" class="mj mk it js b jt mz jx na kb nb kf nc kj nd kn my mr ms mt bi translated">每周最多可装载10，000美元</li><li id="d0c2" class="mj mk it js b jt mz jx na kb nb kf nc kj nd kn my mr ms mt bi translated">无论数量多少，每天最多可执行2次装载。</li></ul><p id="8071" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这样，一个用户试图在一天内加载1000美元两次，在第二次尝试时会被拒绝，一个用户试图在一天内加载500美元四次也会被拒绝。</p><p id="e14b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">3.如果一个事务ID对于一个特定的用户被观察了不止一次，那么除了第一个实例之外的所有实例都可以被忽略。(<em class="ne">为了以后的阅读，请记住这一点，因为我想故意忽略这个需求，并将其添加回来，以测试我的应用程序架构是否可以扩展。</em>)</p><p id="dc25" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">4.对于每笔交易，我们将返回一个JSON响应，指示交易是否根据用户的活动被接受，其结构如下:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nf"><img src="../Images/b550bd4a3dec2f3a11ff9b08ca58b603.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZhFChgmQ9z3f9qjy2lLdzQ.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">输出JSON响应</figcaption></figure></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="3b80" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">计划是:</h1><ol class=""><li id="0f43" class="mj mk it js b jt ml jx mm kb mn kf mo kj mp kn mq mr ms mt bi translated">我们将把用例作为实时过程来处理，这将需要计划规模。一个<strong class="js iu">工作队列</strong>似乎是一个合适的解决方案。</li><li id="7e90" class="mj mk it js b jt mz jx na kb nb kf nc kj nd kn mq mr ms mt bi translated">我们已经确定了3个需求，例如每天可以加载<strong class="js iu">2000美元</strong>，每周加载<strong class="js iu">10000美元</strong>，每天加载<strong class="js iu"> 2次</strong>。我们希望确保这可以是<strong class="js iu">可配置的</strong>，并且还必须将实现逻辑与工作队列分开。</li><li id="7644" class="mj mk it js b jt mz jx na kb nb kf nc kj nd kn mq mr ms mt bi translated">我们还必须考虑内存缓存，以确保事务被跟踪，以符合验证规则。<strong class="js iu"> Redis </strong>或<strong class="js iu"> GCP消防基地</strong>似乎是这个任务的一个好选择，但是，作为POC属性，我们只使用本地映射引用来保持我们的记录跟踪。</li><li id="c48f" class="mj mk it js b jt mz jx na kb nb kf nc kj nd kn mq mr ms mt bi translated">最终的输出，对于演示性质，我们可以保存为输出文件，并作为我们以前的教程/文章批处理到GCP。(本文中我们不会解释太多。)</li></ol><div class="ng nh gp gr ni nj"><a href="https://medium.com/@jayhuang75/build-a-simple-lambda-architecture-data-pipeline-by-using-go-and-gcp-stacks-ea5ca7aa8a99" rel="noopener follow" target="_blank"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd iu gy z fp no fr fs np fu fw is bi translated">使用Go和GCP堆栈构建一个简单的Lambda架构数据管道。</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">周末构建和学习—第2部分</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">medium.com</p></div></div><div class="ns l"><div class="nt l nu nv nw ns nx ky nj"/></div></div></a></div><p id="a389" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">5.按照惯例，单元测试必须超过80% 。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="7492" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">让我们编码</h1><blockquote class="ny"><p id="1657" class="nz oa it bd ob oc od oe of og oh kn dk translated">让我们开始分解高层次的设计和实现细节。</p></blockquote><h2 id="d359" class="oi lm it bd ln oj ok dn lr ol om dp lv kb on oo lz kf op oq md kj or os mh ot bi translated"><strong class="ak">代码结构</strong></h2><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ou"><img src="../Images/117b43a0b406014fedc63fe9aa696fc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k6oVRUt8VXAAVisVKfRGmA.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">代码结构</figcaption></figure><h2 id="1713" class="oi lm it bd ln oj ov dn lr ol ow dp lv kb ox oo lz kf oy oq md kj oz os mh ot bi translated">运行中的界面</h2><p id="fc2a" class="pw-post-body-paragraph jq jr it js b jt ml jv jw jx mm jz ka kb pa kd ke kf pb kh ki kj pc kl km kn im bi translated">每个传入的交易都需要应用3个规则的验证。这可以由接口容易而有效地处理。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pd"><img src="../Images/13b04744a8bad2c6a7c3c7fa1ced1ecb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fivzZJQ1T43Vk_kNbAaKVg.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">运行中的界面</figcaption></figure><h2 id="cc4a" class="oi lm it bd ln oj ov dn lr ol ow dp lv kb ox oo lz kf oy oq md kj oz os mh ot bi translated">在管道上签名</h2><p id="ab33" class="pw-post-body-paragraph jq jr it js b jt ml jv jw jx mm jz ka kb pa kd ke kf pb kh ki kj pc kl km kn im bi translated">当您启动一个管道时，您不希望重新调用相同的初始函数并一遍又一遍地构造管道。单例模式应该适合我们的需求。就像初始化数据库连接一样。然而，我还想让这个<strong class="js iu">对于整个流程流来说是可扩展的</strong>，以防我决定添加更多的连接，比如Redis / GCP栈。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pe"><img src="../Images/4978c1051ff440fb6c724cd297c0b84b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S6IhMRFOL5TIQ8Xx8mgIyQ.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">在管道上签名</figcaption></figure><h2 id="3656" class="oi lm it bd ln oj ov dn lr ol ow dp lv kb ox oo lz kf oy oq md kj oz os mh ot bi translated">工作队列实现</h2><p id="4522" class="pw-post-body-paragraph jq jr it js b jt ml jv jw jx mm jz ka kb pa kd ke kf pb kh ki kj pc kl km kn im bi translated">Go有它漂亮的异步处理:<strong class="js iu">go routines</strong>T18】T6】通道。</p><p id="16b1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">与其他语言的async/waits、promises和futures相比，goroutine和channels更简单，更不容易出错，但功能同样强大。</p><p id="a820" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">构建工人队列系统背后的想法。我们希望维护一个任务/工作队列，在那里我们将推送一个新的工作/作业(在我们的用例中也称为事务)。当新的事务来自实时上游系统时，工作人员将主动监视队列并完成这些工作。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pf"><img src="../Images/fc5f803841ade3aab17194223379e5fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QKFwpOx-Ey0YhLpAemvtuw.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">工作队列实现</figcaption></figure><p id="2aab" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">好处:</p><ol class=""><li id="4aba" class="mj mk it js b jt ju jx jy kb mv kf mw kj mx kn mq mr ms mt bi translated">更好的表现</li><li id="f2a6" class="mj mk it js b jt mz jx na kb nb kf nc kj nd kn mq mr ms mt bi translated">提高可靠性</li><li id="83b1" class="mj mk it js b jt mz jx na kb nb kf nc kj nd kn mq mr ms mt bi translated">增加延展性</li></ol><h2 id="0029" class="oi lm it bd ln oj ov dn lr ol ow dp lv kb ox oo lz kf oy oq md kj oz os mh ot bi translated">如何开始管道和单元测试</h2><p id="13d4" class="pw-post-body-paragraph jq jr it js b jt ml jv jw jx mm jz ka kb pa kd ke kf pb kh ki kj pc kl km kn im bi translated">大多数实现逻辑都是基于接口实现抽象出来的。</p><p id="5425" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">好处:</p><ol class=""><li id="aaf8" class="mj mk it js b jt ju jx jy kb mv kf mw kj mx kn mq mr ms mt bi translated">Main.go的每一步看起来都简单易懂。</li><li id="185c" class="mj mk it js b jt mz jx na kb nb kf nc kj nd kn mq mr ms mt bi translated">使用mock进行单元测试很容易满足我们80%以上的覆盖率要求。</li></ol><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pf"><img src="../Images/f6ec00ccfdb24886185b1fd335120041.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ug1wQnz52iOi2H5i1HsFRA.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">main.go实现</figcaption></figure><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pg"><img src="../Images/86a28d9627a44bf2e478f83ea9f2824f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0pbtHRJ5knnBD7cGQ0TGzg.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">单元测试—覆盖率85.2%</figcaption></figure><h2 id="a2e2" class="oi lm it bd ln oj ov dn lr ol ow dp lv kb ox oo lz kf oy oq md kj oz os mh ot bi translated">最终执行输出</h2><p id="4688" class="pw-post-body-paragraph jq jr it js b jt ml jv jw jx mm jz ka kb pa kd ke kf pb kh ki kj pc kl km kn im bi translated">我们在input.txt中有大约1000条记录，执行时间只需要0.005秒。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pf"><img src="../Images/1223ddb013b0c886d6b4cc17e173a102.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kxd3N2zlInDv0YnwKDccPA.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">执行输出</figcaption></figure><h1 id="2e59" class="ll lm it bd ln lo ph lq lr ls pi lu lv lw pj ly lz ma pk mc md me pl mg mh mi bi translated">嘿，这个管道很容易扩展。</h1><p id="1b24" class="pw-post-body-paragraph jq jr it js b jt ml jv jw jx mm jz ka kb pa kd ke kf pb kh ki kj pc kl km kn im bi translated">你还记得我在简单用例&amp;规范第3节中提到的吗？</p><blockquote class="ny"><p id="05c9" class="nz oa it bd ob oc od oe of og oh kn dk translated">3.如果一个事务ID对于一个特定的用户被观察了不止一次，那么除了第一个实例之外的所有实例都可以被忽略。(<em class="pm">请记住这一点，以便将来阅读，因为我想故意忽略这一需求，并将其添加回来，以测试我的应用程序架构是否可以伸缩。</em>)</p></blockquote><p id="c466" class="pw-post-body-paragraph jq jr it js b jt pn jv jw jx po jz ka kb pp kd ke kf pq kh ki kj pr kl km kn im bi translated">让我们考虑这是一个需要添加的新验证规则。</p><p id="773a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们唯一需要做的是:</p><ol class=""><li id="60b0" class="mj mk it js b jt ju jx jy kb mv kf mw kj mx kn mq mr ms mt bi translated">在交易界面中添加基于业务规则的新验证功能。</li><li id="7eae" class="mj mk it js b jt mz jx na kb nb kf nc kj nd kn mq mr ms mt bi translated">在流水线处理函数中添加函数调用。</li></ol><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pf"><img src="../Images/d1595ab3c33332023d525b5d20b5bf80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2fzzObePHFoKwyrhzK_5BQ.png"/></div></div></figure><h1 id="cc25" class="ll lm it bd ln lo ph lq lr ls pi lu lv lw pj ly lz ma pk mc md me pl mg mh mi bi translated">我学到了什么？</h1><ol class=""><li id="94f5" class="mj mk it js b jt ml jx mm kb mn kf mo kj mp kn mq mr ms mt bi translated">学习金融“速度极限”的定义和概念。</li><li id="1ce0" class="mj mk it js b jt mz jx na kb nb kf nc kj nd kn mq mr ms mt bi translated">如何实现一个工作队列系统来处理事务数据？</li><li id="34a9" class="mj mk it js b jt mz jx na kb nb kf nc kj nd kn mq mr ms mt bi translated">延展性建筑设计。</li><li id="7b33" class="mj mk it js b jt mz jx na kb nb kf nc kj nd kn mq mr ms mt bi translated">永远享受编码的乐趣。:)</li></ol><p id="1cf6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">在下一篇文章第4部分中，我将使用内存缓存解决方案来扩展这个管道。敬请关注。</strong></p><p id="f976" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">如果你想看我的其他系列文章，请看下面:</strong></p><p id="0157" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><a class="ae ps" href="https://medium.com/@jayhuang75" rel="noopener">https://medium.com/@jayhuang75</a></p></div></div>    
</body>
</html>