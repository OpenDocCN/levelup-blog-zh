<html>
<head>
<title>How Google Authenticator, HMAC-Based One-time Password, and Time-based One-time Password Work</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Google认证器、基于HMAC的一次性密码和基于时间的一次性密码是如何工作的</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-google-authenticator-hmac-based-one-time-password-and-time-based-one-time-password-work-17c6bdef0deb?source=collection_archive---------3-----------------------#2021-02-28">https://levelup.gitconnected.com/how-google-authenticator-hmac-based-one-time-password-and-time-based-one-time-password-work-17c6bdef0deb?source=collection_archive---------3-----------------------#2021-02-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/a7291cebf32d34a3a8a8bfe086ae41f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XjLwKES-iJ31O8wfaGL9gA.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://unsplash.com/@mr_williams_photography?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">迈卡·威廉姆斯</a>在<a class="ae kc" href="https://unsplash.com/s/photos/login?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><p id="a2b9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">已经知道<a class="ae kc" href="https://www.jisc.ac.uk/blog/why-having-a-strong-password-isnt-enough-to-secure-your-account-23-jul-2020" rel="noopener ugc nofollow" target="_blank"> <em class="lb">密码不够好</em> </a>。多因素身份认证(MFA)通过要求用户提供除密码之外的其他信息，增加了额外的防御级别。主要有三类信息:</p><ul class=""><li id="d6d8" class="lc ld iq kf b kg kh kk kl ko le ks lf kw lg la lh li lj lk bi translated"><strong class="kf ir">您知道的一些事情:</strong>密码、安全问题、pin码</li><li id="d431" class="lc ld iq kf b kg ll kk lm ko ln ks lo kw lp la lh li lj lk bi translated"><strong class="kf ir">您拥有的东西:</strong>用户拥有的东西，例如智能手机、硬件令牌</li><li id="eb81" class="lc ld iq kf b kg ll kk lm ko ln ks lo kw lp la lh li lj lk bi translated"><strong class="kf ir">你是什么:</strong>证明用户是他们所声称的那个人的东西——通常是生物特征因素(指纹、Face ID等。)</li></ul><p id="e23e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">很多<a class="ae kc" href="https://evanhahn.com/2fa/" rel="noopener ugc nofollow" target="_blank">网站</a>以密码为“你知道的东西”，以认证者生成的令牌为“你拥有的东西”来提供2FA。事实上，如果你在智能手机上使用authenticator应用程序，你还可以免费获得第三个因素，在启动authenticator应用程序之前，你需要通过智能手机的生物认证。</p><blockquote class="lq lr ls"><p id="d97b" class="kd ke lb kf b kg kh ki kj kk kl km kn lt kp kq kr lu kt ku kv lv kx ky kz la ij bi translated">一些密码管理器，如LastPass和BitWarden，也提供认证器功能。我认为使用它们是一个可怕的想法，你基本上是把所有的因素都压缩成一个——你的主密码。</p></blockquote><p id="3fb1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">所有授权码都是平等的吗？</strong></p><p id="a6a8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当你在网站上启用双因素认证时，他们通常会向你显示一个二维码，并要求你扫描并启动你的认证器应用程序。有些网站<strong class="kf ir">专门</strong>要求你使用谷歌认证器，<strong class="kf ir">你不用</strong>。Google Authenticator使用的是基于HMAC的一次性密码(HOTP)和基于时间的一次性密码(TOTP)算法。其他认证器应用程序，如Authy、Duo Mobile、Lastpass和1Password，都实现了相同的算法，并且能够生成与您从谷歌认证器获得的<strong class="kf ir">完全相同的令牌</strong>。</p><p id="5455" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不同授权码之间的主要区别是，一些授权码与云集成，并将您的密钥的加密副本上传到他们的服务器，因此您可以享受在多个设备上访问您的令牌的便利。当然，在这种情况下，您还信任身份验证者提供者。</p><p id="5c5c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">二维码背后有什么魔力？</strong></p><figure class="lx ly lz ma gt jr gh gi paragraph-image"><div class="gh gi lw"><img src="../Images/9e011eee8e511e979c2b0369545fe8fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:946/format:webp/1*X2HCngcFW5jTP_i3IiwQyg.png"/></div></figure><p id="b9c7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">二维码实际上是一个URI。上面截图中的是</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="4061" class="mg mh iq mc b gy mi mj l mk ml">otpauth://totp/Autodesk?secret=KFTDKTSKGNHTC2JV</span></pre><p id="bf5f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">URI计划最初是由谷歌正式提出的。大多数验证器应用程序为<code class="fe mm mn mo mc b">otpauth://</code>注册了一个处理程序，因此相机应用程序知道如何在扫描时提示用户启动验证器应用程序。GitHub上的这个<a class="ae kc" href="https://github.com/google/google-authenticator/wiki/Key-Uri-Format" rel="noopener ugc nofollow" target="_blank">文档</a>解释了URI的构造:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="c0cb" class="mg mh iq mc b gy mi mj l mk ml">otpauth://TYPE/LABEL?PARAMETERS</span></pre><p id="9315" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mm mn mo mc b">TYPE</code>要么是HOTP，要么是TOTP(稍后将详述)。<code class="fe mm mn mo mc b">LABEL</code>仅用于显示，验证者应用程序使用它来预填充帐户名称。<code class="fe mm mn mo mc b">secret</code>是认证者用来生成令牌的密钥。</p><p id="92f0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">尽管URI方案本身支持不同的<code class="fe mm mn mo mc b">PARAMETERS</code>，如<code class="fe mm mn mo mc b">Algorithm</code>和<code class="fe mm mn mo mc b">Digits</code>，但谷歌认证器并不实现它们，大多数网站采用默认设置，使用SHA1和6位令牌。</p><p id="05b8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> HOTP和TOTP </strong></p><p id="145e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Google Authenticator支持两种算法。</p><ul class=""><li id="e300" class="lc ld iq kf b kg kh kk kl ko le ks lf kw lg la lh li lj lk bi translated">HMAC的一次性密码(HOTP)</li><li id="86c2" class="lc ld iq kf b kg ll kk lm ko ln ks lo kw lp la lh li lj lk bi translated">基于时间的一次性密码(TOTP)</li></ul><figure class="lx ly lz ma gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mp"><img src="../Images/2c1548f424142689cd75b54f4eb2e2a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LXv0E9hfh1_8TBVViJ4PVQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">HOTP和TOTP</figcaption></figure><p id="4e31" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这里，一次性密码是用户发送到网站进行验证的6位数令牌。密钥由网站在二维码中提供给用户，<strong class="kf ir">双方需要保留该密钥用于一次性密码生成(该密钥存储在认证器内)</strong>。</p><p id="f403" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一次性密码的一个关键要求是每个密码只应使用一次，因此该算法需要某种可变元素来在用户每次想要登录时生成不同的OTP。</p><p id="b7bd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在HOTP，这个变量是一个计数器。服务器和用户通过对秘密密钥和计数器应用散列和截断操作来计算OTP。服务器将其计算的OTP与用户提供的OTP进行比较。<strong class="kf ir">然后双方递增计数器</strong>。</p><p id="7164" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">HOTP的一个明显缺点是服务器和用户之间的计数器必须保持同步。如果用户打开authenticator应用程序来生成OTP，但最终没有使用它，则用户端的计数器将与服务器不同步。处理这种情况的一种方法是重新同步机制，其中服务器尝试几个未来的计数器值，以查看它是否找到匹配的OTP，并相应地同步计数器。</p><figure class="lx ly lz ma gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mp"><img src="../Images/d8813104ab41d14cb0ad5164eada2a55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GVWHldzFShQTT9A5hpwdfQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">TOTP</figcaption></figure><p id="5516" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">TOTP通过使用当前时间作为可变元素来改进HOTP。在TOTP，时间被定义为从Epoch开始的秒数除以一个周期(在大多数实现中为30秒)。只要用户设备和服务器上的时钟准确，它们将能够一起生成相同的OTP。</p><p id="0c0f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">尽管如此，仍有一个<strong class="kf ir">边缘案例</strong>。在用户OTP生成和服务器OTP生成之间存在时间间隔。服务器根据用户的动态口令到达服务器的时间来生成动态口令。假设用户设备和服务器之间存在一些未知的消息传输时间和时钟漂移，则用户计算中使用的时间可能与服务器使用的时间属于不同的时间步长(30秒)。对此的解决方案通常是让服务器接受使用向前或向后一个时间步长计算的OTP。</p><blockquote class="lq lr ls"><p id="7d37" class="kd ke lb kf b kg kh ki kj kk kl km kn lt kp kq kr lu kt ku kv lv kx ky kz la ij bi translated">你是否曾经等待下一个令牌出现，而它将在几秒钟后到期，担心你没有足够的时间将其输入到文本框中？<em class="iq">你可能不需要</em>，因为如果时差不太大的话，服务器通常会接受新旧两个版本。</p></blockquote><p id="1bfc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">大多数网站使用TOTP算法，市场上所有谷歌认证兼容的替代品都支持同样的算法。如果你是advanturous，你也可以实现自己的TOTP生成器，你会得到完全相同的6位数字令牌作为谷歌认证，如果你这样做是正确的。</p><p id="8a57" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">HOTP和TOTP的简单实现:</p><ul class=""><li id="adf2" class="lc ld iq kf b kg kh kk kl ko le ks lf kw lg la lh li lj lk bi translated"><a class="ae kc" href="https://github.com/susam/mintotp#source-code" rel="noopener ugc nofollow" target="_blank"> Python </a></li><li id="36a4" class="lc ld iq kf b kg ll kk lm ko ln ks lo kw lp la lh li lj lk bi translated"><a class="ae kc" href="https://github.com/robbiev/two-factor-auth" rel="noopener ugc nofollow" target="_blank">走</a></li></ul><p id="8842" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">希望你喜欢这个故事！</p></div></div>    
</body>
</html>