<html>
<head>
<title>Top 30 React Interview Questions of 2019</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">2019年前30名React面试问题</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/everything-about-react-10512639a01e?source=collection_archive---------1-----------------------#2019-11-16">https://levelup.gitconnected.com/everything-about-react-10512639a01e?source=collection_archive---------1-----------------------#2019-11-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="becb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这篇文章将作为你准备React面试的指南。但是在开始React面试问题之前，我们先来快速了解一下React的需求和在市场上的地位。截至今天，Github上大约有1000名贡献者。像虚拟DOM和可重用组件这样的独特特性使得这个库被广泛采用。看看下面的图表，它显示了流行的JS框架的趋势:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/9c758a5fba0bb1cfd886ebce835bed71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2UmCL9vjd51J5AlE2oMOcA.png"/></div></div></figure></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><p id="da94" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Q1:什么是反应？</p><ul class=""><li id="5e14" class="le lf iq jp b jq jr ju jv jy lg kc lh kg li kk lj lk ll lm bi translated">React是脸书在2011年开发的前端JavaScript库。</li><li id="e619" class="le lf iq jp b jq ln ju lo jy lp kc lq kg lr kk lj lk ll lm bi translated">它遵循基于组件的方法，这有助于构建可重用的UI组件。</li><li id="4d9e" class="le lf iq jp b jq ln ju lo jy lp kc lq kg lr kk lj lk ll lm bi translated">它用于开发复杂的交互式web和移动UI。</li><li id="8aef" class="le lf iq jp b jq ln ju lo jy lp kc lq kg lr kk lj lk ll lm bi translated">它在2015年才开源，并有一个最大的社区支持它。</li></ul><p id="133e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">Q2:React的特点是什么？</strong></p><ul class=""><li id="8d12" class="le lf iq jp b jq jr ju jv jy lg kc lh kg li kk lj lk ll lm bi translated">它使用<strong class="jp ir">虚拟dom </strong>而不是真实dom来管理UI。</li><li id="862f" class="le lf iq jp b jq ln ju lo jy lp kc lq kg lr kk lj lk ll lm bi translated">它能够使用<strong class="jp ir">服务器端渲染</strong>。</li><li id="4389" class="le lf iq jp b jq ln ju lo jy lp kc lq kg lr kk lj lk ll lm bi translated">它遵循<strong class="jp ir">单向数据流</strong>。</li><li id="6d97" class="le lf iq jp b jq ln ju lo jy lp kc lq kg lr kk lj lk ll lm bi translated">你的用户界面被分成模块化和可重用的组件。</li><li id="0ea2" class="le lf iq jp b jq ln ju lo jy lp kc lq kg lr kk lj lk ll lm bi translated">它是纯JavaScript——它没有创建任何特定于领域的功能。</li><li id="c782" class="le lf iq jp b jq ln ju lo jy lp kc lq kg lr kk lj lk ll lm bi translated">它提供了钩子和组件生命周期方法来管理副作用和状态。</li><li id="5b30" class="le lf iq jp b jq ln ju lo jy lp kc lq kg lr kk lj lk ll lm bi translated">它使用组件层次结构，数据从父级传递到子级。</li></ul><p id="39f9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> Q3:列出React的一些主要优势。</strong></p><ul class=""><li id="59b4" class="le lf iq jp b jq jr ju jv jy lg kc lh kg li kk lj lk ll lm bi translated">它提高了应用程序的性能。</li><li id="b2a0" class="le lf iq jp b jq ln ju lo jy lp kc lq kg lr kk lj lk ll lm bi translated">这是一个轻量级的库。</li><li id="592c" class="le lf iq jp b jq ln ju lo jy lp kc lq kg lr kk lj lk ll lm bi translated">它可以很容易地用于客户端和服务器端渲染。</li><li id="8bd9" class="le lf iq jp b jq ln ju lo jy lp kc lq kg lr kk lj lk ll lm bi translated">JSX提供了有效的代码可读性。</li><li id="2561" class="le lf iq jp b jq ln ju lo jy lp kc lq kg lr kk lj lk ll lm bi translated">它可以与其他框架集成，如Meteor等。</li><li id="fe17" class="le lf iq jp b jq ln ju lo jy lp kc lq kg lr kk lj lk ll lm bi translated">使用React，编写UI测试用例极其容易。</li><li id="804c" class="le lf iq jp b jq ln ju lo jy lp kc lq kg lr kk lj lk ll lm bi translated">它只是关注应用程序的视图层，而不是一个笨重臃肿的框架。</li></ul><p id="116b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">Q4:React的局限性是什么？</strong></p><ul class=""><li id="6d10" class="le lf iq jp b jq jr ju jv jy lg kc lh kg li kk lj lk ll lm bi translated">React只是一个库，不是一个成熟的框架。你必须定义你自己的依赖关系。</li><li id="cda0" class="le lf iq jp b jq ln ju lo jy lp kc lq kg lr kk lj lk ll lm bi translated">编码变得复杂，因为它使用内联模板和JSX。</li></ul><p id="bb2d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">什么是JSX？</p><p id="a4dd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">JSX是一种类似HTML的语法，用于声明React元素和用户界面。这是React使用的一种文件类型，它利用了JavaScript的表现力和HTML模板语法。这使得HTML文件非常容易理解。这个文件使应用程序更加健壮，可读性更好。</p><p id="cfc3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> Q6:为什么浏览器不能读取JSX？</strong></p><p id="bfbc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">浏览器只能读取JavaScript对象，但是JSX不是一个普通的JavaScript对象。因此，要使浏览器能够读取JSX，我们首先需要使用像巴别塔这样的JSX转换器将JSX文件转换成JavaScript对象，然后将它传递给浏览器。</p><p id="eea6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">问题7:什么是React组件？</strong></p><p id="a198" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">React组件是一些小的、可重用的代码片段，它们返回要呈现到页面上的React元素。React组件的最简单版本是返回React元素的普通JavaScript函数。</p><p id="dd92" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">组件也可以是ES6类。</p><p id="693f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> Q8:解释React中render()的用途。</strong></p><p id="d232" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每个React组件都需要有一个<code class="fe ls lt lu lv b">render()</code>方法。它返回一个React元素，这个元素是原生DOM组件的表示。如果需要呈现一个以上的HTML元素，那么必须将它们组合在一个封闭标签中，如<code class="fe ls lt lu lv b">&lt;form&gt;</code>、<code class="fe ls lt lu lv b">&lt;group&gt;</code>、<code class="fe ls lt lu lv b">&lt;div&gt;</code>等。这个函数必须保持纯净，也就是说，每次根据当前状态调用它时，它必须返回相同的结果。</p><p id="40f3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> Q9:什么是道具？</strong></p><p id="3667" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> Props </strong>是React组件的输入。它们是从父组件传递到子组件的数据。</p><p id="7dd8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> Q10:什么是状态？</strong></p><p id="7501" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">状态是存储在单个组件中的数据。这和道具一起决定了组件的渲染和行为。当与组件相关的一些数据随时间变化时，组件需要状态。</p><p id="1b60" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="lw">例如，一个复选框组件可能需要在其状态中被选中。</em></p><p id="f801" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">状态也可以使用像Redux这样的库进行全局分离和存储。</p><p id="d0a6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> Q11:状态和道具的区别。</strong></p><p id="9b75" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">状态和道具之间最重要的区别是道具是从父组件传递的，但是状态是由组件本身管理的。</p><p id="aa82" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个组件不能改变它的属性，但是可以改变它的状态。虽然父组件可以改变属性，但不能改变子组件的状态。</p><p id="1617" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">Q12:React中如何使用箭头函数？</strong></p><p id="3ad1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">箭头函数是用于编写函数表达式的精简语法。它们也被称为‘胖箭’(<code class="fe ls lt lu lv b">=&gt;</code>)函数。这些函数允许我们正确地绑定组件的上下文，因为在ES6中，自动绑定在默认情况下是不可用的。</p><p id="6593" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">问题13:React中的事件是什么？</strong></p><p id="9999" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在React中，事件是对鼠标悬停、鼠标点击、按键等特定动作的触发反应。处理这些事件类似于处理DOM元素中的事件。</p><p id="bbd3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">Q14:React中的合成事件是什么？</strong></p><p id="667e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">合成事件是围绕浏览器本地事件的跨浏览器包装器。它与浏览器的本地事件具有相同的接口，包括<code class="fe ls lt lu lv b">stopPropagation()</code>和<code class="fe ls lt lu lv b">preventDefault()</code>，除了这些事件在所有浏览器中的工作方式相同。它通过自动使用事件委托来实现高性能。</p><p id="212b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">简单地说——它是React对本地事件的包装。</p><p id="8e5f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">Q15:React中的裁判是什么？</strong></p><p id="5ab5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它是一个属性，用于存储对特定React元素或组件的引用，该引用将由组件呈现配置函数返回。它用于返回对r <code class="fe ls lt lu lv b">ender()</code>返回的特定元素或组件的引用。当我们需要访问React呈现的原生DOM节点时，它们就派上了用场。</p><p id="30c5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">问题16:列举一些你应该使用参考文献的例子。</strong></p><ul class=""><li id="d3b9" class="le lf iq jp b jq jr ju jv jy lg kc lh kg li kk lj lk ll lm bi translated">当您需要管理焦点时，选择文本或媒体播放</li><li id="def8" class="le lf iq jp b jq ln ju lo jy lp kc lq kg lr kk lj lk ll lm bi translated">要触发命令式动画</li><li id="caa1" class="le lf iq jp b jq ln ju lo jy lp kc lq kg lr kk lj lk ll lm bi translated">与第三方DOM库集成</li></ul><p id="f85a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> Q17:你对受控和非受控组件了解多少？</strong></p><p id="e31c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">受控组件:</p><ul class=""><li id="2b63" class="le lf iq jp b jq jr ju jv jy lg kc lh kg li kk lj lk ll lm bi translated">他们没有保持自己的状态</li><li id="656a" class="le lf iq jp b jq ln ju lo jy lp kc lq kg lr kk lj lk ll lm bi translated">数据由状态或父组件控制</li><li id="7cea" class="le lf iq jp b jq ln ju lo jy lp kc lq kg lr kk lj lk ll lm bi translated">它们通过接收当前值，然后通过回调通知更改</li></ul><p id="c8e7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">非受控组件:</p><ul class=""><li id="de61" class="le lf iq jp b jq jr ju jv jy lg kc lh kg li kk lj lk ll lm bi translated">他们保持自己的状态</li><li id="6e98" class="le lf iq jp b jq ln ju lo jy lp kc lq kg lr kk lj lk ll lm bi translated">数据由DOM控制</li></ul><p id="9f1d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> Q18:什么是高阶元件？</strong></p><p id="e676" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">高阶组件是重用组件逻辑的一种高级方式。基本上，这是一种源自React的组合性质的模式。HOC是在其中包装另一个组件的定制组件。它们可以接受任何动态提供的子组件，但不会修改或复制输入组件的任何行为。你可以说HOC是“纯”组件。</p><p id="3c84" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> Q19:列出HOC的用途。</strong></p><p id="c36c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">HOC可用于许多任务:</p><ul class=""><li id="d2fc" class="le lf iq jp b jq jr ju jv jy lg kc lh kg li kk lj lk ll lm bi translated">代码重用、逻辑和引导抽象</li><li id="ef87" class="le lf iq jp b jq ln ju lo jy lp kc lq kg lr kk lj lk ll lm bi translated">渲染装饰</li><li id="d2d8" class="le lf iq jp b jq ln ju lo jy lp kc lq kg lr kk lj lk ll lm bi translated">状态抽象和操作</li><li id="5b75" class="le lf iq jp b jq ln ju lo jy lp kc lq kg lr kk lj lk ll lm bi translated">道具操作</li></ul><p id="6961" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> Q20:什么是纯成分？</strong></p><p id="8f5f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">纯组件为您管理<code class="fe ls lt lu lv b">shouldComponentUpdate</code>函数，只有在状态改变时才会重新呈现。</p><p id="7a0b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">Q21:React中如何模块化代码？</strong></p><p id="546f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以通过使用导出和导入属性来模块化代码。它们有助于在不同的文件中分别编写组件。</p><p id="f619" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">Q22:React组件生命周期的不同阶段是什么？</strong></p><ul class=""><li id="f23a" class="le lf iq jp b jq jr ju jv jy lg kc lh kg li kk lj lk ll lm bi translated"><strong class="jp ir">挂载</strong>:这是组件即将开始其生命之旅并被添加到DOM的阶段。React有四种内置的挂载方法:</li></ul><ol class=""><li id="f488" class="le lf iq jp b jq jr ju jv jy lg kc lh kg li kk lx lk ll lm bi translated">构造函数()</li><li id="dd0b" class="le lf iq jp b jq ln ju lo jy lp kc lq kg lr kk lx lk ll lm bi translated">getDerivedStateFromProps()</li><li id="827d" class="le lf iq jp b jq ln ju lo jy lp kc lq kg lr kk lx lk ll lm bi translated">渲染()</li><li id="a90f" class="le lf iq jp b jq ln ju lo jy lp kc lq kg lr kk lx lk ll lm bi translated">componentDidMount()</li></ol><ul class=""><li id="cfd6" class="le lf iq jp b jq jr ju jv jy lg kc lh kg li kk lj lk ll lm bi translated"><strong class="jp ir">更新</strong>:一旦组件被添加到DOM中，只有当属性或状态发生变化时，它才可能更新和重新呈现。那只发生在这个阶段。React有五种内置的更新方法:</li></ul><ol class=""><li id="77a3" class="le lf iq jp b jq jr ju jv jy lg kc lh kg li kk lx lk ll lm bi translated">getDerivedStateFromProps()</li><li id="f039" class="le lf iq jp b jq ln ju lo jy lp kc lq kg lr kk lx lk ll lm bi translated">shouldComponentUpdate()</li><li id="639d" class="le lf iq jp b jq ln ju lo jy lp kc lq kg lr kk lx lk ll lm bi translated">渲染()</li><li id="0479" class="le lf iq jp b jq ln ju lo jy lp kc lq kg lr kk lx lk ll lm bi translated">getSnapshotBeforeUpdate()</li><li id="1f24" class="le lf iq jp b jq ln ju lo jy lp kc lq kg lr kk lx lk ll lm bi translated">componentDidUpdate()</li></ol><ul class=""><li id="c5a8" class="le lf iq jp b jq jr ju jv jy lg kc lh kg li kk lj lk ll lm bi translated"><strong class="jp ir">卸载:</strong>这是组件生命周期的最后一个阶段，在这个阶段，组件被销毁并从DOM中删除。React只有一个被调用的内置方法:</li></ul><ol class=""><li id="2c4c" class="le lf iq jp b jq jr ju jv jy lg kc lh kg li kk lx lk ll lm bi translated">componentWillUnmount()</li></ol><p id="6db4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae ly" href="https://medium.com/@__jay__singh__/react-lifecycle-2c63aee11c09" rel="noopener"> <em class="lw">了解更多关于生命周期的信息</em> </a></p><p id="bd3d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">Q23:React中按键的意义是什么？</strong></p><p id="bdde" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">键用于标识唯一的虚拟DOM元素，以及驱动UI的相应数据。它们通过回收DOM中的所有现有元素来帮助优化呈现。这些键必须是唯一的数字或字符串，React只是对元素重新排序，而不是重新呈现它们。这导致了应用程序性能的提高。</p><p id="ceb7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> Q24:解释通量。</strong></p><p id="68b5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Flux是一种实施单向数据流的架构模式。它控制派生数据，并使用对所有数据拥有权限的中央存储来实现多个组件之间的通信。整个应用程序中的任何数据更新都只能在这里进行。Flux为应用程序提供了稳定性，并减少了运行时错误。</p><p id="4326" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">Q25:Redux是什么？</strong></p><p id="f396" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Redux是一个用于管理应用程序状态的开源JavaScript库。它通常与React或Angular等库一起用于构建用户界面。这是通量概念的一种实现。</p><p id="7860" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">Q26:Redux遵循的三大原则是什么？</strong></p><ul class=""><li id="e441" class="le lf iq jp b jq jr ju jv jy lg kc lh kg li kk lj lk ll lm bi translated"><strong class="jp ir"> <em class="lw">单一事实来源:</em> </strong>整个应用程序的状态存储在一个单一存储内的对象/状态树中。单一状态树使得跟踪随时间的变化以及调试或检查应用程序变得更加容易。</li><li id="c2a8" class="le lf iq jp b jq ln ju lo jy lp kc lq kg lr kk lj lk ll lm bi translated"><strong class="jp ir"> <em class="lw">状态只读:</em> </strong>改变状态的唯一方法是触发一个动作。动作是描述变更的普通JS对象。就像状态是数据的最小表示一样，动作是数据变化的最小表示。</li><li id="eae1" class="le lf iq jp b jq ln ju lo jy lp kc lq kg lr kk lj lk ll lm bi translated"><strong class="jp ir"> <em class="lw">用纯函数做改变:</em> </strong>为了指定状态树如何被动作转化，你需要纯函数。纯函数是那些返回值仅依赖于参数值的函数。</li></ul><p id="6562" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> Q27:列出Redux的组件。</strong></p><p id="db6f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Redux有以下组件:</p><ul class=""><li id="6813" class="le lf iq jp b jq jr ju jv jy lg kc lh kg li kk lj lk ll lm bi translated"><strong class="jp ir">动作:</strong>是描述所发生事情的宾语。</li><li id="72a1" class="le lf iq jp b jq ln ju lo jy lp kc lq kg lr kk lj lk ll lm bi translated"><strong class="jp ir">减速器:</strong>是决定状态会如何变化的地方。</li><li id="5254" class="le lf iq jp b jq ln ju lo jy lp kc lq kg lr kk lj lk ll lm bi translated"><strong class="jp ir">存储:</strong>整个应用的状态/对象树。</li></ul><p id="ef0b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">Q28:Redux中的动作是如何定义的？</strong></p><p id="840b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">React中的动作必须有一个<code class="fe ls lt lu lv b">type</code>属性来指示正在执行的动作的类型。它们必须被定义为一个字符串常量，你可以添加更多的属性和有效载荷。在Redux中，动作是使用称为动作创建器的函数创建的。</p><p id="a331" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> Q29:解释减速器的作用。</strong></p><p id="bcca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Reducers是纯函数，它指定应用程序的状态如何响应一个动作而改变。Reducers通过接受先前的状态和动作来工作，然后返回一个新的状态。它根据动作的类型确定需要进行哪种更新，然后返回新值。如果不需要做任何工作，它就返回原来的状态。</p><p id="d81e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> Q30:商店在Redux的意义是什么？</strong></p><p id="8a48" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">store是一个JavaScript对象，它可以保存应用程序的状态，并提供一些助手方法来访问状态、调度操作和注册侦听器。应用程序的整个状态/对象树保存在单个存储中。因此，Redux非常简单且可预测。我们可以将中间件传递给商店来处理数据，并记录改变商店状态的各种操作。所有的动作通过reducers返回一个新的状态。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><p id="756c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我希望这一套React面试问答能帮助你准备面试。万事如意！</p></div></div>    
</body>
</html>