<html>
<head>
<title>How to execute an object file: Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何执行目标文件:第1部分</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-execute-an-object-file-part-1-2c92d962f276?source=collection_archive---------32-----------------------#2021-03-07">https://levelup.gitconnected.com/how-to-execute-an-object-file-part-1-2c92d962f276?source=collection_archive---------32-----------------------#2021-03-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c0d3" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在没有链接的情况下调用简单函数</h2></div><p id="13b2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">这是我转贴自</em> <a class="ae lc" href="https://blog.cloudflare.com/how-to-execute-an-object-file-part-1/" rel="noopener ugc nofollow" target="_blank"> <em class="lb"> Cloudflare博客</em> </a>的帖子</p><p id="42e7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们使用高级编译编程语言编写软件时，将源代码转换成最终的可执行二进制代码通常需要几个步骤:</p><figure class="le lf lg lh gt li gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi ld"><img src="../Images/39d7c3d3a00242e25a7e032dcc6fd5ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a4KeL0n6Wt9fqW_S8o-3Ow.png"/></div></div></figure><p id="301b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我们的源文件由一个<em class="lb">编译器</em>编译，该编译器将高级编程语言翻译成机器代码。编译器的输出是一些<em class="lb">对象</em>文件。如果项目包含多个源文件，我们通常会得到同样多的目标文件。下一步是<em class="lb">链接器</em>:由于不同目标文件中的代码可能会相互引用，链接器负责将所有这些目标文件组装成一个大程序，并将这些引用绑定在一起。链接器的输出通常是我们的目标可执行文件，所以只有一个文件。</p><p id="1231" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，在这一点上，我们的可执行文件可能仍然是不完整的。如今，Linux上的大多数可执行文件都是动态链接的:可执行文件本身并没有运行程序所需的所有代码。相反，它希望在运行时从<a class="ae lc" href="https://en.wikipedia.org/wiki/Library_(computing)#Shared_libraries" rel="noopener ugc nofollow" target="_blank">共享库</a>中“借用”部分代码来实现它的一些功能:</p><figure class="le lf lg lh gt li gh gi paragraph-image"><div class="gh gi lp"><img src="../Images/d1471e465f286414378dccb29c68febd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1074/format:webp/1*UWwP5s-8hEulleumeStv7A.png"/></div></figure><p id="88c9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个进程被称为<em class="lb">运行时链接</em>:当我们的可执行文件启动时，操作系统将调用<em class="lb">动态加载器</em>，它将找到所有需要的库，将它们的代码复制/映射到我们的目标进程地址空间，并解析我们的代码对它们的所有依赖。</p><p id="4aba" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">关于这个整体过程需要注意的一个有趣的事情是，我们直接从步骤1(编译源代码)获得可执行的机器代码，但是如果后面的任何步骤失败，我们仍然无法执行我们的程序。因此，在这一系列的博客文章中，我们将研究是否有可能跳过所有后面的步骤，直接从目标文件中执行机器码。</p><h2 id="6915" class="lq lr iq bd ls lt lu dn lv lw lx dp ly ko lz ma mb ks mc md me kw mf mg mh mi bi translated">为什么我们要执行一个目标文件？</h2><p id="1141" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">原因可能有很多。也许我们正在为一个专有的Linux驱动程序或应用程序编写一个开源的替代品，并且想要比较某些代码的行为是否相同。或者我们有一个罕见的，晦涩的程序的一部分，我们不能链接到它，因为它是用一个罕见的，晦涩的编译器编译的。也许我们有一个源文件，但由于缺少构建时间或运行时依赖，我们无法创建一个全功能的可执行文件。恶意软件分析、来自不同操作系统的代码等——所有这些场景都可能将我们置于一个位置，要么链接是不可能的，要么运行时环境是不合适的。</p><h2 id="0c15" class="lq lr iq bd ls lt lu dn lv lw lx dp ly ko lz ma mb ks mc md me kw mf mg mh mi bi translated">一个简单的玩具对象文件</h2><p id="3945" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">出于本文的目的，让我们创建一个简单的玩具对象文件，这样我们就可以在实验中使用它:</p><p id="d7bc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">对象c </em>:</p><pre class="le lf lg lh gt mo mp mq mr aw ms bi"><span id="aa1e" class="lq lr iq mp b gy mt mu l mv mw">int add5(int num)<br/>{<br/>    return num + 5;<br/>}<br/><br/>int add10(int num)<br/>{<br/>    return num + 10;<br/>}</span></pre><p id="b942" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的源文件只包含2个函数，<code class="fe mx my mz mp b">add5</code>和<code class="fe mx my mz mp b">add10</code>，这分别给唯一的输入参数增加了5或10。这是一段很小但功能齐全的代码，我们可以很容易地将其编译成一个目标文件:</p><pre class="le lf lg lh gt mo mp mq mr aw ms bi"><span id="4e33" class="lq lr iq mp b gy mt mu l mv mw">$ gcc -c obj.c <br/>$ ls<br/>obj.c  obj.o</span></pre><h2 id="9751" class="lq lr iq bd ls lt lu dn lv lw lx dp ly ko lz ma mb ks mc md me kw mf mg mh mi bi translated">将目标文件加载到进程内存中</h2><p id="5193" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">现在我们将尝试从目标文件中导入<code class="fe mx my mz mp b">add5</code>和<code class="fe mx my mz mp b">add10</code>函数并执行它们。当我们谈到执行一个目标文件时，我们的意思是将一个目标文件作为某种类型的库来使用。如上所述，当我们有一个利用外部共享库的可执行文件时，<em class="lb">动态加载器</em>会为我们将这些库加载到进程地址空间中。然而，对于目标文件，我们必须手动完成，因为最终我们不能执行不在操作系统RAM中的机器代码。因此，为了执行目标文件，我们仍然需要某种包装程序:</p><p id="c8ad" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb"> loader.c </em>:</p><pre class="le lf lg lh gt mo mp mq mr aw ms bi"><span id="40a3" class="lq lr iq mp b gy mt mu l mv mw">#include &lt;stdio.h&gt;<br/>#include &lt;stdint.h&gt;<br/>#include &lt;stdlib.h&gt;<br/>#include &lt;string.h&gt;<br/><br/>static void load_obj(void)<br/>{<br/>    /* load obj.o into memory */<br/>}<br/><br/>static void parse_obj(void)<br/>{<br/>    /* parse an object file and find add5 and add10 functions */<br/>}<br/><br/>static void execute_funcs(void)<br/>{<br/>    /* execute add5 and add10 with some inputs */<br/>}<br/><br/>int main(void)<br/>{<br/>    load_obj();<br/>    parse_obj();<br/>    execute_funcs();<br/><br/>    return 0;<br/>}</span></pre><p id="65d1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面是一个自包含的对象加载程序，有一些函数作为占位符。我们将在这篇文章中实现这些功能(并添加更多功能)。</p><p id="359b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，正如我们已经建立的，我们需要将我们的目标文件加载到进程地址空间中。我们可以将整个文件读入一个缓冲区，但这样效率不会很高。真实世界的对象文件可能很大，但是正如我们将在后面看到的，我们不需要对象的所有文件内容。因此，最好将文件改为<code class="fe mx my mz mp b"><a class="ae lc" href="https://man7.org/linux/man-pages/man2/mmap.2.html" rel="noopener ugc nofollow" target="_blank">mmap</a></code>:这样操作系统将在我们需要的时候从文件中缓慢地读取我们需要的部分。让我们实现<code class="fe mx my mz mp b">load_obj</code>功能:</p><p id="3c70" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb"> loader.c </em>:</p><pre class="le lf lg lh gt mo mp mq mr aw ms bi"><span id="92db" class="lq lr iq mp b gy mt mu l mv mw">...<br/>/* for open(2), fstat(2) */<br/>#include &lt;sys/types.h&gt;<br/>#include &lt;sys/stat.h&gt;<br/>#include &lt;fcntl.h&gt;<br/><br/>/* for close(2), fstat(2) */<br/>#include &lt;unistd.h&gt;<br/><br/>/* for mmap(2) */<br/>#include &lt;sys/mman.h&gt;<br/><br/>/* parsing ELF files */<br/>#include &lt;elf.h&gt;<br/><br/>/* for errno */<br/>#include &lt;errno.h&gt;<br/><br/>typedef union {<br/>    const Elf64_Ehdr *hdr;<br/>    const uint8_t *base;<br/>} objhdr;<br/><br/>/* obj.o memory address */<br/>static objhdr obj;<br/><br/>static void load_obj(void)<br/>{<br/>    struct stat sb;<br/><br/>    int fd = open("obj.o", O_RDONLY);<br/>    if (fd &lt;= 0) {<br/>        perror("Cannot open obj.o");<br/>        exit(errno);<br/>    }<br/><br/>    /* we need obj.o size for mmap(2) */<br/>    if (fstat(fd, &amp;sb)) {<br/>        perror("Failed to get obj.o info");<br/>        exit(errno);<br/>    }<br/><br/>    /* mmap obj.o into memory */<br/>    obj.base = mmap(NULL, sb.st_size, PROT_READ, MAP_PRIVATE, fd, 0);<br/>    if (obj.base == MAP_FAILED) {<br/>        perror("Maping obj.o failed");<br/>        exit(errno);<br/>    }<br/>    close(fd);<br/>}<br/>...</span></pre><p id="668a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们没有遇到任何错误，在<code class="fe mx my mz mp b">load_obj</code>执行之后，我们应该得到内存地址，它指向<code class="fe mx my mz mp b">obj</code>全局变量中<code class="fe mx my mz mp b">obj.o</code>的开始。值得注意的是，我们已经为<code class="fe mx my mz mp b">obj</code>变量创建了一个特殊的联合类型:我们稍后将解析<code class="fe mx my mz mp b">obj.o</code>(提前查看对象文件实际上是<a class="ae lc" href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format" rel="noopener ugc nofollow" target="_blank"> ELF文件</a>)，因此将引用地址作为<code class="fe mx my mz mp b">Elf64_Ehdr</code>(C语言中的ELF头结构)和一个字节指针(解析ELF文件涉及从文件开始计算字节偏移量)。</p><h2 id="fead" class="lq lr iq bd ls lt lu dn lv lw lx dp ly ko lz ma mb ks mc md me kw mf mg mh mi bi translated">窥视目标文件内部</h2><p id="cd66" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">要使用目标文件中的一些代码，我们需要首先找到它。正如我在上面透露的，目标文件实际上是<a class="ae lc" href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format" rel="noopener ugc nofollow" target="_blank"> ELF文件</a>(与Linux可执行文件和共享库的格式相同)，幸运的是，在标准<code class="fe mx my mz mp b">elf.h</code>头文件的帮助下，它们很容易在Linux上解析，该头文件包括许多与ELF文件结构相关的有用定义。但是我们实际上需要知道我们在寻找什么，所以需要对ELF文件有一个高层次的理解。</p><h2 id="3b8e" class="lq lr iq bd ls lt lu dn lv lw lx dp ly ko lz ma mb ks mc md me kw mf mg mh mi bi translated">ELF段和部分</h2><p id="4b5c" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">段(也称为程序头)和节可能是ELF文件的主要部分，通常是任何ELF教程的起点。然而，这两者之间经常有些混淆。不同的部分包含不同类型的ELF数据:可执行代码(这是我们在这篇文章中最感兴趣的)，常量数据，全局变量等。另一方面，段本身不包含任何数据——它们只是向操作系统描述如何正确地将段加载到RAM中，以使可执行文件正确工作。有些教程说“一个段可能包含0个或多个段”，这并不完全准确:段并不包含段，相反，它们只是向操作系统指示特定段应该加载到内存中的什么位置，以及该内存的访问模式是什么(读、写或执行):</p><figure class="le lf lg lh gt li gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi na"><img src="../Images/5350e35e6ad2324b2d6a06052be13da2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q0254olOJlrfFA4TxHqZtQ.png"/></div></div></figure><p id="d789" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，目标文件根本不包含任何段:目标文件并不意味着由操作系统直接加载。相反，假设它将与一些其他代码链接，所以ELF段通常由链接器生成，而不是编译器。我们可以通过使用<a class="ae lc" href="https://man7.org/linux/man-pages/man1/readelf.1.html" rel="noopener ugc nofollow" target="_blank"> readelf命令</a>来检查这一点:</p><pre class="le lf lg lh gt mo mp mq mr aw ms bi"><span id="f847" class="lq lr iq mp b gy mt mu l mv mw">$ readelf --segments obj.o<br/><br/>There are no program headers in this file.</span></pre><h2 id="73eb" class="lq lr iq bd ls lt lu dn lv lw lx dp ly ko lz ma mb ks mc md me kw mf mg mh mi bi translated">目标文件节</h2><p id="4543" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">同一个<a class="ae lc" href="https://man7.org/linux/man-pages/man1/readelf.1.html" rel="noopener ugc nofollow" target="_blank"> readelf命令</a>可以用来从我们的目标文件中获取所有的部分:</p><pre class="le lf lg lh gt mo mp mq mr aw ms bi"><span id="041b" class="lq lr iq mp b gy mt mu l mv mw">$ readelf --sections obj.o<br/>There are 11 section headers, starting at offset 0x268:<br/><br/>Section Headers:<br/>  [Nr] Name              Type             Address           Offset<br/>       Size              EntSize          Flags  Link  Info  Align<br/>  [ 0]                   NULL             0000000000000000  00000000<br/>       0000000000000000  0000000000000000           0     0     0<br/>  [ 1] .text             PROGBITS         0000000000000000  00000040<br/>       000000000000001e  0000000000000000  AX       0     0     1<br/>  [ 2] .data             PROGBITS         0000000000000000  0000005e<br/>       0000000000000000  0000000000000000  WA       0     0     1<br/>  [ 3] .bss              NOBITS           0000000000000000  0000005e<br/>       0000000000000000  0000000000000000  WA       0     0     1<br/>  [ 4] .comment          PROGBITS         0000000000000000  0000005e<br/>       000000000000001d  0000000000000001  MS       0     0     1<br/>  [ 5] .note.GNU-stack   PROGBITS         0000000000000000  0000007b<br/>       0000000000000000  0000000000000000           0     0     1<br/>  [ 6] .eh_frame         PROGBITS         0000000000000000  00000080<br/>       0000000000000058  0000000000000000   A       0     0     8<br/>  [ 7] .rela.eh_frame    RELA             0000000000000000  000001e0<br/>       0000000000000030  0000000000000018   I       8     6     8<br/>  [ 8] .symtab           SYMTAB           0000000000000000  000000d8<br/>       00000000000000f0  0000000000000018           9     8     8<br/>  [ 9] .strtab           STRTAB           0000000000000000  000001c8<br/>       0000000000000012  0000000000000000           0     0     1<br/>  [10] .shstrtab         STRTAB           0000000000000000  00000210<br/>       0000000000000054  0000000000000000           0     0     1<br/>Key to Flags:<br/>  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),<br/>  L (link order), O (extra OS processing required), G (group), T (TLS),<br/>  C (compressed), x (unknown), o (OS specific), E (exclude),<br/>  l (large), p (processor specific)</span></pre><p id="65a8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">网上有不同的教程详细描述了最流行的ELF部分。另一个很好的参考是<a class="ae lc" href="https://man7.org/linux/man-pages/man5/elf.5.html" rel="noopener ugc nofollow" target="_blank"> Linux联机帮助页项目</a>。它很方便，因为它描述了这两个部分的用途以及来自<code class="fe mx my mz mp b">elf.h</code>的C结构定义，这使得它成为解析ELF文件的一站式商店。然而，为了完整起见，下面是对ELF文件中可能遇到的最常见部分的简短描述:</p><ul class=""><li id="15d6" class="nb nc iq kh b ki kj kl km ko nd ks ne kw nf la ng nh ni nj bi translated">这个部分包含可执行代码(实际的机器代码，由编译器从我们的源代码中创建)。这一部分是这篇文章的主要关注点，因为它应该包含我们想要使用的<code class="fe mx my mz mp b">add5</code>和<code class="fe mx my mz mp b">add10</code>函数。</li><li id="12a9" class="nb nc iq kh b ki nk kl nl ko nm ks nn kw no la ng nh ni nj bi translated"><code class="fe mx my mz mp b">.data</code>和<code class="fe mx my mz mp b">.bss</code>:这些部分包含全局和静态局部变量。不同的是:<code class="fe mx my mz mp b">.data</code>有带初始值的变量(定义像<code class="fe mx my mz mp b">int foo = 5;</code>)而<code class="fe mx my mz mp b">.bss</code>只是为没有初始值的变量预留空间(定义像<code class="fe mx my mz mp b">int bar;</code>)。</li><li id="5d97" class="nb nc iq kh b ki nk kl nl ko nm ks nn kw no la ng nh ni nj bi translated"><code class="fe mx my mz mp b">.rodata</code>:这个部分包含常量数据(大部分是字符串或者字节数组)。例如，如果我们在代码中使用一个字符串文字(例如，对于<code class="fe mx my mz mp b">printf</code>或一些错误消息)，它将被存储在这里。注意，上面的输出中缺少了<code class="fe mx my mz mp b">.rodata</code>，因为我们在<code class="fe mx my mz mp b">obj.c</code>中没有使用任何字符串或常量字节数组。</li><li id="a135" class="nb nc iq kh b ki nk kl nl ko nm ks nn kw no la ng nh ni nj bi translated"><code class="fe mx my mz mp b">.symtab</code>:此部分包含目标文件中符号的信息:函数、全局变量、常量等。它还可能包含关于目标文件需要的外部符号的信息，比如外部库中需要的函数。</li><li id="e9fc" class="nb nc iq kh b ki nk kl nl ko nm ks nn kw no la ng nh ni nj bi translated"><code class="fe mx my mz mp b">.strtab</code>和<code class="fe mx my mz mp b">.shstrtab</code>:包含ELF文件的打包字符串。请注意，这些不是我们可以在源代码中定义的字符串(那些会转到<code class="fe mx my mz mp b">.rodata</code>部分)。这些是描述其他ELF结构名称的字符串，比如来自<code class="fe mx my mz mp b">.symtab</code>的符号，甚至是上表中的部分名称。ELF二进制格式旨在使其结构紧凑并具有固定的大小，因此所有的字符串都存储在一个地方，并且各自的数据结构只是在<code class="fe mx my mz mp b">.shstrtab</code>或<code class="fe mx my mz mp b">.strtab</code>部分中引用它们作为偏移量，而不是在本地存储整个字符串。</li></ul><h2 id="63cf" class="lq lr iq bd ls lt lu dn lv lw lx dp ly ko lz ma mb ks mc md me kw mf mg mh mi bi translated">第<code class="fe mx my mz mp b">.symtab</code>节</h2><p id="a6ba" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">此时，我们知道我们想要导入和执行的代码位于<code class="fe mx my mz mp b">obj.o</code>的<code class="fe mx my mz mp b">.text</code>部分。但是我们有两个功能，<code class="fe mx my mz mp b">add5</code>和<code class="fe mx my mz mp b">add10</code>，记得吗？在这个层次上，<code class="fe mx my mz mp b">.text</code>部分只是一个字节块——我们怎么知道这些函数的位置呢？这就是<code class="fe mx my mz mp b">.symtab</code>(“符号表”)派上用场的地方。它非常重要，在<a class="ae lc" href="https://man7.org/linux/man-pages/man1/readelf.1.html" rel="noopener ugc nofollow" target="_blank"> readelf </a>中有自己专用的参数:</p><pre class="le lf lg lh gt mo mp mq mr aw ms bi"><span id="e95d" class="lq lr iq mp b gy mt mu l mv mw">$ readelf --symbols obj.o<br/><br/>Symbol table '.symtab' contains 10 entries:<br/>   Num:    Value          Size Type    Bind   Vis      Ndx Name<br/>     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND<br/>     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS obj.c<br/>     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1<br/>     3: 0000000000000000     0 SECTION LOCAL  DEFAULT    2<br/>     4: 0000000000000000     0 SECTION LOCAL  DEFAULT    3<br/>     5: 0000000000000000     0 SECTION LOCAL  DEFAULT    5<br/>     6: 0000000000000000     0 SECTION LOCAL  DEFAULT    6<br/>     7: 0000000000000000     0 SECTION LOCAL  DEFAULT    4<br/>     8: 0000000000000000    15 FUNC    GLOBAL DEFAULT    1 add5<br/>     9: 000000000000000f    15 FUNC    GLOBAL DEFAULT    1 add10</span></pre><p id="4f2a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们忽略其他条目，只关注最后两行，因为它们方便地用<code class="fe mx my mz mp b">add5</code>和<code class="fe mx my mz mp b">add10</code>作为它们的符号名。事实上，这是关于我们功能的信息。除了名称之外，符号表还为我们提供了一些额外的元数据:</p><ul class=""><li id="1b20" class="nb nc iq kh b ki kj kl km ko nd ks ne kw nf la ng nh ni nj bi translated"><code class="fe mx my mz mp b">Ndx</code>列告诉我们符号所在部分的索引。我们可以将它与上面的部分表进行交叉检查，并确认这些功能确实位于<code class="fe mx my mz mp b">.text</code>(索引为<code class="fe mx my mz mp b">1</code>的部分)。</li><li id="f125" class="nb nc iq kh b ki nk kl nl ko nm ks nn kw no la ng nh ni nj bi translated"><code class="fe mx my mz mp b">Type</code>设置为<code class="fe mx my mz mp b">FUNC</code>确认这些确实是功能。</li><li id="9075" class="nb nc iq kh b ki nk kl nl ko nm ks nn kw no la ng nh ni nj bi translated"><code class="fe mx my mz mp b">Size</code>告诉我们每个函数的大小，但是这个信息在我们的上下文中不是很有用。对于<code class="fe mx my mz mp b">Bind</code>和<code class="fe mx my mz mp b">Vis</code>也是如此。</li><li id="2f53" class="nb nc iq kh b ki nk kl nl ko nm ks nn kw no la ng nh ni nj bi translated">可能最有用的信息是<code class="fe mx my mz mp b">Value</code>。这个名称容易引起误解，因为在这个上下文中，它实际上是从包含部分开始的偏移。也就是说，<code class="fe mx my mz mp b">add5</code>功能仅从<code class="fe mx my mz mp b">.text</code>的开头开始，而<code class="fe mx my mz mp b">add10</code>从第15个字节开始。</li></ul><p id="7bd9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以现在我们有了如何解析ELF文件并找到我们需要的函数的所有部分。</p><h2 id="08ff" class="lq lr iq bd ls lt lu dn lv lw lx dp ly ko lz ma mb ks mc md me kw mf mg mh mi bi translated">从目标文件中查找并执行函数</h2><p id="b74a" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">根据我们目前所学的知识，让我们定义一个如何从目标文件导入和执行函数的计划:</p><ol class=""><li id="e98c" class="nb nc iq kh b ki kj kl km ko nd ks ne kw nf la np nh ni nj bi translated">找到ELF区段表和<code class="fe mx my mz mp b">.shstrtab</code>区段(我们稍后需要<code class="fe mx my mz mp b">.shstrtab</code>通过名称在区段表中查找区段)。</li><li id="909c" class="nb nc iq kh b ki nk kl nl ko nm ks nn kw no la np nh ni nj bi translated">找到<code class="fe mx my mz mp b">.symtab</code>和<code class="fe mx my mz mp b">.strtab</code>部分(我们需要<code class="fe mx my mz mp b">.strtab</code>在<code class="fe mx my mz mp b">.symtab</code>中按名称查找符号)。</li><li id="9be8" class="nb nc iq kh b ki nk kl nl ko nm ks nn kw no la np nh ni nj bi translated">找到<code class="fe mx my mz mp b">.text</code>段，用可执行权限复制到RAM中。</li><li id="2a98" class="nb nc iq kh b ki nk kl nl ko nm ks nn kw no la np nh ni nj bi translated">从<code class="fe mx my mz mp b">.symtab</code>中找出<code class="fe mx my mz mp b">add5</code>和<code class="fe mx my mz mp b">add10</code>功能偏移量。</li><li id="3ea6" class="nb nc iq kh b ki nk kl nl ko nm ks nn kw no la np nh ni nj bi translated">执行<code class="fe mx my mz mp b">add5</code>和<code class="fe mx my mz mp b">add10</code>功能。</li></ol><p id="ff6a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们从添加更多的全局变量和实现<code class="fe mx my mz mp b">parse_obj</code>函数开始:</p><p id="74a3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb"> loader.c </em>:</p><pre class="le lf lg lh gt mo mp mq mr aw ms bi"><span id="ba0e" class="lq lr iq mp b gy mt mu l mv mw">...<br/><br/>/* sections table */<br/>static const Elf64_Shdr *sections;<br/>static const char *shstrtab = NULL;<br/><br/>/* symbols table */<br/>static const Elf64_Sym *symbols;<br/>/* number of entries in the symbols table */<br/>static int num_symbols;<br/>static const char *strtab = NULL;<br/><br/>...<br/><br/>static void parse_obj(void)<br/>{<br/>    /* the sections table offset is encoded in the ELF header */<br/>    sections = (const Elf64_Shdr *)(obj.base + obj.hdr-&gt;e_shoff);<br/>    /* the index of `.shstrtab` in the sections table is encoded in the ELF header<br/>     * so we can find it without actually using a name lookup<br/>     */<br/>    shstrtab = (const char *)(obj.base + sections[obj.hdr-&gt;e_shstrndx].sh_offset);<br/><br/>...<br/>}<br/><br/>...</span></pre><p id="c6fd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们已经引用了sections表和<code class="fe mx my mz mp b">.shstrtab</code>部分，我们可以通过它们的名称查找其他部分。让我们为此创建一个助手函数:</p><p id="57a9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb"> loader.c </em>:</p><pre class="le lf lg lh gt mo mp mq mr aw ms bi"><span id="b03e" class="lq lr iq mp b gy mt mu l mv mw">...<br/><br/>static const Elf64_Shdr *lookup_section(const char *name)<br/>{<br/>    size_t name_len = strlen(name);<br/><br/>    /* number of entries in the sections table is encoded in the ELF header */<br/>    for (Elf64_Half i = 0; i &lt; obj.hdr-&gt;e_shnum; i++) {<br/>        /* sections table entry does not contain the string name of the section<br/>         * instead, the `sh_name` parameter is an offset in the `.shstrtab`<br/>         * section, which points to a string name<br/>         */<br/>        const char *section_name = shstrtab + sections[i].sh_name;<br/>        size_t section_name_len = strlen(section_name);<br/><br/>        if (name_len == section_name_len &amp;&amp; !strcmp(name, section_name)) {<br/>            /* we ignore sections with 0 size */<br/>            if (sections[i].sh_size)<br/>                return sections + i;<br/>        }<br/>    }<br/><br/>    return NULL;<br/>}<br/><br/>...</span></pre><p id="fb50" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用我们新的助手函数，我们现在可以找到<code class="fe mx my mz mp b">.symtab</code>和<code class="fe mx my mz mp b">.strtab</code>部分:</p><p id="a685" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb"> loader.c </em>:</p><pre class="le lf lg lh gt mo mp mq mr aw ms bi"><span id="83f8" class="lq lr iq mp b gy mt mu l mv mw">...<br/><br/>static void parse_obj(void)<br/>{<br/>...<br/><br/>    /* find the `.symtab` entry in the sections table */<br/>    const Elf64_Shdr *symtab_hdr = lookup_section(".symtab");<br/>    if (!symtab_hdr) {<br/>        fputs("Failed to find .symtab\n", stderr);<br/>        exit(ENOEXEC);<br/>    }<br/><br/>    /* the symbols table */<br/>    symbols = (const Elf64_Sym *)(obj.base + symtab_hdr-&gt;sh_offset);<br/>    /* number of entries in the symbols table = table size / entry size */<br/>    num_symbols = symtab_hdr-&gt;sh_size / symtab_hdr-&gt;sh_entsize;<br/><br/>    const Elf64_Shdr *strtab_hdr = lookup_section(".strtab");<br/>    if (!strtab_hdr) {<br/>        fputs("Failed to find .strtab\n", stderr);<br/>        exit(ENOEXEC);<br/>    }<br/><br/>    strtab = (const char *)(obj.base + strtab_hdr-&gt;sh_offset);<br/>    <br/>...<br/>}<br/><br/>...</span></pre><p id="e851" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，让我们来关注一下<code class="fe mx my mz mp b">.text</code>部分。我们在前面的计划中注意到，仅仅定位目标文件中的<code class="fe mx my mz mp b">.text</code>部分是不够的，就像我们对其他部分所做的那样。我们需要将它复制到RAM中具有可执行权限的不同位置。这有几个原因，但以下是主要原因:</p><ul class=""><li id="d9fc" class="nb nc iq kh b ki kj kl km ko nd ks ne kw nf la ng nh ni nj bi translated">许多CPU架构要么不允许执行机器码，机器码在内存(x86系统为4kb)中<a class="ae lc" href="https://en.wikipedia.org/wiki/Page_(computer_memory)" rel="noopener ugc nofollow" target="_blank">未对齐，要么以性能损失为代价执行机器码。然而，ELF文件中的<code class="fe mx my mz mp b">.text</code>部分并不保证位于页面对齐的偏移量处，因为ELF文件的磁盘版本旨在紧凑而非方便。</a></li><li id="13a6" class="nb nc iq kh b ki nk kl nl ko nm ks nn kw no la ng nh ni nj bi translated">我们可能需要修改<code class="fe mx my mz mp b">.text</code>部分中的一些字节来执行重定位(在这种情况下我们不需要这样做，但是在以后的文章中将会处理重定位)。例如，如果我们在映射ELF文件时忘记使用<code class="fe mx my mz mp b">MAP_PRIVATE</code>标志，我们的修改可能会传播到底层文件并破坏它。</li><li id="12f8" class="nb nc iq kh b ki nk kl nl ko nm ks nn kw no la ng nh ni nj bi translated">最后，运行时需要的不同部分，如<code class="fe mx my mz mp b">.text</code>、<code class="fe mx my mz mp b">.data</code>、<code class="fe mx my mz mp b">.bss</code>和<code class="fe mx my mz mp b">.rodata</code>，需要不同的内存权限位:<code class="fe mx my mz mp b">.text</code>部分的内存需要既是可读的又是可执行的，但不能是可写的(让内存既可写又可执行被认为是一种糟糕的安全实践)。<code class="fe mx my mz mp b">.data</code>和<code class="fe mx my mz mp b">.bss</code>部分需要可读可写以支持全局变量，但不是可执行的。<code class="fe mx my mz mp b">.rodata</code>部分应该是只读的，因为它的目的是保存常量数据。为了支持这一点，必须在页面边界上分配每个部分，因为我们只能在整个页面上设置内存权限位，而不能在自定义范围内设置。因此，我们需要为这些部分创建新的、页面对齐的内存范围，并将数据复制到那里。</li></ul><p id="dcff" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要创建<code class="fe mx my mz mp b">.text</code>部分的页面对齐副本，首先我们需要知道页面大小。许多程序通常只是将页面大小硬编码为4096 (4千字节)，但我们不应该依赖于此。虽然它对于大多数x86系统来说是准确的，但其他CPU架构，如arm64，可能有不同的页面大小。所以硬编码一个页面大小可能会使我们的程序不可移植。让我们找出页面大小并将其存储在另一个全局变量中:</p><p id="2504" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb"> loader.c </em>:</p><pre class="le lf lg lh gt mo mp mq mr aw ms bi"><span id="964b" class="lq lr iq mp b gy mt mu l mv mw">...<br/><br/>static uint64_t page_size;<br/><br/>static inline uint64_t page_align(uint64_t n)<br/>{<br/>    return (n + (page_size - 1)) &amp; ~(page_size - 1);<br/>}<br/><br/>...<br/><br/>static void parse_obj(void)<br/>{<br/>...<br/><br/>    /* get system page size */<br/>    page_size = sysconf(_SC_PAGESIZE);<br/><br/>...<br/>}<br/><br/>...</span></pre><p id="e409" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意，我们还添加了一个方便的函数<code class="fe mx my mz mp b">page_align</code>，它将把传入的数字四舍五入到下一页对齐的边界。接下来，回到<code class="fe mx my mz mp b">.text</code>部分。作为提醒，我们需要:</p><ol class=""><li id="8eea" class="nb nc iq kh b ki kj kl km ko nd ks ne kw nf la np nh ni nj bi translated">在节表中找到<code class="fe mx my mz mp b">.text</code>节元数据。</li><li id="5231" class="nb nc iq kh b ki nk kl nl ko nm ks nn kw no la np nh ni nj bi translated">分配一块内存来保存<code class="fe mx my mz mp b">.text</code>部分副本。</li><li id="010f" class="nb nc iq kh b ki nk kl nl ko nm ks nn kw no la np nh ni nj bi translated">实际上将<code class="fe mx my mz mp b">.text</code>段复制到新分配的内存中。</li><li id="8a73" class="nb nc iq kh b ki nk kl nl ko nm ks nn kw no la np nh ni nj bi translated">使<code class="fe mx my mz mp b">.text</code>部分可执行，这样我们以后可以从它调用函数。</li></ol><p id="a111" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是上述步骤的实现:</p><p id="4812" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb"> loader.c </em>:</p><pre class="le lf lg lh gt mo mp mq mr aw ms bi"><span id="c176" class="lq lr iq mp b gy mt mu l mv mw">...<br/><br/>/* runtime base address of the imported code */<br/>static uint8_t *text_runtime_base;<br/><br/>...<br/><br/>static void parse_obj(void)<br/>{<br/>...<br/><br/>    /* find the `.text` entry in the sections table */<br/>    const Elf64_Shdr *text_hdr = lookup_section(".text");<br/>    if (!text_hdr) {<br/>        fputs("Failed to find .text\n", stderr);<br/>        exit(ENOEXEC);<br/>    }<br/><br/>    /* allocate memory for `.text` copy rounding it up to whole pages */<br/>    text_runtime_base = mmap(NULL, page_align(text_hdr-&gt;sh_size), PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);<br/>    if (text_runtime_base == MAP_FAILED) {<br/>        perror("Failed to allocate memory for .text");<br/>        exit(errno);<br/>    }<br/><br/>    /* copy the contents of `.text` section from the ELF file */<br/>    memcpy(text_runtime_base, obj.base + text_hdr-&gt;sh_offset, text_hdr-&gt;sh_size);<br/><br/>    /* make the `.text` copy readonly and executable */<br/>    if (mprotect(text_runtime_base, page_align(text_hdr-&gt;sh_size), PROT_READ | PROT_EXEC)) {<br/>        perror("Failed to make .text executable");<br/>        exit(errno);<br/>    }<br/>}<br/><br/>...</span></pre><p id="ec91" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们已经有了定位一个函数的地址所需要的所有部分。让我们为它写一个助手:</p><p id="2093" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb"> loader.c </em>:</p><pre class="le lf lg lh gt mo mp mq mr aw ms bi"><span id="8708" class="lq lr iq mp b gy mt mu l mv mw">...<br/><br/>static void *lookup_function(const char *name)<br/>{<br/>    size_t name_len = strlen(name);<br/><br/>    /* loop through all the symbols in the symbol table */<br/>    for (int i = 0; i &lt; num_symbols; i++) {<br/>        /* consider only function symbols */<br/>        if (ELF64_ST_TYPE(symbols[i].st_info) == STT_FUNC) {<br/>            /* symbol table entry does not contain the string name of the symbol<br/>             * instead, the `st_name` parameter is an offset in the `.strtab`<br/>             * section, which points to a string name<br/>             */<br/>            const char *function_name = strtab + symbols[i].st_name;<br/>            size_t function_name_len = strlen(function_name);<br/><br/>            if (name_len == function_name_len &amp;&amp; !strcmp(name, function_name)) {<br/>                /* st_value is an offset in bytes of the function from the<br/>                 * beginning of the `.text` section<br/>                 */<br/>                return text_runtime_base + symbols[i].st_value;<br/>            }<br/>        }<br/>    }<br/><br/>    return NULL;<br/>}<br/><br/>...</span></pre><p id="079e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们可以实现<code class="fe mx my mz mp b">execute_funcs</code>函数来导入和执行目标文件中的代码:</p><p id="3950" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb"> loader.c </em>:</p><pre class="le lf lg lh gt mo mp mq mr aw ms bi"><span id="f94c" class="lq lr iq mp b gy mt mu l mv mw">...<br/><br/>static void execute_funcs(void)<br/>{<br/>    /* pointers to imported add5 and add10 functions */<br/>    int (*add5)(int);<br/>    int (*add10)(int);<br/><br/>    add5 = lookup_function("add5");<br/>    if (!add5) {<br/>        fputs("Failed to find add5 function\n", stderr);<br/>        exit(ENOENT);<br/>    }<br/><br/>    puts("Executing add5...");<br/>    printf("add5(%d) = %d\n", 42, add5(42));<br/><br/>    add10 = lookup_function("add10");<br/>    if (!add10) {<br/>        fputs("Failed to find add10 function\n", stderr);<br/>        exit(ENOENT);<br/>    }<br/><br/>    puts("Executing add10...");<br/>    printf("add10(%d) = %d\n", 42, add10(42));<br/>}<br/><br/>...</span></pre><p id="6aae" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们编译我们的加载程序，并确保它按预期工作:</p><pre class="le lf lg lh gt mo mp mq mr aw ms bi"><span id="d394" class="lq lr iq mp b gy mt mu l mv mw">$ gcc -o loader loader.c <br/>$ ./loader <br/>Executing add5...<br/>add5(42) = 47<br/>Executing add10...<br/>add10(42) = 52</span></pre><p id="bd48" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">瞧啊。我们已经成功地从<code class="fe mx my mz mp b">obj.o</code>导入代码并执行了它。当然，上面的例子是简化的:目标文件中的代码是自包含的，不引用任何全局变量或常量，也没有任何外部依赖。在未来的帖子中，我们将研究更复杂的代码以及如何处理这种情况。</p><h2 id="a35f" class="lq lr iq bd ls lt lu dn lv lw lx dp ly ko lz ma mb ks mc md me kw mf mg mh mi bi translated">安全考虑</h2><p id="1364" class="pw-post-body-paragraph kf kg iq kh b ki mj jr kk kl mk ju kn ko ml kq kr ks mm ku kv kw mn ky kz la ij bi translated">处理外部输入，就像从上面的磁盘中解析ELF文件一样，应该小心处理。来自<em class="lb"> loader.c </em>的代码在解析目标文件时省略了大量的边界检查和额外的ELF完整性检查。出于本文的目的，对代码进行了简化，但很可能还没有准备好投入生产，因为它可能会被特制的恶意输入所利用。仅用于教育目的！</p><p id="3084" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这篇文章的完整源代码可以在<a class="ae lc" href="https://github.com/cloudflare/cloudflare-blog/tree/master/2021-03-obj-file/1" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p></div></div>    
</body>
</html>