<html>
<head>
<title>Beyond the Single-Responsibility Principle</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">超越单一责任原则</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/beyond-the-single-responsibility-principle-d4103418e2e2?source=collection_archive---------31-----------------------#2021-01-12">https://levelup.gitconnected.com/beyond-the-single-responsibility-principle-d4103418e2e2?source=collection_archive---------31-----------------------#2021-01-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7d00" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">最著名的坚实原则以及它如何改变你的思维定势。</h2></div><p id="fe9e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi le translated">当谈到讨论<a class="ae ln" href="https://en.wikipedia.org/wiki/SOLID" rel="noopener ugc nofollow" target="_blank">坚实的原则</a>时，通常首先想到的是<a class="ae ln" href="https://en.wikipedia.org/wiki/Single-responsibility_principle" rel="noopener ugc nofollow" target="_blank">单一责任原则</a>，或简称SRP，首字母缩写。它变得如此明显，以至于没有人真正去思考它，它的重要性在今天被认为是理所当然的。</p><p id="ea9f" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是罗伯特·c·马丁的原创表达(又名鲍勃叔叔:)</p><blockquote class="lo lp lq"><p id="359e" class="ki kj lr kk b kl km ju kn ko kp jx kq ls ks kt ku lt kw kx ky lu la lb lc ld im bi translated">一个类应该只有一个改变的理由。</p></blockquote><figure class="lw lx ly lz gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="gh gi lv"><img src="../Images/29b72de2c498eaf03337dc7a85b710db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0PgsP5g5mg71CvPR18ZP-w.jpeg"/></div></div><figcaption class="mh mi gj gh gi mj mk bd b be z dk translated">照片由<a class="ae ln" href="https://unsplash.com/@callmehangry?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">叫我汉格里·🇫🇷</a>在<a class="ae ln" href="https://unsplash.com/s/photos/single?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></figcaption></figure><p id="8971" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在我早期编程的日子里，这个简单的想法给我留下了深刻的印象，以至于它成为了我的工作思维定势。现在它对我来说不仅仅意味着“编写小的、可测试的类”。我相信它可以应用于软件开发的任何方面。我会试着给你看。</p><h1 id="fc38" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">密码</h1><h2 id="aa01" class="nd mm it bd mn ne nf dn mr ng nh dp mv kr ni nj mx kv nk nl mz kz nm nn nb no bi translated">变量</h2><p id="b543" class="pw-post-body-paragraph ki kj it kk b kl np ju kn ko nq jx kq kr nr kt ku kv ns kx ky kz nt lb lc ld im bi translated">让我们从一些小而简单的事情开始。这是一个改编自<a class="ae ln" href="https://stevemcconnell.com" rel="noopener ugc nofollow" target="_blank">史蒂夫·麦康奈尔</a>的<a class="ae ln" href="https://www.amazon.com/Code-Complete-Practical-Handbook-Construction/dp/0735619670" rel="noopener ugc nofollow" target="_blank">代码全集</a>的例子:</p><p id="5dce" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="lr">(所有代码片段在</em><a class="ae ln" href="https://swift.org" rel="noopener ugc nofollow" target="_blank"><em class="lr">Swift</em></a><em class="lr">中给出)。)</em></p><pre class="lw lx ly lz gt nu nv nw nx aw ny bi"><span id="eb10" class="nd mm it nv b gy nz oa l ob oc"><strong class="nv iu">import</strong> Foundation</span><span id="8e1b" class="nd mm it nv b gy od oa l ob oc">// Qadratic equation: a * x^2 + b * x + c + 0<br/><strong class="nv iu">let</strong> a = 1.0<br/><strong class="nv iu">let</strong> b = -8.0<br/><strong class="nv iu">let</strong> c = 12.0</span><span id="0413" class="nd mm it nv b gy od oa l ob oc"><strong class="nv iu">var</strong> temp = sqrt(pow(b, 2.0) - 4.0 * a * c) // Discriminant.<br/><strong class="nv iu">var</strong> root1 = (-b + temp) / (2.0 * a)<br/><strong class="nv iu">var</strong> root2 = (-b - temp) / (2.0 * a)</span><span id="628e" class="nd mm it nv b gy od oa l ob oc">// Do work.</span><span id="f2e0" class="nd mm it nv b gy od oa l ob oc">// Interchange roots.<br/>temp = root1<br/>root1 = root2<br/>root2 = temp</span></pre><p id="5e5d" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">重用变量会使代码更难理解。它还迫使以笨拙的方式命名变量，这反过来会对可读性产生负面影响。更不用说一些重复使用变量的情况可能导致的副作用了。</p><p id="3dc6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">(考虑这样的情况，当一个变量被初始化一次，然后它参与一些工作，在那里它被赋予一个新的值。然后，有了新的值，它被进一步传递，以参与另一项工作。更改初始值会影响使用该变量的两段代码。而第二个可能是不想要的，甚至是不被注意的。)</p><p id="0e52" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是一个稍微安全和可读的版本:</p><pre class="lw lx ly lz gt nu nv nw nx aw ny bi"><span id="578a" class="nd mm it nv b gy nz oa l ob oc"><strong class="nv iu">import</strong> Foundation</span><span id="9e90" class="nd mm it nv b gy od oa l ob oc">// Qadratic equation: a * x^2 + b * x + c + 0<br/><strong class="nv iu">let</strong> a = 1.0<br/><strong class="nv iu">let</strong> b = -8.0<br/><strong class="nv iu">let</strong> c = 12.0</span><span id="d3fb" class="nd mm it nv b gy od oa l ob oc"><strong class="nv iu">let</strong> discriminant = sqrt(pow(b, 2.0) - 4.0 * a * c)<br/><strong class="nv iu">var</strong> root1 = (-b + discriminant) / (2.0 * a)<br/><strong class="nv iu">var</strong> root2 = (-b - discriminant) / (2.0 * a)</span><span id="fe65" class="nd mm it nv b gy od oa l ob oc">// Do work.</span><span id="7315" class="nd mm it nv b gy od oa l ob oc">// Interchange roots.<br/><strong class="nv iu">let</strong> temp = root1<br/>root1 = root2<br/>root2 = temp</span></pre><h2 id="cbb2" class="nd mm it bd mn ne nf dn mr ng nh dp mv kr ni nj mx kv nk nl mz kz nm nn nb no bi translated">评论</h2><p id="9abe" class="pw-post-body-paragraph ki kj it kk b kl np ju kn ko nq jx kq kr nr kt ku kv ns kx ky kz nt lb lc ld im bi translated">考虑上面的代码注释。如果把它们合二为一呢？</p><pre class="lw lx ly lz gt nu nv nw nx aw ny bi"><span id="a751" class="nd mm it nv b gy nz oa l ob oc"><strong class="nv iu">import</strong> Foundation</span><span id="bd2e" class="nd mm it nv b gy od oa l ob oc">/*<br/>Solves quadratic equation: a * x^2 + b * x + c + 0<br/>(Does some work.)<br/>Then interchanges equation's roots values.<br/>*/</span><span id="4788" class="nd mm it nv b gy od oa l ob oc"><strong class="nv iu">let</strong> a = 1.0<br/><strong class="nv iu">let</strong> b = -8.0<br/><strong class="nv iu">let</strong> c = 12.0</span><span id="92e2" class="nd mm it nv b gy od oa l ob oc"><strong class="nv iu">var</strong> temp = sqrt(pow(b, 2.0) - 4.0 * a * c) // Discriminant.<br/><strong class="nv iu">var</strong> root1 = (-b + temp) / (2.0 * a)<br/><strong class="nv iu">var</strong> root2 = (-b - temp) / (2.0 * a)</span><span id="2581" class="nd mm it nv b gy od oa l ob oc">// Do work.</span><span id="506b" class="nd mm it nv b gy od oa l ob oc">temp = root1<br/>root1 = root2<br/>root2 = temp</span></pre><p id="6b5e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果交换代码消失了呢？最有可能的是，评论会被忽略，不变，变得过时。这就是为什么，主要是，你在写评论的时候也要抓住SRP。当然，首先要记住，良好的、自我记录的代码总是比注释好。</p><h2 id="ab86" class="nd mm it bd mn ne nf dn mr ng nh dp mv kr ni nj mx kv nk nl mz kz nm nn nb no bi translated">试验</h2><p id="a0a3" class="pw-post-body-paragraph ki kj it kk b kl np ju kn ko nq jx kq kr nr kt ku kv ns kx ky kz nt lb lc ld im bi translated">再次考虑上面的代码。你如何测试它？很难检查整部作品中的一切是否都像预期的那样工作。这就是为什么编写一次只检查一件事情的单元测试被认为是一个好的实践:</p><pre class="lw lx ly lz gt nu nv nw nx aw ny bi"><span id="a1f2" class="nd mm it nv b gy nz oa l ob oc"><strong class="nv iu">func</strong> testDiscriminantCalcualtion() {<br/>  // ...<br/>}</span><span id="e3cd" class="nd mm it nv b gy od oa l ob oc"><strong class="nv iu">func</strong> testQuadraticEquationRootsWhenDiscriminantIsPositive() {<br/>  // ...<br/>}</span><span id="b7aa" class="nd mm it nv b gy od oa l ob oc"><strong class="nv iu">func</strong> testQuadraticEquationRootWhenDiscriminantIsZero() {<br/>  // ...<br/>}</span><span id="9303" class="nd mm it nv b gy od oa l ob oc"><strong class="nv iu">func</strong> testQuadraticEquationHasNoRootsWhenDiscriminantIsNegative() {<br/>  // ...<br/>}</span><span id="ef67" class="nd mm it nv b gy od oa l ob oc"><strong class="nv iu">func</strong> testSwappingRoots() {<br/>  // ...<br/>}</span></pre><p id="108e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">把单元测试很好地分开，如果有什么东西坏了，你会确切地知道是什么。</p><h2 id="1b08" class="nd mm it bd mn ne nf dn mr ng nh dp mv kr ni nj mx kv nk nl mz kz nm nn nb no bi translated">功能/方法</h2><p id="1bb3" class="pw-post-body-paragraph ki kj it kk b kl np ju kn ko nq jx kq kr nr kt ku kv ns kx ky kz nt lb lc ld im bi translated">测试的例子让我们明白了分离所有类方法和函数的原则:</p><pre class="lw lx ly lz gt nu nv nw nx aw ny bi"><span id="1d49" class="nd mm it nv b gy nz oa l ob oc"><strong class="nv iu">import</strong> Foundation</span><span id="d86c" class="nd mm it nv b gy od oa l ob oc">/// ax2 + bx + c = 0<br/><strong class="nv iu">func</strong> findQuadraticEquationRoots(a: Double,<br/>                                b: Double,<br/>                                c: Double) -&gt; [Double] {<br/>  <strong class="nv iu">let</strong> discriminant = findDiscriminant(a: a, b: b, c: c)</span><span id="5ce6" class="nd mm it nv b gy od oa l ob oc">  <strong class="nv iu">if</strong> discriminant &lt; 0 {<br/>    return []<br/>  }<br/>  <strong class="nv iu">if</strong> discriminant == 0 {<br/>    let root = -b / (2.0 * a)<br/>    <strong class="nv iu">return</strong> [root]<br/>  }</span><span id="feb0" class="nd mm it nv b gy od oa l ob oc">  <strong class="nv iu">let</strong> root1 = (-b + discriminant) / (2.0 * a)<br/>  <strong class="nv iu">let</strong> root2 = (-b - discriminant) / (2.0 * a)</span><span id="16fc" class="nd mm it nv b gy od oa l ob oc">  <strong class="nv iu">return</strong> [root1,<br/>          root2]<br/>}</span><span id="f98b" class="nd mm it nv b gy od oa l ob oc"><strong class="nv iu">func</strong> findDiscriminant(a: Double, b: Double, c: Double) -&gt; Double {<br/>  <strong class="nv iu">return</strong> sqrt(pow(b, 2.0) - 4.0 * a * c)<br/>}</span><span id="5a83" class="nd mm it nv b gy od oa l ob oc"><strong class="nv iu">let</strong> a = 1.0<br/><strong class="nv iu">let</strong> b = -8.0<br/><strong class="nv iu">let</strong> c = 12.0</span><span id="9a1d" class="nd mm it nv b gy od oa l ob oc"><strong class="nv iu">let</strong> roots = findQuadraticEquationRoots(a: a, b: b, c: c)<br/><strong class="nv iu">var</strong> root1 = roots[0]<br/><strong class="nv iu">var</strong> root2 = roots[1]</span><span id="a18c" class="nd mm it nv b gy od oa l ob oc">// Do work.</span><span id="e74c" class="nd mm it nv b gy od oa l ob oc">swap(&amp;root1, &amp;root2)</span></pre><p id="2a06" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这样，上面所有的测试都可以很容易地编码。当然，这不仅仅是可测试性的问题。众所周知，程序员读代码的时间比写代码的时间多。方法关注点的分离也使得代码更具可读性(从而更易维护)。)</p><p id="2481" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">瞄准没有副作用的方法，所谓的<a class="ae ln" href="https://en.wikipedia.org/wiki/Pure_function" rel="noopener ugc nofollow" target="_blank">纯函数</a>，将使你的代码更不容易出错，错误更容易本地化。</p><h2 id="1e63" class="nd mm it bd mn ne nf dn mr ng nh dp mv kr ni nj mx kv nk nl mz kz nm nn nb no bi translated">班级</h2><p id="378a" class="pw-post-body-paragraph ki kj it kk b kl np ju kn ko nq jx kq kr nr kt ku kv ns kx ky kz nt lb lc ld im bi translated"><em class="lr">(作为一个概括，我这里的类不是指，嗯，只是类。我是说所有时代的味道。即在Swift中，它们是</em> <code class="fe oe of og nv b">class</code> <em class="lr"> es、</em> <code class="fe oe of og nv b">struct</code> <em class="lr"> s和</em> <code class="fe oe of og nv b">enum</code> <em class="lr"> s.) </em></p><p id="3382" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以，经典的SRP来了。这个，希望不需要解释。让你的班级只负责一件事。这将使它们更容易理解，可测试，最重要的是，可组合。也就是说，如果一些需求发生了变化，它不会影响应用程序的其他部分。这正是“改变的一个理由”的含义。</p><h2 id="8666" class="nd mm it bd mn ne nf dn mr ng nh dp mv kr ni nj mx kv nk nl mz kz nm nn nb no bi translated">模块</h2><p id="2de2" class="pw-post-body-paragraph ki kj it kk b kl np ju kn ko nq jx kq kr nr kt ku kv ns kx ky kz nt lb lc ld im bi translated">微服务、框架、后端-前端分离，所有这些(以及更多)都是模块化的味道。单独构建系统的不同部分，使它们能够独立地组合和部署，这一直被认为是一个好的实践。客户端API、本地数据库层、业务规则集是独立模块的良好候选。有时候，独立地分离和组织代码是很棘手的，但是，总的来说，这是值得的。</p><h1 id="2413" class="ml mm it bd mn mo mp mq mr ms mt mu mv jz mw ka mx kc my kd mz kf na kg nb nc bi translated">发展</h1><p id="9d66" class="pw-post-body-paragraph ki kj it kk b kl np ju kn ko nq jx kq kr nr kt ku kv ns kx ky kz nt lb lc ld im bi translated">在我看来，SRP不仅仅是编程。牢记这一点有助于组织你的工作，让你的日常工作更有条理。</p><h2 id="f832" class="nd mm it bd mn ne nf dn mr ng nh dp mv kr ni nj mx kv nk nl mz kz nm nn nb no bi translated">承诺</h2><p id="34d7" class="pw-post-body-paragraph ki kj it kk b kl np ju kn ko nq jx kq kr nr kt ku kv ns kx ky kz nt lb lc ld im bi translated">这是大多数开发人员都听过的一个显而易见的问题。然而，从我的经验来看，很少有人真正遵循它。这里有一个:</p><blockquote class="lo lp lq"><p id="6449" class="ki kj lr kk b kl km ju kn ko kp jx kq ls ks kt ku lt kw kx ky lu la lb lc ld im bi translated">尝试让每个提交成为一个逻辑上独立的变更集。</p></blockquote><p id="ee77" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是来自<a class="ae ln" href="https://git-scm.com/book/en/v2/Distributed-Git-Contributing-to-a-Project" rel="noopener ugc nofollow" target="_blank">Git官方网站</a>的推荐。我会把它重新表述为“尝试让每个<a class="ae ln" href="https://git-scm.com/docs/git-commit" rel="noopener ugc nofollow" target="_blank">提交</a>原子化。”虽然在95%的情况下，这种额外的努力不会被注意到，但最终会有回报的。<a class="ae ln" href="https://git-scm.com/docs/git-revert" rel="noopener ugc nofollow" target="_blank">恢复</a>、<a class="ae ln" href="https://git-scm.com/docs/git-cherry-pick" rel="noopener ugc nofollow" target="_blank">精选</a>、<a class="ae ln" href="https://git-scm.com/docs/git-rebase" rel="noopener ugc nofollow" target="_blank">重定基础</a>和bug搜索git历史简洁明了，用原子提交构建，一切都简单多了。</p><p id="26db" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，如果提交的更改需要单元测试更新或文档修改，我强烈建议您将所有这些附属工作包括到提交中。这将确保在您需要恢复或重置主提交时不会忘记它。</p><h2 id="bcfe" class="nd mm it bd mn ne nf dn mr ng nh dp mv kr ni nj mx kv nk nl mz kz nm nn nb no bi translated">拉式请求/票证</h2><p id="354b" class="pw-post-body-paragraph ki kj it kk b kl np ju kn ko nq jx kq kr nr kt ku kv ns kx ky kz nt lb lc ld im bi translated">关于提交的讨论完美地扩展到了分支(或吉拉票)。)如果您不想通过提交来跟踪小特性，以便禁用它们，您最好遵守与提交相同的规则。</p><h2 id="e9ee" class="nd mm it bd mn ne nf dn mr ng nh dp mv kr ni nj mx kv nk nl mz kz nm nn nb no bi translated">应用程序</h2><p id="a349" class="pw-post-body-paragraph ki kj it kk b kl np ju kn ko nq jx kq kr nr kt ku kv ns kx ky kz nt lb lc ld im bi translated">最后，这是上述所有小事的原因。也是博文中最有争议的部分。</p><p id="4add" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">就个人而言，我不喜欢流行应用程序的发展方式。记得<a class="ae ln" href="https://foursquare.com" rel="noopener ugc nofollow" target="_blank"> Foursquare </a>吗？它曾经是一个很好很简单的应用程序，让你的朋友知道你现在在哪里玩得开心。然而，功能越来越多，这个应用变成了两个——four square和Swarm。在那之后不久，从我的印象中，整个想法变得过时了。</p><p id="94d6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一个更有争议的例子是著名的Instagram。当它只是我朋友的照片时，我真的很喜欢它。后来他们添加了视频，然后是故事，广告，很多东西。尽管如此，这款应用仍然非常受欢迎。然而，当我现在打开它时，它并不像过去那样有趣。我就像一个得到了一艘<a class="ae ln" href="https://www.nasa.gov" rel="noopener ugc nofollow" target="_blank"> NASA </a>星际飞船而不是一套<a class="ae ln" href="https://www.lego.com/" rel="noopener ugc nofollow" target="_blank">乐高</a>火箭套件的小孩一样，跌倒在那里。</p><p id="71d1" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我在这里的观点是，应用程序应该有一个清晰的想法，它们应该简单和令人愉快，而不是充斥着所有可以想象的功能的怪物。当然，你很容易不同意我的观点。我不是营销专家，我只是个工程师。但我认为，任何应用程序都必须首先关注其主旨。</p></div><div class="ab cl oh oi hx oj" role="separator"><span class="ok bw bk ol om on"/><span class="ok bw bk ol om on"/><span class="ok bw bk ol om"/></div><div class="im in io ip iq"><p id="c78b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当然，你应用这些原则的程度取决于环境。永远不要忘记思考你当前的目标，牢记常识和原因。</p></div><div class="ab cl oh oi hx oj" role="separator"><span class="ok bw bk ol om on"/><span class="ok bw bk ol om on"/><span class="ok bw bk ol om"/></div><div class="im in io ip iq"><p id="e338" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你喜欢阅读我(和其他作者)在Medium上的博客，你可以<strong class="kk iu">成为一名正式的Medium成员</strong>(如果还没有)<a class="ae ln" href="https://lazarevzubov.medium.com/membership" rel="noopener"> <strong class="kk iu">这里</strong> </a>。这样做，你就支持了所有的媒体作者。🙏</p><p id="e918" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">…或者你可以给我买杯咖啡！☕</p></div></div>    
</body>
</html>