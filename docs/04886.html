<html>
<head>
<title>SwiftUI — Cube Rotation Transition Tutorial</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">SwiftUI立方体旋转过渡教程</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/cube-rotation-transition-b1b5f108f8d0?source=collection_archive---------16-----------------------#2020-07-21">https://levelup.gitconnected.com/cube-rotation-transition-b1b5f108f8d0?source=collection_archive---------16-----------------------#2020-07-21</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0ea8" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">让-马克·布里安内</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/c1eb17a3ae727b5fdf740b859e812426.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5Sjh2gIgFRLPB8H7.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">SwiftUI立方体旋转过渡</figcaption></figure><p id="e003" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">今天我们将讲述如何创建一个看起来像立方体旋转的自定义<code class="fe lu lv lw lx b">AnyTransition</code>。看看下面的视频。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ly lz l"/></div></figure><blockquote class="ma mb mc"><p id="fa9f" class="ky kz md la b lb lc ju ld le lf jx lg me li lj lk mf lm ln lo mg lq lr ls lt im bi translated">在开始之前，请考虑使用这个<a class="ae mh" href="https://trailingclosure.com/signup/?utm_source=medium&amp;utm_medium=blog_post&amp;utm_campaign=cube_rotation_tutorial" rel="noopener ugc nofollow" target="_blank">链接</a>订阅，如果你没有在<a class="ae mh" href="https://trailingclosure.com/?utm_source=medium&amp;utm_medium=blog_post&amp;utm_campaign=cube_rotation_tutorial" rel="noopener ugc nofollow" target="_blank">TrailingClosure.com</a>上阅读这篇文章，请随时来看看我们！</p></blockquote><h2 id="75f5" class="mi mj it bd mk ml mm dn mn mo mp dp mq lh mr ms mt ll mu mv mw lp mx my mz na bi translated">创建自定义<code class="fe lu lv lw lx b">AnimatableModifier</code></h2><p id="a980" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">首先定义一个名为<code class="fe lu lv lw lx b">CubeRotationModifier</code>的新<code class="fe lu lv lw lx b">AnimatableModifier</code>。在里面，定义一个名为<code class="fe lu lv lw lx b">pct</code>的新<code class="fe lu lv lw lx b">Double</code>，我们将使用它作为我们的<code class="fe lu lv lw lx b">animatableData</code>来制作过渡动画。</p><pre class="kj kk kl km gt ng lx nh ni aw nj bi"><span id="6aaa" class="mi mj it lx b gy nk nl l nm nn">import SwiftUI<br/><br/>struct CubeRotationModifier: AnimatableModifier {<br/>	<br/>    var pct: Double<br/>    <br/>    var animatableData: Double {<br/>        get { pct }<br/>        set { pct = newValue }<br/>    }<br/>    <br/>    func body(content: Content) -&gt; some View {<br/>        content<br/>    }<br/>}</span></pre><h2 id="2e99" class="mi mj it bd mk ml mm dn mn mo mp dp mq lh mr ms mt ll mu mv mw lp mx my mz na bi translated">旋转视图</h2><p id="5769" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">接下来，我们需要沿着y轴对视图进行3D旋转。旋转的锚点取决于视图来自哪个方向(进入或退出)。下面的两个图表可能有助于澄清任何困惑。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/eb061491578090cdf2c4eaaad339cf8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Ebukv4RsTqoKSwce.png"/></div></div></figure><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi no"><img src="../Images/d3458b6f4df8d1e2aa66ee12885644cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ZLhK-5rgckoEM2OD.png"/></div></div></figure><p id="7284" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了区分视图是进入还是退出，我们将创建一个名为<code class="fe lu lv lw lx b">SlideDirection</code>的枚举。然后我们将使用enum来定义一个名为<code class="fe lu lv lw lx b">direction</code>的属性，该属性将定义我们将使用哪个旋转动画。</p><pre class="kj kk kl km gt ng lx nh ni aw nj bi"><span id="6294" class="mi mj it lx b gy nk nl l nm nn">struct CubeRotationModifier: AnimatableModifier {<br/>    <br/>    enum SlideDirection {<br/>        case enter<br/>        case exit<br/>    }<br/>    <br/>    var pct: Double<br/>    var direction: SlideDirection<br/>    <br/>    var animatableData: Double {<br/>        get { pct }<br/>        set { pct = newValue }<br/>    }<br/>    <br/>    func body(content: Content) -&gt; some View {<br/>        content<br/>    }<br/>}</span></pre><p id="c0b2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在将<code class="fe lu lv lw lx b">.rotation3DEffect()</code>应用到视图中。</p><pre class="kj kk kl km gt ng lx nh ni aw nj bi"><span id="176b" class="mi mj it lx b gy nk nl l nm nn">func body(content: Content) -&gt; some View {<br/>    content<br/>        .rotation3DEffect(<br/>            Angle(degrees: calcRotation()),<br/>            axis: (x: 0.0, y: 1.0, z: 0.0),<br/>            anchor: direction == .enter ? .leading : .trailing,<br/>            anchorZ: 0,<br/>            perspective: 0.1<br/>        )<br/>}<br/><br/>func calcRotation() -&gt; Double {<br/>    if direction == .enter {<br/>        return 90 - (pct * 90)<br/>    } else {<br/>        return -1 * (pct * 90)<br/>    }<br/>}</span></pre><p id="d05f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如你所见，根据<code class="fe lu lv lw lx b">SlideDirection</code>我们应用了不同的<code class="fe lu lv lw lx b">Angle</code>和<code class="fe lu lv lw lx b">UnitPoint</code>(锚)。</p><ul class=""><li id="b77d" class="np nq it la b lb lc le lf lh nr ll ns lp nt lt nu nv nw nx bi translated">进入视图从<code class="fe lu lv lw lx b">90</code>开始，一直到<code class="fe lu lv lw lx b">0</code></li><li id="ba3d" class="np nq it la b lb ny le nz lh oa ll ob lp oc lt nu nv nw nx bi translated">退出视图从<code class="fe lu lv lw lx b">0</code>开始，一直到<code class="fe lu lv lw lx b">-90</code></li></ul><p id="b2c4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你现在运行它，你可能会看到一些有趣的动画。这是因为我们没有转换视图在屏幕上的<code class="fe lu lv lw lx b">x</code>位置。现在，它们在开始的位置旋转，一个在另一个上面。</p><h2 id="312a" class="mi mj it bd mk ml mm dn mn mo mp dp mq lh mr ms mt ll mu mv mw lp mx my mz na bi translated">翻译视图</h2><p id="1673" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">为了将视图转换到正确的<code class="fe lu lv lw lx b">x</code>距离，我们需要获取对框架的引用。我们通过将内容包装在一个<code class="fe lu lv lw lx b">GeometryReader</code>中并使用它传入的<code class="fe lu lv lw lx b">GeometryProxy</code>来做到这一点。</p><pre class="kj kk kl km gt ng lx nh ni aw nj bi"><span id="b93f" class="mi mj it lx b gy nk nl l nm nn">func body(content: Content) -&gt; some View {<br/>    GeometryReader { geo in<br/>        content<br/>            .rotation3DEffect(<br/>                Angle(degrees: calcRotation()),<br/>                axis: (x: 0.0, y: 1.0, z: 0.0),<br/>                anchor: direction == .enter ? .leading : .trailing,<br/>                anchorZ: 0,<br/>                perspective: 0.1<br/>            ).transformEffect(.init(translationX: calcTranslation(geo: geo), y: 0))<br/>    }<br/>}<br/><br/>func calcTranslation(geo: GeometryProxy) -&gt; CGFloat {<br/>    if direction == .enter {<br/>        return geo.size.width - (CGFloat(pct) * geo.size.width)<br/>    } else {<br/>        return -1 * (CGFloat(pct) * geo.size.width)<br/>    }<br/>}</span></pre><p id="5060" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">与上面类似，沿着<code class="fe lu lv lw lx b">x</code>轴平移视图取决于视图移动的方向。</p><ul class=""><li id="7596" class="np nq it la b lb lc le lf lh nr ll ns lp nt lt nu nv nw nx bi translated">进入的视图从等于其<code class="fe lu lv lw lx b">width</code>的<code class="fe lu lv lw lx b">x</code>位置开始，并转换为<code class="fe lu lv lw lx b">0</code>。</li><li id="d5c4" class="np nq it la b lb ny le nz lh oa ll ob lp oc lt nu nv nw nx bi translated">退出视图从等于<code class="fe lu lv lw lx b">0</code>的<code class="fe lu lv lw lx b">x</code>位置开始，并转换到<code class="fe lu lv lw lx b">width * -1</code></li></ul><h2 id="b0f7" class="mi mj it bd mk ml mm dn mn mo mp dp mq lh mr ms mt ll mu mv mw lp mx my mz na bi translated">延伸<code class="fe lu lv lw lx b">AnyTransition</code></h2><p id="8b6a" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">在我们可以使用修饰符之前，我们需要扩展<code class="fe lu lv lw lx b">AnyTransition</code>来获取<code class="fe lu lv lw lx b">CubeRotationModifier</code>并将其转换成一个在我们的视图上使用的过渡。</p><blockquote class="ma mb mc"><p id="0095" class="ky kz md la b lb lc ju ld le lf jx lg me li lj lk mf lm ln lo mg lq lr ls lt im bi translated">注意<strong class="la iu">过渡是如何不对称的</strong>。在进入和退出时修改方向，以确保视图在屏幕上以正确的方式旋转。</p></blockquote><pre class="kj kk kl km gt ng lx nh ni aw nj bi"><span id="5c41" class="mi mj it lx b gy nk nl l nm nn">extension AnyTransition {<br/>    static var cubeRotation: AnyTransition {<br/>        get {<br/>            AnyTransition.asymmetric(<br/>                insertion: AnyTransition.modifier(active: CubeRotationModifier(pct: 0, direction: .enter), identity: CubeRotationModifier(pct: 1, direction: .enter)),<br/>                removal: AnyTransition.modifier(active: CubeRotationModifier(pct: 1, direction: .exit), identity: CubeRotationModifier(pct: 0, direction: .exit)))<br/>        }<br/>    }<br/>}</span></pre><h2 id="f9fe" class="mi mj it bd mk ml mm dn mn mo mp dp mq lh mr ms mt ll mu mv mw lp mx my mz na bi translated">测试运行示例</h2><p id="409d" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">获取下面的代码，并在您的模拟器或真实设备上运行它。当一个立方体的颜色在屏幕上旋转时，你会看到<code class="fe lu lv lw lx b">.cubeSlide</code>的转换。</p><pre class="kj kk kl km gt ng lx nh ni aw nj bi"><span id="c7f6" class="mi mj it lx b gy nk nl l nm nn">import SwiftUI<br/><br/>struct ContentView: View {<br/>    <br/>    @State var index: Int = 0<br/>    @State var timer = Timer.publish(every: 2, on: RunLoop.main, in: RunLoop.Mode.common).autoconnect()<br/>    var colors: [Color] = [Color.red, Color.blue, Color.green, Color.orange, Color.purple]<br/><br/>    <br/>    var body: some View {<br/>        ZStack {<br/>            ForEach(colors.indices) { i in<br/>                if index == i {<br/>                    colors[i]<br/>                        .transition(.cubeRotation)<br/>                }<br/>            }<br/>            <br/>        }<br/>        .frame(width: 200, height: 200, alignment: .center)<br/>        .onReceive(timer) { _ in<br/>            withAnimation(.easeInOut(duration: 1.3)) {<br/>                index = (index + 1) % colors.count<br/>            }<br/>        }<br/>        <br/>    }<br/>}</span></pre><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="ly lz l"/></div></figure><h2 id="234c" class="mi mj it bd mk ml mm dn mn mo mp dp mq lh mr ms mt ll mu mv mw lp mx my mz na bi translated">让我们看看你做了什么！</h2><p id="4c91" class="pw-post-body-paragraph ky kz it la b lb nb ju ld le nc jx lg lh nd lj lk ll ne ln lo lp nf lr ls lt im bi translated">我们想看看你用这个教程做了什么！给我们发照片！在推特<a class="ae mh" href="https://twitter.com/TrailingClosure" rel="noopener ugc nofollow" target="_blank"> @TrailingClosure </a>、insta gram<a class="ae mh" href="https://www.instagram.com/trailingclosure/" rel="noopener ugc nofollow" target="_blank">上找到我们，或者发邮件到howdy@TrailingClosure.com<!-- --><!-- -->联系我们。</a></p></div></div>    
</body>
</html>