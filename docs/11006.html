<html>
<head>
<title>Prototype Design Pattern In .NET C#</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">中的原型设计模式。NET C#</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/prototype-design-pattern-in-net-c-67db46c3d28f?source=collection_archive---------3-----------------------#2022-02-07">https://levelup.gitconnected.com/prototype-design-pattern-in-net-c-67db46c3d28f?source=collection_archive---------3-----------------------#2022-02-07</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="0e71" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">设计模式</h2><div class=""/><div class=""><h2 id="2e8a" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">中了解原型设计模式。NET C#</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/4754e7f532fc532f428ecc1fd0e9cc39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FI623dZ0DljA_PloNemtUw.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd lh">原型设计模式。</strong>照片由<a class="ae li" href="https://unsplash.com/@phillshaw?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">菲尔·肖</a>在<a class="ae li" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄，由<a class="ae li" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">艾哈迈德·塔里克</a>调整</figcaption></figure><h1 id="96c8" class="lj lk it bd lh ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">英语原型</h1><p id="558f" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">在本文中，我们将讨论<strong class="mc jd">中的<strong class="mc jd">原型设计模式</strong>。NET C# </strong></p><p id="c909" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">不过，我们先来探究一下<strong class="mc jd">原型</strong>这个词在英语中的意思。</p><p id="186a" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">根据<a class="ae li" href="https://dictionary.cambridge.org/dictionary/english/prototype" rel="noopener ugc nofollow" target="_blank">dictionary.cambridge.org</a>:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nb"><img src="../Images/4c58b479c429b94d7930c0800d44d772.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xo2IHwiAH9j9wzHrKISrVw.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd lh">原型定义来自</strong><a class="ae li" href="https://dictionary.cambridge.org/" rel="noopener ugc nofollow" target="_blank"><strong class="bd lh">https://dictionary.cambridge.org/</strong></a>，由<a class="ae li" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">艾哈迈德·塔里克</a>调整</figcaption></figure><p id="3edd" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">根据<a class="ae li" href="https://www.merriam-webster.com/dictionary/prototype" rel="noopener ugc nofollow" target="_blank">merriam-webster.com</a>:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nc"><img src="../Images/f3b6b9093367bd7afc60bad358a2d2fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XuapuL4TimLU01S88GK-2g.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd lh">原型定义来自</strong><a class="ae li" href="https://www.merriam-webster.com/dictionary/prototype" rel="noopener ugc nofollow" target="_blank"><strong class="bd lh">https://www.merriam-webster.com/dictionary/prototype</strong></a>，由<a class="ae li" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">艾哈迈德·塔雷克</a>调整</figcaption></figure><p id="a3c3" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">正如你所看到的，<strong class="mc jd">原型制作</strong>主要是创建一个要扩展的东西的副本。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nd"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure><div class="ne nf gp gr ng nh"><a href="https://medium.com/subscribe/@eng_ahmed.tarek" rel="noopener follow" target="_blank"><div class="ni ab fo"><div class="nj ab nk cl cj nl"><h2 class="bd jd gy z fp nm fr fs nn fu fw jc bi translated">🔥订阅艾哈迈德的时事通讯🔥</h2><div class="no l"><h3 class="bd b gy z fp nm fr fs nn fu fw dk translated">订阅艾哈迈德的时事通讯📰直接获得最佳实践、教程、提示、技巧和许多其他很酷的东西…</h3></div><div class="np l"><p class="bd b dl z fp nm fr fs nn fu fw dk translated">medium.com</p></div></div><div class="nq l"><div class="nr l ns nt nu nq nv lb nh"/></div></div></a></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nd"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nw"><img src="../Images/c4600b7295d4c3d0df9a1ab299ae30c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0BLUqHR80Hosqt7QOKhvyw.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd lh">原型设计模式定义</strong>。由<a class="ae li" href="https://unsplash.com/@waldemarbrandt67w?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">瓦尔德马尔·布兰德</a>在<a class="ae li" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄，由<a class="ae li" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">艾哈迈德·塔雷克</a>调整</figcaption></figure><h1 id="379e" class="lj lk it bd lh ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">原型设计模式定义</h1><p id="80c6" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">原型设计模式是创造性的设计模式之一。它主要关心的是通过复制一个已经存在的对象来创建一个新的对象，而不丢失它的任何封装的内部细节，同时不依赖于类结构。</p><p id="3c44" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">哇，一个很大的定义，对不对？让我为你简化它。</p></div><div class="ab cl nx ny hx nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="im in io ip iq"><p id="6b3c" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">当您使用任何图表生成器软件工具时，您总是在寻找复制您已经添加的图表形状的功能。</p><p id="e9f9" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">使用此功能，您会得到以下结果:</p><ol class=""><li id="b66a" class="oe of it mc b md mw mg mx mj og mn oh mr oi mv oj ok ol om bi translated">您可以复制图表形状。</li><li id="340e" class="oe of it mc b md on mg oo mj op mn oq mr or mv oj ok ol om bi translated">然后应用微小的变化，如改变颜色，而不必从头开始配置所有的形状属性。</li><li id="940e" class="oe of it mc b md on mg oo mj op mn oq mr or mv oj ok ol om bi translated">您从中复制的主形状的颜色不应受到您为复制形状设置的新颜色的影响。</li></ol><p id="6568" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">你所期望的实际上就是<strong class="mc jd">原型设计模式</strong>的内容。您正在复制的图表形状实际上是从软件代码中定义的类创建的对象。</p></div><div class="ab cl nx ny hx nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="im in io ip iq"><p id="76ee" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">现在，要启用您正在寻找的功能并使其按您预期的那样工作，应该这样做:</p><ol class=""><li id="1703" class="oe of it mc b md mw mg mx mj og mn oh mr oi mv oj ok ol om bi translated">该软件应该能够复制<strong class="mc jd">源</strong>图形状对象。</li><li id="e922" class="oe of it mc b md on mg oo mj op mn oq mr or mv oj ok ol om bi translated">新的<strong class="mc jd">副本</strong>对象应该与<strong class="mc jd">源</strong>对象完全相同，但却是一个完全独立的对象，与<strong class="mc jd">源</strong>对象完全断开。</li><li id="4d71" class="oe of it mc b md on mg oo mj op mn oq mr or mv oj ok ol om bi translated">改变<strong class="mc jd">复制</strong>对象的属性或设置不会对<strong class="mc jd">源</strong>对象产生任何影响。</li></ol><p id="d49a" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">就这些吗？其实没有。</p></div><div class="ab cl nx ny hx nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="im in io ip iq"><p id="f116" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">正如你所知道的，在软件世界里，仅仅有一些工作是不够的。我们应该始终关注其他因素，如可读性、可维护性、可扩展性……以及其他一些目标。其中一个目标是确保我们的代码是松散耦合的，并且对其他模块或类的依赖性最小。</p><p id="c346" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">因此，<strong class="mc jd">原型设计模式</strong>关注的目标之一是确保我们可以实现复制一个对象，而实际上并不依赖于它的类定义。</p><p id="e61f" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">现在，你可能会问:</p><blockquote class="os ot ou"><p id="9e70" class="ma mb ov mc b md mw kd mf mg mx kg mi ow my ml mm ox mz mp mq oy na mt mu mv im bi translated">这是不对的。实际上我的模块已经知道并依赖于这个对象类，否则，我的模块怎么会首先使用这个对象呢？！！</p></blockquote><p id="c895" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">你说对了一部分。您的模块知道对象类向外部世界公开了什么，但这还不是全部。</p><p id="6feb" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">定义这个对象的类可能有其他私有、内部或受保护的成员，而你的模块完全不知道这些成员。</p><p id="b626" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">基于这个事实，我们可以得出结论，您的模块实际上不能处理复制任务本身，因为它没有所需的所有信息。这里实际应该发生的是将复制任务委托给对象类本身，因为它完全了解其内部。</p><p id="3ccc" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">不服气？让我展示给你看。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nd"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi oz"><img src="../Images/46527121ae8796de4dccaac481d0c7be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZVeYVL7pbbsm3UsyIPvnoQ.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd lh">隐藏字段示例</strong>。由<a class="ae li" href="https://unsplash.com/@lazycreekimages?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Michael Dziedzic </a>在<a class="ae li" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄，由<a class="ae li" href="https://medium.com/@eng_ahmed.tarek" rel="noopener"> Ahmed Tarek </a>调整</figcaption></figure><h1 id="a425" class="lj lk it bd lh ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">隐藏字段示例</h1><p id="a50c" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">让我们假设我们有一个如下定义的<code class="fe pa pb pc pd b">Person</code>类:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pe pf l"/></div></figure><p id="f123" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">正如您所注意到的，除了用于评估<code class="fe pa pb pc pd b">FullName</code>属性的私有<code class="fe pa pb pc pd b">separator</code>字段之外，所有成员都是公共的。</p><p id="2bcd" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">现在，假设在某个模块中，我们有一个<code class="fe pa pb pc pd b">Person</code>类的实例对象，我们想如下复制它:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pe pf l"/></div></figure><p id="5da0" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">如你所见，在我们试图复制对象的第<strong class="mc jd"> 4 </strong>行，我们不知道为<code class="fe pa pb pc pd b">separator</code>传递什么，因为我们无法访问已经为原始<code class="fe pa pb pc pd b">ahmedTarek</code>对象设置的对象。</p><p id="51e5" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">这意味着我们不能在我们的模块中处理这个复制任务。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nd"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nw"><img src="../Images/b708a821a5d600e2f0e2f5d1a3fa58c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uikP6wMMJ8ZElS5abvxGXg.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd lh">嵌套对象示例</strong>。照片由<a class="ae li" href="https://unsplash.com/@sandworm?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> X Y </a>在<a class="ae li" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄，由<a class="ae li" href="https://medium.com/@eng_ahmed.tarek" rel="noopener"> Ahmed Tarek </a>调整</figcaption></figure><h1 id="a7e3" class="lj lk it bd lh ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">嵌套对象示例</h1><p id="606c" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">假设我们有一个如下定义的<code class="fe pa pb pc pd b">Node</code>类:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pe pf l"/></div></figure><p id="1a60" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">现在，让我们创建一系列嵌套节点，如下所示:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pe pf l"/></div></figure><p id="a81a" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">运行此命令应该会得到以下结果:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pg"><img src="../Images/553d97e89477587bdf2e4abc3cca96e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*adluuy5i5YaLqSYLq94Tdg.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd lh">原创系列</strong>。图片由<a class="ae li" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">艾哈迈德·塔里克</a>拍摄</figcaption></figure><p id="8c69" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">现在我们想创建一个<code class="fe pa pb pc pd b">node1</code>的副本。有人可能认为正确的做法如下:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pe pf l"/></div></figure><p id="b425" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">但是实际上运行它会得到这样的结果:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pg"><img src="../Images/de757303f991fa376462c1ad08b31c52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cJlGqbSi80oWel3Br1y4fQ.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd lh">错误复制系列</strong>。图片由<a class="ae li" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">艾哈迈德·塔里克</a>拍摄</figcaption></figure><p id="984d" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">这是错误的，因为<strong class="mc jd">节点1 </strong>的新副本引用的是<strong class="mc jd">节点2 </strong>，而不是<strong class="mc jd">节点2 </strong>的副本，依此类推…</p><p id="10b3" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">为了解决这个问题，我们需要采用一种更复杂的方法。我们需要为每个节点创建一个副本，并让每个人都引用下一个副本。</p><p id="4d77" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">接下来，我们应该这样做:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pe pf l"/></div></figure><p id="7f4e" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">运行它，我们会得到以下结果:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi ph"><img src="../Images/8afd626cd36a1151f4f1827db5597383.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QuMAbPkfs-B7675OoMDM8w.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd lh">复抄系列</strong>。图片来自<a class="ae li" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">艾哈迈德·塔里克</a></figcaption></figure><p id="792e" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">现在，它工作得很好，但我们可以注意到代码往往很复杂。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nd"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pi"><img src="../Images/338987c9ec844275c8b0fd11b38e3810.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rHmEDJ_NtDWgO5SqPpzBVA.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd lh">原型设计模式来拯救</strong>。由<a class="ae li" href="https://unsplash.com/@yogipurnama?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Yogi Purnama </a>在<a class="ae li" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄，由<a class="ae li" href="https://medium.com/@eng_ahmed.tarek" rel="noopener"> Ahmed Tarek </a>调整</figcaption></figure><h1 id="1157" class="lj lk it bd lh ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">原型设计模式来拯救</h1><p id="8ba1" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">正如我们现在所理解的，在一个单独的模块上复制一个对象要么是因为隐藏成员的存在而不可能，要么是可能但复杂的。<strong class="mc jd">原型设计模式</strong>提供了解决方案。</p><p id="a630" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">英寸NET C#中，已经有了一个表示在<code class="fe pa pb pc pd b">ICloneable</code>接口中的模式的实现。如果我们通过实现这个接口来扩展我们的类，我们将有一个<code class="fe pa pb pc pd b">public object Clone()</code>方法来实现。</p><p id="b85f" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">然而，这种方法已经存在，并得到了。NET框架本身，我对它有些担心。但是，让我先向您介绍一下这种方法，然后我们可以讨论我的顾虑。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nd"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pj"><img src="../Images/768059e5b19f86d599f5ea280afc900c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zf41zSTqRXUVqGTNQ23NNw.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd lh">使用不可克隆的</strong>。图片由<a class="ae li" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">艾哈迈德·塔里克</a>拍摄</figcaption></figure><h1 id="53e4" class="lj lk it bd lh ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">使用ICloneable</h1><p id="b2a7" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">在这一节中，我们将使用带有<strong class="mc jd">隐藏字段</strong>和<strong class="mc jd">嵌套对象</strong>的<code class="fe pa pb pc pd b">ICloneable</code>示例，看看它是否真的能工作。</p></div><div class="ab cl nx ny hx nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="im in io ip iq"><h2 id="17ca" class="pk lk it bd lh pl pm dn lo pn po dp ls mj pp pq lu mn pr ps lw mr pt pu ly iz bi translated">对隐藏字段使用ICloneable示例</h2><p id="0519" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">让我们回到我们的<code class="fe pa pb pc pd b">Person</code>类例子。但是，这一次，它将如下执行<code class="fe pa pb pc pd b">ICloneable</code>:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pe pf l"/></div></figure><p id="58ee" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">看，现在在第<strong class="mc jd"> 18 </strong>行我们正在创建一个<code class="fe pa pb pc pd b">Person</code>类的新实例，我们可以访问所有私有字段。这很容易。</p><p id="02f0" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">现在，使用它很容易，如下所示:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pe pf l"/></div></figure><p id="7941" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">运行它会得到这样的结果:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pg"><img src="../Images/5418fb9f8c33b9490ba06435d5ddfcb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cm1Pul0TbjyxP7bQuR-LZg.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd lh">使用ICloneable </strong>的结果。图片由<a class="ae li" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">艾哈迈德·塔里克</a>拍摄</figcaption></figure><p id="af15" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">看，这很有魅力。</p></div><div class="ab cl nx ny hx nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="im in io ip iq"><h2 id="7662" class="pk lk it bd lh pl pm dn lo pn po dp ls mj pp pq lu mn pr ps lw mr pt pu ly iz bi translated">将ICloneable与<strong class="ak">嵌套对象</strong>一起使用示例</h2><p id="7f03" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">让我们回到我们的<code class="fe pa pb pc pd b">Node</code>类例子。然而，这一次，它将如下实现<code class="fe pa pb pc pd b">ICloneable</code>:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pe pf l"/></div></figure><p id="a251" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">看，现在在第<strong class="mc jd"> 28 </strong>行我们正在创建一个<code class="fe pa pb pc pd b">Node</code>类的新实例，我们也在使用<code class="fe pa pb pc pd b">Next</code>节点的<code class="fe pa pb pc pd b">Clone</code>方法来复制它。这很容易。</p><p id="2c4f" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi pv translated">注意:这里的一个问题是，我们命名每个节点副本的方式是硬编码的，并且封装在<code class="fe pa pb pc pd b">Node</code>类本身中。这是我们稍后会解决的问题，请继续关注。</p><p id="8eb8" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">现在，使用它很容易，如下所示:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pe pf l"/></div></figure><p id="304d" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">运行它会得到这样的结果:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qe"><img src="../Images/57c9ea72e5b065effd814d9fb0bbee5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gUrcBQN-ir1djPtEiCe6eA.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd lh">使用ICloneable </strong>的结果。图片由<a class="ae li" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">艾哈迈德·塔里克</a>拍摄</figcaption></figure><p id="1f9a" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">看，这很有魅力。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nd"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qf"><img src="../Images/99a3372ba982ef5e10cdf0de80054c94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cXpYpOzPie_hHvNikUNjfQ.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">我对克隆的担忧。照片由<a class="ae li" href="https://unsplash.com/@neonbrand?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> NeONBRAND </a>在<a class="ae li" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄，由<a class="ae li" href="https://medium.com/@eng_ahmed.tarek" rel="noopener"> Ahmed Tarek </a>调整</figcaption></figure><h1 id="284a" class="lj lk it bd lh ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">我对ICloneable的担忧</h1><p id="c492" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">虽然使用<code class="fe pa pb pc pd b">ICloneable</code>看似有效，但我相信它存在一些严重的问题。</p></div><div class="ab cl nx ny hx nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="im in io ip iq"><h2 id="b7f3" class="pk lk it bd lh pl pm dn lo pn po dp ls mj pp pq lu mn pr ps lw mr pt pu ly iz bi translated">不可变副本</h2><p id="9ab1" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated"><code class="fe pa pb pc pd b">ICloneable</code>为我们提供了一个<code class="fe pa pb pc pd b">public object Clone()</code>方法，我们可以用它来复制一个对象。但是，如果对象是不可变的呢？换句话说，如果在创建对象之后，甚至连对象的公共属性都无法设置，那该怎么办？</p><p id="8c5d" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">在这种情况下，我们通过调用<code class="fe pa pb pc pd b">Clone</code>方法得到的对象不能被任何方式操作，这在大多数情况下是没有用的。让我们考虑一下。</p><p id="391d" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">当我们试图复制一个对象时，很可能我们这样做是因为我们需要一个现有对象的精确副本，然后对副本进行一些更新，对吗？现在，如果我告诉你，你得到的副本不能更新，在这种情况下，它是没有价值的。</p><p id="f0ad" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">使用<code class="fe pa pb pc pd b">ICloneable</code>的唯一情况是，如果你只需要一个精确的副本，而不需要任何更新。</p></div><div class="ab cl nx ny hx nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="im in io ip iq"><h2 id="a5a4" class="pk lk it bd lh pl pm dn lo pn po dp ls mj pp pq lu mn pr ps lw mr pt pu ly iz bi translated">返回对象</h2><p id="74c6" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">正如您所注意到的，<code class="fe pa pb pc pd b">ICloneable</code>为我们提供了一个返回<code class="fe pa pb pc pd b">object</code>的<code class="fe pa pb pc pd b">public object Clone()</code>方法，而不是<code class="fe pa pb pc pd b">Person</code>或<code class="fe pa pb pc pd b">Node</code>。这就是为什么我们需要将从<code class="fe pa pb pc pd b">Clone</code>方法返回的<code class="fe pa pb pc pd b">object</code>转换为<code class="fe pa pb pc pd b">Person</code>或<code class="fe pa pb pc pd b">Node</code>。</p><p id="9517" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">实际上，如果你只做几次，这没什么大不了的，但是如果你做的次数太多太频繁，那就有问题了。这将影响整体性能。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nd"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qg"><img src="../Images/9a087aa1178355b24e24f3128a184e6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iiksoQrfIeG81ivrckiOog.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd lh">另一条路</strong>。照片由<a class="ae li" href="https://unsplash.com/@volkanolmez?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">沃尔坎·奥尔梅斯</a>在<a class="ae li" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄，由<a class="ae li" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">艾哈迈德·塔雷克</a>调整</figcaption></figure><h1 id="29e4" class="lj lk it bd lh ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">相反</h1><p id="7694" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">首先，让我强调一下，我认为复制一个对象很可能应该是一个特定于类的任务。这是因为每个类都会定义自己的成员，并且定义这些成员中哪些是不可变的，哪些不是。</p><p id="02c3" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">话虽如此，现在让我们向您展示另一种处理复制对象的方法。</p></div><div class="ab cl nx ny hx nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="im in io ip iq"><h2 id="f597" class="pk lk it bd lh pl pm dn lo pn po dp ls mj pp pq lu mn pr ps lw mr pt pu ly iz bi translated">隐藏字段示例的更好解决方案</h2><p id="2fc4" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">回到我们的<code class="fe pa pb pc pd b">Person</code>类:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pe pf l"/></div></figure><p id="5873" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">注意<code class="fe pa pb pc pd b">FirstName</code>和<code class="fe pa pb pc pd b">LastName</code>都是不可变的。</p><p id="c05d" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">假设<code class="fe pa pb pc pd b">Person</code>类允许自己被复制。在这种情况下，<code class="fe pa pb pc pd b">Person</code>类应该定义一个<code class="fe pa pb pc pd b">Clone</code>方法来返回当前<code class="fe pa pb pc pd b">Person</code>对象的副本。然而，仅仅返回一个不可变的对象对调用者模块可能是无用的，因为它需要在复制的对象上应用一些更新。</p><p id="e10e" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">为了实现这一点，我们可以这样做:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pe pf l"/></div></figure><p id="9fa8" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">看到我们在这里做的了吗？我们添加了一个<code class="fe pa pb pc pd b">Clone</code>方法，调用者有机会覆盖任何属性。那么，返回的对象仍然是不可变的。</p><p id="b124" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">另外，<code class="fe pa pb pc pd b">Clone</code>方法现在返回一个<code class="fe pa pb pc pd b">Person</code>，而不是一个<code class="fe pa pb pc pd b">Object</code>。</p><p id="3117" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">此外，我们添加了一个更简单的无参数的<code class="fe pa pb pc pd b">Clone</code>方法，它将返回一个精确的副本，没有任何覆盖。</p><p id="3274" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">现在，使用它的方式如下:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pe pf l"/></div></figure><p id="fae4" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">运行它会得到这样的结果:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi pg"><img src="../Images/90761cf283be86fb0f2b03128dec9b6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lA65ENxUAVZOAjxLiaUOYQ.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd lh">结果</strong>。图片由<a class="ae li" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">艾哈迈德·塔里克</a>拍摄</figcaption></figure><p id="a49b" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">太棒了，工作起来很有魅力。</p></div><div class="ab cl nx ny hx nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="im in io ip iq"><h2 id="297c" class="pk lk it bd lh pl pm dn lo pn po dp ls mj pp pq lu mn pr ps lw mr pt pu ly iz bi translated">嵌套对象的更好解决方案示例</h2><p id="34e7" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">回到我们的<code class="fe pa pb pc pd b">Node</code>类:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pe pf l"/></div></figure><p id="3574" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">所以，按照和以前一样的概念，我们可以这样做:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="pe pf l"/></div></figure><p id="b043" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">因此，正如您在这里可以注意到的那样，<code class="fe pa pb pc pd b">Clone</code>方法的调用者有不止一个选项；不管是否决还是不否决。</p><p id="ae79" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">另外，现在设置复制的<code class="fe pa pb pc pd b">Node</code>的名称的逻辑被委托给调用者，而不是<code class="fe pa pb pc pd b">Node</code>类本身。</p><p id="de0e" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">现在，运行它会得到这样的结果:</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qh"><img src="../Images/0be6b19f1c72d8c0c053a4b59ba06cc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PORXRMvn8w6kpEpF-LMTqg.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd lh">结果</strong>。图片由<a class="ae li" href="https://medium.com/@eng_ahmed.tarek" rel="noopener">艾哈迈德·塔里克</a>拍摄</figcaption></figure><p id="5cde" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">很好，对吧？</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nd"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi qi"><img src="../Images/22134ac21feef1a70e487f399ea85ff7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0vOSR5E_nv7_fHwUxkpASQ.jpeg"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated"><strong class="bd lh">最终想法</strong>。由<a class="ae li" href="https://unsplash.com/@peterampazzo?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Pietro Rampazzo </a>在<a class="ae li" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄，由<a class="ae li" href="https://medium.com/@eng_ahmed.tarek" rel="noopener"> Ahmed Tarek </a>调整</figcaption></figure><h1 id="1053" class="lj lk it bd lh ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">最后的想法</h1><p id="ddbc" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">在本文中，我们讨论了<strong class="mc jd">中的<strong class="mc jd">原型设计模式</strong>。NET C# </strong>。我们展示了一些例子并对它们进行了分析。</p><p id="f0a1" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">这里要提到的是<strong class="mc jd">原型设计模式</strong>的一个常见用法是在<strong class="mc jd">生成器设计模式</strong>本身。如果你想了解更多，你可以阅读我的文章<a class="ae li" rel="noopener ugc nofollow" target="_blank" href="/builder-design-pattern-in-net-c-bbf11c891548?sk=86d584e92a5f565c35e8a642543e9289"> <strong class="mc jd">构建器设计模式。NET C# </strong> </a>。</p><p id="ddaa" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">有人可能会说，遵循本文提供的增强实现并没有提供任何不同系统模块可以依赖的抽象层。然而，我的回答是，我们仍然可以抽象出我们提供的不同的<code class="fe pa pb pc pd b">Clone</code>方法。我这样做不是为了避免分心，但肯定是可以做到的。</p><p id="2ea4" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">现在你明白了<strong class="mc jd">原型设计模式</strong>是什么了。然而，这并不是故事的结尾。</p><p id="8de7" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">您需要在互联网上搜索更多关于<strong class="mc jd">原型设计模式</strong>及其用法的文章和教程。这会帮助你更好地理解它。</p><p id="58c1" class="pw-post-body-paragraph ma mb it mc b md mw kd mf mg mx kg mi mj my ml mm mn mz mp mq mr na mt mu mv im bi translated">最后，我希望你觉得读这个故事和我写它一样有趣。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nd"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure><h1 id="0bc3" class="lj lk it bd lh ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">希望这些内容对你有用。如果您想支持:</h1><p id="23cf" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">如果您还不是<strong class="mc jd">中型</strong>会员，您可以使用<a class="ae li" href="https://medium.com/@eng_ahmed.tarek/membership" rel="noopener"> <strong class="mc jd">我的推荐链接</strong> </a>，这样我就可以从<strong class="mc jd">中型</strong>中获得您的一部分费用，您无需支付任何额外费用。订阅<br/><a class="ae li" href="https://medium.com/subscribe/@eng_ahmed.tarek" rel="noopener"><strong class="mc jd">我的简讯</strong> </a>将最佳实践、教程、提示、技巧和许多其他很酷的东西直接发送到您的收件箱。</p><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nd"><img src="../Images/eba85e787794ef5357d01af3fcbb9bbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*6_sEKVrKH8btJ_T5.png"/></div></div></figure><h1 id="aa5c" class="lj lk it bd lh ll lm ln lo lp lq lr ls ki lt kj lu kl lv km lw ko lx kp ly lz bi translated">其他资源</h1><p id="6b81" class="pw-post-body-paragraph ma mb it mc b md me kd mf mg mh kg mi mj mk ml mm mn mo mp mq mr ms mt mu mv im bi translated">这些是你可能会发现有用的其他资源。</p><div class="ne nf gp gr ng nh"><a rel="noopener  ugc nofollow" target="_blank" href="/curse-of-recursion-in-net-c-b017271ddbe6"><div class="ni ab fo"><div class="nj ab nk cl cj nl"><h2 class="bd jd gy z fp nm fr fs nn fu fw jc bi translated">递归的诅咒。NET C#</h2><div class="no l"><h3 class="bd b gy z fp nm fr fs nn fu fw dk translated">为什么以及如何在？NET C#</h3></div><div class="np l"><p class="bd b dl z fp nm fr fs nn fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="nq l"><div class="qj l ns nt nu nq nv lb nh"/></div></div></a></div><div class="ne nf gp gr ng nh"><a rel="noopener  ugc nofollow" target="_blank" href="/passing-parameters-to-a-net-c-method-388badb7c095"><div class="ni ab fo"><div class="nj ab nk cl cj nl"><h2 class="bd jd gy z fp nm fr fs nn fu fw jc bi translated">将参数传递给. NET C#方法</h2><div class="no l"><h3 class="bd b gy z fp nm fr fs nn fu fw dk translated">向. NET C#方法传递参数的不同方式。</h3></div><div class="np l"><p class="bd b dl z fp nm fr fs nn fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="nq l"><div class="qk l ns nt nu nq nv lb nh"/></div></div></a></div><div class="ne nf gp gr ng nh"><a rel="noopener  ugc nofollow" target="_blank" href="/protecting-public-methods-from-illogical-calls-in-net-c-91fcbb8bee33"><div class="ni ab fo"><div class="nj ab nk cl cj nl"><h2 class="bd jd gy z fp nm fr fs nn fu fw jc bi translated">保护公共方法免受不合逻辑的调用。NET C#</h2><div class="no l"><h3 class="bd b gy z fp nm fr fs nn fu fw dk translated">包含代码示例和解释的完整指南。</h3></div><div class="np l"><p class="bd b dl z fp nm fr fs nn fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="nq l"><div class="ql l ns nt nu nq nv lb nh"/></div></div></a></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi nd"><img src="../Images/dae42316c04548aad197e34b378e3bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RFZ-qimUzmMG4vLln9mYSw.png"/></div></div></figure></div></div>    
</body>
</html>