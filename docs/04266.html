<html>
<head>
<title>GraphQL with .NET</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GraphQL with。网</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/graphql-with-net-81a2e02ddfc9?source=collection_archive---------2-----------------------#2020-06-17">https://levelup.gitconnected.com/graphql-with-net-81a2e02ddfc9?source=collection_archive---------2-----------------------#2020-06-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="498e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用DotNet Core 3和graphql-dotnet创建GraphQL API</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/e95437984fd6d6cfb00afd571eafcbcf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*26_EAodLYXMhifDV.jpg"/></div></div></figure><p id="6a71" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以前几天我偶然发现了<a class="ae kx" href="https://www.themoviedb.org/" rel="noopener ugc nofollow" target="_blank">电影数据库</a>，更有趣的是<a class="ae kx" href="https://developers.themoviedb.org/3" rel="noopener ugc nofollow" target="_blank">电影数据库API </a>。</p><p id="2025" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它提供了一个REST API来检索和搜索电影、电视节目、演员等。以及添加评论等。我在用VueJS twitter feed制作的<a class="ae kx" href="https://twitter.com/MadeWithVueJS" rel="noopener ugc nofollow" target="_blank">上偶然发现了它</a>(不幸的是，我现在找不到确切的tweet了)，有人在tweet上展示了他们为它构建的VueJS前端。</p><p id="e38b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">“好主意！”我以为。我一直在寻找可以在React中构建的东西，这给了我一些实实在在的东西，在它背后有一个极其丰富的API，给它一些脂肪。</p><p id="6511" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以我创建了基本的React应用程序，开始了我的旅程。</p><p id="b2e3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但后来我想“等等！休息死了！GraphQL FTW”(REST并不是真的死了，只是graph QL酷多了)。幸运的是，我<em class="ky">也</em>一直在寻找一个使用<a class="ae kx" href="https://github.com/graphql-dotnet/graphql-dotnet" rel="noopener ugc nofollow" target="_blank"> graphql-dotnet </a>创建的项目，所以我决定从那里开始。想法是创建一个React前端，最后用他们的新组合API创建一个VueJS前端。</p><p id="11fe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，我现在承担了相当多的工作。但这一切都很有趣，所以我们开始吧！</p><p id="fda2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以在GitHub 上找到服务器<a class="ae kx" href="https://github.com/np-matt/gql-movies" rel="noopener ugc nofollow" target="_blank">的所有源代码(不要因为缺少测试而太恨我。WIP)。</a></p><p id="58dc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以我从一个基本的dotnet core 3 WebAPI应用程序开始，去掉了天气预报的东西，添加了一个新的带有一个HttpPost端点的<code class="fe kz la lb lc b">GraphQlController</code>。</p><p id="bcdf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，我使用<a class="ae kx" href="https://github.com/graphql-dotnet/graphql-dotnet" rel="noopener ugc nofollow" target="_blank"> graphql-dotnet </a>来创建模式并执行查询。</p><p id="0f5a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">端点本身非常简单。整个控制器只有40条线:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ld le l"/></div></figure><p id="501d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">需要调用<code class="fe kz la lb lc b">DeserializeObject</code>来启用application/json的content-type头的神奇设置。可能不是最有性能的做法，将一个字符串转换成对象，然后再转换成一个字符串进行传输；但是现在，它是有效的，并且是那种可以在以后改进的东西。</p><h1 id="53df" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">类型</h1><p id="f005" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">类型需要一点样板。你首先必须创建一个基类来封装描述你的对象的数据，然后用它来扩展<code class="fe kz la lb lc b">ObjectGraphType</code>并描述你想要发布的字段。</p><p id="bff4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">比如电影课:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ld le l"/></div></figure><p id="92a0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这然后被传递到一个<code class="fe kz la lb lc b">MovieType</code>:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ld le l"/></div></figure><p id="5d71" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe kz la lb lc b">ObjectGraphType</code>接受其下对象的类型。这将在<code class="fe kz la lb lc b">Field</code>的回调函数中输入参数。您使用它来描述可以查询的GraphQL对象。它从您返回的属性类型派生字段类型。</p><p id="7456" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您还可以做更复杂的事情来显式地键入属性，并添加底层对象上不存在的成员。</p><p id="2090" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，<code class="fe kz la lb lc b">ResultsType</code>为<code class="fe kz la lb lc b">results</code>数组定义了一个字段。这样我就可以嵌套类型，得到一个带有<code class="fe kz la lb lc b">List&lt;Movie&gt;</code>的结果类，并从GraphQL查询返回一个<code class="fe kz la lb lc b">ListGraphType&lt;MovieType&gt;</code>。</p><h1 id="2039" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">问题</h1><p id="8548" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">查询的定义方式与字段非常相似。只能有一个查询对象，但这并不意味着不能将查询对象分割开来。</p><p id="8f0b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为此，我创建了使用<code class="fe kz la lb lc b">MovieQuery</code>嵌套查询的<code class="fe kz la lb lc b">Query</code>类。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ld le l"/></div></figure><p id="cca3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">根据文档，这种嵌套的关键是在解析器中返回<code class="fe kz la lb lc b">new{ }</code>。</p><p id="43fd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是，这确实意味着我们最终会得到如下查询:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ld le l"/></div></figure><p id="c1d6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我不是100%确定，但我想我喜欢搜索/电影嵌套:耸肩:</p><h1 id="da37" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">模式本身</h1><p id="8720" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">Schema类很简单:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ld le l"/></div></figure><p id="45ea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里最酷的是<code class="fe kz la lb lc b">IDependencyResolver</code>的注射。查看显示服务配置的<code class="fe kz la lb lc b">Startup.cs</code>类。我没有在模式中显式地使用它，但是注入它允许我进一步注入依赖关系，比如将<code class="fe kz la lb lc b">MovieService</code>注入到<code class="fe kz la lb lc b">MovieType</code>类中。</p><p id="6c2b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在模式中，我设置的只是一个<code class="fe kz la lb lc b">Query</code>对象。这也是我设置突变等的地方，但是为了这个例子的目的，我不会更新任何东西。</p><p id="523f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这方面还有很多工作要做，它只涵盖了GraphQL和Movie DB API可能实现的功能的一个子集，但是它让我继续研究核心技术。这个项目的所有源代码可以在<a class="ae kx" href="https://github.com/mlawd/gql-movies" rel="noopener ugc nofollow" target="_blank">https://github.com/mlawd/gql-movies</a>找到。</p></div><div class="ab cl mi mj hu mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ij ik il im in"><p id="acce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="ky">原载于</em><a class="ae kx" href="https://mattlaw.dev/blog/graph-ql-with-net/" rel="noopener ugc nofollow" target="_blank"><em class="ky">https://mattlaw . dev</em></a><em class="ky">。</em></p></div></div>    
</body>
</html>