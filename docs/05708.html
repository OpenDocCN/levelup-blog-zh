<html>
<head>
<title>Building a CI Pipeline for a Microservice in Quarkus with CircleCI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用CircleCI为Quarkus的微服务构建CI管道</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/building-a-ci-pipeline-for-a-microservice-in-quarkus-with-circleci-11e9b679423f?source=collection_archive---------12-----------------------#2020-09-24">https://levelup.gitconnected.com/building-a-ci-pipeline-for-a-microservice-in-quarkus-with-circleci-11e9b679423f?source=collection_archive---------12-----------------------#2020-09-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/007dc737cde45490201e8a650588e2d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ACLDsGd3i8a2iQKk"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由<a class="ae kc" href="https://unsplash.com/@bel2000a?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">贝琳达·费因斯</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="cbd6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是Quarkus和Kotlin 从头开始构建微服务系列的一部分。我们建立了一个微服务。我们有全面的单元和组件测试。我们可以在本地构建它，并生成docker映像，既可以在JVM中运行，也可以在GrallVM中本地运行。现在我们需要一个自动化构建过程的管道。</p><p id="55f9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">管道将</p><ul class=""><li id="0de3" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">查看github的最新版本</li><li id="9f01" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">构建多模块maven项目</li><li id="6f0e" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">将工件安装到本地maven存储库中</li><li id="8749" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">构建docker图像</li><li id="af57" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">使用本地docker映像运行组件测试</li><li id="1c32" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">将docker映像推送到docker注册表(如果是主分支)</li><li id="2d0c" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">构建并推送应用程序的本机映像版本(如果是主分支)</li></ul><p id="0c83" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有许多优秀的CI工具可用，其中许多都有免费层。对于本文，我们将使用<a class="ae kc" href="https://circleci.com/" rel="noopener ugc nofollow" target="_blank"> CircleCI </a></p><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div class="gh gi lp"><img src="../Images/0d9753e0fbb642c441b898b0248162f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*2TUHWGDQ8A8Z_nHwzsBYmQ.png"/></div></figure><p id="d50b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦你用你的github帐号注册了CircleCI，你可以从你的项目列表中选择一个想要配置CI的项目。设置该项目将在github中注册一个webhook，以便每当新的提交被推送时，对CircleCI进行回调。</p><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lu"><img src="../Images/36f28a30a5620586df9dcf1b04d746fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p4EQwEnVKBzMbMv86Awe-A.png"/></div></div></figure><h2 id="9c86" class="lv lw iq bd lx ly lz dn ma mb mc dp md ko me mf mg ks mh mi mj kw mk ml mm mn bi translated">配置构建文件</h2><p id="ffbf" class="pw-post-body-paragraph kd ke iq kf b kg mo ki kj kk mp km kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">CircleCI将在项目的根目录中查找构建配置文件。该文件必须放在名为<strong class="kf ir">的目录中。circleci </strong>并命名为<strong class="kf ir"> config.yml </strong></p><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/fca58d53a645737577e0deb5cf0b772e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1092/format:webp/1*2Cw-q1Vi4xKlnoNxbgN-IA.png"/></div></figure><p id="2e4d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">构建文件由一些设置和一系列步骤组成。我将遍历构建文件并解释每一部分。完整文件可从<a class="ae kc" href="https://github.com/iainporter/sms-service/blob/circleci/.circleci/config.yml" rel="noopener ugc nofollow" target="_blank">这里</a>获得。</p><h2 id="60ac" class="lv lw iq bd lx ly lz dn ma mb mc dp md ko me mf mg ks mh mi mj kw mk ml mm mn bi translated">建立</h2><pre class="lq lr ls lt gt mu mv mw mx aw my bi"><span id="2c18" class="lv lw iq mv b gy mz na l nb nc">version: 2<br/>jobs:<br/>  build:<em class="nd"><br/>    </em>machine:<br/>      image: ubuntu-2004:202008-01<em class="nd"><br/>    </em>resource_class: medium<br/>    working_directory: ~/repo<br/>    environment:<br/>      MAVEN_OPTS: -Xmx6400m<em class="nd"><br/>      </em>GRAALVM_HOME: /home/circleci/repo/.graalvm</span></pre><p id="a196" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您需要选择一个<a class="ae kc" href="https://circleci.com/docs/2.0/executor-types/" rel="noopener ugc nofollow" target="_blank">执行器</a>类型。这定义了运行作业的底层技术或环境。可用的类型有:</p><ul class=""><li id="7f0e" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">Docker图像(<code class="fe ne nf ng mv b">docker</code>)内</li><li id="93a7" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">在Linux虚拟机映像(<code class="fe ne nf ng mv b">machine</code>)内</li><li id="a876" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">在macOS虚拟机映像中(<code class="fe ne nf ng mv b">macos</code></li><li id="c8d1" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">在windows虚拟机映像中(<code class="fe ne nf ng mv b">windows</code></li></ul><p id="87eb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个例子中，我们选择了<strong class="kf ir"> <em class="nd">机器</em> </strong>，它将在一个专用的临时虚拟机中运行构建。我们选择了一个映像，它将为我们提供openjdk 11作为默认设置，以及docker和maven。这是一个早期的预览图像和完整的组件在这里列出<a class="ae kc" href="https://discuss.circleci.com/t/early-preview-new-ubuntu-20-04-linux-machine-executor-image/37281" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="258f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> <em class="nd"> resource_class </em> </strong>默认使用medium。这定义了虚拟CPU和RAM的数量。如果你需要更多的资源，你可以选择一个不同的课程，但这将涉及一些费用。</p><p id="db8c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们定义了几个稍后会用到的环境变量</p><h2 id="e73d" class="lv lw iq bd lx ly lz dn ma mb mc dp md ko me mf mg ks mh mi mj kw mk ml mm mn bi translated">构建步骤</h2><pre class="lq lr ls lt gt mu mv mw mx aw my bi"><span id="6006" class="lv lw iq mv b gy mz na l nb nc">steps:<br/><em class="nd">  </em>- checkout<em class="nd"><br/>  </em>- run:<br/>      name: Set Version<br/>      command: |<br/>            echo 'export VERSION=$(mvn help:evaluate -Dexpression=project.version -q -DforceStdout)' &gt;&gt; $BASH_ENV<br/><br/><em class="nd">  </em>- restore_cache:<br/>      keys:<br/>        - v1-dependencies-{{ checksum "pom.xml" }}<em class="nd"><br/>        </em>- v1-dependencies-</span></pre><p id="1c0d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第一步是检查源代码。接下来，我们从pom文件中提取版本，因为我们稍后将需要它来标记docker图像。我们可以利用CircleCI中的<a class="ae kc" href="https://circleci.com/docs/2.0/caching/" rel="noopener ugc nofollow" target="_blank">缓存</a>特性来提高构建工作的效率。未来的作业将使用<strong class="kf ir"><em class="nd">restore _ cache</em></strong>标签来确保不会再次下载所有的maven依赖项。</p><h2 id="86ce" class="lv lw iq bd lx ly lz dn ma mb mc dp md ko me mf mg ks mh mi mj kw mk ml mm mn bi translated">构建项目</h2><pre class="lq lr ls lt gt mu mv mw mx aw my bi"><span id="88a8" class="lv lw iq mv b gy mz na l nb nc">- run:<br/>    name: Build<br/>    command: mvn clean install -DskipTests<br/><em class="nd"><br/></em>- save_cache:<br/>    paths:<br/>      - ~/.m2<br/>    key: v1-dependencies-{{ checksum "pom.xml" }}<br/>- run:<br/>    name: Test<br/>    command: mvn test</span></pre><p id="dfe3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通常，构建配置会首先使用maven命令加载maven依赖项。</p><pre class="lq lr ls lt gt mu mv mw mx aw my bi"><span id="da7d" class="lv lw iq mv b gy mz na l nb nc"><em class="nd">mvn dependency:go-offline</em></span></pre><p id="349c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为我们有一个多模块maven构建，并且主模块(sms-service)依赖于其他模块中构建的jar，所以在保存缓存之前，我们必须首先构建整个项目。</p><p id="6572" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为服务构建maven的最后一步是生成docker映像。</p><h2 id="ffd9" class="lv lw iq bd lx ly lz dn ma mb mc dp md ko me mf mg ks mh mi mj kw mk ml mm mn bi translated">推到码头中心</h2><pre class="lq lr ls lt gt mu mv mw mx aw my bi"><span id="8863" class="lv lw iq mv b gy mz na l nb nc">- run:<br/>    name: Docker Push<br/>    command: |<br/>        if [ "${CIRCLE_BRANCH}" == "master" ]; then<br/>            echo "$DOCKER_PASS" | docker login --username $DOCKER_USER --password-stdin<br/>            docker push iainporter/sms-service:${VERSION}<br/>        fi</span></pre><p id="af74" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果正在构建的分支是master(我们已经合并了feature分支)，那么我们希望将映像推送到docker hub。首先，我们需要将docker hub凭证作为两个环境变量添加到项目的CircleCI设置中。</p><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nh"><img src="../Images/507436ca13d5a425fa71828948486f7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EPCwHSXeXTxRh6Nns1FLPQ.png"/></div></div></figure><p id="78ae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用之前提取的版本标记图像。</p><h2 id="ec37" class="lv lw iq bd lx ly lz dn ma mb mc dp md ko me mf mg ks mh mi mj kw mk ml mm mn bi translated">构建本机映像</h2><p id="8684" class="pw-post-body-paragraph kd ke iq kf b kg mo ki kj kk mp km kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">我们已经构建并推出了在JVM中运行的映像。我们还需要建立和推动一个本地映像。</p><figure class="lq lr ls lt gt jr"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="af14" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们必须首先安装GraalVM(第7行)，然后安装原生映像工具(第13行)。请注意，通过使用属性，生成步骤可能需要额外的内存</p><pre class="lq lr ls lt gt mu mv mw mx aw my bi"><span id="9bb0" class="lv lw iq mv b gy mz na l nb nc">-Dquarkus.native.native-image-xmx=8g</span></pre><h2 id="8893" class="lv lw iq bd lx ly lz dn ma mb mc dp md ko me mf mg ks mh mi mj kw mk ml mm mn bi translated">构建结果</h2><p id="c757" class="pw-post-body-paragraph kd ke iq kf b kg mo ki kj kk mp km kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">当推送新的提交时，运行构建，输出将类似于以下内容:</p><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nk"><img src="../Images/c6b790da9d9940c3636385ebf65a692e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b4aSCsBSU9bQke2Uuqwp2A.png"/></div></div></figure><p id="4c2a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">太好了，绿色建筑！现在检查图像是否被推送到docker hub</p><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nl"><img src="../Images/8637f2618b1f1a67c17ed862d77cd8da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uXTZLiUnlatlq91WW_HCSQ.png"/></div></div></figure><p id="473d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们现在有一个CI渠道，可以将我们服务的新形象推送到docker hub。服务的代码，包括如何运行它，在这里<a class="ae kc" href="https://github.com/iainporter/sms-service" rel="noopener ugc nofollow" target="_blank">可以找到</a>。</p><p id="d9f3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该系列的其他部分包括:</p><ul class=""><li id="185c" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated"><a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/building-a-microservice-from-the-ground-up-with-quarkus-kotlin-and-debezium-83ae5c8a8bbc">第一部分:构建框架并添加持久性</a></li><li id="d601" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/implementing-the-transactional-outbox-pattern-with-debezium-in-quarkus-f2680306951">第二部分:使用Kafka Connect和Debezium实施CDC</a></li><li id="46c3" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/building-a-resilient-microservice-with-quarkus-and-wiremock-de59b2a4fac7">第三部分:连接到第三方API并用Wiremock测试</a></li><li id="4d44" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><a class="ae kc" rel="noopener ugc nofollow" target="_blank" href="/securing-a-microservice-in-quarkus-with-openid-connect-505204d1c9a9">第四部分:用OpenIdConnect保护Quarkus中的微服务</a></li><li id="42b8" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><a class="ae kc" href="https://medium.com/@changeant/running-a-microservice-in-quarkus-on-graalvm-52d6b42a5840" rel="noopener">第五部分:使用GraalVM本机运行</a></li><li id="14bd" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated"><a class="ae kc" href="https://medium.com/@changeant/containerizing-your-microservice-in-quarkus-with-jib-fae0f62bd57e" rel="noopener">第六部分:用Jib封装你的微服务</a></li></ul></div></div>    
</body>
</html>