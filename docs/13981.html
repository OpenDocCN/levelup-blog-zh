<html>
<head>
<title>Recursion In Python — Solve Complex Problems With Simple Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的递归——用简单的代码解决复杂的问题</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/recursion-in-python-solve-complex-problems-with-simple-code-f6101fa2b65a?source=collection_archive---------2-----------------------#2022-10-22">https://levelup.gitconnected.com/recursion-in-python-solve-complex-problems-with-simple-code-f6101fa2b65a?source=collection_archive---------2-----------------------#2022-10-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><h2 id="9a1a" class="ir is it bd b dl iu iv iw ix iy iz dk ja translated" aria-label="kicker paragraph">计算机编程语言</h2><div class=""/><div class=""><h2 id="85ea" class="pw-subtitle-paragraph jz jc it bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">举例介绍Python中的递归函数。</h2></div><figure class="ks kt ku kv gt kw gh gi paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="gh gi kr"><img src="../Images/a470b620fa58a859bb32c8ebf131f630.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*chY_40WXKBCAifh7hHkahA.png"/></div></div><figcaption class="ld le gj gh gi lf lg bd b be z dk translated">图像由<a class="ae lh" href="https://medium.com/@dreamferus" rel="noopener">雅各布·费罗斯</a>使用Midjourney生成。</figcaption></figure><p id="2b7f" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">一个<strong class="lk jd">递归函数</strong>是一个调用自身的函数。当一个程序使用相同的重复命令重复使用<em class="me">未知</em>次时，这很有用。</p><p id="0725" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">当你听到<em class="me">迭代</em>时，你可能认为这听起来很像一个循环，你是对的。所有递归函数都可以用循环来执行，特别是<em class="me"> while- </em>循环<em class="me">、</em>，因为我们有未知的迭代次数。那么递归有什么意义呢？在适当的时候，递归可以更加简洁、易读和易于理解。让我们举个例子来说明我的意思。假设我们想要<em class="me">扁平化</em>一个列表，也就是把一个列表变成一个列表。这可以很容易地通过循环或使用列表理解来完成:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="4655" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">简单吧？这里我们不需要递归或while循环。这是因为迭代次数是预定义的，即列表中列表的数量，以及深度，即列表的列表(2)。同样，展平列表的列表也不难，我们只需要另一个循环:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="5cac" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">但是如果嵌套列表的深度是未知的，并且数组中的每个元素都不相同，那该怎么办呢？比如<code class="fe mh mi mj mk b">[1, [[[3]]]]</code>。现在事情变得有点困难了。对于for循环，没有直接的方法可以做到这一点。让我们先用while循环来做这件事:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="5b55" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">你觉得这个片段简单吗？我不知道，这不是很直观。请注意，我对“<em class="me">end condition”</em>的注释不是针对导致循环中断的原因，而是针对阻止我们迭代深入列表的原因，即元素不再是列表。</p><p id="4b87" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们看看递归是什么样子的:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="60e7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">让我们解开这里发生了什么。首先，有一个结束条件。如果参数不再是列表，只需返回一个只包含该元素的列表。递归函数总是需要一个结束条件来避免无限递归。返回列表的原因是稍后使用<code class="fe mh mi mj mk b">+=</code>可以连接它。</p><p id="ebd7" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><em class="me">否则</em>，我们循环遍历列表，并在递归调用每个元素上的函数本身后连接结果。</p><ul class=""><li id="5bd5" class="ml mm it lk b ll lm lo lp lr mn lv mo lz mp md mq mr ms mt bi translated">如果循环的元素<em class="me">不是</em>列表，结束条件将被调用，元素将被添加到列表中。</li><li id="3d61" class="ml mm it lk b ll mu lo mv lr mw lv mx lz my md mq mr ms mt bi translated">如果元素<em class="me">是</em>列表，将再次执行相同的“<em class="me">否则</em>”，将<em class="me">列表中的元素收集到一个扁平列表中。</em></li></ul><p id="a691" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">因此，该函数将继续被调用，直到满足结束条件。然后，结果被收集并迭代返回，直到我们返回到顶层函数调用，得到一个包含所有结果的平面列表。例如，对于</p><p id="4375" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated"><code class="fe mh mi mj mk b">flatten_list_with_recursion([1,[[2]]])</code></p><p id="192d" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">发生了以下情况:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="b01e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">很优雅，不是吗？通过递归定义函数来调用自身，代码变得更加简洁易读。当你开始递归思考时，它们也变得更容易创建。开始时可能很难理解它，但是一旦你对它越来越熟悉，就会更容易看到它何时能简化功能。</p><h1 id="43a9" class="mz na it bd nb nc nd ne nf ng nh ni nj ki nk kj nl kl nm km nn ko no kp np nq bi translated">使用递归有什么缺点吗？</h1><p id="9005" class="pw-post-body-paragraph li lj it lk b ll nr kd ln lo ns kg lq lr nt lt lu lv nu lx ly lz nv mb mc md im bi translated">是的，有。首先，你可以调用递归函数的次数是有限制的，也就是说<em class="me">的深度</em>是有限的。无论何时调用一个方法，关于该方法的信息，比如返回地址，都必须存储在一个所谓的<strong class="lk jd">调用栈</strong>中，直到该方法被完全执行。问题在于，在递归函数中，越来越多的信息被添加到调用堆栈的顶部。如果调用堆栈变得太大，就会出现名为<em class="me">堆栈溢出</em>的错误。下面我用Python模拟了一个由此产生的错误:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="e2b2" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">生成的错误称为<strong class="lk jd"> RecursionError <em class="me"> </em> </strong>，是真正的堆栈溢出前的保护性错误。您可以使用以下方法增加回调:</p><figure class="ks kt ku kv gt kw"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="7b39" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">但是如果增加太多，就会发生实际的堆栈溢出。那么一个可管理的异常将不会被抛出，相反，整个程序将会崩溃。一些语言有所谓的<em class="me">尾部调用优化，</em>来处理这个，但是Python不是其中之一。</p><p id="f29e" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">另一个缺点是递归可能比循环慢，因为添加到调用堆栈会比其他方式消耗更多的内存。也就是说，速度差在许多情况下可以忽略不计。但是，如果你想最大限度地优化你的代码，迭代将是一条路要走。</p><h2 id="2616" class="nw na it bd nb nx ny dn nf nz oa dp nj lr ob oc nl lv od oe nn lz of og np iz bi translated">摘要</h2><p id="f37a" class="pw-post-body-paragraph li lj it lk b ll nr kd ln lo ns kg lq lr nt lt lu lv nu lx ly lz nv mb mc md im bi translated">递归函数在适当的情况下，对于编写更容易维护的易读、简洁的代码是很实用的。但是要意识到它的缺点；它比使用循环要慢，而且过多的函数调用会导致堆栈溢出。感谢阅读。</p></div><div class="ab cl oh oi hx oj" role="separator"><span class="ok bw bk ol om on"/><span class="ok bw bk ol om on"/><span class="ok bw bk ol om"/></div><div class="im in io ip iq"><p id="5f78" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果您有兴趣阅读更多关于Python的文章，请查看我下面的阅读列表:</p><div class="oo op gp gr oq"><div role="button" tabindex="0" class="ab bv gv cb fp or os bn ot lb ex"><div class="ou l"><div class="ab q"><div class="l di"><img alt="Jacob Ferus" class="l de bw ov ow fe" src="../Images/3fe8a4152942d124e84f4370bdeaa704.png" width="20" height="20" loading="lazy" data-original-src="https://miro.medium.com/v2/resize:fill:40:40/1*kBjZOzA4VnMIigyfQz5-KQ.png"/><div class="fb bw l ov ow fc n aw fd"/></div><div class="hh l fo"><p class="bd b dl z fp fq fr fs ft fu fv fw dk translated"><a class="ae af ag ah ai aj ak al am an ao ap aq ar as" href="https://medium.com/@dreamferus?source=post_page-----f6101fa2b65a--------------------------------" rel="noopener follow" target="_top">雅各布·费罗斯</a></p></div></div><div class="oz pa gw l"><h2 class="bd jd uf ml fp ug fr fs uh fu fw jc bi translated">计算机编程语言</h2></div><div class="ab q"><div class="l fo"><a class="bd b be z bi ui au uj uk ul qu um an eh ei un uo up el em eo de bk ep" href="https://medium.com/@dreamferus/list/python-c8e4719d93da?source=post_page-----f6101fa2b65a--------------------------------" rel="noopener follow" target="_top">View list</a></div><div class="uq l fo"><span class="bd b dl z dk">32 stories</span></div></div></div><div class="pm dh pn fp ab po fo di"><div class="di pe bv pf pg"><div class="dh l"><img alt="" class="dh" src="../Images/04c5beba0e198bb074b51dab1e99cea5.png" width="194" height="194" loading="lazy" role="presentation" data-original-src="https://miro.medium.com/v2/resize:fill:388:388/1*NDYYDnoigpuPoAeetcRcFg.png"/></div></div><div class="di pe bv ph pi pj"><div class="dh l"><img alt="" class="dh" src="../Images/ddc10e2a657adb0dca6dc40fbab3ef74.png" width="194" height="194" loading="lazy" role="presentation" data-original-src="https://miro.medium.com/v2/resize:fill:388:388/1*s5kLvTIF2VvEEahx_OJaXA.png"/></div></div><div class="di bv pk pl pj"><div class="dh l"><img alt="" class="dh" src="../Images/c0376aaf2f82f915fbbb9e6f86a2c621.png" width="194" height="194" loading="lazy" role="presentation" data-original-src="https://miro.medium.com/v2/resize:fill:388:388/1*m7BwF83vfu-cfexGQ8px0w.png"/></div></div></div></div></div><p id="9d57" class="pw-post-body-paragraph li lj it lk b ll lm kd ln lo lp kg lq lr ls lt lu lv lw lx ly lz ma mb mc md im bi translated">如果你想成为中级会员，你可以使用我的推荐链接。祝你有愉快的一天。</p></div></div>    
</body>
</html>