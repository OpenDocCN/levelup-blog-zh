<html>
<head>
<title>Cross Platform Mobile and Web Development with C++ Explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用C++进行跨平台移动和Web开发</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/cross-platform-mobile-and-web-development-with-c-explained-94e112d31351?source=collection_archive---------13-----------------------#2020-05-19">https://levelup.gitconnected.com/cross-platform-mobile-and-web-development-with-c-explained-94e112d31351?source=collection_archive---------13-----------------------#2020-05-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9a1f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">第5部分:多线程</h2></div><p id="7368" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们处理图形软件时，我们需要确保我们的用户界面保持响应。这就是我们需要多线程的原因，我们需要能够在后台执行长时间的操作，并将结果返回到前台。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi lb"><img src="../Images/c21990afcfc3423811b667b1b39153f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*lY_4tZaf6afJK_gcccv3ow.jpeg"/></div></figure><p id="d927" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">C++11发挥了成熟的多线程库的作用，它是可移植的，易于使用。比<a class="ae lj" href="https://en.wikipedia.org/wiki/POSIX" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir"> POSIX </strong> </a>线程简单多了。然而，我们需要小心一些陷阱。</p><p id="f998" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">源代码在这里:【https://github.com/skonstant/xptuto/tree/part5_threads】T4</p><h1 id="f9da" class="lk ll iq bd lm ln lo lp lq lr ls lt lu jw lv jx lw jz lx ka ly kc lz kd ma mb bi translated">主线程</h1><p id="bd0b" class="pw-post-body-paragraph kf kg iq kh b ki mc jr kk kl md ju kn ko me kq kr ks mf ku kv kw mg ky kz la ij bi translated">每个图形工具包都有我们称之为<em class="mh">的主线程</em>。这不仅仅是一个线程，它实际上是一个循环，一个无限的循环，程序员或操作系统可以停止它。循环处理事件上的动作(一个按钮点击，<em class="mh">例如</em>)，绘制UI和其他东西，按照一定的顺序。为了能够向主线程发送数据，我们实际上<em class="mh">向队列发送</em>消息，然后在循环中处理该消息。如果处理消息的时间太长，循环就没有时间绘制，我们就会感到紧张不安。</p><p id="7eaf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">C++本身或任何编程环境都不知道主循环，UI工具包知道，在我们的例子中，iOS上的<strong class="kh ir"> UIKit </strong>，Android上的<strong class="kh ir"> Activity </strong>框架，以及Web assembly中的<strong class="kh ir">浏览器事件循环</strong>。</p><p id="fda5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于我们的工作，我们需要一个通用的方法在主循环上运行一些东西，在后台线程中运行就像创建一个新的<strong class="kh ir"> std::thread </strong>一样简单。(Java除外，下面我们会看到)。</p><pre class="lc ld le lf gt mi mj mk ml aw mm bi"><span id="e7b9" class="mn ll iq mj b gy mo mp l mq mr">std::thread t([](<strong class="mj ir">const </strong>std::shared_ptr&lt;ThreadFunc&gt; &amp;f) {<br/>    f-&gt;run();<br/>}, func);<br/>t.detach();</span></pre><p id="bb1c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为我们需要用Java实现它，我们在Djinni中定义了我们的<em class="mh"> PlatformThreads </em>接口，灵感来自于<a class="ae lj" href="https://github.com/dropbox/djinni/tree/master/extension-libs/platform-threads" rel="noopener ugc nofollow" target="_blank"> DropBox </a>的一个实现。</p><pre class="lc ld le lf gt mi mj mk ml aw mm bi"><span id="c4d8" class="mn ll iq mj b gy mo mp l mq mr">platform_threads = interface +j +c {<br/>    create_thread(name: string, func: thread_func);<br/><br/>    run_on_main_thread(func: thread_func);<br/><br/>    is_main_thread(): bool;<br/>}<br/><br/>thread_func = interface +c {<br/>    run();<br/>}</span></pre><p id="002c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们需要一个线程函数接口，类似于<em class="mh">Runnable.java</em>。和3个简单的方法:create_thread()，run_on_main_thread()我们需要能够查询环境，看看我们是否在主线程中，这样我们就可以避免post，我们可以直接运行。</p><h2 id="8777" class="mn ll iq bd lm ms mt dn lq mu mv dp lu ko mw mx lw ks my mz ly kw na nb ma nc bi translated">苹果实现</h2><p id="6ac8" class="pw-post-body-paragraph kf kg iq kh b ki mc jr kk kl md ju kn ko me kq kr ks mf ku kv kw mg ky kz la ij bi translated">这是最简单的一个，还是在<strong class="kh ir">中。mm </strong>，我们使用滑稽命名的<a class="ae lj" href="https://developer.apple.com/documentation/dispatch?language=objc" rel="noopener ugc nofollow" target="_blank"><em class="mh">Grand Central Dispatch</em></a>库(我们不添加任何库，它是<strong class="kh ir">基础</strong>的一部分)，我们需要的只是主线程的工作，创建一个线程是在C++中完成的，就像上面一样。</p><p id="8a1e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">发布一个要在主线程中执行的<em class="mh"> ThreadFunc </em>是这样完成的:</p><pre class="lc ld le lf gt mi mj mk ml aw mm bi"><span id="69f1" class="mn ll iq mj b gy mo mp l mq mr">__block <strong class="mj ir">auto </strong>f = func;<br/><br/>dispatch_async(dispatch_get_main_queue(), ^(<strong class="mj ir">void</strong>) {<br/>    f-&gt;run();<br/>});</span></pre><p id="485c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意，我们需要将shared_ptr to func复制到__block变量中，这样它的引用计数就会增加。如果我们不这样做，func可能会在func-&gt;run()被调用之前被释放，我们会进入“未定义的行为”，也称为“崩溃”。</p><p id="b303" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里最酷的是:<strong class="kh ir"> func </strong>是一个C++ <strong class="kh ir"> shared_ptr </strong>和<strong class="kh ir"> __block </strong>是一个Objective-C编译器关键字，从设计上来说，它们可以完美地协同工作。</p><p id="9f25" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们如何知道我们在主线程上？<strong class="kh ir"> NSThread.isMainThread </strong>。</p><p id="cb59" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">MacOS和iOS的工作已经完成，我们可以在GTEST中测试所有这些，并且工作正常。</p><h2 id="8690" class="mn ll iq bd lm ms mt dn lq mu mv dp lu ko mw mx lw ks my mz ly kw na nb ma nc bi translated">Web程序集实现</h2><p id="2c90" class="pw-post-body-paragraph kf kg iq kh b ki mc jr kk kl md ju kn ko me kq kr ks mf ku kv kw mg ky kz la ij bi translated">同样，创建线程是用<strong class="kh ir"> std::thread </strong>完成的。发布到前台并没有多复杂，除了没有方法，据我所知，找到emscriten<a class="ae lj" href="https://emscripten.org/docs/api_reference/html5.h.html" rel="noopener ugc nofollow" target="_blank">html 5 API</a>中的主线程。</p><p id="d886" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们需要保存我们被初始化的线程id，并且我们需要在主浏览器线程中被初始化。这将是我们使用的惯例。</p><pre class="lc ld le lf gt mi mj mk ml aw mm bi"><span id="f5e4" class="mn ll iq mj b gy mo mp l mq mr"><strong class="mj ir">const </strong>std::thread::id main_thread_id;</span><span id="66f6" class="mn ll iq mj b gy nd mp l mq mr"><strong class="mj ir">static inline </strong>std::mutex functionsMutex;<br/><strong class="mj ir">static inline </strong>std::queue&lt;std::shared_ptr&lt;xptuto::ThreadFunc&gt;&gt; functionsToRun;</span><span id="e233" class="mn ll iq mj b gy nd mp l mq mr">WebThreads::WebThreads(): main_thread_id(std::this_thread::get_id()){<br/>    emscripten_request_animation_frame_loop(main_loop, <strong class="mj ir">nullptr</strong>);<br/>}</span><span id="a83f" class="mn ll iq mj b gy nd mp l mq mr"><strong class="mj ir">void </strong>WebThreads::run_on_main_thread(<strong class="mj ir">const </strong>std::shared_ptr&lt;ThreadFunc&gt; &amp;func) {<br/>    <strong class="mj ir">const </strong>std::lock_guard&lt;std::mutex&gt; lock(functionsMutex);<br/>    functionsToRun.push(func);<br/>}</span><span id="c4f7" class="mn ll iq mj b gy nd mp l mq mr"><strong class="mj ir">EM_BOOL </strong>main_loop(<strong class="mj ir">double </strong>time, <strong class="mj ir">void</strong>* userData) {<br/>    <strong class="mj ir">if </strong>(WebThreads::functionsToRun.empty()) {<br/>        <strong class="mj ir">return EM_TRUE</strong>;<br/>    }<br/><br/>    <strong class="mj ir">auto </strong>func = WebThreads::functionsToRun.front();<br/>    func-&gt;run();<br/><br/>    <strong class="mj ir">const </strong>std::lock_guard&lt;std::mutex&gt;<br/>                  lock(WebThreads::functionsMutex);<br/>    WebThreads::functionsToRun.pop();<em class="mh"><br/>    </em><strong class="mj ir">return EM_TRUE</strong>;<br/>}</span></pre><p id="4646" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的<strong class="kh ir"> main_thread_id </strong>是<strong class="kh ir"> const </strong>。它不能被改变，但是我们不能验证这实际上是主浏览器线程，我们相信我们自己不会在一个工人中初始化它。</p><p id="7ee1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二步是初始化一个循环，只要我们告诉它，浏览器就会调用它，这也需要一个C函数，所以我们的<strong class="kh ir"> std::queue </strong>是<strong class="kh ir"> static </strong>，我们的<strong class="kh ir"> std::mutex </strong>也是如此。在循环中，我们检查队列，运行前端<em class="mh"> ThreadFunc </em>并交还控制权。环境会一直调用这个函数:我们有我们的主循环。</p><p id="6177" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们需要一个互斥体，因为STL写不是线程安全的，但是读是，因此锁保护调用的位置很低。</p><p id="de0f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们在浏览器中实现了完全线程化。已经比Javascript环境好得多了，Javascript环境对后台操作没有任何支持，而且Workers API也不是线程的对手。</p><p id="45b7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，这在GTEST中测试不太好，因为浏览器似乎需要一个主循环迭代来启动后台线程，所以我们的promise/future锁阻止了<em class="mh"> ThreaFunc </em>的执行，这有点烦人，但无论如何，GTEST维护者建议不要尝试测试异步的东西。</p><h2 id="2b0c" class="mn ll iq bd lm ms mt dn lq mu mv dp lu ko mw mx lw ks my mz ly kw na nb ma nc bi translated">Android实现</h2><p id="1d97" class="pw-post-body-paragraph kf kg iq kh b ki mc jr kk kl md ju kn ko me kq kr ks mf ku kv kw mg ky kz la ij bi translated">在这种情况下，create_thread()和run_on_main_thread()都必须用Java来完成。我们不能创建std::thread(由于这个原因，不应该直接在我们的代码中创建)，因为如果我们重新进入Java代码，JVM必须知道一个新的线程。</p><blockquote class="ne nf ng"><p id="4f21" class="kf kg mh kh b ki kj jr kk kl km ju kn nh kp kq kr ni kt ku kv nj kx ky kz la ij bi translated"><em class="iq"> JNI </em>接口指针(JNIEnv)只在当前线程中有效。如果另一个线程需要访问Java虚拟机，它必须首先调用<em class="iq"> AttachCurrentThread </em>()</p></blockquote><p id="b175" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们不想这样做，我们不想知道C++可移植代码中的JVM，所以我们抽象了线程，这里是Android实现(不是Java <em class="mh">本身</em>，Java像C++一样没有主线程的概念)。这是Java 8，所以方法引用使它非常简洁。</p><pre class="lc ld le lf gt mi mj mk ml aw mm bi"><span id="f064" class="mn ll iq mj b gy mo mp l mq mr">@Override<br/><strong class="mj ir">public void </strong>createThread(String name, <strong class="mj ir">final </strong>ThreadFunc func) {<br/>    <strong class="mj ir">new </strong>Thread(func::run, name).start();<br/>}</span><span id="bafd" class="mn ll iq mj b gy nd mp l mq mr">@Override<br/><strong class="mj ir">public void </strong>runOnMainThread(<strong class="mj ir">final </strong>ThreadFunc func) {<br/>    <strong class="mj ir">new </strong>Handler(Looper.<em class="mh">getMainLooper</em>()).post(func::run);<br/>}<br/><br/>@Override<br/><strong class="mj ir">public boolean </strong>isMainThread() {<br/>    <strong class="mj ir">return </strong>Looper.<em class="mh">getMainLooper</em>() == Looper.<em class="mh">myLooper</em>();<br/>}</span></pre><p id="fda3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以在另一个<em class="mh">仪器测试</em>中轻松测试这一点。</p><pre class="lc ld le lf gt mi mj mk ml aw mm bi"><span id="f5d1" class="mn ll iq mj b gy mo mp l mq mr">@Test<br/><strong class="mj ir">public void </strong>backgroundThread() <strong class="mj ir">throws </strong>InterruptedException {<br/>    <strong class="mj ir">new </strong>AndroidThreads()<br/>            .createThread(<strong class="mj ir">"background"</strong>, <strong class="mj ir">new </strong>ThreadFunc() {<br/>        @Override<br/>        <strong class="mj ir">public void </strong>run() {<br/>            <em class="mh">assertNotEquals</em>(Looper.<em class="mh">myLooper</em>(), Looper.<em class="mh">getMainLooper</em>());<br/>            <strong class="mj ir">synchronized </strong>(ThreadsInstrumentedTest.<strong class="mj ir">this</strong>) {<br/>                ThreadsInstrumentedTest.<strong class="mj ir">this</strong>.notify();<br/>            }<br/>        }<br/>    });<br/><br/>    <strong class="mj ir">synchronized </strong>(<strong class="mj ir">this</strong>) {<br/>        <strong class="mj ir">this</strong>.wait();<br/>    }<br/>}<br/><br/>@Test<br/><strong class="mj ir">public void </strong>mainThread() {<br/>    <strong class="mj ir">new </strong>AndroidThreads().runOnMainThread(<strong class="mj ir">new </strong>ThreadFunc() {<br/>        @Override<br/>        <strong class="mj ir">public void </strong>run() {<br/>            <em class="mh">assertEquals</em>(Looper.<em class="mh">getMainLooper</em>(), <br/>                            Looper.<em class="mh">getMainLooper</em>());<br/>        }<br/>    });<br/>}</span></pre><h1 id="a04d" class="lk ll iq bd lm ln lo lp lq lr ls lt lu jw lv jx lw jz lx ka ly kc lz kd ma mb bi translated">同步联网</h1><p id="436c" class="pw-post-body-paragraph kf kg iq kh b ki mc jr kk kl md ju kn ko me kq kr ks mf ku kv kw mg ky kz la ij bi translated">我们从能够在后台运行我们想要的任何操作中获得的第一个优势是，现在我们可以进行<em class="mh">同步联网</em>。再往前，我们将能够在后台运行复杂的逻辑，任何事情都可以。</p><p id="84fb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们可以一个接一个地运行我们的调用，以构建一个视图模型，然后我们将该模型转发到视图层，这使得代码更加清晰，调试更加容易。</p><p id="804e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们的示例中，我们现在可以按名称加载用户及其所有存储库:</p><pre class="lc ld le lf gt mi mj mk ml aw mm bi"><span id="4cc4" class="mn ll iq mj b gy mo mp l mq mr"><strong class="mj ir">void </strong>XptutoImpl::get_repos_for_user_name(<br/>        <strong class="mj ir">const </strong>std::string &amp;username,<br/>        <strong class="mj ir">const </strong>std::shared_ptr&lt;xptuto::GetReposCb&gt; &amp;cb) {<br/>    <strong class="mj ir">auto </strong>me = shared_from_this();<br/><br/>    threads-&gt;create_thread(<strong class="mj ir">"get_repos_for_user_name"</strong>, <br/>      std::make_shared&lt;ThreadFuncImpl&gt;([me, cb, username](){<br/>        <strong class="mj ir">try </strong>{<br/>            <strong class="mj ir">auto </strong>user = me-&gt;get_user_sync(username);<br/>            <strong class="mj ir">if </strong>(!user) {<br/>                ...<br/>            } <strong class="mj ir">else </strong>{<br/>                <strong class="mj ir">try </strong>{<br/>                    <strong class="mj ir">auto </strong>repos = me-&gt;get_repos_sync(user.value());<br/>                    me-&gt;threads-&gt;run_on_main_thread(<br/>           std::make_shared&lt;ThreadFuncImpl&gt;([cb, repos, user](){<br/>                        cb-&gt;on_success(repos, user.value());<br/>                    }));<br/>                } <strong class="mj ir">catch </strong>(...) {<br/>                    ...<br/>                }<br/>            }<br/>        } <strong class="mj ir">catch </strong>(...) {<br/>            ...<br/>        }<br/>    }));<br/>}</span></pre><ol class=""><li id="b556" class="nk nl iq kh b ki kj kl km ko nm ks nn kw no la np nq nr ns bi translated">加载用户，请按2。加载repos，3。在主线程上发送响应。</li></ol><p id="2766" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这在我们的GTEST中简单测试过，不再需要承诺/未来，因为我们的方法是同步的。</p><pre class="lc ld le lf gt mi mj mk ml aw mm bi"><span id="bc7b" class="mn ll iq mj b gy mo mp l mq mr"><strong class="mj ir">TEST_F</strong>(Xptuto, GetUserSyncTest) {<br/>    <strong class="mj ir">auto </strong>instance = std::make_shared&lt;XptutoImpl&gt;(stubHttp, <br/>                                              stubThreads);<br/>    stubHttp-&gt;path = <strong class="mj ir">"/responses/users_aosp.json"</strong>;<br/><br/>    <strong class="mj ir">auto </strong>user = instance-&gt;get_user_sync(<strong class="mj ir">"aosp"</strong>);<br/>    <strong class="mj ir">EXPECT_EQ</strong>(<strong class="mj ir">"aosp"</strong>, user-&gt;login);<br/>}<br/><br/><strong class="mj ir">TEST_F</strong>(Xptuto, GetRepoSyncTest) {<br/>    <strong class="mj ir">auto </strong>instance = std::make_shared&lt;XptutoImpl&gt;(stubHttp,<br/>                                               stubThreads);<br/>    stubHttp-&gt;path = <strong class="mj ir">"/responses/users_aosp.json"</strong>;<br/><br/>    <strong class="mj ir">auto </strong>user = instance-&gt;get_user_sync(<strong class="mj ir">"aosp"</strong>);<br/>    <strong class="mj ir">EXPECT_EQ</strong>(<strong class="mj ir">"aosp"</strong>, user-&gt;login);<br/><br/>    stubHttp-&gt;path = <strong class="mj ir">"/responses/repos_aosp.json"</strong>;<br/>    <strong class="mj ir">auto </strong>repos = instance-&gt;get_repos_sync(user.value());<br/>    <strong class="mj ir">EXPECT_FALSE</strong>(repos.empty());<br/>}</span></pre><p id="de4e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为此，我们用新的get_sync()方法扩展了我们的HTTP客户端，与get()方法非常相似，但更简单，下面是WebAssembly版本:</p><pre class="lc ld le lf gt mi mj mk ml aw mm bi"><span id="78fd" class="mn ll iq mj b gy mo mp l mq mr">HttpResponse WebHttpClient::get_sync(<strong class="mj ir">const </strong>std::string &amp;url) {<br/>    emscripten_fetch_attr_t attr;<br/>    emscripten_fetch_attr_init(&amp;attr);<br/>    strcpy(attr.requestMethod, <strong class="mj ir">"GET"</strong>);<br/>    attr.attributes = EMSCRIPTEN_FETCH_LOAD_TO_MEMORY | <br/>        EMSCRIPTEN_FETCH_SYNCHRONOUS;<br/>    emscripten_fetch_t *fetch = emscripten_fetch(&amp;attr,url.c_str());<br/>    <em class="mh">// Blocks here until the operation is complete.<br/><br/>    </em>std::optional&lt;std::string&gt; body;<br/>    <strong class="mj ir">if </strong>(fetch-&gt;data &amp;&amp; fetch-&gt;numBytes &gt; 0) {<br/>        body = {fetch-&gt;data,<br/>        <strong class="mj ir">static_cast</strong>&lt;std::string_view::size_type&gt;(fetch-&gt;numBytes)};<br/>    }<br/><br/>    std::optional&lt;int32_t&gt; code;<br/>    <strong class="mj ir">if </strong>(fetch-&gt;status) {<br/>        code = fetch-&gt;status;<br/>    }<br/>    <strong class="mj ir">auto </strong>response = HttpResponse(code, body);<br/>    emscripten_fetch_close(fetch);<br/>    <strong class="mj ir">return </strong>response;<br/>}</span></pre><p id="586c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不需要回调，更容易阅读和调试。</p><p id="e521" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是练习这一点的Web视图代码。</p><pre class="lc ld le lf gt mi mj mk ml aw mm bi"><span id="c64e" class="mn ll iq mj b gy mo mp l mq mr">x.get_repos_for_user_name(<strong class="mj ir">"aosp"</strong>, <strong class="mj ir">new <em class="mh">Module</em></strong>.JSGetReposCb({<br/>    on_error: <strong class="mj ir">function </strong>(error) {<br/>        <strong class="mj ir"><em class="mh">console</em></strong>.error(error)<br/>    },<br/>    on_success: <strong class="mj ir">function </strong>(repos, user) {<br/>        <strong class="mj ir"><em class="mh">console</em></strong>.log(<strong class="mj ir">'Got user with name: ' </strong>+ user.login);<br/>        <strong class="mj ir">for </strong>(<strong class="mj ir">var </strong>i = 0; i &lt; repos.size(); i++) {<br/>            <strong class="mj ir"><em class="mh">console</em></strong>.log(<strong class="mj ir">'Got repo with name: ' </strong>+ repos.get(i).<strong class="mj ir">name</strong>);<br/>        }<br/>    }<br/>}));</span></pre><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="nu nv di nw bf nx"><div class="gh gi nt"><img src="../Images/f251105073027bfd59c6e40dc90fef22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RSaZ0Or48i_-sy0K8kjq1Q.png"/></div></div></figure><p id="8753" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以看到，我们的同步网络请求是在后台线程中运行的(URL旁边的齿轮)。完全用C++实现，用Javascript不可能实现。</p><p id="7a61" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">既然我们可以在不干扰UI的情况下做复杂耗时的事情，我们就可以满怀信心地在C++层实现我们的逻辑了。</p><h1 id="c512" class="lk ll iq bd lm ln lo lp lq lr ls lt lu jw lv jx lw jz lx ka ly kc lz kd ma mb bi translated">另请参阅:</h1><h1 id="1d3b" class="lk ll iq bd lm ln lo lp lq lr ls lt lu jw lv jx lw jz lx ka ly kc lz kd ma mb bi translated"><a class="ae lj" href="https://medium.com/@stephane_21545/cross-platform-mobile-and-web-development-with-c-explained-aac9952b4f8c" rel="noopener">简介:</a></h1><p id="1c6f" class="pw-post-body-paragraph kf kg iq kh b ki mc jr kk kl md ju kn ko me kq kr ks mf ku kv kw mg ky kz la ij bi translated">我们提出我们的技术选择。</p><h1 id="076d" class="lk ll iq bd lm ln lo lp lq lr ls lt lu jw lv jx lw jz lx ka ly kc lz kd ma mb bi translated">1.<a class="ae lj" href="https://medium.com/@stephane_21545/cross-platform-mobile-and-web-development-with-c-explained-8d2ab1224c0a" rel="noopener">项目设置</a></h1><p id="f538" class="pw-post-body-paragraph kf kg iq kh b ki mc jr kk kl md ju kn ko me kq kr ks mf ku kv kw mg ky kz la ij bi translated">我们将配置一个在iOS/Xcode、Android Studio和Emscripten/CMake上编译和运行的项目，并展示如何运行和调试其中的3个项目。</p><h1 id="33d6" class="lk ll iq bd lm ln lo lp lq lr ls lt lu jw lv jx lw jz lx ka ly kc lz kd ma mb bi translated"><a class="ae lj" href="https://medium.com/@stephane_21545/cross-platform-mobile-and-web-development-with-c-explained-587a235cbb0b" rel="noopener"> 2。在</a>周围传递物体</h1><p id="71e6" class="pw-post-body-paragraph kf kg iq kh b ki mc jr kk kl md ju kn ko me kq kr ks mf ku kv kw mg ky kz la ij bi translated">在这个例子中，我们将展示如何将对象从业务逻辑层传递到不同的视图层。</p><h1 id="ec7f" class="lk ll iq bd lm ln lo lp lq lr ls lt lu jw lv jx lw jz lx ka ly kc lz kd ma mb bi translated"><a class="ae lj" href="https://medium.com/swlh/cross-platform-mobile-and-web-development-with-c-explained-8fb5fb916d35" rel="noopener"> 3。单元测试</a></h1><p id="9575" class="pw-post-body-paragraph kf kg iq kh b ki mc jr kk kl md ju kn ko me kq kr ks mf ku kv kw mg ky kz la ij bi translated">这里我们使用常用的<strong class="kh ir">谷歌测试</strong>框架在C++代码中设置单元测试。</p><h1 id="9566" class="lk ll iq bd lm ln lo lp lq lr ls lt lu jw lv jx lw jz lx ka ly kc lz kd ma mb bi translated"><a class="ae lj" href="https://medium.com/swlh/cross-platform-mobile-and-web-development-with-c-explained-e8cd420665af" rel="noopener"> 4。休息客户端</a></h1><p id="d784" class="pw-post-body-paragraph kf kg iq kh b ki mc jr kk kl md ju kn ko me kq kr ks mf ku kv kw mg ky kz la ij bi translated">我们使用平台HTTP实现实现了一个最小的ReST客户端。</p><h1 id="65e9" class="lk ll iq bd lm ln lo lp lq lr ls lt lu jw lv jx lw jz lx ka ly kc lz kd ma mb bi translated"><a class="ae lj" href="https://medium.com/@stephane_21545/cross-platform-mobile-and-web-development-with-c-explained-7076b84c425b" rel="noopener"> 6。使用SQLite的离线数据</a></h1><p id="4a31" class="pw-post-body-paragraph kf kg iq kh b ki mc jr kk kl md ju kn ko me kq kr ks mf ku kv kw mg ky kz la ij bi translated">添加SQLite数据库一如既往地简单。</p></div></div>    
</body>
</html>