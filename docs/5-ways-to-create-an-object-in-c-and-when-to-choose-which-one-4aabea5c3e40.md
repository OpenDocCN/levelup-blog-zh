# 用 C#创建对象的 5 种方法以及何时选择哪一种

> 原文：<https://levelup.gitconnected.com/5-ways-to-create-an-object-in-c-and-when-to-choose-which-one-4aabea5c3e40>

## 当创建一个对象时，像建筑师一样思考。

![](img/fface17199faf6fd3c1b8d04ff43e6c2.png)

照片由 [Fotis Fotopoulos](https://unsplash.com/@ffstop?utm_source=medium&utm_medium=referral) 在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄

在编程世界中，几乎总是有几种方法可以达到相同的结果。如果软件开发人员在开始编写任何代码之前，定期对解决设计或编码问题的可用方法进行权衡分析，他们可以在职业生涯中快速成长。

还有什么比创建一个对象更容易的呢？几乎没有。

然而，即使是开发人员每天做的这种琐碎的任务也有 5 种不同的方法。了解创建对象的每种方法的优缺点将允许开发人员选择最适合他们特定情况的方法。

# 1.使用 new()关键字创建对象

## 优点:

*   这是**实例化一个对象最简单的方法**。这就像创建一个变量或调用一个静态方法一样简单。
*   使用新关键字创建对象的位置没有限制。可以从应用程序的任何部分实例化一个对象，例如实例方法、静态方法、构造函数、catch 块等。
*   对于构造函数中没有大量逻辑的对象或者不是大型对象，使用 new 关键字在性能方面是一个**廉价的过程**(如果您对为什么实例化大型对象是一个耗时的过程感兴趣，可以查看[这是我的帖子](/why-is-list-struct-is-15-times-faster-to-allocate-than-list-class-17f5f79889ae))。

## 缺点:

*   **新的是胶水**。这种创建对象的方式在类之间创建了一种在运行时不会被破坏的紧密耦合。滥用 new 关键字会使代码可重用性、单元测试变得复杂。新关键字用得越多，代码库就变得越庞大。
*   没有简单的方法**来改变对象的寿命**。由 new 关键字实例化的对象的生存期将由外部对象控制。`EmailService`将在`OrderService`创建后创建。`OrderService`一变成垃圾`EmailService`就变成垃圾。为了将一个`EmailService`对象的生命周期切换到一个单一对象，你需要修改`OrderService`类的代码。
*   如果需要执行来自对象构造器的长时间运行的逻辑，分配对象**会更慢**。
*   将一个对象分配到大对象堆**中比分配一个小对象要慢**，因为运行时需要在内存碎片区域中寻找合适的位置。
*   因为可以在代码中的任何地方创建实例，所以很容易以**隐式依赖**结束。如果一个依赖项没有在构造函数中定义，而是在类的方法中创建的，那么这个依赖项被称为隐式的。要回答一个类使用什么依赖关系的问题，开发人员需要分析该类的整个实现。

# 2.将对象创建委托给阿迪容器

创建对象的责任可以委托给一个单独的组件，即依赖注入容器。

## 优点:

*   理解对象使用的依赖关系要容易得多，因为它们都是在构造函数中指定的。开发人员只需要查看构造函数，就可以清楚地知道对象使用的是什么依赖关系，而不必分析类实现的其余部分。DI 容器鼓励使用**显式依赖**。
*   使用阿迪容器允许开发人员轻松切换**对象生命周期**(单例、按请求等)。)，这可以在应用程序的合成根完成，而不必修改应用程序代码的其余部分。
*   DI 容器允许开发人员在同一接口的不同实现之间快速切换应用程序代码。
*   除了完成构建对象图的主要职责之外，DI 容器还提供了**额外的有用特性**，比如拦截。

## 缺点:

*   与直接使用 new 关键字相比，创建对象**要慢一些**，因为 DI 容器使用反射和其他技术。
*   如果应用组合根中的依赖项配置错误，将不会有**编译错误**，而只是运行时崩溃。
*   应用程序中的**流程更难**跟踪。仅通过查看类构造函数中的接口，如果不阅读组合根中的配置，很难猜出当前使用的是哪个实现。
*   开发者需要通过阅读文档来学习如何使用 DI 容器。

# 3.使用反射创建对象

实例化对象的下一种方法是反射机制。

## 优点:

*   反射允许**后期绑定。**反射机制允许开发者创建编译时不存在的类的实例，例如从动态加载的程序集中创建。
*   反射允许开发者实现一些**通用算法**。例如，使用反射的开发人员可以实现一种方法，该方法可以创建任何复杂程度的对象的深层副本。

## 缺点:

*   反射允许开发人员**绕过封装**，所以很容易错误地破坏类不变量。
*   错误实现的反射算法，类型名中的错别字在构建时不会被检测到**，但在运行时会失败。**
*   对象创建**比使用 new 关键字要慢**，因为必须扫描汇编元数据才能找到类型信息。

# 4.从对象池中获取对象

可以从对象池中加载已经预先创建的对象，而不是创建对象。显然，对象必须预先用新的关键字或反射创建，但这只需要做一次。

## 优点:

*   从池中加载一个对象**比从头开始创建一个对象要快得多**，因此应用程序的性能得到了提高。
*   使用对象池**减少了垃圾收集器**的压力，因为对象在使用后被送回对象池，而不是变成垃圾。同样，这提高了应用程序的性能。

## 缺点:

*   记住**在不再需要对象时将它发送回**对象池是很重要的。这是开发人员很容易忘记的一个额外的重要步骤。
*   当开发人员需要保存许多大型对象时，对象池不是最佳选择。**可达到内存限制**。

# 5.通过反序列化创建对象

创建对象的最后一种方法是将它从二进制、JSON 或其他格式反序列化。当然，对象必须预先序列化并存储在内存或外部文件存储中。

## 优点:

*   被序列化并存储到外部存储器的对象将在应用重启后继续存在。有时候，很少改变的大对象构建一次要便宜得多，以二进制格式存储它们，并在需要时将它们反序列化回内存。
*   二进制序列化**比 JSON 或 XML 序列化**更快。
*   二进制序列化可以序列化和反序列化具有**循环依赖**的对象图。

## 缺点:

*   二进制序列化要求对象标记有**【可序列化】**属性。
*   与 JSON 或 XML 序列化相比，二进制序列化不以人类可读的格式存储数据。
*   这种方法需要为序列化文件提供和维护**附加存储**。

# 结论

没有更好或更坏的方法。这完全取决于你的具体情况。找到以最有效的方式解决您的问题的解决方案的唯一方法是权衡您的需求和每种可用方法的利弊，直到找到最合适的方法。

## 我的其他文章

[](/5-ways-to-implement-the-singleton-design-anti-pattern-in-c-68bb664c31f2) [## 在 C#中实现单例设计反模式的 5 种方法

### 各有利弊

levelup.gitconnected.com](/5-ways-to-implement-the-singleton-design-anti-pattern-in-c-68bb664c31f2) [](/5-ways-to-implement-repository-pattern-in-c-e12565e4d4a2) [## C#中五大存储库模式实现的比较

### 一个成熟的软件工程师通常知道解决同一个编程问题的几种方法，并做出选择…

levelup.gitconnected.com](/5-ways-to-implement-repository-pattern-in-c-e12565e4d4a2) [](/5-ways-to-clone-an-object-in-c-d1374ec28efa) [## 在 C#中克隆对象的 5 种方法

### 各有利弊

levelup.gitconnected.com](/5-ways-to-clone-an-object-in-c-d1374ec28efa) 

# 分级编码

感谢您成为我们社区的一员！[订阅我们的 YouTube 频道](https://www.youtube.com/channel/UC3v9kBR_ab4UHXXdknz8Fbg?sub_confirmation=1)或者加入 [**Skilled.dev 编码面试课程**](https://skilled.dev/) 。