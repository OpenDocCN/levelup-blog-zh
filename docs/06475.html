<html>
<head>
<title>A Beginner’s Guide to Svelto.ECS (3.0) with Unity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">斯韦尔托初学者指南。带Unity的ECS (3.0)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/a-beginners-guide-to-svelto-ecs-3-0-with-unity-e9dbc88a2145?source=collection_archive---------3-----------------------#2020-11-29">https://levelup.gitconnected.com/a-beginners-guide-to-svelto-ecs-3-0-with-unity-e9dbc88a2145?source=collection_archive---------3-----------------------#2020-11-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7a62" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">核心概念的逐步介绍</h2></div><p id="a5ec" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我最近决定辞职，成为一名全职独立游戏开发者。当我到达必须做出架构决策的时候，我正在Unity中为一个想法制作原型。作为一名编程出身的人，我总是告诉自己，有一天我会创建一个样板文件，作为我所有游戏项目的基础，以尽量减少未来的重构，并将重点放在设计游戏而不是代码结构上。终于到了兑现对自己承诺的时候了。</p><p id="f978" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我过去曾使用过几个不同的架构框架和库，但它们要么不能让我兴奋，要么不能与Unity顺利合作。在搜索游戏开发中其他屡试不爽的设计模式时，我偶然发现了实体组件系统(ECS)。我被掌握主要原则的容易程度所震惊，我想学习更多。这个视频很好地解释了基本原理:</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="92bb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">免责声明:ECS以其巨大的性能优势而闻名，它还可以帮助开发团队创建更干净、更好管理的代码，但是它常常被认为对一个人的项目来说是大材小用。我对ECS感兴趣，因为我可以接受我的原型花费更长的时间来制作，如果这意味着我可以将它们构建成任何它们可能成为的样子，而不必在未来进行重大的重构。还因为结构良好的代码让我开心！</p><h1 id="3c2d" class="lj lk iq bd ll lm ln lo lp lq lr ls lt jw lu jx lv jz lw ka lx kc ly kd lz ma bi translated">ECS Unity框架</h1><p id="46cd" class="pw-post-body-paragraph kf kg iq kh b ki mb jr kk kl mc ju kn ko md kq kr ks me ku kv kw mf ky kz la ij bi translated">在研究生产就绪且与Unity集成良好的ECS框架时，有两个框架引起了我的注意，原因如下:</p><ol class=""><li id="4e1b" class="mg mh iq kh b ki kj kl km ko mi ks mj kw mk la ml mm mn mo bi translated"><a class="ae mp" href="https://github.com/sschmid/Entitas-CSharp" rel="noopener ugc nofollow" target="_blank"> Entitas-CSharp </a></li></ol><ul class=""><li id="43b2" class="mg mh iq kh b ki kj kl km ko mi ks mj kw mk la mq mm mn mo bi translated">GitHub上的4.7k星星</li><li id="2a93" class="mg mh iq kh b ki mr kl ms ko mt ks mu kw mv la mq mm mn mo bi translated">有很好的介绍视频</li><li id="e4b4" class="mg mh iq kh b ki mr kl ms ko mt ks mu kw mv la mq mm mn mo bi translated">活跃不和谐社区</li></ul><p id="b5df" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">2.<a class="ae mp" href="https://github.com/sebas77/Svelto.ECS" rel="noopener ugc nofollow" target="_blank">斯维尔托。ECS </a></p><ul class=""><li id="b929" class="mg mh iq kh b ki kj kl km ko mi ks mj kw mk la mq mm mn mo bi translated">超级活跃的创造者/维护者</li><li id="8de6" class="mg mh iq kh b ki mr kl ms ko mt ks mu kw mv la mq mm mn mo bi translated">频繁的更新和发布，Seba的实验室<a class="ae mp" href="https://www.sebaslab.com/" rel="noopener ugc nofollow" target="_blank">上有很多文章</a></li><li id="f11b" class="mg mh iq kh b ki mr kl ms ko mt ks mu kw mv la mq mm mn mo bi translated">发布了3款游戏(在创作者担任首席技术官的公司)</li><li id="e132" class="mg mh iq kh b ki mr kl ms ko mt ks mu kw mv la mq mm mn mo bi translated">刚性框架——关注编码中有趣的部分</li><li id="01da" class="mg mh iq kh b ki mr kl ms ko mt ks mu kw mv la mq mm mn mo bi translated">活跃不和谐社区</li></ul><p id="62aa" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">说实话，我决定调查一下斯维尔托。首先是ECS，因为Entitas的介绍视频从设置Jenny代码生成器开始，这吓到了我，因为我不知道Jenny的目的。我不知道学习斯维尔托。ECS最终将成为从各种文章中过滤和拼凑最新信息的艰巨任务。ECS wiki和<a class="ae mp" href="https://github.com/sebas77/Svelto.MiniExamples" rel="noopener ugc nofollow" target="_blank">微型示例</a>中的评论。经过两天的努力理解这些概念，我发现自己只有一个简单的胶囊，你可以用箭头键移动。</p><figure class="lb lc ld le gt lf gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi mw"><img src="../Images/4cb8bb0cc253d55639ffc1a61a678c77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*qnnzOcmZuuqI6P6g0nJW7Q.gif"/></div></div></figure><p id="4643" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在投入了这么多小时后，我对结果感到沮丧，于是我回到Entitas，意识到Jenny代码生成器会自动连接组件，这样你只需创建一个<code class="fe nd ne nf ng b">XComponent</code>并运行Jenny就可以做像<code class="fe nd ne nf ng b">entity.AddX();</code>这样的事情了！</p><p id="8ecb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">尽管如此，我还是很高兴我花时间学习了斯维尔托。因为我觉得我对ECS框架的基础有了更好的理解。斯维尔托。ECS似乎给了用户更多的控制权，因为所有的工作都是手动完成的，所以除非您明确地这样做，否则不会连接或暴露任何东西。</p><p id="6f5b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我决定通过写这篇指南来好好利用我的努力，希望其他人也有兴趣开始使用Svelto。通过一个引导他们完成基本、核心部分的介绍教程，ECS将更受鼓励。因此，我们将一步一步地重现你在上面的gif中看到的！</p><p id="ab6a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="li">编辑:我可能纠结了两天，因为我太不好意思在</em> <a class="ae mp" href="https://discord.gg/3qAdjDb" rel="noopener ugc nofollow" target="_blank"> <em class="li"> Svelto上问初学者问题。ECS Discord </em> </a> <em class="li">，但事实证明，如果你是新手，你可能会在那里提问！希望这个指南能提供很多答案，但是如果你在学习框架的时候遇到了困难，一定要检查一下服务器！</em></p><p id="3f40" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意，本教程中的所有引文都来自Svelto.ECS的创建者Sebastiano Mandalà。它们摘自Seba的实验室的各种文章以及微型示例的评论。</p><h1 id="a502" class="lj lk iq bd ll lm ln lo lp lq lr ls lt jw lu jx lv jz lw ka lx kc ly kd lz ma bi translated">陷害斯维尔托。ECS 3.0</h1><p id="b2bd" class="pw-post-body-paragraph kf kg iq kh b ki mb jr kk kl mc ju kn ko md kq kr ks me ku kv kw mf ky kz la ij bi translated">在我写这篇文章的时候，斯维尔托。ECS 3.0还没有正式发布。在浏览了Seba的实验室和<a class="ae mp" href="https://github.com/sebas77/Svelto.ECS/wiki" rel="noopener ugc nofollow" target="_blank"> Github Wiki </a>上的文章后，我被有多少关于新版本过时的部分的参考文献所淹没，所以我决定从已经更新到最新版本的<a class="ae mp" href="https://github.com/sebas77/Svelto.MiniExamples" rel="noopener ugc nofollow" target="_blank"> MiniExamples </a>中抓取它，并从那里拼凑逻辑，直接进入3.0。特别是，我把重点放在例2——生存上。以下是如何设置Svelto的方法。ECS 3.0:</p><ol class=""><li id="b76d" class="mg mh iq kh b ki kj kl km ko mi ks mj kw mk la ml mm mn mo bi translated">创建新的3D Unity项目</li><li id="d8b0" class="mg mh iq kh b ki mr kl ms ko mt ks mu kw mv la ml mm mn mo bi translated">从<a class="ae mp" href="https://github.com/sebas77/Svelto.MiniExamples/tree/master/Example2-Survival/Packages" rel="noopener ugc nofollow" target="_blank">生存迷你示例</a>或官方GitHub repos if Svelto获取以下模块。在您阅读本文时，ECS 3.0已经发布:</li></ol><ul class=""><li id="0e4d" class="mg mh iq kh b ki kj kl km ko mi ks mj kw mk la mq mm mn mo bi translated"><a class="ae mp" href="https://github.com/sebas77/Svelto.ECS" rel="noopener ugc nofollow" target="_blank">斯维尔托。ECS </a></li><li id="f22c" class="mg mh iq kh b ki mr kl ms ko mt ks mu kw mv la mq mm mn mo bi translated"><a class="ae mp" href="https://github.com/sebas77/Svelto.Common" rel="noopener ugc nofollow" target="_blank">斯维尔托。常见</a></li><li id="7752" class="mg mh iq kh b ki mr kl ms ko mt ks mu kw mv la mq mm mn mo bi translated">斯韦尔托。任务</li><li id="b069" class="mg mh iq kh b ki mr kl ms ko mt ks mu kw mv la mq mm mn mo bi translated"><a class="ae mp" href="https://github.com/sebas77/com.sebaslab.svelto.unsafe" rel="noopener ugc nofollow" target="_blank">com . sebaslab . svelto . unsafe</a></li></ul><p id="3ec1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">3.在文件系统中打开Unity项目，并将模块复制到<code class="fe nd ne nf ng b">Packages/</code> <em class="li"> </em>文件夹中</p><p id="4586" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">4.打开<code class="fe nd ne nf ng b">Packages/manifest.json</code> <em class="li"> </em>并在<em class="li">依赖关系</em>下添加以下内容:</p><pre class="lb lc ld le gt nh ng ni nj aw nk bi"><span id="d5b6" class="nl lk iq ng b gy nm nn l no np">"com.sebaslab.svelto.common": "com.sebaslab.svelto.common@3.0.0",<br/>"com.sebaslab.svelto.ecs": "com.sebaslab.svelto.ecs@3.0.0",<br/>"com.sebaslab.svelto.tasks": "com.sebaslab.svelto.tasks@1.5.8",<br/>"com.sebaslab.svelto.unsafe": "com.sebaslab.svelto.unsafe@4.7.1",</span></pre><p id="01a2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">5.如果您看到任何错误或IntelliSense无法正常工作，您可能需要重新生成项目文件:</p><ul class=""><li id="f82b" class="mg mh iq kh b ki kj kl km ko mi ks mj kw mk la mq mm mn mo bi translated">确保您的IDE包在Unity包管理器中是最新的</li><li id="508f" class="mg mh iq kh b ki mr kl ms ko mt ks mu kw mv la mq mm mn mo bi translated">首选项&gt;外部工具&gt;重新生成项目文件</li></ul><p id="e0f5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们开始吧！</p><h1 id="66e6" class="lj lk iq bd ll lm ln lo lp lq lr ls lt jw lu jx lv jz lw ka lx kc ly kd lz ma bi translated">上下文和组合根</h1><blockquote class="nq nr ns"><p id="89fd" class="kf kg li kh b ki kj jr kk kl km ju kn nt kp kq kr nu kt ku kv nv kx ky kz la ij bi translated">斯维尔托。上下文不是Svelto的正式组成部分。ECS，但它有助于在没有上下文的环境中使用，比如在Unity中。是自举！</p></blockquote><p id="2b44" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们为Svelto创建一个入口点。使用Svelto.Context的ECS。</p><ol class=""><li id="a847" class="mg mh iq kh b ki kj kl km ko mi ks mj kw mk la ml mm mn mo bi translated">在Unity中创建一个空的游戏对象；我们称之为<em class="li">游戏环境</em></li><li id="4604" class="mg mh iq kh b ki mr kl ms ko mt ks mu kw mv la ml mm mn mo bi translated">创建并附加一个<code class="fe nd ne nf ng b">MainContext.cs</code>脚本到<em class="li">游戏环境</em></li></ol><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="nw lh l"/></div></figure><p id="0b43" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如<a class="ae mp" href="https://github.com/sebas77/Svelto.MiniExamples/blob/master/Example2-Survival/Packages/com.sebaslab.svelto.common%403.0.0/Context/Extensions/Unity/UnityContext.cs" rel="noopener ugc nofollow" target="_blank">源代码</a>所示，<code class="fe nd ne nf ng b">UnityContext</code>只是一个包装器，它基于<em class="li"> GameContext的</em> MonoBehavior <em class="li">触发CompositionRoot中的方法。</em>但是<code class="fe nd ne nf ng b">MainCompositionRoot</code>还不存在！让我们改变这一点:</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="nw lh l"/></div></figure><p id="bb93" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是最低限度。那么作文根还应该包括什么呢？</p><blockquote class="nq nr ns"><p id="6510" class="kf kg li kh b ki kj jr kk kl km ju kn nt kp kq kr nu kt ku kv nv kx ky kz la ij bi translated">组合根是所有依赖项被创建和注入的地方。组合根属于上下文，但是一个上下文可以有多个组合根。例如，工厂是一个复合根。</p></blockquote><p id="8f92" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为<strong class="kh ir">系统</strong>，Svelto称之为<em class="li">引擎，</em>是ECS中唯一包含逻辑的部分，甚至创建实体和组件都发生在引擎内部。因此，自然地，我们将在复合根中创建一堆引擎！通过<a class="ae mp" href="https://github.com/sebas77/Svelto.MiniExamples/blob/master/Example2-Survival/Packages/com.sebaslab.svelto.ecs%403.0.0/EnginesRoot.Engines.cs" rel="noopener ugc nofollow" target="_blank">引擎根</a>管理引擎:</p><blockquote class="nq nr ns"><p id="5c76" class="kf kg li kh b ki kj jr kk kl km ju kn nt kp kq kr nu kt ku kv nv kx ky kz la ij bi translated"><em class="iq"> EnginesRoot </em>类是Svelto.ECS的核心，通过它可以注册引擎并构建游戏的所有实体。动态创建引擎没有多大意义，所以所有引擎都应该从创建它的同一个复合根添加到EnginesRoot实例中。出于类似的原因，EnginesRoot实例决不能被注入，并且一旦添加引擎就不能被删除。</p></blockquote><p id="8691" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好吧！因此，让我们向复合根添加一个EnginesRoot实例，并确保在上下文被破坏时清理它。</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="nw lh l"/></div></figure><p id="ebf2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">EnginesRoot需要一个<code class="fe nd ne nf ng b">EntitiesSubmissionsScheduler</code>，它每一次检查并提交实体的变更。我们使用的是<code class="fe nd ne nf ng b">UnityEntitiesSubmissionScheduler</code>，它使用MonoBehavior的<em class="li">更新</em>作为滴答。</p><p id="ae27" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们已经设置好了，可以开始工作了！</p><h1 id="d832" class="lj lk iq bd ll lm ln lo lp lq lr ls lt jw lu jx lv jz lw ka lx kc ly kd lz ma bi translated">产生一个虚拟玩家</h1><p id="d5e0" class="pw-post-body-paragraph kf kg iq kh b ki mb jr kk kl mc ju kn ko md kq kr ks me ku kv kw mf ky kz la ij bi translated">在这个练习中，我们简单地创建了一个“玩家”游戏对象，我们可以用箭头键输入来移动它。让我们先创建游戏对象，然后再详细讨论玩家实体或其组件。</p><ol class=""><li id="3a43" class="mg mh iq kh b ki kj kl km ko mi ks mj kw mk la ml mm mn mo bi translated">创建您喜欢的任何3D游戏对象，将其重命名为<code class="fe nd ne nf ng b">Player</code>，并将其拖至<code class="fe nd ne nf ng b">Resources/Prefabs</code>，使其成为一个预设。从场景中删除对象。</li></ol><p id="b4da" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了实例化这个预置，我们需要一个<code class="fe nd ne nf ng b">GameObjectFactory</code>和一个<code class="fe nd ne nf ng b">PlayerSpawnerEngine</code>。让我们从引擎开始，我们在ECS中的第一个<strong class="kh ir">系统</strong>！</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="nw lh l"/></div></figure><p id="e5f8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后在<code class="fe nd ne nf ng b">MainCompositionRoot</code>中，我们添加以下几行:</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="nw lh l"/></div></figure><p id="88ac" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们按流程走一遍。因为它实现了<code class="fe nd ne nf ng b">IQueryingEntitiesEngine</code>接口，当PlayerSpawnerEngine被添加到MainCompositionRoot中的EnginesRoot时，它获得了对EnginesRoot跟踪的实体<code class="fe nd ne nf ng b">entitiesDB</code>的访问，然后触发了它的<code class="fe nd ne nf ng b">Ready</code>方法。这里的<code class="fe nd ne nf ng b">SpawnPlayer().Run()</code>中的<code class="fe nd ne nf ng b">Run</code>是Svelto的一部分。任务模块，是以下内容的简写:</p><pre class="lb lc ld le gt nh ng ni nj aw nk bi"><span id="31dc" class="nl lk iq ng b gy nm nn l no np">SpawnPlayer().RunOnScheduler(StandardSchedulers.standardScheduler);</span></pre><p id="17e2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这将触发一个期待一个<code class="fe nd ne nf ng b">IEnumerator</code>的任务运行器，该任务运行器将在特定的MonoBehavior事件函数(如<em class="li"> Update </em>或<em class="li"> FixedUpdate </em>)期间逐步执行。<a class="ae mp" href="https://github.com/sebas77/Svelto.MiniExamples/blob/master/Example2-Survival/Packages/com.sebaslab.svelto.tasks%401.5.8/Svelto.Tasks/StandardSchedulers.cs" rel="noopener ugc nofollow" target="_blank"> StandardSchedulers </a>类显示可用的调度程序类型，而<a class="ae mp" href="https://github.com/sebas77/Svelto.MiniExamples/blob/master/Example2-Survival/Packages/com.sebaslab.svelto.tasks%401.5.8/Svelto.Tasks/Runners/Unity/RunnerBehaviourUpdate.cs" rel="noopener ugc nofollow" target="_blank"> RunnerBehaviourUpdate </a>显示各种调度程序在哪个MonoBehavior事件中运行。到目前为止，您可能已经猜到大多数逻辑都在协程内部。</p><p id="57b9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为我们已经引入了任务运行器，所以如果上下文被破坏，我们也应该确保清理调度器，如<code class="fe nd ne nf ng b">MainCompositionRoot.OnContextDestroyed</code>所示。</p><p id="27d5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果此时运行Unity项目，您应该会在控制台中看到“PlayerSpawnerEngine”。如果您将记录器和yield返回封装在一个<code class="fe nd ne nf ng b">while(true)</code>循环中，您将看到每帧速率记录的消息。恭喜你！您已经连接了您的第一个系统！</p><p id="b24f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们快速创建一个<code class="fe nd ne nf ng b">GameObjectFactory</code>并将其传入复合根中的<code class="fe nd ne nf ng b">PlayerSpawnerEngine</code>；记住，组合根是所有依赖项(包括工厂)应该被创建和注入的地方！</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="nw lh l"/></div></figure><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="nw lh l"/></div></figure><p id="4253" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还将更新PlayerSpawnerEngine来创建游戏对象！</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="nw lh l"/></div></figure><p id="68e3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此时，当您运行Unity时，您应该会看到您的播放器被实例化。干得好！接下来，我们将进一步了解实体及其组件。</p><h1 id="97f5" class="lj lk iq bd ll lm ln lo lp lq lr ls lt jw lu jx lv jz lw ka lx kc ly kd lz ma bi translated">实体和组件</h1><p id="7d39" class="pw-post-body-paragraph kf kg iq kh b ki mb jr kk kl mc ju kn ko md kq kr ks me ku kv kw mf ky kz la ij bi translated">给你一些定义；不要担心，我们将一个一个地重温这些:</p><blockquote class="nq nr ns"><p id="69a0" class="kf kg li kh b ki kj jr kk kl km ju kn nt kp kq kr nu kt ku kv nv kx ky kz la ij bi translated"><strong class="kh ir">实体</strong>:必须是真实具体的，你可以用游戏设计的角度来解释的实体。每个实体的名字应该反映游戏设计领域的一个特定概念</p><p id="f377" class="kf kg li kh b ki kj jr kk kl km ju kn nt kp kq kr nu kt ku kv nv kx ky kz la ij bi translated"><strong class="kh ir"> EntityDescriptors </strong>:给出了一种形式化实体的方法，它还定义了一旦构建了实体就必须生成的组件</p><p id="9ea9" class="kf kg li kh b ki kj jr kk kl km ju kn nt kp kq kr nu kt ku kv nv kx ky kz la ij bi translated">IEntityComponent :可以和纯ECS一起使用的实体组件</p><p id="c23e" class="kf kg li kh b ki kj jr kk kl km ju kn nt kp kq kr nu kt ku kv nv kx ky kz la ij bi translated"><strong class="kh ir"> IEntityViewComponent </strong>:实现这个的结构用于包装来自OOP库的对象。除非由于外部库或平台的原因，被迫将ECS代码与OOP代码混合使用，否则您永远不会使用它。这些特殊“混合”组件只能容纳接口</p><p id="e952" class="kf kg li kh b ki kj jr kk kl km ju kn nt kp kq kr nu kt ku kv nv kx ky kz la ij bi translated"><strong class="kh ir">实现者</strong>:entityview component公开的接口必须由实现者实现，实现者实际上是你需要包装的对象。</p></blockquote><p id="c59f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们有了一个可见的玩家对象，让我们开始创建我们的第一个实体和组件！参见上述<strong class="kh ir">实体</strong>和<strong class="kh ir">实体描述符</strong>的定义。</p><blockquote class="nq nr ns"><p id="bdf0" class="kf kg li kh b ki kj jr kk kl km ju kn nt kp kq kr nu kt ku kv nv kx ky kz la ij bi translated">一个<em class="iq"> EntityDescriptor </em>实例给了编码者一个机会，由将要处理它们的引擎独立地正确命名它们的实体…这个类[被用来]构建实体，虽然它真正做的是完全不同的事情，但用户能够编写<strong class="kh ir">build Entity&lt;<em class="iq">Entity descriptor</em>&gt;()</strong>的事实极大地帮助了可视化要构建的实体，并向其他编码者传达意图…然而一个<em class="iq">Entity descriptor！！</em></p></blockquote><p id="c3f3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们将创建一个<code class="fe nd ne nf ng b">PlayerEntityDescriptor</code>，我们可以在头脑中将其概念化为玩家实体。首先，让我们想象一下这个实体需要什么组件或数据。我们需要位置和输入向量。</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="nw lh l"/></div></figure><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="nw lh l"/></div></figure><p id="93a2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些组件扩展了<code class="fe nd ne nf ng b">IEntityComponent</code>，上面的定义说它将与纯ECS一起使用，这意味着数据不必由Unity等第三方库使用。让我们先以这种方式构建组件，然后在需要时升级到<code class="fe nd ne nf ng b">IEntityViewComponent</code>。现在是时候提一下在EntityDescriptors中使用的<a class="ae mp" href="https://github.com/sebas77/Svelto.MiniExamples/blob/master/Example2-Survival/Packages/com.sebaslab.svelto.ecs%403.0.0/ComponentBuilder.cs" rel="noopener ugc nofollow" target="_blank"> ComponentBuilder </a>只接受<code class="fe nd ne nf ng b">IEntityComponent</code>或<code class="fe nd ne nf ng b">IEntityViewComponent</code>。</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="nw lh l"/></div></figure><p id="c0aa" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了构建这个实体，我们首先需要一个实体工厂——就像我们需要一个游戏对象工厂来创建玩家游戏对象一样。幸运的是，EnginesRoot类<a class="ae mp" href="https://github.com/sebas77/Svelto.MiniExamples/blob/master/Example2-Survival/Packages/com.sebaslab.svelto.ecs%403.0.0/EnginesRoot.GenericEntityFactory.cs" rel="noopener ugc nofollow" target="_blank">为我们准备了一个</a>！</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="nw lh l"/></div></figure><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="nw lh l"/></div></figure><p id="96d1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此时，您将看到最后一行的错误，因为<code class="fe nd ne nf ng b">BuildEntity</code>需要参数。你可以查看<a class="ae mp" href="https://github.com/sebas77/Svelto.MiniExamples/blob/master/Example2-Survival/Packages/com.sebaslab.svelto.ecs%403.0.0/IEntityFactory.cs" rel="noopener ugc nofollow" target="_blank"> IEntityFactory </a>的源代码来查看不同的选项，但是它们都需要一个组ID。所以让我们快速建立一个组并修复PlayerSpawnerEngine中的断线:</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="nw lh l"/></div></figure><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="nw lh l"/></div></figure><blockquote class="nq nr ns"><p id="3121" class="kf kg li kh b ki kj jr kk kl km ju kn nt kp kq kr nu kt ku kv nv kx ky kz la ij bi translated">斯维尔托。ECS有一个独特的特性，让用户决定实体的ID(它必须是唯一的)。</p></blockquote><p id="f68c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我只是将实体ID设置为0。</p><p id="ab46" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在尝试运行Unity。恭喜你！您已经创建了第一个实体和组件！不相信我？我们做一个PlayerInputEngine来证明一下吧！</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="nw lh l"/></div></figure><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="nw lh l"/></div></figure><p id="87d3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">希望你能理解正在发生的一切。唯一的新部分是<a class="ae mp" href="https://github.com/sebas77/Svelto.MiniExamples/blob/master/Example2-Survival/Packages/com.sebaslab.svelto.ecs%403.0.0/EntitiesDB.cs" rel="noopener ugc nofollow" target="_blank"> QueryEntities </a>，由于方法重载，它可以以许多不同的方式使用。一般来说，它返回您正在寻找的组件的数组，包装在一个<a class="ae mp" href="https://github.com/sebas77/Svelto.MiniExamples/blob/master/Example2-Survival/Packages/com.sebaslab.svelto.common%403.0.0/DataStructures/Arrays/NB.cs" rel="noopener ugc nofollow" target="_blank"> NativeBuffer </a>中，以及找到的组件的计数(第一种类型，如果给定多个的话)。</p><p id="f7a6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，当您运行Unity时，您应该在按下箭头键时在控制台中看到您的输入日志！这实际上是更改和读取播放器实体的InputComponent数据。干得好，走了这么远！让我们转到最后一部分。</p><h1 id="96ad" class="lj lk iq bd ll lm ln lo lp lq lr ls lt jw lu jx lv jz lw ka lx kc ly kd lz ma bi translated">混合ECS</h1><blockquote class="nq nr ns"><p id="c260" class="kf kg li kh b ki kj jr kk kl km ju kn nt kp kq kr nu kt ku kv nv kx ky kz la ij bi translated">执行者充当Svelto之间的桥梁。ECS引擎和第三方平台。这个特性对于混合ECS和OOP库是非常重要的。如果您需要unity与Svelto引擎通信，您不需要使用笨拙的变通方法，只需创建一个Monobehaviour实现程序。通过这种方式，你可以在实现者内部使用Unity回调，比如OnTriggerEnter/OnTriggerExit，并根据Unity回调修改数据。除了设置实体组件数据之外，不应在这些回调中使用逻辑。</p></blockquote><p id="3df1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">到目前为止，我们只在“纯”ECS中创建了组件，但是我们需要数据来与Unity的游戏对象进行交互。这就是<code class="fe nd ne nf ng b">Implementors</code>和<code class="fe nd ne nf ng b">IEntityViewComponent</code>的用武之地。看看前一节中它们的定义。这两部分是“混合”ECS的核心，包括与外部库的集成，如Unity的。</p><p id="c07d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是提醒您的好时机，EntityDescriptors中的<code class="fe nd ne nf ng b">ComponentBuilder</code>只接受<code class="fe nd ne nf ng b">IEntityComponent</code>或<code class="fe nd ne nf ng b">IEntityViewComponent</code>。所以让我们为位置数据创建一个<em class="li"> IEntityViewComponent </em>，更新PlayerEntityDescriptor来构建<em class="li"> PositionViewComponent </em>而不是<em class="li"> PositionComponent </em>，并为玩家游戏对象构建一个<em class="li">实现者</em>来与位置数据交互。</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="nw lh l"/></div></figure><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="nw lh l"/></div></figure><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="nw lh l"/></div></figure><p id="1439" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们将把实现者添加到玩家游戏对象中，并确保在为ECS端构建实体时传递它:</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="nw lh l"/></div></figure><p id="ac03" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，让我们制作一个PlayerMovementEngine，它查询PlayersGroup中的InputComponents和PositionComponents，然后根据输入数据更新位置数据！</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="nw lh l"/></div></figure><p id="e981" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不要忘记将新的引擎添加到CompositionRoot中的EnginesRoot！</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="nw lh l"/></div></figure><p id="a206" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这一刻已经到来；继续运行您的Unity项目吧！瞧啊。</p><h1 id="5e10" class="lj lk iq bd ll lm ln lo lp lq lr ls lt jw lu jx lv jz lw ka lx kc ly kd lz ma bi translated">结论</h1><p id="51b0" class="pw-post-body-paragraph kf kg iq kh b ki mb jr kk kl mc ju kn ko md kq kr ks me ku kv kw mf ky kz la ij bi translated">我们刚刚构建的项目可以在GitHub上的<a class="ae mp" href="https://github.com/jiheh/SveltoEcsIntro" rel="noopener ugc nofollow" target="_blank">jiheh/sveltoecsinro</a>下找到。虽然我们只做了一个非常简单的演示，但我们已经了解了Svelto的核心部分。ECS在流程中工作:</p><ul class=""><li id="1eb5" class="mg mh iq kh b ki kj kl km ko mi ks mj kw mk la mq mm mn mo bi translated">设置上下文和合成根</li><li id="afd3" class="mg mh iq kh b ki mr kl ms ko mt ks mu kw mv la mq mm mn mo bi translated">使用工厂构建ECS实体(和Unity游戏对象)</li><li id="8909" class="mg mh iq kh b ki mr kl ms ko mt ks mu kw mv la mq mm mn mo bi translated">创建组件并通过属于指定组的EntityDescriptors构建它们</li><li id="c376" class="mg mh iq kh b ki mr kl ms ko mt ks mu kw mv la mq mm mn mo bi translated">查询特定组中的数据组件并通过引擎更新它们</li><li id="63db" class="mg mh iq kh b ki mr kl ms ko mt ks mu kw mv la mq mm mn mo bi translated">借助组件接口、IEntityViewComponent和实现者，通过混合ECS与Unity集成</li></ul><p id="b399" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当然，斯维尔托。ECS有许多更复杂的概念需要探索，但是希望在很好地掌握基础知识的情况下，您能够轻松地将新的部分与您现有的基础联系起来。</p><p id="d261" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我想提最后一句话，当你们合并斯维尔托的时候。ECS到您自己的项目中:</p><blockquote class="nq nr ns"><p id="80e3" class="kf kg li kh b ki kj jr kk kl km ju kn nt kp kq kr nu kt ku kv nv kx ky kz la ij bi translated">当用svelto开发时，用户需要计划一点他需要工作的实体以及这些实体将会有什么行为。引擎[和实体组件]可以随着时间的推移而添加，所以关键是要对要处理的实体有一个好的概念。所有的推理都应该从实体描述符开始。</p></blockquote><p id="31a2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本指南到此结束！作为下一步，我建议通过<a class="ae mp" href="https://github.com/sebas77/Svelto.MiniExamples/tree/master/Example2-Survival" rel="noopener ugc nofollow" target="_blank">生存小例子</a>来看看斯维尔托。ECS为更大的项目而行动。</p><p id="82cf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我开始调查斯维尔托。ECS，因为我想为我的游戏项目找到一个起点。不管是Entitas还是Svelto。ECS是答案还没有确定，但我已经学到了很多，希望你也是！</p></div></div>    
</body>
</html>