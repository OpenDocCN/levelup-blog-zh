<html>
<head>
<title>JavaScript Function Construction (Part 4)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript函数构造(第4部分)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-function-construction-part-4-d532f0a5e4af?source=collection_archive---------19-----------------------#2020-04-11">https://levelup.gitconnected.com/javascript-function-construction-part-4-d532f0a5e4af?source=collection_archive---------19-----------------------#2020-04-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d7b1" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">立即调用函数构造函数并作出反应</h2></div><p id="43ef" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/function-construction-whats-your-function-5a282b81fc62">第1部分</a> | <a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/function-construction-part-2-f6a711075b11">第2部分</a> | <a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/javascript-function-construction-part-3-d673ff247541">第3部分</a> | <strong class="kh ir">第4部分</strong>|<strong class="kh ir">|</strong><a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/javascript-function-construction-part-5-90733a0e6369">第5部分</a> | <a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/javascript-function-construction-part-6-72cfd6b18a7c">第6部分</a> | <a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/javascript-function-construction-part-7-17c5661e6ea7">第7部分</a></p><p id="43b5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们在这里。自从我写了第一篇关于JavaScript函数构造器的博客以来，我们已经走过了很长的路。我们讨论了闭包、立即调用函数表达式、原型继承、作用域链、全局执行上下文等等。</p><p id="dac2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也看到了我们的小<code class="fe lc ld le lf b">getTime.js</code>库从受限于编写它的文件发展成为一个可导出的立即调用的函数构造器，可以导入到我们编写的任何其他普通JavaScript文件中。它还支持有限的跨平台功能和错误处理，并使用关键字来调用内置的方法。</p><p id="b3a9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是有一件事我一直没有深入研究:<strong class="kh ir">将getTime.js导入React </strong></p><p id="5e00" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">无论何时你将React放到任何堆栈上，它都会打开一个充满机会和问题的潘多拉盒子。当我第一次开始学习React时，正是因为这个原因，我讨厌React。</p><p id="57d6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我过去常说<em class="lg">‘反应糟透了。我用React能做的任何事情，用普通JavaScript都能做得更快，我非常想回到普通JavaScript。</em></p><p id="09ed" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是我大错特错了。大错特错。大错特错。</p><p id="1808" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如今，情况恰恰相反。我坚持使用React，花的时间越多，我就越喜欢它。现在，我害怕用普通的JavaScript做任何类型的DOM操作。请不要。除了那个什么都行。</p><p id="4227" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我今天想做的很简单:用从<code class="fe lc ld le lf b">getTime.js</code>调用<code class="fe lc ld le lf b">‘now’</code>方法替换默认React主页上的<em class="lg">‘编辑src/App.js并保存以重新加载’</em>。我还希望React用当前时间每秒更新文本十次。这使得它像普通时钟一样运行。但是有了互联网(算是)。</p><p id="6fc9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当然，我不可能是认真的。我是认真的，不要叫我雪莉。</p></div><div class="ab cl lh li hu lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ij ik il im in"><h2 id="0c11" class="lo lp iq bd lq lr ls dn lt lu lv dp lw ko lx ly lz ks ma mb mc kw md me mf mg bi translated">准备好做出反应</h2><p id="d792" class="pw-post-body-paragraph kf kg iq kh b ki mh jr kk kl mi ju kn ko mj kq kr ks mk ku kv kw ml ky kz la ij bi translated">此刻，<code class="fe lc ld le lf b">getTime.js</code>看起来是这样的:</p><pre class="mm mn mo mp gt mq lf mr ms aw mt bi"><span id="9fd7" class="lo lp iq lf b gy mu mv l mw mx">(function(env) {<br/>  var getTime = function(keyword){<br/>    var init = new getTime.init(keyword)<br/>    return init[keyword]<br/>  }</span><span id="173e" class="lo lp iq lf b gy my mv l mw mx">  getTime.init = function(keyword){<br/>    this[keyword] = this[keyword] ? this[keyword]() : this.error(keyword)<br/>  }</span><span id="cc8d" class="lo lp iq lf b gy my mv l mw mx">  getTime.prototype = {<br/>    date: new Date(),</span><span id="f75f" class="lo lp iq lf b gy my mv l mw mx">    now: function() {<br/>      let hours = this.date.getHours() % 12<br/>      let ampm = this.date.getHours() &lt;= 12 ? ‘AM’ : ‘PM’<br/>      let minutes = this.date.getMinutes()<br/>      let seconds = this.date.getSeconds()</span><span id="602a" class="lo lp iq lf b gy my mv l mw mx">      hours = hours ? hours : 12<br/>      minutes = minutes &lt; 10 ? ‘0’ + minutes : minutes<br/>      seconds = seconds &lt; 10 ? ‘0’+ seconds : seconds</span><span id="6f99" class="lo lp iq lf b gy my mv l mw mx">      return hours + ‘:’ + minutes + ‘:’ + seconds + ‘ ‘ + ampm<br/>    },</span><span id="fe44" class="lo lp iq lf b gy my mv l mw mx">    day: function() { return this.date.getDate() },</span><span id="3041" class="lo lp iq lf b gy my mv l mw mx">    month: function() { return (this.date.getMonth() + 1) },</span><span id="3355" class="lo lp iq lf b gy my mv l mw mx">    year: function() { return this.date.getFullYear() },</span><span id="7410" class="lo lp iq lf b gy my mv l mw mx">    fullDate: function() { return '(' + this.now() + ') ' + this.month() + '/' + this.day() + '/' + this.year() },</span><span id="e44a" class="lo lp iq lf b gy my mv l mw mx">    error: function(keyword) {<br/>      if (keyword === ‘’ || keyword === null || keyword === undefined) {<br/>        return ‘Please enter a keyword’<br/>      } else {<br/>        return `${keyword} is an invalid keyword`<br/>      }<br/>    }<br/>  }</span><span id="0cf0" class="lo lp iq lf b gy my mv l mw mx">  getTime.init.prototype = getTime.prototype</span><span id="509a" class="lo lp iq lf b gy my mv l mw mx">  env.getTime = getTime</span><span id="38bf" class="lo lp iq lf b gy my mv l mw mx">})(typeof window === “undefined” ? global : window)</span></pre><p id="a27f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们不再像以前那样需要<code class="fe lc ld le lf b">main.js</code>。<code class="fe lc ld le lf b">App.js</code>现在将处理<code class="fe lc ld le lf b">main.js</code>以前做的一切。</p><p id="b266" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我将使用<code class="fe lc ld le lf b">npm create-react-app example1</code>创建最基本的React应用程序，并希望一切设置正确。如果是这样的话，我们应该能够在浏览器中访问<code class="fe lc ld le lf b">localhost:3000</code>,并在一切完成后看到默认的react主页:</p><figure class="mm mn mo mp gt na gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi mz"><img src="../Images/3384eabb88dd1b3629778525172b94e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yLhL80zx-7rxCZI9BVKxZg.jpeg"/></div></div></figure><p id="3d25" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">很简单。</p><p id="08fe" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们整理一下文件结构。</p><p id="3908" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我将在src目录下创建一个名为<code class="fe lc ld le lf b">‘utility’</code>的新文件夹，并将我们当前版本的<code class="fe lc ld le lf b">getTime.js</code>移入其中。一旦<code class="fe lc ld le lf b">create-react-app</code>完成，我们的文件结构应该如下所示:</p><figure class="mm mn mo mp gt na gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/3bb12f37689b202c57a65d9163174b3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:304/format:webp/1*kqRzaVDEjBw9iCoOMniecA.jpeg"/></div></figure><p id="2dda" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将来构建的任何函数构造器都可以放入<code class="fe lc ld le lf b">./utility</code>中，这样一切都保持有序。</p><p id="b8e3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，让我们重构<code class="fe lc ld le lf b">getTime.js</code>，以便我们可以将其导出到<code class="fe lc ld le lf b">App.js</code>。</p><p id="8331" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们所要做的就是添加一行代码:<code class="fe lc ld le lf b">module.exports = getTime</code></p><p id="261a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">是的，就是这么简单。</p><p id="f8ed" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这允许我们使用<code class="fe lc ld le lf b">App.js</code>中的import关键字，并像我们通常导入到React中的任何其他文件、库或包一样访问它。</p><p id="d781" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我喜欢把它加在底部，我们也把<code class="fe lc ld le lf b">getTime.js</code>附加到全局执行上下文，但是老实说，你把它放在哪里并不重要。</p><p id="27a2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">老实说，我们可能不需要将它附加到全局执行上下文中，因为React可能会处理它，但是我没有测试过它，所以我真的不知道。</p><p id="9fbc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在getTime.js中:</p><pre class="mm mn mo mp gt mq lf mr ms aw mt bi"><span id="fda8" class="lo lp iq lf b gy mu mv l mw mx">getTime.init.prototype = getTime.prototype</span><span id="341b" class="lo lp iq lf b gy my mv l mw mx">env.getTime = getTime</span><span id="bd99" class="lo lp iq lf b gy my mv l mw mx">module.exports = getTime</span></pre><p id="e4cd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里有一张<code class="fe lc ld le lf b">getTime.js</code>的图片，用于超清澄清:</p><figure class="mm mn mo mp gt na gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/6095b00e4b74085bfa8607801cda3b71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1352/format:webp/1*B_LuvUeeHgWpceWnTmlgvQ.jpeg"/></div></figure><p id="5712" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">完成后，我将把注意力转向<code class="fe lc ld le lf b">App.js</code>并稍微清理一下。</p><p id="5f0a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我将移除底部的<em class="lg">‘Learn React’</em>链接，并将<code class="fe lc ld le lf b">App.js</code>变成一个类组件。我计划使用状态来更新时钟，以及使用生命周期方法<code class="fe lc ld le lf b">componentDidMount()</code>和<code class="fe lc ld le lf b">componentWillUnmount()</code>。</p><p id="fa35" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在App.js中:</p><pre class="mm mn mo mp gt mq lf mr ms aw mt bi"><span id="6d3d" class="lo lp iq lf b gy mu mv l mw mx">import React from ‘react’</span><span id="8745" class="lo lp iq lf b gy my mv l mw mx">import ‘./App.css’</span><span id="df3e" class="lo lp iq lf b gy my mv l mw mx">import logo from ‘./logo.svg’</span><span id="c9b6" class="lo lp iq lf b gy my mv l mw mx">class App extends React.Component {</span><span id="7ae5" class="lo lp iq lf b gy my mv l mw mx">  state = {}</span><span id="d97e" class="lo lp iq lf b gy my mv l mw mx">  componentDidMount() {</span><span id="378b" class="lo lp iq lf b gy my mv l mw mx">  }</span><span id="1dc0" class="lo lp iq lf b gy my mv l mw mx">  componentWillUnmount() {</span><span id="305b" class="lo lp iq lf b gy my mv l mw mx">  }</span><span id="f8c8" class="lo lp iq lf b gy my mv l mw mx">  render(){<br/>    return (<br/>      &lt;div className=”App”&gt;<br/>        &lt;header className=”App-header”&gt;<br/>          &lt;img src={logo} className=”App-logo” alt=”logo” /&gt;<br/>          &lt;p&gt;<br/>            Edit &lt;code&gt;src/App.js&lt;/code&gt; and save to reload.<br/>         &lt;/p&gt;<br/>        &lt;/header&gt;<br/>      &lt;/div&gt;<br/>    )<br/>  }<br/>}</span><span id="8a8b" class="lo lp iq lf b gy my mv l mw mx">export default App</span></pre><p id="84ff" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，除了删除<em class="lg">‘Learn React’</em>链接之外，我们应该不会在浏览器的<code class="fe lc ld le lf b">localhost:3000</code>处看到任何客户端面临的变化。</p><p id="b90a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们现在可以像平常一样将<code class="fe lc ld le lf b">getTime.js</code>导入到<code class="fe lc ld le lf b">App.js</code>中:</p><p id="1c32" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在App.js</p><pre class="mm mn mo mp gt mq lf mr ms aw mt bi"><span id="3056" class="lo lp iq lf b gy mu mv l mw mx">import getTime from ‘./utility/getTime’</span></pre><p id="0ba0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是如果我们保存<code class="fe lc ld le lf b">App.js</code>,我们会在终端中得到两个错误:</p><figure class="mm mn mo mp gt na gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/d97d49b8cb6af9d063bccf1229f61772.png" data-original-src="https://miro.medium.com/v2/resize:fit:824/format:webp/1*0IfNTA5BpyZEm9r15qinUg.jpeg"/></div></figure><p id="814f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二个错误是意料之中的，因为我们还没有在<code class="fe lc ld le lf b">App.js</code>的任何地方实现<code class="fe lc ld le lf b">getTime.js</code>，但是第一个错误很有趣:</p><pre class="mm mn mo mp gt mq lf mr ms aw mt bi"><span id="cbf7" class="lo lp iq lf b gy mu mv l mw mx">./src/utility/getTime.js</span><span id="713a" class="lo lp iq lf b gy my mv l mw mx">Line 39:37: Unexpected string concatenation of literals no-useless-concat</span></pre><p id="7417" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好吧，让我们看看<code class="fe lc ld le lf b">getTime.js</code>中的<code class="fe lc ld le lf b">line 39</code>:</p><figure class="mm mn mo mp gt na gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/d65475c31beb922047d5fb0670ba33df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1132/format:webp/1*jgoMgj-a-PvHOWK-uusWrw.jpeg"/></div></figure><p id="0515" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">似乎React对我们连接<code class="fe lc ld le lf b">fullDate()</code>返回值的方式不太满意。</p><p id="1f1c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这没什么大不了的，但是修复React可能抛出的哪怕是最小的错误总是一个好主意。对于这样的小事，React可能相当善变，它提出的大多数小问题可能与应用程序的实际功能没有任何关系。</p><p id="7a71" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，嘿，你可能会学到新的东西，这总是好的。</p><p id="5453" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不管怎样，我都会猜测<code class="fe lc ld le lf b">‘useless-concat‘</code>错误是指我们在<code class="fe lc ld le lf b">this.now() + ‘)’</code>和<code class="fe lc ld le lf b">this.month()</code>之间添加的空白字符串。这是我能想到的唯一可能被考虑的事情</p><p id="dec0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，让我们删除它，并在带括号的字符串中添加一个空格:</p><p id="c416" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在getTime.prototype.fullDate()中:</p><pre class="mm mn mo mp gt mq lf mr ms aw mt bi"><span id="8d08" class="lo lp iq lf b gy mu mv l mw mx">return ‘(‘ + this.now() + ‘) ‘ + this.month() + ‘/’ + this.day() + ‘/’ + this.year()</span></pre><p id="0a10" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们保存并重新加载:</p><figure class="mm mn mo mp gt na gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/458b38f8edafc6376b799a3f3acab287.png" data-original-src="https://miro.medium.com/v2/resize:fit:704/format:webp/1*fo5BuGuTrgj0hfCBxBcAkQ.jpeg"/></div></figure><p id="3376" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">太好了。</p><p id="c146" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个问题解决后，让我们尝试一下我们的<code class="fe lc ld le lf b">console.log()</code>方法，看看事情是否正常工作。</p><p id="287d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们将<code class="fe lc ld le lf b">console.log(getTime('now'))</code>添加到<code class="fe lc ld le lf b">componentDidMount()</code>，这样我们在页面加载时只调用<code class="fe lc ld le lf b">getTime('now')</code>一次。</p><p id="6ed1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在App.js中:</p><pre class="mm mn mo mp gt mq lf mr ms aw mt bi"><span id="4fa6" class="lo lp iq lf b gy mu mv l mw mx">componentDidMount() { console.log(getTime(‘now’)) }</span></pre><p id="4973" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们保存<code class="fe lc ld le lf b">App.js</code>，并等待React在浏览器中编译并热加载页面，<code class="fe lc ld le lf b">componentDidMount()</code>应该<code class="fe lc ld le lf b">console.log()</code>调用我们在<code class="fe lc ld le lf b">getTime.prototype</code>中的<code class="fe lc ld le lf b">‘now’</code>方法，并在控制台中显示当前时间:</p><figure class="mm mn mo mp gt na gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi nm"><img src="../Images/69f0c3609d59d3e5059e85fefbaa2bef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BRfRvEvkdrIVykvFhaLKrA.jpeg"/></div></div></figure><p id="2d51" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">太棒了。</p><p id="0a7d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，让我们尝试使用<code class="fe lc ld le lf b">getTime(‘now’)</code>将<em class="lg">‘编辑src/App.js并保存以重新加载’</em>文本替换为当前时间，并使其每秒更新十次。</p></div><div class="ab cl lh li hu lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ij ik il im in"><h2 id="7750" class="lo lp iq bd lq lr ls dn lt lu lv dp lw ko lx ly lz ks ma mb mc kw md me mf mg bi translated">反应时间</h2><p id="edd6" class="pw-post-body-paragraph kf kg iq kh b ki mh jr kk kl mi ju kn ko mj kq kr ks mk ku kv kw ml ky kz la ij bi translated">有两种方法可以解决这个问题。实际上有三种方式。</p><p id="5845" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第一种是使用生命周期法<code class="fe lc ld le lf b">componentDidUpdate()</code>。该方法将使用<code class="fe lc ld le lf b">getTime('now')</code>更新<code class="fe lc ld le lf b">this.state</code>中的属性。</p><p id="1e05" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样做的问题是，我们需要通过在生命周期方法中设置条件评估来操纵组件的状态，否则我们将从<code class="fe lc ld le lf b">componentDidUpdate()</code>内部创建一个调用函数执行的无限循环。</p><p id="4892" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当您在<code class="fe lc ld le lf b">componentDidUpdate()</code>中调用一个函数时，您必须确保您是在满足一个条件状态后调用该函数。比如一个布尔值被设置为真或假。</p><p id="45be" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在执行函数调用后，我们还需要为另一个条件求值设置状态。React每毫秒重新渲染DOM大约9001次(不是真的，但是真的很快)，每次重新渲染都执行<code class="fe lc ld le lf b">componentDidUpdate()</code>。在这种情况下，如果我们在<code class="fe lc ld le lf b">componentDidUpdate()</code>内无限制地调用函数执行，我们会创建一个无限循环，并很快超过最大调用堆栈。</p><p id="9c75" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">幸运的是，一旦达到最大调用堆栈，React将抛出运行时错误，并在我们的计算机爆炸之前停止整个应用程序。</p><p id="4b1c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">记住，无论何时你在<code class="fe lc ld le lf b">componentDidUpdate()</code>中调用一个函数，你必须确保你是在满足一个条件状态后调用该函数，并且在满足另一个条件状态后停止该函数的执行。</p><p id="ca1c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">迷惑？是的，可能是。因此，我们不要为所有这些烦心，看看另一个解决方案。</p><p id="ae96" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以用钩子。对于像更新网页上的字符串这样的小事来说，钩子会很有用。我们应该用钩子。但是，由于钩子在React世界中是一个相对较新的概念，您可能不熟悉(这也是我仍在努力掌握的东西)，所以我们暂时不讨论钩子。另外，我已经为这个博客准备了所有的例子，我们已经把<code class="fe lc ld le lf b">App.js</code>变成了一个类组件，我已经把所有的屏幕截图都打出来了。</p><p id="ae78" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以，如果我承认有点懒，钩子不是我们要用的选项，我们实际上要做什么呢？</p><p id="33ac" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好吧，如果你更熟悉React中的生命周期方法，并注意到当我将它转换成一个类组件时向<code class="fe lc ld le lf b"> App.js</code>添加了<code class="fe lc ld le lf b">componentWillUnmount()</code>，你可能已经猜到我的解决方案是什么了。</p><p id="45c5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我将使用<code class="fe lc ld le lf b">setInterval()</code>创建一个计时器，它每秒钟调用<code class="fe lc ld le lf b">getTime(‘now‘)</code>十次，并更新一个名为<code class="fe lc ld le lf b">time</code>的状态属性。这样，我们就可以将render方法中的<em class="lg">‘Edit src/app . js and save to reload’</em>文本替换为<code class="fe lc ld le lf b">{this.state.time}</code>，一切应该都可以了。我们应该做的另一件事，但不是必须做的，是将<code class="fe lc ld le lf b">clearInterval()</code>添加到<code class="fe lc ld le lf b">componentWillUnmount()</code>中，以确保一旦组件不再被渲染，我们就取消对计时器的订阅。</p><p id="4941" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而我们需要做的就是增加2行代码，替换1行代码，修改1行代码。</p><p id="cd5b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我知道所有事情的设置和解释都远比实际实现<code class="fe lc ld le lf b">getTime.js</code> into React要长，但是这些解释是值得理解的。</p><p id="9f08" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我要做的第一件事是向state添加一个时间属性，并将其设置为一个空字符串:</p><p id="c414" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在App.js中:</p><pre class="mm mn mo mp gt mq lf mr ms aw mt bi"><span id="5d49" class="lo lp iq lf b gy mu mv l mw mx">state = { time: '' }</span></pre><p id="9900" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就是我们将要在DOM上更新和渲染的内容。</p><p id="d1cb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我将为<code class="fe lc ld le lf b">componentDidMount()</code>添加一个计时器:</p><p id="113c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在App.js中:</p><pre class="mm mn mo mp gt mq lf mr ms aw mt bi"><span id="bc39" class="lo lp iq lf b gy mu mv l mw mx">componentDidMount() { this.timeInterval = setInterval(this.timeFunctions, 100) }</span></pre><p id="0a55" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们正在创建一个变量，并将其绑定到<code class="fe lc ld le lf b">App.js</code>组件。我们希望从<code class="fe lc ld le lf b">App.js</code>中的其他方法访问它，更具体地说，能够停止<code class="fe lc ld le lf b">componentWillUnmount()</code>中的计时器。</p><p id="2df2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该变量是对JavaScript内置的<code class="fe lc ld le lf b">setInterval()</code>方法的调用，该方法接受两个参数。第一个是我们即将定义的函数，第二个是我们希望第一个参数执行的速度(以毫秒为单位)。100毫秒等于0.1秒(因为事情发生的时间)。简而言之，<code class="fe lc ld le lf b">timeInterval</code>每秒将执行十次，由于<code class="fe lc ld le lf b">this.timeInterval</code>的定义是对<code class="fe lc ld le lf b">setInterval</code>的调用，<code class="fe lc ld le lf b">this.timeFunctions</code>也将每秒执行十次。</p><p id="3dcb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为什么一秒钟十次？因为我第一次写这个博客的时候打错了，我希望我的时钟非常准确。</p><p id="5290" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">唯一的问题是<code class="fe lc ld le lf b">timeFunctions</code>长什么样？</p><p id="737c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在App.js中:</p><pre class="mm mn mo mp gt mq lf mr ms aw mt bi"><span id="6fd9" class="lo lp iq lf b gy mu mv l mw mx">timeFunctions = () =&gt; { this.setState({ time: getTime(‘now’) })}</span></pre><p id="7221" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lc ld le lf b">timeFunctions</code>是一个ES6有界函数，设置<code class="fe lc ld le lf b">App.js</code>中时间属性的状态。它将<code class="fe lc ld le lf b">time</code>属性的状态设置为调用<code class="fe lc ld le lf b">getTime.js</code>中的<code class="fe lc ld le lf b">‘now’</code>方法的返回值。每秒钟它会这样做十次，因为我们在<code class="fe lc ld le lf b">componentDidMount()</code>中从<code class="fe lc ld le lf b">setInterval()</code>内部调用<code class="fe lc ld le lf b">timeFunctions()</code>。</p><p id="7900" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，每当从DOM中删除<code class="fe lc ld le lf b">App.js</code>时，我们想要取消对<code class="fe lc ld le lf b">this.timeInterval</code>的订阅</p><p id="5d12" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在App.js中:</p><pre class="mm mn mo mp gt mq lf mr ms aw mt bi"><span id="7cf2" class="lo lp iq lf b gy mu mv l mw mx">componentWillUnmount() {clearInterval(this.timeInterval)}</span></pre><p id="994b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了停止计时器，我们需要接近它。为了访问它，我们需要将interval设置为一个变量，并将其绑定到<code class="fe lc ld le lf b">App.js</code>。否则，该间隔将被限制在<code class="fe lc ld le lf b">componentDidMount()</code>的范围内。但是由于我们可以从<code class="fe lc ld le lf b">componentWillUnmount()</code>内部访问<code class="fe lc ld le lf b">this.timeInterval</code>，我们可以通过调用<code class="fe lc ld le lf b">clearInterval()</code>来停止计时器。</p><p id="50b9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们要做的就是在我们的<code class="fe lc ld le lf b">render(){ return () }</code>方法中用<code class="fe lc ld le lf b">{ this.state.time }</code>替换<em class="lg">‘编辑src/App.js并保存以重新加载’</em>。</p><p id="691e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在App.js中:</p><pre class="mm mn mo mp gt mq lf mr ms aw mt bi"><span id="4c22" class="lo lp iq lf b gy mu mv l mw mx">render(){<br/>  return (<br/>    &lt;div className=”App”&gt;<br/>      &lt;header className=”App-header”&gt;<br/>        &lt;img src={logo} className=”App-logo” alt=”logo” /&gt;<br/>        &lt;p&gt;<br/>          { this.state.time }<br/>        &lt;/p&gt;<br/>      &lt;/header&gt;<br/>    &lt;/div&gt;<br/>  )<br/>}</span></pre><p id="cfbc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们保存并热加载<code class="fe lc ld le lf b">localhost:3000</code>，我们应该看到当前时间正确显示在下面的页面上，每秒钟自动更新十次:</p><figure class="mm mn mo mp gt na gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi nn"><img src="../Images/b9cd52b9c8075f9bfd604532c672d6a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sitCzTFBGp3THwhiPIvAnQ.jpeg"/></div></div></figure><p id="b863" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">…而且没有更新。</p><p id="a501" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> **** </strong>。</p><p id="0bd8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">嗯，至少它取代了文本，并正确显示当前时间。</p><p id="c074" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以解决这个问题。我们有技术。</p><p id="ef06" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，让我们用<code class="fe lc ld le lf b">render()</code>方法中的<code class="fe lc ld le lf b">console.log(getTime(‘now‘))</code>来试着诊断问题。我们需要找出这是React中的问题，还是<code class="fe lc ld le lf b">getTime.js</code>中的问题:</p><figure class="mm mn mo mp gt na gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi no"><img src="../Images/eefda30930f649db29bf4c277260ac13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fSOKDUIwAiOaD7gGAV49GA.jpeg"/></div></div></figure><p id="5a28" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">喔，好的。</p><p id="cc0f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以React确实在正确地更新DOM。但是它所做的只是滥发<code class="fe lc ld le lf b">this.state.time</code>的初始值。问题一定存在于<code class="fe lc ld le lf b">getTime.js</code>中，因为React没有接收到更新的时间值，并且/或者React在页面加载中第一次调用<code class="fe lc ld le lf b">getTime</code>时接收到当前时间，然后一次又一次地用相同的值更新<code class="fe lc ld le lf b">this.state.time</code>。</p><p id="da51" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这让我预感到问题出在哪里。我们在prototype方法中存储了JavaScript内置<code class="fe lc ld le lf b">new Date()</code>函数的调用。原型方法仅在创建<code class="fe lc ld le lf b">getTime</code>对象时被引用。</p><p id="af4a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以，如果我们从原型方法中调用<code class="fe lc ld le lf b">this.date</code>，它每次都会返回相同的值，因为我们是通过引用来访问它的。原型对象不会在每次调用时更新，但是<code class="fe lc ld le lf b">init()</code>函数会更新。<code class="fe lc ld le lf b">init()</code>功能是我们暴露出来做出反应的东西，也是我们做所有工作的地方。</p><p id="7fce" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以让我们将日期属性从原型对象移回<code class="fe lc ld le lf b">getTime.init()</code>。</p><p id="7ae3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果这就是问题所在，我会觉得自己很傻。在上一篇博客中，我最初将<code class="fe lc ld le lf b">this.date</code>保留在<code class="fe lc ld le lf b">getTime.init()</code>中，只将其移动到博客末尾的prototype对象中。现在我又把它移回来了。</p><p id="f919" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在getTime.js中:</p><pre class="mm mn mo mp gt mq lf mr ms aw mt bi"><span id="9d5f" class="lo lp iq lf b gy mu mv l mw mx">getTime.init = function(keyword){<br/>  this.date = new Date()</span><span id="f962" class="lo lp iq lf b gy my mv l mw mx">  this[keyword] = this[keyword] ? this[keyword]() : this.error(keyword)</span><span id="b52d" class="lo lp iq lf b gy my mv l mw mx">}</span></pre><p id="b993" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们检查浏览器:</p><figure class="mm mn mo mp gt na gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi np"><img src="../Images/a48ee68a0c1d622230077917e689b2e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*sCRylJIeO9LQ4mZP51jUbQ.gif"/></div></div></figure><p id="689c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当然了。言语无法表达我所感受到的讽刺。</p><p id="1285" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">没关系，耶！有用！</p><p id="5898" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">精益求精！</p><p id="63c2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们最后看一下<code class="fe lc ld le lf b">getTime.js</code>和<code class="fe lc ld le lf b">App.js</code>，称这篇博客为任务完成。</p><p id="5246" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在getTime.js中:</p><pre class="mm mn mo mp gt mq lf mr ms aw mt bi"><span id="d904" class="lo lp iq lf b gy mu mv l mw mx">(function(env) {<br/>  var getTime = function(keyword){<br/>    var init = new getTime.init(keyword)<br/>    return init[keyword]<br/>  }</span><span id="93b3" class="lo lp iq lf b gy my mv l mw mx">  getTime.init = function(keyword){<br/>    this.date = new Date()<br/>    this[keyword] = this[keyword] ? this[keyword]() : this.error(keyword)<br/>  }</span><span id="d548" class="lo lp iq lf b gy my mv l mw mx">  getTime.prototype = {<br/>    now: function() {<br/>      let hours = this.date.getHours() % 12<br/>      let ampm = this.date.getHours() &lt;= 12 ? ‘AM’ : ‘PM’<br/>      let minutes = this.date.getMinutes()<br/>      let seconds = this.date.getSeconds()</span><span id="fbe4" class="lo lp iq lf b gy my mv l mw mx">      hours = hours ? hours : 12<br/>      minutes = minutes &lt; 10 ? ‘0’ + minutes : minutes<br/>      seconds = seconds &lt; 10 ? ‘0’+ seconds : seconds</span><span id="4974" class="lo lp iq lf b gy my mv l mw mx">      return hours + ‘:’ + minutes + ‘:’ + seconds + ‘ ‘ + ampm<br/>    },</span><span id="bd6a" class="lo lp iq lf b gy my mv l mw mx">    day: function() { return this.date.getDate() },</span><span id="8de3" class="lo lp iq lf b gy my mv l mw mx">    month: function() { return (this.date.getMonth() + 1) },</span><span id="c4c2" class="lo lp iq lf b gy my mv l mw mx">    year: function() { return this.date.getFullYear() },</span><span id="67ee" class="lo lp iq lf b gy my mv l mw mx">    fullDate: function() { return ‘(‘ + this.now() + ‘) ‘ + this.month() + ‘/’ + this.day() + ‘/’ + this.year() },</span><span id="456f" class="lo lp iq lf b gy my mv l mw mx">    error: function(keyword) {<br/>      if (keyword === ‘’ || keyword === null || keyword === undefined) {<br/>        return ‘Please enter a keyword’<br/>      } else {<br/>        return `${keyword} is an invalid keyword`<br/>      }<br/>    }<br/>  }</span><span id="f755" class="lo lp iq lf b gy my mv l mw mx">  getTime.init.prototype = getTime.prototype</span><span id="0f51" class="lo lp iq lf b gy my mv l mw mx">  env.getTime = getTime</span><span id="6d85" class="lo lp iq lf b gy my mv l mw mx">  module.exports = getTime</span><span id="8b77" class="lo lp iq lf b gy my mv l mw mx">})(typeof window === “undefined” ? global : window)</span></pre><p id="7f92" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在App.js中:</p><pre class="mm mn mo mp gt mq lf mr ms aw mt bi"><span id="444b" class="lo lp iq lf b gy mu mv l mw mx">import React from ‘react’<br/>import ‘./App.css’<br/>import logo from ‘./logo.svg’<br/>import getTime from ‘./utility/getTime’</span><span id="9bc2" class="lo lp iq lf b gy my mv l mw mx">class App extends React.Component {</span><span id="cd6f" class="lo lp iq lf b gy my mv l mw mx">  state = { time: ‘’ }</span><span id="ae91" class="lo lp iq lf b gy my mv l mw mx">  componentDidMount() { this.timeInterval = setInterval(this.timeFunctions, 100) }</span><span id="21ed" class="lo lp iq lf b gy my mv l mw mx">  timeFunctions = () =&gt; { this.setState({ time: getTime(‘now’) }) }</span><span id="4a08" class="lo lp iq lf b gy my mv l mw mx">  componentWillUnmount() { clearInterval(this.timeInterval) }</span><span id="a8ee" class="lo lp iq lf b gy my mv l mw mx">  render(){<br/>    return (<br/>      &lt;div className=”App”&gt;<br/>        &lt;header className=”App-header”&gt;<br/>          &lt;img src={logo} className=”App-logo” alt=”logo” /&gt;<br/>          &lt;p&gt;<br/>            { this.state.time }<br/>          &lt;/p&gt;<br/>        &lt;/header&gt;<br/>      &lt;/div&gt;<br/>    )<br/>  }<br/>}</span><span id="c6f2" class="lo lp iq lf b gy my mv l mw mx">export default App</span></pre><p id="7cf8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">耶切。</p></div><div class="ab cl lh li hu lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ij ik il im in"><h2 id="b957" class="lo lp iq bd lq lr ls dn lt lu lv dp lw ko lx ly lz ks ma mb mc kw md me mf mg bi translated">任务完成</h2><p id="1a44" class="pw-post-body-paragraph kf kg iq kh b ki mh jr kk kl mi ju kn ko mj kq kr ks mk ku kv kw ml ky kz la ij bi translated">我想重点关注的是<code class="fe lc ld le lf b">App.js</code>中的这一行代码:</p><pre class="mm mn mo mp gt mq lf mr ms aw mt bi"><span id="4eb8" class="lo lp iq lf b gy mu mv l mw mx">timeFunctions = () =&gt; { this.setState({ time: getTime(‘now’) }) }</span></pre><p id="2c49" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这一行代码就是我在过去的4篇博客中花费的所有时间、精力和精力。</p><p id="8a40" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所有的抽象。所有的重构。所有的一切。这一切都包含在那一行代码中。</p><p id="399c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是一个很好的例子，说明JavaScript和React中的函数构造函数是多么强大。能够抽象出如此多的代码，同时能够一次又一次地重用同样的抽象，这给我带来了极大的快乐。</p><p id="4f15" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就像圣诞节，但是有代码。</p><p id="2927" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">无论哪种方式，我都计划将fetch请求与React中的函数构造函数结合起来，并使用与<code class="fe lc ld le lf b">getTime.js</code>抽象基本CRUD操作相同的框架。</p><p id="1e8c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，这个星期对我来说是忙碌的一周。我没有像前三篇那样多的时间来写这篇博客。另外，这个博客比我预期的要长得多，在React中用函数构造器专门写一个单独的博客来获取请求和CRUD操作听起来是个更好的主意。</p><p id="aafb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">再次感谢您的阅读，我希望这个博客更多的是信息性的，而不是迷惑性的(那不是一个词，但你明白了)。</p><p id="7671" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">保持安全，保持健康。</p></div><div class="ab cl lh li hu lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ij ik il im in"><h1 id="ea33" class="nq lp iq bd lq nr ns nt lt nu nv nw lw jw nx jx lz jz ny ka mc kc nz kd mf oa bi translated">JavaScript函数构造</h1><p id="f193" class="pw-post-body-paragraph kf kg iq kh b ki mh jr kk kl mi ju kn ko mj kq kr ks mk ku kv kw ml ky kz la ij bi translated"><a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/function-construction-whats-your-function-5a282b81fc62">第1部分</a> | <a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/function-construction-part-2-f6a711075b11">第2部分</a> | <a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/javascript-function-construction-part-3-d673ff247541">第3部分</a> | <strong class="kh ir">第4部分</strong>|<strong class="kh ir">|</strong><a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/javascript-function-construction-part-5-90733a0e6369">第5部分</a> | <a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/javascript-function-construction-part-6-72cfd6b18a7c">第6部分</a> | <a class="ae lb" rel="noopener ugc nofollow" target="_blank" href="/javascript-function-construction-part-7-17c5661e6ea7">第7部分</a></p></div></div>    
</body>
</html>