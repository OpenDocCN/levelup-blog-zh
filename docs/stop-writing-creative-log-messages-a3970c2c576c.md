# 停止写创造性的日志消息

> 原文：<https://levelup.gitconnected.com/stop-writing-creative-log-messages-a3970c2c576c>

## 把散文留给你的诗歌吧

![](img/ff67c66e852aa41a17377641ce749e82.png)

由[马尔科·霍尔瓦特](https://unsplash.com/@lemondyt?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 拍摄的照片

如果你作为一名软件工程师工作了足够长的时间，你就会看到它们。那些“有趣”的日志消息散布在你公司的代码库中。某个人写的一句话，他想表明自己既是工程师又是幽默大师。类似于:

```
log.error(
  "Couldn’t find the server. Guess it went on vacation!!! :)" );
```

也许你第一次在代码中看到它时会暗自发笑。但是请放心，当你在处理生产中断时，不会有咯咯的笑声，并且*是你希望快速解决的数据。*

*在这一点上，找到写下这条信息的工程师的冲动——并把他们吹到他们自鸣得意、想成为喜剧演员的脸上——可能会很强烈。但是说实话:我们都写过这样的日志消息。那些——如果不那么“有趣”——也同样令人沮丧地无用。毫无疑问，如果面对在产品中看到一些我们自己的信息，我们会希望我们能回到过去重写它们。*

*那么，为什么*我们继续对我们的日志信息如此油嘴滑舌？**

*我认为这仅仅是因为我们专注于解决我们自己眼前的需求。相反，我们应该解决未来工程师的*需求(他可能就是我们！)谁将消耗我们的日志。**

# *解决我们的迫切需求*

*我们倾向于将写日志视为一种必要的罪恶。当我们写代码的时候，我们会遇到一个点，在这个点上我们感到有压力去告诉别人一些事情已经发生了。通常这一点是通过捕获异常来提示的。例如，想象编写如下代码:*

```
*var connection = getConnection();
try {
  var personResponse = connection.get("/persons/" + id);
  var b = validate(personResponse);
  return (b) ? personResponse : null;
} catch (IOException e) {
  //TODO do something
}*
```

*作为有经验的工程师，我们天生知道我们不能把第七行作为`TODO`注释。我们需要以某种方式处理它。*

*所以我们写了一条日志消息。但是说实话。编写日志消息感觉像是对我们“真正的”编程工作的干扰。我们想尽快进入和离开。所以，我们很快打出一条信息:*

```
*} catch (IOException e) {
  log.error("Error taking to the server", e);
}*
```

*知道我们已经满足了最低的错误处理标准，我们回到了“真正的”编程。因此，我们已经解决了第一个迫切的需求:*

> ****迅速排除错误****

*此外，我们可能会把这个机会作为编写所有这些代码的一个小小的休息。撰写工程师可消费的信息是展示我们创造力的机会。所以我们可能会写一些像我们在本文开头看到的东西:*

```
*} catch (IOException e) {
  log.error("Couldn't find the server. Guess it went on vacation!!! :)");
}*
```

*这样，我们就解决了第二个迫切的需求:*

> ****寻找表达创造力的出口****

*问题是，日志记录并不是为了达到这两个目的。相反，它存在的理由是为解决我们的代码部署后出现的问题的人服务。那么，我们如何写日志来达到的目的呢？*

# *只是事实，伙计*

*首先，我们需要停止交谈。这不是巧妙评论或完整句子的地方。相反，我们应该专注于为未来的工程师提供他们排除故障所需的信息。*

*我发现最有效的方法是从两方面考虑:*

*   *键/值对*
*   *可搜索术语*

*让我们来看看每一个。*

## *键/值对*

*如前所述，我们经常想把日志消息写成散文。这自然会导致有用信息的减少。相反，我们应该将日志消息写成一系列的*键/值对*。例如:*

```
*log.error("action=get-person event=server-failure person-id={id} connection-status={connection.status}")*
```

*为什么是键/值字段？我发现用这种方式写信息有一些好处。从心理上来说，它迫使我们停下来考虑日志信息中可能有用的所有信息。它还会生成一条日志消息，以易于使用的方式显示信息。此外，一些日志聚合器如 [Splunk](https://docs.splunk.com/Documentation/Splunk/8.2.0/Knowledge/Automatickey-valuefieldextractionsatsearch-time) 可以配置为自动提取和索引键/值对。这引出了我们的第二个关注点:*

## *可搜索术语*

*通常在诊断生产问题时，我们需要在日志中搜索信息。如果我们像本文开头的例子那样编写了散文式的消息，那么我们的搜索将会是这样的:*

```
*index=my.service "Guess it went on vacation!!!"*
```

*这个搜索可能——意外地——唯一地识别出一个特定的日志输出(也就是说，除非我们在其他日志消息中使用过相同的插科打诨。)在其他情况下，我们可能就没这么幸运了。如果我们养成了这样的习惯:*

```
*} catch (IOException e) {
  log.error("Error taking to the server", e);
}*
```

*那么搜索`"Error taking to the server"`可能有点太不具体了。*

*相反，我们希望确保每个日志消息都允许我们唯一地查询它。幸运的是，如果我们将消息写成一系列的键/值对，这几乎是免费的。为了隔离前面的例子，我们的搜索可能如下所示:*

```
*index=my.service "action=get-person" "event=server-failure"*
```

**(有或没有引号，取决于我们的字段是否由我们的日志聚合器自动提取)**

*注意，我同时使用了`*action*`和`*event*`进行搜索。这指向了日志记录的另一个最佳实践:*

> ***提供一个搜索词，将相关日志联系在一起。***

*通常，在解决问题时，我们需要搜索多个日志消息。大多数工程师都知道[关联 id](https://www.oreilly.com/library/view/building-microservices-with/9781785887833/1bebcf55-05bb-44a1-a4e5-f9733b8edfe3.xhtml)的概念，它允许我们对属于单个*请求*的日志消息进行分组。以类似的方式，我们可以用一个公共的键/值对来标记属于单个*流*的日志消息，这样我们就可以轻松地查询属于那个特定流的所有日志消息。*

*在我们的例子中，我们将在与我们的 *get-person* 调用相关的所有日志消息中包含`action=get-person`。这样，搜索该术语将显示与该请求的初始化相关的所有日志，以及所有成功和失败的日志。然后，通过提供`event`键/值对，我们可以将搜索范围缩小到特定的事件。*

## *关于安全性的简短说明*

*值得停下来讨论日志记录的安全含义。这里概述的方法鼓励我们在日志消息中提供任何可能有用的数据。然而，我们需要确定我们没有在日志中记录任何敏感信息，比如 PII。*

*理想情况下，您的组织有一个安全团队，可以指导您记录什么是可接受的，什么是不可接受的。如果没有，你需要意识到这一点，并在为你的工程组织的其余部分开发标准时采取主动。*

# *尾端*

*写日志消息可能不是火箭科学。但也不应该是诗歌。相反，我们应该停下来，对我们写的信息进行一些思考。此外，我们应该遵循本文中提出的指导原则:*

*   *将日志消息写成一系列的键/值对，而不是散文*
*   *确保我们的信息易于查询*
*   *确保我们包含一个键/值对，允许我们关联与单个操作相关的消息*

*我发现这样做会将写日志消息从一项艰苦的工作变成一项有趣的、有益的挑战。但更重要的是，它会让那些需要消耗我们的日志的穷人、未来的工程师的生活不那么沮丧。记住，未来的工程师可能就是我们！*

*觉得这个故事有用？想多读点？只需[在这里订阅](https://dt-23597.medium.com/subscribe)就可以将我的最新故事直接发送到你的收件箱。*

*你也可以支持我和我的写作——并获得无限数量的故事——通过今天[成为媒体会员](https://dt-23597.medium.com/membership)。*