<html>
<head>
<title>Understand tuple() with Python Example</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python例子理解tuple()</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/understand-tuple-with-python-example-56d2e7259718?source=collection_archive---------15-----------------------#2021-07-05">https://levelup.gitconnected.com/understand-tuple-with-python-example-56d2e7259718?source=collection_archive---------15-----------------------#2021-07-05</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="8045" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">python中数据结构的便捷概念</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/440a7460fec48d054b7875a7c3f5fb17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PfhUjOhYpfI7rrx8"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">由<a class="ae ky" href="https://unsplash.com/@pakata?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Pakata Goh </a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="d3ce" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">元组是表示为()的python对象的集合，元组中的元素用逗号分隔。元组类似于嵌套对象和索引等主题中的列表。但是与列表相比，元组是不可变的。</p><blockquote class="lv lw lx"><p id="194a" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated"><strong class="lb iu"> <em class="it">创建元组</em> </strong></p></blockquote><p id="57e7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">创建一个元组与创建一个列表非常相似，只是略有不同。让我们看看如何创建元组的不同方法:</p><p id="d23b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">注意:</strong>一个元组也可以不用括号写。</p><ol class=""><li id="f8d9" class="mc md it lb b lc ld lf lg li me lm mf lq mg lu mh mi mj mk bi translated"><strong class="lb iu">创建空元组</strong></li></ol><pre class="kj kk kl km gt ml mm mn mo aw mp bi"><span id="947b" class="mq mr it mm b gy ms mt l mu mv">tup1 = ()</span><span id="f449" class="mq mr it mm b gy mw mt l mu mv">print(tup1)</span><span id="6dd1" class="mq mr it mm b gy mw mt l mu mv"><strong class="mm iu">Output:<br/></strong>()</span></pre><p id="ac5f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> 2。混合数据类型的元组</strong></p><pre class="kj kk kl km gt ml mm mn mo aw mp bi"><span id="e2ed" class="mq mr it mm b gy ms mt l mu mv">tup2 = (1, “python”, 26.4)</span><span id="ef85" class="mq mr it mm b gy mw mt l mu mv">print(tup2)</span><span id="e88d" class="mq mr it mm b gy mw mt l mu mv"><strong class="mm iu">Output:<br/></strong>(1, “python”, 26.4)</span></pre><p id="8b48" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> 3。嵌套元组</strong></p><pre class="kj kk kl km gt ml mm mn mo aw mp bi"><span id="3a48" class="mq mr it mm b gy ms mt l mu mv">tup3 = (“python”, (34, 35), [4, 7])</span><span id="6b1d" class="mq mr it mm b gy mw mt l mu mv">print(tup3)</span><span id="b763" class="mq mr it mm b gy mw mt l mu mv"><strong class="mm iu">Output:<br/></strong>(“python”, (34, 35), [4, 7])</span></pre><p id="c43e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">说明:</strong>以上执行的程序以不同的方式说明了元组的创建。这里，每个创建的元组都在类似“tup1”、“tup2”和“tup3”的变量中。</p><blockquote class="lv lw lx"><p id="ed4a" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated"><strong class="lb iu"> <em class="it">访问元组</em> </strong></p></blockquote><p id="c0dc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">既然我们已经创建了元组，接下来的需求就是访问它们。有三种访问方式:正索引、负索引和切片。让我们通过一个示例来详细了解这些方法:</p><ol class=""><li id="d7eb" class="mc md it lb b lc ld lf lg li me lm mf lq mg lu mh mi mj mk bi translated"><strong class="lb iu">正向分度</strong></li></ol><p id="f537" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">程序:</strong></p><pre class="kj kk kl km gt ml mm mn mo aw mp bi"><span id="c9c5" class="mq mr it mm b gy ms mt l mu mv">tup = (‘p’, ‘y’, ‘t’, ‘h’, ‘o’, ’n’, (4, 5, 6), [56, 47])<br/>        ↑    ↑    ↑    ↑    ↑    ↑       ↑          ↑<br/>        0    1    2    3    4    5       6          7</span><span id="e509" class="mq mr it mm b gy mw mt l mu mv">print(tup[4])<br/>print(tup[6][1])<br/>print(tup[7][0])</span><span id="3e11" class="mq mr it mm b gy mw mt l mu mv"><strong class="mm iu">Output:<br/></strong>o<br/>5<br/>56</span></pre><p id="1f19" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">解释:</strong></p><p id="f350" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在正索引中，从左到右访问元组，其中第一个元素的索引总是从“0”开始。让我们了解一下打印语句是如何访问它们的:</p><ul class=""><li id="40c2" class="mc md it lb b lc ld lf lg li me lm mf lq mg lu mx mi mj mk bi translated">在第一个print语句中，它声明访问索引值为4的元素。因此我们得到输出为“0”。</li><li id="e91e" class="mc md it lb b lc my lf mz li na lm nb lq nc lu mx mi mj mk bi translated">在第二个print语句中，它声明访问索引值为“6”的元素。我们可以看到在元组中有一个元组。因此，为了打印索引值为“6”的元组的元素，我们将它的位置设为1。因此，它将输出返回为“5”。该过程也适用于第三张打印报表。</li></ul><p id="cc80" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> 2。负分度</strong></p><p id="1e17" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">程序:</strong></p><pre class="kj kk kl km gt ml mm mn mo aw mp bi"><span id="fefc" class="mq mr it mm b gy ms mt l mu mv">tup = (‘p’, ‘e’, ‘t’, ‘i’, ‘o’, ‘u’)<br/>        ↑    ↑    ↑    ↑    ↑    ↑<br/>      -6    -5   -4   -3   -2   -1</span><span id="d69e" class="mq mr it mm b gy mw mt l mu mv">print(tup[-3])</span><span id="0553" class="mq mr it mm b gy mw mt l mu mv"><strong class="mm iu">Output:<br/></strong>i</span></pre><p id="40e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">说明:</strong></p><p id="041e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在负索引中，从右到左访问元组，其中第一个元素的索引总是以'-1 '开始。在上面的print语句中，要求访问一个索引值为“-3”的元素。因此，输出是“I”。</p><p id="e7c4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> 3。切片</strong></p><p id="be4f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">程序:</strong></p><pre class="kj kk kl km gt ml mm mn mo aw mp bi"><span id="eeb4" class="mq mr it mm b gy ms mt l mu mv">tup = (‘p’, ‘r’, ‘t’, ‘l’, ‘o’, ‘n’)<br/>        ↑    ↑    ↑    ↑    ↑    ↑<br/>        0    1    2    3    4    5</span><span id="6e05" class="mq mr it mm b gy mw mt l mu mv">print(tup[1:3])<br/>print(tup[2:])<br/>print(tup[:-4])<br/>print(tup[:])</span><span id="726a" class="mq mr it mm b gy mw mt l mu mv"><strong class="mm iu">Output:<br/></strong>(‘r’, ‘t’, ‘l’)<br/>(‘t’, ‘l’, ‘o’, ‘n’)<br/>(‘p’, ‘r’)<br/>(‘p’, ‘r’, ‘t’, ‘l’, ‘o’, ‘n’)</span></pre><p id="7ee4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">解释:</strong></p><p id="2a9b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">元组切片允许我们获得定义范围的元素。现在让我们来看看每个打印语句表示什么:</p><ul class=""><li id="0695" class="mc md it lb b lc ld lf lg li me lm mf lq mg lu mx mi mj mk bi translated">在第一个print语句中，要求从索引位置1到3获取元素。因此我们得到的输出是(' r '，' t '，' l ')。</li><li id="4a65" class="mc md it lb b lc my lf mz li na lm nb lq nc lu mx mi mj mk bi translated">在第二个print语句中，要求从索引位置2开始获取所有元素。因此我们得到的输出是(' t '，' l '，' o '，' n ')。</li><li id="c7a5" class="mc md it lb b lc my lf mz li na lm nb lq nc lu mx mi mj mk bi translated">第三条语句表示打印索引位置'-4 '之前的所有语句。因此我们得到的输出为(' p '，' r ')。</li><li id="5b53" class="mc md it lb b lc my lf mz li na lm nb lq nc lu mx mi mj mk bi translated">在第四个print语句中，':'运算符用于显示元组的所有元素。</li></ul><div class="nd ne gp gr nf ng"><a href="https://pub.towardsai.net/become-a-data-scientist-in-2021-with-these-following-steps-5bf70a0fe0a1" rel="noopener  ugc nofollow" target="_blank"><div class="nh ab fo"><div class="ni ab nj cl cj nk"><h2 class="bd iu gy z fp nl fr fs nm fu fw is bi translated">按照以下步骤，在2021年成为一名数据科学家</h2><div class="nn l"><h3 class="bd b gy z fp nl fr fs nm fu fw dk translated">走上数据科学家之路需要具备的基本点</h3></div><div class="no l"><p class="bd b dl z fp nl fr fs nm fu fw dk translated">pub.towardsai.net</p></div></div><div class="np l"><div class="nq l nr ns nt np nu ks ng"/></div></div></a></div><div class="nd ne gp gr nf ng"><a href="https://pub.towardsai.net/python-zero-to-hero-with-examples-c7a5dedb968b" rel="noopener  ugc nofollow" target="_blank"><div class="nh ab fo"><div class="ni ab nj cl cj nk"><h2 class="bd iu gy z fp nl fr fs nm fu fw is bi translated">Python:从零到英雄(带示例)</h2><div class="nn l"><h3 class="bd b gy z fp nl fr fs nm fu fw dk translated">python初学者手册指南</h3></div><div class="no l"><p class="bd b dl z fp nl fr fs nm fu fw dk translated">pub.towardsai.net</p></div></div><div class="np l"><div class="nv l nr ns nt np nu ks ng"/></div></div></a></div><blockquote class="lv lw lx"><p id="2738" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated"><strong class="lb iu"> <em class="it">修改一个元组</em> </strong></p></blockquote><ol class=""><li id="6f31" class="mc md it lb b lc ld lf lg li me lm mf lq mg lu mh mi mj mk bi translated"><strong class="lb iu">替换元组中的元素</strong></li></ol><p id="a2b9" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">程序</strong></p><pre class="kj kk kl km gt ml mm mn mo aw mp bi"><span id="0c3b" class="mq mr it mm b gy ms mt l mu mv">p = (‘p’, ‘y’, ‘t’, ‘h’, ‘o’, ’n’, (4, 5, 6), [56, 47])</span><span id="717e" class="mq mr it mm b gy mw mt l mu mv">p[5] = 8<br/>print(p)</span><span id="b574" class="mq mr it mm b gy mw mt l mu mv"><strong class="mm iu">Output:<br/></strong>(‘p’, ‘y’, ‘t’, ‘h’, ‘o’, 8, (4, 5, 6), [56, 47])</span></pre><p id="049f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> 2。重新分配元组</strong></p><pre class="kj kk kl km gt ml mm mn mo aw mp bi"><span id="f38f" class="mq mr it mm b gy ms mt l mu mv">#Tuples can also be re-assigned</span><span id="9636" class="mq mr it mm b gy mw mt l mu mv">p = (‘p’, ‘u’, ‘t’, ‘i’, ‘o’, ‘t’)</span><span id="99ec" class="mq mr it mm b gy mw mt l mu mv">print(p)</span><span id="d0e6" class="mq mr it mm b gy mw mt l mu mv"><strong class="mm iu">Output:<br/></strong>(‘p’, ‘u’, ‘t’, ‘i’, ‘o’, ‘t’)</span></pre><p id="5672" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">说明:</strong></p><ul class=""><li id="da21" class="mc md it lb b lc ld lf lg li me lm mf lq mg lu mx mi mj mk bi translated">在第一个程序中，我们在索引位置5赋值“8”。运行程序后，我们可以看到值“8”被添加到索引位置5。</li><li id="772d" class="mc md it lb b lc my lf mz li na lm nb lq nc lu mx mi mj mk bi translated">在第二个程序中，我们将元组“(' p '，' y '，' t '，' h '，' o '，' n '，(4，5，6)，[56，47])”替换为“(' p '，' u '，' t '，' I '，' o '，' t ')”。在执行程序时，我们可以观察到发生的变化。</li></ul><blockquote class="lv lw lx"><p id="3e75" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated"><strong class="lb iu"> <em class="it">删除元组</em> </strong></p></blockquote><p id="96bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在元组中，元素不能像列表那样被删除。只能删除整个元组。让我们看一个例子:</p><p id="2afc" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">程序:</strong></p><pre class="kj kk kl km gt ml mm mn mo aw mp bi"><span id="8520" class="mq mr it mm b gy ms mt l mu mv">y = (‘p’, ‘h’, ‘t’, ‘t’, ‘o’, ‘e’)</span><span id="8141" class="mq mr it mm b gy mw mt l mu mv">del y<br/>print(y)</span><span id="e70b" class="mq mr it mm b gy mw mt l mu mv"><strong class="mm iu">Output:<br/></strong>Traceback (most recent call last):<br/>    File “&lt;string&gt;”, line 12, in &lt;module&gt;<br/>NameError: name ‘my_tuple’ is not defined</span></pre><blockquote class="lv lw lx"><p id="5953" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated"><strong class="lb iu"> <em class="it">元组方法</em> </strong></p></blockquote><p id="0d5e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">元组中只有2种方法可用。让我们用一个编程示例来看看它们:</p><ol class=""><li id="724f" class="mc md it lb b lc ld lf lg li me lm mf lq mg lu mh mi mj mk bi translated"><strong class="lb iu">计数()</strong></li></ol><p id="ae23" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">count方法返回位于元组中的元素的位置值。(计数值从1开始)</p><p id="d388" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">程序:</strong></p><pre class="kj kk kl km gt ml mm mn mo aw mp bi"><span id="04c8" class="mq mr it mm b gy ms mt l mu mv">a = (p’, ‘r’, ‘t’, ‘u’, ‘o’, ‘l’)</span><span id="7a76" class="mq mr it mm b gy mw mt l mu mv">print(a.count(‘t’))</span><span id="3f5a" class="mq mr it mm b gy mw mt l mu mv"><strong class="mm iu">Output:<br/></strong>3</span></pre><p id="31d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">解释:</strong>这里的要求是返回元组‘a’中元素‘t’的位置。因此得到的输出是3。</p><p id="13bd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu"> 2。索引()</strong></p><p id="b119" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">index方法返回位于元组中的元素的索引值。(索引值从0开始)</p><p id="0b2e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">程序:</strong></p><pre class="kj kk kl km gt ml mm mn mo aw mp bi"><span id="f325" class="mq mr it mm b gy ms mt l mu mv">b = (p’, ‘d’, ‘t’, ‘g’, ‘o’, ‘m’)</span><span id="6100" class="mq mr it mm b gy mw mt l mu mv">print(a.index(‘t’))</span><span id="cc3b" class="mq mr it mm b gy mw mt l mu mv"><strong class="mm iu">Output:<br/></strong>2</span></pre><p id="6297" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">解释:</strong></p><p id="923d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里的要求是返回元组' a '中元素' t '的索引值。因此得到的输出是2。</p><blockquote class="lv lw lx"><p id="b6e8" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated"><strong class="lb iu"> <em class="it">元组成员测试</em> </strong></p></blockquote><p id="1a90" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">元组中的成员资格测试是检查定义的元素是否出现在列表中。</p><p id="d473" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">程序:</strong></p><pre class="kj kk kl km gt ml mm mn mo aw mp bi"><span id="39b7" class="mq mr it mm b gy ms mt l mu mv">member = (p’, ‘e’, ‘t’, ‘f’, ‘o’, ‘c’)</span><span id="3169" class="mq mr it mm b gy mw mt l mu mv">print(‘t’ in member)<br/>print(‘b’ in member)</span><span id="483a" class="mq mr it mm b gy mw mt l mu mv"><strong class="mm iu">Output:<br/></strong>True<br/>False</span></pre><p id="ff13" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">说明:</strong></p><p id="d636" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，第一个print语句要求检查元素“t”是否出现在元组中。因为元素存在于元组中，所以输出为真。而第二条语句返回false，因为元组中不存在元素“b”。</p><blockquote class="lv lw lx"><p id="5dcc" class="kz la ly lb b lc ld ju le lf lg jx lh lz lj lk ll ma ln lo lp mb lr ls lt lu im bi translated"><strong class="lb iu"> <em class="it">迭代使用元组</em> </strong></p></blockquote><p id="d707" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">元组中的迭代类似于列表中的迭代。“For”循环也用在元组中。让我们看一个例子:</p><p id="f4b4" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">程序:</strong></p><pre class="kj kk kl km gt ml mm mn mo aw mp bi"><span id="4d45" class="mq mr it mm b gy ms mt l mu mv">for word in (‘apple’, ‘oranges’)<br/>    print(“I like”, word)</span><span id="eacf" class="mq mr it mm b gy mw mt l mu mv"><strong class="mm iu">Output:<br/></strong>I like apples<br/>I like oranges</span></pre><p id="5f7b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><strong class="lb iu">解释:</strong></p><p id="d30d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这里，for循环打印元组中的每个元素，直到到达列表的末尾。</p></div><div class="ab cl nw nx hx ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="im in io ip iq"><p id="3c1e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我希望你喜欢这篇文章。通过我的<a class="ae ky" href="https://www.linkedin.com/in/data-scientist-95040a1ab/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>和<a class="ae ky" href="https://twitter.com/amitprius" rel="noopener ugc nofollow" target="_blank"> twitter </a>联系我。</p><h1 id="86d9" class="od mr it bd oe of og oh oi oj ok ol om jz on ka oo kc op kd oq kf or kg os ot bi translated">推荐文章</h1><p id="df19" class="pw-post-body-paragraph kz la it lb b lc ou ju le lf ov jx lh li ow lk ll lm ox lo lp lq oy ls lt lu im bi translated"><a class="ae ky" href="https://medium.com/towards-artificial-intelligence/nlp-zero-to-hero-with-python-2df6fcebff6e?sk=2231d868766e96b13d1e9d7db6064df1" rel="noopener"> 1。NLP —零到英雄与Python </a> <br/> 2。<a class="ae ky" href="https://medium.com/towards-artificial-intelligence/python-data-structures-data-types-and-objects-244d0a86c3cf?sk=42f4b462499f3fc3a160b21e2c94dba6" rel="noopener"> Python数据结构数据类型和对象</a>T5】3 .<a class="ae ky" href="https://pub.towardsai.net/exception-handling-concepts-in-python-4d5116decac3?source=friends_link&amp;sk=a0ed49d9fdeaa67925eac34ecb55ea30" rel="noopener ugc nofollow" target="_blank">Python中的异常处理概念</a> <br/> 4。<a class="ae ky" href="https://pub.towardsai.net/deep-learning-88e218b74a14?source=friends_link&amp;sk=540bf9088d31859d50dbddab7524ba35" rel="noopener ugc nofollow" target="_blank">为什么LSTM在深度学习方面比RNN更有用？</a> <br/> 5。<a class="ae ky" href="https://pub.towardsai.net/neural-networks-the-rise-of-recurrent-neural-networks-df740252da88?source=friends_link&amp;sk=6844935e3de14e478ce00f0b22e419eb" rel="noopener ugc nofollow" target="_blank">神经网络:递归神经网络的兴起</a> <br/> 6。<a class="ae ky" href="https://medium.com/towards-artificial-intelligence/fully-explained-linear-regression-with-python-fe2b313f32f3?source=friends_link&amp;sk=53c91a2a51347ec2d93f8222c0e06402" rel="noopener">用Python </a> <br/> 7全面讲解了线性回归。<a class="ae ky" href="https://medium.com/towards-artificial-intelligence/fully-explained-logistic-regression-with-python-f4a16413ddcd?source=friends_link&amp;sk=528181f15a44e48ea38fdd9579241a78" rel="noopener">用Python </a> <br/>充分解释了Logistic回归8。<a class="ae ky" href="https://pub.towardsai.net/differences-between-concat-merge-and-join-with-python-1a6541abc08d?source=friends_link&amp;sk=3b37b694fb90db16275059ea752fc16a" rel="noopener ugc nofollow" target="_blank">concat()、merge()和join()与Python </a> <br/>的区别9。<a class="ae ky" href="https://pub.towardsai.net/data-wrangling-with-python-part-1-969e3cc81d69?source=friends_link&amp;sk=9c3649cf20f31a5c9ead51c50c89ba0b" rel="noopener ugc nofollow" target="_blank">与Python的数据角力—第一部分</a> <br/> 10。<a class="ae ky" href="https://medium.com/analytics-vidhya/confusion-matrix-in-machine-learning-91b6e2b3f9af?source=friends_link&amp;sk=11c6531da0bab7b504d518d02746d4cc" rel="noopener">机器学习中的混淆矩阵</a></p></div></div>    
</body>
</html>