<html>
<head>
<title>New JavaScript Features Coming in ES2020 That You Can Use Now (Part 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">您现在可以使用的ES2020中的新JavaScript特性(第2部分)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/new-javascript-features-coming-in-es2020-that-you-can-use-now-part-2-4b50831e4cb2?source=collection_archive---------9-----------------------#2019-12-16">https://levelup.gitconnected.com/new-javascript-features-coming-in-es2020-that-you-can-use-now-part-2-4b50831e4cb2?source=collection_archive---------9-----------------------#2019-12-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="5f1f" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">类中的静态字段/方法和顶级等待</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3aa289f8beae74b63c8d8666d0b0440b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rTbUept3hR0FzhRt"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">帕特里克·托马索在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="0cf3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">自2015年以来，JavaScript一直在快速发展，每次迭代都会推出许多新功能。JavaScript语言规范的新版本每年都在更新，新的语言特性提案的完成速度比以往任何时候都要快。</p><p id="0331" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">这意味着新特性正以前所未有的速度融入现代浏览器和Node.js等其他JavaScript运行时引擎。2019年，有许多新功能处于“阶段3”阶段，这意味着它非常接近完成，浏览器现在开始支持这些功能。</p><p id="3cb3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们想将它们用于生产代码，我们可以使用Babel之类的东西将它们转换成旧版本的JavaScript，以便在需要时可以在旧版本的浏览器中使用，如Internet Explorer。</p><p id="f227" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在本文中，我们将研究类中的静态字段和方法，并在常规代码和模块导出中的顶层使用<code class="fe lv lw lx ly b">await</code>关键字。</p><h1 id="fdb0" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">类中的静态字段和方法</h1><p id="9cd6" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">类中的静态字段是browsers和Node.js即将推出的新特性，它允许我们为不需要创建类实例就能访问的类添加静态字段。它们可以是私有的，也可以是公共的。这是枚举的一个方便的替代品。例如，根据最新的提议，我们可以编写一个包含静态变量的类，如下例所示:</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="ea20" class="na ma it ly b gy nb nc l nd ne">class Fruit {  <br/>  static orange = 'orange';<br/>  static grape = 'grape';<br/>  static banana = 'banana';<br/>  static apple = 'apple';</span><span id="1e12" class="na ma it ly b gy nf nc l nd ne">  static #secretPear = 'pear';</span><span id="33a1" class="na ma it ly b gy nf nc l nd ne">}</span><span id="d505" class="na ma it ly b gy nf nc l nd ne">console.log(Fruit.orange);<br/>console.log(Fruit.grape);<br/>console.log(Fruit.banana);<br/>console.log(Fruit.apple);</span></pre><p id="90ab" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">上面的示例应该输出:</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="db94" class="na ma it ly b gy nb nc l nd ne">orange<br/>grape<br/>banana<br/>apple</span></pre><p id="7553" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们试图从类外部访问<code class="fe lv lw lx ly b">secretPear</code>，如下面的代码所示:</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="e6bb" class="na ma it ly b gy nb nc l nd ne">console.log(Fruit.#secretPear);</span></pre><p id="a236" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们将得到“未捕获的语法错误:私有字段“#secretPear”必须在封闭类中声明。”</p><p id="d0e6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">关键字<code class="fe lv lw lx ly b">static</code>从ES6开始就已经在类中使用方法了。例如，我们可以通过使用<code class="fe lv lw lx ly b">static</code>关键字在类中声明一个静态方法，如下面的代码所示:</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="593a" class="na ma it ly b gy nb nc l nd ne">class ClassStatic {<br/>  static staticMethod() {<br/>    return 'Static method has been called.';<br/>  }<br/>}</span><span id="cc0a" class="na ma it ly b gy nf nc l nd ne">console.log(ClassStatic.staticMethod());</span></pre><p id="451b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们应该从<code class="fe lv lw lx ly b">console.log</code>输出中得到‘静态方法已被调用’。正如我们所看到的，调用了<code class="fe lv lw lx ly b">staticMethod</code>方法，但没有像我们预期的那样实例化类<code class="fe lv lw lx ly b">ClassStatic</code>。静态方法也可以是私有的，我们只是在方法名前加一个<code class="fe lv lw lx ly b">#</code>符号，使其私有。例如，我们可以编写以下代码:</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="dc31" class="na ma it ly b gy nb nc l nd ne">class ClassStatic {<br/>  static #privateStaticMethod(){<br/>    return 'Static method has been called.';<br/>  }<br/>  <br/>  static staticMethod() {<br/>    return ClassStatic.#privateStaticMethod();<br/>  }<br/>}</span><span id="bef4" class="na ma it ly b gy nf nc l nd ne">console.log(ClassStatic.staticMethod());</span></pre><p id="fc61" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码中，我们从<code class="fe lv lw lx ly b">staticMethod</code>调用了<code class="fe lv lw lx ly b">privateStaticMethod</code>来获取<code class="fe lv lw lx ly b">staticMethod</code>中<code class="fe lv lw lx ly b">privateStaticMethod</code>的返回值。然后当我们通过运行<code class="fe lv lw lx ly b">ClassStatic.staticMethod()</code>调用<code class="fe lv lw lx ly b">staticMethod</code>时，我们得到‘静态方法已被调用’然而，我们不能直接从类外调用<code class="fe lv lw lx ly b">privateStaticMethod</code>，所以如果我们运行类似于:</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="84a8" class="na ma it ly b gy nb nc l nd ne">class ClassStatic {<br/>  static #privateStaticMethod(){<br/>    return 'Static method has been called.';<br/>  }<br/>  <br/>  static staticMethod() {<br/>    return ClassStatic.#privateStaticMethod();<br/>  }<br/>}</span><span id="ed76" class="na ma it ly b gy nf nc l nd ne">console.log(ClassStatic.#privateStaticMethod());</span></pre><p id="d064" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么我们将得到一个错误。另外，请注意，我们没有使用<code class="fe lv lw lx ly b">this</code>来访问<code class="fe lv lw lx ly b">privateStaticMethod</code>，我们使用了类名<code class="fe lv lw lx ly b">ClassStatic</code>来访问。如果我们使用<code class="fe lv lw lx ly b">this</code>来调用它，就像在<code class="fe lv lw lx ly b">this.#privateStaticMethod()</code>中一样，我们将得到一个错误或<code class="fe lv lw lx ly b">undefined</code>，这取决于我们使用的Babel版本。浏览器部分支持变量的关键字<code class="fe lv lw lx ly b">static</code>。Chrome和Opera等Chromium浏览器都支持。Node.js也支持这个关键字。其他浏览器还不支持它，所以我们必须使用Babel将其转换成旧的JavaScript代码，以便在其他浏览器上运行。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ng"><img src="../Images/4de21bf06dc5ba0c1efbd91f8ffd489a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JwtewiJlkOdIitLJ"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae ky" href="https://unsplash.com/@kaip?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">凯·皮尔格</a>在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="d0c1" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">顶级等待</h1><p id="690e" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">目前，<code class="fe lv lw lx ly b">await</code>关键字只能在<code class="fe lv lw lx ly b">async</code>函数中使用，它是返回承诺的函数。如果我们在一个<code class="fe lv lw lx ly b">async</code>函数之外使用<code class="fe lv lw lx ly b">await</code>关键字，我们将会得到一个类似‘不能在一个异步函数之外使用关键字’这样的错误，我们的程序将不会运行。现在，我们可以使用<code class="fe lv lw lx ly b">await</code>关键字，而不必将其放在<code class="fe lv lw lx ly b">async</code>函数中。例如，我们可以在下面的代码中使用它:</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="0046" class="na ma it ly b gy nb nc l nd ne">const promise1 = new Promise((resolve)=&gt;{<br/>  setTimeout(()=&gt; resolve('promise1 resolved'), 1000);<br/>})</span><span id="f683" class="na ma it ly b gy nf nc l nd ne">const promise2 = new Promise((resolve)=&gt;{<br/>  setTimeout(()=&gt; resolve('promise2 resolved'), 1000);<br/>})</span><span id="c7bc" class="na ma it ly b gy nf nc l nd ne">const val1 = await promise1;<br/>console.log(val1);<br/>const val2 =  await promise2;<br/>console.log(val2);</span></pre><p id="b1ae" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后，当我们在Chrome中运行上面的代码时，我们会得到:</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="54b6" class="na ma it ly b gy nb nc l nd ne">promise1 resolved<br/>promise2 resolved</span></pre><p id="0519" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">有了顶级的<code class="fe lv lw lx ly b">await</code>，我们可以随心所欲地运行异步代码，而且我们不必再使用冗长的<code class="fe lv lw lx ly b">then</code>函数链，将回调传递给每个<code class="fe lv lw lx ly b">then</code>函数调用。这非常简洁，如果我们不想声明一个命名函数，我们不必将它包装在一个<code class="fe lv lw lx ly b">async</code>life(立即调用的函数表达式)中来运行它。</p><p id="881e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">顶级<code class="fe lv lw lx ly b">await</code>的另一个好处是我们可以直接导出它。这意味着当模块导出带有<code class="fe lv lw lx ly b">await</code>关键字的东西时，它将在运行任何东西之前等待作为<code class="fe lv lw lx ly b">await</code>关键字的承诺被解析。表面上，它的行为就像是照常同步导入一样，但在本质上，它实际上是在等待<code class="fe lv lw lx ly b">export</code>表达式中的承诺进行解析。例如，我们可以写:</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="16d4" class="na ma it ly b gy nb nc l nd ne">const promise1 = new Promise((resolve)=&gt;{<br/>  setTimeout(()=&gt; resolve('promise1 resolved'), 1000);<br/>})<br/>export const val1 = await promise1;</span></pre><p id="9f9f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当我们在<code class="fe lv lw lx ly b">module2.js</code>中导入<code class="fe lv lw lx ly b">module1.js</code>时:</p><pre class="kj kk kl km gt mw ly mx my aw mz bi"><span id="c2bd" class="na ma it ly b gy nb nc l nd ne">import { <!-- -->val1 <!-- -->} from './module1';<br/>console.log(<!-- -->val1);</span></pre><p id="323b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">然后我们可以看到记录的<code class="fe lv lw lx ly b">val1</code>的值，好像它正在同步运行，等待<code class="fe lv lw lx ly b">promise1</code>解析。</p><h1 id="eba1" class="lz ma it bd mb mc md me mf mg mh mi mj jz mk ka ml kc mm kd mn kf mo kg mp mq bi translated">结论</h1><p id="33c6" class="pw-post-body-paragraph kz la it lb b lc mr ju le lf ms jx lh li mt lk ll lm mu lo lp lq mv ls lt lu im bi translated">类中的静态字段是browsers和Node.js即将推出的新特性，它允许我们为不需要创建类实例就能访问的类添加静态字段。它们可以是私有的，也可以是公共的。这是枚举的一个方便的替代品。</p><p id="7b31" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">静态方法从ES6开始就存在了，所以它现在可以使用，并得到了广泛的支持。一旦特性完成，在常规代码和模块导出的顶层使用<code class="fe lv lw lx ly b">await</code>关键字会非常方便。它允许我们使用<code class="fe lv lw lx ly b">await</code>在<code class="fe lv lw lx ly b">async</code>函数之外编写异步代码，这比使用带有回调的<code class="fe lv lw lx ly b">then</code>要干净得多。</p><p id="b6bb" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，它可以让我们导出异步代码的解析值，然后导入它，并在其他模块中使用它，就像它是同步代码一样。</p></div></div>    
</body>
</html>