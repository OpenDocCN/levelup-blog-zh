<html>
<head>
<title>Java Spliterator Explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java Spliterator解释</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/java-spliterator-explained-81e501b37b3d?source=collection_archive---------10-----------------------#2021-03-15">https://levelup.gitconnected.com/java-spliterator-explained-81e501b37b3d?source=collection_archive---------10-----------------------#2021-03-15</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="7c54" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated"><em class="ki">迭代器+拆分= &gt;拆分器</em></h2></div><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/548c0d98b2c965507a0ce39231167f94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P6uF6PI408erPpuNjy-K9A.jpeg"/></div></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk translated">图片来自<a class="ae kz" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=820000" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的<a class="ae kz" href="https://pixabay.com/users/republica-24347/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=820000" rel="noopener ugc nofollow" target="_blank"> Republica </a></figcaption></figure><p id="5bcb" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">Java有多种类型的<em class="lw">遍历源的</em>元素。我的上一篇文章展示了如何使用<code class="fe lx ly lz ma b"><a class="ae kz" href="https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html" rel="noopener ugc nofollow" target="_blank">java.util.Iterator&lt;T&gt;</a></code>和<code class="fe lx ly lz ma b"><a class="ae kz" href="https://docs.oracle.com/javase/8/docs/api/java/util/ListIterator.html" rel="noopener ugc nofollow" target="_blank">java.util.ListIterator&lt;T&gt;</a></code>来遍历像集合这样的数据结构。</p><p id="059a" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">从Java 1.2开始就支持<em class="lw">迭代器</em>的概念，但是在Java 8中有了一个新的亲戚<code class="fe lx ly lz ma b"><a class="ae kz" href="https://docs.oracle.com/javase/8/docs/api/java/util/Spliterator.html" rel="noopener ugc nofollow" target="_blank">java.util.Spliterator&lt;T&gt;</a></code>。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="72b4" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">分割器<t/></h1><p id="67aa" class="pw-post-body-paragraph la lb it lc b ld na ju lf lg nb jx li lj nc ll lm ln nd lp lq lr ne lt lu lv im bi translated">除了<em class="lw">遍历</em>序列的数据外，像<code class="fe lx ly lz ma b"><a class="ae kz" href="https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html" rel="noopener ugc nofollow" target="_blank">Iterator&lt;T&gt;</a></code>、<code class="fe lx ly lz ma b"><a class="ae kz" href="https://docs.oracle.com/javase/8/docs/api/java/util/Spliterator.html" rel="noopener ugc nofollow" target="_blank">Spliterator&lt;T&gt;</a></code>也可以<em class="lw">分割</em>它:</p><blockquote class="nf"><p id="e33d" class="ng nh it bd ni nj nk nl nm nn no lv dk translated"><em class="ki">迭代器+拆分= &gt;拆分器</em></p></blockquote><p id="c573" class="pw-post-body-paragraph la lb it lc b ld np ju lf lg nq jx li lj nr ll lm ln ns lp lq lr nt lt lu lv im bi translated"><code class="fe lx ly lz ma b">trySplit()</code>方法允许它将序列中的一些元素划分为另一个<code class="fe lx ly lz ma b"><a class="ae kz" href="https://docs.oracle.com/javase/8/docs/api/java/util/Spliterator.html" rel="noopener ugc nofollow" target="_blank">Spliterator&lt;T&gt;</a></code>。</p><p id="de22" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">与迭代器相比，这个特别的优势使它成为Stream API的核心组件。通过将数据分割成apt子序列，它允许并行处理。</p><h2 id="4ccf" class="nu mj it bd mk nv nw dn mo nx ny dp ms lj nz oa mu ln ob oc mw lr od oe my of bi translated">特征</h2><p id="62e9" class="pw-post-body-paragraph la lb it lc b ld na ju lf lg nb jx li lj nc ll lm ln nd lp lq lr ne lt lu lv im bi translated">不是每个数据序列都可以被<em class="lw">分割成多个部分。</em></p><p id="2952" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">作为并行处理的<em class="lw">使能器</em>，实际的<em class="lw">处理器</em>必须知道更多关于它从<code class="fe lx ly lz ma b"><a class="ae kz" href="https://docs.oracle.com/javase/8/docs/api/java/util/Spliterator.html" rel="noopener ugc nofollow" target="_blank">Spliterator&lt;T&gt;</a></code>获得的数据。例如，如果一个数据序列<em class="lw">必须</em>被排序，那么流需要以不同于无序集合的方式处理它。</p><p id="2093" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">为了提供尽可能多的关于“分裂”数据序列的信息，一个<code class="fe lx ly lz ma b"><a class="ae kz" href="https://docs.oracle.com/javase/8/docs/api/java/util/Spliterator.html" rel="noopener ugc nofollow" target="_blank">Spliterator&lt;T&gt;</a></code>可以具有某些<em class="lw">特征</em>:</p><ul class=""><li id="3635" class="og oh it lc b ld le lg lh lj oi ln oj lr ok lv ol om on oo bi translated"><code class="fe lx ly lz ma b"><a class="ae kz" href="https://docs.oracle.com/javase/8/docs/api/java/util/Spliterator.html#CONCURRENT" rel="noopener ugc nofollow" target="_blank">CONCURRENT</a><br/></code>底层元素源代码在没有外部同步的情况下是线程安全的吗？</li><li id="9862" class="og oh it lc b ld op lg oq lj or ln os lr ot lv ol om on oo bi translated"><code class="fe lx ly lz ma b"><a class="ae kz" href="https://docs.oracle.com/javase/8/docs/api/java/util/Spliterator.html#DISTINCT" rel="noopener ugc nofollow" target="_blank">DISTINCT</a><br/></code>所有元素对于任何一对都是唯一的和<code class="fe lx ly lz ma b">x.equals(y) == false</code>的吗？</li><li id="a467" class="og oh it lc b ld op lg oq lj or ln os lr ot lv ol om on oo bi translated"><code class="fe lx ly lz ma b"><a class="ae kz" href="https://docs.oracle.com/javase/8/docs/api/java/util/Spliterator.html#IMMUTABLE" rel="noopener ugc nofollow" target="_blank">IMMUTABLE</a><br/></code>在遍历过程中，是否不允许对源文件进行任何更改，如添加/删除/替换？</li><li id="d89c" class="og oh it lc b ld op lg oq lj or ln os lr ot lv ol om on oo bi translated"><code class="fe lx ly lz ma b"><a class="ae kz" href="https://docs.oracle.com/javase/8/docs/api/java/util/Spliterator.html#NONNULL" rel="noopener ugc nofollow" target="_blank">NONNULL</a><br/></code>所有元素都有保障<code class="fe lx ly lz ma b">!= null</code>？</li><li id="2e1b" class="og oh it lc b ld op lg oq lj or ln os lr ot lv ol om on oo bi translated"><code class="fe lx ly lz ma b"><a class="ae kz" href="https://docs.oracle.com/javase/8/docs/api/java/util/Spliterator.html#ORDERED" rel="noopener ugc nofollow" target="_blank">ORDERED</a><br/></code>元素来源是否有序？</li><li id="d661" class="og oh it lc b ld op lg oq lj or ln os lr ot lv ol om on oo bi translated"><code class="fe lx ly lz ma b"><a class="ae kz" href="https://docs.oracle.com/javase/8/docs/api/java/util/Spliterator.html#SIZED" rel="noopener ugc nofollow" target="_blank">SIZED</a><br/></code>遍历前的预估尺寸是实际尺寸吗？</li><li id="4644" class="og oh it lc b ld op lg oq lj or ln os lr ot lv ol om on oo bi translated"><code class="fe lx ly lz ma b"><a class="ae kz" href="https://docs.oracle.com/javase/8/docs/api/java/util/Spliterator.html#SORTED" rel="noopener ugc nofollow" target="_blank">SORTED</a><br/></code>元素排序了吗？</li><li id="6356" class="og oh it lc b ld op lg oq lj or ln os lr ot lv ol om on oo bi translated"><code class="fe lx ly lz ma b"><a class="ae kz" href="https://docs.oracle.com/javase/8/docs/api/java/util/Spliterator.html#SUBSIZED" rel="noopener ugc nofollow" target="_blank">SUBSIZED</a><br/></code>源的拆分部分还是<code class="fe lx ly lz ma b"><a class="ae kz" href="https://docs.oracle.com/javase/8/docs/api/java/util/Spliterator.html#SIZED" rel="noopener ugc nofollow" target="_blank">SIZED</a></code>？</li></ul><p id="3a17" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">特征由<code class="fe lx ly lz ma b">int</code>表示，所以要提供多个值，我们需要使用<a class="ae kz" href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/op3.html" rel="noopener ugc nofollow" target="_blank"> <em class="lw">按位or </em> </a> <em class="lw"> </em> <code class="fe lx ly lz ma b">|</code>。</p><p id="5f15" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">以下是由常用集合类型创建的拆分器的特征:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ou ov l"/></div></figure><p id="15b8" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><code class="fe lx ly lz ma b"><a class="ae kz" href="https://docs.oracle.com/javase/8/docs/api/java/util/HashSet.html" rel="noopener ugc nofollow" target="_blank">HashSet&lt;T&gt;</a></code>的例子也表明，这些特征不必固定不变。他们可以利用周围的环境做出明智的决定。</p><h1 id="8bc0" class="mi mj it bd mk ml ow mn mo mp ox mr ms jz oy ka mu kc oz kd mw kf pa kg my mz bi translated">界面</h1><p id="ace1" class="pw-post-body-paragraph la lb it lc b ld na ju lf lg nb jx li lj nc ll lm ln nd lp lq lr ne lt lu lv im bi translated"><code class="fe lx ly lz ma b"><a class="ae kz" href="https://docs.oracle.com/javase/8/docs/api/java/util/Spliterator.html" rel="noopener ugc nofollow" target="_blank">java.util.Spliterator&lt;T&gt;</a></code>只有8种方法。如果我们不计算<code class="fe lx ly lz ma b">default</code>方法，这个数字会下降到4:</p><pre class="kk kl km kn gt pb ma pc pd aw pe bi"><span id="bcca" class="nu mj it ma b gy pf pg l ph pi"><strong class="ma iu">// CHARACTERISTICS</strong></span><span id="bb86" class="nu mj it ma b gy pj pg l ph pi">int <a class="ae kz" href="https://docs.oracle.com/javase/8/docs/api/java/util/Spliterator.html#characteristics--" rel="noopener ugc nofollow" target="_blank">characteristics</a>();</span><span id="e326" class="nu mj it ma b gy pj pg l ph pi">default boolean <a class="ae kz" href="https://docs.oracle.com/javase/8/docs/api/java/util/Spliterator.html#hasCharacteristics-int-" rel="noopener ugc nofollow" target="_blank">hasCharacteristics</a>(int characteristics)</span><span id="c5b8" class="nu mj it ma b gy pj pg l ph pi"><strong class="ma iu">// SIZE</strong></span><span id="48e3" class="nu mj it ma b gy pj pg l ph pi">long <a class="ae kz" href="https://docs.oracle.com/javase/8/docs/api/java/util/Spliterator.html#estimateSize--" rel="noopener ugc nofollow" target="_blank">estimateSize</a>();</span><span id="ad81" class="nu mj it ma b gy pj pg l ph pi">default long <a class="ae kz" href="https://docs.oracle.com/javase/8/docs/api/java/util/Spliterator.html#getExactSizeIfKnown--" rel="noopener ugc nofollow" target="_blank">getExactSizeIfKnown</a>();</span><span id="473d" class="nu mj it ma b gy pj pg l ph pi"><strong class="ma iu">// COMPARATOR</strong></span><span id="c36b" class="nu mj it ma b gy pj pg l ph pi">default Comparator&lt;? super T&gt; <a class="ae kz" href="https://docs.oracle.com/javase/8/docs/api/java/util/Spliterator.html#getComparator--" rel="noopener ugc nofollow" target="_blank">getComparator</a>();</span><span id="08f6" class="nu mj it ma b gy pj pg l ph pi"><strong class="ma iu">// TRAVERSING</strong></span><span id="da25" class="nu mj it ma b gy pj pg l ph pi">boolean <a class="ae kz" href="https://docs.oracle.com/javase/8/docs/api/java/util/Spliterator.html#tryAdvance-java.util.function.Consumer-" rel="noopener ugc nofollow" target="_blank">tryAdvance</a>(Consumer&lt;? super T&gt; action);</span><span id="5972" class="nu mj it ma b gy pj pg l ph pi">default void <a class="ae kz" href="https://docs.oracle.com/javase/8/docs/api/java/util/Spliterator.html#forEachRemaining-java.util.function.Consumer-" rel="noopener ugc nofollow" target="_blank">forEachRemaining</a>(Consumer&lt;? super T&gt; action);</span><span id="72d6" class="nu mj it ma b gy pj pg l ph pi"><strong class="ma iu">// SPLITTING</strong></span><span id="8645" class="nu mj it ma b gy pj pg l ph pi">Spliterator&lt;T&gt; <a class="ae kz" href="https://docs.oracle.com/javase/8/docs/api/java/util/Spliterator.html#trySplit--" rel="noopener ugc nofollow" target="_blank">trySplit</a>();</span></pre><p id="1eb6" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">由于这篇文章更多的是一个高层次的介绍，我就不赘述了。这些方法有很好的描述性名称，并且有很好的文档记录。</p><h1 id="1c43" class="mi mj it bd mk ml ow mn mo mp ox mr ms jz oy ka mu kc oz kd mw kf pa kg my mz bi translated">原始类型</h1><p id="58cc" class="pw-post-body-paragraph la lb it lc b ld na ju lf lg nb jx li lj nc ll lm ln nd lp lq lr ne lt lu lv im bi translated">Valhalla项目还在遥远的未来，用泛型处理基本类型是行不通的。所以原语的专用类型是我们目前唯一的选择，就像专用流一样。</p><p id="8100" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><code class="fe lx ly lz ma b"><a class="ae kz" href="https://docs.oracle.com/javase/8/docs/api/java/util/Spliterator.html" rel="noopener ugc nofollow" target="_blank">Spliterator&lt;T&gt;</a></code> 3种专业类型:</p><ul class=""><li id="61c4" class="og oh it lc b ld le lg lh lj oi ln oj lr ok lv ol om on oo bi translated"><code class="fe lx ly lz ma b"><a class="ae kz" href="https://docs.oracle.com/javase/8/docs/api/java/util/Spliterator.OfInt.html" rel="noopener ugc nofollow" target="_blank">Spliterator.OfInt</a></code></li><li id="b65a" class="og oh it lc b ld op lg oq lj or ln os lr ot lv ol om on oo bi translated"><code class="fe lx ly lz ma b"><a class="ae kz" href="https://docs.oracle.com/javase/8/docs/api/java/util/Spliterator.OfLong.html" rel="noopener ugc nofollow" target="_blank">Spliterator.OfLong</a></code></li><li id="47cd" class="og oh it lc b ld op lg oq lj or ln os lr ot lv ol om on oo bi translated"><code class="fe lx ly lz ma b"><a class="ae kz" href="https://docs.oracle.com/javase/8/docs/api/java/util/Spliterator.OfDouble.html" rel="noopener ugc nofollow" target="_blank">Spliterator.OfDouble</a></code></li></ul><p id="5acd" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">不直接支持其他基本类型，因为除了这三种类型之外，没有专门的<code class="fe lx ly lz ma b">Consumer</code>类型存在。我们可以利用<code class="fe lx ly lz ma b">Spliterator.OfPrimitive</code>来创建我们自己的，但是它需要额外的功能接口，这些接口在JDK并不容易获得。</p><h1 id="23cc" class="mi mj it bd mk ml ow mn mo mp ox mr ms jz oy ka mu kc oz kd mw kf pa kg my mz bi translated">创建拆分器</h1><p id="19d1" class="pw-post-body-paragraph la lb it lc b ld na ju lf lg nb jx li lj nc ll lm ln nd lp lq lr ne lt lu lv im bi translated">最简单的方法是使用<code class="fe lx ly lz ma b"><a class="ae kz" href="https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html" rel="noopener ugc nofollow" target="_blank">java.util.Collection</a></code>的复古<code class="fe lx ly lz ma b"><a class="ae kz" href="https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html#spliterator--" rel="noopener ugc nofollow" target="_blank">spliterator()</a></code>方法，它创造了一个没有任何特色的基本<code class="fe lx ly lz ma b"><a class="ae kz" href="https://docs.oracle.com/javase/8/docs/api/java/util/Spliterator.html" rel="noopener ugc nofollow" target="_blank">Spliterator&lt;T&gt;</a></code>。但是我在JDK遇到的所有收藏类型都提供了一个更加专业化的<code class="fe lx ly lz ma b"><a class="ae kz" href="https://docs.oracle.com/javase/8/docs/api/java/util/Spliterator.html" rel="noopener ugc nofollow" target="_blank">Spliterator&lt;T&gt;</a></code>和优化的特性。</p><p id="bec8" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">如果我们需要为一个定制的数据序列创建一个<code class="fe lx ly lz ma b"><a class="ae kz" href="https://docs.oracle.com/javase/8/docs/api/java/util/Spliterator.html" rel="noopener ugc nofollow" target="_blank">Spliterator&lt;T&gt;</a></code>，我们不一定要自己实现这个接口。相反，我们可以使用<code class="fe lx ly lz ma b"><a class="ae kz" href="https://docs.oracle.com/javase/8/docs/api/java/util/Spliterators.html" rel="noopener ugc nofollow" target="_blank">java.util.Spliterators</a></code>的便利方法。就像其他只有<code class="fe lx ly lz ma b">static</code>便利方法的类型一样，它提供了广泛的选项:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ou ov l"/></div></figure><p id="e443" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">特别有意思的是<code class="fe lx ly lz ma b"><a class="ae kz" href="https://docs.oracle.com/javase/8/docs/api/java/util/Spliterators.html#spliterator-java.util.Iterator-long-int-" rel="noopener ugc nofollow" target="_blank">&lt;T&gt; Spliterator&lt;T&gt; spliterator(Iterator&lt;? extends T&gt; iterator, long size, int characteristics)</a></code>法。在它的帮助下，每个可迭代类型都可以用作<code class="fe lx ly lz ma b"><a class="ae kz" href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html" rel="noopener ugc nofollow" target="_blank">Stream&lt;T&gt;</a></code>，即使它没有提供自己的<code class="fe lx ly lz ma b"><a class="ae kz" href="https://docs.oracle.com/javase/8/docs/api/java/util/Spliterator.html" rel="noopener ugc nofollow" target="_blank">Spliterator&lt;T&gt;</a></code>:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ou ov l"/></div></figure><p id="acde" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">实用程序类<code class="fe lx ly lz ma b"><a class="ae kz" href="https://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html" rel="noopener ugc nofollow" target="_blank">java.util.Arrays</a></code>也提供了<code class="fe lx ly lz ma b">static</code>创建<code class="fe lx ly lz ma b"><a class="ae kz" href="https://docs.oracle.com/javase/8/docs/api/java/util/Spliterator.html" rel="noopener ugc nofollow" target="_blank">Spliterator&lt;T&gt;</a></code>的便利方法，但它们大多只是包装了对<code class="fe lx ly lz ma b"><a class="ae kz" href="https://docs.oracle.com/javase/8/docs/api/java/util/Spliterators.html" rel="noopener ugc nofollow" target="_blank">Spliterators</a></code>的调用:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ou ov l"/></div></figure><h1 id="07fb" class="mi mj it bd mk ml ow mn mo mp ox mr ms jz oy ka mu kc oz kd mw kf pa kg my mz bi translated">平行</h1><p id="9368" class="pw-post-body-paragraph la lb it lc b ld na ju lf lg nb jx li lj nc ll lm ln nd lp lq lr ne lt lu lv im bi translated">并行数据处理也是一项复杂的任务。Java集合框架类型要么不是线程安全的，要么它们提供了<code class="fe lx ly lz ma b">synchronized</code>包装器来缓解。这种方法的问题是<em class="lw">线程争用:</em>线程之间对共享数据结构的访问发生冲突，导致一个线程等待另一个线程完成工作时速度变慢。</p><p id="173d" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">与一次只遍历一个项目不同的是，<code class="fe lx ly lz ma b"><a class="ae kz" href="https://docs.oracle.com/javase/8/docs/api/java/util/Spliterator.html" rel="noopener ugc nofollow" target="_blank">Spliterator&lt;T&gt;</a></code>可以分割它的一部分元素以允许并行处理，而不是提供并行行为本身。</p><p id="5e09" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">我们可以通过调用<code class="fe lx ly lz ma b"><a class="ae kz" href="https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html#parallelStream--" rel="noopener ugc nofollow" target="_blank">Collection#parallelStream()</a></code>或中间流操作<code class="fe lx ly lz ma b"><a class="ae kz" href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/BaseStream.html#parallel--" rel="noopener ugc nofollow" target="_blank">parallel()</a></code>在流中利用这一点。</p><p id="e228" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">如果我们看实际的代码，关于<code class="fe lx ly lz ma b"><a class="ae kz" href="https://docs.oracle.com/javase/8/docs/api/java/util/Spliterator.html" rel="noopener ugc nofollow" target="_blank">Spliterator&lt;T&gt;</a></code>没有太大的区别:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="ou ov l"/></div></figure><p id="9be2" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><code class="fe lx ly lz ma b"><a class="ae kz" href="https://docs.oracle.com/javase/8/docs/api/java/util/Spliterator.html" rel="noopener ugc nofollow" target="_blank">Spliterator&lt;T&gt;</a></code>促进了并行性，但是它是必须做实际工作的流。</p><p id="f2d3" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">何时使用并行流超出了本文的范围。</p><p id="60f0" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated">精髓在于使用并行流不会自动带来更好的性能。这在很大程度上取决于您处理的数据的类型和数量、您的执行环境等等。这里有一篇关于并行流的可能陷阱的文章:</p><div class="pk pl gp gr pm pn"><a rel="noopener  ugc nofollow" target="_blank" href="/be-careful-with-java-parallel-streams-3ed0fd70c3d0"><div class="po ab fo"><div class="pp ab pq cl cj pr"><h2 class="bd iu gy z fp ps fr fs pt fu fw is bi translated">小心Java并行流</h2><div class="pu l"><h3 class="bd b gy z fp ps fr fs pt fu fw dk translated">Parallels streams不仅可以提高性能，还会产生意想不到的错误</h3></div><div class="pv l"><p class="bd b dl z fp ps fr fs pt fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="pw l"><div class="px l py pz qa pw qb kt pn"/></div></div></a></div><h1 id="3d2c" class="mi mj it bd mk ml ow mn mo mp ox mr ms jz oy ka mu kc oz kd mw kf pa kg my mz bi translated">迭代器与拆分器</h1><p id="40dd" class="pw-post-body-paragraph la lb it lc b ld na ju lf lg nb jx li lj nc ll lm ln nd lp lq lr ne lt lu lv im bi translated">尽管<code class="fe lx ly lz ma b"><a class="ae kz" href="https://docs.oracle.com/javase/8/docs/api/java/util/Spliterator.html" rel="noopener ugc nofollow" target="_blank">Spliterator&lt;T&gt;</a></code>和<code class="fe lx ly lz ma b">Iterator&lt;T&gt;</code>都有<em class="lw">迭代</em>的概念，但它们的应用范围不同。</p><p id="5746" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><code class="fe lx ly lz ma b"><a class="ae kz" href="https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html" rel="noopener ugc nofollow" target="_blank">Iterator&lt;T&gt;</a></code>是从Java 1.2开始可用的一种通用的、非并行的迭代方式。它深深植根于<a class="ae kz" href="https://docs.oracle.com/javase/8/docs/technotes/guides/collections/overview.html" rel="noopener ugc nofollow" target="_blank"> Java集合框架</a>中。最有可能的是，我们中的许多人都有某种形式的关于<code class="fe lx ly lz ma b"><a class="ae kz" href="https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html" rel="noopener ugc nofollow" target="_blank">Iterator&lt;T&gt;</a></code>或相关<code class="fe lx ly lz ma b"><a class="ae kz" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Iterable.html" rel="noopener ugc nofollow" target="_blank">java.lang.Iterable&lt;T&gt;</a></code>的<em class="lw">实践</em>经验，用于并发修改，或者由于<a class="ae kz" href="https://betterprogramming.pub/how-to-iterate-with-java-56b0fd83bbfc#a9ce" rel="noopener ugc nofollow" target="_blank"> <em class="lw">增强for-loop </em> </a>。</p><p id="b126" class="pw-post-body-paragraph la lb it lc b ld le ju lf lg lh jx li lj lk ll lm ln lo lp lq lr ls lt lu lv im bi translated"><code class="fe lx ly lz ma b"><a class="ae kz" href="https://docs.oracle.com/javase/8/docs/api/java/util/Spliterator.html" rel="noopener ugc nofollow" target="_blank">Spliterator&lt;T&gt;</a></code>可用于迭代<a class="ae kz" href="https://docs.oracle.com/javase/8/docs/technotes/guides/collections/overview.html" rel="noopener ugc nofollow" target="_blank"> Java集合框架</a>类型，是<a class="ae kz" href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html" rel="noopener ugc nofollow" target="_blank">流API </a>的核心。如果底层数据允许，它还支持并行遍历。尽管它是Stream API如此重要的一部分，但它更多的是一种“后台”类型。我们只通过方便的方法使用它，或者使用JDK中已经存在的类型。</p></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><pre class="kk kl km kn gt pb ma qc bn qd qe bi"><span id="4996" class="qf mj it ma b be qg qh l ph pi"><strong class="ma iu">You like my ramblings about Java?<br/>Check out my upcoming book!</strong><br/><a class="ae kz" href="https://belief-driven-design.com/book/" rel="noopener ugc nofollow" target="_blank">https://belief-driven-design.com/book/</a></span></pre></div><div class="ab cl mb mc hx md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="im in io ip iq"><h1 id="0368" class="mi mj it bd mk ml mm mn mo mp mq mr ms jz mt ka mu kc mv kd mw kf mx kg my mz bi translated">资源</h1><ul class=""><li id="7587" class="og oh it lc b ld na lg nb lj qi ln qj lr qk lv ol om on oo bi translated"><a class="ae kz" href="http://docs.oracle.com/javase/8/docs/api/java/util/Spliterator.html" rel="noopener ugc nofollow" target="_blank">分割器</a>(甲骨文)</li><li id="df16" class="og oh it lc b ld op lg oq lj or ln os lr ot lv ol om on oo bi translated"><a class="ae kz" href="https://docs.oracle.com/javase/tutorial/collections/streams/parallelism.html" rel="noopener ugc nofollow" target="_blank"> Java教程并行</a>(甲骨文)</li><li id="6791" class="og oh it lc b ld op lg oq lj or ln os lr ot lv ol om on oo bi translated"><a class="ae kz" href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html" rel="noopener ugc nofollow" target="_blank"> Java流API </a>(甲骨文)</li><li id="118c" class="og oh it lc b ld op lg oq lj or ln os lr ot lv ol om on oo bi translated"><a class="ae kz" href="https://docs.oracle.com/javase/8/docs/technotes/guides/collections/overview.html" rel="noopener ugc nofollow" target="_blank"> Java集合框架</a>(甲骨文)</li><li id="c272" class="og oh it lc b ld op lg oq lj or ln os lr ot lv ol om on oo bi translated"><a class="ae kz" href="https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html" rel="noopener ugc nofollow" target="_blank">迭代器</a>(甲骨文)</li></ul><div class="pk pl gp gr pm pn"><a href="https://betterprogramming.pub/how-to-iterate-with-java-56b0fd83bbfc" rel="noopener  ugc nofollow" target="_blank"><div class="po ab fo"><div class="pp ab pq cl cj pr"><h2 class="bd iu gy z fp ps fr fs pt fu fw is bi translated">如何用Java正确迭代</h2><div class="pu l"><h3 class="bd b gy z fp ps fr fs pt fu fw dk translated">不仅仅是“for”和“while”</h3></div><div class="pv l"><p class="bd b dl z fp ps fr fs pt fu fw dk translated">better编程. pub</p></div></div><div class="pw l"><div class="ql l py pz qa pw qb kt pn"/></div></div></a></div></div></div>    
</body>
</html>