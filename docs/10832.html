<html>
<head>
<title>How to write concurrent Python code with multithreading</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用多线程编写并发Python代码</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-write-concurrent-python-code-with-multithreading-b24dec228c43?source=collection_archive---------0-----------------------#2022-01-16">https://levelup.gitconnected.com/how-to-write-concurrent-python-code-with-multithreading-b24dec228c43?source=collection_archive---------0-----------------------#2022-01-16</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="a7ca" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">提高应用程序的并发性</h2></div><p id="a2d2" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，将介绍Python中多线程的基础知识。我们将介绍进程、线程、全局解释器锁(GIL)、CPU绑定任务和IO绑定任务的概念。然后，我们将学习如何使用本机<code class="fe le lf lg lh b">threading.Thread</code>和更高级别的<code class="fe le lf lg lh b">concurrent.futures.ThreadPoolExecutor</code>创建多线程应用程序。我们还将介绍如何正确处理线程中出现的异常，这样程序就不会无声无息地失败。最后，我们将构建一个简单的带有队列和多线程的发布者/订阅者(Pub/Sub)异步消息传递系统，它结合了本文中介绍的多线程的所有高级特性。</p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="gh gi li"><img src="../Images/f704445e217296b41961028098d1de6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Q7xQDv01WO7Ae14z.jpg"/></div></div><figcaption class="lu lv gj gh gi lw lx bd b be z dk translated">图片来自<a class="ae ly" href="https://pixabay.com/photos/geese-flying-goose-glide-sail-4028227/" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>。</figcaption></figure></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><p id="d650" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">进程vs线程</strong>。</p><p id="5704" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这更像是一个普通的计算机科学问题，而不是Python问题。关于这个问题有<a class="ae ly" href="https://stackoverflow.com/questions/200469/what-is-the-difference-between-a-process-and-a-thread?page=1&amp;tab=votes#tab-top" rel="noopener ugc nofollow" target="_blank">个关于栈溢出的活跃讨论</a>。本质上，<strong class="kk iu">进程</strong>是程序的执行实例，提供执行程序所需的资源。一个程序可以同时运行多个进程。在这种情况下，程序被认为是并行运行的，可以利用机器上可用的多个CPU内核。同一程序的不同进程相互隔离。他们有隔离的资源，尤其是全局内存空间。</p><p id="a967" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一个<strong class="kk iu">线程</strong>也是一个独立的程序执行单元。线程是在进程的上下文中创建的，并且只能访问进程中可用的资源。每个进程都是由一个单独的线程创建的，这个线程被称为主线程。我们可以从同一个进程中创建多个线程，就像本教程中将要做的那样。这些源自同一进程的线程共享“父”进程的相同全局内存空间。然而，每个线程也可以有自己的线程本地存储，我们将在后面看到。应该注意的是，进程(主线程下)和显式创建的线程都不绑定到单个处理器或CPU内核。一个进程或线程可以跳过不同的内核，这种行为由操作系统通过一种叫做<a class="ae ly" href="https://en.wikipedia.org/wiki/Processor_affinity" rel="noopener ugc nofollow" target="_blank">处理器/线程关联</a>的机制来决定。在开始使用Python中的线程之前，您不需要理解所有的技术细节。如果你感兴趣或感到困惑，这里只是解释一下。</p><p id="c1fd" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">线程比进程更轻量级，因为线程是在进程内部创建的。此外，由于线程共享相同的全局内存空间，因此它们之间的通信更容易。另一方面，由于不同的进程具有隔离的内存空间，因此它们之间的通信要求更高。要在进程间共享的数据需要是可序列化的或可处理的，这是一个主要的限制，会给问题带来额外的开销和复杂性。然而，尽管有这些限制，多线程和多重处理都有它们自己的用例，这将在下面介绍。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><p id="493a" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> Python全局解释器锁(GIL) </strong>。</p><p id="7bc4" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">顾名思义，Python全局解释器锁(GIL)是Python解释器上的一个锁。由于一个进程只有一个解释器实例，所以在同一个进程中创建的所有线程共享同一个解释器。GIL限制只有一个线程可以控制公共Python解释器，这意味着在任何时间点只有一个线程可以处于执行状态。因此，有了GIL，用多线程完全并行执行程序是不可能的。然而，对于CPU受限的应用程序来说，GIL只是一个瓶颈，这些应用程序需要繁重的CPU计算，而不是(输入/输出)IO等待。对于IO绑定的应用程序，大部分时间都花在等待远程服务器的响应上，GIL不是一个限制。当一个线程被阻塞并等待来自文件、数据库或网页的响应时，另一个线程可以接管解释器的控制权并执行其代码。由于执行其他代码所花费的时间比IO等待时间少几个数量级，所以GIL的影响很小。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><p id="18c6" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> CPU受限的任务实例</strong>。</p><p id="520e" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们用简单的例子来看看GIL对CPU和IO相关任务的影响。让我们先来看看多线程是否能让CPU受限的计算更快:</p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="4c12" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">函数<code class="fe le lf lg lh b">cpu_bound_job</code>是一个受CPU限制的任务，因为它所做的只是纯粹的算术计算。没有IO正在等待此任务。当我们用单线程计算一个大数字时，需要15.14秒。如果你想得到一个相似的计算时间，你可能需要根据你的计算机的计算能力来改变这个数字。当我们把大的数拆分成较小的数，尝试用三个线程来做计算时，计算并不比单线程快。这意味着多线程不适用于CPU受限的任务，您不应该浪费时间尝试使用多线程来加速CPU受限的应用程序。相反，你应该尝试使用<a class="ae ly" href="https://docs.python.org/3/library/multiprocessing.html" rel="noopener ugc nofollow" target="_blank">多重处理</a>软件包。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><p id="b62b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu"> IO绑定任务示例</strong>。</p><p id="b492" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">受输入/输出(IO)限制的任务大部分时间都在等待。它们可能正在等待来自文件、数据库或web服务器的响应。现在我们将使用<code class="fe le lf lg lh b">time.sleep()</code>来模拟一个IO绑定的任务。稍后将使用<em class="mi">请求</em>模块来模拟更实际的用法。</p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="40e9" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这个简单的例子中，每个请求需要3秒钟才能完成。这是一个IO绑定的任务，因为它大部分时间都在等待(这里是休眠)。当我们用单线程发出三个请求时，用了9秒。当我们用三个线程发出三个请求，每个线程得到一个请求时，只需要三秒钟，这意味着IO绑定的任务确实与多线程并发运行。原因是当一个线程被阻塞时，解释器的控制权可以被另一个线程接管。这样，缓慢的IO步骤可以看似同时运行。当缓慢的IO步骤完成时，代码的其他部分将有机会再次运行。其他代码运行如此之快，以至于缓慢的IO步骤几乎同时开始和结束。</p><p id="9057" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">到目前为止，您应该很好地理解了为什么多线程适合IO绑定的任务，而不是CPU绑定的任务。现在我们将介绍更高级的多线程知识，这将有助于您的工作。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><p id="7db0" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">线程安全</strong>和<strong class="kk iu">线程本地存储</strong>。</p><p id="4f92" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你有Java的背景，你会非常熟悉“线程安全”的概念。虽然在Python中不太流行，但是如果您编写多线程代码，这个概念也适用。基本上，<a class="ae ly" href="https://en.wikipedia.org/wiki/Thread_safety" rel="noopener ugc nofollow" target="_blank">线程安全</a>意味着一个对象可以被多个线程安全地访问，没有<a class="ae ly" href="https://en.wikipedia.org/wiki/Race_condition" rel="noopener ugc nofollow" target="_blank">竞争条件</a>。线程安全代码意味着同一段代码可以由多个线程同时正确执行，不会出现意外行为。</p><p id="14f5" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Python中有一些对象不是线程安全的。一个例子是<em class="mi">请求</em>库的<code class="fe le lf lg lh b"><a class="ae ly" href="https://github.com/psf/requests/issues/2766" rel="noopener ugc nofollow" target="_blank">Session</a></code>对象。另一个常见的例子是<a class="ae ly" href="https://docs.sqlalchemy.org/en/13/orm/session_basics.html#is-the-session-thread-safe" rel="noopener ugc nofollow" target="_blank"> <em class="mi"> SQLAlchemy </em> </a>库的数据库连接和会话对象。在这种情况下，我们需要在由<code class="fe le lf lg lh b">threading.local()</code>表示的线程本地存储中存储它们的一个实例。</p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="mg mh l"/></div></figure><ul class=""><li id="7915" class="mj mk it kk b kl km ko kp kr ml kv mm kz mn ld mo mp mq mr bi translated">在前面的例子中，我们已经使用本地的<code class="fe le lf lg lh b">threading</code>模块显式地创建了一个线程。我们还可以使用来自<code class="fe le lf lg lh b">concurrent.futures</code>库的<code class="fe le lf lg lh b">ThreadPoolExecutor</code>类，这是在Python中创建线程化作业的更好方法。有了<code class="fe le lf lg lh b">ThreadPoolExecutor</code>，我们可以将线程的总数限制在一个固定的数字，这样我们就不会创建大量的线程并耗尽计算机的内存。此外，我们可以使用<code class="fe le lf lg lh b">ThreadPoolExecutor</code>作为上下文管理器，从而可以在线程任务完成时释放线程池。</li><li id="1040" class="mj mk it kk b kl ms ko mt kr mu kv mv kz mw ld mo mp mq mr bi translated">对于非线程安全的对象，我们需要为每个线程创建一个不同的实例。在这种情况下，<em class="mi"> requests </em>库的<code class="fe le lf lg lh b">Session</code>对象不是线程安全的，因此我们需要为每个线程创建一个新的实例。注意，神奇的<code class="fe le lf lg lh b">threading.local()</code>方法将返回单个线程可以访问的变量。这是保存一些临时数据的常用方法，这些数据应该只能由单个线程访问。</li></ul><p id="3065" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本例中，我们证实了多线程可以显著提高IO绑定任务的速度。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><p id="8961" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">如何处理线程中出现的异常</strong>？</p><p id="6a1c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我编写上面的脚本并在代码中犯了一些错别字时，错误不会显示出来，我们只会看到以下信息:</p><pre class="lj lk ll lm gt mx lh my mz aw na bi"><span id="6e47" class="nb nc it lh b gy nd ne l nf ng">IO-bound job finished in 0.00 seconds with one thread.<br/>IO-bound job finished in 0.00 seconds with ten threads.</span></pre><p id="6ecf" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你可以尝试在函数<code class="fe le lf lg lh b">io_bound_job</code>中引入一些错误，你会看到同样的结果。</p><p id="59ed" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是因为，默认情况下，线程中的错误会被隐藏，不会显示在主线程中。为了捕捉线程中的错误，您需要循环执行从executor返回的<em class="mi"> futures </em>。<a class="ae ly" href="https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Future" rel="noopener ugc nofollow" target="_blank"> <em class="mi"> future </em> </a>是一个对象，表示在一个线程中运行的目标函数的执行。</p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="mg mh l"/></div></figure><ul class=""><li id="b325" class="mj mk it kk b kl km ko kp kr ml kv mm kz mn ld mo mp mq mr bi translated">这一次，我们使用执行器的<code class="fe le lf lg lh b">submit</code>方法显式提交每个任务。使用<code class="fe le lf lg lh b">submit</code>方法的好处是返回一个<em class="mi"> future </em>对象，您可以稍后使用它来检查线程中执行的函数的结果。</li><li id="2d69" class="mj mk it kk b kl ms ko mt kr mu kv mv kz mw ld mo mp mq mr bi translated"><code class="fe le lf lg lh b">as_completed</code>函数返回已完成或取消的<em class="mi">期货</em>。</li><li id="dda5" class="mj mk it kk b kl ms ko mt kr mu kv mv kz mw ld mo mp mq mr bi translated"><code class="fe le lf lg lh b">result()</code>方法返回<em class="mi">未来</em>所代表的函数的结果。GCP的Pub/Sub也使用了<code class="fe le lf lg lh b">result()</code>方法来构建<a class="ae ly" href="https://medium.com/codex/how-to-use-google-pub-sub-to-build-an-asynchronous-messaging-system-in-python-3b43094627dc" rel="noopener">消息/队列系统</a>。</li><li id="cf15" class="mj mk it kk b kl ms ko mt kr mu kv mv kz mw ld mo mp mq mr bi translated">当循环通过<em class="mi">期货</em>时，如果线程中出现异常，它将被捕获，并可以更优雅地处理。</li></ul><p id="06ab" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，如果您试图在函数<code class="fe le lf lg lh b">io_bound_job</code>中引入任何错误，它总是会在<code class="fe le lf lg lh b">try/except</code>块中被捕获。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><p id="25ec" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="kk iu">用多线程构建发布者/订阅者系统</strong>。</p><p id="663b" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在最后一节中，我们将使用Python中的多线程构建自己的发布/订阅系统。如果你不熟悉GCP发布/订阅系统，你可能会对这篇介绍性文章感兴趣。在下面的例子中，我们将用上面学到的知识构建一个超级简单的发布/订阅系统。现在先让代码说话，然后我们来解释重点:</p><figure class="lj lk ll lm gt ln"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="e580" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">乍一看，这个脚本可能有点复杂。然而，一旦你理解了基本的逻辑，事情就简单了。</p><ol class=""><li id="bd85" class="mj mk it kk b kl km ko kp kr ml kv mm kz mn ld nh mp mq mr bi translated">我们使用一个<code class="fe le lf lg lh b">queue.Queue</code>来存储和获取结果。有了队列，我们不需要手动管理线程的<a class="ae ly" href="https://docs.python.org/3/library/threading.html#threading.Lock" rel="noopener ugc nofollow" target="_blank">锁</a>。如果您需要从线程发送/接收数据，这是推荐的方法。可以指定队列的最大大小。如果队列中的消息数量达到最大值，则无法发送新消息，发布者将被阻止。创建的队列作为位置参数发送给发布者和订阅者。</li><li id="9da1" class="mj mk it kk b kl ms ko mt kr mu kv mv kz mw ld nh mp mq mr bi translated">我们使用<code class="fe le lf lg lh b">threading.Event()</code>向用户发送终止信号。如果不希望订阅服务器永远运行，这是必要的。订阅者将运行以接收所有发布的消息，然后退出。请注意，在调用<code class="fe le lf lg lh b">event.set()</code>之前，我们必须<em class="mi">让</em>休眠足够的时间。否则，该程序将被阻止。原因是队列有一个最大大小设置，如果我们设置事件过早，让订阅者过早退出，我们将达到最大队列大小，发布者将被阻塞。</li><li id="87a9" class="mj mk it kk b kl ms ko mt kr mu kv mv kz mw ld nh mp mq mr bi translated">在订阅者中，如果没有设置事件信号并且队列不为空，我们将继续从队列中获取数据。有了这两个条件，我们就可以确保发布者发布的所有消息都能被接收到。订阅者的超时是针对没有消息发布的情况。如果没有设置超时，并且没有发布任何消息，订阅者将被阻止。</li></ol><p id="8729" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果您想构建一个本地分布式计算系统，这个用原生Python代码编写的发布/订阅系统会很有帮助。当一个数据库可以有多个读操作，但只允许一个写操作时，这种方法特别有用。在这种情况下，您可以启动多个发布者和一个订阅者，并充分利用您的系统。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><p id="487c" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">本文介绍了多线程的基础知识。我们已经介绍了进程、线程、全局解释器锁(GIL)、CPU绑定任务和IO绑定任务的概念。我们现在可以用原生的<code class="fe le lf lg lh b">threading.Thread</code>和更高级的<code class="fe le lf lg lh b">concurrent.futures.ThreadPoolExecutor</code>创建线程化的应用。我们还介绍了如何正确处理线程中出现的异常，这样程序就不会无声无息地失败。最后，我们构建了一个简单的带有队列和多线程的发布者/订阅者(Pub/Sub)异步消息传递系统，它结合了我们在本教程中介绍的多线程的所有高级特性。</p></div><div class="ab cl lz ma hx mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="im in io ip iq"><p id="7250" class="pw-post-body-paragraph ki kj it kk b kl km ju kn ko kp jx kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">相关文章:</p><ul class=""><li id="1ce8" class="mj mk it kk b kl km ko kp kr ml kv mm kz mn ld mo mp mq mr bi translated"><a class="ae ly" href="https://medium.com/codex/how-to-debug-python-scripts-and-api-code-in-the-console-and-in-vs-code-a0b825ad7d41?source=your_stories_page----------------------------------------" rel="noopener">如何在控制台和VS代码中调试Python脚本和API代码</a></li></ul></div></div>    
</body>
</html>