<html>
<head>
<title>Protecting Against XSS Attacks in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在React中防范XSS攻击</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/protecting-against-xss-attacks-in-react-52442d9fff4c?source=collection_archive---------3-----------------------#2020-07-13">https://levelup.gitconnected.com/protecting-against-xss-attacks-in-react-52442d9fff4c?source=collection_archive---------3-----------------------#2020-07-13</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/3deefb01ab2bc403b6ae9d95aced57e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xRp6LBhYju13qich"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">迈克尔·盖革在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="4497" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">跨站脚本(XSS)攻击是一种将恶意代码注入网页并执行的攻击。这是前端web开发人员必须处理的最常见的网络攻击形式之一，因此了解攻击的工作原理以及如何防范它非常重要。</p><p id="3007" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将查看一些用React编写的代码示例，这样您也可以保护您的站点和用户。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="421a" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">示例React中成功的XSS攻击</h1><p id="3510" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">对于我们所有的例子，我们将实现相同的基本功能。我们将在页面上有一个搜索框，用户可以输入文本。点击“Go”按钮将模拟运行搜索，然后一些确认文本将显示在屏幕上，向用户重复他们搜索的术语。对于任何允许你搜索的网站来说，这都是非常标准的行为。</p><figure class="mp mq mr ms gt ju gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/c17495013f5a6fe5724741675af5cb11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1312/format:webp/1*OidBTVx6UZV1OHPcvzX7iw.png"/></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">搜索演示</figcaption></figure><p id="7bb3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">很简单，对吧？什么会出错？</p><p id="1008" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么，如果我们在搜索框中输入一些HTML呢？让我们试试下面的片段:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="0bc4" class="my lm it mu b gy mz na l nb nc">&lt;img src="1" onerror="alert('Gotcha!')" /&gt;</span></pre><p id="43c8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在发生了什么？</p><figure class="mp mq mr ms gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nd"><img src="../Images/9e8be09f7b8d9b5d17440bfae7be0aa2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mShPmL3hzWzK1IY2jYkOgQ.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">XSS攻击被执行</figcaption></figure><p id="256a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">哇，<code class="fe ne nf ng mu b">onerror</code>事件处理程序被执行了！这不是我们想要的。我们只是无意中执行了一个来自不可信用户输入的脚本。</p><figure class="mp mq mr ms gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nh"><img src="../Images/3075187f680d2afebc0d8e2d95206c6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FW_wPCwe_YLizXkXqDuR8w.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">残破的图像被渲染</figcaption></figure><p id="75c5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后在页面上呈现这个破碎的图像。这也不是我们想要的。</p><p id="753f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么我们是怎么到这里的呢？在本例中，在呈现搜索结果的JSX中，我们使用了以下代码:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="acf3" class="my lm it mu b gy mz na l nb nc">&lt;p style={searchResultsStyle}&gt;You searched for: &lt;b&gt;&lt;span dangerouslySetInnerHTML={{ __html: this.state.submittedSearch }} /&gt;&lt;/b&gt;&lt;/p&gt;</span></pre><p id="00d4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">用户输入被解析和呈现的原因是因为我们使用了<code class="fe ne nf ng mu b">dangerouslySetInnerHTML</code>属性，这是React中的一个特性，它的工作方式就像本地的<code class="fe ne nf ng mu b">innerHTML</code>浏览器API，由于这个原因，它通常被认为是不安全的。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="e441" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">示例React中失败的XSS攻击</h1><p id="e982" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">现在让我们来看一个成功抵御XSS攻击的示例。这里的修复非常简单。为了安全地呈现用户输入，我们不应该使用<code class="fe ne nf ng mu b">dangerouslySetInnerHTML</code>属性。相反，让我们像这样编写输出代码:</p><pre class="mp mq mr ms gt mt mu mv mw aw mx bi"><span id="042e" class="my lm it mu b gy mz na l nb nc">&lt;p style={searchResultsStyle}&gt;You searched for: &lt;b&gt;{this.state.submittedSearch}&lt;/b&gt;&lt;/p&gt;</span></pre><p id="409a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们将输入相同的输入，但这一次，输出如下:</p><figure class="mp mq mr ms gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi ni"><img src="../Images/80cc979ec50647154999c3db0e4fbb7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ciqu59ReEI7985rfhk-3uw.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">XSS的进攻被阻止了</figcaption></figure><p id="5084" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不错！用户输入仅作为文本呈现在屏幕上。威胁解除。</p><p id="3358" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是个好消息！默认情况下，React将对其呈现的内容进行转义，将所有数据视为文本字符串。这相当于使用原生的<code class="fe ne nf ng mu b">textContent</code>浏览器API。</p></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="0656" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">示例3:净化React中的HTML内容</h1><p id="77ef" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">所以，这里的建议似乎很简单。只是不要在你的React代码中使用<code class="fe ne nf ng mu b">dangerouslySetInnerHTML</code>，你就成功了。但是，如果您发现自己需要使用这个特性，该怎么办呢？</p><p id="4c01" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，您可能正在从Drupal这样的内容管理系统(CMS)中获取内容，其中一些内容包含标记。(顺便说一句，我可能建议首先不要在你的文本内容和来自CMS的翻译中包含标记，但是对于这个例子，我们将假设你已经被否决了，包含标记的内容仍然存在。)</p><p id="f32f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在这种情况下，您<em class="nj">确实</em>想要解析HTML并将其呈现在页面上。那么，如何安全地做到这一点呢？</p><p id="58a1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">答案是在渲染之前净化你的HTML。相反，您将通过一个函数运行内容，在呈现之前去除任何潜在的恶意代码，而不是完全避开HTML。</p><p id="250e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有许多好的HTML清理库可供您使用。与任何网络安全相关的东西一样，最好不要自己写这些东西。外面有比你聪明得多的人，有好人也有坏人，他们比你考虑得更多。始终采用久经考验的解决方案。</p><p id="e49c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我最喜欢的净化库之一叫做<code class="fe ne nf ng mu b"><a class="ae kf" href="https://www.npmjs.com/package/sanitize-html" rel="noopener ugc nofollow" target="_blank">sanitize-html</a></code>，它确实如其名所示。你从一些肮脏的HTML开始，通过一个函数运行它，然后你得到一些漂亮、干净、安全的HTML作为输出。如果您想要比默认设置提供更多的控制，您甚至可以自定义允许哪些HTML标记和属性。</p><p id="7183" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="nj">更新:我推荐一个更小的库</em> <code class="fe ne nf ng mu b"><a class="ae kf" href="https://www.npmjs.com/package/dompurify" rel="noopener ugc nofollow" target="_blank"><em class="nj">dompurify</em></a></code> <em class="nj">。它的缩小和gzip大小只有</em><a class="ae kf" href="https://bundlephobia.com/result?p=dompurify@2.2.2" rel="noopener ugc nofollow" target="_blank"><em class="nj">6.4 kB</em></a><em class="nj">，与</em><code class="fe ne nf ng mu b"><em class="nj">sanitize-html</em></code><em class="nj"/><a class="ae kf" href="https://bundlephobia.com/result?p=sanitize-html@2.1.2" rel="noopener ugc nofollow" target="_blank"><em class="nj">的49.7 kB </em> </a> <em class="nj">形成对比。API遵循相同的格式，使用您可以自定义的选项获取脏输入并返回净化的输出。</em></p><figure class="mp mq mr ms gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi nk"><img src="../Images/bbbdb9a7ffbde32e551b89c19ed1f48d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w25gn_IbiT64GqAas08O5A.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">净化你的HTML</figcaption></figure></div><div class="ab cl le lf hx lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="im in io ip iq"><h1 id="e57d" class="ll lm it bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">结论</h1><p id="d386" class="pw-post-body-paragraph kg kh it ki b kj mj kl km kn mk kp kq kr ml kt ku kv mm kx ky kz mn lb lc ld im bi translated">这就是了。XSS攻击是如何执行的，如何防止它们，以及如何在必要时安全地解析HTML内容。祝您编码愉快，并祝您安全！</p><p id="dbfa" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="nj">完整的代码示例可以在GitHub </em>  <em class="nj">上找到</em> <a class="ae kf" href="https://github.com/thawkin3/xss-demo" rel="noopener ugc nofollow" target="_blank"> <em class="nj">。</em></a></p></div></div>    
</body>
</html>