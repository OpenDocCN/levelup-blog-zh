<html>
<head>
<title>RabbitMQ with Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Java的RabbitMQ</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/rabbitmq-with-java-fe4390be6e87?source=collection_archive---------17-----------------------#2022-07-11">https://levelup.gitconnected.com/rabbitmq-with-java-fe4390be6e87?source=collection_archive---------17-----------------------#2022-07-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="cc89" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有两种不同的通信方式，即同步和异步通信。今天我想讨论异步通信以及它与RabbitMQ的关系(在这篇文章的其余部分，我将使用MQ)。此外，我将提供一些代码。</p><p id="7816" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Mq是一个开源的分布式消息代理，它使用高级消息队列协议(AMQP)协议，该协议是用于面向消息的中间件的<a class="ae kl" href="https://en.wikipedia.org/wiki/Open_standard" rel="noopener ugc nofollow" target="_blank">开放标准</a> <a class="ae kl" href="https://en.wikipedia.org/wiki/Application_layer" rel="noopener ugc nofollow" target="_blank">应用层</a>协议。AMQP的定义特征是消息定向、排队、<a class="ae kl" href="https://en.wikipedia.org/wiki/Routing" rel="noopener ugc nofollow" target="_blank">路由</a>(包括<a class="ae kl" href="https://en.wikipedia.org/wiki/Point-to-point_(telecommunications)" rel="noopener ugc nofollow" target="_blank">点对点</a>和<a class="ae kl" href="https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe" rel="noopener ugc nofollow" target="_blank">发布-订阅</a>)、可靠性和安全性。</p><p id="6e38" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在不同的服务中，我们将它用于不同的目的。比如发送不需要同步的邮件，在一些微服务进程之间进行管理。我们的一些电子邮件和通知并不需要立即发送。这就是为什么我们在这里使用Mq，对我们的请求进行排队，当服务可用时，就执行并发送它们。</p><p id="cb91" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">出于某些特定的原因，比如POST、UPDATE和DELETE进程，我们更喜欢使用Mq在服务之间进行通信。因为我们不希望受到我们正在处理的任何其他服务问题的影响。因此，我们将通过每个服务自己的流程来管理每个服务的问题和责任。</p><p id="a12e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用Mq为我们提供了一些好处，例如:</p><ul class=""><li id="14f3" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk kr ks kt ku bi translated">节省我们的时间</li><li id="8a21" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">提高服务绩效</li><li id="a8a9" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">减少依赖性及其相关问题</li><li id="8b94" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">分离责任</li></ul><p id="bc43" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不幸的是，Mq不是一颗银弹，它有一些我们面临的缺点；</p><ul class=""><li id="285f" class="km kn iq jp b jq jr ju jv jy ko kc kp kg kq kk kr ks kt ku bi translated">当处理成千上万的数据时，速度很慢，需要时间。</li><li id="d1cf" class="km kn iq jp b jq kv ju kw jy kx kc ky kg kz kk kr ks kt ku bi translated">无法将队列中的部分消息移动到目标队列。移动邮件时，所有邮件都会被移动。我希望我们能设法发送一部分。</li></ul><figure class="lb lc ld le gt lf gh gi paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="gh gi la"><img src="../Images/93d449e497f947c8f3552e21d4c039c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HL7O9RiveKcZ5poaHglz7Q.png"/></div></div></figure><p id="2b9b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在跳过代码细节之前，我还想添加我们使用的模型结构。</p><p id="10c8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">模型简介；</p><figure class="lb lc ld le gt lf gh gi paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="gh gi lm"><img src="../Images/fcf8f784f058321f61986aa8f6c31b92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NT4RokwXQTrhDBlN3OIqPw.png"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk translated">图片来源:<a class="ae kl" href="https://www.rabbitmq.com/tutorials/amqp-concepts.html" rel="noopener ugc nofollow" target="_blank">https://www.rabbitmq.com/tutorials/amqp-concepts.html</a></figcaption></figure><p id="7178" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里有两个部分——发布者和消费者。我们将发布者和消费者分开，他们通常位于不同的服务上。这就是为什么我在这里把这篇文章分成两部分。但是有些设置对于依赖关系和application.yml配置这两个部分是必需的。</p><p id="1ac5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我用的是spring-boot-starter-amqp的2.6.6版本:</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="9af3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后将Mq配置添加到我的application.yml</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="lr ls l"/></div></figure><h1 id="5e59" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">出版者</h1><p id="3f87" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk ij bi translated">我们只在publisher中配置交换部分，然后发送消息。</p><p id="eda3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我如下配置了Mq EXCHANGE。</p><p id="5b29" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意，我在这里使用了TopicExchange。我从<a class="ae kl" href="https://www.rabbitmq.com/tutorials/amqp-concepts.html" rel="noopener ugc nofollow" target="_blank"> RabbitMq </a>地址引用的TopicExchange定义是；</p><blockquote class="mw"><p id="9c65" class="mx my iq bd mz na nb nc nd ne nf kk dk translated">主题交换基于消息路由关键字和用于将队列绑定到交换的模式之间的匹配，将消息路由到一个或多个队列。主题交换类型通常用于实现各种发布/订阅模式变体。主题交换通常用于消息的多播路由。</p></blockquote><p id="ce9e" class="pw-post-body-paragraph jn jo iq jp b jq ng js jt ju nh jw jx jy ni ka kb kc nj ke kf kg nk ki kj kk ij bi translated">如果你想学习其他的交换类型，请点击<a class="ae kl" href="https://www.rabbitmq.com/tutorials/amqp-concepts.html#exchanges" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="7d8e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">配置之后，现在我准备好将我的消息发布到该队列的交换中。为此，我使用了<strong class="jp ir"> <em class="nl"> convertAndSend() </em> </strong>方法。</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="lr ls l"/></div></figure><h1 id="4897" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated"><strong class="ak">消费者</strong></h1><p id="e34e" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk ij bi translated">现在，我为消费者部分配置了队列配置。</p><p id="af04" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我用队列、交换和死信队列定义配置了Mq。</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="719a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">代码差不多准备好了。现在只差一步了。我还需要一个侦听器方法，我可以消费发布的消息。</p><p id="dbe3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> @RabbitListener </strong>应该用必需的参数添加到方法的顶部。</p><p id="dbd5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意您的发布者和消费者对象应该是相同的。</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="52a7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">代码已经完全准备好了。</p><p id="a199" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，您可以找到我为上面的类编写的测试类。</p><p id="527a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">RabbitMqConfigurationTest</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="cf61" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里是EnqueueService类测试；</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="5371" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在下一篇文章中，我将分享另一个异步通信的例子，它是基于发布-订阅流/消息的Kafka。</p><p id="b803" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">希望有帮助，</p><p id="ca15" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">感谢阅读…</p><p id="6762" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">参考资料:</p><div class="nm nn gp gr no np"><a href="https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol" rel="noopener  ugc nofollow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd ir gy z fp nu fr fs nv fu fw ip bi translated">高级消息队列协议-维基百科</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">高级消息队列协议(AMQP)是面向消息的开放标准应用层协议</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">en.wikipedia.org</p></div></div><div class="ny l"><div class="nz l oa ob oc ny od lk np"/></div></div></a></div><div class="nm nn gp gr no np"><a href="https://www.rabbitmq.com/tutorials/amqp-concepts.html" rel="noopener  ugc nofollow" target="_blank"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd ir gy z fp nu fr fs nv fu fw ip bi translated">AMQP 0-9-1模型解释</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">本指南概述了AMQP 0-9-1协议，这是RabbitMQ支持的协议之一。AMQP 0-9-1…</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">www.rabbitmq.com</p></div></div><div class="ny l"><div class="oe l oa ob oc ny od lk np"/></div></div></a></div></div></div>    
</body>
</html>