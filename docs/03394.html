<html>
<head>
<title>JavaScript Features You Probably Haven’t Used</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">您可能没有用过的JavaScript特性</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-features-we-probably-havent-used-adc4ca6711b5?source=collection_archive---------0-----------------------#2020-05-06">https://levelup.gitconnected.com/javascript-features-we-probably-havent-used-adc4ca6711b5?source=collection_archive---------0-----------------------#2020-05-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/fedf81da2e8ab0404b58a6f0ac2aba4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5iY45d53bI6WHc83"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">杰森·哈弗索在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="e6da" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">JavaScript有很多经常使用的特性。然而，也有一些功能可能我们大多数人都没有用过。</p><p id="393f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将研究其中的一些特性以及它们可能的用例。</p><h1 id="52e6" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">标记的模板文字</h1><p id="a2d4" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">标记模板文字是处理模板字符串的函数。</p><p id="58c0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它们经常在React库中使用，如<code class="fe mh mi mj mk b">style-components</code>库。这个功能其实很有用。</p><p id="749c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它让我们以一种简单的方式解析模板字符串。它让我们用函数解析模板文字。</p><p id="05fb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以如下使用它:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="5142" class="mt lf it mk b gy mu mv l mw mx">const tag = (strings, ...vals) =&gt; {<br/>  console.log(strings);<br/>  console.log(vals);<br/>}</span><span id="f6b6" class="mt lf it mk b gy my mv l mw mx">const name = 'foo';<br/>tag `Hi ${name}`;</span></pre><p id="bc81" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们有<code class="fe mh mi mj mk b">tag</code>函数和<code class="fe mh mi mj mk b">vals</code>数组，前者有包含字符串片段的<code class="fe mh mi mj mk b">strings</code>函数，后者有插入到字符串中的值。</p><p id="bde5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的例子中，我们有一个带有<code class="fe mh mi mj mk b">'Hi'</code>的数组，并且<code class="fe mh mi mj mk b">''</code>是<code class="fe mh mi mj mk b">strings</code>的值。</p><p id="679a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<code class="fe mh mi mj mk b">vals</code>数组中，我们有<code class="fe mh mi mj mk b">'foo'</code>。</p><p id="6b14" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以用它来返回一个我们想要返回的对象。例如，我们可以将<code class="fe mh mi mj mk b">tag</code>函数重写如下:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="ade1" class="mt lf it mk b gy mu mv l mw mx">const tag = (strings, ...vals) =&gt; {<br/>  return `${strings[0]}! ${vals[0]}`<br/>}</span></pre><p id="9e99" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们从<code class="fe mh mi mj mk b">strings</code>和<code class="fe mh mi mj mk b">vals</code>中获取字符串的各个部分，并在两个表达式之间放置一个<code class="fe mh mi mj mk b">!</code>。</p><p id="3214" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们从返回值中得到<code class="fe mh mi mj mk b">Hi ! foo</code>。</p><h1 id="5f2d" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">逗点算符</h1><p id="97b8" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">逗号运算符总是返回由逗号运算符分隔的项目列表中的最后一个项目。</p><p id="0c5c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以如下使用它:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="8b1e" class="mt lf it mk b gy mu mv l mw mx">const foo = (1, 2, 3);</span></pre><p id="fd71" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么我们得到3。</p><p id="9de3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它可以接受任何表达式，并且总是返回最后一个计算的表达式。</p><h1 id="c58a" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">随着</h1><p id="215d" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mh mi mj mk b">with</code>操作符绝对是我们不应该使用的。在严格模式下是禁止的。</p><p id="8a3e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个操作符在语言中增加了一些性能和安全问题。它用于扩展语句的作用域链。</p><p id="f9cc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它的用法如下:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="4baf" class="mt lf it mk b gy mu mv l mw mx">with(expression)<br/>  statement</span></pre><p id="9a18" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">或者:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="7e51" class="mt lf it mk b gy mu mv l mw mx">with(expression) {<br/> statement<br/> statement<br/>  ...<br/>}</span></pre><p id="b004" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们在<code class="fe mh mi mj mk b">expression</code>周围创建了一个新的范围。</p><p id="1167" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">块内的所有<code class="fe mh mi mj mk b">statements</code>都将<code class="fe mh mi mj mk b">expression</code>作为父作用域。</p><p id="e459" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以如下使用它:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="911a" class="mt lf it mk b gy mu mv l mw mx">const obj = {<br/>  a: 1,<br/>  b: 2,<br/>  c: 3<br/>}<br/>with(obj) {<br/>  console.log(a, b, c);<br/>}</span></pre><p id="0891" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，<code class="fe mh mi mj mk b">with</code>块中的表达式的作用域都是相对于<code class="fe mh mi mj mk b">obj</code>对象的。</p><p id="f085" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以<code class="fe mh mi mj mk b">a</code>、<code class="fe mh mi mj mk b">b</code>、<code class="fe mh mi mj mk b">c</code>其实就是<code class="fe mh mi mj mk b">obj.a</code>、<code class="fe mh mi mj mk b">obj.b</code>、<code class="fe mh mi mj mk b">obj.c</code>。</p><p id="2e38" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">块范围的变量在<code class="fe mh mi mj mk b">with</code>块之外不可用，就像任何其他块范围的变量一样。</p><p id="f6fc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="a71f" class="mt lf it mk b gy mu mv l mw mx">const obj = {<br/>  a: 1,<br/>  b: 2,<br/>  c: 3<br/>}<br/>with(obj) {<br/>  console.log(a, b, c);<br/>  let x = 1;<br/>}</span><span id="66f2" class="mt lf it mk b gy my mv l mw mx">console.log(x);</span></pre><p id="dce9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，如果我们试图在<code class="fe mh mi mj mk b">with</code>块之外引用<code class="fe mh mi mj mk b">x</code>，如果我们试图在<code class="fe mh mi mj mk b">x</code>上调用<code class="fe mh mi mj mk b">console.log</code>，我们会得到一个错误。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/6c057739df8e8754e2417f3998c12adb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DrGecPli3BSgINxl"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">杰里米·斯图尔特在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="40be" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated"><code class="fe mh mi mj mk b">in</code></h1><p id="d86b" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mh mi mj mk b">in</code>操作符对于检查一个属性是对象的一部分还是原型链上的任何一个原型都很有用。</p><p id="daec" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果属性在对象或原型链上的任何属性中，它将返回<code class="fe mh mi mj mk b">true</code>，否则返回<code class="fe mh mi mj mk b">false</code>。</p><p id="cd93" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有下面的类结构和对象:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="f657" class="mt lf it mk b gy mu mv l mw mx">class Foo {<br/>  constructor() {<br/>    this.a = 1;<br/>  }<br/>}</span><span id="0a84" class="mt lf it mk b gy my mv l mw mx">class Bar extends Foo {<br/>  constructor() {<br/>    super();<br/>    this.b = 2;<br/>    this.c = 3;<br/>  }<br/>}</span><span id="0098" class="mt lf it mk b gy my mv l mw mx">const bar = new Bar();</span></pre><p id="8fd1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，如果我们记录以下表达式的返回值:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="ee8d" class="mt lf it mk b gy mu mv l mw mx">console.log('a' in bar);<br/>console.log('b' in bar);<br/>console.log('c' in bar);</span></pre><p id="c35f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们得到所有日志<code class="fe mh mi mj mk b">true</code>。</p><p id="fb0b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是因为<code class="fe mh mi mj mk b">bar</code>有一个<code class="fe mh mi mj mk b">Foo</code>实例作为其原型，而<code class="fe mh mi mj mk b">in</code>操作符检查对象本身及其原型的属性。</p><p id="d02a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，<code class="fe mh mi mj mk b">a in bar</code>也就是<code class="fe mh mi mj mk b">true</code>。如果我们只想检查属性是否为非继承属性，那么我们必须使用<code class="fe mh mi mj mk b">obj.hasOwnProperty</code>方法，其中<code class="fe mh mi mj mk b">obj</code>是任何没有<code class="fe mh mi mj mk b">null</code>原型的JavaScript对象。</p><h1 id="7adf" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="0e52" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">带标签的模板文字对于将模板字符串转换成我们想要的值很有用。</p><p id="31b4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">逗号运算符总是返回逗号分隔列表中的最后一项。</p><p id="b806" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">操作符检查一个属性是在一个对象中还是在它的原型中。</p><p id="b068" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">with</code>是JavaScript代码中不应该有的东西。</p></div></div>    
</body>
</html>