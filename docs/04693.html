<html>
<head>
<title>JavaScript Problems — require, Group Array Items, Classes, and More</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript问题—要求、分组数组项、类等等</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-problems-require-group-array-items-classes-and-more-d3a6269f6cd3?source=collection_archive---------22-----------------------#2020-07-09">https://levelup.gitconnected.com/javascript-problems-require-group-array-items-classes-and-more-d3a6269f6cd3?source=collection_archive---------22-----------------------#2020-07-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/c98bc83e52f632d93cdfbea381cc2aac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GTotwTGO5NylPvHf"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@dragos126?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Dragos Gontariu </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="daba" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">像任何类型的应用程序一样，当我们编写JavaScript应用程序时，有一些困难的问题需要解决。</p><p id="96a1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将研究一些常见JavaScript问题的解决方案。</p><h1 id="dd65" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">要求的目的</h1><p id="ff18" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">不是标准API的一部分。</p><p id="90f9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它用于从Node.js中的其他模块导入成员。</p><p id="5f8f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">模块是一种将应用程序分割成单独文件的方式，而不是将所有应用程序放在一个文件中。</p><p id="991c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">浏览器和节点应用程序的结构是不同的。</p><p id="72df" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">浏览器应用程序是从脚本标签加载的。</p><p id="4ec7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">脚本可以直接访问全局名称空间。</p><p id="5d66" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在节点应用程序中，每个模块都有自己的作用域。除非使用<code class="fe mh mi mj mk b">modulee.exports</code>或<code class="fe mh mi mj mk b">exports</code>导出并且是必需的，否则不能访问中的成员。</p><p id="7d4a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了导入模块，我们使用了<code class="fe mh mi mj mk b">require</code>函数。</p><p id="745e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以从自己的应用程序中获取模块，或者从节点包中获取。</p><p id="0b97" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">大多数节点软件包是从NPM安装的。</p><p id="a296" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这些包在<code class="fe mh mi mj mk b">node_modules</code>文件夹里。</p><h1 id="8ff3" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">检查对象是否为空</h1><p id="565f" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">有几种方法可以检查对象是否为空。</p><p id="97ba" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="e01a" class="mt lf it mk b gy mu mv l mw mx">obj === null</span></pre><p id="1f14" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">检查对象是否为<code class="fe mh mi mj mk b">null</code>。</p><p id="71cc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们也可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="616f" class="mt lf it mk b gy mu mv l mw mx">typeof obj !== 'object'</span></pre><p id="17ed" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">检查<code class="fe mh mi mj mk b">obj</code>是否不是一个对象。</p><p id="6c96" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，我们可以使用<code class="fe mh mi mj mk b">getOwnPropertyNames</code>以数组的形式获取对象的非继承字符串属性名。</p><p id="1108" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="3a57" class="mt lf it mk b gy mu mv l mw mx">Object.getOwnPropertyNames(obj).length === 0</span></pre><p id="f144" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">检查返回的数组是否为空。</p><p id="211b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，我们可以使用<code class="fe mh mi mj mk b">Object.keys</code>来做同样的事情:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="e1db" class="mt lf it mk b gy mu mv l mw mx">Object.<!-- -->keys<!-- -->(obj).length === 0</span></pre><h1 id="25fa" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">按键对对象数组进行分组</h1><p id="7131" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以通过将数组条目的值作为新对象的键，按键对对象数组进行分组。</p><p id="0df1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们从属性中获取数组条目，属性的值在中，给定的键在对象中。</p><p id="2d65" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="76e9" class="mt lf it mk b gy mu mv l mw mx">const groupBy = (items, key) =&gt; items.reduce(<br/>  (result, item) =&gt; ({<br/>    ...result,<br/>    [item[key]]: [<br/>      ...(result[item[key]] || []),<br/>      item,<br/>    ],<br/>  }), <br/>  {},<br/>);</span></pre><p id="576a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在我们有了下面的数组:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="6f92" class="mt lf it mk b gy mu mv l mw mx">const arr = [{<br/>    foo: 'dog',<br/>    bar: 2<br/>  },<br/>  {<br/>    foo: 'cat',<br/>    bar: 2<br/>  },<br/>  {<br/>    foo: 'dog',<br/>    bar: 3<br/>  },<br/>  {<br/>    foo: 'cat',<br/>    bar: 4<br/>  },<br/>]</span></pre><p id="e3ea" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以通过编写来调用<code class="fe mh mi mj mk b">groupBy</code>方法:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="52a4" class="mt lf it mk b gy mu mv l mw mx">const result = groupBy(arr, 'foo');</span></pre><p id="8d90" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么<code class="fe mh mi mj mk b">result</code>将是:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="0de6" class="mt lf it mk b gy mu mv l mw mx">{<br/>  "dog": [<br/>    {<br/>      "foo": "dog",<br/>      "bar": 2<br/>    },<br/>    {<br/>      "foo": "dog",<br/>      "bar": 3<br/>    }<br/>  ],<br/>  "cat": [<br/>    {<br/>      "foo": "cat",<br/>      "bar": 2<br/>    },<br/>    {<br/>      "foo": "cat",<br/>      "bar": 4<br/>    }<br/>  ]<br/>}</span></pre><p id="f1e1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们按照<code class="fe mh mi mj mk b">foo</code>属性对数组进行了分组。</p><p id="d8a7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">并且每个键的值是具有由该键给出的值为<code class="fe mh mi mj mk b">foo</code>的条目的数组。</p><h1 id="91a1" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">用多个分隔符拆分字符串</h1><p id="65ba" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以使用带有所有分隔符的regex的<code class="fe mh mi mj mk b">split</code>方法，通过所有列出的分隔符来分割一个字符串。</p><p id="5ba6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="3ba6" class="mt lf it mk b gy mu mv l mw mx">"foo bar, baz".split(/[\s,]+/)</span></pre><p id="a40c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们得到:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="49a2" class="mt lf it mk b gy mu mv l mw mx">["foo", "bar", "baz"]</span></pre><p id="f8d6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为正则表达式中有空白模式和逗号。</p><h1 id="43de" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">类方法和类原型方法之间的区别</h1><p id="34b9" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">以下两者之间存在差异:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="84ce" class="mt lf it mk b gy mu mv l mw mx">Class.method = function () { <br/>  //...<br/>}</span></pre><p id="3600" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">并且:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="65b1" class="mt lf it mk b gy mu mv l mw mx">Class.prototype.method = function () {<br/>  //...<br/>}</span></pre><p id="f9e4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">Class.method</code>表示<code class="fe mh mi mj mk b">method</code>方法是<code class="fe mh mi mj mk b">Class</code>的静态方法。</p><p id="b1b3" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以我们可以直接调用它，而不用创建它的新实例。</p><p id="d838" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="520d" class="mt lf it mk b gy mu mv l mw mx">Class.method();</span></pre><p id="06eb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一方面，<code class="fe mh mi mj mk b">Class.prototype.method</code>是<code class="fe mh mi mj mk b">Class</code>的一个实例方法。</p><p id="00c4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这意味着我们必须创建一个<code class="fe mh mi mj mk b">Class</code>的实例来使用它。</p><p id="86fd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="d893" class="mt lf it mk b gy mu mv l mw mx">const obj = new Class();</span></pre><p id="90c6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们通过写来调用<code class="fe mh mi mj mk b">Class.prototype.method</code>:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="5842" class="mt lf it mk b gy mu mv l mw mx">obj.method();</span></pre><h1 id="3ff2" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">从文件名中获取文件扩展名</h1><p id="999d" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">如果我们有一个文件名字符串，我们可以调用<code class="fe mh mi mj mk b">split</code>将文件名除以点号来得到文件名和扩展名。</p><p id="2f1e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">返回数组的最后一项是扩展名。</p><p id="170c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以我们可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="81f1" class="mt lf it mk b gy mu mv l mw mx">const ext = <!-- -->filename.split('.').pop();</span></pre><p id="2cc8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们调用<code class="fe mh mi mj mk b">pop</code>返回由<code class="fe mh mi mj mk b">split</code>返回的数组的最后一个条目来获得扩展。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi my"><img src="../Images/f63b45aa4f841b0c1de8f66e4b1a5966.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MqbGzKso-UOvY8j1"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@davidclode?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> David Clode </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="5508" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="032b" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以通过使用<code class="fe mh mi mj mk b">split</code>从文件名中获取文件扩展名。</p><p id="4363" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">附加到<code class="fe mh mi mj mk b">prototype</code>的方法和直接附加到类的方法是有区别的。</p><p id="3112" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过使用数组方法，我们可以根据条目的键值对数组条目进行分组。</p></div></div>    
</body>
</html>