<html>
<head>
<title>type-only imports — A new TypeScript feature that benefits Babel users</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">纯类型导入——一个新的TypeScript特性，对Babel用户有益</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/improving-babel-support-for-typescript-with-type-only-imports-28cb209d9460?source=collection_archive---------1-----------------------#2020-03-08">https://levelup.gitconnected.com/improving-babel-support-for-typescript-with-type-only-imports-28cb209d9460?source=collection_archive---------1-----------------------#2020-03-08</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div class="gh gi jq"><img src="../Images/8d33fb5b9d933acd44d6a3d581fab44a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1294/format:webp/1*YgkEs1_TKDaBvlfmp6qH_Q.png"/></div><figcaption class="jx jy gj gh gi jz ka bd b be z dk translated">巴别塔技术架构图</figcaption></figure><p id="37e9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">您已经决定使用Babel并用TypeScript编写您的源代码。但是当你跨模块边界共享TS类型时会发生什么呢？巴别塔应该如何处理那些进出口？</p><p id="a9d9" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们简单介绍一下Babel和TypeScript是如何协同工作的。</p><p id="175c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">TypeScript做两件事:</p><ol class=""><li id="b1ac" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky le lf lg lh bi translated">将静态类型检查添加到传统上作为JavaScript编写的代码中。</li><li id="d83d" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky le lf lg lh bi translated">将TS+JS代码转换成各种JS风格。</li></ol><p id="cf17" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">巴别塔<em class="ln">也</em>做第二件事。Babel的方法(特别是<a class="ae lo" href="https://babeljs.io/docs/en/babel-plugin-transform-typescript" rel="noopener ugc nofollow" target="_blank"> transform-typescript </a>插件)是简单地删除类型，然后转换文件。这允许你使用Babel的所有好处，同时仍然能够喂它<code class="fe lp lq lr ls b">ts</code>文件。</p><p id="961e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Babel将移除(<a class="ae lo" href="https://www.merriam-webster.com/dictionary/elide" rel="noopener ugc nofollow" target="_blank">省略</a>)任何仅用作类型的<code class="fe lp lq lr ls b">import</code>声明。</p><p id="9e40" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="ln">来源:</em></p><pre class="lt lu lv lw gt lx ls ly lz aw ma bi"><span id="ae9b" class="mb mc it ls b gy md me l mf mg"><em class="ln">// example.ts</em><strong class="ls iu"><br/></strong>import { Color } from "./types";<br/>const changeColor = (color: Color) =&gt; {<br/>  window.color = color;<br/>};</span></pre><p id="c7bc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="ln">通天塔传送输出:</em></p><pre class="lt lu lv lw gt lx ls ly lz aw ma bi"><span id="7d2f" class="mb mc it ls b gy md me l mf mg"><em class="ln">// example.js</em><strong class="ls iu"><br/></strong>const changeColor = (color) =&gt; {<br/>  window.color = color;<br/>};</span></pre><p id="fc10" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果有把握，Babel可以删除该声明，只分析这个单独的文件。当Babel不可能知道某个特定的导入是应该删除的类型还是应该保留的实际值时，问题就出现了。利用再出口时会发生这种情况。</p><pre class="lt lu lv lw gt lx ls ly lz aw ma bi"><span id="ec0b" class="mb mc it ls b gy md me l mf mg"><em class="ln">// example.ts</em><strong class="ls iu"><br/></strong>import { Color } from "./types";<br/>export { Color };</span></pre><p id="78e2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这里，巴别塔不能通过查看<code class="fe lp lq lr ls b">example.ts</code>来判断<code class="fe lp lq lr ls b">Color</code>实际上是一个类型。Babel将被迫在transpiled输出中错误地留下这个声明。</p><p id="e428" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">为什么会这样？嗯，Babel在传输过程中一次显式处理一个文件。据推测，babel团队不希望像TypeScript那样构建相同的类型解析过程，这样就可以删除那些类型。</p><h1 id="d655" class="mh mc it bd mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd bi translated">输入，隔离模块</h1><p id="599f" class="pw-post-body-paragraph kb kc it kd b ke ne kg kh ki nf kk kl km ng ko kp kq nh ks kt ku ni kw kx ky im bi translated"><code class="fe lp lq lr ls b">isolatedModules</code>是一个TypeScript编译器选项，旨在作为一种保护措施。当<code class="fe lp lq lr ls b">isolatedModules</code>编译器标志打开时，由<code class="fe lp lq lr ls b">tsc</code>提供的类型检查将报告类型错误，如果不解决，将影响孤立处理文件的编译工具(babel)。</p><p id="17a5" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">从<a class="ae lo" href="https://www.typescriptlang.org/docs/handbook/compiler-options.html" rel="noopener ugc nofollow" target="_blank">打字稿文件</a>:</p><blockquote class="nj nk nl"><p id="ae38" class="kb kc ln kd b ke kf kg kh ki kj kk kl nm kn ko kp nn kr ks kt no kv kw kx ky im bi translated">执行额外的检查以确保单独编译(比如用<code class="fe lp lq lr ls b"><a class="ae lo" href="https://github.com/Microsoft/TypeScript/wiki/Using-the-Compiler-API#a-simple-transform-function" rel="noopener ugc nofollow" target="_blank"><em class="it">transpileModule</em></a></code>或<a class="ae lo" href="https://babeljs.io/docs/en/babel-plugin-transform-typescript" rel="noopener ugc nofollow" target="_blank">@ babel/plugin-transform-typescript</a>)是安全的。</p></blockquote><p id="ff64" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">来自<a class="ae lo" href="https://babeljs.io/docs/en/babel-plugin-transform-typescript#typescript-compiler-options" rel="noopener ugc nofollow" target="_blank">巴别塔文件</a>:</p><blockquote class="nj nk nl"><p id="8f51" class="kb kc ln kd b ke kf kg kh ki kj kk kl nm kn ko kp nn kr ks kt no kv kw kx ky im bi translated"><code class="fe lp lq lr ls b"><em class="it">--isolatedModules</em></code>这是默认的Babel行为，不能关闭，因为Babel不支持跨文件分析。</p></blockquote><p id="305b" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">换句话说，<strong class="kd iu">每个ts文件必须能够独立传输</strong>。<code class="fe lp lq lr ls b">isolatedModules</code>旗帜阻止我们包括含糊解决的进口。</p><h1 id="fa52" class="mh mc it bd mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd bi translated">隔离模块示例</h1><p id="d271" class="pw-post-body-paragraph kb kc it kd b ke ne kg kh ki nf kk kl km ng ko kp kq nh ks kt ku ni kw kx ky im bi translated">看看babel transpiles代码展示了<code class="fe lp lq lr ls b">isolatedModules</code>标志的重要性的几个例子。</p><p id="bfb8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这两个例子都围绕着音乐流api客户端的构建。</p><h2 id="a821" class="mb mc it bd mi np nq dn mm nr ns dp mq km nt nu mu kq nv nw my ku nx ny nc nz bi translated">示例1 —不明确的再出口</h2><p id="279d" class="pw-post-body-paragraph kb kc it kd b ke ne kg kh ki nf kk kl km ng ko kp kq nh ks kt ku ni kw kx ky im bi translated">在这里，我们获取在<code class="fe lp lq lr ls b">types.ts</code>文件中定义的类型，然后从<code class="fe lp lq lr ls b">lib-ambiguous-re-export.ts</code>重新导出它们。当isolatedModules打开时，此代码<strong class="kd iu">不会</strong> <strong class="kd iu">通过</strong>类型检查。</p><p id="6d58" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="ln">来源:</em></p><pre class="lt lu lv lw gt lx ls ly lz aw ma bi"><span id="7359" class="mb mc it ls b gy md me l mf mg"><em class="ln">// src/types.ts</em><br/>export type Playlist = {<br/>  id: string;<br/>  name: string;<br/>  trackIds: string[];<br/>};</span><span id="010a" class="mb mc it ls b gy oa me l mf mg">export type Track = {<br/>  id: string;<br/>  name: string;<br/>  artist: string;<br/>  duration: number;<br/>};</span><span id="5373" class="mb mc it ls b gy oa me l mf mg"><em class="ln">// src/lib-</em><em class="ln">ambiguous</em><em class="ln">-re-export.ts</em><br/>export { Playlist, Track } from "./types";<br/>export { CreatePlaylistRequestParams, createPlaylist } from "./api";</span></pre><p id="6b11" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="ln">巴别塔传送输出:</em></p><pre class="lt lu lv lw gt lx ls ly lz aw ma bi"><span id="73ca" class="mb mc it ls b gy md me l mf mg"><em class="ln">// dist/types.js</em><br/>--empty--</span><span id="c66a" class="mb mc it ls b gy oa me l mf mg"><em class="ln">// dist/lib-</em><em class="ln">ambiguous</em><em class="ln">-re-export.js</em><br/>export { Playlist, Track } from "./types";<br/>export { CreatePlaylistRequestParams, createPlaylist } from "./api";</span></pre><p id="1a75" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="ln">来源错误:</em></p><figure class="lt lu lv lw gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="oc od di oe bf of"><div class="gh gi ob"><img src="../Images/3c05371d751b642ecc22b952dd32413d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h7ZnxdchigpkPukVUrRMkg.png"/></div></div></figure><p id="0c14" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="ln">几点感悟:</em></p><ul class=""><li id="0994" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky og lf lg lh bi translated">Babel删除了我们的<code class="fe lp lq lr ls b">types</code>模块中的所有内容，因为它只包含了在JS-land中没有用的类型。</li><li id="8fd5" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky og lf lg lh bi translated">Babel没有对我们的<code class="fe lp lq lr ls b">lib</code>模块进行改造。<em class="ln">那就不好了</em>。<code class="fe lp lq lr ls b">Playlist</code>和<code class="fe lp lq lr ls b">Track</code>T33应该已经被巴别塔去掉了。通过node运行这段代码是行不通的。当遇到<code class="fe lp lq lr ls b">lib-ambiguous-re-export.js</code>中的重新导出行时，节点的模块解析过程将看到，没有任何内容从<code class="fe lp lq lr ls b">types.js</code>中导出，并且该过程将终止。</li><li id="0af0" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky og lf lg lh bi translated">如VSCode的截图所示，<code class="fe lp lq lr ls b">tsc</code>类型检查过程会立即将这些不明确的重新导出报告为错误。</li></ul><h2 id="d428" class="mb mc it bd mi np nq dn mm nr ns dp mq km nt nu mu kq nv nw my ku nx ny nc nz bi translated">示例2 —显式导入，显式类型导出</h2><p id="9799" class="pw-post-body-paragraph kb kc it kd b ke ne kg kh ki nf kk kl km ng ko kp kq nh ks kt ku ni kw kx ky im bi translated">这一次，我们在<code class="fe lp lq lr ls b">lib-import-export.ts</code>中明确了类型的再导出。当isolatedModules打开时，该代码<strong class="kd iu">将</strong> <strong class="kd iu">通过</strong>类型检查。</p><p id="f361" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="ln">来源:</em></p><pre class="lt lu lv lw gt lx ls ly lz aw ma bi"><span id="9f18" class="mb mc it ls b gy md me l mf mg"><em class="ln">// src/types.ts</em><strong class="ls iu"><br/></strong>Same as first example</span><span id="7257" class="mb mc it ls b gy oa me l mf mg"><em class="ln">// src/lib-import-export.ts</em><strong class="ls iu"><br/></strong>import {<br/>  Playlist as PlaylistType,<br/>  Track as TrackType,<br/>} from "./types";<br/>import {<br/>  CreatePlaylistRequestParams as CreatePlaylistRequestParamsType,<br/>  createPlaylist<br/>} from "./api";</span><span id="c17a" class="mb mc it ls b gy oa me l mf mg">export type Playlist = PlaylistType;<br/>export type Track = TrackType;</span><span id="c477" class="mb mc it ls b gy oa me l mf mg">export type CreatePlaylistRequestParams = CreatePlaylistRequestParamsType;<br/>export { createPlaylist };</span></pre><p id="2fb7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="ln">通天塔传送输出:</em></p><pre class="lt lu lv lw gt lx ls ly lz aw ma bi"><span id="0603" class="mb mc it ls b gy md me l mf mg"><em class="ln">// dist/types.js</em><br/>--empty-- TODO or does babel remove it all together?</span><span id="61d0" class="mb mc it ls b gy oa me l mf mg"><em class="ln">// dist/lib-import-export.js</em><br/>import { createPlaylist } from "./api";<br/>export { createPlaylist };</span></pre><p id="2232" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="ln">一对夫妇的见解:</em></p><ul class=""><li id="7aea" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky og lf lg lh bi translated">Babel仍然输出一个空的<code class="fe lp lq lr ls b">types.js</code>文件。但是没关系，因为我们的transpiled <code class="fe lp lq lr ls b">lib-import-export.js</code>不再引用它了。</li><li id="17e6" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky og lf lg lh bi translated"><code class="fe lp lq lr ls b">lib-import-export.js</code>现在只导出JS函数，<code class="fe lp lq lr ls b">createPlaylist</code>。这些类型不存在。这是因为我们在源代码中做了额外的工作，通过导入我们的类型，然后显式地重新导出这些类型。</li><li id="532a" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky og lf lg lh bi translated"><code class="fe lp lq lr ls b">tsc</code>对此感到满意，因此您不会看到它像我们在第一个示例中看到的那样报告错误。</li></ul><p id="c96e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">可以看出用Babel处理TypeScript文件时<code class="fe lp lq lr ls b">isolatedModules</code>的重要性。第一个例子更简单、更简洁。但是它违反了隔离模块。到目前为止，为了符合这一要求，必须使用类似冗长的第二个例子。</p></div><div class="ab cl oh oi hx oj" role="separator"><span class="ok bw bk ol om on"/><span class="ok bw bk ol om on"/><span class="ok bw bk ol om"/></div><div class="im in io ip iq"><h1 id="083f" class="mh mc it bd mi mj oo ml mm mn op mp mq mr oq mt mu mv or mx my mz os nb nc nd bi translated">由TypeScript 3.8解决</h1><p id="1889" class="pw-post-body-paragraph kb kc it kd b ke ne kg kh ki nf kk kl km ng ko kp kq nh ks kt ku ni kw kx ky im bi translated">TypeScript 3.8引入了新的语法，当使用时，增加了类型解析过程的确定性。现在，编译器(无论是<code class="fe lp lq lr ls b">tsc</code>、<code class="fe lp lq lr ls b">babel</code>还是其他什么)将能够查看单个文件，如果它是类型脚本类型，就可以省略导入或导出。</p><p id="d32f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">实现这一点的新语法没有引入任何新的关键字，但是允许在两个新位置使用<code class="fe lp lq lr ls b">type</code>。</p><p id="61d4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe lp lq lr ls b">import type ... from </code> —让编译器知道您导入的肯定是一种类型，并且在构建的输出中不需要(或不想要)。</p><p id="2d8e" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><code class="fe lp lq lr ls b">export type ... from</code> —相同，但用于再出口。</p><p id="fe9f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">由于我们上面有两个例子强调了对更好的东西的需求，下面是我们如何重构代码以用于TS 3.8。</p><p id="32fc" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="ln">来源:</em></p><pre class="lt lu lv lw gt lx ls ly lz aw ma bi"><span id="4a4e" class="mb mc it ls b gy md me l mf mg"><em class="ln">// src/lib-type-re-export.ts</em><strong class="ls iu"><br/>export type</strong> { Track, Playlist } <strong class="ls iu">from</strong> "./types";<br/><strong class="ls iu">export type</strong> { CreatePlaylistRequestParams } <strong class="ls iu">from</strong> "./api";<br/>export { createPlaylist } from "./api";</span></pre><p id="a2af" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="ln">巴别塔传送输出:</em></p><pre class="lt lu lv lw gt lx ls ly lz aw ma bi"><span id="3b77" class="mb mc it ls b gy md me l mf mg"><em class="ln">// dist/lib-type-re-export.js</em><br/>export { createPlaylist } from "./api";</span></pre><p id="9a10" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><em class="ln">又多了两个感悟:</em></p><ul class=""><li id="fc2e" class="kz la it kd b ke kf ki kj km lb kq lc ku ld ky og lf lg lh bi translated">源代码看起来很像独立的模块示例1，但是在再导出中消除了歧义。</li><li id="1a41" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky og lf lg lh bi translated">好了，这实际上不是babel transpiled的输出，因为babel还不能处理新的TS 3.8类型的导入和导出。但是当巴别塔7.9发布的时候，这就是它<em class="ln">应该</em>的样子。</li></ul><p id="1a6c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">仅此而已。只有类型的导入/导出是我从<a class="ae lo" href="https://flow.org/" rel="noopener ugc nofollow" target="_blank">流</a>中错过的为数不多的语言特性之一。看到TypeScript的不断发展是很有希望的。</p></div><div class="ab cl oh oi hx oj" role="separator"><span class="ok bw bk ol om on"/><span class="ok bw bk ol om on"/><span class="ok bw bk ol om"/></div><div class="im in io ip iq"><h2 id="dc22" class="mb mc it bd mi np nq dn mm nr ns dp mq km nt nu mu kq nv nw my ku nx ny nc nz bi translated">有关纯类型导入/导出的更多信息的相关资源:</h2><ul class=""><li id="feee" class="kz la it kd b ke ne ki nf km ot kq ou ku ov ky og lf lg lh bi translated">新增TS文档部分:<a class="ae lo" href="https://www.typescriptlang.org/docs/handbook/modules.html#importing-types" rel="noopener ugc nofollow" target="_blank">https://www . typescriptlang . org/docs/handbook/modules . html # importing-types</a></li><li id="0511" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky og lf lg lh bi translated">引入类型导入。公关描述中有很多很棒的信息:【https://github.com/microsoft/TypeScript/pull/35200 T2】</li><li id="f0fe" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky og lf lg lh bi translated">TS 3.8公告:<a class="ae lo" href="https://devblogs.microsoft.com/typescript/announcing-typescript-3-8-beta/#type-only-imports-exports" rel="noopener ugc nofollow" target="_blank">https://dev blogs . Microsoft . com/typescript/announcing-typescript-3-8-beta/# type-only-imports-exports</a></li><li id="904a" class="kz la it kd b ke li ki lj km lk kq ll ku lm ky og lf lg lh bi translated">Babel PR增强了Babel解析器和transform-typescript插件，以利用新的语法。将与巴别塔7.9一同发布:<a class="ae lo" href="https://github.com/babel/babel/pull/11171" rel="noopener ugc nofollow" target="_blank">https://github.com/babel/babel/pull/11171</a></li></ul></div></div>    
</body>
</html>