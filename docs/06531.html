<html>
<head>
<title>Flutter: How to Utilize App Life Cycle (Run Function on App Bootup, Close, and on Interval)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Flutter:如何利用应用程序生命周期(在应用程序启动、关闭和间隔时运行功能)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/flutter-how-to-utilize-app-life-cycle-run-function-on-app-bootup-close-and-on-interval-cacc8d147166?source=collection_archive---------1-----------------------#2020-12-03">https://levelup.gitconnected.com/flutter-how-to-utilize-app-life-cycle-run-function-on-app-bootup-close-and-on-interval-cacc8d147166?source=collection_archive---------1-----------------------#2020-12-03</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/0759a93bd302f0872fb8fc739393f81e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Urml9ncSrB7kKfjCbNB-4A.png"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">Flutter应用生命周期——如何利用</figcaption></figure><p id="9f82" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">一个TL；dr可以在这篇文章的底部找到。</strong></p><p id="c7ed" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">你在手机上使用的大多数(如果不是全部)应用程序都出于各种原因利用应用程序生命周期——也许你想显示用户在关闭应用程序时离线，或者也许你想在会话结束时提交一些关键数据。App lifecycle是一个强大的工具，你应该100%把它放在你的Flutter toolbelt中。</p><p id="2f7f" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">用例</strong></p><p id="7a75" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">以下是应用生命周期的一些使用案例:</p><ul class=""><li id="29fa" class="ld le it kh b ki kj km kn kq lf ku lg ky lh lc li lj lk ll bi translated">报告数据分析(用户看屏幕的时间、点击次数等。)</li><li id="8fb9" class="ld le it kh b ki lm km ln kq lo ku lp ky lq lc li lj lk ll bi translated">清除系统中的会话数据</li><li id="17fa" class="ld le it kh b ki lm km ln kq lo ku lp ky lq lc li lj lk ll bi translated">离线/在线报告</li></ul><p id="e57f" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">其他</strong></p><p id="c75d" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">本教程旨在易于学习——我保证你可以在不到5分钟的时间内(通过学习本教程)为你的应用添加生命周期，并且能够完全控制应用的状态。</p><p id="db12" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这个简单项目的完整回购可以在这里找到<a class="ae lr" href="https://github.com/antholeole/flutter_lifecycle" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="66b6" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">TL；博士垫底。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><p id="0cd8" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们将构建一个计数器应用程序，当用户在线或离线时通知应用程序的其他用户，并在应用程序关闭时向服务器报告数据。</p><h2 id="4021" class="lz ma it bd mb mc md dn me mf mg dp mh kq mi mj mk ku ml mm mn ky mo mp mq mr bi translated">步骤1)设置</h2><p id="3109" class="pw-post-body-paragraph kf kg it kh b ki ms kk kl km mt ko kp kq mu ks kt ku mv kw kx ky mw la lb lc im bi translated">首先，我们将运行<code class="fe mx my mz na b">flutter create</code>命令来生成计数器项目。我总是清除评论，把主页放到另一个文件里。</p><p id="bd2d" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">下一件我们想要做的事情是在树中添加一个定制的小部件:我们称它为<code class="fe mx my mz na b">LifeCycle</code>。现在，它将是一个基本的、有状态的小部件，只通过管道传递给一个子部件:</p><pre class="nb nc nd ne gt nf na ng nh aw ni bi"><span id="f675" class="lz ma it na b gy nj nk l nl nm">import 'package:flutter/material.dart';</span><span id="2914" class="lz ma it na b gy nn nk l nl nm">class LifeCycle extends StatefulWidget {<br/> final Widget child;</span><span id="82d6" class="lz ma it na b gy nn nk l nl nm"> const LifeCycle({@required this.child});</span><span id="8c44" class="lz ma it na b gy nn nk l nl nm"> @override<br/> _LifeCycleState createState() =&gt; _LifeCycleState();<br/>}</span><span id="f953" class="lz ma it na b gy nn nk l nl nm">class _LifeCycleState extends State&lt;LifeCycle&gt; {<br/> @override<br/> Widget build(BuildContext context) {<br/>  return widget.child;<br/> }<br/>}</span></pre><p id="4ac9" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们需要做的就是用这个小部件包装应用程序，然后我们就完成了设置:<code class="fe mx my mz na b">LifeCycle(child: MyHomePage())</code>。</p><h2 id="e057" class="lz ma it bd mb mc md dn me mf mg dp mh kq mi mj mk ku ml mm mn ky mo mp mq mr bi translated">步骤2)获取生命周期</h2><p id="9b65" class="pw-post-body-paragraph kf kg it kh b ki ms kk kl km mt ko kp kq mu ks kt ku mv kw kx ky mw la lb lc im bi translated">为了让生命周期小部件能够观察应用的生命周期，需要做的就是在状态结束时使用<code class="fe mx my mz na b">WidgetsBindingObserver</code>:</p><pre class="nb nc nd ne gt nf na ng nh aw ni bi"><span id="40d5" class="lz ma it na b gy nj nk l nl nm">class _LifeCycleState extends State&lt;LifeCycle&gt; with <!-- -->WidgetsBindingObserver <!-- -->{</span></pre><p id="e19a" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">(额外收获:小部件绑定不仅公开了生命周期方法，还公开了大量“值得一提”的方法。这是关于那个的文件</p><p id="1854" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">现在把<code class="fe mx my mz na b">init</code>和<code class="fe mx my mz na b">dispose</code>改成这样:</p><pre class="nb nc nd ne gt nf na ng nh aw ni bi"><span id="ba3e" class="lz ma it na b gy nj nk l nl nm">@override<br/>void initState() {<br/>WidgetsBinding.instance.addObserver(this);</span><span id="b50a" class="lz ma it na b gy nn nk l nl nm">super.initState();<br/>}</span><span id="c2b9" class="lz ma it na b gy nn nk l nl nm">@override<br/>void dispose() {<br/>WidgetsBinding.instance.removeObserver(this);<br/>super.dispose();<br/>}</span></pre><p id="6350" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">这告诉小部件开始和停止监听小部件绑定。</p><p id="6b4c" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们现在可以通过在小部件中添加一个覆盖来观察生命周期，如下所示:</p><pre class="nb nc nd ne gt nf na ng nh aw ni bi"><span id="c903" class="lz ma it na b gy nj nk l nl nm">@override<br/><strong class="na iu">void </strong>didChangeAppLifecycleState(AppLifecycleState state) {<br/>  print('state = $state');<br/>}</span></pre><p id="ee20" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">该方法采用一个名为<code class="fe mx my mz na b">AppLifecycleState</code>的参数。这是一个对应于应用程序生命周期的每个“状态”的枚举，用外行的话来说就是这些状态。</p><ul class=""><li id="56a9" class="ld le it kh b ki kj km kn kq lf ku lg ky lh lc li lj lk ll bi translated"><code class="fe mx my mz na b">inactive</code>/<code class="fe mx my mz na b">suspending</code>—app正在向后台移动。该应用程序仍处于打开状态，但它不接收输入。这也是暂停的途径，因此应用程序从活动到非活动再到暂停。也许对“离开”状态有用。android和iOS的非活动触发器，但只在iOS暂停——尽管它们在功能上是相同的。</li><li id="883f" class="ld le it kh b ki lm km ln kq lo ku lp ky lq lc li lj lk ll bi translated"><code class="fe mx my mz na b">paused</code> —不再向用户显示该应用程序。也许用户换了应用或者关掉了手机。这是触发的最后一个生命周期方法，这是您想要提交数据的地方。</li><li id="85de" class="ld le it kh b ki lm km ln kq lo ku lp ky lq lc li lj lk ll bi translated"><code class="fe mx my mz na b">resumed</code> —应用可见。这是一个“实时”状态，用户正在使用应用程序。应该注意，使用这种方法，初始应用程序打开时不会调用<code class="fe mx my mz na b">didChangeAppLifecycle</code>——这是因为这个小部件需要挂载。相反，您可以使用initState来打开初始应用程序。</li></ul><h2 id="9e46" class="lz ma it bd mb mc md dn me mf mg dp mh kq mi mj mk ku ml mm mn ky mo mp mq mr bi translated">步骤3)报告生命周期数据(应用使用时间)</h2><p id="0926" class="pw-post-body-paragraph kf kg it kh b ki ms kk kl km mt ko kp kq mu ks kt ku mv kw kx ky mw la lb lc im bi translated">如果你记得，我们要记录两件事:应用程序使用时间，以及计数器点击(定期)。为了报告应用程序的使用时间，我们需要采用正确的生命周期方法。对于我们的例子，它将被暂停和恢复，init应用程序的initState打开。</p><p id="22d2" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们将创建一个名为<code class="fe mx my mz na b">_startTime</code>的私人成员，这将是应用程序打开的时间。我们将有:</p><pre class="nb nc nd ne gt nf na ng nh aw ni bi"><span id="edb2" class="lz ma it na b gy nj nk l nl nm">DateTime _startTime;</span><span id="32a9" class="lz ma it na b gy nn nk l nl nm">@override</span><span id="2cc2" class="lz ma it na b gy nn nk l nl nm">void initState() {<br/>  WidgetsBinding.instance.addObserver(this);<br/>  _startTime = DateTime.now();<br/>  super.initState();<br/>}</span></pre><p id="88d3" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">记录营业时间。然后，在<code class="fe mx my mz na b">didChangeAppLifecycleState</code>中，我们将进入暂停和恢复的生命周期。暂停时，我们将报告数据，恢复时，我们将重置计时器。</p><pre class="nb nc nd ne gt nf na ng nh aw ni bi"><span id="23be" class="lz ma it na b gy nj nk l nl nm">@override<br/>void didChangeAppLifecycleState(AppLifecycleState state) {<br/>  switch (state) {<br/>  case AppLifecycleState.paused:<br/>    _reportData(DateTime.now().difference(_startTime));<br/>    return;<br/>  case AppLifecycleState.resumed:<br/>    _startTime = DateTime.now();<br/>    return;<br/>  default:<br/>    return;<br/>  }<br/> }</span></pre><p id="eb42" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">现在，<code class="fe mx my mz na b">_reportData</code>在我们每次关闭应用程序时都会被记录，计时器也会重置！厉害！</p><h2 id="e27c" class="lz ma it bd mb mc md dn me mf mg dp mh kq mi mj mk ku ml mm mn ky mo mp mq mr bi translated">步骤4)定期报告数据(计数器点击次数)</h2><p id="b1c3" class="pw-post-body-paragraph kf kg it kh b ki ms kk kl km mt ko kp kq mu ks kt ku mv kw kx ky mw la lb lc im bi translated">如何报告计数器点击量？我们可以将它放入<code class="fe mx my mz na b">paused</code>生命周期方法中，但是，让我们试着每10秒报告一次。为此，我们将在<code class="fe mx my mz na b">LifeCycle</code>小部件的<code class="fe mx my mz na b">initState:</code>中设置一个计时器</p><pre class="nb nc nd ne gt nf na ng nh aw ni bi"><span id="d967" class="lz ma it na b gy nj nk l nl nm">_reportClicks = Timer.periodic(Duration(seconds: 10), (_) =&gt; _reportClicksToServer());</span></pre><p id="e72d" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">_reportClicksToServer可以是任何函数。我们需要做的最后一件事是确保我们正确地处理了计时器。在处置:<code class="fe mx my mz na b">_reportClicks.cancel();</code>！</p><p id="6c32" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">我们应该做的最后一件事是找到一种方法来获得这个小部件的计数器点击。我将把这留给你——它可以是任何更高阶的状态管理。<a class="ae lr" rel="noopener ugc nofollow" target="_blank" href="/flutter-state-management-in-2021-when-to-use-what-98722093b8bc">如果您正在尝试寻找适合您的更高阶状态管理，请看一下这篇文章</a>(在这种情况下，为了简单起见，我会使用继承的小部件甚至是单例)。</p><p id="346a" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated">就是这样！由于WidgetsBindingObserver，Flutter中的应用程序生命周期非常简单。</p></div><div class="ab cl ls lt hx lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="im in io ip iq"><p id="0580" class="pw-post-body-paragraph kf kg it kh b ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc im bi translated"><strong class="kh iu">TL；dr: </strong>创建一个小部件并使用<code class="fe mx my mz na b">WidgetsBindingObserver</code> mixin。这将允许您访问<code class="fe mx my mz na b">didChangeAppLifecycleState</code>方法，每次生命周期改变时都会调用该方法。它被具有当前生命周期状态值的枚举参数调用。对于间歇呼叫，您可以使用<code class="fe mx my mz na b">Timer.periodic(Duration(..), (_) =&gt; function)</code></p></div></div>    
</body>
</html>