# 与 Haskell 一起交付

> 原文：<https://levelup.gitconnected.com/delivering-with-haskell-a347d8359597>

这是我对第一次有兴趣使用 Haskell 来发布项目的团队的建议。我的建议是基于两年的 Haskell 经验，结合朋友的战争故事。

![](img/3b9173e207cf3e4f98dd4b46eef9c2bf.png)

不幸的是，我听到越来越多的轶事证据表明 Haskell 项目比其他语言有更高的失败几率。通过在失败的项目中寻找模式，并与成功的项目进行比较，我想帮助新团队远离危险。TL；DR 是**你已经用 Haskell 花光了你所有的新奇预算；所以不要对类型系统做任何花哨的事情。**

我不打算鼓吹为什么任何人都应该使用 Haskell，我不是一个语言传播者，尽管我确实相信它是共享代码库的最佳通用编程语言，并且拥有一流的开发人员工具。如果你发现了 Haskell 的巨大用途，并说服管理层让你使用它，那么希望你能从我的建议中学到一些东西。

我还假设团队中至少有一个人有 Haskell 经验(商业或业余爱好),并且团队的所有核心成员都选择了加入。试图用一种没有经验和/或不情愿的团队成员的语言开始一个项目(每次事情不顺利就质问)肯定会失败，不管你选择什么语言。

# 教育

即使核心团队以前都使用过 Haskell，也会有外围人员找借口抱怨你的项目是如何不可访问的。确保你有一个简单的入职流程，让他们可以自由进出，并随时准备配对和提供帮助

确保您的自述文件链接到优秀的学习材料。我推荐格雷厄姆·赫顿的书《用 Haskell 编程》，同时反对《向你学习一个 Haskell》(它缺乏相关性)和《Haskell 书》(它针对的是非程序员，不是你)。

Haskell 项目之所以失败，是因为核心团队消失在一个筒仓中，把其他所有人都抛在了后面。这被认为是精英主义，是对 Haskell 采用的普遍抱怨。从过去的错误中吸取教训，保持平易近人，渴望教导和分享。

# 工具作业

大多数新的 Haskell 开发人员都使用 VSCode 作为他们的文本编辑器，它有很多相关的扩展。对于小项目来说， [Haskell 语言服务器](https://github.com/haskell/haskell-language-server)非常好用。对于 Emacs 和 Vim 狂热者来说，他们会找到一套成熟的惯用插件。我个人一直在使用名为`[haskell-tng](https://gitlab.com/tseenshe/haskell-tng.el)`的实验性 Emacs 模式，它提供了许多 IDE 特性，使用起来非常愉快。

Haskell 有两个主要的构建工具。[我在两年前写了关于它们的文章](https://medium.com/@fommil/why-not-both-8adadb71a5ed):它们是兼容的，如果你使用`stack.yaml`作为事实的来源，使用`stack2cabal`产生提交给回购的秘密文件，团队成员可以选择他们喜欢的一个。然而，我建议在 CI 中使用`cabal`,因为我发现它和它对话的服务器更容易维护、更可靠、更容易安装、更容易缓存。

不要使用 Nix。没有人理解 Nix，除非他们有时间，Nix 几乎从不工作，使用 NixOS 的人永远不能得到任何工作，Nix 会扼杀你的项目。让 NixOS 的人为了自己的利益保持 nix 文件的更新，如果他真的必须这样做的话，但是不要让它听起来像是一个要求。

请确保在您的自述文件中记录如何为您工作中使用的所有平台设置文本编辑器和构建工具，这样就没有人会声称他们不知道从哪里开始。从 Haskell 安装工具开始，确保非常显著地记录 [Hoogle](https://hoogle.haskell.org/) ，因为这是一个真正的瑰宝和巨大的生产力助推器。

Haskell 有无数的 linters 和 formatters。我建议添加`[ormolu](http://hackage.haskell.org/package/ormolu)`作为`build-tool-depends`(即由构建工具管理，不需要用户设置)并在 CI 中强制执行。它将从项目一开始就停止许多骑自行车的讨论。这一点很重要，因为公司的其他人都在看着你，如果你浪费时间谈论空白，那会很糟糕:这会延续 Haskellers 住在象牙塔里的神话。选择一个工具，让它为你做决定，专注于运输。

# 语言扩展

Haskell 最大的文化冲击之一是没有人真正编写 Haskell；几乎可以肯定，他们正在编写 Haskell 和一些语言扩展。

有超过 120 种语言扩展，其中许多需要读者理解一篇研究论文。我认为每一个扩展背后都有这种水平的文档和考虑是令人惊讶的，我也认为这证明了 Glasgow Haskell 编译器作为学术研究的工具是成功的。然而，作为一名工业开发人员，我意识到每一种语言扩展都会给每一位读者和代码维护者带来教育和概念上的开销、不同级别的工具支持、不明显的功能交互以及令人困惑的编译器错误消息。我之前在[简单的 Haskell 是最好的 Haskell](https://medium.com/@fommil/simple-haskell-is-best-haskell-6a1ea59c73b) 中写过一些这样的问题。

对于第一次采用 Haskell 的团队来说，我的建议比那些 [Simple Haskell](https://www.simplehaskell.org/) 项目要严格得多。哈斯克尔生态系统就像一把没有安全夹的上膛的枪；按照 1998 年报告(2010 年更新)中的定义，坚持股票 Haskell ，你就没事了。除此之外，我认为**有一个选择加入特定语言扩展的过程**，并且在选择小组中包括团队的外围成员以保持名单的合理性是非常重要的。

我建议，至少在第一年，您的小组应该考虑接受以下语言扩展。一旦你交付了，如果每个人都同意 Haskell 在你的公司被正式采用，那么你可以考虑进一步开放它。值得注意的是，我所知道的所有工具都完全支持以下所有扩展。

*   `ScopedTypeVariables`、`ExplicitForAll`、`InstanceSigs`、`KindSignatures`——这些使得在`Haskell2010`忽略需要的地方添加类型签名成为可能，产生更好的错误信息和自我文档。
*   `LambdaCase` -纯粹是语法上的，省去了重复打字。
*   `NamedFieldPuns` -是一种与记录字段交互的显式方式，节省了重复输入。
*   `OverloadedStrings` -将文本输入与数字输入对齐，使得使用内置`String`类型的替代方式更加容易。
*   `BangPatterns` -允许将特定值评估为标准形式，这是避免偶尔内存泄漏或优化性能所必需的。不要和`NFData`混淆，后者是用来强制评估的。
*   `ViewPatterns` -是一种强大的模式守卫，因此节省重复打字。
*   `TupleSections`——“照我的意思做”语法糖处理元组的时候，省去了重复打字。
*   `GeneralizedNewtypeDeriving`——“照我的意思做”为`newtype`事物生成实例的语法糖。

还有一个荣誉奖项颁给了

*   `CPP` -允许使用 C 预处理器，这对于处理多个版本的第三方库或跨平台与本地代码交互是绝对必要的。

这只是一种荣誉，因为`CPP`不被`ormolu`代码格式化程序支持。`ormolu`的作者认为 [CPP 是有害的](https://www.tweag.io/blog/2019-06-27-cpp-considered-harmful/)，坦率地说我不同意他们的观点。不支持`cpp`的语言最终会非常想念它，也没有人提出过向后兼容的替代方案。

Haskell 的老员工会问“就这些？！?"此时此刻。而且，不，我没有忘记`RecordWildcard`或`RecordDotSyntax`(它们隐式地将神奇的符号带入范围)；`Derive*`和`Deriving*`(它们鼓励使用花哨的类型)；`DuplicateRecordFields`(sum 类型不应该有字段，因为它产生部分函数)；`NoImplicitPrelude`(自定义前奏是炒作)；`TypeFamilies`；`GADTs`，或者任何与依赖类型有关的东西(极其花哨的类型)。如果你觉得你正在接近`TypeApplications`，这是一个很好的迹象，表明你正在做一件过于花哨的事情，因为这意味着推理中断了，你需要告诉编译器该做什么。

我也反对一些传统上“安全”的扩展名，如`FunctionalDependencies`和`MultiParamTypeClasses`，它们本身是无害的，但却是通向更多扩展名的门户，如`FlexibleContexts`、`OverlappingInstances`和`IncoherentInstances`。它们的主要用例是启用`MonadReader`和`MonadState`的创建，它们并不像人们预期的那样有用(你会在`[MultiReader](https://hackage.haskell.org/package/multistate-0.8.0.3/docs/Control-Monad-Trans-MultiReader.html)`兔子洞里结束),而且无论如何都可以通过编码显式的`ExceptT`和`StateT`来替换。

顺便说一句，我认为`-fno-warn-orphans`是一种语言扩展，我强烈反对。我认为它攻击了类型类机制的基本原理。使用一个`newtype`，或者将包含类或数据类型的包分支到您的代码库中(Haskell build tooling 使这变得非常容易)，您可以通过将它返回到标记后面的社区来成为一个好公民，这样人们就可以选择加入来获得实例。如果在你的代码库中有冲突的孤立实例，这将会破坏你对每个测试中使用的东西进行推理的能力，并且会使你暴露于罕见的(但是非常耗时的)增量编译错误。与此相关:使用`QuickCheck`但不要使用`Arbitrary`。相反，为每件事编写显式的`Gen`生成器，并在每次测试的基础上选择您想要使用的生成器。一开始做这些只是小菜一碟，但从长远来看，当你开始编写更复杂的测试时，你会感谢我。

# 没有花哨的类型

如果你把依赖类型作为降低缺陷率的一种方法来推销你的管理，那么我不认为 Haskell 是正确的工具；请改用 Idris 或 Agda。

Haskell 类型系统已经被推向诸如类型家族和泛型/类型级编程的方向。我认为每个 Haskell 开发者都应该阅读[用类型思考](https://leanpub.com/thinking-with-types)来理解什么是可能的，但是也不要在试图赢得 Haskell 采用的代码库中做任何类似的事情。

据我所知，每一个失败的 Haskell 项目都有一个共同的主题，那就是他们试图对类型系统做太多的事情，结果代码变得不可维护，错误消息也无法解释。我知道一些项目在大量使用`TypeFamilies`和泛型编程的情况下取得了成功，但是我注意到那些团队是专门作为高级 Haskell 团队建立的，并且只雇佣有 2 年以上商业经验的人。因此，花式类型是有价值的，但这只是比你的第一个项目要远得多。

避免“效果系统”。最近几年有一股热潮，试图让 Haskell 类型系统在类型级别上跟踪个人与现实世界的交互，而不是让一切都在单个`IO`单子中消耗掉。我个人不明白为什么人们想要在类型级别上跟踪这个问题，并且弹出来解决这个问题的效果系统对程序的架构有着巨大的影响，这对于一个实验系统来说是一个相当危险的举动。我参与了一个使用效果系统的项目的分解，我认为公平地说，如果我们没有这样做，这个项目就会失败，并且分解的成本非常高；不是每个项目都有犯这种昂贵错误的奢侈。同样值得注意的是[效果系统表现不佳](https://reasonablypolymorphic.com/blog/mea-culpa/index.html)。

只使用`mtl`风格，或者更好的是，不使用 typeclass 编码(你可能永远不需要定义一个`class`)而只使用函数的记录。我在[MTL 的本地能力](https://discourse.haskell.org/t/local-capabilities-with-mtl/231)和[MTL 的一些限制与函数记录](https://discourse.haskell.org/t/some-limits-of-mtl-with-records-of-functions/576)中详细描述了这一点。

许多库假设您将使用`DeriveGeneric`语言扩展，然后使用泛型编程和记录语法来创建序列化器和反序列化器。这有点像用导弹消灭一只苍蝇，因为间接的层次很多，虽然它对简单的例子有效，但当你有不符合模型的东西时，它就变成了一个兔子洞。与其这样做，我建议只手动编写样板文件，或者更好……用一个名为`[boilerplate](http://hackage.haskell.org/package/boilerplate)`的工具(恰当地说)自动生成样板文件，通过指出它“就像 ide 为 Java、C++和 Go 等语言所做的那样”,它扫除了许多花哨类型的理由。我的结论是,“扔掉你的样板文件”的整个论点实际上是错误的，它解决了一个非问题。

避免花哨的类型对您可能想要使用的库有一些影响。例如，流行的 webframework [服务](https://www.servant.dev/)将要求用户使用`TypeFamilies`来启用几种语言扩展。对用户的影响是错误消息无法理解。我建议用一些更基本的东西，甚至不惜写更多的样板文件，比如 [Scotty](http://hackage.haskell.org/package/scotty) 。我见过一个项目失败(部分原因)是因为它使用了 Servant，而外围开发人员无法为他们的(非 Haskell)服务维护 HTTP 端点定义。该项目也长期没有 Swagger 定义，消费者抱怨他们无法理解 Haskell 服务公开的 HTTP API。不要忘记在你的系统边界使用一种通用语言。

与“花式类型”有点相关的是避免任何事情的出血边缘的一般建议。如果有一个新的图书馆声称比一个已经存在了十多年的图书馆做得更好，也许只要坚持使用更保守的老图书馆就行了。记住，你已经通过选择 Haskell 花费了你的新奇预算。

# 重构

Haskell 使得重构代码变得非常容易。太容易了。**是 bug，不是特性**。

![](img/b3960baa860aef5138a16ac61f395436.png)

[https://twitter.com/rickasaurus/status/1313471620351229958/](https://twitter.com/rickasaurus/status/1313471620351229958/)

对抗过度重构的唯一方法是好的过程和强有力的领导。对代码库的每一次重构都会在中断正在进行的工作方面产生成本，并且对于其他必须审查代码并重新理解他们曾经熟悉的代码的开发人员来说，会产生概念性的开销。从长远来看，回报可能是更易维护的代码库。Haskell 使人们更容易相信重构是正确的，但不要忘记真正的人力和项目管理成本，以及类型系统无法捕捉的错误，这些错误可能会被自动生成 serialisers 等内容的花哨类型所混合。

在这个话题上，艾米丽给了我们一些睿智的建议:

> 问“我的代码是必要的吗，或者就我个人对代码的理解而言，它是更有意义的方便的重构吗？”答案很少是“是”。
> 
> —MLE[https://twitter.com/pitopos/status/1312098569382359040](https://twitter.com/pitopos/status/1312098569382359040)

# 一般建议

我不知道有任何项目因为下面列出的事情而失败，这更像是我浪费时间做的事情的一个垃圾场。Haskell 真的很稳定，但这只是意味着 bug 是众所周知的，不容易修复。对我来说最大的问题是:

*   创建一个类型别名到一个单一的，全局的，monad 的堆栈，并且只需要显式的编码而不是使用`Monad*`约束。对于更一般的代码，你可以只使用一个`Monad`约束。
*   不要使用`String`，这是低效的，将需要你使用语言扩展来实现实例。用`Text`代替。
*   不要使用异常。你认为你理解了它们，因为你已经在其他语言中很好地使用了它们，但是在懒惰的语言中你并不理解它们。如果你真的必须使用它们，那么只使用`[safe-exceptions](http://hackage.haskell.org/package/safe-exceptions)`包中的`*Deep`函数和大量的`NFData`实例。
*   在用户请求/响应级别，投资编写一个真正好的基于模型的测试框架，使用 QuickCheck 生成用户动作，并使用特定于领域的收缩器。

这就是我给你的所有建议！我希望你玩得开心，我真的希望你能帮助增加 Haskell 的采用。我喜欢这种语言，我认为它已经错过了由于误解。我希望你成功，无论如何请让我知道。