<html>
<head>
<title>Golang for Java Developers — The Basics</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向Java开发人员的Golang基础知识</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/go-for-java-devs-the-basics-348fa57f4100?source=collection_archive---------7-----------------------#2021-04-06">https://levelup.gitconnected.com/go-for-java-devs-the-basics-348fa57f4100?source=collection_archive---------7-----------------------#2021-04-06</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="d49b" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">从Java角度看Go编程语言—第1部分</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/ca3eed77d3cccff11b2d286801059e37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gausz1aacOvPJT1MEuBDTA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">作者糟糕的草图</figcaption></figure><p id="04a6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">作为一个用Java编程的人，我一直认为自己是一个“Java迷”。当然，作为业界的主流平台之一，Java有时会被人瞧不起(“它太罗嗦了！”“慢了！”“老了！”)但我个人对这种语言和平台的未来感到兴奋。</p><p id="bf81" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">也就是说，学习其他语言和技术很重要。所以在我学习谷歌云平台的同时，我也在学习围棋。我的学习方法是<a class="ae lu" href="https://medium.datadriveninvestor.com/how-to-write-tutorials-that-actually-teach-f46ae618890f" rel="noopener ugc nofollow" target="_blank">跳过教程</a>，直接开始设计和构建我的软件。当然，这有时会很慢，因为我经常需要停下来，看看如何用语言执行各种琐碎的任务。但是过了一小段时间，我觉得我对这门语言的掌握还不错。</p><p id="34ae" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以我决定从一个长期Java爱好者的角度，概述一下我对Go的看法。事实证明，我有很多想法。所以我把这篇文章分成三部分:</p><ul class=""><li id="9e90" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated">这篇文章是第1部分，介绍了Go的基础知识，主要关注该语言的语法</li><li id="7f96" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated"><a class="ae lu" href="https://medium.com/p/493dad0c5129" rel="noopener">第2部分</a>，涵盖指针、错误处理和并发性</li><li id="c8ac" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated"><a class="ae lu" href="https://medium.com/p/672597c19ae4" rel="noopener">第3部分</a>，从编码的实际本质退一步，讨论编译、包和模块，以及内置到Go core中的一些高级功能</li></ul><h2 id="f026" class="mj mk it bd ml mm mn dn mo mp mq dp mr lh ms mt mu ll mv mw mx lp my mz na nb bi translated">一些需要解决的问题</h2><p id="9138" class="pw-post-body-paragraph ky kz it la b lb nc ju ld le nd jx lg lh ne lj lk ll nf ln lo lp ng lr ls lt im bi translated">在我开始之前，让我澄清一些事情。很明显，我对Java的熟悉程度远远超过了对Go的熟悉程度。所以我会很自然地把Java作为一种基线，和Go进行比较。这并不意味着一种语言优于另一种语言。然而，这确实意味着我可能会错过一些关于围棋的要点，或者弄错一些细节。在这种情况下，我欢迎任何反馈和纠正；我还在学！</p><p id="1503" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">另外，本文有意不冠以“<em class="nh"> Java vs Go，哪个更好？“我现在就告诉你:这两种语言都很好，各有优缺点。我打算放弃Java转围棋吗？没有。我会在未来的项目中使用Go吗？你打赌。我建议你作为一个Java开发人员，学习一些围棋吗？绝对的。</em></p><h2 id="a5a3" class="mj mk it bd ml mm mn dn mo mp mq dp mr lh ms mt mu ll mv mw mx lp my mz na nb bi translated">我为什么选择Go？</h2><p id="1ea6" class="pw-post-body-paragraph ky kz it la b lb nc ju ld le nd jx lg lh ne lj lk ll nf ln lo lp ng lr ls lt im bi translated">最后，有了过多的语言；我为什么选择学围棋？这部分源于Java当前的一个弱点:启动时间。在无服务器云产品的世界里——容器是短暂的，可以随时重启——这变得很重要。从像Spring这样的重型Java框架转移到像Vert.x这样的轻型框架肯定会大大缩短启动时间。但是JVM启动仍然存在。</p><p id="ec03" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Java社区正在解决这个问题。但还没到那一步。所以与此同时，我想我会探索其他的解决方案。我是强类型编译语言的粉丝(大惊喜？)所以我对学习，比如说，Python，不感兴趣。从这个角度来看，Go——一种编译成本地可执行文件的强类型语言——似乎是一个很好的选择。</p><p id="73d2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">至于我在Go中开发的东西，它是微服务和网络应用(在GCP云上运行)以及少量云功能的结合。</p></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><p id="762d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">说了这么多，让我们从Java的角度来看看Go。</p><h1 id="9823" class="np mk it bd ml nq nr ns mo nt nu nv mr jz nw ka mu kc nx kd mx kf ny kg na nz bi translated">句法</h1><p id="e3b1" class="pw-post-body-paragraph ky kz it la b lb nc ju ld le nd jx lg lh ne lj lk ll nf ln lo lp ng lr ls lt im bi translated">当来自Java时，一些语言的语法感觉相当自然。至少在我的经验中，Go不是这些语言中的一种。这两者之间的差异太大了，需要一点时间来适应。幸运的是，Go的设计目标是简单易学，我可以说这个目标达到了。新手应该不会花太多时间来熟悉Go的语法。</p><p id="891c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我不会在这里详尽地回顾Go的语法，但是我会给出一些重点。</p><h2 id="5bd6" class="mj mk it bd ml mm mn dn mo mp mq dp mr lh ms mt mu ll mv mw mx lp my mz na nb bi translated">类型声明和推理</h2><p id="e95a" class="pw-post-body-paragraph ky kz it la b lb nc ju ld le nd jx lg lh ne lj lk ll nf ln lo lp ng lr ls lt im bi translated">Go是强类型的。然而，Go也能够推断类型(类似于Java 10中添加的类型推断，带有<code class="fe oa ob oc od b">var</code>关键字)。因此，在声明类型时，类型放在变量名后的<em class="nh">处，就像这样:<br/> <code class="fe oa ob oc od b">var name string = “Pat”</code> <br/>这样，类型声明可以很容易地省略。由于<em class="nh">【Pat】</em>显然是一个字符串，我们可以省略类型声明，比如:<br/> <code class="fe oa ob oc od b">var name = “Pat”</code> <br/> <code class="fe oa ob oc od b">name</code>仍然很大程度上代表一个字符串。Go提供了额外的点缀，允许我们省略<code class="fe oa ob oc od b">var</code>而使用<code class="fe oa ob oc od b">:=</code>赋值操作符:<br/> <code class="fe oa ob oc od b">name := “Pat”</code></em></p><p id="d261" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">函数(由<code class="fe oa ob oc od b">func</code>关键字标识)也将它们的返回类型放在它们签名的末尾，比如:<br/> <code class="fe oa ob oc od b">func countVowels(s string) int8 { ... }</code></p><p id="19ab" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">和Java一样，函数可以返回<code class="fe oa ob oc od b">void</code>。但与Java中不同的是，<code class="fe oa ob oc od b">void</code>关键字不包含在内:<br/> <code class="fe oa ob oc od b">func setName(p Person, name string) { ... }</code></p><p id="adc1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">注意，Scala和Typescript等其他语言支持类型推断，因此也将类型定义放在最后。但是那些语言使用冒号(<code class="fe oa ob oc od b">:</code>)来分隔变量/函数名和类型，比如:<br/> <code class="fe oa ob oc od b">powers: number[] = []<br/>showName(inc: number, choice: Choice): void</code></p><p id="c78d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Go的语法允许我们输入更少的字符。但是在使用了这两种方法之后，我希望Go采用冒号；它提供了额外的易读性。</p><h2 id="66a8" class="mj mk it bd ml mm mn dn mo mp mq dp mr lh ms mt mu ll mv mw mx lp my mz na nb bi translated">多种退货类型</h2><p id="f5b0" class="pw-post-body-paragraph ky kz it la b lb nc ju ld le nd jx lg lh ne lj lk ll nf ln lo lp ng lr ls lt im bi translated">Go允许函数有多个返回值。当调用这样的函数时，我们可以将变量赋给每个返回值。这是一个很棒的特性，而且在你使用几次之后，感觉这是一个很容易的特性。函数签名的返回值采用元组的形式(虽然Go在技术上不支持元组类型):</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="4bff" class="mj mk it od b gy oi oj l ok ol">func splitName(fullName string) (string, string) { <br/>  fName := ...<br/>  lName := ...<!-- --> <br/>  return fName, lName<br/>}</span></pre><p id="bf0a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当调用代码时，我可以像这样给firstName和lastName变量赋值:<br/> <code class="fe oa ob oc od b">fName, lName := splitName(“Pat Smith”)</code> <br/>然而，请注意，可能不清楚我的<code class="fe oa ob oc od b">splitName</code>函数是否打算返回first name和last name。为了帮助解决这种情况，Go提供了命名返回值:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="2d92" class="mj mk it od b gy oi oj l ok ol">func splitName(fullName string) (firstName, lastName string) { <br/>  firstName = ...<br/>  lastName = ...<br/>  return  // "return" must be called by itself<br/>}</span></pre><p id="0c5a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">虽然这个特性主要是作为一种隐式文档的形式，但是当与并发结构结合使用时，它也提供了额外的好处。</p><h2 id="fcfd" class="mj mk it bd ml mm mn dn mo mp mq dp mr lh ms mt mu ll mv mw mx lp my mz na nb bi translated">不需要分号</h2><p id="0874" class="pw-post-body-paragraph ky kz it la b lb nc ju ld le nd jx lg lh ne lj lk ll nf ln lo lp ng lr ls lt im bi translated">在Go中，单行语句不需要分号。哦，Java…你什么时候采用这个规则？！！</p><h2 id="871d" class="mj mk it bd ml mm mn dn mo mp mq dp mr lh ms mt mu ll mv mw mx lp my mz na nb bi translated">有点太简单了？</h2><p id="479d" class="pw-post-body-paragraph ky kz it la b lb nc ju ld le nd jx lg lh ne lj lk ll nf ln lo lp ng lr ls lt im bi translated">围棋的一个既定设计理念是简单易学。所以设计者保持它的规格最小。这意味着在许多情况下，有一种单一的方法来执行任何特定的功能。</p><p id="216c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">虽然这使得Go很容易学习，但我发现在执行普通任务时，它很快就会令人沮丧。虽然Java可能有冗长的名声，但它不断添加的特性和语法糖使编程变得不那么乏味，而且——我敢这么说吗？—更讨人喜欢。</p><p id="6d5f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">典型的例子。假设我们想基于一个布尔条件给一个变量赋值。在Java和其他语言中，我们可以使用三元运算符:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="782e" class="mj mk it od b gy oi oj l ok ol">var speech = (animal.type == Animal.DOG) ? “Woof” : “Blah”;</span></pre><p id="0d74" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们直到Java 12才开始使用它(即使在那时也只是一个预览特性)，但是我们现在可以使用<a class="ae lu" href="https://docs.oracle.com/en/java/javase/13/language/switch-expressions.html" rel="noopener ugc nofollow" target="_blank">开关表达式</a>来处理更复杂的表达式:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="7827" class="mj mk it od b gy oi oj l ok ol">var speech = switch (animal.type) {<br/>  case Animal.DOG -&gt; "Woof";<br/>  case Animal.CAT -&gt; "Meow";<br/>  case Animal.BIRD -&gt; "Tweet";<br/>  default -&gt; "Blah";<br/>}</span></pre><p id="051e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以我希望Go——作为一门较新的语言——一开始就有这样的内置表达式。没有这样的运气。我们甚至没有三元运算符。相反，我们必须初始化一个变量，并在一个<code class="fe oa ob oc od b">if</code>语句中修改它:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="046c" class="mj mk it od b gy oi oj l ok ol">var speech = "Blah";<br/>if (animal.Type == DOG) {<br/>  speech = "Woof"<br/>}</span></pre><p id="33fd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">值得庆幸的是，Go <em class="nh">至少提供了switch语句(尽管——同样——没有switch <em class="nh">表达式</em>)。</em></p><h1 id="6eb7" class="np mk it bd ml nq nr ns mo nt nu nv mr jz nw ka mu kc nx kd mx kf ny kg na nz bi translated">结构和函数，天啊</h1><p id="92c0" class="pw-post-body-paragraph ky kz it la b lb nc ju ld le nd jx lg lh ne lj lk ll nf ln lo lp ng lr ls lt im bi translated">作为Java开发人员，我们习惯于按照对象来思考。作为一种面向对象语言，Java为我们提供了诸如</p><ul class=""><li id="175b" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated">遗产</li><li id="1431" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">富类型系统</li><li id="086e" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">包装</li></ul><p id="1955" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Go不是一种OO语言；它也不假装是。那么Go在数据结构方面给了我们什么呢？乍一看，答案似乎是:</p><ul class=""><li id="2ad6" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated">原始类型和结构</li><li id="7c57" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">用于操作这些基元类型和结构的函数</li></ul><p id="1ce0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我心想，“<em class="nh">天哪，这就是我们得到的全部吗？</em></p><p id="1515" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">幸运的是，事实证明这肯定是我们用Go得到的全部。</p><h2 id="9db5" class="mj mk it bd ml mm mn dn mo mp mq dp mr lh ms mt mu ll mv mw mx lp my mz na nb bi translated">接收器功能=方法</h2><p id="0c2e" class="pw-post-body-paragraph ky kz it la b lb nc ju ld le nd jx lg lh ne lj lk ll nf ln lo lp ng lr ls lt im bi translated">如果你以前使用过结构，你会知道它们代表了特定数据类型的简单记录。例如，这是Go中的一个结构:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="2654" class="mj mk it od b gy oi oj l ok ol">type Team struct {<br/>  id       int8<br/>  name     string<br/>  company  Company<br/>  members  []Person<br/>}</span></pre><p id="2a81" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">它允许我们创建由原始类型(<code class="fe oa ob oc od b">string</code>是Go中的原始类型)以及其他结构、数组、映射和其他数据类型组成的数据结构。历史上<strong class="la iu"><em class="nh"/></strong>不允许我们做的事情之一是将<em class="nh">行为</em>附加到数据结构上。</p><p id="1147" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是结果是，我们<em class="nh">可以</em>在Go中将行为附加到结构上。这是通过<em class="nh">接收器类型</em>的功能实现的。</p><p id="093c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">为了说明这一点，让我们展示如何创建一个普通函数来计算团队成员的数量:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="1a3a" class="mj mk it od b gy oi oj l ok ol">func countMembers(t Team) int {<br/>  return len(t.members)<br/>}</span></pre><p id="291b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">要使用这个函数，我必须将一个团队实例传递给这个函数，如下所示:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="0986" class="mj mk it od b gy oi oj l ok ol">var c = countMembers(t)</span></pre><p id="3422" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">不可怕，但也不特别自然，尤其是对我们Java开发人员来说。幸运的是，我可以重写函数，将Team作为<em class="nh">接收者</em>:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="2d49" class="mj mk it od b gy oi oj l ok ol">func (t Team) countMembers() int {<br/>  return len(t.members)<br/>}</span></pre><p id="54d7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe oa ob oc od b">Team</code>结构现在是<code class="fe oa ob oc od b">countMembers()</code>函数的接收者，我现在可以在<code class="fe oa ob oc od b">Team</code>的实例上调用它作为方法:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="ba04" class="mj mk it od b gy oi oj l ok ol">var c = t.countMembers()</span></pre><p id="05fd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这使得我们可以像操作对象一样操作结构体，使编码感觉更自然(并且在使用IDE的自动完成功能时帮助很大)。)</p><p id="3236" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><strong class="la iu"> <em class="nh">那么接下来，围棋应该给我们扩展方法了吧？虽然接收函数允许我们调用数据结构上的方法，但是我们声明它们的语法有点笨拙。在Java中，我们在类声明中包含字段和方法，使我们的类定义具有内聚性。在Go中，我们的“方法”是在我们的结构定义之外声明的，有效地将我们的数据与其逻辑分离开来。对我来说，这使得易读性和维护变得不必要的困难。</em></strong></p><p id="8a11" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">事实上，语法是如此的笨拙，我开始怀疑它背后是否有意图。我想:<em class="nh">嘿，也许Go允许我们创建扩展方法！</em></p><p id="192a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><a class="ae lu" href="https://en.wikipedia.org/wiki/Extension_method" rel="noopener ugc nofollow" target="_blank">扩展方法</a>是C#、Scala、Objective-C和Swift等其他语言中的一个有用特性。实际上，通过扩展方法，我们可以将新方法添加到现有的类中，甚至是第三方库中的类。我认为Go的接收函数语法会使扩展方法成为语言的一部分。</p><p id="c57c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">不幸的是，Go不允许当前模块之外的结构使用接收函数。因此，Go中没有扩展方法。</p><h2 id="712f" class="mj mk it bd ml mm mn dn mo mp mq dp mr lh ms mt mu ll mv mw mx lp my mz na nb bi translated">接口</h2><p id="5f38" class="pw-post-body-paragraph ky kz it la b lb nc ju ld le nd jx lg lh ne lj lk ll nf ln lo lp ng lr ls lt im bi translated">Go允许我们定义接口。Go的接口类似于Java和其他语言'；它们只是定义了一组方法签名。与Java不同，struct不需要(事实上，<em class="nh">不能</em>)显式声明它实现了一个接口。如果该结构实现了接口中定义的所有方法，那么它隐式实现了该接口。</p><p id="a41d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，我们可以创建以下接口:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="2d10" class="mj mk it od b gy oi oj l ok ol">type WithMembers interface {<br/>  countMembers() int<br/>}</span></pre><p id="350e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们前面的<code class="fe oa ob oc od b">Team</code>结构现在将自动隐式实现该接口。</p><p id="7d43" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你可能会问:<em class="nh">这是否意味着编译器不能强制接口实现？</em>嗯，当<code class="fe oa ob oc od b">Team</code>本身是<em class="nh">编译的</em>时，编译器无法验证<code class="fe oa ob oc od b">Team</code>实现了<code class="fe oa ob oc od b">WithMembers</code>。但是当<code class="fe oa ob oc od b">Team</code>被<em class="nh">用作</em>时，编译器会验证它。</p><p id="a697" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">例如，如果我有一个函数:<br/> <code class="fe oa ob oc od b">func iterateOverMembers(w WithMembers) { ... }</code> <br/>并且我这样调用它:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="aac3" class="mj mk it od b gy oi oj l ok ol">var t Team = ...</span><span id="9d85" class="mj mk it od b gy om oj l ok ol">iterateOverMembers(t)</span></pre><p id="dede" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">编译器将确保<code class="fe oa ob oc od b">t</code>的类实现<code class="fe oa ob oc od b">WithMembers</code>中定义的所有方法签名。如果我将<code class="fe oa ob oc od b">WithMembers</code>中定义的方法改为类似<code class="fe oa ob oc od b">countAllMembers() int</code>的方法，那么上面的代码片段将无法编译。</p><p id="8d00" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我仍然没有决定我认为这是一个好主意还是坏主意(也许两者都是？)一方面，它消除了可能是不必要的声明，并帮助我们避免了一长串结构上的“实现”。另一方面，我想知道这是否会使维护变得更加困难，特别是如果我们修改我们的接口定义(比方说，通过添加新的方法签名)。</p><p id="96fd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我还发现，这使得浏览和推理现有代码变得更加困难。例如，当我探索各种Go核心语言模块时，我发现自己必须记下某些结构打算实现哪些接口，以帮助自己理解整体代码结构。</p><h2 id="d35a" class="mj mk it bd ml mm mn dn mo mp mq dp mr lh ms mt mu ll mv mw mx lp my mz na nb bi translated">构造函数？</h2><p id="ebdd" class="pw-post-body-paragraph ky kz it la b lb nc ju ld le nd jx lg lh ne lj lk ll nf ln lo lp ng lr ls lt im bi translated">Go结构不能有显式构造函数。要创建一个结构的实例，我们只需这样声明它:</p><p id="d55e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe oa ob oc od b">t := Team{123, “My Team”, abcInc, [],}</code></p><p id="87f5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我们也可以使用命名参数:</p><p id="eb1a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe oa ob oc od b">t := Team{id: 123, name: “My Team”, company: abcInc, members: [],}</code></p><p id="7e3e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">使用命名参数有助于代替构造函数重载。如果省略了任何字段，那么这些字段将被初始化为它们的缺省零值(或者，如果该字段被声明为接口或指针，则为nil)。所以如果我写</p><p id="d937" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe oa ob oc od b">var t = Team{ name: "Your Team"}</code></p><p id="ba1b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe oa ob oc od b"><em class="nh">t</em></code>将代表一个带有<code class="fe oa ob oc od b">id=0</code>、<code class="fe oa ob oc od b">name="Your Team"</code>、一个空的<code class="fe oa ob oc od b">member</code>数组和一个被初始化为其自身缺省零值的<code class="fe oa ob oc od b">Company</code>的团队。</p><p id="caf9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">您可能会注意到，很有可能在非法状态下初始化结构；结构不提供在创建新实例之前验证特定字段是否正确初始化的机制。出现了一些成语来反驳这种说法，它们各有利弊。</p><h1 id="ecdb" class="np mk it bd ml nq nr ns mo nt nu nv mr jz nw ka mu kc nx kd mx kf ny kg na nz bi translated">访问控制(或者，“没有任何命名约定吗？”)</h1><p id="359e" class="pw-post-body-paragraph ky kz it la b lb nc ju ld le nd jx lg lh ne lj lk ll nf ln lo lp ng lr ls lt im bi translated">当我第一次开始阅读Go code时，我对命名约定缺乏一致性感到震惊。具体来说，在命名接口、结构、变量和函数时，对于使用大写还是小写，似乎没有达成共识。仅仅这个事实就使得阅读Go代码比阅读Java代码要困难得多。例如:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="8a92" class="mj mk it od b gy oi oj l ok ol">func Run() {<br/>  strategy := establishStrategy()<br/>  teamRepo = repository.MakeTeamRepo(strategy)</span><span id="6080" class="mj mk it od b gy om oj l ok ol">  var tErr error<br/>  Tmpl, tErr = template.ParseFS(Assets, "assets/index.html")<br/>  if tErr != nil {<br/>    log.Fatal(tErr)<br/>  }</span><span id="6301" class="mj mk it od b gy om oj l ok ol">  router := mux.NewRouter()<br/>  router.HandleFunc("/add", addHandler)<br/>  if err := http.ListenAndServe(":8080", router); err != nil {<br/>    log.Fatal(err)<br/>  }<br/>}</span></pre><p id="e6f7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是有原因的:Go使用大小写来控制访问。Java提供了<code class="fe oa ob oc od b">public</code>、<code class="fe oa ob oc od b">protected</code>和<code class="fe oa ob oc od b">private</code>修饰符(以及默认的说明符)，而现在，Java 9、<em class="nh">模块</em> —Go提供了大写和小写。大写命名的元素被导出到它们的包之外，因此是可访问的；小写名字的就不是了。</p><p id="87e2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">简单？当然可以。但是好像有点…怪怪的。它也有一些缺点。</p><h2 id="0752" class="mj mk it bd ml mm mn dn mo mp mq dp mr lh ms mt mu ll mv mw mx lp my mz na nb bi translated">易辨认</h2><p id="7c8b" class="pw-post-body-paragraph ky kz it la b lb nc ju ld le nd jx lg lh ne lj lk ll nf ln lo lp ng lr ls lt im bi translated">正如我提到的，大写和小写的搭配会影响可读性。Java和大多数其他语言已经建立了命名约定，使得阅读代码更加容易。类名以大写字母开头，变量和方法名以小写字母开头，常量全部大写。</p><p id="0e8f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Go的方法，IMHO，使得代码更加难以阅读。当然，一旦你使用Go一段时间，代码会变得更容易阅读。</p><h2 id="4033" class="mj mk it bd ml mm mn dn mo mp mq dp mr lh ms mt mu ll mv mw mx lp my mz na nb bi translated">可量测性</h2><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi on"><img src="../Images/c29d4957082bc09686421dc902c4ca5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6AokgQ3UtyArNKRl-VGDnQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">我们的小猫Spitfire在被贴上绝育标签后(来源:我)</figcaption></figure><p id="b599" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">几年前，我家领养了一对小猫。我们收养它们的地方有一个有趣的方法来追踪哪些小猫已经绝育:他们剪下绝育小猫的左耳尖。</p><p id="c5f3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">现在，除了看起来有点残忍(收养中心发誓动物们根本没有注意到少了一点耳朵)，这让我觉得是一个完全不可扩展的解决方案。毕竟，猫只有两只耳朵。如果收养中心需要开始追踪小猫病史的其他部分，它们很快就会失去耳朵(而且，我希望，它们不会转移到身体的其他部位)。</p><p id="570c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我对Go使用字母大小写来指定访问控制也有类似的反应。有两种选择:大写或小写。没有中格或超级小写。因此，Go仅限于全局可访问的元素或仅限于其包的元素。它不能提供更细粒度的控制。</p><h2 id="28d5" class="mj mk it bd ml mm mn dn mo mp mq dp mr lh ms mt mu ll mv mw mx lp my mz na nb bi translated">可变性</h2><p id="4ec6" class="pw-post-body-paragraph ky kz it la b lb nc ju ld le nd jx lg lh ne lj lk ll nf ln lo lp ng lr ls lt im bi translated">可维护性也会受到影响。在Java中，如果我们决定修改一个变量的访问限制，我们只需要修改一个关键字。在Go中，我们实际上需要重命名变量。当然，这没什么大不了的，考虑到编译器应该捕捉任何未命中，大多数ide会提供<em class="nh">重命名</em>重构帮助。尽管如此，在我看来，除了提高清晰度之外，我们还需要为变量重新命名。</p><h1 id="b617" class="np mk it bd ml nq nr ns mo nt nu nv mr jz nw ka mu kc nx kd mx kf ny kg na nz bi translated">其他现代语言特征</h1><h2 id="4464" class="mj mk it bd ml mm mn dn mo mp mq dp mr lh ms mt mu ll mv mw mx lp my mz na nb bi translated">不变</h2><p id="12e5" class="pw-post-body-paragraph ky kz it la b lb nc ju ld le nd jx lg lh ne lj lk ll nf ln lo lp ng lr ls lt im bi translated">关于Go是否提供不可变数据结构的讨论比比皆是。例如，Java通过<code class="fe oa ob oc od b">final</code>修饰符提供了不变性——虽然有点笨拙。较新的语言为创建不可变字段提供了更自然的机制。例如，Scala允许我们定义<code class="fe oa ob oc od b">val</code> s(不可变字段)以及<code class="fe oa ob oc od b">var</code> s(可变字段)。</p><p id="a83a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">Go没有提供这样的构造。例如，每个字段都是一个<code class="fe oa ob oc od b">var</code>，所以理论上，每个字段都是可变的。Go确实提供了一个<code class="fe oa ob oc od b">const</code>关键字来创建常量值，但是这并不适用于结构；它仅用于定义全局常量。</p><p id="a1f1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，Go确实提供了限制我们改变数据能力的方法。</p><ul class=""><li id="126b" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated">如前所述，对以小写字母命名的字段的访问仅限于该字段所在的模块。因此，通常用小写首字母命名字段，然后提供大写的“getter”函数，如下所示:</li></ul><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="d21d" class="mj mk it od b gy oi oj l ok ol">type MyStruct struct {<br/>  var secret string  // not accessible outside of MyStruct's module<br/>}</span><span id="dacd" class="mj mk it od b gy om oj l ok ol">func (ms MyStruct) Secret() string {  // accessible everywhere<br/>  return ms.string<br/>}</span></pre><ul class=""><li id="5e4e" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated">结构是通过复制传递的(除非，正如我们后面将要讨论的，我们显式地传递指针)。这意味着我们通常在应用程序代码中处理我们自己的结构的本地副本。我们可以修改副本的字段，但是这些修改对原始结构没有影响。</li></ul><h2 id="4ed7" class="mj mk it bd ml mm mn dn mo mp mq dp mr lh ms mt mu ll mv mw mx lp my mz na nb bi translated">零安全</h2><p id="1c7b" class="pw-post-body-paragraph ky kz it la b lb nc ju ld le nd jx lg lh ne lj lk ll nf ln lo lp ng lr ls lt im bi translated">人们还会问Go是否是空安全的。同样，答案是一个四舍五入的“差不多”。结构和基元不能为空；在最坏的情况下，它们将被初始化为它们的缺省零值。</p><p id="51cb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">然而，其他类型可以为null(或者更确切地说，<em class="nh"> nil </em>)。这包括指针、接口、映射、数组和通道。</p><h2 id="efc8" class="mj mk it bd ml mm mn dn mo mp mq dp mr lh ms mt mu ll mv mw mx lp my mz na nb bi translated">枚举</h2><p id="f6c2" class="pw-post-body-paragraph ky kz it la b lb nc ju ld le nd jx lg lh ne lj lk ll nf ln lo lp ng lr ls lt im bi translated">枚举是Go“差不多”拥有的另一个特性。围棋中没有<em class="nh">枚举</em>类型。然而，有一个结构叫做<em class="nh"> iota </em>。iota本质上是一个表示自动递增整数的关键字。无论何时声明它，它都会发出序列中的下一个整数。<code class="fe oa ob oc od b">iota</code>设计用于声明常量，每当关键字<code class="fe oa ob oc od b">const</code>出现时，它的值重置为<code class="fe oa ob oc od b">0</code>。</p><p id="8f28" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe oa ob oc od b">iota</code>常用于模拟围棋中的枚举。这里有一个例子:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="6300" class="mj mk it od b gy oi oj l ok ol">type Animal int  // we've created a type alias</span><span id="3ed2" class="mj mk it od b gy om oj l ok ol">const (<br/>  Dog Animal = iota<br/>  Cat<br/>  Fish<br/>  Bird<br/>)</span><span id="6866" class="mj mk it od b gy om oj l ok ol">func printAnimal(a Animal) {<br/>  log.Printf("Animal index = %d", a)</span><span id="7654" class="mj mk it od b gy om oj l ok ol">func test() {<br/>  printAnimal(Dog)   // Animal index = 0<br/>  printAnimal(Cat)   // Animal index = 1<br/>  printAnimal(Fish)  // Animal index = 2<br/>  printAnimal(Bird)  // Animal index = 3<br/>  printAnimal(99)    // Animal index = 99<br/>}</span></pre><p id="ea99" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意以下几点:</p><ul class=""><li id="23ce" class="lv lw it la b lb lc le lf lh lx ll ly lp lz lt ma mb mc md bi translated">我们声明<code class="fe oa ob oc od b">Animal</code>类型的常量。<code class="fe oa ob oc od b">Animal</code>实际上只是<code class="fe oa ob oc od b">int</code>的别名，为了提高易读性/自文档化。</li><li id="51e5" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">我们创建的每个<code class="fe oa ob oc od b">Animal</code>常量都被赋予一个递增的<code class="fe oa ob oc od b">int</code>值。</li><li id="9f35" class="lv lw it la b lb me le mf lh mg ll mh lp mi lt ma mb mc md bi translated">没有什么可以阻止我们传递任意的<code class="fe oa ob oc od b">int</code>来代替<code class="fe oa ob oc od b">Animal</code>。</li></ul><p id="3b5a" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后一点相当重要。如果我们创建一个期望我们的常量之一的函数(比如我们的<code class="fe oa ob oc od b">printAnimal()</code>函数，它期望一个<code class="fe oa ob oc od b">Animal</code>)，我们不能强制我们的一个预定义值(<code class="fe oa ob oc od b">Dog</code>、<code class="fe oa ob oc od b">Cat</code>、<code class="fe oa ob oc od b">Fish</code>或<code class="fe oa ob oc od b">Bird</code>)实际上被传递。</p><p id="904e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">此外，在Java和其他语言中，我们不会自动获得我们所期望的枚举功能。例如，没有每个常数都有标签的概念:</p><p id="83c0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><code class="fe oa ob oc od b">log.Printf(“Label of Dog is %s”, Dog.Label()) // can’t do this</code></p><p id="8196" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">当然，我们可以创建自己的函数来实现这一点:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="306c" class="mj mk it od b gy oi oj l ok ol">func (a Animal) Label() string {<br/>  switch a {<br/>    case 0: return "Dog"<br/>    case 1: return "Cat"<br/>    case 2: return "Fish"<br/>    case 3: return "Bird"<br/>    default: "I don't know"<br/>  }<br/>}</span></pre><p id="000c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">但是这需要我们手工操作和手工维护。</p><h2 id="e42a" class="mj mk it bd ml mm mn dn mo mp mq dp mr lh ms mt mu ll mv mw mx lp my mz na nb bi translated">无商标消费品</h2><p id="a35a" class="pw-post-body-paragraph ky kz it la b lb nc ju ld le nd jx lg lh ne lj lk ll nf ln lo lp ng lr ls lt im bi translated">我仍然记得在5之前用Java编程，在泛型被包含之前。即使没有在任何其他语言中使用过泛型，我也能清楚地感觉到对这种构造的需要。现在，我无法想象没有它们的编程。</p><p id="270e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">所以如果你和我一样，你可能会问:<em class="nh">Go支持泛型吗？答案是——在我写这篇文章的时候——还没有，但是会的。</em></p><p id="8494" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">与此同时，你不会感到像你想象的那么痛。Go缺乏对象层次结构，这消除了对泛型的需求。Go的核心库没有像Java那样的集合框架，这一事实也是如此。相反，它提供了数组、切片(其行为类似于可变数组)和映射:由它们包含的数据类型定义的容器。</p><p id="4c15" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">尽管如此，仍有明确的用例需要泛型。例如，我试图创建一个非常简单的表单(或者应该是结构关系映射器(T21)？)作为我的数据访问代码。我发现如果不严重依赖空的接口声明(<code class="fe oa ob oc od b">{}</code>，这实质上相当于Go简单地将某个东西声明为<code class="fe oa ob oc od b">Object</code>)，我就是做不到。我把那个项目放到一边，直到Go 1.18发布。</p><h2 id="9a99" class="mj mk it bd ml mm mn dn mo mp mq dp mr lh ms mt mu ll mv mw mx lp my mz na nb bi translated">一流的功能</h2><p id="0a85" class="pw-post-body-paragraph ky kz it la b lb nc ju ld le nd jx lg lh ne lj lk ll nf ln lo lp ng lr ls lt im bi translated">Go中的函数是一级构造。这意味着我们可以将函数赋给变量，将函数传递给其他函数，或者从其他函数返回函数。我们还可以创建匿名函数(如果需要，可以立即执行它们)。这意味着Go允许我们做的事情至少和Java Lambdas允许我们做的一样多。</p><p id="948d" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">下面我们来看看一些用途:</p><pre class="kj kk kl km gt oe od of og aw oh bi"><span id="2aa9" class="mj mk it od b gy oi oj l ok ol">type mathOp func(a int, b int) int</span><span id="2538" class="mj mk it od b gy om oj l ok ol">func op(m mathOp, x int, y int) {<br/>  log.Printf("Op result is %d", m(x, y))<br/>}</span><span id="c6f1" class="mj mk it od b gy om oj l ok ol">func main() {<br/>  var add mathOp := func(a int, b int) int {<br/>    return a + b<br/>  }<br/>  var mult mathOp := func(a int, b int) int {<br/>    return a * b<br/>  }<br/>  op(add, 2, 4)<br/>  op(mult, 2, 4)</span><span id="cd6f" class="mj mk it od b gy om oj l ok ol">  func(a float32, b float32) {<br/>    log.Printf("Op result is %f", a / b)<br/>  }(2.25, 4.25)<br/>}</span><span id="3683" class="mj mk it od b gy om oj l ok ol">// prints:<br/>Op result is 6<br/>Op result is 8<br/>Op result is 0.529412</span></pre><p id="e329" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">上面，我们定义了一个名为<code class="fe oa ob oc od b">mathOp</code>的函数<em class="nh"> type </em>(把它想象成一个描述函数的接口)，它接受两个int并返回一个int。接下来，我们创建一个名为<code class="fe oa ob oc od b">op</code>的函数，它接受一个<code class="fe oa ob oc od b">mathOp</code>，以及两个int操作数:<em class="nh"> x </em>和<em class="nh"> y </em>。<code class="fe oa ob oc od b">op</code>将依次通过将<code class="fe oa ob oc od b">x</code>和<code class="fe oa ob oc od b">y</code>参数传递给<code class="fe oa ob oc od b">mathOp</code>来执行<code class="fe oa ob oc od b">mathOp</code>参数中传递给它的函数。</p><p id="9c50" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在我们的<code class="fe oa ob oc od b">main</code>函数中，我们创建了两个变量，<code class="fe oa ob oc od b">add</code>和<code class="fe oa ob oc od b">mult</code>，每个变量都符合我们刚刚定义的<code class="fe oa ob oc od b">mathOp</code>类型。然后，我们可以将每一个和两个任意操作数一起传递给<code class="fe oa ob oc od b">op</code>函数。</p><p id="13c0" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">最后，我们将利用Go尚不支持泛型的事实来演示匿名函数。因为我们想在除法运算中使用浮点数，所以我们将创建一个一次性的匿名函数。然后我们通过传递参数立即调用它(即<code class="fe oa ob oc od b">(2.25, 4.25)</code>)。</p><h1 id="5f0d" class="np mk it bd ml nq nr ns mo nt nu nv mr jz nw ka mu kc nx kd mx kf ny kg na nz bi translated">让我们继续前进</h1><p id="f333" class="pw-post-body-paragraph ky kz it la b lb nc ju ld le nd jx lg lh ne lj lk ll nf ln lo lp ng lr ls lt im bi translated">在本系列的下一篇文章中，我们将讨论一些真正区别于Java的地方:指针、错误处理和并发性。</p></div><div class="ab cl ni nj hx nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="im in io ip iq"><p id="efd4" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">觉得这个故事有用？想多读点？只需<a class="ae lu" href="https://dt-23597.medium.com/subscribe" rel="noopener">在此订阅</a>即可将我的最新故事直接发送到您的收件箱。</p><p id="97db" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">你也可以支持我和我的写作——并获得无限数量的故事——通过<a class="ae lu" href="https://dt-23597.medium.com/membership" rel="noopener">今天成为媒体会员</a>。</p></div></div>    
</body>
</html>