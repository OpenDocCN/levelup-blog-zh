<html>
<head>
<title>How IEnumerable.ToArray() Works</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">多么可爱。ToArray()有效</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-ienumerable-toarray-works-4bb7a2cabada?source=collection_archive---------3-----------------------#2019-12-09">https://levelup.gitconnected.com/how-ienumerable-toarray-works-4bb7a2cabada?source=collection_archive---------3-----------------------#2019-12-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3be4" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">英寸NET Framework 4.x</h2></div><p id="9da8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是一个<a class="ae lb" href="https://medium.com/@DavidKlempfner/how-ienumerable-tolist-works-c119a4572c1e" rel="noopener"> 2部分</a>系列的第1部分，讨论<code class="fe lc ld le lf b">ToArray()</code>和<code class="fe lc ld le lf b"><a class="ae lb" href="https://medium.com/@DavidKlempfner/how-ienumerable-tolist-works-c119a4572c1e" rel="noopener">ToList()</a></code>如何在幕后工作，以及哪一个更高效。</p><h1 id="5ae4" class="lg lh iq bd li lj lk ll lm ln lo lp lq jw lr jx ls jz lt ka lu kc lv kd lw lx bi translated">ToArray()源代码</h1><p id="5b79" class="pw-post-body-paragraph kf kg iq kh b ki ly jr kk kl lz ju kn ko ma kq kr ks mb ku kv kw mc ky kz la ij bi translated">以下摘自<a class="ae lb" href="https://referencesource.microsoft.com/#System.Core/System/Linq/Enumerable.cs,942" rel="noopener ugc nofollow" target="_blank">。NET源代码</a>:</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi md"><img src="../Images/a2d8e1058094b5c2a41bc44e1769998b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*r0MLHLQR9dcO_Xfr.JPG"/></div></div></figure><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi mp"><img src="../Images/cbdcf91d2cdc209340e756bdddfb8671.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BaL2x4RIVJO-xmHb.JPG"/></div></div></figure><h2 id="37a5" class="mq lh iq bd li mr ms dn lm mt mu dp lq ko mv mw ls ks mx my lu kw mz na lw nb bi translated">代码摘要</h2><p id="c8d5" class="pw-post-body-paragraph kf kg iq kh b ki ly jr kk kl lz ju kn ko ma kq kr ks mb ku kv kw mc ky kz la ij bi translated">下面是所用逻辑的总结:</p><p id="3513" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">是</strong> <code class="fe lc ld le lf b"><strong class="kh ir">IEnumerable&lt;T&gt;</strong></code> <strong class="kh ir">的一个</strong> <code class="fe lc ld le lf b"><strong class="kh ir">ICollection&lt;T&gt;</strong></code> <strong class="kh ir">(即。它有</strong> <code class="fe lc ld le lf b"><strong class="kh ir">Count</strong></code> <strong class="kh ir">属性吗？).如果是:</strong></p><ol class=""><li id="5486" class="nc nd iq kh b ki kj kl km ko ne ks nf kw ng la nh ni nj nk bi translated">将<code class="fe lc ld le lf b">IEnumerable&lt;T&gt;</code>转换为<code class="fe lc ld le lf b">ICollection&lt;T&gt;</code></li><li id="674b" class="nc nd iq kh b ki nl kl nm ko nn ks no kw np la nh ni nj nk bi translated">创建一个与<code class="fe lc ld le lf b">ICollection&lt;T&gt;</code>大小相同的新数组</li><li id="6733" class="nc nd iq kh b ki nl kl nm ko nn ks no kw np la nh ni nj nk bi translated">使用<code class="fe lc ld le lf b">CopyTo()</code>方法将项目从<code class="fe lc ld le lf b">ICollection&lt;T&gt;</code>复制到这个新数组中。</li></ol><p id="ab86" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">是不是</strong> <code class="fe lc ld le lf b"><strong class="kh ir">IEnumerable&lt;T&gt;</strong></code> <strong class="kh ir">不是一个</strong> <code class="fe lc ld le lf b"><strong class="kh ir">ICollection&lt;T&gt;</strong></code> <strong class="kh ir">(即。真是一个普通的老</strong> <code class="fe lc ld le lf b"><strong class="kh ir">IEnumerable&lt;T&gt;</strong></code> <strong class="kh ir">？).如果是:</strong></p><ol class=""><li id="1a7e" class="nc nd iq kh b ki kj kl km ko ne ks nf kw ng la nh ni nj nk bi translated">创建一个长度为4的新数组</li><li id="6599" class="nc nd iq kh b ki nl kl nm ko nn ks no kw np la nh ni nj nk bi translated">对于<code class="fe lc ld le lf b">IEnumerable&lt;T&gt;</code>中的每个元素，将该元素加载到数组中，每次数组被填充时，创建一个两倍于前一个数组大小的新数组。</li><li id="8cfb" class="nc nd iq kh b ki nl kl nm ko nn ks no kw np la nh ni nj nk bi translated">一旦完成，如果数组的大小等于<code class="fe lc ld le lf b">IEnumerable&lt;T&gt;</code>中元素的数量，那么返回数组。</li><li id="ae1a" class="nc nd iq kh b ki nl kl nm ko nn ks no kw np la nh ni nj nk bi translated">如果数组的大小不等于<code class="fe lc ld le lf b">IEnumerable&lt;T&gt;</code>中元素的数量，即。数组的长度大于<code class="fe lc ld le lf b">IEnumearble&lt;T&gt;</code>中元素的数量，这是大多数情况下的情况，然后创建一个新的数组，其大小为<code class="fe lc ld le lf b">IEnumerable&lt;T&gt;</code>的大小，并将数组中过大的元素复制到这个大小完美的数组中。</li></ol><h1 id="876f" class="lg lh iq bd li lj lk ll lm ln lo lp lq jw lr jx ls jz lt ka lu kc lv kd lw lx bi translated">例子</h1><p id="d616" class="pw-post-body-paragraph kf kg iq kh b ki ly jr kk kl lz ju kn ko ma kq kr ks mb ku kv kw mc ky kz la ij bi translated">让我们看一些例子，从创建的临时阵列的数量来理解最好和最坏的情况。</p><p id="950d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这些例子中，<code class="fe lc ld le lf b">IEnumerable&lt;T&gt;</code>源不是<code class="fe lc ld le lf b">ICollection&lt;T&gt;</code>。</p><h2 id="b613" class="mq lh iq bd li mr ms dn lm mt mu dp lq ko mv mw ls ks mx my lu kw mz na lw nb bi translated">示例1 —最佳情况:</h2><p id="526d" class="pw-post-body-paragraph kf kg iq kh b ki ly jr kk kl lz ju kn ko ma kq kr ks mb ku kv kw mc ky kz la ij bi translated">在最好的情况下，源<code class="fe lc ld le lf b">IEnumerable&lt;T&gt;</code>有4个元素，<code class="fe lc ld le lf b">foreach</code>循环从索引0到索引3计数，将来自<code class="fe lc ld le lf b">IEnumerable&lt;T&gt;</code>的每个元素放入长度= 4的数组中。</p><p id="5e81" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为它只到达index = 3(即count = 3)，<code class="fe lc ld le lf b">else if</code>块永远不会被执行，数组大小永远不会翻倍。</p><p id="1662" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它也不需要创建一个大小合适的数组，因为它已经是一个大小合适的数组了。</p><p id="6e57" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后它会将这个数组返回给<code class="fe lc ld le lf b">ToArray()</code>的调用者。</p><p id="8c13" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">在这个例子中，只创建了一个数组实例。</strong></p><p id="328b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是一个流程图:</p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/5920f3e5c44f770241dbe983f046da75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1194/format:webp/0*p5qFJ0zk9MiwkEjs.jpg"/></div></figure><h2 id="5c92" class="mq lh iq bd li mr ms dn lm mt mu dp lq ko mv mw ls ks mx my lu kw mz na lw nb bi translated">示例2 —最坏情况</h2><p id="a75a" class="pw-post-body-paragraph kf kg iq kh b ki ly jr kk kl lz ju kn ko ma kq kr ks mb ku kv kw mc ky kz la ij bi translated">当<code class="fe lc ld le lf b">IEnumerable&lt;T&gt;.Count</code>为&gt; 4且临时双倍大小数组未被填充时，创建以下数组:</p><ol class=""><li id="3d51" class="nc nd iq kh b ki kj kl km ko ne ks nf kw ng la nh ni nj nk bi translated">一个在开始，大小为4。</li><li id="56f2" class="nc nd iq kh b ki nl kl nm ko nn ks no kw np la nh ni nj nk bi translated">在<code class="fe lc ld le lf b">else if</code>块中至少还有一个，创建一个两倍于先前大小的数组。</li><li id="079d" class="nc nd iq kh b ki nl kl nm ko nn ks no kw np la nh ni nj nk bi translated">一个是在最末尾，创建一个大小适合所有<code class="fe lc ld le lf b">IEnumerable&lt;T&gt;</code>元素的数组。</li></ol><p id="5af1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">所以在最坏的情况下，创建的数组数量是&gt; = 3。</strong></p><figure class="me mf mg mh gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="gh gi nr"><img src="../Images/f8bba38fb9f66dad4a0d990bbd25d644.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*z6CFmIPYEugCw2K-.jpg"/></div></div></figure><p id="5a5a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">点击<a class="ae lb" href="https://medium.com/@DavidKlempfner/how-ienumerable-tolist-works-c119a4572c1e" rel="noopener">此处</a>查看第二部分。</p></div></div>    
</body>
</html>