<html>
<head>
<title>The Built-in Javascript Math Object</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">内置的Javascript数学对象</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/the-javascript-math-object-33293684952b?source=collection_archive---------11-----------------------#2020-07-15">https://levelup.gitconnected.com/the-javascript-math-object-33293684952b?source=collection_archive---------11-----------------------#2020-07-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ea6d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">数学对象的有用方法</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/5028cfbdf86d75a2f0bf52541720a519.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CtnG2SDCgqPiQ567Q6MOBg.jpeg"/></div></div></figure><p id="86bd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Javascript提供了一个方便的内置<code class="fe ln lo lp lq b">Math</code>对象，该对象具有帮助执行数学计算的<em class="lr">属性</em>和<em class="lr">方法</em>。</p><p id="98bd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">正如<a class="ae ls" href="https://www.w3schools.com/js/js_math.asp" rel="noopener ugc nofollow" target="_blank"> w3schools </a>所解释的:</p><blockquote class="lt lu lv"><p id="d0ce" class="kr ks lr kt b ku kv jr kw kx ky ju kz lw lb lc ld lx lf lg lh ly lj lk ll lm ij bi translated">与其他全局对象不同，Math对象没有构造函数。方法和属性是静态的。</p><p id="4397" class="kr ks lr kt b ku kv jr kw kx ky ju kz lw lb lc ld lx lf lg lh ly lj lk ll lm ij bi translated">所有方法和属性(常量)都可以使用，无需先创建Math对象。</p></blockquote><h1 id="9940" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">性能</h1><p id="4e10" class="pw-post-body-paragraph kr ks iq kt b ku mr jr kw kx ms ju kz la mt lc ld le mu lg lh li mv lk ll lm ij bi translated"><code class="fe ln lo lp lq b">Math</code>对象的属性包括各种常量。一个例子是π，它可以通过写<code class="fe ln lo lp lq b">Math.PI</code>来访问。</p><pre class="kg kh ki kj gt mw lq mx my aw mz bi"><span id="f00d" class="na ma iq lq b gy nb nc l nd ne">const radius = 3;<br/>const circumference = 2 * Math.PI * radius;<br/>console.log(circumference)<br/>// expected output: 18.8495....</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nf"><img src="../Images/e1f57cda35b18b8723c486b7d804f9f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tTP0PH292hhm0YZy_mV-PA.jpeg"/></div></div></figure><h1 id="95d0" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">方法</h1><p id="cdaa" class="pw-post-body-paragraph kr ks iq kt b ku mr jr kw kx ms ju kz la mt lc ld le mu lg lh li mv lk ll lm ij bi translated">我使用<code class="fe ln lo lp lq b">Math</code>对象的方法比使用它的属性更频繁。让我们在本文的剩余部分讨论一些我认为最有用的方法。</p><p id="7d36" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> <em class="lr">注:</em> </strong> <em class="lr">一般情况下，</em> <code class="fe ln lo lp lq b"><em class="lr">Math</em></code> <em class="lr">对象的方法期望接收一个数字作为自变量。如果传入的参数不是数字并且不能转换成数字，它将返回</em> <code class="fe ln lo lp lq b"><em class="lr">NaN</em></code> <em class="lr">。</em></p><h2 id="2e3e" class="na ma iq bd mb ng nh dn mf ni nj dp mj la nk nl ml le nm nn mn li no np mp nq bi translated">Math.sqrt(x)</h2><p id="3656" class="pw-post-body-paragraph kr ks iq kt b ku mr jr kw kx ms ju kz la mt lc ld le mu lg lh li mv lk ll lm ij bi translated">这个方法接受一个数字并返回它的(正)平方根。</p><p id="40ca" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ln lo lp lq b">Math.sqrt()</code>期望参数是一个<em class="lr">正</em>数，所以如果传入的参数是<em class="lr">负</em>，则返回<code class="fe ln lo lp lq b">NaN</code>。</p><pre class="kg kh ki kj gt mw lq mx my aw mz bi"><span id="835d" class="na ma iq lq b gy nb nc l nd ne">console.log(Math.sqrt(4)) <br/>// expected output: 2</span><span id="caba" class="na ma iq lq b gy nr nc l nd ne">console.log(Math.sqrt("16"))<br/>// expected output: 4</span><span id="6588" class="na ma iq lq b gy nr nc l nd ne">console.log(Math.sqrt("five")<br/>// expected output: NaN</span><span id="65bd" class="na ma iq lq b gy nr nc l nd ne">console.log(Math.sqrt(-4))<br/>// expected output: NaN</span></pre><h2 id="c8e3" class="na ma iq bd mb ng nh dn mf ni nj dp mj la nk nl ml le nm nn mn li no np mp nq bi translated">Math.round(x)</h2><p id="17c8" class="pw-post-body-paragraph kr ks iq kt b ku mr jr kw kx ms ju kz la mt lc ld le mu lg lh li mv lk ll lm ij bi translated">它接受一个数字，并返回舍入到最接近的整数的参数值。</p><pre class="kg kh ki kj gt mw lq mx my aw mz bi"><span id="8d93" class="na ma iq lq b gy nb nc l nd ne">console.log(Math.round(4.5)) <br/>// expected output: 5</span><span id="6d95" class="na ma iq lq b gy nr nc l nd ne">console.log(Math.round(4.2)) <br/>// expected output: 4</span></pre><h2 id="bb85" class="na ma iq bd mb ng nh dn mf ni nj dp mj la nk nl ml le nm nn mn li no np mp nq bi translated">数学.楼层(x)</h2><p id="8d1f" class="pw-post-body-paragraph kr ks iq kt b ku mr jr kw kx ms ju kz la mt lc ld le mu lg lh li mv lk ll lm ij bi translated">它接受一个数字，并返回将参数值向下舍入到最接近的整数(即。返回小于或等于所提供数字的最大整数)。</p><pre class="kg kh ki kj gt mw lq mx my aw mz bi"><span id="37c0" class="na ma iq lq b gy nb nc l nd ne">console.log(Math.floor(<!-- -->6.001<!-- -->)) <br/>// expected output: 6</span><span id="5662" class="na ma iq lq b gy nr nc l nd ne">console.log(Math.floor(<!-- -->6.999<!-- -->)) <br/>// expected output: 6</span></pre><h2 id="4268" class="na ma iq bd mb ng nh dn mf ni nj dp mj la nk nl ml le nm nn mn li no np mp nq bi translated">Math.ceil(x)</h2><p id="b552" class="pw-post-body-paragraph kr ks iq kt b ku mr jr kw kx ms ju kz la mt lc ld le mu lg lh li mv lk ll lm ij bi translated">这是<code class="fe ln lo lp lq b">Math.floor</code>的反义词。它接受一个数字并返回将<strong class="kt ir">向上</strong>舍入到最接近的整数的参数值(即。返回大于或等于所提供数字的最小整数)。</p><pre class="kg kh ki kj gt mw lq mx my aw mz bi"><span id="6e04" class="na ma iq lq b gy nb nc l nd ne">console.log(Math.ceil(<!-- -->6.001<!-- -->)) <br/>// expected output: 7<br/><br/>console.log(Math.ceil(<!-- -->6.999<!-- -->)) <br/>// expected output: 7</span></pre><h2 id="44c4" class="na ma iq bd mb ng nh dn mf ni nj dp mj la nk nl ml le nm nn mn li no np mp nq bi translated">Math.min(a，b，c，…)</h2><p id="60b1" class="pw-post-body-paragraph kr ks iq kt b ku mr jr kw kx ms ju kz la mt lc ld le mu lg lh li mv lk ll lm ij bi translated">该方法接受任意数量的参数，并返回所提供的最小参数。</p><p id="d5c8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了找到数组中的最小值，可以使用<a class="ae ls" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax" rel="noopener ugc nofollow" target="_blank">扩展运算符</a>来提供数组值作为参数。</p><p id="452d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果<em class="lr">作为参数提供的任何</em>值不是数字并且不能转换为数字，则返回<code class="fe ln lo lp lq b">NaN</code>。</p><pre class="kg kh ki kj gt mw lq mx my aw mz bi"><span id="870b" class="na ma iq lq b gy nb nc l nd ne">console.log(Math.min(1, 3, 2));<br/>// expected output: 1</span><span id="f818" class="na ma iq lq b gy nr nc l nd ne">console.log(Math.min(-1, -3, -2));<br/>// expected output: -3</span><span id="7b85" class="na ma iq lq b gy nr nc l nd ne">const array1 = [1, 3, 2];</span><span id="9dcf" class="na ma iq lq b gy nr nc l nd ne">console.log(Math.min(...array1));<br/>// expected output: 1</span><span id="ef2d" class="na ma iq lq b gy nr nc l nd ne">console.log(Math.min(3, "five", 1))<br/>// expected output: NaN</span></pre><h2 id="dc40" class="na ma iq bd mb ng nh dn mf ni nj dp mj la nk nl ml le nm nn mn li no np mp nq bi translated">Math.max(a，b，c，…)</h2><p id="aded" class="pw-post-body-paragraph kr ks iq kt b ku mr jr kw kx ms ju kz la mt lc ld le mu lg lh li mv lk ll lm ij bi translated">这是<code class="fe ln lo lp lq b">Math.min()</code>的反义词。它返回作为输入给出的最大数字。</p><pre class="kg kh ki kj gt mw lq mx my aw mz bi"><span id="bcff" class="na ma iq lq b gy nb nc l nd ne">console.log(Math.max(1, 3, 2));<br/>// expected output: 3</span><span id="a90c" class="na ma iq lq b gy nr nc l nd ne">console.log(Math.max(-1, -3, -2));<br/>// expected output: -1</span><span id="f196" class="na ma iq lq b gy nr nc l nd ne">const array1 = [1, 3, 2];</span><span id="b396" class="na ma iq lq b gy nr nc l nd ne">console.log(Math.max(...array1));<br/>// expected output: 3</span><span id="0201" class="na ma iq lq b gy nr nc l nd ne">console.log(Math.max(3, "five", 1))<br/>// expected output: NaN</span></pre><p id="67dc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">不像<code class="fe ln lo lp lq b">Math.round()</code>、<code class="fe ln lo lp lq b">Math.floor()</code>、<code class="fe ln lo lp lq b">Math.ceil()</code>不带任何参数调用就会返回<code class="fe ln lo lp lq b">NaN</code>，有趣的是，<code class="fe ln lo lp lq b">Math.max()</code>、<code class="fe ln lo lp lq b">Math.min()</code>也可以不带参数调用。</p><p id="ca47" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果不带参数调用，<code class="fe ln lo lp lq b">Math.max()</code>将返回<code class="fe ln lo lp lq b">-Infinity</code>，<code class="fe ln lo lp lq b">Math.min()</code>将返回<code class="fe ln lo lp lq b">Infinity</code>。</p><p id="c87d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">不，那不是错别字。我不是不小心把顺序搞混了。</strong></p><p id="28b8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我知道这似乎违反直觉，这就是为什么我提出来。</p><p id="dc3c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如<a class="ae ls" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/max" rel="noopener ugc nofollow" target="_blank"> MDN文件</a>中所述，对于<code class="fe ln lo lp lq b">Math.max()</code>:</p><blockquote class="lt lu lv"><p id="5507" class="kr ks lr kt b ku kv jr kw kx ky ju kz lw lb lc ld lx lf lg lh ly lj lk ll lm ij bi translated"><code class="fe ln lo lp lq b"><a class="ae ls" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Infinity" rel="noopener ugc nofollow" target="_blank">-Infinity</a></code>是初始比较值，因为几乎所有其他值都更大，这就是为什么当没有给定参数时，- <code class="fe ln lo lp lq b"><a class="ae ls" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Infinity" rel="noopener ugc nofollow" target="_blank">Infinity</a></code>会返回。</p></blockquote><p id="9a87" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于<code class="fe ln lo lp lq b">Math.min()</code>来说，情况正好相反，<code class="fe ln lo lp lq b">Infinity</code>是初始比较值，因为传入的任何其他值都会更小。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/412f87d9985747879abf80fb59f7d074.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/1*pFj0inrUSCyReVMhFQvklg.jpeg"/></div></figure><h2 id="d229" class="na ma iq bd mb ng nh dn mf ni nj dp mj la nk nl ml le nm nn mn li no np mp nq bi translated">Math.random()</h2><p id="cc95" class="pw-post-body-paragraph kr ks iq kt b ku mr jr kw kx ms ju kz la mt lc ld le mu lg lh li mv lk ll lm ij bi translated">该方法不接受任何参数，它返回一个浮点数，该浮点数是左闭右开范围[0，1]内的一个<a class="ae ls" href="https://hackernoon.com/how-does-javascripts-math-random-generate-random-numbers-ef0de6a20131" rel="noopener ugc nofollow" target="_blank">伪随机</a>数。(对于我们这些永远记不住记数法是什么意思的人来说，它是大于或等于0(包括0)且不超过1(不包括1)的数。)</p><pre class="kg kh ki kj gt mw lq mx my aw mz bi"><span id="1fc4" class="na ma iq lq b gy nb nc l nd ne">Math.random()<br/>// expected output: 0.4594633007874416 (for example)</span></pre><p id="84df" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以使用来自<code class="fe ln lo lp lq b">Math</code>对象的额外方法来缩放和移动生成的数字到一个适合我们需要的范围。</p><p id="cb63" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">例如，如果我想生成一个范围在[1，5](1和5之间，含1和5)内的随机整数:</p><pre class="kg kh ki kj gt mw lq mx my aw mz bi"><span id="975b" class="na ma iq lq b gy nb nc l nd ne">Math.floor(Math.random() * 5) + 1<br/>// expected output: well it's random.... but will be in the set<br/>// {1,2,3,4,5}</span></pre><p id="2402" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">要逐步解释:</p><ol class=""><li id="37dc" class="nt nu iq kt b ku kv kx ky la nv le nw li nx lm ny nz oa ob bi translated"><code class="fe ln lo lp lq b">Math.random() * 5</code>将生成一个介于0(含)和5(不含)之间的浮点数。</li></ol><p id="3159" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">2.我们使用<code class="fe ln lo lp lq b">Math.floor()</code>将其向下舍入到最接近的整数，所以现在它将是0、1、2、3或4。</p><p id="97e8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">3.然后我们加上<code class="fe ln lo lp lq b">1</code>，所以数字将是1、2、3、4或5</p><p id="1a42" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">更一般地，为了生成范围[a，b](在a和b之间，包括a和b)中的随机整数，我们可以使用下面的公式:</p><pre class="kg kh ki kj gt mw lq mx my aw mz bi"><span id="e1e6" class="na ma iq lq b gy nb nc l nd ne">Math.floor(Math.random() * (b - a + 1)) + a</span></pre><p id="6344" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ln lo lp lq b">Math.random()</code>是我使用最多的方法，但是我们可以看到它与其他一些<code class="fe ln lo lp lq b">Math</code>对象方法配合得很好。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/bd06baf24354cc5f18e8a1ae10c8b361.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*QlAVl5QJU7hCdD_rPvQF7g.png"/></div></figure><p id="e388" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> <em class="lr">注:</em> </strong> <em class="lr">你可以在这里</em>  <em class="lr">找到所有数学属性和方法的文档(包括方法签名和如何处理不同的输入值)。</em></p></div></div>    
</body>
</html>