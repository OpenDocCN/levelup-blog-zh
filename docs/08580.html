<html>
<head>
<title>Library vs Service: 7 Arguments to consider</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">图书馆与服务:需要考虑的7个论点</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/library-vs-service-7-arguments-to-consider-5088dced6022?source=collection_archive---------4-----------------------#2021-05-14">https://levelup.gitconnected.com/library-vs-service-7-arguments-to-consider-5088dced6022?source=collection_archive---------4-----------------------#2021-05-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="35e3" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">了解区别以及何时使用哪一种</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e49aee3dfc49c1b6c56a399d25a00933.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RCS_jN8EfocSluJxknomkg.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">共享代码可以在库中，也可以在服务中。图片由马丁·托马斯提供。</figcaption></figure><p id="a4ec" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi lu translated"><span class="l lv lw lx bm ly lz ma mb mc di"> P </span>防止代码重复是一个软件开发原理，叫做<a class="ae md" href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself" rel="noopener ugc nofollow" target="_blank"><em class="me"/></a>—<strong class="la iu">D</strong>on<strong class="la iu">R</strong>EPE at<strong class="la iu">Y</strong>yourself。DRY很重要，因为重复的代码通常意味着需要维护更多的代码。如果你需要修复一个bug，你需要修复所有重复的地方。如果您需要扩展功能，您需要在代码的多个部分进行扩展。当一个新的开发人员调整重复代码的一部分，而忘记调整其他地方时，情况会变得更加复杂。</p><p id="642c" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有两种非常不同的方法来保持你的代码干燥:把共享代码放在一个库中或者放在一个服务中。Eric Knipp称之为“共享能力”(<a class="ae md" href="https://blogs.gartner.com/eric-knipp/2013/03/20/libraries-vs-services/" rel="noopener ugc nofollow" target="_blank"> source </a>)，这已经表明了抽象的不同。当您与服务交互时，您通常不想关心该服务的实现细节。在库中，您可能会更多地考虑运行时的复杂性，甚至偶尔会跳入代码中。</p><p id="af00" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">读完这篇文章，你会知道图书馆和服务之间的区别，以及什么时候你应该使用其中的一个。开始吧！</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="e94d" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">差异</h1><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ne"><img src="../Images/70235174474210e549df6776ca36b873.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7euF5Y587KTF-LS8"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">照片由<a class="ae md" href="https://unsplash.com/@cooljonez?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">丹尼斯·琼斯</a>在<a class="ae md" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="031e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">库是与每个应用程序一起部署的共享代码。所以这个库是应用程序的一部分，和应用程序运行在同一台机器上。库是通过函数调用来访问的。</p><p id="07e6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">相比之下，服务有自己的基础设施。这意味着它有自己的机器，但也有日志记录、监控、警报，可能还有一个随叫随到的团队来解决问题。它独立于应用程序进行部署。更新可以在服务用户没有注意到有任何变化的情况下推出。</p><p id="9811" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">通常，当我与服务交互时，我喜欢将这种交互保留在代码的一部分中。我喜欢为我交互的每个服务编写一个自己的模块。这个模块只负责服务交互。在某些情况下，服务提供这样的模块，例如用于与AWS服务交互的boto3库。我想说的是:如果你创建一个服务，你可能最终会创建一个服务<em class="me">和</em>一个小库。</p><p id="2aa5" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">让我们深入探讨这种或那种解决方案的不同论点吧！</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="6684" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">#1:通话速度</h1><p id="17bd" class="pw-post-body-paragraph ky kz it la b lb nf ju ld le ng jx lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">本地机器上的函数调用在几纳秒内执行，而网络请求需要几毫秒。您可以预期网络请求比内部函数调用花费的时间多1，000，000倍。</p><p id="eebd" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请记住，这只是涵盖了沟通的部分，而不是实际的工作。如果要计算圆周率的第一千亿位，通信速度与工作量相比相形见绌。因此，如果呼叫的工作量很快，那么呼叫的速度只是一个参数。如果是的话，这一点显然属于图书馆。</p><h1 id="70be" class="mm mn it bd mo mp nk mr ms mt nl mv mw jz nm ka my kc nn kd na kf no kg nc nd bi translated">#2:通话的可靠性</h1><p id="8686" class="pw-post-body-paragraph ky kz it la b lb nf ju ld le ng jx lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">网络总是失败。CPU指令也可能失败，但这种情况非常罕见，大多数开发人员可以安全地忽略这种情况。</p><p id="97fe" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您有网络连接，您需要处理超时。您需要处理不可用的服务。因此，商业服务通常会提供服务级别协议(SLA)。有了SLA，您可以了解服务是否可能离线太长时间，或者有一段时间可能会严重影响您自己的SLA。</p><p id="6e73" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这一点显然适用于图书馆。</p><h1 id="1bd4" class="mm mn it bd mo mp nk mr ms mt nl mv mw jz nm ka my kc nn kd na kf no kg nc nd bi translated">#3:基础设施</h1><p id="fa79" class="pw-post-body-paragraph ky kz it la b lb nf ju ld le ng jx lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">服务通常带有自己的基础设施。它有自己的机器。这意味着您必须比在库的情况下多照顾一台机器。但这并没有结束。如果您有服务，您需要确保您有日志记录、监控、警报和潜在的随叫随到团队。</p><p id="a374" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这使得创建库比创建服务更简单。</p><h1 id="d599" class="mm mn it bd mo mp nk mr ms mt nl mv mw jz nm ka my kc nn kd na kf no kg nc nd bi translated">#4:开发开销</h1><p id="9eaf" class="pw-post-body-paragraph ky kz it la b lb nf ju ld le ng jx lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">我们试图遵循DRY原则的一个核心原因是保持低开发和维护成本。如果我们创建一个服务，与库相比，它会带来很多开销。</p><p id="9273" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">一方面，是已经提到的基础设施成本。另一方面，你现在必须考虑秘密管理和<a class="ae md" href="https://medium.com/plain-and-simple/identification-vs-authentication-vs-authorization-e1f03a0ca885" rel="noopener">认证/授权</a>。如何确保只有授权用户才能访问新服务？</p><h1 id="f7df" class="mm mn it bd mo mp nk mr ms mt nl mv mw jz nm ka my kc nn kd na kf no kg nc nd bi translated">#5:可扩展性</h1><p id="ff3b" class="pw-post-body-paragraph ky kz it la b lb nf ju ld le ng jx lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">您可以<a class="ae md" href="https://medium.com/plain-and-simple/scaling-vertically-vs-scaling-horizontally-82547a77d925" rel="noopener">水平或垂直扩展应用程序</a>。纵向扩展意味着购买更大的机器，横向扩展意味着购买第二台机器。购买更大的机器是琐碎和便宜的，直到某一点。从那时起，这就变得不可能了。如果你幸运的话，你永远不会觉得需要垂直扩展。纵向扩展要复杂得多，而且您需要在这上面花费开发时间，这通常会增加成本。</p><p id="7d67" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你有一个独立的服务，你可能已经接近一个允许你纵向扩展的架构。然而，这对于服务来说并不是一个强有力的论据，因为您需要关注服务的基础设施。您只是提前支付了成本，即基础设施的争论。</p><h1 id="066e" class="mm mn it bd mo mp nk mr ms mt nl mv mw jz nm ka my kc nn kd na kf no kg nc nd bi translated">#6:开发的灵活性</h1><p id="b55f" class="pw-post-body-paragraph ky kz it la b lb nf ju ld le ng jx lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">不同的问题需要不同的解决方案。你甚至可能想为你的部分代码转换编程语言，因为一个领域的社区更强大。虽然Python和许多其他编程语言都提供了外部函数接口(<a class="ae md" href="https://en.wikipedia.org/wiki/Foreign_function_interface" rel="noopener ugc nofollow" target="_blank"> FFIs </a>)，但是用不同的服务完全封装这部分可能更简单。</p><p id="ab86" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意，我认为开发中的灵活性是一个强有力的论据，但缺乏关于FFI如何工作的知识是一个弱有力的论据。如果你有不同的团队在不同的主题上工作，如果网络造成的开销不相关，那么就使用服务。</p><h1 id="af8a" class="mm mn it bd mo mp nk mr ms mt nl mv mw jz nm ka my kc nn kd na kf no kg nc nd bi translated">#7:共享状态</h1><p id="bafe" class="pw-post-body-paragraph ky kz it la b lb nf ju ld le ng jx lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">如果我们的代码有一个无状态的部分，这表明库可能是一个好的解决方案。如果你有一个共享状态，也许一个服务更好。</p><p id="7569" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我目前正在考虑的一个具体案例是一个外部服务，它可能不像我希望的那样可靠或快速。它需要包装在一个本地“缓存”层中，该层还抽象出外部服务的一些复杂性。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi np"><img src="../Images/59c6febaedccf172dc0f95bd569c4ed5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xu910lcIyGBY8vauh_f4Fw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图片作者:马丁·托马斯</figcaption></figure><p id="86fe" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在这种情况下，并不清楚库选项比应用程序选项更好还是更差。对数据的处理使我倾向于使用服务，但是我需要处理网络的不可靠性。访问这些数据肯定需要更长的时间。</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="70c4" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">图书馆与服务:一些简单的例子</h1><p id="52bd" class="pw-post-body-paragraph ky kz it la b lb nf ju ld le ng jx lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">世界是复杂的，我不能给你一个5步指南来决定你是否应该使用服务或图书馆。在上面这种情况下，情况就不那么明朗了。但是有一些简单的例子:</p><ul class=""><li id="7354" class="nq nr it la b lb lc le lf lh ns ll nt lp nu lt nv nw nx ny bi translated"><strong class="la iu">纯算法，无共享状态</strong>:如果你只想共享算法或者一些常量(例如HTTP状态码，国家名称/代码，货币，时区)，这是一个非常明确的指示，你想要一个<strong class="la iu">库</strong>。我想到的例子有<a class="ae md" href="https://numpy.org/" rel="noopener ugc nofollow" target="_blank"> Numpy </a>，<a class="ae md" href="https://www.scipy.org/" rel="noopener ugc nofollow" target="_blank"> Scipy </a>，<a class="ae md" href="https://www.tensorflow.org/" rel="noopener ugc nofollow" target="_blank"> Tensorflow </a>，</li><li id="de15" class="nq nr it la b lb nz le oa lh ob ll oc lp od lt nv nw nx ny bi translated"><strong class="la iu">拥有大量数据的算法</strong>:<a class="ae md" href="https://developers.google.com/maps" rel="noopener ugc nofollow" target="_blank">谷歌地图</a>服务具有复杂的功能，比如“离这个GPS点最近的地址是哪里？”或者“从A到B最快的路线是什么？”结合大量数据来支持这些算法。服务很繁重，需要定期更新数据，实现这一点的基础架构非常复杂。利用这一点的应用程序非常简单:画出我的跑步路线。在我的导航系统中显示最快的路线。计算一下我邻居的房产面积。编写一个<strong class="la iu">服务</strong>来消除沉重的基础设施负担是一个好主意。</li><li id="b34a" class="nq nr it la b lb nz le oa lh ob ll oc lp od lt nv nw nx ny bi translated"><strong class="la iu">需要大量内存</strong>:如果你有一部分代码经常需要大量内存，你可能想把它放在自己的机器上。这样，您可以更长时间地保持纵向可伸缩性。在某些情况下，像只做预测的机器学习应用程序，扩展是微不足道的:只需旋转另一台机器并以循环方式(或类似方式)服务请求。你没有一个共享的状态，只有需要在内存中的模型。所有翻译和OCR <strong class="la iu">服务</strong>都是很好的例子。</li><li id="2ae4" class="nq nr it la b lb nz le oa lh ob ll oc lp od lt nv nw nx ny bi translated"><strong class="la iu">只有粉碎状态，没有算法</strong>:你可以考虑只给<strong class="la iu">直接数据库访问</strong>。请注意，这有其自身的问题，从长远来看，这不太可能是一个好的解决方案。这可能是一个可以接受的中间解决办法。</li></ul></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="a0a1" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">过渡</h1><p id="ac33" class="pw-post-body-paragraph ky kz it la b lb nf ju ld le ng jx lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">大型软件项目通常不是从零开始创建的，而是随着时间的推移而发展的。它始于“<strong class="la iu">完成工作</strong>”阶段，在这个阶段，开发人员将所有东西都放在他们的本地机器或托管的web服务上。</p><p id="548e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果事情很严重，就会进入“可靠性很重要”的阶段。在这个阶段，开发人员开始考虑如何处理更多的用户，如何以不中断用户的方式进行部署，多种环境，如本地/开发/试运行/生产、日志记录、监控和警报。开发人员开始在多台机器上运行东西，例如，数据库和应用程序在不同的机器上，特别是CPU密集型的东西在另一台机器上。由于AWS，这在过去几年变得简单多了。</p><p id="5ff6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在某种程度上，需要扩大开发规模。如果你有几十个开发人员，你需要确保不是每个人都需要知道所有的事情。你需要<strong class="la iu">规模化发展</strong>。你需要对软件进行分区。软件可以根据它们提供的价值类型来划分。团队有明确定义的责任，并拥有他们的技术堆栈——代码、基础设施和操作。他们需要与客户交流，需要定义他们的接口。</p><p id="94c2" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">作为一个图像，它可能看起来像这样:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi oe"><img src="../Images/a7d23932319f81cbc1804aefc071b03a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kjoWuYzW7uBElxCha98FIA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">图片作者:马丁·托马斯</figcaption></figure><p id="6210" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我见过几次的一种转变是，首先创建一个整体，让业务运转起来。当公司成长时，他们按照业务功能构建整体。例如，可能有处理会计的模块和处理分析的其他模块。当整体变得非常难以维护时，因为一切都依赖于其他一切，(微)服务被从整体中剔除。</p><p id="1b36" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">我目前考虑的一个中间解决方案是上面描述的(潜在不可靠的)外部服务的问题。有可能首先创建一个库解决方案，其中不同的应用程序可以具有状态的不同部分。两个应用程序中可能都有少量数据。多个应用程序中的数据很难从库解决方案转移到服务解决方案，因为必须考虑同步机制。</p></div><div class="ab cl mf mg hx mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="im in io ip iq"><h1 id="b8e2" class="mm mn it bd mo mp mq mr ms mt mu mv mw jz mx ka my kc mz kd na kf nb kg nc nd bi translated">摘要</h1><p id="a4f4" class="pw-post-body-paragraph ky kz it la b lb nf ju ld le ng jx lg lh nh lj lk ll ni ln lo lp nj lr ls lt im bi translated">库和服务让你的代码保持干燥(<strong class="la iu">d</strong>on t<strong class="la iu">r</strong>EPE at<strong class="la iu">y</strong>yourself)。库更多地集成到应用程序中，构建它们的前期成本更低。服务在基础设施级别上提供了明确的分离，但是您需要考虑网络请求的问题。</p><p id="ecd9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在许多情况下，从一个图书馆到一个服务是微不足道的。一段时间后，从一个服务转向一个图书馆可能是完全不可行的。</p></div></div>    
</body>
</html>