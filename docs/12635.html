<html>
<head>
<title>Java Algorithms: Binary Tree Right Side View (LeetCode)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java算法:二叉树右侧视图(LeetCode)</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/java-algorithms-binary-tree-right-side-view-leetcode-69e69430e2d1?source=collection_archive---------1-----------------------#2022-06-26">https://levelup.gitconnected.com/java-algorithms-binary-tree-right-side-view-leetcode-69e69430e2d1?source=collection_archive---------1-----------------------#2022-06-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/aff858e133b08f996a2bd56556f2f102.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Tr4_8bVQ1NqqestS"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">图为<a class="ae kc" href="https://unsplash.com/@toddquackenbush?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">托德·夸肯布什</a>在<a class="ae kc" href="https://unsplash.com/s/photos/binary-tree?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></figcaption></figure><h2 id="5476" class="kd ke iq bd kf kg kh dn ki kj kk dp kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">任务描述:</h2><p id="88bb" class="pw-post-body-paragraph kz la iq lb b lc ld le lf lg lh li lj km lk ll lm kq ln lo lp ku lq lr ls lt ij bi translated">给定二叉树的<code class="fe lu lv lw lx b">root</code>，想象你站在二叉树的<strong class="lb ir">右侧</strong>，返回<em class="ly">你能看到的从上到下排序的节点的值</em>。</p><p id="0a5b" class="pw-post-body-paragraph kz la iq lb b lc lz le lf lg ma li lj km mb ll lm kq mc lo lp ku md lr ls lt ij bi translated"><strong class="lb ir">例1: </strong></p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div class="gh gi me"><img src="../Images/8bad9840c9951a7580458181cc9aa3f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:802/format:webp/0*SHJZL2GFAnYGTWs8.jpg"/></div></figure><pre class="mf mg mh mi gt mj lx mk ml aw mm bi"><span id="ce1d" class="kd ke iq lx b gy mn mo l mp mq"><strong class="lx ir">Input:</strong> root = [1,2,3,null,5,null,4]<br/><strong class="lx ir">Output:</strong> [1,3,4]</span></pre><p id="7c7d" class="pw-post-body-paragraph kz la iq lb b lc lz le lf lg ma li lj km mb ll lm kq mc lo lp ku md lr ls lt ij bi translated"><strong class="lb ir">例2: </strong></p><pre class="mf mg mh mi gt mj lx mk ml aw mm bi"><span id="ac20" class="kd ke iq lx b gy mn mo l mp mq"><strong class="lx ir">Input:</strong> root = [1,null,3]<br/><strong class="lx ir">Output:</strong> [1,3]</span></pre><p id="06c5" class="pw-post-body-paragraph kz la iq lb b lc lz le lf lg ma li lj km mb ll lm kq mc lo lp ku md lr ls lt ij bi translated"><strong class="lb ir">例3: </strong></p><pre class="mf mg mh mi gt mj lx mk ml aw mm bi"><span id="fb6f" class="kd ke iq lx b gy mn mo l mp mq"><strong class="lx ir">Input:</strong> root = []<br/><strong class="lx ir">Output:</strong> []</span></pre><p id="1741" class="pw-post-body-paragraph kz la iq lb b lc lz le lf lg ma li lj km mb ll lm kq mc lo lp ku md lr ls lt ij bi translated"><strong class="lb ir">约束:</strong></p><ul class=""><li id="8fb6" class="mr ms iq lb b lc lz lg ma km mt kq mu ku mv lt mw mx my mz bi translated">树中的节点数量在范围<code class="fe lu lv lw lx b">[0, 100]</code>内。</li><li id="6cfb" class="mr ms iq lb b lc na lg nb km nc kq nd ku ne lt mw mx my mz bi translated"><code class="fe lu lv lw lx b">-100 &lt;= Node.val &lt;= 100</code></li></ul><h2 id="4f6e" class="kd ke iq bd kf kg kh dn ki kj kk dp kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">推理:</h2><p id="9b2d" class="pw-post-body-paragraph kz la iq lb b lc ld le lf lg lh li lj km lk ll lm kq ln lo lp ku lq lr ls lt ij bi translated">我认为这是一个在编码面试中很常见的问题。乍一看，它似乎很容易实现。这是错误的感觉。你这样想是因为提供了例子。让我给你看另一个不那么容易的例子。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/ebc3a6c6d9936380f4023e88b7103674.png" data-original-src="https://miro.medium.com/v2/resize:fit:680/format:webp/1*zH01YxqogKI4lJXH6L5HXA.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">第一个例子</figcaption></figure><p id="b0e6" class="pw-post-body-paragraph kz la iq lb b lc lz le lf lg ma li lj km mb ll lm kq mc lo lp ku md lr ls lt ij bi translated">你怎么看待这个例子？对你来说还是那么明显吗？如果你的答案是肯定的，让我再试一次</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/751eb2d64d39b9a44f908a8cac8aea8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*pBXrx1x8izjDmdsKlTHcHA.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">第二个例子</figcaption></figure><p id="8714" class="pw-post-body-paragraph kz la iq lb b lc lz le lf lg ma li lj km mb ll lm kq mc lo lp ku md lr ls lt ij bi translated">还那么明显吗？我不这么认为。如果你不同意我的观点，你可以停止阅读，尝试实现你自己的解决方案。对于那些感到困惑的人，请和我在一起。</p><p id="70f7" class="pw-post-body-paragraph kz la iq lb b lc lz le lf lg ma li lj km mb ll lm kq mc lo lp ku md lr ls lt ij bi translated">让我们介绍水平的概念:</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/8a840279bea1aab38ff2f29584cc762b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*vejBVRGNe4v97aLIR4CVKQ.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">二叉树的层次</figcaption></figure><p id="f717" class="pw-post-body-paragraph kz la iq lb b lc lz le lf lg ma li lj km mb ll lm kq mc lo lp ku md lr ls lt ij bi translated">使用简单的词语——将二叉树中特定节点的级别视为该节点的深度。或者换句话说，从树根开始到特定的节点，你需要向下走多少步。</p><p id="abed" class="pw-post-body-paragraph kz la iq lb b lc lz le lf lg ma li lj km mb ll lm kq mc lo lp ku md lr ls lt ij bi translated">我想此时你已经意识到我们需要遍历一个二叉树中的每个节点，对于每个节点，我们只需要回答一个问题。这个节点是同级中最正确的节点吗？就这么简单。</p><h2 id="051f" class="kd ke iq bd kf kg kh dn ki kj kk dp kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">解决方案:</h2><p id="addc" class="pw-post-body-paragraph kz la iq lb b lc ld le lf lg lh li lj km lk ll lm kq ln lo lp ku lq lr ls lt ij bi translated">我将使用递归方法来解释解决方案。我们需要引入一个集合来存储我们的答案。</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="8a64" class="pw-post-body-paragraph kz la iq lb b lc lz le lf lg ma li lj km mb ll lm kq mc lo lp ku md lr ls lt ij bi translated">如果我们得到空的根节点，我们可以立即返回空的集合。</p><p id="908c" class="pw-post-body-paragraph kz la iq lb b lc lz le lf lg ma li lj km mb ll lm kq mc lo lp ku md lr ls lt ij bi translated">我还引入了一个HashMap来存储我们是否访问了特定级别的信息</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="2965" class="pw-post-body-paragraph kz la iq lb b lc lz le lf lg ma li lj km mb ll lm kq mc lo lp ku md lr ls lt ij bi translated">是时候介绍一下主要逻辑在里面的递归方法了。</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="775c" class="pw-post-body-paragraph kz la iq lb b lc lz le lf lg ma li lj km mb ll lm kq mc lo lp ku md lr ls lt ij bi translated">该方法中有三点很重要:</p><ol class=""><li id="7d5e" class="mr ms iq lb b lc lz lg ma km mt kq mu ku mv lt nj mx my mz bi translated">我们需要在某个时候停止探索树，如果我们到达的节点为空，我们就停止探索</li><li id="a774" class="mr ms iq lb b lc na lg nb km nc kq nd ku ne lt nj mx my mz bi translated">当我们访问节点时，我们希望检查它是否是这个特定级别上最合适的节点。如果是这样，我们存储它并将这个节点添加到存储答案的集合中。</li><li id="76f1" class="mr ms iq lb b lc na lg nb km nc kq nd ku ne lt nj mx my mz bi translated">我们如何探索这棵树很重要。你可能已经猜到，只要我们被要求在每一层提供最右边的节点，我们就想先去当前节点的右边的子节点，然后去左边的。</li></ol><p id="2068" class="pw-post-body-paragraph kz la iq lb b lc lz le lf lg ma li lj km mb ll lm kq mc lo lp ku md lr ls lt ij bi translated">完整的解决方案是这样的</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="4d7a" class="pw-post-body-paragraph kz la iq lb b lc lz le lf lg ma li lj km mb ll lm kq mc lo lp ku md lr ls lt ij bi translated">这段代码给了我们线性的时间和空间复杂度，并且执行得相当好。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/150563f6171eda97943d4bd04a94311e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/1*IoLwfyviXNcQ6iI19WTrVw.png"/></div></figure><p id="bd33" class="pw-post-body-paragraph kz la iq lb b lc lz le lf lg ma li lj km mb ll lm kq mc lo lp ku md lr ls lt ij bi translated">下一篇文章再见🙃🙃🙃🙃🙃🙃🙃🙃🙃🙃🙃🙃🙃🙃🙃</p></div><div class="ab cl nl nm hu nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ij ik il im in"><h1 id="62d8" class="ns ke iq bd kf nt nu nv ki nw nx ny kl nz oa ob kp oc od oe kt of og oh kx oi bi translated">分级编码</h1><p id="c5a1" class="pw-post-body-paragraph kz la iq lb b lc ld le lf lg lh li lj km lk ll lm kq ln lo lp ku lq lr ls lt ij bi translated">感谢您成为我们社区的一员！更多内容见<a class="ae kc" href="https://levelup.gitconnected.com/" rel="noopener ugc nofollow" target="_blank">级编码出版物</a>。<br/>跟随:<a class="ae kc" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">推特</a>，<a class="ae kc" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank">领英</a>，<a class="ae kc" href="https://newsletter.levelup.dev/" rel="noopener ugc nofollow" target="_blank">通迅</a> <br/> <strong class="lb ir">升一级正在改造理工大招聘➡️ </strong> <a class="ae kc" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="lb ir">加入我们的人才集体</strong> </a></p></div></div>    
</body>
</html>