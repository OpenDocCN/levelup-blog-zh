<html>
<head>
<title>Send and track faxes with the Twilio Fax API using Sinatra and Ruby</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Sinatra和Ruby通过Twilio传真API发送和跟踪传真</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/send-and-track-faxes-with-the-twilio-fax-api-using-sinatra-and-ruby-f0e87a05039f?source=collection_archive---------17-----------------------#2020-01-30">https://levelup.gitconnected.com/send-and-track-faxes-with-the-twilio-fax-api-using-sinatra-and-ruby-f0e87a05039f?source=collection_archive---------17-----------------------#2020-01-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/e94b5af7be8cd3018e9d5b7474c94fb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JhPLae1EpNUrJ9DpQmaNNg.png"/></div></div></figure><p id="a161" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">发生了！自从2017年Twilio推出可编程传真API以来，我一直在等待我需要发送传真的时刻，这一天终于到来了！我不会详细说明我需要发送什么，但可以肯定地说，医疗行业可以考虑他们未来的通信选择。</p><p id="e6d5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我本可以通过使用API explorer 将PDF上传到<a class="ae kw" href="https://www.twilio.com/docs/runtime/assets" rel="noopener ugc nofollow" target="_blank"> Twilio Assets </a>和<a class="ae kw" href="https://www.twilio.com/console/api-explorer/fax" rel="noopener ugc nofollow" target="_blank">来发送传真，但这不会像过度设计整个应用程序来发送和跟踪传真以确保传真到达并为任何未来的传真情况做好准备那样有趣。</a></p><p id="1a18" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这篇文章中，我将分享如何构建一个发送和跟踪传真的应用程序，但如果你有传真要发送，并想直接使用它，你可以在GitHub 上找到<a class="ae kw" href="https://github.com/philnash/twilio-fax-ruby-sinatra" rel="noopener ugc nofollow" target="_blank">所有的源代码。</a></p><h1 id="d811" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">首选武器</h1><p id="7be2" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">当发送传真时，它更像是打电话而不是发送信息。因此，它可能会像打电话一样失败，例如，如果它收到忙音。因此，在开发这个应用程序的时候，我希望它足够简单，能够快速组装，但又足够强大，能够支持发送和接收传真的状态更新。</p><p id="9cc2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我决定选择鲁比，和辛纳特拉。要开始这项工作，您需要:</p><ul class=""><li id="227e" class="ma mb iq ka b kb kc kf kg kj mc kn md kr me kv mf mg mh mi bi translated"><a class="ae kw" href="https://www.ruby-lang.org/en/downloads/" rel="noopener ugc nofollow" target="_blank"> Ruby安装了</a>，我推荐最新版本，2.6.5</li><li id="335a" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated"><a class="ae kw" href="https://bundler.io/" rel="noopener ugc nofollow" target="_blank">捆绑器</a>用于安装依赖项</li><li id="9f9a" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated"><a class="ae kw" href="https://ngrok.com/" rel="noopener ugc nofollow" target="_blank"> ngrok </a>这样我们就可以<a class="ae kw" href="https://www.twilio.com/blog/2015/09/6-awesome-reasons-to-use-ngrok-when-testing-webhooks.html" rel="noopener ugc nofollow" target="_blank">以样式</a>公开webhook端点</li><li id="b365" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">一个有传真号码的Twilio账户</li></ul><p id="09cf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这应该足以让这个应用程序建立起来，所以让我们开始吧。</p><h1 id="78cf" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">应用程序外壳</h1><p id="a20b" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">在实际发送传真之前，让我们设置应用程序并确保它正常工作。创建一个新的工作目录，并在命令行上切换到该目录。</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="56b4" class="mx ky iq mt b gy my mz l na nb">mkdir fax_app<br/>cd fax_app</span></pre><p id="6a63" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过调用以下命令初始化新应用程序:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="8ce7" class="mx ky iq mt b gy my mz l na nb">bundle init</span></pre><p id="ab45" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">添加我们将用于构建该应用程序的gem:</p><ul class=""><li id="07b5" class="ma mb iq ka b kb kc kf kg kj mc kn md kr me kv mf mg mh mi bi translated">一个简单的网络框架</li><li id="4391" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated"><a class="ae kw" href="https://github.com/twilio/twilio-ruby" rel="noopener ugc nofollow" target="_blank"> twilio-ruby gem </a>与<a class="ae kw" href="https://www.twilio.com/docs/fax" rel="noopener ugc nofollow" target="_blank"> Twilio Fax API </a>交互</li><li id="22ae" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">霰弹枪以便服务器在我们做出更改时重新加载</li><li id="0c02" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated"><a class="ae kw" href="https://github.com/philnash/envyable" rel="noopener ugc nofollow" target="_blank">envable</a>至<a class="ae kw" href="https://www.twilio.com/blog/2015/02/managing-development-environment-variables-across-multiple-ruby-applications.html" rel="noopener ugc nofollow" target="_blank">管理应用程序中的环境变量</a></li></ul><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="a2c6" class="mx ky iq mt b gy my mz l na nb">bundle add sinatra twilio-ruby shotgun envyable</span></pre><p id="89b1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">创建应用程序结构:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="61ce" class="mx ky iq mt b gy my mz l na nb">mkdir views public config files<br/>touch app.rb config.ru views/layout.erb views/index.erb public/style.css config/env.yml</span></pre><p id="a190" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将保存我们的应用程序配置。打开它并添加以下内容:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="f2bf" class="mx ky iq mt b gy my mz l na nb">TWILIO_ACCOUNT_SID: <br/>TWILIO_AUTH_TOKEN: <br/>FROM_NUMBER: <br/>URL_BASE:</span></pre><p id="82cb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从您的<a class="ae kw" href="https://www.twilio.com/console" rel="noopener ugc nofollow" target="_blank"> Twilio控制台</a>填写帐户SID和身份验证令牌。对于发件人号码，从您的Twilio账户添加一个<a class="ae kw" href="https://www.twilio.com/console/phone-numbers/incoming" rel="noopener ugc nofollow" target="_blank">传真号码。稍后我们将填写<code class="fe nc nd ne mt b">URL_BASE</code>。</a></p><p id="fe36" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe nc nd ne mt b">config.ru</code>是启动我们的应用程序的文件。我们将需要应用程序依赖性，从<code class="fe nc nd ne mt b">config/env.yml</code>加载环境变量，加载应用程序，然后运行它。添加以下代码来完成所有这些工作:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="887a" class="mx ky iq mt b gy my mz l na nb">require 'bundler'<br/>Bundler.require<br/><br/>Envyable.load('./config/env.yml')<br/><br/>require './app.rb'<br/>run FaxApp</span></pre><p id="5911" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了确保到目前为止一切正常，我们将构建一个“Hello World！”端点作为我们应用的起点。打开app.rb并添加以下内容:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="5fdc" class="mx ky iq mt b gy my mz l na nb">require 'sinatra/base'<br/><br/>class FaxApp &lt; Sinatra::Base<br/>  get '/' do<br/>    "Hello World!"<br/>  end<br/>end</span></pre><p id="936c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这创建了一个返回文本“Hello World！”作为对加载根路径的响应。使用以下内容运行应用程序:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="a2ac" class="mx ky iq mt b gy my mz l na nb">bundle exec shotgun config.ru -p 3000</span></pre><p id="00a0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">打开<a class="ae kw" href="http://localhost:3000" rel="noopener ugc nofollow" target="_blank"> localhost:3000 </a>，应该说“Hello World！”如果是这样，那么我们就在正确的轨道上。</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/4d3024915d18abf09bc8ab034018575b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*nDnqbE6p7eck28ta.png"/></div></figure><p id="f768" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，让我们构建应用程序的界面。</p><h1 id="782e" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">构建界面</h1><p id="a62e" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">在Sinatra中，默认情况下使用嵌入了Ruby的ERB来呈现视图。默认情况下，Sinatra会在<code class="fe nc nd ne mt b">views/layout.erb</code>寻找版面。我们已经创建了该文件，让我们添加以下HTML结构:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="e32f" class="mx ky iq mt b gy my mz l na nb">&lt;!DOCTYPE html&gt;<br/>&lt;html lang="en"&gt;<br/>&lt;head&gt;<br/>  &lt;meta charset="UTF-8"&gt;<br/>  &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;<br/>  &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt;<br/>  &lt;link rel="stylesheet" href="/style.css"&gt;<br/>  &lt;title&gt;FaxApp&lt;/title&gt;<br/>&lt;/head&gt;<br/>&lt;body&gt;<br/>  &lt;header&gt;<br/>    &lt;h1&gt;FaxApp&lt;/h1&gt;<br/>  &lt;/header&gt;<br/>  &lt;main&gt;<br/>    &lt;%= yield %&gt;<br/>  &lt;/main&gt;<br/>  &lt;footer&gt;<br/>    &lt;p&gt;Built with 📠 by &lt;a href="https://twitter.com/philnash"&gt;philnash&lt;/a&gt;&lt;/p&gt;<br/>  &lt;/footer&gt;<br/>&lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="94ba" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里最重要的部分是中间的<code class="fe nc nd ne mt b">&lt;%= yield %&gt;</code>。这是插入单个视图模板的位置。</p><p id="12d2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们添加一些风格，使应用程序看起来也很好。在GitHub 上打开<code class="fe nc nd ne mt b">public/style.css</code>并复制到<a class="ae kw" href="https://raw.githubusercontent.com/philnash/twilio-fax-ruby-sinatra/master/public/style.css" rel="noopener ugc nofollow" target="_blank">中的CSS文件中。</a></p><p id="b52d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">打开<code class="fe nc nd ne mt b">views/index.erb</code>。现在我们需要构建一个表单来收集我们要发送传真的号码和一个PDF文件，Twilio API会将这个PDF文件转换成传真。在<code class="fe nc nd ne mt b">views/index.erb</code>中增加以下内容:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="f483" class="mx ky iq mt b gy my mz l na nb">&lt;h2&gt;Send a new Fax&lt;/h2&gt;<br/><br/>&lt;form method="POST" action="/faxes" enctype="multipart/form-data"&gt;<br/>  &lt;div&gt;<br/>    &lt;label for="number"&gt;Fax number&lt;/label&gt;<br/>    &lt;input type="tel" id="number" name="number" required /&gt;<br/>  &lt;/div&gt;<br/>  &lt;div&gt;<br/>    &lt;label for="file"&gt;PDF file&lt;/label&gt;<br/>    &lt;input type="file" id="file" name="file" required accept="application/pdf" /&gt;<br/>  &lt;/div&gt;<br/>  &lt;div&gt;<br/>    &lt;button type="submit"&gt;Send&lt;/button&gt;<br/>  &lt;/div&gt;<br/>&lt;/form&gt;</span></pre><p id="f7c8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个表单中，我们将方法设置为<code class="fe nc nd ne mt b">POST</code>，将<code class="fe nc nd ne mt b">enctype</code>设置为<code class="fe nc nd ne mt b">multipart/form-data</code>，这样我们就可以用它将文件上传到服务器。我们已经将<code class="fe nc nd ne mt b">action</code>设置为<code class="fe nc nd ne mt b">/faxes</code>，这是我们即将构建的一个端点。我们还使用了一些HTML表单验证来确保我们输入的值是正确的，两个输入字段都是必需的，传真号码字段是类型<code class="fe nc nd ne mt b">tel</code>并且文件输入只接受PDF文件。</p><p id="748b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">再次打开<code class="fe nc nd ne mt b">app.rb</code>。我们现在想改变我们的“Hello World！”改为端点渲染<code class="fe nc nd ne mt b">views/index.erb</code>。我们用<code class="fe nc nd ne mt b">erb</code>助手方法来做这件事。</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="fcd4" class="mx ky iq mt b gy my mz l na nb">class FaxApp &lt; Sinatra::Base<br/>  get '/' do<br/>    erb :index<br/>  end<br/>end</span></pre><p id="948b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果应用程序仍在运行，请在<a class="ae kw" href="http://localhost:3000" rel="noopener ugc nofollow" target="_blank"> localhost:3000 </a>处再次检查。它应该是这样的:</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/fa2b02994433e5405467b1e00766a03d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*S_XOZ93wznHrOcLK.png"/></div></figure><p id="98ac" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接口完成了，现在让我们构建后端并实际发送一些传真！</p><h1 id="7a05" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">发送传真</h1><p id="7822" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">正如我们提到的，我们需要创建<code class="fe nc nd ne mt b">/faxes</code>端点。它需要做几件事:</p><ul class=""><li id="ccba" class="ma mb iq ka b kb kc kf kg kj mc kn md kr me kv mf mg mh mi bi translated">回复帖子请求</li><li id="fdd8" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">存储我们正在上传的PDF文件</li><li id="932a" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">向Twilio Fax API发出创建传真的请求</li><li id="5448" class="ma mb iq ka b kb mj kf mk kj ml kn mm kr mn kv mf mg mh mi bi translated">最后重定向回主页</li></ul><p id="3d9a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了响应POST请求，我们使用Sinatra <code class="fe nc nd ne mt b">post</code>方法。在<code class="fe nc nd ne mt b">app.rb</code>中，将其添加到应用程序类:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="6705" class="mx ky iq mt b gy my mz l na nb">  post '/faxes' do<br/><br/>  end</span></pre><p id="0c3b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以使用<code class="fe nc nd ne mt b">params</code>散列获得提交给端点的文件和其他参数。</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="f23e" class="mx ky iq mt b gy my mz l na nb">  post '/faxes' do<br/>    filename = params[:file][:filename]<br/>    file = params[:file][:tempfile]<br/>    to = params[:number]<br/>  end</span></pre><p id="d285" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们有一个已上传的文件，我们会将其写入应用程序中的<code class="fe nc nd ne mt b">files</code>目录:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="1e10" class="mx ky iq mt b gy my mz l na nb">  post '/faxes' do<br/>    filename = params[:file][:filename]<br/>    file = params[:file][:tempfile]<br/>    to = params[:number]<br/><br/>    if file<br/>      File.open("./files/#{filename}", 'wb') do |f|<br/>        f.write(file.read)<br/>      end<br/>    end<br/>  end</span></pre><p id="2a3f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们将创建一个Twilio API客户机，用我们的凭证授权它，并调用API来发送传真。我们将使用在<code class="fe nc nd ne mt b">config/env.yml</code>中设置的<code class="fe nc nd ne mt b">FROM_NUMBER</code>作为传真的发件人号码，收件人号码来自表单参数，我们需要发送一个指向传真的<code class="fe nc nd ne mt b">media_url</code>。</p><p id="478b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当Twilio连接到我们要发送的传真机时，它会发出一个webhook请求来检索我们要作为传真发送的PDF文件。因此，我们需要提供该PDF文件的URL。我们还没有定义上传文件的服务方式，但这是我们下一步要做的事情。现在，使用下面的内容作为<code class="fe nc nd ne mt b">media_url</code> : <code class="fe nc nd ne mt b">media_url: "#{ENV["URL_BASE"]}/faxes/files/#{ERB::Util.url_encode(filename)}"</code>。结束端点，重定向回根路径。</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="f1ca" class="mx ky iq mt b gy my mz l na nb">  post '/faxes' do<br/>    filename = params[:file][:filename]<br/>    file = params[:file][:tempfile]<br/>    to = params[:number]<br/><br/>    if file<br/>      File.open("./files/#{filename}", 'wb') do |f|<br/>        f.write(file.read)<br/>      end<br/><br/>      client = Twilio::REST::Client.new(ENV['TWILIO_ACCOUNT_SID'], ENV['TWILIO_AUTH_TOKEN'])<br/>      client.fax.faxes.create(<br/>        from: ENV['FROM_NUMBER'],<br/>        to: to,<br/>        media_url: "#{ENV["URL_BASE"]}/faxes/files/#{ERB::Util.url_encode(filename)}"<br/>      )<br/>    end<br/>    redirect '/'<br/>  end</span></pre><p id="9c22" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们需要构建<code class="fe nc nd ne mt b">/faxes/files/:filename</code>端点来返回上传的文件。好的做法是<a class="ae kw" href="https://www.twilio.com/docs/usage/webhooks/webhooks-security#validating-signatures-from-twilio" rel="noopener ugc nofollow" target="_blank">保护这个webhook端点，确保它只响应来自Twilio </a>的请求。我们可以使用twilio-ruby gem提供的框架中间件<a class="ae kw" href="https://www.twilio.com/blog/2014/09/securing-your-ruby-webhooks-with-rack-middleware.html" rel="noopener ugc nofollow" target="_blank">来完成这项工作，该中间件检查来自Twilio </a>的头中的签名。</p><p id="b444" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Sinatra给了我们一个非常简单的发送文件的方法，即<code class="fe nc nd ne mt b">send_file</code>方法。因此，让我们创建一个get端点来返回文件。我们将把文件名作为路径的最后一部分(路径看起来像<code class="fe nc nd ne mt b">/faxes/files/nameOfFile.pdf</code>)来传递，这样我们就可以通过在路径中用冒号定义它来把它作为一个参数来读取。然后我们将使用文件名在服务器上查找文件，并用<code class="fe nc nd ne mt b">send_file</code>返回。</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="6dd5" class="mx ky iq mt b gy my mz l na nb">  get '/faxes/files/:filename' do<br/>    send_file "./files/#{params[:filename]}"<br/>  end</span></pre><p id="7b77" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了保护这个端点，添加了<code class="fe nc nd ne mt b">Rack::TwilioWebhookAuthentication</code>中间件。我们向中间件传递两个参数，您的Twilio auth令牌，以便它可以对请求进行签名和比较，以及一个正则表达式，用于它将工作的路径。将这一行添加到类的顶部。</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="abd3" class="mx ky iq mt b gy my mz l na nb">use Rack::TwilioWebhookAuthentication, ENV['TWILIO_AUTH_TOKEN'], /\/faxes\/files\/.*\z/</span></pre><h1 id="602a" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">接收状态回调</h1><p id="5d41" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">我们准备好发传真了。但是因为这份传真很重要，所以我想知道它是否也发送了。就像用<a class="ae kw" href="https://www.twilio.com/docs/voice/make-calls#monitor-outbound-call-events" rel="noopener ugc nofollow" target="_blank">呼叫</a>和<a class="ae kw" href="https://www.twilio.com/docs/sms/send-messages#monitor-the-status-of-your-message" rel="noopener ugc nofollow" target="_blank">消息</a>一样，我们可以注册接收一个<code class="fe nc nd ne mt b"><a class="ae kw" href="https://www.twilio.com/docs/fax/api/fax-resource#fax-status-callback" rel="noopener ugc nofollow" target="_blank">statusCallback</a></code> <a class="ae kw" href="https://www.twilio.com/docs/fax/api/fax-resource#fax-status-callback" rel="noopener ugc nofollow" target="_blank"> webhook </a>来跟踪我们的传真。</p><p id="1455" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个应用程序不使用数据库或任何其他存储，所以现在记录状态就可以了。再创建一个post端点来接收statusCallback webhook并记录重要的参数，确保返回200状态和空响应体:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="5198" class="mx ky iq mt b gy my mz l na nb">  post '/faxes/status' do<br/>    puts "===="<br/>    puts "Fax SID:           #{params["FaxSid"]}"<br/>    puts "To:                #{params["To"]}"<br/>    puts "Remote Station ID: #{params["RemoteStationId"]}" if params["RemoteStationId"]<br/>    puts "Status:            #{params["FaxStatus"]}"<br/>    if params["ErrorCode"]<br/>      puts "Error:             #{params["ErrorCode"]}"<br/>      puts params["ErrorMessage"]<br/>    end<br/>    puts "===="<br/>    200<br/>  end</span></pre><p id="7521" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们需要在发送传真的请求中添加这个端点作为<code class="fe nc nd ne mt b">status_callback</code> URL。</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="2404" class="mx ky iq mt b gy my mz l na nb">      client.fax.faxes.create(<br/>        from: ENV['FROM_NUMBER'],<br/>        to: to,<br/>        media_url: "#{ENV["URL_BASE"]}/faxes/files/#{filename}",<br/>        status_callback: "#{ENV["URL_BASE"]}/faxes/status"<br/>      )</span></pre><p id="69b6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们已经准备好发送和跟踪我们的传真了！</p><h1 id="71d6" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">使用ngrok挖掘隧道</h1><p id="1c2f" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">为了向互联网开放我们的webhook端点，以便Twilio可以访问它们，我们将使用<a class="ae kw" href="https://ngrok.com/" rel="noopener ugc nofollow" target="_blank"> ngrok </a>。我们已经在本地端口3000上运行了该应用程序，所以使用以下命令启动ngrok将HTTP流量通过隧道传输到端口3000:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="84ac" class="mx ky iq mt b gy my mz l na nb">ngrok http 3000</span></pre><p id="5ad4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一旦ngrok向您显示了您的隧道URL，就获取它并将其作为<code class="fe nc nd ne mt b">URL_BASE</code>添加到您的<code class="fe nc nd ne mt b">config/env.yml</code>文件中。它应该是这样的:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="2e8d" class="mx ky iq mt b gy my mz l na nb">URL_BASE: 'https://YOUR_NGROK_SUBDOMAIN.ngrok.io'</span></pre><p id="0c1b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">重新启动应用程序，或使用以下命令再次启动:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="8501" class="mx ky iq mt b gy my mz l na nb">bundle exec shotgun config.ru -p 3000</span></pre><h1 id="b51c" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">发送传真</h1><p id="3405" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">如果你没有传真测试的人，你总是可以使用另一个Twilio号码，但是如果你像我一样，你有你的传真号码和PDF准备好了。打开<a class="ae kw" href="http://localhost:3000" rel="noopener ugc nofollow" target="_blank"> localhost:3000 </a>，输入传真号码，选择您的PDF文件。点击发送，在Twilio请求文件时查看日志，几分钟后(<a class="ae kw" href="https://support.twilio.com/hc/en-us/articles/360007629653-How-Does-Twilio-Programmable-Fax-Pricing-Work-" rel="noopener ugc nofollow" target="_blank">我们估计每页发送一份传真需要30-60秒</a>)查看状态日志。</p><figure class="mo mp mq mr gt jr gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/a3cbde22fbc0558ea82edf34d5af0cae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*TG4xdXsSHOZ_9xYf.png"/></div></figure><h1 id="0758" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">派对就像1979年一样</h1><p id="7806" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">在这篇博文中，你了解到某些行业仍然需要传真。而且，如果您需要发送传真，您可以使用Twilio API和这个Ruby项目来完成。</p><p id="21a2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们已经看到了如何使用Sinatra上传文件和twilio-ruby库发送传真。整个应用程序可以从GitHub这里克隆<a class="ae kw" href="https://github.com/philnash/twilio-fax-ruby-sinatra" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="acad" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您想扩展它，您可以添加一个数据库并存储传真及其状态更新。类似的想法，你可以看看如何用SendGrid 在Rails中<a class="ae kw" href="https://www.twilio.com/blog/track-email-status-ruby-on-rails-sendgrid" rel="noopener ugc nofollow" target="_blank">跟踪电子邮件。你也可以考虑将传真媒体存储在静态文件存储中，比如AWS的S3或谷歌云的文件存储，然后将其传输到Twilio。</a></p><p id="d4e4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有人要求你发传真吗？你做了什么？请在下面的评论中或在Twitter上与我分享您的传真故事，地址:<a class="ae kw" href="https://twitter.com/philnash" rel="noopener ugc nofollow" target="_blank"> @philnash </a>。</p></div><div class="ab cl ng nh hu ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ij ik il im in"><p id="c532" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="nn">最初发表于</em><a class="ae kw" href="https://www.twilio.com/blog/send-faxes-twilio-fax-api-sinatra-ruby" rel="noopener ugc nofollow" target="_blank">T5【https://www.twilio.com】</a><em class="nn">。</em></p></div></div>    
</body>
</html>