<html>
<head>
<title>3 Quarkus Lambda Issues You Should Know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你应该知道的3个夸库拉姆达问题</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/3-quarkus-issues-you-should-know-8983a90fba1e?source=collection_archive---------8-----------------------#2021-09-16">https://levelup.gitconnected.com/3-quarkus-issues-you-should-know-8983a90fba1e?source=collection_archive---------8-----------------------#2021-09-16</a></blockquote><div><div class="fc ii ij ik il im"/><div class="in io ip iq ir"><div class=""/><div class=""><h2 id="c152" class="pw-subtitle-paragraph jr it iu bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">我和夸库斯·拉姆达之间的问题</h2></div><figure class="kk kl km kn gu ko gi gj paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gi gj kj"><img src="../Images/394aaedb04c16ec413ecd3438ec1ded0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Uf4uaAoh4bN3hqDzO8HM9Q.png"/></div></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated">照片由<a class="ae kz" href="https://www.pexels.com/@tima-miroshnichenko?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">马体·米罗什尼琴科</a>拍摄，来自<a class="ae kz" href="https://www.pexels.com/photo/woman-in-black-leather-jacket-sitting-at-the-table-5717262/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">Pexels</a>——作者编辑</figcaption></figure><p id="a988" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Quarkus是一个创建云原生项目的框架。该框架的主要特点是可以使用GraalVM。</p><p id="abed" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Quarkus承诺快速启动、低内存占用和良好的开发人员体验。</p><h1 id="224f" class="lw lx iu bd ly lz ma mb mc md me mf mg ka mh kb mi kd mj ke mk kg ml kh mm mn bi translated">我们在建造什么？</h1><p id="78bb" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated">带夸库的AWS Lambda。</p><p id="fb31" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Lambda应该依次调用两个端点。两个端点具有相同的自定义标头。标头包含授权和附加元数据。标头元数据将作为lambda的输入。</p><p id="6973" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><em class="mt">一个端点失效— Lambda失效。Lambda失败-生成错误信息。</em>其中一个端点可能失败，应返回失败原因。</p><p id="b9ad" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">使用SSL保护端点。Lambda需要自定义CA证书。信任存储与Lambda一起出现。</p><p id="3ba7" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">以下是你可能面临的夸库问题。</p></div><div class="ab cl mu mv hy mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="in io ip iq ir"><h1 id="e9f7" class="lw lx iu bd ly lz nb mb mc md nc mf mg ka nd kb mi kd ne ke mk kg nf kh mm mn bi translated">您可能与<code class="fe ng nh ni nj b">@RequestScoped</code>有问题</h1><p id="c9a7" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated"><em class="mt">您想要自定义标题吗？</em>你需要自定义<code class="fe ng nh ni nj b">ClientsHeadersFactory</code>。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nk nl l"/></div><figcaption class="kv kw gk gi gj kx ky bd b be z dk translated"><a class="ae kz" href="https://quarkus.io/guides/rest-client#custom-headers-support" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure><p id="56e8" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">当lambda被调用时，我们的头就出现了。T2和T3都帮不了我们。<em class="mt">我们需要返回一个自定义标题地图。</em></p><p id="c383" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">您需要一个单独的bean。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nk nl l"/></div></figure><p id="3f8a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在lambda中注入这个bean，用自定义属性填充头部。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nk nl l"/></div></figure><p id="f751" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在<code class="fe ng nh ni nj b">CustomClientsHeadersFactory</code>中注入bean，并使用定制的头属性。</p><figure class="kk kl km kn gu ko"><div class="bz fq l di"><div class="nk nl l"/></div></figure></div><div class="ab cl mu mv hy mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="in io ip iq ir"><p id="cd3b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">每个请求都用新的属性填充头。你很想把<code class="fe ng nh ni nj b">@RequestScoped</code>放到标题上。<code class="fe ng nh ni nj b">@ApplicationScoped</code>在当前环境下不太适用。</p><p id="962b" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe ng nh ni nj b">@RequestScoped</code>对我没用。lambda中的headers属性为空。</p><p id="7d08" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">你会发现<a class="ae kz" href="https://github.com/quarkusio/quarkus/issues/4826" rel="noopener ugc nofollow" target="_blank">上下文传播会引起问题。</a>即使加上<code class="fe ng nh ni nj b">quarkus-smallrye-context-propagation</code>这个也不行。</p><p id="c2e2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">把这个豆子留作<code class="fe ng nh ni nj b">ApplicationScoped</code>。因为每个lambda调用都会填充头，所以不会有问题。</p></div><div class="ab cl mu mv hy mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="in io ip iq ir"><h1 id="865e" class="lw lx iu bd ly lz nb mb mc md nc mf mg ka nd kb mi kd ne ke mk kg nf kh mm mn bi translated">您需要一个自定义证书</h1><p id="c5c8" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated">两个端点都受到SSL的保护。您需要在<code class="fe ng nh ni nj b">trustStore</code>中包含证书。</p><p id="d757" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">问题是如何包含证书。你在本地测试吗？你在AWS Lambda上测试吗？让我们看看你可能会遇到什么问题。</p><p id="1e18" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">你想在本地测试Lambda吗？您将无法从本机映像调用<code class="fe ng nh ni nj b">https</code>端点。</p></div><div class="ab cl mu mv hy mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="in io ip iq ir"><p id="a5d4" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">如果没有正确的证书，对端点的调用将会失败。大多数CA证书都是默认的<code class="fe ng nh ni nj b">trustStore</code>。默认<code class="fe ng nh ni nj b">trustStore</code>在<code class="fe ng nh ni nj b">$GRAALVM_HOME/Contents/Home/lib/security/cacerts</code>。</p><p id="5e36" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">默认情况下，Quarkus会将这个<code class="fe ng nh ni nj b">trustStore</code>嵌入到本机Docker映像中。无论哪种方式，您都需要添加一个证书才能使其工作。</p><p id="31e3" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">Docker图像嵌入了默认的<code class="fe ng nh ni nj b">trustStore</code>。<code class="fe ng nh ni nj b">function.zip</code>不会嵌入默认的<code class="fe ng nh ni nj b">trustStore</code>。当您将功能部署到AWS时，这可能会导致问题。</p><p id="20c3" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">让我们来看看这个问题的解决方案。</p></div><div class="ab cl mu mv hy mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="in io ip iq ir"><p id="eb11" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">要将您的证书添加到<code class="fe ng nh ni nj b">function.zip</code>中，您需要一个额外的目录。</p><p id="b352" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这个目录叫做<code class="fe ng nh ni nj b"><a class="ae kz" href="https://quarkus.io/guides/amazon-lambda#modifying-function-zip" rel="noopener ugc nofollow" target="_blank">zip.native</a></code>。你应该把它放在<code class="fe ng nh ni nj b">src/main</code>里。<code class="fe ng nh ni nj b">zip.native</code>应包含<code class="fe ng nh ni nj b">cacerts</code>文件和自定义<code class="fe ng nh ni nj b">bootstrap.sh</code>。</p><p id="2a54" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe ng nh ni nj b">cacerts</code>就是<code class="fe ng nh ni nj b">trustStore</code>。应该持有你需要的所有证件。<code class="fe ng nh ni nj b">bootstrap.sh</code>应该把这个<code class="fe ng nh ni nj b">trustStore</code>嵌入到原生的<code class="fe ng nh ni nj b">function.zip</code>里面。</p><pre class="kk kl km kn gu nm nj nn no aw np bi"><span id="49dd" class="nq lx iu nj b gz nr ns l nt nu"><strong class="nj iv"># bootstrap.sh<br/>#!/usr/bin/env bash<br/><br/></strong>./runner -Djava.library.path=./ -Djavax.net.ssl.trustStore=./cacerts -Djavax.net.ssl.trustStorePassword=changeit</span></pre></div><div class="ab cl mu mv hy mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="in io ip iq ir"><h1 id="7faa" class="lw lx iu bd ly lz nb mb mc md nc mf mg ka nd kb mi kd ne ke mk kg nf kh mm mn bi translated">您将获得本地主机的证书问题</h1><p id="e2de" class="pw-post-body-paragraph la lb iu lc b ld mo jv lf lg mp jy li lj mq ll lm ln mr lp lq lr ms lt lu lv in bi translated">假设您有一个样例Express服务器。这个服务器将模拟真实的端点。对<code class="fe ng nh ni nj b">https://localhost:3000/mockexpressendpoint</code>的呼叫不起作用。</p></div><div class="ab cl mu mv hy mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="in io ip iq ir"><p id="8a3f" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">在本地上调用终结点不起作用。第一个问题是，<code class="fe ng nh ni nj b">localhost</code>不是正确的URL。第二个问题，没有针对<code class="fe ng nh ni nj b">localhost</code>端点的证书。第三个问题，Docker容器在它自己的网络中，调用<code class="fe ng nh ni nj b">localhost</code>导致<code class="fe ng nh ni nj b">Connection refused</code>错误。</p><p id="51e5" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">让我们看看解决方案。</p></div><div class="ab cl mu mv hy mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="in io ip iq ir"><p id="50e9" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">假设您有一个本地Express服务器。联系<code class="fe ng nh ni nj b">localhost</code>没用。<strong class="lc iv">需要联系</strong> <code class="fe ng nh ni nj b"><strong class="lc iv">host.docker.internal</strong></code> <strong class="lc iv">。</strong></p><p id="08f1" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">示例URL端点:<code class="fe ng nh ni nj b"><strong class="lc iv">https://host.docker.internal/mockexpressendpoint</strong></code></p><p id="2bd1" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">这将解决<code class="fe ng nh ni nj b">Connection refused</code>问题。你会遇到的下一个问题是证书。</p><p id="06d2" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">您需要为您的Express服务器创建证书。这里有一种创建证书的方法。</p><p id="e533" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe ng nh ni nj b">openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout ./selfsigneddocker.key -out hostdockerinternal.cer -addext “DNS:host.docker.internal,IP:127.0.0.1”</code></p><p id="b622" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">添加<code class="fe ng nh ni nj b"><strong class="lc iv">host.docker.internal</strong></code>到证书的主题替换名称。使用<code class="fe ng nh ni nj b">-addext</code>将其添加到备选名称中。这将解决问题:</p><pre class="kk kl km kn gu nm nj nn no aw np bi"><span id="b1f5" class="nq lx iu nj b gz nr ns l nt nu">javax.net.ssl.SSLException: Certificate for &lt;host.docker.internal&gt; doesn't match any of the subject alternative names: [xxxxxxx.xxx.xxxxxx.xxx]</span></pre></div><div class="ab cl mu mv hy mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="in io ip iq ir"><p id="2b26" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">然后将证书包含在Express服务器中。</p><pre class="kk kl km kn gu nm nj nn no aw np bi"><span id="4bdf" class="nq lx iu nj b gz nr ns l nt nu">let key = fs.readFileSync(__dirname + '/../selfsigneddocker.key');</span><span id="9463" class="nq lx iu nj b gz nv ns l nt nu">let cert = fs.readFileSync(__dirname + '/../host.docker.internal.pem');</span><span id="aae3" class="nq lx iu nj b gz nv ns l nt nu">https.createServer({key, cert}, app).listen(3000, () =&gt;</span><span id="cc9e" class="nq lx iu nj b gz nv ns l nt nu">console.log(`Example app listening on port 3000!`),</span><span id="8784" class="nq lx iu nj b gz nv ns l nt nu">);</span></pre><p id="6024" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">包含证书后，您需要将证书添加到默认的<code class="fe ng nh ni nj b">trustStore</code>中。导航到<code class="fe ng nh ni nj b">trustStore</code>目录并执行以下命令。<code class="fe ng nh ni nj b">trustStore</code>的默认密码是<code class="fe ng nh ni nj b">changeit</code>。</p><p id="878a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated"><code class="fe ng nh ni nj b">sudo keytool -importcert -alias docker -file hostdockerinternal.cer -keystore cacerts</code></p></div><div class="ab cl mu mv hy mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="in io ip iq ir"><p id="2b0a" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">你有哪些夸夸其谈的问题？请在评论中告诉我。</p><p id="a895" class="pw-post-body-paragraph la lb iu lc b ld le jv lf lg lh jy li lj lk ll lm ln lo lp lq lr ls lt lu lv in bi translated">对于这些问题，你有其他的解决方案吗？评论里说吧。</p></div></div>    
</body>
</html>