<html>
<head>
<title>Making a Skill-Tree With D3 and Vue</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用D3和Vue制作技能树</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/building-a-rpg-like-skill-tree-98bfdbef01de?source=collection_archive---------7-----------------------#2020-07-29">https://levelup.gitconnected.com/building-a-rpg-like-skill-tree-98bfdbef01de?source=collection_archive---------7-----------------------#2020-07-29</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="0af1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">我如何为我的投资组合网站建立我的自定义技能树</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7307fc5468bcd5f62b7c2cd266c5a1d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*hsB7VxeO-GLA2iPpZatp3A.gif"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">我最后从中得到了什么</figcaption></figure><h1 id="ecd2" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">动机</h1><p id="7cad" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">我有一个<a class="ae mm" href="https://zexuan.netlify.app/" rel="noopener ugc nofollow" target="_blank">作品集网站</a>，我基本上把它作为动态简历，展示我的技术能力和成就。我使用用Vue编写的<a class="ae mm" href="https://gridsome.org/" rel="noopener ugc nofollow" target="_blank"> Gridsome </a>来构建它，并使用<a class="ae mm" href="https://buefy.org/" rel="noopener ugc nofollow" target="_blank"> Buefy </a>作为主要组件库，因为我只是想尝试Vue和其他框架。页面中的一个部分是“关键技能”部分，我在这里列出了我觉得最擅长的技能，也是大多数公司最期待的技能。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mn"><img src="../Images/3feead6728e88b55e9d62eb0aee26a20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TGeM02eDWi9gWBGS3gb-cQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">我当前的投资组合网站</figcaption></figure><p id="5664" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz mq mb mc md mr mf mg mh ms mj mk ml im bi translated">目前的设计工作正常，但我觉得它有点暗淡，因为在文本行中列出技能没有太多的“魅力”。因此，我开始寻找一种更好的方式来展示这些技能。我想到了角色扮演游戏(RPG)中的技能树，其中角色的技能和能力以分层的方式显示。然后我想象是否有可能复制它，用它来展示我的技能。大概是这样的:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mt"><img src="../Images/755cb2c3fdd9a79333c024ebde161da3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*hgOCkddoiJFIifit.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated"><a class="ae mm" href="https://www.freecodecamp.org/news/create-a-borderlands-style-skill-tree-in-5-minutes/" rel="noopener ugc nofollow" target="_blank">https://www . freecodecamp . org/news/create-a-borderlands-style-skill-tree-in-5-minutes/</a></figcaption></figure><p id="86b6" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz mq mb mc md mr mf mg mh ms mj mk ml im bi translated">这个“边境风格”的技能树例子使用了一个名为<code class="fe mu mv mw mx b"><a class="ae mm" href="https://github.com/andrico1234/beautiful-skill-tree" rel="noopener ugc nofollow" target="_blank">beautiful-skill-tree</a></code>的库，是为React设计的。由于这与我的Vue网站不兼容，我需要一个替代品，但不幸的是没有任何好的替代品。</p><p id="0db1" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz mq mb mc md mr mf mg mh ms mj mk ml im bi translated">这真的很棒，因为在网上找不到你需要的已经建好并可以使用的东西的情况越来越少了。因此，我开始建立自己的技能树<a class="ae mm" href="https://emojipedia.org/flexed-biceps/" rel="noopener ugc nofollow" target="_blank">💪</a></p><h1 id="6a64" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">技术</h1><p id="cc87" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">首先，我想到了在现代网站中可视化数据集的最佳方式。首先想到的是<a class="ae mm" href="https://d3js.org/" rel="noopener ugc nofollow" target="_blank"> D3 </a>，这是一个JavaScript库，用于组织、处理和格式化数据，以便于以后可视化。我决定使用D3，因为这是一个学习如何使用它的绝佳机会。为了开始学习D3，我浏览了这些材料:</p><div class="my mz gp gr na nb"><a href="https://observablehq.com/@d3/learn-d3" rel="noopener  ugc nofollow" target="_blank"><div class="nc ab fo"><div class="nd ab ne cl cj nf"><h2 class="bd iu gy z fp ng fr fs nh fu fw is bi translated">学习D3:简介</h2><div class="ni l"><h3 class="bd b gy z fp ng fr fs nh fu fw dk translated">学习D3:简介这一系列的笔记本将引导你通过D3.js的第一步。D3的标志是画出来的…</h3></div><div class="nj l"><p class="bd b dl z fp ng fr fs nh fu fw dk translated">observablehq.com</p></div></div><div class="nk l"><div class="nl l nm nn no nk np ks nb"/></div></div></a></div><p id="47c8" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz mq mb mc md mr mf mg mh ms mj mk ml im bi translated">Observable有一个关于如何使用D3的非常深入和写得很好的教程/指南，但是我发现很难设置它并与Vue一起工作，主要是由于Vue的反应系统。</p><div class="my mz gp gr na nb"><a href="https://www.sitepoint.com/vue-d3-data-visualization-intro/" rel="noopener  ugc nofollow" target="_blank"><div class="nc ab fo"><div class="nd ab ne cl cj nf"><h2 class="bd iu gy z fp ng fr fs nh fu fw is bi translated">Vue和D3.js - SitePoint数据可视化简介</h2><div class="ni l"><h3 class="bd b gy z fp ng fr fs nh fu fw dk translated">Web应用程序通常是数据驱动的，经常需要可视化这些数据。这就是图表…</h3></div><div class="nj l"><p class="bd b dl z fp ng fr fs nh fu fw dk translated">www.sitepoint.com</p></div></div><div class="nk l"><div class="nq l nm nn no nk np ks nb"/></div></div></a></div><p id="201f" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz mq mb mc md mr mf mg mh ms mj mk ml im bi translated">然后我就开始找Vue + D3相关指南，很幸运的找到了这个超级有用的教程。这个网站解释了如何让D3很好地与反应系统配合，这实际上很简单，使用Vue的<code class="fe mu mv mw mx b">watchers</code>概念。</p><p id="7ad2" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz mq mb mc md mr mf mg mh ms mj mk ml im bi translated">在玩了D3之后，我了解到D3并没有真正为你提供可视化的部分，比如条形图、树形图等等。大部分可视化部分是用<code class="fe mu mv mw mx b">svg</code>组件手工构建的…这也是我非常不擅长的。😅所以，也是时候学习<code class="fe mu mv mw mx b">svg</code>了！经过一番摆弄，我终于把“脚手架”做好了:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nr"><img src="../Images/323bdf99635cb59562672f0a44bb41f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a4X7iTkMm7SlFhOHdqB1aA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">技能树的基本框架</figcaption></figure><h2 id="7727" class="ns kz it bd la nt nu dn le nv nw dp li lz nx ny lk md nz oa lm mh ob oc lo od bi translated">密码</h2><p id="5fcc" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">我将解释一下代码是如何工作的:</p><pre class="kj kk kl km gt oe mx of og aw oh bi"><span id="f7bf" class="ns kz it mx b gy oi oj l ok ol">// skills data<br/><em class="om">const</em> skills = [<br/>{ id: "tech", label: 'Tech Tree' },<br/>{ parentId: "tech", id: "languages", label: 'Languages',},<br/>{<br/>  parentId: "languages",<br/>  id: "python",<br/>  label: 'Python',<br/>  iconHref:<br/>  require('../assets/icons/python.png'),<br/>  skillLevel: 90,<br/>  descriptions: ['Mainly worked with webserver backend frameworks with it.', 'Used in some simple machine learning applications and projects such as Gestice League and Project 21.']<br/>},<br/>...]</span></pre><p id="0ea5" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz mq mb mc md mr mf mg mh ms mj mk ml im bi translated">要显示的数据必须有一定的结构，特别是基于父子关系的结构。每个数据点(技能)要么是根，要么是另一个数据点的子数据点。为了构造这个，我有一个对象列表，这些对象有自己的<code class="fe mu mv mw mx b">id</code>和一个可选的<code class="fe mu mv mw mx b">parentId</code>来指示它的父对象(如果它有父对象的话)。</p><h2 id="92be" class="ns kz it bd la nt nu dn le nv nw dp li lz nx ny lk md nz oa lm mh ob oc lo od bi translated">组织数据</h2><pre class="kj kk kl km gt oe mx of og aw oh bi"><span id="d315" class="ns kz it mx b gy oi oj l ok ol">...<br/><em class="om">let</em> hierarchy = d3.stratify()(this.skills);<br/><em class="om">const</em> treeLayout = d3.tree().size([<br/>    1280,<br/>    500,<br/>  ]);<br/>hierarchy = treeLayout(hierarchy);</span></pre><p id="548f" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz mq mb mc md mr mf mg mh ms mj mk ml im bi translated">接下来，我利用D3强大的数据处理工具。首先，使用<code class="fe mu mv mw mx b"><a class="ae mm" href="https://observablehq.com/@d3/d3-stratify" rel="noopener ugc nofollow" target="_blank">d3.stratify</a>()</code>有助于处理数据点和形式化层次结构的链接结构。具体来说，它有助于识别根及其子节点，同时还可以计算元数据和结构，比如结果图的深度和高度。如果检测到多个根或其他结构问题，它也会抛出一个错误。最终的输出就是D3所说的“层次”对象。在这个阶段，产生的层次没有特定的布局，这意味着数据点还没有相对于彼此在空间上“定位”。</p><p id="1335" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz mq mb mc md mr mf mg mh ms mj mk ml im bi translated">然后，我使用<code class="fe mu mv mw mx b">d3.tree()</code>将层次结构处理成自顶向下的树形布局。这有助于为数据点分配坐标，然后我们可以用它来直观地绘制出整棵树。</p><h2 id="0e71" class="ns kz it bd la nt nu dn le nv nw dp li lz nx ny lk md nz oa lm mh ob oc lo od bi translated">画树</h2><p id="1133" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">首先，在模板中我有一个简单的结构设置，如下所示:</p><pre class="kj kk kl km gt oe mx of og aw oh bi"><span id="c177" class="ns kz it mx b gy oi oj l ok ol">&lt;template&gt;<br/>  &lt;div&gt;<br/>    &lt;svg /&gt;<br/>  &lt;/div&gt;<br/>&lt;/template&gt;</span></pre><p id="f049" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz mq mb mc md mr mf mg mh ms mj mk ml im bi translated">并且在Vue组件的安装方法中:</p><pre class="kj kk kl km gt oe mx of og aw oh bi"><span id="15c4" class="ns kz it mx b gy oi oj l ok ol">...<br/>mounted() {<br/>  this.svg = d3<br/>  .select("svg")<br/>  .attr("width", "100%")<br/>  .attr("height", 500)<br/>  .attr("cursor", "grab")<br/>  .attr("position", "relative");</span><span id="9583" class="ns kz it mx b gy on oj l ok ol">  this.skillTree = this.svg.append("g");</span><span id="62f0" class="ns kz it mx b gy on oj l ok ol">  this.drawTree();<br/>},</span></pre><p id="5d8d" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz mq mb mc md mr mf mg mh ms mj mk ml im bi translated">在这里，我们看到了使用D3库处理DOM操作的第一个实例。通过使用<code class="fe mu mv mw mx b">d3.select("svg")</code>，我们基本上是在试图找到文档中的第一个<code class="fe mu mv mw mx b">&lt;svg /&gt;</code>对象，然后对其进行操作。</p><p id="021e" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz mq mb mc md mr mf mg mh ms mj mk ml im bi translated">我们对<code class="fe mu mv mw mx b">&lt;svg /&gt;</code>做的第一件事是添加一个<code class="fe mu mv mw mx b">&lt;g /&gt;</code>元素，这只是一个本地svg元素，作为其他组件的容器。做<code class="fe mu mv mw mx b">this.svg.append("g")</code>也将返回结果<code class="fe mu mv mw mx b">&lt;g /&gt;</code>元素，然后我将它指定为<code class="fe mu mv mw mx b">skillTree</code>对象，稍后在其上构建。</p><p id="0b41" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz mq mb mc md mr mf mg mh ms mj mk ml im bi translated">接下来，我们用<code class="fe mu mv mw mx b">drawTree()</code>方法画出树，它是这样工作的:</p><pre class="kj kk kl km gt oe mx of og aw oh bi"><span id="cbc7" class="ns kz it mx b gy oi oj l ok ol">// hierarchy object previously made</span><span id="3273" class="ns kz it mx b gy on oj l ok ol"><em class="om">const</em> links = hierarchy.links();<br/><em class="om">const</em> nodes = hierarchy.descendants();</span><span id="ff28" class="ns kz it mx b gy on oj l ok ol">...<br/>this.skillTree<br/>  .selectAll("rect")<br/>  .data(nodes)<br/>  .enter()<br/>  .append("rect")<br/>  .attr("width", (<em class="om">d</em>) <em class="om">=&gt;</em> rectWidth)<br/>  .attr("x", (<em class="om">d</em>) <em class="om">=&gt;</em> d.x)<br/>  .attr("y", (<em class="om">d</em>) <em class="om">=&gt;</em> d.y)<br/>... //etc.<br/>...</span></pre><p id="d3f5" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz mq mb mc md mr mf mg mh ms mj mk ml im bi translated">首先，我们可以分别通过<code class="fe mu mv mw mx b">hierarchy.links()</code>和<code class="fe mu mv mw mx b">hierarchy.descendants()</code>访问链接和节点对象。</p><p id="a38f" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz mq mb mc md mr mf mg mh ms mj mk ml im bi translated">接下来，我们将看到D3库最强大的特性之一。D3有一个特殊的数据进入-更新-退出概念，在这里<a class="ae mm" href="https://bost.ocks.org/mike/join/" rel="noopener ugc nofollow" target="_blank">有很好的解释。我还不完全熟悉它，但是基本上通过执行<code class="fe mu mv mw mx b">.data(nodes)</code>，你将通知数据集你正在引用下一个的<strong class="ls iu">，并且通过执行<code class="fe mu mv mw mx b">.enter()</code>之后，需要更新的元素列表将被返回。因此，对于初始调用，<code class="fe mu mv mw mx b">.enter()</code>将基本上返回整个节点列表，因为之前在层次结构中没有数据。</strong></a></p><p id="6259" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz mq mb mc md mr mf mg mh ms mj mk ml im bi translated">在获得需要更新的元素列表后，我们将添加我们希望为每个节点构建的svg元素。所以在这种情况下，对于每个节点，我创建了一个正方形的svg元素，然后根据D3库方便地导出的<code class="fe mu mv mw mx b">x, y</code>坐标分配它的位置。</p><p id="a50a" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz mq mb mc md mr mf mg mh ms mj mk ml im bi translated">本质上，这就是如何使用D3来帮助构建和支持您想要呈现的任何数据的可视化。我做的下一步是为链接构建线条，并通过为每个节点添加文本、图像和边框来美化节点。</p><h2 id="2bd7" class="ns kz it bd la nt nu dn le nv nw dp li lz nx ny lk md nz oa lm mh ob oc lo od bi translated">让技能树更具互动性</h2><p id="b8ee" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">我意识到我的技能树有相当多的数据要显示，但没有足够的空间来容纳所有的数据。与其相应地缩小数据，我想为什么不试着让用户能够平移它。我找到了一个很好的指南，告诉我该怎么做:</p><div class="my mz gp gr na nb"><a href="https://css-tricks.com/creating-a-panning-effect-for-svg/" rel="noopener  ugc nofollow" target="_blank"><div class="nc ab fo"><div class="nd ab ne cl cj nf"><h2 class="bd iu gy z fp ng fr fs nh fu fw is bi translated">为SVG | CSS-Tricks创建平移效果</h2><div class="ni l"><h3 class="bd b gy z fp ng fr fs nh fu fw dk translated">在这个月的早些时候，我们讨论了如何找到一种方法让用户在一个…</h3></div><div class="nj l"><p class="bd b dl z fp ng fr fs nh fu fw dk translated">css-tricks.com</p></div></div><div class="nk l"><div class="oo l nm nn no nk np ks nb"/></div></div></a></div><p id="141a" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz mq mb mc md mr mf mg mh ms mj mk ml im bi translated">整个想法是利用<code class="fe mu mv mw mx b">&lt;svg /&gt;</code>组件的<code class="fe mu mv mw mx b">viewBox</code>属性，它基本上控制svg的显示区域。通过改变<code class="fe mu mv mw mx b">viewBox</code>参数，我们可以模拟一个移动的“摄像机”,或者像游戏中的“视口”,移动整个树的区域来显示。</p><p id="d453" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz mq mb mc md mr mf mg mh ms mj mk ml im bi translated">接下来的步骤是计算<code class="fe mu mv mw mx b">viewBox</code>的变化量。为了做到这一点，我们需要做一系列的步骤:<br/> 1。当用户点击svg <br/> 2时，记录原点/起始光标坐标。通过新光标坐标和原始光标坐标<br/> 3的偏移来跟踪和改变视窗。保存最后一个视图框偏移，并在随后的原点计算中考虑它</p><p id="9c6c" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz mq mb mc md mr mf mg mh ms mj mk ml im bi translated">如果做得好，我们基本上会有一个可扩展的技能树！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/688fffa200e7e09b6503edca94c49bc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*r7-1I7UTvBacfhrHTxFfzw.gif"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">哦，看，它动了！</figcaption></figure><p id="42e1" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz mq mb mc md mr mf mg mh ms mj mk ml im bi translated">让我解释一下它的代码:</p><pre class="kj kk kl km gt oe mx of og aw oh bi"><span id="60c1" class="ns kz it mx b gy oi oj l ok ol">...<br/>this.svg.on("pointerdown", this.onPointerDown);<br/>this.svg.on("pointerup", this.onPointerUp);<br/>this.svg.on("pointerleave", this.onPointerUp);<br/>this.svg.on("pointermove", this.onPointerMove);<br/>...</span></pre><p id="91ec" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz mq mb mc md mr mf mg mh ms mj mk ml im bi translated">我们想跟踪整个<code class="fe mu mv mw mx b">&lt;svg /&gt;</code>组件上不同的光标/触摸输入。为此，我们只需要将不同的回调分配给不同的事件。请注意我们是如何将指针离开<code class="fe mu mv mw mx b">&lt;svg /&gt;</code>视为光标“未按下”的。</p><pre class="kj kk kl km gt oe mx of og aw oh bi"><span id="c3eb" class="ns kz it mx b gy oi oj l ok ol">onPointerDown: <em class="om">function</em> () {<br/>  this.isClicked = true;<br/>  <em class="om">const</em> x = d3.event.pageX;<br/>  <em class="om">const</em> y = d3.event.pageY;<br/>  this.viewBoxPointer= {<br/>    x: x + this.viewBoxOffset.x, <br/>    y: y + this.viewBoxOffset.y,<br/>  };<br/>},<br/>onPointerUp: <em class="om">function</em> () {<br/>  this.isClicked = false;<br/>  <em class="om">const</em> x = d3.event.pageX;<br/>  <em class="om">const</em> y = d3.event.pageY;<br/>},<br/>onPointerMove: <em class="om">function</em> () {<br/>  if (this.isClicked) {<br/>    <em class="om">const</em> x = d3.event.pageX;<br/>    <em class="om">const</em> y = d3.event.pageY;<br/>    this.viewBoxOffset = {<br/>      x: this.viewBoxPointer.x - x,<br/>      y: this.viewBoxPointer.y - y,<br/>    };<br/>    this.svg.attr("viewBox", `${x} ${y} ${width} ${height}`);<br/>}<br/>},<br/>...</span></pre><p id="0042" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz mq mb mc md mr mf mg mh ms mj mk ml im bi translated">接下来，我将简要说明平移是如何工作的。首先，在<code class="fe mu mv mw mx b">onPointerDown </code>方法中，我们希望跟踪用户何时仍在点击<code class="fe mu mv mw mx b">&lt;svg /&gt;</code>，我们通过<code class="fe mu mv mw mx b">this.isClicked</code>标志来实现这一点。然后我们还跟踪光标在<code class="fe mu mv mw mx b">this.viewBoxPointer</code>中的当前位置。暂时忽略<code class="fe mu mv mw mx b">viewBoxOffset</code>。</p><p id="6d85" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz mq mb mc md mr mf mg mh ms mj mk ml im bi translated">完成之后，我们观察用户何时开始围绕<code class="fe mu mv mw mx b">&lt;svg /&gt;</code>移动光标。这在<code class="fe mu mv mw mx b">onPointerMove</code>方法中完成。我们首先检查用户是否真的还在点击<code class="fe mu mv mw mx b">&lt;svg /&gt;</code>，这意味着用户正在拖动组件。然后我们跟踪新的光标坐标，然后计算原始位置的偏移量，该偏移量存储在<code class="fe mu mv mw mx b">this.viewBoxPointer</code>中。我们还将当前偏移存储在<code class="fe mu mv mw mx b">viewBoxOffset</code>中。这样做将会模拟技能树被“移动”。</p><p id="a37c" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz mq mb mc md mr mf mg mh ms mj mk ml im bi translated">最后，当用户停止拖动和点击时，我们希望简单地取消设置<code class="fe mu mv mw mx b">this.isClicked</code>标志。</p><p id="041a" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz mq mb mc md mr mf mg mh ms mj mk ml im bi translated">当用户想要再次平移技能树时，我们在<code class="fe mu mv mw mx b">onPointerDown</code>方法中的<code class="fe mu mv mw mx b">viewBoxPointer</code>的计算中加入偏移量，以便我们从正确的最后已知位置开始。</p><h2 id="2f09" class="ns kz it bd la nt nu dn le nv nw dp li lz nx ny lk md nz oa lm mh ob oc lo od bi translated">最终细节</h2><p id="758c" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">整个技能树的最后一部分是当用户点击其中一个节点时，在它的旁边显示一个“描述”抽屉。这是通过放置一个Buefy card组件(通过<code class="fe mu mv mw mx b">&lt;div class="card" ...</code>)并用Buefy <code class="fe mu mv mw mx b">&lt;b-collapse&gt;</code>包装它来完成的，以便在节点被点击时显示/隐藏它。选定的节点数据被传入，然后详细信息被很好地显示出来，并带有一个使用Buefy的<code class="fe mu mv mw mx b">&lt;b-progress&gt;</code>构建的漂亮的小“体验栏”。</p><p id="4091" class="pw-post-body-paragraph lq lr it ls b lt mo ju lv lw mp jx ly lz mq mb mc md mr mf mg mh ms mj mk ml im bi translated">所以在这一切之后，这就是我们最终得到的结果:</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/7307fc5468bcd5f62b7c2cd266c5a1d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*hsB7VxeO-GLA2iPpZatp3A.gif"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">太“有技巧”了！</figcaption></figure><h1 id="20c0" class="ky kz it bd la lb lc ld le lf lg lh li jz lj ka lk kc ll kd lm kf ln kg lo lp bi translated">结论</h1><p id="5103" class="pw-post-body-paragraph lq lr it ls b lt lu ju lv lw lx jx ly lz ma mb mc md me mf mg mh mi mj mk ml im bi translated">我对最终的结果非常满意，我完成了我设定的目标，学会了如何使用D3和svg。我还想探索更多的东西，即如何更好地支持svg的移动触摸支持，并可能为它添加缩放功能。也许在我稍微清理一下代码之后，我可以把它作为一个包发布给其他人使用🤔。但总的来说，这是一个有趣的小项目！如果你愿意，你可以在我的主网站上看到它:😃<a class="ae mm" href="https://zexuan.netlify.app/" rel="noopener ugc nofollow" target="_blank">https://zexuan.netlify.app/</a></p></div></div>    
</body>
</html>