<html>
<head>
<title>Exploring Flutter’s communication with native code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">探索Flutter与本机代码的通信</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/flutters-communication-flow-with-native-1672495e239f?source=collection_archive---------7-----------------------#2021-07-07">https://levelup.gitconnected.com/flutters-communication-flow-with-native-1672495e239f?source=collection_archive---------7-----------------------#2021-07-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="eb29" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Flutter与原生iOS和Android代码对话有多无缝？</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/1d6c58fa258045cbf36c984c46d2b2ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*10RECXGTH5NyaeBg5yD1pw.png"/></div></div></figure><h1 id="4949" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">介绍</h1><p id="e8bc" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">这篇博客研究了Flutter如何与本机代码通信，并探讨了其中涉及的复杂性、挑战和风险。例如，我们想从本地SDK获得一个任务列表，并将它们显示在屏幕上。</p><p id="8551" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">大多数跨平台框架也遵循相似的通信路径，因此这里学到的经验也适用于它们。</p><h1 id="4f3b" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated"><strong class="ak">颤振通信流程</strong></h1><h2 id="1b50" class="ma ky iq bd kz mb mc dn ld md me dp lh jy mf mg ll kc mh mi lp kg mj mk lt ml bi translated">颤振实现</h2><p id="6f51" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">我们希望获得任务并在一个小部件中显示它们:</p><pre class="km kn ko kp gt mm mn mo mp aw mq bi"><span id="1158" class="ma ky iq mn b gy mr ms l mt mu">class MyApp extends StatelessWidget {  <br/>    @override  Widget build(BuildContext context) {<br/>        let tasks = TasksTarget.getTasks(5931)<br/>        setTasks(tasks)<br/>    }<br/>}</span></pre><p id="a03a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这要求我们创建一个中间目标，处理本地函数的调用并从JSON解码它们。</p><pre class="km kn ko kp gt mm mn mo mp aw mq bi"><span id="e08a" class="ma ky iq mn b gy mr ms l mt mu">class TasksTarget {</span><span id="a5de" class="ma ky iq mn b gy mv ms l mt mu">  static Future&lt;List&lt;Task&gt;&gt; getTasks(int userId) async {<br/>      const platform = const MethodChannel('samples.flutter.dev/tasks');</span><span id="2924" class="ma ky iq mn b gy mv ms l mt mu">    try {<br/>        <strong class="mn ir">final</strong> List&lt;dynamic&gt;? tasks = <strong class="mn ir">await </strong>_channel.invokeMethod&lt;List&lt;dynamic&gt;&gt;('getTasks', userId);<br/>        return tasks?.map(Task.fromJson).toList() ?? &lt;Task&gt;[];<br/>    } on PlatformException catch (e) {<br/>        // TODO handle the error here<br/>    }<br/>    return &lt;Task&gt;[]<br/>  }<br/>}</span></pre><h2 id="05a1" class="ma ky iq bd kz mb mc dn ld md me dp lh jy mf mg ll kc mh mi lp kg mj mk lt ml bi translated">本机实现</h2><p id="c456" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">在我们开始本机端之前，我们需要注册一个通道来进行通信:</p><pre class="km kn ko kp gt mm mn mo mp aw mq bi"><span id="6231" class="ma ky iq mn b gy mr ms l mt mu">// In App delegate's didFinishLaunchingWithOptions:</span><span id="4354" class="ma ky iq mn b gy mv ms l mt mu">let controller : FlutterViewController = window?.rootViewController as! FlutterViewController<br/>let taskChannel = FlutterMethodChannel(name: "samples.flutter.dev/tasks",<br/>binaryMessenger: controller.binaryMessenger)</span></pre><p id="5e90" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们必须注册调用处理程序，表明我们可以在新的任务通道上接受<code class="fe mw mx my mn b">getTasks</code>调用，并实现调用时发生的情况:</p><pre class="km kn ko kp gt mm mn mo mp aw mq bi"><span id="5a81" class="ma ky iq mn b gy mr ms l mt mu">taskChannel.setMethodCallHandler({<br/>  [weak self] (call: FlutterMethodCall, result: FlutterResult) -&gt; Void in<br/>  guard call.method == "getTasks" else {<br/>    result(FlutterMethodNotImplemented)<br/>    return<br/>  }<br/>  self?.receiveTaskRequest(result: result)<br/>})</span></pre><p id="4852" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，解码参数并确保它们符合我们的期望，然后调用所需的本机SDK函数。如果参数不符合我们的期望，那么我们必须通过一个错误。</p><pre class="km kn ko kp gt mm mn mo mp aw mq bi"><span id="870a" class="ma ky iq mn b gy mr ms l mt mu">private func receiveTaskRequest(request: FlutterMethodCall, result: FlutterResult) {<br/>  guard let userId = call.arguments as? Int else {<br/>      // Handle error if no user id passed in as arguments<br/>      let error = FlutterError(code: "INVALID_PARAM",<br/>                               message: "No user id passed in"<br/>                               details: nil)</span><span id="e382" class="ma ky iq mn b gy mv ms l mt mu">      result(error)<br/>      return<br/>    }</span><span id="9794" class="ma ky iq mn b gy mv ms l mt mu">    let tasks = <!-- -->NativeModule.getTasks(forUserId: <!-- -->userId<!-- -->)<br/>    result(tasks)<br/>}</span></pre><p id="0525" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个呼叫链可以用下图来总结:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mz"><img src="../Images/130434753fb2ea032896abf4382ac66e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0_OnOvrJ-YOoOx9gKitwSQ.png"/></div></div><figcaption class="na nb gj gh gi nc nd bd b be z dk translated">flutter和本机代码之间的通信通道</figcaption></figure><p id="d0c5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从本地应用的角度来看，这是怎样的？</p><h1 id="18b3" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">iOS通信流程</h1><p id="36e0" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">这将获得一个用户任务并设置它们:</p><pre class="km kn ko kp gt mm mn mo mp aw mq bi"><span id="1db2" class="ma ky iq mn b gy mr ms l mt mu">import UIKit<br/>import NativeModule</span><span id="c9c5" class="ma ky iq mn b gy mv ms l mt mu">class TaskViewController: UIViewController {</span><span id="e878" class="ma ky iq mn b gy mv ms l mt mu">override func viewDidLoad() {<br/>        super.viewDidLoad()<br/>        let tasks = NativeModule.getTasks(forUserId: 5931)<br/>        setTasks(tasks)<br/>    }<br/>}</span></pre><p id="073a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这可以用下面的iOS和Android图表来表示</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ne"><img src="../Images/c4d1e1034205f5c0bd727fcdc4a6ff15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gG4iSwJdUKd8ZxoaXy74ug.png"/></div></div></figure><h1 id="4b04" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">最后</h1><p id="4d23" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">由此可以清楚地看到，Flutter与本机代码的通信通道需要大量的boiler plate代码。接口层之间的这些是通信和数据无缝传输的巨大障碍。它需要更多的时间和精力来开发，并且会留下许多额外的代码需要维护。</p><p id="dc6b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这还意味着所有模型都需要是可序列化的(能够与JSON相互转换),这在所有平台上都增加了额外的工作，并且会影响运行时性能，导致应用程序整体速度变慢。</p><p id="c603" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">静态类型的缺乏意味着所有本地执行的类型检查在前端和通信层都是多余的，也意味着Android、iOS和Flutter代码都需要有完全相同的变量名，这导致运行时异常发生的几率很高。</p><p id="ef1d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">很明显，Flutter应该尽可能地减少与本机代码的通信，并将其留给访问基本服务，如平台特定的SDK。根据经验，如果你在做一个混合应用，最好尽可能用混合代码，并在需要的地方使用插件来访问原生API。只有当一个任务不能使用它们中的任何一个来完成时，你才应该实现你自己的通信层来定制本地代码。</p></div></div>    
</body>
</html>