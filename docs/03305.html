<html>
<head>
<title>How To Build News Aggregator Website Using Vue And Golang</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Vue和Golang构建新闻聚合网站</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-build-news-aggregator-website-using-vue-and-golang-a48999001238?source=collection_archive---------6-----------------------#2020-05-01">https://levelup.gitconnected.com/how-to-build-news-aggregator-website-using-vue-and-golang-a48999001238?source=collection_archive---------6-----------------------#2020-05-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="469d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上一篇文章中，我们已经研究了如何构建一个web scraper来从各种金融新闻网站中提取新闻并将其存储到数据库中(如果您还没有，请点击<a class="ae kl" href="https://medium.com/@wm_7an888/web-scraping-and-task-scheduling-with-golang-da0421abd04c" rel="noopener">此处</a>)。今天，我们将探讨如何使用Vue(前端)和Golang(后端)构建一个新闻聚合网站，将新闻存储在数据库中。</p></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><p id="0dea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">让我们先看看后端。</strong></p><p id="1dba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将采用MVC框架来构建后端服务器。那么什么是MVC呢？</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi kt"><img src="../Images/48067d4cdb12209aaf322d07760caf01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J6P1OJ55xlB9uvHjiQwJDQ.jpeg"/></div></div><figcaption class="lf lg gj gh gi lh li bd b be z dk translated">来自https://www.bacancytechnology.com/blog/mvc-vs-mvp-vs-mvvm<a class="ae kl" href="https://www.bacancytechnology.com/blog/mvc-vs-mvp-vs-mvvm" rel="noopener ugc nofollow" target="_blank">的</a></figcaption></figure><p id="47f0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">模型</strong>:对应用户使用的数据相关逻辑。表示在视图和控制器之间传输的数据。一个客户对象从数据库中检索客户信息，操作它并把它更新回数据库</p><p id="1c8c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">视图</strong>:用于应用的所有UI逻辑。客户视图包括用户交互的UI组件，如文本字段、下拉框等。</p><p id="e0f9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">控制器</strong>:模型和视图之间的接口，用于处理业务逻辑和传入请求，使用模型组件操纵数据，并与视图交互以呈现最终输出。客户控制器处理来自视图的所有交互和输入，并使用模型更新数据库。</p><p id="c57e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，由于我们要分离前端和后端，我们可以放开视图部分，只关注模型和控制器。</p><p id="c572" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将构建两个API路径:检索新闻和运行web抓取。</p><ol class=""><li id="2d54" class="lj lk iq jp b jq jr ju jv jy ll kc lm kg ln kk lo lp lq lr bi translated"><strong class="jp ir">获取新闻文章列表的方法</strong></li></ol><p id="3ab4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于数据库中会有很多新闻文章，我们将构建控制器来接收URL参数中的以下输入:</p><p id="fef4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">a)来源:允许用户根据新闻网站过滤新闻提要</p><p id="2514" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">b) Limit:在每个请求调用中返回最大数量的新闻文章</p><p id="a440" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">c)以前的ID和以前发布的日期时间:按照以前发布的日期时间和以前的ID的降序编写SQL脚本。通过使用以前的ID和以前发布的日期时间进行过滤，我们可以返回比以前已经检索到的文章“更早”的文章。这允许我们稍后构建一个无限滚动的页面。</p><figure class="ku kv kw kx gt ky"><div class="bz fp l di"><div class="ls lt l"/></div><figcaption class="lf lg gj gh gi lh li bd b be z dk translated">控制器和模型</figcaption></figure><p id="496b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在SQL中有几种检索数据列表的方法，我认为其中一种常见的方法是使用limit关键字:</p><p id="fa2c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="lu">SELECT * FROM articles ORDER BY published _ at desc限制0，10；</em></p><p id="6c58" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上述查询将从位置0返回10篇文章，文章以published_at降序排列。它照常工作，给你正确的输出。</p><p id="8ba4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是，当有数百万条记录时，以及当您想从位置10，000开始时(例如)，会有一个性能问题。这是因为在这种方法中，表格将被逐行扫描，直到位置10，000，并且当我们想要从稍后的位置开始时，将花费长得多的时间。</p><p id="57a8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">可以向上阅读<a class="ae kl" href="http://allyouneedisbackend.com/blog/2017/09/24/the-sql-i-love-part-1-scanning-large-table/" rel="noopener ugc nofollow" target="_blank">http://allyouneedisback end . com/blog/2017/09/24/the-SQL-I-love-part-1-scanning-large-table/</a>了解更多。因此，我们将使用键集分页方法，根据以前的ID和以前发布的日期时间进行过滤，以实现更快的执行时间。</p><p id="362b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">2.<strong class="jp ir">帖子方法触发新闻网站的抓取</strong></p><p id="895d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还允许用户选择新闻来源来开始新闻网站的网络搜集。由于网页抓取可能需要一段时间，当用户想要抓取所有新闻网站时，可能会导致很长的等待时间。因此，我们将引入goroutine来允许执行并发运行，以缩短总的执行时间。</p><p id="06a4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">什么是goroutine？</strong></p><p id="9b0b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Goroutine可以被认为是轻量级线程。它是可以并发运行的函数或方法。要在golang中实现goroutine，只需在函数前添加关键字<em class="lu"> go </em>即可。</p><p id="3dc6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，我们必须记住，每次goroutine执行仍然会消耗资源(如CPU、内存等),尽管与其他编程语言相比要少一些。这就是为什么限制goroutine的数量很重要，以避免同时运行太多go routine任务而导致资源耗尽。</p><p id="26c8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为此，我们将使用goroutines和通道实现一个工人池。</p><figure class="ku kv kw kx gt ky"><div class="bz fp l di"><div class="ls lt l"/></div><figcaption class="lf lg gj gh gi lh li bd b be z dk translated">使用goroutines和通道的工人池</figcaption></figure><p id="f708" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个方法中，我们将首先对source ID进行一些预处理，以确保传入的所有源ID都是有效的。然后，我们将创建worker方法，从而接收sourceID通道并在结果通道上发送相应的结果。</p><p id="6aab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这里，我们定义了4个工人数，这些工人最初被阻止，因为还没有收到工作。然后，我们遍历处理过的源ID来发送作业，并关闭通道以表明这是我们所有的工作。最后，我们将收集结果。</p><p id="4c70" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">换句话说，我们将有4个goroutine并发运行。假设我们有10个作业要运行，goroutine工作线程将选择前4个作业并发运行，一旦其中一个工作线程完成，它将选择第5个作业和后续作业，如此重复，直到所有10个作业都完成。</p></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><p id="0122" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们完成了我们的API，完成了2条路线。你可以参考下面的链接来获得完整的代码库。</p><p id="9310" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">来源:https://github.com/wilsontwm/goinvest</p></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><p id="4cf1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">前端使用Vue </strong></p><p id="d05b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将在一个类似于Pinterest的布局中构建一个新闻提要，其中有显示缩略图和标题的新闻提要卡片。将有无限的滚动，用户滚动到底部，它会自动扫描下一篇文章。</p><p id="a1f4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，我们将构建一个允许用户选择新闻来源的过滤器和一个运行web爬行的按钮。</p><p id="9cee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我再一次推荐<a class="ae kl" href="https://vuetifyjs.com/en/" rel="noopener ugc nofollow" target="_blank"> Vuetify </a>(一个材料设计框架)，我以前用过它，因为它无疑加快了我的开发过程，而不必设计和开发每个组件。</p><figure class="ku kv kw kx gt ky gh gi paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="gh gi lv"><img src="../Images/2a7a0cb6c4ba2d4a628ff9ed01185314.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1hllnQYLfjstxSEp3fTayw.png"/></div></div><figcaption class="lf lg gj gh gi lh li bd b be z dk translated">新闻聚合网站的屏幕截图</figcaption></figure><figure class="ku kv kw kx gt ky"><div class="bz fp l di"><div class="ls lt l"/></div><figcaption class="lf lg gj gh gi lh li bd b be z dk translated">新闻提要的主要代码库</figcaption></figure><p id="4226" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们将构建一个包含所有硬编码新闻源的<select>下拉列表，选择的新闻源将被存储为<em class="lu"> selectedNewsSources </em>。为了不在下拉列表中显示所有新闻来源的名称，我们还添加了一些逻辑，以便在选择的数量超过2时显示“全部”或“+( &lt; number &gt; others)”。除此之外，我们还添加了一个列表项操作，允许用户切换选择来选择/取消选择所有新闻源。</select></p><p id="fe04" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，我们需要一个方法来触发API调用，从Golang后端服务器检索新闻数据，如<em class="lu"> applySearch </em>方法所示。收到数据后，我们将存储最后一篇文章的ID和发布日期，以便我们可以扫描从这篇文章开始的下一篇文章。</p><p id="d6f7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">类似地，我们还添加了submitCrawlNews来触发API调用，以启动web爬行功能。这在很大程度上取决于我们在下拉列表中所做的选择。</p><p id="29fa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">主体是我们显示新闻提要的地方。当我们从API响应中收到文章数据时，我们会将它们添加到<em class="lu">news</em>和<em class="lu"> </em>中，然后我们会遍历数组中的每个元素来显示新闻。</p><p id="df04" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另外，请注意，我们添加了一个事件，当在<em class="lu"> mounted </em>方法中到达窗口底部时，该事件将触发搜索。</p><figure class="ku kv kw kx gt ky"><div class="bz fp l di"><div class="ls lt l"/></div><figcaption class="lf lg gj gh gi lh li bd b be z dk translated">要调用API的端点</figcaption></figure><p id="558c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从上面的摘录中，我们可以看到有两个端点:获取新闻列表和触发网络抓取；一个是GET方法，另一个是POST方法。对于GET方法，我们获取输入并将它们连接成查询参数字符串，而对于POST方法，我们将输入转换成JSON格式。随后，我们调用fetch方法向我们的后端服务器发送网络请求，并返回响应或错误。</p><p id="7c17" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">来源:https://github.com/wilsontwm/my-investing-vue<a class="ae kl" href="https://github.com/wilsontwm/my-investing-vue" rel="noopener ugc nofollow" target="_blank"/></p></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><p id="d1ac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们基本上完成了我们的前端和后端。我们现在能够通过分别为我们的后端和前端服务器运行'<em class="lu"> go run main.go' </em>或'<em class="lu"> npm run serve' </em>,在本地托管它。</p><p id="af83" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们将考虑在云上托管它们。</p><p id="78e0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">敬请期待…干杯！</p></div></div>    
</body>
</html>