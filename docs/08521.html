<html>
<head>
<title>Why is List<struct> 15 Times Faster to Allocate than List<class> in C#</class></struct></title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么C#  中List <struct>的分配速度比List <class>快15倍</class></struct></h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/why-is-list-struct-is-15-times-faster-to-allocate-than-list-class-17f5f79889ae?source=collection_archive---------3-----------------------#2021-05-09">https://levelup.gitconnected.com/why-is-list-struct-is-15-times-faster-to-allocate-than-list-class-17f5f79889ae?source=collection_archive---------3-----------------------#2021-05-09</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/5414d5c126b4d08b251a1353312e6e15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XKSezocYQFrh6nZ0"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated"><a class="ae kf" href="https://unsplash.com/@homajob?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">斯科特·格雷厄姆</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="a820" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上一篇文章<a class="ae kf" rel="noopener ugc nofollow" target="_blank" href="/5-ways-to-improve-the-performance-of-c-code-for-free-c89188eba5da"> 5种免费提高C#代码性能的方法</a>中，在其中一个例子中，我测量了分配一个类列表和分配一个结构列表之间的时间差。</p><p id="b44f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">让我们记住这个例子:</p><figure class="le lf lg lh gt ju"><div class="bz fp l di"><div class="li lj l"/></div></figure><p id="1438" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe lk ll lm ln b">ListOfClassesTest</code>和<code class="fe lk ll lm ln b">ListOfStructsTest</code>方法几乎相同。第一种方法分配一百万个<code class="fe lk ll lm ln b">PointClass</code>实例并将其添加到列表中，而第二种方法分配一百万个<code class="fe lk ll lm ln b">PointStruct</code>实例并将其添加到列表中。类型<code class="fe lk ll lm ln b">PointClass</code>和<code class="fe lk ll lm ln b">PointStruct</code>有相同的成员，但是唯一小而关键的区别是<code class="fe lk ll lm ln b">PointClass</code>是一个类，而<code class="fe lk ll lm ln b">PointStruct</code>是一个结构。</p><p id="8dcb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由awesome library<a class="ae kf" href="https://github.com/dotnet/BenchmarkDotNet" rel="noopener ugc nofollow" target="_blank">BenchmarkDotNet</a>完成的性能结果令人印象深刻:</p><figure class="le lf lg lh gt ju gh gi paragraph-image"><div class="gh gi lo"><img src="../Images/98b35a28e64efaa3f79e38ae6692d251.png" data-original-src="https://miro.medium.com/v2/resize:fit:1390/format:webp/1*1t98DIZClL79eHrG1h_ypw.png"/></div></figure><p id="f90f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe lk ll lm ln b">ListOfStructsTest</code>方法比<code class="fe lk ll lm ln b">ListOfClassesTest.</code>快15倍以上</p><p id="6731" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们来试着分析一下为什么会有如此巨大的时差。</p></div><div class="ab cl lp lq hx lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="im in io ip iq"><p id="0429" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们首先要理解在堆上分配一个引用类型的实例和在栈上分配一个结构的实例之间的区别。</p><pre class="le lf lg lh gt lw ln lx ly aw lz bi"><span id="a34f" class="ma mb it ln b gy mc md l me mf">public void Test()<br/>{<br/>   var obj = new object(); //reference type allocation<br/>   <br/>   int x = 12; //value type allocation<br/>}</span></pre><p id="0a97" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在托管堆中为引用类型分配内存的时间通常是快速操作。对象被连续分配和存储<strong class="ki iu">。公共语言运行库拥有指向内存中第一个可用空间的指针。分配一个新对象涉及到将新对象的大小加到指针上。</strong></p><p id="b6fe" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在对象被放入托管堆之后，它的地址被写回到在堆栈上创建的引用<code class="fe lk ll lm ln b">obj</code>。</p><p id="679b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">总的来说，整个过程非常便宜。然而，为引用类型的对象分配内存的过程并不总是那么容易，并且可能涉及额外的繁重部分。</p><p id="f30f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果引用类型大于85K字节，运行时将花费更多时间在<strong class="ki iu">大型对象堆</strong>中寻找合适的位置来存储对象，因为那里的内存是碎片化的(空闲块或地址空间中的“洞”)。</p><p id="2b7d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<strong class="ki iu">小对象堆</strong>中没有更多空闲空间来存储应用程序请求的对象的情况下，引用类型对象分配很慢。发生这种情况时，公共语言运行库需要运行垃圾回收进程。如果垃圾收集器没有释放足够的内存，运行时会请求额外的虚拟内存页面。</p><p id="86a4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在堆栈上分配值类型实例怎么样？</p><p id="90bf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为值类型分配内存<strong class="ki iu">几乎是即时操作，分配的时间几乎不取决于值类型的大小。运行时应该做的唯一事情是创建一个适当大小的堆栈框架来存储值类型和修改堆栈指针。</strong></p><p id="d6c1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">要点是将值类型的实例放入堆栈很快，更重要的是，与在堆上分配引用类型对象相比，这是一个时间上确定的过程。</p></div><div class="ab cl lp lq hx lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="im in io ip iq"><p id="8e6d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在让我们回到我们的例子。</p><p id="3acc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当分配了一百万个引用类型的实例时，它们被一个接一个地推入托管堆中，并且引用被存储回集合实例中。事实上，会有一百万+ 1个对象进入内存。</p><figure class="le lf lg lh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mg"><img src="../Images/d7190aa06fd9b590a597eaac4d4df79f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tEvzDL6DkmJ3xwntRhYsaQ.png"/></div></div></figure><p id="b95f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然而，当分配了一百万个值类型的实例时，只有一个对象<strong class="ki iu">被推入托管堆</strong>，它是一个集合的实例。一百万个结构将被嵌入到<code class="fe lk ll lm ln b">List&lt;T&gt;</code>实例中。在创建了<code class="fe lk ll lm ln b">List&lt;T&gt;</code>实例之后，运行时唯一要做的事情就是用数据填充它。</p><figure class="le lf lg lh gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mh"><img src="../Images/2b7bc6cd6b67aa49c0471cca60448c9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_uNZT8CGkFbtiiylqBZ-bg.png"/></div></div></figure><p id="060b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">开发人员不仅受益于为大型集合选择结构而不是类时的快速分配时间，还受益于发布时间。</p><p id="9e8c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果开发人员分配了一百万个<code class="fe lk ll lm ln b">PointClass</code>实例，在“标记和清理”阶段，垃圾收集器将不得不扫描一百万个对象，并检查每个对象是否仍有引用。然后，在“压缩”阶段，垃圾收集器将不得不移动一百万个对象。最终，存储在<code class="fe lk ll lm ln b">List&lt;PointClass&gt;</code>实例中的地址应该用新地址更新。这是大量的工作。</p><p id="4a91" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是对于垃圾收集器来说，当开发人员分配一百万个<code class="fe lk ll lm ln b">PointStruct</code>实例时，情况会好得多，因为在托管堆中只有一个<code class="fe lk ll lm ln b">List&lt;PointStruct&gt;</code>实例是垃圾收集器必须处理的。</p></div><div class="ab cl lp lq hx lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="im in io ip iq"><h1 id="5354" class="mi mb it bd mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne bi translated">结论</h1><p id="465c" class="pw-post-body-paragraph kg kh it ki b kj nf kl km kn ng kp kq kr nh kt ku kv ni kx ky kz nj lb lc ld im bi translated">结构可能比类更具性能，但是在用<code class="fe lk ll lm ln b">struct</code>替换<code class="fe lk ll lm ln b">class</code>关键字或相反的情况之前，一定要仔细分析您的具体情况。程序员的工作不是盲目地遵循建议或最佳实践，而是选择最合适的工具、方法和途径，以尽可能最好的方式解决他或她的独特情况。</p></div><div class="ab cl lp lq hx lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="im in io ip iq"><h1 id="6fe9" class="mi mb it bd mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne bi translated">参考</h1><ul class=""><li id="019e" class="nk nl it ki b kj nf kn ng kr nm kv nn kz no ld np nq nr ns bi translated"><a class="ae kf" href="https://tooslowexception.com/heap-vs-stack-value-type-vs-reference-type/" rel="noopener ugc nofollow" target="_blank">堆vs栈，值类型vs引用类型</a></li><li id="92ae" class="nk nl it ki b kj nt kn nu kr nv kv nw kz nx ld np nq nr ns bi translated"><a class="ae kf" href="https://devblogs.microsoft.com/dotnet/allocating-on-the-stack-or-the-heap/" rel="noopener ugc nofollow" target="_blank">分配在栈上还是堆上？</a></li><li id="77ab" class="nk nl it ki b kj nt kn nu kr nv kv nw kz nx ld np nq nr ns bi translated"><a class="ae kf" href="https://www.amazon.com/Pro-NET-Performance-Optimize-Applications/dp/1430244585" rel="noopener ugc nofollow" target="_blank">亲。NET Performance:优化你的C#应用程序，作者Sasha Goldshtein(第3章)</a></li><li id="ea6f" class="nk nl it ki b kj nt kn nu kr nv kv nw kz nx ld np nq nr ns bi translated"><a class="ae kf" href="https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/fundamentals" rel="noopener ugc nofollow" target="_blank">垃圾收集的基础</a></li></ul></div><div class="ab cl lp lq hx lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="im in io ip iq"><h2 id="7a29" class="ma mb it bd mj ny nz dn mn oa ob dp mr kr oc od mv kv oe of mz kz og oh nd oi bi translated">我的其他文章:</h2><div class="oj ok gp gr ol om"><a rel="noopener  ugc nofollow" target="_blank" href="/50-software-engineering-best-practices-for-technical-leaders-and-seniors-cfcdf6a17e44"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd iu gy z fp or fr fs os fu fw is bi translated">面向技术领导者和资深人士的50个软件工程最佳实践</h2><div class="ot l"><h3 class="bd b gy z fp or fr fs os fu fw dk translated">最佳工程师的最佳实践。</h3></div><div class="ou l"><p class="bd b dl z fp or fr fs os fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="ov l"><div class="ow l ox oy oz ov pa jz om"/></div></div></a></div><div class="oj ok gp gr ol om"><a rel="noopener  ugc nofollow" target="_blank" href="/how-to-fix-bugs-and-not-introduce-new-ones-9f35e625673a"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd iu gy z fp or fr fs os fu fw is bi translated">如何在不破坏应用程序的情况下修复Bug</h2><div class="ot l"><h3 class="bd b gy z fp or fr fs os fu fw dk translated">更改源代码时更自信的步骤。</h3></div><div class="ou l"><p class="bd b dl z fp or fr fs os fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="ov l"><div class="pb l ox oy oz ov pa jz om"/></div></div></a></div><div class="oj ok gp gr ol om"><a rel="noopener  ugc nofollow" target="_blank" href="/5-ways-to-clone-an-object-in-c-d1374ec28efa"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd iu gy z fp or fr fs os fu fw is bi translated">在C#中克隆对象的5种方法</h2><div class="ot l"><h3 class="bd b gy z fp or fr fs os fu fw dk translated">各有利弊</h3></div><div class="ou l"><p class="bd b dl z fp or fr fs os fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="ov l"><div class="pc l ox oy oz ov pa jz om"/></div></div></a></div></div></div>    
</body>
</html>