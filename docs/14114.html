<html>
<head>
<title>How to use Web Workers API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Web Workers API</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-use-web-workers-api-b1ef96c46fc0?source=collection_archive---------3-----------------------#2022-11-02">https://levelup.gitconnected.com/how-to-use-web-workers-api-b1ef96c46fc0?source=collection_archive---------3-----------------------#2022-11-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/db452be4288cbbd1c08d6a7f25c593dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dZVWtfNpEQrLFG2jQDYUDA.png"/></div></div></figure><p id="cc85" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers" rel="noopener ugc nofollow" target="_blank"> Web Workers </a>是Web内容在后台线程中运行脚本的一种简单方式。工作线程可以在不干扰用户界面的情况下执行任务。</p><p id="6495" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">除了一些例外，您可以在工作线程中运行您喜欢的任何代码。例如，您不能从worker内部直接操纵DOM，也不能使用一些默认的方法和<code class="fe kx ky kz la b"><a class="ae kw" href="https://developer.mozilla.org/en-US/docs/Web/API/Window" rel="noopener ugc nofollow" target="_blank">window</a></code>对象的属性。</p><p id="ca3f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以在JS主线程之外运行繁重的操作。主线程是浏览器处理用户事件和绘画的地方。默认情况下，浏览器使用单线程来运行页面上的所有JavaScript，以及执行布局、重排和垃圾收集。这意味着长时间运行的JavaScript函数可能会阻塞线程，导致页面无响应和糟糕的用户体验。🤔</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lb"><img src="../Images/773fa2df93233aab47b4e0dde0107c2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xFY4ewB4Cd0Qpt4VGX1tPw.png"/></div></div></figure><p id="e785" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，我将调用一个计算量很大的方法来求解斐波那契数列(以一种非常低效的方式)。如果碰巧你正在寻找一个序列计算的好的解决方案，使用记忆。类似这样的<a class="ae kw" href="https://stackoverflow.com/a/67765989/15439733" rel="noopener ugc nofollow" target="_blank">【1】</a>。总之…继续我们的话题。</p><pre class="lc ld le lf gt lg la lh li aw lj bi"><span id="effa" class="lk ll iq la b gy lm ln l lo lp">// The typical fibonacci implementation (warning! slow!)<br/>const fibonacci = (num: number): any =&gt; {<br/>  if (num &lt;= 1) return 1;<br/>  return fibonacci(num - 1) + fibonacci(num - 2);<br/>};</span></pre><p id="5abd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">观察javascript主线程上运行的微调器，此时主线程开始解决繁重的计算。它会在计算过程中冻结，因为主线程仍然忙于计算，它不会关注其他任何事情。同步执行的美妙之处— <strong class="ka ir">程序中的第一个任务必须在继续执行下一个任务之前完成处理。</strong></p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lq"><img src="../Images/9539044e55b3afacf0615f54e98118da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*KyAH7XWOIcDeIH4oWzsvJw.gif"/></div></div></figure><p id="ef0a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那么，我们如何在繁重的计算中防止主线程阻塞呢？</p></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="5023" class="ly ll iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">解决办法？网络工作者。🤗</h1><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/6202b300e8ff79c7bac8df6520e06cea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iUkr96PkY-PJPIOJ5FDoeQ.png"/></div></div></figure><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="mw mx l"/></div></figure><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="a32f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">数据通过消息系统在工作线程和主线程之间发送——双方都使用<code class="fe kx ky kz la b">postMessage()</code>方法发送消息。工人的魔力通过<code class="fe kx ky kz la b"><a class="ae kw" href="https://developer.mozilla.org/en-US/docs/Web/API/Worker/postMessage" rel="noopener ugc nofollow" target="_blank">postMessage()</a></code>方法和<code class="fe kx ky kz la b"><a class="ae kw" href="https://developer.mozilla.org/en-US/docs/Web/API/Worker/message_event" rel="noopener ugc nofollow" target="_blank">onmessage</a></code>事件处理程序实现。</p><p id="b937" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">每次调用时，都会产生一个新的工作线程。工人完成他们的工作并返回结果。这就是所谓的异步执行，它使你能够在一个单独的<a class="ae kw" href="https://developer.mozilla.org/en-US/docs/Glossary/Thread" rel="noopener ugc nofollow" target="_blank">线程</a>中运行一些任务。</p><h2 id="8047" class="lk ll iq bd lz my mz dn md na nb dp mh kj nc nd ml kn ne nf mp kr ng nh mt ni bi translated">Web Workers允许您在Web应用程序中执行多线程。</h2><p id="6ec0" class="pw-post-body-paragraph jy jz iq ka b kb nj kd ke kf nk kh ki kj nl kl km kn nm kp kq kr nn kt ku kv ij bi translated">让我们观察同样的斐波那契数列计算。注意两件事:1)微调不再冻结2)总执行时间明显减少。🤩</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lq"><img src="../Images/40c024d9d8d88bc2f3a9c05929fb0651.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*BoJu0TgsiOeM6Pfyjghl0w.gif"/></div></div></figure></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="9abc" class="ly ll iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">需要考虑的事项</h1><h2 id="ad16" class="lk ll iq bd lz my mz dn md na nb dp mh kj nc nd ml kn ne nf mp kr ng nh mt ni bi translated">保安？</h2><p id="f401" class="pw-post-body-paragraph jy jz iq ka b kb nj kd ke kf nk kh ki kj nl kl km kn nm kp kq kr nn kt ku kv ij bi translated"><code class="fe kx ky kz la b"><a class="ae kw" href="https://developer.mozilla.org/en-US/docs/Web/API/Worker" rel="noopener ugc nofollow" target="_blank">Worker</a></code>接口产生了真正的操作系统级线程，细心的程序员可能会担心，如果不小心的话，并发可能会在代码中产生“有趣”的效果。</p><p id="1607" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，由于web工作者已经小心地控制了与其他线程的通信点，所以实际上很难引起并发问题。无法访问非线程安全组件或DOM。您必须通过序列化对象将特定数据传入和传出线程。所以你必须非常努力才能在你的代码中引起问题。</p><h2 id="88f6" class="lk ll iq bd lz my mz dn md na nb dp mh kj nc nd ml kn ne nf mp kr ng nh mt ni bi translated">资源？</h2><p id="ccd5" class="pw-post-body-paragraph jy jz iq ka b kb nj kd ke kf nk kh ki kj nl kl km kn nm kp kq kr nn kt ku kv ij bi translated">用于产生新线程的资源仍然来自客户端的硬件。这意味着，如果您的客户端在物理上没有大量的计算能力(例如，一些较旧的智能手机)，新线程可能不会那么快。甚至主线程也可能因为整个设备100%运行(不仅仅是主线程)而遇到阻塞。</p><h2 id="c15f" class="lk ll iq bd lz my mz dn md na nb dp mh kj nc nd ml kn ne nf mp kr ng nh mt ni bi translated">如果这么棒，为什么不用这个？</h2><p id="9d48" class="pw-post-body-paragraph jy jz iq ka b kb nj kd ke kf nk kh ki kj nl kl km kn nm kp kq kr nn kt ku kv ij bi translated">谁说不是呢？但是如果我必须列出一些限制它们使用的限制:</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi no"><img src="../Images/f267b8815a7d311cab357b7e121fea65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZCaDHlDc7ZMtEueKo7bsrA.png"/></div></div></figure><ol class=""><li id="8e60" class="np nq iq ka b kb kc kf kg kj nr kn ns kr nt kv nu nv nw nx bi translated">首先，也可能是最重要的一点是不能访问文档对象模型。</li><li id="5362" class="np nq iq ka b kb ny kf nz kj oa kn ob kr oc kv nu nv nw nx bi translated">您无法从Web Worker访问您的框架的功能，因为您无权访问它的库。</li><li id="07b0" class="np nq iq ka b kb ny kf nz kj oa kn ob kr oc kv nu nv nw nx bi translated">Web Worker无法访问<code class="fe kx ky kz la b">window</code>名称空间，但在某种程度上，它的概念是可以访问的。</li></ol><p id="cb10" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">更多关于这个<a class="ae kw" href="https://www.codemag.com/Article/2101071/Understanding-and-Using-Web-Workers" rel="noopener ugc nofollow" target="_blank">这里</a>。</p></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="db55" class="ly ll iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">源代码</h1><p id="cccd" class="pw-post-body-paragraph jy jz iq ka b kb nj kd ke kf nk kh ki kj nl kl km kn nm kp kq kr nn kt ku kv ij bi translated">源代码可以在<a class="ae kw" href="https://codesandbox.io/p/github/Nurech/web-workers-example/draft/serene-borg?file=%2Fsrc%2Fapp%2Fservices%2Fdata.service.ts&amp;selection=%5B%7B%22endColumn%22%3A1%2C%22endLineNumber%22%3A53%2C%22startColumn%22%3A1%2C%22startLineNumber%22%3A52%7D%5D" rel="noopener ugc nofollow" target="_blank"> CodeSandBox </a>和<a class="ae kw" href="https://github.com/Nurech/web-workers-example" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到。</p><p id="92df" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">感谢阅读！</p></div></div>    
</body>
</html>