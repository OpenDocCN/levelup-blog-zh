<html>
<head>
<title>A Practical Example of React Lifecycle Events</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应生命周期事件实际例子</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/a-practical-example-of-react-lifecycle-events-d73bc263df07?source=collection_archive---------14-----------------------#2020-11-24">https://levelup.gitconnected.com/a-practical-example-of-react-lifecycle-events-d73bc263df07?source=collection_archive---------14-----------------------#2020-11-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="49f0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我想我们都熟悉React生命周期事件组件DidMount。我总是认为它是在组件初始加载时用它需要的状态值初始化组件。除此之外，其他生命周期事件对于初学者来说可能有点陌生。这是我用来展示这些其他事件可以派上用场的另一个事件，取决于你的需要。这是设置。</p><p id="1dbe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我的应用程序有一个下拉菜单，允许用户选择要查看的课程。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/f766e73b8698dc0c66468d9ac4d5a16d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jkeU9z5YpU2y6PDCc_BMqg.png"/></div></div></figure><p id="e0da" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">初始选择后，所选球场的地图会显示出来，地图上带有俱乐部会所标记。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/2abf18dc78a45c67cf1283698aba9316.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*02wGUpnyNHGu3ei3ZvZlCA.png"/></div></div></figure><p id="7381" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过导航到BrowserRouter中设置的/courses/:id路径来触发该组件。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kx"><img src="../Images/5ebce4a0b08dc5b630754a88981719dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EaHhLEDDDomQqAJVIM7ctg.png"/></div></div></figure><p id="8705" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">导航栏中的操作触发了下面的代码。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kx"><img src="../Images/44c2168c15625dac38023d025812941b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DtOf2TvidMyAr3grtH0SSw.png"/></div></div></figure><p id="1417" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">函数参数中的值是相关课程的id。history.push方法会将其“重定向”到路径/courses/${value}，这又会触发ShowCourse组件。</p><p id="147e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦触发，我们现在可以检查熟悉的componentDidMount生命周期事件。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ky"><img src="../Images/7a0a537fb2e338b078f29b5792098104.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K7hMYF-XSH21nYjYLkurEg.png"/></div></div></figure><p id="0ca2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这里，我使用Redux props中的match.params.id来定位所选课程的id，因为我知道这个组件是由一个路径触发的，该路径包含课程id。然后可以用它在Redux存储中查找课程(通过一个find方法)，然后用页面运行所需的所有信息设置本地状态。</p><p id="03b7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，如果用户仍然在ShowCourse组件上，从下拉菜单中选择不同的课程。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/e3da10890ad26766e4ecc2e0194cff73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TFwltiZY1iMjCLhKoh2n6w.png"/></div></div></figure><p id="4761" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们期待一个不同的过程立即显示出来。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/2794c2e697e43492c9ea58e4d93376d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2QZx5MEzZTfZIRgm6Kz3bw.png"/></div></div></figure><p id="7dc5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是另一个生命周期事件componentDidUpdate发挥作用的地方。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kz"><img src="../Images/df1be445c420bd901ce44e17462dd05d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PjSVsNmpRgH7mdRStJugMQ.png"/></div></div></figure><p id="e241" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于componentDidMount只在组件最初被触发时执行一次，所以当选择发生变化时，我们不能使用它来将本地状态更改为不同的过程。原因是该组件已经安装，因此我们在正常操作期间无法再次触发此事件。</p><p id="5c56" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们需要componentDidUpdate来允许我们捕获变化的事件并执行代码来刷新内容。在这种情况下，将本地状态设置为新的路线。这个函数中的关键字是Redux在props和prevProps中存储的match.params.id。prevProps包含我们之前所在球场的id，而Props包含用户选择新球场时在路径中设置的当前球场的id。</p><p id="ac6b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们检测到两个id不同，我们就知道需要改变航线显示。然后，我们可以像在componentDidMount中一样执行路线查找和本地状态设置。一旦状态被设置为新的球场，组件将使用新的地图和标记位置重新呈现。当然，如果用户从下拉列表中选择相同的课程，id检查将失败，因为props和prevProps包含相同的值，因此不会发生重新呈现。</p></div></div>    
</body>
</html>