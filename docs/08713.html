<html>
<head>
<title>Create distortion effect in images using ThreeJS + React + GSAP</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用三个JS + React + GSAP在图像中创建扭曲效果</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/create-distortion-effect-in-images-using-threejs-react-gsap-97ca92959351?source=collection_archive---------2-----------------------#2021-05-28">https://levelup.gitconnected.com/create-distortion-effect-in-images-using-threejs-react-gsap-97ca92959351?source=collection_archive---------2-----------------------#2021-05-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="7509" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对我来说，这是一篇很难写的文章，因为我在这个主题上没有太多的专业知识，但我发现这是非常必要的，因为我在网上看到的所有关于三个j和图像应用效果的东西都没有透露代码，或者你必须知道一点GLSL (OpenGL着色语言)才能在你的图像上创建一些漂亮的效果。</p><p id="c4a3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我只想指出，我在<a class="ae kl" href="https://codepen.io/ashthornton/pen/KRQbMO" rel="noopener ugc nofollow" target="_blank"> Codepen </a>中改编了一个现有的项目，并集成到一个React应用程序中。但是别担心，我会带你走完这个项目的每一步。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/37cb1b0261f11e2ca4bf7915fd400a5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Wk3N9kY014qxAX4k6UkL-Q.gif"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">项目演示</figcaption></figure><p id="680c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了更好地理解我构建了什么，让我们来看看我的React应用程序架构。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi lc"><img src="../Images/55c9f671981a4625f2a12af4ac19a90f.png" data-original-src="https://miro.medium.com/v2/resize:fit:742/format:webp/1*4U37JyfZfspdVYj8c_qMUQ.png"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk translated">React组件架构</figcaption></figure><p id="635b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">分解结构，我们有:</p><ul class=""><li id="a665" class="ld le iq jp b jq jr ju jv jy lf kc lg kg lh kk li lj lk ll bi translated">Header组件——将保存标题元素，对于这个项目来说，它就是要做的所有事情。</li><li id="dfa6" class="ld le iq jp b jq lm ju ln jy lo kc lp kg lq kk li lj lk ll bi translated">Slider组件— Sider元素，它接收要显示的项目数。除了元素数量之外，还接收一个包含父元素上下文的方法，该方法将更新图像的选定索引。</li><li id="ee19" class="ld le iq jp b jq lm ju ln jy lo kc lp kg lq kk li lj lk ll bi translated">着陆组件—渲染ThreeJS动画，创建先前应用于图像的纹理阵列。将从滑块组件接收事件以更新选定的图像(使用纹理数组)。</li></ul><p id="ea15" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如您所理解的，因为这篇文章都是关于ThreeJS和图像动画的，所以让我们把注意力集中在这个登陆组件上(您可以查看完整的源代码来更好地理解其他组件是如何构建的)。</p><p id="a6d4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在着陆组件中，我们做的第一件事是在图像数组(包含原始图像的链接)到达时，我们必须使用ThreeJS来生成我们的纹理。因此，在我的例子中，我使用了React钩子，因此我使用了useEffect来创建我的纹理数组。</p><pre class="kn ko kp kq gt lr ls lt lu aw lv bi"><span id="7ffa" class="lw lx iq ls b gy ly lz l ma mb">useEffect(() =&gt; {<br/>  const parent = document.querySelector('.landing') as HTMLElement;<br/>  const images = document.querySelectorAll('.landing__image');</span><span id="48b1" class="lw lx iq ls b gy mc lz l ma mb">  if (parent &amp;&amp; images) {<br/>    const effects = SliderEffect({<br/>      parent,<br/>      images: Array.from(images)<br/>    });<br/>    setEffects(effects);<br/>  }<br/>}, []);</span></pre><p id="7a36" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这将得到所有渲染在屏幕上的图像(虽然只有一个是可见的)，并将调用我的效果模块来生成纹理效果。让我们调查一下。</p><pre class="kn ko kp kq gt lr ls lt lu aw lv bi"><span id="e39c" class="lw lx iq ls b gy ly lz l ma mb">export const SliderEffect = (opts: {<br/>  parent: HTMLElement,<br/>  images: Element[]<br/>  }): {<br/>        material: ShaderMaterial;<br/>        images: Texture[];<br/>      }</span></pre><p id="1246" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">查看方法签名(我明确地添加了接口，只是为了让您更好地理解),我们可以看到该方法将接收父元素，该父元素将保存由ThreeJS生成的canvas元素和一组HTML图像元素。着陆组件将接收着色器材质对象和纹理数组。</p><p id="4ef9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个SliderEffect方法做的第一件事是为ShaderMaterial定义顶点和片段。你可能会问，这个阴影物质是什么？这是一个带有自定义着色器(顶点和片段)的材质渲染器，这些着色器是使用GLSL ( <a class="ae kl" href="https://www.khronos.org/files/opengles_shading_language.pdf" rel="noopener ugc nofollow" target="_blank">手动</a>)编写的。顶点将用于定义图像的位置和大小，而碎片将负责我们看到的酷效果(模糊失真)。该片段将始终在顶点着色器之后运行(这是GPU渲染中一个众所周知的话题)。</p><p id="f5ad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们定义了我们的顶点和片段之后，我们必须创建一个画布区域来保存我们的图像纹理。为此，让我们为画布区域创建宽度和高度，这将是我们的窗口大小我们的图像大小(我们选择哪个更大)以保证我们在窗口中显示完整的图像。下一步是创建一个WebGL渲染器，设置我们的背景颜色、大小并将其添加到DOM中。</p><pre class="kn ko kp kq gt lr ls lt lu aw lv bi"><span id="a0c2" class="lw lx iq ls b gy ly lz l ma mb">let renderer = new THREE.WebGLRenderer({<br/>  antialias: false,<br/>});</span><span id="3007" class="lw lx iq ls b gy mc lz l ma mb">renderer.setClearColor( 0x23272A, 1.0 );<br/>renderer.setSize( renderW, renderH );<br/>parent.appendChild( renderer.domElement );</span></pre><p id="1d85" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们已经创建了画布，剩下要做的就是为图像创建纹理。</p><pre class="kn ko kp kq gt lr ls lt lu aw lv bi"><span id="3120" class="lw lx iq ls b gy ly lz l ma mb">let loader = new THREE.TextureLoader();<br/>images.forEach((img: Element) =&gt; {<br/>  image = loader.load(<br/>      img.getAttribute( 'src' ) + '?v=' + Date.now()<br/>  );<br/>image.magFilter = image.minFilter = THREE.LinearFilter;<br/>image.anisotropy = renderer.capabilities.getMaxAnisotropy();</span><span id="f3e7" class="lw lx iq ls b gy mc lz l ma mb">sliderImages.push( image );</span><span id="4c7a" class="lw lx iq ls b gy mc lz l ma mb">});</span></pre><p id="2037" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们创建一个包含已加载图像的纹理，并在图像中设置默认过滤器。这里，选择了线性过滤器，它定义了在场景中应用效果后纹理像素的行为。</p><p id="1a6d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后的步骤是创建一个场景和摄像机视角，最后是着色器材质，它将使用我们的顶点和片段代码(并设置初始图像)。</p><pre class="kn ko kp kq gt lr ls lt lu aw lv bi"><span id="4176" class="lw lx iq ls b gy ly lz l ma mb">let scene = new THREE.Scene();<br/>scene.background = new THREE.Color( 0x23272A );<br/>let camera = new THREE.OrthographicCamera(<br/>  renderWidth / -2,<br/>  renderWidth / 2,<br/>  renderHeight / 2,<br/>  renderHeight / -2,<br/>  1,<br/>  1000<br/>);<br/>camera.position.z = 2;</span><span id="a0e9" class="lw lx iq ls b gy mc lz l ma mb">let mat = new THREE.ShaderMaterial({<br/>  uniforms: {<br/>    dispFactor: { value: 0.0 },<br/>    currentImage: { value: sliderImages[0] },<br/>    nextImage: { value: sliderImages[1] },<br/>  },<br/>  vertexShader: vertex,<br/>  fragmentShader: fragment,<br/>  transparent: true,<br/>  opacity: 1.0<br/>});</span><span id="bd59" class="lw lx iq ls b gy mc lz l ma mb">let geometry = new THREE.PlaneBufferGeometry(<br/>  parent.offsetWidth,<br/>  parent.offsetHeight,<br/>  1<br/>);</span><span id="3ae0" class="lw lx iq ls b gy mc lz l ma mb">let object = new THREE.Mesh(geometry, mat);<br/>object.position.set(0, 0, 0);<br/>scene.add(object);</span></pre><p id="6eee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">关于着陆组件逻辑，我所做的是让一个useEffect监听我们所选项目中的变化，当滑块被单击时，它将执行代码来执行动画。这个动画是使用TweenLite和我们的着色器材质创建的。</p><pre class="kn ko kp kq gt lr ls lt lu aw lv bi"><span id="750a" class="lw lx iq ls b gy ly lz l ma mb">effects.material.uniforms.nextImage.value = effects.images[item];</span><span id="ea51" class="lw lx iq ls b gy mc lz l ma mb">TweenLite.to(effects.material.uniforms.dispFactor, 1, {<br/> value: 1,<br/> ease: 'Expo.easeOut',<br/> onComplete: () =&gt; {<br/>  effects.material.uniforms.currentImage.value =<br/>    effects.images[item];<br/>  effects.material.uniforms.dispFactor.value = 0.0;<br/> }<br/>});</span></pre><p id="23ee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这将使用我们的色散值将从1到0，并将导致我们看到的失真效果。此外，如果您注意到了，我创建了一个关键帧动画来在我们的文本元素中创建一些效果(在最初的示例中使用了TweenLite)。</p><p id="67d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">仓库代码:<a class="ae kl" href="https://github.com/thealmarques/react-threejs-distorion-effect" rel="noopener ugc nofollow" target="_blank"> Github </a></p><p id="7918" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是你要的，希望你喜欢，希望很快见到你。</p></div></div>    
</body>
</html>