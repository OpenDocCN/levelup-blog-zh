<html>
<head>
<title>Learning Go: Maps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习围棋:地图</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/learning-go-maps-c56404049f78?source=collection_archive---------18-----------------------#2020-03-23">https://levelup.gitconnected.com/learning-go-maps-c56404049f78?source=collection_archive---------18-----------------------#2020-03-23</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/cea4cb242b7cf1143a016a9240c302fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qTMky2w5EjYb03nx"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">安德鲁·斯图特斯曼在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="4815" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一个<em class="le">映射</em>是一个关联数据结构，它根据<em class="le">键</em>和<em class="le">值</em>存储相关数据。电话簿(或年轻人的联系人列表)是地图的一个很好的例子，其中姓名与电话号码相关联。词典是地图的另一个例子，其中一个单词与一个定义相关联。</p><p id="27a2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从技术上讲，Go map是一个哈希表，其中的键被哈希为一个值，该值被用作存储该值的数据结构的键。如果您对哈希表不熟悉，请到这里查看介绍。</p><h1 id="0bb3" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">在Go中声明地图</h1><p id="6b14" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">可以用几种方式来声明一个映射。最好的方法是使用内置的<code class="fe mi mj mk ml b">make</code>函数。该函数的语法模板如下所示:</p><p id="fdbf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">映射名称:= make(映射[关键字-数据类型]值-数据类型)</em></p><p id="aa2f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这里有一个例子:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="d2c3" class="mu lg it ml b gy mv mw l mx my">inventory := make(map[string] int)</span></pre><p id="256f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">键和值由冒号分隔，条目必须以逗号结束。</p><p id="fb6e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">用于键的值类型必须是可比较的类型。您不应该对键使用浮点类型，因为众所周知，浮点值在比较时是不明确的。</p><h1 id="ffbb" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">地图操作</h1><p id="196d" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">使用数组表示法访问地图值。例如，要更改库存图中的卫生纸数量，请编写:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="66e1" class="mu lg it ml b gy mv mw l mx my">inventory["toilet paper"] = 10</span></pre><p id="3af0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果只需要将一卷添加到原料中，可以使用增量运算符:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="8d8c" class="mu lg it ml b gy mv mw l mx my">inventory["toilet paper]++</span></pre><p id="2816" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">现在，我将花点时间创建一个更大的清单:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="957b" class="mu lg it ml b gy mv mw l mx my">func main() {<br/>  inventory := map[string] int {<br/>    "toilet paper": 0,<br/>  }<br/>  inventory["clorox wipes"] = 0<br/>  inventory["milk"] = 2<br/>  inventory["hand sanitizer"] = 1<br/>  inventory["paper towels"] = 5<br/>  inventory["eggs"] = 0<br/>}</span></pre><p id="af4d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我可以通过使用一个<code class="fe mi mj mk ml b">range for</code>循环来显示map中的键和值的列表:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="8ff5" class="mu lg it ml b gy mv mw l mx my">for item, count := range inventory {<br/>  fmt.Printf("%s: %d", item, count)<br/>}</span></pre><p id="13c5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此代码的输出是(对于一次运行):</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="e7e5" class="mu lg it ml b gy mv mw l mx my">hand sanitizer: 1<br/>paper towels: 5<br/>eggs: 0<br/>toilet paper: 0<br/>clorox wipes: 0<br/>milk: 2</span></pre><p id="f8d7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当我再次执行循环时，我得到:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="8045" class="mu lg it ml b gy mv mw l mx my">clorox wipes: 0<br/>milk: 2<br/>hand sanitizer: 1<br/>paper towels: 5</span></pre><p id="9228" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">很明显，地图中的项目没有按照任何顺序存储。这是因为排序是随机的。如果你想看到你的地图以某种顺序显示，比如按字母顺序，你必须首先对关键字进行排序，然后显示地图中的项目。有一个内置的<code class="fe mi mj mk ml b"> sort</code>功能，它是<code class="fe mi mj mk ml b">sort</code>包的一部分。以下是您的操作方法:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="70c3" class="mu lg it ml b gy mv mw l mx my">package main</span><span id="30aa" class="mu lg it ml b gy mz mw l mx my">import (<br/>  "fmt"<br/>  "sort"<br/>)</span><span id="2a19" class="mu lg it ml b gy mz mw l mx my">func main() {<br/>  inventory := map[string] int {<br/>    "toilet paper": 0,<br/>  }<br/>  inventory["clorox wipes"] = 0<br/>  inventory["milk"] = 2<br/>  inventory["hand sanitizer"] = 1<br/>  inventory["paper towels"] = 5<br/>  inventory["eggs"] = 0<br/>  var items []string<br/>  for item := range inventory {<br/>    items = append(items, item)<br/>  }<br/>  sort.Strings(items)<br/>  for _, item := range items { <br/>    fmt.Printf("%s: %d\n", item, inventory[item])<br/>  }<br/>}</span></pre><p id="7aec" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">第一步是创建一个片来存储库存项目。下一步是遍历地图，将每个项目键添加到切片中。接下来，使用<code class="fe mi mj mk ml b">sort.Strings</code>功能对切片进行排序。最后，遍历切片，使用每个商品名称作为键来返回它在库存图中的相关计数。</p><p id="b46e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是该程序的输出:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="3ade" class="mu lg it ml b gy mv mw l mx my">clorox wipes: 0<br/>eggs: 0<br/>hand sanitizer: 1<br/>milk: 2<br/>paper towels: 5<br/>toilet paper: 0</span></pre><p id="350f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">映射的键是唯一的，因此如果您尝试插入与现有键具有相同键的键/值对，新键将替换现有键。这里有一个例子:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="3613" class="mu lg it ml b gy mv mw l mx my">func main() {<br/>  inventory := map[string] int {<br/>    "toilet paper": 0,<br/>  }<br/>  inventory["clorox wipes"] = 0<br/>  inventory["milk"] = 2<br/>  inventory["milk"] = 5<br/>  for item, count := range inventory {<br/>    fmt.Printf("%s: %d\n", item, count)<br/>  }<br/>}</span></pre><p id="29be" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">milk的最新键/值对被插入到映射中，以便库存列表显示milk的计数为5而不是2。</p><p id="f0d8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以使用内置的<code class="fe mi mj mk ml b">len</code>函数来查找映射中键/值对的数量:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="7446" class="mu lg it ml b gy mv mw l mx my">fmt.Printf("There are %d items in inventory.\n", len(inventory))</span></pre><p id="2a9e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以使用内置的<code class="fe mi mj mk ml b">delete</code>函数删除映射键/值对:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="f99d" class="mu lg it ml b gy mv mw l mx my">delete(inventory, "eggs")</span></pre><p id="3c11" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">零映射是已经声明但尚未用键/值对初始化的映射。以下代码片段返回true，因为地图中没有任何数据:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="ca82" class="mu lg it ml b gy mv mw l mx my">var numbers map[string] string<br/>fmt.Print(numbers == nil)</span></pre><p id="b630" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以在nil映射上调用<code class="fe mi mj mk ml b">len </code>和<code class="fe mi mj mk ml b">delete</code>函数，因为这些函数将返回所声明映射的值类型的默认值。换句话说，如果值类型是<code class="fe mi mj mk ml b">string</code>，在nil映射上调用<code class="fe mi mj mk ml b">len</code>或<code class="fe mi mj mk ml b">delete</code>将返回一个空字符串。</p><p id="8de8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个使用零映射的例子，它的值类型是<code class="fe mi mj mk ml b">int</code>:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="8dbc" class="mu lg it ml b gy mv mw l mx my">var numbers map[string] int<br/>val := len(numbers)<br/>fmt.Print(val) // displays 0</span></pre><p id="1214" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当您试图访问一个不存在的键时，这也是有效的。Go中一个常见的习语是这样编写键访问:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="e853" class="mu lg it ml b gy mv mw l mx my">func main() {<br/>  inventory := map[string] int {<br/>    "toilet paper": 0,<br/>  }<br/>  inventory["clorox wipes"] = 0<br/>  inventory["milk"] = 2<br/>  key := "eggs"<br/>  count, ok := inventory[key]<br/>  if !ok {<br/>    fmt.Printf("%s not found in inventory.", key)<br/>  } else {<br/>    fmt.Printf("There are %d %s in inventory.\n", count, key)<br/>  }<br/>}</span></pre><h1 id="c77d" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">切片作为贴图值</h1><p id="e181" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">在很多应用程序中，您会希望使用切片来表示地图的值。下面的程序演示了一种使用切片来存储与学生相关的一组成绩的方法:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="acb2" class="mu lg it ml b gy mv mw l mx my">func main() {<br/>  grades := map[string] []int {<br/>    "Joey": {81, 77, 83},<br/>    "Audie": {91, 100, 88},<br/>    "Bill": {77, 81, 72},<br/>  }<br/>  total := 0<br/>  allGrades := grades["Joey"]<br/>  for _, aGrade := range allGrades {<br/>    total += aGrade<br/>  }<br/>  average := float64(total) / float64(len(allGrades))<br/>  fmt.Printf("Joey's grade average is %.2f\n", average)<br/>}</span></pre><p id="4691" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了计算平均成绩，我们访问Joey的成绩，并将其存储在一个新的切片中。然后，我们使用新切片来计算平均分数。</p><h1 id="1e79" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">去找地图</h1><p id="0db8" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">该映射为程序员提供了轻松创建数据结构的机会，这些数据结构可用于存储关联数据的应用程序。虽然我在本文中没有涉及到它，但是地图也可以用于实现一组数据结构，它存储唯一的数据元素。如果你对此感兴趣，请参阅Alan Donovan和Brian Kernighan的《Go编程语言》。</p><p id="32e9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢您阅读这篇文章，如果您有任何意见和建议，请发邮件给我。</p></div></div>    
</body>
</html>