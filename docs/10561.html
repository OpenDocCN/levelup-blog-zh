<html>
<head>
<title>Debugging Concurrent Systems with a Model Checker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用模型检查器调试并发系统</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/debugging-concurrent-systems-with-a-model-checker-c7eee210d86f?source=collection_archive---------1-----------------------#2021-12-20">https://levelup.gitconnected.com/debugging-concurrent-systems-with-a-model-checker-c7eee210d86f?source=collection_archive---------1-----------------------#2021-12-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="cd87" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当测试不够时，使用正式的方法！</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/ea0fec3e51fe181fd3b21d94346d0b7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*El1F-6g1a73DvSH4qWFO9A.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated"><em class="lb">生产者和消费者共享一个有限的缓冲区</em></figcaption></figure><h1 id="a38d" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">多线程程序(Java语言)</h1><p id="a8fc" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">编写并发程序很难。在很大程度上，这种困难源于缺乏良好的测试和调试策略。当我们写顺序程序时，我们也会犯错误，但是我们有更好的能力去检测和纠正它们。</p><p id="1ba2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使处理并发系统更加困难的是它们固有的不确定性:相同的程序，相同的输入，在不同的运行中会有不同的表现。这导致了极少发生的错误，并且不容易重现。这样的bug可能是真正的噩梦。你的系统有问题，你知道它，你已经看到它，但是直到你能让它再次发生，你不知道如何处理这个问题。</p><p id="812d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了说明这个困难，考虑生产者和消费者系统中共享缓冲区的经典例子。这样的缓冲区保存由生产线程创建的数据，直到它们被消费线程检索。更重要的是，缓冲区充当同步器，在线程无事可做时阻塞和挂起线程。当缓冲区为空时，任何消耗线程都需要被阻塞，直到缓冲区中有数据为止。相反，如果缓冲区容量有限，当缓冲区满了时，生产线程必须挂起。</p><p id="5253" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个不幸的程序员没有使用<code class="fe mf mg mh mi b">java.util.concurrent</code>中的缓冲实现，而是写了下面的<code class="fe mf mg mh mi b">Buffer</code>类:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="53f4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">缓冲区被实现为循环列表。方法<code class="fe mf mg mh mi b">get</code>使用<code class="fe mf mg mh mi b">wait</code>挂起调用线程，直到缓冲区不为空。然后线程从缓冲区中移除一个对象，并对<code class="fe mf mg mh mi b">notify</code>进行一次调用来(潜在地)解锁一个生产线程。方法<code class="fe mf mg mh mi b">put</code>是对称的。这两个方法都是<code class="fe mf mg mh mi b">synchronized</code>，以便它们的执行对所有线程来说都是原子的。特别是，当缓冲区被另一个线程修改时，一个线程看不到中间状态。(这也是为什么对<code class="fe mf mg mh mi b">notify</code>的调用可以在缓冲区被实际修改之前发生。)</p><p id="3204" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里使用的挂起Java线程的基本机制是方法<code class="fe mf mg mh mi b">Object.wait</code>，它无条件地挂起一个线程。每个调用<code class="fe mf mg mh mi b">x.wait()</code>的线程都被挂起并放入对象<code class="fe mf mg mh mi b">x</code>的<em class="ml">等待集</em>(每个Java对象都有一个等待集)。对<code class="fe mf mg mh mi b">x.notify()</code>的调用选择<code class="fe mf mg mh mi b">x</code>的等待集中的线程，如果有的话，以恢复执行。对<code class="fe mf mg mh mi b">x.notifyAll()</code>的调用允许<code class="fe mf mg mh mi b">x</code>的等待集中的所有线程恢复执行。如果等待集为空，对<code class="fe mf mg mh mi b">notify</code>或<code class="fe mf mg mh mi b">notifyAll</code>的调用无效。(这是对这些方法过于简化的描述；详见<a class="ae mm" href="https://docs.oracle.com/javase/specs/jls/se17/html/jls-17.html#jls-17.2" rel="noopener ugc nofollow" target="_blank"> Java语言规范</a>。)</p><p id="8e12" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该缓冲区实现中使用的策略是使用缓冲区对象的等待集(即在<code class="fe mf mg mh mi b">this</code>上调用<code class="fe mf mg mh mi b">wait()</code>，并允许一个被阻塞的线程在每次缓冲区修改后恢复执行。这个想法是，在将一个对象放入<em class="ml">缓冲区后(或移除一个对象后)，没有理由通知<em class="ml">多个</em>线程。</em></p><h1 id="08f1" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">一只虫子！</h1><p id="7236" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">有一天，<code class="fe mf mg mh mi b">Buffer</code>类的作者接到一个客户的电话，通知他他写的系统完全冻结了，什么也没有发生，一切都停滞了，数百万的钱正在流失，这是不可接受的。</p><p id="fe03" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在用程序员解决每个问题的方式解决了眼前的问题(也就是说，拔掉插头，重新启动整个该死的东西)之后，在为给他的客户造成的任何不便深表歉意之后，我们的开发人员决定，如果他能保证这种情况在将来不会再次发生，他的工作会更安全。因此，他开始了一项调试任务。</p><p id="d70d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的伙伴有点过时(他使用打印语句进行调试)，但并不完全愚蠢。他猜测(正确地)他的缓冲区实现会导致线程死锁(T21)。因此，他决定编写缓冲区的注释版本，以便研究死锁后的执行跟踪:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="eeae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，他编写了一个程序来创建生产和消费线程，试图重现几乎毁掉他最重要的客户的死锁。他使用<code class="fe mf mg mh mi b">Thread.sleep</code>来模拟真实系统的处理任务(在将对象添加到缓冲区之前创建对象所花费的时间，以及在将对象从缓冲区中移除之后处理对象所花费的时间)，它将一个线程挂起一段指定的时间(就好像该线程正忙于正在模拟的工作一样):</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="6173" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用<code class="fe mf mg mh mi b">Thread.sleep</code>有两大好处。首先，挂起的线程不使用CPU资源，所以客户的大型系统可以在一台便宜的笔记本电脑上模拟——这是我们的错误代码作者所能负担的。第二，<code class="fe mf mg mh mi b">sleep</code>方法可以输入随机值来模拟一大类短、中和长的处理任务。这是必要的，因为系统是不确定的，只有<em class="ml">一些</em>计时值可以产生期望的死锁。因此，使用尽可能多的不同值的组合是必要的，对于这些组合，伪随机数是合适的(虽然不是很好，但那是改天讨论的内容)。</p><p id="283e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后一步，我们的程序员编写一个主程序来监控生产者-消费者应用程序。这个程序每分钟都会检查缓冲区等待集的大小。如果等于线程总数，则意味着<em class="ml">所有的</em>线程都在等待，没有线程运行来通知它们，这是客户观察到的死锁情况:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mj mk l"/></div></figure><h1 id="98b7" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">靠运气</h1><p id="bb2b" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">剩下的工作就是运行程序直到死锁发生，然后分析产生的跟踪以了解哪里出错了。抛开分析跟踪的问题(这可能很棘手，因为来自不同线程的打印语句往往以令人困惑的方式交织在一起)和理解后解决实际问题的问题，第一个挑战是获得合适的跟踪，也就是说，让死锁再次发生。</p><p id="9bf2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在他的第一次尝试中，我们勇敢的程序员如下开始他的程序:</p><pre class="km kn ko kp gt mn mi mo mp aw mq bi"><span id="395b" class="mr ld iq mi b gy ms mt l mu mv">java AnnotatedBuffer 10 5 5 50 50</span></pre><p id="c60f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这创建了一个容量为10的缓冲区，5个生产者，5个消费者，并模拟生产和消费任务，随机计时在0到50毫秒之间。</p><p id="96da" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">几个小时后——因为他的廉价笔记本电脑中的风扇开始产生难闻的烟雾——他放弃了，决定尝试不同的参数组合。经过多次尝试后，参数组合最终在不到两个小时的时间内产生了一个死锁，并带有一个跟踪:</p><pre class="km kn ko kp gt mn mi mo mp aw mq bi"><span id="6f87" class="mr ld iq mi b gy ms mt l mu mv">java AnnotatedBuffer 5 10 3 10 3<br/>20:53:45.695: DEADLOCK after 13963562 messages and 6477.4 seconds!</span></pre><p id="3917" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，跟踪是很难的，部分是因为在线程被通知的时刻和它打印<em class="ml">“我被通知了”</em>的时刻之间有延迟(和额外的消息)，而且还因为有13个线程要跟踪。</p><p id="7ea8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如爱因斯坦所说，由于CPU周期比灰质便宜，我们的程序员决定继续寻找一个包含更少线程的死锁。他最终得到了一个，碰巧是这个系统最小的非平凡死锁情况:</p><pre class="km kn ko kp gt mn mi mo mp aw mq bi"><span id="6ae7" class="mr ld iq mi b gy ms mt l mu mv">java AnnotatedBuffer 2 3 2 3 2<br/>01:35:39.047: DEADLOCK after 3970423422 messages and 1576335.9 seconds!</span></pre><p id="ea72" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，这几乎是40亿条消息，并且连续超过18天！(本页使用的输出是真实的。它来自于在8核机器上的实际运行，而不是我们不幸的程序员的笔记本电脑)。</p><p id="dabe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">跟踪分析揭示了缓冲区实现中的缺陷:所有线程(生产者和消费者)都在<em class="ml">相同的</em>等待集中等待。当方法<code class="fe mf mg mh mi b">get</code>调用<code class="fe mf mg mh mi b">notify</code>时，目的是通知<em class="ml">生产者</em>缓冲区中有一个可用的槽。但是这个调用有时会通知一个<em class="ml">消费者</em>，如果这种情况发生几次，就会导致死锁。</p><h1 id="0486" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">应用正式方法</h1><p id="c1a4" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">在对他的代码进行快速修复之后——用<code class="fe mf mg mh mi b">notifyAll</code>替换<code class="fe mf mg mh mi b">notify</code>,从而以低效为代价带回了正确性——我们如释重负的程序员认为他可以开始放松了。但是他不能。一个问题一直困扰着他:如果这发生在一个更复杂的系统上呢？如果他下次没这么幸运呢？如果下一个bug一个月才出现一次呢？一年一次？如果在部署的代码中产生bug的特定时间不能在他的测试设置中重现，该怎么办？</p><p id="0ccc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，我们的程序员决定报名参加<a class="ae mm" href="https://catalog.unh.edu/search/?search=cs+745" rel="noopener ugc nofollow" target="_blank">正式方法课程</a>，在那里他接触到了跟踪并发软件中棘手bug的替代技术。他学习了TLA+，动作的<a class="ae mm" href="http://research.microsoft.com/en-us/um/people/lamport/tla/tla.html" rel="noopener ugc nofollow" target="_blank"> <em class="ml">时序逻辑</em> </a>，以及TLA+的模型检查器TLC。他意识到像这样的符号和工具会对他的工作有所帮助，并开始在他的有界缓冲区问题上练习使用它们。</p><p id="1c7c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有界缓冲器的中心算法可以被建模为TLA+模块:</p><pre class="km kn ko kp gt mn mi mo mp aw mq bi"><span id="192d" class="mr ld iq mi b gy ms mt l mu mv">EXTENDS Naturals, Sequences<br/><br/>CONSTANTS Producers,<br/>          Consumers,<br/>          BufCapacity,<br/>          Data<br/><br/>ASSUME /\ Producers # {}<br/>       /\ Consumers # {}<br/>       /\ Producers \intersect Consumers = {}<br/>       /\ BufCapacity &gt; 0<br/>       /\ Data # {}<br/>...</span></pre><p id="96ee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">TLA+是一种基于集合论的数学符号，大量使用数学符号(很少使用“关键词”)。由于这个原因，它漂亮的打印形式比原始的ASCII源代码更具可读性。因此，我们将以漂亮的印刷形式继续描述<code class="fe mf mg mh mi b">Buffer</code>模块:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mw"><img src="../Images/5d7cd1c121f80b829f74a56436d9246b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qqagXW2wHQKQIWoKZuNhgA.png"/></div></div></figure><p id="bbc2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">TLA+模块以几个常量开始，这些常量充当参数:一组生产线程、一组消费线程、一个缓冲区容量和一个数据类型(把<em class="ml">数据</em>想象成java类中的类型参数<code class="fe mf mg mh mi b">E</code>)。为了使模块有意义，我们需要假设线程集是不相交的且非空的，缓冲区容量至少为1，并且至少有一条数据可以通过缓冲区发送。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mw"><img src="../Images/b14be9ff949c89a7ca89477e536ca036.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5sGVOcZz_bgv_tegP71CMA.png"/></div></div></figure><p id="6070" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，该模块为缓冲区(作为一系列数据元素)及其等待集(作为一组线程)引入变量。<em class="ml"> RunningThreads </em>定义为所有线程(<em class="ml">参与者</em>)与当前等待集合中的线程之间的集合差。因此，它是当前正在运行的一组线程。</p><p id="833e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，该模块定义了三个“宏”(<em class="ml">操作符</em>，在TLA+)来对Java方法<code class="fe mf mg mh mi b">wait</code>、<code class="fe mf mg mh mi b">notify</code>和<code class="fe mf mg mh mi b">notifyAll</code>进行建模。这些定义可能看起来很奇怪(有点吓人)，但是你会习惯的。然而，为了理解它们，我们需要深入一点TLA+语义。</p><p id="b690" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">基本上，TLA+模块定义了一个<em class="ml">状态转换系统</em>。一个状态(变量名到值的映射)<em class="ml">通过代表系统行为的动作转移</em>到一个新的状态。动作在逻辑上被定义为动作前状态下的值和动作后状态下的值之间的关系。例如，Java赋值语句<code class="fe mf mg mh mi b">x = 3*x + 1;</code>对应于关系<code class="fe mf mg mh mi b">x' = 3*x + 1</code>。请注意，这是一个布尔公式，<code class="fe mf mg mh mi b">=</code>是古老的数学等式，<em class="ml">不是</em>赋值。因此，<code class="fe mf mg mh mi b">x’ ≥ x</code>或<code class="fe mf mg mh mi b">(x' - x) % 7 = 1</code>是可能的TLA动作，尽管它们在Java这样的编程语言中没有对等词。特别是，人们可以编写<em class="ml">不确定的</em>动作(就像上面的最后两个动作，给定<code class="fe mf mg mh mi b">x</code>，有几个可能的<code class="fe mf mg mh mi b">x'</code>值)，这在建模并发系统时非常有用。</p><p id="bfda" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">考虑到这一点，现在有可能破译<code class="fe mf mg mh mi b">wait</code>(无条件地将线程<code class="fe mf mg mh mi b">t</code>添加到等待集)；<code class="fe mf mg mh mi b">notifyAll</code>(从变为空的等待集中移除每个线程)和<code class="fe mf mg mh mi b">notify</code>(如果等待集不为空，移除一个线程，否则不做任何事情)的TLA+公式。<code class="fe mf mg mh mi b">notify</code>的情况是最有趣的，因为它的建模是非确定性的:<em class="ml">某个</em>线程被从等待集中移除，但是我们没有指定是哪一个(Java语言规范也没有指定)。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mw"><img src="../Images/bb3fc6d6f244508251d5b3f162383da5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uZ4uCWuNRpWB9HChIhyNTQ.png"/></div></div></figure><p id="2ac5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用这些类似Java的操作符，模块继续形式化<code class="fe mf mg mh mi b">put</code>和<code class="fe mf mg mh mi b">get</code>方法。TLA+公式模仿Java代码，很直接:<code class="fe mf mg mh mi b">Put(t, m)</code>:如果缓冲区未满，在末尾加<code class="fe mf mg mh mi b">m</code>并通知；否则，线程<code class="fe mf mg mh mi b">t</code>等待，缓冲区保持不变。因为Java方法是<em class="ml">同步的</em>，所以它可以被建模为单个TLA+转换。</p><p id="8de5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，该模块指定可接受的初始状态(在本例中，只有一种可能的初始状态:所有线程都在运行，缓冲区为空)以及系统所有可能的转换。<code class="fe mf mg mh mi b">Next</code>的定义如下:为了使系统转换到下一个状态，<em class="ml">当前正在运行的某个</em>线程<code class="fe mf mg mh mi b">t</code>执行一个操作；要么<code class="fe mf mg mh mi b">t</code>是生产者，它试图将<em class="ml">的某个</em>数据块<code class="fe mf mg mh mi b">m</code>放入缓冲区；或者<code class="fe mf mg mh mi b">t</code>是一个消费者，它试图从缓冲区中检索一些数据。</p><p id="490d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">确定性系统对于给定的输入只有一种可能的行为。不确定性系统可以有很多，这就是为什么它们很难测试和调试的原因。这里研究的死锁发生在<em class="ml">这些行为中的一些</em>中，但不是全部(正如我们之前看到的，有<em class="ml">许多</em>行为没有发生死锁)。TLA+模型的不确定性有三个来源:调用<code class="fe mf mg mh mi b">notify</code>时哪个线程被唤醒；哪个线程获得了缓冲区的锁，并可以尝试一个<code class="fe mf mg mh mi b">put</code>或<code class="fe mf mg mh mi b">get</code>操作；以及当线程是生产者时，将哪段数据放入缓冲区。请注意，所有这些不确定性是如何使用逻辑析取或存在量词(基本上是一回事)引入的。还要注意，不确定性的第三个来源在Java程序中可能不存在(生产者倾向于生产特定的元素)，而且无论如何也是不相关的。不确定性的另外两个来源是那些使系统分析复杂化并导致潜在死锁的来源。(实际上，进一步的研究将表明，即使<code class="fe mf mg mh mi b">notify</code>成为FIFO，死锁仍然是可能的，所以它实际上是不确定性的第二个来源，线程的调度和锁的争用，这是我们所有麻烦的原因。)</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mw"><img src="../Images/078f39544347c06016059682c613bf41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*37EgegwGGFHJg9w4vh8xBQ.png"/></div></div></figure><p id="1c2f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">TLA+模块以系统的期望属性的形式化结束，即它是无死锁的。<code class="fe mf mg mh mi b">NoDeadlock</code>公式表示总有至少一个线程在运行(◻时间操作符使其适用于<em class="ml">系统的所有</em>状态)，该定理表示系统是类型正确的并且满足<code class="fe mf mg mh mi b">NoDeadlock</code>属性。</p><h1 id="b07c" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">薄层色谱模型检查器</h1><p id="72dd" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">TLA+模块可用于多种用途。它可以作为随机模拟的基础，类似于用<code class="fe mf mg mh mi b">AnnotatedBuffer</code> Java程序所做的。更重要的是，人们可以正式地<em class="ml">证明</em>模块的正确性，即模型满足期望的属性。TLA+有证明规则——基于经典概念，如<em class="ml">归纳不变量</em>和<em class="ml">良好基础集合——这些规则</em>可用于正式推导模块结尾陈述的逻辑含义。</p><p id="0927" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">作为证明的替代，<a class="ae mm" href="http://cacm.acm.org/magazines/2008/7/5378-qa-talking-model-checking-technology/fulltext" rel="noopener ugc nofollow" target="_blank"> <em class="ml">模型检测</em> </a>是一种在工业上应用相当成功的方法。它比随机模拟强大得多，也比形式证明容易实现得多。模型检查的工作原理基本上是枚举系统所有可能的行为，并检查它们是否都具有所需的属性。</p><p id="83d9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae mm" href="http://research.microsoft.com/en-us/um/people/lamport/tla/toolbox.html" rel="noopener ugc nofollow" target="_blank"> TLC </a>是TLA+的<em class="ml">型号检查器</em>。虽然它非常有用，但从概念上讲，TLC是一个相当笨的工具。当面对几种可能性时(如在非确定性系统的行为中)，它拒绝选择。不像Buridan的屁股(更像非确定性图灵机)，TLC不会卡在可能性之间；它探索了所有这些。更具体地说，TLC试图以广度优先的方式计算系统的所有可达状态。这与我们的程序员之前所做的测试形成对比，之前的测试只尝试了<em class="ml">一些</em>随机选择的路径。</p><p id="02ec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由此可见，该工具的优势和局限性显而易见。一方面，它不是靠运气找到bug的；另一方面，即使是小的非确定性系统也可能有太多的状态需要进行模型检查。这个问题——状态数量的指数增长——多年来一直是模型检验社区的研究人员最讨厌的问题。</p><p id="e299" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">尽管如此，模型检查仍然是一项非常有用的技术，这可以通过将其应用于我们的有界缓冲区问题来证明。要启动TLC，需要通过给所有常量赋值来实例化一个模块。对于缓冲区示例，TLC配置文件可能如下所示:</p><pre class="km kn ko kp gt mn mi mo mp aw mq bi"><span id="5fd5" class="mr ld iq mi b gy ms mt l mu mv">SPECIFICATION Prog<br/>CONSTANTS     Producers = {p1,p2,p3,p4,p5}<br/>              Consumers = {c1,c2,c3,c4,c5}<br/>              BufCapacity = 10<br/>              Data = {m1}<br/>INVARIANT     TypeInv<br/>PROPERTY      NoDeadlock</span></pre><p id="3f85" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">(因为放入缓冲区的内容是不相关的，所以使用非常小的<code class="fe mf mg mh mi b">Data</code>集合大大减少了要探索的状态的数量。)</p><p id="dc1c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">给定这种配置，TLC产生以下输出:</p><pre class="km kn ko kp gt mn mi mo mp aw mq bi"><span id="506e" class="mr ld iq mi b gy ms mt l mu mv">Computing initial states...<br/>Finished computing initial states: 1 distinct state generated.<br/>Model checking completed. <strong class="mi ir">No error has been found</strong>.<br/>  Estimates of the probability that TLC did not check all reachable states because two distinct states had the same fingerprint:<br/>  calculated (optimistic):  val = 3.9E-14<br/>  based on the actual fingerprints:  val = 1.3E-15<br/>3461 states generated, 223 distinct states found, 0 states left on queue.<br/>The depth of the complete state graph search is 20.</span></pre><p id="7375" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">换句话说，如果缓冲区的容量为10，并且在5个生产者和5个消费者之间共享，则系统是无死锁的。这是我们的程序员在他的笔记本电脑开始冒烟时放弃的配置。他放弃是正确的:这个体系永远不会陷入僵局。</p><p id="206c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是，如果TLC在具有3个生产者、2个消费者和容量为2的缓冲器的配置上启动，它会产生以下输出:</p><pre class="km kn ko kp gt mn mi mo mp aw mq bi"><span id="8ecf" class="mr ld iq mi b gy ms mt l mu mv">Computing initial states...<br/>Finished computing initial states: 1 distinct state generated.<br/>Error: Invariant NoDeadlock is violated.</span></pre><p id="b539" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就其本身而言，这并不是很有用。这很像客户打来的投诉电话，说什么都挂了。关于TLC最好的事情是接下来发生的事情，<em class="ml">导致死锁状态的系统的明确跟踪:</em></p><pre class="km kn ko kp gt mn mi mo mp aw mq bi"><span id="cccf" class="mr ld iq mi b gy ms mt l mu mv">Error: The behavior up to this point is:<br/>State 1: &lt;Initial predicate&gt;<br/>/\ buffer = &lt;&lt;&gt;&gt;<br/>/\ waitSet = {}<br/><br/>State 2: &lt;Action line 52, col 9 to line 53, col 62 of module Buffer&gt;<br/>/\ buffer = &lt;&lt;m1&gt;&gt;<br/>/\ waitSet = {}<br/><br/>State 3: &lt;Action line 52, col 9 to line 53, col 62 of module Buffer&gt;<br/>/\ buffer = &lt;&lt;m1, m1&gt;&gt;<br/>/\ waitSet = {}<br/><br/>State 4: &lt;Action line 52, col 9 to line 53, col 62 of module Buffer&gt;<br/>/\ buffer = &lt;&lt;m1, m1&gt;&gt;<br/>/\ waitSet = {p1}</span><span id="9321" class="mr ld iq mi b gy mx mt l mu mv">&lt;...&gt;</span><span id="1867" class="mr ld iq mi b gy mx mt l mu mv">State 24: &lt;Action line 52, col 9 to line 53, col 62 of module Buffer&gt;<br/>/\ buffer = &lt;&lt;m1, m1&gt;&gt;<br/>/\ waitSet = {p1, p2, p3, c1, c2}<br/><br/>385 states generated, 86 distinct states found, 2 states left on queue.<br/>The depth of the complete state graph search is 24.</span></pre><p id="6779" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">达到死锁需要23次转换。因为TLC以广度优先的方式工作，所以没有导致死锁的更短的行为。对于Java程序来说，这23个动作实际上以正确的顺序发生，需要运气(测试时的<em class="ml">好运气</em>，部署后的<em class="ml">坏运气</em>)。因此，故意让它发生是困难的。</p><p id="ec3b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">其中有几个转变值得注意，比如这个:</p><pre class="km kn ko kp gt mn mi mo mp aw mq bi"><span id="e491" class="mr ld iq mi b gy ms mt l mu mv">State 10: &lt;Action line 52, col 9 to line 53, col 62 of module Buffer&gt;<br/>/\ buffer = &lt;&lt;&gt;&gt;<br/>/\ waitSet = {p3, c1, c2}<br/><br/>State 11: &lt;Action line 52, col 9 to line 53, col 62 of module Buffer&gt;<br/>/\ buffer = &lt;&lt;m1&gt;&gt;<br/>/\ waitSet = {c1, c2}</span></pre><p id="f4d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">某个生产者(<code class="fe mf mg mh mi b">p1</code>或<code class="fe mf mg mh mi b">p2</code>，因为<code class="fe mf mg mh mi b">p3</code>被挂起)成功地将<code class="fe mf mg mh mi b">m1</code>放入缓冲区并调用<code class="fe mf mg mh mi b">notify</code>。但是，<em class="ml">生产者</em> <code class="fe mf mg mh mi b">p3</code>被通知并从等待集合中移除，而不是消费者。如前所述，这个缓冲区实现的问题是生产者和消费者等待同一个集合。同理，从状态19到状态20的转换有<code class="fe mf mg mh mi b">p1</code>调用<code class="fe mf mg mh mi b">notify</code>，通知<code class="fe mf mg mh mi b">p2</code>；从状态20到21，另一个<code class="fe mf mg mh mi b">put</code>操作通知<code class="fe mf mg mh mi b">p1:</code></p><pre class="km kn ko kp gt mn mi mo mp aw mq bi"><span id="a52a" class="mr ld iq mi b gy ms mt l mu mv">State 21: &lt;Action line 52, col 9 to line 53, col 62 of module Buffer&gt;<br/>/\ buffer = &lt;&lt;m1, m1&gt;&gt;<br/>/\ waitSet = {c1, c2}</span></pre><p id="10cc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此时，缓冲区已满，没有用户线程正在运行。情况无望，最终导致状态24:</p><pre class="km kn ko kp gt mn mi mo mp aw mq bi"><span id="eb66" class="mr ld iq mi b gy ms mt l mu mv">State 24: &lt;Action line 52, col 9 to line 53, col 62 of module Buffer&gt;<br/>/\ buffer = &lt;&lt;m1, m1&gt;&gt;<br/>/\ waitSet = {p1, p2, p3, c1, c2}</span></pre><p id="3f14" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所有五个线程都在等待集合中:死锁！(完整的轨迹可在<a class="ae mm" href="https://gist.github.com/charpov/45cf6010f188764dbd864332131c2e43" rel="noopener ugc nofollow" target="_blank">这里</a>获得。)</p><h1 id="5b06" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">模型检查的局限性</h1><p id="8b94" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">当然，如果事情总是像这样很好地工作，模型检查将会在小学被教授。作为一种技术，模型检查有一个严重的缺点，称为<em class="ml">状态爆炸</em>。(从技术上来说，<em class="ml">状态空间爆炸</em>是一个更好的术语。爆发的不是国家。事实上，没有什么真正的<em class="ml">爆炸</em>和模型检查是一个非常安全的活动。)由于原子动作的所有可能的交错，如果一些状态变量是无界的，则系统可达到的状态的数量可以迅速变得巨大，或者甚至是无限的。事实上，大多数与模型检查相关的研究都集中在状态爆炸问题上，不管是哪种方式(符号模型检查、抽象等等)。</p><p id="5024" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">作为说明，再次考虑容量为10但有21个线程(11个生产者和10个消费者)的缓冲区示例。这个系统可能会死锁。最短的轨迹是431步，TLC必须生成2，219，959，047个状态(其中23，011，357个是不同的)才能找到它。随机计时的Java程序会发生多长时间？</p><p id="bfe1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里描述的缓冲区示例恰好在线程数量最多是缓冲区容量的两倍时是无死锁的。但这不是通过模型检查就能显示出来的。如前所述，在TLA模型上进行数学证明是可能的，但这并不像运行模型检查器那么容易。然而，证明(可能结合一些模型检查)仍然是处理无限(或大型)状态空间的唯一方法。</p><p id="2c20" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里的教训是，一个正式的模型可以用于许多目的，简单的模型检查可以是发现由不确定性导致的错误的一种方式，对于这种情况，测试可能非常棘手(并且需要耐心、计算资源，以及更成问题的运气)。</p><p id="6195" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">TLA+/TLC已经被用于在比我们简单的缓冲区复杂得多的系统中发现错误。例如，亚马逊的工程师已经用它来寻找他们的aws分布式系统中的缺陷(例如，参见<a class="ae mm" href="https://dl.acm.org/doi/10.1145/2699417" rel="noopener ugc nofollow" target="_blank"> <em class="ml">亚马逊网络服务如何使用正式方法</em> </a>)。</p><p id="639c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">存在其他正式的符号，但是TLA+被证明是最有用的符号之一，尽管它的语法过于数学化，一开始可能会令人生畏。如果需要，可以通过使用<a class="ae mm" href="http://lamport.azurewebsites.net/tla/high-level-view.html#pluscal?unhideBut=hide-pluscal&amp;unhideDiv=pluscal" rel="noopener ugc nofollow" target="_blank"> PlusCal </a>(一种从伪代码中生成TLA+的工具)，或者其他模型检查器，如<a class="ae mm" href="http://spinroot.com/spin/whatispin.html" rel="noopener ugc nofollow" target="_blank"> Spin </a>(它依赖于一种类似C语言的模式系统)来避免一些数学运算。</p></div></div>    
</body>
</html>