<html>
<head>
<title>JavaScript Fetch API — Basics</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript获取API —基础</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-fetch-api-basics-5b28b47cde74?source=collection_archive---------8-----------------------#2020-07-10">https://levelup.gitconnected.com/javascript-fetch-api-basics-5b28b47cde74?source=collection_archive---------8-----------------------#2020-07-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8802" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">非常简单！Fetch API解释了一个示例代码和一个图表。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/cca39def2112d98be9957c3cf6130f93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*iW6lglSu7NLzKvV0"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">Emile Perron 在<a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="a3b2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这篇短文中，我解释了开始使用Fetch API所必需的基本概念。我通过开发一个简短的示例代码并一步一步地解释它来做到这一点。您可以在本文末尾找到完整的示例。</p><p id="72cd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在示例代码中，我将向<a class="ae kv" href="https://restcountries.eu/" rel="noopener ugc nofollow" target="_blank"> restcountries.eu </a>发出一个HTTP请求，以获取国家列表及其详细信息，比如它们的首都、国家代码、货币等等。我写过一篇文章描述使用<em class="ls"> XMLHttpRequest() </em>做同样的事情。</p><div class="lt lu gp gr lv lw"><a href="https://medium.com/swlh/javascript-xmlhttprequest-basics-3da6f7e99dcc" rel="noopener follow" target="_blank"><div class="lx ab fo"><div class="ly ab lz cl cj ma"><h2 class="bd ir gy z fp mb fr fs mc fu fw ip bi translated">JavaScript XMLHttpRequest —基础知识</h2><div class="md l"><h3 class="bd b gy z fp mb fr fs mc fu fw dk translated">使用XMLHttpRequest发出HTTP请求比您想象的要简单——包括代码和图表</h3></div><div class="me l"><p class="bd b dl z fp mb fr fs mc fu fw dk translated">medium.com</p></div></div><div class="mf l"><div class="mg l mh mi mj mf mk kp lw"/></div></div></a></div></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="ac10" class="ms mt iq bd mu mv mw mx my mz na nb nc jw nd jx ne jz nf ka ng kc nh kd ni nj bi translated">获取API —实际示例</h1><p id="cd2c" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">先说显而易见的。Fetch是一个基于承诺的接口，它允许我们从JavaScript代码发出HTTP请求。我会尽量让“基于承诺”的部分变得简单。然而，如果你想知道更多，那么在这篇文章的最后，我附上了我的另外两篇描述承诺和承诺链基础的文章的链接。</p><p id="7fd2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls"> fetch() </em>方法有两个参数:</p><ul class=""><li id="3521" class="np nq iq ky b kz la lc ld lf nr lj ns ln nt lr nu nv nw nx bi translated">统一资源定位器</li><li id="d457" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated">我们可以定义请求设置的init对象。</li></ul><p id="620c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第二个参数是可选的，默认设置是基本HTTP请求所需要的，所以我将跳过它。我们可以提出这样一个基本要求…</p><pre class="kg kh ki kj gt od oe of og aw oh bi"><span id="6a45" class="oi mt iq oe b gy oj ok l ol om">const aThing = fetch('http://restcountries.eu/rest/v2/all', {})</span></pre><p id="2470" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">问题是——我们从<em class="ls"> fetch() </em>方法中得到什么？我们可以通过添加这几行来得到这个问题的答案…</p><pre class="kg kh ki kj gt od oe of og aw oh bi"><span id="22a6" class="oi mt iq oe b gy oj ok l ol om">console.log(aThing)</span><span id="7a33" class="oi mt iq oe b gy on ok l ol om">setTimeout( () =&gt; {<br/>    console.log(aThing)<br/>}, 1000)</span></pre><p id="6610" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这里，我们只是在<em class="ls"> fetch() </em>发出请求后立即打印一个东西(返回的内容<em class="ls"> fetch() </em>),然后在一秒钟后再次打印。这是我们在控制台中看到的内容(图1)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/a25d72fac372f5db4eb90f8f8f891694.png" data-original-src="https://miro.medium.com/v2/resize:fit:1168/format:webp/1*cCpKsrvWyHxgq2dxtJToug.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">图一。从fetch()返回的Promise对象</figcaption></figure><p id="978d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们问题的答案是——它返回一个Promise对象。由<em class="ls"> fetch() </em>创建的Promise对象是挂起的，直到我们得到服务器的响应。这就是为什么在控制台(图1)中，我们首先得到<em class="ls">承诺{ &lt;待决&gt; } </em>，然后经过一段延迟<em class="ls">承诺{ &lt;已解决&gt;:响应} </em>。承诺通过代表响应的响应对象得到解析。</p><p id="3791" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由<em class="ls"> fetch() </em>创建的承诺被异步解析。意思是<em class="ls"> fetch() </em>发送请求并马上返回，然后执行我们剩下的代码。在收到响应后，承诺被实现，并调用该承诺的成功处理程序。</p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h2 id="81c6" class="oi mt iq bd mu op oq dn my or os dp nc lf ot ou ne lj ov ow ng ln ox oy ni oz bi translated">Then()方法</h2><p id="bf54" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">这就是你进来的地方。使用<em class="ls"> then() </em>方法定义成功处理程序。你可以这样做:</p><pre class="kg kh ki kj gt od oe of og aw oh bi"><span id="584d" class="oi mt iq oe b gy oj ok l ol om">fetch('URL')<strong class="oe ir">.then(successHandler)</strong></span></pre><p id="58a1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">其中<em class="ls"> successHandler()是</em>一个接受一个参数的函数。这个论点就是承诺解决的问题——响应对象。将使用响应对象作为参数调用<em class="ls"> successHandler() </em>函数。这是您定义如何处理响应的地方。</p><p id="6714" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你也可以这样做…</p><pre class="kg kh ki kj gt od oe of og aw oh bi"><span id="7e14" class="oi mt iq oe b gy oj ok l ol om">fetch('URL')<strong class="oe ir">.then(successHandler, errorhandler)</strong></span></pre><p id="15d2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">其中<em class="ls"> errorHandler() </em>是一个接受一个参数的函数——被拒绝承诺的错误原因或值。然而，更常见的情况是只定义成功处理程序，并有一个<em class="ls"> catch() </em>方法来捕捉和处理承诺链末端的所有错误。</p><p id="0852" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个阶段，我们可以在控制台中打印响应对象，让我们开始吧。我将在<em class="ls"> then() </em>方法的参数列表中将成功处理程序定义为匿名函数，如下所示…</p><pre class="kg kh ki kj gt od oe of og aw oh bi"><span id="3c00" class="oi mt iq oe b gy oj ok l ol om">const aThing = fetch('http://restcountries.eu/rest/v2/all', {})<br/><strong class="oe ir">.then( (response) =&gt; {<br/>    console.log(response)<br/>})</strong></span><span id="256d" class="oi mt iq oe b gy on ok l ol om">console.log(aThing)</span><span id="0f3b" class="oi mt iq oe b gy on ok l ol om">setTimeout( () =&gt; {<br/>    console.log(aThing)<br/>}, 1000)</span></pre><p id="6a83" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是我们现在在控制台中看到的内容…</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pa"><img src="../Images/8061ed975ff0ff7e5086c46116a60d83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MZeSMflOPvB6mdJBI7n_gg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">图二。响应对象</figcaption></figure><p id="36e6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如我们在图2中看到的，<em class="ls">‘Live reload enabled’。</em>标志着我们的同步代码结束的地方。之后的一切都被异步调用。在这种情况下，我们</p><ul class=""><li id="494e" class="np nq iq ky b kz la lc ld lf nr lj ns ln nt lr nu nv nw nx bi translated">首先使用<em class="ls"> fetch() </em>发出请求</li><li id="8484" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated">然后，我们使用<em class="ls"> then() </em>注册成功处理程序</li><li id="a1e2" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated">然后在控制台中打印一个东西(待定承诺)。</li><li id="67f4" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated">然后我们注册一个函数，它会在一秒钟后运行。这是我们的同步代码结束的地方。</li></ul><p id="61f2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，响应到达，并调用成功处理程序。成功处理程序(在<em class="ls"> then() </em>方法中定义)在控制台中打印响应并终止。这就是它的全部功能。一段时间后，我们的1秒钟延迟到期，我们再次打印一个东西。</p><p id="d951" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是为什么现在说<em class="ls">承诺{ &lt;解决&gt;未定义} </em>？如果我们没有从<em class="ls"> then() </em>方法返回任何东西，为什么会被解析？为什么<em class="ls">未定义</em>而不响应？</p><p id="cdc1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">承诺周围的黑魔法是造成这种情况的原因。但我相信，所有的魔法都只是一种没有被完全理解的技术或物理现象。一个简单的解释是<em class="ls"> then() </em>方法总是返回承诺。即使不返回任何东西，<em class="ls"> then() </em>方法也会自动生成并返回一个新的履行的承诺，其值为<em class="ls"> undefined </em>。</p><p id="c49a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们附加<em class="ls"> then() </em>方法之前，aThing正在从<em class="ls"> fetch() </em>获得一个承诺。现在，这个承诺由<em class="ls"> then() </em>方法接管，aThing得到<em class="ls"> then() </em>返回的任何内容。</p><p id="8c38" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以通过在成功处理程序中添加下面一行来解决这个问题:</p><pre class="kg kh ki kj gt od oe of og aw oh bi"><span id="82d5" class="oi mt iq oe b gy oj ok l ol om">return response</span></pre></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h2 id="0287" class="oi mt iq bd mu op oq dn my or os dp nc lf ot ou ne lj ov ow ng ln ox oy ni oz bi translated">反应</h2><p id="2259" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">我们能够在控制台中打印响应对象的事实证明，我们从<a class="ae kv" href="https://restcountries.eu/" rel="noopener ugc nofollow" target="_blank"> restcountries.eu </a>获得了一些响应，并且我们可以在<em class="ls"> then() </em>方法中访问该响应。</p><p id="3a31" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们来看看我们的国家列表及其详细信息。让我们使用响应对象的<em class="ls"> text() </em>方法将其作为字符串打印到控制台。</p><pre class="kg kh ki kj gt od oe of og aw oh bi"><span id="ccb8" class="oi mt iq oe b gy oj ok l ol om">const aThing = fetch('http://restcountries.eu/rest/v2/all', {})<br/>.then( (response) =&gt; {<br/>    console.log(response<strong class="oe ir">.text()</strong>)<br/>})</span><span id="9ec4" class="oi mt iq oe b gy on ok l ol om">console.log(aThing)</span><span id="d419" class="oi mt iq oe b gy on ok l ol om">setTimeout( () =&gt; {<br/>    console.log(aThing)<br/>}, 1000)</span></pre><p id="95cf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这给了…</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pb"><img src="../Images/c4f9904a108224bad807a413e8576d00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rZlLB4cUhJURD7qEA606yw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">图3。响应体被困在承诺中</figcaption></figure><p id="5d43" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">哦不！再次承诺。</p><blockquote class="pc pd pe"><p id="9392" class="kw kx ls ky b kz la jr lb lc ld ju le pf lg lh li pg lk ll lm ph lo lp lq lr ij bi translated">Response implements Body(…)<br/>Body . text()<br/>获取一个响应流并读取它直到完成。它返回一个用USVString(文本)解析的<strong class="ky ir">承诺</strong>。— MDN网络文档</p></blockquote><p id="12d2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">到处都是承诺。由<em class="ls"> text() </em>返回的新承诺解析出我们感兴趣的字符串。怎样才能把世界各国从承诺的魔爪中解救出来？</p><p id="7117" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以通过将另一个<em class="ls"> then() </em>方法附加到现在成为承诺链的方法上，并从第一个<em class="ls"> then() </em>方法返回任何<em class="ls"> text() </em>方法返回的内容，来拯救世界。</p><p id="acfa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我刚刚意识到字符串相当长，我不知道如何在不占用整个屏幕高度的情况下方便地在控制台中打印它。我的解决方案是简单地从<em class="ls"> text() </em>切换到<em class="ls"> json() </em>方法。现在，我们将在控制台中看到一个对象数组，而不是一个字符串。</p><pre class="kg kh ki kj gt od oe of og aw oh bi"><span id="4bf7" class="oi mt iq oe b gy oj ok l ol om">const aThing = fetch('http://restcountries.eu/rest/v2/all', {})<br/>.then( (response) =&gt; {<br/>    <strong class="oe ir">return(response.json())</strong><br/>})<br/><strong class="oe ir">.then( (data) =&gt; {<br/>    console.log(data)<br/>})</strong></span><span id="7a23" class="oi mt iq oe b gy on ok l ol om">console.log(aThing)</span><span id="97e0" class="oi mt iq oe b gy on ok l ol om">setTimeout( () =&gt; {<br/>    console.log(aThing)<br/>}, 1000)</span></pre><p id="9dd0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">还有控制台…</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pi"><img src="../Images/33cce9e5ad7936316df673d72a53676c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xXsQH6u9abMfC1yPLiZzaA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">图4。响应主体—一组对象</figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pj"><img src="../Images/5126fd3054cbb78c0e6ab325410ed14e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1fKowSln2qrh7rjgfm6Kjg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">图5。响应正文—对象数组(展开)</figcaption></figure><p id="0c9a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如我们在图4和图5中看到的，我们现在可以访问从<a class="ae kv" href="https://restcountries.eu/" rel="noopener ugc nofollow" target="_blank"> restcountries.eu </a>接收的数据。</p><p id="e8d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在第一个<em class="ls"> then() </em>方法中，我们使用<em class="ls"> response.json() </em>来解析响应的主体文本，然后我们返回它。黑魔法创造了一个新的承诺，它根据解析的结果进行解析，这就是第一个<em class="ls"> then() </em>方法真正返回的内容。</p><p id="f976" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第二个<em class="ls"> then() </em>方法中的成功处理程序接收解析结果，这是我们可以处理响应数据的地方。</p><p id="4106" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">关于<em class="ls"> fetch() </em>方法的另一个有趣的事实是，即使请求不成功，它返回的承诺也会解析为响应对象。这迫使我们首先检查响应对象的状态属性。我在下一节的最终演示代码中实现了这一点。</p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="d2b9" class="ms mt iq bd mu mv mw mx my mz na nb nc jw nd jx ne jz nf ka ng kc nh kd ni nj bi translated">演示代码</h1><p id="885f" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">下面的代码片段包含了我们在上面看到的所有代码</p><ul class=""><li id="8f4a" class="np nq iq ky b kz la lc ld lf nr lj ns ln nt lr nu nv nw nx bi translated">检查响应状态和</li><li id="6eb4" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated">承诺链末端的<em class="ls"> catch() </em>方法。</li></ul><p id="b9f5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们在读取不同于200的状态代码时抛出一个错误，那么<em class="ls"> then() </em>方法将返回一个被拒绝的承诺，并以错误消息作为其值。被拒绝的承诺沿着链传播，直到被<em class="ls"> catch() </em>方法捕获，在这种情况下，该方法只是将错误消息打印到控制台。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pk pl l"/></div></figure></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="9a35" class="ms mt iq bd mu mv mw mx my mz na nb nc jw nd jx ne jz nf ka ng kc nh kd ni nj bi translated">摘要</h1><p id="05ae" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">我们已经使用Fetch API发送请求并为响应提供服务。我们还使用了承诺和承诺链，因为Fetch API是基于承诺的。如果我们隐藏所有的函数定义，那么这就是我们所做的...</p><pre class="kg kh ki kj gt od oe of og aw oh bi"><span id="1372" class="oi mt iq oe b gy oj ok l ol om">fetch(URL).then(successCb1).then(successCb2).catch(errorCb)</span></pre><p id="4a3d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果没有图表，这篇文章会是什么呢？图表比文字更能解释代码。下图总结了代码。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pm"><img src="../Images/4f523f8b1f9dfb9af3da943eee04bdfd.png" data-original-src="https://miro.medium.com/v2/resize:fit:642/format:webp/1*Y9GwZPkCdFwFR_BJp5ct_Q.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">图6。提取流程</figcaption></figure><p id="70e2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望承诺不会让事情变得太难。如果是的话，那么你可以从这两篇文章中了解更多。</p><div class="lt lu gp gr lv lw"><a href="https://medium.com/swlh/javascript-promise-basics-d8465d70a54f" rel="noopener follow" target="_blank"><div class="lx ab fo"><div class="ly ab lz cl cj ma"><h2 class="bd ir gy z fp mb fr fs mc fu fw ip bi translated">JavaScript Promise —基础知识</h2><div class="md l"><h3 class="bd b gy z fp mb fr fs mc fu fw dk translated">用示例代码和图表很好地解释。</h3></div><div class="me l"><p class="bd b dl z fp mb fr fs mc fu fw dk translated">medium.com</p></div></div><div class="mf l"><div class="pn l mh mi mj mf mk kp lw"/></div></div></a></div><div class="lt lu gp gr lv lw"><a rel="noopener  ugc nofollow" target="_blank" href="/javascript-promise-chaining-basics-e2618c5e74a9"><div class="lx ab fo"><div class="ly ab lz cl cj ma"><h2 class="bd ir gy z fp mb fr fs mc fu fw ip bi translated">JavaScript承诺链—基础知识</h2><div class="md l"><h3 class="bd b gy z fp mb fr fs mc fu fw dk translated">没有看起来那么难。代码、图表和截图。</h3></div><div class="me l"><p class="bd b dl z fp mb fr fs mc fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="mf l"><div class="po l mh mi mj mf mk kp lw"/></div></div></a></div></div></div>    
</body>
</html>