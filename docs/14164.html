<html>
<head>
<title>Azure Durable Functions Patterns</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Azure持久功能模式</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/azure-durable-functions-patterns-49a2c81bddfb?source=collection_archive---------14-----------------------#2022-11-06">https://levelup.gitconnected.com/azure-durable-functions-patterns-49a2c81bddfb?source=collection_archive---------14-----------------------#2022-11-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="386b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有时候，无状态的Azure功能无法帮助你设计复杂解决方案的无服务器架构。这就是持久功能发挥作用的地方。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/3fd135f16852c6ea2a630ad3db44fa46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zchN-B2SEZkhczy1"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk translated">照片由<a class="ae lb" href="https://unsplash.com/@haru88?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">SAWA孝治</a>在<a class="ae lb" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="6f8f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">持久函数</strong>是Azure函数的扩展，通过它你可以使用一个或多个orchestrator函数定义一个有状态的工作流。您可以专注于业务逻辑，而不用担心管理状态和检查点。</p><p id="cc9c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本文中，在开始讨论常见的持久函数模式之前，有必要(用很少的话)解释一下存在哪些类型的持久函数，以及它们各自的作用。</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h1 id="098b" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">功能类型</h1><p id="dd35" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">使用持久函数，您可以使用不同类型的函数协同工作来达到一个共同的目标。每个功能在工作流程中扮演不同的角色。</p><ul class=""><li id="a9a9" class="mm mn iq jp b jq jr ju jv jy mo kc mp kg mq kk mr ms mt mu bi translated"><strong class="jp ir">管弦乐功能</strong>。顾名思义，这种类型的功能编排工作流。在这里，您可以决定如何以及何时调用其他函数。Orchestrator函数必须是<strong class="jp ir"> <em class="mv">确定性的</em> </strong>，这意味着结果在后续执行之间永远不会改变，因此您可以在这种类型的函数中执行的操作受到约束。</li><li id="d0ee" class="mm mn iq jp b jq mw ju mx jy my kc mz kg na kk mr ms mt mu bi translated"><strong class="jp ir">活动功能。</strong>你可以把一个活动函数想象成一个<strong class="jp ir"> <em class="mv"> worker </em> </strong>由orchestrator调用，负责一项任务并执行一些活动以完成它。</li><li id="c9b5" class="mm mn iq jp b jq mw ju mx jy my kc mz kg na kk mr ms mt mu bi translated"><strong class="jp ir">实体功能。</strong>它提供了读取和更新小<strong class="jp ir"> <em class="mv">状态</em> </strong>的方法。实体具有唯一的身份和内部状态。您可以通过标识符引用实体，并读取和更新其状态。</li><li id="2392" class="mm mn iq jp b jq mw ju mx jy my kc mz kg na kk mr ms mt mu bi translated"><strong class="jp ir">客户端功能。</strong>这是您工作流程的<strong class="jp ir"> <em class="mv">入口点</em> </strong>。有必要触发编排器或实体功能。客户端函数使用<em class="mv">持久客户端输出绑定</em>，并且可以像经典Azure函数一样被所有可用的触发器触发。</li></ul><h1 id="87d4" class="lj lk iq bd ll lm nb lo lp lq nc ls lt lu nd lw lx ly ne ma mb mc nf me mf mg bi translated">建筑模式</h1><p id="62f0" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">基本上，有六种适用于持久功能的典型模式类型:</p><ol class=""><li id="61fe" class="mm mn iq jp b jq jr ju jv jy mo kc mp kg mq kk ng ms mt mu bi translated">函数链接</li><li id="41f2" class="mm mn iq jp b jq mw ju mx jy my kc mz kg na kk ng ms mt mu bi translated">扇出/扇入</li><li id="c909" class="mm mn iq jp b jq mw ju mx jy my kc mz kg na kk ng ms mt mu bi translated">异步HTTP APIs</li><li id="39c9" class="mm mn iq jp b jq mw ju mx jy my kc mz kg na kk ng ms mt mu bi translated">监视</li><li id="595b" class="mm mn iq jp b jq mw ju mx jy my kc mz kg na kk ng ms mt mu bi translated">人际互动</li><li id="27e2" class="mm mn iq jp b jq mw ju mx jy my kc mz kg na kk ng ms mt mu bi translated">集合商</li></ol><h2 id="53f3" class="nh lk iq bd ll ni nj dn lp nk nl dp lt jy nm nn lx kc no np mb kg nq nr mf ns bi translated">1.函数链接</h2><p id="b3ec" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">这种模式非常简单，由链接函数组成，因此一个函数的输出是下一个函数的输入。这意味着以特定的顺序执行功能。这可以通过在orchestrator中调用它们来实现，在orchestrator中可以指定执行链。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nt"><img src="../Images/18ce0649263f3114d8aabe68f8eb4326.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Mq2Ur5zoP4QH2dVF57Dd7A.png"/></div></div></figure><p id="920a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用异步调用，每个调用都必须使用<em class="mv"> await/yield </em>关键字，以便在调用下一个函数之前等待函数的响应。</p><h2 id="a00f" class="nh lk iq bd ll ni nj dn lp nk nl dp lt jy nm nn lx kc no np mb kg nq nr mf ns bi translated">2.扇出/扇入</h2><p id="57a5" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">如果使用前面的模式按顺序执行函数，这种模式被认为是并行执行。通过异步执行一个活动函数<strong class="jp ir">的多个实例</strong>，可以很容易地扇出，类似于并行执行多个任务。然后，您只需等待每个功能结束，然后汇总结果或继续您的工作流程。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/90f26e7a657b0884308acbcb41c6b760.png" data-original-src="https://miro.medium.com/v2/resize:fit:1230/format:webp/1*yKdtTg_ZbKPVWG_PTDOXkg.png"/></div></figure><p id="e78a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在orchestrator内部，您必须跟踪活动函数的状态。</p><h2 id="790c" class="nh lk iq bd ll ni nj dn lp nk nl dp lt jy nm nn lx kc no np mb kg nq nr mf ns bi translated">3.异步<strong class="ak">HTTP</strong>API</h2><p id="67f8" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">这是一个<strong class="jp ir">内置的</strong>模式，当您的工作流由<strong class="jp ir">长时间运行的</strong>操作组成时，这非常有用。这种模式背后的思想是，一旦客户端函数结束执行，就提供一个端点，通过这个端点可以检查执行的状态。基本上，客户端函数触发orchestrator，然后返回一组由持久函数扩展公开的webhook HTTP APIs端点，您可以使用这些端点来查询状态、发送事件或终止执行。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/987db239d359e41e29a4b989f9477cc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:850/format:webp/1*FxLrgfOhlwfL5RSJ01ctFg.png"/></div></figure><h2 id="879a" class="nh lk iq bd ll ni nj dn lp nk nl dp lt jy nm nn lx kc no np mb kg nq nr mf ns bi translated"><strong class="ak"> 4。监视器</strong></h2><p id="30df" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">monitor模式旨在自动执行状态检查过程。与<em class="mv">异步HTTP API</em>模式相比，客户端不需要检查orchestrator执行的状态。通过计时器，您可以定义轮询速率，并在满足特定条件时定期检查。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/d40d8dab95da7726296b80c7d2560641.png" data-original-src="https://miro.medium.com/v2/resize:fit:962/format:webp/1*WPMYhJFDYe75Tu0IbhDAuw.png"/></div></figure><p id="a060" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以定义一个活动函数，当您正在检查的条件得到验证时调用该函数，并执行一些操作来通知用户，例如，您可以使用<a class="ae lb" href="https://sendgrid.com/" rel="noopener ugc nofollow" target="_blank"> SendGrid </a>发送电子邮件，或者使用<a class="ae lb" href="https://www.twilio.com/" rel="noopener ugc nofollow" target="_blank"> Twilio </a> SMS服务发送SMS。也就是说，您可以公开webhook HTTP API来检查监视器的状态，并在需要时终止执行。</p><h2 id="2ccb" class="nh lk iq bd ll ni nj dn lp nk nl dp lt jy nm nn lx kc no np mb kg nq nr mf ns bi translated">5.人际互动</h2><p id="3397" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">有时，您的业务逻辑可能需要人工交互。在自动化流程中处理它们通常很复杂，因为您需要定义一些<strong class="jp ir">逻辑来等待响应</strong>(人类不像机器那样响应)，并在交互没有在时限内到达的情况下退出执行或执行默认操作。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/74d39eb8027657d1e52179842817267e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1084/format:webp/1*tSS_GWkxUhaDIXzs3RlYsA.png"/></div></figure><p id="8ba1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种模式的一个常见例子是询问用户是否同意执行。同样，在这种情况下，您可以使用Twilio SMS服务来发送验证码，并使用另一个函数来公开webhook API端点，用户可以通过该端点发送接收到的代码。</p><h2 id="f80d" class="nh lk iq bd ll ni nj dn lp nk nl dp lt jy nm nn lx kc no np mb kg nq nr mf ns bi translated">6.集合商</h2><p id="6deb" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">这种模式利用实体功能来聚合来自一个或多个来源(如事件中心)的数据。您可以在很长一段时间内成批接收数据，也可以不接收。使用这种模式，您可以为想要聚合的指标创建一个实体实例，它拥有状态。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/cb087c164eead2ef8fc99b5390193c19.png" data-original-src="https://miro.medium.com/v2/resize:fit:920/format:webp/1*hiyYeLVm6-WZjWNxQr3kxA.png"/></div></figure><p id="f840" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">客户端应该能够查询聚合值。</p></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h1 id="12b7" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">参考</h1><ul class=""><li id="409c" class="mm mn iq jp b jq mh ju mi jy nz kc oa kg ob kk mr ms mt mu bi translated">Microsoft Azure文档</li></ul></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h1 id="1699" class="lj lk iq bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">分级编码</h1><p id="4ab4" class="pw-post-body-paragraph jn jo iq jp b jq mh js jt ju mi jw jx jy mj ka kb kc mk ke kf kg ml ki kj kk ij bi translated">感谢您成为我们社区的一员！在你离开之前:</p><ul class=""><li id="7f2b" class="mm mn iq jp b jq jr ju jv jy mo kc mp kg mq kk mr ms mt mu bi translated">👏为故事鼓掌，跟着作者走👉</li><li id="78df" class="mm mn iq jp b jq mw ju mx jy my kc mz kg na kk mr ms mt mu bi translated">📰查看<a class="ae lb" href="https://levelup.gitconnected.com/?utm_source=pub&amp;utm_medium=post" rel="noopener ugc nofollow" target="_blank">级编码出版物</a>中的更多内容</li><li id="688a" class="mm mn iq jp b jq mw ju mx jy my kc mz kg na kk mr ms mt mu bi translated">🔔关注我们:<a class="ae lb" href="https://twitter.com/gitconnected" rel="noopener ugc nofollow" target="_blank">推特</a> | <a class="ae lb" href="https://www.linkedin.com/company/gitconnected" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a> | <a class="ae lb" href="https://newsletter.levelup.dev" rel="noopener ugc nofollow" target="_blank">时事通讯</a></li></ul><p id="24e3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">🚀👉<a class="ae lb" href="https://jobs.levelup.dev/talent/welcome?referral=true" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">将像你这样的开发人员安置在顶级创业公司和科技公司</strong> </a></p></div></div>    
</body>
</html>