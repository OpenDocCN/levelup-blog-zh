<html>
<head>
<title>JavaScript/Nodejs Open Source ETL Tools and Scripts for Data Engineering — Part 1 on “Extraction”</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用于数据工程的JavaScript/Nodejs开源ETL工具和脚本——第1部分“抽取”</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-and-node-js-open-source-etl-tools-for-easy-data-engineering-part-1-on-extraction-deb9ea32b910?source=collection_archive---------5-----------------------#2022-10-22">https://levelup.gitconnected.com/javascript-and-node-js-open-source-etl-tools-for-easy-data-engineering-part-1-on-extraction-deb9ea32b910?source=collection_archive---------5-----------------------#2022-10-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="d9ed" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">本文是一个系列的一部分，为您提供关于最佳JS和Node开源ETL工具的全面指南，描述特性，展示有用的现代JS代码片段，并触及利用这些工具的一些限制。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/b8ea5c7204497e9f72664a19fec2e92e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dhgAdp9_RcLzYw9Y2A4Sgw.jpeg"/></div></div></figure><h1 id="f1a1" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">TL；速度三角形定位法(dead reckoning)</h1><ul class=""><li id="01ab" class="ly lz it js b jt ma jx mb kb mc kf md kj me kn mf mg mh mi bi translated">ETL管道的第一步是从数据源中提取数据。</li><li id="8828" class="ly lz it js b jt mj jx mk kb ml kf mm kj mn kn mf mg mh mi bi translated">在这个阶段，重要的是选择数据源，决定提取什么数据以及如何查询或检索数据。</li></ul><h1 id="c564" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">1.对于XML提取</h1><p id="ea51" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mo kd ke kf mp kh ki kj mq kl km kn im bi translated">要生成用于测试目的的随机XML数据，请访问<a class="ae mr" href="https://codebeautify.org/generate-random-xml" rel="noopener ugc nofollow" target="_blank">这里</a></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ms"><img src="../Images/d6dd82ffc01d7dfd30e32f36f0dfe977.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0SqJJ6TVNYTO3XGDcYvX4g.png"/></div></div></figure><h2 id="76ab" class="mt lb it bd lc mu mv dn lg mw mx dp lk kb my mz lo kf na nb ls kj nc nd lw ne bi translated">快速xml解析器</h2><p id="5c99" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mo kd ke kf mp kh ki kj mq kl km kn im bi translated">验证XML，将XML解析为JS对象，或者在没有基于C/C++的库和回调的情况下从JS对象构建XML。</p><pre class="kp kq kr ks gt nf ng nh ni aw nj bi"><span id="c5d5" class="mt lb it ng b gy nk nl l nm nn">const { XMLParser, XMLBuilder, XMLValidator } = require("fast-xml-parser");<br/>const fsPromise = require("fs").promises;</span><span id="5734" class="mt lb it ng b gy no nl l nm nn">const readXmlData = async (filename) =&gt; {<br/>  const readFile = await fsPromise.readFile(filename, "utf-8");<br/>  const parser = new XMLParser();<br/>  let data = parser.parse(readFile);<br/>  return data;<br/>};</span></pre><h1 id="91b0" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">2用于CSV提取</h1><p id="b281" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mo kd ke kf mp kh ki kj mq kl km kn im bi translated">要生成用于测试目的的随机CSV数据，请访问此处的<a class="ae mr" href="https://www.mockaroo.com/" rel="noopener ugc nofollow" target="_blank"/></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi np"><img src="../Images/b8cf437f1c6cc3f2b8b27fc1f3005999.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YFINTmgWT0WKiFAPu-4DlA.png"/></div></div></figure><h2 id="0d16" class="mt lb it bd lc mu mv dn lg mw mx dp lk kb my mz lo kf na nb ls kj nc nd lw ne bi translated">2.1 CSV-解析</h2><p id="9a82" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mo kd ke kf mp kh ki kj mq kl km kn im bi translated"><code class="fe nq nr ns ng b"><a class="ae mr" href="https://csv.js.org/parse/" rel="noopener ugc nofollow" target="_blank">csv-parse</a></code> <a class="ae mr" href="https://csv.js.org/parse/" rel="noopener ugc nofollow" target="_blank">包</a>是一个将CSV文本输入转换成数组或对象的解析器。它是<a class="ae mr" href="https://csv.js.org/" rel="noopener ugc nofollow" target="_blank"> CSV项目</a>的一部分。</p><p id="5bc7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">它实现了Node.js <code class="fe nq nr ns ng b"><a class="ae mr" href="http://nodejs.org/api/stream.html#stream_class_stream_transform" rel="noopener ugc nofollow" target="_blank">stream.Transform</a></code> <a class="ae mr" href="http://nodejs.org/api/stream.html#stream_class_stream_transform" rel="noopener ugc nofollow" target="_blank"> API </a>。为了方便起见，它还提供了一个简单的基于回调的API。它不仅非常容易使用，而且功能强大。它于2010年首次发布，由一个大型社区用于大数据集。</p><pre class="kp kq kr ks gt nf ng nh ni aw nj bi"><span id="71e3" class="mt lb it ng b gy nk nl l nm nn">const { parse } = require("csv-parse/sync");<br/>const readCsvData = async (filename) =&gt; {<br/>  const fileData = await fs.readFile(filename);<br/>  return await parse(fileData, {columns: true});<br/>};</span></pre><h2 id="30be" class="mt lb it bd lc mu mv dn lg mw mx dp lk kb my mz lo kf na nb ls kj nc nd lw ne bi translated">2.2 csv解析器</h2><p id="474d" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mo kd ke kf mp kh ki kj mq kl km kn im bi translated">流式CSV解析器，旨在实现最高速度以及与<a class="ae mr" href="https://npmjs.org/csv-spectrum" rel="noopener ugc nofollow" target="_blank"> csv-spectrum </a> CSV acid测试套件的兼容性。</p><p id="6e7c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe nq nr ns ng b">csv-parser</code>能够以每秒90，000行的速度将CSV转换成JSON。性能因使用的数据而异；尝试<code class="fe nq nr ns ng b">bin/bench.js &lt;your file&gt;</code>对您的数据进行基准测试。</p><pre class="kp kq kr ks gt nf ng nh ni aw nj bi"><span id="6ff1" class="mt lb it ng b gy nk nl l nm nn">const csv = require('csv-parser')<br/>const fs = require('fs')</span><span id="e316" class="mt lb it ng b gy no nl l nm nn">const readCsvData = async (filename) =&gt; {<br/> return new Promise((resolve, reject) =&gt; {<br/>   const results = [];<br/>   fs.createReadStream(filename)<br/>     .pipe(csv())<br/>     .on('error', (err) =&gt; {<br/>       reject(err);<br/>     })<br/>     .on('data', (data) =&gt; results.push(data))<br/>     .on('end', () =&gt; {<br/>       resolve(results);<br/>     });<br/> })<br/>}</span></pre><h1 id="ba01" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">3.对于JSON提取</h1><p id="483b" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mo kd ke kf mp kh ki kj mq kl km kn im bi translated">要生成用于测试目的的随机json数据，请访问此处的<a class="ae mr" href="https://random-data-api.com/" rel="noopener ugc nofollow" target="_blank">和</a></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi np"><img src="../Images/5063b27098ffbffc19dda5e70c914701.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aJLpzAyAZGWyjYtrv8yjNQ.png"/></div></div></figure><p id="9e11" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">读取JSON文件最简单的方法是请求它。传递带有JSON文件路径的<code class="fe nq nr ns ng b">require()</code>将同步读取数据并解析成JavaScript对象。</p><pre class="kp kq kr ks gt nf ng nh ni aw nj bi"><span id="a506" class="mt lb it ng b gy nk nl l nm nn">const data = require(filename)<br/>// for example, <!-- -->const data = require("./data.json");</span></pre><p id="7fb6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是用require读取JSON文件有它的缺点。该文件将只被读取一次；再次请求它将返回第一次运行require时的缓存数据。这对于在启动时加载静态数据(比如配置数据)来说很好。但是对于读取磁盘上发生变化的文件，就像我们的<em class="nt"> customer.json </em>可能做的那样，我们需要使用异步<code class="fe nq nr ns ng b">fs.readFile</code>手动读取文件。</p><pre class="kp kq kr ks gt nf ng nh ni aw nj bi"><span id="1c83" class="mt lb it ng b gy nk nl l nm nn">const fs = require("fs").promises;</span><span id="cb9f" class="mt lb it ng b gy no nl l nm nn">const readJsonData = async (filename) =&gt; {<br/>  const readFile = await fs.readFile(filename, "utf-8");<br/>  return JSON.parse(readFile);<br/>};</span></pre><h1 id="97b1" class="la lb it bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">JavaScript &amp; Node.js开源ETL工具的局限性</h1><p id="fbfc" class="pw-post-body-paragraph jq jr it js b jt ma jv jw jx mb jz ka kb mo kd ke kf mp kh ki kj mq kl km kn im bi translated">尽管JavaScript和Node.js开源ETL工具可以为您的数据管道提供坚实的基础，但是它们有一些限制，尤其是在提供支持方面。</p><p id="01cb" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">由于这些工具是正在开发的工具，它们中的许多还没有完全开发出来，并且与多种数据源不兼容。这些工具的一些局限性包括:</p><ul class=""><li id="6717" class="ly lz it js b jt ju jx jy kb nu kf nv kj nw kn mf mg mh mi bi translated"><strong class="js iu">企业应用程序连接</strong>:由于兼容性的原因，公司不能用Node.js开源ETL工具连接他们的一些应用程序。</li><li id="328f" class="ly lz it js b jt mj jx mk kb ml kf mm kj mn kn mf mg mh mi bi translated"><strong class="js iu">管理&amp;错误处理能力</strong>:许多开源的ETL工具由于缺乏错误处理能力而不容易处理错误。</li><li id="705f" class="ly lz it js b jt mj jx mk kb ml kf mm kj mn kn mf mg mh mi bi translated"><strong class="js iu">大数据量&amp;小批量窗口</strong>:很多Node.js开源ETL工具需要分析大数据量，但是只能处理小批量的数据。这是因为许多工具都是命令行界面，需要Node.js和ETL工具的强大功能才能有效运行。</li><li id="fc2e" class="ly lz it js b jt mj jx mk kb ml kf mm kj mn kn mf mg mh mi bi translated"><strong class="js iu">复杂转型需求</strong>:有复杂转型需求的公司不能使用Node.js开源ETL工具。这是因为它们通常缺乏对执行复杂转换的支持。</li><li id="92cf" class="ly lz it js b jt mj jx mk kb ml kf mm kj mn kn mf mg mh mi bi translated"><strong class="js iu">缺乏客户支持团队</strong>:由于开源ETL工具由世界各地的社区和开发者管理，他们没有专门的客户支持团队来处理问题。</li><li id="9f9c" class="ly lz it js b jt mj jx mk kb ml kf mm kj mn kn mf mg mh mi bi translated"><strong class="js iu">安全性差</strong>:开源导致这些工具安全性差，容易受到网络攻击。</li></ul><p id="74ad" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一旦数据被提取出来，ETL管道的下一步就是转换它<a class="ae mr" href="https://medium.com/@caopengau/javascript-nodejs-open-source-etl-tools-and-scripts-for-data-engineering-part-2-on-transform-afabd0026c98" rel="noopener">这里是</a>。</p><p id="20a9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><strong class="js iu">行动呼吁</strong></p><p id="651e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你觉得这个指南有帮助，请鼓掌并跟我来。通过<a class="ae mr" href="https://medium.com/@caopengau/membership" rel="noopener">链接</a>加入medium，获取我和所有其他优秀作家在medium上发表的所有优质文章。</p></div></div>    
</body>
</html>