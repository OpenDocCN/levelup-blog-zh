<html>
<head>
<title>Securing a RESTful API Built with Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">保护用Node.js构建的RESTful API</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/securing-a-restful-api-built-with-node-js-f7feefc1efe1?source=collection_archive---------7-----------------------#2020-04-11">https://levelup.gitconnected.com/securing-a-restful-api-built-with-node-js-f7feefc1efe1?source=collection_archive---------7-----------------------#2020-04-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="90e2" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用JSON Web令牌和bcrypt密码散列添加身份验证和访问管理</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8e4fd43e7e8dda74887719fc1281d1bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*a2F0uwZNBh4LEgEM"/></div></div></figure><p id="f39a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在这篇博客中，我将详细介绍如何为Node.js应用程序添加安全性，更具体地说，如何为使用Node.js构建的RESTful API构建身份验证和访问管理端点。这些端点将允许最终用户为我们的应用程序创建一个新的用户帐户，使用该帐户的凭据登录，并获得对应用程序中其他路由的访问权限。这篇博客对我在之前的博客中所做的开发进行了扩展，在之前的博客中，我详细介绍了如何使用Node.js、Express.js和MongoDB 构建RESTful API。要跟进，您可以在我的GitHub上找到<a class="ae lq" href="https://github.com/ckraczkowsky91/rest-api-node-secure" rel="noopener ugc nofollow" target="_blank">源代码</a>。</p><blockquote class="lr ls lt"><p id="6792" class="ku kv lu kw b kx ky ju kz la lb jx lc lv le lf lg lw li lj lk lx lm ln lo lp im bi translated"><strong class="kw iu">注意:</strong>当我们在这篇博客中使用Node.js和Express web framework时，我有另一篇博客关注Python中Flask web framework的安全性，并解释了<a class="ae lq" href="https://medium.com/@ckraczkowsky/building-a-secure-admin-interface-with-flask-admin-and-flask-security-13ae81faa05" rel="noopener">如何使用Flask-Admin构建一个管理界面，该界面使用Flask-Security进行保护</a>。</p></blockquote><h2 id="dfa4" class="ly lz it bd ma mb mc dn md me mf dp mg ld mh mi mj lh mk ml mm ll mn mo mp mq bi translated"><strong class="ak">定义用户的特征</strong></h2><p id="0aec" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">我们要做的第一件事是创建一个新文件，在这个文件中，我们将把用户的特征定义为一个新的模式。</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="521f" class="ly lz it mx b gy nb nc l nd ne">$ touch userModel.js</span></pre><p id="293d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在<code class="fe nf ng nh mx b">userModel.js</code>文件中，我们定义一个用户有三个属性:<code class="fe nf ng nh mx b">name</code>、<code class="fe nf ng nh mx b">email</code>和<code class="fe nf ng nh mx b">password</code>。</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="ef38" class="ly lz it mx b gy nb nc l nd ne">const mongoose = require(‘mongoose’);<br/>const userSchema = new mongoose.Schema({<br/>  name: {<br/>    type: String,<br/>    required: true<br/>  },<br/>  email: {<br/>    type: String,<br/>    required: true<br/>  },<br/>password: {<br/>  type: String,<br/>  required: true<br/>  }<br/>});</span><span id="ccad" class="ly lz it mx b gy ni nc l nd ne">module.exports = userSchema;</span></pre><p id="41a7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">然后，我们导出新的<code class="fe nf ng nh mx b">userSchema</code>,在一个新文件中使用，我们称之为<code class="fe nf ng nh mx b">authController.js</code>,我们将把应用程序的所有授权和访问管理逻辑放在这个文件中。在接下来的几节中，我们将构建包含该逻辑的控制器函数，并深入研究每个函数的功能。让我们首先构建一个函数来处理大多数授权过程中的第一个任务，即注册新用户。</p><h2 id="bcf4" class="ly lz it bd ma mb mc dn md me mf dp mg ld mh mi mj lh mk ml mm ll mn mo mp mq bi translated"><strong class="ak">注册新用户</strong></h2><p id="2ff6" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">打开一个私人浏览器窗口，进入你最喜欢的网站。你会注意到，这个网站可能会向你提供一部分内容，但你不可避免地会在你的经历中需要一个该网站的帐户，以便进一步发展。这就是注册新用户的常见授权机制，所以我们添加到<code class="fe nf ng nh mx b">authController.js</code>文件的第一个控制器函数是<code class="fe nf ng nh mx b">registerUser</code>函数。</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="9bba" class="ly lz it mx b gy nb nc l nd ne">$ touch authController.js</span></pre><p id="d1d0" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nf ng nh mx b">registerUser</code>控制器函数将使我们能够向API添加一个端点，用于创建新用户并将他们保存到我们的MongoDB数据库中。</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="1053" class="ly lz it mx b gy nb nc l nd ne">const userSchema = require(‘./userModel’);<br/>const bcrypt = require(‘bcryptjs’);<br/>const jwt = require(‘jsonwebtoken’);<br/>const config = require(‘./config’);<br/>...<br/>const User = mongoose.model(‘User’, userSchema);<br/>...<br/>const registerUser = (req, res) =&gt; {<br/>  let hashedPassword = bcrypt.hashSync(req.body.password, 8);<br/>  let newUser = new User({<br/>    name: req.body.name,<br/>    email: req.body.email,<br/>    password: hashedPassword<br/>  });<br/>  newUser.save((error, User) =&gt; {<br/>    var token = jwt.sign({ id: User._id }, config.secretKey, <br/>      {expiresIn: 86400});<br/>    if (error) {<br/>      res.status(500).send(error);<br/>    } else {<br/>      res.status(200).send({auth: true, token: token});<br/>    };<br/>  });<br/>};<br/>...</span></pre><p id="64af" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">由于我们的<code class="fe nf ng nh mx b">registerUser</code>控制器函数将创建用户，我们需要给它访问我们在上面的<strong class="kw iu">定义用户特征</strong>部分中定义的<code class="fe nf ng nh mx b">userSchema</code>的权限。我们使用我们的<code class="fe nf ng nh mx b">userSchema</code>来创建用户模型，它提供对Mongoose的内置方法的访问，以查询MongoDB。</p><p id="64ac" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">深入到<code class="fe nf ng nh mx b">registerUser</code>函数，我们的第一行代码将<code class="fe nf ng nh mx b">req</code>和<code class="fe nf ng nh mx b">res</code>对象传递给该函数。您会记得我以前的博客<a class="ae lq" rel="noopener ugc nofollow" target="_blank" href="/building-a-restful-api-with-node-js-831bff629e3b">中的这些对象，用Node.js </a>构建一个RESTful API。我们在<code class="fe nf ng nh mx b">req</code>对象中期望的是一个名为<code class="fe nf ng nh mx b">body</code>的属性，它包含JSON格式的数据，表示在<code class="fe nf ng nh mx b">userSchema</code>中定义的用户特征。</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="4fb1" class="ly lz it mx b gy nb nc l nd ne">body: {<br/>  name: ‘Colin’,<br/>  email: ‘colin_codes@gmail.com’,<br/>  password: ‘password’<br/>}</span></pre><p id="8b46" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们将收到如上所示的请求，但是您可以看到我们有一个问题:密码是明文！这不是我们想要的存储用户个人信息的方式，所以第二行代码创建了一个新变量，我们将纯文本密码存储为散列密码。我们使用<code class="fe nf ng nh mx b">bcryptjs</code>库进行哈希运算，我们需要使用节点包管理器来安装这个库，也就是Node.js运行时环境的默认包管理器。</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="d4bb" class="ly lz it mx b gy nb nc l nd ne">$ npm install bcryptjs</span></pre><p id="e3fd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nf ng nh mx b">hashSync</code>函数有两个参数:<code class="fe nf ng nh mx b">data</code>和<code class="fe nf ng nh mx b">salt</code>。<code class="fe nf ng nh mx b">data</code>参数代表要加密的数据，即密码。为了理解<code class="fe nf ng nh mx b">salt</code>参数，我们需要了解一些关于密码学的基础知识。在密码学中，加盐散列指的是将随机数据添加到散列函数的输入中，以保证唯一的输出，即散列。这确保了即使输入相同，输出的散列也会不同。在我们的例子中，即使两个用户输入相同的纯文本密码，我们存储在数据库中的散列密码也是唯一的。通过为<code class="fe nf ng nh mx b">salt</code>参数指定一个数字，我们告诉<code class="fe nf ng nh mx b">bcryptjs</code>通过该轮数来生成一个salt。在确定这个数字时，我们必须考虑选择一个高或低的数字的成本。较高的数字意味着要进行更多的哈希循环，因此需要更长的时间，而较低的数字会更快，但会产生更容易被破解的哈希密码。默认情况下，<code class="fe nf ng nh mx b">bcryptjs</code>将这个参数设置为10，但是为了这个练习的目的，我将它降低到了8。</p><p id="2b21" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我们散列密码之后，我们使用从请求中获得的名称和电子邮件创建一个新的<code class="fe nf ng nh mx b">User</code>模型实例，并将它们与我们刚刚创建的散列密码相结合。然后，我们将该实例作为新文档保存到MongoDB。在保存实例的过程中，我们使用需要安装的<code class="fe nf ng nh mx b">jsonwebtoken</code>库为新用户生成一个JSON Web令牌。</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="0a61" class="ly lz it mx b gy nb nc l nd ne">$ npm install jsonwebtoken</span></pre><p id="c875" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nf ng nh mx b">jsonwebtoken</code>库是JSON Web Tokens (JWT)的一个实现，它是一个开放标准，定义了一种紧凑的方式，以JSON对象的形式在各方之间安全地传输数据。我们在应用程序中使用jwt，以便在用户登录后，每个后续请求都将包含令牌，允许他们访问我们用该令牌允许的路由、服务和资源。</p><p id="1e94" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">JSON Web令牌由三部分组成:头部、有效负载和签名:</p><ul class=""><li id="ec6f" class="nj nk it kw b kx ky la lb ld nl lh nm ll nn lp no np nq nr bi translated">报头通常由两部分组成:令牌的类型，即JWT，以及所使用的签名算法。默认情况下，<code class="fe nf ng nh mx b">jsonwebtoken</code>库支持使用代码中表示为<code class="fe nf ng nh mx b">HS256</code>的SHA-256哈希算法的HMAC，但它也支持其他算法，如使用SHA-256哈希算法的RS assa-PKCS1-v1 _ 5(<code class="fe nf ng nh mx b">RS256</code>)和使用P-256曲线和SHA-256哈希算法的ECDSA】)。报头是Base64Url编码的，构成了令牌的第一部分。</li><li id="bdc5" class="nj nk it kw b kx ns la nt ld nu lh nv ll nw lp no np nq nr bi translated">有效载荷包含所谓的“声明”。术语“声明”指的是主体对自身的陈述，它定义了主体是什么或不是什么。然后，这些声明被打包在令牌中，并由令牌服务发布，以便接收方(即我们的Node.js应用程序)知道这些声明来自可信来源，就像我们的年龄和驾驶机动车辆的许可被打包在由可信政府机构发布的驾照中一样。在我们的例子中，声明是登录用户的唯一ID、令牌发布的时间以及令牌到期的时间。然后对有效负载进行Base64Url编码，形成令牌的第二部分。</li><li id="36b6" class="nj nk it kw b kx ns la nt ld nu lh nv ll nw lp no np nq nr bi translated">签名是Base64Url编码的标头、Base64Url编码的有效负载和一个秘密的组合，该秘密通过标头中指定的算法传递，然后进行签名。</li></ul><p id="08e1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nf ng nh mx b">jsonwebtoken</code>库通过提供<code class="fe nf ng nh mx b">sign</code>函数简化了签名过程。该函数接受几个参数，包括<code class="fe nf ng nh mx b">payload</code>、<code class="fe nf ng nh mx b">secretOrPrivateKey</code>，以及一个包含任何附加选项的对象。我们将<code class="fe nf ng nh mx b">User._id</code>作为<code class="fe nf ng nh mx b">payload</code>传递，因为它提供了用户的唯一表示。<code class="fe nf ng nh mx b">secretOrPrivateKey</code>可以是一个字符串、缓冲区或对象，包含HMAC算法的秘密或RSA和ECDSA的PEM编码私钥，因此得名。由于我们使用默认的散列算法HMAC，我们将提供一个秘密。我决定把这个秘密放在一个单独的文件中，因为我们会经常用到它，所以最好把它放在一个地方，以便于维护。让我们现在创建该文件。</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="52d9" class="ly lz it mx b gy nb nc l nd ne">$ touch config.js</span></pre><p id="1cc1" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在<code class="fe nf ng nh mx b">config.js</code>文件中，我们定义了秘密的密钥和秘密的值。</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="b140" class="ly lz it mx b gy nb nc l nd ne">module.exports = {<br/>  ‘secretKey’: ‘secretKeyValue’<br/>}</span></pre><blockquote class="lr ls lt"><p id="7902" class="ku kv lu kw b kx ky ju kz la lb jx lc lv le lf lg lw li lj lk lx lm ln lo lp im bi translated"><strong class="kw iu">注意:</strong>这是不言而喻的，但是我选择的秘密只是为了这个练习的目的，并不是生产环境中应用程序的秘密的准确表示。</p></blockquote><p id="584d" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">至于其他选项，<code class="fe nf ng nh mx b">sign</code>函数接受一个对象，该对象的属性包括我们首选的散列算法、生存时间以及声明的任何配置。我们使用<code class="fe nf ng nh mx b">expiresIn</code>属性将令牌的生存时间指定为86，400秒或24小时。该属性展示了JSON Web令牌提供的访问控制粒度。我们可以撤销jwt，并在jwt上设置过期时间，以限制特定用户访问特定的路由。</p><p id="16a3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated"><code class="fe nf ng nh mx b">registerUser</code>函数的最后一部分指示Node.js应用程序将新用户的数据作为新文档保存到MongoDB集合中。如果操作失败，res对象应该包含一个符合RFC规范的状态代码<code class="fe nf ng nh mx b">500 Internal Server Error</code>，以及一个错误描述。如果操作成功，res对象应该包含一个状态代码<code class="fe nf ng nh mx b">200 OK</code>和一个包含新注册用户的JSON Web令牌的对象。</p><h2 id="2bae" class="ly lz it bd ma mb mc dn md me mf dp mg ld mh mi mj lh mk ml mm ll mn mo mp mq bi translated"><strong class="ak">创建并测试我们的API的注册端点</strong></h2><p id="9c8e" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">既然我们已经有了<code class="fe nf ng nh mx b">registerUser</code>控制器函数，我们需要通过一个路由将它作为API提供。我们将函数加载到<code class="fe nf ng nh mx b">routes.js</code>文件中。</p><blockquote class="lr ls lt"><p id="452f" class="ku kv lu kw b kx ky ju kz la lb jx lc lv le lf lg lw li lj lk lx lm ln lo lp im bi translated"><strong class="kw iu">注意:</strong>在其他博客中，我将文件<code class="fe nf ng nh mx b">routes.js</code>称为<code class="fe nf ng nh mx b">itemRoutes.js</code>文件。</p></blockquote><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="e003" class="ly lz it mx b gy nb nc l nd ne">const itemControllers = require(‘./itemControllers’);<br/>const authController = require(‘./authController’);<br/>const addItem = itemControllers.addItem;<br/>const getItems = itemControllers.getItems;<br/>const registerUser = authController.registerUser;<br/>const path = require(‘path’);<br/>const routes = (app) =&gt; {<br/>  app.route(‘/’)<br/>  .get((req, res) =&gt; {<br/>    res.sendFile(path.join(__dirname + ‘/index.html’));<br/>});<br/><strong class="mx iu">app.route(‘/auth/register’)<br/>  .post(registerUser);<br/></strong>app.route(‘/auth/login’)<br/>  .post(loginUser);<br/>app.route(‘/items’)<br/>  .post(addItem)<br/>  .get(getItems);<br/>};</span><span id="76c8" class="ly lz it mx b gy ni nc l nd ne">module.exports = routes;</span></pre><p id="0366" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如您所见，我们已经在“/auth/register”端点提供了注册新用户的功能。我们现在可以测试这个功能了！我们首先启动Node.js应用程序。</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="4c3b" class="ly lz it mx b gy nb nc l nd ne">$ node ./index.js</span></pre><p id="aec2" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">此外，我们需要通过在新的命令行窗口中输入<code class="fe nf ng nh mx b">mongod</code>命令来启动MongoDB的本地实例。</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="dd30" class="ly lz it mx b gy nb nc l nd ne">$ mongod</span></pre><p id="3a95" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在让我们向位于<a class="ae lq" href="http://localhost:4000/auth/register" rel="noopener ugc nofollow" target="_blank">http://localhost:4000/auth/register</a>的端点发出请求。我们可以用Postman工具模拟这种情况，它提供了一个HTTP客户端来发出HTTP请求。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/2d977dce84b7a57d4485833f34aab101.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BrMsXctYaXB0wRKO"/></div></div></figure><p id="b081" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">太好了，这是工作！当我们在<code class="fe nf ng nh mx b">itemSchema</code>中提供我们需要的数据时，我们看到一个包含JSON Web令牌的响应。</p><p id="7cfb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们还应该测试数据是否成功地添加到了我们的MongoDB数据库中，所以让我们启动MongoDB的内置接口mongo shell。</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="e586" class="ly lz it mx b gy nb nc l nd ne">$ mongo</span></pre><p id="fe9c" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在mongo shell中，我们可以查看我们的数据库。</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="802e" class="ly lz it mx b gy nb nc l nd ne">&gt; use itemDB<br/>switched to db itemDB<br/>&gt; show collections<br/>items<br/>users<br/>&gt; db.users.find()<br/>{ “_id” : ObjectId(“5e8bad41c85d7e0fed4f939e”), “name” : “Colin Kraczkowsky”, “email” : “colin_codes@gmail.com”, “password” : “$2a$08$iIR7HAGtdeN9V4/AwPg1veSnQJxK8IRRewTkqfsP43hZ3hPpmXnm2”, “__v” : 0 }</span></pre><p id="fe2f" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">看起来这也很有效！一个名为Mongoose的新集合被自动命名为<code class="fe nf ng nh mx b">users</code>，一个包含新用户数据的新文档被成功添加。</p><h2 id="7491" class="ly lz it bd ma mb mc dn md me mf dp mg ld mh mi mj lh mk ml mm ll mn mo mp mq bi translated"><strong class="ak">更好地理解JSON Web令牌</strong></h2><p id="6c33" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">测试我们的API的注册端点产生了一个JSON Web令牌，我们可以对其进行研究，以更好地理解幕后发生的事情。下面是被归还的JWT。</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="8edc" class="ly lz it mx b gy nb nc l nd ne">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.<br/>eyJpZCI6IjVlOGJhZDQxYzg1ZDdlMGZlZDRmOTM5ZSIsImlhdCI6MTU4NjIxMjE2MSwiZXhwIjoxNTg2Mjk4NTYxfQ.<br/>Zg7HsBj7PdgicKCJOQPPE9V4RLR374WfNgN35v5ss2o</span></pre><p id="09b7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">回想一下上面的<strong class="kw iu">注册新用户</strong>部分，JSON Web令牌有三个部分:头部、有效载荷和签名。我们可以在上面的示例令牌中看到由“.”分隔的各个部分点符号。让我们在我们的<code class="fe nf ng nh mx b">registerUser</code>函数中再添加一行代码，这使我们能够看到令牌所代表的JSON对象被分解成三个部分。</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="e19f" class="ly lz it mx b gy nb nc l nd ne">...<br/>const registerUser = (req, res) =&gt; {<br/>  let hashedPassword = bcrypt.hashSync(req.body.password, 8);<br/>  let newUser = new User({<br/>    name: req.body.name,<br/>    email: req.body.email,<br/>    password: hashedPassword<br/>  });<br/>  newUser.save((error, User) =&gt; {<br/>    var token = jwt.sign({ id: User._id }, config.secretKey, <br/>      {expiresIn: 86400});<br/>    if (error) {<br/>      res.status(500).send(error);<br/>    } else {<br/>      <strong class="mx iu">console.log(jwt.decode(token, {complete: true}));<br/>      </strong>res.status(200).send({auth: true, token: token});<br/>    };<br/>  });<br/>};<br/>...</span></pre><p id="b4f5" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这将把以下信息记录到控制台。</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="19f5" class="ly lz it mx b gy nb nc l nd ne">{<br/>  header: { alg: ‘HS256’, typ: ‘JWT’ },<br/>  payload: { id: ‘5e8bad41c85d7e0fed4f939e’, iat: 1586212161, exp: 1586298561 },<br/>  signature: ‘Zg7HsBj7PdgicKCJOQPPE9V4RLR374WfNgN35v5ss2o’<br/>}</span></pre><p id="c355" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">您会将<code class="fe nf ng nh mx b">payload</code>中的<code class="fe nf ng nh mx b">id</code>识别为新创建用户的ID。此外，<code class="fe nf ng nh mx b">iat</code>的值，即创建时间和<code class="fe nf ng nh mx b">exp</code>，即到期时间，与我们配置的相差86，400个单位。最后，<code class="fe nf ng nh mx b">signature</code>的值与上面示例令牌的第三部分的值相同。我们应该预料到<code class="fe nf ng nh mx b">payload</code>和<code class="fe nf ng nh mx b">signature</code>会随着新用户的增加而改变，而<code class="fe nf ng nh mx b">header</code>应该保持不变，如果我们不改变我们的散列算法或令牌类型的话。</p><p id="25ed" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们的测试即将完成！目前，我们的注册函数获取用户数据，生成一个JSON Web令牌，并将令牌返回给我们。为了结束这个循环，我们应该能够使用一个函数对这个流进行逆向工程，这个函数接受一个JWT，并把它发给用户。我们必须快速构建这个新函数，因为我们在本节中创建的令牌只能存在24小时！</p><h2 id="ead4" class="ly lz it bd ma mb mc dn md me mf dp mg ld mh mi mj lh mk ml mm ll mn mo mp mq bi translated"><strong class="ak">从JSON Web令牌获取注册用户</strong></h2><p id="4c49" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">回到<code class="fe nf ng nh mx b">authController.js</code>文件，我们添加了一个新的控制器函数<code class="fe nf ng nh mx b">getRegisteredUser</code>，它接受一个JSON Web令牌并返回相关的用户。</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="dcf3" class="ly lz it mx b gy nb nc l nd ne">...<br/>const getRegisteredUser = (req, res) =&gt; {<br/>  var token = req.headers[‘x-json-web-token’];<br/>  if (!token) {<br/>    res.status(401).send({auth: false, message: ‘Token not provided.’});<br/>  } else {<br/>    jwt.verify(token, config.secretKey, (error, decoded) =&gt; {<br/>      if (error) {<br/>        res.status(500).send({auth: false, message: ‘Token can not be verified.’});<br/>      } else {<br/>        User.findById(decoded.id, {password: 0}, (error, User) =&gt; {<br/>          if (error) {<br/>            res.status(500).send(‘There was an error finding that user.’);<br/>          } else if (!User) {<br/>            res.status(404).send(‘Could not locate that user.’);<br/>          } else {<br/>            res.status(200).send(User);<br/>          };<br/>        });<br/>      };<br/>    });<br/>  };<br/>};<br/>...</span></pre><p id="f4d3" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在我们的<code class="fe nf ng nh mx b">getRegisteredUser</code>函数中执行的第一个任务是检索和存储JSON Web令牌。我们创建一个新的变量<code class="fe nf ng nh mx b">token</code>，并使用它来引用我们期望在请求的HTTP头的<code class="fe nf ng nh mx b">x-json-web-token</code>头中找到的JWT。出于本练习的目的，我发明了<code class="fe nf ng nh mx b">x-json-web-token</code>作为自定义头，但是我们可以随意命名它，只要函数中使用的头的名称与请求中的头的名称一致。实际上，客户端发送JWT的方式是使用带有<code class="fe nf ng nh mx b">Bearer</code>认证方案的<code class="fe nf ng nh mx b">Authorization</code>报头，如<a class="ae lq" href="https://tools.ietf.org/html/rfc6750" rel="noopener ugc nofollow" target="_blank"> RFC 6750 </a>中所述。然而，这超出了本博客的范围。此外，我们使用括号符号而不是点符号来访问<code class="fe nf ng nh mx b">x-json-web-token</code>头，因为如果您还记得早期的JavaScript，点符号只能访问字母数字属性，除了下划线和美元符号。</p><p id="3257" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们有了对令牌的引用，我们可以定义适当的响应了。马上，如果<code class="fe nf ng nh mx b">x-json-web-token</code>自定义HTTP头丢失，因此没有提供令牌，响应的<code class="fe nf ng nh mx b">res</code>对象应该包含一个<code class="fe nf ng nh mx b">401 Unauthorized</code>状态代码。现在我们需要处理提供令牌时的情况。仅仅因为提供了令牌，并不意味着应该立即授予访问权限。我们应该首先验证所提供的令牌是否有效。<code class="fe nf ng nh mx b">jsonwebtoken</code>库通过提供<code class="fe nf ng nh mx b">verify</code>函数简化了验证过程。这个函数有几个参数，包括<code class="fe nf ng nh mx b">token</code>、<code class="fe nf ng nh mx b">secretOrPrivateKey</code>和一个回调函数。因此，我们将我们对令牌的引用作为第一个参数，将我们在上面的<strong class="kw iu">注册新用户</strong>部分创建的<code class="fe nf ng nh mx b">config.js</code>文件中的秘密作为第二个参数。然后，我们使用回调函数作为第三个参数来处理响应。如果<code class="fe nf ng nh mx b">verify</code>函数失败，令牌无效，并且<code class="fe nf ng nh mx b">res</code>对象应该包含一个<code class="fe nf ng nh mx b">500 Internal Server Error</code>状态代码。如果令牌有效，那么我们尝试定位与令牌相关联的用户。我们用在上面的<strong class="kw iu">注册新用户</strong>小节中用Mongoose实例化的<code class="fe nf ng nh mx b">User</code>模型来做这件事。Mongoose中的所有模型对象都有一套查询方法，包括<code class="fe nf ng nh mx b">findById</code>方法。顾名思义，我们需要与令牌相关联的用户的id。我们可以从回调函数中得到这个。在幕后，给<code class="fe nf ng nh mx b">verify</code>函数提供一个回调会触发它异步操作，这意味着在调用回调之前将首先验证令牌。根据令牌是否有效，回调要么用<code class="fe nf ng nh mx b">error</code>调用，要么用<code class="fe nf ng nh mx b">decoded</code>调用，后者是从Base64Url形式解码的JSON Web令牌的有效负载。然后，我们通过适当地响应令牌是否无效来处理这个问题，或者通过用包含<code class="fe nf ng nh mx b">200 OK</code>状态代码的<code class="fe nf ng nh mx b">res</code>对象和包含相关用户数据的对象来响应。</p><blockquote class="lr ls lt"><p id="17cf" class="ku kv lu kw b kx ky ju kz la lb jx lc lv le lf lg lw li lj lk lx lm ln lo lp im bi translated"><strong class="kw iu">注意:</strong>在许多情况下，在响应中包含用户的密码是不合适的，即使是散列版本。我们可以通过向包含投影的<code class="fe nf ng nh mx b">findById</code>方法传递一个可选对象来从响应中删除密码。在MongoDB中，一个投影，也称为“查询投影”，指定在返回的文档中包含或排除哪些字段。在我们的例子中，投影<code class="fe nf ng nh mx b">{password: 0}</code>告诉MongoDB通过在投影中将<code class="fe nf ng nh mx b">password</code>字段设置为0来将其从结果中移除，并且当与传递给<code class="fe nf ng nh mx b">findById</code>方法的所有参数结合时，在语法上与下面的查询相同。</p></blockquote><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="be2c" class="ly lz it mx b gy nb nc l nd ne">SELECT _id, name, email, __v<br/>FROM users<br/>WHERE _id = “[decoded.id]”;</span></pre><p id="26d6" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">接下来，我们像处理<code class="fe nf ng nh mx b">registerUser</code>控制器函数一样，将<code class="fe nf ng nh mx b">getRegisteredUser</code>控制器函数加载到<code class="fe nf ng nh mx b">routes.js</code>文件中。</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="f331" class="ly lz it mx b gy nb nc l nd ne">const authController = require(‘./authController’);<br/>...<br/>const getRegisteredUser = authController.getRegisteredUser;<br/>...<br/>const routes = (app) =&gt; {<br/>  app.route(‘/auth/register’)<br/>  .post(registerUser)<br/>  .get(getRegisteredUser);<br/>...</span></pre><p id="cc35" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，当客户机使用有效的JSON Web令牌向我们的注册端点提交GET请求时，我们的Node.js应用程序将返回关联的用户。让我们用Postman工具来模拟这一点，方法是将上面的API 部分的<strong class="kw iu">创建和测试注册端点中的令牌插入到对我们的<a class="ae lq" href="http://localhost:4000/auth/register" rel="noopener ugc nofollow" target="_blank">http://localhost:4000/auth/register</a>端点的GET请求的<code class="fe nf ng nh mx b">x-json-web-token</code>头中。</strong></p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/fd821021c830efc2a232969c621ae43c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wI713CpneiY8DJ6z"/></div></div></figure><p id="06fb" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">太棒了，我们已经完成了注册端点的测试！我们的端点通过创建一个新用户并在提供用户数据时向该用户发出一个JSON Web令牌来响应POST请求，当提供JSON Web令牌时，它用用户数据来响应GET请求。</p><h2 id="a80f" class="ly lz it bd ma mb mc dn md me mf dp mg ld mh mi mj lh mk ml mm ll mn mo mp mq bi translated"><strong class="ak">登录用户账户</strong></h2><p id="c136" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">在上面的小节中，我们构建并测试了一个用新用户帐户注册用户的函数。接下来，让我们处理大多数授权过程中的第二个任务，即允许用户登录到他们的用户帐户。为此，我们添加到<code class="fe nf ng nh mx b">authController.js</code>文件的下一个控制器函数是<code class="fe nf ng nh mx b">loginUser</code>函数。</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="ffc1" class="ly lz it mx b gy nb nc l nd ne">...<br/>const loginUser = (req, res) =&gt; {<br/>  User.findOne({email: req.body.email}, (error, User) =&gt; {<br/>    if (error) {<br/>      res.status(500).send(‘There was an error with login.’);<br/>    } else if (!User) {<br/>      res.status(404).send(‘Sorry, that user does not appear to exist.’);<br/>    } else {<br/>      var passwordIsValid = bcrypt.compareSync(req.body.password, User.password);<br/>      if (!passwordIsValid) {<br/>        res.status(401).send({auth: false, token: null});<br/>      } else {<br/>        var token = jwt.sign({id: User._id}, config.secretKey, <br/>        {expiresIn: 86400});<br/>        res.status(200).send({auth: true, token: token});<br/>      };<br/>    };<br/>  });<br/>};<br/>...</span></pre><p id="e220" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们使用Mongoose的<code class="fe nf ng nh mx b">findOne</code>查询方法，该方法将一个对象作为第一个参数，将一个回调函数作为可选的附加参数。一般来说，这个方法从我们的MongoDB数据库的集合中返回一个文档，该文档与第一个参数中的对象相匹配。这个方法的应用程序获取在<code class="fe nf ng nh mx b">req</code>对象中传递的电子邮件，并在用户集合中找到一个在<code class="fe nf ng nh mx b">email</code>键中有匹配值的文档。我们使用回调函数来处理响应。如果我们在数据库中找不到匹配的电子邮件，我们会用一个<code class="fe nf ng nh mx b">404 Not Found</code>状态代码进行响应。如果我们找到了匹配的用户，我们将验证所提供的密码是否与匹配用户的密码相匹配。因为我们已经散列了密码，所以我们不能简单地比较在<code class="fe nf ng nh mx b">req</code>对象中提供的密码和保存在我们数据库中的密码。幸运的是，<code class="fe nf ng nh mx b">bcryptjs</code>提供了<code class="fe nf ng nh mx b">compareSync</code>函数，该函数根据散列测试一个字符串，并返回一个布尔值来判断它们是否匹配。如果<code class="fe nf ng nh mx b">compareSync</code>返回false，那么提供的密码与保存的密码不匹配，我们的Node.js应用程序用一个<code class="fe nf ng nh mx b">401 Unauthorized</code>状态代码进行响应。如果<code class="fe nf ng nh mx b">compareSync</code>返回true，则密码匹配，我们认为该用户“已登录”,并为其帐户签发令牌。</p><p id="2c26" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在下一节中，我们通过将对特定路由的访问限制为只有具有有效令牌的用户，为我们的应用程序添加了一个新的安全层。</p><h2 id="a830" class="ly lz it bd ma mb mc dn md me mf dp mg ld mh mi mj lh mk ml mm ll mn mo mp mq bi translated"><strong class="ak">保护我们的路线</strong></h2><p id="5275" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">在上面的小节中，我们构建了一些机制，允许用户注册一个用户帐户并登录到他们的帐户。这两种机制都会为特定用户生成一个JSON Web令牌。现在，让我们构建一个机制，通过使用令牌授权用户访问某些路由，使用JWT来保护我们的应用程序。让我们创建一个名为<code class="fe nf ng nh mx b">verifyToken.js</code>的新文件来保存这个机制。</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="79a9" class="ly lz it mx b gy nb nc l nd ne">$ touch verifyToken.js</span></pre><p id="c4d7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在<code class="fe nf ng nh mx b">verifyToken.js</code>文件中，我们构建了一个“中间件函数”。中间件功能是在应用程序的请求-响应周期中可以访问<code class="fe nf ng nh mx b">req</code>对象、<code class="fe nf ng nh mx b">res</code>对象和下一个中间件功能的功能。从技术上讲，我们构建的所有控制器功能都可以被视为中间件功能。</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="767c" class="ly lz it mx b gy nb nc l nd ne">...<br/>const verifyToken = (req, res, next) =&gt; {<br/>  var token = req.headers[‘x-access-token’];<br/>  if (!token) {<br/>    res.status(403).sendFile(path.join(__dirname + ‘/unverified.html’));<br/>    console.log(‘No token was provided.’);<br/>  } else {<br/>    jwt.verify(token, config.secretKey, (error, decoded) =&gt; {<br/>      if (error) {<br/>        res.status(500).sendFile(path.join(__dirname + ‘/unverified.html’));<br/>        console.log(‘Failure to verify the token.’);<br/>      } else {<br/>        next();<br/>      };<br/>    });<br/>  };<br/>};<br/>...</span></pre><p id="16bc" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们创建了一个名为<code class="fe nf ng nh mx b">verifyToken</code>的函数，并向它传递了我们从其他控制器函数中熟悉的<code class="fe nf ng nh mx b">res</code>和<code class="fe nf ng nh mx b">req</code>对象，但是您会注意到我们还传递了第三个参数<code class="fe nf ng nh mx b">next</code>，这个参数我们还没有使用过。回想一下上面的内容，中间件功能可以访问它前面的中间件功能，而这正是下一个变量所指的。</p><blockquote class="lr ls lt"><p id="78db" class="ku kv lu kw b kx ky ju kz la lb jx lc lv le lf lg lw li lj lk lx lm ln lo lp im bi translated"><strong class="kw iu">注意:</strong> <code class="fe nf ng nh mx b">next</code>不是JavaScript中的保留字。事实上，我们可以用我们选择的任何词来指代这个变量。然而，通常的做法是，前面的中间件函数通常由前面的中间件函数中的一个名为<code class="fe nf ng nh mx b">next</code>的变量来表示，这样会使您的代码更容易阅读和理解。</p></blockquote><p id="9bf7" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">我们的<code class="fe nf ng nh mx b">verifyToken</code>中间件函数的第一行从HTTP头中获取JSON Web令牌，就像我们在上面的<strong class="kw iu">从JSON Web令牌</strong>中获取注册用户的<code class="fe nf ng nh mx b">getRegisteredUser</code>函数中所做的那样。然后我们处理返回的内容。如果头没有返回JWT，我们用一个<code class="fe nf ng nh mx b">403 Forbidden</code>状态码响应请求，并将用户重定向到<code class="fe nf ng nh mx b">unverified.html</code>文件，这是一个基本的HTML文档。让我们现在创建该文件。</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="178a" class="ly lz it mx b gy nb nc l nd ne">$ touch unverified.html</span></pre><p id="fafe" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">该文件的目的是为没有足够权限访问所请求路线的用户提供一个简单的登录页面。</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="1002" class="ly lz it mx b gy nb nc l nd ne">&lt;!doctype html&gt;<br/>&lt;html&gt;<br/>  &lt;head&gt;<br/>  &lt;/head&gt;<br/>  &lt;body&gt;<br/>    &lt;h1&gt;You &lt;u&gt;DO NOT&lt;/u&gt; have access to this page!&lt;/h1&gt;<br/>  &lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="7eec" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果提供了一个JSON Web令牌，那么我们使用与上面的<strong class="kw iu">登录现有用户</strong>一节中相同的<code class="fe nf ng nh mx b">verify</code>函数来验证它。我们通过用一个<code class="fe nf ng nh mx b">500 Internal Server Error</code>状态码响应并发送上面定义的<code class="fe nf ng nh mx b">unverified.html</code>文件来处理验证中的任何错误。如果验证成功，我们用一个<code class="fe nf ng nh mx b">200 OK</code>状态代码进行响应，然后调用<code class="fe nf ng nh mx b">next</code>变量，该变量将调用队列中的下一个中间件。</p><p id="7a4a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以你可能想知道为什么这很酷？这很酷，因为作为中间件，我们可以将我们的<code class="fe nf ng nh mx b">verifyToken</code>函数插入到我们的任何路径中来保护它们——非常符合软件开发的DRY原则！</p><p id="1829" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">例如，让我们返回到<code class="fe nf ng nh mx b">routes.js</code>文件。</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="8842" class="ly lz it mx b gy nb nc l nd ne">const verifyToken = require(‘./verifyToken’);<br/>...<br/>const routes = (app) =&gt; {<br/>  app.route(‘/’)<br/>  .get((req, res) =&gt; {<br/>    res.sendFile(path.join(__dirname + ‘/index.html’));<br/>    });<br/>  app.route(‘/content’)<br/>  .get(verifyToken, (req, res) =&gt; {<br/>    res.sendFile(path.join(__dirname + ‘/verified.html’))<br/>    });<br/>...</span></pre><p id="9abd" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">如果您阅读了我的上一篇博客<a class="ae lq" href="https://medium.com/@ckraczkowsky/building-a-secure-admin-interface-with-flask-admin-and-flask-security-13ae81faa05" rel="noopener">用Node.js构建RESTful API</a>，您会记得我们将Node.js应用程序前端的根路径设置为<code class="fe nf ng nh mx b">index.html</code>文件中的HTML文档。在该文档中，让我们添加一个将调用我们新定义的'/content '路由的链接。</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="edd6" class="ly lz it mx b gy nb nc l nd ne">&lt;a href=”/content”&gt;Click here for content!&lt;/a&gt;</span></pre><p id="8794" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">这将模拟上面<strong class="kw iu">注册新用户</strong>一节中讨论的体验，即一个网站向任何个人提供其部分内容，并限制拥有用户帐户的个人访问其其余内容。我们可以使用Postman工具来观察这一点，所以让我们再次启动我们的应用程序。</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="6957" class="ly lz it mx b gy nb nc l nd ne">$ node ./index.js</span></pre><p id="00ea" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">首先，我们向前端的根节点发送一个GET请求。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/b1efcabc5b21deafa10b7688cd9f05e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hx6YshIowSD7pAeX"/></div></div></figure><p id="3f61" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">正如所料，响应是<code class="fe nf ng nh mx b">index.html</code>文件。接下来，我们向'/content '路由发送一个GET请求，在这里我们插入了我们的<code class="fe nf ng nh mx b">verifyToken</code>中间件函数。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/b8da4331e9a7f5da990de74851a12f63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2VGhkGer6YKDpaCU"/></div></div></figure><p id="a660" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">不出所料，如果请求中没有JSON Web令牌，我们的Node.js应用程序将使用<code class="fe nf ng nh mx b">unverified.html</code>文件进行响应，表明我们无权访问该内容。接下来，我们提交一个新的GET请求，但是这次我们在HTTP头中传递一个JWT。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi nx"><img src="../Images/625f0c12d2e3abedf4f299f11b490c34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*S5HjQWsJ-vsWr6ev"/></div></div></figure><p id="9d6a" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在我们的Node.js应用程序用<code class="fe nf ng nh mx b">verified.html</code>文件响应，表明我们被授权访问这个内容。太好了，所以我们的中间件功能正在保护我们的路由免受没有有效JSON Web令牌的请求的影响！</p><h2 id="2540" class="ly lz it bd ma mb mc dn md me mf dp mg ld mh mi mj lh mk ml mm ll mn mo mp mq bi translated"><strong class="ak">使用中间件简化我们的控制器功能</strong></h2><p id="6e7b" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">除了调用队列中的下一个函数，我们还可以使用中间件函数在请求-响应周期中沿着函数传递数据。这使我们能够将一项工作写入控制器功能之间共享的单个中间件功能，而不是将该工作写入每个控制器功能。例如，我们可以简化我们的<code class="fe nf ng nh mx b">getRegisteredUser</code>控制器函数，以重用我们的<code class="fe nf ng nh mx b">verifyToken</code>中间件函数中完成的工作。</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="243d" class="ly lz it mx b gy nb nc l nd ne">const verifyToken = (req, res, next) =&gt; {<br/>  var token = req.headers[‘x-json-web-token’];<br/>  if (!token) {<br/>    res.status(403).sendFile(path.join(__dirname + ‘/unverified.html’));<br/>    console.log(‘No token was provided.’);<br/>  } else {<br/>    jwt.verify(token, config.secretKey, (error, decoded) =&gt; {<br/>      if (error) {<br/>        res.status(500).sendFile(path.join(__dirname + ‘/unverified.html’));<br/>        console.log(‘Failure to verify the token.’);<br/>      } else {<br/>        <strong class="mx iu">req.token = token;<br/>        req.decoded = decoded;<br/>        </strong>next();<br/>      };<br/>    });<br/>  };<br/>};</span></pre><p id="a7d9" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">在<code class="fe nf ng nh mx b">verifyToken</code>中，我们向<code class="fe nf ng nh mx b">req</code>对象添加了两个新属性<code class="fe nf ng nh mx b">token</code>和<code class="fe nf ng nh mx b">decoded</code>，并将它们设置为我们从HTTP头中提取的JSON Web令牌和我们从JWT获得的解码数据。然后这些值通过<code class="fe nf ng nh mx b">req</code>对象提供给下一个函数。</p><pre class="kj kk kl km gt mw mx my mz aw na bi"><span id="0576" class="ly lz it mx b gy nb nc l nd ne">const getRegisteredUser = (req, res) =&gt; {<br/>  <strong class="mx iu">var token = req.token;<br/>  var decoded = req.decoded;<br/>  </strong>if (!token) {<br/>    res.status(401).send({auth: false, message: ‘Token not provided.’});<br/>  } else {<br/>    User.findById(decoded.id, {password: 0}, (error, User) =&gt; {<br/>      if (error) {<br/>        res.status(500).send(‘There was an error finding that user.’);<br/>      } else if (!User) {<br/>        res.status(404).send(‘Could not locate that user.’);<br/>      } else {<br/>        res.status(200).send(User);<br/>      };<br/>    });<br/>  };<br/>};</span></pre><p id="89d4" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">现在，在我们的<code class="fe nf ng nh mx b">getRegisteredUser</code>函数中，我们使用从<code class="fe nf ng nh mx b">verifyToken</code>函数传递下来的JSON Web令牌，而不是再次从头文件中提取它。我们还删除了验证JWT的代码，因为我们的<code class="fe nf ng nh mx b">verifyToken</code>函数会替我们完成这项工作。我们剩下的是一个简单得多的<code class="fe nf ng nh mx b">getRegisteredUser</code>函数，它只执行显式的工作，即查找并返回注册用户。</p><p id="2830" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">所以回顾一下我们在这篇博客中所做的工作，我们从我以前的博客<a class="ae lq" href="https://medium.com/@ckraczkowsky/building-a-secure-admin-interface-with-flask-admin-and-flask-security-13ae81faa05" rel="noopener">中的一个基本REST API开始，用Node.js </a>构建一个RESTful API。然后，我们通过向我们的API添加两个新的端点来包含一些身份验证，以便个人可以为我们的应用程序注册一个用户帐户并登录到该帐户。我们确保这些终端使用<code class="fe nf ng nh mx b">bcryptjs</code>库安全负责地存储它们处理的敏感数据，例如密码。然后，我们添加了授权，在用户成功登录后授予用户一个JSON Web令牌，创建一个中间件函数来验证JWT是否有效，并将该中间件嵌入到我们希望对访问进行更严格控制的路由中。最终，我们得到了一个更加安全的REST API和Node.js应用程序！将来，我们可以通过添加基于角色的授权并为单个用户分配特定的角色，或者将用户分配给一个组并为该组分配一个角色，来实现更细粒度的访问控制。</p><p id="a023" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">要获得使用Nodes.js、MongoDB、JSON Web Tokens和bcrypt构建安全REST API的一些实践经验，请从我的GitHub中克隆我们在这篇博客中构建的应用程序的<a class="ae lq" href="https://github.com/ckraczkowsky91/rest-api-node-secure" rel="noopener ugc nofollow" target="_blank">源代码</a>，并在您的本地机器上运行它。</p><h2 id="6da5" class="ly lz it bd ma mb mc dn md me mf dp mg ld mh mi mj lh mk ml mm ll mn mo mp mq bi translated"><strong class="ak">关于作者</strong></h2><p id="9893" class="pw-post-body-paragraph ku kv it kw b kx mr ju kz la ms jx lc ld mt lf lg lh mu lj lk ll mv ln lo lp im bi translated">Colin Kraczkowsky在探索了产品管理的技巧之后，最近回到了web开发领域。Colin的职业经历包括在企业和初创企业环境中工作，编写web和移动应用程序代码，推出新产品，构建模型和原型，分析指标，以及不断创新。</p><p id="5baf" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">闲暇时，科林会去大苏尔看看最新的阿利特露营装备，计划下一次去柯克伍德·丹尼尔山，或者在网飞的恐怖区冲浪。科林目前居住在加利福尼亚州的旧金山。</p><p id="1c03" class="pw-post-body-paragraph ku kv it kw b kx ky ju kz la lb jx lc ld le lf lg lh li lj lk ll lm ln lo lp im bi translated">联系科林—<a class="ae lq" href="https://www.linkedin.com/in/colinkraczkowsky" rel="noopener ugc nofollow" target="_blank">https://www.linkedin.com/in/colinkraczkowsky</a></p></div></div>    
</body>
</html>