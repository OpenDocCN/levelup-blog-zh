<html>
<head>
<title>JavaScript Best Practices for Writing More Robust Code — Removing Duplicates and Merging Arrays</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编写更健壮代码的JavaScript最佳实践——删除重复和合并数组</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/javascript-best-practices-for-writing-more-robust-code-removing-duplicates-and-merging-arrays-67d0dfce9592?source=collection_archive---------20-----------------------#2020-05-22">https://levelup.gitconnected.com/javascript-best-practices-for-writing-more-robust-code-removing-duplicates-and-merging-arrays-67d0dfce9592?source=collection_archive---------20-----------------------#2020-05-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/7ccdea8a26b3baa9b2fa147ac5d1e812.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*i2Zr0mmevFF0eXdE"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@llon?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Leon Hinz </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="a0fc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">JavaScript是一种简单易学的编程语言。编写运行并执行某些操作的程序很容易。然而，很难考虑所有的用例并编写健壮的JavaScript代码。</p><p id="60ee" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将研究如何以一种可靠的方式从数组中移除重复项。</p><h1 id="3760" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">设置</h1><p id="b187" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以使用JavaScript <code class="fe mh mi mj mk b">Set</code>构造函数来创建集合，这些集合是不能包含重复项的对象。</p><p id="0102" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">重复项的确定方式类似于<code class="fe mh mi mj mk b">===</code>操作符，但是we -0和+0被认为是不同的值。</p><p id="83c7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了确定<code class="fe mh mi mj mk b">Set</code> s的重复项目，<code class="fe mh mi mj mk b">NaN</code>也被认为与自身相同</p><p id="61c9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以从数组创建一个集合，如下所示:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="97b5" class="mt lf it mk b gy mu mv l mw mx">const set = new Set([1, 2, 3, 3]);</span></pre><p id="9f40" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们有一个<code class="fe mh mi mj mk b">Set</code>实例，它的值是1、2和3。</p><p id="a670" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于<code class="fe mh mi mj mk b">Set</code>是一个可迭代对象，我们可以使用spread操作符将其转换回数组，如下所示:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="250d" class="mt lf it mk b gy mu mv l mw mx">const noDup = [...set];</span></pre><p id="46a6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我们所见，将<code class="fe mh mi mj mk b">Set</code>转换回数组非常容易。</p><p id="160a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因为确定重复的算法是以类似于<code class="fe mh mi mj mk b">===</code>操作符的方式确定的，所以它对于删除重复的原始值很有效。</p><p id="8d14" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是，对于对象来说，除非它们引用内存中的同一个项，否则效果不好。</p><p id="4895" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们有对象，那么消除重复的最可靠的方法是将它们转换成字符串，然后解析回对象。</p><p id="6cb5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有以下数组:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="5249" class="mt lf it mk b gy mu mv l mw mx">const arr = [{<br/>  a: 1<br/>}, {<br/>  a: 1<br/>}];</span></pre><p id="3b8b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们可以编写以下代码，将数组映射到一个字符串，将其转换为一个<code class="fe mh mi mj mk b">Set</code>，然后我们可以将剩余的项解析回对象，如下所示:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="a432" class="mt lf it mk b gy mu mv l mw mx">const set = new Set(arr.map(a =&gt; JSON.stringify(a)));<br/>const noDup = [...set].map(a =&gt; JSON.parse(a));</span></pre><p id="c6f4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们有一个<code class="fe mh mi mj mk b">Set</code>，它是从用<code class="fe mh mi mj mk b">JSON.stringify</code>字符串化的数组条目中创建的。</p><p id="5c0a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们使用spread操作符将<code class="fe mh mi mj mk b">set</code>扩展回一个数组，然后将字符串化的条目映射回带有<code class="fe mh mi mj mk b">JSON.parse</code>的对象。</p><p id="d860" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这对于没有方法的普通对象来说很有效。</p><p id="c10c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们的对象有方法，那么我们应该确保每个条目引用同一个对象。</p><p id="ca59" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">也有一些方法使遍历它们变得更容易。有一个<code class="fe mh mi mj mk b">entries</code>方法将所有条目作为迭代器获取，迭代器将每个条目作为具有<code class="fe mh mi mj mk b">[key, value]</code>结构的数组返回。</p><p id="d193" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">forEach</code>使用回调来遍历它们。<code class="fe mh mi mj mk b">keys</code>和<code class="fe mh mi mj mk b">values</code>方法让我们分别得到键和值。</p><p id="b916" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">方法从集合中移除所有的项目。</p><p id="3b44" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它还具有<code class="fe mh mi mj mk b">size</code>属性来获取<code class="fe mh mi mj mk b">Set</code>的大小。</p><h1 id="1278" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">使用扩展运算符</h1><p id="02c1" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">spread操作符是JavaScript最近增加的最有用的特性之一。</p><p id="4d40" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当它和数组一起使用时，它可以让我们复制数组或者合并数组，而不需要调用任何方法。这使得我们的代码简短易读。</p><p id="562d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们只是用spread操作符把所有东西放在一个数组中，然后我们得到一个包含新条目的新数组。</p><p id="c2ca" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此外，它允许我们将不同类型的iterable对象中的项组合到一个数组中。</p><p id="2830" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，我们可以对多个数组使用spread运算符，如下所示:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="7ff2" class="mt lf it mk b gy mu mv l mw mx">const arr1 = [1, 2, 3];<br/>const arr2 = [4, 5];<br/>const arr = [...arr1, ...arr2];</span></pre><p id="8c6d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们得到<code class="fe mh mi mj mk b">arr</code>的值是<code class="fe mh mi mj mk b">[1, 2, 3, 4, 5]</code>。</p><p id="c7ef" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我们所看到的，条目是用spread操作符按顺序添加到新数组中的。</p><p id="e187" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">由于spread操作符处理不同种类的iterable对象，我们也可以将<code class="fe mh mi mj mk b">Map</code>和<code class="fe mh mi mj mk b">Set</code>扩展到数组中:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="2c73" class="mt lf it mk b gy mu mv l mw mx">const arr1 = [1, 2, 3];<br/>const set = new Set([4, 5]);<br/>const map = new Map();<br/>map.set('a', 1);<br/>map.set('b', 2);<br/>const arr = [...arr1, ...set, ...map];</span></pre><p id="25d5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">那么我们得到<code class="fe mh mi mj mk b">arr</code>是:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="eb36" class="mt lf it mk b gy mu mv l mw mx">[<br/>  1,<br/>  2,<br/>  3,<br/>  4,<br/>  5,<br/>  [<br/>    "a",<br/>    1<br/>  ],<br/>  [<br/>    "b",<br/>    2<br/>  ]<br/>]</span></pre><p id="50e6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">Map</code>被转换成一个数组，数组中的条目是<code class="fe mh mi mj mk b">key</code>和<code class="fe mh mi mj mk b">value</code>的数组。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi my"><img src="../Images/0fca7e321adb259bba5d6e70a2a36fb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tMVhgDymXf6q4c24"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">胡安·Á·阿尔瓦雷斯·阿贾米尔在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><h1 id="d58c" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="faa7" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mh mi mj mk b">Set</code>对于从数组中删除重复项很有用。它们也可以被转换或合并成数组。</p><p id="7fa8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还可以用spread操作符将多种可迭代对象合并到一个数组中。</p></div></div>    
</body>
</html>