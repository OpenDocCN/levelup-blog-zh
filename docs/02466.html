<html>
<head>
<title>Working with the Azure Cosmos DB Change Feed Processor in C#</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在C#中使用Azure Cosmos DB更改提要处理器</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/working-with-the-azure-cosmos-db-change-feed-processor-in-c-a0d1e2b26aed?source=collection_archive---------6-----------------------#2020-03-15">https://levelup.gitconnected.com/working-with-the-azure-cosmos-db-change-feed-processor-in-c-a0d1e2b26aed?source=collection_archive---------6-----------------------#2020-03-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1c99" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">多亏了变更提要处理器，您可以简化在Azure Cosmos DB上读取变更提要的过程</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/cffd6250435c889aac201d9c305ff64a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*9owtR7ohVjkZ9Br3.png"/></div></div></figure><p id="c478" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">作为Azure Cosmos DB的<a class="ae ln" href="https://github.com/Azure/azure-cosmos-dotnet-v3" rel="noopener ugc nofollow" target="_blank"> v3的一部分。NET SDK </a>，Cosmos DB集成了<a class="ae ln" href="https://docs.microsoft.com/en-us/azure/cosmos-db/change-feed-processor" rel="noopener ugc nofollow" target="_blank">变化馈送处理器</a>作为库的一部分。以前在v2中，它有自己的<a class="ae ln" href="https://docs.microsoft.com/en-us/azure/cosmos-db/sql-api-sdk-dotnet-changefeed" rel="noopener ugc nofollow" target="_blank">库</a>，你必须单独下载才能使用。</p><p id="00b5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用C#，我们可以以各种不同的方式处理变更提要。实现变更提要最简单的方法是通过Azure函数。您可以创建一个带有Cosmos DB触发器的函数，以这种方式监听容器。您还可以使用Azure Cosmos DB SQL API SDK，它提供了对变更提要的底层控制。最后，您可以通过使用变更提要处理器库来读取变更提要。</p><p id="f3bf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在本文中，我将讨论Change Feed处理器，分解代码中使其工作的特定部分，并使用一个演示来将其概念化。这个演示将从我们的Cosmos DB帐户的源容器中读取事件，并将这些更改保存在Cosmos DB的备份容器中。您也可以使用另一个数据存储(比如Blob存储或Azure SQL)，但是为了简单起见，我将把它放在Cosmos DB中。</p><p id="ea36" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">等等，我对这个还不熟悉。Cosmos DB中的更改提要是什么？</strong></p><p id="93ec" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在Cosmos DB中，我们使用Change Feed来监听我们的Cosmos数据库中的容器，以检测该容器中的任何更改。然后，更改提要将返回一个按修改顺序排序的文档列表。</p><p id="d9b3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是一个非常棒的特性，它允许我们根据我们在Cosmos DB容器中的活动来触发事件。本文将演示如何使用变更提要将数据从我们的Cosmos DB集合转移到另一种类型的数据存储中，但是您也可以将变更提要用于其他用例，比如流处理或者在插入或更新项目时触发通知。</p><p id="abf8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在撰写本文时，您可以使用SQL API、Cassandra、MongoDB API和Gremlin API Cosmos DB account的更改提要。变更提要当前捕获所有操作。<strong class="kt ir">您不能限制变更提要将监听的操作类型(比如仅更新或仅插入)。</strong>更改提要也不会监听任何删除操作。</p><p id="1259" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您不需要做任何特别的事情来启用您的Cosmos DB帐户中的变更提要(它是默认存在的！).</p><p id="df88" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">好的，那么零钱处理器有什么特别之处呢？</strong></p><p id="d40e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">变更馈送处理器简化了变更馈送的读取，并且它将事件的处理分布在多个消费者之间。它的容错行为提供了变更提要中所有事件的“至少一次”交付。</p><p id="2449" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">该库遵循观察者模式。如果您的变更提要具有较高的吞吐量，我们可以实例化多个客户端来读取提要，库将在所有客户端之间分配负载，而无需我们做任何事情。如果你真的想或者需要有自己的负载均衡器，你也可以这样做。</p><p id="da91" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">那么处理器是如何工作的呢？</strong></p><p id="f487" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">变更馈送处理器分4步工作:</p><ol class=""><li id="df6b" class="lo lp iq kt b ku kv kx ky la lq le lr li ls lm lt lu lv lw bi translated">它将读取更改馈送</li><li id="2ac6" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated"><strong class="kt ir">如果没有任何变化</strong>，它将进入睡眠状态(这次我们可以自定义)。</li><li id="46c7" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated"><strong class="kt ir">如果有变更</strong>，我们将使用委托来处理这些变更。</li><li id="71a5" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated">处理完这些更改后，将使用最新处理的点更新租赁存储，并返回到步骤1。</li></ol><p id="1416" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了实现Change Feed处理器，我们需要设置以下组件:</p><ul class=""><li id="084f" class="lo lp iq kt b ku kv kx ky la lq le lr li ls lm mc lu lv lw bi translated">我们需要一个容器来监控事件。这些事件生成变更馈送。</li><li id="7d20" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm mc lu lv lw bi translated">我们需要一个租赁集装箱。这作为一个状态存储，将有助于协调多个工作人员的变更处理。</li><li id="c401" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm mc lu lv lw bi translated">我们需要一台使用处理器监听变化的主机。如果我们有多个共享相同租约配置的变更馈送处理器实例，那么每个主机实例应该有不同的名称。</li><li id="e6e8" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm mc lu lv lw bi translated">最后，我们需要一个代表。这是我们处理变更的地方，变更提要将会读取这些变更。</li></ul><p id="280e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">如果我的代理出错了怎么办？如何处理错误？</strong></p><p id="36c0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您的委托中有未处理的异常，处理这些更改的线程将被停止，并将创建一个新线程。</p><p id="0e3a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后，这个新线程将查看租约存储区中保存的最新时间点，并从那里重新开始。这将一直持续到我们的更改得到处理。这是更改馈送处理器提供的“至少一次”保证。</p><p id="3c04" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你能给我看一些代码吗？</p><p id="7ebd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们写一些代码来看看这是怎么回事。我将创建一个简单的控制台应用程序，并浏览最重要的部分:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="52af" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这个方法中，我们定义了入口点，它是我们想要监控的容器。我们使用GetChangeFeedProcessorBuilder方法在我们想要监控的容器上构建我们的处理器。在这里，我们定义如何处理我们的变更提要中的变更(定义我们的委托)，定义实例名，然后添加租约容器配置。</p><p id="d6c9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在让我们来看看这位代表:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="md me l"/></div></figure><p id="4cba" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里，我们正在传递一个IReadOnlyCollection产品项列表。这实质上是已经被挑选出来的变更提要事件。然后，我们遍历这些更改，对于添加到列表中的每个产品，我们都将该项保存在备份集合中。</p><p id="a62e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你想看这个的完整实现，请查看这个GitHub Repo 。</p><p id="f77d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">看起来很简单，但是我该如何衡量呢？</strong></p><p id="b9d1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">只要您部署的更改馈送的所有实例对租约容器使用相同的配置，它们都具有相同的工作流名称，并且每个实例都有自己的名称，更改馈送处理器就会将租约容器中的所有租约分布到我们的所有实例中。我们可以增加和减少实例的数量，处理器会调整负载。</p><p id="c453" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">就吞吐量而言，我将如何收费？</strong></p><p id="8ece" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">更改提要本质上仍然是一个读操作，因此您将为消耗的RU付费。这些将由租赁容器使用。</p><p id="5b48" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">结论</strong></p><p id="def3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">读完本文后，我希望您已经对Change Feed处理器的工作原理有了基本的了解。如果您需要在同一个容器上执行多个变更提要操作，那么我强烈建议您使用处理器，而不是在Cosmos DB触发器中使用多个Azure函数。</p><p id="08e6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你有任何问题，请在评论中发表。</p></div></div>    
</body>
</html>