<html>
<head>
<title>How much Code Coverage do you need?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你需要多少代码覆盖率？</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-much-code-coverage-do-you-need-ea07c74a2717?source=collection_archive---------28-----------------------#2021-01-11">https://levelup.gitconnected.com/how-much-code-coverage-do-you-need-ea07c74a2717?source=collection_archive---------28-----------------------#2021-01-11</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="3fe1" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">使用代码覆盖工具将有助于发现哪里需要它</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/d7cb14a07790e61b1c228648ff2ea7d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gRK6JbFQTfW7woObW5jx_Q.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">截图由作者提供</figcaption></figure><p id="1eb1" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">在过去的文章中，我关于代码覆盖率的观点的最初措辞可能会产生误导。让我们借此机会讨论一下使用这些工具的关键价值，这样你就可以发现并验证什么对你来说是重要的。</p><h1 id="29f3" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">完成不一定意味着100%</h1><p id="5307" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">过去，我们讨论过实时代码覆盖工具，像<a class="ae ms" href="https://www.ncrunch.net/" rel="noopener ugc nofollow" target="_blank"> NCrunch </a>或<a class="ae ms" href="https://docs.microsoft.com/en-us/visualstudio/test/live-unit-testing?view=vs-2019" rel="noopener ugc nofollow" target="_blank"> VS Enterprise的实时单元测试</a>，这些工具让开发人员<em class="lu">对他们编写的每一行代码</em>负责。大多数开发人员的本能反应是不会用这种确切的措辞，但我的初衷不是使用代码覆盖率来减少回报。</p><p id="850f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">请注意，<em class="lu">对你写的每一行代码负责</em>不同于<em class="lu">字面上的</em>写测试覆盖每一行代码。责任始于<em class="lu">意识</em>，一旦你意识到未被覆盖的代码，就由你来辨别覆盖它是否有价值。</p><h1 id="4116" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">意识是一个开始</h1><p id="93d8" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">当您在代码编辑器的空白处有逐行测试状态时，它会直观地告诉您哪些代码行被通过测试、失败测试或根本没有被任何测试覆盖。如果您将鼠标悬停在状态上，您可以获得每行代码影响了多少测试的明细。</p><p id="c3ba" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">“受影响”并不意味着每一行代码都有一个特定的测试，而是指该行代码在至少一个测试的调用堆栈期间的某个点执行。您可以看到受每行代码影响的测试列表，并跳转到它们。</p><p id="6617" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">有了实时覆盖，您还会意识到，当您破坏测试所覆盖的现有代码时。不仅是在CI上运行之前，而且是在您输入时的<em class="lu">，在您检入甚至保存您正在处理的源文件之前！</em></p><h2 id="b496" class="mt lw it bd lx mu mv dn mb mw mx dp mf lh my mz mh ll na nb mj lp nc nd ml ne bi translated">为什么或什么时候意识是重要的？</h2><p id="33a1" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">如果不是你写的所有代码都保证被QA场景实际执行，随着时间的推移会产生大量未测试的代码，并因此产生bug，不要感到惊讶。这并不奇怪，因为我发现开发人员很少知道QA的测试套件，更不用说了解最新的测试套件了。</p><p id="c566" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">大多数开发人员没有意识到的是，每个if/else、switch case、enum、break和continue语句或早期返回——开发人员是唯一知道它们的人(代码审查人员之外)——并且不是所有这些都会直接映射到QA在创建套件时可以引用的需求。你一周、一个月或一年写多少？将这个数字乘以你的团队中有多少开发人员，你可以很快想象出你有多少未测试的代码。</p><p id="be61" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">除非你正在实践<a class="ae ms" href="https://medium.com/@jeffreybakker/defining-and-measuring-software-behaviour-b542370e8b7d" rel="noopener">行为驱动的开发</a>，否则开发人员和QA都从产品所有者的需求中提取他们的期望——并且所有三个团队通常不会在同一页上，直到它已经处于测试阶段。整个主题完全是另一个故事，但是希望这个简短的提及说明了需求、实现和期望之间的重叠并不像您想象的那样紧密。</p><h1 id="847f" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">不要报道的事情</h1><p id="bb5c" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">从显而易见的开始，肯定有一些胶水、样板文件、OS级应用程序挂钩和head项目初始化代码不值得进行测试。当然，还有其他你可以信赖的“管用”的基本原则。然后你有服务和用户界面代码，你可能只是想存根或模拟出来。也有最适合集成测试或UI自动化的代码，所以单元测试覆盖率肯定不总是适用的。</p><p id="b5b9" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您纯粹着眼于核心业务逻辑，您仍然可以找到一定数量的代码，这些代码太琐碎了，以至于不值得为其显式编写测试，或者根本不是您的首要任务。这很好，每个公司或项目都不一样，但至少覆盖工具会让你知道他们没有被覆盖——这让你有意识地做出决定。</p><p id="7db3" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated"><em class="lu">选择</em>不覆盖某些东西(希望有一个合理的理由)总是比<em class="lu">不考虑</em>覆盖你的代码要好得多。</p><h1 id="7fb2" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">要考虑的项目</h1><p id="ed97" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">再次从显而易见的开始，任何算法，或任何产生不同输出或可能用于各种输入组合的例程，都将是覆盖多个测试的理想选择——特别是如果不同输入如何影响预期结果不明显的话。一些过于复杂的东西实际上可能是一种气味，而这种气味是由一个单一的程序造成的。</p><p id="416e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果您有多个子系统通过事件相互响应，并且正确的事件通知程序和侦听器必须在适当的时间触发，那么您可以考虑测试它们。虽然这并不重要；如果真的感觉你只是过度测试事件机制本身，如果它已经被覆盖或被证明是可靠的。如果某些事件基于配置或其他参数可变地触发，它仍然是有用的。</p><p id="bbb7" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">状态管理或状态转换。如果您的产品依赖于对程序生命周期中状态如何变化的预期，或者状态机中的转换应该何时发生，您可能会考虑它。覆盖这些代码可以确保您的状态仍然正常，同时多年来维护您的产品。在这个领域破坏测试要么是一个明显的bug，要么是一个我们应该认识到的重大变化。</p><p id="d012" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">非平凡数据转换。有编组原语或简单的dto或数据包，它们在99.9%的情况下都完全符合您的预期，但还有转换更复杂的数据类型的主题。如果转换对输出隐式应用了格式或其他变化，会怎么样呢？如果您正在使用非标准的或“巧妙的”解序列化技术呢？</p><h1 id="ed26" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">明确定义预期结果</h1><p id="4f94" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">您的代码实际上是否如设计的那样工作的真相可以在一个写得很好的测试中被捕获。不仅仅是提供证据，而是明确定义如果代码被使用，人们应该期待什么。</p><p id="dd6b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">快乐路径、错误案例、参数化场景、bug案例，有时甚至是边缘案例，一旦你为它们编写了测试，它们都变成了最新的、活的文档。当你定义了什么是预期的，并跟踪它何时改变或不再成为现实，你就走在了意想不到的变化的前面。</p><h1 id="2da5" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">当覆盖失败时</h1><p id="1cf5" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">如果你发现自己编写的测试覆盖了第三方框架或你自己的样板文件，而不是你的问题领域的逻辑，你可能是在浪费时间。</p><p id="9e0b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">此外，如果你花更多的时间维护测试，而不是实际编写有成效的代码——特别是如果大多数失败都是假阴性的话——你可能想看看你是如何编写测试的，或者应该覆盖哪些区域。有可能你做错了或者没有效率，但是也有可能你测试的东西不够确定，不足以有效维护。</p><p id="288f" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">拥有一个定义良好的测试策略、测试实现和处理失败测试的计划对于保持事情在控制之下是必不可少的。优先级、所有权和个人责任应该非常明确。</p><p id="729e" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果贡献不是每个人都参与的一致的团队努力，你的测试覆盖策略可能会失败；把它留给主要开发人员或一小部分高级开发人员不仅会导致太多的不平衡，还会破坏问责制和增长的教学。</p><h1 id="004f" class="lv lw it bd lx ly lz ma mb mc md me mf jz mg ka mh kc mi kd mj kf mk kg ml mm bi translated">最后的想法</h1><p id="759f" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">热爱代码覆盖工具有太多好的理由，希望在读完这篇文章后，现在<em class="lu">有更少的理由不去</em>。无论你的目标是80%的代码覆盖率还是30%的覆盖率，都取决于你自己，没有明确的“对”或“错”。这个想法是知道你的立场和意识到差距，理想情况下，这是一个预先的决定，而不是事后的<em class="lu"/>。</p><h2 id="fd68" class="mt lw it bd lx mu mv dn mb mw mx dp mf lh my mz mh ll na nb mj lp nc nd ml ne bi translated">每个人都喜欢精彩的情节转折</h2><p id="5152" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">但是你能安排的时间有限。就我个人而言，作为一名在前端工作过很多的开发人员，如果我必须在a)高代码覆盖率，但根本没有UI测试，或者b)只有关键路径单元测试，但有UI测试之间做出选择，我会选择b)我参与过的一些项目。</p><p id="e351" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">这是因为，虽然单元测试和代码覆盖率对于算法、子系统交互和代码库的总体健康非常重要，但最终重要的是软件按照用户或利益相关者的预期工作；引擎盖下的东西与他们无关(但对开发人员来说应该是)。从用户接受的角度来定义和测试的最好方法是通过行为驱动开发。</p><p id="168b" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">代码覆盖工具很棒，但是覆盖不一定是最有价值的部分。它允许您更仔细地考虑应该如何使用您的代码，并真正帮助您评估您编写的代码中有多少是可测试的。很多时候，不可测试的代码是糟糕的软件架构的结果，这反过来意味着高维护成本和大量的错误来源。编写好的、可维护的代码，并用单元测试覆盖它，这是齐头并进的。</p><h2 id="9b33" class="mt lw it bd lx mu mv dn mb mw mx dp mf lh my mz mh ll na nb mj lp nc nd ml ne bi translated">结论</h2><p id="a25b" class="pw-post-body-paragraph ky kz it la b lb mn ju ld le mo jx lg lh mp lj lk ll mq ln lo lp mr lr ls lt im bi translated">如果你关心代码质量，你可以从代码库的单元可测试性开始。然后建立一个适合你的项目的覆盖策略，并开始朝着这个目标努力。您可以在事后添加验收测试，因为验收测试的黑盒性质不会对您的代码结构产生太大影响。</p><p id="5fa6" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">如果你关心输出质量(应用程序如何为用户工作)，你应该<em class="lu">认真地</em>通过采用BDD实践和哲学来考虑验收测试自动化。您仍然应该考虑将您的代码结构化为可隔离的类，以支持单元测试，这样以后添加它们也不是不可能的。</p></div><div class="ab cl nf ng hx nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="im in io ip iq"><p id="72bb" class="pw-post-body-paragraph ky kz it la b lb lc ju ld le lf jx lg lh li lj lk ll lm ln lo lp lq lr ls lt im bi translated">文章怎么样？爱它，恨它，我错过了什么吗？我想在评论区听到你的意见。</p></div></div>    
</body>
</html>