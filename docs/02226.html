<html>
<head>
<title>State and Lifecycle of React Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React组件的状态和生命周期</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/state-and-lifecycle-of-react-components-18a4ddc367c1?source=collection_archive---------12-----------------------#2020-02-27">https://levelup.gitconnected.com/state-and-lifecycle-of-react-components-18a4ddc367c1?source=collection_archive---------12-----------------------#2020-02-27</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/3890b99b82a30790f06e49fa15903196.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FsRhTVZ1Lt8_eQT3"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@benwhitephotography?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">本怀特</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="a91f" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">React是一个用于创建前端视图的库。它有一个庞大的图书馆生态系统与之合作。此外，我们可以用它来增强现有的应用程序。</p><p id="c171" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将研究React组件的生命周期以及如何改变它们的内部状态。</p><h1 id="dfe3" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">改变内部状态</h1><p id="9cab" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">道具是不可变的，因为我们希望保持React组件相对于道具的纯洁性。这意味着当我们传入相同的道具时，我们总是得到相同的输出，假设其他什么都没有改变。</p><p id="bc60" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这在大多数情况下不是很有用，因为我们想改变组件内部的东西。</p><p id="fa56" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为此，我们可以操纵组件的内部状态。</p><p id="58d1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所有基于类的React组件都有可通过<code class="fe mh mi mj mk b">this.state</code>访问的内部状态，我们可以通过调用<code class="fe mh mi mj mk b">this.setState</code>来改变它。</p><p id="2eac" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们想创建一个显示当前时间并每秒更新一次的<code class="fe mh mi mj mk b">Clock</code>组件，我们可以这样做:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="6745" class="mt lf it mk b gy mu mv l mw mx">class Clock extends React.Component {<br/>  constructor(props) {<br/>    super(props);<br/>    this.state = { date: new Date(), timer: undefined };<br/>  }</span><span id="d39f" class="mt lf it mk b gy my mv l mw mx">  componentWillMount() {<br/>    this.updateDate();<br/>  }</span><span id="8557" class="mt lf it mk b gy my mv l mw mx">  componentWillUnmount() {<br/>    clearInterval(this.state.timer);<br/>  }</span><span id="433e" class="mt lf it mk b gy my mv l mw mx">  updateDate() {<br/>    const timer = setInterval(() =&gt; {<br/>      this.setState({ date: new Date() });<br/>    }, 1000);<br/>    this.setState({ timer });<br/>  }</span><span id="7b70" class="mt lf it mk b gy my mv l mw mx">  render() {<br/>    return (<br/>      &lt;div&gt;<br/>        &lt;p&gt;It is {this.state.date.toLocaleTimeString()}.&lt;/p&gt;<br/>      &lt;/div&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="5a34" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们声明了一个扩展了<code class="fe mh mi mj mk b">React.Component</code>的类<code class="fe mh mi mj mk b">Clock</code>。这意味着代码是一个React组件，它可以有自己的生命周期方法和<code class="fe mh mi mj mk b">render</code>方法。</p><p id="707e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<code class="fe mh mi mj mk b">Clock</code>组件内部，我们声明了<code class="fe mh mi mj mk b">constructor</code>中的<code class="fe mh mi mj mk b">state</code>字段，它具有初始状态<code class="fe mh mi mj mk b">date</code>和一个<code class="fe mh mi mj mk b">timer</code>状态来保存由<code class="fe mh mi mj mk b">setInterval</code>返回的定时器对象。</p><p id="6020" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另外，我们调用<code class="fe mh mi mj mk b">super(props)</code>是因为<code class="fe mh mi mj mk b">Clock</code>扩展了<code class="fe mh mi mj mk b">React.Component</code>，而<code class="fe mh mi mj mk b">React.Constructor</code>将<code class="fe mh mi mj mk b">props</code>作为参数。</p><p id="895b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，当<code class="fe mh mi mj mk b">Clock</code>组件被挂载到DOM中时，我们有自己的<code class="fe mh mi mj mk b">componentDidMount</code>生命周期钩子来加载初始化代码。</p><p id="0c25" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在<code class="fe mh mi mj mk b">componentDidMount</code>中调用<code class="fe mh mi mj mk b">updateDate</code>方法，每秒不断更新<code class="fe mh mi mj mk b">this.state.date</code>。</p><p id="29e1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了更新<code class="fe mh mi mj mk b">setInterval</code>回调中的日期，我们用一个对象调用了<code class="fe mh mi mj mk b">this.setState</code>。</p><p id="c87a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对象将状态名作为键，正如我们在第一行中定义的那样，值是我们想要设置状态的新值。</p><p id="f879" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还调用了<code class="fe mh mi mj mk b">setState</code>来设置<code class="fe mh mi mj mk b">timer</code>字段，这样我们就可以在<code class="fe mh mi mj mk b">componentWillUnmount</code>中用它来调用<code class="fe mh mi mj mk b">clearInterval</code>。当组件从DOM中移除时，调用<code class="fe mh mi mj mk b">componentWillUnmount</code>钩子。</p><p id="85f8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是一个运行任何用于清理的代码的好地方。</p><p id="71d8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">最后，在<code class="fe mh mi mj mk b">render</code>方法中，我们呈现日期。每当<code class="fe mh mi mj mk b">this.state</code>通过调用<code class="fe mh mi mj mk b">this.setState</code>而改变时，这个方法就会被调用，所以如果我们把<code class="fe mh mi mj mk b">this.state</code>属性放在那里，它的最新值将总是被显示。</p><p id="3008" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这意味着<code class="fe mh mi mj mk b">this.state.date</code>将是以下日期之后的最晚日期:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="af04" class="mt lf it mk b gy mu mv l mw mx">this.setState({ date: new Date() });</span></pre><p id="8de6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">叫做。</p><p id="c516" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">componentDidMount</code>和<code class="fe mh mi mj mk b">componentWillUnmount</code>是生命周期方法。它们只在React组件生命周期的特定部分被调用。</p><p id="df54" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe mh mi mj mk b">this.setState</code>是异步的，所以我们不应该假设在<code class="fe mh mi mj mk b">this.setstate</code>调用之后列出的代码会在<code class="fe mh mi mj mk b">this.setState</code>之后立即运行。</p><p id="61e1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了在DOM中挂载它，我们调用带有传入的<code class="fe mh mi mj mk b">Clock</code>的<code class="fe mh mi mj mk b">ReactDOM.render</code>方法，如下所示:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="e993" class="mt lf it mk b gy mu mv l mw mx">import React from "react";<br/>import ReactDOM from "react-dom";</span><span id="bb6c" class="mt lf it mk b gy my mv l mw mx">class Clock extends React.Component {<br/>  constructor(props) {<br/>    super(props);<br/>    this.state = { date: new Date(), timer: undefined };<br/>  }</span><span id="ec96" class="mt lf it mk b gy my mv l mw mx">  componentWillMount() {<br/>    this.updateDate();<br/>  }</span><span id="7b7c" class="mt lf it mk b gy my mv l mw mx">  componentWillUnmount() {<br/>    clearInterval(this.state.timer);<br/>  }</span><span id="2b96" class="mt lf it mk b gy my mv l mw mx">  updateDate() {<br/>    const timer = setInterval(() =&gt; {<br/>      this.setState({ date: new Date() });<br/>    }, 1000);<br/>    this.setState({ timer });<br/>  }</span><span id="1f74" class="mt lf it mk b gy my mv l mw mx">  render() {<br/>    return (<br/>      &lt;div&gt;<br/>        &lt;p&gt;It is {this.state.date.toLocaleTimeString()}.&lt;/p&gt;<br/>      &lt;/div&gt;<br/>    );<br/>  }<br/>}</span><span id="03e8" class="mt lf it mk b gy my mv l mw mx">const rootElement = document.getElementById("root");<br/>ReactDOM.render(&lt;Clock /&gt;, rootElement);</span></pre><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/cbb411f69b8ca85b676c0696d835f2a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FyGeN3y6NUyxCz1r"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">Max Ostrozhinskiy 在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="d47d" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">正确使用状态</h1><p id="3c24" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们不应该直接修改状态，因为它不会触发组件的重新呈现。</p><p id="576b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">所以我们不应该写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="596b" class="mt lf it mk b gy mu mv l mw mx">this.state.foo = 'bar';</span></pre><p id="d6cc" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">相反，我们应该始终使用如下<code class="fe mh mi mj mk b">this.setState</code>:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="bf7e" class="mt lf it mk b gy mu mv l mw mx">this.setState({foo: 'bar'});</span></pre><h1 id="a79a" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">状态更新可以是异步的</h1><p id="6a9f" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">状态更新是异步的，所以我们不应该依赖它一个接一个地运行。</p><p id="cafd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">同样，我们不能仅仅在<code class="fe mh mi mj mk b">setState</code>中组合<code class="fe mh mi mj mk b">props</code>和<code class="fe mh mi mj mk b">state</code>的值。</p><p id="52e4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，以下操作可能会失败:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="ea4a" class="mt lf it mk b gy mu mv l mw mx">this.setState({<br/>  count: this.state.count + this.props.increment,<br/>});</span></pre><p id="22e4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">相反，我们写道:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="e536" class="mt lf it mk b gy mu mv l mw mx">this.setState((state, props) =&gt; ({<br/>  count: state.count + props.increment<br/>}));</span></pre><p id="8bad" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">从<code class="fe mh mi mj mk b">props</code>获取最新值来更新代码。</p><p id="e7bf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">常规函数和箭头函数都起作用，所以我们也可以写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="5eb3" class="mt lf it mk b gy mu mv l mw mx">this.setState(function(state, props) {<br/>  return {<br/>    count: state.count + props.increment<br/>  };<br/>});</span></pre><h1 id="7847" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">合并状态更新</h1><p id="9ab4" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">当我们调用<code class="fe mh mi mj mk b">setState</code>时，React将我们传入<code class="fe mh mi mj mk b">setState</code>的对象合并到当前状态。</p><p id="cccf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有两个状态，<code class="fe mh mi mj mk b">firstName</code>和<code class="fe mh mi mj mk b">lastName</code>，那么当我们调用<code class="fe mh mi mj mk b">this.setstate({ lastName });</code>时，<code class="fe mh mi mj mk b">this.state.firstName</code>保持不变，而<code class="fe mh mi mj mk b">this.state.lastName</code>用最新的值<code class="fe mh mi mj mk b">lastName</code>更新。</p><h1 id="e6f3" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">数据向下流动</h1><p id="1add" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">状态总是在组件内部，它可以作为道具传递给子组件和元素。</p><p id="23f5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">React apps有一个从父母到孩子的单向数据流。</p><h1 id="db9e" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="054c" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以通过在组件内部存储状态来创建一个动态的React组件。</p><p id="a945" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">状态对象存储在React组件类的<code class="fe mh mi mj mk b">state</code>字段中。</p><p id="e180" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以通过运行<code class="fe mh mi mj mk b">this.setState</code>来设置状态。</p><p id="2dad" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">React组件具有触发React组件类中的方法的生命周期。这些被称为生命周期挂钩。</p><p id="cdfe" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以使用它们在React组件生命周期的特定阶段运行代码。</p></div></div>    
</body>
</html>