<html>
<head>
<title>How I bricked my router trying to lock a door</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我如何用砖砌我的路由器试图锁门</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-i-bricked-my-router-to-manually-lock-an-old-door-935f863fb613?source=collection_archive---------16-----------------------#2020-01-14">https://levelup.gitconnected.com/how-i-bricked-my-router-to-manually-lock-an-old-door-935f863fb613?source=collection_archive---------16-----------------------#2020-01-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="168c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我以为我有一个聪明的办法来解决一个古老的问题，结果却是一个愚蠢的工程探索。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/6bc914e9758af63d15292ebb29d63588.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lYQDo7tBPYAauqDwQsqrxA.jpeg"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">伊莎贝尔·加格在<a class="ae le" href="https://unsplash.com/s/photos/door?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="10a3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">自从我出生以来，我一直住在伊斯坦布尔一个不太好的街区，每隔一段时间就会发生盗窃事件。此外，我们住在一栋家属楼里，这栋楼的三个房间都被我们、我的叔叔和他们的家人住着。事情是这样的，我们的大楼有一扇生锈的旧外门，门上的锁坏了；因此，我们不能锁门，我们只是锁了我们公寓的门，但同时我们把鞋子放在我们公寓的前面，这在家庭建筑中很常见，这个陈旧生锈的门在这段时间里导致了好几双鞋子被偷。在上次事故后，我们决定在门上安装一个手动滑锁，只能从里面锁上，当这个锁被锁上时，即使有钥匙，门也不能从外面打开。这种锁的问题是，在我们用这种新的手动锁锁门之前，我们必须确保每个公寓至少有一个人在家，以防其他人回家，这样他们就可以下楼，打开锁，让其他人进来，然后再锁上，这意味着我们会让门不锁，并希望无论谁在上午12点以后来都会锁门，因为很难通过查看鞋子来检查所有公寓以确定是否有人在家。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi lf"><img src="../Images/f6fb678f0e911dfba572008812da7ce2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qy8HDPg_ys9VOdCVgk54kg.jpeg"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">照片由<a class="ae le" href="https://unsplash.com/@markusspiske?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">马库斯·斯皮斯克</a>在<a class="ae le" href="https://unsplash.com/s/photos/lock?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="d332" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在另一个单独的话题上，我不知道它是如何发生的，但在某个时候，我发现自己通过我的小型哑调制解调器支持10+人的互联网连接，该调制解调器在负载下经常损坏。我想知道谁在什么时候连接，我也想能够不时地阻止我的一些年轻的堂兄弟，他们通过观看全高清《我的世界》视频来劫持我们所有人的带宽。我当时有一个非常简单的华硕调制解调器，看起来像一个宇宙飞船模型。这个调制解调器有一个非常简单的接口，能够做的事情很少，但它完成了工作，并允许我看到所有连接的客户端，以及阻止它们。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi lg"><img src="../Images/b7b80c47b07b2b5a50658d2da6e58a47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*MZlA2pBbYJUo9zvt.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">路由器看起来和这个一模一样，但是我不记得确切的型号名称了。</figcaption></figure><p id="1852" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">当时，就像我的大多数想法一样，我有一个永远不会变成现实的想法:如果我能获得我的调制解调器的所有连接客户端的列表，将他们的MAC地址与他们的真实身份相关联，并使用贴在墙上的旧电话在楼下的门旁边显示这个列表，我可能会允许每个回家的人检查这个屏幕，看看谁在家，他们将能够决定是否锁门。虽然这有点侵犯他们的隐私，但我更感兴趣的是它带来的技术挑战，这就是为什么我没有给他妈的，并开始建立它。</p><p id="307f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">第一个挑战是获得客户端列表，我想我可以扫描本地网络中的端口，看看谁使用nmap连接到网络，然后我会以某种方式获得关于客户端的附加信息。</p><h1 id="7c26" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">使用nmap</h1><p id="d58c" class="pw-post-body-paragraph jq jr it js b jt mg jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn im bi translated">Python通过<a class="ae le" href="https://xael.org/pages/python-nmap-en.html" rel="noopener ugc nofollow" target="_blank"> python-nmap </a>包绑定了nmap，这非常容易使用:</p><pre class="kp kq kr ks gt ml mm mn mo aw mp bi"><span id="1bc3" class="mq lj it mm b gy mr ms l mt mu">nm.scan(hosts='192.168.2.0/24', arguments='-sn')<br/>hosts_list = [(x, nm[x]['status']['state']) for x in nm.all_hosts()]<br/>for host, status in hosts_list:<br/>    print('{0}: {1}'.format(host, status))</span></pre><p id="8d0f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">通过使用这个，我希望得到一个IP列表，但是猜猜发生了什么？每次我运行脚本时，调制解调器都会死机，我不得不重启它，让它重新活过来。我尝试了许多不同的选项，但我以前没有正确使用nmap，我也不知道调制解调器有什么问题，这就是为什么我必须找到另一种解决方案。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mv"><img src="../Images/b24426f5c343368862a0b410f84dd2e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HYzNi2kwUnnP0E098PIJjQ.jpeg"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">Julia Joppien 在<a class="ae le" href="https://unsplash.com/s/photos/broken?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="8fe4" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">使用调制解调器的管理界面</h1><p id="4f40" class="pw-post-body-paragraph jq jr it js b jt mg jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn im bi translated">第二个想法是以某种方式抓取调制解调器的管理界面，因为客户端列表可以在界面的家长控制部分获得。在此之前，我检查了网络请求，发现它使用HTTP basic与后端通信，后端返回一个完整的HTML响应，其值嵌入到HTML的脚本部分。当我检查HTML主体时，我发现它包含四个主要变量，这些变量以一种奇怪的方式拥有所有必需的值:<code class="fe mw mx my mm b">leases</code>、<code class="fe mw mx my mm b">arps</code>、<code class="fe mw mx my mm b">wireless</code>和<code class="fe mw mx my mm b">ipmonitor</code>。这些值中的每一个都保存着数组的数组，简化后，它们就像这样:</p><pre class="kp kq kr ks gt ml mm mn mo aw mp bi"><span id="3eb8" class="mq lj it mm b gy mr ms l mt mu">var leases = [["40:D3:05:G7:BB:F9", "192.168.2.228"]];	// [MAC, ip]<br/>var arps = [["192.168.2.22", "40:0E:85:52:D4:43"]];	// [ip, MAC]<br/>var wireless = [["40:F3:08:F7:BB:F9", "Yes", "Yes"]];	// [MAC, assoc, auth]<br/>var ipmonitor = [["192.168.2.12", "3C:BD:D8:D7:E8:17", "3CBDD8D7E817"]]; // [IP, MAC, DeviceName]</span></pre><p id="bfef" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我对网络非常无知，因此我不知道什么是<code class="fe mw mx my mm b">leases</code>，也不知道为什么这些东西会存储在不同的变量中，比如<code class="fe mw mx my mm b">leases</code>和<code class="fe mw mx my mm b">ipmonitor</code>，每个变量都有不同的属性和细节；然而，我有预感这些就是我一直在寻找的东西。在摆弄它的时候，我注意到<code class="fe mw mx my mm b">ipmonitor</code>变量总是最大的数组，它包含了分散在其他变量中的所有项目，它似乎是关于连接设备的事实的来源。作为世界上最差的python程序员，我认为这是python的一份好工作。</p><pre class="kp kq kr ks gt ml mm mn mo aw mp bi"><span id="717b" class="mq lj it mm b gy mr ms l mt mu">def get_leases_arps_monitors(contents):<br/>    contents = contents.split('\n')<br/>    leases = []<br/>    arps = []<br/>    ip_monitors = []<br/>    wireless_devices = []</span><span id="e3af" class="mq lj it mm b gy mz ms l mt mu">    # Loop over the lines to find items.<br/>    found_count = 0<br/>    for line in contents:<br/>        if 'var leases' in line and not leases:<br/>            leases = line.split("= ", 1)[1]<br/>            leases = leases.split(";")[0]<br/>            leases = json.loads(leases)<br/>            found_count += 1<br/>        elif 'var arps' in line and not arps:<br/>            arps = line.split("= ", 1)[1]<br/>            arps = arps.split(";")[0]<br/>            arps = json.loads(arps)<br/>            found_count += 1<br/>        elif 'var ipmonitor' in line and not ip_monitors:<br/>            ip_monitors = line.split("= ", 1)[1]<br/>            ip_monitors = ip_monitors.split(";")[0]<br/>            ip_monitors = json.loads(ip_monitors)<br/>            found_count += 1<br/>        elif 'var wireless' in line and not wireless_devices:<br/>            wireless_devices = line.split("= ", 1)[1]<br/>            wireless_devices = wireless_devices.split(";")[0]<br/>            wireless_devices = json.loads(wireless_devices)</span><span id="dcc3" class="mq lj it mm b gy mz ms l mt mu">            found_count += 1</span><span id="a3ba" class="mq lj it mm b gy mz ms l mt mu">        if found_count == 4:<br/>            break</span><span id="da05" class="mq lj it mm b gy mz ms l mt mu">    return leases, arps, ip_monitors, wireless_devices</span></pre><p id="533e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一旦我得到了这些变量的值，就很容易通过遍历它们来构建一个简单的字典数组。我构建了一个简单的类来完成所有这些工作，包括获取HTML响应、解析它并构建一个已连接客户端的列表。</p><p id="a135" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">以下是完整的代码:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">检索连接到路由器的客户端列表的完整代码</figcaption></figure><p id="d51a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，我用两行代码列出了客户列表:</p><pre class="kp kq kr ks gt ml mm mn mo aw mp bi"><span id="68cc" class="mq lj it mm b gy mr ms l mt mu">asus = Asus('192.168.2.1', 'admin_username', 'admin_password')<br/>clients = asus.get_clients()</span></pre><p id="b0c9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">商品列表应该是这样的，准备好供客户消费:</p><pre class="kp kq kr ks gt ml mm mn mo aw mp bi"><span id="2b4a" class="mq lj it mm b gy mr ms l mt mu">[<br/>    {<br/>      "is_wireless": false,<br/>      "ip": "192.168.2.12",<br/>      "mac": "DB:45:D8:C3:38:14",<br/>      "name": "burak's desktop computer"<br/>    },<br/>    {<br/>      "is_wireless": true,<br/>      "ip": "192.168.2.228",<br/>      "mac": "50:33:D8:37:CC:F5",<br/>      "name": "burak's phone"<br/>    }<br/>]</span></pre><p id="3459" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">到目前为止，一切都很完美。</p><h1 id="773c" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">然后呢？</h1><p id="a689" class="pw-post-body-paragraph jq jr it js b jt mg jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn im bi translated">既然获取客户端列表的代码已经准备好了，是时候构建一个简单的前端来显示这些内容了，方法是用<code class="fe mw mx my mm b">setInterval</code>连续轮询后端，大约每5秒钟一次。在这一点上，一切都准备好了，但猜猜谁不能保持冷静，不要搞砸了？</p><p id="019e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在我的内心深处，我仍然在思考我以前遇到的nmap问题；基本上，调制解调器无法处理扫描，这让我预感到持续轮询其管理界面会消耗其资源，并使每个人的连接饱和，我不想这样。我有数据支持这种说法吗？不。我知道调制解调器是怎么工作的吗？没有。我是否做了任何概念验证来测试实际情况是否如此？当然不是。</p><p id="97a7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我坚信自己的直觉，并专注于这个不存在的、不现实的问题，我决定用<a class="ae le" href="https://openwrt.org/" rel="noopener ugc nofollow" target="_blank"> OpenWrt </a>替换调制解调器的默认固件，这将更加稳定，允许我用更少的代码获得更多的指标，并简化这里的工作。我有数据支持这种说法吗？没有。我知道调制解调器固件是如何工作的吗？没有。我是否做了任何概念验证来测试实际情况是否如此？当然不是。再一次，我只有纯粹的直觉。</p><p id="6d3a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">最后，我用一个定制的开源固件替换了我路由器的默认固件，以锁住一扇该死的旧门。</p><p id="de45" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">—在这里插入一个巨大的掌脸—</p><h1 id="b083" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">尝试升级路由器固件</h1><p id="d7b2" class="pw-post-body-paragraph jq jr it js b jt mg jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn im bi translated">我依稀记得它是如何发生的，但我记得读过路由器关于更新固件的文档，文档中有一个用粗体字写的句子，声明<strong class="js iu">如果过程不知何故失败或中途中断，设备将会死亡</strong>。我读了这份声明，并立即在我的脑海中将其标记为无关紧要，因为升级这个简单的小设备应该很快很容易。再问一次，我有任何数据来支持这种说法吗？没有。我知道升级过程是如何进行的吗？没有。我是否做了任何概念验证来测试实际情况是否如此？<strong class="js iu">当然不是。</strong></p><p id="6e01" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">猜猜发生了什么？<strong class="js iu">发生了一些事情，路由器决定在升级过程中自行重启。</strong>本质上，我用砖头砌好了我完美的路由器，用于锁住一扇生锈的旧门，即使路由器工作了，它也永远不会出现；你可以在这里插入另一个巨大的facepalm。</p><h1 id="a0d6" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">我不得不下结论</h1><p id="d237" class="pw-post-body-paragraph jq jr it js b jt mg jv jw jx mh jz ka kb mi kd ke kf mj kh ki kj mk kl km kn im bi translated">在做了所有这些工作之后，我所拥有的只是一个简单的Python脚本，这个脚本应该是针对这个已经死了的华硕路由器的。最终，在大约3个小时没有互联网连接后，我买了另一台路由器，一切又恢复了正常。因此，我有了:</p><ul class=""><li id="0dbc" class="nc nd it js b jt ju jx jy kb ne kf nf kj ng kn nh ni nj nk bi translated">一个Python脚本，用于提取连接到我的Asus路由器的客户端</li><li id="1439" class="nc nd it js b jt nl jx nm kb nn kf no kj np kn nh ni nj nk bi translated">一个死掉的华硕路由器</li><li id="4cc3" class="nc nd it js b jt nl jx nm kb nn kf no kj np kn nh ni nj nk bi translated">全新的路由器</li><li id="188c" class="nc nd it js b jt nl jx nm kb nn kf no kj np kn nh ni nj nk bi translated">一个意志消沉的CS学生(<em class="lh">提示:这就是我</em>)</li></ul><p id="bd3e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">总的来说，这是一个有趣的失败实验，花了我一个路由器，但它很有趣，这是我开始研究这个的主要原因。作为额外的代价，当我解释为什么几个小时没有网络连接时，我的家人开了我一点玩笑，但这没关系，我活该。</p><p id="2a92" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你想建造类似的东西，我建议以某种方式更换门锁，这样每个人都可以使用好的旧钥匙，而不是像我计划的那样复杂的设置；更换锁可能比购买新路由器更便宜。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nq"><img src="../Images/e011040dd8d1fc9764fee5b47caecfbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mPvy6CDDS7PzmKTUesUvkg.jpeg"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk translated">我砌好路由器后的样子，照片由<a class="ae le" href="https://unsplash.com/@charlesdeluvio?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">查尔斯</a>在<a class="ae le" href="https://unsplash.com/s/photos/animal?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure></div></div>    
</body>
</html>