<html>
<head>
<title>Redis: Introduction, Caching and Transactions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Redis:介绍、缓存和事务</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/redis-introduction-caching-and-transactions-aa32d385aa2b?source=collection_archive---------10-----------------------#2022-10-10">https://levelup.gitconnected.com/redis-introduction-caching-and-transactions-aa32d385aa2b?source=collection_archive---------10-----------------------#2022-10-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f3f1" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Redis为什么这么受欢迎？</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/dce38991d2233b778022d620721ee84a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jed-UVwaIqf16oq5f8ATDQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">Redis徽标</figcaption></figure><h1 id="f675" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">介绍</h1><p id="7a07" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">什么是<strong class="lp ir"> Redis </strong>？</p><p id="da37" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">Redis是一个开源的，<strong class="lp ir">内存数据存储</strong>，以速度极快而闻名，因为它将东西存储在内存中(即RAM中)，而不是磁盘中(例如SSD)。</p><p id="bb22" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">最初Redis被用作<strong class="lp ir">键-值数据库</strong>，但是现在它提供了<a class="ae mo" href="https://redis.io/docs/modules/" rel="noopener ugc nofollow" target="_blank">更多的特性</a>。在本文中，我将只讨论作为键值数据库的Redis，这是它最常用的方式。</p><p id="59d8" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">本文假设您对关系数据库和客户机-服务器模型有所了解。我的目的是帮助解释为什么以及如何在应用程序中使用Redis。</p><h1 id="1aaa" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">键值</h1><p id="e1d4" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">什么是<strong class="lp ir">键值数据库</strong>？</p><p id="e7d8" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">基本上就是<strong class="lp ir"> <em class="mp"> (key，value) </em> </strong> <em class="mp">对</em>的集合。这种数据结构现在更普遍地被称为<em class="mp">字典</em>或<em class="mp">散列表。</em></p><p id="d2ee" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">换句话说，这是一个结构，其中有许多对，每一对都包含:</p><ul class=""><li id="4f9d" class="mq mr iq lp b lq mj lt mk lw ms ma mt me mu mi mv mw mx my bi translated">一个<strong class="lp ir"> <em class="mp">键</em> </strong> —一个值的标识符；</li><li id="9880" class="mq mr iq lp b lq mz lt na lw nb ma nc me nd mi mv mw mx my bi translated">一个<strong class="lp ir"> <em class="mp">值</em></strong>——我们要存储的实际东西。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/f9da4d5a1cbc97d24dca8bc44c39e223.png" data-original-src="https://miro.medium.com/v2/resize:fit:1010/format:webp/1*LkiJ-b2OcK8H_CGYpJG-xg.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">来源:<a class="ae mo" href="https://www.youtube.com/watch?v=G1rOthIU-uo&amp;ab_channel=Fireship" rel="noopener ugc nofollow" target="_blank"> Fireship.io </a></figcaption></figure><p id="9024" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">假设我们在终端中打开Redis(即<a class="ae mo" href="https://redis.io/docs/manual/cli/" rel="noopener ugc nofollow" target="_blank"> Redis CLI </a>):</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="2fc5" class="nk kw iq ng b gy nl nm l nn no">&gt;</span></pre><p id="90bd" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">现在让我们通过使用<code class="fe np nq nr ng b">SET</code>命令并给出一个键名来存储值<code class="fe np nq nr ng b">1</code>，例如<code class="fe np nq nr ng b">x</code>:</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="ff72" class="nk kw iq ng b gy nl nm l nn no">&gt; SET x 1<br/>OK</span></pre><p id="d4c6" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">我们已经储存了<code class="fe np nq nr ng b">x=1</code>！让我们用<code class="fe np nq nr ng b">GET</code>命令得到这个值:</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="ea72" class="nk kw iq ng b gy nl nm l nn no">&gt; GET x<br/>“1”</span></pre><p id="bbf6" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">并删除它:</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="3da8" class="nk kw iq ng b gy nl nm l nn no">&gt; DEL x<br/>(integer) 1 // <strong class="ng ir"><em class="mp">key is deleted</em></strong></span></pre><p id="64a5" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">其实你可以把<a class="ae mo" href="https://redis.io/docs/data-types/" rel="noopener ugc nofollow" target="_blank">很多不同的数据结构</a>存储为<em class="mp">值</em> : <em class="mp"> </em>字符串、数字、哈希、JSON文档等等。</p><p id="45bc" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">有些数据结构有特定的命令，但它们非常相似:</p><ul class=""><li id="2d88" class="mq mr iq lp b lq mj lt mk lw ms ma mt me mu mi mv mw mx my bi translated"><a class="ae mo" href="https://redis.io/docs/data-types/hashes/" rel="noopener ugc nofollow" target="_blank">哈希</a> : <code class="fe np nq nr ng b">HGET</code>，<code class="fe np nq nr ng b">HSET</code> …</li><li id="3afd" class="mq mr iq lp b lq mz lt na lw nb ma nc me nd mi mv mw mx my bi translated"><a class="ae mo" href="https://redis.io/docs/stack/json/" rel="noopener ugc nofollow" target="_blank"> JSON </a> : <code class="fe np nq nr ng b">JSON.GET</code>，<code class="fe np nq nr ng b">JSON.SET</code> …</li></ul><p id="63d8" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">极其简单，对吧？您可能想知道—为什么要为这样一个简单的数据库费心呢？嗯，它的强大之处在于它解决的问题——<strong class="lp ir">缓存</strong>。</p><h1 id="2ef9" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">什么是缓存？</h1><p id="bc75" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated"><strong class="lp ir">缓存</strong>是在<strong class="lp ir">缓存中存储一些数据的过程。</strong></p><p id="8cce" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated"><strong class="lp ir">高速缓存</strong>是一种高速数据存储器，它存储一些数据，以便将来对这些数据的请求能够比访问数据的主存储位置更快地得到响应。</p><h1 id="330e" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">为什么使用缓存？</h1><h2 id="e30c" class="nk kw iq bd kx ns nt dn lb nu nv dp lf lw nw nx lh ma ny nz lj me oa ob ll oc bi translated">问题是</h2><p id="1175" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">想象一下，一个人访问了埃隆·马斯克的Twitter页面。客户机向服务器请求数据，服务器查询数据库。</p><p id="573e" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">这是它工作的基本方式:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi od"><img src="../Images/2d7cdbd6398fc72e739488fbf2dc8980.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DPzgXsbQS1qBO4c3nLHH4w.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">基本客户端-服务器请求流</figcaption></figure><p id="9cac" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">然而，有一个问题——埃隆·马斯克非常受欢迎，因此每分钟都有数百万次请求获取该页面。使用上面的解决方案，服务器会因请求而过载，查询数据库会花费很长时间。而且，这要花很多钱。这是因为请求:</p><ul class=""><li id="a9d1" class="mq mr iq lp b lq mj lt mk lw ms ma mt me mu mi mv mw mx my bi translated">调用数据库(这本身就很昂贵)；</li><li id="4d60" class="mq mr iq lp b lq mz lt na lw nb ma nc me nd mi mv mw mx my bi translated">需要高成本的SQL操作(如JOIN)，这需要大量的计算时间；</li><li id="069a" class="mq mr iq lp b lq mz lt na lw nb ma nc me nd mi mv mw mx my bi translated">从磁盘获取数据，读取速度很慢。</li></ul><h2 id="635e" class="nk kw iq bd kx ns nt dn lb nu nv dp lf lw nw nx lh ma ny nz lj me oa ob ll oc bi translated">解决方案</h2><p id="5289" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">相反，我们可以使用Redis并将这些数据存储在一个键中，例如<code class="fe np nq nr ng b">page:elon-musk</code>，所以:</p><ul class=""><li id="c04b" class="mq mr iq lp b lq mj lt mk lw ms ma mt me mu mi mv mw mx my bi translated">我们不需要进行数据库调用；</li><li id="443e" class="mq mr iq lp b lq mz lt na lw nb ma nc me nd mi mv mw mx my bi translated">这些数据将存储在内存中，因此服务速度会更快！</li></ul><p id="1e0d" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">这意味着我们使用Redis作为缓存:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oe"><img src="../Images/085d358ad78bc46b85f09e5cef077257.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dhIaHL0whNnqE8fAp9mB7w.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">从Redis缓存提供的请求</figcaption></figure><p id="d834" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">请注意密钥格式— <code class="fe np nq nr ng b">page:elon-musk</code>。我使用两个值来创建一个<strong class="lp ir">组合键</strong>。这意味着我们基本上可以模拟一个关系数据库，其中<code class="fe np nq nr ng b">page</code>是一个表名，<code class="fe np nq nr ng b">elon-musk</code>是一个主键值:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/3aa49e9f869d4dcdea7412fb318a9020.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WLCG54SrPo6NWQn-ooFupg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">关系数据库模拟</figcaption></figure><p id="9270" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">但是如果主数据库中的数据更新了呢？例如，埃隆·马斯克(Elon Musk)发了一篇新帖子或改变了他的描述。我们不可能永远在Redis中保持相同的值！我们需要以某种方式<em class="mp">使缓存</em>无效。</p><h2 id="be84" class="nk kw iq bd kx ns nt dn lb nu nv dp lf lw nw nx lh ma ny nz lj me oa ob ll oc bi translated">缓存失效</h2><p id="f65d" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated"><strong class="lp ir">缓存失效</strong>意味着声明一个<strong class="lp ir">缓存值无效</strong>。我们可以在应用中实施几种缓存失效策略。例如，我们可以用两种方法<strong class="lp ir">删除</strong>键:</p><ol class=""><li id="c870" class="mq mr iq lp b lq mj lt mk lw ms ma mt me mu mi og mw mx my bi translated">按需删除<code class="fe np nq nr ng b">page:elon-musk</code>键(即当埃隆做出改变时)，或</li><li id="550c" class="mq mr iq lp b lq mz lt na lw nb ma nc me nd mi og mw mx my bi translated">使用<code class="fe np nq nr ng b"><a class="ae mo" href="https://redis.io/commands/setex/" rel="noopener ugc nofollow" target="_blank">SETEX</a></code>设置密钥的到期时间。然后，该密钥将在指定的时间后自动删除:</li></ol><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="3c54" class="nk kw iq ng b gy nl nm l nn no">&gt; SETEX x 30 "Hello"<br/>OK // <strong class="ng ir"><em class="mp">key is set with 30 seconds expiration time</em></strong></span></pre><blockquote class="oh oi oj"><p id="5cae" class="ln lo mp lp b lq mj jr ls lt mk ju lv ok ml ly lz ol mm mc md om mn mg mh mi ij bi translated">注:与同时使用<code class="fe np nq nr ng b"><em class="iq">SET</em></code>和<code class="fe np nq nr ng b"><em class="iq">EXPIRE</em></code>命令相同。</p></blockquote><p id="58fb" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">最后，当有人请求Elon的页面(现在已经失效)时，我们可以指示:</p><ul class=""><li id="bfb1" class="mq mr iq lp b lq mj lt mk lw ms ma mt me mu mi mv mw mx my bi translated">检查密钥是否存在</li><li id="07b7" class="mq mr iq lp b lq mz lt na lw nb ma nc me nd mi mv mw mx my bi translated">如果不是-从数据库中获取更新的值，并再次将其放入缓存中。</li></ul><h2 id="42e4" class="nk kw iq bd kx ns nt dn lb nu nv dp lf lw nw nx lh ma ny nz lj me oa ob ll oc bi translated">持久性</h2><p id="3353" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">在幕后，Redis不时地将数据从RAM复制到更持久的存储设备(如SSD ),因此即使在服务器停机时，数据也是持久的。点击阅读更多<a class="ae mo" href="https://redis.io/docs/manual/persistence/" rel="noopener ugc nofollow" target="_blank">。</a></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi on"><img src="../Images/6a79836371533e34127952fca9e1d330.png" data-original-src="https://miro.medium.com/v2/resize:fit:1324/format:webp/1*e75i4F3APbqBY9ZYlToHQg.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">Redis将数据从RAM复制到磁盘</figcaption></figure><h2 id="2049" class="nk kw iq bd kx ns nt dn lb nu nv dp lf lw nw nx lh ma ny nz lj me oa ob ll oc bi translated">其他使用案例</h2><p id="b38b" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">除了缓存，Redis还有许多其他的用例，例如:</p><ul class=""><li id="f04f" class="mq mr iq lp b lq mj lt mk lw ms ma mt me mu mi mv mw mx my bi translated"><a class="ae mo" href="https://redis.com/solutions/use-cases/messaging/" rel="noopener ugc nofollow" target="_blank">消息队列</a></li><li id="0c8c" class="mq mr iq lp b lq mz lt na lw nb ma nc me nd mi mv mw mx my bi translated"><a class="ae mo" href="https://redis.com/solutions/use-cases/session-management/" rel="noopener ugc nofollow" target="_blank">会话管理</a></li><li id="b084" class="mq mr iq lp b lq mz lt na lw nb ma nc me nd mi mv mw mx my bi translated"><a class="ae mo" href="https://redis.com/docs/real-time-analytics-redis/" rel="noopener ugc nofollow" target="_blank">实时分析</a></li></ul><h1 id="864e" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">Redis中的交易</h1><p id="e8eb" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated"><a class="ae mo" href="https://redis.io/docs/manual/transactions/" rel="noopener ugc nofollow" target="_blank"> <strong class="lp ir">事务</strong> </a>对于任何想要保持数据一致性的数据库都很重要。它们保证一组操作将在没有其他操作干扰的情况下执行<strong class="lp ir">，或者根本不执行。幸运的是，Redis也给了我们实现事务的工具，尽管它们不是默认的<a class="ae mo" href="https://www.databricks.com/glossary/acid-transactions" rel="noopener ugc nofollow" target="_blank"><strong class="lp ir"/></a>。然而，我会告诉你如何实现一些酸的属性。</strong></p><p id="6499" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">执行事务有两个主要命令:</p><ul class=""><li id="f3e6" class="mq mr iq lp b lq mj lt mk lw ms ma mt me mu mi mv mw mx my bi translated"><code class="fe np nq nr ng b">MULTI</code>标记一个事务块的<strong class="lp ir">开始</strong>(它之后的所有命令排队等待执行)；</li><li id="50db" class="mq mr iq lp b lq mz lt na lw nb ma nc me nd mi mv mw mx my bi translated"><code class="fe np nq nr ng b">EXEC</code> <strong class="lp ir">执行</strong>事务块。</li></ul><p id="bf49" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">让我们也使用一个假想的JavaScript库，它有一个<code class="fe np nq nr ng b">send</code>函数用于向Redis发送命令，在这里我们可以提供一个字符串或多个字符串和值的命令:</p><ul class=""><li id="ae64" class="mq mr iq lp b lq mj lt mk lw ms ma mt me mu mi mv mw mx my bi translated"><code class="fe np nq nr ng b">send('SET x 2')</code></li><li id="08fa" class="mq mr iq lp b lq mz lt na lw nb ma nc me nd mi mv mw mx my bi translated"><code class="fe np nq nr ng b">send('SET x', 2)</code> —这将使我们更容易提供变量。</li></ul><p id="8bef" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">在下面的例子中，我将使用<a class="ae mo" href="https://redis.io/docs/stack/json/" rel="noopener ugc nofollow" target="_blank"> RedisJSON </a>模块来启用JSON操作(<code class="fe np nq nr ng b">JSON.GET</code>、<code class="fe np nq nr ng b">JSON.SET</code>等)。).</p><h2 id="0070" class="nk kw iq bd kx ns nt dn lb nu nv dp lf lw nw nx lh ma ny nz lj me oa ob ll oc bi translated">不正确的例子</h2><p id="63de" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">假设比尔·盖茨想<strong class="lp ir">往埃隆·马斯克的钱包里送10美元</strong>。他们的钱包作为主数据库存储在Redis上，他们有一个<code class="fe np nq nr ng b">amount</code>属性。让我们试着简单地编写这个场景:</p><ol class=""><li id="d1b4" class="mq mr iq lp b lq mj lt mk lw ms ma mt me mu mi og mw mx my bi translated">我们<strong class="lp ir">读取</strong>钱包金额；</li><li id="7843" class="mq mr iq lp b lq mz lt na lw nb ma nc me nd mi og mw mx my bi translated"><strong class="lp ir">更新</strong>吧；</li><li id="f109" class="mq mr iq lp b lq mz lt na lw nb ma nc me nd mi og mw mx my bi translated">最后，<strong class="lp ir">写下</strong>它:</li></ol><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oo op l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">不正确的例子</figcaption></figure><p id="5a25" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">但是如果在执行交易块的过程中，别人转了100美元给埃隆马斯克呢？我们会用我们的值(20美元)覆盖数据(<code class="fe np nq nr ng b">JSON.SET</code>)并失去他的100美元！</p><p id="f204" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">换句话说，这个交易不是孤立的。<strong class="lp ir">隔离</strong>是指<strong class="lp ir">没有两个事务相互混合或干扰</strong>。我们如何解决这个问题？</p><h2 id="d226" class="nk kw iq bd kx ns nt dn lb nu nv dp lf lw nw nx lh ma ny nz lj me oa ob ll oc bi translated">正确的例子</h2><p id="5023" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">Redis使用<a class="ae mo" href="https://www.geeksforgeeks.org/difference-between-pessimistic-approach-and-optimistic-approach-in-dbms/" rel="noopener ugc nofollow" target="_blank"> <strong class="lp ir"> <em class="mp">乐观并发控制</em> </strong> </a>(又名<em class="mp">乐观锁定</em>)来实现隔离。这意味着事务不需要锁定它正在使用的值——它希望这些值不会被外部操作修改，但是如果它们被修改了——事务将被取消。</p><p id="813c" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">为了将这个策略付诸实施，我们将使用<code class="fe np nq nr ng b">WATCH</code>，它指示Redis:</p><ul class=""><li id="a823" class="mq mr iq lp b lq mj lt mk lw ms ma mt me mu mi mv mw mx my bi translated">“看着”钥匙，和</li><li id="028c" class="mq mr iq lp b lq mz lt na lw nb ma nc me nd mi mv mw mx my bi translated">如果自<code class="fe np nq nr ng b">WATCH</code>被调用后，键被一些不相关的操作修改，自动<strong class="lp ir">取消交易</strong>。</li></ul><p id="c5aa" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated"><code class="fe np nq nr ng b">WATCH</code>用法很简单:</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="198a" class="nk kw iq ng b gy nl nm l nn no">WATCH wallet:elon-musk</span></pre><p id="c2c0" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">让我们在代码中应用它:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oo op l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">正确的例子</figcaption></figure><p id="e528" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">此外，我们不需要在事务结束后执行<code class="fe np nq nr ng b">UNWATCH</code>(即告诉Redis刷新所有被监视的键)— <code class="fe np nq nr ng b">EXEC</code>和<code class="fe np nq nr ng b">DISCARD</code>会自动为我们完成这项工作。</p><p id="1c3b" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">然而，有一个问题。<strong class="lp ir">我们</strong> <code class="fe np nq nr ng b"><strong class="lp ir">WATCH</strong></code> <strong class="lp ir">的钥匙越多，我们的交易被取消的几率就越大。在大量请求更新相同数据的系统中(如社交媒体)，这种机会可能相当大，所以我们希望尽可能避免取消。因为如果10个不同的事务尝试更新同一个密钥，其中的9个将被取消，我们将不得不重试，但第二次会有8个失败，以此类推。</strong></p><p id="ff56" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">好吧，所以我们应该少用<code class="fe np nq nr ng b">WATCH</code>。我们可以通过优化这段代码来避免任何<code class="fe np nq nr ng b">WATCH</code>吗？是啊！</p><h2 id="3447" class="nk kw iq bd kx ns nt dn lb nu nv dp lf lw nw nx lh ma ny nz lj me oa ob ll oc bi translated">优化的示例</h2><p id="35a9" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">我们只验证Bill的金额(它是否有足够的资金)，而不是Elon的— Elon只需要他的钱包金额增加，而无需任何验证。因此我们不需要埃隆的数据——我们可以直接增加埃隆的数量。</p><p id="f6e6" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">然而，要移除<code class="fe np nq nr ng b">WATCH</code>，我们需要确保在我们增加Elon钱包金额的同时，不会有任何其他操作改变它。如果我们简单地移除<code class="fe np nq nr ng b">WATCH</code>并继续使用几个操作(1。<strong class="lp ir">阅读</strong> 2。<strong class="lp ir">增加代码3中的</strong>数量。<strong class="lp ir">写</strong>。然而，如果我们只使用一个，我们可以实现它！</p><blockquote class="oh oi oj"><p id="8f96" class="ln lo mp lp b lq mj jr ls lt mk ju lv ok ml ly lz ol mm mc md om mn mg mh mi ij bi translated">Redis是单线程的，并且保证单个操作是原子的。这意味着当一个命令正在执行时，其他命令不会运行。"</p></blockquote><p id="61b8" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">Redis为我们提供了直接在数据库中增加JSON值的<code class="fe np nq nr ng b"><a class="ae mo" href="https://redis.io/commands/json.numincrby/" rel="noopener ugc nofollow" target="_blank">JSON.NUMINCRBY</a></code>。它递增(或递减，如果值为负)指定的值:</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="5215" class="nk kw iq ng b gy nl nm l nn no">send('JSON.NUMINCRBY wallet:elon-musk $.amount 10')</span></pre><p id="e8bf" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">下面是我们如何应用它:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oo op l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">优化示例</figcaption></figure><p id="c96e" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">太好了！现在，我们有了一个隔离和优化的交易。</p><h1 id="c946" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">几个Redis命令</h1><p id="1b23" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">这里还有几个命令，因此您可以更好地了解Redis。</p><p id="b7c2" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated"><strong class="lp ir">过期(设置按键超时)</strong></p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="fb2a" class="nk kw iq ng b gy nl nm l nn no">&gt; EXPIRE x 20<br/>(integer) 20 // <strong class="ng ir"><em class="mp">20 seconds left to timeout</em></strong></span></pre><p id="074e" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated"><strong class="lp ir"> TTL(超时键剩余的总时间)</strong></p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="2d0f" class="nk kw iq ng b gy nl nm l nn no">&gt; TTL x<br/>(integer) 10 // <strong class="ng ir"><em class="mp">10 seconds left to timeout</em></strong></span></pre><p id="c817" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated"><strong class="lp ir">持续(从键中删除超时)</strong></p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="45b0" class="nk kw iq ng b gy nl nm l nn no">&gt; PERSIST x<br/>(integer) 1 <strong class="ng ir"><em class="mp">// key won't expire</em></strong></span></pre><p id="3cf2" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated"><strong class="lp ir">重命名(重命名当前已有的键)</strong></p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="c967" class="nk kw iq ng b gy nl nm l nn no">&gt; RENAME x y<br/>OK // <strong class="ng ir"><em class="mp">renamed the key 'x' as 'y'</em></strong></span></pre><p id="7388" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated"><strong class="lp ir"> FLUSHALL(删除目前保存的所有密钥)</strong></p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="bb62" class="nk kw iq ng b gy nl nm l nn no">&gt; flushall<br/>OK // <strong class="ng ir"><em class="mp">all keys are deleted</em></strong></span></pre></div><div class="ab cl oq or hu os" role="separator"><span class="ot bw bk ou ov ow"/><span class="ot bw bk ou ov ow"/><span class="ot bw bk ou ov"/></div><div class="ij ik il im in"><h1 id="189e" class="kv kw iq bd kx ky ox la lb lc oy le lf jw oz jx lh jz pa ka lj kc pb kd ll lm bi translated">摘要</h1><p id="a0c8" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">那么我们为什么要使用Redis呢？</p><ol class=""><li id="1d22" class="mq mr iq lp b lq mj lt mk lw ms ma mt me mu mi og mw mx my bi translated">它非常<strong class="lp ir">快</strong>；</li><li id="ee4e" class="mq mr iq lp b lq mz lt na lw nb ma nc me nd mi og mw mx my bi translated">对数据的生命周期给予很大的控制；</li><li id="aa2d" class="mq mr iq lp b lq mz lt na lw nb ma nc me nd mi og mw mx my bi translated">它在大多数语言中都支持<strong class="lp ir"/>(见<a class="ae mo" href="https://redis.io/docs/libraries/" rel="noopener ugc nofollow" target="_blank">此处</a>)；</li><li id="dc79" class="mq mr iq lp b lq mz lt na lw nb ma nc me nd mi og mw mx my bi translated">Redis是<strong class="lp ir">开源</strong>；</li><li id="faa6" class="mq mr iq lp b lq mz lt na lw nb ma nc me nd mi og mw mx my bi translated">有很多模块用于不同的用例，我在这篇文章中没有详细介绍；</li><li id="f428" class="mq mr iq lp b lq mz lt na lw nb ma nc me nd mi og mw mx my bi translated">支持<strong class="lp ir">交易</strong>。</li></ol><p id="992e" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">我希望你在这篇文章中学到了新的东西！</p><p id="888e" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">欢迎在<a class="ae mo" href="https://www.linkedin.com/in/ignas-pangonis/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>、<a class="ae mo" href="https://github.com/ignaspangonis" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上与我联系。</p><h1 id="ac01" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">参考</h1><div class="pc pd gp gr pe pf"><a href="https://redis.io/docs/" rel="noopener  ugc nofollow" target="_blank"><div class="pg ab fo"><div class="ph ab pi cl cj pj"><h2 class="bd ir gy z fp pk fr fs pl fu fw ip bi translated">证明文件</h2><div class="pm l"><h3 class="bd b gy z fp pk fr fs pl fu fw dk translated">欢迎阅读Redis文档。Redis简介了解Redis开源项目入门…</h3></div><div class="pn l"><p class="bd b dl z fp pk fr fs pl fu fw dk translated">redis.io</p></div></div></div></a></div><div class="pc pd gp gr pe pf"><a href="https://www.ibm.com/docs/en/rational-clearquest/7.1.0?topic=clearquest-optimistic-pessimistic-record-locking" rel="noopener  ugc nofollow" target="_blank"><div class="pg ab fo"><div class="ph ab pi cl cj pj"><h2 class="bd ir gy z fp pk fr fs pl fu fw ip bi translated">乐观和悲观记录锁定</h2><div class="pm l"><h3 class="bd b gy z fp pk fr fs pl fu fw dk translated">Rational ClearQuest中乐观和悲观锁定实现的概述。</h3></div><div class="pn l"><p class="bd b dl z fp pk fr fs pl fu fw dk translated">www.ibm.com</p></div></div></div></a></div><div class="pc pd gp gr pe pf"><a href="https://redis.com/solutions/use-cases/caching/" rel="noopener  ugc nofollow" target="_blank"><div class="pg ab fo"><div class="ph ab pi cl cj pj"><h2 class="bd ir gy z fp pk fr fs pl fu fw ip bi translated">Redis缓存:内存缓存解决方案| Redis Enterprise</h2><div class="pm l"><h3 class="bd b gy z fp pk fr fs pl fu fw dk translated">基本缓存层满足临时存储数据的最低要求，以便重复的数据库请求可以…</h3></div><div class="pn l"><p class="bd b dl z fp pk fr fs pl fu fw dk translated">redis.com</p></div></div><div class="po l"><div class="pp l pq pr ps po pt kp pf"/></div></div></a></div><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pu op l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk translated">火船. io</figcaption></figure></div></div>    
</body>
</html>