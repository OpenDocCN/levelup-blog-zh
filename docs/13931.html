<html>
<head>
<title>Understand and Implement Long-Polling and Short Polling in Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解并实现Node.js中的长轮询和短轮询</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/understand-and-implement-long-polling-and-short-polling-in-node-js-94334d2233f3?source=collection_archive---------1-----------------------#2022-10-18">https://levelup.gitconnected.com/understand-and-implement-long-polling-and-short-polling-in-node-js-94334d2233f3?source=collection_archive---------1-----------------------#2022-10-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="ae66" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">HTTP轮询是一种我们可以用来构建实时应用程序的技术。在本文中，您将了解什么是短轮询和长轮询。我们还想用Node.js实现一些例子。</p><h1 id="ee0a" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">什么是短轮询？</h1><p id="6eaf" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">在短轮询中，客户端<em class="lo">向服务器发送常规请求</em>。如果服务器有新的信息，它会将它发送回客户端，否则它会发送一个空响应。</p><p id="4bb2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">客户端发送请求的时间取决于业务类型。</p><p id="7a2e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这段时间越短，服务器上的压力就越大。</p><h1 id="6181" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">短轮询的用例有哪些？</h1><p id="92bc" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">如果您需要的更新频率不短(超过几秒和几分钟)，您可以使用短轮询来更新您的客户端(目前没有这方面的标准)。一个很好的例子是发送关于客户端环境温度的更新。温度不是我们每秒更新的东西，也许我们可以从服务器每1或2分钟更新一次。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi lp"><img src="../Images/bad96badaf3e0715f31f705fb77d6efa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TpQPuXWFq2IPIJU3eX3neg.png"/></div></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated">短轮询图</figcaption></figure><p id="181c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们用短轮询实现一个短天气API。</p><h1 id="cd46" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">短轮询示例</h1><p id="ca61" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">这是一个简单的快速应用程序，用于实时获取天气数据。</p><p id="4bde" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们需要两条路线来实现最新的天气状态:</p><ul class=""><li id="6a14" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mk ml mm mn bi translated"><em class="lo"> /weather/ </em>:第一次获取天气数据</li><li id="b835" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated"><em class="lo"> /weather/update </em>:用于获取天气数据的更新。</li></ul><p id="4388" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在第一个路径中，我们返回一个数组:</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated">第一时间获取天气数据</figcaption></figure><p id="370d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了获得天气变化，我们将生成这些随机数中的一个:-1，0，1，表示城市温度的变化:</p><pre class="lq lr ls lt gt mv mw mx my aw mz bi"><span id="4327" class="na km iq mw b gy nb nc l nd ne">Math.ceil(Math.random()*3 - 2) // A random number: -1, 0, +1</span></pre><p id="e4f5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了模拟温度的变化，我们可以使用这样一个函数:</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated">天气变化发生器</figcaption></figure><p id="4dff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果温度变化不为0，我们只给对象添加一个键值。(不向客户端发送不需要的数据)</p><p id="ed87" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，我们必须定期调用这个函数，以每分钟改变它。(想象一下，在真实情况下，我们向第三方发送请求，第三方从世界各地获取传感器数据，并每分钟更新数据)</p><p id="aacc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个函数中我们应该做的是</p><ul class=""><li id="80a7" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mk ml mm mn bi translated">如果一个城市的温度没有变化，我们需要从<code class="fe nf ng nh mw b">changes</code>对象中删除这个城市</li><li id="8f09" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">如果有变化，我们需要将它添加到<code class="fe nf ng nh mw b">changes</code>对象中，并更新保存所有数据的原始对象<code class="fe nf ng nh mw b">weathers</code>。</li></ul><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated">获取天气更新</figcaption></figure><p id="4e96" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们一起检查我通过向这些路由发送请求获得的数据:</p><ul class=""><li id="e21c" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mk ml mm mn bi translated">第一次获取天气数据:我们可以看到所有的城市都在这个响应中。</li><li id="0bd2" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">获得更新:没有变化，所以我们收到:<code class="fe nf ng nh mw b">{"changes": {}}</code></li><li id="22fc" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">得到最新消息:只有巴黎的天气变了。</li><li id="e422" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">更新:仍然只有巴黎变了(你可能会问为什么我们又有了同样的变化？因为我们发送请求太快，如果数据每分钟都在更新，我们每秒发送一个请求，那么我们会得到59次相同的更改，直到更改被更新)</li><li id="0b85" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">更新一下:只有柏林变了。</li><li id="cb43" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated">获得最新消息:所有四个城市的温度都有变化。</li></ul><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi ni"><img src="../Images/abfdb454c17c19e8e9a83623d35643ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jYE1yCVGDlIvPsiDto7ZPg.png"/></div></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated">获取天气数据的示例</figcaption></figure><p id="01c7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是一个超级简单的短轮询应用程序的实现。</p><h2 id="45e1" class="na km iq bd kn nj nk dn kr nl nm dp kv jy nn no kz kc np nq ld kg nr ns lh nt bi translated">短轮询有什么问题？</h2><p id="7595" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">通常，当<strong class="jp ir"> <em class="lo">可接受的延迟较低</em> </strong>时，轮询频率会对服务器、网络或两者造成不可接受的负担。例如，在线游戏和资本市场中的高频交易是我们需要在短时间内更新状态的两个很好的例子(对于一些在线游戏，甚至100毫秒的延迟也被认为是不可接受的)。此外，短轮询和长轮询之间还有一些共同的问题，您可以在本文的最后一部分查看:</p><ul class=""><li id="73a8" class="mf mg iq jp b jq jr ju jv jy mh kc mi kg mj kk mk ml mm mn bi translated"><strong class="jp ir">割台开销</strong></li><li id="ac5d" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated"><strong class="jp ir">连接建立</strong></li><li id="a7ae" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated"><strong class="jp ir">缓存</strong></li></ul><p id="8a52" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">整个短轮询示例</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated">简短轮询示例(完整)</figcaption></figure><p id="97bf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们进入长期投票。问题是:我们想要同样的天气应用程序，而用户想要每100毫秒更新一次。我们没有足够的资源来处理大量的请求。例如，如果我们有1000个活跃用户查看我们的天气页面，那么我们需要每秒处理10，000个请求。因此，在增加资源之前，我们想尝试的第一件事是使用<strong class="jp ir"> HTTP长轮询</strong>，看看它是否能减少负载。</p></div><div class="ab cl nu nv hu nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="ij ik il im in"><h1 id="ce02" class="kl km iq bd kn ko ob kq kr ks oc ku kv kw od ky kz la oe lc ld le of lg lh li bi translated">什么是长轮询？</h1><p id="fd2e" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">在HTTP长轮询中，服务器让您保持一个开放的TCP连接，然后您可能会收到来自已更改内容的响应，或者您的请求可能会在一段时间后超时，在这两种情况下，您都必须<strong class="jp ir">重新建立</strong>另一个连接。换句话说，客户端总是与服务器保持实时连接。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi ni"><img src="../Images/b1d1309cc16c04e1ee818c8298ff9c86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*upv4jqCsozxw6Yls1_7aww.png"/></div></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated">长轮询图</figcaption></figure><h2 id="ad94" class="na km iq bd kn nj nk dn kr nl nm dp kv jy nn no kz kc np nq ld kg nr ns lh nt bi translated">这样设计的原因是什么？</h2><ul class=""><li id="5897" class="mf mg iq jp b jq lj ju lk jy og kc oh kg oi kk mk ml mm mn bi translated"><strong class="jp ir">最小化服务器-客户端消息的延迟</strong>:您有一个到数据库的开放连接，这样您就可以在它改变后立即获得新的状态。</li><li id="cb76" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated"><strong class="jp ir">最小化使用处理/网络资源</strong>:当没有变化时，我们不发送检查状态的请求。</li></ul><h1 id="7b12" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">长轮询示例</h1><p id="8417" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">我们想把我们的短轮询实现变成长轮询实现。</p><p id="4a9a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">唯一的区别是，当没有变化时，我们不需要在<code class="fe nf ng nh mw b">update</code>路由中发送响应。我们需要倾听变化，当天气温度发生变化时，我们应该将更新的数据发送给用户。为了实现这一点，我们使用了事件发射器:</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated">实现长轮询的简单事件发射器</figcaption></figure><p id="8ed5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，每当我们发出一个事件<code class="fe nf ng nh mw b">new_change</code>时，我们的端点就会发送所有的响应。如果你想了解更多关于事件发射器的信息，你可以查看<a class="ae oj" href="https://javascript.plainenglish.io/how-we-can-use-node-js-event-emitter-5c9e39c38749" rel="noopener ugc nofollow" target="_blank">这篇文章</a>。</p><p id="af53" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们将它集成到我们的应用程序中:</p><p id="f7c6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第一步，我们需要创建我们的事件发射器:</p><pre class="lq lr ls lt gt mv mw mx my aw mz bi"><span id="651a" class="na km iq mw b gy nb nc l nd ne">const weatherChange = new Event()</span></pre><p id="45cb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在第二步中，我们需要在函数检测到变化时发出一个事件，因此我们需要检查<code class="fe nf ng nh mw b">changes</code>对象是否为空。</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated">当changes对象不为空时发出事件</figcaption></figure><p id="3fda" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们将更新路线改为:</p><p id="c722" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过添加一个侦听器，我们只在发生变化时发送响应。还要小心监听器，因为如果不删除它，会导致内存泄漏(监听器函数仍然希望返回对前一个请求的响应)。</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated">获取天气变化的长轮询路线</figcaption></figure><p id="1a17" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看看轮询工作了多长时间。每当我们得到响应时，我将发送另一个请求:</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi ok"><img src="../Images/aabe603ad72f426b197a09c2ae7c005f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*4hL_pdZPBGB89F5TG3QMRA.gif"/></div></div><figcaption class="mb mc gj gh gi md me bd b be z dk translated">运行中的长轮询示例</figcaption></figure><h2 id="22e0" class="na km iq bd kn nj nk dn kr nl nm dp kv jy nn no kz kc np nq ld kg nr ns lh nt bi translated">长轮询设计有哪些问题？</h2><ul class=""><li id="1fe1" class="mf mg iq jp b jq lj ju lk jy og kc oh kg oi kk mk ml mm mn bi translated"><strong class="jp ir">报头开销</strong>:每个轮询响应都是一个完整的HTTP消息，因此<br/>在消息帧中包含了完整的HTTP报头集。<em class="lo">(短轮询设计也存在这个问题)</em></li><li id="1fb8" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated"><strong class="jp ir">最大延迟</strong>:在收到每个响应后，<br/>服务器需要等待下一个长轮询请求，然后才能向客户端发送另一个<br/>消息</li><li id="8c34" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated"><strong class="jp ir">连接建立</strong>:在Http轮询中，你需要频繁打开TCP/IP连接，这是有代价的。<br/>连接，然后关闭它们。<em class="lo">(短轮询设计也存在这个问题)</em></li><li id="9442" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated"><strong class="jp ir">超时</strong>:Firefox的默认超时值是<a class="ae oj" href="https://digitash.com/learntips/topic/how-to-change-firefox-network-connection-timeout-settings/" rel="noopener ugc nofollow" target="_blank"> 90秒</a>，chrome是<a class="ae oj" href="https://source.chromium.org/chromium/chromium/src/+/main:net/socket/client_socket_pool.cc;l=25" rel="noopener ugc nofollow" target="_blank"> 300秒</a>，但是大多数网络基础设施包括<br/>代理和服务器，它们的超时时间并不长，所以你的请求可能会比这个时间更早超时。</li><li id="e172" class="mf mg iq jp b jq mo ju mp jy mq kc mr kg ms kk mk ml mm mn bi translated"><strong class="jp ir">缓存</strong>:由中间实体实现的缓存机制会干扰长轮询请求。终端客户端或主机无法向HTTP中介发出信号通知长轮询正在使用中；作为一个最佳实践，在一个长轮询请求或响应中总是有意禁用缓存。例如，这可以通过将“高速缓存控制”报头设置为“无高速缓存”来实现。<em class="lo">(短轮询设计也存在问题)</em></li></ul><h1 id="c436" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">结论</h1><p id="6ae3" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">在我看来，人们可以实现的最简单的实时实现是使用短轮询设计。在下一步中，根据业务情况，您可以尝试长时间轮询来减轻压力。最终，从长远来看，使用Web Sockets等其他解决方案来扩展您的实时应用程序更有意义。</p><div class="ol om gp gr on oo"><a href="https://www.rfc-editor.org/rfc/rfc6202" rel="noopener  ugc nofollow" target="_blank"><div class="op ab fo"><div class="oq ab or cl cj os"><h2 class="bd ir gy z fp ot fr fs ou fu fw ip bi translated">RFC 6202:使用长轮询和流式传输的已知问题和最佳实践…</h2><div class="ov l"><h3 class="bd b gy z fp ot fr fs ou fu fw dk translated">信息互联网工程任务组(IETF) S. Loreto征求意见:6202爱立信类别…</h3></div><div class="ow l"><p class="bd b dl z fp ot fr fs ou fu fw dk translated">www.rfc-editor.org</p></div></div></div></a></div><div class="ol om gp gr on oo"><a href="https://www.informatica.com/services-and-training/glossary-of-terms/low-latency-definition.html" rel="noopener  ugc nofollow" target="_blank"><div class="op ab fo"><div class="oq ab or cl cj os"><h2 class="bd ir gy z fp ot fr fs ou fu fw ip bi translated">低延迟:它是什么，意义和定义</h2><div class="ov l"><h3 class="bd b gy z fp ot fr fs ou fu fw dk translated">了解有关低延迟的更多信息，包括哪里需要低延迟，以及如何在金融交易等行业中使用低延迟。</h3></div><div class="ow l"><p class="bd b dl z fp ot fr fs ou fu fw dk translated">www.informatica.com</p></div></div><div class="ox l"><div class="oy l oz pa pb ox pc lz oo"/></div></div></a></div><div class="ol om gp gr on oo"><a href="https://www.esparkinfo.com/blog/node-js-long-polling.html" rel="noopener  ugc nofollow" target="_blank"><div class="op ab fo"><div class="oq ab or cl cj os"><h2 class="bd ir gy z fp ot fr fs ou fu fw ip bi translated">Node.js框架中长轮询的综合指南</h2><div class="ov l"><h3 class="bd b gy z fp ot fr fs ou fu fw dk translated">根据最新的网络技术，有一个稳定的信息传输从一端到另一端，没有任何…</h3></div><div class="ow l"><p class="bd b dl z fp ot fr fs ou fu fw dk translated">www.esparkinfo.com</p></div></div><div class="ox l"><div class="pd l oz pa pb ox pc lz oo"/></div></div></a></div></div></div>    
</body>
</html>