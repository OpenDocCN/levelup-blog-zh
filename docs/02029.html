<html>
<head>
<title>What is really so special about JavaScript Closures?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript闭包到底有什么特别之处？</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/what-is-really-so-special-about-javascript-closures-5701f8e4229f?source=collection_archive---------5-----------------------#2020-02-13">https://levelup.gitconnected.com/what-is-really-so-special-about-javascript-closures-5701f8e4229f?source=collection_archive---------5-----------------------#2020-02-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/49e412f80563ad5df944d9642cd15206.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/0*n6pke36dvxSHV7RW.png"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk translated"><em class="jy">原载于</em><a class="ae jz" href="https://edward-huang.com/tech/javascript/closure/functional-programming/programming/2020/02/13/what-is-really-so-special-about-javascript-closure/" rel="noopener ugc nofollow" target="_blank"><em class="jy">https://edward-huang.com</em></a></figcaption></figure><p id="deb5" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated">"你能给我解释一下什么是结束吗？"</p><p id="cebe" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated">如果你是全栈、前端、后端或者用JavaScript做任何事情的人，你可能听说过术语闭包。如果你正在面试一个软件工程师的角色，你可能会遇到一个问题，要求你解释什么是闭包。</p><p id="9127" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated">上述问题很容易回答——只要记住闭包的定义并给出几个例子。</p><p id="696b" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated">这个术语的问题不在于理解闭包的定义，而是理解为什么您可能想要在您的项目中使用它。</p><p id="7259" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated">在我们深入探讨JavaScript中闭包有多坚固之前，让我们先了解一下什么是闭包。</p><p id="d5c5" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated">闭包是一个可以访问它所定义的“外部”作用域的函数。因此，即使封闭函数终止，它也可以访问外部范围中的值。</p><p id="54d6" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated">以此为例:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="7f71" class="lh li iq ld b gy lj lk l ll lm">function takeOne() {<br/>  let i = 0;<br/>  return function incrementFunction() {<br/>    return i++;<br/>  }<br/>}</span></pre><p id="c77a" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated">上面的代码表示一个函数返回另一个函数。然而，当你调用<code class="fe ln lo lp ld b">takeOne</code>并得到<code class="fe ln lo lp ld b">incrementFunction</code>后，<code class="fe ln lo lp ld b">incrementFunction</code>会记住<code class="fe ln lo lp ld b">takeOne</code>的局部变量，即使<code class="fe ln lo lp ld b">takeOne</code>已经终止。</p><h1 id="1677" class="lq li iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">关闭的好处</h1><p id="0d32" class="pw-post-body-paragraph ka kb iq kc b kd mn kf kg kh mo kj kk kl mp kn ko kp mq kr ks kt mr kv kw kx ij bi translated">闭包的第一个好处是在范围内保留局部变量。由于JavaScript函数是一等公民，开发人员经常会遇到名称冲突，这会导致一些意外的输出。使用闭包有助于将命名空间作为私有变量保留在该范围内。你可以在过去的jQuery代码中看到很多这样的例子，其中定义了一个click方法。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="8850" class="lh li iq ld b gy lj lk l ll lm">$(function() {<br/>  var selections = []<br/>  $(".something").click(function() { <em class="ms">// this closure has access to the outer variable selections</em><br/>    selections.push("something") <em class="ms">// this are able to get the outer function selections</em><br/>  })<br/>})</span></pre><p id="6b53" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated">虽然这确实是闭包的用例之一，但它可能会让您思考，“这真的是闭包的目的吗？”您可能仍然会质疑闭包的一般用例是什么。</p><p id="942b" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated">第二个好处更像是一个通用用例，它在异步环境中很有用。</p><p id="ec39" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated">想象一下，如果您需要遍历数组中的一个值:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="9335" class="lh li iq ld b gy lj lk l ll lm">for(var i = 0 ; i&lt; 3; i++) {<br/>  setTimeout(() =&gt; console.log(i), 3000)<br/>}</span></pre><p id="53fb" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated">这个程序的输出会是什么？</p><p id="53a8" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated">它打印<code class="fe ln lo lp ld b">3</code>三次。由于<code class="fe ln lo lp ld b">setTimeout</code>是异步的，到循环结束的时候，外部作用域<code class="fe ln lo lp ld b">i</code>也变成了3，循环过程中对<code class="fe ln lo lp ld b">setTimeout</code>的后续调用每次都会触发回调并打印<code class="fe ln lo lp ld b">3</code>。</p><p id="16ce" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated">你会怎么解决这个问题？</p><p id="4242" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated">有很多方法，包括使用ES6语法<code class="fe ln lo lp ld b">let</code>而不是<code class="fe ln lo lp ld b">var</code>在块级别定义它的范围并解决问题。然而，如果他们想让你不使用任何ES6特性来解决这个问题，你的答案就是一个闭包。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="d05a" class="lh li iq ld b gy lj lk l ll lm">function printSomething(i) {<br/>  setTimeout(() =&gt; console.log(i), 3000)<br/>}<br/><br/>for(var i = 0; i&lt;3; i++) {<br/>  printSomething(i)<br/>}</span></pre><p id="78a6" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated">通过在<code class="fe ln lo lp ld b">setTimeout</code>之外创建另一个外部函数，您定义了一个闭包。即使在<code class="fe ln lo lp ld b">printSomething</code>终止后,<code class="fe ln lo lp ld b">i</code>值仍然保留。然后回调将<code class="fe ln lo lp ld b">0 1 2</code>打印到控制台。</p><p id="d90b" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated">这就是闭包是一个强大的JavaScript特性的原因。在异步环境中，可以使用闭包来保留外部变量的范围。</p><h1 id="e0a7" class="lq li iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">另一个例子</h1><p id="cb8a" class="pw-post-body-paragraph ka kb iq kc b kd mn kf kg kh mo kj kk kl mp kn ko kp mq kr ks kt mr kv kw kx ij bi translated">让我们想象另一个例子，您需要创建一个函数，该函数需要调用第三方API，并聚合结果并将其返回给调用者。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="66ff" class="lh li iq ld b gy lj lk l ll lm">function getAPI(cb) {<br/>    setTimeout(() =&gt; cb("a"), 3000)<br/>}<br/><br/>function getAPIB(cb) {<br/>    setTimeout(() =&gt; cb("b"), 2000)<br/>}<br/><br/>function getAPIC(cb) {<br/>    setTimeout(() =&gt; cb("c"), 1000)<br/>}<br/><br/>function aggregateValue() {<br/>  var aggregateData = []<br/>  <br/>  <em class="ms">// your implementation here</em><br/>}</span></pre><p id="d14e" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated">在您继续阅读解决方案之前，暂停一秒钟，想想如何在没有承诺或async/await的情况下解决这个问题。</p><p id="ffa2" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated">我们可以利用闭包的力量来保留函数的作用域，并通过使用回调来阻止<code class="fe ln lo lp ld b">aggregateValue</code>提前返回。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="052d" class="lh li iq ld b gy lj lk l ll lm">function aggregateValue(cb) {<br/>  var aggregateData = []<br/>  var numberAPICalledSoFar = 0<br/>  <br/>  function callback(value) {<br/>    aggregateData = [...aggregateData, value]<br/>    if(numberAPICalledSoFar &lt; 2) {<br/>      numberAPICalledSoFar++;<br/>    }else {<br/>      cb(aggregateData)<br/>    }<br/>  }<br/>  getAPI(callback)<br/>  getAPIB(callback)<br/>  getAPIC(callback)<br/>}</span></pre><p id="2c21" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated">由于<code class="fe ln lo lp ld b">getAPI</code>、<code class="fe ln lo lp ld b">getAPIB</code>、<code class="fe ln lo lp ld b">getAPIC</code>都使用了回调函数，所以可以创建一个回调函数来递增到目前为止调用的API的计数。一旦调用的API数量超过2，调用返回回调值。</p><p id="2fd9" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated">上面的代码再次利用闭包的能力，在封闭函数被触发时保留它的局部变量。当<code class="fe ln lo lp ld b">getAPI</code>完成其调用并调用回调函数时，回调函数访问外部作用域<code class="fe ln lo lp ld b">aggregateValue</code>以增加API完成执行的计数。然后<code class="fe ln lo lp ld b">aggregateData</code>从外部<code class="fe ln lo lp ld b">aggregateValue</code>返回一个回调函数，该函数需要来自所有第三方API的所有聚合数据。</p><p id="2cf0" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated">运行此功能:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="84af" class="lh li iq ld b gy lj lk l ll lm">aggregateValue((ans) =&gt; ans.foreach(console.log))</span></pre><h1 id="b794" class="lq li iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">外卖食品</h1><ul class=""><li id="f0df" class="mt mu iq kc b kd mn kh mo kl mv kp mw kt mx kx my mz na nb bi translated">虽然闭包是在javaScript的第一堂课上讲授的，但它们是JavaScript的一个更“高级”的特性。</li><li id="4594" class="mt mu iq kc b kd nc kh nd kl ne kp nf kt ng kx my mz na nb bi translated">ClosureClosure难的问题不是它的概念，而是它的好处，以及为什么你需要理解它的用例。</li><li id="46ce" class="mt mu iq kc b kd nc kh nd kl ne kp nf kt ng kx my mz na nb bi translated">闭包的一般用例是在异步环境中解决计算问题。</li></ul><p id="0140" class="pw-post-body-paragraph ka kb iq kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ij bi translated">本教程所有的源代码都是<a class="ae jz" href="https://github.com/edwardGunawan/Blog-Tutorial/tree/master/ClosureTutorial" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><h2 id="d421" class="lh li iq bd lr nh ni dn lv nj nk dp lz kl nl nm md kp nn no mh kt np nq ml nr bi translated">感谢阅读！如果你喜欢这篇文章，请随意<a class="ae jz" href="https://edward-huang.com/subscribe/" rel="noopener ugc nofollow" target="_blank">订阅</a>我的时事通讯，接收关于科技职业的每周文章、有趣的链接和内容！</h2><p id="e2ef" class="pw-post-body-paragraph ka kb iq kc b kd mn kf kg kh mo kj kk kl mp kn ko kp mq kr ks kt mr kv kw kx ij bi translated">你可以关注我，也可以关注我在<a class="ae jz" href="https://medium.com/@edwardgunawan880" rel="noopener">媒体</a>上的更多帖子。</p></div></div>    
</body>
</html>