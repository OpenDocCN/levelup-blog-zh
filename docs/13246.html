<html>
<head>
<title>Enums</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">枚举</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/enums-d56a726387c5?source=collection_archive---------3-----------------------#2022-08-19">https://levelup.gitconnected.com/enums-d56a726387c5?source=collection_archive---------3-----------------------#2022-08-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/05f3b296fd2bc21524f5475924559b16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aUzDhIfyyRjr6ra5wJORIA.png"/></div></div></figure><div class=""/><p id="653f" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用<em class="kz">枚举</em>是分离和组织状态驱动行为的一个非常有用的方法，同时保持你的代码整洁易读。枚举也能让其他设计师，甚至你自己的生活变得简单。我们走吧！</p></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><p id="4923" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd jf">难度选择器</strong></p><p id="7dbd" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里有一个<em class="kz">难度</em>脚本，带有一个私有<em class="kz">枚举</em>叫做<em class="kz">难度选择器</em>。Pascal case是声明和命名你的<em class="kz">枚举</em>的标准格式。打开一些花括号，列出要切换的不同状态。重要的是在每个状态名<em class="kz">后使用一个<em class="kz">逗号</em>，而最后一个状态没有逗号</em>。这里<em class="kz">困难选择器枚举</em>有<em class="kz">简单、正常、困难</em>和<em class="kz">专家</em>的状态。在底部，声明了一个变量来存储<em class="kz">当前难度</em>级别。我们可以用这个来分配选择的难度。</p><figure class="li lj lk ll gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi lh"><img src="../Images/f801076836e35bfac68c2d8499f3c8c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_FJkzmjAC13AkevWAohSoQ.png"/></div></div></figure><p id="fd7a" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果您愿意，您可以选择在一行中列出您的州。</p><figure class="li lj lk ll gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi lm"><img src="../Images/0caf307ab98977bdccc0813ef287073e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HuBooH-HkLYyHDZ6DhPqQw.png"/></div></div></figure><p id="0f06" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">默认情况下，<em class="kz">值</em>将像<em class="kz">元素</em>系统一样工作。从<em class="kz">零</em>开始，然后向上计数。<em class="kz">弱</em>，会有一个<em class="kz"> int </em>值为<em class="kz"> 0 </em>，而<em class="kz">中</em>会有一个<em class="kz"> int </em>值为<em class="kz"> 1 </em>。<em class="kz">强</em>和<em class="kz"> OP </em>将分别具有<em class="kz"> int </em>值<em class="kz"> 2 </em>和<em class="kz"> 3、</em>。如果需要，您可以<em class="kz">在这里分配</em>不同的值，如下图所示。现在这些状态将为它们的<em class="kz">硬编码</em>值<em class="kz"> (2，5，8，12) </em>返回一个<em class="kz"> int </em>值。</p><figure class="li lj lk ll gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ln"><img src="../Images/213dbf18c460ec2c514a1936d6014cf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A8Wypk_Wya_qiCCg_ZVZLQ.png"/></div></div></figure><p id="98a6" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">查看<em class="kz">检查器</em>中的<em class="kz">当前难度</em>变量，会显示一个漂亮的<em class="kz">下拉</em>选择器，用于<em class="kz">设置<em class="kz">枚举</em>的<em class="kz">状态</em>。</em></p><figure class="li lj lk ll gt iv gh gi paragraph-image"><div class="gh gi lo"><img src="../Images/79eb19133f23462fc6680997ac310835.png" data-original-src="https://miro.medium.com/v2/resize:fit:1246/format:webp/1*SC-1UgsNerMHL1BC4OMByw.png"/></div></figure><p id="2f09" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">所有<em class="kz">难度</em>选项都可用。</p><figure class="li lj lk ll gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi lp"><img src="../Images/e9d27552ba36f510339f7f284cb9af66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1242/1*OcZoKchl4MaNmu2_Dt7TAA.gif"/></div></div></figure><p id="cc28" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">枚举本身不会做任何事情。这需要一些逻辑来解决，所以让我们使用一个<em class="kz"> switch </em>语句来切换当前难度枚举变量的状态。在<em class="kz">难度选择器</em>枚举中，每个<em class="kz">难度</em>都有一个<em class="kz">案例</em>。<em class="kz">调试</em>消息会将所选难度打印到控制台。</p><figure class="li lj lk ll gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi lq"><img src="../Images/0558aac8dfbc4f9acadab86f768e552a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zm_VegEG5n-1nM1ht6D8eA.png"/></div></div></figure></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><p id="09a1" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd jf">铸造值</strong></p><p id="8949" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">虽然您不能直接使用<em class="kz">枚举值</em>作为一个<em class="kz">整数</em>，但是在这种情况下，您可以将它转换为一个<em class="kz"> int </em>，您希望<em class="kz">基于一个<em class="kz">索引</em>号加载</em>一个<em class="kz">游戏场景</em>。</p><figure class="li lj lk ll gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi lr"><img src="../Images/6b25329ec003a1100308854db4bbedf9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G3Qw8YzIkya9OGId1ZuVag.png"/></div></div></figure></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><p id="643d" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd jf">敌人的行为</strong></p><p id="bf2e" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">将<em class="kz">枚举</em>用于<em class="kz">状态驱动行为</em>正是敌方人工智能系统所需要的。这个<em class="kz">敌人行为</em>脚本附加在场景视图中几个不同的<em class="kz">立方体</em>敌人身上。他们都有<em class="kz"> 100生命值</em>，状态为<em class="kz">巡逻，跟随，攻击，防守，躲避</em>和<em class="kz">死亡</em>。<em class="kz">枚举敌人状态</em>可以通过<em class="kz">当前状态</em>变量循环。</p><figure class="li lj lk ll gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/05f3b296fd2bc21524f5475924559b16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aUzDhIfyyRjr6ra5wJORIA.png"/></div></div></figure><p id="0948" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在void <em class="kz"> update </em>中，我运行了一个名为<em class="kz">改变敌方状态</em>的方法，这个方法现在调用一个将为敌方对象运行<em class="kz">行为</em>动作脚本的方法。</p><figure class="li lj lk ll gt iv gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/3dc0f2545699d488d01420f8a4426d13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1356/format:webp/1*PMAeSdiCnrrPEgImwcdSyQ.png"/></div></figure><p id="619a" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个函数的开始将在下一个例子中发挥作用，但是这里的<em class="kz">敌人状态</em>被重置为<em class="kz">巡逻</em>，如果该状态的<em class="kz"> int </em>值试图将<em class="kz">移动到比<em class="kz">死亡</em>状态更高的</em>。</p><figure class="li lj lk ll gt iv gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/b8d24843c6a3d92ba52aebfa69c9154a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1030/format:webp/1*mhtbq-GGL9TDrOlz8CLdCQ.png"/></div></figure><p id="f156" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">该<em class="kz">切换</em>语句使用<em class="kz">当前状态</em>变量在不同的<em class="kz">枚举敌人状态</em>中循环。这里没有插入实际的敌人移动行为，我只是发送一个<em class="kz">调试</em>消息到控制台来显示那个特定的状态。</p><figure class="li lj lk ll gt iv gh gi paragraph-image"><div class="gh gi lu"><img src="../Images/20d3cb015ddccfa1ee26ab60042f88ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1122/format:webp/1*IZJyRyzpcxx5eypPHA0_Xg.png"/></div></figure><p id="a73a" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这些敌人对象中的每一个都附有<em class="kz">敌人行为</em>脚本。</p><figure class="li lj lk ll gt iv gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/7d3120c91b52ecbeccabfda2e8aed704.png" data-original-src="https://miro.medium.com/v2/resize:fit:396/format:webp/1*O9TEVjkWDtp5CTmKa3Hung.png"/></div></figure><p id="275c" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这使他们能够单独使用<em class="kz">当前状态</em>变量来选择他们自己的行为。这里的这个敌人是<em class="kz">巡逻的</em>。</p><figure class="li lj lk ll gt iv gh gi paragraph-image"><div class="gh gi lw"><img src="../Images/22448300a82f8f606b5997e85ca75a0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1244/format:webp/1*FTjGPfeaf7WO19OrgS0CNw.png"/></div></figure><p id="094d" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个敌人是跟随的<em class="kz">。</em></p><figure class="li lj lk ll gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi lw"><img src="../Images/4b4ecea43ca8d37e8613c6e8b48b8f06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1244/format:webp/1*HTRJbIRYyanSmjSF52WBYA.png"/></div></div></figure><p id="ee8d" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这个敌人是<em class="kz">攻击</em>。</p><figure class="li lj lk ll gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi lx"><img src="../Images/5705302d151b17bdc47f1b1140af108d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1258/format:webp/1*2HdLnSqmcOzdXQHCgICR8w.png"/></div></div></figure><p id="c7da" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里你可以看到每个敌人都有所有<em class="kz">行为</em>可用。</p><figure class="li lj lk ll gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi lw"><img src="../Images/3146ba78c84bc3db2a657ba7703bf01c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1244/1*ver9MVGx4vO9pXQideyMeQ.gif"/></div></div></figure><p id="2e43" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果我玩这个游戏，每个敌人都会向控制台发送自己的<em class="kz">调试</em>消息。这通常是在<em class="kz"> 60 FPS </em>时触发的<em class="kz">移动</em>行为。</p><figure class="li lj lk ll gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ly"><img src="../Images/60f7974b46b4a9df9e9c0ad8024f13b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*bxjdITEIE0LsjyK-QhIe5A.gif"/></div></div></figure><p id="1503" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">你会想要一个<em class="kz">条件</em>或者<em class="kz">事件</em>来改变敌方行为<em class="kz">状态</em>。与其在update中运行这个方法，不如让我们使用<em class="kz">空格键</em>来展示我们如何在行为状态之间改变。</p><figure class="li lj lk ll gt iv gh gi paragraph-image"><div class="gh gi lz"><img src="../Images/298452f95db34bd0d294d537d594d054.png" data-original-src="https://miro.medium.com/v2/resize:fit:978/format:webp/1*Xl64fun_vmW909SIR5dOuQ.png"/></div></figure><p id="3a2d" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当按下空格键时，<em class="kz">当前状态</em>变量将<em class="kz">增加</em>，将其向前移动到下一个列出的状态。一旦当前状态移过<em class="kz">死亡</em>，则重置为<em class="kz">巡逻</em>。</p><figure class="li lj lk ll gt iv gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/c4135aca4e438851e6d990b9ef7cedd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1030/format:webp/1*RCicGRF-sm7JhwQqqPT_Xg.png"/></div></figure><p id="9155" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">这里可以看到<em class="kz">空格键</em>在运行时改变<em class="kz">敌人行为</em> <em class="kz">枚举</em>！</p><figure class="li lj lk ll gt iv gh gi paragraph-image"><div class="gh gi lw"><img src="../Images/9a62be50e1087e6185e010163a946068.png" data-original-src="https://miro.medium.com/v2/resize:fit:1244/1*2QzyUqR7BpM8H1sX8lcFgQ.gif"/></div></figure><p id="a625" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在你的switch语句中使用<em class="kz">逻辑</em>和<em class="kz">条件</em>是你想要敌人的行为<em class="kz">改变</em>的理想选择。正如这里看到的，一旦这个敌人的<em class="kz">生命值</em>低于<em class="kz">20</em>，这个<em class="kz">规避</em>状态就会运行你在这里插入的任何脚本。我真正应该做的是在<em class="kz">之前的</em>状态下检查健康状况，然后<em class="kz">将</em>状态设置为<em class="kz">在那里规避</em>。在这里的规避中，我将检查一个条件以<em class="kz">退出</em>规避机动，并将状态设置为另一个。</p><figure class="li lj lk ll gt iv gh gi paragraph-image"><div class="gh gi ma"><img src="../Images/eaeabfb13bf30bd1977fe067c4a01974.png" data-original-src="https://miro.medium.com/v2/resize:fit:1214/format:webp/1*R24Bl8DeGLL0d_ecz2HC0g.png"/></div></figure><p id="f5ca" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">敌人<em class="kz">死亡</em>状态是<em class="kz">消灭</em>敌人游戏对象的好地方！</p><figure class="li lj lk ll gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mb"><img src="../Images/bc432d45de6b63d7671596ab22c1efbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kjokFglZGxHDZEePD-kvvg.png"/></div></div></figure></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><p id="40f3" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated"><strong class="kd jf">自定义类别</strong></p><p id="1764" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们将一个<em class="kz">枚举</em>添加到这个自定义<em class="kz">项目</em>类中。<em class="kz"> ItemType枚举</em>表示每个项目可以声明的不同项目类型。这里我有<em class="kz">武器、消耗品、护甲</em>和<em class="kz">货币</em>供选择。</p><figure class="li lj lk ll gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mc"><img src="../Images/38237431009ab86e225eb5375d562b16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cw7fNSFuCW_lN6xCrpm1NQ.png"/></div></div></figure><p id="2b8a" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用带有<em class="kz">开关</em>语句的<em class="kz">方法</em>，当另一个脚本想要<em class="kz">引用</em>它时，给用户一个机会返回一些关于被调用的<em class="kz">项目类型</em>的信息。</p><figure class="li lj lk ll gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi md"><img src="../Images/ab47b4dc5414f9d85ebd366be5fc7499.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eOQPstolnqcr728WabliYg.png"/></div></div></figure></div><div class="ab cl la lb hx lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="im in io ip iq"><p id="f385" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们进入一个<em class="kz"> ItemDatabase </em>脚本，它附加到场景中的一个空对象上。最后一行创建一个名为<em class="kz"> itemsList </em>的<em class="kz"> Items </em>的新<em class="kz"> List </em>，然后<em class="kz">初始化</em>它。</p><figure class="li lj lk ll gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi me"><img src="../Images/b858884cf85c21405fda187ed04585bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TttpiD6r1retEd_FhCxUdw.png"/></div></div></figure><p id="02c6" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">每个<em class="kz"> ItemAction </em>方法都可以通过<em class="kz"> itemsList List </em>调用，然后声明要对哪个<em class="kz">元素</em>执行操作。</p><figure class="li lj lk ll gt iv gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/3d1eacf2f35cbf1d2c58863e39b96124.png" data-original-src="https://miro.medium.com/v2/resize:fit:918/format:webp/1*Hq0eWDYp91Goz064k8xYXQ.png"/></div></figure><p id="c5c2" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">每个项目<em class="kz">动作</em>被调用，其各自的<em class="kz">项目类型</em>被<em class="kz">打印</em>到控制台。如果你有各种各样的可消耗物品，它们在被消耗时都有相似的行为，这可能是有用的。</p><figure class="li lj lk ll gt iv gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/244f8eca9c9c9f806f909fca9070264a.png" data-original-src="https://miro.medium.com/v2/resize:fit:820/format:webp/1*bWe7-4VRF515JsefGbN7yg.png"/></div></figure><p id="0372" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果你需要组装一个库存系统，你完全可以在<em class="kz">类继承</em>、<em class="kz">列表</em>、<em class="kz">数组</em>和现在的<em class="kz">枚举之间得到照顾！</em></p><figure class="li lj lk ll gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mh"><img src="../Images/0b622d0421b8f5169c8ca37b8e83f32d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1254/format:webp/1*olR5XZklLQUdVbO0b_KdPw.png"/></div></div></figure><p id="2af9" class="pw-post-body-paragraph kb kc je kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">感谢阅读！</p></div></div>    
</body>
</html>