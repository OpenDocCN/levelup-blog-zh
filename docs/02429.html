<html>
<head>
<title>Higher-order Functions in Javascript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Javascript中的高阶函数</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/higher-order-functions-in-javascript-566ed1d32db6?source=collection_archive---------6-----------------------#2020-03-12">https://levelup.gitconnected.com/higher-order-functions-in-javascript-566ed1d32db6?source=collection_archive---------6-----------------------#2020-03-12</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><div class=""><h2 id="e07c" class="pw-subtitle-paragraph jq is it bd b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh dk translated">闭包、回调，以及如何使用Spread操作符访问高阶函数中数量不确定的参数</h2></div><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/e73167e8e9109c77184a0f8b95ecc784.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Tsbt0TpnxeOQOlZl"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk translated">布雷特·乔丹在<a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="c8ac" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">无论您是Javascript新手还是相当高级的人，并且只是回顾基本主题，高阶函数都是理解并能够在代码中实现的重要特性。</p><p id="cfd2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">作为一种编程语言，Javascript是<a class="ae ky" href="https://codeburst.io/imperative-vs-declarative-javascript-8b5e45a602dd" rel="noopener" target="_blank">多范例</a>:它支持命令式和声明式编程。命令式编程包括<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Object-oriented_JS" rel="noopener ugc nofollow" target="_blank">面向对象编程</a>(或OOP)和原型继承，而声明式编程——或函数式编程——建立在第一类函数和闭包以及其他属性之上。这些函数式编程特性用来<em class="lv">声明</em>一个函数的预期行为是什么，而不特定于任何一个例子。就本文的范围而言，我们不会深入研究这两种范式的细节(更多信息请参见这里的<a class="ae ky" href="https://medium.com/javascript-in-plain-english/what-are-javascript-programming-paradigms-3ef0f576dfdb" rel="noopener"/>),而是关注Javascript函数式编程的一些基本特性，因为它们与高阶函数特别相关。然后，我们将一起构建一个高阶函数的示例。</p><h1 id="94ed" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">一流的功能</h1><p id="9eb5" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">在任何编程语言(不仅仅是Javascript)中，<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Glossary/First-class_Function" rel="noopener ugc nofollow" target="_blank">一级函数</a>是一个被视为任何其他变量的函数。这个概念允许Javascript中的函数作为另一个函数的参数被接受，由另一个封闭函数返回，甚至作为变量值被赋值。同样，在Javascript中，函数被视为<em class="lv">对象</em>。为了创建高阶函数，这是必要的。</p><p id="0a1b" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">您可以查看每种可能性的代码片段(作为参数的函数、作为返回值的函数或作为变量值的函数)<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Glossary/First-class_Function" rel="noopener ugc nofollow" target="_blank">这里</a>或<a class="ae ky" href="https://medium.com/launch-school/javascript-weekly-an-introduction-to-first-class-functions-9d069e6fb137" rel="noopener">这里</a>。</p><h1 id="d204" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">关闭</h1><p id="6bcc" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">一个<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures" rel="noopener ugc nofollow" target="_blank">闭包</a>是Javascript中的函数如何记住和访问它周围的状态(或词汇环境)。每当一个函数访问一个定义在自己作用域 之外的<strong class="lb iu"> <em class="lv">变量时，就会产生闭包。当考虑闭包以及它们如何操作时，考虑下面的例子可能会有所帮助。让我们一起走过它。</em></strong></p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="397c" class="my lx it mu b gy mz na l nb nc">01  const globalVar = "xyz"<br/>02  (function outerFunc(outerArg){<br/>03    const outerVar = 'a'<br/>04    (function innerFunc(innerArg){<br/>05      const innerVar = 'b'<br/>06      console.log(outerArg) // 123<br/>07      console.log(innerArg) // 456<br/>08      console.log(outerVar) // "a"<br/>09      console.log(innerVar) // "b"<br/>10     console.log(globalVar) // "xyz"<br/>11    })(456)<br/>12  })(123)<br/>```</span></pre><p id="38a7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在代码片段的全局范围内，有一个全局变量<code class="fe nd ne nf mu b">globalVar</code>，它是用值<code class="fe nd ne nf mu b">“xyz”</code>声明和实例化的。<code class="fe nd ne nf mu b">outerFunc</code>是一个life——一个<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Glossary/IIFE" rel="noopener ugc nofollow" target="_blank">立即调用的函数表达式</a>——接受第2行<code class="fe nd ne nf mu b">outerArg</code>的参数，用第12行<code class="fe nd ne nf mu b">123</code>的实参调用。在<code class="fe nd ne nf mu b">outerFunc</code>中，声明了一个变量<code class="fe nd ne nf mu b">outerVar</code>，并用<code class="fe nd ne nf mu b">‘a’</code>的值实例化。<code class="fe nd ne nf mu b">outerFunc</code>还包括<code class="fe nd ne nf mu b">innerFunc</code>。<code class="fe nd ne nf mu b">innerFunc</code>也是一个生命，接受第4行<code class="fe nd ne nf mu b">innerArg</code>的参数，用第11行的参数<code class="fe nd ne nf mu b">456</code>调用。在<code class="fe nd ne nf mu b">innerFunc</code>中，它声明并实例化了一个变量<code class="fe nd ne nf mu b">innerVar</code>，其值为<code class="fe nd ne nf mu b">‘b’</code>。在<code class="fe nd ne nf mu b">innerFunc</code>中，它记录了每个变量值。</p><p id="a730" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nd ne nf mu b">innerFunc</code>在这里充当一个闭包。正如您从日志中看到的(由上面的<code class="fe nd ne nf mu b">//</code>描述)，<code class="fe nd ne nf mu b">innerFunc</code>可以访问这个代码片段中每个变量的值。<code class="fe nd ne nf mu b">innerFunc</code>创建自己的作用域，可以在这个作用域内访问<code class="fe nd ne nf mu b">innerVar</code>，但是<strong class="lb iu"> <em class="lv">也可以</em> </strong>访问其封闭作用域内的变量<code class="fe nd ne nf mu b">outerFunc</code>，以及任何全局声明的变量<code class="fe nd ne nf mu b">globalVar</code>。基本上，内部闭包总是可以向外看，但是反过来是<em class="lv">不</em>真。</p><p id="3e85" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">回顾了一级函数和闭包之后，高阶函数只是这两个概念的组合。</p><h1 id="cfb5" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">高阶函数</h1><p id="e8b2" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">简单来说，一个<a class="ae ky" href="https://eloquentjavascript.net/05_higher_order.html" rel="noopener ugc nofollow" target="_blank">高阶函数</a>只是一个一级函数，可以接受另一个函数作为自变量<strong class="lb iu"> <em class="lv">和/或</em> </strong>返回一个函数。高阶函数的一个常见示例是当函数接受第二个函数(命名的或匿名的)作为参数时。作为参数传入的函数也称为<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Glossary/Callback_function" rel="noopener ugc nofollow" target="_blank">回调函数</a>。请记住，当回调函数在封闭函数中被调用并需要访问外部变量时，闭包就会被创建。</p><p id="858d" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">让我们考虑一个简短的例子:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="7133" class="my lx it mu b gy mz na l nb nc">01  function hello() {<br/>02    console.log("hello world")<br/>03  } </span><span id="ebe5" class="my lx it mu b gy ng na l nb nc">04  function start(callback){<br/>05    callback()<br/>06  } </span><span id="8a2b" class="my lx it mu b gy ng na l nb nc">07  start(hello)<br/>// "hello world"</span></pre><p id="9ed8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码片段中，第1–3行声明了函数<code class="fe nd ne nf mu b">hello</code>。在第4行的<code class="fe nd ne nf mu b">start</code>的函数声明中，我们将<code class="fe nd ne nf mu b">callback</code>作为参数传入。在第7行，<code class="fe nd ne nf mu b">start</code>被调用，函数<code class="fe nd ne nf mu b">hello</code>作为参数被传入。<code class="fe nd ne nf mu b">start</code>在被调用时记录<code class="fe nd ne nf mu b">“hello world”</code>，因为<code class="fe nd ne nf mu b">hello</code>作为一个回调函数，它本身将在<code class="fe nd ne nf mu b">start</code>中被调用(见第2行)。</p><h1 id="ff5b" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">实现高级高阶函数</h1><p id="b2c8" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">我们将一起构建一个高阶函数<code class="fe nd ne nf mu b">logger</code>，它将接受一个回调函数。该函数应该记录<em class="lv">回调</em>函数的参数(<strong class="lb iu"> <em class="lv">而不是</em> </strong> <em class="lv"> </em> <code class="fe nd ne nf mu b">logger</code>的参数)；评估回调函数的返回值；最后，记录回调函数的返回值。</p><p id="9da7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在下面的代码片段中，我创建了三个函数作为示例性的回调函数用于<code class="fe nd ne nf mu b">logger</code> : <code class="fe nd ne nf mu b">add</code>、<code class="fe nd ne nf mu b">square</code>和<code class="fe nd ne nf mu b">sumArray</code>。这些函数都基于所提供的参数计算一个数学方程。为了调用高阶函数<code class="fe nd ne nf mu b">logger</code>，进行了一个变量声明(见下面第12-14行)，该值是一个函数表达式(即<code class="fe nd ne nf mu b">logger(add)</code>)。通过使用我们的高阶函数，函数表达式可以接受一个回调函数。</p><p id="4ba8" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated"><code class="fe nd ne nf mu b">logger</code>满足高阶函数的要求:它接受一个函数作为回调函数，并且<strong class="lb iu">也将</strong>返回一个函数，该函数将评估回调函数。还要记住，<code class="fe nd ne nf mu b">logAdd</code>、<code class="fe nd ne nf mu b">logSquare</code>和<code class="fe nd ne nf mu b">logSum</code>在被调用时都会创建自己的闭包；它们共享对<code class="fe nd ne nf mu b">logger</code>函数的相同引用，但是会创建不同的词法环境。</p><h2 id="76f0" class="my lx it bd ly nh ni dn mc nj nk dp mg li nl nm mi lm nn no mk lq np nq mm nr bi translated">起始代码:</h2><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="2bc5" class="my lx it mu b gy mz na l nb nc">01  function add(x, y){<br/>02    return x + y<br/>03  }<br/> <br/>04  function square(x, y){<br/>05    return x * y<br/>06  }<br/><br/>07  function sumArray(arr){<br/>08    return arr.reduce((accumulator, currentValue) =&gt; {<br/>09      return accumulator + currentValue<br/>10    })<br/>11  }<br/> <br/>12  const logAdd = logger(add)<br/>13  const logSquare = logger(square)<br/>14  const logSum = logger(sumArray)<br/><br/>16  logAdd(1, 2) <br/>// "these are my arguments:" 1 2<br/>// "this is the result:" 3<br/>  <br/>17  logSquare(3, 3)<br/>// "these are my arguments:" 3 3<br/>// "this is the result:" 9<br/> <br/>18  logSum([1, 2, 3])<br/>// "these are my arguments:" [1, 2, 3]<br/>// "this is the result:" 6</span></pre><p id="4826" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在处理这个问题时，让我们首先考虑第12–14行的变量声明中发生了什么。我们可以理解第16行的<code class="fe nd ne nf mu b">logAdd(1, 2)</code>会用<code class="fe nd ne nf mu b">logger</code> : <code class="fe nd ne nf mu b">logger(add(1, 2))</code>内的<code class="fe nd ne nf mu b">1</code>和<code class="fe nd ne nf mu b">2</code>的参数调用<code class="fe nd ne nf mu b">add</code>。通过将预期的功能放在上下文中，我们可以看到主要的障碍是<code class="fe nd ne nf mu b">logger</code>中的<code class="fe nd ne nf mu b">add</code>函数需要访问将传递给<code class="fe nd ne nf mu b">logAdd</code>的参数。然而，<code class="fe nd ne nf mu b">logger</code>也需要足够抽象以接受任意数量的参数，这样它也可以成功地评估任何回调。虽然<code class="fe nd ne nf mu b">logAdd</code>需要两个参数，但是<code class="fe nd ne nf mu b">logSum</code>需要一个数组。</p><p id="a086" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们再次考虑闭包是如何工作的，我们知道内部函数总是可以向外看它们的封闭范围。</p><h2 id="fd6d" class="my lx it bd ly nh ni dn mc nj nk dp mg li nl nm mi lm nn no mk lq np nq mm nr bi translated">访问未知数量的参数</h2><p id="3f56" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">在直接进入<code class="fe nd ne nf mu b">logger</code>之前，让我们首先尝试弥合差距，构建一个单独的<code class="fe nd ne nf mu b">combined</code>函数，它可以处理接受未知数量的参数。(稍后我们可以将内部功能抽象成回调。)<code class="fe nd ne nf mu b">combined</code>的参数将被传递给一个内部函数，该函数需要特定数量的参数。为了简洁起见，代码片段将集中于从上面构建<code class="fe nd ne nf mu b">add</code>功能；它需要两个数字参数。</p><p id="7888" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在伪代码中:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="c428" class="my lx it mu b gy mz na l nb nc">01  function combined(args??){<br/>02    return (math args) =&gt; {<br/>03      do some math here<br/>04    } <br/>05  }  </span></pre><p id="9be3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">我们先把<code class="fe nd ne nf mu b">add</code>的功能性作为<code class="fe nd ne nf mu b">combined</code>的返回值包含进来。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="e233" class="my lx it mu b gy mz na l nb nc">01  function combined(/* args? */){<br/>02    return ((x, y) =&gt; {<br/>03      return x + y<br/>04    })(/* args? */)<br/>05  } </span></pre><p id="25f7" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">为了让匿名箭头函数(第2-4行)访问<code class="fe nd ne nf mu b">combined</code>的参数，我们可以在这里使用一个IIFE。我们在第4行传递的参数将与上面代码片段中第1行的参数相匹配。</p><p id="b4d3" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">那么，Javascript中有没有什么运算符可以让我们访问未知数量的参数呢？让我们回顾一下<strong class="lb iu">扩展运算符</strong>。根据<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax" rel="noopener ugc nofollow" target="_blank"> MDN文档</a>:</p><blockquote class="ns nt nu"><p id="e068" class="kz la lv lb b lc ld ju le lf lg jx lh nv lj lk ll nw ln lo lp nx lr ls lt lu im bi translated"><strong class="lb iu">“扩展语法</strong>允许在应该有零个或多个参数(用于函数调用)或元素(用于数组文字)的地方扩展可迭代对象，如数组表达式或字符串……”</p></blockquote><p id="8c18" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">通过在我们的外部函数的参数<em class="lv">和</em>中实现spread操作符，当我们立即调用匿名函数表达式时，内部函数可以访问这些变量，而外部函数不需要指定预期的数量。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="dde0" class="my lx it mu b gy mz na l nb nc">01  function combined(...args){<br/>02    return ((x, y) =&gt; {<br/>03      return x + y<br/>04    })(...args)<br/>05  }<br/><br/>// without arrow function syntax<br/><br/>06  function combined(...args){<br/>07    return (function adder(x, y){<br/>08      return x + y<br/>09    })(...args)  <br/>10  }</span></pre><h2 id="c107" class="my lx it bd ly nh ni dn mc nj nk dp mg li nl nm mi lm nn no mk lq np nq mm nr bi translated">使用回调进行重构</h2><p id="15ca" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">完成了这些，我们现在可以考虑如何将<code class="fe nd ne nf mu b">combined</code>函数重构为预期的<code class="fe nd ne nf mu b">logger</code>函数。</p><p id="753f" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">首先，我们不再需要像在上面的<code class="fe nd ne nf mu b">combined</code>中那样包含<code class="fe nd ne nf mu b">add</code>的功能。我们传递给<code class="fe nd ne nf mu b">logger</code>的<code class="fe nd ne nf mu b">callback</code>将会处理这个问题。其次，请记住，我们可以扩展封闭的外部函数的参数，以便内部函数可以使用spread运算符访问零个或多个参数。</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="7b97" class="my lx it mu b gy mz na l nb nc">01  function logger1(callback){<br/>02    return (...args) =&gt; {<br/>03      console.log('these are my arguments: ', ...args)<br/>04      const result = callback(...args)<br/>05      console.log('this is the result: ', result)<br/>06    }<br/>07  }<br/><br/>    // without arrow function syntax<br/> <br/>08  function logger2(callback){<br/>09    return function(...args){<br/>10      console.log('these are my arguments: ', ...args)<br/>11      const result = callback(...args)<br/>12      console.log('this is the result: ', result)<br/>13    }<br/>14  }<br/> <br/>    // without the spread operator or arrow function syntax <br/>    // (pre-ES6) <br/>  <br/>15  function logger3(callback){<br/>16    return function(){<br/>17      console.log('these are my arguments: ', arguments)<br/>18        const result = callback.apply(null, arguments)<br/>19      console.log('this is the result: ', result)<br/>20    }<br/>21  }</span></pre><p id="beea" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">在上面的代码片段中，<code class="fe nd ne nf mu b">logger1</code>中的第2行和第9行传播了<code class="fe nd ne nf mu b">combined</code>先前显式传递给其内部函数的参数。这里，我们必须记住，<code class="fe nd ne nf mu b">logAdd</code>将在被调用时为<code class="fe nd ne nf mu b">logger(add)</code>创建一个闭包，<code class="fe nd ne nf mu b">logAdd</code>将为<code class="fe nd ne nf mu b">logger</code>的<code class="fe nd ne nf mu b">callback</code>传入参数。匿名函数(第2–6行)通过将它们作为参数(第2行)传递给<code class="fe nd ne nf mu b">callback</code>来访问<code class="fe nd ne nf mu b">…args</code>。</p><h2 id="5d8c" class="my lx it bd ly nh ni dn mc nj nk dp mg li nl nm mi lm nn no mk lq np nq mm nr bi translated">ES6之前的版本</h2><p id="bac4" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">顺便说一下，上面代码片段中的<code class="fe nd ne nf mu b">logger3</code>给出了一个ES6之前的解决方案。第17行和第18行访问Javascript的<code class="fe nd ne nf mu b"><a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments" rel="noopener ugc nofollow" target="_blank">arguments</a></code>对象。这是一个类似数组的对象，在函数中只有<em class="lv">和</em>可以访问，并且包含传递给该函数的参数的<strong class="lb iu">值</strong>。明确地说，您<em class="lv">不能</em>使用任何内置数组方法(即<code class="fe nd ne nf mu b">map</code>或<code class="fe nd ne nf mu b">forEach</code>)，但是您可以在对象上调用<code class="fe nd ne nf mu b">.length</code>或通过它们的索引号访问任何参数属性:<code class="fe nd ne nf mu b">arguments[0]</code>。</p><p id="fffd" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">此外，如果没有spread操作符，第18行的<code class="fe nd ne nf mu b">apply</code>方法将调用<code class="fe nd ne nf mu b">callback</code>函数，就好像它是<code class="fe nd ne nf mu b">arguments</code>的方法一样(作为<code class="fe nd ne nf mu b">apply</code>的第二个参数传入)。通过提供<code class="fe nd ne nf mu b">null</code>作为第一个必需的参数，全局对象被使用，而不是提供<code class="fe nd ne nf mu b">apply</code>方法一个特定的<code class="fe nd ne nf mu b">this</code>上下文给<code class="fe nd ne nf mu b">callback</code>(更多信息<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply" rel="noopener ugc nofollow" target="_blank">在这里</a>)。<code class="fe nd ne nf mu b">arguments</code>都被传递到<code class="fe nd ne nf mu b">callback</code>函数中，并且可以被成功评估。</p><p id="deb2" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">如果我们比较<code class="fe nd ne nf mu b">logger1</code>和<code class="fe nd ne nf mu b">logger3</code>的日志:</p><pre class="kj kk kl km gt mt mu mv mw aw mx bi"><span id="ecd6" class="my lx it mu b gy mz na l nb nc">01  const log1Add = logger1(add)<br/>02  log1Add(1, 2)<br/>// <!-- -->these are my arguments: 1 2<br/>// this is the result: 3<br/><br/>03  const log3Add = logger3(add)<br/>04  log3Add(1, 2)<br/>// "<!-- -->these are my arguments:" [Arguments] { ‘0’: 1, ‘1’: 2 }<br/>// "this is the result:" 3</span></pre><p id="e97e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">当调用<code class="fe nd ne nf mu b">logger3</code>时，第17行将记录<code class="fe nd ne nf mu b">these are my arguments:[Arguments] { ‘0’: 1, ‘1’: 2 }</code>，而不是像<code class="fe nd ne nf mu b">logger1</code>或<code class="fe nd ne nf mu b">logger2</code>那样记录<code class="fe nd ne nf mu b">these are my arguments: 1 2</code>。这是因为我们在<code class="fe nd ne nf mu b">logger3</code>中专门访问Javascript <code class="fe nd ne nf mu b">arguments</code>对象，而不是传递给<code class="fe nd ne nf mu b">logAdd</code>并在<code class="fe nd ne nf mu b">logger1</code>或<code class="fe nd ne nf mu b">logger2</code>中传播的参数。</p><p id="5b10" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">但是，请注意，如果我们调用<code class="fe nd ne nf mu b">log3Add(1, 2)</code>，那么<code class="fe nd ne nf mu b">logger3</code>的第19行仍然会记录<code class="fe nd ne nf mu b">this is the result: 3</code>，就像上面代码片段中的<code class="fe nd ne nf mu b">log1Add(1, 2)</code>一样。</p><h1 id="ef8d" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">结论</h1><p id="2740" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">每当您将Javascript实现为函数式编程语言时，通常会使用高阶函数。上面的教程回顾了高阶函数建立在什么概念之上(记住:一级函数和闭包)以及如何在自己的程序中实现高阶函数。</p><p id="f0e1" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">祝你好运，并快乐编码！</p><h1 id="ca20" class="lw lx it bd ly lz ma mb mc md me mf mg jz mh ka mi kc mj kd mk kf ml kg mm mn bi translated">来源</h1><p id="0095" class="pw-post-body-paragraph kz la it lb b lc mo ju le lf mp jx lh li mq lk ll lm mr lo lp lq ms ls lt lu im bi translated">MDN Web Docs: <a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Object-oriented_JS" rel="noopener ugc nofollow" target="_blank">面向对象的Javascript初学者</a>，<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Glossary/First-class_Function" rel="noopener ugc nofollow" target="_blank">一级函数</a>，<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures" rel="noopener ugc nofollow" target="_blank">闭包</a>，<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Glossary/Callback_function" rel="noopener ugc nofollow" target="_blank">回调函数</a>，<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Glossary/IIFE" rel="noopener ugc nofollow" target="_blank">life</a>，<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax" rel="noopener ugc nofollow" target="_blank">传播语法</a>，<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments" rel="noopener ugc nofollow" target="_blank"> arguments object </a>，<a class="ae ky" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply" rel="noopener ugc nofollow" target="_blank">Function . prototype . apply()</a></p><p id="1939" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">Javascript说白了:<a class="ae ky" href="https://medium.com/javascript-in-plain-english/what-are-javascript-programming-paradigms-3ef0f576dfdb" rel="noopener">Javascript编程范式有哪些？</a></p><p id="10b6" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">代码突发:<a class="ae ky" href="https://codeburst.io/imperative-vs-declarative-javascript-8b5e45a602dd" rel="noopener" target="_blank">命令式vs声明式Javascript </a></p><p id="d314" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">推出学校:<a class="ae ky" href="https://medium.com/launch-school/javascript-weekly-an-introduction-to-first-class-functions-9d069e6fb137" rel="noopener">一级函数介绍</a></p><p id="8250" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">雄辩的Javascript: <a class="ae ky" href="https://eloquentjavascript.net/05_higher_order.html" rel="noopener ugc nofollow" target="_blank">高阶函数</a></p><p id="4c5e" class="pw-post-body-paragraph kz la it lb b lc ld ju le lf lg jx lh li lj lk ll lm ln lo lp lq lr ls lt lu im bi translated">零零碎碎:<a class="ae ky" href="https://blog.bitsrc.io/understanding-higher-order-functions-in-javascript-75461803bad" rel="noopener ugc nofollow" target="_blank">理解Javascript中的高阶函数</a></p></div></div>    
</body>
</html>