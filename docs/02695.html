<html>
<head>
<title>Async Events in Sequence with React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有React的序列中的异步事件</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/async-events-in-sequence-with-react-aefd6749d37b?source=collection_archive---------2-----------------------#2020-03-30">https://levelup.gitconnected.com/async-events-in-sequence-with-react-aefd6749d37b?source=collection_archive---------2-----------------------#2020-03-30</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/81bd75b1b9045f3f5b10f70ac2711c8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fr6OHtRrXW8Z_OJmNdPuPg.png"/></div></div></figure><p id="6813" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">Javascript是一种单线程、阻塞、<em class="kz">同步</em>编程语言。浏览器从上到下按顺序读取包含Javascript代码的脚本，并阻止长时间运行的任务，如网络请求和I/O事件。</p><p id="fbd2" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以通过确定以下内容的适用位置来编写异步运行的JavaScript代码:</p><ol class=""><li id="8219" class="la lb it kd b ke kf ki kj km lc kq ld ku le ky lf lg lh li bi translated"><em class="kz">异步</em>代码，同步<em class="kz">执行</em>。</li><li id="9385" class="la lb it kd b ke lj ki lk km ll kq lm ku ln ky lf lg lh li bi translated"><em class="kz">异步执行<em class="kz">的同步</em>代码</em>。</li></ol><p id="66fe" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在本文中，我们将创建一个例子，采用异步Javascript中的概念，并使用React将它们应用到一个实际的例子中。</p><h1 id="3553" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">编写异步方法</h1><p id="9f27" class="pw-post-body-paragraph kb kc it kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">在ES7中，更新引入了使用<code class="fe mr ms mt mu b">async</code> / <code class="fe mr ms mt mu b">await</code>在Javascript中编写异步代码的语法。让我们回顾一下这个特性如何让我们编写异步代码，通过保持异步和同步函数之间的代码结构相同，使<em class="kz">同步读取</em>。</p><p id="ea54" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">给定一个<em class="kz">同步</em>函数<code class="fe mr ms mt mu b">multiplyByTwo</code>，它将一个给定数字的值加倍，如果该数字为负，它将抛出一个错误。</p><pre class="mv mw mx my gt mz mu na nb aw nc bi"><span id="9e95" class="nd lp it mu b gy ne nf l ng nh">const multiplyByTwo = function(num){<br/>  if (num &lt; 0) { <br/>    throw new Error('Cannot be negative');<br/>  } <br/>  return num * 2;<br/>}</span></pre><p id="8bcf" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们可以通过创建处于已解决、拒绝或待定状态的承诺来使功能<em class="kz">异步</em>。我们可以通过创建一个承诺将同步功能转变为异步功能:</p><pre class="mv mw mx my gt mz mu na nb aw nc bi"><span id="8f33" class="nd lp it mu b gy ne nf l ng nh">const multiplyByTwoAsync = function(num) {<br/>  if (number &lt; 0) {<br/>    return <strong class="mu iu">Promise.reject</strong>("Cannot be negative");<br/>  }<br/>  return <strong class="mu iu">Promise.resolve</strong>(number * 2);<br/>};</span></pre><p id="f4b6" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在<code class="fe mr ms mt mu b">async/await</code>之前，我们可以使用<code class="fe mr ms mt mu b">then-catch</code>语法调用异步函数。观察使用<code class="fe mr ms mt mu b">then-catch</code>编写对同步函数的调用与异步调用的代码结构的不同。使用<code class="fe mr ms mt mu b">async/await</code>，我们可以编写与同步调用结构相同的语法:</p><pre class="mv mw mx my gt mz mu na nb aw nc bi"><span id="096e" class="nd lp it mu b gy ne nf l ng nh">// synchronous call<br/>const someSyncCall = function(number) {<br/>   try {<br/>     const result = <strong class="mu iu">multiplyByTwo</strong>(number);<br/>     return result;<br/>   } catch (e) {<br/>     ...<br/>   }<br/>} </span><span id="32ef" class="nd lp it mu b gy ni nf l ng nh">// async-await asynchronous call (reads synchronously!)<br/>const someAsyncCallB = async function(number) {<br/>  try {<br/>    const result = <strong class="mu iu">await multiplyByTwoAsync(number);</strong><br/>    return result;<br/>  } catch (e) {<br/>    ...<br/>  }<br/>};</span><span id="98b9" class="nd lp it mu b gy ni nf l ng nh">// then-catch asynchronous call <br/>const someAsyncCallA = function(number) {<br/>   return <strong class="mu iu">multiplyByTwoAsync</strong>(number)<br/>     .<strong class="mu iu">then</strong>(result =&gt; {<br/>       return result;<br/>   })<br/>     .<strong class="mu iu">catch</strong>(err =&gt; console.log(err));<br/>}</span></pre><p id="3af8" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在继续之前，我们先拿上面的方法来创建一个新方法，依次调用<em class="kz"> someAsyncCallA </em>和<em class="kz"> someAsyncCallB </em>。出于学习目的，我将有目的地混合搭配不同的异步语法:</p><pre class="mv mw mx my gt mz mu na nb aw nc bi"><span id="d00b" class="nd lp it mu b gy ne nf l ng nh">async function asyncCalls(param) {<br/>  const someSyncCall = function(number){ ... }<br/><strong class="mu iu">  </strong>const someAsyncCallB = async function(number) { ... }<strong class="mu iu"><br/>  </strong>async function callComputeAsyncB(number) { ... }</span><span id="7836" class="nd lp it mu b gy ni nf l ng nh"><strong class="mu iu">  return await callComputeAsyncA(param)<br/>        .then(resA =&gt; callComputeAsyncB(resA));<br/></strong>}</span><span id="e2a3" class="nd lp it mu b gy ni nf l ng nh"><strong class="mu iu">// Example: asyncCalls(3) =&gt; 12<br/>// resultA = 3 * 2 = 6<br/>// return resultA * 2 = 12;</strong></span></pre><h1 id="311b" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">React-Setup的练习示例</h1><p id="7816" class="pw-post-body-paragraph kb kc it kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">让我们使用上面的方法为React中的示例定义一个场景。我们有三个组件，一个父组件、一个子组件和一个孙组件。</p><p id="6323" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">我们的目标是观察从父组件到孙组件的事件序列，其中每个子组件都依赖于其父组件的值。下面是我们组件树的设置:</p><pre class="mv mw mx my gt mz mu na nb aw nc bi"><span id="cfad" class="nd lp it mu b gy ne nf l ng nh"><strong class="mu iu">function Parent</strong>() {<br/>  const [current, setCurrent] = useState(1);</span><span id="c63d" class="nd lp it mu b gy ni nf l ng nh">   useEffect(() =&gt; {<br/>    ....<br/>   });</span><span id="b638" class="nd lp it mu b gy ni nf l ng nh">return (<br/>      &lt;div className="Parent"&gt;<br/>          &lt;h1&gt;Parent: {<strong class="mu iu">current</strong>}&lt;/h1&gt;<br/>          <em class="kz">&lt;Child value={</em><strong class="mu iu"><em class="kz">current</em></strong><em class="kz">} /&gt;</em><br/>      &lt;/div&gt;<br/>   );<br/>}</span><span id="2219" class="nd lp it mu b gy ni nf l ng nh"><strong class="mu iu">function Child</strong>({value}) { <br/>  const [childValue, setChildValue] = useState()</span><span id="92f9" class="nd lp it mu b gy ni nf l ng nh">  useEffect(() =&gt; {<br/>    ....<br/>  });<br/>  return (<br/>      &lt;div className="Child"&gt;<br/>        &lt;h1&gt;child val: {<strong class="mu iu">childValue</strong>}&lt;/h1&gt;<br/>          <em class="kz">&lt;GrandChild value={</em><strong class="mu iu">childValue</strong><em class="kz">} /&gt;</em><br/>      &lt;/div&gt;<br/>   );<br/>}</span><span id="c754" class="nd lp it mu b gy ni nf l ng nh"><strong class="mu iu">function GrandChild</strong>({value}) { <br/>  const [grandChildValue, setGrandChildValue] = useState()</span><span id="f191" class="nd lp it mu b gy ni nf l ng nh">  useEffect(() =&gt; {<br/>    ....<br/>  });<br/>  return (<br/>      &lt;div className="GrandChild"&gt;<br/>        &lt;h1&gt;grand val: {<strong class="mu iu">grandChildValue</strong>}&lt;/h1&gt;<br/>      &lt;/div&gt;<br/>   );<br/>}</span></pre><h1 id="ec85" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">用useEffect()处理承诺</h1><p id="1bc1" class="pw-post-body-paragraph kb kc it kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">只要承诺没有解决，使用<code class="fe mr ms mt mu b">await</code>关键字的异步函数将阻止语句执行。使用<code class="fe mr ms mt mu b"><a class="ae nj" href="https://reactjs.org/docs/hooks-reference.html#useeffec" rel="noopener ugc nofollow" target="_blank">useEffect</a></code> <a class="ae nj" href="https://reactjs.org/docs/hooks-reference.html#useeffec" rel="noopener ugc nofollow" target="_blank">钩子</a>，调用异步函数将使组件订阅承诺的未决结果。</p><p id="8602" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在这个例子中，我们将通过每五秒更新一次它在状态中的值来增加父组件中的<code class="fe mr ms mt mu b">current</code>。</p><p id="c445" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">重新审视我们的父组件:</p><pre class="mv mw mx my gt mz mu na nb aw nc bi"><span id="15d5" class="nd lp it mu b gy ne nf l ng nh">function Parent() {<br/>  const [current, <strong class="mu iu">setCurrent</strong>] = useState(0);</span><span id="88fe" class="nd lp it mu b gy ni nf l ng nh">useEffect(() =&gt; {<br/>    const <strong class="mu iu">someasync </strong>= <strong class="mu iu">async </strong>() =&gt; {<br/>      try { <br/>      <strong class="mu iu"> await asyncCalls(current);</strong><br/>       setTimeout(() =&gt; {<br/>         setCurrent(current + 1);<br/>      }, 5000);<br/>      } catch (e) {<br/>         alert(e);<br/>      }<br/>    }<br/>    <strong class="mu iu">someasync()</strong>;<br/>   }, [current, setCurrent]);</span><span id="3f2c" class="nd lp it mu b gy ni nf l ng nh">  return ...<br/>}<br/></span></pre><p id="4984" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果一个组件在承诺解决之前被卸载会发生什么？</p><p id="e87f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">对<code class="fe mr ms mt mu b">setCurrent</code>的调用将导致一个未安装的组件出错。因为我们不能取消承诺，所以我们需要一种方法来有条件地调用生命周期方法。</p><blockquote class="nk nl nm"><p id="5902" class="kb kc kz kd b ke kf kg kh ki kj kk kl nn kn ko kp no kr ks kt np kv kw kx ky im bi translated">除了用于清理的函数之外，效果函数不能返回任何内容。看起来你写了useEffect(async () =&gt; …)或者返回了一个承诺。相反，在你的效果中编写异步函数并立即调用它</p></blockquote><p id="9d3d" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">如果组件被卸载，我们需要防止它设置状态。这可以通过设置一个标志来实现，该标志只允许在我们的组件仍然安装的情况下调用<code class="fe mr ms mt mu b">setCurrent</code>:</p><pre class="mv mw mx my gt mz mu na nb aw nc bi"><span id="e50a" class="nd lp it mu b gy ne nf l ng nh">useEffect(() =&gt; {<br/>    <strong class="mu iu">const loaded = true;</strong><br/>    const someasync<strong class="mu iu"> </strong>= async () =&gt; {<br/>      try { <br/>      <strong class="mu iu"> </strong>await <strong class="mu iu">asyncCalls</strong>(current);<br/>       setTimeout(() =&gt; {<br/>       <strong class="mu iu">  loaded &amp;&amp; setCurrent(current + 1);</strong><br/>      }, 5000);<br/>      } catch (e) {<br/>         alert(e);<br/>      }<br/>    }<br/>    <strong class="mu iu">someasync()</strong>;<br/>   }, [current, setCurrent]);</span></pre><h1 id="952c" class="lo lp it bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">React生命周期中的渲染顺序</h1><p id="1ee8" class="pw-post-body-paragraph kb kc it kd b ke mm kg kh ki mn kk kl km mo ko kp kq mp ks kt ku mq kw kx ky im bi translated">让我们用上面<code class="fe mr ms mt mu b">useEffect</code>的类似实现来更新这篇文章中的其他组件:</p><pre class="mv mw mx my gt mz mu na nb aw nc bi"><span id="8f54" class="nd lp it mu b gy ne nf l ng nh"><strong class="mu iu">function Child</strong>({<strong class="mu iu">value</strong>}) { <br/>  const [childValue, setChildValue] = useState();</span><span id="8b14" class="nd lp it mu b gy ni nf l ng nh">  useEffect(() =&gt; {<br/>    <strong class="mu iu">const loaded = true;</strong><br/>    const someasync<strong class="mu iu"> </strong>= <strong class="mu iu">async </strong>() =&gt; {<br/>      try { <br/>      <strong class="mu iu"> const res = await asyncCalls</strong>(<strong class="mu iu">value</strong>);<br/>       setTimeout(() =&gt; {<br/>       <strong class="mu iu">  loaded &amp;&amp; setChildValue(res);</strong><br/>      }, 1000);<br/>      } catch (e) {<br/>         alert(e);<br/>      }<br/>    }<br/>    <strong class="mu iu">someasync()</strong>;<br/>   }, [<strong class="mu iu">value</strong>, <strong class="mu iu">setChildValue</strong>]);</span><span id="70f8" class="nd lp it mu b gy ni nf l ng nh">  return ...<br/>}</span><span id="bb0a" class="nd lp it mu b gy ni nf l ng nh"><strong class="mu iu">function GrandChild</strong>({<strong class="mu iu">value</strong>}) { <br/>  const [grandChildValue, setGrandChildValue] = useState();</span><span id="eaec" class="nd lp it mu b gy ni nf l ng nh">  useEffect(() =&gt; {<br/>    <strong class="mu iu">const loaded = true;</strong><br/>    const someasync<strong class="mu iu"> </strong>= <strong class="mu iu">async </strong>() =&gt; {<br/>      try { <br/>      <strong class="mu iu"> const res = await asyncCalls</strong>(<strong class="mu iu">value</strong>);<br/>       setTimeout(() =&gt; {<br/>       <strong class="mu iu">  loaded &amp;&amp; setGrandChildValue(res);</strong><br/>      }, 1000);<br/>      } catch (e) {<br/>         alert(e);<br/>      }<br/>    }<br/>    <strong class="mu iu">someasync()</strong>;<br/>   }, [<strong class="mu iu">value</strong>, <strong class="mu iu">setGrandChildValue</strong>]);<br/>   <br/>   return ...</span></pre><p id="0426" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">让我们回顾一下到目前为止我们已经创造了什么。</p><p id="a764" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用<code class="fe mr ms mt mu b">async/await</code>和<code class="fe mr ms mt mu b">useEffect</code>，我们能够创建一系列异步事件，在React生命周期中按照<em class="kz">顺序</em>执行。这是第一次通过时的当前结果:</p><figure class="mv mw mx my gt ju gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/62724e52b9a6192dd0999b42e329bfec.png" data-original-src="https://miro.medium.com/v2/resize:fit:784/format:webp/1*z0hyU1ohpG6j2GfnYWzQIg.png"/></div></figure><p id="c0e7" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">使用Chrome开发工具中的断点，我们可以更好地理解Javascript的异步特性在React生命周期中的表现。</p><p id="44c3" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">当一个组件挂载时，它会先<strong class="kd iu"> <em class="kz">处理所有子节点</em> </strong>而不阻塞执行。任何未完成的承诺都将被添加到调用堆栈中，并可能仅在承诺完成后触发一个设置组件状态的调用。</p><p id="0948" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在组件的初始渲染中，回想一下我们有一个设置为五秒间隔的计时器，父组件中的<code class="fe mr ms mt mu b">current</code>的值设置为1:</p><pre class="mv mw mx my gt mz mu na nb aw nc bi"><span id="dc52" class="nd lp it mu b gy ne nf l ng nh"><strong class="mu iu">function Parent</strong>() {<br/>  const [current, setCurrent] = useState(1);</span></pre><p id="02a4" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">随着子组件的呈现，每个子组件都将创建一个对调用我们的异步方法时创建的承诺的新引用:</p><pre class="mv mw mx my gt mz mu na nb aw nc bi"><span id="e112" class="nd lp it mu b gy ne nf l ng nh">// Reference to Child/GrandChild <br/>useEffect(() =&gt; {<br/>    <strong class="mu iu">const loaded = true;</strong><br/>    const someasync<strong class="mu iu"> </strong>= <strong class="mu iu">async </strong>() =&gt; {<br/>      try { <br/>      <strong class="mu iu"> const res = await asyncCalls</strong>(<strong class="mu iu">value</strong>);</span></pre><p id="bf34" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">一旦任务完成，它将把结果或错误传递给对<code class="fe mr ms mt mu b"><em class="kz">asyncCalls</em></code>的调用中的承诺。(如果异步函数完成得很快，结果马上就出来了。)</p><p id="baed" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">研究堆栈中的调用，其中子值为4，孙值为NaN，从呈现序列中，我们可以确认child中的已解决状态。在孙儿中，来自效果的异步调用还没有完成，在孙儿中体现为<em class="kz">楠</em>。</p><div class="mv mw mx my gt ab cb"><figure class="nr ju ns nt nu nv nw paragraph-image"><img src="../Images/37e271b6bf967ce0080f6ae43fd1641b.png" data-original-src="https://miro.medium.com/v2/resize:fit:776/format:webp/1*EMNhI-pBzlmFgbyvCinmaw.png"/></figure><figure class="nr ju nx nt nu nv nw paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><img src="../Images/67c5311f8e782443b74f56af30d487a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1128/format:webp/1*u3tOmIXoopku0pUAsQUJiw.png"/></div></figure></div><p id="4f5c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">在解析我们示例的子代中的所有承诺时，您应该看到以下值显示在它们各自的字段中。这个序列将每五秒钟重新评估整个组件树。</p><div class="mv mw mx my gt ab cb"><figure class="nr ju ny nt nu nv nw paragraph-image"><img src="../Images/3e49b133421df8e69258bd4a8aa4be77.png" data-original-src="https://miro.medium.com/v2/resize:fit:698/format:webp/1*FeiV5E1KqOlmOJdCOUD77Q.png"/></figure><figure class="nr ju nz nt nu nv nw paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><img src="../Images/f9a4619a2b694df75eb80677bcdd3b5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1256/format:webp/1*0kzHwvxZwGZQfGvBgzvb_w.png"/></div></figure></div><p id="b37f" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">只介绍了<code class="fe mr ms mt mu b">useEffect</code>，我鼓励您扩展React中其他生命周期挂钩所涉及的概念。使用这篇文章中的例子，在开发者工具中自己尝试一下。</p><p id="fe5c" class="pw-post-body-paragraph kb kc it kd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky im bi translated">感谢阅读！</p><div class="oa ob gp gr oc od"><a href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Introducing" rel="noopener  ugc nofollow" target="_blank"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd iu gy z fp oi fr fs oj fu fw is bi translated">异步JavaScript简介</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">在这篇文章中，我们简要回顾了与同步JavaScript相关的问题，并先看一看一些…</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">developer.mozilla.org</p></div></div><div class="om l"><div class="on l oo op oq om or jz od"/></div></div></a></div><div class="oa ob gp gr oc od"><a href="https://javascript.info/dom-nodes" rel="noopener  ugc nofollow" target="_blank"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd iu gy z fp oi fr fs oj fu fw is bi translated">DOM树</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">HTML文档的支柱是标签。根据文档对象模型(DOM ),每个HTML标签都是一个对象…</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">javascript.info</p></div></div><div class="om l"><div class="os l oo op oq om or jz od"/></div></div></a></div><div class="oa ob gp gr oc od"><a href="https://docstore.mik.ua/orelly/webprog/jscript/ch12_03.htm" rel="noopener  ugc nofollow" target="_blank"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd iu gy z fp oi fr fs oj fu fw is bi translated">JavaScript程序的执行(JavaScript:权威指南，第4版)</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">上一节讨论了将JavaScript代码集成到HTML文件中的机制。现在我们继续…</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">docstore.mik.ua</p></div></div></div></a></div><div class="oa ob gp gr oc od"><a href="https://blog.avenuecode.com/understanding-the-javascript-concurrency-model" rel="noopener  ugc nofollow" target="_blank"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd iu gy z fp oi fr fs oj fu fw is bi translated">理解JavaScript并发模型</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">您可能听说过诸如“V8”、“事件循环”、“调用堆栈”和“回调队列”等术语在这篇文章中，我们…</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">blog.avenuecode.com</p></div></div><div class="om l"><div class="ot l oo op oq om or jz od"/></div></div></a></div></div></div>    
</body>
</html>