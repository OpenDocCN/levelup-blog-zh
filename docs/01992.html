<html>
<head>
<title>Asynchronous Callbacks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">异步回调</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/asynchronous-callbacks-a7e146336035?source=collection_archive---------19-----------------------#2020-02-10">https://levelup.gitconnected.com/asynchronous-callbacks-a7e146336035?source=collection_archive---------19-----------------------#2020-02-10</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><figure class="is it gp gr iu iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi ir"><img src="../Images/93786b9255d05d4b525fc872c9b429af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*j2a51E77W6KmbW_z"/></div></div><figcaption class="jc jd gj gh gi je jf bd b be z dk translated">戈兰·艾沃斯在<a class="ae jg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><div class=""/><p id="f88c" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">JavaScript是一种单线程语言。这意味着计算机从上到下读取一个JS文档。因此，代码从页面的顶部到底部执行。这被称为同步代码。只要函数快速有效地运行，这就很好，但是如果函数需要几秒钟才能运行，会发生什么呢？</p><p id="15aa" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">运行时间长的函数可能会阻碍后面的其他函数进程。这被称为阻塞代码。如果发生这种情况，页面或应用程序将滞后，客户/客户将会丢失。解决这个问题的一种方法是编写异步代码。</p><p id="4d4d" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在异步代码中，需要花费大量时间运行的函数可以在“后台”运行，而其他更快的函数在“前台”运行。这样，页面的其余功能可以运行和操作。解决这个问题的一个方法是回调。</p><p id="b18c" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">回调函数是作为参数传递给另一个函数的函数。回调将在父函数完成后运行。为了更好地理解这一点，我决定创建一个异步回调示例。我创建了两个示例数据的基本JSON文件。然后我创建了两个函数:一个从JSON文件中检索数据(一个名为loadJSON的XMLHttpRequest ),另一个将数据放在html页面上(postData)。</p><h1 id="fcee" class="le lf jj bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated"><strong class="ak">示例数据和功能</strong></h1><p id="a51d" class="pw-post-body-paragraph kg kh jj ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><strong class="ki jk"> Data.json — </strong>对象数组，带有字符串化的名称和消息的关键字</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="be7f" class="mq lf jj mm b gy mr ms l mt mu"><strong class="mm jk">[<br/>  { “name”: “My Name”, “message”: “My message” },<br/>  { “name”: “UR Name”, “message”: “UR message” },<br/>  { “name”: “Our Name”, “message”: “Our message” }<br/>]</strong></span></pre><p id="8e1a" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki jk"> Data1.json — </strong>要从中获取信息的第二个json数据文件</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="ff4d" class="mq lf jj mm b gy mr ms l mt mu"><strong class="mm jk">[<br/>  { "name": "No Name", "message": "No message" },<br/>  { "name": "Any Name", "message": "Any message" },<br/>  { "name": "Specific Name", "message": "Specific message" }<br/>]</strong></span></pre><p id="fe7b" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki jk"> PostData — </strong>在DOM上发布数据的函数。来自JSON文件的数据需要被解析成JavaScript可用的数据。然后数据被循环并连接到一个名为post的字符串文字上。然后，post字符串显示在DOM上的一个div标签中，该标签包含“app”的id。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="6ac8" class="mq lf jj mm b gy mr ms l mt mu"><strong class="mm jk">const postData = (res) =&gt; {<br/>  let data = JSON.parse(res);<br/>  let post = "";<br/>  data.forEach(ele =&gt; post +=<br/>    `&lt;h3&gt;${ele.name}&lt;/h3&gt;<br/>    &lt;p&gt;&lt;i&gt;${ele.message}&lt;/i&gt;&lt;/p&gt;`);<br/>  document.getElementById('app').innerHTML += post;<br/>};</strong></span></pre><p id="71e3" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki jk"> LoadJSON — </strong>从JSON文件中获取数据的函数(注意函数参数中的回调)</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="1726" class="mq lf jj mm b gy mr ms l mt mu"><strong class="mm jk">const loadJSON = (file, </strong>callback<strong class="mm jk">) =&gt; {<br/>  let xobj = new XMLHttpRequest();<br/>  xobj.open('GET', `${file}`, true);<br/>  xobj.onreadystatechange = () =&gt; {<br/>    if (xobj.readyState === 4 &amp;&amp; xobj.status === 200) {<br/>      </strong>callback<strong class="mm jk">(xobj.responseText);<br/>    }<br/>  };<br/>  xobj.send(null);<br/>};</strong></span></pre><p id="3ee8" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki jk">函数调用— </strong>此处，loadJSON通过调用postData的回调来调用，而包含第二个postData的第二个loadJSON在第二个回调中被调用。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="653f" class="mq lf jj mm b gy mr ms l mt mu"><strong class="mm jk">loadJSON('data.json', (res) =&gt; {<br/>  postData(res);<br/>  loadJSON('data1.json',(res) =&gt; {<br/>    postData(res);<br/>  })<br/>});</strong></span></pre><p id="e3cd" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki jk">结果— </strong>两个数据集都已加载并呈现到页面上。控制台上未记录任何错误。</p><figure class="mh mi mj mk gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mv"><img src="../Images/7b9c6c0888ac20b0ff6430102de4ad3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZgIF2VluTTQnsWh-"/></div></div></figure><figure class="mh mi mj mk gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mv"><img src="../Images/26cfaa7e7dde09c530fb0ac1a11d6b53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2NXjn1AXfNpHckpr"/></div></div></figure><p id="f7d5" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki jk">重构— </strong> PostData函数被重构为接受回调。添加了一个默认的回调函数done，这样控制台将记录“Done！”当所有的回调都完成时。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="4460" class="mq lf jj mm b gy mr ms l mt mu"><strong class="mm jk">const postData = (res, callback = done) =&gt; {<br/>  let data = JSON.parse(res);<br/>  let post = "";<br/>  data.forEach(ele =&gt; post +=<br/>    `&lt;h3&gt;${ele.name}&lt;/h3&gt;<br/>    &lt;p&gt;&lt;i&gt;${ele.message}&lt;/i&gt;&lt;/p&gt;`);<br/>  document.getElementById('app').innerHTML += post;<br/>  callback();<br/>};</strong></span></pre><p id="a67b" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki jk">重构函数的调用— </strong>在这里，loadJSON通过调用postData的回调来调用，postData有一个调用另一个loadJSON的回调，load JSON也有一个调用另一个postData的回调。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="f4ff" class="mq lf jj mm b gy mr ms l mt mu"><strong class="mm jk">loadJSON('data.json',<br/>  (res) =&gt; postData(res,<br/>    () =&gt; loadJSON('data1.json',<br/>      (res) =&gt; postData(res))));</strong></span></pre><p id="b2ad" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><strong class="ki jk">结果</strong>(仍然有效)添加默认的done功能防止了任何错误被记录在控制台上。</p><figure class="mh mi mj mk gt iv gh gi paragraph-image"><div role="button" tabindex="0" class="iw ix di iy bf iz"><div class="gh gi mv"><img src="../Images/b4d49b1a1af5676f7948bd37a39a37e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dErlUQ5DaZbMMDs1"/></div></div></figure><p id="84a1" class="pw-post-body-paragraph kg kh jj ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">总结这篇博客，JavaScript是一种同步运行的单线程语言。避开同步代码的方法是运行异步代码。运行异步代码的一种方法是使用回调。回调是作为参数传递并在另一个函数内部调用的函数。回调是解决长时间运行(可能阻塞)代码的好方法。</p></div></div>    
</body>
</html>