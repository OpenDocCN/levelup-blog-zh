<html>
<head>
<title>Create Flag Using Bitmask and Bitwise Operator in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Go中使用位掩码和位运算符创建标志</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/create-flag-using-bitmask-and-bitwise-operator-in-go-e3ae097f4098?source=collection_archive---------2-----------------------#2022-07-15">https://levelup.gitconnected.com/create-flag-using-bitmask-and-bitwise-operator-in-go-e3ae097f4098?source=collection_archive---------2-----------------------#2022-07-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/382a2ae444dc1cd30ce94097bda08af5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5lcEDuOsvZkCiB_i"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><em class="kc">照片由</em><a class="ae kd" href="https://unsplash.com/@swimstaralex" rel="noopener ugc nofollow" target="_blank"><em class="kc">@ swimtaralex</em></a><em class="kc">在Unsplash上</em></figcaption></figure><h1 id="91fa" class="ke kf iq bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">介绍</h1><p id="2f3c" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">我重温了一些大学笔记，发现在大学第一年，在算法和编程课程中，提到了按位运算符，但没有突出显示。要么是我没有写那个特定话题的笔记(<em class="ma">我第二学期就不写笔记了</em>)要么是讲师没有解释任何用法。但后来我发现它对于位屏蔽非常有用。例如，Unix的文件访问控制使用位掩码来表示访问:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="a29a" class="mk kf iq mg b gy ml mm l mn mo">000 =&gt; 0 =&gt; can't access anything<br/>001 =&gt; 1 =&gt; can only execute<br/>010 =&gt; 2 =&gt; can only read<br/>011 =&gt; 3 =&gt; can execute+read<br/>100 =&gt; 4 =&gt; can only write<br/>101 =&gt; 5 =&gt; can execute+write<br/>110 =&gt; 6 =&gt; can read+write<br/>111 =&gt; 7 =&gt; can execute+read+write</span></pre><p id="f507" class="pw-post-body-paragraph lc ld iq le b lf mp lh li lj mq ll lm ln mr lp lq lr ms lt lu lv mt lx ly lz ij bi translated">所有这些组合可以仅用3位来构造。如您所见，位掩码使用多组位来表示是否给予了特定的访问权限。如果为0，表示不给予特定的访问权限，否则给予。在本文中，您将学习如何在Golang中实现位屏蔽及其操作。</p><h1 id="7779" class="ke kf iq bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">密码</h1><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="0885" class="mk kf iq mg b gy ml mm l mn mo">package main</span><span id="46a2" class="mk kf iq mg b gy mu mm l mn mo">import "fmt"</span><span id="8922" class="mk kf iq mg b gy mu mm l mn mo">type Permission uint8</span><span id="657f" class="mk kf iq mg b gy mu mm l mn mo">const (<br/> // 1<br/> PermissionExecute Permission = 1 &lt;&lt; iota</span><span id="5c2e" class="mk kf iq mg b gy mu mm l mn mo">// 2<br/> PermissionRead</span><span id="7d41" class="mk kf iq mg b gy mu mm l mn mo">// 4<br/> PermissionWrite<br/>)</span><span id="0070" class="mk kf iq mg b gy mu mm l mn mo">const (<br/> PermissionAll = PermissionExecute | PermissionRead | PermissionWrite<br/>)</span><span id="0fa6" class="mk kf iq mg b gy mu mm l mn mo">func Set(p, flag Permission) Permission {<br/> return p | flag<br/>}</span><span id="ed85" class="mk kf iq mg b gy mu mm l mn mo">func Clear(p, flag Permission) Permission {<br/> return p &amp;^ flag<br/>}</span><span id="bc0a" class="mk kf iq mg b gy mu mm l mn mo">func HasAll(p, flag Permission) bool {<br/> return p&amp;flag == flag<br/>}</span><span id="7bc4" class="mk kf iq mg b gy mu mm l mn mo">func HasOneOf(p, flag Permission) bool {<br/> return p&amp;flag != 0<br/>}</span><span id="563d" class="mk kf iq mg b gy mu mm l mn mo">func main() {<br/> var p Permission<br/>    // you can use Set/Clear(p, PermissionExecute|PermissionRead|PermissionWrite) to set multiple bits<br/> p = Set(p, PermissionAll)<br/> p = Clear(p, PermissionRead)</span><span id="f7da" class="mk kf iq mg b gy mu mm l mn mo">// false, because PermissionRead is cleared<br/> hasExecuteAndRead := HasAll(p, PermissionExecute|PermissionRead)</span><span id="4b36" class="mk kf iq mg b gy mu mm l mn mo">// true, because PermissionExecute and PermissionWrite are set<br/> hasExecuteAndWrite := HasAll(p, PermissionExecute|PermissionWrite)</span><span id="06e3" class="mk kf iq mg b gy mu mm l mn mo">// true, because PermissionExecute is set even though PermissionRead is cleared<br/> hasExecuteOrRead := HasOneOf(p, PermissionExecute|PermissionRead)</span><span id="686c" class="mk kf iq mg b gy mu mm l mn mo">fmt.Println(hasExecuteAndRead, hasExecuteAndWrite, hasExecuteOrRead)<br/>}</span></pre><p id="ba9b" class="pw-post-body-paragraph lc ld iq le b lf mp lh li lj mq ll lm ln mr lp lq lr ms lt lu lv mt lx ly lz ij bi translated">让我们逐行进行解释。</p><h1 id="f9a7" class="ke kf iq bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">一组</h1><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="53f1" class="mk kf iq mg b gy ml mm l mn mo">var p Permission // has no permission 000<br/>p = Set(p, PermissionAll) // set all permission 111</span><span id="557c" class="mk kf iq mg b gy mu mm l mn mo">// 000 (current permission)<br/>// 111 (PermissionAll)<br/>// --- OR<br/>// 111</span></pre><h1 id="dc54" class="ke kf iq bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">清楚的</h1><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="0f94" class="mk kf iq mg b gy ml mm l mn mo">// clear the bit of PermissionRead (010)<br/>p = Clear(p, PermissionRead)</span><span id="1939" class="mk kf iq mg b gy mu mm l mn mo">// reverse the PermissionRead first<br/>// 010<br/>// ---- NOT<br/>// 101 (NOT result)</span><span id="f5b9" class="mk kf iq mg b gy mu mm l mn mo">// 111 (current permission)<br/>// 101 (NOT result)<br/>// --- AND<br/>// 101</span></pre><blockquote class="mv mw mx"><p id="3281" class="lc ld ma le b lf mp lh li lj mq ll lm my mr lp lq mz ms lt lu na mt lx ly lz ij bi translated">使用BITCLEAR (AND NOT)运算符而不是NOT(在本例中是XOR)运算符是很重要的。BITCLEAR总是将该位设置为0，因为它首先使用NOT反转标志，然后使用AND。同时，NOT是反转位，所以如果你不操作两次，它会切换回来。例如，请参见下面的片段。</p></blockquote><h1 id="9772" class="ke kf iq bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">切换与清除</h1><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="d8b4" class="mk kf iq mg b gy ml mm l mn mo">// toggling using NOT/XOR<br/>foo := PermissionAll<br/>fmt.Printf("Set All %03b\n", foo) // 111<br/>foo ^= PermissionRead<br/>fmt.Printf("Toggle %03b\n", foo) // 101<br/>foo ^= PermissionRead<br/>fmt.Printf("Toggle %03b\n", foo) // 111 it toggles back!</span><span id="05ab" class="mk kf iq mg b gy mu mm l mn mo">// clearing using BITCLEAR<br/>bar := PermissionAll<br/>fmt.Printf("Set All %03b\n", bar) // 111<br/>bar &amp;^= PermissionRead<br/>fmt.Printf("Clear %03b\n", bar) // 101<br/>bar &amp;^= PermissionRead<br/>fmt.Printf("Clear %03b\n", bar) // 101</span></pre><h1 id="72c7" class="ke kf iq bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">哈索尔</h1><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="d219" class="mk kf iq mg b gy ml mm l mn mo">// check whether has both Execute AND Read permission<br/>hasExecuteAndRead := HasAll(p, PermissionExecute|PermissionRead) // false</span><span id="3047" class="mk kf iq mg b gy mu mm l mn mo">// PermissionExecute|PermissionRead<br/>// 001 (PermissionExecute)<br/>// 010 (PermissionRead)<br/>// --- OR<br/>// 011 (PermissionRead+PermissionExecute)</span><span id="738e" class="mk kf iq mg b gy mu mm l mn mo">// check whether has both Execute AND Read permission<br/>// 101 (current permission)<br/>// 011 (PermissionRead+PermissionExecute)<br/>// --- AND<br/>// 001 (PermissionExecute)</span><span id="1daf" class="mk kf iq mg b gy mu mm l mn mo">// 001 != 011 so it doesn't have both Execute AND Read permission</span><span id="98cc" class="mk kf iq mg b gy mu mm l mn mo">// check whether has both Execute AND Write permission<br/>hasExecuteAndWrite := HasAll(p, PermissionExecute|PermissionWrite)</span><span id="24b9" class="mk kf iq mg b gy mu mm l mn mo">// PermissionExecute|PermissionWrite<br/>// 001 (PermissionExecute)<br/>// 100 (PermissionWrite)<br/>// --- OR<br/>// 101 (Write+Execute)</span><span id="30b9" class="mk kf iq mg b gy mu mm l mn mo">// check whether has both Execute AND Write permission<br/>// 101 (current permission)<br/>// 101 (PermissionWrite+PermissionExecute)<br/>// --- AND<br/>// 101 (PermissionWrite+PermissionExecute)</span><span id="83d7" class="mk kf iq mg b gy mu mm l mn mo">// 101 == 101 so it has both Execute AND Write permission</span></pre><h1 id="dd49" class="ke kf iq bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">HasOneOf</h1><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="2c04" class="mk kf iq mg b gy ml mm l mn mo">// check whether has either Execute OR Read permission<br/>hasExecuteOrRead := HasOneOf(p, PermissionExecute|PermissionRead)</span><span id="48b1" class="mk kf iq mg b gy mu mm l mn mo">// PermissionExecute|PermissionRead<br/>// 001 (PermissionExecute)<br/>// 010 (PermissionRead)<br/>// --- OR<br/>// 011 (PermissionRead+PermissionExecute)</span><span id="5bac" class="mk kf iq mg b gy mu mm l mn mo">// check whether has either Execute OR Read permission<br/>// 101 (current permission)<br/>// 011 (PermissionRead+PermissionExecute)<br/>// --- AND<br/>// 001 (PermissionExecute)</span><span id="b1ad" class="mk kf iq mg b gy mu mm l mn mo">// 001 != 0 so it has either Execute OR Read permission</span></pre><h1 id="f085" class="ke kf iq bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">需要关注的事项</h1><p id="258c" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">您也可以将位掩码存储在您的数据库中，但是在您的逻辑中使用<code class="fe nb nc nd mg b">iota</code>可能不是一个好主意。根据上面的代码，假设您想要删除<code class="fe nb nc nd mg b">PermissionRead</code>。那么<code class="fe nb nc nd mg b">PermissionWrite</code>将由2而不是4来表示。为了避免这种情况，您可能希望为您的权限设置一个<a class="ae kd" href="https://cs.opensource.google/go/x/tools/+/master:go/packages/packages.go;l=96-117;drc=db8f89b397771c885c6218de3f383d800d72e62a" rel="noopener ugc nofollow" target="_blank">弃用标志</a>，而不是将其从代码中完全移除。或者，作为一种选择，你可以手动输入号码，但是如果你有很多权限，这又是一个麻烦。</p><h1 id="57c7" class="ke kf iq bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb bi translated">结论</h1><p id="39bb" class="pw-post-body-paragraph lc ld iq le b lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">在这种情况下，位屏蔽是实现访问控制的有用工具。您只用1个字节实现了访问控制，因为您只需要使用<code class="fe nb nc nd mg b">uint8</code>。例如，如果您使用布尔变量集来表示访问控制，您需要不止一个变量，并且需要不止一个字节来存储。</p><p id="690e" class="pw-post-body-paragraph lc ld iq le b lf mp lh li lj mq ll lm ln mr lp lq lr ms lt lu lv mt lx ly lz ij bi translated">感谢您的阅读！</p></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><p id="1f42" class="pw-post-body-paragraph lc ld iq le b lf mp lh li lj mq ll lm ln mr lp lq lr ms lt lu lv mt lx ly lz ij bi translated"><em class="ma">原载于2022年7月15日</em><a class="ae kd" href="https://clavinjune.dev/en/blogs/create-flag-using-bitmask-and-bitwise-operator-in-go/" rel="noopener ugc nofollow" target="_blank"><em class="ma">https://clavinjune . dev</em></a><em class="ma">。</em></p></div></div>    
</body>
</html>