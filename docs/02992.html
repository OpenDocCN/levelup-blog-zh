<html>
<head>
<title>Node.js Best Practices — Error Handling and Logging</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js最佳实践—错误处理和日志记录</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/node-js-best-practices-error-handling-and-logging-341fc4ce6a72?source=collection_archive---------8-----------------------#2020-04-14">https://levelup.gitconnected.com/node-js-best-practices-error-handling-and-logging-341fc4ce6a72?source=collection_archive---------8-----------------------#2020-04-14</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/a7d82f27e86d7535f07b2fbb9205925f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*m5MCIlkRK238MORB"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@honeyfangs?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">蜜牙</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="9e43" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">Node.js是用JavaScript编写应用程序的流行运行时。为了使维护它们变得更容易，我们必须为人们设定一些准则来遵循。</p><p id="92c0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将研究如何记录API并优雅地退出进程。</p><h1 id="e043" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">使用GraphQL记录API错误</h1><p id="d293" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以使用GraphQL库来构建我们的API。这为我们提供了一个查询数据的沙盒。它还提供了强类型，只返回我们想要的。</p><p id="1554" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">它还提供了模式和注释，这样我们就可以在不添加更多文档的情况下记录我们的API。</p><p id="af88" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了创建一个GraphQL API，我们可以使用<code class="fe mh mi mj mk b">graphql</code>和<code class="fe mh mi mj mk b">express-graphql</code>包来创建一个GraphQL API。我们通过运行以下命令来安装它:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="839e" class="mt lf it mk b gy mu mv l mw mx">npm i express-graphql graphql</span></pre><p id="21d0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们可以通过编写以下代码来创建一个简单的GraphQL API:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="a5d2" class="mt lf it mk b gy mu mv l mw mx">const express = require('express');<br/>const bodyParser = require('body-parser');<br/>const graphqlHTTP = require('express-graphql');<br/>const { buildSchema } = require('graphql');<br/>const app = express();</span><span id="b861" class="mt lf it mk b gy my mv l mw mx">app.use(bodyParser.json());<br/>app.use(bodyParser.urlencoded({ extended: true }));</span><span id="a1f3" class="mt lf it mk b gy my mv l mw mx">const schema = buildSchema(`<br/>  type Query {<br/>    quoteOfTheDay: String<br/>  }<br/>`);</span><span id="6566" class="mt lf it mk b gy my mv l mw mx">const root = {<br/>  quoteOfTheDay: () =&gt; {<br/>    return 'hello';<br/>  },<br/>};</span><span id="f0c7" class="mt lf it mk b gy my mv l mw mx">app.use('/graphql', graphqlHTTP({<br/>  schema: schema,<br/>  rootValue: root,<br/>  graphiql: true,<br/>}));</span><span id="1ce6" class="mt lf it mk b gy my mv l mw mx">app.listen(3000, () =&gt; console.log('server started'));</span></pre><p id="b4c8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们应该可以去<code class="fe mh mi mj mk b">/graphql</code>测试我们的<code class="fe mh mi mj mk b">quotwOfTheDay</code>查询。由于强键入，自动完成应该是可用的。</p><h1 id="69a9" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">当出现未知错误时，优雅地退出进程</h1><p id="840f" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">当未知错误发生时，我们应该退出进程，因为我们不知道它失败的原因。一种常见的做法是使用流程管理工具(如Forever或PM2)重启流程。</p><p id="c8a4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在错误的状态下继续运行应用程序是一个坏主意。</p><h1 id="270d" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">使用成熟的日志记录器来增加错误可见性</h1><p id="bf6e" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">为了更容易发现错误，我们可以使用类似Winston、Bunyan、Log4js或Pino的日志程序来记录应用程序中发生的活动。例如，我们可以使用Winston和<code class="fe mh mi mj mk b">express-winston</code>包将日志添加到Express应用程序中，如下所示:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="42ff" class="mt lf it mk b gy mu mv l mw mx">const express = require('express');<br/>const bodyParser = require('body-parser');<br/>const winston = require('winston');<br/>const expressWinston = require('express-winston');</span><span id="07ba" class="mt lf it mk b gy my mv l mw mx">const app = express();<br/>app.use(bodyParser.json());<br/>app.use(bodyParser.urlencoded({ extended: true }));</span><span id="2f4c" class="mt lf it mk b gy my mv l mw mx">app.use(expressWinston.logger({<br/>  transports: [<br/>    new winston.transports.Console()<br/>  ],<br/>  format: winston.format.combine(<br/>    winston.format.colorize(),<br/>    winston.format.json()<br/>  ),<br/>  meta: true,<br/>  msg: "HTTP {{req.method}} {{req.url}}",<br/>  expressFormat: true,<br/>  colorize: false,<br/>  ignoreRoute: function (req, res) { return false; }<br/>}));</span><span id="1d88" class="mt lf it mk b gy my mv l mw mx">app.get('/', (req, res, next) =&gt; {<br/>  res.send('hello')<br/>});</span><span id="e0af" class="mt lf it mk b gy my mv l mw mx">app.get('/foo', (req, res, next) =&gt; {<br/>  try {<br/>    throw new Error('error')<br/>    res.send('hello')<br/>  } catch (err) {<br/>    next(err)<br/>  }<br/>});</span><span id="39a6" class="mt lf it mk b gy my mv l mw mx">app.use((err, req, res, next) =&gt; {<br/>  res.send('error occurred')<br/>})<br/>app.listen(3000, () =&gt; console.log('server started'));</span></pre><p id="db80" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们只是通过使用<code class="fe mh mi mj mk b">expressWinston.logger</code>功能将记录器直接添加到我们的应用程序中。</p><h1 id="a7bc" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">使用我们最喜欢的测试框架测试错误流</h1><p id="a8de" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">依靠手工测试既慢又容易出错。因此，我们应该在我们的应用程序中添加自动化测试。它让我们通过运行几秒钟内运行的代码来检查正面和错误的场景。</p><p id="0e80" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">有许多测试框架，如Mocha、Chai和Jest，可以为我们做到这一点。</p><h1 id="e551" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">使用APM产品发现错误和停机时间</h1><p id="08c6" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们可以使用停机时间和性能监控产品来监控我们的应用程序的状态。</p><p id="7717" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于Express应用程序，我们可以添加<code class="fe mh mi mj mk b">express-status-monitor</code>包来查看我们的应用程序的状态，包括CPU和内存使用情况、响应时间、每秒请求数等等。</p><p id="7bd6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们只需运行以下命令来安装软件包:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="5f38" class="mt lf it mk b gy mu mv l mw mx">npm i <!-- -->express-status-monitor</span></pre><p id="656c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们可以通过编写以下代码来使用它:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="2188" class="mt lf it mk b gy mu mv l mw mx">const express = require('express');<br/>const bodyParser = require('body-parser');</span><span id="0ca5" class="mt lf it mk b gy my mv l mw mx">const app = express();<br/>app.use(require('express-status-monitor')());<br/>app.use(bodyParser.json());<br/>app.use(bodyParser.urlencoded({ extended: true }));</span><span id="9485" class="mt lf it mk b gy my mv l mw mx">app.get('/', (req, res, next) =&gt; {<br/>  res.send('hello')<br/>});</span><span id="56ae" class="mt lf it mk b gy my mv l mw mx">app.listen(3000, () =&gt; console.log('server started'));</span></pre><p id="15a5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们只是用<code class="fe mh mi mj mk b">app.use(require(‘express-status-monitor’)());</code>把这个包直接放到我们的应用程序中。</p><p id="5cdf" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，当我们转到<code class="fe mh mi mj mk b">/status</code>页面时，我们将看到列出的所有性能和运行状况指标。</p><figure class="ml mm mn mo gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/e89acd76a349cc7666f67167aefcf559.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*sReX3xl9eaIIfqvJ"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@v2osk?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> v2osk </a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="9795" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">捕捉未处理的承诺拒绝和错误事件</h1><p id="fe07" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">未处理的承诺拒绝应该被捕获。因此，我们应该总是为常规承诺添加一个<code class="fe mh mi mj mk b">catch</code>回调，或者为被拒绝的承诺添加<code class="fe mh mi mj mk b">catch</code>阻塞。</p><p id="5022" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们还应该订阅<code class="fe mh mi mj mk b">process.unhandledRejection</code>来处理错误事件。例如，如果我们试图访问一个不存在的文件并且失败了，我们应该写一些东西:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="5b42" class="mt lf it mk b gy mu mv l mw mx">const fs = require('fs')<br/>const stream = fs.createReadStream('does-not-exist')</span><span id="53c2" class="mt lf it mk b gy my mv l mw mx">process.on('unhandledRejection', (reason, promise) =&gt; {<br/>  console.log(`Unhandled Rejection at: ${reason.stack || reason}`)<br/>})</span></pre><p id="62a9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们处理在不使应用程序崩溃的情况下试图访问一个找不到的文件所引发的错误。</p><p id="b919" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了捕捉拒绝承诺的错误，我们写:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="c75d" class="mt lf it mk b gy mu mv l mw mx">Promise.reject('error')<br/>.catch(err=&gt; console.log(err))</span></pre><p id="3212" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">或者:</p><pre class="ml mm mn mo gt mp mk mq mr aw ms bi"><span id="2ea8" class="mt lf it mk b gy mu mv l mw mx">(async()=&gt;{<br/>  try {<br/>    await Promise.reject('error')<br/>  }<br/>  catch(ex){<br/>    console.log(ex);<br/>  }<br/>})();</span></pre><h1 id="f7a0" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="556a" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">我们应该捕捉代码中的错误并优雅地处理它们。此外，我们应该用记录器记录我们应用程序中的活动，并用监控工具观察我们应用程序的健康和性能。我们应用程序的文档也非常重要。</p></div></div>    
</body>
</html>