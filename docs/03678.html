<html>
<head>
<title>Adopting Better JavaScript Code Style — Error Handling and Comparisons</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">采用更好的JavaScript代码风格——错误处理和比较</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/adopting-better-javascript-code-style-error-handling-and-comparisons-5c399a57da5b?source=collection_archive---------6-----------------------#2020-05-22">https://levelup.gitconnected.com/adopting-better-javascript-code-style-error-handling-and-comparisons-5c399a57da5b?source=collection_archive---------6-----------------------#2020-05-22</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/19fc069495268bac0d5a87391f7230d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BskOetsHv9LD1aEC"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">梅森·哈森在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="52a7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们编写JavaScript的方式总是可以改进的。</p><p id="1eba" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在本文中，我们将看看如何通过改进代码中使用的基本语法来改进我们的代码风格。</p><h1 id="828a" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">错误处理</h1><p id="35f0" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">错误处理应该尽可能简单。如果我们在运行一个函数时遇到一个错误，我们应该抛出一个错误。</p><p id="d75b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果遇到无效值，我们可以抛出一个错误，如下所示:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="3639" class="mq lf it mm b gy mr ms l mt mu">const greet = (name) =&gt; {<br/>  if (typeof name !== 'string') {<br/>    throw new Error('name not provided');<br/>  }<br/>  return `hi ${name}`;<br/>}</span></pre><p id="44c4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们检查<code class="fe mv mw mx mm b">name</code>是否是一个字符串。如果不是，那么我们抛出一个错误。</p><p id="914e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">否则，我们返回带有问候语的字符串。</p><p id="15ee" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这比返回错误值的替代方法要好:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="5568" class="mq lf it mm b gy mr ms l mt mu">const greet = (name) =&gt; {<br/>  if (typeof name !== 'string') {<br/>    return '';<br/>  }<br/>  return `hi ${name}`;<br/>}</span></pre><p id="385a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们返回了一个空字符串，而不是抛出一个错误，所以我们使用函数和用户对开发人员隐藏了错误。</p><p id="1087" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">很容易忽略错误值，因为它们并不明显。与错误不同，错误会立即显示在控制台中，我们在调试之前看不到错误值。</p><p id="a88e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这使得调试更加困难，因为错误值不会显示在控制台中。</p><p id="6891" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们需要处理错误，我们可以如下使用<code class="fe mv mw mx mm b">try...catch</code>块:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="5783" class="mq lf it mm b gy mr ms l mt mu">const greet = (name) =&gt; {<br/>  if (typeof name !== 'string') {<br/>    throw new Error('name not provided');<br/>  }<br/>  return `hi ${name}`;<br/>}</span><span id="c298" class="mq lf it mm b gy my ms l mt mu">try {<br/>  greet();<br/>} catch (ex) {<br/>  console.log(ex);<br/>}</span></pre><p id="f4c8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们有下面的<code class="fe mv mw mx mm b">try...catch</code>块:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="90a0" class="mq lf it mm b gy mr ms l mt mu">try {<br/>  greet();<br/>} catch (ex) {<br/>  console.log(ex);<br/>}</span></pre><p id="6713" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，由于我们在调用<code class="fe mv mw mx mm b">greet</code>函数时没有传入任何参数，我们在控制台中从<code class="fe mv mw mx mm b">catch</code>块得到一个错误。</p><p id="8b50" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了更好地处理它，我们可以选择显示一个错误消息或类似的东西。</p><p id="cd2a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于异步代码，我们应该尽可能使用承诺。如果遇到错误，承诺会被拒绝，就像在同步代码中抛出错误一样，它们也会出现在控制台中。</p><p id="f6c6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，如果我们有一个被拒绝的承诺，如下所示:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="d6a6" class="mq lf it mm b gy mr ms l mt mu">Promise.reject('error');</span></pre><p id="d0e0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">我们可以对它调用<code class="fe mv mw mx mm b">catch</code>来捕捉错误并按如下方式处理它:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="a3d2" class="mq lf it mm b gy mr ms l mt mu">Promise.reject('error')<br/>  .catch(err =&gt; console.log(err));</span></pre><p id="3281" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">在上面的代码中，我们调用了<code class="fe mv mw mx mm b">catch</code>方法，在<code class="fe mv mw mx mm b">catch</code>方法调用中，我们传递了一个回调来记录错误。</p><p id="7e3a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后，我们可以看到错误，并在异步代码中轻松处理它们。</p><p id="ad2e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">使用<code class="fe mv mw mx mm b">async</code>和<code class="fe mv mw mx mm b">await</code>语法，我们可以从拒绝的承诺中捕获错误，如下所示:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="df99" class="mq lf it mm b gy mr ms l mt mu">(async () =&gt; {<br/>  try {<br/>    await Promise.reject('error');<br/>  } catch (err) {<br/>    console.log(err);<br/>  }<br/>})();</span></pre><p id="88f7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我们所见，如果我们使用<code class="fe mv mw mx mm b">async</code>和<code class="fe mv mw mx mm b">await</code>语法，我们就像使用同步代码一样使用<code class="fe mv mw mx mm b">try...catch</code>。</p><figure class="mh mi mj mk gt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi mz"><img src="../Images/43f3e149776326b85d96c7f3aff13328.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MdctEb0BbvnxqgnD"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@thoughtcatalog?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">思想目录</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="d833" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">比较</h1><p id="848b" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated"><code class="fe mv mw mx mm b">===</code>和<code class="fe mv mw mx mm b">!==</code>永远比<code class="fe mv mw mx mm b">==</code>和<code class="fe mv mw mx mm b">!=</code>强。</p><p id="282a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是因为<code class="fe mv mw mx mm b">===</code>和<code class="fe mv mw mx mm b">!==</code>在进行比较之前不会强制其操作数的数据类型。</p><p id="1a7d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">另一方面，<code class="fe mv mw mx mm b">==</code>和<code class="fe mv mw mx mm b">!=</code>在进行任何比较之前对它们的操作数进行数据类型强制。</p><p id="1aa6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">通过跳过键入一个字符，我们为自己引入了许多令人头痛的问题，因为自动类型强制。</p><p id="ee42" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">因此，我们应该总是只键入额外的<code class="fe mv mw mx mm b">=</code>符号，从而大大减少出错的机会。</p><p id="c87e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了保持条件表达式的简单，我们应该尽可能地使用快捷方式。</p><p id="7ffb" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">例如，以下是不好的:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="5c7b" class="mq lf it mm b gy mr ms l mt mu">if (condition === true) {<br/>  // ...<br/>}</span></pre><p id="8d2c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这很糟糕，因为我们不需要与<code class="fe mv mw mx mm b">true</code>进行比较来检查某个东西是否是<code class="fe mv mw mx mm b">true</code>。</p><p id="6fa0" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">相反，我们应该写:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="eebb" class="mq lf it mm b gy mr ms l mt mu">if (condition) {<br/>  // ...<br/>}</span></pre><p id="cd68" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">然后我们检查<code class="fe mv mw mx mm b">condition</code>是否为真，其中包括值<code class="fe mv mw mx mm b">true</code>。</p><p id="2e34" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果我们使用三元表达式，我们不应该嵌套它们。例如，以下是好的:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="9967" class="mq lf it mm b gy mr ms l mt mu">const foo = cond ? 'foo' : 'bar';</span></pre><p id="ac75" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是因为我们只有一个条件<code class="fe mv mw mx mm b">cond</code>，返回<code class="fe mv mw mx mm b">'foo'</code>为<code class="fe mv mw mx mm b">cond</code>为<code class="fe mv mw mx mm b">true</code>否则为<code class="fe mv mw mx mm b">'bar'</code>。</p><p id="bfbd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">但是，我们不应该将多个三元表达式嵌套在一起。所以下面是不好的:</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="a992" class="mq lf it mm b gy mr ms l mt mu">const foo = cond1 ? cond2 ? 'foo' : 'bar' : 'baz';</span></pre><p id="ca19" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">嵌套使得表达式难以理解。我们必须在大脑中放入括号来计算大脑中的值，这样我们才能理解它在做什么。</p><h1 id="8f5d" class="le lf it bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="9b2d" class="pw-post-body-paragraph kg kh it ki b kj mc kl km kn md kp kq kr me kt ku kv mf kx ky kz mg lb lc ld im bi translated">错误处理是通过抛出错误，然后通过捕获错误来处理它们。</p><p id="43cd" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于异步代码，我们可以拒绝承诺，然后调用<code class="fe mv mw mx mm b">catch</code>或使用<code class="fe mv mw mx mm b">catch</code>块来处理错误。</p><p id="9290" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">对于条件句，我们应该尽可能使用最短的方式。我们也不应该嵌套三元表达式。</p><p id="7c44" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">为了进行比较，我们应该使用<code class="fe mv mw mx mm b">===</code>和<code class="fe mv mw mx mm b">!==</code>进行比较，这样我们就不必担心类型强制。</p></div></div>    
</body>
</html>