<html>
<head>
<title>Dockerization and deployment of a Node.js application to Kubernetes using GitLab-CI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用GitLab-CI将Node.js应用程序停靠和部署到Kubernetes</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/development-containerization-and-deployment-of-a-node-js-application-to-kubernetes-using-gitlab-ci-e78a3eb38c26?source=collection_archive---------3-----------------------#2020-05-26">https://levelup.gitconnected.com/development-containerization-and-deployment-of-a-node-js-application-to-kubernetes-using-gitlab-ci-e78a3eb38c26?source=collection_archive---------3-----------------------#2020-05-26</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="f630" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在本文中，我们将构建一个简单的Node.js应用程序，它使用Express来响应HTTP请求。为了将这个应用程序部署到生产环境中，我们还将配置一个GitLab CI/CD管道，以便对其进行dockerize，并将其容器部署到Kubernetes集群中。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ko"><img src="../Images/5a0dca0d5f1af8877975d568920c5ae6.png" data-original-src="https://miro.medium.com/v2/resize:fit:502/format:webp/1*6TR5wdQ3pNclkFv04RpBWg.png"/></div></figure><h1 id="f08f" class="kw kx it bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">先决条件</h1><p id="54d5" class="pw-post-body-paragraph jq jr it js b jt lu jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn im bi translated">本文假设读者可以使用以下环境:</p><ul class=""><li id="047c" class="lz ma it js b jt ju jx jy kb mb kf mc kj md kn me mf mg mh bi translated">安装了<a class="ae mi" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank"> Node.js </a>的开发环境。</li><li id="ac67" class="lz ma it js b jt mj jx mk kb ml kf mm kj mn kn me mf mg mh bi translated">一个<a class="ae mi" href="https://about.gitlab.com/install/" rel="noopener ugc nofollow" target="_blank"> GitLab </a>实例，一个可用的<a class="ae mi" href="https://docs.gitlab.com/runner/install/" rel="noopener ugc nofollow" target="_blank"> runner </a>能够运行<em class="mo"> docker </em>和<em class="mo"> kubectl </em>命令。</li><li id="2e0b" class="lz ma it js b jt mj jx mk kb ml kf mm kj mn kn me mf mg mh bi translated">从GitLab实例可以访问带有Kubernetes集群的生产环境。为此，<a class="ae mi" href="https://microk8s.io/" rel="noopener ugc nofollow" target="_blank"> Microk8s </a>很容易上手</li><li id="4302" class="lz ma it js b jt mj jx mk kb ml kf mm kj mn kn me mf mg mh bi translated">一个<a class="ae mi" href="https://docs.docker.com/registry/deploying/" rel="noopener ugc nofollow" target="_blank">码头登记系统</a>,用于推进和拉出集装箱。请注意，运行您自己的注册表可能需要<a class="ae mi" href="https://docs.docker.com/registry/insecure/" rel="noopener ugc nofollow" target="_blank"> Docker </a>和Kubernetes配置(此处提供MicroK8s指南)</li></ul><h1 id="55b1" class="kw kx it bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">Node.js应用程序</h1><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi mp"><img src="../Images/81af4dd83047517b413d8a1b944f9341.png" data-original-src="https://miro.medium.com/v2/resize:fit:612/format:webp/1*v_Zpvp_iiXhGNojDHqe6jQ.png"/></div></div></figure><p id="d475" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">本指南中部署的应用程序是使用<a class="ae mi" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank"> Node.js构建的。</a>它由一个使用<a class="ae mi" href="https://expressjs.com/" rel="noopener ugc nofollow" target="_blank"> Express </a>包构建的简单web服务器组成，该服务器简单地响应<em class="mo"> Hello World！</em>对HTTP的请求。</p><h2 id="583b" class="mu kx it bd ky mv mw dn lc mx my dp lg kb mz na lk kf nb nc lo kj nd ne ls nf bi translated">项目创建</h2><p id="55df" class="pw-post-body-paragraph jq jr it js b jt lu jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn im bi translated">为了创建我们的应用程序，我们将首先创建一个新目录，其中包含一个名为<em class="mo"> main.js </em>的空javascript文件。</p><pre class="kp kq kr ks gt ng nh ni nj aw nk bi"><span id="374e" class="mu kx it nh b gy nl nm l nn no">mkdir my_application<br/>cd my_application<br/>touch main.js</span></pre><p id="2cb9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们需要安装Express，这可以使用节点包管理器或NPM来完成。这需要用NPM初始化项目，可以使用<em class="mo"> init </em>命令来完成:</p><pre class="kp kq kr ks gt ng nh ni nj aw nk bi"><span id="79c8" class="mu kx it nh b gy nl nm l nn no">npm init -y</span></pre><p id="4df7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">完成后，使用以下命令安装Express:</p><pre class="kp kq kr ks gt ng nh ni nj aw nk bi"><span id="74b2" class="mu kx it nh b gy nl nm l nn no">npm install --save express</span></pre><p id="4e27" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">此时，名为<em class="mo"> node_modules </em>的新文件夹以及名为<em class="mo"> package.json </em>和<em class="mo"> package-lock.json </em>的文件应该已经出现在项目的目录中。这些是用于依赖性管理的。<em class="mo"> node_modules </em>是包本地存储的有效位置<em class="mo">。</em></p><p id="0d13" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">完成这些之后，项目就可以进行实际的开发了。</p><h2 id="4568" class="mu kx it bd ky mv mw dn lc mx my dp lg kb mz na lk kf nb nc lo kj nd ne ls nf bi translated">Node.js应用程序开发</h2><p id="66f2" class="pw-post-body-paragraph jq jr it js b jt lu jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn im bi translated">作为一个示例应用程序，我们将使用Express文档中的<a class="ae mi" href="https://expressjs.com/en/starter/hello-world.html" rel="noopener ugc nofollow" target="_blank"> hello world示例</a></p><p id="5dc7" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用文本编辑器，打开应用程序目录中的空文件main.js，输入以下内容:</p><pre class="kp kq kr ks gt ng nh ni nj aw nk bi"><span id="fb6c" class="mu kx it nh b gy nl nm l nn no">// Import the express package<br/>const express = require('express')</span><span id="e4a9" class="mu kx it nh b gy np nm l nn no">// Instanciate an express app<br/>const app = express()</span><span id="515a" class="mu kx it nh b gy np nm l nn no">// Specify port on which the application will listen<br/>const port = 3000</span><span id="ce16" class="mu kx it nh b gy np nm l nn no">// Define a route<br/>app.get('/', (req, res) =&gt; res.send('Hello World!'))</span><span id="1374" class="mu kx it nh b gy np nm l nn no">// Start listening on the defined port<br/>app.listen(port, () =&gt; console.log(`Example app listening on port ${port}`))</span></pre><p id="0c73" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该应用程序可通过以下方式执行:</p><pre class="kp kq kr ks gt ng nh ni nj aw nk bi"><span id="2ad1" class="mu kx it nh b gy nl nm l nn no">node main.js</span></pre><p id="487d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，用户可以将浏览器指向服务器的IP地址并指定端口3000，以查看应用程序用<code class="fe nq nr ns nh b">Hello World!</code>做出的响应。要退出应用程序，请按下<em class="mo"> Ctrl+C </em>。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/8a1f5b712a30efc9d95760f253cb1115.png" data-original-src="https://miro.medium.com/v2/resize:fit:710/format:webp/1*BFx0W138-R3K96Rlj-iygg.png"/></div></figure><p id="13c3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">人们可能会争论这种应用的有用性。然而，对读者来说，显而易见的是，可以将业务逻辑添加到代码中以扩展其功能。</p><h1 id="0c88" class="kw kx it bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">码头化配置</h1><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi mp"><img src="../Images/5fd2ab255564a0edb7f22b7b171156ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:612/format:webp/1*DEjgfvGwJQFjUY-TswWNXw.png"/></div></div></figure><p id="127e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">既然应用程序已经在开发环境中运行了，那么是时候对它进行容器化了，这样它就可以被发布到生产环境中了。</p><p id="3d8b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用<a class="ae mi" href="https://www.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker </a>将应用程序容器化，只需要一个配置文件(称为Dockerfile)来指定容器化参数。本节遵循<a class="ae mi" href="https://nodejs.org/fr/docs/guides/nodejs-docker-webapp/" rel="noopener ugc nofollow" target="_blank"> NodeJS应用程序归档指南</a></p><p id="ac84" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Dockerfile用于创建一个容器映像，作为容器的模板。例如，官方Python docker映像可用于部署预装Python的容器。</p><p id="883e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">因此，为了创建我们的应用程序的图像，在项目的根目录下创建一个名为<em class="mo"> Dockerfile </em>的文件，其内容如下:</p><pre class="kp kq kr ks gt ng nh ni nj aw nk bi"><span id="bd45" class="mu kx it nh b gy nl nm l nn no"># The image is built on top of one that has node preinstalled<br/>FROM node:12</span><span id="5be1" class="mu kx it nh b gy np nm l nn no"># Create app directory<br/>WORKDIR /usr/src/app</span><span id="dcac" class="mu kx it nh b gy np nm l nn no"># Copy all files into the container<br/>COPY . .</span><span id="910b" class="mu kx it nh b gy np nm l nn no"># Install dependencies<br/>RUN npm install</span><span id="b6cf" class="mu kx it nh b gy np nm l nn no"># Open appropriate port <br/>EXPOSE 3000</span><span id="08f9" class="mu kx it nh b gy np nm l nn no"># Start the application<br/>CMD [ "node", "main.js" ]</span></pre><p id="7d79" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为了防止容器太重，里面不需要<em class="mo"> node_modules </em>目录。相反，当执行<em class="mo"> npm安装</em>时，将自动重新创建<em class="mo"> node_modules </em>。为了防止目录被复制，创建一个名为<em class="mo">的文件。应用程序目录中的dockerignore </em>，内容如下:</p><pre class="kp kq kr ks gt ng nh ni nj aw nk bi"><span id="a5a3" class="mu kx it nh b gy nl nm l nn no">node_modules</span></pre><h1 id="a4be" class="kw kx it bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">部署到Kubernetes的配置</h1><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi mp"><img src="../Images/9ddcd6c78661ad38348e15d364a02e2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:612/format:webp/1*00GCvr4Zq5fkfthE2ewq1w.png"/></div></div></figure><p id="cb0c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">使用前一节中创建的Dockerfile，可以创建应用程序的容器映像，并将其推送到容器注册中心。这使得应用程序可以部署在Kubernetes集群中。</p><p id="e13c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在Kubernetes中部署这个应用程序包括在集群中创建两个资源:一个<a class="ae mi" href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/" rel="noopener ugc nofollow" target="_blank">部署</a>和一个<a class="ae mi" href="https://kubernetes.io/docs/concepts/services-networking/service/" rel="noopener ugc nofollow" target="_blank">服务</a>。部署基本上是应用程序本身，而服务是用于将应用程序连接到其用户的资源，通过为部署提供它可以与外部通信的端口来有效地进行连接。这里，我们将使用端口31234进行服务。</p><p id="9892" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们的应用程序的部署和服务的创建是通过在一个清单文件中描述它们并让Kubernetes读取该文件的内容来完成的。因此，在项目的根目录下创建一个名为kubernetes_manifest.yml的文件，其内容如下:</p><pre class="kp kq kr ks gt ng nh ni nj aw nk bi"><span id="34bf" class="mu kx it nh b gy nl nm l nn no"># This section will create a deployment in the Kubernetes cluster<br/>apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: my-application<br/>spec:<br/>  replicas: 1<br/>  selector:<br/>    matchLabels:<br/>      app: my-application<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: my-application<br/>    spec:<br/>      containers:<br/>      - name: my-application<br/>        image: my-registry/my-application:latest<br/>        imagePullPolicy: Always<br/>        ports:<br/>        - containerPort: 3000<br/>---<br/># This section will create a service in the Kubernetes cluster<br/># so that the deployment can be accessed from the outside<br/>apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: my-application<br/>spec:<br/>  ports:<br/>  - port: 3000<br/>    nodePort: 31234<br/>  selector:<br/>    app: my-application<br/>  type: NodePort</span></pre><h1 id="f567" class="kw kx it bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">GitLab CI配置</h1><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi mp"><img src="../Images/5642a66a12c76dffd55dd61785597cd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:612/format:webp/1*T4_wAnByuzWn-pQR9m9Hqg.png"/></div></div></figure><p id="c07d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">该项目现在已经有了一个工作源代码，以及需要打包并部署到Kubernetes集群的配置。虽然容器化和部署可以手动完成，但是让GitLab自动执行这些步骤会更方便。如果执行这些步骤所需的工具没有安装在开发环境中，情况尤其如此。</p><p id="0c5a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">要让GitLab负责容器化和部署，只需创建一个名为<em class="mo">的文件。gitlab-ci.yml </em>以yaml数组的形式包含了每一步所必需的命令:</p><pre class="kp kq kr ks gt ng nh ni nj aw nk bi"><span id="1a05" class="mu kx it nh b gy nl nm l nn no">stages:<br/>  - containerization<br/>  - deploy</span><span id="24cd" class="mu kx it nh b gy np nm l nn no">containerization:<br/>  stage: containerization # must match the stage name declared above<br/>  script:<br/>    # Build the container image<br/>    - docker build -t my-registry/my-application .<br/>    # Push the container image to the registry<br/>    - docker push my-registry/my-application<br/>    # Cleanup by removing the local image<br/>    - docker image rm my-registry/my-application</span><span id="3683" class="mu kx it nh b gy np nm l nn no">deployment:<br/>  stage: deploy # must match the stage name declared above<br/>  script:<br/>    # create/update the kubernetes resources<br/>    - kubectl apply -f kubernetes_manifest.yml<br/>    # Restart the deployment so as to pull the latest version of the container image<br/>    - kubectl rollout restart deployment/my-application<br/>  environment:<br/>    name: production</span></pre><p id="e38c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">需要注意的重要一点是缺乏自动化测试。这样做是为了保持文章的简洁，但是对于比这个例子更复杂的应用程序来说，快速实现严格的测试是必要的。</p><h1 id="63cb" class="kw kx it bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">GitLab项目</h1><h2 id="2dae" class="mu kx it bd ky mv mw dn lc mx my dp lg kb mz na lk kf nb nc lo kj nd ne ls nf bi translated">项目创建</h2><p id="880e" class="pw-post-body-paragraph jq jr it js b jt lu jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn im bi translated">项目的本地内容已经为应用程序的部署做好准备。现在，需要在GitLab中为项目创建一个远程存储库。</p><p id="34fc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">只需点击<em class="mo">新建项目</em>按钮，然后给项目命名即可。</p><p id="ba3a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">创建之后，GitLab提供了一个URL，可以用来将代码推送到存储库。</p><h2 id="b0df" class="mu kx it bd ky mv mw dn lc mx my dp lg kb mz na lk kf nb nc lo kj nd ne ls nf bi translated">Kubernetes集群集成</h2><p id="ca94" class="pw-post-body-paragraph jq jr it js b jt lu jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn im bi translated">既然已经在GitLab中创建了项目，那么必须对其进行配置，以便集成所需的Kubernetes集群。</p><p id="6eda" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为此，请转到GitLab中项目的Operations菜单，然后单击Kubernetes。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/3927dbdd7c53461b4f21488c3c261f40.png" data-original-src="https://miro.medium.com/v2/resize:fit:866/format:webp/1*qrXRF5sIF8VHeqx16IpAFw.png"/></div></figure><p id="8bd3" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这将导致一个页面，允许用户配置Kubernetes集群集成的详细信息。Gitlab文档提供了完整的指南。</p><h2 id="b9ba" class="mu kx it bd ky mv mw dn lc mx my dp lg kb mz na lk kf nb nc lo kj nd ne ls nf bi translated">使用Git将项目推送到GitLab</h2><p id="66a1" class="pw-post-body-paragraph jq jr it js b jt lu jv jw jx lv jz ka kb lw kd ke kf lx kh ki kj ly kl km kn im bi translated">创建远程存储库后，可以使用<a class="ae mi" href="https://git-scm.com/" rel="noopener ugc nofollow" target="_blank"> Git </a>推送本地内容。为此，必须初始化项目目录，以便与git一起使用，可以这样做</p><pre class="kp kq kr ks gt ng nh ni nj aw nk bi"><span id="3933" class="mu kx it nh b gy nl nm l nn no">git init</span></pre><p id="8304" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">然后可以使用<code class="fe nq nr ns nh b">git remote add</code>命令注册远程存储库:</p><pre class="kp kq kr ks gt ng nh ni nj aw nk bi"><span id="9159" class="mu kx it nh b gy nl nm l nn no">git remote add gitlab http://&lt;gitlab url&gt;/&lt;username&gt;/my-application</span></pre><p id="cc94" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">无论如何,<code class="fe nq nr ns nh b">node_modules </code>目录可能会很大，并且是在使用npm install时自动生成的，因此不需要将其推送到远程存储库。为了防止它被上传，文件命名为<em class="mo">。gitignore </em>在项目的根目录下，有如下内容:</p><pre class="kp kq kr ks gt ng nh ni nj aw nk bi"><span id="bbc8" class="mu kx it nh b gy nl nm l nn no">node_modules</span></pre><p id="6637" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">一切就绪后，代码就可以准备、提交和推送了</p><pre class="kp kq kr ks gt ng nh ni nj aw nk bi"><span id="1404" class="mu kx it nh b gy nl nm l nn no">git add .<br/>git commit -m "Deploying to k8s"<br/>git push gitlab master</span></pre><p id="ba2c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在代码已经被推送到GitLab，CI管道负责应用程序的容器化和部署。如果一切顺利，项目页面应该会在提交号旁边显示一个绿色的复选标记来欢迎用户。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi nv"><img src="../Images/d9afd4c1e62e1ef50bd469b9a1bc3537.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nDOrADxvJlBTs8Kdl-H0zw.png"/></div></div></figure><p id="43d5" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果一切顺利，那么可以在生产环境的端口31234上访问应用程序。</p><p id="b56a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">有了这样的管道，Kubernetes中运行的应用程序将在每次开发人员在项目的主分支上推送代码时自动更新。因此，开发人员现在可以专注于应用程序本身的开发，而不必担心部署细节。</p></div></div>    
</body>
</html>