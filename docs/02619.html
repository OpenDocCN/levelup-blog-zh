<html>
<head>
<title>Learning Go: Pointers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习围棋:指针</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/learning-go-pointers-5d1c491f833e?source=collection_archive---------14-----------------------#2020-03-25">https://levelup.gitconnected.com/learning-go-pointers-5d1c491f833e?source=collection_archive---------14-----------------------#2020-03-25</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/63bcb700a88b75ba8c5c3561eb6b0403.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3Izfg2qMz6Lsgc_s"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">照片由<a class="ae kf" href="https://unsplash.com/@fbngsk?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">法比安·吉斯克</a>在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="28b5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">指针</em>是保存内存地址的变量。您可以使用指针间接访问和操作存储在变量中的数据。在这篇文章中，我将讨论如何在Go中使用指针。</p><h1 id="de40" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">创建指针</h1><p id="7c23" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">指针存储变量的地址。通过使用带有变量的地址运算符(<code class="fe mi mj mk ml b">&amp;</code>)创建指针。创建指针的语法模板是:</p><p id="b10d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le"> *ptr-name := &amp;变量名</em></p><p id="c434" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个简单的程序，演示了如何声明、赋值和访问指针变量:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="c0a1" class="mu lg it ml b gy mv mw l mx my">func main() {<br/>  x := 1<br/>  ptrX := &amp;x<br/>  fmt.Printf("Address of x: %x\n", ptrX)<br/>  fmt.Printf("Value stored in x: %d\n", *ptrX)<br/>}</span></pre><p id="c745" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个程序的输出是:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="7ab9" class="mu lg it ml b gy mv mw l mx my">Address of x: c0000100b0<br/>Value stored in x: 1</span></pre><p id="4b83" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当引用不带星号的指针变量时，访问内存地址，当使用<code class="fe mi mj mk ml b">*</code>运算符将星号添加到指针变量的<em class="le">解引用</em>时，访问内存地址中存储的值。</p><p id="8902" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以通过更改指向变量的指针的值来修改该变量的值，如下例所示:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="613c" class="mu lg it ml b gy mv mw l mx my">func main() {<br/>  x := 1<br/>  ptrX := &amp;x<br/>  fmt.Printf("X's current value: %d\n", x) // displays 1<br/>  *ptrX++<br/>  fmt.Printf("X's current value: %d\n", x) // displays 2<br/>}</span></pre><p id="8852" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当然，如果你改变一个指针所指向的变量的值，指针也会随之改变:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="4976" class="mu lg it ml b gy mv mw l mx my">func main() {<br/>  x := 1<br/>  ptrX := &amp;x<br/>  fmt.Printf("X's current value: %d\n", x) // displays 1<br/>  *ptrX++<br/>  fmt.Printf("X's current value: %d\n", x) // displays 2<br/>  x = 100<br/>  fmt.Printf("X's current value via pointer: %d\n", *ptrX)<br/>  // 100 is displayed<br/>}</span></pre><p id="8a64" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如果你声明一个变量而没有给它分配地址，它的值为零:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="0118" class="mu lg it ml b gy mv mw l mx my">func main() {<br/>  var ptr *int<br/>  fmt.Println("ptr's value is: ",ptr) // ptr's value is &lt;nil&gt;<br/>}</span></pre><p id="b9d5" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">一旦你给指针分配了一个地址，它的值就会变成那个地址。</p><p id="4776" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">创建指针的最后一种方法是使用关键字new。new的语法模板是:</p><p id="6e60" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><em class="le">指针名称:=新(数据类型)</em></p><p id="9470" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是一个使用new创建指针的示例:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="95b2" class="mu lg it ml b gy mv mw l mx my">func main() {<br/>  ptr := new(int)<br/>  fmt.Println("ptr's value:",*ptr)<br/>  *ptr = 14<br/>  fmt.Println("ptr's value:",*ptr)<br/>}</span></pre><p id="04e2" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个程序的输出是:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="4863" class="mu lg it ml b gy mv mw l mx my">ptr's value: 0<br/>ptr's value: 14</span></pre><p id="1966" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">如您所见，当您使用new创建指针时，指针的值将被设置为指定数据类型的默认值。</p><h1 id="a8a0" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">使用指针</h1><p id="bd70" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">指针可以用来修改函数的参数，以避开Go的按值传递行为。这里有一个例子:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="952f" class="mu lg it ml b gy mv mw l mx my">func addFive(val *int) {<br/>  *val += 5<br/>}</span><span id="85e1" class="mu lg it ml b gy mz mw l mx my">func main() {<br/>  x := 0<br/>  ptrX := &amp;x<br/>  addFive(ptrX)<br/>  fmt.Println("x's value:",x)<br/>}</span></pre><p id="c114" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">你可以用指针写一个函数来交换变量，就像这样:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="21cb" class="mu lg it ml b gy mv mw l mx my">func swap(val1 *int, val2 *int) {<br/>  temp := *val1<br/>  *val1 = *val2<br/>  *val2 = temp<br/>}</span><span id="cd4a" class="mu lg it ml b gy mz mw l mx my">func main() {<br/>  x := 1<br/>  y := 2<br/>  fmt.Printf("x: %d, y: %d\n", x, y) // x: 1, y: 2<br/>  swap(&amp;x, &amp;y)<br/>  fmt.Printf("x: %d, y: %d\n", x, y)  // x: 2, y: 1<br/>}</span></pre><p id="309b" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是可行的，但是在Go中交换两个变量的惯用方法是这样的:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="4fe2" class="mu lg it ml b gy mv mw l mx my">func swap(val1, val2 int) (int, int) {<br/>  return val2, val1<br/>}</span><span id="2049" class="mu lg it ml b gy mz mw l mx my">func main() {<br/>  x := 1<br/>  y := 2<br/>  fmt.Printf("x: %d, y: %d\n", x, y)<br/>  x, y = swap(x, y)<br/>  fmt.Printf("x: %d, y: %d\n", x, y)<br/>}</span></pre><p id="bd6e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是可行的，因为Go函数可以返回多个值。</p><p id="f8ff" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您也可能想通过传递指向数组的指针来修改函数中的数组，如下例所示:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="a93e" class="mu lg it ml b gy mv mw l mx my">func curve(arr *[5]int, amount int) {<br/>  for i:=0; i&lt;5; i++ {<br/>    (*arr)[i] += amount<br/>  }<br/>}</span><span id="46a6" class="mu lg it ml b gy mz mw l mx my">func main() {<br/>  const size = 5<br/>  grades := [size]int{81, 77, 71, 83, 67}<br/>  fmt.Println(grades)<br/>  curve(&amp;grades, 5)<br/>  fmt.Println(grades)<br/>}</span></pre><p id="3ad9" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这是可行的，但不是惯用的方法。相反，您应该将数组切片传递给函数，如下例所示:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="dc66" class="mu lg it ml b gy mv mw l mx my">func curve(arr []int, amount int) {<br/>  for index, _ := range arr {<br/>    arr[index] += amount<br/>  }<br/>}</span><span id="e234" class="mu lg it ml b gy mz mw l mx my">func main() {<br/>  const size = 5<br/>  grades := [size]int{81, 77, 71, 83, 67}<br/>  fmt.Println(grades)<br/>  curve(grades[:], 5)<br/>  fmt.Println(grades)<br/>}</span></pre><p id="7b4c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">指针在Go中的最后一个用途是当你使用结构体的时候。因为结构可以保存大量数据，所以结构应该作为指针传递给函数，这样它就不会通过值传递给函数。这里有一个例子:</p><pre class="mm mn mo mp gt mq ml mr ms aw mt bi"><span id="068f" class="mu lg it ml b gy mv mw l mx my">type Student struct {<br/>  name string<br/>  id int<br/>  major string<br/>}</span><span id="eec7" class="mu lg it ml b gy mz mw l mx my">func changeMajor(s *Student, m string)  {<br/>  s.major = m<br/>}</span><span id="f9b1" class="mu lg it ml b gy mz mw l mx my">func main() {<br/>  st1 := &amp;Student{"Jane Doe", 123, "Computer Science"}<br/>  fmt.Println(*st1)<br/>  changeMajor(st1, "Information Science")<br/>  fmt.Println(*st1)<br/>}</span></pre><p id="eec1" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">此示例还演示了如何使用struct文本创建指针变量。</p><p id="c63e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">正如我前面提到的，将结构作为指针传递给函数在Go中是惯用的，正如将对象作为引用传递在C++中是惯用的效率问题，因为结构可以包含大量数据，并且通过值传递它们可能非常低效。</p><h1 id="873c" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">Go指针和数组</h1><p id="3884" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">与C和C++不同，Go数组名不是指向数组的指针，因此不能使用指针作为访问数组的替代方法。另外，Go没有指针算法，所以你不能在指针上使用递增和递减操作符。</p><h1 id="5242" class="lf lg it bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">去指点一下</h1><p id="f33d" class="pw-post-body-paragraph kg kh it ki b kj md kl km kn me kp kq kr mf kt ku kv mg kx ky kz mh lb lc ld im bi translated">Go提供了使用指针间接访问变量值的能力。在某些情况下，指针会提高程序的效率，例如，当您将结构传递给函数时，您希望以最有效的方式来传递。Go指针不如C和C++等语言中的指针强大，但这可能是一个特性，而不是一个错误。</p><p id="2cf6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢您阅读这篇文章，请给我发电子邮件，提出您的意见和建议。</p></div></div>    
</body>
</html>