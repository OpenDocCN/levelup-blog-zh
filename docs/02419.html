<html>
<head>
<title>Master RxJS: Batching Messages</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">主RxJS:批处理消息</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/master-rxjs-batching-messages-bb1e40bdd5ea?source=collection_archive---------10-----------------------#2020-03-11">https://levelup.gitconnected.com/master-rxjs-batching-messages-bb1e40bdd5ea?source=collection_archive---------10-----------------------#2020-03-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/c40888e1140c012adcb832cbb4951abf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3zV5siQHLZt5EGJh"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated"><a class="ae kc" href="https://unsplash.com/@spacexuan?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">郭锦恩</a>在<a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h2 id="3592" class="kd ke iq bd kf kg kh dn ki kj kk dp kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">方案</h2><p id="ef08" class="pw-post-body-paragraph kz la iq lb b lc ld le lf lg lh li lj km lk ll lm kq ln lo lp ku lq lr ls lt ij bi translated"><strong class="lb ir">您的应用程序连接到外部错误报告服务，使得开发人员可以直接看到任何用户错误。然而，一些错误往往会在短时间内为每个用户抛出许多次，导致类似错误的快速累积和配额的快速耗尽。</strong></p><p id="f0c2" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">当然，这个批处理系统将适用于任何其他类似的场景，在这些场景中，您基于可能会不断重复的输入来触发事件，比如mouseEvents或用户对字段的输入。</p><p id="62f4" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">假设我们有一个简单的<code class="fe lz ma mb mc b">errorMessageHandler</code>,它从应用程序的底层获取一个参数<code class="fe lz ma mb mc b">errorMessage: string</code>。如果我们在服务等中使用Observables，这是一种非常可能的情况。其中<code class="fe lz ma mb mc b">catchError</code>管道用于将错误消息转发给<code class="fe lz ma mb mc b">errorMessageHandler</code>。然后，<code class="fe lz ma mb mc b">errorMessageHandler</code>使用<code class="fe lz ma mb mc b">Sentry.captureException</code>将这些消息转发给Sentry，并根据收到的消息抛出一个错误。我们假设它看起来像这样:</p><figure class="md me mf mg gt jr"><div class="bz fp l di"><div class="mh mi l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">我们的超级简单但不太聪明的errorMessageHandler</figcaption></figure><p id="26e7" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">我们通过创建一个名为<code class="fe lz ma mb mc b">messageBatcher$</code>的<code class="fe lz ma mb mc b">Subject</code>来解决我们的问题，我们将使用<code class="fe lz ma mb mc b">Subject</code>的内置<code class="fe lz ma mb mc b">.next()</code>函数将我们的错误消息转发给它。我们只需更改我们的<code class="fe lz ma mb mc b">errorHandler</code>以将其发送给<code class="fe lz ma mb mc b">messageBatcher$</code>，并添加一个订阅，将消息转发给Sentry。换句话说，行为将暂时保持不变。</p><figure class="md me mf mg gt jr"><div class="bz fp l di"><div class="mh mi l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">向我们的主题转发错误消息</figcaption></figure><p id="8f9d" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">现在，为了将消息批量处理在一起，我们将以一种稍微有创意的方式利用一些操作符。我们将使用<code class="fe lz ma mb mc b">buffer</code>对消息进行批处理，使用<code class="fe lz ma mb mc b">debounceTime</code>来确定何时应该转发该批消息。根据下面的解释，生成的代码如下所示:</p><figure class="md me mf mg gt jr"><div class="bz fp l di"><div class="mh mi l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">去抖动为300时批处理错误消息</figcaption></figure><p id="6c77" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">那么到底是怎么回事呢？<code class="fe lz ma mb mc b">buffer</code>收集传入发射中的所有值，直到提供的可观察发射，然后以数组形式发射这些值。这听起来很合理，但是什么样的可观察性会给出正确的行为呢？</p><p id="17ed" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">在我的用例中，我希望在300毫秒内没有新消息被报告给批处理程序时，消息批次被转发。通过使用<code class="fe lz ma mb mc b">messageBatcher$</code>本身作为源，并通过<code class="fe lz ma mb mc b">debounceTime(300)</code>传输它，我最终得到了完全正确的行为。当消息不断被报告时，批处理程序只是简单地等待，直到它冷却下来，一旦300毫秒过去了，没有新的错误消息，消息就作为一个单独的异常被转发给Sentry。</p><p id="3f85" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">还有一个可以改进的地方。假设在等待期间，报告了几个相同的错误消息。在我们发送给Sentry的批处理错误中，我们可能不想要重复的错误。在这种情况下，我们将代码更改如下:</p><figure class="md me mf mg gt jr"><div class="bz fp l di"><div class="mh mi l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">删除重复项的错误消息批处理程序</figcaption></figure></div><div class="ab cl mj mk hu ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ij ik il im in"><p id="7fde" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">这个例子是基于我在一个项目中偶然发现的真实问题。在我们的例子中，对于给定的翻译关键字，我们的CMS中缺少翻译字符串。每个丢失的键都会抛出一个错误，并且偶尔会在产品CMS更新之前发布产品版本。</p><p id="23b9" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">在这些情况下，我们会看到Sentry中报告的错误荒谬地增加，都是“missing translation key: BLABLA”的形式，有来自相同用户的大量重复。有时我们会看到在一个新的生产版本发布后，错误会激增到几万个，很快就花光了Sentry的配额。</p><p id="b1a6" class="pw-post-body-paragraph kz la iq lb b lc lu le lf lg lv li lj km lw ll lm kq lx lo lp ku ly lr ls lt ij bi translated">更改为这种方法后，Sentry的输出将是“missing translation keys: BLABLA1，BLABLA2，...”的形式，如果出现类似的问题，错误将增加到几百个，有效地减少了90%以上的报告错误！用管道通向成功！</p></div></div>    
</body>
</html>