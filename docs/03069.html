<html>
<head>
<title>Learning C++: The STL and the queue Class</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习c++:STL和队列类</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/learning-c-the-stl-and-the-queue-class-6d8ba7a73d9c?source=collection_archive---------20-----------------------#2020-04-17">https://levelup.gitconnected.com/learning-c-the-stl-and-the-queue-class-6d8ba7a73d9c?source=collection_archive---------20-----------------------#2020-04-17</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><figure class="gl gn jr js jt ju gh gi paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="gh gi jq"><img src="../Images/5e9b97bb1e654de51ddc590ee49cadb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*khL8P-dzZSZRsAED"/></div></div><figcaption class="kb kc gj gh gi kd ke bd b be z dk translated">查尔斯·德鲁维奥在<a class="ae kf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="19d8" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">queue</code>是一个具有先进先出(FIFO)行为的容器。排队的经典例子是杂货店排队。数据放在队列的后面，数据放在队列的前面，一次只能有一个数据元素进入或离开队列。在本文中，我将演示如何使用标准模板库的(STL) <code class="fe le lf lg lh b">queue</code>类，并讨论一些使用队列的应用程序。</p><h1 id="220c" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">队列概述</h1><p id="78d3" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">当我们美国人使用排队这个词时，英国人和其他欧洲人使用排队这个词。每个人都熟悉队列是如何工作的。当你进入一条线时，你从后面进入这条线，除非你是唯一一个排队的人，然后你在这条线的后面和前面。</p><p id="0a1e" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">当人们处理完事务后，他们从前面离开队伍，下一个人移到队伍的前面。当用一条线进行交易时，你通常只与这条线的前端或后端进行交易。不在队伍前面或后面的人不能上场，除非有人试图“切断”队伍，但这是违反规则的，我在这里不会考虑这种可能性。</p><p id="96d4" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">queue</code>容器以同样的方式工作。数据从后面进入队列，从前面离开队列。您只能检查队列的两个位置—前面和后面。这些接口约束使得使用队列的应用程序更有效，老实说，更容易使用，因为通常只有一种方法来执行操作。</p><h1 id="614d" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">声明队列</h1><p id="0f9c" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">要使用<code class="fe le lf lg lh b">queue</code>类，您必须首先引用正确的头文件:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="6688" class="mt lj it lh b gy mu mv l mw mx">#include &lt;queue&gt;</span></pre><p id="5a4a" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">queue</code>容器是一个模板类，所以在声明新队列时必须提供一个数据类型。以下是一些例子:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="b38c" class="mt lj it lh b gy mu mv l mw mx">queue&lt;string&gt; names;<br/>queue&lt;double&gt; floats;<br/>queue&lt;int&gt; ids;</span></pre><p id="4800" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">不能用初始值设定项列表初始化队列，也不能将容量指定为构造函数参数。</p><h1 id="cb1e" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">向队列中添加数据并检查前端和后端</h1><p id="b907" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">使用<code class="fe le lf lg lh b">push</code>功能将数据添加到队列中。这里有一个例子:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="81bb" class="mt lj it lh b gy mu mv l mw mx">#include &lt;iostream&gt;<br/>#include &lt;queue&gt;<br/>#include &lt;vector&gt;<br/>using namespace std;</span><span id="b5c6" class="mt lj it lh b gy my mv l mw mx">int main()<br/>{<br/>  vector&lt;string&gt; people = {"Meredith", "Allison", "Mason"};<br/>  queue&lt;string&gt; names;<br/>  for (const string person : people) {<br/>    names.push(person);<br/>  }<br/>  return 0;<br/>}</span></pre><p id="c4f7" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated"><code class="fe le lf lg lh b">front</code>和<code class="fe le lf lg lh b">back</code>功能分别用于检查队列的前面和后面。我们可以将下面的代码片段添加到上面的程序中，看看谁在队列的前面，谁在后面:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="e88a" class="mt lj it lh b gy mu mv l mw mx">cout &lt;&lt; "Front of queue: " &lt;&lt; names.front() &lt;&lt; endl; // Meredith<br/>cout &lt;&lt; "Back of queue: " &lt;&lt; names.back() &lt;&lt; endl; // Mason</span></pre><h1 id="b815" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">从队列中删除数据并显示队列的大小</h1><p id="5691" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">从队列中删除数据的唯一方法是使用<code class="fe le lf lg lh b">pop</code>函数。此函数删除该行前面的元素，将所有其他元素上移一个位置。</p><p id="cd60" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">您可以使用<code class="fe le lf lg lh b">size</code>函数来查看一个元素已经从队列中弹出。下面是一个演示了<code class="fe le lf lg lh b">pop</code>函数和<code class="fe le lf lg lh b">size</code>函数的程序:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="0617" class="mt lj it lh b gy mu mv l mw mx">int main()<br/>{<br/>  vector&lt;string&gt; people = {"Meredith", "Allison", "Mason"};<br/>  queue&lt;string&gt; line;<br/>  for (const string person : people) {<br/>    line.push(person);<br/>  }<br/>  do {<br/>    cout &lt;&lt; "Now serving: " &lt;&lt; line.front() &lt;&lt; endl;<br/>    line.pop();<br/>    cout &lt;&lt; "Number waiting in line: " &lt;&lt; line.size() &lt;&lt; endl;<br/>  } while (!line.empty());<br/>  if (line.empty()) {<br/>    cout &lt;&lt; "Line empty." &lt;&lt; endl;<br/>  }<br/>  return 0;<br/>}</span></pre><p id="0679" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这个程序的输出是:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="4c6d" class="mt lj it lh b gy mu mv l mw mx">Now serving: Meredith<br/>Number waiting in line: 2<br/>Now serving: Allison<br/>Number waiting in line: 1<br/>Now serving: Mason<br/>Number waiting in line: 0<br/>Line empty.</span></pre><p id="4153" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这就结束了我对队列类及其函数的回顾。现在让我们看看队列的一些应用程序。</p><h1 id="1dcf" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">排队申请</h1><p id="fa75" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">队列最常见的应用是在模拟中。演示复杂的模拟超出了本文的范围，但是我可以演示一个简单的模拟——为一个方块舞配对。我从威廉·福特和威廉·托普的教科书《C++ 的T4数据结构》中引用了这个例子。</p><p id="a21c" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">这种模拟是通过将广场舞的男性和女性参与者放置在两个单独的队列中来进行的。到了开始跳舞的时候，从每个队列的最前面抽出一男一女组成舞伴。如果两个队列的人数不相等，群众演员必须等到下一场舞会。为了简单起见，我将从两个向量中获取数据(男性和女性)，而不是像教科书示例那样从一个文件中获取。</p><p id="0f37" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">程序是这样的:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="df0f" class="mt lj it lh b gy mu mv l mw mx">#include &lt;iostream&gt;<br/>#include &lt;queue&gt;<br/>#include &lt;vector&gt;<br/>using namespace std;</span><span id="0438" class="mt lj it lh b gy my mv l mw mx">int main()<br/>{<br/>  vector&lt;string&gt; men =<br/>    {"George", "Bill", "Bob", "Dave", "Harold", "Dan", "John"};<br/>  vector&lt;string&gt; women =<br/>    {"Jane", "Sandra", "Shirley", "Louise", "Roberta"};<br/>  queue&lt;string&gt; menDancers, womenDancers;<br/>  for (string man : men) {<br/>    menDancers.push(man);<br/>  }<br/>  for (string woman : women) {<br/>    womenDancers.push(woman);<br/>  }<br/>  cout &lt;&lt; "Current dance partners are: " &lt;&lt; endl &lt;&lt; endl;<br/>  do {<br/>    man = menDancers.front();<br/>    woman = womenDancers.front();<br/>    menDancers.pop();<br/>    womenDancers.pop();<br/>    cout &lt;&lt; woman &lt;&lt; " and " &lt;&lt; man &lt;&lt; endl;<br/>  } while ((!menDancers.empty() &amp;&amp; !womenDancers.empty()));<br/>  if (!menDancers.empty()){<br/>    cout &lt;&lt; endl &lt;&lt; endl<br/>         &lt;&lt; "Men dancers waiting for next dance: "<br/>         &lt;&lt; endl &lt;&lt; endl;<br/>    men.clear();<br/>    while (!menDancers.empty()) {<br/>      men.push_back(menDancers.front());<br/>      cout &lt;&lt; menDancers.front() &lt;&lt; endl;<br/>      menDancers.pop();<br/>    }<br/>  }<br/>  if (!womenDancers.empty()){<br/>    cout &lt;&lt; endl &lt;&lt; endl<br/>         &lt;&lt; "Women dancers waiting for next dance: "<br/>         &lt;&lt; endl &lt;&lt; endl;<br/>    women.clear();<br/>    while (!womenDancers.empty()) {<br/>      men.push_back(menDancers.front());<br/>      cout &lt;&lt; womenDancers.front();<br/>      womenDancers.pop();<br/>    }<br/>  }<br/>  return 0;<br/>}</span></pre><p id="52ca" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">以下是该程序的输出:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="04bd" class="mt lj it lh b gy mu mv l mw mx">Current dance partners are:</span><span id="f5dd" class="mt lj it lh b gy my mv l mw mx">Jane and George<br/>Sandra and Bill<br/>Shirley and Bob<br/>Louise and Dave<br/>Roberta and Harold</span><span id="da0a" class="mt lj it lh b gy my mv l mw mx">Men dancers waiting for next dance:</span><span id="fe93" class="mt lj it lh b gy my mv l mw mx">Dan<br/>John</span></pre><p id="95ee" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">福特和托普演示的另一个例子是基数排序。<a class="ae kf" href="https://en.wikipedia.org/wiki/Radix_sort" rel="noopener ugc nofollow" target="_blank">这里</a>描述了基数排序及其工作原理。下面是我用队列进行基数排序的程序:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="5133" class="mt lj it lh b gy mu mv l mw mx">#include &lt;iostream&gt;<br/>#include &lt;queue&gt;<br/>#include &lt;cstdlib&gt;<br/>#include &lt;ctime&gt;<br/>#include &lt;cmath&gt;<br/>using namespace std;</span><span id="8a30" class="mt lj it lh b gy my mv l mw mx">void radixSort(vector&lt;int&gt; &amp;vec, int n) {<br/>  queue&lt;int&gt; bins[10];<br/>  int maxDigits=3;<br/>  int currentDigit=0;<br/>  while (currentDigit &lt; maxDigits) {<br/>    for(int i=0; i&lt;n; i++){<br/>      int divisor=pow(10,currentDigit);<br/>      int num = vec[i];<br/>      int digitValue = static_cast&lt;int&gt;((num/divisor)%10);<br/>      bins[digitValue].push(num);<br/>    }<br/>    int i=0;<br/>    for(int k=0;k&lt;10;k++){<br/>      while (!bins[k].empty()){<br/>        int temp=bins[k].front();<br/>        vec[i]=temp;<br/>        bins[k].pop();<br/>        i++;<br/>      }<br/>    }<br/>    currentDigit++;<br/>  }<br/>}</span><span id="1b4e" class="mt lj it lh b gy my mv l mw mx">int main()<br/>{<br/>  const int SZ = 50;<br/>  vector&lt;int&gt; numbers;<br/>  for (int i = 0; i &lt; SZ; i++) {<br/>    numbers.push_back(rand() % 100 + 1);<br/>  }<br/>  radixSort(numbers, SZ);<br/>  for (int i = 0; i &lt; SZ; i++) {<br/>    cout &lt;&lt; numbers[i] &lt;&lt; " ";<br/>  }<br/>  return 0;<br/>}</span></pre><p id="3cc6" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">下面是这个程序运行一次的输出:</p><pre class="ml mm mn mo gt mp lh mq mr aw ms bi"><span id="db77" class="mt lj it lh b gy mu mv l mw mx">42 68 35 1 70 25 79 59 63 65 6 46 82 28 62 92 96 43 28 37<br/><br/>1 6 25 28 28 35 37 42 43 46 59 62 63 65 68 70 79 82 92 96</span></pre><h1 id="ef52" class="li lj it bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">其他队列应用程序</h1><p id="8c39" class="pw-post-body-paragraph kg kh it ki b kj mg kl km kn mh kp kq kr mi kt ku kv mj kx ky kz mk lb lc ld im bi translated">在计算机科学和运筹学的许多领域中，每当需要将数据保存在存储器中以备后用时，就会使用队列。在这些应用中，队列作为一个缓冲区工作，就像内存在计算机内存中被缓冲一样。</p><p id="304d" class="pw-post-body-paragraph kg kh it ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld im bi translated">感谢您阅读这篇文章，请给我发电子邮件，提出您的意见和建议。</p></div></div>    
</body>
</html>