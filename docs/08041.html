<html>
<head>
<title>Building custom typescript decorators for angular</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为angular构建自定义类型脚本装饰器</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/building-custom-typescript-decorators-for-angular-4595816e7b87?source=collection_archive---------0-----------------------#2021-03-30">https://levelup.gitconnected.com/building-custom-typescript-decorators-for-angular-4595816e7b87?source=collection_archive---------0-----------------------#2021-03-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/54f84b9124f50588173279d622a325c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*IFOv2QMFpVheai4ImmJFGA.gif"/></div></div></figure><p id="de1e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">作为前端开发人员，我们喜欢漂亮的用户界面。同样，我们真的应该努力拥有干净的可重用代码。现代工具和技术为我们提供了许多实现这一目标的方法。在本文中，我们将研究typescript装饰器，以及它们如何帮助我们向代码中添加抽象和可重用性。</p><p id="d338" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为此，我们将创建一个自定义装饰器来启动一个<a class="ae kw" href="https://sweetalert.js.org/guides/" rel="noopener ugc nofollow" target="_blank"> Sweetalert </a>。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><p id="6e72" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是首先让我们看看什么是装饰者。</p><p id="c27b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我第一次被介绍给装修工人时，我想知道我们为什么需要他们。当然，Angular在任何地方都使用“无论什么”符号，但是它们实际上是如何工作的呢？最终它们看起来像黑匣子。当然，人们可以在不理解的情况下用TS / Angular构建应用程序。但是一旦我们挖掘得更深一点，我们就能理解它们是什么，以及使用它们的好处。</p><h2 id="a5e4" class="le lf iq bd lg lh li dn lj lk ll dp lm kj ln lo lp kn lq lr ls kr lt lu lv lw bi translated">什么是装修工？</h2><p id="4b72" class="pw-post-body-paragraph jy jz iq ka b kb lx kd ke kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv ij bi translated">本质上，装饰器只是一个JavaScript函数。好吧，我知道这听起来像一个笑话，但真的！装饰器只是一个允许我们“扩展”代码做更多事情的函数。是的，现在它非常抽象，但是我们很快就会弄清楚。</p><p id="8a39" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们看看typescript中可用的不同类型的装饰器。</p><p id="de51" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有四种主要类型:</p><ul class=""><li id="534f" class="mc md iq ka b kb kc kf kg kj me kn mf kr mg kv mh mi mj mk bi translated">类装饰器，用于给类添加功能，例如<strong class="ka ir">@组件</strong>和<strong class="ka ir"> @NgModule </strong></li><li id="7490" class="mc md iq ka b kb ml kf mm kj mn kn mo kr mp kv mh mi mj mk bi translated">属性装饰器，用于向类内部的属性添加功能，例如<strong class="ka ir"> @Input </strong>和<strong class="ka ir"> @Output </strong></li><li id="b1be" class="mc md iq ka b kb ml kf mm kj mn kn mo kr mp kv mh mi mj mk bi translated">类内方法的方法装饰器，例如<strong class="ka ir"> @HostListener </strong></li><li id="75d4" class="mc md iq ka b kb ml kf mm kj mn kn mo kr mp kv mh mi mj mk bi translated">类构造函数内部参数的参数装饰器，例如<strong class="ka ir"> @Inject </strong></li></ul><p id="2c19" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">每个装饰者都有一个独特的角色。有关不同装饰器类型及其在angular中应用的示例，请查看Angular 中使用的<a class="ae kw" href="https://medium.com/@bilkiss.dulloo/decorators-in-angular-16e20efcd17c" rel="noopener">装饰器。</a></p><p id="f664" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们进入有趣的部分(实际代码)之前，这些是您应该知道的基础知识:)如前所述，我们将创建一个方法装饰器，它将在方法执行之前显示一个sweetalert确认框。</p></div><div class="ab cl kx ky hu kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ij ik il im in"><h2 id="88eb" class="le lf iq bd lg lh li dn lj lk ll dp lm kj ln lo lp kn lq lr ls kr lt lu lv lw bi translated">好了，我们开始吧！</h2><p id="e27f" class="pw-post-body-paragraph jy jz iq ka b kb lx kd ke kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv ij bi translated">如前所述，decorators实际上只是函数，就这么简单，用它们正在装饰的任何东西来调用。方法装饰器将在它所装饰的方法之前被调用，而类装饰器将在要装饰的类之前被调用。</p><p id="9bc1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我假设你已经有一个角度项目，但如果没有，你可以创建一个</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="581e" class="le lf iq mv b gy mz na l nb nc">ng new</span></pre><p id="2b76" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们快速制作一个可以在类中使用的装饰器来进一步演示这一点。我们将要构建的装饰器是一个可确认的装饰器，它会在执行一个方法之前要求确认。我们将使用<a class="ae kw" href="https://sweetalert2.github.io/" rel="noopener ugc nofollow" target="_blank"> SweetAlert 2 </a>作为我们的弹出插件。</p><h2 id="7981" class="le lf iq bd lg lh li dn lj lk ll dp lm kj ln lo lp kn lq lr ls kr lt lu lv lw bi translated"><strong class="ak">安装</strong>:</h2><p id="349b" class="pw-post-body-paragraph jy jz iq ka b kb lx kd ke kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv ij bi translated">要安装sweetalert，我们需要在终端中运行以下命令</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="aa9f" class="le lf iq mv b gy mz na l nb nc">npm install --save sweetalert2</span></pre><p id="f2a2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">安装完成后，在angular中使用sweetalert非常简单。我们需要:</p><ol class=""><li id="4eb1" class="mc md iq ka b kb kc kf kg kj me kn mf kr mg kv nd mi mj mk bi translated">在我们的组件中导入库</li><li id="1e52" class="mc md iq ka b kb ml kf mm kj mn kn mo kr mp kv nd mi mj mk bi translated">调用swal . fire()；显示弹出窗口。</li></ol><p id="da81" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，考虑下面的代码示例:</p><figure class="mq mr ms mt gt jr"><div class="bz fp l di"><div class="ne nf l"/></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated"><strong class="ak">example-swal-component . ts</strong></figcaption></figure><p id="a011" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">(此代码示例仅用于说明目的，项目中不需要此组件)。</p><p id="da76" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上面的例子中，当组件启动时，会出现一个警告框</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nk"><img src="../Images/95ae73cebab0d735588583cc8d8af883.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yhTyHuPa-EDKACJb4Dkrpw.png"/></div></div></figure><p id="6d7e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们已经了解了sweetalert的基本用法，让我们编写一些代码。首先，我们将创建一个组件，这将是我们这次冒险的起点。像往常一样，我们将使用cli。</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="42e9" class="le lf iq mv b gy mz na l nb nc">ng g c item</span></pre><p id="27d2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这将创建以下文件。</p><p id="d1a5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> item.component.ts </strong></p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="1994" class="le lf iq mv b gy mz na l nb nc">import { Component, OnInit } from '@angular/core';</span><span id="97df" class="le lf iq mv b gy nl na l nb nc">@Component({<br/>  selector: 'app-item',<br/>  templateUrl: ‘./item.component.html',<br/>  styleUrls: ['./item.component.scss']<br/>})</span><span id="0c44" class="le lf iq mv b gy nl na l nb nc">export class ItemComponent implements OnInit {</span><span id="8813" class="le lf iq mv b gy nl na l nb nc">constructor() {}</span><span id="0141" class="le lf iq mv b gy nl na l nb nc">ngOnInit(): void {}</span><span id="8958" class="le lf iq mv b gy nl na l nb nc">}</span></pre><p id="d18b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">暂时不要太花哨。我们将向这个组件类添加一个删除方法，它将简单地向浏览器控制台记录一条消息。</p><p id="f24f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> item.component.ts </strong></p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="ca8a" class="le lf iq mv b gy mz na l nb nc">import { Component, OnInit } from '@angular/core';</span><span id="4cd6" class="le lf iq mv b gy nl na l nb nc">@Component({<br/>  selector: 'app-item',<br/>  templateUrl: ‘./item.component.html',<br/>  styleUrls: ['./item.component.scss']<br/>})</span><span id="2f43" class="le lf iq mv b gy nl na l nb nc">export class ItemComponent implements OnInit {</span><span id="dc21" class="le lf iq mv b gy nl na l nb nc"> constructor() {}</span><span id="0d42" class="le lf iq mv b gy nl na l nb nc"> ngOnInit(): void {}</span><span id="d7b1" class="le lf iq mv b gy nl na l nb nc"> deleteItem(): void {<br/>  console.log(“An item was deleted”);<br/> }</span><span id="bd2b" class="le lf iq mv b gy nl na l nb nc">}</span></pre><p id="8b40" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在组件的标记中，我们将添加一个按钮来触发新创建的方法。</p><p id="eb7c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">item.component.html</strong></p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="176b" class="le lf iq mv b gy mz na l nb nc">&lt;button (click)=”deleteItem()”&gt;Delete item&lt;/button&gt;</span></pre><p id="8f6f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们加载组件并单击按钮，控制台确实会记录消息。到目前为止一切顺利，但是如果我们想让用户确认这个操作而不是直接运行这个方法呢？</p><p id="1316" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一种选择是在deleteItem方法本身中调用sweetalert，这也可以，但是如果我们希望这是一个可重用的逻辑，这样我们就不需要在每次有需要用户确认的功能时都复制/粘贴它，该怎么办呢？我知道你在等它，这就是我们的室内设计师要来的地方！</p><p id="f151" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，在下一步中，我们将在app目录中创建一个名为“decorators”的文件夹，并在其中添加一个名为<code class="fe nm nn no mv b"><em class="np">confirmable.decorator.ts</em></code>的新的空白typescript文件。</p><p id="f029" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在该文件中，我们要做的第一件事是导入sweetalert。</p><p id="8f03" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">confirm able . decorator . ts</strong></p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="0ddd" class="le lf iq mv b gy mz na l nb nc">import Swal from 'sweetalert2';</span></pre><p id="ad49" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，还记得我们说过装饰者是简单的TS函数吗？对于方法装饰者来说，这些函数的签名如下所示:</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="6eda" class="le lf iq mv b gy mz na l nb nc">function confirmable(target: Object, propertyKey: string, descriptor: PropertyDescriptor)</span></pre><p id="9e34" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">其中“target”表示包含我们正在修饰的方法的类，“propertyKey”表示方法名，“descriptor”将包含方法实现。在decorator函数中，我们能够在方法执行之前/之后做一些事情，或者根据任意条件完全跳过执行。例如</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="d8d9" class="le lf iq mv b gy mz na l nb nc">function decorator(target: Object, propertyKey: string, descriptor: PropertyDescriptor){</span><span id="097b" class="le lf iq mv b gy nl na l nb nc"> // we first cache the original method implementation<br/> const originalMethod = descriptor.value;</span><span id="ae47" class="le lf iq mv b gy nl na l nb nc"> // then we overwrite it with a new implementation,<br/> // ...args represent the original arguments</span><span id="3a75" class="le lf iq mv b gy nl na l nb nc"> descriptor.value = function (...args) {</span><span id="5c59" class="le lf iq mv b gy nl na l nb nc">  // do custom logic before executing the original method<br/>  // execute original method with the original arguments<br/>  const result = originalMethod.apply(this, args);</span><span id="18c9" class="le lf iq mv b gy nl na l nb nc">   // execute custom logic after executing the original method<br/>   return result;<br/>  }</span><span id="799c" class="le lf iq mv b gy nl na l nb nc"> };</span><span id="b7ff" class="le lf iq mv b gy nl na l nb nc"> return descriptor;</span><span id="136b" class="le lf iq mv b gy nl na l nb nc">};</span></pre><p id="7b3e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如我们在上面的方法中看到的，使用decorators，我们可以将逻辑注入到被修饰的方法中。然后，可以通过在我们的component.ts中导入函数来使用这个装饰器，并将其添加到我们的方法定义中，如下所示</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="ccc8" class="le lf iq mv b gy mz na l nb nc">@decorator<br/>myDecoratedMethod(){.....}</span></pre><p id="247f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有道理？现在让我们在我们的可确认装饰器上真正尝试一下:)</p><p id="3883" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> confirmable.decorator.ts </strong></p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="ca98" class="le lf iq mv b gy mz na l nb nc">import Swal, {SweetAlertOptions} from 'sweetalert2';</span><span id="c007" class="le lf iq mv b gy nl na l nb nc">export function Confirmable (target: Object, propertyKey: string, descriptor: PropertyDescriptor) {</span><span id="dfc6" class="le lf iq mv b gy nl na l nb nc"> // Again, cache the original method for later use<br/> const originalMethod = descriptor.value;</span><span id="2469" class="le lf iq mv b gy nl na l nb nc"> // the configuration object for sweetalert<br/> const config: SweetAlertOptions = {<br/>  title: 'Are you sure?',<br/>  html: 'Do you want to perform this action?',<br/>  showDenyButton: true,<br/>  confirmButtonText: 'Yes',<br/>  denyButtonText: 'No',<br/>  icon: 'question'<br/> };</span><span id="1940" class="le lf iq mv b gy nl na l nb nc"> // we write a new implementation for the method<br/> descriptor.value = async function (...args) {</span><span id="3c9f" class="le lf iq mv b gy nl na l nb nc">   const res = await Swal.fire(config);  <br/>   // fire sweetalert with the config object</span><span id="0768" class="le lf iq mv b gy nl na l nb nc">   if (res.isConfirmed){ // if user clicked yes,</span><span id="3653" class="le lf iq mv b gy nl na l nb nc">   // we run the original method with the original arguments<br/>   const result = originalMethod.apply(this, args);<br/>  <br/>   // and return the result<br/>   return result;<br/>  }<br/> };</span><span id="c190" class="le lf iq mv b gy nl na l nb nc"> return descriptor;<br/> };</span><span id="f09e" class="le lf iq mv b gy nl na l nb nc">}</span></pre><p id="20e6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以现在，任何用我们的decorator修饰的方法都会要求确认，只有当用户点击“是”时才会执行。我们现在将在项目组件中实现它。</p><p id="e95a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">项目编号</strong></p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="bb72" class="le lf iq mv b gy mz na l nb nc">import { Component, OnInit } from '@angular/core';<br/>import { Confirmable } from '../decorators/confirmable.decorator';</span><span id="046e" class="le lf iq mv b gy nl na l nb nc">@Component({<br/> selector: 'app-item',<br/> templateUrl: ‘./item.component.html',<br/> styleUrls: ['./item.component.scss']<br/>})</span><span id="645d" class="le lf iq mv b gy nl na l nb nc">export class ItemComponent implements OnInit {</span><span id="9adb" class="le lf iq mv b gy nl na l nb nc"> constructor() {}</span><span id="635f" class="le lf iq mv b gy nl na l nb nc"> ngOnInit(): void {}</span><span id="56d8" class="le lf iq mv b gy nl na l nb nc"> @Confirmable<br/> deleteItem(): void {<br/>   //Code to delete your item<br/> }</span><span id="a730" class="le lf iq mv b gy nl na l nb nc">}</span></pre><p id="5b28" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">【item.component.html T4】</p><pre class="mq mr ms mt gt mu mv mw mx aw my bi"><span id="2d4b" class="le lf iq mv b gy mz na l nb nc">&lt;button (click)=”deleteItem()”&gt;Delete item&lt;/button&gt;</span></pre><p id="dcef" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们开始吧。现在，当单击按钮时，我们的装饰器将触发请求确认，只有当用户单击“是”时，我们的<strong class="ka ir"> deleteItem </strong>方法才会执行。</p><h2 id="e72e" class="le lf iq bd lg lh li dn lj lk ll dp lm kj ln lo lp kn lq lr ls kr lt lu lv lw bi translated"><strong class="ak">向装饰器传递数据</strong></h2><p id="7654" class="pw-post-body-paragraph jy jz iq ka b kb lx kd ke kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv ij bi translated">我们之前的解决方案肯定有效，但在我看来，我们的实现中有一个小缺陷，这使得它有点不灵活:使用这个装饰器，确认标题和消息被硬编码在装饰器逻辑中，因此我们将在整个应用程序中为每个确认框提供相同的消息。虽然在某些用例中这可能是可以接受的，但绝对不总是这样！</p><p id="4b35" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">解决这个问题的方法是使用装饰工厂。我们不是让decorator ts文件直接导出decorator函数，而是导出一个可调用的函数，它将返回我们的decorator函数。这里的细微差别是，我们的可调用工厂函数将能够接受参数，这些参数可用于进一步定制我们的装饰器的行为。</p><p id="4c67" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这听起来有点抽象，所以让我们再来看看代码:)</p><figure class="mq mr ms mt gt jr"><div class="bz fp l di"><div class="ne nf l"/></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated"><strong class="ak">confirmable . decorator . ts</strong></figcaption></figure><p id="5bb5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了使用这个新版本的装饰器，我们现在必须更新组件代码，以反映这样一个事实，即“Confirmable”现在是一个返回我们的装饰器的可调用函数，而不是装饰器本身。</p><figure class="mq mr ms mt gt jr"><div class="bz fp l di"><div class="ne nf l"/></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk translated"><strong class="ak">item.component.html&amp;item . component . ts</strong></figcaption></figure><p id="bd13" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们可以从@Confirmable()调用本身传递不同的键。这里需要注意的几件事是:</p><ul class=""><li id="6ec0" class="mc md iq ka b kb kc kf kg kj me kn mf kr mg kv mh mi mj mk bi translated">options参数是可选的。因此,@ Confirmable()也同样适用。</li><li id="7207" class="mc md iq ka b kb ml kf mm kj mn kn mo kr mp kv mh mi mj mk bi translated">由于我们将选项的类型设置为“SweetAlertOptions”，typescript和您的编辑器将开始工作，您应该可以自动完成选项对象的可用属性:)</li></ul><p id="fab7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">同样，运行代码并单击删除按钮将显示我们的sweetalert确认框:)</p><figure class="mq mr ms mt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nq"><img src="../Images/86da27d1dca8a140fb13c5afa229ea85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eeqNWAO8zk5xfSzzEOlbmg.png"/></div></div></figure><p id="65ff" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，每当我们需要得到用户对某个动作的确认时，我们只需导入我们的可确认装饰器，并将其应用到我们需要确认的方法上。</p><p id="7edd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这只是一个使用decorators可以实现什么的例子。目标是提取出可重用的功能，然后只需导入即可使用。</p><p id="c566" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意安全，坚持学习:)</p></div></div>    
</body>
</html>