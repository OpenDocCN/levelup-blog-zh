<html>
<head>
<title>How to Use React Hooks to Monitor Events in Your App</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用React钩子来监控应用程序中的事件</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/how-to-use-react-hooks-to-monitor-events-in-your-app-cd404042df6?source=collection_archive---------16-----------------------#2021-01-19">https://levelup.gitconnected.com/how-to-use-react-hooks-to-monitor-events-in-your-app-cd404042df6?source=collection_archive---------16-----------------------#2021-01-19</a></blockquote><div><div class="fc ih ii ij ik il"/><div class="im in io ip iq"><div class=""/><p id="2638" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">React 中钩子的引入是一个游戏改变者。开发人员现在可以选择创建有状态的组件。过去，如果你有一个有状态的组件，你必须使用一个类组件，如果你有一个表示组件，你可以在类或函数组件之间选择。现在，通过钩子，可以在函数组件内部管理状态。但这并不是Hooks为React开发者所做的全部。</p><p id="c29b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Hooks引入了一种更好的重用有状态函数的方法。今天，我们将探索如何构建一个自定义的React钩子，它将允许我们在应用程序中监控事件。这些事件可以是错误、消息、功能使用、日志或任何您想要的东西。有很多错误监控服务，但是我们将利用<a class="ae ko" href="https://exceptionless.com/" rel="noopener ugc nofollow" target="_blank"> Exceptionless </a>，原因有三:</p><ol class=""><li id="e07c" class="kp kq it js b jt ju jx jy kb kr kf ks kj kt kn ku kv kw kx bi translated">实时更新</li><li id="4eef" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ku kv kw kx bi translated">这是开源的</li><li id="7e5f" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ku kv kw kx bi translated">无异常的JavaScript客户端给了我们一个单例选项(这在本文中是一个很好的例子)</li></ol><p id="710c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们从启动一个新的React项目开始。您需要在您的机器上安装以下设备:</p><ul class=""><li id="c300" class="kp kq it js b jt ju jx jy kb kr kf ks kj kt kn ld kv kw kx bi translated">节点&gt; = 8.10</li><li id="0ece" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ld kv kw kx bi translated">npm &gt;= 5.6</li><li id="3447" class="kp kq it js b jt ky jx kz kb la kf lb kj lc kn ld kv kw kx bi translated">文字编辑器</li></ul><p id="c550" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">假设你已经准备好了，打开一个终端。要创建新的React项目，只需运行:</p><p id="5a1e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe le lf lg lh b">npx create-react-app Monitoring-App</code></p><p id="2842" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">将<code class="fe le lf lg lh b">Monitoring-App</code>替换为您喜欢的项目名称。当一切都完成后，进入你的新应用程序的目录(<code class="fe le lf lg lh b">cd Monitoring-App</code>)。现在，我们需要安装无异常的JavaScript客户端。</p><p id="8fb2" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">为此，只需运行:</p><p id="7953" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe le lf lg lh b">npm install exceptionless</code></p><p id="9a34" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">安装完成后，启动你的应用程序(<code class="fe le lf lg lh b">npm start</code>)，在你选择的文本编辑器中打开你的项目目录。</p><h2 id="2a9e" class="li lj it bd lk ll lm dn ln lo lp dp lq kb lr ls lt kf lu lv lw kj lx ly lz ma bi translated">什么是钩子？</h2><p id="b744" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">React的文档对钩子有最简单的定义，我认为值得在这里提出来:</p><blockquote class="mg mh mi"><p id="a9f4" class="jq jr mj js b jt ju jv jw jx jy jz ka mk kc kd ke ml kg kh ki mm kk kl km kn im bi translated"><em class="it">钩子是React 16.8中的新增功能。它们允许您使用状态和其他React特性，而无需编写类。</em></p></blockquote><p id="5411" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">总的来说，JavaScript中的类的流行程度有了很大的波动。然而，在React生态系统中，这是创建实际上可以做任何事情的组件的唯一选择。因为许多JavaScript开发人员不喜欢也不想使用类，所以选择编写函数组件是一个巨大的进步。但是在开发人员的偏好之外，React挂钩开辟了在React应用中编写代码的新途径，并有望帮助您在这个过程中减少代码占用。</p><p id="e3d9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Hooks还引入了一种新的方式来处理React中的生命周期事件。<code class="fe le lf lg lh b">componentDidMount</code>和<code class="fe le lf lg lh b">componentDidUpdate</code>方法已经不存在了。在是简单而优雅的<code class="fe le lf lg lh b">useEffect</code>功能。</p><p id="8654" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你可以在这里阅读更多关于React引入钩子<a class="ae ko" href="https://reactjs.org/docs/hooks-intro.html" rel="noopener ugc nofollow" target="_blank">背后的逻辑，但是对于本教程来说，我认为这已经足够了。</a></p><h1 id="7fb6" class="mn lj it bd lk mo mp mq ln mr ms mt lq mu mv mw lt mx my mz lw na nb nc lz nd bi translated">创造了我们的第一个钩子</h1><p id="53f7" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">钩子只是一个返回值的函数。然而，钩子的一个大问题是，它们只能在函数组件的主体中被调用。随着我们的进步，请记住这一点。它仍然处于钩子生命的相对早期，但是已经有了一些标准和约定。惯例是将您的定制钩子放在一个叫做<code class="fe le lf lg lh b">hooks</code>的文件夹中。就这么办吧。</p><p id="c32d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在项目的<code class="fe le lf lg lh b">src</code>目录下创建一个名为<code class="fe le lf lg lh b">hooks</code>的文件夹。在该文件夹中，我们将使用React Hooks社区中的另一种约定创建一个文件。开发人员通常会用一个<code class="fe le lf lg lh b">useFunctionPurpose</code>类型的模式来命名他们的钩子。例如，如果你正在构建一个钩子来决定一个导航栏是否应该出现，你可以将这个钩子文件命名为<code class="fe le lf lg lh b">useNavigation</code>。对我们来说，我们将把我们的文件称为<code class="fe le lf lg lh b">useMonitoring</code>。</p><p id="f8a9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在<code class="fe le lf lg lh b">hooks</code>目录中创建文件，然后我们可以开始构建函数。我们将逐行进行，然后我将在一个片段中显示整个文件。让我们从从React导入必要的函数开始。</p><p id="57ad" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe le lf lg lh b">import { useState, useEffect } from 'react';</code></p><p id="9095" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我简单谈了一下<code class="fe le lf lg lh b">useEffect</code>。可以在与<code class="fe le lf lg lh b">componentDidMount</code>或<code class="fe le lf lg lh b">componentDidUpdate</code>相同的上下文中考虑。我们将利用这一点来处理无例外客户机设置中的一些逻辑。<code class="fe le lf lg lh b">useState</code>可以被认为类似于React类组件中的<code class="fe le lf lg lh b">this.state</code>和<code class="fe le lf lg lh b">this.setState</code>。</p><p id="1faa" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们将像这样访问无异常的JavaScript客户机:</p><p id="10f8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe le lf lg lh b">import { ExceptionlessClient } from "exceptionless/dist/exceptionless";</code></p><p id="58d9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">注意:引用<code class="fe le lf lg lh b">/dist/exceptionless</code>文件很重要，因为Exceptionless针对多个环境，我们希望确保导入正确的环境。</p><p id="df4d" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来我们要处理我之前提到的一些东西。Exceptionless是一个基于类的客户端。这意味着我们可以选择在每次使用该类时实例化它，或者我们可以使用Exceptionless提供给我们的singleton。我们首先设置单例模式，然后我们将使用一些逻辑来处理可能不需要使用单例的情况。像这样毫无例外地抓住<code class="fe le lf lg lh b">default</code>客户端:</p><p id="bd35" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe le lf lg lh b">const defaultClient = ExceptionlessClient.default;</code></p><p id="2055" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您还没有这样做，请从Exceptionless为自己获取一个API密钥。你可以在这里注册一个免费账户。一旦你有了它，我们将把这个密钥提供给默认的无异常客户端。我喜欢利用环境变量，即使在浏览器中使用安全的键也是如此。所以我的看起来像这样:</p><p id="02da" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe le lf lg lh b">defaultClient.config.apiKey = process.env.REACT_APP_EXCEPTIONLESS_API_KEY;</code></p><p id="77a8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在我们已经处理了所有的导入和初始配置，我们可以构建钩子函数了。基本功能如下所示:</p><pre class="ne nf ng nh gt ni lh nj nk aw nl bi"><span id="18b0" class="li lj it lh b gy nm nn l no np">export const useMonitoring = ({ config, useDefault }) =&gt; {<br/>  <em class="mj">// Code goes here</em><br/>}</span></pre><p id="4490" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这看起来没什么，但有两件事我想说出来。函数名遵循我之前说的约定，这个函数取两个道具:<code class="fe le lf lg lh b">config</code>和<code class="fe le lf lg lh b">useDefault</code>。如果我们使用无异常客户端的默认单例实例，<code class="fe le lf lg lh b">useDefault</code>将为真，<code class="fe le lf lg lh b">config</code>将为空。然而，如果我们正在创建一个无异常客户端的定制实例，<code class="fe le lf lg lh b">config</code>将是一个对象，而<code class="fe le lf lg lh b">useDefault</code>将是null或false。</p><p id="c5b6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">让我们来处理这个逻辑。在函数的顶部添加以下内容:</p><p id="47d4" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe le lf lg lh b">const [client, setClient] = useState(defaultClient);</code></p><p id="07fe" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们在这里使用内置的<code class="fe le lf lg lh b">useState</code>钩子。我们只是定义了一个<code class="fe le lf lg lh b">client</code>状态变量，定义了一个用于更新该变量的函数(<code class="fe le lf lg lh b">setClient</code>，并为变量设置了一个默认值。如您所见，我们设置了缺省值以使用来自Exceptionless的缺省客户机。有道理，对吧？</p><p id="3696" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">接下来，我们将使用内置的<code class="fe le lf lg lh b">useEffect</code>钩子来确定应该返回哪个客户端，以供请求它的应用程序的特定部分使用。</p><pre class="ne nf ng nh gt ni lh nj nk aw nl bi"><span id="7088" class="li lj it lh b gy nm nn l no np">useEffect(() =&gt; {<br/>    if(useDefault) {<br/>      return client;      <br/>    } else if(config) {<br/>      config.apiKey = process.env.REACT_APP_EXCEPTIONLESS_API_KEY;      <br/>      setClient(new ExceptionlessClient(config));<br/>    } else {<br/>      throw "Please pass useDefault as true or a config object in";<br/>    }<br/>  });</span></pre><p id="593a" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">在这种情况下，最好像看待<code class="fe le lf lg lh b">componentDidUpdate</code>一样看待我们的<code class="fe le lf lg lh b">useEffect</code>函数。对调用我们的<code class="fe le lf lg lh b">useMonitoring</code>钩子的组件的任何更新都会触发我们的<code class="fe le lf lg lh b">useEffect</code>函数中的另一个事件。</p><p id="aa03" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果你想让这个<code class="fe le lf lg lh b">useEffect</code>方法更像<code class="fe le lf lg lh b">componentDidMount</code>那样运行，你应该这样构建它:</p><pre class="ne nf ng nh gt ni lh nj nk aw nl bi"><span id="77c3" class="li lj it lh b gy nm nn l no np">useEffect(() =&gt; {</span><span id="d994" class="li lj it lh b gy nq nn l no np">}, []) <em class="mj">// &lt;-- This array says only run this function once when the component mounts</em></span></pre><p id="81f8" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">上例中的空数组可以用依赖列表来填充。比方说，你想让你的<code class="fe le lf lg lh b">useEffect</code>方法在每次某个特定变量改变时运行，你只需要把那个变量名传入数组。</p><p id="0d8b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">好的，回到我们的<code class="fe le lf lg lh b">useEffect</code>方法。你可以看到我们正在检查我之前提到的<code class="fe le lf lg lh b">useDefault</code>道具。如果是真的，我们返回客户端状态变量。我们已经将该变量设置为使用无singleton异常客户端，所以我们所要做的就是返回它。如果<code class="fe le lf lg lh b">useDefault</code>为假，那么我们检查配置对象。如果存在，我们将apiKey添加到传递给config对象的任何值中，然后实例化一个新的无异常客户端。</p><p id="23e6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果没有提供<code class="fe le lf lg lh b">config</code>对象，我们抛出一个错误。你可以更进一步，检查<code class="fe le lf lg lh b">config</code> prop是否确实是object类型，但是，嘿，这就是Typescript的作用，对吗？我们危险地生活在这个疯狂的动态世界里。</p><p id="e48e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您需要在<code class="fe le lf lg lh b">useMonitoring</code>函数中做的最后一件事是返回客户端。听起来很简单:</p><p id="e5bf" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe le lf lg lh b">return client;</code></p><p id="3165" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">这是完整的文件:</p><pre class="ne nf ng nh gt ni lh nj nk aw nl bi"><span id="b774" class="li lj it lh b gy nm nn l no np">import { useState, useEffect } from 'react';<br/>import { ExceptionlessClient } from "exceptionless/dist/exceptionless";<br/>const defaultClient = ExceptionlessClient.default;<br/>defaultClient.config.apiKey = process.env.REACT_APP_EXCEPTIONLESS_API_KEY;</span><span id="ebda" class="li lj it lh b gy nq nn l no np">export const useMonitoring = ({ config, useDefault }) =&gt; {<br/>  const [client, setClient] = useState(defaultClient);<br/>  useEffect(() =&gt; {<br/>    if(useDefault) {<br/>      return client;      <br/>    } else if(config) {<br/>      config.apiKey = process.env.REACT_APP_EXCEPTIONLESS_API_KEY;      <br/>      setClient(new ExceptionlessClient(config));<br/>    } else {<br/>      throw "Please pass useDefault as true or a config object in";<br/>    }<br/>  });<br/>  return client;<br/>}</span></pre><p id="8ffc" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">准备好用这个坏小子了吗？</p><h1 id="28e0" class="mn lj it bd lk mo mp mq ln mr ms mt lq mu mv mw lt mx my mz lw na nb nc lz nd bi translated">使用您的自定义挂钩</h1><p id="d174" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">我们创建了一个基本的React应用程序，所以让我们只利用开箱即用的东西。打开您的<code class="fe le lf lg lh b">App.js</code>文件，并导入您的新定制钩子。</p><p id="f08c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe le lf lg lh b">import { useMonitoring } from "./hooks/useMonitoring";</code></p><p id="1040" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">您还需要从React导入内置的<code class="fe le lf lg lh b">useEffect</code>钩子:</p><p id="9221" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe le lf lg lh b">import { useEffect } from 'react';</code></p><p id="2e3b" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，在主<code class="fe le lf lg lh b">App</code>函数中，您可以使用新的定制钩子:</p><p id="19e0" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated"><code class="fe le lf lg lh b">const exceptionlessClient = useMonitoring({ useDefault: true });</code></p><p id="d303" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">我们现在如何测试这个？好吧，让我们利用<code class="fe le lf lg lh b">useEffect</code>函数在组件挂载时抛出一个错误。</p><pre class="ne nf ng nh gt ni lh nj nk aw nl bi"><span id="0771" class="li lj it lh b gy nm nn l no np">useEffect(() =&gt; {<br/>  throwException();<br/>}, []);</span></pre><p id="43c1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">正如您所记得的，函数末尾的空数组表示，这只应在组件挂载时运行一次。</p><p id="e39e" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在，像这样定义实际的<code class="fe le lf lg lh b">throwException</code>函数:</p><pre class="ne nf ng nh gt ni lh nj nk aw nl bi"><span id="fe14" class="li lj it lh b gy nm nn l no np">const throwException = () =&gt; {<br/>  try {<br/>    throw new Error("Whoops, it broke"); <br/>  } catch (error) {<br/>    exceptionlessClient.submitException(error);<br/>  }<br/>}</span></pre><p id="e6d9" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">准备好测试了吗？如果你之前启动了React应用，它可能已经工作了。如果您还没有启动该应用程序，现在就开始吧。</p><p id="dc50" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">除了默认的starter React模板之外，你不会看到太多。但是没关系。打开您的无异常仪表板，您应该看到一个异常已经被捕获。</p><figure class="ne nf ng nh gt ns gh gi paragraph-image"><div role="button" tabindex="0" class="nt nu di nv bf nw"><div class="gh gi nr"><img src="../Images/1a7247459b0ed05be7aef05a49bc7fce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*qa_RhK_GUoQhsY9U.png"/></div></div></figure><p id="954c" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您单击该异常，您将获得一系列额外的有用信息。你可以开始看到这是如何有帮助的。</p><p id="290f" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">现在是我提醒你的时候了，我们的定制钩子只能在你的组件函数体内部使用。如果您试图在Redux操作函数中使用您的钩子，您会看到一个错误。美妙之处在于，即使您使用Redux或其他东西，您仍然可以将错误返回给您的组件，并用您的<code class="fe le lf lg lh b">useMonitoring</code>钩子处理错误。</p><p id="0ef6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">但是无例外不仅仅是错误。让我们构建一个快速、更实用的示例。</p><h1 id="4602" class="mn lj it bd lk mo mp mq ln mr ms mt lq mu mv mw lt mx my mz lw na nb nc lz nd bi translated">使用情况跟踪</h1><p id="4b77" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">在你的<code class="fe le lf lg lh b">App.js</code>文件中，我们将删除所有的样板文件并添加一些难看的按钮。这篇文章没有风格。这是您的<code class="fe le lf lg lh b">App.js</code>文件现在应该看起来的样子:</p><pre class="ne nf ng nh gt ni lh nj nk aw nl bi"><span id="4acf" class="li lj it lh b gy nm nn l no np">import { useMonitoring } from "./hooks/useMonitoring";</span><span id="26d0" class="li lj it lh b gy nq nn l no np">function App() {<br/>  const exceptionlessClient = useMonitoring({ useDefault: true });</span><span id="a0f0" class="li lj it lh b gy nq nn l no np">  const handleButtonClick = (planName) =&gt; {<br/>    exceptionlessClient.submitFeatureUsage(planName);<br/>  }<br/>  return (<br/>    &lt;div&gt;<br/>      &lt;button onClick={() =&gt; handleButtonClick("Free")}&gt;Free Plan - Learn More&lt;/button&gt;<br/>      &lt;button onClick={() =&gt; handleButtonClick("Starter")}&gt;Starter Plan - Learn More&lt;/button&gt;<br/>      &lt;button onClick={() =&gt; handleButtonClick("Premium")}&gt;Premium Plan - Learn More&lt;/button&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span><span id="ff77" class="li lj it lh b gy nq nn l no np">export default App;</span></pre><p id="4087" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">你可以看到我们在应用程序中有一个定价页面。有三个按钮，每个计划一个。我们已经连接了一个按钮，该按钮将调用一个函数，该函数最终会向Exceptionless发送一个特性使用事件。继续点击按钮。</p><p id="73f1" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">如果您转到您的无例外仪表板，并单击左侧的功能使用链接，您会看到这些事件已在一个专门的部分捕获，这使您可以轻松地跟踪功能使用情况。这可能不会取代你的分析提供商，但它有很长的路要走。</p><figure class="ne nf ng nh gt ns gh gi paragraph-image"><div role="button" tabindex="0" class="nt nu di nv bf nw"><div class="gh gi nz"><img src="../Images/ee23a35aeaaffb32d32a133ad1b080b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*PJzzCCeUI5M4HVTv.png"/></div></div></figure><h1 id="c99a" class="mn lj it bd lk mo mp mq ln mr ms mt lq mu mv mw lt mx my mz lw na nb nc lz nd bi translated">包扎</h1><p id="471a" class="pw-post-body-paragraph jq jr it js b jt mb jv jw jx mc jz ka kb md kd ke kf me kh ki kj mf kl km kn im bi translated">你可以用Exceptionless做更多的事情。例如，你可能已经注意到了，我们只把<code class="fe le lf lg lh b">useDefault</code>道具传递给了我们的定制钩子。您可以完全定制您的无例外配置，并传入一个<code class="fe le lf lg lh b">config</code>道具来代替。我鼓励你<a class="ae ko" href="https://exceptionless.com/docs/clients/javascript/client-configuration/" rel="noopener ugc nofollow" target="_blank">阅读这里的选项</a>。</p><p id="3df6" class="pw-post-body-paragraph jq jr it js b jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn im bi translated">Exceptionless <a class="ae ko" href="https://exceptionless.com/docs/clients/javascript/sending-events/" rel="noopener ugc nofollow" target="_blank">提供了大量内置于其JavaScript客户端的方法</a>，这将使调试、日志记录和跟踪更加容易。</p></div></div>    
</body>
</html>