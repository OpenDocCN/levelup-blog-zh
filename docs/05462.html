<html>
<head>
<title>Efficient Permutations In Lexicographic Order</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">词典顺序的有效置换</h1>
<blockquote>原文：<a href="https://levelup.gitconnected.com/efficient-permutations-in-lexicographic-order-8e004f94b4b8?source=collection_archive---------10-----------------------#2020-08-31">https://levelup.gitconnected.com/efficient-permutations-in-lexicographic-order-8e004f94b4b8?source=collection_archive---------10-----------------------#2020-08-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/9190e6f753435b11f65c2c76c55cea50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*k0ghZwS3FuHTwrsl"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk translated">照片由Olav Ahrens rtne在Unsplash上拍摄</figcaption></figure><p id="8613" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在这篇文章中，我想向你展示一种生成集合排序排列的方法。我们将着重于按字典顺序或数字顺序生成这些排列。有几种方法可以做到这一点，但就效率而言，有些方法比其他方法更好。</p><p id="9700" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们还将研究一种方法，在我们按字典顺序排列的序列中的任意位置获得一个排列。用这种方法，我们可以更直接地生成我们正在寻找的排列。我们不需要在目标序列之前生成任何先前的排列。</p><p id="de93" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">让我们先回忆一下什么是排列。</p><h1 id="c32f" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">什么是排列？</h1><p id="79cb" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">从<a class="ae md" href="https://en.wikipedia.org/wiki/Combinatorics" rel="noopener ugc nofollow" target="_blank">组合学</a>来看，排列——也称为“顺序”——是一个集合中元素重新排列的数量。一组<em class="me"> n </em>元素的排列数由<em class="me"> n给出！</em> (n阶乘)。比如集合<em class="me"> {1，2，3} </em>中有<em class="me"> 3个！= 3x2x1 = 6 </em>排列:<em class="me"> {1，2，3}、{1，3，2}、{2，1，3}、{2，3，1}、{3，1，2}和{3，2，1} </em>。</p><p id="1ebe" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">从一组<em class="me"> n </em>元素中重新排列第<em class="me"> k </em>元素的<strong class="ke ir">子集</strong>的方式的数量由下式给出:</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/1daa1bcb9feb521730733aea33daec1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:124/0*nxslM_-bdnW8JmkL"/></div></figure><p id="0937" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这个公式很容易从我们以前的定义中推导出来。让我们用一个具体的例子来说明这一点。假设我们想从10本书中找出4本书的排列方式。根据上面的公式，我们有:</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/23af0ce9850283d8ac0bd46a43538a19.png" data-original-src="https://miro.medium.com/v2/resize:fit:138/0*trr1742Vfd16-_LF"/></div></figure><p id="3ea5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们可以这样来思考这个问题。在分子中，我们有10本书的排列方式数——也就是<em class="me"> 10！</em>。但是，我们只关心前4种方式。所以，我们把剩下的6种方式——or(<em class="me">10-4)！= 6!</em>:</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/59805be918aa5dc1f03b84dd1844b302.png" data-original-src="https://miro.medium.com/v2/resize:fit:754/0*S9P62qzvVja7Ux19"/></div></figure><p id="4370" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">最后，记住在排列中，我们计算一个集合中所有可能的顺序。</p><h1 id="a700" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">生成排列</h1><p id="c1e8" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">我们可以用不同的方法产生排列。而且，根据我们选择的方法，结果排列的顺序会改变。此外，有些方法会比其他方法更有效。<a class="ae md" href="https://www.cs.princeton.edu/~rs/" rel="noopener ugc nofollow" target="_blank">罗伯特·塞奇威克</a>在他的调查论文<a class="ae md" href="http://homepage.divms.uiowa.edu/~goodman/22m150.dir/2007/Permutation%20Generation%20Methods.pdf" rel="noopener ugc nofollow" target="_blank"> <em class="me">排列生成方法</em> </a>中总结出生成排列最快的算法是<a class="ae md" href="https://en.wikipedia.org/wiki/Heap%27s_algorithm" rel="noopener ugc nofollow" target="_blank"> <em class="me">堆的</em>算法</a>。然而，由此方法产生的重新排列不是按字典顺序排列的。</p><h1 id="d257" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">按字典顺序排列</h1><p id="68d8" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">在我们的例子中，我们希望按字典顺序或数字顺序列出它们。作为一个例子，让我们生成集合<em class="me"> {0 1 2} </em>的排列。我们取最小的数字，<em class="me"> 0 </em>，把它放在前面，然后我们附加上剩余的<em class="me"> 1和2 </em>。这给出了第一个排列{0 1 2}。接下来，保持<em class="me"> 0 </em>在前面，我们重新排列<em class="me"> 1和2 </em> : {0 2 1}。我们重复这个过程，但是现在<em class="me"> 1 </em>在前面。因此，我们得到排列<em class="me"> {1 0 2} </em>和<em class="me"> {1 2 0} </em>。最后，我们用前面的<em class="me"> 2 </em>重复:<em class="me">{ 2 0 1 }</em><em class="me">{ 2 1 0 }</em>。产生的排列列表如下。</p><pre class="mg mh mi mj gt mm mn mo mp aw mq bi"><span id="6e44" class="mr lb iq mn b gy ms mt l mu mv">1. {0 1 2} <br/>2. {0 2 1} <br/>3. {1 0 2} <br/>4. {1 2 0} <br/>5. {2 0 1} <br/>6. {2 1 0}</span></pre><p id="84d2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">请注意，列表是按数字顺序排列的。换句话说，数字的每一个后续排列都比前一个大。</p><p id="518e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在这个例子中，我们只有集合{1 2 3}的6种排列。所以，很容易把它们都列出来。然而，随着集合的大小开始增长，排列的数量增加得更快。请记住，它遵循的是增长率的阶乘——一组大小为<em class="me"> n </em> = <em class="me"> n的排列数！</em>。因此，如果我们想生成集合{0 1 2 3 4 5 6 7 8 9}的排列，我们将得到<em class="me"> 10！= 3，628，800 </em>器械包的重新排列。</p><p id="dcf0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">按字典顺序生成排列的经典算法如下。考虑数字列表<em class="me">s =【1，2，3，4】</em>。请注意，该序列最初是排序的。这是算法所要求的。现在——假设列表的索引是从零开始的——我们进行如下操作:</p><p id="2ff9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">步骤1) </strong>找出最大的索引<em class="me"> i </em>使得<em class="me"> s[i] &lt; s[i + 1] </em>。如果我们找不到这样的索引，这意味着我们处于序列的最后一个排列:</p><p id="806e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">从我们的列表来看，<em class="me"> i = 2 </em>，因为索引2处的数字，<em class="me"> s[2] = 3 </em>小于索引<em class="me"> i + 1 = 3 </em>，<em class="me"> s[3] = 4 </em>，而<em class="me"> i = 2 </em>是满足这个条件的最大索引。</p><p id="d146" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">步骤2) </strong>找出大于<em class="me"> i </em>的最大指数<em class="me"> j </em>，使得<em class="me">s【I】&lt;s【j】</em>:</p><p id="dae0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">查看我们的列表，我们得到<em class="me"> j = 3 </em>。这满足了我们的条件<em class="me"> (s[2] = 3) &lt; (s[3] = 4) </em></p><p id="5935" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">步骤3) </strong>将<em class="me"> s[i] </em>的值与<em class="me"> s[j] </em>的值互换:</p><p id="3b90" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">所以，我们交换两个指数的值。我们的列表变成了:s = [1，2，4，3]</p><p id="4328" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">步骤4) </strong>颠倒从<em class="me"> s[i + 1] </em>到最后一个元素的顺序:</p><p id="10d5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在我们的例子中，<em class="me"> i = 2 </em>。因此，下一个索引<em class="me"> i + 1 = 3 </em>，这是我们列表的最后一个索引，因此它保持不变。我们的下一个排列是<em class="me">s =【1，2，4，3】</em>。</p><p id="719b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们用下一个置换继续这个过程，直到不满足条件<em class="me"> s[i] &lt; s[i + 1] </em>。这将表明我们已经到达了序列的最后一个排列。</p><h1 id="fbce" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">在有序序列中寻找第n个排列</h1><p id="c329" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">上面的方法按顺序生成一组元素的所有排列。这个顺序总是按字典顺序排列的。但是，如果我们想在序列中的任意位置找到按字典顺序排列的排列呢？例如，如果我们想在集合{0 1 2 3 4 5 6 7 8 9}中找到第980，000个排列？如上所述，我们知道这个序列中有<em class="me"> 3，628，800个</em>排列。使用我们之前的算法，在得到第<em class="me"> 980，000个</em>之前，我们必须生成所有之前的<em class="me"> 979，999个</em>排列。</p><p id="d38a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">对于这个任务，我们可以使用<em class="me">阶乘数字系统</em>来帮助我们更有效地找到我们的任意排列。</p><h1 id="2152" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">阶乘数字系统</h1><p id="2b54" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">阶乘数制或<em class="me"> factoradic </em>是一种<a class="ae md" href="https://en.wikipedia.org/wiki/Mixed_radix" rel="noopener ugc nofollow" target="_blank"> <em class="me">混合基数</em> </a>数制。这意味着每个数位的<em class="me">基数</em>或<em class="me">基数</em>随其位置而变化。相比之下，我们更熟悉的数字系统——如十进制或二进制——在每个位置上所有数字的基数都是固定的。</p><p id="efef" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">下表说明了阶乘数字系统。</p><figure class="mg mh mi mj gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/537bba278604ba3bd307b1023df51524.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hAjVv_AP9woLpJy10R-ndA.png"/></div></div></figure><p id="e21f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">要将一个值从十进制转换为因式，我们只需将该值除以基数——从1、2、3开始……在连续的除法中，我们跟踪余数——直到除法结果为<em class="me"> 0 </em>。每个除法的余数将对应于该位置的因数位数，从右到左。例如，要将<em class="me"> 256 </em>(十进制)转换为阶乘数表示:</p><pre class="mg mh mi mj gt mm mn mo mp aw mq bi"><span id="5f74" class="mr lb iq mn b gy ms mt l mu mv">256 / 1 = 256, remainder 0 <br/>256 / 2 = 128, remainder 0 <br/>128 / 3 =  42, remainder 2 <br/> 42 / 4 =  10, remainder 2 <br/> 10 / 5 =   2, remainder 0 <br/>  2 / 6 =   0, remainder 2</span></pre><p id="5090" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">排列余数——从底部开始向上——我们得到工厂编号:<em class="me"> 202200 </em>。作为练习，您可以尝试使用上表将其转换回十进制表示。我们只需要将每个位置的数字乘以其对应的<em class="me">位值</em>，然后将它们相加。</p><h1 id="bd33" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">用阶乘数系求第n种排列</h1><p id="9e7a" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">我们现在准备使用阶乘数字系统来帮助我们找到序列中的任意排列。事实证明，这个数字系统和一组按字典顺序排列的排列之间存在联系。这种关系或映射被称为<a class="ae md" href="https://en.wikipedia.org/wiki/Lehmer_code" rel="noopener ugc nofollow" target="_blank"> <em class="me">莱默码</em> </a>。</p><p id="f999" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在，让我们回到我们的问题:在集合<em class="me"> {0 1 2 3 4 5 6 7 8 9} </em>的按字典序排列中，寻找<em class="me">的第980，000个</em>排列。如您所见，集合最初是排序的(按非降序)。这代表集合中最低的排列。请记住，使用这种方法，我们不需要生成所有以前的排列来得到我们正在寻找的排列。</p><p id="7087" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们进行如下。首先，我们将为集合中的所有数字分配一个索引——从<em class="me">0–</em>开始。最初，索引<em class="me"> 0 </em>对应数字<em class="me"> 0 </em>，索引<em class="me"> 1 </em>对应数字<em class="me"> 1 </em>等等，直到索引<em class="me"> 9 </em>对应数字<em class="me"> 9 </em>。此外，我们将从<em class="me"> 0 </em>开始枚举序列中的每个排列。所以，集合的初始排序是排列数<em class="me"> 0 </em>。所以我们现在需要找到<em class="me">(第980000-1)= 979999</em>排列。</p><p id="a083" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在，我们把数字<em class="me"> 979，999 </em>除以<em class="me"> (n -1)！</em>其中<em class="me"> n </em>是集合中元素的数量——在我们的例子中，<em class="me">n = 10–</em>所以我们开始除以<em class="me"> 9！</em>。我们将跟踪余数和整数商:</p><pre class="mg mh mi mj gt mm mn mo mp aw mq bi"><span id="d831" class="mr lb iq mn b gy ms mt l mu mv">Initial set: {0 1 2 3 4 5 6 7 8 9} <br/>979,999 / 9! = 2, remainder 254,239 <br/>permutation 1st digit: 2</span></pre><p id="2af3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这里，整数除法的结果，<em class="me"> 2 </em>，表示与我们的<em class="me"> 979，999</em>排列中的第一个数字相对应的数字在集合中的索引。索引<em class="me"> 2 </em>对应编号<em class="me"> 2 </em>。我们现在从集合中取出这个数，取余数作为我们的新分子，继续下一次迭代，从分母<em class="me"> (n-1)中的<em class="me"> n </em>中减去<em class="me"> 1 </em>！</em>。我们将继续这一过程，直到并包括<em class="me"> (n -1)！= 0!</em>:</p><pre class="mg mh mi mj gt mm mn mo mp aw mq bi"><span id="81b2" class="mr lb iq mn b gy ms mt l mu mv">set: {0 1 3 4 5 6 7 8 9} <br/>254,239 / 8! = 6, remainder 12,319 <br/>permutation 2nd digit: 7 </span><span id="1d9b" class="mr lb iq mn b gy mx mt l mu mv">set: {0 1 3 4 5 6 8 9} <br/>12,319 / 7! = 2, remainder 2,239 <br/>permutation 3rd digit: 3 </span><span id="5007" class="mr lb iq mn b gy mx mt l mu mv">set: {0 1 4 5 6 8 9} <br/>2,239 / 6! = 3, remainder 79 <br/>permutation 4th digit: 5 </span><span id="1309" class="mr lb iq mn b gy mx mt l mu mv">set: {0 1 4 6 8 9} <br/>79 / 5! = 0, remainder 79 <br/>permutation 5th digit: 0 </span><span id="fb99" class="mr lb iq mn b gy mx mt l mu mv">set: {1 4 6 8 9} <br/>79 / 4! = 3, remainder 7 <br/>permutation 6th digit: 8 </span><span id="de72" class="mr lb iq mn b gy mx mt l mu mv">set: {1 4 6 9} <br/>7 / 3! = 1, remainder 1 <br/>permutation 7th digit: 4 </span><span id="6e6f" class="mr lb iq mn b gy mx mt l mu mv">set: {1 6 9} <br/>1 / 2! = 0, remainder 1 <br/>permutation 8th digit: 1 </span><span id="937d" class="mr lb iq mn b gy mx mt l mu mv">set: {6 9} <br/>1 / 1! = 1, remainder 0 <br/>permutation 9th digit: 9 </span><span id="45ed" class="mr lb iq mn b gy mx mt l mu mv">set: {6} <br/>0 / 0! = 0, remainder 0 <br/>permutation 10th digit: 6</span></pre><p id="f8ee" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">把所有的数字放在一起，我们得到:<em class="me"> {2 7 3 5 0 8 4 1 9 6} </em>。这是我们集合按字典顺序排列的第<em class="me">980000个</em>排列。</p><p id="1938" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">注意，上面每个整数除法的结果对应于十进制的<em class="me"> 979，999 </em>的因式数表示中的每个数字。将这些数字放在一起得到<em class="me"> 2623031010 </em>。这是十进制数<em class="me"> 979，999的阶乘数表示:</em></p><pre class="mg mh mi mj gt mm mn mo mp aw mq bi"><span id="872a" class="mr lb iq mn b gy ms mt l mu mv">979,000(decimal) = 2623031010(factoradic)</span></pre><p id="e58a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这说明了阶乘数字系统和字典排列之间的映射。同样，我们可以按照上一节中的过程，将<em class="me"> 979，000–</em>转换为阶乘数表示。然后使用因数位数中的每个数字作为收缩集的索引，就像我们上面做的那样。</p><h1 id="8ec2" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">排列的应用</h1><p id="8f70" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">在本文中，我们从排列的基本定义出发，讨论了生成排列的不同方法。我们特别感兴趣的是按字典顺序生成排列，以及我们如何有效地做到这一点。作为总结，我将简要提及排列在不同领域的一些应用。</p><p id="6e58" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">其中一些应用包括<a class="ae md" href="https://en.wikipedia.org/wiki/Information_theory" rel="noopener ugc nofollow" target="_blank">信息论</a>中的错误检测和纠正算法。置换用于分析计算机科学中的排序算法。它们也用于描述生物学中的RNA序列。并且，它们出现在数学的许多分支中。</p><p id="c57f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">希望这个排列的讨论给你另一个视角，并激发你继续探索这个主题。</p></div><div class="ab cl my mz hu na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ij ik il im in"><p id="6a6e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="me">原载于2020年8月31日https://stemhash.com</em><a class="ae md" href="https://stemhash.com/efficient-permutations-in-lexicographic-order/" rel="noopener ugc nofollow" target="_blank"><em class="me"/></a><em class="me">。</em></p></div></div>    
</body>
</html>